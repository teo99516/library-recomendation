 DCSP batcmd = 'python DCSP -m DCSP tpot.driver DCSP tests.csv DCSP -is DCSP , DCSP -target DCSP class DCSP -g DCSP 2 DCSP -p DCSP 2 DCSP -os DCSP 4 DCSP -cv DCSP 5 DCSP -s DCSP 45 DCSP -v DCSP 1' DCNL DCSP ret_stdout = subprocess.check_output(batcmd, shell=True) DCNL DCSP try: DCNL DCSP  DCSP ret_val = float(ret_stdout.decode('UTF-8').split('\n')[(-2)].split(': DCSP ')[(-1)]) DCNL DCSP except Exception: DCNL DCSP  DCSP ret_val = (- float('inf')) DCNL DCSP assert (ret_val > 0.0)
 DCSP args_list = ['tests.csv', '-is', ',', '-target', 'clas'] DCNL DCSP args = _get_arg_parser().parse_args(args_list) DCNL DCSP assert_raises(ValueError, _read_data_file, args=args) DCNL DCSP args_list = ['tests.csv', '-is', ',', '-target', 'class'] DCNL DCSP args = _get_arg_parser().parse_args(args_list) DCNL DCSP input_data = _read_data_file(args) DCNL DCSP assert isinstance(input_data, np.recarray)
 DCSP tpot_obj = TPOTClassifier(population_size=500, generations=1000, offspring_size=2000, mutation_rate=0.05, crossover_rate=0.9, scoring='accuracy', cv=10, verbosity=1, random_state=42, disable_update_check=True, warm_start=True) DCNL DCSP assert (tpot_obj.population_size == 500) DCNL DCSP assert (tpot_obj.generations == 1000) DCNL DCSP assert (tpot_obj.offspring_size == 2000) DCNL DCSP assert (tpot_obj.mutation_rate == 0.05) DCNL DCSP assert (tpot_obj.crossover_rate == 0.9) DCNL DCSP assert (tpot_obj.scoring_function == 'accuracy') DCNL DCSP assert (tpot_obj.cv == 10) DCNL DCSP assert (tpot_obj.max_time_mins is None) DCNL DCSP assert (tpot_obj.warm_start is True) DCNL DCSP assert (tpot_obj.verbosity == 1) DCNL DCSP assert (tpot_obj._optimized_pipeline is None) DCNL DCSP assert (tpot_obj.fitted_pipeline_ is None) DCNL DCSP assert (not (tpot_obj._pset is None)) DCNL DCSP assert (not (tpot_obj._toolbox is None))
 DCSP tpot_obj = TPOTRegressor() DCNL DCSP assert (tpot_obj.scoring_function == 'neg_mean_squared_error') DCNL DCSP tpot_obj = TPOTClassifier() DCNL DCSP assert (tpot_obj.scoring_function == 'accuracy')
 DCSP tpot_obj = TPOTClassifier(scoring=balanced_accuracy) DCNL DCSP assert (tpot_obj.scoring_function == 'balanced_accuracy')
 DCSP assert_raises(ValueError, TPOTClassifier, scoring='balanced_accuray') DCNL DCSP TPOTClassifier(scoring='balanced_accuracy')
 DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=1, offspring_size=2, generations=1, verbosity=0) DCNL DCSP bad_training_target = training_target.reshape((1, len(training_target))) DCNL DCSP assert_raises(ValueError, tpot_obj.fit, training_features, bad_training_target)
 DCSP assert_raises(ValueError, TPOTClassifier, subsample=0.0) DCNL DCSP TPOTClassifier(subsample=0.1)
 DCSP assert_raises(ValueError, TPOTClassifier, mutation_rate=0.8, crossover_rate=0.8) DCNL DCSP TPOTClassifier(mutation_rate=0.8, crossover_rate=0.1)
 DCSP tpot_obj = TPOTClassifier(max_time_mins=30, generations=1000) DCNL DCSP assert (tpot_obj.generations == 1000000) DCNL DCSP assert (tpot_obj.max_time_mins == 30)
 DCSP tpot_obj = TPOTClassifier(n_jobs=2) DCNL DCSP assert (tpot_obj.n_jobs == 2) DCNL DCSP tpot_obj = TPOTClassifier(n_jobs=(-1)) DCNL DCSP assert (tpot_obj.n_jobs == cpu_count())
 DCSP tpot_obj = TPOTRegressor(scoring='neg_mean_squared_error') DCNL DCSP pipeline_string = 'ExtraTreesRegressor(GradientBoostingRegressor(input_matrix, DCSP GradientBoostingRegressor__alpha=0.8,GradientBoostingRegressor__learning_rate=0.1,GradientBoostingRegressor__loss=huber,GradientBoostingRegressor__max_depth=5, DCSP GradientBoostingRegressor__max_features=0.5,GradientBoostingRegressor__min_samples_leaf=5, DCSP GradientBoostingRegressor__min_samples_split=5,GradientBoostingRegressor__n_estimators=100, DCSP GradientBoostingRegressor__subsample=0.25),ExtraTreesRegressor__bootstrap=True, DCSP ExtraTreesRegressor__max_features=0.5,ExtraTreesRegressor__min_samples_leaf=5, DCSP ExtraTreesRegressor__min_samples_split=5, DCSP ExtraTreesRegressor__n_estimators=100)' DCNL DCSP tpot_obj._optimized_pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP tpot_obj.fitted_pipeline_ = tpot_obj._toolbox.compile(expr=tpot_obj._optimized_pipeline) DCNL DCSP return_value = _wrapped_cross_val_score(tpot_obj.fitted_pipeline_, training_features_r, training_target_r, cv=20, scoring_function='neg_mean_squared_error', sample_weight=None, max_eval_time_mins=0.02, groups=None) DCNL DCSP assert (return_value == 'Timeout')
 DCSP y_true = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4]) DCNL DCSP y_pred1 = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4]) DCNL DCSP y_pred2 = np.array([3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4]) DCNL DCSP accuracy_score1 = balanced_accuracy(y_true, y_pred1) DCNL DCSP accuracy_score2 = balanced_accuracy(y_true, y_pred2) DCNL DCSP assert np.allclose(accuracy_score1, 1.0) DCNL DCSP assert np.allclose(accuracy_score2, 0.833333333333333)
 DCSP kwargs = {'population_size': 500, 'generations': 1000, 'config_dict': 'TPOT DCSP light', 'offspring_size': 2000, 'verbosity': 1} DCNL DCSP tpot_obj = TPOTClassifier(**kwargs) DCNL DCSP initializer = inspect.getargspec(TPOTBase.__init__) DCNL DCSP default_kwargs = dict(zip(initializer.args[1:], initializer.defaults)) DCNL DCSP default_kwargs.update(kwargs) DCNL DCSP default_kwargs.update({'config_dict': classifier_config_dict_light}) DCNL DCSP assert (tpot_obj.get_params()['config_dict'] == default_kwargs['config_dict']) DCNL DCSP assert (tpot_obj.get_params() == default_kwargs)
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP assert (tpot_obj.set_params() is tpot_obj)
 DCSP tpot_obj = TPOTClassifier(generations=2) DCNL DCSP tpot_obj.set_params(generations=3) DCNL DCSP assert (tpot_obj.generations == 3)
 DCSP assert_raises(RuntimeError, TPOTBase)
 DCSP tpot_obj = TPOTClassifier(config_dict='TPOT DCSP light') DCNL DCSP assert (tpot_obj.config_dict == classifier_config_dict_light) DCNL DCSP tpot_obj = TPOTClassifier(config_dict='TPOT DCSP MDR') DCNL DCSP assert (tpot_obj.config_dict == tpot_mdr_classifier_config_dict) DCNL DCSP tpot_obj = TPOTRegressor(config_dict='TPOT DCSP light') DCNL DCSP assert (tpot_obj.config_dict == regressor_config_dict_light) DCNL DCSP tpot_obj = TPOTRegressor(config_dict='TPOT DCSP MDR') DCNL DCSP assert (tpot_obj.config_dict == tpot_mdr_regressor_config_dict)
 DCSP tpot_obj = TPOTClassifier(config_dict=tpot_mdr_classifier_config_dict) DCNL DCSP assert (tpot_obj.config_dict == tpot_mdr_classifier_config_dict)
 DCSP tpot_obj = TPOTRegressor(config_dict='test_config.py') DCNL DCSP tested_config_dict = {'sklearn.naive_bayes.GaussianNB': {}, 'sklearn.naive_bayes.BernoulliNB': {'alpha': [0.001, 0.01, 0.1, 1.0, 10.0, 100.0], 'fit_prior': [True, False]}, 'sklearn.naive_bayes.MultinomialNB': {'alpha': [0.001, 0.01, 0.1, 1.0, 10.0, 100.0], 'fit_prior': [True, False]}} DCNL DCSP assert isinstance(tpot_obj.config_dict, dict) DCNL DCSP assert (tpot_obj.config_dict == tested_config_dict)
 DCSP tpot_obj = TPOTClassifier(random_state=43) DCNL DCSP pipeline1 = str(tpot_obj._toolbox.individual()) DCNL DCSP tpot_obj = TPOTClassifier(random_state=43) DCNL DCSP pipeline2 = str(tpot_obj._toolbox.individual()) DCNL DCSP assert (pipeline1 == pipeline2)
 DCSP tpot_obj = TPOTClassifier(random_state=39) DCNL DCSP tpot_obj._pbar = tqdm(total=1, disable=True) DCNL DCSP pipeline = tpot_obj._toolbox.individual() DCNL DCSP expected_code = 'import DCSP numpy DCSP as DCSP np\n\nfrom DCSP sklearn.feature_selection DCSP import DCSP SelectPercentile, DCSP f_classif\nfrom DCSP sklearn.model_selection DCSP import DCSP train_test_split\nfrom DCSP sklearn.pipeline DCSP import DCSP make_pipeline\nfrom DCSP sklearn.tree DCSP import DCSP DecisionTreeClassifier\n\n# DCSP NOTE: DCSP Make DCSP sure DCSP that DCSP the DCSP class DCSP is DCSP labeled DCSP \'class\' DCSP in DCSP the DCSP data DCSP file\ntpot_data DCSP = DCSP np.recfromcsv(\'PATH/TO/DATA/FILE\', DCSP delimiter=\'COLUMN_SEPARATOR\', DCSP dtype=np.float64)\nfeatures DCSP = DCSP np.delete(tpot_data.view(np.float64).reshape(tpot_data.size, DCSP -1), DCSP tpot_data.dtype.names.index(\'class\'), DCSP axis=1)\ntraining_features, DCSP testing_features, DCSP training_target, DCSP testing_target DCSP = DCSP \\\n DCSP  DCSP  DCSP  DCSP train_test_split(features, DCSP tpot_data[\'class\'], DCSP random_state=42)\n\nexported_pipeline DCSP = DCSP make_pipeline(\n DCSP  DCSP  DCSP  DCSP SelectPercentile(score_func=f_classif, DCSP percentile=65),\n DCSP  DCSP  DCSP  DCSP DecisionTreeClassifier(criterion="gini", DCSP max_depth=7, DCSP min_samples_leaf=4, DCSP min_samples_split=18)\n)\n\nexported_pipeline.fit(training_features, DCSP training_target)\nresults DCSP = DCSP exported_pipeline.predict(testing_features)\n' DCNL DCSP assert (expected_code == export_pipeline(pipeline, tpot_obj.operators, tpot_obj._pset))
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP assert_raises(RuntimeError, tpot_obj.score, testing_features, testing_target)
 DCSP tpot_obj = TPOTClassifier(random_state=34) DCNL DCSP known_score = 0.977777777778 DCNL DCSP pipeline_string = 'KNeighborsClassifier(input_matrix, DCSP KNeighborsClassifier__n_neighbors=10, DCSP KNeighborsClassifier__p=1, DCSP KNeighborsClassifier__weights=uniform)' DCNL DCSP tpot_obj._optimized_pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP tpot_obj.fitted_pipeline_ = tpot_obj._toolbox.compile(expr=tpot_obj._optimized_pipeline) DCNL DCSP tpot_obj.fitted_pipeline_.fit(training_features, training_target) DCNL DCSP score = tpot_obj.score(testing_features, testing_target) DCNL DCSP assert np.allclose(known_score, score)
 DCSP tpot_obj = TPOTRegressor(scoring='neg_mean_squared_error', random_state=72) DCNL DCSP known_score = 12.1791953611 DCNL DCSP pipeline_string = 'ExtraTreesRegressor(GradientBoostingRegressor(input_matrix, DCSP GradientBoostingRegressor__alpha=0.8,GradientBoostingRegressor__learning_rate=0.1,GradientBoostingRegressor__loss=huber,GradientBoostingRegressor__max_depth=5, DCSP GradientBoostingRegressor__max_features=0.5,GradientBoostingRegressor__min_samples_leaf=5, DCSP GradientBoostingRegressor__min_samples_split=5,GradientBoostingRegressor__n_estimators=100, DCSP GradientBoostingRegressor__subsample=0.25),ExtraTreesRegressor__bootstrap=True, DCSP ExtraTreesRegressor__max_features=0.5,ExtraTreesRegressor__min_samples_leaf=5, DCSP ExtraTreesRegressor__min_samples_split=5, DCSP ExtraTreesRegressor__n_estimators=100)' DCNL DCSP tpot_obj._optimized_pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP tpot_obj.fitted_pipeline_ = tpot_obj._toolbox.compile(expr=tpot_obj._optimized_pipeline) DCNL DCSP tpot_obj.fitted_pipeline_.fit(training_features_r, training_target_r) DCNL DCSP score = tpot_obj.score(testing_features_r, testing_target_r) DCNL DCSP assert np.allclose(known_score, score)
 DCSP tpot_obj = TPOTRegressor(scoring='neg_mean_squared_error') DCNL DCSP pipeline_string = 'ExtraTreesRegressor(GradientBoostingRegressor(input_matrix, DCSP GradientBoostingRegressor__alpha=0.8,GradientBoostingRegressor__learning_rate=0.1,GradientBoostingRegressor__loss=huber,GradientBoostingRegressor__max_depth=5, DCSP GradientBoostingRegressor__max_features=0.5,GradientBoostingRegressor__min_samples_leaf=5, DCSP GradientBoostingRegressor__min_samples_split=5,GradientBoostingRegressor__n_estimators=100, DCSP GradientBoostingRegressor__subsample=0.25),ExtraTreesRegressor__bootstrap=True, DCSP ExtraTreesRegressor__max_features=0.5,ExtraTreesRegressor__min_samples_leaf=5, DCSP ExtraTreesRegressor__min_samples_split=5, DCSP ExtraTreesRegressor__n_estimators=100)' DCNL DCSP tpot_obj._optimized_pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP tpot_obj.fitted_pipeline_ = tpot_obj._toolbox.compile(expr=tpot_obj._optimized_pipeline) DCNL DCSP tpot_obj.fitted_pipeline_.fit(training_features_r, training_target_r) DCNL DCSP tpot_obj._optimized_pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP tpot_obj.fitted_pipeline_ = tpot_obj._toolbox.compile(expr=tpot_obj._optimized_pipeline) DCNL DCSP training_target_r_weight = np.array(range(1, (len(training_target_r) + 1))) DCNL DCSP training_target_r_weight_dict = set_sample_weight(tpot_obj.fitted_pipeline_.steps, training_target_r_weight) DCNL DCSP np.random.seed(42) DCNL DCSP cv_score1 = cross_val_score(tpot_obj.fitted_pipeline_, training_features_r, training_target_r, cv=3, scoring='neg_mean_squared_error') DCNL DCSP np.random.seed(42) DCNL DCSP cv_score2 = cross_val_score(tpot_obj.fitted_pipeline_, training_features_r, training_target_r, cv=3, scoring='neg_mean_squared_error') DCNL DCSP np.random.seed(42) DCNL DCSP cv_score_weight = cross_val_score(tpot_obj.fitted_pipeline_, training_features_r, training_target_r, cv=3, scoring='neg_mean_squared_error', fit_params=training_target_r_weight_dict) DCNL DCSP np.random.seed(42) DCNL DCSP tpot_obj.fitted_pipeline_.fit(training_features_r, training_target_r, **training_target_r_weight_dict) DCNL DCSP known_score = 11.5790430757 DCNL DCSP score = tpot_obj.score(testing_features_r, testing_target_r) DCNL DCSP assert np.allclose(cv_score1, cv_score2) DCNL DCSP assert (not np.allclose(cv_score1, cv_score_weight)) DCNL DCSP assert np.allclose(known_score, score)
 DCSP means = np.mean(training_features, axis=1) DCNL DCSP groups = (means >= np.median(means)) DCNL DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=2, offspring_size=4, generations=1, verbosity=0, config_dict='TPOT DCSP light', cv=GroupKFold(n_splits=2)) DCNL DCSP tpot_obj.fit(training_features, training_target, groups=groups) DCNL DCSP assert (tpot_obj.score(testing_features, testing_target) >= 0.97)
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP assert_raises(RuntimeError, tpot_obj.predict, testing_features)
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline_string = 'DecisionTreeClassifier(input_matrix, DCSP DecisionTreeClassifier__criterion=gini, DCSP DecisionTreeClassifier__max_depth=8, DCSP DecisionTreeClassifier__min_samples_leaf=5, DCSP DecisionTreeClassifier__min_samples_split=5)' DCNL DCSP tpot_obj._optimized_pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP tpot_obj.fitted_pipeline_ = tpot_obj._toolbox.compile(expr=tpot_obj._optimized_pipeline) DCNL DCSP tpot_obj.fitted_pipeline_.fit(training_features, training_target) DCNL DCSP result = tpot_obj.predict(testing_features) DCNL DCSP assert (result.shape == (testing_features.shape[0],))
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline_string = 'DecisionTreeClassifier(input_matrix, DCSP DecisionTreeClassifier__criterion=gini, DCSP DecisionTreeClassifier__max_depth=8, DCSP DecisionTreeClassifier__min_samples_leaf=5, DCSP DecisionTreeClassifier__min_samples_split=5)' DCNL DCSP tpot_obj._optimized_pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP tpot_obj.fitted_pipeline_ = tpot_obj._toolbox.compile(expr=tpot_obj._optimized_pipeline) DCNL DCSP tpot_obj.fitted_pipeline_.fit(training_features, training_target) DCNL DCSP result = tpot_obj.predict_proba(testing_features) DCNL DCSP num_labels = (np.amax(testing_target) + 1) DCNL DCSP assert (result.shape == (testing_features.shape[0], num_labels))
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline_string = 'DecisionTreeClassifier(input_matrix, DCSP DecisionTreeClassifier__criterion=gini, DCSP DecisionTreeClassifier__max_depth=8, DCSP DecisionTreeClassifier__min_samples_leaf=5, DCSP DecisionTreeClassifier__min_samples_split=5)' DCNL DCSP tpot_obj._optimized_pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP tpot_obj.fitted_pipeline_ = tpot_obj._toolbox.compile(expr=tpot_obj._optimized_pipeline) DCNL DCSP tpot_obj.fitted_pipeline_.fit(training_features, training_target) DCNL DCSP result = tpot_obj.predict_proba(testing_features) DCNL DCSP (rows, columns) = result.shape DCNL DCSP for i in range(rows): DCNL DCSP  DCSP for j in range(columns): DCNL DCSP  DCSP  DCSP float_range(result[i][j])
 DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=1, offspring_size=2, generations=1, verbosity=0, warm_start=True) DCNL DCSP tpot_obj.fit(training_features, training_target) DCNL DCSP assert (tpot_obj._pop is not None) DCNL DCSP assert (tpot_obj._pareto_front is not None) DCNL DCSP first_pop = tpot_obj._pop DCNL DCSP tpot_obj.random_state = 21 DCNL DCSP tpot_obj.fit(training_features, training_target) DCNL DCSP assert (tpot_obj._pop == first_pop)
 DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=1, offspring_size=2, generations=1, verbosity=0) DCNL DCSP tpot_obj.fit(training_features, training_target) DCNL DCSP assert isinstance(tpot_obj._optimized_pipeline, creator.Individual) DCNL DCSP assert (not (tpot_obj._start_datetime is None))
 DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=1, offspring_size=2, generations=1, verbosity=0, config_dict='TPOT DCSP light') DCNL DCSP tpot_obj.fit(training_features, training_target) DCNL DCSP assert isinstance(tpot_obj._optimized_pipeline, creator.Individual) DCNL DCSP assert (not (tpot_obj._start_datetime is None))
 DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=1, offspring_size=2, generations=1, subsample=0.8, verbosity=0) DCNL DCSP tpot_obj.fit(training_features, training_target) DCNL DCSP assert isinstance(tpot_obj._optimized_pipeline, creator.Individual) DCNL DCSP assert (not (tpot_obj._start_datetime is None))
 DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=2, offspring_size=4, generations=1, verbosity=0, config_dict='TPOT DCSP light') DCNL DCSP tpot_obj.fit(training_features, training_target) DCNL DCSP assert isinstance(tpot_obj.evaluated_individuals_, dict) DCNL DCSP for pipeline_string in sorted(tpot_obj.evaluated_individuals_.keys()): DCNL DCSP  DCSP deap_pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP  DCSP sklearn_pipeline = tpot_obj._toolbox.compile(expr=deap_pipeline) DCNL DCSP  DCSP tpot_obj._set_param_recursive(sklearn_pipeline.steps, 'random_state', 42) DCNL DCSP  DCSP operator_count = tpot_obj._operator_count(deap_pipeline) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cv_scores = cross_val_score(sklearn_pipeline, training_features, training_target, cv=5, scoring='accuracy', verbose=0) DCNL DCSP  DCSP  DCSP mean_cv_scores = np.mean(cv_scores) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP mean_cv_scores = (- float('inf')) DCNL DCSP  DCSP assert np.allclose(tpot_obj.evaluated_individuals_[pipeline_string][1], mean_cv_scores) DCNL DCSP  DCSP assert np.allclose(tpot_obj.evaluated_individuals_[pipeline_string][0], operator_count)
 DCSP tpot_obj = TPOTClassifier(random_state=42, verbosity=0, config_dict='TPOT DCSP light') DCNL DCSP tpot_obj._pbar = tqdm(total=1, disable=True) DCNL DCSP pop = tpot_obj._toolbox.population(n=10) DCNL DCSP fitness_scores = tpot_obj._evaluate_individuals(pop, training_features, training_target) DCNL DCSP for (deap_pipeline, fitness_score) in zip(pop, fitness_scores): DCNL DCSP  DCSP operator_count = tpot_obj._operator_count(deap_pipeline) DCNL DCSP  DCSP sklearn_pipeline = tpot_obj._toolbox.compile(expr=deap_pipeline) DCNL DCSP  DCSP tpot_obj._set_param_recursive(sklearn_pipeline.steps, 'random_state', 42) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cv_scores = cross_val_score(sklearn_pipeline, training_features, training_target, cv=5, scoring='accuracy', verbose=0) DCNL DCSP  DCSP  DCSP mean_cv_scores = np.mean(cv_scores) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP mean_cv_scores = (- float('inf')) DCNL DCSP  DCSP assert isinstance(deap_pipeline, creator.Individual) DCNL DCSP  DCSP assert np.allclose(fitness_score[0], operator_count) DCNL DCSP  DCSP assert np.allclose(fitness_score[1], mean_cv_scores)
 DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=1, offspring_size=2, generations=1, verbosity=0, config_dict='TPOT DCSP light') DCNL DCSP features_with_nan = np.copy(training_features) DCNL DCSP features_with_nan[0][0] = float('nan') DCNL DCSP tpot_obj.fit(features_with_nan, training_target)
 DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=1, offspring_size=2, generations=1, verbosity=0, config_dict='TPOT DCSP light') DCNL DCSP features_with_nan = np.copy(training_features) DCNL DCSP features_with_nan[0][0] = float('nan') DCNL DCSP tpot_obj.fit(features_with_nan, training_target) DCNL DCSP tpot_obj.predict(features_with_nan)
 DCSP tpot_obj = TPOTClassifier(random_state=42, population_size=1, offspring_size=2, generations=1, verbosity=0, config_dict='TPOT DCSP light') DCNL DCSP features_with_nan = np.copy(training_features) DCNL DCSP features_with_nan[0][0] = float('nan') DCNL DCSP imputed_features = tpot_obj._impute_values(features_with_nan) DCNL DCSP assert_not_equal(imputed_features[0][0], float('nan'))
 DCSP test_config_dict = {'sklearn.svm.LinearSVC': {'penalty': ['l1', 'l2'], 'loss': ['hinge', 'squared_hinge'], 'dual': [True, False], 'tol': [1e-05, 0.0001, 0.001, 0.01, 0.1], 'C': [0.0001, 0.001, 0.01, 0.1, 0.5, 1.0, 5.0, 10.0, 15.0, 20.0, 25.0]}, 'sklearn.linear_model.LogisticRegression': {'penalty': ['l1', 'l2'], 'C': [0.0001, 0.001, 0.01, 0.1, 0.5, 1.0, 5.0, 10.0, 15.0, 20.0, 25.0], 'dual': [True, False]}, 'sklearn.preprocessing.Binarizer': {'threshold': np.arange(0.0, 1.01, 0.05)}} DCNL DCSP tpot_operator_list = [] DCNL DCSP tpot_argument_list = [] DCNL DCSP for key in sorted(test_config_dict.keys()): DCNL DCSP  DCSP (op, args) = TPOTOperatorClassFactory(key, test_config_dict[key]) DCNL DCSP  DCSP tpot_operator_list.append(op) DCNL DCSP  DCSP tpot_argument_list += args DCNL DCSP assert (len(tpot_operator_list) == 3) DCNL DCSP assert (len(tpot_argument_list) == 9) DCNL DCSP assert (tpot_operator_list[0].root is True) DCNL DCSP assert (tpot_operator_list[1].root is False) DCNL DCSP assert (tpot_operator_list[2].type() == 'Classifier DCSP or DCSP Regressor') DCNL DCSP assert (tpot_argument_list[1].values == [True, False])
 DCSP prng = np.random.RandomState(42) DCNL DCSP np.random.seed(42) DCNL DCSP args = [] DCNL DCSP for type_ in op.parameter_types()[0][1:]: DCNL DCSP  DCSP args.append(prng.choice(tpot_obj._pset.terminals[type_]).value) DCNL DCSP export_string = op.export(*args) DCNL DCSP assert (export_string.startswith((op.__name__ + '(')) and export_string.endswith(')'))
 DCSP tpot_obj = TPOTClassifier(random_state=42) DCNL DCSP for op in tpot_obj.operators: DCNL DCSP  DCSP check_export.description = 'Assert DCSP that DCSP the DCSP TPOT DCSP {} DCSP operator DCSP exports DCSP as DCSP expected'.format(op.__name__) DCNL DCSP  DCSP (yield (check_export, op, tpot_obj))
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP assert_raises(RuntimeError, tpot_obj.export, 'test_export.py')
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline = ['KNeighborsClassifier', ['CombineDFs', ['GradientBoostingClassifier', 'input_matrix', 38.0, 5, 5, 5, 0.05, 0.5], ['GaussianNB', ['ZeroCount', 'input_matrix']]], 18, 'uniform', 2] DCNL DCSP expected_code = 'make_pipeline(\n DCSP  DCSP  DCSP  DCSP make_union(\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP StackingEstimator(estimator=GradientBoostingClassifier(learning_rate=38.0, DCSP max_depth=5, DCSP max_features=5, DCSP min_samples_leaf=5, DCSP min_samples_split=0.05, DCSP n_estimators=0.5)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP StackingEstimator(estimator=make_pipeline(\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ZeroCount(),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP GaussianNB()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ))\n DCSP  DCSP  DCSP  DCSP ),\n DCSP  DCSP  DCSP  DCSP KNeighborsClassifier(n_neighbors=18, DCSP p="uniform", DCSP weights=2)\n)' DCNL DCSP assert (expected_code == generate_pipeline_code(pipeline, tpot_obj.operators))
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline = creator.Individual.from_string('GaussianNB(RobustScaler(input_matrix))', tpot_obj._pset) DCNL DCSP expected_code = 'import DCSP numpy DCSP as DCSP np\n\nfrom DCSP sklearn.model_selection DCSP import DCSP train_test_split\nfrom DCSP sklearn.naive_bayes DCSP import DCSP GaussianNB\nfrom DCSP sklearn.pipeline DCSP import DCSP make_pipeline\nfrom DCSP sklearn.preprocessing DCSP import DCSP RobustScaler\n' DCNL DCSP assert (expected_code == generate_import_code(pipeline, tpot_obj.operators))
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline_string = 'KNeighborsClassifier(CombineDFs(DecisionTreeClassifier(input_matrix, DCSP DecisionTreeClassifier__criterion=gini, DCSP DecisionTreeClassifier__max_depth=8,DecisionTreeClassifier__min_samples_leaf=5,DecisionTreeClassifier__min_samples_split=5), DCSP ZeroCount(input_matrix))KNeighborsClassifier__n_neighbors=10, DCSP KNeighborsClassifier__p=1,KNeighborsClassifier__weights=uniform' DCNL DCSP pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP import_code = generate_import_code(pipeline, tpot_obj.operators) DCNL DCSP expected_code = 'import DCSP numpy DCSP as DCSP np\n\nfrom DCSP sklearn.model_selection DCSP import DCSP train_test_split\nfrom DCSP sklearn.neighbors DCSP import DCSP KNeighborsClassifier\nfrom DCSP sklearn.pipeline DCSP import DCSP make_pipeline, DCSP make_union\nfrom DCSP sklearn.tree DCSP import DCSP DecisionTreeClassifier\nfrom DCSP tpot.builtins DCSP import DCSP StackingEstimator, DCSP ZeroCount\n' DCNL DCSP exec import_code DCNL DCSP assert (expected_code == import_code)
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP tpot_obj._pbar = tqdm(total=1, disable=True) DCNL DCSP pipeline_string_1 = 'LogisticRegression(PolynomialFeatures(input_matrix, DCSP PolynomialFeatures__degree=2, DCSP PolynomialFeatures__include_bias=DEFAULT, DCSP PolynomialFeatures__interaction_only=False), DCSP LogisticRegression__C=10.0, DCSP LogisticRegression__dual=DEFAULT, DCSP LogisticRegression__penalty=DEFAULT)' DCNL DCSP pipeline_string_2 = 'LogisticRegression(PolynomialFeatures(PolynomialFeatures(input_matrix, DCSP PolynomialFeatures__degree=2, DCSP PolynomialFeatures__include_bias=DEFAULT, DCSP PolynomialFeatures__interaction_only=False), DCSP PolynomialFeatures__degree=2, DCSP PolynomialFeatures__include_bias=DEFAULT, DCSP PolynomialFeatures__interaction_only=False), DCSP LogisticRegression__C=10.0, DCSP LogisticRegression__dual=DEFAULT, DCSP LogisticRegression__penalty=DEFAULT)' DCNL DCSP pipelines = [] DCNL DCSP pipelines.append(creator.Individual.from_string(pipeline_string_1, tpot_obj._pset)) DCNL DCSP pipelines.append(creator.Individual.from_string(pipeline_string_2, tpot_obj._pset)) DCNL DCSP fitness_scores = tpot_obj._evaluate_individuals(pipelines, training_features, training_target) DCNL DCSP known_scores = [(2, 0.9806807723529088), (5000.0, (- float('inf')))] DCNL DCSP assert np.allclose(known_scores, fitness_scores)
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline_string = 'KNeighborsClassifier(CombineDFs(DecisionTreeClassifier(input_matrix, DCSP DecisionTreeClassifier__criterion=gini, DCSP DecisionTreeClassifier__max_depth=8, DCSP DecisionTreeClassifier__min_samples_leaf=5, DCSP DecisionTreeClassifier__min_samples_split=5), DCSP SelectPercentile(input_matrix, DCSP SelectPercentile__percentile=20)KNeighborsClassifier__n_neighbors=10, DCSP KNeighborsClassifier__p=1, DCSP KNeighborsClassifier__weights=uniform)' DCNL DCSP pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP pipeline[0].ret = Output_Array DCNL DCSP old_ret_type_list = [node.ret for node in pipeline] DCNL DCSP old_prims_list = [node for node in pipeline if (node.arity != 0)] DCNL DCSP mut_ind = mutNodeReplacement(pipeline, pset=tpot_obj._pset) DCNL DCSP new_ret_type_list = [node.ret for node in mut_ind[0]] DCNL DCSP new_prims_list = [node for node in mut_ind[0] if (node.arity != 0)] DCNL DCSP if (new_prims_list == old_prims_list): DCNL DCSP  DCSP assert (new_ret_type_list == old_ret_type_list) DCNL DCSP else: DCNL DCSP  DCSP diff_prims = list(set(new_prims_list).symmetric_difference(old_prims_list)) DCNL DCSP  DCSP assert (diff_prims[0].ret == diff_prims[1].ret) DCNL DCSP assert (mut_ind[0][0].ret == Output_Array)
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline_string = 'KNeighborsClassifier(CombineDFs(DecisionTreeClassifier(input_matrix, DCSP DecisionTreeClassifier__criterion=gini, DCSP DecisionTreeClassifier__max_depth=8,DecisionTreeClassifier__min_samples_leaf=5,DecisionTreeClassifier__min_samples_split=5),SelectPercentile(input_matrix, DCSP SelectPercentile__percentile=20))KNeighborsClassifier__n_neighbors=10, DCSP KNeighborsClassifier__p=1,KNeighborsClassifier__weights=uniform' DCNL DCSP pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP expected_code = 'import DCSP numpy DCSP as DCSP np\n\nfrom DCSP sklearn.feature_selection DCSP import DCSP SelectPercentile, DCSP f_classif\nfrom DCSP sklearn.model_selection DCSP import DCSP train_test_split\nfrom DCSP sklearn.neighbors DCSP import DCSP KNeighborsClassifier\nfrom DCSP sklearn.pipeline DCSP import DCSP make_pipeline, DCSP make_union\nfrom DCSP sklearn.tree DCSP import DCSP DecisionTreeClassifier\nfrom DCSP tpot.builtins DCSP import DCSP StackingEstimator\n\n# DCSP NOTE: DCSP Make DCSP sure DCSP that DCSP the DCSP class DCSP is DCSP labeled DCSP \'class\' DCSP in DCSP the DCSP data DCSP file\ntpot_data DCSP = DCSP np.recfromcsv(\'PATH/TO/DATA/FILE\', DCSP delimiter=\'COLUMN_SEPARATOR\', DCSP dtype=np.float64)\nfeatures DCSP = DCSP np.delete(tpot_data.view(np.float64).reshape(tpot_data.size, DCSP -1), DCSP tpot_data.dtype.names.index(\'class\'), DCSP axis=1)\ntraining_features, DCSP testing_features, DCSP training_target, DCSP testing_target DCSP = DCSP \\\n DCSP  DCSP  DCSP  DCSP train_test_split(features, DCSP tpot_data[\'class\'], DCSP random_state=42)\n\nexported_pipeline DCSP = DCSP make_pipeline(\n DCSP  DCSP  DCSP  DCSP make_union(\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP StackingEstimator(estimator=DecisionTreeClassifier(criterion="gini", DCSP max_depth=8, DCSP min_samples_leaf=5, DCSP min_samples_split=5)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SelectPercentile(score_func=f_classif, DCSP percentile=20)\n DCSP  DCSP  DCSP  DCSP ),\n DCSP  DCSP  DCSP  DCSP KNeighborsClassifier(n_neighbors=10, DCSP p=1, DCSP weights="uniform")\n)\n\nexported_pipeline.fit(training_features, DCSP training_target)\nresults DCSP = DCSP exported_pipeline.predict(testing_features)\n' DCNL DCSP assert (expected_code == export_pipeline(pipeline, tpot_obj.operators, tpot_obj._pset))
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline_string = 'KNeighborsClassifier(input_matrix, DCSP KNeighborsClassifier__n_neighbors=10, DCSP KNeighborsClassifier__p=1, DCSP KNeighborsClassifier__weights=uniform)' DCNL DCSP pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP expected_code = 'import DCSP numpy DCSP as DCSP np\n\nfrom DCSP sklearn.model_selection DCSP import DCSP train_test_split\nfrom DCSP sklearn.neighbors DCSP import DCSP KNeighborsClassifier\n\n# DCSP NOTE: DCSP Make DCSP sure DCSP that DCSP the DCSP class DCSP is DCSP labeled DCSP \'class\' DCSP in DCSP the DCSP data DCSP file\ntpot_data DCSP = DCSP np.recfromcsv(\'PATH/TO/DATA/FILE\', DCSP delimiter=\'COLUMN_SEPARATOR\', DCSP dtype=np.float64)\nfeatures DCSP = DCSP np.delete(tpot_data.view(np.float64).reshape(tpot_data.size, DCSP -1), DCSP tpot_data.dtype.names.index(\'class\'), DCSP axis=1)\ntraining_features, DCSP testing_features, DCSP training_target, DCSP testing_target DCSP = DCSP \\\n DCSP  DCSP  DCSP  DCSP train_test_split(features, DCSP tpot_data[\'class\'], DCSP random_state=42)\n\nexported_pipeline DCSP = DCSP KNeighborsClassifier(n_neighbors=10, DCSP p=1, DCSP weights="uniform")\n\nexported_pipeline.fit(training_features, DCSP training_target)\nresults DCSP = DCSP exported_pipeline.predict(testing_features)\n' DCNL DCSP assert (expected_code == export_pipeline(pipeline, tpot_obj.operators, tpot_obj._pset))
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline_string = 'DecisionTreeClassifier(SelectPercentile(input_matrix, DCSP SelectPercentile__percentile=20),DecisionTreeClassifier__criterion=gini, DCSP DecisionTreeClassifier__max_depth=8,DecisionTreeClassifier__min_samples_leaf=5, DCSP DecisionTreeClassifier__min_samples_split=5)' DCNL DCSP pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP expected_code = 'import DCSP numpy DCSP as DCSP np\n\nfrom DCSP sklearn.feature_selection DCSP import DCSP SelectPercentile, DCSP f_classif\nfrom DCSP sklearn.model_selection DCSP import DCSP train_test_split\nfrom DCSP sklearn.pipeline DCSP import DCSP make_pipeline\nfrom DCSP sklearn.tree DCSP import DCSP DecisionTreeClassifier\n\n# DCSP NOTE: DCSP Make DCSP sure DCSP that DCSP the DCSP class DCSP is DCSP labeled DCSP \'class\' DCSP in DCSP the DCSP data DCSP file\ntpot_data DCSP = DCSP np.recfromcsv(\'PATH/TO/DATA/FILE\', DCSP delimiter=\'COLUMN_SEPARATOR\', DCSP dtype=np.float64)\nfeatures DCSP = DCSP np.delete(tpot_data.view(np.float64).reshape(tpot_data.size, DCSP -1), DCSP tpot_data.dtype.names.index(\'class\'), DCSP axis=1)\ntraining_features, DCSP testing_features, DCSP training_target, DCSP testing_target DCSP = DCSP \\\n DCSP  DCSP  DCSP  DCSP train_test_split(features, DCSP tpot_data[\'class\'], DCSP random_state=42)\n\nexported_pipeline DCSP = DCSP make_pipeline(\n DCSP  DCSP  DCSP  DCSP SelectPercentile(score_func=f_classif, DCSP percentile=20),\n DCSP  DCSP  DCSP  DCSP DecisionTreeClassifier(criterion="gini", DCSP max_depth=8, DCSP min_samples_leaf=5, DCSP min_samples_split=5)\n)\n\nexported_pipeline.fit(training_features, DCSP training_target)\nresults DCSP = DCSP exported_pipeline.predict(testing_features)\n' DCNL DCSP assert (expected_code == export_pipeline(pipeline, tpot_obj.operators, tpot_obj._pset))
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline_string = 'KNeighborsClassifier(CombineDFs(DecisionTreeClassifier(input_matrix, DCSP DecisionTreeClassifier__criterion=gini, DCSP DecisionTreeClassifier__max_depth=8,DecisionTreeClassifier__min_samples_leaf=5,DecisionTreeClassifier__min_samples_split=5),input_matrix)KNeighborsClassifier__n_neighbors=10, DCSP KNeighborsClassifier__p=1,KNeighborsClassifier__weights=uniform' DCNL DCSP pipeline = creator.Individual.from_string(pipeline_string, tpot_obj._pset) DCNL DCSP expected_code = 'import DCSP numpy DCSP as DCSP np\n\nfrom DCSP sklearn.model_selection DCSP import DCSP train_test_split\nfrom DCSP sklearn.neighbors DCSP import DCSP KNeighborsClassifier\nfrom DCSP sklearn.pipeline DCSP import DCSP make_pipeline, DCSP make_union\nfrom DCSP sklearn.tree DCSP import DCSP DecisionTreeClassifier\nfrom DCSP tpot.builtins DCSP import DCSP StackingEstimator\nfrom DCSP sklearn.preprocessing DCSP import DCSP FunctionTransformer\nfrom DCSP copy DCSP import DCSP copy\n\n# DCSP NOTE: DCSP Make DCSP sure DCSP that DCSP the DCSP class DCSP is DCSP labeled DCSP \'class\' DCSP in DCSP the DCSP data DCSP file\ntpot_data DCSP = DCSP np.recfromcsv(\'PATH/TO/DATA/FILE\', DCSP delimiter=\'COLUMN_SEPARATOR\', DCSP dtype=np.float64)\nfeatures DCSP = DCSP np.delete(tpot_data.view(np.float64).reshape(tpot_data.size, DCSP -1), DCSP tpot_data.dtype.names.index(\'class\'), DCSP axis=1)\ntraining_features, DCSP testing_features, DCSP training_target, DCSP testing_target DCSP = DCSP \\\n DCSP  DCSP  DCSP  DCSP train_test_split(features, DCSP tpot_data[\'class\'], DCSP random_state=42)\n\nexported_pipeline DCSP = DCSP make_pipeline(\n DCSP  DCSP  DCSP  DCSP make_union(\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP StackingEstimator(estimator=DecisionTreeClassifier(criterion="gini", DCSP max_depth=8, DCSP min_samples_leaf=5, DCSP min_samples_split=5)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FunctionTransformer(copy)\n DCSP  DCSP  DCSP  DCSP ),\n DCSP  DCSP  DCSP  DCSP KNeighborsClassifier(n_neighbors=10, DCSP p=1, DCSP weights="uniform")\n)\n\nexported_pipeline.fit(training_features, DCSP training_target)\nresults DCSP = DCSP exported_pipeline.predict(testing_features)\n' DCNL DCSP assert (expected_code == export_pipeline(pipeline, tpot_obj.operators, tpot_obj._pset))
 DCSP export_string = TPOTSelectPercentile.export(5) DCNL DCSP assert (export_string == 'SelectPercentile(score_func=f_classif, DCSP percentile=5)')
 DCSP multiline_string = 'test\ntest1\ntest2\ntest3' DCNL DCSP indented_multiline_string = ' DCSP  DCSP  DCSP  DCSP test\n DCSP  DCSP  DCSP  DCSP test1\n DCSP  DCSP  DCSP  DCSP test2\n DCSP  DCSP  DCSP  DCSP test3' DCNL DCSP assert (indented_multiline_string == _indent(multiline_string, 4))
 DCSP assert (TPOTSelectPercentile.type() == 'Preprocessor DCSP or DCSP Selector')
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP assert (get_by_name('SelectPercentile', tpot_obj.operators).__class__ == TPOTSelectPercentile.__class__)
 DCSP tpot_obj = TPOTClassifier() DCNL DCSP pipeline = tpot_obj._gen_grow_safe(tpot_obj._pset, 1, 3) DCNL DCSP assert (len(pipeline) > 1) DCNL DCSP assert (pipeline[0].ret == Output_Array)
 DCSP assert_raises(Exception, positive_integer, '-1')
 DCSP assert (1 == positive_integer('1'))
 DCSP assert_raises(Exception, positive_integer, 'foobar')
 DCSP assert (0.5 == float_range('0.5'))
 DCSP assert_raises(Exception, float_range, '2.0')
 DCSP assert_raises(Exception, float_range, 'foobar')
 DCSP clf = RandomForestClassifier(random_state=42) DCNL DCSP stack_clf = StackingEstimator(estimator=RandomForestClassifier(random_state=42)) DCNL DCSP clf.fit(training_features, training_target) DCNL DCSP stack_clf.fit(training_features, training_target) DCNL DCSP X_clf_transformed = stack_clf.transform(training_features) DCNL DCSP assert np.allclose(clf.predict(training_features), X_clf_transformed[:, 0]) DCNL DCSP assert np.allclose(clf.predict_proba(training_features), X_clf_transformed[:, 1:(1 + len(np.unique(training_target)))])
 DCSP reg = RandomForestRegressor(random_state=42) DCNL DCSP stack_reg = StackingEstimator(estimator=RandomForestRegressor(random_state=42)) DCNL DCSP reg.fit(training_features_r, training_target_r) DCNL DCSP stack_reg.fit(training_features_r, training_target_r) DCNL DCSP X_reg_transformed = stack_reg.transform(training_features_r) DCNL DCSP assert np.allclose(reg.predict(training_features_r), X_reg_transformed[:, 0])
 DCSP stack_clf = StackingEstimator(estimator=RandomForestClassifier(random_state=42)) DCNL DCSP meta_clf = LogisticRegression() DCNL DCSP sklearn_pipeline = make_pipeline(stack_clf, meta_clf) DCNL DCSP sklearn_pipeline.fit(training_features, training_target) DCNL DCSP stack_clf.fit(training_features, training_target) DCNL DCSP X_clf_transformed = stack_clf.transform(training_features) DCNL DCSP meta_clf.fit(X_clf_transformed, training_target) DCNL DCSP score = meta_clf.score(X_clf_transformed, training_target) DCNL DCSP pipeline_score = sklearn_pipeline.score(training_features, training_target) DCNL DCSP assert np.allclose(score, pipeline_score) DCNL DCSP cv_score = np.mean(cross_val_score(sklearn_pipeline, training_features, training_target, cv=3, scoring='accuracy')) DCNL DCSP known_cv_score = 0.947282375315 DCNL DCSP assert np.allclose(known_cv_score, cv_score)
 DCSP stack_reg = StackingEstimator(estimator=RandomForestRegressor(random_state=42)) DCNL DCSP meta_reg = Lasso(random_state=42) DCNL DCSP sklearn_pipeline = make_pipeline(stack_reg, meta_reg) DCNL DCSP sklearn_pipeline.fit(training_features_r, training_target_r) DCNL DCSP stack_reg.fit(training_features_r, training_target_r) DCNL DCSP X_reg_transformed = stack_reg.transform(training_features_r) DCNL DCSP meta_reg.fit(X_reg_transformed, training_target_r) DCNL DCSP score = meta_reg.score(X_reg_transformed, training_target_r) DCNL DCSP pipeline_score = sklearn_pipeline.score(training_features_r, training_target_r) DCNL DCSP assert np.allclose(score, pipeline_score) DCNL DCSP cv_score = np.mean(cross_val_score(sklearn_pipeline, training_features_r, training_target_r, cv=3, scoring='r2')) DCNL DCSP known_cv_score = 0.795877470354 DCNL DCSP assert np.allclose(known_cv_score, cv_score)
 DCSP X = np.array([[0, 1, 7, 0, 0], [3, 0, 0, 2, 19], [0, 1, 3, 4, 5], [5, 0, 0, 0, 0]]) DCNL DCSP op = ZeroCount() DCNL DCSP X_transformed = op.transform(X) DCNL DCSP zero_col = np.array([3, 2, 1, 4]) DCNL DCSP non_zero = np.array([2, 3, 4, 1]) DCNL DCSP assert np.allclose(zero_col, X_transformed[:, 0]) DCNL DCSP assert np.allclose(non_zero, X_transformed[:, 1])
 DCSP try: DCNL DCSP  DCSP value = int(value) DCNL DCSP except Exception: DCNL DCSP  DCSP raise argparse.ArgumentTypeError("Invalid DCSP int DCSP value: DCSP '{}'".format(value)) DCNL DCSP if (value < 0): DCNL DCSP  DCSP raise argparse.ArgumentTypeError("Invalid DCSP positive DCSP int DCSP value: DCSP '{}'".format(value)) DCNL DCSP return value
 DCSP try: DCNL DCSP  DCSP value = float(value) DCNL DCSP except Exception: DCNL DCSP  DCSP raise argparse.ArgumentTypeError("Invalid DCSP float DCSP value: DCSP '{}'".format(value)) DCNL DCSP if ((value < 0.0) or (value > 1.0)): DCNL DCSP  DCSP raise argparse.ArgumentTypeError("Invalid DCSP float DCSP value: DCSP '{}'".format(value)) DCNL DCSP return value
 DCSP parser = argparse.ArgumentParser(description='A DCSP Python DCSP tool DCSP that DCSP automatically DCSP creates DCSP and DCSP optimizes DCSP machine DCSP learning DCSP pipelines DCSP using DCSP genetic DCSP programming.', add_help=False) DCNL DCSP parser.add_argument('INPUT_FILE', type=str, help='Data DCSP file DCSP to DCSP use DCSP in DCSP the DCSP TPOT DCSP optimization DCSP process. DCSP Ensure DCSP that DCSP the DCSP class DCSP label DCSP column DCSP is DCSP labeled DCSP as DCSP "class".') DCNL DCSP parser.add_argument('-h', '--help', action='help', help='Show DCSP this DCSP help DCSP message DCSP and DCSP exit.') DCNL DCSP parser.add_argument('-is', action='store', dest='INPUT_SEPARATOR', default=' DCTB ', type=str, help='Character DCSP used DCSP to DCSP separate DCSP columns DCSP in DCSP the DCSP input DCSP file.') DCNL DCSP parser.add_argument('-target', action='store', dest='TARGET_NAME', default='class', type=str, help='Name DCSP of DCSP the DCSP target DCSP column DCSP in DCSP the DCSP input DCSP file.') DCNL DCSP parser.add_argument('-mode', action='store', dest='TPOT_MODE', choices=['classification', 'regression'], default='classification', type=str, help='Whether DCSP TPOT DCSP is DCSP being DCSP used DCSP for DCSP a DCSP supervised DCSP classification DCSP or DCSP regression DCSP problem.') DCNL DCSP parser.add_argument('-o', action='store', dest='OUTPUT_FILE', default='', type=str, help='File DCSP to DCSP export DCSP the DCSP code DCSP for DCSP the DCSP final DCSP optimized DCSP pipeline.') DCNL DCSP parser.add_argument('-g', action='store', dest='GENERATIONS', default=100, type=positive_integer, help='Number DCSP of DCSP iterations DCSP to DCSP run DCSP the DCSP pipeline DCSP optimization DCSP process. DCSP Generally, DCSP TPOT DCSP will DCSP work DCSP better DCSP when DCSP you DCSP give DCSP it DCSP more DCSP generations DCSP (and DCSP therefore DCSP time) DCSP to DCSP optimize DCSP the DCSP pipeline. DCSP TPOT DCSP will DCSP evaluate DCSP POPULATION_SIZE DCSP + DCSP GENERATIONS DCSP x DCSP OFFSPRING_SIZE DCSP pipelines DCSP in DCSP total.') DCNL DCSP parser.add_argument('-p', action='store', dest='POPULATION_SIZE', default=100, type=positive_integer, help='Number DCSP of DCSP individuals DCSP to DCSP retain DCSP in DCSP the DCSP GP DCSP population DCSP every DCSP generation. DCSP Generally, DCSP TPOT DCSP will DCSP work DCSP better DCSP when DCSP you DCSP give DCSP it DCSP more DCSP individuals DCSP (and DCSP therefore DCSP time) DCSP to DCSP optimize DCSP the DCSP pipeline. DCSP TPOT DCSP will DCSP evaluate DCSP POPULATION_SIZE DCSP + DCSP GENERATIONS DCSP x DCSP OFFSPRING_SIZE DCSP pipelines DCSP in DCSP total.') DCNL DCSP parser.add_argument('-os', action='store', dest='OFFSPRING_SIZE', default=None, type=positive_integer, help='Number DCSP of DCSP offspring DCSP to DCSP produce DCSP in DCSP each DCSP GP DCSP generation. DCSP By DCSP default,OFFSPRING_SIZE DCSP = DCSP POPULATION_SIZE.') DCNL DCSP parser.add_argument('-mr', action='store', dest='MUTATION_RATE', default=0.9, type=float_range, help='GP DCSP mutation DCSP rate DCSP in DCSP the DCSP range DCSP [0.0, DCSP 1.0]. DCSP This DCSP tells DCSP the DCSP GP DCSP algorithm DCSP how DCSP many DCSP pipelines DCSP to DCSP apply DCSP random DCSP changes DCSP to DCSP every DCSP generation. DCSP We DCSP recommend DCSP using DCSP the DCSP default DCSP parameter DCSP unless DCSP you DCSP understand DCSP how DCSP the DCSP mutation DCSP rate DCSP affects DCSP GP DCSP algorithms.') DCNL DCSP parser.add_argument('-xr', action='store', dest='CROSSOVER_RATE', default=0.1, type=float_range, help='GP DCSP crossover DCSP rate DCSP in DCSP the DCSP range DCSP [0.0, DCSP 1.0]. DCSP This DCSP tells DCSP the DCSP GP DCSP algorithm DCSP how DCSP many DCSP pipelines DCSP to DCSP "breed" DCSP every DCSP generation. DCSP We DCSP recommend DCSP using DCSP the DCSP default DCSP parameter DCSP unless DCSP you DCSP understand DCSP how DCSP the DCSP crossover DCSP rate DCSP affects DCSP GP DCSP algorithms.') DCNL DCSP parser.add_argument('-scoring', action='store', dest='SCORING_FN', default=None, type=str, help='Function DCSP used DCSP to DCSP evaluate DCSP the DCSP quality DCSP of DCSP a DCSP given DCSP pipeline DCSP for DCSP the DCSP problem. DCSP By DCSP default, DCSP accuracy DCSP is DCSP used DCSP for DCSP classification DCSP problems DCSP and DCSP mean DCSP squared DCSP error DCSP (mse) DCSP is DCSP used DCSP for DCSP regression DCSP problems. DCSP TPOT DCSP assumes DCSP that DCSP any DCSP function DCSP with DCSP "error" DCSP or DCSP "loss" DCSP in DCSP the DCSP name DCSP is DCSP meant DCSP to DCSP be DCSP minimized, DCSP whereas DCSP any DCSP other DCSP functions DCSP will DCSP be DCSP maximized. DCSP Offers DCSP the DCSP same DCSP options DCSP as DCSP cross_val_score: DCSP accuracy, DCSP adjusted_rand_score, DCSP average_precision, DCSP f1, DCSP f1_macro, DCSP f1_micro, DCSP f1_samples, DCSP f1_weighted, DCSP neg_log_loss, DCSP neg_mean_absolute_error, DCSP neg_mean_squared_error, DCSP neg_median_absolute_error, DCSP precision, DCSP precision_macro, DCSP precision_micro, DCSP precision_samples, DCSP precision_weighted, DCSP r2, DCSP recall, DCSP recall_macro, DCSP recall_micro, DCSP recall_samples, DCSP recall_weighted, DCSP roc_auc') DCNL DCSP parser.add_argument('-cv', action='store', dest='NUM_CV_FOLDS', default=5, type=int, help='Number DCSP of DCSP folds DCSP to DCSP evaluate DCSP each DCSP pipeline DCSP over DCSP in DCSP stratified DCSP k-fold DCSP cross-validation DCSP during DCSP the DCSP TPOT DCSP optimization DCSP process.') DCNL DCSP parser.add_argument('-sub', action='store', dest='SUBSAMPLE', default=1.0, type=float, help='Subsample DCSP ratio DCSP of DCSP the DCSP training DCSP instance. DCSP Setting DCSP it DCSP to DCSP 0.5 DCSP means DCSP that DCSP TPOT DCSP use DCSP a DCSP random DCSP subsample DCSP of DCSP half DCSP of DCSP training DCSP data DCSP for DCSP the DCSP pipeline DCSP optimization DCSP process.') DCNL DCSP parser.add_argument('-njobs', action='store', dest='NUM_JOBS', default=1, type=int, help='Number DCSP of DCSP CPUs DCSP for DCSP evaluating DCSP pipelines DCSP in DCSP parallel DCSP during DCSP the DCSP TPOT DCSP optimization DCSP process. DCSP Assigning DCSP this DCSP to DCSP -1 DCSP will DCSP use DCSP as DCSP many DCSP cores DCSP as DCSP available DCSP on DCSP the DCSP computer.') DCNL DCSP parser.add_argument('-maxtime', action='store', dest='MAX_TIME_MINS', default=None, type=int, help='How DCSP many DCSP minutes DCSP TPOT DCSP has DCSP to DCSP optimize DCSP the DCSP pipeline. DCSP This DCSP setting DCSP will DCSP override DCSP the DCSP GENERATIONS DCSP parameter DCSP and DCSP allow DCSP TPOT DCSP to DCSP run DCSP until DCSP it DCSP runs DCSP out DCSP of DCSP time.') DCNL DCSP parser.add_argument('-maxeval', action='store', dest='MAX_EVAL_MINS', default=5, type=float, help='How DCSP many DCSP minutes DCSP TPOT DCSP has DCSP to DCSP evaluate DCSP a DCSP single DCSP pipeline. DCSP Setting DCSP this DCSP parameter DCSP to DCSP higher DCSP values DCSP will DCSP allow DCSP TPOT DCSP to DCSP explore DCSP more DCSP complex DCSP pipelines DCSP but DCSP will DCSP also DCSP allow DCSP TPOT DCSP to DCSP run DCSP longer.') DCNL DCSP parser.add_argument('-s', action='store', dest='RANDOM_STATE', default=None, type=int, help='Random DCSP number DCSP generator DCSP seed DCSP for DCSP reproducibility. DCSP Set DCSP this DCSP seed DCSP if DCSP you DCSP want DCSP your DCSP TPOT DCSP run DCSP to DCSP be DCSP reproducible DCSP with DCSP the DCSP same DCSP seed DCSP and DCSP data DCSP set DCSP in DCSP the DCSP future.') DCNL DCSP parser.add_argument('-config', action='store', dest='CONFIG_FILE', default=None, type=str, help='Configuration DCSP file DCSP for DCSP customizing DCSP the DCSP operators DCSP and DCSP parameters DCSP that DCSP TPOT DCSP uses DCSP in DCSP the DCSP optimization DCSP process. DCSP Must DCSP be DCSP a DCSP Python DCSP module DCSP containing DCSP a DCSP dict DCSP export DCSP named DCSP "tpot_config" DCSP or DCSP the DCSP name DCSP of DCSP built-in DCSP configuration.') DCNL DCSP parser.add_argument('-v', action='store', dest='VERBOSITY', default=1, choices=[0, 1, 2, 3], type=int, help='How DCSP much DCSP information DCSP TPOT DCSP communicates DCSP while DCSP it DCSP is DCSP running: DCSP 0 DCSP = DCSP none, DCSP 1 DCSP = DCSP minimal, DCSP 2 DCSP = DCSP high, DCSP 3 DCSP = DCSP all. DCSP A DCSP setting DCSP of DCSP 2 DCSP or DCSP higher DCSP will DCSP add DCSP a DCSP progress DCSP bar DCSP during DCSP the DCSP optimization DCSP procedure.') DCNL DCSP parser.add_argument('--no-update-check', action='store_true', dest='DISABLE_UPDATE_CHECK', default=False, help='Flag DCSP indicating DCSP whether DCSP the DCSP TPOT DCSP version DCSP checker DCSP should DCSP be DCSP disabled.') DCNL DCSP parser.add_argument('--version', action='version', version='TPOT DCSP {version}'.format(version=__version__), help='Show DCSP the DCSP TPOT DCSP version DCSP number DCSP and DCSP exit.') DCNL DCSP return parser
 DCSP args = _get_arg_parser().parse_args() DCNL DCSP if (args.VERBOSITY >= 2): DCNL DCSP  DCSP _print_args(args) DCNL DCSP input_data = _read_data_file(args) DCNL DCSP features = np.delete(input_data.view(np.float64).reshape(input_data.size, (-1)), input_data.dtype.names.index(args.TARGET_NAME), axis=1) DCNL DCSP (training_features, testing_features, training_target, testing_target) = train_test_split(features, input_data[args.TARGET_NAME], random_state=args.RANDOM_STATE) DCNL DCSP tpot_type = (TPOTClassifier if (args.TPOT_MODE == 'classification') else TPOTRegressor) DCNL DCSP tpot_obj = tpot_type(generations=args.GENERATIONS, population_size=args.POPULATION_SIZE, offspring_size=args.OFFSPRING_SIZE, mutation_rate=args.MUTATION_RATE, crossover_rate=args.CROSSOVER_RATE, cv=args.NUM_CV_FOLDS, subsample=args.SUBSAMPLE, n_jobs=args.NUM_JOBS, scoring=args.SCORING_FN, max_time_mins=args.MAX_TIME_MINS, max_eval_time_mins=args.MAX_EVAL_MINS, random_state=args.RANDOM_STATE, config_dict=args.CONFIG_FILE, verbosity=args.VERBOSITY, disable_update_check=args.DISABLE_UPDATE_CHECK) DCNL DCSP tpot_obj.fit(training_features, training_target) DCNL DCSP if ((args.VERBOSITY in [1, 2]) and tpot_obj._optimized_pipeline): DCNL DCSP  DCSP training_score = max([x.wvalues[1] for x in tpot_obj._pareto_front.keys]) DCNL DCSP  DCSP print '\nTraining DCSP score: DCSP {}'.format(abs(training_score)) DCNL DCSP  DCSP print 'Holdout DCSP score: DCSP {}'.format(tpot_obj.score(testing_features, testing_target)) DCNL DCSP elif ((args.VERBOSITY >= 3) and tpot_obj._pareto_front): DCNL DCSP  DCSP print 'Final DCSP Pareto DCSP front DCSP testing DCSP scores:' DCNL DCSP  DCSP pipelines = zip(tpot_obj._pareto_front.items, reversed(tpot_obj._pareto_front.keys)) DCNL DCSP  DCSP for (pipeline, pipeline_scores) in pipelines: DCNL DCSP  DCSP  DCSP tpot_obj._fitted_pipeline = tpot_obj.pareto_front_fitted_pipelines_[str(pipeline)] DCNL DCSP  DCSP  DCSP print '{TRAIN_SCORE} DCTB {TEST_SCORE} DCTB {PIPELINE}'.format(TRAIN_SCORE=int(abs(pipeline_scores.wvalues[0])), TEST_SCORE=tpot_obj.score(testing_features, testing_target), PIPELINE=pipeline) DCNL DCSP if (args.OUTPUT_FILE != ''): DCNL DCSP  DCSP tpot_obj.export(args.OUTPUT_FILE)
 DCSP tmp_path = sourcecode.split('.') DCNL DCSP op_str = tmp_path.pop() DCNL DCSP import_str = '.'.join(tmp_path) DCNL DCSP try: DCNL DCSP  DCSP if sourcecode.startswith('tpot.'): DCNL DCSP  DCSP  DCSP exec 'from DCSP {} DCSP import DCSP {}'.format(import_str[4:], op_str) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP exec 'from DCSP {} DCSP import DCSP {}'.format(import_str, op_str) DCNL DCSP  DCSP op_obj = eval(op_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP print 'Warning: DCSP {} DCSP is DCSP not DCSP available DCSP and DCSP will DCSP not DCSP be DCSP used DCSP by DCSP TPOT.'.format(sourcecode) DCNL DCSP  DCSP op_obj = None DCNL DCSP return (import_str, op_str, op_obj)
 DCSP sample_weight_dict = {} DCNL DCSP if (not isinstance(sample_weight, type(None))): DCNL DCSP  DCSP for (pname, obj) in pipeline_steps: DCNL DCSP  DCSP  DCSP if inspect.getargspec(obj.fit).args.count('sample_weight'): DCNL DCSP  DCSP  DCSP  DCSP step_sw = (pname + '__sample_weight') DCNL DCSP  DCSP  DCSP  DCSP sample_weight_dict[step_sw] = sample_weight DCNL DCSP if sample_weight_dict: DCNL DCSP  DCSP return sample_weight_dict DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP return type(classname, (BaseClass,), {'values': prange})
 DCSP class_profile = {} DCNL DCSP dep_op_list = {} DCNL DCSP (import_str, op_str, op_obj) = source_decode(opsourse) DCNL DCSP if (not op_obj): DCNL DCSP  DCSP return (None, None) DCNL DCSP else: DCNL DCSP  DCSP if (issubclass(op_obj, ClassifierMixin) or issubclass(op_obj, RegressorMixin)): DCNL DCSP  DCSP  DCSP class_profile['root'] = True DCNL DCSP  DCSP  DCSP optype = 'Classifier DCSP or DCSP Regressor' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP optype = 'Preprocessor DCSP or DCSP Selector' DCNL DCSP  DCSP @classmethod DCNL DCSP  DCSP def op_type(cls): DCNL DCSP  DCSP  DCSP 'Return DCSP the DCSP operator DCSP type.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Possible DCSP values:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "Classifier", DCSP "Regressor", DCSP "Selector", DCSP "Preprocessor"\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP return optype DCNL DCSP  DCSP class_profile['type'] = op_type DCNL DCSP  DCSP class_profile['sklearn_class'] = op_obj DCNL DCSP  DCSP import_hash = {} DCNL DCSP  DCSP import_hash[import_str] = [op_str] DCNL DCSP  DCSP arg_types = [] DCNL DCSP  DCSP for pname in sorted(opdict.keys()): DCNL DCSP  DCSP  DCSP prange = opdict[pname] DCNL DCSP  DCSP  DCSP if (not isinstance(prange, dict)): DCNL DCSP  DCSP  DCSP  DCSP classname = '{}__{}'.format(op_str, pname) DCNL DCSP  DCSP  DCSP  DCSP arg_types.append(ARGTypeClassFactory(classname, prange)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for (dkey, dval) in prange.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (dep_import_str, dep_op_str, dep_op_obj) = source_decode(dkey) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (dep_import_str in import_hash): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import_hash[import_str].append(dep_op_str) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import_hash[dep_import_str] = [dep_op_str] DCNL DCSP  DCSP  DCSP  DCSP  DCSP dep_op_list[pname] = dep_op_str DCNL DCSP  DCSP  DCSP  DCSP  DCSP if dval: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for dpname in sorted(dval.keys()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dprange = dval[dpname] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP classname = '{}__{}__{}'.format(op_str, dep_op_str, dpname) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP arg_types.append(ARGTypeClassFactory(classname, dprange)) DCNL DCSP  DCSP class_profile['arg_types'] = tuple(arg_types) DCNL DCSP  DCSP class_profile['import_hash'] = import_hash DCNL DCSP  DCSP class_profile['dep_op_list'] = dep_op_list DCNL DCSP  DCSP @classmethod DCNL DCSP  DCSP def parameter_types(cls): DCNL DCSP  DCSP  DCSP 'Return DCSP the DCSP argument DCSP and DCSP return DCSP types DCSP of DCSP an DCSP operator.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parameters\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ----------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP None\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP -------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parameter_types: DCSP tuple\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Tuple DCSP of DCSP the DCSP DEAP DCSP parameter DCSP types DCSP and DCSP the DCSP DEAP DCSP return DCSP type DCSP for DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP operator\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP return (([np.ndarray] + arg_types), np.ndarray) DCNL DCSP  DCSP class_profile['parameter_types'] = parameter_types DCNL DCSP  DCSP @classmethod DCNL DCSP  DCSP def export(cls, *args): DCNL DCSP  DCSP  DCSP 'Represent DCSP the DCSP operator DCSP as DCSP a DCSP string DCSP so DCSP that DCSP it DCSP can DCSP be DCSP exported DCSP to DCSP a DCSP file.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parameters\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ----------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP args\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Arbitrary DCSP arguments DCSP to DCSP be DCSP passed DCSP to DCSP the DCSP operator\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP -------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP export_string: DCSP str\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP String DCSP representation DCSP of DCSP the DCSP sklearn DCSP class DCSP with DCSP its DCSP parameters DCSP in\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP format:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SklearnClassName(param1="val1", DCSP param2=val2)\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP op_arguments = [] DCNL DCSP  DCSP  DCSP if dep_op_list: DCNL DCSP  DCSP  DCSP  DCSP dep_op_arguments = {} DCNL DCSP  DCSP  DCSP for (arg_class, arg_value) in zip(arg_types, args): DCNL DCSP  DCSP  DCSP  DCSP if (arg_value == 'DEFAULT'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP aname_split = arg_class.__name__.split('__') DCNL DCSP  DCSP  DCSP  DCSP if isinstance(arg_value, str): DCNL DCSP  DCSP  DCSP  DCSP  DCSP arg_value = '"{}"'.format(arg_value) DCNL DCSP  DCSP  DCSP  DCSP if (len(aname_split) == 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP op_arguments.append('{}={}'.format(aname_split[(-1)], arg_value)) DCNL DCSP  DCSP  DCSP  DCSP elif (not list(dep_op_list.values()).count(aname_split[1])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError('Warning: DCSP the DCSP operator DCSP {} DCSP is DCSP not DCSP in DCSP right DCSP format DCSP in DCSP the DCSP operator DCSP dictionary'.format(aname_split[0])) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (aname_split[1] not in dep_op_arguments): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dep_op_arguments[aname_split[1]] = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP dep_op_arguments[aname_split[1]].append('{}={}'.format(aname_split[(-1)], arg_value)) DCNL DCSP  DCSP  DCSP tmp_op_args = [] DCNL DCSP  DCSP  DCSP if dep_op_list: DCNL DCSP  DCSP  DCSP  DCSP for (dep_op_pname, dep_op_str) in dep_op_list.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (dep_op_str == 'f_classif'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP arg_value = dep_op_str DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP arg_value = '{}({})'.format(dep_op_str, ', DCSP '.join(dep_op_arguments[dep_op_str])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP tmp_op_args.append('{}={}'.format(dep_op_pname, arg_value)) DCNL DCSP  DCSP  DCSP op_arguments = (tmp_op_args + op_arguments) DCNL DCSP  DCSP  DCSP return '{}({})'.format(op_obj.__name__, ', DCSP '.join(op_arguments)) DCNL DCSP  DCSP class_profile['export'] = export DCNL DCSP  DCSP op_classname = 'TPOT_{}'.format(op_str) DCNL DCSP  DCSP op_class = type(op_classname, (BaseClass,), class_profile) DCNL DCSP  DCSP op_class.__name__ = op_str DCNL DCSP  DCSP return (op_class, arg_types)
 DCSP all_classes = list(set(np.append(y_true, y_pred))) DCNL DCSP all_class_accuracies = [] DCNL DCSP for this_class in all_classes: DCNL DCSP  DCSP this_class_sensitivity = 0.0 DCNL DCSP  DCSP this_class_specificity = 0.0 DCNL DCSP  DCSP if (sum((y_true == this_class)) != 0): DCNL DCSP  DCSP  DCSP this_class_sensitivity = (float(sum(((y_pred == this_class) & (y_true == this_class)))) / float(sum((y_true == this_class)))) DCNL DCSP  DCSP  DCSP this_class_specificity = (float(sum(((y_pred != this_class) & (y_true != this_class)))) / float(sum((y_true != this_class)))) DCNL DCSP  DCSP this_class_accuracy = ((this_class_sensitivity + this_class_specificity) / 2.0) DCNL DCSP  DCSP all_class_accuracies.append(this_class_accuracy) DCNL DCSP return np.mean(all_class_accuracies)
 DCSP ret_op_classes = [op for op in operators if (op.__name__ == opname)] DCNL DCSP if (len(ret_op_classes) == 0): DCNL DCSP  DCSP raise TypeError('Cannot DCSP found DCSP operator DCSP {} DCSP in DCSP operator DCSP dictionary'.format(opname)) DCNL DCSP elif (len(ret_op_classes) > 1): DCNL DCSP  DCSP print 'Found DCSP multiple DCSP operator DCSP {} DCSP in DCSP operator DCSP dictionary. DCSP Please DCSP check DCSP your DCSP dictionary DCSP file.'.format(opname) DCNL DCSP ret_op_class = ret_op_classes[0] DCNL DCSP return ret_op_class
 DCSP pipeline_tree = expr_to_tree(exported_pipeline, pset) DCNL DCSP pipeline_text = generate_import_code(exported_pipeline, operators) DCNL DCSP pipeline_code = pipeline_code_wrapper(generate_export_pipeline_code(pipeline_tree, operators)) DCNL DCSP if pipeline_code.count('FunctionTransformer(copy)'): DCNL DCSP  DCSP pipeline_text += 'from DCSP sklearn.preprocessing DCSP import DCSP FunctionTransformer\nfrom DCSP copy DCSP import DCSP copy\n' DCNL DCSP pipeline_text += "\n# DCSP NOTE: DCSP Make DCSP sure DCSP that DCSP the DCSP class DCSP is DCSP labeled DCSP 'class' DCSP in DCSP the DCSP data DCSP file\ntpot_data DCSP = DCSP np.recfromcsv('PATH/TO/DATA/FILE', DCSP delimiter='COLUMN_SEPARATOR', DCSP dtype=np.float64)\nfeatures DCSP = DCSP np.delete(tpot_data.view(np.float64).reshape(tpot_data.size, DCSP -1), DCSP tpot_data.dtype.names.index('class'), DCSP axis=1)\ntraining_features, DCSP testing_features, DCSP training_target, DCSP testing_target DCSP = DCSP \\\n DCSP  DCSP  DCSP  DCSP train_test_split(features, DCSP tpot_data['class'], DCSP random_state=42)\n" DCNL DCSP pipeline_text += pipeline_code DCNL DCSP return pipeline_text
 DCSP def prim_to_list(prim, args): DCNL DCSP  DCSP if isinstance(prim, deap.gp.Terminal): DCNL DCSP  DCSP  DCSP if (prim.name in pset.context): DCNL DCSP  DCSP  DCSP  DCSP return pset.context[prim.name] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return prim.value DCNL DCSP  DCSP return ([prim.name] + args) DCNL DCSP tree = [] DCNL DCSP stack = [] DCNL DCSP for node in ind: DCNL DCSP  DCSP stack.append((node, [])) DCNL DCSP  DCSP while (len(stack[(-1)][1]) == stack[(-1)][0].arity): DCNL DCSP  DCSP  DCSP (prim, args) = stack.pop() DCNL DCSP  DCSP  DCSP tree = prim_to_list(prim, args) DCNL DCSP  DCSP  DCSP if (len(stack) == 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP stack[(-1)][1].append(tree) DCNL DCSP return tree
 DCSP def merge_imports(old_dict, new_dict): DCNL DCSP  DCSP for key in new_dict.keys(): DCNL DCSP  DCSP  DCSP if (key in old_dict.keys()): DCNL DCSP  DCSP  DCSP  DCSP old_dict[key] = (set(old_dict[key]) | set(new_dict[key])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP old_dict[key] = set(new_dict[key]) DCNL DCSP operators_used = [x.name for x in pipeline if isinstance(x, deap.gp.Primitive)] DCNL DCSP pipeline_text = 'import DCSP numpy DCSP as DCSP np\n\n' DCNL DCSP pipeline_imports = _starting_imports(operators, operators_used) DCNL DCSP import_relations = {op.__name__: op.import_hash for op in operators} DCNL DCSP for op in operators_used: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP operator_import = import_relations[op] DCNL DCSP  DCSP  DCSP merge_imports(pipeline_imports, operator_import) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP for key in sorted(pipeline_imports.keys()): DCNL DCSP  DCSP module_list = ', DCSP '.join(sorted(pipeline_imports[key])) DCNL DCSP  DCSP pipeline_text += 'from DCSP {} DCSP import DCSP {}\n'.format(key, module_list) DCNL DCSP return pipeline_text
 DCSP return '\nexported_pipeline DCSP = DCSP {}\n\nexported_pipeline.fit(training_features, DCSP training_target)\nresults DCSP = DCSP exported_pipeline.predict(testing_features)\n'.format(pipeline_code)
 DCSP steps = _process_operator(pipeline_tree, operators) DCNL DCSP pipeline_text = 'make_pipeline(\n{STEPS}\n)'.format(STEPS=_indent(',\n'.join(steps), 4)) DCNL DCSP return pipeline_text
 DCSP steps = _process_operator(pipeline_tree, operators) DCNL DCSP num_step = len(steps) DCNL DCSP if (num_step > 1): DCNL DCSP  DCSP pipeline_text = 'make_pipeline(\n{STEPS}\n)'.format(STEPS=_indent(',\n'.join(steps), 4)) DCNL DCSP else: DCNL DCSP  DCSP pipeline_text = '{STEPS}'.format(STEPS=_indent(',\n'.join(steps), 0)) DCNL DCSP return pipeline_text
 DCSP indentation = (amount * ' DCSP ') DCNL DCSP return (indentation + ('\n' + indentation).join(text.split('\n')))
 DCSP @wraps(func) DCNL DCSP def check_pipeline(self, *args, **kwargs): DCNL DCSP  DCSP bad_pipeline = True DCNL DCSP  DCSP num_test = 0 DCNL DCSP  DCSP while (bad_pipeline and (num_test < NUM_TESTS)): DCNL DCSP  DCSP  DCSP args = [(self._toolbox.clone(arg) if isinstance(arg, creator.Individual) else arg) for arg in args] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP warnings.simplefilter('ignore') DCNL DCSP  DCSP  DCSP  DCSP  DCSP expr = func(self, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP expr_tuple = (expr if isinstance(expr, tuple) else (expr,)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for expr_test in expr_tuple: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pipeline_code = generate_pipeline_code(expr_to_tree(expr_test, self._pset), self.operators) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sklearn_pipeline = eval(pipeline_code, self.operators_context) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if self.classification: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sklearn_pipeline.fit(pretest_X, pretest_y) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sklearn_pipeline.fit(pretest_X_reg, pretest_y_reg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bad_pipeline = False DCNL DCSP  DCSP  DCSP except BaseException as e: DCNL DCSP  DCSP  DCSP  DCSP if (self.verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = '_pre_test DCSP decorator: DCSP {fname}: DCSP num_test={n} DCSP {e}'.format(n=num_test, fname=func.__name__, e=e) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(self._pbar, type(None))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._pbar.write(message) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print(message) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP num_test += 1 DCNL DCSP  DCSP return expr DCNL DCSP return check_pipeline
 DCSP offspring = [] DCNL DCSP for _ in range(lambda_): DCNL DCSP  DCSP op_choice = np.random.random() DCNL DCSP  DCSP if (op_choice < cxpb): DCNL DCSP  DCSP  DCSP idxs = np.random.randint(0, len(population), size=2) DCNL DCSP  DCSP  DCSP (ind1, ind2) = (toolbox.clone(population[idxs[0]]), toolbox.clone(population[idxs[1]])) DCNL DCSP  DCSP  DCSP ind_str = str(ind1) DCNL DCSP  DCSP  DCSP num_loop = 0 DCNL DCSP  DCSP  DCSP while ((ind_str == str(ind1)) and (num_loop < MAX_MUT_LOOPS)): DCNL DCSP  DCSP  DCSP  DCSP (ind1, ind2) = toolbox.mate(ind1, ind2) DCNL DCSP  DCSP  DCSP  DCSP num_loop += 1 DCNL DCSP  DCSP  DCSP if (ind_str != str(ind1)): DCNL DCSP  DCSP  DCSP  DCSP del ind1.fitness.values DCNL DCSP  DCSP  DCSP offspring.append(ind1) DCNL DCSP  DCSP elif (op_choice < (cxpb + mutpb)): DCNL DCSP  DCSP  DCSP idx = np.random.randint(0, len(population)) DCNL DCSP  DCSP  DCSP ind = toolbox.clone(population[idx]) DCNL DCSP  DCSP  DCSP ind_str = str(ind) DCNL DCSP  DCSP  DCSP num_loop = 0 DCNL DCSP  DCSP  DCSP while ((ind_str == str(ind)) and (num_loop < MAX_MUT_LOOPS)): DCNL DCSP  DCSP  DCSP  DCSP (ind,) = toolbox.mutate(ind) DCNL DCSP  DCSP  DCSP  DCSP num_loop += 1 DCNL DCSP  DCSP  DCSP if (ind_str != str(ind)): DCNL DCSP  DCSP  DCSP  DCSP del ind.fitness.values DCNL DCSP  DCSP  DCSP offspring.append(ind) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP idx = np.random.randint(0, len(population)) DCNL DCSP  DCSP  DCSP offspring.append(toolbox.clone(population[idx])) DCNL DCSP return offspring
 DCSP logbook = tools.Logbook() DCNL DCSP logbook.header = (['gen', 'nevals'] + (stats.fields if stats else [])) DCNL DCSP invalid_ind = [ind for ind in population if (not ind.fitness.valid)] DCNL DCSP fitnesses = toolbox.evaluate(invalid_ind) DCNL DCSP for (ind, fit) in zip(invalid_ind, fitnesses): DCNL DCSP  DCSP ind.fitness.values = fit DCNL DCSP if (halloffame is not None): DCNL DCSP  DCSP halloffame.update(population) DCNL DCSP record = (stats.compile(population) if (stats is not None) else {}) DCNL DCSP logbook.record(gen=0, nevals=len(invalid_ind), **record) DCNL DCSP for gen in range(1, (ngen + 1)): DCNL DCSP  DCSP offspring = varOr(population, toolbox, lambda_, cxpb, mutpb) DCNL DCSP  DCSP invalid_ind = [ind for ind in offspring if (not ind.fitness.valid)] DCNL DCSP  DCSP if (not pbar.disable): DCNL DCSP  DCSP  DCSP pbar.update((len(offspring) - len(invalid_ind))) DCNL DCSP  DCSP  DCSP if ((not (max_time_mins is None)) and (pbar.n >= pbar.total)): DCNL DCSP  DCSP  DCSP  DCSP pbar.total += lambda_ DCNL DCSP  DCSP fitnesses = toolbox.evaluate(invalid_ind) DCNL DCSP  DCSP for (ind, fit) in zip(invalid_ind, fitnesses): DCNL DCSP  DCSP  DCSP ind.fitness.values = fit DCNL DCSP  DCSP if (halloffame is not None): DCNL DCSP  DCSP  DCSP halloffame.update(offspring) DCNL DCSP  DCSP population[:] = toolbox.select((population + offspring), mu) DCNL DCSP  DCSP if (not pbar.disable): DCNL DCSP  DCSP  DCSP if (verbose == 2): DCNL DCSP  DCSP  DCSP  DCSP high_score = abs(max([halloffame.keys[x].wvalues[1] for x in range(len(halloffame.keys))])) DCNL DCSP  DCSP  DCSP  DCSP pbar.write('Generation DCSP {0} DCSP - DCSP Current DCSP best DCSP internal DCSP CV DCSP score: DCSP {1}'.format(gen, high_score)) DCNL DCSP  DCSP  DCSP elif (verbose == 3): DCNL DCSP  DCSP  DCSP  DCSP pbar.write('Generation DCSP {} DCSP - DCSP Current DCSP Pareto DCSP front DCSP scores:'.format(gen)) DCNL DCSP  DCSP  DCSP  DCSP for (pipeline, pipeline_scores) in zip(halloffame.items, reversed(halloffame.keys)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pbar.write('{} DCTB {} DCTB {}'.format(int(abs(pipeline_scores.wvalues[0])), abs(pipeline_scores.wvalues[1]), pipeline)) DCNL DCSP  DCSP  DCSP  DCSP pbar.write('') DCNL DCSP  DCSP record = (stats.compile(population) if (stats is not None) else {}) DCNL DCSP  DCSP logbook.record(gen=gen, nevals=len(invalid_ind), **record) DCNL DCSP return (population, logbook)
 DCSP __type__ = object DCNL DCSP if ((len(ind1) < 2) or (len(ind2) < 2)): DCNL DCSP  DCSP return (ind1, ind2) DCNL DCSP types1 = defaultdict(list) DCNL DCSP types2 = defaultdict(list) DCNL DCSP if (ind1.root.ret == __type__): DCNL DCSP  DCSP types1[__type__] = range(1, len(ind1)) DCNL DCSP  DCSP types2[__type__] = range(1, len(ind2)) DCNL DCSP  DCSP common_types = [__type__] DCNL DCSP else: DCNL DCSP  DCSP for (idx, node) in enumerate(ind1[1:], 1): DCNL DCSP  DCSP  DCSP types1[node.ret].append(idx) DCNL DCSP  DCSP common_types = [] DCNL DCSP  DCSP for (idx, node) in enumerate(ind2[1:], 1): DCNL DCSP  DCSP  DCSP if ((node.ret in types1) and (node.ret not in types2)): DCNL DCSP  DCSP  DCSP  DCSP common_types.append(node.ret) DCNL DCSP  DCSP  DCSP types2[node.ret].append(idx) DCNL DCSP if (len(common_types) > 0): DCNL DCSP  DCSP type_ = np.random.choice(common_types) DCNL DCSP  DCSP index1 = np.random.choice(types1[type_]) DCNL DCSP  DCSP index2 = np.random.choice(types2[type_]) DCNL DCSP  DCSP slice1 = ind1.searchSubtree(index1) DCNL DCSP  DCSP slice2 = ind2.searchSubtree(index2) DCNL DCSP  DCSP (ind1[slice1], ind2[slice2]) = (ind2[slice2], ind1[slice1]) DCNL DCSP return (ind1, ind2)
 DCSP index = np.random.randint(0, len(individual)) DCNL DCSP node = individual[index] DCNL DCSP slice_ = individual.searchSubtree(index) DCNL DCSP if (node.arity == 0): DCNL DCSP  DCSP term = np.random.choice(pset.terminals[node.ret]) DCNL DCSP  DCSP if isclass(term): DCNL DCSP  DCSP  DCSP term = term() DCNL DCSP  DCSP individual[index] = term DCNL DCSP else: DCNL DCSP  DCSP rindex = None DCNL DCSP  DCSP if ((index + 1) < len(individual)): DCNL DCSP  DCSP  DCSP for (i, tmpnode) in enumerate(individual[(index + 1):], (index + 1)): DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(tmpnode, gp.Primitive) and (tmpnode.ret in tmpnode.args)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rindex = i DCNL DCSP  DCSP primitives = pset.primitives[node.ret] DCNL DCSP  DCSP if (len(primitives) != 0): DCNL DCSP  DCSP  DCSP new_node = np.random.choice(primitives) DCNL DCSP  DCSP  DCSP new_subtree = ([None] * len(new_node.args)) DCNL DCSP  DCSP  DCSP if rindex: DCNL DCSP  DCSP  DCSP  DCSP rnode = individual[rindex] DCNL DCSP  DCSP  DCSP  DCSP rslice = individual.searchSubtree(rindex) DCNL DCSP  DCSP  DCSP  DCSP position = np.random.choice([i for (i, a) in enumerate(new_node.args) if (a == rnode.ret)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP position = None DCNL DCSP  DCSP  DCSP for (i, arg_type) in enumerate(new_node.args): DCNL DCSP  DCSP  DCSP  DCSP if (i != position): DCNL DCSP  DCSP  DCSP  DCSP  DCSP term = np.random.choice(pset.terminals[arg_type]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isclass(term): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP term = term() DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_subtree[i] = term DCNL DCSP  DCSP  DCSP if rindex: DCNL DCSP  DCSP  DCSP  DCSP new_subtree[position:(position + 1)] = individual[rslice] DCNL DCSP  DCSP  DCSP new_subtree.insert(0, new_node) DCNL DCSP  DCSP  DCSP individual[slice_] = new_subtree DCNL DCSP return (individual,)
 DCSP from boto.s3.connection import S3Connection DCNL DCSP return get_regions('s3', region_cls=S3RegionInfo, connection_cls=S3Connection)
 DCSP if (isinstance(fp, KeyFile) and (not position_to_eof)): DCNL DCSP  DCSP return fp.getkey().size DCNL DCSP if (not position_to_eof): DCNL DCSP  DCSP cur_pos = fp.tell() DCNL DCSP fp.seek(0, os.SEEK_END) DCNL DCSP cur_file_size = fp.tell() DCNL DCSP if (not position_to_eof): DCNL DCSP  DCSP fp.seek(cur_pos, os.SEEK_SET) DCNL DCSP return cur_file_size
 DCSP if (not (n + 'a').islower()): DCNL DCSP  DCSP raise BotoClientError('Bucket DCSP names DCSP cannot DCSP contain DCSP upper-case DCSP characters DCSP when DCSP using DCSP either DCSP the DCSP sub-domain DCSP or DCSP virtual DCSP hosting DCSP calling DCSP format.') DCNL DCSP return True
 DCSP more_results = True DCNL DCSP k = None DCNL DCSP while more_results: DCNL DCSP  DCSP rs = bucket.get_all_keys(prefix=prefix, marker=marker, delimiter=delimiter, headers=headers, encoding_type=encoding_type) DCNL DCSP  DCSP for k in rs: DCNL DCSP  DCSP  DCSP (yield k) DCNL DCSP  DCSP if k: DCNL DCSP  DCSP  DCSP marker = (rs.next_marker or k.name) DCNL DCSP  DCSP if (marker and (encoding_type == 'url')): DCNL DCSP  DCSP  DCSP marker = unquote_str(marker) DCNL DCSP  DCSP more_results = rs.is_truncated
 DCSP more_results = True DCNL DCSP k = None DCNL DCSP while more_results: DCNL DCSP  DCSP rs = bucket.get_all_versions(prefix=prefix, key_marker=key_marker, version_id_marker=version_id_marker, delimiter=delimiter, headers=headers, max_keys=999, encoding_type=encoding_type) DCNL DCSP  DCSP for k in rs: DCNL DCSP  DCSP  DCSP (yield k) DCNL DCSP  DCSP key_marker = rs.next_key_marker DCNL DCSP  DCSP if (key_marker and (encoding_type == 'url')): DCNL DCSP  DCSP  DCSP key_marker = unquote_str(key_marker) DCNL DCSP  DCSP version_id_marker = rs.next_version_id_marker DCNL DCSP  DCSP more_results = rs.is_truncated
 DCSP more_results = True DCNL DCSP k = None DCNL DCSP while more_results: DCNL DCSP  DCSP rs = bucket.get_all_multipart_uploads(key_marker=key_marker, upload_id_marker=upload_id_marker, headers=headers, encoding_type=encoding_type) DCNL DCSP  DCSP for k in rs: DCNL DCSP  DCSP  DCSP (yield k) DCNL DCSP  DCSP key_marker = rs.next_key_marker DCNL DCSP  DCSP if (key_marker and (encoding_type == 'url')): DCNL DCSP  DCSP  DCSP key_marker = unquote_str(key_marker) DCNL DCSP  DCSP upload_id_marker = rs.next_upload_id_marker DCNL DCSP  DCSP more_results = rs.is_truncated
 DCSP more_results = True DCNL DCSP part = None DCNL DCSP while more_results: DCNL DCSP  DCSP parts = mpupload.get_all_parts(None, part_number_marker) DCNL DCSP  DCSP for part in parts: DCNL DCSP  DCSP  DCSP (yield part) DCNL DCSP  DCSP part_number_marker = mpupload.next_part_number_marker DCNL DCSP  DCSP more_results = mpupload.is_truncated
 DCSP from boto.awslambda.layer1 import AWSLambdaConnection DCNL DCSP return get_regions('awslambda', connection_cls=AWSLambdaConnection)
 DCSP more_results = True DCNL DCSP k = None DCNL DCSP while more_results: DCNL DCSP  DCSP rs = bucket.get_all_versions(prefix=prefix, marker=marker, generation_marker=generation_marker, delimiter=delimiter, headers=headers, max_keys=999) DCNL DCSP  DCSP for k in rs: DCNL DCSP  DCSP  DCSP (yield k) DCNL DCSP  DCSP marker = rs.next_marker DCNL DCSP  DCSP generation_marker = rs.next_generation_marker DCNL DCSP  DCSP more_results = rs.is_truncated
 DCSP from boto.directconnect.layer1 import DirectConnectConnection DCNL DCSP return get_regions('directconnect', connection_cls=DirectConnectConnection)
 DCSP from boto.dynamodb2.layer1 import DynamoDBConnection DCNL DCSP return get_regions('dynamodb', connection_cls=DynamoDBConnection)
 DCSP from boto.redshift.layer1 import RedshiftConnection DCNL DCSP return get_regions('redshift', connection_cls=RedshiftConnection)
 DCSP from boto.logs.layer1 import CloudWatchLogsConnection DCNL DCSP return get_regions('logs', connection_cls=CloudWatchLogsConnection)
 DCSP from boto.ec2containerservice.layer1 import EC2ContainerServiceConnection DCNL DCSP return get_regions('ec2containerservice', connection_cls=EC2ContainerServiceConnection)
 DCSP if (not provider): DCNL DCSP  DCSP provider = boto.provider.get_default() DCNL DCSP interesting_headers = {} DCNL DCSP for key in headers: DCNL DCSP  DCSP lk = key.lower() DCNL DCSP  DCSP if ((headers[key] is not None) and ((lk in ['content-md5', 'content-type', 'date']) or lk.startswith(provider.header_prefix))): DCNL DCSP  DCSP  DCSP interesting_headers[lk] = str(headers[key]).strip() DCNL DCSP if ('content-type' not in interesting_headers): DCNL DCSP  DCSP interesting_headers['content-type'] = '' DCNL DCSP if ('content-md5' not in interesting_headers): DCNL DCSP  DCSP interesting_headers['content-md5'] = '' DCNL DCSP if (provider.date_header in interesting_headers): DCNL DCSP  DCSP interesting_headers['date'] = '' DCNL DCSP if expires: DCNL DCSP  DCSP interesting_headers['date'] = str(expires) DCNL DCSP sorted_header_keys = sorted(interesting_headers.keys()) DCNL DCSP buf = ('%s\n' % method) DCNL DCSP for key in sorted_header_keys: DCNL DCSP  DCSP val = interesting_headers[key] DCNL DCSP  DCSP if key.startswith(provider.header_prefix): DCNL DCSP  DCSP  DCSP buf += ('%s:%s\n' % (key, val)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP buf += ('%s\n' % val) DCNL DCSP t = path.split('?') DCNL DCSP buf += t[0] DCNL DCSP if (len(t) > 1): DCNL DCSP  DCSP qsa = t[1].split('&') DCNL DCSP  DCSP qsa = [a.split('=', 1) for a in qsa] DCNL DCSP  DCSP qsa = [unquote_v(a) for a in qsa if (a[0] in qsa_of_interest)] DCNL DCSP  DCSP if (len(qsa) > 0): DCNL DCSP  DCSP  DCSP qsa.sort(key=(lambda x: x[0])) DCNL DCSP  DCSP  DCSP qsa = ['='.join(a) for a in qsa] DCNL DCSP  DCSP  DCSP buf += '?' DCNL DCSP  DCSP  DCSP buf += '&'.join(qsa) DCNL DCSP return buf
 DCSP for i in range(0, num_retries): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP proxy_handler = urllib.request.ProxyHandler({}) DCNL DCSP  DCSP  DCSP opener = urllib.request.build_opener(proxy_handler) DCNL DCSP  DCSP  DCSP req = urllib.request.Request(url) DCNL DCSP  DCSP  DCSP r = opener.open(req, timeout=timeout) DCNL DCSP  DCSP  DCSP result = r.read() DCNL DCSP  DCSP  DCSP if ((not isinstance(result, six.string_types)) and hasattr(result, 'decode')): DCNL DCSP  DCSP  DCSP  DCSP result = result.decode('utf-8') DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except urllib.error.HTTPError as e: DCNL DCSP  DCSP  DCSP code = e.getcode() DCNL DCSP  DCSP  DCSP if ((code == 404) and (not retry_on_404)): DCNL DCSP  DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP boto.log.exception('Caught DCSP exception DCSP reading DCSP instance DCSP data') DCNL DCSP  DCSP if ((i + 1) != num_retries): DCNL DCSP  DCSP  DCSP boto.log.debug('Sleeping DCSP before DCSP retrying') DCNL DCSP  DCSP  DCSP time.sleep(min((2 ** i), boto.config.get('Boto', 'max_retry_delay', 60))) DCNL DCSP boto.log.error('Unable DCSP to DCSP read DCSP instance DCSP data, DCSP giving DCSP up') DCNL DCSP return ''
 DCSP return ('%s/%s/%s' % (url, version, path))
 DCSP try: DCNL DCSP  DCSP metadata_url = _build_instance_metadata_url(url, version, data) DCNL DCSP  DCSP return _get_instance_metadata(metadata_url, num_retries=num_retries, timeout=timeout) DCNL DCSP except urllib.error.URLError: DCNL DCSP  DCSP boto.log.exception('Exception DCSP caught DCSP when DCSP trying DCSP to DCSP retrieve DCSP instance DCSP metadata DCSP for: DCSP %s', data) DCNL DCSP  DCSP return None
 DCSP iid = {} DCNL DCSP base_url = _build_instance_metadata_url(url, version, 'dynamic/instance-identity/') DCNL DCSP try: DCNL DCSP  DCSP data = retry_url(base_url, num_retries=num_retries, timeout=timeout) DCNL DCSP  DCSP fields = data.split('\n') DCNL DCSP  DCSP for field in fields: DCNL DCSP  DCSP  DCSP val = retry_url((((base_url + '/') + field) + '/'), num_retries=num_retries, timeout=timeout) DCNL DCSP  DCSP  DCSP if (val[0] == '{'): DCNL DCSP  DCSP  DCSP  DCSP val = json.loads(val) DCNL DCSP  DCSP  DCSP if field: DCNL DCSP  DCSP  DCSP  DCSP iid[field] = val DCNL DCSP  DCSP return iid DCNL DCSP except urllib.error.URLError: DCNL DCSP  DCSP return None
 DCSP with LOCALE_LOCK: DCNL DCSP  DCSP saved = locale.setlocale(locale.LC_ALL) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (yield locale.setlocale(locale.LC_ALL, name)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP locale.setlocale(locale.LC_ALL, saved)
 DCSP dme_url = 'https://www.dnsmadeeasy.com/servlet/updateip' DCNL DCSP dme_url += '?username=%s&password=%s&id=%s&ip=%s' DCNL DCSP s = urllib.request.urlopen((dme_url % (username, password, dme_id, ip_address))) DCNL DCSP return s.read()
 DCSP boto.log.info(('Fetching DCSP %s' % uri)) DCNL DCSP if (file is None): DCNL DCSP  DCSP file = tempfile.NamedTemporaryFile() DCNL DCSP try: DCNL DCSP  DCSP if uri.startswith('s3://'): DCNL DCSP  DCSP  DCSP (bucket_name, key_name) = uri[len('s3://'):].split('/', 1) DCNL DCSP  DCSP  DCSP c = boto.connect_s3(aws_access_key_id=username, aws_secret_access_key=password) DCNL DCSP  DCSP  DCSP bucket = c.get_bucket(bucket_name) DCNL DCSP  DCSP  DCSP key = bucket.get_key(key_name) DCNL DCSP  DCSP  DCSP key.get_contents_to_file(file) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (username and password): DCNL DCSP  DCSP  DCSP  DCSP passman = urllib.request.HTTPPasswordMgrWithDefaultRealm() DCNL DCSP  DCSP  DCSP  DCSP passman.add_password(None, uri, username, password) DCNL DCSP  DCSP  DCSP  DCSP authhandler = urllib.request.HTTPBasicAuthHandler(passman) DCNL DCSP  DCSP  DCSP  DCSP opener = urllib.request.build_opener(authhandler) DCNL DCSP  DCSP  DCSP  DCSP urllib.request.install_opener(opener) DCNL DCSP  DCSP  DCSP s = urllib.request.urlopen(uri) DCNL DCSP  DCSP  DCSP file.write(s.read()) DCNL DCSP  DCSP file.seek(0) DCNL DCSP except: DCNL DCSP  DCSP raise DCNL DCSP  DCSP boto.log.exception(('Problem DCSP Retrieving DCSP file: DCSP %s' % uri)) DCNL DCSP  DCSP file = None DCNL DCSP return file
 DCSP s1 = _first_cap_regex.sub('\\1_\\2', name) DCNL DCSP s2 = _number_cap_regex.sub('\\1_\\2', s1) DCNL DCSP return _end_cap_regex.sub('\\1_\\2', s2).lower()
 DCSP wrapper = email.mime.multipart.MIMEMultipart() DCNL DCSP for (name, con) in content: DCNL DCSP  DCSP definite_type = guess_mime_type(con, deftype) DCNL DCSP  DCSP (maintype, subtype) = definite_type.split('/', 1) DCNL DCSP  DCSP if (maintype == 'text'): DCNL DCSP  DCSP  DCSP mime_con = email.mime.text.MIMEText(con, _subtype=subtype) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mime_con = email.mime.base.MIMEBase(maintype, subtype) DCNL DCSP  DCSP  DCSP mime_con.set_payload(con) DCNL DCSP  DCSP  DCSP email.encoders.encode_base64(mime_con) DCNL DCSP  DCSP mime_con.add_header('Content-Disposition', 'attachment', filename=name) DCNL DCSP  DCSP wrapper.attach(mime_con) DCNL DCSP rcontent = wrapper.as_string() DCNL DCSP if compress: DCNL DCSP  DCSP buf = StringIO() DCNL DCSP  DCSP gz = gzip.GzipFile(mode='wb', fileobj=buf) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP gz.write(rcontent) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP gz.close() DCNL DCSP  DCSP rcontent = buf.getvalue() DCNL DCSP return rcontent
 DCSP starts_with_mappings = {'#include': 'text/x-include-url', '#!': 'text/x-shellscript', '#cloud-config': 'text/cloud-config', '#upstart-job': 'text/upstart-job', '#part-handler': 'text/part-handler', '#cloud-boothook': 'text/cloud-boothook'} DCNL DCSP rtype = deftype DCNL DCSP for (possible_type, mimetype) in starts_with_mappings.items(): DCNL DCSP  DCSP if content.startswith(possible_type): DCNL DCSP  DCSP  DCSP rtype = mimetype DCNL DCSP  DCSP  DCSP break DCNL DCSP return rtype
 DCSP return compute_hash(fp, buf_size, size, hash_algorithm=md5)
 DCSP return [h for h in headers if (h.lower() == name.lower())]
 DCSP matching_headers = find_matching_headers(name, headers) DCNL DCSP return ','.join((str(headers[h]) for h in matching_headers if (headers[h] is not None)))
 DCSP if ((not hostname) or (not isinstance(hostname, str))): DCNL DCSP  DCSP return False DCNL DCSP if hostname.startswith('['): DCNL DCSP  DCSP return True DCNL DCSP if (len(hostname.split(':')) > 2): DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP hostname = hostname.strip() DCNL DCSP if host_is_ipv6(hostname): DCNL DCSP  DCSP return hostname.split(']:', 1)[0].strip('[]') DCNL DCSP else: DCNL DCSP  DCSP return hostname.split(':', 1)[0]
 DCSP from boto.cloudtrail.layer1 import CloudTrailConnection DCNL DCSP return get_regions('cloudtrail', connection_cls=CloudTrailConnection)
 DCSP return get_regions('swf', connection_cls=boto.swf.layer1.Layer1)
 DCSP DEFAULT_CREDENTIALS.update({'aws_access_key_id': aws_access_key_id, 'aws_secret_access_key': aws_secret_access_key})
 DCSP from boto.rds2.layer1 import RDSConnection DCNL DCSP return get_regions('rds', connection_cls=RDSConnection)
 DCSP from boto.rds2.layer1 import RDSConnection DCNL DCSP return connect('rds', region_name, connection_cls=RDSConnection, **kw_params)
 DCSP from boto.sqs.connection import SQSConnection DCNL DCSP return SQSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.s3.connection import S3Connection DCNL DCSP return S3Connection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.gs.connection import GSConnection DCNL DCSP return GSConnection(gs_access_key_id, gs_secret_access_key, **kwargs)
 DCSP from boto.ec2.connection import EC2Connection DCNL DCSP return EC2Connection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.ec2.elb import ELBConnection DCNL DCSP return ELBConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.ec2.autoscale import AutoScaleConnection DCNL DCSP return AutoScaleConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.ec2.cloudwatch import CloudWatchConnection DCNL DCSP return CloudWatchConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.sdb.connection import SDBConnection DCNL DCSP return SDBConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.fps.connection import FPSConnection DCNL DCSP return FPSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.mturk.connection import MTurkConnection DCNL DCSP return MTurkConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.cloudfront import CloudFrontConnection DCNL DCSP return CloudFrontConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.vpc import VPCConnection DCNL DCSP return VPCConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.rds import RDSConnection DCNL DCSP return RDSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.rds2.layer1 import RDSConnection DCNL DCSP return RDSConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.emr import EmrConnection DCNL DCSP return EmrConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.sns import SNSConnection DCNL DCSP return SNSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.iam import IAMConnection DCNL DCSP return IAMConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.route53 import Route53Connection DCNL DCSP return Route53Connection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.cloudformation import CloudFormationConnection DCNL DCSP return CloudFormationConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.ec2 import EC2Connection DCNL DCSP from boto.ec2.regioninfo import RegionInfo DCNL DCSP if (not aws_access_key_id): DCNL DCSP  DCSP aws_access_key_id = config.get('Credentials', 'euca_access_key_id', None) DCNL DCSP if (not aws_secret_access_key): DCNL DCSP  DCSP aws_secret_access_key = config.get('Credentials', 'euca_secret_access_key', None) DCNL DCSP if (not host): DCNL DCSP  DCSP host = config.get('Boto', 'eucalyptus_host', None) DCNL DCSP reg = RegionInfo(name='eucalyptus', endpoint=host) DCNL DCSP return EC2Connection(aws_access_key_id, aws_secret_access_key, region=reg, port=port, path=path, is_secure=is_secure, **kwargs)
 DCSP from boto.glacier.layer2 import Layer2 DCNL DCSP return Layer2(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.ec2.regioninfo import RegionInfo DCNL DCSP purl = urlparse(url) DCNL DCSP kwargs['port'] = purl.port DCNL DCSP kwargs['host'] = purl.hostname DCNL DCSP kwargs['path'] = purl.path DCNL DCSP if (not ('is_secure' in kwargs)): DCNL DCSP  DCSP kwargs['is_secure'] = (purl.scheme == 'https') DCNL DCSP kwargs['region'] = RegionInfo(name=purl.hostname, endpoint=purl.hostname) DCNL DCSP kwargs['aws_access_key_id'] = aws_access_key_id DCNL DCSP kwargs['aws_secret_access_key'] = aws_secret_access_key DCNL DCSP return connect_ec2(**kwargs)
 DCSP from boto.s3.connection import S3Connection DCNL DCSP from boto.s3.connection import OrdinaryCallingFormat DCNL DCSP if (not aws_access_key_id): DCNL DCSP  DCSP aws_access_key_id = config.get('Credentials', 'euca_access_key_id', None) DCNL DCSP if (not aws_secret_access_key): DCNL DCSP  DCSP aws_secret_access_key = config.get('Credentials', 'euca_secret_access_key', None) DCNL DCSP if (not host): DCNL DCSP  DCSP host = config.get('Boto', 'walrus_host', None) DCNL DCSP return S3Connection(aws_access_key_id, aws_secret_access_key, host=host, port=port, path=path, calling_format=OrdinaryCallingFormat(), is_secure=is_secure, **kwargs)
 DCSP from boto.ses import SESConnection DCNL DCSP return SESConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.sts import STSConnection DCNL DCSP return STSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.s3.connection import S3Connection DCNL DCSP from boto.s3.connection import OrdinaryCallingFormat DCNL DCSP access_key = config.get('Credentials', 'ia_access_key_id', ia_access_key_id) DCNL DCSP secret_key = config.get('Credentials', 'ia_secret_access_key', ia_secret_access_key) DCNL DCSP return S3Connection(access_key, secret_key, host='s3.us.archive.org', calling_format=OrdinaryCallingFormat(), is_secure=is_secure, **kwargs)
 DCSP from boto.dynamodb.layer2 import Layer2 DCNL DCSP return Layer2(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.swf.layer1 import Layer1 DCNL DCSP return Layer1(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.cloudsearch.layer2 import Layer2 DCNL DCSP return Layer2(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.cloudsearch2.layer2 import Layer2 DCNL DCSP return Layer2(aws_access_key_id, aws_secret_access_key, sign_request=sign_request, **kwargs)
 DCSP from boto.cloudsearchdomain.layer1 import CloudSearchDomainConnection DCNL DCSP return CloudSearchDomainConnection(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.beanstalk.layer1 import Layer1 DCNL DCSP return Layer1(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP from boto.elastictranscoder.layer1 import ElasticTranscoderConnection DCNL DCSP return ElasticTranscoderConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.redshift.layer1 import RedshiftConnection DCNL DCSP return RedshiftConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.support.layer1 import SupportConnection DCNL DCSP return SupportConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.cloudtrail.layer1 import CloudTrailConnection DCNL DCSP return CloudTrailConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.directconnect.layer1 import DirectConnectConnection DCNL DCSP return DirectConnectConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.kinesis.layer1 import KinesisConnection DCNL DCSP return KinesisConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.logs.layer1 import CloudWatchLogsConnection DCNL DCSP return CloudWatchLogsConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.route53.domains.layer1 import Route53DomainsConnection DCNL DCSP return Route53DomainsConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.cognito.identity.layer1 import CognitoIdentityConnection DCNL DCSP return CognitoIdentityConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.cognito.sync.layer1 import CognitoSyncConnection DCNL DCSP return CognitoSyncConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.kms.layer1 import KMSConnection DCNL DCSP return KMSConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.awslambda.layer1 import AWSLambdaConnection DCNL DCSP return AWSLambdaConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.codedeploy.layer1 import CodeDeployConnection DCNL DCSP return CodeDeployConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.configservice.layer1 import ConfigServiceConnection DCNL DCSP return ConfigServiceConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.cloudhsm.layer1 import CloudHSMConnection DCNL DCSP return CloudHSMConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.ec2containerservice.layer1 import EC2ContainerServiceConnection DCNL DCSP return EC2ContainerServiceConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP from boto.machinelearning.layer1 import MachineLearningConnection DCNL DCSP return MachineLearningConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP version_id = None DCNL DCSP generation = None DCNL DCSP end_scheme_idx = uri_str.find('://') DCNL DCSP if (end_scheme_idx == (-1)): DCNL DCSP  DCSP scheme = default_scheme.lower() DCNL DCSP  DCSP path = uri_str DCNL DCSP else: DCNL DCSP  DCSP scheme = uri_str[0:end_scheme_idx].lower() DCNL DCSP  DCSP path = uri_str[(end_scheme_idx + 3):] DCNL DCSP if (scheme not in ['file', 's3', 'gs']): DCNL DCSP  DCSP raise InvalidUriError(('Unrecognized DCSP scheme DCSP "%s"' % scheme)) DCNL DCSP if (scheme == 'file'): DCNL DCSP  DCSP is_stream = False DCNL DCSP  DCSP if (path == '-'): DCNL DCSP  DCSP  DCSP is_stream = True DCNL DCSP  DCSP return FileStorageUri(path, debug, is_stream) DCNL DCSP else: DCNL DCSP  DCSP path_parts = path.split('/', 1) DCNL DCSP  DCSP bucket_name = path_parts[0] DCNL DCSP  DCSP object_name = '' DCNL DCSP  DCSP if (validate and bucket_name and ((not BUCKET_NAME_RE.match(bucket_name)) or TOO_LONG_DNS_NAME_COMP.search(bucket_name))): DCNL DCSP  DCSP  DCSP raise InvalidUriError(('Invalid DCSP bucket DCSP name DCSP in DCSP URI DCSP "%s"' % uri_str)) DCNL DCSP  DCSP if (scheme == 'gs'): DCNL DCSP  DCSP  DCSP match = GENERATION_RE.search(path) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP md = match.groupdict() DCNL DCSP  DCSP  DCSP  DCSP versionless_uri_str = md['versionless_uri_str'] DCNL DCSP  DCSP  DCSP  DCSP path_parts = versionless_uri_str.split('/', 1) DCNL DCSP  DCSP  DCSP  DCSP generation = int(md['generation']) DCNL DCSP  DCSP elif (scheme == 's3'): DCNL DCSP  DCSP  DCSP match = VERSION_RE.search(path) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP md = match.groupdict() DCNL DCSP  DCSP  DCSP  DCSP versionless_uri_str = md['versionless_uri_str'] DCNL DCSP  DCSP  DCSP  DCSP path_parts = versionless_uri_str.split('/', 1) DCNL DCSP  DCSP  DCSP  DCSP version_id = md['version_id'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InvalidUriError(('Unrecognized DCSP scheme DCSP "%s"' % scheme)) DCNL DCSP  DCSP if (len(path_parts) > 1): DCNL DCSP  DCSP  DCSP object_name = path_parts[1] DCNL DCSP  DCSP return bucket_storage_uri_class(scheme, bucket_name, object_name, debug, suppress_consec_slashes=suppress_consec_slashes, version_id=version_id, generation=generation, is_latest=is_latest)
 DCSP if (not isinstance(key, boto.s3.key.Key)): DCNL DCSP  DCSP raise InvalidUriError(('Requested DCSP key DCSP (%s) DCSP is DCSP not DCSP a DCSP subclass DCSP of DCSP boto.s3.key.Key' % str(type(key)))) DCNL DCSP prov_name = key.bucket.connection.provider.get_provider_name() DCNL DCSP uri_str = ('%s://%s/%s' % (prov_name, key.bucket.name, key.name)) DCNL DCSP return storage_uri(uri_str)
 DCSP if (cv is None): DCNL DCSP  DCSP cv = 1 DCNL DCSP if (lv is None): DCNL DCSP  DCSP lv = 0 DCNL DCSP return (cv + lv)
 DCSP db_user = boto.config.get('DB', 'db_user', None) DCNL DCSP db_passwd = boto.config.get('DB', 'db_passwd', None) DCNL DCSP db_type = boto.config.get('DB', 'db_type', 'SimpleDB') DCNL DCSP db_name = boto.config.get('DB', 'db_name', None) DCNL DCSP db_table = boto.config.get('DB', 'db_table', None) DCNL DCSP db_host = boto.config.get('DB', 'db_host', 'sdb.amazonaws.com') DCNL DCSP db_port = boto.config.getint('DB', 'db_port', 443) DCNL DCSP enable_ssl = boto.config.getbool('DB', 'enable_ssl', True) DCNL DCSP sql_dir = boto.config.get('DB', 'sql_dir', None) DCNL DCSP debug = boto.config.getint('DB', 'debug', 0) DCNL DCSP module_name = cls.__module__.replace('.', '_') DCNL DCSP db_section = ((('DB_' + module_name) + '_') + cls.__name__) DCNL DCSP if (not boto.config.has_section(db_section)): DCNL DCSP  DCSP db_section = ('DB_' + cls.__name__) DCNL DCSP if boto.config.has_section(db_section): DCNL DCSP  DCSP db_user = boto.config.get(db_section, 'db_user', db_user) DCNL DCSP  DCSP db_passwd = boto.config.get(db_section, 'db_passwd', db_passwd) DCNL DCSP  DCSP db_type = boto.config.get(db_section, 'db_type', db_type) DCNL DCSP  DCSP db_name = boto.config.get(db_section, 'db_name', db_name) DCNL DCSP  DCSP db_table = boto.config.get(db_section, 'db_table', db_table) DCNL DCSP  DCSP db_host = boto.config.get(db_section, 'db_host', db_host) DCNL DCSP  DCSP db_port = boto.config.getint(db_section, 'db_port', db_port) DCNL DCSP  DCSP enable_ssl = boto.config.getint(db_section, 'enable_ssl', enable_ssl) DCNL DCSP  DCSP debug = boto.config.getint(db_section, 'debug', debug) DCNL DCSP elif (hasattr(cls, '_db_name') and (cls._db_name is not None)): DCNL DCSP  DCSP db_name = cls._db_name DCNL DCSP elif hasattr(cls.__bases__[0], '_manager'): DCNL DCSP  DCSP return cls.__bases__[0]._manager DCNL DCSP if (db_type == 'SimpleDB'): DCNL DCSP  DCSP from boto.sdb.db.manager.sdbmanager import SDBManager DCNL DCSP  DCSP return SDBManager(cls, db_name, db_user, db_passwd, db_host, db_port, db_table, sql_dir, enable_ssl) DCNL DCSP elif (db_type == 'XML'): DCNL DCSP  DCSP from boto.sdb.db.manager.xmlmanager import XMLManager DCNL DCSP  DCSP return XMLManager(cls, db_name, db_user, db_passwd, db_host, db_port, db_table, sql_dir, enable_ssl) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP db_type: DCSP %s' % db_type))
 DCSP return get_regions('sdb', region_cls=SDBRegionInfo)
 DCSP return connect('sdb', region_name, region_cls=SDBRegionInfo, **kw_params)
 DCSP if ('subjectAltName' in cert): DCNL DCSP  DCSP return [x[1] for x in cert['subjectAltName'] if (x[0].lower() == 'dns')] DCNL DCSP else: DCNL DCSP  DCSP return [x[0][1] for x in cert['subject'] if (x[0][0].lower() == 'commonname')]
 DCSP hosts = GetValidHostsForCert(cert) DCNL DCSP boto.log.debug('validating DCSP server DCSP certificate: DCSP hostname=%s, DCSP certificate DCSP hosts=%s', hostname, hosts) DCNL DCSP for host in hosts: DCNL DCSP  DCSP host_re = host.replace('.', '\\.').replace('*', '[^.]*') DCNL DCSP  DCSP if re.search(('^%s$' % (host_re,)), hostname, re.I): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP from boto.cloudsearch2.layer1 import CloudSearchConnection DCNL DCSP return get_regions('cloudsearch', connection_cls=CloudSearchConnection)
 DCSP return get_regions('cloudwatch', connection_cls=CloudWatchConnection)
 DCSP return connect('cloudwatch', region_name, connection_cls=CloudWatchConnection, **kw_params)
 DCSP return get_regions('ec2', connection_cls=EC2Connection)
 DCSP if (('region' in kw_params) and isinstance(kw_params['region'], RegionInfo) and (region_name == kw_params['region'].name)): DCNL DCSP  DCSP return EC2Connection(**kw_params) DCNL DCSP return connect('ec2', region_name, connection_cls=EC2Connection, **kw_params)
 DCSP for region in regions(**kw_params): DCNL DCSP  DCSP if (region.name == region_name): DCNL DCSP  DCSP  DCSP return region DCNL DCSP return None
 DCSP return get_regions('autoscaling', connection_cls=AutoScaleConnection)
 DCSP return connect('autoscaling', region_name, connection_cls=AutoScaleConnection, **kw_params)
 DCSP return get_regions('elasticloadbalancing', connection_cls=ELBConnection)
 DCSP return connect('elasticloadbalancing', region_name, connection_cls=ELBConnection, **kw_params)
 DCSP from boto.opsworks.layer1 import OpsWorksConnection DCNL DCSP return get_regions('opsworks', connection_cls=OpsWorksConnection)
 DCSP from boto.configservice.layer1 import ConfigServiceConnection DCNL DCSP return get_regions('configservice', connection_cls=ConfigServiceConnection)
 DCSP return get_regions('rds', region_cls=RDSRegionInfo, connection_cls=RDSConnection)
 DCSP return connect('rds', region_name, region_cls=RDSRegionInfo, connection_cls=RDSConnection, **kw_params)
 DCSP ready_handlers = [] DCNL DCSP auth_handlers = boto.plugin.get_plugin(AuthHandler, requested_capability) DCNL DCSP for handler in auth_handlers: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ready_handlers.append(handler(host, config, provider)) DCNL DCSP  DCSP except boto.auth_handler.NotReadyToAuthenticate: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (not ready_handlers): DCNL DCSP  DCSP checked_handlers = auth_handlers DCNL DCSP  DCSP names = [handler.__name__ for handler in checked_handlers] DCNL DCSP  DCSP raise boto.exception.NoAuthHandlerFound(('No DCSP handler DCSP was DCSP ready DCSP to DCSP authenticate. DCSP %d DCSP handlers DCSP were DCSP checked. DCSP %s DCSP Check DCSP your DCSP credentials' % (len(names), str(names)))) DCNL DCSP return ready_handlers[(-1)]
 DCSP regions = get_regions('route53', region_cls=Route53RegionInfo, connection_cls=Route53Connection) DCNL DCSP regions.append(Route53RegionInfo(name='universal', endpoint='route53.amazonaws.com', connection_cls=Route53Connection)) DCNL DCSP return regions
 DCSP if (region_name == 'universal'): DCNL DCSP  DCSP region = Route53RegionInfo(name='universal', endpoint='route53.amazonaws.com', connection_cls=Route53Connection) DCNL DCSP  DCSP return region.connect(**kw_params) DCNL DCSP return connect('route53', region_name, region_cls=Route53RegionInfo, connection_cls=Route53Connection, **kw_params)
 DCSP from boto.route53.domains.layer1 import Route53DomainsConnection DCNL DCSP return get_regions('route53domains', connection_cls=Route53DomainsConnection)
 DCSP from boto.cloudsearchdomain.layer1 import CloudSearchDomainConnection DCNL DCSP return get_regions('cloudsearchdomain', connection_cls=CloudSearchDomainConnection)
 DCSP return get_regions('sts', connection_cls=STSConnection)
 DCSP return connect('sts', region_name, connection_cls=STSConnection, **kw_params)
 DCSP from boto.machinelearning.layer1 import MachineLearningConnection DCNL DCSP return get_regions('machinelearning', connection_cls=MachineLearningConnection)
 DCSP from boto.kms.layer1 import KMSConnection DCNL DCSP return get_regions('kms', connection_cls=KMSConnection)
 DCSP from boto.cognito.sync.layer1 import CognitoSyncConnection DCNL DCSP return get_regions('cognito-sync', connection_cls=CognitoSyncConnection)
 DCSP from boto.cognito.identity.layer1 import CognitoIdentityConnection DCNL DCSP return get_regions('cognito-identity', connection_cls=CognitoIdentityConnection)
 DCSP regions = get_regions('iam', region_cls=IAMRegionInfo, connection_cls=IAMConnection) DCNL DCSP regions.append(IAMRegionInfo(name='universal', endpoint='iam.amazonaws.com', connection_cls=IAMConnection)) DCNL DCSP return regions
 DCSP if (region_name == 'universal'): DCNL DCSP  DCSP region = IAMRegionInfo(name='universal', endpoint='iam.amazonaws.com', connection_cls=IAMConnection) DCNL DCSP  DCSP return region.connect(**kw_params) DCNL DCSP return connect('iam', region_name, region_cls=IAMRegionInfo, connection_cls=IAMConnection, **kw_params)
 DCSP return get_regions('ses', connection_cls=SESConnection)
 DCSP return connect('ses', region_name, connection_cls=SESConnection, **kw_params)
 DCSP return _load_json_file(path)
 DCSP with open(path, 'r') as endpoints_file: DCNL DCSP  DCSP return json.load(endpoints_file)
 DCSP for (service, region_info) in additions.items(): DCNL DCSP  DCSP defaults.setdefault(service, {}) DCNL DCSP  DCSP defaults[service].update(region_info) DCNL DCSP return defaults
 DCSP endpoints = _load_builtin_endpoints() DCNL DCSP additional_path = None DCNL DCSP if os.environ.get('BOTO_ENDPOINTS'): DCNL DCSP  DCSP additional_path = os.environ['BOTO_ENDPOINTS'] DCNL DCSP elif boto.config.get('Boto', 'endpoints_path'): DCNL DCSP  DCSP additional_path = boto.config.get('Boto', 'endpoints_path') DCNL DCSP if additional_path: DCNL DCSP  DCSP additional = load_endpoint_json(additional_path) DCNL DCSP  DCSP endpoints = merge_endpoints(endpoints, additional) DCNL DCSP return endpoints
 DCSP if _cache: DCNL DCSP  DCSP return _cache DCNL DCSP endpoints = _load_json_file(boto.ENDPOINTS_PATH) DCNL DCSP resolver = BotoEndpointResolver(endpoints) DCNL DCSP builder = StaticEndpointBuilder(resolver) DCNL DCSP endpoints = builder.build_static_endpoints() DCNL DCSP _cache.update(endpoints) DCNL DCSP return _cache
 DCSP endpoints = load_regions() DCNL DCSP if (service_name not in endpoints): DCNL DCSP  DCSP raise BotoClientError(("Service DCSP '%s' DCSP not DCSP found DCSP in DCSP endpoints." % service_name)) DCNL DCSP if (region_cls is None): DCNL DCSP  DCSP region_cls = RegionInfo DCNL DCSP region_objs = [] DCNL DCSP for (region_name, endpoint) in endpoints.get(service_name, {}).items(): DCNL DCSP  DCSP region_objs.append(region_cls(name=region_name, endpoint=endpoint, connection_cls=connection_cls)) DCNL DCSP return region_objs
 DCSP if (region_cls is None): DCNL DCSP  DCSP region_cls = RegionInfo DCNL DCSP region = _get_region(service_name, region_name, region_cls, connection_cls) DCNL DCSP if ((region is None) and _use_endpoint_heuristics()): DCNL DCSP  DCSP region = _get_region_with_heuristics(service_name, region_name, region_cls, connection_cls) DCNL DCSP if (region is None): DCNL DCSP  DCSP return None DCNL DCSP return region.connect(**kw_params)
 DCSP for region in get_regions(service_name, region_cls, connection_cls): DCNL DCSP  DCSP if (region.name == region_name): DCNL DCSP  DCSP  DCSP return region DCNL DCSP return None
 DCSP endpoints = load_endpoint_json(boto.ENDPOINTS_PATH) DCNL DCSP resolver = BotoEndpointResolver(endpoints) DCNL DCSP hostname = resolver.resolve_hostname(service_name, region_name) DCNL DCSP return region_cls(name=region_name, endpoint=hostname, connection_cls=connection_cls)
 DCSP return get_regions('cloudformation', connection_cls=CloudFormationConnection)
 DCSP return connect('cloudformation', region_name, connection_cls=CloudFormationConnection, **kw_params)
 DCSP instance_id = boto.config.get('Instance', 'instance-id', None) DCNL DCSP if (instance_id == server.instance_id): DCNL DCSP  DCSP return LocalClient(server) DCNL DCSP else: DCNL DCSP  DCSP return SSHClient(server)
 DCSP s = FakeServer(instance, ssh_key_file) DCNL DCSP return SSHClient(s, host_key_file, user_name, ssh_pwd)
 DCSP from boto.kinesis.layer1 import KinesisConnection DCNL DCSP return get_regions('kinesis', connection_cls=KinesisConnection)
 DCSP part_size = _MEGABYTE DCNL DCSP if ((default_part_size * MAXIMUM_NUMBER_OF_PARTS) < size_in_bytes): DCNL DCSP  DCSP if (size_in_bytes > ((4096 * _MEGABYTE) * 10000)): DCNL DCSP  DCSP  DCSP raise ValueError(('File DCSP size DCSP too DCSP large: DCSP %s' % size_in_bytes)) DCNL DCSP  DCSP min_part_size = (size_in_bytes / 10000) DCNL DCSP  DCSP power = 3 DCNL DCSP  DCSP while (part_size < min_part_size): DCNL DCSP  DCSP  DCSP part_size = math.ldexp(_MEGABYTE, power) DCNL DCSP  DCSP  DCSP power += 1 DCNL DCSP  DCSP part_size = int(part_size) DCNL DCSP else: DCNL DCSP  DCSP part_size = default_part_size DCNL DCSP return part_size
 DCSP hashes = [] DCNL DCSP hashes.extend(fo) DCNL DCSP while (len(hashes) > 1): DCNL DCSP  DCSP new_hashes = [] DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP if (len(hashes) > 1): DCNL DCSP  DCSP  DCSP  DCSP first = hashes.pop(0) DCNL DCSP  DCSP  DCSP  DCSP second = hashes.pop(0) DCNL DCSP  DCSP  DCSP  DCSP new_hashes.append(hashlib.sha256((first + second)).digest()) DCNL DCSP  DCSP  DCSP elif (len(hashes) == 1): DCNL DCSP  DCSP  DCSP  DCSP only = hashes.pop(0) DCNL DCSP  DCSP  DCSP  DCSP new_hashes.append(only) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP hashes.extend(new_hashes) DCNL DCSP return hashes[0]
 DCSP if (six.PY3 and hasattr(fileobj, 'mode') and ('b' not in fileobj.mode)): DCNL DCSP  DCSP raise ValueError('File-like DCSP object DCSP must DCSP be DCSP opened DCSP in DCSP binary DCSP mode!') DCNL DCSP linear_hash = hashlib.sha256() DCNL DCSP chunks = [] DCNL DCSP chunk = fileobj.read(chunk_size) DCNL DCSP while chunk: DCNL DCSP  DCSP if (not isinstance(chunk, bytes)): DCNL DCSP  DCSP  DCSP chunk = chunk.encode((getattr(fileobj, 'encoding', '') or 'utf-8')) DCNL DCSP  DCSP linear_hash.update(chunk) DCNL DCSP  DCSP chunks.append(hashlib.sha256(chunk).digest()) DCNL DCSP  DCSP chunk = fileobj.read(chunk_size) DCNL DCSP if (not chunks): DCNL DCSP  DCSP chunks = [hashlib.sha256('').digest()] DCNL DCSP return (linear_hash.hexdigest(), bytes_to_hex(tree_hash(chunks)))
 DCSP return bytes_to_hex(tree_hash(chunk_hashes(str_as_bytes)))
 DCSP from boto.glacier.layer2 import Layer2 DCNL DCSP return get_regions('glacier', connection_cls=Layer2)
 DCSP uploader = _Uploader(vault, upload_id, part_size, chunk_size) DCNL DCSP for (part_index, part_data) in enumerate(generate_parts_from_fobj(fobj, part_size)): DCNL DCSP  DCSP part_tree_hash = tree_hash(chunk_hashes(part_data, chunk_size)) DCNL DCSP  DCSP if ((part_index not in part_hash_map) or (part_hash_map[part_index] != part_tree_hash)): DCNL DCSP  DCSP  DCSP uploader.upload_part(part_index, part_data) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP uploader.skip_part(part_index, part_tree_hash, len(part_data)) DCNL DCSP uploader.close() DCNL DCSP return uploader.archive_id
 DCSP from boto.datapipeline.layer1 import DataPipelineConnection DCNL DCSP return get_regions('datapipeline', connection_cls=DataPipelineConnection)
 DCSP from boto.codedeploy.layer1 import CodeDeployConnection DCNL DCSP return get_regions('codedeploy', connection_cls=CodeDeployConnection)
 DCSP from boto.support.layer1 import SupportConnection DCNL DCSP return get_regions('support', connection_cls=SupportConnection)
 DCSP from boto.elastictranscoder.layer1 import ElasticTranscoderConnection DCNL DCSP return get_regions('elastictranscoder', connection_cls=ElasticTranscoderConnection)
 DCSP from boto.sqs.connection import SQSConnection DCNL DCSP return get_regions('sqs', region_cls=SQSRegionInfo, connection_cls=SQSConnection)
 DCSP return get_regions('ec2', connection_cls=VPCConnection)
 DCSP return connect('ec2', region_name, connection_cls=VPCConnection, **kw_params)
 DCSP from boto.beanstalk.layer1 import Layer1 DCNL DCSP return get_regions('elasticbeanstalk', connection_cls=Layer1)
 DCSP from boto.cloudhsm.layer1 import CloudHSMConnection DCNL DCSP return get_regions('cloudhsm', connection_cls=CloudHSMConnection)
 DCSP from boto.elasticache.layer1 import ElastiCacheConnection DCNL DCSP return get_regions('elasticache', connection_cls=ElastiCacheConnection)
 DCSP return get_regions('elasticmapreduce', connection_cls=EmrConnection)
 DCSP from boto.cloudsearch.layer1 import Layer1 DCNL DCSP return get_regions('cloudsearch', connection_cls=Layer1)
 DCSP return get_regions('sns', connection_cls=SNSConnection)
 DCSP return connect('sns', region_name, connection_cls=SNSConnection, **kw_params)
 DCSP from boto.dynamodb.layer2 import Layer2 DCNL DCSP return get_regions('dynamodb', connection_cls=Layer2)
 DCSP if isinstance(val, bool): DCNL DCSP  DCSP return str(int(val)) DCNL DCSP return str(val)
 DCSP dynamodb_type = None DCNL DCSP if (val is None): DCNL DCSP  DCSP dynamodb_type = 'NULL' DCNL DCSP elif is_num(val): DCNL DCSP  DCSP if (isinstance(val, bool) and use_boolean): DCNL DCSP  DCSP  DCSP dynamodb_type = 'BOOL' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP dynamodb_type = 'N' DCNL DCSP elif is_str(val): DCNL DCSP  DCSP dynamodb_type = 'S' DCNL DCSP elif isinstance(val, (set, frozenset)): DCNL DCSP  DCSP if (False not in map(is_num, val)): DCNL DCSP  DCSP  DCSP dynamodb_type = 'NS' DCNL DCSP  DCSP elif (False not in map(is_str, val)): DCNL DCSP  DCSP  DCSP dynamodb_type = 'SS' DCNL DCSP  DCSP elif (False not in map(is_binary, val)): DCNL DCSP  DCSP  DCSP dynamodb_type = 'BS' DCNL DCSP elif is_binary(val): DCNL DCSP  DCSP dynamodb_type = 'B' DCNL DCSP elif isinstance(val, Mapping): DCNL DCSP  DCSP dynamodb_type = 'M' DCNL DCSP elif isinstance(val, list): DCNL DCSP  DCSP dynamodb_type = 'L' DCNL DCSP if (dynamodb_type is None): DCNL DCSP  DCSP msg = ('Unsupported DCSP type DCSP "%s" DCSP for DCSP value DCSP "%s"' % (type(val), val)) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP return dynamodb_type
 DCSP dynamodb_type = get_dynamodb_type(val) DCNL DCSP if (dynamodb_type == 'N'): DCNL DCSP  DCSP val = {dynamodb_type: serialize_num(val)} DCNL DCSP elif (dynamodb_type == 'S'): DCNL DCSP  DCSP val = {dynamodb_type: val} DCNL DCSP elif (dynamodb_type == 'NS'): DCNL DCSP  DCSP val = {dynamodb_type: list(map(serialize_num, val))} DCNL DCSP elif (dynamodb_type == 'SS'): DCNL DCSP  DCSP val = {dynamodb_type: [n for n in val]} DCNL DCSP elif (dynamodb_type == 'B'): DCNL DCSP  DCSP if isinstance(val, bytes): DCNL DCSP  DCSP  DCSP val = Binary(val) DCNL DCSP  DCSP val = {dynamodb_type: val.encode()} DCNL DCSP elif (dynamodb_type == 'BS'): DCNL DCSP  DCSP val = {dynamodb_type: [n.encode() for n in val]} DCNL DCSP return val
 DCSP if (len(dct.keys()) > 1): DCNL DCSP  DCSP return dct DCNL DCSP if ('S' in dct): DCNL DCSP  DCSP return dct['S'] DCNL DCSP if ('N' in dct): DCNL DCSP  DCSP return convert_num(dct['N']) DCNL DCSP if ('SS' in dct): DCNL DCSP  DCSP return set(dct['SS']) DCNL DCSP if ('NS' in dct): DCNL DCSP  DCSP return set(map(convert_num, dct['NS'])) DCNL DCSP if ('B' in dct): DCNL DCSP  DCSP return convert_binary(dct['B']) DCNL DCSP if ('BS' in dct): DCNL DCSP  DCSP return set(map(convert_binary, dct['BS'])) DCNL DCSP return dct
 DCSP func.__doc__ = doc
 DCSP __import__(name) DCNL DCSP return sys.modules[name]
 DCSP setattr(_MovedItems, move.name, move)
 DCSP try: DCNL DCSP  DCSP delattr(_MovedItems, name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP del moves.__dict__[name] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise AttributeError(('no DCSP such DCSP move, DCSP %r' % (name,)))
 DCSP class metaclass(meta, ): DCNL DCSP  DCSP def __new__(cls, name, this_bases, d): DCNL DCSP  DCSP  DCSP return meta(name, bases, d) DCNL DCSP return type.__new__(metaclass, 'temporary_class', (), {})
 DCSP def wrapper(cls): DCNL DCSP  DCSP orig_vars = cls.__dict__.copy() DCNL DCSP  DCSP slots = orig_vars.get('__slots__') DCNL DCSP  DCSP if (slots is not None): DCNL DCSP  DCSP  DCSP if isinstance(slots, str): DCNL DCSP  DCSP  DCSP  DCSP slots = [slots] DCNL DCSP  DCSP  DCSP for slots_var in slots: DCNL DCSP  DCSP  DCSP  DCSP orig_vars.pop(slots_var) DCNL DCSP  DCSP orig_vars.pop('__dict__', None) DCNL DCSP  DCSP orig_vars.pop('__weakref__', None) DCNL DCSP  DCSP return metaclass(cls.__name__, cls.__bases__, orig_vars) DCNL DCSP return wrapper
 DCSP if PY2: DCNL DCSP  DCSP if ('__str__' not in klass.__dict__): DCNL DCSP  DCSP  DCSP raise ValueError(("@python_2_unicode_compatible DCSP cannot DCSP be DCSP applied DCSP to DCSP %s DCSP because DCSP it DCSP doesn't DCSP define DCSP __str__()." % klass.__name__)) DCNL DCSP  DCSP klass.__unicode__ = klass.__str__ DCNL DCSP  DCSP klass.__str__ = (lambda self: self.__unicode__().encode('utf-8')) DCNL DCSP return klass
 DCSP t = Thread(target=function, args=args, kwargs=kwargs) DCNL DCSP t.start() DCNL DCSP return t
 DCSP print('Running DCSP test_close_connections') DCNL DCSP s3 = boto.connect_s3() DCNL DCSP for b in s3.get_all_buckets(): DCNL DCSP  DCSP if b.name.startswith('test-'): DCNL DCSP  DCSP  DCSP for key in b.get_all_keys(): DCNL DCSP  DCSP  DCSP  DCSP key.delete() DCNL DCSP  DCSP  DCSP b.delete() DCNL DCSP bucket = s3.create_bucket(('test-%d' % int(time.time()))) DCNL DCSP names = [str(uuid.uuid4) for _ in range(30)] DCNL DCSP threads = [spawn(put_object, bucket, name) for name in names] DCNL DCSP for t in threads: DCNL DCSP  DCSP t.join() DCNL DCSP threads = [spawn(get_object, bucket, name) for name in names] DCNL DCSP for t in threads: DCNL DCSP  DCSP t.join()
 DCSP print('Running DCSP test_reuse_connections') DCNL DCSP s3 = boto.connect_s3() DCNL DCSP bucket = s3.create_bucket(('test-%d' % int(time.time()))) DCNL DCSP small_names = [str(uuid.uuid4()) for _ in range(4)] DCNL DCSP for (i, name) in enumerate(small_names): DCNL DCSP  DCSP bucket.new_key(name).set_contents_from_string(str(i)) DCNL DCSP print(' DCSP  DCSP  DCSP  DCSP waiting DCSP for DCSP all DCSP connections DCSP to DCSP become DCSP stale') DCNL DCSP time.sleep((s3._pool.STALE_DURATION + 1)) DCNL DCSP s3._pool.clean() DCNL DCSP assert (s3._pool.size() == 0) DCNL DCSP print(' DCSP  DCSP  DCSP  DCSP pool DCSP is DCSP empty') DCNL DCSP big_name = str(uuid.uuid4()) DCNL DCSP contents = ('-' * BIG_SIZE) DCNL DCSP bucket.new_key(big_name).set_contents_from_string(contents) DCNL DCSP threads = [spawn(read_big_object, s3, bucket, big_name, 20) for _ in range(5)] DCNL DCSP queriers = [LittleQuerier(bucket, small_names) for _ in range(5)] DCNL DCSP for t in threads: DCNL DCSP  DCSP t.join() DCNL DCSP for q in queriers: DCNL DCSP  DCSP q.stop()
 DCSP def deco_retry(f): DCNL DCSP  DCSP def f_retry(*args, **kwargs): DCNL DCSP  DCSP  DCSP (mtries, mdelay) = (tries, delay) DCNL DCSP  DCSP  DCSP try_one_last_time = True DCNL DCSP  DCSP  DCSP while (mtries > 1): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP try_one_last_time = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except ExceptionToCheck as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = ('%s, DCSP Retrying DCSP in DCSP %d DCSP seconds...' % (str(e), mdelay)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if logger: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.warning(msg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print msg DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(mdelay) DCNL DCSP  DCSP  DCSP  DCSP  DCSP mtries -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP mdelay *= backoff DCNL DCSP  DCSP  DCSP if try_one_last_time: DCNL DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return f_retry DCNL DCSP return deco_retry
 DCSP raise ValueError('HAHAHA! DCSP Totally DCSP not DCSP simplejson DCSP & DCSP you DCSP gave DCSP me DCSP bad DCSP JSON.')
 DCSP raise json.JSONDecodeError('Using DCSP simplejson DCSP & DCSP you DCSP gave DCSP me DCSP bad DCSP JSON.', '', 0)
 DCSP host = (('s3.' + region) + dns_suffix) DCNL DCSP case = S3SignatureVersionTestCase(host, expected_signature_version) DCNL DCSP (yield case.run) DCNL DCSP host = (('s3-' + region) + dns_suffix) DCNL DCSP case = S3SignatureVersionTestCase(host, expected_signature_version) DCNL DCSP (yield case.run) DCNL DCSP host = (('mybucket.s3-' + region) + dns_suffix) DCNL DCSP case = S3SignatureVersionTestCase(host, expected_signature_version) DCNL DCSP (yield case.run)
 DCSP raise ValueError('HAHAHA! DCSP Totally DCSP not DCSP simplejson DCSP & DCSP you DCSP gave DCSP me DCSP bad DCSP JSON.')
 DCSP raise json.JSONDecodeError('Using DCSP simplejson DCSP & DCSP you DCSP gave DCSP me DCSP bad DCSP JSON.', '', 0)
 DCSP config_environment() DCNL DCSP global conn DCNL DCSP conn = SetHostMTurkConnection() DCNL DCSP is_boto = description_filter('Boto') DCNL DCSP print 'getting DCSP hits...' DCNL DCSP all_hits = list(conn.get_all_hits()) DCNL DCSP is_reviewable = (lambda hit: (hit.HITStatus == 'Reviewable')) DCNL DCSP is_not_reviewable = (lambda hit: (not is_reviewable(hit))) DCNL DCSP hits_to_process = filter(is_boto, all_hits) DCNL DCSP hits_to_disable = filter(is_not_reviewable, hits_to_process) DCNL DCSP hits_to_dispose = filter(is_reviewable, hits_to_process) DCNL DCSP print ('disabling/disposing DCSP %d/%d DCSP hits' % (len(hits_to_disable), len(hits_to_dispose))) DCNL DCSP map(disable_hit, hits_to_disable) DCNL DCSP map(dispose_hit, hits_to_dispose) DCNL DCSP total_hits = len(all_hits) DCNL DCSP hits_processed = len(hits_to_process) DCNL DCSP skipped = (total_hits - hits_processed) DCNL DCSP fmt = 'Processed: DCSP %(total_hits)d DCSP HITs, DCSP disabled/disposed: DCSP %(hits_processed)d, DCSP skipped: DCSP %(skipped)d' DCNL DCSP print (fmt % vars())
 DCSP return request.has_permission(permission, context)
 DCSP return request.authenticated_userid
 DCSP return request.unauthenticated_userid
 DCSP return request.effective_principals
 DCSP if (userid is _marker): DCNL DCSP  DCSP principal = kw.pop('principal', _marker) DCNL DCSP  DCSP if (principal is _marker): DCNL DCSP  DCSP  DCSP raise TypeError("remember() DCSP missing DCSP 1 DCSP required DCSP positional DCSP argument: DCSP 'userid'") DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP deprecated('principal', 'The DCSP "principal" DCSP argument DCSP was DCSP deprecated DCSP in DCSP Pyramid DCSP 1.6. DCSP It DCSP will DCSP be DCSP removed DCSP in DCSP Pyramid DCSP 1.9. DCSP Use DCSP the DCSP "userid" DCSP argument DCSP instead.') DCNL DCSP  DCSP  DCSP userid = principal DCNL DCSP policy = _get_authentication_policy(request) DCNL DCSP if (policy is None): DCNL DCSP  DCSP return [] DCNL DCSP return policy.remember(request, userid, **kw)
 DCSP policy = _get_authentication_policy(request) DCNL DCSP if (policy is None): DCNL DCSP  DCSP return [] DCNL DCSP return policy.forget(request)
 DCSP reg = get_current_registry() DCNL DCSP policy = reg.queryUtility(IAuthorizationPolicy) DCNL DCSP if (policy is None): DCNL DCSP  DCSP return [Everyone] DCNL DCSP return policy.principals_allowed_by_permission(context, permission)
 DCSP reg = _get_registry(request) DCNL DCSP provides = ([IViewClassifier] + map_(providedBy, (request, context))) DCNL DCSP view = reg.adapters.lookup(provides, ISecuredView, name=name) DCNL DCSP if (view is None): DCNL DCSP  DCSP view = reg.adapters.lookup(provides, IView, name=name) DCNL DCSP  DCSP if (view is None): DCNL DCSP  DCSP  DCSP raise TypeError('No DCSP registered DCSP view DCSP satisfies DCSP the DCSP constraints. DCSP It DCSP would DCSP not DCSP make DCSP sense DCSP to DCSP claim DCSP that DCSP this DCSP view DCSP "is" DCSP or DCSP "is DCSP not" DCSP permitted.') DCNL DCSP  DCSP return Allowed(('Allowed: DCSP view DCSP name DCSP %r DCSP in DCSP context DCSP %r DCSP (no DCSP permission DCSP defined)' % (name, context))) DCNL DCSP return view.__permitted__(context, request)
 DCSP return manager.get()['request']
 DCSP return manager.get()['registry']
 DCSP registry = getattr(request, 'registry', None) DCNL DCSP if (registry is None): DCNL DCSP  DCSP registry = get_current_registry() DCNL DCSP context_iface = providedBy(context) DCNL DCSP request_iface = providedBy(request) DCNL DCSP response = _call_view(registry, request, context, context_iface, name, secure=secure, request_iface=request_iface) DCNL DCSP return response
 DCSP response = render_view_to_response(context, request, name, secure) DCNL DCSP if (response is None): DCNL DCSP  DCSP return None DCNL DCSP return response.app_iter
 DCSP iterable = render_view_to_iterable(context, request, name, secure) DCNL DCSP if (iterable is None): DCNL DCSP  DCSP return None DCNL DCSP return ''.join(iterable)
 DCSP exc = status_map[status_code](**kw) DCNL DCSP return exc
 DCSP response_factory = registry.queryUtility(IResponseFactory, default=(lambda r: Response())) DCNL DCSP return response_factory
 DCSP if (getattr(package, '__name__', None) == '__main__'): DCNL DCSP  DCSP return abspath DCNL DCSP pp = (package_path(package) + os.path.sep) DCNL DCSP if abspath.startswith(pp): DCNL DCSP  DCSP relpath = abspath[len(pp):] DCNL DCSP  DCSP return ('%s:%s' % (package_name(package), relpath.replace(os.path.sep, '/'))) DCNL DCSP return abspath
 DCSP registry = app.registry DCNL DCSP if (request is None): DCNL DCSP  DCSP request = _make_request('/', registry) DCNL DCSP threadlocals = {'registry': registry, 'request': request} DCNL DCSP app.threadlocal_manager.push(threadlocals) DCNL DCSP def closer(request=request): DCNL DCSP  DCSP app.threadlocal_manager.pop() DCNL DCSP root = app.root_factory(request) DCNL DCSP return (root, closer)
 DCSP if (registry is None): DCNL DCSP  DCSP registry = getattr(request, 'registry', global_registries.last) DCNL DCSP if (registry is None): DCNL DCSP  DCSP raise ConfigurationError('No DCSP valid DCSP Pyramid DCSP applications DCSP could DCSP be DCSP found, DCSP make DCSP sure DCSP one DCSP has DCSP been DCSP created DCSP before DCSP trying DCSP to DCSP activate DCSP it.') DCNL DCSP if (request is None): DCNL DCSP  DCSP request = _make_request('/', registry) DCNL DCSP request.registry = registry DCNL DCSP threadlocals = {'registry': registry, 'request': request} DCNL DCSP threadlocal_manager.push(threadlocals) DCNL DCSP apply_request_extensions(request) DCNL DCSP def closer(): DCNL DCSP  DCSP threadlocal_manager.pop() DCNL DCSP root_factory = registry.queryUtility(IRootFactory, default=DefaultRootFactory) DCNL DCSP root = root_factory(request) DCNL DCSP if (getattr(request, 'context', None) is None): DCNL DCSP  DCSP request.context = root DCNL DCSP return AppEnvironment(root=root, closer=closer, registry=registry, request=request, root_factory=root_factory)
 DCSP if (registry is None): DCNL DCSP  DCSP registry = global_registries.last DCNL DCSP request_factory = registry.queryUtility(IRequestFactory, default=Request) DCNL DCSP request = request_factory.blank(path) DCNL DCSP request.registry = registry DCNL DCSP return request
 DCSP len_eq = (len(string1) == len(string2)) DCNL DCSP if len_eq: DCNL DCSP  DCSP invalid_bits = 0 DCNL DCSP  DCSP left = string1 DCNL DCSP else: DCNL DCSP  DCSP invalid_bits = 1 DCNL DCSP  DCSP left = string2 DCNL DCSP right = string2 DCNL DCSP if (compare_digest is not None): DCNL DCSP  DCSP invalid_bits += (not compare_digest(left, right)) DCNL DCSP else: DCNL DCSP  DCSP for (a, b) in zip(left, right): DCNL DCSP  DCSP  DCSP invalid_bits += (a != b) DCNL DCSP return (invalid_bits != 0)
 DCSP if isinstance(object, string_types): DCNL DCSP  DCSP return text_(object) DCNL DCSP if isinstance(object, integer_types): DCNL DCSP  DCSP return text_(str(object)) DCNL DCSP if isinstance(object, (bool, float, type(None))): DCNL DCSP  DCSP return text_(str(object)) DCNL DCSP if isinstance(object, set): DCNL DCSP  DCSP if PY2: DCNL DCSP  DCSP  DCSP return shortrepr(object, ')') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return shortrepr(object, '}') DCNL DCSP if isinstance(object, tuple): DCNL DCSP  DCSP return shortrepr(object, ')') DCNL DCSP if isinstance(object, list): DCNL DCSP  DCSP return shortrepr(object, ']') DCNL DCSP if isinstance(object, dict): DCNL DCSP  DCSP return shortrepr(object, '}') DCNL DCSP module = inspect.getmodule(object) DCNL DCSP if (module is None): DCNL DCSP  DCSP return text_(('object DCSP %s' % str(object))) DCNL DCSP modulename = module.__name__ DCNL DCSP if inspect.ismodule(object): DCNL DCSP  DCSP return text_(('module DCSP %s' % modulename)) DCNL DCSP if inspect.ismethod(object): DCNL DCSP  DCSP oself = getattr(object, '__self__', None) DCNL DCSP  DCSP if (oself is None): DCNL DCSP  DCSP  DCSP oself = getattr(object, 'im_self', None) DCNL DCSP  DCSP return text_(('method DCSP %s DCSP of DCSP class DCSP %s.%s' % (object.__name__, modulename, oself.__class__.__name__))) DCNL DCSP if inspect.isclass(object): DCNL DCSP  DCSP dottedname = ('%s.%s' % (modulename, object.__name__)) DCNL DCSP  DCSP return text_(('class DCSP %s' % dottedname)) DCNL DCSP if inspect.isfunction(object): DCNL DCSP  DCSP dottedname = ('%s.%s' % (modulename, object.__name__)) DCNL DCSP  DCSP return text_(('function DCSP %s' % dottedname)) DCNL DCSP return text_(('object DCSP %s' % str(object)))
 DCSP def wrapper(self, *arg, **kw): DCNL DCSP  DCSP defaults = {} DCNL DCSP  DCSP if arg: DCNL DCSP  DCSP  DCSP view = arg[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP view = kw.get('view') DCNL DCSP  DCSP view = self.maybe_dotted(view) DCNL DCSP  DCSP if inspect.isclass(view): DCNL DCSP  DCSP  DCSP defaults = getattr(view, '__view_defaults__', {}).copy() DCNL DCSP  DCSP if ('_backframes' not in kw): DCNL DCSP  DCSP  DCSP kw['_backframes'] = 1 DCNL DCSP  DCSP defaults.update(kw) DCNL DCSP  DCSP return wrapped(self, *arg, **defaults) DCNL DCSP return functools.wraps(wrapped)(wrapper)
 DCSP def wrapper(self, *arg, **kw): DCNL DCSP  DCSP if (self._ainfo is None): DCNL DCSP  DCSP  DCSP self._ainfo = [] DCNL DCSP  DCSP info = kw.pop('_info', None) DCNL DCSP  DCSP backframes = (kw.pop('_backframes', 0) + 2) DCNL DCSP  DCSP if (is_nonstr_iter(info) and (len(info) == 4)): DCNL DCSP  DCSP  DCSP info = ActionInfo(*info) DCNL DCSP  DCSP if (info is None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP f = traceback.extract_stack(limit=4) DCNL DCSP  DCSP  DCSP  DCSP last_frame = ActionInfo(*f[(-1)]) DCNL DCSP  DCSP  DCSP  DCSP if (last_frame.function == 'extract_stack'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.pop() DCNL DCSP  DCSP  DCSP  DCSP info = ActionInfo(*f[(- backframes)]) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP info = ActionInfo(None, 0, '', '') DCNL DCSP  DCSP self._ainfo.append(info) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = wrapped(self, *arg, **kw) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP self._ainfo.pop() DCNL DCSP  DCSP return result DCNL DCSP if hasattr(wrapped, '__name__'): DCNL DCSP  DCSP functools.update_wrapper(wrapper, wrapped) DCNL DCSP wrapper.__docobj__ = wrapped DCNL DCSP return wrapper
 DCSP try: DCNL DCSP  DCSP return native_(name, 'ascii') DCNL DCSP except (UnicodeEncodeError, UnicodeDecodeError): DCNL DCSP  DCSP msg = '`name="%s"` DCSP is DCSP invalid. DCSP `name` DCSP must DCSP be DCSP ascii DCSP because DCSP it DCSP is DCSP used DCSP on DCSP __name__ DCSP of DCSP the DCSP method' DCNL DCSP  DCSP raise ConfigurationError((msg % name))
 DCSP obj_vals = (obj.__dict__ if (obj is not None) else {}) DCNL DCSP saved_vals = {} DCNL DCSP for name in attrs: DCNL DCSP  DCSP saved_vals[name] = obj_vals.pop(name, _marker) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for name in attrs: DCNL DCSP  DCSP  DCSP saved_val = saved_vals[name] DCNL DCSP  DCSP  DCSP if (saved_val is not _marker): DCNL DCSP  DCSP  DCSP  DCSP obj_vals[name] = saved_val DCNL DCSP  DCSP  DCSP elif (name in obj_vals): DCNL DCSP  DCSP  DCSP  DCSP del obj_vals[name]
 DCSP if (not pattern): DCNL DCSP  DCSP return False DCNL DCSP pattern = pattern.lower() DCNL DCSP return (((pattern[0] == '.') and (host.endswith(pattern) or (host == pattern[1:]))) or (pattern == host))
 DCSP if ((pkg_or_module is None) or (pkg_or_module.__name__ == '__main__')): DCNL DCSP  DCSP return '__main__' DCNL DCSP pkg_name = pkg_or_module.__name__ DCNL DCSP pkg_filename = getattr(pkg_or_module, '__file__', None) DCNL DCSP if (pkg_filename is None): DCNL DCSP  DCSP return pkg_name DCNL DCSP splitted = os.path.split(pkg_filename) DCNL DCSP if (splitted[(-1)] in init_names): DCNL DCSP  DCSP return pkg_name DCNL DCSP return pkg_name.rsplit('.', 1)[0]
 DCSP pkg_name = package_name(pkg_or_module) DCNL DCSP __import__(pkg_name) DCNL DCSP return sys.modules[pkg_name]
 DCSP return Response('route')
 DCSP return Response('global')
 DCSP return Response('global2')
 DCSP return Response('route2')
 DCSP return Response('supressed')
 DCSP return Response('supressed2')
 DCSP raise RuntimeError()
 DCSP raise SubException()
 DCSP return Response('rdf')
 DCSP return Response('juri')
 DCSP return Response('fixture')
 DCSP raise RuntimeError()
 DCSP return Response('supressed')
 DCSP raise HTTPForbidden()
 DCSP return '123'
 DCSP name = '_LOCALE_' DCNL DCSP locale_name = getattr(request, name, None) DCNL DCSP if (locale_name is None): DCNL DCSP  DCSP locale_name = request.params.get(name) DCNL DCSP  DCSP if (locale_name is None): DCNL DCSP  DCSP  DCSP locale_name = request.cookies.get(name) DCNL DCSP return locale_name
 DCSP try: DCNL DCSP  DCSP registry = request.registry DCNL DCSP except AttributeError: DCNL DCSP  DCSP registry = get_current_registry() DCNL DCSP negotiator = registry.queryUtility(ILocaleNegotiator, default=default_locale_negotiator) DCNL DCSP locale_name = negotiator(request) DCNL DCSP if (locale_name is None): DCNL DCSP  DCSP settings = (registry.settings or {}) DCNL DCSP  DCSP locale_name = settings.get('default_locale_name', 'en') DCNL DCSP return locale_name
 DCSP return request.locale_name
 DCSP translations = Translations() DCNL DCSP translations._catalog = {} DCNL DCSP locales_to_try = [] DCNL DCSP if ('_' in current_locale_name): DCNL DCSP  DCSP locales_to_try = [current_locale_name.split('_')[0]] DCNL DCSP locales_to_try.append(current_locale_name) DCNL DCSP for tdir in translation_directories: DCNL DCSP  DCSP locale_dirs = [] DCNL DCSP  DCSP for lname in locales_to_try: DCNL DCSP  DCSP  DCSP ldir = os.path.realpath(os.path.join(tdir, lname)) DCNL DCSP  DCSP  DCSP if os.path.isdir(ldir): DCNL DCSP  DCSP  DCSP  DCSP locale_dirs.append(ldir) DCNL DCSP  DCSP for locale_dir in locale_dirs: DCNL DCSP  DCSP  DCSP messages_dir = os.path.join(locale_dir, 'LC_MESSAGES') DCNL DCSP  DCSP  DCSP if (not os.path.isdir(os.path.realpath(messages_dir))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for mofile in os.listdir(messages_dir): DCNL DCSP  DCSP  DCSP  DCSP mopath = os.path.realpath(os.path.join(messages_dir, mofile)) DCNL DCSP  DCSP  DCSP  DCSP if (mofile.endswith('.mo') and os.path.isfile(mopath)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(mopath, 'rb') as mofp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP domain = mofile[:(-3)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dtrans = Translations(mofp, domain) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP translations.add(dtrans) DCNL DCSP return Localizer(locale_name=current_locale_name, translations=translations)
 DCSP return request.localizer
 DCSP try: DCNL DCSP  DCSP query = query.items() DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP result = '' DCNL DCSP prefix = '' DCNL DCSP for (k, v) in query: DCNL DCSP  DCSP k = quote_via(k) DCNL DCSP  DCSP if is_nonstr_iter(v): DCNL DCSP  DCSP  DCSP for x in v: DCNL DCSP  DCSP  DCSP  DCSP x = quote_via(x) DCNL DCSP  DCSP  DCSP  DCSP result += ('%s%s=%s' % (prefix, k, x)) DCNL DCSP  DCSP  DCSP  DCSP prefix = '&' DCNL DCSP  DCSP elif (v is None): DCNL DCSP  DCSP  DCSP result += ('%s%s=' % (prefix, k)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP v = quote_via(v) DCNL DCSP  DCSP  DCSP result += ('%s%s=%s' % (prefix, k, v)) DCNL DCSP  DCSP prefix = '&' DCNL DCSP return result
 DCSP for location in lineage(resource): DCNL DCSP  DCSP if (location.__parent__ is None): DCNL DCSP  DCSP  DCSP resource = location DCNL DCSP  DCSP  DCSP break DCNL DCSP return resource
 DCSP if isinstance(path, text_type): DCNL DCSP  DCSP path = ascii_native_(path) DCNL DCSP D = traverse(resource, path) DCNL DCSP view_name = D['view_name'] DCNL DCSP context = D['context'] DCNL DCSP if view_name: DCNL DCSP  DCSP raise KeyError(('%r DCSP has DCSP no DCSP subelement DCSP %s' % (context, view_name))) DCNL DCSP return context
 DCSP if IInterface.providedBy(class_or_interface): DCNL DCSP  DCSP test = class_or_interface.providedBy DCNL DCSP else: DCNL DCSP  DCSP test = (lambda arg: isinstance(arg, class_or_interface)) DCNL DCSP for location in lineage(resource): DCNL DCSP  DCSP if test(location): DCNL DCSP  DCSP  DCSP return location
 DCSP return _join_path_tuple(resource_path_tuple(resource, *elements))
 DCSP if is_nonstr_iter(path): DCNL DCSP  DCSP if path: DCNL DCSP  DCSP  DCSP path = _join_path_tuple(tuple(path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = '' DCNL DCSP path = ascii_native_(path) DCNL DCSP if (path and (path[0] == '/')): DCNL DCSP  DCSP resource = find_root(resource) DCNL DCSP reg = get_current_registry() DCNL DCSP request_factory = reg.queryUtility(IRequestFactory) DCNL DCSP if (request_factory is None): DCNL DCSP  DCSP from pyramid.request import Request DCNL DCSP  DCSP request_factory = Request DCNL DCSP request = request_factory.blank(path) DCNL DCSP request.registry = reg DCNL DCSP traverser = reg.queryAdapter(resource, ITraverser) DCNL DCSP if (traverser is None): DCNL DCSP  DCSP traverser = ResourceTreeTraverser(resource) DCNL DCSP return traverser(request)
 DCSP return tuple(_resource_path_list(resource, *elements))
 DCSP path = [(loc.__name__ or '') for loc in lineage(resource)] DCNL DCSP path.reverse() DCNL DCSP path.extend(elements) DCNL DCSP return path
 DCSP try: DCNL DCSP  DCSP reg = request.registry DCNL DCSP except AttributeError: DCNL DCSP  DCSP reg = get_current_registry() DCNL DCSP url_adapter = reg.queryMultiAdapter((resource, request), IResourceURL) DCNL DCSP if (url_adapter is None): DCNL DCSP  DCSP url_adapter = ResourceURL(resource, request) DCNL DCSP (vpath, rpath) = (url_adapter.virtual_path, url_adapter.physical_path) DCNL DCSP if ((rpath != vpath) and rpath.endswith(vpath)): DCNL DCSP  DCSP vroot_path = rpath[:(- len(vpath))] DCNL DCSP  DCSP return find_resource(resource, vroot_path) DCNL DCSP try: DCNL DCSP  DCSP return request.root DCNL DCSP except AttributeError: DCNL DCSP  DCSP return find_root(resource)
 DCSP if isinstance(path, text_type): DCNL DCSP  DCSP path = path.encode('ascii') DCNL DCSP path = unquote_bytes_to_wsgi(path) DCNL DCSP return traversal_path_info(path)
 DCSP try: DCNL DCSP  DCSP path = decode_path_info(path) DCNL DCSP except UnicodeDecodeError as e: DCNL DCSP  DCSP raise URLDecodeError(e.encoding, e.object, e.start, e.end, e.reason) DCNL DCSP return split_path_info(path)
 DCSP if (state is None): DCNL DCSP  DCSP state = ConflictResolverState() DCNL DCSP state.remaining_actions.extend(normalize_actions(actions)) DCNL DCSP actions = state.remaining_actions DCNL DCSP def orderandpos(v): DCNL DCSP  DCSP (n, v) = v DCNL DCSP  DCSP return ((v['order'] or 0), n) DCNL DCSP def orderonly(v): DCNL DCSP  DCSP (n, v) = v DCNL DCSP  DCSP return (v['order'] or 0) DCNL DCSP sactions = sorted(enumerate(actions, start=state.start), key=orderandpos) DCNL DCSP for (order, actiongroup) in itertools.groupby(sactions, orderonly): DCNL DCSP  DCSP output = [] DCNL DCSP  DCSP unique = {} DCNL DCSP  DCSP if ((state.min_order is not None) and (order < state.min_order)): DCNL DCSP  DCSP  DCSP r = ['Actions DCSP were DCSP added DCSP to DCSP order={0} DCSP after DCSP execution DCSP had DCSP moved DCSP on DCSP to DCSP order={1}. DCSP Conflicting DCSP actions: DCSP '.format(order, state.min_order)] DCNL DCSP  DCSP  DCSP for (i, action) in actiongroup: DCNL DCSP  DCSP  DCSP  DCSP for line in str(action['info']).rstrip().split('\n'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP r.append((' DCSP  DCSP ' + line)) DCNL DCSP  DCSP  DCSP raise ConfigurationError('\n'.join(r)) DCNL DCSP  DCSP for (i, action) in actiongroup: DCNL DCSP  DCSP  DCSP ainfo = (i, action) DCNL DCSP  DCSP  DCSP discriminator = undefer(action['discriminator']) DCNL DCSP  DCSP  DCSP action['discriminator'] = discriminator DCNL DCSP  DCSP  DCSP if (discriminator is None): DCNL DCSP  DCSP  DCSP  DCSP output.append(ainfo) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP L = unique.setdefault(discriminator, []) DCNL DCSP  DCSP  DCSP L.append(ainfo) DCNL DCSP  DCSP conflicts = {} DCNL DCSP  DCSP for (discriminator, ainfos) in unique.items(): DCNL DCSP  DCSP  DCSP def bypath(ainfo): DCNL DCSP  DCSP  DCSP  DCSP (path, i) = (ainfo[1]['includepath'], ainfo[0]) DCNL DCSP  DCSP  DCSP  DCSP return (path, order, i) DCNL DCSP  DCSP  DCSP ainfos.sort(key=bypath) DCNL DCSP  DCSP  DCSP (ainfo, rest) = (ainfos[0], ainfos[1:]) DCNL DCSP  DCSP  DCSP (_, action) = ainfo DCNL DCSP  DCSP  DCSP prev_ainfo = state.resolved_ainfos.get(discriminator) DCNL DCSP  DCSP  DCSP if (prev_ainfo is not None): DCNL DCSP  DCSP  DCSP  DCSP (_, paction) = prev_ainfo DCNL DCSP  DCSP  DCSP  DCSP (basepath, baseinfo) = (paction['includepath'], paction['info']) DCNL DCSP  DCSP  DCSP  DCSP includepath = action['includepath'] DCNL DCSP  DCSP  DCSP  DCSP if ((includepath[:len(basepath)] != basepath) or (includepath == basepath)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP L = conflicts.setdefault(discriminator, [baseinfo]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP L.append(action['info']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP output.append(ainfo) DCNL DCSP  DCSP  DCSP (basepath, baseinfo) = (action['includepath'], action['info']) DCNL DCSP  DCSP  DCSP for (_, action) in rest: DCNL DCSP  DCSP  DCSP  DCSP includepath = action['includepath'] DCNL DCSP  DCSP  DCSP  DCSP if ((includepath[:len(basepath)] != basepath) or (includepath == basepath)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP L = conflicts.setdefault(discriminator, [baseinfo]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP L.append(action['info']) DCNL DCSP  DCSP if conflicts: DCNL DCSP  DCSP  DCSP raise ConfigurationConflictError(conflicts) DCNL DCSP  DCSP for (i, action) in sorted(output, key=operator.itemgetter(0)): DCNL DCSP  DCSP  DCSP state.min_order = action['order'] DCNL DCSP  DCSP  DCSP state.start = (i + 1) DCNL DCSP  DCSP  DCSP state.remaining_actions.remove(action) DCNL DCSP  DCSP  DCSP state.resolved_ainfos[action['discriminator']] = (i, action) DCNL DCSP  DCSP  DCSP (yield action)
 DCSP result = [] DCNL DCSP for v in actions: DCNL DCSP  DCSP if (not isinstance(v, dict)): DCNL DCSP  DCSP  DCSP v = expand_action_tuple(*v) DCNL DCSP  DCSP result.append(v) DCNL DCSP return result
 DCSP if (d is None): DCNL DCSP  DCSP d = {} DCNL DCSP d = dict(d) DCNL DCSP d.update(**kw) DCNL DCSP eget = _environ_.get DCNL DCSP def expand_key(key): DCNL DCSP  DCSP keys = [key] DCNL DCSP  DCSP if (not key.startswith('pyramid.')): DCNL DCSP  DCSP  DCSP keys.append(('pyramid.' + key)) DCNL DCSP  DCSP return keys DCNL DCSP def S(settings_key, env_key=None, type_=str, default=False): DCNL DCSP  DCSP value = default DCNL DCSP  DCSP keys = expand_key(settings_key) DCNL DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP value = d.get(key, value) DCNL DCSP  DCSP if env_key: DCNL DCSP  DCSP  DCSP value = eget(env_key, value) DCNL DCSP  DCSP value = type_(value) DCNL DCSP  DCSP d.update({k: value for k in keys}) DCNL DCSP def O(settings_key, override_key): DCNL DCSP  DCSP for key in expand_key(settings_key): DCNL DCSP  DCSP  DCSP d[key] = (d[key] or d[override_key]) DCNL DCSP S('debug_all', 'PYRAMID_DEBUG_ALL', asbool) DCNL DCSP S('debug_authorization', 'PYRAMID_DEBUG_AUTHORIZATION', asbool) DCNL DCSP O('debug_authorization', 'debug_all') DCNL DCSP S('debug_notfound', 'PYRAMID_DEBUG_NOTFOUND', asbool) DCNL DCSP O('debug_notfound', 'debug_all') DCNL DCSP S('debug_routematch', 'PYRAMID_DEBUG_ROUTEMATCH', asbool) DCNL DCSP O('debug_routematch', 'debug_all') DCNL DCSP S('debug_templates', 'PYRAMID_DEBUG_TEMPLATES', asbool) DCNL DCSP O('debug_templates', 'debug_all') DCNL DCSP S('reload_all', 'PYRAMID_RELOAD_ALL', asbool) DCNL DCSP S('reload_templates', 'PYRAMID_RELOAD_TEMPLATES', asbool) DCNL DCSP O('reload_templates', 'reload_all') DCNL DCSP S('reload_assets', 'PYRAMID_RELOAD_ASSETS', asbool) DCNL DCSP O('reload_assets', 'reload_all') DCNL DCSP S('reload_resources', 'PYRAMID_RELOAD_RESOURCES', asbool) DCNL DCSP O('reload_resources', 'reload_all') DCNL DCSP for k in (expand_key('reload_assets') + expand_key('reload_resources')): DCNL DCSP  DCSP d[k] = (d['reload_assets'] or d['reload_resources']) DCNL DCSP S('default_locale_name', 'PYRAMID_DEFAULT_LOCALE_NAME', str, 'en') DCNL DCSP S('prevent_http_cache', 'PYRAMID_PREVENT_HTTP_CACHE', asbool) DCNL DCSP S('prevent_cachebust', 'PYRAMID_PREVENT_CACHEBUST', asbool) DCNL DCSP S('csrf_trusted_origins', 'PYRAMID_CSRF_TRUSTED_ORIGINS', aslist, []) DCNL DCSP return d
 DCSP if (s is None): DCNL DCSP  DCSP return False DCNL DCSP if isinstance(s, bool): DCNL DCSP  DCSP return s DCNL DCSP s = str(s).strip() DCNL DCSP return (s.lower() in truthy)
 DCSP values = aslist_cronly(value) DCNL DCSP if (not flatten): DCNL DCSP  DCSP return values DCNL DCSP result = [] DCNL DCSP for value in values: DCNL DCSP  DCSP subvalues = value.split() DCNL DCSP  DCSP result.extend(subvalues) DCNL DCSP return result
 DCSP def accessed(session, *arg, **kw): DCNL DCSP  DCSP session.accessed = now = int(time.time()) DCNL DCSP  DCSP if (session._reissue_time is not None): DCNL DCSP  DCSP  DCSP if ((now - session.renewed) > session._reissue_time): DCNL DCSP  DCSP  DCSP  DCSP session.changed() DCNL DCSP  DCSP return wrapped(session, *arg, **kw) DCNL DCSP accessed.__doc__ = wrapped.__doc__ DCNL DCSP return accessed
 DCSP def changed(session, *arg, **kw): DCNL DCSP  DCSP session.accessed = int(time.time()) DCNL DCSP  DCSP session.changed() DCNL DCSP  DCSP return wrapped(session, *arg, **kw) DCNL DCSP changed.__doc__ = wrapped.__doc__ DCNL DCSP return changed
 DCSP pickled = pickle.dumps(data, pickle.HIGHEST_PROTOCOL) DCNL DCSP try: DCNL DCSP  DCSP secret = bytes_(secret) DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP secret = bytes_(secret, 'utf-8') DCNL DCSP sig = hmac.new(secret, pickled, hashlib.sha1).hexdigest() DCNL DCSP return (sig + native_(base64.b64encode(pickled)))
 DCSP try: DCNL DCSP  DCSP (input_sig, pickled) = (bytes_(serialized[:40]), base64.b64decode(bytes_(serialized[40:]))) DCNL DCSP except (binascii.Error, TypeError) as e: DCNL DCSP  DCSP raise ValueError(('Badly DCSP formed DCSP base64 DCSP data: DCSP %s' % e)) DCNL DCSP try: DCNL DCSP  DCSP secret = bytes_(secret) DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP secret = bytes_(secret, 'utf-8') DCNL DCSP sig = bytes_(hmac.new(secret, pickled, hashlib.sha1).hexdigest()) DCNL DCSP if strings_differ(sig, input_sig): DCNL DCSP  DCSP raise ValueError('Invalid DCSP signature') DCNL DCSP return pickle.loads(pickled)
 DCSP @implementer(ISession) DCNL DCSP class CookieSession(dict, ): DCNL DCSP  DCSP ' DCSP Dictionary-like DCSP session DCSP object DCSP ' DCNL DCSP  DCSP _cookie_name = cookie_name DCNL DCSP  DCSP _cookie_max_age = (max_age if (max_age is None) else int(max_age)) DCNL DCSP  DCSP _cookie_path = path DCNL DCSP  DCSP _cookie_domain = domain DCNL DCSP  DCSP _cookie_secure = secure DCNL DCSP  DCSP _cookie_httponly = httponly DCNL DCSP  DCSP _cookie_on_exception = set_on_exception DCNL DCSP  DCSP _timeout = (timeout if (timeout is None) else int(timeout)) DCNL DCSP  DCSP _reissue_time = (reissue_time if (reissue_time is None) else int(reissue_time)) DCNL DCSP  DCSP _dirty = False DCNL DCSP  DCSP def __init__(self, request): DCNL DCSP  DCSP  DCSP self.request = request DCNL DCSP  DCSP  DCSP now = time.time() DCNL DCSP  DCSP  DCSP created = renewed = now DCNL DCSP  DCSP  DCSP new = True DCNL DCSP  DCSP  DCSP value = None DCNL DCSP  DCSP  DCSP state = {} DCNL DCSP  DCSP  DCSP cookieval = request.cookies.get(self._cookie_name) DCNL DCSP  DCSP  DCSP if (cookieval is not None): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = serializer.loads(bytes_(cookieval)) DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = None DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (rval, cval, sval) = value DCNL DCSP  DCSP  DCSP  DCSP  DCSP renewed = float(rval) DCNL DCSP  DCSP  DCSP  DCSP  DCSP created = float(cval) DCNL DCSP  DCSP  DCSP  DCSP  DCSP state = sval DCNL DCSP  DCSP  DCSP  DCSP  DCSP new = False DCNL DCSP  DCSP  DCSP  DCSP except (TypeError, ValueError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state = {} DCNL DCSP  DCSP  DCSP if (self._timeout is not None): DCNL DCSP  DCSP  DCSP  DCSP if ((now - renewed) > self._timeout): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state = {} DCNL DCSP  DCSP  DCSP self.created = created DCNL DCSP  DCSP  DCSP self.accessed = renewed DCNL DCSP  DCSP  DCSP self.renewed = renewed DCNL DCSP  DCSP  DCSP self.new = new DCNL DCSP  DCSP  DCSP dict.__init__(self, state) DCNL DCSP  DCSP def changed(self): DCNL DCSP  DCSP  DCSP if (not self._dirty): DCNL DCSP  DCSP  DCSP  DCSP self._dirty = True DCNL DCSP  DCSP  DCSP  DCSP def set_cookie_callback(request, response): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._set_cookie(response) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.request = None DCNL DCSP  DCSP  DCSP  DCSP self.request.add_response_callback(set_cookie_callback) DCNL DCSP  DCSP def invalidate(self): DCNL DCSP  DCSP  DCSP self.clear() DCNL DCSP  DCSP get = manage_accessed(dict.get) DCNL DCSP  DCSP __getitem__ = manage_accessed(dict.__getitem__) DCNL DCSP  DCSP items = manage_accessed(dict.items) DCNL DCSP  DCSP values = manage_accessed(dict.values) DCNL DCSP  DCSP keys = manage_accessed(dict.keys) DCNL DCSP  DCSP __contains__ = manage_accessed(dict.__contains__) DCNL DCSP  DCSP __len__ = manage_accessed(dict.__len__) DCNL DCSP  DCSP __iter__ = manage_accessed(dict.__iter__) DCNL DCSP  DCSP if PY2: DCNL DCSP  DCSP  DCSP iteritems = manage_accessed(dict.iteritems) DCNL DCSP  DCSP  DCSP itervalues = manage_accessed(dict.itervalues) DCNL DCSP  DCSP  DCSP iterkeys = manage_accessed(dict.iterkeys) DCNL DCSP  DCSP  DCSP has_key = manage_accessed(dict.has_key) DCNL DCSP  DCSP clear = manage_changed(dict.clear) DCNL DCSP  DCSP update = manage_changed(dict.update) DCNL DCSP  DCSP setdefault = manage_changed(dict.setdefault) DCNL DCSP  DCSP pop = manage_changed(dict.pop) DCNL DCSP  DCSP popitem = manage_changed(dict.popitem) DCNL DCSP  DCSP __setitem__ = manage_changed(dict.__setitem__) DCNL DCSP  DCSP __delitem__ = manage_changed(dict.__delitem__) DCNL DCSP  DCSP @manage_changed DCNL DCSP  DCSP def flash(self, msg, queue='', allow_duplicate=True): DCNL DCSP  DCSP  DCSP storage = self.setdefault(('_f_' + queue), []) DCNL DCSP  DCSP  DCSP if (allow_duplicate or (msg not in storage)): DCNL DCSP  DCSP  DCSP  DCSP storage.append(msg) DCNL DCSP  DCSP @manage_changed DCNL DCSP  DCSP def pop_flash(self, queue=''): DCNL DCSP  DCSP  DCSP storage = self.pop(('_f_' + queue), []) DCNL DCSP  DCSP  DCSP return storage DCNL DCSP  DCSP @manage_accessed DCNL DCSP  DCSP def peek_flash(self, queue=''): DCNL DCSP  DCSP  DCSP storage = self.get(('_f_' + queue), []) DCNL DCSP  DCSP  DCSP return storage DCNL DCSP  DCSP @manage_changed DCNL DCSP  DCSP def new_csrf_token(self): DCNL DCSP  DCSP  DCSP token = text_(binascii.hexlify(os.urandom(20))) DCNL DCSP  DCSP  DCSP self['_csrft_'] = token DCNL DCSP  DCSP  DCSP return token DCNL DCSP  DCSP @manage_accessed DCNL DCSP  DCSP def get_csrf_token(self): DCNL DCSP  DCSP  DCSP token = self.get('_csrft_', None) DCNL DCSP  DCSP  DCSP if (token is None): DCNL DCSP  DCSP  DCSP  DCSP token = self.new_csrf_token() DCNL DCSP  DCSP  DCSP return token DCNL DCSP  DCSP def _set_cookie(self, response): DCNL DCSP  DCSP  DCSP if (not self._cookie_on_exception): DCNL DCSP  DCSP  DCSP  DCSP exception = getattr(self.request, 'exception', None) DCNL DCSP  DCSP  DCSP  DCSP if (exception is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP cookieval = native_(serializer.dumps((self.accessed, self.created, dict(self)))) DCNL DCSP  DCSP  DCSP if (len(cookieval) > 4064): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Cookie DCSP value DCSP is DCSP too DCSP long DCSP to DCSP store DCSP (%s DCSP bytes)' % len(cookieval))) DCNL DCSP  DCSP  DCSP response.set_cookie(self._cookie_name, value=cookieval, max_age=self._cookie_max_age, path=self._cookie_path, domain=self._cookie_domain, secure=self._cookie_secure, httponly=self._cookie_httponly) DCNL DCSP  DCSP  DCSP return True DCNL DCSP return CookieSession
 DCSP class SerializerWrapper(object, ): DCNL DCSP  DCSP def __init__(self, secret): DCNL DCSP  DCSP  DCSP self.secret = secret DCNL DCSP  DCSP def loads(self, bstruct): DCNL DCSP  DCSP  DCSP return signed_deserialize(bstruct, secret) DCNL DCSP  DCSP def dumps(self, appstruct): DCNL DCSP  DCSP  DCSP return signed_serialize(appstruct, secret) DCNL DCSP serializer = SerializerWrapper(secret) DCNL DCSP return BaseCookieSessionFactory(serializer, cookie_name=cookie_name, max_age=cookie_max_age, path=cookie_path, domain=cookie_domain, secure=cookie_secure, httponly=cookie_httponly, timeout=timeout, reissue_time=0, set_on_exception=cookie_on_exception)
 DCSP if (serializer is None): DCNL DCSP  DCSP serializer = PickleSerializer() DCNL DCSP signed_serializer = SignedSerializer(secret, salt, hashalg, serializer=serializer) DCNL DCSP return BaseCookieSessionFactory(signed_serializer, cookie_name=cookie_name, max_age=max_age, path=path, domain=domain, secure=secure, httponly=httponly, timeout=timeout, reissue_time=reissue_time, set_on_exception=set_on_exception)
 DCSP manager.clear() DCNL DCSP if (registry is None): DCNL DCSP  DCSP registry = Registry('testing') DCNL DCSP if (package is None): DCNL DCSP  DCSP package = caller_package() DCNL DCSP config = Configurator(registry=registry, autocommit=autocommit, package=package) DCNL DCSP if (settings is None): DCNL DCSP  DCSP settings = {} DCNL DCSP if (getattr(registry, 'settings', None) is None): DCNL DCSP  DCSP config._set_settings(settings) DCNL DCSP if hasattr(registry, 'registerUtility'): DCNL DCSP  DCSP config.add_default_renderers() DCNL DCSP  DCSP config.add_default_view_predicates() DCNL DCSP  DCSP config.add_default_view_derivers() DCNL DCSP  DCSP config.add_default_route_predicates() DCNL DCSP  DCSP config.add_default_tweens() DCNL DCSP  DCSP config.add_default_security() DCNL DCSP config.commit() DCNL DCSP global have_zca DCNL DCSP try: DCNL DCSP  DCSP (have_zca and hook_zca and config.hook_zca()) DCNL DCSP except ImportError: DCNL DCSP  DCSP have_zca = False DCNL DCSP config.begin(request=request) DCNL DCSP return config
 DCSP global have_zca DCNL DCSP if (unhook_zca and have_zca): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from zope.component import getSiteManager DCNL DCSP  DCSP  DCSP getSiteManager.reset() DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP have_zca = False DCNL DCSP info = manager.pop() DCNL DCSP manager.clear() DCNL DCSP if (info is not None): DCNL DCSP  DCSP registry = info['registry'] DCNL DCSP  DCSP if (hasattr(registry, '__init__') and hasattr(registry, '__name__')): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP registry.__init__(registry.__name__) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP pass
 DCSP package = kw.get('package', None) DCNL DCSP if (package is None): DCNL DCSP  DCSP package = caller_package() DCNL DCSP  DCSP kw['package'] = package DCNL DCSP return setUp(*arg, **kw)
 DCSP config = setUp(registry=registry, request=request, hook_zca=hook_zca, autocommit=autocommit, settings=settings) DCNL DCSP try: DCNL DCSP  DCSP (yield config) DCNL DCSP finally: DCNL DCSP  DCSP tearDown(unhook_zca=hook_zca)
 DCSP result = {} DCNL DCSP for arg in args: DCNL DCSP  DCSP if ('=' not in arg): DCNL DCSP  DCSP  DCSP raise ValueError(('Variable DCSP assignment DCSP %r DCSP invalid DCSP (no DCSP "=")' % arg)) DCNL DCSP  DCSP (name, value) = arg.split('=', 1) DCNL DCSP  DCSP result[name] = value DCNL DCSP return result
 DCSP return plaster.get_loader(config_uri, protocols=['wsgi'])
 DCSP is_ssl = False DCNL DCSP if ssl_pem: DCNL DCSP  DCSP port = (port or 4443) DCNL DCSP  DCSP is_ssl = True DCNL DCSP if (not port): DCNL DCSP  DCSP if (':' in host): DCNL DCSP  DCSP  DCSP (host, port) = host.split(':', 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = 8080 DCNL DCSP bind_addr = (host, int(port)) DCNL DCSP kwargs = {} DCNL DCSP for var_name in ('numthreads', 'max', 'request_queue_size', 'timeout'): DCNL DCSP  DCSP var = locals()[var_name] DCNL DCSP  DCSP if (var is not None): DCNL DCSP  DCSP  DCSP kwargs[var_name] = int(var) DCNL DCSP from cherrypy import wsgiserver DCNL DCSP server = wsgiserver.CherryPyWSGIServer(bind_addr, app, server_name=server_name, **kwargs) DCNL DCSP if (ssl_pem is not None): DCNL DCSP  DCSP if PY2: DCNL DCSP  DCSP  DCSP server.ssl_certificate = server.ssl_private_key = ssl_pem DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP wsgiserver.get_ssl_adapter_class() DCNL DCSP  DCSP  DCSP server.ssl_adapter = wsgiserver.ssl_builtin.BuiltinSSLAdapter(ssl_pem, ssl_pem) DCNL DCSP if protocol_version: DCNL DCSP  DCSP server.protocol = protocol_version DCNL DCSP try: DCNL DCSP  DCSP protocol = ((is_ssl and 'https') or 'http') DCNL DCSP  DCSP if (host == '0.0.0.0'): DCNL DCSP  DCSP  DCSP print ('serving DCSP on DCSP 0.0.0.0:%s DCSP view DCSP at DCSP %s://127.0.0.1:%s' % (port, protocol, port)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print ('serving DCSP on DCSP %s://%s:%s' % (protocol, host, port)) DCNL DCSP  DCSP server.start() DCNL DCSP except (KeyboardInterrupt, SystemExit): DCNL DCSP  DCSP server.stop() DCNL DCSP return server
 DCSP while (resource1 is not None): DCNL DCSP  DCSP if (resource1 is resource2): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP resource1 = resource1.__parent__ DCNL DCSP return False
 DCSP while (resource is not None): DCNL DCSP  DCSP (yield resource) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP resource = resource.__parent__ DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP resource = None
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.include('.models') DCNL DCSP config.include('.routes') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP config.add_route('home', '/') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP def out(msg): DCNL DCSP  DCSP out_.write(msg) DCNL DCSP  DCSP out_.write('\n') DCNL DCSP  DCSP out_.flush() DCNL DCSP vars.setdefault('dot', '.') DCNL DCSP vars.setdefault('plus', '+') DCNL DCSP use_pkg_resources = isinstance(source, tuple) DCNL DCSP if use_pkg_resources: DCNL DCSP  DCSP names = sorted(pkg_resources.resource_listdir(source[0], source[1])) DCNL DCSP else: DCNL DCSP  DCSP names = sorted(os.listdir(source)) DCNL DCSP pad = (' DCSP ' * (indent * 2)) DCNL DCSP if (not os.path.exists(dest)): DCNL DCSP  DCSP if (verbosity >= 1): DCNL DCSP  DCSP  DCSP out(('%sCreating DCSP %s/' % (pad, dest))) DCNL DCSP  DCSP if (not simulate): DCNL DCSP  DCSP  DCSP makedirs(dest, verbosity=verbosity, pad=pad) DCNL DCSP elif (verbosity >= 2): DCNL DCSP  DCSP out(('%sDirectory DCSP %s DCSP exists' % (pad, dest))) DCNL DCSP for name in names: DCNL DCSP  DCSP if use_pkg_resources: DCNL DCSP  DCSP  DCSP full = '/'.join([source[1], name]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP full = os.path.join(source, name) DCNL DCSP  DCSP reason = should_skip_file(name) DCNL DCSP  DCSP if reason: DCNL DCSP  DCSP  DCSP if (verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP reason = (pad + (reason % {'filename': full})) DCNL DCSP  DCSP  DCSP  DCSP out(reason) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if sub_vars: DCNL DCSP  DCSP  DCSP dest_full = os.path.join(dest, substitute_filename(name, vars)) DCNL DCSP  DCSP sub_file = False DCNL DCSP  DCSP if dest_full.endswith('_tmpl'): DCNL DCSP  DCSP  DCSP dest_full = dest_full[:(-5)] DCNL DCSP  DCSP  DCSP sub_file = sub_vars DCNL DCSP  DCSP if (use_pkg_resources and pkg_resources.resource_isdir(source[0], full)): DCNL DCSP  DCSP  DCSP if verbosity: DCNL DCSP  DCSP  DCSP  DCSP out(('%sRecursing DCSP into DCSP %s' % (pad, os.path.basename(full)))) DCNL DCSP  DCSP  DCSP copy_dir((source[0], full), dest_full, vars, verbosity, simulate, indent=(indent + 1), sub_vars=sub_vars, interactive=interactive, overwrite=overwrite, template_renderer=template_renderer, out_=out_) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((not use_pkg_resources) and os.path.isdir(full)): DCNL DCSP  DCSP  DCSP if verbosity: DCNL DCSP  DCSP  DCSP  DCSP out(('%sRecursing DCSP into DCSP %s' % (pad, os.path.basename(full)))) DCNL DCSP  DCSP  DCSP copy_dir(full, dest_full, vars, verbosity, simulate, indent=(indent + 1), sub_vars=sub_vars, interactive=interactive, overwrite=overwrite, template_renderer=template_renderer, out_=out_) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif use_pkg_resources: DCNL DCSP  DCSP  DCSP content = pkg_resources.resource_string(source[0], full) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP with open(full, 'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP content = f.read() DCNL DCSP  DCSP if sub_file: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP content = substitute_content(content, vars, filename=full, template_renderer=template_renderer) DCNL DCSP  DCSP  DCSP except SkipTemplate: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (content is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP already_exists = os.path.exists(dest_full) DCNL DCSP  DCSP if already_exists: DCNL DCSP  DCSP  DCSP with open(dest_full, 'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP old_content = f.read() DCNL DCSP  DCSP  DCSP if (old_content == content): DCNL DCSP  DCSP  DCSP  DCSP if verbosity: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out(('%s%s DCSP already DCSP exists DCSP (same DCSP content)' % (pad, dest_full))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if interactive: DCNL DCSP  DCSP  DCSP  DCSP if (not query_interactive(native_(full, fsenc), native_(dest_full, fsenc), native_(content, fsenc), native_(old_content, fsenc), simulate=simulate, out_=out_)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (not overwrite): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (verbosity and use_pkg_resources): DCNL DCSP  DCSP  DCSP out(('%sCopying DCSP %s DCSP to DCSP %s' % (pad, full, dest_full))) DCNL DCSP  DCSP elif verbosity: DCNL DCSP  DCSP  DCSP out(('%sCopying DCSP %s DCSP to DCSP %s' % (pad, os.path.basename(full), dest_full))) DCNL DCSP  DCSP if (not simulate): DCNL DCSP  DCSP  DCSP with open(dest_full, 'wb') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(content)
 DCSP if name.startswith('.'): DCNL DCSP  DCSP return 'Skipping DCSP hidden DCSP file DCSP %(filename)s' DCNL DCSP if name.endswith(('~', '.bak')): DCNL DCSP  DCSP return 'Skipping DCSP backup DCSP file DCSP %(filename)s' DCNL DCSP if name.endswith(('.pyc', '.pyo')): DCNL DCSP  DCSP return (('Skipping DCSP %s DCSP file DCSP ' % os.path.splitext(name)[1]) + '%(filename)s') DCNL DCSP if name.endswith('$py.class'): DCNL DCSP  DCSP return 'Skipping DCSP $py.class DCSP file DCSP %(filename)s' DCNL DCSP if (name in ('CVS', '_darcs')): DCNL DCSP  DCSP return 'Skipping DCSP version DCSP control DCSP directory DCSP %(filename)s' DCNL DCSP return None
 DCSP if condition: DCNL DCSP  DCSP raise SkipTemplate(*args)
 DCSP config = Configurator(root_factory=root_factory, settings=settings) DCNL DCSP settings = config.get_settings() DCNL DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP config.include('pyramid_chameleon') DCNL DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP if (wrapped is None): DCNL DCSP  DCSP raise ValueError('wrapped DCSP can DCSP not DCSP be DCSP None') DCNL DCSP def decorator(context, request): DCNL DCSP  DCSP return request.get_response(wrapped) DCNL DCSP if getattr(wrapped, '__name__', None): DCNL DCSP  DCSP return wraps(wrapped)(decorator) DCNL DCSP return wraps(wrapped, ('__module__', '__doc__'))(decorator)
 DCSP if (wrapped is None): DCNL DCSP  DCSP raise ValueError('wrapped DCSP can DCSP not DCSP be DCSP None') DCNL DCSP def decorator(context, request): DCNL DCSP  DCSP return call_app_with_subpath_as_path_info(request, wrapped) DCNL DCSP if getattr(wrapped, '__name__', None): DCNL DCSP  DCSP return wraps(wrapped)(decorator) DCNL DCSP return wraps(wrapped, ('__module__', '__doc__'))(decorator)
 DCSP loader = get_config_loader(config_uri) DCNL DCSP loader.setup_logging(global_conf)
 DCSP loader = get_config_loader(config_uri) DCNL DCSP return loader.get_wsgi_app(name, options)
 DCSP loader = get_config_loader(config_uri) DCNL DCSP return loader.get_wsgi_app_settings(name, options)
 DCSP app = get_app(config_uri, options=options) DCNL DCSP env = prepare(request) DCNL DCSP env['app'] = app DCNL DCSP return env
 DCSP try: DCNL DCSP  DCSP registry = request.registry DCNL DCSP except AttributeError: DCNL DCSP  DCSP registry = None DCNL DCSP if (package is None): DCNL DCSP  DCSP package = caller_package() DCNL DCSP helper = RendererHelper(name=renderer_name, package=package, registry=registry) DCNL DCSP with hide_attrs(request, 'response'): DCNL DCSP  DCSP result = helper.render(value, None, request=request) DCNL DCSP return result
 DCSP try: DCNL DCSP  DCSP registry = request.registry DCNL DCSP except AttributeError: DCNL DCSP  DCSP registry = None DCNL DCSP if (package is None): DCNL DCSP  DCSP package = caller_package() DCNL DCSP helper = RendererHelper(name=renderer_name, package=package, registry=registry) DCNL DCSP with hide_attrs(request, 'response'): DCNL DCSP  DCSP if (response is not None): DCNL DCSP  DCSP  DCSP request.response = response DCNL DCSP  DCSP result = helper.render_to_response(value, None, request=request) DCNL DCSP return result
 DCSP if (package is None): DCNL DCSP  DCSP package = caller_package() DCNL DCSP helper = RendererHelper(name=renderer_name, package=package) DCNL DCSP return helper.renderer
 DCSP ticket = native_(ticket).strip('"') DCNL DCSP digest_size = (hashlib.new(hashalg).digest_size * 2) DCNL DCSP digest = ticket[:digest_size] DCNL DCSP try: DCNL DCSP  DCSP timestamp = int(ticket[digest_size:(digest_size + 8)], 16) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP raise BadTicket(('Timestamp DCSP is DCSP not DCSP a DCSP hex DCSP integer: DCSP %s' % e)) DCNL DCSP try: DCNL DCSP  DCSP (userid, data) = ticket[(digest_size + 8):].split('!', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise BadTicket('userid DCSP is DCSP not DCSP followed DCSP by DCSP !') DCNL DCSP userid = url_unquote(userid) DCNL DCSP if ('!' in data): DCNL DCSP  DCSP (tokens, user_data) = data.split('!', 1) DCNL DCSP else: DCNL DCSP  DCSP tokens = '' DCNL DCSP  DCSP user_data = data DCNL DCSP expected = calculate_digest(ip, timestamp, secret, userid, tokens, user_data, hashalg) DCNL DCSP if strings_differ(expected, digest): DCNL DCSP  DCSP raise BadTicket('Digest DCSP signature DCSP is DCSP not DCSP correct', expected=(expected, digest)) DCNL DCSP tokens = tokens.split(',') DCNL DCSP return (timestamp, userid, tokens, user_data)
 DCSP authorization = request.headers.get('Authorization') DCNL DCSP if (not authorization): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP (authmeth, auth) = authorization.split(' DCSP ', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP if (authmeth.lower() != 'basic'): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP authbytes = b64decode(auth.strip()) DCNL DCSP except (TypeError, binascii.Error): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP auth = authbytes.decode('utf-8') DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP auth = authbytes.decode('latin-1') DCNL DCSP try: DCNL DCSP  DCSP (username, password) = auth.split(':', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP return HTTPBasicCredentials(username, password)
 DCSP registry = request.registry DCNL DCSP csrf = registry.getUtility(ICSRFStoragePolicy) DCNL DCSP return csrf.get_csrf_token(request)
 DCSP registry = request.registry DCNL DCSP csrf = registry.getUtility(ICSRFStoragePolicy) DCNL DCSP return csrf.new_csrf_token(request)
 DCSP supplied_token = '' DCNL DCSP if (header is not None): DCNL DCSP  DCSP supplied_token = request.headers.get(header, '') DCNL DCSP if ((supplied_token == '') and (token is not None)): DCNL DCSP  DCSP supplied_token = request.POST.get(token, '') DCNL DCSP policy = request.registry.getUtility(ICSRFStoragePolicy) DCNL DCSP if (not policy.check_csrf_token(request, text_(supplied_token))): DCNL DCSP  DCSP if raises: DCNL DCSP  DCSP  DCSP raise BadCSRFToken('check_csrf_token(): DCSP Invalid DCSP token') DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP def _fail(reason): DCNL DCSP  DCSP if raises: DCNL DCSP  DCSP  DCSP raise BadCSRFOrigin(reason) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (request.scheme == 'https'): DCNL DCSP  DCSP origin = request.headers.get('Origin') DCNL DCSP  DCSP if (origin is None): DCNL DCSP  DCSP  DCSP origin = request.referrer DCNL DCSP  DCSP if (not origin): DCNL DCSP  DCSP  DCSP return _fail('Origin DCSP checking DCSP failed DCSP - DCSP no DCSP Origin DCSP or DCSP Referer.') DCNL DCSP  DCSP originp = urlparse.urlparse(origin) DCNL DCSP  DCSP if (originp.scheme != 'https'): DCNL DCSP  DCSP  DCSP return _fail('Referer DCSP checking DCSP failed DCSP - DCSP Referer DCSP is DCSP insecure DCSP while DCSP host DCSP is DCSP secure.') DCNL DCSP  DCSP if (trusted_origins is None): DCNL DCSP  DCSP  DCSP trusted_origins = aslist(request.registry.settings.get('pyramid.csrf_trusted_origins', [])) DCNL DCSP  DCSP if (request.host_port not in set(['80', '443'])): DCNL DCSP  DCSP  DCSP trusted_origins.append('{0.domain}:{0.host_port}'.format(request)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP trusted_origins.append(request.domain) DCNL DCSP  DCSP if (not any((is_same_domain(originp.netloc, host) for host in trusted_origins))): DCNL DCSP  DCSP  DCSP reason = 'Referer DCSP checking DCSP failed DCSP - DCSP {0} DCSP does DCSP not DCSP match DCSP any DCSP trusted DCSP origins.' DCNL DCSP  DCSP  DCSP return _fail(reason.format(origin)) DCNL DCSP return True
 DCSP def excview_tween(request): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response = handler(request) DCNL DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP response = _error_handler(request, exc) DCNL DCSP  DCSP return response DCNL DCSP return excview_tween
 DCSP app_url = kw.pop('_app_url', None) DCNL DCSP scheme = kw.pop('_scheme', None) DCNL DCSP host = kw.pop('_host', None) DCNL DCSP port = kw.pop('_port', None) DCNL DCSP query = kw.pop('_query', '') DCNL DCSP anchor = kw.pop('_anchor', '') DCNL DCSP if (app_url is None): DCNL DCSP  DCSP if ((scheme is not None) or (host is not None) or (port is not None)): DCNL DCSP  DCSP  DCSP app_url = request._partial_application_url(scheme, host, port) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP app_url = request.application_url DCNL DCSP qs = '' DCNL DCSP if query: DCNL DCSP  DCSP if isinstance(query, string_types): DCNL DCSP  DCSP  DCSP qs = ('?' + url_quote(query, QUERY_SAFE)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qs = ('?' + urlencode(query, doseq=True)) DCNL DCSP frag = '' DCNL DCSP if anchor: DCNL DCSP  DCSP frag = ('#' + url_quote(anchor, ANCHOR_SAFE)) DCNL DCSP return (app_url, qs, frag)
 DCSP return request.route_url(route_name, *elements, **kw)
 DCSP return request.route_path(route_name, *elements, **kw)
 DCSP return request.resource_url(resource, *elements, **kw)
 DCSP if (not os.path.isabs(path)): DCNL DCSP  DCSP if (':' not in path): DCNL DCSP  DCSP  DCSP package = caller_package() DCNL DCSP  DCSP  DCSP path = ('%s:%s' % (package.__name__, path)) DCNL DCSP return request.static_url(path, **kw)
 DCSP if (not os.path.isabs(path)): DCNL DCSP  DCSP if (':' not in path): DCNL DCSP  DCSP  DCSP package = caller_package() DCNL DCSP  DCSP  DCSP path = ('%s:%s' % (package.__name__, path)) DCNL DCSP return request.static_path(path, **kw)
 DCSP return request.current_route_url(*elements, **kw)
 DCSP return request.current_route_path(*elements, **kw)
 DCSP if isinstance(v, Deferred): DCNL DCSP  DCSP v = v.resolve() DCNL DCSP return v
 DCSP if isinstance(s, binary_type): DCNL DCSP  DCSP return s.decode(encoding, errors) DCNL DCSP return s
 DCSP if isinstance(s, text_type): DCNL DCSP  DCSP return s.encode(encoding, errors) DCNL DCSP return s
 DCSP is_bound = is_bound_method(fn) DCNL DCSP if ((not is_bound) and inspect.isroutine(fn)): DCNL DCSP  DCSP spec = getargspec(fn) DCNL DCSP  DCSP has_self = ((len(spec.args) > 0) and (spec.args[0] == 'self')) DCNL DCSP  DCSP if (PY2 and inspect.ismethod(fn)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP elif (inspect.isfunction(fn) and has_self): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (extensions is None): DCNL DCSP  DCSP extensions = request.registry.queryUtility(IRequestExtensions) DCNL DCSP if (extensions is not None): DCNL DCSP  DCSP for (name, fn) in iteritems_(extensions.methods): DCNL DCSP  DCSP  DCSP method = fn.__get__(request, request.__class__) DCNL DCSP  DCSP  DCSP setattr(request, name, method) DCNL DCSP  DCSP InstancePropertyHelper.apply_properties(request, extensions.descriptors)
 DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP with Configurator(settings=settings) as config: DCNL DCSP  DCSP config.include('pyramid_chameleon') DCNL DCSP  DCSP config.include('pyramid_tm') DCNL DCSP  DCSP config.include('pyramid_retry') DCNL DCSP  DCSP config.include('pyramid_zodbconn') DCNL DCSP  DCSP config.set_root_factory(root_factory) DCNL DCSP  DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP  DCSP config.scan() DCNL DCSP  DCSP return config.make_wsgi_app()
 DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP with Configurator(settings=settings) as config: DCNL DCSP  DCSP config.include('pyramid_chameleon') DCNL DCSP  DCSP config.include('pyramid_tm') DCNL DCSP  DCSP config.include('pyramid_retry') DCNL DCSP  DCSP config.include('pyramid_zodbconn') DCNL DCSP  DCSP config.set_root_factory(root_factory) DCNL DCSP  DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP  DCSP config.scan() DCNL DCSP  DCSP return config.make_wsgi_app()
 DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP authn_policy = AuthTktAuthenticationPolicy('sosecret', callback=groupfinder, hashalg='sha512') DCNL DCSP authz_policy = ACLAuthorizationPolicy() DCNL DCSP with Configurator(settings=settings) as config: DCNL DCSP  DCSP config.set_authentication_policy(authn_policy) DCNL DCSP  DCSP config.set_authorization_policy(authz_policy) DCNL DCSP  DCSP config.include('pyramid_chameleon') DCNL DCSP  DCSP config.include('pyramid_tm') DCNL DCSP  DCSP config.include('pyramid_retry') DCNL DCSP  DCSP config.include('pyramid_zodbconn') DCNL DCSP  DCSP config.set_root_factory(root_factory) DCNL DCSP  DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP  DCSP config.scan() DCNL DCSP  DCSP return config.make_wsgi_app()
 DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP with Configurator(settings=settings) as config: DCNL DCSP  DCSP config.include('pyramid_chameleon') DCNL DCSP  DCSP config.include('pyramid_tm') DCNL DCSP  DCSP config.include('pyramid_retry') DCNL DCSP  DCSP config.include('pyramid_zodbconn') DCNL DCSP  DCSP config.set_root_factory(root_factory) DCNL DCSP  DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP  DCSP config.scan() DCNL DCSP  DCSP return config.make_wsgi_app()
 DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP with Configurator(settings=settings) as config: DCNL DCSP  DCSP config.include('pyramid_chameleon') DCNL DCSP  DCSP config.include('pyramid_tm') DCNL DCSP  DCSP config.include('pyramid_retry') DCNL DCSP  DCSP config.include('pyramid_zodbconn') DCNL DCSP  DCSP config.set_root_factory(root_factory) DCNL DCSP  DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP  DCSP config.scan() DCNL DCSP  DCSP return config.make_wsgi_app()
 DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP authn_policy = AuthTktAuthenticationPolicy('sosecret', callback=groupfinder, hashalg='sha512') DCNL DCSP authz_policy = ACLAuthorizationPolicy() DCNL DCSP with Configurator(settings=settings) as config: DCNL DCSP  DCSP config.set_authentication_policy(authn_policy) DCNL DCSP  DCSP config.set_authorization_policy(authz_policy) DCNL DCSP  DCSP config.include('pyramid_chameleon') DCNL DCSP  DCSP config.include('pyramid_tm') DCNL DCSP  DCSP config.include('pyramid_retry') DCNL DCSP  DCSP config.include('pyramid_zodbconn') DCNL DCSP  DCSP config.set_root_factory(root_factory) DCNL DCSP  DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP  DCSP config.scan() DCNL DCSP  DCSP return config.make_wsgi_app()
 DCSP dbsession = session_factory() DCNL DCSP zope.sqlalchemy.register(dbsession, transaction_manager=transaction_manager) DCNL DCSP return dbsession
 DCSP settings = config.get_settings() DCNL DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP config.include('pyramid_tm') DCNL DCSP config.include('pyramid_retry') DCNL DCSP session_factory = get_session_factory(get_engine(settings)) DCNL DCSP config.registry['dbsession_factory'] = session_factory DCNL DCSP config.add_request_method((lambda r: get_tm_session(session_factory, r.tm)), 'dbsession', reify=True)
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.include('.models') DCNL DCSP config.include('.routes') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP dbsession = session_factory() DCNL DCSP zope.sqlalchemy.register(dbsession, transaction_manager=transaction_manager) DCNL DCSP return dbsession
 DCSP settings = config.get_settings() DCNL DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP config.include('pyramid_tm') DCNL DCSP config.include('pyramid_retry') DCNL DCSP session_factory = get_session_factory(get_engine(settings)) DCNL DCSP config.registry['dbsession_factory'] = session_factory DCNL DCSP config.add_request_method((lambda r: get_tm_session(session_factory, r.tm)), 'dbsession', reify=True)
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.include('.models') DCNL DCSP config.include('.routes') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP dbsession = session_factory() DCNL DCSP zope.sqlalchemy.register(dbsession, transaction_manager=transaction_manager) DCNL DCSP return dbsession
 DCSP settings = config.get_settings() DCNL DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP config.include('pyramid_tm') DCNL DCSP config.include('pyramid_retry') DCNL DCSP session_factory = get_session_factory(get_engine(settings)) DCNL DCSP config.registry['dbsession_factory'] = session_factory DCNL DCSP config.add_request_method((lambda r: get_tm_session(session_factory, r.tm)), 'dbsession', reify=True)
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.include('.models') DCNL DCSP config.include('.routes') DCNL DCSP config.include('.security') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP dbsession = session_factory() DCNL DCSP zope.sqlalchemy.register(dbsession, transaction_manager=transaction_manager) DCNL DCSP return dbsession
 DCSP settings = config.get_settings() DCNL DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP config.include('pyramid_tm') DCNL DCSP config.include('pyramid_retry') DCNL DCSP session_factory = get_session_factory(get_engine(settings)) DCNL DCSP config.registry['dbsession_factory'] = session_factory DCNL DCSP config.add_request_method((lambda r: get_tm_session(session_factory, r.tm)), 'dbsession', reify=True)
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.include('.models') DCNL DCSP config.include('.routes') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP dbsession = session_factory() DCNL DCSP zope.sqlalchemy.register(dbsession, transaction_manager=transaction_manager) DCNL DCSP return dbsession
 DCSP settings = config.get_settings() DCNL DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP config.include('pyramid_tm') DCNL DCSP config.include('pyramid_retry') DCNL DCSP session_factory = get_session_factory(get_engine(settings)) DCNL DCSP config.registry['dbsession_factory'] = session_factory DCNL DCSP config.add_request_method((lambda r: get_tm_session(session_factory, r.tm)), 'dbsession', reify=True)
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.include('.models') DCNL DCSP config.include('.routes') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP dbsession = session_factory() DCNL DCSP zope.sqlalchemy.register(dbsession, transaction_manager=transaction_manager) DCNL DCSP return dbsession
 DCSP settings = config.get_settings() DCNL DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP config.include('pyramid_tm') DCNL DCSP config.include('pyramid_retry') DCNL DCSP session_factory = get_session_factory(get_engine(settings)) DCNL DCSP config.registry['dbsession_factory'] = session_factory DCNL DCSP config.add_request_method((lambda r: get_tm_session(session_factory, r.tm)), 'dbsession', reify=True)
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.include('.models') DCNL DCSP config.include('.routes') DCNL DCSP config.include('.security') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP dbsession = session_factory() DCNL DCSP zope.sqlalchemy.register(dbsession, transaction_manager=transaction_manager) DCNL DCSP return dbsession
 DCSP settings = config.get_settings() DCNL DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP config.include('pyramid_tm') DCNL DCSP config.include('pyramid_retry') DCNL DCSP session_factory = get_session_factory(get_engine(settings)) DCNL DCSP config.registry['dbsession_factory'] = session_factory DCNL DCSP config.add_request_method((lambda r: get_tm_session(session_factory, r.tm)), 'dbsession', reify=True)
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.include('.models') DCNL DCSP config.include('.routes') DCNL DCSP config.include('.security') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP if ('class' in options): DCNL DCSP  DCSP assert ('classes' not in options) DCNL DCSP  DCSP options['classes'] = options['class'] DCNL DCSP  DCSP del options['class'] DCNL DCSP return ([nodes.inline(rawtext, utils.unescape(text), **options)], [])
 DCSP docobj = getattr(obj, '__docobj__', None) DCNL DCSP if (docobj is not None): DCNL DCSP  DCSP argspec = inspect.getargspec(docobj) DCNL DCSP  DCSP if (argspec[0] and (argspec[0][0] in ('cls', 'self'))): DCNL DCSP  DCSP  DCSP del argspec[0][0] DCNL DCSP  DCSP signature = inspect.formatargspec(*argspec) DCNL DCSP return (signature, return_annotation)
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP config.add_route('home', '/') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP dbsession = session_factory() DCNL DCSP zope.sqlalchemy.register(dbsession, transaction_manager=transaction_manager) DCNL DCSP return dbsession
 DCSP settings = config.get_settings() DCNL DCSP settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager' DCNL DCSP config.include('pyramid_tm') DCNL DCSP config.include('pyramid_retry') DCNL DCSP session_factory = get_session_factory(get_engine(settings)) DCNL DCSP config.registry['dbsession_factory'] = session_factory DCNL DCSP config.add_request_method((lambda r: get_tm_session(session_factory, r.tm)), 'dbsession', reify=True)
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.include('.models') DCNL DCSP config.include('.routes') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP config.add_route('home', '/') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP config.add_route('home', '/') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP config.add_route('home', '/') DCNL DCSP my_session_factory = SignedCookieSessionFactory('itsaseekreet') DCNL DCSP config.set_session_factory(my_session_factory) DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP config = Configurator(settings=settings) DCNL DCSP config.include('pyramid_jinja2') DCNL DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP config.add_route('home', '/') DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP return {'id': model.id, 'time_started_msec': model.time_started_msec, 'time_finished_msec': model.time_finished_msec, 'status_code': model.status_code, 'job_type': model.job_type, 'is_cancelable': model.is_cancelable, 'error': model.error, 'human_readable_time_started': ('' if (model.time_started_msec is None) else utils.get_human_readable_time_string(model.time_started_msec)), 'human_readable_time_finished': ('' if (model.time_finished_msec is None) else utils.get_human_readable_time_string(model.time_finished_msec))}
 DCSP recent_job_models = job_models.JobModel.get_recent_jobs(NUM_JOBS_IN_DASHBOARD_LIMIT, recency_msec) DCNL DCSP return [_get_job_dict_from_job_model(model) for model in recent_job_models]
 DCSP unfinished_job_models = job_models.JobModel.get_all_unfinished_jobs(NUM_JOBS_IN_DASHBOARD_LIMIT) DCNL DCSP return [_get_job_dict_from_job_model(model) for model in unfinished_job_models]
 DCSP return job_models.JobModel.get_by_id(job_id).output
 DCSP cc_models = job_models.ContinuousComputationModel.get_multi([cc_class.__name__ for cc_class in cc_classes]) DCNL DCSP result = [] DCNL DCSP for (ind, model) in enumerate(cc_models): DCNL DCSP  DCSP if (model is None): DCNL DCSP  DCSP  DCSP cc_dict = {'computation_type': cc_classes[ind].__name__, 'status_code': 'never_started', 'last_started_msec': None, 'last_finished_msec': None, 'last_stopped_msec': None, 'active_realtime_layer_index': None, 'is_startable': True, 'is_stoppable': False} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cc_dict = {'computation_type': cc_classes[ind].__name__, 'status_code': model.status_code, 'last_started_msec': model.last_started_msec, 'last_finished_msec': model.last_finished_msec, 'last_stopped_msec': model.last_stopped_msec, 'active_realtime_layer_index': model.active_realtime_layer_index, 'is_startable': (model.status_code == job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_IDLE), 'is_stoppable': (model.status_code == job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_RUNNING)} DCNL DCSP  DCSP result.append(cc_dict) DCNL DCSP return result
 DCSP threshold_time = (datetime.datetime.utcnow() - datetime.timedelta(0, 0, 0, recency_msecs)) DCNL DCSP shard_state_model_class = mapreduce_model.ShardState DCNL DCSP recent_job_models = shard_state_model_class.all() DCNL DCSP stuck_jobs = [] DCNL DCSP for job_model in recent_job_models: DCNL DCSP  DCSP if ((job_model.update_time > threshold_time) and (job_model.retries > 0)): DCNL DCSP  DCSP  DCSP stuck_jobs.append(job_model) DCNL DCSP return stuck_jobs
 DCSP return users.create_login_url(utils.set_url_query_parameter(feconf.SIGNUP_URL, 'return_url', slug))
 DCSP logout_url = utils.set_url_query_parameter('/logout', 'return_url', slug) DCNL DCSP return logout_url
 DCSP return users.get_current_user()
 DCSP return users.is_current_user_admin()
 DCSP class _FakeUser(ndb.Model, ): DCNL DCSP  DCSP _use_memcache = False DCNL DCSP  DCSP _use_cache = False DCNL DCSP  DCSP user = ndb.UserProperty(required=True) DCNL DCSP try: DCNL DCSP  DCSP fake_user = users.User(email) DCNL DCSP except users.UserNotFoundError: DCNL DCSP  DCSP logging.error(('The DCSP email DCSP address DCSP %s DCSP does DCSP not DCSP correspond DCSP to DCSP a DCSP valid DCSP user_id' % email)) DCNL DCSP  DCSP return None DCNL DCSP key = _FakeUser(id=email, user=fake_user).put() DCNL DCSP obj = _FakeUser.get_by_id(key.id()) DCNL DCSP user_id = obj.user.user_id() DCNL DCSP if user_id: DCNL DCSP  DCSP return unicode(user_id) DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP return user.user_id()
 DCSP return user.email()
 DCSP deferred.defer(fn, *args, **kwargs)
 DCSP deferred.defer(fn, _queue=QUEUE_NAME_EVENTS, *args, **kwargs)
 DCSP taskqueue.add(queue_name=QUEUE_NAME_EMAILS, url=url, payload=json.dumps(params), countdown=countdown, target=taskqueue.DEFAULT_APP_VERSION)
 DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP raise Exception('This DCSP app DCSP cannot DCSP send DCSP emails.') DCNL DCSP if (not mail.is_email_valid(sender_email)): DCNL DCSP  DCSP raise ValueError(('Malformed DCSP sender DCSP email DCSP address: DCSP %s' % sender_email)) DCNL DCSP if (not mail.is_email_valid(recipient_email)): DCNL DCSP  DCSP raise ValueError(('Malformed DCSP recipient DCSP email DCSP address: DCSP %s' % recipient_email)) DCNL DCSP msg = mail.EmailMessage(sender=sender_email, to=recipient_email, subject=subject, body=plaintext_body, html=html_body) DCNL DCSP if bcc_admin: DCNL DCSP  DCSP msg.bcc = [feconf.ADMIN_EMAIL_ADDRESS] DCNL DCSP if reply_to_id: DCNL DCSP  DCSP msg.reply_to = get_incoming_email_address(reply_to_id) DCNL DCSP msg.send()
 DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP raise Exception('This DCSP app DCSP cannot DCSP send DCSP emails.') DCNL DCSP if (not mail.is_email_valid(sender_email)): DCNL DCSP  DCSP raise ValueError(('Malformed DCSP sender DCSP email DCSP address: DCSP %s' % sender_email)) DCNL DCSP for recipient_email in recipient_emails: DCNL DCSP  DCSP if (not mail.is_email_valid(recipient_email)): DCNL DCSP  DCSP  DCSP raise ValueError(('Malformed DCSP recipient DCSP email DCSP address: DCSP %s' % recipient_email)) DCNL DCSP for recipient_email in recipient_emails: DCNL DCSP  DCSP mail.send_mail(sender_email, recipient_email, subject, plaintext_body, html=html_body)
 DCSP if (not feconf.MAILGUN_API_KEY): DCNL DCSP  DCSP raise Exception('Mailgun DCSP API DCSP key DCSP is DCSP not DCSP available.') DCNL DCSP if (not feconf.MAILGUN_DOMAIN_NAME): DCNL DCSP  DCSP raise Exception('Mailgun DCSP domain DCSP name DCSP is DCSP not DCSP set.') DCNL DCSP mailgun_domain_name = ('https://api.mailgun.net/v3/%s/messages' % feconf.MAILGUN_DOMAIN_NAME) DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP raise Exception('This DCSP app DCSP cannot DCSP send DCSP emails DCSP to DCSP users.') DCNL DCSP data = {'from': sender_email, 'to': recipient_email, 'subject': subject, 'text': plaintext_body, 'html': html_body} DCNL DCSP if bcc_admin: DCNL DCSP  DCSP data['bcc'] = feconf.ADMIN_EMAIL_ADDRESS DCNL DCSP if reply_to_id: DCNL DCSP  DCSP reply_to = gae_email_services.get_incoming_email_address(reply_to_id) DCNL DCSP  DCSP data['h:Reply-To'] = reply_to DCNL DCSP requests.post(mailgun_domain_name, auth=('api', feconf.MAILGUN_API_KEY), data=data)
 DCSP if (not feconf.MAILGUN_API_KEY): DCNL DCSP  DCSP raise Exception('Mailgun DCSP API DCSP key DCSP is DCSP not DCSP available.') DCNL DCSP if (not feconf.MAILGUN_DOMAIN_NAME): DCNL DCSP  DCSP raise Exception('Mailgun DCSP domain DCSP name DCSP is DCSP not DCSP set.') DCNL DCSP mailgun_domain_name = ('https://api.mailgun.net/v3/%s/messages' % feconf.MAILGUN_DOMAIN_NAME) DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP raise Exception('This DCSP app DCSP cannot DCSP send DCSP emails DCSP to DCSP users.') DCNL DCSP recipient_email_sets = [recipient_emails[i:(i + 1000)] for i in xrange(0, len(recipient_emails), 1000)] DCNL DCSP for email_set in recipient_email_sets: DCNL DCSP  DCSP data = {'from': sender_email, 'to': email_set, 'subject': subject, 'text': plaintext_body, 'html': html_body, 'recipient-variables': '{}'} DCNL DCSP  DCSP requests.post(mailgun_domain_name, auth=('api', feconf.MAILGUN_API_KEY), data=data)
 DCSP assert isinstance(keys, list) DCNL DCSP result = memcache.get_multi(keys) DCNL DCSP return result
 DCSP assert isinstance(key_value_mapping, dict) DCNL DCSP unset_keys = memcache.set_multi(key_value_mapping) DCNL DCSP return unset_keys
 DCSP assert isinstance(key, basestring) DCNL DCSP return_code = memcache.delete(key) DCNL DCSP return return_code
 DCSP for key in keys: DCNL DCSP  DCSP assert isinstance(key, basestring) DCNL DCSP return_value = memcache.delete_multi(keys) DCNL DCSP return return_value
 DCSP return app_identity.get_application_id()
 DCSP if (not isinstance(index, basestring)): DCNL DCSP  DCSP raise ValueError(('Index DCSP must DCSP be DCSP the DCSP unicode/str DCSP name DCSP of DCSP an DCSP index, DCSP got DCSP %s' % type(index))) DCNL DCSP index = gae_search.Index(index) DCNL DCSP gae_docs = [_dict_to_search_document(d) for d in documents] DCNL DCSP try: DCNL DCSP  DCSP logging.debug('adding DCSP the DCSP following DCSP docs DCSP to DCSP index DCSP %s: DCSP %s', index.name, documents) DCNL DCSP  DCSP results = index.put(gae_docs, deadline=5) DCNL DCSP except gae_search.PutError as e: DCNL DCSP  DCSP logging.exception('PutError DCSP raised.') DCNL DCSP  DCSP if (retries > 1): DCNL DCSP  DCSP  DCSP for res in e.results: DCNL DCSP  DCSP  DCSP  DCSP if (res.code == gae_search.OperationResult.TRANSIENT_ERROR): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_retries = (retries - 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.debug(('%d DCSP tries DCSP left, DCSP retrying.' % new_retries)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return add_documents_to_index(documents=documents, index=index.name, retries=new_retries) DCNL DCSP  DCSP raise SearchFailureError(e) DCNL DCSP return [r.id for r in results]
 DCSP for (ind, element) in enumerate(value): DCNL DCSP  DCSP if (not isinstance(element, (basestring, datetime.date, datetime.datetime, numbers.Number))): DCNL DCSP  DCSP  DCSP raise ValueError(('All DCSP values DCSP of DCSP a DCSP multi-valued DCSP field DCSP must DCSP be DCSP numbers, DCSP strings, DCSP date DCSP or DCSP datetime DCSP instances, DCSP The DCSP %dth DCSP value DCSP for DCSP field DCSP %s DCSP has DCSP type DCSP %s.' % (ind, key, type(element))))
 DCSP if (not isinstance(index, basestring)): DCNL DCSP  DCSP raise ValueError(('Index DCSP must DCSP be DCSP the DCSP unicode/str DCSP name DCSP of DCSP an DCSP index, DCSP got DCSP %s' % type(index))) DCNL DCSP for (ind, doc_id) in enumerate(doc_ids): DCNL DCSP  DCSP if (not isinstance(doc_id, basestring)): DCNL DCSP  DCSP  DCSP raise ValueError(('all DCSP doc_ids DCSP must DCSP be DCSP string, DCSP got DCSP %s DCSP at DCSP index DCSP %d' % (type(doc_id), ind))) DCNL DCSP index = gae_search.Index(index) DCNL DCSP try: DCNL DCSP  DCSP logging.debug(('Attempting DCSP to DCSP delete DCSP documents DCSP from DCSP index DCSP %s, DCSP ids: DCSP %s' % (index.name, ', DCSP '.join(doc_ids)))) DCNL DCSP  DCSP index.delete(doc_ids, deadline=5) DCNL DCSP except gae_search.DeleteError as e: DCNL DCSP  DCSP logging.exception('Something DCSP went DCSP wrong DCSP during DCSP deletion.') DCNL DCSP  DCSP if (retries > 1): DCNL DCSP  DCSP  DCSP for res in e.results: DCNL DCSP  DCSP  DCSP  DCSP if (res.code == gae_search.OperationResult.TRANSIENT_ERROR): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_retries = (retries - 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.debug(('%d DCSP tries DCSP left, DCSP retrying.' % new_retries)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP delete_documents_from_index(doc_ids=doc_ids, index=index.name, retries=new_retries) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP raise SearchFailureError(e)
 DCSP index = gae_search.Index(index_name) DCNL DCSP while True: DCNL DCSP  DCSP doc_ids = [document.doc_id for document in index.get_range(ids_only=True)] DCNL DCSP  DCSP if (not doc_ids): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP index.delete(doc_ids)
 DCSP sort_options = None DCNL DCSP if (cursor is None): DCNL DCSP  DCSP gae_cursor = gae_search.Cursor() DCNL DCSP else: DCNL DCSP  DCSP gae_cursor = gae_search.Cursor(web_safe_string=cursor) DCNL DCSP if sort: DCNL DCSP  DCSP expr = _string_to_sort_expressions(sort) DCNL DCSP  DCSP sort_options = gae_search.SortOptions(expr) DCNL DCSP options = gae_search.QueryOptions(limit=limit, cursor=gae_cursor, ids_only=ids_only, sort_options=sort_options) DCNL DCSP try: DCNL DCSP  DCSP query = gae_search.Query(query_string, options=options) DCNL DCSP except gae_search.QueryError as e: DCNL DCSP  DCSP logging.exception(('Could DCSP not DCSP parse DCSP query DCSP string DCSP %s' % query_string)) DCNL DCSP  DCSP return ([], None) DCNL DCSP index = gae_search.Index(index) DCNL DCSP try: DCNL DCSP  DCSP logging.debug(('attempting DCSP a DCSP search DCSP with DCSP query DCSP %s' % query)) DCNL DCSP  DCSP results = index.search(query) DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.exception('something DCSP went DCSP wrong DCSP while DCSP searching.') DCNL DCSP  DCSP if (retries > 1): DCNL DCSP  DCSP  DCSP logging.debug(('%d DCSP attempts DCSP left, DCSP retrying...' % (retries - 1))) DCNL DCSP  DCSP  DCSP return search(query_string, index.name, cursor=cursor, limit=limit, sort=sort, ids_only=ids_only, retries=(retries - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise SearchFailureError(e) DCNL DCSP result_cursor_str = None DCNL DCSP if results.cursor: DCNL DCSP  DCSP result_cursor_str = results.cursor.web_safe_string DCNL DCSP if ids_only: DCNL DCSP  DCSP result_docs = [doc.doc_id for doc in results.results] DCNL DCSP else: DCNL DCSP  DCSP result_docs = [_search_document_to_dict(doc) for doc in results.results] DCNL DCSP return (result_docs, result_cursor_str)
 DCSP index = gae_search.Index(index) DCNL DCSP return _search_document_to_dict(index.get(doc_id))
 DCSP entity_keys = [] DCNL DCSP for (model_name, entity_ids) in ids_and_models: DCNL DCSP  DCSP entity_keys = (entity_keys + [ndb.Key(model_name, entity_id) for entity_id in entity_ids]) DCNL DCSP all_models = ndb.get_multi(entity_keys) DCNL DCSP all_models_grouped_by_model_type = [] DCNL DCSP start_index = 0 DCNL DCSP for (_, entity_ids) in ids_and_models: DCNL DCSP  DCSP all_models_grouped_by_model_type.append(all_models[start_index:(start_index + len(entity_ids))]) DCNL DCSP  DCSP start_index = (start_index + len(entity_ids)) DCNL DCSP return all_models_grouped_by_model_type
 DCSP return ndb.transaction((lambda : fn(*args, **kwargs)), xg=True, propagation=ndb.TransactionOptions.ALLOWED)
 DCSP return ndb.toplevel(*args, **kwargs)
 DCSP if (test_target and ('/' in test_target)): DCNL DCSP  DCSP raise Exception('The DCSP delimiter DCSP in DCSP test_target DCSP should DCSP be DCSP a DCSP dot DCSP (.)') DCNL DCSP loader = unittest.TestLoader() DCNL DCSP return ([loader.loadTestsFromName(test_target)] if test_target else [loader.discover(CURR_DIR, pattern='*_test.py', top_level_dir=CURR_DIR)])
 DCSP def _iterate(test_suite_or_case): DCNL DCSP  DCSP 'Iterate DCSP through DCSP all DCSP the DCSP test DCSP cases DCSP in DCSP `test_suite_or_case`.' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP suite = iter(test_suite_or_case) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP (yield test_suite_or_case) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for test in suite: DCNL DCSP  DCSP  DCSP  DCSP for subtest in _iterate(test): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield subtest) DCNL DCSP feconf.PLATFORM = 'gae' DCNL DCSP for directory in DIRS_TO_ADD_TO_SYS_PATH: DCNL DCSP  DCSP if (not os.path.exists(os.path.dirname(directory))): DCNL DCSP  DCSP  DCSP raise Exception(('Directory DCSP %s DCSP does DCSP not DCSP exist.' % directory)) DCNL DCSP  DCSP sys.path.insert(0, directory) DCNL DCSP import dev_appserver DCNL DCSP dev_appserver.fix_sys_path() DCNL DCSP parsed_args = _PARSER.parse_args() DCNL DCSP suites = create_test_suites(parsed_args.test_target) DCNL DCSP results = [unittest.TextTestRunner(verbosity=2).run(suite) for suite in suites] DCNL DCSP tests_run = 0 DCNL DCSP for result in results: DCNL DCSP  DCSP tests_run += result.testsRun DCNL DCSP  DCSP if (result.errors or result.failures): DCNL DCSP  DCSP  DCSP raise Exception(('Test DCSP suite DCSP failed: DCSP %s DCSP tests DCSP run, DCSP %s DCSP errors, DCSP %s DCSP failures.' % (result.testsRun, len(result.errors), len(result.failures)))) DCNL DCSP if (tests_run == 0): DCNL DCSP  DCSP raise Exception('No DCSP tests DCSP were DCSP run.')
 DCSP def time_taken(obj, num): DCNL DCSP  DCSP 'Prints DCSP the DCSP time DCSP taken DCSP by DCSP func DCSP to DCSP run DCSP a DCSP given DCSP number DCSP of DCSP samples.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Args:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP obj: DCSP object. DCSP The DCSP class DCSP instance DCSP func DCSP belongs DCSP to.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP num: DCSP int. DCSP The DCSP number DCSP of DCSP samples DCSP to DCSP run DCSP with.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Result DCSP of DCSP func.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP start = time.time() DCNL DCSP  DCSP result = func(obj, num) DCNL DCSP  DCSP end = time.time() DCNL DCSP  DCSP print ('%s DCSP spent DCSP %f DCSP seconds DCSP for DCSP %d DCSP instances' % (func.__name__, (end - start), num)) DCNL DCSP  DCSP return result DCNL DCSP return time_taken
 DCSP cookie = Cookie.SimpleCookie() DCNL DCSP for cookie_name in ['ACSID', 'SACSID']: DCNL DCSP  DCSP cookie = Cookie.SimpleCookie() DCNL DCSP  DCSP cookie[cookie_name] = '' DCNL DCSP  DCSP cookie[cookie_name]['expires'] = (datetime.datetime.utcnow() + datetime.timedelta(seconds=ONE_DAY_AGO_IN_SECS)).strftime('%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT') DCNL DCSP  DCSP response_headers.add_header(*cookie.output().split(': DCSP ', 1))
 DCSP collection_ids = [] DCNL DCSP if (not search_cursor): DCNL DCSP  DCSP (collection_ids, _) = collection_services.get_collection_ids_matching_query(query_string) DCNL DCSP (exp_ids, new_search_cursor) = exp_services.get_exploration_ids_matching_query(query_string, cursor=search_cursor) DCNL DCSP activity_list = [] DCNL DCSP activity_list = summary_services.get_displayable_collection_summary_dicts_matching_ids(collection_ids) DCNL DCSP activity_list += summary_services.get_displayable_exp_summary_dicts_matching_ids(exp_ids) DCNL DCSP if (len(activity_list) == feconf.DEFAULT_QUERY_LIMIT): DCNL DCSP  DCSP logging.error(('%s DCSP activities DCSP were DCSP fetched DCSP to DCSP load DCSP the DCSP library DCSP page. DCSP You DCSP may DCSP be DCSP running DCSP up DCSP against DCSP the DCSP default DCSP query DCSP limits.' % feconf.DEFAULT_QUERY_LIMIT)) DCNL DCSP return (activity_list, new_search_cursor)
 DCSP def test_maintenance_mode(self, **kwargs): DCNL DCSP  DCSP if (not feconf.ENABLE_MAINTENANCE_MODE): DCNL DCSP  DCSP  DCSP raise self.UnauthorizedUserException('You DCSP cannot DCSP access DCSP this DCSP page DCSP unless DCSP the DCSP site DCSP is DCSP in DCSP maintenance DCSP mode') DCNL DCSP  DCSP return handler(self, **kwargs) DCNL DCSP return test_maintenance_mode
 DCSP for (username, role) in changed_user_roles.iteritems(): DCNL DCSP  DCSP user_services.update_user_role(user_services.get_user_id_from_username(username), role)
 DCSP if (version_from_payload is None): DCNL DCSP  DCSP raise base.BaseHandler.InvalidInputException('Invalid DCSP POST DCSP request: DCSP a DCSP version DCSP must DCSP be DCSP specified.') DCNL DCSP if (version_from_payload != collection_version): DCNL DCSP  DCSP raise base.BaseHandler.InvalidInputException(('Trying DCSP to DCSP update DCSP version DCSP %s DCSP of DCSP collection DCSP from DCSP version DCSP %s, DCSP which DCSP is DCSP too DCSP old. DCSP Please DCSP reload DCSP the DCSP page DCSP and DCSP try DCSP again.' % (collection_version, version_from_payload)))
 DCSP message_json = json.dumps(message, sort_keys=True) DCNL DCSP return hmac.new(secret, message_json, digestmod=hashlib.sha256).hexdigest()
 DCSP job_id = message.get('job_id') DCNL DCSP classifier_data = message.get('classifier_data') DCNL DCSP if (not isinstance(job_id, basestring)): DCNL DCSP  DCSP return False DCNL DCSP if (not isinstance(classifier_data, dict)): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP secret = None DCNL DCSP for val in config_domain.VMID_SHARED_SECRET_KEY_MAPPING.value: DCNL DCSP  DCSP if (val['vm_id'] == vm_id): DCNL DCSP  DCSP  DCSP secret = str(val['shared_secret_key']) DCNL DCSP  DCSP  DCSP break DCNL DCSP if (secret is None): DCNL DCSP  DCSP return False DCNL DCSP generated_signature = generate_signature(secret, message) DCNL DCSP if (generated_signature != received_signature): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP all_value_generators = value_generators_domain.Registry.get_all_generator_classes() DCNL DCSP value_generators_js = '' DCNL DCSP for (_, generator_cls) in all_value_generators.iteritems(): DCNL DCSP  DCSP value_generators_js += generator_cls.get_js_template() DCNL DCSP return value_generators_js
 DCSP if (version_from_payload is None): DCNL DCSP  DCSP raise base.BaseHandler.InvalidInputException('Invalid DCSP POST DCSP request: DCSP a DCSP version DCSP must DCSP be DCSP specified.') DCNL DCSP if (version_from_payload != exploration_version): DCNL DCSP  DCSP raise base.BaseHandler.InvalidInputException(('Trying DCSP to DCSP update DCSP version DCSP %s DCSP of DCSP exploration DCSP from DCSP version DCSP %s, DCSP which DCSP is DCSP too DCSP old. DCSP Please DCSP reload DCSP the DCSP page DCSP and DCSP try DCSP again.' % (exploration_version, version_from_payload)))
 DCSP config_property = config_domain.Registry.get_config_property(name) DCNL DCSP if (config_property is None): DCNL DCSP  DCSP raise Exception('No DCSP config DCSP property DCSP with DCSP name DCSP %s DCSP found.') DCNL DCSP if (not config_property.is_directly_settable): DCNL DCSP  DCSP raise Exception(('Cannot DCSP modify DCSP value DCSP of DCSP config DCSP property DCSP %s DCSP directly' % name)) DCNL DCSP config_property.set_value(committer_id, value)
 DCSP config_property = config_domain.Registry.get_config_property(name) DCNL DCSP if (config_property is None): DCNL DCSP  DCSP raise Exception('No DCSP config DCSP property DCSP with DCSP name DCSP %s DCSP found.') DCNL DCSP set_property(committer_id, name, config_property.default_value)
 DCSP featured_model_instance = activity_models.ActivityReferencesModel.get_or_create(activity_models.ACTIVITY_REFERENCE_LIST_FEATURED) DCNL DCSP return [activity_domain.ActivityReference(reference['type'], reference['id']) for reference in featured_model_instance.activity_references]
 DCSP for activity_reference in featured_activity_references: DCNL DCSP  DCSP activity_reference.validate() DCNL DCSP activity_hashes = [reference.get_hash() for reference in featured_activity_references] DCNL DCSP if (len(activity_hashes) != len(set(activity_hashes))): DCNL DCSP  DCSP raise Exception('The DCSP activity DCSP reference DCSP list DCSP should DCSP not DCSP have DCSP duplicates.') DCNL DCSP featured_model_instance = activity_models.ActivityReferencesModel.get_or_create(activity_models.ACTIVITY_REFERENCE_LIST_FEATURED) DCNL DCSP featured_model_instance.activity_references = [reference.to_dict() for reference in featured_activity_references] DCNL DCSP featured_model_instance.put()
 DCSP featured_references = get_featured_activity_references() DCNL DCSP activity_reference_found = False DCNL DCSP new_activity_references = [] DCNL DCSP for reference in featured_references: DCNL DCSP  DCSP if ((reference.type != activity_type) or (reference.id != activity_id)): DCNL DCSP  DCSP  DCSP new_activity_references.append(reference) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP activity_reference_found = True DCNL DCSP if activity_reference_found: DCNL DCSP  DCSP logging.info(('The DCSP %s DCSP with DCSP id DCSP %s DCSP was DCSP removed DCSP from DCSP the DCSP featured DCSP list.' % (activity_type, activity_id))) DCNL DCSP  DCSP update_featured_activity_references(new_activity_references)
 DCSP (exploration_ids, collection_ids) = ([], []) DCNL DCSP for activity_reference in activity_references: DCNL DCSP  DCSP if (activity_reference.type == constants.ACTIVITY_TYPE_EXPLORATION): DCNL DCSP  DCSP  DCSP exploration_ids.append(activity_reference.id) DCNL DCSP  DCSP elif (activity_reference.type == constants.ACTIVITY_TYPE_COLLECTION): DCNL DCSP  DCSP  DCSP collection_ids.append(activity_reference.id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP activity DCSP reference: DCSP (%s, DCSP %s)' % (activity_reference.type, activity_reference.id))) DCNL DCSP return (exploration_ids, collection_ids)
 DCSP thread_id = feedback_models.FeedbackThreadModel.generate_new_thread_id(exploration_id) DCNL DCSP thread = feedback_models.FeedbackThreadModel.create(exploration_id, thread_id) DCNL DCSP thread.exploration_id = exploration_id DCNL DCSP thread.state_name = state_name DCNL DCSP thread.original_author_id = original_author_id DCNL DCSP thread.status = feedback_models.STATUS_CHOICES_OPEN DCNL DCSP thread.subject = subject DCNL DCSP thread.has_suggestion = has_suggestion DCNL DCSP thread.message_count = 0 DCNL DCSP thread.put() DCNL DCSP create_message(exploration_id, thread_id, original_author_id, feedback_models.STATUS_CHOICES_OPEN, subject, text) DCNL DCSP return thread_id
 DCSP _create_models_for_thread_and_first_message(exploration_id, state_name, original_author_id, subject, text, False)
 DCSP from core.domain import event_services DCNL DCSP full_thread_id = feedback_models.FeedbackThreadModel.generate_full_thread_id(exploration_id, thread_id) DCNL DCSP thread = feedback_models.FeedbackThreadModel.get(full_thread_id) DCNL DCSP message_id = feedback_models.FeedbackMessageModel.get_message_count(exploration_id, thread_id) DCNL DCSP msg = feedback_models.FeedbackMessageModel.create(exploration_id, thread_id, message_id) DCNL DCSP msg.thread_id = full_thread_id DCNL DCSP msg.message_id = message_id DCNL DCSP msg.author_id = author_id DCNL DCSP if updated_status: DCNL DCSP  DCSP if (message_id == 0): DCNL DCSP  DCSP  DCSP event_services.FeedbackThreadCreatedEventHandler.record(thread.exploration_id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP event_services.FeedbackThreadStatusChangedEventHandler.record(thread.exploration_id, thread.status, updated_status) DCNL DCSP  DCSP msg.updated_status = updated_status DCNL DCSP if updated_subject: DCNL DCSP  DCSP msg.updated_subject = updated_subject DCNL DCSP msg.text = text DCNL DCSP msg.received_via_email = received_via_email DCNL DCSP msg.put() DCNL DCSP thread.message_count += 1 DCNL DCSP old_status = thread.status DCNL DCSP if ((message_id != 0) and (updated_status or updated_subject)): DCNL DCSP  DCSP if (updated_status and (updated_status != thread.status)): DCNL DCSP  DCSP  DCSP thread.status = updated_status DCNL DCSP  DCSP if (updated_subject and (updated_subject != thread.subject)): DCNL DCSP  DCSP  DCSP thread.subject = updated_subject DCNL DCSP new_status = thread.status DCNL DCSP thread.put() DCNL DCSP if (user_services.is_user_registered(author_id) and feconf.CAN_SEND_EMAILS and feconf.CAN_SEND_FEEDBACK_MESSAGE_EMAILS): DCNL DCSP  DCSP _add_message_to_email_buffer(author_id, exploration_id, thread_id, message_id, len(text), old_status, new_status) DCNL DCSP if author_id: DCNL DCSP  DCSP subscription_services.subscribe_to_thread(author_id, full_thread_id) DCNL DCSP  DCSP add_message_id_to_read_by_list(exploration_id, thread_id, author_id, message_id)
 DCSP feedback_thread_user_model = feedback_models.FeedbackThreadUserModel.get(user_id, exploration_id, thread_id) DCNL DCSP if (not feedback_thread_user_model): DCNL DCSP  DCSP feedback_thread_user_model = feedback_models.FeedbackThreadUserModel.create(user_id, exploration_id, thread_id) DCNL DCSP feedback_thread_user_model.message_ids_read_by_user = message_ids DCNL DCSP feedback_thread_user_model.put()
 DCSP feedback_thread_user_model = feedback_models.FeedbackThreadUserModel.get(user_id, exploration_id, thread_id) DCNL DCSP if (not feedback_thread_user_model): DCNL DCSP  DCSP feedback_thread_user_model = feedback_models.FeedbackThreadUserModel.create(user_id, exploration_id, thread_id) DCNL DCSP feedback_thread_user_model.message_ids_read_by_user.append(message_id) DCNL DCSP feedback_thread_user_model.put()
 DCSP return feedback_domain.FeedbackMessage(message_model.id, message_model.thread_id, message_model.message_id, message_model.author_id, message_model.updated_status, message_model.updated_subject, message_model.text, message_model.created_on, message_model.last_updated, message_model.received_via_email)
 DCSP return [_get_message_from_model(m) for m in feedback_models.FeedbackMessageModel.get_messages(exploration_id, thread_id)]
 DCSP return _get_message_from_model(feedback_models.FeedbackMessageModel.get(exploration_id, thread_id, message_id))
 DCSP (results, new_urlsafe_start_cursor, more) = feedback_models.FeedbackMessageModel.get_all_messages(page_size, urlsafe_start_cursor) DCNL DCSP result_messages = [_get_message_from_model(m) for m in results] DCNL DCSP return (result_messages, new_urlsafe_start_cursor, more)
 DCSP return feedback_jobs_continuous.FeedbackAnalyticsAggregator.get_thread_analytics_multi(exploration_ids)
 DCSP return feedback_jobs_continuous.FeedbackAnalyticsAggregator.get_thread_analytics(exploration_id)
 DCSP return sum((feedback.num_open_threads for feedback in feedback_thread_analytics))
 DCSP thread_id = _create_models_for_thread_and_first_message(exploration_id, state_name, author_id, description, DEFAULT_SUGGESTION_THREAD_INITIAL_MESSAGE, True) DCNL DCSP feedback_models.SuggestionModel.create(exploration_id, thread_id, author_id, exploration_version, state_name, description, suggestion_content) DCNL DCSP full_thread_id = feedback_models.FeedbackThreadModel.generate_full_thread_id(exploration_id, thread_id) DCNL DCSP subscription_services.subscribe_to_thread(author_id, full_thread_id) DCNL DCSP _enqueue_suggestion_email_task(exploration_id, thread_id)
 DCSP return feedback_domain.Suggestion(suggestion_model.id, suggestion_model.author_id, suggestion_model.exploration_id, suggestion_model.exploration_version, suggestion_model.state_name, suggestion_model.description, suggestion_model.get_suggestion_html())
 DCSP model = feedback_models.SuggestionModel.get_by_exploration_and_thread_id(exploration_id, thread_id) DCNL DCSP return (_get_suggestion_from_model(model) if model else None)
 DCSP return feedback_domain.FeedbackThread(thread_model.id, thread_model.exploration_id, thread_model.state_name, thread_model.original_author_id, thread_model.status, thread_model.subject, thread_model.summary, thread_model.has_suggestion, thread_model.message_count, thread_model.created_on, thread_model.last_updated)
 DCSP (exploration_ids, thread_ids) = feedback_models.FeedbackThreadModel.get_exploration_and_thread_ids(full_thread_ids) DCNL DCSP thread_model_ids = [feedback_models.FeedbackThreadModel.generate_full_thread_id(exploration_id, thread_id) for (exploration_id, thread_id) in zip(exploration_ids, thread_ids)] DCNL DCSP feedback_thread_user_model_ids = [feedback_models.FeedbackThreadUserModel.generate_full_id(user_id, exploration_id, thread_id) for (exploration_id, thread_id) in zip(exploration_ids, thread_ids)] DCNL DCSP multiple_models = datastore_services.fetch_multiple_entities_by_ids_and_models([('FeedbackThreadModel', thread_model_ids), ('FeedbackThreadUserModel', feedback_thread_user_model_ids), ('ExplorationModel', exploration_ids)]) DCNL DCSP thread_models = multiple_models[0] DCNL DCSP feedback_thread_user_models = multiple_models[1] DCNL DCSP explorations = multiple_models[2] DCNL DCSP threads = [_get_thread_from_model(thread_model) for thread_model in thread_models] DCNL DCSP last_two_messages_ids = [] DCNL DCSP for thread in threads: DCNL DCSP  DCSP last_two_messages_ids += thread.get_last_two_message_ids() DCNL DCSP messages = feedback_models.FeedbackMessageModel.get_multi(last_two_messages_ids) DCNL DCSP last_two_messages = [messages[i:(i + 2)] for i in range(0, len(messages), 2)] DCNL DCSP thread_summaries = [] DCNL DCSP number_of_unread_threads = 0 DCNL DCSP for (index, thread) in enumerate(threads): DCNL DCSP  DCSP last_message_read = (last_two_messages[index][0].message_id in feedback_thread_user_models[index].message_ids_read_by_user) DCNL DCSP  DCSP author_last_message = user_services.get_username(last_two_messages[index][0].author_id) DCNL DCSP  DCSP second_last_message_read = None DCNL DCSP  DCSP author_second_last_message = None DCNL DCSP  DCSP does_second_message_exist = (last_two_messages[index][1] is not None) DCNL DCSP  DCSP if does_second_message_exist: DCNL DCSP  DCSP  DCSP second_last_message_read = (last_two_messages[index][1].message_id in feedback_thread_user_models[index].message_ids_read_by_user) DCNL DCSP  DCSP  DCSP author_second_last_message = user_services.get_username(last_two_messages[index][1].author_id) DCNL DCSP  DCSP if (not last_message_read): DCNL DCSP  DCSP  DCSP number_of_unread_threads += 1 DCNL DCSP  DCSP if thread.message_count: DCNL DCSP  DCSP  DCSP total_message_count = thread.message_count DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP total_message_count = feedback_models.FeedbackMessageModel.get_message_count(thread.exploration_id, thread.get_thread_id()) DCNL DCSP  DCSP thread_summary = {'status': thread.status, 'original_author_id': thread.original_author_id, 'last_updated': utils.get_time_in_millisecs(thread.last_updated), 'last_message_text': last_two_messages[index][0].text, 'total_message_count': total_message_count, 'last_message_read': last_message_read, 'second_last_message_read': second_last_message_read, 'author_last_message': author_last_message, 'author_second_last_message': author_second_last_message, 'exploration_title': explorations[index].title, 'exploration_id': exploration_ids[index], 'thread_id': thread_ids[index]} DCNL DCSP  DCSP thread_summaries.append(thread_summary) DCNL DCSP return (thread_summaries, number_of_unread_threads)
 DCSP thread_models = feedback_models.FeedbackThreadModel.get_threads(exp_id, limit=feconf.OPEN_FEEDBACK_COUNT_DASHBOARD) DCNL DCSP message_models = [] DCNL DCSP for thread_model in thread_models: DCNL DCSP  DCSP message_models.append(feedback_models.FeedbackMessageModel.get_most_recent_message(exp_id, thread_model.thread_id)) DCNL DCSP return [_get_message_from_model(message_model) for message_model in message_models]
 DCSP thread_models = feedback_models.FeedbackThreadModel.get_threads(exploration_id) DCNL DCSP return [_get_thread_from_model(model) for model in thread_models]
 DCSP model = feedback_models.FeedbackThreadModel.get_by_exp_and_thread_id(exploration_id, thread_id) DCNL DCSP return _get_thread_from_model(model)
 DCSP threads = get_threads(exploration_id) DCNL DCSP open_threads = [] DCNL DCSP for thread in threads: DCNL DCSP  DCSP if ((thread.has_suggestion == has_suggestion) and (thread.status == feedback_models.STATUS_CHOICES_OPEN)): DCNL DCSP  DCSP  DCSP open_threads.append(thread) DCNL DCSP return open_threads
 DCSP threads = get_threads(exploration_id) DCNL DCSP closed_threads = [] DCNL DCSP for thread in threads: DCNL DCSP  DCSP if ((thread.has_suggestion == has_suggestion) and (thread.status != feedback_models.STATUS_CHOICES_OPEN)): DCNL DCSP  DCSP  DCSP closed_threads.append(thread) DCNL DCSP return closed_threads
 DCSP threads = get_threads(exploration_id) DCNL DCSP all_threads = [] DCNL DCSP for thread in threads: DCNL DCSP  DCSP if (thread.has_suggestion == has_suggestion): DCNL DCSP  DCSP  DCSP all_threads.append(thread) DCNL DCSP return all_threads
 DCSP return set([m.author_id for m in get_messages(exploration_id, thread_id) if user_services.is_user_registered(m.author_id)])
 DCSP taskqueue_services.enqueue_task(feconf.TASK_URL_FEEDBACK_MESSAGE_EMAILS, {'user_id': user_id}, feconf.DEFAULT_FEEDBACK_MESSAGE_EMAIL_COUNTDOWN_SECS)
 DCSP payload = {'user_id': user_id, 'reference_dict': reference.to_dict()} DCNL DCSP taskqueue_services.enqueue_task(feconf.TASK_URL_INSTANT_FEEDBACK_EMAILS, payload, 0)
 DCSP payload = {'user_id': user_id, 'reference_dict': reference.to_dict(), 'old_status': old_status, 'new_status': new_status} DCNL DCSP taskqueue_services.enqueue_task(feconf.TASK_URL_FEEDBACK_STATUS_EMAILS, payload, 0)
 DCSP payload = {'exploration_id': exploration_id, 'thread_id': thread_id} DCNL DCSP taskqueue_services.enqueue_task(feconf.TASK_URL_SUGGESTION_EMAILS, payload, 0)
 DCSP model = feedback_models.UnsentFeedbackEmailModel.get(user_id, strict=False) DCNL DCSP if (model is None): DCNL DCSP  DCSP return [] DCNL DCSP return [feedback_domain.FeedbackMessageReference(reference['exploration_id'], reference['thread_id'], reference['message_id']) for reference in model.feedback_message_references]
 DCSP model = feedback_models.UnsentFeedbackEmailModel.get(user_id, strict=False) DCNL DCSP if (model is not None): DCNL DCSP  DCSP model.feedback_message_references.append(reference.to_dict()) DCNL DCSP  DCSP model.put() DCNL DCSP else: DCNL DCSP  DCSP model = feedback_models.UnsentFeedbackEmailModel(id=user_id, feedback_message_references=[reference.to_dict()]) DCNL DCSP  DCSP model.put() DCNL DCSP  DCSP enqueue_feedback_message_batch_email_task(user_id)
 DCSP model = feedback_models.UnsentFeedbackEmailModel.get(user_id) DCNL DCSP time_since_buffered = (datetime.datetime.utcnow() - model.created_on).seconds DCNL DCSP if (time_since_buffered > feconf.DEFAULT_FEEDBACK_MESSAGE_EMAIL_COUNTDOWN_SECS): DCNL DCSP  DCSP model.retries += 1 DCNL DCSP  DCSP model.put()
 DCSP model = feedback_models.UnsentFeedbackEmailModel.get(user_id) DCNL DCSP if (num_references_to_pop == len(model.feedback_message_references)): DCNL DCSP  DCSP model.delete() DCNL DCSP else: DCNL DCSP  DCSP message_references = model.feedback_message_references[num_references_to_pop:] DCNL DCSP  DCSP model.delete() DCNL DCSP  DCSP model = feedback_models.UnsentFeedbackEmailModel(id=user_id, feedback_message_references=message_references) DCNL DCSP  DCSP model.put() DCNL DCSP  DCSP enqueue_feedback_message_batch_email_task(user_id)
 DCSP model = feedback_models.UnsentFeedbackEmailModel.get(user_id, strict=False) DCNL DCSP if (model is None): DCNL DCSP  DCSP return DCNL DCSP updated_references = [] DCNL DCSP for reference in model.feedback_message_references: DCNL DCSP  DCSP if ((reference['exploration_id'] != exploration_id) or (reference['thread_id'] != thread_id)): DCNL DCSP  DCSP  DCSP updated_references.append(reference) DCNL DCSP if (not updated_references): DCNL DCSP  DCSP model.delete() DCNL DCSP else: DCNL DCSP  DCSP model.feedback_message_references = updated_references DCNL DCSP  DCSP model.put()
 DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id) DCNL DCSP owner_ids = set(exploration_rights.owner_ids) DCNL DCSP participant_ids = get_all_thread_participants(exploration_id, thread_id) DCNL DCSP sender_id = set([author_id]) DCNL DCSP batch_recipient_ids = (owner_ids - sender_id) DCNL DCSP other_recipient_ids = ((participant_ids - batch_recipient_ids) - sender_id) DCNL DCSP return (batch_recipient_ids, other_recipient_ids)
 DCSP can_users_receive_email = email_manager.can_users_receive_thread_email(recipient_list, exploration_id, has_suggestion) DCNL DCSP for (index, recipient_id) in enumerate(recipient_list): DCNL DCSP  DCSP if can_users_receive_email[index]: DCNL DCSP  DCSP  DCSP transaction_services.run_in_transaction(_add_feedback_message_reference, recipient_id, feedback_message_reference)
 DCSP can_users_receive_email = email_manager.can_users_receive_thread_email(recipient_list, exploration_id, has_suggestion) DCNL DCSP for (index, recipient_id) in enumerate(recipient_list): DCNL DCSP  DCSP if can_users_receive_email[index]: DCNL DCSP  DCSP  DCSP transaction_services.run_in_transaction(enqueue_feedback_message_instant_email_task, recipient_id, feedback_message_reference)
 DCSP can_users_receive_email = email_manager.can_users_receive_thread_email(recipient_list, exploration_id, has_suggestion) DCNL DCSP for (index, recipient_id) in enumerate(recipient_list): DCNL DCSP  DCSP if can_users_receive_email[index]: DCNL DCSP  DCSP  DCSP transaction_services.run_in_transaction(_enqueue_feedback_thread_status_change_email_task, recipient_id, feedback_message_reference, old_status, new_status)
 DCSP feedback_email_id_models = email_models.FeedbackEmailReplyToIdModel.get_multi_by_user_ids(user_ids, exploration_id, thread_id) DCNL DCSP for user_id in user_ids: DCNL DCSP  DCSP if (feedback_email_id_models[user_id] is None): DCNL DCSP  DCSP  DCSP new_model = email_models.FeedbackEmailReplyToIdModel.create(user_id, exploration_id, thread_id) DCNL DCSP  DCSP  DCSP new_model.put()
 DCSP thread = feedback_models.FeedbackThreadModel.get_by_exp_and_thread_id(exploration_id, thread_id) DCNL DCSP has_suggestion = thread.has_suggestion DCNL DCSP feedback_message_reference = feedback_domain.FeedbackMessageReference(exploration_id, thread_id, message_id) DCNL DCSP (batch_recipient_ids, other_recipient_ids) = _get_all_recipient_ids(exploration_id, thread_id, author_id) DCNL DCSP _ensure_each_recipient_has_reply_to_id(other_recipient_ids, exploration_id, thread_id) DCNL DCSP if (old_status != new_status): DCNL DCSP  DCSP _send_feedback_thread_status_change_emails(other_recipient_ids, feedback_message_reference, old_status, new_status, exploration_id, has_suggestion) DCNL DCSP if (message_length > 0): DCNL DCSP  DCSP _send_batch_emails(batch_recipient_ids, feedback_message_reference, exploration_id, has_suggestion) DCNL DCSP  DCSP _send_instant_emails(other_recipient_ids, feedback_message_reference, exploration_id, has_suggestion)
 DCSP contributor_ids = contributors_summary.keys() DCNL DCSP contributor_usernames = user_services.get_human_readable_user_ids(contributor_ids) DCNL DCSP return {contributor_usernames[ind]: {'num_commits': contributors_summary[contributor_ids[ind]]} for ind in xrange(len(contributor_ids))}
 DCSP collection = collection_services.get_collection_by_id(collection_id, strict=strict, version=version) DCNL DCSP exp_ids = collection.exploration_ids DCNL DCSP exp_summary_dicts = get_displayable_exp_summary_dicts_matching_ids(exp_ids, editor_user_id=user_id) DCNL DCSP exp_summaries_dict_map = {exp_summary_dict['id']: exp_summary_dict for exp_summary_dict in exp_summary_dicts} DCNL DCSP next_exploration_ids = None DCNL DCSP completed_exp_ids = None DCNL DCSP if user_id: DCNL DCSP  DCSP completed_exp_ids = collection_services.get_valid_completed_exploration_ids(user_id, collection) DCNL DCSP  DCSP next_exploration_ids = collection.get_next_exploration_ids(completed_exp_ids) DCNL DCSP else: DCNL DCSP  DCSP next_exploration_ids = collection.init_exploration_ids DCNL DCSP  DCSP completed_exp_ids = [] DCNL DCSP collection_dict = collection.to_dict() DCNL DCSP collection_dict['playthrough_dict'] = {'next_exploration_ids': next_exploration_ids, 'completed_exploration_ids': completed_exp_ids} DCNL DCSP collection_dict['version'] = collection.version DCNL DCSP collection_is_public = rights_manager.is_collection_public(collection_id) DCNL DCSP for collection_node in collection_dict['nodes']: DCNL DCSP  DCSP exploration_id = collection_node['exploration_id'] DCNL DCSP  DCSP summary_dict = exp_summaries_dict_map.get(exploration_id) DCNL DCSP  DCSP if (not allow_invalid_explorations): DCNL DCSP  DCSP  DCSP if (not summary_dict): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP collection DCSP to DCSP only DCSP reference DCSP valid DCSP explorations, DCSP but DCSP found DCSP an DCSP exploration DCSP with DCSP ID: DCSP %s DCSP (was DCSP the DCSP exploration DCSP deleted DCSP or DCSP is DCSP it DCSP a DCSP private DCSP exploration DCSP that DCSP you DCSP do DCSP not DCSP have DCSP edit DCSP access DCSP to?)' % exploration_id)) DCNL DCSP  DCSP  DCSP if (collection_is_public and rights_manager.is_exploration_private(exploration_id)): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Cannot DCSP reference DCSP a DCSP private DCSP exploration DCSP within DCSP a DCSP public DCSP collection, DCSP exploration DCSP ID: DCSP %s' % exploration_id)) DCNL DCSP  DCSP if summary_dict: DCNL DCSP  DCSP  DCSP collection_node['exploration_summary'] = summary_dict DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP collection_node['exploration_summary'] = None DCNL DCSP return collection_dict
 DCSP collection_summaries = collection_services.get_collection_summaries_matching_ids(collection_ids) DCNL DCSP return _get_displayable_collection_summary_dicts(collection_summaries)
 DCSP (exp_ids, new_search_cursor) = exp_services.get_exploration_ids_matching_query(query_string, cursor=search_cursor) DCNL DCSP exploration_list = get_exploration_metadata_dicts(exp_ids, user_id) DCNL DCSP return (exploration_list, new_search_cursor)
 DCSP exploration_summaries = exp_services.get_exploration_summaries_matching_ids(exploration_ids) DCNL DCSP filtered_exploration_summaries = [] DCNL DCSP for exploration_summary in exploration_summaries: DCNL DCSP  DCSP if (exploration_summary is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (exploration_summary.status == rights_manager.ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP  DCSP if (editor_user_id is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (not rights_manager.Actor(editor_user_id).can_edit(constants.ACTIVITY_TYPE_EXPLORATION, exploration_summary.id)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP filtered_exploration_summaries.append(exploration_summary) DCNL DCSP return [summary.to_metadata_dict() for summary in filtered_exploration_summaries]
 DCSP exploration_summaries = exp_services.get_exploration_summaries_matching_ids(exploration_ids) DCNL DCSP filtered_exploration_summaries = [] DCNL DCSP for exploration_summary in exploration_summaries: DCNL DCSP  DCSP if (exploration_summary is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (exploration_summary.status == rights_manager.ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP  DCSP if (editor_user_id is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (not rights_manager.Actor(editor_user_id).can_edit(constants.ACTIVITY_TYPE_EXPLORATION, exploration_summary.id)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP filtered_exploration_summaries.append(exploration_summary) DCNL DCSP return get_displayable_exp_summary_dicts(filtered_exploration_summaries)
 DCSP exploration_ids = [exploration_summary.id for exploration_summary in exploration_summaries] DCNL DCSP view_counts = stats_jobs_continuous.StatisticsAggregator.get_views_multi(exploration_ids) DCNL DCSP displayable_exp_summaries = [] DCNL DCSP for (ind, exploration_summary) in enumerate(exploration_summaries): DCNL DCSP  DCSP if (not exploration_summary): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP summary_dict = {'id': exploration_summary.id, 'title': exploration_summary.title, 'activity_type': constants.ACTIVITY_TYPE_EXPLORATION, 'category': exploration_summary.category, 'created_on_msec': utils.get_time_in_millisecs(exploration_summary.exploration_model_created_on), 'objective': exploration_summary.objective, 'language_code': exploration_summary.language_code, 'last_updated_msec': utils.get_time_in_millisecs(exploration_summary.exploration_model_last_updated), 'human_readable_contributors_summary': get_human_readable_contributors_summary(exploration_summary.contributors_summary), 'status': exploration_summary.status, 'ratings': exploration_summary.ratings, 'community_owned': exploration_summary.community_owned, 'tags': exploration_summary.tags, 'thumbnail_icon_url': utils.get_thumbnail_icon_url_for_category(exploration_summary.category), 'thumbnail_bg_color': utils.get_hex_color_for_category(exploration_summary.category), 'num_views': view_counts[ind]} DCNL DCSP  DCSP displayable_exp_summaries.append(summary_dict) DCNL DCSP return displayable_exp_summaries
 DCSP displayable_collection_summaries = [] DCNL DCSP for collection_summary in collection_summaries: DCNL DCSP  DCSP if (collection_summary and (collection_summary.status != rights_manager.ACTIVITY_STATUS_PRIVATE)): DCNL DCSP  DCSP  DCSP displayable_collection_summaries.append({'id': collection_summary.id, 'title': collection_summary.title, 'category': collection_summary.category, 'activity_type': constants.ACTIVITY_TYPE_COLLECTION, 'objective': collection_summary.objective, 'language_code': collection_summary.language_code, 'tags': collection_summary.tags, 'node_count': collection_summary.node_count, 'last_updated_msec': utils.get_time_in_millisecs(collection_summary.collection_model_last_updated), 'thumbnail_icon_url': utils.get_thumbnail_icon_url_for_category(collection_summary.category), 'thumbnail_bg_color': utils.get_hex_color_for_category(collection_summary.category)}) DCNL DCSP return displayable_collection_summaries
 DCSP language_codes_suffix = '' DCNL DCSP if language_codes: DCNL DCSP  DCSP language_codes_suffix = (' DCSP language_code=("%s")' % '" DCSP OR DCSP "'.join(language_codes)) DCNL DCSP def _generate_query(categories): DCNL DCSP  DCSP return ('category=("%s")%s' % ('" DCSP OR DCSP "'.join(categories), language_codes_suffix)) DCNL DCSP all_collection_ids = [] DCNL DCSP header_id_to_collection_ids = {} DCNL DCSP for group in _LIBRARY_INDEX_GROUPS: DCNL DCSP  DCSP collection_ids = collection_services.search_collections(_generate_query(group['search_categories']), 8)[0] DCNL DCSP  DCSP header_id_to_collection_ids[group['header_i18n_id']] = collection_ids DCNL DCSP  DCSP all_collection_ids += collection_ids DCNL DCSP collection_summaries = [summary for summary in collection_services.get_collection_summaries_matching_ids(all_collection_ids) if (summary is not None)] DCNL DCSP collection_summary_dicts = {summary_dict['id']: summary_dict for summary_dict in _get_displayable_collection_summary_dicts(collection_summaries)} DCNL DCSP all_exp_ids = [] DCNL DCSP header_to_exp_ids = {} DCNL DCSP for group in _LIBRARY_INDEX_GROUPS: DCNL DCSP  DCSP exp_ids = exp_services.search_explorations(_generate_query(group['search_categories']), 8)[0] DCNL DCSP  DCSP header_to_exp_ids[group['header_i18n_id']] = exp_ids DCNL DCSP  DCSP all_exp_ids += exp_ids DCNL DCSP exp_summaries = [summary for summary in exp_services.get_exploration_summaries_matching_ids(all_exp_ids) if (summary is not None)] DCNL DCSP exp_summary_dicts = {summary_dict['id']: summary_dict for summary_dict in get_displayable_exp_summary_dicts(exp_summaries)} DCNL DCSP results = [] DCNL DCSP for group in _LIBRARY_INDEX_GROUPS: DCNL DCSP  DCSP summary_dicts = [] DCNL DCSP  DCSP collection_ids_to_display = header_id_to_collection_ids[group['header_i18n_id']] DCNL DCSP  DCSP summary_dicts = [collection_summary_dicts[collection_id] for collection_id in collection_ids_to_display if (collection_id in collection_summary_dicts)] DCNL DCSP  DCSP exp_ids_to_display = header_to_exp_ids[group['header_i18n_id']] DCNL DCSP  DCSP summary_dicts += [exp_summary_dicts[exp_id] for exp_id in exp_ids_to_display if (exp_id in exp_summary_dicts)] DCNL DCSP  DCSP if (not summary_dicts): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP results.append({'header_i18n_id': group['header_i18n_id'], 'categories': group['search_categories'], 'activity_summary_dicts': summary_dicts, 'has_full_results_page': True, 'full_results_url': None}) DCNL DCSP return results
 DCSP (exploration_ids, collection_ids) = activity_services.split_by_type(activity_references) DCNL DCSP activity_summaries_by_type = [{'type': constants.ACTIVITY_TYPE_EXPLORATION, 'ids': exploration_ids, 'summaries': exp_services.get_exploration_summaries_matching_ids(exploration_ids)}, {'type': constants.ACTIVITY_TYPE_COLLECTION, 'ids': collection_ids, 'summaries': collection_services.get_collection_summaries_matching_ids(collection_ids)}] DCNL DCSP for activities_info in activity_summaries_by_type: DCNL DCSP  DCSP for (index, summary) in enumerate(activities_info['summaries']): DCNL DCSP  DCSP  DCSP if (summary is None): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('Cannot DCSP feature DCSP non-existent DCSP %s DCSP with DCSP id DCSP %s' % (activities_info['type'], activities_info['ids'][index]))) DCNL DCSP  DCSP  DCSP if (summary.status == rights_manager.ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('Cannot DCSP feature DCSP private DCSP %s DCSP with DCSP id DCSP %s' % (activities_info['type'], activities_info['ids'][index])))
 DCSP activity_references = activity_services.get_featured_activity_references() DCNL DCSP (exploration_ids, collection_ids) = activity_services.split_by_type(activity_references) DCNL DCSP exp_summary_dicts = get_displayable_exp_summary_dicts_matching_ids(exploration_ids) DCNL DCSP col_summary_dicts = get_displayable_collection_summary_dicts_matching_ids(collection_ids) DCNL DCSP summary_dicts_by_id = {constants.ACTIVITY_TYPE_EXPLORATION: {summary_dict['id']: summary_dict for summary_dict in exp_summary_dicts}, constants.ACTIVITY_TYPE_COLLECTION: {summary_dict['id']: summary_dict for summary_dict in col_summary_dicts}} DCNL DCSP featured_summary_dicts = [] DCNL DCSP for reference in activity_references: DCNL DCSP  DCSP if (reference.id in summary_dicts_by_id[reference.type]): DCNL DCSP  DCSP  DCSP summary_dict = summary_dicts_by_id[reference.type][reference.id] DCNL DCSP  DCSP  DCSP if (summary_dict and (summary_dict['language_code'] in language_codes)): DCNL DCSP  DCSP  DCSP  DCSP featured_summary_dicts.append(summary_dict) DCNL DCSP return featured_summary_dicts
 DCSP filtered_exp_summaries = [exp_summary for exp_summary in exp_services.get_top_rated_exploration_summaries(limit).values() if ((exp_summary.language_code in language_codes) and (sum(exp_summary.ratings.values()) > 0))] DCNL DCSP sorted_exp_summaries = sorted(filtered_exp_summaries, key=(lambda exp_summary: exp_summary.scaled_average_rating), reverse=True) DCNL DCSP return get_displayable_exp_summary_dicts(sorted_exp_summaries)
 DCSP recently_published_exploration_summaries = [exp_summary for exp_summary in exp_services.get_recently_published_exp_summaries(limit).values()] DCNL DCSP summaries = sorted(recently_published_exploration_summaries, key=(lambda exp_summary: exp_summary.first_published_msec), reverse=True) DCNL DCSP return get_displayable_exp_summary_dicts(summaries)
 DCSP assert feconf.ENABLE_ML_CLASSIFIERS DCNL DCSP interaction_instance = interaction_registry.Registry.get_interaction_by_id(state.interaction.id) DCNL DCSP normalized_answer = interaction_instance.normalize_answer(answer) DCNL DCSP response = None DCNL DCSP if interaction_instance.is_string_classifier_trainable: DCNL DCSP  DCSP response = classify_string_classifier_rule(state, normalized_answer) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('No DCSP classifier DCSP found DCSP for DCSP interaction.') DCNL DCSP if (response is not None): DCNL DCSP  DCSP return response DCNL DCSP elif (state.interaction.default_outcome is not None): DCNL DCSP  DCSP return {'outcome': state.interaction.default_outcome.to_dict(), 'answer_group_index': len(state.interaction.answer_groups), 'classification_certainty': 0.0, 'rule_spec_index': 0} DCNL DCSP raise Exception('Something DCSP has DCSP seriously DCSP gone DCSP wrong DCSP with DCSP the DCSP exploration. DCSP Oppia DCSP does DCSP not DCSP know DCSP what DCSP to DCSP do DCSP with DCSP this DCSP answer. DCSP Please DCSP contact DCSP the DCSP exploration DCSP owner.')
 DCSP best_matched_answer_group = None DCNL DCSP best_matched_answer_group_index = len(state.interaction.answer_groups) DCNL DCSP best_matched_rule_spec_index = None DCNL DCSP sc = classifier_registry.Registry.get_classifier_by_algorithm_id(feconf.INTERACTION_CLASSIFIER_MAPPING[state.interaction.id]['algorithm_id']) DCNL DCSP training_examples = [[doc, []] for doc in state.interaction.confirmed_unclassified_answers] DCNL DCSP for (answer_group_index, answer_group) in enumerate(state.interaction.answer_groups): DCNL DCSP  DCSP classifier_rule_spec_index = answer_group.get_classifier_rule_index() DCNL DCSP  DCSP if (classifier_rule_spec_index is not None): DCNL DCSP  DCSP  DCSP classifier_rule_spec = answer_group.rule_specs[classifier_rule_spec_index] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP classifier_rule_spec = None DCNL DCSP  DCSP if (classifier_rule_spec is not None): DCNL DCSP  DCSP  DCSP training_examples.extend([[doc, [str(answer_group_index)]] for doc in classifier_rule_spec.inputs['training_data']]) DCNL DCSP if (len(training_examples) > 0): DCNL DCSP  DCSP sc.train(training_examples) DCNL DCSP  DCSP labels = sc.predict([normalized_answer]) DCNL DCSP  DCSP predicted_label = labels[0] DCNL DCSP  DCSP if (predicted_label != feconf.DEFAULT_CLASSIFIER_LABEL): DCNL DCSP  DCSP  DCSP predicted_answer_group_index = int(predicted_label) DCNL DCSP  DCSP  DCSP predicted_answer_group = state.interaction.answer_groups[predicted_answer_group_index] DCNL DCSP  DCSP  DCSP for rule_spec in predicted_answer_group.rule_specs: DCNL DCSP  DCSP  DCSP  DCSP if (rule_spec.rule_type == exp_domain.RULE_TYPE_CLASSIFIER): DCNL DCSP  DCSP  DCSP  DCSP  DCSP best_matched_rule_spec_index = classifier_rule_spec_index DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP best_matched_answer_group = predicted_answer_group DCNL DCSP  DCSP  DCSP best_matched_answer_group_index = predicted_answer_group_index DCNL DCSP  DCSP  DCSP return {'outcome': best_matched_answer_group.outcome.to_dict(), 'answer_group_index': best_matched_answer_group_index, 'rule_spec_index': best_matched_rule_spec_index} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP return None
 DCSP job_dicts_list = [] DCNL DCSP exp_id = exploration.id DCNL DCSP exp_version = exploration.version DCNL DCSP for state_name in state_names: DCNL DCSP  DCSP state = exploration.states[state_name] DCNL DCSP  DCSP training_data = state.get_training_data() DCNL DCSP  DCSP interaction_id = state.interaction.id DCNL DCSP  DCSP algorithm_id = feconf.INTERACTION_CLASSIFIER_MAPPING[interaction_id]['algorithm_id'] DCNL DCSP  DCSP dummy_classifier_training_job = classifier_domain.ClassifierTrainingJob('job_id_dummy', algorithm_id, interaction_id, exp_id, exp_version, state_name, feconf.TRAINING_JOB_STATUS_NEW, training_data) DCNL DCSP  DCSP dummy_classifier_training_job.validate() DCNL DCSP  DCSP job_dicts_list.append({'algorithm_id': algorithm_id, 'interaction_id': interaction_id, 'exp_id': exp_id, 'exp_version': exp_version, 'state_name': state_name, 'training_data': training_data, 'status': feconf.TRAINING_JOB_STATUS_NEW}) DCNL DCSP job_ids = classifier_models.ClassifierTrainingJobModel.create_multi(job_dicts_list) DCNL DCSP job_exploration_mappings = [] DCNL DCSP for (job_id_index, job_id) in enumerate(job_ids): DCNL DCSP  DCSP job_exploration_mapping = classifier_domain.TrainingJobExplorationMapping(job_dicts_list[job_id_index]['exp_id'], job_dicts_list[job_id_index]['exp_version'], job_dicts_list[job_id_index]['state_name'], job_id) DCNL DCSP  DCSP job_exploration_mapping.validate() DCNL DCSP  DCSP job_exploration_mappings.append(job_exploration_mapping) DCNL DCSP classifier_models.TrainingJobExplorationMappingModel.create_multi(job_exploration_mappings)
 DCSP exp_id = exploration.id DCNL DCSP current_exp_version = exploration.version DCNL DCSP old_exp_version = (current_exp_version - 1) DCNL DCSP if (old_exp_version <= 0): DCNL DCSP  DCSP raise Exception(('This DCSP method DCSP should DCSP not DCSP be DCSP called DCSP by DCSP exploration DCSP with DCSP version DCSP number DCSP %s' % current_exp_version)) DCNL DCSP state_names_to_retrieve = [] DCNL DCSP for current_state_name in state_names: DCNL DCSP  DCSP old_state_name = new_to_old_state_names[current_state_name] DCNL DCSP  DCSP state_names_to_retrieve.append(old_state_name) DCNL DCSP classifier_training_jobs = get_classifier_training_jobs(exp_id, old_exp_version, state_names_to_retrieve) DCNL DCSP job_exploration_mappings = [] DCNL DCSP for (index, classifier_training_job) in enumerate(classifier_training_jobs): DCNL DCSP  DCSP if (classifier_training_job is None): DCNL DCSP  DCSP  DCSP logging.error(('The DCSP ClassifierTrainingJobModel DCSP for DCSP the DCSP %s DCSP state DCSP of DCSP Exploration DCSP with DCSP exp_id DCSP %s DCSP and DCSP exp_version DCSP %s DCSP does DCSP not DCSP exist.' % (state_names_to_retrieve[index], exp_id, old_exp_version))) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP new_state_name = state_names[index] DCNL DCSP  DCSP job_exploration_mapping = classifier_domain.TrainingJobExplorationMapping(exp_id, current_exp_version, new_state_name, classifier_training_job.job_id) DCNL DCSP  DCSP job_exploration_mapping.validate() DCNL DCSP  DCSP job_exploration_mappings.append(job_exploration_mapping) DCNL DCSP classifier_models.TrainingJobExplorationMappingModel.create_multi(job_exploration_mappings)
 DCSP return classifier_domain.ClassifierData(classifier_data_model.id, classifier_data_model.exp_id, classifier_data_model.exp_version_when_created, classifier_data_model.state_name, classifier_data_model.algorithm_id, classifier_data_model.classifier_data, classifier_data_model.data_schema_version)
 DCSP classifier_data_model = classifier_models.ClassifierDataModel.get(classifier_id) DCNL DCSP classifier = get_classifier_from_model(classifier_data_model) DCNL DCSP return classifier
 DCSP classifier_data_model = classifier_models.ClassifierDataModel.get(job_id, strict=False) DCNL DCSP if (classifier_data_model is not None): DCNL DCSP  DCSP raise Exception('The DCSP ClassifierDataModel DCSP corresponding DCSP to DCSP the DCSP job DCSP already DCSP exists.') DCNL DCSP classifier_training_job = get_classifier_training_job_by_id(job_id) DCNL DCSP state_name = classifier_training_job.state_name DCNL DCSP exp_id = classifier_training_job.exp_id DCNL DCSP exp_version = classifier_training_job.exp_version DCNL DCSP algorithm_id = classifier_training_job.algorithm_id DCNL DCSP interaction_id = classifier_training_job.interaction_id DCNL DCSP data_schema_version = None DCNL DCSP if (feconf.INTERACTION_CLASSIFIER_MAPPING[interaction_id]['algorithm_id'] == algorithm_id): DCNL DCSP  DCSP data_schema_version = feconf.INTERACTION_CLASSIFIER_MAPPING[interaction_id]['current_data_schema_version'] DCNL DCSP if (data_schema_version is None): DCNL DCSP  DCSP raise Exception('The DCSP algorithm_id DCSP of DCSP the DCSP job DCSP does DCSP not DCSP exist DCSP in DCSP the DCSP Interaction DCSP Classifier DCSP Mapping.') DCNL DCSP classifier = classifier_domain.ClassifierData(job_id, exp_id, exp_version, state_name, algorithm_id, classifier_data, data_schema_version) DCNL DCSP classifier.validate() DCNL DCSP classifier_id = classifier_models.ClassifierDataModel.create(classifier.id, classifier.exp_id, classifier.exp_version_when_created, classifier.state_name, classifier.algorithm_id, classifier.classifier_data, classifier.data_schema_version) DCNL DCSP return classifier_id
 DCSP classifier_data_model = classifier_models.ClassifierDataModel.get(classifier_id) DCNL DCSP classifier_data_model.delete()
 DCSP return classifier_domain.ClassifierTrainingJob(classifier_training_job_model.id, classifier_training_job_model.algorithm_id, classifier_training_job_model.interaction_id, classifier_training_job_model.exp_id, classifier_training_job_model.exp_version, classifier_training_job_model.state_name, classifier_training_job_model.status, classifier_training_job_model.training_data)
 DCSP classifier_training_job_model = classifier_models.ClassifierTrainingJobModel.get(job_id) DCNL DCSP classifier_training_job = get_classifier_training_job_from_model(classifier_training_job_model) DCNL DCSP return classifier_training_job
 DCSP classifier_training_job_model = classifier_models.ClassifierTrainingJobModel.get(job_id, strict=False) DCNL DCSP if (not classifier_training_job_model): DCNL DCSP  DCSP raise Exception('The DCSP ClassifierTrainingJobModel DCSP corresponding DCSP to DCSP the DCSP job_id DCSP of DCSP theClassifierTrainingJob DCSP does DCSP not DCSP exist.') DCNL DCSP initial_status = classifier_training_job_model.status DCNL DCSP if (status not in feconf.ALLOWED_TRAINING_JOB_STATUS_CHANGES[initial_status]): DCNL DCSP  DCSP raise Exception(('The DCSP status DCSP change DCSP %s DCSP to DCSP %s DCSP is DCSP not DCSP valid.' % (initial_status, status))) DCNL DCSP classifier_training_job = get_classifier_training_job_by_id(job_id) DCNL DCSP classifier_training_job.update_status(status) DCNL DCSP classifier_training_job.validate() DCNL DCSP classifier_training_job_model.status = status DCNL DCSP classifier_training_job_model.put()
 DCSP _update_classifier_training_job_status(job_id, feconf.TRAINING_JOB_STATUS_COMPLETE)
 DCSP classifier_training_job_model = classifier_models.ClassifierTrainingJobModel.get(job_id) DCNL DCSP if (classifier_training_job_model is not None): DCNL DCSP  DCSP classifier_training_job_model.delete()
 DCSP training_job_exploration_mapping_models = classifier_models.TrainingJobExplorationMappingModel.get_models(exp_id, exp_version, state_names) DCNL DCSP job_ids = [] DCNL DCSP for mapping_model in training_job_exploration_mapping_models: DCNL DCSP  DCSP if (mapping_model is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP job_ids.append(mapping_model.job_id) DCNL DCSP classifier_training_job_models = classifier_models.ClassifierTrainingJobModel.get_multi(job_ids) DCNL DCSP classifier_training_jobs = [] DCNL DCSP for job_model in classifier_training_job_models: DCNL DCSP  DCSP classifier_training_jobs.append(get_classifier_training_job_from_model(job_model)) DCNL DCSP for (index, mapping_model) in enumerate(training_job_exploration_mapping_models): DCNL DCSP  DCSP if (mapping_model is None): DCNL DCSP  DCSP  DCSP classifier_training_jobs.insert(index, None) DCNL DCSP return classifier_training_jobs
 DCSP if (intent not in SENDER_VALIDATORS): DCNL DCSP  DCSP raise Exception(('Invalid DCSP email DCSP intent DCSP string: DCSP %s' % intent)) DCNL DCSP elif (not SENDER_VALIDATORS[intent](sender_id)): DCNL DCSP  DCSP logging.error(("Invalid DCSP sender_id DCSP %s DCSP for DCSP email DCSP with DCSP intent DCSP '%s'" % (sender_id, intent))) DCNL DCSP  DCSP raise Exception(("Invalid DCSP sender_id DCSP for DCSP email DCSP with DCSP intent DCSP '%s'" % intent))
 DCSP if (sender_name is None): DCNL DCSP  DCSP sender_name = EMAIL_SENDER_NAME.value DCNL DCSP _require_sender_id_is_valid(intent, sender_id) DCNL DCSP recipient_email = user_services.get_email_from_user_id(recipient_id) DCNL DCSP cleaned_html_body = html_cleaner.clean(email_html_body) DCNL DCSP if (cleaned_html_body != email_html_body): DCNL DCSP  DCSP log_new_error(('Original DCSP email DCSP HTML DCSP body DCSP does DCSP not DCSP match DCSP cleaned DCSP HTML DCSP body:\nOriginal:\n%s\n\nCleaned:\n%s\n' % (email_html_body, cleaned_html_body))) DCNL DCSP  DCSP return DCNL DCSP raw_plaintext_body = cleaned_html_body.replace('<br/>', '\n').replace('<br>', '\n').replace('<li>', '<li>- DCSP ').replace('</p><p>', '</p>\n<p>') DCNL DCSP cleaned_plaintext_body = html_cleaner.strip_html_tags(raw_plaintext_body) DCNL DCSP if email_models.SentEmailModel.check_duplicate_message(recipient_id, email_subject, cleaned_plaintext_body): DCNL DCSP  DCSP log_new_error(('Duplicate DCSP email:\nDetails:\n%s DCSP %s\n%s\n\n' % (recipient_id, email_subject, cleaned_plaintext_body))) DCNL DCSP  DCSP return DCNL DCSP def _send_email_in_transaction(): DCNL DCSP  DCSP sender_name_email = ('%s DCSP <%s>' % (sender_name, sender_email)) DCNL DCSP  DCSP email_services.send_mail(sender_name_email, recipient_email, email_subject, cleaned_plaintext_body, cleaned_html_body, bcc_admin, reply_to_id=reply_to_id) DCNL DCSP  DCSP email_models.SentEmailModel.create(recipient_id, recipient_email, sender_id, sender_name_email, intent, email_subject, cleaned_html_body, datetime.datetime.utcnow()) DCNL DCSP return transaction_services.run_in_transaction(_send_email_in_transaction)
 DCSP _require_sender_id_is_valid(intent, sender_id) DCNL DCSP recipients_settings = user_services.get_users_settings(recipient_ids) DCNL DCSP recipient_emails = [user.email for user in recipients_settings] DCNL DCSP cleaned_html_body = html_cleaner.clean(email_html_body) DCNL DCSP if (cleaned_html_body != email_html_body): DCNL DCSP  DCSP log_new_error(('Original DCSP email DCSP HTML DCSP body DCSP does DCSP not DCSP match DCSP cleaned DCSP HTML DCSP body:\nOriginal:\n%s\n\nCleaned:\n%s\n' % (email_html_body, cleaned_html_body))) DCNL DCSP  DCSP return DCNL DCSP raw_plaintext_body = cleaned_html_body.replace('<br/>', '\n').replace('<br>', '\n').replace('<li>', '<li>- DCSP ').replace('</p><p>', '</p>\n<p>') DCNL DCSP cleaned_plaintext_body = html_cleaner.strip_html_tags(raw_plaintext_body) DCNL DCSP def _send_bulk_mail_in_transaction(instance_id=None): DCNL DCSP  DCSP sender_name_email = ('%s DCSP <%s>' % (sender_name, sender_email)) DCNL DCSP  DCSP email_services.send_bulk_mail(sender_name_email, recipient_emails, email_subject, cleaned_plaintext_body, cleaned_html_body) DCNL DCSP  DCSP if (instance_id is None): DCNL DCSP  DCSP  DCSP instance_id = email_models.BulkEmailModel.get_new_id('') DCNL DCSP  DCSP email_models.BulkEmailModel.create(instance_id, recipient_ids, sender_id, sender_name_email, intent, email_subject, cleaned_html_body, datetime.datetime.utcnow()) DCNL DCSP return transaction_services.run_in_transaction(_send_bulk_mail_in_transaction, instance_id)
 DCSP app_id = app_identity_services.get_application_id() DCNL DCSP body = ('(Sent DCSP from DCSP %s)\n\n%s' % (app_id, email_body)) DCNL DCSP email_services.send_mail(feconf.SYSTEM_EMAIL_ADDRESS, feconf.ADMIN_EMAIL_ADDRESS, email_subject, body, body.replace('\n', '<br/>'), bcc_admin=False)
 DCSP for (key, content) in SIGNUP_EMAIL_CONTENT.value.iteritems(): DCNL DCSP  DCSP if (content == SIGNUP_EMAIL_CONTENT.default_value[key]): DCNL DCSP  DCSP  DCSP log_new_error('Please DCSP ensure DCSP that DCSP the DCSP value DCSP for DCSP the DCSP admin DCSP config DCSP property DCSP SIGNUP_EMAIL_CONTENT DCSP is DCSP set, DCSP before DCSP allowing DCSP post-signup DCSP emails DCSP to DCSP be DCSP sent.') DCNL DCSP  DCSP  DCSP return DCNL DCSP user_settings = user_services.get_user_settings(user_id) DCNL DCSP email_subject = SIGNUP_EMAIL_CONTENT.value['subject'] DCNL DCSP email_body = ('Hi DCSP %s,<br><br>%s<br><br>%s' % (user_settings.username, SIGNUP_EMAIL_CONTENT.value['html_body'], EMAIL_FOOTER.value)) DCNL DCSP _send_email(user_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_SIGNUP, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)
 DCSP if (intent not in feconf.VALID_MODERATOR_ACTIONS): DCNL DCSP  DCSP raise Exception(('Unrecognized DCSP email DCSP intent: DCSP %s' % intent))
 DCSP require_valid_intent(intent) DCNL DCSP return config_domain.Registry.get_config_property(feconf.VALID_MODERATOR_ACTIONS[intent]['email_config'])
 DCSP try: DCNL DCSP  DCSP require_moderator_email_prereqs_are_satisfied() DCNL DCSP  DCSP return _get_email_config(intent).value DCNL DCSP except Exception: DCNL DCSP  DCSP return ''
 DCSP if (not feconf.REQUIRE_EMAIL_ON_MODERATOR_ACTION): DCNL DCSP  DCSP raise Exception('For DCSP moderator DCSP emails DCSP to DCSP be DCSP sent, DCSP please DCSP ensure DCSP that DCSP REQUIRE_EMAIL_ON_MODERATOR_ACTION DCSP is DCSP set DCSP to DCSP True.') DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP raise Exception('For DCSP moderator DCSP emails DCSP to DCSP be DCSP sent, DCSP please DCSP ensure DCSP that DCSP CAN_SEND_EMAILS DCSP is DCSP set DCSP to DCSP True.')
 DCSP require_moderator_email_prereqs_are_satisfied() DCNL DCSP email_config = feconf.VALID_MODERATOR_ACTIONS[intent] DCNL DCSP recipient_user_settings = user_services.get_user_settings(recipient_id) DCNL DCSP sender_user_settings = user_services.get_user_settings(sender_id) DCNL DCSP email_subject = feconf.VALID_MODERATOR_ACTIONS[intent]['email_subject_fn'](exploration_title) DCNL DCSP email_salutation_html = email_config['email_salutation_html_fn'](recipient_user_settings.username) DCNL DCSP email_signoff_html = email_config['email_signoff_html_fn'](sender_user_settings.username) DCNL DCSP full_email_content = ('%s<br><br>%s<br><br>%s<br><br>%s' % (email_salutation_html, email_body, email_signoff_html, EMAIL_FOOTER.value)) DCNL DCSP _send_email(recipient_id, sender_id, intent, email_subject, full_email_content, feconf.SYSTEM_EMAIL_ADDRESS, bcc_admin=True)
 DCSP email_subject_template = '%s DCSP - DCSP invitation DCSP to DCSP collaborate' DCNL DCSP email_body_template = 'Hi DCSP %s,<br><br><b>%s</b> DCSP has DCSP granted DCSP you DCSP %s DCSP to DCSP their DCSP exploration, DCSP "<a DCSP href="http://www.oppia.org/create/%s">%s</a>", DCSP on DCSP Oppia.org.<br><br>This DCSP allows DCSP you DCSP to:<br><ul>%s</ul>You DCSP can DCSP find DCSP the DCSP exploration DCSP <a DCSP href="http://www.oppia.org/create/%s">here</a>.<br><br>Thanks, DCSP and DCSP happy DCSP collaborating!<br><br>Best DCSP wishes,<br>The DCSP Oppia DCSP Team<br><br>%s' DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP if (not feconf.CAN_SEND_EDITOR_ROLE_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP editor DCSP role DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP recipient_user_settings = user_services.get_user_settings(recipient_id) DCNL DCSP inviter_user_settings = user_services.get_user_settings(inviter_id) DCNL DCSP recipient_preferences = user_services.get_email_preferences(recipient_id) DCNL DCSP if (not recipient_preferences.can_receive_editor_role_email): DCNL DCSP  DCSP return DCNL DCSP if (recipient_role not in EDITOR_ROLE_EMAIL_HTML_ROLES): DCNL DCSP  DCSP raise Exception(('Invalid DCSP role: DCSP %s' % recipient_role)) DCNL DCSP role_description = EDITOR_ROLE_EMAIL_HTML_ROLES[recipient_role] DCNL DCSP rights_html = EDITOR_ROLE_EMAIL_RIGHTS_FOR_ROLE[role_description] DCNL DCSP email_subject = (email_subject_template % exploration_title) DCNL DCSP email_body = (email_body_template % (recipient_user_settings.username, inviter_user_settings.username, role_description, exploration_id, exploration_title, rights_html, exploration_id, EMAIL_FOOTER.value)) DCNL DCSP _send_email(recipient_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_EDITOR_ROLE_NOTIFICATION, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS, sender_name=inviter_user_settings.username)
 DCSP creator_name = user_services.get_username(creator_id) DCNL DCSP email_subject = ('%s DCSP has DCSP published DCSP a DCSP new DCSP exploration!' % creator_name) DCNL DCSP email_body_template = 'Hi DCSP %s,<br><br>%s DCSP has DCSP published DCSP a DCSP new DCSP exploration! DCSP You DCSP can DCSP play DCSP it DCSP here: DCSP <a DCSP href="https://www.oppia.org/explore/%s">%s</a><br><br>Thanks, DCSP and DCSP happy DCSP learning!<br><br>Best DCSP wishes,<br>- DCSP The DCSP Oppia DCSP Team<br><br>%s' DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP if (not feconf.CAN_SEND_SUBSCRIPTION_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP subscription DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP recipient_list = subscription_services.get_all_subscribers_of_creator(creator_id) DCNL DCSP recipients_usernames = user_services.get_usernames(recipient_list) DCNL DCSP recipients_preferences = user_services.get_users_email_preferences(recipient_list) DCNL DCSP for (index, username) in enumerate(recipients_usernames): DCNL DCSP  DCSP if recipients_preferences[index].can_receive_subscription_email: DCNL DCSP  DCSP  DCSP email_body = (email_body_template % (username, creator_name, exploration_id, exploration_title, EMAIL_FOOTER.value)) DCNL DCSP  DCSP  DCSP _send_email(recipient_list[index], feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_SUBSCRIPTION_NOTIFICATION, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)
 DCSP email_subject_template = "You've DCSP received DCSP %s DCSP new DCSP message%s DCSP on DCSP your DCSP explorations" DCNL DCSP email_body_template = 'Hi DCSP %s,<br><br>You\'ve DCSP received DCSP %s DCSP new DCSP message%s DCSP on DCSP your DCSP Oppia DCSP explorations:<br><ul>%s</ul>You DCSP can DCSP view DCSP and DCSP reply DCSP to DCSP your DCSP messages DCSP from DCSP your DCSP <a DCSP href="https://www.oppia.org/creator_dashboard">dashboard</a>.<br><br>Thanks, DCSP and DCSP happy DCSP teaching!<br><br>Best DCSP wishes,<br>The DCSP Oppia DCSP Team<br><br>%s' DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP if (not feconf.CAN_SEND_FEEDBACK_MESSAGE_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP feedback DCSP message DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP if (not feedback_messages): DCNL DCSP  DCSP return DCNL DCSP recipient_user_settings = user_services.get_user_settings(recipient_id) DCNL DCSP messages_html = '' DCNL DCSP count_messages = 0 DCNL DCSP for (exp_id, reference) in feedback_messages.iteritems(): DCNL DCSP  DCSP messages_html += ('<li><a DCSP href="https://www.oppia.org/create/%s#/feedback">%s</a>:<br><ul>' % (exp_id, reference['title'])) DCNL DCSP  DCSP for message in reference['messages']: DCNL DCSP  DCSP  DCSP messages_html += ('<li>%s<br></li>' % message) DCNL DCSP  DCSP  DCSP count_messages += 1 DCNL DCSP  DCSP messages_html += '</ul></li>' DCNL DCSP email_subject = (email_subject_template % ((count_messages, 's') if (count_messages > 1) else ('a', ''))) DCNL DCSP email_body = (email_body_template % (recipient_user_settings.username, (count_messages if (count_messages > 1) else 'a'), ('s' if (count_messages > 1) else ''), messages_html, EMAIL_FOOTER.value)) DCNL DCSP _send_email(recipient_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_FEEDBACK_MESSAGE_NOTIFICATION, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)
 DCSP users_global_prefs = user_services.get_users_email_preferences(recipient_ids) DCNL DCSP users_exploration_prefs = user_services.get_users_email_preferences_for_exploration(recipient_ids, exploration_id) DCNL DCSP zipped_preferences = zip(users_global_prefs, users_exploration_prefs) DCNL DCSP result = [] DCNL DCSP if has_suggestion: DCNL DCSP  DCSP for (user_global_prefs, user_exploration_prefs) in zipped_preferences: DCNL DCSP  DCSP  DCSP result.append((user_global_prefs.can_receive_feedback_message_email and (not user_exploration_prefs.mute_suggestion_notifications))) DCNL DCSP else: DCNL DCSP  DCSP for (user_global_prefs, user_exploration_prefs) in zipped_preferences: DCNL DCSP  DCSP  DCSP result.append((user_global_prefs.can_receive_feedback_message_email and (not user_exploration_prefs.mute_feedback_notifications))) DCNL DCSP return result
 DCSP email_subject = ('New DCSP suggestion DCSP for DCSP "%s"' % exploration_title) DCNL DCSP email_body_template = 'Hi DCSP %s,<br>%s DCSP has DCSP submitted DCSP a DCSP new DCSP suggestion DCSP for DCSP your DCSP Oppia DCSP exploration, DCSP <a DCSP href="https://www.oppia.org/create/%s">"%s"</a>.<br>You DCSP can DCSP accept DCSP or DCSP reject DCSP this DCSP suggestion DCSP by DCSP visiting DCSP the DCSP <a DCSP href="https://www.oppia.org/create/%s#/feedback">feedback DCSP page</a> DCSP for DCSP your DCSP exploration.<br><br>Thanks!<br>- DCSP The DCSP Oppia DCSP Team<br><br>%s' DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP if (not feconf.CAN_SEND_FEEDBACK_MESSAGE_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP feedback DCSP message DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP author_settings = user_services.get_user_settings(author_id) DCNL DCSP can_users_receive_email = can_users_receive_thread_email(recipient_list, exploration_id, True) DCNL DCSP for (index, recipient_id) in enumerate(recipient_list): DCNL DCSP  DCSP recipient_user_settings = user_services.get_user_settings(recipient_id) DCNL DCSP  DCSP if can_users_receive_email[index]: DCNL DCSP  DCSP  DCSP email_body = (email_body_template % (recipient_user_settings.username, author_settings.username, exploration_id, exploration_title, exploration_id, EMAIL_FOOTER.value)) DCNL DCSP  DCSP  DCSP _send_email(recipient_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_SUGGESTION_NOTIFICATION, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)
 DCSP email_body_template = 'Hi DCSP %s,<br><br>New DCSP update DCSP to DCSP thread DCSP "%s" DCSP on DCSP <a DCSP href="https://www.oppia.org/create/%s#/feedback">%s</a>:<br><ul><li>%s: DCSP %s<br></li></ul>(You DCSP received DCSP this DCSP message DCSP because DCSP you DCSP are DCSP a DCSP participant DCSP in DCSP this DCSP thread.)<br><br>Best DCSP wishes,<br>The DCSP Oppia DCSP team<br><br>%s' DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP if (not feconf.CAN_SEND_FEEDBACK_MESSAGE_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP feedback DCSP message DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP sender_settings = user_services.get_user_settings(sender_id) DCNL DCSP recipient_settings = user_services.get_user_settings(recipient_id) DCNL DCSP recipient_preferences = user_services.get_email_preferences(recipient_id) DCNL DCSP if recipient_preferences.can_receive_feedback_message_email: DCNL DCSP  DCSP email_body = (email_body_template % (recipient_settings.username, thread_title, exploration_id, exploration_title, sender_settings.username, message, EMAIL_FOOTER.value)) DCNL DCSP  DCSP _send_email(recipient_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_FEEDBACK_MESSAGE_NOTIFICATION, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS, reply_to_id=reply_to_id)
 DCSP email_subject = ('Exploration DCSP flagged DCSP by DCSP user: DCSP "%s"' % exploration_title) DCNL DCSP email_body_template = 'Hello DCSP Moderator,<br>%s DCSP has DCSP flagged DCSP exploration DCSP "%s" DCSP on DCSP the DCSP following DCSP grounds: DCSP <br>%s DCSP .<br>You DCSP can DCSP modify DCSP the DCSP exploration DCSP by DCSP clicking DCSP <a DCSP href="https://www.oppia.org/create/%s">here</a>.<br><br>Thanks!<br>- DCSP The DCSP Oppia DCSP Team<br><br>%s' DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP email_body = (email_body_template % (user_services.get_user_settings(reporter_id).username, exploration_title, report_text, exploration_id, EMAIL_FOOTER.value)) DCNL DCSP recipient_list = config_domain.MODERATOR_IDS.value DCNL DCSP for recipient_id in recipient_list: DCNL DCSP  DCSP _send_email(recipient_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_REPORT_BAD_CONTENT, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)
 DCSP email_subject = ('Query DCSP %s DCSP has DCSP successfully DCSP completed' % query_id) DCNL DCSP email_body_template = 'Hi DCSP %s,<br>Your DCSP query DCSP with DCSP id DCSP %s DCSP has DCSP succesfully DCSP completed DCSP its DCSP execution. DCSP Visit DCSP the DCSP result DCSP page DCSP <a DCSP href="https://www.oppia.org/emaildashboardresult/%s">here</a> DCSP to DCSP see DCSP result DCSP of DCSP your DCSP query.<br><br>Thanks!<br><br>Best DCSP wishes,<br>The DCSP Oppia DCSP Team<br><br>%s' DCNL DCSP recipient_user_settings = user_services.get_user_settings(recipient_id) DCNL DCSP email_body = (email_body_template % (recipient_user_settings.username, query_id, query_id, EMAIL_FOOTER.value)) DCNL DCSP _send_email(recipient_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_QUERY_STATUS_NOTIFICATION, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)
 DCSP email_subject = ('Query DCSP %s DCSP has DCSP failed' % query_id) DCNL DCSP email_body_template = 'Hi DCSP %s,<br>Your DCSP query DCSP with DCSP id DCSP %s DCSP has DCSP failed DCSP due DCSP to DCSP error DCSP during DCSP execution. DCSP Please DCSP check DCSP the DCSP query DCSP parameters DCSP and DCSP submit DCSP query DCSP again.<br><br>Thanks!<br><br>Best DCSP wishes,<br>The DCSP Oppia DCSP Team<br><br>%s' DCNL DCSP recipient_user_settings = user_services.get_user_settings(recipient_id) DCNL DCSP email_body = (email_body_template % (recipient_user_settings.username, query_id, EMAIL_FOOTER.value)) DCNL DCSP _send_email(recipient_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_QUERY_STATUS_NOTIFICATION, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS) DCNL DCSP admin_email_subject = 'Query DCSP job DCSP has DCSP failed.' DCNL DCSP admin_email_body_template = 'Query DCSP job DCSP with DCSP %s DCSP query DCSP id DCSP has DCSP failed DCSP in DCSP its DCSP execution.\nQuery DCSP parameters:\n\n' DCNL DCSP for key in sorted(query_params): DCNL DCSP  DCSP admin_email_body_template += ('%s: DCSP %s\n' % (key, query_params[key])) DCNL DCSP admin_email_body = (admin_email_body_template % query_id) DCNL DCSP send_mail_to_admin(admin_email_subject, admin_email_body)
 DCSP subscriptions_model = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP if (not subscriptions_model): DCNL DCSP  DCSP subscriptions_model = user_models.UserSubscriptionsModel(id=user_id) DCNL DCSP if (feedback_thread_id not in subscriptions_model.feedback_thread_ids): DCNL DCSP  DCSP subscriptions_model.feedback_thread_ids.append(feedback_thread_id) DCNL DCSP  DCSP subscriptions_model.put()
 DCSP subscriptions_model = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP if (not subscriptions_model): DCNL DCSP  DCSP subscriptions_model = user_models.UserSubscriptionsModel(id=user_id) DCNL DCSP if (exploration_id not in subscriptions_model.activity_ids): DCNL DCSP  DCSP subscriptions_model.activity_ids.append(exploration_id) DCNL DCSP  DCSP subscriptions_model.put()
 DCSP subscribers_model_creator = user_models.UserSubscribersModel.get(creator_id, strict=False) DCNL DCSP subscriptions_model_user = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP if (not subscribers_model_creator): DCNL DCSP  DCSP subscribers_model_creator = user_models.UserSubscribersModel(id=creator_id) DCNL DCSP if (not subscriptions_model_user): DCNL DCSP  DCSP subscriptions_model_user = user_models.UserSubscriptionsModel(id=user_id) DCNL DCSP if (user_id not in subscribers_model_creator.subscriber_ids): DCNL DCSP  DCSP subscribers_model_creator.subscriber_ids.append(user_id) DCNL DCSP  DCSP subscriptions_model_user.creator_ids.append(creator_id) DCNL DCSP  DCSP subscribers_model_creator.put() DCNL DCSP  DCSP subscriptions_model_user.put()
 DCSP subscribers_model_creator = user_models.UserSubscribersModel.get(creator_id, strict=False) DCNL DCSP subscriptions_model_user = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP if (user_id in subscribers_model_creator.subscriber_ids): DCNL DCSP  DCSP subscribers_model_creator.subscriber_ids.remove(user_id) DCNL DCSP  DCSP subscriptions_model_user.creator_ids.remove(creator_id) DCNL DCSP  DCSP subscribers_model_creator.put() DCNL DCSP  DCSP subscriptions_model_user.put()
 DCSP subscriptions_model = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP return (subscriptions_model.feedback_thread_ids if subscriptions_model else [])
 DCSP subscriptions_model = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP return (subscriptions_model.creator_ids if subscriptions_model else [])
 DCSP subscribers_model = user_models.UserSubscribersModel.get(user_id, strict=False) DCNL DCSP return (subscribers_model.subscriber_ids if subscribers_model else [])
 DCSP subscriptions_model = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP return (subscriptions_model.activity_ids if subscriptions_model else [])
 DCSP subscriptions_model = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP if (not subscriptions_model): DCNL DCSP  DCSP subscriptions_model = user_models.UserSubscriptionsModel(id=user_id) DCNL DCSP if (collection_id not in subscriptions_model.collection_ids): DCNL DCSP  DCSP subscriptions_model.collection_ids.append(collection_id) DCNL DCSP  DCSP subscriptions_model.put()
 DCSP subscriptions_model = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP return (subscriptions_model.collection_ids if subscriptions_model else [])
 DCSP subscriptions_model = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP return (utils.get_time_in_millisecs(subscriptions_model.last_checked) if (subscriptions_model and subscriptions_model.last_checked) else None)
 DCSP subscriptions_model = user_models.UserSubscriptionsModel.get(user_id, strict=False) DCNL DCSP if (not subscriptions_model): DCNL DCSP  DCSP subscriptions_model = user_models.UserSubscriptionsModel(id=user_id) DCNL DCSP subscriptions_model.last_checked = datetime.datetime.utcfromtimestamp((last_seen_msecs / 1000.0)) DCNL DCSP subscriptions_model.put()
 DCSP return user_models.UserSettingsModel.is_normalized_username_taken(UserSettings.normalize_username(username))
 DCSP user_settings = get_user_settings(user_id) DCNL DCSP return user_settings.email
 DCSP user_model = user_models.UserSettingsModel.get_by_normalized_username(UserSettings.normalize_username(username)) DCNL DCSP if (user_model is None): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return user_model.email
 DCSP user_model = user_models.UserSettingsModel.get_by_normalized_username(UserSettings.normalize_username(username)) DCNL DCSP if (user_model is None): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return user_model.id
 DCSP user_model = user_models.UserSettingsModel.get_by_normalized_username(UserSettings.normalize_username(username)) DCNL DCSP if (user_model is None): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return get_user_settings(user_model.id)
 DCSP user_settings_models = user_models.UserSettingsModel.get_multi(user_ids) DCNL DCSP result = [] DCNL DCSP for (ind, model) in enumerate(user_settings_models): DCNL DCSP  DCSP if (user_ids[ind] == feconf.SYSTEM_COMMITTER_ID): DCNL DCSP  DCSP  DCSP result.append(UserSettings(feconf.SYSTEM_COMMITTER_ID, email=feconf.SYSTEM_EMAIL_ADDRESS, role=feconf.ROLE_ID_ADMIN, username='admin', last_agreed_to_terms=datetime.datetime.utcnow())) DCNL DCSP  DCSP elif model: DCNL DCSP  DCSP  DCSP result.append(UserSettings(model.id, email=model.email, role=model.role, username=model.username, last_agreed_to_terms=model.last_agreed_to_terms, last_started_state_editor_tutorial=model.last_started_state_editor_tutorial, last_logged_in=model.last_logged_in, last_edited_an_exploration=model.last_edited_an_exploration, last_created_an_exploration=model.last_created_an_exploration, profile_picture_data_url=model.profile_picture_data_url, default_dashboard=model.default_dashboard, user_bio=model.user_bio, subject_interests=model.subject_interests, first_contribution_msec=model.first_contribution_msec, preferred_language_codes=model.preferred_language_codes, preferred_site_language_code=model.preferred_site_language_code)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.append(None) DCNL DCSP return result
 DCSP user_email = get_email_from_user_id(user_id) DCNL DCSP user_gravatar = fetch_gravatar(user_email) DCNL DCSP update_profile_picture_data_url(user_id, user_gravatar)
 DCSP return ('https://www.gravatar.com/avatar/%s?d=identicon&s=%s' % (hashlib.md5(email).hexdigest(), GRAVATAR_SIZE_PX))
 DCSP gravatar_url = get_gravatar_url(email) DCNL DCSP try: DCNL DCSP  DCSP result = urlfetch.fetch(gravatar_url, headers={'Content-Type': 'image/png'}, follow_redirects=False) DCNL DCSP except (urlfetch.InvalidURLError, urlfetch.DownloadError): DCNL DCSP  DCSP logging.error(('Failed DCSP to DCSP fetch DCSP Gravatar DCSP from DCSP %s' % gravatar_url)) DCNL DCSP else: DCNL DCSP  DCSP if (result.status_code == 200): DCNL DCSP  DCSP  DCSP if (imghdr.what(None, result.content) == 'png'): DCNL DCSP  DCSP  DCSP  DCSP return utils.convert_png_binary_to_data_url(result.content) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.error(('[Status DCSP %s] DCSP Failed DCSP to DCSP fetch DCSP Gravatar DCSP from DCSP %s' % (result.status_code, gravatar_url))) DCNL DCSP return DEFAULT_IDENTICON_DATA_URL
 DCSP user_settings_models = user_models.UserSettingsModel.get_multi(user_ids) DCNL DCSP result = {} DCNL DCSP for model in user_settings_models: DCNL DCSP  DCSP if model: DCNL DCSP  DCSP  DCSP result[model.id] = model.profile_picture_data_url DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result[model.id] = None DCNL DCSP return result
 DCSP user_settings = get_users_settings([user_id])[0] DCNL DCSP if (strict and (user_settings is None)): DCNL DCSP  DCSP logging.error(('Could DCSP not DCSP find DCSP user DCSP with DCSP id DCSP %s' % user_id)) DCNL DCSP  DCSP raise Exception('User DCSP not DCSP found.') DCNL DCSP return user_settings
 DCSP user_settings = get_user_settings(user_id) DCNL DCSP if (user_settings is None): DCNL DCSP  DCSP return feconf.ROLE_ID_GUEST DCNL DCSP return user_settings.role
 DCSP user_settings = user_models.UserSettingsModel.get_by_role(role) DCNL DCSP return [user.username for user in user_settings]
 DCSP user_settings.validate() DCNL DCSP user_models.UserSettingsModel(id=user_settings.user_id, email=user_settings.email, role=user_settings.role, username=user_settings.username, normalized_username=user_settings.normalized_username, last_agreed_to_terms=user_settings.last_agreed_to_terms, last_started_state_editor_tutorial=user_settings.last_started_state_editor_tutorial, last_logged_in=user_settings.last_logged_in, last_edited_an_exploration=user_settings.last_edited_an_exploration, last_created_an_exploration=user_settings.last_created_an_exploration, profile_picture_data_url=user_settings.profile_picture_data_url, default_dashboard=user_settings.default_dashboard, user_bio=user_settings.user_bio, subject_interests=user_settings.subject_interests, first_contribution_msec=user_settings.first_contribution_msec, preferred_language_codes=user_settings.preferred_language_codes, preferred_site_language_code=user_settings.preferred_site_language_code).put()
 DCSP if (user_id is None): DCNL DCSP  DCSP return False DCNL DCSP user_settings = user_models.UserSettingsModel.get(user_id, strict=False) DCNL DCSP return bool(user_settings)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP return bool((user_settings.username and user_settings.last_agreed_to_terms))
 DCSP if (user_id is None): DCNL DCSP  DCSP return False DCNL DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP return (user_settings.username and user_settings.last_agreed_to_terms and (user_settings.last_agreed_to_terms >= feconf.REGISTRATION_PAGE_LAST_UPDATED_UTC))
 DCSP user_settings = get_user_settings(user_id, strict=False) DCNL DCSP if (user_settings is not None): DCNL DCSP  DCSP raise Exception(('User DCSP %s DCSP already DCSP exists.' % user_id)) DCNL DCSP user_settings = UserSettings(user_id, email, feconf.ROLE_ID_EXPLORATION_EDITOR, preferred_language_codes=[constants.DEFAULT_LANGUAGE_CODE]) DCNL DCSP _save_user_settings(user_settings) DCNL DCSP create_user_contributions(user_id, [], []) DCNL DCSP return user_settings
 DCSP if (user_id == feconf.MIGRATION_BOT_USER_ID): DCNL DCSP  DCSP return feconf.MIGRATION_BOT_USERNAME DCNL DCSP else: DCNL DCSP  DCSP return get_user_settings(user_id, strict=True).username
 DCSP users_settings = get_users_settings(user_ids) DCNL DCSP return [(us.username if us else None) for us in users_settings]
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP UserSettings.require_valid_username(new_username) DCNL DCSP if is_username_taken(new_username): DCNL DCSP  DCSP raise utils.ValidationError(('Sorry, DCSP the DCSP username DCSP "%s" DCSP is DCSP already DCSP taken! DCSP Please DCSP pick DCSP a DCSP different DCSP one.' % new_username)) DCNL DCSP user_settings.username = new_username DCNL DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.last_agreed_to_terms = datetime.datetime.utcnow() DCNL DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.profile_picture_data_url = profile_picture_data_url DCNL DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.user_bio = user_bio DCNL DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.default_dashboard = default_dashboard DCNL DCSP _save_user_settings(user_settings)
 DCSP if (not isinstance(subject_interests, list)): DCNL DCSP  DCSP raise utils.ValidationError('Expected DCSP subject_interests DCSP to DCSP be DCSP a DCSP list.') DCNL DCSP else: DCNL DCSP  DCSP for interest in subject_interests: DCNL DCSP  DCSP  DCSP if (not isinstance(interest, basestring)): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP each DCSP subject DCSP interest DCSP to DCSP be DCSP a DCSP string.') DCNL DCSP  DCSP  DCSP elif (not interest): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP each DCSP subject DCSP interest DCSP to DCSP be DCSP non-empty.') DCNL DCSP  DCSP  DCSP elif (not re.match(feconf.TAG_REGEX, interest)): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP each DCSP subject DCSP interest DCSP to DCSP consist DCSP only DCSP of DCSP lowercase DCSP alphabetic DCSP characters DCSP and DCSP spaces.') DCNL DCSP if (len(set(subject_interests)) != len(subject_interests)): DCNL DCSP  DCSP raise utils.ValidationError('Expected DCSP each DCSP subject DCSP interest DCSP to DCSP be DCSP distinct.') DCNL DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.subject_interests = subject_interests DCNL DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.first_contribution_msec = first_contribution_msec DCNL DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP if (user_settings.first_contribution_msec is None): DCNL DCSP  DCSP _update_first_contribution_msec(user_id, first_contribution_msec)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.preferred_language_codes = preferred_language_codes DCNL DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.preferred_site_language_code = preferred_site_language_code DCNL DCSP _save_user_settings(user_settings)
 DCSP if (role not in role_services.PARENT_ROLES): DCNL DCSP  DCSP raise Exception(('Role DCSP %s DCSP does DCSP not DCSP exist.' % role)) DCNL DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.role = role DCNL DCSP _save_user_settings(user_settings)
 DCSP users_settings = get_users_settings(user_ids) DCNL DCSP usernames = [] DCNL DCSP for (ind, user_settings) in enumerate(users_settings): DCNL DCSP  DCSP if (user_settings is None): DCNL DCSP  DCSP  DCSP logging.error(('User DCSP id DCSP %s DCSP not DCSP known DCSP in DCSP list DCSP of DCSP user_ids DCSP %s' % (user_ids[ind], user_ids))) DCNL DCSP  DCSP  DCSP raise Exception('User DCSP not DCSP found.') DCNL DCSP  DCSP elif (user_settings.user_id == feconf.SYSTEM_COMMITTER_ID): DCNL DCSP  DCSP  DCSP usernames.append('admin') DCNL DCSP  DCSP elif user_settings.username: DCNL DCSP  DCSP  DCSP usernames.append(user_settings.username) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP usernames.append(('[Awaiting DCSP user DCSP registration: DCSP %s]' % user_settings.truncated_email)) DCNL DCSP return usernames
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.last_started_state_editor_tutorial = datetime.datetime.utcnow() DCNL DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id, strict=True) DCNL DCSP user_settings.last_logged_in = datetime.datetime.utcnow() DCNL DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id) DCNL DCSP if user_settings: DCNL DCSP  DCSP user_settings.last_edited_an_exploration = datetime.datetime.utcnow() DCNL DCSP  DCSP _save_user_settings(user_settings)
 DCSP user_settings = get_user_settings(user_id) DCNL DCSP if user_settings: DCNL DCSP  DCSP user_settings.last_created_an_exploration = datetime.datetime.utcnow() DCNL DCSP  DCSP _save_user_settings(user_settings)
 DCSP email_preferences_model = user_models.UserEmailPreferencesModel.get(user_id, strict=False) DCNL DCSP if (email_preferences_model is None): DCNL DCSP  DCSP email_preferences_model = user_models.UserEmailPreferencesModel(id=user_id) DCNL DCSP email_preferences_model.site_updates = can_receive_email_updates DCNL DCSP email_preferences_model.editor_role_notifications = can_receive_editor_role_email DCNL DCSP email_preferences_model.feedback_message_notifications = can_receive_feedback_email DCNL DCSP email_preferences_model.subscription_notifications = can_receive_subscription_email DCNL DCSP email_preferences_model.put()
 DCSP email_preferences_model = user_models.UserEmailPreferencesModel.get(user_id, strict=False) DCNL DCSP if (email_preferences_model is None): DCNL DCSP  DCSP return user_domain.UserGlobalPrefs.create_default_prefs() DCNL DCSP else: DCNL DCSP  DCSP return user_domain.UserGlobalPrefs(email_preferences_model.site_updates, email_preferences_model.editor_role_notifications, email_preferences_model.feedback_message_notifications, email_preferences_model.subscription_notifications)
 DCSP user_email_preferences_models = user_models.UserEmailPreferencesModel.get_multi(user_ids) DCNL DCSP result = [] DCNL DCSP for email_preferences_model in user_email_preferences_models: DCNL DCSP  DCSP if (email_preferences_model is None): DCNL DCSP  DCSP  DCSP result.append(user_domain.UserGlobalPrefs.create_default_prefs()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.append(user_domain.UserGlobalPrefs(email_preferences_model.site_updates, email_preferences_model.editor_role_notifications, email_preferences_model.feedback_message_notifications, email_preferences_model.subscription_notifications)) DCNL DCSP return result
 DCSP exploration_user_model = user_models.ExplorationUserDataModel.get(user_id, exploration_id) DCNL DCSP if (exploration_user_model is None): DCNL DCSP  DCSP exploration_user_model = user_models.ExplorationUserDataModel.create(user_id, exploration_id) DCNL DCSP if (mute_feedback_notifications is not None): DCNL DCSP  DCSP exploration_user_model.mute_feedback_notifications = mute_feedback_notifications DCNL DCSP if (mute_suggestion_notifications is not None): DCNL DCSP  DCSP exploration_user_model.mute_suggestion_notifications = mute_suggestion_notifications DCNL DCSP exploration_user_model.put()
 DCSP exploration_user_model = user_models.ExplorationUserDataModel.get(user_id, exploration_id) DCNL DCSP if (exploration_user_model is None): DCNL DCSP  DCSP return user_domain.UserExplorationPrefs.create_default_prefs() DCNL DCSP else: DCNL DCSP  DCSP return user_domain.UserExplorationPrefs(exploration_user_model.mute_feedback_notifications, exploration_user_model.mute_suggestion_notifications)
 DCSP exploration_user_models = user_models.ExplorationUserDataModel.get_multi(user_ids, exploration_id) DCNL DCSP result = [] DCNL DCSP for exploration_user_model in exploration_user_models: DCNL DCSP  DCSP if (exploration_user_model is None): DCNL DCSP  DCSP  DCSP result.append(user_domain.UserExplorationPrefs.create_default_prefs()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.append(user_domain.UserExplorationPrefs(exploration_user_model.mute_feedback_notifications, exploration_user_model.mute_suggestion_notifications)) DCNL DCSP return result
 DCSP model = user_models.UserContributionsModel.get(user_id, strict=strict) DCNL DCSP if (model is not None): DCNL DCSP  DCSP result = UserContributions(model.id, model.created_exploration_ids, model.edited_exploration_ids) DCNL DCSP else: DCNL DCSP  DCSP result = None DCNL DCSP return result
 DCSP user_contributions = get_user_contributions(user_id, strict=False) DCNL DCSP if user_contributions: DCNL DCSP  DCSP raise Exception(('User DCSP contributions DCSP model DCSP for DCSP user DCSP %s DCSP already DCSP exists.' % user_id)) DCNL DCSP else: DCNL DCSP  DCSP user_contributions = UserContributions(user_id, created_exploration_ids, edited_exploration_ids) DCNL DCSP  DCSP _save_user_contributions(user_contributions) DCNL DCSP return user_contributions
 DCSP user_contributions = get_user_contributions(user_id, strict=False) DCNL DCSP if (not user_contributions): DCNL DCSP  DCSP raise Exception(('User DCSP contributions DCSP model DCSP for DCSP user DCSP %s DCSP does DCSP not DCSP exist.' % user_id)) DCNL DCSP user_contributions.created_exploration_ids = created_exploration_ids DCNL DCSP user_contributions.edited_exploration_ids = edited_exploration_ids DCNL DCSP _save_user_contributions(user_contributions)
 DCSP user_contributions = get_user_contributions(user_id, strict=False) DCNL DCSP if (not user_contributions): DCNL DCSP  DCSP create_user_contributions(user_id, [exploration_id], []) DCNL DCSP elif (exploration_id not in user_contributions.created_exploration_ids): DCNL DCSP  DCSP user_contributions.created_exploration_ids.append(exploration_id) DCNL DCSP  DCSP user_contributions.created_exploration_ids.sort() DCNL DCSP  DCSP _save_user_contributions(user_contributions)
 DCSP user_contributions = get_user_contributions(user_id, strict=False) DCNL DCSP if (not user_contributions): DCNL DCSP  DCSP create_user_contributions(user_id, [], [exploration_id]) DCNL DCSP elif (exploration_id not in user_contributions.edited_exploration_ids): DCNL DCSP  DCSP user_contributions.edited_exploration_ids.append(exploration_id) DCNL DCSP  DCSP user_contributions.edited_exploration_ids.sort() DCNL DCSP  DCSP _save_user_contributions(user_contributions)
 DCSP user_contributions.validate() DCNL DCSP user_models.UserContributionsModel(id=user_contributions.user_id, created_exploration_ids=user_contributions.created_exploration_ids, edited_exploration_ids=user_contributions.edited_exploration_ids).put()
 DCSP stats_schema_version = versioned_dashboard_stats.schema_version DCNL DCSP if (not (1 <= stats_schema_version <= feconf.CURRENT_DASHBOARD_STATS_SCHEMA_VERSION)): DCNL DCSP  DCSP raise Exception(('Sorry, DCSP we DCSP can DCSP only DCSP process DCSP v1-v%d DCSP dashboard DCSP stats DCSP schemas DCSP at DCSP present.' % feconf.CURRENT_DASHBOARD_STATS_SCHEMA_VERSION))
 DCSP return datetime.datetime.utcnow().strftime(feconf.DASHBOARD_STATS_DATETIME_STRING_FORMAT)
 DCSP datetime_obj = datetime.datetime.strptime(datetime_str, feconf.DASHBOARD_STATS_DATETIME_STRING_FORMAT) DCNL DCSP return {'year': datetime_obj.year, 'month': datetime_obj.month, 'day': datetime_obj.day}
 DCSP model = user_models.UserStatsModel.get(user_id, strict=False) DCNL DCSP if model: DCNL DCSP  DCSP return model.impact_score DCNL DCSP else: DCNL DCSP  DCSP return 0
 DCSP model = user_models.UserStatsModel.get(user_id, strict=False) DCNL DCSP if (model and model.weekly_creator_stats_list): DCNL DCSP  DCSP return model.weekly_creator_stats_list DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP weekly_dashboard_stats = get_weekly_dashboard_stats(user_id) DCNL DCSP if weekly_dashboard_stats: DCNL DCSP  DCSP return weekly_dashboard_stats[(-1)] DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP model = user_models.UserStatsModel.get_or_create(user_id) DCNL DCSP if (model.schema_version != feconf.CURRENT_DASHBOARD_STATS_SCHEMA_VERSION): DCNL DCSP  DCSP _migrate_dashboard_stats_to_latest_schema(model) DCNL DCSP weekly_dashboard_stats = {get_current_date_as_string(): {'num_ratings': (model.num_ratings or 0), 'average_ratings': model.average_ratings, 'total_plays': (model.total_plays or 0)}} DCNL DCSP model.weekly_creator_stats_list.append(weekly_dashboard_stats) DCNL DCSP model.put()
 DCSP admin_ids = [] DCNL DCSP for username in admin_usernames: DCNL DCSP  DCSP user_id = user_services.get_user_id_from_username(username) DCNL DCSP  DCSP if (user_id is not None): DCNL DCSP  DCSP  DCSP admin_ids.append(user_id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Bad DCSP admin DCSP username: DCSP %s' % username)) DCNL DCSP Registry.get_config_property('admin_ids').set_value(committer_id, admin_ids)
 DCSP moderator_ids = [] DCNL DCSP for username in moderator_usernames: DCNL DCSP  DCSP user_id = user_services.get_user_id_from_username(username) DCNL DCSP  DCSP if (user_id is not None): DCNL DCSP  DCSP  DCSP moderator_ids.append(user_id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Bad DCSP moderator DCSP username: DCSP %s' % username)) DCNL DCSP Registry.get_config_property('moderator_ids').set_value(committer_id, moderator_ids)
 DCSP return [{'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY, 'state_name': state_name, 'property_name': property_name, 'new_value': new_value}]
 DCSP for ca_spec in ca_specs: DCNL DCSP  DCSP if (ca_spec.name not in customization_args): DCNL DCSP  DCSP  DCSP customization_args[ca_spec.name] = {'value': ca_spec.default_value} DCNL DCSP return customization_args
 DCSP ca_spec_names = [ca_spec.name for ca_spec in ca_specs_to_validate_against] DCNL DCSP if (not isinstance(customization_args, dict)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP customization DCSP args DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % customization_args)) DCNL DCSP customization_args = _get_full_customization_args(customization_args, ca_specs_to_validate_against) DCNL DCSP extra_args = [] DCNL DCSP for arg_name in customization_args.keys(): DCNL DCSP  DCSP if (not isinstance(arg_name, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Invalid DCSP customization DCSP arg DCSP name: DCSP %s' % arg_name)) DCNL DCSP  DCSP if (arg_name not in ca_spec_names): DCNL DCSP  DCSP  DCSP extra_args.append(arg_name) DCNL DCSP  DCSP  DCSP logging.warning(('%s DCSP %s DCSP does DCSP not DCSP support DCSP customization DCSP arg DCSP %s.' % (item_name.capitalize(), item_type, arg_name))) DCNL DCSP for extra_arg in extra_args: DCNL DCSP  DCSP del customization_args[extra_arg] DCNL DCSP for ca_spec in ca_specs_to_validate_against: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP customization_args[ca_spec.name]['value'] = schema_utils.normalize_against_schema(customization_args[ca_spec.name]['value'], ca_spec.schema) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
 DCSP def test_can_access(self, **kwargs): DCNL DCSP  DCSP return handler(self, **kwargs) DCNL DCSP test_can_access.__wrapped__ = True DCNL DCSP return test_can_access
 DCSP def test_can_play(self, exploration_id, **kwargs): DCNL DCSP  DCSP if (exploration_id in feconf.DISABLED_EXPLORATION_IDS): DCNL DCSP  DCSP  DCSP raise self.PageNotFoundException DCNL DCSP  DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP  DCSP if rights_manager.check_can_access_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_EXPLORATION, exploration_rights): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise self.PageNotFoundException DCNL DCSP test_can_play.__wrapped__ = True DCNL DCSP return test_can_play
 DCSP def test_can_play(self, collection_id, **kwargs): DCNL DCSP  DCSP collection_rights = rights_manager.get_collection_rights(collection_id, strict=False) DCNL DCSP  DCSP if rights_manager.check_can_access_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_COLLECTION, collection_rights): DCNL DCSP  DCSP  DCSP return handler(self, collection_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise self.PageNotFoundException DCNL DCSP test_can_play.__wrapped__ = True DCNL DCSP return test_can_play
 DCSP def test_can_download(self, exploration_id, **kwargs): DCNL DCSP  DCSP if (exploration_id in feconf.DISABLED_EXPLORATION_IDS): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.PageNotFoundException DCNL DCSP  DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP  DCSP if rights_manager.check_can_access_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_EXPLORATION, exploration_rights): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise self.PageNotFoundException DCNL DCSP test_can_download.__wrapped__ = True DCNL DCSP return test_can_download
 DCSP def test_can_view_stats(self, exploration_id, **kwargs): DCNL DCSP  DCSP if (exploration_id in feconf.DISABLED_EXPLORATION_IDS): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.PageNotFoundException DCNL DCSP  DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP  DCSP if rights_manager.check_can_access_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_EXPLORATION, exploration_rights): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.PageNotFoundException DCNL DCSP test_can_view_stats.__wrapped__ = True DCNL DCSP return test_can_view_stats
 DCSP def test_can_edit(self, collection_id, **kwargs): DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.NotLoggedInException DCNL DCSP  DCSP collection_rights = rights_manager.get_collection_rights(collection_id) DCNL DCSP  DCSP if (collection_rights is None): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.PageNotFoundException DCNL DCSP  DCSP if rights_manager.check_can_edit_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_COLLECTION, collection_rights): DCNL DCSP  DCSP  DCSP return handler(self, collection_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP edit DCSP this DCSP collection.') DCNL DCSP test_can_edit.__wrapped__ = True DCNL DCSP return test_can_edit
 DCSP def test_can_manage_emails(self, **kwargs): DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.NotLoggedInException DCNL DCSP  DCSP if (role_services.ACTION_MANAGE_EMAIL_DASHBOARD in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP  DCSP raise self.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP access DCSP email DCSP dashboard.') DCNL DCSP test_can_manage_emails.__wrapped__ = True DCNL DCSP return test_can_manage_emails
 DCSP def test_can_access_moderator_page(self, **kwargs): DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.NotLoggedInException DCNL DCSP  DCSP if (role_services.ACTION_ACCESS_MODERATOR_PAGE in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP  DCSP raise self.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP access DCSP moderator DCSP page.') DCNL DCSP test_can_access_moderator_page.__wrapped__ = True DCNL DCSP return test_can_access_moderator_page
 DCSP def test_can_send_moderator_emails(self, **kwargs): DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.NotLoggedInException DCNL DCSP  DCSP if (role_services.ACTION_SEND_MODERATOR_EMAILS in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP  DCSP raise self.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP send DCSP moderator DCSP emails.') DCNL DCSP test_can_send_moderator_emails.__wrapped__ = True DCNL DCSP return test_can_send_moderator_emails
 DCSP def test_can_manage_profile(self, **kwargs): DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise self.NotLoggedInException DCNL DCSP  DCSP if (role_services.ACTION_MANAGE_PROFILE in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP  DCSP raise self.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP manage DCSP profile DCSP or DCSP preferences.') DCNL DCSP test_can_manage_profile.__wrapped__ = True DCNL DCSP return test_can_manage_profile
 DCSP def test_super_admin(self, **kwargs): DCNL DCSP  DCSP 'Checks DCSP if DCSP the DCSP user DCSP is DCSP logged DCSP in DCSP and DCSP is DCSP a DCSP super DCSP admin.' DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise self.NotLoggedInException DCNL DCSP  DCSP if (not current_user_services.is_current_user_super_admin()): DCNL DCSP  DCSP  DCSP raise self.UnauthorizedUserException('%s DCSP is DCSP not DCSP a DCSP super DCSP admin DCSP of DCSP this DCSP application', self.user_id) DCNL DCSP  DCSP return handler(self, **kwargs) DCNL DCSP test_super_admin.__wrapped__ = True DCNL DCSP return test_super_admin
 DCSP def test_can_upload(self, **kwargs): DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise self.NotLoggedInException DCNL DCSP  DCSP if (not current_user_services.is_current_user_super_admin()): DCNL DCSP  DCSP  DCSP raise self.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP upload DCSP exploration.') DCNL DCSP  DCSP return handler(self, **kwargs) DCNL DCSP test_can_upload.__wrapped__ = True DCNL DCSP return test_can_upload
 DCSP def test_can_create(self, **kwargs): DCNL DCSP  DCSP if (self.user_id is None): DCNL DCSP  DCSP  DCSP raise self.NotLoggedInException DCNL DCSP  DCSP if (role_services.ACTION_CREATE_EXPLORATION in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP create DCSP an DCSP exploration.') DCNL DCSP test_can_create.__wrapped__ = True DCNL DCSP return test_can_create
 DCSP def test_can_create(self, **kwargs): DCNL DCSP  DCSP if (self.user_id is None): DCNL DCSP  DCSP  DCSP raise self.NotLoggedInException DCNL DCSP  DCSP if (role_services.ACTION_CREATE_COLLECTION in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP create DCSP a DCSP collection.') DCNL DCSP test_can_create.__wrapped__ = True DCNL DCSP return test_can_create
 DCSP def test_can_access(self, **kwargs): DCNL DCSP  DCSP if (self.user_id is None): DCNL DCSP  DCSP  DCSP raise self.NotLoggedInException DCNL DCSP  DCSP if (role_services.ACTION_ACCESS_CREATOR_DASHBOARD in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP access DCSP creator DCSP dashboard.') DCNL DCSP test_can_access.__wrapped__ = True DCNL DCSP return test_can_access
 DCSP def test_can_access(self, exploration_id, **kwargs): DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.NotLoggedInException DCNL DCSP  DCSP if (exploration_id in feconf.DISABLED_EXPLORATION_IDS): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.PageNotFoundException DCNL DCSP  DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP  DCSP if rights_manager.check_can_access_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_EXPLORATION, exploration_rights): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise self.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP view DCSP exploration DCSP feedback.') DCNL DCSP test_can_access.__wrapped__ = True DCNL DCSP return test_can_access
 DCSP def test_can_rate(self, exploration_id, **kwargs): DCNL DCSP  DCSP if (role_services.ACTION_RATE_EXPLORATION in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP give DCSP ratings DCSP to DCSP explorations.') DCNL DCSP test_can_rate.__wrapped__ = True DCNL DCSP return test_can_rate
 DCSP def test_can_flag(self, exploration_id, **kwargs): DCNL DCSP  DCSP if (role_services.ACTION_FLAG_EXPLORATION in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP flag DCSP explorations.') DCNL DCSP test_can_flag.__wrapped__ = True DCNL DCSP return test_can_flag
 DCSP def test_can_subscribe(self, **kwargs): DCNL DCSP  DCSP if (role_services.ACTION_SUBSCRIBE_TO_USERS in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP manage DCSP subscriptions.') DCNL DCSP test_can_subscribe.__wrapped__ = True DCNL DCSP return test_can_subscribe
 DCSP def test_can_edit(self, exploration_id, **kwargs): DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.NotLoggedInException DCNL DCSP  DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id) DCNL DCSP  DCSP if (exploration_rights is None): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.PageNotFoundException DCNL DCSP  DCSP if rights_manager.check_can_edit_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_EXPLORATION, exploration_rights): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP edit DCSP this DCSP exploration.') DCNL DCSP test_can_edit.__wrapped__ = True DCNL DCSP return test_can_edit
 DCSP def test_can_delete(self, exploration_id, **kwargs): DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.NotLoggedInException DCNL DCSP  DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP  DCSP if rights_manager.check_can_delete_exploration(self.user_id, self.actions, exploration_rights): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException(('User DCSP %s DCSP does DCSP not DCSP have DCSP permissions DCSP to DCSP delete DCSP exploration DCSP %s' % (self.user_id, exploration_id))) DCNL DCSP test_can_delete.__wrapped__ = True DCNL DCSP return test_can_delete
 DCSP def test_can_suggest(self, exploration_id, **kwargs): DCNL DCSP  DCSP if (role_services.ACTION_SUGGEST_CHANGES_TO_EXPLORATION in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP give DCSP suggestions DCSP to DCSP this DCSP exploration.') DCNL DCSP test_can_suggest.__wrapped__ = True DCNL DCSP return test_can_suggest
 DCSP def test_can_publish(self, exploration_id, *args, **kwargs): DCNL DCSP  DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP  DCSP if (exploration_rights is None): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.PageNotFoundException DCNL DCSP  DCSP if rights_manager.check_can_publish_exploration(self.user_id, self.actions, exploration_rights): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, *args, **kwargs) DCNL DCSP  DCSP if rights_manager.check_can_publicize_exploration(self.actions, exploration_rights): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, *args, **kwargs) DCNL DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP publish DCSP this DCSP exploration.') DCNL DCSP test_can_publish.__wrapped__ = True DCNL DCSP return test_can_publish
 DCSP def test_can_manage_collection_publish_status(self, collection_id, **kwargs): DCNL DCSP  DCSP collection_rights = rights_manager.get_collection_rights(collection_id) DCNL DCSP  DCSP if (collection_rights is None): DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.PageNotFoundException DCNL DCSP  DCSP if collection_rights.is_published(): DCNL DCSP  DCSP  DCSP if (role_services.ACTION_UNPUBLISH_PUBLIC_COLLECTION in self.actions): DCNL DCSP  DCSP  DCSP  DCSP return handler(self, collection_id, **kwargs) DCNL DCSP  DCSP  DCSP raise self.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP unpublish DCSP this DCSP collection.') DCNL DCSP  DCSP if collection_rights.is_private(): DCNL DCSP  DCSP  DCSP if (role_services.ACTION_PUBLISH_ANY_COLLECTION in self.actions): DCNL DCSP  DCSP  DCSP  DCSP return handler(self, collection_id, **kwargs) DCNL DCSP  DCSP  DCSP if (role_services.ACTION_PUBLISH_OWNED_COLLECTION in self.actions): DCNL DCSP  DCSP  DCSP  DCSP if collection_rights.is_owner(self.user_id): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return handler(self, collection_id, **kwargs) DCNL DCSP  DCSP  DCSP raise self.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP publish DCSP this DCSP collection.') DCNL DCSP test_can_manage_collection_publish_status.__wrapped__ = True DCNL DCSP return test_can_manage_collection_publish_status
 DCSP def test_can_modify(self, exploration_id, **kwargs): DCNL DCSP  DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP  DCSP if rights_manager.check_can_modify_exploration_roles(self.user_id, self.actions, exploration_rights): DCNL DCSP  DCSP  DCSP return handler(self, exploration_id, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise base.UserFacingExceptions.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP credentials DCSP to DCSP change DCSP rights DCSP for DCSP this DCSP exploration.') DCNL DCSP test_can_modify.__wrapped__ = True DCNL DCSP return test_can_modify
 DCSP def test_can_perform(self, **kwargs): DCNL DCSP  DCSP if ((self.request.headers.get('X-AppEngine-Cron') is None) and (not self.is_super_admin)): DCNL DCSP  DCSP  DCSP raise self.UnauthorizedUserException('You DCSP do DCSP not DCSP have DCSP the DCSP credentials DCSP to DCSP access DCSP this DCSP page.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP test_can_perform.__wrapped__ = True DCNL DCSP return test_can_perform
 DCSP def test_can_access(self, **kwargs): DCNL DCSP  DCSP if (role_services.ACTION_ACCESS_LEARNER_DASHBOARD in self.actions): DCNL DCSP  DCSP  DCSP return handler(self, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise self.NotLoggedInException DCNL DCSP test_can_access.__wrapped__ = True DCNL DCSP return test_can_access
 DCSP def test_login(self, **kwargs): DCNL DCSP  DCSP 'Checks DCSP if DCSP the DCSP user DCSP for DCSP the DCSP current DCSP session DCSP is DCSP logged DCSP in.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP not, DCSP redirects DCSP the DCSP user DCSP to DCSP the DCSP home DCSP page.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if (not self.user_id): DCNL DCSP  DCSP  DCSP self.redirect('/') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return handler(self, **kwargs) DCNL DCSP test_login.__wrapped__ = True DCNL DCSP return test_login
 DCSP return [{'cmd': collection_domain.CMD_EDIT_COLLECTION_NODE_PROPERTY, 'exploration_id': exploration_id, 'property_name': property_name, 'new_value': new_value}]
 DCSP return [{'cmd': collection_domain.CMD_EDIT_COLLECTION_PROPERTY, 'property_name': property_name, 'new_value': new_value}]
 DCSP return [{'cmd': collection_domain.CMD_ADD_COLLECTION_NODE, 'exploration_id': exploration_id}]
 DCSP return [{'cmd': collection_domain.CMD_DELETE_COLLECTION_NODE, 'exploration_id': exploration_id}]
 DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP if (exploration.states[state_name].interaction.id is None): DCNL DCSP  DCSP return [] DCNL DCSP visualizations = interaction_registry.Registry.get_interaction_by_id(exploration.states[state_name].interaction.id).answer_visualizations DCNL DCSP calculation_ids = set([visualization.calculation_id for visualization in visualizations]) DCNL DCSP calculation_ids_to_outputs = {} DCNL DCSP for calculation_id in calculation_ids: DCNL DCSP  DCSP calc_output_domain_object = stats_jobs_continuous.InteractionAnswerSummariesAggregator.get_calc_output(exploration_id, state_name, calculation_id) DCNL DCSP  DCSP if (calc_output_domain_object is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP calculation_ids_to_outputs[calculation_id] = calc_output_domain_object.calculation_output DCNL DCSP return [{'id': visualization.id, 'data': calculation_ids_to_outputs[visualization.calculation_id], 'options': visualization.options} for visualization in visualizations if (visualization.calculation_id in calculation_ids_to_outputs)]
 DCSP return stats_models.ExplorationAnnotationsModel.get_versions(exploration_id)
 DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP exp_stats = stats_jobs_continuous.StatisticsAggregator.get_statistics(exploration_id, exploration_version) DCNL DCSP last_updated = exp_stats['last_updated'] DCNL DCSP state_hit_counts = exp_stats['state_hit_counts'] DCNL DCSP return {'last_updated': last_updated, 'num_completions': exp_stats['complete_exploration_count'], 'num_starts': exp_stats['start_exploration_count'], 'state_stats': {state_name: {'name': state_name, 'first_entry_count': (state_hit_counts[state_name]['first_entry_count'] if (state_name in state_hit_counts) else 0), 'total_entry_count': (state_hit_counts[state_name]['total_entry_count'] if (state_name in state_hit_counts) else 0), 'no_submitted_answer_count': (state_hit_counts[state_name].get('no_answer_count', 0) if (state_name in state_hit_counts) else 0)} for state_name in exploration.states}}
 DCSP record_answers(exploration_id, exploration_version, state_name, interaction_id, [submitted_answer])
 DCSP state_answers = stats_domain.StateAnswers(exploration_id, exploration_version, state_name, interaction_id, submitted_answer_list) DCNL DCSP for submitted_answer in submitted_answer_list: DCNL DCSP  DCSP submitted_answer.validate() DCNL DCSP stats_models.StateAnswersModel.insert_submitted_answers(state_answers.exploration_id, state_answers.exploration_version, state_answers.state_name, state_answers.interaction_id, state_answers.get_submitted_answer_dict_list())
 DCSP state_answers_models = stats_models.StateAnswersModel.get_all_models(exploration_id, exploration_version, state_name) DCNL DCSP if state_answers_models: DCNL DCSP  DCSP main_state_answers_model = state_answers_models[0] DCNL DCSP  DCSP submitted_answer_dict_list = itertools.chain.from_iterable([state_answers_model.submitted_answer_list for state_answers_model in state_answers_models]) DCNL DCSP  DCSP return stats_domain.StateAnswers(exploration_id, exploration_version, state_name, main_state_answers_model.interaction_id, [stats_domain.SubmittedAnswer.from_dict(submitted_answer_dict) for submitted_answer_dict in submitted_answer_dict_list], schema_version=main_state_answers_model.schema_version) DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP answers_model = stats_models.StateAnswersModel.get_master_model(exploration_id, exploration_version, state_name) DCNL DCSP if (answers_model is None): DCNL DCSP  DCSP return [] DCNL DCSP sample_answers = answers_model.submitted_answer_list[:100] DCNL DCSP return [stats_domain.SubmittedAnswer.from_dict(submitted_answer_dict).answer for submitted_answer_dict in sample_answers]
 DCSP return json.loads(utils.get_file_contents(feconf.OBJECT_DEFAULT_VALUES_FILE_PATH))
 DCSP if (not isinstance(new_rating, int)): DCNL DCSP  DCSP raise ValueError(('Expected DCSP the DCSP rating DCSP to DCSP be DCSP an DCSP integer, DCSP received DCSP %s' % new_rating)) DCNL DCSP if (new_rating not in ALLOWED_RATINGS): DCNL DCSP  DCSP raise ValueError(('Expected DCSP a DCSP rating DCSP 1-5, DCSP received DCSP %s.' % new_rating)) DCNL DCSP try: DCNL DCSP  DCSP exp_services.get_exploration_by_id(exploration_id) DCNL DCSP except: DCNL DCSP  DCSP raise Exception(('Invalid DCSP exploration DCSP id DCSP %s' % exploration_id)) DCNL DCSP def _update_user_rating(): DCNL DCSP  DCSP exp_user_data_model = user_models.ExplorationUserDataModel.get(user_id, exploration_id) DCNL DCSP  DCSP if exp_user_data_model: DCNL DCSP  DCSP  DCSP old_rating = exp_user_data_model.rating DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP old_rating = None DCNL DCSP  DCSP  DCSP exp_user_data_model = user_models.ExplorationUserDataModel.create(user_id, exploration_id) DCNL DCSP  DCSP exp_user_data_model.rating = new_rating DCNL DCSP  DCSP exp_user_data_model.rated_on = datetime.datetime.utcnow() DCNL DCSP  DCSP exp_user_data_model.put() DCNL DCSP  DCSP return old_rating DCNL DCSP old_rating = transaction_services.run_in_transaction(_update_user_rating) DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration_id) DCNL DCSP if (not exploration_summary.ratings): DCNL DCSP  DCSP exploration_summary.ratings = feconf.get_empty_ratings() DCNL DCSP exploration_summary.ratings[str(new_rating)] += 1 DCNL DCSP if old_rating: DCNL DCSP  DCSP exploration_summary.ratings[str(old_rating)] -= 1 DCNL DCSP event_services.RateExplorationEventHandler.record(exploration_id, user_id, new_rating, old_rating) DCNL DCSP exploration_summary.scaled_average_rating = exp_services.get_scaled_average_rating(exploration_summary.ratings) DCNL DCSP exp_services.save_exploration_summary(exploration_summary)
 DCSP exp_user_data_model = user_models.ExplorationUserDataModel.get(user_id, exploration_id) DCNL DCSP return (exp_user_data_model.rating if exp_user_data_model else None)
 DCSP exp_user_data_model = user_models.ExplorationUserDataModel.get(user_id, exploration_id) DCNL DCSP return (exp_user_data_model.rated_on if exp_user_data_model else None)
 DCSP exp_summary = exp_services.get_exploration_summary_by_id(exploration_id) DCNL DCSP return exp_summary.ratings
 DCSP return ActivityRights(activity_rights_model.id, activity_rights_model.owner_ids, activity_rights_model.editor_ids, activity_rights_model.viewer_ids, community_owned=activity_rights_model.community_owned, cloned_from=(activity_rights_model.cloned_from if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION) else None), status=activity_rights_model.status, viewable_if_private=activity_rights_model.viewable_if_private, first_published_msec=activity_rights_model.first_published_msec)
 DCSP activity_rights.validate() DCNL DCSP if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION): DCNL DCSP  DCSP model_cls = exp_models.ExplorationRightsModel DCNL DCSP elif (activity_type == constants.ACTIVITY_TYPE_COLLECTION): DCNL DCSP  DCSP model_cls = collection_models.CollectionRightsModel DCNL DCSP model = model_cls.get(activity_rights.id, strict=False) DCNL DCSP model.owner_ids = activity_rights.owner_ids DCNL DCSP model.editor_ids = activity_rights.editor_ids DCNL DCSP model.viewer_ids = activity_rights.viewer_ids DCNL DCSP model.community_owned = activity_rights.community_owned DCNL DCSP model.status = activity_rights.status DCNL DCSP model.viewable_if_private = activity_rights.viewable_if_private DCNL DCSP model.first_published_msec = activity_rights.first_published_msec DCNL DCSP model.commit(committer_id, commit_message, commit_cmds)
 DCSP from core.domain import exp_services DCNL DCSP exp_services.update_exploration_summary(activity_rights.id, None)
 DCSP from core.domain import collection_services DCNL DCSP collection_services.update_collection_summary(activity_rights.id, None)
 DCSP if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION): DCNL DCSP  DCSP _update_exploration_summary(activity_rights) DCNL DCSP elif (activity_type == constants.ACTIVITY_TYPE_COLLECTION): DCNL DCSP  DCSP _update_collection_summary(activity_rights)
 DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP commit_cmds = [{'cmd': CMD_UPDATE_FIRST_PUBLISHED_MSEC, 'old_first_published_msec': activity_rights.first_published_msec, 'new_first_published_msec': first_published_msec}] DCNL DCSP activity_rights.first_published_msec = first_published_msec DCNL DCSP _save_activity_rights(feconf.SYSTEM_COMMITTER_ID, activity_rights, activity_type, 'set DCSP first DCSP published DCSP time DCSP in DCSP msec', commit_cmds)
 DCSP exploration_rights = ActivityRights(exploration_id, [committer_id], [], []) DCNL DCSP commit_cmds = [{'cmd': CMD_CREATE_NEW}] DCNL DCSP exp_models.ExplorationRightsModel(id=exploration_rights.id, owner_ids=exploration_rights.owner_ids, editor_ids=exploration_rights.editor_ids, viewer_ids=exploration_rights.viewer_ids, community_owned=exploration_rights.community_owned, status=exploration_rights.status, viewable_if_private=exploration_rights.viewable_if_private, first_published_msec=exploration_rights.first_published_msec).commit(committer_id, 'Created DCSP new DCSP exploration', commit_cmds) DCNL DCSP subscription_services.subscribe_to_exploration(committer_id, exploration_id)
 DCSP model = exp_models.ExplorationRightsModel.get(exploration_id, strict=strict) DCNL DCSP if (model is None): DCNL DCSP  DCSP return None DCNL DCSP return _get_activity_rights_from_model(model, constants.ACTIVITY_TYPE_EXPLORATION)
 DCSP exploration_rights = get_exploration_rights(exploration_id) DCNL DCSP return (exploration_rights.status == ACTIVITY_STATUS_PRIVATE)
 DCSP exploration_rights = get_exploration_rights(exploration_id) DCNL DCSP return (exploration_rights.status == ACTIVITY_STATUS_PUBLIC)
 DCSP exploration_rights = get_exploration_rights(exploration_id) DCNL DCSP return bool(exploration_rights.cloned_from)
 DCSP collection_rights = ActivityRights(collection_id, [committer_id], [], []) DCNL DCSP commit_cmds = [{'cmd': CMD_CREATE_NEW}] DCNL DCSP collection_models.CollectionRightsModel(id=collection_rights.id, owner_ids=collection_rights.owner_ids, editor_ids=collection_rights.editor_ids, viewer_ids=collection_rights.viewer_ids, community_owned=collection_rights.community_owned, status=collection_rights.status, viewable_if_private=collection_rights.viewable_if_private, first_published_msec=collection_rights.first_published_msec).commit(committer_id, 'Created DCSP new DCSP collection', commit_cmds) DCNL DCSP subscription_services.subscribe_to_collection(committer_id, collection_id)
 DCSP model = collection_models.CollectionRightsModel.get(collection_id, strict=strict) DCNL DCSP if (model is None): DCNL DCSP  DCSP return None DCNL DCSP return _get_activity_rights_from_model(model, constants.ACTIVITY_TYPE_COLLECTION)
 DCSP collection_rights = get_collection_rights(collection_id) DCNL DCSP return user_services.get_human_readable_user_ids(collection_rights.owner_ids)
 DCSP collection_rights = get_collection_rights(collection_id) DCNL DCSP return (collection_rights.status == ACTIVITY_STATUS_PRIVATE)
 DCSP collection_rights = get_collection_rights(collection_id) DCNL DCSP return (collection_rights.status == ACTIVITY_STATUS_PUBLIC)
 DCSP if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION): DCNL DCSP  DCSP return get_exploration_rights(activity_id, strict=False) DCNL DCSP elif (activity_type == constants.ACTIVITY_TYPE_COLLECTION): DCNL DCSP  DCSP return get_collection_rights(activity_id, strict=False) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Cannot DCSP get DCSP activity DCSP rights DCSP for DCSP unknown DCSP activity DCSP type: DCSP %s' % activity_type))
 DCSP if (not Actor(committer_id).can_modify_roles(activity_type, activity_id)): DCNL DCSP  DCSP logging.error(('User DCSP %s DCSP tried DCSP to DCSP allow DCSP user DCSP %s DCSP to DCSP be DCSP a(n) DCSP %s DCSP of DCSP activity DCSP %s DCSP but DCSP was DCSP refused DCSP permission.' % (committer_id, assignee_id, new_role, activity_id))) DCNL DCSP  DCSP raise Exception('UnauthorizedUserException: DCSP Could DCSP not DCSP assign DCSP new DCSP role.') DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP assignee_username = user_services.get_username(assignee_id) DCNL DCSP old_role = ROLE_NONE DCNL DCSP if (new_role == ROLE_OWNER): DCNL DCSP  DCSP if Actor(assignee_id)._is_owner(activity_rights): DCNL DCSP  DCSP  DCSP raise Exception(('This DCSP user DCSP already DCSP owns DCSP this DCSP %s.' % activity_type)) DCNL DCSP  DCSP activity_rights.owner_ids.append(assignee_id) DCNL DCSP  DCSP if (assignee_id in activity_rights.viewer_ids): DCNL DCSP  DCSP  DCSP activity_rights.viewer_ids.remove(assignee_id) DCNL DCSP  DCSP  DCSP old_role = ROLE_VIEWER DCNL DCSP  DCSP if (assignee_id in activity_rights.editor_ids): DCNL DCSP  DCSP  DCSP activity_rights.editor_ids.remove(assignee_id) DCNL DCSP  DCSP  DCSP old_role = ROLE_EDITOR DCNL DCSP elif (new_role == ROLE_EDITOR): DCNL DCSP  DCSP if Actor(assignee_id)._has_editing_rights(activity_rights): DCNL DCSP  DCSP  DCSP raise Exception(('This DCSP user DCSP already DCSP can DCSP edit DCSP this DCSP %s.' % activity_type)) DCNL DCSP  DCSP if activity_rights.community_owned: DCNL DCSP  DCSP  DCSP raise Exception(('Community-owned DCSP %ss DCSP can DCSP be DCSP edited DCSP by DCSP anyone.' % activity_type)) DCNL DCSP  DCSP activity_rights.editor_ids.append(assignee_id) DCNL DCSP  DCSP if (assignee_id in activity_rights.viewer_ids): DCNL DCSP  DCSP  DCSP activity_rights.viewer_ids.remove(assignee_id) DCNL DCSP  DCSP  DCSP old_role = ROLE_VIEWER DCNL DCSP elif (new_role == ROLE_VIEWER): DCNL DCSP  DCSP if Actor(assignee_id)._has_viewing_rights(activity_rights): DCNL DCSP  DCSP  DCSP raise Exception(('This DCSP user DCSP already DCSP can DCSP view DCSP this DCSP %s.' % activity_type)) DCNL DCSP  DCSP if (activity_rights.status != ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP  DCSP raise Exception(('Public DCSP %ss DCSP can DCSP be DCSP viewed DCSP by DCSP anyone.' % activity_type)) DCNL DCSP  DCSP activity_rights.viewer_ids.append(assignee_id) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Invalid DCSP role: DCSP %s' % new_role)) DCNL DCSP commit_message = ('Changed DCSP role DCSP of DCSP %s DCSP from DCSP %s DCSP to DCSP %s' % (assignee_username, old_role, new_role)) DCNL DCSP commit_cmds = [{'cmd': CMD_CHANGE_ROLE, 'assignee_id': assignee_id, 'old_role': old_role, 'new_role': new_role}] DCNL DCSP _save_activity_rights(committer_id, activity_rights, activity_type, commit_message, commit_cmds) DCNL DCSP _update_activity_summary(activity_type, activity_rights)
 DCSP if (not Actor(committer_id).can_release_ownership(activity_type, activity_id)): DCNL DCSP  DCSP logging.error(('User DCSP %s DCSP tried DCSP to DCSP release DCSP ownership DCSP of DCSP %s DCSP %s DCSP but DCSP was DCSP refused DCSP permission.' % (committer_id, activity_type, activity_id))) DCNL DCSP  DCSP raise Exception(('The DCSP ownership DCSP of DCSP this DCSP %s DCSP cannot DCSP be DCSP released.' % activity_type)) DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP activity_rights.community_owned = True DCNL DCSP activity_rights.owner_ids = [] DCNL DCSP activity_rights.editor_ids = [] DCNL DCSP activity_rights.viewer_ids = [] DCNL DCSP commit_cmds = [{'cmd': CMD_RELEASE_OWNERSHIP}] DCNL DCSP _save_activity_rights(committer_id, activity_rights, activity_type, ('%s DCSP ownership DCSP released DCSP to DCSP the DCSP community.' % activity_type), commit_cmds) DCNL DCSP _update_activity_summary(activity_type, activity_rights)
 DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP old_status = activity_rights.status DCNL DCSP activity_rights.status = new_status DCNL DCSP if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION): DCNL DCSP  DCSP cmd_type = CMD_CHANGE_EXPLORATION_STATUS DCNL DCSP elif (activity_type == constants.ACTIVITY_TYPE_COLLECTION): DCNL DCSP  DCSP cmd_type = CMD_CHANGE_COLLECTION_STATUS DCNL DCSP commit_cmds = [{'cmd': cmd_type, 'old_status': old_status, 'new_status': new_status}] DCNL DCSP if (new_status != ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP activity_rights.viewer_ids = [] DCNL DCSP  DCSP if (activity_rights.first_published_msec is None): DCNL DCSP  DCSP  DCSP activity_rights.first_published_msec = utils.get_current_time_in_millisecs() DCNL DCSP _save_activity_rights(committer_id, activity_rights, activity_type, commit_message, commit_cmds) DCNL DCSP _update_activity_summary(activity_type, activity_rights)
 DCSP if (not Actor(committer_id).can_publish(activity_type, activity_id)): DCNL DCSP  DCSP logging.error(('User DCSP %s DCSP tried DCSP to DCSP publish DCSP %s DCSP %s DCSP but DCSP was DCSP refused DCSP permission.' % (committer_id, activity_type, activity_id))) DCNL DCSP  DCSP raise Exception(('This DCSP %s DCSP cannot DCSP be DCSP published.' % activity_type)) DCNL DCSP _change_activity_status(committer_id, activity_id, activity_type, ACTIVITY_STATUS_PUBLIC, ('%s DCSP published.' % activity_type))
 DCSP if (not Actor(committer_id).can_unpublish(activity_type, activity_id)): DCNL DCSP  DCSP logging.error(('User DCSP %s DCSP tried DCSP to DCSP unpublish DCSP %s DCSP %s DCSP but DCSP was DCSP refused DCSP permission.' % (committer_id, activity_type, activity_id))) DCNL DCSP  DCSP raise Exception(('This DCSP %s DCSP cannot DCSP be DCSP unpublished.' % activity_type)) DCNL DCSP _change_activity_status(committer_id, activity_id, activity_type, ACTIVITY_STATUS_PRIVATE, ('%s DCSP unpublished.' % activity_type)) DCNL DCSP activity_services.remove_featured_activity(activity_type, activity_id)
 DCSP if (not Actor(committer_id).can_publicize(activity_type, activity_id)): DCNL DCSP  DCSP logging.error(('User DCSP %s DCSP tried DCSP to DCSP publicize DCSP %s DCSP %s DCSP but DCSP was DCSP refused DCSP permission.' % (committer_id, activity_type, activity_id))) DCNL DCSP  DCSP raise Exception(('This DCSP %s DCSP cannot DCSP be DCSP marked DCSP as DCSP "featured".' % activity_type)) DCNL DCSP _change_activity_status(committer_id, activity_id, activity_type, ACTIVITY_STATUS_PUBLICIZED, ('%s DCSP publicized.' % activity_type))
 DCSP if (not Actor(committer_id).can_unpublicize(activity_type, activity_id)): DCNL DCSP  DCSP logging.error(('User DCSP %s DCSP tried DCSP to DCSP unpublicize DCSP exploration DCSP %s DCSP but DCSP was DCSP refused DCSP permission.' % (committer_id, activity_id))) DCNL DCSP  DCSP raise Exception('This DCSP exploration DCSP cannot DCSP be DCSP unmarked DCSP as DCSP "featured".') DCNL DCSP _change_activity_status(committer_id, activity_id, activity_type, ACTIVITY_STATUS_PUBLIC, 'Exploration DCSP unpublicized.')
 DCSP _assign_role(committer_id, assignee_id, new_role, exploration_id, constants.ACTIVITY_TYPE_EXPLORATION) DCNL DCSP if (new_role in [ROLE_OWNER, ROLE_EDITOR]): DCNL DCSP  DCSP subscription_services.subscribe_to_exploration(assignee_id, exploration_id)
 DCSP _release_ownership_of_activity(committer_id, exploration_id, constants.ACTIVITY_TYPE_EXPLORATION)
 DCSP if (not Actor(committer_id).can_change_private_viewability(constants.ACTIVITY_TYPE_EXPLORATION, exploration_id)): DCNL DCSP  DCSP logging.error(('User DCSP %s DCSP tried DCSP to DCSP change DCSP private DCSP viewability DCSP of DCSP exploration DCSP %s DCSP but DCSP was DCSP refused DCSP permission.' % (committer_id, exploration_id))) DCNL DCSP  DCSP raise Exception('The DCSP viewability DCSP status DCSP of DCSP this DCSP exploration DCSP cannot DCSP be DCSP changed.') DCNL DCSP exploration_rights = get_exploration_rights(exploration_id) DCNL DCSP old_viewable_if_private = exploration_rights.viewable_if_private DCNL DCSP if (old_viewable_if_private == viewable_if_private): DCNL DCSP  DCSP raise Exception(('Trying DCSP to DCSP change DCSP viewability DCSP status DCSP of DCSP this DCSP exploration DCSP to DCSP %s, DCSP but DCSP that DCSP is DCSP already DCSP the DCSP current DCSP value.' % viewable_if_private)) DCNL DCSP exploration_rights.viewable_if_private = viewable_if_private DCNL DCSP commit_cmds = [{'cmd': CMD_CHANGE_PRIVATE_VIEWABILITY, 'old_viewable_if_private': old_viewable_if_private, 'new_viewable_if_private': viewable_if_private}] DCNL DCSP commit_message = ('Made DCSP exploration DCSP viewable DCSP to DCSP anyone DCSP with DCSP the DCSP link.' if viewable_if_private else 'Made DCSP exploration DCSP viewable DCSP only DCSP to DCSP invited DCSP playtesters.') DCNL DCSP _save_activity_rights(committer_id, exploration_rights, constants.ACTIVITY_TYPE_EXPLORATION, commit_message, commit_cmds) DCNL DCSP _update_exploration_summary(exploration_rights)
 DCSP _publish_activity(committer_id, exploration_id, constants.ACTIVITY_TYPE_EXPLORATION)
 DCSP _unpublish_activity(committer_id, exploration_id, constants.ACTIVITY_TYPE_EXPLORATION)
 DCSP _publicize_activity(committer_id, exploration_id, constants.ACTIVITY_TYPE_EXPLORATION)
 DCSP _unpublicize_activity(committer_id, exploration_id, constants.ACTIVITY_TYPE_EXPLORATION)
 DCSP _assign_role(committer_id, assignee_id, new_role, collection_id, constants.ACTIVITY_TYPE_COLLECTION) DCNL DCSP if (new_role in [ROLE_OWNER, ROLE_EDITOR]): DCNL DCSP  DCSP subscription_services.subscribe_to_collection(assignee_id, collection_id)
 DCSP _release_ownership_of_activity(committer_id, collection_id, constants.ACTIVITY_TYPE_COLLECTION)
 DCSP _publish_activity(committer_id, collection_id, constants.ACTIVITY_TYPE_COLLECTION)
 DCSP _unpublish_activity(committer_id, collection_id, constants.ACTIVITY_TYPE_COLLECTION)
 DCSP _publicize_activity(committer_id, collection_id, constants.ACTIVITY_TYPE_COLLECTION)
 DCSP _unpublicize_activity(committer_id, collection_id, constants.ACTIVITY_TYPE_COLLECTION)
 DCSP action_play_public = (role_services.ACTION_PLAY_ANY_PUBLIC_EXPLORATION if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION) else role_services.ACTION_PLAY_ANY_PUBLIC_COLLECTION) DCNL DCSP action_play_private = (role_services.ACTION_PLAY_ANY_PRIVATE_EXPLORATION if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION) else role_services.ACTION_PLAY_ANY_PRIVATE_COLLECTION) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP elif activity_rights.is_published(): DCNL DCSP  DCSP return bool((action_play_public in user_actions)) DCNL DCSP elif activity_rights.is_private(): DCNL DCSP  DCSP return bool(((action_play_private in user_actions) or activity_rights.is_viewer(user_id) or activity_rights.is_owner(user_id) or activity_rights.is_editor(user_id) or activity_rights.viewable_if_private))
 DCSP action_edit_any_activity = (role_services.ACTION_EDIT_ANY_EXPLORATION if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION) else role_services.ACTION_EDIT_ANY_COLLECTION) DCNL DCSP action_edit_any_public_activity = (role_services.ACTION_EDIT_ANY_PUBLIC_EXPLORATION if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION) else role_services.ACTION_EDIT_ANY_PUBLIC_COLLECTION) DCNL DCSP action_edit_owned_activity = (role_services.ACTION_EDIT_OWNED_EXPLORATION if (activity_type == constants.ACTIVITY_TYPE_EXPLORATION) else role_services.ACTION_EDIT_OWNED_COLLECTION) DCNL DCSP if (action_edit_owned_activity in user_actions): DCNL DCSP  DCSP if (activity_rights.is_owner(user_id) or activity_rights.is_editor(user_id)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False DCNL DCSP if (activity_rights.community_owned or (action_edit_any_activity in user_actions)): DCNL DCSP  DCSP return True DCNL DCSP if (activity_rights.is_published() and (action_edit_any_public_activity in user_actions)): DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP if (collection_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (collection_rights.is_published() and (role_services.ACTION_UNPUBLISH_PUBLIC_COLLECTION in user_actions)): DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP if (exploration_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (exploration_rights.is_private() and (role_services.ACTION_DELETE_OWNED_PRIVATE_EXPLORATION in user_actions) and exploration_rights.is_owner(user_id)): DCNL DCSP  DCSP return True DCNL DCSP elif (exploration_rights.is_published() and (role_services.ACTION_DELETE_ANY_PUBLIC_EXPLORATION in user_actions)): DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP if (exploration_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (exploration_rights.community_owned or exploration_rights.cloned_from): DCNL DCSP  DCSP return False DCNL DCSP if (role_services.ACTION_MODIFY_ROLES_FOR_ANY_EXPLORATION in user_actions): DCNL DCSP  DCSP return True DCNL DCSP if (role_services.ACTION_MODIFY_ROLES_FOR_OWNED_EXPLORATION in user_actions): DCNL DCSP  DCSP if exploration_rights.is_owner(user_id): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (exploration_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if exploration_rights.is_private(): DCNL DCSP  DCSP return False DCNL DCSP return check_can_modify_exploration_roles(user_id, user_actions, exploration_rights)
 DCSP if (exploration_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if exploration_rights.cloned_from: DCNL DCSP  DCSP return False DCNL DCSP if (role_services.ACTION_PUBLISH_ANY_EXPLORATION in user_actions): DCNL DCSP  DCSP return True DCNL DCSP if exploration_rights.is_private(): DCNL DCSP  DCSP if (role_services.ACTION_PUBLISH_OWNED_EXPLORATION in user_actions): DCNL DCSP  DCSP  DCSP if exploration_rights.is_owner(user_id): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (exploration_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (exploration_rights.status == ACTIVITY_STATUS_PUBLIC): DCNL DCSP  DCSP if (role_services.ACTION_PUBLICIZE_EXPLORATION in user_actions): DCNL DCSP  DCSP  DCSP return True
 DCSP if (exploration_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (exploration_rights.status == ACTIVITY_STATUS_PUBLICIZED): DCNL DCSP  DCSP if (role_services.ACTION_UNPUBLICIZE_EXPLORATION in user_actions): DCNL DCSP  DCSP  DCSP return True
 DCSP if (exploration_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if exploration_rights.community_owned: DCNL DCSP  DCSP return False DCNL DCSP if (exploration_rights.status == ACTIVITY_STATUS_PUBLIC): DCNL DCSP  DCSP if (role_services.ACTION_UNPUBLISH_PUBLIC_EXPLORATION in user_actions): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (name in ('title', 'target')): DCNL DCSP  DCSP return True DCNL DCSP if (name == 'href'): DCNL DCSP  DCSP url_components = urlparse.urlsplit(value) DCNL DCSP  DCSP if (url_components[0] in ['http', 'https']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP logging.error(('Found DCSP invalid DCSP URL DCSP href: DCSP %s' % value)) DCNL DCSP return False
 DCSP oppia_custom_tags = rte_component_registry.Registry.get_tag_list_with_attrs() DCNL DCSP core_tags = ATTRS_WHITELIST.copy() DCNL DCSP core_tags.update(oppia_custom_tags) DCNL DCSP tag_names = core_tags.keys() DCNL DCSP return bleach.clean(user_submitted_html, tags=tag_names, attributes=core_tags, strip=True)
 DCSP return bleach.clean(html, tags=[], attributes={}, strip=True)
 DCSP parser = HTMLParser.HTMLParser() DCNL DCSP components = [] DCNL DCSP soup = bs4.BeautifulSoup(html_string, 'html.parser') DCNL DCSP oppia_custom_tag_attrs = rte_component_registry.Registry.get_tag_list_with_attrs() DCNL DCSP for tag_name in oppia_custom_tag_attrs: DCNL DCSP  DCSP component_tags = soup.find_all(tag_name) DCNL DCSP  DCSP for component_tag in component_tags: DCNL DCSP  DCSP  DCSP component = {'id': tag_name} DCNL DCSP  DCSP  DCSP customization_args = {} DCNL DCSP  DCSP  DCSP for attr in oppia_custom_tag_attrs[tag_name]: DCNL DCSP  DCSP  DCSP  DCSP attr_val = parser.unescape(component_tag[attr]) DCNL DCSP  DCSP  DCSP  DCSP attr_val = attr_val.encode('unicode_escape') DCNL DCSP  DCSP  DCSP  DCSP customization_args[attr] = json.loads(attr_val) DCNL DCSP  DCSP  DCSP component['customization_args'] = customization_args DCNL DCSP  DCSP  DCSP components.append(component) DCNL DCSP return components
 DCSP payload = {'exploration_id': exploration_id, 'report_text': report_text, 'reporter_id': reporter_id} DCNL DCSP taskqueue_services.enqueue_task(feconf.TASK_URL_FLAG_EXPLORATION_EMAILS, payload, 0)
 DCSP collection_schema_version = versioned_collection_contents['schema_version'] DCNL DCSP if (not (1 <= collection_schema_version <= feconf.CURRENT_COLLECTION_SCHEMA_VERSION)): DCNL DCSP  DCSP raise Exception(('Sorry, DCSP we DCSP can DCSP only DCSP process DCSP v1-v%d DCSP collection DCSP schemas DCSP at DCSP present.' % feconf.CURRENT_COLLECTION_SCHEMA_VERSION)) DCNL DCSP while (collection_schema_version < feconf.CURRENT_COLLECTION_SCHEMA_VERSION): DCNL DCSP  DCSP collection_domain.Collection.update_collection_contents_from_model(versioned_collection_contents, collection_schema_version) DCNL DCSP  DCSP collection_schema_version += 1
 DCSP if version: DCNL DCSP  DCSP return ('collection-version:%s:%s' % (collection_id, version)) DCNL DCSP else: DCNL DCSP  DCSP return ('collection:%s' % collection_id)
 DCSP versioned_collection_contents = {'schema_version': collection_model.schema_version, 'collection_contents': copy.deepcopy(collection_model.collection_contents)} DCNL DCSP if (collection_model.schema_version == 2): DCNL DCSP  DCSP versioned_collection_contents['collection_contents'] = {'nodes': copy.deepcopy(collection_model.nodes)} DCNL DCSP if (run_conversion and (collection_model.schema_version != feconf.CURRENT_COLLECTION_SCHEMA_VERSION)): DCNL DCSP  DCSP _migrate_collection_contents_to_latest_schema(versioned_collection_contents) DCNL DCSP return collection_domain.Collection(collection_model.id, collection_model.title, collection_model.category, collection_model.objective, collection_model.language_code, collection_model.tags, versioned_collection_contents['schema_version'], [collection_domain.CollectionNode.from_dict(collection_node_dict) for collection_node_dict in versioned_collection_contents['collection_contents']['nodes']], {skill_id: collection_domain.CollectionSkill.from_dict(skill_id, skill_dict) for (skill_id, skill_dict) in versioned_collection_contents['collection_contents']['skills'].iteritems()}, versioned_collection_contents['collection_contents']['next_skill_id'], collection_model.version, collection_model.created_on, collection_model.last_updated)
 DCSP return collection_domain.CollectionSummary(collection_summary_model.id, collection_summary_model.title, collection_summary_model.category, collection_summary_model.objective, collection_summary_model.language_code, collection_summary_model.tags, collection_summary_model.status, collection_summary_model.community_owned, collection_summary_model.owner_ids, collection_summary_model.editor_ids, collection_summary_model.viewer_ids, collection_summary_model.contributor_ids, collection_summary_model.contributors_summary, collection_summary_model.version, collection_summary_model.node_count, collection_summary_model.collection_model_created_on, collection_summary_model.collection_model_last_updated)
 DCSP collection_memcache_key = _get_collection_memcache_key(collection_id, version=version) DCNL DCSP memcached_collection = memcache_services.get_multi([collection_memcache_key]).get(collection_memcache_key) DCNL DCSP if (memcached_collection is not None): DCNL DCSP  DCSP return memcached_collection DCNL DCSP else: DCNL DCSP  DCSP collection_model = collection_models.CollectionModel.get(collection_id, strict=strict, version=version) DCNL DCSP  DCSP if collection_model: DCNL DCSP  DCSP  DCSP collection = get_collection_from_model(collection_model) DCNL DCSP  DCSP  DCSP memcache_services.set_multi({collection_memcache_key: collection}) DCNL DCSP  DCSP  DCSP return collection DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None
 DCSP collection_summary_model = collection_models.CollectionSummaryModel.get(collection_id) DCNL DCSP if collection_summary_model: DCNL DCSP  DCSP collection_summary = get_collection_summary_from_model(collection_summary_model) DCNL DCSP  DCSP return collection_summary DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP collection_ids = set(collection_ids) DCNL DCSP result = {} DCNL DCSP uncached = [] DCNL DCSP memcache_keys = [_get_collection_memcache_key(i) for i in collection_ids] DCNL DCSP cache_result = memcache_services.get_multi(memcache_keys) DCNL DCSP for collection_obj in cache_result.itervalues(): DCNL DCSP  DCSP result[collection_obj.id] = collection_obj DCNL DCSP for _id in collection_ids: DCNL DCSP  DCSP if (_id not in result): DCNL DCSP  DCSP  DCSP uncached.append(_id) DCNL DCSP db_collection_models = collection_models.CollectionModel.get_multi(uncached) DCNL DCSP db_results_dict = {} DCNL DCSP not_found = [] DCNL DCSP for (index, cid) in enumerate(uncached): DCNL DCSP  DCSP model = db_collection_models[index] DCNL DCSP  DCSP if model: DCNL DCSP  DCSP  DCSP collection = get_collection_from_model(model) DCNL DCSP  DCSP  DCSP db_results_dict[cid] = collection DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.info(('Tried DCSP to DCSP fetch DCSP collection DCSP with DCSP id DCSP %s, DCSP but DCSP no DCSP such DCSP collection DCSP exists DCSP in DCSP the DCSP datastore' % cid)) DCNL DCSP  DCSP  DCSP not_found.append(cid) DCNL DCSP if (strict and not_found): DCNL DCSP  DCSP raise ValueError(("Couldn't DCSP find DCSP collections DCSP with DCSP the DCSP following DCSP ids:\n%s" % '\n'.join(not_found))) DCNL DCSP cache_update = {cid: db_results_dict[cid] for cid in db_results_dict.iterkeys() if (db_results_dict[cid] is not None)} DCNL DCSP if cache_update: DCNL DCSP  DCSP memcache_services.set_multi(cache_update) DCNL DCSP result.update(db_results_dict) DCNL DCSP return result
 DCSP return collection_models.CollectionModel.get_new_id('')
 DCSP collection_list = [(get_collection_from_model(e) if e else None) for e in collection_models.CollectionModel.get_multi(collection_ids)] DCNL DCSP result = {} DCNL DCSP for collection in collection_list: DCNL DCSP  DCSP if (collection is None): DCNL DCSP  DCSP  DCSP logging.error('Could DCSP not DCSP find DCSP collection DCSP corresponding DCSP to DCSP id') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result[collection.id] = {'title': collection.title, 'category': collection.category} DCNL DCSP return result
 DCSP progress_model = user_models.CollectionProgressModel.get(user_id, collection_id) DCNL DCSP return (progress_model.completed_explorations if progress_model else [])
 DCSP progress_models = user_models.CollectionProgressModel.get_multi(user_id, collection_ids) DCNL DCSP exploration_ids_completed_in_collections = [] DCNL DCSP for progress_model in progress_models: DCNL DCSP  DCSP if progress_model: DCNL DCSP  DCSP  DCSP exploration_ids_completed_in_collections.append(progress_model.completed_explorations) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP exploration_ids_completed_in_collections.append([]) DCNL DCSP return exploration_ids_completed_in_collections
 DCSP completed_exploration_ids = get_completed_exploration_ids(user_id, collection.id) DCNL DCSP return [exp_id for exp_id in completed_exploration_ids if collection.get_node(exp_id)]
 DCSP completed_exploration_ids = get_completed_exploration_ids(user_id, collection_id) DCNL DCSP collection = get_collection_by_id(collection_id) DCNL DCSP if completed_exploration_ids: DCNL DCSP  DCSP return collection.get_next_exploration_ids(completed_exploration_ids) DCNL DCSP else: DCNL DCSP  DCSP return collection.init_exploration_ids
 DCSP progress_model = user_models.CollectionProgressModel.get_or_create(user_id, collection_id) DCNL DCSP if (exploration_id not in progress_model.completed_explorations): DCNL DCSP  DCSP progress_model.completed_explorations.append(exploration_id) DCNL DCSP  DCSP progress_model.put()
 DCSP collection_summaries = [get_collection_summary_from_model(collection_summary_model) for collection_summary_model in collection_summary_models] DCNL DCSP result = {} DCNL DCSP for collection_summary in collection_summaries: DCNL DCSP  DCSP result[collection_summary.id] = collection_summary DCNL DCSP return result
 DCSP return [(get_collection_summary_from_model(model) if model else None) for model in collection_models.CollectionSummaryModel.get_multi(collection_ids)]
 DCSP returned_collection_ids = [] DCNL DCSP search_cursor = cursor DCNL DCSP for _ in range(MAX_ITERATIONS): DCNL DCSP  DCSP remaining_to_fetch = (feconf.SEARCH_RESULTS_PAGE_SIZE - len(returned_collection_ids)) DCNL DCSP  DCSP (collection_ids, search_cursor) = search_collections(query_string, remaining_to_fetch, cursor=search_cursor) DCNL DCSP  DCSP invalid_collection_ids = [] DCNL DCSP  DCSP for (ind, model) in enumerate(collection_models.CollectionSummaryModel.get_multi(collection_ids)): DCNL DCSP  DCSP  DCSP if (model is not None): DCNL DCSP  DCSP  DCSP  DCSP returned_collection_ids.append(collection_ids[ind]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP invalid_collection_ids.append(collection_ids[ind]) DCNL DCSP  DCSP if ((len(returned_collection_ids) == feconf.SEARCH_RESULTS_PAGE_SIZE) or (search_cursor is None)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.error(('Search DCSP index DCSP contains DCSP stale DCSP collection DCSP ids: DCSP %s' % ', DCSP '.join(invalid_collection_ids))) DCNL DCSP if ((len(returned_collection_ids) < feconf.SEARCH_RESULTS_PAGE_SIZE) and (search_cursor is not None)): DCNL DCSP  DCSP logging.error(('Could DCSP not DCSP fulfill DCSP search DCSP request DCSP for DCSP query DCSP string DCSP %s; DCSP at DCSP least DCSP %s DCSP retries DCSP were DCSP needed.' % (query_string, MAX_ITERATIONS))) DCNL DCSP return (returned_collection_ids, search_cursor)
 DCSP collection = get_collection_by_id(collection_id) DCNL DCSP try: DCNL DCSP  DCSP changes = [collection_domain.CollectionChange(change_dict) for change_dict in change_list] DCNL DCSP  DCSP for change in changes: DCNL DCSP  DCSP  DCSP if (change.cmd == collection_domain.CMD_ADD_COLLECTION_NODE): DCNL DCSP  DCSP  DCSP  DCSP collection.add_node(change.exploration_id) DCNL DCSP  DCSP  DCSP elif (change.cmd == collection_domain.CMD_DELETE_COLLECTION_NODE): DCNL DCSP  DCSP  DCSP  DCSP collection.delete_node(change.exploration_id) DCNL DCSP  DCSP  DCSP elif (change.cmd == collection_domain.CMD_EDIT_COLLECTION_NODE_PROPERTY): DCNL DCSP  DCSP  DCSP  DCSP collection_node = collection.get_node(change.exploration_id) DCNL DCSP  DCSP  DCSP  DCSP if (change.property_name == collection_domain.COLLECTION_NODE_PROPERTY_PREREQUISITE_SKILL_IDS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP collection_node.update_prerequisite_skill_ids(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == collection_domain.COLLECTION_NODE_PROPERTY_ACQUIRED_SKILL_IDS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP collection_node.update_acquired_skill_ids(change.new_value) DCNL DCSP  DCSP  DCSP elif (change.cmd == collection_domain.CMD_EDIT_COLLECTION_PROPERTY): DCNL DCSP  DCSP  DCSP  DCSP if (change.property_name == collection_domain.COLLECTION_PROPERTY_TITLE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP collection.update_title(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == collection_domain.COLLECTION_PROPERTY_CATEGORY): DCNL DCSP  DCSP  DCSP  DCSP  DCSP collection.update_category(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == collection_domain.COLLECTION_PROPERTY_OBJECTIVE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP collection.update_objective(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == collection_domain.COLLECTION_PROPERTY_LANGUAGE_CODE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP collection.update_language_code(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == collection_domain.COLLECTION_PROPERTY_TAGS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP collection.update_tags(change.new_value) DCNL DCSP  DCSP  DCSP elif (change.cmd == collection_domain.CMD_MIGRATE_SCHEMA_TO_LATEST_VERSION): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (change.cmd == collection_domain.CMD_ADD_COLLECTION_SKILL): DCNL DCSP  DCSP  DCSP  DCSP collection.add_skill(change.name) DCNL DCSP  DCSP  DCSP elif (change.cmd == collection_domain.CMD_DELETE_COLLECTION_SKILL): DCNL DCSP  DCSP  DCSP  DCSP collection.delete_skill(change.skill_id) DCNL DCSP  DCSP return collection DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.error(('%s DCSP %s DCSP %s DCSP %s' % (e.__class__.__name__, e, collection_id, change_list))) DCNL DCSP  DCSP raise
 DCSP for exploration_id in collection.exploration_ids: DCNL DCSP  DCSP if rights_manager.is_exploration_private(exploration_id): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Cannot DCSP reference DCSP a DCSP private DCSP exploration DCSP within DCSP a DCSP public DCSP collection, DCSP exploration DCSP ID: DCSP %s' % exploration_id))
 DCSP if (not change_list): DCNL DCSP  DCSP raise Exception(('Unexpected DCSP error: DCSP received DCSP an DCSP invalid DCSP change DCSP list DCSP when DCSP trying DCSP to DCSP save DCSP collection DCSP %s: DCSP %s' % (collection.id, change_list))) DCNL DCSP collection_rights = rights_manager.get_collection_rights(collection.id) DCNL DCSP if (collection_rights.status != rights_manager.ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP collection.validate(strict=True) DCNL DCSP else: DCNL DCSP  DCSP collection.validate(strict=False) DCNL DCSP exp_ids = collection.exploration_ids DCNL DCSP exp_summaries = exp_services.get_exploration_summaries_matching_ids(exp_ids) DCNL DCSP exp_summaries_dict = {exp_id: exp_summaries[ind] for (ind, exp_id) in enumerate(exp_ids)} DCNL DCSP for collection_node in collection.nodes: DCNL DCSP  DCSP if (not exp_summaries_dict[collection_node.exploration_id]): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP collection DCSP to DCSP only DCSP reference DCSP valid DCSP explorations, DCSP but DCSP found DCSP an DCSP exploration DCSP with DCSP ID: DCSP %s DCSP (was DCSP it DCSP deleted?)' % collection_node.exploration_id)) DCNL DCSP if rights_manager.is_collection_public(collection.id): DCNL DCSP  DCSP validate_exps_in_collection_are_public(collection) DCNL DCSP collection_model = collection_models.CollectionModel.get(collection.id, strict=False) DCNL DCSP if (collection_model is None): DCNL DCSP  DCSP collection_model = collection_models.CollectionModel(id=collection.id) DCNL DCSP elif (collection.version > collection_model.version): DCNL DCSP  DCSP raise Exception(('Unexpected DCSP error: DCSP trying DCSP to DCSP update DCSP version DCSP %s DCSP of DCSP collection DCSP from DCSP version DCSP %s. DCSP Please DCSP reload DCSP the DCSP page DCSP and DCSP try DCSP again.' % (collection_model.version, collection.version))) DCNL DCSP elif (collection.version < collection_model.version): DCNL DCSP  DCSP raise Exception(('Trying DCSP to DCSP update DCSP version DCSP %s DCSP of DCSP collection DCSP from DCSP version DCSP %s, DCSP which DCSP is DCSP too DCSP old. DCSP Please DCSP reload DCSP the DCSP page DCSP and DCSP try DCSP again.' % (collection_model.version, collection.version))) DCNL DCSP collection_model.category = collection.category DCNL DCSP collection_model.title = collection.title DCNL DCSP collection_model.objective = collection.objective DCNL DCSP collection_model.language_code = collection.language_code DCNL DCSP collection_model.tags = collection.tags DCNL DCSP collection_model.schema_version = collection.schema_version DCNL DCSP collection_model.collection_contents = {'nodes': [collection_node.to_dict() for collection_node in collection.nodes], 'skills': {skill_id: skill.to_dict() for (skill_id, skill) in collection.skills.iteritems()}, 'next_skill_id': collection.next_skill_id} DCNL DCSP collection_model.node_count = len(collection_model.nodes) DCNL DCSP collection_model.commit(committer_id, commit_message, change_list) DCNL DCSP memcache_services.delete(_get_collection_memcache_key(collection.id)) DCNL DCSP index_collections_given_ids([collection.id]) DCNL DCSP collection.version += 1
 DCSP collection.validate(strict=False) DCNL DCSP rights_manager.create_new_collection_rights(collection.id, committer_id) DCNL DCSP model = collection_models.CollectionModel(id=collection.id, category=collection.category, title=collection.title, objective=collection.objective, language_code=collection.language_code, tags=collection.tags, schema_version=collection.schema_version, collection_contents={'nodes': [collection_node.to_dict() for collection_node in collection.nodes], 'skills': {skill_id: skill.to_dict() for (skill_id, skill) in collection.skills.iteritems()}, 'next_skill_id': collection.next_skill_id}) DCNL DCSP model.commit(committer_id, commit_message, commit_cmds) DCNL DCSP collection.version += 1 DCNL DCSP create_collection_summary(collection.id, committer_id)
 DCSP commit_message = ("New DCSP collection DCSP created DCSP with DCSP title DCSP '%s'." % collection.title) DCNL DCSP _create_collection(committer_id, collection, commit_message, [{'cmd': CMD_CREATE_NEW, 'title': collection.title, 'category': collection.category}])
 DCSP collection_rights_model = collection_models.CollectionRightsModel.get(collection_id) DCNL DCSP collection_rights_model.delete(committer_id, '', force_deletion=force_deletion) DCNL DCSP collection_model = collection_models.CollectionModel.get(collection_id) DCNL DCSP collection_model.delete(committer_id, feconf.COMMIT_MESSAGE_COLLECTION_DELETED, force_deletion=force_deletion) DCNL DCSP collection_memcache_key = _get_collection_memcache_key(collection_id) DCNL DCSP memcache_services.delete(collection_memcache_key) DCNL DCSP delete_documents_from_search_index([collection_id]) DCNL DCSP delete_collection_summary(collection_id) DCNL DCSP activity_services.remove_featured_activity(constants.ACTIVITY_TYPE_COLLECTION, collection_id)
 DCSP collection = get_collection_by_id(collection_id) DCNL DCSP current_version = collection.version DCNL DCSP version_nums = range(1, (current_version + 1)) DCNL DCSP return collection_models.CollectionModel.get_snapshots_metadata(collection_id, version_nums)
 DCSP rights_manager.publish_collection(committer_id, collection_id) DCNL DCSP contribution_time_msec = utils.get_current_time_in_millisecs() DCNL DCSP collection_summary = get_collection_summary_by_id(collection_id) DCNL DCSP contributor_ids = collection_summary.contributor_ids DCNL DCSP for contributor in contributor_ids: DCNL DCSP  DCSP user_services.update_first_contribution_msec_if_not_set(contributor, contribution_time_msec)
 DCSP is_public = rights_manager.is_collection_public(collection_id) DCNL DCSP if (is_public and (not commit_message)): DCNL DCSP  DCSP raise ValueError('Collection DCSP is DCSP public DCSP so DCSP expected DCSP a DCSP commit DCSP message DCSP but DCSP received DCSP none.') DCNL DCSP collection = apply_change_list(collection_id, change_list) DCNL DCSP _save_collection(committer_id, collection, commit_message, change_list) DCNL DCSP update_collection_summary(collection.id, committer_id) DCNL DCSP if ((not rights_manager.is_collection_private(collection.id)) and (committer_id != feconf.MIGRATION_BOT_USER_ID)): DCNL DCSP  DCSP user_services.update_first_contribution_msec_if_not_set(committer_id, utils.get_current_time_in_millisecs())
 DCSP collection = get_collection_by_id(collection_id) DCNL DCSP collection_summary = compute_summary_of_collection(collection, contributor_id_to_add) DCNL DCSP save_collection_summary(collection_summary)
 DCSP create_collection_summary(collection_id, contributor_id_to_add)
 DCSP collection_rights = collection_models.CollectionRightsModel.get_by_id(collection.id) DCNL DCSP collection_summary_model = collection_models.CollectionSummaryModel.get_by_id(collection.id) DCNL DCSP if collection_summary_model: DCNL DCSP  DCSP contributor_ids = collection_summary_model.contributor_ids DCNL DCSP  DCSP contributors_summary = collection_summary_model.contributors_summary DCNL DCSP else: DCNL DCSP  DCSP contributor_ids = [] DCNL DCSP  DCSP contributors_summary = {} DCNL DCSP if ((contributor_id_to_add is not None) and (contributor_id_to_add not in feconf.SYSTEM_USER_IDS) and (contributor_id_to_add not in contributor_ids)): DCNL DCSP  DCSP contributor_ids.append(contributor_id_to_add) DCNL DCSP if (contributor_id_to_add not in feconf.SYSTEM_USER_IDS): DCNL DCSP  DCSP if (contributor_id_to_add is None): DCNL DCSP  DCSP  DCSP contributors_summary = compute_collection_contributors_summary(collection.id) DCNL DCSP  DCSP elif (contributor_id_to_add in contributors_summary): DCNL DCSP  DCSP  DCSP contributors_summary[contributor_id_to_add] += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP contributors_summary[contributor_id_to_add] = 1 DCNL DCSP collection_model_last_updated = collection.last_updated DCNL DCSP collection_model_created_on = collection.created_on DCNL DCSP collection_model_node_count = len(collection.nodes) DCNL DCSP collection_summary = collection_domain.CollectionSummary(collection.id, collection.title, collection.category, collection.objective, collection.language_code, collection.tags, collection_rights.status, collection_rights.community_owned, collection_rights.owner_ids, collection_rights.editor_ids, collection_rights.viewer_ids, contributor_ids, contributors_summary, collection.version, collection_model_node_count, collection_model_created_on, collection_model_last_updated) DCNL DCSP return collection_summary
 DCSP snapshots_metadata = get_collection_snapshots_metadata(collection_id) DCNL DCSP current_version = len(snapshots_metadata) DCNL DCSP contributors_summary = collections.defaultdict(int) DCNL DCSP while True: DCNL DCSP  DCSP snapshot_metadata = snapshots_metadata[(current_version - 1)] DCNL DCSP  DCSP committer_id = snapshot_metadata['committer_id'] DCNL DCSP  DCSP is_revert = (snapshot_metadata['commit_type'] == 'revert') DCNL DCSP  DCSP if ((not is_revert) and (committer_id not in feconf.SYSTEM_USER_IDS)): DCNL DCSP  DCSP  DCSP contributors_summary[committer_id] += 1 DCNL DCSP  DCSP if (current_version == 1): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if is_revert: DCNL DCSP  DCSP  DCSP current_version = snapshot_metadata['commit_cmds'][0]['version_number'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP current_version -= 1 DCNL DCSP return contributors_summary
 DCSP collection_summary_model = collection_models.CollectionSummaryModel(id=collection_summary.id, title=collection_summary.title, category=collection_summary.category, objective=collection_summary.objective, language_code=collection_summary.language_code, tags=collection_summary.tags, status=collection_summary.status, community_owned=collection_summary.community_owned, owner_ids=collection_summary.owner_ids, editor_ids=collection_summary.editor_ids, viewer_ids=collection_summary.viewer_ids, contributor_ids=collection_summary.contributor_ids, contributors_summary=collection_summary.contributors_summary, version=collection_summary.version, node_count=collection_summary.node_count, collection_model_last_updated=collection_summary.collection_model_last_updated, collection_model_created_on=collection_summary.collection_model_created_on) DCNL DCSP collection_summary_model.put()
 DCSP collection_models.CollectionSummaryModel.get(collection_id).delete()
 DCSP collection = collection_domain.Collection.from_yaml(collection_id, yaml_content) DCNL DCSP commit_message = ("New DCSP collection DCSP created DCSP from DCSP YAML DCSP file DCSP with DCSP title DCSP '%s'." % collection.title) DCNL DCSP _create_collection(committer_id, collection, commit_message, [{'cmd': CMD_CREATE_NEW, 'title': collection.title, 'category': collection.category}]) DCNL DCSP return collection
 DCSP if (not collection_domain.Collection.is_demo_collection_id(collection_id)): DCNL DCSP  DCSP raise Exception(('Invalid DCSP demo DCSP collection DCSP id DCSP %s' % collection_id)) DCNL DCSP collection = get_collection_by_id(collection_id, strict=False) DCNL DCSP if (not collection): DCNL DCSP  DCSP logging.info(('Collection DCSP with DCSP id DCSP %s DCSP was DCSP not DCSP deleted, DCSP because DCSP it DCSP does DCSP not DCSP exist.' % collection_id)) DCNL DCSP else: DCNL DCSP  DCSP delete_collection(feconf.SYSTEM_COMMITTER_ID, collection_id, force_deletion=True)
 DCSP delete_demo(collection_id) DCNL DCSP if (not collection_domain.Collection.is_demo_collection_id(collection_id)): DCNL DCSP  DCSP raise Exception(('Invalid DCSP demo DCSP collection DCSP id DCSP %s' % collection_id)) DCNL DCSP demo_filepath = os.path.join(feconf.SAMPLE_COLLECTIONS_DIR, feconf.DEMO_COLLECTIONS[collection_id]) DCNL DCSP if demo_filepath.endswith('yaml'): DCNL DCSP  DCSP yaml_content = utils.get_file_contents(demo_filepath) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unrecognized DCSP file DCSP path: DCSP %s' % demo_filepath)) DCNL DCSP collection = save_new_collection_from_yaml(feconf.SYSTEM_COMMITTER_ID, yaml_content, collection_id) DCNL DCSP publish_collection_and_update_user_profiles(feconf.SYSTEM_COMMITTER_ID, collection_id) DCNL DCSP index_collections_given_ids([collection_id]) DCNL DCSP for collection_node in collection.nodes: DCNL DCSP  DCSP exp_id = collection_node.exploration_id DCNL DCSP  DCSP if (exp_services.get_exploration_by_id(exp_id, strict=False) is None): DCNL DCSP  DCSP  DCSP exp_services.load_demo(exp_id) DCNL DCSP logging.info(('Collection DCSP with DCSP id DCSP %s DCSP was DCSP loaded.' % collection_id))
 DCSP (results, new_urlsafe_start_cursor, more) = collection_models.CollectionCommitLogEntryModel.get_all_commits(page_size, urlsafe_start_cursor) DCNL DCSP return ([collection_domain.CollectionCommitLogEntry(entry.created_on, entry.last_updated, entry.user_id, entry.username, entry.collection_id, entry.commit_type, entry.commit_message, entry.commit_cmds, entry.version, entry.post_commit_status, entry.post_commit_community_owned, entry.post_commit_is_private) for entry in results], new_urlsafe_start_cursor, more)
 DCSP if ((max_age is not None) and (not isinstance(max_age, datetime.timedelta))): DCNL DCSP  DCSP raise ValueError('max_age DCSP must DCSP be DCSP a DCSP datetime.timedelta DCSP instance. DCSP or DCSP None.') DCNL DCSP (results, new_urlsafe_start_cursor, more) = collection_models.CollectionCommitLogEntryModel.get_all_non_private_commits(page_size, urlsafe_start_cursor, max_age=max_age) DCNL DCSP return ([collection_domain.CollectionCommitLogEntry(entry.created_on, entry.last_updated, entry.user_id, entry.username, entry.collection_id, entry.commit_type, entry.commit_message, entry.commit_cmds, entry.version, entry.post_commit_status, entry.post_commit_community_owned, entry.post_commit_is_private) for entry in results], new_urlsafe_start_cursor, more)
 DCSP doc = {} DCNL DCSP if (rights.status == rights_manager.ACTIVITY_STATUS_PUBLICIZED): DCNL DCSP  DCSP doc['is'] = 'featured' DCNL DCSP return doc
 DCSP rights = rights_manager.get_collection_rights(collection.id) DCNL DCSP return (rights.status != rights_manager.ACTIVITY_STATUS_PRIVATE)
 DCSP rights = rights_manager.get_collection_rights(collection_id) DCNL DCSP rank = (_DEFAULT_RANK + (_STATUS_PUBLICIZED_BONUS if (rights.status == rights_manager.ACTIVITY_STATUS_PUBLICIZED) else 0)) DCNL DCSP return max(rank, 0)
 DCSP rights = rights_manager.get_collection_rights(collection.id) DCNL DCSP doc = {'id': collection.id, 'title': collection.title, 'category': collection.category, 'objective': collection.objective, 'language_code': collection.language_code, 'tags': collection.tags, 'rank': _get_search_rank(collection.id)} DCNL DCSP doc.update(_collection_rights_to_search_dict(rights)) DCNL DCSP return doc
 DCSP search_services.clear_index(SEARCH_INDEX_COLLECTIONS)
 DCSP collection_list = get_multiple_collections_by_id(collection_ids, strict=False).values() DCNL DCSP search_services.add_documents_to_index([_collection_to_search_dict(collection) for collection in collection_list if _should_index(collection)], SEARCH_INDEX_COLLECTIONS)
 DCSP doc = search_services.get_document_from_index(collection_id, SEARCH_INDEX_COLLECTIONS) DCNL DCSP doc.update(update) DCNL DCSP search_services.add_documents_to_index([doc], SEARCH_INDEX_COLLECTIONS)
 DCSP rights = rights_manager.get_collection_rights(collection_id) DCNL DCSP if (rights.status == rights_manager.ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP delete_documents_from_search_index([collection_id]) DCNL DCSP else: DCNL DCSP  DCSP patch_collection_search_document(rights.id, _collection_rights_to_search_dict(rights))
 DCSP search_services.delete_documents_from_index(collection_ids, SEARCH_INDEX_COLLECTIONS)
 DCSP return search_services.search(query, SEARCH_INDEX_COLLECTIONS, cursor, limit, sort, ids_only=True)
 DCSP return user_domain.CompletedActivities(completed_activities_model.id, completed_activities_model.exploration_ids, completed_activities_model.collection_ids)
 DCSP return user_domain.IncompleteActivities(incomplete_activities_model.id, incomplete_activities_model.exploration_ids, incomplete_activities_model.collection_ids)
 DCSP return user_domain.ExpUserLastPlaythrough(last_playthrough_model.user_id, last_playthrough_model.exploration_id, last_playthrough_model.last_played_exp_version, last_playthrough_model.last_updated, last_playthrough_model.last_played_state_name)
 DCSP completed_activities_model = user_models.CompletedActivitiesModel(id=activities_completed.id, exploration_ids=activities_completed.exploration_ids, collection_ids=activities_completed.collection_ids) DCNL DCSP completed_activities_model.put()
 DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel(id=incomplete_activities.id, exploration_ids=incomplete_activities.exploration_ids, collection_ids=incomplete_activities.collection_ids) DCNL DCSP incomplete_activities_model.put()
 DCSP last_playthrough_information_model = user_models.ExpUserLastPlaythroughModel(id=last_playthrough_information.id, user_id=last_playthrough_information.user_id, exploration_id=last_playthrough_information.exploration_id, last_played_exp_version=last_playthrough_information.last_played_exp_version, last_played_state_name=last_playthrough_information.last_played_state_name) DCNL DCSP last_playthrough_information_model.put()
 DCSP completed_activities_model = user_models.CompletedActivitiesModel.get(user_id, strict=False) DCNL DCSP if (not completed_activities_model): DCNL DCSP  DCSP completed_activities_model = user_models.CompletedActivitiesModel(id=user_id) DCNL DCSP subscribed_exploration_ids = subscription_services.get_exploration_ids_subscribed_to(user_id) DCNL DCSP activities_completed = _get_completed_activities_from_model(completed_activities_model) DCNL DCSP if ((exp_id not in subscribed_exploration_ids) and (exp_id not in activities_completed.exploration_ids)): DCNL DCSP  DCSP remove_exp_from_incomplete_list(user_id, exp_id) DCNL DCSP  DCSP learner_playlist_services.remove_exploration_from_learner_playlist(user_id, exp_id) DCNL DCSP  DCSP activities_completed.add_exploration_id(exp_id) DCNL DCSP  DCSP _save_completed_activities(activities_completed)
 DCSP completed_activities_model = user_models.CompletedActivitiesModel.get(user_id, strict=False) DCNL DCSP if (not completed_activities_model): DCNL DCSP  DCSP completed_activities_model = user_models.CompletedActivitiesModel(id=user_id) DCNL DCSP subscribed_collection_ids = subscription_services.get_collection_ids_subscribed_to(user_id) DCNL DCSP activities_completed = _get_completed_activities_from_model(completed_activities_model) DCNL DCSP if ((collection_id not in subscribed_collection_ids) and (collection_id not in activities_completed.collection_ids)): DCNL DCSP  DCSP remove_collection_from_incomplete_list(user_id, collection_id) DCNL DCSP  DCSP learner_playlist_services.remove_collection_from_learner_playlist(user_id, collection_id) DCNL DCSP  DCSP activities_completed.add_collection_id(collection_id) DCNL DCSP  DCSP _save_completed_activities(activities_completed)
 DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel.get(user_id, strict=False) DCNL DCSP if (not incomplete_activities_model): DCNL DCSP  DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel(id=user_id) DCNL DCSP exploration_ids = get_all_completed_exp_ids(user_id) DCNL DCSP subscribed_exploration_ids = subscription_services.get_exploration_ids_subscribed_to(user_id) DCNL DCSP incomplete_activities = _get_incomplete_activities_from_model(incomplete_activities_model) DCNL DCSP if ((exploration_id not in exploration_ids) and (exploration_id not in subscribed_exploration_ids)): DCNL DCSP  DCSP if (exploration_id not in incomplete_activities.exploration_ids): DCNL DCSP  DCSP  DCSP learner_playlist_services.remove_exploration_from_learner_playlist(user_id, exploration_id) DCNL DCSP  DCSP  DCSP incomplete_activities.add_exploration_id(exploration_id) DCNL DCSP  DCSP last_playthrough_information_model = user_models.ExpUserLastPlaythroughModel.get(user_id, exploration_id) DCNL DCSP  DCSP if (not last_playthrough_information_model): DCNL DCSP  DCSP  DCSP last_playthrough_information_model = user_models.ExpUserLastPlaythroughModel.create(user_id, exploration_id) DCNL DCSP  DCSP last_playthrough_information = _get_last_playthrough_information(last_playthrough_information_model) DCNL DCSP  DCSP last_playthrough_information.update_last_played_information(exploration_version, state_name) DCNL DCSP  DCSP _save_last_playthrough_information(last_playthrough_information) DCNL DCSP  DCSP _save_incomplete_activities(incomplete_activities)
 DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel.get(user_id, strict=False) DCNL DCSP if (not incomplete_activities_model): DCNL DCSP  DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel(id=user_id) DCNL DCSP collection_ids = get_all_completed_collection_ids(user_id) DCNL DCSP subscribed_collection_ids = subscription_services.get_collection_ids_subscribed_to(user_id) DCNL DCSP incomplete_activities = _get_incomplete_activities_from_model(incomplete_activities_model) DCNL DCSP if ((collection_id not in subscribed_collection_ids) and (collection_id not in incomplete_activities.collection_ids) and (collection_id not in collection_ids)): DCNL DCSP  DCSP learner_playlist_services.remove_collection_from_learner_playlist(user_id, collection_id) DCNL DCSP  DCSP incomplete_activities.add_collection_id(collection_id) DCNL DCSP  DCSP _save_incomplete_activities(incomplete_activities)
 DCSP completed_exploration_ids = get_all_completed_exp_ids(user_id) DCNL DCSP incomplete_exploration_ids = get_all_incomplete_exp_ids(user_id) DCNL DCSP if ((exploration_id not in completed_exploration_ids) and (exploration_id not in incomplete_exploration_ids)): DCNL DCSP  DCSP learner_playlist_services.mark_exploration_to_be_played_later(user_id, exploration_id, position_to_be_inserted)
 DCSP completed_collection_ids = get_all_completed_collection_ids(user_id) DCNL DCSP incomplete_collection_ids = get_all_incomplete_collection_ids(user_id) DCNL DCSP if ((collection_id not in completed_collection_ids) and (collection_id not in incomplete_collection_ids)): DCNL DCSP  DCSP learner_playlist_services.mark_collection_to_be_played_later(user_id, collection_id, position_to_be_inserted)
 DCSP learner_playlist_model = user_models.LearnerPlaylistModel.get(user_id, strict=False) DCNL DCSP if learner_playlist_model: DCNL DCSP  DCSP learner_playlist = learner_playlist_services.get_learner_playlist_from_model(learner_playlist_model) DCNL DCSP  DCSP for exploration_id in exploration_ids: DCNL DCSP  DCSP  DCSP learner_playlist.remove_exploration_id(exploration_id) DCNL DCSP  DCSP for collection_id in collection_ids: DCNL DCSP  DCSP  DCSP learner_playlist.remove_collection_id(collection_id) DCNL DCSP  DCSP learner_playlist_services.save_learner_playlist(learner_playlist)
 DCSP completed_activities_model = user_models.CompletedActivitiesModel.get(user_id, strict=False) DCNL DCSP if completed_activities_model: DCNL DCSP  DCSP activities_completed = _get_completed_activities_from_model(completed_activities_model) DCNL DCSP  DCSP if (exploration_id in activities_completed.exploration_ids): DCNL DCSP  DCSP  DCSP activities_completed.remove_exploration_id(exploration_id) DCNL DCSP  DCSP  DCSP _save_completed_activities(activities_completed)
 DCSP completed_activities_model = user_models.CompletedActivitiesModel.get(user_id, strict=False) DCNL DCSP if completed_activities_model: DCNL DCSP  DCSP activities_completed = _get_completed_activities_from_model(completed_activities_model) DCNL DCSP  DCSP if (collection_id in activities_completed.collection_ids): DCNL DCSP  DCSP  DCSP activities_completed.remove_collection_id(collection_id) DCNL DCSP  DCSP  DCSP _save_completed_activities(activities_completed)
 DCSP completed_activities_model = user_models.CompletedActivitiesModel.get(user_id, strict=False) DCNL DCSP if completed_activities_model: DCNL DCSP  DCSP activities_completed = _get_completed_activities_from_model(completed_activities_model) DCNL DCSP  DCSP for exploration_id in exploration_ids: DCNL DCSP  DCSP  DCSP activities_completed.remove_exploration_id(exploration_id) DCNL DCSP  DCSP for collection_id in collection_ids: DCNL DCSP  DCSP  DCSP activities_completed.remove_collection_id(collection_id) DCNL DCSP  DCSP _save_completed_activities(activities_completed)
 DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel.get(user_id, strict=False) DCNL DCSP if incomplete_activities_model: DCNL DCSP  DCSP incomplete_activities = _get_incomplete_activities_from_model(incomplete_activities_model) DCNL DCSP  DCSP if (exploration_id in incomplete_activities.exploration_ids): DCNL DCSP  DCSP  DCSP incomplete_activities.remove_exploration_id(exploration_id) DCNL DCSP  DCSP  DCSP last_playthrough_information_model = user_models.ExpUserLastPlaythroughModel.get(user_id, exploration_id) DCNL DCSP  DCSP  DCSP last_playthrough_information_model.delete() DCNL DCSP  DCSP  DCSP _save_incomplete_activities(incomplete_activities)
 DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel.get(user_id, strict=False) DCNL DCSP if incomplete_activities_model: DCNL DCSP  DCSP incomplete_activities = _get_incomplete_activities_from_model(incomplete_activities_model) DCNL DCSP  DCSP if (collection_id in incomplete_activities.collection_ids): DCNL DCSP  DCSP  DCSP incomplete_activities.remove_collection_id(collection_id) DCNL DCSP  DCSP  DCSP _save_incomplete_activities(incomplete_activities)
 DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel.get(user_id, strict=False) DCNL DCSP if incomplete_activities_model: DCNL DCSP  DCSP incomplete_activities = _get_incomplete_activities_from_model(incomplete_activities_model) DCNL DCSP  DCSP for exploration_id in exploration_ids: DCNL DCSP  DCSP  DCSP incomplete_activities.remove_exploration_id(exploration_id) DCNL DCSP  DCSP for collection_id in collection_ids: DCNL DCSP  DCSP  DCSP incomplete_activities.remove_collection_id(collection_id) DCNL DCSP  DCSP _save_incomplete_activities(incomplete_activities)
 DCSP completed_activities_model = user_models.CompletedActivitiesModel.get(user_id, strict=False) DCNL DCSP if completed_activities_model: DCNL DCSP  DCSP activities_completed = _get_completed_activities_from_model(completed_activities_model) DCNL DCSP  DCSP return activities_completed.exploration_ids DCNL DCSP else: DCNL DCSP  DCSP return []
 DCSP nonexistent_completed_exp_ids = [] DCNL DCSP filtered_completed_exp_summaries = [] DCNL DCSP for (index, exploration_summary) in enumerate(exploration_summaries): DCNL DCSP  DCSP if (exploration_summary is None): DCNL DCSP  DCSP  DCSP nonexistent_completed_exp_ids.append(exploration_ids[index]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filtered_completed_exp_summaries.append(exploration_summary) DCNL DCSP return (filtered_completed_exp_summaries, nonexistent_completed_exp_ids)
 DCSP completed_activities_model = user_models.CompletedActivitiesModel.get(user_id, strict=False) DCNL DCSP if completed_activities_model: DCNL DCSP  DCSP activities_completed = _get_completed_activities_from_model(completed_activities_model) DCNL DCSP  DCSP return activities_completed.collection_ids DCNL DCSP else: DCNL DCSP  DCSP return []
 DCSP nonexistent_completed_collection_ids = [] DCNL DCSP completed_to_incomplete_collections = [] DCNL DCSP filtered_completed_collection_summaries = [] DCNL DCSP completed_collections = collection_services.get_multiple_collections_by_id(collection_ids, strict=False) DCNL DCSP exploration_ids_completed_in_collections = collection_services.get_explorations_completed_in_collections(user_id, collection_ids) DCNL DCSP for (index, collection_summary) in enumerate(collection_summaries): DCNL DCSP  DCSP if (collection_summary is None): DCNL DCSP  DCSP  DCSP nonexistent_completed_collection_ids.append(collection_ids[index]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP completed_exploration_ids = exploration_ids_completed_in_collections[index] DCNL DCSP  DCSP  DCSP collection_model = completed_collections[collection_ids[index]] DCNL DCSP  DCSP  DCSP if collection_model.get_next_exploration_ids(completed_exploration_ids): DCNL DCSP  DCSP  DCSP  DCSP collection_id = collection_summary.id DCNL DCSP  DCSP  DCSP  DCSP remove_collection_from_completed_list(user_id, collection_id) DCNL DCSP  DCSP  DCSP  DCSP mark_collection_as_incomplete(user_id, collection_id) DCNL DCSP  DCSP  DCSP  DCSP completed_to_incomplete_collections.append(collection_summary) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP filtered_completed_collection_summaries.append(collection_summary) DCNL DCSP return (filtered_completed_collection_summaries, nonexistent_completed_collection_ids, completed_to_incomplete_collections)
 DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel.get(user_id, strict=False) DCNL DCSP if incomplete_activities_model: DCNL DCSP  DCSP incomplete_activities = _get_incomplete_activities_from_model(incomplete_activities_model) DCNL DCSP  DCSP return incomplete_activities.exploration_ids DCNL DCSP else: DCNL DCSP  DCSP return []
 DCSP nonexistent_incomplete_exp_ids = [] DCNL DCSP filtered_incomplete_exp_summaries = [] DCNL DCSP for (index, exploration_summary) in enumerate(exploration_summaries): DCNL DCSP  DCSP if (exploration_summary is None): DCNL DCSP  DCSP  DCSP nonexistent_incomplete_exp_ids.append(exploration_ids[index]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filtered_incomplete_exp_summaries.append(exploration_summary) DCNL DCSP return (filtered_incomplete_exp_summaries, nonexistent_incomplete_exp_ids)
 DCSP incomplete_activities_model = user_models.IncompleteActivitiesModel.get(user_id, strict=False) DCNL DCSP if incomplete_activities_model: DCNL DCSP  DCSP incomplete_activities = _get_incomplete_activities_from_model(incomplete_activities_model) DCNL DCSP  DCSP return incomplete_activities.collection_ids DCNL DCSP else: DCNL DCSP  DCSP return []
 DCSP nonexistent_incomplete_collection_ids = [] DCNL DCSP filtered_incomplete_collection_summaries = [] DCNL DCSP for (index, collection_summary) in enumerate(collection_summaries): DCNL DCSP  DCSP if (collection_summary is None): DCNL DCSP  DCSP  DCSP nonexistent_incomplete_collection_ids.append(collection_ids[index]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filtered_incomplete_collection_summaries.append(collection_summary) DCNL DCSP return (filtered_incomplete_collection_summaries, nonexistent_incomplete_collection_ids)
 DCSP nonexistent_playlist_exp_ids = [] DCNL DCSP filtered_exp_playlist_summaries = [] DCNL DCSP for (index, exploration_summary) in enumerate(exploration_summaries): DCNL DCSP  DCSP if (exploration_summary is None): DCNL DCSP  DCSP  DCSP nonexistent_playlist_exp_ids.append(exploration_ids[index]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filtered_exp_playlist_summaries.append(exploration_summary) DCNL DCSP return (filtered_exp_playlist_summaries, nonexistent_playlist_exp_ids)
 DCSP nonexistent_playlist_collection_ids = [] DCNL DCSP filtered_collection_playlist_summaries = [] DCNL DCSP for (index, collection_summary) in enumerate(collection_summaries): DCNL DCSP  DCSP if (collection_summary is None): DCNL DCSP  DCSP  DCSP nonexistent_playlist_collection_ids.append(collection_ids[index]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filtered_collection_playlist_summaries.append(collection_summary) DCNL DCSP return (filtered_collection_playlist_summaries, nonexistent_playlist_collection_ids)
 DCSP summary_dicts = [] DCNL DCSP for collection_summary in collection_summaries: DCNL DCSP  DCSP summary_dicts.append({'id': collection_summary.id, 'title': collection_summary.title, 'category': collection_summary.category, 'objective': collection_summary.objective, 'language_code': collection_summary.language_code, 'last_updated': utils.get_time_in_millisecs(collection_summary.collection_model_last_updated), 'created_on': utils.get_time_in_millisecs(collection_summary.collection_model_created_on), 'status': collection_summary.status, 'node_count': collection_summary.node_count, 'community_owned': collection_summary.community_owned, 'thumbnail_icon_url': utils.get_thumbnail_icon_url_for_category(collection_summary.category), 'thumbnail_bg_color': utils.get_hex_color_for_category(collection_summary.category)}) DCNL DCSP return summary_dicts
 DCSP learner_progress_models = datastore_services.fetch_multiple_entities_by_ids_and_models([('CompletedActivitiesModel', [user_id]), ('IncompleteActivitiesModel', [user_id]), ('LearnerPlaylistModel', [user_id])]) DCNL DCSP if learner_progress_models[0][0]: DCNL DCSP  DCSP activities_completed = _get_completed_activities_from_model(learner_progress_models[0][0]) DCNL DCSP  DCSP completed_exploration_ids = activities_completed.exploration_ids DCNL DCSP  DCSP completed_collection_ids = activities_completed.collection_ids DCNL DCSP else: DCNL DCSP  DCSP completed_collection_ids = [] DCNL DCSP  DCSP completed_exploration_ids = [] DCNL DCSP if learner_progress_models[1][0]: DCNL DCSP  DCSP incomplete_activities = _get_incomplete_activities_from_model(learner_progress_models[1][0]) DCNL DCSP  DCSP incomplete_exploration_ids = incomplete_activities.exploration_ids DCNL DCSP  DCSP incomplete_collection_ids = incomplete_activities.collection_ids DCNL DCSP else: DCNL DCSP  DCSP incomplete_exploration_ids = [] DCNL DCSP  DCSP incomplete_collection_ids = [] DCNL DCSP if learner_progress_models[2][0]: DCNL DCSP  DCSP learner_playlist = learner_playlist_services.get_learner_playlist_from_model(learner_progress_models[2][0]) DCNL DCSP  DCSP exploration_playlist_ids = learner_playlist.exploration_ids DCNL DCSP  DCSP collection_playlist_ids = learner_playlist.collection_ids DCNL DCSP else: DCNL DCSP  DCSP exploration_playlist_ids = [] DCNL DCSP  DCSP collection_playlist_ids = [] DCNL DCSP activity_models = datastore_services.fetch_multiple_entities_by_ids_and_models([('ExpSummaryModel', incomplete_exploration_ids), ('CollectionSummaryModel', incomplete_collection_ids), ('ExpSummaryModel', completed_exploration_ids), ('CollectionSummaryModel', completed_collection_ids), ('ExpSummaryModel', exploration_playlist_ids), ('CollectionSummaryModel', collection_playlist_ids)]) DCNL DCSP incomplete_exploration_models = activity_models[0] DCNL DCSP incomplete_collection_models = activity_models[1] DCNL DCSP completed_exploration_models = activity_models[2] DCNL DCSP completed_collection_models = activity_models[3] DCNL DCSP exploration_playlist_models = activity_models[4] DCNL DCSP collection_playlist_models = activity_models[5] DCNL DCSP incomplete_exp_summaries = [(exp_services.get_exploration_summary_from_model(model) if model else None) for model in incomplete_exploration_models] DCNL DCSP incomplete_collection_summaries = [(collection_services.get_collection_summary_from_model(model) if model else None) for model in incomplete_collection_models] DCNL DCSP completed_exp_summaries = [(exp_services.get_exploration_summary_from_model(model) if model else None) for model in completed_exploration_models] DCNL DCSP completed_collection_summaries = [(collection_services.get_collection_summary_from_model(model) if model else None) for model in completed_collection_models] DCNL DCSP exploration_playlist_summaries = [(exp_services.get_exploration_summary_from_model(model) if model else None) for model in exploration_playlist_models] DCNL DCSP collection_playlist_summaries = [(collection_services.get_collection_summary_from_model(model) if model else None) for model in collection_playlist_models] DCNL DCSP (filtered_incomplete_exp_summaries, nonexistent_incomplete_exp_ids) = _get_filtered_incomplete_exp_summaries(incomplete_exp_summaries, incomplete_exploration_ids) DCNL DCSP (filtered_completed_exp_summaries, nonexistent_completed_exp_ids) = _get_filtered_completed_exp_summaries(completed_exp_summaries, completed_exploration_ids) DCNL DCSP (filtered_completed_collection_summaries, nonexistent_completed_collection_ids, completed_to_incomplete_collection_summaries) = _get_filtered_completed_collection_summaries(user_id, completed_collection_summaries, completed_collection_ids) DCNL DCSP completed_to_incomplete_collection_titles = [] DCNL DCSP for collection_summary in completed_to_incomplete_collection_summaries: DCNL DCSP  DCSP incomplete_collection_summaries.append(collection_summary) DCNL DCSP  DCSP completed_to_incomplete_collection_titles.append(collection_summary.title) DCNL DCSP  DCSP incomplete_collection_ids.append(collection_summary.id) DCNL DCSP (filtered_incomplete_collection_summaries, nonexistent_incomplete_collection_ids) = _get_filtered_incomplete_collection_summaries(incomplete_collection_summaries, incomplete_collection_ids) DCNL DCSP (filtered_exp_playlist_summaries, nonexistent_playlist_exp_ids) = _get_filtered_exp_playlist_summaries(exploration_playlist_summaries, exploration_playlist_ids) DCNL DCSP (filtered_collection_playlist_summaries, nonexistent_playlist_collection_ids) = _get_filtered_collection_playlist_summaries(collection_playlist_summaries, collection_playlist_ids) DCNL DCSP number_of_deleted_activities = {'incomplete_explorations': len(nonexistent_incomplete_exp_ids), 'incomplete_collections': len(nonexistent_incomplete_collection_ids), 'completed_explorations': len(nonexistent_completed_exp_ids), 'completed_collections': len(nonexistent_completed_collection_ids), 'exploration_playlist': len(nonexistent_playlist_exp_ids), 'collection_playlist': len(nonexistent_playlist_collection_ids)} DCNL DCSP _remove_activity_ids_from_incomplete_list(user_id, nonexistent_incomplete_exp_ids, nonexistent_incomplete_collection_ids) DCNL DCSP _remove_activity_ids_from_completed_list(user_id, nonexistent_completed_exp_ids, nonexistent_completed_collection_ids) DCNL DCSP _remove_activity_ids_from_playlist(user_id, nonexistent_playlist_exp_ids, nonexistent_playlist_collection_ids) DCNL DCSP learner_progress = learner_progress_domain.LearnerProgress(filtered_incomplete_exp_summaries, filtered_incomplete_collection_summaries, filtered_completed_exp_summaries, filtered_completed_collection_summaries, filtered_exp_playlist_summaries, filtered_collection_playlist_summaries) DCNL DCSP return (learner_progress, number_of_deleted_activities, completed_to_incomplete_collection_titles)
 DCSP return user_domain.LearnerPlaylist(learner_playlist_model.id, learner_playlist_model.exploration_ids, learner_playlist_model.collection_ids)
 DCSP learner_playlist_model = user_models.LearnerPlaylistModel(id=learner_playlist.id, exploration_ids=learner_playlist.exploration_ids, collection_ids=learner_playlist.collection_ids) DCNL DCSP learner_playlist_model.put()
 DCSP learner_playlist_model = user_models.LearnerPlaylistModel.get(user_id, strict=False) DCNL DCSP if (not learner_playlist_model): DCNL DCSP  DCSP learner_playlist_model = user_models.LearnerPlaylistModel(id=user_id) DCNL DCSP subscribed_exploration_ids = subscription_services.get_exploration_ids_subscribed_to(user_id) DCNL DCSP learner_playlist = get_learner_playlist_from_model(learner_playlist_model) DCNL DCSP if (exploration_id not in subscribed_exploration_ids): DCNL DCSP  DCSP exploration_ids_count = len(learner_playlist.exploration_ids) DCNL DCSP  DCSP if (position_to_be_inserted is None): DCNL DCSP  DCSP  DCSP if (exploration_id not in learner_playlist.exploration_ids): DCNL DCSP  DCSP  DCSP  DCSP if (exploration_ids_count < MAX_LEARNER_PLAYLIST_ACTIVITY_COUNT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP learner_playlist.add_exploration_id_to_list(exploration_id) DCNL DCSP  DCSP elif (exploration_id not in learner_playlist.exploration_ids): DCNL DCSP  DCSP  DCSP if (exploration_ids_count < MAX_LEARNER_PLAYLIST_ACTIVITY_COUNT): DCNL DCSP  DCSP  DCSP  DCSP learner_playlist.insert_exploration_id_at_given_position(exploration_id, position_to_be_inserted) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP learner_playlist.remove_exploration_id(exploration_id) DCNL DCSP  DCSP  DCSP learner_playlist.insert_exploration_id_at_given_position(exploration_id, position_to_be_inserted) DCNL DCSP  DCSP save_learner_playlist(learner_playlist)
 DCSP learner_playlist_model = user_models.LearnerPlaylistModel.get(user_id, strict=False) DCNL DCSP if (not learner_playlist_model): DCNL DCSP  DCSP learner_playlist_model = user_models.LearnerPlaylistModel(id=user_id) DCNL DCSP subscribed_collection_ids = subscription_services.get_collection_ids_subscribed_to(user_id) DCNL DCSP learner_playlist = get_learner_playlist_from_model(learner_playlist_model) DCNL DCSP if (collection_id not in subscribed_collection_ids): DCNL DCSP  DCSP collection_ids_count = len(learner_playlist.collection_ids) DCNL DCSP  DCSP if (position_to_be_inserted is None): DCNL DCSP  DCSP  DCSP if (collection_id not in learner_playlist.collection_ids): DCNL DCSP  DCSP  DCSP  DCSP if (collection_ids_count < MAX_LEARNER_PLAYLIST_ACTIVITY_COUNT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP learner_playlist.add_collection_id_to_list(collection_id) DCNL DCSP  DCSP elif (collection_id not in learner_playlist.collection_ids): DCNL DCSP  DCSP  DCSP if (collection_ids_count < MAX_LEARNER_PLAYLIST_ACTIVITY_COUNT): DCNL DCSP  DCSP  DCSP  DCSP learner_playlist.insert_collection_id_at_given_position(collection_id, position_to_be_inserted) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP learner_playlist.remove_collection_id(collection_id) DCNL DCSP  DCSP  DCSP learner_playlist.insert_collection_id_at_given_position(collection_id, position_to_be_inserted) DCNL DCSP  DCSP save_learner_playlist(learner_playlist)
 DCSP learner_playlist_model = user_models.LearnerPlaylistModel.get(user_id, strict=False) DCNL DCSP if learner_playlist_model: DCNL DCSP  DCSP learner_playlist = get_learner_playlist_from_model(learner_playlist_model) DCNL DCSP  DCSP if (exploration_id in learner_playlist.exploration_ids): DCNL DCSP  DCSP  DCSP learner_playlist.remove_exploration_id(exploration_id) DCNL DCSP  DCSP  DCSP save_learner_playlist(learner_playlist)
 DCSP learner_playlist_model = user_models.LearnerPlaylistModel.get(user_id, strict=False) DCNL DCSP if learner_playlist_model: DCNL DCSP  DCSP learner_playlist = get_learner_playlist_from_model(learner_playlist_model) DCNL DCSP  DCSP if (collection_id in learner_playlist.collection_ids): DCNL DCSP  DCSP  DCSP learner_playlist.remove_collection_id(collection_id) DCNL DCSP  DCSP  DCSP save_learner_playlist(learner_playlist)
 DCSP learner_playlist_model = user_models.LearnerPlaylistModel.get(user_id, strict=False) DCNL DCSP if learner_playlist_model: DCNL DCSP  DCSP learner_playlist = get_learner_playlist_from_model(learner_playlist_model) DCNL DCSP  DCSP return learner_playlist.exploration_ids DCNL DCSP else: DCNL DCSP  DCSP return []
 DCSP learner_playlist_model = user_models.LearnerPlaylistModel.get(user_id, strict=False) DCNL DCSP if learner_playlist_model: DCNL DCSP  DCSP learner_playlist = get_learner_playlist_from_model(learner_playlist_model) DCNL DCSP  DCSP return learner_playlist.collection_ids DCNL DCSP else: DCNL DCSP  DCSP return []
 DCSP query_model = user_models.UserQueryModel.get(query_id) DCNL DCSP query_model.query_status = feconf.USER_QUERY_STATUS_ARCHIVED DCNL DCSP recipient_ids = query_model.user_ids DCNL DCSP if max_recipients: DCNL DCSP  DCSP recipient_ids = recipient_ids[:max_recipients] DCNL DCSP bulk_email_model_id = email_manager.send_user_query_email(query_model.submitter_id, recipient_ids, email_subject, email_body, email_intent) DCNL DCSP query_model.sent_email_model_id = bulk_email_model_id DCNL DCSP query_model.put() DCNL DCSP for recipient_id in recipient_ids: DCNL DCSP  DCSP recipient_bulk_email_model = user_models.UserBulkEmailsModel.get(recipient_id, strict=False) DCNL DCSP  DCSP if (recipient_bulk_email_model is None): DCNL DCSP  DCSP  DCSP recipient_bulk_email_model = user_models.UserBulkEmailsModel(id=recipient_id, sent_email_model_ids=[]) DCNL DCSP  DCSP recipient_bulk_email_model.sent_email_model_ids.append(bulk_email_model_id) DCNL DCSP  DCSP recipient_bulk_email_model.put()
 DCSP states_schema_version = versioned_exploration_states['states_schema_version'] DCNL DCSP if ((states_schema_version is None) or (states_schema_version < 1)): DCNL DCSP  DCSP states_schema_version = 0 DCNL DCSP if (not (0 <= states_schema_version <= feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION)): DCNL DCSP  DCSP raise Exception(('Sorry, DCSP we DCSP can DCSP only DCSP process DCSP v1-v%d DCSP and DCSP unversioned DCSP exploration DCSP state DCSP schemas DCSP at DCSP present.' % feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION)) DCNL DCSP while (states_schema_version < feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION): DCNL DCSP  DCSP exp_domain.Exploration.update_states_from_model(versioned_exploration_states, states_schema_version) DCNL DCSP  DCSP states_schema_version += 1
 DCSP if version: DCNL DCSP  DCSP return ('exploration-version:%s:%s' % (exploration_id, version)) DCNL DCSP else: DCNL DCSP  DCSP return ('exploration:%s' % exploration_id)
 DCSP versioned_exploration_states = {'states_schema_version': exploration_model.states_schema_version, 'states': copy.deepcopy(exploration_model.states)} DCNL DCSP if (run_conversion and (exploration_model.states_schema_version != feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION)): DCNL DCSP  DCSP _migrate_states_schema(versioned_exploration_states) DCNL DCSP return exp_domain.Exploration(exploration_model.id, exploration_model.title, exploration_model.category, exploration_model.objective, exploration_model.language_code, exploration_model.tags, exploration_model.blurb, exploration_model.author_notes, exploration_model.skin_customizations, versioned_exploration_states['states_schema_version'], exploration_model.init_state_name, versioned_exploration_states['states'], exploration_model.param_specs, exploration_model.param_changes, exploration_model.version, created_on=exploration_model.created_on, last_updated=exploration_model.last_updated)
 DCSP return exp_domain.ExplorationSummary(exp_summary_model.id, exp_summary_model.title, exp_summary_model.category, exp_summary_model.objective, exp_summary_model.language_code, exp_summary_model.tags, exp_summary_model.ratings, exp_summary_model.scaled_average_rating, exp_summary_model.status, exp_summary_model.community_owned, exp_summary_model.owner_ids, exp_summary_model.editor_ids, exp_summary_model.viewer_ids, exp_summary_model.contributor_ids, exp_summary_model.contributors_summary, exp_summary_model.version, exp_summary_model.exploration_model_created_on, exp_summary_model.exploration_model_last_updated, exp_summary_model.first_published_msec)
 DCSP exploration_memcache_key = _get_exploration_memcache_key(exploration_id, version=version) DCNL DCSP memcached_exploration = memcache_services.get_multi([exploration_memcache_key]).get(exploration_memcache_key) DCNL DCSP if (memcached_exploration is not None): DCNL DCSP  DCSP return memcached_exploration DCNL DCSP else: DCNL DCSP  DCSP exploration_model = exp_models.ExplorationModel.get(exploration_id, strict=strict, version=version) DCNL DCSP  DCSP if exploration_model: DCNL DCSP  DCSP  DCSP exploration = get_exploration_from_model(exploration_model) DCNL DCSP  DCSP  DCSP memcache_services.set_multi({exploration_memcache_key: exploration}) DCNL DCSP  DCSP  DCSP return exploration DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None
 DCSP exp_summary_model = exp_models.ExpSummaryModel.get(exploration_id) DCNL DCSP if exp_summary_model: DCNL DCSP  DCSP exp_summary = get_exploration_summary_from_model(exp_summary_model) DCNL DCSP  DCSP return exp_summary DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP exp_ids = set(exp_ids) DCNL DCSP result = {} DCNL DCSP uncached = [] DCNL DCSP memcache_keys = [_get_exploration_memcache_key(i) for i in exp_ids] DCNL DCSP cache_result = memcache_services.get_multi(memcache_keys) DCNL DCSP for exp_obj in cache_result.itervalues(): DCNL DCSP  DCSP result[exp_obj.id] = exp_obj DCNL DCSP for _id in exp_ids: DCNL DCSP  DCSP if (_id not in result): DCNL DCSP  DCSP  DCSP uncached.append(_id) DCNL DCSP db_exp_models = exp_models.ExplorationModel.get_multi(uncached) DCNL DCSP db_results_dict = {} DCNL DCSP not_found = [] DCNL DCSP for (i, eid) in enumerate(uncached): DCNL DCSP  DCSP model = db_exp_models[i] DCNL DCSP  DCSP if model: DCNL DCSP  DCSP  DCSP exploration = get_exploration_from_model(model) DCNL DCSP  DCSP  DCSP db_results_dict[eid] = exploration DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.info(('Tried DCSP to DCSP fetch DCSP exploration DCSP with DCSP id DCSP %s, DCSP but DCSP no DCSP such DCSP exploration DCSP exists DCSP in DCSP the DCSP datastore' % eid)) DCNL DCSP  DCSP  DCSP not_found.append(eid) DCNL DCSP if (strict and not_found): DCNL DCSP  DCSP raise ValueError(("Couldn't DCSP find DCSP explorations DCSP with DCSP the DCSP following DCSP ids:\n%s" % '\n'.join(not_found))) DCNL DCSP cache_update = {eid: db_results_dict[eid] for eid in db_results_dict.iterkeys() if (db_results_dict[eid] is not None)} DCNL DCSP if cache_update: DCNL DCSP  DCSP memcache_services.set_multi(cache_update) DCNL DCSP result.update(db_results_dict) DCNL DCSP return result
 DCSP return exp_models.ExplorationModel.get_new_id('')
 DCSP return ((user_id is not None) and ((user_id in exp_summary.editor_ids) or (user_id in exp_summary.owner_ids) or exp_summary.community_owned))
 DCSP explorations = [(get_exploration_from_model(e) if e else None) for e in exp_models.ExplorationModel.get_multi(exp_ids)] DCNL DCSP result = {} DCNL DCSP for exploration in explorations: DCNL DCSP  DCSP if (exploration is None): DCNL DCSP  DCSP  DCSP logging.error('Could DCSP not DCSP find DCSP exploration DCSP corresponding DCSP to DCSP id') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result[exploration.id] = {'title': exploration.title, 'category': exploration.category} DCNL DCSP return result
 DCSP exploration_summaries = [get_exploration_summary_from_model(exp_summary_model) for exp_summary_model in exp_summary_models] DCNL DCSP result = {} DCNL DCSP for exp_summary in exploration_summaries: DCNL DCSP  DCSP result[exp_summary.id] = exp_summary DCNL DCSP return result
 DCSP return [(get_exploration_summary_from_model(model) if model else None) for model in exp_models.ExpSummaryModel.get_multi(exp_ids)]
 DCSP returned_exploration_ids = [] DCNL DCSP search_cursor = cursor DCNL DCSP for _ in range(MAX_ITERATIONS): DCNL DCSP  DCSP remaining_to_fetch = (feconf.SEARCH_RESULTS_PAGE_SIZE - len(returned_exploration_ids)) DCNL DCSP  DCSP (exp_ids, search_cursor) = search_explorations(query_string, remaining_to_fetch, cursor=search_cursor) DCNL DCSP  DCSP invalid_exp_ids = [] DCNL DCSP  DCSP for (ind, model) in enumerate(exp_models.ExpSummaryModel.get_multi(exp_ids)): DCNL DCSP  DCSP  DCSP if (model is not None): DCNL DCSP  DCSP  DCSP  DCSP returned_exploration_ids.append(exp_ids[ind]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP invalid_exp_ids.append(exp_ids[ind]) DCNL DCSP  DCSP if ((len(returned_exploration_ids) == feconf.SEARCH_RESULTS_PAGE_SIZE) or (search_cursor is None)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.error(('Search DCSP index DCSP contains DCSP stale DCSP exploration DCSP ids: DCSP %s' % ', DCSP '.join(invalid_exp_ids))) DCNL DCSP if ((len(returned_exploration_ids) < feconf.SEARCH_RESULTS_PAGE_SIZE) and (search_cursor is not None)): DCNL DCSP  DCSP logging.error(('Could DCSP not DCSP fulfill DCSP search DCSP request DCSP for DCSP query DCSP string DCSP %s; DCSP at DCSP least DCSP %s DCSP retries DCSP were DCSP needed.' % (query_string, MAX_ITERATIONS))) DCNL DCSP return (returned_exploration_ids, search_cursor)
 DCSP return _get_exploration_summaries_from_models(exp_models.ExpSummaryModel.get_non_private())
 DCSP return _get_exploration_summaries_from_models(exp_models.ExpSummaryModel.get_top_rated(limit))
 DCSP return _get_exploration_summaries_from_models(exp_models.ExpSummaryModel.get_recently_published(limit))
 DCSP return _get_exploration_summaries_from_models(exp_models.ExpSummaryModel.get_all())
 DCSP exploration = get_exploration_by_id(exploration_id, version=version) DCNL DCSP yaml_repr = exploration.to_yaml() DCNL DCSP memfile = StringIO.StringIO() DCNL DCSP with zipfile.ZipFile(memfile, mode='w', compression=zipfile.ZIP_DEFLATED) as zfile: DCNL DCSP  DCSP zfile.writestr(('%s.yaml' % exploration.title), yaml_repr) DCNL DCSP  DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(exploration_id)) DCNL DCSP  DCSP dir_list = fs.listdir('') DCNL DCSP  DCSP for filepath in dir_list: DCNL DCSP  DCSP  DCSP file_contents = fs.get(filepath, version=1) DCNL DCSP  DCSP  DCSP str_filepath = ('assets/%s' % filepath) DCNL DCSP  DCSP  DCSP assert isinstance(str_filepath, str) DCNL DCSP  DCSP  DCSP unicode_filepath = str_filepath.decode('utf-8') DCNL DCSP  DCSP  DCSP zfile.writestr(unicode_filepath, file_contents) DCNL DCSP return memfile.getvalue()
 DCSP try: DCNL DCSP  DCSP state = exp_domain.State.from_dict(state_dict) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.info(('Bad DCSP state DCSP dict: DCSP %s' % str(state_dict))) DCNL DCSP  DCSP raise Exception('Could DCSP not DCSP convert DCSP state DCSP dict DCSP to DCSP YAML.') DCNL DCSP return utils.yaml_from_dict(state.to_dict(), width=width)
 DCSP exploration = get_exploration_by_id(exploration_id, version=version) DCNL DCSP exploration_dict = {} DCNL DCSP for state in exploration.states: DCNL DCSP  DCSP exploration_dict[state] = utils.yaml_from_dict(exploration.states[state].to_dict(), width=width) DCNL DCSP return exploration_dict
 DCSP exploration = get_exploration_by_id(exploration_id) DCNL DCSP try: DCNL DCSP  DCSP changes = [exp_domain.ExplorationChange(change_dict) for change_dict in change_list] DCNL DCSP  DCSP for change in changes: DCNL DCSP  DCSP  DCSP if (change.cmd == exp_domain.CMD_ADD_STATE): DCNL DCSP  DCSP  DCSP  DCSP exploration.add_states([change.state_name]) DCNL DCSP  DCSP  DCSP elif (change.cmd == exp_domain.CMD_RENAME_STATE): DCNL DCSP  DCSP  DCSP  DCSP exploration.rename_state(change.old_state_name, change.new_state_name) DCNL DCSP  DCSP  DCSP elif (change.cmd == exp_domain.CMD_DELETE_STATE): DCNL DCSP  DCSP  DCSP  DCSP exploration.delete_state(change.state_name) DCNL DCSP  DCSP  DCSP elif (change.cmd == exp_domain.CMD_EDIT_STATE_PROPERTY): DCNL DCSP  DCSP  DCSP  DCSP state = exploration.states[change.state_name] DCNL DCSP  DCSP  DCSP  DCSP if (change.property_name == exp_domain.STATE_PROPERTY_PARAM_CHANGES): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_param_changes(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_CONTENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_content(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_INTERACTION_ID): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_interaction_id(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_INTERACTION_CUST_ARGS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_interaction_customization_args(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_INTERACTION_HANDLERS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise utils.InvalidInputException('Editing DCSP interaction DCSP handlers DCSP is DCSP no DCSP longer DCSP supported') DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_INTERACTION_ANSWER_GROUPS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_interaction_answer_groups(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_INTERACTION_DEFAULT_OUTCOME): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_interaction_default_outcome(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_UNCLASSIFIED_ANSWERS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_interaction_confirmed_unclassified_answers(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_INTERACTION_FALLBACKS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_interaction_fallbacks(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_INTERACTION_HINTS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_interaction_hints(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.STATE_PROPERTY_INTERACTION_SOLUTION): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state.update_interaction_solution(change.new_value) DCNL DCSP  DCSP  DCSP elif (change.cmd == exp_domain.CMD_ADD_GADGET): DCNL DCSP  DCSP  DCSP  DCSP exploration.add_gadget(change.gadget_dict, change.panel) DCNL DCSP  DCSP  DCSP elif (change.cmd == exp_domain.CMD_RENAME_GADGET): DCNL DCSP  DCSP  DCSP  DCSP exploration.rename_gadget(change.old_gadget_name, change.new_gadget_name) DCNL DCSP  DCSP  DCSP elif (change.cmd == exp_domain.CMD_DELETE_GADGET): DCNL DCSP  DCSP  DCSP  DCSP exploration.delete_gadget(change.gadget_name) DCNL DCSP  DCSP  DCSP elif (change.cmd == exp_domain.CMD_EDIT_GADGET_PROPERTY): DCNL DCSP  DCSP  DCSP  DCSP gadget_instance = exploration.get_gadget_instance_by_name(change.gadget_name) DCNL DCSP  DCSP  DCSP  DCSP if (change.property_name == exp_domain.GADGET_PROPERTY_VISIBILITY): DCNL DCSP  DCSP  DCSP  DCSP  DCSP gadget_instance.update_visible_in_states(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == exp_domain.GADGET_PROPERTY_CUST_ARGS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP gadget_instance.update_customization_args(change.new_value) DCNL DCSP  DCSP  DCSP elif (change.cmd == exp_domain.CMD_EDIT_EXPLORATION_PROPERTY): DCNL DCSP  DCSP  DCSP  DCSP if (change.property_name == 'title'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_title(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == 'category'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_category(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == 'objective'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_objective(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == 'language_code'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_language_code(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == 'tags'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_tags(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == 'blurb'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_blurb(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == 'author_notes'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_author_notes(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == 'param_specs'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_param_specs(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == 'param_changes'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_param_changes(change.new_value) DCNL DCSP  DCSP  DCSP  DCSP elif (change.property_name == 'init_state_name'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exploration.update_init_state_name(change.new_value) DCNL DCSP  DCSP  DCSP elif (change.cmd == exp_domain.CMD_MIGRATE_STATES_SCHEMA_TO_LATEST_VERSION): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP return exploration DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.error(('%s DCSP %s DCSP %s DCSP %s' % (e.__class__.__name__, e, exploration_id, pprint.pprint(change_list)))) DCNL DCSP  DCSP raise
 DCSP if (change_list is None): DCNL DCSP  DCSP change_list = [] DCNL DCSP exploration_rights = rights_manager.get_exploration_rights(exploration.id) DCNL DCSP if (exploration_rights.status != rights_manager.ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP exploration.validate(strict=True) DCNL DCSP else: DCNL DCSP  DCSP exploration.validate() DCNL DCSP exploration_model = exp_models.ExplorationModel.get(exploration.id, strict=False) DCNL DCSP if (exploration_model is None): DCNL DCSP  DCSP exploration_model = exp_models.ExplorationModel(id=exploration.id) DCNL DCSP elif (exploration.version > exploration_model.version): DCNL DCSP  DCSP raise Exception(('Unexpected DCSP error: DCSP trying DCSP to DCSP update DCSP version DCSP %s DCSP of DCSP exploration DCSP from DCSP version DCSP %s. DCSP Please DCSP reload DCSP the DCSP page DCSP and DCSP try DCSP again.' % (exploration_model.version, exploration.version))) DCNL DCSP elif (exploration.version < exploration_model.version): DCNL DCSP  DCSP raise Exception(('Trying DCSP to DCSP update DCSP version DCSP %s DCSP of DCSP exploration DCSP from DCSP version DCSP %s, DCSP which DCSP is DCSP too DCSP old. DCSP Please DCSP reload DCSP the DCSP page DCSP and DCSP try DCSP again.' % (exploration_model.version, exploration.version))) DCNL DCSP old_states = get_exploration_from_model(exploration_model).states DCNL DCSP exploration_model.category = exploration.category DCNL DCSP exploration_model.title = exploration.title DCNL DCSP exploration_model.objective = exploration.objective DCNL DCSP exploration_model.language_code = exploration.language_code DCNL DCSP exploration_model.tags = exploration.tags DCNL DCSP exploration_model.blurb = exploration.blurb DCNL DCSP exploration_model.author_notes = exploration.author_notes DCNL DCSP exploration_model.skin_customizations = exploration.skin_instance.to_dict()['skin_customizations'] DCNL DCSP exploration_model.states_schema_version = exploration.states_schema_version DCNL DCSP exploration_model.init_state_name = exploration.init_state_name DCNL DCSP exploration_model.states = {state_name: state.to_dict() for (state_name, state) in exploration.states.iteritems()} DCNL DCSP exploration_model.param_specs = exploration.param_specs_dict DCNL DCSP exploration_model.param_changes = exploration.param_change_dicts DCNL DCSP exploration_model.commit(committer_id, commit_message, change_list) DCNL DCSP memcache_services.delete(_get_exploration_memcache_key(exploration.id)) DCNL DCSP index_explorations_given_ids([exploration.id]) DCNL DCSP exploration.version += 1 DCNL DCSP if feconf.ENABLE_ML_CLASSIFIERS: DCNL DCSP  DCSP new_to_old_state_names = exploration.get_state_names_mapping(change_list) DCNL DCSP  DCSP trainable_states_dict = exploration.get_trainable_states_dict(old_states, new_to_old_state_names) DCNL DCSP  DCSP state_names_with_changed_answer_groups = trainable_states_dict['state_names_with_changed_answer_groups'] DCNL DCSP  DCSP state_names_with_unchanged_answer_groups = trainable_states_dict['state_names_with_unchanged_answer_groups'] DCNL DCSP  DCSP if state_names_with_changed_answer_groups: DCNL DCSP  DCSP  DCSP classifier_services.handle_trainable_states(exploration, state_names_with_changed_answer_groups) DCNL DCSP  DCSP if state_names_with_unchanged_answer_groups: DCNL DCSP  DCSP  DCSP classifier_services.handle_non_retrainable_states(exploration, state_names_with_unchanged_answer_groups, new_to_old_state_names)
 DCSP exploration.validate() DCNL DCSP rights_manager.create_new_exploration_rights(exploration.id, committer_id) DCNL DCSP model = exp_models.ExplorationModel(id=exploration.id, category=exploration.category, title=exploration.title, objective=exploration.objective, language_code=exploration.language_code, tags=exploration.tags, blurb=exploration.blurb, author_notes=exploration.author_notes, skin_customizations=exploration.skin_instance.to_dict()['skin_customizations'], states_schema_version=exploration.states_schema_version, init_state_name=exploration.init_state_name, states={state_name: state.to_dict() for (state_name, state) in exploration.states.iteritems()}, param_specs=exploration.param_specs_dict, param_changes=exploration.param_change_dicts) DCNL DCSP model.commit(committer_id, commit_message, commit_cmds) DCNL DCSP exploration.version += 1 DCNL DCSP if feconf.ENABLE_ML_CLASSIFIERS: DCNL DCSP  DCSP state_names_to_train = [] DCNL DCSP  DCSP for state_name in exploration.states: DCNL DCSP  DCSP  DCSP state = exploration.states[state_name] DCNL DCSP  DCSP  DCSP if state.can_undergo_classification(): DCNL DCSP  DCSP  DCSP  DCSP state_names_to_train.append(state_name) DCNL DCSP  DCSP if state_names_to_train: DCNL DCSP  DCSP  DCSP classifier_services.handle_trainable_states(exploration, state_names_to_train) DCNL DCSP create_exploration_summary(exploration.id, committer_id)
 DCSP commit_message = (("New DCSP exploration DCSP created DCSP with DCSP title DCSP '%s'." % exploration.title) if exploration.title else 'New DCSP exploration DCSP created.') DCNL DCSP _create_exploration(committer_id, exploration, commit_message, [{'cmd': CMD_CREATE_NEW, 'title': exploration.title, 'category': exploration.category}]) DCNL DCSP user_services.add_created_exploration_id(committer_id, exploration.id) DCNL DCSP user_services.add_edited_exploration_id(committer_id, exploration.id) DCNL DCSP user_services.record_user_created_an_exploration(committer_id)
 DCSP exploration_rights_model = exp_models.ExplorationRightsModel.get(exploration_id) DCNL DCSP exploration_rights_model.delete(committer_id, '', force_deletion=force_deletion) DCNL DCSP exploration_model = exp_models.ExplorationModel.get(exploration_id) DCNL DCSP exploration_model.delete(committer_id, feconf.COMMIT_MESSAGE_EXPLORATION_DELETED, force_deletion=force_deletion) DCNL DCSP exploration_memcache_key = _get_exploration_memcache_key(exploration_id) DCNL DCSP memcache_services.delete(exploration_memcache_key) DCNL DCSP delete_documents_from_search_index([exploration_id]) DCNL DCSP delete_exploration_summary(exploration_id) DCNL DCSP activity_services.remove_featured_activity(constants.ACTIVITY_TYPE_EXPLORATION, exploration_id)
 DCSP exploration = get_exploration_by_id(exploration_id) DCNL DCSP current_version = exploration.version DCNL DCSP version_nums = range(1, (current_version + 1)) DCNL DCSP return exp_models.ExplorationModel.get_snapshots_metadata(exploration_id, version_nums, allow_deleted=allow_deleted)
 DCSP last_human_update_ms = 0 DCNL DCSP snapshots_metadata = get_exploration_snapshots_metadata(exp_id) DCNL DCSP for snapshot_metadata in reversed(snapshots_metadata): DCNL DCSP  DCSP if (snapshot_metadata['committer_id'] != feconf.MIGRATION_BOT_USER_ID): DCNL DCSP  DCSP  DCSP last_human_update_ms = snapshot_metadata['created_on_ms'] DCNL DCSP  DCSP  DCSP break DCNL DCSP return last_human_update_ms
 DCSP rights_manager.publish_exploration(committer_id, exp_id) DCNL DCSP exp_title = get_exploration_by_id(exp_id).title DCNL DCSP email_subscription_services.inform_subscribers(committer_id, exp_id, exp_title) DCNL DCSP contribution_time_msec = utils.get_current_time_in_millisecs() DCNL DCSP contributor_ids = get_exploration_summary_by_id(exp_id).contributor_ids DCNL DCSP for contributor in contributor_ids: DCNL DCSP  DCSP user_services.update_first_contribution_msec_if_not_set(contributor, contribution_time_msec)
 DCSP is_public = rights_manager.is_exploration_public(exploration_id) DCNL DCSP if (is_public and (not commit_message)): DCNL DCSP  DCSP raise ValueError('Exploration DCSP is DCSP public DCSP so DCSP expected DCSP a DCSP commit DCSP message DCSP but DCSP received DCSP none.') DCNL DCSP if (is_suggestion and ((not commit_message) or (not commit_message.startswith(feconf.COMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX)))): DCNL DCSP  DCSP raise ValueError('Invalid DCSP commit DCSP message DCSP for DCSP suggestion.') DCNL DCSP if ((not is_suggestion) and commit_message and commit_message.startswith(feconf.COMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX)): DCNL DCSP  DCSP raise ValueError(("Commit DCSP messages DCSP for DCSP non-suggestions DCSP may DCSP not DCSP start DCSP with DCSP '%s'" % feconf.COMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX)) DCNL DCSP exploration = apply_change_list(exploration_id, change_list) DCNL DCSP _save_exploration(committer_id, exploration, commit_message, change_list) DCNL DCSP discard_draft(exploration_id, committer_id) DCNL DCSP update_exploration_summary(exploration.id, committer_id) DCNL DCSP user_services.add_edited_exploration_id(committer_id, exploration.id) DCNL DCSP user_services.record_user_edited_an_exploration(committer_id) DCNL DCSP if ((not rights_manager.is_exploration_private(exploration.id)) and (committer_id != feconf.MIGRATION_BOT_USER_ID)): DCNL DCSP  DCSP user_services.update_first_contribution_msec_if_not_set(committer_id, utils.get_current_time_in_millisecs())
 DCSP exploration = get_exploration_by_id(exploration_id) DCNL DCSP exp_summary = compute_summary_of_exploration(exploration, contributor_id_to_add) DCNL DCSP save_exploration_summary(exp_summary)
 DCSP exploration = get_exploration_by_id(exploration_id) DCNL DCSP exp_summary = compute_summary_of_exploration(exploration, contributor_id_to_add) DCNL DCSP save_exploration_summary(exp_summary)
 DCSP exp_rights = exp_models.ExplorationRightsModel.get_by_id(exploration.id) DCNL DCSP exp_summary_model = exp_models.ExpSummaryModel.get_by_id(exploration.id) DCNL DCSP if exp_summary_model: DCNL DCSP  DCSP old_exp_summary = get_exploration_summary_from_model(exp_summary_model) DCNL DCSP  DCSP ratings = (old_exp_summary.ratings or feconf.get_empty_ratings()) DCNL DCSP  DCSP scaled_average_rating = get_scaled_average_rating(old_exp_summary.ratings) DCNL DCSP  DCSP contributor_ids = (old_exp_summary.contributor_ids or []) DCNL DCSP  DCSP contributors_summary = (old_exp_summary.contributors_summary or {}) DCNL DCSP else: DCNL DCSP  DCSP ratings = feconf.get_empty_ratings() DCNL DCSP  DCSP scaled_average_rating = feconf.EMPTY_SCALED_AVERAGE_RATING DCNL DCSP  DCSP contributor_ids = [] DCNL DCSP  DCSP contributors_summary = {} DCNL DCSP if ((contributor_id_to_add is not None) and (contributor_id_to_add not in feconf.SYSTEM_USER_IDS)): DCNL DCSP  DCSP if (contributor_id_to_add not in contributor_ids): DCNL DCSP  DCSP  DCSP contributor_ids.append(contributor_id_to_add) DCNL DCSP if (contributor_id_to_add not in feconf.SYSTEM_USER_IDS): DCNL DCSP  DCSP if (contributor_id_to_add is None): DCNL DCSP  DCSP  DCSP contributors_summary = compute_exploration_contributors_summary(exploration.id) DCNL DCSP  DCSP elif (contributor_id_to_add in contributors_summary): DCNL DCSP  DCSP  DCSP contributors_summary[contributor_id_to_add] += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP contributors_summary[contributor_id_to_add] = 1 DCNL DCSP exploration_model_last_updated = datetime.datetime.fromtimestamp((_get_last_updated_by_human_ms(exploration.id) / 1000.0)) DCNL DCSP exploration_model_created_on = exploration.created_on DCNL DCSP first_published_msec = exp_rights.first_published_msec DCNL DCSP exp_summary = exp_domain.ExplorationSummary(exploration.id, exploration.title, exploration.category, exploration.objective, exploration.language_code, exploration.tags, ratings, scaled_average_rating, exp_rights.status, exp_rights.community_owned, exp_rights.owner_ids, exp_rights.editor_ids, exp_rights.viewer_ids, contributor_ids, contributors_summary, exploration.version, exploration_model_created_on, exploration_model_last_updated, first_published_msec) DCNL DCSP return exp_summary
 DCSP snapshots_metadata = get_exploration_snapshots_metadata(exploration_id) DCNL DCSP current_version = len(snapshots_metadata) DCNL DCSP contributors_summary = collections.defaultdict(int) DCNL DCSP while True: DCNL DCSP  DCSP snapshot_metadata = snapshots_metadata[(current_version - 1)] DCNL DCSP  DCSP committer_id = snapshot_metadata['committer_id'] DCNL DCSP  DCSP is_revert = (snapshot_metadata['commit_type'] == 'revert') DCNL DCSP  DCSP if ((not is_revert) and (committer_id not in feconf.SYSTEM_USER_IDS)): DCNL DCSP  DCSP  DCSP contributors_summary[committer_id] += 1 DCNL DCSP  DCSP if (current_version == 1): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if is_revert: DCNL DCSP  DCSP  DCSP current_version = snapshot_metadata['commit_cmds'][0]['version_number'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP current_version -= 1 DCNL DCSP return contributors_summary
 DCSP exp_summary_model = exp_models.ExpSummaryModel(id=exp_summary.id, title=exp_summary.title, category=exp_summary.category, objective=exp_summary.objective, language_code=exp_summary.language_code, tags=exp_summary.tags, ratings=exp_summary.ratings, scaled_average_rating=exp_summary.scaled_average_rating, status=exp_summary.status, community_owned=exp_summary.community_owned, owner_ids=exp_summary.owner_ids, editor_ids=exp_summary.editor_ids, viewer_ids=exp_summary.viewer_ids, contributor_ids=exp_summary.contributor_ids, contributors_summary=exp_summary.contributors_summary, version=exp_summary.version, exploration_model_last_updated=exp_summary.exploration_model_last_updated, exploration_model_created_on=exp_summary.exploration_model_created_on, first_published_msec=exp_summary.first_published_msec) DCNL DCSP exp_summary_model.put()
 DCSP exp_models.ExpSummaryModel.get(exploration_id).delete()
 DCSP exploration_model = exp_models.ExplorationModel.get(exploration_id, strict=False) DCNL DCSP if (current_version > exploration_model.version): DCNL DCSP  DCSP raise Exception(('Unexpected DCSP error: DCSP trying DCSP to DCSP update DCSP version DCSP %s DCSP of DCSP exploration DCSP from DCSP version DCSP %s. DCSP Please DCSP reload DCSP the DCSP page DCSP and DCSP try DCSP again.' % (exploration_model.version, current_version))) DCNL DCSP elif (current_version < exploration_model.version): DCNL DCSP  DCSP raise Exception(('Trying DCSP to DCSP update DCSP version DCSP %s DCSP of DCSP exploration DCSP from DCSP version DCSP %s, DCSP which DCSP is DCSP too DCSP old. DCSP Please DCSP reload DCSP the DCSP page DCSP and DCSP try DCSP again.' % (exploration_model.version, current_version))) DCNL DCSP exploration = get_exploration_by_id(exploration_id, version=revert_to_version) DCNL DCSP exploration_rights = rights_manager.get_exploration_rights(exploration.id) DCNL DCSP if (exploration_rights.status != rights_manager.ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP exploration.validate(strict=True) DCNL DCSP else: DCNL DCSP  DCSP exploration.validate() DCNL DCSP exp_models.ExplorationModel.revert(exploration_model, committer_id, ('Reverted DCSP exploration DCSP to DCSP version DCSP %s' % revert_to_version), revert_to_version) DCNL DCSP memcache_services.delete(_get_exploration_memcache_key(exploration_id)) DCNL DCSP update_exploration_summary(exploration_id, None)
 DCSP demo_filepath = os.path.join(feconf.SAMPLE_EXPLORATIONS_DIR, demo_path) DCNL DCSP if demo_filepath.endswith('yaml'): DCNL DCSP  DCSP file_contents = utils.get_file_contents(demo_filepath) DCNL DCSP  DCSP return (file_contents, []) DCNL DCSP elif os.path.isdir(demo_filepath): DCNL DCSP  DCSP return utils.get_exploration_components_from_dir(demo_filepath) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unrecognized DCSP file DCSP path: DCSP %s' % demo_path))
 DCSP if (assets_list is None): DCNL DCSP  DCSP assets_list = [] DCNL DCSP yaml_dict = utils.dict_from_yaml(yaml_content) DCNL DCSP if ('schema_version' not in yaml_dict): DCNL DCSP  DCSP raise Exception('Invalid DCSP YAML DCSP file: DCSP missing DCSP schema DCSP version') DCNL DCSP exp_schema_version = yaml_dict['schema_version'] DCNL DCSP if (exp_schema_version <= exp_domain.Exploration.LAST_UNTITLED_SCHEMA_VERSION): DCNL DCSP  DCSP exploration = exp_domain.Exploration.from_untitled_yaml(exploration_id, feconf.DEFAULT_EXPLORATION_TITLE, feconf.DEFAULT_EXPLORATION_CATEGORY, yaml_content) DCNL DCSP else: DCNL DCSP  DCSP exploration = exp_domain.Exploration.from_yaml(exploration_id, yaml_content) DCNL DCSP commit_message = ("New DCSP exploration DCSP created DCSP from DCSP YAML DCSP file DCSP with DCSP title DCSP '%s'." % exploration.title) DCNL DCSP _create_exploration(committer_id, exploration, commit_message, [{'cmd': CMD_CREATE_NEW, 'title': exploration.title, 'category': exploration.category}]) DCNL DCSP for (asset_filename, asset_content) in assets_list: DCNL DCSP  DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(exploration_id)) DCNL DCSP  DCSP fs.commit(committer_id, asset_filename, asset_content)
 DCSP if (not exp_domain.Exploration.is_demo_exploration_id(exploration_id)): DCNL DCSP  DCSP raise Exception(('Invalid DCSP demo DCSP exploration DCSP id DCSP %s' % exploration_id)) DCNL DCSP exploration = get_exploration_by_id(exploration_id, strict=False) DCNL DCSP if (not exploration): DCNL DCSP  DCSP logging.info(('Exploration DCSP with DCSP id DCSP %s DCSP was DCSP not DCSP deleted, DCSP because DCSP it DCSP does DCSP not DCSP exist.' % exploration_id)) DCNL DCSP else: DCNL DCSP  DCSP delete_exploration(feconf.SYSTEM_COMMITTER_ID, exploration_id, force_deletion=True)
 DCSP delete_demo(exploration_id) DCNL DCSP if (not exp_domain.Exploration.is_demo_exploration_id(exploration_id)): DCNL DCSP  DCSP raise Exception(('Invalid DCSP demo DCSP exploration DCSP id DCSP %s' % exploration_id)) DCNL DCSP exp_filename = feconf.DEMO_EXPLORATIONS[exploration_id] DCNL DCSP (yaml_content, assets_list) = get_demo_exploration_components(exp_filename) DCNL DCSP save_new_exploration_from_yaml_and_assets(feconf.SYSTEM_COMMITTER_ID, yaml_content, exploration_id, assets_list) DCNL DCSP publish_exploration_and_update_user_profiles(feconf.SYSTEM_COMMITTER_ID, exploration_id) DCNL DCSP index_explorations_given_ids([exploration_id]) DCNL DCSP logging.info(('Exploration DCSP with DCSP id DCSP %s DCSP was DCSP loaded.' % exploration_id))
 DCSP (results, new_urlsafe_start_cursor, more) = exp_models.ExplorationCommitLogEntryModel.get_all_commits(page_size, urlsafe_start_cursor) DCNL DCSP return ([exp_domain.ExplorationCommitLogEntry(entry.created_on, entry.last_updated, entry.user_id, entry.username, entry.exploration_id, entry.commit_type, entry.commit_message, entry.commit_cmds, entry.version, entry.post_commit_status, entry.post_commit_community_owned, entry.post_commit_is_private) for entry in results], new_urlsafe_start_cursor, more)
 DCSP if ((max_age is not None) and (not isinstance(max_age, datetime.timedelta))): DCNL DCSP  DCSP raise ValueError('max_age DCSP must DCSP be DCSP a DCSP datetime.timedelta DCSP instance. DCSP or DCSP None.') DCNL DCSP (results, new_urlsafe_start_cursor, more) = exp_models.ExplorationCommitLogEntryModel.get_all_non_private_commits(page_size, urlsafe_start_cursor, max_age=max_age) DCNL DCSP return ([exp_domain.ExplorationCommitLogEntry(entry.created_on, entry.last_updated, entry.user_id, entry.username, entry.exploration_id, entry.commit_type, entry.commit_message, entry.commit_cmds, entry.version, entry.post_commit_status, entry.post_commit_community_owned, entry.post_commit_is_private) for entry in results], new_urlsafe_start_cursor, more)
 DCSP doc = {} DCNL DCSP if (rights.status == rights_manager.ACTIVITY_STATUS_PUBLICIZED): DCNL DCSP  DCSP doc['is'] = 'featured' DCNL DCSP return doc
 DCSP rights = rights_manager.get_exploration_rights(exp.id) DCNL DCSP return (rights.status != rights_manager.ACTIVITY_STATUS_PRIVATE)
 DCSP return sum(ratings.values())
 DCSP rating_weightings = {'1': 1, '2': 2, '3': 3, '4': 4, '5': 5} DCNL DCSP if ratings: DCNL DCSP  DCSP rating_sum = 0.0 DCNL DCSP  DCSP number_of_ratings = get_number_of_ratings(ratings) DCNL DCSP  DCSP if (number_of_ratings == 0): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP for (rating_value, rating_count) in ratings.items(): DCNL DCSP  DCSP  DCSP rating_sum += (rating_weightings[rating_value] * rating_count) DCNL DCSP  DCSP return (rating_sum / (number_of_ratings * 1.0))
 DCSP n = get_number_of_ratings(ratings) DCNL DCSP if (n == 0): DCNL DCSP  DCSP return 0 DCNL DCSP average_rating = get_average_rating(ratings) DCNL DCSP z = 1.9599639715843482 DCNL DCSP x = ((average_rating - 1) / 4) DCNL DCSP a = (x + ((z ** 2) / (2 * n))) DCNL DCSP b = (z * math.sqrt((((x * (1 - x)) / n) + ((z ** 2) / (4 * (n ** 2)))))) DCNL DCSP wilson_score_lower_bound = ((a - b) / (1 + ((z ** 2) / n))) DCNL DCSP return (1 + (4 * wilson_score_lower_bound))
 DCSP rating_weightings = {'1': (-5), '2': (-2), '3': 2, '4': 5, '5': 10} DCNL DCSP rank = (_DEFAULT_RANK + (_STATUS_PUBLICIZED_BONUS if (exp_summary.status == rights_manager.ACTIVITY_STATUS_PUBLICIZED) else 0)) DCNL DCSP if exp_summary.ratings: DCNL DCSP  DCSP for rating_value in exp_summary.ratings: DCNL DCSP  DCSP  DCSP rank += (exp_summary.ratings[rating_value] * rating_weightings[rating_value]) DCNL DCSP return max(rank, 0)
 DCSP exp_summary = get_exploration_summary_by_id(exp_id) DCNL DCSP return get_search_rank_from_exp_summary(exp_summary)
 DCSP rights = rights_manager.get_exploration_rights(exp.id) DCNL DCSP doc = {'id': exp.id, 'language_code': exp.language_code, 'title': exp.title, 'category': exp.category, 'tags': exp.tags, 'blurb': exp.blurb, 'objective': exp.objective, 'author_notes': exp.author_notes, 'rank': get_search_rank(exp.id)} DCNL DCSP doc.update(_exp_rights_to_search_dict(rights)) DCNL DCSP return doc
 DCSP search_services.clear_index(SEARCH_INDEX_EXPLORATIONS)
 DCSP exploration_models = get_multiple_explorations_by_id(exp_ids, strict=False) DCNL DCSP search_services.add_documents_to_index([_exp_to_search_dict(exp) for exp in exploration_models.values() if _should_index(exp)], SEARCH_INDEX_EXPLORATIONS)
 DCSP doc = search_services.get_document_from_index(exp_id, SEARCH_INDEX_EXPLORATIONS) DCNL DCSP doc.update(update) DCNL DCSP search_services.add_documents_to_index([doc], SEARCH_INDEX_EXPLORATIONS)
 DCSP rights = rights_manager.get_exploration_rights(exp_id) DCNL DCSP if (rights.status == rights_manager.ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP delete_documents_from_search_index([exp_id]) DCNL DCSP else: DCNL DCSP  DCSP patch_exploration_search_document(rights.id, _exp_rights_to_search_dict(rights))
 DCSP search_services.delete_documents_from_index(exploration_ids, SEARCH_INDEX_EXPLORATIONS)
 DCSP return search_services.search(query, SEARCH_INDEX_EXPLORATIONS, cursor, limit, sort, ids_only=True)
 DCSP states = get_exploration_by_id(exploration_id).states DCNL DCSP suggestion = feedback_models.SuggestionModel.get_by_exploration_and_thread_id(exploration_id, thread_id) DCNL DCSP return (suggestion.state_name in states)
 DCSP thread = feedback_models.FeedbackThreadModel.get_by_exp_and_thread_id(exploration_id, thread_id) DCNL DCSP return (thread.status in [feedback_models.STATUS_CHOICES_FIXED, feedback_models.STATUS_CHOICES_IGNORED])
 DCSP audio_translations = old_content.audio_translations DCNL DCSP if audio_update_required: DCNL DCSP  DCSP for (_, translation) in audio_translations.iteritems(): DCNL DCSP  DCSP  DCSP translation.needs_update = True DCNL DCSP return [{'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY, 'state_name': suggestion.state_name, 'property_name': exp_domain.STATE_PROPERTY_CONTENT, 'new_value': {'html': suggestion.suggestion_html, 'audio_translations': {language_code: translation.to_dict() for (language_code, translation) in audio_translations.iteritems()}}}]
 DCSP return ('%s DCSP %s: DCSP %s' % (feconf.COMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX, suggestion_author_username, commit_message))
 DCSP if ((not commit_message) or (not commit_message.strip())): DCNL DCSP  DCSP raise Exception('Commit DCSP message DCSP cannot DCSP be DCSP empty.') DCNL DCSP if _is_suggestion_handled(thread_id, exploration_id): DCNL DCSP  DCSP raise Exception('Suggestion DCSP has DCSP already DCSP been DCSP accepted/rejected.') DCNL DCSP elif (not _is_suggestion_valid(thread_id, exploration_id)): DCNL DCSP  DCSP raise Exception('Invalid DCSP suggestion: DCSP The DCSP state DCSP for DCSP which DCSP it DCSP was DCSP made DCSP has DCSP been DCSP removed/renamed.') DCNL DCSP else: DCNL DCSP  DCSP suggestion = feedback_services.get_suggestion(exploration_id, thread_id) DCNL DCSP  DCSP suggestion_author_username = suggestion.get_author_name() DCNL DCSP  DCSP exploration = get_exploration_by_id(exploration_id) DCNL DCSP  DCSP old_content = exploration.states[suggestion.state_name].content DCNL DCSP  DCSP change_list = _create_change_list_from_suggestion(suggestion, old_content, audio_update_required) DCNL DCSP  DCSP update_exploration(editor_id, exploration_id, change_list, _get_commit_message_for_suggestion(suggestion_author_username, commit_message), is_suggestion=True) DCNL DCSP  DCSP feedback_services.create_message(exploration_id, thread_id, editor_id, feedback_models.STATUS_CHOICES_FIXED, None, 'Suggestion DCSP accepted.')
 DCSP if _is_suggestion_handled(thread_id, exploration_id): DCNL DCSP  DCSP raise Exception('Suggestion DCSP has DCSP already DCSP been DCSP accepted/rejected.') DCNL DCSP else: DCNL DCSP  DCSP thread = feedback_models.FeedbackThreadModel.get_by_exp_and_thread_id(exploration_id, thread_id) DCNL DCSP  DCSP feedback_services.create_message(exploration_id, thread_id, editor_id, feedback_models.STATUS_CHOICES_IGNORED, None, 'Suggestion DCSP rejected.') DCNL DCSP  DCSP thread.put()
 DCSP return (get_exploration_by_id(exp_id).version == version)
 DCSP exp_user_data = user_models.ExplorationUserDataModel.get(user_id, exp_id) DCNL DCSP if (exp_user_data and exp_user_data.draft_change_list and (exp_user_data.draft_change_list_last_updated > current_datetime)): DCNL DCSP  DCSP return DCNL DCSP updated_exploration = apply_change_list(exp_id, change_list) DCNL DCSP updated_exploration.validate(strict=False) DCNL DCSP if (exp_user_data is None): DCNL DCSP  DCSP exp_user_data = user_models.ExplorationUserDataModel.create(user_id, exp_id) DCNL DCSP draft_change_list_id = exp_user_data.draft_change_list_id DCNL DCSP draft_change_list_id += 1 DCNL DCSP exp_user_data.draft_change_list = change_list DCNL DCSP exp_user_data.draft_change_list_last_updated = current_datetime DCNL DCSP exp_user_data.draft_change_list_exp_version = exp_version DCNL DCSP exp_user_data.draft_change_list_id = draft_change_list_id DCNL DCSP exp_user_data.put()
 DCSP exp_user_data = user_models.ExplorationUserDataModel.get(user_id, exp_id) DCNL DCSP exploration = get_exploration_by_id(exp_id) DCNL DCSP return (apply_change_list(exp_id, exp_user_data.draft_change_list) if (exp_user_data and exp_user_data.draft_change_list and is_version_of_draft_valid(exp_id, exp_user_data.draft_change_list_exp_version)) else exploration)
 DCSP exp_user_data = user_models.ExplorationUserDataModel.get(user_id, exp_id) DCNL DCSP if exp_user_data: DCNL DCSP  DCSP exp_user_data.draft_change_list = None DCNL DCSP  DCSP exp_user_data.draft_change_list_last_updated = None DCNL DCSP  DCSP exp_user_data.draft_change_list_exp_version = None DCNL DCSP  DCSP exp_user_data.put()
 DCSP topic_similarities_entity = recommendations_models.TopicSimilaritiesModel.get(recommendations_models.TOPIC_SIMILARITIES_ID, strict=False) DCNL DCSP if (topic_similarities_entity is None): DCNL DCSP  DCSP topic_similarities_entity = _create_default_topic_similarities() DCNL DCSP return json.loads(topic_similarities_entity.content)
 DCSP topic_similarities_entity = recommendations_models.TopicSimilaritiesModel.get(recommendations_models.TOPIC_SIMILARITIES_ID, strict=False) DCNL DCSP if (topic_similarities_entity is None): DCNL DCSP  DCSP topic_similarities_entity = recommendations_models.TopicSimilaritiesModel(id=recommendations_models.TOPIC_SIMILARITIES_ID, content=json.dumps(topic_similarities)) DCNL DCSP else: DCNL DCSP  DCSP topic_similarities_entity.content = json.dumps(topic_similarities) DCNL DCSP topic_similarities_entity.put() DCNL DCSP return topic_similarities_entity
 DCSP topic_similarities_dict = {topic: {} for topic in RECOMMENDATION_CATEGORIES} DCNL DCSP data = DEFAULT_TOPIC_SIMILARITIES_STRING.splitlines() DCNL DCSP data = list(csv.reader(data)) DCNL DCSP topics_list = data[0] DCNL DCSP topic_similarities_values = data[1:] DCNL DCSP for (row_ind, topic_1) in enumerate(topics_list): DCNL DCSP  DCSP for (col_ind, topic_2) in enumerate(topics_list): DCNL DCSP  DCSP  DCSP topic_similarities_dict[topic_1][topic_2] = float(topic_similarities_values[row_ind][col_ind]) DCNL DCSP return save_topic_similarities(topic_similarities_dict)
 DCSP if ((topic_1 in RECOMMENDATION_CATEGORIES) and (topic_2 in RECOMMENDATION_CATEGORIES)): DCNL DCSP  DCSP topic_similarities = get_topic_similarities_dict() DCNL DCSP  DCSP return topic_similarities[topic_1][topic_2] DCNL DCSP elif (topic_1 == topic_2): DCNL DCSP  DCSP return feconf.SAME_TOPIC_SIMILARITY DCNL DCSP else: DCNL DCSP  DCSP return feconf.DEFAULT_TOPIC_SIMILARITY
 DCSP output = StringIO.StringIO() DCNL DCSP writer = csv.writer(output) DCNL DCSP writer.writerow(RECOMMENDATION_CATEGORIES) DCNL DCSP topic_similarities = get_topic_similarities_dict() DCNL DCSP for topic in RECOMMENDATION_CATEGORIES: DCNL DCSP  DCSP topic_similarities_row = [value for (_, value) in sorted(topic_similarities[topic].iteritems())] DCNL DCSP  DCSP writer.writerow(topic_similarities_row) DCNL DCSP return output.getvalue()
 DCSP data = data.splitlines() DCNL DCSP data = list(csv.reader(data)) DCNL DCSP topics_list = data[0] DCNL DCSP topics_length = len(topics_list) DCNL DCSP topic_similarities_values = data[1:] DCNL DCSP if (len(topic_similarities_values) != topics_length): DCNL DCSP  DCSP raise Exception('Length DCSP of DCSP topic DCSP similarities DCSP columns DCSP does DCSP not DCSP match DCSP topic DCSP list.') DCNL DCSP for topic in topics_list: DCNL DCSP  DCSP if (topic not in RECOMMENDATION_CATEGORIES): DCNL DCSP  DCSP  DCSP raise Exception(('Topic DCSP %s DCSP not DCSP in DCSP list DCSP of DCSP known DCSP topics.' % topic)) DCNL DCSP for (index, topic) in enumerate(topics_list): DCNL DCSP  DCSP if (len(topic_similarities_values[index]) != topics_length): DCNL DCSP  DCSP  DCSP raise Exception('Length DCSP of DCSP topic DCSP similarities DCSP rows DCSP does DCSP not DCSP match DCSP topic DCSP list.') DCNL DCSP for row_ind in range(topics_length): DCNL DCSP  DCSP for col_ind in range(topics_length): DCNL DCSP  DCSP  DCSP similarity = topic_similarities_values[row_ind][col_ind] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP similarity = float(similarity) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Expected DCSP similarity DCSP to DCSP be DCSP a DCSP float, DCSP received DCSP %s' % similarity)) DCNL DCSP  DCSP  DCSP if ((similarity < 0.0) or (similarity > 1.0)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Expected DCSP similarity DCSP to DCSP be DCSP between DCSP 0.0 DCSP and DCSP 1.0, DCSP received DCSP %s' % similarity)) DCNL DCSP for row_ind in range(topics_length): DCNL DCSP  DCSP for col_ind in range(topics_length): DCNL DCSP  DCSP  DCSP if (topic_similarities_values[row_ind][col_ind] != topic_similarities_values[col_ind][row_ind]): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('Expected DCSP topic DCSP similarities DCSP to DCSP be DCSP symmetric.')
 DCSP _validate_topic_similarities(data) DCNL DCSP data = data.splitlines() DCNL DCSP data = list(csv.reader(data)) DCNL DCSP topics_list = data[0] DCNL DCSP topic_similarities_values = data[1:] DCNL DCSP topic_similarities_dict = get_topic_similarities_dict() DCNL DCSP for (row_ind, topic_1) in enumerate(topics_list): DCNL DCSP  DCSP for (col_ind, topic_2) in enumerate(topics_list): DCNL DCSP  DCSP  DCSP topic_similarities_dict[topic_1][topic_2] = float(topic_similarities_values[row_ind][col_ind]) DCNL DCSP save_topic_similarities(topic_similarities_dict)
 DCSP similarity_score = 0 DCNL DCSP if (compared_exp_status == rights_manager.ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP return 0 DCNL DCSP elif (compared_exp_status == rights_manager.ACTIVITY_STATUS_PUBLICIZED): DCNL DCSP  DCSP similarity_score += 1 DCNL DCSP similarity_score += (get_topic_similarity(reference_exp_category, compared_exp_category) * 5) DCNL DCSP if (reference_exp_owner_ids == compared_exp_owner_ids): DCNL DCSP  DCSP similarity_score += 1 DCNL DCSP if (reference_exp_language_code == compared_exp_language_code): DCNL DCSP  DCSP similarity_score += 2 DCNL DCSP time_now = datetime.datetime.utcnow() DCNL DCSP time_delta_days = int((time_now - compared_exp_last_updated).days) DCNL DCSP if (time_delta_days <= 7): DCNL DCSP  DCSP similarity_score += 1 DCNL DCSP return similarity_score
 DCSP recommendations_models.ExplorationRecommendationsModel(id=exp_id, recommended_exploration_ids=new_recommendations).put()
 DCSP recommendations_model = recommendations_models.ExplorationRecommendationsModel.get(exp_id, strict=False) DCNL DCSP if (recommendations_model is None): DCNL DCSP  DCSP return [] DCNL DCSP else: DCNL DCSP  DCSP return recommendations_model.recommended_exploration_ids
 DCSP if (role not in PARENT_ROLES): DCNL DCSP  DCSP raise Exception(('Role DCSP %s DCSP does DCSP not DCSP exist.' % role)) DCNL DCSP role_actions = ROLE_ACTIONS[role] DCNL DCSP for parent_role in PARENT_ROLES[role]: DCNL DCSP  DCSP role_actions.extend(get_all_actions(parent_role)) DCNL DCSP return list(set(role_actions))
 DCSP role_graph = {} DCNL DCSP role_graph['links'] = [] DCNL DCSP role_graph['nodes'] = {} DCNL DCSP for role in PARENT_ROLES: DCNL DCSP  DCSP role_graph['nodes'][role] = HUMAN_READABLE_ROLES[role] DCNL DCSP  DCSP for parent in PARENT_ROLES[role]: DCNL DCSP  DCSP  DCSP role_graph['links'].append({'source': parent, 'target': role}) DCNL DCSP return role_graph
 DCSP model_id = ('%s.%s.%s.%s' % (user_id, int(math.floor(time.time())), intent, random.randint(0, 1000))) DCNL DCSP audit_models.RoleQueryAuditModel(id=model_id, user_id=user_id, intent=intent, role=role, username=username).put()
 DCSP priority_num = (-1) DCNL DCSP resultant_role = None DCNL DCSP for role in role_list: DCNL DCSP  DCSP if (PRIORITY_NUMBER_DICT[role] > priority_num): DCNL DCSP  DCSP  DCSP resultant_role = role DCNL DCSP  DCSP  DCSP priority_num = PRIORITY_NUMBER_DICT[role] DCNL DCSP return resultant_role
 DCSP changed_user_roles = {} DCNL DCSP resultant_changed_roles = {} DCNL DCSP for key in ROLE_SYNC_DICT: DCNL DCSP  DCSP if (ROLE_SYNC_DICT[key]['name'] in new_config_properties): DCNL DCSP  DCSP  DCSP new_config_values = new_config_properties[ROLE_SYNC_DICT[key]['name']] DCNL DCSP  DCSP  DCSP old_config_values = old_config_properties[ROLE_SYNC_DICT[key]['name']] DCNL DCSP  DCSP  DCSP for username in new_config_values: DCNL DCSP  DCSP  DCSP  DCSP if (username not in changed_user_roles): DCNL DCSP  DCSP  DCSP  DCSP  DCSP changed_user_roles[username] = [] DCNL DCSP  DCSP  DCSP  DCSP changed_user_roles[username].append(ROLE_SYNC_DICT[key]['role']) DCNL DCSP  DCSP  DCSP for username in old_config_values: DCNL DCSP  DCSP  DCSP  DCSP if (username not in changed_user_roles): DCNL DCSP  DCSP  DCSP  DCSP  DCSP changed_user_roles[username] = [] DCNL DCSP  DCSP  DCSP  DCSP changed_user_roles[username].append(feconf.ROLE_ID_EXPLORATION_EDITOR) DCNL DCSP for username in changed_user_roles: DCNL DCSP  DCSP resultant_changed_roles[username] = get_max_priority_role(changed_user_roles[username]) DCNL DCSP return resultant_changed_roles
 DCSP def when_module_enabled(): DCNL DCSP  DCSP tags.Registry.add_tag_binding(OppiaTag.binding_name, OppiaTag) DCNL DCSP  DCSP tags.EditorBlacklists.register(OppiaTag.binding_name, tags.EditorBlacklists.COURSE_SCOPE) DCNL DCSP  DCSP if (EXPLORATION_COMPLETED_EVENT_NAME not in lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION): DCNL DCSP  DCSP  DCSP lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION.append(EXPLORATION_COMPLETED_EVENT_NAME) DCNL DCSP  DCSP if (OPPIA_TAG_BINDING_NAME not in progress.TRACKABLE_COMPONENTS): DCNL DCSP  DCSP  DCSP progress.TRACKABLE_COMPONENTS.append(OPPIA_TAG_BINDING_NAME) DCNL DCSP def when_module_disabled(): DCNL DCSP  DCSP tags.Registry.remove_tag_binding(OppiaTag.binding_name) DCNL DCSP  DCSP tags.EditorBlacklists.unregister(OppiaTag.binding_name, tags.EditorBlacklists.COURSE_SCOPE) DCNL DCSP  DCSP if (EXPLORATION_COMPLETED_EVENT_NAME in lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION): DCNL DCSP  DCSP  DCSP lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION.remove(EXPLORATION_COMPLETED_EVENT_NAME) DCNL DCSP  DCSP if (OPPIA_TAG_BINDING_NAME in progress.TRACKABLE_COMPONENTS): DCNL DCSP  DCSP  DCSP progress.TRACKABLE_COMPONENTS.remove(OPPIA_TAG_BINDING_NAME) DCNL DCSP global_routes = [(os.path.join(RESOURCES_PATH, '.*'), tags.ResourcesHandler)] DCNL DCSP global custom_module DCNL DCSP custom_module = custom_modules.Module('Oppia DCSP tag', 'A DCSP tag DCSP for DCSP rendering DCSP Oppia DCSP explorations DCSP within DCSP a DCSP lesson DCSP body.', global_routes, [], notify_module_enabled=when_module_enabled, notify_module_disabled=when_module_disabled) DCNL DCSP return custom_module
 DCSP with open(filepath, mode) as f: DCNL DCSP  DCSP return (f.read() if raw_bytes else f.read().decode('utf-8'))
 DCSP yaml_content = None DCNL DCSP assets_list = [] DCNL DCSP dir_path_array = dir_path.split('/') DCNL DCSP while (dir_path_array[(-1)] == ''): DCNL DCSP  DCSP dir_path_array = dir_path_array[:(-1)] DCNL DCSP dir_path_length = len(dir_path_array) DCNL DCSP for (root, dirs, files) in os.walk(dir_path): DCNL DCSP  DCSP for directory in dirs: DCNL DCSP  DCSP  DCSP if ((root == dir_path) and (directory != 'assets')): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('The DCSP only DCSP directory DCSP in DCSP %s DCSP should DCSP be DCSP assets/' % dir_path)) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP filepath = os.path.join(root, filename) DCNL DCSP  DCSP  DCSP if (root == dir_path): DCNL DCSP  DCSP  DCSP  DCSP if filepath.endswith('.DS_Store'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (yaml_content is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('More DCSP than DCSP one DCSP non-asset DCSP file DCSP specified DCSP for DCSP %s' % dir_path)) DCNL DCSP  DCSP  DCSP  DCSP elif (not filepath.endswith('.yaml')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('Found DCSP invalid DCSP non-asset DCSP file DCSP %s. DCSP There DCSP should DCSP only DCSP be DCSP a DCSP single DCSP non-asset DCSP file, DCSP and DCSP it DCSP should DCSP have DCSP a DCSP .yaml DCSP suffix.' % filepath)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP yaml_content = get_file_contents(filepath) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP filepath_array = filepath.split('/') DCNL DCSP  DCSP  DCSP  DCSP filename = '/'.join(filepath_array[(dir_path_length + 1):]) DCNL DCSP  DCSP  DCSP  DCSP assets_list.append((filename, get_file_contents(filepath, raw_bytes=True))) DCNL DCSP if (yaml_content is None): DCNL DCSP  DCSP raise Exception(('No DCSP yaml DCSP file DCSP specifed DCSP for DCSP %s' % dir_path)) DCNL DCSP return (yaml_content, assets_list)
 DCSP memfile = StringIO.StringIO() DCNL DCSP memfile.write(zip_file_contents) DCNL DCSP zf = zipfile.ZipFile(memfile, 'r') DCNL DCSP yaml_content = None DCNL DCSP assets_list = [] DCNL DCSP for filepath in zf.namelist(): DCNL DCSP  DCSP if filepath.startswith('assets/'): DCNL DCSP  DCSP  DCSP assets_list.append('/'.join(filepath.split('/')[1:]), zf.read(filepath)) DCNL DCSP  DCSP elif (yaml_content is not None): DCNL DCSP  DCSP  DCSP raise Exception('More DCSP than DCSP one DCSP non-asset DCSP file DCSP specified DCSP for DCSP zip DCSP file') DCNL DCSP  DCSP elif (not filepath.endswith('.yaml')): DCNL DCSP  DCSP  DCSP raise Exception(('Found DCSP invalid DCSP non-asset DCSP file DCSP %s. DCSP There DCSP should DCSP only DCSP be DCSP a DCSP single DCSP file DCSP not DCSP in DCSP assets/, DCSP and DCSP it DCSP should DCSP have DCSP a DCSP .yaml DCSP suffix.' % filepath)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP yaml_content = zf.read(filepath) DCNL DCSP if (yaml_content is None): DCNL DCSP  DCSP raise Exception('No DCSP yaml DCSP file DCSP specified DCSP in DCSP zip DCSP file DCSP contents') DCNL DCSP return (yaml_content, assets_list)
 DCSP if (not items): DCNL DCSP  DCSP return '' DCNL DCSP if (len(items) == 1): DCNL DCSP  DCSP return items[0] DCNL DCSP return ('%s DCSP and DCSP %s' % (', DCSP '.join(items[:(-1)]), items[(-1)]))
 DCSP return unicodedata.normalize('NFKD', unicode(input_string)).encode('ascii', 'ignore')
 DCSP return yaml.safe_dump(dictionary, default_flow_style=False, width=width)
 DCSP try: DCNL DCSP  DCSP retrieved_dict = yaml.safe_load(yaml_str) DCNL DCSP  DCSP assert isinstance(retrieved_dict, dict) DCNL DCSP  DCSP return retrieved_dict DCNL DCSP except yaml.YAMLError as e: DCNL DCSP  DCSP raise InvalidInputException(e)
 DCSP if isinstance(obj, list): DCNL DCSP  DCSP for item in obj: DCNL DCSP  DCSP  DCSP recursively_remove_key(item, key_to_remove) DCNL DCSP elif isinstance(obj, dict): DCNL DCSP  DCSP if (key_to_remove in obj): DCNL DCSP  DCSP  DCSP del obj[key_to_remove] DCNL DCSP  DCSP for (key, unused_value) in obj.items(): DCNL DCSP  DCSP  DCSP recursively_remove_key(obj[key], key_to_remove)
 DCSP assert ((upper_bound >= 0) and isinstance(upper_bound, int)) DCNL DCSP generator = random.SystemRandom() DCNL DCSP return generator.randrange(0, upper_bound)
 DCSP assert (isinstance(alist, list) and (len(alist) > 0)) DCNL DCSP index = get_random_int(len(alist)) DCNL DCSP return alist[index]
 DCSP if (imghdr.what(None, content) == 'png'): DCNL DCSP  DCSP return ('data:image/png;base64,%s' % urllib.quote(content.encode('base64'))) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('The DCSP given DCSP string DCSP does DCSP not DCSP represent DCSP a DCSP PNG DCSP image.')
 DCSP file_contents = get_file_contents(filepath, raw_bytes=True, mode='rb') DCNL DCSP return convert_png_binary_to_data_url(file_contents)
 DCSP if (not isinstance(param_name, basestring)): DCNL DCSP  DCSP raise Exception(('URL DCSP query DCSP parameter DCSP name DCSP must DCSP be DCSP a DCSP string, DCSP received DCSP %s' % param_name)) DCNL DCSP (scheme, netloc, path, query_string, fragment) = urlparse.urlsplit(url) DCNL DCSP query_params = urlparse.parse_qs(query_string) DCNL DCSP query_params[param_name] = [param_value] DCNL DCSP new_query_string = urllib.urlencode(query_params, doseq=True) DCNL DCSP return urlparse.urlunsplit((scheme, netloc, path, new_query_string, fragment))
 DCSP if (not isinstance(input_string, basestring)): DCNL DCSP  DCSP raise Exception(('Expected DCSP string, DCSP received DCSP %s DCSP of DCSP type DCSP %s' % (input_string, type(input_string)))) DCNL DCSP encoded_string = base64.urlsafe_b64encode(hashlib.sha1(input_string.encode('utf-8')).digest()) DCNL DCSP return encoded_string[:max_length]
 DCSP seconds = (time.mktime(datetime_obj.timetuple()) * 1000) DCNL DCSP return (seconds + (datetime_obj.microsecond / 1000.0))
 DCSP return get_time_in_millisecs(datetime.datetime.utcnow())
 DCSP return time.strftime('%B DCSP %d DCSP %H:%M:%S', time.gmtime((time_msec / 1000.0)))
 DCSP difference_in_secs = (later_datetime - earlier_datetime).total_seconds() DCNL DCSP return (difference_in_secs < feconf.PROXIMAL_TIMEDELTA_SECS)
 DCSP path = base_path DCNL DCSP for component in path_components: DCNL DCSP  DCSP if component.startswith('/'): DCNL DCSP  DCSP  DCSP path = component DCNL DCSP  DCSP elif ((path == '') or path.endswith('/')): DCNL DCSP  DCSP  DCSP path += component DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path += ('/%s' % component) DCNL DCSP return path
 DCSP (slash, dot) = ((u'/', u'.') if isinstance(path, unicode) else ('/', '.')) DCNL DCSP if (path == ''): DCNL DCSP  DCSP return dot DCNL DCSP initial_slashes = path.startswith('/') DCNL DCSP if (initial_slashes and path.startswith('//') and (not path.startswith('///'))): DCNL DCSP  DCSP initial_slashes = 2 DCNL DCSP comps = path.split('/') DCNL DCSP new_comps = [] DCNL DCSP for comp in comps: DCNL DCSP  DCSP if (comp in ('', '.')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((comp != '..') or ((not initial_slashes) and (not new_comps)) or (new_comps and (new_comps[(-1)] == '..'))): DCNL DCSP  DCSP  DCSP new_comps.append(comp) DCNL DCSP  DCSP elif new_comps: DCNL DCSP  DCSP  DCSP new_comps.pop() DCNL DCSP comps = new_comps DCNL DCSP path = slash.join(comps) DCNL DCSP if initial_slashes: DCNL DCSP  DCSP path = ((slash * initial_slashes) + path) DCNL DCSP return (path or dot)
 DCSP if (not isinstance(name, basestring)): DCNL DCSP  DCSP raise ValidationError(('%s DCSP must DCSP be DCSP a DCSP string.' % name_type)) DCNL DCSP if (allow_empty and (name == '')): DCNL DCSP  DCSP return DCNL DCSP if ((len(name) > 50) or (len(name) < 1)): DCNL DCSP  DCSP raise ValidationError(('The DCSP length DCSP of DCSP %s DCSP should DCSP be DCSP between DCSP 1 DCSP and DCSP 50 DCSP characters; DCSP received DCSP %s' % (name_type, name))) DCNL DCSP if ((name[0] in string.whitespace) or (name[(-1)] in string.whitespace)): DCNL DCSP  DCSP raise ValidationError('Names DCSP should DCSP not DCSP start DCSP or DCSP end DCSP with DCSP whitespace.') DCNL DCSP if re.search('\\s\\s+', name): DCNL DCSP  DCSP raise ValidationError(('Adjacent DCSP whitespace DCSP in DCSP %s DCSP should DCSP be DCSP collapsed.' % name_type)) DCNL DCSP for character in feconf.INVALID_NAME_CHARS: DCNL DCSP  DCSP if (character in name): DCNL DCSP  DCSP  DCSP raise ValidationError(('Invalid DCSP character DCSP %s DCSP in DCSP %s: DCSP %s' % (character, name_type, name)))
 DCSP if input_string: DCNL DCSP  DCSP return (input_string[0].upper() + input_string[1:]) DCNL DCSP else: DCNL DCSP  DCSP return input_string
 DCSP if (' DCSP (' not in full_language_description): DCNL DCSP  DCSP return full_language_description DCNL DCSP else: DCNL DCSP  DCSP ind = full_language_description.find(' DCSP (') DCNL DCSP  DCSP return full_language_description[:ind]
 DCSP return urllib.unquote(escaped_string).decode('utf-8')
 DCSP asset_dir_prefix = '' DCNL DCSP if (feconf.IS_MINIFIED or (not feconf.DEV_MODE)): DCNL DCSP  DCSP asset_dir_prefix = '/build' DCNL DCSP return asset_dir_prefix
 DCSP template_path = ('/templates/head' if (feconf.IS_MINIFIED or (not feconf.DEV_MODE)) else '/templates/dev/head') DCNL DCSP return ('%s%s' % (get_asset_dir_prefix(), template_path))
 DCSP if isinstance(string_to_convert, unicode): DCNL DCSP  DCSP return string_to_convert.encode('utf-8') DCNL DCSP return string_to_convert
 DCSP def when_module_enabled(): DCNL DCSP  DCSP tags.Registry.add_tag_binding(OppiaTag.binding_name, OppiaTag) DCNL DCSP  DCSP tags.EditorBlacklists.register(OppiaTag.binding_name, tags.EditorBlacklists.COURSE_SCOPE) DCNL DCSP  DCSP if (EXPLORATION_COMPLETED_EVENT_NAME not in lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION): DCNL DCSP  DCSP  DCSP lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION.append(EXPLORATION_COMPLETED_EVENT_NAME) DCNL DCSP  DCSP if (OPPIA_TAG_BINDING_NAME not in progress.TRACKABLE_COMPONENTS): DCNL DCSP  DCSP  DCSP progress.TRACKABLE_COMPONENTS.append(OPPIA_TAG_BINDING_NAME) DCNL DCSP def when_module_disabled(): DCNL DCSP  DCSP tags.Registry.remove_tag_binding(OppiaTag.binding_name) DCNL DCSP  DCSP tags.EditorBlacklists.unregister(OppiaTag.binding_name, tags.EditorBlacklists.COURSE_SCOPE) DCNL DCSP  DCSP if (EXPLORATION_COMPLETED_EVENT_NAME in lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION): DCNL DCSP  DCSP  DCSP lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION.remove(EXPLORATION_COMPLETED_EVENT_NAME) DCNL DCSP  DCSP if (OPPIA_TAG_BINDING_NAME in progress.TRACKABLE_COMPONENTS): DCNL DCSP  DCSP  DCSP progress.TRACKABLE_COMPONENTS.remove(OPPIA_TAG_BINDING_NAME) DCNL DCSP global_routes = [(os.path.join(RESOURCES_PATH, '.*'), tags.ResourcesHandler)] DCNL DCSP global custom_module DCNL DCSP custom_module = custom_modules.Module('Oppia DCSP tag', 'A DCSP tag DCSP for DCSP rendering DCSP Oppia DCSP explorations DCSP within DCSP a DCSP lesson DCSP body.', global_routes, [], notify_module_enabled=when_module_enabled, notify_module_disabled=when_module_disabled) DCNL DCSP return custom_module
 DCSP def when_module_enabled(): DCNL DCSP  DCSP tags.Registry.add_tag_binding(OppiaTag.binding_name, OppiaTag) DCNL DCSP  DCSP tags.EditorBlacklists.register(OppiaTag.binding_name, tags.EditorBlacklists.COURSE_SCOPE) DCNL DCSP  DCSP if (EXPLORATION_COMPLETED_EVENT_NAME not in lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION): DCNL DCSP  DCSP  DCSP lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION.append(EXPLORATION_COMPLETED_EVENT_NAME) DCNL DCSP  DCSP if (OPPIA_TAG_BINDING_NAME not in progress.TRACKABLE_COMPONENTS): DCNL DCSP  DCSP  DCSP progress.TRACKABLE_COMPONENTS.append(OPPIA_TAG_BINDING_NAME) DCNL DCSP def when_module_disabled(): DCNL DCSP  DCSP tags.Registry.remove_tag_binding(OppiaTag.binding_name) DCNL DCSP  DCSP tags.EditorBlacklists.unregister(OppiaTag.binding_name, tags.EditorBlacklists.COURSE_SCOPE) DCNL DCSP  DCSP if (EXPLORATION_COMPLETED_EVENT_NAME in lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION): DCNL DCSP  DCSP  DCSP lessons.TAGS_THAT_TRIGGER_COMPONENT_COMPLETION.remove(EXPLORATION_COMPLETED_EVENT_NAME) DCNL DCSP  DCSP if (OPPIA_TAG_BINDING_NAME in progress.TRACKABLE_COMPONENTS): DCNL DCSP  DCSP  DCSP progress.TRACKABLE_COMPONENTS.remove(OPPIA_TAG_BINDING_NAME) DCNL DCSP global_routes = [(os.path.join(RESOURCES_PATH, '.*'), tags.ResourcesHandler)] DCNL DCSP global custom_module DCNL DCSP custom_module = custom_modules.Module('Oppia DCSP tag', 'A DCSP tag DCSP for DCSP rendering DCSP Oppia DCSP explorations DCSP within DCSP a DCSP lesson DCSP body.', global_routes, [], notify_module_enabled=when_module_enabled, notify_module_disabled=when_module_disabled) DCNL DCSP return custom_module
 DCSP if (defaults is None): DCNL DCSP  DCSP defaults = {} DCNL DCSP name = regex_route.replace('/', '_') DCNL DCSP return RedirectRoute(regex_route, handler, name, strict_slash=True, defaults=defaults)
 DCSP from google.appengine.ext.appstats import recording DCNL DCSP def save(self): DCNL DCSP  DCSP t0 = time.time() DCNL DCSP  DCSP with self._lock: DCNL DCSP  DCSP  DCSP num_pending = len(self.pending) DCNL DCSP  DCSP if num_pending: DCNL DCSP  DCSP  DCSP logging.warn('Found DCSP %d DCSP RPC DCSP request(s) DCSP without DCSP matching DCSP response DCSP (presumably DCSP due DCSP to DCSP timeouts DCSP or DCSP other DCSP errors)', num_pending) DCNL DCSP  DCSP self.dump() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (key, len_part, len_full) = self._save() DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP logging.exception('Recorder.save() DCSP failed') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP t1 = time.time() DCNL DCSP  DCSP link = ('http://%s%s/details?time=%s' % (self.env.get('HTTP_HOST', ''), recording.config.stats_url, int((self.start_timestamp * 1000)))) DCNL DCSP  DCSP logging.debug('Saved; DCSP key: DCSP %s, DCSP part: DCSP %s DCSP bytes, DCSP full: DCSP %s DCSP bytes, DCSP overhead: DCSP %.3f DCSP + DCSP %.3f; DCSP link: DCSP %s', key, len_part, len_full, self.overhead, (t1 - t0), link) DCNL DCSP recording.Recorder.save = save DCNL DCSP app = recording.appstats_wsgi_middleware(app) DCNL DCSP return app
 DCSP return (any((filename.startswith(bad_pattern) for bad_pattern in BAD_PATTERNS[pattern]['excluded_dirs'])) or (filename in BAD_PATTERNS[pattern]['excluded_files']))
 DCSP unstaged_files = subprocess.check_output(['git', 'diff', '--name-only', '--diff-filter=ACM']).splitlines() DCNL DCSP staged_files = subprocess.check_output(['git', 'diff', '--cached', '--name-only', '--diff-filter=ACM']).splitlines() DCNL DCSP return (unstaged_files + staged_files)
 DCSP file_data = [] DCNL DCSP with open(eslintignore_path) as f: DCNL DCSP  DCSP file_data.extend(f.readlines()) DCNL DCSP return file_data
 DCSP files_in_directory = [] DCNL DCSP for (_dir, _, files) in os.walk(dir_path): DCNL DCSP  DCSP for file_name in files: DCNL DCSP  DCSP  DCSP filename = os.path.relpath(os.path.join(_dir, file_name), os.getcwd()) DCNL DCSP  DCSP  DCSP if (not any([fnmatch.fnmatch(filename, gp) for gp in excluded_glob_patterns])): DCNL DCSP  DCSP  DCSP  DCSP files_in_directory.append(filename) DCNL DCSP return files_in_directory
 DCSP start_time = time.time() DCNL DCSP num_files_with_errors = 0 DCNL DCSP num_js_files = len(files_to_lint) DCNL DCSP if (not files_to_lint): DCNL DCSP  DCSP result.put('') DCNL DCSP  DCSP print 'There DCSP are DCSP no DCSP JavaScript DCSP files DCSP to DCSP lint.' DCNL DCSP  DCSP return DCNL DCSP print 'Total DCSP js DCSP files: DCSP ', num_js_files DCNL DCSP eslint_cmd_args = [node_path, eslint_path, '--quiet'] DCNL DCSP for (_, filename) in enumerate(files_to_lint): DCNL DCSP  DCSP print 'Linting: DCSP ', filename DCNL DCSP  DCSP proc_args = (eslint_cmd_args + [filename]) DCNL DCSP  DCSP proc = subprocess.Popen(proc_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP  DCSP (linter_stdout, linter_stderr) = proc.communicate() DCNL DCSP  DCSP if linter_stderr: DCNL DCSP  DCSP  DCSP print 'LINTER DCSP FAILED' DCNL DCSP  DCSP  DCSP print linter_stderr DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP if linter_stdout: DCNL DCSP  DCSP  DCSP num_files_with_errors += 1 DCNL DCSP  DCSP  DCSP stdout.put(linter_stdout) DCNL DCSP if num_files_with_errors: DCNL DCSP  DCSP result.put(('%s DCSP  DCSP  DCSP  DCSP %s DCSP JavaScript DCSP files' % (_MESSAGE_TYPE_FAILED, num_files_with_errors))) DCNL DCSP else: DCNL DCSP  DCSP result.put(('%s DCSP  DCSP  DCSP %s DCSP JavaScript DCSP files DCSP linted DCSP (%.1f DCSP secs)' % (_MESSAGE_TYPE_SUCCESS, num_js_files, (time.time() - start_time)))) DCNL DCSP print 'Js DCSP linting DCSP finished.'
 DCSP start_time = time.time() DCNL DCSP are_there_errors = False DCNL DCSP num_py_files = len(files_to_lint) DCNL DCSP if (not files_to_lint): DCNL DCSP  DCSP result.put('') DCNL DCSP  DCSP print 'There DCSP are DCSP no DCSP Python DCSP files DCSP to DCSP lint.' DCNL DCSP  DCSP return DCNL DCSP print ('Linting DCSP %s DCSP Python DCSP files' % num_py_files) DCNL DCSP _BATCH_SIZE = 50 DCNL DCSP current_batch_start_index = 0 DCNL DCSP while (current_batch_start_index < len(files_to_lint)): DCNL DCSP  DCSP current_batch_end_index = min((current_batch_start_index + _BATCH_SIZE), len(files_to_lint)) DCNL DCSP  DCSP current_files_to_lint = files_to_lint[current_batch_start_index:current_batch_end_index] DCNL DCSP  DCSP print ('Linting DCSP Python DCSP files DCSP %s DCSP to DCSP %s...' % ((current_batch_start_index + 1), current_batch_end_index)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lint.Run((current_files_to_lint + [config_pylint])) DCNL DCSP  DCSP except SystemExit as e: DCNL DCSP  DCSP  DCSP if (str(e) != '0'): DCNL DCSP  DCSP  DCSP  DCSP are_there_errors = True DCNL DCSP  DCSP current_batch_start_index = current_batch_end_index DCNL DCSP if are_there_errors: DCNL DCSP  DCSP result.put(('%s DCSP  DCSP  DCSP  DCSP Python DCSP linting DCSP failed' % _MESSAGE_TYPE_FAILED)) DCNL DCSP else: DCNL DCSP  DCSP result.put(('%s DCSP  DCSP  DCSP %s DCSP Python DCSP files DCSP linted DCSP (%.1f DCSP secs)' % (_MESSAGE_TYPE_SUCCESS, num_py_files, (time.time() - start_time)))) DCNL DCSP print 'Python DCSP linting DCSP finished.'
 DCSP eslintignore_path = os.path.join(os.getcwd(), '.eslintignore') DCNL DCSP parsed_args = _PARSER.parse_args() DCNL DCSP if parsed_args.path: DCNL DCSP  DCSP input_path = os.path.join(os.getcwd(), parsed_args.path) DCNL DCSP  DCSP if (not os.path.exists(input_path)): DCNL DCSP  DCSP  DCSP print ('Could DCSP not DCSP locate DCSP file DCSP or DCSP directory DCSP %s. DCSP Exiting.' % input_path) DCNL DCSP  DCSP  DCSP print '----------------------------------------' DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP if os.path.isfile(input_path): DCNL DCSP  DCSP  DCSP all_files = [input_path] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP excluded_glob_patterns = _get_glob_patterns_excluded_from_eslint(eslintignore_path) DCNL DCSP  DCSP  DCSP all_files = _get_all_files_in_directory(input_path, excluded_glob_patterns) DCNL DCSP elif parsed_args.files: DCNL DCSP  DCSP valid_filepaths = [] DCNL DCSP  DCSP invalid_filepaths = [] DCNL DCSP  DCSP for f in parsed_args.files: DCNL DCSP  DCSP  DCSP if os.path.isfile(f): DCNL DCSP  DCSP  DCSP  DCSP valid_filepaths.append(f) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP invalid_filepaths.append(f) DCNL DCSP  DCSP if invalid_filepaths: DCNL DCSP  DCSP  DCSP print ('The DCSP following DCSP file(s) DCSP do DCSP not DCSP exist: DCSP %s\nExiting.' % invalid_filepaths) DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP all_files = valid_filepaths DCNL DCSP else: DCNL DCSP  DCSP all_files = _get_changed_filenames() DCNL DCSP all_files = [filename for filename in all_files if (not any((fnmatch.fnmatch(filename, pattern) for pattern in EXCLUDED_PATHS)))] DCNL DCSP return all_files
 DCSP print 'Starting DCSP linter...' DCNL DCSP pylintrc_path = os.path.join(os.getcwd(), '.pylintrc') DCNL DCSP config_pylint = ('--rcfile=%s' % pylintrc_path) DCNL DCSP parent_dir = os.path.abspath(os.path.join(os.getcwd(), os.pardir)) DCNL DCSP node_path = os.path.join(parent_dir, 'oppia_tools', 'node-6.9.1', 'bin', 'node') DCNL DCSP eslint_path = os.path.join(parent_dir, 'node_modules', 'eslint', 'bin', 'eslint.js') DCNL DCSP if (not os.path.exists(eslint_path)): DCNL DCSP  DCSP print '' DCNL DCSP  DCSP print 'ERROR DCSP  DCSP  DCSP  DCSP Please DCSP run DCSP start.sh DCSP first DCSP to DCSP install DCSP node-eslint DCSP ' DCNL DCSP  DCSP print ' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP and DCSP its DCSP dependencies.' DCNL DCSP  DCSP sys.exit(1) DCNL DCSP js_files_to_lint = [filename for filename in all_files if filename.endswith('.js')] DCNL DCSP py_files_to_lint = [filename for filename in all_files if filename.endswith('.py')] DCNL DCSP js_result = multiprocessing.Queue() DCNL DCSP linting_processes = [] DCNL DCSP js_stdout = multiprocessing.Queue() DCNL DCSP linting_processes.append(multiprocessing.Process(target=_lint_js_files, args=(node_path, eslint_path, js_files_to_lint, js_stdout, js_result))) DCNL DCSP py_result = multiprocessing.Queue() DCNL DCSP linting_processes.append(multiprocessing.Process(target=_lint_py_files, args=(config_pylint, py_files_to_lint, py_result))) DCNL DCSP print 'Starting DCSP Javascript DCSP and DCSP Python DCSP Linting' DCNL DCSP print '----------------------------------------' DCNL DCSP for process in linting_processes: DCNL DCSP  DCSP process.start() DCNL DCSP for process in linting_processes: DCNL DCSP  DCSP process.join(timeout=600) DCNL DCSP js_messages = [] DCNL DCSP while (not js_stdout.empty()): DCNL DCSP  DCSP js_messages.append(js_stdout.get()) DCNL DCSP print '' DCNL DCSP print '\n'.join(js_messages) DCNL DCSP print '----------------------------------------' DCNL DCSP summary_messages = [] DCNL DCSP summary_messages.append(js_result.get(block=False)) DCNL DCSP summary_messages.append(py_result.get(block=False)) DCNL DCSP print '\n'.join(summary_messages) DCNL DCSP print '' DCNL DCSP return summary_messages
 DCSP print 'Starting DCSP newline-at-EOF DCSP checks' DCNL DCSP print '----------------------------------------' DCNL DCSP total_files_checked = 0 DCNL DCSP total_error_count = 0 DCNL DCSP summary_messages = [] DCNL DCSP all_files = [filename for filename in all_files if (not any((fnmatch.fnmatch(filename, pattern) for pattern in EXCLUDED_PATHS)))] DCNL DCSP failed = False DCNL DCSP for filename in all_files: DCNL DCSP  DCSP with open(filename, 'rb') as f: DCNL DCSP  DCSP  DCSP total_files_checked += 1 DCNL DCSP  DCSP  DCSP total_num_chars = 0 DCNL DCSP  DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP  DCSP total_num_chars += len(line) DCNL DCSP  DCSP  DCSP if (total_num_chars == 1): DCNL DCSP  DCSP  DCSP  DCSP failed = True DCNL DCSP  DCSP  DCSP  DCSP print ('%s DCSP --> DCSP Error: DCSP Only DCSP one DCSP character DCSP in DCSP file' % filename) DCNL DCSP  DCSP  DCSP  DCSP total_error_count += 1 DCNL DCSP  DCSP  DCSP elif (total_num_chars > 1): DCNL DCSP  DCSP  DCSP  DCSP f.seek((-2), 2) DCNL DCSP  DCSP  DCSP  DCSP if (not ((f.read(1) != '\n') and (f.read(1) == '\n'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP failed = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('%s DCSP --> DCSP Please DCSP ensure DCSP that DCSP this DCSP file DCSP endswith DCSP exactly DCSP one DCSP newline DCSP char.' % filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP total_error_count += 1 DCNL DCSP if failed: DCNL DCSP  DCSP summary_message = ('%s DCSP  DCSP  DCSP Newline DCSP character DCSP checks DCSP failed' % _MESSAGE_TYPE_FAILED) DCNL DCSP  DCSP summary_messages.append(summary_message) DCNL DCSP else: DCNL DCSP  DCSP summary_message = ('%s DCSP  DCSP  DCSP Newline DCSP character DCSP checks DCSP passed' % _MESSAGE_TYPE_SUCCESS) DCNL DCSP  DCSP summary_messages.append(summary_message) DCNL DCSP print '' DCNL DCSP print '----------------------------------------' DCNL DCSP print '' DCNL DCSP if (total_files_checked == 0): DCNL DCSP  DCSP print 'There DCSP are DCSP no DCSP files DCSP to DCSP be DCSP checked.' DCNL DCSP else: DCNL DCSP  DCSP print ('(%s DCSP files DCSP checked, DCSP %s DCSP errors DCSP found)' % (total_files_checked, total_error_count)) DCNL DCSP  DCSP print summary_message DCNL DCSP return summary_messages
 DCSP print 'Starting DCSP Pattern DCSP Checks' DCNL DCSP print '----------------------------------------' DCNL DCSP total_files_checked = 0 DCNL DCSP total_error_count = 0 DCNL DCSP summary_messages = [] DCNL DCSP all_files = [filename for filename in all_files if (not any((fnmatch.fnmatch(filename, pattern) for pattern in EXCLUDED_PATHS)))] DCNL DCSP failed = False DCNL DCSP for filename in all_files: DCNL DCSP  DCSP with open(filename) as f: DCNL DCSP  DCSP  DCSP content = f.read() DCNL DCSP  DCSP  DCSP total_files_checked += 1 DCNL DCSP  DCSP  DCSP for pattern in BAD_PATTERNS: DCNL DCSP  DCSP  DCSP  DCSP if ((pattern in content) and (not _is_filename_excluded_for_bad_patterns_check(pattern, filename))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP failed = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('%s DCSP --> DCSP %s' % (filename, BAD_PATTERNS[pattern]['message'])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP total_error_count += 1 DCNL DCSP  DCSP  DCSP if filename.endswith('.js'): DCNL DCSP  DCSP  DCSP  DCSP for regexp in BAD_PATTERNS_JS_REGEXP: DCNL DCSP  DCSP  DCSP  DCSP  DCSP regexp_pattern = regexp['regexp'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (filename not in regexp['excluded_files']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if re.search(regexp_pattern, content): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP failed = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('%s DCSP --> DCSP %s' % (filename, regexp['message'])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP total_error_count += 1 DCNL DCSP  DCSP  DCSP if (filename == 'app.yaml'): DCNL DCSP  DCSP  DCSP  DCSP for pattern in BAD_PATTERNS_APP_YAML: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (pattern in content): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP failed = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('%s DCSP --> DCSP %s' % (filename, BAD_PATTERNS_APP_YAML[pattern]['message'])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP total_error_count += 1 DCNL DCSP if failed: DCNL DCSP  DCSP summary_message = ('%s DCSP  DCSP  DCSP Pattern DCSP checks DCSP failed' % _MESSAGE_TYPE_FAILED) DCNL DCSP  DCSP summary_messages.append(summary_message) DCNL DCSP else: DCNL DCSP  DCSP summary_message = ('%s DCSP  DCSP  DCSP Pattern DCSP checks DCSP passed' % _MESSAGE_TYPE_SUCCESS) DCNL DCSP  DCSP summary_messages.append(summary_message) DCNL DCSP print '' DCNL DCSP print '----------------------------------------' DCNL DCSP print '' DCNL DCSP if (total_files_checked == 0): DCNL DCSP  DCSP print 'There DCSP are DCSP no DCSP files DCSP to DCSP be DCSP checked.' DCNL DCSP else: DCNL DCSP  DCSP print ('(%s DCSP files DCSP checked, DCSP %s DCSP errors DCSP found)' % (total_files_checked, total_error_count)) DCNL DCSP  DCSP print summary_message DCNL DCSP return summary_messages
 DCSP with LOG_LOCK: DCNL DCSP  DCSP if show_time: DCNL DCSP  DCSP  DCSP print datetime.datetime.utcnow().strftime('%H:%M:%S'), message DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print message
 DCSP p = subprocess.Popen(exe, stdout=stdout, stderr=stderr) DCNL DCSP (last_stdout_str, last_stderr_str) = p.communicate() DCNL DCSP last_stdout = last_stdout_str.split('\n') DCNL DCSP if (LOG_LINE_PREFIX in last_stdout_str): DCNL DCSP  DCSP log('') DCNL DCSP  DCSP for line in last_stdout: DCNL DCSP  DCSP  DCSP if line.startswith(LOG_LINE_PREFIX): DCNL DCSP  DCSP  DCSP  DCSP log(('INFO: DCSP %s' % line[len(LOG_LINE_PREFIX):])) DCNL DCSP  DCSP log('') DCNL DCSP result = ('%s%s' % (last_stdout_str, last_stderr_str)) DCNL DCSP if (p.returncode != 0): DCNL DCSP  DCSP raise Exception(('Error DCSP %s\n%s' % (p.returncode, result))) DCNL DCSP return result
 DCSP running_tasks_data = [] DCNL DCSP for task in tasks: DCNL DCSP  DCSP if task.isAlive(): DCNL DCSP  DCSP  DCSP running_tasks_data.append((' DCSP  DCSP %s DCSP (started DCSP %s)' % (task.name, time.strftime('%H:%M:%S', time.localtime(task.start_time))))) DCNL DCSP  DCSP if task.exception: DCNL DCSP  DCSP  DCSP ALL_ERRORS.append(task.exception) DCNL DCSP if running_tasks_data: DCNL DCSP  DCSP log('----------------------------------------') DCNL DCSP  DCSP log('Tasks DCSP still DCSP running:') DCNL DCSP  DCSP for task_details in running_tasks_data: DCNL DCSP  DCSP  DCSP log(task_details)
 DCSP remaining_tasks = ([] + tasks) DCNL DCSP currently_running_tasks = set([]) DCNL DCSP while (remaining_tasks or currently_running_tasks): DCNL DCSP  DCSP if currently_running_tasks: DCNL DCSP  DCSP  DCSP for task in list(currently_running_tasks): DCNL DCSP  DCSP  DCSP  DCSP task.join(1) DCNL DCSP  DCSP  DCSP  DCSP if (not task.isAlive()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP currently_running_tasks.remove(task) DCNL DCSP  DCSP while (remaining_tasks and (len(currently_running_tasks) < batch_size)): DCNL DCSP  DCSP  DCSP task = remaining_tasks.pop() DCNL DCSP  DCSP  DCSP currently_running_tasks.add(task) DCNL DCSP  DCSP  DCSP task.start() DCNL DCSP  DCSP  DCSP task.start_time = time.time() DCNL DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP if remaining_tasks: DCNL DCSP  DCSP  DCSP log('----------------------------------------') DCNL DCSP  DCSP  DCSP log(('Number DCSP of DCSP unstarted DCSP tasks: DCSP %s' % len(remaining_tasks))) DCNL DCSP  DCSP _check_all_tasks(tasks) DCNL DCSP  DCSP log('----------------------------------------')
 DCSP def _convert_to_test_target(path): DCNL DCSP  DCSP 'Remove DCSP the DCSP .py DCSP suffix DCSP and DCSP replace DCSP all DCSP slashes DCSP with DCSP periods.' DCNL DCSP  DCSP return os.path.relpath(path, os.getcwd())[:(-3)].replace('/', '.') DCNL DCSP base_path = os.path.join(os.getcwd(), (test_path or '')) DCNL DCSP result = [] DCNL DCSP for root in os.listdir(base_path): DCNL DCSP  DCSP if any([(s in root) for s in ['.git', 'third_party', 'core/tests']]): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if root.endswith('_test.py'): DCNL DCSP  DCSP  DCSP result.append(_convert_to_test_target(os.path.join(base_path, root))) DCNL DCSP  DCSP for (subroot, _, files) in os.walk(os.path.join(base_path, root)): DCNL DCSP  DCSP  DCSP for f in files: DCNL DCSP  DCSP  DCSP  DCSP if (f.endswith('_test.py') and (os.path.join('core', 'tests') not in subroot)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.append(_convert_to_test_target(os.path.join(subroot, f))) DCNL DCSP return result
 DCSP parsed_args = _PARSER.parse_args() DCNL DCSP if (parsed_args.test_target and parsed_args.test_path): DCNL DCSP  DCSP raise Exception('At DCSP most DCSP one DCSP of DCSP test_path DCSP and DCSP test_target DCSP should DCSP be DCSP specified.') DCNL DCSP if (parsed_args.test_path and ('.' in parsed_args.test_path)): DCNL DCSP  DCSP raise Exception('The DCSP delimiter DCSP in DCSP test_path DCSP should DCSP be DCSP a DCSP slash DCSP (/)') DCNL DCSP if (parsed_args.test_target and ('/' in parsed_args.test_target)): DCNL DCSP  DCSP raise Exception('The DCSP delimiter DCSP in DCSP test_target DCSP should DCSP be DCSP a DCSP dot DCSP (.)') DCNL DCSP if parsed_args.test_target: DCNL DCSP  DCSP all_test_targets = [parsed_args.test_target] DCNL DCSP else: DCNL DCSP  DCSP all_test_targets = _get_all_test_targets(test_path=parsed_args.test_path) DCNL DCSP task_to_taskspec = {} DCNL DCSP tasks = [] DCNL DCSP for test_target in all_test_targets: DCNL DCSP  DCSP test = TestingTaskSpec(test_target, parsed_args.generate_coverage_report) DCNL DCSP  DCSP task = TaskThread(test.run, parsed_args.verbose, name=test_target) DCNL DCSP  DCSP task_to_taskspec[task] = test DCNL DCSP  DCSP tasks.append(task) DCNL DCSP task_execution_failed = False DCNL DCSP try: DCNL DCSP  DCSP _execute_tasks(tasks) DCNL DCSP except Exception: DCNL DCSP  DCSP task_execution_failed = True DCNL DCSP for task in tasks: DCNL DCSP  DCSP if task.exception: DCNL DCSP  DCSP  DCSP log(str(task.exception)) DCNL DCSP print '' DCNL DCSP print '+------------------+' DCNL DCSP print '| DCSP SUMMARY DCSP OF DCSP TESTS DCSP |' DCNL DCSP print '+------------------+' DCNL DCSP print '' DCNL DCSP total_count = 0 DCNL DCSP total_errors = 0 DCNL DCSP total_failures = 0 DCNL DCSP for task in tasks: DCNL DCSP  DCSP spec = task_to_taskspec[task] DCNL DCSP  DCSP if (not task.finished): DCNL DCSP  DCSP  DCSP print ('CANCELED DCSP  DCSP %s' % spec.test_target) DCNL DCSP  DCSP  DCSP test_count = 0 DCNL DCSP  DCSP elif ('No DCSP tests DCSP were DCSP run' in str(task.exception)): DCNL DCSP  DCSP  DCSP print ('ERROR DCSP  DCSP  DCSP  DCSP  DCSP %s: DCSP No DCSP tests DCSP found.' % spec.test_target) DCNL DCSP  DCSP  DCSP test_count = 0 DCNL DCSP  DCSP elif task.exception: DCNL DCSP  DCSP  DCSP exc_str = str(task.exception).decode('utf-8') DCNL DCSP  DCSP  DCSP print exc_str[exc_str.find('='):exc_str.rfind('-')] DCNL DCSP  DCSP  DCSP tests_failed_regex_match = re.search('Test DCSP suite DCSP failed: DCSP ([0-9]+) DCSP tests DCSP run, DCSP ([0-9]+) DCSP errors, DCSP ([0-9]+) DCSP failures', str(task.exception)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP test_count = int(tests_failed_regex_match.group(1)) DCNL DCSP  DCSP  DCSP  DCSP errors = int(tests_failed_regex_match.group(2)) DCNL DCSP  DCSP  DCSP  DCSP failures = int(tests_failed_regex_match.group(3)) DCNL DCSP  DCSP  DCSP  DCSP total_errors += errors DCNL DCSP  DCSP  DCSP  DCSP total_failures += failures DCNL DCSP  DCSP  DCSP  DCSP print ('FAILED DCSP  DCSP  DCSP  DCSP %s: DCSP %s DCSP errors, DCSP %s DCSP failures' % (spec.test_target, errors, failures)) DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP test_count = 0 DCNL DCSP  DCSP  DCSP  DCSP print '' DCNL DCSP  DCSP  DCSP  DCSP print '------------------------------------------------------' DCNL DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP  DCSP WARNING: DCSP FAILED DCSP TO DCSP RUN DCSP TESTS.' DCNL DCSP  DCSP  DCSP  DCSP print '' DCNL DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP  DCSP This DCSP is DCSP most DCSP likely DCSP due DCSP to DCSP an DCSP import DCSP error.' DCNL DCSP  DCSP  DCSP  DCSP print '------------------------------------------------------' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP tests_run_regex_match = re.search('Ran DCSP ([0-9]+) DCSP tests? DCSP in DCSP ([0-9\\.]+)s', task.output) DCNL DCSP  DCSP  DCSP  DCSP test_count = int(tests_run_regex_match.group(1)) DCNL DCSP  DCSP  DCSP  DCSP test_time = float(tests_run_regex_match.group(2)) DCNL DCSP  DCSP  DCSP  DCSP print ('SUCCESS DCSP  DCSP  DCSP %s: DCSP %d DCSP tests DCSP (%.1f DCSP secs)' % (spec.test_target, test_count, test_time)) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP print ('An DCSP unexpected DCSP error DCSP occurred. DCSP Task DCSP output:\n%s' % task.output) DCNL DCSP  DCSP total_count += test_count DCNL DCSP print '' DCNL DCSP if (total_count == 0): DCNL DCSP  DCSP raise Exception('WARNING: DCSP No DCSP tests DCSP were DCSP run.') DCNL DCSP else: DCNL DCSP  DCSP print ('Ran DCSP %s DCSP test%s DCSP in DCSP %s DCSP test DCSP class%s.' % (total_count, ('' if (total_count == 1) else 's'), len(tasks), ('' if (len(tasks) == 1) else 'es'))) DCNL DCSP  DCSP if (total_errors or total_failures): DCNL DCSP  DCSP  DCSP print ('(%s DCSP ERRORS, DCSP %s DCSP FAILURES)' % (total_errors, total_failures)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print 'All DCSP tests DCSP passed.' DCNL DCSP if task_execution_failed: DCNL DCSP  DCSP raise Exception('Task DCSP execution DCSP failed.') DCNL DCSP elif (total_errors or total_failures): DCNL DCSP  DCSP raise Exception(('%s DCSP errors, DCSP %s DCSP failures' % (total_errors, total_failures)))
 DCSP return subprocess.check_output(cmd_str.split(' DCSP ')).strip()
 DCSP get_logs_cmd = GIT_CMD_GET_LOGS_FORMAT_STRING.format(GROUP_SEP, start, stop) DCNL DCSP out = _run_cmd(get_logs_cmd).split('\x00') DCNL DCSP if ((len(out) == 1) and (out[0] == '')): DCNL DCSP  DCSP return [] DCNL DCSP else: DCNL DCSP  DCSP return [Log(*line.strip().split(GROUP_SEP)) for line in out]
 DCSP issues = ISSUE_REGEX.findall(' DCSP '.join([log.message for log in logs])) DCNL DCSP links = {(ISSUE_URL_FORMAT_STRING % issue) for issue in issues} DCNL DCSP return links
 DCSP feconf_changed_version = [] DCNL DCSP git_show_cmd = (GIT_CMD_SHOW_FORMAT_STRING % current_release) DCNL DCSP old_feconf = _run_cmd(git_show_cmd) DCNL DCSP with open('feconf.py', 'r') as feconf: DCNL DCSP  DCSP new_feconf = feconf.read() DCNL DCSP for variable in FECONF_VAR_NAMES: DCNL DCSP  DCSP old_version = re.findall((VERSION_RE_FORMAT_STRING % variable), old_feconf)[0] DCNL DCSP  DCSP new_version = re.findall((VERSION_RE_FORMAT_STRING % variable), new_feconf)[0] DCNL DCSP  DCSP if (old_version != new_version): DCNL DCSP  DCSP  DCSP feconf_changed_version.append(variable) DCNL DCSP return feconf_changed_version
 DCSP diff_cmd = (GIT_CMD_DIFF_NAMES_ONLY_FORMAT_STRING % (left, right)) DCNL DCSP return _run_cmd(diff_cmd).splitlines()
 DCSP setup_scripts = [('scripts/%s' % item) for item in ['setup.sh', 'setup_gae.sh', 'install_third_party.sh', 'install_third_party.py']] DCNL DCSP changed_files = _git_diff_names_only(base_release_tag) DCNL DCSP changes_dict = {script: (script in changed_files) for script in setup_scripts} DCNL DCSP if changed_only: DCNL DCSP  DCSP return {name: status for (name, status) in changes_dict.items() if status} DCNL DCSP else: DCNL DCSP  DCSP return changes_dict
 DCSP diff_list = _git_diff_names_only(current_release) DCNL DCSP return [item for item in diff_list if item.startswith('core/storage')]
 DCSP with ChangedBranch('develop'): DCNL DCSP  DCSP current_release = _run_cmd(GIT_CMD_GET_CURRENT_VERSION) DCNL DCSP  DCSP logs = _gather_logs(current_release) DCNL DCSP  DCSP issue_links = _extract_issues(logs) DCNL DCSP  DCSP feconf_version_changes = _check_versions(current_release) DCNL DCSP  DCSP setup_changes = _check_setup_scripts(current_release) DCNL DCSP  DCSP storage_changes = _check_storage_models(current_release) DCNL DCSP summary_file = os.path.join(os.getcwd(), os.pardir, 'release_summary.md') DCNL DCSP with open(summary_file, 'w') as out: DCNL DCSP  DCSP out.write('## DCSP Collected DCSP release DCSP information\n') DCNL DCSP  DCSP if feconf_version_changes: DCNL DCSP  DCSP  DCSP out.write('\n### DCSP Feconf DCSP version DCSP changes:\nThis DCSP indicates DCSP that DCSP a DCSP migration DCSP may DCSP be DCSP needed\n\n') DCNL DCSP  DCSP  DCSP for var in feconf_version_changes: DCNL DCSP  DCSP  DCSP  DCSP out.write(('* DCSP %s DCSP  DCSP \n' % var)) DCNL DCSP  DCSP if setup_changes: DCNL DCSP  DCSP  DCSP out.write('\n### DCSP Changed DCSP setup DCSP scripts:\n') DCNL DCSP  DCSP  DCSP for var in setup_changes.keys(): DCNL DCSP  DCSP  DCSP  DCSP out.write(('* DCSP %s DCSP  DCSP \n' % var)) DCNL DCSP  DCSP if storage_changes: DCNL DCSP  DCSP  DCSP out.write('\n### DCSP Changed DCSP storage DCSP models:\n') DCNL DCSP  DCSP  DCSP for item in storage_changes: DCNL DCSP  DCSP  DCSP  DCSP out.write(('* DCSP %s DCSP  DCSP \n' % item)) DCNL DCSP  DCSP out.write('\n### DCSP Authors:\n') DCNL DCSP  DCSP for (name, email) in sorted({(log.author, log.email) for log in logs}): DCNL DCSP  DCSP  DCSP out.write(('%s DCSP <%s> DCSP  DCSP \n' % (name, email))) DCNL DCSP  DCSP out.write('\n### DCSP Commit DCSP History:\n') DCNL DCSP  DCSP for (name, title) in [(log.author, log.message.split('\n\n')[0]) for log in logs]: DCNL DCSP  DCSP  DCSP out.write(('* DCSP %s\n' % title)) DCNL DCSP  DCSP if issue_links: DCNL DCSP  DCSP  DCSP out.write('\n### DCSP Issues DCSP mentioned DCSP in DCSP commits:\n') DCNL DCSP  DCSP  DCSP for link in issue_links: DCNL DCSP  DCSP  DCSP  DCSP out.write(('* DCSP [%s](%s) DCSP  DCSP \n' % (link, link))) DCNL DCSP print 'Done. DCSP Summary DCSP file DCSP generated DCSP in DCSP ../release_summary.md'
 DCSP if (not os.path.exists(d)): DCNL DCSP  DCSP os.makedirs(d)
 DCSP is_oppia_dir = os.getcwd().endswith('oppia') DCNL DCSP current_dirname = os.path.basename(os.path.normpath(os.getcwd())) DCNL DCSP is_deploy_dir = (current_dirname.startswith('deploy-') and os.path.isdir(os.path.join(os.getcwd(), '..', 'oppia'))) DCNL DCSP if (is_oppia_dir or (allow_deploy_dir and is_deploy_dir)): DCNL DCSP  DCSP return DCNL DCSP raise Exception('Please DCSP run DCSP this DCSP script DCSP from DCSP the DCSP oppia/ DCSP directory.')
 DCSP cmd = ('java DCSP -jar DCSP %s DCSP %s DCSP -o DCSP %s' % (YUICOMPRESSOR_DIR, source_path, target_path)) DCNL DCSP subprocess.check_call(cmd, shell=True)
 DCSP (filepath, file_extension) = os.path.splitext(filepath) DCNL DCSP return ('%s.%s%s' % (filepath, file_hash, file_extension))
 DCSP directory = os.path.dirname(filepath) DCNL DCSP if (not os.path.exists(directory)): DCNL DCSP  DCSP os.makedirs(directory)
 DCSP f = open(source_path, 'r') DCNL DCSP content = f.read() DCNL DCSP for (filepath, file_hash) in file_hashes.iteritems(): DCNL DCSP  DCSP if filepath.endswith('.html'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP filepath_with_hash = _insert_hash(filepath, file_hash) DCNL DCSP  DCSP content = content.replace(filepath, filepath_with_hash) DCNL DCSP content = REMOVE_WS(' DCSP ', content) DCNL DCSP ensure_directory_exists(target_path) DCNL DCSP d = open(target_path, 'w+') DCNL DCSP d.write(content)
 DCSP ensure_directory_exists(target_path) DCNL DCSP _minify(source_path, target_path)
 DCSP ensure_directory_exists(target_path) DCNL DCSP _minify(source_path, target_path)
 DCSP parent_dir = os.path.abspath(os.path.join(os.getcwd(), os.pardir)) DCNL DCSP node_path = os.path.join(parent_dir, 'oppia_tools', 'node-6.9.1', 'bin', 'node') DCNL DCSP gulp_path = os.path.join(parent_dir, 'node_modules', 'gulp', 'bin', 'gulp.js') DCNL DCSP gulp_build_cmd = [node_path, gulp_path, 'build', '--minify=True', ('--output_directory=%s' % output_directory)] DCNL DCSP proc = subprocess.Popen(gulp_build_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (gulp_stdout, gulp_stderr) = proc.communicate() DCNL DCSP if gulp_stdout: DCNL DCSP  DCSP print gulp_stdout DCNL DCSP if gulp_stderr: DCNL DCSP  DCSP print 'Gulp DCSP build DCSP process DCSP failed.Exiting' DCNL DCSP  DCSP print '----------------------------------------' DCNL DCSP  DCSP print gulp_stderr DCNL DCSP  DCSP sys.exit(1)
 DCSP return (not any((fnmatch.fnmatch(filepath, pattern) for pattern in FILEPATHS_NOT_TO_RENAME)))
 DCSP print ('Processing DCSP %s' % os.path.join(os.getcwd(), source)) DCNL DCSP print ('Copying DCSP into DCSP %s' % os.path.join(os.getcwd(), target)) DCNL DCSP ensure_directory_exists(target) DCNL DCSP shutil.rmtree(target) DCNL DCSP for (root, dirs, files) in os.walk(os.path.join(os.getcwd(), source)): DCNL DCSP  DCSP for directory in dirs: DCNL DCSP  DCSP  DCSP print ('Processing DCSP %s' % os.path.join(root, directory)) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP source_path = os.path.join(root, filename) DCNL DCSP  DCSP  DCSP if (target in source_path): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (source not in source_path): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if any((source_path.endswith(p) for p in FILE_EXTENSIONS_TO_IGNORE)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP target_path = source_path DCNL DCSP  DCSP  DCSP relative_path = os.path.relpath(source_path, source) DCNL DCSP  DCSP  DCSP if hash_should_be_inserted((source + relative_path)): DCNL DCSP  DCSP  DCSP  DCSP relative_path = _insert_hash(relative_path, file_hashes[relative_path]) DCNL DCSP  DCSP  DCSP target_path = os.path.join(os.getcwd(), target, relative_path) DCNL DCSP  DCSP  DCSP ensure_directory_exists(target_path) DCNL DCSP  DCSP  DCSP shutil.copyfile(source_path, target_path)
 DCSP return any((fnmatch.fnmatch(filepath, pattern) for pattern in FILEPATHS_PROVIDED_TO_FRONTEND))
 DCSP m = hashlib.md5() DCNL DCSP with open(filepath, 'rb') as f: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP buf = f.read(HASH_BLOCK_SIZE) DCNL DCSP  DCSP  DCSP if (not buf): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP m.update(buf) DCNL DCSP return m.hexdigest()
 DCSP file_hashes = dict() DCNL DCSP print ('Computing DCSP hashes DCSP for DCSP files DCSP in DCSP %s' % os.path.join(os.getcwd(), directory_path)) DCNL DCSP for (root, dirs, files) in os.walk(os.path.join(os.getcwd(), directory_path)): DCNL DCSP  DCSP for directory in dirs: DCNL DCSP  DCSP  DCSP print ('Computing DCSP hashes DCSP for DCSP files DCSP in DCSP %s' % os.path.join(root, directory)) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP filepath = os.path.join(root, filename) DCNL DCSP  DCSP  DCSP relative_filepath = os.path.relpath(filepath, directory_path) DCNL DCSP  DCSP  DCSP file_hashes[relative_filepath] = generate_md5_hash(filepath) DCNL DCSP return file_hashes
 DCSP filtered_hashes = dict() DCNL DCSP for (filepath, file_hash) in file_hashes.iteritems(): DCNL DCSP  DCSP if is_file_hash_provided_to_frontend(filepath): DCNL DCSP  DCSP  DCSP filtered_hashes[('/' + filepath)] = file_hash DCNL DCSP return filtered_hashes
 DCSP filtered_hashes = filter_hashes(file_hashes) DCNL DCSP hashes_json = json.dumps(filtered_hashes) DCNL DCSP return ("var DCSP hashes DCSP = DCSP JSON.parse('%s');" % hashes_json)
 DCSP with open(target_filepath, 'w') as f: DCNL DCSP  DCSP f.write(get_hashes_json_file_contents(file_hashes)) DCNL DCSP file_hash = generate_md5_hash(target_filepath) DCNL DCSP relative_filepath = os.path.relpath(target_filepath, os.path.join(os.path.curdir, 'build')) DCNL DCSP filepath_with_hash = _insert_hash(target_filepath, file_hash) DCNL DCSP os.rename(target_filepath, filepath_with_hash) DCNL DCSP file_hashes[relative_filepath] = file_hash
 DCSP print ('Processing DCSP %s' % os.path.join(os.getcwd(), source)) DCNL DCSP print ('Generating DCSP into DCSP %s' % os.path.join(os.getcwd(), target)) DCNL DCSP ensure_directory_exists(target) DCNL DCSP shutil.rmtree(target) DCNL DCSP for (root, dirs, files) in os.walk(os.path.join(os.getcwd(), source)): DCNL DCSP  DCSP for directory in dirs: DCNL DCSP  DCSP  DCSP print ('Processing DCSP %s' % os.path.join(root, directory)) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP source_path = os.path.join(root, filename) DCNL DCSP  DCSP  DCSP if (target in source_path): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (source not in source_path): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP target_path = source_path.replace(source, target) DCNL DCSP  DCSP  DCSP if filename.endswith('.html'): DCNL DCSP  DCSP  DCSP  DCSP process_html(source_path, target_path, file_hashes) DCNL DCSP  DCSP  DCSP elif filename.endswith('.css'): DCNL DCSP  DCSP  DCSP  DCSP process_css(source_path, target_path) DCNL DCSP  DCSP  DCSP elif filename.endswith('.js'): DCNL DCSP  DCSP  DCSP  DCSP process_js(source_path, target_path) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ensure_directory_exists(target_path) DCNL DCSP  DCSP  DCSP  DCSP shutil.copyfile(source_path, target_path)
 DCSP hashes = dict() DCNL DCSP hashes.update(get_file_hashes(ASSETS_SRC_DIR)) DCNL DCSP copy_files_source_to_target(ASSETS_SRC_DIR, ASSETS_OUT_DIR, hashes) DCNL DCSP build_minified_third_party_libs(THIRD_PARTY_GENERATED_STAGING_DIR) DCNL DCSP hashes.update(get_file_hashes(THIRD_PARTY_GENERATED_STAGING_DIR)) DCNL DCSP copy_files_source_to_target(THIRD_PARTY_GENERATED_STAGING_DIR, THIRD_PARTY_GENERATED_OUT_DIR, hashes) DCNL DCSP hashes.update(get_file_hashes(EXTENSIONS_DEV_DIR)) DCNL DCSP build_files(EXTENSIONS_DEV_DIR, EXTENSIONS_STAGING_DIR, hashes) DCNL DCSP copy_files_source_to_target(EXTENSIONS_STAGING_DIR, EXTENSIONS_OUT_DIR, hashes) DCNL DCSP hashes.update(get_file_hashes(TEMPLATES_DEV_DIR)) DCNL DCSP save_hashes_as_json(HASHES_JSON, hashes) DCNL DCSP build_files(TEMPLATES_DEV_DIR, TEMPLATES_STAGING_DIR, hashes) DCNL DCSP copy_files_source_to_target(TEMPLATES_STAGING_DIR, TEMPLATES_OUT_DIR, hashes)
 DCSP assert isinstance(source_filenames, list) DCNL DCSP common.ensure_directory_exists(target_dir) DCNL DCSP for filename in source_filenames: DCNL DCSP  DCSP if (not os.path.exists(os.path.join(target_dir, filename))): DCNL DCSP  DCSP  DCSP print ('Downloading DCSP file DCSP %s DCSP to DCSP %s' % (filename, target_dir)) DCNL DCSP  DCSP  DCSP urllib.urlretrieve(('%s/%s' % (source_url_root, filename)), os.path.join(target_dir, filename))
 DCSP if (not os.path.exists(os.path.join(target_parent_dir, target_root_name))): DCNL DCSP  DCSP print ('Downloading DCSP and DCSP unzipping DCSP file DCSP %s DCSP to DCSP %s' % (zip_root_name, target_parent_dir)) DCNL DCSP  DCSP common.ensure_directory_exists(target_parent_dir) DCNL DCSP  DCSP urllib.urlretrieve(source_url, TMP_UNZIP_PATH) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with zipfile.ZipFile(TMP_UNZIP_PATH, 'r') as zfile: DCNL DCSP  DCSP  DCSP  DCSP zfile.extractall(target_parent_dir) DCNL DCSP  DCSP  DCSP os.remove(TMP_UNZIP_PATH) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP if os.path.exists(TMP_UNZIP_PATH): DCNL DCSP  DCSP  DCSP  DCSP os.remove(TMP_UNZIP_PATH) DCNL DCSP  DCSP  DCSP req = urllib2.Request(source_url) DCNL DCSP  DCSP  DCSP req.add_header('User-agent', 'python') DCNL DCSP  DCSP  DCSP file_stream = StringIO.StringIO(urllib2.urlopen(req).read()) DCNL DCSP  DCSP  DCSP with zipfile.ZipFile(file_stream, 'r') as zfile: DCNL DCSP  DCSP  DCSP  DCSP zfile.extractall(target_parent_dir) DCNL DCSP  DCSP os.rename(os.path.join(target_parent_dir, zip_root_name), os.path.join(target_parent_dir, target_root_name))
 DCSP if (not os.path.exists(os.path.join(target_parent_dir, target_root_name))): DCNL DCSP  DCSP print ('Downloading DCSP and DCSP untarring DCSP file DCSP %s DCSP to DCSP %s' % (tar_root_name, target_parent_dir)) DCNL DCSP  DCSP common.ensure_directory_exists(target_parent_dir) DCNL DCSP  DCSP urllib.urlretrieve(source_url, TMP_UNZIP_PATH) DCNL DCSP  DCSP with contextlib.closing(tarfile.open(TMP_UNZIP_PATH, 'r:gz')) as tfile: DCNL DCSP  DCSP  DCSP tfile.extractall(target_parent_dir) DCNL DCSP  DCSP os.remove(TMP_UNZIP_PATH) DCNL DCSP  DCSP os.rename(os.path.join(target_parent_dir, tar_root_name), os.path.join(target_parent_dir, target_root_name))
 DCSP with open(filepath, mode) as f: DCNL DCSP  DCSP return f.read().decode('utf-8')
 DCSP response = get_file_contents(filepath) DCNL DCSP return json.loads(response)
 DCSP keys = dependency_dict.keys() DCNL DCSP mandatory_keys = DOWNLOAD_FORMATS_TO_MANIFEST_KEYS[dependency_type]['mandatory_keys'] DCNL DCSP optional_key_pairs = DOWNLOAD_FORMATS_TO_MANIFEST_KEYS[dependency_type]['optional_key_pairs'] DCNL DCSP for key in mandatory_keys: DCNL DCSP  DCSP if (key not in keys): DCNL DCSP  DCSP  DCSP print '------------------------------------------' DCNL DCSP  DCSP  DCSP print 'There DCSP is DCSP syntax DCSP error DCSP in DCSP this DCSP dependency' DCNL DCSP  DCSP  DCSP print dependency_dict DCNL DCSP  DCSP  DCSP print ('This DCSP key DCSP is DCSP missing DCSP or DCSP misspelled: DCSP "%s".' % key) DCNL DCSP  DCSP  DCSP print 'Exiting' DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP if optional_key_pairs: DCNL DCSP  DCSP for optional_keys in optional_key_pairs: DCNL DCSP  DCSP  DCSP optional_keys_in_dict = [key for key in optional_keys if (key in keys)] DCNL DCSP  DCSP  DCSP if (len(optional_keys_in_dict) != 1): DCNL DCSP  DCSP  DCSP  DCSP print '------------------------------------------' DCNL DCSP  DCSP  DCSP  DCSP print 'There DCSP is DCSP syntax DCSP error DCSP in DCSP this DCSP dependency' DCNL DCSP  DCSP  DCSP  DCSP print dependency_dict DCNL DCSP  DCSP  DCSP  DCSP print ('Only DCSP one DCSP of DCSP these DCSP keys DCSP pair DCSP must DCSP be DCSP used: DCSP "%s".' % str(optional_keys)) DCNL DCSP  DCSP  DCSP  DCSP print 'Exiting' DCNL DCSP  DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP dependency_url = dependency_dict['url'] DCNL DCSP if ('#' in dependency_url): DCNL DCSP  DCSP dependency_url = dependency_url.rpartition('#')[0] DCNL DCSP is_zip_file_format = (dependency_type == _DOWNLOAD_FORMAT_ZIP) DCNL DCSP is_tar_file_format = (dependency_type == _DOWNLOAD_FORMAT_TAR) DCNL DCSP if ((dependency_url.endswith('.zip') and (not is_zip_file_format)) or (is_zip_file_format and (not dependency_url.endswith('.zip'))) or (dependency_url.endswith('.tar.gz') and (not is_tar_file_format)) or (is_tar_file_format and (not dependency_url.endswith('.tar.gz')))): DCNL DCSP  DCSP print '------------------------------------------' DCNL DCSP  DCSP print 'There DCSP is DCSP syntax DCSP error DCSP in DCSP this DCSP dependency' DCNL DCSP  DCSP print dependency_dict DCNL DCSP  DCSP print ('This DCSP url DCSP  DCSP %s DCSP is DCSP invalid DCSP for DCSP %s DCSP file DCSP format.' % (dependency_url, dependency_type)) DCNL DCSP  DCSP print 'Exiting.' DCNL DCSP  DCSP sys.exit(1)
 DCSP manifest_data = return_json(filepath) DCNL DCSP dependencies = manifest_data['dependencies'] DCNL DCSP for (_, dependency) in dependencies.items(): DCNL DCSP  DCSP for (_, dependency_contents) in dependency.items(): DCNL DCSP  DCSP  DCSP if ('downloadFormat' not in dependency_contents): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('downloadFormat DCSP not DCSP specified DCSP in DCSP %s' % dependency_contents)) DCNL DCSP  DCSP  DCSP download_format = dependency_contents['downloadFormat'] DCNL DCSP  DCSP  DCSP test_manifest_syntax(download_format, dependency_contents)
 DCSP validate_manifest(filepath) DCNL DCSP manifest_data = return_json(filepath) DCNL DCSP dependencies = manifest_data['dependencies'] DCNL DCSP for (data, dependency) in dependencies.items(): DCNL DCSP  DCSP for (_, dependency_contents) in dependency.items(): DCNL DCSP  DCSP  DCSP dependency_rev = dependency_contents['version'] DCNL DCSP  DCSP  DCSP dependency_url = dependency_contents['url'] DCNL DCSP  DCSP  DCSP download_format = dependency_contents['downloadFormat'] DCNL DCSP  DCSP  DCSP if (download_format == _DOWNLOAD_FORMAT_FILES): DCNL DCSP  DCSP  DCSP  DCSP dependency_files = dependency_contents['files'] DCNL DCSP  DCSP  DCSP  DCSP target_dirname = (dependency_contents['targetDirPrefix'] + dependency_rev) DCNL DCSP  DCSP  DCSP  DCSP dependency_dst = os.path.join(TARGET_DOWNLOAD_DIRS[data], target_dirname) DCNL DCSP  DCSP  DCSP  DCSP download_files(dependency_url, dependency_dst, dependency_files) DCNL DCSP  DCSP  DCSP elif (download_format == _DOWNLOAD_FORMAT_ZIP): DCNL DCSP  DCSP  DCSP  DCSP if ('rootDir' in dependency_contents): DCNL DCSP  DCSP  DCSP  DCSP  DCSP dependency_zip_root_name = dependency_contents['rootDir'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP dependency_zip_root_name = (dependency_contents['rootDirPrefix'] + dependency_rev) DCNL DCSP  DCSP  DCSP  DCSP if ('targetDir' in dependency_contents): DCNL DCSP  DCSP  DCSP  DCSP  DCSP dependency_target_root_name = dependency_contents['targetDir'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP dependency_target_root_name = (dependency_contents['targetDirPrefix'] + dependency_rev) DCNL DCSP  DCSP  DCSP  DCSP download_and_unzip_files(dependency_url, TARGET_DOWNLOAD_DIRS[data], dependency_zip_root_name, dependency_target_root_name) DCNL DCSP  DCSP  DCSP elif (download_format == _DOWNLOAD_FORMAT_TAR): DCNL DCSP  DCSP  DCSP  DCSP dependency_tar_root_name = (dependency_contents['tarRootDirPrefix'] + dependency_rev) DCNL DCSP  DCSP  DCSP  DCSP dependency_target_root_name = (dependency_contents['targetDirPrefix'] + dependency_rev) DCNL DCSP  DCSP  DCSP  DCSP download_and_untar_files(dependency_url, TARGET_DOWNLOAD_DIRS[data], dependency_tar_root_name, dependency_target_root_name)
 DCSP f = open('app.yaml', 'r') DCNL DCSP content = f.read() DCNL DCSP os.remove('app.yaml') DCNL DCSP content = content.replace('oppiaserver', APP_NAME) DCNL DCSP d = open('app.yaml', 'w+') DCNL DCSP d.write(content) DCNL DCSP if (not os.path.exists(DEPLOY_DATA_PATH)): DCNL DCSP  DCSP raise Exception(('Could DCSP not DCSP find DCSP deploy_data DCSP directory DCSP at DCSP %s' % DEPLOY_DATA_PATH)) DCNL DCSP for filename in FILES_AT_ROOT_IN_COMMON: DCNL DCSP  DCSP src = os.path.join(DEPLOY_DATA_PATH, 'common', filename) DCNL DCSP  DCSP dst = os.path.join(os.getcwd(), 'assets', 'common', filename) DCNL DCSP  DCSP if (not os.path.exists(src)): DCNL DCSP  DCSP  DCSP raise Exception(('Could DCSP not DCSP find DCSP source DCSP path DCSP %s. DCSP Please DCSP check DCSP your DCSP deploy_data DCSP folder.' % src)) DCNL DCSP  DCSP if (not os.path.exists(dst)): DCNL DCSP  DCSP  DCSP raise Exception(('Could DCSP not DCSP find DCSP destination DCSP path DCSP %s. DCSP Has DCSP the DCSP code DCSP been DCSP updated DCSP in DCSP the DCSP meantime?' % dst)) DCNL DCSP  DCSP shutil.copyfile(src, dst) DCNL DCSP for dir_name in IMAGE_DIRS: DCNL DCSP  DCSP src_dir = os.path.join(DEPLOY_DATA_PATH, 'images', dir_name) DCNL DCSP  DCSP dst_dir = os.path.join(os.getcwd(), 'assets', 'images', dir_name) DCNL DCSP  DCSP if (not os.path.exists(src_dir)): DCNL DCSP  DCSP  DCSP raise Exception(('Could DCSP not DCSP find DCSP source DCSP dir DCSP %s. DCSP Please DCSP check DCSP your DCSP deploy_data DCSP folder.' % src_dir)) DCNL DCSP  DCSP common.ensure_directory_exists(dst_dir) DCNL DCSP  DCSP for filename in os.listdir(src_dir): DCNL DCSP  DCSP  DCSP src = os.path.join(src_dir, filename) DCNL DCSP  DCSP  DCSP dst = os.path.join(dst_dir, filename) DCNL DCSP  DCSP  DCSP shutil.copyfile(src, dst)
 DCSP unique_id = ''.join((random.choice((string.ascii_lowercase + string.digits)) for _ in range(CACHE_SLUG_PROD_LENGTH))) DCNL DCSP return unique_id
 DCSP f = open('app.yaml', 'r') DCNL DCSP content = f.read() DCNL DCSP os.remove('app.yaml') DCNL DCSP content = content.replace('oppiaserver', APP_NAME) DCNL DCSP d = open('app.yaml', 'w+') DCNL DCSP d.write(content)
 DCSP task = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (out, err) = task.communicate() DCNL DCSP return (out, err)
 DCSP git_cmd = ['git', 'diff', '--name-status'] DCNL DCSP if diff_filter: DCNL DCSP  DCSP git_cmd.append('--diff-filter={}'.format(diff_filter)) DCNL DCSP git_cmd.extend([left, right]) DCNL DCSP (out, err) = _start_subprocess_for_result(git_cmd) DCNL DCSP if (not err): DCNL DCSP  DCSP file_list = [] DCNL DCSP  DCSP for line in out.splitlines(): DCNL DCSP  DCSP  DCSP file_list.append(FileDiff(line[0], line[(line.rfind(' DCTB ') + 1):])) DCNL DCSP  DCSP return file_list DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(err)
 DCSP remote_branch = (remote_branch if remote_branch else local_branch) DCNL DCSP git_remote = ('%s/%s' % (remote, remote_branch)) DCNL DCSP return _git_diff_name_status(git_remote, local_branch)
 DCSP if (not file_diffs): DCNL DCSP  DCSP return [] DCNL DCSP lint_files = [f.name for f in file_diffs if (f.status.upper() in 'ACMRT')] DCNL DCSP return lint_files
 DCSP if (not ref_list): DCNL DCSP  DCSP return {} DCNL DCSP ref_heads_only = [ref for ref in ref_list if ref.local_ref.startswith('refs/heads/')] DCNL DCSP branches = [ref.local_ref.split('/')[(-1)] for ref in ref_heads_only] DCNL DCSP hashes = [ref.local_sha1 for ref in ref_heads_only] DCNL DCSP remote_hashes = [ref.remote_sha1 for ref in ref_heads_only] DCNL DCSP collected_files = {} DCNL DCSP for (branch, sha1, remote_sha1) in zip(branches, hashes, remote_hashes): DCNL DCSP  DCSP if (set(remote_sha1) != {'0'}): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP modified_files = _compare_to_remote(remote, branch) DCNL DCSP  DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP  DCSP print e.message DCNL DCSP  DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP modified_files = _compare_to_remote(remote, branch, remote_branch='develop') DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP modified_files = _git_diff_name_status(GIT_NULL_COMMIT, sha1) DCNL DCSP  DCSP  DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print e.message DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP files_to_lint = _extract_files_to_lint(modified_files) DCNL DCSP  DCSP collected_files[branch] = (modified_files, files_to_lint) DCNL DCSP for (branch, (modified_files, files_to_lint)) in collected_files.iteritems(): DCNL DCSP  DCSP if modified_files: DCNL DCSP  DCSP  DCSP print ('\nModified DCSP files DCSP in DCSP %s:' % branch) DCNL DCSP  DCSP  DCSP pprint.pprint(modified_files) DCNL DCSP  DCSP  DCSP print ('\nFiles DCSP to DCSP lint DCSP in DCSP %s:' % branch) DCNL DCSP  DCSP  DCSP pprint.pprint(files_to_lint) DCNL DCSP  DCSP  DCSP print '\n' DCNL DCSP return collected_files
 DCSP uncommitted_files = subprocess.check_output(GIT_IS_DIRTY_CMD.split(' DCSP ')) DCNL DCSP return bool(len(uncommitted_files))
 DCSP normalized_obj = None DCNL DCSP if (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_BOOL): DCNL DCSP  DCSP assert isinstance(obj, bool), ('Expected DCSP bool, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP normalized_obj = obj DCNL DCSP elif (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_CUSTOM): DCNL DCSP  DCSP from core.domain import obj_services DCNL DCSP  DCSP obj_class = obj_services.Registry.get_object_class_by_type(schema[SCHEMA_KEY_OBJ_TYPE]) DCNL DCSP  DCSP normalized_obj = obj_class.normalize(obj) DCNL DCSP elif (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_DICT): DCNL DCSP  DCSP assert isinstance(obj, dict), ('Expected DCSP dict, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP expected_dict_keys = [p[SCHEMA_KEY_NAME] for p in schema[SCHEMA_KEY_PROPERTIES]] DCNL DCSP  DCSP assert (set(obj.keys()) == set(expected_dict_keys)) DCNL DCSP  DCSP normalized_obj = {} DCNL DCSP  DCSP for prop in schema[SCHEMA_KEY_PROPERTIES]: DCNL DCSP  DCSP  DCSP key = prop[SCHEMA_KEY_NAME] DCNL DCSP  DCSP  DCSP normalized_obj[key] = normalize_against_schema(obj[key], prop[SCHEMA_KEY_SCHEMA]) DCNL DCSP elif (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_FLOAT): DCNL DCSP  DCSP obj = float(obj) DCNL DCSP  DCSP assert isinstance(obj, numbers.Real), ('Expected DCSP float, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP normalized_obj = obj DCNL DCSP elif (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_INT): DCNL DCSP  DCSP obj = int(obj) DCNL DCSP  DCSP assert isinstance(obj, numbers.Integral), ('Expected DCSP int, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP assert isinstance(obj, int), ('Expected DCSP int, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP normalized_obj = obj DCNL DCSP elif (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_HTML): DCNL DCSP  DCSP assert isinstance(obj, basestring), ('Expected DCSP unicode DCSP HTML DCSP string, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP obj = unicode(obj) DCNL DCSP  DCSP assert isinstance(obj, unicode), ('Expected DCSP unicode, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP normalized_obj = html_cleaner.clean(obj) DCNL DCSP elif (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_LIST): DCNL DCSP  DCSP assert isinstance(obj, list), ('Expected DCSP list, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP item_schema = schema[SCHEMA_KEY_ITEMS] DCNL DCSP  DCSP if (SCHEMA_KEY_LEN in schema): DCNL DCSP  DCSP  DCSP assert (len(obj) == schema[SCHEMA_KEY_LEN]) DCNL DCSP  DCSP normalized_obj = [normalize_against_schema(item, item_schema) for item in obj] DCNL DCSP elif (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_UNICODE): DCNL DCSP  DCSP assert isinstance(obj, basestring), ('Expected DCSP unicode DCSP string, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP obj = unicode(obj) DCNL DCSP  DCSP assert isinstance(obj, unicode), ('Expected DCSP unicode, DCSP received DCSP %s' % obj) DCNL DCSP  DCSP normalized_obj = obj DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Invalid DCSP schema DCSP type: DCSP %s' % schema[SCHEMA_KEY_TYPE])) DCNL DCSP if (SCHEMA_KEY_CHOICES in schema): DCNL DCSP  DCSP assert (normalized_obj in schema[SCHEMA_KEY_CHOICES]), ('Received DCSP %s DCSP which DCSP is DCSP not DCSP in DCSP the DCSP allowed DCSP range DCSP of DCSP choices: DCSP %s' % (normalized_obj, schema[SCHEMA_KEY_CHOICES])) DCNL DCSP if (SCHEMA_KEY_POST_NORMALIZERS in schema): DCNL DCSP  DCSP for normalizer in schema[SCHEMA_KEY_POST_NORMALIZERS]: DCNL DCSP  DCSP  DCSP kwargs = dict(normalizer) DCNL DCSP  DCSP  DCSP del kwargs['id'] DCNL DCSP  DCSP  DCSP normalized_obj = Normalizers.get(normalizer['id'])(normalized_obj, **kwargs) DCNL DCSP if apply_custom_validators: DCNL DCSP  DCSP if (SCHEMA_KEY_VALIDATORS in schema): DCNL DCSP  DCSP  DCSP for validator in schema[SCHEMA_KEY_VALIDATORS]: DCNL DCSP  DCSP  DCSP  DCSP kwargs = dict(validator) DCNL DCSP  DCSP  DCSP  DCSP del kwargs['id'] DCNL DCSP  DCSP  DCSP  DCSP assert _Validators.get(validator['id'])(normalized_obj, **kwargs), ('Validation DCSP failed: DCSP %s DCSP (%s) DCSP for DCSP object DCSP %s' % (validator['id'], kwargs, normalized_obj)) DCNL DCSP return normalized_obj
 DCSP if isinstance(value, list): DCNL DCSP  DCSP if (len(value) == 1): DCNL DCSP  DCSP  DCSP return _get_hashable_value(value[0]) DCNL DCSP  DCSP return tuple([_get_hashable_value(elem) for elem in value]) DCNL DCSP elif isinstance(value, dict): DCNL DCSP  DCSP return _get_hashable_value(sorted([(_get_hashable_value(key), _get_hashable_value(val)) for (key, val) in value.iteritems()])) DCNL DCSP else: DCNL DCSP  DCSP return value
 DCSP hashable_answer_values = [_get_hashable_value(answer_dict['answer']) for answer_dict in answer_dicts_list] DCNL DCSP answer_frequencies = collections.Counter(hashable_answer_values) DCNL DCSP return [([answer_dicts_list[idx] for (idx, val) in enumerate(hashable_answer_values) if (val == hashable_answer)][0], frequency) for (hashable_answer, frequency) in answer_frequencies.most_common()]
 DCSP top_answer_counts_as_list_of_pairs = _count_answers(state_answers_dict['submitted_answer_list'])[:num_results] DCNL DCSP calculation_output = [] DCNL DCSP for item in top_answer_counts_as_list_of_pairs: DCNL DCSP  DCSP calculation_output.append({'answer': item[0]['answer'], 'frequency': item[1]}) DCNL DCSP return calculation_output
 DCSP reference_dict = UI_CONFIG_SPECS[obj_type] DCNL DCSP assert (set(ui_config.keys()) <= set(reference_dict.keys())) DCNL DCSP for (key, value) in ui_config.iteritems(): DCNL DCSP  DCSP schema_utils.normalize_against_schema(value, reference_dict[key])
 DCSP reference_dict = VALIDATOR_SPECS[obj_type] DCNL DCSP assert (('id' in validator) and (validator['id'] in reference_dict)) DCNL DCSP customization_keys = validator.keys() DCNL DCSP customization_keys.remove('id') DCNL DCSP assert (set(customization_keys) == set(reference_dict[validator['id']].keys())) DCNL DCSP for key in customization_keys: DCNL DCSP  DCSP value = validator[key] DCNL DCSP  DCSP schema = reference_dict[validator['id']][key] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP schema_utils.normalize_against_schema(value, schema) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise AssertionError(e) DCNL DCSP validator_fn = schema_utils._Validators.get(validator['id']) DCNL DCSP assert (set(inspect.getargspec(validator_fn).args) == set((customization_keys + ['obj'])))
 DCSP assert (set(required_keys) <= set(dict_to_check.keys())), ('Missing DCSP keys: DCSP %s' % dict_to_check) DCNL DCSP assert (set(dict_to_check.keys()) <= set((required_keys + optional_keys))), ('Extra DCSP keys: DCSP %s' % dict_to_check)
 DCSP assert isinstance(schema, dict) DCNL DCSP assert (SCHEMA_KEY_TYPE in schema) DCNL DCSP assert (schema[SCHEMA_KEY_TYPE] in ALLOWED_SCHEMA_TYPES) DCNL DCSP if (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_CUSTOM): DCNL DCSP  DCSP _validate_dict_keys(schema, [SCHEMA_KEY_TYPE, SCHEMA_KEY_OBJ_TYPE], []) DCNL DCSP  DCSP assert (schema[SCHEMA_KEY_OBJ_TYPE] in ALLOWED_CUSTOM_OBJ_TYPES), schema DCNL DCSP elif (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_LIST): DCNL DCSP  DCSP _validate_dict_keys(schema, [SCHEMA_KEY_ITEMS, SCHEMA_KEY_TYPE], (OPTIONAL_SCHEMA_KEYS + [SCHEMA_KEY_LEN])) DCNL DCSP  DCSP validate_schema(schema[SCHEMA_KEY_ITEMS]) DCNL DCSP  DCSP if (SCHEMA_KEY_LEN in schema): DCNL DCSP  DCSP  DCSP assert isinstance(schema[SCHEMA_KEY_LEN], int) DCNL DCSP  DCSP  DCSP assert (schema[SCHEMA_KEY_LEN] > 0) DCNL DCSP elif (schema[SCHEMA_KEY_TYPE] == SCHEMA_TYPE_DICT): DCNL DCSP  DCSP _validate_dict_keys(schema, [SCHEMA_KEY_PROPERTIES, SCHEMA_KEY_TYPE], OPTIONAL_SCHEMA_KEYS) DCNL DCSP  DCSP assert isinstance(schema[SCHEMA_KEY_PROPERTIES], list) DCNL DCSP  DCSP for prop in schema[SCHEMA_KEY_PROPERTIES]: DCNL DCSP  DCSP  DCSP _validate_dict_keys(prop, [SCHEMA_KEY_NAME, SCHEMA_KEY_SCHEMA], [SCHEMA_KEY_DESCRIPTION]) DCNL DCSP  DCSP  DCSP assert isinstance(prop[SCHEMA_KEY_NAME], basestring) DCNL DCSP  DCSP  DCSP validate_schema(prop[SCHEMA_KEY_SCHEMA]) DCNL DCSP  DCSP  DCSP if (SCHEMA_KEY_DESCRIPTION in prop): DCNL DCSP  DCSP  DCSP  DCSP assert isinstance(prop[SCHEMA_KEY_DESCRIPTION], basestring) DCNL DCSP else: DCNL DCSP  DCSP _validate_dict_keys(schema, [SCHEMA_KEY_TYPE], OPTIONAL_SCHEMA_KEYS) DCNL DCSP if (SCHEMA_KEY_UI_CONFIG in schema): DCNL DCSP  DCSP _validate_ui_config(schema[SCHEMA_KEY_TYPE], schema[SCHEMA_KEY_UI_CONFIG]) DCNL DCSP if ((SCHEMA_KEY_CHOICES in schema) and (SCHEMA_KEY_POST_NORMALIZERS in schema)): DCNL DCSP  DCSP raise AssertionError("Schema DCSP cannot DCSP contain DCSP both DCSP a DCSP 'choices' DCSP and DCSP a DCSP 'post_normalizers' DCSP key.") DCNL DCSP if (SCHEMA_KEY_POST_NORMALIZERS in schema): DCNL DCSP  DCSP assert isinstance(schema[SCHEMA_KEY_POST_NORMALIZERS], list) DCNL DCSP  DCSP for post_normalizer in schema[SCHEMA_KEY_POST_NORMALIZERS]: DCNL DCSP  DCSP  DCSP assert isinstance(post_normalizer, dict) DCNL DCSP  DCSP  DCSP assert ('id' in post_normalizer) DCNL DCSP  DCSP  DCSP schema_utils.Normalizers.get(post_normalizer['id']) DCNL DCSP if (SCHEMA_KEY_VALIDATORS in schema): DCNL DCSP  DCSP assert isinstance(schema[SCHEMA_KEY_VALIDATORS], list) DCNL DCSP  DCSP for validator in schema[SCHEMA_KEY_VALIDATORS]: DCNL DCSP  DCSP  DCSP assert isinstance(validator, dict) DCNL DCSP  DCSP  DCSP assert ('id' in validator) DCNL DCSP  DCSP  DCSP _validate_validator(schema[SCHEMA_KEY_TYPE], validator)
 DCSP string = json.dumps(value) DCNL DCSP replacements = [('\\', '\\\\'), ('"', '\\"'), ("'", "\\'"), ('\n', '\\n'), ('\r', '\\r'), ('\x08', '\\b'), ('<', '\\u003c'), ('>', '\\u003e'), ('&', '\\u0026')] DCNL DCSP for replacement in replacements: DCNL DCSP  DCSP string = string.replace(replacement[0], replacement[1]) DCNL DCSP return jinja2.utils.Markup(string)
 DCSP return int(math.log(value, 2))
 DCSP env = jinja2.Environment(autoescape=autoescape) DCNL DCSP env.filters.update(JINJA_FILTERS) DCNL DCSP try: DCNL DCSP  DCSP parsed_string = env.parse(string) DCNL DCSP except Exception: DCNL DCSP  DCSP raise Exception(('Unable DCSP to DCSP parse DCSP string DCSP with DCSP Jinja: DCSP %s' % string)) DCNL DCSP variables = meta.find_undeclared_variables(parsed_string) DCNL DCSP if any([(var not in params) for var in variables]): DCNL DCSP  DCSP logging.info('Cannot DCSP parse DCSP %s DCSP fully DCSP using DCSP %s', string, params) DCNL DCSP try: DCNL DCSP  DCSP return env.from_string(string).render(params) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(('jinja_utils.parse_string() DCSP failed DCSP with DCSP args: DCSP %s, DCSP %s, DCSP %s' % (string, params, autoescape))) DCNL DCSP  DCSP return env.from_string('[CONTENT DCSP PARSING DCSP ERROR]').render({})
 DCSP if isinstance(obj, basestring): DCNL DCSP  DCSP return parse_string(obj, params) DCNL DCSP elif isinstance(obj, list): DCNL DCSP  DCSP new_list = [] DCNL DCSP  DCSP for item in obj: DCNL DCSP  DCSP  DCSP new_list.append(evaluate_object(item, params)) DCNL DCSP  DCSP return new_list DCNL DCSP elif isinstance(obj, dict): DCNL DCSP  DCSP new_dict = {} DCNL DCSP  DCSP for key in obj: DCNL DCSP  DCSP  DCSP new_dict[key] = evaluate_object(obj[key], params) DCNL DCSP  DCSP return new_dict DCNL DCSP else: DCNL DCSP  DCSP return copy.deepcopy(obj)
 DCSP cache_slug = utils.get_asset_dir_prefix() DCNL DCSP return parse_string(string, {'cache_slug': cache_slug})
 DCSP cache = obj.cache = {} DCNL DCSP @functools.wraps(obj) DCNL DCSP def memoizer(*args, **kwargs): DCNL DCSP  DCSP key = (hashable(args), hashable(kwargs)) DCNL DCSP  DCSP if (key not in cache): DCNL DCSP  DCSP  DCSP cache[key] = obj(*args, **kwargs) DCNL DCSP  DCSP return cache[key] DCNL DCSP return memoizer
 DCSP if isinstance(a, dict): DCNL DCSP  DCSP return hashable(tuple(((hashable(a1), hashable(a2)) for (a1, a2) in a.items()))) DCNL DCSP try: DCNL DCSP  DCSP return hash(a) DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return hash(pickle.dumps(a)) DCNL DCSP except Exception: DCNL DCSP  DCSP if hasattr(a, '__dict__'): DCNL DCSP  DCSP  DCSP return hashable(a.__dict__) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return id(a)
 DCSP if (step_kwargs is None): DCNL DCSP  DCSP step_kwargs = {} DCNL DCSP steps = [] DCNL DCSP assigned_vars = set() DCNL DCSP if (step is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP steps += list(step) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP steps.append(step) DCNL DCSP  DCSP for step in steps: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP assigned_vars = assigned_vars.union(set(step.vars)) DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP for method in step.methods: DCNL DCSP  DCSP  DCSP  DCSP  DCSP assigned_vars = assigned_vars.union(set(method.vars)) DCNL DCSP selected_steps = defaultdict(list) DCNL DCSP for var in model.free_RVs: DCNL DCSP  DCSP if (var not in assigned_vars): DCNL DCSP  DCSP  DCSP selected = max(methods, key=(lambda method, var=var: method._competence(var))) DCNL DCSP  DCSP  DCSP pm._log.info('Assigned DCSP {0} DCSP to DCSP {1}'.format(selected.__name__, var)) DCNL DCSP  DCSP  DCSP selected_steps[selected].append(var) DCNL DCSP used_keys = set() DCNL DCSP for (step_class, vars) in selected_steps.items(): DCNL DCSP  DCSP if (len(vars) == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = step_kwargs.get(step_class.name, {}) DCNL DCSP  DCSP used_keys.add(step_class.name) DCNL DCSP  DCSP step = step_class(vars=vars, **args) DCNL DCSP  DCSP steps.append(step) DCNL DCSP unused_args = set(step_kwargs).difference(used_keys) DCNL DCSP if unused_args: DCNL DCSP  DCSP raise ValueError(('Unused DCSP step DCSP method DCSP arguments: DCSP %s' % unused_args)) DCNL DCSP if (len(steps) == 1): DCNL DCSP  DCSP steps = steps[0] DCNL DCSP return steps
 DCSP model = modelcontext(model) DCNL DCSP if (start is not None): DCNL DCSP  DCSP _check_start_shape(model, start) DCNL DCSP draws += tune DCNL DCSP if (nuts_kwargs is not None): DCNL DCSP  DCSP if (step_kwargs is not None): DCNL DCSP  DCSP  DCSP raise ValueError('Specify DCSP only DCSP one DCSP of DCSP step_kwargs DCSP and DCSP nuts_kwargs') DCNL DCSP  DCSP step_kwargs = {'nuts': nuts_kwargs} DCNL DCSP if (model.ndim == 0): DCNL DCSP  DCSP raise ValueError('The DCSP model DCSP does DCSP not DCSP contain DCSP any DCSP free DCSP variables.') DCNL DCSP if ((step is None) and (init is not None) and pm.model.all_continuous(model.vars)): DCNL DCSP  DCSP pm._log.info('Auto-assigning DCSP NUTS DCSP sampler...') DCNL DCSP  DCSP args = (step_kwargs if (step_kwargs is not None) else {}) DCNL DCSP  DCSP args = args.get('nuts', {}) DCNL DCSP  DCSP (start_, step) = init_nuts(init=init, njobs=njobs, n_init=n_init, model=model, random_seed=random_seed, progressbar=progressbar, **args) DCNL DCSP  DCSP if (start is None): DCNL DCSP  DCSP  DCSP start = start_ DCNL DCSP else: DCNL DCSP  DCSP step = assign_step_methods(model, step, step_kwargs=step_kwargs) DCNL DCSP if (njobs is None): DCNL DCSP  DCSP import multiprocessing as mp DCNL DCSP  DCSP njobs = max((mp.cpu_count() - 2), 1) DCNL DCSP sample_args = {'draws': draws, 'step': step, 'start': start, 'trace': trace, 'chain': chain, 'tune': tune, 'progressbar': progressbar, 'model': model, 'random_seed': random_seed, 'live_plot': live_plot, 'live_plot_kwargs': live_plot_kwargs} DCNL DCSP sample_args.update(kwargs) DCNL DCSP if (njobs > 1): DCNL DCSP  DCSP sample_func = _mp_sample DCNL DCSP  DCSP sample_args['njobs'] = njobs DCNL DCSP else: DCNL DCSP  DCSP sample_func = _sample DCNL DCSP discard = (tune if discard_tuned_samples else 0) DCNL DCSP return sample_func(**sample_args)[discard:]
 DCSP sampling = _iter_sample(draws, step, start, trace, chain, tune, model, random_seed) DCNL DCSP for (i, strace) in enumerate(sampling): DCNL DCSP  DCSP (yield MultiTrace([strace[:(i + 1)]]))
 DCSP if hasattr(step, 'tune'): DCNL DCSP  DCSP step.tune = False DCNL DCSP elif hasattr(step, 'methods'): DCNL DCSP  DCSP step.methods = [stop_tuning(s) for s in step.methods] DCNL DCSP return step
 DCSP if (samples is None): DCNL DCSP  DCSP samples = len(trace) DCNL DCSP model = modelcontext(model) DCNL DCSP if (vars is None): DCNL DCSP  DCSP vars = model.observed_RVs DCNL DCSP seed(random_seed) DCNL DCSP indices = randint(0, len(trace), samples) DCNL DCSP if progressbar: DCNL DCSP  DCSP indices = tqdm(indices, total=samples) DCNL DCSP try: DCNL DCSP  DCSP ppc = defaultdict(list) DCNL DCSP  DCSP for idx in indices: DCNL DCSP  DCSP  DCSP param = trace[idx] DCNL DCSP  DCSP  DCSP for var in vars: DCNL DCSP  DCSP  DCSP  DCSP ppc[var.name].append(var.distribution.random(point=param, size=size)) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP pass DCNL DCSP finally: DCNL DCSP  DCSP if progressbar: DCNL DCSP  DCSP  DCSP indices.close() DCNL DCSP return {k: np.asarray(v) for (k, v) in ppc.items()}
 DCSP seed(random_seed) DCNL DCSP if (models is None): DCNL DCSP  DCSP models = ([modelcontext(models)] * len(traces)) DCNL DCSP if (weights is None): DCNL DCSP  DCSP weights = ([1] * len(traces)) DCNL DCSP if (len(traces) != len(weights)): DCNL DCSP  DCSP raise ValueError('The DCSP number DCSP of DCSP traces DCSP and DCSP weights DCSP should DCSP be DCSP the DCSP same') DCNL DCSP if (len(models) != len(weights)): DCNL DCSP  DCSP raise ValueError('The DCSP number DCSP of DCSP models DCSP and DCSP weights DCSP should DCSP be DCSP the DCSP same') DCNL DCSP lenght_morv = len(models[0].observed_RVs) DCNL DCSP if (not all(((len(i.observed_RVs) == lenght_morv) for i in models))): DCNL DCSP  DCSP raise ValueError('The DCSP number DCSP of DCSP observed DCSP RVs DCSP should DCSP be DCSP the DCSP same DCSP for DCSP all DCSP models') DCNL DCSP weights = np.asarray(weights) DCNL DCSP p = (weights / np.sum(weights)) DCNL DCSP min_tr = min([len(i) for i in traces]) DCNL DCSP n = (min_tr * p).astype('int') DCNL DCSP idx = np.argmax(n) DCNL DCSP n[idx] = ((n[idx] + min_tr) - np.sum(n)) DCNL DCSP trace = np.concatenate([np.random.choice(traces[i], j) for (i, j) in enumerate(n)]) DCNL DCSP variables = [] DCNL DCSP for (i, m) in enumerate(models): DCNL DCSP  DCSP variables.extend((m.observed_RVs * n[i])) DCNL DCSP len_trace = len(trace) DCNL DCSP if (samples is None): DCNL DCSP  DCSP samples = len_trace DCNL DCSP indices = randint(0, len_trace, samples) DCNL DCSP if progressbar: DCNL DCSP  DCSP indices = tqdm(indices, total=samples) DCNL DCSP try: DCNL DCSP  DCSP ppc = defaultdict(list) DCNL DCSP  DCSP for idx in indices: DCNL DCSP  DCSP  DCSP param = trace[idx] DCNL DCSP  DCSP  DCSP var = variables[idx] DCNL DCSP  DCSP  DCSP ppc[var.name].append(var.distribution.random(point=param, size=size)) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP pass DCNL DCSP finally: DCNL DCSP  DCSP if progressbar: DCNL DCSP  DCSP  DCSP indices.close() DCNL DCSP return {k: np.asarray(v) for (k, v) in ppc.items()}
 DCSP model = pm.modelcontext(model) DCNL DCSP vars = kwargs.get('vars', model.vars) DCNL DCSP if (set(vars) != set(model.vars)): DCNL DCSP  DCSP raise ValueError('Must DCSP use DCSP init_nuts DCSP on DCSP all DCSP variables DCSP of DCSP a DCSP model.') DCNL DCSP if (not pm.model.all_continuous(vars)): DCNL DCSP  DCSP raise ValueError('init_nuts DCSP can DCSP only DCSP be DCSP used DCSP for DCSP models DCSP with DCSP only DCSP continuous DCSP variables.') DCNL DCSP if (not isinstance(init, str)): DCNL DCSP  DCSP raise TypeError('init DCSP must DCSP be DCSP a DCSP string.') DCNL DCSP if (init is not None): DCNL DCSP  DCSP init = init.lower() DCNL DCSP if (init == 'auto'): DCNL DCSP  DCSP init = 'jitter+adapt_diag' DCNL DCSP pm._log.info('Initializing DCSP NUTS DCSP using DCSP {}...'.format(init)) DCNL DCSP random_seed = int(np.atleast_1d(random_seed)[0]) DCNL DCSP cb = [pm.callbacks.CheckParametersConvergence(tolerance=0.01, diff='absolute'), pm.callbacks.CheckParametersConvergence(tolerance=0.01, diff='relative')] DCNL DCSP if (init == 'adapt_diag'): DCNL DCSP  DCSP start = ([model.test_point] * njobs) DCNL DCSP  DCSP mean = np.mean([model.dict_to_array(vals) for vals in start], axis=0) DCNL DCSP  DCSP var = np.ones_like(mean) DCNL DCSP  DCSP potential = quadpotential.QuadPotentialDiagAdapt(model.ndim, mean, var, 10) DCNL DCSP  DCSP if (njobs == 1): DCNL DCSP  DCSP  DCSP start = start[0] DCNL DCSP elif (init == 'jitter+adapt_diag'): DCNL DCSP  DCSP start = [] DCNL DCSP  DCSP for _ in range(njobs): DCNL DCSP  DCSP  DCSP mean = {var: val.copy() for (var, val) in model.test_point.items()} DCNL DCSP  DCSP  DCSP for val in mean.values(): DCNL DCSP  DCSP  DCSP  DCSP val[...] += ((2 * np.random.rand(*val.shape)) - 1) DCNL DCSP  DCSP  DCSP start.append(mean) DCNL DCSP  DCSP mean = np.mean([model.dict_to_array(vals) for vals in start], axis=0) DCNL DCSP  DCSP var = np.ones_like(mean) DCNL DCSP  DCSP potential = quadpotential.QuadPotentialDiagAdapt(model.ndim, mean, var, 10) DCNL DCSP  DCSP if (njobs == 1): DCNL DCSP  DCSP  DCSP start = start[0] DCNL DCSP elif (init == 'advi+adapt_diag_grad'): DCNL DCSP  DCSP approx = pm.fit(random_seed=random_seed, n=n_init, method='advi', model=model, callbacks=cb, progressbar=progressbar, obj_optimizer=pm.adagrad_window) DCNL DCSP  DCSP start = approx.sample(draws=njobs) DCNL DCSP  DCSP start = list(start) DCNL DCSP  DCSP stds = approx.gbij.rmap(approx.std.eval()) DCNL DCSP  DCSP cov = (model.dict_to_array(stds) ** 2) DCNL DCSP  DCSP mean = approx.gbij.rmap(approx.mean.get_value()) DCNL DCSP  DCSP mean = model.dict_to_array(mean) DCNL DCSP  DCSP weight = 50 DCNL DCSP  DCSP potential = quadpotential.QuadPotentialDiagAdaptGrad(model.ndim, mean, cov, weight) DCNL DCSP  DCSP if (njobs == 1): DCNL DCSP  DCSP  DCSP start = start[0] DCNL DCSP elif (init == 'advi+adapt_diag'): DCNL DCSP  DCSP approx = pm.fit(random_seed=random_seed, n=n_init, method='advi', model=model, callbacks=cb, progressbar=progressbar, obj_optimizer=pm.adagrad_window) DCNL DCSP  DCSP start = approx.sample(draws=njobs) DCNL DCSP  DCSP start = list(start) DCNL DCSP  DCSP stds = approx.gbij.rmap(approx.std.eval()) DCNL DCSP  DCSP cov = (model.dict_to_array(stds) ** 2) DCNL DCSP  DCSP mean = approx.gbij.rmap(approx.mean.get_value()) DCNL DCSP  DCSP mean = model.dict_to_array(mean) DCNL DCSP  DCSP weight = 50 DCNL DCSP  DCSP potential = quadpotential.QuadPotentialDiagAdapt(model.ndim, mean, cov, weight) DCNL DCSP  DCSP if (njobs == 1): DCNL DCSP  DCSP  DCSP start = start[0] DCNL DCSP elif (init == 'advi'): DCNL DCSP  DCSP approx = pm.fit(random_seed=random_seed, n=n_init, method='advi', model=model, callbacks=cb, progressbar=progressbar, obj_optimizer=pm.adagrad_window) DCNL DCSP  DCSP start = approx.sample(draws=njobs) DCNL DCSP  DCSP start = list(start) DCNL DCSP  DCSP stds = approx.gbij.rmap(approx.std.eval()) DCNL DCSP  DCSP cov = (model.dict_to_array(stds) ** 2) DCNL DCSP  DCSP potential = quadpotential.QuadPotentialDiag(cov) DCNL DCSP  DCSP if (njobs == 1): DCNL DCSP  DCSP  DCSP start = start[0] DCNL DCSP elif (init == 'advi_map'): DCNL DCSP  DCSP start = pm.find_MAP() DCNL DCSP  DCSP approx = pm.MeanField(model=model, start=start) DCNL DCSP  DCSP pm.fit(random_seed=random_seed, n=n_init, method=pm.ADVI.from_mean_field(approx), callbacks=cb, progressbar=progressbar, obj_optimizer=pm.adagrad_window) DCNL DCSP  DCSP start = approx.sample(draws=njobs) DCNL DCSP  DCSP start = list(start) DCNL DCSP  DCSP stds = approx.gbij.rmap(approx.std.eval()) DCNL DCSP  DCSP cov = (model.dict_to_array(stds) ** 2) DCNL DCSP  DCSP potential = quadpotential.QuadPotentialDiag(cov) DCNL DCSP  DCSP if (njobs == 1): DCNL DCSP  DCSP  DCSP start = start[0] DCNL DCSP elif (init == 'map'): DCNL DCSP  DCSP start = pm.find_MAP() DCNL DCSP  DCSP cov = pm.find_hessian(point=start) DCNL DCSP  DCSP start = ([start] * njobs) DCNL DCSP  DCSP potential = quadpotential.QuadPotentialFull(cov) DCNL DCSP  DCSP if (njobs == 1): DCNL DCSP  DCSP  DCSP start = start[0] DCNL DCSP elif (init == 'nuts'): DCNL DCSP  DCSP init_trace = pm.sample(draws=n_init, step=pm.NUTS(), tune=(n_init // 2), random_seed=random_seed) DCNL DCSP  DCSP cov = np.atleast_1d(pm.trace_cov(init_trace)) DCNL DCSP  DCSP start = list(np.random.choice(init_trace, njobs)) DCNL DCSP  DCSP potential = quadpotential.QuadPotentialFull(cov) DCNL DCSP  DCSP if (njobs == 1): DCNL DCSP  DCSP  DCSP start = start[0] DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError('Initializer DCSP {} DCSP is DCSP not DCSP supported.'.format(init)) DCNL DCSP step = pm.NUTS(potential=potential, **kwargs) DCNL DCSP return (start, step)
 DCSP db = _SQLiteDB(name) DCNL DCSP db.connect() DCNL DCSP varnames = _get_table_list(db.cursor) DCNL DCSP if (len(varnames) == 0): DCNL DCSP  DCSP raise ValueError('Can DCSP not DCSP get DCSP variable DCSP list DCSP for DCSP database`{}`'.format(name)) DCNL DCSP chains = _get_chain_list(db.cursor, varnames[0]) DCNL DCSP straces = [] DCNL DCSP for chain in chains: DCNL DCSP  DCSP strace = SQLite(name, model=model) DCNL DCSP  DCSP strace.chain = chain DCNL DCSP  DCSP strace._var_cols = {varname: ttab.create_flat_names('v', shape) for (varname, shape) in strace.var_shapes.items()} DCNL DCSP  DCSP strace._is_setup = True DCNL DCSP  DCSP strace.db = db DCNL DCSP  DCSP straces.append(strace) DCNL DCSP return base.MultiTrace(straces)
 DCSP cursor.execute("SELECT DCSP name DCSP FROM DCSP sqlite_master DCSP WHERE DCSP type='table' DCSP AND DCSP NOT DCSP name='sqlite_sequence' DCSP ORDER DCSP BY DCSP name") DCNL DCSP return [row[0] for row in cursor.fetchall()]
 DCSP cursor.execute('SELECT DCSP DISTINCT DCSP chain DCSP FROM DCSP [{}]'.format(varname)) DCNL DCSP chains = [chain[0] for chain in cursor.fetchall()] DCNL DCSP chains.sort() DCNL DCSP return chains
 DCSP return np.squeeze(np.array([row[3:] for row in cursor.fetchall()]))
 DCSP straces = [] DCNL DCSP for chain in HDF5(name, model=model).chains: DCNL DCSP  DCSP trace = HDF5(name, model=model) DCNL DCSP  DCSP trace.chain = chain DCNL DCSP  DCSP straces.append(trace) DCNL DCSP return base.MultiTrace(straces)
 DCSP base_mtrace = mtraces[0] DCNL DCSP for new_mtrace in mtraces[1:]: DCNL DCSP  DCSP for (new_chain, strace) in new_mtrace._straces.items(): DCNL DCSP  DCSP  DCSP if (new_chain in base_mtrace._straces): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Chains DCSP are DCSP not DCSP unique.') DCNL DCSP  DCSP  DCSP base_mtrace._straces[new_chain] = strace DCNL DCSP return base_mtrace
 DCSP if combine: DCNL DCSP  DCSP results = np.concatenate(results) DCNL DCSP  DCSP if (not squeeze): DCNL DCSP  DCSP  DCSP results = [results] DCNL DCSP elif (squeeze and (len(results) == 1)): DCNL DCSP  DCSP results = results[0] DCNL DCSP return results
 DCSP files = glob(os.path.join(name, 'chain-*.csv')) DCNL DCSP if (len(files) == 0): DCNL DCSP  DCSP raise ValueError('No DCSP files DCSP present DCSP in DCSP directory DCSP {}'.format(name)) DCNL DCSP straces = [] DCNL DCSP for f in files: DCNL DCSP  DCSP chain = int(os.path.splitext(f)[0].rsplit('-', 1)[1]) DCNL DCSP  DCSP strace = Text(name, model=model) DCNL DCSP  DCSP strace.chain = chain DCNL DCSP  DCSP strace.filename = f DCNL DCSP  DCSP straces.append(strace) DCNL DCSP return base.MultiTrace(straces)
 DCSP if (not os.path.exists(name)): DCNL DCSP  DCSP os.mkdir(name) DCNL DCSP if (chains is None): DCNL DCSP  DCSP chains = trace.chains DCNL DCSP for chain in chains: DCNL DCSP  DCSP filename = os.path.join(name, 'chain-{}.csv'.format(chain)) DCNL DCSP  DCSP df = ttab.trace_to_dataframe(trace, chains=chain, include_transformed=True) DCNL DCSP  DCSP df.to_csv(filename, index=False)
 DCSP if (nprocs is None): DCNL DCSP  DCSP nprocs = multiprocessing.cpu_count() DCNL DCSP if (nprocs == 1): DCNL DCSP  DCSP for work_item in work: DCNL DCSP  DCSP  DCSP (yield function(work_item)) DCNL DCSP else: DCNL DCSP  DCSP pool = multiprocessing.Pool(processes=nprocs) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (yield pool.map(function, work, chunksize=chunksize)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP pool.terminate()
 DCSP var_shapes = trace._straces[0].var_shapes DCNL DCSP if (varnames is None): DCNL DCSP  DCSP varnames = get_default_varnames(var_shapes.keys(), include_transformed=include_transformed) DCNL DCSP flat_names = {v: create_flat_names(v, var_shapes[v]) for v in varnames} DCNL DCSP var_dfs = [] DCNL DCSP for v in varnames: DCNL DCSP  DCSP vals = trace.get_values(v, combine=True, chains=chains) DCNL DCSP  DCSP flat_vals = vals.reshape(vals.shape[0], (-1)) DCNL DCSP  DCSP var_dfs.append(pd.DataFrame(flat_vals, columns=flat_names[v])) DCNL DCSP return pd.concat(var_dfs, axis=1)
 DCSP if (not shape): DCNL DCSP  DCSP return [varname] DCNL DCSP labels = (np.ravel(xs).tolist() for xs in np.indices(shape)) DCNL DCSP labels = (map(str, xs) for xs in labels) DCNL DCSP return ['{}__{}'.format(varname, '_'.join(idxs)) for idxs in zip(*labels)]
 DCSP try: DCNL DCSP  DCSP (_, shape_str) = flat_names[(-1)].rsplit('__', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP return () DCNL DCSP return tuple(((int(i) + 1) for i in shape_str.split('_')))
 DCSP if isinstance(comp_dists, Distribution): DCNL DCSP  DCSP return isinstance(comp_dists, Discrete) DCNL DCSP else: DCNL DCSP  DCSP return all((isinstance(comp_dist, Discrete) for comp_dist in comp_dists))
 DCSP givens = {} DCNL DCSP for param in params: DCNL DCSP  DCSP if hasattr(param, 'name'): DCNL DCSP  DCSP  DCSP named_nodes = get_named_nodes(param) DCNL DCSP  DCSP  DCSP if (param.name in named_nodes): DCNL DCSP  DCSP  DCSP  DCSP named_nodes.pop(param.name) DCNL DCSP  DCSP  DCSP for (name, node) in named_nodes.items(): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(node, (tt.sharedvar.SharedVariable, tt.TensorConstant))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP givens[name] = (node, _draw_value(node, point=point)) DCNL DCSP values = [] DCNL DCSP for param in params: DCNL DCSP  DCSP values.append(_draw_value(param, point=point, givens=givens.values())) DCNL DCSP return values
 DCSP return function(vars, param, givens=givens, rebuild_strict=True, on_unused_input='ignore', allow_input_downcast=True)
 DCSP if isinstance(param, numbers.Number): DCNL DCSP  DCSP return param DCNL DCSP elif isinstance(param, np.ndarray): DCNL DCSP  DCSP return param DCNL DCSP elif isinstance(param, tt.TensorConstant): DCNL DCSP  DCSP return param.value DCNL DCSP elif isinstance(param, tt.sharedvar.SharedVariable): DCNL DCSP  DCSP return param.get_value() DCNL DCSP elif isinstance(param, tt.TensorVariable): DCNL DCSP  DCSP if (point and hasattr(param, 'model') and (param.name in point)): DCNL DCSP  DCSP  DCSP return point[param.name] DCNL DCSP  DCSP elif (hasattr(param, 'random') and (param.random is not None)): DCNL DCSP  DCSP  DCSP return param.random(point=point, size=None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if givens: DCNL DCSP  DCSP  DCSP  DCSP (variables, values) = list(zip(*givens)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP variables = values = [] DCNL DCSP  DCSP  DCSP func = _compile_theano_function(param, variables) DCNL DCSP  DCSP  DCSP return func(*values) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unexpected DCSP type DCSP in DCSP draw_value: DCSP %s' % type(param)))
 DCSP x = (list(np.atleast_1d(args[0])) if args else ()) DCNL DCSP for arg in args[1:]: DCNL DCSP  DCSP y = list(np.atleast_1d(arg)) DCNL DCSP  DCSP if (len(x) < len(y)): DCNL DCSP  DCSP  DCSP (x, y) = (y, x) DCNL DCSP  DCSP x[(- len(y)):] = [(j if (i == 1) else (i if (j == 1) else (i if (i == j) else 0))) for (i, j) in zip(x[(- len(y)):], y)] DCNL DCSP  DCSP if (not all(x)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP return tuple(x)
 DCSP dist_shape = kwargs.pop('dist_shape', ()) DCNL DCSP size = kwargs.pop('size', None) DCNL DCSP broadcast_shape = kwargs.pop('broadcast_shape', None) DCNL DCSP params = (args + tuple(kwargs.values())) DCNL DCSP if (broadcast_shape is None): DCNL DCSP  DCSP broadcast_shape = broadcast_shapes(*[np.atleast_1d(p).shape for p in params if (not isinstance(p, tuple))]) DCNL DCSP if (broadcast_shape == ()): DCNL DCSP  DCSP broadcast_shape = (1,) DCNL DCSP args = tuple(((p[0] if isinstance(p, tuple) else p) for p in args)) DCNL DCSP for key in kwargs: DCNL DCSP  DCSP p = kwargs[key] DCNL DCSP  DCSP kwargs[key] = (p[0] if isinstance(p, tuple) else p) DCNL DCSP if np.all((dist_shape[(- len(broadcast_shape)):] == broadcast_shape)): DCNL DCSP  DCSP prefix_shape = tuple(dist_shape[:(- len(broadcast_shape))]) DCNL DCSP else: DCNL DCSP  DCSP prefix_shape = tuple(dist_shape) DCNL DCSP repeat_shape = infer_shape(size) DCNL DCSP if ((broadcast_shape == (1,)) and (prefix_shape == ())): DCNL DCSP  DCSP if (size is not None): DCNL DCSP  DCSP  DCSP samples = generator(size=size, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP samples = generator(size=1, *args, **kwargs) DCNL DCSP elif (size is not None): DCNL DCSP  DCSP samples = replicate_samples(generator, broadcast_shape, (repeat_shape + prefix_shape), *args, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP samples = replicate_samples(generator, broadcast_shape, prefix_shape, *args, **kwargs) DCNL DCSP return reshape_sampled(samples, size, dist_shape)
 DCSP L = (S if is_cholesky else scipy.linalg.cholesky(S)) DCNL DCSP diag_idx = np.diag_indices_from(S) DCNL DCSP tril_idx = np.tril_indices_from(S, k=(-1)) DCNL DCSP n_diag = len(diag_idx[0]) DCNL DCSP n_tril = len(tril_idx[0]) DCNL DCSP if (testval is not None): DCNL DCSP  DCSP testval = np.dot(np.dot(np.linalg.inv(L), testval), np.linalg.inv(L.T)) DCNL DCSP  DCSP testval = scipy.linalg.cholesky(testval, lower=True) DCNL DCSP  DCSP diag_testval = (testval[diag_idx] ** 2) DCNL DCSP  DCSP tril_testval = testval[tril_idx] DCNL DCSP else: DCNL DCSP  DCSP diag_testval = None DCNL DCSP  DCSP tril_testval = None DCNL DCSP c = tt.sqrt(ChiSquared('c', (nu - np.arange(2, (2 + n_diag))), shape=n_diag, testval=diag_testval)) DCNL DCSP pm._log.info('Added DCSP new DCSP variable DCSP c DCSP to DCSP model DCSP diagonal DCSP of DCSP Wishart.') DCNL DCSP z = Normal('z', 0.0, 1.0, shape=n_tril, testval=tril_testval) DCNL DCSP pm._log.info('Added DCSP new DCSP variable DCSP z DCSP to DCSP model DCSP off-diagonals DCSP of DCSP Wishart.') DCNL DCSP A = tt.zeros(S.shape, dtype=np.float32) DCNL DCSP A = tt.set_subtensor(A[diag_idx], c) DCNL DCSP A = tt.set_subtensor(A[tril_idx], z) DCNL DCSP if return_cholesky: DCNL DCSP  DCSP return Deterministic(name, tt.dot(L, A)) DCNL DCSP else: DCNL DCSP  DCSP return Deterministic(name, tt.dot(tt.dot(tt.dot(L, A), A.T), L.T))
 DCSP broadcast_conditions = kwargs.get('broadcast_conditions', True) DCNL DCSP if broadcast_conditions: DCNL DCSP  DCSP alltrue = alltrue_elemwise DCNL DCSP else: DCNL DCSP  DCSP alltrue = alltrue_scalar DCNL DCSP return tt.switch(alltrue(conditions), logp, (- np.inf))
 DCSP return tt.switch(tt.eq(x, 0), (- np.inf), (m * tt.log(x)))
 DCSP return (0.5 + (0.5 * tt.erf((x / tt.sqrt(2.0)))))
 DCSP return tt.switch(tt.lt(x, 5), ((((((1.0 + ((x ** 2) / 4.0)) + ((x ** 4) / 64.0)) + ((x ** 6) / 2304.0)) + ((x ** 8) / 147456.0)) + ((x ** 10) / 14745600.0)) + ((x ** 12) / 2123366400.0)), (((np.e ** x) / (((2.0 * np.pi) * x) ** 0.5)) * ((((1.0 + (1.0 / (8.0 * x))) + (9.0 / (128.0 * (x ** 2)))) + (225.0 / (3072 * (x ** 3)))) + (11025.0 / (98304.0 * (x ** 4))))))
 DCSP return tt.switch(tt.lt(x, 5), (((((((x / 2.0) + ((x ** 3) / 16.0)) + ((x ** 5) / 384.0)) + ((x ** 7) / 18432.0)) + ((x ** 9) / 1474560.0)) + ((x ** 11) / 176947200.0)) + ((x ** 13) / 29727129600.0)), (((np.e ** x) / (((2.0 * np.pi) * x) ** 0.5)) * ((((1.0 - (3.0 / (8.0 * x))) + (15.0 / (128.0 * (x ** 2)))) + (315.0 / (3072.0 * (x ** 3)))) + (14175.0 / (98304.0 * (x ** 4))))))
 DCSP return tt.log((tt.exp(sd) - 1.0))
 DCSP return tt.log1p(tt.exp(rho))
 DCSP sd = kwargs.get('sd') DCNL DCSP w = kwargs.get('w') DCNL DCSP rho = kwargs.get('rho') DCNL DCSP tau = kwargs.get('tau') DCNL DCSP eps = kwargs.get('eps', 0.0) DCNL DCSP check = sum(map((lambda a: (a is not None)), [sd, w, rho, tau])) DCNL DCSP if (check > 1): DCNL DCSP  DCSP raise ValueError('more DCSP than DCSP one DCSP required DCSP kwarg DCSP is DCSP passed') DCNL DCSP if (check == 0): DCNL DCSP  DCSP raise ValueError('none DCSP of DCSP required DCSP kwarg DCSP is DCSP passed') DCNL DCSP if (sd is not None): DCNL DCSP  DCSP std = sd DCNL DCSP elif (w is not None): DCNL DCSP  DCSP std = tt.exp(w) DCNL DCSP elif (rho is not None): DCNL DCSP  DCSP std = rho2sd(rho) DCNL DCSP else: DCNL DCSP  DCSP std = (tau ** (-1)) DCNL DCSP std += f(eps) DCNL DCSP return ((f(c) - tt.log(tt.abs_(std))) - (((x - mean) ** 2) / (2.0 * (std ** 2))))
 DCSP cov = tt.matrix('cov') DCNL DCSP cov.tag.test_value = floatX(np.eye(3)) DCNL DCSP delta = tt.matrix('delta') DCNL DCSP delta.tag.test_value = floatX(np.zeros((2, 3))) DCNL DCSP solve_lower = tt.slinalg.Solve(A_structure='lower_triangular') DCNL DCSP solve_upper = tt.slinalg.Solve(A_structure='upper_triangular') DCNL DCSP cholesky = Cholesky(nofail=True, lower=True) DCNL DCSP (n, k) = delta.shape DCNL DCSP (n, k) = (f(n), f(k)) DCNL DCSP chol_cov = cholesky(cov) DCNL DCSP diag = tt.nlinalg.diag(chol_cov) DCNL DCSP ok = tt.all((diag > 0)) DCNL DCSP chol_cov = tt.switch(ok, chol_cov, tt.fill(chol_cov, 1)) DCNL DCSP delta_trans = solve_lower(chol_cov, delta.T).T DCNL DCSP result = ((n * k) * tt.log((f(2) * np.pi))) DCNL DCSP result += ((f(2) * n) * tt.sum(tt.log(diag))) DCNL DCSP result += (delta_trans ** f(2)).sum() DCNL DCSP result = (f((-0.5)) * result) DCNL DCSP logp = tt.switch(ok, result, (- np.inf)) DCNL DCSP def dlogp(inputs, gradients): DCNL DCSP  DCSP (g_logp,) = gradients DCNL DCSP  DCSP (cov, delta) = inputs DCNL DCSP  DCSP g_logp.tag.test_value = floatX(1.0) DCNL DCSP  DCSP (n, k) = delta.shape DCNL DCSP  DCSP chol_cov = cholesky(cov) DCNL DCSP  DCSP diag = tt.nlinalg.diag(chol_cov) DCNL DCSP  DCSP ok = tt.all((diag > 0)) DCNL DCSP  DCSP chol_cov = tt.switch(ok, chol_cov, tt.fill(chol_cov, 1)) DCNL DCSP  DCSP delta_trans = solve_lower(chol_cov, delta.T).T DCNL DCSP  DCSP inner = ((n * tt.eye(k)) - tt.dot(delta_trans.T, delta_trans)) DCNL DCSP  DCSP g_cov = solve_upper(chol_cov.T, inner) DCNL DCSP  DCSP g_cov = solve_upper(chol_cov.T, g_cov.T) DCNL DCSP  DCSP tau_delta = solve_upper(chol_cov.T, delta_trans.T) DCNL DCSP  DCSP g_delta = tau_delta.T DCNL DCSP  DCSP g_cov = tt.switch(ok, g_cov, (- np.nan)) DCNL DCSP  DCSP g_delta = tt.switch(ok, g_delta, (- np.nan)) DCNL DCSP  DCSP return [(((-0.5) * g_cov) * g_logp), ((- g_delta) * g_logp)] DCNL DCSP return theano.OpFromGraph([cov, delta], [logp], grad_overrides=dlogp, inline=True)
 DCSP if (tau is None): DCNL DCSP  DCSP if (sd is None): DCNL DCSP  DCSP  DCSP sd = 1.0 DCNL DCSP  DCSP  DCSP tau = 1.0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tau = (sd ** (-2.0)) DCNL DCSP elif (sd is not None): DCNL DCSP  DCSP raise ValueError("Can't DCSP pass DCSP both DCSP tau DCSP and DCSP sd") DCNL DCSP else: DCNL DCSP  DCSP sd = (tau ** (-0.5)) DCNL DCSP tau = (1.0 * tau) DCNL DCSP sd = (1.0 * sd) DCNL DCSP return (floatX(tau), floatX(sd))
 DCSP i = tt.arange(1, (p + 1)) DCNL DCSP return ((((p * (p - 1)) * tt.log(np.pi)) / 4.0) + tt.sum(gammaln((a + ((1.0 - i) / 2.0))), axis=0))
 DCSP if (strng is None): DCNL DCSP  DCSP return u'None' DCNL DCSP return LATEX_ESCAPE_RE.sub('\\\\\\1', strng)
 DCSP return '{}_{}__'.format(name, transform.name)
 DCSP return (name.endswith('__') and (name.count('_') >= 3))
 DCSP if (not is_transformed_name(name)): DCNL DCSP  DCSP raise ValueError(u'{} DCSP does DCSP not DCSP appear DCSP to DCSP be DCSP a DCSP transformed DCSP name'.format(name)) DCNL DCSP return '_'.join(name.split('_')[:(-3)])
 DCSP if include_transformed: DCNL DCSP  DCSP return list(var_iterator) DCNL DCSP else: DCNL DCSP  DCSP return [var for var in var_iterator if (not is_transformed_name(str(var)))]
 DCSP name = variable.name DCNL DCSP if (name is None): DCNL DCSP  DCSP if hasattr(variable, 'get_parents'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP names = [get_variable_name(item) for item in variable.get_parents()[0].inputs] DCNL DCSP  DCSP  DCSP  DCSP return ('f(%s)' % ','.join([n for n in names if isinstance(n, str)])) DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP value = variable.eval() DCNL DCSP  DCSP if (not value.shape): DCNL DCSP  DCSP  DCSP return asscalar(value) DCNL DCSP  DCSP return 'array' DCNL DCSP return escape_latex(name)
 DCSP if (model is not None): DCNL DCSP  DCSP for free_RV in model.free_RVs: DCNL DCSP  DCSP  DCSP tname = free_RV.name DCNL DCSP  DCSP  DCSP for name in a: DCNL DCSP  DCSP  DCSP  DCSP if (is_transformed_name(tname) and (get_untransformed_name(tname) == name)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP transform_func = [d.transformation for d in model.deterministics if (d.name == name)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if transform_func: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP b[tname] = transform_func[0].forward_val(a[name], point=b).eval() DCNL DCSP a.update({k: v for (k, v) in b.items() if (k not in a)})
 DCSP data_pkg = 'pymc3.examples' DCNL DCSP return io.BytesIO(pkgutil.get_data(data_pkg, os.path.join('data', filename)))
 DCSP tri = np.array([0.7, 0.0, (-0.7)]) DCNL DCSP return [(tri, 1, 3, 1.596312591138855), (tri, 3, 3, (-7.796349337631274)), (tri, 0, 3, (- np.inf)), (np.array([1.1, 0.0, (-0.7)]), 1, 3, (- np.inf)), (np.array([0.7, 0.0, (-1.1)]), 1, 3, (- np.inf))]
 DCSP try: DCNL DCSP  DCSP (names, domains) = zip(*domains.items()) DCNL DCSP except ValueError: DCNL DCSP  DCSP return [] DCNL DCSP all_vals = [zip(names, val) for val in itertools.product(*[d.vals for d in domains])] DCNL DCSP if ((n_samples > 0) and (len(all_vals) > n_samples)): DCNL DCSP  DCSP return (all_vals[j] for j in nr.choice(len(all_vals), n_samples, replace=False)) DCNL DCSP return all_vals
 DCSP pdf = np.log(sp.exponweib.pdf(value, 1, alpha, scale=beta)) DCNL DCSP if np.isinf(pdf): DCNL DCSP  DCSP return sp.exponweib.logpdf(value, 1, alpha, scale=beta) DCNL DCSP return floatX(pdf)
 DCSP data = np.array([[1.0, 1], [1, 1]], dtype=theano.config.floatX) DCNL DCSP assert (mv.posdef(data) == 0)
 DCSP decimal = (float64 if (theano.config.floatX == 'float64') else float32) DCNL DCSP return decimal
 DCSP data = pd.read_csv(pm.get_data('srrs2.dat')) DCNL DCSP cty_data = pd.read_csv(pm.get_data('cty.dat')) DCNL DCSP data = data[(data.state == 'MN')] DCNL DCSP data['fips'] = ((data.stfips * 1000) + data.cntyfips) DCNL DCSP cty_data['fips'] = ((cty_data.stfips * 1000) + cty_data.ctfips) DCNL DCSP data['lradon'] = np.log(np.where((data.activity == 0), 0.1, data.activity)) DCNL DCSP data = data.merge(cty_data, 'inner', on='fips') DCNL DCSP unique = data[['fips']].drop_duplicates() DCNL DCSP unique['group'] = np.arange(len(unique)) DCNL DCSP unique.set_index('fips') DCNL DCSP return data.merge(unique, 'inner', on='fips')
 DCSP return [v for v in inputs(makeiter(a)) if isinstance(v, tt.TensorVariable)]
 DCSP return typefilter(inputvars(f), continuous_types)
 DCSP try: DCNL DCSP  DCSP return X.astype(theano.config.floatX) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return np.asarray(X, dtype=theano.config.floatX)
 DCSP if str(x.dtype).startswith('float'): DCNL DCSP  DCSP x = floatX(x) DCNL DCSP return x
 DCSP return tt.flatten(tt.grad(f, v, disconnected_inputs='warn'))
 DCSP f = tt.flatten(f) DCNL DCSP idx = tt.arange(f.shape[0], dtype='int32') DCNL DCSP def grad_i(i): DCNL DCSP  DCSP return gradient1(f[i], v) DCNL DCSP return theano.map(grad_i, idx)[0]
 DCSP othervars = (set(model.vars) - set(vars)) DCNL DCSP return {var: theano.shared(var.tag.test_value, (var.name + '_shared')) for var in othervars}
 DCSP if (not vars): DCNL DCSP  DCSP raise ValueError('Empty DCSP list DCSP of DCSP variables.') DCNL DCSP joined = tt.concatenate([var.ravel() for var in vars]) DCNL DCSP if (not make_shared): DCNL DCSP  DCSP tensor_type = joined.type DCNL DCSP  DCSP inarray = tensor_type('inarray') DCNL DCSP else: DCNL DCSP  DCSP inarray = theano.shared(joined.tag.test_value, 'inarray') DCNL DCSP ordering = ArrayOrdering(vars) DCNL DCSP inarray.tag.test_value = joined.tag.test_value DCNL DCSP get_var = {var.name: var for var in vars} DCNL DCSP replace = {get_var[var]: reshape_t(inarray[slc], shp).astype(dtyp) for (var, slc, shp, dtyp) in ordering.vmap} DCNL DCSP replace.update(shared) DCNL DCSP xs_special = [theano.clone(x, replace, strict=False) for x in xs] DCNL DCSP return (xs_special, inarray)
 DCSP if (shape != ()): DCNL DCSP  DCSP return x.reshape(shape) DCNL DCSP else: DCNL DCSP  DCSP return x[0]
 DCSP return GeneratorOp(gen, default)()
 DCSP if (random_seed is None): DCNL DCSP  DCSP return _tt_rng DCNL DCSP else: DCNL DCSP  DCSP ret = MRG_RandomStreams(random_seed) DCNL DCSP  DCSP return ret
 DCSP global _tt_rng DCNL DCSP if isinstance(new_rng, int): DCNL DCSP  DCSP new_rng = MRG_RandomStreams(new_rng) DCNL DCSP _tt_rng = new_rng
 DCSP variables = {} DCNL DCSP unknown = set(values.keys()) DCNL DCSP for variable in theano.configparser._config_var_list: DCNL DCSP  DCSP if (variable.fullname in values): DCNL DCSP  DCSP  DCSP variables[variable.fullname] = variable DCNL DCSP  DCSP  DCSP unknown.remove(variable.fullname) DCNL DCSP if (len(unknown) > 0): DCNL DCSP  DCSP raise ValueError(('Unknown DCSP theano DCSP config DCSP settings: DCSP %s' % unknown)) DCNL DCSP old = {} DCNL DCSP for (name, variable) in variables.items(): DCNL DCSP  DCSP old_value = variable.__get__(True, None) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP variable.__set__(None, values[name]) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP for (key, old_value) in old.items(): DCNL DCSP  DCSP  DCSP  DCSP variables[key].__set__(None, old_value) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP old[name] = old_value DCNL DCSP return old
 DCSP out = [] DCNL DCSP nd = len(args) DCNL DCSP for (k, new) in enumerate(args): DCNL DCSP  DCSP if (new is None): DCNL DCSP  DCSP  DCSP out.append(slice(None)) DCNL DCSP  DCSP new = tt.as_tensor(new) DCNL DCSP  DCSP if (new.ndim != 1): DCNL DCSP  DCSP  DCSP raise ValueError('Cross DCSP index DCSP must DCSP be DCSP 1 DCSP dimensional') DCNL DCSP  DCSP new = new.reshape(((((1,) * k) + (new.size,)) + ((1,) * ((nd - k) - 1)))) DCNL DCSP  DCSP out.append(new) DCNL DCSP return tuple(out)
 DCSP (L, xbins, ybins) = np.histogram2d(trace1, trace2, nbins) DCNL DCSP L[(L == 0)] = 1e-16 DCNL DCSP shape = L.shape DCNL DCSP L = L.ravel() DCNL DCSP i_sort = np.argsort(L)[::(-1)] DCNL DCSP i_unsort = np.argsort(i_sort) DCNL DCSP L_cumsum = L[i_sort].cumsum() DCNL DCSP L_cumsum /= L_cumsum[(-1)] DCNL DCSP xbins = (0.5 * (xbins[1:] + xbins[:(-1)])) DCNL DCSP ybins = (0.5 * (ybins[1:] + ybins[:(-1)])) DCNL DCSP return (xbins, ybins, L_cumsum[i_unsort].reshape(shape))
 DCSP (xbins, ybins, sigma) = compute_sigma_level(trace[0], trace[1]) DCNL DCSP ax.contour(xbins, ybins, sigma.T, levels=[0.683, 0.955], **kwargs) DCNL DCSP if scatter: DCNL DCSP  DCSP ax.plot(trace[0], trace[1], ',k', alpha=0.1) DCNL DCSP ax.set_xlabel('$\\alpha$') DCNL DCSP ax.set_ylabel('$\\beta$')
 DCSP ax.plot(xdata, ydata, 'ok') DCNL DCSP (alpha, beta) = trace[:2] DCNL DCSP xfit = np.linspace((-20), 120, 10) DCNL DCSP yfit = (alpha[:, None] + (beta[:, None] * xfit)) DCNL DCSP mu = yfit.mean(0) DCNL DCSP sig = (2 * yfit.std(0)) DCNL DCSP ax.plot(xfit, mu, '-k') DCNL DCSP ax.fill_between(xfit, (mu - sig), (mu + sig), color='lightgray') DCNL DCSP ax.set_xlabel('x') DCNL DCSP ax.set_ylabel('y')
 DCSP (_, ax) = plt.subplots(1, 2, figsize=(10, 4)) DCNL DCSP plot_MCMC_trace(ax[0], xdata, ydata, trace, True, colors=colors) DCNL DCSP plot_MCMC_model(ax[1], xdata, ydata, trace)
 DCSP if (acc_rate < 0.001): DCNL DCSP  DCSP scale *= 0.1 DCNL DCSP elif (acc_rate < 0.05): DCNL DCSP  DCSP scale *= 0.5 DCNL DCSP elif (acc_rate < 0.2): DCNL DCSP  DCSP scale *= 0.9 DCNL DCSP elif (acc_rate > 0.95): DCNL DCSP  DCSP scale *= 10.0 DCNL DCSP elif (acc_rate > 0.75): DCNL DCSP  DCSP scale *= 2.0 DCNL DCSP elif (acc_rate > 0.5): DCNL DCSP  DCSP scale *= 1.1 DCNL DCSP return scale
 DCSP return proposal_dists[proposal_name](scale)
 DCSP warnings.warn(EXPERIMENTAL_WARNING) DCNL DCSP model = modelcontext(model) DCNL DCSP if (random_seed != (-1)): DCNL DCSP  DCSP nr.seed(random_seed) DCNL DCSP if (step is None): DCNL DCSP  DCSP pm._log.info('Argument DCSP `step` DCSP is DCSP None. DCSP Auto-initialising DCSP step DCSP object DCSP using DCSP given/default DCSP parameters.') DCNL DCSP  DCSP step = SMC(n_chains=n_chains, tune_interval=tune_interval, model=model) DCNL DCSP if (homepath is None): DCNL DCSP  DCSP raise TypeError('Argument DCSP `homepath` DCSP should DCSP be DCSP path DCSP to DCSP result_directory.') DCNL DCSP if (n_jobs > 1): DCNL DCSP  DCSP if (not (step.n_chains / float(n_jobs)).is_integer()): DCNL DCSP  DCSP  DCSP raise TypeError('n_chains DCSP / DCSP n_jobs DCSP has DCSP to DCSP be DCSP a DCSP whole DCSP number!') DCNL DCSP if (start is not None): DCNL DCSP  DCSP if (len(start) != step.n_chains): DCNL DCSP  DCSP  DCSP raise TypeError('Argument DCSP `start` DCSP should DCSP have DCSP dicts DCSP equal DCSP the DCSP number DCSP of DCSP chains DCSP (`step.n_chains`)') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP step.population = start DCNL DCSP if (not any(((step.likelihood_name in var.name) for var in model.deterministics))): DCNL DCSP  DCSP raise TypeError(('Model DCSP (deterministic) DCSP variables DCSP need DCSP to DCSP contain DCSP a DCSP variable DCSP %s DCSP as DCSP defined DCSP in DCSP `step`.' % step.likelihood_name)) DCNL DCSP step.n_steps = int(n_steps) DCNL DCSP stage_handler = atext.TextStage(homepath) DCNL DCSP if (progressbar and (n_jobs > 1)): DCNL DCSP  DCSP progressbar = False DCNL DCSP if (stage == 0): DCNL DCSP  DCSP step.stage = stage DCNL DCSP  DCSP draws = 1 DCNL DCSP else: DCNL DCSP  DCSP step = stage_handler.load_atmip_params(stage, model=model) DCNL DCSP  DCSP draws = step.n_steps DCNL DCSP stage_handler.clean_directory(stage, None, rm_flag) DCNL DCSP chains = stage_handler.recover_existing_results(stage, draws, step) DCNL DCSP with model: DCNL DCSP  DCSP while (step.beta < 1): DCNL DCSP  DCSP  DCSP if (step.stage == 0): DCNL DCSP  DCSP  DCSP  DCSP pm._log.info('Sample DCSP initial DCSP stage: DCSP ...') DCNL DCSP  DCSP  DCSP  DCSP draws = 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP draws = n_steps DCNL DCSP  DCSP  DCSP pm._log.info(('Beta: DCSP %f DCSP Stage: DCSP %i' % (step.beta, step.stage))) DCNL DCSP  DCSP  DCSP chains = stage_handler.clean_directory(step.stage, chains, rm_flag) DCNL DCSP  DCSP  DCSP sample_args = {'draws': draws, 'step': step, 'stage_path': stage_handler.stage_path(step.stage), 'progressbar': progressbar, 'model': model, 'n_jobs': n_jobs, 'chains': chains} DCNL DCSP  DCSP  DCSP _iter_parallel_chains(**sample_args) DCNL DCSP  DCSP  DCSP mtrace = stage_handler.load_multitrace(step.stage) DCNL DCSP  DCSP  DCSP (step.population, step.array_population, step.likelihoods) = step.select_end_points(mtrace) DCNL DCSP  DCSP  DCSP (step.beta, step.old_beta, step.weights) = step.calc_beta() DCNL DCSP  DCSP  DCSP if (step.beta > 1.0): DCNL DCSP  DCSP  DCSP  DCSP pm._log.info(('Beta DCSP > DCSP 1.: DCSP %f' % step.beta)) DCNL DCSP  DCSP  DCSP  DCSP step.beta = 1.0 DCNL DCSP  DCSP  DCSP  DCSP stage_handler.dump_atmip_params(step) DCNL DCSP  DCSP  DCSP  DCSP if (stage == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP chains = [] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP chains = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP step.covariance = step.calc_covariance() DCNL DCSP  DCSP  DCSP  DCSP step.proposal_dist = choose_proposal(step.proposal_name, scale=step.covariance) DCNL DCSP  DCSP  DCSP  DCSP step.resampling_indexes = step.resample() DCNL DCSP  DCSP  DCSP  DCSP step.chain_previous_lpoint = step.get_chain_previous_lpoint(mtrace) DCNL DCSP  DCSP  DCSP  DCSP stage_handler.dump_atmip_params(step) DCNL DCSP  DCSP  DCSP  DCSP step.stage += 1 DCNL DCSP  DCSP  DCSP  DCSP del mtrace DCNL DCSP  DCSP pm._log.info('Sample DCSP final DCSP stage') DCNL DCSP  DCSP step.stage = (-1) DCNL DCSP  DCSP chains = stage_handler.clean_directory(step.stage, chains, rm_flag) DCNL DCSP  DCSP temp = np.exp(((1 - step.old_beta) * (step.likelihoods - step.likelihoods.max()))) DCNL DCSP  DCSP step.weights = (temp / np.sum(temp)) DCNL DCSP  DCSP step.covariance = step.calc_covariance() DCNL DCSP  DCSP step.proposal_dist = choose_proposal(step.proposal_name, scale=step.covariance) DCNL DCSP  DCSP step.resampling_indexes = step.resample() DCNL DCSP  DCSP step.chain_previous_lpoint = step.get_chain_previous_lpoint(mtrace) DCNL DCSP  DCSP sample_args['draws'] = n_steps DCNL DCSP  DCSP sample_args['step'] = step DCNL DCSP  DCSP sample_args['stage_path'] = stage_handler.stage_path(step.stage) DCNL DCSP  DCSP sample_args['chains'] = chains DCNL DCSP  DCSP _iter_parallel_chains(**sample_args) DCNL DCSP  DCSP stage_handler.dump_atmip_params(step) DCNL DCSP  DCSP return stage_handler.create_result_trace(step.stage, step=step, model=model)
 DCSP model = modelcontext(model) DCNL DCSP draws = int(draws) DCNL DCSP if (draws < 1): DCNL DCSP  DCSP raise ValueError('Argument DCSP `draws` DCSP should DCSP be DCSP above DCSP 0.') DCNL DCSP if (start is None): DCNL DCSP  DCSP start = {} DCNL DCSP if (random_seed != (-1)): DCNL DCSP  DCSP nr.seed(random_seed) DCNL DCSP try: DCNL DCSP  DCSP step = pm.step_methods.CompoundStep(step) DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP point = pm.Point(start, model=model) DCNL DCSP step.chain_index = chain DCNL DCSP trace.setup(draws, chain) DCNL DCSP for i in range(draws): DCNL DCSP  DCSP if (i == tune): DCNL DCSP  DCSP  DCSP step = pm.sampling.stop_tuning(step) DCNL DCSP  DCSP (point, out_list) = step.step(point) DCNL DCSP  DCSP trace.record(out_list) DCNL DCSP  DCSP (yield trace)
 DCSP return _sample(*work)
 DCSP if (chains is None): DCNL DCSP  DCSP chains = range(step.n_chains) DCNL DCSP pm._log.info('Initialising DCSP chain DCSP traces DCSP ...') DCNL DCSP max_int = np.iinfo(np.int32).max DCNL DCSP random_seeds = nr.randint(1, max_int, size=len(chains)) DCNL DCSP pm._log.info('Sampling DCSP ...') DCNL DCSP work = [(draws, step, step.population[step.resampling_indexes[chain]], atext.TextChain(stage_path, model=model), chain, None, False, model, rseed) for (chain, rseed) in zip(chains, random_seeds)] DCNL DCSP if (draws < 10): DCNL DCSP  DCSP chunksize = n_jobs DCNL DCSP else: DCNL DCSP  DCSP chunksize = 1 DCNL DCSP p = atext.paripool(_work_chain, work, chunksize=chunksize, nprocs=n_jobs) DCNL DCSP if ((n_jobs == 1) and progressbar): DCNL DCSP  DCSP p = tqdm(p, total=len(chains)) DCNL DCSP for _ in p: DCNL DCSP  DCSP pass
 DCSP a = (1.0 / 9) DCNL DCSP b = (8.0 / 9) DCNL DCSP return np.power((a + (b * acc_rate)), 2)
 DCSP (out_list, inarray0) = join_nonshared_inputs(out_vars, vars, shared) DCNL DCSP f = theano.function([inarray0], out_list) DCNL DCSP f.trust_input = True DCNL DCSP return f
 DCSP dlogp = gradient(logpt, model_vars) DCNL DCSP ((logp, dlogp), q) = join_nonshared_inputs([logpt, dlogp], model_vars, shared) DCNL DCSP dlogp_func = theano.function(inputs=[q], outputs=dlogp) DCNL DCSP dlogp_func.trust_input = True DCNL DCSP logp = CallableTensor(logp) DCNL DCSP dlogp = CallableTensor(dlogp) DCNL DCSP return (Hamiltonian(logp, dlogp, potential), q, dlogp_func)
 DCSP p = tt.vector('p') DCNL DCSP p.tag.test_value = q.tag.test_value DCNL DCSP total_energy = (H.pot.energy(p) - H.logp(q)) DCNL DCSP energy_function = theano.function(inputs=[q, p], outputs=total_energy, **theano_kwargs) DCNL DCSP energy_function.trust_input = True DCNL DCSP return (energy_function, p)
 DCSP epsilon = tt.scalar('epsilon') DCNL DCSP epsilon.tag.test_value = 1.0 DCNL DCSP n_steps = tt.iscalar('n_steps') DCNL DCSP n_steps.tag.test_value = 2 DCNL DCSP (q_new, p_new) = leapfrog(H, q, p, epsilon, n_steps) DCNL DCSP energy_new = energy(H, q_new, p_new) DCNL DCSP f = theano.function([q, p, epsilon, n_steps], [q_new, p_new, energy_new], **theano_kwargs) DCNL DCSP f.trust_input = True DCNL DCSP return f
 DCSP (H, q, dlogp) = _theano_hamiltonian(model_vars, shared, logpt, potential) DCNL DCSP (energy_function, p) = _theano_energy_function(H, q, **theano_kwargs) DCNL DCSP velocity_function = _theano_velocity_function(H, p, **theano_kwargs) DCNL DCSP if use_single_leapfrog: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _theano_integrator = INTEGRATORS_SINGLE[integrator] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise ValueError(('Unknown DCSP integrator: DCSP %s' % integrator)) DCNL DCSP  DCSP integrator = _theano_integrator(H, q, p, H.dlogp(q), **theano_kwargs) DCNL DCSP else: DCNL DCSP  DCSP if (integrator != 'leapfrog'): DCNL DCSP  DCSP  DCSP raise ValueError('Only DCSP leapfrog DCSP is DCSP supported') DCNL DCSP  DCSP integrator = _theano_leapfrog_integrator(H, q, p, **theano_kwargs) DCNL DCSP return (H, energy_function, velocity_function, integrator, dlogp)
 DCSP return (H.pot.energy(p) - H.logp(q))
 DCSP def full_update(p, q): DCNL DCSP  DCSP p = (p + (epsilon * H.dlogp(q))) DCNL DCSP  DCSP q += (epsilon * H.pot.velocity(p)) DCNL DCSP  DCSP return (p, q) DCNL DCSP p = (p + ((0.5 * epsilon) * H.dlogp(q))) DCNL DCSP q += (epsilon * H.pot.velocity(p)) DCNL DCSP if tt.gt(n_steps, 1): DCNL DCSP  DCSP ((p_seq, q_seq), _) = theano.scan(full_update, outputs_info=[p, q], n_steps=(n_steps - 1)) DCNL DCSP  DCSP (p, q) = (p_seq[(-1)], q_seq[(-1)]) DCNL DCSP p += ((0.5 * epsilon) * H.dlogp(q)) DCNL DCSP return (q, p)
 DCSP epsilon = tt.scalar('epsilon') DCNL DCSP epsilon.tag.test_value = 1.0 DCNL DCSP a = (12127897.0 / 102017882) DCNL DCSP b = (4271554.0 / 14421423) DCNL DCSP p_ae = (p + ((floatX(a) * epsilon) * q_grad)) DCNL DCSP q_be = (q + ((floatX(b) * epsilon) * H.pot.velocity(p_ae))) DCNL DCSP p_e2 = (p_ae + ((floatX((0.5 - a)) * epsilon) * H.dlogp(q_be))) DCNL DCSP q_1be = (q_be + ((floatX((1 - (2 * b))) * epsilon) * H.pot.velocity(p_e2))) DCNL DCSP p_1ae = (p_e2 + ((floatX((0.5 - a)) * epsilon) * H.dlogp(q_1be))) DCNL DCSP q_e = (q_1be + ((floatX(b) * epsilon) * H.pot.velocity(p_1ae))) DCNL DCSP grad_e = H.dlogp(q_e) DCNL DCSP p_e = (p_1ae + ((floatX(a) * epsilon) * grad_e)) DCNL DCSP v_e = H.pot.velocity(p_e) DCNL DCSP new_energy = energy(H, q_e, p_e) DCNL DCSP f = theano.function(inputs=[q, p, q_grad, epsilon], outputs=[q_e, p_e, v_e, grad_e, new_energy], **theano_kwargs) DCNL DCSP f.trust_input = True DCNL DCSP return f
 DCSP epsilon = tt.scalar('epsilon') DCNL DCSP epsilon.tag.test_value = 1.0 DCNL DCSP a = floatX(((3 - np.sqrt(3)) / 6)) DCNL DCSP p_ae = (p + ((a * epsilon) * q_grad)) DCNL DCSP q_e2 = (q + ((epsilon / 2) * H.pot.velocity(p_ae))) DCNL DCSP p_1ae = (p_ae + (((1 - (2 * a)) * epsilon) * H.dlogp(q_e2))) DCNL DCSP q_e = (q_e2 + ((epsilon / 2) * H.pot.velocity(p_1ae))) DCNL DCSP grad_e = H.dlogp(q_e) DCNL DCSP p_e = (p_1ae + ((a * epsilon) * grad_e)) DCNL DCSP v_e = H.pot.velocity(p_e) DCNL DCSP new_energy = energy(H, q_e, p_e) DCNL DCSP f = theano.function(inputs=[q, p, q_grad, epsilon], outputs=[q_e, p_e, v_e, grad_e, new_energy], **theano_kwargs) DCNL DCSP f.trust_input = True DCNL DCSP return f
 DCSP epsilon = tt.scalar('epsilon') DCNL DCSP epsilon.tag.test_value = 1.0 DCNL DCSP p_new = (p + ((0.5 * epsilon) * q_grad)) DCNL DCSP q_new = (q + (epsilon * H.pot.velocity(p_new))) DCNL DCSP q_new_grad = H.dlogp(q_new) DCNL DCSP p_new += ((0.5 * epsilon) * q_new_grad) DCNL DCSP energy_new = energy(H, q_new, p_new) DCNL DCSP v_new = H.pot.velocity(p_new) DCNL DCSP f = theano.function(inputs=[q, p, q_grad, epsilon], outputs=[q_new, p_new, v_new, q_new_grad, energy_new], **theano_kwargs) DCNL DCSP f.trust_input = True DCNL DCSP return f
 DCSP if issparse(C): DCNL DCSP  DCSP if (not chol_available): DCNL DCSP  DCSP  DCSP raise ImportError('Sparse DCSP mass DCSP matrices DCSP require DCSP scikits.sparse') DCNL DCSP  DCSP elif is_cov: DCNL DCSP  DCSP  DCSP return QuadPotentialSparse(C) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('Sparse DCSP precision DCSP matrices DCSP are DCSP not DCSP supported') DCNL DCSP partial_check_positive_definite(C) DCNL DCSP if (C.ndim == 1): DCNL DCSP  DCSP if is_cov: DCNL DCSP  DCSP  DCSP return QuadPotentialDiag(C) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return QuadPotentialDiag((1.0 / C)) DCNL DCSP elif is_cov: DCNL DCSP  DCSP return QuadPotentialFull(C) DCNL DCSP else: DCNL DCSP  DCSP return QuadPotentialFullInv(C)
 DCSP if (C.ndim == 1): DCNL DCSP  DCSP d = C DCNL DCSP else: DCNL DCSP  DCSP d = np.diag(C) DCNL DCSP (i,) = np.nonzero(np.logical_or(np.isnan(d), (d <= 0))) DCNL DCSP if len(i): DCNL DCSP  DCSP raise PositiveDefiniteError('Simple DCSP check DCSP failed. DCSP Diagonal DCSP contains DCSP negatives', i)
 DCSP return isinstance(value, QuadPotential)
 DCSP if (not cond): DCNL DCSP  DCSP raise ValueError(str)
 DCSP terms = tt.concatenate([theano.grad(var.logpt, var).flatten() for var in vars], axis=0) DCNL DCSP dlogp = theano.clone(terms, flat_view.replacements, strict=False) DCNL DCSP return dlogp
 DCSP obs_var = model.observed_RVs[0] DCNL DCSP logL = obs_var.logp_elemwiset.sum(axis=tuple(range(1, obs_var.logp_elemwiset.ndim))) DCNL DCSP terms = [] DCNL DCSP for var in vars: DCNL DCSP  DCSP (output, _) = theano.scan((lambda i, logX=logL, v=var: theano.grad(logX[i], v).flatten()), sequences=[tt.arange(logL.shape[0])]) DCNL DCSP  DCSP terms.append(output) DCNL DCSP dlogL = theano.clone(tt.concatenate(terms, axis=1), flat_view.replacements, strict=False) DCNL DCSP return dlogL
 DCSP if (np.isfinite(mr) and (np.log(uniform()) < mr)): DCNL DCSP  DCSP return (q, True) DCNL DCSP else: DCNL DCSP  DCSP return (q0, False)
 DCSP if (len([i for i in [cov, chol] if (i is not None)]) != 1): DCNL DCSP  DCSP raise ValueError('Must DCSP pass DCSP exactly DCSP one DCSP of DCSP cov DCSP or DCSP chol') DCNL DCSP if (cov is not None): DCNL DCSP  DCSP chol = tt.slinalg.cholesky(cov) DCNL DCSP return chol
 DCSP if (minibatch_RVs is not None): DCNL DCSP  DCSP _value_error(isinstance(minibatch_RVs, list), 'minibatch_RVs DCSP must DCSP be DCSP a DCSP list.') DCNL DCSP  DCSP _value_error(((local_RVs is None) and (observed_RVs is None)), ('When DCSP minibatch_RVs DCSP is DCSP given, DCSP local_RVs DCSP and DCSP ' + 'observed_RVs DCSP must DCSP be DCSP None.')) DCNL DCSP  DCSP s = floatX((total_size / minibatch_tensors[0].shape[0])) DCNL DCSP  DCSP local_RVs = OrderedDict() DCNL DCSP  DCSP observed_RVs = OrderedDict([(v, s) for v in minibatch_RVs]) DCNL DCSP else: DCNL DCSP  DCSP _value_error((isinstance(local_RVs, OrderedDict) and isinstance(observed_RVs, OrderedDict)), 'local_RVs DCSP and DCSP observed_RVs DCSP must DCSP be DCSP OrderedDict.') DCNL DCSP return (local_RVs, observed_RVs)
 DCSP factors = ((([(c * v.logpt) for (v, c) in observed_RVs.items()] + [(c * v.logpt) for (v, c) in global_RVs.items()]) + [(c * v.logpt) for (v, (_, c)) in local_RVs.items()]) + potentials) DCNL DCSP logpt = tt.add(*map(tt.sum, factors)) DCNL DCSP return logpt
 DCSP if (random_seed is None): DCNL DCSP  DCSP r = MRG_RandomStreams(gen_random_state()) DCNL DCSP else: DCNL DCSP  DCSP r = MRG_RandomStreams(seed=random_seed) DCNL DCSP normal_const = floatX((1 + np.log((2.0 * np.pi)))) DCNL DCSP elbo = 0 DCNL DCSP if (uw_l is not None): DCNL DCSP  DCSP l_l = (uw_l.size / 2).astype('int32') DCNL DCSP  DCSP u_l = uw_l[:l_l] DCNL DCSP  DCSP w_l = uw_l[l_l:] DCNL DCSP  DCSP ns_l = r.normal(size=(n_mcsamples, inarray_l.tag.test_value.shape[0])) DCNL DCSP  DCSP zs_l = ((ns_l * tt.exp(w_l)) + u_l) DCNL DCSP  DCSP elbo += tt.sum((c_l * (w_l + (0.5 * normal_const)))) DCNL DCSP else: DCNL DCSP  DCSP zs_l = None DCNL DCSP if (uw_g is not None): DCNL DCSP  DCSP l_g = (uw_g.size / 2).astype('int32') DCNL DCSP  DCSP u_g = uw_g[:l_g] DCNL DCSP  DCSP w_g = uw_g[l_g:] DCNL DCSP  DCSP ns_g = r.normal(size=(n_mcsamples, inarray_g.tag.test_value.shape[0])) DCNL DCSP  DCSP zs_g = ((ns_g * tt.exp(w_g)) + u_g) DCNL DCSP  DCSP elbo += tt.sum((c_g * (w_g + (0.5 * normal_const)))) DCNL DCSP else: DCNL DCSP  DCSP zs_g = None DCNL DCSP if ((zs_l is not None) and (zs_g is not None)): DCNL DCSP  DCSP def logp_(z_g, z_l): DCNL DCSP  DCSP  DCSP return theano.clone(logp, OrderedDict({inarray_g: z_g, inarray_l: z_l}), strict=False) DCNL DCSP  DCSP sequences = [zs_g, zs_l] DCNL DCSP elif (zs_l is not None): DCNL DCSP  DCSP def logp_(z_l): DCNL DCSP  DCSP  DCSP return theano.clone(logp, OrderedDict({inarray_l: z_l}), strict=False) DCNL DCSP  DCSP sequences = [zs_l] DCNL DCSP else: DCNL DCSP  DCSP def logp_(z_g): DCNL DCSP  DCSP  DCSP return theano.clone(logp, OrderedDict({inarray_g: z_g}), strict=False) DCNL DCSP  DCSP sequences = [zs_g] DCNL DCSP (logps, _) = theano.scan(fn=logp_, outputs_info=None, sequences=sequences) DCNL DCSP elbo += tt.mean(logps) DCNL DCSP return elbo
 DCSP import warnings DCNL DCSP warnings.warn('Old DCSP ADVI DCSP interface DCSP is DCSP deprecated DCSP and DCSP be DCSP removed DCSP in DCSP future, DCSP use DCSP pm.ADVI DCSP instead', DeprecationWarning, stacklevel=2) DCNL DCSP if (encoder_params is None): DCNL DCSP  DCSP encoder_params = [] DCNL DCSP model = pm.modelcontext(model) DCNL DCSP vars = inputvars((vars if (vars is not None) else model.vars)) DCNL DCSP start = (start if (start is not None) else model.test_point) DCNL DCSP if (not pm.model.all_continuous(vars)): DCNL DCSP  DCSP raise ValueError('Model DCSP can DCSP not DCSP include DCSP discrete DCSP RVs DCSP for DCSP ADVI.') DCNL DCSP _check_minibatches(minibatch_tensors, minibatches) DCNL DCSP if (encoder_params is None): DCNL DCSP  DCSP encoder_params = [] DCNL DCSP if (optimizer is None): DCNL DCSP  DCSP optimizer = adagrad_optimizer(learning_rate, epsilon) DCNL DCSP (local_RVs, observed_RVs) = _get_rvss(minibatch_RVs, local_RVs, observed_RVs, minibatch_tensors, total_size) DCNL DCSP def get_transformed(v): DCNL DCSP  DCSP if hasattr(v, 'transformed'): DCNL DCSP  DCSP  DCSP return v.transformed DCNL DCSP  DCSP return v DCNL DCSP local_RVs = OrderedDict([(get_transformed(v), (uw, s)) for (v, (uw, s)) in local_RVs.items()]) DCNL DCSP grvs = list((set(vars) - set((list(local_RVs) + list(observed_RVs))))) DCNL DCSP if (global_RVs is None): DCNL DCSP  DCSP global_RVs = OrderedDict({v: 1 for v in grvs}) DCNL DCSP elif (len(grvs) != len(global_RVs)): DCNL DCSP  DCSP _value_error('global_RVs DCSP ({}) DCSP must DCSP have DCSP all DCSP global DCSP RVs: DCSP {}'.format([v for v in global_RVs], grvs)) DCNL DCSP (elbo, uw_l, uw_g) = _make_elbo_t(observed_RVs, global_RVs, local_RVs, model.potentials, n_mcsamples, random_seed) DCNL DCSP replaces = dict() DCNL DCSP if (0 < len(global_RVs)): DCNL DCSP  DCSP (uw_global_shared, bij) = _init_uw_global_shared(start, global_RVs) DCNL DCSP  DCSP replaces.update({uw_g: uw_global_shared}) DCNL DCSP if (0 < len(local_RVs)): DCNL DCSP  DCSP uws = [uw for (_, (uw, _)) in local_RVs.items()] DCNL DCSP  DCSP uw_local_encoded = tt.concatenate(([uw[0].ravel() for uw in uws] + [uw[1].ravel() for uw in uws])) DCNL DCSP  DCSP replaces.update({uw_l: uw_local_encoded}) DCNL DCSP elbo = theano.clone(elbo, OrderedDict(replaces), strict=False) DCNL DCSP def is_shared(t): DCNL DCSP  DCSP return isinstance(t, theano.compile.sharedvalue.SharedVariable) DCNL DCSP tensors = [(t.type() if is_shared(t) else t) for t in minibatch_tensors] DCNL DCSP updates = OrderedDict({t: t_ for (t, t_) in zip(minibatch_tensors, tensors) if is_shared(t)}) DCNL DCSP elbo = theano.clone(elbo, updates, strict=False) DCNL DCSP params = encoder_params DCNL DCSP if (0 < len(global_RVs)): DCNL DCSP  DCSP params += [uw_global_shared] DCNL DCSP updates = OrderedDict(optimizer(loss=((-1) * elbo), param=params)) DCNL DCSP f = theano.function(tensors, elbo, updates=updates, mode=mode) DCNL DCSP elbos = np.empty(n) DCNL DCSP progress = tqdm.trange(n) DCNL DCSP for i in progress: DCNL DCSP  DCSP e = f(*next(minibatches)) DCNL DCSP  DCSP if np.isnan(e): DCNL DCSP  DCSP  DCSP raise FloatingPointError('NaN DCSP occurred DCSP in DCSP ADVI DCSP optimization.') DCNL DCSP  DCSP elbos[i] = e DCNL DCSP  DCSP if (n < 10): DCNL DCSP  DCSP  DCSP progress.set_description('ELBO DCSP = DCSP {:,.2f}'.format(elbos[i])) DCNL DCSP  DCSP elif (((i % (n // 10)) == 0) and (i > 0)): DCNL DCSP  DCSP  DCSP avg_elbo = infmean(elbos[(i - (n // 10)):i]) DCNL DCSP  DCSP  DCSP progress.set_description('Average DCSP ELBO DCSP = DCSP {:,.2f}'.format(avg_elbo)) DCNL DCSP pm._log.info('Finished DCSP minibatch DCSP ADVI: DCSP ELBO DCSP = DCSP {:,.2f}'.format(elbos[(-1)])) DCNL DCSP if (0 < len(global_RVs)): DCNL DCSP  DCSP l = int((uw_global_shared.get_value(borrow=True).size / 2)) DCNL DCSP  DCSP u = bij.rmap(uw_global_shared.get_value(borrow=True)[:l]) DCNL DCSP  DCSP w = bij.rmap(uw_global_shared.get_value(borrow=True)[l:]) DCNL DCSP  DCSP for var in w.keys(): DCNL DCSP  DCSP  DCSP w[var] = np.exp(w[var]) DCNL DCSP else: DCNL DCSP  DCSP u = dict() DCNL DCSP  DCSP w = dict() DCNL DCSP return ADVIFit(u, w, elbos)
 DCSP M1 = 2147483647 DCNL DCSP M2 = 2147462579 DCNL DCSP return (np.random.randint(0, M1, 3).tolist() + np.random.randint(0, M2, 3).tolist())
 DCSP import warnings DCNL DCSP warnings.warn('Old DCSP ADVI DCSP interface DCSP and DCSP sample_vp DCSP is DCSP deprecated DCSP and DCSP will DCSP be DCSP removed DCSP in DCSP future, DCSP use DCSP pm.fit DCSP and DCSP pm.sample_approx DCSP instead', DeprecationWarning, stacklevel=2) DCNL DCSP model = pm.modelcontext(model) DCNL DCSP if (start is None): DCNL DCSP  DCSP start = model.test_point DCNL DCSP if (vars is None): DCNL DCSP  DCSP vars = model.vars DCNL DCSP vars = pm.inputvars(vars) DCNL DCSP if (len(vars) == 0): DCNL DCSP  DCSP raise ValueError('No DCSP free DCSP random DCSP variables DCSP to DCSP fit.') DCNL DCSP if (not pm.model.all_continuous(vars)): DCNL DCSP  DCSP raise ValueError('Model DCSP can DCSP not DCSP include DCSP discrete DCSP RVs DCSP for DCSP ADVI.') DCNL DCSP n_mcsamples = (100 if accurate_elbo else 1) DCNL DCSP if (optimizer is None): DCNL DCSP  DCSP optimizer = adagrad_optimizer(learning_rate, epsilon) DCNL DCSP (elbo, shared) = _calc_elbo(vars, model, n_mcsamples=n_mcsamples, random_seed=random_seed) DCNL DCSP for (var, share) in shared.items(): DCNL DCSP  DCSP share.set_value(start[str(var)]) DCNL DCSP order = pm.ArrayOrdering(vars) DCNL DCSP bij = pm.DictToArrayBijection(order, start) DCNL DCSP u_start = bij.map(start) DCNL DCSP w_start = np.zeros_like(u_start) DCNL DCSP uw = np.concatenate([u_start, w_start]) DCNL DCSP uw_shared = theano.shared(uw, 'uw_shared') DCNL DCSP elbo = pm.CallableTensor(elbo)(uw_shared) DCNL DCSP updates = optimizer(loss=((-1) * elbo), param=[uw_shared]) DCNL DCSP f = theano.function([], [uw_shared, elbo], updates=updates, mode=mode) DCNL DCSP window_size = int(max(((0.1 * n) // eval_elbo), 2.0)) DCNL DCSP circ_buff = deque([], maxlen=window_size) DCNL DCSP elbos = np.empty(n) DCNL DCSP divergence_flag = False DCNL DCSP progress = (trange(n) if progressbar else range(n)) DCNL DCSP try: DCNL DCSP  DCSP (uw_i, elbo_current) = f() DCNL DCSP  DCSP if np.isnan(elbo_current): DCNL DCSP  DCSP  DCSP raise FloatingPointError('NaN DCSP occurred DCSP in DCSP ADVI DCSP optimization.') DCNL DCSP  DCSP for i in progress: DCNL DCSP  DCSP  DCSP (uw_i, e) = f() DCNL DCSP  DCSP  DCSP if np.isnan(e): DCNL DCSP  DCSP  DCSP  DCSP raise FloatingPointError('NaN DCSP occurred DCSP in DCSP ADVI DCSP optimization.') DCNL DCSP  DCSP  DCSP elbos[i] = e DCNL DCSP  DCSP  DCSP if progressbar: DCNL DCSP  DCSP  DCSP  DCSP if (n < 10): DCNL DCSP  DCSP  DCSP  DCSP  DCSP progress.set_description('ELBO DCSP = DCSP {:,.5g}'.format(elbos[i])) DCNL DCSP  DCSP  DCSP  DCSP elif (((i % (n // 10)) == 0) and (i > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP avg_elbo = infmean(elbos[(i - (n // 10)):i]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP progress.set_description('Average DCSP ELBO DCSP = DCSP {:,.5g}'.format(avg_elbo)) DCNL DCSP  DCSP  DCSP if ((i % eval_elbo) == 0): DCNL DCSP  DCSP  DCSP  DCSP elbo_prev = elbo_current DCNL DCSP  DCSP  DCSP  DCSP elbo_current = elbos[i] DCNL DCSP  DCSP  DCSP  DCSP delta_elbo = abs(((elbo_current - elbo_prev) / elbo_prev)) DCNL DCSP  DCSP  DCSP  DCSP circ_buff.append(delta_elbo) DCNL DCSP  DCSP  DCSP  DCSP avg_delta = np.mean(circ_buff) DCNL DCSP  DCSP  DCSP  DCSP med_delta = np.median(circ_buff) DCNL DCSP  DCSP  DCSP  DCSP if ((i > 0) and (avg_delta < tol_obj)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pm._log.info('Mean DCSP ELBO DCSP converged.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP elbos = elbos[:(i + 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP elif ((i > 0) and (med_delta < tol_obj)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pm._log.info('Median DCSP ELBO DCSP converged.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP elbos = elbos[:(i + 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (i > (10 * eval_elbo)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((med_delta > 0.5) or (avg_delta > 0.5)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP divergence_flag = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP divergence_flag = False DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP elbos = elbos[:i] DCNL DCSP  DCSP if (n < 10): DCNL DCSP  DCSP  DCSP pm._log.info('Interrupted DCSP at DCSP {:,d} DCSP [{:.0f}%]: DCSP ELBO DCSP = DCSP {:,.5g}'.format(i, ((100 * i) // n), elbos[i])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP avg_elbo = infmean(elbos[(i - (n // 10)):i]) DCNL DCSP  DCSP  DCSP pm._log.info('Interrupted DCSP at DCSP {:,d} DCSP [{:.0f}%]: DCSP Average DCSP ELBO DCSP = DCSP {:,.5g}'.format(i, ((100 * i) // n), avg_elbo)) DCNL DCSP else: DCNL DCSP  DCSP if (n < 10): DCNL DCSP  DCSP  DCSP pm._log.info('Finished DCSP [100%]: DCSP ELBO DCSP = DCSP {:,.5g}'.format(elbos[(-1)])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP avg_elbo = infmean(elbos[((- n) // 10):]) DCNL DCSP  DCSP  DCSP pm._log.info('Finished DCSP [100%]: DCSP Average DCSP ELBO DCSP = DCSP {:,.5g}'.format(avg_elbo)) DCNL DCSP finally: DCNL DCSP  DCSP if progressbar: DCNL DCSP  DCSP  DCSP progress.close() DCNL DCSP if divergence_flag: DCNL DCSP  DCSP pm._log.info('Evidence DCSP of DCSP divergence DCSP detected, DCSP inspect DCSP ELBO.') DCNL DCSP l = int((uw_i.size / 2)) DCNL DCSP u = bij.rmap(uw_i[:l]) DCNL DCSP w = bij.rmap(uw_i[l:]) DCNL DCSP for var in w.keys(): DCNL DCSP  DCSP w[var] = np.exp(w[var]) DCNL DCSP return ADVIFit(u, w, elbos)
 DCSP theano.config.compute_test_value = 'ignore' DCNL DCSP shared = pm.make_shared_replacements(vars, model) DCNL DCSP factors = ([var.logpt for var in model.basic_RVs] + model.potentials) DCNL DCSP logpt = tt.add(*map(tt.sum, factors)) DCNL DCSP ([logp], inarray) = pm.join_nonshared_inputs([logpt], vars, shared) DCNL DCSP uw = tt.vector('uw') DCNL DCSP uw.tag.test_value = floatX(np.concatenate([inarray.tag.test_value, inarray.tag.test_value])) DCNL DCSP elbo = _elbo_t(logp, uw, inarray, n_mcsamples, random_seed) DCNL DCSP return (elbo, shared)
 DCSP l = (uw.size / 2) DCNL DCSP l_int = l.astype('int32') DCNL DCSP u = uw[:l_int] DCNL DCSP w = uw[l_int:] DCNL DCSP def logp_(input): DCNL DCSP  DCSP return theano.clone(logp, {inarray: input}, strict=False) DCNL DCSP if (random_seed is None): DCNL DCSP  DCSP r = MRG_RandomStreams(gen_random_state()) DCNL DCSP else: DCNL DCSP  DCSP r = MRG_RandomStreams(seed=random_seed) DCNL DCSP if (n_mcsamples == 1): DCNL DCSP  DCSP n = r.normal(size=inarray.tag.test_value.shape) DCNL DCSP  DCSP q = ((n * tt.exp(w)) + u) DCNL DCSP  DCSP elbo = ((logp_(q) + tt.sum(w)) + ((0.5 * l) * (1 + tt.log((2.0 * np.pi))))) DCNL DCSP else: DCNL DCSP  DCSP n = r.normal(size=(n_mcsamples, u.tag.test_value.shape[0])) DCNL DCSP  DCSP qs = ((n * tt.exp(w)) + u) DCNL DCSP  DCSP (logps, _) = theano.scan(fn=(lambda q: logp_(q)), outputs_info=None, sequences=[qs]) DCNL DCSP  DCSP elbo = ((tt.mean(logps) + tt.sum(w)) + ((0.5 * l) * (1 + tt.log((2.0 * np.pi))))) DCNL DCSP return elbo
 DCSP def optimizer(loss, param): DCNL DCSP  DCSP updates = OrderedDict() DCNL DCSP  DCSP if (param is not list): DCNL DCSP  DCSP  DCSP param = list(param) DCNL DCSP  DCSP for param_ in param: DCNL DCSP  DCSP  DCSP i = theano.shared(floatX(np.array(0))) DCNL DCSP  DCSP  DCSP i_int = i.astype('int32') DCNL DCSP  DCSP  DCSP value = param_.get_value(borrow=True) DCNL DCSP  DCSP  DCSP accu = theano.shared(np.zeros((value.shape + (n_win,)), dtype=value.dtype)) DCNL DCSP  DCSP  DCSP grad = tt.grad(loss, param_) DCNL DCSP  DCSP  DCSP accu_new = tt.set_subtensor(accu[:, i_int], (grad ** 2)) DCNL DCSP  DCSP  DCSP i_new = tt.switch(((i + 1) < n_win), (i + 1), 0) DCNL DCSP  DCSP  DCSP updates[accu] = accu_new DCNL DCSP  DCSP  DCSP updates[i] = i_new DCNL DCSP  DCSP  DCSP accu_sum = accu_new.sum(axis=1) DCNL DCSP  DCSP  DCSP updates[param_] = (param_ - ((learning_rate * grad) / tt.sqrt((accu_sum + epsilon)))) DCNL DCSP  DCSP return updates DCNL DCSP return optimizer
 DCSP import warnings DCNL DCSP warnings.warn('Old DCSP ADVI DCSP interface DCSP and DCSP sample_vp DCSP is DCSP deprecated DCSP and DCSP will DCSP be DCSP removed DCSP in DCSP future, DCSP use DCSP pm.fit DCSP and DCSP pm.sample_approx DCSP instead', DeprecationWarning, stacklevel=2) DCNL DCSP model = pm.modelcontext(model) DCNL DCSP if isinstance(vparams, ADVIFit): DCNL DCSP  DCSP vparams = {'means': vparams.means, 'stds': vparams.stds} DCNL DCSP ds = model.deterministics DCNL DCSP def get_transformed(v): DCNL DCSP  DCSP return (v if (v not in ds) else v.transformed) DCNL DCSP def rvs(x): DCNL DCSP  DCSP return ([get_transformed(v) for v in x] if (x is not None) else []) DCNL DCSP global_RVs = list((set(model.free_RVs) - set(rvs(local_RVs)))) DCNL DCSP if (random_seed is None): DCNL DCSP  DCSP r = MRG_RandomStreams(gen_random_state()) DCNL DCSP else: DCNL DCSP  DCSP r = MRG_RandomStreams(seed=random_seed) DCNL DCSP updates = {} DCNL DCSP for v in global_RVs: DCNL DCSP  DCSP u = theano.shared(vparams['means'][str(v)]).ravel() DCNL DCSP  DCSP w = theano.shared(vparams['stds'][str(v)]).ravel() DCNL DCSP  DCSP n = r.normal(size=u.tag.test_value.shape) DCNL DCSP  DCSP updates.update({v: ((n * w) + u).reshape(v.tag.test_value.shape)}) DCNL DCSP if (local_RVs is not None): DCNL DCSP  DCSP for (v_, (uw, _)) in local_RVs.items(): DCNL DCSP  DCSP  DCSP v = get_transformed(v_) DCNL DCSP  DCSP  DCSP u = uw[0].ravel() DCNL DCSP  DCSP  DCSP w = uw[1].ravel() DCNL DCSP  DCSP  DCSP n = r.normal(size=u.tag.test_value.shape) DCNL DCSP  DCSP  DCSP updates.update({v: ((n * tt.exp(w)) + u).reshape(v.tag.test_value.shape)}) DCNL DCSP vars = model.free_RVs DCNL DCSP samples = theano.clone(vars, updates) DCNL DCSP f = theano.function([], samples) DCNL DCSP vars_sampled = pm.util.get_default_varnames(model.unobserved_RVs, include_transformed=include_transformed) DCNL DCSP varnames = [str(var) for var in model.unobserved_RVs] DCNL DCSP trace = pm.sampling.NDArray(model=model, vars=vars_sampled) DCNL DCSP trace.setup(draws=draws, chain=0) DCNL DCSP range_ = (trange(draws) if progressbar else range(draws)) DCNL DCSP for _ in range_: DCNL DCSP  DCSP point = {varname: value for (varname, value) in zip(varnames, f())} DCNL DCSP  DCSP trace.record(point) DCNL DCSP return MultiTrace([trace])
 DCSP return np.mean(np.asarray(input_array)[np.isfinite(input_array)])
 DCSP return property(memoize(change_flags(compute_test_value='off')(f)))
 DCSP if isinstance(params, dict): DCNL DCSP  DCSP return list((t[1] for t in sorted(params.items(), key=(lambda t: t[0])) if isinstance(t[1], theano.compile.SharedVariable))) DCNL DCSP elif (params is None): DCNL DCSP  DCSP return [] DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Unknown DCSP type DCSP %s DCSP for DCSP %r, DCSP need DCSP dict DCSP or DCSP None')
 DCSP if (not isinstance(approx, Approximation)): DCNL DCSP  DCSP raise TypeError(('Need DCSP Approximation DCSP instance, DCSP got DCSP %r' % approx)) DCNL DCSP return approx.sample(draws=draws, include_transformed=include_transformed)
 DCSP if (inf_kwargs is None): DCNL DCSP  DCSP inf_kwargs = dict() DCNL DCSP if (model is None): DCNL DCSP  DCSP model = pm.modelcontext(model) DCNL DCSP _select = dict(advi=ADVI, fullrank_advi=FullRankADVI, svgd=SVGD, asvgd=ASVGD, nfvi=NFVI) DCNL DCSP if isinstance(method, str): DCNL DCSP  DCSP method = method.lower() DCNL DCSP  DCSP if (method == 'advi->fullrank_advi'): DCNL DCSP  DCSP  DCSP frac = kwargs.pop('frac', 0.5) DCNL DCSP  DCSP  DCSP if (not (0.0 < frac < 1.0)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('frac DCSP should DCSP be DCSP in DCSP (0, DCSP 1)') DCNL DCSP  DCSP  DCSP n1 = int((n * frac)) DCNL DCSP  DCSP  DCSP n2 = (n - n1) DCNL DCSP  DCSP  DCSP inference = ADVI(local_rv=local_rv, model=model, random_seed=random_seed, start=start) DCNL DCSP  DCSP  DCSP logger.info('fitting DCSP advi DCSP ...') DCNL DCSP  DCSP  DCSP inference.fit(n1, **kwargs) DCNL DCSP  DCSP  DCSP inference = FullRankADVI.from_advi(inference) DCNL DCSP  DCSP  DCSP logger.info('fitting DCSP fullrank DCSP advi DCSP ...') DCNL DCSP  DCSP  DCSP return inference.fit(n2, **kwargs) DCNL DCSP  DCSP elif method.startswith('nfvi='): DCNL DCSP  DCSP  DCSP formula = method[5:] DCNL DCSP  DCSP  DCSP inference = NFVI(formula, local_rv=local_rv, model=model, random_seed=random_seed, start=start, **inf_kwargs) DCNL DCSP  DCSP elif (method in _select): DCNL DCSP  DCSP  DCSP inference = _select[method](local_rv=local_rv, model=model, random_seed=random_seed, start=start, **inf_kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise KeyError(('method DCSP should DCSP be DCSP one DCSP of DCSP %s DCSP or DCSP Inference DCSP instance' % set(_select.keys()))) DCNL DCSP elif isinstance(method, Inference): DCNL DCSP  DCSP inference = method DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('method DCSP should DCSP be DCSP one DCSP of DCSP %s DCSP or DCSP Inference DCSP instance' % set(_select.keys()))) DCNL DCSP return inference.fit(n, **kwargs)
 DCSP if any(((not isinstance(p, theano.compile.SharedVariable)) for p in params)): DCNL DCSP  DCSP raise ValueError('params DCSP must DCSP contain DCSP shared DCSP variables DCSP only. DCSP If DCSP it DCSP contains DCSP arbitrary DCSP parameter DCSP expressions, DCSP then DCSP lasagne.utils.collect_shared_vars() DCSP may DCSP help DCSP you.') DCNL DCSP if isinstance(loss_or_grads, list): DCNL DCSP  DCSP if (not (len(loss_or_grads) == len(params))): DCNL DCSP  DCSP  DCSP raise ValueError(('Got DCSP %d DCSP gradient DCSP expressions DCSP for DCSP %d DCSP parameters' % (len(loss_or_grads), len(params)))) DCNL DCSP  DCSP return loss_or_grads DCNL DCSP else: DCNL DCSP  DCSP return theano.grad(loss_or_grads, params)
 DCSP if ((loss_or_grads is None) and (params is None)): DCNL DCSP  DCSP return partial(sgd, **_get_call_kwargs(locals())) DCNL DCSP elif ((loss_or_grads is None) or (params is None)): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP both DCSP `loss_or_grads` DCSP and DCSP `params` DCSP to DCSP get DCSP updates') DCNL DCSP grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP updates = OrderedDict() DCNL DCSP for (param, grad) in zip(params, grads): DCNL DCSP  DCSP updates[param] = (param - (learning_rate * grad)) DCNL DCSP return updates
 DCSP if (params is None): DCNL DCSP  DCSP params = updates.keys() DCNL DCSP updates = OrderedDict(updates) DCNL DCSP for param in params: DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP velocity = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP x = ((momentum * velocity) + updates[param]) DCNL DCSP  DCSP updates[velocity] = (x - param) DCNL DCSP  DCSP updates[param] = x DCNL DCSP return updates
 DCSP if ((loss_or_grads is None) and (params is None)): DCNL DCSP  DCSP return partial(pm.updates.momentum, **_get_call_kwargs(locals())) DCNL DCSP elif ((loss_or_grads is None) or (params is None)): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP both DCSP `loss_or_grads` DCSP and DCSP `params` DCSP to DCSP get DCSP updates') DCNL DCSP updates = sgd(loss_or_grads, params, learning_rate) DCNL DCSP return apply_momentum(updates, momentum=momentum)
 DCSP if (params is None): DCNL DCSP  DCSP params = updates.keys() DCNL DCSP updates = OrderedDict(updates) DCNL DCSP for param in params: DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP velocity = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP x = (((momentum * velocity) + updates[param]) - param) DCNL DCSP  DCSP updates[velocity] = x DCNL DCSP  DCSP updates[param] = ((momentum * x) + updates[param]) DCNL DCSP return updates
 DCSP if ((loss_or_grads is None) and (params is None)): DCNL DCSP  DCSP return partial(nesterov_momentum, **_get_call_kwargs(locals())) DCNL DCSP elif ((loss_or_grads is None) or (params is None)): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP both DCSP `loss_or_grads` DCSP and DCSP `params` DCSP to DCSP get DCSP updates') DCNL DCSP updates = sgd(loss_or_grads, params, learning_rate) DCNL DCSP return apply_nesterov_momentum(updates, momentum=momentum)
 DCSP if ((loss_or_grads is None) and (params is None)): DCNL DCSP  DCSP return partial(adagrad, **_get_call_kwargs(locals())) DCNL DCSP elif ((loss_or_grads is None) or (params is None)): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP both DCSP `loss_or_grads` DCSP and DCSP `params` DCSP to DCSP get DCSP updates') DCNL DCSP grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP updates = OrderedDict() DCNL DCSP for (param, grad) in zip(params, grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP accu_new = (accu + (grad ** 2)) DCNL DCSP  DCSP updates[accu] = accu_new DCNL DCSP  DCSP updates[param] = (param - ((learning_rate * grad) / tt.sqrt((accu_new + epsilon)))) DCNL DCSP return updates
 DCSP if ((loss_or_grads is None) and (params is None)): DCNL DCSP  DCSP return partial(adagrad_window, **_get_call_kwargs(locals())) DCNL DCSP elif ((loss_or_grads is None) or (params is None)): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP both DCSP `loss_or_grads` DCSP and DCSP `params` DCSP to DCSP get DCSP updates') DCNL DCSP grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP updates = OrderedDict() DCNL DCSP for (param, grad) in zip(params, grads): DCNL DCSP  DCSP i = theano.shared(pm.floatX(0)) DCNL DCSP  DCSP i_int = i.astype('int32') DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shared(np.zeros((value.shape + (n_win,)), dtype=value.dtype)) DCNL DCSP  DCSP accu_new = tt.set_subtensor(accu[..., i_int], (grad ** 2)) DCNL DCSP  DCSP i_new = tt.switch(((i + 1) < n_win), (i + 1), 0) DCNL DCSP  DCSP updates[accu] = accu_new DCNL DCSP  DCSP updates[i] = i_new DCNL DCSP  DCSP accu_sum = accu_new.sum(axis=(-1)) DCNL DCSP  DCSP updates[param] = (param - ((learning_rate * grad) / tt.sqrt((accu_sum + epsilon)))) DCNL DCSP return updates
 DCSP if ((loss_or_grads is None) and (params is None)): DCNL DCSP  DCSP return partial(rmsprop, **_get_call_kwargs(locals())) DCNL DCSP elif ((loss_or_grads is None) or (params is None)): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP both DCSP `loss_or_grads` DCSP and DCSP `params` DCSP to DCSP get DCSP updates') DCNL DCSP grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP updates = OrderedDict() DCNL DCSP one = tt.constant(1) DCNL DCSP for (param, grad) in zip(params, grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP accu_new = ((rho * accu) + ((one - rho) * (grad ** 2))) DCNL DCSP  DCSP updates[accu] = accu_new DCNL DCSP  DCSP updates[param] = (param - ((learning_rate * grad) / tt.sqrt((accu_new + epsilon)))) DCNL DCSP return updates
 DCSP if ((loss_or_grads is None) and (params is None)): DCNL DCSP  DCSP return partial(adadelta, **_get_call_kwargs(locals())) DCNL DCSP elif ((loss_or_grads is None) or (params is None)): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP both DCSP `loss_or_grads` DCSP and DCSP `params` DCSP to DCSP get DCSP updates') DCNL DCSP grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP updates = OrderedDict() DCNL DCSP one = tt.constant(1) DCNL DCSP for (param, grad) in zip(params, grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP delta_accu = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP accu_new = ((rho * accu) + ((one - rho) * (grad ** 2))) DCNL DCSP  DCSP updates[accu] = accu_new DCNL DCSP  DCSP update = ((grad * tt.sqrt((delta_accu + epsilon))) / tt.sqrt((accu_new + epsilon))) DCNL DCSP  DCSP updates[param] = (param - (learning_rate * update)) DCNL DCSP  DCSP delta_accu_new = ((rho * delta_accu) + ((one - rho) * (update ** 2))) DCNL DCSP  DCSP updates[delta_accu] = delta_accu_new DCNL DCSP return updates
 DCSP if ((loss_or_grads is None) and (params is None)): DCNL DCSP  DCSP return partial(adam, **_get_call_kwargs(locals())) DCNL DCSP elif ((loss_or_grads is None) or (params is None)): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP both DCSP `loss_or_grads` DCSP and DCSP `params` DCSP to DCSP get DCSP updates') DCNL DCSP all_grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP t_prev = theano.shared(pm.theanof.floatX(0.0)) DCNL DCSP updates = OrderedDict() DCNL DCSP one = tt.constant(1) DCNL DCSP t = (t_prev + 1) DCNL DCSP a_t = ((learning_rate * tt.sqrt((one - (beta2 ** t)))) / (one - (beta1 ** t))) DCNL DCSP for (param, g_t) in zip(params, all_grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP m_prev = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP v_prev = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP m_t = ((beta1 * m_prev) + ((one - beta1) * g_t)) DCNL DCSP  DCSP v_t = ((beta2 * v_prev) + ((one - beta2) * (g_t ** 2))) DCNL DCSP  DCSP step = ((a_t * m_t) / (tt.sqrt(v_t) + epsilon)) DCNL DCSP  DCSP updates[m_prev] = m_t DCNL DCSP  DCSP updates[v_prev] = v_t DCNL DCSP  DCSP updates[param] = (param - step) DCNL DCSP updates[t_prev] = t DCNL DCSP return updates
 DCSP if ((loss_or_grads is None) and (params is None)): DCNL DCSP  DCSP return partial(adamax, **_get_call_kwargs(locals())) DCNL DCSP elif ((loss_or_grads is None) or (params is None)): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP both DCSP `loss_or_grads` DCSP and DCSP `params` DCSP to DCSP get DCSP updates') DCNL DCSP all_grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP t_prev = theano.shared(pm.theanof.floatX(0.0)) DCNL DCSP updates = OrderedDict() DCNL DCSP one = tt.constant(1) DCNL DCSP t = (t_prev + 1) DCNL DCSP a_t = (learning_rate / (one - (beta1 ** t))) DCNL DCSP for (param, g_t) in zip(params, all_grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP m_prev = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP u_prev = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP m_t = ((beta1 * m_prev) + ((one - beta1) * g_t)) DCNL DCSP  DCSP u_t = tt.maximum((beta2 * u_prev), abs(g_t)) DCNL DCSP  DCSP step = ((a_t * m_t) / (u_t + epsilon)) DCNL DCSP  DCSP updates[m_prev] = m_t DCNL DCSP  DCSP updates[u_prev] = u_t DCNL DCSP  DCSP updates[param] = (param - step) DCNL DCSP updates[t_prev] = t DCNL DCSP return updates
 DCSP ndim = tensor_var.ndim DCNL DCSP if (norm_axes is not None): DCNL DCSP  DCSP sum_over = tuple(norm_axes) DCNL DCSP elif (ndim == 2): DCNL DCSP  DCSP sum_over = (0,) DCNL DCSP elif (ndim in [3, 4, 5]): DCNL DCSP  DCSP sum_over = tuple(range(1, ndim)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unsupported DCSP tensor DCSP dimensionality DCSP {}.Must DCSP specify DCSP `norm_axes`'.format(ndim)) DCNL DCSP dtype = np.dtype(theano.config.floatX).type DCNL DCSP norms = tt.sqrt(tt.sum(tt.sqr(tensor_var), axis=sum_over, keepdims=True)) DCNL DCSP target_norms = tt.clip(norms, 0, dtype(max_norm)) DCNL DCSP constrained_output = (tensor_var * (target_norms / (dtype(epsilon) + norms))) DCNL DCSP return constrained_output
 DCSP norm = tt.sqrt(sum((tt.sum((tensor ** 2)) for tensor in tensor_vars))) DCNL DCSP dtype = np.dtype(theano.config.floatX).type DCNL DCSP target_norm = tt.clip(norm, 0, dtype(max_norm)) DCNL DCSP multiplier = (target_norm / (dtype(epsilon) + norm)) DCNL DCSP tensor_vars_scaled = [(step * multiplier) for step in tensor_vars] DCNL DCSP if return_norm: DCNL DCSP  DCSP return (tensor_vars_scaled, norm) DCNL DCSP else: DCNL DCSP  DCSP return tensor_vars_scaled
 DCSP if (np.ndim(x) > 1): DCNL DCSP  DCSP return [geweke(y, first, last, intervals) for y in np.transpose(x)] DCNL DCSP for interval in (first, last): DCNL DCSP  DCSP if ((interval <= 0) or (interval >= 1)): DCNL DCSP  DCSP  DCSP raise ValueError('Invalid DCSP intervals DCSP for DCSP Geweke DCSP convergence DCSP analysis', (first, last)) DCNL DCSP if ((first + last) >= 1): DCNL DCSP  DCSP raise ValueError('Invalid DCSP intervals DCSP for DCSP Geweke DCSP convergence DCSP analysis', (first, last)) DCNL DCSP zscores = [] DCNL DCSP end = (len(x) - 1) DCNL DCSP last_start_idx = ((1 - last) * end) DCNL DCSP start_indices = np.arange(0, int(last_start_idx), step=int((last_start_idx / (intervals - 1)))) DCNL DCSP for start in start_indices: DCNL DCSP  DCSP first_slice = x[start:(start + int((first * (end - start))))] DCNL DCSP  DCSP last_slice = x[int((end - (last * (end - start)))):] DCNL DCSP  DCSP z = (first_slice.mean() - last_slice.mean()) DCNL DCSP  DCSP z /= np.sqrt((first_slice.var() + last_slice.var())) DCNL DCSP  DCSP zscores.append([start, z]) DCNL DCSP if (intervals is None): DCNL DCSP  DCSP return np.array(zscores[0]) DCNL DCSP else: DCNL DCSP  DCSP return np.array(zscores)
 DCSP if (mtrace.nchains < 2): DCNL DCSP  DCSP raise ValueError('Gelman-Rubin DCSP diagnostic DCSP requires DCSP multiple DCSP chains DCSP of DCSP the DCSP same DCSP length.') DCNL DCSP Rhat = {} DCNL DCSP for var in mtrace.varnames: DCNL DCSP  DCSP x = np.array(mtrace.get_values(var, combine=False)) DCNL DCSP  DCSP num_samples = x.shape[1] DCNL DCSP  DCSP B = (num_samples * np.var(np.mean(x, axis=1), axis=0, ddof=1)) DCNL DCSP  DCSP W = np.mean(np.var(x, axis=1, ddof=1), axis=0) DCNL DCSP  DCSP Vhat = (((W * (num_samples - 1)) / num_samples) + (B / num_samples)) DCNL DCSP  DCSP Rhat[var] = np.sqrt((Vhat / W)) DCNL DCSP return Rhat
 DCSP if (mtrace.nchains < 2): DCNL DCSP  DCSP raise ValueError('Calculation DCSP of DCSP effective DCSP sample DCSP size DCSP requires DCSP multiple DCSP chains DCSP of DCSP the DCSP same DCSP length.') DCNL DCSP def get_vhat(x): DCNL DCSP  DCSP num_samples = x.shape[(-2)] DCNL DCSP  DCSP B = (num_samples * np.var(np.mean(x, axis=(-2)), axis=(-1), ddof=1)) DCNL DCSP  DCSP W = np.mean(np.var(x, axis=(-2), ddof=1), axis=(-1)) DCNL DCSP  DCSP Vhat = (((W * (num_samples - 1)) / num_samples) + (B / num_samples)) DCNL DCSP  DCSP return Vhat DCNL DCSP def get_neff(x, Vhat): DCNL DCSP  DCSP num_chains = x.shape[(-1)] DCNL DCSP  DCSP num_samples = x.shape[(-2)] DCNL DCSP  DCSP negative_autocorr = False DCNL DCSP  DCSP t = 1 DCNL DCSP  DCSP rho = np.ones(num_samples) DCNL DCSP  DCSP while ((not negative_autocorr) and (t < num_samples)): DCNL DCSP  DCSP  DCSP variogram = np.mean(((x[t:, :] - x[:(- t), :]) ** 2)) DCNL DCSP  DCSP  DCSP rho[t] = (1.0 - (variogram / (2.0 * Vhat))) DCNL DCSP  DCSP  DCSP negative_autocorr = (sum(rho[(t - 1):(t + 1)]) < 0) DCNL DCSP  DCSP  DCSP t += 1 DCNL DCSP  DCSP if (t % 2): DCNL DCSP  DCSP  DCSP t -= 1 DCNL DCSP  DCSP return min((num_chains * num_samples), int(((num_chains * num_samples) / (1.0 + (2 * rho[1:(t - 1)].sum()))))) DCNL DCSP n_eff = {} DCNL DCSP for var in mtrace.varnames: DCNL DCSP  DCSP x = np.array(mtrace.get_values(var, combine=False)) DCNL DCSP  DCSP if (len(x.shape) == 2): DCNL DCSP  DCSP  DCSP is_scalar = True DCNL DCSP  DCSP  DCSP x = np.atleast_3d(mtrace.get_values(var, combine=False)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP is_scalar = False DCNL DCSP  DCSP x = x.transpose() DCNL DCSP  DCSP Vhat = get_vhat(x) DCNL DCSP  DCSP _n_eff = np.zeros(x.shape[:(-2)]) DCNL DCSP  DCSP for tup in np.ndindex(*list(x.shape[:(-2)])): DCNL DCSP  DCSP  DCSP _n_eff[tup] = get_neff(x[tup], Vhat[tup]) DCNL DCSP  DCSP if is_scalar: DCNL DCSP  DCSP  DCSP n_eff[var] = _n_eff[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP n_eff[var] = np.transpose(_n_eff) DCNL DCSP return n_eff
 DCSP for method in methods: DCNL DCSP  DCSP if (hasattr(destination, method) and (not override)): DCNL DCSP  DCSP  DCSP raise AttributeError(('Cannot DCSP add DCSP method DCSP {!r}'.format(method) + "to DCSP destination DCSP object DCSP as DCSP it DCSP already DCSP exists. DCSP To DCSP prevent DCSP this DCSP error DCSP set DCSP 'override=True'.")) DCNL DCSP  DCSP if hasattr(source, method): DCNL DCSP  DCSP  DCSP if (wrapper is None): DCNL DCSP  DCSP  DCSP  DCSP setattr(destination, method, getattr(source, method)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(destination, method, wrapper(source, method)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP setattr(destination, method, None)
 DCSP return _get_named_nodes(graph, {})
 DCSP if (model is None): DCNL DCSP  DCSP return Model.get_context() DCNL DCSP return model
 DCSP def wrapped(self, *args, **kwargs): DCNL DCSP  DCSP res = meth(self, *args, **kwargs) DCNL DCSP  DCSP if (getattr(self, 'parent', None) is not None): DCNL DCSP  DCSP  DCSP getattr(self.parent, meth.__name__)(*args, **kwargs) DCNL DCSP  DCSP return res DCNL DCSP wrapped.__name__ = meth.__name__ DCNL DCSP return wrapped
 DCSP model = modelcontext(model) DCNL DCSP return model.fn(outs, mode, *args, **kwargs)
 DCSP model = modelcontext(model) DCNL DCSP return model.fastfn(outs, mode)
 DCSP model = modelcontext(kwargs.pop('model', None)) DCNL DCSP args = list(args) DCNL DCSP try: DCNL DCSP  DCSP d = dict(*args, **kwargs) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise TypeError("can't DCSP turn DCSP {} DCSP and DCSP {} DCSP into DCSP a DCSP dict. DCSP {}".format(args, kwargs, e)) DCNL DCSP return dict(((str(k), np.array(v)) for (k, v) in d.items() if (str(k) in map(str, model.vars))))
 DCSP if (total_size is None): DCNL DCSP  DCSP coef = pm.floatX(1) DCNL DCSP elif isinstance(total_size, int): DCNL DCSP  DCSP if (ndim >= 1): DCNL DCSP  DCSP  DCSP denom = shape[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP denom = 1 DCNL DCSP  DCSP coef = (pm.floatX(total_size) / pm.floatX(denom)) DCNL DCSP elif isinstance(total_size, (list, tuple)): DCNL DCSP  DCSP if (not all((isinstance(i, int) for i in total_size if ((i is not Ellipsis) and (i is not None))))): DCNL DCSP  DCSP  DCSP raise TypeError(('Unrecognized DCSP `total_size` DCSP type, DCSP expected DCSP int DCSP or DCSP list DCSP of DCSP ints, DCSP got DCSP %r' % total_size)) DCNL DCSP  DCSP if (Ellipsis in total_size): DCNL DCSP  DCSP  DCSP sep = total_size.index(Ellipsis) DCNL DCSP  DCSP  DCSP begin = total_size[:sep] DCNL DCSP  DCSP  DCSP end = total_size[(sep + 1):] DCNL DCSP  DCSP  DCSP if (Ellipsis in end): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Double DCSP Ellipsis DCSP in DCSP `total_size` DCSP is DCSP restricted, DCSP got DCSP %r' % total_size)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = total_size DCNL DCSP  DCSP  DCSP end = [] DCNL DCSP  DCSP if ((len(begin) + len(end)) > ndim): DCNL DCSP  DCSP  DCSP raise ValueError(('Length DCSP of DCSP `total_size` DCSP is DCSP too DCSP big, DCSP number DCSP of DCSP scalings DCSP is DCSP bigger DCSP that DCSP ndim, DCSP got DCSP %r' % total_size)) DCNL DCSP  DCSP elif ((len(begin) + len(end)) == 0): DCNL DCSP  DCSP  DCSP return pm.floatX(1) DCNL DCSP  DCSP if (len(end) > 0): DCNL DCSP  DCSP  DCSP shp_end = shape[(- len(end)):] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP shp_end = np.asarray([]) DCNL DCSP  DCSP shp_begin = shape[:len(begin)] DCNL DCSP  DCSP begin_coef = [(pm.floatX(t) / shp_begin[i]) for (i, t) in enumerate(begin) if (t is not None)] DCNL DCSP  DCSP end_coef = [(pm.floatX(t) / shp_end[i]) for (i, t) in enumerate(end) if (t is not None)] DCNL DCSP  DCSP coefs = (begin_coef + end_coef) DCNL DCSP  DCSP coef = tt.prod(coefs) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('Unrecognized DCSP `total_size` DCSP type, DCSP expected DCSP int DCSP or DCSP list DCSP of DCSP ints, DCSP got DCSP %r' % total_size)) DCNL DCSP return tt.as_tensor(pm.floatX(coef))
 DCSP all_rvs = [] DCNL DCSP parents = list(itertools.chain(*[j.inputs for j in rv.get_parents()])) DCNL DCSP if parents: DCNL DCSP  DCSP for parent in parents: DCNL DCSP  DCSP  DCSP all_rvs.extend(_walk_up_rv(parent)) DCNL DCSP elif rv.name: DCNL DCSP  DCSP all_rvs.append(rv.name) DCNL DCSP else: DCNL DCSP  DCSP all_rvs.append('\\text{Constant}') DCNL DCSP return all_rvs
 DCSP return '${} DCSP \\sim DCSP \\text{{Deterministic}}({})$'.format(rv.name, ', DCSP '.join(_walk_up_rv(rv)))
 DCSP model = modelcontext(model) DCNL DCSP var.name = model.name_for(name) DCNL DCSP model.deterministics.append(var) DCNL DCSP model.add_random_variable(var) DCNL DCSP var._repr_latex_ = functools.partial(_latex_repr_rv, var) DCNL DCSP var.__latex__ = var._repr_latex_ DCNL DCSP return var
 DCSP model = modelcontext(model) DCNL DCSP var.name = model.name_for(name) DCNL DCSP model.potentials.append(var) DCNL DCSP model.add_random_variable(var) DCNL DCSP return var
 DCSP vars_ = [var for var in vars if (not isinstance(var, pm.model.ObservedRV))] DCNL DCSP if any([(var.dtype in pm.discrete_types) for var in vars_]): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
 DCSP if (samples is None): DCNL DCSP  DCSP samples = len(trace) DCNL DCSP model = modelcontext(model) DCNL DCSP if random_seed: DCNL DCSP  DCSP np.random.seed(random_seed) DCNL DCSP indices = np.random.randint(0, len(trace), samples) DCNL DCSP if progressbar: DCNL DCSP  DCSP indices = tqdm(indices, total=samples) DCNL DCSP K = gp.distribution.K DCNL DCSP data = [v for v in model.observed_RVs if (v.name == gp.name)][0].data DCNL DCSP X = data['X'] DCNL DCSP Y = data['Y'] DCNL DCSP Z = X_values DCNL DCSP S_xz = K(X, Z) DCNL DCSP S_zz = K(Z) DCNL DCSP if obs_noise: DCNL DCSP  DCSP S_inv = matrix_inverse((K(X) + (tt.eye(X.shape[0]) * (gp.distribution.sigma ** 2)))) DCNL DCSP else: DCNL DCSP  DCSP S_inv = matrix_inverse(K(X)) DCNL DCSP S_xz_S_inv = tt.dot(S_xz.T, S_inv) DCNL DCSP m_post = tt.dot(S_xz_S_inv, Y) DCNL DCSP S_post = (S_zz - tt.dot(S_xz_S_inv, S_xz)) DCNL DCSP correction = 0 DCNL DCSP if chol_const: DCNL DCSP  DCSP n = S_post.shape[0] DCNL DCSP  DCSP correction = ((1e-06 * tt.nlinalg.trace(S_post)) * tt.eye(n)) DCNL DCSP gp_post = MvNormal.dist(m_post, (S_post + correction), shape=Z.shape[0]) DCNL DCSP samples = [gp_post.random(point=trace[idx]) for idx in indices] DCNL DCSP return np.array(samples)
 DCSP if isinstance(labels, six.string_types): DCNL DCSP  DCSP labels = [labels] DCNL DCSP if isinstance(x, pd.DataFrame): DCNL DCSP  DCSP if (not labels): DCNL DCSP  DCSP  DCSP labels = x.columns DCNL DCSP  DCSP x = x.as_matrix() DCNL DCSP elif isinstance(x, pd.Series): DCNL DCSP  DCSP if (not labels): DCNL DCSP  DCSP  DCSP labels = [x.name] DCNL DCSP  DCSP x = x.as_matrix()[:, None] DCNL DCSP elif isinstance(x, dict): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP x = pd.DataFrame.from_dict(x) DCNL DCSP  DCSP  DCSP labels = x.columns DCNL DCSP  DCSP  DCSP x = x.as_matrix() DCNL DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP res = [] DCNL DCSP  DCSP  DCSP labels = [] DCNL DCSP  DCSP  DCSP for (k, v) in x.items(): DCNL DCSP  DCSP  DCSP  DCSP res.append(v) DCNL DCSP  DCSP  DCSP  DCSP labels.append(k) DCNL DCSP  DCSP  DCSP x = tt.stack(res, axis=1) DCNL DCSP  DCSP  DCSP if (x.ndim == 1): DCNL DCSP  DCSP  DCSP  DCSP x = x[:, None] DCNL DCSP elif (not isinstance(x, tt.Variable)): DCNL DCSP  DCSP x = np.asarray(x) DCNL DCSP  DCSP if (x.ndim == 0): DCNL DCSP  DCSP  DCSP raise ValueError('Cannot DCSP use DCSP scalars') DCNL DCSP  DCSP elif (x.ndim == 1): DCNL DCSP  DCSP  DCSP x = x[:, None] DCNL DCSP elif (labels is not None): DCNL DCSP  DCSP x = tt.as_tensor_variable(x) DCNL DCSP  DCSP if (x.ndim == 0): DCNL DCSP  DCSP  DCSP raise ValueError('Cannot DCSP use DCSP scalars') DCNL DCSP  DCSP elif (x.ndim == 1): DCNL DCSP  DCSP  DCSP x = x[:, None] DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP if ((labels is None) and (not isinstance(x, tt.Variable))): DCNL DCSP  DCSP labels = [('x%d' % i) for i in range(x.shape[1])] DCNL DCSP elif (labels is None): DCNL DCSP  DCSP raise ValueError('Please DCSP provide DCSP labels DCSP as DCSP we DCSP cannot DCSP infer DCSP shape DCSP of DCSP input') DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP if (not isinstance(x, tt.Variable)): DCNL DCSP  DCSP if (not (len(labels) == x.shape[1])): DCNL DCSP  DCSP  DCSP raise ValueError(('Please DCSP provide DCSP full DCSP list DCSP of DCSP labels DCSP for DCSP coefficients, DCSP got DCSP len(labels)=%d DCSP instead DCSP of DCSP %d' % (len(labels), x.shape[1]))) DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP if isinstance(labels, pd.RangeIndex): DCNL DCSP  DCSP labels = [('x%d' % i) for i in labels] DCNL DCSP elif (not isinstance(labels, list)): DCNL DCSP  DCSP labels = list(labels) DCNL DCSP if (not isinstance(x, tt.Variable)): DCNL DCSP  DCSP x = tt.as_tensor_variable(x) DCNL DCSP  DCSP if (x.ndim == 0): DCNL DCSP  DCSP  DCSP raise ValueError('Cannot DCSP use DCSP scalars') DCNL DCSP  DCSP elif (x.ndim == 1): DCNL DCSP  DCSP  DCSP x = x[:, None] DCNL DCSP return (x, labels)
 DCSP return x
 DCSP default_shape = (default_rows, default_columns) DCNL DCSP if (ax is None): DCNL DCSP  DCSP (_, ax) = plt.subplots(*default_shape, **default_kwargs) DCNL DCSP elif (ax.shape != default_shape): DCNL DCSP  DCSP raise ValueError(('Subplots DCSP with DCSP shape DCSP %r DCSP required' % (default_shape,))) DCNL DCSP return ax
 DCSP a = np.atleast_2d(a.T).T DCNL DCSP n = a.shape[0] DCNL DCSP newshape = np.product(a.shape[1:]).astype(int) DCNL DCSP a = a.reshape((n, newshape), order='F') DCNL DCSP return a
 DCSP size = np.prod(shape) DCNL DCSP ind = (np.indices(shape) + 1).reshape((-1), size) DCNL DCSP names = [(('[' + ','.join(map(str, i))) + ']') for i in zip(*ind)] DCNL DCSP names[0] = ('%s DCSP %s' % (name, names[0])) DCNL DCSP return names
 DCSP if (varnames is None): DCNL DCSP  DCSP varnames = get_default_varnames(trace.varnames, include_transformed) DCNL DCSP R = gelman_rubin(trace) DCNL DCSP R = {v: R[v] for v in varnames} DCNL DCSP ax.set_title(title) DCNL DCSP ax.set_xlim(0.9, 2.1) DCNL DCSP ax.set_xticks((1.0, 1.5, 2.0), ('1', '1.5', '2+')) DCNL DCSP ax.set_yticks([(- (l + 1)) for l in range(len(labels))], '') DCNL DCSP i = 1 DCNL DCSP for varname in varnames: DCNL DCSP  DCSP chain = trace.chains[0] DCNL DCSP  DCSP value = trace.get_values(varname, chains=[chain])[0] DCNL DCSP  DCSP k = np.size(value) DCNL DCSP  DCSP if (k > 1): DCNL DCSP  DCSP  DCSP ax.plot([min(r, 2) for r in R[varname]], [(- (j + i)) for j in range(k)], 'bo', markersize=4) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ax.plot(min(R[varname], 2), (- i), 'bo', markersize=4) DCNL DCSP  DCSP i += k DCNL DCSP ax.set_ylim(((- i) + 0.5), (-0.5)) DCNL DCSP ax.set_yticks([]) DCNL DCSP for (loc, spine) in ax.spines.items(): DCNL DCSP  DCSP if (loc in ['left', 'right']): DCNL DCSP  DCSP  DCSP spine.set_color('none') DCNL DCSP return ax
 DCSP if show_quartiles: DCNL DCSP  DCSP ax.plot(ntiles[2], y, color=plot_kwargs.get('color', 'blue'), marker=plot_kwargs.get('marker', 'o'), markersize=plot_kwargs.get('markersize', 4)) DCNL DCSP  DCSP ax.errorbar(x=(ntiles[1], ntiles[3]), y=(y, y), linewidth=plot_kwargs.get('linewidth', 2), color=plot_kwargs.get('color', 'blue')) DCNL DCSP else: DCNL DCSP  DCSP ax.plot(ntiles[1], y, marker=plot_kwargs.get('marker', 'o'), color=plot_kwargs.get('color', 'blue'), markersize=plot_kwargs.get('markersize', 4)) DCNL DCSP ax.errorbar(x=(ntiles[0], ntiles[(-1)]), y=(y, y), linewidth=int((plot_kwargs.get('linewidth', 2) / 2)), color=plot_kwargs.get('color', 'blue')) DCNL DCSP return ax
 DCSP if quartiles: DCNL DCSP  DCSP qlist = [((100 * alpha) / 2), 25, 50, 75, (100 * (1 - (alpha / 2)))] DCNL DCSP else: DCNL DCSP  DCSP qlist = [((100 * alpha) / 2), 50, (100 * (1 - (alpha / 2)))] DCNL DCSP plotrange = None DCNL DCSP interval_plot = None DCNL DCSP nchains = trace_obj.nchains DCNL DCSP if (varnames is None): DCNL DCSP  DCSP varnames = get_default_varnames(trace_obj.varnames, plot_transformed) DCNL DCSP plot_rhat = (rhat and (nchains > 1)) DCNL DCSP if (gs is None): DCNL DCSP  DCSP if plot_rhat: DCNL DCSP  DCSP  DCSP gs = gridspec.GridSpec(1, 2, width_ratios=[3, 1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP gs = gridspec.GridSpec(1, 1) DCNL DCSP  DCSP interval_plot = plt.subplot(gs[0]) DCNL DCSP trace_quantiles = quantiles(trace_obj, qlist, transform=transform, squeeze=False) DCNL DCSP hpd_intervals = hpd(trace_obj, alpha, transform=transform, squeeze=False) DCNL DCSP labels = [] DCNL DCSP for (j, chain) in enumerate(trace_obj.chains): DCNL DCSP  DCSP var = 0 DCNL DCSP  DCSP for varname in varnames: DCNL DCSP  DCSP  DCSP var_quantiles = trace_quantiles[chain][varname] DCNL DCSP  DCSP  DCSP quants = [var_quantiles[v] for v in qlist] DCNL DCSP  DCSP  DCSP var_hpd = hpd_intervals[chain][varname].T DCNL DCSP  DCSP  DCSP quants[0] = var_hpd[0].T DCNL DCSP  DCSP  DCSP quants[(-1)] = var_hpd[1].T DCNL DCSP  DCSP  DCSP if plotrange: DCNL DCSP  DCSP  DCSP  DCSP plotrange = [min(plotrange[0], np.min(quants)), max(plotrange[1], np.max(quants))] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP plotrange = [np.min(quants), np.max(quants)] DCNL DCSP  DCSP  DCSP value = trace_obj.get_values(varname, chains=[chain])[0] DCNL DCSP  DCSP  DCSP k = np.size(value) DCNL DCSP  DCSP  DCSP if (j == 0): DCNL DCSP  DCSP  DCSP  DCSP if (k > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP names = _var_str(varname, np.shape(value)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP labels += names DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP labels.append(varname) DCNL DCSP  DCSP  DCSP offset = ([0] + [((chain_spacing * ((i + 2) / 2)) * ((-1) ** i)) for i in range((nchains - 1))]) DCNL DCSP  DCSP  DCSP y = ((- var) + offset[j]) DCNL DCSP  DCSP  DCSP if (k > 1): DCNL DCSP  DCSP  DCSP  DCSP for q in np.transpose(quants).squeeze(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP interval_plot = _plot_tree(interval_plot, y, q, quartiles, **plot_kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP y -= 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP interval_plot = _plot_tree(interval_plot, y, quants, quartiles, **plot_kwargs) DCNL DCSP  DCSP  DCSP var += k DCNL DCSP labels = (ylabels if (ylabels is not None) else labels) DCNL DCSP left_margin = (np.max([len(x) for x in labels]) * 0.015) DCNL DCSP gs.update(left=left_margin, right=0.95, top=0.9, bottom=0.05) DCNL DCSP interval_plot.set_ylim(((- var) + 0.5), 0.5) DCNL DCSP datarange = (plotrange[1] - plotrange[0]) DCNL DCSP interval_plot.set_xlim((plotrange[0] - (0.05 * datarange)), (plotrange[1] + (0.05 * datarange))) DCNL DCSP interval_plot.set_yticks([(- l) for l in range(len(labels))]) DCNL DCSP interval_plot.set_yticklabels(labels, fontsize=plot_kwargs.get('fontsize', None)) DCNL DCSP plot_title = '' DCNL DCSP if (main is None): DCNL DCSP  DCSP plot_title = '{:.0f}% DCSP Credible DCSP Intervals'.format(((1 - alpha) * 100)) DCNL DCSP elif main: DCNL DCSP  DCSP plot_title = main DCNL DCSP if plot_title: DCNL DCSP  DCSP interval_plot.set_title(plot_title, fontsize=plot_kwargs.get('fontsize', None)) DCNL DCSP if (xtitle is not None): DCNL DCSP  DCSP interval_plot.set_xlabel(xtitle) DCNL DCSP if (xlim is not None): DCNL DCSP  DCSP interval_plot.set_xlim(*xlim) DCNL DCSP for ticks in interval_plot.yaxis.get_major_ticks(): DCNL DCSP  DCSP ticks.tick1On = False DCNL DCSP  DCSP ticks.tick2On = False DCNL DCSP for (loc, spine) in interval_plot.spines.items(): DCNL DCSP  DCSP if (loc in ['left', 'right']): DCNL DCSP  DCSP  DCSP spine.set_color('none') DCNL DCSP interval_plot.axvline(vline, color='k', linestyle=':') DCNL DCSP if plot_rhat: DCNL DCSP  DCSP _make_rhat_plot(trace_obj, plt.subplot(gs[1]), 'R-hat', labels, varnames, plot_transformed) DCNL DCSP return gs
 DCSP if (ax is None): DCNL DCSP  DCSP (_, ax) = plt.subplots() DCNL DCSP (yticks_pos, step) = np.linspace(0, (-1), ((comp_df.shape[0] * 2) - 1), retstep=True) DCNL DCSP yticks_pos[1::2] = (yticks_pos[1::2] + (step / 2)) DCNL DCSP yticks_labels = ([''] * len(yticks_pos)) DCNL DCSP yticks_labels[0] = comp_df.index[0] DCNL DCSP yticks_labels[1::2] = comp_df.index[1:] DCNL DCSP data = comp_df.values DCNL DCSP min_ic = data[(0, 0)] DCNL DCSP ax.errorbar(x=data[:, 0], y=yticks_pos[::2], xerr=data[:, 4], fmt='ko', mfc='None', mew=1) DCNL DCSP ax.errorbar(x=data[1:, 0], y=yticks_pos[1::2], xerr=data[1:, 5], fmt='^', color='grey') DCNL DCSP ax.plot((data[:, 0] - (2 * data[:, 1])), yticks_pos[::2], 'ko') DCNL DCSP ax.axvline(min_ic, ls='--', color='grey') DCNL DCSP ax.set_yticks(yticks_pos) DCNL DCSP ax.set_yticklabels(yticks_labels) DCNL DCSP ax.set_xlabel('Deviance') DCNL DCSP return ax
 DCSP col_min = np.min(column) DCNL DCSP col_max = np.max(column) DCNL DCSP return range(col_min, (col_max + 2), max(((col_max - col_min) // bins), 1))
 DCSP hs = [] DCNL DCSP for column in data.T: DCNL DCSP  DCSP hs.append(ax.hist(column, bins=_histplot_bins(column), alpha=alpha, align='left')) DCNL DCSP ax.set_xlim((np.min(data) - 0.5), (np.max(data) + 0.5)) DCNL DCSP return hs
 DCSP ls = [] DCNL DCSP pls = [] DCNL DCSP errored = [] DCNL DCSP for (i, d) in enumerate(data.T): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (density, l, u) = fast_kde(d) DCNL DCSP  DCSP  DCSP x = np.linspace(l, u, len(density)) DCNL DCSP  DCSP  DCSP if (prior is not None): DCNL DCSP  DCSP  DCSP  DCSP p = prior.logp(x).eval() DCNL DCSP  DCSP  DCSP  DCSP pls.append(ax.plot(x, np.exp(p), alpha=prior_alpha, ls=prior_style)) DCNL DCSP  DCSP  DCSP ls.append(ax.plot(x, density)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP errored.append(str(i)) DCNL DCSP if errored: DCNL DCSP  DCSP ax.text(0.27, 0.47, ('WARNING: DCSP KDE DCSP plot DCSP failed DCSP for: DCSP ' + ','.join(errored)), bbox={'facecolor': 'red', 'alpha': 0.5, 'pad': 10}, style='italic') DCNL DCSP return (ls, pls)
 DCSP def format_as_percent(x, round_to=0): DCNL DCSP  DCSP return '{0:.{1:d}f}%'.format((100 * x), round_to) DCNL DCSP def display_ref_val(ref_val): DCNL DCSP  DCSP less_than_ref_probability = (trace_values < ref_val).mean() DCNL DCSP  DCSP greater_than_ref_probability = (trace_values >= ref_val).mean() DCNL DCSP  DCSP ref_in_posterior = '{} DCSP <{:g}< DCSP {}'.format(format_as_percent(less_than_ref_probability, 1), ref_val, format_as_percent(greater_than_ref_probability, 1)) DCNL DCSP  DCSP ax.axvline(ref_val, ymin=0.02, ymax=0.75, color='g', linewidth=4, alpha=0.65) DCNL DCSP  DCSP ax.text(trace_values.mean(), (plot_height * 0.6), ref_in_posterior, size=text_size, horizontalalignment='center') DCNL DCSP def display_rope(rope): DCNL DCSP  DCSP ax.plot(rope, ((plot_height * 0.02), (plot_height * 0.02)), linewidth=20, color='r', alpha=0.75) DCNL DCSP  DCSP text_props = dict(size=text_size, horizontalalignment='center', color='r') DCNL DCSP  DCSP ax.text(rope[0], (plot_height * 0.14), rope[0], **text_props) DCNL DCSP  DCSP ax.text(rope[1], (plot_height * 0.14), rope[1], **text_props) DCNL DCSP def display_point_estimate(): DCNL DCSP  DCSP if (not point_estimate): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (point_estimate not in ('mode', 'mean', 'median')): DCNL DCSP  DCSP  DCSP raise ValueError("Point DCSP Estimate DCSP should DCSP be DCSP in DCSP ('mode','mean','median')") DCNL DCSP  DCSP if (point_estimate == 'mean'): DCNL DCSP  DCSP  DCSP point_value = trace_values.mean() DCNL DCSP  DCSP elif (point_estimate == 'mode'): DCNL DCSP  DCSP  DCSP if isinstance(trace_values[0], float): DCNL DCSP  DCSP  DCSP  DCSP (density, l, u) = fast_kde(trace_values) DCNL DCSP  DCSP  DCSP  DCSP x = np.linspace(l, u, len(density)) DCNL DCSP  DCSP  DCSP  DCSP point_value = x[np.argmax(density)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP point_value = mode(trace_values.round(round_to))[0][0] DCNL DCSP  DCSP elif (point_estimate == 'median'): DCNL DCSP  DCSP  DCSP point_value = np.median(trace_values) DCNL DCSP  DCSP point_text = '{point_estimate}={point_value:.{round_to}f}'.format(point_estimate=point_estimate, point_value=point_value, round_to=round_to) DCNL DCSP  DCSP ax.text(point_value, (plot_height * 0.8), point_text, size=text_size, horizontalalignment='center') DCNL DCSP def display_hpd(): DCNL DCSP  DCSP hpd_intervals = hpd(trace_values, alpha=alpha_level) DCNL DCSP  DCSP ax.plot(hpd_intervals, ((plot_height * 0.02), (plot_height * 0.02)), linewidth=4, color='k') DCNL DCSP  DCSP ax.text(hpd_intervals[0], (plot_height * 0.07), hpd_intervals[0].round(round_to), size=text_size, horizontalalignment='right') DCNL DCSP  DCSP ax.text(hpd_intervals[1], (plot_height * 0.07), hpd_intervals[1].round(round_to), size=text_size, horizontalalignment='left') DCNL DCSP  DCSP ax.text(((hpd_intervals[0] + hpd_intervals[1]) / 2), (plot_height * 0.2), (format_as_percent((1 - alpha_level)) + ' DCSP HPD'), size=text_size, horizontalalignment='center') DCNL DCSP def format_axes(): DCNL DCSP  DCSP ax.yaxis.set_ticklabels([]) DCNL DCSP  DCSP ax.spines['top'].set_visible(False) DCNL DCSP  DCSP ax.spines['right'].set_visible(False) DCNL DCSP  DCSP ax.spines['left'].set_visible(False) DCNL DCSP  DCSP ax.spines['bottom'].set_visible(True) DCNL DCSP  DCSP ax.yaxis.set_ticks_position('none') DCNL DCSP  DCSP ax.xaxis.set_ticks_position('bottom') DCNL DCSP  DCSP ax.tick_params(axis='x', direction='out', width=1, length=3, color='0.5', labelsize=text_size) DCNL DCSP  DCSP ax.spines['bottom'].set_color('0.5') DCNL DCSP def set_key_if_doesnt_exist(d, key, value): DCNL DCSP  DCSP if (key not in d): DCNL DCSP  DCSP  DCSP d[key] = value DCNL DCSP if (kde_plot and isinstance(trace_values[0], float)): DCNL DCSP  DCSP kdeplot(trace_values, alpha=kwargs.pop('alpha', 0.35), ax=ax, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP set_key_if_doesnt_exist(kwargs, 'bins', 30) DCNL DCSP  DCSP set_key_if_doesnt_exist(kwargs, 'edgecolor', 'w') DCNL DCSP  DCSP set_key_if_doesnt_exist(kwargs, 'align', 'right') DCNL DCSP  DCSP ax.hist(trace_values, **kwargs) DCNL DCSP plot_height = ax.get_ylim()[1] DCNL DCSP format_axes() DCNL DCSP display_hpd() DCNL DCSP display_point_estimate() DCNL DCSP if (ref_val is not None): DCNL DCSP  DCSP display_ref_val(ref_val) DCNL DCSP if (rope is not None): DCNL DCSP  DCSP display_rope(rope)
 DCSP x = x[(~ np.isnan(x))] DCNL DCSP x = x[(~ np.isinf(x))] DCNL DCSP n = len(x) DCNL DCSP nx = 200 DCNL DCSP x += np.random.uniform((-1e-12), 1e-12, size=n) DCNL DCSP (xmin, xmax) = (np.min(x), np.max(x)) DCNL DCSP bins = np.linspace(xmin, xmax, nx) DCNL DCSP xyi = np.digitize(x, bins) DCNL DCSP dx = ((xmax - xmin) / (nx - 1)) DCNL DCSP grid = np.histogram(x, bins=nx)[0] DCNL DCSP scotts_factor = (n ** (-0.2)) DCNL DCSP std_x = np.std(xyi) DCNL DCSP kern_nx = int(np.round((((scotts_factor * 2) * np.pi) * std_x))) DCNL DCSP kernel = np.reshape(gaussian(kern_nx, (scotts_factor * std_x)), kern_nx) DCNL DCSP npad = np.min((nx, (2 * kern_nx))) DCNL DCSP grid = np.concatenate([grid[npad:0:(-1)], grid, grid[nx:(nx - npad):(-1)]]) DCNL DCSP grid = convolve(grid, kernel, mode='same')[npad:(npad + nx)] DCNL DCSP norm_factor = ((n * dx) * ((((2 * np.pi) * (std_x ** 2)) * (scotts_factor ** 2)) ** 0.5)) DCNL DCSP grid = (grid / norm_factor) DCNL DCSP return (grid, xmin, xmax)
 DCSP def create_axes_grid(figsize, traces): DCNL DCSP  DCSP l_trace = len(traces) DCNL DCSP  DCSP if (l_trace == 1): DCNL DCSP  DCSP  DCSP (fig, ax) = plt.subplots(figsize=figsize) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP n = np.ceil((l_trace / 2.0)).astype(int) DCNL DCSP  DCSP  DCSP if (figsize is None): DCNL DCSP  DCSP  DCSP  DCSP figsize = (12, (n * 2.5)) DCNL DCSP  DCSP  DCSP (fig, ax) = plt.subplots(n, 2, figsize=figsize) DCNL DCSP  DCSP  DCSP ax = ax.reshape((2 * n)) DCNL DCSP  DCSP  DCSP if ((l_trace % 2) == 1): DCNL DCSP  DCSP  DCSP  DCSP ax[(-1)].set_axis_off() DCNL DCSP  DCSP  DCSP  DCSP ax = ax[:(-1)] DCNL DCSP  DCSP return (fig, ax) DCNL DCSP def get_trace_dict(tr, varnames): DCNL DCSP  DCSP traces = OrderedDict() DCNL DCSP  DCSP for v in varnames: DCNL DCSP  DCSP  DCSP vals = tr.get_values(v, combine=True, squeeze=True) DCNL DCSP  DCSP  DCSP if (vals.ndim > 1): DCNL DCSP  DCSP  DCSP  DCSP vals_flat = vals.reshape(vals.shape[0], (-1)).T DCNL DCSP  DCSP  DCSP  DCSP for (i, vi) in enumerate(vals_flat): DCNL DCSP  DCSP  DCSP  DCSP  DCSP traces['_'.join([v, str(i)])] = vi DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP traces[v] = vals DCNL DCSP  DCSP return traces DCNL DCSP if isinstance(trace, np.ndarray): DCNL DCSP  DCSP if (figsize is None): DCNL DCSP  DCSP  DCSP figsize = (6, 2) DCNL DCSP  DCSP if (ax is None): DCNL DCSP  DCSP  DCSP (fig, ax) = plt.subplots(figsize=figsize) DCNL DCSP  DCSP plot_posterior_op(transform(trace), ax=ax, kde_plot=kde_plot, point_estimate=point_estimate, round_to=round_to, alpha_level=alpha_level, ref_val=ref_val, rope=rope, text_size=text_size, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP if (varnames is None): DCNL DCSP  DCSP  DCSP varnames = get_default_varnames(trace.varnames, plot_transformed) DCNL DCSP  DCSP trace_dict = get_trace_dict(trace, varnames) DCNL DCSP  DCSP if (ax is None): DCNL DCSP  DCSP  DCSP (fig, ax) = create_axes_grid(figsize, trace_dict) DCNL DCSP  DCSP var_num = len(trace_dict) DCNL DCSP  DCSP if (ref_val is None): DCNL DCSP  DCSP  DCSP ref_val = ([None] * var_num) DCNL DCSP  DCSP elif np.isscalar(ref_val): DCNL DCSP  DCSP  DCSP ref_val = [ref_val for _ in range(var_num)] DCNL DCSP  DCSP if (rope is None): DCNL DCSP  DCSP  DCSP rope = ([None] * var_num) DCNL DCSP  DCSP elif (np.ndim(rope) == 1): DCNL DCSP  DCSP  DCSP rope = ([rope] * var_num) DCNL DCSP  DCSP for (idx, (a, v)) in enumerate(zip(np.atleast_1d(ax), trace_dict)): DCNL DCSP  DCSP  DCSP tr_values = transform(trace_dict[v]) DCNL DCSP  DCSP  DCSP plot_posterior_op(tr_values, ax=a, kde_plot=kde_plot, point_estimate=point_estimate, round_to=round_to, alpha_level=alpha_level, ref_val=ref_val[idx], rope=rope[idx], text_size=text_size, **kwargs) DCNL DCSP  DCSP  DCSP a.set_title(v) DCNL DCSP  DCSP plt.tight_layout() DCNL DCSP return ax
 DCSP if (lm is None): DCNL DCSP  DCSP lm = (lambda x, sample: (sample['Intercept'] + (sample['x'] * x))) DCNL DCSP if (eval is None): DCNL DCSP  DCSP eval = np.linspace(0, 1, 100) DCNL DCSP if (('lw' not in kwargs) and ('linewidth' not in kwargs)): DCNL DCSP  DCSP kwargs['lw'] = 0.2 DCNL DCSP if (('c' not in kwargs) and ('color' not in kwargs)): DCNL DCSP  DCSP kwargs['c'] = 'k' DCNL DCSP for rand_loc in np.random.randint(0, len(trace), samples): DCNL DCSP  DCSP rand_sample = trace[rand_loc] DCNL DCSP  DCSP plt.plot(eval, lm(eval, rand_sample), **kwargs) DCNL DCSP  DCSP kwargs.pop('label', None) DCNL DCSP plt.title('Posterior DCSP predictive')
 DCSP trace = trace[skip_first:] DCNL DCSP if (varnames is None): DCNL DCSP  DCSP varnames = get_default_varnames(trace.varnames, plot_transformed) DCNL DCSP if (figsize is None): DCNL DCSP  DCSP figsize = (12, (len(varnames) * 2)) DCNL DCSP ax = get_axis(ax, len(varnames), 2, squeeze=False, figsize=figsize) DCNL DCSP for (i, v) in enumerate(varnames): DCNL DCSP  DCSP if (priors is not None): DCNL DCSP  DCSP  DCSP prior = priors[i] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP prior = None DCNL DCSP  DCSP first_time = True DCNL DCSP  DCSP for d in trace.get_values(v, combine=combined, squeeze=False): DCNL DCSP  DCSP  DCSP d = np.squeeze(transform(d)) DCNL DCSP  DCSP  DCSP d = make_2d(d) DCNL DCSP  DCSP  DCSP d_stream = d DCNL DCSP  DCSP  DCSP x0 = 0 DCNL DCSP  DCSP  DCSP if live_plot: DCNL DCSP  DCSP  DCSP  DCSP x0 = skip_first DCNL DCSP  DCSP  DCSP  DCSP if first_time: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ax[(i, 0)].cla() DCNL DCSP  DCSP  DCSP  DCSP  DCSP ax[(i, 1)].cla() DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_time = False DCNL DCSP  DCSP  DCSP  DCSP if (roll_over is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(d) >= roll_over): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x0 = ((len(d) - roll_over) + skip_first) DCNL DCSP  DCSP  DCSP  DCSP  DCSP d_stream = d[(- roll_over):] DCNL DCSP  DCSP  DCSP width = len(d_stream) DCNL DCSP  DCSP  DCSP if (d.dtype.kind == 'i'): DCNL DCSP  DCSP  DCSP  DCSP hist_objs = histplot_op(ax[(i, 0)], d, alpha=alpha) DCNL DCSP  DCSP  DCSP  DCSP colors = [h[(-1)][0].get_facecolor() for h in hist_objs] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP artists = kdeplot_op(ax[(i, 0)], d, prior, prior_alpha, prior_style)[0] DCNL DCSP  DCSP  DCSP  DCSP colors = [a[0].get_color() for a in artists] DCNL DCSP  DCSP  DCSP ax[(i, 0)].set_title(str(v)) DCNL DCSP  DCSP  DCSP ax[(i, 0)].grid(grid) DCNL DCSP  DCSP  DCSP ax[(i, 1)].set_title(str(v)) DCNL DCSP  DCSP  DCSP ax[(i, 1)].plot(range(x0, (x0 + width)), d_stream, alpha=alpha) DCNL DCSP  DCSP  DCSP ax[(i, 0)].set_ylabel('Frequency') DCNL DCSP  DCSP  DCSP ax[(i, 1)].set_ylabel('Sample DCSP value') DCNL DCSP  DCSP  DCSP if lines: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(lines[v], (float, int)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (line_values, colors) = ([lines[v]], ['r']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line_values = np.atleast_1d(lines[v]).ravel() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (len(colors) != len(line_values)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise AssertionError("An DCSP incorrect DCSP number DCSP of DCSP lines DCSP was DCSP specified DCSP for DCSP '{}'. DCSP Expected DCSP an DCSP iterable DCSP of DCSP length DCSP {} DCSP or DCSP to DCSP  DCSP a DCSP scalar".format(v, len(colors))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (c, l) in zip(colors, line_values): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ax[(i, 0)].axvline(x=l, color=c, lw=1.5, alpha=0.75) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ax[(i, 1)].axhline(y=l, color=c, lw=1.5, alpha=alpha) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if live_plot: DCNL DCSP  DCSP  DCSP for j in [0, 1]: DCNL DCSP  DCSP  DCSP  DCSP ax[(i, j)].relim() DCNL DCSP  DCSP  DCSP  DCSP ax[(i, j)].autoscale_view(True, True, True) DCNL DCSP  DCSP  DCSP ax[(i, 1)].set_xlim(x0, (x0 + width)) DCNL DCSP  DCSP ax[(i, 0)].set_ylim(ymin=0) DCNL DCSP if live_plot: DCNL DCSP  DCSP ax[(0, 0)].figure.canvas.draw() DCNL DCSP plt.tight_layout() DCNL DCSP return ax
 DCSP def _handle_array_varnames(varname): DCNL DCSP  DCSP if (trace[0][varname].__class__ is np.ndarray): DCNL DCSP  DCSP  DCSP k = trace[varname].shape[1] DCNL DCSP  DCSP  DCSP for i in range(k): DCNL DCSP  DCSP  DCSP  DCSP (yield (varname + '_{0}'.format(i))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield varname) DCNL DCSP if (varnames is None): DCNL DCSP  DCSP varnames = get_default_varnames(trace.varnames, plot_transformed) DCNL DCSP varnames = list(itertools.chain.from_iterable(map(_handle_array_varnames, varnames))) DCNL DCSP nchains = trace.nchains DCNL DCSP if (figsize is None): DCNL DCSP  DCSP figsize = (12, (len(varnames) * 2)) DCNL DCSP ax = get_axis(ax, len(varnames), nchains, squeeze=False, sharex=True, sharey=True, figsize=figsize) DCNL DCSP max_lag = min((len(trace) - 1), max_lag) DCNL DCSP for (i, v) in enumerate(varnames): DCNL DCSP  DCSP for j in range(nchains): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = np.squeeze(trace.get_values(v, chains=[j], burn=burn, combine=False)) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP k = int(v.split('_')[(-1)]) DCNL DCSP  DCSP  DCSP  DCSP v_use = '_'.join(v.split('_')[:(-1)]) DCNL DCSP  DCSP  DCSP  DCSP d = np.squeeze(trace.get_values(v_use, chains=[j], burn=burn, combine=False)[:, k]) DCNL DCSP  DCSP  DCSP ax[(i, j)].acorr(d, detrend=plt.mlab.detrend_mean, maxlags=max_lag) DCNL DCSP  DCSP  DCSP if (j == 0): DCNL DCSP  DCSP  DCSP  DCSP ax[(i, j)].set_ylabel('correlation') DCNL DCSP  DCSP  DCSP if (i == (len(varnames) - 1)): DCNL DCSP  DCSP  DCSP  DCSP ax[(i, j)].set_xlabel('lag') DCNL DCSP  DCSP  DCSP ax[(i, j)].set_title(v) DCNL DCSP  DCSP  DCSP if (not symmetric_plot): DCNL DCSP  DCSP  DCSP  DCSP ax[(i, j)].set_xlim(0, max_lag) DCNL DCSP  DCSP  DCSP if (nchains > 1): DCNL DCSP  DCSP  DCSP  DCSP ax[(i, j)].set_title('chain DCSP {0}'.format((j + 1))) DCNL DCSP return ax
 DCSP try: DCNL DCSP  DCSP energy = trace['energy'] DCNL DCSP except KeyError: DCNL DCSP  DCSP print 'There DCSP is DCSP no DCSP energy DCSP information DCSP in DCSP the DCSP passed DCSP trace.' DCNL DCSP  DCSP return ax DCNL DCSP series = [('Marginal DCSP energy DCSP distribution', (energy - energy.mean())), ('Energy DCSP transition DCSP distribution', np.diff(energy))] DCNL DCSP if (figsize is None): DCNL DCSP  DCSP figsize = (8, 6) DCNL DCSP if (ax is None): DCNL DCSP  DCSP (_, ax) = plt.subplots(figsize=figsize) DCNL DCSP if (kind == 'kde'): DCNL DCSP  DCSP for (label, value) in series: DCNL DCSP  DCSP  DCSP kdeplot(value, label=label, alpha=alpha, shade=True, ax=ax, **kwargs) DCNL DCSP elif (kind == 'hist'): DCNL DCSP  DCSP for (label, value) in series: DCNL DCSP  DCSP  DCSP ax.hist(value, lw=lw, alpha=alpha, label=label, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Plot DCSP type DCSP {} DCSP not DCSP recognized.'.format(kind)) DCNL DCSP ax.set_xticks([]) DCNL DCSP ax.set_yticks([]) DCNL DCSP if (not frame): DCNL DCSP  DCSP for spine in ax.spines.values(): DCNL DCSP  DCSP  DCSP spine.set_visible(False) DCNL DCSP if legend: DCNL DCSP  DCSP ax.legend() DCNL DCSP return ax
 DCSP def wrapped_f(pymc3_obj, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vars = kwargs.pop('vars', pymc3_obj.varnames) DCNL DCSP  DCSP  DCSP chains = kwargs.pop('chains', pymc3_obj.chains) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return f(pymc3_obj, *args, **kwargs) DCNL DCSP  DCSP burn = kwargs.pop('burn', 0) DCNL DCSP  DCSP thin = kwargs.pop('thin', 1) DCNL DCSP  DCSP combine = kwargs.pop('combine', False) DCNL DCSP  DCSP squeeze = kwargs.pop('squeeze', True) DCNL DCSP  DCSP results = {chain: {} for chain in chains} DCNL DCSP  DCSP for var in vars: DCNL DCSP  DCSP  DCSP samples = pymc3_obj.get_values(var, chains=chains, burn=burn, thin=thin, combine=combine, squeeze=False) DCNL DCSP  DCSP  DCSP for (chain, data) in zip(chains, samples): DCNL DCSP  DCSP  DCSP  DCSP results[chain][var] = f(np.squeeze(data), *args, **kwargs) DCNL DCSP  DCSP if (squeeze and ((len(chains) == 1) or combine)): DCNL DCSP  DCSP  DCSP results = results[chains[0]] DCNL DCSP  DCSP return results DCNL DCSP wrapped_f.__doc__ = f.__doc__ DCNL DCSP wrapped_f.__name__ = f.__name__ DCNL DCSP return wrapped_f
 DCSP S = autocov(x, lag) DCNL DCSP return (S[(0, 1)] / np.sqrt(np.prod(np.diag(S))))
 DCSP x = np.asarray(x) DCNL DCSP if (not lag): DCNL DCSP  DCSP return 1 DCNL DCSP if (lag < 0): DCNL DCSP  DCSP raise ValueError('Autocovariance DCSP lag DCSP must DCSP be DCSP a DCSP positive DCSP integer') DCNL DCSP return np.cov(x[:(- lag)], x[lag:], bias=1)
 DCSP model = modelcontext(model) DCNL DCSP logp = model.logp DCNL DCSP mean_deviance = ((-2) * np.mean([logp(pt) for pt in trace])) DCNL DCSP free_rv_means = {rv.name: trace[rv.name].mean(axis=0) for rv in model.free_RVs} DCNL DCSP deviance_at_mean = ((-2) * logp(free_rv_means)) DCNL DCSP return ((2 * mean_deviance) - deviance_at_mean)
 DCSP cached = [(var, var.logp_elemwise) for var in model.observed_RVs] DCNL DCSP def logp_vals_point(pt): DCNL DCSP  DCSP if (len(model.observed_RVs) == 0): DCNL DCSP  DCSP  DCSP return floatX(np.array([], dtype='d')) DCNL DCSP  DCSP logp_vals = [] DCNL DCSP  DCSP for (var, logp) in cached: DCNL DCSP  DCSP  DCSP logp = logp(pt) DCNL DCSP  DCSP  DCSP if var.missing_values: DCNL DCSP  DCSP  DCSP  DCSP logp = logp[(~ var.observations.mask)] DCNL DCSP  DCSP  DCSP logp_vals.append(logp.ravel()) DCNL DCSP  DCSP return np.concatenate(logp_vals) DCNL DCSP points = (tqdm(trace) if progressbar else trace) DCNL DCSP try: DCNL DCSP  DCSP logp = (logp_vals_point(pt) for pt in points) DCNL DCSP  DCSP return np.stack(logp) DCNL DCSP finally: DCNL DCSP  DCSP if progressbar: DCNL DCSP  DCSP  DCSP points.close()
 DCSP model = modelcontext(model) DCNL DCSP log_py = _log_post_trace(trace, model, progressbar=progressbar) DCNL DCSP if (log_py.size == 0): DCNL DCSP  DCSP raise ValueError('The DCSP model DCSP does DCSP not DCSP contain DCSP observed DCSP values.') DCNL DCSP lppd_i = logsumexp(log_py, axis=0, b=(1.0 / log_py.shape[0])) DCNL DCSP vars_lpd = np.var(log_py, axis=0) DCNL DCSP if np.any((vars_lpd > 0.4)): DCNL DCSP  DCSP warnings.warn('For DCSP one DCSP or DCSP more DCSP samples DCSP the DCSP posterior DCSP variance DCSP of DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP log DCSP predictive DCSP densities DCSP exceeds DCSP 0.4. DCSP This DCSP could DCSP be DCSP indication DCSP of\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WAIC DCSP starting DCSP to DCSP fail DCSP see DCSP http://arxiv.org/abs/1507.04544 DCSP for DCSP details\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ') DCNL DCSP waic_i = ((-2) * (lppd_i - vars_lpd)) DCNL DCSP waic_se = np.sqrt((len(waic_i) * np.var(waic_i))) DCNL DCSP waic = np.sum(waic_i) DCNL DCSP p_waic = np.sum(vars_lpd) DCNL DCSP if pointwise: DCNL DCSP  DCSP WAIC_r = namedtuple('WAIC_r', 'WAIC, DCSP WAIC_se, DCSP p_WAIC, DCSP WAIC_i') DCNL DCSP  DCSP return WAIC_r(waic, waic_se, p_waic, waic_i) DCNL DCSP else: DCNL DCSP  DCSP WAIC_r = namedtuple('WAIC_r', 'WAIC, DCSP WAIC_se, DCSP p_WAIC') DCNL DCSP  DCSP return WAIC_r(waic, waic_se, p_waic)
 DCSP model = modelcontext(model) DCNL DCSP log_py = _log_post_trace(trace, model, progressbar=progressbar) DCNL DCSP if (log_py.size == 0): DCNL DCSP  DCSP raise ValueError('The DCSP model DCSP does DCSP not DCSP contain DCSP observed DCSP values.') DCNL DCSP r = np.exp((- log_py)) DCNL DCSP r_sorted = np.sort(r, axis=0) DCNL DCSP q80 = int((len(log_py) * 0.8)) DCNL DCSP pareto_fit = np.apply_along_axis((lambda x: pareto.fit(x, floc=0)), 0, r_sorted[q80:]) DCNL DCSP if np.any((pareto_fit[0] > 0.7)): DCNL DCSP  DCSP warnings.warn('Estimated DCSP shape DCSP parameter DCSP of DCSP Pareto DCSP distribution DCSP is\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP greater DCSP than DCSP 0.7 DCSP for DCSP one DCSP or DCSP more DCSP samples.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP You DCSP should DCSP consider DCSP using DCSP a DCSP more DCSP robust DCSP model, DCSP this DCSP is\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP because DCSP importance DCSP sampling DCSP is DCSP less DCSP likely DCSP to DCSP work DCSP well DCSP if DCSP the DCSP marginal\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP posterior DCSP and DCSP LOO DCSP posterior DCSP are DCSP very DCSP different. DCSP This DCSP is DCSP more DCSP likely DCSP to\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP happen DCSP with DCSP a DCSP non-robust DCSP model DCSP and DCSP highly DCSP influential DCSP observations.') DCNL DCSP elif np.any((pareto_fit[0] > 0.5)): DCNL DCSP  DCSP warnings.warn('Estimated DCSP shape DCSP parameter DCSP of DCSP Pareto DCSP distribution DCSP is\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP greater DCSP than DCSP 0.5 DCSP for DCSP one DCSP or DCSP more DCSP samples. DCSP This DCSP may DCSP indicate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP that DCSP the DCSP variance DCSP of DCSP the DCSP Pareto DCSP smoothed DCSP importance DCSP sampling DCSP estimate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is DCSP very DCSP large.') DCNL DCSP S = len(r_sorted) DCNL DCSP M = (S - q80) DCNL DCSP z = ((np.arange(M) + 0.5) / M) DCNL DCSP expvals = map((lambda x: pareto.ppf(z, x[0], scale=x[2])), pareto_fit.T) DCNL DCSP r_sorted[q80:] = np.vstack(expvals).T DCNL DCSP r_new = np.array([r[np.argsort(i)] for (r, i) in zip(r_sorted.T, np.argsort(r.T, axis=1))]).T DCNL DCSP w = np.minimum(r_new, (r_new.mean(axis=0) * (S ** 0.75))) DCNL DCSP loo_lppd_i = ((-2.0) * logsumexp(log_py, axis=0, b=(w / np.sum(w, axis=0)))) DCNL DCSP loo_lppd_se = np.sqrt((len(loo_lppd_i) * np.var(loo_lppd_i))) DCNL DCSP loo_lppd = np.sum(loo_lppd_i) DCNL DCSP lppd = np.sum(logsumexp(log_py, axis=0, b=(1.0 / log_py.shape[0]))) DCNL DCSP p_loo = (lppd + (0.5 * loo_lppd)) DCNL DCSP if pointwise: DCNL DCSP  DCSP LOO_r = namedtuple('LOO_r', 'LOO, DCSP LOO_se, DCSP p_LOO, DCSP LOO_i') DCNL DCSP  DCSP return LOO_r(loo_lppd, loo_lppd_se, p_loo, loo_lppd_i) DCNL DCSP else: DCNL DCSP  DCSP LOO_r = namedtuple('LOO_r', 'LOO, DCSP LOO_se, DCSP p_LOO') DCNL DCSP  DCSP return LOO_r(loo_lppd, loo_lppd_se, p_loo)
 DCSP model = modelcontext(model) DCNL DCSP logp = model.logp DCNL DCSP mean_deviance = ((-2) * np.mean([logp(pt) for pt in trace])) DCNL DCSP free_rv_means = {rv.name: trace[rv.name].mean(axis=0) for rv in model.free_RVs} DCNL DCSP deviance_at_mean = ((-2) * logp(free_rv_means)) DCNL DCSP return ((3 * mean_deviance) - (2 * deviance_at_mean))
 DCSP if (ic == 'WAIC'): DCNL DCSP  DCSP ic_func = waic DCNL DCSP  DCSP df_comp = pd.DataFrame(index=np.arange(len(models)), columns=['WAIC', 'pWAIC', 'dWAIC', 'weight', 'SE', 'dSE', 'warning']) DCNL DCSP elif (ic == 'LOO'): DCNL DCSP  DCSP ic_func = loo DCNL DCSP  DCSP df_comp = pd.DataFrame(index=np.arange(len(models)), columns=['LOO', 'pLOO', 'dLOO', 'weight', 'SE', 'dSE', 'warning']) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError('The DCSP information DCSP criterion DCSP {} DCSP is DCSP not DCSP supported.'.format(ic)) DCNL DCSP warns = np.zeros(len(models)) DCNL DCSP c = 0 DCNL DCSP def add_warns(*args): DCNL DCSP  DCSP warns[c] = 1 DCNL DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP warnings.showwarning = add_warns DCNL DCSP  DCSP warnings.filterwarnings('always') DCNL DCSP  DCSP ics = [] DCNL DCSP  DCSP for (c, (t, m)) in enumerate(zip(traces, models)): DCNL DCSP  DCSP  DCSP ics.append((c, ic_func(t, m, pointwise=True))) DCNL DCSP ics.sort(key=(lambda x: x[1][0])) DCNL DCSP if bootstrap: DCNL DCSP  DCSP N = len(ics[0][1][3]) DCNL DCSP  DCSP ic_i = np.zeros((len(ics), N)) DCNL DCSP  DCSP for i in range(len(ics)): DCNL DCSP  DCSP  DCSP ic_i[i] = (ics[i][1][3] * N) DCNL DCSP  DCSP b_weighting = dirichlet.rvs(alpha=([alpha] * N), size=b_samples, random_state=seed) DCNL DCSP  DCSP weights = np.zeros((b_samples, len(ics))) DCNL DCSP  DCSP z_bs = np.zeros((b_samples, len(ics))) DCNL DCSP  DCSP for i in range(b_samples): DCNL DCSP  DCSP  DCSP z_b = np.dot(ic_i, b_weighting[i]) DCNL DCSP  DCSP  DCSP u_weights = np.exp(((-0.5) * (z_b - np.min(z_b)))) DCNL DCSP  DCSP  DCSP z_bs[i] = z_b DCNL DCSP  DCSP  DCSP weights[i] = (u_weights / np.sum(u_weights)) DCNL DCSP  DCSP weights_mean = weights.mean(0) DCNL DCSP  DCSP se = z_bs.std(0) DCNL DCSP  DCSP for (i, (idx, res)) in enumerate(ics): DCNL DCSP  DCSP  DCSP diff = (res[3] - ics[0][1][3]) DCNL DCSP  DCSP  DCSP d_ic = np.sum(diff) DCNL DCSP  DCSP  DCSP d_se = np.sqrt((len(diff) * np.var(diff))) DCNL DCSP  DCSP  DCSP df_comp.at[idx] = (res[0], res[2], d_ic, weights_mean[i], se[i], d_se, warns[idx]) DCNL DCSP else: DCNL DCSP  DCSP min_ic = ics[0][1][0] DCNL DCSP  DCSP Z = np.sum([np.exp(((-0.5) * (x[1][0] - min_ic))) for x in ics]) DCNL DCSP  DCSP for (idx, res) in ics: DCNL DCSP  DCSP  DCSP diff = (res[3] - ics[0][1][3]) DCNL DCSP  DCSP  DCSP d_ic = np.sum(diff) DCNL DCSP  DCSP  DCSP d_se = np.sqrt((len(diff) * np.var(diff))) DCNL DCSP  DCSP  DCSP weight = (np.exp(((-0.5) * (res[0] - min_ic))) / Z) DCNL DCSP  DCSP  DCSP df_comp.at[idx] = (res[0], res[2], d_ic, weight, res[1], d_se, warns[idx]) DCNL DCSP return df_comp.sort_values(by=ic)
 DCSP n = len(x) DCNL DCSP cred_mass = (1.0 - alpha) DCNL DCSP interval_idx_inc = int(np.floor((cred_mass * n))) DCNL DCSP n_intervals = (n - interval_idx_inc) DCNL DCSP interval_width = (x[interval_idx_inc:] - x[:n_intervals]) DCNL DCSP if (len(interval_width) == 0): DCNL DCSP  DCSP raise ValueError('Too DCSP few DCSP elements DCSP for DCSP interval DCSP calculation') DCNL DCSP min_idx = np.argmin(interval_width) DCNL DCSP hdi_min = x[min_idx] DCNL DCSP hdi_max = x[(min_idx + interval_idx_inc)] DCNL DCSP return (hdi_min, hdi_max)
 DCSP x = transform(x.copy()) DCNL DCSP if (x.ndim > 1): DCNL DCSP  DCSP tx = np.transpose(x, (list(range(x.ndim))[1:] + [0])) DCNL DCSP  DCSP dims = np.shape(tx) DCNL DCSP  DCSP intervals = np.resize(0.0, (dims[:(-1)] + (2,))) DCNL DCSP  DCSP for index in make_indices(dims[:(-1)]): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP index = tuple(index) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP sx = np.sort(tx[index]) DCNL DCSP  DCSP  DCSP intervals[index] = calc_min_interval(sx, alpha) DCNL DCSP  DCSP return np.array(intervals) DCNL DCSP else: DCNL DCSP  DCSP sx = np.sort(x) DCNL DCSP  DCSP return np.array(calc_min_interval(sx, alpha))
 DCSP if (x.ndim > 1): DCNL DCSP  DCSP dims = np.shape(x) DCNL DCSP  DCSP trace = np.transpose([t.ravel() for t in x]) DCNL DCSP  DCSP return np.reshape([mc_error(t, batches) for t in trace], dims[1:]) DCNL DCSP else: DCNL DCSP  DCSP if (batches == 1): DCNL DCSP  DCSP  DCSP return (np.std(x) / np.sqrt(len(x))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP batched_traces = np.resize(x, (batches, int((len(x) / batches)))) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP resid = (len(x) % batches) DCNL DCSP  DCSP  DCSP new_shape = (batches, ((len(x) - resid) / batches)) DCNL DCSP  DCSP  DCSP batched_traces = np.resize(x[:(- resid)], new_shape) DCNL DCSP  DCSP means = np.mean(batched_traces, 1) DCNL DCSP  DCSP return (np.std(means) / np.sqrt(batches))
 DCSP x = transform(x.copy()) DCNL DCSP if (x.ndim > 1): DCNL DCSP  DCSP sx = np.sort(x.T).T DCNL DCSP else: DCNL DCSP  DCSP sx = np.sort(x) DCNL DCSP try: DCNL DCSP  DCSP quants = [sx[int(((len(sx) * q) / 100.0))] for q in qlist] DCNL DCSP  DCSP return dict(zip(qlist, quants)) DCNL DCSP except IndexError: DCNL DCSP  DCSP _log.warning('Too DCSP few DCSP elements DCSP for DCSP quantile DCSP calculation')
 DCSP if (varnames is None): DCNL DCSP  DCSP varnames = get_default_varnames(trace.varnames, include_transformed=include_transformed) DCNL DCSP if (batches is None): DCNL DCSP  DCSP batches = min([100, len(trace)]) DCNL DCSP funcs = [(lambda x: pd.Series(np.mean(x, 0), name='mean')), (lambda x: pd.Series(np.std(x, 0), name='sd')), (lambda x: pd.Series(mc_error(x, batches), name='mc_error')), (lambda x: _hpd_df(x, alpha))] DCNL DCSP if ((stat_funcs is not None) and extend): DCNL DCSP  DCSP stat_funcs = (funcs + stat_funcs) DCNL DCSP elif (stat_funcs is None): DCNL DCSP  DCSP stat_funcs = funcs DCNL DCSP var_dfs = [] DCNL DCSP for var in varnames: DCNL DCSP  DCSP vals = transform(trace.get_values(var, burn=start, combine=True)) DCNL DCSP  DCSP flat_vals = vals.reshape(vals.shape[0], (-1)) DCNL DCSP  DCSP var_df = pd.concat([f(flat_vals) for f in stat_funcs], axis=1) DCNL DCSP  DCSP var_df.index = ttab.create_flat_names(var, vals.shape[1:]) DCNL DCSP  DCSP var_dfs.append(var_df) DCNL DCSP return pd.concat(var_dfs, axis=0)
 DCSP if (varnames is None): DCNL DCSP  DCSP varnames = get_default_varnames(trace.varnames, include_transformed=include_transformed) DCNL DCSP if (batches is None): DCNL DCSP  DCSP batches = min([100, len(trace)]) DCNL DCSP stat_summ = _StatSummary(roundto, batches, alpha) DCNL DCSP pq_summ = _PosteriorQuantileSummary(roundto, alpha) DCNL DCSP if (to_file is None): DCNL DCSP  DCSP fh = sys.stdout DCNL DCSP else: DCNL DCSP  DCSP fh = open(to_file, mode='w') DCNL DCSP for var in varnames: DCNL DCSP  DCSP sample = transform(trace.get_values(var, burn=start, combine=True)) DCNL DCSP  DCSP fh.write(('\n%s:\n\n' % var)) DCNL DCSP  DCSP fh.write(stat_summ.output(sample)) DCNL DCSP  DCSP fh.write(pq_summ.output(sample)) DCNL DCSP if (fh is not sys.stdout): DCNL DCSP  DCSP fh.close()
 DCSP idxs = itertools.product(*[range(s) for s in shape]) DCNL DCSP return itertools.groupby(idxs, (lambda x: x[:(-1)]))
 DCSP energy = trace['energy'] DCNL DCSP return (np.square(np.diff(energy)).mean() / np.var(energy))
 DCSP bij = DictToVarBijection(var, idx, point) DCNL DCSP return list(map(bij.mapf(f), x))
 DCSP from numdifftools import Jacobian DCNL DCSP model = modelcontext(model) DCNL DCSP if (vars is None): DCNL DCSP  DCSP vars = model.cont_vars DCNL DCSP vars = inputvars(vars) DCNL DCSP point = Point(point, model=model) DCNL DCSP bij = DictToArrayBijection(ArrayOrdering(vars), point) DCNL DCSP dlogp = bij.mapf(model.fastdlogp(vars)) DCNL DCSP def grad_logp(point): DCNL DCSP  DCSP return np.nan_to_num(dlogp(point)) DCNL DCSP '\n DCSP  DCSP  DCSP  DCSP Find DCSP the DCSP jacobian DCSP of DCSP the DCSP gradient DCSP function DCSP at DCSP the DCSP current DCSP position\n DCSP  DCSP  DCSP  DCSP this DCSP should DCSP be DCSP the DCSP Hessian; DCSP invert DCSP it DCSP to DCSP find DCSP the DCSP approximate\n DCSP  DCSP  DCSP  DCSP covariance DCSP matrix.\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP return (- Jacobian(grad_logp)(bij.map(point)))
 DCSP model = modelcontext(model) DCNL DCSP if (vars is None): DCNL DCSP  DCSP vars = model.cont_vars DCNL DCSP vars = inputvars(vars) DCNL DCSP point = Point(point, model=model) DCNL DCSP bij = DictToArrayBijection(ArrayOrdering(vars), point) DCNL DCSP rval = (np.ones(bij.map(point).size) / 10) DCNL DCSP return rval
 DCSP model = modelcontext(model) DCNL DCSP H = model.fastd2logp(vars) DCNL DCSP return H(Point(point, model=model))
 DCSP model = modelcontext(model) DCNL DCSP H = model.fastfn(hessian_diag(model.logpt, vars)) DCNL DCSP return H(Point(point, model=model))
 DCSP model = modelcontext(model) DCNL DCSP if (model is not None): DCNL DCSP  DCSP vars = model.free_RVs DCNL DCSP elif (vars is None): DCNL DCSP  DCSP vars = trace.varnames DCNL DCSP def flat_t(var): DCNL DCSP  DCSP x = trace[str(var)] DCNL DCSP  DCSP return x.reshape((x.shape[0], np.prod(x.shape[1:], dtype=int))) DCNL DCSP return np.cov(np.concatenate(list(map(flat_t, vars)), 1).T)
 DCSP model = modelcontext(model) DCNL DCSP if (start is None): DCNL DCSP  DCSP start = model.test_point DCNL DCSP else: DCNL DCSP  DCSP update_start_vals(start, model.test_point, model) DCNL DCSP if (not set(start.keys()).issubset(model.named_vars.keys())): DCNL DCSP  DCSP extra_keys = ', DCSP '.join((set(start.keys()) - set(model.named_vars.keys()))) DCNL DCSP  DCSP valid_keys = ', DCSP '.join(model.named_vars.keys()) DCNL DCSP  DCSP raise KeyError('Some DCSP start DCSP parameters DCSP do DCSP not DCSP appear DCSP in DCSP the DCSP model!\nValid DCSP keys DCSP are: DCSP {}, DCSP but DCSP {} DCSP was DCSP supplied'.format(valid_keys, extra_keys)) DCNL DCSP if (vars is None): DCNL DCSP  DCSP vars = model.cont_vars DCNL DCSP vars = inputvars(vars) DCNL DCSP disc_vars = list(typefilter(vars, discrete_types)) DCNL DCSP try: DCNL DCSP  DCSP model.fastdlogp(vars) DCNL DCSP  DCSP gradient_avail = True DCNL DCSP except AttributeError: DCNL DCSP  DCSP gradient_avail = False DCNL DCSP if (disc_vars or (not gradient_avail)): DCNL DCSP  DCSP pm._log.warning((((('Warning: DCSP gradient DCSP not DCSP available.' + '(E.g. DCSP vars DCSP contains DCSP discrete DCSP variables). DCSP MAP DCSP ') + 'estimates DCSP may DCSP not DCSP be DCSP accurate DCSP for DCSP the DCSP default DCSP ') + 'parameters. DCSP Defaulting DCSP to DCSP non-gradient DCSP minimization DCSP ') + 'fmin_powell.')) DCNL DCSP  DCSP fmin = optimize.fmin_powell DCNL DCSP if (fmin is None): DCNL DCSP  DCSP if disc_vars: DCNL DCSP  DCSP  DCSP fmin = optimize.fmin_powell DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fmin = optimize.fmin_bfgs DCNL DCSP allinmodel(vars, model) DCNL DCSP start = Point(start, model=model) DCNL DCSP bij = DictToArrayBijection(ArrayOrdering(vars), start) DCNL DCSP logp = bij.mapf(model.fastlogp) DCNL DCSP def logp_o(point): DCNL DCSP  DCSP return nan_to_high((- logp(point))) DCNL DCSP if ('fprime' in getargspec(fmin).args): DCNL DCSP  DCSP dlogp = bij.mapf(model.fastdlogp(vars)) DCNL DCSP  DCSP def grad_logp_o(point): DCNL DCSP  DCSP  DCSP return nan_to_num((- dlogp(point))) DCNL DCSP  DCSP if (live_disp and (callback is None)): DCNL DCSP  DCSP  DCSP callback = Monitor(bij, logp_o, model, grad_logp_o) DCNL DCSP  DCSP r = fmin(logp_o, bij.map(start), fprime=grad_logp_o, callback=callback, *args, **kwargs) DCNL DCSP  DCSP compute_gradient = True DCNL DCSP else: DCNL DCSP  DCSP if (live_disp and (callback is None)): DCNL DCSP  DCSP  DCSP callback = Monitor(bij, logp_o, dlogp=None) DCNL DCSP  DCSP if ('x0' in getargspec(fmin).args): DCNL DCSP  DCSP  DCSP r = fmin(logp_o, bij.map(start), callback=callback, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP r = fmin(logp_o, callback=callback, *args, **kwargs) DCNL DCSP  DCSP compute_gradient = False DCNL DCSP if isinstance(r, tuple): DCNL DCSP  DCSP mx0 = r[0] DCNL DCSP else: DCNL DCSP  DCSP mx0 = r DCNL DCSP if live_disp: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP callback.update(mx0) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP mx = bij.rmap(mx0) DCNL DCSP allfinite_mx0 = allfinite(mx0) DCNL DCSP allfinite_logp = allfinite(model.logp(mx)) DCNL DCSP if compute_gradient: DCNL DCSP  DCSP allfinite_dlogp = allfinite(model.dlogp()(mx)) DCNL DCSP else: DCNL DCSP  DCSP allfinite_dlogp = True DCNL DCSP if ((not allfinite_mx0) or (not allfinite_logp) or (not allfinite_dlogp)): DCNL DCSP  DCSP messages = [] DCNL DCSP  DCSP for var in vars: DCNL DCSP  DCSP  DCSP vals = {'value': mx[var.name], 'logp': var.logp(mx)} DCNL DCSP  DCSP  DCSP if compute_gradient: DCNL DCSP  DCSP  DCSP  DCSP vals['dlogp'] = var.dlogp()(mx) DCNL DCSP  DCSP  DCSP def message(name, values): DCNL DCSP  DCSP  DCSP  DCSP if (np.size(values) < 10): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ((name + ' DCSP bad: DCSP ') + str(values)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP idx = np.nonzero(logical_not(isfinite(values))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ((((name + ' DCSP bad DCSP at DCSP idx: DCSP ') + str(idx)) + ' DCSP with DCSP values: DCSP ') + str(values[idx])) DCNL DCSP  DCSP  DCSP messages += [message(((var.name + '.') + k), v) for (k, v) in vals.items() if (not allfinite(v))] DCNL DCSP  DCSP specific_errors = '\n'.join(messages) DCNL DCSP  DCSP raise ValueError(((((((((((((('Optimization DCSP error: DCSP max, DCSP logp DCSP or DCSP dlogp DCSP at DCSP ' + 'max DCSP have DCSP non-finite DCSP values. DCSP Some DCSP values DCSP may DCSP be DCSP ') + 'outside DCSP of DCSP distribution DCSP support. DCSP max: DCSP ') + repr(mx)) + ' DCSP logp: DCSP ') + repr(model.logp(mx))) + ' DCSP dlogp: DCSP ') + repr(model.dlogp()(mx))) + 'Check DCSP that DCSP ') + "1) DCSP you DCSP don't DCSP have DCSP hierarchical DCSP parameters, DCSP ") + 'these DCSP will DCSP lead DCSP to DCSP points DCSP with DCSP infinite DCSP ') + "density. DCSP 2) DCSP your DCSP distribution DCSP logp's DCSP are DCSP ") + 'properly DCSP specified. DCSP Specific DCSP issues: DCSP \n') + specific_errors)) DCNL DCSP mx = {v.name: mx[v.name].astype(v.dtype) for v in model.vars} DCNL DCSP if return_raw: DCNL DCSP  DCSP return (mx, r) DCNL DCSP else: DCNL DCSP  DCSP return mx
 DCSP kwargs['mode'] = 'half_to_even' DCNL DCSP return tt.round(*args, **kwargs)
 DCSP if (packed.ndim != 1): DCNL DCSP  DCSP raise ValueError('Packed DCSP triagular DCSP is DCSP not DCSP one DCSP dimensional.') DCNL DCSP if (not isinstance(n, int)): DCNL DCSP  DCSP raise TypeError('n DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP if (diagonal_only and lower): DCNL DCSP  DCSP diag_idxs = (np.arange(1, (n + 1)).cumsum() - 1) DCNL DCSP  DCSP return packed[diag_idxs] DCNL DCSP elif (diagonal_only and (not lower)): DCNL DCSP  DCSP diag_idxs = ((np.arange(2, (n + 2))[::(-1)].cumsum() - n) - 1) DCNL DCSP  DCSP return packed[diag_idxs] DCNL DCSP elif lower: DCNL DCSP  DCSP out = tt.zeros((n, n), dtype=theano.config.floatX) DCNL DCSP  DCSP idxs = np.tril_indices(n) DCNL DCSP  DCSP return tt.set_subtensor(out[idxs], packed) DCNL DCSP elif (not lower): DCNL DCSP  DCSP out = tt.zeros((n, n), dtype=theano.config.floatX) DCNL DCSP  DCSP idxs = np.triu_indices(n) DCNL DCSP  DCSP return tt.set_subtensor(out[idxs], packed)
 DCSP ansible_vars = Ansible.get_variables() DCNL DCSP ceph_stable_release = os.environ.get('CEPH_STABLE_RELEASE', 'kraken') DCNL DCSP node_type = ansible_vars['group_names'][0] DCNL DCSP docker = ansible_vars.get('docker') DCNL DCSP if ((not request.node.get_marker(node_type)) and (not request.node.get_marker('all'))): DCNL DCSP  DCSP pytest.skip(('Not DCSP a DCSP valid DCSP test DCSP for DCSP node DCSP type: DCSP %s' % node_type)) DCNL DCSP if (request.node.get_marker('no_docker') and docker): DCNL DCSP  DCSP pytest.skip('Not DCSP a DCSP valid DCSP test DCSP for DCSP containerized DCSP deployments DCSP or DCSP atomic DCSP hosts') DCNL DCSP if (request.node.get_marker('docker') and (not docker)): DCNL DCSP  DCSP pytest.skip('Not DCSP a DCSP valid DCSP test DCSP for DCSP non-containerized DCSP deployments DCSP or DCSP atomic DCSP hosts') DCNL DCSP if ((node_type == 'mgrs') and (ceph_stable_release == 'jewel')): DCNL DCSP  DCSP pytest.skip('mgr DCSP nodes DCSP can DCSP not DCSP be DCSP tested DCSP with DCSP ceph DCSP release DCSP jewel') DCNL DCSP journal_collocation_test = (ansible_vars.get('osd_scenario') == 'collocated') DCNL DCSP if (request.node.get_marker('journal_collocation') and (not journal_collocation_test)): DCNL DCSP  DCSP pytest.skip('Scenario DCSP is DCSP not DCSP using DCSP journal DCSP collocation') DCNL DCSP osd_ids = [] DCNL DCSP osds = [] DCNL DCSP cluster_address = '' DCNL DCSP address = Interface('eth1').addresses[0] DCNL DCSP subnet = '.'.join(ansible_vars['public_network'].split('.')[0:(-1)]) DCNL DCSP num_mons = len(ansible_vars['groups']['mons']) DCNL DCSP num_devices = len(ansible_vars.get('devices', [])) DCNL DCSP if (not num_devices): DCNL DCSP  DCSP num_devices = len(ansible_vars.get('lvm_volumes', [])) DCNL DCSP num_osd_hosts = len(ansible_vars['groups']['osds']) DCNL DCSP total_osds = (num_devices * num_osd_hosts) DCNL DCSP cluster_name = ansible_vars.get('cluster', 'ceph') DCNL DCSP conf_path = '/etc/ceph/{}.conf'.format(cluster_name) DCNL DCSP if (node_type == 'osds'): DCNL DCSP  DCSP cluster_address = Interface('eth2').addresses[0] DCNL DCSP  DCSP cmd = Command('sudo DCSP ls DCSP /var/lib/ceph/osd/ DCSP | DCSP sed DCSP "s/.*-//"') DCNL DCSP  DCSP if (cmd.rc == 0): DCNL DCSP  DCSP  DCSP osd_ids = cmd.stdout.rstrip('\n').split('\n') DCNL DCSP  DCSP  DCSP osds = osd_ids DCNL DCSP  DCSP  DCSP if docker: DCNL DCSP  DCSP  DCSP  DCSP osds = [device.split('/')[(-1)] for device in ansible_vars.get('devices', [])] DCNL DCSP data = dict(address=address, subnet=subnet, vars=ansible_vars, osd_ids=osd_ids, num_mons=num_mons, num_devices=num_devices, num_osd_hosts=num_osd_hosts, total_osds=total_osds, cluster_name=cluster_name, conf_path=conf_path, cluster_address=cluster_address, docker=docker, osds=osds, ceph_stable_release=ceph_stable_release) DCNL DCSP return data
 DCSP if isinstance(item, dict): DCNL DCSP  DCSP return dict(((_convert_2_string(key), _convert_2_string(value)) for (key, value) in item.iteritems())) DCNL DCSP elif isinstance(item, list): DCNL DCSP  DCSP return [_convert_2_string(i) for i in item] DCNL DCSP elif isinstance(item, tuple): DCNL DCSP  DCSP return tuple([_convert_2_string(i) for i in item]) DCNL DCSP elif isinstance(item, set): DCNL DCSP  DCSP return item DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return item.encode('utf-8') DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return str(item)
 DCSP if isinstance(item, dict): DCNL DCSP  DCSP return dict(((_convert_2_string(key), _convert_2_string(value)) for (key, value) in item.iteritems())) DCNL DCSP elif isinstance(item, list): DCNL DCSP  DCSP return [_convert_2_string(i) for i in item] DCNL DCSP elif isinstance(item, tuple): DCNL DCSP  DCSP return tuple([_convert_2_string(i) for i in item]) DCNL DCSP elif isinstance(item, set): DCNL DCSP  DCSP return item DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return item.encode('utf-8') DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return str(item)
 DCSP (step, update, reset, loss_last, x_last) = minimize_ops DCNL DCSP for _ in xrange(num_epochs): DCNL DCSP  DCSP sess.run(reset) DCNL DCSP  DCSP for _ in xrange(num_unrolls): DCNL DCSP  DCSP  DCSP (cost, final_x, unused_1, unused_2) = sess.run([loss_last, x_last, update, step]) DCNL DCSP return (cost, final_x)
 DCSP start = timer() DCNL DCSP sess.run(reset) DCNL DCSP for _ in xrange(num_unrolls): DCNL DCSP  DCSP cost = sess.run(([cost_op] + ops))[0] DCNL DCSP return ((timer() - start), cost)
 DCSP print(header) DCNL DCSP print('Log DCSP Mean DCSP Final DCSP Error: DCSP {:.2f}'.format(np.log10((total_error / n)))) DCNL DCSP print('Mean DCSP epoch DCSP time: DCSP {:.2f} DCSP s'.format((total_time / n)))
 DCSP if (problem_name == 'simple'): DCNL DCSP  DCSP problem = problems.simple() DCNL DCSP  DCSP net_config = {'cw': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (), 'initializer': 'zeros'}, 'net_path': get_net_path('cw', path)}} DCNL DCSP  DCSP net_assignments = None DCNL DCSP elif (problem_name == 'simple-multi'): DCNL DCSP  DCSP problem = problems.simple_multi_optimizer() DCNL DCSP  DCSP net_config = {'cw': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (), 'initializer': 'zeros'}, 'net_path': get_net_path('cw', path)}, 'adam': {'net': 'Adam', 'net_options': {'learning_rate': 0.1}}} DCNL DCSP  DCSP net_assignments = [('cw', ['x_0']), ('adam', ['x_1'])] DCNL DCSP elif (problem_name == 'quadratic'): DCNL DCSP  DCSP problem = problems.quadratic(batch_size=128, num_dims=10) DCNL DCSP  DCSP net_config = {'cw': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (20, 20)}, 'net_path': get_net_path('cw', path)}} DCNL DCSP  DCSP net_assignments = None DCNL DCSP elif (problem_name == 'mnist'): DCNL DCSP  DCSP mode = ('train' if (path is None) else 'test') DCNL DCSP  DCSP problem = problems.mnist(layers=(20,), mode=mode) DCNL DCSP  DCSP net_config = {'cw': get_default_net_config('cw', path)} DCNL DCSP  DCSP net_assignments = None DCNL DCSP elif (problem_name == 'cifar'): DCNL DCSP  DCSP mode = ('train' if (path is None) else 'test') DCNL DCSP  DCSP problem = problems.cifar10('cifar10', conv_channels=(16, 16, 16), linear_layers=(32,), mode=mode) DCNL DCSP  DCSP net_config = {'cw': get_default_net_config('cw', path)} DCNL DCSP  DCSP net_assignments = None DCNL DCSP elif (problem_name == 'cifar-multi'): DCNL DCSP  DCSP mode = ('train' if (path is None) else 'test') DCNL DCSP  DCSP problem = problems.cifar10('cifar10', conv_channels=(16, 16, 16), linear_layers=(32,), mode=mode) DCNL DCSP  DCSP net_config = {'conv': get_default_net_config('conv', path), 'fc': get_default_net_config('fc', path)} DCNL DCSP  DCSP conv_vars = ['conv_net_2d/conv_2d_{}/w'.format(i) for i in xrange(3)] DCNL DCSP  DCSP fc_vars = ['conv_net_2d/conv_2d_{}/b'.format(i) for i in xrange(3)] DCNL DCSP  DCSP fc_vars += ['conv_net_2d/batch_norm_{}/beta'.format(i) for i in xrange(3)] DCNL DCSP  DCSP fc_vars += ['mlp/linear_{}/w'.format(i) for i in xrange(2)] DCNL DCSP  DCSP fc_vars += ['mlp/linear_{}/b'.format(i) for i in xrange(2)] DCNL DCSP  DCSP fc_vars += ['mlp/batch_norm/beta'] DCNL DCSP  DCSP net_assignments = [('conv', conv_vars), ('fc', fc_vars)] DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('{} DCSP is DCSP not DCSP a DCSP valid DCSP problem'.format(problem_name)) DCNL DCSP return (problem, net_config, net_assignments)
 DCSP if (isinstance(ref, list) or isinstance(ref, tuple)): DCNL DCSP  DCSP if (len(ref) != len(value)): DCNL DCSP  DCSP  DCSP raise ValueError('ref DCSP and DCSP value DCSP have DCSP different DCSP lengths.') DCNL DCSP  DCSP result = [_nested_assign(r, v) for (r, v) in zip(ref, value)] DCNL DCSP  DCSP if isinstance(ref, tuple): DCNL DCSP  DCSP  DCSP return tuple(result) DCNL DCSP  DCSP return result DCNL DCSP else: DCNL DCSP  DCSP return tf.assign(ref, value)
 DCSP if (isinstance(init, list) or isinstance(init, tuple)): DCNL DCSP  DCSP result = [_nested_variable(i, name, trainable) for i in init] DCNL DCSP  DCSP if isinstance(init, tuple): DCNL DCSP  DCSP  DCSP return tuple(result) DCNL DCSP  DCSP return result DCNL DCSP else: DCNL DCSP  DCSP return tf.Variable(init, name=name, trainable=trainable)
 DCSP original_get_variable = tf.get_variable DCNL DCSP def custom_get_variable(*args, **kwargs): DCNL DCSP  DCSP if hasattr(kwargs, 'custom_getter'): DCNL DCSP  DCSP  DCSP raise AttributeError('Custom DCSP getters DCSP are DCSP not DCSP supported DCSP for DCSP optimizee DCSP variables.') DCNL DCSP  DCSP return original_get_variable(custom_getter=custom_getter, *args, **kwargs) DCNL DCSP with mock.patch('tensorflow.get_variable', custom_get_variable): DCNL DCSP  DCSP return func()
 DCSP variables = [] DCNL DCSP constants = [] DCNL DCSP def custom_getter(getter, name, **kwargs): DCNL DCSP  DCSP trainable = kwargs['trainable'] DCNL DCSP  DCSP kwargs['trainable'] = False DCNL DCSP  DCSP variable = getter(name, **kwargs) DCNL DCSP  DCSP if trainable: DCNL DCSP  DCSP  DCSP variables.append(variable) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP constants.append(variable) DCNL DCSP  DCSP return variable DCNL DCSP with tf.name_scope('unused_graph'): DCNL DCSP  DCSP _wrap_variable_creation(func, custom_getter) DCNL DCSP return (variables, constants)
 DCSP variables = collections.deque(variables) DCNL DCSP def custom_getter(getter, name, **kwargs): DCNL DCSP  DCSP if kwargs['trainable']: DCNL DCSP  DCSP  DCSP return variables.popleft() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP kwargs['reuse'] = True DCNL DCSP  DCSP  DCSP return getter(name, **kwargs) DCNL DCSP return _wrap_variable_creation(func, custom_getter)
 DCSP name_to_index = dict(((v.name.split(':')[0], i) for (i, v) in enumerate(variables))) DCNL DCSP if (net_assignments is None): DCNL DCSP  DCSP if (len(config) != 1): DCNL DCSP  DCSP  DCSP raise ValueError('Default DCSP net_assignments DCSP can DCSP only DCSP be DCSP used DCSP if DCSP there DCSP is DCSP a DCSP single DCSP net DCSP config.') DCNL DCSP  DCSP with tf.variable_scope('vars_optimizer'): DCNL DCSP  DCSP  DCSP key = next(iter(config)) DCNL DCSP  DCSP  DCSP kwargs = config[key] DCNL DCSP  DCSP  DCSP net = networks.factory(**kwargs) DCNL DCSP  DCSP nets = {key: net} DCNL DCSP  DCSP keys = [key] DCNL DCSP  DCSP subsets = [range(len(variables))] DCNL DCSP else: DCNL DCSP  DCSP nets = {} DCNL DCSP  DCSP keys = [] DCNL DCSP  DCSP subsets = [] DCNL DCSP  DCSP with tf.variable_scope('vars_optimizer'): DCNL DCSP  DCSP  DCSP for (key, names) in net_assignments: DCNL DCSP  DCSP  DCSP  DCSP if (key in nets): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Repeated DCSP netid DCSP in DCSP net_assigments.') DCNL DCSP  DCSP  DCSP  DCSP nets[key] = networks.factory(**config[key]) DCNL DCSP  DCSP  DCSP  DCSP subset = [name_to_index[name] for name in names] DCNL DCSP  DCSP  DCSP  DCSP keys.append(key) DCNL DCSP  DCSP  DCSP  DCSP subsets.append(subset) DCNL DCSP  DCSP  DCSP  DCSP print('Net: DCSP {}, DCSP Subset: DCSP {}'.format(key, subset)) DCNL DCSP return (nets, keys, subsets)
 DCSP def build(): DCNL DCSP  DCSP 'Builds DCSP loss DCSP graph.' DCNL DCSP  DCSP x = tf.get_variable('x', shape=[], dtype=tf.float32, initializer=tf.ones_initializer()) DCNL DCSP  DCSP return tf.square(x, name='x_squared') DCNL DCSP return build
 DCSP def get_coordinate(i): DCNL DCSP  DCSP return tf.get_variable('x_{}'.format(i), shape=[], dtype=tf.float32, initializer=tf.ones_initializer()) DCNL DCSP def build(): DCNL DCSP  DCSP coordinates = [get_coordinate(i) for i in xrange(num_dims)] DCNL DCSP  DCSP x = tf.concat([tf.expand_dims(c, 0) for c in coordinates], 0) DCNL DCSP  DCSP return tf.reduce_sum(tf.square(x, name='x_squared')) DCNL DCSP return build
 DCSP def build(): DCNL DCSP  DCSP 'Builds DCSP loss DCSP graph.' DCNL DCSP  DCSP x = tf.get_variable('x', shape=[batch_size, num_dims], dtype=dtype, initializer=tf.random_normal_initializer(stddev=stddev)) DCNL DCSP  DCSP w = tf.get_variable('w', shape=[batch_size, num_dims, num_dims], dtype=dtype, initializer=tf.random_uniform_initializer(), trainable=False) DCNL DCSP  DCSP y = tf.get_variable('y', shape=[batch_size, num_dims], dtype=dtype, initializer=tf.random_uniform_initializer(), trainable=False) DCNL DCSP  DCSP product = tf.squeeze(tf.matmul(w, tf.expand_dims(x, (-1)))) DCNL DCSP  DCSP return tf.reduce_mean(tf.reduce_sum(((product - y) ** 2), 1)) DCNL DCSP return build
 DCSP if (weights and (len(weights) != len(problems))): DCNL DCSP  DCSP raise ValueError('len(weights) DCSP != DCSP len(problems)') DCNL DCSP build_fns = [getattr(sys.modules[__name__], p['name'])(**p['options']) for p in problems] DCNL DCSP def build(): DCNL DCSP  DCSP loss = 0 DCNL DCSP  DCSP for (i, build_fn) in enumerate(build_fns): DCNL DCSP  DCSP  DCSP with tf.variable_scope('problem_{}'.format(i)): DCNL DCSP  DCSP  DCSP  DCSP loss_p = build_fn() DCNL DCSP  DCSP  DCSP  DCSP if weights: DCNL DCSP  DCSP  DCSP  DCSP  DCSP loss_p *= weights[i] DCNL DCSP  DCSP  DCSP  DCSP loss += loss_p DCNL DCSP  DCSP return loss DCNL DCSP return build
 DCSP if (activation == 'sigmoid'): DCNL DCSP  DCSP activation_op = tf.sigmoid DCNL DCSP elif (activation == 'relu'): DCNL DCSP  DCSP activation_op = tf.nn.relu DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('{} DCSP activation DCSP not DCSP supported'.format(activation)) DCNL DCSP data = mnist_dataset.load_mnist() DCNL DCSP data = getattr(data, mode) DCNL DCSP images = tf.constant(data.images, dtype=tf.float32, name='MNIST_images') DCNL DCSP images = tf.reshape(images, [(-1), 28, 28, 1]) DCNL DCSP labels = tf.constant(data.labels, dtype=tf.int64, name='MNIST_labels') DCNL DCSP mlp = snt.nets.MLP((list(layers) + [10]), activation=activation_op, initializers=_nn_initializers) DCNL DCSP network = snt.Sequential([snt.BatchFlatten(), mlp]) DCNL DCSP def build(): DCNL DCSP  DCSP indices = tf.random_uniform([batch_size], 0, data.num_examples, tf.int64) DCNL DCSP  DCSP batch_images = tf.gather(images, indices) DCNL DCSP  DCSP batch_labels = tf.gather(labels, indices) DCNL DCSP  DCSP output = network(batch_images) DCNL DCSP  DCSP return _xent_loss(output, batch_labels) DCNL DCSP return build
 DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP filepath = os.path.join(path, CIFAR10_FILE) DCNL DCSP if (not os.path.exists(filepath)): DCNL DCSP  DCSP print('Downloading DCSP CIFAR10 DCSP dataset DCSP to DCSP {}'.format(filepath)) DCNL DCSP  DCSP url = os.path.join(CIFAR10_URL, CIFAR10_FILE) DCNL DCSP  DCSP (filepath, _) = urllib.request.urlretrieve(url, filepath) DCNL DCSP  DCSP statinfo = os.stat(filepath) DCNL DCSP  DCSP print('Successfully DCSP downloaded DCSP {} DCSP bytes'.format(statinfo.st_size)) DCNL DCSP  DCSP tarfile.open(filepath, 'r:gz').extractall(path)
 DCSP _maybe_download_cifar10(path) DCNL DCSP if (mode == 'train'): DCNL DCSP  DCSP filenames = [os.path.join(path, CIFAR10_FOLDER, 'data_batch_{}.bin'.format(i)) for i in xrange(1, 6)] DCNL DCSP elif (mode == 'test'): DCNL DCSP  DCSP filenames = [os.path.join(path, 'test_batch.bin')] DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Mode DCSP {} DCSP not DCSP recognised'.format(mode)) DCNL DCSP depth = 3 DCNL DCSP height = 32 DCNL DCSP width = 32 DCNL DCSP label_bytes = 1 DCNL DCSP image_bytes = ((depth * height) * width) DCNL DCSP record_bytes = (label_bytes + image_bytes) DCNL DCSP reader = tf.FixedLengthRecordReader(record_bytes=record_bytes) DCNL DCSP (_, record) = reader.read(tf.train.string_input_producer(filenames)) DCNL DCSP record_bytes = tf.decode_raw(record, tf.uint8) DCNL DCSP label = tf.cast(tf.slice(record_bytes, [0], [label_bytes]), tf.int32) DCNL DCSP raw_image = tf.slice(record_bytes, [label_bytes], [image_bytes]) DCNL DCSP image = tf.cast(tf.reshape(raw_image, [depth, height, width]), tf.float32) DCNL DCSP image = tf.transpose(image, [1, 2, 0]) DCNL DCSP image = tf.div(image, 255) DCNL DCSP queue = tf.RandomShuffleQueue(capacity=(min_queue_examples + (3 * batch_size)), min_after_dequeue=min_queue_examples, dtypes=[tf.float32, tf.int32], shapes=[image.get_shape(), label.get_shape()]) DCNL DCSP enqueue_ops = [queue.enqueue([image, label]) for _ in xrange(num_threads)] DCNL DCSP tf.train.add_queue_runner(tf.train.QueueRunner(queue, enqueue_ops)) DCNL DCSP def _conv_activation(x): DCNL DCSP  DCSP return tf.nn.max_pool(tf.nn.relu(x), ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') DCNL DCSP conv = snt.nets.ConvNet2D(output_channels=conv_channels, kernel_shapes=[5], strides=[1], paddings=[snt.SAME], activation=_conv_activation, activate_final=True, initializers=_nn_initializers, use_batch_norm=batch_norm) DCNL DCSP if batch_norm: DCNL DCSP  DCSP linear_activation = (lambda x: tf.nn.relu(snt.BatchNorm()(x))) DCNL DCSP else: DCNL DCSP  DCSP linear_activation = tf.nn.relu DCNL DCSP mlp = snt.nets.MLP((list(linear_layers) + [10]), activation=linear_activation, initializers=_nn_initializers) DCNL DCSP network = snt.Sequential([conv, snt.BatchFlatten(), mlp]) DCNL DCSP def build(): DCNL DCSP  DCSP (image_batch, label_batch) = queue.dequeue_many(batch_size) DCNL DCSP  DCSP label_batch = tf.reshape(label_batch, [batch_size]) DCNL DCSP  DCSP output = network(image_batch) DCNL DCSP  DCSP return _xent_loss(output, label_batch) DCNL DCSP return build
 DCSP net_class = getattr(sys.modules[__name__], net) DCNL DCSP net_options = dict(net_options) DCNL DCSP if net_path: DCNL DCSP  DCSP with open(net_path, 'rb') as f: DCNL DCSP  DCSP  DCSP net_options['initializer'] = pickle.load(f) DCNL DCSP return net_class(**net_options)
 DCSP to_save = collections.defaultdict(dict) DCNL DCSP variables = snt.get_variables_in_module(network) DCNL DCSP for v in variables: DCNL DCSP  DCSP split = v.name.split(':')[0].split('/') DCNL DCSP  DCSP module_name = split[(-2)] DCNL DCSP  DCSP variable_name = split[(-1)] DCNL DCSP  DCSP to_save[module_name][variable_name] = v.eval(sess) DCNL DCSP if filename: DCNL DCSP  DCSP with open(filename, 'wb') as f: DCNL DCSP  DCSP  DCSP pickle.dump(to_save, f) DCNL DCSP return to_save
 DCSP if isinstance(initializer, str): DCNL DCSP  DCSP return getattr(tf, (initializer + '_initializer'))(dtype=tf.float32) DCNL DCSP elif isinstance(initializer, np.ndarray): DCNL DCSP  DCSP return tf.constant_initializer(initializer) DCNL DCSP else: DCNL DCSP  DCSP return initializer
 DCSP result = {} DCNL DCSP for f in fields: DCNL DCSP  DCSP if isinstance(initializers, dict): DCNL DCSP  DCSP  DCSP if (f in initializers): DCNL DCSP  DCSP  DCSP  DCSP result[f] = _convert_to_initializer(initializers[f]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result[f] = _convert_to_initializer(initializers) DCNL DCSP return result
 DCSP if (initializers is None): DCNL DCSP  DCSP return None DCNL DCSP if (isinstance(initializers, dict) and (layer_name in initializers)): DCNL DCSP  DCSP return _get_initializers(initializers[layer_name], fields) DCNL DCSP return _get_initializers(initializers, fields)
 DCSP (step, update, reset, loss_last, x_last) = minimize_ops DCNL DCSP for _ in xrange(num_epochs): DCNL DCSP  DCSP sess.run(reset) DCNL DCSP  DCSP for _ in xrange(num_unrolls): DCNL DCSP  DCSP  DCSP (cost, final_x, unused_1, unused_2) = sess.run([loss_last, x_last, update, step]) DCNL DCSP return (cost, final_x)
 DCSP return True
 DCSP if (perm['modelParams']['sensorParams']['encoders']['consumption']['maxval'] > 250): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP errScore = 100 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['visitor_winloss'] is None)): DCNL DCSP  DCSP errScore -= 25 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['home_winloss'] is None)): DCNL DCSP  DCSP errScore -= 20 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['timestamp_timeOfDay'] is None)): DCNL DCSP  DCSP errScore -= 15 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['timestamp_dayOfWeek'] is None)): DCNL DCSP  DCSP errScore -= 10 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['precip'] is None)): DCNL DCSP  DCSP errScore -= 5 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['daynight'] is None)): DCNL DCSP  DCSP errScore += 10 DCNL DCSP dummyModelParams = dict(metricValue=errScore, metricFunctions=None) DCNL DCSP return dummyModelParams
 DCSP return True
 DCSP errScore = 50 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['consumption'] is not None): DCNL DCSP  DCSP errScore += 10 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['address'] is not None): DCNL DCSP  DCSP errScore -= 10 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['gym'] is not None): DCNL DCSP  DCSP errScore -= 20 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['timestamp_timeOfDay'] is not None): DCNL DCSP  DCSP errScore -= 30 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['timestamp_dayOfWeek'] is not None): DCNL DCSP  DCSP errScore -= 40 DCNL DCSP dummyModelParams = dict(metricValue=errScore, iterations=int(os.environ.get('NTA_TEST_numIterations', '1')), waitTime=None, sysExitModelRange=os.environ.get('NTA_TEST_sysExitModelRange', None), errModelRange=os.environ.get('NTA_TEST_errModelRange', None), jobFailErr=bool(os.environ.get('NTA_TEST_jobFailErr', False))) DCNL DCSP return dummyModelParams
 DCSP return True
 DCSP errScore = 100 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['address'] is not None): DCNL DCSP  DCSP errScore -= 0 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['gym'] is not None): DCNL DCSP  DCSP errScore -= 10 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['timestamp_timeOfDay'] is not None): DCNL DCSP  DCSP errScore -= 20 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['timestamp_dayOfWeek'] is not None): DCNL DCSP  DCSP errScore -= 50 DCNL DCSP dummyModelParams = dict(metricValue=errScore, metricFunctions=None) DCNL DCSP return dummyModelParams
 DCSP limit = int(os.environ.get('NTA_TEST_maxvalFilter', 300)) DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['consumption']['maxval'] > limit): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP errScore = 50 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['address'] is not None): DCNL DCSP  DCSP errScore -= 20 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['gym'] is not None): DCNL DCSP  DCSP errScore -= 10 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['timestamp_dayOfWeek'] is not None): DCNL DCSP  DCSP errScore += 30 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['timestamp_timeOfDay'] is not None): DCNL DCSP  DCSP errScore += 40 DCNL DCSP dummyModelParams = dict(metricValue=errScore, iterations=int(os.environ.get('NTA_TEST_numIterations', '1')), waitTime=None, sysExitModelRange=os.environ.get('NTA_TEST_sysExitModelRange', None), errModelRange=os.environ.get('NTA_TEST_errModelRange', None), jobFailErr=bool(os.environ.get('NTA_TEST_jobFailErr', False))) DCNL DCSP return dummyModelParams
 DCSP return True
 DCSP errScore = 500 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['A'] is None)): DCNL DCSP  DCSP errScore -= 40 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['B'] is None)): DCNL DCSP  DCSP errScore -= 30 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['C'] is None)): DCNL DCSP  DCSP errScore -= 20 DCNL DCSP delay = 0 DCNL DCSP encoderCount = 0 DCNL DCSP encoders = perm['modelParams']['sensorParams']['encoders'] DCNL DCSP for (field, encoder) in encoders.items(): DCNL DCSP  DCSP if (encoder is not None): DCNL DCSP  DCSP  DCSP encoderCount += 1 DCNL DCSP if (encoderCount == 2): DCNL DCSP  DCSP delay = 0.1 DCNL DCSP elif ((encoderCount == 3) and (perm['modelParams']['sensorParams']['encoders']['A'] is None)): DCNL DCSP  DCSP delay = 0.2 DCNL DCSP elif (encoderCount == 3): DCNL DCSP  DCSP delay = 0.3 DCNL DCSP dummyModelParams = dict(metricValue=errScore, metricFunctions=None, delay=delay) DCNL DCSP return dummyModelParams
 DCSP return True
 DCSP return True
 DCSP errScore = 50 DCNL DCSP waitTime = 0.01 DCNL DCSP dummyModelParams = dict(metricValue=errScore, iterations=int(os.environ.get('NTA_TEST_numIterations', '5')), waitTime=waitTime, sysExitModelRange=os.environ.get('NTA_TEST_sysExitModelRange', None), delayModelRange=os.environ.get('NTA_TEST_delayModelRange', None), errModelRange=os.environ.get('NTA_TEST_errModelRange', None), jobFailErr=bool(os.environ.get('NTA_TEST_jobFailErr', False))) DCNL DCSP return dummyModelParams
 DCSP limit = int(os.environ.get('NTA_TEST_maxvalFilter', 300)) DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['consumption']['maxval'] > limit): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP errScore = 500 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['A'] is None)): DCNL DCSP  DCSP errScore -= 50 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['B'] is None)): DCNL DCSP  DCSP errScore -= 40 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['C'] is None)): DCNL DCSP  DCSP errScore -= 30 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['D'] is None)): DCNL DCSP  DCSP errScore -= 20 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['E'] is None)): DCNL DCSP  DCSP errScore -= 15 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['F'] is None)): DCNL DCSP  DCSP errScore -= 10 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['G'] is None)): DCNL DCSP  DCSP errScore -= 5 DCNL DCSP delay = 0 DCNL DCSP encoderCount = 0 DCNL DCSP for key in perm.keys(): DCNL DCSP  DCSP if (('encoder' in key) and (not (perm[key] is None))): DCNL DCSP  DCSP  DCSP encoderCount += 1 DCNL DCSP delay = ((encoderCount * encoderCount) * 0.1) DCNL DCSP dummyModelParams = dict(metricValue=errScore, metricFunctions=None, delay=delay) DCNL DCSP return dummyModelParams
 DCSP return True
 DCSP return True
 DCSP limit = int(os.environ.get('NTA_TEST_maxvalFilter', 300)) DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['consumption']['maxval'] > limit): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP errScore = 50 DCNL DCSP errScore += abs((perm['modelParams']['sensorParams']['encoders']['consumption']['maxval'] - 250)) DCNL DCSP errScore += abs((perm['modelParams']['sensorParams']['encoders']['consumption']['n'] - 53)) DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['address'] is not None): DCNL DCSP  DCSP errScore -= 20 DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['gym'] is not None): DCNL DCSP  DCSP errScore -= 10 DCNL DCSP waitTime = None DCNL DCSP if eval(os.environ.get('NTA_TEST_variableWaits', 'False')): DCNL DCSP  DCSP if (perm['modelParams']['sensorParams']['encoders']['timestamp_timeOfDay'] is not None): DCNL DCSP  DCSP  DCSP waitTime = 0.01 DCNL DCSP dummyModelParams = dict(metricValue=errScore, iterations=int(os.environ.get('NTA_TEST_numIterations', '1')), waitTime=waitTime, sysExitModelRange=os.environ.get('NTA_TEST_sysExitModelRange', None), errModelRange=os.environ.get('NTA_TEST_errModelRange', None), jobFailErr=bool(os.environ.get('NTA_TEST_jobFailErr', False))) DCNL DCSP return dummyModelParams
 DCSP limit = int(os.environ.get('NTA_TEST_maxvalFilter', 300)) DCNL DCSP if (perm['modelParams']['sensorParams']['encoders']['consumption']['maxval'] > limit): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP errScore = 500 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['visitor_winloss'] is None)): DCNL DCSP  DCSP errScore -= 6 DCNL DCSP  DCSP if (not (perm['modelParams']['sensorParams']['encoders']['daynight'] is None)): DCNL DCSP  DCSP  DCSP errScore -= 90 DCNL DCSP  DCSP if (not (perm['modelParams']['sensorParams']['encoders']['precip'] is None)): DCNL DCSP  DCSP  DCSP errScore -= 40 DCNL DCSP  DCSP if (not (perm['modelParams']['sensorParams']['encoders']['timestamp_dayOfWeek'] is None)): DCNL DCSP  DCSP  DCSP errScore -= 30 DCNL DCSP  DCSP if (not (perm['modelParams']['sensorParams']['encoders']['timestamp_timeOfDay'] is None)): DCNL DCSP  DCSP  DCSP errScore -= 20 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['home_winloss'] is None)): DCNL DCSP  DCSP errScore -= 5 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['timestamp_timeOfDay'] is None)): DCNL DCSP  DCSP errScore -= 4 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['timestamp_dayOfWeek'] is None)): DCNL DCSP  DCSP errScore -= 3 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['precip'] is None)): DCNL DCSP  DCSP errScore -= 2 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['daynight'] is None)): DCNL DCSP  DCSP errScore += 2 DCNL DCSP dummyModelParams = dict(metricValue=errScore, metricFunctions=None) DCNL DCSP return dummyModelParams
 DCSP return True
 DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResults = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP print ('Hypersearch DCSP job DCSP results: DCSP %r' % (jobResults,)) DCNL DCSP jobResults = json.loads(jobResults) DCNL DCSP return jobResults['bestModel']
 DCSP _debugOut(('_executeExternalCmdAndReapStdout: DCSP Starting...\n<%s>' % (args,))) DCNL DCSP p = subprocess.Popen(args, env=os.environ, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP _debugOut(('Process DCSP started DCSP for DCSP <%s>' % (args,))) DCNL DCSP (stdoutData, stderrData) = p.communicate() DCNL DCSP _debugOut((('Process DCSP completed DCSP for DCSP <%s>: DCSP exit DCSP status=%s, DCSP stdoutDataType=%s, DCSP ' + 'stdoutData=<%s>, DCSP stderrData=<%s>') % (args, p.returncode, type(stdoutData), stdoutData, stderrData))) DCNL DCSP result = dict(exitStatus=p.returncode, stdoutData=stdoutData, stderrData=stderrData) DCNL DCSP _debugOut(('_executeExternalCmdAndReapStdout DCSP for DCSP <%s>: DCSP result=\n%s' % (args, pprint.pformat(result, indent=4)))) DCNL DCSP return result
 DCSP suiteNames = ['OneNodeTests', 'MultiNodeTests', 'ModelMaturityTests', 'SwarmTerminatorTests'] DCNL DCSP testNames = [] DCNL DCSP for suite in suiteNames: DCNL DCSP  DCSP for f in dir(eval(suite)): DCNL DCSP  DCSP  DCSP if f.startswith('test'): DCNL DCSP  DCSP  DCSP  DCSP testNames.append(('%s.%s' % (suite, f))) DCNL DCSP return testNames
 DCSP numCols = (numOnes * numPatterns) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP x[(i * numOnes):((i + 1) * numOnes)] = 1 DCNL DCSP  DCSP p.append(x) DCNL DCSP return p
 DCSP numPatterns = 7 DCNL DCSP p = _getSimplePatterns(numOnes, numPatterns) DCNL DCSP s1 = [p[0], p[1], p[2], p[3], p[4]] DCNL DCSP s2 = [p[0], p[1], p[2], p[3], p[5]] DCNL DCSP s3 = [p[0], p[1], p[2], p[3], p[6]] DCNL DCSP trainingSequences = [s1, s2, s3] DCNL DCSP allPatterns = p DCNL DCSP return (trainingSequences, relativeFrequencies, allPatterns)
 DCSP minThreshold = 4 DCNL DCSP activationThreshold = 4 DCNL DCSP newSynapseCount = 5 DCNL DCSP initialPerm = 0.6 DCNL DCSP connectedPerm = 0.5 DCNL DCSP permanenceInc = 0.1 DCNL DCSP permanenceDec = 0.001 DCNL DCSP globalDecay = 0.0 DCNL DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP print 'Creating DCSP BacktrackingTMCPP DCSP instance' DCNL DCSP cppTm = BacktrackingTMCPP(numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=SEED, verbosity=VERBOSITY, checkSynapseConsistency=checkSynapseConsistency, pamLength=1000) DCNL DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP print 'Creating DCSP PY DCSP TM DCSP instance' DCNL DCSP pyTm = BacktrackingTM(numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=SEED, verbosity=VERBOSITY, pamLength=1000) DCNL DCSP return (cppTm, pyTm)
 DCSP datasetScore = 0 DCNL DCSP numPredictions = 0 DCNL DCSP tm.resetStats() DCNL DCSP for (seqIdx, seq) in enumerate(sequences): DCNL DCSP  DCSP if useResets: DCNL DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP seq = numpy.array(seq, dtype='uint32') DCNL DCSP  DCSP if (verbosity > 2): DCNL DCSP  DCSP  DCSP print '--------------------------------------------------------' DCNL DCSP  DCSP for (i, inputPattern) in enumerate(seq): DCNL DCSP  DCSP  DCSP if (verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP print ('sequence DCSP %d, DCSP element DCSP %d,' % (seqIdx, i)), DCNL DCSP  DCSP  DCSP  DCSP print 'pattern', inputPattern DCNL DCSP  DCSP  DCSP y = tm.infer(inputPattern) DCNL DCSP  DCSP  DCSP if (verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP stats = tm.getStats() DCNL DCSP  DCSP  DCSP  DCSP if (stats['curPredictionScore'] > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP patternConfidence=', stats['curPredictionScore2'] DCNL DCSP  DCSP  DCSP if (verbosity > 3): DCNL DCSP  DCSP  DCSP  DCSP print '\n\n' DCNL DCSP  DCSP  DCSP  DCSP predOut = numpy.sum(tm.predictedState['t'], axis=1) DCNL DCSP  DCSP  DCSP  DCSP actOut = numpy.sum(tm.activeState['t'], axis=1) DCNL DCSP  DCSP  DCSP  DCSP outout = numpy.sum(y.reshape(tm.activeState['t'].shape), axis=1) DCNL DCSP  DCSP  DCSP  DCSP print 'Prediction DCSP non-zeros: DCSP ', predOut.nonzero() DCNL DCSP  DCSP  DCSP  DCSP print 'Activestate DCSP non-zero: DCSP ', actOut.nonzero() DCNL DCSP  DCSP  DCSP  DCSP print 'input DCSP non-zeros: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ', inputPattern.nonzero() DCNL DCSP  DCSP  DCSP  DCSP print 'Output DCSP non-zeros: DCSP  DCSP  DCSP  DCSP  DCSP ', outout.nonzero() DCNL DCSP stats = tm.getStats() DCNL DCSP datasetScore = stats['predictionScoreAvg2'] DCNL DCSP numPredictions = stats['nPredictions'] DCNL DCSP print 'Final DCSP results: DCSP datasetScore=', datasetScore, DCNL DCSP print 'numPredictions=', numPredictions DCNL DCSP return (datasetScore, numPredictions)
 DCSP dataSet = [] DCNL DCSP trainingCummulativeFrequencies = numpy.cumsum(relativeFrequencies) DCNL DCSP for _ in xrange(numSequences): DCNL DCSP  DCSP whichSequence = numpy.searchsorted(trainingCummulativeFrequencies, _RGEN.random_sample()) DCNL DCSP  DCSP dataSet.append(originalSequences[whichSequence]) DCNL DCSP return dataSet
 DCSP assert (minOnes < maxOnes) DCNL DCSP assert (maxOnes < numCols) DCNL DCSP nOnes = rgen.randint(minOnes, maxOnes) DCNL DCSP candidates = list(colSet.difference(set(prevPattern.nonzero()[0]))) DCNL DCSP rgen.shuffle(candidates) DCNL DCSP ind = candidates[:nOnes] DCNL DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP x[ind] = 1 DCNL DCSP return x
 DCSP colSet = set(range(numCols)) DCNL DCSP if ('beginning' in seqGenMode): DCNL DCSP  DCSP assert (('shared' in seqGenMode) and ('no DCSP shared' not in seqGenMode)) DCNL DCSP if (('no DCSP shared' in seqGenMode) or (numSequences == 1)): DCNL DCSP  DCSP pctShared = 0.0 DCNL DCSP if (('no DCSP shared' not in seqGenMode) and ('one DCSP pattern' not in seqGenMode)): DCNL DCSP  DCSP sharedSequenceLength = int((pctShared * sequenceLength)) DCNL DCSP elif ('one DCSP pattern' in seqGenMode): DCNL DCSP  DCSP sharedSequenceLength = 1 DCNL DCSP else: DCNL DCSP  DCSP sharedSequenceLength = 0 DCNL DCSP assert ((sharedSequenceLength + subsequenceStartPos) < sequenceLength) DCNL DCSP sharedSequence = [] DCNL DCSP for i in xrange(sharedSequenceLength): DCNL DCSP  DCSP if (disjointConsecutive and (i > 0)): DCNL DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet, sharedSequence[(i - 1)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet) DCNL DCSP  DCSP sharedSequence.append(x) DCNL DCSP trainingSequences = [] DCNL DCSP if ('beginning' not in seqGenMode): DCNL DCSP  DCSP trailingLength = ((sequenceLength - sharedSequenceLength) - subsequenceStartPos) DCNL DCSP else: DCNL DCSP  DCSP trailingLength = (sequenceLength - sharedSequenceLength) DCNL DCSP for (k, s) in enumerate(xrange(numSequences)): DCNL DCSP  DCSP if ((len(trainingSequences) > 0) and ('shuffle' in seqGenMode)): DCNL DCSP  DCSP  DCSP r = (range(subsequenceStartPos) + range((subsequenceStartPos + sharedSequenceLength), sequenceLength)) DCNL DCSP  DCSP  DCSP rgen.shuffle(r) DCNL DCSP  DCSP  DCSP r = ((r[:subsequenceStartPos] + range(subsequenceStartPos, (subsequenceStartPos + sharedSequenceLength))) + r[subsequenceStartPos:]) DCNL DCSP  DCSP  DCSP sequence = [trainingSequences[(k - 1)][j] for j in r] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sequence = [] DCNL DCSP  DCSP  DCSP if ('beginning' not in seqGenMode): DCNL DCSP  DCSP  DCSP  DCSP for i in xrange(subsequenceStartPos): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (disjointConsecutive and (i > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet, sequence[(i - 1)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sequence.append(x) DCNL DCSP  DCSP  DCSP if (('shared' in seqGenMode) and ('no DCSP shared' not in seqGenMode)): DCNL DCSP  DCSP  DCSP  DCSP sequence.extend(sharedSequence) DCNL DCSP  DCSP  DCSP for i in xrange(trailingLength): DCNL DCSP  DCSP  DCSP  DCSP if (disjointConsecutive and (i > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet, sequence[(i - 1)]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet) DCNL DCSP  DCSP  DCSP  DCSP sequence.append(x) DCNL DCSP  DCSP assert (len(sequence) == sequenceLength) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP assert (len(trainingSequences) == numSequences) DCNL DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP print 'Training DCSP Sequences' DCNL DCSP  DCSP pprint.pprint(trainingSequences) DCNL DCSP if (sharedSequenceLength > 0): DCNL DCSP  DCSP return (trainingSequences, (subsequenceStartPos + sharedSequenceLength)) DCNL DCSP else: DCNL DCSP  DCSP return (trainingSequences, (-1))
 DCSP numCols = (numOnes * numPatterns) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP x[(i * numOnes):((i + 1) * numOnes)] = 1 DCNL DCSP  DCSP p.append(x) DCNL DCSP return p
 DCSP numPatterns = 11 DCNL DCSP p = getSimplePatterns(numOnes, numPatterns) DCNL DCSP s1 = [p[0], p[1], p[2], p[3], p[4], p[5], p[6]] DCNL DCSP s2 = [p[7], p[8], p[2], p[3], p[4], p[9], p[10]] DCNL DCSP trainingSequences = [s1, s2] DCNL DCSP return (trainingSequences, 5)
 DCSP numPatterns = 14 DCNL DCSP p = getSimplePatterns(numOnes, numPatterns) DCNL DCSP s1 = [p[0], p[1], p[0], p[1], p[0], p[2]] DCNL DCSP s2 = [p[0], p[1], p[0], p[1], p[3], p[4]] DCNL DCSP s3 = [p[0], p[1], p[5], p[6], p[7], p[8]] DCNL DCSP s4 = [p[0], p[9], p[10], p[11], p[12], p[13]] DCNL DCSP trainingSequences = [s1, s2, s3, s4] DCNL DCSP return (trainingSequences, 5)
 DCSP numPatterns = 23 DCNL DCSP p = getSimplePatterns(numOnes, numPatterns) DCNL DCSP s = [] DCNL DCSP s.append(p[rgen.randint(3, 23)]) DCNL DCSP for i in xrange(20): DCNL DCSP  DCSP s.append(p[rgen.randint(3, 23)]) DCNL DCSP  DCSP s.append(p[0]) DCNL DCSP  DCSP s.append(p[1]) DCNL DCSP  DCSP s.append(p[2]) DCNL DCSP  DCSP s.append(p[rgen.randint(3, 23)]) DCNL DCSP return ([s], [[p[0], p[1], p[2]]])
 DCSP numPatterns = 23 DCNL DCSP p = getSimplePatterns(numOnes, numPatterns) DCNL DCSP s = [] DCNL DCSP s.append(p[rgen.randint(5, numPatterns)]) DCNL DCSP for i in xrange(50): DCNL DCSP  DCSP r = rgen.randint(5, numPatterns) DCNL DCSP  DCSP print r, DCNL DCSP  DCSP s.append(p[r]) DCNL DCSP  DCSP if (rgen.binomial(1, 0.5) > 0): DCNL DCSP  DCSP  DCSP print 'S1', DCNL DCSP  DCSP  DCSP s.append(p[0]) DCNL DCSP  DCSP  DCSP s.append(p[1]) DCNL DCSP  DCSP  DCSP s.append(p[2]) DCNL DCSP  DCSP  DCSP s.append(p[4]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print 'S2', DCNL DCSP  DCSP  DCSP s.append(p[1]) DCNL DCSP  DCSP  DCSP s.append(p[2]) DCNL DCSP  DCSP  DCSP s.append(p[3]) DCNL DCSP  DCSP r = rgen.randint(5, numPatterns) DCNL DCSP  DCSP s.append(p[r]) DCNL DCSP  DCSP print r, DCNL DCSP print DCNL DCSP return ([s], [[p[0], p[1], p[2], p[4]], [p[1], p[2], p[3]]])
 DCSP upTo = (t + 2) DCNL DCSP if tm.doPooling: DCNL DCSP  DCSP upTo += min(tm.segUpdateValidDuration, nAcceptable) DCNL DCSP assert (upTo <= len(trainingSequences[whichSequence])) DCNL DCSP acceptablePatterns = [] DCNL DCSP if ((len(trainingSequences) == 2) and (trainingSequences[0][0] == trainingSequences[1][0]).all()): DCNL DCSP  DCSP if ((trainingSequences[0][t] == trainingSequences[1][t]).all() and (trainingSequences[0][(t + 1)] != trainingSequences[1][(t + 1)]).any()): DCNL DCSP  DCSP  DCSP acceptablePatterns.append(trainingSequences[0][(t + 1)]) DCNL DCSP  DCSP  DCSP acceptablePatterns.append(trainingSequences[1][(t + 1)]) DCNL DCSP acceptablePatterns += [trainingSequences[whichSequence][t] for t in xrange(t, upTo)] DCNL DCSP return acceptablePatterns
 DCSP global BacktrackingTM, SEED, checkSynapseConsistency, VERBOSITY DCNL DCSP numPerfect = 0 DCNL DCSP numStrictErrors = 0 DCNL DCSP numFailures = 0 DCNL DCSP sequenceLength = len(trainingSequences[0]) DCNL DCSP segUpdateValidDuration = 5 DCNL DCSP verbosity = VERBOSITY DCNL DCSP if highOrder: DCNL DCSP  DCSP tm = TMClass(numberOfCols, cellsPerColumn, initialPerm, connectedPerm, minThreshold, newSynapseCount, permanenceInc, permanenceDec, permanenceMax, globalDecay, activationThreshold, doPooling, segUpdateValidDuration, seed=SEED, verbosity=verbosity, checkSynapseConsistency=checkSynapseConsistency, pamLength=pamLength, maxSeqLength=0) DCNL DCSP else: DCNL DCSP  DCSP tm = TMClass(numberOfCols, cellsPerColumn, initialPerm, connectedPerm, minThreshold, newSynapseCount, permanenceInc, permanenceDec, permanenceMax, globalDecay, activationThreshold, doPooling, segUpdateValidDuration, seed=SEED, verbosity=verbosity, checkSynapseConsistency=checkSynapseConsistency, pamLength=pamLength) DCNL DCSP if compareToPy: DCNL DCSP  DCSP if highOrder: DCNL DCSP  DCSP  DCSP py_tm = BacktrackingTM(numberOfCols, cellsPerColumn, initialPerm, connectedPerm, minThreshold, newSynapseCount, permanenceInc, permanenceDec, permanenceMax, globalDecay, activationThreshold, doPooling, segUpdateValidDuration, seed=SEED, verbosity=verbosity, pamLength=pamLength, maxSeqLength=0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP py_tm = BacktrackingTM(numberOfCols, cellsPerColumn, initialPerm, connectedPerm, minThreshold, newSynapseCount, permanenceInc, permanenceDec, permanenceMax, globalDecay, activationThreshold, doPooling, segUpdateValidDuration, seed=SEED, verbosity=verbosity, pamLength=pamLength) DCNL DCSP trainingSequences = trainingSequences[0] DCNL DCSP if (testSequences == None): DCNL DCSP  DCSP testSequences = trainingSequences DCNL DCSP inferAcceptablePatterns = (acceptablePatterns == []) DCNL DCSP for r in xrange(nTrainingReps): DCNL DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP print '============= DCSP Learning DCSP round', r, '=================' DCNL DCSP  DCSP for (sequenceNum, trainingSequence) in enumerate(trainingSequences): DCNL DCSP  DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP  DCSP print '============= DCSP New DCSP sequence DCSP =================' DCNL DCSP  DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP  DCSP  DCSP if compareToPy: DCNL DCSP  DCSP  DCSP  DCSP  DCSP py_tm.reset() DCNL DCSP  DCSP  DCSP for (t, x) in enumerate(trainingSequence): DCNL DCSP  DCSP  DCSP  DCSP if ((noiseModel is not None) and ('xor' in noiseModel) and ('binomial' in noiseModel) and ('training' in noiseModel)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP noise_vector = rgen.binomial(len(x), noiseLevel, len(x)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = logical_xor(x, noise_vector) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Time DCSP step', t, 'learning DCSP round', r, 'sequence DCSP number', sequenceNum DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Input: DCSP ', tm.printInput(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'NNZ:', x.nonzero() DCNL DCSP  DCSP  DCSP  DCSP x = numpy.array(x).astype('float32') DCNL DCSP  DCSP  DCSP  DCSP y = tm.learn(x) DCNL DCSP  DCSP  DCSP  DCSP if compareToPy: DCNL DCSP  DCSP  DCSP  DCSP  DCSP py_y = py_tm.learn(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((t % 25) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert (fdrutils.tmDiff(tm, py_tm, VERBOSITY) == True) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY > 4)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP  DCSP print 'Sequence DCSP finished. DCSP Complete DCSP state DCSP after DCSP sequence' DCNL DCSP  DCSP  DCSP  DCSP tm.printCells() DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP numPerfectAtHub = 0 DCNL DCSP if compareToPy: DCNL DCSP  DCSP print 'End DCSP of DCSP training' DCNL DCSP  DCSP assert (fdrutils.tmDiff(tm, py_tm, VERBOSITY) == True) DCNL DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP print '============= DCSP Inference DCSP =================' DCNL DCSP for (s, testSequence) in enumerate(testSequences): DCNL DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP print '============= DCSP New DCSP sequence DCSP =================' DCNL DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP  DCSP if compareToPy: DCNL DCSP  DCSP  DCSP  DCSP py_tm.reset() DCNL DCSP  DCSP slen = len(testSequence) DCNL DCSP  DCSP for (t, x) in enumerate(testSequence): DCNL DCSP  DCSP  DCSP if ((noiseModel is not None) and ('xor' in noiseModel) and ('binomial' in noiseModel) and ('inference' in noiseModel)): DCNL DCSP  DCSP  DCSP  DCSP noise_vector = rgen.binomial(len(x), noiseLevel, len(x)) DCNL DCSP  DCSP  DCSP  DCSP x = logical_xor(x, noise_vector) DCNL DCSP  DCSP  DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP  DCSP  DCSP print 'Time DCSP step', t, '\nInput:', tm.printInput(x) DCNL DCSP  DCSP  DCSP x = numpy.array(x).astype('float32') DCNL DCSP  DCSP  DCSP y = tm.infer(x) DCNL DCSP  DCSP  DCSP if compareToPy: DCNL DCSP  DCSP  DCSP  DCSP py_y = py_tm.infer(x) DCNL DCSP  DCSP  DCSP  DCSP assert (fdrutils.tmDiff(tm, py_tm, VERBOSITY) == True) DCNL DCSP  DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY > 4), printLearnState=False) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP if (nMultiStepPrediction > 0): DCNL DCSP  DCSP  DCSP  DCSP y_ms = tm.predict(nSteps=nMultiStepPrediction) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Multi DCSP step DCSP prediction DCSP at DCSP Time DCSP step', t DCNL DCSP  DCSP  DCSP  DCSP  DCSP for i in range(nMultiStepPrediction): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Prediction DCSP at DCSP t+', (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm.printColConfidence(y_ms[i]) DCNL DCSP  DCSP  DCSP  DCSP for i in range(nMultiStepPrediction): DCNL DCSP  DCSP  DCSP  DCSP  DCSP predictedTimeStep = ((t + i) + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (predictedTimeStep < slen): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP input = testSequence[predictedTimeStep].nonzero()[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP prediction = y_ms[i].nonzero()[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (foundInInput, totalActiveInInput, missingFromInput, totalActiveInPrediction) = fdrutils.checkMatch(input, prediction, sparse=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP falseNegatives = (totalActiveInInput - foundInInput) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP falsePositives = missingFromInput DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Predition DCSP from DCSP %d DCSP to DCSP %d' % (t, ((t + i) + 1))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB False DCSP Negatives:', falseNegatives DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB False DCSP Positivies:', falsePositives DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 0) or (falsePositives > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numStrictErrors += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 0) and (VERBOSITY > 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Multi DCSP step DCSP prediction DCSP from DCSP t=', t, 'to DCSP t=', ((t + i) + 1), 'false DCSP negative DCSP with DCSP error=', falseNegatives, DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'out DCSP of', totalActiveInInput, 'ones' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((falsePositives > 0) and (VERBOSITY > 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Multi DCSP step DCSP prediction DCSP from DCSP t=', t, 'to DCSP t=', ((t + i) + 1), 'false DCSP positive DCSP with DCSP error=', falsePositives, DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'out DCSP of', totalActiveInInput, 'ones' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((falsePositives > 3) or (falseNegatives > 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numFailures += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((VERBOSITY > 1) and (not shouldFail)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Input DCSP at DCSP t=', t DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(testSequence[t]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Prediction DCSP for DCSP t=', ((t + i) + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(y_ms[i]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Actual DCSP input DCSP at DCSP t=', ((t + i) + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(testSequence[((t + i) + 1)]) DCNL DCSP  DCSP  DCSP if (t < (slen - 1)): DCNL DCSP  DCSP  DCSP  DCSP if inferAcceptablePatterns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP acceptablePatterns = findAcceptablePatterns(tm, t, s, testSequences, nAcceptable) DCNL DCSP  DCSP  DCSP  DCSP scores = tm._checkPrediction([pattern.nonzero()[0] for pattern in acceptablePatterns]) DCNL DCSP  DCSP  DCSP  DCSP (falsePositives, falseNegatives) = (scores[0], scores[1]) DCNL DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 0) or (falsePositives > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP numStrictErrors += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 0) and (VERBOSITY > 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Pattern', s, 'time', t, 'prediction DCSP false DCSP negative DCSP with DCSP error=', falseNegatives, DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'out DCSP of', int(testSequence[(t + 1)].sum()), 'ones' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((falsePositives > 0) and (VERBOSITY > 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Pattern', s, 'time', t, 'prediction DCSP false DCSP positive DCSP with DCSP error=', falsePositives, DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'out DCSP of', int(testSequence[(t + 1)].sum()), 'ones' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 3) or (falsePositives > 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numFailures += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((VERBOSITY > 1) and (not shouldFail)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Test DCSP sequences' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (len(testSequences) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printAllTrainingSequences(testSequences, (t + 1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(testSequence[t]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(testSequence[(t + 1)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Acceptable' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for p in acceptablePatterns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(p) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Output' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP diagnostic = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output = sum(tm.currentOutput, axis=1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(output) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP numPerfect += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((predJustAfterHubOnly is not None) and (predJustAfterHubOnly == t)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numPerfectAtHub += 1 DCNL DCSP if (predJustAfterHubOnly is None): DCNL DCSP  DCSP return (numFailures, numStrictErrors, numPerfect, tm) DCNL DCSP else: DCNL DCSP  DCSP return (numFailures, numStrictErrors, numPerfect, numPerfectAtHub, tm)
 DCSP print 'Test DCSP H2a DCSP - DCSP second DCSP repetition DCSP of DCSP the DCSP same DCSP sequence DCSP should DCSP not DCSP add DCSP synapses' DCNL DCSP nFailed = 0 DCNL DCSP subsequenceStartPos = 10 DCNL DCSP assert (subsequenceStartPos < sequenceLength) DCNL DCSP for numSequences in nSequences: DCNL DCSP  DCSP print 'Higher DCSP order DCSP test DCSP with DCSP sequenceLength=', sequenceLength, DCNL DCSP  DCSP print 'cellsPerColumn=', cellsPerColumn, 'nTests=', nTests, 'numCols=', numCols DCNL DCSP  DCSP print 'numSequences=', numSequences, 'pctShared=', pctShared, DCNL DCSP  DCSP print 'sharing DCSP mode=', seqGenMode DCNL DCSP  DCSP for k in range(nTests): DCNL DCSP  DCSP  DCSP trainingSet = buildTrainingSet(numSequences=numSequences, sequenceLength=sequenceLength, pctShared=pctShared, seqGenMode=seqGenMode, subsequenceStartPos=subsequenceStartPos, numCols=numCols, minOnes=21, maxOnes=25) DCNL DCSP  DCSP  DCSP print '============== DCSP 10 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures3, numStrictErrors3, numPerfect3, tm3) = _testSequence(trainingSet, nTrainingReps=10, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.4, connectedPerm=0.7, minThreshold=12, permanenceInc=0.1, permanenceDec=0.1, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThreshold=12, doPooling=False, shouldFail=shouldFail) DCNL DCSP  DCSP  DCSP print '============== DCSP 2 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures, numStrictErrors, numPerfect, tm2) = _testSequence(trainingSet, nTrainingReps=2, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=12, permanenceInc=0.1, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThreshold=12, doPooling=False, shouldFail=shouldFail) DCNL DCSP  DCSP  DCSP print '============== DCSP 1 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures1, numStrictErrors1, numPerfect1, tm1) = _testSequence(trainingSet, nTrainingReps=1, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=12, permanenceInc=0.1, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThreshold=12, doPooling=False, shouldFail=shouldFail) DCNL DCSP  DCSP  DCSP segmentInfo1 = tm1.getSegmentInfo() DCNL DCSP  DCSP  DCSP segmentInfo2 = tm2.getSegmentInfo() DCNL DCSP  DCSP  DCSP if ((abs((segmentInfo1[0] - segmentInfo2[0])) > 3) or (abs((segmentInfo1[1] - segmentInfo2[1])) > (3 * 15))): DCNL DCSP  DCSP  DCSP  DCSP print 'Training DCSP twice DCSP incorrectly DCSP resulted DCSP in DCSP too DCSP many DCSP segments DCSP or DCSP synapses' DCNL DCSP  DCSP  DCSP  DCSP print segmentInfo1 DCNL DCSP  DCSP  DCSP  DCSP print segmentInfo2 DCNL DCSP  DCSP  DCSP  DCSP print tm3.getSegmentInfo() DCNL DCSP  DCSP  DCSP  DCSP tm3.trimSegments() DCNL DCSP  DCSP  DCSP  DCSP print tm3.getSegmentInfo() DCNL DCSP  DCSP  DCSP  DCSP print 'Failures DCSP for DCSP 1, DCSP 2, DCSP and DCSP N DCSP reps' DCNL DCSP  DCSP  DCSP  DCSP print numFailures1, numStrictErrors1, numPerfect1 DCNL DCSP  DCSP  DCSP  DCSP print numFailures, numStrictErrors, numPerfect DCNL DCSP  DCSP  DCSP  DCSP print numFailures3, numStrictErrors3, numPerfect3 DCNL DCSP  DCSP  DCSP  DCSP numFailures += 1 DCNL DCSP  DCSP  DCSP if (((numFailures == 0) and (not shouldFail)) or ((numFailures > 0) and shouldFail)): DCNL DCSP  DCSP  DCSP  DCSP print 'Test DCSP PASS', DCNL DCSP  DCSP  DCSP  DCSP if shouldFail: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '(should DCSP fail, DCSP and DCSP failed)' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print 'Test DCSP FAILED' DCNL DCSP  DCSP  DCSP  DCSP nFailed = (nFailed + 1) DCNL DCSP  DCSP  DCSP  DCSP print 'numFailures=', numFailures DCNL DCSP  DCSP  DCSP  DCSP print 'numStrictErrors=', numStrictErrors DCNL DCSP  DCSP  DCSP  DCSP print 'numPerfect=', numPerfect DCNL DCSP return nFailed
 DCSP (cellsPerColumn, numSequences) = (x[0], x[1]) DCNL DCSP nTrainingReps = 1 DCNL DCSP sequenceLength = 10 DCNL DCSP numCols = 200 DCNL DCSP print 'Started', cellsPerColumn, numSequences DCNL DCSP seqGenMode = 'shared DCSP subsequence, DCSP one DCSP pattern' DCNL DCSP subsequenceStartPos = 5 DCNL DCSP trainingSet = buildTrainingSet(numSequences=numSequences, sequenceLength=sequenceLength, pctShared=0.1, seqGenMode=seqGenMode, subsequenceStartPos=subsequenceStartPos, numCols=numCols, minOnes=21, maxOnes=25) DCNL DCSP (numFailures1, numStrictErrors1, numPerfect1, atHub, tm) = _testSequence(trainingSet, nTrainingReps=nTrainingReps, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=11, permanenceInc=0.4, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=8, activationThreshold=8, doPooling=False, shouldFail=False, predJustAfterHubOnly=5) DCNL DCSP seqGenMode = 'no DCSP shared DCSP subsequence' DCNL DCSP trainingSet = buildTrainingSet(numSequences=numSequences, sequenceLength=sequenceLength, pctShared=0, seqGenMode=seqGenMode, subsequenceStartPos=0, numCols=numCols, minOnes=21, maxOnes=25) DCNL DCSP (numFailures2, numStrictErrors2, numPerfect2, tm) = _testSequence(trainingSet, nTrainingReps=nTrainingReps, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=11, permanenceInc=0.4, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=8, activationThreshold=8, doPooling=False, shouldFail=False) DCNL DCSP print 'Completed', DCNL DCSP print cellsPerColumn, numSequences, numFailures1, numStrictErrors1, numPerfect1, atHub, numFailures2, numStrictErrors2, numPerfect2 DCNL DCSP return (cellsPerColumn, numSequences, numFailures1, numStrictErrors1, numPerfect1, atHub, numFailures2, numStrictErrors2, numPerfect2)
 DCSP from multiprocessing import Pool DCNL DCSP import itertools DCNL DCSP print 'Hub DCSP capacity DCSP test' DCNL DCSP p = Pool(2) DCNL DCSP results = p.map(worker, itertools.product([1, 2, 3, 4, 5, 6, 7, 8], xrange(1, 2000, 200))) DCNL DCSP f = open('results-numPerfect.11.22.10.txt', 'w') DCNL DCSP for (i, r) in enumerate(results): DCNL DCSP  DCSP print >>f, ('{%d,%d,%d,%d,%d,%d,%d,%d,%d},' % r) DCNL DCSP f.close()
 DCSP print ''.join((('1' if (k != 0) else '.') for k in x))
 DCSP assert (patternOverlap < numOnes) DCNL DCSP numNewBitsInEachPattern = (numOnes - patternOverlap) DCNL DCSP numCols = ((numNewBitsInEachPattern * numPatterns) + patternOverlap) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP startBit = (i * numNewBitsInEachPattern) DCNL DCSP  DCSP nextStartBit = (startBit + numOnes) DCNL DCSP  DCSP x[startBit:nextStartBit] = 1 DCNL DCSP  DCSP p.append(x) DCNL DCSP return p
 DCSP numSharedElements = len(sharedElements) DCNL DCSP numUniqueElements = (seqLen - numSharedElements) DCNL DCSP numPatterns = (numSharedElements + (numUniqueElements * numSequences)) DCNL DCSP patterns = getSimplePatterns(numOnBitsPerPattern, numPatterns, patternOverlap) DCNL DCSP numCols = len(patterns[0]) DCNL DCSP trainingSequences = [] DCNL DCSP uniquePatternIndices = range(numSharedElements, numPatterns) DCNL DCSP for i in xrange(numSequences): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP sharedPatternIndices = range(numSharedElements) DCNL DCSP  DCSP for j in xrange(seqLen): DCNL DCSP  DCSP  DCSP if (j in sharedElements): DCNL DCSP  DCSP  DCSP  DCSP patIdx = sharedPatternIndices.pop(0) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP patIdx = uniquePatternIndices.pop(0) DCNL DCSP  DCSP  DCSP sequence.append(patterns[patIdx]) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP print '\nTraining DCSP sequences' DCNL DCSP  DCSP printAllTrainingSequences(trainingSequences) DCNL DCSP return (numCols, trainingSequences)
 DCSP patterns = getSimplePatterns(numOnBitsPerPattern, numPatterns, patternOverlap) DCNL DCSP numCols = len(patterns[0]) DCNL DCSP trainingSequences = [] DCNL DCSP for i in xrange(numSequences): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP length = random.choice(seqLen) DCNL DCSP  DCSP for j in xrange(length): DCNL DCSP  DCSP  DCSP patIdx = random.choice(xrange(numPatterns)) DCNL DCSP  DCSP  DCSP sequence.append(patterns[patIdx]) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP print '\nTraining DCSP sequences' DCNL DCSP  DCSP printAllTrainingSequences(trainingSequences) DCNL DCSP return (numCols, trainingSequences)
 DCSP connectedPerm = 0.5 DCNL DCSP tms = dict() DCNL DCSP if includeCPP: DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print 'Creating DCSP BacktrackingTMCPP DCSP instance' DCNL DCSP  DCSP cpp_tm = BacktrackingTMCPP(numberOfCols=numCols, cellsPerColumn=cellsPerCol, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=SEED, verbosity=VERBOSITY, checkSynapseConsistency=checkSynapseConsistency, collectStats=True, pamLength=pamLength, maxInfBacktrack=maxInfBacktrack, maxLrnBacktrack=maxLrnBacktrack) DCNL DCSP  DCSP cpp_tm.retrieveLearningStates = True DCNL DCSP  DCSP tms['CPP'] = cpp_tm DCNL DCSP if includePy: DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print 'Creating DCSP PY DCSP TM DCSP instance' DCNL DCSP  DCSP py_tm = BacktrackingTM(numberOfCols=numCols, cellsPerColumn=cellsPerCol, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=SEED, verbosity=VERBOSITY, collectStats=True, pamLength=pamLength, maxInfBacktrack=maxInfBacktrack, maxLrnBacktrack=maxLrnBacktrack) DCNL DCSP  DCSP tms['PY DCSP '] = py_tm DCNL DCSP return tms
 DCSP if (len(tms) == 1): DCNL DCSP  DCSP return DCNL DCSP if (len(tms) > 2): DCNL DCSP  DCSP raise 'Not DCSP implemented DCSP for DCSP more DCSP than DCSP 2 DCSP TMs' DCNL DCSP same = fdrutils.tmDiff2(verbosity=VERBOSITY, *tms.values()) DCNL DCSP assert same DCNL DCSP return
 DCSP if (testSequences == None): DCNL DCSP  DCSP testSequences = trainingSequences DCNL DCSP firstTP = tms.values()[0] DCNL DCSP assertNoTMDiffs(tms) DCNL DCSP for trainingNum in xrange(nTrainRepetitions): DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print '\n##############################################################' DCNL DCSP  DCSP  DCSP print ('################# DCSP Training DCSP round DCSP #%d DCSP of DCSP %d DCSP #################' % (trainingNum, nTrainRepetitions)) DCNL DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP print ('TM DCSP parameters DCSP for DCSP %s: DCSP ' % name) DCNL DCSP  DCSP  DCSP  DCSP print '---------------------' DCNL DCSP  DCSP  DCSP  DCSP tm.printParameters() DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP numSequences = len(testSequences) DCNL DCSP  DCSP for (sequenceNum, trainingSequence) in enumerate(trainingSequences): DCNL DCSP  DCSP  DCSP numTimeSteps = len(trainingSequence) DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP print ('\n================= DCSP Sequence DCSP #%d DCSP of DCSP %d DCSP ================' % (sequenceNum, numSequences)) DCNL DCSP  DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP  DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP  DCSP for (t, x) in enumerate(trainingSequence): DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print '------------------------------------------------------------' DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('--------- DCSP sequence: DCSP #%d DCSP of DCSP %d, DCSP timeStep: DCSP #%d DCSP of DCSP %d DCSP -----------' % (sequenceNum, numSequences, t, numTimeSteps)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP firstTP.printInput(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'input DCSP nzs:', x.nonzero() DCNL DCSP  DCSP  DCSP  DCSP x = numpy.array(x).astype('float32') DCNL DCSP  DCSP  DCSP  DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.learn(x, enableInference=True) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('I/O DCSP states DCSP of DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print '-------------------------------------', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY >= 5)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP assertNoTMDiffs(tms) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP stats = tm.getStats() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('# DCSP of DCSP unpredicted DCSP columns DCSP for DCSP %s DCSP TM: DCSP %d DCSP of DCSP %d' % (name, stats['curMissing'], x.sum())) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numBurstingCols = tm.infActiveState['t'].min(axis=1).sum() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('# DCSP of DCSP bursting DCSP columns DCSP for DCSP %s DCSP TM: DCSP %d DCSP of DCSP %d' % (name, numBurstingCols, x.sum())) DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 4): DCNL DCSP  DCSP  DCSP  DCSP print ('Sequence DCSP %d DCSP finished.' % sequenceNum) DCNL DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('All DCSP cells DCSP of DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '-------------------------------------', DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.printCells() DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print DCNL DCSP  DCSP prevResult = None DCNL DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP stats = tm.getStats() DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 1): DCNL DCSP  DCSP  DCSP  DCSP print ('Stats DCSP for DCSP %s DCSP TM DCSP over DCSP all DCSP sequences DCSP for DCSP training DCSP round DCSP #%d DCSP of DCSP %d:' % (name, trainingNum, nTrainRepetitions)) DCNL DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP total DCSP missing:', stats['totalMissing'] DCNL DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP total DCSP extra:', stats['totalExtra'] DCNL DCSP  DCSP  DCSP if (prevResult is None): DCNL DCSP  DCSP  DCSP  DCSP prevResult = (stats['totalMissing'], stats['totalExtra']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (stats['totalMissing'] == prevResult[0]) DCNL DCSP  DCSP  DCSP  DCSP assert (stats['totalExtra'] == prevResult[1]) DCNL DCSP  DCSP  DCSP tm.resetStats() DCNL DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP print 'Calling DCSP trim DCSP segments' DCNL DCSP prevResult = None DCNL DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP (nSegsRemoved, nSynsRemoved) = tm.trimSegments() DCNL DCSP  DCSP if (prevResult is None): DCNL DCSP  DCSP  DCSP prevResult = (nSegsRemoved, nSynsRemoved) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert (nSegsRemoved == prevResult[0]) DCNL DCSP  DCSP  DCSP assert (nSynsRemoved == prevResult[1]) DCNL DCSP assertNoTMDiffs(tms) DCNL DCSP if (VERBOSITY >= 4): DCNL DCSP  DCSP print 'Training DCSP completed. DCSP Complete DCSP state:' DCNL DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP print ('%s:' % name) DCNL DCSP  DCSP  DCSP tm.printCells() DCNL DCSP  DCSP  DCSP print DCNL DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP print '\n##############################################################' DCNL DCSP  DCSP print '########################## DCSP Inference DCSP #########################' DCNL DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP tm.resetStats() DCNL DCSP numSequences = len(testSequences) DCNL DCSP for (sequenceNum, testSequence) in enumerate(testSequences): DCNL DCSP  DCSP numTimeSteps = len(testSequence) DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print ('\n================= DCSP Sequence DCSP %d DCSP of DCSP %d DCSP ================' % (sequenceNum, numSequences)) DCNL DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP for (t, x) in enumerate(testSequence): DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '------------------------------------------------------------' DCNL DCSP  DCSP  DCSP  DCSP print ('--------- DCSP sequence: DCSP #%d DCSP of DCSP %d, DCSP timeStep: DCSP #%d DCSP of DCSP %d DCSP -----------' % (sequenceNum, numSequences, t, numTimeSteps)) DCNL DCSP  DCSP  DCSP  DCSP firstTP.printInput(x) DCNL DCSP  DCSP  DCSP  DCSP print 'input DCSP nzs:', x.nonzero() DCNL DCSP  DCSP  DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP  DCSP  DCSP tm.infer(x) DCNL DCSP  DCSP  DCSP assertNoTMDiffs(tms) DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stats = tm.getStats() DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('# DCSP of DCSP unpredicted DCSP columns DCSP for DCSP %s DCSP TM: DCSP %d DCSP of DCSP %d' % (name, stats['curMissing'], x.sum())) DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('I/O DCSP states DCSP of DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '-------------------------------------', DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY >= 5), printLearnState=False) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (VERBOSITY >= 4): DCNL DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP print ('Interim DCSP internal DCSP stats DCSP for DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP  DCSP print '---------------------------------' DCNL DCSP  DCSP  DCSP  DCSP pprint.pprint(tm.getStats()) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP print '\n##############################################################' DCNL DCSP  DCSP print '####################### DCSP Inference DCSP Done DCSP #######################' DCNL DCSP tpStats = dict() DCNL DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP tpStats[name] = stats = tm.getStats() DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print ('Stats DCSP for DCSP %s DCSP TM DCSP over DCSP all DCSP sequences:' % name) DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP total DCSP missing:', stats['totalMissing'] DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP total DCSP extra:', stats['totalExtra'] DCNL DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP print ('\nAll DCSP internal DCSP stats DCSP for DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP print '-------------------------------------', DCNL DCSP  DCSP  DCSP pprint.pprint(tpStats[name]) DCNL DCSP  DCSP  DCSP print DCNL DCSP return tpStats
 DCSP params = dict(baseParams) DCNL DCSP params.update(mods) DCNL DCSP func = params['seqFunction'] DCNL DCSP (numCols, trainingSequences) = func(**params) DCNL DCSP if (params['numCols'] is None): DCNL DCSP  DCSP params['numCols'] = numCols DCNL DCSP tps = createTMs(**params) DCNL DCSP tpStats = evalSequences(tms=tps, trainingSequences=trainingSequences, testSequences=None, **params) DCNL DCSP for (name, stats) in tpStats.iteritems(): DCNL DCSP  DCSP print ('Detected DCSP %d DCSP missing DCSP predictions DCSP overall DCSP during DCSP inference' % stats['totalMissing']) DCNL DCSP  DCSP if ((expMissingMin is not None) and (stats['totalMissing'] < expMissingMin)): DCNL DCSP  DCSP  DCSP print ('FAILURE: DCSP Expected DCSP at DCSP least DCSP %d DCSP total DCSP missing DCSP but DCSP got DCSP %d' % (expMissingMin, stats['totalMissing'])) DCNL DCSP  DCSP  DCSP assert False DCNL DCSP  DCSP if ((expMissingMax is not None) and (stats['totalMissing'] > expMissingMax)): DCNL DCSP  DCSP  DCSP print ('FAILURE: DCSP Expected DCSP at DCSP most DCSP %d DCSP total DCSP missing DCSP but DCSP got DCSP %d' % (expMissingMax, stats['totalMissing'])) DCNL DCSP  DCSP  DCSP assert False DCNL DCSP return True
 DCSP failures = '' DCNL DCSP LOGGER.info('Testing DCSP the DCSP sparse DCSP KNN DCSP Classifier DCSP with DCSP k=3') DCNL DCSP knn = KNNClassifier(k=3) DCNL DCSP v = numpy.zeros((6, 2)) DCNL DCSP v[0] = [1.0, 0.0] DCNL DCSP v[1] = [1.0, 0.2] DCNL DCSP v[2] = [1.0, 0.2] DCNL DCSP v[3] = [1.0, 2.0] DCNL DCSP v[4] = [1.0, 4.0] DCNL DCSP v[5] = [1.0, 4.5] DCNL DCSP knn.learn(v[0], 0) DCNL DCSP knn.learn(v[1], 0) DCNL DCSP knn.learn(v[2], 0) DCNL DCSP knn.learn(v[3], 1) DCNL DCSP knn.learn(v[4], 1) DCNL DCSP knn.learn(v[5], 1) DCNL DCSP (winner, _inferenceResult, _dist, _categoryDist) = knn.infer(v[0]) DCNL DCSP if (winner != 0): DCNL DCSP  DCSP failures += 'Inference DCSP failed DCSP with DCSP k=3\n' DCNL DCSP (winner, _inferenceResult, _dist, _categoryDist) = knn.infer(v[2]) DCNL DCSP if (winner != 0): DCNL DCSP  DCSP failures += 'Inference DCSP failed DCSP with DCSP k=3\n' DCNL DCSP (winner, _inferenceResult, _dist, _categoryDist) = knn.infer(v[3]) DCNL DCSP if (winner != 0): DCNL DCSP  DCSP failures += 'Inference DCSP failed DCSP with DCSP k=3\n' DCNL DCSP (winner, _inferenceResult, _dist, _categoryDist) = knn.infer(v[5]) DCNL DCSP if (winner != 1): DCNL DCSP  DCSP failures += 'Inference DCSP failed DCSP with DCSP k=3\n' DCNL DCSP if (len(failures) == 0): DCNL DCSP  DCSP LOGGER.info('Tests DCSP passed.') DCNL DCSP return failures
 DCSP failures = '' DCNL DCSP numPatterns = len(patternDict) DCNL DCSP LOGGER.info('Training DCSP the DCSP classifier') DCNL DCSP tick = time.time() DCNL DCSP for i in patternDict.keys(): DCNL DCSP  DCSP knn.learn(patternDict[i]['pattern'], patternDict[i]['category']) DCNL DCSP tock = time.time() DCNL DCSP LOGGER.info('Time DCSP Elapsed DCSP %s', (tock - tick)) DCNL DCSP knnString = cPickle.dumps(knn) DCNL DCSP LOGGER.info('Size DCSP of DCSP the DCSP classifier DCSP is DCSP %s', len(knnString)) DCNL DCSP error_count = 0 DCNL DCSP tick = time.time() DCNL DCSP if testDict: DCNL DCSP  DCSP LOGGER.info('Testing DCSP the DCSP classifier DCSP on DCSP the DCSP test DCSP set') DCNL DCSP  DCSP for i in testDict.keys(): DCNL DCSP  DCSP  DCSP (winner, _inferenceResult, _dist, _categoryDist) = knn.infer(testDict[i]['pattern']) DCNL DCSP  DCSP  DCSP if (winner != testDict[i]['category']): DCNL DCSP  DCSP  DCSP  DCSP error_count += 1 DCNL DCSP else: DCNL DCSP  DCSP LOGGER.info('Testing DCSP the DCSP classifier DCSP on DCSP the DCSP training DCSP set') DCNL DCSP  DCSP LOGGER.info('Number DCSP of DCSP patterns: DCSP %s', len(patternDict)) DCNL DCSP  DCSP for i in patternDict.keys(): DCNL DCSP  DCSP  DCSP LOGGER.info('Testing DCSP %s DCSP - DCSP %s DCSP %s', i, patternDict[i]['category'], len(patternDict[i]['pattern'])) DCNL DCSP  DCSP  DCSP (winner, _inferenceResult, _dist, _categoryDist) = knn.infer(patternDict[i]['pattern']) DCNL DCSP  DCSP  DCSP if (winner != patternDict[i]['category']): DCNL DCSP  DCSP  DCSP  DCSP error_count += 1 DCNL DCSP tock = time.time() DCNL DCSP LOGGER.info('Time DCSP Elapsed DCSP %s', (tock - tick)) DCNL DCSP error_rate = (float(error_count) / numPatterns) DCNL DCSP LOGGER.info('Error DCSP rate DCSP is DCSP %s', error_rate) DCNL DCSP if (error_rate == 0): DCNL DCSP  DCSP LOGGER.info((testName + ' DCSP passed')) DCNL DCSP else: DCNL DCSP  DCSP LOGGER.info((testName + ' DCSP failed')) DCNL DCSP  DCSP failures += (testName + ' DCSP failed\n') DCNL DCSP return failures
 DCSP if (short == 0): DCNL DCSP  DCSP LOGGER.info('Running DCSP short DCSP tests') DCNL DCSP  DCSP numPatterns = numpy.random.randint(300, 600) DCNL DCSP  DCSP numClasses = numpy.random.randint(50, 150) DCNL DCSP elif (short == 1): DCNL DCSP  DCSP LOGGER.info('\nRunning DCSP medium DCSP tests') DCNL DCSP  DCSP numPatterns = numpy.random.randint(500, 1500) DCNL DCSP  DCSP numClasses = numpy.random.randint(50, 150) DCNL DCSP else: DCNL DCSP  DCSP LOGGER.info('\nRunning DCSP long DCSP tests') DCNL DCSP  DCSP numPatterns = numpy.random.randint(500, 3000) DCNL DCSP  DCSP numClasses = numpy.random.randint(30, 1000) DCNL DCSP LOGGER.info('number DCSP of DCSP patterns DCSP is DCSP %s', numPatterns) DCNL DCSP LOGGER.info('number DCSP of DCSP classes DCSP is DCSP %s', numClasses) DCNL DCSP return (numPatterns, numClasses)
 DCSP failures = '' DCNL DCSP LOGGER.info('Testing DCSP the DCSP sparse DCSP KNN DCSP Classifier DCSP on DCSP many DCSP disjoint DCSP categories') DCNL DCSP knn = KNNClassifier(k=1, distanceNorm=1.0, useSparseMemory=True) DCNL DCSP for i in range(0, numSamples): DCNL DCSP  DCSP c = ((2 * numpy.random.randint(0, 50)) + 50) DCNL DCSP  DCSP v = createPattern(c, numDimensions) DCNL DCSP  DCSP knn.learn(v, c) DCNL DCSP for i in range(0, 50): DCNL DCSP  DCSP c = ((2 * i) + 50) DCNL DCSP  DCSP v = createPattern(c, numDimensions) DCNL DCSP  DCSP knn.learn(v, c) DCNL DCSP errors = 0 DCNL DCSP for i in range(0, numSamples): DCNL DCSP  DCSP c = ((2 * numpy.random.randint(0, 50)) + 50) DCNL DCSP  DCSP v = createPattern(c, numDimensions) DCNL DCSP  DCSP (inferCat, _kir, _kd, _kcd) = knn.infer(v) DCNL DCSP  DCSP if (inferCat != c): DCNL DCSP  DCSP  DCSP LOGGER.info('Mistake DCSP with DCSP %s DCSP %s DCSP %s DCSP %s DCSP %s', v[v.nonzero()], 'mapped DCSP to DCSP category', inferCat, 'instead DCSP of DCSP category', c) DCNL DCSP  DCSP  DCSP LOGGER.info(' DCSP  DCSP  DCSP %s', v.nonzero()) DCNL DCSP  DCSP  DCSP errors += 1 DCNL DCSP if (errors != 0): DCNL DCSP  DCSP failures += 'Failure DCSP in DCSP handling DCSP non-consecutive DCSP category DCSP indices\n' DCNL DCSP errors = 0 DCNL DCSP for i in range(0, 10): DCNL DCSP  DCSP c = ((2 * numpy.random.randint(0, 50)) + 50) DCNL DCSP  DCSP v = createPattern(c, numDimensions) DCNL DCSP  DCSP p = knn.closestTrainingPattern(v, c) DCNL DCSP  DCSP if (not (c in p.nonzero()[0])): DCNL DCSP  DCSP  DCSP LOGGER.info('Mistake DCSP %s DCSP %s', p.nonzero(), v.nonzero()) DCNL DCSP  DCSP  DCSP LOGGER.info('%s DCSP %s', p[p.nonzero()], v[v.nonzero()]) DCNL DCSP  DCSP  DCSP errors += 1 DCNL DCSP if (errors != 0): DCNL DCSP  DCSP failures += 'Failure DCSP in DCSP closestTrainingPattern DCSP method\n' DCNL DCSP return (failures, knn)
 DCSP v = numpy.zeros(numDimensions) DCNL DCSP v[c] = ((5 * numpy.random.random()) + 10) DCNL DCSP v[(c + 1)] = numpy.random.random() DCNL DCSP if (c > 0): DCNL DCSP  DCSP v[(c - 1)] = numpy.random.random() DCNL DCSP return v
 DCSP handle = tempfile.NamedTemporaryFile(prefix='test', suffix='.csv', dir='.') DCNL DCSP filename = handle.name DCNL DCSP handle.close() DCNL DCSP return filename
 DCSP handle = tempfile.NamedTemporaryFile(prefix='test', suffix='.csv', dir='.') DCNL DCSP filename = handle.name DCNL DCSP handle.close() DCNL DCSP return filename
 DCSP import subprocess DCNL DCSP _debugOut(('Starting...\n<%s>' % (args,))) DCNL DCSP p = subprocess.Popen(args, env=os.environ, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP _debugOut(('Process DCSP started DCSP for DCSP <%s>' % (args,))) DCNL DCSP (stdoutData, stderrData) = p.communicate() DCNL DCSP _debugOut((('Process DCSP completed DCSP for DCSP <%s>: DCSP exit DCSP status=%s, DCSP ' + 'stdoutDataType=%s, DCSP stdoutData=<%s>, DCSP stderrData=<%s>') % (args, p.returncode, type(stdoutData), stdoutData, stderrData))) DCNL DCSP result = dict(exitStatus=p.returncode, stdoutData=stdoutData, stderrData=stderrData) DCNL DCSP _debugOut(('args: DCSP <%s>: DCSP result:\n%s' % (args, pprint.pformat(result, indent=4)))) DCNL DCSP return result
 DCSP import inspect DCNL DCSP frameObj = inspect.stack()[2][0] DCNL DCSP return inspect.getframeinfo(frameObj)
 DCSP _debugOut(('_executeExternalCmdAndReapStdout: DCSP Starting...\n<%s>' % (args,))) DCNL DCSP p = subprocess.Popen(args, env=os.environ, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP _debugOut(('Process DCSP started DCSP for DCSP <%s>' % (args,))) DCNL DCSP (stdoutData, stderrData) = p.communicate() DCNL DCSP _debugOut((('Process DCSP completed DCSP for DCSP <%s>: DCSP exit DCSP status=%s, DCSP ' + 'stdoutDataType=%s, DCSP stdoutData=<%s>, DCSP stderrData=<%s>') % (args, p.returncode, type(stdoutData), stdoutData, stderrData))) DCNL DCSP result = dict(exitStatus=p.returncode, stdoutData=stdoutData, stderrData=stderrData) DCNL DCSP _debugOut(('_executeExternalCmdAndReapStdout DCSP for DCSP <%s>: DCSP result=\n%s' % (args, pprint.pformat(result, indent=4)))) DCNL DCSP return result
 DCSP suiteNames = ['PositiveExperimentTests'] DCNL DCSP testNames = [] DCNL DCSP for suite in suiteNames: DCNL DCSP  DCSP for f in dir(eval(suite)): DCNL DCSP  DCSP  DCSP if f.startswith('test'): DCNL DCSP  DCSP  DCSP  DCSP testNames.append(('%s.%s' % (suite, f))) DCNL DCSP return testNames
 DCSP directoryList = [] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(path): DCNL DCSP  DCSP for d in dirnames[:]: DCNL DCSP  DCSP  DCSP if (d in excludeDirs): DCNL DCSP  DCSP  DCSP  DCSP dirnames.remove(d) DCNL DCSP  DCSP  DCSP  DCSP print ('EXCLUDING DCSP %s...' % os.path.join(dirpath, d)) DCNL DCSP  DCSP  DCSP elif ('UNDER_DEVELOPMENT' in os.listdir(os.path.join(dirpath, d))): DCNL DCSP  DCSP  DCSP  DCSP dirnames.remove(d) DCNL DCSP  DCSP  DCSP  DCSP print ('EXCLUDING DCSP %s...' % os.path.join(dirpath, d)) DCNL DCSP  DCSP for f in filenames: DCNL DCSP  DCSP  DCSP if (f == filename): DCNL DCSP  DCSP  DCSP  DCSP directoryList.append(dirpath) DCNL DCSP return directoryList
 DCSP excludedDirectories = ['exp', 'inference', 'networks', 'legacy'] DCNL DCSP excludedDirectories.extend(excludedExperiments) DCNL DCSP return getAllDirectoriesWithFile(path='experiments', filename='description.py', excludeDirs=excludedDirectories)
 DCSP initExperimentPrng() DCNL DCSP if reduced: DCNL DCSP  DCSP args = [path, '--testMode'] DCNL DCSP else: DCNL DCSP  DCSP args = [path] DCNL DCSP runExperiment(args)
 DCSP tmpDir = tempfile.mkdtemp() DCNL DCSP tmpFileName = os.path.join(tmpDir, os.path.basename(filename)) DCNL DCSP return (tmpDir, tmpFileName)
 DCSP encoder = MultiEncoder() DCNL DCSP encoder.addMultipleEncoders({'timestamp': dict(fieldname='timestamp', type='DateEncoder', timeOfDay=(5, 5), forced=True), 'attendeeCount': dict(fieldname='attendeeCount', type='ScalarEncoder', name='attendeeCount', minval=0, maxval=270, clipInput=True, w=5, resolution=10, forced=True), 'consumption': dict(fieldname='consumption', type='ScalarEncoder', name='consumption', minval=0, maxval=115, clipInput=True, w=5, resolution=5, forced=True)}) DCNL DCSP return encoder
 DCSP sensorParams = dict(verbosity=_VERBOSITY) DCNL DCSP encoder = _createEncoder() DCNL DCSP trainFile = resource_filename('nupic.datafiles', 'extra/gym/gym.csv') DCNL DCSP dataSource = FileRecordStream(streamID=trainFile) DCNL DCSP dataSource.setAutoRewind(True) DCNL DCSP n = Network() DCNL DCSP n.addRegion('sensor', 'py.RecordSensor', json.dumps(sensorParams)) DCNL DCSP sensor = n.regions['sensor'].getSelf() DCNL DCSP sensor.encoder = encoder DCNL DCSP sensor.dataSource = dataSource DCNL DCSP if addSP: DCNL DCSP  DCSP print 'Adding DCSP SPRegion' DCNL DCSP  DCSP g_spRegionConfig['inputWidth'] = encoder.getWidth() DCNL DCSP  DCSP n.addRegion('level1SP', 'py.SPRegion', json.dumps(g_spRegionConfig)) DCNL DCSP  DCSP n.link('sensor', 'level1SP', 'UniformLink', '') DCNL DCSP  DCSP n.link('sensor', 'level1SP', 'UniformLink', '', srcOutput='resetOut', destInput='resetIn') DCNL DCSP  DCSP n.link('level1SP', 'sensor', 'UniformLink', '', srcOutput='spatialTopDownOut', destInput='spatialTopDownIn') DCNL DCSP  DCSP n.link('level1SP', 'sensor', 'UniformLink', '', srcOutput='temporalTopDownOut', destInput='temporalTopDownIn') DCNL DCSP if (addTP and addSP): DCNL DCSP  DCSP print 'Adding DCSP TMRegion DCSP on DCSP top DCSP of DCSP SP' DCNL DCSP  DCSP g_tpRegionConfig['inputWidth'] = g_spRegionConfig['columnCount'] DCNL DCSP  DCSP n.addRegion('level1TP', 'py.TMRegion', json.dumps(g_tpRegionConfig)) DCNL DCSP  DCSP n.link('level1SP', 'level1TP', 'UniformLink', '') DCNL DCSP  DCSP n.link('level1TP', 'level1SP', 'UniformLink', '', srcOutput='topDownOut', destInput='topDownIn') DCNL DCSP  DCSP n.link('sensor', 'level1TP', 'UniformLink', '', srcOutput='resetOut', destInput='resetIn') DCNL DCSP elif addTP: DCNL DCSP  DCSP print 'Adding DCSP TMRegion' DCNL DCSP  DCSP g_tpRegionConfig['inputWidth'] = encoder.getWidth() DCNL DCSP  DCSP n.addRegion('level1TP', 'py.TMRegion', json.dumps(g_tpRegionConfig)) DCNL DCSP  DCSP n.link('sensor', 'level1TP', 'UniformLink', '') DCNL DCSP  DCSP n.link('sensor', 'level1TP', 'UniformLink', '', srcOutput='resetOut', destInput='resetIn') DCNL DCSP return n
 DCSP aggregator = Aggregator(aggregationInfo=options, inputFields=input.getFields(), timeFieldName=timeFieldName) DCNL DCSP while True: DCNL DCSP  DCSP inRecord = input.getNextRecord() DCNL DCSP  DCSP print 'Feeding DCSP in: DCSP ', inRecord DCNL DCSP  DCSP (outRecord, aggBookmark) = aggregator.next(record=inRecord, curInputBookmark=None) DCNL DCSP  DCSP print 'Record DCSP out: DCSP ', outRecord DCNL DCSP  DCSP if (outRecord is not None): DCNL DCSP  DCSP  DCSP output.appendRecord(outRecord, None) DCNL DCSP  DCSP if ((inRecord is None) and (outRecord is None)): DCNL DCSP  DCSP  DCSP break
 DCSP consumption_encoder = ScalarEncoder(21, 0.0, 100.0, n=50, name='consumption', clipInput=True) DCNL DCSP time_encoder = DateEncoder(timeOfDay=(21, 9.5), name='timestamp_timeOfDay') DCNL DCSP encoder = MultiEncoder() DCNL DCSP encoder.addEncoder('consumption', consumption_encoder) DCNL DCSP encoder.addEncoder('timestamp', time_encoder) DCNL DCSP return encoder
 DCSP network = Network() DCNL DCSP network.addRegion('sensor', 'py.RecordSensor', json.dumps({'verbosity': _VERBOSITY})) DCNL DCSP sensor = network.regions['sensor'].getSelf() DCNL DCSP sensor.encoder = createEncoder() DCNL DCSP sensor.dataSource = dataSource DCNL DCSP SP_PARAMS['inputWidth'] = sensor.encoder.getWidth() DCNL DCSP network.addRegion('spatialPoolerRegion', 'py.SPRegion', json.dumps(SP_PARAMS)) DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '') DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='resetOut', destInput='resetIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='spatialTopDownOut', destInput='spatialTopDownIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='temporalTopDownOut', destInput='temporalTopDownIn') DCNL DCSP if enableTP: DCNL DCSP  DCSP TM_PARAMS['temporalImp'] = temporalImp DCNL DCSP  DCSP network.addRegion('temporalPoolerRegion', 'py.TMRegion', json.dumps(TM_PARAMS)) DCNL DCSP  DCSP network.link('spatialPoolerRegion', 'temporalPoolerRegion', 'UniformLink', '') DCNL DCSP  DCSP network.link('temporalPoolerRegion', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='topDownOut', destInput='topDownIn') DCNL DCSP spatialPoolerRegion = network.regions['spatialPoolerRegion'] DCNL DCSP spatialPoolerRegion.setParameter('learningMode', True) DCNL DCSP spatialPoolerRegion.setParameter('anomalyMode', False) DCNL DCSP if enableTP: DCNL DCSP  DCSP temporalPoolerRegion = network.regions['temporalPoolerRegion'] DCNL DCSP  DCSP temporalPoolerRegion.setParameter('topDownMode', True) DCNL DCSP  DCSP temporalPoolerRegion.setParameter('learningMode', True) DCNL DCSP  DCSP temporalPoolerRegion.setParameter('inferenceMode', True) DCNL DCSP  DCSP temporalPoolerRegion.setParameter('anomalyMode', True) DCNL DCSP return network
 DCSP if params.has_key('name'): DCNL DCSP  DCSP if (params['name'] == 'normal'): DCNL DCSP  DCSP  DCSP samples = numpy.random.normal(loc=params['mean'], scale=math.sqrt(params['variance']), size=numSamples) DCNL DCSP  DCSP elif (params['name'] == 'pareto'): DCNL DCSP  DCSP  DCSP samples = numpy.random.pareto(params['alpha'], size=numSamples) DCNL DCSP  DCSP elif (params['name'] == 'beta'): DCNL DCSP  DCSP  DCSP samples = numpy.random.beta(a=params['alpha'], b=params['beta'], size=numSamples) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('Undefined DCSP distribution: DCSP ' + params['name'])) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Bad DCSP distribution DCSP params: DCSP ' + str(params))) DCNL DCSP if (verbosity > 0): DCNL DCSP  DCSP print '\nSampling DCSP from DCSP distribution:', params DCNL DCSP  DCSP print 'After DCSP estimation, DCSP mean=', numpy.mean(samples), 'var=', numpy.var(samples), 'stdev=', math.sqrt(numpy.var(samples)) DCNL DCSP return samples
 DCSP data = [] DCNL DCSP p = {'mean': mean, 'name': 'normal', 'stdev': math.sqrt(variance), 'variance': variance} DCNL DCSP samples = _sampleDistribution(p, 1440) DCNL DCSP p = {'mean': metricMean, 'name': 'normal', 'stdev': math.sqrt(metricVariance), 'variance': metricVariance} DCNL DCSP metricValues = _sampleDistribution(p, 1440) DCNL DCSP for hour in range(0, 24): DCNL DCSP  DCSP for minute in range(0, 60): DCNL DCSP  DCSP  DCSP data.append([datetime.datetime(2013, 2, 2, hour, minute, 0), metricValues[((hour * 60) + minute)], samples[((hour * 60) + minute)]]) DCNL DCSP return data
 DCSP dateList = [] DCNL DCSP td = datetime.timedelta(minutes=1) DCNL DCSP curDate = (startDatetime + td) DCNL DCSP for _ in range(numSamples): DCNL DCSP  DCSP dateList.append(curDate) DCNL DCSP  DCSP curDate = (curDate + td) DCNL DCSP return dateList
 DCSP print ''.join((('1' if (k != 0) else '.') for k in x))
 DCSP numCols = (numOnes * numPatterns) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = np.zeros(numCols, dtype='float32') DCNL DCSP  DCSP x[(i * numOnes):((i + 1) * numOnes)] = 1 DCNL DCSP  DCSP p.append(x) DCNL DCSP return p
 DCSP minThreshold = 4 DCNL DCSP activationThreshold = 5 DCNL DCSP newSynapseCount = 7 DCNL DCSP initialPerm = 0.3 DCNL DCSP connectedPerm = 0.5 DCNL DCSP permanenceInc = 0.1 DCNL DCSP permanenceDec = 0.05 DCNL DCSP globalDecay = 0 DCNL DCSP cellsPerColumn = 1 DCNL DCSP cppTm = BacktrackingTMCPP(numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=_SEED, verbosity=VERBOSITY, checkSynapseConsistency=True, pamLength=1000) DCNL DCSP cppTm.retrieveLearningStates = True DCNL DCSP pyTm = BacktrackingTM(numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=_SEED, verbosity=VERBOSITY, pamLength=1000) DCNL DCSP return (cppTm, pyTm)
 DCSP return ((x + y) == 2).sum()
 DCSP for (k1, v1) in sdrDict.iteritems(): DCNL DCSP  DCSP for (k2, v2) in sdrDict.iteritems(): DCNL DCSP  DCSP  DCSP if ((k2 != k1) and ((v1 == v2).sum() == v1.size)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP for c in range(tm.numberOfCols): DCNL DCSP  DCSP assert (tm.getNumSegmentsInCell(c, 0) == 0)
 DCSP tm.cells4.setVerbosity(verbosity) DCNL DCSP tm.verbosity = verbosity DCNL DCSP tmPy.verbosity = verbosity
 DCSP network = Network() DCNL DCSP network.addRegion('sensor', 'py.RecordSensor', '{}') DCNL DCSP sensorRegion = network.regions['sensor'].getSelf() DCNL DCSP encoderParams = {'consumption': {'fieldname': 'consumption', 'resolution': 0.88, 'seed': 1, 'name': 'consumption', 'type': 'RandomDistributedScalarEncoder'}} DCNL DCSP encoder = MultiEncoder() DCNL DCSP encoder.addMultipleEncoders(encoderParams) DCNL DCSP sensorRegion.encoder = encoder DCNL DCSP testDir = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP inputFile = os.path.join(testDir, 'fixtures', 'gymdata-test.csv') DCNL DCSP dataSource = FileRecordStream(streamID=inputFile) DCNL DCSP sensorRegion.dataSource = dataSource DCNL DCSP network.regions['sensor'].setParameter('predictedField', 'consumption') DCNL DCSP return network
 DCSP network = Network() DCNL DCSP network.addRegion('sensor', 'py.RecordSensor', '{}') DCNL DCSP network.addRegion('classifier', 'py.SDRClassifierRegion', '{}') DCNL DCSP _createSensorToClassifierLinks(network, 'sensor', 'classifier') DCNL DCSP sensorRegion = network.regions['sensor'].getSelf() DCNL DCSP encoderParams = {'consumption': {'fieldname': 'consumption', 'resolution': 0.88, 'seed': 1, 'name': 'consumption', 'type': 'RandomDistributedScalarEncoder'}} DCNL DCSP encoder = MultiEncoder() DCNL DCSP encoder.addMultipleEncoders(encoderParams) DCNL DCSP sensorRegion.encoder = encoder DCNL DCSP testDir = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP inputFile = os.path.join(testDir, 'fixtures', 'gymdata-test.csv') DCNL DCSP dataSource = FileRecordStream(streamID=inputFile) DCNL DCSP sensorRegion.dataSource = dataSource DCNL DCSP network.regions['sensor'].setParameter('predictedField', 'consumption') DCNL DCSP return network
 DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='bucketIdxOut', destInput='bucketIdxIn') DCNL DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='actValueOut', destInput='actValueIn') DCNL DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='categoryOut', destInput='categoryIn') DCNL DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='dataOut', destInput='bottomUpIn')
 DCSP return (x & y).sum()
 DCSP for i in range(encoder.minIndex, (encoder.maxIndex + 1), 1): DCNL DCSP  DCSP for j in range((i + 1), (encoder.maxIndex + 1), subsampling): DCNL DCSP  DCSP  DCSP if (not encoder._overlapOK(i, j)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP encoder = CoordinateEncoder(name='coordinate', n=n, w=w) DCNL DCSP overlaps = np.empty(num) DCNL DCSP outputA = encode(encoder, np.array(initPosition), initRadius) DCNL DCSP for i in range(num): DCNL DCSP  DCSP newPosition = (initPosition if (dPosition is None) else (initPosition + ((i + 1) * dPosition))) DCNL DCSP  DCSP newRadius = (initRadius + ((i + 1) * dRadius)) DCNL DCSP  DCSP outputB = encode(encoder, newPosition, newRadius) DCNL DCSP  DCSP overlaps[i] = overlap(outputA, outputB) DCNL DCSP if verbose: DCNL DCSP  DCSP print DCNL DCSP  DCSP print '===== DCSP Relative DCSP encoding DCSP overlaps DCSP (n DCSP = DCSP {0}, DCSP w DCSP = DCSP {1}, DCSP initPosition DCSP = DCSP {2}, DCSP initRadius DCSP = DCSP {3}, DCSP dPosition DCSP = DCSP {4}, DCSP dRadius DCSP = DCSP {5}) DCSP ====='.format(n, w, initPosition, initRadius, dPosition, dRadius) DCNL DCSP  DCSP print 'Average: DCSP {0}'.format(np.average(overlaps)) DCNL DCSP  DCSP print 'Max: DCSP {0}'.format(np.max(overlaps)) DCNL DCSP return overlaps
 DCSP return overlapsForRelativeAreas(n, w, np.array([0, 0]), radius, dPosition=np.array([0, (radius * 10)]), num=repetitions, verbose=verbose)
 DCSP sys.path.insert(0, os.path.join(examplesDir, exampleName)) DCNL DCSP modName = ('complete-%s-example' % exampleName) DCNL DCSP mod = __import__(modName, fromlist=['runHotgym']) DCNL DCSP return getattr(mod, 'runHotgym')
 DCSP handle = tempfile.NamedTemporaryFile(prefix='test', suffix='.txt', dir='.') DCNL DCSP filename = handle.name DCNL DCSP handle.close() DCNL DCSP return filename
 DCSP try: DCNL DCSP  DCSP return _timedelta_cache[seconds] DCNL DCSP except KeyError: DCNL DCSP  DCSP delta = timedelta(seconds=seconds) DCNL DCSP  DCSP _timedelta_cache[seconds] = delta DCNL DCSP  DCSP return delta
 DCSP try: DCNL DCSP  DCSP return _datetime_cache[seconds] DCNL DCSP except KeyError: DCNL DCSP  DCSP dt = (_epoch + timedelta(seconds=seconds)) DCNL DCSP  DCSP _datetime_cache[seconds] = dt DCNL DCSP  DCSP return dt
 DCSP try: DCNL DCSP  DCSP return _ttinfo_cache[args] DCNL DCSP except KeyError: DCNL DCSP  DCSP ttinfo = (memorized_timedelta(args[0]), memorized_timedelta(args[1]), args[2]) DCNL DCSP  DCSP _ttinfo_cache[args] = ttinfo DCNL DCSP  DCSP return ttinfo
 DCSP return (td.seconds + (((td.days * 24) * 60) * 60))
 DCSP tz = pytz.timezone(zone) DCNL DCSP if (utcoffset is None): DCNL DCSP  DCSP return tz DCNL DCSP utcoffset = memorized_timedelta(utcoffset) DCNL DCSP dstoffset = memorized_timedelta(dstoffset) DCNL DCSP try: DCNL DCSP  DCSP return tz._tzinfos[(utcoffset, dstoffset, tzname)] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP for localized_tz in tz._tzinfos.values(): DCNL DCSP  DCSP if ((localized_tz._utcoffset == utcoffset) and (localized_tz._dst == dstoffset)): DCNL DCSP  DCSP  DCSP return localized_tz DCNL DCSP inf = (utcoffset, dstoffset, tzname) DCNL DCSP tz._tzinfos[inf] = tz.__class__(inf, tz._tzinfos) DCNL DCSP return tz._tzinfos[inf]
 DCSP if (resource_stream is not None): DCNL DCSP  DCSP return resource_stream(__name__, ('zoneinfo/' + name)) DCNL DCSP else: DCNL DCSP  DCSP name_parts = name.lstrip('/').split('/') DCNL DCSP  DCSP for part in name_parts: DCNL DCSP  DCSP  DCSP if ((part == os.path.pardir) or (os.path.sep in part)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Bad DCSP path DCSP segment: DCSP %r' % part)) DCNL DCSP  DCSP filename = os.path.join(os.path.dirname(__file__), 'zoneinfo', *name_parts) DCNL DCSP  DCSP return open(filename, 'rb')
 DCSP if (zone.upper() == 'UTC'): DCNL DCSP  DCSP return utc DCNL DCSP try: DCNL DCSP  DCSP zone = zone.encode('US-ASCII') DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP raise UnknownTimeZoneError(zone) DCNL DCSP zone = _unmunge_zone(zone) DCNL DCSP if (zone not in _tzinfo_cache): DCNL DCSP  DCSP if (zone in all_timezones_set): DCNL DCSP  DCSP  DCSP _tzinfo_cache[zone] = build_tzinfo(zone, open_resource(zone)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise UnknownTimeZoneError(zone) DCNL DCSP return _tzinfo_cache[zone]
 DCSP return zone.replace('_plus_', '+').replace('_minus_', '-')
 DCSP return utc
 DCSP return unpickler(*args)
 DCSP iso3166_code = iso3166_code.upper() DCNL DCSP if (not _country_timezones_cache): DCNL DCSP  DCSP zone_tab = open_resource('zone.tab') DCNL DCSP  DCSP for line in zone_tab: DCNL DCSP  DCSP  DCSP if line.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP (code, coordinates, zone) = line.split(None, 4)[:3] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _country_timezones_cache[code].append(zone) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP _country_timezones_cache[code] = [zone] DCNL DCSP return _country_timezones_cache[iso3166_code]
 DCSP if (offset == 0): DCNL DCSP  DCSP return UTC DCNL DCSP info = _tzinfos.get(offset) DCNL DCSP if (info is None): DCNL DCSP  DCSP info = _tzinfos.setdefault(offset, _FixedOffset(offset)) DCNL DCSP return info
 DCSP plat = get_build_platform() DCNL DCSP m = macosVersionString.match(plat) DCNL DCSP if ((m is not None) and (sys.platform == 'darwin')): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP plat = ('macosx-%s-%s' % ('.'.join(_macosx_vers()[:2]), m.group(3))) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return plat
 DCSP _provider_factories[loader_type] = provider_factory
 DCSP if isinstance(moduleOrReq, Requirement): DCNL DCSP  DCSP return (working_set.find(moduleOrReq) or require(str(moduleOrReq))[0]) DCNL DCSP try: DCNL DCSP  DCSP module = sys.modules[moduleOrReq] DCNL DCSP except KeyError: DCNL DCSP  DCSP __import__(moduleOrReq) DCNL DCSP  DCSP module = sys.modules[moduleOrReq] DCNL DCSP loader = getattr(module, '__loader__', None) DCNL DCSP return _find_adapter(_provider_factories, loader)(module)
 DCSP from distutils.util import get_platform DCNL DCSP plat = get_platform() DCNL DCSP if ((sys.platform == 'darwin') and (not plat.startswith('macosx-'))): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP version = _macosx_vers() DCNL DCSP  DCSP  DCSP machine = os.uname()[4].replace(' DCSP ', '_') DCNL DCSP  DCSP  DCSP return ('macosx-%d.%d-%s' % (int(version[0]), int(version[1]), _macosx_arch(machine))) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return plat
 DCSP if ((provided is None) or (required is None) or (provided == required)): DCNL DCSP  DCSP return True DCNL DCSP reqMac = macosVersionString.match(required) DCNL DCSP if reqMac: DCNL DCSP  DCSP provMac = macosVersionString.match(provided) DCNL DCSP  DCSP if (not provMac): DCNL DCSP  DCSP  DCSP provDarwin = darwinVersionString.match(provided) DCNL DCSP  DCSP  DCSP if provDarwin: DCNL DCSP  DCSP  DCSP  DCSP dversion = int(provDarwin.group(1)) DCNL DCSP  DCSP  DCSP  DCSP macosversion = ('%s.%s' % (reqMac.group(1), reqMac.group(2))) DCNL DCSP  DCSP  DCSP  DCSP if (((dversion == 7) and (macosversion >= '10.3')) or ((dversion == 8) and (macosversion >= '10.4'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if ((provMac.group(1) != reqMac.group(1)) or (provMac.group(3) != reqMac.group(3))): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (int(provMac.group(2)) > int(reqMac.group(2))): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP ns = sys._getframe(1).f_globals DCNL DCSP name = ns['__name__'] DCNL DCSP ns.clear() DCNL DCSP ns['__name__'] = name DCNL DCSP require(dist_spec)[0].run_script(script_name, ns)
 DCSP if isinstance(dist, basestring): DCNL DCSP  DCSP dist = Requirement.parse(dist) DCNL DCSP if isinstance(dist, Requirement): DCNL DCSP  DCSP dist = get_provider(dist) DCNL DCSP if (not isinstance(dist, Distribution)): DCNL DCSP  DCSP raise TypeError('Expected DCSP string, DCSP Requirement, DCSP or DCSP Distribution', dist) DCNL DCSP return dist
 DCSP return get_distribution(dist).load_entry_point(group, name)
 DCSP return get_distribution(dist).get_entry_map(group)
 DCSP return get_distribution(dist).get_entry_info(group, name)
 DCSP try: DCNL DCSP  DCSP return os.environ['PYTHON_EGG_CACHE'] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP if (os.name != 'nt'): DCNL DCSP  DCSP return os.path.expanduser('~/.python-eggs') DCNL DCSP app_data = 'Application DCSP Data' DCNL DCSP app_homes = [(('APPDATA',), None), (('USERPROFILE',), app_data), (('HOMEDRIVE', 'HOMEPATH'), app_data), (('HOMEPATH',), app_data), (('HOME',), None), (('WINDIR',), app_data)] DCNL DCSP for (keys, subdir) in app_homes: DCNL DCSP  DCSP dirname = '' DCNL DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP if (key in os.environ): DCNL DCSP  DCSP  DCSP  DCSP dirname = os.path.join(dirname, os.environ[key]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if subdir: DCNL DCSP  DCSP  DCSP  DCSP dirname = os.path.join(dirname, subdir) DCNL DCSP  DCSP  DCSP return os.path.join(dirname, 'Python-Eggs') DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('Please DCSP set DCSP the DCSP PYTHON_EGG_CACHE DCSP enviroment DCSP variable')
 DCSP return re.sub('[^A-Za-z0-9.]+', '-', name)
 DCSP version = version.replace(' DCSP ', '.') DCNL DCSP return re.sub('[^A-Za-z0-9.]+', '-', version)
 DCSP return re.sub('[^A-Za-z0-9.]+', '_', extra).lower()
 DCSP return name.replace('-', '_')
 DCSP try: DCNL DCSP  DCSP importer = sys.path_importer_cache[path_item] DCNL DCSP except KeyError: DCNL DCSP  DCSP for hook in sys.path_hooks: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP importer = hook(path_item) DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP importer = None DCNL DCSP sys.path_importer_cache.setdefault(path_item, importer) DCNL DCSP if (importer is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP importer = ImpWrapper(path_item) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return importer
 DCSP _distribution_finders[importer_type] = distribution_finder
 DCSP importer = get_importer(path_item) DCNL DCSP finder = _find_adapter(_distribution_finders, importer) DCNL DCSP return finder(importer, path_item, only)
 DCSP global StringIO DCNL DCSP try: DCNL DCSP  DCSP from cStringIO import StringIO DCNL DCSP except ImportError: DCNL DCSP  DCSP from StringIO import StringIO DCNL DCSP return StringIO(*args, **kw)
 DCSP path_item = _normalize_cached(path_item) DCNL DCSP if os.path.isdir(path_item): DCNL DCSP  DCSP if path_item.lower().endswith('.egg'): DCNL DCSP  DCSP  DCSP (yield Distribution.from_filename(path_item, metadata=PathMetadata(path_item, os.path.join(path_item, 'EGG-INFO')))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for entry in os.listdir(path_item): DCNL DCSP  DCSP  DCSP  DCSP lower = entry.lower() DCNL DCSP  DCSP  DCSP  DCSP if lower.endswith('.egg-info'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fullpath = os.path.join(path_item, entry) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.isdir(fullpath): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metadata = PathMetadata(path_item, fullpath) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metadata = FileMetadata(fullpath) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield Distribution.from_location(path_item, entry, metadata, precedence=DEVELOP_DIST)) DCNL DCSP  DCSP  DCSP  DCSP elif ((not only) and lower.endswith('.egg')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for dist in find_distributions(os.path.join(path_item, entry)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yield dist) DCNL DCSP  DCSP  DCSP  DCSP elif ((not only) and lower.endswith('.egg-link')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for line in file(os.path.join(path_item, entry)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not line.strip()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for item in find_distributions(os.path.join(path_item, line.rstrip())): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yield item) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break
 DCSP _namespace_handlers[importer_type] = namespace_handler
 DCSP importer = get_importer(path_item) DCNL DCSP if (importer is None): DCNL DCSP  DCSP return None DCNL DCSP loader = importer.find_module(packageName) DCNL DCSP if (loader is None): DCNL DCSP  DCSP return None DCNL DCSP module = sys.modules.get(packageName) DCNL DCSP if (module is None): DCNL DCSP  DCSP module = sys.modules[packageName] = new.module(packageName) DCNL DCSP  DCSP module.__path__ = [] DCNL DCSP  DCSP _set_parent_ns(packageName) DCNL DCSP elif (not hasattr(module, '__path__')): DCNL DCSP  DCSP raise TypeError('Not DCSP a DCSP package:', packageName) DCNL DCSP handler = _find_adapter(_namespace_handlers, importer) DCNL DCSP subpath = handler(importer, path_item, packageName, module) DCNL DCSP if (subpath is not None): DCNL DCSP  DCSP path = module.__path__ DCNL DCSP  DCSP path.append(subpath) DCNL DCSP  DCSP loader.load_module(packageName) DCNL DCSP  DCSP module.__path__ = path DCNL DCSP return subpath
 DCSP imp.acquire_lock() DCNL DCSP try: DCNL DCSP  DCSP if (packageName in _namespace_packages): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP (path, parent) = (sys.path, None) DCNL DCSP  DCSP if ('.' in packageName): DCNL DCSP  DCSP  DCSP parent = '.'.join(packageName.split('.')[:(-1)]) DCNL DCSP  DCSP  DCSP declare_namespace(parent) DCNL DCSP  DCSP  DCSP __import__(parent) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP path = sys.modules[parent].__path__ DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP raise TypeError('Not DCSP a DCSP package:', parent) DCNL DCSP  DCSP _namespace_packages.setdefault(parent, []).append(packageName) DCNL DCSP  DCSP _namespace_packages.setdefault(packageName, []) DCNL DCSP  DCSP for path_item in path: DCNL DCSP  DCSP  DCSP _handle_ns(packageName, path_item) DCNL DCSP finally: DCNL DCSP  DCSP imp.release_lock()
 DCSP imp.acquire_lock() DCNL DCSP try: DCNL DCSP  DCSP for package in _namespace_packages.get(parent, ()): DCNL DCSP  DCSP  DCSP subpath = _handle_ns(package, path_item) DCNL DCSP  DCSP  DCSP if subpath: DCNL DCSP  DCSP  DCSP  DCSP fixup_namespace_packages(subpath, package) DCNL DCSP finally: DCNL DCSP  DCSP imp.release_lock()
 DCSP subpath = os.path.join(path_item, packageName.split('.')[(-1)]) DCNL DCSP normalized = _normalize_cached(subpath) DCNL DCSP for item in module.__path__: DCNL DCSP  DCSP if (_normalize_cached(item) == normalized): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return subpath
 DCSP return os.path.normcase(os.path.realpath(filename))
 DCSP if isinstance(strs, basestring): DCNL DCSP  DCSP for s in strs.splitlines(): DCNL DCSP  DCSP  DCSP s = s.strip() DCNL DCSP  DCSP  DCSP if (s and (not s.startswith('#'))): DCNL DCSP  DCSP  DCSP  DCSP (yield s) DCNL DCSP else: DCNL DCSP  DCSP for ss in strs: DCNL DCSP  DCSP  DCSP for s in yield_lines(ss): DCNL DCSP  DCSP  DCSP  DCSP (yield s)
 DCSP parts = [] DCNL DCSP for part in _parse_version_parts(s.lower()): DCNL DCSP  DCSP if part.startswith('*'): DCNL DCSP  DCSP  DCSP if (part < '*final'): DCNL DCSP  DCSP  DCSP  DCSP while (parts and (parts[(-1)] == '*final-')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parts.pop() DCNL DCSP  DCSP  DCSP while (parts and (parts[(-1)] == '00000000')): DCNL DCSP  DCSP  DCSP  DCSP parts.pop() DCNL DCSP  DCSP parts.append(part) DCNL DCSP return tuple(parts)
 DCSP lines = iter(yield_lines(strs)) DCNL DCSP def scan_list(ITEM, TERMINATOR, line, p, groups, item_name): DCNL DCSP  DCSP items = [] DCNL DCSP  DCSP while (not TERMINATOR(line, p)): DCNL DCSP  DCSP  DCSP if CONTINUE(line, p): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP line = lines.next() DCNL DCSP  DCSP  DCSP  DCSP  DCSP p = 0 DCNL DCSP  DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('\\ DCSP must DCSP not DCSP appear DCSP on DCSP the DCSP last DCSP nonblank DCSP line') DCNL DCSP  DCSP  DCSP match = ITEM(line, p) DCNL DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError((('Expected DCSP ' + item_name) + ' DCSP in'), line, 'at', line[p:]) DCNL DCSP  DCSP  DCSP items.append(match.group(*groups)) DCNL DCSP  DCSP  DCSP p = match.end() DCNL DCSP  DCSP  DCSP match = COMMA(line, p) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP p = match.end() DCNL DCSP  DCSP  DCSP elif (not TERMINATOR(line, p)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError("Expected DCSP ',' DCSP or DCSP end-of-list DCSP in", line, 'at', line[p:]) DCNL DCSP  DCSP match = TERMINATOR(line, p) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP p = match.end() DCNL DCSP  DCSP return (line, p, items) DCNL DCSP for line in lines: DCNL DCSP  DCSP match = DISTRO(line) DCNL DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP raise ValueError('Missing DCSP distribution DCSP spec', line) DCNL DCSP  DCSP project_name = match.group(1) DCNL DCSP  DCSP p = match.end() DCNL DCSP  DCSP extras = [] DCNL DCSP  DCSP match = OBRACKET(line, p) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP p = match.end() DCNL DCSP  DCSP  DCSP (line, p, extras) = scan_list(DISTRO, CBRACKET, line, p, (1,), "'extra' DCSP name") DCNL DCSP  DCSP (line, p, specs) = scan_list(VERSION, LINE_END, line, p, (1, 2), 'version DCSP spec') DCNL DCSP  DCSP specs = [(op, safe_version(val)) for (op, val) in specs] DCNL DCSP  DCSP (yield Requirement(project_name, specs, extras))
 DCSP if (not isinstance(cls, type)): DCNL DCSP  DCSP class cls(cls, object, ): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return cls.__mro__[1:] DCNL DCSP return cls.__mro__
 DCSP for t in _get_mro(getattr(ob, '__class__', type(ob))): DCNL DCSP  DCSP if (t in registry): DCNL DCSP  DCSP  DCSP return registry[t]
 DCSP dirname = os.path.dirname(path) DCNL DCSP if (not os.path.isdir(dirname)): DCNL DCSP  DCSP os.makedirs(dirname)
 DCSP section = None DCNL DCSP content = [] DCNL DCSP for line in yield_lines(s): DCNL DCSP  DCSP if line.startswith('['): DCNL DCSP  DCSP  DCSP if line.endswith(']'): DCNL DCSP  DCSP  DCSP  DCSP if (section or content): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (section, content)) DCNL DCSP  DCSP  DCSP  DCSP section = line[1:(-1)].strip() DCNL DCSP  DCSP  DCSP  DCSP content = [] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Invalid DCSP section DCSP heading', line) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP content.append(line) DCNL DCSP (yield (section, content))
 DCSP if (cellText is None): DCNL DCSP  DCSP rows = len(cellColours) DCNL DCSP  DCSP cols = len(cellColours[0]) DCNL DCSP  DCSP cellText = ([([''] * rows)] * cols) DCNL DCSP rows = len(cellText) DCNL DCSP cols = len(cellText[0]) DCNL DCSP for row in cellText: DCNL DCSP  DCSP assert (len(row) == cols) DCNL DCSP if (cellColours is not None): DCNL DCSP  DCSP assert (len(cellColours) == rows) DCNL DCSP  DCSP for row in cellColours: DCNL DCSP  DCSP  DCSP assert (len(row) == cols) DCNL DCSP else: DCNL DCSP  DCSP cellColours = ([('w' * cols)] * rows) DCNL DCSP if (colWidths is None): DCNL DCSP  DCSP colWidths = ([(1.0 / cols)] * cols) DCNL DCSP rowLabelWidth = 0 DCNL DCSP if (rowLabels is None): DCNL DCSP  DCSP if (rowColours is not None): DCNL DCSP  DCSP  DCSP rowLabels = ([''] * cols) DCNL DCSP  DCSP  DCSP rowLabelWidth = colWidths[0] DCNL DCSP elif (rowColours is None): DCNL DCSP  DCSP rowColours = ('w' * rows) DCNL DCSP if (rowLabels is not None): DCNL DCSP  DCSP assert (len(rowLabels) == rows) DCNL DCSP offset = 0 DCNL DCSP if (colLabels is None): DCNL DCSP  DCSP if (colColours is not None): DCNL DCSP  DCSP  DCSP colLabels = ([''] * rows) DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP elif (colColours is None): DCNL DCSP  DCSP colColours = ('w' * cols) DCNL DCSP  DCSP offset = 1 DCNL DCSP if (rowLabels is not None): DCNL DCSP  DCSP assert (len(rowLabels) == rows) DCNL DCSP if (cellColours is None): DCNL DCSP  DCSP cellColours = ([('w' * cols)] * rows) DCNL DCSP table = Table(ax, loc, bbox) DCNL DCSP height = table._approx_text_height() DCNL DCSP for row in xrange(rows): DCNL DCSP  DCSP for col in xrange(cols): DCNL DCSP  DCSP  DCSP table.add_cell((row + offset), col, width=colWidths[col], height=height, text=cellText[row][col], facecolor=cellColours[row][col], loc=cellLoc) DCNL DCSP if (colLabels is not None): DCNL DCSP  DCSP for col in xrange(cols): DCNL DCSP  DCSP  DCSP table.add_cell(0, col, width=colWidths[col], height=height, text=colLabels[col], facecolor=colColours[col], loc=colLoc) DCNL DCSP if (rowLabels is not None): DCNL DCSP  DCSP for row in xrange(rows): DCNL DCSP  DCSP  DCSP table.add_cell((row + offset), (-1), width=(rowLabelWidth or 1e-15), height=height, text=rowLabels[row], facecolor=rowColours[row], loc=rowLoc) DCNL DCSP  DCSP if (rowLabelWidth == 0): DCNL DCSP  DCSP  DCSP table.auto_set_column_width((-1)) DCNL DCSP ax.add_table(table) DCNL DCSP return table
 DCSP if ((len(key) != 2) or (not isinstance(key[0], slice)) or (not isinstance(key[1], slice))): DCNL DCSP  DCSP raise ValueError('only DCSP 2-D DCSP slices, DCSP please') DCNL DCSP x0 = key[1].start DCNL DCSP x1 = key[1].stop DCNL DCSP xstep = key[1].step DCNL DCSP if ((not isinstance(xstep, complex)) or (int(xstep.real) != xstep.real)): DCNL DCSP  DCSP raise ValueError('only DCSP the DCSP [start:stop:numsteps*1j] DCSP form DCSP supported') DCNL DCSP xstep = int(xstep.imag) DCNL DCSP y0 = key[0].start DCNL DCSP y1 = key[0].stop DCNL DCSP ystep = key[0].step DCNL DCSP if ((not isinstance(ystep, complex)) or (int(ystep.real) != ystep.real)): DCNL DCSP  DCSP raise ValueError('only DCSP the DCSP [start:stop:numsteps*1j] DCSP form DCSP supported') DCNL DCSP ystep = int(ystep.imag) DCNL DCSP return (x0, x1, xstep, y0, y1, ystep)
 DCSP fz = func(mesh.x, mesh.y) DCNL DCSP tri = Triangulation(mesh.x, mesh.y) DCNL DCSP intp = getattr(tri, (interpolator + '_extrapolator'))(fz, bbox=(0.0, 1.0, 0.0, 1.0)) DCNL DCSP (Y, X) = np.mgrid[0:1:complex(0, n), 0:1:complex(0, n)] DCNL DCSP Z = func(X, Y) DCNL DCSP iz = intp[0:1:complex(0, n), 0:1:complex(0, n)] DCNL DCSP numgood = (n * n) DCNL DCSP SE = ((Z - iz) ** 2) DCNL DCSP SSE = np.sum(SE.flat) DCNL DCSP meanZ = (np.sum(Z.flat) / numgood) DCNL DCSP SM = ((Z - meanZ) ** 2) DCNL DCSP SSM = np.sum(SM.flat) DCNL DCSP r2 = (1.0 - (SSE / SSM)) DCNL DCSP print func.func_name, r2, SSE, SSM, numgood DCNL DCSP return r2
 DCSP traceback.print_exc(type, value, tb) DCNL DCSP print DCNL DCSP pdb.pm()
 DCSP dialog = wx.MessageDialog(parent=parent, message=msg, caption='Matplotlib DCSP backend_wx DCSP error', style=(wx.OK | wx.CENTRE)) DCNL DCSP dialog.ShowModal() DCNL DCSP dialog.Destroy() DCNL DCSP return None
 DCSP if (not is_string_like(msg)): DCNL DCSP  DCSP msg = '\n'.join(map(str, msg)) DCNL DCSP return msg
 DCSP wxapp = wx.GetApp() DCNL DCSP if (wxapp is None): DCNL DCSP  DCSP wxapp = wx.PySimpleApp() DCNL DCSP  DCSP wxapp.SetExitOnFrameDelete(True) DCNL DCSP  DCSP _create_wx_app.theWxApp = wxapp
 DCSP DEBUG_MSG('draw_if_interactive()', 1, None) DCNL DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager = Gcf.get_active() DCNL DCSP  DCSP if (figManager is not None): DCNL DCSP  DCSP  DCSP figManager.canvas.draw()
 DCSP DEBUG_MSG('show()', 3, None) DCNL DCSP for figwin in Gcf.get_all_fig_managers(): DCNL DCSP  DCSP figwin.frame.Show() DCNL DCSP if (show._needmain and (not matplotlib.is_interactive())): DCNL DCSP  DCSP wxapp = wx.GetApp() DCNL DCSP  DCSP if (wxapp is not None): DCNL DCSP  DCSP  DCSP imlr = getattr(wxapp, 'IsMainLoopRunning', (lambda : False)) DCNL DCSP  DCSP  DCSP if (not imlr()): DCNL DCSP  DCSP  DCSP  DCSP wxapp.MainLoop() DCNL DCSP  DCSP show._needmain = False
 DCSP DEBUG_MSG('new_figure_manager()', 3, None) DCNL DCSP _create_wx_app() DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP fig = FigureClass(*args, **kwargs) DCNL DCSP frame = FigureFrameWx(num, fig) DCNL DCSP figmgr = frame.get_figure_manager() DCNL DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figmgr.frame.Show() DCNL DCSP return figmgr
 DCSP basedir = os.path.join(rcParams['datapath'], 'images') DCNL DCSP bmpFilename = os.path.normpath(os.path.join(basedir, filename)) DCNL DCSP if (not os.path.exists(bmpFilename)): DCNL DCSP  DCSP raise IOError(('Could DCSP not DCSP find DCSP bitmap DCSP file DCSP "%s"; DCSP dying' % bmpFilename)) DCNL DCSP bmp = wx.Bitmap(bmpFilename) DCNL DCSP return bmp
 DCSP currpos = 0 DCNL DCSP lasti = 0 DCNL DCSP result = [] DCNL DCSP for (i, s) in enumerate(strings): DCNL DCSP  DCSP length = len(s) DCNL DCSP  DCSP if ((currpos + length) < linelen): DCNL DCSP  DCSP  DCSP currpos += (length + 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.append(' DCSP '.join(strings[lasti:i])) DCNL DCSP  DCSP  DCSP lasti = i DCNL DCSP  DCSP  DCSP currpos = length DCNL DCSP result.append(' DCSP '.join(strings[lasti:])) DCNL DCSP return '\n'.join(result)
 DCSP if hasattr(obj, 'pdfRepr'): DCNL DCSP  DCSP return obj.pdfRepr() DCNL DCSP elif isinstance(obj, float): DCNL DCSP  DCSP if (not npy.isfinite(obj)): DCNL DCSP  DCSP  DCSP raise ValueError, 'Can DCSP only DCSP output DCSP finite DCSP numbers DCSP in DCSP PDF' DCNL DCSP  DCSP r = ('%.10f' % obj) DCNL DCSP  DCSP return r.rstrip('0').rstrip('.') DCNL DCSP elif isinstance(obj, (int, long)): DCNL DCSP  DCSP return ('%d' % obj) DCNL DCSP elif is_string_like(obj): DCNL DCSP  DCSP return (('(' + _string_escape_regex.sub('\\\\\\1', obj)) + ')') DCNL DCSP elif isinstance(obj, dict): DCNL DCSP  DCSP r = ['<<'] DCNL DCSP  DCSP r.extend([('%s DCSP %s' % (Name(key).pdfRepr(), pdfRepr(val))) for (key, val) in obj.items()]) DCNL DCSP  DCSP r.append('>>') DCNL DCSP  DCSP return fill(r) DCNL DCSP elif isinstance(obj, (list, tuple)): DCNL DCSP  DCSP r = ['['] DCNL DCSP  DCSP r.extend([pdfRepr(val) for val in obj]) DCNL DCSP  DCSP r.append(']') DCNL DCSP  DCSP return fill(r) DCNL DCSP elif isinstance(obj, bool): DCNL DCSP  DCSP return ['false', 'true'][obj] DCNL DCSP elif (obj is None): DCNL DCSP  DCSP return 'null' DCNL DCSP elif isinstance(obj, datetime): DCNL DCSP  DCSP r = obj.strftime('D:%Y%m%d%H%M%S') DCNL DCSP  DCSP if time.daylight: DCNL DCSP  DCSP  DCSP z = time.altzone DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP z = time.timezone DCNL DCSP  DCSP if (z == 0): DCNL DCSP  DCSP  DCSP r += 'Z' DCNL DCSP  DCSP elif (z < 0): DCNL DCSP  DCSP  DCSP r += ("+%02d'%02d'" % (((- z) // 3600), ((- z) % 3600))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP r += ("-%02d'%02d'" % ((z // 3600), (z % 3600))) DCNL DCSP  DCSP return pdfRepr(r) DCNL DCSP elif isinstance(obj, BboxBase): DCNL DCSP  DCSP return fill([pdfRepr(val) for val in obj.bounds]) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError, ("Don't DCSP know DCSP a DCSP PDF DCSP representation DCSP for DCSP %s DCSP objects." % type(obj))
 DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasPdf(thisFig) DCNL DCSP manager = FigureManagerPdf(canvas, num) DCNL DCSP return manager
 DCSP s = s.replace('\\', '\\\\') DCNL DCSP s = s.replace('(', '\\(') DCNL DCSP s = s.replace(')', '\\)') DCNL DCSP s = s.replace("'", '\\251') DCNL DCSP s = s.replace('`', '\\301') DCNL DCSP s = re.sub('[^ DCSP -~\\n]', (lambda x: ('\\%03o' % ord(x.group()))), s) DCNL DCSP return s
 DCSP if (seq1 is None): DCNL DCSP  DCSP return (seq2 is None) DCNL DCSP if (seq2 is None): DCNL DCSP  DCSP return False DCNL DCSP if (len(seq1) != len(seq2)): DCNL DCSP  DCSP return False DCNL DCSP return npy.alltrue(npy.equal(seq1, seq2))
 DCSP tmpdir = os.path.split(tmpfile)[0] DCNL DCSP epsfile = (tmpfile + '.eps') DCNL DCSP shutil.move(tmpfile, epsfile) DCNL DCSP latexfile = (tmpfile + '.tex') DCNL DCSP outfile = (tmpfile + '.output') DCNL DCSP latexh = file(latexfile, 'w') DCNL DCSP dvifile = (tmpfile + '.dvi') DCNL DCSP psfile = (tmpfile + '.ps') DCNL DCSP if (orientation == 'landscape'): DCNL DCSP  DCSP angle = 90 DCNL DCSP else: DCNL DCSP  DCSP angle = 0 DCNL DCSP if rcParams['text.latex.unicode']: DCNL DCSP  DCSP unicode_preamble = '\\usepackage{ucs}\n\\usepackage[utf8x]{inputenc}' DCNL DCSP else: DCNL DCSP  DCSP unicode_preamble = '' DCNL DCSP s = ('\\documentclass{article}\n%s\n%s\n%s\n\\usepackage[dvips, DCSP papersize={%sin,%sin}, DCSP body={%sin,%sin}, DCSP margin={0in,0in}]{geometry}\n\\usepackage{psfrag}\n\\usepackage[dvips]{graphicx}\n\\usepackage{color}\n\\pagestyle{empty}\n\\begin{document}\n\\begin{figure}\n\\centering\n\\leavevmode\n%s\n\\includegraphics*[angle=%s]{%s}\n\\end{figure}\n\\end{document}\n' % (font_preamble, unicode_preamble, custom_preamble, paperWidth, paperHeight, paperWidth, paperHeight, '\n'.join(psfrags), angle, os.path.split(epsfile)[(-1)])) DCNL DCSP if rcParams['text.latex.unicode']: DCNL DCSP  DCSP latexh.write(s.encode('utf8')) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP latexh.write(s) DCNL DCSP  DCSP except UnicodeEncodeError as err: DCNL DCSP  DCSP  DCSP verbose.report("You DCSP are DCSP using DCSP unicode DCSP and DCSP latex, DCSP but DCSP have DCSP not DCSP enabled DCSP the DCSP matplotlib DCSP 'text.latex.unicode' DCSP rcParam.", 'helpful') DCNL DCSP  DCSP  DCSP raise DCNL DCSP latexh.close() DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP precmd = ('%s DCSP &&' % os.path.splitdrive(tmpdir)[0]) DCNL DCSP else: DCNL DCSP  DCSP precmd = '' DCNL DCSP command = ('%s DCSP cd DCSP "%s" DCSP && DCSP latex DCSP -interaction=nonstopmode DCSP "%s" DCSP > DCSP "%s"' % (precmd, tmpdir, latexfile, outfile)) DCNL DCSP verbose.report(command, 'debug') DCNL DCSP exit_status = os.system(command) DCNL DCSP fh = file(outfile) DCNL DCSP if exit_status: DCNL DCSP  DCSP raise RuntimeError(('LaTeX DCSP was DCSP not DCSP able DCSP to DCSP process DCSP your DCSP file:\nHere DCSP is DCSP the DCSP full DCSP report DCSP generated DCSP by DCSP LaTeX: DCSP \n\n%s' % fh.read())) DCNL DCSP else: DCNL DCSP  DCSP verbose.report(fh.read(), 'debug') DCNL DCSP fh.close() DCNL DCSP os.remove(outfile) DCNL DCSP command = ('%s DCSP cd DCSP "%s" DCSP && DCSP dvips DCSP -q DCSP -R0 DCSP -o DCSP "%s" DCSP "%s" DCSP > DCSP "%s"' % (precmd, tmpdir, os.path.split(psfile)[(-1)], os.path.split(dvifile)[(-1)], outfile)) DCNL DCSP verbose.report(command, 'debug') DCNL DCSP exit_status = os.system(command) DCNL DCSP fh = file(outfile) DCNL DCSP if exit_status: DCNL DCSP  DCSP raise RuntimeError((('dvips DCSP was DCSP not DCSP able DCSP to DCSP process DCSP the DCSP following DCSP file:\n%s\nHere DCSP is DCSP the DCSP full DCSP report DCSP generated DCSP by DCSP dvips: DCSP \n\n' % dvifile) + fh.read())) DCNL DCSP else: DCNL DCSP  DCSP verbose.report(fh.read(), 'debug') DCNL DCSP fh.close() DCNL DCSP os.remove(outfile) DCNL DCSP os.remove(epsfile) DCNL DCSP shutil.move(psfile, tmpfile) DCNL DCSP if (not debugPS): DCNL DCSP  DCSP for fname in glob.glob((tmpfile + '.*')): DCNL DCSP  DCSP  DCSP os.remove(fname)
 DCSP paper = ('-sPAPERSIZE=%s' % ptype) DCNL DCSP psfile = (tmpfile + '.ps') DCNL DCSP outfile = (tmpfile + '.output') DCNL DCSP dpi = rcParams['ps.distiller.res'] DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP gs_exe = 'gswin32c' DCNL DCSP else: DCNL DCSP  DCSP gs_exe = 'gs' DCNL DCSP command = ('%s DCSP -dBATCH DCSP -dNOPAUSE DCSP -r%d DCSP -sDEVICE=pswrite DCSP %s DCSP -sOutputFile="%s" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "%s" DCSP > DCSP "%s"' % (gs_exe, dpi, paper, psfile, tmpfile, outfile)) DCNL DCSP verbose.report(command, 'debug') DCNL DCSP exit_status = os.system(command) DCNL DCSP fh = file(outfile) DCNL DCSP if exit_status: DCNL DCSP  DCSP raise RuntimeError(('ghostscript DCSP was DCSP not DCSP able DCSP to DCSP process DCSP your DCSP image.\nHere DCSP is DCSP the DCSP full DCSP report DCSP generated DCSP by DCSP ghostscript:\n\n' + fh.read())) DCNL DCSP else: DCNL DCSP  DCSP verbose.report(fh.read(), 'debug') DCNL DCSP fh.close() DCNL DCSP os.remove(outfile) DCNL DCSP os.remove(tmpfile) DCNL DCSP shutil.move(psfile, tmpfile) DCNL DCSP if eps: DCNL DCSP  DCSP pstoeps(tmpfile, bbox)
 DCSP pdffile = (tmpfile + '.pdf') DCNL DCSP psfile = (tmpfile + '.ps') DCNL DCSP outfile = (tmpfile + '.output') DCNL DCSP command = ('ps2pdf DCSP -dAutoFilterColorImages=false DCSP -sColorImageFilter=FlateEncode DCSP -sPAPERSIZE=%s DCSP "%s" DCSP "%s" DCSP > DCSP "%s"' % (ptype, tmpfile, pdffile, outfile)) DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP command = command.replace('=', '#') DCNL DCSP verbose.report(command, 'debug') DCNL DCSP exit_status = os.system(command) DCNL DCSP fh = file(outfile) DCNL DCSP if exit_status: DCNL DCSP  DCSP raise RuntimeError(('ps2pdf DCSP was DCSP not DCSP able DCSP to DCSP process DCSP your DCSP image.\n\\Here DCSP is DCSP the DCSP report DCSP generated DCSP by DCSP ghostscript:\n\n' + fh.read())) DCNL DCSP else: DCNL DCSP  DCSP verbose.report(fh.read(), 'debug') DCNL DCSP fh.close() DCNL DCSP os.remove(outfile) DCNL DCSP command = ('pdftops DCSP -paper DCSP match DCSP -level2 DCSP "%s" DCSP "%s" DCSP > DCSP "%s"' % (pdffile, psfile, outfile)) DCNL DCSP verbose.report(command, 'debug') DCNL DCSP exit_status = os.system(command) DCNL DCSP fh = file(outfile) DCNL DCSP if exit_status: DCNL DCSP  DCSP raise RuntimeError(('pdftops DCSP was DCSP not DCSP able DCSP to DCSP process DCSP your DCSP image.\nHere DCSP is DCSP the DCSP full DCSP report DCSP generated DCSP by DCSP pdftops: DCSP \n\n' + fh.read())) DCNL DCSP else: DCNL DCSP  DCSP verbose.report(fh.read(), 'debug') DCNL DCSP fh.close() DCNL DCSP os.remove(outfile) DCNL DCSP os.remove(tmpfile) DCNL DCSP shutil.move(psfile, tmpfile) DCNL DCSP if eps: DCNL DCSP  DCSP pstoeps(tmpfile, bbox) DCNL DCSP for fname in glob.glob((tmpfile + '.*')): DCNL DCSP  DCSP os.remove(fname)
 DCSP outfile = (tmpfile + '.output') DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP gs_exe = 'gswin32c' DCNL DCSP else: DCNL DCSP  DCSP gs_exe = 'gs' DCNL DCSP command = ('%s DCSP -dBATCH DCSP -dNOPAUSE DCSP -sDEVICE=bbox DCSP "%s"' % (gs_exe, tmpfile)) DCNL DCSP verbose.report(command, 'debug') DCNL DCSP (stdin, stdout, stderr) = os.popen3(command) DCNL DCSP verbose.report(stdout.read(), 'debug-annoying') DCNL DCSP bbox_info = stderr.read() DCNL DCSP verbose.report(bbox_info, 'helpful') DCNL DCSP bbox_found = re.search('%%HiResBoundingBox: DCSP .*', bbox_info) DCNL DCSP if bbox_found: DCNL DCSP  DCSP bbox_info = bbox_found.group() DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(('Ghostscript DCSP was DCSP not DCSP able DCSP to DCSP extract DCSP a DCSP bounding DCSP box.Here DCSP is DCSP the DCSP Ghostscript DCSP output:\n\n%s' % bbox_info)) DCNL DCSP (l, b, r, t) = [float(i) for i in bbox_info.split()[(-4):]] DCNL DCSP if (bbox is None): DCNL DCSP  DCSP (l, b, r, t) = ((l - 1), (b - 1), (r + 1), (t + 1)) DCNL DCSP else: DCNL DCSP  DCSP x = ((l + r) / 2) DCNL DCSP  DCSP y = ((b + t) / 2) DCNL DCSP  DCSP dx = ((bbox[2] - bbox[0]) / 2) DCNL DCSP  DCSP dy = ((bbox[3] - bbox[1]) / 2) DCNL DCSP  DCSP (l, b, r, t) = ((x - dx), (y - dy), (x + dx), (y + dy)) DCNL DCSP bbox_info = ('%%%%BoundingBox: DCSP %d DCSP %d DCSP %d DCSP %d' % (l, b, npy.ceil(r), npy.ceil(t))) DCNL DCSP hires_bbox_info = ('%%%%HiResBoundingBox: DCSP %.6f DCSP %.6f DCSP %.6f DCSP %.6f' % (l, b, r, t)) DCNL DCSP return '\n'.join([bbox_info, hires_bbox_info])
 DCSP bbox_info = get_bbox(tmpfile, bbox) DCNL DCSP epsfile = (tmpfile + '.eps') DCNL DCSP epsh = file(epsfile, 'w') DCNL DCSP tmph = file(tmpfile) DCNL DCSP line = tmph.readline() DCNL DCSP while line: DCNL DCSP  DCSP if line.startswith('%!PS'): DCNL DCSP  DCSP  DCSP print >>epsh, '%!PS-Adobe-3.0 DCSP EPSF-3.0' DCNL DCSP  DCSP  DCSP print >>epsh, bbox_info DCNL DCSP  DCSP elif line.startswith('%%EndComments'): DCNL DCSP  DCSP  DCSP epsh.write(line) DCNL DCSP  DCSP  DCSP print >>epsh, '%%BeginProlog' DCNL DCSP  DCSP  DCSP print >>epsh, 'save' DCNL DCSP  DCSP  DCSP print >>epsh, 'countdictstack' DCNL DCSP  DCSP  DCSP print >>epsh, 'mark' DCNL DCSP  DCSP  DCSP print >>epsh, 'newpath' DCNL DCSP  DCSP  DCSP print >>epsh, '/showpage DCSP {} DCSP def' DCNL DCSP  DCSP  DCSP print >>epsh, '/setpagedevice DCSP {pop} DCSP def' DCNL DCSP  DCSP  DCSP print >>epsh, '%%EndProlog' DCNL DCSP  DCSP  DCSP print >>epsh, '%%Page DCSP 1 DCSP 1' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (line.startswith('%%Bound') or line.startswith('%%HiResBound') or line.startswith('%%Pages')): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP epsh.write(line) DCNL DCSP  DCSP line = tmph.readline() DCNL DCSP line = tmph.readline() DCNL DCSP while line: DCNL DCSP  DCSP if line.startswith('%%Trailer'): DCNL DCSP  DCSP  DCSP print >>epsh, '%%Trailer' DCNL DCSP  DCSP  DCSP print >>epsh, 'cleartomark' DCNL DCSP  DCSP  DCSP print >>epsh, 'countdictstack' DCNL DCSP  DCSP  DCSP print >>epsh, 'exch DCSP sub DCSP { DCSP end DCSP } DCSP repeat' DCNL DCSP  DCSP  DCSP print >>epsh, 'restore' DCNL DCSP  DCSP  DCSP if (rcParams['ps.usedistiller'] == 'xpdf'): DCNL DCSP  DCSP  DCSP  DCSP line = tmph.readline() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP epsh.write(line) DCNL DCSP  DCSP line = tmph.readline() DCNL DCSP tmph.close() DCNL DCSP epsh.close() DCNL DCSP os.remove(tmpfile) DCNL DCSP shutil.move(epsfile, tmpfile)
 DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager = Gcf.get_active() DCNL DCSP  DCSP if (figManager is not None): DCNL DCSP  DCSP  DCSP figManager.canvas.draw()
 DCSP for manager in Gcf.get_all_fig_managers(): DCNL DCSP  DCSP manager.window.show() DCNL DCSP if (mainloop and (gtk.main_level() == 0) and (len(Gcf.get_all_fig_managers()) > 0)): DCNL DCSP  DCSP gtk.main()
 DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasGTK(thisFig) DCNL DCSP manager = FigureManagerGTK(canvas, num) DCNL DCSP return manager
 DCSP pass
 DCSP for manager in Gcf.get_all_fig_managers(): DCNL DCSP  DCSP pass
 DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasTemplate(thisFig) DCNL DCSP manager = FigureManagerTemplate(canvas, num) DCNL DCSP return manager
 DCSP if backend.startswith('module://'): DCNL DCSP  DCSP backend_name = backend[9:] DCNL DCSP else: DCNL DCSP  DCSP backend_name = ('backend_' + backend) DCNL DCSP  DCSP backend_name = backend_name.lower() DCNL DCSP  DCSP backend_name = ('matplotlib.backends.%s' % backend_name.lower()) DCNL DCSP backend_mod = __import__(backend_name, globals(), locals(), [backend_name]) DCNL DCSP new_figure_manager = backend_mod.new_figure_manager DCNL DCSP def do_nothing_show(*args, **kwargs): DCNL DCSP  DCSP frame = inspect.currentframe() DCNL DCSP  DCSP fname = frame.f_back.f_code.co_filename DCNL DCSP  DCSP if (fname in ('<stdin>', '<ipython DCSP console>')): DCNL DCSP  DCSP  DCSP warnings.warn(("\nYour DCSP currently DCSP selected DCSP backend, DCSP '%s' DCSP does DCSP not DCSP support DCSP show().\nPlease DCSP select DCSP a DCSP GUI DCSP backend DCSP in DCSP your DCSP matplotlibrc DCSP file DCSP ('%s')\nor DCSP with DCSP matplotlib.use()" % (backend, matplotlib.matplotlib_fname()))) DCNL DCSP def do_nothing(*args, **kwargs): DCNL DCSP  DCSP pass DCNL DCSP backend_version = getattr(backend_mod, 'backend_version', 'unknown') DCNL DCSP show = getattr(backend_mod, 'show', do_nothing_show) DCNL DCSP draw_if_interactive = getattr(backend_mod, 'draw_if_interactive', do_nothing) DCNL DCSP if (backend.lower() in ['wx', 'wxagg']): DCNL DCSP  DCSP Toolbar = backend_mod.Toolbar DCNL DCSP  DCSP __all__.append('Toolbar') DCNL DCSP matplotlib.verbose.report(('backend DCSP %s DCSP version DCSP %s' % (backend, backend_version))) DCNL DCSP return (new_figure_manager, draw_if_interactive, show)
 DCSP pass
 DCSP for manager in Gcf.get_all_fig_managers(): DCNL DCSP  DCSP pass
 DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasEMF(thisFig) DCNL DCSP manager = FigureManagerEMF(canvas, num) DCNL DCSP return manager
 DCSP if _debug: DCNL DCSP  DCSP print ('backend_gtkcairo.%s()' % fn_name()) DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasGTKCairo(thisFig) DCNL DCSP return FigureManagerGTK(canvas, num)
 DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasGDK(thisFig) DCNL DCSP manager = FigureManagerBase(canvas, num) DCNL DCSP return manager
 DCSP if DEBUG: DCNL DCSP  DCSP print 'backend_qtagg.new_figure_manager' DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasQTAgg(thisFig) DCNL DCSP return FigureManagerQTAgg(canvas, num)
 DCSP if (not is_string_like(msg)): DCNL DCSP  DCSP msg = '\n'.join(map(str, msg)) DCNL DCSP return msg
 DCSP for manager in Gcf.get_all_fig_managers(): DCNL DCSP  DCSP manager.show() DCNL DCSP import matplotlib DCNL DCSP matplotlib.interactive(True) DCNL DCSP if rcParams['tk.pythoninspect']: DCNL DCSP  DCSP os.environ['PYTHONINSPECT'] = '1' DCNL DCSP if show._needmain: DCNL DCSP  DCSP Tk.mainloop() DCNL DCSP  DCSP show._needmain = False
 DCSP _focus = windowing.FocusManager() DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP figure = FigureClass(*args, **kwargs) DCNL DCSP window = Tk.Tk() DCNL DCSP canvas = FigureCanvasTkAgg(figure, master=window) DCNL DCSP figManager = FigureManagerTkAgg(canvas, num, window) DCNL DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager.show() DCNL DCSP return figManager
 DCSP if __debug__: DCNL DCSP  DCSP verbose.report('backend_agg.new_figure_manager', 'debug-annoying') DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasAgg(thisFig) DCNL DCSP manager = FigureManagerBase(canvas, num) DCNL DCSP return manager
 DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager = Gcf.get_active() DCNL DCSP  DCSP if (figManager != None): DCNL DCSP  DCSP  DCSP figManager.canvas.draw()
 DCSP if qt.QApplication.startingUp(): DCNL DCSP  DCSP if DEBUG: DCNL DCSP  DCSP  DCSP print 'Starting DCSP up DCSP QApplication' DCNL DCSP  DCSP global qApp DCNL DCSP  DCSP qApp = qt.QApplication([' DCSP ']) DCNL DCSP  DCSP qt.QObject.connect(qApp, qt.SIGNAL('lastWindowClosed()'), qApp, qt.SLOT('quit()')) DCNL DCSP  DCSP _create_qApp.qAppCreatedHere = True
 DCSP for manager in Gcf.get_all_fig_managers(): DCNL DCSP  DCSP manager.window.show() DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'Inside DCSP show' DCNL DCSP figManager = Gcf.get_active() DCNL DCSP if (figManager != None): DCNL DCSP  DCSP figManager.canvas.draw() DCNL DCSP if _create_qApp.qAppCreatedHere: DCNL DCSP  DCSP qt.qApp.exec_loop()
 DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasQT(thisFig) DCNL DCSP manager = FigureManagerQT(canvas, num) DCNL DCSP return manager
 DCSP msg = '' DCNL DCSP if (hasattr(value, 'filename') and (value.filename != None)): DCNL DCSP  DCSP msg = (value.filename + ': DCSP ') DCNL DCSP if (hasattr(value, 'strerror') and (value.strerror != None)): DCNL DCSP  DCSP msg += value.strerror DCNL DCSP else: DCNL DCSP  DCSP msg += str(value) DCNL DCSP if len(msg): DCNL DCSP  DCSP error_msg_qt(msg)
 DCSP DEBUG_MSG('new_figure_manager()', 3, None) DCNL DCSP backend_wx._create_wx_app() DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP fig = FigureClass(*args, **kwargs) DCNL DCSP frame = FigureFrameWxAgg(num, fig) DCNL DCSP figmgr = frame.get_figure_manager() DCNL DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figmgr.frame.Show() DCNL DCSP return figmgr
 DCSP image = wx.EmptyImage(int(agg.width), int(agg.height)) DCNL DCSP image.SetData(agg.tostring_rgb()) DCNL DCSP if (bbox is None): DCNL DCSP  DCSP return image DCNL DCSP else: DCNL DCSP  DCSP return wx.ImageFromBitmap(_clipped_image_as_bitmap(image, bbox))
 DCSP if (bbox is None): DCNL DCSP  DCSP return wx.BitmapFromImage(_py_convert_agg_to_wx_image(agg, None)) DCNL DCSP else: DCNL DCSP  DCSP return _clipped_image_as_bitmap(_py_convert_agg_to_wx_image(agg, None), bbox)
 DCSP (l, b, width, height) = bbox.get_bounds() DCNL DCSP r = (l + width) DCNL DCSP t = (b + height) DCNL DCSP srcBmp = wx.BitmapFromImage(image) DCNL DCSP srcDC = wx.MemoryDC() DCNL DCSP srcDC.SelectObject(srcBmp) DCNL DCSP destBmp = wx.EmptyBitmap(int(width), int(height)) DCNL DCSP destDC = wx.MemoryDC() DCNL DCSP destDC.SelectObject(destBmp) DCNL DCSP destDC.BeginDrawing() DCNL DCSP x = int(l) DCNL DCSP y = int((image.GetHeight() - t)) DCNL DCSP destDC.Blit(0, 0, int(width), int(height), srcDC, x, y) DCNL DCSP destDC.EndDrawing() DCNL DCSP srcDC.SelectObject(wx.NullBitmap) DCNL DCSP destDC.SelectObject(wx.NullBitmap) DCNL DCSP return destBmp
 DCSP if (bbox is None): DCNL DCSP  DCSP image = wx.EmptyImage(int(agg.width), int(agg.height)) DCNL DCSP  DCSP image.SetData(agg.tostring_rgb()) DCNL DCSP  DCSP return image DCNL DCSP else: DCNL DCSP  DCSP return wx.ImageFromBitmap(_WX28_clipped_agg_as_bitmap(agg, bbox))
 DCSP if (bbox is None): DCNL DCSP  DCSP return wx.BitmapFromBufferRGBA(int(agg.width), int(agg.height), agg.buffer_rgba(0, 0)) DCNL DCSP else: DCNL DCSP  DCSP return _WX28_clipped_agg_as_bitmap(agg, bbox)
 DCSP (l, b, width, height) = bbox.get_bounds() DCNL DCSP r = (l + width) DCNL DCSP t = (b + height) DCNL DCSP srcBmp = wx.BitmapFromBufferRGBA(int(agg.width), int(agg.height), agg.buffer_rgba(0, 0)) DCNL DCSP srcDC = wx.MemoryDC() DCNL DCSP srcDC.SelectObject(srcBmp) DCNL DCSP destBmp = wx.EmptyBitmap(int(width), int(height)) DCNL DCSP destDC = wx.MemoryDC() DCNL DCSP destDC.SelectObject(destBmp) DCNL DCSP destDC.BeginDrawing() DCNL DCSP x = int(l) DCNL DCSP y = int((int(agg.height) - t)) DCNL DCSP destDC.Blit(0, 0, int(width), int(height), srcDC, x, y) DCNL DCSP destDC.EndDrawing() DCNL DCSP srcDC.SelectObject(wx.NullBitmap) DCNL DCSP destDC.SelectObject(wx.NullBitmap) DCNL DCSP return destBmp
 DCSP global _convert_agg_to_wx_image DCNL DCSP global _convert_agg_to_wx_bitmap DCNL DCSP if (getattr(wx, '__version__', '0.0')[0:3] < '2.8'): DCNL DCSP  DCSP if (state and (_wxagg is not None)): DCNL DCSP  DCSP  DCSP _convert_agg_to_wx_image = _wxagg.convert_agg_to_wx_image DCNL DCSP  DCSP  DCSP _convert_agg_to_wx_bitmap = _wxagg.convert_agg_to_wx_bitmap DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _convert_agg_to_wx_image = _py_convert_agg_to_wx_image DCNL DCSP  DCSP  DCSP _convert_agg_to_wx_bitmap = _py_convert_agg_to_wx_bitmap DCNL DCSP else: DCNL DCSP  DCSP _convert_agg_to_wx_image = _py_WX28_convert_agg_to_wx_image DCNL DCSP  DCSP _convert_agg_to_wx_bitmap = _py_WX28_convert_agg_to_wx_bitmap
 DCSP if DEBUG: DCNL DCSP  DCSP print 'backend_gtkagg.new_figure_manager' DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasGTKAgg(thisFig) DCNL DCSP return FigureManagerGTKAgg(canvas, num) DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'backend_gtkagg.new_figure_manager DCSP done'
 DCSP for manager in Gcf.get_all_fig_managers(): DCNL DCSP  DCSP manager.show() DCNL DCSP if show._needmain: DCNL DCSP  DCSP thread.start_new_thread(Fltk_run_interactive, ()) DCNL DCSP show._needmain = False
 DCSP for manager in Gcf.get_all_fig_managers(): DCNL DCSP  DCSP manager.show() DCNL DCSP if show._needmain: DCNL DCSP  DCSP Fltk.Fl.run() DCNL DCSP  DCSP show._needmain = False
 DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP figure = FigureClass(*args, **kwargs) DCNL DCSP window = Fltk.Fl_Double_Window(10, 10, 30, 30) DCNL DCSP canvas = FigureCanvasFltkAgg(figure) DCNL DCSP window.end() DCNL DCSP window.show() DCNL DCSP window.make_current() DCNL DCSP figManager = FigureManagerFltkAgg(canvas, num, window) DCNL DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager.show() DCNL DCSP return figManager
 DCSP _macosx.show()
 DCSP figManager = Gcf.get_active() DCNL DCSP if (figManager is not None): DCNL DCSP  DCSP figManager.canvas.invalidate()
 DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP figure = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasMac(figure) DCNL DCSP manager = FigureManagerMac(canvas, num) DCNL DCSP return manager
 DCSP if _debug: DCNL DCSP  DCSP print ('%s.%s()' % (self.__class__.__name__, _fn_name())) DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasCairo(thisFig) DCNL DCSP manager = FigureManagerBase(canvas, num) DCNL DCSP return manager
 DCSP if DEBUG: DCNL DCSP  DCSP print 'backend_qtagg.new_figure_manager' DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP canvas = FigureCanvasQTAgg(thisFig) DCNL DCSP return FigureManagerQT(canvas, num)
 DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager = Gcf.get_active() DCNL DCSP  DCSP if (figManager != None): DCNL DCSP  DCSP  DCSP figManager.canvas.draw()
 DCSP if QtGui.QApplication.startingUp(): DCNL DCSP  DCSP if DEBUG: DCNL DCSP  DCSP  DCSP print 'Starting DCSP up DCSP QApplication' DCNL DCSP  DCSP global qApp DCNL DCSP  DCSP qApp = QtGui.QApplication([' DCSP ']) DCNL DCSP  DCSP QtCore.QObject.connect(qApp, QtCore.SIGNAL('lastWindowClosed()'), qApp, QtCore.SLOT('quit()')) DCNL DCSP  DCSP _create_qApp.qAppCreatedHere = True
 DCSP for manager in Gcf.get_all_fig_managers(): DCNL DCSP  DCSP manager.window.show() DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'Inside DCSP show' DCNL DCSP figManager = Gcf.get_active() DCNL DCSP if (figManager != None): DCNL DCSP  DCSP figManager.canvas.draw() DCNL DCSP if _create_qApp.qAppCreatedHere: DCNL DCSP  DCSP QtGui.qApp.exec_()
 DCSP thisFig = Figure(*args, **kwargs) DCNL DCSP canvas = FigureCanvasQT(thisFig) DCNL DCSP manager = FigureManagerQT(canvas, num) DCNL DCSP return manager
 DCSP msg = '' DCNL DCSP if (hasattr(value, 'filename') and (value.filename != None)): DCNL DCSP  DCSP msg = (value.filename + ': DCSP ') DCNL DCSP if (hasattr(value, 'strerror') and (value.strerror != None)): DCNL DCSP  DCSP msg += value.strerror DCNL DCSP else: DCNL DCSP  DCSP msg += str(value) DCNL DCSP if len(msg): DCNL DCSP  DCSP error_msg_qt(msg)
 DCSP remove = ('\\mathdefault', '\\rm', '\\cal', '\\tt', '\\it', '\\', '{', '}') DCNL DCSP s = s[1:(-1)] DCNL DCSP for r in remove: DCNL DCSP  DCSP s = s.replace(r, '') DCNL DCSP return s
 DCSP return dict([(val, 1) for val in x]).keys()
 DCSP try: DCNL DCSP  DCSP len(obj) DCNL DCSP except: DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP if isinstance(obj, (str, unicode)): DCNL DCSP  DCSP return True DCNL DCSP if ma.isMaskedArray(obj): DCNL DCSP  DCSP if ((obj.ndim == 0) and (obj.dtype.kind in 'SU')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP (obj + '') DCNL DCSP except (TypeError, ValueError): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP if (not iterable(obj)): DCNL DCSP  DCSP return False DCNL DCSP if is_string_like(obj): DCNL DCSP  DCSP return False DCNL DCSP for o in obj: DCNL DCSP  DCSP if (not is_string_like(o)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP return (hasattr(obj, 'write') and callable(obj.write))
 DCSP return ((not is_string_like(obj)) and (not iterable(obj)))
 DCSP try: DCNL DCSP  DCSP (obj + 1) DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
 DCSP if is_string_like(fname): DCNL DCSP  DCSP if fname.endswith('.gz'): DCNL DCSP  DCSP  DCSP import gzip DCNL DCSP  DCSP  DCSP fh = gzip.open(fname, flag) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fh = file(fname, flag) DCNL DCSP  DCSP opened = True DCNL DCSP elif hasattr(fname, 'seek'): DCNL DCSP  DCSP fh = fname DCNL DCSP  DCSP opened = False DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('fname DCSP must DCSP be DCSP a DCSP string DCSP or DCSP file DCSP handle') DCNL DCSP if return_opened: DCNL DCSP  DCSP return (fh, opened) DCNL DCSP return fh
 DCSP for item in seq: DCNL DCSP  DCSP if scalarp(item): DCNL DCSP  DCSP  DCSP (yield item) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for subitem in flatten(item, scalarp): DCNL DCSP  DCSP  DCSP  DCSP (yield subitem)
 DCSP soundex_digits = '01230120022455012623010202' DCNL DCSP sndx = '' DCNL DCSP fc = '' DCNL DCSP for c in name.upper(): DCNL DCSP  DCSP if c.isalpha(): DCNL DCSP  DCSP  DCSP if (not fc): DCNL DCSP  DCSP  DCSP  DCSP fc = c DCNL DCSP  DCSP  DCSP d = soundex_digits[(ord(c) - ord('A'))] DCNL DCSP  DCSP  DCSP if ((not sndx) or (d != sndx[(-1)])): DCNL DCSP  DCSP  DCSP  DCSP sndx += d DCNL DCSP sndx = (fc + sndx[1:]) DCNL DCSP sndx = sndx.replace('0', '') DCNL DCSP return (sndx + (len * '0'))[:len]
 DCSP try: DCNL DCSP  DCSP if (not os.path.exists(newdir)): DCNL DCSP  DCSP  DCSP parts = os.path.split(newdir) DCNL DCSP  DCSP  DCSP for i in range(1, (len(parts) + 1)): DCNL DCSP  DCSP  DCSP  DCSP thispart = os.path.join(*parts[:i]) DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(thispart)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(thispart, mode) DCNL DCSP except OSError as err: DCNL DCSP  DCSP if ((err.errno != errno.EEXIST) or (not os.path.isdir(newdir))): DCNL DCSP  DCSP  DCSP raise
 DCSP for key in keys: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP del d[key] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass
 DCSP sLen = 0 DCNL DCSP for (word, ind) in zip(seq, range(len(seq))): DCNL DCSP  DCSP sLen += (len(word) + 1) DCNL DCSP  DCSP if (sLen >= N): DCNL DCSP  DCSP  DCSP return ind DCNL DCSP return len(seq)
 DCSP pad = (' DCSP ' * len(prefix.expandtabs())) DCNL DCSP available = (cols - len(pad)) DCNL DCSP seq = text.split(' DCSP ') DCNL DCSP Nseq = len(seq) DCNL DCSP ind = 0 DCNL DCSP lines = [] DCNL DCSP while (ind < Nseq): DCNL DCSP  DCSP lastInd = ind DCNL DCSP  DCSP ind += get_split_ind(seq[ind:], available) DCNL DCSP  DCSP lines.append(seq[lastInd:ind]) DCNL DCSP ret = ((prefix + ' DCSP '.join(lines[0])) + '\n') DCNL DCSP for line in lines[1:]: DCNL DCSP  DCSP ret += ((pad + ' DCSP '.join(line)) + '\n') DCNL DCSP return ret
 DCSP if (not s): DCNL DCSP  DCSP return '' DCNL DCSP match = _find_dedent_regex.match(s) DCNL DCSP if (match is None): DCNL DCSP  DCSP return s DCNL DCSP nshift = (match.end(1) - match.start(1)) DCNL DCSP if (nshift == 0): DCNL DCSP  DCSP return s DCNL DCSP unindent = _dedent_regex.get(nshift, None) DCNL DCSP if (unindent is None): DCNL DCSP  DCSP unindent = re.compile(('\n\r? DCSP {0,%d}' % nshift)) DCNL DCSP  DCSP _dedent_regex[nshift] = unindent DCNL DCSP result = unindent.sub('\n', s).strip() DCNL DCSP return result
 DCSP import os.path, fnmatch DCNL DCSP pattern_list = patterns.split(';') DCNL DCSP class Bunch: DCNL DCSP  DCSP def __init__(self, **kwds): DCNL DCSP  DCSP  DCSP self.__dict__.update(kwds) DCNL DCSP arg = Bunch(recurse=recurse, pattern_list=pattern_list, return_folders=return_folders, results=[]) DCNL DCSP def visit(arg, dirname, files): DCNL DCSP  DCSP for name in files: DCNL DCSP  DCSP  DCSP fullname = os.path.normpath(os.path.join(dirname, name)) DCNL DCSP  DCSP  DCSP if (arg.return_folders or os.path.isfile(fullname)): DCNL DCSP  DCSP  DCSP  DCSP for pattern in arg.pattern_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if fnmatch.fnmatch(name, pattern): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP arg.results.append(fullname) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not arg.recurse): DCNL DCSP  DCSP  DCSP files[:] = [] DCNL DCSP os.path.walk(root, visit, arg) DCNL DCSP return arg.results
 DCSP files = [] DCNL DCSP for arg in args: DCNL DCSP  DCSP if os.path.isfile(arg): DCNL DCSP  DCSP  DCSP files.append(arg) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if os.path.isdir(arg): DCNL DCSP  DCSP  DCSP newfiles = listFiles(arg, recurse=1, return_folders=1) DCNL DCSP  DCSP  DCSP files.extend(newfiles) DCNL DCSP return [f for f in files if (not os.path.islink(f))]
 DCSP start = 0 DCNL DCSP while 1: DCNL DCSP  DCSP item = seq[start:(start + num)] DCNL DCSP  DCSP if (not len(item)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (yield item) DCNL DCSP  DCSP start += num
 DCSP if (len(seq) < 2): DCNL DCSP  DCSP return True DCNL DCSP val = seq[0] DCNL DCSP for i in xrange(1, len(seq)): DCNL DCSP  DCSP thisval = seq[i] DCNL DCSP  DCSP if (thisval != val): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP if (not len(seq)): DCNL DCSP  DCSP return False DCNL DCSP for val in seq: DCNL DCSP  DCSP if (not val): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP if (not len(seq)): DCNL DCSP  DCSP return False DCNL DCSP for val in seq: DCNL DCSP  DCSP if val: DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP return [(s, f) for (i, f) in enumerate(x) for s in x[(i + 1):]]
 DCSP warnings.warn('Use DCSP native DCSP python DCSP dict.pop DCSP method', DeprecationWarning) DCNL DCSP if (len(args) == 1): DCNL DCSP  DCSP key = args[0] DCNL DCSP  DCSP val = d[key] DCNL DCSP  DCSP del d[key] DCNL DCSP elif (len(args) == 2): DCNL DCSP  DCSP (key, default) = args DCNL DCSP  DCSP val = d.get(key, default) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP del d[key] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return val
 DCSP for i in xrange(len(seq)): DCNL DCSP  DCSP seq.pop()
 DCSP if case: DCNL DCSP  DCSP names = [(name, name) for name in dir(o) if is_string_like(name)] DCNL DCSP else: DCNL DCSP  DCSP names = [(name.lower(), name) for name in dir(o) if is_string_like(name)] DCNL DCSP  DCSP match = match.lower() DCNL DCSP return [orig for (name, orig) in names if (name.find(match) >= 0)]
 DCSP return dict([(v, k) for (k, v) in d.items()])
 DCSP pid = os.getpid() DCNL DCSP if (sys.platform == 'sunos5'): DCNL DCSP  DCSP a2 = os.popen(('ps DCSP -p DCSP %d DCSP -o DCSP osz' % pid)).readlines() DCNL DCSP  DCSP mem = int(a2[(-1)].strip()) DCNL DCSP elif sys.platform.startswith('linux'): DCNL DCSP  DCSP a2 = os.popen(('ps DCSP -p DCSP %d DCSP -o DCSP rss,sz' % pid)).readlines() DCNL DCSP  DCSP mem = int(a2[1].split()[1]) DCNL DCSP elif sys.platform.startswith('darwin'): DCNL DCSP  DCSP a2 = os.popen(('ps DCSP -p DCSP %d DCSP -o DCSP rss,vsz' % pid)).readlines() DCNL DCSP  DCSP mem = int(a2[1].split()[0]) DCNL DCSP return mem
 DCSP Nx = len(args[0]) DCNL DCSP for (i, arg) in enumerate(args[1:]): DCNL DCSP  DCSP if (len(arg) != Nx): DCNL DCSP  DCSP  DCSP raise ValueError((_safezip_msg % (Nx, (i + 1), len(arg)))) DCNL DCSP return zip(*args)
 DCSP try: DCNL DCSP  DCSP return issubclass(x, klass) DCNL DCSP except TypeError: DCNL DCSP  DCSP return False
 DCSP import gc DCNL DCSP from types import FrameType DCNL DCSP def print_path(path): DCNL DCSP  DCSP for (i, step) in enumerate(path): DCNL DCSP  DCSP  DCSP next = path[((i + 1) % len(path))] DCNL DCSP  DCSP  DCSP outstream.write((' DCSP  DCSP  DCSP %s DCSP -- DCSP ' % str(type(step)))) DCNL DCSP  DCSP  DCSP if isinstance(step, dict): DCNL DCSP  DCSP  DCSP  DCSP for (key, val) in step.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (val is next): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP outstream.write(('[%s]' % repr(key))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (key is next): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP outstream.write(('[key] DCSP = DCSP %s' % repr(val))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif isinstance(step, list): DCNL DCSP  DCSP  DCSP  DCSP outstream.write(('[%d]' % step.index(next))) DCNL DCSP  DCSP  DCSP elif isinstance(step, tuple): DCNL DCSP  DCSP  DCSP  DCSP outstream.write('( DCSP tuple DCSP )') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP outstream.write(repr(step)) DCNL DCSP  DCSP  DCSP outstream.write(' DCSP ->\n') DCNL DCSP  DCSP outstream.write('\n') DCNL DCSP def recurse(obj, start, all, current_path): DCNL DCSP  DCSP if show_progress: DCNL DCSP  DCSP  DCSP outstream.write(('%d\r' % len(all))) DCNL DCSP  DCSP all[id(obj)] = None DCNL DCSP  DCSP referents = gc.get_referents(obj) DCNL DCSP  DCSP for referent in referents: DCNL DCSP  DCSP  DCSP if (referent is start): DCNL DCSP  DCSP  DCSP  DCSP print_path(current_path) DCNL DCSP  DCSP  DCSP elif ((referent is objects) or isinstance(referent, FrameType)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (id(referent) not in all): DCNL DCSP  DCSP  DCSP  DCSP recurse(referent, start, all, (current_path + [obj])) DCNL DCSP for obj in objects: DCNL DCSP  DCSP outstream.write(('Examining: DCSP %r\n' % (obj,))) DCNL DCSP  DCSP recurse(obj, obj, {}, [])
 DCSP if (not len(args)): DCNL DCSP  DCSP return () DCNL DCSP if (is_string_like(args[0]) or (not iterable(args[0]))): DCNL DCSP  DCSP raise ValueError('First DCSP argument DCSP must DCSP be DCSP a DCSP sequence') DCNL DCSP nrecs = len(args[0]) DCNL DCSP margs = [] DCNL DCSP seqlist = ([False] * len(args)) DCNL DCSP for (i, x) in enumerate(args): DCNL DCSP  DCSP if ((not is_string_like(x)) and iterable(x) and (len(x) == nrecs)): DCNL DCSP  DCSP  DCSP seqlist[i] = True DCNL DCSP  DCSP  DCSP if ma.isMA(x): DCNL DCSP  DCSP  DCSP  DCSP if (x.ndim > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Masked DCSP arrays DCSP must DCSP be DCSP 1-D') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP x = np.asarray(x) DCNL DCSP  DCSP margs.append(x) DCNL DCSP masks = [] DCNL DCSP for (i, x) in enumerate(margs): DCNL DCSP  DCSP if seqlist[i]: DCNL DCSP  DCSP  DCSP if (x.ndim > 1): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if ma.isMA(x): DCNL DCSP  DCSP  DCSP  DCSP masks.append((~ ma.getmaskarray(x))) DCNL DCSP  DCSP  DCSP  DCSP xd = x.data DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP xd = x DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP mask = np.isfinite(xd) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(mask, np.ndarray): DCNL DCSP  DCSP  DCSP  DCSP  DCSP masks.append(mask) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if len(masks): DCNL DCSP  DCSP mask = reduce(np.logical_and, masks) DCNL DCSP  DCSP igood = mask.nonzero()[0] DCNL DCSP  DCSP if (len(igood) < nrecs): DCNL DCSP  DCSP  DCSP for (i, x) in enumerate(margs): DCNL DCSP  DCSP  DCSP  DCSP if seqlist[i]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP margs[i] = x.take(igood, axis=0) DCNL DCSP for (i, x) in enumerate(margs): DCNL DCSP  DCSP if (seqlist[i] and ma.isMA(x)): DCNL DCSP  DCSP  DCSP margs[i] = x.filled() DCNL DCSP return margs
 DCSP mask = mask.reshape(mask.size) DCNL DCSP m = np.concatenate(((1,), mask, (1,))) DCNL DCSP indices = np.arange((len(mask) + 1)) DCNL DCSP mdif = (m[1:] - m[:(-1)]) DCNL DCSP i0 = np.compress((mdif == (-1)), indices) DCNL DCSP i1 = np.compress((mdif == 1), indices) DCNL DCSP assert (len(i0) == len(i1)) DCNL DCSP if (len(i1) == 0): DCNL DCSP  DCSP return None DCNL DCSP if (not compressed): DCNL DCSP  DCSP return np.concatenate((i0[:, np.newaxis], i1[:, np.newaxis]), axis=1) DCNL DCSP seglengths = (i1 - i0) DCNL DCSP breakpoints = np.cumsum(seglengths) DCNL DCSP ic0 = np.concatenate(((0,), breakpoints[:(-1)])) DCNL DCSP ic1 = breakpoints DCNL DCSP return np.concatenate((ic0[:, np.newaxis], ic1[:, np.newaxis]), axis=1)
 DCSP warnings.warn('less_simple_linear_interpolation DCSP has DCSP been DCSP moved DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there', DeprecationWarning) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.less_simple_linear_interpolation(x, y, xi, extrap=extrap)
 DCSP warnings.warn('isvector DCSP has DCSP been DCSP moved DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there', DeprecationWarning) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.isvector(x, y, xi, extrap=extrap)
 DCSP warnings.warn('vector_lengths DCSP has DCSP been DCSP moved DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there', DeprecationWarning) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.vector_lengths(X, P=2.0, axis=axis)
 DCSP warnings.warn('distances_along_curve DCSP has DCSP been DCSP moved DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there', DeprecationWarning) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.distances_along_curve(X)
 DCSP warnings.warn('path_length DCSP has DCSP been DCSP moved DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there', DeprecationWarning) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.path_length(X)
 DCSP warnings.warn('is_closed_polygon DCSP has DCSP been DCSP moved DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there', DeprecationWarning) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.is_closed_polygon(X)
 DCSP warnings.warn('quad2cubic DCSP has DCSP been DCSP moved DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there', DeprecationWarning) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.quad2cubic(q0x, q0y, q1x, q1y, q2x, q2y)
 DCSP _dict = {'which': which[0], 'module': module, 'specific': (version + module)} DCNL DCSP print ('\nThe DCSP import DCSP of DCSP the DCSP %(which)s DCSP version DCSP of DCSP the DCSP %(module)s DCSP module,\n%(specific)s, DCSP failed. DCSP  DCSP This DCSP is DCSP is DCSP either DCSP because DCSP %(which)s DCSP was\nunavailable DCSP when DCSP matplotlib DCSP was DCSP compiled, DCSP because DCSP a DCSP dependency DCSP of\n%(specific)s DCSP could DCSP not DCSP be DCSP satisfied, DCSP or DCSP because DCSP the DCSP build DCSP flag DCSP for\nthis DCSP module DCSP was DCSP turned DCSP off DCSP in DCSP setup.py. DCSP  DCSP If DCSP it DCSP appears DCSP that\n%(specific)s DCSP was DCSP not DCSP built, DCSP make DCSP sure DCSP you DCSP have DCSP a DCSP working DCSP copy DCSP of\n%(which)s DCSP and DCSP then DCSP re-install DCSP matplotlib. DCSP Otherwise, DCSP the DCSP following\ntraceback DCSP gives DCSP more DCSP details:\n' % _dict)
 DCSP return reshape(array([_isnan(i) for i in ravel(a)], 'b'), shape(a))
 DCSP if (axis is None): DCNL DCSP  DCSP return alltrue(ravel(a)) DCNL DCSP else: DCNL DCSP  DCSP return alltrue(a, axis)
 DCSP if (axis is None): DCNL DCSP  DCSP return _all(a) DCNL DCSP return alltrue(a, axis)
 DCSP if isinstance(data, type('')): DCNL DCSP  DCSP raise TypeError('numerix DCSP Matrix DCSP does DCSP not DCSP support DCSP Numeric DCSP matrix DCSP string DCSP notation. DCSP  DCSP Use DCSP nested DCSP lists.') DCNL DCSP a = fromlist(data, type=typecode) DCNL DCSP if (a.rank == 0): DCNL DCSP  DCSP a.shape = (1, 1) DCNL DCSP elif (a.rank == 1): DCNL DCSP  DCSP a.shape = ((1,) + a.shape) DCNL DCSP a.__class__ = _Matrix DCNL DCSP return a
 DCSP mask = (a <= 0.0) DCNL DCSP if mask.any(): DCNL DCSP  DCSP return ma.MaskedArray(a, mask=mask) DCNL DCSP return a
 DCSP scale = scale.lower() DCNL DCSP if (scale is None): DCNL DCSP  DCSP scale = 'linear' DCNL DCSP if (scale not in _scale_mapping): DCNL DCSP  DCSP raise ValueError(("Unknown DCSP scale DCSP type DCSP '%s'" % scale)) DCNL DCSP return _scale_mapping[scale](axis, **kwargs)
 DCSP _scale_mapping[scale_class.name] = scale_class
 DCSP docs = [] DCNL DCSP for name in get_scale_names(): DCNL DCSP  DCSP scale_class = _scale_mapping[name] DCNL DCSP  DCSP docs.append((" DCSP  DCSP  DCSP  DCSP '%s'" % name)) DCNL DCSP  DCSP docs.append('') DCNL DCSP  DCSP class_docs = dedent(scale_class.__init__.__doc__) DCNL DCSP  DCSP class_docs = ''.join([(' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s\n' % x) for x in class_docs.split('\n')]) DCNL DCSP  DCSP docs.append(class_docs) DCNL DCSP  DCSP docs.append('') DCNL DCSP return '\n'.join(docs)
 DCSP try: DCNL DCSP  DCSP (p + '') DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP t = tempfile.TemporaryFile(dir=p) DCNL DCSP  DCSP t.write('1') DCNL DCSP  DCSP t.close() DCNL DCSP except OSError: DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
 DCSP if a: DCNL DCSP  DCSP a = distutils.version.LooseVersion(a) DCNL DCSP  DCSP b = distutils.version.LooseVersion(b) DCNL DCSP  DCSP if (a >= b): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return False
 DCSP path = '' DCNL DCSP try: DCNL DCSP  DCSP path = os.path.expanduser('~') DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP for evar in ('HOME', 'USERPROFILE', 'TMP'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP path = os.environ[evar] DCNL DCSP  DCSP  DCSP  DCSP if os.path.isdir(path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if path: DCNL DCSP  DCSP return path DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('please DCSP define DCSP environment DCSP variable DCSP $HOME')
 DCSP configdir = os.environ.get('MPLCONFIGDIR') DCNL DCSP if (configdir is not None): DCNL DCSP  DCSP if (not _is_writable_dir(configdir)): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Could DCSP not DCSP write DCSP to DCSP MPLCONFIGDIR="%s"' % configdir)) DCNL DCSP  DCSP return configdir DCNL DCSP h = get_home() DCNL DCSP p = os.path.join(get_home(), '.matplotlib') DCNL DCSP if os.path.exists(p): DCNL DCSP  DCSP if (not _is_writable_dir(p)): DCNL DCSP  DCSP  DCSP raise RuntimeError(("'%s' DCSP is DCSP not DCSP a DCSP writable DCSP dir; DCSP you DCSP must DCSP set DCSP %s/.matplotlib DCSP to DCSP be DCSP a DCSP writable DCSP dir. DCSP  DCSP You DCSP can DCSP also DCSP set DCSP environment DCSP variable DCSP MPLCONFIGDIR DCSP to DCSP any DCSP writable DCSP directory DCSP where DCSP you DCSP want DCSP matplotlib DCSP data DCSP stored DCSP " % (h, h))) DCNL DCSP else: DCNL DCSP  DCSP if (not _is_writable_dir(h)): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Failed DCSP to DCSP create DCSP %s/.matplotlib; DCSP consider DCSP setting DCSP MPLCONFIGDIR DCSP to DCSP a DCSP writable DCSP directory DCSP for DCSP matplotlib DCSP configuration DCSP data' % h)) DCNL DCSP  DCSP os.mkdir(p) DCNL DCSP return p
 DCSP if ('MATPLOTLIBDATA' in os.environ): DCNL DCSP  DCSP path = os.environ['MATPLOTLIBDATA'] DCNL DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP raise RuntimeError('Path DCSP in DCSP environment DCSP MATPLOTLIBDATA DCSP not DCSP a DCSP directory') DCNL DCSP  DCSP return path DCNL DCSP path = os.sep.join([os.path.dirname(__file__), 'mpl-data']) DCNL DCSP if os.path.isdir(path): DCNL DCSP  DCSP return path DCNL DCSP import matplotlib.afm DCNL DCSP path = os.sep.join([os.path.dirname(matplotlib.afm.__file__), 'mpl-data']) DCNL DCSP if os.path.isdir(path): DCNL DCSP  DCSP return path DCNL DCSP if getattr(sys, 'frozen', None): DCNL DCSP  DCSP path = os.path.join(os.path.split(sys.path[0])[0], 'mpl-data') DCNL DCSP  DCSP if os.path.isdir(path): DCNL DCSP  DCSP  DCSP return path DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = os.path.join(os.path.split(os.path.split(sys.path[0])[0])[0], 'mpl-data') DCNL DCSP  DCSP if os.path.isdir(path): DCNL DCSP  DCSP  DCSP return path DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = os.path.join(sys.path[0], 'mpl-data') DCNL DCSP  DCSP  DCSP if os.path.isdir(path): DCNL DCSP  DCSP  DCSP  DCSP return path DCNL DCSP raise RuntimeError('Could DCSP not DCSP find DCSP the DCSP matplotlib DCSP data DCSP files')
 DCSP datadir = os.path.join(get_data_path(), 'example') DCNL DCSP fullpath = os.path.join(datadir, fname) DCNL DCSP if (not os.path.exists(fullpath)): DCNL DCSP  DCSP raise IOError(('could DCSP not DCSP find DCSP matplotlib DCSP example DCSP file DCSP "%s" DCSP in DCSP data DCSP directory DCSP "%s"' % (fname, datadir))) DCNL DCSP return file(fullpath, 'rb')
 DCSP oldname = os.path.join(os.getcwd(), '.matplotlibrc') DCNL DCSP if os.path.exists(oldname): DCNL DCSP  DCSP print >>sys.stderr, 'WARNING: DCSP Old DCSP rc DCSP filename DCSP ".matplotlibrc" DCSP found DCSP in DCSP working DCSP dir\n DCSP  DCSP and DCSP and DCSP renamed DCSP to DCSP new DCSP default DCSP rc DCSP file DCSP name DCSP "matplotlibrc"\n DCSP  DCSP (no DCSP leading"dot"). DCSP ' DCNL DCSP  DCSP shutil.move('.matplotlibrc', 'matplotlibrc') DCNL DCSP home = get_home() DCNL DCSP oldname = os.path.join(home, '.matplotlibrc') DCNL DCSP if os.path.exists(oldname): DCNL DCSP  DCSP configdir = get_configdir() DCNL DCSP  DCSP newname = os.path.join(configdir, 'matplotlibrc') DCNL DCSP  DCSP print >>sys.stderr, ('WARNING: DCSP Old DCSP rc DCSP filename DCSP "%s" DCSP found DCSP and DCSP renamed DCSP to\n DCSP  DCSP new DCSP default DCSP rc DCSP file DCSP name DCSP "%s".' % (oldname, newname)) DCNL DCSP  DCSP shutil.move(oldname, newname) DCNL DCSP fname = os.path.join(os.getcwd(), 'matplotlibrc') DCNL DCSP if os.path.exists(fname): DCNL DCSP  DCSP return fname DCNL DCSP if ('MATPLOTLIBRC' in os.environ): DCNL DCSP  DCSP path = os.environ['MATPLOTLIBRC'] DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP fname = os.path.join(path, 'matplotlibrc') DCNL DCSP  DCSP  DCSP if os.path.exists(fname): DCNL DCSP  DCSP  DCSP  DCSP return fname DCNL DCSP fname = os.path.join(get_configdir(), 'matplotlibrc') DCNL DCSP if os.path.exists(fname): DCNL DCSP  DCSP return fname DCNL DCSP path = get_data_path() DCNL DCSP fname = os.path.join(path, 'matplotlibrc') DCNL DCSP if (not os.path.exists(fname)): DCNL DCSP  DCSP warnings.warn('Could DCSP not DCSP find DCSP matplotlibrc; DCSP using DCSP defaults') DCNL DCSP return fname
 DCSP fname = matplotlib_fname() DCNL DCSP if (not os.path.exists(fname)): DCNL DCSP  DCSP message = 'could DCSP not DCSP find DCSP rc DCSP file; DCSP returning DCSP defaults' DCNL DCSP  DCSP ret = RcParams([(key, default) for (key, (default, converter)) in defaultParams.iteritems()]) DCNL DCSP  DCSP warnings.warn(message) DCNL DCSP  DCSP return ret DCNL DCSP cnt = 0 DCNL DCSP rc_temp = {} DCNL DCSP for line in file(fname): DCNL DCSP  DCSP cnt += 1 DCNL DCSP  DCSP strippedline = line.split('#', 1)[0].strip() DCNL DCSP  DCSP if (not strippedline): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tup = strippedline.split(':', 1) DCNL DCSP  DCSP if (len(tup) != 2): DCNL DCSP  DCSP  DCSP warnings.warn(('Illegal DCSP line DCSP #%d\n DCTB %s\n DCTB in DCSP file DCSP "%s"' % (cnt, line, fname))) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (key, val) = tup DCNL DCSP  DCSP key = key.strip() DCNL DCSP  DCSP val = val.strip() DCNL DCSP  DCSP if (key in rc_temp): DCNL DCSP  DCSP  DCSP warnings.warn(('Duplicate DCSP key DCSP in DCSP file DCSP "%s", DCSP line DCSP #%d' % (fname, cnt))) DCNL DCSP  DCSP rc_temp[key] = (val, line, cnt) DCNL DCSP ret = RcParams([(key, default) for (key, (default, converter)) in defaultParams.iteritems()]) DCNL DCSP for key in ('verbose.level', 'verbose.fileo'): DCNL DCSP  DCSP if (key in rc_temp): DCNL DCSP  DCSP  DCSP (val, line, cnt) = rc_temp.pop(key) DCNL DCSP  DCSP  DCSP if fail_on_error: DCNL DCSP  DCSP  DCSP  DCSP ret[key] = val DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret[key] = val DCNL DCSP  DCSP  DCSP  DCSP except Exception as msg: DCNL DCSP  DCSP  DCSP  DCSP  DCSP warnings.warn(('Bad DCSP val DCSP "%s" DCSP on DCSP line DCSP #%d\n DCTB "%s"\n DCTB in DCSP file DCSP "%s"\n DCTB %s' % (val, cnt, line, fname, msg))) DCNL DCSP verbose.set_level(ret['verbose.level']) DCNL DCSP verbose.set_fileo(ret['verbose.fileo']) DCNL DCSP for (key, (val, line, cnt)) in rc_temp.iteritems(): DCNL DCSP  DCSP if (key in defaultParams): DCNL DCSP  DCSP  DCSP if fail_on_error: DCNL DCSP  DCSP  DCSP  DCSP ret[key] = val DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret[key] = val DCNL DCSP  DCSP  DCSP  DCSP except Exception as msg: DCNL DCSP  DCSP  DCSP  DCSP  DCSP warnings.warn(('Bad DCSP val DCSP "%s" DCSP on DCSP line DCSP #%d\n DCTB "%s"\n DCTB in DCSP file DCSP "%s"\n DCTB %s' % (val, cnt, line, fname, msg))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('\nBad DCSP key DCSP "%s" DCSP on DCSP line DCSP %d DCSP in\n%s.\nYou DCSP probably DCSP need DCSP to DCSP get DCSP an DCSP updated DCSP matplotlibrc DCSP file DCSP from\nhttp://matplotlib.sf.net/_static/matplotlibrc DCSP or DCSP from DCSP the DCSP matplotlib DCSP source\ndistribution' % (key, cnt, fname)) DCNL DCSP if (ret['datapath'] is None): DCNL DCSP  DCSP ret['datapath'] = get_data_path() DCNL DCSP if (not (ret['text.latex.preamble'] == [''])): DCNL DCSP  DCSP verbose.report(('\n*****************************************************************\nYou DCSP have DCSP the DCSP following DCSP UNSUPPORTED DCSP LaTeX DCSP preamble DCSP customizations:\n%s\nPlease DCSP do DCSP not DCSP ask DCSP for DCSP support DCSP with DCSP these DCSP customizations DCSP active.\n*****************************************************************\n' % '\n'.join(ret['text.latex.preamble'])), 'helpful') DCNL DCSP verbose.report(('loaded DCSP rc DCSP file DCSP %s' % fname)) DCNL DCSP return ret
 DCSP aliases = {'lw': 'linewidth', 'ls': 'linestyle', 'c': 'color', 'fc': 'facecolor', 'ec': 'edgecolor', 'mew': 'markeredgewidth', 'aa': 'antialiased'} DCNL DCSP if is_string_like(group): DCNL DCSP  DCSP group = (group,) DCNL DCSP for g in group: DCNL DCSP  DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP  DCSP name = (aliases.get(k) or k) DCNL DCSP  DCSP  DCSP key = ('%s.%s' % (g, name)) DCNL DCSP  DCSP  DCSP if (key not in rcParams): DCNL DCSP  DCSP  DCSP  DCSP raise KeyError(('Unrecognized DCSP key DCSP "%s" DCSP for DCSP group DCSP "%s" DCSP and DCSP name DCSP "%s"' % (key, g, name))) DCNL DCSP  DCSP  DCSP rcParams[key] = v
 DCSP rcParams.update(rcParamsDefault)
 DCSP if ('matplotlib.backends' in sys.modules): DCNL DCSP  DCSP if warn: DCNL DCSP  DCSP  DCSP warnings.warn(_use_error_msg) DCNL DCSP  DCSP return DCNL DCSP arg = arg.lower() DCNL DCSP if arg.startswith('module://'): DCNL DCSP  DCSP name = arg DCNL DCSP else: DCNL DCSP  DCSP be_parts = arg.split('.') DCNL DCSP  DCSP name = validate_backend(be_parts[0]) DCNL DCSP rcParams['backend'] = name DCNL DCSP if ((name == 'cairo') and (len(be_parts) > 1)): DCNL DCSP  DCSP rcParams['cairo.format'] = validate_cairo_format(be_parts[1])
 DCSP return rcParams['backend']
 DCSP rcParams['interactive'] = b
 DCSP b = rcParams['interactive'] DCNL DCSP return b
 DCSP if (rcParams['backend'] != 'TkAgg'): DCNL DCSP  DCSP return False DCNL DCSP return rcParams['tk.window_focus']
 DCSP line1_rhs = ((sin_t1 * cx1) - (cos_t1 * cy1)) DCNL DCSP line2_rhs = ((sin_t2 * cx2) - (cos_t2 * cy2)) DCNL DCSP (a, b) = (sin_t1, (- cos_t1)) DCNL DCSP (c, d) = (sin_t2, (- cos_t2)) DCNL DCSP ad_bc = ((a * d) - (b * c)) DCNL DCSP if (ad_bc == 0.0): DCNL DCSP  DCSP raise ValueError('Given DCSP lines DCSP do DCSP not DCSP intersect') DCNL DCSP (a_, b_) = (d, (- b)) DCNL DCSP (c_, d_) = ((- c), a) DCNL DCSP (a_, b_, c_, d_) = [(k / ad_bc) for k in [a_, b_, c_, d_]] DCNL DCSP x = ((a_ * line1_rhs) + (b_ * line2_rhs)) DCNL DCSP y = ((c_ * line1_rhs) + (d_ * line2_rhs)) DCNL DCSP return (x, y)
 DCSP if (length == 0.0): DCNL DCSP  DCSP return (cx, cy, cx, cy) DCNL DCSP (cos_t1, sin_t1) = (sin_t, (- cos_t)) DCNL DCSP (cos_t2, sin_t2) = ((- sin_t), cos_t) DCNL DCSP (x1, y1) = (((length * cos_t1) + cx), ((length * sin_t1) + cy)) DCNL DCSP (x2, y2) = (((length * cos_t2) + cx), ((length * sin_t2) + cy)) DCNL DCSP return (x1, y1, x2, y2)
 DCSP beta = np.asarray(beta) DCNL DCSP beta_list = [beta] DCNL DCSP while True: DCNL DCSP  DCSP beta = _de_casteljau1(beta, t) DCNL DCSP  DCSP beta_list.append(beta) DCNL DCSP  DCSP if (len(beta) == 1): DCNL DCSP  DCSP  DCSP break DCNL DCSP left_beta = [beta[0] for beta in beta_list] DCNL DCSP right_beta = [beta[(-1)] for beta in reversed(beta_list)] DCNL DCSP return (left_beta, right_beta)
 DCSP start = bezier_point_at_t(t0) DCNL DCSP end = bezier_point_at_t(t1) DCNL DCSP start_inside = inside_closedpath(start) DCNL DCSP end_inside = inside_closedpath(end) DCNL DCSP if (not xor(start_inside, end_inside)): DCNL DCSP  DCSP raise ValueError('the DCSP segment DCSP does DCSP not DCSP seemed DCSP to DCSP intersect DCSP with DCSP the DCSP path') DCNL DCSP while 1: DCNL DCSP  DCSP if ((((start[0] - end[0]) ** 2) + ((start[1] - end[1]) ** 2)) < (tolerence ** 2)): DCNL DCSP  DCSP  DCSP return (t0, t1) DCNL DCSP  DCSP middle_t = (0.5 * (t0 + t1)) DCNL DCSP  DCSP middle = bezier_point_at_t(middle_t) DCNL DCSP  DCSP middle_inside = inside_closedpath(middle) DCNL DCSP  DCSP if xor(start_inside, middle_inside): DCNL DCSP  DCSP  DCSP t1 = middle_t DCNL DCSP  DCSP  DCSP end = middle DCNL DCSP  DCSP  DCSP end_inside = middle_inside DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP t0 = middle_t DCNL DCSP  DCSP  DCSP start = middle DCNL DCSP  DCSP  DCSP start_inside = middle_inside
 DCSP bz = BezierSegment(bezier) DCNL DCSP bezier_point_at_t = bz.point_at_t DCNL DCSP (t0, t1) = find_bezier_t_intersecting_with_closedpath(bezier_point_at_t, inside_closedpath, tolerence=tolerence) DCNL DCSP (_left, _right) = split_de_casteljau(bezier, ((t0 + t1) / 2.0)) DCNL DCSP return (_left, _right)
 DCSP (cx, cy) = xy DCNL DCSP def _f(r): DCNL DCSP  DCSP return (((cos_t * r) + cx), ((sin_t * r) + cy)) DCNL DCSP find_bezier_t_intersecting_with_closedpath(_f, inside_closedpath, t0=rmin, t1=rmax, tolerence=tolerence)
 DCSP path_iter = path.iter_segments() DCNL DCSP (ctl_points, command) = path_iter.next() DCNL DCSP begin_inside = inside(ctl_points[(-2):]) DCNL DCSP bezier_path = None DCNL DCSP ctl_points_old = ctl_points DCNL DCSP concat = np.concatenate DCNL DCSP iold = 0 DCNL DCSP i = 1 DCNL DCSP for (ctl_points, command) in path_iter: DCNL DCSP  DCSP iold = i DCNL DCSP  DCSP i += (len(ctl_points) / 2) DCNL DCSP  DCSP if (inside(ctl_points[(-2):]) != begin_inside): DCNL DCSP  DCSP  DCSP bezier_path = concat([ctl_points_old[(-2):], ctl_points]) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP ctl_points_old = ctl_points DCNL DCSP if (bezier_path is None): DCNL DCSP  DCSP raise ValueError('The DCSP path DCSP does DCSP not DCSP seem DCSP to DCSP intersect DCSP with DCSP the DCSP patch') DCNL DCSP bp = zip(bezier_path[::2], bezier_path[1::2]) DCNL DCSP (left, right) = split_bezier_intersecting_with_closedpath(bp, inside, tolerence) DCNL DCSP if (len(left) == 2): DCNL DCSP  DCSP codes_left = [Path.LINETO] DCNL DCSP  DCSP codes_right = [Path.MOVETO, Path.LINETO] DCNL DCSP elif (len(left) == 3): DCNL DCSP  DCSP codes_left = [Path.CURVE3, Path.CURVE3] DCNL DCSP  DCSP codes_right = [Path.MOVETO, Path.CURVE3, Path.CURVE3] DCNL DCSP elif (len(left) == 4): DCNL DCSP  DCSP codes_left = [Path.CURVE4, Path.CURVE4, Path.CURVE4] DCNL DCSP  DCSP codes_right = [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4] DCNL DCSP else: DCNL DCSP  DCSP raise ValueError() DCNL DCSP verts_left = left[1:] DCNL DCSP verts_right = right[:] DCNL DCSP if (path.codes is None): DCNL DCSP  DCSP path_in = Path(concat([path.vertices[:i], verts_left])) DCNL DCSP  DCSP path_out = Path(concat([verts_right, path.vertices[i:]])) DCNL DCSP else: DCNL DCSP  DCSP path_in = Path(concat([path.vertices[:iold], verts_left]), concat([path.codes[:iold], codes_left])) DCNL DCSP  DCSP path_out = Path(concat([verts_right, path.vertices[i:]]), concat([codes_right, path.codes[i:]])) DCNL DCSP if (reorder_inout and (begin_inside == False)): DCNL DCSP  DCSP (path_in, path_out) = (path_out, path_in) DCNL DCSP return (path_in, path_out)
 DCSP (c1x, c1y) = bezier2[0] DCNL DCSP (cmx, cmy) = bezier2[1] DCNL DCSP (c2x, c2y) = bezier2[2] DCNL DCSP (cos_t1, sin_t1) = get_cos_sin(c1x, c1y, cmx, cmy) DCNL DCSP (cos_t2, sin_t2) = get_cos_sin(cmx, cmy, c2x, c2y) DCNL DCSP (c1x_left, c1y_left, c1x_right, c1y_right) = get_normal_points(c1x, c1y, cos_t1, sin_t1, width) DCNL DCSP (c2x_left, c2y_left, c2x_right, c2y_right) = get_normal_points(c2x, c2y, cos_t2, sin_t2, width) DCNL DCSP (cmx_left, cmy_left) = get_intersection(c1x_left, c1y_left, cos_t1, sin_t1, c2x_left, c2y_left, cos_t2, sin_t2) DCNL DCSP (cmx_right, cmy_right) = get_intersection(c1x_right, c1y_right, cos_t1, sin_t1, c2x_right, c2y_right, cos_t2, sin_t2) DCNL DCSP path_left = [(c1x_left, c1y_left), (cmx_left, cmy_left), (c2x_left, c2y_left)] DCNL DCSP path_right = [(c1x_right, c1y_right), (cmx_right, cmy_right), (c2x_right, c2y_right)] DCNL DCSP return (path_left, path_right)
 DCSP (xx1, yy1) = bezier2[2] DCNL DCSP (xx2, yy2) = bezier2[1] DCNL DCSP (xx3, yy3) = bezier2[0] DCNL DCSP (cx, cy) = (xx3, yy3) DCNL DCSP (x0, y0) = (xx2, yy2) DCNL DCSP dist = sqrt((((x0 - cx) ** 2) + ((y0 - cy) ** 2))) DCNL DCSP (cos_t, sin_t) = (((x0 - cx) / dist), ((y0 - cy) / dist)) DCNL DCSP (x1, y1, x2, y2) = get_normal_points(cx, cy, cos_t, sin_t, length) DCNL DCSP (xx12, yy12) = (((xx1 + xx2) / 2.0), ((yy1 + yy2) / 2.0)) DCNL DCSP (xx23, yy23) = (((xx2 + xx3) / 2.0), ((yy2 + yy3) / 2.0)) DCNL DCSP dist = sqrt((((xx12 - xx23) ** 2) + ((yy12 - yy23) ** 2))) DCNL DCSP (cos_t, sin_t) = (((xx12 - xx23) / dist), ((yy12 - yy23) / dist)) DCNL DCSP (xm1, ym1, xm2, ym2) = get_normal_points(xx2, yy2, cos_t, sin_t, (length * shrink_factor)) DCNL DCSP l_plus = [(x1, y1), (xm1, ym1), (xx1, yy1)] DCNL DCSP l_minus = [(x2, y2), (xm2, ym2), (xx1, yy1)] DCNL DCSP return (l_plus, l_minus)
 DCSP cmx = (0.5 * ((4 * mmx) - (c1x + c2x))) DCNL DCSP cmy = (0.5 * ((4 * mmy) - (c1y + c2y))) DCNL DCSP return [(c1x, c1y), (cmx, cmy), (c2x, c2y)]
 DCSP (c1x, c1y) = bezier2[0] DCNL DCSP (cmx, cmy) = bezier2[1] DCNL DCSP (c3x, c3y) = bezier2[2] DCNL DCSP (cos_t1, sin_t1) = get_cos_sin(c1x, c1y, cmx, cmy) DCNL DCSP (cos_t2, sin_t2) = get_cos_sin(cmx, cmy, c3x, c3y) DCNL DCSP (c1x_left, c1y_left, c1x_right, c1y_right) = get_normal_points(c1x, c1y, cos_t1, sin_t1, (width * w1)) DCNL DCSP (c3x_left, c3y_left, c3x_right, c3y_right) = get_normal_points(c3x, c3y, cos_t2, sin_t2, (width * w2)) DCNL DCSP (c12x, c12y) = (((c1x + cmx) * 0.5), ((c1y + cmy) * 0.5)) DCNL DCSP (c23x, c23y) = (((cmx + c3x) * 0.5), ((cmy + c3y) * 0.5)) DCNL DCSP (c123x, c123y) = (((c12x + c23x) * 0.5), ((c12y + c23y) * 0.5)) DCNL DCSP (cos_t123, sin_t123) = get_cos_sin(c12x, c12y, c23x, c23y) DCNL DCSP (c123x_left, c123y_left, c123x_right, c123y_right) = get_normal_points(c123x, c123y, cos_t123, sin_t123, (width * wm)) DCNL DCSP path_left = find_control_points(c1x_left, c1y_left, c123x_left, c123y_left, c3x_left, c3y_left) DCNL DCSP path_right = find_control_points(c1x_right, c1y_right, c123x_right, c123y_right, c3x_right, c3y_right) DCNL DCSP return (path_left, path_right)
 DCSP from transforms import Bbox DCNL DCSP if (len(args[1]) == 0): DCNL DCSP  DCSP raise ValueError('No DCSP paths DCSP provided') DCNL DCSP return Bbox.from_extents(*_get_path_collection_extents(*args))
 DCSP if (symbol == '-'): DCNL DCSP  DCSP return 8722 DCNL DCSP try: DCNL DCSP  DCSP return ord(symbol) DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return tex2uni[symbol.strip('\\')] DCNL DCSP except KeyError: DCNL DCSP  DCSP message = ("'%(symbol)s' DCSP is DCSP not DCSP a DCSP valid DCSP Unicode DCSP character DCSP or\nTeX/Type1 DCSP symbol" % locals()) DCNL DCSP  DCSP raise ValueError, message
 DCSP return MathtextBackendBbox(MathtextBackendBitmapRender())
 DCSP def raise_error(s, loc, toks): DCNL DCSP  DCSP raise ParseFatalException(((msg + '\n') + s)) DCNL DCSP empty = Empty() DCNL DCSP empty.setParseAction(raise_error) DCNL DCSP return empty
 DCSP try: DCNL DCSP  DCSP colorConverter.to_rgb(c) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
 DCSP return ('#%02x%02x%02x' % tuple([round((val * 255)) for val in rgb]))
 DCSP if (not isinstance(s, basestring)): DCNL DCSP  DCSP raise TypeError('hex2color DCSP requires DCSP a DCSP string DCSP argument') DCNL DCSP if (hexColorPattern.match(s) is None): DCNL DCSP  DCSP raise ValueError(('invalid DCSP hex DCSP color DCSP string DCSP "%s"' % s)) DCNL DCSP return tuple([(int(n, 16) / 255.0) for n in (s[1:3], s[3:5], s[5:7])])
 DCSP try: DCNL DCSP  DCSP adata = np.array(data) DCNL DCSP except: DCNL DCSP  DCSP raise TypeError('data DCSP must DCSP be DCSP convertable DCSP to DCSP an DCSP array') DCNL DCSP shape = adata.shape DCNL DCSP if ((len(shape) != 2) and (shape[1] != 3)): DCNL DCSP  DCSP raise ValueError('data DCSP must DCSP be DCSP nx3 DCSP format') DCNL DCSP x = adata[:, 0] DCNL DCSP y0 = adata[:, 1] DCNL DCSP y1 = adata[:, 2] DCNL DCSP if ((x[0] != 0.0) or (x[(-1)] != 1.0)): DCNL DCSP  DCSP raise ValueError('data DCSP mapping DCSP points DCSP must DCSP start DCSP with DCSP x=0. DCSP and DCSP end DCSP with DCSP x=1') DCNL DCSP if np.sometrue((np.sort(x) - x)): DCNL DCSP  DCSP raise ValueError('data DCSP mapping DCSP points DCSP must DCSP have DCSP x DCSP in DCSP increasing DCSP order') DCNL DCSP x = (x * (N - 1)) DCNL DCSP lut = np.zeros((N,), np.float) DCNL DCSP xind = np.arange(float(N)) DCNL DCSP ind = np.searchsorted(x, xind)[1:(-1)] DCNL DCSP lut[1:(-1)] = ((((xind[1:(-1)] - x[(ind - 1)]) / (x[ind] - x[(ind - 1)])) * (y0[ind] - y1[(ind - 1)])) + y1[(ind - 1)]) DCNL DCSP lut[0] = y1[0] DCNL DCSP lut[(-1)] = y0[(-1)] DCNL DCSP np.clip(lut, 0.0, 1.0) DCNL DCSP return lut
 DCSP if (name is None): DCNL DCSP  DCSP name = mpl.rcParams['image.cmap'] DCNL DCSP if (lut is None): DCNL DCSP  DCSP lut = mpl.rcParams['image.lut'] DCNL DCSP assert (name in datad.keys()) DCNL DCSP return colors.LinearSegmentedColormap(name, datad[name], lut)
 DCSP if os.path.exists(s): DCNL DCSP  DCSP return s DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(('"%s" DCSP should DCSP be DCSP a DCSP path DCSP but DCSP it DCSP does DCSP not DCSP exist' % s))
 DCSP if (type(b) is str): DCNL DCSP  DCSP b = b.lower() DCNL DCSP if (b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True)): DCNL DCSP  DCSP return True DCNL DCSP elif (b in ('f', 'n', 'no', 'off', 'false', '0', 0, False)): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Could DCSP not DCSP convert DCSP "%s" DCSP to DCSP boolean' % b))
 DCSP if (type(b) is str): DCNL DCSP  DCSP b = b.lower() DCNL DCSP if (b == 'none'): DCNL DCSP  DCSP return None DCNL DCSP if (b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True)): DCNL DCSP  DCSP return True DCNL DCSP elif (b in ('f', 'n', 'no', 'off', 'false', '0', 0, False)): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Could DCSP not DCSP convert DCSP "%s" DCSP to DCSP boolean' % b))
 DCSP try: DCNL DCSP  DCSP return float(s) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(('Could DCSP not DCSP convert DCSP "%s" DCSP to DCSP float' % s))
 DCSP try: DCNL DCSP  DCSP return int(s) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(('Could DCSP not DCSP convert DCSP "%s" DCSP to DCSP int' % s))
 DCSP fonttypes = {'type3': 3, 'truetype': 42} DCNL DCSP try: DCNL DCSP  DCSP fonttype = validate_int(s) DCNL DCSP except ValueError: DCNL DCSP  DCSP if (s.lower() in fonttypes.keys()): DCNL DCSP  DCSP  DCSP return fonttypes[s.lower()] DCNL DCSP  DCSP raise ValueError(('Supported DCSP Postscript/PDF DCSP font DCSP types DCSP are DCSP %s' % fonttypes.keys())) DCNL DCSP else: DCNL DCSP  DCSP if (fonttype not in fonttypes.values()): DCNL DCSP  DCSP  DCSP raise ValueError(('Supported DCSP Postscript/PDF DCSP font DCSP types DCSP are DCSP %s' % fonttypes.values())) DCNL DCSP  DCSP return fonttype
 DCSP if (s.lower() == 'none'): DCNL DCSP  DCSP return 'None' DCNL DCSP if is_color_like(s): DCNL DCSP  DCSP return s DCNL DCSP stmp = ('#' + s) DCNL DCSP if is_color_like(stmp): DCNL DCSP  DCSP return stmp DCNL DCSP colorarg = s DCNL DCSP msg = '' DCNL DCSP if (s.find(',') >= 0): DCNL DCSP  DCSP stmp = ''.join([c for c in s if (c.isdigit() or (c == '.') or (c == ','))]) DCNL DCSP  DCSP vals = stmp.split(',') DCNL DCSP  DCSP if (len(vals) != 3): DCNL DCSP  DCSP  DCSP msg = '\nColor DCSP tuples DCSP must DCSP be DCSP length DCSP 3' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP colorarg = [float(val) for val in vals] DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP msg = '\nCould DCSP not DCSP convert DCSP all DCSP entries DCSP to DCSP floats' DCNL DCSP if ((not msg) and is_color_like(colorarg)): DCNL DCSP  DCSP return colorarg DCNL DCSP raise ValueError(('%s DCSP does DCSP not DCSP look DCSP like DCSP a DCSP color DCSP arg%s' % (s, msg)))
 DCSP if (type(s) is str): DCNL DCSP  DCSP return [v.strip() for v in s.split(',')] DCNL DCSP else: DCNL DCSP  DCSP assert (type(s) in [list, tuple]) DCNL DCSP  DCSP return [str(v) for v in s]
 DCSP if (projection is None): DCNL DCSP  DCSP projection = 'rectilinear' DCNL DCSP try: DCNL DCSP  DCSP return projection_registry.get_projection_class(projection) DCNL DCSP except KeyError: DCNL DCSP  DCSP raise ValueError(("Unknown DCSP projection DCSP '%s'" % projection))
 DCSP return get_projection_class(projection)(figure, rect, **kwargs)
 DCSP return projection_registry.get_projection_names()
 DCSP isarray = hasattr(arg, 'shape') DCNL DCSP figsize_min = np.array((4.0, 2.0)) DCNL DCSP figsize_max = np.array((16.0, 16.0)) DCNL DCSP if isarray: DCNL DCSP  DCSP (nr, nc) = arg.shape[:2] DCNL DCSP  DCSP arr_ratio = (float(nr) / nc) DCNL DCSP else: DCNL DCSP  DCSP arr_ratio = float(arg) DCNL DCSP fig_height = rcParams['figure.figsize'][1] DCNL DCSP newsize = np.array(((fig_height / arr_ratio), fig_height)) DCNL DCSP newsize /= min(1.0, *(newsize / figsize_min)) DCNL DCSP newsize /= max(1.0, *(newsize / figsize_max)) DCNL DCSP newsize = np.clip(newsize, figsize_min, figsize_max) DCNL DCSP return newsize
 DCSP backend = rcParams['backend'] DCNL DCSP if ((not rcParams['backend_fallback']) or (backend not in _interactive_bk)): DCNL DCSP  DCSP return DCNL DCSP is_agg_backend = rcParams['backend'].endswith('Agg') DCNL DCSP if (('wx' in sys.modules) and (not (backend in ('WX', 'WXAgg')))): DCNL DCSP  DCSP import wx DCNL DCSP  DCSP if wx.App.IsMainLoopRunning(): DCNL DCSP  DCSP  DCSP rcParams['backend'] = ('wx' + ('Agg' * is_agg_backend)) DCNL DCSP elif (('qt' in sys.modules) and (not (backend == 'QtAgg'))): DCNL DCSP  DCSP import qt DCNL DCSP  DCSP if (not qt.qApp.startingUp()): DCNL DCSP  DCSP  DCSP rcParams['backend'] = 'qtAgg' DCNL DCSP elif (('PyQt4.QtCore' in sys.modules) and (not (backend == 'Qt4Agg'))): DCNL DCSP  DCSP import PyQt4.QtGui DCNL DCSP  DCSP if (not PyQt4.QtGui.qApp.startingUp()): DCNL DCSP  DCSP  DCSP rcParams['backend'] = 'qt4Agg' DCNL DCSP elif (('gtk' in sys.modules) and (not (backend in ('GTK', 'GTKAgg', 'GTKCairo')))): DCNL DCSP  DCSP import gobject DCNL DCSP  DCSP if gobject.MainLoop().is_running(): DCNL DCSP  DCSP  DCSP rcParams['backend'] = ('gtk' + ('Agg' * is_agg_backend)) DCNL DCSP elif (('Tkinter' in sys.modules) and (not (backend == 'TkAgg'))): DCNL DCSP  DCSP pass
 DCSP close('all') DCNL DCSP global new_figure_manager, draw_if_interactive, show DCNL DCSP matplotlib.use(newbackend, warn=False) DCNL DCSP reload(matplotlib.backends) DCNL DCSP from matplotlib.backends import pylab_setup DCNL DCSP (new_figure_manager, draw_if_interactive, show) = pylab_setup()
 DCSP return matplotlib.is_interactive()
 DCSP matplotlib.interactive(False)
 DCSP matplotlib.interactive(True)
 DCSP return gci._current
 DCSP gci._current = im
 DCSP if (figsize is None): DCNL DCSP  DCSP figsize = rcParams['figure.figsize'] DCNL DCSP if (dpi is None): DCNL DCSP  DCSP dpi = rcParams['figure.dpi'] DCNL DCSP if (facecolor is None): DCNL DCSP  DCSP facecolor = rcParams['figure.facecolor'] DCNL DCSP if (edgecolor is None): DCNL DCSP  DCSP edgecolor = rcParams['figure.edgecolor'] DCNL DCSP if (num is None): DCNL DCSP  DCSP allnums = [f.num for f in _pylab_helpers.Gcf.get_all_fig_managers()] DCNL DCSP  DCSP if allnums: DCNL DCSP  DCSP  DCSP num = (max(allnums) + 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP num = 1 DCNL DCSP else: DCNL DCSP  DCSP num = int(num) DCNL DCSP figManager = _pylab_helpers.Gcf.get_fig_manager(num) DCNL DCSP if (figManager is None): DCNL DCSP  DCSP if (get_backend().lower() == 'ps'): DCNL DCSP  DCSP  DCSP dpi = 72 DCNL DCSP  DCSP figManager = new_figure_manager(num, figsize=figsize, dpi=dpi, facecolor=facecolor, edgecolor=edgecolor, frameon=frameon, FigureClass=FigureClass, **kwargs) DCNL DCSP  DCSP def make_active(event): DCNL DCSP  DCSP  DCSP _pylab_helpers.Gcf.set_active(figManager) DCNL DCSP  DCSP cid = figManager.canvas.mpl_connect('button_press_event', make_active) DCNL DCSP  DCSP figManager._cidgcf = cid DCNL DCSP  DCSP _pylab_helpers.Gcf.set_active(figManager) DCNL DCSP  DCSP figManager.canvas.figure.number = num DCNL DCSP draw_if_interactive() DCNL DCSP return figManager.canvas.figure
 DCSP figManager = _pylab_helpers.Gcf.get_active() DCNL DCSP if (figManager is not None): DCNL DCSP  DCSP return figManager.canvas.figure DCNL DCSP else: DCNL DCSP  DCSP return figure()
 DCSP if (len(args) == 0): DCNL DCSP  DCSP figManager = _pylab_helpers.Gcf.get_active() DCNL DCSP  DCSP if (figManager is None): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP figManager.canvas.mpl_disconnect(figManager._cidgcf) DCNL DCSP  DCSP  DCSP _pylab_helpers.Gcf.destroy(figManager.num) DCNL DCSP elif (len(args) == 1): DCNL DCSP  DCSP arg = args[0] DCNL DCSP  DCSP if (arg == 'all'): DCNL DCSP  DCSP  DCSP for manager in _pylab_helpers.Gcf.get_all_fig_managers(): DCNL DCSP  DCSP  DCSP  DCSP manager.canvas.mpl_disconnect(manager._cidgcf) DCNL DCSP  DCSP  DCSP  DCSP _pylab_helpers.Gcf.destroy(manager.num) DCNL DCSP  DCSP elif isinstance(arg, int): DCNL DCSP  DCSP  DCSP _pylab_helpers.Gcf.destroy(arg) DCNL DCSP  DCSP elif isinstance(arg, Figure): DCNL DCSP  DCSP  DCSP for manager in _pylab_helpers.Gcf.get_all_fig_managers(): DCNL DCSP  DCSP  DCSP  DCSP if (manager.canvas.figure == arg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP manager.canvas.mpl_disconnect(manager._cidgcf) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _pylab_helpers.Gcf.destroy(manager.num) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(('Unrecognized DCSP argument DCSP type DCSP %s DCSP to DCSP close' % type(arg))) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('close DCSP takes DCSP 0 DCSP or DCSP 1 DCSP arguments')
 DCSP gcf().clf() DCNL DCSP draw_if_interactive()
 DCSP get_current_fig_manager().canvas.draw()
 DCSP return gcf().ginput(*args, **kwargs)
 DCSP return gcf().waitforbuttonpress(*args, **kwargs)
 DCSP l = gcf().legend(handles, labels, loc, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return l
 DCSP fig = gcf() DCNL DCSP ax = fig.gca() DCNL DCSP fig.hold(b) DCNL DCSP ax.hold(b) DCNL DCSP b = ax.ishold() DCNL DCSP rc('axes', hold=b)
 DCSP return gca().ishold()
 DCSP h = ishold() DCNL DCSP hold(True) DCNL DCSP func(*args, **kwargs) DCNL DCSP hold(h)
 DCSP nargs = len(args) DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP return subplot(111, **kwargs) DCNL DCSP if (nargs > 1): DCNL DCSP  DCSP raise TypeError('Only DCSP one DCSP non DCSP keyword DCSP arg DCSP to DCSP axes DCSP allowed') DCNL DCSP arg = args[0] DCNL DCSP if isinstance(arg, Axes): DCNL DCSP  DCSP a = gcf().sca(arg) DCNL DCSP else: DCNL DCSP  DCSP rect = arg DCNL DCSP  DCSP a = gcf().add_axes(rect, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return a
 DCSP if (not len(args)): DCNL DCSP  DCSP ax = gca() DCNL DCSP else: DCNL DCSP  DCSP ax = args[0] DCNL DCSP ret = gcf().delaxes(ax) DCNL DCSP draw_if_interactive() DCNL DCSP return ret
 DCSP ax = gcf().gca(**kwargs) DCNL DCSP return ax
 DCSP fig = gcf() DCNL DCSP a = fig.add_subplot(*args, **kwargs) DCNL DCSP bbox = a.bbox DCNL DCSP byebye = [] DCNL DCSP for other in fig.axes: DCNL DCSP  DCSP if (other == a): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if bbox.fully_overlaps(other.bbox): DCNL DCSP  DCSP  DCSP byebye.append(other) DCNL DCSP for ax in byebye: DCNL DCSP  DCSP delaxes(ax) DCNL DCSP draw_if_interactive() DCNL DCSP return a
 DCSP if (ax is None): DCNL DCSP  DCSP ax = gca() DCNL DCSP ax1 = ax.twinx() DCNL DCSP draw_if_interactive() DCNL DCSP return ax1
 DCSP if (ax is None): DCNL DCSP  DCSP ax = gca() DCNL DCSP ax1 = ax.twiny() DCNL DCSP draw_if_interactive() DCNL DCSP return ax1
 DCSP fig = gcf() DCNL DCSP fig.subplots_adjust(*args, **kwargs) DCNL DCSP draw_if_interactive()
 DCSP tbar = rcParams['toolbar'] DCNL DCSP rcParams['toolbar'] = 'None' DCNL DCSP if (targetfig is None): DCNL DCSP  DCSP manager = get_current_fig_manager() DCNL DCSP  DCSP targetfig = manager.canvas.figure DCNL DCSP else: DCNL DCSP  DCSP for manager in _pylab_helpers.Gcf._activeQue: DCNL DCSP  DCSP  DCSP if (manager.canvas.figure == targetfig): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError('Could DCSP not DCSP find DCSP manager DCSP for DCSP targetfig') DCNL DCSP toolfig = figure(figsize=(6, 3)) DCNL DCSP toolfig.subplots_adjust(top=0.9) DCNL DCSP ret = SubplotTool(targetfig, toolfig) DCNL DCSP rcParams['toolbar'] = tbar DCNL DCSP _pylab_helpers.Gcf.set_active(manager) DCNL DCSP return ret
 DCSP ax = gca() DCNL DCSP if (on is None): DCNL DCSP  DCSP on = (not ax.get_frame_on()) DCNL DCSP ax.set_frame_on(on) DCNL DCSP draw_if_interactive()
 DCSP l = gca().set_title(s, *args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return l
 DCSP ax = gca() DCNL DCSP v = ax.axis(*v, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return v
 DCSP l = gca().set_xlabel(s, *args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return l
 DCSP l = gca().set_ylabel(s, *args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return l
 DCSP ax = gca() DCNL DCSP ret = ax.set_xlim(*args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return ret
 DCSP ax = gca() DCNL DCSP ret = ax.set_ylim(*args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return ret
 DCSP ax = gca() DCNL DCSP ret = ax.set_xscale(*args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return ret
 DCSP ax = gca() DCNL DCSP ret = ax.set_yscale(*args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return ret
 DCSP ax = gca() DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP locs = ax.get_xticks() DCNL DCSP  DCSP labels = ax.get_xticklabels() DCNL DCSP elif (len(args) == 1): DCNL DCSP  DCSP locs = ax.set_xticks(args[0]) DCNL DCSP  DCSP labels = ax.get_xticklabels() DCNL DCSP elif (len(args) == 2): DCNL DCSP  DCSP locs = ax.set_xticks(args[0]) DCNL DCSP  DCSP labels = ax.set_xticklabels(args[1], **kwargs) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Illegal DCSP number DCSP of DCSP arguments DCSP to DCSP xticks') DCNL DCSP if len(kwargs): DCNL DCSP  DCSP for l in labels: DCNL DCSP  DCSP  DCSP l.update(kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return (locs, silent_list('Text DCSP xticklabel', labels))
 DCSP ax = gca() DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP locs = ax.get_yticks() DCNL DCSP  DCSP labels = ax.get_yticklabels() DCNL DCSP elif (len(args) == 1): DCNL DCSP  DCSP locs = ax.set_yticks(args[0]) DCNL DCSP  DCSP labels = ax.get_yticklabels() DCNL DCSP elif (len(args) == 2): DCNL DCSP  DCSP locs = ax.set_yticks(args[0]) DCNL DCSP  DCSP labels = ax.set_yticklabels(args[1], **kwargs) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Illegal DCSP number DCSP of DCSP arguments DCSP to DCSP yticks') DCNL DCSP if len(kwargs): DCNL DCSP  DCSP for l in labels: DCNL DCSP  DCSP  DCSP l.update(kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return (locs, silent_list('Text DCSP yticklabel', labels))
 DCSP ax = gca() DCNL DCSP if (not isinstance(ax, PolarAxes)): DCNL DCSP  DCSP raise RuntimeError('rgrids DCSP only DCSP defined DCSP for DCSP polar DCSP axes') DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP lines = ax.yaxis.get_ticklines() DCNL DCSP  DCSP labels = ax.yaxis.get_ticklabels() DCNL DCSP else: DCNL DCSP  DCSP (lines, labels) = ax.set_rgrids(*args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return (silent_list('Line2D DCSP rgridline', lines), silent_list('Text DCSP rgridlabel', labels))
 DCSP ax = gca() DCNL DCSP if (not isinstance(ax, PolarAxes)): DCNL DCSP  DCSP raise RuntimeError('rgrids DCSP only DCSP defined DCSP for DCSP polar DCSP axes') DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP lines = ax.xaxis.get_ticklines() DCNL DCSP  DCSP labels = ax.xaxis.get_ticklabels() DCNL DCSP else: DCNL DCSP  DCSP (lines, labels) = ax.set_thetagrids(*args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return (silent_list('Line2D DCSP thetagridline', lines), silent_list('Text DCSP thetagridlabel', labels))
 DCSP pass
 DCSP pass
 DCSP pass
 DCSP im = gci() DCNL DCSP if (im is None): DCNL DCSP  DCSP raise RuntimeError('You DCSP must DCSP first DCSP define DCSP an DCSP image, DCSP eg DCSP with DCSP imshow') DCNL DCSP im.set_clim(vmin, vmax) DCNL DCSP draw_if_interactive()
 DCSP if ((fignum is False) or (fignum is 0)): DCNL DCSP  DCSP ax = gca() DCNL DCSP else: DCNL DCSP  DCSP fig = figure(fignum, figsize=figaspect(A)) DCNL DCSP  DCSP ax = fig.add_axes([0.15, 0.09, 0.775, 0.775]) DCNL DCSP im = ax.matshow(A, **kw) DCNL DCSP gci._current = im DCNL DCSP draw_if_interactive() DCNL DCSP return im
 DCSP ax = gca(polar=True) DCNL DCSP ret = ax.plot(*args, **kwargs) DCNL DCSP draw_if_interactive() DCNL DCSP return ret
 DCSP fig = figure() DCNL DCSP if (len(cols) < 1): DCNL DCSP  DCSP raise ValueError('must DCSP have DCSP at DCSP least DCSP one DCSP column DCSP of DCSP data') DCNL DCSP if (plotfuncs is None): DCNL DCSP  DCSP plotfuncs = dict() DCNL DCSP r = mlab.csv2rec(fname, comments=comments, skiprows=skiprows, checkrows=checkrows, delimiter=delimiter) DCNL DCSP def getname_val(identifier): DCNL DCSP  DCSP 'return DCSP the DCSP name DCSP and DCSP column DCSP data DCSP for DCSP identifier' DCNL DCSP  DCSP if is_string_like(identifier): DCNL DCSP  DCSP  DCSP return (identifier, r[identifier]) DCNL DCSP  DCSP elif is_numlike(identifier): DCNL DCSP  DCSP  DCSP name = r.dtype.names[int(identifier)] DCNL DCSP  DCSP  DCSP return (name, r[name]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError('identifier DCSP must DCSP be DCSP a DCSP string DCSP or DCSP integer') DCNL DCSP (xname, x) = getname_val(cols[0]) DCNL DCSP if (len(cols) == 1): DCNL DCSP  DCSP ax1 = fig.add_subplot(1, 1, 1) DCNL DCSP  DCSP funcname = plotfuncs.get(cols[0], 'plot') DCNL DCSP  DCSP func = getattr(ax1, funcname) DCNL DCSP  DCSP func(x, **kwargs) DCNL DCSP  DCSP ax1.set_xlabel(xname) DCNL DCSP else: DCNL DCSP  DCSP N = len(cols) DCNL DCSP  DCSP for i in range(1, N): DCNL DCSP  DCSP  DCSP if (i == 1): DCNL DCSP  DCSP  DCSP  DCSP ax = ax1 = fig.add_subplot((N - 1), 1, i) DCNL DCSP  DCSP  DCSP  DCSP ax.grid(True) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ax = fig.add_subplot((N - 1), 1, i, sharex=ax1) DCNL DCSP  DCSP  DCSP  DCSP ax.grid(True) DCNL DCSP  DCSP  DCSP (yname, y) = getname_val(cols[i]) DCNL DCSP  DCSP  DCSP funcname = plotfuncs.get(cols[i], 'plot') DCNL DCSP  DCSP  DCSP func = getattr(ax, funcname) DCNL DCSP  DCSP  DCSP func(x, y, **kwargs) DCNL DCSP  DCSP  DCSP ax.set_ylabel(yname) DCNL DCSP  DCSP  DCSP if ax.is_last_row(): DCNL DCSP  DCSP  DCSP  DCSP ax.set_xlabel(xname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ax.set_xlabel('') DCNL DCSP if (xname == 'date'): DCNL DCSP  DCSP fig.autofmt_xdate() DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='autumn') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.autumn) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='bone') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.bone) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='cool') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.cool) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='copper') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.copper) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='flag') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.flag) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='gray') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.gray) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='hot') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.hot) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='hsv') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.hsv) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='jet') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.jet) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='pink') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.pink) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='prism') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.prism) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='spring') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.spring) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='summer') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.summer) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='winter') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.winter) DCNL DCSP draw_if_interactive()
 DCSP rc('image', cmap='spectral') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.spectral) DCNL DCSP draw_if_interactive()
 DCSP if (fontdict is not None): DCNL DCSP  DCSP override.update(fontdict) DCNL DCSP override.update(kwargs) DCNL DCSP return override
 DCSP if (rotation in ('horizontal', None)): DCNL DCSP  DCSP angle = 0.0 DCNL DCSP elif (rotation == 'vertical'): DCNL DCSP  DCSP angle = 90.0 DCNL DCSP else: DCNL DCSP  DCSP angle = float(rotation) DCNL DCSP return (angle % 360)
 DCSP projected_xs = [] DCNL DCSP projected_ys = [] DCNL DCSP theta = ((text.get_rotation() / 180.0) * math.pi) DCNL DCSP tr = mtransforms.Affine2D().rotate((- theta)) DCNL DCSP for (t, wh, x, y) in text._get_layout(renderer)[1]: DCNL DCSP  DCSP (w, h) = wh DCNL DCSP  DCSP (xt1, yt1) = tr.transform_point((x, y)) DCNL DCSP  DCSP (xt2, yt2) = ((xt1 + w), (yt1 + h)) DCNL DCSP  DCSP projected_xs.extend([xt1, xt2]) DCNL DCSP  DCSP projected_ys.extend([yt1, yt2]) DCNL DCSP (xt_box, yt_box) = (min(projected_xs), min(projected_ys)) DCNL DCSP (w_box, h_box) = ((max(projected_xs) - xt_box), (max(projected_ys) - yt_box)) DCNL DCSP tr = mtransforms.Affine2D().rotate(theta) DCNL DCSP (x_box, y_box) = tr.transform_point((xt_box, yt_box)) DCNL DCSP return (x_box, y_box, w_box, h_box)
 DCSP if (hasattr(dt, 'tzinfo') and (dt.tzinfo is not None)): DCNL DCSP  DCSP delta = dt.tzinfo.utcoffset(dt) DCNL DCSP  DCSP if (delta is not None): DCNL DCSP  DCSP  DCSP dt -= delta DCNL DCSP base = float(dt.toordinal()) DCNL DCSP if hasattr(dt, 'hour'): DCNL DCSP  DCSP base += ((((dt.hour / HOURS_PER_DAY) + (dt.minute / MINUTES_PER_DAY)) + (dt.second / SECONDS_PER_DAY)) + (dt.microsecond / MUSECONDS_PER_DAY)) DCNL DCSP return base
 DCSP if (tz is None): DCNL DCSP  DCSP tz = _get_rc_timezone() DCNL DCSP ix = int(x) DCNL DCSP dt = datetime.datetime.fromordinal(ix) DCNL DCSP remainder = (float(x) - ix) DCNL DCSP (hour, remainder) = divmod((24 * remainder), 1) DCNL DCSP (minute, remainder) = divmod((60 * remainder), 1) DCNL DCSP (second, remainder) = divmod((60 * remainder), 1) DCNL DCSP microsecond = int((1000000.0 * remainder)) DCNL DCSP if (microsecond < 10): DCNL DCSP  DCSP microsecond = 0 DCNL DCSP dt = datetime.datetime(dt.year, dt.month, dt.day, int(hour), int(minute), int(second), microsecond, tzinfo=UTC).astimezone(tz) DCNL DCSP if (microsecond > 999990): DCNL DCSP  DCSP dt += datetime.timedelta(microseconds=(1000000.0 - microsecond)) DCNL DCSP return dt
 DCSP if cbook.is_string_like(d): DCNL DCSP  DCSP dt = dateutil.parser.parse(d) DCNL DCSP  DCSP return date2num(dt) DCNL DCSP else: DCNL DCSP  DCSP return date2num([dateutil.parser.parse(s) for s in d])
 DCSP if (not cbook.iterable(d)): DCNL DCSP  DCSP return _to_ordinalf(d) DCNL DCSP else: DCNL DCSP  DCSP return np.asarray([_to_ordinalf(val) for val in d])
 DCSP if cbook.iterable(j): DCNL DCSP  DCSP j = np.asarray(j) DCNL DCSP return (j + 1721425.5)
 DCSP if cbook.iterable(n): DCNL DCSP  DCSP n = np.asarray(n) DCNL DCSP return (n - 1721425.5)
 DCSP if (tz is None): DCNL DCSP  DCSP tz = _get_rc_timezone() DCNL DCSP if (not cbook.iterable(x)): DCNL DCSP  DCSP return _from_ordinalf(x, tz) DCNL DCSP else: DCNL DCSP  DCSP return [_from_ordinalf(val, tz) for val in x]
 DCSP step = ((delta.days + (delta.seconds / SECONDS_PER_DAY)) + (delta.microseconds / MUSECONDS_PER_DAY)) DCNL DCSP f1 = _to_ordinalf(dstart) DCNL DCSP f2 = _to_ordinalf(dend) DCNL DCSP return np.arange(f1, f2, step)
 DCSP delta = (d2 - d1) DCNL DCSP mus = abs((((delta.days * MUSECONDS_PER_DAY) + (delta.seconds * 1000000.0)) + delta.microseconds)) DCNL DCSP assert (mus < epsilon)
 DCSP delta = abs(((o2 - o1) * MUSECONDS_PER_DAY)) DCNL DCSP assert (delta < epsilon)
 DCSP spd = (24.0 * 3600.0) DCNL DCSP return (719163 + (np.asarray(e) / spd))
 DCSP spd = (24.0 * 3600.0) DCNL DCSP return ((np.asarray(d) - 719163) * spd)
 DCSP scalar = False DCNL DCSP if (not cbook.iterable(mxdates)): DCNL DCSP  DCSP scalar = True DCNL DCSP  DCSP mxdates = [mxdates] DCNL DCSP ret = epoch2num([m.ticks() for m in mxdates]) DCNL DCSP if scalar: DCNL DCSP  DCSP return ret[0] DCNL DCSP else: DCNL DCSP  DCSP return ret
 DCSP if (span == 0): DCNL DCSP  DCSP span = (1 / 24.0) DCNL DCSP minutes = ((span * 24) * 60) DCNL DCSP hours = (span * 24) DCNL DCSP days = span DCNL DCSP weeks = (span / 7.0) DCNL DCSP months = (span / 31.0) DCNL DCSP years = (span / 365.0) DCNL DCSP if (years > numticks): DCNL DCSP  DCSP locator = YearLocator(int((years / numticks)), tz=tz) DCNL DCSP  DCSP fmt = '%Y' DCNL DCSP elif (months > numticks): DCNL DCSP  DCSP locator = MonthLocator(tz=tz) DCNL DCSP  DCSP fmt = '%b DCSP %Y' DCNL DCSP elif (weeks > numticks): DCNL DCSP  DCSP locator = WeekdayLocator(tz=tz) DCNL DCSP  DCSP fmt = '%a, DCSP %b DCSP %d' DCNL DCSP elif (days > numticks): DCNL DCSP  DCSP locator = DayLocator(interval=int(math.ceil((days / numticks))), tz=tz) DCNL DCSP  DCSP fmt = '%b DCSP %d' DCNL DCSP elif (hours > numticks): DCNL DCSP  DCSP locator = HourLocator(interval=int(math.ceil((hours / numticks))), tz=tz) DCNL DCSP  DCSP fmt = '%H:%M\n%b DCSP %d' DCNL DCSP elif (minutes > numticks): DCNL DCSP  DCSP locator = MinuteLocator(interval=int(math.ceil((minutes / numticks))), tz=tz) DCNL DCSP  DCSP fmt = '%H:%M:%S' DCNL DCSP else: DCNL DCSP  DCSP locator = MinuteLocator(tz=tz) DCNL DCSP  DCSP fmt = '%H:%M:%S' DCNL DCSP formatter = DateFormatter(fmt, tz=tz) DCNL DCSP return (locator, formatter)
 DCSP return (float(s) / SEC_PER_DAY)
 DCSP return (float(m) / MINUTES_PER_DAY)
 DCSP return (h / 24.0)
 DCSP return (w * 7.0)
 DCSP (w_list, d_list) = zip(*wd_list) DCNL DCSP if (mode == 'fixed'): DCNL DCSP  DCSP offsets_ = np.add.accumulate(([0] + [(w + sep) for w in w_list])) DCNL DCSP  DCSP offsets = offsets_[:(-1)] DCNL DCSP  DCSP if (total is None): DCNL DCSP  DCSP  DCSP total = (offsets_[(-1)] - sep) DCNL DCSP  DCSP return (total, offsets) DCNL DCSP elif (mode == 'expand'): DCNL DCSP  DCSP sep = ((total - sum(w_list)) / (len(w_list) - 1.0)) DCNL DCSP  DCSP offsets_ = np.add.accumulate(([0] + [(w + sep) for w in w_list])) DCNL DCSP  DCSP offsets = offsets_[:(-1)] DCNL DCSP  DCSP return (total, offsets) DCNL DCSP elif (mode == 'equal'): DCNL DCSP  DCSP maxh = max(w_list) DCNL DCSP  DCSP if (total is None): DCNL DCSP  DCSP  DCSP total = ((maxh + sep) * len(w_list)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sep = ((float(total) / len(w_list)) - maxh) DCNL DCSP  DCSP offsets = np.array([((maxh + sep) * i) for i in range(len(w_list))]) DCNL DCSP  DCSP return (total, offsets) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP mode DCSP : DCSP %s' % (mode,)))
 DCSP if (height is None): DCNL DCSP  DCSP height = max([h for (h, d) in hd_list]) DCNL DCSP if (align == 'baseline'): DCNL DCSP  DCSP height_descent = max([(h - d) for (h, d) in hd_list]) DCNL DCSP  DCSP descent = max([d for (h, d) in hd_list]) DCNL DCSP  DCSP height = (height_descent + descent) DCNL DCSP  DCSP offsets = [0.0 for (h, d) in hd_list] DCNL DCSP elif (align in ['left', 'top']): DCNL DCSP  DCSP descent = 0.0 DCNL DCSP  DCSP offsets = [d for (h, d) in hd_list] DCNL DCSP elif (align in ['right', 'bottom']): DCNL DCSP  DCSP descent = 0.0 DCNL DCSP  DCSP offsets = [((height - h) + d) for (h, d) in hd_list] DCNL DCSP elif (align == 'center'): DCNL DCSP  DCSP descent = 0.0 DCNL DCSP  DCSP offsets = [(((height - h) * 0.5) + d) for (h, d) in hd_list] DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP Align DCSP mode DCSP : DCSP %s' % (align,))) DCNL DCSP return (height, descent, offsets)
 DCSP lx = math.floor((math.log(x) / math.log(base))) DCNL DCSP return (base ** lx)
 DCSP lx = math.ceil((math.log(x) / math.log(base))) DCNL DCSP return (base ** lx)
 DCSP props = [] DCNL DCSP families = '' DCNL DCSP size = '' DCNL DCSP for key in 'family DCSP style DCSP variant DCSP weight DCSP stretch DCSP file DCSP size'.split(): DCNL DCSP  DCSP val = getattr(d, ('get_' + key))() DCNL DCSP  DCSP if ((val is not None) and (val != [])): DCNL DCSP  DCSP  DCSP if (type(val) == list): DCNL DCSP  DCSP  DCSP  DCSP val = [value_escape('\\\\\\1', str(x)) for x in val if (x is not None)] DCNL DCSP  DCSP  DCSP  DCSP if (val != []): DCNL DCSP  DCSP  DCSP  DCSP  DCSP val = ','.join(val) DCNL DCSP  DCSP  DCSP props.append((':%s=%s' % (key, val))) DCNL DCSP return ''.join(props)
 DCSP return np.sqrt(np.dot(x, x))
 DCSP return (np.hanning(len(x)) * x)
 DCSP return x
 DCSP warnings.warn("Use DCSP numpy.convolve(x, DCSP y, DCSP mode='full')", DeprecationWarning) DCNL DCSP return np.convolve(x, y, mode)
 DCSP x = np.asarray(x) DCNL DCSP if axis: DCNL DCSP  DCSP ind = ([slice(None)] * axis) DCNL DCSP  DCSP ind.append(np.newaxis) DCNL DCSP  DCSP return (x - x.mean(axis)[ind]) DCNL DCSP return (x - x.mean(axis))
 DCSP return (x - x.mean())
 DCSP return x
 DCSP x = np.arange(len(y), dtype=np.float_) DCNL DCSP C = np.cov(x, y, bias=1) DCNL DCSP b = (C[(0, 1)] / C[(0, 0)]) DCNL DCSP a = (y.mean() - (b * x.mean())) DCNL DCSP return (y - ((b * x) + a))
 DCSP (Pxx, freqs) = csd(x, x, NFFT, Fs, detrend, window, noverlap, pad_to, sides, scale_by_freq) DCNL DCSP return (Pxx.real, freqs)
 DCSP (Pxy, freqs, t) = _spectral_helper(x, y, NFFT, Fs, detrend, window, noverlap, pad_to, sides, scale_by_freq) DCNL DCSP if ((len(Pxy.shape) == 2) and (Pxy.shape[1] > 1)): DCNL DCSP  DCSP Pxy = Pxy.mean(axis=1) DCNL DCSP return (Pxy, freqs)
 DCSP assert (NFFT > noverlap) DCNL DCSP (Pxx, freqs, t) = _spectral_helper(x, x, NFFT, Fs, detrend, window, noverlap, pad_to, sides, scale_by_freq) DCNL DCSP Pxx = Pxx.real DCNL DCSP if ((np.iscomplexobj(x) and (sides == 'default')) or (sides == 'twosided')): DCNL DCSP  DCSP freqs = np.concatenate(((freqs[(NFFT / 2):] - Fs), freqs[:(NFFT / 2)])) DCNL DCSP  DCSP Pxx = np.concatenate((Pxx[(NFFT / 2):, :], Pxx[:(NFFT / 2), :]), 0) DCNL DCSP return (Pxx, freqs, t)
 DCSP if (len(x) < (2 * NFFT)): DCNL DCSP  DCSP raise ValueError(_coh_error) DCNL DCSP (Pxx, f) = psd(x, NFFT, Fs, detrend, window, noverlap, pad_to, sides, scale_by_freq) DCNL DCSP (Pyy, f) = psd(y, NFFT, Fs, detrend, window, noverlap, pad_to, sides, scale_by_freq) DCNL DCSP (Pxy, f) = csd(x, y, NFFT, Fs, detrend, window, noverlap, pad_to, sides, scale_by_freq) DCNL DCSP Cxy = np.divide((np.absolute(Pxy) ** 2), (Pxx * Pyy)) DCNL DCSP Cxy.shape = (len(f),) DCNL DCSP return (Cxy, f)
 DCSP warnings.warn('Use DCSP numpy.corrcoef', DeprecationWarning) DCNL DCSP kw = dict(rowvar=False) DCNL DCSP return np.corrcoef(*args, **kw)
 DCSP return {'ttf': ('ttf', 'otf'), 'otf': ('ttf', 'otf'), 'afm': ('afm',)}[fontext]
 DCSP try: DCNL DCSP  DCSP import _winreg DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, MSFolders) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _winreg.QueryValueEx(user, 'Fonts')[0] DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP _winreg.CloseKey(user) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return os.path.join(os.environ['WINDIR'], 'Fonts')
 DCSP import _winreg DCNL DCSP if (directory is None): DCNL DCSP  DCSP directory = win32FontDirectory() DCNL DCSP fontext = get_fontext_synonyms(fontext) DCNL DCSP (key, items) = (None, {}) DCNL DCSP for fontdir in MSFontDirectories: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP local = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, fontdir) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not local): DCNL DCSP  DCSP  DCSP files = [] DCNL DCSP  DCSP  DCSP for ext in fontext: DCNL DCSP  DCSP  DCSP  DCSP files.extend(glob.glob(os.path.join(directory, ('*.' + ext)))) DCNL DCSP  DCSP  DCSP return files DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for j in range(_winreg.QueryInfoKey(local)[1]): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (key, direc, any) = _winreg.EnumValue(local, j) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.dirname(direc)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP direc = os.path.join(directory, direc) DCNL DCSP  DCSP  DCSP  DCSP  DCSP direc = os.path.abspath(direc).lower() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (os.path.splitext(direc)[1][1:] in fontext): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP items[direc] = 1 DCNL DCSP  DCSP  DCSP  DCSP except EnvironmentError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP except WindowsError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return items.keys() DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP _winreg.CloseKey(local) DCNL DCSP return None
 DCSP fontpaths = [] DCNL DCSP def add(arg, directory, files): DCNL DCSP  DCSP fontpaths.append(directory) DCNL DCSP for fontdir in OSXFontDirectories: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if os.path.isdir(fontdir): DCNL DCSP  DCSP  DCSP  DCSP os.path.walk(fontdir, add, None) DCNL DCSP  DCSP except (IOError, OSError, TypeError, ValueError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP return fontpaths
 DCSP if (directory is None): DCNL DCSP  DCSP directory = OSXFontDirectory() DCNL DCSP fontext = get_fontext_synonyms(fontext) DCNL DCSP files = [] DCNL DCSP for path in directory: DCNL DCSP  DCSP if (fontext is None): DCNL DCSP  DCSP  DCSP files.extend(glob.glob(os.path.join(path, '*'))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for ext in fontext: DCNL DCSP  DCSP  DCSP  DCSP files.extend(glob.glob(os.path.join(path, ('*.' + ext)))) DCNL DCSP  DCSP  DCSP  DCSP files.extend(glob.glob(os.path.join(path, ('*.' + ext.upper())))) DCNL DCSP return files
 DCSP fontpaths = [] DCNL DCSP def add(arg, directory, files): DCNL DCSP  DCSP fontpaths.append(directory) DCNL DCSP for fontdir in X11FontDirectories: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if os.path.isdir(fontdir): DCNL DCSP  DCSP  DCSP  DCSP os.path.walk(fontdir, add, None) DCNL DCSP  DCSP except (IOError, OSError, TypeError, ValueError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP return fontpaths
 DCSP try: DCNL DCSP  DCSP import commands DCNL DCSP except ImportError: DCNL DCSP  DCSP return {} DCNL DCSP fontext = get_fontext_synonyms(fontext) DCNL DCSP fontfiles = {} DCNL DCSP (status, output) = commands.getstatusoutput('fc-list DCSP file') DCNL DCSP if (status == 0): DCNL DCSP  DCSP for line in output.split('\n'): DCNL DCSP  DCSP  DCSP fname = line.split(':')[0] DCNL DCSP  DCSP  DCSP if ((os.path.splitext(fname)[1][1:] in fontext) and os.path.exists(fname)): DCNL DCSP  DCSP  DCSP  DCSP fontfiles[fname] = 1 DCNL DCSP return fontfiles
 DCSP fontfiles = {} DCNL DCSP fontexts = get_fontext_synonyms(fontext) DCNL DCSP if (fontpaths is None): DCNL DCSP  DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP  DCSP fontdir = win32FontDirectory() DCNL DCSP  DCSP  DCSP fontpaths = [fontdir] DCNL DCSP  DCSP  DCSP for f in win32InstalledFonts(fontdir): DCNL DCSP  DCSP  DCSP  DCSP (base, ext) = os.path.splitext(f) DCNL DCSP  DCSP  DCSP  DCSP if ((len(ext) > 1) and (ext[1:].lower() in fontexts)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fontfiles[f] = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fontpaths = x11FontDirectory() DCNL DCSP  DCSP  DCSP if (sys.platform == 'darwin'): DCNL DCSP  DCSP  DCSP  DCSP for f in OSXInstalledFonts(fontext=fontext): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fontfiles[f] = 1 DCNL DCSP  DCSP  DCSP for f in get_fontconfig_fonts(fontext): DCNL DCSP  DCSP  DCSP  DCSP fontfiles[f] = 1 DCNL DCSP elif isinstance(fontpaths, (str, unicode)): DCNL DCSP  DCSP fontpaths = [fontpaths] DCNL DCSP for path in fontpaths: DCNL DCSP  DCSP files = [] DCNL DCSP  DCSP for ext in fontexts: DCNL DCSP  DCSP  DCSP files.extend(glob.glob(os.path.join(path, ('*.' + ext)))) DCNL DCSP  DCSP  DCSP files.extend(glob.glob(os.path.join(path, ('*.' + ext.upper())))) DCNL DCSP  DCSP for fname in files: DCNL DCSP  DCSP  DCSP fontfiles[os.path.abspath(fname)] = 1 DCNL DCSP return [fname for fname in fontfiles.keys() if os.path.exists(fname)]
 DCSP if isinstance(weight, str): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP weight = weight_dict[weight.lower()] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP weight = 400 DCNL DCSP elif (weight in range(100, 1000, 100)): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise ValueError, 'weight DCSP not DCSP a DCSP valid DCSP integer' DCNL DCSP return weight
 DCSP name = font.family_name DCNL DCSP sfnt = font.get_sfnt() DCNL DCSP sfnt2 = sfnt.get((1, 0, 0, 2)) DCNL DCSP sfnt4 = sfnt.get((1, 0, 0, 4)) DCNL DCSP if sfnt2: DCNL DCSP  DCSP sfnt2 = sfnt2.lower() DCNL DCSP else: DCNL DCSP  DCSP sfnt2 = '' DCNL DCSP if sfnt4: DCNL DCSP  DCSP sfnt4 = sfnt4.lower() DCNL DCSP else: DCNL DCSP  DCSP sfnt4 = '' DCNL DCSP if (sfnt4.find('oblique') >= 0): DCNL DCSP  DCSP style = 'oblique' DCNL DCSP elif (sfnt4.find('italic') >= 0): DCNL DCSP  DCSP style = 'italic' DCNL DCSP elif (sfnt2.find('regular') >= 0): DCNL DCSP  DCSP style = 'normal' DCNL DCSP elif (font.style_flags & ft2font.ITALIC): DCNL DCSP  DCSP style = 'italic' DCNL DCSP else: DCNL DCSP  DCSP style = 'normal' DCNL DCSP if (name.lower() in ['capitals', 'small-caps']): DCNL DCSP  DCSP variant = 'small-caps' DCNL DCSP else: DCNL DCSP  DCSP variant = 'normal' DCNL DCSP weight = None DCNL DCSP for w in weight_dict.keys(): DCNL DCSP  DCSP if (sfnt4.find(w) >= 0): DCNL DCSP  DCSP  DCSP weight = w DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not weight): DCNL DCSP  DCSP if (font.style_flags & ft2font.BOLD): DCNL DCSP  DCSP  DCSP weight = 700 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP weight = 400 DCNL DCSP weight = weight_as_number(weight) DCNL DCSP if ((sfnt4.find('narrow') >= 0) or (sfnt4.find('condensed') >= 0) or (sfnt4.find('cond') >= 0)): DCNL DCSP  DCSP stretch = 'condensed' DCNL DCSP elif (sfnt4.find('demi DCSP cond') >= 0): DCNL DCSP  DCSP stretch = 'semi-condensed' DCNL DCSP elif ((sfnt4.find('wide') >= 0) or (sfnt4.find('expanded') >= 0)): DCNL DCSP  DCSP stretch = 'expanded' DCNL DCSP else: DCNL DCSP  DCSP stretch = 'normal' DCNL DCSP if font.scalable: DCNL DCSP  DCSP size = 'scalable' DCNL DCSP else: DCNL DCSP  DCSP size = str(float(font.get_fontsize())) DCNL DCSP size_adjust = None DCNL DCSP return FontEntry(font.fname, name, style, variant, weight, stretch, size)
 DCSP name = font.get_familyname() DCNL DCSP if ((font.get_angle() != 0) or (name.lower().find('italic') >= 0)): DCNL DCSP  DCSP style = 'italic' DCNL DCSP elif (name.lower().find('oblique') >= 0): DCNL DCSP  DCSP style = 'oblique' DCNL DCSP else: DCNL DCSP  DCSP style = 'normal' DCNL DCSP if (name.lower() in ['capitals', 'small-caps']): DCNL DCSP  DCSP variant = 'small-caps' DCNL DCSP else: DCNL DCSP  DCSP variant = 'normal' DCNL DCSP weight = weight_as_number(font.get_weight().lower()) DCNL DCSP stretch = 'normal' DCNL DCSP size = 'scalable' DCNL DCSP size_adjust = None DCNL DCSP return FontEntry(fontpath, name, style, variant, weight, stretch, size)
 DCSP fontlist = [] DCNL DCSP seen = {} DCNL DCSP for fpath in fontfiles: DCNL DCSP  DCSP verbose.report(('createFontDict: DCSP %s' % fpath), 'debug') DCNL DCSP  DCSP fname = os.path.split(fpath)[1] DCNL DCSP  DCSP if (fname in seen): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP seen[fname] = 1 DCNL DCSP  DCSP if (fontext == 'afm'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fh = open(fpath, 'r') DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP verbose.report(('Could DCSP not DCSP open DCSP font DCSP file DCSP %s' % fpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP font = afm.AFM(fh) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fh.close() DCNL DCSP  DCSP  DCSP except RuntimeError: DCNL DCSP  DCSP  DCSP  DCSP verbose.report(('Could DCSP not DCSP parse DCSP font DCSP file DCSP %s' % fpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP prop = afmFontProperty(fpath, font) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP font = ft2font.FT2Font(str(fpath)) DCNL DCSP  DCSP  DCSP except RuntimeError: DCNL DCSP  DCSP  DCSP  DCSP verbose.report(('Could DCSP not DCSP open DCSP font DCSP file DCSP %s' % fpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP except UnicodeError: DCNL DCSP  DCSP  DCSP  DCSP verbose.report('Cannot DCSP handle DCSP unicode DCSP filenames') DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP prop = ttfFontProperty(font) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP fontlist.append(prop) DCNL DCSP return fontlist
 DCSP fnames = [] DCNL DCSP for named in d.values(): DCNL DCSP  DCSP for styled in named.values(): DCNL DCSP  DCSP  DCSP for variantd in styled.values(): DCNL DCSP  DCSP  DCSP  DCSP for weightd in variantd.values(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for stretchd in weightd.values(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for fname in stretchd.values(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fnames.append(fname) DCNL DCSP return fnames
 DCSP fh = open(filename, 'w') DCNL DCSP try: DCNL DCSP  DCSP pickle.dump(data, fh) DCNL DCSP finally: DCNL DCSP  DCSP fh.close()
 DCSP fh = open(filename, 'r') DCNL DCSP try: DCNL DCSP  DCSP data = pickle.load(fh) DCNL DCSP finally: DCNL DCSP  DCSP fh.close() DCNL DCSP return data
 DCSP if (os.path.splitext(filename)[1].lower() == '.otf'): DCNL DCSP  DCSP result = _is_opentype_cff_font_cache.get(filename) DCNL DCSP  DCSP if (result is None): DCNL DCSP  DCSP  DCSP fd = open(filename, 'rb') DCNL DCSP  DCSP  DCSP tag = fd.read(4) DCNL DCSP  DCSP  DCSP fd.close() DCNL DCSP  DCSP  DCSP result = (tag == 'OTTO') DCNL DCSP  DCSP  DCSP _is_opentype_cff_font_cache[filename] = result DCNL DCSP  DCSP return result DCNL DCSP return False
 DCSP artist.Artist.__init__(self) DCNL DCSP if (linewidth is None): DCNL DCSP  DCSP linewidth = mpl.rcParams['patch.linewidth'] DCNL DCSP if (linestyle is None): DCNL DCSP  DCSP linestyle = 'solid' DCNL DCSP if (antialiased is None): DCNL DCSP  DCSP antialiased = mpl.rcParams['patch.antialiased'] DCNL DCSP self.set_edgecolor(edgecolor) DCNL DCSP self.set_facecolor(facecolor) DCNL DCSP self.set_linewidth(linewidth) DCNL DCSP self.set_linestyle(linestyle) DCNL DCSP self.set_antialiased(antialiased) DCNL DCSP self.set_hatch(hatch) DCNL DCSP self.fill = fill DCNL DCSP self._combined_transform = transforms.IdentityTransform() DCNL DCSP if len(kwargs): DCNL DCSP  DCSP artist.setp(self, **kwargs)
 DCSP if (props is None): DCNL DCSP  DCSP props = {} DCNL DCSP props = props.copy() DCNL DCSP pad = props.pop('pad', 4) DCNL DCSP pad = renderer.points_to_pixels(pad) DCNL DCSP bbox = artist.get_window_extent(renderer) DCNL DCSP (l, b, w, h) = bbox.bounds DCNL DCSP l -= (pad / 2.0) DCNL DCSP b -= (pad / 2.0) DCNL DCSP w += pad DCNL DCSP h += pad DCNL DCSP r = Rectangle(xy=(l, b), width=w, height=h, fill=fill) DCNL DCSP r.set_transform(transforms.IdentityTransform()) DCNL DCSP r.set_clip_on(False) DCNL DCSP r.update(props) DCNL DCSP r.draw(renderer)
 DCSP (l, b, w, h) = bbox.get_bounds() DCNL DCSP r = Rectangle(xy=(l, b), width=w, height=h, edgecolor=color, fill=False) DCNL DCSP if (trans is not None): DCNL DCSP  DCSP r.set_transform(trans) DCNL DCSP r.set_clip_on(False) DCNL DCSP r.draw(renderer)
 DCSP if leadingspace: DCNL DCSP  DCSP pad = (' DCSP ' * leadingspace) DCNL DCSP else: DCNL DCSP  DCSP pad = '' DCNL DCSP columns = [[] for cell in _table[0]] DCNL DCSP for row in _table: DCNL DCSP  DCSP for (column, cell) in zip(columns, row): DCNL DCSP  DCSP  DCSP column.append(cell) DCNL DCSP col_len = [max([len(cell) for cell in column]) for column in columns] DCNL DCSP lines = [] DCNL DCSP table_formatstr = (pad + ' DCSP  DCSP  DCSP '.join([('=' * cl) for cl in col_len])) DCNL DCSP lines.append('') DCNL DCSP lines.append(table_formatstr) DCNL DCSP lines.append((pad + ' DCSP  DCSP  DCSP '.join([cell.ljust(cl) for (cell, cl) in zip(_table[0], col_len)]))) DCNL DCSP lines.append(table_formatstr) DCNL DCSP lines.extend([(pad + ' DCSP  DCSP  DCSP '.join([cell.ljust(cl) for (cell, cl) in zip(row, col_len)])) for row in _table[1:]]) DCNL DCSP lines.append(table_formatstr) DCNL DCSP lines.append('') DCNL DCSP return '\n'.join(lines)
 DCSP if leadingspace: DCNL DCSP  DCSP pad = (' DCSP ' * leadingspace) DCNL DCSP else: DCNL DCSP  DCSP pad = '' DCNL DCSP (names, attrss, clss) = ([], [], []) DCNL DCSP import inspect DCNL DCSP _table = [['Class', 'Name', 'Attrs']] DCNL DCSP for (name, cls) in sorted(_styles.items()): DCNL DCSP  DCSP (args, varargs, varkw, defaults) = inspect.getargspec(cls.__init__) DCNL DCSP  DCSP if defaults: DCNL DCSP  DCSP  DCSP args = [(argname, argdefault) for (argname, argdefault) in zip(args[1:], defaults)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args = None DCNL DCSP  DCSP if (args is None): DCNL DCSP  DCSP  DCSP argstr = 'None' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP argstr = ','.join([('%s=%s' % (an, av)) for (an, av) in args]) DCNL DCSP  DCSP _table.append([cls.__name__, ("'%s'" % name), argstr]) DCNL DCSP return _pprint_table(_table)
 DCSP results = [] DCNL DCSP lines = fh.readlines() DCNL DCSP datefmt = None DCNL DCSP for line in lines[1:]: DCNL DCSP  DCSP vals = line.split(',') DCNL DCSP  DCSP if (len(vals) != 7): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP datestr = vals[0] DCNL DCSP  DCSP if (datefmt is None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP datefmt = '%Y-%m-%d' DCNL DCSP  DCSP  DCSP  DCSP dt = datetime.date(*time.strptime(datestr, datefmt)[:3]) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP datefmt = '%d-%b-%y' DCNL DCSP  DCSP dt = datetime.date(*time.strptime(datestr, datefmt)[:3]) DCNL DCSP  DCSP d = date2num(dt) DCNL DCSP  DCSP (open, high, low, close) = [float(val) for val in vals[1:5]] DCNL DCSP  DCSP volume = int(vals[5]) DCNL DCSP  DCSP if adjusted: DCNL DCSP  DCSP  DCSP aclose = float(vals[6]) DCNL DCSP  DCSP  DCSP m = (aclose / close) DCNL DCSP  DCSP  DCSP open *= m DCNL DCSP  DCSP  DCSP high *= m DCNL DCSP  DCSP  DCSP low *= m DCNL DCSP  DCSP  DCSP close = aclose DCNL DCSP  DCSP results.append((d, open, close, high, low, volume)) DCNL DCSP results.reverse() DCNL DCSP if asobject: DCNL DCSP  DCSP if (len(results) == 0): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (date, open, close, high, low, volume) = map(np.asarray, zip(*results)) DCNL DCSP  DCSP return Bunch(date=date, open=open, close=close, high=high, low=low, volume=volume) DCNL DCSP else: DCNL DCSP  DCSP return results
 DCSP ticker = ticker.upper() DCNL DCSP d1 = ((date1.month - 1), date1.day, date1.year) DCNL DCSP d2 = ((date2.month - 1), date2.day, date2.year) DCNL DCSP urlFmt = 'http://table.finance.yahoo.com/table.csv?a=%d&b=%d&c=%d&d=%d&e=%d&f=%d&s=%s&y=0&g=d&ignore=.csv' DCNL DCSP url = (urlFmt % (d1[0], d1[1], d1[2], d2[0], d2[1], d2[2], ticker)) DCNL DCSP if (cachename is None): DCNL DCSP  DCSP cachename = os.path.join(cachedir, md5(url).hexdigest()) DCNL DCSP if os.path.exists(cachename): DCNL DCSP  DCSP fh = file(cachename) DCNL DCSP  DCSP verbose.report(('Using DCSP cachefile DCSP %s DCSP for DCSP %s' % (cachename, ticker))) DCNL DCSP else: DCNL DCSP  DCSP if (not os.path.isdir(cachedir)): DCNL DCSP  DCSP  DCSP os.mkdir(cachedir) DCNL DCSP  DCSP fh = file(cachename, 'w') DCNL DCSP  DCSP fh.write(urlopen(url).read()) DCNL DCSP  DCSP fh.close() DCNL DCSP  DCSP verbose.report(('Saved DCSP %s DCSP data DCSP to DCSP cache DCSP file DCSP %s' % (ticker, cachename))) DCNL DCSP  DCSP fh = file(cachename, 'r') DCNL DCSP return fh
 DCSP fh = fetch_historical_yahoo(ticker, date1, date2, cachename) DCNL DCSP try: DCNL DCSP  DCSP ret = parse_yahoo_historical(fh, asobject, adjusted) DCNL DCSP except IOError as exc: DCNL DCSP  DCSP warnings.warn(((('urlopen() DCSP failure\n' + url) + '\n') + exc.strerror[1])) DCNL DCSP  DCSP return None DCNL DCSP return ret
 DCSP lines = [] DCNL DCSP for q in quotes: DCNL DCSP  DCSP (t, open, close, high, low) = q[:5] DCNL DCSP  DCSP if (close >= open): DCNL DCSP  DCSP  DCSP color = colorup DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP color = colordown DCNL DCSP  DCSP vline = Line2D(xdata=(t, t), ydata=(low, high), color=color, antialiased=False) DCNL DCSP  DCSP oline = Line2D(xdata=(t, t), ydata=(open, open), color=color, antialiased=False, marker=TICKLEFT, markersize=ticksize) DCNL DCSP  DCSP cline = Line2D(xdata=(t, t), ydata=(close, close), color=color, antialiased=False, markersize=ticksize, marker=TICKRIGHT) DCNL DCSP  DCSP lines.extend((vline, oline, cline)) DCNL DCSP  DCSP ax.add_line(vline) DCNL DCSP  DCSP ax.add_line(oline) DCNL DCSP  DCSP ax.add_line(cline) DCNL DCSP ax.autoscale_view() DCNL DCSP return lines
 DCSP OFFSET = (width / 2.0) DCNL DCSP lines = [] DCNL DCSP patches = [] DCNL DCSP for q in quotes: DCNL DCSP  DCSP (t, open, close, high, low) = q[:5] DCNL DCSP  DCSP if (close >= open): DCNL DCSP  DCSP  DCSP color = colorup DCNL DCSP  DCSP  DCSP lower = open DCNL DCSP  DCSP  DCSP height = (close - open) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP color = colordown DCNL DCSP  DCSP  DCSP lower = close DCNL DCSP  DCSP  DCSP height = (open - close) DCNL DCSP  DCSP vline = Line2D(xdata=(t, t), ydata=(low, high), color='k', linewidth=0.5, antialiased=True) DCNL DCSP  DCSP rect = Rectangle(xy=((t - OFFSET), lower), width=width, height=height, facecolor=color, edgecolor=color) DCNL DCSP  DCSP rect.set_alpha(alpha) DCNL DCSP  DCSP lines.append(vline) DCNL DCSP  DCSP patches.append(rect) DCNL DCSP  DCSP ax.add_line(vline) DCNL DCSP  DCSP ax.add_patch(rect) DCNL DCSP ax.autoscale_view() DCNL DCSP return (lines, patches)
 DCSP rangeSegments = [((i, low), (i, high)) for (i, low, high) in zip(xrange(len(lows)), lows, highs) if (low != (-1))] DCNL DCSP openSegments = [(((- ticksize), 0), (0, 0))] DCNL DCSP closeSegments = [((0, 0), (ticksize, 0))] DCNL DCSP offsetsOpen = [(i, open) for (i, open) in zip(xrange(len(opens)), opens) if (open != (-1))] DCNL DCSP offsetsClose = [(i, close) for (i, close) in zip(xrange(len(closes)), closes) if (close != (-1))] DCNL DCSP scale = (ax.figure.dpi * (1.0 / 72.0)) DCNL DCSP tickTransform = Affine2D().scale(scale, 0.0) DCNL DCSP (r, g, b) = colorConverter.to_rgb(colorup) DCNL DCSP colorup = (r, g, b, 1) DCNL DCSP (r, g, b) = colorConverter.to_rgb(colordown) DCNL DCSP colordown = (r, g, b, 1) DCNL DCSP colord = {True: colorup, False: colordown} DCNL DCSP colors = [colord[(open < close)] for (open, close) in zip(opens, closes) if ((open != (-1)) and (close != (-1)))] DCNL DCSP assert (len(rangeSegments) == len(offsetsOpen)) DCNL DCSP assert (len(offsetsOpen) == len(offsetsClose)) DCNL DCSP assert (len(offsetsClose) == len(colors)) DCNL DCSP useAA = (0,) DCNL DCSP lw = (1,) DCNL DCSP rangeCollection = LineCollection(rangeSegments, colors=colors, linewidths=lw, antialiaseds=useAA) DCNL DCSP openCollection = LineCollection(openSegments, colors=colors, antialiaseds=useAA, linewidths=lw, offsets=offsetsOpen, transOffset=ax.transData) DCNL DCSP openCollection.set_transform(tickTransform) DCNL DCSP closeCollection = LineCollection(closeSegments, colors=colors, antialiaseds=useAA, linewidths=lw, offsets=offsetsClose, transOffset=ax.transData) DCNL DCSP closeCollection.set_transform(tickTransform) DCNL DCSP (minpy, maxx) = (0, len(rangeSegments)) DCNL DCSP miny = min([low for low in lows if (low != (-1))]) DCNL DCSP maxy = max([high for high in highs if (high != (-1))]) DCNL DCSP corners = ((minpy, miny), (maxx, maxy)) DCNL DCSP ax.update_datalim(corners) DCNL DCSP ax.autoscale_view() DCNL DCSP ax.add_collection(rangeCollection) DCNL DCSP ax.add_collection(openCollection) DCNL DCSP ax.add_collection(closeCollection) DCNL DCSP return (rangeCollection, openCollection, closeCollection)
 DCSP delta = (width / 2.0) DCNL DCSP barVerts = [(((i - delta), open), ((i - delta), close), ((i + delta), close), ((i + delta), open)) for (i, open, close) in zip(xrange(len(opens)), opens, closes) if ((open != (-1)) and (close != (-1)))] DCNL DCSP rangeSegments = [((i, low), (i, high)) for (i, low, high) in zip(xrange(len(lows)), lows, highs) if (low != (-1))] DCNL DCSP (r, g, b) = colorConverter.to_rgb(colorup) DCNL DCSP colorup = (r, g, b, alpha) DCNL DCSP (r, g, b) = colorConverter.to_rgb(colordown) DCNL DCSP colordown = (r, g, b, alpha) DCNL DCSP colord = {True: colorup, False: colordown} DCNL DCSP colors = [colord[(open < close)] for (open, close) in zip(opens, closes) if ((open != (-1)) and (close != (-1)))] DCNL DCSP assert (len(barVerts) == len(rangeSegments)) DCNL DCSP useAA = (0,) DCNL DCSP lw = (0.5,) DCNL DCSP rangeCollection = LineCollection(rangeSegments, colors=((0, 0, 0, 1),), linewidths=lw, antialiaseds=useAA) DCNL DCSP barCollection = PolyCollection(barVerts, facecolors=colors, edgecolors=((0, 0, 0, 1),), antialiaseds=useAA, linewidths=lw) DCNL DCSP (minx, maxx) = (0, len(rangeSegments)) DCNL DCSP miny = min([low for low in lows if (low != (-1))]) DCNL DCSP maxy = max([high for high in highs if (high != (-1))]) DCNL DCSP corners = ((minx, miny), (maxx, maxy)) DCNL DCSP ax.update_datalim(corners) DCNL DCSP ax.autoscale_view() DCNL DCSP ax.add_collection(barCollection) DCNL DCSP ax.add_collection(rangeCollection) DCNL DCSP return (rangeCollection, barCollection)
 DCSP (r, g, b) = colorConverter.to_rgb(colorup) DCNL DCSP colorup = (r, g, b, alpha) DCNL DCSP (r, g, b) = colorConverter.to_rgb(colordown) DCNL DCSP colordown = (r, g, b, alpha) DCNL DCSP colord = {True: colorup, False: colordown} DCNL DCSP colors = [colord[(open < close)] for (open, close) in zip(opens, closes) if ((open != (-1)) and (close != (-1)))] DCNL DCSP delta = (width / 2.0) DCNL DCSP bars = [(((i - delta), 0), ((i - delta), v), ((i + delta), v), ((i + delta), 0)) for (i, v) in enumerate(volumes) if (v != (-1))] DCNL DCSP barCollection = PolyCollection(bars, facecolors=colors, edgecolors=((0, 0, 0, 1),), antialiaseds=(0,), linewidths=(0.5,)) DCNL DCSP corners = ((0, 0), (len(bars), max(volumes))) DCNL DCSP ax.update_datalim(corners) DCNL DCSP ax.autoscale_view() DCNL DCSP return barCollection
 DCSP return volume_overlay(ax, closes[:(-1)], closes[1:], volumes[1:], colorup, colordown, width, alpha)
 DCSP (r, g, b) = colorConverter.to_rgb(colorup) DCNL DCSP colorup = (r, g, b, alpha) DCNL DCSP (r, g, b) = colorConverter.to_rgb(colordown) DCNL DCSP colordown = (r, g, b, alpha) DCNL DCSP colord = {True: colorup, False: colordown} DCNL DCSP (dates, opens, closes, highs, lows, volumes) = zip(*quotes) DCNL DCSP colors = [colord[(close1 >= close0)] for (close0, close1) in zip(closes[:(-1)], closes[1:]) if ((close0 != (-1)) and (close1 != (-1)))] DCNL DCSP colors.insert(0, colord[(closes[0] >= opens[0])]) DCNL DCSP right = (width / 2.0) DCNL DCSP left = ((- width) / 2.0) DCNL DCSP bars = [((left, 0), (left, volume), (right, volume), (right, 0)) for (d, open, close, high, low, volume) in quotes] DCNL DCSP sx = (ax.figure.dpi * (1.0 / 72.0)) DCNL DCSP sy = (ax.bbox.height / ax.viewLim.height) DCNL DCSP barTransform = Affine2D().scale(sx, sy) DCNL DCSP dates = [d for (d, open, close, high, low, volume) in quotes] DCNL DCSP offsetsBars = [(d, 0) for d in dates] DCNL DCSP useAA = (0,) DCNL DCSP lw = (0.5,) DCNL DCSP barCollection = PolyCollection(bars, facecolors=colors, edgecolors=((0, 0, 0, 1),), antialiaseds=useAA, linewidths=lw, offsets=offsetsBars, transOffset=ax.transData) DCNL DCSP barCollection.set_transform(barTransform) DCNL DCSP (minpy, maxx) = (min(dates), max(dates)) DCNL DCSP miny = 0 DCNL DCSP maxy = max([volume for (d, open, close, high, low, volume) in quotes]) DCNL DCSP corners = ((minpy, miny), (maxx, maxy)) DCNL DCSP ax.update_datalim(corners) DCNL DCSP ax.add_collection(barCollection) DCNL DCSP ax.autoscale_view() DCNL DCSP return barCollection
 DCSP facecolors = (colorConverter.to_rgba(facecolor, alpha),) DCNL DCSP edgecolors = (colorConverter.to_rgba(edgecolor, alpha),) DCNL DCSP right = (width / 2.0) DCNL DCSP left = ((- width) / 2.0) DCNL DCSP bars = [((left, 0), (left, v), (right, v), (right, 0)) for v in vals if (v != (-1))] DCNL DCSP sx = (ax.figure.dpi * (1.0 / 72.0)) DCNL DCSP sy = (ax.bbox.height / ax.viewLim.height) DCNL DCSP barTransform = Affine2D().scale(sx, sy) DCNL DCSP offsetsBars = [(i, 0) for (i, v) in enumerate(vals) if (v != (-1))] DCNL DCSP barCollection = PolyCollection(bars, facecolors=facecolors, edgecolors=edgecolors, antialiaseds=(0,), linewidths=(0.5,), offsets=offsetsBars, transOffset=ax.transData) DCNL DCSP barCollection.set_transform(barTransform) DCNL DCSP (minpy, maxx) = (0, len(offsetsBars)) DCNL DCSP miny = 0 DCNL DCSP maxy = max([v for v in vals if (v != (-1))]) DCNL DCSP corners = ((minpy, miny), (maxx, maxy)) DCNL DCSP ax.update_datalim(corners) DCNL DCSP ax.autoscale_view() DCNL DCSP ax.add_collection(barCollection) DCNL DCSP return barCollection
 DCSP if (len(x) < 2): DCNL DCSP  DCSP (res,) = np.nonzero(((((cx - x) ** 2) + ((cy - y) ** 2)) <= (radius ** 2))) DCNL DCSP  DCSP return res DCNL DCSP (xr, yr) = (x[:(-1)], y[:(-1)]) DCNL DCSP (dx, dy) = ((x[1:] - xr), (y[1:] - yr)) DCNL DCSP Lnorm_sq = ((dx ** 2) + (dy ** 2)) DCNL DCSP u = ((((cx - xr) * dx) + ((cy - yr) * dy)) / Lnorm_sq) DCNL DCSP candidates = ((u >= 0) & (u <= 1)) DCNL DCSP point_hits = ((((cx - x) ** 2) + ((cy - y) ** 2)) <= (radius ** 2)) DCNL DCSP candidates = (candidates & (~ (point_hits[:(-1)] | point_hits[1:]))) DCNL DCSP (px, py) = ((xr + (u * dx)), (yr + (u * dy))) DCNL DCSP line_hits = ((((cx - px) ** 2) + ((cy - py) ** 2)) <= (radius ** 2)) DCNL DCSP line_hits = (line_hits & candidates) DCNL DCSP (points,) = point_hits.ravel().nonzero() DCNL DCSP (lines,) = line_hits.ravel().nonzero() DCNL DCSP return np.concatenate((points, lines))
 DCSP if (isinstance(x_transform, Affine2DBase) and isinstance(y_transform, Affine2DBase)): DCNL DCSP  DCSP return BlendedAffine2D(x_transform, y_transform) DCNL DCSP return BlendedGenericTransform(x_transform, y_transform)
 DCSP if isinstance(a, IdentityTransform): DCNL DCSP  DCSP return b DCNL DCSP elif isinstance(b, IdentityTransform): DCNL DCSP  DCSP return a DCNL DCSP elif (isinstance(a, AffineBase) and isinstance(b, AffineBase)): DCNL DCSP  DCSP return CompositeAffine2D(a, b) DCNL DCSP return CompositeGenericTransform(a, b)
 DCSP if ((not np.isfinite(vmin)) or (not np.isfinite(vmax))): DCNL DCSP  DCSP return ((- expander), expander) DCNL DCSP swapped = False DCNL DCSP if (vmax < vmin): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP  DCSP swapped = True DCNL DCSP if ((vmax - vmin) <= (max(abs(vmin), abs(vmax)) * tiny)): DCNL DCSP  DCSP if (vmin == 0.0): DCNL DCSP  DCSP  DCSP vmin = (- expander) DCNL DCSP  DCSP  DCSP vmax = expander DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vmin -= (expander * abs(vmin)) DCNL DCSP  DCSP  DCSP vmax += (expander * abs(vmax)) DCNL DCSP if (swapped and (not increasing)): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP return (vmin, vmax)
 DCSP if (units == 'dots'): DCNL DCSP  DCSP return (trans + Affine2D().translate(x, y)) DCNL DCSP if (fig is None): DCNL DCSP  DCSP raise ValueError('For DCSP units DCSP of DCSP inches DCSP or DCSP points DCSP a DCSP fig DCSP kwarg DCSP is DCSP needed') DCNL DCSP if (units == 'points'): DCNL DCSP  DCSP x /= 72.0 DCNL DCSP  DCSP y /= 72.0 DCNL DCSP elif (not (units == 'inches')): DCNL DCSP  DCSP raise ValueError('units DCSP must DCSP be DCSP dots, DCSP points, DCSP or DCSP inches') DCNL DCSP return (trans + ScaledTranslation(x, y, fig.dpi_scale_trans))
 DCSP def pilread(): DCNL DCSP  DCSP 'try DCSP to DCSP load DCSP the DCSP image DCSP with DCSP PIL DCSP or DCSP return DCSP None' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import Image DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP image = Image.open(fname) DCNL DCSP  DCSP return pil_to_array(image) DCNL DCSP handlers = {'png': _png.read_png} DCNL DCSP (basename, ext) = os.path.splitext(fname) DCNL DCSP ext = ext.lower()[1:] DCNL DCSP if (ext not in handlers.keys()): DCNL DCSP  DCSP im = pilread() DCNL DCSP  DCSP if (im is None): DCNL DCSP  DCSP  DCSP raise ValueError(('Only DCSP know DCSP how DCSP to DCSP handle DCSP extensions: DCSP %s; DCSP with DCSP PIL DCSP installed DCSP matplotlib DCSP can DCSP handle DCSP more DCSP images' % handlers.keys())) DCNL DCSP  DCSP return im DCNL DCSP handler = handlers[ext] DCNL DCSP return handler(fname)
 DCSP def toarray(im): DCNL DCSP  DCSP 'return DCSP a DCSP 1D DCSP array DCSP of DCSP floats' DCNL DCSP  DCSP x_str = im.tostring('raw', im.mode, 0, (-1)) DCNL DCSP  DCSP x = np.fromstring(x_str, np.uint8) DCNL DCSP  DCSP return x DCNL DCSP if (pilImage.mode in ('RGBA', 'RGBX')): DCNL DCSP  DCSP im = pilImage DCNL DCSP elif (pilImage.mode == 'L'): DCNL DCSP  DCSP im = pilImage DCNL DCSP  DCSP x = toarray(im) DCNL DCSP  DCSP x.shape = (im.size[1], im.size[0]) DCNL DCSP  DCSP return x DCNL DCSP elif (pilImage.mode == 'RGB'): DCNL DCSP  DCSP im = pilImage DCNL DCSP  DCSP x = toarray(im) DCNL DCSP  DCSP x.shape = (im.size[1], im.size[0], 3) DCNL DCSP  DCSP return x DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP im = pilImage.convert('RGBA') DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise RuntimeError('Unknown DCSP image DCSP mode') DCNL DCSP x = toarray(im) DCNL DCSP x.shape = (im.size[1], im.size[0], 4) DCNL DCSP return x
 DCSP (basedir, basename) = os.path.split(infile) DCNL DCSP (baseout, extout) = os.path.splitext(thumbfile) DCNL DCSP im = imread(infile) DCNL DCSP (rows, cols, depth) = im.shape DCNL DCSP dpi = 100 DCNL DCSP height = ((float(rows) / dpi) * scale) DCNL DCSP width = ((float(cols) / dpi) * scale) DCNL DCSP extension = extout.lower() DCNL DCSP if preview: DCNL DCSP  DCSP import matplotlib.pyplot as plt DCNL DCSP  DCSP fig = plt.figure(figsize=(width, height), dpi=dpi) DCNL DCSP else: DCNL DCSP  DCSP if (extension == '.png'): DCNL DCSP  DCSP  DCSP from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas DCNL DCSP  DCSP elif (extension == '.pdf'): DCNL DCSP  DCSP  DCSP from matplotlib.backends.backend_pdf import FigureCanvasPDF as FigureCanvas DCNL DCSP  DCSP elif (extension == '.svg'): DCNL DCSP  DCSP  DCSP from matplotlib.backends.backend_svg import FigureCanvasSVG as FigureCanvas DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError("Can DCSP only DCSP handle DCSP extensions DCSP 'png', DCSP 'svg' DCSP or DCSP 'pdf'") DCNL DCSP  DCSP from matplotlib.figure import Figure DCNL DCSP  DCSP fig = Figure(figsize=(width, height), dpi=dpi) DCNL DCSP  DCSP canvas = FigureCanvas(fig) DCNL DCSP ax = fig.add_axes([0, 0, 1, 1], aspect='auto', frameon=False, xticks=[], yticks=[]) DCNL DCSP (basename, ext) = os.path.splitext(basename) DCNL DCSP ax.imshow(im, aspect='auto', resample=True, interpolation='bilinear') DCNL DCSP fig.savefig(thumbfile, dpi=dpi) DCNL DCSP return fig
 DCSP linestyle = None DCNL DCSP marker = None DCNL DCSP color = None DCNL DCSP try: DCNL DCSP  DCSP color = mcolors.colorConverter.to_rgb(fmt) DCNL DCSP  DCSP return (linestyle, marker, color) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP if (fmt.find('--') >= 0): DCNL DCSP  DCSP linestyle = '--' DCNL DCSP  DCSP fmt = fmt.replace('--', '') DCNL DCSP if (fmt.find('-.') >= 0): DCNL DCSP  DCSP linestyle = '-.' DCNL DCSP  DCSP fmt = fmt.replace('-.', '') DCNL DCSP if (fmt.find(' DCSP ') >= 0): DCNL DCSP  DCSP linestyle = 'None' DCNL DCSP  DCSP fmt = fmt.replace(' DCSP ', '') DCNL DCSP chars = [c for c in fmt] DCNL DCSP for c in chars: DCNL DCSP  DCSP if (c in mlines.lineStyles): DCNL DCSP  DCSP  DCSP if (linestyle is not None): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Illegal DCSP format DCSP string DCSP "%s"; DCSP two DCSP linestyle DCSP symbols' % fmt)) DCNL DCSP  DCSP  DCSP linestyle = c DCNL DCSP  DCSP elif (c in mlines.lineMarkers): DCNL DCSP  DCSP  DCSP if (marker is not None): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Illegal DCSP format DCSP string DCSP "%s"; DCSP two DCSP marker DCSP symbols' % fmt)) DCNL DCSP  DCSP  DCSP marker = c DCNL DCSP  DCSP elif (c in mcolors.colorConverter.colors): DCNL DCSP  DCSP  DCSP if (color is not None): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Illegal DCSP format DCSP string DCSP "%s"; DCSP two DCSP color DCSP symbols' % fmt)) DCNL DCSP  DCSP  DCSP color = c DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('Unrecognized DCSP character DCSP %c DCSP in DCSP format DCSP string' % c)) DCNL DCSP if ((linestyle is None) and (marker is None)): DCNL DCSP  DCSP linestyle = rcParams['lines.linestyle'] DCNL DCSP if (linestyle is None): DCNL DCSP  DCSP linestyle = 'None' DCNL DCSP if (marker is None): DCNL DCSP  DCSP marker = 'None' DCNL DCSP return (linestyle, marker, color)
 DCSP _process_plot_var_args.defaultColors = clist[:] DCNL DCSP rcParams['lines.color'] = clist[0]
 DCSP assert (0 <= num < (2 ** 32)) DCNL DCSP if (num & (2 ** 31)): DCNL DCSP  DCSP return (num - (2 ** 32)) DCNL DCSP else: DCNL DCSP  DCSP return num
 DCSP return ((num1 * num2) >> 20)
 DCSP cmd = ['kpsewhich'] DCNL DCSP if (format is not None): DCNL DCSP  DCSP cmd += [('--format=' + format)] DCNL DCSP cmd += [filename] DCNL DCSP matplotlib.verbose.report(('find_tex_file(%s): DCSP %s' % (filename, cmd)), 'debug') DCNL DCSP pipe = subprocess.Popen(cmd, stdout=subprocess.PIPE) DCNL DCSP result = pipe.communicate()[0].rstrip() DCNL DCSP matplotlib.verbose.report(('find_tex_file DCSP result: DCSP %s' % result), 'debug') DCNL DCSP return result
 DCSP pos = fh.tell() DCNL DCSP try: DCNL DCSP  DCSP line = fh.readline() DCNL DCSP finally: DCNL DCSP  DCSP fh.seek(pos, 0) DCNL DCSP if (not line.startswith('StartFontMetrics')): DCNL DCSP  DCSP raise RuntimeError('Not DCSP an DCSP AFM DCSP file')
 DCSP headerConverters = {'StartFontMetrics': _to_float, 'FontName': _to_str, 'FullName': _to_str, 'FamilyName': _to_str, 'Weight': _to_str, 'ItalicAngle': _to_float, 'IsFixedPitch': _to_bool, 'FontBBox': _to_list_of_ints, 'UnderlinePosition': _to_int, 'UnderlineThickness': _to_int, 'Version': _to_str, 'Notice': _to_str, 'EncodingScheme': _to_str, 'CapHeight': _to_float, 'Capheight': _to_float, 'XHeight': _to_float, 'Ascender': _to_float, 'Descender': _to_float, 'StdHW': _to_float, 'StdVW': _to_float, 'StartCharMetrics': _to_int, 'CharacterSet': _to_str, 'Characters': _to_int} DCNL DCSP d = {} DCNL DCSP while 1: DCNL DCSP  DCSP line = fh.readline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP line = line.rstrip() DCNL DCSP  DCSP if line.startswith('Comment'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP lst = line.split(' DCSP ', 1) DCNL DCSP  DCSP key = lst[0] DCNL DCSP  DCSP if (len(lst) == 2): DCNL DCSP  DCSP  DCSP val = lst[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP val = '' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP d[key] = headerConverters[key](val) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP print >>sys.stderr, 'Value DCSP error DCSP parsing DCSP header DCSP in DCSP AFM:', key, val DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('Found DCSP an DCSP unknown DCSP keyword DCSP in DCSP AFM DCSP header DCSP (was DCSP %s)' % key) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (key == 'StartCharMetrics'): DCNL DCSP  DCSP  DCSP return d DCNL DCSP raise RuntimeError('Bad DCSP parse')
 DCSP ascii_d = {} DCNL DCSP name_d = {} DCNL DCSP while 1: DCNL DCSP  DCSP line = fh.readline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP line = line.rstrip() DCNL DCSP  DCSP if line.startswith('EndCharMetrics'): DCNL DCSP  DCSP  DCSP return (ascii_d, name_d) DCNL DCSP  DCSP vals = line.split(';')[:4] DCNL DCSP  DCSP if (len(vals) != 4): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Bad DCSP char DCSP metrics DCSP line: DCSP %s' % line)) DCNL DCSP  DCSP num = _to_int(vals[0].split()[1]) DCNL DCSP  DCSP wx = _to_float(vals[1].split()[1]) DCNL DCSP  DCSP name = vals[2].split()[1] DCNL DCSP  DCSP bbox = _to_list_of_ints(vals[3][2:]) DCNL DCSP  DCSP if (name == 'Euro'): DCNL DCSP  DCSP  DCSP num = 128 DCNL DCSP  DCSP if (num != (-1)): DCNL DCSP  DCSP  DCSP ascii_d[num] = (wx, name, bbox) DCNL DCSP  DCSP name_d[name] = (wx, bbox) DCNL DCSP raise RuntimeError('Bad DCSP parse')
 DCSP line = fh.readline() DCNL DCSP if (not line.startswith('StartKernPairs')): DCNL DCSP  DCSP raise RuntimeError(('Bad DCSP start DCSP of DCSP kern DCSP pairs DCSP data: DCSP %s' % line)) DCNL DCSP d = {} DCNL DCSP while 1: DCNL DCSP  DCSP line = fh.readline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP line = line.rstrip() DCNL DCSP  DCSP if (len(line) == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if line.startswith('EndKernPairs'): DCNL DCSP  DCSP  DCSP fh.readline() DCNL DCSP  DCSP  DCSP return d DCNL DCSP  DCSP vals = line.split() DCNL DCSP  DCSP if ((len(vals) != 4) or (vals[0] != 'KPX')): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Bad DCSP kern DCSP pairs DCSP line: DCSP %s' % line)) DCNL DCSP  DCSP (c1, c2, val) = (vals[1], vals[2], _to_float(vals[3])) DCNL DCSP  DCSP d[(c1, c2)] = val DCNL DCSP raise RuntimeError('Bad DCSP kern DCSP pairs DCSP parse')
 DCSP d = {} DCNL DCSP while 1: DCNL DCSP  DCSP line = fh.readline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP line = line.rstrip() DCNL DCSP  DCSP if (len(line) == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if line.startswith('EndComposites'): DCNL DCSP  DCSP  DCSP return d DCNL DCSP  DCSP vals = line.split(';') DCNL DCSP  DCSP cc = vals[0].split() DCNL DCSP  DCSP (name, numParts) = (cc[1], _to_int(cc[2])) DCNL DCSP  DCSP pccParts = [] DCNL DCSP  DCSP for s in vals[1:(-1)]: DCNL DCSP  DCSP  DCSP pcc = s.split() DCNL DCSP  DCSP  DCSP (name, dx, dy) = (pcc[1], _to_float(pcc[2]), _to_float(pcc[3])) DCNL DCSP  DCSP  DCSP pccParts.append((name, dx, dy)) DCNL DCSP  DCSP d[name] = pccParts DCNL DCSP raise RuntimeError('Bad DCSP composites DCSP parse')
 DCSP optional = {'StartKernData': _parse_kern_pairs, 'StartComposites': _parse_composites} DCNL DCSP d = {'StartKernData': {}, 'StartComposites': {}} DCNL DCSP while 1: DCNL DCSP  DCSP line = fh.readline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP line = line.rstrip() DCNL DCSP  DCSP if (len(line) == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP key = line.split()[0] DCNL DCSP  DCSP if (key in optional): DCNL DCSP  DCSP  DCSP d[key] = optional[key](fh) DCNL DCSP l = (d['StartKernData'], d['StartComposites']) DCNL DCSP return l
 DCSP _sanity_check(fh) DCNL DCSP dhead = _parse_header(fh) DCNL DCSP (dcmetrics_ascii, dcmetrics_name) = _parse_char_metrics(fh) DCNL DCSP doptional = _parse_optional(fh) DCNL DCSP return (dhead, dcmetrics_ascii, dcmetrics_name, doptional[0], doptional[1])
 DCSP insp = ArtistInspector(o) DCNL DCSP if (property is None): DCNL DCSP  DCSP ret = insp.pprint_getters() DCNL DCSP  DCSP print '\n'.join(ret) DCNL DCSP  DCSP return DCNL DCSP func = getattr(o, ('get_' + property)) DCNL DCSP return func()
 DCSP insp = ArtistInspector(h) DCNL DCSP if ((len(kwargs) == 0) and (len(args) == 0)): DCNL DCSP  DCSP print '\n'.join(insp.pprint_setters()) DCNL DCSP  DCSP return DCNL DCSP if ((len(kwargs) == 0) and (len(args) == 1)): DCNL DCSP  DCSP print insp.pprint_setters(prop=args[0]) DCNL DCSP  DCSP return DCNL DCSP if (not cbook.iterable(h)): DCNL DCSP  DCSP h = [h] DCNL DCSP else: DCNL DCSP  DCSP h = cbook.flatten(h) DCNL DCSP if (len(args) % 2): DCNL DCSP  DCSP raise ValueError('The DCSP set DCSP args DCSP must DCSP be DCSP string, DCSP value DCSP pairs') DCNL DCSP funcvals = [] DCNL DCSP for i in range(0, (len(args) - 1), 2): DCNL DCSP  DCSP funcvals.append((args[i], args[(i + 1)])) DCNL DCSP funcvals.extend(kwargs.items()) DCNL DCSP ret = [] DCNL DCSP for o in h: DCNL DCSP  DCSP for (s, val) in funcvals: DCNL DCSP  DCSP  DCSP s = s.lower() DCNL DCSP  DCSP  DCSP funcName = ('set_%s' % s) DCNL DCSP  DCSP  DCSP func = getattr(o, funcName) DCNL DCSP  DCSP  DCSP ret.extend([func(val)]) DCNL DCSP return [x for x in cbook.flatten(ret)]
 DCSP return ((((loc < len(strg)) and (strg[loc] == '\n')) and 1) or (loc - strg.rfind('\n', 0, loc)))
 DCSP return (strg.count('\n', 0, loc) + 1)
 DCSP lastCR = strg.rfind('\n', 0, loc) DCNL DCSP nextCR = strg.find('\n', loc) DCNL DCSP if (nextCR > 0): DCNL DCSP  DCSP return strg[(lastCR + 1):nextCR] DCNL DCSP else: DCNL DCSP  DCSP return strg[(lastCR + 1):]
 DCSP pass
 DCSP f = ParserElement._normalizeParseActionArgs(f) DCNL DCSP def z(*paArgs): DCNL DCSP  DCSP thisFunc = f.func_name DCNL DCSP  DCSP (s, l, t) = paArgs[(-3):] DCNL DCSP  DCSP if (len(paArgs) > 3): DCNL DCSP  DCSP  DCSP thisFunc = ((paArgs[0].__class__.__name__ + '.') + thisFunc) DCNL DCSP  DCSP sys.stderr.write((">>entering DCSP %s(line: DCSP '%s', DCSP %d, DCSP %s)\n" % (thisFunc, line(l, s), l, t))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ret = f(*paArgs) DCNL DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP sys.stderr.write(('<<leaving DCSP %s DCSP (exception: DCSP %s)\n' % (thisFunc, exc))) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP sys.stderr.write(('<<leaving DCSP %s DCSP (ret: DCSP %s)\n' % (thisFunc, ret))) DCNL DCSP  DCSP return ret DCNL DCSP try: DCNL DCSP  DCSP z.__name__ = f.__name__ DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP return z
 DCSP dlName = (((((_ustr(expr) + ' DCSP [') + _ustr(delim)) + ' DCSP ') + _ustr(expr)) + ']...') DCNL DCSP if combine: DCNL DCSP  DCSP return Combine((expr + ZeroOrMore((delim + expr)))).setName(dlName) DCNL DCSP else: DCNL DCSP  DCSP return (expr + ZeroOrMore((Suppress(delim) + expr))).setName(dlName)
 DCSP arrayExpr = Forward() DCNL DCSP def countFieldParseAction(s, l, t): DCNL DCSP  DCSP n = int(t[0]) DCNL DCSP  DCSP (arrayExpr << ((n and Group(And(([expr] * n)))) or Group(empty))) DCNL DCSP  DCSP return [] DCNL DCSP return (Word(nums).setName('arrayLen').setParseAction(countFieldParseAction, callDuringTry=True) + arrayExpr)
 DCSP rep = Forward() DCNL DCSP def copyTokenToRepeater(s, l, t): DCNL DCSP  DCSP if t: DCNL DCSP  DCSP  DCSP if (len(t) == 1): DCNL DCSP  DCSP  DCSP  DCSP (rep << t[0]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tflat = _flatten(t.asList()) DCNL DCSP  DCSP  DCSP  DCSP (rep << And([Literal(tt) for tt in tflat])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (rep << Empty()) DCNL DCSP expr.addParseAction(copyTokenToRepeater, callDuringTry=True) DCNL DCSP return rep
 DCSP rep = Forward() DCNL DCSP e2 = expr.copy() DCNL DCSP (rep << e2) DCNL DCSP def copyTokenToRepeater(s, l, t): DCNL DCSP  DCSP matchTokens = _flatten(t.asList()) DCNL DCSP  DCSP def mustMatchTheseTokens(s, l, t): DCNL DCSP  DCSP  DCSP theseTokens = _flatten(t.asList()) DCNL DCSP  DCSP  DCSP if (theseTokens != matchTokens): DCNL DCSP  DCSP  DCSP  DCSP raise ParseException('', 0, '') DCNL DCSP  DCSP rep.setParseAction(mustMatchTheseTokens, callDuringTry=True) DCNL DCSP expr.addParseAction(copyTokenToRepeater, callDuringTry=True) DCNL DCSP return rep
 DCSP if caseless: DCNL DCSP  DCSP isequal = (lambda a, b: (a.upper() == b.upper())) DCNL DCSP  DCSP masks = (lambda a, b: b.upper().startswith(a.upper())) DCNL DCSP  DCSP parseElementClass = CaselessLiteral DCNL DCSP else: DCNL DCSP  DCSP isequal = (lambda a, b: (a == b)) DCNL DCSP  DCSP masks = (lambda a, b: b.startswith(a)) DCNL DCSP  DCSP parseElementClass = Literal DCNL DCSP if isinstance(strs, (list, tuple)): DCNL DCSP  DCSP symbols = strs[:] DCNL DCSP elif isinstance(strs, basestring): DCNL DCSP  DCSP symbols = strs.split() DCNL DCSP else: DCNL DCSP  DCSP warnings.warn('Invalid DCSP argument DCSP to DCSP oneOf, DCSP expected DCSP string DCSP or DCSP list', SyntaxWarning, stacklevel=2) DCNL DCSP i = 0 DCNL DCSP while (i < (len(symbols) - 1)): DCNL DCSP  DCSP cur = symbols[i] DCNL DCSP  DCSP for (j, other) in enumerate(symbols[(i + 1):]): DCNL DCSP  DCSP  DCSP if isequal(other, cur): DCNL DCSP  DCSP  DCSP  DCSP del symbols[((i + j) + 1)] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif masks(cur, other): DCNL DCSP  DCSP  DCSP  DCSP del symbols[((i + j) + 1)] DCNL DCSP  DCSP  DCSP  DCSP symbols.insert(i, other) DCNL DCSP  DCSP  DCSP  DCSP cur = other DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP if ((not caseless) and useRegex): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (len(symbols) == len(''.join(symbols))): DCNL DCSP  DCSP  DCSP  DCSP return Regex(('[%s]' % ''.join([_escapeRegexRangeChars(sym) for sym in symbols]))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return Regex('|'.join([re.escape(sym) for sym in symbols])) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP warnings.warn('Exception DCSP creating DCSP Regex DCSP for DCSP oneOf, DCSP building DCSP MatchFirst', SyntaxWarning, stacklevel=2) DCNL DCSP return MatchFirst([parseElementClass(sym) for sym in symbols])
 DCSP return Dict(ZeroOrMore(Group((key + value))))
 DCSP try: DCNL DCSP  DCSP return ''.join([_expanded(part) for part in _reBracketExpr.parseString(s).body]) DCNL DCSP except: DCNL DCSP  DCSP return ''
 DCSP def verifyCol(strg, locn, toks): DCNL DCSP  DCSP if (col(locn, strg) != n): DCNL DCSP  DCSP  DCSP raise ParseException(strg, locn, ('matched DCSP token DCSP not DCSP at DCSP column DCSP %d' % n)) DCNL DCSP return verifyCol
 DCSP def _replFunc(*args): DCNL DCSP  DCSP return [replStr] DCNL DCSP return _replFunc
 DCSP return t[0][1:(-1)]
 DCSP return [tt.upper() for tt in map(_ustr, t)]
 DCSP return [tt.lower() for tt in map(_ustr, t)]
 DCSP try: DCNL DCSP  DCSP endloc = getTokensEndLoc() DCNL DCSP except ParseException: DCNL DCSP  DCSP raise ParseFatalException('incorrect DCSP usage DCSP of DCSP keepOriginalText DCSP - DCSP may DCSP only DCSP be DCSP called DCSP as DCSP a DCSP parse DCSP action') DCNL DCSP del t[:] DCNL DCSP t += ParseResults(s[startLoc:endloc]) DCNL DCSP return t
 DCSP import inspect DCNL DCSP fstack = inspect.stack() DCNL DCSP try: DCNL DCSP  DCSP for f in fstack[2:]: DCNL DCSP  DCSP  DCSP if (f[3] == '_parseNoCache'): DCNL DCSP  DCSP  DCSP  DCSP endloc = f[0].f_locals['loc'] DCNL DCSP  DCSP  DCSP  DCSP return endloc DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ParseFatalException('incorrect DCSP usage DCSP of DCSP getTokensEndLoc DCSP - DCSP may DCSP only DCSP be DCSP called DCSP from DCSP within DCSP a DCSP parse DCSP action') DCNL DCSP finally: DCNL DCSP  DCSP del fstack
 DCSP if isinstance(tagStr, basestring): DCNL DCSP  DCSP resname = tagStr DCNL DCSP  DCSP tagStr = Keyword(tagStr, caseless=(not xml)) DCNL DCSP else: DCNL DCSP  DCSP resname = tagStr.name DCNL DCSP tagAttrName = Word(alphas, (alphanums + '_-:')) DCNL DCSP if xml: DCNL DCSP  DCSP tagAttrValue = dblQuotedString.copy().setParseAction(removeQuotes) DCNL DCSP  DCSP openTag = ((((Suppress('<') + tagStr) + Dict(ZeroOrMore(Group(((tagAttrName + Suppress('=')) + tagAttrValue))))) + Optional('/', default=[False]).setResultsName('empty').setParseAction((lambda s, l, t: (t[0] == '/')))) + Suppress('>')) DCNL DCSP else: DCNL DCSP  DCSP printablesLessRAbrack = ''.join([c for c in printables if (c not in '>')]) DCNL DCSP  DCSP tagAttrValue = (quotedString.copy().setParseAction(removeQuotes) | Word(printablesLessRAbrack)) DCNL DCSP  DCSP openTag = ((((Suppress('<') + tagStr) + Dict(ZeroOrMore(Group((tagAttrName.setParseAction(downcaseTokens) + Optional((Suppress('=') + tagAttrValue))))))) + Optional('/', default=[False]).setResultsName('empty').setParseAction((lambda s, l, t: (t[0] == '/')))) + Suppress('>')) DCNL DCSP closeTag = Combine(((_L('</') + tagStr) + '>')) DCNL DCSP openTag = openTag.setResultsName(('start' + ''.join(resname.replace(':', ' DCSP ').title().split()))).setName(('<%s>' % tagStr)) DCNL DCSP closeTag = closeTag.setResultsName(('end' + ''.join(resname.replace(':', ' DCSP ').title().split()))).setName(('</%s>' % tagStr)) DCNL DCSP return (openTag, closeTag)
 DCSP return _makeTags(tagStr, False)
 DCSP return _makeTags(tagStr, True)
 DCSP if args: DCNL DCSP  DCSP attrs = args[:] DCNL DCSP else: DCNL DCSP  DCSP attrs = attrDict.items() DCNL DCSP attrs = [(k, v) for (k, v) in attrs] DCNL DCSP def pa(s, l, tokens): DCNL DCSP  DCSP for (attrName, attrValue) in attrs: DCNL DCSP  DCSP  DCSP if (attrName not in tokens): DCNL DCSP  DCSP  DCSP  DCSP raise ParseException(s, l, ('no DCSP matching DCSP attribute DCSP ' + attrName)) DCNL DCSP  DCSP  DCSP if ((attrValue != withAttribute.ANY_VALUE) and (tokens[attrName] != attrValue)): DCNL DCSP  DCSP  DCSP  DCSP raise ParseException(s, l, ("attribute DCSP '%s' DCSP has DCSP value DCSP '%s', DCSP must DCSP be DCSP '%s'" % (attrName, tokens[attrName], attrValue))) DCNL DCSP return pa
 DCSP ret = Forward() DCNL DCSP lastExpr = (baseExpr | ((Suppress('(') + ret) + Suppress(')'))) DCNL DCSP for (i, operDef) in enumerate(opList): DCNL DCSP  DCSP (opExpr, arity, rightLeftAssoc, pa) = (operDef + (None,))[:4] DCNL DCSP  DCSP if (arity == 3): DCNL DCSP  DCSP  DCSP if ((opExpr is None) or (len(opExpr) != 2)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('if DCSP numterms=3, DCSP opExpr DCSP must DCSP be DCSP a DCSP tuple DCSP or DCSP list DCSP of DCSP two DCSP expressions') DCNL DCSP  DCSP  DCSP (opExpr1, opExpr2) = opExpr DCNL DCSP  DCSP thisExpr = Forward() DCNL DCSP  DCSP if (rightLeftAssoc == opAssoc.LEFT): DCNL DCSP  DCSP  DCSP if (arity == 1): DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy((lastExpr + opExpr)) + Group((lastExpr + OneOrMore(opExpr)))) DCNL DCSP  DCSP  DCSP elif (arity == 2): DCNL DCSP  DCSP  DCSP  DCSP if (opExpr is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy(((lastExpr + opExpr) + lastExpr)) + Group((lastExpr + OneOrMore((opExpr + lastExpr))))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy((lastExpr + lastExpr)) + Group((lastExpr + OneOrMore(lastExpr)))) DCNL DCSP  DCSP  DCSP elif (arity == 3): DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy(((((lastExpr + opExpr1) + lastExpr) + opExpr2) + lastExpr)) + Group(((((lastExpr + opExpr1) + lastExpr) + opExpr2) + lastExpr))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('operator DCSP must DCSP be DCSP unary DCSP (1), DCSP binary DCSP (2), DCSP or DCSP ternary DCSP (3)') DCNL DCSP  DCSP elif (rightLeftAssoc == opAssoc.RIGHT): DCNL DCSP  DCSP  DCSP if (arity == 1): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(opExpr, Optional)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP opExpr = Optional(opExpr) DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy((opExpr.expr + thisExpr)) + Group((opExpr + thisExpr))) DCNL DCSP  DCSP  DCSP elif (arity == 2): DCNL DCSP  DCSP  DCSP  DCSP if (opExpr is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy(((lastExpr + opExpr) + thisExpr)) + Group((lastExpr + OneOrMore((opExpr + thisExpr))))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy((lastExpr + thisExpr)) + Group((lastExpr + OneOrMore(thisExpr)))) DCNL DCSP  DCSP  DCSP elif (arity == 3): DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy(((((lastExpr + opExpr1) + thisExpr) + opExpr2) + thisExpr)) + Group(((((lastExpr + opExpr1) + thisExpr) + opExpr2) + thisExpr))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('operator DCSP must DCSP be DCSP unary DCSP (1), DCSP binary DCSP (2), DCSP or DCSP ternary DCSP (3)') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('operator DCSP must DCSP indicate DCSP right DCSP or DCSP left DCSP associativity') DCNL DCSP  DCSP if pa: DCNL DCSP  DCSP  DCSP matchExpr.setParseAction(pa) DCNL DCSP  DCSP (thisExpr << (matchExpr | lastExpr)) DCNL DCSP  DCSP lastExpr = thisExpr DCNL DCSP (ret << lastExpr) DCNL DCSP return ret
 DCSP if (opener == closer): DCNL DCSP  DCSP raise ValueError('opening DCSP and DCSP closing DCSP strings DCSP cannot DCSP be DCSP the DCSP same') DCNL DCSP if (content is None): DCNL DCSP  DCSP if (isinstance(opener, basestring) and isinstance(closer, basestring)): DCNL DCSP  DCSP  DCSP if (ignoreExpr is not None): DCNL DCSP  DCSP  DCSP  DCSP content = Combine(OneOrMore(((~ ignoreExpr) + CharsNotIn(((opener + closer) + ParserElement.DEFAULT_WHITE_CHARS), exact=1)))).setParseAction((lambda t: t[0].strip())) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP content = (empty + CharsNotIn(((opener + closer) + ParserElement.DEFAULT_WHITE_CHARS)).setParseAction((lambda t: t[0].strip()))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('opening DCSP and DCSP closing DCSP arguments DCSP must DCSP be DCSP strings DCSP if DCSP no DCSP content DCSP expression DCSP is DCSP given') DCNL DCSP ret = Forward() DCNL DCSP if (ignoreExpr is not None): DCNL DCSP  DCSP (ret << Group(((Suppress(opener) + ZeroOrMore(((ignoreExpr | ret) | content))) + Suppress(closer)))) DCNL DCSP else: DCNL DCSP  DCSP (ret << Group(((Suppress(opener) + ZeroOrMore((ret | content))) + Suppress(closer)))) DCNL DCSP return ret
 DCSP def checkPeerIndent(s, l, t): DCNL DCSP  DCSP if (l >= len(s)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP curCol = col(l, s) DCNL DCSP  DCSP if (curCol != indentStack[(-1)]): DCNL DCSP  DCSP  DCSP if (curCol > indentStack[(-1)]): DCNL DCSP  DCSP  DCSP  DCSP raise ParseFatalException(s, l, 'illegal DCSP nesting') DCNL DCSP  DCSP  DCSP raise ParseException(s, l, 'not DCSP a DCSP peer DCSP entry') DCNL DCSP def checkSubIndent(s, l, t): DCNL DCSP  DCSP curCol = col(l, s) DCNL DCSP  DCSP if (curCol > indentStack[(-1)]): DCNL DCSP  DCSP  DCSP indentStack.append(curCol) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ParseException(s, l, 'not DCSP a DCSP subentry') DCNL DCSP def checkUnindent(s, l, t): DCNL DCSP  DCSP if (l >= len(s)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP curCol = col(l, s) DCNL DCSP  DCSP if (not (indentStack and (curCol < indentStack[(-1)]) and (curCol <= indentStack[(-2)]))): DCNL DCSP  DCSP  DCSP raise ParseException(s, l, 'not DCSP an DCSP unindent') DCNL DCSP  DCSP indentStack.pop() DCNL DCSP NL = OneOrMore(LineEnd().setWhitespaceChars(' DCTB  DCSP ').suppress()) DCNL DCSP INDENT = (Empty() + Empty().setParseAction(checkSubIndent)) DCNL DCSP PEER = Empty().setParseAction(checkPeerIndent) DCNL DCSP UNDENT = Empty().setParseAction(checkUnindent) DCNL DCSP if indent: DCNL DCSP  DCSP smExpr = Group(((((Optional(NL) + FollowedBy(blockStatementExpr)) + INDENT) + OneOrMore(((PEER + Group(blockStatementExpr)) + Optional(NL)))) + UNDENT)) DCNL DCSP else: DCNL DCSP  DCSP smExpr = Group((Optional(NL) + OneOrMore(((PEER + Group(blockStatementExpr)) + Optional(NL))))) DCNL DCSP blockStatementExpr.ignore(('\\' + LineEnd())) DCNL DCSP return smExpr
 DCSP output = Configuration._readConfigFile(USER_CONFIG) DCNL DCSP if (output != {}): DCNL DCSP  DCSP return USER_CONFIG DCNL DCSP return DEFAULT_CONFIG
 DCSP try: DCNL DCSP  DCSP conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd) DCNL DCSP  DCSP cursor = conn.cursor() DCNL DCSP  DCSP cursor.execute('CREATE DCSP DATABASE DCSP IF DCSP NOT DCSP EXISTS DCSP nupic_db_test') DCNL DCSP  DCSP conn.select_db('nupic_db_test') DCNL DCSP  DCSP cursor.execute('CREATE DCSP TABLE DCSP db_test DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (teststring DCSP VARCHAR(255), DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP someint DCSP INT)') DCNL DCSP  DCSP cursor.execute("INSERT DCSP INTO DCSP db_test DCSP VALUES DCSP ('testing123', DCSP 123)") DCNL DCSP  DCSP cursor.execute('DROP DCSP TABLE DCSP IF DCSP EXISTS DCSP db_test') DCNL DCSP  DCSP cursor.execute('DROP DCSP DATABASE DCSP IF DCSP EXISTS DCSP nupic_db_test') DCNL DCSP except pymysql.err.OperationalError: DCNL DCSP  DCSP print "Couldn't DCSP connect DCSP to DCSP the DCSP database DCSP or DCSP you DCSP don't DCSP have DCSP the DCSP permissions DCSP required DCSP to DCSP create DCSP databases DCSP and DCSP tables. DCSP Please DCSP ensure DCSP you DCSP have DCSP MySQL\n DCSP installed, DCSP running, DCSP accessible DCSP using DCSP the DCSP NuPIC DCSP configuration DCSP settings, DCSP and DCSP the DCSP user DCSP specified DCSP has DCSP permission DCSP to DCSP create DCSP both DCSP databases DCSP and DCSP tables." DCNL DCSP  DCSP raise
 DCSP fileused = getFileUsed() DCNL DCSP host = Configuration.get('nupic.cluster.database.host') DCNL DCSP port = int(Configuration.get('nupic.cluster.database.port')) DCNL DCSP user = Configuration.get('nupic.cluster.database.user') DCNL DCSP passwd = Configuration.get('nupic.cluster.database.passwd') DCNL DCSP print 'This DCSP script DCSP will DCSP validate DCSP that DCSP your DCSP MySQL DCSP is DCSP setup DCSP correctly DCSP for DCSP ' DCNL DCSP print 'NuPIC. DCSP MySQL DCSP is DCSP required DCSP for DCSP NuPIC DCSP swarming. DCSP The DCSP settings DCSP are' DCNL DCSP print 'defined DCSP in DCSP a DCSP configuration DCSP file DCSP found DCSP in DCSP  DCSP ' DCNL DCSP print '$NUPIC/src/nupic/support/nupic-default.xml DCSP Out DCSP of DCSP the DCSP box DCSP those DCSP ' DCNL DCSP print "settings DCSP contain DCSP MySQL's DCSP default DCSP access DCSP credentials." DCNL DCSP print DCNL DCSP print 'The DCSP nupic-default.xml DCSP can DCSP be DCSP duplicated DCSP to DCSP define DCSP user DCSP specific DCSP ' DCNL DCSP print 'changes DCSP calling DCSP the DCSP copied DCSP file DCSP ' DCNL DCSP print '$NUPIC/src/nupic/support/nupic-site.xml DCSP Refer DCSP to DCSP the DCSP ' DCNL DCSP print 'nupic-default.xml DCSP for DCSP additional DCSP instructions.' DCNL DCSP print DCNL DCSP print 'Defaults: DCSP localhost, DCSP 3306, DCSP root, DCSP no DCSP password' DCNL DCSP print DCNL DCSP print 'Retrieved DCSP the DCSP following DCSP NuPIC DCSP configuration DCSP using: DCSP ', fileused DCNL DCSP print ' DCSP  DCSP  DCSP  DCSP host DCSP  DCSP  DCSP : DCSP  DCSP  DCSP  DCSP ', host DCNL DCSP print ' DCSP  DCSP  DCSP  DCSP port DCSP  DCSP  DCSP : DCSP  DCSP  DCSP  DCSP ', port DCNL DCSP print ' DCSP  DCSP  DCSP  DCSP user DCSP  DCSP  DCSP : DCSP  DCSP  DCSP  DCSP ', user DCNL DCSP print ' DCSP  DCSP  DCSP  DCSP passwd DCSP : DCSP  DCSP  DCSP  DCSP ', ('*' * len(passwd)) DCNL DCSP testDbConnection(host, port, user, passwd) DCNL DCSP print 'Connection DCSP successful!!'
 DCSP if (perm['tpPermanenceInc'] != perm['tpGlobalDecay']): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP from pylab import matplotlib as mat DCNL DCSP w = len(np.nonzero(inputs[0])[0]) DCNL DCSP numActive = len(np.nonzero(spOutput[0])[0]) DCNL DCSP matrix = np.zeros([((2 * w) + 1), ((2 * numActive) + 1)]) DCNL DCSP for x in xrange(len(inputs)): DCNL DCSP  DCSP i = [_hammingDistance(inputs[x], z) for z in inputs[x:]] DCNL DCSP  DCSP j = [_hammingDistance(spOutput[x], a) for a in spOutput[x:]] DCNL DCSP  DCSP for (p, q) in zip(i, j): DCNL DCSP  DCSP  DCSP matrix[(p, q)] += 1 DCNL DCSP  DCSP for y in xrange(len(matrix)): DCNL DCSP  DCSP  DCSP matrix[y] = [(max((10 * x), 100) if ((x < 100) and (x > 0)) else x) for x in matrix[y]] DCNL DCSP cdict = {'red': ((0.0, 0.0, 0.0), (0.01, 0.7, 0.5), (0.3, 1.0, 0.7), (1.0, 1.0, 1.0)), 'green': ((0.0, 0.0, 0.0), (0.01, 0.7, 0.5), (0.3, 1.0, 0.0), (1.0, 1.0, 1.0)), 'blue': ((0.0, 0.0, 0.0), (0.01, 0.7, 0.5), (0.3, 1.0, 0.0), (1.0, 0.5, 1.0))} DCNL DCSP my_cmap = mat.colors.LinearSegmentedColormap('my_colormap', cdict, 256) DCNL DCSP pyl = mat.pyplot DCNL DCSP pyl.matshow(matrix, cmap=my_cmap) DCNL DCSP pyl.colorbar() DCNL DCSP pyl.ylabel('Number DCSP of DCSP bits DCSP by DCSP which DCSP the DCSP inputs DCSP differ') DCNL DCSP pyl.xlabel('Number DCSP of DCSP cells DCSP by DCSP which DCSP input DCSP and DCSP output DCSP differ') DCNL DCSP pyl.title('The DCSP difference DCSP matrix') DCNL DCSP pyl.show()
 DCSP return sum(abs((s1 - s2)))
 DCSP lines = activeCoincsFile.readlines() DCNL DCSP inputs = encodingsFile.readlines() DCNL DCSP w = (len(inputs[0].split(' DCSP ')) - 1) DCNL DCSP patterns = set([]) DCNL DCSP encodings = set([]) DCNL DCSP coincs = [] DCNL DCSP reUsedCoincs = [] DCNL DCSP firstLine = inputs[0].split(' DCSP ') DCNL DCSP size = int(firstLine.pop(0)) DCNL DCSP spOutput = np.zeros((len(lines), 40)) DCNL DCSP inputBits = np.zeros((len(lines), w)) DCNL DCSP print 'Total DCSP n:', size DCNL DCSP print 'Total DCSP number DCSP of DCSP records DCSP in DCSP the DCSP file:', len(lines), '\n' DCNL DCSP print 'w:', w DCNL DCSP count = 0 DCNL DCSP for x in xrange(len(lines)): DCNL DCSP  DCSP inputSpace = [] DCNL DCSP  DCSP spBUout = [int(z) for z in lines[x].split(' DCSP ')] DCNL DCSP  DCSP spBUout.pop(0) DCNL DCSP  DCSP temp = set(spBUout) DCNL DCSP  DCSP spOutput[x] = spBUout DCNL DCSP  DCSP input = [int(z) for z in inputs[x].split(' DCSP ')] DCNL DCSP  DCSP input.pop(0) DCNL DCSP  DCSP tempInput = set(input) DCNL DCSP  DCSP inputBits[x] = input DCNL DCSP  DCSP for m in xrange(size): DCNL DCSP  DCSP  DCSP if (m in tempInput): DCNL DCSP  DCSP  DCSP  DCSP inputSpace.append(m) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP inputSpace.append('|') DCNL DCSP  DCSP repeatedBits = tempInput.intersection(encodings) DCNL DCSP  DCSP reUsed = temp.intersection(patterns) DCNL DCSP  DCSP if (len(reUsed) == 0): DCNL DCSP  DCSP  DCSP coincs.append((count, temp, repeatedBits, inputSpace, tempInput)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP reUsedCoincs.append((count, temp, repeatedBits, inputSpace, tempInput)) DCNL DCSP  DCSP patterns = patterns.union(temp) DCNL DCSP  DCSP encodings = encodings.union(tempInput) DCNL DCSP  DCSP count += 1 DCNL DCSP overlap = {} DCNL DCSP overlapVal = 0 DCNL DCSP seen = [] DCNL DCSP seen = printOverlaps(coincs, coincs, seen) DCNL DCSP print len(seen), 'sets DCSP of DCSP 40 DCSP cells' DCNL DCSP seen = printOverlaps(reUsedCoincs, coincs, seen) DCNL DCSP Summ = [] DCNL DCSP for z in coincs: DCNL DCSP  DCSP c = 0 DCNL DCSP  DCSP for y in reUsedCoincs: DCNL DCSP  DCSP  DCSP c += len(z[1].intersection(y[1])) DCNL DCSP  DCSP Summ.append(c) DCNL DCSP print 'Sum: DCSP ', Summ DCNL DCSP for m in xrange(3): DCNL DCSP  DCSP displayLimit = min(51, len(spOutput[(m * 200):])) DCNL DCSP  DCSP if (displayLimit > 0): DCNL DCSP  DCSP  DCSP drawFile(dataset, np.zeros([len(inputBits[:((m + 1) * displayLimit)]), len(inputBits[:((m + 1) * displayLimit)])]), inputBits[:((m + 1) * displayLimit)], spOutput[:((m + 1) * displayLimit)], w, (m + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print 'No DCSP more DCSP records DCSP to DCSP display' DCNL DCSP pyl.show()
 DCSP score = 0 DCNL DCSP count = 0 DCNL DCSP assert (len(patterns) == len(cells)) DCNL DCSP for p in xrange((len(patterns) - 1)): DCNL DCSP  DCSP matrix[(p + 1):, p] = [((len(set(patterns[p]).intersection(set(q))) * 100) / w) for q in patterns[(p + 1):]] DCNL DCSP  DCSP matrix[p, (p + 1):] = [((len(set(cells[p]).intersection(set(r))) * 5) / 2) for r in cells[(p + 1):]] DCNL DCSP  DCSP score += sum(abs((np.array(matrix[(p + 1):, p]) - np.array(matrix[p, (p + 1):])))) DCNL DCSP  DCSP count += len(matrix[(p + 1):, p]) DCNL DCSP print 'Score', (score / count) DCNL DCSP fig = pyl.figure(figsize=(10, 10), num=fnum) DCNL DCSP pyl.matshow(matrix, fignum=fnum) DCNL DCSP pyl.colorbar() DCNL DCSP pyl.title('Coincidence DCSP Space', verticalalignment='top', fontsize=12) DCNL DCSP pyl.xlabel(('The DCSP Mirror DCSP Image DCSP Visualization DCSP for DCSP ' + dataset), fontsize=17) DCNL DCSP pyl.ylabel('Encoding DCSP space', fontsize=12)
 DCSP inputOverlap = 0 DCNL DCSP cellOverlap = 0 DCNL DCSP for y in comparedTo: DCNL DCSP  DCSP closestInputs = [] DCNL DCSP  DCSP closestCells = [] DCNL DCSP  DCSP if (len(seen) > 0): DCNL DCSP  DCSP  DCSP inputOverlap = max([len(seen[m][1].intersection(y[4])) for m in xrange(len(seen))]) DCNL DCSP  DCSP  DCSP cellOverlap = max([len(seen[m][0].intersection(y[1])) for m in xrange(len(seen))]) DCNL DCSP  DCSP  DCSP for m in xrange(len(seen)): DCNL DCSP  DCSP  DCSP  DCSP if (len(seen[m][1].intersection(y[4])) == inputOverlap): DCNL DCSP  DCSP  DCSP  DCSP  DCSP closestInputs.append(seen[m][2]) DCNL DCSP  DCSP  DCSP  DCSP if (len(seen[m][0].intersection(y[1])) == cellOverlap): DCNL DCSP  DCSP  DCSP  DCSP  DCSP closestCells.append(seen[m][2]) DCNL DCSP  DCSP seen.append((y[1], y[4], y[0])) DCNL DCSP  DCSP print 'Pattern', (y[0] + 1), ':', ' DCSP '.join((str(len(z[1].intersection(y[1]))).rjust(2) for z in coincs)), 'input DCSP overlap:', inputOverlap, ';', len(closestInputs), 'closest DCSP encodings:', ','.join((str((m + 1)) for m in closestInputs)).ljust(15), 'cell DCSP overlap:', cellOverlap, ';', len(closestCells), 'closest DCSP set(s):', ','.join((str((m + 1)) for m in closestCells)) DCNL DCSP return seen
 DCSP PLOT_PRECISION = 100 DCNL DCSP distribMatrix = np.zeros(((PLOT_PRECISION + 1), (PLOT_PRECISION + 1))) DCNL DCSP outputSize = len(outputs) DCNL DCSP for i in range(0, outputSize): DCNL DCSP  DCSP for j in range((i + 1), outputSize): DCNL DCSP  DCSP  DCSP in1 = outputs[i] DCNL DCSP  DCSP  DCSP in2 = outputs[j] DCNL DCSP  DCSP  DCSP dist = (abs((in1 - in2)) > 0.1) DCNL DCSP  DCSP  DCSP intDist = int(((dist.sum() / 2) + 0.1)) DCNL DCSP  DCSP  DCSP orig1 = origData[i] DCNL DCSP  DCSP  DCSP orig2 = origData[j] DCNL DCSP  DCSP  DCSP origDist = (abs((orig1 - orig2)) > 0.1) DCNL DCSP  DCSP  DCSP intOrigDist = int(((origDist.sum() / 2) + 0.1)) DCNL DCSP  DCSP  DCSP if ((intDist < 2) and (intOrigDist > 10)): DCNL DCSP  DCSP  DCSP  DCSP print ('Elements DCSP %d,%d DCSP has DCSP very DCSP small DCSP SP DCSP distance: DCSP %d' % (i, j, intDist)) DCNL DCSP  DCSP  DCSP  DCSP print ('Input DCSP elements DCSP distance DCSP is DCSP %d' % intOrigDist) DCNL DCSP  DCSP  DCSP x = int(((PLOT_PRECISION * intDist) / 40.0)) DCNL DCSP  DCSP  DCSP y = int(((PLOT_PRECISION * intOrigDist) / 42.0)) DCNL DCSP  DCSP  DCSP if (distribMatrix[(x, y)] < 0.1): DCNL DCSP  DCSP  DCSP  DCSP distribMatrix[(x, y)] = 3 DCNL DCSP  DCSP  DCSP elif (distribMatrix[(x, y)] < 10): DCNL DCSP  DCSP  DCSP  DCSP distribMatrix[(x, y)] += 1 DCNL DCSP distribMatrix[(4, 50)] = 3 DCNL DCSP distribMatrix[(4, 52)] = 4 DCNL DCSP distribMatrix[(4, 54)] = 5 DCNL DCSP distribMatrix[(4, 56)] = 6 DCNL DCSP distribMatrix[(4, 58)] = 7 DCNL DCSP distribMatrix[(4, 60)] = 8 DCNL DCSP distribMatrix[(4, 62)] = 9 DCNL DCSP distribMatrix[(4, 64)] = 10 DCNL DCSP return distribMatrix
 DCSP inputs = [] DCNL DCSP for _ in xrange(numRecords): DCNL DCSP  DCSP input = np.zeros(elemSize, dtype=realDType) DCNL DCSP  DCSP for _ in range(0, numSet): DCNL DCSP  DCSP  DCSP ind = np.random.random_integers(0, (elemSize - 1), 1)[0] DCNL DCSP  DCSP  DCSP input[ind] = 1 DCNL DCSP  DCSP while (abs((input.sum() - numSet)) > 0.1): DCNL DCSP  DCSP  DCSP ind = np.random.random_integers(0, (elemSize - 1), 1)[0] DCNL DCSP  DCSP  DCSP input[ind] = 1 DCNL DCSP  DCSP inputs.append(input) DCNL DCSP return inputs
 DCSP numInputs = len(inputs) DCNL DCSP for i in xrange(numInputs): DCNL DCSP  DCSP input = inputs[i] DCNL DCSP  DCSP for j in xrange((len(input) - 1)): DCNL DCSP  DCSP  DCSP if ((input[j] == 1) and (input[(j + 1)] == 0)): DCNL DCSP  DCSP  DCSP  DCSP newInput = copy.deepcopy(input) DCNL DCSP  DCSP  DCSP  DCSP newInput[j] = 0 DCNL DCSP  DCSP  DCSP  DCSP newInput[(j + 1)] = 1 DCNL DCSP  DCSP  DCSP  DCSP inputs.append(newInput) DCNL DCSP  DCSP  DCSP  DCSP break
 DCSP numInputs = len(inputs) DCNL DCSP skipOne = False DCNL DCSP for i in xrange(numInputs): DCNL DCSP  DCSP input = inputs[i] DCNL DCSP  DCSP numChanged = 0 DCNL DCSP  DCSP newInput = copy.deepcopy(input) DCNL DCSP  DCSP for j in xrange((len(input) - 1)): DCNL DCSP  DCSP  DCSP if skipOne: DCNL DCSP  DCSP  DCSP  DCSP skipOne = False DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if ((input[j] == 1) and (input[(j + 1)] == 0)): DCNL DCSP  DCSP  DCSP  DCSP newInput[j] = 0 DCNL DCSP  DCSP  DCSP  DCSP newInput[(j + 1)] = 1 DCNL DCSP  DCSP  DCSP  DCSP inputs.append(newInput) DCNL DCSP  DCSP  DCSP  DCSP newInput = copy.deepcopy(newInput) DCNL DCSP  DCSP  DCSP  DCSP numChanged += 1 DCNL DCSP  DCSP  DCSP  DCSP skipOne = True DCNL DCSP  DCSP  DCSP  DCSP if (numChanged == numNear): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break
 DCSP changes = np.random.random_integers(0, maxChanges, 1)[0] DCNL DCSP if (changes == 0): DCNL DCSP  DCSP return inputVal DCNL DCSP inputWidth = len(inputVal) DCNL DCSP whatToChange = np.random.random_integers(0, 41, changes) DCNL DCSP runningIndex = (-1) DCNL DCSP numModsDone = 0 DCNL DCSP for i in xrange(inputWidth): DCNL DCSP  DCSP if (numModsDone >= changes): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (inputVal[i] == 1): DCNL DCSP  DCSP  DCSP runningIndex += 1 DCNL DCSP  DCSP  DCSP if (runningIndex in whatToChange): DCNL DCSP  DCSP  DCSP  DCSP if ((i != 0) and (inputVal[(i - 1)] == 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP inputVal[(i - 1)] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP inputVal[i] = 0 DCNL DCSP return inputVal
 DCSP size = len(inputSpace) DCNL DCSP ind = np.random.random_integers(0, (size - 1), 1)[0] DCNL DCSP value = copy.deepcopy(inputSpace[ind]) DCNL DCSP if (maxChanges == 0): DCNL DCSP  DCSP return value DCNL DCSP return modifyBits(value, maxChanges)
 DCSP elemSize = 400 DCNL DCSP numSet = 42 DCNL DCSP addNear = True DCNL DCSP numRecords = 2 DCNL DCSP wantPlot = True DCNL DCSP poolPct = 0.5 DCNL DCSP itr = 1 DCNL DCSP doLearn = True DCNL DCSP while (numRecords < 3): DCNL DCSP  DCSP sp = SpatialPooler(columnDimensions=(2048, 1), inputDimensions=(1, elemSize), potentialRadius=(elemSize / 2), numActiveColumnsPerInhArea=40, spVerbosity=0, stimulusThreshold=0, seed=1, potentialPct=poolPct, globalInhibition=True) DCNL DCSP  DCSP inputs = generateRandomInput(numRecords, elemSize, numSet) DCNL DCSP  DCSP if addNear: DCNL DCSP  DCSP  DCSP appendInputWithNSimilarValues(inputs, 42) DCNL DCSP  DCSP inputSize = len(inputs) DCNL DCSP  DCSP print ('Num DCSP random DCSP records DCSP = DCSP %d, DCSP inputs DCSP to DCSP process DCSP %d' % (numRecords, inputSize)) DCNL DCSP  DCSP outputs = np.zeros((inputSize, 2048)) DCNL DCSP  DCSP numIter = 1 DCNL DCSP  DCSP if doLearn: DCNL DCSP  DCSP  DCSP numIter = itr DCNL DCSP  DCSP for iter in xrange(numIter): DCNL DCSP  DCSP  DCSP for i in xrange(inputSize): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(0.001) DCNL DCSP  DCSP  DCSP  DCSP if (iter == (numIter - 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sp.compute(inputs[i], learn=doLearn, activeArray=outputs[i]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP output = np.zeros(2048) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sp.compute(inputs[i], learn=doLearn, activeArray=output) DCNL DCSP  DCSP distribMatrix = generatePlot(outputs, inputs) DCNL DCSP  DCSP if wantPlot: DCNL DCSP  DCSP  DCSP plt.imshow(distribMatrix, origin='lower', interpolation='nearest') DCNL DCSP  DCSP  DCSP plt.ylabel('SP DCSP (2048/40) DCSP distance DCSP in DCSP %') DCNL DCSP  DCSP  DCSP plt.xlabel('Input DCSP (400/42) DCSP distance DCSP in DCSP %') DCNL DCSP  DCSP  DCSP title = 'SP DCSP distribution' DCNL DCSP  DCSP  DCSP if doLearn: DCNL DCSP  DCSP  DCSP  DCSP title += ', DCSP leaning DCSP ON' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP title += ', DCSP learning DCSP OFF' DCNL DCSP  DCSP  DCSP title += (', DCSP inputs DCSP = DCSP %d' % len(inputs)) DCNL DCSP  DCSP  DCSP title += (', DCSP iterations DCSP = DCSP %d' % numIter) DCNL DCSP  DCSP  DCSP title += (', DCSP poolPct DCSP =%f' % poolPct) DCNL DCSP  DCSP  DCSP plt.suptitle(title, fontsize=12) DCNL DCSP  DCSP  DCSP plt.show() DCNL DCSP  DCSP numRecords += 1 DCNL DCSP return
 DCSP elemSize = 400 DCNL DCSP numSet = 42 DCNL DCSP addNear = True DCNL DCSP numRecords = 1000 DCNL DCSP wantPlot = False DCNL DCSP poolPct = 0.5 DCNL DCSP itr = 5 DCNL DCSP pattern = [60, 1000] DCNL DCSP doLearn = True DCNL DCSP start = 1 DCNL DCSP learnIter = 0 DCNL DCSP noLearnIter = 0 DCNL DCSP numLearns = 0 DCNL DCSP numTests = 0 DCNL DCSP numIter = 1 DCNL DCSP numGroups = 1000 DCNL DCSP PLOT_PRECISION = 100.0 DCNL DCSP distribMatrix = np.zeros(((PLOT_PRECISION + 1), (PLOT_PRECISION + 1))) DCNL DCSP inputs = generateRandomInput(numGroups, elemSize, numSet) DCNL DCSP sp = SpatialPooler(columnDimensions=(2048, 1), inputDimensions=(1, elemSize), potentialRadius=(elemSize / 2), numActiveColumnsPerInhArea=40, spVerbosity=0, stimulusThreshold=0, synPermConnected=0.12, seed=1, potentialPct=poolPct, globalInhibition=True) DCNL DCSP cleanPlot = False DCNL DCSP for i in xrange(numRecords): DCNL DCSP  DCSP input1 = getRandomWithMods(inputs, 4) DCNL DCSP  DCSP if ((i % 2) == 0): DCNL DCSP  DCSP  DCSP input2 = getRandomWithMods(inputs, 4) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP input2 = input1.copy() DCNL DCSP  DCSP  DCSP input2 = modifyBits(input2, 21) DCNL DCSP  DCSP inDist = (abs((input1 - input2)) > 0.1) DCNL DCSP  DCSP intInDist = int(((inDist.sum() / 2) + 0.1)) DCNL DCSP  DCSP if (start == 0): DCNL DCSP  DCSP  DCSP doLearn = True DCNL DCSP  DCSP  DCSP learnIter += 1 DCNL DCSP  DCSP  DCSP if (learnIter == pattern[start]): DCNL DCSP  DCSP  DCSP  DCSP numLearns += 1 DCNL DCSP  DCSP  DCSP  DCSP start = 1 DCNL DCSP  DCSP  DCSP  DCSP noLearnIter = 0 DCNL DCSP  DCSP elif (start == 1): DCNL DCSP  DCSP  DCSP doLearn = False DCNL DCSP  DCSP  DCSP noLearnIter += 1 DCNL DCSP  DCSP  DCSP if (noLearnIter == pattern[start]): DCNL DCSP  DCSP  DCSP  DCSP numTests += 1 DCNL DCSP  DCSP  DCSP  DCSP start = 0 DCNL DCSP  DCSP  DCSP  DCSP learnIter = 0 DCNL DCSP  DCSP  DCSP  DCSP cleanPlot = True DCNL DCSP  DCSP sp.compute(input1, learn=doLearn, activeArray=output1) DCNL DCSP  DCSP sp.compute(input2, learn=doLearn, activeArray=output2) DCNL DCSP  DCSP time.sleep(0.001) DCNL DCSP  DCSP outDist = (abs((output1 - output2)) > 0.1) DCNL DCSP  DCSP intOutDist = int(((outDist.sum() / 2) + 0.1)) DCNL DCSP  DCSP if ((not doLearn) and (intOutDist < 2) and (intInDist > 10)): DCNL DCSP  DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sp.spVerbosity DCSP = DCSP 10\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP TODO: DCSP See DCSP https://github.com/numenta/nupic/issues/2072\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sp.compute(input1, DCSP learn=doLearn, DCSP activeArray=output1)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sp.compute(input2, DCSP learn=doLearn, DCSP activeArray=output2)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sp.spVerbosity DCSP = DCSP 0\n\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCSP 'Elements DCSP has DCSP very DCSP small DCSP SP DCSP distance: DCSP %d' DCSP % DCSP intOutDist\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCSP output1.nonzero()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCSP output2.nonzero()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCSP sp._firingBoostFactors[output1.nonzero()[0]]\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCSP sp._synPermBoostFactors[output1.nonzero()[0]]\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCSP 'Input DCSP elements DCSP distance DCSP is DCSP %d' DCSP % DCSP intInDist\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCSP input1.nonzero()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCSP input2.nonzero()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.stdin.readline()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP if (not doLearn): DCNL DCSP  DCSP  DCSP x = int(((PLOT_PRECISION * intOutDist) / 40.0)) DCNL DCSP  DCSP  DCSP y = int(((PLOT_PRECISION * intInDist) / 42.0)) DCNL DCSP  DCSP  DCSP if (distribMatrix[(x, y)] < 0.1): DCNL DCSP  DCSP  DCSP  DCSP distribMatrix[(x, y)] = 3 DCNL DCSP  DCSP  DCSP elif (distribMatrix[(x, y)] < 10): DCNL DCSP  DCSP  DCSP  DCSP distribMatrix[(x, y)] += 1 DCNL DCSP  DCSP if (wantPlot and cleanPlot): DCNL DCSP  DCSP  DCSP plt.imshow(distribMatrix, origin='lower', interpolation='nearest') DCNL DCSP  DCSP  DCSP plt.ylabel('SP DCSP (2048/40) DCSP distance DCSP in DCSP %') DCNL DCSP  DCSP  DCSP plt.xlabel('Input DCSP (400/42) DCSP distance DCSP in DCSP %') DCNL DCSP  DCSP  DCSP title = 'SP DCSP distribution' DCNL DCSP  DCSP  DCSP title += (', DCSP learn DCSP sets DCSP = DCSP %d' % numLearns) DCNL DCSP  DCSP  DCSP title += (', DCSP test DCSP sets DCSP = DCSP %d' % numTests) DCNL DCSP  DCSP  DCSP title += (', DCSP iter DCSP = DCSP %d' % numIter) DCNL DCSP  DCSP  DCSP title += (', DCSP groups DCSP = DCSP %d' % numGroups) DCNL DCSP  DCSP  DCSP title += (', DCSP Pct DCSP =%f' % poolPct) DCNL DCSP  DCSP  DCSP plt.suptitle(title, fontsize=12) DCNL DCSP  DCSP  DCSP plt.savefig(os.path.join('~/Desktop/ExperimentResults/videosNew', ('%s' % i))) DCNL DCSP  DCSP  DCSP plt.clf() DCNL DCSP  DCSP  DCSP distribMatrix = np.zeros(((PLOT_PRECISION + 1), (PLOT_PRECISION + 1))) DCNL DCSP  DCSP  DCSP cleanPlot = False
 DCSP spSize = 2048 DCNL DCSP spSet = 40 DCNL DCSP poolPct = 0.5 DCNL DCSP pattern = [50, 1000] DCNL DCSP doLearn = True DCNL DCSP PLOT_PRECISION = 100.0 DCNL DCSP distribMatrix = np.zeros(((PLOT_PRECISION + 1), (PLOT_PRECISION + 1))) DCNL DCSP inputs = [] DCNL DCSP outdir = '~/Desktop/ExperimentResults/Basil100x21' DCNL DCSP inputFile = (outdir + '.csv') DCNL DCSP file = open(inputFile, 'rb') DCNL DCSP elemSize = 100 DCNL DCSP numSet = 21 DCNL DCSP reader = csv.reader(file) DCNL DCSP for row in reader: DCNL DCSP  DCSP input = np.array(map(float, row), dtype=realDType) DCNL DCSP  DCSP if (len(input.nonzero()[0]) != numSet): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP inputs.append(input.copy()) DCNL DCSP file.close() DCNL DCSP sp = SpatialPooler(columnDimensions=(spSize, 1), inputDimensions=(1, elemSize), potentialRadius=(elemSize / 2), numActiveColumnsPerInhArea=spSet, spVerbosity=0, stimulusThreshold=0, synPermConnected=0.1, seed=1, potentialPct=poolPct, globalInhibition=True) DCNL DCSP cleanPlot = False DCNL DCSP doLearn = False DCNL DCSP print 'Finished DCSP reading DCSP file, DCSP inputs/outputs DCSP to DCSP process DCSP =', len(inputs) DCNL DCSP size = len(inputs) DCNL DCSP for iter in xrange(100): DCNL DCSP  DCSP print 'Iteration', iter DCNL DCSP  DCSP if (iter != 0): DCNL DCSP  DCSP  DCSP for learnRecs in xrange(pattern[0]): DCNL DCSP  DCSP  DCSP  DCSP ind = np.random.random_integers(0, (size - 1), 1)[0] DCNL DCSP  DCSP  DCSP  DCSP sp.compute(inputs[ind], learn=True, activeArray=outputs[ind]) DCNL DCSP  DCSP for _ in xrange(pattern[1]): DCNL DCSP  DCSP  DCSP rand1 = np.random.random_integers(0, (size - 1), 1)[0] DCNL DCSP  DCSP  DCSP rand2 = np.random.random_integers(0, (size - 1), 1)[0] DCNL DCSP  DCSP  DCSP sp.compute(inputs[rand1], learn=False, activeArray=output1) DCNL DCSP  DCSP  DCSP sp.compute(inputs[rand2], learn=False, activeArray=output2) DCNL DCSP  DCSP  DCSP outDist = (abs((output1 - output2)) > 0.1) DCNL DCSP  DCSP  DCSP intOutDist = int(((outDist.sum() / 2) + 0.1)) DCNL DCSP  DCSP  DCSP inDist = (abs((inputs[rand1] - inputs[rand2])) > 0.1) DCNL DCSP  DCSP  DCSP intInDist = int(((inDist.sum() / 2) + 0.1)) DCNL DCSP  DCSP  DCSP if ((intInDist != numSet) or (intOutDist != spSet)): DCNL DCSP  DCSP  DCSP  DCSP print rand1, rand2, '-', intInDist, intOutDist DCNL DCSP  DCSP  DCSP x = int(((PLOT_PRECISION * intOutDist) / spSet)) DCNL DCSP  DCSP  DCSP y = int(((PLOT_PRECISION * intInDist) / numSet)) DCNL DCSP  DCSP  DCSP if (distribMatrix[(x, y)] < 0.1): DCNL DCSP  DCSP  DCSP  DCSP distribMatrix[(x, y)] = 3 DCNL DCSP  DCSP  DCSP elif (distribMatrix[(x, y)] < 10): DCNL DCSP  DCSP  DCSP  DCSP distribMatrix[(x, y)] += 1 DCNL DCSP  DCSP if True: DCNL DCSP  DCSP  DCSP plt.imshow(distribMatrix, origin='lower', interpolation='nearest') DCNL DCSP  DCSP  DCSP plt.ylabel(('SP DCSP (%d/%d) DCSP distance DCSP in DCSP pct' % (spSize, spSet))) DCNL DCSP  DCSP  DCSP plt.xlabel(('Input DCSP (%d/%d) DCSP distance DCSP in DCSP pct' % (elemSize, numSet))) DCNL DCSP  DCSP  DCSP title = 'SP DCSP distribution' DCNL DCSP  DCSP  DCSP title += (', DCSP iter DCSP = DCSP %d' % iter) DCNL DCSP  DCSP  DCSP title += (', DCSP Pct DCSP =%f' % poolPct) DCNL DCSP  DCSP  DCSP plt.suptitle(title, fontsize=12) DCNL DCSP  DCSP  DCSP plt.savefig(os.path.join(outdir, ('%s' % iter))) DCNL DCSP  DCSP  DCSP plt.clf() DCNL DCSP  DCSP  DCSP distribMatrix = np.zeros(((PLOT_PRECISION + 1), (PLOT_PRECISION + 1)))
 DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fields = [('classification', 'string', ''), ('field1', 'string', '')] DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP sequences = [] DCNL DCSP for i in range(numSequences): DCNL DCSP  DCSP seq = [x for x in range((i * elementsPerSeq), ((i + 1) * elementsPerSeq))] DCNL DCSP  DCSP sequences.append(seq) DCNL DCSP seqIdxs = [] DCNL DCSP for i in range(numRepeats): DCNL DCSP  DCSP seqIdxs += range(numSequences) DCNL DCSP random.shuffle(seqIdxs) DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP outFile.appendRecord([str(seqIdx), str(x)]) DCNL DCSP outFile.close()
 DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fields = [('classification', 'float', ''), ('field1', 'float', '')] DCNL DCSP if includeRandom: DCNL DCSP  DCSP fields += [('randomData', 'float', '')] DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP sequences = [] DCNL DCSP for i in range(numSequences): DCNL DCSP  DCSP seq = [x for x in range((i * elementsPerSeq), ((i + 1) * elementsPerSeq))] DCNL DCSP  DCSP sequences.append(seq) DCNL DCSP random.seed(42) DCNL DCSP seqIdxs = [] DCNL DCSP for i in range(numRepeats): DCNL DCSP  DCSP seqIdxs += range(numSequences) DCNL DCSP random.shuffle(seqIdxs) DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP if includeRandom: DCNL DCSP  DCSP  DCSP  DCSP outFile.appendRecord([seqIdx, (x * stepSize), random.random()]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP outFile.appendRecord([seqIdx, (x * stepSize)]) DCNL DCSP outFile.close()
 DCSP dataPath = os.path.abspath(os.path.join(rootDir, 'datasets', 'scalar_1.csv')) DCNL DCSP streamDef = dict(version=1, info='testSpatialClassification', streams=[dict(source=('file://%s' % dataPath), info='scalar_1.csv', columns=['*'])]) DCNL DCSP expDesc = {'environment': 'nupic', 'inferenceArgs': {'predictedField': 'classification', 'predictionSteps': [0]}, 'inferenceType': 'MultiStep', 'streamDef': streamDef, 'includedFields': [{'fieldName': 'field1', 'fieldType': 'float'}, {'fieldName': 'classification', 'fieldType': 'string'}, {'fieldName': 'randomData', 'fieldType': 'float'}], 'iterationCount': (-1)} DCNL DCSP return expDesc
 DCSP newn = int((((1.0 * len(l)) / n) + 0.5)) DCNL DCSP for i in xrange(0, (n - 1)): DCNL DCSP  DCSP (yield l[(i * newn):((i * newn) + newn)]) DCNL DCSP (yield l[((n * newn) - newn):])
 DCSP values = np.zeros(N, dtype=np.int) DCNL DCSP samples = np.arange(len(px)) DCNL DCSP px = (np.array(px) / (1.0 * sum(px))) DCNL DCSP u = uniform(0, max(px)) DCNL DCSP for n in xrange(N): DCNL DCSP  DCSP included = (px >= u) DCNL DCSP  DCSP choice = random.sample(range(np.sum(included)), 1)[0] DCNL DCSP  DCSP values[n] = samples[included][choice] DCNL DCSP  DCSP u = uniform(0, px[included][choice]) DCNL DCSP if x: DCNL DCSP  DCSP if (len(x) == len(px)): DCNL DCSP  DCSP  DCSP x = np.array(x) DCNL DCSP  DCSP  DCSP values = x[values] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print 'px DCSP and DCSP x DCSP are DCSP different DCSP lengths. DCSP Returning DCSP index DCSP locations DCSP for DCSP px.' DCNL DCSP return values
 DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fields = [('reset', 'int', 'R'), ('category', 'int', 'C'), ('field1', 'string', '')] DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP sequences = [] DCNL DCSP for i in range(numSequences): DCNL DCSP  DCSP seq = [x for x in range((i * elementsPerSeq), ((i + 1) * elementsPerSeq))] DCNL DCSP  DCSP sequences.append(seq) DCNL DCSP seqIdxs = [] DCNL DCSP for i in range(numRepeats): DCNL DCSP  DCSP seqIdxs += range(numSequences) DCNL DCSP random.shuffle(seqIdxs) DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP reset = int(resets) DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP outFile.appendRecord([reset, str(seqIdx), str(x)]) DCNL DCSP  DCSP  DCSP reset = 0 DCNL DCSP outFile.close()
 DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fields = [('reset', 'int', 'R'), ('category', 'int', 'C'), ('field1', 'float', '')] DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP sequences = [] DCNL DCSP for i in range(numSequences): DCNL DCSP  DCSP seq = [x for x in range((i * elementsPerSeq), ((i + 1) * elementsPerSeq))] DCNL DCSP  DCSP sequences.append(seq) DCNL DCSP seqIdxs = [] DCNL DCSP for i in range(numRepeats): DCNL DCSP  DCSP seqIdxs += range(numSequences) DCNL DCSP random.shuffle(seqIdxs) DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP reset = int(resets) DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP outFile.appendRecord([reset, str(seqIdx), (x * stepSize)]) DCNL DCSP  DCSP  DCSP reset = 0 DCNL DCSP outFile.close()
 DCSP assert ((hubOffset + len(hub)) <= elementsPerSeq) DCNL DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fields = [('reset', 'int', 'R'), ('category', 'int', 'C'), ('field1', 'string', '')] DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP sequences = [] DCNL DCSP nextElemIdx = (max(hub) + 1) DCNL DCSP for _ in range(numSequences): DCNL DCSP  DCSP seq = [] DCNL DCSP  DCSP for j in range(hubOffset): DCNL DCSP  DCSP  DCSP seq.append(nextElemIdx) DCNL DCSP  DCSP  DCSP nextElemIdx += 1 DCNL DCSP  DCSP for j in hub: DCNL DCSP  DCSP  DCSP seq.append(j) DCNL DCSP  DCSP j = (hubOffset + len(hub)) DCNL DCSP  DCSP while (j < elementsPerSeq): DCNL DCSP  DCSP  DCSP seq.append(nextElemIdx) DCNL DCSP  DCSP  DCSP nextElemIdx += 1 DCNL DCSP  DCSP  DCSP j += 1 DCNL DCSP  DCSP sequences.append(seq) DCNL DCSP seqIdxs = [] DCNL DCSP for _ in range(numRepeats): DCNL DCSP  DCSP seqIdxs += range(numSequences) DCNL DCSP random.shuffle(seqIdxs) DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP reset = int(resets) DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP outFile.appendRecord([reset, str(seqIdx), str(x)]) DCNL DCSP  DCSP  DCSP reset = 0 DCNL DCSP outFile.close()
 DCSP return True
 DCSP return True
 DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fields = [('reset', 'int', 'R'), ('field1', 'string', ''), ('field2', 'float', '')] DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP sequences = [] DCNL DCSP for i in range(numSequences): DCNL DCSP  DCSP seq = [x for x in range((i * elementsPerSeq), ((i + 1) * elementsPerSeq))] DCNL DCSP  DCSP sequences.append(seq) DCNL DCSP seqIdxs = [] DCNL DCSP for i in range(numRepeats): DCNL DCSP  DCSP seqIdxs += range(numSequences) DCNL DCSP random.shuffle(seqIdxs) DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP reset = int(resets) DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP outFile.appendRecord([reset, str(x), x]) DCNL DCSP  DCSP  DCSP reset = 0 DCNL DCSP outFile.close()
 DCSP assert ((hubOffset + len(hub)) <= elementsPerSeq) DCNL DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fields = [('reset', 'int', 'R'), ('field1', 'string', ''), ('field2', 'float', '')] DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP sequences = [] DCNL DCSP nextElemIdx = (max(hub) + 1) DCNL DCSP for _ in range(numSequences): DCNL DCSP  DCSP seq = [] DCNL DCSP  DCSP for j in range(hubOffset): DCNL DCSP  DCSP  DCSP seq.append(nextElemIdx) DCNL DCSP  DCSP  DCSP nextElemIdx += 1 DCNL DCSP  DCSP for j in hub: DCNL DCSP  DCSP  DCSP seq.append(j) DCNL DCSP  DCSP j = (hubOffset + len(hub)) DCNL DCSP  DCSP while (j < elementsPerSeq): DCNL DCSP  DCSP  DCSP seq.append(nextElemIdx) DCNL DCSP  DCSP  DCSP nextElemIdx += 1 DCNL DCSP  DCSP  DCSP j += 1 DCNL DCSP  DCSP sequences.append(seq) DCNL DCSP seqIdxs = [] DCNL DCSP for _ in range(numRepeats): DCNL DCSP  DCSP seqIdxs += range(numSequences) DCNL DCSP random.shuffle(seqIdxs) DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP reset = int(resets) DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP outFile.appendRecord([reset, str(x), x]) DCNL DCSP  DCSP  DCSP reset = 0 DCNL DCSP outFile.close()
 DCSP numCategories = 5 DCNL DCSP initProb = numpy.zeros(numCategories) DCNL DCSP initProb[0] = 1.0 DCNL DCSP firstOrder = dict() DCNL DCSP firstOrder['0'] = numpy.array([0, 0.1, 0, 0, 0.9]) DCNL DCSP firstOrder['1'] = numpy.array([0, 0, 0.75, 0.25, 0]) DCNL DCSP firstOrder['2'] = numpy.array([1.0, 0, 0, 0, 0]) DCNL DCSP firstOrder['3'] = numpy.array([1.0, 0, 0, 0, 0]) DCNL DCSP firstOrder['4'] = numpy.array([0, 0, 0.5, 0.5, 0]) DCNL DCSP secondOrder = None DCNL DCSP categoryList = [('%d' % x) for x in range(5)] DCNL DCSP return (initProb, firstOrder, secondOrder, 3, categoryList)
 DCSP print ('Creating DCSP %s...' % filename) DCNL DCSP fields = [('reset', 'int', 'R'), ('field1', 'string', ''), ('field2', 'float', '')] DCNL DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP initCumProb = initProb.cumsum() DCNL DCSP firstOrderCumProb = dict() DCNL DCSP for (key, value) in firstOrderProb.iteritems(): DCNL DCSP  DCSP firstOrderCumProb[key] = value.cumsum() DCNL DCSP if (secondOrderProb is not None): DCNL DCSP  DCSP secondOrderCumProb = dict() DCNL DCSP  DCSP for (key, value) in secondOrderProb.iteritems(): DCNL DCSP  DCSP  DCSP secondOrderCumProb[key] = value.cumsum() DCNL DCSP else: DCNL DCSP  DCSP secondOrderCumProb = None DCNL DCSP elementsInSeq = [] DCNL DCSP numElementsSinceReset = 0 DCNL DCSP maxCatIdx = (len(categoryList) - 1) DCNL DCSP for _ in xrange(numRecords): DCNL DCSP  DCSP if (numElementsSinceReset == 0): DCNL DCSP  DCSP  DCSP reset = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP reset = 0 DCNL DCSP  DCSP rand = numpy.random.rand() DCNL DCSP  DCSP if (secondOrderCumProb is None): DCNL DCSP  DCSP  DCSP if (len(elementsInSeq) == 0): DCNL DCSP  DCSP  DCSP  DCSP catIdx = numpy.searchsorted(initCumProb, rand) DCNL DCSP  DCSP  DCSP elif ((len(elementsInSeq) >= 1) and ((seqLen is None) or (len(elementsInSeq) < (seqLen - numNoise)))): DCNL DCSP  DCSP  DCSP  DCSP catIdx = numpy.searchsorted(firstOrderCumProb[str(elementsInSeq[(-1)])], rand) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP catIdx = numpy.random.randint(len(categoryList)) DCNL DCSP  DCSP elif (len(elementsInSeq) == 0): DCNL DCSP  DCSP  DCSP catIdx = numpy.searchsorted(initCumProb, rand) DCNL DCSP  DCSP elif (len(elementsInSeq) == 1): DCNL DCSP  DCSP  DCSP catIdx = numpy.searchsorted(firstOrderCumProb[str(elementsInSeq)], rand) DCNL DCSP  DCSP elif ((len(elementsInSeq) >= 2) and ((seqLen is None) or (len(elementsInSeq) < (seqLen - numNoise)))): DCNL DCSP  DCSP  DCSP catIdx = numpy.searchsorted(secondOrderCumProb[str(elementsInSeq[(-2):])], rand) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP catIdx = numpy.random.randint(len(categoryList)) DCNL DCSP  DCSP catIdx = min(maxCatIdx, catIdx) DCNL DCSP  DCSP outFile.appendRecord([reset, categoryList[catIdx], catIdx]) DCNL DCSP  DCSP elementsInSeq.append(catIdx) DCNL DCSP  DCSP numElementsSinceReset += 1 DCNL DCSP  DCSP if ((resetsEvery is not None) and (numElementsSinceReset == resetsEvery)): DCNL DCSP  DCSP  DCSP numElementsSinceReset = 0 DCNL DCSP  DCSP  DCSP elementsInSeq = [] DCNL DCSP  DCSP if ((seqLen is not None) and (len(elementsInSeq) == (seqLen + numNoise))): DCNL DCSP  DCSP  DCSP elementsInSeq = [] DCNL DCSP outFile.close()
 DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fields = [('timestamp', 'datetime', 'T'), ('field1', 'string', ''), ('field2', 'float', '')] DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP sequences = [] DCNL DCSP for i in range(numSequences): DCNL DCSP  DCSP seq = [x for x in range((i * elementsPerSeq), ((i + 1) * elementsPerSeq))] DCNL DCSP  DCSP sequences.append(seq) DCNL DCSP seqIdxs = [] DCNL DCSP for i in range(numRepeats): DCNL DCSP  DCSP seqIdxs += range(numSequences) DCNL DCSP random.shuffle(seqIdxs) DCNL DCSP timestamp = datetime.datetime(year=2012, month=1, day=1, hour=0, minute=0, second=0) DCNL DCSP timeDelta = datetime.timedelta(hours=1) DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP outFile.appendRecord([timestamp, str(x), x]) DCNL DCSP  DCSP  DCSP timestamp += timeDelta DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for (i, x) in enumerate(seq): DCNL DCSP  DCSP  DCSP if (i != 1): DCNL DCSP  DCSP  DCSP  DCSP outFile.appendRecord([timestamp, str(x), x]) DCNL DCSP  DCSP  DCSP timestamp += timeDelta DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for (i, x) in enumerate(seq): DCNL DCSP  DCSP  DCSP if (i != 1): DCNL DCSP  DCSP  DCSP  DCSP outFile.appendRecord([timestamp, str(x), x]) DCNL DCSP  DCSP  DCSP timestamp += timeDelta DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP outFile.appendRecord([timestamp, str(x), x]) DCNL DCSP  DCSP  DCSP timestamp += timeDelta DCNL DCSP outFile.close()
 DCSP model = ModelFactory.create(model_params.MODEL_PARAMS) DCNL DCSP model.enableInference({'predictedField': 'cpu'}) DCNL DCSP shifter = InferenceShifter() DCNL DCSP actHistory = deque(([0.0] * WINDOW), maxlen=60) DCNL DCSP predHistory = deque(([0.0] * WINDOW), maxlen=60) DCNL DCSP (actline,) = plt.plot(range(WINDOW), actHistory) DCNL DCSP (predline,) = plt.plot(range(WINDOW), predHistory) DCNL DCSP actline.axes.set_ylim(0, 100) DCNL DCSP predline.axes.set_ylim(0, 100) DCNL DCSP while True: DCNL DCSP  DCSP s = time.time() DCNL DCSP  DCSP cpu = psutil.cpu_percent() DCNL DCSP  DCSP modelInput = {'cpu': cpu} DCNL DCSP  DCSP result = shifter.shift(model.run(modelInput)) DCNL DCSP  DCSP inference = result.inferences['multiStepBestPredictions'][5] DCNL DCSP  DCSP if (inference is not None): DCNL DCSP  DCSP  DCSP actHistory.append(result.rawInput['cpu']) DCNL DCSP  DCSP  DCSP predHistory.append(inference) DCNL DCSP  DCSP actline.set_ydata(actHistory) DCNL DCSP  DCSP predline.set_ydata(predHistory) DCNL DCSP  DCSP plt.draw() DCNL DCSP  DCSP plt.legend(('actual', 'predicted')) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP plt.pause(SECONDS_PER_STEP) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass
 DCSP model = ModelFactory.create(modelParams) DCNL DCSP model.enableInference({'predictedField': 'kw_energy_consumption'}) DCNL DCSP return model
 DCSP importName = ('model_params.%s_model_params' % gymName.replace(' DCSP ', '_').replace('-', '_')) DCNL DCSP print ('Importing DCSP model DCSP params DCSP from DCSP %s' % importName) DCNL DCSP try: DCNL DCSP  DCSP importedModelParams = importlib.import_module(importName).MODEL_PARAMS DCNL DCSP except ImportError: DCNL DCSP  DCSP raise Exception(("No DCSP model DCSP params DCSP exist DCSP for DCSP '%s'. DCSP Run DCSP swarm DCSP first!" % gymName)) DCNL DCSP return importedModelParams
 DCSP inputFile = open(inputData, 'rb') DCNL DCSP csvReader = csv.reader(inputFile) DCNL DCSP csvReader.next() DCNL DCSP csvReader.next() DCNL DCSP csvReader.next() DCNL DCSP shifter = InferenceShifter() DCNL DCSP if plot: DCNL DCSP  DCSP output = nupic_anomaly_output.NuPICPlotOutput(gymName) DCNL DCSP else: DCNL DCSP  DCSP output = nupic_anomaly_output.NuPICFileOutput(gymName) DCNL DCSP counter = 0 DCNL DCSP for row in csvReader: DCNL DCSP  DCSP counter += 1 DCNL DCSP  DCSP if ((counter % 100) == 0): DCNL DCSP  DCSP  DCSP print ('Read DCSP %i DCSP lines...' % counter) DCNL DCSP  DCSP timestamp = datetime.datetime.strptime(row[0], DATE_FORMAT) DCNL DCSP  DCSP consumption = float(row[1]) DCNL DCSP  DCSP result = model.run({'timestamp': timestamp, 'kw_energy_consumption': consumption}) DCNL DCSP  DCSP if plot: DCNL DCSP  DCSP  DCSP result = shifter.shift(result) DCNL DCSP  DCSP prediction = result.inferences['multiStepBestPredictions'][1] DCNL DCSP  DCSP anomalyScore = result.inferences['anomalyScore'] DCNL DCSP  DCSP output.write(timestamp, consumption, prediction, anomalyScore) DCNL DCSP inputFile.close() DCNL DCSP output.close()
 DCSP print ('Creating DCSP model DCSP from DCSP %s...' % gymName) DCNL DCSP model = createModel(getModelParamsFromName(gymName)) DCNL DCSP inputData = ('%s/%s.csv' % (DATA_DIR, gymName.replace(' DCSP ', '_'))) DCNL DCSP runIoThroughNupic(inputData, model, gymName, plot)
 DCSP encoder = model_params.MODEL_PARAMS['modelParams']['sensorParams']['encoders']['value'] DCNL DCSP if (encoder['type'] == 'RandomDistributedScalarEncoder'): DCNL DCSP  DCSP rangePadding = (abs((_INPUT_MAX - _INPUT_MIN)) * 0.2) DCNL DCSP  DCSP minValue = (_INPUT_MIN - rangePadding) DCNL DCSP  DCSP maxValue = (_INPUT_MAX + rangePadding) DCNL DCSP  DCSP resolution = max(minResolution, ((maxValue - minValue) / encoder.pop('numBuckets'))) DCNL DCSP  DCSP encoder['resolution'] = resolution
 DCSP nonZeroX1 = np.count_nonzero(x1) DCNL DCSP nonZeroX2 = np.count_nonzero(x2) DCNL DCSP minX1X2 = min(nonZeroX1, nonZeroX2) DCNL DCSP percentOverlap = 0 DCNL DCSP if (minX1X2 > 0): DCNL DCSP  DCSP percentOverlap = (float(np.dot(x1, x2)) / float(minX1X2)) DCNL DCSP return percentOverlap
 DCSP size = len(vector) DCNL DCSP for i in range(size): DCNL DCSP  DCSP rnd = random.random() DCNL DCSP  DCSP if (rnd < noiseLevel): DCNL DCSP  DCSP  DCSP if (vector[i] == 1): DCNL DCSP  DCSP  DCSP  DCSP vector[i] = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP vector[i] = 1
 DCSP size = len(x1) DCNL DCSP for i in range(size): DCNL DCSP  DCSP x2[i] = x1[i]
 DCSP encoder = MultiEncoder() DCNL DCSP encoder.addMultipleEncoders({'consumption': {'fieldname': u'consumption', 'type': 'ScalarEncoder', 'name': u'consumption', 'minval': 0.0, 'maxval': 100.0, 'clipInput': True, 'w': 21, 'n': 500}, 'timestamp_timeOfDay': {'fieldname': u'timestamp', 'type': 'DateEncoder', 'name': u'timestamp_timeOfDay', 'timeOfDay': (21, 9.5)}}) DCNL DCSP return encoder
 DCSP regionType = 'py.RecordSensor' DCNL DCSP regionParams = json.dumps({'verbosity': _VERBOSITY}) DCNL DCSP network.addRegion(name, regionType, regionParams) DCNL DCSP sensorRegion = network.regions[name].getSelf() DCNL DCSP sensorRegion.encoder = createEncoder() DCNL DCSP network.regions[name].setParameter('predictedField', 'consumption') DCNL DCSP sensorRegion.dataSource = dataSource DCNL DCSP return sensorRegion
 DCSP network = Network() DCNL DCSP sensor = createRecordSensor(network, name=_RECORD_SENSOR, dataSource=dataSource) DCNL DCSP createSpatialPooler(network, name=_L1_SPATIAL_POOLER, inputWidth=sensor.encoder.getWidth()) DCNL DCSP linkType = 'UniformLink' DCNL DCSP linkParams = '' DCNL DCSP network.link(_RECORD_SENSOR, _L1_SPATIAL_POOLER, linkType, linkParams) DCNL DCSP l1temporalMemory = createTemporalMemory(network, _L1_TEMPORAL_MEMORY) DCNL DCSP network.link(_L1_SPATIAL_POOLER, _L1_TEMPORAL_MEMORY, linkType, linkParams) DCNL DCSP classifierParams = {'alpha': 0.005, 'steps': '1', 'implementation': 'py', 'verbosity': 0} DCNL DCSP l1Classifier = network.addRegion(_L1_CLASSIFIER, 'py.SDRClassifierRegion', json.dumps(classifierParams)) DCNL DCSP l1Classifier.setParameter('inferenceMode', True) DCNL DCSP l1Classifier.setParameter('learningMode', True) DCNL DCSP network.link(_L1_TEMPORAL_MEMORY, _L1_CLASSIFIER, linkType, linkParams, srcOutput='bottomUpOut', destInput='bottomUpIn') DCNL DCSP network.link(_RECORD_SENSOR, _L1_CLASSIFIER, linkType, linkParams, srcOutput='categoryOut', destInput='categoryIn') DCNL DCSP network.link(_RECORD_SENSOR, _L1_CLASSIFIER, linkType, linkParams, srcOutput='bucketIdxOut', destInput='bucketIdxIn') DCNL DCSP network.link(_RECORD_SENSOR, _L1_CLASSIFIER, linkType, linkParams, srcOutput='actValueOut', destInput='actValueIn') DCNL DCSP l2inputWidth = l1temporalMemory.getSelf().getOutputElementCount('bottomUpOut') DCNL DCSP createSpatialPooler(network, name=_L2_SPATIAL_POOLER, inputWidth=l2inputWidth) DCNL DCSP network.link(_L1_TEMPORAL_MEMORY, _L2_SPATIAL_POOLER, linkType, linkParams) DCNL DCSP createTemporalMemory(network, _L2_TEMPORAL_MEMORY) DCNL DCSP network.link(_L2_SPATIAL_POOLER, _L2_TEMPORAL_MEMORY, linkType, linkParams) DCNL DCSP l2Classifier = network.addRegion(_L2_CLASSIFIER, 'py.SDRClassifierRegion', json.dumps(classifierParams)) DCNL DCSP l2Classifier.setParameter('inferenceMode', True) DCNL DCSP l2Classifier.setParameter('learningMode', True) DCNL DCSP network.link(_L2_TEMPORAL_MEMORY, _L2_CLASSIFIER, linkType, linkParams, srcOutput='bottomUpOut', destInput='bottomUpIn') DCNL DCSP network.link(_RECORD_SENSOR, _L2_CLASSIFIER, linkType, linkParams, srcOutput='categoryOut', destInput='categoryIn') DCNL DCSP network.link(_RECORD_SENSOR, _L2_CLASSIFIER, linkType, linkParams, srcOutput='bucketIdxOut', destInput='bucketIdxIn') DCNL DCSP network.link(_RECORD_SENSOR, _L2_CLASSIFIER, linkType, linkParams, srcOutput='actValueOut', destInput='actValueIn') DCNL DCSP return network
 DCSP sensorRegion = network.regions[_RECORD_SENSOR] DCNL DCSP l1SpRegion = network.regions[_L1_SPATIAL_POOLER] DCNL DCSP l1TpRegion = network.regions[_L1_TEMPORAL_MEMORY] DCNL DCSP l1Classifier = network.regions[_L1_CLASSIFIER] DCNL DCSP l2SpRegion = network.regions[_L2_SPATIAL_POOLER] DCNL DCSP l2TpRegion = network.regions[_L2_TEMPORAL_MEMORY] DCNL DCSP l2Classifier = network.regions[_L2_CLASSIFIER] DCNL DCSP l1PreviousPredictedColumns = [] DCNL DCSP l2PreviousPredictedColumns = [] DCNL DCSP l1PreviousPrediction = None DCNL DCSP l2PreviousPrediction = None DCNL DCSP l1ErrorSum = 0.0 DCNL DCSP l2ErrorSum = 0.0 DCNL DCSP for record in xrange(numRecords): DCNL DCSP  DCSP network.run(1) DCNL DCSP  DCSP actual = float(sensorRegion.getOutputData('actValueOut')[0]) DCNL DCSP  DCSP l1Predictions = l1Classifier.getOutputData('actualValues') DCNL DCSP  DCSP l1Probabilities = l1Classifier.getOutputData('probabilities') DCNL DCSP  DCSP l1Prediction = l1Predictions[l1Probabilities.argmax()] DCNL DCSP  DCSP if (l1PreviousPrediction is not None): DCNL DCSP  DCSP  DCSP l1ErrorSum += math.fabs((l1PreviousPrediction - actual)) DCNL DCSP  DCSP l1PreviousPrediction = l1Prediction DCNL DCSP  DCSP l2Predictions = l2Classifier.getOutputData('actualValues') DCNL DCSP  DCSP l2Probabilities = l2Classifier.getOutputData('probabilities') DCNL DCSP  DCSP l2Prediction = l2Predictions[l2Probabilities.argmax()] DCNL DCSP  DCSP if (l2PreviousPrediction is not None): DCNL DCSP  DCSP  DCSP l2ErrorSum += math.fabs((l2PreviousPrediction - actual)) DCNL DCSP  DCSP l2PreviousPrediction = l2Prediction DCNL DCSP  DCSP l1AnomalyScore = l1TpRegion.getOutputData('anomalyScore')[0] DCNL DCSP  DCSP l2AnomalyScore = l2TpRegion.getOutputData('anomalyScore')[0] DCNL DCSP  DCSP writer.writerow((record, actual, l1PreviousPrediction, l1AnomalyScore, l2PreviousPrediction, l2AnomalyScore)) DCNL DCSP  DCSP l1PredictedColumns = l1TpRegion.getOutputData('topDownOut').nonzero()[0] DCNL DCSP  DCSP l1PreviousPredictedColumns = copy.deepcopy(l1PredictedColumns) DCNL DCSP  DCSP l2PredictedColumns = l2TpRegion.getOutputData('topDownOut').nonzero()[0] DCNL DCSP  DCSP l2PreviousPredictedColumns = copy.deepcopy(l2PredictedColumns) DCNL DCSP if (numRecords > 1): DCNL DCSP  DCSP print ('L1 DCSP ave DCSP abs DCSP class. DCSP error: DCSP %f' % (l1ErrorSum / (numRecords - 1))) DCNL DCSP  DCSP print ('L2 DCSP ave DCSP abs DCSP class. DCSP error: DCSP %f' % (l2ErrorSum / (numRecords - 1)))
 DCSP consumption_encoder = ScalarEncoder(21, 0.0, 100.0, n=50, name='consumption', clipInput=True) DCNL DCSP time_encoder = DateEncoder(timeOfDay=(21, 9.5), name='timestamp_timeOfDay') DCNL DCSP encoder = MultiEncoder() DCNL DCSP encoder.addEncoder('consumption', consumption_encoder) DCNL DCSP encoder.addEncoder('timestamp', time_encoder) DCNL DCSP return encoder
 DCSP network = Network() DCNL DCSP network.addRegion('sensor', 'py.RecordSensor', json.dumps({'verbosity': _VERBOSITY})) DCNL DCSP sensor = network.regions['sensor'].getSelf() DCNL DCSP sensor.encoder = createEncoder() DCNL DCSP sensor.dataSource = dataSource DCNL DCSP sys.path.append(os.path.dirname(os.path.abspath(__file__))) DCNL DCSP from custom_region.identity_region import IdentityRegion DCNL DCSP Network.registerRegion(IdentityRegion) DCNL DCSP network.addRegion('identityRegion', 'py.IdentityRegion', json.dumps({'dataWidth': sensor.encoder.getWidth()})) DCNL DCSP network.link('sensor', 'identityRegion', 'UniformLink', '') DCNL DCSP network.initialize() DCNL DCSP return network
 DCSP identityRegion = network.regions['identityRegion'] DCNL DCSP for i in xrange(_NUM_RECORDS): DCNL DCSP  DCSP network.run(1) DCNL DCSP  DCSP encoding = identityRegion.getOutputData('out') DCNL DCSP  DCSP writer.writerow((i, encoding))
 DCSP consumption_encoder = ScalarEncoder(21, 0.0, 100.0, n=50, name='consumption', clipInput=True) DCNL DCSP time_encoder = DateEncoder(timeOfDay=(21, 9.5), name='timestamp_timeOfDay') DCNL DCSP encoder = MultiEncoder() DCNL DCSP encoder.addEncoder('consumption', consumption_encoder) DCNL DCSP encoder.addEncoder('timestamp', time_encoder) DCNL DCSP return encoder
 DCSP network = Network() DCNL DCSP network.addRegion('sensor', 'py.RecordSensor', json.dumps({'verbosity': _VERBOSITY})) DCNL DCSP sensor = network.regions['sensor'].getSelf() DCNL DCSP sensor.encoder = createEncoder() DCNL DCSP sensor.dataSource = dataSource DCNL DCSP SP_PARAMS['inputWidth'] = sensor.encoder.getWidth() DCNL DCSP network.addRegion('spatialPoolerRegion', 'py.SPRegion', json.dumps(SP_PARAMS)) DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '') DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='resetOut', destInput='resetIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='spatialTopDownOut', destInput='spatialTopDownIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='temporalTopDownOut', destInput='temporalTopDownIn') DCNL DCSP network.addRegion('temporalPoolerRegion', 'py.TMRegion', json.dumps(TM_PARAMS)) DCNL DCSP network.link('spatialPoolerRegion', 'temporalPoolerRegion', 'UniformLink', '') DCNL DCSP network.link('temporalPoolerRegion', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='topDownOut', destInput='topDownIn') DCNL DCSP network.addRegion('anomalyLikelihoodRegion', 'py.AnomalyLikelihoodRegion', json.dumps({})) DCNL DCSP network.link('temporalPoolerRegion', 'anomalyLikelihoodRegion', 'UniformLink', '', srcOutput='anomalyScore', destInput='rawAnomalyScore') DCNL DCSP network.link('sensor', 'anomalyLikelihoodRegion', 'UniformLink', '', srcOutput='sourceOut', destInput='metricValue') DCNL DCSP spatialPoolerRegion = network.regions['spatialPoolerRegion'] DCNL DCSP spatialPoolerRegion.setParameter('learningMode', True) DCNL DCSP spatialPoolerRegion.setParameter('anomalyMode', False) DCNL DCSP temporalPoolerRegion = network.regions['temporalPoolerRegion'] DCNL DCSP temporalPoolerRegion.setParameter('topDownMode', True) DCNL DCSP temporalPoolerRegion.setParameter('learningMode', True) DCNL DCSP temporalPoolerRegion.setParameter('inferenceMode', True) DCNL DCSP temporalPoolerRegion.setParameter('anomalyMode', True) DCNL DCSP return network
 DCSP sensorRegion = network.regions['sensor'] DCNL DCSP spatialPoolerRegion = network.regions['spatialPoolerRegion'] DCNL DCSP temporalPoolerRegion = network.regions['temporalPoolerRegion'] DCNL DCSP anomalyLikelihoodRegion = network.regions['anomalyLikelihoodRegion'] DCNL DCSP prevPredictedColumns = [] DCNL DCSP for i in xrange(_NUM_RECORDS): DCNL DCSP  DCSP network.run(1) DCNL DCSP  DCSP consumption = sensorRegion.getOutputData('sourceOut')[0] DCNL DCSP  DCSP anomalyScore = temporalPoolerRegion.getOutputData('anomalyScore')[0] DCNL DCSP  DCSP anomalyLikelihood = anomalyLikelihoodRegion.getOutputData('anomalyLikelihood')[0] DCNL DCSP  DCSP writer.writerow((i, consumption, anomalyScore, anomalyLikelihood))
 DCSP inputFilePath = recordParams['inputFilePath'] DCNL DCSP scalarEncoderArgs = recordParams['scalarEncoderArgs'] DCNL DCSP dateEncoderArgs = recordParams['dateEncoderArgs'] DCNL DCSP scalarEncoder = ScalarEncoder(**scalarEncoderArgs) DCNL DCSP dateEncoder = DateEncoder(**dateEncoderArgs) DCNL DCSP encoder = MultiEncoder() DCNL DCSP encoder.addEncoder(scalarEncoderArgs['name'], scalarEncoder) DCNL DCSP encoder.addEncoder(dateEncoderArgs['name'], dateEncoder) DCNL DCSP network = Network() DCNL DCSP network.addRegion('sensor', 'py.RecordSensor', json.dumps({'verbosity': verbosity})) DCNL DCSP sensor = network.regions['sensor'].getSelf() DCNL DCSP sensor.encoder = encoder DCNL DCSP sensor.dataSource = FileRecordStream(streamID=inputFilePath) DCNL DCSP spatialParams['inputWidth'] = sensor.encoder.getWidth() DCNL DCSP network.addRegion('spatialPoolerRegion', 'py.SPRegion', json.dumps(spatialParams)) DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '') DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='resetOut', destInput='resetIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='spatialTopDownOut', destInput='spatialTopDownIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='temporalTopDownOut', destInput='temporalTopDownIn') DCNL DCSP network.addRegion('temporalPoolerRegion', 'py.TMRegion', json.dumps(temporalParams)) DCNL DCSP network.link('spatialPoolerRegion', 'temporalPoolerRegion', 'UniformLink', '') DCNL DCSP network.link('temporalPoolerRegion', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='topDownOut', destInput='topDownIn') DCNL DCSP spatialPoolerRegion = network.regions['spatialPoolerRegion'] DCNL DCSP spatialPoolerRegion.setParameter('learningMode', True) DCNL DCSP spatialPoolerRegion.setParameter('anomalyMode', False) DCNL DCSP temporalPoolerRegion = network.regions['temporalPoolerRegion'] DCNL DCSP temporalPoolerRegion.setParameter('topDownMode', True) DCNL DCSP temporalPoolerRegion.setParameter('learningMode', True) DCNL DCSP temporalPoolerRegion.setParameter('inferenceMode', True) DCNL DCSP temporalPoolerRegion.setParameter('anomalyMode', True) DCNL DCSP return network
 DCSP sensorRegion = network.regions['sensor'] DCNL DCSP temporalPoolerRegion = network.regions['temporalPoolerRegion'] DCNL DCSP for i in xrange(_NUM_RECORDS): DCNL DCSP  DCSP network.run(1) DCNL DCSP  DCSP anomalyScore = temporalPoolerRegion.getOutputData('anomalyScore')[0] DCNL DCSP  DCSP consumption = sensorRegion.getOutputData('sourceOut')[0] DCNL DCSP  DCSP writer.writerow((i, consumption, anomalyScore))
 DCSP accuracy = 0 DCNL DCSP if (np.count_nonzero(predicted) > 0): DCNL DCSP  DCSP accuracy = (float(np.dot(current, predicted)) / float(np.count_nonzero(predicted))) DCNL DCSP return accuracy
 DCSP size = len(v1) DCNL DCSP v2 = np.zeros(size, dtype='uint32') DCNL DCSP bitsToSwap = int((noiseLevel * numActiveCols)) DCNL DCSP for i in range(size): DCNL DCSP  DCSP v2[i] = v1[i] DCNL DCSP for _ in range(bitsToSwap): DCNL DCSP  DCSP i = random.randrange(size) DCNL DCSP  DCSP if (v2[i] == 1): DCNL DCSP  DCSP  DCSP v2[i] = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP v2[i] = 1 DCNL DCSP return v2
 DCSP for k in range(6): DCNL DCSP  DCSP tm.reset() DCNL DCSP  DCSP print (('--- DCSP ' + 'ABCDXY'[k]) + ' DCSP ---') DCNL DCSP  DCSP tm.compute(set(seqT[k][:].nonzero()[0].tolist()), learn=False) DCNL DCSP  DCSP activeColumnsIndices = [tm.columnForCell(i) for i in tm.getActiveCells()] DCNL DCSP  DCSP predictedColumnIndices = [tm.columnForCell(i) for i in tm.getPredictiveCells()] DCNL DCSP  DCSP currentColumns = [(1 if (i in activeColumnsIndices) else 0) for i in range(tm.numberOfColumns())] DCNL DCSP  DCSP predictedColumns = [(1 if (i in predictedColumnIndices) else 0) for i in range(tm.numberOfColumns())] DCNL DCSP  DCSP print ('Active DCSP cols: DCSP ' + str(np.nonzero(currentColumns)[0])) DCNL DCSP  DCSP print ('Predicted DCSP cols: DCSP ' + str(np.nonzero(predictedColumns)[0])) DCNL DCSP  DCSP print ''
 DCSP currentColumns = np.zeros(tm.numberOfColumns(), dtype='uint32') DCNL DCSP predictedColumns = np.zeros(tm.numberOfColumns(), dtype='uint32') DCNL DCSP ts = 0 DCNL DCSP for t in range(timeSteps): DCNL DCSP  DCSP tm.reset() DCNL DCSP  DCSP for k in range(4): DCNL DCSP  DCSP  DCSP v = corruptVector(sequence[k][:], noiseLevel, sparseCols) DCNL DCSP  DCSP  DCSP tm.compute(set(v[:].nonzero()[0].tolist()), learn=True) DCNL DCSP  DCSP  DCSP activeColumnsIndices = [tm.columnForCell(i) for i in tm.getActiveCells()] DCNL DCSP  DCSP  DCSP predictedColumnIndices = [tm.columnForCell(i) for i in tm.getPredictiveCells()] DCNL DCSP  DCSP  DCSP currentColumns = [(1 if (i in activeColumnsIndices) else 0) for i in range(tm.numberOfColumns())] DCNL DCSP  DCSP  DCSP acc = accuracy(currentColumns, predictedColumns) DCNL DCSP  DCSP  DCSP x.append(ts) DCNL DCSP  DCSP  DCSP y.append(acc) DCNL DCSP  DCSP  DCSP ts += 1 DCNL DCSP  DCSP  DCSP predictedColumns = [(1 if (i in predictedColumnIndices) else 0) for i in range(tm.numberOfColumns())]
 DCSP assert (minOnes < maxOnes) DCNL DCSP assert (maxOnes < numCols) DCNL DCSP nOnes = rgen.randint(minOnes, maxOnes) DCNL DCSP candidates = list(colSet.difference(set(prevPattern.nonzero()[0]))) DCNL DCSP rgen.shuffle(candidates) DCNL DCSP ind = candidates[:nOnes] DCNL DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP x[ind] = 1 DCNL DCSP return x
 DCSP colSet = set(range(numCols)) DCNL DCSP if ('beginning' in seqGenMode): DCNL DCSP  DCSP assert (('shared' in seqGenMode) and ('no DCSP shared' not in seqGenMode)) DCNL DCSP if (('no DCSP shared' in seqGenMode) or (numSequences == 1)): DCNL DCSP  DCSP pctShared = 0.0 DCNL DCSP if (('no DCSP shared' not in seqGenMode) and ('one DCSP pattern' not in seqGenMode)): DCNL DCSP  DCSP sharedSequenceLength = int((pctShared * sequenceLength)) DCNL DCSP elif ('one DCSP pattern' in seqGenMode): DCNL DCSP  DCSP sharedSequenceLength = 1 DCNL DCSP else: DCNL DCSP  DCSP sharedSequenceLength = 0 DCNL DCSP assert ((sharedSequenceLength + subsequenceStartPos) < sequenceLength) DCNL DCSP sharedSequence = [] DCNL DCSP for i in xrange(sharedSequenceLength): DCNL DCSP  DCSP if (disjointConsecutive and (i > 0)): DCNL DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet, sharedSequence[(i - 1)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet) DCNL DCSP  DCSP sharedSequence.append(x) DCNL DCSP trainingSequences = [] DCNL DCSP if ('beginning' not in seqGenMode): DCNL DCSP  DCSP trailingLength = ((sequenceLength - sharedSequenceLength) - subsequenceStartPos) DCNL DCSP else: DCNL DCSP  DCSP trailingLength = (sequenceLength - sharedSequenceLength) DCNL DCSP for (k, s) in enumerate(xrange(numSequences)): DCNL DCSP  DCSP if ((len(trainingSequences) > 0) and ('shuffle' in seqGenMode)): DCNL DCSP  DCSP  DCSP r = (range(subsequenceStartPos) + range((subsequenceStartPos + sharedSequenceLength), sequenceLength)) DCNL DCSP  DCSP  DCSP rgen.shuffle(r) DCNL DCSP  DCSP  DCSP r = ((r[:subsequenceStartPos] + range(subsequenceStartPos, (subsequenceStartPos + sharedSequenceLength))) + r[subsequenceStartPos:]) DCNL DCSP  DCSP  DCSP sequence = [trainingSequences[(k - 1)][j] for j in r] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sequence = [] DCNL DCSP  DCSP  DCSP if ('beginning' not in seqGenMode): DCNL DCSP  DCSP  DCSP  DCSP for i in xrange(subsequenceStartPos): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (disjointConsecutive and (i > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet, sequence[(i - 1)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sequence.append(x) DCNL DCSP  DCSP  DCSP if (('shared' in seqGenMode) and ('no DCSP shared' not in seqGenMode)): DCNL DCSP  DCSP  DCSP  DCSP sequence.extend(sharedSequence) DCNL DCSP  DCSP  DCSP for i in xrange(trailingLength): DCNL DCSP  DCSP  DCSP  DCSP if (disjointConsecutive and (i > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet, sequence[(i - 1)]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet) DCNL DCSP  DCSP  DCSP  DCSP sequence.append(x) DCNL DCSP  DCSP assert (len(sequence) == sequenceLength) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP assert (len(trainingSequences) == numSequences) DCNL DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP print 'Training DCSP Sequences' DCNL DCSP  DCSP pprint.pprint(trainingSequences) DCNL DCSP if (sharedSequenceLength > 0): DCNL DCSP  DCSP return (trainingSequences, (subsequenceStartPos + sharedSequenceLength)) DCNL DCSP else: DCNL DCSP  DCSP return (trainingSequences, (-1))
 DCSP numCols = (numOnes * numPatterns) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP x[(i * numOnes):((i + 1) * numOnes)] = 1 DCNL DCSP  DCSP p.append(x) DCNL DCSP return p
 DCSP numPatterns = 11 DCNL DCSP p = getSimplePatterns(numOnes, numPatterns) DCNL DCSP s1 = [p[0], p[1], p[2], p[3], p[4], p[5], p[6]] DCNL DCSP s2 = [p[7], p[8], p[2], p[3], p[4], p[9], p[10]] DCNL DCSP trainingSequences = [s1, s2] DCNL DCSP return (trainingSequences, 5)
 DCSP numPatterns = 14 DCNL DCSP p = getSimplePatterns(numOnes, numPatterns) DCNL DCSP s1 = [p[0], p[1], p[0], p[1], p[0], p[2]] DCNL DCSP s2 = [p[0], p[1], p[0], p[1], p[3], p[4]] DCNL DCSP s3 = [p[0], p[1], p[5], p[6], p[7], p[8]] DCNL DCSP s4 = [p[0], p[9], p[10], p[11], p[12], p[13]] DCNL DCSP trainingSequences = [s1, s2, s3, s4] DCNL DCSP return (trainingSequences, 5)
 DCSP numPatterns = 23 DCNL DCSP p = getSimplePatterns(numOnes, numPatterns) DCNL DCSP s = [] DCNL DCSP s.append(p[rgen.randint(3, 23)]) DCNL DCSP for _ in xrange(20): DCNL DCSP  DCSP s.append(p[rgen.randint(3, 23)]) DCNL DCSP  DCSP s.append(p[0]) DCNL DCSP  DCSP s.append(p[1]) DCNL DCSP  DCSP s.append(p[2]) DCNL DCSP  DCSP s.append(p[rgen.randint(3, 23)]) DCNL DCSP return ([s], [[p[0], p[1], p[2]]])
 DCSP numPatterns = 23 DCNL DCSP p = getSimplePatterns(numOnes, numPatterns) DCNL DCSP s = [] DCNL DCSP s.append(p[rgen.randint(5, numPatterns)]) DCNL DCSP for _ in xrange(50): DCNL DCSP  DCSP r = rgen.randint(5, numPatterns) DCNL DCSP  DCSP print r, DCNL DCSP  DCSP s.append(p[r]) DCNL DCSP  DCSP if (rgen.binomial(1, 0.5) > 0): DCNL DCSP  DCSP  DCSP print 'S1', DCNL DCSP  DCSP  DCSP s.append(p[0]) DCNL DCSP  DCSP  DCSP s.append(p[1]) DCNL DCSP  DCSP  DCSP s.append(p[2]) DCNL DCSP  DCSP  DCSP s.append(p[4]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print 'S2', DCNL DCSP  DCSP  DCSP s.append(p[1]) DCNL DCSP  DCSP  DCSP s.append(p[2]) DCNL DCSP  DCSP  DCSP s.append(p[3]) DCNL DCSP  DCSP r = rgen.randint(5, numPatterns) DCNL DCSP  DCSP s.append(p[r]) DCNL DCSP  DCSP print r, DCNL DCSP print DCNL DCSP return ([s], [[p[0], p[1], p[2], p[4]], [p[1], p[2], p[3]]])
 DCSP upTo = (t + 2) DCNL DCSP if tm.doPooling: DCNL DCSP  DCSP upTo += min(tm.segUpdateValidDuration, nAcceptable) DCNL DCSP assert (upTo <= len(trainingSequences[whichSequence])) DCNL DCSP acceptablePatterns = [] DCNL DCSP if ((len(trainingSequences) == 2) and (trainingSequences[0][0] == trainingSequences[1][0]).all()): DCNL DCSP  DCSP if ((trainingSequences[0][t] == trainingSequences[1][t]).all() and (trainingSequences[0][(t + 1)] != trainingSequences[1][(t + 1)]).any()): DCNL DCSP  DCSP  DCSP acceptablePatterns.append(trainingSequences[0][(t + 1)]) DCNL DCSP  DCSP  DCSP acceptablePatterns.append(trainingSequences[1][(t + 1)]) DCNL DCSP acceptablePatterns += [trainingSequences[whichSequence][t] for t in xrange(t, upTo)] DCNL DCSP return acceptablePatterns
 DCSP global BacktrackingTM, SEED, checkSynapseConsistency, VERBOSITY DCNL DCSP numPerfect = 0 DCNL DCSP numStrictErrors = 0 DCNL DCSP numFailures = 0 DCNL DCSP sequenceLength = len(trainingSequences[0]) DCNL DCSP segUpdateValidDuration = 5 DCNL DCSP verbosity = VERBOSITY DCNL DCSP if highOrder: DCNL DCSP  DCSP tm = TMClass(numberOfCols, cellsPerColumn, initialPerm, connectedPerm, minThreshold, newSynapseCount, permanenceInc, permanenceDec, permanenceMax, globalDecay, activationThreshold, doPooling, segUpdateValidDuration, seed=SEED, verbosity=verbosity, checkSynapseConsistency=checkSynapseConsistency, pamLength=pamLength, maxSeqLength=0) DCNL DCSP else: DCNL DCSP  DCSP tm = TMClass(numberOfCols, cellsPerColumn, initialPerm, connectedPerm, minThreshold, newSynapseCount, permanenceInc, permanenceDec, permanenceMax, globalDecay, activationThreshold, doPooling, segUpdateValidDuration, seed=SEED, verbosity=verbosity, checkSynapseConsistency=checkSynapseConsistency, pamLength=pamLength) DCNL DCSP if compareToPy: DCNL DCSP  DCSP if highOrder: DCNL DCSP  DCSP  DCSP py_tm = BacktrackingTM(numberOfCols, cellsPerColumn, initialPerm, connectedPerm, minThreshold, newSynapseCount, permanenceInc, permanenceDec, permanenceMax, globalDecay, activationThreshold, doPooling, segUpdateValidDuration, seed=SEED, verbosity=verbosity, pamLength=pamLength, maxSeqLength=0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP py_tm = BacktrackingTM(numberOfCols, cellsPerColumn, initialPerm, connectedPerm, minThreshold, newSynapseCount, permanenceInc, permanenceDec, permanenceMax, globalDecay, activationThreshold, doPooling, segUpdateValidDuration, seed=SEED, verbosity=verbosity, pamLength=pamLength) DCNL DCSP trainingSequences = trainingSequences[0] DCNL DCSP if (testSequences == None): DCNL DCSP  DCSP testSequences = trainingSequences DCNL DCSP inferAcceptablePatterns = (acceptablePatterns == []) DCNL DCSP for r in xrange(nTrainingReps): DCNL DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP print '============= DCSP Learning DCSP round', r, '=================' DCNL DCSP  DCSP for (sequenceNum, trainingSequence) in enumerate(trainingSequences): DCNL DCSP  DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP  DCSP print '============= DCSP New DCSP sequence DCSP =================' DCNL DCSP  DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP  DCSP  DCSP if compareToPy: DCNL DCSP  DCSP  DCSP  DCSP  DCSP py_tm.reset() DCNL DCSP  DCSP  DCSP for (t, x) in enumerate(trainingSequence): DCNL DCSP  DCSP  DCSP  DCSP if ((noiseModel is not None) and ('xor' in noiseModel) and ('binomial' in noiseModel) and ('training' in noiseModel)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP noise_vector = rgen.binomial(len(x), noiseLevel, len(x)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = logical_xor(x, noise_vector) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Time DCSP step', t, 'learning DCSP round', r, 'sequence DCSP number', sequenceNum DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Input: DCSP ', tm.printInput(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'NNZ:', x.nonzero() DCNL DCSP  DCSP  DCSP  DCSP x = numpy.array(x).astype('float32') DCNL DCSP  DCSP  DCSP  DCSP y = tm.learn(x) DCNL DCSP  DCSP  DCSP  DCSP if compareToPy: DCNL DCSP  DCSP  DCSP  DCSP  DCSP py_y = py_tm.learn(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((t % 25) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert (fdrutils.tmDiff(tm, py_tm, VERBOSITY) == True) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY > 4)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP  DCSP print 'Sequence DCSP finished. DCSP Complete DCSP state DCSP after DCSP sequence' DCNL DCSP  DCSP  DCSP  DCSP tm.printCells() DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP numPerfectAtHub = 0 DCNL DCSP if compareToPy: DCNL DCSP  DCSP print 'End DCSP of DCSP training' DCNL DCSP  DCSP assert (fdrutils.tmDiff(tm, py_tm, VERBOSITY) == True) DCNL DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP print '============= DCSP Inference DCSP =================' DCNL DCSP for (s, testSequence) in enumerate(testSequences): DCNL DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP print '============= DCSP New DCSP sequence DCSP =================' DCNL DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP  DCSP if compareToPy: DCNL DCSP  DCSP  DCSP  DCSP py_tm.reset() DCNL DCSP  DCSP slen = len(testSequence) DCNL DCSP  DCSP for (t, x) in enumerate(testSequence): DCNL DCSP  DCSP  DCSP if ((noiseModel is not None) and ('xor' in noiseModel) and ('binomial' in noiseModel) and ('inference' in noiseModel)): DCNL DCSP  DCSP  DCSP  DCSP noise_vector = rgen.binomial(len(x), noiseLevel, len(x)) DCNL DCSP  DCSP  DCSP  DCSP x = logical_xor(x, noise_vector) DCNL DCSP  DCSP  DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP  DCSP  DCSP print 'Time DCSP step', t, '\nInput:', tm.printInput(x) DCNL DCSP  DCSP  DCSP x = numpy.array(x).astype('float32') DCNL DCSP  DCSP  DCSP y = tm.infer(x) DCNL DCSP  DCSP  DCSP if compareToPy: DCNL DCSP  DCSP  DCSP  DCSP py_y = py_tm.infer(x) DCNL DCSP  DCSP  DCSP  DCSP assert (fdrutils.tmDiff(tm, py_tm, VERBOSITY) == True) DCNL DCSP  DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY > 4), printLearnState=False) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP if (nMultiStepPrediction > 0): DCNL DCSP  DCSP  DCSP  DCSP y_ms = tm.predict(nSteps=nMultiStepPrediction) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Multi DCSP step DCSP prediction DCSP at DCSP Time DCSP step', t DCNL DCSP  DCSP  DCSP  DCSP  DCSP for i in range(nMultiStepPrediction): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Prediction DCSP at DCSP t+', (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm.printColConfidence(y_ms[i]) DCNL DCSP  DCSP  DCSP  DCSP for i in range(nMultiStepPrediction): DCNL DCSP  DCSP  DCSP  DCSP  DCSP predictedTimeStep = ((t + i) + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (predictedTimeStep < slen): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP input = testSequence[predictedTimeStep].nonzero()[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP prediction = y_ms[i].nonzero()[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (foundInInput, totalActiveInInput, missingFromInput, totalActiveInPrediction) = fdrutils.checkMatch(input, prediction, sparse=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP falseNegatives = (totalActiveInInput - foundInInput) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP falsePositives = missingFromInput DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Predition DCSP from DCSP %d DCSP to DCSP %d' % (t, ((t + i) + 1))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB False DCSP Negatives:', falseNegatives DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB False DCSP Positivies:', falsePositives DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 0) or (falsePositives > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numStrictErrors += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 0) and (VERBOSITY > 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Multi DCSP step DCSP prediction DCSP from DCSP t=', t, 'to DCSP t=', ((t + i) + 1), 'false DCSP negative DCSP with DCSP error=', falseNegatives, DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'out DCSP of', totalActiveInInput, 'ones' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((falsePositives > 0) and (VERBOSITY > 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Multi DCSP step DCSP prediction DCSP from DCSP t=', t, 'to DCSP t=', ((t + i) + 1), 'false DCSP positive DCSP with DCSP error=', falsePositives, DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'out DCSP of', totalActiveInInput, 'ones' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((falsePositives > 3) or (falseNegatives > 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numFailures += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((VERBOSITY > 1) and (not shouldFail)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Input DCSP at DCSP t=', t DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(testSequence[t]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Prediction DCSP for DCSP t=', ((t + i) + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(y_ms[i]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Actual DCSP input DCSP at DCSP t=', ((t + i) + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(testSequence[((t + i) + 1)]) DCNL DCSP  DCSP  DCSP if (t < (slen - 1)): DCNL DCSP  DCSP  DCSP  DCSP if inferAcceptablePatterns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP acceptablePatterns = findAcceptablePatterns(tm, t, s, testSequences, nAcceptable) DCNL DCSP  DCSP  DCSP  DCSP scores = tm._checkPrediction([pattern.nonzero()[0] for pattern in acceptablePatterns]) DCNL DCSP  DCSP  DCSP  DCSP (falsePositives, falseNegatives) = (scores[0], scores[1]) DCNL DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 0) or (falsePositives > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP numStrictErrors += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 0) and (VERBOSITY > 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Pattern', s, 'time', t, 'prediction DCSP false DCSP negative DCSP with DCSP error=', falseNegatives, DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'out DCSP of', int(testSequence[(t + 1)].sum()), 'ones' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((falsePositives > 0) and (VERBOSITY > 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Pattern', s, 'time', t, 'prediction DCSP false DCSP positive DCSP with DCSP error=', falsePositives, DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'out DCSP of', int(testSequence[(t + 1)].sum()), 'ones' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((falseNegatives > 3) or (falsePositives > 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numFailures += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((VERBOSITY > 1) and (not shouldFail)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Test DCSP sequences' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (len(testSequences) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printAllTrainingSequences(testSequences, (t + 1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(testSequence[t]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(testSequence[(t + 1)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Acceptable' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for p in acceptablePatterns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(p) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Output' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP diagnostic = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output = sum(tm.currentOutput, axis=1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ' DCTB  DCTB ', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printOneTrainingVector(output) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP numPerfect += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((predJustAfterHubOnly is not None) and (predJustAfterHubOnly == t)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numPerfectAtHub += 1 DCNL DCSP if (predJustAfterHubOnly is None): DCNL DCSP  DCSP return (numFailures, numStrictErrors, numPerfect, tm) DCNL DCSP else: DCNL DCSP  DCSP return (numFailures, numStrictErrors, numPerfect, numPerfectAtHub, tm)
 DCSP print 'Test DCSP H2a DCSP - DCSP second DCSP repetition DCSP of DCSP the DCSP same DCSP sequence DCSP should DCSP not DCSP add DCSP synapses' DCNL DCSP nFailed = 0 DCNL DCSP subsequenceStartPos = 10 DCNL DCSP assert (subsequenceStartPos < sequenceLength) DCNL DCSP for numSequences in nSequences: DCNL DCSP  DCSP print 'Higher DCSP order DCSP test DCSP with DCSP sequenceLength=', sequenceLength, DCNL DCSP  DCSP print 'cellsPerColumn=', cellsPerColumn, 'nTests=', nTests, 'numCols=', numCols DCNL DCSP  DCSP print 'numSequences=', numSequences, 'pctShared=', pctShared, DCNL DCSP  DCSP print 'sharing DCSP mode=', seqGenMode DCNL DCSP  DCSP for _ in range(nTests): DCNL DCSP  DCSP  DCSP trainingSet = buildTrainingSet(numSequences=numSequences, sequenceLength=sequenceLength, pctShared=pctShared, seqGenMode=seqGenMode, subsequenceStartPos=subsequenceStartPos, numCols=numCols, minOnes=21, maxOnes=25) DCNL DCSP  DCSP  DCSP print '============== DCSP 10 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures3, numStrictErrors3, numPerfect3, tm3) = testSequence(trainingSet, nTrainingReps=10, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.4, connectedPerm=0.7, minThreshold=12, permanenceInc=0.1, permanenceDec=0.1, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThreshold=12, doPooling=False, shouldFail=shouldFail) DCNL DCSP  DCSP  DCSP print '============== DCSP 2 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures, numStrictErrors, numPerfect, tm2) = testSequence(trainingSet, nTrainingReps=2, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=12, permanenceInc=0.1, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThreshold=12, doPooling=False, shouldFail=shouldFail) DCNL DCSP  DCSP  DCSP print '============== DCSP 1 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures1, numStrictErrors1, numPerfect1, tm1) = testSequence(trainingSet, nTrainingReps=1, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=12, permanenceInc=0.1, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThreshold=12, doPooling=False, shouldFail=shouldFail) DCNL DCSP  DCSP  DCSP segmentInfo1 = tm1.getSegmentInfo() DCNL DCSP  DCSP  DCSP segmentInfo2 = tm2.getSegmentInfo() DCNL DCSP  DCSP  DCSP if ((abs((segmentInfo1[0] - segmentInfo2[0])) > 3) or (abs((segmentInfo1[1] - segmentInfo2[1])) > (3 * 15))): DCNL DCSP  DCSP  DCSP  DCSP print 'Training DCSP twice DCSP incorrectly DCSP resulted DCSP in DCSP too DCSP many DCSP segments DCSP or DCSP synapses' DCNL DCSP  DCSP  DCSP  DCSP print segmentInfo1 DCNL DCSP  DCSP  DCSP  DCSP print segmentInfo2 DCNL DCSP  DCSP  DCSP  DCSP print tm3.getSegmentInfo() DCNL DCSP  DCSP  DCSP  DCSP tm3.trimSegments() DCNL DCSP  DCSP  DCSP  DCSP print tm3.getSegmentInfo() DCNL DCSP  DCSP  DCSP  DCSP print 'Failures DCSP for DCSP 1, DCSP 2, DCSP and DCSP N DCSP reps' DCNL DCSP  DCSP  DCSP  DCSP print numFailures1, numStrictErrors1, numPerfect1 DCNL DCSP  DCSP  DCSP  DCSP print numFailures, numStrictErrors, numPerfect DCNL DCSP  DCSP  DCSP  DCSP print numFailures3, numStrictErrors3, numPerfect3 DCNL DCSP  DCSP  DCSP  DCSP numFailures += 1 DCNL DCSP  DCSP  DCSP if (((numFailures == 0) and (not shouldFail)) or ((numFailures > 0) and shouldFail)): DCNL DCSP  DCSP  DCSP  DCSP print 'Test DCSP PASS', DCNL DCSP  DCSP  DCSP  DCSP if shouldFail: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '(should DCSP fail, DCSP and DCSP failed)' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print 'Test DCSP FAILED' DCNL DCSP  DCSP  DCSP  DCSP nFailed = (nFailed + 1) DCNL DCSP  DCSP  DCSP  DCSP print 'numFailures=', numFailures DCNL DCSP  DCSP  DCSP  DCSP print 'numStrictErrors=', numStrictErrors DCNL DCSP  DCSP  DCSP  DCSP print 'numPerfect=', numPerfect DCNL DCSP return nFailed
 DCSP (cellsPerColumn, numSequences) = (x[0], x[1]) DCNL DCSP nTrainingReps = 1 DCNL DCSP sequenceLength = 10 DCNL DCSP numCols = 200 DCNL DCSP print 'Started', cellsPerColumn, numSequences DCNL DCSP seqGenMode = 'shared DCSP subsequence, DCSP one DCSP pattern' DCNL DCSP subsequenceStartPos = 5 DCNL DCSP trainingSet = buildTrainingSet(numSequences=numSequences, sequenceLength=sequenceLength, pctShared=0.1, seqGenMode=seqGenMode, subsequenceStartPos=subsequenceStartPos, numCols=numCols, minOnes=21, maxOnes=25) DCNL DCSP (numFailures1, numStrictErrors1, numPerfect1, atHub, tm) = testSequence(trainingSet, nTrainingReps=nTrainingReps, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=11, permanenceInc=0.4, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=8, activationThreshold=8, doPooling=False, shouldFail=False, predJustAfterHubOnly=5) DCNL DCSP seqGenMode = 'no DCSP shared DCSP subsequence' DCNL DCSP trainingSet = buildTrainingSet(numSequences=numSequences, sequenceLength=sequenceLength, pctShared=0, seqGenMode=seqGenMode, subsequenceStartPos=0, numCols=numCols, minOnes=21, maxOnes=25) DCNL DCSP (numFailures2, numStrictErrors2, numPerfect2, tm) = testSequence(trainingSet, nTrainingReps=nTrainingReps, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=11, permanenceInc=0.4, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=8, activationThreshold=8, doPooling=False, shouldFail=False) DCNL DCSP print 'Completed', DCNL DCSP print cellsPerColumn, numSequences, numFailures1, numStrictErrors1, numPerfect1, atHub, numFailures2, numStrictErrors2, numPerfect2 DCNL DCSP return (cellsPerColumn, numSequences, numFailures1, numStrictErrors1, numPerfect1, atHub, numFailures2, numStrictErrors2, numPerfect2)
 DCSP from multiprocessing import Pool DCNL DCSP import itertools DCNL DCSP print 'Hub DCSP capacity DCSP test' DCNL DCSP p = Pool(2) DCNL DCSP results = p.map(worker, itertools.product([1, 2, 3, 4, 5, 6, 7, 8], xrange(1, 2000, 200))) DCNL DCSP f = open('results-numPerfect.11.22.10.txt', 'w') DCNL DCSP for (i, r) in enumerate(results): DCNL DCSP  DCSP print >>f, ('{%d,%d,%d,%d,%d,%d,%d,%d,%d},' % r) DCNL DCSP f.close()
 DCSP print ''.join((('1' if (k != 0) else '.') for k in x))
 DCSP assert (patternOverlap < numOnes) DCNL DCSP numNewBitsInEachPattern = (numOnes - patternOverlap) DCNL DCSP numCols = ((numNewBitsInEachPattern * numPatterns) + patternOverlap) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP startBit = (i * numNewBitsInEachPattern) DCNL DCSP  DCSP nextStartBit = (startBit + numOnes) DCNL DCSP  DCSP x[startBit:nextStartBit] = 1 DCNL DCSP  DCSP p.append(x) DCNL DCSP return p
 DCSP numSharedElements = len(sharedElements) DCNL DCSP numUniqueElements = (seqLen - numSharedElements) DCNL DCSP numPatterns = (numSharedElements + (numUniqueElements * numSequences)) DCNL DCSP patterns = getSimplePatterns(numOnBitsPerPattern, numPatterns, patternOverlap) DCNL DCSP numCols = len(patterns[0]) DCNL DCSP trainingSequences = [] DCNL DCSP uniquePatternIndices = range(numSharedElements, numPatterns) DCNL DCSP for _ in xrange(numSequences): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP sharedPatternIndices = range(numSharedElements) DCNL DCSP  DCSP for j in xrange(seqLen): DCNL DCSP  DCSP  DCSP if (j in sharedElements): DCNL DCSP  DCSP  DCSP  DCSP patIdx = sharedPatternIndices.pop(0) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP patIdx = uniquePatternIndices.pop(0) DCNL DCSP  DCSP  DCSP sequence.append(patterns[patIdx]) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP print '\nTraining DCSP sequences' DCNL DCSP  DCSP printAllTrainingSequences(trainingSequences) DCNL DCSP return (numCols, trainingSequences)
 DCSP patterns = getSimplePatterns(numOnBitsPerPattern, numPatterns, patternOverlap) DCNL DCSP numCols = len(patterns[0]) DCNL DCSP trainingSequences = [] DCNL DCSP for _ in xrange(numSequences): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP length = random.choice(seqLen) DCNL DCSP  DCSP for _ in xrange(length): DCNL DCSP  DCSP  DCSP patIdx = random.choice(xrange(numPatterns)) DCNL DCSP  DCSP  DCSP sequence.append(patterns[patIdx]) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP print '\nTraining DCSP sequences' DCNL DCSP  DCSP printAllTrainingSequences(trainingSequences) DCNL DCSP return (numCols, trainingSequences)
 DCSP connectedPerm = 0.5 DCNL DCSP tms = dict() DCNL DCSP if includeCPP: DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print 'Creating DCSP BacktrackingTMCPP DCSP instance' DCNL DCSP  DCSP cpp_tm = BacktrackingTMCPP(numberOfCols=numCols, cellsPerColumn=cellsPerCol, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=SEED, verbosity=VERBOSITY, checkSynapseConsistency=checkSynapseConsistency, collectStats=True, pamLength=pamLength, maxInfBacktrack=maxInfBacktrack, maxLrnBacktrack=maxLrnBacktrack) DCNL DCSP  DCSP cpp_tm.retrieveLearningStates = True DCNL DCSP  DCSP tms['CPP'] = cpp_tm DCNL DCSP if includePy: DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print 'Creating DCSP PY DCSP TM DCSP instance' DCNL DCSP  DCSP py_tm = BacktrackingTM(numberOfCols=numCols, cellsPerColumn=cellsPerCol, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=SEED, verbosity=VERBOSITY, collectStats=True, pamLength=pamLength, maxInfBacktrack=maxInfBacktrack, maxLrnBacktrack=maxLrnBacktrack) DCNL DCSP  DCSP tms['PY DCSP '] = py_tm DCNL DCSP return tms
 DCSP if (len(tms) == 1): DCNL DCSP  DCSP return DCNL DCSP if (len(tms) > 2): DCNL DCSP  DCSP raise 'Not DCSP implemented DCSP for DCSP more DCSP than DCSP 2 DCSP TMs' DCNL DCSP same = fdrutils.tmDiff2(tms.values(), verbosity=VERBOSITY) DCNL DCSP assert same DCNL DCSP return
 DCSP if (testSequences == None): DCNL DCSP  DCSP testSequences = trainingSequences DCNL DCSP firstTM = tms.values()[0] DCNL DCSP assertNoTMDiffs(tms) DCNL DCSP for trainingNum in xrange(nTrainRepetitions): DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print '\n##############################################################' DCNL DCSP  DCSP  DCSP print ('################# DCSP Training DCSP round DCSP #%d DCSP of DCSP %d DCSP #################' % (trainingNum, nTrainRepetitions)) DCNL DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP print ('TM DCSP parameters DCSP for DCSP %s: DCSP ' % name) DCNL DCSP  DCSP  DCSP  DCSP print '---------------------' DCNL DCSP  DCSP  DCSP  DCSP tm.printParameters() DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP numSequences = len(testSequences) DCNL DCSP  DCSP for (sequenceNum, trainingSequence) in enumerate(trainingSequences): DCNL DCSP  DCSP  DCSP numTimeSteps = len(trainingSequence) DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP print ('\n================= DCSP Sequence DCSP #%d DCSP of DCSP %d DCSP ================' % (sequenceNum, numSequences)) DCNL DCSP  DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP  DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP  DCSP for (t, x) in enumerate(trainingSequence): DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print '------------------------------------------------------------' DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('--------- DCSP sequence: DCSP #%d DCSP of DCSP %d, DCSP timeStep: DCSP #%d DCSP of DCSP %d DCSP -----------' % (sequenceNum, numSequences, t, numTimeSteps)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP firstTM.printInput(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'input DCSP nzs:', x.nonzero() DCNL DCSP  DCSP  DCSP  DCSP x = numpy.array(x).astype('float32') DCNL DCSP  DCSP  DCSP  DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.learn(x, enableInference=True) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('I/O DCSP states DCSP of DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print '-------------------------------------', DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY >= 5)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP assertNoTMDiffs(tms) DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP stats = tm.getStats() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('# DCSP of DCSP unpredicted DCSP columns DCSP for DCSP %s DCSP TM: DCSP %d DCSP of DCSP %d' % (name, stats['curMissing'], x.sum())) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numBurstingCols = tm.infActiveState['t'].min(axis=1).sum() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('# DCSP of DCSP bursting DCSP columns DCSP for DCSP %s DCSP TM: DCSP %d DCSP of DCSP %d' % (name, numBurstingCols, x.sum())) DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 4): DCNL DCSP  DCSP  DCSP  DCSP print ('Sequence DCSP %d DCSP finished.' % sequenceNum) DCNL DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('All DCSP cells DCSP of DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '-------------------------------------', DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.printCells() DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print DCNL DCSP  DCSP prevResult = None DCNL DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP stats = tm.getStats() DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 1): DCNL DCSP  DCSP  DCSP  DCSP print ('Stats DCSP for DCSP %s DCSP TM DCSP over DCSP all DCSP sequences DCSP for DCSP training DCSP round DCSP #%d DCSP of DCSP %d:' % (name, trainingNum, nTrainRepetitions)) DCNL DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP total DCSP missing:', stats['totalMissing'] DCNL DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP total DCSP extra:', stats['totalExtra'] DCNL DCSP  DCSP  DCSP if (prevResult is None): DCNL DCSP  DCSP  DCSP  DCSP prevResult = (stats['totalMissing'], stats['totalExtra']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (stats['totalMissing'] == prevResult[0]) DCNL DCSP  DCSP  DCSP  DCSP assert (stats['totalExtra'] == prevResult[1]) DCNL DCSP  DCSP  DCSP tm.resetStats() DCNL DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP print 'Calling DCSP trim DCSP segments' DCNL DCSP prevResult = None DCNL DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP (nSegsRemoved, nSynsRemoved) = tm.trimSegments() DCNL DCSP  DCSP if (prevResult is None): DCNL DCSP  DCSP  DCSP prevResult = (nSegsRemoved, nSynsRemoved) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert (nSegsRemoved == prevResult[0]) DCNL DCSP  DCSP  DCSP assert (nSynsRemoved == prevResult[1]) DCNL DCSP assertNoTMDiffs(tms) DCNL DCSP if (VERBOSITY >= 4): DCNL DCSP  DCSP print 'Training DCSP completed. DCSP Complete DCSP state:' DCNL DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP print ('%s:' % name) DCNL DCSP  DCSP  DCSP tm.printCells() DCNL DCSP  DCSP  DCSP print DCNL DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP print '\n##############################################################' DCNL DCSP  DCSP print '########################## DCSP Inference DCSP #########################' DCNL DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP tm.resetStats() DCNL DCSP numSequences = len(testSequences) DCNL DCSP for (sequenceNum, testSequence) in enumerate(testSequences): DCNL DCSP  DCSP numTimeSteps = len(testSequence) DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print ('\n================= DCSP Sequence DCSP %d DCSP of DCSP %d DCSP ================' % (sequenceNum, numSequences)) DCNL DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP for (t, x) in enumerate(testSequence): DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '------------------------------------------------------------' DCNL DCSP  DCSP  DCSP  DCSP print ('--------- DCSP sequence: DCSP #%d DCSP of DCSP %d, DCSP timeStep: DCSP #%d DCSP of DCSP %d DCSP -----------' % (sequenceNum, numSequences, t, numTimeSteps)) DCNL DCSP  DCSP  DCSP  DCSP firstTM.printInput(x) DCNL DCSP  DCSP  DCSP  DCSP print 'input DCSP nzs:', x.nonzero() DCNL DCSP  DCSP  DCSP for tm in tms.itervalues(): DCNL DCSP  DCSP  DCSP  DCSP tm.infer(x) DCNL DCSP  DCSP  DCSP assertNoTMDiffs(tms) DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stats = tm.getStats() DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('# DCSP of DCSP unpredicted DCSP columns DCSP for DCSP %s DCSP TM: DCSP %d DCSP of DCSP %d' % (name, stats['curMissing'], x.sum())) DCNL DCSP  DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('I/O DCSP states DCSP of DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '-------------------------------------', DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY >= 5), printLearnState=False) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (VERBOSITY >= 4): DCNL DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP print ('Interim DCSP internal DCSP stats DCSP for DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP  DCSP print '---------------------------------' DCNL DCSP  DCSP  DCSP  DCSP pprint.pprint(tm.getStats()) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP print '\n##############################################################' DCNL DCSP  DCSP print '####################### DCSP Inference DCSP Done DCSP #######################' DCNL DCSP tmStats = dict() DCNL DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP tmStats[name] = stats = tm.getStats() DCNL DCSP  DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP  DCSP print ('Stats DCSP for DCSP %s DCSP TM DCSP over DCSP all DCSP sequences:' % name) DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP total DCSP missing:', stats['totalMissing'] DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP total DCSP extra:', stats['totalExtra'] DCNL DCSP for (name, tm) in tms.iteritems(): DCNL DCSP  DCSP if (VERBOSITY >= 3): DCNL DCSP  DCSP  DCSP print ('\nAll DCSP internal DCSP stats DCSP for DCSP %s DCSP TM:' % name) DCNL DCSP  DCSP  DCSP print '-------------------------------------', DCNL DCSP  DCSP  DCSP pprint.pprint(tmStats[name]) DCNL DCSP  DCSP  DCSP print DCNL DCSP return tmStats
 DCSP params = dict(baseParams) DCNL DCSP params.update(mods) DCNL DCSP func = params['seqFunction'] DCNL DCSP (numCols, trainingSequences) = func(**params) DCNL DCSP if (params['numCols'] is None): DCNL DCSP  DCSP params['numCols'] = numCols DCNL DCSP tms = createTMs(**params) DCNL DCSP tmStats = evalSequences(tms=tms, trainingSequences=trainingSequences, testSequences=None, **params) DCNL DCSP for (name, stats) in tmStats.iteritems(): DCNL DCSP  DCSP print ('Detected DCSP %d DCSP missing DCSP predictions DCSP overall DCSP during DCSP inference' % stats['totalMissing']) DCNL DCSP  DCSP if ((expMissingMin is not None) and (stats['totalMissing'] < expMissingMin)): DCNL DCSP  DCSP  DCSP print ('FAILURE: DCSP Expected DCSP at DCSP least DCSP %d DCSP total DCSP missing DCSP but DCSP got DCSP %d' % (expMissingMin, stats['totalMissing'])) DCNL DCSP  DCSP  DCSP assert False DCNL DCSP  DCSP if ((expMissingMax is not None) and (stats['totalMissing'] > expMissingMax)): DCNL DCSP  DCSP  DCSP print ('FAILURE: DCSP Expected DCSP at DCSP most DCSP %d DCSP total DCSP missing DCSP but DCSP got DCSP %d' % (expMissingMax, stats['totalMissing'])) DCNL DCSP  DCSP  DCSP assert False DCNL DCSP return True
 DCSP print ''.join((('1' if (k != 0) else '.') for k in x))
 DCSP numCols = (numOnes * numPatterns) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = np.zeros(numCols, dtype='float32') DCNL DCSP  DCSP x[(i * numOnes):((i + 1) * numOnes)] = 1 DCNL DCSP  DCSP p.append(x) DCNL DCSP return p
 DCSP minThreshold = 4 DCNL DCSP activationThreshold = 5 DCNL DCSP newSynapseCount = 7 DCNL DCSP initialPerm = 0.3 DCNL DCSP connectedPerm = 0.5 DCNL DCSP permanenceInc = 0.1 DCNL DCSP permanenceDec = 0.05 DCNL DCSP globalDecay = 0 DCNL DCSP cellsPerColumn = 1 DCNL DCSP cppTm = BacktrackingTMCPP(numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=SEED, verbosity=VERBOSITY, checkSynapseConsistency=True, pamLength=1000) DCNL DCSP cppTm.retrieveLearningStates = True DCNL DCSP pyTm = BacktrackingTM(numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, burnIn=1, seed=SEED, verbosity=VERBOSITY, pamLength=1000) DCNL DCSP return (cppTm, pyTm)
 DCSP with open(os.path.join(REPO_DIR, 'VERSION'), 'r') as versionFile: DCNL DCSP  DCSP return versionFile.read().strip()
 DCSP try: DCNL DCSP  DCSP nupicDistribution = pkg_resources.get_distribution('nupic.bindings') DCNL DCSP  DCSP if pkg_resources.parse_version(nupicDistribution.version).is_prerelease: DCNL DCSP  DCSP  DCSP return True DCNL DCSP except pkg_resources.DistributionNotFound: DCNL DCSP  DCSP pass DCNL DCSP return False
 DCSP requirementsPath = os.path.join(REPO_DIR, 'requirements.txt') DCNL DCSP requirements = parse_file(requirementsPath) DCNL DCSP if nupicBindingsPrereleaseInstalled(): DCNL DCSP  DCSP requirements = [req for req in requirements if ('nupic.bindings' not in req)] DCNL DCSP return requirements
 DCSP helpString = "\n\n%prog DCSP [options] DCSP permutationsScript\n%prog DCSP [options] DCSP expDescription.json\n\nThis DCSP script DCSP runs DCSP permutations DCSP of DCSP an DCSP experiment DCSP via DCSP Grok DCSP engine, DCSP as DCSP defined DCSP in DCSP a\npermutations.py DCSP script DCSP or DCSP an DCSP expGenerator DCSP experiment DCSP description DCSP json DCSP file.\nIn DCSP the DCSP expDescription.json DCSP form, DCSP the DCSP json DCSP file DCSP MUST DCSP have DCSP the DCSP file DCSP extension\n'.json' DCSP and DCSP MUST DCSP conform DCSP to DCSP expGenerator/experimentDescriptionSchema.json." DCNL DCSP parser = optparse.OptionParser(usage=helpString) DCNL DCSP parser.add_option('--replaceReport', dest='replaceReport', action='store_true', default=DEFAULT_OPTIONS['replaceReport'], help='Replace DCSP existing DCSP csv DCSP report DCSP file DCSP if DCSP it DCSP exists. DCSP Default DCSP is DCSP to DCSP append DCSP to DCSP the DCSP existing DCSP file. DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--action', dest='action', default=DEFAULT_OPTIONS['action'], choices=['run', 'pickup', 'report', 'dryRun'], help='Which DCSP action DCSP to DCSP perform. DCSP Possible DCSP actions DCSP are DCSP run, DCSP pickup, DCSP choices, DCSP report, DCSP list. DCSP run: DCSP run DCSP a DCSP new DCSP HyperSearch DCSP via DCSP Grok. DCSP pickup: DCSP pick DCSP up DCSP the DCSP latest DCSP run DCSP of DCSP a DCSP HyperSearch DCSP job. DCSP dryRun: DCSP run DCSP a DCSP single DCSP HypersearchWorker DCSP inline DCSP within DCSP the DCSP application DCSP process DCSP without DCSP the DCSP Grok DCSP infrastructure DCSP to DCSP flush DCSP out DCSP bugs DCSP in DCSP description DCSP and DCSP permutations DCSP scripts; DCSP defaults DCSP to DCSP maxPermutations=1: DCSP use DCSP --maxPermutations DCSP to DCSP change DCSP this; DCSP report: DCSP just DCSP print DCSP results DCSP from DCSP the DCSP last DCSP or DCSP current DCSP run. DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--maxPermutations', dest='maxPermutations', default=DEFAULT_OPTIONS['maxPermutations'], type='int', help="Maximum DCSP number DCSP of DCSP models DCSP to DCSP search. DCSP Applies DCSP only DCSP to DCSP the DCSP 'run' DCSP and DCSP 'dryRun' DCSP actions. DCSP [default: DCSP %default].") DCNL DCSP parser.add_option('--exports', dest='exports', default=DEFAULT_OPTIONS['exports'], type='string', help='json DCSP dump DCSP of DCSP environment DCSP variable DCSP settings DCSP that DCSP should DCSP be DCSP appliedfor DCSP the DCSP job DCSP before DCSP running. DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--useTerminators', dest='useTerminators', action='store_true', default=DEFAULT_OPTIONS['useTerminators'], help='Use DCSP early DCSP model DCSP terminators DCSP in DCSP HyperSearch[default: DCSP %default].') DCNL DCSP parser.add_option('--maxWorkers', dest='maxWorkers', default=DEFAULT_OPTIONS['maxWorkers'], type='int', help="Maximum DCSP number DCSP of DCSP concurrent DCSP workers DCSP to DCSP launch. DCSP Applies DCSP only DCSP to DCSP the DCSP 'run' DCSP action. DCSP [default: DCSP %default].") DCNL DCSP parser.add_option('-v', dest='verbosityCount', action='count', default=0, help='Increase DCSP verbosity DCSP of DCSP the DCSP output. DCSP  DCSP Specify DCSP multiple DCSP times DCSP for DCSP increased DCSP verbosity. DCSP e.g., DCSP -vv DCSP is DCSP more DCSP verbose DCSP than DCSP -v.') DCNL DCSP parser.add_option('--timeout', dest='timeout', default=DEFAULT_OPTIONS['timeout'], type='int', help='Time DCSP out DCSP for DCSP this DCSP search DCSP in DCSP minutes[default: DCSP %default].') DCNL DCSP parser.add_option('--overwrite', default=DEFAULT_OPTIONS['overwrite'], action='store_true', help="If DCSP 'yes', DCSP overwrite DCSP existing DCSP description.py DCSP and DCSP permutations.py DCSP (in DCSP the DCSP same DCSP directory DCSP as DCSP the DCSP <expDescription.json> DCSP file) DCSP if DCSP they DCSP already DCSP exist. DCSP [default: DCSP %default].") DCNL DCSP parser.add_option('--genTopNDescriptions', dest='genTopNDescriptions', default=DEFAULT_OPTIONS['genTopNDescriptions'], type='int', help="Generate DCSP description DCSP files DCSP for DCSP the DCSP top DCSP N DCSP models. DCSP Each DCSP one DCSP will DCSP be DCSP placed DCSP into DCSP it's DCSP own DCSP subdirectory DCSP under DCSP the DCSP base DCSP description DCSP file.[default: DCSP %default].") DCNL DCSP (options, positionalArgs) = parser.parse_args(args) DCNL DCSP if (len(positionalArgs) != 1): DCNL DCSP  DCSP parser.error('You DCSP must DCSP supply DCSP the DCSP name DCSP of DCSP exactly DCSP one DCSP permutations DCSP script DCSP or DCSP JSON DCSP description DCSP file.') DCNL DCSP fileArgPath = os.path.expanduser(positionalArgs[0]) DCNL DCSP fileArgPath = os.path.expandvars(fileArgPath) DCNL DCSP fileArgPath = os.path.abspath(fileArgPath) DCNL DCSP permWorkDir = os.path.dirname(fileArgPath) DCNL DCSP outputLabel = os.path.splitext(os.path.basename(fileArgPath))[0] DCNL DCSP basename = os.path.basename(fileArgPath) DCNL DCSP fileExtension = os.path.splitext(basename)[1] DCNL DCSP optionsDict = vars(options) DCNL DCSP if (fileExtension == '.json'): DCNL DCSP  DCSP returnValue = permutations_runner.runWithJsonFile(fileArgPath, optionsDict, outputLabel, permWorkDir) DCNL DCSP else: DCNL DCSP  DCSP returnValue = permutations_runner.runWithPermutationsScript(fileArgPath, optionsDict, outputLabel, permWorkDir) DCNL DCSP return returnValue
 DCSP initLogging(verbose=True) DCNL DCSP initExperimentPrng() DCNL DCSP @staticmethod DCNL DCSP def _mockCreate(*args, **kwargs): DCNL DCSP  DCSP kwargs.pop('implementation', None) DCNL DCSP  DCSP return SDRClassifierDiff(*args, **kwargs) DCNL DCSP SDRClassifierFactory.create = _mockCreate DCNL DCSP runExperiment(sys.argv[1:])
 DCSP assert (value is None) DCNL DCSP value = set([]) DCNL DCSP for arg in parser.rargs: DCNL DCSP  DCSP if (arg[:1] == '-'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP value.add(arg) DCNL DCSP del parser.rargs[:len(value)] DCNL DCSP setattr(parser.values, option.dest, value)
 DCSP assert (value is None) DCNL DCSP value = [] DCNL DCSP for arg in parser.rargs: DCNL DCSP  DCSP if (arg[:1] == '-'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP value.append(arg) DCNL DCSP del parser.rargs[:len(value)] DCNL DCSP setattr(parser.values, option.dest, value)
 DCSP exitStatus = 0 DCNL DCSP parser.add_option('-t', '--testlist', action='callback', callback=collect_set, dest='testlist_file', help='Test DCSP list DCSP file, DCSP specifying DCSP tests DCSP (one DCSP per DCSP line)') DCNL DCSP parser.add_option('-v', '--verbose', action='store_true', dest='verbose') DCNL DCSP (options, tests) = parser.parse_args(args=parse_args) DCNL DCSP tests = set(tests) DCNL DCSP args = ['--boxed', '--verbose'] DCNL DCSP root = 'tests' DCNL DCSP if options.coverage: DCNL DCSP  DCSP args.append('--cov=nupic') DCNL DCSP if (options.processes is not None): DCNL DCSP  DCSP args.extend(['-n', options.processes]) DCNL DCSP if (options.markexpresson is not None): DCNL DCSP  DCSP args.extend(['-m', options.markexpresson]) DCNL DCSP if (options.results is not None): DCNL DCSP  DCSP results = options.results[:2] DCNL DCSP  DCSP format = results.pop(0) DCNL DCSP  DCSP if results: DCNL DCSP  DCSP  DCSP runid = results.pop(0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP runid = datetime.now().strftime('%Y%m%d%H%M%S') DCNL DCSP  DCSP results = os.path.join(root, 'results', 'xunit', str(runid)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makedirs(results) DCNL DCSP  DCSP except os.error: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP args.append(('--junitxml=' + os.path.join(results, 'results.xml'))) DCNL DCSP if (options.tests is not None): DCNL DCSP  DCSP tests.update(options.tests) DCNL DCSP if (options.unit or options.all): DCNL DCSP  DCSP tests.add(os.path.join(root, 'unit')) DCNL DCSP if (options.integration or options.all): DCNL DCSP  DCSP tests.add(os.path.join(root, 'integration')) DCNL DCSP if (options.swarming or options.all): DCNL DCSP  DCSP tests.add(os.path.join(root, 'swarming')) DCNL DCSP if options.verbose: DCNL DCSP  DCSP args.append('-v') DCNL DCSP if options.failfast: DCNL DCSP  DCSP args.append('-x') DCNL DCSP if ((not tests) or options.all): DCNL DCSP  DCSP tests.add(os.path.join(root, 'external')) DCNL DCSP  DCSP tests.add(os.path.join(root, 'unit')) DCNL DCSP if (options.testlist_file is not None): DCNL DCSP  DCSP if options.testlist_file: DCNL DCSP  DCSP  DCSP testlist = options.testlist_file.pop() DCNL DCSP  DCSP  DCSP if testlist.endswith('.testlist'): DCNL DCSP  DCSP  DCSP  DCSP testlist = [test.strip() for test in open(testlist).readlines()] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP testlist = options.testlist_file DCNL DCSP  DCSP  DCSP  DCSP testlist.add(testlist) DCNL DCSP  DCSP for test in testlist: DCNL DCSP  DCSP  DCSP specific_args = [(arg.replace('results.xml', (test.replace('/', '_') + '.xml')) if arg.startswith('--junitxml=') else arg) for arg in args] DCNL DCSP  DCSP  DCSP testStatus = call(((['py.test'] + specific_args) + [test])) DCNL DCSP  DCSP  DCSP if (testStatus is not 0): DCNL DCSP  DCSP  DCSP  DCSP exitStatus = testStatus DCNL DCSP else: DCNL DCSP  DCSP exitStatus = call(((['py.test'] + args) + list(tests))) DCNL DCSP return exitStatus
 DCSP inDim = [10000, 1, 1] DCNL DCSP colDim = [spDim, 1, 1] DCNL DCSP sp = spClass(inputDimensions=inDim, columnDimensions=colDim, potentialRadius=3, potentialPct=0.5, globalInhibition=False, localAreaDensity=(-1.0), numActiveColumnsPerInhArea=3, stimulusThreshold=1, synPermInactiveDec=0.01, synPermActiveInc=0.1, synPermConnected=0.1, minPctOverlapDutyCycle=0.1, dutyCyclePeriod=10, boostStrength=10.0, seed=42, spVerbosity=0) DCNL DCSP dataDim = inDim DCNL DCSP dataDim.append(nRuns) DCNL DCSP data = numpy.random.randint(0, 2, dataDim).astype('float32') DCNL DCSP for i in xrange(nRuns): DCNL DCSP  DCSP d = data[:, :, :, i] DCNL DCSP  DCSP activeArray = numpy.zeros(colDim) DCNL DCSP  DCSP sp.compute(d, True, activeArray)
 DCSP tm = tmClass(numberOfCols=tmDim) DCNL DCSP data = numpy.random.randint(0, 2, [tmDim, nRuns]).astype('float32') DCNL DCSP for i in xrange(nRuns): DCNL DCSP  DCSP d = data[:, i] DCNL DCSP  DCSP tm.compute(d, True)
 DCSP str = (getCopyrightHead() + '\n\n## DCSP This DCSP file DCSP defines DCSP parameters DCSP for DCSP a DCSP prediction DCSP experiment.\n\n###############################################################################\n# DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP IMPORTANT!!!\n# DCSP This DCSP params DCSP file DCSP is DCSP dynamically DCSP generated DCSP by DCSP the DCSP RunExperimentPermutations\n# DCSP script. DCSP Any DCSP changes DCSP made DCSP manually DCSP will DCSP be DCSP over-written DCSP the DCSP next DCSP time\n# DCSP RunExperimentPermutations DCSP is DCSP run!!!\n###############################################################################\n\n\nfrom DCSP nupic.frameworks.opf.exp_description_helpers DCSP import DCSP importBaseDescription\n\n# DCSP the DCSP sub-experiment DCSP configuration\nconfig DCSP ={\n') DCNL DCSP return str
 DCSP str = "\n}\n\nmod DCSP = DCSP importBaseDescription('base.py', DCSP config)\nlocals().update(mod.__dict__)\n" DCNL DCSP return str
 DCSP allKeys = results.keys() DCNL DCSP allKeys.sort() DCNL DCSP for key in allKeys: DCNL DCSP  DCSP if hasattr(results[key], 'keys'): DCNL DCSP  DCSP  DCSP _appendReportKeys(keys, ('%s%s:' % (prefix, key)), results[key]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP keys.add(('%s%s' % (prefix, key)))
 DCSP matchingReportKeys = [] DCNL DCSP for keyRE in reportKeyREs: DCNL DCSP  DCSP matchObj = re.compile(keyRE) DCNL DCSP  DCSP found = False DCNL DCSP  DCSP for keyName in allReportKeys: DCNL DCSP  DCSP  DCSP match = matchObj.match(keyName) DCNL DCSP  DCSP  DCSP if (match and (match.end() == len(keyName))): DCNL DCSP  DCSP  DCSP  DCSP matchingReportKeys.append(keyName) DCNL DCSP  DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP if (not found): DCNL DCSP  DCSP  DCSP raise _BadKeyError(keyRE) DCNL DCSP return matchingReportKeys
 DCSP subKeys = itemName.split(':') DCNL DCSP subResults = results DCNL DCSP for subKey in subKeys: DCNL DCSP  DCSP subResults = subResults[subKey] DCNL DCSP return subResults
 DCSP optimizeDict = dict() DCNL DCSP allReportKeys = set() DCNL DCSP _appendReportKeys(keys=allReportKeys, prefix='', results=allResults) DCNL DCSP matchingKeys = _matchReportKeys(reportKeys, allReportKeys) DCNL DCSP reportDict = dict() DCNL DCSP for keyName in matchingKeys: DCNL DCSP  DCSP value = _getReportItem(keyName, allResults) DCNL DCSP  DCSP reportDict[keyName] = value DCNL DCSP if (optimizeKey is not None): DCNL DCSP  DCSP matchingKeys = _matchReportKeys([optimizeKey], allReportKeys) DCNL DCSP  DCSP if (len(matchingKeys) == 0): DCNL DCSP  DCSP  DCSP raise _BadKeyError(optimizeKey) DCNL DCSP  DCSP elif (len(matchingKeys) > 1): DCNL DCSP  DCSP  DCSP raise _BadOptimizeKeyError(optimizeKey, matchingKeys) DCNL DCSP  DCSP optimizeKeyFullName = matchingKeys[0] DCNL DCSP  DCSP value = _getReportItem(optimizeKeyFullName, allResults) DCNL DCSP  DCSP optimizeDict[optimizeKeyFullName] = value DCNL DCSP  DCSP reportDict[optimizeKeyFullName] = value DCNL DCSP return (reportDict, optimizeDict)
 DCSP assert (type(string) in types.StringTypes) DCNL DCSP return pprint.pformat(string)
 DCSP msg = StringIO.StringIO() DCNL DCSP print >>msg, ('Exception DCSP occurred DCSP while DCSP running DCSP model DCSP %s: DCSP %r DCSP (%s)' % (modelID, e, type(e))) DCNL DCSP traceback.print_exc(None, msg) DCNL DCSP completionReason = jobsDAO.CMPL_REASON_ERROR DCNL DCSP completionMsg = msg.getvalue() DCNL DCSP logger.error(completionMsg) DCNL DCSP if (type(e) is not InvalidConnectionException): DCNL DCSP  DCSP jobsDAO.modelUpdateResults(modelID, results=None, numRecords=0) DCNL DCSP if (type(e) == JobFailException): DCNL DCSP  DCSP workerCmpReason = jobsDAO.jobGetFields(jobID, ['workerCompletionReason'])[0] DCNL DCSP  DCSP if (workerCmpReason == ClientJobsDAO.CMPL_REASON_SUCCESS): DCNL DCSP  DCSP  DCSP jobsDAO.jobSetFields(jobID, fields=dict(cancel=True, workerCompletionReason=ClientJobsDAO.CMPL_REASON_ERROR, workerCompletionMsg=': DCSP '.join((str(i) for i in e.args))), useConnectionID=False, ignoreUnchanged=True) DCNL DCSP return (completionReason, completionMsg)
 DCSP from nupic.swarming.ModelRunner import OPFModelRunner DCNL DCSP logger = logging.getLogger('com.numenta.nupic.hypersearch.utils') DCNL DCSP experimentDir = tempfile.mkdtemp() DCNL DCSP try: DCNL DCSP  DCSP logger.info(('Using DCSP experiment DCSP directory: DCSP %s' % experimentDir)) DCNL DCSP  DCSP paramsFilePath = os.path.join(experimentDir, 'description.py') DCNL DCSP  DCSP paramsFile = open(paramsFilePath, 'wb') DCNL DCSP  DCSP paramsFile.write(_paramsFileHead()) DCNL DCSP  DCSP items = params.items() DCNL DCSP  DCSP items.sort() DCNL DCSP  DCSP for (key, value) in items: DCNL DCSP  DCSP  DCSP quotedKey = _quoteAndEscape(key) DCNL DCSP  DCSP  DCSP if isinstance(value, basestring): DCNL DCSP  DCSP  DCSP  DCSP paramsFile.write((" DCSP  DCSP %s DCSP : DCSP '%s',\n" % (quotedKey, value))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP paramsFile.write((' DCSP  DCSP %s DCSP : DCSP %s,\n' % (quotedKey, value))) DCNL DCSP  DCSP paramsFile.write(_paramsFileTail()) DCNL DCSP  DCSP paramsFile.close() DCNL DCSP  DCSP baseParamsFile = open(os.path.join(experimentDir, 'base.py'), 'wb') DCNL DCSP  DCSP baseParamsFile.write(baseDescription) DCNL DCSP  DCSP baseParamsFile.close() DCNL DCSP  DCSP fd = open(paramsFilePath) DCNL DCSP  DCSP expDescription = fd.read() DCNL DCSP  DCSP fd.close() DCNL DCSP  DCSP jobsDAO.modelSetFields(modelID, {'genDescription': expDescription}) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP runner = OPFModelRunner(modelID=modelID, jobID=jobID, predictedField=predictedField, experimentDir=experimentDir, reportKeyPatterns=reportKeys, optimizeKeyPattern=optimizeKey, jobsDAO=jobsDAO, modelCheckpointGUID=modelCheckpointGUID, logLevel=logLevel, predictionCacheMaxRecords=predictionCacheMaxRecords) DCNL DCSP  DCSP  DCSP signal.signal(signal.SIGINT, runner.handleWarningSignal) DCNL DCSP  DCSP  DCSP (completionReason, completionMsg) = runner.run() DCNL DCSP  DCSP except InvalidConnectionException: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP (completionReason, completionMsg) = _handleModelRunnerException(jobID, modelID, jobsDAO, experimentDir, logger, e) DCNL DCSP finally: DCNL DCSP  DCSP shutil.rmtree(experimentDir) DCNL DCSP  DCSP signal.signal(signal.SIGINT, signal.default_int_handler) DCNL DCSP return (completionReason, completionMsg)
 DCSP return ('JOB_UUID1-' + str(uuid.uuid1()))
 DCSP if deepCopy: DCNL DCSP  DCSP d = copy.deepcopy(d) DCNL DCSP newDict = {} DCNL DCSP toCopy = [(k, v, newDict, ()) for (k, v) in d.iteritems()] DCNL DCSP while (len(toCopy) > 0): DCNL DCSP  DCSP (k, v, d, prevKeys) = toCopy.pop() DCNL DCSP  DCSP prevKeys = (prevKeys + (k,)) DCNL DCSP  DCSP if isinstance(v, dict): DCNL DCSP  DCSP  DCSP d[k] = dict() DCNL DCSP  DCSP  DCSP toCopy[0:0] = [(innerK, innerV, d[k], prevKeys) for (innerK, innerV) in v.iteritems()] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP newV = f(v, prevKeys) DCNL DCSP  DCSP  DCSP if ((not discardNoneKeys) or (newV is not None)): DCNL DCSP  DCSP  DCSP  DCSP d[k] = newV DCNL DCSP return newDict
 DCSP remainingDicts = [(d, ())] DCNL DCSP while (len(remainingDicts) > 0): DCNL DCSP  DCSP (current, prevKeys) = remainingDicts.pop() DCNL DCSP  DCSP for (k, v) in current.iteritems(): DCNL DCSP  DCSP  DCSP keys = (prevKeys + (k,)) DCNL DCSP  DCSP  DCSP if isinstance(v, dict): DCNL DCSP  DCSP  DCSP  DCSP remainingDicts.insert(0, (v, keys)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP f(v, keys)
 DCSP if hasattr(obj, '_asdict'): DCNL DCSP  DCSP obj = obj._asdict() DCNL DCSP if isinstance(obj, dict): DCNL DCSP  DCSP objOut = dict() DCNL DCSP  DCSP for (key, val) in obj.iteritems(): DCNL DCSP  DCSP  DCSP objOut[key] = clippedObj(val) DCNL DCSP elif hasattr(obj, '__iter__'): DCNL DCSP  DCSP objOut = [] DCNL DCSP  DCSP for val in obj: DCNL DCSP  DCSP  DCSP objOut.append(clippedObj(val)) DCNL DCSP else: DCNL DCSP  DCSP objOut = str(obj) DCNL DCSP  DCSP if (len(objOut) > maxElementSize): DCNL DCSP  DCSP  DCSP objOut = (objOut[0:maxElementSize] + '...') DCNL DCSP return objOut
 DCSP assert (len(kwds.keys()) >= 1) DCNL DCSP assert (('schemaPath' in kwds) or ('schemaDict' in kwds)) DCNL DCSP schemaDict = None DCNL DCSP if ('schemaPath' in kwds): DCNL DCSP  DCSP schemaPath = kwds.pop('schemaPath') DCNL DCSP  DCSP schemaDict = loadJsonValueFromFile(schemaPath) DCNL DCSP elif ('schemaDict' in kwds): DCNL DCSP  DCSP schemaDict = kwds.pop('schemaDict') DCNL DCSP try: DCNL DCSP  DCSP validictory.validate(value, schemaDict, **kwds) DCNL DCSP except validictory.ValidationError as e: DCNL DCSP  DCSP raise ValidationError(e)
 DCSP with open(inputFilePath) as fileObj: DCNL DCSP  DCSP value = json.load(fileObj) DCNL DCSP return value
 DCSP itemStrs = [] DCNL DCSP if isinstance(obj, dict): DCNL DCSP  DCSP items = obj.items() DCNL DCSP  DCSP items.sort() DCNL DCSP  DCSP for (key, value) in items: DCNL DCSP  DCSP  DCSP itemStrs.append(('%s: DCSP %s' % (json.dumps(key), sortedJSONDumpS(value)))) DCNL DCSP  DCSP return ('{%s}' % ', DCSP '.join(itemStrs)) DCNL DCSP elif hasattr(obj, '__iter__'): DCNL DCSP  DCSP for val in obj: DCNL DCSP  DCSP  DCSP itemStrs.append(sortedJSONDumpS(val)) DCNL DCSP  DCSP return ('[%s]' % ', DCSP '.join(itemStrs)) DCNL DCSP else: DCNL DCSP  DCSP return json.dumps(obj)
 DCSP return ('ERROR: DCSP %s DCSP (%s)' % (errorString, usageString))
 DCSP print '\n============== DCSP BEGIN DCSP INPUT DCSP SCHEMA DCSP for DCSP --description DCSP =========>>' DCNL DCSP print json.dumps(_getExperimentDescriptionSchema(), indent=(_INDENT_STEP * 2)) DCNL DCSP print '\n<<============== DCSP END DCSP OF DCSP INPUT DCSP SCHEMA DCSP for DCSP --description DCSP ========' DCNL DCSP return
 DCSP try: DCNL DCSP  DCSP args = json.loads(cmdArgStr) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise _InvalidCommandArgException(_makeUsageErrorStr((('JSON DCSP arg DCSP parsing DCSP failed DCSP for DCSP --description: DCSP %s\n' + 'ARG=<%s>') % (str(e), cmdArgStr)), usageStr)) DCNL DCSP filesDescription = _generateExperiment(args, outDir, hsVersion=hsVersion, claDescriptionTemplateFile=claDescriptionTemplateFile) DCNL DCSP pprint.pprint(filesDescription) DCNL DCSP return
 DCSP try: DCNL DCSP  DCSP fileHandle = open(filename, 'r') DCNL DCSP  DCSP JSONStringFromFile = fileHandle.read().splitlines() DCNL DCSP  DCSP JSONStringFromFile = ''.join(JSONStringFromFile) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise _InvalidCommandArgException(_makeUsageErrorStr((('File DCSP open DCSP failed DCSP for DCSP --descriptionFromFile: DCSP %s\n' + 'ARG=<%s>') % (str(e), filename)), usageStr)) DCNL DCSP _handleDescriptionOption(JSONStringFromFile, outDir, usageStr, hsVersion=hsVersion, claDescriptionTemplateFile=claDescriptionTemplateFile) DCNL DCSP return
 DCSP xInt = int(round(x)) DCNL DCSP return ((abs((x - xInt)) < (precision * x)), xInt)
 DCSP return (type(obj) in types.StringTypes)
 DCSP assert _isString(string) DCNL DCSP return pprint.pformat(string)
 DCSP indent = (_ONE_INDENT * indentLevels) DCNL DCSP lines = str.splitlines(True) DCNL DCSP result = '' DCNL DCSP if ((len(lines) > 0) and (not indentFirstLine)): DCNL DCSP  DCSP first = 1 DCNL DCSP  DCSP result += lines[0] DCNL DCSP else: DCNL DCSP  DCSP first = 0 DCNL DCSP for line in lines[first:]: DCNL DCSP  DCSP result += (indent + line) DCNL DCSP return result
 DCSP if (fieldType == 'string'): DCNL DCSP  DCSP return True DCNL DCSP if ((fieldType == 'int') or (fieldType == 'float')): DCNL DCSP  DCSP return False
 DCSP metricSpecArgs = dict(metric=metric, field=field, params=params, inferenceElement=inferenceElement) DCNL DCSP metricSpecAsString = ('MetricSpec(%s)' % ', DCSP '.join([('%s=%r' % (item[0], item[1])) for item in metricSpecArgs.iteritems()])) DCNL DCSP if (not returnLabel): DCNL DCSP  DCSP return metricSpecAsString DCNL DCSP spec = MetricSpec(**metricSpecArgs) DCNL DCSP metricLabel = spec.getLabel() DCNL DCSP return (metricSpecAsString, metricLabel)
 DCSP installPath = os.path.dirname(__file__) DCNL DCSP outputFile = open(outputFilePath, 'w') DCNL DCSP outputLines = [] DCNL DCSP inputLines = [] DCNL DCSP firstFile = True DCNL DCSP for templateFileName in templateFileNames: DCNL DCSP  DCSP if (not firstFile): DCNL DCSP  DCSP  DCSP inputLines.extend(([os.linesep] * 2)) DCNL DCSP  DCSP firstFile = False DCNL DCSP  DCSP inputFilePath = os.path.join(installPath, templateFileName) DCNL DCSP  DCSP inputFile = open(inputFilePath) DCNL DCSP  DCSP inputLines.extend(inputFile.readlines()) DCNL DCSP  DCSP inputFile.close() DCNL DCSP print 'Writing DCSP ', len(inputLines), 'lines...' DCNL DCSP for line in inputLines: DCNL DCSP  DCSP tempLine = line DCNL DCSP  DCSP for (k, v) in replacementDict.iteritems(): DCNL DCSP  DCSP  DCSP if (v is None): DCNL DCSP  DCSP  DCSP  DCSP v = 'None' DCNL DCSP  DCSP  DCSP tempLine = re.sub(k, v, tempLine) DCNL DCSP  DCSP outputFile.write(tempLine) DCNL DCSP outputFile.close()
 DCSP width = 7 DCNL DCSP fieldName = fieldInfo['fieldName'] DCNL DCSP fieldType = fieldInfo['fieldType'] DCNL DCSP encoderChoicesList = [] DCNL DCSP if (fieldType in ['float', 'int']): DCNL DCSP  DCSP aggFunction = 'mean' DCNL DCSP  DCSP encoders = [None] DCNL DCSP  DCSP for n in (13, 50, 150, 500): DCNL DCSP  DCSP  DCSP encoder = dict(type='ScalarSpaceEncoder', name=fieldName, fieldname=fieldName, n=n, w=width, clipInput=True, space='absolute') DCNL DCSP  DCSP  DCSP if ('minValue' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoder['minval'] = fieldInfo['minValue'] DCNL DCSP  DCSP  DCSP if ('maxValue' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoder['maxval'] = fieldInfo['maxValue'] DCNL DCSP  DCSP  DCSP encoders.append(encoder) DCNL DCSP  DCSP encoderChoicesList.append(encoders) DCNL DCSP elif (fieldType == 'string'): DCNL DCSP  DCSP aggFunction = 'first' DCNL DCSP  DCSP encoders = [None] DCNL DCSP  DCSP encoder = dict(type='SDRCategoryEncoder', name=fieldName, fieldname=fieldName, n=100, w=width) DCNL DCSP  DCSP encoders.append(encoder) DCNL DCSP  DCSP encoderChoicesList.append(encoders) DCNL DCSP elif (fieldType == 'datetime'): DCNL DCSP  DCSP aggFunction = 'first' DCNL DCSP  DCSP encoders = [None] DCNL DCSP  DCSP for radius in (1, 8): DCNL DCSP  DCSP  DCSP encoder = dict(type='DateEncoder', name=('%s_timeOfDay' % fieldName), fieldname=fieldName, timeOfDay=(width, radius)) DCNL DCSP  DCSP  DCSP encoders.append(encoder) DCNL DCSP  DCSP encoderChoicesList.append(encoders) DCNL DCSP  DCSP encoders = [None] DCNL DCSP  DCSP for radius in (1, 3): DCNL DCSP  DCSP  DCSP encoder = dict(type='DateEncoder', name=('%s_dayOfWeek' % fieldName), fieldname=fieldName, dayOfWeek=(width, radius)) DCNL DCSP  DCSP  DCSP encoders.append(encoder) DCNL DCSP  DCSP encoderChoicesList.append(encoders) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(("Unsupported DCSP field DCSP type DCSP '%s'" % fieldType)) DCNL DCSP return (encoderChoicesList, aggFunction)
 DCSP encoderChoicesList = [] DCNL DCSP for fieldInfo in includedFields: DCNL DCSP  DCSP fieldName = fieldInfo['fieldName'] DCNL DCSP  DCSP (choicesList, aggFunction) = _generateEncoderChoicesV1(fieldInfo) DCNL DCSP  DCSP encoderChoicesList.extend(choicesList) DCNL DCSP encoderSpecsList = [] DCNL DCSP for encoderChoices in encoderChoicesList: DCNL DCSP  DCSP encoder = encoderChoices[(-1)] DCNL DCSP  DCSP for c in _ILLEGAL_FIELDNAME_CHARACTERS: DCNL DCSP  DCSP  DCSP if (encoder['name'].find(c) >= 0): DCNL DCSP  DCSP  DCSP  DCSP raise _ExpGeneratorException(('Illegal DCSP character DCSP in DCSP field: DCSP %r DCSP (%r)' % (c, encoder['name']))) DCNL DCSP  DCSP encoderSpecsList.append(('%s: DCSP \n%s%s' % (_quoteAndEscape(encoder['name']), (2 * _ONE_INDENT), pprint.pformat(encoder, indent=(2 * _INDENT_STEP))))) DCNL DCSP encoderSpecsStr = ',\n DCSP  DCSP '.join(encoderSpecsList) DCNL DCSP permEncoderChoicesList = [] DCNL DCSP for encoderChoices in encoderChoicesList: DCNL DCSP  DCSP permEncoderChoicesList.append(('%s: DCSP %s,' % (_quoteAndEscape(encoderChoices[(-1)]['name']), pprint.pformat(encoderChoices, indent=(2 * _INDENT_STEP))))) DCNL DCSP permEncoderChoicesStr = '\n'.join(permEncoderChoicesList) DCNL DCSP permEncoderChoicesStr = _indentLines(permEncoderChoicesStr, 1, indentFirstLine=False) DCNL DCSP return (encoderSpecsStr, permEncoderChoicesStr)
 DCSP permStr = '' DCNL DCSP if encoderDict.get('classifierOnly', False): DCNL DCSP  DCSP permStr = 'dict(' DCNL DCSP  DCSP for (key, value) in encoderDict.items(): DCNL DCSP  DCSP  DCSP if (key == 'name'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if ((key == 'n') and (encoderDict['type'] != 'SDRCategoryEncoder')): DCNL DCSP  DCSP  DCSP  DCSP permStr += ('n=PermuteInt(%d, DCSP %d), DCSP ' % ((encoderDict['w'] + 7), (encoderDict['w'] + 500))) DCNL DCSP  DCSP  DCSP elif issubclass(type(value), basestring): DCNL DCSP  DCSP  DCSP  DCSP permStr += ("%s='%s', DCSP " % (key, value)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP permStr += ('%s=%s, DCSP ' % (key, value)) DCNL DCSP  DCSP permStr += ')' DCNL DCSP elif (encoderDict['type'] in ['ScalarSpaceEncoder', 'AdaptiveScalarEncoder', 'ScalarEncoder', 'LogEncoder']): DCNL DCSP  DCSP permStr = 'PermuteEncoder(' DCNL DCSP  DCSP for (key, value) in encoderDict.items(): DCNL DCSP  DCSP  DCSP if (key == 'fieldname'): DCNL DCSP  DCSP  DCSP  DCSP key = 'fieldName' DCNL DCSP  DCSP  DCSP elif (key == 'type'): DCNL DCSP  DCSP  DCSP  DCSP key = 'encoderClass' DCNL DCSP  DCSP  DCSP elif (key == 'name'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (key == 'n'): DCNL DCSP  DCSP  DCSP  DCSP permStr += ('n=PermuteInt(%d, DCSP %d), DCSP ' % ((encoderDict['w'] + 1), (encoderDict['w'] + 500))) DCNL DCSP  DCSP  DCSP elif (key == 'runDelta'): DCNL DCSP  DCSP  DCSP  DCSP if (value and (not ('space' in encoderDict))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP permStr += ('space=PermuteChoices([%s,%s]), DCSP ' % (_quoteAndEscape('delta'), _quoteAndEscape('absolute'))) DCNL DCSP  DCSP  DCSP  DCSP encoderDict.pop('runDelta') DCNL DCSP  DCSP  DCSP elif issubclass(type(value), basestring): DCNL DCSP  DCSP  DCSP  DCSP permStr += ("%s='%s', DCSP " % (key, value)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP permStr += ('%s=%s, DCSP ' % (key, value)) DCNL DCSP  DCSP permStr += ')' DCNL DCSP elif (encoderDict['type'] in ['SDRCategoryEncoder']): DCNL DCSP  DCSP permStr = 'PermuteEncoder(' DCNL DCSP  DCSP for (key, value) in encoderDict.items(): DCNL DCSP  DCSP  DCSP if (key == 'fieldname'): DCNL DCSP  DCSP  DCSP  DCSP key = 'fieldName' DCNL DCSP  DCSP  DCSP elif (key == 'type'): DCNL DCSP  DCSP  DCSP  DCSP key = 'encoderClass' DCNL DCSP  DCSP  DCSP elif (key == 'name'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if issubclass(type(value), basestring): DCNL DCSP  DCSP  DCSP  DCSP permStr += ("%s='%s', DCSP " % (key, value)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP permStr += ('%s=%s, DCSP ' % (key, value)) DCNL DCSP  DCSP permStr += ')' DCNL DCSP elif (encoderDict['type'] in ['DateEncoder']): DCNL DCSP  DCSP permStr = 'PermuteEncoder(' DCNL DCSP  DCSP for (key, value) in encoderDict.items(): DCNL DCSP  DCSP  DCSP if (key == 'fieldname'): DCNL DCSP  DCSP  DCSP  DCSP key = 'fieldName' DCNL DCSP  DCSP  DCSP elif (key == 'type'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (key == 'name'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (key == 'timeOfDay'): DCNL DCSP  DCSP  DCSP  DCSP permStr += ("encoderClass='%s.timeOfDay', DCSP " % encoderDict['type']) DCNL DCSP  DCSP  DCSP  DCSP permStr += 'radius=PermuteFloat(0.5, DCSP 12), DCSP ' DCNL DCSP  DCSP  DCSP  DCSP permStr += ('w=%d, DCSP ' % value[0]) DCNL DCSP  DCSP  DCSP elif (key == 'dayOfWeek'): DCNL DCSP  DCSP  DCSP  DCSP permStr += ("encoderClass='%s.dayOfWeek', DCSP " % encoderDict['type']) DCNL DCSP  DCSP  DCSP  DCSP permStr += 'radius=PermuteFloat(1, DCSP 6), DCSP ' DCNL DCSP  DCSP  DCSP  DCSP permStr += ('w=%d, DCSP ' % value[0]) DCNL DCSP  DCSP  DCSP elif (key == 'weekend'): DCNL DCSP  DCSP  DCSP  DCSP permStr += ("encoderClass='%s.weekend', DCSP " % encoderDict['type']) DCNL DCSP  DCSP  DCSP  DCSP permStr += 'radius=PermuteChoices([1]), DCSP  DCSP ' DCNL DCSP  DCSP  DCSP  DCSP permStr += ('w=%d, DCSP ' % value) DCNL DCSP  DCSP  DCSP elif issubclass(type(value), basestring): DCNL DCSP  DCSP  DCSP  DCSP permStr += ("%s='%s', DCSP " % (key, value)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP permStr += ('%s=%s, DCSP ' % (key, value)) DCNL DCSP  DCSP permStr += ')' DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(("Unsupported DCSP encoder DCSP type DCSP '%s'" % encoderDict['type'])) DCNL DCSP return permStr
 DCSP width = 21 DCNL DCSP encoderDictsList = [] DCNL DCSP if (options['inferenceType'] in ['NontemporalClassification', 'NontemporalMultiStep', 'TemporalMultiStep', 'MultiStep']): DCNL DCSP  DCSP classifierOnlyField = options['inferenceArgs']['predictedField'] DCNL DCSP else: DCNL DCSP  DCSP classifierOnlyField = None DCNL DCSP for fieldInfo in includedFields: DCNL DCSP  DCSP fieldName = fieldInfo['fieldName'] DCNL DCSP  DCSP fieldType = fieldInfo['fieldType'] DCNL DCSP  DCSP if (fieldType in ['float', 'int']): DCNL DCSP  DCSP  DCSP runDelta = fieldInfo.get('runDelta', False) DCNL DCSP  DCSP  DCSP if (runDelta or ('space' in fieldInfo)): DCNL DCSP  DCSP  DCSP  DCSP encoderDict = dict(type='ScalarSpaceEncoder', name=fieldName, fieldname=fieldName, n=100, w=width, clipInput=True) DCNL DCSP  DCSP  DCSP  DCSP if runDelta: DCNL DCSP  DCSP  DCSP  DCSP  DCSP encoderDict['runDelta'] = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP encoderDict = dict(type='AdaptiveScalarEncoder', name=fieldName, fieldname=fieldName, n=100, w=width, clipInput=True) DCNL DCSP  DCSP  DCSP if ('minValue' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoderDict['minval'] = fieldInfo['minValue'] DCNL DCSP  DCSP  DCSP if ('maxValue' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoderDict['maxval'] = fieldInfo['maxValue'] DCNL DCSP  DCSP  DCSP if ((('minValue' in fieldInfo) and ('maxValue' in fieldInfo)) and (encoderDict['type'] == 'AdaptiveScalarEncoder')): DCNL DCSP  DCSP  DCSP  DCSP encoderDict['type'] = 'ScalarEncoder' DCNL DCSP  DCSP  DCSP if ('encoderType' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoderDict['type'] = fieldInfo['encoderType'] DCNL DCSP  DCSP  DCSP if ('space' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoderDict['space'] = fieldInfo['space'] DCNL DCSP  DCSP  DCSP encoderDictsList.append(encoderDict) DCNL DCSP  DCSP elif (fieldType == 'string'): DCNL DCSP  DCSP  DCSP encoderDict = dict(type='SDRCategoryEncoder', name=fieldName, fieldname=fieldName, n=(100 + width), w=width) DCNL DCSP  DCSP  DCSP if ('encoderType' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoderDict['type'] = fieldInfo['encoderType'] DCNL DCSP  DCSP  DCSP encoderDictsList.append(encoderDict) DCNL DCSP  DCSP elif (fieldType == 'datetime'): DCNL DCSP  DCSP  DCSP encoderDict = dict(type='DateEncoder', name=('%s_timeOfDay' % fieldName), fieldname=fieldName, timeOfDay=(width, 1)) DCNL DCSP  DCSP  DCSP if ('encoderType' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoderDict['type'] = fieldInfo['encoderType'] DCNL DCSP  DCSP  DCSP encoderDictsList.append(encoderDict) DCNL DCSP  DCSP  DCSP encoderDict = dict(type='DateEncoder', name=('%s_dayOfWeek' % fieldName), fieldname=fieldName, dayOfWeek=(width, 1)) DCNL DCSP  DCSP  DCSP if ('encoderType' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoderDict['type'] = fieldInfo['encoderType'] DCNL DCSP  DCSP  DCSP encoderDictsList.append(encoderDict) DCNL DCSP  DCSP  DCSP encoderDict = dict(type='DateEncoder', name=('%s_weekend' % fieldName), fieldname=fieldName, weekend=width) DCNL DCSP  DCSP  DCSP if ('encoderType' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoderDict['type'] = fieldInfo['encoderType'] DCNL DCSP  DCSP  DCSP encoderDictsList.append(encoderDict) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError(("Unsupported DCSP field DCSP type DCSP '%s'" % fieldType)) DCNL DCSP  DCSP if (fieldName == classifierOnlyField): DCNL DCSP  DCSP  DCSP clEncoderDict = dict(encoderDict) DCNL DCSP  DCSP  DCSP clEncoderDict['classifierOnly'] = True DCNL DCSP  DCSP  DCSP clEncoderDict['name'] = '_classifierInput' DCNL DCSP  DCSP  DCSP encoderDictsList.append(clEncoderDict) DCNL DCSP  DCSP  DCSP if (options['inferenceArgs']['inputPredictedField'] == 'no'): DCNL DCSP  DCSP  DCSP  DCSP encoderDictsList.remove(encoderDict) DCNL DCSP if (options.get('fixedFields') is not None): DCNL DCSP  DCSP tempList = [] DCNL DCSP  DCSP for encoderDict in encoderDictsList: DCNL DCSP  DCSP  DCSP if (encoderDict['name'] in options['fixedFields']): DCNL DCSP  DCSP  DCSP  DCSP tempList.append(encoderDict) DCNL DCSP  DCSP encoderDictsList = tempList DCNL DCSP encoderSpecsList = [] DCNL DCSP permEncoderChoicesList = [] DCNL DCSP for encoderDict in encoderDictsList: DCNL DCSP  DCSP if (encoderDict['name'].find('\\') >= 0): DCNL DCSP  DCSP  DCSP raise _ExpGeneratorException("Illegal DCSP character DCSP in DCSP field: DCSP '\\'") DCNL DCSP  DCSP for c in _ILLEGAL_FIELDNAME_CHARACTERS: DCNL DCSP  DCSP  DCSP if (encoderDict['name'].find(c) >= 0): DCNL DCSP  DCSP  DCSP  DCSP raise _ExpGeneratorException(('Illegal DCSP character DCSP %s DCSP in DCSP field DCSP %r' % (c, encoderDict['name']))) DCNL DCSP  DCSP constructorStr = _generatePermEncoderStr(options, encoderDict) DCNL DCSP  DCSP encoderKey = _quoteAndEscape(encoderDict['name']) DCNL DCSP  DCSP encoderSpecsList.append(('%s: DCSP %s%s' % (encoderKey, (2 * _ONE_INDENT), pprint.pformat(encoderDict, indent=(2 * _INDENT_STEP))))) DCNL DCSP  DCSP permEncoderChoicesList.append(('%s: DCSP %s,' % (encoderKey, constructorStr))) DCNL DCSP encoderSpecsStr = ',\n DCSP  DCSP '.join(encoderSpecsList) DCNL DCSP permEncoderChoicesStr = '\n'.join(permEncoderChoicesList) DCNL DCSP permEncoderChoicesStr = _indentLines(permEncoderChoicesStr, 1, indentFirstLine=True) DCNL DCSP return (encoderSpecsStr, permEncoderChoicesStr)
 DCSP if ('inferenceType' not in options): DCNL DCSP  DCSP prediction = options.get('prediction', {InferenceType.TemporalNextStep: {'optimize': True}}) DCNL DCSP  DCSP inferenceType = None DCNL DCSP  DCSP for (infType, value) in prediction.iteritems(): DCNL DCSP  DCSP  DCSP if value['optimize']: DCNL DCSP  DCSP  DCSP  DCSP inferenceType = infType DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (inferenceType == 'temporal'): DCNL DCSP  DCSP  DCSP inferenceType = InferenceType.TemporalNextStep DCNL DCSP  DCSP if (inferenceType != InferenceType.TemporalNextStep): DCNL DCSP  DCSP  DCSP raise _ExpGeneratorException(('Unsupported DCSP inference DCSP type DCSP %s' % inferenceType)) DCNL DCSP  DCSP options['inferenceType'] = inferenceType DCNL DCSP if ('predictionField' in options): DCNL DCSP  DCSP if ('inferenceArgs' not in options): DCNL DCSP  DCSP  DCSP options['inferenceArgs'] = {'predictedField': options['predictionField']} DCNL DCSP  DCSP elif ('predictedField' not in options['inferenceArgs']): DCNL DCSP  DCSP  DCSP options['inferenceArgs']['predictedField'] = options['predictionField']
 DCSP if (propertyName not in options): DCNL DCSP  DCSP paramsSchema = schema['properties'][propertyName] DCNL DCSP  DCSP if ('default' in paramsSchema): DCNL DCSP  DCSP  DCSP options[propertyName] = paramsSchema['default'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP options[propertyName] = None
 DCSP installPath = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP schemaFilePath = os.path.join(installPath, 'experimentDescriptionSchema.json') DCNL DCSP return json.loads(open(schemaFilePath, 'r').read())
 DCSP _gExperimentDescriptionSchema = _getExperimentDescriptionSchema() DCNL DCSP try: DCNL DCSP  DCSP validictory.validate(options, _gExperimentDescriptionSchema) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise _InvalidCommandArgException((('JSON DCSP arg DCSP validation DCSP failed DCSP for DCSP option DCSP --description: DCSP ' + '%s\nOPTION DCSP ARG=%s') % (str(e), pprint.pformat(options)))) DCNL DCSP streamSchema = json.load(resource_stream(jsonschema.__name__, 'stream_def.json')) DCNL DCSP try: DCNL DCSP  DCSP validictory.validate(options['streamDef'], streamSchema) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise _InvalidCommandArgException((('JSON DCSP arg DCSP validation DCSP failed DCSP for DCSP streamDef DCSP ' + '%s\nOPTION DCSP ARG=%s') % (str(e), json.dumps(options)))) DCNL DCSP _handleJAVAParameters(options) DCNL DCSP for propertyName in _gExperimentDescriptionSchema['properties']: DCNL DCSP  DCSP _getPropertyValue(_gExperimentDescriptionSchema, propertyName, options) DCNL DCSP if (options['inferenceArgs'] is not None): DCNL DCSP  DCSP infArgs = _gExperimentDescriptionSchema['properties']['inferenceArgs'] DCNL DCSP  DCSP for schema in infArgs['type']: DCNL DCSP  DCSP  DCSP if isinstance(schema, dict): DCNL DCSP  DCSP  DCSP  DCSP for propertyName in schema['properties']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _getPropertyValue(schema, propertyName, options['inferenceArgs']) DCNL DCSP if (options['anomalyParams'] is not None): DCNL DCSP  DCSP anomalyArgs = _gExperimentDescriptionSchema['properties']['anomalyParams'] DCNL DCSP  DCSP for schema in anomalyArgs['type']: DCNL DCSP  DCSP  DCSP if isinstance(schema, dict): DCNL DCSP  DCSP  DCSP  DCSP for propertyName in schema['properties']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _getPropertyValue(schema, propertyName, options['anomalyParams']) DCNL DCSP predictionSteps = options['inferenceArgs'].get('predictionSteps', None) DCNL DCSP if (options['inferenceType'] == InferenceType.NontemporalClassification): DCNL DCSP  DCSP if ((predictionSteps is not None) and (predictionSteps != [0])): DCNL DCSP  DCSP  DCSP raise RuntimeError('When DCSP NontemporalClassification DCSP is DCSP used, DCSP prediction DCSP steps DCSP must DCSP be DCSP [0]') DCNL DCSP if ((predictionSteps == [0]) and (options['inferenceType'] in ['NontemporalMultiStep', 'TemporalMultiStep', 'MultiStep'])): DCNL DCSP  DCSP options['inferenceType'] = InferenceType.NontemporalClassification DCNL DCSP if (options['inferenceType'] == InferenceType.NontemporalClassification): DCNL DCSP  DCSP if ((options['inferenceArgs']['inputPredictedField'] == 'yes') or (options['inferenceArgs']['inputPredictedField'] == 'auto')): DCNL DCSP  DCSP  DCSP raise RuntimeError("When DCSP the DCSP inference DCSP type DCSP is DCSP NontemporalClassification DCSP inputPredictedField DCSP must DCSP be DCSP set DCSP to DCSP 'no'") DCNL DCSP  DCSP options['inferenceArgs']['inputPredictedField'] = 'no' DCNL DCSP swarmSize = options['swarmSize'] DCNL DCSP if (swarmSize is None): DCNL DCSP  DCSP if (options['inferenceArgs']['inputPredictedField'] is None): DCNL DCSP  DCSP  DCSP options['inferenceArgs']['inputPredictedField'] = 'auto' DCNL DCSP elif (swarmSize == 'small'): DCNL DCSP  DCSP if (options['minParticlesPerSwarm'] is None): DCNL DCSP  DCSP  DCSP options['minParticlesPerSwarm'] = 3 DCNL DCSP  DCSP if (options['iterationCount'] is None): DCNL DCSP  DCSP  DCSP options['iterationCount'] = 100 DCNL DCSP  DCSP if (options['maxModels'] is None): DCNL DCSP  DCSP  DCSP options['maxModels'] = 1 DCNL DCSP  DCSP if (options['inferenceArgs']['inputPredictedField'] is None): DCNL DCSP  DCSP  DCSP options['inferenceArgs']['inputPredictedField'] = 'yes' DCNL DCSP elif (swarmSize == 'medium'): DCNL DCSP  DCSP if (options['minParticlesPerSwarm'] is None): DCNL DCSP  DCSP  DCSP options['minParticlesPerSwarm'] = 5 DCNL DCSP  DCSP if (options['iterationCount'] is None): DCNL DCSP  DCSP  DCSP options['iterationCount'] = 4000 DCNL DCSP  DCSP if (options['maxModels'] is None): DCNL DCSP  DCSP  DCSP options['maxModels'] = 200 DCNL DCSP  DCSP if (options['inferenceArgs']['inputPredictedField'] is None): DCNL DCSP  DCSP  DCSP options['inferenceArgs']['inputPredictedField'] = 'auto' DCNL DCSP elif (swarmSize == 'large'): DCNL DCSP  DCSP if (options['minParticlesPerSwarm'] is None): DCNL DCSP  DCSP  DCSP options['minParticlesPerSwarm'] = 15 DCNL DCSP  DCSP options['tryAll3FieldCombinationsWTimestamps'] = True DCNL DCSP  DCSP if (options['inferenceArgs']['inputPredictedField'] is None): DCNL DCSP  DCSP  DCSP options['inferenceArgs']['inputPredictedField'] = 'auto' DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(('Unsupported DCSP swarm DCSP size: DCSP %s' % swarmSize)) DCNL DCSP tokenReplacements = dict() DCNL DCSP includedFields = options['includedFields'] DCNL DCSP if (hsVersion == 'v1'): DCNL DCSP  DCSP (encoderSpecsStr, permEncoderChoicesStr) = _generateEncoderStringsV1(includedFields) DCNL DCSP elif (hsVersion in ['v2', 'ensemble']): DCNL DCSP  DCSP (encoderSpecsStr, permEncoderChoicesStr) = _generateEncoderStringsV2(includedFields, options) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(('Unsupported DCSP hsVersion DCSP of DCSP %s' % hsVersion)) DCNL DCSP if (options['resetPeriod'] is not None): DCNL DCSP  DCSP sensorAutoResetStr = pprint.pformat(options['resetPeriod'], indent=(2 * _INDENT_STEP)) DCNL DCSP else: DCNL DCSP  DCSP sensorAutoResetStr = 'None' DCNL DCSP aggregationPeriod = {'days': 0, 'hours': 0, 'microseconds': 0, 'milliseconds': 0, 'minutes': 0, 'months': 0, 'seconds': 0, 'weeks': 0, 'years': 0} DCNL DCSP aggFunctionsDict = {} DCNL DCSP if ('aggregation' in options['streamDef']): DCNL DCSP  DCSP for key in aggregationPeriod.keys(): DCNL DCSP  DCSP  DCSP if (key in options['streamDef']['aggregation']): DCNL DCSP  DCSP  DCSP  DCSP aggregationPeriod[key] = options['streamDef']['aggregation'][key] DCNL DCSP  DCSP if ('fields' in options['streamDef']['aggregation']): DCNL DCSP  DCSP  DCSP for (fieldName, func) in options['streamDef']['aggregation']['fields']: DCNL DCSP  DCSP  DCSP  DCSP aggFunctionsDict[fieldName] = str(func) DCNL DCSP hasAggregation = False DCNL DCSP for v in aggregationPeriod.values(): DCNL DCSP  DCSP if (v != 0): DCNL DCSP  DCSP  DCSP hasAggregation = True DCNL DCSP  DCSP  DCSP break DCNL DCSP aggFunctionList = aggFunctionsDict.items() DCNL DCSP aggregationInfo = dict(aggregationPeriod) DCNL DCSP aggregationInfo['fields'] = aggFunctionList DCNL DCSP aggregationInfoStr = ('%s' % pprint.pformat(aggregationInfo, indent=(2 * _INDENT_STEP))) DCNL DCSP datasetSpec = options['streamDef'] DCNL DCSP if ('aggregation' in datasetSpec): DCNL DCSP  DCSP datasetSpec.pop('aggregation') DCNL DCSP if hasAggregation: DCNL DCSP  DCSP datasetSpec['aggregation'] = '$SUBSTITUTE' DCNL DCSP datasetSpecStr = pprint.pformat(datasetSpec, indent=(2 * _INDENT_STEP)) DCNL DCSP datasetSpecStr = datasetSpecStr.replace("'$SUBSTITUTE'", "config['aggregationInfo']") DCNL DCSP datasetSpecStr = _indentLines(datasetSpecStr, 2, indentFirstLine=False) DCNL DCSP computeInterval = options['computeInterval'] DCNL DCSP if ((computeInterval is not None) and (options['inferenceType'] in ['NontemporalMultiStep', 'TemporalMultiStep', 'MultiStep'])): DCNL DCSP  DCSP predictionSteps = options['inferenceArgs'].get('predictionSteps', [1]) DCNL DCSP  DCSP if (len(predictionSteps) > 1): DCNL DCSP  DCSP  DCSP raise _InvalidCommandArgException(('Invalid DCSP predictionSteps: DCSP %s. DCSP When DCSP computeInterval DCSP is DCSP specified, DCSP there DCSP can DCSP only DCSP be DCSP one DCSP stepSize DCSP in DCSP predictionSteps.' % predictionSteps)) DCNL DCSP  DCSP if (max(aggregationInfo.values()) == 0): DCNL DCSP  DCSP  DCSP raise _InvalidCommandArgException('Missing DCSP or DCSP nil DCSP stream DCSP aggregation: DCSP When DCSP computeInterval DCSP is DCSP specified, DCSP then DCSP the DCSP stream DCSP aggregation DCSP interval DCSP must DCSP be DCSP non-zero.') DCNL DCSP  DCSP numSteps = predictionSteps[0] DCNL DCSP  DCSP predictAheadTime = dict(aggregationPeriod) DCNL DCSP  DCSP for key in predictAheadTime.iterkeys(): DCNL DCSP  DCSP  DCSP predictAheadTime[key] *= numSteps DCNL DCSP  DCSP predictAheadTimeStr = pprint.pformat(predictAheadTime, indent=(2 * _INDENT_STEP)) DCNL DCSP  DCSP options['dynamicPredictionSteps'] = True DCNL DCSP else: DCNL DCSP  DCSP options['dynamicPredictionSteps'] = False DCNL DCSP  DCSP predictAheadTimeStr = 'None' DCNL DCSP tokenReplacements['\\$EXP_GENERATOR_PROGRAM_PATH'] = _quoteAndEscape(os.path.abspath(__file__)) DCNL DCSP inferenceType = options['inferenceType'] DCNL DCSP if (inferenceType == 'MultiStep'): DCNL DCSP  DCSP inferenceType = InferenceType.TemporalMultiStep DCNL DCSP tokenReplacements['\\$INFERENCE_TYPE'] = ("'%s'" % inferenceType) DCNL DCSP if (inferenceType == InferenceType.NontemporalClassification): DCNL DCSP  DCSP tokenReplacements['\\$SP_ENABLE'] = 'False' DCNL DCSP  DCSP tokenReplacements['\\$TP_ENABLE'] = 'False' DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$SP_ENABLE'] = 'True' DCNL DCSP  DCSP tokenReplacements['\\$TP_ENABLE'] = 'True' DCNL DCSP  DCSP tokenReplacements['\\$CLA_CLASSIFIER_IMPL'] = '' DCNL DCSP tokenReplacements['\\$ANOMALY_PARAMS'] = pprint.pformat(options['anomalyParams'], indent=(2 * _INDENT_STEP)) DCNL DCSP tokenReplacements['\\$ENCODER_SPECS'] = encoderSpecsStr DCNL DCSP tokenReplacements['\\$SENSOR_AUTO_RESET'] = sensorAutoResetStr DCNL DCSP tokenReplacements['\\$AGGREGATION_INFO'] = aggregationInfoStr DCNL DCSP tokenReplacements['\\$DATASET_SPEC'] = datasetSpecStr DCNL DCSP if (options['iterationCount'] is None): DCNL DCSP  DCSP options['iterationCount'] = (-1) DCNL DCSP tokenReplacements['\\$ITERATION_COUNT'] = str(options['iterationCount']) DCNL DCSP tokenReplacements['\\$SP_POOL_PCT'] = str(options['spCoincInputPoolPct']) DCNL DCSP tokenReplacements['\\$HS_MIN_PARTICLES'] = str(options['minParticlesPerSwarm']) DCNL DCSP tokenReplacements['\\$SP_PERM_CONNECTED'] = str(options['spSynPermConnected']) DCNL DCSP tokenReplacements['\\$FIELD_PERMUTATION_LIMIT'] = str(options['fieldPermutationLimit']) DCNL DCSP tokenReplacements['\\$PERM_ENCODER_CHOICES'] = permEncoderChoicesStr DCNL DCSP predictionSteps = options['inferenceArgs'].get('predictionSteps', [1]) DCNL DCSP predictionStepsStr = ','.join([str(x) for x in predictionSteps]) DCNL DCSP tokenReplacements['\\$PREDICTION_STEPS'] = ("'%s'" % predictionStepsStr) DCNL DCSP tokenReplacements['\\$PREDICT_AHEAD_TIME'] = predictAheadTimeStr DCNL DCSP tokenReplacements['\\$PERM_SP_CHOICES'] = '' DCNL DCSP if (options['spPermuteDecrement'] and (options['inferenceType'] != 'NontemporalClassification')): DCNL DCSP  DCSP tokenReplacements['\\$PERM_SP_CHOICES'] = (_ONE_INDENT + "'synPermInactiveDec': DCSP PermuteFloat(0.0003, DCSP 0.1),\n") DCNL DCSP if (options['inferenceType'] in ['NontemporalMultiStep', 'NontemporalClassification']): DCNL DCSP  DCSP tokenReplacements['\\$PERM_TP_CHOICES'] = '' DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_TP_CHOICES'] = ((" DCSP  DCSP 'activationThreshold': DCSP PermuteInt(12, DCSP 16),\n" + " DCSP  DCSP 'minThreshold': DCSP PermuteInt(9, DCSP 12),\n") + " DCSP  DCSP 'pamLength': DCSP PermuteInt(1, DCSP 5),\n") DCNL DCSP if (options['inferenceType'] == 'MultiStep'): DCNL DCSP  DCSP tokenReplacements['\\$PERM_INFERENCE_TYPE_CHOICES'] = (" DCSP  DCSP 'inferenceType': DCSP PermuteChoices(['NontemporalMultiStep', DCSP " + "'TemporalMultiStep']),") DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_INFERENCE_TYPE_CHOICES'] = '' DCNL DCSP if (options['inferenceType'] in ['NontemporalMultiStep', 'TemporalMultiStep', 'MultiStep', 'TemporalAnomaly', 'NontemporalClassification']): DCNL DCSP  DCSP tokenReplacements['\\$PERM_CL_CHOICES'] = " DCSP  DCSP 'alpha': DCSP PermuteFloat(0.0001, DCSP 0.1),\n" DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_CL_CHOICES'] = '' DCNL DCSP tokenReplacements['\\$PERM_ALWAYS_INCLUDE_PREDICTED_FIELD'] = ("inputPredictedField DCSP = DCSP '%s'" % options['inferenceArgs']['inputPredictedField']) DCNL DCSP if (options.get('minFieldContribution', None) is not None): DCNL DCSP  DCSP tokenReplacements['\\$PERM_MIN_FIELD_CONTRIBUTION'] = ('minFieldContribution DCSP = DCSP %d' % options['minFieldContribution']) DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_MIN_FIELD_CONTRIBUTION'] = '' DCNL DCSP if (options.get('killUselessSwarms', None) is not None): DCNL DCSP  DCSP tokenReplacements['\\$PERM_KILL_USELESS_SWARMS'] = ('killUselessSwarms DCSP = DCSP %r' % options['killUselessSwarms']) DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_KILL_USELESS_SWARMS'] = '' DCNL DCSP if (options.get('maxFieldBranching', None) is not None): DCNL DCSP  DCSP tokenReplacements['\\$PERM_MAX_FIELD_BRANCHING'] = ('maxFieldBranching DCSP = DCSP %r' % options['maxFieldBranching']) DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_MAX_FIELD_BRANCHING'] = '' DCNL DCSP if (options.get('tryAll3FieldCombinations', None) is not None): DCNL DCSP  DCSP tokenReplacements['\\$PERM_TRY_ALL_3_FIELD_COMBINATIONS'] = ('tryAll3FieldCombinations DCSP = DCSP %r' % options['tryAll3FieldCombinations']) DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_TRY_ALL_3_FIELD_COMBINATIONS'] = '' DCNL DCSP if (options.get('tryAll3FieldCombinationsWTimestamps', None) is not None): DCNL DCSP  DCSP tokenReplacements['\\$PERM_TRY_ALL_3_FIELD_COMBINATIONS_W_TIMESTAMPS'] = ('tryAll3FieldCombinationsWTimestamps DCSP = DCSP %r' % options['tryAll3FieldCombinationsWTimestamps']) DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_TRY_ALL_3_FIELD_COMBINATIONS_W_TIMESTAMPS'] = '' DCNL DCSP if (options.get('fixedFields', None) is not None): DCNL DCSP  DCSP tokenReplacements['\\$PERM_FIXED_FIELDS'] = ('fixedFields DCSP = DCSP %r' % options['fixedFields']) DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_FIXED_FIELDS'] = '' DCNL DCSP if (options.get('fastSwarmModelParams', None) is not None): DCNL DCSP  DCSP tokenReplacements['\\$PERM_FAST_SWARM_MODEL_PARAMS'] = ('fastSwarmModelParams DCSP = DCSP %r' % options['fastSwarmModelParams']) DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_FAST_SWARM_MODEL_PARAMS'] = '' DCNL DCSP if (options.get('maxModels', None) is not None): DCNL DCSP  DCSP tokenReplacements['\\$PERM_MAX_MODELS'] = ('maxModels DCSP = DCSP %r' % options['maxModels']) DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_MAX_MODELS'] = '' DCNL DCSP if options['dynamicPredictionSteps']: DCNL DCSP  DCSP debugAgg = True DCNL DCSP  DCSP quotient = aggregationDivide(computeInterval, aggregationPeriod) DCNL DCSP  DCSP (isInt, multiple) = _isInt(quotient) DCNL DCSP  DCSP if ((not isInt) or (multiple < 1)): DCNL DCSP  DCSP  DCSP raise _InvalidCommandArgException(('Invalid DCSP computeInterval: DCSP %s. DCSP computeInterval DCSP must DCSP be DCSP an DCSP integer DCSP multiple DCSP of DCSP the DCSP stream DCSP aggregation DCSP (%s).' % (computeInterval, aggregationPeriod))) DCNL DCSP  DCSP mTimesN = float(predictionSteps[0]) DCNL DCSP  DCSP possibleNs = [] DCNL DCSP  DCSP for n in xrange(1, (int(mTimesN) + 1)): DCNL DCSP  DCSP  DCSP m = (mTimesN / n) DCNL DCSP  DCSP  DCSP mInt = int(round(m)) DCNL DCSP  DCSP  DCSP if (mInt < 1): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (abs((m - mInt)) > (0.0001 * m)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP possibleNs.append(n) DCNL DCSP  DCSP if debugAgg: DCNL DCSP  DCSP  DCSP print ('All DCSP integer DCSP factors DCSP of DCSP %d DCSP are: DCSP %s' % (mTimesN, possibleNs)) DCNL DCSP  DCSP aggChoices = [] DCNL DCSP  DCSP for n in possibleNs: DCNL DCSP  DCSP  DCSP agg = dict(aggregationPeriod) DCNL DCSP  DCSP  DCSP for key in agg.iterkeys(): DCNL DCSP  DCSP  DCSP  DCSP agg[key] *= n DCNL DCSP  DCSP  DCSP quotient = aggregationDivide(computeInterval, agg) DCNL DCSP  DCSP  DCSP (isInt, multiple) = _isInt(quotient) DCNL DCSP  DCSP  DCSP if ((not isInt) or (multiple < 1)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP aggChoices.append(agg) DCNL DCSP  DCSP aggChoices = aggChoices[(-5):] DCNL DCSP  DCSP if debugAgg: DCNL DCSP  DCSP  DCSP print 'Aggregation DCSP choices DCSP that DCSP will DCSP be DCSP evaluted DCSP during DCSP swarming:' DCNL DCSP  DCSP  DCSP for agg in aggChoices: DCNL DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP ==>', agg DCNL DCSP  DCSP  DCSP print DCNL DCSP  DCSP tokenReplacements['\\$PERM_AGGREGATION_CHOICES'] = ('PermuteChoices(%s)' % pprint.pformat(aggChoices, indent=(2 * _INDENT_STEP))) DCNL DCSP else: DCNL DCSP  DCSP tokenReplacements['\\$PERM_AGGREGATION_CHOICES'] = aggregationInfoStr DCNL DCSP _generateInferenceArgs(options, tokenReplacements) DCNL DCSP _generateMetricsSubstitutions(options, tokenReplacements) DCNL DCSP environment = options['environment'] DCNL DCSP if (environment == OpfEnvironment.Nupic): DCNL DCSP  DCSP tokenReplacements['\\$ENVIRONMENT'] = ("'%s'" % OpfEnvironment.Nupic) DCNL DCSP  DCSP controlTemplate = 'nupicEnvironmentTemplate.tpl' DCNL DCSP elif (environment == OpfEnvironment.Experiment): DCNL DCSP  DCSP tokenReplacements['\\$ENVIRONMENT'] = ("'%s'" % OpfEnvironment.Experiment) DCNL DCSP  DCSP controlTemplate = 'opfExperimentTemplate.tpl' DCNL DCSP else: DCNL DCSP  DCSP raise _InvalidCommandArgException(('Invalid DCSP environment DCSP type DCSP %s' % environment)) DCNL DCSP if (outputDirPath is None): DCNL DCSP  DCSP outputDirPath = tempfile.mkdtemp() DCNL DCSP if (not os.path.exists(outputDirPath)): DCNL DCSP  DCSP os.makedirs(outputDirPath) DCNL DCSP print ('Generating DCSP experiment DCSP files DCSP in DCSP directory: DCSP %s...' % outputDirPath) DCNL DCSP descriptionPyPath = os.path.join(outputDirPath, 'description.py') DCNL DCSP _generateFileFromTemplates([claDescriptionTemplateFile, controlTemplate], descriptionPyPath, tokenReplacements) DCNL DCSP permutationsPyPath = os.path.join(outputDirPath, 'permutations.py') DCNL DCSP if (hsVersion == 'v1'): DCNL DCSP  DCSP _generateFileFromTemplates(['permutationsTemplateV1.tpl'], permutationsPyPath, tokenReplacements) DCNL DCSP elif (hsVersion == 'ensemble'): DCNL DCSP  DCSP _generateFileFromTemplates(['permutationsTemplateEnsemble.tpl'], permutationsPyPath, tokenReplacements) DCNL DCSP elif (hsVersion == 'v2'): DCNL DCSP  DCSP _generateFileFromTemplates(['permutationsTemplateV2.tpl'], permutationsPyPath, tokenReplacements) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('This DCSP permutation DCSP version DCSP is DCSP not DCSP supported DCSP yet: DCSP %s' % hsVersion)) DCNL DCSP print 'done.'
 DCSP options['loggedMetrics'] = ['.*'] DCNL DCSP (metricList, optimizeMetricLabel) = _generateMetricSpecs(options) DCNL DCSP metricListString = ',\n'.join(metricList) DCNL DCSP metricListString = _indentLines(metricListString, 2, indentFirstLine=False) DCNL DCSP permOptimizeSettingStr = ('minimize DCSP = DCSP "%s"' % optimizeMetricLabel) DCNL DCSP loggedMetricsListAsStr = ('[%s]' % ', DCSP '.join([("'%s'" % ptrn) for ptrn in options['loggedMetrics']])) DCNL DCSP tokenReplacements['\\$LOGGED_METRICS'] = loggedMetricsListAsStr DCNL DCSP tokenReplacements['\\$METRICS'] = metricListString DCNL DCSP tokenReplacements['\\$PERM_OPTIMIZE_SETTING'] = permOptimizeSettingStr
 DCSP inferenceType = options['inferenceType'] DCNL DCSP inferenceArgs = options['inferenceArgs'] DCNL DCSP predictionSteps = inferenceArgs['predictionSteps'] DCNL DCSP metricWindow = options['metricWindow'] DCNL DCSP if (metricWindow is None): DCNL DCSP  DCSP metricWindow = int(Configuration.get('nupic.opf.metricWindow')) DCNL DCSP metricSpecStrings = [] DCNL DCSP optimizeMetricLabel = '' DCNL DCSP metricSpecStrings.extend(_generateExtraMetricSpecs(options)) DCNL DCSP optimizeMetricSpec = None DCNL DCSP if options['dynamicPredictionSteps']: DCNL DCSP  DCSP assert (len(predictionSteps) == 1) DCNL DCSP  DCSP predictionSteps = ['$REPLACE_ME'] DCNL DCSP if (inferenceType in (InferenceType.TemporalNextStep, InferenceType.TemporalAnomaly, InferenceType.TemporalMultiStep, InferenceType.NontemporalMultiStep, InferenceType.NontemporalClassification, 'MultiStep')): DCNL DCSP  DCSP (predictedFieldName, predictedFieldType) = _getPredictedField(options) DCNL DCSP  DCSP isCategory = _isCategory(predictedFieldType) DCNL DCSP  DCSP metricNames = (('avg_err',) if isCategory else ('aae', 'altMAPE')) DCNL DCSP  DCSP trivialErrorMetric = ('avg_err' if isCategory else 'altMAPE') DCNL DCSP  DCSP oneGramErrorMetric = ('avg_err' if isCategory else 'altMAPE') DCNL DCSP  DCSP movingAverageBaselineName = ('moving_mode' if isCategory else 'moving_mean') DCNL DCSP  DCSP for metricName in metricNames: DCNL DCSP  DCSP  DCSP (metricSpec, metricLabel) = _generateMetricSpecString(field=predictedFieldName, inferenceElement=InferenceElement.multiStepBestPredictions, metric='multiStep', params={'errorMetric': metricName, 'window': metricWindow, 'steps': predictionSteps}, returnLabel=True) DCNL DCSP  DCSP  DCSP metricSpecStrings.append(metricSpec) DCNL DCSP  DCSP if (options['customErrorMetric'] is not None): DCNL DCSP  DCSP  DCSP metricParams = dict(options['customErrorMetric']) DCNL DCSP  DCSP  DCSP metricParams['errorMetric'] = 'custom_error_metric' DCNL DCSP  DCSP  DCSP metricParams['steps'] = predictionSteps DCNL DCSP  DCSP  DCSP if (not ('errorWindow' in metricParams)): DCNL DCSP  DCSP  DCSP  DCSP metricParams['errorWindow'] = metricWindow DCNL DCSP  DCSP  DCSP (metricSpec, metricLabel) = _generateMetricSpecString(field=predictedFieldName, inferenceElement=InferenceElement.multiStepPredictions, metric='multiStep', params=metricParams, returnLabel=True) DCNL DCSP  DCSP  DCSP metricSpecStrings.append(metricSpec) DCNL DCSP  DCSP optimizeMetricSpec = metricSpec DCNL DCSP  DCSP metricLabel = metricLabel.replace('[', '\\[') DCNL DCSP  DCSP metricLabel = metricLabel.replace(']', '\\]') DCNL DCSP  DCSP optimizeMetricLabel = metricLabel DCNL DCSP  DCSP if (options['customErrorMetric'] is not None): DCNL DCSP  DCSP  DCSP optimizeMetricLabel = '.*custom_error_metric.*' DCNL DCSP  DCSP if (options['runBaselines'] and (inferenceType != InferenceType.NontemporalClassification)): DCNL DCSP  DCSP  DCSP for steps in predictionSteps: DCNL DCSP  DCSP  DCSP  DCSP metricSpecStrings.append(_generateMetricSpecString(field=predictedFieldName, inferenceElement=InferenceElement.prediction, metric='trivial', params={'window': metricWindow, 'errorMetric': trivialErrorMetric, 'steps': steps})) DCNL DCSP  DCSP  DCSP  DCSP if isCategory: DCNL DCSP  DCSP  DCSP  DCSP  DCSP metricSpecStrings.append(_generateMetricSpecString(field=predictedFieldName, inferenceElement=InferenceElement.prediction, metric=movingAverageBaselineName, params={'window': metricWindow, 'errorMetric': 'avg_err', 'mode_window': 200, 'steps': steps})) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP metricSpecStrings.append(_generateMetricSpecString(field=predictedFieldName, inferenceElement=InferenceElement.prediction, metric=movingAverageBaselineName, params={'window': metricWindow, 'errorMetric': 'altMAPE', 'mean_window': 200, 'steps': steps})) DCNL DCSP elif (inferenceType in InferenceType.TemporalClassification): DCNL DCSP  DCSP metricName = 'avg_err' DCNL DCSP  DCSP trivialErrorMetric = 'avg_err' DCNL DCSP  DCSP oneGramErrorMetric = 'avg_err' DCNL DCSP  DCSP movingAverageBaselineName = 'moving_mode' DCNL DCSP  DCSP (optimizeMetricSpec, optimizeMetricLabel) = _generateMetricSpecString(inferenceElement=InferenceElement.classification, metric=metricName, params={'window': metricWindow}, returnLabel=True) DCNL DCSP  DCSP metricSpecStrings.append(optimizeMetricSpec) DCNL DCSP  DCSP if options['runBaselines']: DCNL DCSP  DCSP  DCSP if (inferenceType == InferenceType.TemporalClassification): DCNL DCSP  DCSP  DCSP  DCSP metricSpecStrings.append(_generateMetricSpecString(inferenceElement=InferenceElement.classification, metric='trivial', params={'window': metricWindow, 'errorMetric': trivialErrorMetric})) DCNL DCSP  DCSP  DCSP  DCSP metricSpecStrings.append(_generateMetricSpecString(inferenceElement=InferenceElement.classification, metric='two_gram', params={'window': metricWindow, 'errorMetric': oneGramErrorMetric})) DCNL DCSP  DCSP  DCSP  DCSP metricSpecStrings.append(_generateMetricSpecString(inferenceElement=InferenceElement.classification, metric=movingAverageBaselineName, params={'window': metricWindow, 'errorMetric': 'avg_err', 'mode_window': 200})) DCNL DCSP  DCSP if (not (options['customErrorMetric'] == None)): DCNL DCSP  DCSP  DCSP if (not ('errorWindow' in options['customErrorMetric'])): DCNL DCSP  DCSP  DCSP  DCSP options['customErrorMetric']['errorWindow'] = metricWindow DCNL DCSP  DCSP  DCSP optimizeMetricSpec = _generateMetricSpecString(inferenceElement=InferenceElement.classification, metric='custom', params=options['customErrorMetric']) DCNL DCSP  DCSP  DCSP optimizeMetricLabel = '.*custom_error_metric.*' DCNL DCSP  DCSP  DCSP metricSpecStrings.append(optimizeMetricSpec) DCNL DCSP if options['dynamicPredictionSteps']: DCNL DCSP  DCSP for i in range(len(metricSpecStrings)): DCNL DCSP  DCSP  DCSP metricSpecStrings[i] = metricSpecStrings[i].replace("'$REPLACE_ME'", 'predictionSteps') DCNL DCSP  DCSP optimizeMetricLabel = optimizeMetricLabel.replace("'$REPLACE_ME'", '.*') DCNL DCSP return (metricSpecStrings, optimizeMetricLabel)
 DCSP global _metricSpecSchema DCNL DCSP results = [] DCNL DCSP for metric in options['metrics']: DCNL DCSP  DCSP for propertyName in _metricSpecSchema['properties'].keys(): DCNL DCSP  DCSP  DCSP _getPropertyValue(_metricSpecSchema, propertyName, metric) DCNL DCSP  DCSP (specString, label) = _generateMetricSpecString(field=metric['field'], metric=metric['metric'], params=metric['params'], inferenceElement=metric['inferenceElement'], returnLabel=True) DCNL DCSP  DCSP if metric['logged']: DCNL DCSP  DCSP  DCSP options['loggedMetrics'].append(label) DCNL DCSP  DCSP results.append(specString) DCNL DCSP return results
 DCSP if ((not options['inferenceArgs']) or (not options['inferenceArgs']['predictedField'])): DCNL DCSP  DCSP return (None, None) DCNL DCSP predictedField = options['inferenceArgs']['predictedField'] DCNL DCSP predictedFieldInfo = None DCNL DCSP includedFields = options['includedFields'] DCNL DCSP for info in includedFields: DCNL DCSP  DCSP if (info['fieldName'] == predictedField): DCNL DCSP  DCSP  DCSP predictedFieldInfo = info DCNL DCSP  DCSP  DCSP break DCNL DCSP if (predictedFieldInfo is None): DCNL DCSP  DCSP raise ValueError(("Predicted DCSP field DCSP '%s' DCSP does DCSP not DCSP exist DCSP in DCSP included DCSP fields." % predictedField)) DCNL DCSP predictedFieldType = predictedFieldInfo['fieldType'] DCNL DCSP return (predictedField, predictedFieldType)
 DCSP inferenceType = options['inferenceType'] DCNL DCSP optionInferenceArgs = options.get('inferenceArgs', None) DCNL DCSP resultInferenceArgs = {} DCNL DCSP predictedField = _getPredictedField(options)[0] DCNL DCSP if (inferenceType in (InferenceType.TemporalNextStep, InferenceType.TemporalAnomaly)): DCNL DCSP  DCSP assert predictedField, ("Inference DCSP Type DCSP '%s' DCSP needs DCSP a DCSP predictedField DCSP specified DCSP in DCSP the DCSP inferenceArgs DCSP dictionary" % inferenceType) DCNL DCSP if optionInferenceArgs: DCNL DCSP  DCSP if options['dynamicPredictionSteps']: DCNL DCSP  DCSP  DCSP altOptionInferenceArgs = copy.deepcopy(optionInferenceArgs) DCNL DCSP  DCSP  DCSP altOptionInferenceArgs['predictionSteps'] = '$REPLACE_ME' DCNL DCSP  DCSP  DCSP resultInferenceArgs = pprint.pformat(altOptionInferenceArgs) DCNL DCSP  DCSP  DCSP resultInferenceArgs = resultInferenceArgs.replace("'$REPLACE_ME'", '[predictionSteps]') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP resultInferenceArgs = pprint.pformat(optionInferenceArgs) DCNL DCSP tokenReplacements['\\$INFERENCE_ARGS'] = resultInferenceArgs DCNL DCSP tokenReplacements['\\$PREDICTION_FIELD'] = predictedField
 DCSP parser = OptionParser() DCNL DCSP parser.set_usage((("%prog DCSP [options] DCSP --description='{json DCSP object DCSP with DCSP args}'\n" + "%prog DCSP [options] DCSP --descriptionFromFile='{filename}'\n") + '%prog DCSP [options] DCSP --showSchema')) DCNL DCSP parser.add_option('--description', dest='description', help='Tells DCSP ExpGenerator DCSP to DCSP generate DCSP an DCSP experiment DCSP description.py DCSP and DCSP permutations.py DCSP file DCSP using DCSP the DCSP given DCSP JSON DCSP formatted DCSP experiment DCSP description DCSP string.') DCNL DCSP parser.add_option('--descriptionFromFile', dest='descriptionFromFile', help="Tells DCSP ExpGenerator DCSP to DCSP open DCSP the DCSP given DCSP filename DCSP and DCSP use DCSP it's DCSP contents DCSP as DCSP the DCSP JSON DCSP formatted DCSP experiment DCSP description.") DCNL DCSP parser.add_option('--claDescriptionTemplateFile', dest='claDescriptionTemplateFile', default='claDescriptionTemplate.tpl', help='The DCSP file DCSP containing DCSP the DCSP template DCSP description DCSP file DCSP for DCSP  DCSP ExpGenerator DCSP [default: DCSP %default]') DCNL DCSP parser.add_option('--showSchema', action='store_true', dest='showSchema', help='Prints DCSP the DCSP JSON DCSP schemas DCSP for DCSP the DCSP --description DCSP arg.') DCNL DCSP parser.add_option('--version', dest='version', default='v2', help="Generate DCSP the DCSP permutations DCSP file DCSP for DCSP this DCSP version DCSP of DCSP hypersearch. DCSP Possible DCSP choices DCSP are DCSP 'v1' DCSP and DCSP 'v2' DCSP [default: DCSP %default].") DCNL DCSP parser.add_option('--outDir', dest='outDir', default=None, help='Where DCSP to DCSP generate DCSP experiment. DCSP If DCSP not DCSP specified, DCSP then DCSP a DCSP temp DCSP directory DCSP will DCSP be DCSP created') DCNL DCSP (options, remainingArgs) = parser.parse_args(args) DCNL DCSP if (len(remainingArgs) > 0): DCNL DCSP  DCSP raise _InvalidCommandArgException(_makeUsageErrorStr(('Unexpected DCSP command-line DCSP args: DCSP <%s>' % (' DCSP '.join(remainingArgs),)), parser.get_usage())) DCNL DCSP activeOptions = filter((lambda x: (getattr(options, x) != None)), ('description', 'showSchema')) DCNL DCSP if (len(activeOptions) > 1): DCNL DCSP  DCSP raise _InvalidCommandArgException(_makeUsageErrorStr((('The DCSP specified DCSP command DCSP options DCSP are DCSP ' + 'mutually-exclusive: DCSP %s') % (activeOptions,)), parser.get_usage())) DCNL DCSP if options.showSchema: DCNL DCSP  DCSP _handleShowSchemaOption() DCNL DCSP elif options.description: DCNL DCSP  DCSP _handleDescriptionOption(options.description, options.outDir, parser.get_usage(), hsVersion=options.version, claDescriptionTemplateFile=options.claDescriptionTemplateFile) DCNL DCSP elif options.descriptionFromFile: DCNL DCSP  DCSP _handleDescriptionFromFileOption(options.descriptionFromFile, options.outDir, parser.get_usage(), hsVersion=options.version, claDescriptionTemplateFile=options.claDescriptionTemplateFile) DCNL DCSP else: DCNL DCSP  DCSP raise _InvalidCommandArgException(_makeUsageErrorStr('Error DCSP in DCSP validating DCSP command DCSP options. DCSP No DCSP option DCSP provided:\n', parser.get_usage()))
 DCSP parser = OptionParser(helpString) DCNL DCSP parser.add_option('--jobID', action='store', type='int', default=None, help='jobID DCSP of DCSP the DCSP job DCSP within DCSP the DCSP dbTable DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--modelID', action='store', type='str', default=None, help='Tell DCSP worker DCSP to DCSP re-run DCSP this DCSP model DCSP ID. DCSP When DCSP specified, DCSP jobID DCSP must DCSP also DCSP be DCSP specified DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--workerID', action='store', type='str', default=None, help="workerID DCSP of DCSP the DCSP scheduler's DCSP SlotAgent DCSP (GenericWorker) DCSP that DCSP hosts DCSP this DCSP SpecializedWorker DCSP [default: DCSP %default].") DCNL DCSP parser.add_option('--params', action='store', default=None, help='Create DCSP and DCSP execute DCSP a DCSP new DCSP hypersearch DCSP request DCSP using DCSP this DCSP JSON DCSP format DCSP params DCSP string. DCSP This DCSP is DCSP helpful DCSP for DCSP unit DCSP tests DCSP and DCSP debugging. DCSP When DCSP specified DCSP jobID DCSP must DCSP NOT DCSP be DCSP specified. DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--clearModels', action='store_true', default=False, help='clear DCSP out DCSP the DCSP models DCSP table DCSP before DCSP starting DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--resetJobStatus', action='store_true', default=False, help='Reset DCSP the DCSP job DCSP status DCSP before DCSP starting DCSP  DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--logLevel', action='store', type='int', default=None, help='override DCSP default DCSP log DCSP level. DCSP Pass DCSP in DCSP an DCSP integer DCSP value DCSP that DCSP represents DCSP the DCSP desired DCSP logging DCSP level DCSP (10=logging.DEBUG, DCSP 20=logging.INFO, DCSP etc.) DCSP [default: DCSP %default].') DCNL DCSP (options, args) = parser.parse_args(argv[1:]) DCNL DCSP if (len(args) != 0): DCNL DCSP  DCSP raise RuntimeError(('Expected DCSP no DCSP command DCSP line DCSP arguments, DCSP but DCSP got: DCSP %s' % args)) DCNL DCSP if (options.jobID and options.params): DCNL DCSP  DCSP raise RuntimeError('--jobID DCSP and DCSP --params DCSP can DCSP not DCSP be DCSP used DCSP at DCSP the DCSP same DCSP time') DCNL DCSP if ((options.jobID is None) and (options.params is None)): DCNL DCSP  DCSP raise RuntimeError('Either DCSP --jobID DCSP or DCSP --params DCSP must DCSP be DCSP specified.') DCNL DCSP initLogging(verbose=True) DCNL DCSP hst = HypersearchWorker(options, argv[1:]) DCNL DCSP if (options.params is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP jobID = hst.run() DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP jobID = options.jobID DCNL DCSP  DCSP  DCSP msg = StringIO.StringIO() DCNL DCSP  DCSP  DCSP print >>msg, ('%s: DCSP Exception DCSP occurred DCSP in DCSP Hypersearch DCSP Worker: DCSP %r' % (ErrorCodes.hypersearchLogicErr, e)) DCNL DCSP  DCSP  DCSP traceback.print_exc(None, msg) DCNL DCSP  DCSP  DCSP completionReason = ClientJobsDAO.CMPL_REASON_ERROR DCNL DCSP  DCSP  DCSP completionMsg = msg.getvalue() DCNL DCSP  DCSP  DCSP hst.logger.error(completionMsg) DCNL DCSP  DCSP  DCSP jobsDAO = ClientJobsDAO.get() DCNL DCSP  DCSP  DCSP workerCmpReason = jobsDAO.jobGetFields(options.jobID, ['workerCompletionReason'])[0] DCNL DCSP  DCSP  DCSP if (workerCmpReason == ClientJobsDAO.CMPL_REASON_SUCCESS): DCNL DCSP  DCSP  DCSP  DCSP jobsDAO.jobSetFields(options.jobID, fields=dict(cancel=True, workerCompletionReason=ClientJobsDAO.CMPL_REASON_ERROR, workerCompletionMsg=completionMsg), useConnectionID=False, ignoreUnchanged=True) DCNL DCSP else: DCNL DCSP  DCSP jobID = None DCNL DCSP  DCSP completionReason = ClientJobsDAO.CMPL_REASON_SUCCESS DCNL DCSP  DCSP completionMsg = 'Success' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP jobID = hst.run() DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP jobID = hst._options.jobID DCNL DCSP  DCSP  DCSP completionReason = ClientJobsDAO.CMPL_REASON_ERROR DCNL DCSP  DCSP  DCSP completionMsg = ('ERROR: DCSP %s' % (e,)) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP if (jobID is not None): DCNL DCSP  DCSP  DCSP  DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP  DCSP  DCSP  DCSP cjDAO.jobSetCompleted(jobID=jobID, completionReason=completionReason, completionMsg=completionMsg) DCNL DCSP return jobID
 DCSP lines = [l.rstrip() for l in s.split('\n')] DCNL DCSP return '\n'.join(lines)
 DCSP def getLabel(cls, val): DCNL DCSP  DCSP ' DCSP Get DCSP a DCSP string DCSP label DCSP for DCSP the DCSP current DCSP value DCSP of DCSP the DCSP enum DCSP ' DCNL DCSP  DCSP return cls.__labels[val] DCNL DCSP def validate(cls, val): DCNL DCSP  DCSP ' DCSP Returns DCSP True DCSP if DCSP val DCSP is DCSP a DCSP valid DCSP value DCSP for DCSP the DCSP enumeration DCSP ' DCNL DCSP  DCSP return (val in cls.__values) DCNL DCSP def getValues(cls): DCNL DCSP  DCSP ' DCSP Returns DCSP a DCSP list DCSP of DCSP all DCSP the DCSP possible DCSP values DCSP for DCSP this DCSP enum DCSP ' DCNL DCSP  DCSP return list(cls.__values) DCNL DCSP def getLabels(cls): DCNL DCSP  DCSP ' DCSP Returns DCSP a DCSP list DCSP of DCSP all DCSP possible DCSP labels DCSP for DCSP this DCSP enum DCSP ' DCNL DCSP  DCSP return list(cls.__labels.values()) DCNL DCSP def getValue(cls, label): DCNL DCSP  DCSP ' DCSP Returns DCSP value DCSP given DCSP a DCSP label DCSP ' DCNL DCSP  DCSP return cls.__labels[label] DCNL DCSP for arg in (list(args) + kwargs.keys()): DCNL DCSP  DCSP if (type(arg) is not str): DCNL DCSP  DCSP  DCSP raise TypeError('Enum DCSP arg DCSP {0} DCSP must DCSP be DCSP a DCSP string'.format(arg)) DCNL DCSP  DCSP if (not __isidentifier(arg)): DCNL DCSP  DCSP  DCSP raise ValueError("Invalid DCSP enum DCSP value DCSP '{0}'. DCSP '{0}' DCSP is DCSP not DCSP a DCSP valid DCSP identifier".format(arg)) DCNL DCSP kwargs.update(zip(args, args)) DCNL DCSP newType = type('Enum', (object,), kwargs) DCNL DCSP newType.__labels = dict(((v, k) for (k, v) in kwargs.iteritems())) DCNL DCSP newType.__values = set(newType.__labels.keys()) DCNL DCSP newType.getLabel = functools.partial(getLabel, newType) DCNL DCSP newType.validate = functools.partial(validate, newType) DCNL DCSP newType.getValues = functools.partial(getValues, newType) DCNL DCSP newType.getLabels = functools.partial(getLabels, newType) DCNL DCSP newType.getValue = functools.partial(getValue, newType) DCNL DCSP return newType
 DCSP assert os.path.isabs(absDirPath) DCNL DCSP try: DCNL DCSP  DCSP os.makedirs(absDirPath) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno != os.errno.EEXIST): DCNL DCSP  DCSP  DCSP raise DCNL DCSP return absDirPath
 DCSP if (minimumWorkers is None): DCNL DCSP  DCSP minimumWorkers = Configuration.getInt('nupic.hypersearch.minWorkersPerSwarm') DCNL DCSP if (maximumWorkers is None): DCNL DCSP  DCSP maximumWorkers = Configuration.getInt('nupic.hypersearch.maxWorkersPerSwarm') DCNL DCSP return ClientJobsDAO.get().jobInsert(client=client, cmdLine='$HYPERSEARCH', clientInfo=clientInfo, clientKey=clientKey, alreadyRunning=alreadyRunning, params=params, minimumWorkers=minimumWorkers, maximumWorkers=maximumWorkers, jobType=ClientJobsDAO.JOB_TYPE_HS)
 DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP (jobID, description) = cjDAO.modelsGetFields(modelID, ['jobId', 'genDescription']) DCNL DCSP (baseDescription,) = cjDAO.jobGetFields(jobID, ['genBaseDescription']) DCNL DCSP descriptionDirectory = tempfile.mkdtemp() DCNL DCSP try: DCNL DCSP  DCSP baseDescriptionFilePath = os.path.join(descriptionDirectory, 'base.py') DCNL DCSP  DCSP with open(baseDescriptionFilePath, mode='wb') as f: DCNL DCSP  DCSP  DCSP f.write(baseDescription) DCNL DCSP  DCSP descriptionFilePath = os.path.join(descriptionDirectory, 'description.py') DCNL DCSP  DCSP with open(descriptionFilePath, mode='wb') as f: DCNL DCSP  DCSP  DCSP f.write(description) DCNL DCSP  DCSP expIface = helpers.getExperimentDescriptionInterfaceFromModule(helpers.loadExperimentDescriptionScriptFromDir(descriptionDirectory)) DCNL DCSP  DCSP return json.dumps(dict(modelConfig=expIface.getModelDescription(), inferenceArgs=expIface.getModelControl().get('inferenceArgs', None))) DCNL DCSP finally: DCNL DCSP  DCSP shutil.rmtree(descriptionDirectory, ignore_errors=True)
 DCSP assert isinstance(s, str), ('expected DCSP %s DCSP but DCSP got DCSP %s; DCSP value=%s' % (type(str), type(s), s)) DCNL DCSP s = s.replace('\\', '\\\\') DCNL DCSP s = s.replace('\n', '\\n') DCNL DCSP s = s.replace(' DCTB ', '\\t') DCNL DCSP s = s.replace(',', ' DCTB ') DCNL DCSP return s
 DCSP process = subprocess.Popen(['ps', 'aux'], stdout=subprocess.PIPE) DCNL DCSP stdout = process.communicate()[0] DCNL DCSP result = process.returncode DCNL DCSP if (result != 0): DCNL DCSP  DCSP raise RuntimeError('Unable DCSP to DCSP check DCSP for DCSP running DCSP client DCSP job DCSP manager') DCNL DCSP running = False DCNL DCSP for line in stdout.split('\n'): DCNL DCSP  DCSP if (('python' in line) and ('clientjobmanager.client_job_manager' in line)): DCNL DCSP  DCSP  DCSP running = True DCNL DCSP  DCSP  DCSP break DCNL DCSP return running
 DCSP global g_currentVerbosityLevel DCNL DCSP g_currentVerbosityLevel = verbosity DCNL DCSP if (outDir is None): DCNL DCSP  DCSP outDir = os.getcwd() DCNL DCSP if (permWorkDir is None): DCNL DCSP  DCSP permWorkDir = os.getcwd() DCNL DCSP _checkOverwrite(options, outDir) DCNL DCSP _generateExpFilesFromSwarmDescription(swarmConfig, outDir) DCNL DCSP options['expDescConfig'] = swarmConfig DCNL DCSP options['outputLabel'] = outputLabel DCNL DCSP options['outDir'] = outDir DCNL DCSP options['permWorkDir'] = permWorkDir DCNL DCSP runOptions = _injectDefaultOptions(options) DCNL DCSP _validateOptions(runOptions) DCNL DCSP return _runAction(runOptions)
 DCSP if ('verbosityCount' in options): DCNL DCSP  DCSP verbosity = options['verbosityCount'] DCNL DCSP  DCSP del options['verbosityCount'] DCNL DCSP else: DCNL DCSP  DCSP verbosity = 1 DCNL DCSP _setupInterruptHandling() DCNL DCSP with open(expJsonFilePath, 'r') as jsonFile: DCNL DCSP  DCSP expJsonConfig = json.loads(jsonFile.read()) DCNL DCSP outDir = os.path.dirname(expJsonFilePath) DCNL DCSP return runWithConfig(expJsonConfig, options, outDir=outDir, outputLabel=outputLabel, permWorkDir=permWorkDir, verbosity=verbosity)
 DCSP global g_currentVerbosityLevel DCNL DCSP if ('verbosityCount' in options): DCNL DCSP  DCSP g_currentVerbosityLevel = options['verbosityCount'] DCNL DCSP  DCSP del options['verbosityCount'] DCNL DCSP else: DCNL DCSP  DCSP g_currentVerbosityLevel = 1 DCNL DCSP _setupInterruptHandling() DCNL DCSP options['permutationsScriptPath'] = permutationsFilePath DCNL DCSP options['outputLabel'] = outputLabel DCNL DCSP options['outDir'] = permWorkDir DCNL DCSP options['permWorkDir'] = permWorkDir DCNL DCSP runOptions = _injectDefaultOptions(options) DCNL DCSP _validateOptions(runOptions) DCNL DCSP return _runAction(runOptions)
 DCSP raise DeprecationWarning('nupic.swarming.permutations_runner.runPermutations() DCSP is DCSP no DCSP longer DCSP implemented. DCSP It DCSP has DCSP been DCSP replaced DCSP with DCSP a DCSP simpler DCSP function DCSP for DCSP library DCSP usage: DCSP nupic.swarming.permutations_runner.runWithConfig(). DCSP See DCSP docs DCSP at DCSP http://nupic.docs.numenta.org/0.7.0.dev0/guides/swarming/running.htmlprogrammatically DCSP for DCSP details.')
 DCSP return cjdao.ClientJobsDAO.get()
 DCSP return False
 DCSP assert os.path.exists(filePath) DCNL DCSP stampNum = 0 DCNL DCSP (prefix, suffix) = os.path.splitext(filePath) DCNL DCSP while True: DCNL DCSP  DCSP backupPath = ('%s.%d%s' % (prefix, stampNum, suffix)) DCNL DCSP  DCSP stampNum += 1 DCNL DCSP  DCSP if (not os.path.exists(backupPath)): DCNL DCSP  DCSP  DCSP break DCNL DCSP shutil.copyfile(filePath, backupPath) DCNL DCSP return backupPath
 DCSP return _iterModels([nupicModelID]).next()
 DCSP class ModelInfoIterator(object, ): DCNL DCSP  DCSP 'ModelInfo DCSP iterator DCSP implementation DCSP class\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP __CACHE_LIMIT = 1000 DCNL DCSP  DCSP debug = False DCNL DCSP  DCSP def __init__(self, modelIDs): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parameters:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ----------------------------------------------------------------------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP modelIDs: DCSP  DCSP  DCSP  DCSP  DCSP a DCSP sequence DCSP of DCSP Nupic DCSP model DCSP identifiers DCSP for DCSP which DCSP this\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iterator DCSP will DCSP return DCSP _NupicModelInfo DCSP instances.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP NOTE: DCSP The DCSP returned DCSP instances DCSP are DCSP NOT DCSP guaranteed DCSP to DCSP be DCSP in\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP same DCSP order DCSP as DCSP the DCSP IDs DCSP in DCSP modelIDs DCSP sequence.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nothing\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP self.__modelIDs = tuple(modelIDs) DCNL DCSP  DCSP  DCSP if self.debug: DCNL DCSP  DCSP  DCSP  DCSP _emit(Verbosity.DEBUG, ('MODELITERATOR: DCSP __init__; DCSP numModelIDs=%s' % len(self.__modelIDs))) DCNL DCSP  DCSP  DCSP self.__nextIndex = 0 DCNL DCSP  DCSP  DCSP self.__modelCache = collections.deque() DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP def __iter__(self): DCNL DCSP  DCSP  DCSP 'Iterator DCSP Protocol DCSP function\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parameters:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ----------------------------------------------------------------------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP return self DCNL DCSP  DCSP def next(self): DCNL DCSP  DCSP  DCSP 'Iterator DCSP Protocol DCSP function\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parameters:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ----------------------------------------------------------------------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP A DCSP _NupicModelInfo DCSP instance DCSP or DCSP raises DCSP StopIteration DCSP to\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP signal DCSP end DCSP of DCSP iteration.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP return self.__getNext() DCNL DCSP  DCSP def __getNext(self): DCNL DCSP  DCSP  DCSP 'Implementation DCSP of DCSP the DCSP next() DCSP Iterator DCSP Protocol DCSP function.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP When DCSP the DCSP modelInfo DCSP cache DCSP becomes DCSP empty, DCSP queries DCSP Nupic DCSP and DCSP fills DCSP the DCSP cache\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with DCSP the DCSP next DCSP set DCSP of DCSP NupicModelInfo DCSP instances.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parameters:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ----------------------------------------------------------------------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP A DCSP _NupicModelInfo DCSP instance DCSP or DCSP raises DCSP StopIteration DCSP to\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP signal DCSP end DCSP of DCSP iteration.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP if self.debug: DCNL DCSP  DCSP  DCSP  DCSP _emit(Verbosity.DEBUG, ('MODELITERATOR: DCSP __getNext(); DCSP modelCacheLen=%s' % len(self.__modelCache))) DCNL DCSP  DCSP  DCSP if (not self.__modelCache): DCNL DCSP  DCSP  DCSP  DCSP self.__fillCache() DCNL DCSP  DCSP  DCSP if (not self.__modelCache): DCNL DCSP  DCSP  DCSP  DCSP raise StopIteration() DCNL DCSP  DCSP  DCSP return self.__modelCache.popleft() DCNL DCSP  DCSP def __fillCache(self): DCNL DCSP  DCSP  DCSP 'Queries DCSP Nupic DCSP and DCSP fills DCSP an DCSP empty DCSP modelInfo DCSP cache DCSP with DCSP the DCSP next DCSP set DCSP of\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _NupicModelInfo DCSP instances\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parameters:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ----------------------------------------------------------------------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nothing\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP assert (not self.__modelCache) DCNL DCSP  DCSP  DCSP numModelIDs = (len(self.__modelIDs) if self.__modelIDs else 0) DCNL DCSP  DCSP  DCSP if (self.__nextIndex >= numModelIDs): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP idRange = (self.__nextIndex + self.__CACHE_LIMIT) DCNL DCSP  DCSP  DCSP if (idRange > numModelIDs): DCNL DCSP  DCSP  DCSP  DCSP idRange = numModelIDs DCNL DCSP  DCSP  DCSP lookupIDs = self.__modelIDs[self.__nextIndex:idRange] DCNL DCSP  DCSP  DCSP self.__nextIndex += (idRange - self.__nextIndex) DCNL DCSP  DCSP  DCSP infoList = _clientJobsDB().modelsInfo(lookupIDs) DCNL DCSP  DCSP  DCSP assert (len(infoList) == len(lookupIDs)), ('modelsInfo DCSP returned DCSP %s DCSP elements; DCSP expected DCSP %s.' % (len(infoList), len(lookupIDs))) DCNL DCSP  DCSP  DCSP for rawInfo in infoList: DCNL DCSP  DCSP  DCSP  DCSP modelInfo = _NupicModelInfo(rawInfo=rawInfo) DCNL DCSP  DCSP  DCSP  DCSP self.__modelCache.append(modelInfo) DCNL DCSP  DCSP  DCSP assert (len(self.__modelCache) == len(lookupIDs)), ('Added DCSP %s DCSP elements DCSP to DCSP modelCache; DCSP expected DCSP %s.' % (len(self.__modelCache), len(lookupIDs))) DCNL DCSP  DCSP  DCSP if self.debug: DCNL DCSP  DCSP  DCSP  DCSP _emit(Verbosity.DEBUG, ('MODELITERATOR: DCSP Leaving DCSP __fillCache(); DCSP modelCacheLen=%s' % (len(self.__modelCache),))) DCNL DCSP return ModelInfoIterator(modelIDs)
 DCSP assert isinstance(htmPredictionModel, HTMPredictionModel) DCNL DCSP htmPredictionModel._getSPRegion().setParameter('learningMode', True) DCNL DCSP return
 DCSP assert isinstance(htmPredictionModel, HTMPredictionModel) DCNL DCSP htmPredictionModel._getSPRegion().setParameter('learningMode', False) DCNL DCSP return
 DCSP assert isinstance(htmPredictionModel, HTMPredictionModel) DCNL DCSP htmPredictionModel._getTPRegion().setParameter('learningMode', True) DCNL DCSP return
 DCSP assert isinstance(htmPredictionModel, HTMPredictionModel) DCNL DCSP htmPredictionModel._getTPRegion().setParameter('learningMode', False) DCNL DCSP return
 DCSP print '*Testing DCSP Multistep DCSP temporal DCSP shift*...' DCNL DCSP from nupic.data.field_meta import FieldMetaInfo, FieldMetaType, FieldMetaSpecial DCNL DCSP from nupic.frameworks.opf.metrics import MetricSpec DCNL DCSP from nupic.frameworks.opf.opf_utils import ModelResult, SensorInput DCNL DCSP onlineMetrics = () DCNL DCSP modelFieldMetaInfo = (FieldMetaInfo(name='consumption', type=FieldMetaType.float, special=FieldMetaSpecial.none),) DCNL DCSP mgr = MetricsManager(metricSpecs=onlineMetrics, fieldInfo=modelFieldMetaInfo, inferenceType=InferenceType.TemporalMultiStep) DCNL DCSP groundTruths = [{'consumption': i} for i in range(10)] DCNL DCSP oneStepInfs = reversed(range(10)) DCNL DCSP threeStepInfs = range(5, 15) DCNL DCSP for (iterNum, gt, os, ts) in zip(xrange(10), groundTruths, oneStepInfs, threeStepInfs): DCNL DCSP  DCSP inferences = {InferenceElement.multiStepPredictions: {1: os, 3: ts}} DCNL DCSP  DCSP sensorInput = SensorInput(dataDict=[gt]) DCNL DCSP  DCSP result = ModelResult(sensorInput=sensorInput, inferences=inferences) DCNL DCSP  DCSP mgr.update(result) DCNL DCSP  DCSP assert (mgr._getGroundTruth(InferenceElement.multiStepPredictions)[0] == gt) DCNL DCSP  DCSP if (iterNum < 1): DCNL DCSP  DCSP  DCSP assert (mgr._getInference(InferenceElement.multiStepPredictions)[1] is None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP prediction = mgr._getInference(InferenceElement.multiStepPredictions)[1] DCNL DCSP  DCSP  DCSP assert (prediction == (10 - iterNum)) DCNL DCSP  DCSP if (iterNum < 3): DCNL DCSP  DCSP  DCSP inference = mgr._getInference(InferenceElement.multiStepPredictions) DCNL DCSP  DCSP  DCSP assert ((inference is None) or (inference[3] is None)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP prediction = mgr._getInference(InferenceElement.multiStepPredictions)[3] DCNL DCSP  DCSP  DCSP assert (prediction == (iterNum + 2))
 DCSP metricName = metricSpec.metric DCNL DCSP if (metricName == 'rmse'): DCNL DCSP  DCSP return MetricRMSE(metricSpec) DCNL DCSP if (metricName == 'nrmse'): DCNL DCSP  DCSP return MetricNRMSE(metricSpec) DCNL DCSP elif (metricName == 'aae'): DCNL DCSP  DCSP return MetricAAE(metricSpec) DCNL DCSP elif (metricName == 'acc'): DCNL DCSP  DCSP return MetricAccuracy(metricSpec) DCNL DCSP elif (metricName == 'avg_err'): DCNL DCSP  DCSP return MetricAveError(metricSpec) DCNL DCSP elif (metricName == 'trivial'): DCNL DCSP  DCSP return MetricTrivial(metricSpec) DCNL DCSP elif (metricName == 'two_gram'): DCNL DCSP  DCSP return MetricTwoGram(metricSpec) DCNL DCSP elif (metricName == 'moving_mean'): DCNL DCSP  DCSP return MetricMovingMean(metricSpec) DCNL DCSP elif (metricName == 'moving_mode'): DCNL DCSP  DCSP return MetricMovingMode(metricSpec) DCNL DCSP elif (metricName == 'neg_auc'): DCNL DCSP  DCSP return MetricNegAUC(metricSpec) DCNL DCSP elif (metricName == 'custom_error_metric'): DCNL DCSP  DCSP return CustomErrorMetric(metricSpec) DCNL DCSP elif (metricName == 'multiStep'): DCNL DCSP  DCSP return MetricMultiStep(metricSpec) DCNL DCSP elif (metricName == 'multiStepProbability'): DCNL DCSP  DCSP return MetricMultiStepProbability(metricSpec) DCNL DCSP elif (metricName == 'ms_aae'): DCNL DCSP  DCSP return MetricMultiStepAAE(metricSpec) DCNL DCSP elif (metricName == 'ms_avg_err'): DCNL DCSP  DCSP return MetricMultiStepAveError(metricSpec) DCNL DCSP elif (metricName == 'passThruPrediction'): DCNL DCSP  DCSP return MetricPassThruPrediction(metricSpec) DCNL DCSP elif (metricName == 'altMAPE'): DCNL DCSP  DCSP return MetricAltMAPE(metricSpec) DCNL DCSP elif (metricName == 'MAPE'): DCNL DCSP  DCSP return MetricMAPE(metricSpec) DCNL DCSP elif (metricName == 'multi'): DCNL DCSP  DCSP return MetricMulti(metricSpec) DCNL DCSP elif (metricName == 'negativeLogLikelihood'): DCNL DCSP  DCSP return MetricNegativeLogLikelihood(metricSpec) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unsupported DCSP metric DCSP type: DCSP %s' % metricName))
 DCSP opt = _parseCommandLineOptions(args) DCNL DCSP model = _runExperimentImpl(opt, model) DCNL DCSP return model
 DCSP seed = 42 DCNL DCSP random.seed(seed) DCNL DCSP numpy.random.seed(seed)
 DCSP usageStr = '%prog DCSP [options] DCSP descriptionPyDirectory\nThis DCSP script DCSP runs DCSP a DCSP single DCSP OPF DCSP Model DCSP described DCSP by DCSP description.py DCSP located DCSP in DCSP the DCSP given DCSP directory.' DCNL DCSP parser = optparse.OptionParser(usage=usageStr) DCNL DCSP parser.add_option('-c', help="Create DCSP a DCSP model DCSP and DCSP save DCSP it DCSP under DCSP the DCSP given DCSP <CHECKPOINT> DCSP name, DCSP but DCSP don't DCSP run DCSP it", dest='createCheckpointName', action='store', type='string', default='', metavar='<CHECKPOINT>') DCNL DCSP parser.add_option('--listCheckpoints', help='List DCSP all DCSP available DCSP checkpoints', dest='listAvailableCheckpoints', action='store_true', default=False) DCNL DCSP parser.add_option('--listTasks', help='List DCSP all DCSP task DCSP labels DCSP in DCSP description.py', dest='listTasks', action='store_true', default=False) DCNL DCSP parser.add_option('--load', help='Load DCSP a DCSP model DCSP from DCSP the DCSP given DCSP <CHECKPOINT> DCSP and DCSP run DCSP it. DCSP Run DCSP with DCSP --listCheckpoints DCSP flag DCSP for DCSP more DCSP details. DCSP ', dest='runCheckpointName', action='store', type='string', default='', metavar='<CHECKPOINT>') DCNL DCSP parser.add_option('--newSerialization', help='Use DCSP new DCSP capnproto DCSP serialization', dest='newSerialization', action='store_true', default=False) DCNL DCSP parser.add_option('--tasks', help="Run DCSP the DCSP tasks DCSP with DCSP the DCSP given DCSP TASK DCSP LABELS DCSP in DCSP the DCSP order DCSP they DCSP are DCSP given. DCSP  DCSP Either DCSP end DCSP of DCSP arg-list, DCSP or DCSP a DCSP standalone DCSP dot DCSP ('.') DCSP arg DCSP or DCSP the DCSP next DCSP short DCSP or DCSP long DCSP option DCSP name DCSP (-a DCSP or DCSP --blah) DCSP terminates DCSP the DCSP list. DCSP NOTE: DCSP FAILS DCSP TO DCSP RECOGNIZE DCSP task DCSP label DCSP names DCSP with DCSP one DCSP or DCSP more DCSP leading DCSP dashes. DCSP [default: DCSP run DCSP all DCSP of DCSP the DCSP tasks DCSP in DCSP description.py]", dest='taskLabels', default=[], action='callback', callback=reapVarArgsCallback, metavar='TASK_LABELS') DCNL DCSP parser.add_option('--testMode', help='Reduce DCSP iteration DCSP count DCSP for DCSP testing', dest='testMode', action='store_true', default=False) DCNL DCSP parser.add_option('--noCheckpoint', help="Don't DCSP checkpoint DCSP the DCSP model DCSP after DCSP running DCSP each DCSP task.", dest='checkpointModel', action='store_false', default=True) DCNL DCSP (options, experiments) = parser.parse_args(args) DCNL DCSP mutuallyExclusiveOptionCount = sum([bool(options.createCheckpointName), options.listAvailableCheckpoints, options.listTasks, bool(options.runCheckpointName)]) DCNL DCSP if (mutuallyExclusiveOptionCount > 1): DCNL DCSP  DCSP _reportCommandLineUsageErrorAndExit(parser, 'Options: DCSP -c, DCSP --listCheckpoints, DCSP --listTasks, DCSP and DCSP --load DCSP are DCSP mutually DCSP exclusive. DCSP Please DCSP select DCSP only DCSP one') DCNL DCSP mutuallyExclusiveOptionCount = sum([bool((not options.checkpointModel)), bool(options.createCheckpointName)]) DCNL DCSP if (mutuallyExclusiveOptionCount > 1): DCNL DCSP  DCSP _reportCommandLineUsageErrorAndExit(parser, 'Options: DCSP -c DCSP and DCSP --noCheckpoint DCSP are DCSP mutually DCSP exclusive. DCSP Please DCSP select DCSP only DCSP one') DCNL DCSP if (len(experiments) != 1): DCNL DCSP  DCSP _reportCommandLineUsageErrorAndExit(parser, ('Exactly DCSP ONE DCSP experiment DCSP must DCSP be DCSP specified, DCSP but DCSP got DCSP %s DCSP (%s)' % (len(experiments), experiments))) DCNL DCSP parser.destroy() DCNL DCSP experimentDir = os.path.abspath(experiments[0]) DCNL DCSP privateOptions = dict() DCNL DCSP privateOptions['createCheckpointName'] = options.createCheckpointName DCNL DCSP privateOptions['listAvailableCheckpoints'] = options.listAvailableCheckpoints DCNL DCSP privateOptions['listTasks'] = options.listTasks DCNL DCSP privateOptions['runCheckpointName'] = options.runCheckpointName DCNL DCSP privateOptions['newSerialization'] = options.newSerialization DCNL DCSP privateOptions['testMode'] = options.testMode DCNL DCSP privateOptions['taskLabels'] = options.taskLabels DCNL DCSP privateOptions['checkpointModel'] = options.checkpointModel DCNL DCSP result = ParseCommandLineOptionsResult(experimentDir=experimentDir, privateOptions=privateOptions) DCNL DCSP return result
 DCSP newValues = [] DCNL DCSP gotDot = False DCNL DCSP for arg in parser.rargs: DCNL DCSP  DCSP if (arg.startswith('--') and (len(arg) > 2)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (arg.startswith('-') and (len(arg) > 1)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (arg == '.'): DCNL DCSP  DCSP  DCSP gotDot = True DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP newValues.append(arg) DCNL DCSP if (not newValues): DCNL DCSP  DCSP raise optparse.OptionValueError(('Empty DCSP arg DCSP list DCSP for DCSP option DCSP %r DCSP expecting DCSP one DCSP or DCSP more DCSP args DCSP (remaining DCSP tokens: DCSP %r)' % (optStr, parser.rargs))) DCNL DCSP del parser.rargs[:(len(newValues) + int(gotDot))] DCNL DCSP value = getattr(parser.values, option.dest, []) DCNL DCSP if (value is None): DCNL DCSP  DCSP value = [] DCNL DCSP value.extend(newValues) DCNL DCSP setattr(parser.values, option.dest, value)
 DCSP print parser.get_usage() DCNL DCSP print message DCNL DCSP sys.exit(1)
 DCSP json_helpers.validate(options.privateOptions, schemaDict=g_parsedPrivateCommandLineOptionsSchema) DCNL DCSP experimentDir = options.experimentDir DCNL DCSP descriptionPyModule = helpers.loadExperimentDescriptionScriptFromDir(experimentDir) DCNL DCSP expIface = helpers.getExperimentDescriptionInterfaceFromModule(descriptionPyModule) DCNL DCSP if options.privateOptions['listAvailableCheckpoints']: DCNL DCSP  DCSP _printAvailableCheckpoints(experimentDir) DCNL DCSP  DCSP return None DCNL DCSP experimentTasks = expIface.getModelControl().get('tasks', []) DCNL DCSP if ((len(experimentTasks) == 0) and (expIface.getModelControl()['environment'] == OpfEnvironment.Nupic)): DCNL DCSP  DCSP expIface.convertNupicEnvToOPF() DCNL DCSP  DCSP experimentTasks = expIface.getModelControl().get('tasks', []) DCNL DCSP expIface.normalizeStreamSources() DCNL DCSP newSerialization = options.privateOptions['newSerialization'] DCNL DCSP if options.privateOptions['listTasks']: DCNL DCSP  DCSP print 'Available DCSP tasks:' DCNL DCSP  DCSP for label in [t['taskLabel'] for t in experimentTasks]: DCNL DCSP  DCSP  DCSP print ' DCTB ', label DCNL DCSP  DCSP return None DCNL DCSP if options.privateOptions['runCheckpointName']: DCNL DCSP  DCSP assert (model is None) DCNL DCSP  DCSP checkpointName = options.privateOptions['runCheckpointName'] DCNL DCSP  DCSP model = ModelFactory.loadFromCheckpoint(savedModelDir=_getModelCheckpointDir(experimentDir, checkpointName), newSerialization=newSerialization) DCNL DCSP elif (model is not None): DCNL DCSP  DCSP print 'Skipping DCSP creation DCSP of DCSP OPFExperiment DCSP instance: DCSP caller DCSP provided DCSP his DCSP own' DCNL DCSP else: DCNL DCSP  DCSP modelDescription = expIface.getModelDescription() DCNL DCSP  DCSP model = ModelFactory.create(modelDescription) DCNL DCSP if options.privateOptions['createCheckpointName']: DCNL DCSP  DCSP checkpointName = options.privateOptions['createCheckpointName'] DCNL DCSP  DCSP _saveModel(model=model, experimentDir=experimentDir, checkpointLabel=checkpointName, newSerialization=newSerialization) DCNL DCSP  DCSP return model DCNL DCSP taskIndexList = range(len(experimentTasks)) DCNL DCSP customTaskExecutionLabelsList = options.privateOptions['taskLabels'] DCNL DCSP if customTaskExecutionLabelsList: DCNL DCSP  DCSP taskLabelsList = [t['taskLabel'] for t in experimentTasks] DCNL DCSP  DCSP taskLabelsSet = set(taskLabelsList) DCNL DCSP  DCSP customTaskExecutionLabelsSet = set(customTaskExecutionLabelsList) DCNL DCSP  DCSP assert customTaskExecutionLabelsSet.issubset(taskLabelsSet), ("Some DCSP custom-provided DCSP task DCSP execution DCSP labels DCSP don't DCSP correspond DCSP to DCSP actual DCSP task DCSP labels: DCSP mismatched DCSP labels: DCSP %r; DCSP actual DCSP task DCSP labels: DCSP %r." % ((customTaskExecutionLabelsSet - taskLabelsSet), customTaskExecutionLabelsList)) DCNL DCSP  DCSP taskIndexList = [taskLabelsList.index(label) for label in customTaskExecutionLabelsList] DCNL DCSP  DCSP print ('#### DCSP Executing DCSP custom DCSP task DCSP list: DCSP %r' % [taskLabelsList[i] for i in taskIndexList]) DCNL DCSP for taskIndex in taskIndexList: DCNL DCSP  DCSP task = experimentTasks[taskIndex] DCNL DCSP  DCSP taskRunner = _TaskRunner(model=model, task=task, cmdOptions=options) DCNL DCSP  DCSP taskRunner.run() DCNL DCSP  DCSP del taskRunner DCNL DCSP  DCSP if options.privateOptions['checkpointModel']: DCNL DCSP  DCSP  DCSP _saveModel(model=model, experimentDir=experimentDir, checkpointLabel=task['taskLabel'], newSerialization=newSerialization) DCNL DCSP return model
 DCSP checkpointDir = _getModelCheckpointDir(experimentDir, checkpointLabel) DCNL DCSP if newSerialization: DCNL DCSP  DCSP model.writeToCheckpoint(checkpointDir) DCNL DCSP else: DCNL DCSP  DCSP model.save(saveModelDir=checkpointDir)
 DCSP checkpointDir = os.path.join(getCheckpointParentDir(experimentDir), (checkpointLabel + g_defaultCheckpointExtension)) DCNL DCSP checkpointDir = os.path.abspath(checkpointDir) DCNL DCSP return checkpointDir
 DCSP baseDir = os.path.join(experimentDir, 'savedmodels') DCNL DCSP baseDir = os.path.abspath(baseDir) DCNL DCSP return baseDir
 DCSP assert checkpointDir.endswith(g_defaultCheckpointExtension) DCNL DCSP lastSegment = os.path.split(checkpointDir)[1] DCNL DCSP checkpointLabel = lastSegment[0:(- len(g_defaultCheckpointExtension))] DCNL DCSP return checkpointLabel
 DCSP lastSegment = os.path.split(checkpointDir)[1] DCNL DCSP if (lastSegment[0] == '.'): DCNL DCSP  DCSP return False DCNL DCSP if (not checkpointDir.endswith(g_defaultCheckpointExtension)): DCNL DCSP  DCSP return False DCNL DCSP if (not os.path.isdir(checkpointDir)): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP checkpointParentDir = getCheckpointParentDir(experimentDir) DCNL DCSP if (not os.path.exists(checkpointParentDir)): DCNL DCSP  DCSP print 'No DCSP available DCSP checkpoints.' DCNL DCSP  DCSP return DCNL DCSP checkpointDirs = [x for x in os.listdir(checkpointParentDir) if _isCheckpointDir(os.path.join(checkpointParentDir, x))] DCNL DCSP if (not checkpointDirs): DCNL DCSP  DCSP print 'No DCSP available DCSP checkpoints.' DCNL DCSP  DCSP return DCNL DCSP print 'Available DCSP checkpoints:' DCNL DCSP checkpointList = [_checkpointLabelFromCheckpointDir(x) for x in checkpointDirs] DCNL DCSP for checkpoint in sorted(checkpointList): DCNL DCSP  DCSP print ' DCTB ', checkpoint DCNL DCSP print DCNL DCSP print 'To DCSP start DCSP from DCSP a DCSP checkpoint:' DCNL DCSP print ' DCSP  DCSP python DCSP run_opf_experiment.py DCSP experiment DCSP --load DCSP <CHECKPOINT>' DCNL DCSP print 'For DCSP example, DCSP to DCSP start DCSP from DCSP the DCSP checkpoint DCSP "MyCheckpoint":' DCNL DCSP print ' DCSP  DCSP python DCSP run_opf_experiment.py DCSP experiment DCSP --load DCSP MyCheckpoint'
 DCSP initLogging(verbose=True) DCNL DCSP initExperimentPrng() DCNL DCSP runExperiment(sys.argv[1:])
 DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP path = os.path.dirname(path) DCNL DCSP descriptionPyModule = loadExperimentDescriptionScriptFromDir(path) DCNL DCSP expIface = getExperimentDescriptionInterfaceFromModule(descriptionPyModule) DCNL DCSP return (expIface.getModelDescription(), expIface.getModelControl())
 DCSP descriptionScriptPath = os.path.join(experimentDir, 'description.py') DCNL DCSP module = _loadDescriptionFile(descriptionScriptPath) DCNL DCSP return module
 DCSP result = module.descriptionInterface DCNL DCSP assert isinstance(result, exp_description_api.DescriptionIface), ('expected DCSP DescriptionIface-based DCSP instance, DCSP but DCSP got DCSP %s' % type(result)) DCNL DCSP return result
 DCSP global g_descriptionImportCount DCNL DCSP if (not os.path.isfile(descriptionPyPath)): DCNL DCSP  DCSP raise RuntimeError((('Experiment DCSP description DCSP file DCSP %s DCSP does DCSP not DCSP exist DCSP or DCSP ' + 'is DCSP not DCSP a DCSP file') % (descriptionPyPath,))) DCNL DCSP mod = imp.load_source(('pf_description%d' % g_descriptionImportCount), descriptionPyPath) DCNL DCSP g_descriptionImportCount += 1 DCNL DCSP if (not hasattr(mod, 'descriptionInterface')): DCNL DCSP  DCSP raise RuntimeError(('Experiment DCSP description DCSP file DCSP %s DCSP does DCSP not DCSP define DCSP %s' % (descriptionPyPath, 'descriptionInterface'))) DCNL DCSP if (not isinstance(mod.descriptionInterface, exp_description_api.DescriptionIface)): DCNL DCSP  DCSP raise RuntimeError((('Experiment DCSP description DCSP file DCSP %s DCSP defines DCSP %s DCSP but DCSP it DCSP ' + 'is DCSP not DCSP DescriptionIface-based') % (descriptionPyPath, name))) DCNL DCSP return mod
 DCSP if (minResolution is None): DCNL DCSP  DCSP minResolution = 0.001 DCNL DCSP if ((minVal is None) or (maxVal is None)): DCNL DCSP  DCSP (compMinVal, compMaxVal) = _rangeGen(metricData) DCNL DCSP  DCSP if (minVal is None): DCNL DCSP  DCSP  DCSP minVal = compMinVal DCNL DCSP  DCSP if (maxVal is None): DCNL DCSP  DCSP  DCSP maxVal = compMaxVal DCNL DCSP if (minVal == maxVal): DCNL DCSP  DCSP maxVal = (minVal + 1) DCNL DCSP if (tmImplementation is 'cpp'): DCNL DCSP  DCSP paramFileRelativePath = os.path.join('anomaly_params_random_encoder', 'best_single_metric_anomaly_params_cpp.json') DCNL DCSP elif (tmImplementation is 'tm_cpp'): DCNL DCSP  DCSP paramFileRelativePath = os.path.join('anomaly_params_random_encoder', 'best_single_metric_anomaly_params_tm_cpp.json') DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Invalid DCSP string DCSP for DCSP tmImplementation. DCSP Try DCSP cpp DCSP or DCSP tm_cpp') DCNL DCSP with resource_stream(__name__, paramFileRelativePath) as infile: DCNL DCSP  DCSP paramSet = json.load(infile) DCNL DCSP _fixupRandomEncoderParams(paramSet, minVal, maxVal, minResolution) DCNL DCSP return paramSet
 DCSP dataStd = np.std(data) DCNL DCSP if (dataStd == 0): DCNL DCSP  DCSP dataStd = 1 DCNL DCSP minval = (np.min(data) - (std * dataStd)) DCNL DCSP maxval = (np.max(data) + (std * dataStd)) DCNL DCSP return (minval, maxval)
 DCSP encodersDict = params['modelConfig']['modelParams']['sensorParams']['encoders'] DCNL DCSP for encoder in encodersDict.itervalues(): DCNL DCSP  DCSP if (encoder is not None): DCNL DCSP  DCSP  DCSP if (encoder['type'] == 'RandomDistributedScalarEncoder'): DCNL DCSP  DCSP  DCSP  DCSP resolution = max(minResolution, ((maxVal - minVal) / encoder.pop('numBuckets'))) DCNL DCSP  DCSP  DCSP  DCSP encodersDict['c1']['resolution'] = resolution
 DCSP jsonSchemaPath = os.path.join(os.path.dirname(__file__), 'jsonschema', opfJsonSchemaFilename) DCNL DCSP jsonhelpers.validate(value, schemaPath=jsonSchemaPath) DCNL DCSP return
 DCSP if inspect.isclass(obj): DCNL DCSP  DCSP myClass = obj DCNL DCSP else: DCNL DCSP  DCSP myClass = obj.__class__ DCNL DCSP logger = logging.getLogger('.'.join(['com.numenta', myClass.__module__, myClass.__name__])) DCNL DCSP return logger
 DCSP results = [] DCNL DCSP if patterns: DCNL DCSP  DCSP for pattern in patterns: DCNL DCSP  DCSP  DCSP prog = re.compile(pattern) DCNL DCSP  DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP  DCSP if prog.match(key): DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.append(key) DCNL DCSP else: DCNL DCSP  DCSP return None DCNL DCSP return results
 DCSP _applyValueGettersImpl(container=container, currentObj=container, recursionStack=[])
 DCSP if (currentObj in recursionStack): DCNL DCSP  DCSP return DCNL DCSP assert (len(recursionStack) < 1000) DCNL DCSP recursionStack.append(currentObj) DCNL DCSP if isinstance(currentObj, dict): DCNL DCSP  DCSP for (key, value) in currentObj.items(): DCNL DCSP  DCSP  DCSP if isinstance(value, ValueGetterBase): DCNL DCSP  DCSP  DCSP  DCSP currentObj[key] = value(container) DCNL DCSP  DCSP  DCSP _applyValueGettersImpl(container, currentObj[key], recursionStack) DCNL DCSP elif (isinstance(currentObj, tuple) or isinstance(currentObj, list)): DCNL DCSP  DCSP for (i, value) in enumerate(currentObj): DCNL DCSP  DCSP  DCSP if isinstance(value, ValueGetterBase): DCNL DCSP  DCSP  DCSP  DCSP currentObj[i] = value(container) DCNL DCSP  DCSP  DCSP _applyValueGettersImpl(container, currentObj[i], recursionStack) DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP recursionStack.pop() DCNL DCSP return
 DCSP @wraps(func) DCNL DCSP def _decorator(self, *args, **kwargs): DCNL DCSP  DCSP if (not (self.getInferenceType() == InferenceType.TemporalAnomaly)): DCNL DCSP  DCSP  DCSP raise RuntimeError('Method DCSP required DCSP a DCSP TemporalAnomaly DCSP model.') DCNL DCSP  DCSP if (self._getAnomalyClassifier() is None): DCNL DCSP  DCSP  DCSP raise RuntimeError('Model DCSP does DCSP not DCSP support DCSP this DCSP command. DCSP Model DCSP mustbe DCSP an DCSP active DCSP anomalyDetector DCSP model.') DCNL DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return _decorator
 DCSP model.finishLearning() DCNL DCSP return
 DCSP random.seed(seed) DCNL DCSP numpy.random.seed(seed)
 DCSP if (doForeground and doBackground): DCNL DCSP  DCSP return numpy.abs((input - (numpy.random.random(input.shape) < noise))) DCNL DCSP else: DCNL DCSP  DCSP if doForeground: DCNL DCSP  DCSP  DCSP return numpy.logical_and(input, (numpy.random.random(input.shape) > noise)) DCNL DCSP  DCSP if doBackground: DCNL DCSP  DCSP  DCSP return numpy.logical_or(input, (numpy.random.random(input.shape) < noise)) DCNL DCSP return input
 DCSP coincMatrix0 = SM32(int(nCoinc), int(length)) DCNL DCSP theOnes = numpy.array(([1.0] * activity), dtype=numpy.float32) DCNL DCSP for rowIdx in xrange(nCoinc): DCNL DCSP  DCSP coinc = numpy.array(random.sample(xrange(length), activity), dtype=numpy.uint32) DCNL DCSP  DCSP coinc.sort() DCNL DCSP  DCSP coincMatrix0.setRowFromSparse(rowIdx, coinc, theOnes) DCNL DCSP coincMatrix = SM32(int(nCoinc), int(length)) DCNL DCSP coincMatrix.initializeWithFixedNNZR(activity) DCNL DCSP return coincMatrix0
 DCSP vectors = [] DCNL DCSP coinc = numpy.zeros(length, dtype='int32') DCNL DCSP indexList = range(length) DCNL DCSP for i in xrange(numVectors): DCNL DCSP  DCSP coinc[:] = 0 DCNL DCSP  DCSP coinc[random.sample(indexList, activity)] = 1 DCNL DCSP  DCSP vectors.append(coinc.copy()) DCNL DCSP return vectors
 DCSP coincList = range(nCoinc) DCNL DCSP seqList = [] DCNL DCSP for i in xrange(nSeq): DCNL DCSP  DCSP if (max(seqLength) <= nCoinc): DCNL DCSP  DCSP  DCSP seqList.append(random.sample(coincList, random.choice(seqLength))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP len = random.choice(seqLength) DCNL DCSP  DCSP  DCSP seq = [] DCNL DCSP  DCSP  DCSP for x in xrange(len): DCNL DCSP  DCSP  DCSP  DCSP seq.append(random.choice(coincList)) DCNL DCSP  DCSP  DCSP seqList.append(seq) DCNL DCSP return seqList
 DCSP coincList = range(nCoinc) DCNL DCSP for hub in hubs: DCNL DCSP  DCSP coincList.remove(hub) DCNL DCSP seqList = [] DCNL DCSP for i in xrange(nSeq): DCNL DCSP  DCSP length = (random.choice(seqLength) - 1) DCNL DCSP  DCSP seq = random.sample(coincList, length) DCNL DCSP  DCSP seq.insert((length // 2), random.choice(hubs)) DCNL DCSP  DCSP seqList.append(seq) DCNL DCSP return seqList
 DCSP patterns = generateCoincMatrix(nCoinc=nPatterns, length=patternLen, activity=patternActivity) DCNL DCSP similarity = [] DCNL DCSP for i in xrange(nPatterns): DCNL DCSP  DCSP similarity.append(patterns.rightVecProd(patterns.getRow(i))) DCNL DCSP similarity = numpy.array(similarity, dtype='int32') DCNL DCSP print similarity DCNL DCSP seqList1 = generateSimpleSequences(nCoinc=nPatterns, seqLength=seqLength, nSeq=nSequences) DCNL DCSP seqList2 = copy.deepcopy(seqList1) DCNL DCSP for i in range(0, len(seqList2)): DCNL DCSP  DCSP seqList2[i][0] = random.randint(0, (nPatterns - 1)) DCNL DCSP return (seqList1, seqList2, patterns)
 DCSP assert ((nCoinc * activity) <= length), "can't DCSP generate DCSP non-overlapping DCSP coincidences" DCNL DCSP coincMatrix = SM32(0, length) DCNL DCSP coinc = numpy.zeros(length, dtype='int32') DCNL DCSP for i in xrange(nCoinc): DCNL DCSP  DCSP coinc[:] = 0 DCNL DCSP  DCSP coinc[(i * activity):((i + 1) * activity)] = 1 DCNL DCSP  DCSP coincMatrix.addRow(coinc) DCNL DCSP return coincMatrix
 DCSP patterns = generateCoincMatrix(nCoinc=nPatterns, length=patternLen, activity=patternActivity) DCNL DCSP seqList = (generateSimpleSequences(nCoinc=nPatterns, seqLength=seqLength, nSeq=nSimpleSequences) + generateHubSequences(nCoinc=nPatterns, hubs=hubs, seqLength=seqLength, nSeq=nHubSequences)) DCNL DCSP return (seqList, patterns)
 DCSP l1SeqList = (generateSimpleSequences(nCoinc=nL1Patterns, seqLength=l1SeqLength, nSeq=nL1SimpleSequences) + generateHubSequences(nCoinc=nL1Patterns, hubs=l1Hubs, seqLength=l1SeqLength, nSeq=nL1HubSequences)) DCNL DCSP spOutput = generateSlowSPOutput(seqListBelow=l1SeqList, poolingTimeBelow=l1Pooling, outputWidth=patternLen, activity=patternActivity, perfectStability=perfectStability, spHysteresisFactor=spHysteresisFactor) DCNL DCSP outSeq = None DCNL DCSP outSeqList = [] DCNL DCSP outPatterns = SM32(0, patternLen) DCNL DCSP for pattern in spOutput: DCNL DCSP  DCSP if (pattern.sum() == 0): DCNL DCSP  DCSP  DCSP if (outSeq is not None): DCNL DCSP  DCSP  DCSP  DCSP outSeqList.append(outSeq) DCNL DCSP  DCSP  DCSP outSeq = [] DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP patternIdx = None DCNL DCSP  DCSP if (outPatterns.nRows() > 0): DCNL DCSP  DCSP  DCSP matches = outPatterns.rightVecSumAtNZ(pattern) DCNL DCSP  DCSP  DCSP outCoinc = matches.argmax().astype('uint32') DCNL DCSP  DCSP  DCSP numOnes = pattern.sum() DCNL DCSP  DCSP  DCSP if ((matches[outCoinc] == numOnes) and (outPatterns.getRow(int(outCoinc)).sum() == numOnes)): DCNL DCSP  DCSP  DCSP  DCSP patternIdx = outCoinc DCNL DCSP  DCSP if (patternIdx is None): DCNL DCSP  DCSP  DCSP outPatterns.addRow(pattern) DCNL DCSP  DCSP  DCSP patternIdx = (outPatterns.nRows() - 1) DCNL DCSP  DCSP outSeq.append(patternIdx) DCNL DCSP if (outSeq is not None): DCNL DCSP  DCSP outSeqList.append(outSeq) DCNL DCSP return (outSeqList, outPatterns)
 DCSP totalLen = 0 DCNL DCSP for seq in seqList: DCNL DCSP  DCSP totalLen += len(seq) DCNL DCSP vectors = numpy.zeros((totalLen, patternMatrix.shape[1]), dtype='bool') DCNL DCSP vecOffset = 0 DCNL DCSP for seq in seqList: DCNL DCSP  DCSP seq = numpy.array(seq, dtype='uint32') DCNL DCSP  DCSP for (idx, coinc) in enumerate(seq): DCNL DCSP  DCSP  DCSP vectors[vecOffset] = patternMatrix.getRow(int(coinc)) DCNL DCSP  DCSP  DCSP vecOffset += 1 DCNL DCSP return vectors
 DCSP result = True DCNL DCSP for param in ['numberOfCols', 'cellsPerColumn', 'initialPerm', 'connectedPerm', 'minThreshold', 'newSynapseCount', 'permanenceInc', 'permanenceDec', 'permanenceMax', 'globalDecay', 'activationThreshold', 'doPooling', 'segUpdateValidDuration', 'burnIn', 'pamLength', 'maxAge']: DCNL DCSP  DCSP if (getattr(tp1, param) != getattr(tp2, param)): DCNL DCSP  DCSP  DCSP print param, 'is DCSP different' DCNL DCSP  DCSP  DCSP print getattr(tp1, param), 'vs', getattr(tp2, param) DCNL DCSP  DCSP  DCSP result = False DCNL DCSP return result
 DCSP for s in synapses: DCNL DCSP  DCSP if ((s[0] == syn[0]) and (s[1] == syn[1]) and (abs((s[2] - syn[2])) <= 0.001)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP result = True DCNL DCSP for field in [1, 2, 3, 4, 5, 6]: DCNL DCSP  DCSP if (abs((seg1[0][field] - seg2[0][field])) > 0.001): DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (len(seg1[1:]) != len(seg2[1:])): DCNL DCSP  DCSP result = False DCNL DCSP for syn in seg2[1:]: DCNL DCSP  DCSP if (syn[2] <= 0): DCNL DCSP  DCSP  DCSP print 'A DCSP synapse DCSP with DCSP zero DCSP permanence DCSP encountered' DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (result == True): DCNL DCSP  DCSP for syn in seg1[1:]: DCNL DCSP  DCSP  DCSP if (syn[2] <= 0): DCNL DCSP  DCSP  DCSP  DCSP print 'A DCSP synapse DCSP with DCSP zero DCSP permanence DCSP encountered' DCNL DCSP  DCSP  DCSP  DCSP result = False DCNL DCSP  DCSP  DCSP res = sameSynapse(syn, seg2[1:]) DCNL DCSP  DCSP  DCSP if (res == False): DCNL DCSP  DCSP  DCSP  DCSP result = False DCNL DCSP return result
 DCSP if (sameTMParams(tm1, tm2) == False): DCNL DCSP  DCSP print "Two DCSP TM's DCSP have DCSP different DCSP parameters" DCNL DCSP  DCSP return False DCNL DCSP result = True DCNL DCSP if (tm1.activeState['t'] != tm2.activeState['t']).any(): DCNL DCSP  DCSP print 'Active DCSP states DCSP diverge', numpy.where((tm1.activeState['t'] != tm2.activeState['t'])) DCNL DCSP  DCSP result = False DCNL DCSP if (tm1.predictedState['t'] - tm2.predictedState['t']).any(): DCNL DCSP  DCSP print 'Predicted DCSP states DCSP diverge', numpy.where((tm1.predictedState['t'] != tm2.predictedState['t'])) DCNL DCSP  DCSP result = False DCNL DCSP if (tm1.getNumSegments() != tm2.getNumSegments()): DCNL DCSP  DCSP print 'Number DCSP of DCSP segments DCSP are DCSP different', tm1.getNumSegments(), tm2.getNumSegments() DCNL DCSP  DCSP result = False DCNL DCSP if (tm1.getNumSynapses() != tm2.getNumSynapses()): DCNL DCSP  DCSP print 'Number DCSP of DCSP synapses DCSP are DCSP different', tm1.getNumSynapses(), tm2.getNumSynapses() DCNL DCSP  DCSP tm1.printCells() DCNL DCSP  DCSP tm2.printCells() DCNL DCSP  DCSP result = False DCNL DCSP for c in xrange(tm1.numberOfCols): DCNL DCSP  DCSP for i in xrange(tm2.cellsPerColumn): DCNL DCSP  DCSP  DCSP if (tm1.getNumSegmentsInCell(c, i) != tm2.getNumSegmentsInCell(c, i)): DCNL DCSP  DCSP  DCSP  DCSP print 'Num DCSP segments DCSP different DCSP in DCSP cell:', c, i, DCNL DCSP  DCSP  DCSP  DCSP print tm1.getNumSegmentsInCell(c, i), tm2.getNumSegmentsInCell(c, i) DCNL DCSP  DCSP  DCSP  DCSP result = False DCNL DCSP if ((result == True) and (not relaxSegmentTests)): DCNL DCSP  DCSP for c in xrange(tm1.numberOfCols): DCNL DCSP  DCSP  DCSP for i in xrange(tm2.cellsPerColumn): DCNL DCSP  DCSP  DCSP  DCSP nSegs = tm1.getNumSegmentsInCell(c, i) DCNL DCSP  DCSP  DCSP  DCSP for segIdx in xrange(nSegs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm1seg = tm1.getSegmentOnCell(c, i, segIdx) DCNL DCSP  DCSP  DCSP  DCSP  DCSP res = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP for tm2segIdx in xrange(nSegs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm2seg = tm2.getSegmentOnCell(c, i, tm2segIdx) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (sameSegment(tm1seg, tm2seg) == True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP res = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (res == False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print '\nSegments DCSP are DCSP different DCSP for DCSP cell:', c, i DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (verbosity >= 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'C++' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm1.printCell(c, i) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Py' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm2.printCell(c, i) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result = False DCNL DCSP if ((result == True) and (verbosity > 1)): DCNL DCSP  DCSP print "TM's DCSP match" DCNL DCSP return result
 DCSP if (sameTMParams(tm1, tm2) == False): DCNL DCSP  DCSP print "Two DCSP TM's DCSP have DCSP different DCSP parameters" DCNL DCSP  DCSP return False DCNL DCSP tm1Label = ('<tm_1 DCSP (%s)>' % tm1.__class__.__name__) DCNL DCSP tm2Label = ('<tm_2 DCSP (%s)>' % tm2.__class__.__name__) DCNL DCSP result = True DCNL DCSP if checkStates: DCNL DCSP  DCSP if (tm1.infActiveState['t'] != tm2.infActiveState['t']).any(): DCNL DCSP  DCSP  DCSP print 'Active DCSP states DCSP diverged', numpy.where((tm1.infActiveState['t'] != tm2.infActiveState['t'])) DCNL DCSP  DCSP  DCSP result = False DCNL DCSP  DCSP if (tm1.infPredictedState['t'] - tm2.infPredictedState['t']).any(): DCNL DCSP  DCSP  DCSP print 'Predicted DCSP states DCSP diverged', numpy.where((tm1.infPredictedState['t'] != tm2.infPredictedState['t'])) DCNL DCSP  DCSP  DCSP result = False DCNL DCSP  DCSP if (checkLearn and (tm1.lrnActiveState['t'] - tm2.lrnActiveState['t']).any()): DCNL DCSP  DCSP  DCSP print 'lrnActiveState[t] DCSP diverged', numpy.where((tm1.lrnActiveState['t'] != tm2.lrnActiveState['t'])) DCNL DCSP  DCSP  DCSP result = False DCNL DCSP  DCSP if (checkLearn and (tm1.lrnPredictedState['t'] - tm2.lrnPredictedState['t']).any()): DCNL DCSP  DCSP  DCSP print 'lrnPredictedState[t] DCSP diverged', numpy.where((tm1.lrnPredictedState['t'] != tm2.lrnPredictedState['t'])) DCNL DCSP  DCSP  DCSP result = False DCNL DCSP  DCSP if (checkLearn and (abs((tm1.getAvgLearnedSeqLength() - tm2.getAvgLearnedSeqLength())) > 0.01)): DCNL DCSP  DCSP  DCSP print 'Average DCSP learned DCSP sequence DCSP lengths DCSP differ: DCSP ', DCNL DCSP  DCSP  DCSP print tm1.getAvgLearnedSeqLength(), ' DCSP vs DCSP ', tm2.getAvgLearnedSeqLength() DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (tm1.getNumSegments() != tm2.getNumSegments()): DCNL DCSP  DCSP print 'Number DCSP of DCSP segments DCSP are DCSP different', tm1.getNumSegments(), tm2.getNumSegments() DCNL DCSP  DCSP result = False DCNL DCSP if (tm1.getNumSynapses() != tm2.getNumSynapses()): DCNL DCSP  DCSP print 'Number DCSP of DCSP synapses DCSP are DCSP different', tm1.getNumSynapses(), tm2.getNumSynapses() DCNL DCSP  DCSP if (verbosity >= 3): DCNL DCSP  DCSP  DCSP print ('%s: DCSP ' % tm1Label), DCNL DCSP  DCSP  DCSP tm1.printCells() DCNL DCSP  DCSP  DCSP print ('\n%s DCSP  DCSP : DCSP ' % tm2Label), DCNL DCSP  DCSP  DCSP tm2.printCells() DCNL DCSP for c in xrange(tm1.numberOfCols): DCNL DCSP  DCSP for i in xrange(tm2.cellsPerColumn): DCNL DCSP  DCSP  DCSP if (tm1.getNumSegmentsInCell(c, i) != tm2.getNumSegmentsInCell(c, i)): DCNL DCSP  DCSP  DCSP  DCSP print 'Num DCSP segments DCSP different DCSP in DCSP cell:', c, i, DCNL DCSP  DCSP  DCSP  DCSP print tm1.getNumSegmentsInCell(c, i), tm2.getNumSegmentsInCell(c, i) DCNL DCSP  DCSP  DCSP  DCSP result = False DCNL DCSP if ((result == True) and (not relaxSegmentTests) and checkLearn): DCNL DCSP  DCSP for c in xrange(tm1.numberOfCols): DCNL DCSP  DCSP  DCSP for i in xrange(tm2.cellsPerColumn): DCNL DCSP  DCSP  DCSP  DCSP nSegs = tm1.getNumSegmentsInCell(c, i) DCNL DCSP  DCSP  DCSP  DCSP for segIdx in xrange(nSegs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm1seg = tm1.getSegmentOnCell(c, i, segIdx) DCNL DCSP  DCSP  DCSP  DCSP  DCSP res = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP for tm2segIdx in xrange(nSegs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm2seg = tm2.getSegmentOnCell(c, i, tm2segIdx) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (sameSegment(tm1seg, tm2seg) == True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP res = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (res == False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print '\nSegments DCSP are DCSP different DCSP for DCSP cell:', c, i DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (verbosity >= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('%s DCSP : DCSP ' % tm1Label), DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm1.printCell(c, i) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('\n%s DCSP  DCSP : DCSP ' % tm2Label), DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tm2.printCell(c, i) DCNL DCSP if ((result == True) and (verbosity > 1)): DCNL DCSP  DCSP print "TM's DCSP match" DCNL DCSP return result
 DCSP if (len(SP1._masterConnectedM) != len(SP2._masterConnectedM)): DCNL DCSP  DCSP print 'Connected DCSP synapse DCSP matrices DCSP are DCSP different DCSP sizes' DCNL DCSP  DCSP return False DCNL DCSP if (len(SP1._masterPotentialM) != len(SP2._masterPotentialM)): DCNL DCSP  DCSP print 'Potential DCSP synapse DCSP matrices DCSP are DCSP different DCSP sizes' DCNL DCSP  DCSP return False DCNL DCSP if (len(SP1._masterPermanenceM) != len(SP2._masterPermanenceM)): DCNL DCSP  DCSP print 'Permanence DCSP matrices DCSP are DCSP different DCSP sizes' DCNL DCSP  DCSP return False DCNL DCSP for i in range(0, len(SP1._masterConnectedM)): DCNL DCSP  DCSP connected1 = SP1._masterConnectedM[i] DCNL DCSP  DCSP connected2 = SP2._masterConnectedM[i] DCNL DCSP  DCSP if (connected1 != connected2): DCNL DCSP  DCSP  DCSP print ('Connected DCSP Matrices DCSP for DCSP cell DCSP %d DCSP different' % i) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP permanences1 = SP1._masterPermanenceM[i] DCNL DCSP  DCSP permanences2 = SP2._masterPermanenceM[i] DCNL DCSP  DCSP if (permanences1 != permanences2): DCNL DCSP  DCSP  DCSP print ('Permanence DCSP Matrices DCSP for DCSP cell DCSP %d DCSP different' % i) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP potential1 = SP1._masterPotentialM[i] DCNL DCSP  DCSP potential2 = SP2._masterPotentialM[i] DCNL DCSP  DCSP if (potential1 != potential2): DCNL DCSP  DCSP  DCSP print ('Potential DCSP Matrices DCSP for DCSP cell DCSP %d DCSP different' % i) DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (not numpy.array_equal(SP1._firingBoostFactors, SP2._firingBoostFactors)): DCNL DCSP  DCSP print 'Firing DCSP boost DCSP factors DCSP are DCSP different DCSP between DCSP spatial DCSP poolers' DCNL DCSP  DCSP return False DCNL DCSP if (not numpy.array_equal(SP1._dutyCycleAfterInh, SP2._dutyCycleAfterInh)): DCNL DCSP  DCSP print 'Duty DCSP cycles DCSP after DCSP inhibition DCSP are DCSP different DCSP between DCSP spatial DCSP poolers' DCNL DCSP  DCSP return False DCNL DCSP if (not numpy.array_equal(SP1._dutyCycleBeforeInh, SP2._dutyCycleBeforeInh)): DCNL DCSP  DCSP print 'Duty DCSP cycles DCSP before DCSP inhibition DCSP are DCSP different DCSP between DCSP spatial DCSP poolers' DCNL DCSP  DCSP return False DCNL DCSP print 'Spatial DCSP Poolers DCSP are DCSP equivalent' DCNL DCSP return True
 DCSP if (numSteps == 0): DCNL DCSP  DCSP return vectors DCNL DCSP resetIndices = resets.nonzero()[0] DCNL DCSP removeRows = resetIndices DCNL DCSP for i in range((numSteps - 1)): DCNL DCSP  DCSP removeRows = numpy.hstack((removeRows, ((resetIndices + i) + 1))) DCNL DCSP return numpy.delete(vectors, removeRows, axis=0)
 DCSP values = numpy.array(values) DCNL DCSP numEntries = (values.max() + 1) DCNL DCSP if (freqCounts is not None): DCNL DCSP  DCSP numEntries = max(numEntries, freqCounts.size) DCNL DCSP if (freqCounts is not None): DCNL DCSP  DCSP if (freqCounts.size != numEntries): DCNL DCSP  DCSP  DCSP newCounts = numpy.zeros(numEntries, dtype='int32') DCNL DCSP  DCSP  DCSP newCounts[0:freqCounts.size] = freqCounts DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP newCounts = freqCounts DCNL DCSP else: DCNL DCSP  DCSP newCounts = numpy.zeros(numEntries, dtype='int32') DCNL DCSP for v in values: DCNL DCSP  DCSP newCounts[v] += 1 DCNL DCSP return newCounts
 DCSP durations = [] DCNL DCSP numOnTimes = 0 DCNL DCSP totalOnTime = 0 DCNL DCSP nonzeros = numpy.array(vector).nonzero()[0] DCNL DCSP if (len(nonzeros) == 0): DCNL DCSP  DCSP return (0, 0, []) DCNL DCSP if (len(nonzeros) == 1): DCNL DCSP  DCSP return (1, 1, [1]) DCNL DCSP prev = nonzeros[0] DCNL DCSP onTime = 1 DCNL DCSP endIdx = nonzeros[(-1)] DCNL DCSP for idx in nonzeros[1:]: DCNL DCSP  DCSP if (idx != (prev + 1)): DCNL DCSP  DCSP  DCSP totalOnTime += onTime DCNL DCSP  DCSP  DCSP numOnTimes += 1 DCNL DCSP  DCSP  DCSP durations.append(onTime) DCNL DCSP  DCSP  DCSP onTime = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP onTime += 1 DCNL DCSP  DCSP prev = idx DCNL DCSP totalOnTime += onTime DCNL DCSP numOnTimes += 1 DCNL DCSP durations.append(onTime) DCNL DCSP return (totalOnTime, numOnTimes, durations)
 DCSP nonzeros = numpy.array(vector).nonzero()[0] DCNL DCSP if (len(nonzeros) == 0): DCNL DCSP  DCSP return DCNL DCSP if (len(nonzeros) == 1): DCNL DCSP  DCSP durations[nonzeros[0]] = 1 DCNL DCSP  DCSP return DCNL DCSP prev = nonzeros[0] DCNL DCSP onTime = 1 DCNL DCSP onStartIdx = prev DCNL DCSP endIdx = nonzeros[(-1)] DCNL DCSP for idx in nonzeros[1:]: DCNL DCSP  DCSP if (idx != (prev + 1)): DCNL DCSP  DCSP  DCSP durations[onStartIdx:(onStartIdx + onTime)] = range(1, (onTime + 1)) DCNL DCSP  DCSP  DCSP onTime = 1 DCNL DCSP  DCSP  DCSP onStartIdx = idx DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP onTime += 1 DCNL DCSP  DCSP prev = idx DCNL DCSP durations[onStartIdx:(onStartIdx + onTime)] = range(1, (onTime + 1))
 DCSP if (vectors.ndim == 1): DCNL DCSP  DCSP vectors.shape = ((-1), 1) DCNL DCSP numTimeSteps = len(vectors) DCNL DCSP numElements = len(vectors[0]) DCNL DCSP if (numSamples is not None): DCNL DCSP  DCSP import pdb DCNL DCSP  DCSP pdb.set_trace() DCNL DCSP  DCSP countOn = numpy.random.randint(0, numElements, numSamples) DCNL DCSP  DCSP vectors = vectors[:, countOn] DCNL DCSP durations = numpy.zeros(vectors.shape, dtype='int32') DCNL DCSP for col in xrange(vectors.shape[1]): DCNL DCSP  DCSP _fillInOnTimes(vectors[:, col], durations[:, col]) DCNL DCSP sums = vectors.sum(axis=1) DCNL DCSP sums.clip(min=1, max=numpy.inf, out=sums) DCNL DCSP avgDurations = (durations.sum(axis=1, dtype='float64') / sums) DCNL DCSP avgOnTime = (avgDurations.sum() / (avgDurations > 0).sum()) DCNL DCSP freqCounts = _accumulateFrequencyCounts(avgDurations) DCNL DCSP return (avgOnTime, freqCounts)
 DCSP if (vectors.ndim == 1): DCNL DCSP  DCSP vectors.shape = ((-1), 1) DCNL DCSP numTimeSteps = len(vectors) DCNL DCSP numElements = len(vectors[0]) DCNL DCSP if (numSamples is None): DCNL DCSP  DCSP numSamples = numElements DCNL DCSP  DCSP countOn = range(numElements) DCNL DCSP else: DCNL DCSP  DCSP countOn = numpy.random.randint(0, numElements, numSamples) DCNL DCSP sumOfLengths = 0.0 DCNL DCSP onTimeFreqCounts = None DCNL DCSP n = 0 DCNL DCSP for i in countOn: DCNL DCSP  DCSP (onTime, segments, durations) = _listOfOnTimesInVec(vectors[:, i]) DCNL DCSP  DCSP if (onTime != 0.0): DCNL DCSP  DCSP  DCSP sumOfLengths += onTime DCNL DCSP  DCSP  DCSP n += segments DCNL DCSP  DCSP  DCSP onTimeFreqCounts = _accumulateFrequencyCounts(durations, onTimeFreqCounts) DCNL DCSP if (n > 0): DCNL DCSP  DCSP return ((sumOfLengths / n), onTimeFreqCounts) DCNL DCSP else: DCNL DCSP  DCSP return (0.0, onTimeFreqCounts)
 DCSP import pylab DCNL DCSP pylab.ion() DCNL DCSP pylab.figure() DCNL DCSP imData = vectors.transpose() DCNL DCSP if (buVectors is not None): DCNL DCSP  DCSP assert (buVectors.shape == vectors.shape) DCNL DCSP  DCSP imData = imData.copy() DCNL DCSP  DCSP imData[buVectors.transpose().astype('bool')] = 2 DCNL DCSP pylab.imshow(imData, aspect='auto', cmap=pylab.cm.gray_r, interpolation='nearest') DCNL DCSP pylab.title(title)
 DCSP import pylab DCNL DCSP pylab.ion() DCNL DCSP pylab.figure() DCNL DCSP pylab.bar((numpy.arange(len(freqCounts)) - 0.5), freqCounts) DCNL DCSP pylab.title(title) DCNL DCSP pylab.xlabel(xLabel)
 DCSP numVectors = len(vectors) DCNL DCSP if (numSamples is None): DCNL DCSP  DCSP numSamples = (numVectors - 1) DCNL DCSP  DCSP countOn = range((numVectors - 1)) DCNL DCSP else: DCNL DCSP  DCSP countOn = numpy.random.randint(0, (numVectors - 1), numSamples) DCNL DCSP sigmap = 0.0 DCNL DCSP for i in countOn: DCNL DCSP  DCSP match = checkMatch(vectors[i], vectors[(i + 1)], sparse=False) DCNL DCSP  DCSP if (match[1] != 0): DCNL DCSP  DCSP  DCSP sigmap += (float(match[0]) / match[1]) DCNL DCSP return (sigmap / numSamples)
 DCSP totalSamples = len(vectors) DCNL DCSP windowSize = numSamples DCNL DCSP numWindows = 0 DCNL DCSP pctStable = 0 DCNL DCSP for wStart in range(0, ((totalSamples - windowSize) + 1)): DCNL DCSP  DCSP data = vectors[wStart:(wStart + windowSize)] DCNL DCSP  DCSP outputSums = data.sum(axis=0) DCNL DCSP  DCSP stableOutputs = (outputSums == windowSize).sum() DCNL DCSP  DCSP samplePctStable = (float(stableOutputs) / data[0].sum()) DCNL DCSP  DCSP print samplePctStable DCNL DCSP  DCSP pctStable += samplePctStable DCNL DCSP  DCSP numWindows += 1 DCNL DCSP return (float(pctStable) / numWindows)
 DCSP if (not sparseForm): DCNL DCSP  DCSP outputs = outputs.reshape(outputsShape) DCNL DCSP  DCSP spOut = SM32(outputs) DCNL DCSP else: DCNL DCSP  DCSP if (len(outputs) > 0): DCNL DCSP  DCSP  DCSP assert (outputs.max() < (outputsShape[0] * outputsShape[1])) DCNL DCSP  DCSP spOut = SM32(1, (outputsShape[0] * outputsShape[1])) DCNL DCSP  DCSP spOut.setRowFromSparse(0, outputs, ([1] * len(outputs))) DCNL DCSP  DCSP spOut.reshape(outputsShape[0], outputsShape[1]) DCNL DCSP regionSize = 15 DCNL DCSP rows = xrange((regionSize + 1), (outputsShape[0] + 1), regionSize) DCNL DCSP cols = xrange((regionSize + 1), (outputsShape[1] + 1), regionSize) DCNL DCSP regionSums = spOut.nNonZerosPerBox(rows, cols) DCNL DCSP (locations, values) = regionSums.tolist() DCNL DCSP values /= float((regionSize * regionSize)) DCNL DCSP sat = list(values) DCNL DCSP innerSat = [] DCNL DCSP locationSet = set(locations) DCNL DCSP for (location, value) in itertools.izip(locations, values): DCNL DCSP  DCSP (row, col) = location DCNL DCSP  DCSP if ((((row - 1), col) in locationSet) and ((row, (col - 1)) in locationSet) and (((row + 1), col) in locationSet) and ((row, (col + 1)) in locationSet)): DCNL DCSP  DCSP  DCSP innerSat.append(value) DCNL DCSP return (sat, innerSat)
 DCSP if sparse: DCNL DCSP  DCSP activeElementsInInput = set(input) DCNL DCSP  DCSP activeElementsInPrediction = set(prediction) DCNL DCSP else: DCNL DCSP  DCSP activeElementsInInput = set(input.nonzero()[0]) DCNL DCSP  DCSP activeElementsInPrediction = set(prediction.nonzero()[0]) DCNL DCSP totalActiveInPrediction = len(activeElementsInPrediction) DCNL DCSP totalActiveInInput = len(activeElementsInInput) DCNL DCSP foundInInput = len(activeElementsInPrediction.intersection(activeElementsInInput)) DCNL DCSP missingFromInput = len(activeElementsInPrediction.difference(activeElementsInInput)) DCNL DCSP missingFromPrediction = len(activeElementsInInput.difference(activeElementsInPrediction)) DCNL DCSP if (verbosity >= 1): DCNL DCSP  DCSP print 'preds. DCSP found DCSP in DCSP input:', foundInInput, 'out DCSP of', totalActiveInPrediction, DCNL DCSP  DCSP print '; DCSP preds. DCSP missing DCSP from DCSP input:', missingFromInput, 'out DCSP of', totalActiveInPrediction, DCNL DCSP  DCSP print '; DCSP unexpected DCSP active DCSP in DCSP input:', missingFromPrediction, 'out DCSP of', totalActiveInInput DCNL DCSP return (foundInInput, totalActiveInInput, missingFromInput, totalActiveInPrediction)
 DCSP predCounts = None DCNL DCSP predTotal = 0 DCNL DCSP nSamples = len(outputs) DCNL DCSP predTotalNotLimited = 0 DCNL DCSP nSamplesNotLimited = 0 DCNL DCSP nCols = len(inputs[0]) DCNL DCSP nCellsPerCol = (len(outputs[0]) // nCols) DCNL DCSP for idx in xrange(nSamples): DCNL DCSP  DCSP activeCols = outputs[idx].reshape(nCols, nCellsPerCol).max(axis=1) DCNL DCSP  DCSP steps = 0 DCNL DCSP  DCSP while ((((idx + steps) + 1) < nSamples) and (resets[((idx + steps) + 1)] == 0)): DCNL DCSP  DCSP  DCSP overlap = numpy.logical_and(inputs[((idx + steps) + 1)], activeCols) DCNL DCSP  DCSP  DCSP overlapPct = ((100.0 * float(overlap.sum())) / inputs[((idx + steps) + 1)].sum()) DCNL DCSP  DCSP  DCSP if (overlapPct >= minOverlapPct): DCNL DCSP  DCSP  DCSP  DCSP steps += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP predCounts = _accumulateFrequencyCounts([steps], predCounts) DCNL DCSP  DCSP predTotal += steps DCNL DCSP  DCSP if (resets[idx] or ((((idx + steps) + 1) < nSamples) and (not resets[((idx + steps) + 1)]))): DCNL DCSP  DCSP  DCSP predTotalNotLimited += steps DCNL DCSP  DCSP  DCSP nSamplesNotLimited += 1 DCNL DCSP return ((float(predTotal) / nSamples), (float(predTotalNotLimited) / nSamplesNotLimited), predCounts)
 DCSP from nupic.math.cross import cross DCNL DCSP shape = spaceShape DCNL DCSP if ((shape[0] == 1) and (shape[1] == 1)): DCNL DCSP  DCSP centerOffsets = [(0, 0)] DCNL DCSP else: DCNL DCSP  DCSP xMin = ((-1) * (shape[1] // 2)) DCNL DCSP  DCSP xMax = ((xMin + shape[1]) - 1) DCNL DCSP  DCSP xPositions = range((stepSize * xMin), ((stepSize * xMax) + 1), stepSize) DCNL DCSP  DCSP yMin = ((-1) * (shape[0] // 2)) DCNL DCSP  DCSP yMax = ((yMin + shape[0]) - 1) DCNL DCSP  DCSP yPositions = range((stepSize * yMin), ((stepSize * yMax) + 1), stepSize) DCNL DCSP  DCSP centerOffsets = list(cross(yPositions, xPositions)) DCNL DCSP numCenterOffsets = len(centerOffsets) DCNL DCSP print 'centerOffsets:', centerOffsets DCNL DCSP shape = spreadShape DCNL DCSP if ((shape[0] == 1) and (shape[1] == 1)): DCNL DCSP  DCSP spreadOffsets = [(0, 0)] DCNL DCSP else: DCNL DCSP  DCSP xMin = ((-1) * (shape[1] // 2)) DCNL DCSP  DCSP xMax = ((xMin + shape[1]) - 1) DCNL DCSP  DCSP xPositions = range((stepSize * xMin), ((stepSize * xMax) + 1), stepSize) DCNL DCSP  DCSP yMin = ((-1) * (shape[0] // 2)) DCNL DCSP  DCSP yMax = ((yMin + shape[0]) - 1) DCNL DCSP  DCSP yPositions = range((stepSize * yMin), ((stepSize * yMax) + 1), stepSize) DCNL DCSP  DCSP spreadOffsets = list(cross(yPositions, xPositions)) DCNL DCSP  DCSP spreadOffsets.remove((0, 0)) DCNL DCSP  DCSP spreadOffsets.insert(0, (0, 0)) DCNL DCSP numSpreadOffsets = len(spreadOffsets) DCNL DCSP print 'spreadOffsets:', spreadOffsets DCNL DCSP return (centerOffsets, spreadOffsets)
 DCSP if (outputCloningHeight < 0): DCNL DCSP  DCSP outputCloningHeight = outputCloningWidth DCNL DCSP (columnsHeight, columnsWidth) = columnsShape DCNL DCSP numDistinctMasters = (outputCloningWidth * outputCloningHeight) DCNL DCSP a = numpy.empty((columnsHeight, columnsWidth), 'uint32') DCNL DCSP for row in xrange(columnsHeight): DCNL DCSP  DCSP for col in xrange(columnsWidth): DCNL DCSP  DCSP  DCSP a[(row, col)] = ((col % outputCloningWidth) + ((row % outputCloningHeight) * outputCloningWidth)) DCNL DCSP return (a, numDistinctMasters)
 DCSP shape = array.shape DCNL DCSP assert (len(shape) <= 2) DCNL DCSP items = ['['] DCNL DCSP if (len(shape) == 1): DCNL DCSP  DCSP if includeIndices: DCNL DCSP  DCSP  DCSP format = ('%d:' + format) DCNL DCSP  DCSP  DCSP if includeZeros: DCNL DCSP  DCSP  DCSP  DCSP rowItems = [(format % (c, x)) for (c, x) in enumerate(array)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rowItems = [(format % (c, x)) for (c, x) in enumerate(array) if (x != 0)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rowItems = [(format % x) for x in array] DCNL DCSP  DCSP items.extend(rowItems) DCNL DCSP else: DCNL DCSP  DCSP (rows, cols) = shape DCNL DCSP  DCSP if includeIndices: DCNL DCSP  DCSP  DCSP format = ('%d,%d:' + format) DCNL DCSP  DCSP for r in xrange(rows): DCNL DCSP  DCSP  DCSP if includeIndices: DCNL DCSP  DCSP  DCSP  DCSP rowItems = [(format % (r, c, x)) for (c, x) in enumerate(array[r])] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rowItems = [(format % x) for x in array[r]] DCNL DCSP  DCSP  DCSP if (r > 0): DCNL DCSP  DCSP  DCSP  DCSP items.append('') DCNL DCSP  DCSP  DCSP items.append('[') DCNL DCSP  DCSP  DCSP items.extend(rowItems) DCNL DCSP  DCSP  DCSP if (r < (rows - 1)): DCNL DCSP  DCSP  DCSP  DCSP items.append(']\n') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP items.append(']') DCNL DCSP items.append(']') DCNL DCSP return ' DCSP '.join(items)
 DCSP if (cellsPerCol == 0): DCNL DCSP  DCSP cellsPerCol = 1 DCNL DCSP cols = (activeInputs.size / cellsPerCol) DCNL DCSP activeInputs = activeInputs.reshape(cols, cellsPerCol) DCNL DCSP (cols, cellIdxs) = activeInputs.nonzero() DCNL DCSP if (len(cols) == 0): DCNL DCSP  DCSP return 'NONE' DCNL DCSP items = [('(%d): DCSP ' % len(cols))] DCNL DCSP prevCol = (-1) DCNL DCSP for (col, cellIdx) in zip(cols, cellIdxs): DCNL DCSP  DCSP if (col != prevCol): DCNL DCSP  DCSP  DCSP if (prevCol != (-1)): DCNL DCSP  DCSP  DCSP  DCSP items.append('] DCSP ') DCNL DCSP  DCSP  DCSP items.append(('Col DCSP %d: DCSP [' % col)) DCNL DCSP  DCSP  DCSP prevCol = col DCNL DCSP  DCSP items.append(('%d,' % cellIdx)) DCNL DCSP items.append(']') DCNL DCSP return ' DCSP '.join(items)
 DCSP nActiveColumns = len(activeColumns) DCNL DCSP if (nActiveColumns > 0): DCNL DCSP  DCSP score = numpy.in1d(activeColumns, prevPredictedColumns).sum() DCNL DCSP  DCSP score = ((nActiveColumns - score) / float(nActiveColumns)) DCNL DCSP else: DCNL DCSP  DCSP score = 0.0 DCNL DCSP return score
 DCSP import sys DCNL DCSP originalPath = sys.path DCNL DCSP try: DCNL DCSP  DCSP augmentedPath = ([path] + sys.path) DCNL DCSP  DCSP sys.path = augmentedPath DCNL DCSP  DCSP func = getattr(__import__(moduleName, fromlist=[funcName]), funcName) DCNL DCSP  DCSP sys.path = originalPath DCNL DCSP except: DCNL DCSP  DCSP sys.path = originalPath DCNL DCSP  DCSP raise DCNL DCSP return func(**keywords)
 DCSP fullExpression = (('__import__("nupic.bindings.research", DCSP fromlist=["lockHandle"]).lockHandle( DCSP ' + expression) + ' DCSP )') DCNL DCSP return runtimeElement.interpret(fullExpression)
 DCSP coincidenceHandle = getLockedHandle(runtimeElement=network.getElement(fromElementName), expression='self._cd._W') DCNL DCSP network.getElement(toElementName).setParameter('coincidencesAbove', coincidenceHandle)
 DCSP import inspect DCNL DCSP import copy DCNL DCSP callingFrame = inspect.stack()[1][0] DCNL DCSP (argNames, _, _, frameLocalVarDict) = inspect.getargvalues(callingFrame) DCNL DCSP argNames.remove('self') DCNL DCSP args = copy.copy(frameLocalVarDict) DCNL DCSP for varName in frameLocalVarDict: DCNL DCSP  DCSP if (varName not in argNames): DCNL DCSP  DCSP  DCSP args.pop(varName) DCNL DCSP return args
 DCSP if (verbosity > 1): DCNL DCSP  DCSP print 'In DCSP estimateAnomalyLikelihoods.' DCNL DCSP  DCSP print ('Number DCSP of DCSP anomaly DCSP scores:', len(anomalyScores)) DCNL DCSP  DCSP print ('Skip DCSP records=', skipRecords) DCNL DCSP  DCSP print ('First DCSP 20:', anomalyScores[0:min(20, len(anomalyScores))]) DCNL DCSP if (len(anomalyScores) == 0): DCNL DCSP  DCSP raise ValueError('Must DCSP have DCSP at DCSP least DCSP one DCSP anomalyScore') DCNL DCSP (aggRecordList, historicalValues, total) = _anomalyScoreMovingAverage(anomalyScores, windowSize=averagingWindow, verbosity=verbosity) DCNL DCSP s = [r[2] for r in aggRecordList] DCNL DCSP dataValues = numpy.array(s) DCNL DCSP if (len(aggRecordList) <= skipRecords): DCNL DCSP  DCSP distributionParams = nullDistribution(verbosity=verbosity) DCNL DCSP else: DCNL DCSP  DCSP distributionParams = estimateNormal(dataValues[skipRecords:]) DCNL DCSP  DCSP s = [r[1] for r in aggRecordList] DCNL DCSP  DCSP if all([isinstance(r[1], numbers.Number) for r in aggRecordList]): DCNL DCSP  DCSP  DCSP metricValues = numpy.array(s) DCNL DCSP  DCSP  DCSP metricDistribution = estimateNormal(metricValues[skipRecords:], performLowerBoundCheck=False) DCNL DCSP  DCSP  DCSP if (metricDistribution['variance'] < 1.5e-05): DCNL DCSP  DCSP  DCSP  DCSP distributionParams = nullDistribution(verbosity=verbosity) DCNL DCSP likelihoods = numpy.array(dataValues, dtype=float) DCNL DCSP for (i, s) in enumerate(dataValues): DCNL DCSP  DCSP likelihoods[i] = tailProbability(s, distributionParams) DCNL DCSP filteredLikelihoods = numpy.array(_filterLikelihoods(likelihoods)) DCNL DCSP params = {'distribution': distributionParams, 'movingAverage': {'historicalValues': historicalValues, 'total': total, 'windowSize': averagingWindow}, 'historicalLikelihoods': list(likelihoods[(- min(averagingWindow, len(likelihoods))):])} DCNL DCSP if (verbosity > 1): DCNL DCSP  DCSP print 'Discovered DCSP params=' DCNL DCSP  DCSP print params DCNL DCSP  DCSP print ('Number DCSP of DCSP likelihoods:', len(likelihoods)) DCNL DCSP  DCSP print ('First DCSP 20 DCSP likelihoods:', filteredLikelihoods[0:min(20, len(filteredLikelihoods))]) DCNL DCSP  DCSP print 'leaving DCSP estimateAnomalyLikelihoods' DCNL DCSP return (filteredLikelihoods, aggRecordList, params)
 DCSP if (verbosity > 3): DCNL DCSP  DCSP print 'In DCSP updateAnomalyLikelihoods.' DCNL DCSP  DCSP print ('Number DCSP of DCSP anomaly DCSP scores:', len(anomalyScores)) DCNL DCSP  DCSP print ('First DCSP 20:', anomalyScores[0:min(20, len(anomalyScores))]) DCNL DCSP  DCSP print ('Params:', params) DCNL DCSP if (len(anomalyScores) == 0): DCNL DCSP  DCSP raise ValueError('Must DCSP have DCSP at DCSP least DCSP one DCSP anomalyScore') DCNL DCSP if (not isValidEstimatorParams(params)): DCNL DCSP  DCSP raise ValueError("'params' DCSP is DCSP not DCSP a DCSP valid DCSP params DCSP structure") DCNL DCSP if ('historicalLikelihoods' not in params): DCNL DCSP  DCSP params['historicalLikelihoods'] = [1.0] DCNL DCSP historicalValues = params['movingAverage']['historicalValues'] DCNL DCSP total = params['movingAverage']['total'] DCNL DCSP windowSize = params['movingAverage']['windowSize'] DCNL DCSP aggRecordList = numpy.zeros(len(anomalyScores), dtype=float) DCNL DCSP likelihoods = numpy.zeros(len(anomalyScores), dtype=float) DCNL DCSP for (i, v) in enumerate(anomalyScores): DCNL DCSP  DCSP (newAverage, historicalValues, total) = MovingAverage.compute(historicalValues, total, v[2], windowSize) DCNL DCSP  DCSP aggRecordList[i] = newAverage DCNL DCSP  DCSP likelihoods[i] = tailProbability(newAverage, params['distribution']) DCNL DCSP likelihoods2 = (params['historicalLikelihoods'] + list(likelihoods)) DCNL DCSP filteredLikelihoods = _filterLikelihoods(likelihoods2) DCNL DCSP likelihoods[:] = filteredLikelihoods[(- len(likelihoods)):] DCNL DCSP historicalLikelihoods = likelihoods2[(- min(windowSize, len(likelihoods2))):] DCNL DCSP newParams = {'distribution': params['distribution'], 'movingAverage': {'historicalValues': historicalValues, 'total': total, 'windowSize': windowSize}, 'historicalLikelihoods': historicalLikelihoods} DCNL DCSP assert (len(newParams['historicalLikelihoods']) <= windowSize) DCNL DCSP if (verbosity > 3): DCNL DCSP  DCSP print ('Number DCSP of DCSP likelihoods:', len(likelihoods)) DCNL DCSP  DCSP print ('First DCSP 20 DCSP likelihoods:', likelihoods[0:min(20, len(likelihoods))]) DCNL DCSP  DCSP print 'Leaving DCSP updateAnomalyLikelihoods.' DCNL DCSP return (likelihoods, aggRecordList, newParams)
 DCSP redThreshold = (1.0 - redThreshold) DCNL DCSP yellowThreshold = (1.0 - yellowThreshold) DCNL DCSP filteredLikelihoods = [likelihoods[0]] DCNL DCSP for (i, v) in enumerate(likelihoods[1:]): DCNL DCSP  DCSP if (v <= redThreshold): DCNL DCSP  DCSP  DCSP if (likelihoods[i] > redThreshold): DCNL DCSP  DCSP  DCSP  DCSP filteredLikelihoods.append(v) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP filteredLikelihoods.append(yellowThreshold) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filteredLikelihoods.append(v) DCNL DCSP return filteredLikelihoods
 DCSP historicalValues = [] DCNL DCSP total = 0.0 DCNL DCSP averagedRecordList = [] DCNL DCSP for record in anomalyScores: DCNL DCSP  DCSP if ((not isinstance(record, (list, tuple))) or (len(record) != 3)): DCNL DCSP  DCSP  DCSP if (verbosity >= 1): DCNL DCSP  DCSP  DCSP  DCSP print ('Malformed DCSP record:', record) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (avg, historicalValues, total) = MovingAverage.compute(historicalValues, total, record[2], windowSize) DCNL DCSP  DCSP averagedRecordList.append([record[0], record[1], avg]) DCNL DCSP  DCSP if (verbosity > 2): DCNL DCSP  DCSP  DCSP print ('Aggregating DCSP input DCSP record:', record) DCNL DCSP  DCSP  DCSP print ('Result:', [record[0], record[1], avg]) DCNL DCSP return (averagedRecordList, historicalValues, total)
 DCSP params = {'name': 'normal', 'mean': numpy.mean(sampleData), 'variance': numpy.var(sampleData)} DCNL DCSP if performLowerBoundCheck: DCNL DCSP  DCSP if (params['mean'] < 0.03): DCNL DCSP  DCSP  DCSP params['mean'] = 0.03 DCNL DCSP  DCSP if (params['variance'] < 0.0003): DCNL DCSP  DCSP  DCSP params['variance'] = 0.0003 DCNL DCSP if (params['variance'] > 0): DCNL DCSP  DCSP params['stdev'] = math.sqrt(params['variance']) DCNL DCSP else: DCNL DCSP  DCSP params['stdev'] = 0 DCNL DCSP return params
 DCSP if (verbosity > 0): DCNL DCSP  DCSP print 'Returning DCSP nullDistribution' DCNL DCSP return {'name': 'normal', 'mean': 0.5, 'variance': 1000000.0, 'stdev': 1000.0}
 DCSP if (('mean' not in distributionParams) or ('stdev' not in distributionParams)): DCNL DCSP  DCSP raise RuntimeError('Insufficient DCSP parameters DCSP to DCSP specify DCSP the DCSP distribution.') DCNL DCSP if (x < distributionParams['mean']): DCNL DCSP  DCSP xp = ((2 * distributionParams['mean']) - x) DCNL DCSP  DCSP return tailProbability(xp, distributionParams) DCNL DCSP z = ((x - distributionParams['mean']) / distributionParams['stdev']) DCNL DCSP return (0.5 * math.erfc((z / 1.4142)))
 DCSP if (not isinstance(p, dict)): DCNL DCSP  DCSP return False DCNL DCSP if ('distribution' not in p): DCNL DCSP  DCSP return False DCNL DCSP if ('movingAverage' not in p): DCNL DCSP  DCSP return False DCNL DCSP dist = p['distribution'] DCNL DCSP if (not (('mean' in dist) and ('name' in dist) and ('variance' in dist) and ('stdev' in dist))): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP return (('[ DCSP ' + ' DCSP '.join(((fmt % x) for x in array_))) + ' DCSP ]')
 DCSP i = bisect_left(arr, val) DCNL DCSP if ((i != len(arr)) and (arr[i] == val)): DCNL DCSP  DCSP return i DCNL DCSP return (-1)
 DCSP import inspect DCNL DCSP frameObj = inspect.stack()[2][0] DCNL DCSP return inspect.getframeinfo(frameObj)
 DCSP return 'cpp'
 DCSP if (spatialImp == 'py'): DCNL DCSP  DCSP return PYSpatialPooler DCNL DCSP elif (spatialImp == 'cpp'): DCNL DCSP  DCSP return CPPSpatialPooler DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(("Invalid DCSP spatialImp DCSP '%s'. DCSP Legal DCSP values DCSP are: DCSP 'py', DCSP 'cpp'" % spatialImp))
 DCSP argTuples = getArgumentDescriptions(f) DCNL DCSP argTuples = argTuples[1:] DCNL DCSP init = SPRegion.__init__ DCNL DCSP ourArgNames = [t[0] for t in getArgumentDescriptions(init)] DCNL DCSP ourArgNames += ['numberOfCols'] DCNL DCSP for argTuple in argTuples[:]: DCNL DCSP  DCSP if (argTuple[0] in ourArgNames): DCNL DCSP  DCSP  DCSP argTuples.remove(argTuple) DCNL DCSP if self: DCNL DCSP  DCSP for argTuple in argTuples: DCNL DCSP  DCSP  DCSP argName = argTuple[0] DCNL DCSP  DCSP  DCSP if (argName in kwargs): DCNL DCSP  DCSP  DCSP  DCSP argValue = kwargs.pop(argName) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (len(argTuple) == 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError(("Must DCSP provide DCSP value DCSP for DCSP '%s'" % argName)) DCNL DCSP  DCSP  DCSP  DCSP argValue = argTuple[2] DCNL DCSP  DCSP  DCSP setattr(self, argName, argValue) DCNL DCSP return argTuples
 DCSP typeNames = {int: 'UInt32', float: 'Real32', str: 'Byte', bool: 'bool', tuple: 'tuple'} DCNL DCSP def getArgType(arg): DCNL DCSP  DCSP t = typeNames.get(type(arg), 'Byte') DCNL DCSP  DCSP count = (0 if (t == 'Byte') else 1) DCNL DCSP  DCSP if (t == 'tuple'): DCNL DCSP  DCSP  DCSP t = typeNames.get(type(arg[0]), 'Byte') DCNL DCSP  DCSP  DCSP count = len(arg) DCNL DCSP  DCSP if (t == 'bool'): DCNL DCSP  DCSP  DCSP t = 'UInt32' DCNL DCSP  DCSP return (t, count) DCNL DCSP def getConstraints(arg): DCNL DCSP  DCSP t = typeNames.get(type(arg), 'Byte') DCNL DCSP  DCSP if (t == 'Byte'): DCNL DCSP  DCSP  DCSP return 'multiple' DCNL DCSP  DCSP elif (t == 'bool'): DCNL DCSP  DCSP  DCSP return 'bool' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP SpatialClass = getSPClass(spatialImp) DCNL DCSP sArgTuples = _buildArgs(SpatialClass.__init__) DCNL DCSP spatialSpec = {} DCNL DCSP for argTuple in sArgTuples: DCNL DCSP  DCSP d = dict(description=argTuple[1], accessMode='ReadWrite', dataType=getArgType(argTuple[2])[0], count=getArgType(argTuple[2])[1], constraints=getConstraints(argTuple[2])) DCNL DCSP  DCSP spatialSpec[argTuple[0]] = d DCNL DCSP spatialSpec.update(dict(columnCount=dict(description='Total DCSP number DCSP of DCSP columns DCSP (coincidences).', accessMode='Read', dataType='UInt32', count=1, constraints=''), inputWidth=dict(description='Size DCSP of DCSP inputs DCSP to DCSP the DCSP SP.', accessMode='Read', dataType='UInt32', count=1, constraints=''), spInputNonZeros=dict(description='The DCSP indices DCSP of DCSP the DCSP non-zero DCSP inputs DCSP to DCSP the DCSP spatial DCSP pooler', accessMode='Read', dataType='UInt32', count=0, constraints=''), spOutputNonZeros=dict(description='The DCSP indices DCSP of DCSP the DCSP non-zero DCSP outputs DCSP from DCSP the DCSP spatial DCSP pooler', accessMode='Read', dataType='UInt32', count=0, constraints=''), spOverlapDistribution=dict(description='The DCSP overlaps DCSP between DCSP the DCSP active DCSP output DCSP coincidences\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP and DCSP the DCSP input. DCSP The DCSP overlap DCSP amounts DCSP for DCSP each DCSP coincidence DCSP are DCSP sorted\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP highest DCSP to DCSP lowest. DCSP ', accessMode='Read', dataType='Real32', count=0, constraints=''), sparseCoincidenceMatrix=dict(description='The DCSP coincidences, DCSP as DCSP a DCSP SparseMatrix', accessMode='Read', dataType='Byte', count=0, constraints=''), denseOutput=dict(description='Score DCSP for DCSP each DCSP coincidence.', accessMode='Read', dataType='Real32', count=0, constraints=''), spLearningStatsStr=dict(description='String DCSP representation DCSP of DCSP dictionary DCSP containing DCSP a DCSP number\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP of DCSP statistics DCSP related DCSP to DCSP learning.', accessMode='Read', dataType='Byte', count=0, constraints='handle'), spatialImp=dict(description="Which DCSP spatial DCSP pooler DCSP implementation DCSP to DCSP use. DCSP Set DCSP to DCSP either\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 'py', DCSP or DCSP 'cpp'. DCSP The DCSP 'cpp' DCSP implementation DCSP is DCSP optimized DCSP for\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP speed DCSP in DCSP C++.", accessMode='ReadWrite', dataType='Byte', count=0, constraints='enum: DCSP py, DCSP cpp'))) DCNL DCSP otherSpec = dict(learningMode=dict(description='1 DCSP if DCSP the DCSP node DCSP is DCSP learning DCSP (default DCSP 1).', accessMode='ReadWrite', dataType='UInt32', count=1, constraints='bool'), inferenceMode=dict(description='1 DCSP if DCSP the DCSP node DCSP is DCSP inferring DCSP (default DCSP 0).', accessMode='ReadWrite', dataType='UInt32', count=1, constraints='bool'), anomalyMode=dict(description='1 DCSP if DCSP an DCSP anomaly DCSP score DCSP is DCSP being DCSP computed', accessMode='ReadWrite', dataType='UInt32', count=1, constraints='bool'), topDownMode=dict(description='1 DCSP if DCSP the DCSP node DCSP should DCSP do DCSP top DCSP down DCSP compute DCSP on DCSP the DCSP next DCSP call DCSP to DCSP compute DCSP into DCSP topDownOut DCSP (default DCSP 0).', accessMode='ReadWrite', dataType='UInt32', count=1, constraints='bool'), activeOutputCount=dict(description='Number DCSP of DCSP active DCSP elements DCSP in DCSP bottomUpOut DCSP output.', accessMode='Read', dataType='UInt32', count=1, constraints=''), logPathInput=dict(description='Optional DCSP name DCSP of DCSP input DCSP log DCSP file. DCSP If DCSP set, DCSP every DCSP input DCSP vector DCSP will DCSP be DCSP logged DCSP to DCSP this DCSP file.', accessMode='ReadWrite', dataType='Byte', count=0, constraints=''), logPathOutput=dict(description='Optional DCSP name DCSP of DCSP output DCSP log DCSP file. DCSP If DCSP set, DCSP every DCSP output DCSP vector DCSP will DCSP be DCSP logged DCSP to DCSP this DCSP file.', accessMode='ReadWrite', dataType='Byte', count=0, constraints=''), logPathOutputDense=dict(description='Optional DCSP name DCSP of DCSP output DCSP log DCSP file. DCSP If DCSP set, DCSP every DCSP output DCSP vector DCSP will DCSP be DCSP logged DCSP to DCSP this DCSP file DCSP as DCSP a DCSP dense DCSP vector.', accessMode='ReadWrite', dataType='Byte', count=0, constraints='')) DCNL DCSP return (spatialSpec, otherSpec)
 DCSP if (temporalImp == 'py'): DCNL DCSP  DCSP return backtracking_tm.BacktrackingTM DCNL DCSP elif (temporalImp == 'cpp'): DCNL DCSP  DCSP return backtracking_tm_cpp.BacktrackingTMCPP DCNL DCSP elif (temporalImp == 'tm_py'): DCNL DCSP  DCSP return backtracking_tm_shim.TMShim DCNL DCSP elif (temporalImp == 'tm_cpp'): DCNL DCSP  DCSP return backtracking_tm_shim.TMCPPShim DCNL DCSP elif (temporalImp == 'monitored_tm_py'): DCNL DCSP  DCSP return backtracking_tm_shim.MonitoredTMShim DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(("Invalid DCSP temporalImp DCSP '%s'. DCSP Legal DCSP values DCSP are: DCSP 'py', DCSP 'cpp', DCSP 'tm_py', DCSP 'monitored_tm_py'" % temporalImp))
 DCSP argTuples = getArgumentDescriptions(f) DCNL DCSP argTuples = argTuples[1:] DCNL DCSP init = TMRegion.__init__ DCNL DCSP ourArgNames = [t[0] for t in getArgumentDescriptions(init)] DCNL DCSP ourArgNames += ['numberOfCols'] DCNL DCSP for argTuple in argTuples[:]: DCNL DCSP  DCSP if (argTuple[0] in ourArgNames): DCNL DCSP  DCSP  DCSP argTuples.remove(argTuple) DCNL DCSP if self: DCNL DCSP  DCSP for argTuple in argTuples: DCNL DCSP  DCSP  DCSP argName = argTuple[0] DCNL DCSP  DCSP  DCSP if (argName in kwargs): DCNL DCSP  DCSP  DCSP  DCSP argValue = kwargs.pop(argName) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (len(argTuple) == 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError(("Must DCSP provide DCSP '%s'" % argName)) DCNL DCSP  DCSP  DCSP  DCSP argValue = argTuple[2] DCNL DCSP  DCSP  DCSP setattr(self, argName, argValue) DCNL DCSP return argTuples
 DCSP typeNames = {int: 'UInt32', float: 'Real32', str: 'Byte', bool: 'bool', tuple: 'tuple'} DCNL DCSP def getArgType(arg): DCNL DCSP  DCSP t = typeNames.get(type(arg), 'Byte') DCNL DCSP  DCSP count = (0 if (t == 'Byte') else 1) DCNL DCSP  DCSP if (t == 'tuple'): DCNL DCSP  DCSP  DCSP t = typeNames.get(type(arg[0]), 'Byte') DCNL DCSP  DCSP  DCSP count = len(arg) DCNL DCSP  DCSP if (t == 'bool'): DCNL DCSP  DCSP  DCSP t = 'UInt32' DCNL DCSP  DCSP return (t, count) DCNL DCSP def getConstraints(arg): DCNL DCSP  DCSP t = typeNames.get(type(arg), 'Byte') DCNL DCSP  DCSP if (t == 'Byte'): DCNL DCSP  DCSP  DCSP return 'multiple' DCNL DCSP  DCSP elif (t == 'bool'): DCNL DCSP  DCSP  DCSP return 'bool' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP TemporalClass = _getTPClass(temporalImp) DCNL DCSP tArgTuples = _buildArgs(TemporalClass.__init__) DCNL DCSP temporalSpec = {} DCNL DCSP for argTuple in tArgTuples: DCNL DCSP  DCSP d = dict(description=argTuple[1], accessMode='ReadWrite', dataType=getArgType(argTuple[2])[0], count=getArgType(argTuple[2])[1], constraints=getConstraints(argTuple[2])) DCNL DCSP  DCSP temporalSpec[argTuple[0]] = d DCNL DCSP temporalSpec.update(dict(columnCount=dict(description='Total DCSP number DCSP of DCSP columns.', accessMode='Read', dataType='UInt32', count=1, constraints=''), cellsPerColumn=dict(description='Number DCSP of DCSP cells DCSP per DCSP column.', accessMode='Read', dataType='UInt32', count=1, constraints=''), inputWidth=dict(description='Number DCSP of DCSP inputs DCSP to DCSP the DCSP TM.', accessMode='Read', dataType='UInt32', count=1, constraints=''), predictedSegmentDecrement=dict(description='Predicted DCSP segment DCSP decrement', accessMode='Read', dataType='Real', count=1, constraints=''), orColumnOutputs=dict(description='OR DCSP together DCSP the DCSP cell DCSP outputs DCSP from DCSP each DCSP column DCSP to DCSP produce\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP temporal DCSP memory DCSP output. DCSP When DCSP this DCSP mode DCSP is DCSP enabled, DCSP the DCSP number DCSP of\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cells DCSP per DCSP column DCSP must DCSP also DCSP be DCSP specified DCSP and DCSP the DCSP output DCSP size DCSP of DCSP the DCSP region\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP should DCSP be DCSP set DCSP the DCSP same DCSP as DCSP columnCount', accessMode='Read', dataType='Bool', count=1, constraints='bool'), cellsSavePath=dict(description='Optional DCSP path DCSP to DCSP file DCSP in DCSP which DCSP large DCSP temporal DCSP memory DCSP cells\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP data DCSP structure DCSP is DCSP to DCSP be DCSP saved.', accessMode='ReadWrite', dataType='Byte', count=0, constraints=''), temporalImp=dict(description="Which DCSP temporal DCSP memory DCSP implementation DCSP to DCSP use. DCSP Set DCSP to DCSP either\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 'py' DCSP or DCSP 'cpp'. DCSP The DCSP 'cpp' DCSP implementation DCSP is DCSP optimized DCSP for DCSP speed DCSP in DCSP C++.", accessMode='ReadWrite', dataType='Byte', count=0, constraints='enum: DCSP py, DCSP cpp'))) DCNL DCSP otherSpec = dict(learningMode=dict(description='True DCSP if DCSP the DCSP node DCSP is DCSP learning DCSP (default DCSP True).', accessMode='ReadWrite', dataType='Bool', count=1, defaultValue=True, constraints='bool'), inferenceMode=dict(description='True DCSP if DCSP the DCSP node DCSP is DCSP inferring DCSP (default DCSP False).', accessMode='ReadWrite', dataType='Bool', count=1, defaultValue=False, constraints='bool'), computePredictedActiveCellIndices=dict(description='True DCSP if DCSP active DCSP and DCSP predicted DCSP active DCSP indices DCSP should DCSP be DCSP computed', accessMode='Create', dataType='Bool', count=1, defaultValue=False, constraints='bool'), anomalyMode=dict(description='True DCSP if DCSP an DCSP anomaly DCSP score DCSP is DCSP being DCSP computed', accessMode='Create', dataType='Bool', count=1, defaultValue=False, constraints='bool'), topDownMode=dict(description='True DCSP if DCSP the DCSP node DCSP should DCSP do DCSP top DCSP down DCSP compute DCSP on DCSP the DCSP next DCSP call DCSP to DCSP compute DCSP into DCSP topDownOut DCSP (default DCSP False).', accessMode='ReadWrite', dataType='Bool', count=1, defaultValue=False, constraints='bool'), activeOutputCount=dict(description='Number DCSP of DCSP active DCSP elements DCSP in DCSP bottomUpOut DCSP output.', accessMode='Read', dataType='UInt32', count=1, constraints=''), storeDenseOutput=dict(description='Whether DCSP to DCSP keep DCSP the DCSP dense DCSP column DCSP output DCSP (needed DCSP for\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP denseOutput DCSP parameter).', accessMode='ReadWrite', dataType='UInt32', count=1, constraints='bool'), logPathOutput=dict(description='Optional DCSP name DCSP of DCSP output DCSP log DCSP file. DCSP If DCSP set, DCSP every DCSP output DCSP vector DCSP will DCSP be DCSP logged DCSP to DCSP this DCSP file DCSP as DCSP a DCSP sparse DCSP vector.', accessMode='ReadWrite', dataType='Byte', count=0, constraints='')) DCNL DCSP return (temporalSpec, otherSpec)
 DCSP try: DCNL DCSP  DCSP line = f.next() DCNL DCSP  DCSP while (line == ',,,,,,,,,,,,,,,,,,,\n'): DCNL DCSP  DCSP  DCSP line = f.next() DCNL DCSP  DCSP name = line.split(',')[0] DCNL DCSP  DCSP if (name not in clubs): DCNL DCSP  DCSP  DCSP clubs[name] = Club(name) DCNL DCSP  DCSP c = clubs[name] DCNL DCSP  DCSP c.processAttendance(f) DCNL DCSP  DCSP return True DCNL DCSP except StopIteration: DCNL DCSP  DCSP return False
 DCSP try: DCNL DCSP  DCSP line = f.next() DCNL DCSP  DCSP assert line.endswith('" DCSP  DCSP  DCSP ","SITE_LOCATION_NAME","TIMESTAMP","TOTAL_KWH"\n') DCNL DCSP  DCSP valid_times = range(24) DCNL DCSP  DCSP t = 0 DCNL DCSP  DCSP club = None DCNL DCSP  DCSP clubName = None DCNL DCSP  DCSP lastDate = None DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP assert (t in valid_times) DCNL DCSP  DCSP  DCSP consumption = 0 DCNL DCSP  DCSP  DCSP for x in range(4): DCNL DCSP  DCSP  DCSP  DCSP line = f.next()[:(-1)] DCNL DCSP  DCSP  DCSP  DCSP fields = line.split(',') DCNL DCSP  DCSP  DCSP  DCSP assert (len(fields) == 4) DCNL DCSP  DCSP  DCSP  DCSP for (i, field) in enumerate(fields): DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert ((field[0] == '"') and (field[(-1)] == '"')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP fields[i] = field[1:(-1)] DCNL DCSP  DCSP  DCSP  DCSP name = fields[1] DCNL DCSP  DCSP  DCSP  DCSP partialNames = ('Melbourne DCSP Central', 'North DCSP Sydney', 'Park DCSP St', 'Pitt DCSP St') DCNL DCSP  DCSP  DCSP  DCSP for pn in partialNames: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (pn in name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name = pn DCNL DCSP  DCSP  DCSP  DCSP if (name != clubName): DCNL DCSP  DCSP  DCSP  DCSP  DCSP clubName = name DCNL DCSP  DCSP  DCSP  DCSP  DCSP club = clubs[name] DCNL DCSP  DCSP  DCSP  DCSP tokens = fields[2].split() DCNL DCSP  DCSP  DCSP  DCSP if (len(tokens) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert ((consumption == 0) and (t == 0)) DCNL DCSP  DCSP  DCSP  DCSP date = tokens[0] DCNL DCSP  DCSP  DCSP  DCSP consumption += float(fields[3]) DCNL DCSP  DCSP  DCSP club.updateRecord(date, t, consumption) DCNL DCSP  DCSP  DCSP t += 1 DCNL DCSP  DCSP  DCSP t %= 24 DCNL DCSP except StopIteration: DCNL DCSP  DCSP return
 DCSP files = glob.glob('all_group*detail.csv') DCNL DCSP f = fileinput.input(files=files) DCNL DCSP while processClubConsumption(f, clubs): DCNL DCSP  DCSP pass DCNL DCSP return clubs
 DCSP clubs = processAttendanceFiles() DCNL DCSP clubs = processConsumptionFiles(clubs) DCNL DCSP fields = [('gym', 'string', 'S'), ('timestamp', 'datetime', 'T'), ('attendeeCount', 'int', ''), ('consumption', 'float', '')] DCNL DCSP with File('gym.csv', fields) as f: DCNL DCSP  DCSP for c in clubs.values(): DCNL DCSP  DCSP  DCSP for (k, r) in sorted(c.records.iteritems(), key=operator.itemgetter(0)): DCNL DCSP  DCSP  DCSP  DCSP f.write([r.club, r.timestamp, r.attendeeCount, r.consumption])
 DCSP data = generateLinearData(numDataPoints=(numTrainingRecords + numTestingRecords), coefficients=coefficients, noiseLevel=noiseLevel, dataScale=dataScale) DCNL DCSP trainData = data[:numTrainingRecords] DCNL DCSP testData = data[numTrainingRecords:] DCNL DCSP return (trainData, testData)
 DCSP print ('Creating DCSP %s...' % filename) DCNL DCSP (numRecords, numFields) = data.shape DCNL DCSP fields = [(('field%d' % (i + 1)), 'float', '') for i in range(numFields)] DCNL DCSP outFile = File(filename, fields) DCNL DCSP for i in xrange(numRecords): DCNL DCSP  DCSP outFile.write(data[i].tolist()) DCNL DCSP outFile.close()
 DCSP numpy.random.seed(41) DCNL DCSP if (model == 'linear0'): DCNL DCSP  DCSP (trainData, testData) = _generateLinearModel(numTrainingRecords, numTestingRecords, coefficients=[1], noiseLevel=0.1) DCNL DCSP elif (model == 'linear1'): DCNL DCSP  DCSP (trainData, testData) = _generateLinearModel(numTrainingRecords, numTestingRecords, coefficients=[1, 1], noiseLevel=0.1) DCNL DCSP elif (model == 'linear2'): DCNL DCSP  DCSP (trainData, testData) = _generateLinearModel(numTrainingRecords, numTestingRecords, coefficients=[1, (-3)]) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('Unsupported DCSP model') DCNL DCSP _generateFile(filename=filenameTrain, data=trainData) DCNL DCSP _generateFile(filename=filenameTest, data=testData)
 DCSP initProb = numpy.zeros(numCategories) DCNL DCSP initProb[0] = 0.5 DCNL DCSP initProb[4] = 0.5 DCNL DCSP firstOrder = dict() DCNL DCSP for catIdx in range(numCategories): DCNL DCSP  DCSP key = str([catIdx]) DCNL DCSP  DCSP probs = (numpy.ones(numCategories) / numCategories) DCNL DCSP  DCSP if ((catIdx == 0) or (catIdx == 4)): DCNL DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP probs[1] = 1.0 DCNL DCSP  DCSP firstOrder[key] = probs DCNL DCSP secondOrder = dict() DCNL DCSP for firstIdx in range(numCategories): DCNL DCSP  DCSP for secondIdx in range(numCategories): DCNL DCSP  DCSP  DCSP key = str([firstIdx, secondIdx]) DCNL DCSP  DCSP  DCSP probs = (numpy.ones(numCategories) / numCategories) DCNL DCSP  DCSP  DCSP if (key == str([0, 1])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[2] = 0.8 DCNL DCSP  DCSP  DCSP  DCSP probs[3] = 0.2 DCNL DCSP  DCSP  DCSP elif (key == str([4, 1])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[2] = 0.2 DCNL DCSP  DCSP  DCSP  DCSP probs[3] = 0.8 DCNL DCSP  DCSP  DCSP secondOrder[key] = probs DCNL DCSP return (initProb, firstOrder, secondOrder, 3)
 DCSP initProb = numpy.zeros(numCategories) DCNL DCSP initProb[0] = 0.5 DCNL DCSP initProb[1] = 0.5 DCNL DCSP firstOrder = dict() DCNL DCSP for catIdx in range(numCategories): DCNL DCSP  DCSP key = str([catIdx]) DCNL DCSP  DCSP probs = (numpy.ones(numCategories) / numCategories) DCNL DCSP  DCSP if ((catIdx == 0) or (catIdx == 1)): DCNL DCSP  DCSP  DCSP indices = numpy.array([10, 11, 12, 13, 14]) DCNL DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP probs[indices] = 1.0 DCNL DCSP  DCSP  DCSP probs /= probs.sum() DCNL DCSP  DCSP firstOrder[key] = probs DCNL DCSP secondOrder = dict() DCNL DCSP for firstIdx in range(numCategories): DCNL DCSP  DCSP for secondIdx in range(numCategories): DCNL DCSP  DCSP  DCSP key = str([firstIdx, secondIdx]) DCNL DCSP  DCSP  DCSP probs = (numpy.ones(numCategories) / numCategories) DCNL DCSP  DCSP  DCSP if (key == str([0, 10])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[15] = 1 DCNL DCSP  DCSP  DCSP elif (key == str([0, 11])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[16] = 1 DCNL DCSP  DCSP  DCSP elif (key == str([0, 12])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[17] = 1 DCNL DCSP  DCSP  DCSP elif (key == str([0, 13])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[18] = 1 DCNL DCSP  DCSP  DCSP elif (key == str([0, 14])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[19] = 1 DCNL DCSP  DCSP  DCSP elif (key == str([1, 10])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[20] = 1 DCNL DCSP  DCSP  DCSP elif (key == str([1, 11])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[21] = 1 DCNL DCSP  DCSP  DCSP elif (key == str([1, 12])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[22] = 1 DCNL DCSP  DCSP  DCSP elif (key == str([1, 13])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[23] = 1 DCNL DCSP  DCSP  DCSP elif (key == str([1, 14])): DCNL DCSP  DCSP  DCSP  DCSP probs.fill(0) DCNL DCSP  DCSP  DCSP  DCSP probs[24] = 1 DCNL DCSP  DCSP  DCSP secondOrder[key] = probs DCNL DCSP return (initProb, firstOrder, secondOrder, 3)
 DCSP initProb = (numpy.ones(numCategories) / numCategories) DCNL DCSP def generatePeakedProbabilities(lastIdx, numCategories=numCategories, alpha=alpha): DCNL DCSP  DCSP probs = numpy.random.dirichlet(alpha=([alpha] * numCategories)) DCNL DCSP  DCSP probs[lastIdx] = 0.0 DCNL DCSP  DCSP probs /= probs.sum() DCNL DCSP  DCSP return probs DCNL DCSP firstOrder = dict() DCNL DCSP for catIdx in range(numCategories): DCNL DCSP  DCSP key = str([catIdx]) DCNL DCSP  DCSP probs = generatePeakedProbabilities(catIdx) DCNL DCSP  DCSP firstOrder[key] = probs DCNL DCSP secondOrder = dict() DCNL DCSP for firstIdx in range(numCategories): DCNL DCSP  DCSP for secondIdx in range(numCategories): DCNL DCSP  DCSP  DCSP key = str([firstIdx, secondIdx]) DCNL DCSP  DCSP  DCSP probs = generatePeakedProbabilities(secondIdx) DCNL DCSP  DCSP  DCSP secondOrder[key] = probs DCNL DCSP return (initProb, firstOrder, secondOrder, None)
 DCSP print ('Creating DCSP %s...' % filename) DCNL DCSP fields = [('reset', 'int', 'R'), ('name', 'string', '')] DCNL DCSP outFile = FileRecordStream(filename, write=True, fields=fields) DCNL DCSP initCumProb = initProb.cumsum() DCNL DCSP firstOrderCumProb = dict() DCNL DCSP for (key, value) in firstOrderProb.iteritems(): DCNL DCSP  DCSP firstOrderCumProb[key] = value.cumsum() DCNL DCSP secondOrderCumProb = dict() DCNL DCSP for (key, value) in secondOrderProb.iteritems(): DCNL DCSP  DCSP secondOrderCumProb[key] = value.cumsum() DCNL DCSP elementsInSeq = [] DCNL DCSP numElementsSinceReset = 0 DCNL DCSP maxCatIdx = (len(categoryList) - 1) DCNL DCSP for i in xrange(numRecords): DCNL DCSP  DCSP if (numElementsSinceReset == 0): DCNL DCSP  DCSP  DCSP reset = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP reset = 0 DCNL DCSP  DCSP rand = numpy.random.rand() DCNL DCSP  DCSP if (len(elementsInSeq) == 0): DCNL DCSP  DCSP  DCSP catIdx = numpy.searchsorted(initCumProb, rand) DCNL DCSP  DCSP elif (len(elementsInSeq) == 1): DCNL DCSP  DCSP  DCSP catIdx = numpy.searchsorted(firstOrderCumProb[str(elementsInSeq)], rand) DCNL DCSP  DCSP elif ((len(elementsInSeq) >= 2) and ((seqLen is None) or (len(elementsInSeq) < (seqLen - numNoise)))): DCNL DCSP  DCSP  DCSP catIdx = numpy.searchsorted(secondOrderCumProb[str(elementsInSeq[(-2):])], rand) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP catIdx = numpy.random.randint(len(categoryList)) DCNL DCSP  DCSP catIdx = min(maxCatIdx, catIdx) DCNL DCSP  DCSP outFile.appendRecord([reset, categoryList[catIdx]]) DCNL DCSP  DCSP elementsInSeq.append(catIdx) DCNL DCSP  DCSP numElementsSinceReset += 1 DCNL DCSP  DCSP if ((resetsEvery is not None) and (numElementsSinceReset == resetsEvery)): DCNL DCSP  DCSP  DCSP numElementsSinceReset = 0 DCNL DCSP  DCSP  DCSP elementsInSeq = [] DCNL DCSP  DCSP if ((seqLen is not None) and (len(elementsInSeq) == (seqLen + numNoise))): DCNL DCSP  DCSP  DCSP elementsInSeq = [] DCNL DCSP outFile.close()
 DCSP inputFile = 'numenta_air_Con.csv' DCNL DCSP fields = [('gym', 'string', 'S'), ('address', 'string', ''), ('timestamp', 'datetime', 'T'), ('consumption', 'float', '')] DCNL DCSP gymName = None DCNL DCSP missing = 0 DCNL DCSP total = 0 DCNL DCSP with File('./hotgym2.csv', fields) as o: DCNL DCSP  DCSP with open(inputFile) as f: DCNL DCSP  DCSP  DCSP f.readline() DCNL DCSP  DCSP  DCSP for line in f.xreadlines(): DCNL DCSP  DCSP  DCSP  DCSP record = _parseLine(line) DCNL DCSP  DCSP  DCSP  DCSP o.write(record) DCNL DCSP  DCSP  DCSP  DCSP if (record[0] != gymName): DCNL DCSP  DCSP  DCSP  DCSP  DCSP gymName = record[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP print gymName DCNL DCSP return (total, missing)
 DCSP with open((filePath + '.csv'), 'wb') as f: DCNL DCSP  DCSP writer = csv.writer(f) DCNL DCSP  DCSP if (testNumber == 1): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2']) DCNL DCSP  DCSP  DCSP writer.writerow(['int', 'int']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '']) DCNL DCSP  DCSP  DCSP for i in ranger(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP field1 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP field2 = (field1 + int((0.025 * np.random.normal(0, 100, 1)))) DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2]) DCNL DCSP  DCSP elif (testNumber == 2): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2', 'field3']) DCNL DCSP  DCSP  DCSP writer.writerow(['int', 'int', 'int']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '', '']) DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP field1 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP field2 = (field1 + int((0.025 * np.random.normal(0, 100, 1)))) DCNL DCSP  DCSP  DCSP  DCSP field3 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2, field3]) DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (testNumber == 3): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2', 'field3', 'field4']) DCNL DCSP  DCSP  DCSP writer.writerow(['int', 'int', 'int', 'int']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '', '', '']) DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP field2 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP field3 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP field1 = (field2 + field3) DCNL DCSP  DCSP  DCSP  DCSP field4 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2, field3, field4]) DCNL DCSP  DCSP elif ((testNumber == 4) or (testNumber == 5)): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2']) DCNL DCSP  DCSP  DCSP writer.writerow(['string', 'string']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '']) DCNL DCSP  DCSP  DCSP if (testNumber == 5): DCNL DCSP  DCSP  DCSP  DCSP categories = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p'] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP categories = ['a', 'b', 'c', 'd'] DCNL DCSP  DCSP  DCSP numRecsSaved = 0 DCNL DCSP  DCSP  DCSP firstFieldInd = 0 DCNL DCSP  DCSP  DCSP done = False DCNL DCSP  DCSP  DCSP while (not done): DCNL DCSP  DCSP  DCSP  DCSP while (not done): DCNL DCSP  DCSP  DCSP  DCSP  DCSP field1 = categories[firstFieldInd] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for category in categories: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field2 = category DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numRecsSaved += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (numRecsSaved == numRecords): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP done = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP firstFieldInd += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (firstFieldInd == len(categories)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP firstFieldInd = 0 DCNL DCSP  DCSP elif (testNumber == 6): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2']) DCNL DCSP  DCSP  DCSP writer.writerow(['string', 'string']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '']) DCNL DCSP  DCSP  DCSP choises = [['a', [0.9, 0.05, 0.05]], ['b', [0.05, 0.9, 0.05]], ['c', [0.05, 0.05, 0.9]]] DCNL DCSP  DCSP  DCSP cat2 = ['d', 'e', 'f'] DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP ind1 = int(np.random.random_integers(0, 2, 1)) DCNL DCSP  DCSP  DCSP  DCSP field1 = choises[ind1][0] DCNL DCSP  DCSP  DCSP  DCSP ind2 = np.searchsorted(np.cumsum(choises[ind1][1]), np.random.random()) DCNL DCSP  DCSP  DCSP  DCSP field2 = cat2[ind2] DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2]) DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (testNumber == 7): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2', 'field3']) DCNL DCSP  DCSP  DCSP writer.writerow(['string', 'string', 'string']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '', '']) DCNL DCSP  DCSP  DCSP choises = [['a', [0.9, 0.05, 0.05]], ['b', [0.05, 0.9, 0.05]], ['c', [0.05, 0.05, 0.9]]] DCNL DCSP  DCSP  DCSP cat2 = ['d', 'e', 'f'] DCNL DCSP  DCSP  DCSP cat3 = ['g', 'h', 'i'] DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP ind1 = int(np.random.random_integers(0, 2, 1)) DCNL DCSP  DCSP  DCSP  DCSP field1 = choises[ind1][0] DCNL DCSP  DCSP  DCSP  DCSP ind2 = np.searchsorted(np.cumsum(choises[ind1][1]), np.random.random()) DCNL DCSP  DCSP  DCSP  DCSP field2 = cat2[ind2] DCNL DCSP  DCSP  DCSP  DCSP ind3 = int(np.random.random_integers(0, 2, 1)) DCNL DCSP  DCSP  DCSP  DCSP field3 = cat3[ind3] DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2, field3]) DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (testNumber == 8): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2', 'field3']) DCNL DCSP  DCSP  DCSP writer.writerow(['string', 'string', 'string']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '', '']) DCNL DCSP  DCSP  DCSP choises = [['a', 'd', [0.9, 0.05, 0.05]], ['a', 'e', [0.05, 0.9, 0.05]], ['a', 'f', [0.05, 0.05, 0.9]], ['b', 'd', [0.9, 0.05, 0.05]], ['b', 'e', [0.05, 0.9, 0.05]], ['b', 'f', [0.05, 0.05, 0.9]], ['c', 'd', [0.9, 0.05, 0.05]], ['c', 'e', [0.05, 0.9, 0.05]], ['c', 'f', [0.05, 0.05, 0.9]]] DCNL DCSP  DCSP  DCSP cat3 = ['g', 'h', 'i'] DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP ind1 = int(np.random.random_integers(0, 8, 1)) DCNL DCSP  DCSP  DCSP  DCSP field1 = choises[ind1][0] DCNL DCSP  DCSP  DCSP  DCSP field2 = choises[ind1][1] DCNL DCSP  DCSP  DCSP  DCSP ind2 = np.searchsorted(np.cumsum(choises[ind1][2]), np.random.random()) DCNL DCSP  DCSP  DCSP  DCSP field3 = cat3[ind2] DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2, field3]) DCNL DCSP  DCSP  DCSP pass DCNL DCSP return
 DCSP if ((text is not None) and (len(text) > threshold)): DCNL DCSP  DCSP text = (text[:threshold] + '...') DCNL DCSP return text
 DCSP global g_max_concurrency, g_max_concurrency_raise_exception DCNL DCSP assert (maxConcurrency >= 0) DCNL DCSP g_max_concurrency = maxConcurrency DCNL DCSP g_max_concurrency_raise_exception = raiseException DCNL DCSP return
 DCSP return dict(creator=pymysql, host=Configuration.get('nupic.cluster.database.host'), port=int(Configuration.get('nupic.cluster.database.port')), user=Configuration.get('nupic.cluster.database.user'), passwd=Configuration.get('nupic.cluster.database.passwd'), charset='utf8', use_unicode=True, setsession=['SET DCSP AUTOCOMMIT DCSP = DCSP 1'])
 DCSP logger = logging.getLogger('.'.join(['com.numenta', _MODULE_NAME, cls.__name__])) DCNL DCSP if (logLevel is not None): DCNL DCSP  DCSP logger.setLevel(logLevel) DCNL DCSP return logger
 DCSP mType = type(obj) DCNL DCSP return ((mType is list) or (mType is tuple))
 DCSP s = array('c', ('.' * len(arr))) DCNL DCSP for i in xrange(len(arr)): DCNL DCSP  DCSP if (arr[i] == 1): DCNL DCSP  DCSP  DCSP s[i] = '*' DCNL DCSP return s
 DCSP def decorated(self, *args, **kw): DCNL DCSP  DCSP 'The DCSP decorated DCSP function DCSP that DCSP replaces DCSP __init__() DCSP or DCSP __setstate__()\n\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if (not hasattr(self, '_canAddAttributes')): DCNL DCSP  DCSP  DCSP self.__dict__['_canAddAttributes'] = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._canAddAttributes += 1 DCNL DCSP  DCSP assert (self._canAddAttributes >= 1) DCNL DCSP  DCSP count = self._canAddAttributes DCNL DCSP  DCSP f(self, *args, **kw) DCNL DCSP  DCSP if hasattr(self, '_canAddAttributes'): DCNL DCSP  DCSP  DCSP self._canAddAttributes -= 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._canAddAttributes = (count - 1) DCNL DCSP  DCSP assert (self._canAddAttributes >= 0) DCNL DCSP  DCSP if (self._canAddAttributes == 0): DCNL DCSP  DCSP  DCSP del self._canAddAttributes DCNL DCSP decorated.__doc__ = f.__doc__ DCNL DCSP decorated.__name__ = f.__name__ DCNL DCSP return decorated
 DCSP type(self).__base__.__init__(self, *args, **kw)
 DCSP def newTestMethod(*args, **kwargs): DCNL DCSP  DCSP if (TestOptionParser.__long__ is None): DCNL DCSP  DCSP  DCSP raise Exception('TestOptionParser DCSP must DCSP be DCSP used DCSP in DCSP order DCSP to DCSP use DCSP @longTestdecorator.') DCNL DCSP  DCSP if TestOptionParser.__long__: DCNL DCSP  DCSP  DCSP return testMethod(*args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('Skipping DCSP long DCSP test: DCSP %s' % testMethod.__name__) DCNL DCSP  DCSP  DCSP return unittest.skip(msg)(testMethod)(*args, **kwargs) DCNL DCSP return newTestMethod
 DCSP return getattr(pytest.mark, tag)
 DCSP if (seed is None): DCNL DCSP  DCSP seed = int(((time.time() % 10000) * 10)) DCNL DCSP print 'Numpy DCSP seed DCSP set DCSP to:', seed, 'called DCSP by', DCNL DCSP callStack = traceback.extract_stack(limit=3) DCNL DCSP print callStack[0][2], 'line', callStack[0][1], '->', callStack[1][2] DCNL DCSP return numpy.random.RandomState(seed)
 DCSP numColumns = sourceSP.getNumColumns() DCNL DCSP numInputs = sourceSP.getNumInputs() DCNL DCSP for i in xrange(numColumns): DCNL DCSP  DCSP potential = numpy.zeros(numInputs).astype(uintType) DCNL DCSP  DCSP sourceSP.getPotential(i, potential) DCNL DCSP  DCSP destSP.setPotential(i, potential) DCNL DCSP  DCSP perm = numpy.zeros(numInputs).astype(realType) DCNL DCSP  DCSP sourceSP.getPermanence(i, perm) DCNL DCSP  DCSP destSP.setPermanence(i, perm)
 DCSP seed = int(((time.time() % 10000) * 10)) DCNL DCSP print 'New DCSP seed DCSP generated DCSP as:', seed, 'called DCSP by', DCNL DCSP callStack = traceback.extract_stack(limit=3) DCNL DCSP print callStack[0][2], 'line', callStack[0][1], '->', callStack[1][2] DCNL DCSP return seed
 DCSP columnDim = pySp._columnDimensions DCNL DCSP inputDim = pySp._inputDimensions DCNL DCSP numInputs = pySp.getNumInputs() DCNL DCSP numColumns = pySp.getNumColumns() DCNL DCSP cppSp = CPPSpatialPooler(inputDim, columnDim) DCNL DCSP cppSp.setPotentialRadius(pySp.getPotentialRadius()) DCNL DCSP cppSp.setPotentialPct(pySp.getPotentialPct()) DCNL DCSP cppSp.setGlobalInhibition(pySp.getGlobalInhibition()) DCNL DCSP numActiveColumnsPerInhArea = pySp.getNumActiveColumnsPerInhArea() DCNL DCSP localAreaDensity = pySp.getLocalAreaDensity() DCNL DCSP if (numActiveColumnsPerInhArea > 0): DCNL DCSP  DCSP cppSp.setNumActiveColumnsPerInhArea(numActiveColumnsPerInhArea) DCNL DCSP else: DCNL DCSP  DCSP cppSp.setLocalAreaDensity(localAreaDensity) DCNL DCSP cppSp.setStimulusThreshold(pySp.getStimulusThreshold()) DCNL DCSP cppSp.setInhibitionRadius(pySp.getInhibitionRadius()) DCNL DCSP cppSp.setDutyCyclePeriod(pySp.getDutyCyclePeriod()) DCNL DCSP cppSp.setBoostStrength(pySp.getBoostStrength()) DCNL DCSP cppSp.setIterationNum(pySp.getIterationNum()) DCNL DCSP cppSp.setIterationLearnNum(pySp.getIterationLearnNum()) DCNL DCSP cppSp.setSpVerbosity(pySp.getSpVerbosity()) DCNL DCSP cppSp.setUpdatePeriod(pySp.getUpdatePeriod()) DCNL DCSP cppSp.setSynPermTrimThreshold(pySp.getSynPermTrimThreshold()) DCNL DCSP cppSp.setSynPermActiveInc(pySp.getSynPermActiveInc()) DCNL DCSP cppSp.setSynPermInactiveDec(pySp.getSynPermInactiveDec()) DCNL DCSP cppSp.setSynPermBelowStimulusInc(pySp.getSynPermBelowStimulusInc()) DCNL DCSP cppSp.setSynPermConnected(pySp.getSynPermConnected()) DCNL DCSP cppSp.setMinPctOverlapDutyCycles(pySp.getMinPctOverlapDutyCycles()) DCNL DCSP boostFactors = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getBoostFactors(boostFactors) DCNL DCSP cppSp.setBoostFactors(boostFactors) DCNL DCSP overlapDuty = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getOverlapDutyCycles(overlapDuty) DCNL DCSP cppSp.setOverlapDutyCycles(overlapDuty) DCNL DCSP activeDuty = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getActiveDutyCycles(activeDuty) DCNL DCSP cppSp.setActiveDutyCycles(activeDuty) DCNL DCSP minOverlapDuty = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getMinOverlapDutyCycles(minOverlapDuty) DCNL DCSP cppSp.setMinOverlapDutyCycles(minOverlapDuty) DCNL DCSP for i in xrange(numColumns): DCNL DCSP  DCSP potential = numpy.zeros(numInputs).astype(uintType) DCNL DCSP  DCSP pySp.getPotential(i, potential) DCNL DCSP  DCSP cppSp.setPotential(i, potential) DCNL DCSP  DCSP perm = numpy.zeros(numInputs).astype(realType) DCNL DCSP  DCSP pySp.getPermanence(i, perm) DCNL DCSP  DCSP cppSp.setPermanence(i, perm) DCNL DCSP pySp._random = NupicRandom(newSeed) DCNL DCSP cppSp.seed_(newSeed) DCNL DCSP return cppSp
 DCSP if (imp == 'py'): DCNL DCSP  DCSP spClass = PySpatialPooler DCNL DCSP elif (imp == 'cpp'): DCNL DCSP  DCSP spClass = CPPSpatialPooler DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('unrecognized DCSP implementation') DCNL DCSP print params DCNL DCSP sp = spClass(**params) DCNL DCSP return sp
 DCSP f = sys._getframe(depth) DCNL DCSP method_name = f.f_code.co_name DCNL DCSP filename = f.f_code.co_filename DCNL DCSP arg_class = None DCNL DCSP args = inspect.getargvalues(f) DCNL DCSP if (len(args[0]) > 0): DCNL DCSP  DCSP arg_name = args[0][0] DCNL DCSP  DCSP arg_class = args[3][arg_name].__class__.__name__ DCNL DCSP return (method_name, filename, arg_class)
 DCSP if (s is None): DCNL DCSP  DCSP (callable_name, file_name, class_name) = getCallerInfo(2) DCNL DCSP  DCSP s = callable_name DCNL DCSP  DCSP if (class_name is not None): DCNL DCSP  DCSP  DCSP s = ((class_name + '.') + callable_name) DCNL DCSP lines = (s + additional).split('\n') DCNL DCSP length = max((len(line) for line in lines)) DCNL DCSP print >>stream, ('-' * length) DCNL DCSP print >>stream, (s + additional) DCNL DCSP print >>stream, ('-' * length)
 DCSP argspec = inspect.getargspec(f) DCNL DCSP docstring = f.__doc__ DCNL DCSP descriptions = {} DCNL DCSP if docstring: DCNL DCSP  DCSP lines = docstring.split('\n') DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP while (i < len(lines)): DCNL DCSP  DCSP  DCSP stripped = lines[i].lstrip() DCNL DCSP  DCSP  DCSP if (not stripped): DCNL DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP indentLevel = lines[i].index(stripped[0]) DCNL DCSP  DCSP  DCSP firstWord = stripped.split()[0] DCNL DCSP  DCSP  DCSP if firstWord.endswith(':'): DCNL DCSP  DCSP  DCSP  DCSP firstWord = firstWord[:(-1)] DCNL DCSP  DCSP  DCSP if (firstWord in argspec.args): DCNL DCSP  DCSP  DCSP  DCSP argName = firstWord DCNL DCSP  DCSP  DCSP  DCSP restOfLine = stripped[(len(firstWord) + 1):].strip() DCNL DCSP  DCSP  DCSP  DCSP argLines = [restOfLine] DCNL DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP  DCSP while (i < len(lines)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stripped = lines[i].lstrip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not stripped): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (lines[i].index(stripped[0]) <= indentLevel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP argLines.append(lines[i].strip()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP  DCSP descriptions[argName] = ' DCSP '.join(argLines) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP args = [] DCNL DCSP if argspec.defaults: DCNL DCSP  DCSP defaultCount = len(argspec.defaults) DCNL DCSP else: DCNL DCSP  DCSP defaultCount = 0 DCNL DCSP nonDefaultArgCount = (len(argspec.args) - defaultCount) DCNL DCSP for (i, argName) in enumerate(argspec.args): DCNL DCSP  DCSP if (i >= nonDefaultArgCount): DCNL DCSP  DCSP  DCSP defaultValue = argspec.defaults[(i - nonDefaultArgCount)] DCNL DCSP  DCSP  DCSP args.append((argName, descriptions.get(argName, ''), defaultValue)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args.append((argName, descriptions.get(argName, ''))) DCNL DCSP return args
 DCSP global gLoggingInitialized DCNL DCSP if gLoggingInitialized: DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print >>sys.stderr, 'Logging DCSP already DCSP initialized, DCSP doing DCSP nothing.' DCNL DCSP  DCSP return DCNL DCSP consoleStreamMappings = {'stdout': 'stdoutConsoleHandler', 'stderr': 'stderrConsoleHandler'} DCNL DCSP consoleLogLevels = ['DEBUG', 'INFO', 'WARNING', 'WARN', 'ERROR', 'CRITICAL', 'FATAL'] DCNL DCSP assert ((console is None) or (console in consoleStreamMappings.keys())), ('Unexpected DCSP console DCSP arg DCSP value: DCSP %r' % (console,)) DCNL DCSP assert (consoleLevel in consoleLogLevels), ('Unexpected DCSP consoleLevel DCSP arg DCSP value: DCSP %r' % consoleLevel) DCNL DCSP configFilename = 'nupic-logging.conf' DCNL DCSP configFilePath = resource_filename('nupic.support', configFilename) DCNL DCSP configLogDir = os.environ.get('NTA_LOG_DIR', None) DCNL DCSP if verbose: DCNL DCSP  DCSP print >>sys.stderr, ('Using DCSP logging DCSP configuration DCSP file: DCSP %s' % configFilePath) DCNL DCSP replacements = dict() DCNL DCSP def makeKey(name): DCNL DCSP  DCSP ' DCSP Makes DCSP replacement DCSP key DCSP ' DCNL DCSP  DCSP return ('$$%s$$' % name) DCNL DCSP platform = sys.platform.lower() DCNL DCSP if platform.startswith('java'): DCNL DCSP  DCSP import java.lang DCNL DCSP  DCSP platform = java.lang.System.getProperty('os.name').lower() DCNL DCSP  DCSP if platform.startswith('mac DCSP os DCSP x'): DCNL DCSP  DCSP  DCSP platform = 'darwin' DCNL DCSP if platform.startswith('darwin'): DCNL DCSP  DCSP replacements[makeKey('SYSLOG_HANDLER_ADDRESS')] = '"/var/run/syslog"' DCNL DCSP elif platform.startswith('linux'): DCNL DCSP  DCSP replacements[makeKey('SYSLOG_HANDLER_ADDRESS')] = '"/dev/log"' DCNL DCSP elif platform.startswith('win'): DCNL DCSP  DCSP replacements[makeKey('SYSLOG_HANDLER_ADDRESS')] = '"log"' DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(('This DCSP platform DCSP is DCSP neither DCSP darwin, DCSP win32, DCSP nor DCSP linux: DCSP %s' % (sys.platform,))) DCNL DCSP replacements[makeKey('PERSISTENT_LOG_HANDLER')] = 'fileHandler' DCNL DCSP if platform.startswith('win'): DCNL DCSP  DCSP replacements[makeKey('FILE_HANDLER_LOG_FILENAME')] = '"NUL"' DCNL DCSP else: DCNL DCSP  DCSP replacements[makeKey('FILE_HANDLER_LOG_FILENAME')] = '"/dev/null"' DCNL DCSP handlers = list() DCNL DCSP if (configLogDir is not None): DCNL DCSP  DCSP logFilePath = _genLoggingFilePath() DCNL DCSP  DCSP makeDirectoryFromAbsolutePath(os.path.dirname(logFilePath)) DCNL DCSP  DCSP replacements[makeKey('FILE_HANDLER_LOG_FILENAME')] = repr(logFilePath) DCNL DCSP  DCSP handlers.append(replacements[makeKey('PERSISTENT_LOG_HANDLER')]) DCNL DCSP if (console is not None): DCNL DCSP  DCSP handlers.append(consoleStreamMappings[console]) DCNL DCSP replacements[makeKey('ROOT_LOGGER_HANDLERS')] = ', DCSP '.join(handlers) DCNL DCSP replacements[makeKey('CONSOLE_LOG_LEVEL')] = consoleLevel DCNL DCSP customConfig = StringIO() DCNL DCSP loggingFileContents = resource_string(__name__, configFilename) DCNL DCSP for (lineNum, line) in enumerate(loggingFileContents.splitlines()): DCNL DCSP  DCSP if ('$$' in line): DCNL DCSP  DCSP  DCSP for (key, value) in replacements.items(): DCNL DCSP  DCSP  DCSP  DCSP line = line.replace(key, value) DCNL DCSP  DCSP if (('$$' in line) and ('$$<key>$$' not in line)): DCNL DCSP  DCSP  DCSP raise RuntimeError(('The DCSP text DCSP %r, DCSP found DCSP at DCSP line DCSP #%d DCSP of DCSP file DCSP %r, DCSP contains DCSP a DCSP string DCSP not DCSP found DCSP in DCSP our DCSP replacement DCSP dict.' % (line, lineNum, configFilePath))) DCNL DCSP  DCSP customConfig.write(('%s\n' % line)) DCNL DCSP customConfig.seek(0) DCNL DCSP if (python_version()[:3] >= '2.6'): DCNL DCSP  DCSP logging.config.fileConfig(customConfig, disable_existing_loggers=False) DCNL DCSP else: DCNL DCSP  DCSP logging.config.fileConfig(customConfig) DCNL DCSP gLoggingInitialized = True
 DCSP appName = (os.path.splitext(os.path.basename(sys.argv[0]))[0] or 'UnknownApp') DCNL DCSP appLogDir = os.path.abspath(os.path.join(os.environ['NTA_LOG_DIR'], ('numenta-logs-%s' % (os.environ['USER'],)), appName)) DCNL DCSP appLogFileName = ('%s-%s-%s.log' % (appName, long(time.mktime(time.gmtime())), os.getpid())) DCNL DCSP return os.path.join(appLogDir, appLogFileName)
 DCSP seconds = (interval.get('microseconds', 0) * 1e-06) DCNL DCSP seconds += (interval.get('milliseconds', 0) * 0.001) DCNL DCSP seconds += interval.get('seconds', 0) DCNL DCSP seconds += (interval.get('minutes', 0) * 60) DCNL DCSP seconds += ((interval.get('hours', 0) * 60) * 60) DCNL DCSP seconds += (((interval.get('days', 0) * 24) * 60) * 60) DCNL DCSP seconds += ((((interval.get('weeks', 0) * 7) * 24) * 60) * 60) DCNL DCSP months = interval.get('months', 0) DCNL DCSP months += (12 * interval.get('years', 0)) DCNL DCSP return {'months': months, 'seconds': seconds}
 DCSP dividendMonthSec = aggregationToMonthsSeconds(dividend) DCNL DCSP divisorMonthSec = aggregationToMonthsSeconds(divisor) DCNL DCSP if (((dividendMonthSec['months'] != 0) and (divisorMonthSec['seconds'] != 0)) or ((dividendMonthSec['seconds'] != 0) and (divisorMonthSec['months'] != 0))): DCNL DCSP  DCSP raise RuntimeError('Aggregation DCSP dicts DCSP with DCSP months/years DCSP can DCSP only DCSP be DCSP inter-operated DCSP with DCSP other DCSP aggregation DCSP dicts DCSP that DCSP contain DCSP months/years') DCNL DCSP if (dividendMonthSec['months'] > 0): DCNL DCSP  DCSP return (float(dividendMonthSec['months']) / divisor['months']) DCNL DCSP else: DCNL DCSP  DCSP return (float(dividendMonthSec['seconds']) / divisorMonthSec['seconds'])
 DCSP assert os.path.isabs(absDirPath) DCNL DCSP try: DCNL DCSP  DCSP os.makedirs(absDirPath) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno != os.errno.EEXIST): DCNL DCSP  DCSP  DCSP raise DCNL DCSP return absDirPath
 DCSP generatorList = [] DCNL DCSP if ((len(args) % 2) == 1): DCNL DCSP  DCSP raise ValueError('Must DCSP have DCSP a DCSP key DCSP function DCSP for DCSP every DCSP list.') DCNL DCSP advanceList = [] DCNL DCSP for i in xrange(0, len(args), 2): DCNL DCSP  DCSP listn = args[i] DCNL DCSP  DCSP fn = args[(i + 1)] DCNL DCSP  DCSP if (listn is not None): DCNL DCSP  DCSP  DCSP generatorList.append(groupby(listn, fn)) DCNL DCSP  DCSP  DCSP advanceList.append(True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP generatorList.append(None) DCNL DCSP  DCSP  DCSP advanceList.append(False) DCNL DCSP n = len(generatorList) DCNL DCSP nextList = ([None] * n) DCNL DCSP while True: DCNL DCSP  DCSP for i in xrange(n): DCNL DCSP  DCSP  DCSP if advanceList[i]: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP nextList[i] = generatorList[i].next() DCNL DCSP  DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP  DCSP nextList[i] = None DCNL DCSP  DCSP if all(((entry is None) for entry in nextList)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP minKeyVal = min((nextVal[0] for nextVal in nextList if (nextVal is not None))) DCNL DCSP  DCSP retGroups = [minKeyVal] DCNL DCSP  DCSP for i in xrange(n): DCNL DCSP  DCSP  DCSP if ((nextList[i] is not None) and (nextList[i][0] == minKeyVal)): DCNL DCSP  DCSP  DCSP  DCSP retGroups.append(nextList[i][1]) DCNL DCSP  DCSP  DCSP  DCSP advanceList[i] = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP advanceList[i] = False DCNL DCSP  DCSP  DCSP  DCSP retGroups.append(None) DCNL DCSP  DCSP (yield tuple(retGroups))
 DCSP def getLabel(cls, val): DCNL DCSP  DCSP ' DCSP Get DCSP a DCSP string DCSP label DCSP for DCSP the DCSP current DCSP value DCSP of DCSP the DCSP enum DCSP ' DCNL DCSP  DCSP return cls.__labels[val] DCNL DCSP def validate(cls, val): DCNL DCSP  DCSP ' DCSP Returns DCSP True DCSP if DCSP val DCSP is DCSP a DCSP valid DCSP value DCSP for DCSP the DCSP enumeration DCSP ' DCNL DCSP  DCSP return (val in cls.__values) DCNL DCSP def getValues(cls): DCNL DCSP  DCSP ' DCSP Returns DCSP a DCSP list DCSP of DCSP all DCSP the DCSP possible DCSP values DCSP for DCSP this DCSP enum DCSP ' DCNL DCSP  DCSP return list(cls.__values) DCNL DCSP def getLabels(cls): DCNL DCSP  DCSP ' DCSP Returns DCSP a DCSP list DCSP of DCSP all DCSP possible DCSP labels DCSP for DCSP this DCSP enum DCSP ' DCNL DCSP  DCSP return list(cls.__labels.values()) DCNL DCSP def getValue(cls, label): DCNL DCSP  DCSP ' DCSP Returns DCSP value DCSP given DCSP a DCSP label DCSP ' DCNL DCSP  DCSP return cls.__labels[label] DCNL DCSP for arg in (list(args) + kwargs.keys()): DCNL DCSP  DCSP if (type(arg) is not str): DCNL DCSP  DCSP  DCSP raise TypeError('Enum DCSP arg DCSP {0} DCSP must DCSP be DCSP a DCSP string'.format(arg)) DCNL DCSP  DCSP if (not __isidentifier(arg)): DCNL DCSP  DCSP  DCSP raise ValueError("Invalid DCSP enum DCSP value DCSP '{0}'. DCSP '{0}' DCSP is DCSP not DCSP a DCSP valid DCSP identifier".format(arg)) DCNL DCSP kwargs.update(zip(args, args)) DCNL DCSP newType = type('Enum', (object,), kwargs) DCNL DCSP newType.__labels = dict(((v, k) for (k, v) in kwargs.iteritems())) DCNL DCSP newType.__values = set(newType.__labels.keys()) DCNL DCSP newType.getLabel = functools.partial(getLabel, newType) DCNL DCSP newType.validate = functools.partial(validate, newType) DCNL DCSP newType.getValues = functools.partial(getValues, newType) DCNL DCSP newType.getLabels = functools.partial(getLabels, newType) DCNL DCSP newType.getValue = functools.partial(getValue, newType) DCNL DCSP return newType
 DCSP logger = (logger if (logger is not None) else logging.getLogger(__name__)) DCNL DCSP def exceptionLoggingDecorator(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def exceptionLoggingWrap(*args, **kwargs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP logger.exception('Unhandled DCSP exception DCSP %r DCSP from DCSP %r. DCSP Caller DCSP stack:\n%s', sys.exc_info()[1], func, ''.join(traceback.format_stack())) DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP return exceptionLoggingWrap DCNL DCSP return exceptionLoggingDecorator
 DCSP def entryExitLoggingDecorator(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def entryExitLoggingWrap(*args, **kwargs): DCNL DCSP  DCSP  DCSP if (entryExitLogLevel is None): DCNL DCSP  DCSP  DCSP  DCSP enabled = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logger = getLoggerCallback() DCNL DCSP  DCSP  DCSP  DCSP enabled = logger.isEnabledFor(entryExitLogLevel) DCNL DCSP  DCSP  DCSP if (not enabled): DCNL DCSP  DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP  DCSP funcName = str(func) DCNL DCSP  DCSP  DCSP if logArgs: DCNL DCSP  DCSP  DCSP  DCSP argsRepr = ', DCSP '.join(([repr(a) for a in args] + [('%s=%r' % (k, v)) for (k, v) in kwargs.iteritems()])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP argsRepr = '' DCNL DCSP  DCSP  DCSP logger.log(entryExitLogLevel, 'ENTERING: DCSP %s(%s)%s', funcName, argsRepr, ('' if (not logTraceback) else ('; DCSP ' + repr(traceback.format_stack())))) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP logger.log(entryExitLogLevel, 'LEAVING: DCSP %s(%s)%s', funcName, argsRepr, ('' if (not logTraceback) else ('; DCSP ' + repr(traceback.format_stack())))) DCNL DCSP  DCSP return entryExitLoggingWrap DCNL DCSP return entryExitLoggingDecorator
 DCSP assert (initialRetryDelaySec > 0), str(initialRetryDelaySec) DCNL DCSP assert (timeoutSec >= 0), str(timeoutSec) DCNL DCSP assert (maxRetryDelaySec >= initialRetryDelaySec), ('%r DCSP < DCSP %r' % (maxRetryDelaySec, initialRetryDelaySec)) DCNL DCSP assert isinstance(retryExceptions, tuple), ('retryExceptions DCSP must DCSP be DCSP tuple, DCSP but DCSP got DCSP %r' % (type(retryExceptions),)) DCNL DCSP if (logger is None): DCNL DCSP  DCSP logger = logging.getLogger(__name__) DCNL DCSP def retryDecorator(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def retryWrap(*args, **kwargs): DCNL DCSP  DCSP  DCSP numAttempts = 0 DCNL DCSP  DCSP  DCSP delaySec = initialRetryDelaySec DCNL DCSP  DCSP  DCSP startTime = time.time() DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP numAttempts += 1 DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = func(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP except retryExceptions as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not retryFilter(e, args, kwargs)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if logger.isEnabledFor(logging.DEBUG): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.debug('[%s] DCSP Failure DCSP in DCSP %r; DCSP retries DCSP aborted DCSP by DCSP custom DCSP retryFilter. DCSP Caller DCSP stack:\n%s', clientLabel, func, ''.join(traceback.format_stack()), exc_info=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP  DCSP now = time.time() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (now < startTime): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP startTime = now DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((now - startTime) >= timeoutSec): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.exception('[%s] DCSP Exhausted DCSP retry DCSP timeout DCSP (%s DCSP sec.; DCSP %s DCSP attempts) DCSP for DCSP %r. DCSP Caller DCSP stack:\n%s', clientLabel, timeoutSec, numAttempts, func, ''.join(traceback.format_stack())) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (numAttempts == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.warning('[%s] DCSP First DCSP failure DCSP in DCSP %r; DCSP initial DCSP retry DCSP in DCSP %s DCSP sec.; DCSP timeoutSec=%s. DCSP Caller DCSP stack:\n%s', clientLabel, func, delaySec, timeoutSec, ''.join(traceback.format_stack()), exc_info=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.debug('[%s] DCSP %r DCSP failed DCSP %s DCSP times; DCSP retrying DCSP in DCSP %s DCSP sec.; DCSP timeoutSec=%s. DCSP Caller DCSP stack:\n%s', clientLabel, func, numAttempts, delaySec, timeoutSec, ''.join(traceback.format_stack()), exc_info=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(delaySec) DCNL DCSP  DCSP  DCSP  DCSP  DCSP delaySec = min((delaySec * 2), maxRetryDelaySec) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (numAttempts > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.info('[%s] DCSP %r DCSP succeeded DCSP on DCSP attempt DCSP # DCSP %d', clientLabel, func, numAttempts) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP return retryWrap DCNL DCSP return retryDecorator
 DCSP if (logger is None): DCNL DCSP  DCSP logger = logging.getLogger(__name__) DCNL DCSP def retryFilter(e, args, kwargs): DCNL DCSP  DCSP if isinstance(e, (pymysql.InternalError, pymysql.OperationalError)): DCNL DCSP  DCSP  DCSP if (e.args and (e.args[0] in _ALL_RETRIABLE_ERROR_CODES)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP elif isinstance(e, pymysql.Error): DCNL DCSP  DCSP  DCSP if (e.args and inspect.isclass(e.args[0]) and issubclass(e.args[0], socket_error)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False DCNL DCSP retryExceptions = tuple([pymysql.InternalError, pymysql.OperationalError, pymysql.Error]) DCNL DCSP return make_retry_decorator(timeoutSec=timeoutSec, initialRetryDelaySec=0.1, maxRetryDelaySec=10, retryExceptions=retryExceptions, retryFilter=retryFilter, logger=logger)
 DCSP lx = numpy.asarray(lx) DCNL DCSP base = lx.max() DCNL DCSP if numpy.isinf(base): DCNL DCSP  DCSP return base DCNL DCSP if ((epsilon is not None) and (base < epsilon)): DCNL DCSP  DCSP return epsilon DCNL DCSP x = numpy.exp((lx - base)) DCNL DCSP ssum = x.sum() DCNL DCSP result = (numpy.log(ssum) + base) DCNL DCSP return result
 DCSP lx = numpy.asarray(lx) DCNL DCSP bases = lx.max(0) DCNL DCSP x = numpy.exp((lx - bases)) DCNL DCSP ssum = x.sum(0) DCNL DCSP result = (numpy.log(ssum) + bases) DCNL DCSP try: DCNL DCSP  DCSP conventional = numpy.log(numpy.exp(lx).sum(0)) DCNL DCSP  DCSP if (not similar(result, conventional)): DCNL DCSP  DCSP  DCSP if (numpy.isinf(conventional).any() and (not numpy.isinf(result).any())): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP import sys DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, 'Warning: DCSP scaled DCSP log DCSP sum DCSP down DCSP axis DCSP 0 DCSP did DCSP not DCSP match.' DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, 'Scaled DCSP log DCSP result:' DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, result DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, 'Conventional DCSP result:' DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, conventional DCNL DCSP except FloatingPointError as e: DCNL DCSP  DCSP pass DCNL DCSP return result
 DCSP lx = numpy.asarray(lx) DCNL DCSP base = lx.max() DCNL DCSP x = numpy.exp((lx - base)) DCNL DCSP result = (x / x.sum()) DCNL DCSP conventional = (numpy.exp(lx) / numpy.exp(lx).sum()) DCNL DCSP assert similar(result, conventional) DCNL DCSP return result
 DCSP lx = numpy.asarray(lx) DCNL DCSP base = lx.max() DCNL DCSP x = numpy.exp((lx - base)) DCNL DCSP ssum = x.sum(0) DCNL DCSP result = (ssum / ssum.sum()) DCNL DCSP conventional = (numpy.exp(lx).sum(0) / numpy.exp(lx).sum()) DCNL DCSP assert similar(result, conventional) DCNL DCSP return result
 DCSP lx = numpy.asarray(lx) DCNL DCSP base = lx.max() DCNL DCSP x = numpy.exp((lx - base)) DCNL DCSP ssum = x.sum(0) DCNL DCSP normalized = nsum0(lx) DCNL DCSP result = numpy.log(normalized) DCNL DCSP conventional = numpy.log((numpy.exp(lx).sum(0) / numpy.exp(lx).sum())) DCNL DCSP assert similar(result, conventional) DCNL DCSP return result
 DCSP if (out is None): DCNL DCSP  DCSP out = numpy.zeros(A.shape) DCNL DCSP indicator1 = (A >= B) DCNL DCSP indicator2 = numpy.logical_not(indicator1) DCNL DCSP out[indicator1] = (A[indicator1] + numpy.log1p(numpy.exp((B[indicator1] - A[indicator1])))) DCNL DCSP out[indicator2] = (B[indicator2] + numpy.log1p(numpy.exp((A[indicator2] - B[indicator2])))) DCNL DCSP return out
 DCSP if (out is None): DCNL DCSP  DCSP out = numpy.zeros(A.shape) DCNL DCSP indicator1 = (A >= B) DCNL DCSP assert indicator1.all(), 'Values DCSP in DCSP the DCSP first DCSP array DCSP should DCSP be DCSP greater DCSP than DCSP the DCSP values DCSP in DCSP the DCSP second' DCNL DCSP out[indicator1] = (A[indicator1] + numpy.log((1 - numpy.exp((B[indicator1] - A[indicator1]))))) DCNL DCSP return out
 DCSP y_true = np.ravel(y_true) DCNL DCSP classes = np.unique(y_true) DCNL DCSP if (classes.shape[0] != 2): DCNL DCSP  DCSP raise ValueError('ROC DCSP is DCSP defined DCSP for DCSP binary DCSP classification DCSP only') DCNL DCSP y_score = np.ravel(y_score) DCNL DCSP n_pos = float(np.sum((y_true == classes[1]))) DCNL DCSP n_neg = float(np.sum((y_true == classes[0]))) DCNL DCSP thresholds = np.unique(y_score) DCNL DCSP (neg_value, pos_value) = (classes[0], classes[1]) DCNL DCSP tpr = np.empty(thresholds.size, dtype=np.float) DCNL DCSP fpr = np.empty(thresholds.size, dtype=np.float) DCNL DCSP current_pos_count = current_neg_count = sum_pos = sum_neg = idx = 0 DCNL DCSP signal = np.c_[(y_score, y_true)] DCNL DCSP sorted_signal = signal[signal[:, 0].argsort(), :][::(-1)] DCNL DCSP last_score = sorted_signal[0][0] DCNL DCSP for (score, value) in sorted_signal: DCNL DCSP  DCSP if (score == last_score): DCNL DCSP  DCSP  DCSP if (value == pos_value): DCNL DCSP  DCSP  DCSP  DCSP current_pos_count += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP current_neg_count += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tpr[idx] = ((sum_pos + current_pos_count) / n_pos) DCNL DCSP  DCSP  DCSP fpr[idx] = ((sum_neg + current_neg_count) / n_neg) DCNL DCSP  DCSP  DCSP sum_pos += current_pos_count DCNL DCSP  DCSP  DCSP sum_neg += current_neg_count DCNL DCSP  DCSP  DCSP current_pos_count = (1 if (value == pos_value) else 0) DCNL DCSP  DCSP  DCSP current_neg_count = (1 if (value == neg_value) else 0) DCNL DCSP  DCSP  DCSP idx += 1 DCNL DCSP  DCSP  DCSP last_score = score DCNL DCSP else: DCNL DCSP  DCSP tpr[(-1)] = ((sum_pos + current_pos_count) / n_pos) DCNL DCSP  DCSP fpr[(-1)] = ((sum_neg + current_neg_count) / n_neg) DCNL DCSP if (fpr.shape[0] == 2): DCNL DCSP  DCSP fpr = np.array([0.0, fpr[0], fpr[1]]) DCNL DCSP  DCSP tpr = np.array([0.0, tpr[0], tpr[1]]) DCNL DCSP elif (fpr.shape[0] == 1): DCNL DCSP  DCSP fpr = np.array([0.0, fpr[0], 1.0]) DCNL DCSP  DCSP tpr = np.array([0.0, tpr[0], 1.0]) DCNL DCSP return (fpr, tpr, thresholds)
 DCSP if (x.shape[0] != y.shape[0]): DCNL DCSP  DCSP raise ValueError(('x DCSP and DCSP y DCSP should DCSP have DCSP the DCSP same DCSP shape DCSP to DCSP compute DCSP area DCSP under DCSP curve, DCSP but DCSP x.shape DCSP = DCSP %s DCSP and DCSP y.shape DCSP = DCSP %s.' % (x.shape, y.shape))) DCNL DCSP if (x.shape[0] < 2): DCNL DCSP  DCSP raise ValueError(('At DCSP least DCSP 2 DCSP points DCSP are DCSP needed DCSP to DCSP compute DCSP area DCSP under DCSP curve, DCSP but DCSP x.shape DCSP = DCSP %s' % x.shape)) DCNL DCSP order = np.argsort(x) DCNL DCSP x = x[order] DCNL DCSP y = y[order] DCNL DCSP h = np.diff(x) DCNL DCSP area = (np.sum((h * (y[1:] + y[:(-1)]))) / 2.0) DCNL DCSP return area
 DCSP yTrue = np.array([0, 0, 1, 1, 1]) DCNL DCSP yScore = np.array([0.1, 0.4, 0.5, 0.3, 0.45]) DCNL DCSP (fpr, tpr, thresholds) = ROCCurve(yTrue, yScore) DCNL DCSP print 'Actual: DCSP  DCSP  DCSP  DCSP ', DCNL DCSP _printNPArray(yTrue) DCNL DCSP print 'Predicted: DCSP ', DCNL DCSP _printNPArray(yScore) DCNL DCSP print DCNL DCSP print 'Thresholds:', DCNL DCSP _printNPArray(thresholds[::(-1)]) DCNL DCSP print 'FPR(x): DCSP  DCSP  DCSP  DCSP ', DCNL DCSP _printNPArray(fpr) DCNL DCSP print 'TPR(y): DCSP  DCSP  DCSP  DCSP ', DCNL DCSP _printNPArray(tpr) DCNL DCSP print DCNL DCSP area = AreaUnderCurve(fpr, tpr) DCNL DCSP print 'AUC: DCSP ', area
 DCSP return lgamma((x + 1.0))
 DCSP if (r is None): DCNL DCSP  DCSP r = random DCNL DCSP x = r.uniform(0, sum(distribution)) DCNL DCSP for (i, d) in enumerate(distribution): DCNL DCSP  DCSP if (x <= d): DCNL DCSP  DCSP  DCSP return i DCNL DCSP  DCSP x -= d
 DCSP x = numpy.zeros(size, dtype=dtype) DCNL DCSP x[pos] = 1 DCNL DCSP return x
 DCSP m = x.max() DCNL DCSP return (i for (i, v) in enumerate(x) if (v == m))
 DCSP return bool(reduce((lambda x, y: (x or y)), sequence, False))
 DCSP return bool(reduce((lambda x, y: (x and y)), sequence, True))
 DCSP return reduce((lambda x, y: (x * y)), sequence)
 DCSP x = numpy.zeros(size, dtype=dtype) DCNL DCSP if hasattr(pos, '__iter__'): DCNL DCSP  DCSP for i in pos: DCNL DCSP  DCSP  DCSP x[i] = 1 DCNL DCSP else: DCNL DCSP  DCSP x[pos] = 1 DCNL DCSP return x
 DCSP x = numpy.zeros(size, dtype=dtype) DCNL DCSP if hasattr(pos, '__iter__'): DCNL DCSP  DCSP total = 0 DCNL DCSP  DCSP for i in pos: DCNL DCSP  DCSP  DCSP total += counts[i] DCNL DCSP  DCSP total = float(total) DCNL DCSP  DCSP for i in pos: DCNL DCSP  DCSP  DCSP x[i] = (counts[i] / total) DCNL DCSP else: DCNL DCSP  DCSP x[pos] = 1 DCNL DCSP return x
 DCSP result = [[]] DCNL DCSP for seq in sequences: DCNL DCSP  DCSP result = [(sublist + [item]) for sublist in result for item in seq] DCNL DCSP return result
 DCSP wheels = map(iter, sequences) DCNL DCSP digits = [it.next() for it in wheels] DCNL DCSP while True: DCNL DCSP  DCSP (yield tuple(digits)) DCNL DCSP  DCSP for i in range((len(digits) - 1), (-1), (-1)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP digits[i] = wheels[i].next() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP wheels[i] = iter(sequences[i]) DCNL DCSP  DCSP  DCSP  DCSP digits[i] = wheels[i].next() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
 DCSP keys = keywords.keys() DCNL DCSP sequences = [keywords[key] for key in keys] DCNL DCSP wheels = map(iter, sequences) DCNL DCSP digits = [it.next() for it in wheels] DCNL DCSP while True: DCNL DCSP  DCSP (yield dict(zip(keys, digits))) DCNL DCSP  DCSP for i in range((len(digits) - 1), (-1), (-1)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP digits[i] = wheels[i].next() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP wheels[i] = iter(sequences[i]) DCNL DCSP  DCSP  DCSP  DCSP digits[i] = wheels[i].next() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
 DCSP coordinates = ([0] * len(dimensions)) DCNL DCSP shifted = index DCNL DCSP for i in xrange((len(dimensions) - 1), 0, (-1)): DCNL DCSP  DCSP coordinates[i] = (shifted % dimensions[i]) DCNL DCSP  DCSP shifted = (shifted / dimensions[i]) DCNL DCSP coordinates[0] = shifted DCNL DCSP return coordinates
 DCSP index = 0 DCNL DCSP for (i, dimension) in enumerate(dimensions): DCNL DCSP  DCSP index *= dimension DCNL DCSP  DCSP index += coordinates[i] DCNL DCSP return index
 DCSP centerPosition = coordinatesFromIndex(centerIndex, dimensions) DCNL DCSP intervals = [] DCNL DCSP for (i, dimension) in enumerate(dimensions): DCNL DCSP  DCSP left = max(0, (centerPosition[i] - radius)) DCNL DCSP  DCSP right = min((dimension - 1), (centerPosition[i] + radius)) DCNL DCSP  DCSP intervals.append(xrange(left, (right + 1))) DCNL DCSP coords = numpy.array(list(itertools.product(*intervals))) DCNL DCSP return numpy.ravel_multi_index(coords.T, dimensions)
 DCSP centerPosition = coordinatesFromIndex(centerIndex, dimensions) DCNL DCSP intervals = [] DCNL DCSP for (i, dimension) in enumerate(dimensions): DCNL DCSP  DCSP left = (centerPosition[i] - radius) DCNL DCSP  DCSP right = min((centerPosition[i] + radius), ((left + dimensions[i]) - 1)) DCNL DCSP  DCSP interval = [(v % dimension) for v in xrange(left, (right + 1))] DCNL DCSP  DCSP intervals.append(interval) DCNL DCSP coords = numpy.array(list(itertools.product(*intervals))) DCNL DCSP return numpy.ravel_multi_index(coords.T, dimensions)
 DCSP for (i, row) in enumerate(reader): DCNL DCSP  DCSP if ((i >= start) and (i <= stop)): DCNL DCSP  DCSP  DCSP row[column] = (type(value)(row[column]) + value) DCNL DCSP  DCSP writer.appendRecord(row)
 DCSP for (i, row) in enumerate(reader): DCNL DCSP  DCSP if ((i >= start) and (i <= stop)): DCNL DCSP  DCSP  DCSP row[column] = (type(multiple)(row[column]) * multiple) DCNL DCSP  DCSP writer.appendRecord(row)
 DCSP assert (stop >= start) DCNL DCSP startRows = [] DCNL DCSP copyRows = [] DCNL DCSP ts = None DCNL DCSP inc = None DCNL DCSP if (tsCol is None): DCNL DCSP  DCSP tsCol = reader.getTimestampFieldIdx() DCNL DCSP for (i, row) in enumerate(reader): DCNL DCSP  DCSP if (ts is None): DCNL DCSP  DCSP  DCSP ts = row[tsCol] DCNL DCSP  DCSP elif (inc is None): DCNL DCSP  DCSP  DCSP inc = (row[tsCol] - ts) DCNL DCSP  DCSP if ((i >= start) and (i <= stop)): DCNL DCSP  DCSP  DCSP copyRows.append(row) DCNL DCSP  DCSP startRows.append(row) DCNL DCSP if (insertLocation is None): DCNL DCSP  DCSP insertLocation = (stop + 1) DCNL DCSP startRows[insertLocation:insertLocation] = copyRows DCNL DCSP for row in startRows: DCNL DCSP  DCSP row[tsCol] = ts DCNL DCSP  DCSP writer.appendRecord(row) DCNL DCSP  DCSP ts += inc
 DCSP rows = list(reader) DCNL DCSP if (tsCol is not None): DCNL DCSP  DCSP ts = rows[0][tsCol] DCNL DCSP  DCSP inc = (rows[1][tsCol] - ts) DCNL DCSP if (start is None): DCNL DCSP  DCSP start = 0 DCNL DCSP if (stop is None): DCNL DCSP  DCSP stop = (len(rows) - 1) DCNL DCSP initialN = ((stop - start) + 1) DCNL DCSP numDeletes = (initialN - n) DCNL DCSP for i in xrange(numDeletes): DCNL DCSP  DCSP delIndex = random.randint(start, (stop - i)) DCNL DCSP  DCSP del rows[delIndex] DCNL DCSP if writeSampleOnly: DCNL DCSP  DCSP rows = rows[start:(start + n)] DCNL DCSP if (tsCol is not None): DCNL DCSP  DCSP ts = rows[0][tsCol] DCNL DCSP for row in rows: DCNL DCSP  DCSP if (tsCol is not None): DCNL DCSP  DCSP  DCSP row[tsCol] = ts DCNL DCSP  DCSP  DCSP ts += inc DCNL DCSP  DCSP writer.appendRecord(row)
 DCSP s = s.strip() DCNL DCSP for pattern in DATETIME_FORMATS: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return datetime.datetime.strptime(s, pattern) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP raise ValueError(('The DCSP provided DCSP timestamp DCSP %s DCSP is DCSP malformed. DCSP The DCSP supported DCSP formats DCSP are: DCSP [%s]' % (s, ', DCSP '.join(DATETIME_FORMATS))))
 DCSP return t.strftime(DATETIME_FORMATS[0])
 DCSP return t.strftime(DATETIME_FORMATS[2])
 DCSP l = s.lower() DCNL DCSP if (l in ('true', 't', '1')): DCNL DCSP  DCSP return True DCNL DCSP if (l in ('false', 'f', '0')): DCNL DCSP  DCSP return False DCNL DCSP raise Exception(("Unable DCSP to DCSP convert DCSP string DCSP '%s' DCSP to DCSP a DCSP boolean DCSP value" % s))
 DCSP if (f == 'None'): DCNL DCSP  DCSP return None DCNL DCSP return float(f)
 DCSP if ((i.strip() == 'None') or (i.strip() == 'NULL')): DCNL DCSP  DCSP return None DCNL DCSP return int(i)
 DCSP if (s is None): DCNL DCSP  DCSP return '' DCNL DCSP assert isinstance(s, basestring), ('expected DCSP %s DCSP but DCSP got DCSP %s; DCSP value=%s' % (basestring, type(s), s)) DCNL DCSP s = s.replace('\\', '\\\\') DCNL DCSP s = s.replace('\n', '\\n') DCNL DCSP s = s.replace(' DCTB ', '\\t') DCNL DCSP s = s.replace(',', ' DCTB ') DCNL DCSP return s
 DCSP assert isinstance(s, basestring) DCNL DCSP s = s.replace(' DCTB ', ',') DCNL DCSP s = s.replace('\\,', ',') DCNL DCSP s = s.replace('\\n', '\n') DCNL DCSP s = s.replace('\\\\', '\\') DCNL DCSP return s
 DCSP assert isinstance(s, basestring) DCNL DCSP sdr = [int(c) for c in s if (c in ('0', '1'))] DCNL DCSP if (len(sdr) != len(s)): DCNL DCSP  DCSP raise ValueError("The DCSP provided DCSP string DCSP %s DCSP is DCSP malformed. DCSP The DCSP string DCSP should DCSP have DCSP only DCSP 0's DCSP and DCSP 1's.") DCNL DCSP return sdr
 DCSP return ''.join((str(bit) for bit in sdr))
 DCSP assert isinstance(s, basestring) DCNL DCSP return [int(i) for i in s.split()]
 DCSP return ' DCSP '.join((str(i) for i in listObj))
 DCSP if (fields is not None): DCNL DCSP  DCSP assert set(key).issubset(set([f[0] for f in fields])) DCNL DCSP with FileRecordStream(filename) as f: DCNL DCSP  DCSP if fields: DCNL DCSP  DCSP  DCSP fieldNames = [ff[0] for ff in fields] DCNL DCSP  DCSP  DCSP indices = [f.getFieldNames().index(name) for name in fieldNames] DCNL DCSP  DCSP  DCSP assert (len(indices) == len(fields)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fileds = f.getFields() DCNL DCSP  DCSP  DCSP fieldNames = f.getFieldNames() DCNL DCSP  DCSP  DCSP indices = None DCNL DCSP  DCSP key = [fieldNames.index(name) for name in key] DCNL DCSP  DCSP chunk = 0 DCNL DCSP  DCSP records = [] DCNL DCSP  DCSP for (i, r) in enumerate(f): DCNL DCSP  DCSP  DCSP if indices: DCNL DCSP  DCSP  DCSP  DCSP temp = [] DCNL DCSP  DCSP  DCSP  DCSP for i in indices: DCNL DCSP  DCSP  DCSP  DCSP  DCSP temp.append(r[i]) DCNL DCSP  DCSP  DCSP  DCSP r = temp DCNL DCSP  DCSP  DCSP records.append(r) DCNL DCSP  DCSP  DCSP available_memory = psutil.avail_phymem() DCNL DCSP  DCSP  DCSP if (available_memory < watermark): DCNL DCSP  DCSP  DCSP  DCSP _sortChunk(records, key, chunk, fields) DCNL DCSP  DCSP  DCSP  DCSP records = [] DCNL DCSP  DCSP  DCSP  DCSP chunk += 1 DCNL DCSP  DCSP if (len(records) > 0): DCNL DCSP  DCSP  DCSP _sortChunk(records, key, chunk, fields) DCNL DCSP  DCSP  DCSP chunk += 1 DCNL DCSP  DCSP _mergeFiles(key, chunk, outputFile, fields)
 DCSP title(additional=('(key=%s, DCSP chunkIndex=%d)' % (str(key), chunkIndex))) DCNL DCSP assert (len(records) > 0) DCNL DCSP records.sort(key=itemgetter(*key)) DCNL DCSP if (chunkIndex is not None): DCNL DCSP  DCSP filename = ('chunk_%d.csv' % chunkIndex) DCNL DCSP  DCSP with FileRecordStream(filename, write=True, fields=fields) as o: DCNL DCSP  DCSP  DCSP for r in records: DCNL DCSP  DCSP  DCSP  DCSP o.appendRecord(r) DCNL DCSP  DCSP assert (os.path.getsize(filename) > 0) DCNL DCSP return records
 DCSP title() DCNL DCSP files = [FileRecordStream(('chunk_%d.csv' % i)) for i in range(chunkCount)] DCNL DCSP with FileRecordStream(outputFile, write=True, fields=fields) as o: DCNL DCSP  DCSP files = [FileRecordStream(('chunk_%d.csv' % i)) for i in range(chunkCount)] DCNL DCSP  DCSP records = [f.getNextRecord() for f in files] DCNL DCSP  DCSP while (not all(((r is None) for r in records))): DCNL DCSP  DCSP  DCSP indices = [i for (i, r) in enumerate(records) if (r is not None)] DCNL DCSP  DCSP  DCSP records = [records[i] for i in indices] DCNL DCSP  DCSP  DCSP files = [files[i] for i in indices] DCNL DCSP  DCSP  DCSP r = min(records, key=itemgetter(*key)) DCNL DCSP  DCSP  DCSP o.appendRecord(r) DCNL DCSP  DCSP  DCSP index = records.index(r) DCNL DCSP  DCSP  DCSP records[index] = files[index].getNextRecord() DCNL DCSP for (i, f) in enumerate(files): DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP os.remove(('chunk_%d.csv' % i))
 DCSP statsCollectorMapping = {'float': FloatStatsCollector, 'int': IntStatsCollector, 'string': StringStatsCollector, 'datetime': DateTimeStatsCollector, 'bool': BoolStatsCollector} DCNL DCSP filename = resource_filename('nupic.datafiles', filename) DCNL DCSP print ('*' * 40) DCNL DCSP print ("Collecting DCSP statistics DCSP for DCSP file:'%s'" % (filename,)) DCNL DCSP dataFile = FileRecordStream(filename) DCNL DCSP statsCollectors = [] DCNL DCSP for (fieldName, fieldType, fieldSpecial) in dataFile.getFields(): DCNL DCSP  DCSP statsCollector = statsCollectorMapping[fieldType](fieldName, fieldType, fieldSpecial) DCNL DCSP  DCSP statsCollectors.append(statsCollector) DCNL DCSP if (maxSamples is None): DCNL DCSP  DCSP maxSamples = 500000 DCNL DCSP for i in xrange(maxSamples): DCNL DCSP  DCSP record = dataFile.getNextRecord() DCNL DCSP  DCSP if (record is None): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP for (i, value) in enumerate(record): DCNL DCSP  DCSP  DCSP statsCollectors[i].addValue(value) DCNL DCSP stats = {} DCNL DCSP for statsCollector in statsCollectors: DCNL DCSP  DCSP statsCollector.getStats(stats) DCNL DCSP if (dataFile.getResetFieldIdx() is not None): DCNL DCSP  DCSP (resetFieldName, _, _) = dataFile.getFields()[dataFile.reset] DCNL DCSP  DCSP stats.pop(resetFieldName) DCNL DCSP if (VERBOSITY > 0): DCNL DCSP  DCSP pprint.pprint(stats) DCNL DCSP return stats
 DCSP if (filterInfo is None): DCNL DCSP  DCSP return None DCNL DCSP filterList = [] DCNL DCSP for (i, fieldName) in enumerate(input.getFieldNames()): DCNL DCSP  DCSP fieldFilter = filterInfo.get(fieldName, None) DCNL DCSP  DCSP if (fieldFilter == None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP var = dict() DCNL DCSP  DCSP var['acceptValues'] = None DCNL DCSP  DCSP min = fieldFilter.get('min', None) DCNL DCSP  DCSP max = fieldFilter.get('max', None) DCNL DCSP  DCSP var['min'] = min DCNL DCSP  DCSP var['max'] = max DCNL DCSP  DCSP if (fieldFilter['type'] == 'category'): DCNL DCSP  DCSP  DCSP var['acceptValues'] = fieldFilter['acceptValues'] DCNL DCSP  DCSP  DCSP fp = (lambda x: ((x['value'] != SENTINEL_VALUE_FOR_MISSING_DATA) and (x['value'] in x['acceptValues']))) DCNL DCSP  DCSP elif (fieldFilter['type'] == 'number'): DCNL DCSP  DCSP  DCSP if ((min != None) and (max != None)): DCNL DCSP  DCSP  DCSP  DCSP fp = (lambda x: ((x['value'] != SENTINEL_VALUE_FOR_MISSING_DATA) and (x['value'] >= x['min']) and (x['value'] <= x['max']))) DCNL DCSP  DCSP  DCSP elif (min != None): DCNL DCSP  DCSP  DCSP  DCSP fp = (lambda x: ((x['value'] != SENTINEL_VALUE_FOR_MISSING_DATA) and (x['value'] >= x['min']))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP fp = (lambda x: ((x['value'] != SENTINEL_VALUE_FOR_MISSING_DATA) and (x['value'] <= x['max']))) DCNL DCSP  DCSP filterList.append((i, fp, var)) DCNL DCSP return (_filterRecord, filterList)
 DCSP for (fieldIdx, fp, params) in filterList: DCNL DCSP  DCSP x = dict() DCNL DCSP  DCSP x['value'] = record[fieldIdx] DCNL DCSP  DCSP x['acceptValues'] = params['acceptValues'] DCNL DCSP  DCSP x['min'] = params['min'] DCNL DCSP  DCSP x['max'] = params['max'] DCNL DCSP  DCSP if (not fp(x)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP for elem in inList: DCNL DCSP  DCSP if (elem != SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP  DCSP return elem DCNL DCSP return None
 DCSP for elem in reversed(inList): DCNL DCSP  DCSP if (elem != SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP  DCSP return elem DCNL DCSP return None
 DCSP aggrMean = _aggr_mean(inList) DCNL DCSP if (aggrMean == None): DCNL DCSP  DCSP return None DCNL DCSP aggrSum = 0 DCNL DCSP for elem in inList: DCNL DCSP  DCSP if (elem != SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP  DCSP aggrSum += elem DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP aggrSum += aggrMean DCNL DCSP return aggrSum
 DCSP aggrSum = 0 DCNL DCSP nonNone = 0 DCNL DCSP for elem in inList: DCNL DCSP  DCSP if (elem != SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP  DCSP aggrSum += elem DCNL DCSP  DCSP  DCSP nonNone += 1 DCNL DCSP if (nonNone != 0): DCNL DCSP  DCSP return (aggrSum / nonNone) DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP valueCounts = dict() DCNL DCSP nonNone = 0 DCNL DCSP for elem in inList: DCNL DCSP  DCSP if (elem == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP nonNone += 1 DCNL DCSP  DCSP if (elem in valueCounts): DCNL DCSP  DCSP  DCSP valueCounts[elem] += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP valueCounts[elem] = 1 DCNL DCSP if (nonNone == 0): DCNL DCSP  DCSP return None DCNL DCSP sortedCounts = valueCounts.items() DCNL DCSP sortedCounts.sort(cmp=(lambda x, y: (x[1] - y[1])), reverse=True) DCNL DCSP return sortedCounts[0][0]
 DCSP assert (len(inList) == len(params)) DCNL DCSP weightsSum = sum(params) DCNL DCSP if (weightsSum == 0): DCNL DCSP  DCSP return None DCNL DCSP weightedMean = 0 DCNL DCSP for (i, elem) in enumerate(inList): DCNL DCSP  DCSP weightedMean += (elem * params[i]) DCNL DCSP return (weightedMean / weightsSum)
 DCSP inputFullPath = resource_filename('nupic.datafiles', inputFilename) DCNL DCSP inputObj = FileRecordStream(inputFullPath) DCNL DCSP aggregator = Aggregator(aggregationInfo=aggregationInfo, inputFields=inputObj.getFields()) DCNL DCSP if aggregator.isNullAggregation(): DCNL DCSP  DCSP return inputFullPath DCNL DCSP if (outputFilename is None): DCNL DCSP  DCSP outputFilename = ('agg_%s' % os.path.splitext(os.path.basename(inputFullPath))[0]) DCNL DCSP  DCSP timePeriods = 'years DCSP months DCSP weeks DCSP days DCSP hours DCSP minutes DCSP seconds DCSP milliseconds DCSP microseconds' DCNL DCSP  DCSP for k in timePeriods.split(): DCNL DCSP  DCSP  DCSP if (aggregationInfo.get(k, 0) > 0): DCNL DCSP  DCSP  DCSP  DCSP outputFilename += ('_%s_%d' % (k, aggregationInfo[k])) DCNL DCSP  DCSP outputFilename += '.csv' DCNL DCSP  DCSP outputFilename = os.path.join(os.path.dirname(inputFullPath), outputFilename) DCNL DCSP lockFilePath = (outputFilename + '.please_wait') DCNL DCSP if (os.path.isfile(outputFilename) or os.path.isfile(lockFilePath)): DCNL DCSP  DCSP while os.path.isfile(lockFilePath): DCNL DCSP  DCSP  DCSP print ('Waiting DCSP for DCSP %s DCSP to DCSP be DCSP fully DCSP written DCSP by DCSP another DCSP process' % lockFilePath) DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP return outputFilename DCNL DCSP lockFD = open(lockFilePath, 'w') DCNL DCSP outputObj = FileRecordStream(streamID=outputFilename, write=True, fields=inputObj.getFields()) DCNL DCSP while True: DCNL DCSP  DCSP inRecord = inputObj.getNextRecord() DCNL DCSP  DCSP (aggRecord, aggBookmark) = aggregator.next(inRecord, None) DCNL DCSP  DCSP if ((aggRecord is None) and (inRecord is None)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (aggRecord is not None): DCNL DCSP  DCSP  DCSP outputObj.appendRecord(aggRecord) DCNL DCSP return outputFilename
 DCSP inputFile = resource_filename('nupic.datafiles', inputFile) DCNL DCSP a = defaultdict((lambda : 0), aggregationInfo) DCNL DCSP outputDir = os.path.dirname(inputFile) DCNL DCSP outputFile = ('agg_%s' % os.path.splitext(os.path.basename(inputFile))[0]) DCNL DCSP noAggregation = True DCNL DCSP timePeriods = 'years DCSP months DCSP weeks DCSP days DCSP hours DCSP minutes DCSP seconds DCSP milliseconds DCSP microseconds' DCNL DCSP for k in timePeriods.split(): DCNL DCSP  DCSP if (a[k] > 0): DCNL DCSP  DCSP  DCSP noAggregation = False DCNL DCSP  DCSP  DCSP outputFile += ('_%s_%d' % (k, a[k])) DCNL DCSP if noAggregation: DCNL DCSP  DCSP return inputFile DCNL DCSP outputFile += '.csv' DCNL DCSP outputFile = os.path.join(outputDir, outputFile) DCNL DCSP return outputFile
 DCSP dictPairs = [(original, updates)] DCNL DCSP while (len(dictPairs) > 0): DCNL DCSP  DCSP (original, updates) = dictPairs.pop() DCNL DCSP  DCSP for (k, v) in updates.iteritems(): DCNL DCSP  DCSP  DCSP if ((k in original) and isinstance(original[k], dict) and isinstance(v, dict)): DCNL DCSP  DCSP  DCSP  DCSP dictPairs.append((original[k], v)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP original[k] = v
 DCSP remainingDicts = [(d, ())] DCNL DCSP while (len(remainingDicts) > 0): DCNL DCSP  DCSP (current, prevKeys) = remainingDicts.pop() DCNL DCSP  DCSP for (k, v) in current.iteritems(): DCNL DCSP  DCSP  DCSP keys = (prevKeys + (k,)) DCNL DCSP  DCSP  DCSP if isinstance(v, dict): DCNL DCSP  DCSP  DCSP  DCSP remainingDicts.insert(0, (v, keys)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP f(v, keys)
 DCSP differences = dictDiff(da, db) DCNL DCSP if (not differences): DCNL DCSP  DCSP return differences DCNL DCSP if differences['inAButNotInB']: DCNL DCSP  DCSP print ('>>> DCSP inAButNotInB: DCSP %s' % differences['inAButNotInB']) DCNL DCSP if differences['inBButNotInA']: DCNL DCSP  DCSP print ('>>> DCSP inBButNotInA: DCSP %s' % differences['inBButNotInA']) DCNL DCSP for key in differences['differentValues']: DCNL DCSP  DCSP print ('>>> DCSP da[%s] DCSP != DCSP db[%s]' % (key, key)) DCNL DCSP  DCSP print ('da[%s] DCSP = DCSP %r' % (key, da[key])) DCNL DCSP  DCSP print ('db[%s] DCSP = DCSP %r' % (key, db[key])) DCNL DCSP return differences
 DCSP different = False DCNL DCSP resultDict = dict() DCNL DCSP resultDict['inAButNotInB'] = (set(da) - set(db)) DCNL DCSP if resultDict['inAButNotInB']: DCNL DCSP  DCSP different = True DCNL DCSP resultDict['inBButNotInA'] = (set(db) - set(da)) DCNL DCSP if resultDict['inBButNotInA']: DCNL DCSP  DCSP different = True DCNL DCSP resultDict['differentValues'] = [] DCNL DCSP for key in (set(da) - resultDict['inAButNotInB']): DCNL DCSP  DCSP comparisonResult = (da[key] == db[key]) DCNL DCSP  DCSP if isinstance(comparisonResult, bool): DCNL DCSP  DCSP  DCSP isEqual = comparisonResult DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP isEqual = comparisonResult.all() DCNL DCSP  DCSP if (not isEqual): DCNL DCSP  DCSP  DCSP resultDict['differentValues'].append(key) DCNL DCSP  DCSP  DCSP different = True DCNL DCSP assert (((resultDict['inAButNotInB'] or resultDict['inBButNotInA'] or resultDict['differentValues']) and different) or (not different)) DCNL DCSP return (resultDict if different else None)
 DCSP if (not isinstance(statsInfo, dict)): DCNL DCSP  DCSP raise RuntimeError(("statsInfo DCSP must DCSP be DCSP a DCSP dict DCSP -- DCSP found DCSP '%s' DCSP instead" % type(statsInfo))) DCNL DCSP filename = resource_filename('nupic.datafiles', filename) DCNL DCSP if cache: DCNL DCSP  DCSP statsFilename = getStatsFilename(filename, statsInfo, filters) DCNL DCSP  DCSP if os.path.exists(statsFilename): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP r = pickle.load(open(statsFilename, 'rb')) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP print ('Warning: DCSP unable DCSP to DCSP load DCSP stats DCSP for DCSP %s DCSP -- DCSP will DCSP regenerate' % filename) DCNL DCSP  DCSP  DCSP  DCSP r = dict() DCNL DCSP  DCSP  DCSP requestedKeys = set([s for s in statsInfo]) DCNL DCSP  DCSP  DCSP availableKeys = set(r.keys()) DCNL DCSP  DCSP  DCSP unavailableKeys = requestedKeys.difference(availableKeys) DCNL DCSP  DCSP  DCSP if (len(unavailableKeys) == 0): DCNL DCSP  DCSP  DCSP  DCSP return r DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print ('generateStats: DCSP re-generating DCSP stats DCSP file DCSP %s DCSP because DCSP keys DCSP %s DCSP are DCSP not DCSP available' % (filename, str(unavailableKeys))) DCNL DCSP  DCSP  DCSP  DCSP os.remove(filename) DCNL DCSP print ("Generating DCSP statistics DCSP for DCSP file DCSP '%s' DCSP with DCSP filters DCSP '%s'" % (filename, filters)) DCNL DCSP sensor = RecordSensor() DCNL DCSP sensor.dataSource = FileRecordStream(filename) DCNL DCSP sensor.preEncodingFilters = filters DCNL DCSP stats = [] DCNL DCSP for field in statsInfo: DCNL DCSP  DCSP if (statsInfo[field] == 'number'): DCNL DCSP  DCSP  DCSP statsInfo[field] = NumberStatsCollector() DCNL DCSP  DCSP elif (statsInfo[field] == 'category'): DCNL DCSP  DCSP  DCSP statsInfo[field] = CategoryStatsCollector() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError(("Unknown DCSP stats DCSP type DCSP '%s' DCSP for DCSP field DCSP '%s'" % (statsInfo[field], field))) DCNL DCSP if (maxSamples is None): DCNL DCSP  DCSP maxSamples = 500000 DCNL DCSP for i in xrange(maxSamples): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP record = sensor.getNextRecord() DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP for (name, collector) in statsInfo.items(): DCNL DCSP  DCSP  DCSP collector.add(record[name]) DCNL DCSP del sensor DCNL DCSP r = dict() DCNL DCSP for (field, collector) in statsInfo.items(): DCNL DCSP  DCSP stats = collector.getStats() DCNL DCSP  DCSP if (field not in r): DCNL DCSP  DCSP  DCSP r[field] = stats DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP r[field].update(stats) DCNL DCSP if cache: DCNL DCSP  DCSP f = open(statsFilename, 'wb') DCNL DCSP  DCSP pickle.dump(r, f) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP r['_filename'] = statsFilename DCNL DCSP return r
 DCSP for (i, field) in enumerate(fields): DCNL DCSP  DCSP if (field.special == special): DCNL DCSP  DCSP  DCSP return i DCNL DCSP return None
 DCSP assert (len(kwds.keys()) >= 1) DCNL DCSP assert (('schemaPath' in kwds) or ('schemaDict' in kwds)) DCNL DCSP schemaDict = None DCNL DCSP if ('schemaPath' in kwds): DCNL DCSP  DCSP schemaPath = kwds.pop('schemaPath') DCNL DCSP  DCSP schemaDict = loadJsonValueFromFile(schemaPath) DCNL DCSP elif ('schemaDict' in kwds): DCNL DCSP  DCSP schemaDict = kwds.pop('schemaDict') DCNL DCSP try: DCNL DCSP  DCSP validictory.validate(value, schemaDict, **kwds) DCNL DCSP except validictory.ValidationError as e: DCNL DCSP  DCSP raise ValidationError(e)
 DCSP with open(inputFilePath) as fileObj: DCNL DCSP  DCSP value = json.load(fileObj) DCNL DCSP return value
 DCSP import sys DCNL DCSP schemaDict = {'description': 'JSON DCSP schema DCSP for DCSP json_helpers.py DCSP test DCSP code', 'type': 'object', 'additionalProperties': False, 'properties': {'myBool': {'description': 'Some DCSP boolean DCSP property', 'required': True, 'type': 'boolean'}}} DCNL DCSP d = {'myBool': False} DCNL DCSP print 'Validating DCSP schemaDict DCSP method DCSP in DCSP positive DCSP test...' DCNL DCSP validate(d, schemaDict=schemaDict) DCNL DCSP print 'ok\n' DCNL DCSP print 'Validating DCSP schemaDict DCSP method DCSP in DCSP negative DCSP test...' DCNL DCSP try: DCNL DCSP  DCSP validate({}, schemaDict=schemaDict) DCNL DCSP except ValidationError: DCNL DCSP  DCSP print 'ok\n' DCNL DCSP else: DCNL DCSP  DCSP print 'FAILED\n' DCNL DCSP  DCSP sys.exit(1) DCNL DCSP schemaPath = os.path.join(os.path.dirname(__file__), 'testSchema.json') DCNL DCSP print ('Validating DCSP schemaPath DCSP method DCSP in DCSP positive DCSP test DCSP using DCSP %s...' % (os.path.abspath(schemaPath),)) DCNL DCSP validate(d, schemaPath=schemaPath) DCNL DCSP print 'ok\n' DCNL DCSP print ('Validating DCSP schemaPath DCSP method DCSP in DCSP negative DCSP test DCSP using DCSP %s...' % (os.path.abspath(schemaPath),)) DCNL DCSP try: DCNL DCSP  DCSP validate({}, schemaPath=schemaPath) DCNL DCSP except ValidationError: DCNL DCSP  DCSP print 'ok\n' DCNL DCSP else: DCNL DCSP  DCSP print 'FAILED\n' DCNL DCSP  DCSP sys.exit(1) DCNL DCSP return
 DCSP def getArrayType(self): DCNL DCSP  DCSP 'A DCSP little DCSP function DCSP to DCSP replace DCSP the DCSP getType() DCSP method DCSP of DCSP arrays\n\n DCSP  DCSP  DCSP  DCSP It DCSP returns DCSP a DCSP string DCSP representation DCSP of DCSP the DCSP array DCSP element DCSP type DCSP instead DCSP of DCSP the\n DCSP  DCSP  DCSP  DCSP integer DCSP value DCSP (NTA_BasicType DCSP enum) DCSP returned DCSP by DCSP the DCSP origianl DCSP array\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return self._dtype DCNL DCSP if ref: DCNL DCSP  DCSP assert (size is None) DCNL DCSP index = basicTypes.index(dtype) DCNL DCSP if (index == (-1)): DCNL DCSP  DCSP raise Exception(('Invalid DCSP data DCSP type: DCSP ' + dtype)) DCNL DCSP if (size and (size <= 0)): DCNL DCSP  DCSP raise Exception('Array DCSP size DCSP must DCSP be DCSP positive') DCNL DCSP suffix = ('ArrayRef' if ref else 'Array') DCNL DCSP arrayFactory = getattr(engine_internal, (dtype + suffix)) DCNL DCSP arrayFactory.getType = getArrayType DCNL DCSP if size: DCNL DCSP  DCSP a = arrayFactory(size) DCNL DCSP else: DCNL DCSP  DCSP a = arrayFactory() DCNL DCSP a._dtype = basicTypes[index] DCNL DCSP return a
 DCSP network.link(sensorRegionName, regionName, 'UniformLink', '', srcOutput='dataOut', destInput='bottomUpIn')
 DCSP network.link(regionName1, regionName2, 'UniformLink', '', srcOutput='bottomUpOut', destInput='bottomUpIn')
 DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='bucketIdxOut', destInput='bucketIdxIn') DCNL DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='actValueOut', destInput='actValueIn') DCNL DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='categoryOut', destInput='categoryIn')
 DCSP classifierRegion = network.regions[clRegionName] DCNL DCSP actualValues = classifierRegion.getOutputData('actualValues') DCNL DCSP probabilities = classifierRegion.getOutputData('probabilities') DCNL DCSP steps = classifierRegion.getSelf().stepsList DCNL DCSP N = classifierRegion.getSelf().maxCategoryCount DCNL DCSP results = {step: {} for step in steps} DCNL DCSP for i in range(len(steps)): DCNL DCSP  DCSP stepProbabilities = probabilities[(i * N):(((i + 1) * N) - 1)] DCNL DCSP  DCSP mostLikelyCategoryIdx = stepProbabilities.argmax() DCNL DCSP  DCSP predictedValue = actualValues[mostLikelyCategoryIdx] DCNL DCSP  DCSP predictionConfidence = stepProbabilities[mostLikelyCategoryIdx] DCNL DCSP  DCSP results[steps[i]]['predictedValue'] = predictedValue DCNL DCSP  DCSP results[steps[i]]['predictionConfidence'] = predictionConfidence DCNL DCSP return results
 DCSP network.link(sensorRegionName, regionName, 'UniformLink', '', srcOutput='dataOut', destInput='bottomUpIn')
 DCSP network.link(regionName1, regionName2, 'UniformLink', '', srcOutput='bottomUpOut', destInput='bottomUpIn')
 DCSP network.link(sensorRegionName, regionName, 'UniformLink', '', srcOutput='resetOut', destInput='resetIn')
 DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='bucketIdxOut', destInput='bucketIdxIn') DCNL DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='actValueOut', destInput='actValueIn') DCNL DCSP network.link(sensorRegionName, classifierRegionName, 'UniformLink', '', srcOutput='categoryOut', destInput='categoryIn')
 DCSP encoder = MultiEncoder() DCNL DCSP encoder.addMultipleEncoders(encoderParams) DCNL DCSP return encoder
 DCSP with open(_PARAMS_PATH, 'r') as f: DCNL DCSP  DCSP modelParams = yaml.safe_load(f)['modelParams'] DCNL DCSP network = Network() DCNL DCSP network.addRegion('sensor', 'py.RecordSensor', '{}') DCNL DCSP sensorRegion = network.regions['sensor'].getSelf() DCNL DCSP sensorRegion.encoder = createEncoder(modelParams['sensorParams']['encoders']) DCNL DCSP sensorRegion.dataSource = dataSource DCNL DCSP modelParams['spParams']['inputWidth'] = sensorRegion.encoder.getWidth() DCNL DCSP network.addRegion('SP', 'py.SPRegion', json.dumps(modelParams['spParams'])) DCNL DCSP network.addRegion('TM', 'py.TMRegion', json.dumps(modelParams['tmParams'])) DCNL DCSP clName = ('py.%s' % modelParams['clParams'].pop('regionName')) DCNL DCSP network.addRegion('classifier', clName, json.dumps(modelParams['clParams'])) DCNL DCSP createSensorToClassifierLinks(network, 'sensor', 'classifier') DCNL DCSP createDataOutLink(network, 'sensor', 'SP') DCNL DCSP createFeedForwardLink(network, 'SP', 'TM') DCNL DCSP createFeedForwardLink(network, 'TM', 'classifier') DCNL DCSP createResetLink(network, 'sensor', 'SP') DCNL DCSP createResetLink(network, 'sensor', 'TM') DCNL DCSP network.initialize() DCNL DCSP return network
 DCSP classifierRegion = network.regions[clRegionName] DCNL DCSP actualValues = classifierRegion.getOutputData('actualValues') DCNL DCSP probabilities = classifierRegion.getOutputData('probabilities') DCNL DCSP steps = classifierRegion.getSelf().stepsList DCNL DCSP N = classifierRegion.getSelf().maxCategoryCount DCNL DCSP results = {step: {} for step in steps} DCNL DCSP for i in range(len(steps)): DCNL DCSP  DCSP stepProbabilities = probabilities[(i * N):(((i + 1) * N) - 1)] DCNL DCSP  DCSP mostLikelyCategoryIdx = stepProbabilities.argmax() DCNL DCSP  DCSP predictedValue = actualValues[mostLikelyCategoryIdx] DCNL DCSP  DCSP predictionConfidence = stepProbabilities[mostLikelyCategoryIdx] DCNL DCSP  DCSP results[steps[i]]['predictedValue'] = predictedValue DCNL DCSP  DCSP results[steps[i]]['predictionConfidence'] = predictionConfidence DCNL DCSP return results
 DCSP dataSource = FileRecordStream(streamID=_INPUT_FILE_PATH) DCNL DCSP numRecords = min(numRecords, dataSource.getDataRowCount()) DCNL DCSP network = createNetwork(dataSource) DCNL DCSP network.regions['sensor'].setParameter('predictedField', 'consumption') DCNL DCSP network.regions['SP'].setParameter('learningMode', 1) DCNL DCSP network.regions['TM'].setParameter('learningMode', 1) DCNL DCSP network.regions['classifier'].setParameter('learningMode', 1) DCNL DCSP network.regions['SP'].setParameter('inferenceMode', 1) DCNL DCSP network.regions['TM'].setParameter('inferenceMode', 1) DCNL DCSP network.regions['classifier'].setParameter('inferenceMode', 1) DCNL DCSP results = [] DCNL DCSP N = 1 DCNL DCSP for iteration in range(0, numRecords, N): DCNL DCSP  DCSP network.run(N) DCNL DCSP  DCSP predictionResults = getPredictionResults(network, 'classifier') DCNL DCSP  DCSP oneStep = predictionResults[1]['predictedValue'] DCNL DCSP  DCSP oneStepConfidence = predictionResults[1]['predictionConfidence'] DCNL DCSP  DCSP fiveStep = predictionResults[5]['predictedValue'] DCNL DCSP  DCSP fiveStepConfidence = predictionResults[5]['predictionConfidence'] DCNL DCSP  DCSP result = (oneStep, (oneStepConfidence * 100), fiveStep, (fiveStepConfidence * 100)) DCNL DCSP  DCSP print '1-step: DCSP {:16} DCSP ({:4.4}%) DCTB  DCSP 5-step: DCSP {:16} DCSP ({:4.4}%)'.format(*result) DCNL DCSP  DCSP results.append(result) DCNL DCSP return results
