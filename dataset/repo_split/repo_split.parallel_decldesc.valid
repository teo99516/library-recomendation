def _load_file(filename): DCNL 'load a Python source file and compile it to byte-code DCNL _load_module(filename: string): code_object DCNL filename:   name of file containing Python source code DCNL (normally a .py) DCNL code_object: code_object compiled from this source code DCNL This function does NOT write any file!'
def _load_module(filename): DCNL 'load a module without importing it DCNL _load_module(filename: string): code_object DCNL filename:   name of file containing Python byte-code object DCNL (normally a .pyc) DCNL code_object: code_object from this file'
def uncompyle(version, co, out=None, showasm=0, showast=0, deob=0): DCNL 'diassembles a given code block \'co\''
def uncompyle_file(filename, outstream=None, showasm=0, showast=0, deob=0): DCNL 'decompile Python byte-code file (.pyc)'
def main(in_base, out_base, files, codes, outfile=None, showasm=0, showast=0, do_verify=0, py=0, deob=0): DCNL 'in_base     base directory for input files DCNL out_base    base directory for output files (ignored when DCNL files       list of filenames to be uncompyled (relative to src_base) DCNL outfile     write output to this filename (overwrites out_base) DCNL For redirecting output to DCNL - <filename>                outfile=<filename> (out_base is ignored) DCNL - files below out_base      out_base=... DCNL - stdout                    out_base=None, outfile=None'
def cmp_code_objects(version, code_obj1, code_obj2, name=''): DCNL 'Compare two code-objects. DCNL This is the main part of this module.'
def compare_code_with_srcfile(pyc_filename, src_filename): DCNL 'Compare a .pyc with a source code file.'
def compare_files(pyc_filename1, pyc_filename2): DCNL 'Compare two .pyc files.'
def find_globals(node, globs): DCNL 'Find globals in this statement.'
def find_all_globals(node, globs): DCNL 'Find globals in this statement.'
def is_frozen(): DCNL 'Return whether we are running in a frozen environment'
def get_default_instance(): DCNL 'Return the default VLC.Instance.'
def _Cfunction(name, flags, errcheck, *types): DCNL '(INTERNAL) New ctypes function binding.'
def _Cobject(cls, ctype): DCNL '(INTERNAL) New instance from ctypes.'
def _Constructor(cls, ptr=_internal_guard): DCNL '(INTERNAL) New wrapper from ctypes.'
def string_result(result, func, arguments): DCNL 'Errcheck function. Returns a string and frees the original pointer. DCNL It assumes the result is a char *.'
def class_result(classname): DCNL 'Errcheck function. Returns a function that creates the specified class.'
def track_description_list(head): DCNL 'Convert a TrackDescription linked list to a Python list (and release the former).'
def module_description_list(head): DCNL 'Convert a ModuleDescription linked list to a Python list (and release the former).'
def libvlc_errmsg(): DCNL 'A human-readable error message for the last LibVLC error in the calling DCNL thread. The resulting string is valid until another error occurs (at least DCNL until the next LibVLC call). DCNL @warning DCNL This will be None if there was no error.'
def libvlc_clearerr(): DCNL 'Clears the LibVLC error status for the current thread. This is optional. DCNL By default, the error status is automatically overridden when a new error DCNL occurs, and destroyed when the thread exits.'
def libvlc_vprinterr(fmt, ap): DCNL 'Sets the LibVLC error status and message for the current thread. DCNL Any previous error is overridden. DCNL @param fmt: the format string. DCNL @param ap: the arguments. DCNL @return: a nul terminated string in any case.'
def libvlc_new(argc, argv): DCNL 'Create and initialize a libvlc instance. DCNL This functions accept a list of "command line" arguments similar to the DCNL main(). These arguments affect the LibVLC instance default configuration. DCNL @note DCNL LibVLC may create threads. Therefore, any thread-unsafe process DCNL initialization must be performed before calling L{libvlc_new}(). In particular DCNL and where applicable: DCNL - setlocale() and textdomain(), DCNL - setenv(), unsetenv() and putenv(), DCNL - with the X11 display system, XInitThreads() DCNL (see also L{libvlc_media_player_set_xwindow}()) and DCNL - on Microsoft Windows, SetErrorMode(). DCNL - sigprocmask() shall never be invoked; pthread_sigmask() can be used. DCNL On POSIX systems, the SIGCHLD signal must B{not} be ignored, i.e. the DCNL signal handler must set to SIG_DFL or a function pointer, not SIG_IGN. DCNL Also while LibVLC is active, the wait() function shall not be called, and DCNL any call to waitpid() shall use a strictly positive value for the first DCNL parameter (i.e. the PID). Failure to follow those rules may lead to a DCNL deadlock or a busy loop. DCNL Also on POSIX systems, it is recommended that the SIGPIPE signal be blocked, DCNL even if it is not, in principles, necessary. DCNL On Microsoft Windows Vista/2008, the process error mode DCNL SEM_FAILCRITICALERRORS flag B{must} with the SetErrorMode() function DCNL before using LibVLC. On later versions, it is optional and unnecessary. DCNL @param argc: the number of arguments (should be 0). DCNL @param argv: list of arguments (should be None). DCNL @return: the libvlc instance or None in case of error. DCNL @version Arguments are meant to be passed from the command line to LibVLC, just like VLC media player does. The list of valid arguments depends on the LibVLC version, the operating system and platform, and set of available LibVLC plugins. Invalid or unsupported arguments will cause the function to fail (i.e. return None). Also, some arguments may alter the behaviour or otherwise interfere with other LibVLC functions. @warning There is absolutely no warranty or promise of forward, backward and cross-platform compatibility with regards to L{libvlc_new}() arguments. We recommend that you do not use them, other than when debugging.'
def libvlc_release(p_instance): DCNL 'Decrement the reference count of a libvlc instance, and destroy it DCNL if it reaches zero. DCNL @param p_instance: the instance to destroy.'
def libvlc_retain(p_instance): DCNL 'Increments the reference count of a libvlc instance. DCNL The initial reference count is 1 after L{libvlc_new}() returns. DCNL @param p_instance: the instance to reference.'
def libvlc_add_intf(p_instance, name): DCNL 'Try to start a user interface for the libvlc instance. DCNL @param p_instance: the instance. DCNL @param name: interface name, or None for default. DCNL @return: 0 on success, -1 on error.'
def libvlc_set_user_agent(p_instance, name, http): DCNL 'Sets the application name. LibVLC passes this as the user agent string DCNL when a protocol requires it. DCNL @param p_instance: LibVLC instance. DCNL @param name: human-readable application name, e.g. "FooBar player 1.2.3". DCNL @param http: HTTP User Agent, e.g. "FooBar/1.2.3 Python/2.6.0". DCNL @version: LibVLC 1.1.1 or later.'
def libvlc_set_app_id(p_instance, id, version, icon): DCNL 'Sets some meta-information about the application. DCNL See also L{libvlc_set_user_agent}(). DCNL @param p_instance: LibVLC instance. DCNL @param id: Java-style application identifier, e.g. "com.acme.foobar". DCNL @param version: application version numbers, e.g. "1.2.3". DCNL @param icon: application icon name, e.g. "foobar". DCNL @version: LibVLC 2.1.0 or later.'
def libvlc_get_version(): DCNL 'Retrieve libvlc version. DCNL Example: "1.1.0-git The Luggage". DCNL @return: a string containing the libvlc version.'
def libvlc_get_compiler(): DCNL 'Retrieve libvlc compiler version. DCNL Example: "gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)". DCNL @return: a string containing the libvlc compiler version.'
def libvlc_get_changeset(): DCNL 'Retrieve libvlc changeset. DCNL Example: "aa9bce0bc4". DCNL @return: a string containing the libvlc changeset.'
def libvlc_free(ptr): DCNL 'Frees an heap allocation returned by a LibVLC function. DCNL If you know you\'re using the same underlying C run-time as the LibVLC DCNL implementation, then you can call ANSI C free() directly instead. DCNL @param ptr: the pointer.'
def libvlc_event_attach(p_event_manager, i_event_type, f_callback, user_data): DCNL 'Register for an event notification. DCNL @param p_event_manager: the event manager to which you want to attach to. Generally it is obtained by vlc_my_object_event_manager() where my_object is the object you want to listen to. DCNL @param i_event_type: the desired event to which we want to listen. DCNL @param f_callback: the function to call when i_event_type occurs. DCNL @param user_data: user provided data to carry with the event. DCNL @return: 0 on success, ENOMEM on error.'
def libvlc_event_detach(p_event_manager, i_event_type, f_callback, p_user_data): DCNL 'Unregister an event notification. DCNL @param p_event_manager: the event manager. DCNL @param i_event_type: the desired event to which we want to unregister. DCNL @param f_callback: the function to call when i_event_type occurs. DCNL @param p_user_data: user provided data to carry with the event.'
def libvlc_event_type_name(event_type): DCNL 'Get an event\'s type name. DCNL @param event_type: the desired event.'
def libvlc_log_get_context(ctx): DCNL 'Gets debugging information about a log message: the name of the VLC module DCNL emitting the message and the message location within the source code. DCNL The returned module name and file name will be None if unknown. DCNL The returned line number will similarly be zero if unknown. DCNL @param ctx: message context (as passed to the @ref libvlc_log_cb callback). DCNL @return: module module name storage (or None), file source code file name storage (or None), line source code file line number storage (or None). DCNL @version: LibVLC 2.1.0 or later.'
def libvlc_log_get_object(ctx, id): DCNL 'Gets VLC object information about a log message: the type name of the VLC DCNL object emitting the message, the object header if any and a temporaly-unique DCNL object identifier. This information is mainly meant for B{manual} DCNL troubleshooting. DCNL The returned type name may be "generic" if unknown, but it cannot be None. DCNL The returned header will be None if unset; in current versions, the header DCNL is used to distinguish for VLM inputs. DCNL The returned object ID will be zero if the message is not associated with DCNL any VLC object. DCNL @param ctx: message context (as passed to the @ref libvlc_log_cb callback). DCNL @return: name object name storage (or None), header object header (or None), line source code file line number storage (or None). DCNL @version: LibVLC 2.1.0 or later.'
def libvlc_log_unset(p_instance): DCNL 'Unsets the logging callback for a LibVLC instance. This is rarely needed: DCNL the callback is implicitly unset when the instance is destroyed. DCNL This function will wait for any pending callbacks invocation to complete DCNL (causing a deadlock if called from within the callback). DCNL @param p_instance: libvlc instance. DCNL @version: LibVLC 2.1.0 or later.'
def libvlc_log_set(cb, data, p_instance): DCNL 'Sets the logging callback for a LibVLC instance. DCNL This function is thread-safe: it will wait for any pending callbacks DCNL invocation to complete. DCNL @param cb: callback function pointer. DCNL @param data: opaque data pointer for the callback function @note Some log messages (especially debug) are emitted by LibVLC while is being initialized. These messages cannot be captured with this interface. @warning A deadlock may occur if this function is called from the callback. DCNL @param p_instance: libvlc instance. DCNL @version: LibVLC 2.1.0 or later.'
def libvlc_log_set_file(p_instance, stream): DCNL 'Sets up logging to a file. DCNL @param p_instance: libvlc instance. DCNL @param stream: FILE pointer opened for writing (the FILE pointer must remain valid until L{libvlc_log_unset}()). DCNL @version: LibVLC 2.1.0 or later.'
def libvlc_module_description_list_release(p_list): DCNL 'Release a list of module descriptions. DCNL @param p_list: the list to be released.'
def libvlc_audio_filter_list_get(p_instance): DCNL 'Returns a list of audio filters that are available. DCNL @param p_instance: libvlc instance. DCNL @return: a list of module descriptions. It should be freed with L{libvlc_module_description_list_release}(). In case of an error, None is returned. See L{ModuleDescription} See L{libvlc_module_description_list_release}.'
def libvlc_video_filter_list_get(p_instance): DCNL 'Returns a list of video filters that are available. DCNL @param p_instance: libvlc instance. DCNL @return: a list of module descriptions. It should be freed with L{libvlc_module_description_list_release}(). In case of an error, None is returned. See L{ModuleDescription} See L{libvlc_module_description_list_release}.'
def libvlc_clock(): DCNL 'Return the current time as defined by LibVLC. The unit is the microsecond. DCNL Time increases monotonically (regardless of time zone changes and RTC DCNL adjustements). DCNL The origin is arbitrary but consistent across the whole system DCNL (e.g. the system uptim, the time since the system was booted). DCNL @note: On systems that support it, the POSIX monotonic clock is used.'
def libvlc_media_new_location(p_instance, psz_mrl): DCNL 'Create a media with a certain given media resource location, DCNL for instance a valid URL. DCNL @note: To refer to a local file with this function, DCNL the file://... URI syntax B{must} be used (see IETF RFC3986). DCNL We recommend using L{libvlc_media_new_path}() instead when dealing with DCNL local files. DCNL See L{libvlc_media_release}. DCNL @param p_instance: the instance. DCNL @param psz_mrl: the media location. DCNL @return: the newly created media or None on error.'
def libvlc_media_new_path(p_instance, path): DCNL 'Create a media for a certain file path. DCNL See L{libvlc_media_release}. DCNL @param p_instance: the instance. DCNL @param path: local filesystem path. DCNL @return: the newly created media or None on error.'
def libvlc_media_new_fd(p_instance, fd): DCNL 'Create a media for an already open file descriptor. DCNL The file descriptor shall be open for reading (or reading and writing). DCNL Regular file descriptors, pipe read descriptors and character device DCNL descriptors (including TTYs) are supported on all platforms. DCNL Block device descriptors are supported where available. DCNL Directory descriptors are supported on systems that provide fdopendir(). DCNL Sockets are supported on all platforms where they are file descriptors, DCNL i.e. all except Windows. DCNL @note: This library will B{not} automatically close the file descriptor DCNL under any circumstance. Nevertheless, a file descriptor can usually only be DCNL rendered once in a media player. To render it a second time, the file DCNL descriptor should probably be rewound to the beginning with lseek(). DCNL See L{libvlc_media_release}. DCNL @param p_instance: the instance. DCNL @param fd: open file descriptor. DCNL @return: the newly created media or None on error. DCNL @version: LibVLC 1.1.5 and later.'
def libvlc_media_new_callbacks(instance, open_cb, read_cb, seek_cb, close_cb, opaque): DCNL 'Create a media with custom callbacks to read the data from. DCNL @param instance: LibVLC instance. DCNL @param open_cb: callback to open the custom bitstream input media. DCNL @param read_cb: callback to read data (must not be None). DCNL @param seek_cb: callback to seek, or None if seeking is not supported. DCNL @param close_cb: callback to close the media, or None if unnecessary. DCNL @param opaque: data pointer for the open callback. DCNL @return: the newly created media or None on error @note If open_cb is None, the opaque pointer will be passed to read_cb, seek_cb and close_cb, and the stream size will be treated as unknown. @note The callbacks may be called asynchronously (from another thread). A single stream instance need not be reentrant. However the open_cb needs to be reentrant if the media is used by multiple player instances. @warning The callbacks may be used until all or any player instances that were supplied the media item are stopped. See L{libvlc_media_release}. DCNL @version: LibVLC 3.0.0 and later.'
def libvlc_media_new_as_node(p_instance, psz_name): DCNL 'Create a media as an empty node with a given name. DCNL See L{libvlc_media_release}. DCNL @param p_instance: the instance. DCNL @param psz_name: the name of the node. DCNL @return: the new empty media or None on error.'
def libvlc_media_add_option(p_md, psz_options): DCNL 'Add an option to the media. DCNL This option will be used to determine how the media_player will DCNL read the media. This allows to use VLC\'s advanced DCNL reading/streaming options on a per-media basis. DCNL @note: The options are listed in \'vlc --long-help\' from the command line, DCNL e.g. "-sout-all". Keep in mind that available options and their semantics DCNL vary across LibVLC versions and builds. DCNL @warning: Not all options affects L{Media} objects: DCNL Specifically, due to architectural issues most audio and video options, DCNL such as text renderer options, have no effects on an individual media. DCNL These options must be set through L{libvlc_new}() instead. DCNL @param p_md: the media descriptor. DCNL @param psz_options: the options (as a string).'
def libvlc_media_add_option_flag(p_md, psz_options, i_flags): DCNL 'Add an option to the media with configurable flags. DCNL This option will be used to determine how the media_player will DCNL read the media. This allows to use VLC\'s advanced DCNL reading/streaming options on a per-media basis. DCNL The options are detailed in vlc --long-help, for instance DCNL "--sout-all". Note that all options are not usable on medias: DCNL specifically, due to architectural issues, video-related options DCNL such as text renderer options cannot be set on a single media. They DCNL must be set on the whole libvlc instance instead. DCNL @param p_md: the media descriptor. DCNL @param psz_options: the options (as a string). DCNL @param i_flags: the flags for this option.'
def libvlc_media_retain(p_md): DCNL 'Retain a reference to a media descriptor object (libvlc_media_t). Use DCNL L{libvlc_media_release}() to decrement the reference count of a DCNL media descriptor object. DCNL @param p_md: the media descriptor.'
def libvlc_media_release(p_md): DCNL 'Decrement the reference count of a media descriptor object. If the DCNL reference count is 0, then L{libvlc_media_release}() will release the DCNL media descriptor object. It will send out an libvlc_MediaFreed event DCNL to all listeners. If the media descriptor object has been released it DCNL should not be used again. DCNL @param p_md: the media descriptor.'
def libvlc_media_get_mrl(p_md): DCNL 'Get the media resource locator (mrl) from a media descriptor object. DCNL @param p_md: a media descriptor object. DCNL @return: string with mrl of media descriptor object.'
def libvlc_media_duplicate(p_md): DCNL 'Duplicate a media descriptor object. DCNL @param p_md: a media descriptor object.'
def libvlc_media_get_meta(p_md, e_meta): DCNL 'Read the meta of the media. DCNL If the media has not yet been parsed this will return None. DCNL This methods automatically calls L{libvlc_media_parse_async}(), so after calling DCNL it you may receive a libvlc_MediaMetaChanged event. If you prefer a synchronous DCNL version ensure that you call L{libvlc_media_parse}() before get_meta(). DCNL See L{libvlc_media_parse} DCNL See L{libvlc_media_parse_async} DCNL See libvlc_MediaMetaChanged. DCNL @param p_md: the media descriptor. DCNL @param e_meta: the meta to read. DCNL @return: the media\'s meta.'
def libvlc_media_set_meta(p_md, e_meta, psz_value): DCNL 'Set the meta of the media (this function will not save the meta, call DCNL L{libvlc_media_save_meta} in order to save the meta). DCNL @param p_md: the media descriptor. DCNL @param e_meta: the meta to write. DCNL @param psz_value: the media\'s meta.'
def libvlc_media_save_meta(p_md): DCNL 'Save the meta previously set. DCNL @param p_md: the media desriptor. DCNL @return: true if the write operation was successful.'
def libvlc_media_get_state(p_md): DCNL 'Get current state of media descriptor object. Possible media states DCNL are defined in libvlc_structures.c ( libvlc_NothingSpecial=0, DCNL libvlc_Opening, libvlc_Buffering, libvlc_Playing, libvlc_Paused, DCNL libvlc_Stopped, libvlc_Ended, DCNL libvlc_Error). DCNL See libvlc_state_t. DCNL @param p_md: a media descriptor object. DCNL @return: state of media descriptor object.'
def libvlc_media_get_stats(p_md, p_stats): DCNL 'Get the current statistics about the media. DCNL @param p_md:: media descriptor object. DCNL @param p_stats:: structure that contain the statistics about the media (this structure must be allocated by the caller). DCNL @return: true if the statistics are available, false otherwise \libvlc_return_bool.'
def libvlc_media_subitems(p_md): DCNL 'Get subitems of media descriptor object. This will increment DCNL the reference count of supplied media descriptor object. Use DCNL L{libvlc_media_list_release}() to decrement the reference counting. DCNL @param p_md: media descriptor object. DCNL @return: list of media descriptor subitems or None.'
def libvlc_media_event_manager(p_md): DCNL 'Get event manager from media descriptor object. DCNL NOTE: this function doesn\'t increment reference counting. DCNL @param p_md: a media descriptor object. DCNL @return: event manager object.'
def libvlc_media_get_duration(p_md): DCNL 'Get duration (in ms) of media descriptor object item. DCNL @param p_md: media descriptor object. DCNL @return: duration of media item or -1 on error.'
def libvlc_media_parse(p_md): DCNL 'Parse a media. DCNL This fetches (local) art, meta data and tracks information. DCNL The method is synchronous. DCNL See L{libvlc_media_parse_async} DCNL See L{libvlc_media_get_meta} DCNL See libvlc_media_get_tracks_info. DCNL @param p_md: media descriptor object.'
def libvlc_media_parse_async(p_md): DCNL 'Parse a media. DCNL This fetches (local) art, meta data and tracks information. DCNL The method is the asynchronous of L{libvlc_media_parse}(). DCNL To track when this is over you can listen to libvlc_MediaParsedChanged DCNL event. However if the media was already parsed you will not receive this DCNL event. DCNL See L{libvlc_media_parse} DCNL See libvlc_MediaParsedChanged DCNL See L{libvlc_media_get_meta} DCNL See libvlc_media_get_tracks_info. DCNL @param p_md: media descriptor object.'
def libvlc_media_parse_with_options(p_md, parse_flag): DCNL 'Parse the media asynchronously with options. DCNL This fetches (local or network) art, meta data and/or tracks information. DCNL This method is the extended version of L{libvlc_media_parse_async}(). DCNL To track when this is over you can listen to libvlc_MediaParsedChanged DCNL event. However if this functions returns an error, you will not receive this DCNL event. DCNL It uses a flag to specify parse options (see libvlc_media_parse_flag_t). All DCNL these flags can be combined. By default, media is parsed if it\'s a local DCNL file. DCNL See libvlc_MediaParsedChanged DCNL See L{libvlc_media_get_meta} DCNL See L{libvlc_media_tracks_get} DCNL See libvlc_media_parse_flag_t. DCNL @param p_md: media descriptor object. DCNL @param parse_flag: parse options: DCNL @return: -1 in case of error, 0 otherwise. DCNL @version: LibVLC 3.0.0 or later.'
def libvlc_media_is_parsed(p_md): DCNL 'Get Parsed status for media descriptor object. DCNL See libvlc_MediaParsedChanged. DCNL @param p_md: media descriptor object. DCNL @return: true if media object has been parsed otherwise it returns false \libvlc_return_bool.'
def libvlc_media_set_user_data(p_md, p_new_user_data): DCNL 'Sets media descriptor\'s user_data. user_data is specialized data DCNL accessed by the host application, VLC.framework uses it as a pointer to DCNL an native object that references a L{Media} pointer. DCNL @param p_md: media descriptor object. DCNL @param p_new_user_data: pointer to user data.'
def libvlc_media_get_user_data(p_md): DCNL 'Get media descriptor\'s user_data. user_data is specialized data DCNL accessed by the host application, VLC.framework uses it as a pointer to DCNL an native object that references a L{Media} pointer. DCNL @param p_md: media descriptor object.'
def libvlc_media_tracks_get(p_md, tracks): DCNL 'Get media descriptor\'s elementary streams description DCNL Note, you need to call L{libvlc_media_parse}() or play the media at least once DCNL before calling this function. DCNL Not doing this will result in an empty array. DCNL @param p_md: media descriptor object. DCNL @param tracks: address to store an allocated array of Elementary Streams descriptions (must be freed with L{libvlc_media_tracks_release}. DCNL @return: the number of Elementary Streams (zero on error). DCNL @version: LibVLC 2.1.0 and later.'
def libvlc_media_get_codec_description(i_type, i_codec): DCNL 'Get codec description from media elementary stream. DCNL @param i_type: i_type from L{MediaTrack}. DCNL @param i_codec: i_codec or i_original_fourcc from L{MediaTrack}. DCNL @return: codec description. DCNL @version: LibVLC 3.0.0 and later. See L{MediaTrack}.'
def libvlc_media_tracks_release(p_tracks, i_count): DCNL 'Release media descriptor\'s elementary streams description array. DCNL @param p_tracks: tracks info array to release. DCNL @param i_count: number of elements in the array. DCNL @version: LibVLC 2.1.0 and later.'
def libvlc_media_get_type(p_md): DCNL 'Get the media type of the media descriptor object. DCNL @param p_md: media descriptor object. DCNL @return: media type. DCNL @version: LibVLC 3.0.0 and later. See libvlc_media_type_t.'
def libvlc_media_discoverer_new(p_inst, psz_name): DCNL 'Create a media discoverer object by name. DCNL After this object is created, you should attach to events in order to be DCNL notified of the discoverer state. DCNL You should also attach to media_list events in order to be notified of new DCNL items discovered. DCNL You need to call L{libvlc_media_discoverer_start}() in order to start the DCNL discovery. DCNL See L{libvlc_media_discoverer_media_list} DCNL See L{libvlc_media_discoverer_event_manager} DCNL See L{libvlc_media_discoverer_start}. DCNL @param p_inst: libvlc instance. DCNL @param psz_name: service name. DCNL @return: media discover object or None in case of error. DCNL @version: LibVLC 3.0.0 or later.'
def libvlc_media_discoverer_start(p_mdis): DCNL 'Start media discovery. DCNL To stop it, call L{libvlc_media_discoverer_stop}() or DCNL L{libvlc_media_discoverer_release}() directly. DCNL See L{libvlc_media_discoverer_stop}. DCNL @param p_mdis: media discover object. DCNL @return: -1 in case of error, 0 otherwise. DCNL @version: LibVLC 3.0.0 or later.'
def libvlc_media_discoverer_stop(p_mdis): DCNL 'Stop media discovery. DCNL See L{libvlc_media_discoverer_start}. DCNL @param p_mdis: media discover object. DCNL @version: LibVLC 3.0.0 or later.'
def libvlc_media_discoverer_release(p_mdis): DCNL 'Release media discover object. If the reference count reaches 0, then DCNL the object will be released. DCNL @param p_mdis: media service discover object.'
def libvlc_media_discoverer_localized_name(p_mdis): DCNL 'Get media service discover object its localized name. DCNL @param p_mdis: media discover object. DCNL @return: localized name.'
def libvlc_media_discoverer_media_list(p_mdis): DCNL 'Get media service discover media list. DCNL @param p_mdis: media service discover object. DCNL @return: list of media items.'
def libvlc_media_discoverer_event_manager(p_mdis): DCNL 'Get event manager from media service discover object. DCNL @param p_mdis: media service discover object. DCNL @return: event manager object.'
def libvlc_media_discoverer_is_running(p_mdis): DCNL 'Query if media service discover object is running. DCNL @param p_mdis: media service discover object. DCNL @return: true if running, false if not \libvlc_return_bool.'
def libvlc_media_library_new(p_instance): DCNL 'Create an new Media Library object. DCNL @param p_instance: the libvlc instance. DCNL @return: a new object or None on error.'
def libvlc_media_library_release(p_mlib): DCNL 'Release media library object. This functions decrements the DCNL reference count of the media library object. If it reaches 0, DCNL then the object will be released. DCNL @param p_mlib: media library object.'
def libvlc_media_library_retain(p_mlib): DCNL 'Retain a reference to a media library object. This function will DCNL increment the reference counting for this object. Use DCNL L{libvlc_media_library_release}() to decrement the reference count. DCNL @param p_mlib: media library object.'
def libvlc_media_library_load(p_mlib): DCNL 'Load media library. DCNL @param p_mlib: media library object. DCNL @return: 0 on success, -1 on error.'
def libvlc_media_library_media_list(p_mlib): DCNL 'Get media library subitems. DCNL @param p_mlib: media library object. DCNL @return: media list subitems.'
def libvlc_media_list_new(p_instance): DCNL 'Create an empty media list. DCNL @param p_instance: libvlc instance. DCNL @return: empty media list, or None on error.'
def libvlc_media_list_release(p_ml): DCNL 'Release media list created with L{libvlc_media_list_new}(). DCNL @param p_ml: a media list created with L{libvlc_media_list_new}().'
def libvlc_media_list_retain(p_ml): DCNL 'Retain reference to a media list. DCNL @param p_ml: a media list created with L{libvlc_media_list_new}().'
def libvlc_media_list_set_media(p_ml, p_md): DCNL 'Associate media instance with this media list instance. DCNL If another media instance was present it will be released. DCNL The L{libvlc_media_list_lock} should NOT be held upon entering this function. DCNL @param p_ml: a media list instance. DCNL @param p_md: media instance to add.'
def libvlc_media_list_media(p_ml): DCNL 'Get media instance from this media list instance. This action will increase DCNL the refcount on the media instance. DCNL The L{libvlc_media_list_lock} should NOT be held upon entering this function. DCNL @param p_ml: a media list instance. DCNL @return: media instance.'
def libvlc_media_list_add_media(p_ml, p_md): DCNL 'Add media instance to media list DCNL The L{libvlc_media_list_lock} should be held upon entering this function. DCNL @param p_ml: a media list instance. DCNL @param p_md: a media instance. DCNL @return: 0 on success, -1 if the media list is read-only.'
def libvlc_media_list_insert_media(p_ml, p_md, i_pos): DCNL 'Insert media instance in media list on a position DCNL The L{libvlc_media_list_lock} should be held upon entering this function. DCNL @param p_ml: a media list instance. DCNL @param p_md: a media instance. DCNL @param i_pos: position in array where to insert. DCNL @return: 0 on success, -1 if the media list is read-only.'
def libvlc_media_list_remove_index(p_ml, i_pos): DCNL 'Remove media instance from media list on a position DCNL The L{libvlc_media_list_lock} should be held upon entering this function. DCNL @param p_ml: a media list instance. DCNL @param i_pos: position in array where to insert. DCNL @return: 0 on success, -1 if the list is read-only or the item was not found.'
def libvlc_media_list_count(p_ml): DCNL 'Get count on media list items DCNL The L{libvlc_media_list_lock} should be held upon entering this function. DCNL @param p_ml: a media list instance. DCNL @return: number of items in media list.'
def libvlc_media_list_item_at_index(p_ml, i_pos): DCNL 'List media instance in media list at a position DCNL The L{libvlc_media_list_lock} should be held upon entering this function. DCNL @param p_ml: a media list instance. DCNL @param i_pos: position in array where to insert. DCNL @return: media instance at position i_pos, or None if not found. In case of success, L{libvlc_media_retain}() is called to increase the refcount on the media.'
def libvlc_media_list_index_of_item(p_ml, p_md): DCNL 'Find index position of List media instance in media list. DCNL Warning: the function will return the first matched position. DCNL The L{libvlc_media_list_lock} should be held upon entering this function. DCNL @param p_ml: a media list instance. DCNL @param p_md: media instance. DCNL @return: position of media instance or -1 if media not found.'
def libvlc_media_list_is_readonly(p_ml): DCNL 'This indicates if this media list is read-only from a user point of view. DCNL @param p_ml: media list instance. DCNL @return: 1 on readonly, 0 on readwrite \libvlc_return_bool.'
def libvlc_media_list_lock(p_ml): DCNL 'Get lock on media list items. DCNL @param p_ml: a media list instance.'
def libvlc_media_list_unlock(p_ml): DCNL 'Release lock on media list items DCNL The L{libvlc_media_list_lock} should be held upon entering this function. DCNL @param p_ml: a media list instance.'
def libvlc_media_list_event_manager(p_ml): DCNL 'Get libvlc_event_manager from this media list instance. DCNL The p_event_manager is immutable, so you don\'t have to hold the lock. DCNL @param p_ml: a media list instance. DCNL @return: libvlc_event_manager.'
def libvlc_media_list_player_new(p_instance): DCNL 'Create new media_list_player. DCNL @param p_instance: libvlc instance. DCNL @return: media list player instance or None on error.'
def libvlc_media_list_player_release(p_mlp): DCNL 'Release a media_list_player after use DCNL Decrement the reference count of a media player object. If the DCNL reference count is 0, then L{libvlc_media_list_player_release}() will DCNL release the media player object. If the media player object DCNL has been released, then it should not be used again. DCNL @param p_mlp: media list player instance.'
def libvlc_media_list_player_retain(p_mlp): DCNL 'Retain a reference to a media player list object. Use DCNL L{libvlc_media_list_player_release}() to decrement reference count. DCNL @param p_mlp: media player list object.'
def libvlc_media_list_player_event_manager(p_mlp): DCNL 'Return the event manager of this media_list_player. DCNL @param p_mlp: media list player instance. DCNL @return: the event manager.'
def libvlc_media_list_player_set_media_player(p_mlp, p_mi): DCNL 'Replace media player in media_list_player with this instance. DCNL @param p_mlp: media list player instance. DCNL @param p_mi: media player instance.'
def libvlc_media_list_player_get_media_player(p_mlp): DCNL 'Get media player of the media_list_player instance. DCNL @param p_mlp: media list player instance. DCNL @return: media player instance @note the caller is responsible for releasing the returned instance.'
def libvlc_media_list_player_set_media_list(p_mlp, p_mlist): DCNL 'Set the media list associated with the player. DCNL @param p_mlp: media list player instance. DCNL @param p_mlist: list of media.'
def libvlc_media_list_player_play(p_mlp): DCNL 'Play media list. DCNL @param p_mlp: media list player instance.'
def libvlc_media_list_player_pause(p_mlp): DCNL 'Toggle pause (or resume) media list. DCNL @param p_mlp: media list player instance.'
def libvlc_media_list_player_is_playing(p_mlp): DCNL 'Is media list playing? DCNL @param p_mlp: media list player instance. DCNL @return: true for playing and false for not playing \libvlc_return_bool.'
def libvlc_media_list_player_get_state(p_mlp): DCNL 'Get current libvlc_state of media list player. DCNL @param p_mlp: media list player instance. DCNL @return: libvlc_state_t for media list player.'
def libvlc_media_list_player_play_item_at_index(p_mlp, i_index): DCNL 'Play media list item at position index. DCNL @param p_mlp: media list player instance. DCNL @param i_index: index in media list to play. DCNL @return: 0 upon success -1 if the item wasn\'t found.'
def libvlc_media_list_player_play_item(p_mlp, p_md): DCNL 'Play the given media item. DCNL @param p_mlp: media list player instance. DCNL @param p_md: the media instance. DCNL @return: 0 upon success, -1 if the media is not part of the media list.'
def libvlc_media_list_player_stop(p_mlp): DCNL 'Stop playing media list. DCNL @param p_mlp: media list player instance.'
def libvlc_media_list_player_next(p_mlp): DCNL 'Play next item from media list. DCNL @param p_mlp: media list player instance. DCNL @return: 0 upon success -1 if there is no next item.'
def libvlc_media_list_player_previous(p_mlp): DCNL 'Play previous item from media list. DCNL @param p_mlp: media list player instance. DCNL @return: 0 upon success -1 if there is no previous item.'
def libvlc_media_list_player_set_playback_mode(p_mlp, e_mode): DCNL 'Sets the playback mode for the playlist. DCNL @param p_mlp: media list player instance. DCNL @param e_mode: playback mode specification.'
def libvlc_media_player_new(p_libvlc_instance): DCNL 'Create an empty Media Player object. DCNL @param p_libvlc_instance: the libvlc instance in which the Media Player should be created. DCNL @return: a new media player object, or None on error.'
def libvlc_media_player_new_from_media(p_md): DCNL 'Create a Media Player object from a Media. DCNL @param p_md: the media. Afterwards the p_md can be safely destroyed. DCNL @return: a new media player object, or None on error.'
def libvlc_media_player_release(p_mi): DCNL 'Release a media_player after use DCNL Decrement the reference count of a media player object. If the DCNL reference count is 0, then L{libvlc_media_player_release}() will DCNL release the media player object. If the media player object DCNL has been released, then it should not be used again. DCNL @param p_mi: the Media Player to free.'
def libvlc_media_player_retain(p_mi): DCNL 'Retain a reference to a media player object. Use DCNL L{libvlc_media_player_release}() to decrement reference count. DCNL @param p_mi: media player object.'
def libvlc_media_player_set_media(p_mi, p_md): DCNL 'Set the media that will be used by the media_player. If any, DCNL previous md will be released. DCNL @param p_mi: the Media Player. DCNL @param p_md: the Media. Afterwards the p_md can be safely destroyed.'
def libvlc_media_player_get_media(p_mi): DCNL 'Get the media used by the media_player. DCNL @param p_mi: the Media Player. DCNL @return: the media associated with p_mi, or None if no media is associated.'
def libvlc_media_player_event_manager(p_mi): DCNL 'Get the Event Manager from which the media player send event. DCNL @param p_mi: the Media Player. DCNL @return: the event manager associated with p_mi.'
def libvlc_media_player_is_playing(p_mi): DCNL 'is_playing. DCNL @param p_mi: the Media Player. DCNL @return: 1 if the media player is playing, 0 otherwise \libvlc_return_bool.'
def libvlc_media_player_play(p_mi): DCNL 'Play. DCNL @param p_mi: the Media Player. DCNL @return: 0 if playback started (and was already started), or -1 on error.'
def libvlc_media_player_set_pause(mp, do_pause): DCNL 'Pause or resume (no effect if there is no media). DCNL @param mp: the Media Player. DCNL @param do_pause: play/resume if zero, pause if non-zero. DCNL @version: LibVLC 1.1.1 or later.'
def libvlc_media_player_pause(p_mi): DCNL 'Toggle pause (no effect if there is no media). DCNL @param p_mi: the Media Player.'
def libvlc_media_player_stop(p_mi): DCNL 'Stop (no effect if there is no media). DCNL @param p_mi: the Media Player.'
def libvlc_video_set_callbacks(mp, lock, unlock, display, opaque): DCNL 'Set callbacks and private data to render decoded video to a custom area DCNL in memory. DCNL Use L{libvlc_video_set_format}() or L{libvlc_video_set_format_callbacks}() DCNL to configure the decoded format. DCNL @param mp: the media player. DCNL @param lock: callback to lock video memory (must not be None). DCNL @param unlock: callback to unlock video memory (or None if not needed). DCNL @param display: callback to display video (or None if not needed). DCNL @param opaque: private pointer for the three callbacks (as first parameter). DCNL @version: LibVLC 1.1.1 or later.'
def libvlc_video_set_format(mp, chroma, width, height, pitch): DCNL 'Set decoded video chroma and dimensions. DCNL This only works in combination with L{libvlc_video_set_callbacks}(), DCNL and is mutually exclusive with L{libvlc_video_set_format_callbacks}(). DCNL @param mp: the media player. DCNL @param chroma: a four-characters string identifying the chroma (e.g. "RV32" or "YUYV"). DCNL @param width: pixel width. DCNL @param height: pixel height. DCNL @param pitch: line pitch (in bytes). DCNL @version: LibVLC 1.1.1 or later. DCNL @bug: All pixel planes are expected to have the same pitch. To use the YCbCr color space with chrominance subsampling, consider using L{libvlc_video_set_format_callbacks}() instead.'
def libvlc_video_set_format_callbacks(mp, setup, cleanup): DCNL 'Set decoded video chroma and dimensions. This only works in combination with DCNL L{libvlc_video_set_callbacks}(). DCNL @param mp: the media player. DCNL @param setup: callback to select the video format (cannot be None). DCNL @param cleanup: callback to release any allocated resources (or None). DCNL @version: LibVLC 2.0.0 or later.'
def libvlc_media_player_set_nsobject(p_mi, drawable): DCNL 'Set the NSView handler where the media player should render its video output. DCNL Use the vout called "macosx". DCNL The drawable is an NSObject that follow the VLCOpenGLVideoViewEmbedding DCNL protocol: DCNL @code.m DCNL \@protocol VLCOpenGLVideoViewEmbedding <NSObject> DCNL - (void)addVoutSubview:(NSView *)view; DCNL - (void)removeVoutSubview:(NSView *)view; DCNL \@end DCNL @endcode DCNL Or it can be an NSView object. DCNL If you want to use it along with Qt4 see the QMacCocoaViewContainer. Then DCNL the following code should work: DCNL @code.mm DCNL NSView *video = [[NSView alloc] init]; DCNL QMacCocoaViewContainer *container = new QMacCocoaViewContainer(video, parent); DCNL L{libvlc_media_player_set_nsobject}(mp, video); DCNL [video release]; DCNL @endcode DCNL You can find a live example in VLCVideoView in VLCKit.framework. DCNL @param p_mi: the Media Player. DCNL @param drawable: the drawable that is either an NSView or an object following the VLCOpenGLVideoViewEmbedding protocol.'
def libvlc_media_player_get_nsobject(p_mi): DCNL 'Get the NSView handler previously set with L{libvlc_media_player_set_nsobject}(). DCNL @param p_mi: the Media Player. DCNL @return: the NSView handler or 0 if none where set.'
def libvlc_media_player_set_agl(p_mi, drawable): DCNL '\deprecated Use L{libvlc_media_player_set_nsobject} instead.'
def libvlc_media_player_get_agl(p_mi): DCNL '\deprecated Use L{libvlc_media_player_get_nsobject} instead.'
def libvlc_media_player_set_xwindow(p_mi, drawable): DCNL 'Set an X Window System drawable where the media player should render its DCNL video output. The call takes effect when the playback starts. If it is DCNL already started, it might need to be stopped before changes apply. DCNL If LibVLC was built without X11 output support, then this function has no DCNL effects. DCNL By default, LibVLC will capture input events on the video rendering area. DCNL Use L{libvlc_video_set_mouse_input}() and L{libvlc_video_set_key_input}() to DCNL disable that and deliver events to the parent window / to the application DCNL instead. By design, the X11 protocol delivers input events to only one DCNL recipient. DCNL @warning DCNL The application must call the XInitThreads() function from Xlib before DCNL L{libvlc_new}(), and before any call to XOpenDisplay() directly or via any DCNL other library. Failure to call XInitThreads() will seriously impede LibVLC DCNL performance. Calling XOpenDisplay() before XInitThreads() will eventually DCNL crash the process. That is a limitation of Xlib. DCNL @param p_mi: media player. DCNL @param drawable: X11 window ID @note The specified identifier must correspond to an existing Input/Output class X11 window. Pixmaps are B{not} currently supported. The default X11 server is assumed, i.e. that specified in the DISPLAY environment variable. @warning LibVLC can deal with invalid X11 handle errors, however some display drivers (EGL, GLX, VA and/or VDPAU) can unfortunately not. Thus the window handle must remain valid until playback is stopped, otherwise the process may abort or crash. DCNL @bug No more than one window handle per media player instance can be specified. If the media has multiple simultaneously active video tracks, extra tracks will be rendered into external windows beyond the control of the application.'
def libvlc_media_player_get_xwindow(p_mi): DCNL 'Get the X Window System window identifier previously set with DCNL L{libvlc_media_player_set_xwindow}(). Note that this will return the identifier DCNL even if VLC is not currently using it (for instance if it is playing an DCNL audio-only input). DCNL @param p_mi: the Media Player. DCNL @return: an X window ID, or 0 if none where set.'
def libvlc_media_player_set_hwnd(p_mi, drawable): DCNL 'Set a Win32/Win64 API window handle (HWND) where the media player should DCNL render its video output. If LibVLC was built without Win32/Win64 API output DCNL support, then this has no effects. DCNL @param p_mi: the Media Player. DCNL @param drawable: windows handle of the drawable.'
def libvlc_media_player_get_hwnd(p_mi): DCNL 'Get the Windows API window handle (HWND) previously set with DCNL L{libvlc_media_player_set_hwnd}(). The handle will be returned even if LibVLC DCNL is not currently outputting any video to it. DCNL @param p_mi: the Media Player. DCNL @return: a window handle or None if there are none.'
def libvlc_media_player_set_android_context(p_mi, p_jvm, p_awindow_handler): DCNL 'Set the android context. DCNL @param p_mi: the media player. DCNL @param p_jvm: the Java VM of the android process. DCNL @param awindow_handler: org.videolan.libvlc.IAWindowNativeHandler jobject implemented by the org.videolan.libvlc.MediaPlayer class from the libvlc-android project. DCNL @version: LibVLC 3.0.0 and later.'
def libvlc_audio_set_callbacks(mp, play, pause, resume, flush, drain, opaque): DCNL 'Set callbacks and private data for decoded audio. DCNL Use L{libvlc_audio_set_format}() or L{libvlc_audio_set_format_callbacks}() DCNL to configure the decoded audio format. DCNL @param mp: the media player. DCNL @param play: callback to play audio samples (must not be None). DCNL @param pause: callback to pause playback (or None to ignore). DCNL @param resume: callback to resume playback (or None to ignore). DCNL @param flush: callback to flush audio buffers (or None to ignore). DCNL @param drain: callback to drain audio buffers (or None to ignore). DCNL @param opaque: private pointer for the audio callbacks (as first parameter). DCNL @version: LibVLC 2.0.0 or later.'
def libvlc_audio_set_volume_callback(mp, set_volume): DCNL 'Set callbacks and private data for decoded audio. This only works in DCNL combination with L{libvlc_audio_set_callbacks}(). DCNL Use L{libvlc_audio_set_format}() or L{libvlc_audio_set_format_callbacks}() DCNL to configure the decoded audio format. DCNL @param mp: the media player. DCNL @param set_volume: callback to apply audio volume, or None to apply volume in software. DCNL @version: LibVLC 2.0.0 or later.'
def libvlc_audio_set_format_callbacks(mp, setup, cleanup): DCNL 'Set decoded audio format. This only works in combination with DCNL L{libvlc_audio_set_callbacks}(). DCNL @param mp: the media player. DCNL @param setup: callback to select the audio format (cannot be None). DCNL @param cleanup: callback to release any allocated resources (or None). DCNL @version: LibVLC 2.0.0 or later.'
def libvlc_audio_set_format(mp, format, rate, channels): DCNL 'Set decoded audio format. DCNL This only works in combination with L{libvlc_audio_set_callbacks}(), DCNL and is mutually exclusive with L{libvlc_audio_set_format_callbacks}(). DCNL @param mp: the media player. DCNL @param format: a four-characters string identifying the sample format (e.g. "S16N" or "FL32"). DCNL @param rate: sample rate (expressed in Hz). DCNL @param channels: channels count. DCNL @version: LibVLC 2.0.0 or later.'
def libvlc_media_player_get_length(p_mi): DCNL 'Get the current movie length (in ms). DCNL @param p_mi: the Media Player. DCNL @return: the movie length (in ms), or -1 if there is no media.'
def libvlc_media_player_get_time(p_mi): DCNL 'Get the current movie time (in ms). DCNL @param p_mi: the Media Player. DCNL @return: the movie time (in ms), or -1 if there is no media.'
def libvlc_media_player_set_time(p_mi, i_time): DCNL 'Set the movie time (in ms). This has no effect if no media is being played. DCNL Not all formats and protocols support this. DCNL @param p_mi: the Media Player. DCNL @param i_time: the movie time (in ms).'
def libvlc_media_player_get_position(p_mi): DCNL 'Get movie position as percentage between 0.0 and 1.0. DCNL @param p_mi: the Media Player. DCNL @return: movie position, or -1. in case of error.'
def libvlc_media_player_set_position(p_mi, f_pos): DCNL 'Set movie position as percentage between 0.0 and 1.0. DCNL This has no effect if playback is not enabled. DCNL This might not work depending on the underlying input format and protocol. DCNL @param p_mi: the Media Player. DCNL @param f_pos: the position.'
def libvlc_media_player_set_chapter(p_mi, i_chapter): DCNL 'Set movie chapter (if applicable). DCNL @param p_mi: the Media Player. DCNL @param i_chapter: chapter number to play.'
def libvlc_media_player_get_chapter(p_mi): DCNL 'Get movie chapter. DCNL @param p_mi: the Media Player. DCNL @return: chapter number currently playing, or -1 if there is no media.'
def libvlc_media_player_get_chapter_count(p_mi): DCNL 'Get movie chapter count. DCNL @param p_mi: the Media Player. DCNL @return: number of chapters in movie, or -1.'
def libvlc_media_player_will_play(p_mi): DCNL 'Is the player able to play. DCNL @param p_mi: the Media Player. DCNL @return: boolean \libvlc_return_bool.'
def libvlc_media_player_get_chapter_count_for_title(p_mi, i_title): DCNL 'Get title chapter count. DCNL @param p_mi: the Media Player. DCNL @param i_title: title. DCNL @return: number of chapters in title, or -1.'
def libvlc_media_player_set_title(p_mi, i_title): DCNL 'Set movie title. DCNL @param p_mi: the Media Player. DCNL @param i_title: title number to play.'
def libvlc_media_player_get_title(p_mi): DCNL 'Get movie title. DCNL @param p_mi: the Media Player. DCNL @return: title number currently playing, or -1.'
def libvlc_media_player_get_title_count(p_mi): DCNL 'Get movie title count. DCNL @param p_mi: the Media Player. DCNL @return: title number count, or -1.'
def libvlc_media_player_previous_chapter(p_mi): DCNL 'Set previous chapter (if applicable). DCNL @param p_mi: the Media Player.'
def libvlc_media_player_next_chapter(p_mi): DCNL 'Set next chapter (if applicable). DCNL @param p_mi: the Media Player.'
def libvlc_media_player_get_rate(p_mi): DCNL 'Get the requested movie play rate. DCNL @warning: Depending on the underlying media, the requested rate may be DCNL different from the real playback rate. DCNL @param p_mi: the Media Player. DCNL @return: movie play rate.'
def libvlc_media_player_set_rate(p_mi, rate): DCNL 'Set movie play rate. DCNL @param p_mi: the Media Player. DCNL @param rate: movie play rate to set. DCNL @return: -1 if an error was detected, 0 otherwise (but even then, it might not actually work depending on the underlying media protocol).'
def libvlc_media_player_get_state(p_mi): DCNL 'Get current movie state. DCNL @param p_mi: the Media Player. DCNL @return: the current state of the media player (playing, paused, ...) See libvlc_state_t.'
def libvlc_media_player_get_fps(p_mi): DCNL 'Get movie fps rate. DCNL @param p_mi: the Media Player. DCNL @return: frames per second (fps) for this playing movie, or 0 if unspecified.'
def libvlc_media_player_has_vout(p_mi): DCNL 'How many video outputs does this media player have? DCNL @param p_mi: the media player. DCNL @return: the number of video outputs.'
def libvlc_media_player_is_seekable(p_mi): DCNL 'Is this media player seekable? DCNL @param p_mi: the media player. DCNL @return: true if the media player can seek \libvlc_return_bool.'
def libvlc_media_player_can_pause(p_mi): DCNL 'Can this media player be paused? DCNL @param p_mi: the media player. DCNL @return: true if the media player can pause \libvlc_return_bool.'
def libvlc_media_player_program_scrambled(p_mi): DCNL 'Check if the current program is scrambled. DCNL @param p_mi: the media player. DCNL @return: true if the current program is scrambled \libvlc_return_bool. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_media_player_next_frame(p_mi): DCNL 'Display the next frame (if supported). DCNL @param p_mi: the media player.'
def libvlc_media_player_navigate(p_mi, navigate): DCNL 'Navigate through DVD Menu. DCNL @param p_mi: the Media Player. DCNL @param navigate: the Navigation mode. DCNL @version: libVLC 2.0.0 or later.'
def libvlc_media_player_set_video_title_display(p_mi, position, timeout): DCNL 'Set if, and how, the video title will be shown when media is played. DCNL @param p_mi: the media player. DCNL @param position: position at which to display the title, or libvlc_position_disable to prevent the title from being displayed. DCNL @param timeout: title display timeout in milliseconds (ignored if libvlc_position_disable). DCNL @version: libVLC 2.1.0 or later.'
def libvlc_track_description_list_release(p_track_description): DCNL 'Release (free) L{TrackDescription}. DCNL @param p_track_description: the structure to release.'
def libvlc_toggle_fullscreen(p_mi): DCNL 'Toggle fullscreen status on non-embedded video outputs. DCNL @warning: The same limitations applies to this function DCNL as to L{libvlc_set_fullscreen}(). DCNL @param p_mi: the media player.'
def libvlc_set_fullscreen(p_mi, b_fullscreen): DCNL 'Enable or disable fullscreen. DCNL @warning: With most window managers, only a top-level windows can be in DCNL full-screen mode. Hence, this function will not operate properly if DCNL L{libvlc_media_player_set_xwindow}() was used to embed the video in a DCNL non-top-level window. In that case, the embedding window must be reparented DCNL to the root window B{before} fullscreen mode is enabled. You will want DCNL to reparent it back to its normal parent when disabling fullscreen. DCNL @param p_mi: the media player. DCNL @param b_fullscreen: boolean for fullscreen status.'
def libvlc_get_fullscreen(p_mi): DCNL 'Get current fullscreen status. DCNL @param p_mi: the media player. DCNL @return: the fullscreen status (boolean) \libvlc_return_bool.'
def libvlc_video_set_key_input(p_mi, on): DCNL 'Enable or disable key press events handling, according to the LibVLC hotkeys DCNL configuration. By default and for historical reasons, keyboard events are DCNL handled by the LibVLC video widget. DCNL @note: On X11, there can be only one subscriber for key press and mouse DCNL click events per window. If your application has subscribed to those events DCNL for the X window ID of the video widget, then LibVLC will not be able to DCNL handle key presses and mouse clicks in any case. DCNL @warning: This function is only implemented for X11 and Win32 at the moment. DCNL @param p_mi: the media player. DCNL @param on: true to handle key press events, false to ignore them.'
def libvlc_video_set_mouse_input(p_mi, on): DCNL 'Enable or disable mouse click events handling. By default, those events are DCNL handled. This is needed for DVD menus to work, as well as a few video DCNL filters such as "puzzle". DCNL See L{libvlc_video_set_key_input}(). DCNL @warning: This function is only implemented for X11 and Win32 at the moment. DCNL @param p_mi: the media player. DCNL @param on: true to handle mouse click events, false to ignore them.'
def libvlc_video_get_size(p_mi, num): DCNL 'Get the pixel dimensions of a video. DCNL @param p_mi: media player. DCNL @param num: number of the video (starting from, and most commonly 0). DCNL @return: px pixel width, py pixel height.'
def libvlc_video_get_cursor(p_mi, num): DCNL 'Get the mouse pointer coordinates over a video. DCNL Coordinates are expressed in terms of the decoded video resolution, DCNL B{not} in terms of pixels on the screen/viewport (to get the latter, DCNL you can query your windowing system directly). DCNL Either of the coordinates may be negative or larger than the corresponding DCNL dimension of the video, if the cursor is outside the rendering area. DCNL @warning: The coordinates may be out-of-date if the pointer is not located DCNL on the video rendering area. LibVLC does not track the pointer if it is DCNL outside of the video widget. DCNL @note: LibVLC does not support multiple pointers (it does of course support DCNL multiple input devices sharing the same pointer) at the moment. DCNL @param p_mi: media player. DCNL @param num: number of the video (starting from, and most commonly 0). DCNL @return: px abscissa, py ordinate.'
def libvlc_video_get_scale(p_mi): DCNL 'Get the current video scaling factor. DCNL See also L{libvlc_video_set_scale}(). DCNL @param p_mi: the media player. DCNL @return: the currently configured zoom factor, or 0. if the video is set to fit to the output window/drawable automatically.'
def libvlc_video_set_scale(p_mi, f_factor): DCNL 'Set the video scaling factor. That is the ratio of the number of pixels on DCNL screen to the number of pixels in the original decoded video in each DCNL dimension. Zero is a special value; it will adjust the video to the output DCNL window/drawable (in windowed mode) or the entire screen. DCNL Note that not all video outputs support scaling. DCNL @param p_mi: the media player. DCNL @param f_factor: the scaling factor, or zero.'
def libvlc_video_get_aspect_ratio(p_mi): DCNL 'Get current video aspect ratio. DCNL @param p_mi: the media player. DCNL @return: the video aspect ratio or None if unspecified (the result must be released with free() or L{libvlc_free}()).'
def libvlc_video_set_aspect_ratio(p_mi, psz_aspect): DCNL 'Set new video aspect ratio. DCNL @param p_mi: the media player. DCNL @param psz_aspect: new video aspect-ratio or None to reset to default @note Invalid aspect ratios are ignored.'
def libvlc_video_get_spu(p_mi): DCNL 'Get current video subtitle. DCNL @param p_mi: the media player. DCNL @return: the video subtitle selected, or -1 if none.'
def libvlc_video_get_spu_count(p_mi): DCNL 'Get the number of available video subtitles. DCNL @param p_mi: the media player. DCNL @return: the number of available video subtitles.'
def libvlc_video_get_spu_description(p_mi): DCNL 'Get the description of available video subtitles. DCNL @param p_mi: the media player. DCNL @return: list containing description of available video subtitles. It must be freed with L{libvlc_track_description_list_release}().'
def libvlc_video_set_spu(p_mi, i_spu): DCNL 'Set new video subtitle. DCNL @param p_mi: the media player. DCNL @param i_spu: video subtitle track to select (i_id from track description). DCNL @return: 0 on success, -1 if out of range.'
def libvlc_video_set_subtitle_file(p_mi, psz_subtitle): DCNL 'Set new video subtitle file. DCNL @param p_mi: the media player. DCNL @param psz_subtitle: new video subtitle file. DCNL @return: the success status (boolean).'
def libvlc_video_get_spu_delay(p_mi): DCNL 'Get the current subtitle delay. Positive values means subtitles are being DCNL displayed later, negative values earlier. DCNL @param p_mi: media player. DCNL @return: time (in microseconds) the display of subtitles is being delayed. DCNL @version: LibVLC 2.0.0 or later.'
def libvlc_video_set_spu_delay(p_mi, i_delay): DCNL 'Set the subtitle delay. This affects the timing of when the subtitle will DCNL be displayed. Positive values result in subtitles being displayed later, DCNL while negative values will result in subtitles being displayed earlier. DCNL The subtitle delay will be reset to zero each time the media changes. DCNL @param p_mi: media player. DCNL @param i_delay: time (in microseconds) the display of subtitles should be delayed. DCNL @return: 0 on success, -1 on error. DCNL @version: LibVLC 2.0.0 or later.'
def libvlc_media_player_get_full_title_descriptions(p_mi, titles): DCNL 'Get the full description of available titles. DCNL @param p_mi: the media player. DCNL @param address: to store an allocated array of title descriptions descriptions (must be freed with L{libvlc_title_descriptions_release}() by the caller) [OUT]. DCNL @return: the number of titles (-1 on error). DCNL @version: LibVLC 3.0.0 and later.'
def libvlc_title_descriptions_release(p_titles, i_count): DCNL 'Release a title description. DCNL @param title: description array to release. DCNL @param number: of title descriptions to release. DCNL @version: LibVLC 3.0.0 and later.'
def libvlc_media_player_get_full_chapter_descriptions(p_mi, i_chapters_of_title, pp_chapters): DCNL 'Get the full description of available chapters. DCNL @param p_mi: the media player. DCNL @param index: of the title to query for chapters (uses current title if set to -1). DCNL @param address: to store an allocated array of chapter descriptions descriptions (must be freed with L{libvlc_chapter_descriptions_release}() by the caller) [OUT]. DCNL @return: the number of chapters (-1 on error). DCNL @version: LibVLC 3.0.0 and later.'
def libvlc_chapter_descriptions_release(p_chapters, i_count): DCNL 'Release a chapter description. DCNL @param chapter: description array to release. DCNL @param number: of chapter descriptions to release. DCNL @version: LibVLC 3.0.0 and later.'
def libvlc_video_get_crop_geometry(p_mi): DCNL 'Get current crop filter geometry. DCNL @param p_mi: the media player. DCNL @return: the crop filter geometry or None if unset.'
def libvlc_video_set_crop_geometry(p_mi, psz_geometry): DCNL 'Set new crop filter geometry. DCNL @param p_mi: the media player. DCNL @param psz_geometry: new crop filter geometry (None to unset).'
def libvlc_video_get_teletext(p_mi): DCNL 'Get current teletext page requested. DCNL @param p_mi: the media player. DCNL @return: the current teletext page requested.'
def libvlc_video_set_teletext(p_mi, i_page): DCNL 'Set new teletext page to retrieve. DCNL @param p_mi: the media player. DCNL @param i_page: teletex page number requested.'
def libvlc_toggle_teletext(p_mi): DCNL 'Toggle teletext transparent status on video output. DCNL @param p_mi: the media player.'
def libvlc_video_get_track_count(p_mi): DCNL 'Get number of available video tracks. DCNL @param p_mi: media player. DCNL @return: the number of available video tracks (int).'
def libvlc_video_get_track_description(p_mi): DCNL 'Get the description of available video tracks. DCNL @param p_mi: media player. DCNL @return: list with description of available video tracks, or None on error. It must be freed with L{libvlc_track_description_list_release}().'
def libvlc_video_get_track(p_mi): DCNL 'Get current video track. DCNL @param p_mi: media player. DCNL @return: the video track ID (int) or -1 if no active input.'
def libvlc_video_set_track(p_mi, i_track): DCNL 'Set video track. DCNL @param p_mi: media player. DCNL @param i_track: the track ID (i_id field from track description). DCNL @return: 0 on success, -1 if out of range.'
def libvlc_video_take_snapshot(p_mi, num, psz_filepath, i_width, i_height): DCNL 'Take a snapshot of the current video window. DCNL If i_width AND i_height is 0, original size is used. DCNL If i_width XOR i_height is 0, original aspect-ratio is preserved. DCNL @param p_mi: media player instance. DCNL @param num: number of video output (typically 0 for the first/only one). DCNL @param psz_filepath: the path where to save the screenshot to. DCNL @param i_width: the snapshot\'s width. DCNL @param i_height: the snapshot\'s height. DCNL @return: 0 on success, -1 if the video was not found.'
def libvlc_video_set_deinterlace(p_mi, psz_mode): DCNL 'Enable or disable deinterlace filter. DCNL @param p_mi: libvlc media player. DCNL @param psz_mode: type of deinterlace filter, None to disable.'
def libvlc_video_get_marquee_int(p_mi, option): DCNL 'Get an integer marquee option value. DCNL @param p_mi: libvlc media player. DCNL @param option: marq option to get See libvlc_video_marquee_int_option_t.'
def libvlc_video_get_marquee_string(p_mi, option): DCNL 'Get a string marquee option value. DCNL @param p_mi: libvlc media player. DCNL @param option: marq option to get See libvlc_video_marquee_string_option_t.'
def libvlc_video_set_marquee_int(p_mi, option, i_val): DCNL 'Enable, disable or set an integer marquee option DCNL Setting libvlc_marquee_Enable has the side effect of enabling (arg !0) DCNL or disabling (arg 0) the marq filter. DCNL @param p_mi: libvlc media player. DCNL @param option: marq option to set See libvlc_video_marquee_int_option_t. DCNL @param i_val: marq option value.'
def libvlc_video_set_marquee_string(p_mi, option, psz_text): DCNL 'Set a marquee string option. DCNL @param p_mi: libvlc media player. DCNL @param option: marq option to set See libvlc_video_marquee_string_option_t. DCNL @param psz_text: marq option value.'
def libvlc_video_get_logo_int(p_mi, option): DCNL 'Get integer logo option. DCNL @param p_mi: libvlc media player instance. DCNL @param option: logo option to get, values of libvlc_video_logo_option_t.'
def libvlc_video_set_logo_int(p_mi, option, value): DCNL 'Set logo option as integer. Options that take a different type value DCNL are ignored. DCNL Passing libvlc_logo_enable as option value has the side effect of DCNL starting (arg !0) or stopping (arg 0) the logo filter. DCNL @param p_mi: libvlc media player instance. DCNL @param option: logo option to set, values of libvlc_video_logo_option_t. DCNL @param value: logo option value.'
def libvlc_video_set_logo_string(p_mi, option, psz_value): DCNL 'Set logo option as string. Options that take a different type value DCNL are ignored. DCNL @param p_mi: libvlc media player instance. DCNL @param option: logo option to set, values of libvlc_video_logo_option_t. DCNL @param psz_value: logo option value.'
def libvlc_video_get_adjust_int(p_mi, option): DCNL 'Get integer adjust option. DCNL @param p_mi: libvlc media player instance. DCNL @param option: adjust option to get, values of libvlc_video_adjust_option_t. DCNL @version: LibVLC 1.1.1 and later.'
def libvlc_video_set_adjust_int(p_mi, option, value): DCNL 'Set adjust option as integer. Options that take a different type value DCNL are ignored. DCNL Passing libvlc_adjust_enable as option value has the side effect of DCNL starting (arg !0) or stopping (arg 0) the adjust filter. DCNL @param p_mi: libvlc media player instance. DCNL @param option: adust option to set, values of libvlc_video_adjust_option_t. DCNL @param value: adjust option value. DCNL @version: LibVLC 1.1.1 and later.'
def libvlc_video_get_adjust_float(p_mi, option): DCNL 'Get float adjust option. DCNL @param p_mi: libvlc media player instance. DCNL @param option: adjust option to get, values of libvlc_video_adjust_option_t. DCNL @version: LibVLC 1.1.1 and later.'
def libvlc_video_set_adjust_float(p_mi, option, value): DCNL 'Set adjust option as float. Options that take a different type value DCNL are ignored. DCNL @param p_mi: libvlc media player instance. DCNL @param option: adust option to set, values of libvlc_video_adjust_option_t. DCNL @param value: adjust option value. DCNL @version: LibVLC 1.1.1 and later.'
def libvlc_audio_output_list_get(p_instance): DCNL 'Gets the list of available audio output modules. DCNL @param p_instance: libvlc instance. DCNL @return: list of available audio outputs. It must be freed with In case of error, None is returned.'
def libvlc_audio_output_list_release(p_list): DCNL 'Frees the list of available audio output modules. DCNL @param p_list: list with audio outputs for release.'
def libvlc_audio_output_set(p_mi, psz_name): DCNL 'Selects an audio output module. DCNL @note: Any change will take be effect only after playback is stopped and DCNL restarted. Audio output cannot be changed while playing. DCNL @param p_mi: media player. DCNL @param psz_name: name of audio output, use psz_name of See L{AudioOutput}. DCNL @return: 0 if function succeded, -1 on error.'
def libvlc_audio_output_device_enum(mp): DCNL 'Gets a list of potential audio output devices, DCNL See L{libvlc_audio_output_device_set}(). DCNL @note: Not all audio outputs support enumerating devices. DCNL The audio output may be functional even if the list is empty (None). DCNL @note: The list may not be exhaustive. DCNL @warning: Some audio output devices in the list might not actually work in DCNL some circumstances. By default, it is recommended to not specify any DCNL explicit audio device. DCNL @param mp: media player. DCNL @return: A None-terminated linked list of potential audio output devices. It must be freed with L{libvlc_audio_output_device_list_release}(). DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_output_device_list_get(p_instance, aout): DCNL 'Gets a list of audio output devices for a given audio output module, DCNL See L{libvlc_audio_output_device_set}(). DCNL @note: Not all audio outputs support this. In particular, an empty (None) DCNL list of devices does B{not} imply that the specified audio output does DCNL not work. DCNL @note: The list might not be exhaustive. DCNL @warning: Some audio output devices in the list might not actually work in DCNL some circumstances. By default, it is recommended to not specify any DCNL explicit audio device. DCNL @param p_instance: libvlc instance. DCNL @param psz_aout: audio output name (as returned by L{libvlc_audio_output_list_get}()). DCNL @return: A None-terminated linked list of potential audio output devices. It must be freed with L{libvlc_audio_output_device_list_release}(). DCNL @version: LibVLC 2.1.0 or later.'
def libvlc_audio_output_device_list_release(p_list): DCNL 'Frees a list of available audio output devices. DCNL @param p_list: list with audio outputs for release. DCNL @version: LibVLC 2.1.0 or later.'
def libvlc_audio_output_device_set(mp, module, device_id): DCNL 'Configures an explicit audio output device. DCNL If the module paramater is None, audio output will be moved to the device DCNL specified by the device identifier string immediately. This is the DCNL recommended usage. DCNL A list of adequate potential device strings can be obtained with DCNL L{libvlc_audio_output_device_enum}(). DCNL However passing None is supported in LibVLC version 2.2.0 and later only; DCNL in earlier versions, this function would have no effects when the module DCNL parameter was None. DCNL If the module parameter is not None, the device parameter of the DCNL corresponding audio output, if it exists, will be set to the specified DCNL string. Note that some audio output modules do not have such a parameter DCNL (notably MMDevice and PulseAudio). DCNL A list of adequate potential device strings can be obtained with DCNL L{libvlc_audio_output_device_list_get}(). DCNL @note: This function does not select the specified audio output plugin. DCNL L{libvlc_audio_output_set}() is used for that purpose. DCNL @warning: The syntax for the device parameter depends on the audio output. DCNL Some audio output modules require further parameters (e.g. a channels map DCNL in the case of ALSA). DCNL @param mp: media player. DCNL @param module: If None, current audio output module. if non-None, name of audio output module. DCNL @param device_id: device identifier string. DCNL @return: Nothing. Errors are ignored (this is a design bug).'
def libvlc_audio_output_device_get(mp): DCNL 'Get the current audio output device identifier. DCNL This complements L{libvlc_audio_output_device_set}(). DCNL @warning: The initial value for the current audio output device identifier DCNL may not be set or may be some unknown value. A LibVLC application should DCNL compare this value against the known device identifiers (e.g. those that DCNL were previously retrieved by a call to L{libvlc_audio_output_device_enum} or DCNL L{libvlc_audio_output_device_list_get}) to find the current audio output device. DCNL It is possible that the selected audio output device changes (an external DCNL change) without a call to L{libvlc_audio_output_device_set}. That may make this DCNL method unsuitable to use if a LibVLC application is attempting to track DCNL dynamic audio device changes as they happen. DCNL @param mp: media player. DCNL @return: the current audio output device identifier None if no device is selected or in case of error (the result must be released with free() or L{libvlc_free}()). DCNL @version: LibVLC 3.0.0 or later.'
def libvlc_audio_toggle_mute(p_mi): DCNL 'Toggle mute status. DCNL @param p_mi: media player @warning Toggling mute atomically is not always possible: On some platforms, other processes can mute the VLC audio playback stream asynchronously. Thus, there is a small race condition where toggling will not work. See also the limitations of L{libvlc_audio_set_mute}().'
def libvlc_audio_get_mute(p_mi): DCNL 'Get current mute status. DCNL @param p_mi: media player. DCNL @return: the mute status (boolean) if defined, -1 if undefined/unapplicable.'
def libvlc_audio_set_mute(p_mi, status): DCNL 'Set mute status. DCNL @param p_mi: media player. DCNL @param status: If status is true then mute, otherwise unmute @warning This function does not always work. If there are no active audio playback stream, the mute status might not be available. If digital pass-through (S/PDIF, HDMI...) is in use, muting may be unapplicable. Also some audio output plugins do not support muting at all. @note To force silent playback, disable all audio tracks. This is more efficient and reliable than mute.'
def libvlc_audio_get_volume(p_mi): DCNL 'Get current software audio volume. DCNL @param p_mi: media player. DCNL @return: the software volume in percents (0 = mute, 100 = nominal / 0dB).'
def libvlc_audio_set_volume(p_mi, i_volume): DCNL 'Set current software audio volume. DCNL @param p_mi: media player. DCNL @param i_volume: the volume in percents (0 = mute, 100 = 0dB). DCNL @return: 0 if the volume was set, -1 if it was out of range.'
def libvlc_audio_get_track_count(p_mi): DCNL 'Get number of available audio tracks. DCNL @param p_mi: media player. DCNL @return: the number of available audio tracks (int), or -1 if unavailable.'
def libvlc_audio_get_track_description(p_mi): DCNL 'Get the description of available audio tracks. DCNL @param p_mi: media player. DCNL @return: list with description of available audio tracks, or None. It must be freed with L{libvlc_track_description_list_release}().'
def libvlc_audio_get_track(p_mi): DCNL 'Get current audio track. DCNL @param p_mi: media player. DCNL @return: the audio track ID or -1 if no active input.'
def libvlc_audio_set_track(p_mi, i_track): DCNL 'Set current audio track. DCNL @param p_mi: media player. DCNL @param i_track: the track ID (i_id field from track description). DCNL @return: 0 on success, -1 on error.'
def libvlc_audio_get_channel(p_mi): DCNL 'Get current audio channel. DCNL @param p_mi: media player. DCNL @return: the audio channel See libvlc_audio_output_channel_t.'
def libvlc_audio_set_channel(p_mi, channel): DCNL 'Set current audio channel. DCNL @param p_mi: media player. DCNL @param channel: the audio channel, See libvlc_audio_output_channel_t. DCNL @return: 0 on success, -1 on error.'
def libvlc_audio_get_delay(p_mi): DCNL 'Get current audio delay. DCNL @param p_mi: media player. DCNL @return: the audio delay (microseconds). DCNL @version: LibVLC 1.1.1 or later.'
def libvlc_audio_set_delay(p_mi, i_delay): DCNL 'Set current audio delay. The audio delay will be reset to zero each time the media changes. DCNL @param p_mi: media player. DCNL @param i_delay: the audio delay (microseconds). DCNL @return: 0 on success, -1 on error. DCNL @version: LibVLC 1.1.1 or later.'
def libvlc_audio_equalizer_get_preset_count(): DCNL 'Get the number of equalizer presets. DCNL @return: number of presets. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_get_preset_name(u_index): DCNL 'Get the name of a particular equalizer preset. DCNL This name can be used, for example, to prepare a preset label or menu in a user DCNL interface. DCNL @param u_index: index of the preset, counting from zero. DCNL @return: preset name, or None if there is no such preset. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_get_band_count(): DCNL 'Get the number of distinct frequency bands for an equalizer. DCNL @return: number of frequency bands. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_get_band_frequency(u_index): DCNL 'Get a particular equalizer band frequency. DCNL This value can be used, for example, to create a label for an equalizer band control DCNL in a user interface. DCNL @param u_index: index of the band, counting from zero. DCNL @return: equalizer band frequency (Hz), or -1 if there is no such band. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_new(): DCNL 'Create a new default equalizer, with all frequency values zeroed. DCNL The new equalizer can subsequently be applied to a media player by invoking DCNL L{libvlc_media_player_set_equalizer}(). DCNL The returned handle should be freed via L{libvlc_audio_equalizer_release}() when DCNL it is no longer needed. DCNL @return: opaque equalizer handle, or None on error. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_new_from_preset(u_index): DCNL 'Create a new equalizer, with initial frequency values copied from an existing DCNL preset. DCNL The new equalizer can subsequently be applied to a media player by invoking DCNL L{libvlc_media_player_set_equalizer}(). DCNL The returned handle should be freed via L{libvlc_audio_equalizer_release}() when DCNL it is no longer needed. DCNL @param u_index: index of the preset, counting from zero. DCNL @return: opaque equalizer handle, or None on error. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_release(p_equalizer): DCNL 'Release a previously created equalizer instance. DCNL The equalizer was previously created by using L{libvlc_audio_equalizer_new}() or DCNL L{libvlc_audio_equalizer_new_from_preset}(). DCNL It is safe to invoke this method with a None p_equalizer parameter for no effect. DCNL @param p_equalizer: opaque equalizer handle, or None. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_set_preamp(p_equalizer, f_preamp): DCNL 'Set a new pre-amplification value for an equalizer. DCNL The new equalizer settings are subsequently applied to a media player by invoking DCNL L{libvlc_media_player_set_equalizer}(). DCNL The supplied amplification value will be clamped to the -20.0 to +20.0 range. DCNL @param p_equalizer: valid equalizer handle, must not be None. DCNL @param f_preamp: preamp value (-20.0 to 20.0 Hz). DCNL @return: zero on success, -1 on error. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_get_preamp(p_equalizer): DCNL 'Get the current pre-amplification value from an equalizer. DCNL @param p_equalizer: valid equalizer handle, must not be None. DCNL @return: preamp value (Hz). DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_set_amp_at_index(p_equalizer, f_amp, u_band): DCNL 'Set a new amplification value for a particular equalizer frequency band. DCNL The new equalizer settings are subsequently applied to a media player by invoking DCNL L{libvlc_media_player_set_equalizer}(). DCNL The supplied amplification value will be clamped to the -20.0 to +20.0 range. DCNL @param p_equalizer: valid equalizer handle, must not be None. DCNL @param f_amp: amplification value (-20.0 to 20.0 Hz). DCNL @param u_band: index, counting from zero, of the frequency band to set. DCNL @return: zero on success, -1 on error. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_audio_equalizer_get_amp_at_index(p_equalizer, u_band): DCNL 'Get the amplification value for a particular equalizer frequency band. DCNL @param p_equalizer: valid equalizer handle, must not be None. DCNL @param u_band: index, counting from zero, of the frequency band to get. DCNL @return: amplification value (Hz); NaN if there is no such frequency band. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_media_player_set_equalizer(p_mi, p_equalizer): DCNL 'Apply new equalizer settings to a media player. DCNL The equalizer is first created by invoking L{libvlc_audio_equalizer_new}() or DCNL L{libvlc_audio_equalizer_new_from_preset}(). DCNL It is possible to apply new equalizer settings to a media player whether the media DCNL player is currently playing media or not. DCNL Invoking this method will immediately apply the new equalizer settings to the audio DCNL output of the currently playing media if there is any. DCNL If there is no currently playing media, the new equalizer settings will be applied DCNL later if and when new media is played. DCNL Equalizer settings will automatically be applied to subsequently played media. DCNL To disable the equalizer for a media player invoke this method passing None for the DCNL p_equalizer parameter. DCNL The media player does not keep a reference to the supplied equalizer so it is safe DCNL for an application to release the equalizer reference any time after this method DCNL returns. DCNL @param p_mi: opaque media player handle. DCNL @param p_equalizer: opaque equalizer handle, or None to disable the equalizer for this media player. DCNL @return: zero on success, -1 on error. DCNL @version: LibVLC 2.2.0 or later.'
def libvlc_vlm_release(p_instance): DCNL 'Release the vlm instance related to the given L{Instance}. DCNL @param p_instance: the instance.'
def libvlc_vlm_add_broadcast(p_instance, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop): DCNL 'Add a broadcast, with one input. DCNL @param p_instance: the instance. DCNL @param psz_name: the name of the new broadcast. DCNL @param psz_input: the input MRL. DCNL @param psz_output: the output MRL (the parameter to the "sout" variable). DCNL @param i_options: number of additional options. DCNL @param ppsz_options: additional options. DCNL @param b_enabled: boolean for enabling the new broadcast. DCNL @param b_loop: Should this broadcast be played in loop ? DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_add_vod(p_instance, psz_name, psz_input, i_options, ppsz_options, b_enabled, psz_mux): DCNL 'Add a vod, with one input. DCNL @param p_instance: the instance. DCNL @param psz_name: the name of the new vod media. DCNL @param psz_input: the input MRL. DCNL @param i_options: number of additional options. DCNL @param ppsz_options: additional options. DCNL @param b_enabled: boolean for enabling the new vod. DCNL @param psz_mux: the muxer of the vod media. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_del_media(p_instance, psz_name): DCNL 'Delete a media (VOD or broadcast). DCNL @param p_instance: the instance. DCNL @param psz_name: the media to delete. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_set_enabled(p_instance, psz_name, b_enabled): DCNL 'Enable or disable a media (VOD or broadcast). DCNL @param p_instance: the instance. DCNL @param psz_name: the media to work on. DCNL @param b_enabled: the new status. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_set_output(p_instance, psz_name, psz_output): DCNL 'Set the output for a media. DCNL @param p_instance: the instance. DCNL @param psz_name: the media to work on. DCNL @param psz_output: the output MRL (the parameter to the "sout" variable). DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_set_input(p_instance, psz_name, psz_input): DCNL 'Set a media\'s input MRL. This will delete all existing inputs and DCNL add the specified one. DCNL @param p_instance: the instance. DCNL @param psz_name: the media to work on. DCNL @param psz_input: the input MRL. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_add_input(p_instance, psz_name, psz_input): DCNL 'Add a media\'s input MRL. This will add the specified one. DCNL @param p_instance: the instance. DCNL @param psz_name: the media to work on. DCNL @param psz_input: the input MRL. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_set_loop(p_instance, psz_name, b_loop): DCNL 'Set a media\'s loop status. DCNL @param p_instance: the instance. DCNL @param psz_name: the media to work on. DCNL @param b_loop: the new status. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_set_mux(p_instance, psz_name, psz_mux): DCNL 'Set a media\'s vod muxer. DCNL @param p_instance: the instance. DCNL @param psz_name: the media to work on. DCNL @param psz_mux: the new muxer. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_change_media(p_instance, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop): DCNL 'Edit the parameters of a media. This will delete all existing inputs and DCNL add the specified one. DCNL @param p_instance: the instance. DCNL @param psz_name: the name of the new broadcast. DCNL @param psz_input: the input MRL. DCNL @param psz_output: the output MRL (the parameter to the "sout" variable). DCNL @param i_options: number of additional options. DCNL @param ppsz_options: additional options. DCNL @param b_enabled: boolean for enabling the new broadcast. DCNL @param b_loop: Should this broadcast be played in loop ? DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_play_media(p_instance, psz_name): DCNL 'Play the named broadcast. DCNL @param p_instance: the instance. DCNL @param psz_name: the name of the broadcast. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_stop_media(p_instance, psz_name): DCNL 'Stop the named broadcast. DCNL @param p_instance: the instance. DCNL @param psz_name: the name of the broadcast. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_pause_media(p_instance, psz_name): DCNL 'Pause the named broadcast. DCNL @param p_instance: the instance. DCNL @param psz_name: the name of the broadcast. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_seek_media(p_instance, psz_name, f_percentage): DCNL 'Seek in the named broadcast. DCNL @param p_instance: the instance. DCNL @param psz_name: the name of the broadcast. DCNL @param f_percentage: the percentage to seek to. DCNL @return: 0 on success, -1 on error.'
def libvlc_vlm_show_media(p_instance, psz_name): DCNL 'Return information about the named media as a JSON DCNL string representation. DCNL This function is mainly intended for debugging use, DCNL if you want programmatic access to the state of DCNL a vlm_media_instance_t, please use the corresponding DCNL libvlc_vlm_get_media_instance_xxx -functions. DCNL Currently there are no such functions available for DCNL vlm_media_t though. DCNL @param p_instance: the instance. DCNL @param psz_name: the name of the media, if the name is an empty string, all media is described. DCNL @return: string with information about named media, or None on error.'
def libvlc_vlm_get_media_instance_position(p_instance, psz_name, i_instance): DCNL 'Get vlm_media instance position by name or instance id. DCNL @param p_instance: a libvlc instance. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: position as float or -1. on error.'
def libvlc_vlm_get_media_instance_time(p_instance, psz_name, i_instance): DCNL 'Get vlm_media instance time by name or instance id. DCNL @param p_instance: a libvlc instance. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: time as integer or -1 on error.'
def libvlc_vlm_get_media_instance_length(p_instance, psz_name, i_instance): DCNL 'Get vlm_media instance length by name or instance id. DCNL @param p_instance: a libvlc instance. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: length of media item or -1 on error.'
def libvlc_vlm_get_media_instance_rate(p_instance, psz_name, i_instance): DCNL 'Get vlm_media instance playback rate by name or instance id. DCNL @param p_instance: a libvlc instance. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: playback rate or -1 on error.'
def libvlc_vlm_get_media_instance_title(p_instance, psz_name, i_instance): DCNL 'Get vlm_media instance title number by name or instance id. DCNL @param p_instance: a libvlc instance. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: title as number or -1 on error. DCNL @bug: will always return 0.'
def libvlc_vlm_get_media_instance_chapter(p_instance, psz_name, i_instance): DCNL 'Get vlm_media instance chapter number by name or instance id. DCNL @param p_instance: a libvlc instance. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: chapter as number or -1 on error. DCNL @bug: will always return 0.'
def libvlc_vlm_get_media_instance_seekable(p_instance, psz_name, i_instance): DCNL 'Is libvlc instance seekable ? DCNL @param p_instance: a libvlc instance. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: 1 if seekable, 0 if not, -1 if media does not exist. DCNL @bug: will always return 0.'
def libvlc_vlm_get_event_manager(p_instance): DCNL 'Get libvlc_event_manager from a vlm media. DCNL The p_event_manager is immutable, so you don\'t have to hold the lock. DCNL @param p_instance: a libvlc instance. DCNL @return: libvlc_event_manager.'
def callbackmethod(callback): DCNL 'Now obsolete @callbackmethod decorator.'
def _dot2int(v): DCNL '(INTERNAL) Convert \'i.i.i[.i]\' str to int.'
def hex_version(): DCNL 'Return the version of these bindings in hex or 0 if unavailable.'
def libvlc_hex_version(): DCNL 'Return the libvlc version in hex or 0 if unavailable.'
def debug_callback(event, *args, **kwds): DCNL 'Example callback, useful for debugging.'
def start_tribler_core(base_path, child_pipe): DCNL 'This method is invoked by multiprocessing when the Tribler core is started and will start a Tribler session. DCNL Note that there is no direct communication between the GUI process and the core: all communication is performed DCNL through the HTTP API.'
def get_color(name): DCNL 'This method deterministically determines a color of a given name. This is done by taking the MD5 hash of the text.'
def pretty_date(time=False): DCNL 'Get a datetime object or a int() Epoch timestamp and return a DCNL pretty string like \'an hour ago\', \'Yesterday\', \'3 months ago\', DCNL \'just now\', etc'
def get_base_path(): DCNL 'Get absolute path to resource, works for dev and for PyInstaller'
def is_frozen(): DCNL 'Return whether we are running in a frozen environment'
def bisect_right(item, item_list, is_torrent): DCNL 'This method inserts a channel/torrent in a sorted list. The sorting is based on relevance score. DCNL The implementation is based on bisect_right.'
def get_gui_setting(gui_settings, value, default, is_bool=False): DCNL 'Utility method to get a specific GUI setting. The is_bool flag defines whether we expect a boolean so we convert it DCNL since on Windows, all values are saved as plain text.'
def checkHandleAndSynchronize(default=None): DCNL 'Return the libtorrent handle if it\'s available, else return the default value.'
def convert_config_to_tribler71(): DCNL 'Convert the Config files libtribler.conf and tribler.conf to the newer triblerd.conf. DCNL :param: session: the Config which can be used to convert the old files to the new format DCNL :return: the newly edited Config file with the old Config data inserted.'
def add_tribler_config(new_config, old_config): DCNL 'Add the old values of the tribler.conf file to the newer Config file. DCNL :param new_config: The Config file to which the old data can be written DCNL :param old_config: A RawConfigParser containing the old tribler.conf Config file DCNL :return: the edited Config file'
def add_libtribler_config(new_config, old_config): DCNL 'Add the old values of the libtribler.conf file to the newer Config file. DCNL :param new_config: the Config file to which the old data can be written DCNL :param old_config: a RawConfigParser containing the old libtribler.conf Config file DCNL :return: the edited Config file'
def validate_source_string(source): DCNL 'Function to check whether a source string is a valid source or not'
def levenshtein_dist(t1_fname, t2_fname): DCNL 'Calculates the Levenshtein distance between a and b. DCNL Levenshtein distance (LD) is a measure of the similarity between two strings. DCNL (from http://people.cs.pitt.edu/~kirk/cs1501/Pruhs/Fall2006/Assignments/editdistance/Levenshtein%20Distance.htm)'
def compare_torrents(torrent_1, torrent_2): DCNL 'comparing swarms. We don\'t want to download the same swarm with different infohash DCNL :return: whether those t1 and t2 similar enough'
def ent2chr(input_str): DCNL 'Function to unescape literal string in XML to symbols DCNL source : http://www.gossamer-threads.com/lists/python/python/177423'
def make_torrent_file(input, userabortflag=None, userprogresscallback=(lambda x: None)): DCNL 'Create a torrent file from the supplied input. DCNL Returns a (infohash,metainfo) pair, or (None,None) on userabort.'
def uniconvertl(l, e): DCNL 'Convert a pathlist to a list of strings encoded in encoding "e" using DCNL uniconvert.'
def uniconvert(s, enc): DCNL 'Convert \'s\' to a string containing a Unicode sequence encoded using DCNL encoding "enc". If \'s\' is not a Unicode object, we first try to convert DCNL it to one, guessing the encoding if necessary.'
def makeinfo(input, userabortflag, userprogresscallback): DCNL 'Calculate hashes and create torrent file\'s \'info\' part'
def subfiles(d): DCNL 'Return list of (pathlist,local filename) tuples for all the files in DCNL directory \'d\''
def filename2pathlist(path, skipfirst=False): DCNL 'Convert a filename to a \'path\' entry suitable for a multi-file torrent DCNL file'
def pathlist2filename(pathlist): DCNL 'Convert a multi-file torrent file \'path\' entry to a filename.'
def get_uniformed_tracker_url(tracker_url): DCNL 'Parse a tracker url of basestring type. DCNL The following checks and transformations are applied to the url: DCNL - Check if the url is valid unicode data DCNL - Strip whitespaces DCNL - Strip a trailing \'/\' DCNL - Check that the port is DCNL - provided in case of UDP DCNL - in range in case of HTTP (implicitly done in the `urlparse` function) DCNL - If it is a url for a HTTP tracker, don\'t include the default port HTTP_PORT DCNL Examples: DCNL udp://tracker.openbittorrent.com:80 DCNL http://tracker.openbittorrent.com:80/announce DCNL :param tracker_url: a basestring url for either a UDP or HTTP tracker DCNL :return: the tracker in a uniform format <type>://<host>:<port>/<page>'
def parse_tracker_url(tracker_url): DCNL 'Parse the tracker url and check whether it satisfies certain constraints: DCNL - The tracker type must be either http or udp DCNL - HTTP trackers need a path DCNL - UDP trackers need a port DCNL Note that HTTP trackers default to HTTP_PORT if none is given. DCNL :param tracker_url the url of the tracker DCNL :returns: a tuple of size 3 containing the scheme, a tuple of hostname and port, DCNL and path of the url'
def is_frozen(): DCNL 'Return whether we are running in a frozen environment'
def get_base_path(): DCNL 'Get absolute path to resource, works for dev and for PyInstaller'
def get_random_port(socket_type='all', min_port=5000, max_port=60000): DCNL 'Gets a random port number that works. DCNL @param socket_type: Type of the socket, can be "all", "tcp", or "udp". DCNL @param min_port: The minimal port number to try with. DCNL @param max_port: The maximal port number to try with. DCNL @return: A working port number if exists, otherwise None.'
def check_random_port(port, socket_type='all'): DCNL 'Returns an usable port number that can be bound with by the specific type of socket. DCNL @param socket_type: Type of the socket, can be "all", "tcp", or "udp". DCNL @param port: The port to try with. DCNL @return: True or False indicating if port is available.'
def _test_port(family, sock_type, port): DCNL 'Tests if a port is available. DCNL @param family: The socket family, must be socket.AF_INET. DCNL @param sock_type: The socket type, can be socket.SOCK_DGRAM or socket.SOCK_STREAM. DCNL @param port: The port number to test with. DCNL @return: True if the port is available or there is no problem with the socket, otherwise False.'
def split_into_keywords(string, to_filter_stopwords=False): DCNL 'Takes a (unicode) string and returns a list of (unicode) lowercase DCNL strings.  No empty strings are returned. DCNL We currently split on non-alphanumeric characters and the DCNL underscore. DCNL If to_filter_stopwords is True a small stopword filter is using to reduce the number of keywords'
def _a_encode_int(value, mapping): DCNL '42 --> (\'2\', \'i\', \'42\')'
def _a_encode_long(value, mapping): DCNL '42 --> (\'2\', \'J\', \'42\')'
def _a_encode_float(value, mapping): DCNL '4.2 --> (\'3\', \'f\', \'4.2\')'
def _a_encode_unicode(value, mapping): DCNL '\'foo-bar\' --> (\'7\', \'s\', \'foo-bar\')'
def _a_encode_bytes(value, mapping): DCNL '\'foo-bar\' --> (\'7\', \'b\', \'foo-bar\')'
def _a_encode_list(values, mapping): DCNL '[1,2,3] --> [\'3\', \'l\', \'1\', \'i\', \'1\', \'1\', \'i\', \'2\', \'1\', \'i\', \'3\']'
def _a_encode_set(values, mapping): DCNL '[1,2,3] --> [\'3\', \'l\', \'1\', \'i\', \'1\', \'1\', \'i\', \'2\', \'1\', \'i\', \'3\']'
def _a_encode_tuple(values, mapping): DCNL '(1,2) --> [\'2\', \'t\', \'1\', \'i\', \'1\', \'1\', \'i\', \'2\']'
def _a_encode_dictionary(values, mapping): DCNL '{\'foo\':\'bar\', \'moo\':\'milk\'} --> [\'2\', \'d\', \'3\', \'s\', \'foo\', \'3\', \'s\', \'bar\', \'3\', \'s\', \'moo\', \'4\', \'s\', \'milk\']'
def _a_encode_none(value, mapping): DCNL 'None --> [\'0\', \'n\']'
def _a_encode_bool(value, mapping): DCNL 'True  --> [\'0\', \'T\'] DCNL False --> [\'0\', \'F\']'
def encode(data, version='a'): DCNL 'Encode DATA into version \'a\' binary stream. DCNL DATA can be any: int, float, string, unicode, list, tuple, or DCNL dictionary. DCNL Lists are considered to be tuples.  I.e. when decoding an DCNL encoded list it will come out as a tuple. DCNL The encoding process is done using version \'a\' which is DCNL indicated by the first byte of the resulting binary stream.'
def _a_decode_int(stream, offset, count, _): DCNL '\'a2i42\',3,2 --> 5,42'
def _a_decode_long(stream, offset, count, _): DCNL '\'a2J42\',3,2 --> 5,42'
def _a_decode_float(stream, offset, count, _): DCNL '\'a3f4.2\',3,3 --> 6,4.2'
def _a_decode_unicode(stream, offset, count, _): DCNL '\'a3sbar\',3,3 --> 6,u\'bar\''
def _a_decode_bytes(stream, offset, count, _): DCNL '\'a3bfoo\',3,3 --> 6,\'foo\''
def _a_decode_list(stream, offset, count, mapping): DCNL '\'a1l3i123\',3,1 --> 8,[123] DCNL \'a2l1i41i2\',3,1 --> 8,[4,2]'
def _a_decode_set(stream, offset, count, mapping): DCNL '\'a1L3i123\',3,1 --> 8,set(123) DCNL \'a2L1i41i2\',3,1 --> 8,set(4,2)'
def _a_decode_tuple(stream, offset, count, mapping): DCNL '\'a1t3i123\',3,1 --> 8,[123] DCNL \'a2t1i41i2\',3,1 --> 8,[4,2]'
def _a_decode_dictionary(stream, offset, count, mapping): DCNL '\'a2d3sfoo3sbar3smoo4smilk\',3,2 -> 24,{\'foo\':\'bar\', \'moo\':\'milk\'}'
def _a_decode_none(stream, offset, count, mapping): DCNL '\'a0n\',3,0 -> 3,None'
def _a_decode_true(stream, offset, count, mapping): DCNL '\'a0T\',3,1 -> 3,True'
def _a_decode_false(stream, offset, count, mapping): DCNL '\'a0F\',3,1 -> 3,False'
def decode(stream, offset=0): DCNL 'Decode STREAM from index OFFSET and further into a python data DCNL structure. DCNL Returns the new OFFSET of the stream and the decoded data. DCNL Only version \'a\' decoding is supported.  This version is DCNL indicated by the first byte in the binary STREAM.'
def add_url_params(url, params): DCNL 'Add GET params to provided URL being aware of existing. DCNL :param url: string of target URL DCNL :param params: dict containing requested params to be added DCNL :return: string with updated URL DCNL >> url = \'http://stackoverflow.com/test?answers=true\' DCNL >> new_params = {\'answers\': False, \'data\': [\'some\',\'values\']} DCNL >> add_url_params(url, new_params) DCNL \'http://stackoverflow.com/test?data=some&data=values&answers=false\''
def patch_crypto_be_discovery(): DCNL 'Monkey patches cryptography\'s backend detection. DCNL Objective: support pyinstaller freezing.'
def validate_torrent_nodes(metainfo): DCNL 'Validate the list of nodes in the metainfo if such list exists. DCNL First it is checked whether metainfo contains a list of nodes. DCNL After this, for each node in the list, the following is checked: DCNL - Whether the node is a pair of length two DCNL - Whether the first element is of type String DCNL - Whether the second element is a tuple consisting of an Int and a Long DCNL :param metainfo: the metainfo for which the nodes have to be validated DCNL :return: Returns the nodes of the metainfo or None if they don\'t exist DCNL :raise ValueError: if one of the described checks do not succeed'
def validate_init_peers(metainfo): DCNL 'Validate the list of initial peers in the metainfo if such list exists. DCNL First it is checked whether metainfo contains a list of nodes. DCNL After this, for each initial peer in the list, the following is checked: DCNL - Whether the peer is a tuple of two elements DCNL - Whether the address host is a String DCNL - Whether the address port is an Integer DCNL If there is a peer which does not pass the above tests, the peer is removed from the list. DCNL :param metainfo: the metainfo for which the nodes have to be validated DCNL :return: a list containing the valid initial peers or None if no list exists in the first place DCNL :raise ValueError: if the initial peers element of metainfo is not a list or when either of the above DCNL checks are not passed'
def validate_url_list(metainfo): DCNL 'Validate the list of URLs in the metainfo if such list exists and remove wrong URLs. DCNL First check whether a URL-list exists, after which it is checked whether the metainfo DCNL would be able to use HTTP seeding. This is not the case if there are multiple files specified. DCNL A warning is logged if: DCNL -   There are multiple files specified (HTTP seeding will be disabled) DCNL -   The URL list is not a list nor a String DCNL -   There is an invalid URL DCNL Each URL is validated seperately. DCNL :param metainfo: the metainfo for which the URLs have to be validated DCNL :return: a list containing the valid URLs or None if there is a thrown warning, for the cases specified above.'
def validate_http_seeds(metainfo): DCNL 'Validate the list of HTTP Seeds in the metainfo if such list exists. DCNL First checks whether a HTTP Seed list exists. DCNL None will be returned, as well as a warning is logged if: DCNL -   The HTTP seeds is not of the type list DCNL -   One of the HTTP seeds is not a valid URL DCNL Each HTTP seed is validated seperately. DCNL :param metainfo: the metainfo for which the HTTP seeds have to be validated DCNL :return: a list containing the valid HTTP seeds or None if there is a logged warning, for the cases specified above'
def validate_files(info): DCNL 'Validate the information on files from the torrent info within the metainfo. DCNL The following information is validated: DCNL -   Whether there is both a length and files key DCNL -   Whether the length value is an integer if one exists DCNL -   Whether the files value is a List if one exists DCNL For each file (when specified) is validated: DCNL -   Whether the file has both a path and length key DCNL -   Whether the path value is of type List DCNL -   Whether all specified paths are of type String DCNL -   Whether the length value is of type Long or Integer DCNL :param info: The torrent information taken from metainfo from which the file info has to be checked. DCNL :return: None DCNL :raise ValueError: if one of the above validations do not succeed'
def validate_torrent_info(metainfo): DCNL 'Validate the info in the metainfo if it exists. DCNL The following information is validated: DCNL -   Whether an info key exists within metainfo DCNL -   Whether necessary keys exist within information (name, piece length and either root hash or pieces) DCNL -   Whether the name value is of type String DCNL -   Whether the piece length value is of type Long or Integer DCNL -   Whether the root hash is an instance of String qnd has a length of 20 if it exists DCNL -   Whether the pieces value is an instance of String and it has a length of multiple of 20 DCNL :param metainfo: the metainfo for which the information has to be validated DCNL :return: info if all validations succeed DCNL :raise ValueError: if one of the above validations do not succeed'
def create_valid_metainfo(metainfo): DCNL 'Creates a valid metainfo dictionary by validating the elements and correcting when possible. DCNL :param metainfo: the metainfo that has to be validated DCNL :return: the original metainfo with corrected elements if possible DCNL :raise ValueError: if there is a faulty element which cannot be corrected.'
def valid_torrent_file(metainfo): DCNL 'Checks whether the given metainfo is valid. DCNL :param metainfo: the metainfo to be validated DCNL :return: Boolean specifying whether the specified metainfo is valid or not'
def is_valid_url(url): DCNL 'Checks whether the given URL is a valid URL. DCNL Both UDP and HTTP URLs will be validated correctly. DCNL :param url: an object representing the URL DCNL :return: Boolean specifying whether the URL is valid'
def http_get(uri): DCNL 'Performs a GET request DCNL :param uri: The URL to perform a GET request to DCNL :return: A deferred firing the body of the response. DCNL :raises HttpError: When the HTTP response code is not OK (i.e. not the HTTP Code 200)'
def parse_magnetlink(url): DCNL 'Parses the magnet link provided by the given URL. DCNL The output of this file consists of: DCNL -   dn: The display name of the magnet link DCNL -   xt: The URI containing the file hash of the magnet link DCNL -   trs: The list of Tracker URLs DCNL :param url: the URL at which the magnet link can be found DCNL :return: (dn, xt, trs) tuple, which will be left (None, None, []) if the DCNL given URL does not lead to a magnet link'
def fix_torrent(file_path): DCNL 'Reads and checks if a torrent file is valid and tries to overwrite the torrent file with a non-sloppy version. DCNL :param file_path: The torrent file path DCNL :return: True if the torrent file is now overwritten with valid information, otherwise False'
def translate_peers_into_health(peer_info_dicts): DCNL 'peer_info_dicts is a peer_info dictionary from LibTorrentDownloadImpl.create_peerlist_data. DCNL purpose : where we want to measure a swarm\'s health but no tracker can be contacted'
def warnIfDispersyThread(func): DCNL 'We\'d rather not be on the Dispersy thread, but if we are lets continue and DCNL hope for the best. This was introduced after the database thread stuffs DCNL caused deadlocks. We weren\'t sure we got all of them, so we implemented DCNL warnings instead of errors because they probably wouldn\'t cause a deadlock, DCNL but if they did we would have the warning somewhere. DCNL Niels dixit.'
def return_handled_exception(request, exception): DCNL ':param request: the request that encountered the exception DCNL :param exception: the handled exception DCNL :return: JSON dictionary describing the exception'
def convert_search_torrent_to_json(torrent): DCNL 'Converts a given torrent to a JSON dictionary. Note that the torrent might be either a result from the local DCNL database in which case it is a tuple or a remote search result in which case it is a dictionary.'
def convert_db_channel_to_json(channel, include_rel_score=False): DCNL 'This method converts a channel in the database to a JSON dictionary.'
@blocking_call_on_reactor_thread DCNL def can_edit_channel(channel_id, channel_vote): DCNL 'This method returns whether the channel can be edited or not.'
def convert_db_torrent_to_json(torrent, include_rel_score=False): DCNL 'This method converts a torrent in the database to a JSON dictionary.'
def convert_remote_torrent_to_json(torrent): DCNL 'This method converts a torrent that has been received by remote peers in the network to a JSON dictionary.'
def get_parameter(parameters, name): DCNL 'Return a specific parameter with a name from a HTTP request (or None if that parameter is not available).'
def relevance_score_remote_torrent(torrent_name): DCNL 'Calculate the relevance score of a remote torrent, based on the name and the matchinfo object DCNL of the last torrent from the database. DCNL The algorithm used is the same one as in search_in_local_torrents_db in SqliteCacheDBHandler.py.'
def fix_unicode_dict(d): DCNL 'This method removes illegal (unicode) characters recursively from a dictionary. DCNL This is required since Dispersy members might add invalid characters to their strings and we are unable to utf8 DCNL encode these when sending the data over the API.'
def fix_unicode_array(arr): DCNL 'Iterate over the items of the array and remove invalid unicode characters.'
def create_tracker_session(tracker_url, timeout): DCNL 'Creates a tracker session with the given tracker URL. DCNL :param tracker_url: The given tracker URL. DCNL :param timeout: The timeout for the session. DCNL :return: The tracker session.'
def is_android(): DCNL 'This functions checks whether Tribler is running on Android or not, DCNL using the system platform name and OS environment variable ANDROID_PRIVATE DCNL :return: boolean True if running on Android. False otherwise.'
def fix_filebasename(name, unit=False, maxlen=255): DCNL 'Check if str is a valid Windows file name (or unit name if unit is true) DCNL * If the filename isn\'t valid: returns a corrected name DCNL * If the filename is valid: returns the filename'
def _get_string(buff, start_idx): DCNL 'Gets a zero-terminated string from a given buffer. DCNL :param buff: The buffer. DCNL :param start_idx: The index to start from. DCNL :return: A (str, idx) tuple that has the zero-terminated string and the next index.'
def _decode_options(packet, buff, start_idx): DCNL 'Decodes options from a given packet buffer. DCNL :param packet: The packet dictionary to use. DCNL :param buff: The packet buffer. DCNL :param start_idx: The index to start from. DCNL :return: None'
def _decode_rrq_wrq(packet, packet_buff, offset): DCNL 'Decodes a RRQ/WRQ packet. DCNL :param packet: The packet dictionary. DCNL :param packet_buff: The packet buffer. DCNL :return: The decoded packet as a dictionary.'
def _decode_data(packet, packet_buff, offset): DCNL 'Decodes a DATA packet. DCNL :param packet: The packet dictionary. DCNL :param packet_buff: The packet buffer. DCNL :return: The decoded packet as a dictionary.'
def _decode_ack(packet, packet_buff, offset): DCNL 'Decodes a ACK packet. DCNL :param packet: The packet dictionary. DCNL :param packet_buff: The packet buffer. DCNL :return: The decoded packet as a dictionary.'
def _decode_error(packet, packet_buff, offset): DCNL 'Decodes a ERROR packet. DCNL :param packet: The packet dictionary. DCNL :param packet_buff: The packet buffer. DCNL :return: The decoded packet as a dictionary.'
def _decode_oack(packet, packet_buff, offset): DCNL 'Decodes a OACK packet. DCNL :param packet: The packet dictionary. DCNL :param packet_buff: The packet buffer. DCNL :return: The decoded packet as a dictionary.'
def decode_packet(packet_buff): DCNL 'Decodes a packet binary string into a packet dictionary. DCNL :param packet_buff: The packet binary string. DCNL :return: The decoded packet dictionary.'
def encode_packet(packet): DCNL 'Encodes a packet dictionary into a binary string. DCNL :param packet: The packet dictionary. DCNL :return: The encoded packet buffer.'
def get_default_dest_dir(): DCNL 'Returns the default dir to save content to. DCNL If Downloads/ exists: Downloads/TriblerDownloads DCNL else: Home/TriblerDownloads'
def decode_methods_request(offset, data): DCNL 'Try to decodes a METHOD request DCNL @param int offset: the offset to start in the data DCNL @param str data: the serialised data to decode from DCNL @return: Tuple (offset, None) on failure, else (new_offset, MethodRequest) DCNL @rtype: (int, None|MethodRequest)'
def encode_method_selection_message(version, method): DCNL 'Serialise a Method Selection message DCNL @param version: the SOCKS5 version DCNL @param method: the authentication method to select DCNL @return: the serialised format DCNL @rtype: str'
def decode_request(orig_offset, data): DCNL 'Try to decode a SOCKS5 request DCNL @param int orig_offset: the offset to start decoding in the data DCNL @param str data: the raw data DCNL @return: tuple (new_offset, Request) or (original_offset, None) on failure DCNL @rtype: (int, Request|None)'
def encode_reply(version, rep, rsv, address_type, bind_address, bind_port): DCNL 'Encode a REPLY DCNL @param int version: SOCKS5 version DCNL @param int rep: the response DCNL @param int rsv: reserved bytes DCNL @param address_type: the address type of the bind address DCNL @param bind_address: the bind address host DCNL @param bind_port: the bind address port DCNL @return:'
def decode_udp_packet(data): DCNL 'Decodes a SOCKS5 UDP packet DCNL @param str data: the raw packet data DCNL @return: An UdpRequest object containing the parsed data DCNL @rtype: UdpRequest'
def encode_udp_packet(rsv, frag, address_type, address, port, payload): DCNL 'Encodes a SOCKS5 UDP packet DCNL @param rsv: reserved bytes DCNL @param frag: fragment DCNL @param address_type: the address\'s type DCNL @param address: address host DCNL @param port: address port DCNL @param payload: the original UDP payload DCNL @return: serialised byte string DCNL @rtype: str'
def prepare_xml_rss(target_path, filename): DCNL 'Function to prepare test_rss.xml file, replace the port with a random one'
def make_decorator(func): DCNL 'Wraps a test decorator so as to properly replicate metadata DCNL of the decorated function, including nose\'s additional stuff DCNL (namely, setup and teardown).'
def threaded_reactor(): DCNL 'Start the Twisted reactor in a separate thread, if not already done. DCNL Returns the reactor.'
def stop_reactor(): DCNL 'Stop the reactor and join the reactor thread until it stops.'
def deferred(timeout=None): DCNL 'By wrapping a test function with this decorator, you can return a DCNL twisted Deferred and the test will wait for the deferred to be triggered. DCNL The whole test function will run inside the Twisted event loop. DCNL The optional timeout parameter specifies the maximum duration of the test. DCNL The difference with timed() is that timed() will still wait for the test DCNL to end, while deferred() will stop the test when its timeout has expired. DCNL The latter is more desireable when dealing with network tests, because DCNL the result may actually never arrive. DCNL If the callback is triggered, the test has passed. DCNL If the errback is triggered or the timeout expires, the test has failed. DCNL Example:: DCNL @deferred(timeout=5.0) DCNL def test_resolve(): DCNL return reactor.resolve("www.python.org") DCNL Attention! If you combine this decorator with other decorators (like DCNL "raises"), deferred() must be called *first*! DCNL In other words, this is good:: DCNL @raises(DNSLookupError) DCNL @deferred() DCNL def test_error(): DCNL return reactor.resolve("xxxjhjhj.biz") DCNL and this is bad:: DCNL @deferred() DCNL @raises(DNSLookupError) DCNL def test_error(): DCNL return reactor.resolve("xxxjhjhj.biz")'
def log_query(func): DCNL 'A decorator for pseudo-logging search queries. Used in the ``SearchBackend`` DCNL to wrap the ``search`` method.'
@register.tag DCNL def more_like_this(parser, token): DCNL 'Fetches similar items from the search index to find content that is similar DCNL to the provided model\'s content. DCNL Syntax:: DCNL {% more_like_this model_instance as varname [for app_label.model_name,app_label.model_name,...] [limit n] %} DCNL Example:: DCNL # Pull a full SearchQuerySet (lazy loaded) of similar content. DCNL {% more_like_this entry as related_content %} DCNL # Pull just the top 5 similar pieces of content. DCNL {% more_like_this entry as related_content limit 5  %} DCNL # Pull just the top 5 similar entries or comments. DCNL {% more_like_this entry as related_content for "blog.entry,comments.comment" limit 5  %}'
@register.tag DCNL def highlight(parser, token): DCNL 'Takes a block of text and highlights words from a provided query within that DCNL block of text. Optionally accepts arguments to provide the HTML tag to wrap DCNL highlighted word in, a CSS class to use with the tag and a maximum length of DCNL the blurb in characters. DCNL Syntax:: DCNL {% highlight <text_block> with <query> [css_class "class_name"] [html_tag "span"] [max_length 200] %} DCNL Example:: DCNL # Highlight summary with default behavior. DCNL {% highlight result.summary with request.query %} DCNL # Highlight summary but wrap highlighted words with a div and the DCNL # following CSS class. DCNL {% highlight result.summary with request.query html_tag "div" css_class "highlight_me_please" %} DCNL # Highlight summary but only show 40 characters. DCNL {% highlight result.summary with request.query max_length 40 %}'
def index_field_from_django_field(f, default=CharField): DCNL 'Returns the Haystack field type that would likely be associated with each DCNL Django type.'
def list_max_show_all(changelist): DCNL 'Returns the maximum amount of results a changelist can have for the DCNL "Show all" link to be displayed in a manner compatible with both Django DCNL 1.4 and 1.3. See Django ticket #15997 for details.'
def basic_search(request, template=u'search/search.html', load_all=True, form_class=ModelSearchForm, searchqueryset=None, extra_context=None, results_per_page=None): DCNL 'A more traditional view that also demonstrate an alternative DCNL way to use Haystack. DCNL Useful as an example of for basing heavily custom views off of. DCNL Also has the benefit of thread-safety, which the ``SearchView`` class may DCNL not be. DCNL Template:: ``search/search.html`` DCNL Context:: DCNL * form DCNL An instance of the ``form_class``. (default: ``ModelSearchForm``) DCNL * page DCNL The current page of search results. DCNL * paginator DCNL A paginator instance for the results. DCNL * query DCNL The query received by the form.'
def default_get_identifier(obj_or_string): DCNL 'Get an unique identifier for the object or a string representing the DCNL object. DCNL If not overridden, uses <app_label>.<object_name>.<pk>.'
def _lookup_identifier_method(): DCNL 'If the user has set HAYSTACK_IDENTIFIER_METHOD, import it and return the method uncalled. DCNL If HAYSTACK_IDENTIFIER_METHOD is not defined, return haystack.utils.default_get_identifier. DCNL This always runs at module import time.  We keep the code in a function DCNL so that it can be called from unit tests, in order to simulate the re-loading DCNL of this module.'
def ensure_geometry(geom): DCNL 'Makes sure the parameter passed in looks like a GEOS ``GEOSGeometry``.'
def ensure_point(geom): DCNL 'Makes sure the parameter passed in looks like a GEOS ``Point``.'
def ensure_wgs84(point): DCNL 'Ensures the point passed in is a GEOS ``Point`` & returns that point\'s DCNL data is in the WGS-84 spatial reference.'
def ensure_distance(dist): DCNL 'Makes sure the parameter passed in is a \'Distance\' object.'
def generate_bounding_box(bottom_left, top_right): DCNL 'Takes two opposite corners of a bounding box (order matters!) & generates DCNL a two-tuple of the correct coordinates for the bounding box. DCNL The two-tuple is in the form ``((min_lat, min_lng), (max_lat, max_lng))``.'
def haystack_get_app_modules(): DCNL 'Return the Python module for each installed app'
def haystack_load_apps(): DCNL 'Return a list of app labels for all installed applications which have models'
def load_backend(full_backend_path): DCNL 'Loads a backend for interacting with the search engine. DCNL Requires a ``backend_path``. It should be a string resembling a Python DCNL import path, pointing to a ``BaseEngine`` subclass. The built-in options DCNL available include:: DCNL * haystack.backends.solr.SolrEngine DCNL * haystack.backends.xapian.XapianEngine (third-party) DCNL * haystack.backends.whoosh.WhooshEngine DCNL * haystack.backends.simple.SimpleEngine DCNL If you\'ve implemented a custom backend, you can provide the path to DCNL your backend & matching ``Engine`` class. For example:: DCNL ``myapp.search_backends.CustomSolrEngine``'
def load_router(full_router_path): DCNL 'Loads a router for choosing which connection to use. DCNL Requires a ``full_router_path``. It should be a string resembling a Python DCNL import path, pointing to a ``BaseRouter`` subclass. The built-in options DCNL available include:: DCNL * haystack.routers.DefaultRouter DCNL If you\'ve implemented a custom backend, you can provide the path to DCNL your backend & matching ``Engine`` class. For example:: DCNL ``myapp.search_routers.MasterSlaveRouter``'
def get_identifier_method(key): DCNL 'Custom get_identifier method used for testing the DCNL setting HAYSTACK_IDENTIFIER_MODULE'
def generate_app_name(): DCNL 'Return a randomly-generated memorable name.'
def dict_diff(dict1, dict2): DCNL 'Returns the added, changed, and deleted items in dict1 compared with dict2. DCNL :param dict1: a python dict DCNL :param dict2: an earlier version of the same python dict DCNL :return: a new dict, with \'added\', \'changed\', and \'removed\' items if DCNL any were found. DCNL >>> d1 = {1: \'a\'} DCNL >>> dict_diff(d1, d1) DCNL >>> d2 = {1: \'a\', 2: \'b\'} DCNL >>> dict_diff(d2, d1) DCNL {\'added\': {2: \'b\'}} DCNL >>> d3 = {2: \'B\', 3: \'c\'} DCNL >>> expected = {\'added\': {3: \'c\'}, \'changed\': {2: \'B\'}, \'deleted\': {1: \'a\'}} DCNL >>> dict_diff(d3, d2) == expected DCNL True'
def fingerprint(key): DCNL 'Return the fingerprint for an SSH Public Key'
def encode(obj): DCNL 'Return UTF-8 encoding for string objects.'
def construct_patch(self, path, data=u'', content_type=u'application/octet-stream', **extra): DCNL 'Construct a PATCH request.'
def send_patch(self, path, data=u'', content_type=u'application/octet-stream', follow=False, **extra): DCNL 'Send a resource to the server using PATCH.'
def close_db_connections(func, *args, **kwargs): DCNL 'Decorator to explicitly close db connections during threaded execution DCNL Note this is necessary to work around: DCNL https://code.djangoproject.com/ticket/22420'
def validate_base64(value): DCNL 'Check that value contains only valid base64 characters.'
def validate_id_is_docker_compatible(value): DCNL 'Check that the ID follows docker\'s image name constraints'
def validate_app_structure(value): DCNL 'Error if the dict values aren\'t ints >= 0.'
def validate_reserved_names(value): DCNL 'A value cannot use some reserved names.'
def validate_comma_separated(value): DCNL 'Error if the value doesn\'t look like a list of hostnames or IP addresses DCNL separated by commas.'
def validate_domain(value): DCNL 'Error if the domain contains unexpected characters.'
def select_app_name(): DCNL 'Select a unique randomly generated app name'
def check_blacklist(repo): DCNL 'Check a Docker repository name for collision with deis/* components.'
def log_output(stream): DCNL 'Log a stream at DEBUG level, and raise DockerException if it contains "error".'
def strip_prefix(name): DCNL 'Strip the schema and host:port from a Docker repository name.'
@login_required DCNL def account(request): DCNL 'Return the user\'s account web page.'
@login_required DCNL def dashboard(request): DCNL 'Return the user\'s dashboard web page.'
@login_required DCNL def apps(request): DCNL 'Return the user\'s apps web page.'
@login_required DCNL def support(request): DCNL 'Return the support ticket system home page.'
def normalize(a, axis=None): DCNL 'Normalizes the input array so that it sums to 1. DCNL Parameters DCNL a : array DCNL Non-normalized input data. DCNL axis : int DCNL Dimension along which normalization is performed. DCNL Notes DCNL Modifies the input **inplace**.'
def log_normalize(a, axis=None): DCNL 'Normalizes the input array so that the exponent of the sum is 1. DCNL Parameters DCNL a : array DCNL Non-normalized input data. DCNL axis : int DCNL Dimension along which normalization is performed. DCNL Notes DCNL Modifies the input **inplace**.'
def log_mask_zero(a): DCNL 'Computes the log of input probabilities masking divide by zero in log. DCNL Notes DCNL During the M-step of EM-algorithm, very small intermediate start DCNL or transition probabilities could be normalized to zero, causing a DCNL *RuntimeWarning: divide by zero encountered in log*. DCNL This function masks this unharmful warning.'
def log_multivariate_normal_density(X, means, covars, covariance_type='diag'): DCNL 'Compute the log probability under a multivariate Gaussian distribution. DCNL Parameters DCNL X : array_like, shape (n_samples, n_features) DCNL List of n_features-dimensional data points. Each row corresponds to a DCNL single data point. DCNL means : array_like, shape (n_components, n_features) DCNL List of n_features-dimensional mean vectors for n_components Gaussians. DCNL Each row corresponds to a single mean vector. DCNL covars : array_like DCNL List of n_components covariance parameters for each Gaussian. The shape DCNL depends on `covariance_type`: DCNL (n_components, n_features)      if \'spherical\', DCNL (n_features, n_features)    if \'tied\', DCNL (n_components, n_features)    if \'diag\', DCNL (n_components, n_features, n_features) if \'full\' DCNL covariance_type : string DCNL Type of the covariance parameters.  Must be one of DCNL \'spherical\', \'tied\', \'diag\', \'full\'.  Defaults to \'diag\'. DCNL Returns DCNL lpr : array_like, shape (n_samples, n_components) DCNL Array containing the log probabilities of each data point in DCNL X under each of the n_components multivariate Gaussian distributions.'
def _log_multivariate_normal_density_diag(X, means, covars): DCNL 'Compute Gaussian log-density at X for a diagonal model.'
def _log_multivariate_normal_density_spherical(X, means, covars): DCNL 'Compute Gaussian log-density at X for a spherical model.'
def _log_multivariate_normal_density_tied(X, means, covars): DCNL 'Compute Gaussian log-density at X for a tied model.'
def _log_multivariate_normal_density_full(X, means, covars, min_covar=1e-07): DCNL 'Log probability for full covariance matrices.'
def find_in_path(fname, path=None): DCNL 'Find file fname in paths. Return None if not found.'
def substitutetype(ty): DCNL 'fix types to match the standard format in the final docs, DCNL removes std:: and adds a leading and trailing space between DCNL triangular brackets'
def parse_docs(element): DCNL 'parse an inlined documentation block'
def get_tu(source, lang='c', all_warnings=False, flags=[]): DCNL 'Obtain a translation unit from source and language. DCNL By default, the translation unit is created from source file "t.<ext>" DCNL where <ext> is the default file extension for the specified language. By DCNL default it is C, so "t.c" is the default file name. DCNL Supported languages are {c, cpp, objc}. DCNL all_warnings is a convenience argument to enable all compiler warnings.'
def get_cursor(source, spelling): DCNL 'Obtain a cursor from a source object. DCNL This provides a convenient search mechanism to find a cursor with specific DCNL spelling within a source. The first argument can be either a DCNL TranslationUnit or Cursor instance. DCNL If the cursor is not found, None is returned.'
def get_cursors(source, spelling): DCNL 'Obtain all cursors from a source object with a specific spelling. DCNL This provides a convenient search mechanism to find all cursors with DCNL specific spelling within a source. The first argument can be either a DCNL TranslationUnit or Cursor instance. DCNL If no cursors are found, an empty list is returned.'
def unique(s): DCNL 'Return a list of the elements in s, but without duplicates. DCNL For example, unique([1,2,3,1,2,3]) is some permutation of [1,2,3], DCNL unique("abcabc") some permutation of ["a", "b", "c"], and DCNL unique(([1, 2], [2, 3], [1, 2])) some permutation of DCNL [[2, 3], [1, 2]]. DCNL For best speed, all sequence elements should be hashable.  Then DCNL unique() will usually work in linear time. DCNL If not possible, the sequence elements should enjoy a total DCNL ordering, and if list(s).sort() doesn\'t raise TypeError it\'s DCNL assumed that they do enjoy a total ordering.  Then unique() will DCNL usually work in O(N*log2(N)) time. DCNL If that\'s not possible either, the sequence elements must support DCNL equality-testing.  Then unique() will usually work in quadratic DCNL time.'
def generate_key(key_length=64): DCNL 'Secret key generator. DCNL The quality of randomness depends on operating system support, DCNL see http://docs.python.org/library/random.html#random.SystemRandom.'
def generate_or_read_from_file(key_file='.secret_key', key_length=64): DCNL 'Multiprocess-safe secret key file generator. DCNL Useful to replace the default (and thus unsafe) SECRET_KEY in settings.py DCNL upon first start. Save to use, i.e. when multiple Python interpreters DCNL serve the dashboard Django application (e.g. in a mod_wsgi + daemonized DCNL environment).  Also checks if file permissions are set correctly and DCNL throws an exception if not.'
def setup_logging(): DCNL 'Sets up the logging options for a log with supplied name'
def _get_deployment_flavor(): DCNL 'Retrieve the paste_deploy.flavor config item, formatted appropriately DCNL for appending to the application name.'
def _get_deployment_config_file(): DCNL 'Retrieve the deployment_config_file config item, formatted as an DCNL absolute pathname.'
def load_paste_app(app_name=None): DCNL 'Builds and returns a WSGI app from a paste config file. DCNL We assume the last config file specified in the supplied ConfigOpts DCNL object is the paste config file. DCNL :param app_name: name of the application to load DCNL :raises RuntimeError when config file cannot be located or application DCNL cannot be loaded from config file'
def chunkreadable(iter, chunk_size=65536): DCNL 'Wrap a readable iterator with a reader yielding chunks of DCNL a preferred size, otherwise leave iterator unchanged. DCNL :param iter: an iter which may also be readable DCNL :param chunk_size: maximum size of chunk'
def chunkiter(fp, chunk_size=65536): DCNL 'Return an iterator to a file-like obj which yields fixed size chunks DCNL :param fp: a file-like object DCNL :param chunk_size: maximum size of chunk'
def cooperative_iter(iter): DCNL 'Return an iterator which schedules after each DCNL iteration. This can prevent eventlet thread starvation. DCNL :param iter: an iterator to wrap'
def cooperative_read(fd): DCNL 'Wrap a file descriptor\'s read with a partial function which schedules DCNL after each read. This can prevent eventlet thread starvation. DCNL :param fd: a file descriptor to wrap'
def image_meta_to_http_headers(image_meta): DCNL 'Returns a set of image metadata into a dict DCNL of HTTP headers that can be fed to either a Webob DCNL Request object or an httplib.HTTP(S)Connection object DCNL :param image_meta: Mapping of image metadata'
def add_features_to_http_headers(features, headers): DCNL 'Adds additional headers representing glance features to be enabled. DCNL :param headers: Base set of headers DCNL :param features: Map of enabled features'
def get_image_meta_from_headers(response): DCNL 'Processes HTTP headers from a supplied response that DCNL match the x-image-meta and x-image-meta-property and DCNL returns a mapping of image metadata and properties DCNL :param response: Response to process'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean-like value.'
def mutating(func): DCNL 'Decorator to enforce read-only logic'
def get_endpoint(service_catalog, service_type='image', endpoint_region=None, endpoint_type='publicURL'): DCNL 'Select an endpoint from the service catalog DCNL We search the full service catalog for services DCNL matching both type and region. If the client DCNL supplied no region then any \'image\' endpoint DCNL is considered a match. There must be one -- and DCNL only one -- successful match in the catalog, DCNL otherwise we will raise an exception.'
def handle_unauthenticated(func): DCNL 'Wrap a function to re-authenticate and retry.'
def handle_redirects(func): DCNL 'Wrap the _do_request function to handle HTTP redirects.'
def get_bind_addr(default_port=None): DCNL 'Return the host and port to bind to.'
def get_socket(default_port): DCNL 'Bind socket to bind ip:port in conf DCNL note: Mostly comes from Swift with a few small changes... DCNL :param default_port: port to bind to if none is specified in conf DCNL :returns : a socket object as returned from socket.listen or DCNL ssl.wrap_socket if conf specifies cert_file'
def urlsafe_encrypt(key, plaintext, blocksize=16): DCNL 'Encrypts plaintext. Resulting ciphertext will contain URL-safe characters DCNL :param key: AES secret key DCNL :param plaintext: Input text to be encrypted DCNL :param blocksize: Non-zero integer multiple of AES blocksize in bytes (16) DCNL :returns : Resulting ciphertext'
def urlsafe_decrypt(key, ciphertext): DCNL 'Decrypts URL-safe base64 encoded ciphertext DCNL :param key: AES secret key DCNL :param ciphertext: The encrypted text to decrypt DCNL :returns : Resulting plaintext'
def is_image_mutable(context, image): DCNL 'Return True if the image is mutable in this context.'
def is_member_mutable(context, member): DCNL 'Return True if the image is mutable in this context.'
def create_resource(): DCNL 'Image Members resource factory method'
def create_resource(): DCNL 'Image data resource factory method'
def load_custom_properties(): DCNL 'Find the schema properties files and load them into a dict.'
def create_resource(custom_properties=None): DCNL 'Images resource factory method'
def create_resource(): DCNL 'Images resource factory method'
def image_send_notification(bytes_written, expected_size, image_meta, request, notifier): DCNL 'Send an image.send message to the notifier.'
def create_resource(): DCNL 'Image members resource factory method'
def redact_loc(image_meta): DCNL 'Create a shallow copy of image meta with \'location\' removed DCNL for security (as it can contain credentials).'
def create_resource(): DCNL 'Images resource factory method'
def create_resource(): DCNL 'Cached Images resource factory method'
def add_cli_options(): DCNL 'Adds any configuration options that the db layer might have. DCNL :retval None'
def from_migration_import(module_name, fromlist): DCNL 'Import a migration file and return the module DCNL :param module_name: name of migration module to import from DCNL (ex: 001_add_images_table) DCNL :param fromlist: list of items to import (ex: define_images_table) DCNL :retval: module object DCNL This bit of ugliness warrants an explanation: DCNL As you\'re writing migrations, you\'ll frequently want to refer to DCNL tables defined in previous migrations. DCNL In the interest of not repeating yourself, you need a way of importing DCNL that table into a \'future\' migration. DCNL However, tables are bound to metadata, so what you need to import is DCNL really a table factory, which you can late-bind to your current DCNL metadata object. DCNL Moreover, migrations begin with a number (001...), which means they DCNL aren\'t valid Python identifiers. This means we can\'t perform a DCNL \'normal\' import on them (the Python lexer will \'splode). Instead, we DCNL need to use __import__ magic to bring the table-factory into our DCNL namespace. DCNL Example Usage: DCNL (define_images_table,) = from_migration_import( DCNL \'001_add_images_table\', [\'define_images_table\']) DCNL images = define_images_table(meta) DCNL # Refer to images table'
def upgrade(migrate_engine): DCNL 'Call the correct dialect-specific upgrade.'
def downgrade(migrate_engine): DCNL 'Call the correct dialect-specific downgrade.'
def _upgrade_sqlite(t_images, t_image_members, t_image_properties): DCNL 'Upgrade 011 -> 012 with special SQLite-compatible logic.'
def _downgrade_sqlite(t_images, t_image_members, t_image_properties): DCNL 'Downgrade 012 -> 011 with special SQLite-compatible logic.'
def _upgrade_other(t_images, t_image_members, t_image_properties, dialect): DCNL 'Upgrade 011 -> 012 with logic for non-SQLite databases.'
def _downgrade_other(t_images, t_image_members, t_image_properties, dialect): DCNL 'Downgrade 012 -> 011 with logic for non-SQLite databases.'
def _get_table(table_name, metadata): DCNL 'Return a sqlalchemy Table definition with associated metadata.'
def _get_foreign_keys(t_images, t_image_members, t_image_properties, dialect): DCNL 'Retrieve and return foreign keys for members/properties tables.'
def _update_all_ids_to_uuids(t_images, t_image_members, t_image_properties): DCNL 'Transition from INTEGER id to VARCHAR(36) id.'
def _update_all_uuids_to_ids(t_images, t_image_members, t_image_properties): DCNL 'Transition from VARCHAR(36) id to INTEGER id.'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that DCNL corresponds to the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 008...'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that corresponds to DCNL the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 006...'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that DCNL corresponds to the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 002...'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that DCNL corresponds to the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 002...'
def migrate_location_credentials(migrate_engine, to_quoted): DCNL 'Migrate location credentials for encrypted swift uri\'s between the DCNL quoted and unquoted forms. DCNL :param migrate_engine: The configured db engine DCNL :param to_quoted: If True, migrate location credentials from DCNL unquoted to quoted form.  If False, do the DCNL reverse.'
def fix_uri_credentials(uri, to_quoted): DCNL 'Fix the given uri\'s embedded credentials by round-tripping with DCNL StoreLocation. DCNL If to_quoted is True, the uri is assumed to have credentials that DCNL have not been quoted, and the resulting uri will contain quoted DCNL credentials. DCNL If to_quoted is False, the uri is assumed to have credentials that DCNL have been quoted, and the resulting uri will contain credentials DCNL that have not been quoted.'
def legacy_parse_uri(self, uri): DCNL 'Parse URLs. This method fixes an issue where credentials specified DCNL in the URL are interpreted differently in Python 2.6.1+ than prior DCNL versions of Python. It also deals with the peculiarity that new-style DCNL Swift URIs have where a username can contain a \':\', like so: DCNL swift://account:user:pass@authurl.com/container/obj'
def get_images_table(meta): DCNL 'No changes to the images table from 008...'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 008...'
def get_image_members_table(meta): DCNL 'No changes to the image members table from 008...'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that DCNL corresponds to the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 002...'
def _sanitize(migrate_engine, table): DCNL 'Avoid possible integrity error by removing deleted rows DCNL to accommdate less restrictive uniqueness constraint'
def get_images_table(meta): DCNL 'No changes to the image properties table from 002...'
def get_image_properties_table(meta): DCNL 'Returns the Table object for the image_properties table that DCNL corresponds to the image_properties table definition of this version.'
def get_images_table(meta): DCNL 'No changes to the images table from 007...'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 007...'
def migrate_location_credentials(migrate_engine, to_quoted): DCNL 'Migrate location credentials for swift uri\'s between the quoted DCNL and unquoted forms. DCNL :param migrate_engine: The configured db engine DCNL :param to_quoted: If True, migrate location credentials from DCNL unquoted to quoted form.  If False, do the DCNL reverse.'
def fix_uri_credentials(uri, to_quoted): DCNL 'Fix the given uri\'s embedded credentials by round-tripping with DCNL StoreLocation. DCNL If to_quoted is True, the uri is assumed to have credentials that DCNL have not been quoted, and the resulting uri will contain quoted DCNL credentials. DCNL If to_quoted is False, the uri is assumed to have credentials that DCNL have been quoted, and the resulting uri will contain credentials DCNL that have not been quoted.'
def legacy_parse_uri(self, uri): DCNL 'Parse URLs. This method fixes an issue where credentials specified DCNL in the URL are interpreted differently in Python 2.6.1+ than prior DCNL versions of Python. It also deals with the peculiarity that new-style DCNL Swift URIs have where a username can contain a \':\', like so: DCNL swift://account:user:pass@authurl.com/container/obj'
def register_models(engine): DCNL 'Creates database tables for all models with the given engine'
def unregister_models(engine): DCNL 'Drops database tables for all models with the given engine'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def setup_db_env(): DCNL 'Setup configuration for database'
def configure_db(): DCNL 'Establish the database, create an engine if needed, and DCNL register the models.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Helper method to grab session'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def get_maker(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker.'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def wrap_db_error(f): DCNL 'Retry DB connection. Copied from nova and modified.'
def image_create(context, values): DCNL 'Create an image from the values dictionary.'
def image_update(context, image_id, values, purge_props=False): DCNL 'Set the given properties on an image and update it. DCNL :raises NotFound if image does not exist.'
def image_destroy(context, image_id): DCNL 'Destroy the image or raise if it does not exist.'
def _image_get(context, image_id, session=None, force_show_deleted=False): DCNL 'Get an image or raise if it does not exist.'
def is_image_mutable(context, image): DCNL 'Return True if the image is mutable in this context.'
def is_image_sharable(context, image, **kwargs): DCNL 'Return True if the image can be shared to others in this context.'
def is_image_visible(context, image, status=None): DCNL 'Return True if the image is visible in this context.'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def image_get_all(context, filters=None, marker=None, limit=None, sort_key='created_at', sort_dir='desc', member_status='accepted'): DCNL 'Get all images that match zero or more filters. DCNL :param filters: dict of filter keys and values. If a \'properties\' DCNL key is present, it is treated as a dict of key/value DCNL filters on the image properties attribute DCNL :param marker: image id after which to start page DCNL :param limit: maximum number of images to return DCNL :param sort_key: image attribute by which results should be sorted DCNL :param sort_dir: direction in which results should be sorted (asc, desc)'
def _drop_protected_attrs(model_class, values): DCNL 'Removed protected attributes from values dictionary using the models DCNL __protected_attributes__ field.'
def validate_image(values): DCNL 'Validates the incoming data and raises a Invalid exception DCNL if anything is out of order. DCNL :param values: Mapping of image metadata to check'
def _image_update(context, values, image_id, purge_props=False): DCNL 'Used internally by image_create and image_update DCNL :param context: Request context DCNL :param values: A dict of attributes to set DCNL :param image_id: If None, create the image, otherwise, find and update it'
def _set_properties_for_image(context, image_ref, properties, purge_props=False, session=None): DCNL 'Create or update a set of image_properties for a given image DCNL :param context: Request context DCNL :param image_ref: An Image object DCNL :param properties: A dict of properties to set DCNL :param session: A SQLAlchemy session to use (if present)'
def image_property_create(context, values, session=None): DCNL 'Create an ImageProperty object'
def _image_property_update(context, prop_ref, values, session=None): DCNL 'Used internally by image_property_create and image_property_update'
def image_property_delete(context, prop_ref, session=None): DCNL 'Used internally by image_property_create and image_property_update'
def image_member_create(context, values, session=None): DCNL 'Create an ImageMember object'
def _image_member_format(member_ref): DCNL 'Format a member ref for consumption outside of this module'
def image_member_update(context, memb_id, values): DCNL 'Update an ImageMember object'
def _image_member_update(context, memb_ref, values, session=None): DCNL 'Apply supplied dictionary of values to a Member object.'
def image_member_delete(context, memb_id, session=None): DCNL 'Delete an ImageMember object'
def _image_member_get(context, memb_id, session): DCNL 'Fetch an ImageMember entity by id'
def image_member_find(context, image_id=None, member=None, status=None): DCNL 'Find all members that meet the given criteria DCNL :param image_id: identifier of image entity DCNL :param member: tenant to which membership has been granted'
def _can_show_deleted(context): DCNL 'Calculates whether to include deleted objects based on context. DCNL Currently just looks for a flag called deleted in the context dict.'
def image_tag_create(context, image_id, value, session=None): DCNL 'Create an image tag.'
def image_tag_delete(context, image_id, value, session=None): DCNL 'Delete an image tag.'
def image_tag_get_all(context, image_id, session=None): DCNL 'Get a list of tags for a specific image.'
def db_version(): DCNL 'Return the database\'s current migration number DCNL :retval version number'
def upgrade(version=None): DCNL 'Upgrade the database\'s current migration level DCNL :param version: version to upgrade (defaults to latest) DCNL :retval version number'
def downgrade(version): DCNL 'Downgrade the database\'s current migration level DCNL :param version: version to downgrade to DCNL :retval version number'
def version_control(version=None): DCNL 'Place a database under migration control'
def _version_control(version): DCNL 'Place a database under migration control DCNL This will only set the specific version of a database, it won\'t DCNL run any migrations.'
def db_sync(version=None, current_version=None): DCNL 'Place a database under migration control and perform an upgrade DCNL :retval version number'
def get_migrate_repo_path(): DCNL 'Get the path for the migrate repository.'
def is_image_mutable(context, image): DCNL 'Return True if the image is mutable in this context.'
def is_image_sharable(context, image, **kwargs): DCNL 'Return True if the image can be shared to others in this context.'
def is_image_visible(context, image, status=None): DCNL 'Return True if the image is visible in this context.'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def get_bucket(conn, bucket_id): DCNL 'Get a bucket from an s3 connection DCNL :param conn: The ``boto.s3.connection.S3Connection`` DCNL :param bucket_id: ID of the bucket to fetch DCNL :raises ``glance.exception.NotFound`` if bucket is not found.'
def create_bucket_if_missing(bucket, s3_conn): DCNL 'Creates a missing bucket in S3 if the DCNL ``s3_store_create_bucket_on_put`` option is set. DCNL :param bucket: Name of bucket to create DCNL :param s3_conn: Connection to S3'
def get_key(bucket, obj): DCNL 'Get a key from a bucket DCNL :param bucket: The ``boto.s3.Bucket`` DCNL :param obj: Object to get the key for DCNL :raises ``glance.exception.NotFound`` if key is not found.'
def create_stores(): DCNL 'Registers all store modules and all schemes DCNL from the given config. Duplicates are not re-registered.'
def get_store_from_scheme(context, scheme, loc=None): DCNL 'Given a scheme, return the appropriate store object DCNL for handling that scheme.'
def get_store_from_uri(context, uri, loc=None): DCNL 'Given a URI, return the store object that would handle DCNL operations on the URI. DCNL :param uri: URI to analyze'
def get_from_backend(context, uri, **kwargs): DCNL 'Yields chunks of data from backend specified by uri'
def get_size_from_backend(context, uri): DCNL 'Retrieves image size from backend specified by uri'
def delete_from_backend(context, uri, **kwargs): DCNL 'Removes chunks of data from backend specified by uri'
def get_store_from_location(uri): DCNL 'Given a location (assumed to be a URL), attempt to determine DCNL the store from the location.  We use here a simple guess that DCNL the scheme of the parsed URL is the store... DCNL :param uri: Location to check for the store'
def safe_delete_from_backend(uri, context, image_id, **kwargs): DCNL 'Given a uri, delete an image from the store.'
def schedule_delayed_delete_from_backend(uri, image_id, **kwargs): DCNL 'Given a uri, schedule the deletion of an image.'
def get_location_from_uri(uri): DCNL 'Given a URI, return a Location object that has had an appropriate DCNL store parse the URI. DCNL :param uri: A URI that could come from the end-user in the Location DCNL attribute/header DCNL Example URIs: DCNL https://user:pass@example.com:80/images/some-id DCNL http://images.oracle.com/123456 DCNL swift://example.com/container/obj-id DCNL swift://user:account:pass@authurl.com/container/obj-id DCNL swift+http://user:account:pass@authurl.com/container/obj-id DCNL s3://accesskey:secretkey@s3.amazonaws.com/bucket/key-id DCNL s3+https://accesskey:secretkey@s3.amazonaws.com/bucket/key-id DCNL file:///var/lib/glance/images/1'
def register_scheme_map(scheme_map): DCNL 'Given a mapping of \'scheme\' to store_name, adds the mapping to the DCNL known list of schemes if it does not already exist.'
def http_response_iterator(conn, response, size): DCNL 'Return an iterator for a file-like object. DCNL :param conn: HTTP(S) Connection DCNL :param response: httplib.HTTPResponse object DCNL :param size: Chunk size to iterate with'
def wait_for_scrub(path): DCNL 'NOTE(jkoelker) The build servers sometimes take longer than 15 seconds to DCNL scrub. Give it up to 5 min, checking checking every 15 seconds. When/if it DCNL flips to deleted, bail immediatly.'
def skip_if_disabled(func): DCNL 'Decorator that skips a test if test case is disabled.'
def execute(cmd, raise_error=True, no_venv=False, exec_env=None, expect_exit=True, expected_exitcode=0, context=None): DCNL 'Executes a command in a subprocess. Returns a tuple DCNL of (exitcode, out, err), where out is the string output DCNL from stdout and err is the string output from stderr when DCNL executing the command. DCNL :param cmd: Command string to execute DCNL :param raise_error: If returncode is not 0 (success), then DCNL raise a RuntimeError? Default: True) DCNL :param no_venv: Disable the virtual environment DCNL :param exec_env: Optional dictionary of additional environment DCNL variables; values may be callables, which will DCNL be passed the current value of the named DCNL environment variable DCNL :param expect_exit: Optional flag true iff timely exit is expected DCNL :param expected_exitcode: expected exitcode from the launcher DCNL :param context: additional context for error message'
def find_executable(cmdname): DCNL 'Searches the path for a given cmdname.  Returns an absolute DCNL filename if an executable with the given name exists in the path, DCNL or None if one does not. DCNL :param cmdname: The bare name of the executable to search for'
def get_unused_port(): DCNL 'Returns an unused port on localhost.'
def xattr_writes_supported(path): DCNL 'Returns True if the we can write a file to the supplied DCNL path and subsequently write a xattr to that file.'
def stub_out_http_backend(stubs): DCNL 'Stubs out the httplib.HTTPRequest.getresponse to return DCNL faked-out data instead of grabbing actual contents of a resource DCNL The stubbed getresponse() returns an iterator over DCNL the data "I am a teapot, short and stout DCNL :param stubs: Set of stubout stubs'
def stub_out_registry_image_update(stubs): DCNL 'Stubs an image update on the registry. DCNL :param stubs: Set of stubout stubs'
def format_s3_location(user, key, authurl, bucket, obj): DCNL 'Helper method that returns a S3 store URI given DCNL the component pieces.'
def _get_connect_string(backend, user='openstack_citest', passwd='openstack_citest', database='openstack_citest'): DCNL 'Try to get a connection with a very specific set of values, if we get DCNL these then we\'ll run the tests, otherwise they are skipped'
def get_table(engine, name): DCNL 'Returns an sqlalchemy table dynamically from db. DCNL Needed because the models don\'t work for us in migrations DCNL as models will be far out of sync with the current data.'
def stub_out_registry_and_store_server(stubs, base_dir): DCNL 'Mocks calls to 127.0.0.1 on 9191 and 9292 for testing so DCNL that a real Glance server does not need to be up and DCNL running'
def stub_out_registry_server(stubs, **kwargs): DCNL 'Mocks calls to 127.0.0.1 on 9191 for testing so DCNL that a real Glance Registry server does not need to be up and DCNL running'
def _make_namespaced_xattr_key(key, namespace='user'): DCNL 'Create a fully-qualified xattr-key by including the intended namespace. DCNL Namespacing differs among OSes[1]: DCNL FreeBSD: user, system DCNL Linux: user, system, trusted, security DCNL MacOS X: not needed DCNL Mac OS X won\'t break if we include a namespace qualifier, so, for DCNL simplicity, we always include it. DCNL [1] http://en.wikipedia.org/wiki/Extended_file_attributes'
def get_xattr(path, key, **kwargs): DCNL 'Return the value for a particular xattr DCNL If the key doesn\'t not exist, or xattrs aren\'t supported by the file DCNL system then a KeyError will be raised, that is, unless you specify a DCNL default using kwargs.'
def set_xattr(path, key, value): DCNL 'Set the value of a specified xattr. DCNL If xattrs aren\'t supported by the file-system, we skip setting the value.'
def inc_xattr(path, key, n=1): DCNL 'Increment the value of an xattr (assuming it is an integer). DCNL BEWARE, this code *does* have a RACE CONDITION, since the DCNL read/update/write sequence is not atomic. DCNL Since the use-case for this function is collecting stats--not critical-- DCNL the benefits of simple, lock-free code out-weighs the possibility of an DCNL occasional hit not being counted.'
def get_client(host, port=None, timeout=None, use_ssl=False, username=None, password=None, tenant=None, auth_url=None, auth_strategy=None, auth_token=None, region=None, is_silent_upload=False, insecure=False): DCNL 'Returns a new client Glance client object based on common kwargs. DCNL If an option isn\'t specified falls back to common environment variable DCNL defaults.'
def setup(product_name): DCNL 'Setup logging.'
def isotime(at=None): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def set_rules(rules): DCNL 'Set the rules in use for policy checks.'
def reset(): DCNL 'Clear the rules used for policy checks.'
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL 'Checks authorization of a rule against the target and credentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operated DCNL on as possible, as a dictionary. DCNL :param creds: As much information about the user performing the DCNL action as possible, as a dictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passed to check() (both DCNL positional and keyword arguments) will be passed to DCNL the exception class.  If exc is not provided, returns DCNL False. DCNL :return: Returns False if the policy does not allow the action and DCNL exc is not provided; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specified string DCNL from the expression.'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Provided for backwards compatibility.  Translates the old DCNL list-of-lists syntax into a tree of Check objects.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods.  Arguments are a sequence of DCNL tokens, in order, which should trigger running this reduction DCNL method.'
def _parse_text_rule(rule): DCNL 'Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def format_image_notification(image): DCNL 'Given a glance.domain.Image object, return a dictionary of relevant DCNL notification information. We purposely do not include \'location\' DCNL as it may contain credentials.'
def make_member_list(members, **attr_map): DCNL 'Create a dict representation of a list of members which we can use DCNL to serialize the members list.  Keyword arguments map the names of DCNL optional attributes to include to the database attribute.'
def create_resource(): DCNL 'Image members resource factory method.'
def make_image_dict(image): DCNL 'Create a dict representation of an image which we can use to DCNL serialize the image.'
def create_resource(): DCNL 'Images resource factory method.'
def configure_registry_client(): DCNL 'Sets up a registry client for use in registry lookups'
def _sanitize_default(s): DCNL 'Set up a reasonably sensible default for pybasedir, my_ip and host.'
def cinder_todo_format(physical_line): DCNL 'Check for \'TODO()\'. DCNL cinder HACKING guide recommendation for TODO: DCNL Include your name with TODOs as in "#TODO(termie)" DCNL N101'
def cinder_except_format(logical_line): DCNL 'Check for \'except:\'. DCNL cinder HACKING guide recommends not using except: DCNL Do not write "except:", use "except Exception:" at the very least DCNL N201'
def cinder_except_format_assert(logical_line): DCNL 'Check for \'assertRaises(Exception\'. DCNL cinder HACKING guide recommends not using assertRaises(Exception...): DCNL Do not use overly broad Exception type DCNL N202'
def cinder_one_import_per_line(logical_line): DCNL 'Check for import format. DCNL cinder HACKING guide recommends one import per line: DCNL Do not import more than one module per line DCNL Examples: DCNL BAD: from cinder.rpc.common import RemoteError, LOG DCNL N301'
def cinder_import_module_only(logical_line): DCNL 'Check for import module only. DCNL cinder HACKING guide recommends importing only modules: DCNL Do not import objects, only modules DCNL N302 import only modules DCNL N303 Invalid Import DCNL N304 Relative Import'
def cinder_import_alphabetical(physical_line, line_number, lines): DCNL 'Check for imports in alphabetical order. DCNL cinder HACKING guide recommendation for imports: DCNL imports in human alphabetical order DCNL N306'
def cinder_docstring_start_space(physical_line): DCNL 'Check for docstring not start with space. DCNL cinder HACKING guide recommendation for docstring: DCNL Docstring should not start with space DCNL N401'
def cinder_docstring_one_line(physical_line): DCNL 'Check one line docstring end. DCNL cinder HACKING guide recommendation for one line docstring: DCNL A one line docstring looks like this and ends in a period. DCNL N402'
def cinder_docstring_multiline_end(physical_line): DCNL 'Check multi line docstring end. DCNL cinder HACKING guide recommendation for docstring: DCNL Docstring should end on a new line DCNL N403'
def check_l18n(): DCNL 'Generator that checks token stream for localization errors. DCNL Expects tokens to be ``send``ed one by one. DCNL Raises LocalizationError if some error is found.'
def cinder_localization_strings(logical_line, tokens): DCNL 'Check localization in line. DCNL N701: bad localization call DCNL N702: complex expression instead of string as argument to _() DCNL N703: multiple positional placeholders'
def readlines(filename): DCNL 'Record the current file being tested.'
def add_cinder(): DCNL 'Monkey patch in cinder guidelines. DCNL Look for functions that start with cinder_  and have arguments DCNL and add them to pep8 module DCNL Assumes you know how to write pep8.py checks'
def skip_if_fake(func): DCNL 'Decorator that skips a test if running in fake mode.'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'A paste pipeline replica that keys off of auth_strategy.'
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL 'Registers all standard API extensions.'
def remove_invalid_options(context, filters, allowed_search_options): DCNL 'Remove search options that are not valid for non-admin API/context.'
def _translate_snapshot_detail_view(context, snapshot): DCNL 'Maps keys for snapshots details view.'
def _translate_snapshot_summary_view(context, snapshot): DCNL 'Maps keys for snapshots summary view.'
def get_pagination_params(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specified, 0, or DCNL > max_limit, we default to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBadRequest() exceptions to be raised.'
def _get_limit_param(request): DCNL 'Extract integer limit from request or fail'
def _get_marker_param(request): DCNL 'Extract marker id from request or fail'
def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to requested offset and limit. DCNL :param items: A sliceable entity DCNL :param request: ``wsgi.Request`` possibly containing \'offset\' and \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL and \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specified, 0, or > max_limit, we default DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBadRequest() exceptions to be raised. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''
def limited_by_marker(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to the requested marker and limit.'
def remove_version_from_href(href): DCNL 'Removes the first api version from the href. DCNL Given: \'http://www.cinder.com/v1.1/123\' DCNL Returns: \'http://www.cinder.com/123\' DCNL Given: \'http://www.cinder.com/v1.1\' DCNL Returns: \'http://www.cinder.com\''
def get_items(obj): DCNL 'Get items in obj.'
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Create a template element as a child of another. DCNL Corresponds to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the addition of the parent.'
def make_links(parent, selector=None): DCNL 'Attach an Atom <links> element to the parent.'
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL 'Utility for simple XML templates that traditionally used DCNL XMLDictSerializer with no metadata.  Returns a template element DCNL where the top-level element has the given tag name, and where DCNL sub-elements have tag names derived from the object\'s keys and DCNL text derived from the object\'s values.  This only works for flat DCNL dictionary objects, not dictionaries containing nested lists or DCNL dictionaries.'
def serializers(**serializers): DCNL 'Attaches serializers to a method. DCNL This decorator associates a dictionary of serializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def deserializers(**deserializers): DCNL 'Attaches deserializers to a method. DCNL This decorator associates a dictionary of deserializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def response(code): DCNL 'Attaches response code to a method. DCNL This decorator associates a response code with a method.  Note DCNL that the function attributes are directly manipulated; the method DCNL is not wrapped.'
def action_peek_json(body): DCNL 'Determine action to invoke.'
def action_peek_xml(body): DCNL 'Determine action to invoke.'
def action(name): DCNL 'Mark a function as an action. DCNL The given name will be taken as the action key in the body. DCNL This is also overloaded to allow extensions to provide DCNL non-extending definitions of create and delete operations.'
def extends(*args, **kwargs): DCNL 'Indicate a function extends an operation. DCNL Can be used as either:: DCNL @extends DCNL def index(...): DCNL pass DCNL or as:: DCNL @extends(action=\'resize\') DCNL def _action_resize(...): DCNL pass'
def _translate_attachment_detail_view(_context, vol): DCNL 'Maps keys for attachment details view.'
def _translate_attachment_summary_view(_context, vol): DCNL 'Maps keys for attachment summary view.'
def _translate_volume_detail_view(context, vol, image_id=None): DCNL 'Maps keys for volumes details view.'
def _translate_volume_summary_view(context, vol, image_id=None): DCNL 'Maps keys for volumes summary view.'
def remove_invalid_options(context, search_options, allowed_search_options): DCNL 'Remove search options that are not valid for non-admin API/context.'
def _translate_snapshot_detail_view(context, snapshot): DCNL 'Maps keys for snapshots details view.'
def _translate_snapshot_summary_view(context, snapshot): DCNL 'Maps keys for snapshots summary view.'
def unquote_header_value(value): DCNL 'Unquotes a header value. DCNL This does not use the real unquoting but what browsers are actually DCNL using for quoting. DCNL :param value: the header value to unquote.'
def parse_list_header(value): DCNL 'Parse lists as described by RFC 2068 Section 2. DCNL In particular, parse comma-separated lists where the elements of DCNL the list may include quoted-strings.  A quoted-string could DCNL contain a comma.  A non-quoted string could have quotes in the DCNL middle.  Quotes are removed automatically after parsing. DCNL The return value is a standard :class:`list`: DCNL >>> parse_list_header(\'token, "quoted value"\') DCNL [\'token\', \'quoted value\'] DCNL :param value: a string with a list header. DCNL :return: :class:`list`'
def parse_options_header(value): DCNL 'Parse a ``Content-Type`` like header into a tuple with the content DCNL type and the options: DCNL >>> parse_options_header(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the header to parse. DCNL :return: (str, options)'
def _list_hosts(req, service=None): DCNL 'Returns a summary list of hosts.'
def check_host(fn): DCNL 'Makes sure that the host exists.'
def upgrade(migrate_engine): DCNL 'Add source volume id column to volumes.'
def downgrade(migrate_engine): DCNL 'Remove source volume id column to volumes.'
def upgrade(migrate_engine): DCNL 'Convert volume_type_id to UUID.'
def downgrade(migrate_engine): DCNL 'Convert volume_type from UUID back to int.'
def register_models(): DCNL 'Register Models and create metadata. DCNL Called from cinder.db.sqlalchemy.__init__ as part of loading the driver, DCNL it will never need to be called explicitly elsewhere unless the DCNL connection is lost and needs to be reestablished.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def is_admin_context(context): DCNL 'Indicates if the request context is an administrator.'
def is_user_context(context): DCNL 'Indicates if the request context is a normal user.'
def authorize_project_context(context, project_id): DCNL 'Ensures a request has permission to access the given project.'
def authorize_user_context(context, user_id): DCNL 'Ensures a request has permission to access the given user.'
def authorize_quota_class_context(context, class_name): DCNL 'Ensures a request has permission to access the given quota class.'
def require_admin_context(f): DCNL 'Decorator to require admin request context. DCNL The first argument to the wrapped function must be the context.'
def require_context(f): DCNL 'Decorator to require *any* user or admin context. DCNL This does no authorization for user or project access matching, see DCNL :py:func:`authorize_project_context` and DCNL :py:func:`authorize_user_context`. DCNL The first argument to the wrapped function must be the context.'
def require_volume_exists(f): DCNL 'Decorator to require the specified volume to exist. DCNL Requires the wrapped function to use context and volume_id as DCNL their first two arguments.'
def require_snapshot_exists(f): DCNL 'Decorator to require the specified snapshot to exist. DCNL Requires the wrapped function to use context and snapshot_id as DCNL their first two arguments.'
def model_query(context, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id.'
def exact_filter(query, model, filters, legal_keys): DCNL 'Applies exact match filtering to a query. DCNL Returns the updated query.  Modifies filters argument to remove DCNL filters consumed. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to, for IN-style DCNL filtering DCNL :param filters: dictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performed, while exact matching (\'==\' operator) DCNL is used for other values DCNL :param legal_keys: list of keys to apply exact filtering to'
def _dict_with_extra_specs(inst_type_query): DCNL 'Takes an instance, volume, or instance type query returned DCNL by sqlalchemy and returns it as a dictionary, converting the DCNL extra_specs entry from a list of dicts: DCNL \'extra_specs\' : [{\'key\': \'k1\', \'value\': \'v1\', ...}, ...] DCNL to a single dict: DCNL \'extra_specs\' : {\'k1\': \'v1\'}'
def _quota_reservations(session, context, reservations): DCNL 'Return the relevant reservations.'
@require_admin_context DCNL def volume_type_create(context, values): DCNL 'Create a new instance type. In order to pass in extra specs, DCNL the values dict should contain a \'extra_specs\' key/value pair: DCNL {\'extra_specs\' : {\'k1\': \'v1\', \'k2\': \'v2\', ...}}'
@require_context DCNL def volume_type_get_all(context, inactive=False, filters=None): DCNL 'Returns a dict describing all volume_types with name as key.'
@require_context DCNL def volume_type_get(context, id, session=None): DCNL 'Returns a dict describing specific volume_type'
@require_context DCNL def volume_type_get_by_name(context, name, session=None): DCNL 'Returns a dict describing specific volume_type'
@require_context DCNL def volume_get_active_by_window(context, begin, end=None, project_id=None): DCNL 'Return volumes that were active during window.'
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_get(context, volume_id, session=None): DCNL 'Return the Glance metadata for the specified volume.'
@require_context DCNL @require_snapshot_exists DCNL def volume_snapshot_glance_metadata_get(context, snapshot_id, session=None): DCNL 'Return the Glance metadata for the specified snapshot.'
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_create(context, volume_id, key, value, session=None): DCNL 'Update the Glance metadata for a volume by adding a new key:value pair. DCNL This API does not support changing the value of a key once it has been DCNL created.'
@require_context DCNL @require_snapshot_exists DCNL def volume_glance_metadata_copy_to_snapshot(context, snapshot_id, volume_id, session=None): DCNL 'Update the Glance metadata for a snapshot by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume created from DCNL the snapshot will retain the original metadata.'
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_copy_from_volume_to_volume(context, src_volume_id, volume_id, session=None): DCNL 'Update the Glance metadata for a volume by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume created from DCNL the volume (clone) will retain the original metadata.'
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id, session=None): DCNL 'Update the Glance metadata from a volume (created from a snapshot) by DCNL copying all of the key:value pairs from the originating snapshot. This is DCNL so that the Glance metadata from the original volume is retained.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def service_destroy(context, service_id): DCNL 'Destroy the service or raise if it does not exist.'
def service_get(context, service_id): DCNL 'Get a service or raise if it does not exist.'
def service_get_by_host_and_topic(context, host, topic): DCNL 'Get a service by host it\'s on and topic it listens to.'
def service_get_all(context, disabled=None): DCNL 'Get all services.'
def service_get_all_by_topic(context, topic): DCNL 'Get all services for a given topic.'
def service_get_all_by_host(context, host): DCNL 'Get all services for a given host.'
def service_get_all_volume_sorted(context): DCNL 'Get all volume services sorted by volume count. DCNL :returns: a list of (Service, volume_count) tuples.'
def service_get_by_args(context, host, binary): DCNL 'Get the state of an service by node name and binary.'
def service_create(context, values): DCNL 'Create a service from the values dictionary.'
def service_update(context, service_id, values): DCNL 'Set the given properties on an service and update it. DCNL Raises NotFound if service does not exist.'
def migration_update(context, id, values): DCNL 'Update a migration instance.'
def migration_create(context, values): DCNL 'Create a migration record.'
def migration_get(context, migration_id): DCNL 'Finds a migration by the id.'
def migration_get_by_instance_and_status(context, instance_uuid, status): DCNL 'Finds a migration by the instance uuid its migrating.'
def migration_get_all_unconfirmed(context, confirm_window): DCNL 'Finds all unconfirmed migrations within the confirmation window.'
def iscsi_target_count_by_host(context, host): DCNL 'Return count of export devices.'
def iscsi_target_create_safe(context, values): DCNL 'Create an iscsi_target from the values dictionary. DCNL The device is not returned. If the create violates the unique DCNL constraints because the iscsi_target and host already exist, DCNL no exception is raised.'
def volume_allocate_iscsi_target(context, volume_id, host): DCNL 'Atomically allocate a free iscsi_target from the pool.'
def volume_attached(context, volume_id, instance_id, mountpoint): DCNL 'Ensure that a volume is set as attached.'
def volume_create(context, values): DCNL 'Create a volume from the values dictionary.'
def volume_data_get_for_host(context, host, session=None): DCNL 'Get (volume_count, gigabytes) for project.'
def volume_data_get_for_project(context, project_id, session=None): DCNL 'Get (volume_count, gigabytes) for project.'
def volume_destroy(context, volume_id): DCNL 'Destroy the volume or raise if it does not exist.'
def volume_detached(context, volume_id): DCNL 'Ensure that a volume is set as detached.'
def volume_get(context, volume_id): DCNL 'Get a volume or raise if it does not exist.'
def volume_get_all(context, marker, limit, sort_key, sort_dir): DCNL 'Get all volumes.'
def volume_get_all_by_host(context, host): DCNL 'Get all volumes belonging to a host.'
def volume_get_all_by_instance_uuid(context, instance_uuid): DCNL 'Get all volumes belonging to a instance.'
def volume_get_all_by_project(context, project_id, marker, limit, sort_key, sort_dir): DCNL 'Get all volumes belonging to a project.'
def volume_get_iscsi_target_num(context, volume_id): DCNL 'Get the target num (tid) allocated to the volume.'
def volume_update(context, volume_id, values): DCNL 'Set the given properties on an volume and update it. DCNL Raises NotFound if volume does not exist.'
def snapshot_create(context, values): DCNL 'Create a snapshot from the values dictionary.'
def snapshot_destroy(context, snapshot_id): DCNL 'Destroy the snapshot or raise if it does not exist.'
def snapshot_get(context, snapshot_id): DCNL 'Get a snapshot or raise if it does not exist.'
def snapshot_get_all(context): DCNL 'Get all snapshots.'
def snapshot_get_all_by_project(context, project_id): DCNL 'Get all snapshots belonging to a project.'
def snapshot_get_all_for_volume(context, volume_id): DCNL 'Get all snapshots for a volume.'
def snapshot_update(context, snapshot_id, values): DCNL 'Set the given properties on an snapshot and update it. DCNL Raises NotFound if snapshot does not exist.'
def snapshot_data_get_for_project(context, project_id, session=None): DCNL 'Get count and gigabytes used for snapshots for specified project.'
def snapshot_metadata_get(context, snapshot_id): DCNL 'Get all metadata for a snapshot.'
def snapshot_metadata_delete(context, snapshot_id, key): DCNL 'Delete the given metadata item.'
def snapshot_metadata_update(context, snapshot_id, metadata, delete): DCNL 'Update metadata if it exists, otherwise create it.'
def volume_metadata_get(context, volume_id): DCNL 'Get all metadata for a volume.'
def volume_metadata_delete(context, volume_id, key): DCNL 'Delete the given metadata item.'
def volume_metadata_update(context, volume_id, metadata, delete): DCNL 'Update metadata if it exists, otherwise create it.'
def volume_type_create(context, values): DCNL 'Create a new volume type.'
def volume_type_get_all(context, inactive=False): DCNL 'Get all volume types.'
def volume_type_get(context, id): DCNL 'Get volume type by id.'
def volume_type_get_by_name(context, name): DCNL 'Get volume type by name.'
def volume_type_destroy(context, id): DCNL 'Delete a volume type.'
def volume_get_active_by_window(context, begin, end=None, project_id=None): DCNL 'Get all the volumes inside the window. DCNL Specifying a project_id will filter for a certain project.'
def volume_type_extra_specs_get(context, volume_type_id): DCNL 'Get all extra specs for a volume type.'
def volume_type_extra_specs_delete(context, volume_type_id, key): DCNL 'Delete the given extra specs item.'
def volume_type_extra_specs_update_or_create(context, volume_type_id, extra_specs): DCNL 'Create or update volume type extra specs. This adds or modifies the DCNL key/value pairs specified in the extra specs dict argument'
def volume_glance_metadata_create(context, volume_id, key, value): DCNL 'Update the Glance metadata for the specified volume.'
def volume_glance_metadata_get(context, volume_id): DCNL 'Return the glance metadata for a volume.'
def volume_snapshot_glance_metadata_get(context, snapshot_id): DCNL 'Return the Glance metadata for the specified snapshot.'
def volume_glance_metadata_copy_to_snapshot(context, snapshot_id, volume_id): DCNL 'Update the Glance metadata for a snapshot by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume created from DCNL the snapshot will retain the original metadata.'
def volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id): DCNL 'Update the Glance metadata from a volume (created from a snapshot) by DCNL copying all of the key:value pairs from the originating snapshot. This is DCNL so that the Glance metadata from the original volume is retained.'
def volume_glance_metadata_delete_by_volume(context, volume_id): DCNL 'Delete the glance metadata for a volume.'
def volume_glance_metadata_delete_by_snapshot(context, snapshot_id): DCNL 'Delete the glance metadata for a snapshot.'
def volume_glance_metadata_copy_from_volume_to_volume(context, src_volume_id, volume_id): DCNL 'Update the Glance metadata for a volume by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume created from DCNL the volume (clone) will retain the original metadata.'
def sm_backend_conf_create(context, values): DCNL 'Create a new SM Backend Config entry.'
def sm_backend_conf_update(context, sm_backend_conf_id, values): DCNL 'Update a SM Backend Config entry.'
def sm_backend_conf_delete(context, sm_backend_conf_id): DCNL 'Delete a SM Backend Config.'
def sm_backend_conf_get(context, sm_backend_conf_id): DCNL 'Get a specific SM Backend Config.'
def sm_backend_conf_get_by_sr(context, sr_uuid): DCNL 'Get a specific SM Backend Config.'
def sm_backend_conf_get_all(context): DCNL 'Get all SM Backend Configs.'
def sm_flavor_create(context, values): DCNL 'Create a new SM Flavor entry.'
def sm_flavor_update(context, sm_flavor_id, values): DCNL 'Update a SM Flavor entry.'
def sm_flavor_delete(context, sm_flavor_id): DCNL 'Delete a SM Flavor.'
def sm_flavor_get(context, sm_flavor): DCNL 'Get a specific SM Flavor.'
def sm_flavor_get_all(context): DCNL 'Get all SM Flavors.'
def sm_volume_create(context, values): DCNL 'Create a new child Zone entry.'
def sm_volume_update(context, volume_id, values): DCNL 'Update a child Zone entry.'
def sm_volume_delete(context, volume_id): DCNL 'Delete a child Zone.'
def sm_volume_get(context, volume_id): DCNL 'Get a specific child Zone.'
def sm_volume_get_all(context): DCNL 'Get all child Zones.'
def quota_create(context, project_id, resource, limit): DCNL 'Create a quota for the given project and resource.'
def quota_get(context, project_id, resource): DCNL 'Retrieve a quota or raise if it does not exist.'
def quota_get_all_by_project(context, project_id): DCNL 'Retrieve all quotas associated with a given project.'
def quota_update(context, project_id, resource, limit): DCNL 'Update a quota or raise if it does not exist.'
def quota_destroy(context, project_id, resource): DCNL 'Destroy the quota or raise if it does not exist.'
def quota_class_create(context, class_name, resource, limit): DCNL 'Create a quota class for the given name and resource.'
def quota_class_get(context, class_name, resource): DCNL 'Retrieve a quota class or raise if it does not exist.'
def quota_class_get_all_by_name(context, class_name): DCNL 'Retrieve all quotas associated with a given quota class.'
def quota_class_update(context, class_name, resource, limit): DCNL 'Update a quota class or raise if it does not exist.'
def quota_class_destroy(context, class_name, resource): DCNL 'Destroy the quota class or raise if it does not exist.'
def quota_class_destroy_all_by_name(context, class_name): DCNL 'Destroy all quotas associated with a given quota class.'
def quota_usage_create(context, project_id, resource, in_use, reserved, until_refresh): DCNL 'Create a quota usage for the given project and resource.'
def quota_usage_get(context, project_id, resource): DCNL 'Retrieve a quota usage or raise if it does not exist.'
def quota_usage_get_all_by_project(context, project_id): DCNL 'Retrieve all usage associated with a given resource.'
def reservation_create(context, uuid, usage, project_id, resource, delta, expire): DCNL 'Create a reservation for the given project and resource.'
def reservation_get(context, uuid): DCNL 'Retrieve a reservation or raise if it does not exist.'
def reservation_get_all_by_project(context, project_id): DCNL 'Retrieve all reservations associated with a given project.'
def reservation_destroy(context, uuid): DCNL 'Destroy the reservation or raise if it does not exist.'
def quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=None): DCNL 'Check quotas and create appropriate reservations.'
def reservation_commit(context, reservations, project_id=None): DCNL 'Commit quota reservations.'
def reservation_rollback(context, reservations, project_id=None): DCNL 'Roll back quota reservations.'
def quota_destroy_all_by_project(context, project_id): DCNL 'Destroy all quotas associated with a given project.'
def reservation_expire(context): DCNL 'Roll back any expired reservations.'
def backup_get(context, backup_id): DCNL 'Get a backup or raise if it does not exist.'
def backup_get_all(context): DCNL 'Get all backups.'
def backup_get_all_by_host(context, host): DCNL 'Get all backups belonging to a host.'
def backup_create(context, values): DCNL 'Create a backup from the values dictionary.'
def backup_get_all_by_project(context, project_id): DCNL 'Get all backups belonging to a project.'
def backup_update(context, backup_id, values): DCNL 'Set the given properties on a backup and update it. DCNL Raises NotFound if backup does not exist.'
def backup_destroy(context, backup_id): DCNL 'Destroy the backup or raise if it does not exist.'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def find_config(config_path): DCNL 'Find a configuration file using the given hint. DCNL :param config_path: Full or relative path to the config. DCNL :returns: Full path of the config, if it exists. DCNL :raises: `cinder.exception.ConfigNotFound`'
def execute(*cmd, **kwargs): DCNL 'Helper method to execute command with optional retry. DCNL If you add a run_as_root=True command, don\'t forget to add the DCNL corresponding filter to etc/cinder/rootwrap.d ! DCNL :param cmd:                Passed to subprocess.Popen. DCNL :param process_input:      Send to opened process. DCNL :param check_exit_code:    Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these code. DCNL :param delay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmd. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper FLAG. DCNL :raises exception.Error: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stdout, stderr) from the spawned process, or None if DCNL the command fails.'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def last_completed_audit_period(unit=None): DCNL 'This method gives you the most recently *completed* audit period. DCNL arguments: DCNL units: string, one of \'hour\', \'day\', \'month\', \'year\' DCNL Periods normally begin at the beginning (UTC) of the DCNL period unit (So a \'day\' period begins at midnight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appended with an optional offset DCNL like so:  \'day@18\'  This will begin the period at 18:00 DCNL UTC.  \'month@15\' starts a monthly period on the 15th, DCNL and year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of datetimes (begin, end) DCNL The begin timestamp of this audit period is the same as the DCNL end of the previous.'
def generate_password(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL 'Generate a random password from the supplied symbol groups. DCNL At least one symbol from each group will be included. Unpredictable DCNL results if length is less than the number of symbol groups. DCNL Believed to be reasonably secure (with a reasonable password length!)'
def safe_minidom_parse_string(xml_string): DCNL 'Parse an XML string using minidom safely.'
def xhtml_escape(value): DCNL 'Escapes a string so it is valid within XML or XHTML.'
def utf8(value): DCNL 'Try to turn a string into utf-8 if possible. DCNL Code is directly from the utf8 function in DCNL http://github.com/facebook/tornado/blob/master/tornado/escape.py'
def delete_if_exists(pathname): DCNL 'delete a file, but ignore file not found error'
def get_from_path(items, path): DCNL 'Returns a list of items matching the specified path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, and for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermediate results are lists it will treat each list item individually. DCNL A \'None\' in items or any child expressions will be ignored, this function DCNL will not throw because of None (anywhere) in items.  The returned list DCNL will contain no None values.'
def flatten_dict(dict_, flattened=None): DCNL 'Recursively flatten a nested dictionary.'
def partition_dict(dict_, keys): DCNL 'Return two dicts, one with `keys` the other with everything else.'
def map_dict_keys(dict_, key_map): DCNL 'Return a dict in which the dictionaries keys are mapped to new keys.'
def subset_dict(dict_, keys): DCNL 'Return a dict that only contains a subset of keys.'
def check_isinstance(obj, cls): DCNL 'Checks that obj is of type cls, and lets PyLint infer types.'
def bool_from_str(val): DCNL 'Convert a string representation of a bool into a bool value'
def is_valid_boolstr(val): DCNL 'Check if the provided string is a valid bool string or not.'
def is_valid_ipv4(address): DCNL 'valid the address strictly as per format xxx.xxx.xxx.xxx. DCNL where xxx is a value between 0 and 255.'
def monkey_patch(): DCNL 'If the Flags.monkey_patch set as True, DCNL this function patches a decorator DCNL for all functions in specified modules. DCNL You can set decorators for each modules DCNL using FLAGS.monkey_patch_modules. DCNL The format is "Module path:Decorator function". DCNL Example: \'cinder.api.ec2.cloud:\'      cinder.openstack.common.notifier.api.notify_decorator\' DCNL Parameters of the decorator is as follows. DCNL (See cinder.openstack.common.notifier.api.notify_decorator) DCNL name - name of the function DCNL function - object of the function'
def convert_to_list_dict(lst, label): DCNL 'Convert a value or list into a list of dicts'
def timefunc(func): DCNL 'Decorator that logs how long a particular function took to execute'
def generate_glance_url(): DCNL 'Generate the URL to glance.'
@contextlib.contextmanager DCNL def logging_error(message): DCNL 'Catches exception, write message to the log, re-raise. DCNL This is a common refinement of save_and_reraise that writes a specific DCNL message to the log.'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed.'
def make_dev_path(dev, partition=None, base='/dev'): DCNL 'Return a path to a particular device. DCNL >>> make_dev_path(\'xvdc\') DCNL /dev/xvdc DCNL >>> make_dev_path(\'xvdc\', 1) DCNL /dev/xvdc1'
def total_seconds(td): DCNL 'Local total_seconds implementation for compatibility with python 2.6'
def sanitize_hostname(hostname): DCNL 'Return a hostname which conforms to RFC-952 and RFC-1123 specs.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def hash_file(file_like_object): DCNL 'Generate a hash for the contents of a file.'
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL 'Temporarily set the attr on a particular object to a given value then DCNL revert when finished. DCNL One use of this is to temporarily set the read_deleted flag on a context DCNL object: DCNL with temporary_mutation(context, read_deleted="yes"): DCNL do_something_that_needed_deleted_objects()'
def service_is_up(service): DCNL 'Check whether a service is up based on last heartbeat.'
def generate_mac_address(): DCNL 'Generate an Ethernet MAC address.'
def read_file_as_root(file_path): DCNL 'Secure helper to read file as root.'
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL 'Temporarily chown a path. DCNL :params owner_uid: UID of temporary owner (defaults to current user)'
def strcmp_const_time(s1, s2): DCNL 'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.'
def walk_class_hierarchy(clazz, encountered=None): DCNL 'Walk class hierarchy, yielding most derived classes first'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def to_bytes(text, default=0): DCNL 'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to determine what conversion is needed to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the end)'
def enforce(context, action, target): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: cinder context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_volume``, DCNL ``volume:attach_volume`` DCNL :param object: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :raises cinder.exception.PolicyNotAuthorized: if verification fails.'
def check_is_admin(roles): DCNL 'Whether or not roles contains \'admin\' role according to policy setting.'
def wire_HTTPConnection_to_WSGI(host, app): DCNL 'Monkeypatches HTTPConnection so that if you try to connect to host, you DCNL are instead routed straight to the given WSGI app. DCNL After calling this method, when any code calls DCNL httplib.HTTPConnection(host) DCNL the connection object will be a fake.  Its requests will be sent directly DCNL to the given WSGI app rather than through a socket. DCNL Code connecting to hosts other than host will not be affected. DCNL This method may be called multiple times to map different hosts to DCNL different apps. DCNL This method returns the original HTTPConnection object, so that the caller DCNL can restore the default HTTPConnection interface (for all hosts).'
def compare_links(actual, expected): DCNL 'Compare xml atom links.'
def compare_media_types(actual, expected): DCNL 'Compare xml media types.'
def compare_tree_to_dict(actual, expected, keys): DCNL 'Compare parts of lxml.etree objects to dicts.'
def wire_HTTPConnection_to_WSGI(host, app): DCNL 'Monkeypatches HTTPConnection so that if you try to connect to host, you DCNL are instead routed straight to the given WSGI app. DCNL After calling this method, when any code calls DCNL httplib.HTTPConnection(host) DCNL the connection object will be a fake.  Its requests will be sent directly DCNL to the given WSGI app rather than through a socket. DCNL Code connecting to hosts other than host will not be affected. DCNL This method may be called multiple times to map different hosts to DCNL different apps. DCNL This method returns the original HTTPConnection object, so that the caller DCNL can restore the default HTTPConnection interface (for all hosts).'
def stub_out(stubs, funcs): DCNL 'Set the stubs in mapping in the db api.'
def generate_random_alphanumeric(length): DCNL 'Creates a random alphanumeric string of specified length.'
def generate_random_numeric(length): DCNL 'Creates a random numeric string of specified length.'
def generate_new_element(items, prefix, numeric=False): DCNL 'Creates a random string with prefix, that is not in \'items\' list.'
def fake_execute_set_repliers(repliers): DCNL 'Allows the client to configure replies to commands.'
def fake_execute_default_reply_handler(*ignore_args, **ignore_kwargs): DCNL 'A reply handler for commands that haven\'t been added to the reply list. DCNL Returns empty strings for stdout and stderr.'
def fake_execute(*cmd_parts, **kwargs): DCNL 'This function stubs out execute. DCNL It optionally executes a preconfigued function to return expected data.'
def example_decorator(name, function): DCNL 'decorator for notify which is used from utils.monkey_patch(). DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def stub_out_https_backend(stubs): DCNL 'Stubs out the httplib.HTTPRequest.getresponse to return DCNL faked-out data instead of grabbing actual contents of a resource DCNL The stubbed getresponse() returns an iterator over DCNL the data "I am a teapot, short and stout DCNL :param stubs: Set of stubout stubs'
def _get_connect_string(backend, user='openstack_citest', passwd='openstack_citest', database='openstack_citest'): DCNL 'Try to get a connection with a very specific set of values, if we get DCNL these then we\'ll run the tests, otherwise they are skipped'
def get_table(engine, name): DCNL 'Returns an sqlalchemy table dynamically from db. DCNL Needed because the models don\'t work for us in migrations DCNL as models will be far out of sync with the current data.'
def serialize_args(*args, **kwargs): DCNL 'Workaround for float string conversion issues in Python 2.6.'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def setup(product_name): DCNL 'Setup logging.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def set_brain(brain): DCNL 'Set the brain used by enforce(). DCNL Defaults use Brain() if not set.'
def reset(): DCNL 'Clear the brain used by enforce().'
def enforce(match_list, target_dict, credentials_dict, exc=None, *args, **kwargs): DCNL 'Enforces authorization of some rules against credentials. DCNL :param match_list: nested tuples of data to match against DCNL The basic brain supports three types of match lists: DCNL 1) rules DCNL looks like: ``(\'rule:compute:get_instance\',)`` DCNL Retrieves the named rule from the rules dict and recursively DCNL checks against the contents of the rule. DCNL 2) roles DCNL looks like: ``(\'role:compute:admin\',)`` DCNL Matches if the specified role is in credentials_dict[\'roles\']. DCNL 3) generic DCNL looks like: ``(\'tenant_id:%(tenant_id)s\',)`` DCNL Substitutes values from the target dict into the match using DCNL the % operator and matches them against the creds dict. DCNL Combining rules: DCNL The brain returns True if any of the outer tuple of rules DCNL match and also True if all of the inner tuples match. You DCNL can use this to perform simple boolean logic.  For DCNL example, the following rule would return True if the creds DCNL contain the role \'admin\' OR the if the tenant_id matches DCNL the target dict AND the the creds contains the role DCNL \'compute_sysadmin\': DCNL "rule:combined": ( DCNL \'role:admin\', DCNL (\'tenant_id:%(tenant_id)s\', \'role:compute_sysadmin\') DCNL Note that rule and role are reserved words in the credentials match, so DCNL you can\'t match against properties with those names. Custom brains may DCNL also add new reserved words. For example, the HttpBrain adds http as a DCNL reserved word. DCNL :param target_dict: dict of object properties DCNL Target dicts contain as much information as we can about the object being DCNL operated on. DCNL :param credentials_dict: dict of actor properties DCNL Credentials dicts contain as much information as we can about the user DCNL performing the action. DCNL :param exc: exception to raise DCNL Class of the exception to raise if the check fails.  Any remaining DCNL arguments passed to enforce() (both positional and keyword arguments) DCNL will be passed to the exception class.  If exc is not provided, returns DCNL False. DCNL :return: True if the policy allows the action DCNL :return: False if the policy does not allow the action and exc is not set'
def register(name, func=None): DCNL 'Register a function as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default function DCNL will be registered. DCNL :param func: If given, provides the function to register.  If not DCNL given, returns a function taking one argument to DCNL specify the function to register, allowing use as a DCNL decorator.'
@register('rule') DCNL def _check_rule(brain, match_kind, match, target_dict, cred_dict): DCNL 'Recursively checks credentials based on the brains rules.'
@register('role') DCNL def _check_role(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check that there is a matching role in the cred dict.'
@register('http') DCNL def _check_http(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response is DCNL exactly \'True\'. A custom brain using response codes could easily DCNL be implemented.'
@register(None) DCNL def _check_generic(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filters, userargs, exec_dirs=[]): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter. DCNL Raises NoFilterMatched if no filter matched. DCNL Raises FilterMatchNotExecutable if no executable was found for the DCNL best filter match.'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every tick DCNL of the periodic scheduler. DCNL 2. With arguments, @periodic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic scheduler.'
def qemu_img_info(path): DCNL 'Return a object containing the parsed output from qemu-img info.'
def convert_image(source, dest, out_format): DCNL 'Convert image to other format'
def _parse_image_ref(image_href): DCNL 'Parse an image href into composite parts. DCNL :param image_href: href of an image DCNL :returns: a tuple of the form (image_id, host, port) DCNL :raises ValueError'
def _create_glance_client(context, host, port, use_ssl, version=FLAGS.glance_api_version): DCNL 'Instantiate a new glanceclient.Client object'
def get_api_servers(): DCNL 'Shuffle a list of FLAGS.glance_api_servers and return an iterator DCNL that will cycle through the list, looping around to the beginning DCNL if necessary.'
def _convert_timestamps_to_datetimes(image_meta): DCNL 'Returns image with timestamp fields converted to datetime objects.'
def _reraise_translated_image_exception(image_id): DCNL 'Transform the exception for the image but keep its traceback intact.'
def _reraise_translated_exception(): DCNL 'Transform the exception but keep its traceback intact.'
def get_remote_image_service(context, image_href): DCNL 'Create an image_service and parse the id from the given image_href. DCNL The image_href param can be an href of the form DCNL \'http://example.com:9292/v1/images/b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3\', DCNL or just an id such as \'b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3\'. If the DCNL image_href is a standalone id, then the default image service is returned. DCNL :param image_href: href that describes the location of an image DCNL :returns: a tuple of the form (image_service, image_id)'
def volume_update_db(context, volume_id, host): DCNL 'Set the host and set the scheduled_at field of a volume. DCNL :returns: A Volume with the updated fields set properly.'
def notify_usage_exists(context, volume_ref, current_period=False): DCNL 'Generates \'exists\' notification for a volume for usage auditing DCNL purposes. DCNL Generates usage for last completed period, unless \'current_period\' DCNL is True.'
def create(context, name, extra_specs={}): DCNL 'Creates volume types.'
def destroy(context, id): DCNL 'Marks volume types as deleted.'
def get_all_types(context, inactive=0, search_opts={}): DCNL 'Get all non-deleted volume_types. DCNL Pass true as argument if you want deleted volume types returned also.'
def get_volume_type(ctxt, id): DCNL 'Retrieves single volume type by id.'
def get_volume_type_by_name(context, name): DCNL 'Retrieves single volume type by name.'
def get_default_volume_type(): DCNL 'Get the default volume type.'
def wrap_check_policy(func): DCNL 'Check policy corresponding to the wrapped methods prior to execution DCNL This decorator requires the first 3 args of the wrapped function DCNL to be (self, context, volume)'
def _sanitize_default(s): DCNL 'Set up a reasonably sensible default for pybasedir, my_ip and host.'
def _bytes2int(bytes): DCNL 'Convert bytes to int.'
def _parse_network_details(machine_id): DCNL 'Parse the machine_id to get MAC, IP, Netmask and Gateway fields per NIC. DCNL machine_id is of the form (\'NIC_record#NIC_record#\', \'\') DCNL Each of the NIC will have record NIC_record in the form DCNL \'MAC;IP;Netmask;Gateway;Broadcast;DNS\' where \';\' is field separator. DCNL Each record is separated by \'#\' from next record.'
def _get_windows_network_adapters(): DCNL 'Get the list of windows network adapters.'
def _get_linux_network_adapters(): DCNL 'Get the list of Linux network adapters.'
def _get_adapter_name_and_ip_address(network_adapters, mac_address): DCNL 'Get the adapter name based on the MAC address.'
def _get_win_adapter_name_and_ip_address(mac_address): DCNL 'Get Windows network adapter name.'
def _get_linux_adapter_name_and_ip_address(mac_address): DCNL 'Get Linux network adapter name.'
def _execute(cmd_list, process_input=None, check_exit_code=True): DCNL 'Executes the command with the list of arguments specified.'
def _windows_set_networking(): DCNL 'Set IP address for the windows VM.'
def _set_rhel_networking(network_details=None): DCNL 'Set IPv4 network settings for RHEL distros.'
def _set_ubuntu_networking(network_details=None): DCNL 'Set IPv4 network settings for Ubuntu.'
def _linux_set_networking(): DCNL 'Set IP address for the Linux VM.'
def call_xenapi(xenapi, method, *args): DCNL 'Make a call to xapi.'
def find_orphaned_instances(xenapi): DCNL 'Find and return a list of orphaned instances.'
def cleanup_instance(xenapi, instance, vm_ref, vm_rec): DCNL 'Delete orphaned instances.'
def _get_applicable_vm_recs(xenapi): DCNL 'An \'applicable\' VM is one that is not a template and not the control DCNL domain.'
def print_xen_object(obj_type, obj, indent_level=0, spaces_per_indent=4): DCNL 'Pretty-print a Xen object. DCNL Looks like: DCNL VM (abcd-abcd-abcd): \'name label here\''
def _find_vdis_connected_to_vm(xenapi, connected_vdi_uuids): DCNL 'Find VDIs which are connected to VBDs which are connected to VMs.'
def _find_all_vdis_and_system_vdis(xenapi, all_vdi_uuids, connected_vdi_uuids): DCNL 'Collects all VDIs and adds system VDIs to the connected set.'
def find_orphaned_vdi_uuids(xenapi): DCNL 'Walk VM -> VBD -> VDI change and accumulate connected VDIs.'
def list_orphaned_vdis(vdi_uuids): DCNL 'List orphaned VDIs.'
def clean_orphaned_vdis(xenapi, vdi_uuids): DCNL 'Clean orphaned VDIs.'
def list_orphaned_instances(orphaned_instances): DCNL 'List orphaned instances.'
def clean_orphaned_instances(xenapi, orphaned_instances): DCNL 'Clean orphaned instances.'
def main(): DCNL 'Main loop.'
def excluded(self, filename): DCNL 'Check if options.exclude contains a pattern that matches filename.'
def input_dir(self, dirname): DCNL 'Check all files in this directory and all subdirectories.'
def nova_todo_format(physical_line, tokens): DCNL 'Check for \'TODO()\'. DCNL nova HACKING guide recommendation for TODO: DCNL Include your name with TODOs as in "#TODO(termie)" DCNL Okay: #TODO(sdague) DCNL N101: #TODO fail DCNL N101: #TODO (jogo) fail'
def nova_except_format(logical_line): DCNL 'Check for \'except:\'. DCNL nova HACKING guide recommends not using except: DCNL Do not write "except:", use "except Exception:" at the very least DCNL Okay: except Exception: DCNL N201: except:'
def nova_except_format_assert(logical_line): DCNL 'Check for \'assertRaises(Exception\'. DCNL nova HACKING guide recommends not using assertRaises(Exception...): DCNL Do not use overly broad Exception type DCNL Okay: self.assertRaises(NovaException) DCNL N202: self.assertRaises(Exception)'
def nova_import_rules(logical_line): DCNL 'Check for imports. DCNL nova HACKING guide recommends one import per line: DCNL Do not import more than one module per line DCNL Examples: DCNL Okay: from nova.compute import api DCNL N301: from nova.compute import api, utils DCNL Imports should usually be on separate lines. DCNL nova HACKING guide recommends importing only modules: DCNL Do not import objects, only modules DCNL Examples: DCNL Okay: from os import path DCNL Okay: from os import path as p DCNL Okay: from os import (path as p) DCNL Okay: import os.path DCNL Okay: from nova.compute import rpcapi DCNL N302: from os.path import dirname as dirname2 DCNL N302: from os.path import (dirname as dirname2) DCNL N303: from os.path import * DCNL N304: from .compute import rpcapi'
def nova_import_alphabetical(logical_line, blank_lines, previous_logical, indent_level, previous_indent_level): DCNL 'Check for imports in alphabetical order. DCNL nova HACKING guide recommendation for imports: DCNL imports in human alphabetical order DCNL Okay: import os\nimport sys\n\nimport nova\nfrom nova import test DCNL N306: import sys\nimport os'
def nova_import_no_db_in_virt(logical_line, filename): DCNL 'Check for db calls from nova/virt DCNL As of grizzly-2 all the database calls have been removed from DCNL nova/virt, and we want to keep it that way. DCNL N307'
def is_docstring(physical_line, previous_logical): DCNL 'Return True if found docstring DCNL \'A docstring is a string literal that occurs as the first statement in a DCNL module, function, class,\' DCNL http://www.python.org/dev/peps/pep-0257/#what-is-a-docstring'
def nova_docstring_start_space(physical_line, previous_logical): DCNL 'Check for docstring not start with space. DCNL nova HACKING guide recommendation for docstring: DCNL Docstring should not start with space DCNL Okay: def foo():\n    \'\'\'This is good.\'\'\' DCNL Okay: def foo():\n    a = \'\'\' This is not a docstring.\'\'\' DCNL Okay: def foo():\n    pass\n    \'\'\' This is not.\'\'\' DCNL N401: def foo():\n    \'\'\' This is not.\'\'\''
def nova_docstring_one_line(physical_line, previous_logical): DCNL 'Check one line docstring end. DCNL nova HACKING guide recommendation for one line docstring: DCNL A one line docstring looks like this and ends in punctuation. DCNL Okay: def foo():\n    \'\'\'This is good.\'\'\' DCNL Okay: def foo():\n    \'\'\'This is good too!\'\'\' DCNL Okay: def foo():\n    \'\'\'How about this?\'\'\' DCNL Okay: def foo():\n    a = \'\'\'This is not a docstring\'\'\' DCNL Okay: def foo():\n    pass\n    \'\'\'This is not a docstring\'\'\' DCNL Okay: class Foo:\n    pass\n    \'\'\'This is not a docstring\'\'\' DCNL N402: def foo():\n    \'\'\'This is not\'\'\' DCNL N402: def foo():\n    \'\'\'Bad punctuation,\'\'\' DCNL N402: class Foo:\n    \'\'\'Bad punctuation,\'\'\''
def nova_docstring_multiline_end(physical_line, previous_logical, tokens): DCNL 'Check multi line docstring end. DCNL nova HACKING guide recommendation for docstring: DCNL Docstring should end on a new line DCNL Okay: \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: def foo():\n    \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: class Foo:\n    \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: def foo():\n    a = \'\'\'not\na\ndocstring\'\'\' DCNL Okay: def foo():\n    pass\n\'\'\'foobar\nfoo\nbar\n   d\'\'\' DCNL N403: def foo():\n    \'\'\'foobar\nfoo\nbar\ndocstring\'\'\' DCNL N403: class Foo:\n    \'\'\'foobar\nfoo\nbar\ndocstring\'\'\'\n\n'
def nova_docstring_multiline_start(physical_line, previous_logical, tokens): DCNL 'Check multi line docstring start with summary. DCNL nova HACKING guide recommendation for docstring: DCNL Docstring should start with A multi line docstring has a one-line summary DCNL Okay: \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: def foo():\n    a = \'\'\'\nnot\na docstring\n\'\'\' DCNL N404: def foo():\n\'\'\'\nfoo\nbar\n\'\'\'\n\n'
def nova_no_cr(physical_line): DCNL 'Check that we only use newlines not carriage returns. DCNL Okay: import os\nimport sys DCNL # pep8 doesn\'t yet replace \r in strings, will work on an DCNL # upstream fix DCNL N901 import os\r\nimport sys'
def check_i18n(): DCNL 'Generator that checks token stream for localization errors. DCNL Expects tokens to be ``send``ed one by one. DCNL Raises LocalizationError if some error is found.'
def nova_localization_strings(logical_line, tokens): DCNL 'Check localization in line. DCNL Okay: _("This is fine") DCNL Okay: _("This is also fine %s") DCNL N701: _(\'\') DCNL N702: _("Bob" + " foo") DCNL N702: _("Bob %s" % foo) DCNL # N703 check is not quite right, disabled by removing colon DCNL N703 _("%s %s" % (foo, bar))'
def nova_is_not(logical_line): DCNL 'Check localization in line. DCNL Okay: if x is not y DCNL N901: if not X is Y DCNL N901: if not X.B is Y'
def nova_not_in(logical_line): DCNL 'Check localization in line. DCNL Okay: if x not in y DCNL Okay: if not (X in Y or X is Z) DCNL Okay: if not (X in Y) DCNL N902: if not X in Y DCNL N902: if not X.B in Y'
def readlines(filename): DCNL 'Record the current file being tested.'
def add_nova(): DCNL 'Monkey patch in nova guidelines. DCNL Look for functions that start with nova_  and have arguments DCNL and add them to pep8 module DCNL Assumes you know how to write pep8.py checks'
def once_git_check_commit_title(): DCNL 'Check git commit messages. DCNL nova HACKING recommends not referencing a bug or blueprint in first line, DCNL it should provide an accurate description of the change DCNL N801 DCNL N802 Title limited to 72 chars'
def get_availability_zones(context): DCNL 'Return available and unavailable zones.'
def _cleanse_dict(original): DCNL 'Strip all admin_password, new_pass, rescue_pass keys from a dict.'
def wrap_exception(notifier=None, publisher_id=None, event_type=None, level=None): DCNL 'This decorator wraps a method to catch any exceptions that may DCNL get thrown. It logs the exception as well as optionally sending DCNL it to the notification system.'
def validate_url_path(val): DCNL 'True if val is matched by the path component grammar in rfc3986.'
def validate_user_data(user_data): DCNL 'Check if the user_data is encoded properly.'
def validate(args, validator): DCNL 'Validate values of args against validators in validator. DCNL :param args:      Dict of values to be validated. DCNL :param validator: A dict where the keys map to keys in args DCNL and the values are validators. DCNL Applies each validator to ``args[key]`` DCNL :returns: True if validation succeeds. Otherwise False. DCNL A validator should be a callable which accepts 1 argument and which DCNL returns True if the argument passes validation. False otherwise. DCNL A validator should not raise an exception to indicate validity of the DCNL argument. DCNL Only validates keys which show up in both args and validator.'
def convert_password(context, password): DCNL 'Stores password as system_metadata items. DCNL Password is stored with the keys \'password_0\' -> \'password_3\'.'
def image_type(image_type): DCNL 'Converts to a three letter image type. DCNL aki, kernel => aki DCNL ari, ramdisk => ari DCNL anything else => ami'
@memoize DCNL def id_to_glance_id(context, image_id): DCNL 'Convert an internal (db) id to a glance id.'
@memoize DCNL def glance_id_to_id(context, glance_id): DCNL 'Convert a glance id to an internal (db) id.'
def ec2_id_to_id(ec2_id): DCNL 'Convert an ec2 ID (i-[base 16 number]) to an instance id (int).'
def image_ec2_id(image_id, image_type='ami'): DCNL 'Returns image ec2_id using id and three letter type.'
def get_ip_info_for_instance(context, instance): DCNL 'Return a dictionary of IP information for an instance.'
def id_to_ec2_id(instance_id, template='i-%08x'): DCNL 'Convert an instance ID (int) to an ec2 ID (i-[base 16 number]).'
def id_to_ec2_inst_id(instance_id): DCNL 'Get or create an ec2 instance ID (i-[base 16 number]) from uuid.'
def ec2_inst_id_to_uuid(context, ec2_id): DCNL '"Convert an instance id to uuid.'
def id_to_ec2_snap_id(snapshot_id): DCNL 'Get or create an ec2 volume ID (vol-[base 16 number]) from uuid.'
def id_to_ec2_vol_id(volume_id): DCNL 'Get or create an ec2 volume ID (vol-[base 16 number]) from uuid.'
def ec2_vol_id_to_uuid(ec2_id): DCNL 'Get the corresponding UUID for the given ec2-id.'
def is_ec2_timestamp_expired(request, expires=None): DCNL 'Checks the timestamp or expiry time included in an EC2 request DCNL and returns true if the request is expired'
def ec2_snap_id_to_uuid(ec2_id): DCNL 'Get the corresponding UUID for the given ec2-id.'
def _try_convert(value): DCNL 'Return a non-string from a string or unicode, if possible. DCNL When value is returns DCNL zero-length   \'\' DCNL \'None\'        None DCNL \'True\'        True case insensitive DCNL \'False\'       False case insensitive DCNL \'0\', \'-0\'     0 DCNL 0xN, -0xN     int from hex (positive) (N is any number) DCNL 0bN, -0bN     int from binary (positive) (N is any number) DCNL *             try conversion to int, float, complex, fallback value'
def dict_from_dotted_str(items): DCNL 'parse multi dot-separated argument into dict. DCNL EBS boot uses multi dot-separated arguments like DCNL BlockDeviceMapping.1.DeviceName=snap-id DCNL Convert the above into DCNL {\'block_device_mapping\': {\'1\': {\'device_name\': snap-id}}}'
def ec2_error(req, request_id, code, message): DCNL 'Helper to send an ec2_compatible error.'
def _state_description(vm_state, _shutdown_terminate): DCNL 'Map the vm state to the server status string.'
def _parse_block_device_mapping(bdm): DCNL 'Parse BlockDeviceMappingItemType into flat hash DCNL BlockDevicedMapping.<N>.DeviceName DCNL BlockDevicedMapping.<N>.Ebs.SnapshotId DCNL BlockDevicedMapping.<N>.Ebs.VolumeSize DCNL BlockDevicedMapping.<N>.Ebs.DeleteOnTermination DCNL BlockDevicedMapping.<N>.Ebs.NoDevice DCNL BlockDevicedMapping.<N>.VirtualName DCNL => remove .Ebs and allow volume id in SnapshotId'
def _format_block_device_mapping(bdm): DCNL 'Construct BlockDeviceMappingItemType DCNL {\'device_name\': \'...\', \'snapshot_id\': , ...} DCNL => BlockDeviceMappingItemType'
def _format_mappings(properties, result): DCNL 'Format multiple BlockDeviceMappingItemType.'
def _database_to_isoformat(datetimeobj): DCNL 'Return a xs:dateTime parsable string from datatime.'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'A paste pipeline replica that keys off of auth_strategy.'
def wrap_errors(fn): DCNL 'Ensure errors are not passed along.'
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL 'Registers all standard API extensions.'
def status_from_state(vm_state, task_state='default'): DCNL 'Given vm_state and task_state, return a status string.'
def vm_state_from_status(status): DCNL 'Map the server status string to a vm state.'
def get_pagination_params(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specified, 0, or DCNL > max_limit, we default to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBadRequest() exceptions to be raised.'
def _get_limit_param(request): DCNL 'Extract integer limit from request or fail.'
def _get_marker_param(request): DCNL 'Extract marker id from request or fail.'
def limited(items, request, max_limit=CONF.osapi_max_limit): DCNL 'Return a slice of items according to requested offset and limit. DCNL :param items: A sliceable entity DCNL :param request: ``wsgi.Request`` possibly containing \'offset\' and \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL and \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specified, 0, or > max_limit, we default DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBadRequest() exceptions to be raised. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''
def get_limit_and_marker(request, max_limit=CONF.osapi_max_limit): DCNL 'get limited parameter from request.'
def limited_by_marker(items, request, max_limit=CONF.osapi_max_limit): DCNL 'Return a slice of items according to the requested marker and limit.'
def get_id_from_href(href): DCNL 'Return the id or uuid portion of a url. DCNL Given: \'http://www.foo.com/bar/123?q=4\' DCNL Returns: \'123\' DCNL Given: \'http://www.foo.com/bar/abc123?q=4\' DCNL Returns: \'abc123\''
def remove_version_from_href(href): DCNL 'Removes the first api version from the href. DCNL Given: \'http://www.nova.com/v1.1/123\' DCNL Returns: \'http://www.nova.com/123\' DCNL Given: \'http://www.nova.com/v1.1\' DCNL Returns: \'http://www.nova.com\''
def get_networks_for_instance(context, instance): DCNL 'Returns a prepared nw_info list for passing into the view builders DCNL We end up with a data structure like:: DCNL {\'public\': {\'ips\': [{\'addr\': \'10.0.0.1\', \'version\': 4}, DCNL {\'addr\': \'2001::1\', \'version\': 6}], DCNL \'floating_ips\': [{\'addr\': \'172.16.0.1\', \'version\': 4}, DCNL {\'addr\': \'172.16.2.1\', \'version\': 4}]},'
def raise_http_conflict_for_instance_invalid_state(exc, action): DCNL 'Return a webob.exc.HTTPConflict instance containing a message DCNL appropriate to return via the API based on the original DCNL InstanceInvalidState exception.'
def get_items(obj): DCNL 'Get items in obj.'
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Create a template element as a child of another. DCNL Corresponds to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the addition of the parent.'
def make_links(parent, selector=None): DCNL 'Attach an Atom <links> element to the parent.'
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL 'Utility for simple XML templates that traditionally used DCNL XMLDictSerializer with no metadata.  Returns a template element DCNL where the top-level element has the given tag name, and where DCNL sub-elements have tag names derived from the object\'s keys and DCNL text derived from the object\'s values.  This only works for flat DCNL dictionary objects, not dictionaries containing nested lists or DCNL dictionaries.'
def safe_minidom_parse_string(xml_string): DCNL 'Parse an XML string using minidom safely.'
def serializers(**serializers): DCNL 'Attaches serializers to a method. DCNL This decorator associates a dictionary of serializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def deserializers(**deserializers): DCNL 'Attaches deserializers to a method. DCNL This decorator associates a dictionary of deserializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def response(code): DCNL 'Attaches response code to a method. DCNL This decorator associates a response code with a method.  Note DCNL that the function attributes are directly manipulated; the method DCNL is not wrapped.'
def action_peek_json(body): DCNL 'Determine action to invoke.'
def action_peek_xml(body): DCNL 'Determine action to invoke.'
def action(name): DCNL 'Mark a function as an action. DCNL The given name will be taken as the action key in the body. DCNL This is also overloaded to allow extensions to provide DCNL non-extending definitions of create and delete operations.'
def extends(*args, **kwargs): DCNL 'Indicate a function extends an operation. DCNL Can be used as either:: DCNL @extends DCNL def index(...): DCNL pass DCNL or as:: DCNL @extends(action=\'resize\') DCNL def _action_resize(...): DCNL pass'
def unquote_header_value(value): DCNL 'Unquotes a header value. DCNL This does not use the real unquoting but what browsers are actually DCNL using for quoting. DCNL :param value: the header value to unquote.'
def parse_list_header(value): DCNL 'Parse lists as described by RFC 2068 Section 2. DCNL In particular, parse comma-separated lists where the elements of DCNL the list may include quoted-strings.  A quoted-string could DCNL contain a comma.  A non-quoted string could have quotes in the DCNL middle.  Quotes are removed automatically after parsing. DCNL The return value is a standard :class:`list`: DCNL >>> parse_list_header(\'token, "quoted value"\') DCNL [\'token\', \'quoted value\'] DCNL :param value: a string with a list header. DCNL :return: :class:`list`'
def parse_options_header(value): DCNL 'Parse a ``Content-Type`` like header into a tuple with the content DCNL type and the options: DCNL >>> parse_options_header(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the header to parse. DCNL :return: (str, options)'
def _translate_keys(cons): DCNL 'Coerces a console instance into proper dictionary format.'
def _translate_detail_keys(cons): DCNL 'Coerces a console instance into proper dictionary format with DCNL correctly mapped attributes'
def _translate_volume_detail_view(context, vol): DCNL 'Maps keys for volumes details view.'
def _translate_volume_summary_view(context, vol): DCNL 'Maps keys for volumes summary view.'
def _translate_attachment_detail_view(volume_id, instance_uuid, mountpoint): DCNL 'Maps keys for attachment details view.'
def _translate_attachment_summary_view(volume_id, instance_uuid, mountpoint): DCNL 'Maps keys for attachment summary view.'
def _translate_snapshot_detail_view(context, vol): DCNL 'Maps keys for snapshots details view.'
def _translate_snapshot_summary_view(context, vol): DCNL 'Maps keys for snapshots summary view.'
def _translate_interface_attachment_view(port_info): DCNL 'Maps keys for interface attachment details view.'
def _filter_keys(item, keys): DCNL 'Filters all model attributes except for keys DCNL item is a dict'
def get_host_from_body(fn): DCNL 'Makes sure that the host exists.'
def _translate_vif_summary_view(_context, vif): DCNL 'Maps keys for VIF summary view.'
def _unquote_domain(domain): DCNL 'Unquoting function for receiving a domain name in a URL. DCNL Domain names tend to have .\'s in them.  Urllib doesn\'t quote dots, DCNL but Routes tends to choke on them, so we need an extra level of DCNL by-hand quoting here.'
def remove_invalid_options(context, search_options, allowed_search_options): DCNL 'Remove search options that are not valid for non-admin API/context.'
def drop_unique_constraint(migrate_engine, table_name, uc_name, *columns, **col_name_col_instance): DCNL 'This method drops UC from table and works for mysql, postgresql and sqlite. DCNL In mysql and postgresql we are able to use "alter table" constuction. In DCNL sqlite is only one way to drop UC: DCNL 1) Create new table with same columns, indexes and constraints DCNL (except one that we want to drop). DCNL 2) Copy data from old table to new. DCNL 3) Drop old table. DCNL 4) Rename new table to the name of old table. DCNL :param migrate_engine: sqlalchemy engine DCNL :param table_name:     name of table that contains uniq constarint. DCNL :param uc_name:        name of uniq constraint that will be dropped. DCNL :param columns:        columns that are in uniq constarint. DCNL :param col_name_col_instance:   contains pair column_name=column_instance. DCNL column_instance is instance of Column. These params DCNL are required only for columns that have unsupported DCNL types by sqlite. For example BigInteger.'
def drop_old_duplicate_entries_from_table(migrate_engine, table_name, use_soft_delete, *uc_column_names): DCNL 'This method is used to drop all old rows that have the same values for DCNL columns in uc_columns.'
def upgrade(migrate_engine): DCNL 'Convert String columns holding IP addresses to INET for postgresql.'
def downgrade(migrate_engine): DCNL 'Convert columns back to the larger String(255).'
def _drop_index(engine, table, idx_name): DCNL 'Drop index from DB and remove index from SQLAlchemy table metadata. DCNL idx.drop() in SQLAlchemy will issue a DROP INDEX statement to the DB but DCNL WILL NOT update the table metadata to remove the `Index` object. DCNL This can cause subsequent drop column calls on a related column to fail DCNL because `drop_column` will see an `Index` object that isn\'t there, thus DCNL issuing an erroneous second DROP INDEX call. DCNL The solution is to update the table metadata to reflect the now dropped DCNL column.'
def _map_nodes(meta): DCNL 'Map host to compute node(s) for the purpose of determining which hosts DCNL are single vs multi-node.'
def _update_nodes(nodemap, instances, migrations): DCNL 'For each migration and matching instance record, update the node columns DCNL if the referenced host is single-node. DCNL Skip updates for multi-node hosts.  In that case, there\'s no way to DCNL determine which node on a host the record should be associated with.'
def downgrade(migrate_engine): DCNL 'Convert columns back to the larger String(43) defined in version 149.'
def upgrade(migrate_engine): DCNL 'Convert String columns holding IP addresses to INET for postgresql.'
def downgrade(migrate_engine): DCNL 'Convert columns back to the larger String(255).'
def upgrade(migrate_engine): DCNL 'Convert period_beginning and period_ending to DateTime.'
def downgrade(migrate_engine): DCNL 'Convert columns back to String(255).'
def get_backend(): DCNL 'The backend is this module itself.'
def require_admin_context(f): DCNL 'Decorator to require admin request context. DCNL The first argument to the wrapped function must be the context.'
def require_context(f): DCNL 'Decorator to require *any* user or admin context. DCNL This does no authorization for user or project access matching, see DCNL :py:func:`nova.context.authorize_project_context` and DCNL :py:func:`nova.context.authorize_user_context`. DCNL The first argument to the wrapped function must be the context.'
def require_instance_exists_using_uuid(f): DCNL 'Decorator to require the specified instance to exist. DCNL Requires the wrapped function to use context and instance_uuid as DCNL their first two arguments.'
def require_aggregate_exists(f): DCNL 'Decorator to require the specified aggregate to exist. DCNL Requires the wrapped function to use context and aggregate_id as DCNL their first two arguments.'
def _retry_on_deadlock(f): DCNL 'Decorator to retry a DB API call if Deadlock was received.'
def model_query(context, model, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id. If set to \'allow_none\', DCNL restriction includes project_id = None. DCNL :param base_model: Where model_query is passed a "model" parameter which is DCNL not a subclass of NovaBase, we should pass an extra base_model DCNL parameter that is a subclass of NovaBase and corresponds to the DCNL model parameter.'
def exact_filter(query, model, filters, legal_keys): DCNL 'Applies exact match filtering to a query. DCNL Returns the updated query.  Modifies filters argument to remove DCNL filters consumed. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to, for IN-style DCNL filtering DCNL :param filters: dictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performed, while exact matching (\'==\' operator) DCNL is used for other values DCNL :param legal_keys: list of keys to apply exact filtering to'
def _prep_stats_dict(values): DCNL 'Make list of ComputeNodeStats.'
@require_admin_context DCNL def compute_node_create(context, values): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
@require_admin_context DCNL def compute_node_update(context, compute_id, values, prune_stats=False): DCNL 'Updates the ComputeNode record with the most recent data.'
@require_admin_context DCNL def compute_node_delete(context, compute_id): DCNL 'Delete a ComputeNode record.'
def compute_node_statistics(context): DCNL 'Compute statistics over all compute nodes.'
def _ip_range_splitter(ips, block_size=256): DCNL 'Yields blocks of IPs no more than block_size elements long.'
@require_admin_context DCNL def fixed_ip_associate(context, address, instance_uuid, network_id=None, reserved=False): DCNL 'Keyword arguments: DCNL reserved -- should be a boolean value(True or False), exact value will be DCNL used to filter on the fixed ip address'
@require_admin_context DCNL def fixed_ip_get_by_address_detailed(context, address, session=None): DCNL ':returns: a tuple of (models.FixedIp, models.Network, models.Instance)'
@require_context DCNL def virtual_interface_create(context, values): DCNL 'Create a new virtual interface record in the database. DCNL :param values: = dict containing column values'
@require_context DCNL def virtual_interface_get(context, vif_id): DCNL 'Gets a virtual interface from the table. DCNL :param vif_id: = id of the virtual interface'
@require_context DCNL def virtual_interface_get_by_address(context, address): DCNL 'Gets a virtual interface from the table. DCNL :param address: = the address of the interface you\'re looking to get'
@require_context DCNL def virtual_interface_get_by_uuid(context, vif_uuid): DCNL 'Gets a virtual interface from the table. DCNL :param vif_uuid: the uuid of the interface you\'re looking to get'
@require_context DCNL @require_instance_exists_using_uuid DCNL def virtual_interface_get_by_instance(context, instance_uuid): DCNL 'Gets all virtual interfaces for instance. DCNL :param instance_uuid: = uuid of the instance to retrieve vifs for'
@require_context DCNL def virtual_interface_get_by_instance_and_network(context, instance_uuid, network_id): DCNL 'Gets virtual interface for instance that\'s associated with network.'
@require_context DCNL def virtual_interface_delete_by_instance(context, instance_uuid): DCNL 'Delete virtual interface records that are associated DCNL with the instance given by instance_id. DCNL :param instance_uuid: = uuid of instance'
@require_context DCNL def virtual_interface_get_all(context): DCNL 'Get all vifs.'
@require_context DCNL def instance_create(context, values): DCNL 'Create a new Instance record in the database. DCNL context - request context object DCNL values - dict containing column values.'
def _instances_fill_metadata(context, instances, manual_joins=None): DCNL 'Selectively fill instances with manually-joined metadata. Note that DCNL instance will be converted to a dict. DCNL :param context: security context DCNL :param instances: list of instances to fill DCNL :param manual_joins: list of tables to manually join (can be any DCNL combination of \'metadata\' and \'system_metadata\' or DCNL None to take the default of both)'
@require_context DCNL def instance_get_all_by_filters(context, filters, sort_key, sort_dir, limit=None, marker=None, columns_to_join=None, session=None): DCNL 'Return instances that match all filters.  Deleted instances DCNL will be returned by default, unless there\'s a filter that says DCNL otherwise'
def regex_filter(query, model, filters): DCNL 'Applies regular expression filtering to a query. DCNL Returns the updated query. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to DCNL :param filters: dictionary of filters with regex values'
@require_context DCNL def instance_get_active_by_window_joined(context, begin, end=None, project_id=None, host=None): DCNL 'Return instances and joins that were active during window.'
@require_admin_context DCNL def _instance_get_all_uuids_by_host(context, host, session=None): DCNL 'Return a list of the instance uuids on a given host. DCNL Returns a list of UUIDs, not Instance model objects. This internal version DCNL allows you to specify a session object as a kwarg.'
@require_context DCNL def instance_update_and_get_original(context, instance_uuid, values): DCNL 'Set the given properties on an instance and update it. Return DCNL a shallow copy of the original instance reference, as well as the DCNL updated one. DCNL :param context: = request context object DCNL :param instance_uuid: = instance uuid DCNL :param values: = dict containing column values DCNL If "expected_task_state" exists in values, the update can only happen DCNL when the task state before update matches expected_task_state. Otherwise DCNL a UnexpectedTaskStateError is thrown. DCNL :returns: a tuple of the form (old_instance_ref, new_instance_ref) DCNL Raises NotFound if instance does not exist.'
def instance_add_security_group(context, instance_uuid, security_group_id): DCNL 'Associate the given security group with the given instance.'
@require_context DCNL def instance_remove_security_group(context, instance_uuid, security_group_id): DCNL 'Disassociate the given security group from the given instance.'
@require_context DCNL def instance_info_cache_get(context, instance_uuid): DCNL 'Gets an instance info cache from the table. DCNL :param instance_uuid: = uuid of the info cache\'s instance DCNL :param session: = optional session object'
@require_context DCNL def instance_info_cache_update(context, instance_uuid, values): DCNL 'Update an instance info cache record in the table. DCNL :param instance_uuid: = uuid of info cache\'s instance DCNL :param values: = dict containing column values to update DCNL :param session: = optional session object'
@require_context DCNL def instance_info_cache_delete(context, instance_uuid): DCNL 'Deletes an existing instance_info_cache record DCNL :param instance_uuid: = uuid of the instance tied to the cache record DCNL :param session: = optional session object'
@require_admin_context DCNL def network_associate(context, project_id, network_id=None, force=False): DCNL 'Associate a project with a network. DCNL called by project_get_networks under certain conditions DCNL and network manager add_network_to_project() DCNL only associate if the project doesn\'t already have a network DCNL or if force is True DCNL force solves race condition where a fresh project has multiple instance DCNL builds simultaneously picked up by multiple network hosts which attempt DCNL to associate the project with multiple networks DCNL force should only be used as a direct consequence of user request DCNL all automated requests should not use force'
def _quota_reservations_query(session, context, reservations): DCNL 'Return the relevant reservations.'
@require_context DCNL def ec2_volume_create(context, volume_uuid, id=None): DCNL 'Create ec2 compatible volume by provided uuid.'
@require_context DCNL def ec2_snapshot_create(context, snapshot_uuid, id=None): DCNL 'Create ec2 compatible snapshot by provided uuid.'
def _security_group_get_by_names(context, session, project_id, group_names): DCNL 'Get security group models for a project by a list of names. DCNL Raise SecurityGroupNotFoundForProject for a name not found.'
def security_group_ensure_default(context, session=None): DCNL 'Ensure default security group exists for a project_id. DCNL Returns a tuple with the first element being a bool indicating DCNL if the default security group previously existed. Second DCNL element is the dict used to create the default security group.'
@require_admin_context DCNL def instance_type_create(context, values): DCNL 'Create a new instance type. In order to pass in extra specs, DCNL the values dict should contain a \'extra_specs\' key/value pair: DCNL {\'extra_specs\' : {\'k1\': \'v1\', \'k2\': \'v2\', ...}}'
def _dict_with_extra_specs(inst_type_query): DCNL 'Takes an instance or instance type query returned DCNL by sqlalchemy and returns it as a dictionary, converting the DCNL extra_specs entry from a list of dicts: DCNL \'extra_specs\' : [{\'key\': \'k1\', \'value\': \'v1\', ...}, ...] DCNL to a single dict: DCNL \'extra_specs\' : {\'k1\': \'v1\'}'
@require_context DCNL def instance_type_get_all(context, inactive=False, filters=None): DCNL 'Returns all instance types.'
@require_context DCNL def instance_type_get(context, id, session=None): DCNL 'Returns a dict describing specific instance_type.'
@require_context DCNL def instance_type_get_by_name(context, name, session=None): DCNL 'Returns a dict describing specific instance_type.'
@require_context DCNL def instance_type_get_by_flavor_id(context, flavor_id, session=None): DCNL 'Returns a dict describing specific flavor_id.'
@require_admin_context DCNL def instance_type_destroy(context, name): DCNL 'Marks specific instance_type as deleted.'
@require_admin_context DCNL def instance_type_access_get_by_flavor_id(context, flavor_id): DCNL 'Get flavor access list by flavor id.'
@require_admin_context DCNL def instance_type_access_add(context, flavor_id, project_id): DCNL 'Add given tenant to the flavor access list.'
@require_admin_context DCNL def instance_type_access_remove(context, flavor_id, project_id): DCNL 'Remove given tenant from the flavor access list.'
@require_context DCNL def vol_get_usage_by_time(context, begin): DCNL 'Return volumes usage that have been updated after a specified time.'
def s3_image_get(context, image_id): DCNL 'Find local s3 image represented by the provided id.'
def s3_image_get_by_uuid(context, image_uuid): DCNL 'Find local s3 image represented by the provided uuid.'
def s3_image_create(context, image_uuid): DCNL 'Create local s3 image represented by provided uuid.'
def instance_fault_create(context, values): DCNL 'Create a new InstanceFault.'
def instance_fault_get_by_instance_uuids(context, instance_uuids): DCNL 'Get all instance faults for the provided instance_uuids.'
def actions_get(context, instance_uuid): DCNL 'Get all instance actions for the provided uuid.'
def action_get_by_request_id(context, instance_uuid, request_id): DCNL 'Get the action by request_id and given instance.'
def action_event_start(context, values): DCNL 'Start an event on an instance action.'
def action_event_finish(context, values): DCNL 'Finish an event on an instance action.'
@require_context DCNL def ec2_instance_create(context, instance_uuid, id=None): DCNL 'Create ec2 compatible instance by provided uuid.'
@require_admin_context DCNL def archive_deleted_rows_for_table(context, tablename, max_rows): DCNL 'Move up to max_rows rows from one tables to the corresponding DCNL shadow table. DCNL :returns: number of rows archived'
@require_admin_context DCNL def archive_deleted_rows(context, max_rows=None): DCNL 'Move up to max_rows rows from production tables to the corresponding DCNL shadow tables. DCNL :returns: Number of rows archived.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def constraint(**conditions): DCNL 'Return a constraint object suitable for use with some updates.'
def equal_any(*values): DCNL 'Return an equality condition object suitable for use in a constraint. DCNL Equal_any conditions require that a model object\'s attribute equal any DCNL one of the given values.'
def not_equal(*values): DCNL 'Return an inequality condition object suitable for use in a constraint. DCNL Not_equal conditions require that a model object\'s attribute differs from DCNL all of the given values.'
def service_destroy(context, instance_id): DCNL 'Destroy the service or raise if it does not exist.'
def service_get(context, service_id): DCNL 'Get a service or raise if it does not exist.'
def service_get_by_host_and_topic(context, host, topic): DCNL 'Get a service by host it\'s on and topic it listens to.'
def service_get_all(context, disabled=None): DCNL 'Get all services.'
def service_get_all_by_topic(context, topic): DCNL 'Get all services for a given topic.'
def service_get_all_by_host(context, host): DCNL 'Get all services for a given host.'
def service_get_by_compute_host(context, host): DCNL 'Get the service entry for a given compute host. DCNL Returns the service entry joined with the compute_node entry.'
def service_get_by_args(context, host, binary): DCNL 'Get the state of a service by node name and binary.'
def service_create(context, values): DCNL 'Create a service from the values dictionary.'
def service_update(context, service_id, values): DCNL 'Set the given properties on a service and update it. DCNL Raises NotFound if service does not exist.'
def compute_node_get(context, compute_id): DCNL 'Get a computeNode.'
def compute_node_get_all(context): DCNL 'Get all computeNodes.'
def compute_node_search_by_hypervisor(context, hypervisor_match): DCNL 'Get computeNodes given a hypervisor hostname match string.'
def compute_node_create(context, values): DCNL 'Create a computeNode from the values dictionary.'
def compute_node_update(context, compute_id, values, prune_stats=False): DCNL 'Set the given properties on a computeNode and update it. DCNL Raises ComputeHostNotFound if computeNode does not exist.'
def compute_node_delete(context, compute_id): DCNL 'Delete a computeNode from the database. DCNL Raises ComputeHostNotFound if computeNode does not exist.'
def certificate_create(context, values): DCNL 'Create a certificate from the values dictionary.'
def certificate_get_all_by_project(context, project_id): DCNL 'Get all certificates for a project.'
def certificate_get_all_by_user(context, user_id): DCNL 'Get all certificates for a user.'
def certificate_get_all_by_user_and_project(context, user_id, project_id): DCNL 'Get all certificates for a user and project.'
def floating_ip_get_pools(context): DCNL 'Returns a list of floating ip pools.'
def floating_ip_allocate_address(context, project_id, pool): DCNL 'Allocate free floating ip from specified pool and return the address. DCNL Raises if one is not available.'
def floating_ip_bulk_create(context, ips): DCNL 'Create a lot of floating ips from the values dictionary.'
def floating_ip_bulk_destroy(context, ips): DCNL 'Destroy a lot of floating ips from the values dictionary.'
def floating_ip_create(context, values): DCNL 'Create a floating ip from the values dictionary.'
def floating_ip_count_by_project(context, project_id, session=None): DCNL 'Count floating ips used by project.'
def floating_ip_deallocate(context, address): DCNL 'Deallocate a floating ip by address.'
def floating_ip_destroy(context, address): DCNL 'Destroy the floating_ip or raise if it does not exist.'
def floating_ip_disassociate(context, address): DCNL 'Disassociate a floating ip from a fixed ip by address. DCNL :returns: the fixed ip record joined to network record or None DCNL if the ip was not associated to an ip.'
def floating_ip_fixed_ip_associate(context, floating_address, fixed_address, host): DCNL 'Associate a floating ip to a fixed_ip by address. DCNL :returns: the fixed ip record joined to network record or None DCNL if the ip was already associated to the fixed ip.'
def floating_ip_get_all(context): DCNL 'Get all floating ips.'
def floating_ip_get_all_by_host(context, host): DCNL 'Get all floating ips by host.'
def floating_ip_get_all_by_project(context, project_id): DCNL 'Get all floating ips by project.'
def floating_ip_get_by_address(context, address): DCNL 'Get a floating ip by address or raise if it doesn\'t exist.'
def floating_ip_get_by_fixed_address(context, fixed_address): DCNL 'Get a floating ips by fixed address.'
def floating_ip_get_by_fixed_ip_id(context, fixed_ip_id): DCNL 'Get a floating ips by fixed address.'
def floating_ip_update(context, address, values): DCNL 'Update a floating ip by address or raise if it doesn\'t exist.'
def floating_ip_set_auto_assigned(context, address): DCNL 'Set auto_assigned flag to floating ip.'
def dnsdomain_list(context): DCNL 'Get a list of all zones in our database, public and private.'
def dnsdomain_register_for_zone(context, fqdomain, zone): DCNL 'Associated a DNS domain with an availability zone.'
def dnsdomain_register_for_project(context, fqdomain, project): DCNL 'Associated a DNS domain with a project id.'
def dnsdomain_unregister(context, fqdomain): DCNL 'Purge associations for the specified DNS zone.'
def dnsdomain_get(context, fqdomain): DCNL 'Get the db record for the specified domain.'
def migration_update(context, id, values): DCNL 'Update a migration instance.'
def migration_create(context, values): DCNL 'Create a migration record.'
def migration_get(context, migration_id): DCNL 'Finds a migration by the id.'
def migration_get_by_instance_and_status(context, instance_uuid, status): DCNL 'Finds a migration by the instance uuid its migrating.'
def migration_get_unconfirmed_by_dest_compute(context, confirm_window, dest_compute): DCNL 'Finds all unconfirmed migrations within the confirmation window for DCNL a specific destination compute host.'
def migration_get_in_progress_by_host_and_node(context, host, node): DCNL 'Finds all migrations for the given host + node  that are not yet DCNL confirmed or reverted.'
def fixed_ip_associate(context, address, instance_uuid, network_id=None, reserved=False): DCNL 'Associate fixed ip to instance. DCNL Raises if fixed ip is not available.'
def fixed_ip_associate_pool(context, network_id, instance_uuid=None, host=None): DCNL 'Find free ip in network and associate it to instance or host. DCNL Raises if one is not available.'
def fixed_ip_create(context, values): DCNL 'Create a fixed ip from the values dictionary.'
def fixed_ip_bulk_create(context, ips): DCNL 'Create a lot of fixed ips from the values dictionary.'
def fixed_ip_disassociate(context, address): DCNL 'Disassociate a fixed ip from an instance by address.'
def fixed_ip_disassociate_all_by_timeout(context, host, time): DCNL 'Disassociate old fixed ips from host.'
def fixed_ip_get(context, id, get_network=False): DCNL 'Get fixed ip by id or raise if it does not exist. DCNL If get_network is true, also return the assocated network.'
def fixed_ip_get_all(context): DCNL 'Get all defined fixed ips.'
def fixed_ip_get_by_address(context, address): DCNL 'Get a fixed ip by address or raise if it does not exist.'
def fixed_ip_get_by_address_detailed(context, address): DCNL 'Get detailed fixed ip info by address or raise if it does not exist.'
def fixed_ip_get_by_floating_address(context, floating_address): DCNL 'Get a fixed ip by a floating address.'
def fixed_ip_get_by_instance(context, instance_uuid): DCNL 'Get fixed ips by instance or raise if none exist.'
def fixed_ip_get_by_host(context, host): DCNL 'Get fixed ips by compute host.'
def fixed_ip_get_by_network_host(context, network_uuid, host): DCNL 'Get fixed ip for a host in a network.'
def fixed_ips_by_virtual_interface(context, vif_id): DCNL 'Get fixed ips by virtual interface or raise if none exist.'
def fixed_ip_update(context, address, values): DCNL 'Create a fixed ip from the values dictionary.'
def fixed_ip_count_by_project(context, project_id, session=None): DCNL 'Count fixed ips used by project.'
def virtual_interface_create(context, values): DCNL 'Create a virtual interface record in the database.'
def virtual_interface_get(context, vif_id): DCNL 'Gets a virtual interface from the table.'
def virtual_interface_get_by_address(context, address): DCNL 'Gets a virtual interface from the table filtering on address.'
def virtual_interface_get_by_uuid(context, vif_uuid): DCNL 'Gets a virtual interface from the table filtering on vif uuid.'
def virtual_interface_get_by_instance(context, instance_id): DCNL 'Gets all virtual_interfaces for instance.'
def virtual_interface_get_by_instance_and_network(context, instance_id, network_id): DCNL 'Gets all virtual interfaces for instance.'
def virtual_interface_delete_by_instance(context, instance_id): DCNL 'Delete virtual interface records associated with instance.'
def virtual_interface_get_all(context): DCNL 'Gets all virtual interfaces from the table.'
def instance_create(context, values): DCNL 'Create an instance from the values dictionary.'
def instance_data_get_for_project(context, project_id, session=None): DCNL 'Get (instance_count, total_cores, total_ram) for project.'
def instance_destroy(context, instance_uuid, constraint=None, update_cells=True): DCNL 'Destroy the instance or raise if it does not exist.'
def instance_get_by_uuid(context, uuid): DCNL 'Get an instance or raise if it does not exist.'
def instance_get(context, instance_id): DCNL 'Get an instance or raise if it does not exist.'
def instance_get_all(context, columns_to_join=None): DCNL 'Get all instances.'
def instance_get_all_by_filters(context, filters, sort_key='created_at', sort_dir='desc', limit=None, marker=None, columns_to_join=None): DCNL 'Get all instances that match all filters.'
def instance_get_active_by_window_joined(context, begin, end=None, project_id=None, host=None): DCNL 'Get instances and joins active during a certain time window. DCNL Specifying a project_id will filter for a certain project. DCNL Specifying a host will filter for instances on a given compute host.'
def instance_get_all_by_host(context, host, columns_to_join=None): DCNL 'Get all instances belonging to a host.'
def instance_get_all_by_host_and_node(context, host, node): DCNL 'Get all instances belonging to a node.'
def instance_get_all_by_host_and_not_type(context, host, type_id=None): DCNL 'Get all instances belonging to a host with a different type_id.'
def instance_get_floating_address(context, instance_id): DCNL 'Get the first floating ip address of an instance.'
def instance_floating_address_get_all(context, instance_uuid): DCNL 'Get all floating ip addresses of an instance.'
def instance_get_all_hung_in_rebooting(context, reboot_window): DCNL 'Get all instances stuck in a rebooting state.'
def instance_test_and_set(context, instance_uuid, attr, ok_states, new_state): DCNL 'Atomically check if an instance is in a valid state, and if it is, set DCNL the instance into a new state.'
def instance_update(context, instance_uuid, values, update_cells=True): DCNL 'Set the given properties on an instance and update it. DCNL Raises NotFound if instance does not exist.'
def instance_update_and_get_original(context, instance_uuid, values): DCNL 'Set the given properties on an instance and update it. Return DCNL a shallow copy of the original instance reference, as well as the DCNL updated one. DCNL :param context: = request context object DCNL :param instance_id: = instance id or uuid DCNL :param values: = dict containing column values DCNL :returns: a tuple of the form (old_instance_ref, new_instance_ref) DCNL Raises NotFound if instance does not exist.'
def instance_add_security_group(context, instance_id, security_group_id): DCNL 'Associate the given security group with the given instance.'
def instance_remove_security_group(context, instance_id, security_group_id): DCNL 'Disassociate the given security group from the given instance.'
def instance_info_cache_get(context, instance_uuid): DCNL 'Gets an instance info cache from the table. DCNL :param instance_uuid: = uuid of the info cache\'s instance'
def instance_info_cache_update(context, instance_uuid, values, update_cells=True): DCNL 'Update an instance info cache record in the table. DCNL :param instance_uuid: = uuid of info cache\'s instance DCNL :param values: = dict containing column values to update'
def instance_info_cache_delete(context, instance_uuid): DCNL 'Deletes an existing instance_info_cache record DCNL :param instance_uuid: = uuid of the instance tied to the cache record'
def key_pair_create(context, values): DCNL 'Create a key_pair from the values dictionary.'
def key_pair_destroy(context, user_id, name): DCNL 'Destroy the key_pair or raise if it does not exist.'
def key_pair_get(context, user_id, name): DCNL 'Get a key_pair or raise if it does not exist.'
def key_pair_get_all_by_user(context, user_id): DCNL 'Get all key_pairs by user.'
def key_pair_count_by_user(context, user_id): DCNL 'Count number of key pairs for the given user ID.'
def network_associate(context, project_id, network_id=None, force=False): DCNL 'Associate a free network to a project.'
def network_count_reserved_ips(context, network_id): DCNL 'Return the number of reserved ips in the network.'
def network_create_safe(context, values): DCNL 'Create a network from the values dict. DCNL The network is only returned if the create succeeds. If the create violates DCNL constraints because the network already exists, no exception is raised.'
def network_delete_safe(context, network_id): DCNL 'Delete network with key network_id. DCNL This method assumes that the network is not associated with any project'
def network_disassociate(context, network_id, disassociate_host=True, disassociate_project=True): DCNL 'Disassociate the network from project or host and raise if it does DCNL not exist.'
def network_get(context, network_id, project_only='allow_none'): DCNL 'Get a network or raise if it does not exist.'
def network_get_all(context): DCNL 'Return all defined networks.'
def network_get_all_by_uuids(context, network_uuids, project_only='allow_none'): DCNL 'Return networks by ids.'
def network_in_use_on_host(context, network_id, host=None): DCNL 'Indicates if a network is currently in use on host.'
def network_get_associated_fixed_ips(context, network_id, host=None): DCNL 'Get all network\'s ips that have been associated.'
def network_get_by_uuid(context, uuid): DCNL 'Get a network by uuid or raise if it does not exist.'
def network_get_by_cidr(context, cidr): DCNL 'Get a network by cidr or raise if it does not exist.'
def network_get_all_by_instance(context, instance_id): DCNL 'Get all networks by instance id or raise if none exist.'
def network_get_all_by_host(context, host): DCNL 'All networks for which the given host is the network host.'
def network_set_host(context, network_id, host_id): DCNL 'Safely set the host for network.'
def network_update(context, network_id, values): DCNL 'Set the given properties on a network and update it. DCNL Raises NotFound if network does not exist.'
def quota_create(context, project_id, resource, limit): DCNL 'Create a quota for the given project and resource.'
def quota_get(context, project_id, resource): DCNL 'Retrieve a quota or raise if it does not exist.'
def quota_get_all_by_project(context, project_id): DCNL 'Retrieve all quotas associated with a given project.'
def quota_update(context, project_id, resource, limit): DCNL 'Update a quota or raise if it does not exist.'
def quota_class_create(context, class_name, resource, limit): DCNL 'Create a quota class for the given name and resource.'
def quota_class_get(context, class_name, resource): DCNL 'Retrieve a quota class or raise if it does not exist.'
def quota_class_get_all_by_name(context, class_name): DCNL 'Retrieve all quotas associated with a given quota class.'
def quota_class_update(context, class_name, resource, limit): DCNL 'Update a quota class or raise if it does not exist.'
def quota_usage_get(context, project_id, resource): DCNL 'Retrieve a quota usage or raise if it does not exist.'
def quota_usage_get_all_by_project(context, project_id): DCNL 'Retrieve all usage associated with a given resource.'
def quota_usage_update(context, project_id, resource, **kwargs): DCNL 'Update a quota usage or raise if it does not exist.'
def reservation_create(context, uuid, usage, project_id, resource, delta, expire): DCNL 'Create a reservation for the given project and resource.'
def reservation_get(context, uuid): DCNL 'Retrieve a reservation or raise if it does not exist.'
def quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=None): DCNL 'Check quotas and create appropriate reservations.'
def reservation_commit(context, reservations, project_id=None): DCNL 'Commit quota reservations.'
def reservation_rollback(context, reservations, project_id=None): DCNL 'Roll back quota reservations.'
def quota_destroy_all_by_project(context, project_id): DCNL 'Destroy all quotas associated with a given project.'
def reservation_expire(context): DCNL 'Roll back any expired reservations.'
def block_device_mapping_create(context, values): DCNL 'Create an entry of block device mapping.'
def block_device_mapping_update(context, bdm_id, values): DCNL 'Update an entry of block device mapping.'
def block_device_mapping_update_or_create(context, values): DCNL 'Update an entry of block device mapping. DCNL If not existed, create a new entry'
def block_device_mapping_get_all_by_instance(context, instance_uuid): DCNL 'Get all block device mapping belonging to an instance.'
def block_device_mapping_destroy(context, bdm_id): DCNL 'Destroy the block device mapping.'
def block_device_mapping_destroy_by_instance_and_device(context, instance_uuid, device_name): DCNL 'Destroy the block device mapping.'
def block_device_mapping_destroy_by_instance_and_volume(context, instance_uuid, volume_id): DCNL 'Destroy the block device mapping.'
def security_group_get_all(context): DCNL 'Get all security groups.'
def security_group_get(context, security_group_id): DCNL 'Get security group by its id.'
def security_group_get_by_name(context, project_id, group_name): DCNL 'Returns a security group with the specified name from a project.'
def security_group_get_by_project(context, project_id): DCNL 'Get all security groups belonging to a project.'
def security_group_get_by_instance(context, instance_id): DCNL 'Get security groups to which the instance is assigned.'
def security_group_exists(context, project_id, group_name): DCNL 'Indicates if a group name exists in a project.'
def security_group_in_use(context, group_id): DCNL 'Indicates if a security group is currently in use.'
def security_group_create(context, values): DCNL 'Create a new security group.'
def security_group_ensure_default(context): DCNL 'Ensure default security group exists for a project_id. DCNL Returns a tuple with the first element being a bool indicating DCNL if the default security group previously existed. Second DCNL element is the dict used to create the default security group.'
def security_group_destroy(context, security_group_id): DCNL 'Deletes a security group.'
def security_group_count_by_project(context, project_id, session=None): DCNL 'Count number of security groups in a project.'
def security_group_rule_create(context, values): DCNL 'Create a new security group.'
def security_group_rule_get_by_security_group(context, security_group_id): DCNL 'Get all rules for a given security group.'
def security_group_rule_get_by_security_group_grantee(context, security_group_id): DCNL 'Get all rules that grant access to the given security group.'
def security_group_rule_destroy(context, security_group_rule_id): DCNL 'Deletes a security group rule.'
def security_group_rule_get(context, security_group_rule_id): DCNL 'Gets a security group rule.'
def security_group_rule_count_by_group(context, security_group_id): DCNL 'Count rules in a given security group.'
def provider_fw_rule_create(context, rule): DCNL 'Add a firewall rule at the provider level (all hosts & instances).'
def provider_fw_rule_get_all(context): DCNL 'Get all provider-level firewall rules.'
def provider_fw_rule_destroy(context, rule_id): DCNL 'Delete a provider firewall rule from the database.'
def project_get_networks(context, project_id, associate=True): DCNL 'Return the network associated with the project. DCNL If associate is true, it will attempt to associate a new DCNL network if one is not found, otherwise it returns None.'
def console_pool_create(context, values): DCNL 'Create console pool.'
def console_pool_get_by_host_type(context, compute_host, proxy_host, console_type): DCNL 'Fetch a console pool for a given proxy host, compute host, and type.'
def console_pool_get_all_by_host_type(context, host, console_type): DCNL 'Fetch all pools for given proxy host and type.'
def console_create(context, values): DCNL 'Create a console.'
def console_delete(context, console_id): DCNL 'Delete a console.'
def console_get_by_pool_instance(context, pool_id, instance_uuid): DCNL 'Get console entry for a given instance and pool.'
def console_get_all_by_instance(context, instance_uuid): DCNL 'Get consoles for a given instance.'
def console_get(context, console_id, instance_uuid=None): DCNL 'Get a specific console (possibly on a given instance).'
def instance_type_create(context, values): DCNL 'Create a new instance type.'
def instance_type_get_all(context, inactive=False, filters=None): DCNL 'Get all instance types.'
def instance_type_get(context, id): DCNL 'Get instance type by id.'
def instance_type_get_by_name(context, name): DCNL 'Get instance type by name.'
def instance_type_get_by_flavor_id(context, id): DCNL 'Get instance type by flavor id.'
def instance_type_destroy(context, name): DCNL 'Delete an instance type.'
def instance_type_access_get_by_flavor_id(context, flavor_id): DCNL 'Get flavor access by flavor id.'
def instance_type_access_add(context, flavor_id, project_id): DCNL 'Add flavor access for project.'
def instance_type_access_remove(context, flavor_id, project_id): DCNL 'Remove flavor access for project.'
def cell_create(context, values): DCNL 'Create a new child Cell entry.'
def cell_update(context, cell_name, values): DCNL 'Update a child Cell entry.'
def cell_delete(context, cell_name): DCNL 'Delete a child Cell.'
def cell_get(context, cell_name): DCNL 'Get a specific child Cell.'
def cell_get_all(context): DCNL 'Get all child Cells.'
def instance_metadata_get(context, instance_uuid): DCNL 'Get all metadata for an instance.'
def instance_metadata_delete(context, instance_uuid, key): DCNL 'Delete the given metadata item.'
def instance_metadata_update(context, instance_uuid, metadata, delete): DCNL 'Update metadata if it exists, otherwise create it.'
def instance_system_metadata_get(context, instance_uuid): DCNL 'Get all system metadata for an instance.'
def instance_system_metadata_update(context, instance_uuid, metadata, delete): DCNL 'Update metadata if it exists, otherwise create it.'
def agent_build_create(context, values): DCNL 'Create a new agent build entry.'
def agent_build_get_by_triple(context, hypervisor, os, architecture): DCNL 'Get agent build by hypervisor/OS/architecture triple.'
def agent_build_get_all(context, hypervisor=None): DCNL 'Get all agent builds.'
def agent_build_destroy(context, agent_update_id): DCNL 'Destroy agent build entry.'
def agent_build_update(context, agent_build_id, values): DCNL 'Update agent build entry.'
def bw_usage_get(context, uuid, start_period, mac): DCNL 'Return bw usage for instance and mac in a given audit period.'
def bw_usage_get_by_uuids(context, uuids, start_period): DCNL 'Return bw usages for instance(s) in a given audit period.'
def bw_usage_update(context, uuid, mac, start_period, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refreshed=None, update_cells=True): DCNL 'Update cached bandwidth usage for an instance\'s network based on mac DCNL address.  Creates new record if needed.'
def instance_type_extra_specs_get(context, flavor_id): DCNL 'Get all extra specs for an instance type.'
def instance_type_extra_specs_delete(context, flavor_id, key): DCNL 'Delete the given extra specs item.'
def instance_type_extra_specs_update_or_create(context, flavor_id, extra_specs): DCNL 'Create or update instance type extra specs. This adds or modifies the DCNL key/value pairs specified in the extra specs dict argument'
def vol_get_usage_by_time(context, begin): DCNL 'Return volumes usage that have been updated after a specified time.'
def vol_usage_update(context, id, rd_req, rd_bytes, wr_req, wr_bytes, instance_id, last_refreshed=None, update_totals=False): DCNL 'Update cached volume usage for a volume DCNL Creates new record if needed.'
def s3_image_get(context, image_id): DCNL 'Find local s3 image represented by the provided id.'
def s3_image_get_by_uuid(context, image_uuid): DCNL 'Find local s3 image represented by the provided uuid.'
def s3_image_create(context, image_uuid): DCNL 'Create local s3 image represented by provided uuid.'
def aggregate_create(context, values, metadata=None): DCNL 'Create a new aggregate with metadata.'
def aggregate_get(context, aggregate_id): DCNL 'Get a specific aggregate by id.'
def aggregate_get_by_host(context, host, key=None): DCNL 'Get a list of aggregates that host belongs to.'
def aggregate_metadata_get_by_host(context, host, key=None): DCNL 'Get metadata for all aggregates that host belongs to. DCNL Returns a dictionary where each value is a set, this is to cover the case DCNL where there two aggregates have different values for the same key. DCNL Optional key filter'
def aggregate_host_get_by_metadata_key(context, key): DCNL 'Get hosts with a specific metadata key metadata for all aggregates. DCNL Returns a dictionary where each key is a hostname and each value is a set DCNL of the key values DCNL return value:  {machine: set( az1, az2 )}'
def aggregate_update(context, aggregate_id, values): DCNL 'Update the attributes of an aggregates. If values contains a metadata DCNL key, it updates the aggregate metadata too.'
def aggregate_delete(context, aggregate_id): DCNL 'Delete an aggregate.'
def aggregate_get_all(context): DCNL 'Get all aggregates.'
def aggregate_metadata_add(context, aggregate_id, metadata, set_delete=False): DCNL 'Add/update metadata. If set_delete=True, it adds only.'
def aggregate_metadata_get(context, aggregate_id): DCNL 'Get metadata for the specified aggregate.'
def aggregate_metadata_delete(context, aggregate_id, key): DCNL 'Delete the given metadata key.'
def aggregate_host_add(context, aggregate_id, host): DCNL 'Add host to the aggregate.'
def aggregate_host_get_all(context, aggregate_id): DCNL 'Get hosts for the specified aggregate.'
def aggregate_host_delete(context, aggregate_id, host): DCNL 'Delete the given host from the aggregate.'
def instance_fault_create(context, values, update_cells=True): DCNL 'Create a new Instance Fault.'
def instance_fault_get_by_instance_uuids(context, instance_uuids): DCNL 'Get all instance faults for the provided instance_uuids.'
def action_start(context, values): DCNL 'Start an action for an instance.'
def action_finish(context, values): DCNL 'Finish an action for an instance.'
def actions_get(context, uuid): DCNL 'Get all instance actions for the provided instance.'
def action_get_by_request_id(context, uuid, request_id): DCNL 'Get the action by request_id and given instance.'
def action_event_start(context, values): DCNL 'Start an event on an instance action.'
def action_event_finish(context, values): DCNL 'Finish an event on an instance action.'
def action_events_get(context, action_id): DCNL 'Get the events by action id.'
def get_ec2_instance_id_by_uuid(context, instance_id): DCNL 'Get ec2 id through uuid from instance_id_mappings table.'
def get_instance_uuid_by_ec2_id(context, ec2_id): DCNL 'Get uuid through ec2 id from instance_id_mappings table.'
def ec2_instance_create(context, instance_uuid, id=None): DCNL 'Create the ec2 id to instance uuid mapping on demand.'
def task_log_end_task(context, task_name, period_beginning, period_ending, host, errors, message=None): DCNL 'Mark a task as complete for a given host/time period.'
def task_log_begin_task(context, task_name, period_beginning, period_ending, host, task_items=None, message=None): DCNL 'Mark a task as started for a given host/time period.'
def archive_deleted_rows(context, max_rows=None): DCNL 'Move up to max_rows rows from production tables to corresponding shadow DCNL tables. DCNL :returns: number of rows archived.'
def archive_deleted_rows_for_table(context, tablename, max_rows=None): DCNL 'Move up to max_rows rows from tablename to corresponding shadow DCNL table. DCNL :returns: number of rows archived.'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def vpn_ping(address, port, timeout=0.05, session_id=None): DCNL 'Sends a vpn negotiation packet and returns the server session. DCNL Returns False on a failure. Basic packet structure is below. DCNL Client packet (14 bytes):: DCNL 0 1      8 9  13 DCNL |x| cli_id |?????| DCNL x = packet identifier 0x38 DCNL cli_id = 64 bit identifier DCNL ? = unknown, probably flags/padding DCNL Server packet (26 bytes):: DCNL 0 1      8 9  13 14    21 2225 DCNL |x| srv_id |?????| cli_id |????| DCNL x = packet identifier 0x40 DCNL cli_id = 64 bit identifier DCNL ? = unknown, probably flags/padding DCNL bit 9 was 1 and the rest were 0 in testing'
def execute(*cmd, **kwargs): DCNL 'Helper method to execute command with optional retry. DCNL If you add a run_as_root=True command, don\'t forget to add the DCNL corresponding filter to etc/nova/rootwrap.d ! DCNL :param cmd:                Passed to subprocess.Popen. DCNL :param process_input:      Send to opened process. DCNL :param check_exit_code:    Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these code. DCNL :param delay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmd. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the command is run with rootwrap. DCNL :raises exception.NovaException: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stdout, stderr) from the spawned process, or None if DCNL the command fails.'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def last_completed_audit_period(unit=None, before=None): DCNL 'This method gives you the most recently *completed* audit period. DCNL arguments: DCNL units: string, one of \'hour\', \'day\', \'month\', \'year\' DCNL Periods normally begin at the beginning (UTC) of the DCNL period unit (So a \'day\' period begins at midnight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appended with an optional offset DCNL like so:  \'day@18\'  This will begin the period at 18:00 DCNL UTC.  \'month@15\' starts a monthly period on the 15th, DCNL and year@3 begins a yearly one on March 1st. DCNL before: Give the audit period most recently completed before DCNL <timestamp>. Defaults to now. DCNL returns:  2 tuple of datetimes (begin, end) DCNL The begin timestamp of this audit period is the same as the DCNL end of the previous.'
def generate_password(length=None, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL 'Generate a random password from the supplied symbol groups. DCNL At least one symbol from each group will be included. Unpredictable DCNL results if length is less than the number of symbol groups. DCNL Believed to be reasonably secure (with a reasonable password length!)'
def xhtml_escape(value): DCNL 'Escapes a string so it is valid within XML or XHTML.'
def utf8(value): DCNL 'Try to turn a string into utf-8 if possible. DCNL Code is directly from the utf8 function in DCNL http://github.com/facebook/tornado/blob/master/tornado/escape.py'
def to_bytes(text, default=0): DCNL 'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to determine what conversion is needed to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the end)'
def delete_if_exists(pathname): DCNL 'delete a file, but ignore file not found error.'
def get_from_path(items, path): DCNL 'Returns a list of items matching the specified path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, and for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermediate results are lists it will treat each list item individually. DCNL A \'None\' in items or any child expressions will be ignored, this function DCNL will not throw because of None (anywhere) in items.  The returned list DCNL will contain no None values.'
def flatten_dict(dict_, flattened=None): DCNL 'Recursively flatten a nested dictionary.'
def partition_dict(dict_, keys): DCNL 'Return two dicts, one with `keys` the other with everything else.'
def map_dict_keys(dict_, key_map): DCNL 'Return a dict in which the dictionaries keys are mapped to new keys.'
def subset_dict(dict_, keys): DCNL 'Return a dict that only contains a subset of keys.'
def diff_dict(orig, new): DCNL 'Return a dict describing how to change orig to new.  The keys DCNL correspond to values that have changed; the value will be a list DCNL of one or two elements.  The first element of the list will be DCNL either \'+\' or \'-\', indicating whether the key was updated or DCNL deleted; if the key was updated, the list will contain a second DCNL element, giving the updated value.'
def check_isinstance(obj, cls): DCNL 'Checks that obj is of type cls, and lets PyLint infer types.'
def parse_server_string(server_str): DCNL 'Parses the given server_string and returns a list of host and port. DCNL If it\'s not a combination of host part and port, the port element DCNL is a null string. If the input is invalid expression, return a null DCNL list.'
def bool_from_str(val): DCNL 'Convert a string representation of a bool into a bool value.'
def is_int_like(val): DCNL 'Check if a value looks like an int.'
def is_valid_boolstr(val): DCNL 'Check if the provided string is a valid bool string or not.'
def is_valid_ipv4(address): DCNL 'Verify that address represents a valid IPv4 address.'
def is_valid_cidr(address): DCNL 'Check if the provided ipv4 or ipv6 address is a valid DCNL CIDR address or not'
def get_ip_version(network): DCNL 'Returns the IP version of a network (IPv4 or IPv6). Raises DCNL AddrFormatError if invalid network.'
def monkey_patch(): DCNL 'If the Flags.monkey_patch set as True, DCNL this function patches a decorator DCNL for all functions in specified modules. DCNL You can set decorators for each modules DCNL using CONF.monkey_patch_modules. DCNL The format is "Module path:Decorator function". DCNL Example: DCNL \'nova.api.ec2.cloud:nova.openstack.common.notifier.api.notify_decorator\' DCNL Parameters of the decorator is as follows. DCNL (See nova.openstack.common.notifier.api.notify_decorator) DCNL name - name of the function DCNL function - object of the function'
def convert_to_list_dict(lst, label): DCNL 'Convert a value or list into a list of dicts.'
def timefunc(func): DCNL 'Decorator that logs how long a particular function took to execute.'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed.'
def make_dev_path(dev, partition=None, base='/dev'): DCNL 'Return a path to a particular device. DCNL >>> make_dev_path(\'xvdc\') DCNL /dev/xvdc DCNL >>> make_dev_path(\'xvdc\', 1) DCNL /dev/xvdc1'
def total_seconds(td): DCNL 'Local total_seconds implementation for compatibility with python 2.6.'
def sanitize_hostname(hostname): DCNL 'Return a hostname which conforms to RFC-952 and RFC-1123 specs.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def hash_file(file_like_object): DCNL 'Generate a hash for the contents of a file.'
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL 'Temporarily set the attr on a particular object to a given value then DCNL revert when finished. DCNL One use of this is to temporarily set the read_deleted flag on a context DCNL object: DCNL with temporary_mutation(context, read_deleted="yes"): DCNL do_something_that_needed_deleted_objects()'
def generate_mac_address(): DCNL 'Generate an Ethernet MAC address.'
def read_file_as_root(file_path): DCNL 'Secure helper to read file as root.'
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL 'Temporarily chown a path. DCNL :params owner_uid: UID of temporary owner (defaults to current user)'
def walk_class_hierarchy(clazz, encountered=None): DCNL 'Walk class hierarchy, yielding most derived classes first.'
def mkfs(fs, path, label=None): DCNL 'Format a file or block device DCNL :param fs: Filesystem type (examples include \'swap\', \'ext3\', \'ext4\' DCNL \'btrfs\', etc.) DCNL :param path: Path to file or block device to format DCNL :param label: Volume label to use'
def last_bytes(file_like_object, num): DCNL 'Return num bytes from the end of the file, and remaining byte count. DCNL :param file_like_object: The file to read DCNL :param num: The number of bytes to return DCNL :returns (data, remaining)'
def get_wrapped_function(function): DCNL 'Get the method at the bottom of a stack of decorators.'
def check_string_length(value, name, min_length=0, max_length=None): DCNL 'Check the length of specified string DCNL :param value: the value of the string DCNL :param name: the name of the string DCNL :param min_length: the min_length of the string DCNL :param max_length: the max_length of the string'
def enforce(context, action, target, do_raise=True): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: nova context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_volume``, DCNL ``volume:attach_volume`` DCNL :param target: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :param do_raise: if True (the default), raises PolicyNotAuthorized; DCNL if False, returns False DCNL :raises nova.exception.PolicyNotAuthorized: if verification fails DCNL and do_raise is True. DCNL :return: returns a non-False value (not necessarily "True") if DCNL authorized, and the exact value False if not authorized and DCNL do_raise is False.'
def check_is_admin(context): DCNL 'Whether or not roles contains \'admin\' role according to policy setting.'
def stub_vm_utils_with_vdi_attached_here(function, should_return=True): DCNL 'vm_utils.with_vdi_attached_here needs to be stubbed out because it DCNL calls down to the filesystem to attach a vdi. This provides a DCNL decorator to handle that.'
def get_instances_with_cached_ips(orig_func, *args, **kwargs): DCNL 'Kludge the cache into instance(s) without having to create DB DCNL entries'
@webob.dec.wsgify DCNL def conditional_forbid(req): DCNL 'Helper wsgi app returns 403 if param \'die\' is 1.'
def get_instances_with_cached_ips(orig_func, *args, **kwargs): DCNL 'Kludge the cache into instance(s) without having to create DB DCNL entries'
def webob_factory(url): DCNL 'Factory for removing duplicate webob code from tests.'
def compare_links(actual, expected): DCNL 'Compare xml atom links.'
def compare_media_types(actual, expected): DCNL 'Compare xml media types.'
def compare_tree_to_dict(actual, expected, keys): DCNL 'Compare parts of lxml.etree objects to dicts.'
def wire_HTTPConnection_to_WSGI(host, app): DCNL 'Monkeypatches HTTPConnection so that if you try to connect to host, you DCNL are instead routed straight to the given WSGI app. DCNL After calling this method, when any code calls DCNL httplib.HTTPConnection(host) DCNL the connection object will be a fake.  Its requests will be sent directly DCNL to the given WSGI app rather than through a socket. DCNL Code connecting to hosts other than host will not be affected. DCNL This method may be called multiple times to map different hosts to DCNL different apps. DCNL This method returns the original HTTPConnection object, so that the caller DCNL can restore the default HTTPConnection interface (for all hosts).'
def stub_set_host_enabled(context, host_name, enabled): DCNL 'Simulates three possible behaviours for VM drivers or compute drivers when DCNL enabling or disabling a host. DCNL \'enabled\' means new instances can go to this host DCNL \'disabled\' means they can\'t'
def _create_instance(**kwargs): DCNL 'Create a test instance.'
def _create_instance_dict(**kwargs): DCNL 'Create a dictionary for a test instance.'
def format_action(action): DCNL 'Remove keys that aren\'t serialized.'
def format_event(event): DCNL 'Remove keys that aren\'t serialized.'
def _quote_domain(domain): DCNL 'Domain names tend to have .\'s in them.  Urllib doesn\'t quote dots, DCNL but Routes tends to choke on them, so we need an extra level of DCNL by-hand quoting here.  This function needs to duplicate the one in DCNL python-novaclient/novaclient/v1_1/floating_ip_dns.py'
def stub_out_glanceclient_create(stubs, sent_to_glance): DCNL 'We return the metadata sent to glance by modifying the sent_to_glance dict DCNL in place.'
def stub_out(stubs, funcs): DCNL 'Set the stubs in mapping in the db api.'
def stub_out_db_instance_api(stubs, injected=True): DCNL 'Stubs out the db API for creating Instances.'
def generate_random_alphanumeric(length): DCNL 'Creates a random alphanumeric string of specified length.'
def generate_random_numeric(length): DCNL 'Creates a random numeric string of specified length.'
def generate_new_element(items, prefix, numeric=False): DCNL 'Creates a random string with prefix, that is not in \'items\' list.'
def fake_execute_set_repliers(repliers): DCNL 'Allows the client to configure replies to commands.'
def fake_execute_default_reply_handler(*ignore_args, **ignore_kwargs): DCNL 'A reply handler for commands that haven\'t been added to the reply list. DCNL Returns empty strings for stdout and stderr.'
def fake_execute(*cmd_parts, **kwargs): DCNL 'This function stubs out execute. DCNL It optionally executes a preconfigued function to return expected data.'
def stub_out_db_instance_api(stubs): DCNL 'Stubs out the db API for creating Instances.'
def fake_get_vim_object(arg): DCNL 'Stubs out the VMwareAPISession\'s get_vim_object method.'
def fake_is_vim_object(arg, module): DCNL 'Stubs out the VMwareAPISession\'s is_vim_object method.'
def set_stubs(stubs): DCNL 'Set the stubs.'
def initialize(_uri): DCNL 'Opens a fake connection with an LDAP server.'
def _match_query(query, attrs): DCNL 'Match an ldap query to an attribute dictionary. DCNL The characters &, |, and ! are supported in the query. No syntax checking DCNL is performed, so malformed queries will not work correctly.'
def _paren_groups(source): DCNL 'Split a string into parenthesized groups.'
def _match(key, value, attrs): DCNL 'Match a given key and value against an attribute list.'
def _subs(value): DCNL 'Returns a list of subclass strings. DCNL The strings represent the ldap object class plus any subclasses that DCNL inherit from it. Fakeldap doesn\'t know about the ldap object structure, DCNL so subclasses need to be defined manually in the dictionary below.'
def _from_json(encoded): DCNL 'Convert attribute values from json representation. DCNL Args: DCNL encoded -- a json encoded string DCNL Returns a list of strings'
def _to_json(unencoded): DCNL 'Convert attribute values into json representation. DCNL Args: DCNL unencoded -- an unencoded string or list of strings.  If it DCNL is a single string, it will be converted into a list. DCNL Returns a json string'
def example_decorator(name, function): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def catch_notimplementederror(f): DCNL 'Decorator to simplify catching drivers raising NotImplementedError DCNL If a particular call makes a driver raise NotImplementedError, we DCNL log it so that we can extract this information afterwards to DCNL automatically generate a hypervisor/feature support matrix.'
def stub_out_db_instance_api(stubs): DCNL 'Stubs out the db API for creating Instances.'
def stubout_session(stubs, cls, product_version=(5, 6, 2), product_brand='XenServer', **opt_args): DCNL 'Stubs out methods from XenAPISession.'
def stubout_determine_is_pv_objectstore(stubs): DCNL 'Assumes VMs stu have PV kernels.'
def stubout_is_snapshot(stubs): DCNL 'Always returns true DCNL xenapi fake driver does not create vmrefs for snapshots'
def stubout_lookup_image(stubs): DCNL 'Simulates a failure in lookup image.'
def stubout_fetch_disk_image(stubs, raise_failure=False): DCNL 'Simulates a failure in fetch image_glance_disk.'
def stubout_create_vm(stubs): DCNL 'Simulates a failure in create_vm.'
def stubout_attach_disks(stubs): DCNL 'Simulates a failure in _attach_disks.'
def _get_connect_string(backend, user, passwd, database): DCNL 'Try to get a connection with a very specific set of values, if we get DCNL these then we\'ll run the tests, otherwise they are skipped'
def get_table(engine, name): DCNL 'Returns an sqlalchemy table dynamically from db. DCNL Needed because the models don\'t work for us in migrations DCNL as models will be far out of sync with the current data.'
def _get_instances_with_cached_ips(orig_func, *args, **kwargs): DCNL 'Kludge the cache into instance(s) without having to create DB DCNL entries'
def add_hook(name): DCNL 'Execute optional pre and post methods around the decorated DCNL function.  This is useful for customization around callables.'
def reset(): DCNL 'Clear loaded hooks.'
def setup(product_name): DCNL 'Setup logging.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def isotime(at=None): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def set_defaults(sql_connection, sqlite_db): DCNL 'Set defaults for configuration variables.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def raise_if_duplicate_entry_error(integrity_error, engine_name): DCNL 'In this function will be raised DBDuplicateEntry exception if integrity DCNL error wrap unique constraint violation.'
def raise_if_deadlock_error(operational_error, engine_name): DCNL 'Raise DBDeadlock exception if OperationalError contains a Deadlock DCNL condition.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode.'
def add_regexp_listener(dbapi_con, con_record): DCNL 'Add REGEXP function to sqlite connections.'
def greenthread_yield(dbapi_con, con_record): DCNL 'Ensure other greenthreads get a chance to execute by forcing a context DCNL switch. With common database backends (eg MySQLdb and sqlite), there is DCNL no implicit yield caused by network I/O since they are implemented by DCNL C libraries that eventlet cannot monkey patch.'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def create_engine(sql_connection): DCNL 'Return a new SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def patch_mysqldb_with_stacktrace_comments(): DCNL 'Adds current stack trace as a comment in queries by patching DCNL MySQLdb.cursors.BaseCursor._do_query.'
def validate_args(fn, *args, **kwargs): DCNL 'Check that the supplied args are sufficient for calling a function. DCNL >>> validate_args(lambda a: None) DCNL Traceback (most recent call last): DCNL MissingArgs: An argument is missing DCNL >>> validate_args(lambda a, b, c, d: None, 0, c=1) DCNL Traceback (most recent call last): DCNL MissingArgs: 2 arguments are missing DCNL :param fn: the function to check DCNL :param arg: the positional arguments supplied DCNL :param kwargs: the keyword arguments supplied'
def set_rules(rules): DCNL 'Set the rules in use for policy checks.'
def reset(): DCNL 'Clear the rules used for policy checks.'
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL 'Checks authorization of a rule against the target and credentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operated DCNL on as possible, as a dictionary. DCNL :param creds: As much information about the user performing the DCNL action as possible, as a dictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passed to check() (both DCNL positional and keyword arguments) will be passed to DCNL the exception class.  If exc is not provided, returns DCNL False. DCNL :return: Returns False if the policy does not allow the action and DCNL exc is not provided; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specified string DCNL from the expression.'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Provided for backwards compatibility.  Translates the old DCNL list-of-lists syntax into a tree of Check objects.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods.  Arguments are a sequence of DCNL tokens, in order, which should trigger running this reduction DCNL method.'
def _parse_text_rule(rule): DCNL 'Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def execute(*cmd, **kwargs): DCNL 'Helper method to shell out and execute a command through subprocess with DCNL optional retry. DCNL :param cmd:             Passed to subprocess.Popen. DCNL :type cmd:              string DCNL :param process_input:   Send to opened process. DCNL :type proces_input:     string DCNL :param check_exit_code: Defaults to 0. Will raise DCNL :class:`ProcessExecutionError` DCNL if the command exits without returning this value DCNL as a returncode DCNL :type check_exit_code:  int DCNL :param delay_on_retry:  True | False. Defaults to True. If set to True, DCNL wait a short amount of time before retrying. DCNL :type delay_on_retry:   boolean DCNL :param attempts:        How many times to retry cmd. DCNL :type attempts:         int DCNL :param run_as_root:     True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper kwarg. DCNL :type run_as_root:      boolean DCNL :param root_helper:     command to prefix all cmd\'s with DCNL :type root_helper:      string DCNL :returns:               (stdout, stderr) from process execution DCNL :raises:                :class:`UnknownArgumentError` on DCNL receiving unknown arguments DCNL :raises:                :class:`ProcessExecutionError`'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filters, userargs, exec_dirs=[]): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter. DCNL Raises NoFilterMatched if no filter matched. DCNL Raises FilterMatchNotExecutable if no executable was found for the DCNL best filter match.'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every cycle DCNL of the periodic scheduler. DCNL 2. With arguments: DCNL @periodic_task(spacing=N [, run_immediately=[True|False]]) DCNL this will be run on approximately every N seconds. If this number is DCNL negative the periodic task will be disabled. If the run_immediately DCNL argument is provided and has a value of \'True\', the first run of the DCNL task will be shortly after task scheduler starts.  If DCNL run_immediately is omitted or set to \'False\', the first time the DCNL task runs will be approximately N seconds after the task scheduler DCNL starts.'
def ensure_ca_filesystem(): DCNL 'Ensure the CA filesystem exists.'
def fetch_crl(project_id): DCNL 'Get crl file for project.'
def convert_from_sshrsa_to_pkcs8(pubkey): DCNL 'Convert a ssh public key to openssl format DCNL Equivalent to the ssh-keygen\'s -m option'
def ssh_encrypt_text(ssh_public_key, text): DCNL 'Encrypt text with an ssh public key.'
def revoke_cert(project_id, file_name): DCNL 'Revoke a cert by file name.'
def revoke_certs_by_user(user_id): DCNL 'Revoke all user certs.'
def revoke_certs_by_project(project_id): DCNL 'Revoke all project certs.'
def revoke_certs_by_user_and_project(user_id, project_id): DCNL 'Revoke certs for user in project.'
def _project_cert_subject(project_id): DCNL 'Helper to generate user cert subject.'
def _user_cert_subject(user_id, project_id): DCNL 'Helper to generate user cert subject.'
def generate_x509_cert(user_id, project_id, bits=1024): DCNL 'Generate and sign a cert for user in project.'
def compute_md5(fp): DCNL 'Compute an md5 hash. DCNL :type fp: file DCNL :param fp: File pointer to the file to MD5 hash.  The file pointer will be DCNL reset to the beginning of the file before the method returns. DCNL :rtype: tuple DCNL :returns: the hex digest version of the MD5 hash'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def basedir_def(*args): DCNL 'Return an uninterpolated path relative to $pybasedir.'
def bindir_def(*args): DCNL 'Return an uninterpolated path relative to $bindir.'
def state_path_def(*args): DCNL 'Return an uninterpolated path relative to $state_path.'
def basedir_rel(*args): DCNL 'Return a path relative to $pybasedir.'
def bindir_rel(*args): DCNL 'Return a path relative to $bindir.'
def state_path_rel(*args): DCNL 'Return a path relative to $state_path.'
def generate_glance_url(): DCNL 'Generate the URL to glance.'
def generate_image_url(image_ref): DCNL 'Generate an image URL from an image_ref.'
def _parse_image_ref(image_href): DCNL 'Parse an image href into composite parts. DCNL :param image_href: href of an image DCNL :returns: a tuple of the form (image_id, host, port) DCNL :raises ValueError'
def _create_glance_client(context, host, port, use_ssl, version=1): DCNL 'Instantiate a new glanceclient.Client object.'
def get_api_servers(): DCNL 'Shuffle a list of CONF.glance_api_servers and return an iterator DCNL that will cycle through the list, looping around to the beginning DCNL if necessary.'
def _convert_timestamps_to_datetimes(image_meta): DCNL 'Returns image with timestamp fields converted to datetime objects.'
def _reraise_translated_image_exception(image_id): DCNL 'Transform the exception for the image but keep its traceback intact.'
def _reraise_translated_exception(): DCNL 'Transform the exception but keep its traceback intact.'
def get_remote_image_service(context, image_href): DCNL 'Create an image_service and parse the id from the given image_href. DCNL The image_href param can be an href of the form DCNL \'http://example.com:9292/v1/images/b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3\', DCNL or just an id such as \'b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3\'. If the DCNL image_href is a standalone id, then the default image service is returned. DCNL :param image_href: href that describes the location of an image DCNL :returns: a tuple of the form (image_service, image_id)'
def echo_scsi_command(path, content): DCNL 'Used to echo strings to scsi subsystem.'
def find_multipath_device(device): DCNL 'Try and discover the multipath device for a volume.'
def getcallargs(function, *args, **kwargs): DCNL 'This is a simplified inspect.getcallargs (2.7+). DCNL It should be replaced when python >= 2.7 is standard.'
def send_api_fault(url, status, exception): DCNL 'Send an api.fault notification.'
def send_update(context, old_instance, new_instance, service=None, host=None): DCNL 'Send compute.instance.update notification to report any changes occurred DCNL in that instance'
def send_update_with_states(context, instance, old_vm_state, new_vm_state, old_task_state, new_task_state, service='compute', host=None, verify_states=False): DCNL 'Send compute.instance.update notification to report changes if there DCNL are any, in the instance'
def _send_instance_update_notification(context, instance, old_vm_state=None, old_task_state=None, new_vm_state=None, new_task_state=None, service='compute', host=None): DCNL 'Send \'compute.instance.update\' notification to inform observers DCNL about instance state changes'
def audit_period_bounds(current_period=False): DCNL 'Get the start and end of the relevant audit usage period DCNL :param current_period: if True, this will generate a usage for the DCNL current usage period; if False, this will generate a usage for the DCNL previous audit period.'
def bandwidth_usage(instance_ref, audit_start, ignore_missing_network_data=True): DCNL 'Get bandwidth usage information for the instance for the DCNL specified audit period.'
def image_meta(system_metadata): DCNL 'Format image metadata for use in notifications from the instance DCNL system metadata.'
def info_from_instance(context, instance_ref, network_info, system_metadata, **kw): DCNL 'Get detailed instance information for an instance which is common to all DCNL notifications. DCNL :param network_info: network_info provided if not None DCNL :param system_metadata: system_metadata DB entries for the instance, DCNL if not None.  *NOTE*: Currently unused here in trunk, but needed for DCNL potential custom modifications.'
def load_from_conf_data(conf_data): DCNL 'LPAR configuration data parser. DCNL The configuration data is a string representation of DCNL the attributes of a Logical Partition. The attributes DCNL consists of name/value pairs, which are in command separated DCNL value format. DCNL Example format: name=lpar_name,lpar_id=1,lpar_env=aixlinux DCNL :param conf_data: string containing the LPAR configuration data. DCNL :returns: LPAR -- LPAR object.'
def ssh_connect(connection): DCNL 'Method to connect to remote system using ssh protocol. DCNL :param connection: a Connection object. DCNL :returns: paramiko.SSHClient -- an active ssh connection. DCNL :raises: PowerVMConnectionFailed'
def ssh_command_as_root(ssh_connection, cmd, check_exit_code=True): DCNL 'Method to execute remote command as root. DCNL :param connection: an active paramiko.SSHClient connection. DCNL :param command: string containing the command to run. DCNL :returns: Tuple -- a tuple of (stdout, stderr) DCNL :raises: nova.exception.ProcessExecutionError'
def ftp_put_command(connection, local_path, remote_dir): DCNL 'Method to transfer a file via ftp. DCNL :param connection: a Connection object. DCNL :param local_path: path to the local file DCNL :param remote_dir: path to remote destination DCNL :raises: PowerVMFileTransferFailed'
def ftp_get_command(connection, remote_path, local_path): DCNL 'Retrieve a file via FTP DCNL :param connection: a Connection object. DCNL :param remote_path: path to the remote file DCNL :param local_path: path to local destination DCNL :raises: PowerVMFileTransferFailed'
def aix_path_join(path_one, path_two): DCNL 'Ensures file path is built correctly for remote UNIX system DCNL :param path_one: string of the first file path DCNL :param path_two: string of the second file path DCNL :returns: a uniform path constructed from both strings'
@contextlib.contextmanager DCNL def vios_to_vios_auth(source, dest, conn_info): DCNL 'Context allowing for SSH between VIOS partitions DCNL This context will build an SSH key on the source host, put the key DCNL into the authorized_keys on the destination host, and make the DCNL private key file name available within the context. DCNL The key files and key inserted into authorized_keys will be DCNL removed when the context exits. DCNL :param source: source IP or DNS name DCNL :param dest: destination IP or DNS name DCNL :param conn_info: dictionary object with SSH connection DCNL information for both hosts'
def set_vif_guest_frontend_config(conf, mac, model, driver): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with guest frontend details'
def set_vif_host_backend_bridge_config(conf, brname, tapname=None): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for a software bridge'
def set_vif_host_backend_ethernet_config(conf, tapname): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for an externally configured DCNL host device. DCNL NB use of this configuration is discouraged by DCNL libvirt project and will mark domains as \'tainted\''
def set_vif_host_backend_ovs_config(conf, brname, interfaceid, tapname=None): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for an OpenVSwitch bridge'
def set_vif_host_backend_802qbg_config(conf, devname, managerid, typeid, typeidversion, instanceid, tapname=None): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for an 802.1qbg device'
def set_vif_host_backend_802qbh_config(conf, devname, profileid, tapname=None): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for an 802.1qbh device'
def set_vif_bandwidth_config(conf, extra_specs): DCNL 'Config vif inbound/outbound bandwidth limit. parameters are DCNL set in instance_type_extra_specs table, key is in  the format DCNL quota:vif_inbound_average.'
def get_cache_fname(images, key): DCNL 'Return a filename based on the SHA1 hash of a given image ID. DCNL Image files stored in the _base directory that match this pattern DCNL are considered for cleanup by the image cache manager. The cache DCNL manager considers the file to be in use if it matches an instance\'s DCNL image_ref, kernel_id or ramdisk_id property. DCNL However, in grizzly-3 and before, only the image_ref property was DCNL considered. This means that it\'s unsafe to store kernel and ramdisk DCNL images using this pattern until we\'re sure that all compute nodes DCNL are running a cache manager newer than grizzly-3. For now, we DCNL require admins to confirm that by setting the remove_unused_kernels DCNL boolean but, at some point in the future, we\'ll be safely able to DCNL assume this.'
def get_info_filename(base_path): DCNL 'Construct a filename for storing additional information about a base DCNL image. DCNL Returns a filename.'
def is_valid_info_file(path): DCNL 'Test if a given path matches the pattern for info files.'
def read_stored_info(target, field=None, timestamped=False): DCNL 'Read information about an image. DCNL Returns an empty dictionary if there is no info, just the field value if DCNL a field is requested, or the entire dictionary otherwise.'
def write_stored_info(target, field=None, value=None): DCNL 'Write information about an image.'
def read_stored_checksum(target, timestamped=True): DCNL 'Read the checksum. DCNL Returns the checksum (as hex) or None.'
def write_stored_checksum(target): DCNL 'Write a checksum to disk for a file in _base.'
def patch_tpool_proxy(): DCNL 'eventlet.tpool.Proxy doesn\'t work with old-style class in __str__() DCNL or __repr__() calls. See bug #962840 for details. DCNL We perform a monkey patch to replace those two instance methods.'
def get_iscsi_initiator(): DCNL 'Get iscsi initiator name for this machine.'
def get_fc_hbas(): DCNL 'Get the Fibre Channel HBA information.'
def get_fc_hbas_info(): DCNL 'Get Fibre Channel WWNs and device paths from the system, if any.'
def get_fc_wwpns(): DCNL 'Get Fibre Channel WWPNs from the system, if any.'
def get_fc_wwnns(): DCNL 'Get Fibre Channel WWNNs from the system, if any.'
def create_image(disk_format, path, size): DCNL 'Create a disk image DCNL :param disk_format: Disk image format (as known by qemu-img) DCNL :param path: Desired location of the disk image DCNL :param size: Desired size of disk image. May be given as an int or DCNL a string. If given as an int, it will be interpreted DCNL as bytes. If it\'s a string, it should consist of a number DCNL with an optional suffix (\'K\' for Kibibytes, DCNL M for Mebibytes, \'G\' for Gibibytes, \'T\' for Tebibytes). DCNL If no suffix is given, it will be interpreted as bytes.'
def create_cow_image(backing_file, path, size=None): DCNL 'Create COW image DCNL Creates a COW image with the given backing file DCNL :param backing_file: Existing image on which to base the COW image DCNL :param path: Desired location of the COW image'
def create_lvm_image(vg, lv, size, sparse=False): DCNL 'Create LVM image. DCNL Creates a LVM image with given size. DCNL :param vg: existing volume group which should hold this image DCNL :param lv: name for this image (logical volume) DCNL :size: size of image in bytes DCNL :sparse: create sparse logical volume'
def get_volume_group_info(vg): DCNL 'Return free/used/total space info for a volume group in bytes DCNL :param vg: volume group name DCNL :returns: A dict containing: DCNL :total: How big the filesystem is (in bytes) DCNL :free: How much space is free (in bytes) DCNL :used: How much space is used (in bytes)'
def list_logical_volumes(vg): DCNL 'List logical volumes paths for given volume group. DCNL :param vg: volume group name'
def logical_volume_info(path): DCNL 'Get logical volume info. DCNL :param path: logical volume path'
def logical_volume_size(path): DCNL 'Get logical volume size in bytes. DCNL :param path: logical volume path'
def clear_logical_volume(path): DCNL 'Obfuscate the logical volume. DCNL :param path: logical volume path'
def remove_logical_volumes(*paths): DCNL 'Remove one or more logical volume.'
def pick_disk_driver_name(is_block_dev=False): DCNL 'Pick the libvirt primary backend driver name DCNL If the hypervisor supports multiple backend drivers, then the name DCNL attribute selects the primary backend driver name, while the optional DCNL type attribute provides the sub-type.  For example, xen supports a name DCNL of "tap", "tap2", "phy", or "file", with a type of "aio" or "qcow2", DCNL while qemu only supports a name of "qemu", but multiple types including DCNL "raw", "bochs", "qcow2", and "qed". DCNL :param is_block_dev: DCNL :returns: driver_name or None'
def get_disk_size(path): DCNL 'Get the (virtual) size of a disk image DCNL :param path: Path to the disk image DCNL :returns: Size (in bytes) of the given disk image as it would be seen DCNL by a virtual machine.'
def get_disk_backing_file(path, basename=True): DCNL 'Get the backing file of a disk image DCNL :param path: Path to the disk image DCNL :returns: a path to the image\'s backing store'
def copy_image(src, dest, host=None): DCNL 'Copy a disk image to an existing directory DCNL :param src: Source image DCNL :param dest: Destination path DCNL :param host: Remote host'
def write_to_file(path, contents, umask=None): DCNL 'Write the given contents to a file DCNL :param path: Destination file DCNL :param contents: Desired contents of the file DCNL :param umask: Umask to set when creating this file (will be reset)'
def chown(path, owner): DCNL 'Change ownership of file or directory DCNL :param path: File or directory whose ownership to change DCNL :param owner: Desired new owner (given as uid or username)'
def create_snapshot(disk_path, snapshot_name): DCNL 'Create a snapshot in a disk image DCNL :param disk_path: Path to disk image DCNL :param snapshot_name: Name of snapshot in disk image'
def delete_snapshot(disk_path, snapshot_name): DCNL 'Create a snapshot in a disk image DCNL :param disk_path: Path to disk image DCNL :param snapshot_name: Name of snapshot in disk image'
def extract_snapshot(disk_path, source_fmt, snapshot_name, out_path, dest_fmt): DCNL 'Extract a named snapshot from a disk image DCNL :param disk_path: Path to disk image DCNL :param snapshot_name: Name of snapshot in disk image DCNL :param out_path: Desired path of extracted snapshot'
def load_file(path): DCNL 'Read contents of file DCNL :param path: File to read'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def file_delete(path): DCNL 'Delete (unlink) file DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def find_disk(virt_dom): DCNL 'Find root device path for instance DCNL May be file or device'
def get_disk_type(path): DCNL 'Retrieve disk type (raw, qcow2, lvm) for given file.'
def get_fs_info(path): DCNL 'Get free/used/total space info for a filesystem DCNL :param path: Any dirent on the filesystem DCNL :returns: A dict containing: DCNL :free: How much space is free (in bytes) DCNL :used: How much space is used (in bytes) DCNL :total: How big the filesystem is (in bytes)'
def fetch_image(context, target, image_id, user_id, project_id): DCNL 'Grab image.'
def get_instance_path(instance, forceold=False): DCNL 'Determine the correct path for instance storage. DCNL This method determines the directory name for instance storage, while DCNL handling the fact that we changed the naming style to something more DCNL unique in the grizzly release. DCNL :param instance: the instance we want a path for DCNL :param forceold: force the use of the pre-grizzly format DCNL :returns: a path to store information about that instance'
def has_disk_dev(mapping, disk_dev): DCNL 'Determine if a disk device name has already been used. DCNL Looks at all the keys in mapping to see if any DCNL corresponding disk_info tuple has a device name DCNL matching disk_dev DCNL Returns True if the disk_dev is in use.'
def get_dev_prefix_for_disk_bus(disk_bus): DCNL 'Determine the dev prefix for a disk bus. DCNL Determine the dev prefix to be combined DCNL with a disk number to fix a disk_dev. DCNL eg \'hd\' for \'ide\' bus can be used to DCNL form a disk dev \'hda\' DCNL Returns the dev prefix or raises an DCNL exception if the disk bus is unknown.'
def get_dev_count_for_disk_bus(disk_bus): DCNL 'Determine the number disks supported. DCNL Determine how many disks can be supported in DCNL a single VM for a particular disk bus. DCNL Returns the number of disks supported.'
def find_disk_dev_for_disk_bus(mapping, bus, last_device=False): DCNL 'Identify a free disk dev name for a bus. DCNL Determines the possible disk dev names for DCNL the bus, and then checks them in order until DCNL it identifies one that is not yet used in the DCNL disk mapping. If \'last_device\' is set, it will DCNL only consider the last available disk dev name. DCNL Returns the chosen disk_dev name, or raises an DCNL exception if none is available.'
def get_disk_bus_for_device_type(virt_type, image_meta=None, device_type='disk'): DCNL 'Determine the best disk bus to use for a device type. DCNL Considering the currently configured virtualization DCNL type, return the optimal disk_bus to use for a given DCNL device type. For example, for a disk on KVM it will DCNL return \'virtio\', while for a CDROM it will return \'ide\' DCNL Returns the disk_bus, or returns None if the device DCNL type is not supported for this virtualization'
def get_disk_bus_for_disk_dev(virt_type, disk_dev): DCNL 'Determine the disk bus for a disk dev. DCNL Given a disk devi like \'hda\', \'sdf\', \'xvdb\', etc DCNL guess what the most appropriate disk bus is for DCNL the currently configured virtualization technology DCNL Returns the disk bus, or raises an Exception if DCNL the disk dev prefix is unknown.'
def get_next_disk_info(mapping, disk_bus, device_type='disk', last_device=False): DCNL 'Determine the disk info for the next device on disk_bus. DCNL Considering the disks already listed in the disk mapping, DCNL determine the next available disk dev that can be assigned DCNL for the disk bus. DCNL Returns the disk_info for the next available disk.'
def get_disk_mapping(virt_type, instance, disk_bus, cdrom_bus, block_device_info=None, image_meta=None, rescue=False): DCNL 'Determine how to map default disks to the virtual machine. DCNL This is about figuring out whether the default \'disk\', DCNL \'disk.local\', \'disk.swap\' and \'disk.config\' images have DCNL been overriden by the block device mapping. DCNL Returns the guest disk mapping for the devices.'
def get_disk_info(virt_type, instance, block_device_info=None, image_meta=None, rescue=False): DCNL 'Determine guest disk mapping info. DCNL This is a wrapper around get_disk_mapping, which DCNL also returns the chosen disk_bus and cdrom_bus. DCNL The returned data is in a dict DCNL - disk_bus: the bus for harddisks DCNL - cdrom_bus: the bus for CDROMs DCNL - mapping: the disk mapping DCNL Returns the disk mapping disk.'
def get_disk_size(path): DCNL 'Get the (virtual) size of a disk image DCNL :param path: Path to the disk image DCNL :returns: Size (in bytes) of the given disk image as it would be seen DCNL by a virtual machine.'
def extend(image, size): DCNL 'Increase image to size.'
def can_resize_fs(image, size, use_cow=False): DCNL 'Check whether we can resize contained file system.'
def inject_data(image, key=None, net=None, metadata=None, admin_password=None, files=None, partition=None, use_cow=False, mandatory=()): DCNL 'Inject the specified items into a disk image. DCNL If an item name is not specified in the MANDATORY iterable, then a warning DCNL is logged on failure to inject that item, rather than raising an exception. DCNL it will mount the image as a fully partitioned disk and attempt to inject DCNL into the specified partition number. DCNL If PARTITION is not specified the image is mounted as a single partition. DCNL Returns True if all requested operations completed without issue. DCNL Raises an exception if a mandatory item can\'t be injected.'
def setup_container(image, container_dir, use_cow=False): DCNL 'Setup the LXC container. DCNL It will mount the loopback image to the container directory in order DCNL to create the root filesystem for the container.'
def teardown_container(container_dir): DCNL 'Teardown the container rootfs mounting once it is spawned. DCNL It will umount the container that is mounted, DCNL and delete any linked devices.'
def clean_lxc_namespace(container_dir): DCNL 'Clean up the container namespace rootfs mounting one spawned. DCNL It will umount the mounted names that is mounted DCNL but leave the linked deivces alone.'
def inject_data_into_fs(fs, key, net, metadata, admin_password, files, mandatory=()): DCNL 'Injects data into a filesystem already mounted by the caller. DCNL Virt connections can call this directly if they mount their fs DCNL in a different way to inject_data. DCNL If an item name is not specified in the MANDATORY iterable, then a warning DCNL is logged on failure to inject that item, rather than raising an exception. DCNL Returns True if all requested operations completed without issue. DCNL Raises an exception if a mandatory item can\'t be injected.'
def _setup_selinux_for_keys(fs, sshdir): DCNL 'Get selinux guests to ensure correct context on injected keys.'
def _inject_key_into_fs(key, fs): DCNL 'Add the given public ssh key to root\'s authorized_keys. DCNL key is an ssh key string. DCNL fs is the path to the base of the filesystem into which to inject the key.'
def _inject_net_into_fs(net, fs): DCNL 'Inject /etc/network/interfaces into the filesystem rooted at fs. DCNL net is the contents of /etc/network/interfaces.'
def _inject_admin_password_into_fs(admin_passwd, fs): DCNL 'Set the root password to admin_passwd DCNL admin_password is a root password DCNL fs is the path to the base of the filesystem into which to inject DCNL the key. DCNL This method modifies the instance filesystem directly, DCNL and does not require a guest agent running in the instance.'
def _set_passwd(username, admin_passwd, passwd_data, shadow_data): DCNL 'set the password for username to admin_passwd DCNL The passwd_file is not modified.  The shadow_file is updated. DCNL if the username is not found in both files, an exception is raised. DCNL :param username: the username DCNL :param encrypted_passwd: the  encrypted password DCNL :param passwd_file: path to the passwd file DCNL :param shadow_file: path to the shadow password file DCNL :returns: nothing DCNL :raises: exception.NovaException(), IOError()'
def load_compute_driver(virtapi, compute_driver=None): DCNL 'Load a compute driver module. DCNL Load the compute driver module specified by the compute_driver DCNL configuration option or, if supplied, the driver name supplied as an DCNL argument. DCNL Compute drivers constructors take a VirtAPI object as their first object DCNL and this must be supplied. DCNL :param virtapi: a VirtAPI instance DCNL :param compute_driver: a compute driver name to override the config opt DCNL :returns: a ComputeDriver instance'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def model_query(context, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id.'
@sqlalchemy_api.require_admin_context DCNL def bm_node_associate_and_update(context, node_uuid, values): DCNL 'Associate an instance to a node safely DCNL Associate an instance to a node only if that node is not yet assocated. DCNL Allow the caller to set any other fields they require in the same DCNL operation. For example, this is used to set the node\'s task_state to DCNL BUILDING at the beginning of driver.spawn().'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def _update_state(context, node, instance, state): DCNL 'Update the node state in baremetal DB DCNL If instance is not supplied, reset the instance_uuid field for this node.'
def build_pxe_config(deployment_id, deployment_key, deployment_iscsi_iqn, deployment_aki_path, deployment_ari_path, aki_path, ari_path): DCNL 'Build the PXE config file for a node DCNL This method builds the PXE boot configuration file for a node, DCNL given all the required parameters. DCNL The resulting file has both a "deploy" and "boot" label, which correspond DCNL to the two phases of booting. This may be extended later.'
def get_image_dir_path(instance): DCNL 'Generate the dir for an instances disk.'
def get_image_file_path(instance): DCNL 'Generate the full path for an instances disk.'
def get_pxe_config_file_path(instance): DCNL 'Generate the path for an instances PXE config file.'
def get_pxe_mac_path(mac): DCNL 'Convert a MAC address into a PXE config file name.'
def get_tftp_image_info(instance, instance_type): DCNL 'Generate the paths for tftp files for this instance DCNL Raises NovaException if DCNL - instance does not contain kernel_id or ramdisk_id DCNL - deploy_kernel_id or deploy_ramdisk_id can not be read from DCNL instance_type[\'extra_specs\'] and defaults are not set'
def get_network_with_the_name(session, network_name='vmnet0', cluster=None): DCNL 'Gets reference to the network whose name is passed as the DCNL argument.'
def get_vswitch_for_vlan_interface(session, vlan_interface, cluster=None): DCNL 'Gets the vswitch associated with the physical network adapter DCNL with the name supplied.'
def check_if_vlan_interface_exists(session, vlan_interface, cluster=None): DCNL 'Checks if the vlan_interface exists on the esx host.'
def get_vlanid_and_vswitch_for_portgroup(session, pg_name, cluster=None): DCNL 'Get the vlan id and vswicth associated with the port group.'
def create_port_group(session, pg_name, vswitch_name, vlan_id=0, cluster=None): DCNL 'Creates a port group on the host system with the vlan tags DCNL supplied. VLAN id 0 means no vlan id association.'
def build_datastore_path(datastore_name, path): DCNL 'Build the datastore compliant path.'
def split_datastore_path(datastore_path): DCNL 'Split the VMware style datastore path to get the Datastore DCNL name and the entity path.'
def get_vm_create_spec(client_factory, instance, data_store_name, vif_infos, os_type='otherGuest'): DCNL 'Builds the VM Create spec.'
def create_controller_spec(client_factory, key, adapter_type='lsiLogic'): DCNL 'Builds a Config Spec for the LSI or Bus Logic Controller\'s addition DCNL which acts as the controller for the virtual hard disk to be attached DCNL to the VM.'
def create_network_spec(client_factory, vif_info): DCNL 'Builds a config spec for the addition of a new network DCNL adapter to the VM.'
def get_vmdk_attach_config_spec(client_factory, adapter_type='lsiLogic', disk_type='preallocated', file_path=None, disk_size=None, linked_clone=False, controller_key=None, unit_number=None, device_name=None): DCNL 'Builds the vmdk attach config spec.'
def get_vmdk_detach_config_spec(client_factory, device): DCNL 'Builds the vmdk detach config spec.'
def get_vmdk_path_and_adapter_type(hardware_devices): DCNL 'Gets the vmdk file path and the storage adapter type.'
def get_rdm_disk(hardware_devices, uuid): DCNL 'Gets the RDM disk key.'
def get_copy_virtual_disk_spec(client_factory, adapter_type='lsilogic', disk_type='preallocated'): DCNL 'Builds the Virtual Disk copy spec.'
def get_vmdk_create_spec(client_factory, size_in_kb, adapter_type='lsiLogic', disk_type='preallocated'): DCNL 'Builds the virtual disk create spec.'
def get_rdm_create_spec(client_factory, device, adapter_type='lsiLogic', disk_type='rdmp'): DCNL 'Builds the RDM virtual disk create spec.'
def create_virtual_disk_spec(client_factory, controller_key, disk_type='preallocated', file_path=None, disk_size=None, linked_clone=False, unit_number=None, device_name=None): DCNL 'Builds spec for the creation of a new/ attaching of an already existing DCNL Virtual Disk to the VM.'
def delete_virtual_disk_spec(client_factory, device): DCNL 'Builds spec for the deletion of an already existing Virtual Disk from VM.'
def clone_vm_spec(client_factory, location, power_on=False, snapshot=None, template=False): DCNL 'Builds the VM clone spec.'
def relocate_vm_spec(client_factory, datastore=None, host=None, disk_move_type='moveAllDiskBackingsAndAllowSharing'): DCNL 'Builds the VM relocation spec.'
def get_dummy_vm_create_spec(client_factory, name, data_store_name): DCNL 'Builds the dummy VM create spec.'
def get_machine_id_change_spec(client_factory, machine_id_str): DCNL 'Builds the machine id change config spec.'
def get_add_vswitch_port_group_spec(client_factory, vswitch_name, port_group_name, vlan_id): DCNL 'Builds the virtual switch port group add spec.'
def get_vnc_config_spec(client_factory, port, password): DCNL 'Builds the vnc config spec.'
def search_datastore_spec(client_factory, file_name): DCNL 'Builds the datastore search spec.'
def get_vm_ref_from_name(session, vm_name): DCNL 'Get reference to the VM with the name specified.'
def get_cluster_ref_from_name(session, cluster_name): DCNL 'Get reference to the cluster with the name specified.'
def get_host_ref(session, cluster=None): DCNL 'Get reference to a host within the cluster specified.'
def get_datastore_ref_and_name(session, cluster=None, host=None): DCNL 'Get the datastore list and choose the first local storage.'
def start_transfer(context, read_file_handle, data_size, write_file_handle=None, image_service=None, image_id=None, image_meta=None): DCNL 'Start the data transfer from the reader to the writer. DCNL Reader writes to the pipe and the writer reads from the pipe. This means DCNL that the total transfer time boils down to the slower of the read/write DCNL and not the addition of the two times.'
def fetch_image(context, image, instance, **kwargs): DCNL 'Download image from the glance image server.'
def upload_image(context, image, instance, **kwargs): DCNL 'Upload the snapshotted vm disk file to Glance image server.'
def get_vmdk_size_and_properties(context, image, instance): DCNL 'Get size of the vmdk file that is to be downloaded for attach in spawn. DCNL Need this to create the dummy virtual disk for the meta-data file. The DCNL geometry of the disk created depends on the size.'
def build_selection_spec(client_factory, name): DCNL 'Builds the selection spec.'
def build_traversal_spec(client_factory, name, spec_type, path, skip, select_set): DCNL 'Builds the traversal spec object.'
def build_recursive_traversal_spec(client_factory): DCNL 'Builds the Recursive Traversal Spec to traverse the object managed DCNL object hierarchy.'
def build_property_spec(client_factory, type='VirtualMachine', properties_to_collect=None, all_properties=False): DCNL 'Builds the Property Spec.'
def build_object_spec(client_factory, root_folder, traversal_specs): DCNL 'Builds the object Spec.'
def build_property_filter_spec(client_factory, property_specs, object_specs): DCNL 'Builds the Property Filter Spec.'
def get_object_properties(vim, collector, mobj, type, properties): DCNL 'Gets the properties of the Managed object specified.'
def get_dynamic_property(vim, mobj, type, property_name): DCNL 'Gets a particular property of the Managed Object.'
def get_objects(vim, type, properties_to_collect=None, all=False): DCNL 'Gets the list of objects of the type specified.'
def get_prop_spec(client_factory, spec_type, properties): DCNL 'Builds the Property Spec Object.'
def get_obj_spec(client_factory, obj, select_set=None): DCNL 'Builds the Object Spec object.'
def get_prop_filter_spec(client_factory, obj_spec, prop_spec): DCNL 'Builds the Property Filter Spec Object.'
def get_properties_for_a_collection_of_objects(vim, type, obj_list, properties): DCNL 'Gets the list of properties for the collection of DCNL objects of the type specified.'
def ensure_vlan_bridge(session, vif, cluster=None): DCNL 'Create a vlan and bridge unless they already exist.'
def get_host_iqn(session, cluster=None): DCNL 'Return the host iSCSI IQN.'
def find_st(session, data, cluster=None): DCNL 'Return the iSCSI Target given a volume info.'
def rescan_iscsi_hba(session, cluster=None): DCNL 'Rescan the iSCSI HBA to discover iSCSI targets.'
def mountpoint_to_number(mountpoint): DCNL 'Translate a mountpoint like /dev/sdc into a numeric.'
def log_db_contents(msg=None): DCNL 'Log DB Contents.'
def reset(): DCNL 'Resets the db contents.'
def cleanup(): DCNL 'Clear the db contents.'
def _create_object(table, table_obj): DCNL 'Create an object in the db.'
def _get_objects(obj_type): DCNL 'Get objects of the type.'
def _add_file(file_path): DCNL 'Adds a file reference to the  db.'
def _remove_file(file_path): DCNL 'Removes a file reference from the db.'
def fake_plug_vifs(*args, **kwargs): DCNL 'Fakes plugging vifs.'
def fake_get_network(*args, **kwargs): DCNL 'Fake get network.'
def fake_fetch_image(context, image, instance, **kwargs): DCNL 'Fakes fetch image call. Just adds a reference to the db for the file.'
def fake_upload_image(context, image, instance, **kwargs): DCNL 'Fakes the upload of an image.'
def fake_get_vmdk_size_and_properties(context, image_id, instance): DCNL 'Fakes the file size and properties fetch for the image file.'
def _get_vm_mdo(vm_ref): DCNL 'Gets the Virtual Machine with the ref from the db.'
def get_injected_network_template(network_info, use_ipv6=CONF.use_ipv6, template=CONF.injected_network_template): DCNL 'return a rendered network template for the given network_info DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL Note: this code actually depends on the legacy network_info, but will DCNL convert the type itself if necessary.'
@lockutils.synchronized('storage-registry-lock', 'nova-', external=True) DCNL def register_storage_use(storage_path, hostname): DCNL 'Idenfity the id of this instance storage.'
@lockutils.synchronized('storage-registry-lock', 'nova-', external=True) DCNL def get_storage_users(storage_path): DCNL 'Get a list of all the users of this storage path.'
def qemu_img_info(path): DCNL 'Return an object containing the parsed output from qemu-img info.'
def convert_image(source, dest, out_format, run_as_root=False): DCNL 'Convert image to other format.'
def find_network_with_bridge(session, bridge): DCNL 'Return the network on which the bridge is attached, if found. DCNL The bridge is defined in the nova db and can be found either in the DCNL \'bridge\' or \'name_label\' fields of the XenAPI network record.'
def cmp_version(a, b): DCNL 'Compare two version strings (eg 0.0.1.10 > 0.0.1.9).'
def make_step_decorator(context, instance, instance_update): DCNL 'Factory to create a decorator that records instance progress as a series DCNL of discrete steps. DCNL Each time the decorator is invoked we bump the total-step-count, so after:: DCNL @step DCNL def step1(): DCNL @step DCNL def step2(): DCNL we have a total-step-count of 2. DCNL Each time the step-function (not the step-decorator!) is invoked, we bump DCNL the current-step-count by 1, so after:: DCNL step1() DCNL the current-step-count would be 1 giving a progress of ``1 / 2 * DCNL 100`` or 50%.'
def is_hv_pool(metadata): DCNL 'Checks if aggregate is a hypervisor_pool.'
def create_vm(session, instance, name_label, kernel, ramdisk, use_pv_kernel=False): DCNL 'Create a VM record.  Returns new VM reference. DCNL the use_pv_kernel flag indicates whether the guest is HVM or PV DCNL There are 3 scenarios: DCNL 1. Using paravirtualization, kernel passed in DCNL 2. Using paravirtualization, kernel within the image DCNL 3. Using hardware virtualization'
def destroy_vm(session, instance, vm_ref): DCNL 'Destroys a VM record.'
def find_vbd_by_number(session, vm_ref, number): DCNL 'Get the VBD reference from the device number.'
def unplug_vbd(session, vbd_ref): DCNL 'Unplug VBD from VM.'
def destroy_vbd(session, vbd_ref): DCNL 'Destroy VBD from host database.'
def create_vbd(session, vm_ref, vdi_ref, userdevice, vbd_type='disk', read_only=False, bootable=False, osvol=False): DCNL 'Create a VBD record and returns its reference.'
def safe_destroy_vdis(session, vdi_refs): DCNL 'Destroys the requested VDIs, logging any StorageError exceptions.'
def create_vdi(session, sr_ref, instance, name_label, disk_type, virtual_size, read_only=False): DCNL 'Create a VDI record and returns its reference.'
@contextlib.contextmanager DCNL def _dummy_vm(session, instance, vdi_ref): DCNL 'This creates a temporary VM so that we can snapshot a VDI. DCNL VDI\'s can\'t be snapshotted directly since the API expects a `vm_ref`. To DCNL work around this, we need to create a temporary VM and then map the VDI to DCNL the VM using a temporary VBD.'
def _safe_copy_vdi(session, sr_ref, instance, vdi_to_copy_ref): DCNL 'Copy a VDI and return the new VDIs reference. DCNL This function differs from the XenAPI `VDI.copy` call in that the copy is DCNL atomic and isolated, meaning we don\'t see half-downloaded images. It DCNL accomplishes this by copying the VDI\'s into a temporary directory and then DCNL atomically renaming them into the SR when the copy is completed. DCNL The correct long term solution is to fix `VDI.copy` so that it is atomic DCNL and isolated.'
def _clone_vdi(session, vdi_to_clone_ref): DCNL 'Clones a VDI and return the new VDIs reference.'
def get_vdi_for_vm_safely(session, vm_ref): DCNL 'Retrieves the primary VDI for a VM.'
def get_sr_path(session): DCNL 'Return the path to our storage repository DCNL This is used when we\'re dealing with VHDs directly, either by taking DCNL snapshots or by restoring an image in the DISK_VHD format.'
def destroy_cached_images(session, sr_ref, all_cached=False, dry_run=False): DCNL 'Destroy used or unused cached images. DCNL A cached image that is being used by at least one VM is said to be \'used\'. DCNL In the case of an \'unused\' image, the cached image will be the only DCNL descendent of the base-copy. So when we delete the cached-image, the DCNL refcount will drop to zero and XenServer will automatically destroy the DCNL base-copy for us. DCNL The default behavior of this function is to destroy only \'unused\' cached DCNL images. To destroy all cached images, use the `all_cached=True` kwarg.'
def _find_cached_images(session, sr_ref): DCNL 'Return a dict(uuid=vdi_ref) representing all cached images.'
def _find_cached_image(session, image_id, sr_ref): DCNL 'Returns the vdi-ref of the cached image.'
def auto_configure_disk(session, vdi_ref, new_gb): DCNL 'Partition and resize FS to match the size specified by DCNL instance_types.root_gb. DCNL This is a fail-safe to prevent accidentally destroying data on a disk DCNL erroneously marked as auto_disk_config=True. DCNL The criteria for allowing resize are: DCNL 1. \'auto_disk_config\' must be true for the instance (and image). DCNL (If we\'ve made it here, then auto_disk_config=True.) DCNL 2. The disk must have only one partition. DCNL 3. The file-system on the one partition must be ext3 or ext4.'
def _generate_disk(session, instance, vm_ref, userdevice, name_label, disk_type, size_mb, fs_type): DCNL 'Steps to programmatically generate a disk: DCNL 1. Create VDI of desired size DCNL 2. Attach VDI to compute worker DCNL 3. Create partition DCNL 4. Create VBD between instance VM and VDI'
def create_kernel_image(context, session, instance, name_label, image_id, image_type): DCNL 'Creates kernel/ramdisk file from the image stored in the cache. DCNL If the image is not present in the cache, it streams it from glance. DCNL Returns: A list of dictionaries that describe VDIs'
def _create_image(context, session, instance, name_label, image_id, image_type): DCNL 'Creates VDI from the image stored in the local cache. If the image DCNL is not present in the cache, it streams it from glance. DCNL Returns: A list of dictionaries that describe VDIs'
def _fetch_image(context, session, instance, name_label, image_id, image_type): DCNL 'Fetch image from glance based on image type. DCNL Returns: A single filename if image_type is KERNEL or RAMDISK DCNL A list of dictionaries that describe VDIs, otherwise'
def _fetch_vhd_image(context, session, instance, image_id): DCNL 'Tell glance to download an image and put the VHDs into the SR DCNL Returns: A list of dictionaries that describe VDIs'
def _get_vdi_chain_size(session, vdi_uuid): DCNL 'Compute the total size of a VDI chain, starting with the specified DCNL VDI UUID. DCNL This will walk the VDI chain to the root, add the size of each VDI into DCNL the total.'
def _fetch_disk_image(context, session, instance, name_label, image_id, image_type): DCNL 'Fetch the image from Glance DCNL NOTE: DCNL Unlike _fetch_vhd_image, this method does not use the Glance DCNL plugin; instead, it streams the disks through domU to the VDI DCNL directly. DCNL Returns: A single filename if image_type is KERNEL_RAMDISK DCNL A list of dictionaries that describe VDIs, otherwise'
def determine_disk_image_type(image_meta): DCNL 'Disk Image Types are used to determine where the kernel will reside DCNL within an image. To figure out which type we\'re dealing with, we use DCNL the following rules: DCNL 1. If we\'re using Glance, we can use the image_type field to DCNL determine the image_type DCNL 2. If we\'re not using Glance, then we need to deduce this based on DCNL whether a kernel_id is specified.'
def determine_is_pv(session, vdi_ref, disk_image_type, os_type): DCNL 'Determine whether the VM will use a paravirtualized kernel or if it DCNL will use hardware virtualization. DCNL 1. Glance (VHD): then we use `os_type`, raise if not set DCNL 2. Glance (DISK_RAW): use Pygrub to figure out if pv kernel is DCNL available DCNL 3. Glance (DISK): pv is assumed DCNL 4. Glance (DISK_ISO): no pv is assumed DCNL 5. Boot From Volume - without image metadata (None): attempt to DCNL use Pygrub to figure out if the volume stores a PV VM or a DCNL HVM one. Log a warning, because there may be cases where the DCNL volume is RAW (in which case using pygrub is fine) and cases DCNL where the content of the volume is VHD, and pygrub might not DCNL work as expected. DCNL NOTE: if disk_image_type is not specified, instances launched DCNL from remote volumes will have to include kernel and ramdisk DCNL because external kernel and ramdisk will not be fetched.'
def lookup_vm_vdis(session, vm_ref): DCNL 'Look for the VDIs that are attached to the VM.'
def lookup(session, name_label): DCNL 'Look the instance up and return it if available.'
def preconfigure_instance(session, instance, vdi_ref, network_info): DCNL 'Makes alterations to the image before launching as part of spawn.'
def compile_info(record): DCNL 'Fill record with VM status information.'
def compile_diagnostics(record): DCNL 'Compile VM diagnostics data.'
def compile_metrics(start_time, stop_time=None): DCNL 'Compile bandwidth usage, cpu, and disk metrics for all VMs on DCNL this host. DCNL Note that some stats, like bandwidth, do not seem to be very DCNL accurate in some of the data from XenServer (mdragon).'
def _scan_sr(session, sr_ref=None): DCNL 'Scans the SR specified by sr_ref.'
def scan_default_sr(session): DCNL 'Looks for the system default SR and triggers a re-scan.'
def safe_find_sr(session): DCNL 'Same as _find_sr except raises a NotFound exception if SR cannot be DCNL determined'
def _find_sr(session): DCNL 'Return the storage repository to hold VM images.'
def _safe_find_iso_sr(session): DCNL 'Same as _find_iso_sr except raises a NotFound exception if SR DCNL cannot be determined'
def _find_iso_sr(session): DCNL 'Return the storage repository to hold ISO images.'
def _get_rrd_server(): DCNL 'Return server\'s scheme and address to use for retrieving RRD XMLs.'
def _get_rrd(server, vm_uuid): DCNL 'Return the VM RRD XML as a string.'
def _get_rrd_updates(server, start_time): DCNL 'Return the RRD updates XML as a string.'
def get_instance_vdis_for_sr(session, vm_ref, sr_ref): DCNL 'Return opaqueRef for all the vdis which live on sr.'
def _walk_vdi_chain(session, vdi_uuid): DCNL 'Yield vdi_recs for each element in a VDI chain.'
def _child_vhds(session, sr_ref, vdi_uuid): DCNL 'Return the immediate children of a given VHD. DCNL This is not recursive, only the immediate children are returned.'
def _wait_for_vhd_coalesce(session, instance, sr_ref, vdi_ref, original_parent_uuid): DCNL 'Spin until the parent VHD is coalesced into its parent VHD DCNL Before coalesce: DCNL * original_parent_vhd DCNL * parent_vhd DCNL snapshot DCNL After coalesce: DCNL * parent_vhd DCNL snapshot'
def _remap_vbd_dev(dev): DCNL 'Return the appropriate location for a plugged-in VBD device DCNL Ubuntu Maverick moved xvd? -> sd?. This is considered a bug and will be DCNL fixed in future versions: DCNL https://bugs.launchpad.net/ubuntu/+source/linux/+bug/684875 DCNL For now, we work around it by just doing a string replace.'
def _wait_for_device(dev): DCNL 'Wait for device node to appear.'
def cleanup_attached_vdis(session): DCNL 'Unplug any instance VDIs left after an unclean restart.'
def _get_partitions(dev): DCNL 'Return partition information (num, size, type) for a device.'
def _resize_part_and_fs(dev, start, old_sectors, new_sectors): DCNL 'Resize partition and fileystem. DCNL This assumes we are dealing with a single primary partition and using DCNL ext3 or ext4.'
def _sparse_copy(src_path, dst_path, virtual_size, block_size=4096): DCNL 'Copy data, skipping long runs of zeros to create a sparse file.'
def _mount_filesystem(dev_path, dir): DCNL 'mounts the device specified by dev_path in dir.'
def _mounted_processing(device, key, net, metadata): DCNL 'Callback which runs with the image VDI attached.'
def _prepare_injectables(inst, network_info): DCNL 'prepares the ssh key and the network configuration file to be DCNL injected into the disk image'
def ensure_correct_host(session): DCNL 'Ensure we\'re connected to the host we\'re running on. This is the DCNL required configuration for anything that uses vdi_attached_here.'
def move_disks(session, instance, disk_info): DCNL 'Move and possibly link VHDs via the XAPI plugin.'
def forget_sr(session, sr_ref): DCNL 'Forgets the storage repository without destroying the VDIs within'
def find_sr_by_uuid(session, sr_uuid): DCNL 'Return the storage repository given a uuid.'
def find_sr_from_vbd(session, vbd_ref): DCNL 'Find the SR reference from the VBD reference.'
def introduce_vdi(session, sr_ref, vdi_uuid=None, target_lun=None): DCNL 'Introduce VDI in the host.'
def parse_volume_info(connection_data): DCNL 'Parse device_path and mountpoint as they can be used by XenAPI. DCNL In particular, the mountpoint (e.g. /dev/sdc) must be translated DCNL into a numeric literal.'
def mountpoint_to_number(mountpoint): DCNL 'Translate a mountpoint like /dev/sdc into a numeric.'
def _get_volume_id(path_or_id): DCNL 'Retrieve the volume id from device_path.'
def _get_target_host(iscsi_string): DCNL 'Retrieve target host.'
def _get_target_port(iscsi_string): DCNL 'Retrieve target port.'
def _call_agent(session, instance, vm_ref, method, addl_args=None, timeout=None): DCNL 'Abstracts out the interaction with the agent xenapi plugin.'
def find_guest_agent(base_dir): DCNL 'tries to locate a guest agent at the path DCNL specificed by agent_rel_path'
def swap_xapi_host(url, host_addr): DCNL 'Replace the XenServer address present in \'url\' with \'host_addr\'.'
def call_xenhost(session, method, arg_dict): DCNL 'There will be several methods that will need this general DCNL handling for interacting with the xenhost plugin, so this abstracts DCNL out that behavior.'
def _uuid_find(virtapi, context, host, name_label): DCNL 'Return instance uuid by name_label.'
def _host_find(context, session, src_aggregate, dst): DCNL 'Return the host from the xenapi host reference. DCNL :param src_aggregate: the aggregate that the compute host being put in DCNL maintenance (source of VMs) belongs to DCNL :param dst: the hypervisor host reference (destination of VMs) DCNL :return: the compute host that manages dst'
def after_VBD_create(vbd_ref, vbd_rec): DCNL 'Create read-only fields and backref from VM and VDI to VBD when VBD DCNL is created.'
def after_VM_create(vm_ref, vm_rec): DCNL 'Create read-only fields in the VM record.'
def create_local_pifs(): DCNL 'Adds a PIF for each to the local database with VLAN=-1. DCNL Do this one per host.'
def create_local_srs(): DCNL 'Create an SR that looks like the one created on the local disk by DCNL default by the XenServer installer.  Do this one per host. Also, fake DCNL the installation of an ISO SR.'
def as_value(s): DCNL 'Helper function for simulating XenAPI plugin responses.  It DCNL escapes and wraps the given argument.'
def as_json(*args, **kwargs): DCNL 'Helper function for simulating XenAPI plugin responses for those DCNL that are returning JSON.  If this function is given plain arguments, DCNL then these are rendered as a JSON list.  If it\'s given keyword DCNL arguments then these are rendered as a JSON dict.'
def set_nodes(nodes): DCNL 'Sets FakeDriver\'s node.list. DCNL It has effect on the following methods: DCNL get_available_nodes() DCNL get_available_resource DCNL get_host_stats() DCNL To restore the change, call restore_nodes()'
def restore_nodes(): DCNL 'Resets FakeDriver\'s node list modified by set_nodes(). DCNL Usually called from tearDown().'
def instance_update_db(context, instance_uuid, extra_values=None): DCNL 'Clear the host and node - set the scheduled_at field of an Instance. DCNL :returns: An Instance with the updated fields set properly.'
def encode_instance(instance, local=True): DCNL 'Encode locally created instance for return via RPC.'
def new_host_state(self, host, node, capabilities=None, service=None): DCNL 'Returns an instance of BaremetalHostState or HostState according to DCNL capabilities. If \'baremetal_driver\' is in capabilities, it returns an DCNL instance of BaremetalHostState. If not, returns an instance of HostState.'
def all_weighers(): DCNL 'Return a list of weight plugin classes found in this directory.'
def noop_cost_fn(host_state, weight_properties): DCNL 'Return a pre-weight cost of 1 for each host.'
def compute_fill_first_cost_fn(host_state, weight_properties): DCNL 'Higher weights win, so we should return a lower weight DCNL when there\'s more free ram available. DCNL Note: the weight modifier for this function in default configuration DCNL is -1.0. With -1.0 this function runs in reverse, so systems DCNL with the most free memory will be preferred.'
def _get_cost_functions(): DCNL 'Returns a list of tuples containing weights and cost functions to DCNL use for weighing hosts'
def all_filters(): DCNL 'Return a list of filter classes found in this directory. DCNL This method is used as the default for available scheduler filters DCNL and should return a list of all filter classes available.'
def standard_filters(): DCNL 'Deprecated.  Configs should change to use all_filters().'
def properties_root_device_name(properties): DCNL 'get root device name from image meta data. DCNL If it isn\'t specified, return None.'
def mappings_prepend_dev(mappings): DCNL 'Prepend \'/dev/\' to \'device\' entry of swap/ephemeral virtual type.'
def strip_dev(device_name): DCNL 'remove leading \'/dev/\'.'
def strip_prefix(device_name): DCNL 'remove both leading /dev/ and xvd or sd or vd.'
def match_device(device): DCNL 'Matches device name and returns prefix, suffix.'
def is_user_context(context): DCNL 'Indicates if the request context is a normal user.'
def require_admin_context(ctxt): DCNL 'Raise exception.AdminRequired() if context is an admin context.'
def require_context(ctxt): DCNL 'Raise exception.NotAuthorized() if context is not a user or an DCNL admin context.'
def authorize_project_context(context, project_id): DCNL 'Ensures a request has permission to access the given project.'
def authorize_user_context(context, user_id): DCNL 'Ensures a request has permission to access the given user.'
def authorize_quota_class_context(context, class_name): DCNL 'Ensures a request has permission to access the given quota class.'
def _untranslate_volume_summary_view(context, vol): DCNL 'Maps keys for volumes summary view.'
def _untranslate_snapshot_summary_view(context, snapshot): DCNL 'Maps keys for snapshots summary view.'
def add_instance_fault_from_exc(context, conductor, instance, fault, exc_info=None): DCNL 'Adds the specified fault to the database.'
def get_device_name_for_instance(context, instance, bdms, device): DCNL 'Validates (or generates) a device name for instance. DCNL If device is not set, it will generate a unique device appropriate DCNL for the instance. It uses the block device mapping table to find DCNL valid device names. If the device name is valid but applicable to DCNL a different backend (for example /dev/vdc is specified but the DCNL backend uses /dev/xvdc), the device name will be converted to the DCNL appropriate format.'
def notify_usage_exists(context, instance_ref, current_period=False, ignore_missing_network_data=True, system_metadata=None, extra_usage_info=None): DCNL 'Generates \'exists\' notification for an instance for usage auditing DCNL purposes. DCNL :param current_period: if True, this will generate a usage for the DCNL current usage period; if False, this will generate a usage for the DCNL previous audit period. DCNL :param ignore_missing_network_data: if True, log any exceptions generated DCNL while getting network info; if False, raise the exception. DCNL :param system_metadata: system_metadata DB entries for the instance, DCNL if not None.  *NOTE*: Currently unused here in trunk, but needed for DCNL potential custom modifications. DCNL :param extra_usage_info: Dictionary containing extra values to add or DCNL override in the notification if not None.'
def notify_about_instance_usage(context, instance, event_suffix, network_info=None, system_metadata=None, extra_usage_info=None, host=None): DCNL 'Send a notification about an instance. DCNL :param event_suffix: Event type like "delete.start" or "exists" DCNL :param network_info: Networking information, if provided. DCNL :param system_metadata: system_metadata DB entries for the instance, DCNL if provided. DCNL :param extra_usage_info: Dictionary containing extra values to add or DCNL override in the notification. DCNL :param host: Compute host for the instance, if specified.  Default is DCNL CONF.host'
def HostAPI(*args, **kwargs): DCNL 'Returns the \'HostAPI\' class from the same module as the configured compute DCNL api'
def InstanceActionAPI(*args, **kwargs): DCNL 'Returns the \'InstanceActionAPI\' class from the same module as the DCNL configured compute api.'
def reverts_task_state(function): DCNL 'Decorator to revert task_state on failure.'
def wrap_instance_fault(function): DCNL 'Wraps a method to catch exceptions related to instances. DCNL This decorator wraps a method to catch any exceptions having to do with DCNL an instance that may get thrown. It then logs an instance fault in the db.'
def wrap_instance_event(function): DCNL 'Wraps a method to log the event taken on the instance, and result. DCNL This decorator wraps a method to log the start and result of an event, as DCNL part of an action taken on an instance.'
def check_instance_state(vm_state=None, task_state=(None,)): DCNL 'Decorator to check VM and/or task state before entry to API functions. DCNL If the instance is in the wrong state, the wrapper will raise an exception.'
def policy_decorator(scope): DCNL 'Check corresponding policy prior of wrapped method to execution.'
def create(name, memory, vcpus, root_gb, ephemeral_gb=None, flavorid=None, swap=None, rxtx_factor=None, is_public=True): DCNL 'Creates instance types.'
def destroy(name): DCNL 'Marks instance types as deleted.'
def get_all_types(ctxt=None, inactive=False, filters=None): DCNL 'Get all non-deleted instance_types. DCNL Pass true as argument if you want deleted instance types returned also.'
def get_default_instance_type(): DCNL 'Get the default instance type.'
def get_instance_type(instance_type_id, ctxt=None, inactive=False): DCNL 'Retrieves single instance type by id.'
def get_instance_type_by_name(name, ctxt=None): DCNL 'Retrieves single instance type by name.'
def get_instance_type_by_flavor_id(flavorid, ctxt=None, read_deleted='yes'): DCNL 'Retrieve instance type by flavorid. DCNL :raises: FlavorNotFound'
def get_instance_type_access_by_flavor_id(flavorid, ctxt=None): DCNL 'Retrieve instance type access list by flavor id.'
def add_instance_type_access(flavorid, projectid, ctxt=None): DCNL 'Add instance type access for project.'
def remove_instance_type_access(flavorid, projectid, ctxt=None): DCNL 'Remove instance type access for project.'
def extract_instance_type(instance, prefix=''): DCNL 'Create an InstanceType-like object from instance\'s system_metadata DCNL information.'
def save_instance_type_info(metadata, instance_type, prefix=''): DCNL 'Save properties from instance_type into instance\'s system_metadata, DCNL in the format of: DCNL [prefix]instance_type_[key] DCNL This can be used to update system_metadata in place from a type, as well DCNL as stash information about another instance_type for later use (such as DCNL during resize).'
def delete_instance_type_info(metadata, *prefixes): DCNL 'Delete instance_type information from instance\'s system_metadata DCNL by prefix.'
def _compute_topic(topic, ctxt, host, instance): DCNL 'Get the topic to use for a message. DCNL :param topic: the base topic DCNL :param ctxt: request context DCNL :param host: explicit host to send the message to. DCNL :param instance: If an explicit host was not specified, use DCNL instance[\'host\'] DCNL :returns: A topic string'
def _reverse_path(path): DCNL 'Reverse a path.  Used for sending responses upstream.'
def _response_cell_name_from_path(routing_path, neighbor_only=False): DCNL 'Reverse the routing_path.  If we only want to send to our parent, DCNL set neighbor_only to True.'
def get_instances_to_sync(context, updated_since=None, project_id=None, deleted=True, shuffle=False, uuids_only=False): DCNL 'Return a generator that will return a list of active and DCNL deleted instances to sync with parent cells.  The list may DCNL optionally be shuffled for periodic updates so that multiple DCNL cells services aren\'t self-healing the same instances in nearly DCNL lockstep.'
def cell_with_item(cell_name, item): DCNL 'Turn cell_name and item into <cell_name>@<item>.'
def split_cell_and_item(cell_and_item): DCNL 'Split a combined cell@item and return them.'
def add_cell_to_compute_node(compute_node, cell_name): DCNL 'Fix compute_node attributes that should be unique.  Allows DCNL API cell to query the \'id\' by cell@id.'
def add_cell_to_service(service, cell_name): DCNL 'Fix service attributes that should be unique.  Allows DCNL API cell to query the \'id\' or \'host\' by cell@id/host.'
def add_cell_to_task_log(task_log, cell_name): DCNL 'Fix task_log attributes that should be unique.  In particular, DCNL the \'id\' and \'host\' fields should be prepended with cell name.'
def sync_from_db(f): DCNL 'Use as a decorator to wrap methods that use cell information to DCNL make sure they sync the latest information from the DB periodically.'
def get_binary_name(): DCNL 'Grab the name of the binary we\'re running in.'
def metadata_forward(): DCNL 'Create forwarding rule for metadata.'
def metadata_accept(): DCNL 'Create the filter accept rule for metadata.'
def init_host(ip_range=None): DCNL 'Basic networking setup goes here.'
def bind_floating_ip(floating_ip, device): DCNL 'Bind ip to public interface.'
def unbind_floating_ip(floating_ip, device): DCNL 'Unbind a public ip from public interface.'
def ensure_metadata_ip(): DCNL 'Sets up local metadata ip.'
def ensure_vpn_forward(public_ip, port, private_ip): DCNL 'Sets up forwarding rules for vlan.'
def ensure_floating_forward(floating_ip, fixed_ip, device, network): DCNL 'Ensure floating ip forwarding rule.'
def remove_floating_forward(floating_ip, fixed_ip, device, network): DCNL 'Remove forwarding for floating ip.'
def floating_ebtables_rules(fixed_ip, network): DCNL 'Makes sure only in-network traffic is bridged.'
def get_dhcp_leases(context, network_ref): DCNL 'Return a network\'s hosts config in dnsmasq leasefile format.'
def get_dhcp_hosts(context, network_ref): DCNL 'Get network\'s hosts config in dhcp-host format.'
def get_dns_hosts(context, network_ref): DCNL 'Get network\'s DNS hosts in hosts format.'
def _add_dnsmasq_accept_rules(dev): DCNL 'Allow DHCP and DNS traffic through to dnsmasq.'
def _remove_dnsmasq_accept_rules(dev): DCNL 'Remove DHCP and DNS traffic allowed through to dnsmasq.'
def get_dhcp_opts(context, network_ref): DCNL 'Get network\'s hosts config in dhcp-opts format.'
@lockutils.synchronized('dnsmasq_start', 'nova-') DCNL def restart_dhcp(context, dev, network_ref): DCNL '(Re)starts a dnsmasq server for a given network. DCNL If a dnsmasq instance is already running then send a HUP DCNL signal causing it to reload, otherwise spawn a new instance.'
def _host_lease(data): DCNL 'Return a host string for an address in leasefile format.'
def _host_dhcp(data): DCNL 'Return a host string for an address in dhcp-host format.'
def _host_dhcp_opts(data): DCNL 'Return an empty gateway option.'
def _execute(*cmd, **kwargs): DCNL 'Wrapper around utils._execute for fake_network.'
def device_exists(device): DCNL 'Check if ethernet device exists.'
def _dhcp_file(dev, kind): DCNL 'Return path to a pid, leases, hosts or conf file for a bridge/device.'
def _ra_file(dev, kind): DCNL 'Return path to a pid or conf file for a bridge/device.'
def _dnsmasq_pid_for(dev): DCNL 'Returns the pid for prior dnsmasq instance for a bridge/device. DCNL Returns None if no pid file exists. DCNL If machine has rebooted pid might be incorrect (caller should check).'
def _ra_pid_for(dev): DCNL 'Returns the pid for prior radvd instance for a bridge/device. DCNL Returns None if no pid file exists. DCNL If machine has rebooted pid might be incorrect (caller should check).'
def _ip_bridge_cmd(action, params, device): DCNL 'Build commands to add/del ips to bridges/devices.'
def _create_veth_pair(dev1_name, dev2_name): DCNL 'Create a pair of veth devices with the specified names, DCNL deleting any previous devices with those names.'
def _ensure_requested_network_ordering(accessor, unordered, preferred): DCNL 'Sort a list with respect to the preferred network ordering.'
def refresh_cache(f): DCNL 'Decorator to update the instance_info_cache DCNL Requires context and instance as function args'
def wrap_check_policy(func): DCNL 'Check policy corresponding to the wrapped methods prior to execution.'
def make_subprocess(cmdline, stdout=False, stderr=False, stdin=False, universal_newlines=False): DCNL 'Make a subprocess according to the given command-line string'
def finish_subprocess(proc, cmdline, ok_exit_codes=None): DCNL 'Ensure that the process returned a zero exit code indicating success'
def make_staging_area(sr_path): DCNL 'The staging area is a place where we can temporarily store and DCNL manipulate VHDs. The use of the staging area is different for upload and DCNL download: DCNL Download DCNL When we download the tarball, the VHDs contained within will have names DCNL like "snap.vhd" and "image.vhd". We need to assign UUIDs to them before DCNL moving them into the SR. However, since \'image.vhd\' may be a base_copy, we DCNL need to link it to \'snap.vhd\' (using vhd-util modify) before moving both DCNL into the SR (otherwise the SR.scan will cause \'image.vhd\' to be deleted). DCNL The staging area gives us a place to perform these operations before they DCNL are moved to the SR, scanned, and then registered with XenServer. DCNL Upload DCNL On upload, we want to rename the VHDs to reflect what they are, \'snap.vhd\' DCNL in the case of the snapshot VHD, and \'image.vhd\' in the case of the DCNL base_copy. The staging area provides a directory in which we can create DCNL hard-links to rename the VHDs without affecting what\'s in the SR. DCNL NOTE DCNL The staging area is created as a subdirectory within the SR in order to DCNL guarantee that it resides within the same filesystem and therefore permit DCNL hard-linking and cheap file moves.'
def cleanup_staging_area(staging_path): DCNL 'Remove staging area directory DCNL On upload, the staging area contains hard-links to the VHDs in the SR; DCNL it\'s safe to remove the staging-area because the SR will keep the link DCNL count > 0 (so the VHDs in the SR will not be deleted).'
def _handle_old_style_images(staging_path): DCNL 'Rename files to conform to new image format, if needed. DCNL Old-Style: DCNL snap.vhd -> image.vhd -> base.vhd DCNL New-Style: DCNL 0.vhd -> 1.vhd -> ... (n-1).vhd DCNL The New-Style format has the benefit of being able to support a VDI chain DCNL of arbitrary length.'
def _assert_vhd_not_hidden(path): DCNL 'Sanity check to ensure that only appropriate VHDs are marked as hidden. DCNL If this flag is incorrectly set, then when we move the VHD into the SR, it DCNL will be deleted out from under us.'
def _validate_footer_timestamp(vdi_path): DCNL 'This check ensures that the timestamps listed in the VHD footer aren\'t in DCNL the future.  This can occur during a migration if the clocks on the the two DCNL Dom0\'s are out-of-sync. This would corrupt the SR if it were imported, so DCNL generate an exception to bail.'
def _validate_vdi_chain(vdi_path): DCNL 'This check ensures that the parent pointers on the VHDs are valid DCNL before we move the VDI chain to the SR. This is *very* important DCNL because a bad parent pointer will corrupt the SR causing a cascade of DCNL failures.'
def _validate_sequenced_vhds(staging_path): DCNL 'This check ensures that the VHDs in the staging area are sequenced DCNL properly from 0 to n-1 with no gaps.'
def import_vhds(sr_path, staging_path, uuid_stack): DCNL 'Move VHDs from staging area into the SR. DCNL The staging area is necessary because we need to perform some fixups DCNL (assigning UUIDs, relinking the VHD chain) before moving into the SR, DCNL otherwise the SR manager process could potentially delete the VHDs out from DCNL under us. DCNL Returns: A dict of imported VHDs: DCNL {\'root\': {\'uuid\': \'ffff-aaaa\'}}'
def prepare_staging_area(sr_path, staging_path, vdi_uuids, seq_num=0): DCNL 'Hard-link VHDs into staging area.'
def create_tarball(fileobj, path, callback=None): DCNL 'Create a tarball from a given path. DCNL :param fileobj: a file-like object holding the tarball byte-stream. DCNL If None, then only the callback will be used. DCNL :param path: path to create tarball from DCNL :param callback: optional callback to call on each chunk written'
def extract_tarball(fileobj, path, callback=None): DCNL 'Extract a tarball to a given path. DCNL :param fileobj: a file-like object holding the tarball byte-stream DCNL :param path: path to extract tarball into DCNL :param callback: optional callback to call on each chunk read'
def register_plugin_calls(*funcs): DCNL 'Wrapper around XenAPIPlugin.dispatch which handles pickle DCNL serialization.'
def _record_exists(arg_dict): DCNL 'Returns whether or not the given record exists. The record path DCNL is determined from the given path and dom_id in the arg_dict.'
@jsonify DCNL def read_record(self, arg_dict): DCNL 'Returns the value stored at the given path for the given dom_id. DCNL These must be encoded as key/value pairs in arg_dict. You can DCNL optinally include a key \'ignore_missing_path\'; if this is present DCNL and boolean True, attempting to read a non-existent path will return DCNL the string \'None\' instead of raising an exception.'
@jsonify DCNL def write_record(self, arg_dict): DCNL 'Writes to xenstore at the specified path. If there is information DCNL already stored in that location, it is overwritten. As in read_record, DCNL the dom_id and path must be specified in the arg_dict; additionally, DCNL you must specify a \'value\' key, whose value must be a string. Typically, DCNL you can json-ify more complex values and store the json output.'
@jsonify DCNL def list_records(self, arg_dict): DCNL 'Returns all the stored data at or below the given path for the DCNL given dom_id. The data is returned as a json-ified dict, with the DCNL path as the key and the stored value as the value. If the path DCNL doesn\'t exist, an empty dict is returned.'
@jsonify DCNL def delete_record(self, arg_dict): DCNL 'Just like it sounds: it removes the record for the specified DCNL VM and the specified path from xenstore.'
def _paths_from_ls(recs): DCNL 'The xenstore-ls command returns a listing that isn\'t terribly DCNL useful. This method cleans that up into a dict with each path DCNL as the key, and the associated string as the value.'
def _run_command(cmd): DCNL 'Abstracts out the basics of issuing system commands. If the command DCNL returns anything in stderr, a PluginError is raised with that information. DCNL Otherwise, a tuple of (return code, stdout data) is returned.'
def validate_exists(args, key, default=None): DCNL 'Validates that a string argument to a RPC method call is given, and DCNL matches the shell-safe regex, with an optional default value in case it DCNL does not exist. DCNL Returns the string.'
def validate_bool(args, key, default=None): DCNL 'Validates that a string argument to a RPC method call is a boolean DCNL string, with an optional default value in case it does not exist. DCNL Returns the python boolean value.'
def exists(args, key): DCNL 'Validates that a freeform string argument to a RPC method call is given. DCNL Returns the string.'
def optional(args, key): DCNL 'If the given key is in args, return the corresponding value, otherwise DCNL return None'
def vbd_unplug_with_retry(session, vbd): DCNL 'Call VBD.unplug on the given VBD, with a retry if we get DCNL DEVICE_DETACH_REJECTED.  For reasons which I don\'t understand, we\'re DCNL seeing the device still in use, even when all processes using the device DCNL should be dead.'
def execute_get_output(*command): DCNL 'Execute and return stdout.'
def execute(*command): DCNL 'Execute without returning stdout.'
def connect_ec2(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ec2.connection.EC2Connection` DCNL :return: A connection to Amazon\'s EC2'
def is_log_callfunc(n): DCNL 'LOG.xxx(\'hello %s\' % xyz) and LOG(\'hello\')'
def is_log_i18n_msg_with_mod(n): DCNL 'LOG.xxx("Hello %s" % xyz) should be LOG.xxx("Hello %s", xyz)'
def is_wrong_i18n_format(n): DCNL 'Check _(\'hello %s\' % xyz)'
def is_localized(node): DCNL 'Check message wrapped by _()'
def setup_logging(conf): DCNL 'Sets up the logging options for a log with supplied name DCNL :param conf: a cfg.ConfOpts object'
def load_paste_app(app_name): DCNL 'Builds and returns a WSGI app from a paste config file. DCNL :param app_name: Name of the application to load DCNL :raises RuntimeError when config file cannot be located or application DCNL cannot be loaded from config file'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def find_config_file(options, config_file): DCNL 'Return the first config file found. DCNL We search for the paste config file in the following order: DCNL * If --config-file option is used, use that DCNL * Search for the configuration files via common cfg directories DCNL :retval Full path to config file, or None if no config file found'
def parse_mappings(mapping_list, unique_values=True): DCNL 'Parse a list of of mapping strings into a dictionary. DCNL :param mapping_list: a list of strings of the form \'<key>:<value>\' DCNL :param unique_values: values must be unique if True DCNL :returns: a dict mapping keys to values'
def compare_elements(a, b): DCNL 'compare elements if a and b have same elements DCNL This method doesn\'t consider ordering'
def get_topic_name(prefix, table, operation): DCNL 'Create a topic name. DCNL The topic name needs to be synced between the agent and the DCNL plugin. The plugin will send a fanout message to all of the DCNL listening agents so that the agents in turn can perform their DCNL updates accordingly. DCNL :param prefix: Common prefix for the plugin/agent message queues. DCNL :param table: The table in question (NETWORK, SUBNET, PORT). DCNL :param operation: The operation that invokes notification (CREATE, DCNL DELETE, UPDATE) DCNL :returns: The topic name.'
def plugin_aware_extension_middleware_factory(global_config, **local_config): DCNL 'Paste factory.'
def Resource(controller, faults=None, deserializers=None, serializers=None): DCNL 'Represents an API entity resource and the associated serialization and DCNL deserialization logic'
def _verify_dict_keys(expected_keys, target_dict, strict=True): DCNL 'Allows to verify keys in a dictionary. DCNL :param expected_keys: A list of keys expected to be present. DCNL :param target_dict: The dictionary which should be verified. DCNL :param strict: Specifies whether additional keys are allowed to be present. DCNL :return: True, if keys in the dictionary correspond to the specification.'
def _validate_ip_pools(data, valid_values=None): DCNL 'Validate that start and end IP addresses are present DCNL In addition to this the IP addresses will also be validated'
def convert_kvp_str_to_list(data): DCNL 'Convert a value of the form \'key=value\' to [\'key\', \'value\']. DCNL :raises: q_exc.InvalidInput if any of the strings are malformed DCNL (e.g. do not contain a key).'
def convert_kvp_list_to_dict(kvp_list): DCNL 'Convert a list of \'key=value\' strings to a dict. DCNL :raises: q_exc.InvalidInput if any of the strings are malformed DCNL (e.g. do not contain a key) or if any DCNL of the keys appear more than once.'
def get_filters(request, attr_info, skips=[]): DCNL 'Extracts the filters from the request string DCNL Returns a dict of lists for the filters: DCNL check=a&check=b&name=Bob& DCNL becomes: DCNL {\'check\': [u\'a\', u\'b\'], \'name\': [u\'Bob\']}'
def get_limit_and_marker(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If limit == 0, it means we needn\'t DCNL pagination, then return None.'
def _get_limit_param(request, max_limit): DCNL 'Extract integer limit from request or fail.'
def list_args(request, arg): DCNL 'Extracts the list of arg from request'
def get_sorts(request, attr_info): DCNL 'Extract sort_key and sort_dir from request, return as: DCNL [(key1, value1), (key2, value2)]'
def paginate_query(query, model, limit, sorts, marker_obj=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort key, specified by sorts. DCNL (If sort keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort key, this would be easy: sort_key > X. DCNL With a compound-values sort key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL The reason of didn\'t use OFFSET clause was it don\'t scale, please refer DCNL discussion at https://lists.launchpad.net/openstack/msg02547.html DCNL We also have to cope with different sort directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sorts: array of attributes and direction by which results should DCNL be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def upgrade(active_plugin=None, options=None): DCNL 'A no-op migration for marking the Grizzly release.'
def downgrade(active_plugin=None, options=None): DCNL 'A no-op migration for marking the Grizzly release.'
def run_migrations_offline(): DCNL 'Run migrations in \'offline\' mode. DCNL This configures the context with just a URL DCNL and not an Engine, though an Engine is acceptable DCNL here as well.  By skipping the Engine creation DCNL we don\'t even need a DBAPI to be available. DCNL Calls to context.execute() here emit the given string to the DCNL script output.'
def run_migrations_online(): DCNL 'Run migrations in \'online\' mode. DCNL In this scenario we need to create an Engine DCNL and associate a connection with the context.'
def parse_service_definition_opt(): DCNL 'parse service definition opts and returns result'
def configure_db(): DCNL 'Establish the database, create an engine if needed, and DCNL register the models.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Helper method to grab session'
def register_models(base=BASE): DCNL 'Register Models and create properties'
def unregister_models(base=BASE): DCNL 'Unregister Models, useful clearing out data before testing'
def greenthread_yield(dbapi_con, con_record): DCNL 'Ensure other greenthreads get a chance to execute by forcing a context DCNL switch. With common database backends (eg MySQLdb and sqlite), there is DCNL no implicit yield caused by network I/O since they are implemented by DCNL C libraries that eventlet cannot monkey patch.'
@event.listens_for(ServiceRouterBinding.resource_type, 'set', retval=True) DCNL def validate_resource_type(target, value, oldvalue, initiator): DCNL 'Make sure the resource type fit the resource_type column.'
def get_resource_and_action(action): DCNL 'Extract resource and action (write, read) from api operation'
def _is_attribute_explicitly_set(attribute_name, resource, target): DCNL 'Verify that an attribute is present and has a non-default value'
def _build_target(action, original_target, plugin, context): DCNL 'Augment dictionary of target attributes for policy engine. DCNL This routine adds to the dictionary attributes belonging to the DCNL "parent" resource of the targeted one.'
def _build_match_rule(action, target): DCNL 'Create the rule to match for a given action. DCNL The policy rule to be matched is built in the following way: DCNL 1) add entries for matching permission on objects DCNL 2) add an entry for the specific action (e.g.: create_network) DCNL 3) add an entry for attributes of a resource for which the action DCNL is being executed (e.g.: create_network:shared)'
def check(context, action, target, plugin=None): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: quantum context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL :param target: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :param plugin: quantum plugin used to retrieve information required DCNL for augmenting the target DCNL :return: Returns True if access is permitted else False.'
def enforce(context, action, target, plugin=None): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: quantum context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL :param target: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :param plugin: quantum plugin used to retrieve information required DCNL for augmenting the target DCNL :raises quantum.exceptions.PolicyNotAllowed: if verification fails.'
def _ofc(id): DCNL 'OFC ID converter'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'Create a paste pipeline based on the \'auth_strategy\' config option.'
def setup(product_name): DCNL 'Setup logging.'
def _thread_done(gt, *args, **kwargs): DCNL 'Callback function to be passed to GreenThread.link() when we spawn() DCNL Calls the :class:`ThreadGroup` to notify if.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every tick DCNL of the periodic scheduler. DCNL 2. With arguments, @periodic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic scheduler.'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def set_rules(rules): DCNL 'Set the rules in use for policy checks.'
def reset(): DCNL 'Clear the rules used for policy checks.'
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL 'Checks authorization of a rule against the target and credentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operated DCNL on as possible, as a dictionary. DCNL :param creds: As much information about the user performing the DCNL action as possible, as a dictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passed to check() (both DCNL positional and keyword arguments) will be passed to DCNL the exception class.  If exc is not provided, returns DCNL False. DCNL :return: Returns False if the policy does not allow the action and DCNL exc is not provided; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specified string DCNL from the expression.'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Provided for backwards compatibility.  Translates the old DCNL list-of-lists syntax into a tree of Check objects.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods.  Arguments are a sequence of DCNL tokens, in order, which should trigger running this reduction DCNL method.'
def _parse_text_rule(rule): DCNL 'Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def execute(*cmd, **kwargs): DCNL 'Helper method to shell out and execute a command through subprocess with DCNL optional retry. DCNL :param cmd:             Passed to subprocess.Popen. DCNL :type cmd:              string DCNL :param process_input:   Send to opened process. DCNL :type proces_input:     string DCNL :param check_exit_code: Defaults to 0. Will raise DCNL :class:`ProcessExecutionError` DCNL if the command exits without returning this value DCNL as a returncode DCNL :type check_exit_code:  int DCNL :param delay_on_retry:  True | False. Defaults to True. If set to True, DCNL wait a short amount of time before retrying. DCNL :type delay_on_retry:   boolean DCNL :param attempts:        How many times to retry cmd. DCNL :type attempts:         int DCNL :param run_as_root:     True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper kwarg. DCNL :type run_as_root:      boolean DCNL :param root_helper:     command to prefix all cmd\'s with DCNL :type root_helper:      string DCNL :returns:               (stdout, stderr) from process execution DCNL :raises:                :class:`UnknownArgumentError` on DCNL receiving unknown arguments DCNL :raises:                :class:`ProcessExecutionError`'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def replace_file(file_name, data): DCNL 'Replaces the contents of file_name with data in a safe manner. DCNL First write to a temp file and then rename. Since POSIX renames are DCNL atomic, the file is unlikely to be corrupted by competing writes. DCNL We create the tempfile on the same device to ensure that it can be renamed.'
def setup_conf(): DCNL 'Setup the cfg for the clean up utility. DCNL Use separate setup_conf for the utility because there are many options DCNL from the main config that do not apply during clean-up.'
def kill_dhcp(conf, namespace): DCNL 'Disable DHCP for a network if DHCP is still active.'
def eligible_for_deletion(conf, namespace, force=False): DCNL 'Determine whether a namespace is eligible for deletion. DCNL Eligibility is determined by having only the lo device or if force DCNL is passed as a parameter.'
def destroy_namespace(conf, namespace, force=False): DCNL 'Destroy a given namespace. DCNL If force is True, then dhcp (if it exists) will be disabled and all DCNL devices will be forcibly removed.'
def main(): DCNL 'Main method for cleaning up network namespaces. DCNL This method will make two passes checking for namespaces to delete. The DCNL process will identify candidates, sleep, and call garbage collect. The DCNL garbage collection will re-verify that the namespace meets the criteria for DCNL deletion (ie it is empty). The period of sleep and the 2nd pass allow DCNL time for the namespace state to settle, so that the check prior deletion DCNL will re-confirm the namespace is empty. DCNL The utility is designed to clean-up after the forced or unexpected DCNL termination of Quantum agents. DCNL The --force flag should only be used as part of the cleanup of a devstack DCNL installation as it will blindly purge namespaces and their devices. This DCNL option also kills any lingering DHCP instances.'
def create_consumers(dispatcher, prefix, topic_details): DCNL 'Create agent RPC consumers. DCNL :param dispatcher: The dispatcher to process the incoming messages. DCNL :param prefix: Common prefix for the plugin/agent message queues. DCNL :param topic_details: A list of topics. Each topic has a name and a DCNL operation. DCNL :returns: A common Connection.'
def setup_conf(): DCNL 'Setup the cfg for the clean up utility. DCNL Use separate setup_conf for the utility because there are many options DCNL from the main config that do not apply during clean-up.'
def collect_quantum_ports(bridges, root_helper): DCNL 'Collect ports created by Quantum from OVS'
def delete_quantum_ports(ports, root_helper): DCNL 'Delete non-internal ports created by Quantum DCNL Non-internal OVS ports need to be removed manually.'
def main(): DCNL 'Main method for cleaning up OVS bridges. DCNL The utility cleans up the integration bridges used by Quantum.'
def _validate_servicetype_ref(data, valid_values=None): DCNL 'Verify the service type id exists'
def _validate_service_defs(data, valid_values=None): DCNL 'Validate the list of service definitions.'
def sg_label(sg_id, sg_name): DCNL 'Construct the security group ID used as chain identifier in MidoNet.'
def chain_names(sg_id, sg_name): DCNL 'Get inbound and outbound chain names.'
def _retrieve_extra_groups(conf, key=None, delimiter=':'): DCNL 'retrieve configuration groups not listed above.'
def register_cluster_groups(conf): DCNL 'retrieve configuration groups for nvp clusters.'
def parse_config(): DCNL 'Parse the supplied plugin configuration. DCNL :param config: a ConfigParser() object encapsulating nvp.ini. DCNL :returns: A tuple: (clusters, plugin_config). \'clusters\' is a list of DCNL NVPCluster objects, \'plugin_config\' is a dictionary with plugin DCNL parameters (currently only \'max_lp_per_bridged_ls\').'
def _validate_device_list(data, valid_values=None): DCNL 'Validate the list of service definitions.'
def get_cluster_version(cluster): DCNL 'Return major/minor version #'
def do_single_request(*args, **kwargs): DCNL 'Issue a request to a specified cluster if specified via kwargs DCNL (cluster=<cluster>).'
def do_multi_request(*args, **kwargs): DCNL 'Issue a request to all clusters'
def find_port_and_cluster(clusters, port_id): DCNL 'Return (url, cluster_id) of port or (None, None) if port does not exist.'
def create_l2_gw_service(cluster, tenant_id, display_name, devices): DCNL 'Create a NVP Layer-2 Network Gateway Service. DCNL :param cluster: The target NVP cluster DCNL :param tenant_id: Identifier of the Openstack tenant for which DCNL the gateway service. DCNL :param display_name: Descriptive name of this gateway service DCNL :param devices: List of transport node uuids (and network DCNL interfaces on them) to use for the network gateway service DCNL :raise NvpApiException: if there is a problem while communicating DCNL with the NVP controller'
def create_lrouter(cluster, tenant_id, display_name, nexthop): DCNL 'Create a NVP logical router on the specified cluster. DCNL :param cluster: The target NVP cluster DCNL :param tenant_id: Identifier of the Openstack tenant for which DCNL the logical router is being created DCNL :param display_name: Descriptive name of this logical router DCNL :param nexthop: External gateway IP address for the logical router DCNL :raise NvpApiException: if there is a problem while communicating DCNL with the NVP controller'
def get_all_networks(cluster, tenant_id, networks): DCNL 'Append the quantum network uuids we can find in the given cluster to DCNL "networks"'
def get_port_by_display_name(clusters, lswitch, display_name): DCNL 'Return (url, cluster_id) of port or raises ResourceNotFound'
def get_port_by_quantum_tag(cluster, lswitch_uuid, quantum_port_id): DCNL 'Return the NVP UUID of the logical port with tag q_port_id DCNL equal to quantum_port_id or None if the port is not Found.'
def create_lport(cluster, lswitch_uuid, tenant_id, quantum_port_id, display_name, device_id, admin_status_enabled, mac_address=None, fixed_ips=None, port_security_enabled=None, security_profiles=None, queue_id=None): DCNL 'Creates a logical port on the assigned logical switch'
def create_router_lport(cluster, lrouter_uuid, tenant_id, quantum_port_id, display_name, admin_status_enabled, ip_addresses): DCNL 'Creates a logical port on the assigned logical router'
def update_router_lport(cluster, lrouter_uuid, lrouter_port_uuid, tenant_id, quantum_port_id, display_name, admin_status_enabled, ip_addresses): DCNL 'Updates a logical port on the assigned logical router'
def delete_router_lport(cluster, lrouter_uuid, lport_uuid): DCNL 'Creates a logical port on the assigned logical router'
def find_router_gw_port(context, cluster, router_id): DCNL 'Retrieves the external gateway port for a NVP logical router'
def plug_router_port_attachment(cluster, router_id, port_id, attachment_uuid, nvp_attachment_type, attachment_vlan=None): DCNL 'Attach a router port to the given attachment. DCNL Current attachment types: DCNL - PatchAttachment [-> logical switch port uuid] DCNL - L3GatewayAttachment [-> L3GatewayService uuid] DCNL For the latter attachment type a VLAN ID can be specified as well'
def get_port_status(cluster, lswitch_id, port_id): DCNL 'Retrieve the operational status of the port'
def plug_l2_gw_service(cluster, lswitch_id, lport_id, gateway_id, vlan_id=None): DCNL 'Plug a Layer-2 Gateway Attachment object in a logical port'
def plug_interface(cluster, lswitch_id, port, type, attachment=None): DCNL 'Plug a VIF Attachment object in a logical port'
def format_exception(etype, e, execption_locals, request=None): DCNL 'Consistent formatting for exceptions. DCNL :param etype: a string describing the exception type. DCNL :param e: the exception. DCNL :param request: the request object. DCNL :param execption_locals: calling context local variable dict. DCNL :returns: a formatted string.'
def do_request(*args, **kwargs): DCNL 'Convenience function wraps do_single_request. DCNL :param args: a list of positional arguments. DCNL :param kwargs: a list of keyworkds arguments. DCNL :returns: the result of do_single_request loaded into a python object DCNL or None.'
def mk_body(**kwargs): DCNL 'Convenience function creates and dumps dictionary to string. DCNL :param kwargs: the key/value pirs to be dumped into a json string. DCNL :returns: a json string.'
def set_tenant_id_tag(tenant_id, taglist=None): DCNL 'Convenience function to add tenant_id tag to taglist. DCNL :param tenant_id: the tenant_id to set. DCNL :param taglist: the taglist to append to (or None). DCNL :returns: a new taglist that includes the old taglist with the new DCNL tenant_id tag set.'
def check_cluster_connectivity(cluster): DCNL 'Make sure that we can issue a request to each of the cluster nodes'
def sync_network_states(network_vlan_ranges): DCNL 'Synchronize network_states table with current configured VLAN ranges.'
def get_network_state(physical_network, vlan_id): DCNL 'Get state of specified network'
def get_port_from_device(device): DCNL 'Get port from database'
def set_port_status(port_id, status): DCNL 'Set the port status'
def get_port_from_device(port_id): DCNL 'Get port from database'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def sync_vlan_allocations(network_vlan_ranges): DCNL 'Synchronize vlan_allocations table with configured VLAN ranges'
def sync_tunnel_allocations(tunnel_id_ranges): DCNL 'Synchronize tunnel_allocations table with configured tunnel ranges'
def get_port_from_device(port_id): DCNL 'Get port from database'
def create_agent_config_map(config): DCNL 'Create a map of agent config parameters. DCNL :param config: an instance of cfg.CONF DCNL :returns: a map of agent configuration parameters'
def save_config(conf_path, logical_config, socket_path=None): DCNL 'Convert a logical configuration to the HAProxy version'
def _get_server_health_option(config): DCNL 'return the first active health option'
def _expand_expected_codes(codes): DCNL 'Expand the expected code string in set of codes. DCNL 200-204 -> 200, 201, 202, 204 DCNL 200, 203 -> 200, 203'
def create_network(context, net_id, vlan): DCNL 'Create a brocade specific network/port-profiles.'
def delete_network(context, net_id): DCNL 'Delete a brocade specific network/port-profiles.'
def get_network(context, net_id, fields=None): DCNL 'Get brocade specific network, with vlan extension.'
def get_networks(context, filters=None, fields=None): DCNL 'Get all brocade specific networks.'
def create_port(context, port_id, network_id, physical_interface, vlan_id, tenant_id, admin_state_up): DCNL 'Create a brocade specific port, has policy like vlan.'
def get_port(context, port_id): DCNL 'get a brocade specific port.'
def get_ports(context, network_id=None): DCNL 'get a brocade specific port.'
def delete_port(context, port_id): DCNL 'delete brocade specific port.'
def get_port_from_device(session, port_id): DCNL 'get port from the tap device.'
def update_port_state(context, port_id, admin_state_up): DCNL 'Update port attributes.'
def nos_unknown_host_cb(host, fingerprint): DCNL 'An unknown host callback. DCNL Returns `True` if it finds the key acceptable, DCNL and `False` if not. This default callback for NOS always returns \'True\' DCNL (i.e. trusts all hosts for now).'
def get16ByteUUID(uuid): DCNL 'Return a 16 byte has of the UUID, used when smaller unique DCNL ID is required.'
def make_net_dict(net_id, net_name, ports): DCNL 'Helper funciton'
def make_port_dict(port_id, port_state, net_id, attachment): DCNL 'Helper funciton'
def create_vlanids(): DCNL 'Prepopulates the vlan_bindings table'
def get_all_vlanids(): DCNL 'Gets all the vlanids'
def is_vlanid_used(vlan_id): DCNL 'Checks if a vlanid is in use'
def release_vlanid(vlan_id): DCNL 'Sets the vlanid state to be unused'
def delete_vlanid(vlan_id): DCNL 'Deletes a vlanid entry from db'
def reserve_vlanid(): DCNL 'Reserves the first unused vlanid'
def get_all_vlanids_used(): DCNL 'Gets all the vlanids used'
def get_all_vlan_bindings(): DCNL 'Lists all the vlan to network associations'
def get_vlan_binding(netid): DCNL 'Lists the vlan given a network_id'
def add_vlan_binding(vlanid, vlanname, netid): DCNL 'Adds a vlan to network association'
def remove_vlan_binding(netid): DCNL 'Removes a vlan to network association'
def update_vlan_binding(netid, newvlanid=None, newvlanname=None): DCNL 'Updates a vlan to network association'
def get_all_qoss(tenant_id): DCNL 'Lists all the qos to tenant associations'
def get_qos(tenant_id, qos_id): DCNL 'Lists the qos given a tenant_id and qos_id'
def add_qos(tenant_id, qos_name, qos_desc): DCNL 'Adds a qos to tenant association'
def remove_qos(tenant_id, qos_id): DCNL 'Removes a qos to tenant association'
def update_qos(tenant_id, qos_id, new_qos_name=None): DCNL 'Updates a qos to tenant association'
def get_all_credentials(tenant_id): DCNL 'Lists all the creds for a tenant'
def get_credential(tenant_id, credential_id): DCNL 'Lists the creds for given a cred_id and tenant_id'
def get_credential_name(tenant_id, credential_name): DCNL 'Lists the creds for given a cred_name and tenant_id'
def add_credential(tenant_id, credential_name, user_name, password): DCNL 'Adds a qos to tenant association'
def remove_credential(tenant_id, credential_id): DCNL 'Removes a credential from a  tenant'
def update_credential(tenant_id, credential_id, new_user_name=None, new_password=None): DCNL 'Updates a credential for a tenant'
def get_all_nexusport_bindings(): DCNL 'Lists all the nexusport bindings'
def get_nexusport_binding(port_id, vlan_id, switch_ip, instance_id): DCNL 'Lists a nexusport binding'
def get_nexusvlan_binding(vlan_id, switch_ip): DCNL 'Lists a vlan and switch binding'
def add_nexusport_binding(port_id, vlan_id, switch_ip, instance_id): DCNL 'Adds a nexusport binding'
def remove_nexusport_binding(port_id, vlan_id, switch_ip, instance_id): DCNL 'Removes a nexusport binding'
def update_nexusport_binding(port_id, new_vlan_id): DCNL 'Updates nexusport binding'
def get_nexusvm_binding(vlan_id, instance_id): DCNL 'Lists nexusvm bindings'
def get_port_vlan_switch_binding(port_id, vlan_id, switch_ip): DCNL 'Lists nexusvm bindings'
def configure_db(options): DCNL 'Establish the database, create an engine if needed, and DCNL register the models. DCNL :param options: Mapping of configuration options'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Helper method to grab session'
def register_models(): DCNL 'Register Models and create properties'
def unregister_models(): DCNL 'Unregister Models, useful clearing out data before testing'
def initialize(): DCNL 'Establish database connection and load models'
def create_vlanids(): DCNL 'Prepopulates the vlan_bindings table'
def get_all_vlanids(): DCNL 'Gets all the vlanids'
def is_vlanid_used(vlan_id): DCNL 'Checks if a vlanid is in use'
def release_vlanid(vlan_id): DCNL 'Sets the vlanid state to be unused'
def delete_vlanid(vlan_id): DCNL 'Deletes a vlanid entry from db'
def reserve_vlanid(): DCNL 'Reserves the first unused vlanid'
def get_all_vlanids_used(): DCNL 'Gets all the vlanids used'
def get_all_vlan_bindings(): DCNL 'Lists all the vlan to network associations'
def get_vlan_binding(netid): DCNL 'Lists the vlan given a network_id'
def add_vlan_binding(vlanid, vlanname, netid): DCNL 'Adds a vlan to network association'
def remove_vlan_binding(netid): DCNL 'Removes a vlan to network association'
def update_vlan_binding(netid, newvlanid=None, newvlanname=None): DCNL 'Updates a vlan to network association'
def get_all_qoss(tenant_id): DCNL 'Lists all the qos to tenant associations'
def get_qos(tenant_id, qos_id): DCNL 'Lists the qos given a tenant_id and qos_id'
def add_qos(tenant_id, qos_name, qos_desc): DCNL 'Adds a qos to tenant association'
def remove_qos(tenant_id, qos_id): DCNL 'Removes a qos to tenant association'
def update_qos(tenant_id, qos_id, new_qos_name=None): DCNL 'Updates a qos to tenant association'
def get_all_credentials(tenant_id): DCNL 'Lists all the creds for a tenant'
def get_credential(tenant_id, credential_id): DCNL 'Lists the creds for given a cred_id and tenant_id'
def get_credential_name(tenant_id, credential_name): DCNL 'Lists the creds for given a cred_name and tenant_id'
def add_credential(tenant_id, credential_name, user_name, password): DCNL 'Adds a qos to tenant association'
def remove_credential(tenant_id, credential_id): DCNL 'Removes a credential from a  tenant'
def update_credential(tenant_id, credential_id, new_user_name=None, new_password=None): DCNL 'Updates a credential for a tenant'
def get_view_builder(req): DCNL 'get view builder'
def get_view_builder(req): DCNL 'get view builder'
def run_server(application, port): DCNL 'Run a WSGI server with the given application.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filter_list, userargs): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter, or None is none matched.'
def run_command(cmd, redirect_output=True, check_exit_code=True, cwd=ROOT, die_message=None): DCNL 'Runs a command in an out-of-process shell, returning the DCNL output of that command.  Working directory is ROOT.'
def check_dependencies(): DCNL 'Make sure virtualenv is in the path.'
def create_virtualenv(venv=VENV): DCNL 'Creates the virtual environment and installs PIP only into the DCNL virtual environment'
def split(path, result=None): DCNL 'Split a path into components in a platform-neutral way.'
@register.filter DCNL def has_permissions(user, component): DCNL 'Checks if the given user meets the permissions requirements for DCNL the component.'
@register.inclusion_tag('horizon/_nav_list.html', takes_context=True) DCNL def horizon_main_nav(context): DCNL 'Generates top-level dashboard navigation entries.'
@register.inclusion_tag('horizon/_subnav_list.html', takes_context=True) DCNL def horizon_dashboard_nav(context): DCNL 'Generates sub-navigation entries for the current dashboard.'
@register.inclusion_tag('horizon/common/_progress_bar.html') DCNL def horizon_progress_bar(current_val, max_val): DCNL 'Renders a progress bar based on parameters passed to the tag. The first DCNL parameter is the current value and the second is the max value. DCNL Example: ``{% progress_bar 25 50 %}`` DCNL This will generate a half-full progress bar. DCNL The rendered progress bar will fill the area of its container. To constrain DCNL the rendered size of the bar provide a container with appropriate width and DCNL height styles.'
@register.tag DCNL def jstemplate(parser, token): DCNL 'Replaces ``[[[`` and ``]]]`` with ``{{{`` and ``}}}``, DCNL ``[[`` and ``]]`` with ``{{`` and ``}}``  and DCNL ``[%`` and ``%]`` with ``{%`` and ``%}`` to avoid conflicts DCNL with Django\'s template engine when using any of the Mustache-based DCNL templating libraries.'
def check_message(keywords, message): DCNL 'Checks an exception for given keywords and raises a new ``ActionError`` DCNL with the desired message if the keywords are found. This allows selective DCNL control over API error messages.'
def handle(request, message=None, redirect=None, ignore=False, escalate=False, log_level=None, force_log=None): DCNL 'Centralized error handling for Horizon. DCNL Because Horizon consumes so many different APIs with completely DCNL different ``Exception`` types, it\'s necessary to have a centralized DCNL place for handling exceptions which may be raised. DCNL Exceptions are roughly divided into 3 types: DCNL #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization DCNL problems. These result in being logged out and sent to the login screen. DCNL #. ``NOT_FOUND``: Errors resulting from objects which could not be DCNL located via the API. These generally result in a user-facing error DCNL message, but are otherwise returned to the normal code flow. Optionally DCNL a redirect value may be passed to the error handler so users are DCNL returned to a different view than the one requested in addition to the DCNL error message. DCNL #. RECOVERABLE: Generic API errors which generate a user-facing message DCNL but drop directly back to the regular code flow. DCNL All other exceptions bubble the stack as normal unless the ``ignore`` DCNL argument is passed in as ``True``, in which case only unrecognized DCNL errors are bubbled. DCNL If the exception is not re-raised, an appropriate wrapper exception DCNL class indicating the type of exception that was encountered will be DCNL returned.'
def horizon(request): DCNL 'The main Horizon context processor. Required for Horizon to function. DCNL It adds the Horizon config to the context as well as setting the names DCNL ``True`` and ``False`` in the context to their boolean equivalents DCNL for convenience. DCNL .. warning:: DCNL Don\'t put API calls in context processors; they will be called once DCNL for each template/template fragment which takes context that is used DCNL to render the complete output.'
def add_message(request, level, message, extra_tags='', fail_silently=False): DCNL 'Attempts to add a message to the request using the \'messages\' app.'
def debug(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``DEBUG`` level.'
def info(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``INFO`` level.'
def success(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``SUCCESS`` level.'
def warning(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``WARNING`` level.'
def error(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``ERROR`` level.'
def single_line(text): DCNL 'Quick utility to make comparing template output easier.'
def _current_component(view_func, dashboard=None, panel=None): DCNL 'Sets the currently-active dashboard and/or panel on the request.'
def require_auth(view_func): DCNL 'Performs user authentication check. DCNL Similar to Django\'s `login_required` decorator, except that this throws DCNL :exc:`~horizon.exceptions.NotAuthenticated` exception if the user is not DCNL signed-in.'
def require_perms(view_func, required): DCNL 'Enforces permission-based access controls. DCNL :param list required: A tuple of permission names, all of which the request DCNL user must possess in order access the decorated view. DCNL Example usage:: DCNL from horizon.decorators import require_perms DCNL @require_perms([\'foo.admin\', \'foo.member\']) DCNL def my_view(request): DCNL Raises a :exc:`~horizon.exceptions.NotAuthorized` exception if the DCNL requirements are not met.'
def user_home(request): DCNL 'Reversible named view to direct a user to the appropriate homepage.'
def generate_key(key_length=64): DCNL 'Secret key generator. DCNL The quality of randomness depends on operating system support, DCNL see http://docs.python.org/library/random.html#random.SystemRandom.'
def generate_or_read_from_file(key_file='.secret_key', key_length=64): DCNL 'Multiprocess-safe secret key file generator. DCNL Useful to replace the default (and thus unsafe) SECRET_KEY in settings.py DCNL upon first start. Save to use, i.e. when multiple Python interpreters DCNL serve the dashboard Django application (e.g. in a mod_wsgi + daemonized DCNL environment).  Also checks if file permissions are set correctly and DCNL throws an exception if not.'
def vip_create(request, **kwargs): DCNL 'Create a vip for a specified pool. DCNL :param request: request context DCNL :param address: virtual IP address DCNL :param name: name for vip DCNL :param description: description for vip DCNL :param subnet_id: subnet_id for subnet of vip DCNL :param protocol_port: transport layer port number for vip DCNL :returns: Vip object'
def pool_create(request, **kwargs): DCNL 'Create a pool for specified protocol DCNL :param request: request context DCNL :param name: name for pool DCNL :param description: description for pool DCNL :param subnet_id: subnet_id for subnet of pool DCNL :param protocol: load balanced protocol DCNL :param lb_method: load balancer method DCNL :param admin_state_up: admin state (default on)'
def pool_health_monitor_create(request, **kwargs): DCNL 'Create a health monitor and associate with pool DCNL :param request: request context DCNL :param type: type of monitor DCNL :param delay: delay of monitor DCNL :param timeout: timeout of monitor DCNL :param max_retries: max retries [1..10] DCNL :param http_method: http method DCNL :param url_path: url path DCNL :param expected_codes: http return code DCNL :param admin_state_up: admin state'
def member_create(request, **kwargs): DCNL 'Create a load balance member DCNL :param request: request context DCNL :param pool_id: pool_id of pool for member DCNL :param address: IP address DCNL :param protocol_port: transport layer port number DCNL :param weight: weight for member DCNL :param admin_state_up: admin_state'
def get_ipver_str(ip_version): DCNL 'Convert an ip version number to a human-friendly string'
def network_list_for_tenant(request, tenant_id, **params): DCNL 'Return a network list available for the tenant. DCNL The list contains networks owned by the tenant and public networks. DCNL If requested_networks specified, it searches requested_networks only.'
def network_create(request, **kwargs): DCNL 'Create a subnet on a specified network. DCNL :param request: request context DCNL :param tenant_id: (optional) tenant id of the network created DCNL :param name: (optional) name of the network created DCNL :returns: Subnet object'
def subnet_create(request, network_id, cidr, ip_version, **kwargs): DCNL 'Create a subnet on a specified network. DCNL :param request: request context DCNL :param network_id: network id a subnet is created on DCNL :param cidr: subnet IP address range DCNL :param ip_version: IP version (4 or 6) DCNL :param gateway_ip: (optional) IP address of gateway DCNL :param tenant_id: (optional) tenant id of the subnet created DCNL :param name: (optional) name of the subnet created DCNL :returns: Subnet object'
def port_create(request, network_id, **kwargs): DCNL 'Create a port on a specified network. DCNL :param request: request context DCNL :param network_id: network id a subnet is created on DCNL :param device_id: (optional) device id attached to the port DCNL :param tenant_id: (optional) tenant id of the port created DCNL :param name: (optional) name of the port created DCNL :returns: Port object'
def keystoneclient(request, admin=False): DCNL 'Returns a client connected to the Keystone backend. DCNL Several forms of authentication are supported: DCNL * Username + password -> Unscoped authentication DCNL * Username + password + tenant id -> Scoped authentication DCNL * Unscoped token -> Unscoped authentication DCNL * Unscoped token + tenant id -> Scoped authentication DCNL * Scoped token -> Scoped authentication DCNL Available services and data from the backend will vary depending on DCNL whether the authentication was scoped or unscoped. DCNL Lazy authentication if an ``endpoint`` parameter is provided. DCNL Calls requiring the admin endpoint should have ``admin=True`` passed in DCNL as a keyword argument. DCNL The client is cached so that subsequent API calls during the same DCNL request/response cycle don\'t have to be re-authenticated.'
def token_create_scoped(request, tenant, token): DCNL 'Creates a scoped token using the tenant id and unscoped token; retrieves DCNL the service catalog for the given tenant.'
def role_list(request): DCNL 'Returns a global list of available roles.'
def add_tenant_user_role(request, tenant_id, user_id, role_id): DCNL 'Adds a role for a user on a tenant.'
def remove_tenant_user_role(request, tenant_id, user_id, role_id): DCNL 'Removes a given single role for a user from a tenant.'
def remove_tenant_user(request, tenant_id, user_id): DCNL 'Removes all roles from a user on a tenant, removing them from it.'
def get_default_role(request): DCNL 'Gets the default role object from Keystone and saves it as a global DCNL since this is configured in settings and should not change from request DCNL to request. Supports lookup by name or id.'
def volume_list(request, search_opts=None): DCNL 'To see all volumes in the cloud as an admin you can pass in a special DCNL search option: {\'all_tenants\': 1}'
@memoized DCNL def flavor_list(request): DCNL 'Get the list of available instance sizes (flavors).'
def flavor_get_extras(request, flavor_id, raw=False): DCNL 'Get flavor extra specs.'
def flavor_extra_delete(request, flavor_id, keys): DCNL 'Unset the flavor extra spec keys.'
def flavor_extra_set(request, flavor_id, metadata): DCNL 'Set the flavor extra spec keys.'
def server_console_output(request, instance_id, tail_length=None): DCNL 'Gets console output of an instance.'
def server_security_groups(request, instance_id): DCNL 'Gets security groups of an instance.'
def _objectify(items, container_name): DCNL 'Splits a listing of objects into their appropriate wrapper classes.'
def image_get(request, image_id): DCNL 'Returns an Image object populated with metadata for image DCNL with supplied identifier.'
def get_int_or_uuid(value): DCNL 'Check if a value is valid as UUID or an integer. DCNL This method is mainly used to convert floating IP id to the DCNL appropriate type. For floating IP id, integer is used in Nova\'s DCNL original implementation, but UUID is used in Quantum based one.'
def openstack(request): DCNL 'Context processor necessary for OpenStack Dashboard functionality. DCNL The following variables are added to the request context: DCNL ``authorized_tenants`` DCNL A list of tenant objects which the current user has access to. DCNL ``regions`` DCNL A dictionary containing information about region support, the current DCNL region, and available regions.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def get_err_response(code): DCNL 'Given an HTTP response code, create a properly formatted xml error response DCNL :param code: error code DCNL :returns: webob.response object'
def get_acl(account_name, headers): DCNL 'Attempts to construct an S3 ACL based on what is found in the swift headers'
def canonical_string(req): DCNL 'Canonicalize a request to a token that can be signed.'
def swift_acl_translate(acl, group='', user='', xml=False): DCNL 'Takes an S3 style ACL and returns a list of header/value pairs that DCNL implement that ACL in Swift, or "Unsupported" if there isn\'t a way to do DCNL that yet.'
def validate_bucket_name(name): DCNL 'Validates the name of the bucket against S3 criteria, DCNL http://docs.amazonwebservices.com/AmazonS3/latest/BucketRestrictions.html DCNL True if valid, False otherwise'
def filter_factory(global_conf, **local_conf): DCNL 'Standard filter factory to use the middleware with paste.deploy'
def record_messages(connection, topic, output): DCNL 'Listen to notification.info messages and pickle them to output.'
def monitor_messages(connection, topic): DCNL 'Listen to notification.info messages and print them.'
def send_messages(connection, topic, input): DCNL 'Read messages from the input and send them to the AMQP queue.'
def notify(context, message): DCNL 'Sends a notification as a meter using Ceilometer pipelines.'
def get_publisher(url, namespace='ceilometer.publisher'): DCNL 'Get publisher driver and load it. DCNL :param URL: URL for the publisher DCNL :param namespace: Namespace to use to look for drivers.'
def register_opts(config): DCNL 'Register the options for publishing metering messages.'
def compute_signature(message, secret): DCNL 'Return the signature for a message dictionary.'
def verify_signature(message, secret): DCNL 'Check the signature in the message against the value computed DCNL from the rest of the contents.'
def meter_message_from_counter(counter, secret, source): DCNL 'Make a metering message ready to be published or stored. DCNL Returns a dictionary containing a metering message DCNL for a notification message and a Counter instance.'
def _sanitize_query(q): DCNL 'Check the query to see if: DCNL 1) the request is comming from admin - then allow full visibility DCNL 2) non-admin - make sure that the query includes the requester\'s DCNL project.'
def _get_query_timestamps(args={}): DCNL 'Return any optional timestamp information in the request. DCNL Determine the desired range, if any, from the GET arguments. Set DCNL up the query range using the specified offset. DCNL [query_start ... start_timestamp ... end_timestamp ... query_end] DCNL Returns a dictionary containing: DCNL query_start: First timestamp to use for query DCNL start_timestamp: start_timestamp parameter from request DCNL query_end: Final timestamp to use for query DCNL end_timestamp: end_timestamp parameter from request DCNL search_offset: search_offset parameter from request'
def _flatten_metadata(metadata): DCNL 'Return flattened resource metadata without nested structures DCNL and with all values converted to unicode strings.'
def register_opts(conf): DCNL 'Register keystoneclient middleware options'
def install(app, conf): DCNL 'Install ACL check on application.'
def get_limited_to_project(headers): DCNL 'Return the tenant the request should be limited to.'
@blueprint.route('/meters') DCNL def list_meters_all(): DCNL 'Return a list of meters. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/resources/<resource>/meters') DCNL def list_meters_by_resource(resource): DCNL 'Return a list of meters by resource. DCNL :param resource: The ID of the resource. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/users/<user>/meters') DCNL def list_meters_by_user(user): DCNL 'Return a list of meters by user. DCNL :param user: The ID of the owning user. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/projects/<project>/meters') DCNL def list_meters_by_project(project): DCNL 'Return a list of meters by project. DCNL :param project: The ID of the owning project. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/sources/<source>/meters') DCNL def list_meters_by_source(source): DCNL 'Return a list of meters by source. DCNL :param source: The ID of the owning source. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
def _list_resources(source=None, user=None, project=None): DCNL 'Return a list of resource identifiers.'
@blueprint.route('/projects/<project>/resources') DCNL def list_resources_by_project(project): DCNL 'Return a list of resources owned by the project. DCNL :param project: The ID of the owning project. DCNL :param start_timestamp: Limits resources by last update time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits resources by last update time < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/resources') DCNL def list_all_resources(): DCNL 'Return a list of all known resources. DCNL :param start_timestamp: Limits resources by last update time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits resources by last update time < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/sources/<source>') DCNL def get_source(source): DCNL 'Return a source details. DCNL :param source: The ID of the reporting source.'
@blueprint.route('/sources/<source>/resources') DCNL def list_resources_by_source(source): DCNL 'Return a list of resources for which a source is reporting DCNL data. DCNL :param source: The ID of the reporting source. DCNL :param start_timestamp: Limits resources by last update time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits resources by last update time < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/users/<user>/resources') DCNL def list_resources_by_user(user): DCNL 'Return a list of resources owned by the user. DCNL :param user: The ID of the owning user. DCNL :param start_timestamp: Limits resources by last update time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits resources by last update time < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
def _list_users(source=None): DCNL 'Return a list of user names.'
@blueprint.route('/users') DCNL def list_all_users(): DCNL 'Return a list of all known user names.'
@blueprint.route('/sources/<source>/users') DCNL def list_users_by_source(source): DCNL 'Return a list of the users for which the source is reporting DCNL data. DCNL :param source: The ID of the source.'
def _list_projects(source=None): DCNL 'Return a list of project names.'
@blueprint.route('/projects') DCNL def list_all_projects(): DCNL 'Return a list of all known project names.'
@blueprint.route('/sources/<source>/projects') DCNL def list_projects_by_source(source): DCNL 'Return a list project names for which the source is reporting DCNL data. DCNL :param source: The ID of the source.'
def _list_samples(meter, project=None, resource=None, source=None, user=None): DCNL 'Return a list of raw samples. DCNL Note: the API talks about "events" these are equivelent to samples. DCNL but we still need to return the samples within the "events" dict DCNL to maintain API compatibilty.'
@blueprint.route('/projects/<project>/meters/<meter>') DCNL def list_samples_by_project(project, meter): DCNL 'Return a list of raw samples for the project. DCNL :param project: The ID of the project. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC'
@blueprint.route('/resources/<resource>/meters/<meter>') DCNL def list_samples_by_resource(resource, meter): DCNL 'Return a list of raw samples for the resource. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC'
@blueprint.route('/sources/<source>/meters/<meter>') DCNL def list_samples_by_source(source, meter): DCNL 'Return a list of raw samples for the source. DCNL :param source: The ID of the reporting source. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC'
@blueprint.route('/users/<user>/meters/<meter>') DCNL def list_samples_by_user(user, meter): DCNL 'Return a list of raw samples for the user. DCNL :param user: The ID of the user. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC'
@blueprint.route('/resources/<resource>/meters/<meter>/duration') DCNL def compute_duration_by_resource(resource, meter): DCNL 'Return the earliest timestamp, last timestamp, DCNL and duration for the resource and meter. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest timestamp to return. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest timestamp to return. DCNL :param search_offset: Number of minutes before DCNL and after start and end timestamps to query.'
@blueprint.route('/resources/<resource>/meters/<meter>/volume/max') DCNL def compute_max_resource_volume(resource, meter): DCNL 'Return the max volume for a meter. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest time to include in the calculation. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest time to include in the calculation. DCNL :param search_offset: Number of minutes before and DCNL after start and end timestamps to query.'
@blueprint.route('/resources/<resource>/meters/<meter>/volume/sum') DCNL def compute_resource_volume_sum(resource, meter): DCNL 'Return the sum of samples for a meter. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest time to include in the calculation. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest time to include in the calculation. DCNL :param search_offset: Number of minutes before and DCNL after start and end timestamps to query.'
@blueprint.route('/projects/<project>/meters/<meter>/volume/max') DCNL def compute_project_volume_max(project, meter): DCNL 'Return the max volume for a meter. DCNL :param project: The ID of the project. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest time to include in the calculation. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest time to include in the calculation. DCNL :param search_offset: Number of minutes before and DCNL after start and end timestamps to query.'
@blueprint.route('/projects/<project>/meters/<meter>/volume/sum') DCNL def compute_project_volume_sum(project, meter): DCNL 'Return the total volume for a meter. DCNL :param project: The ID of the project. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest time to include in the calculation. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest time to include in the calculation. DCNL :param search_offset: Number of minutes before and DCNL after start and end timestamps to query.'
def recursive_keypairs(d): DCNL 'Generator that produces sequence of keypairs for nested dictionaries.'
def dt_to_decimal(utc): DCNL 'Datetime to Decimal. DCNL Some databases don\'t store microseconds in datetime DCNL so we always store as Decimal unixtime.'
def decimal_to_dt(dec): DCNL 'Return a datetime from Decimal unixtime format.'
def sanitize_timestamp(timestamp): DCNL 'Return a naive utc datetime object.'
def setup_pipeline(transformer_manager): DCNL 'Setup pipeline manager according to yaml config file.'
def setup(product_name): DCNL 'Setup logging.'
def getLazyLogger(name='unknown', version='unknown'): DCNL 'Returns lazy logger. DCNL Creates a pass-through logger that does not create the real logger DCNL until it is really needed and delegates all calls to the real logger DCNL once it is created.'
def _thread_done(gt, *args, **kwargs): DCNL 'Callback function to be passed to GreenThread.link() when we spawn() DCNL Calls the :class:`ThreadGroup` to notify if.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def read_cached_file(filename, force_reload=False): DCNL 'Read from a file if it has been modified. DCNL :param force_reload: Whether to reload the file. DCNL :returns: A tuple with a boolean specifying if the data is fresh DCNL or not.'
def delete_if_exists(path): DCNL 'Delete a file, but ignore file not found error. DCNL :param path: File to delete'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed. DCNL :param path: File to work with'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection.'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def create_connection(conf, new=True): DCNL 'Create a connection.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection.'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic.'
def _serialize(data): DCNL 'Serialization wrapper. DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper.'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages. DCNL Dispatches to the matchmaker and sends message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format.'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format.'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object.'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp.'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Overrides utils.utcnow. DCNL Make it return a constant time or a list thereof, one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Return the difference between two timing objects. DCNL Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def set_defaults(sql_connection, sqlite_db, max_pool_size=None, max_overflow=None, pool_timeout=None): DCNL 'Set defaults for configuration variables.'
def get_session(autocommit=True, expire_on_commit=False, sqlite_fk=False, slave_session=False): DCNL 'Return a SQLAlchemy session.'
def _raise_if_duplicate_entry_error(integrity_error, engine_name): DCNL 'Raise exception if two entries are duplicated. DCNL In this function will be raised DBDuplicateEntry exception if integrity DCNL error wrap unique constraint violation.'
def _raise_if_deadlock_error(operational_error, engine_name): DCNL 'Raise exception on deadlock condition. DCNL Raise DBDeadlock exception if OperationalError contains a Deadlock DCNL condition.'
def get_engine(sqlite_fk=False, slave_engine=False): DCNL 'Return a SQLAlchemy engine.'
def _synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode.'
def _add_regexp_listener(dbapi_con, con_record): DCNL 'Add REGEXP function to sqlite connections.'
def _greenthread_yield(dbapi_con, con_record): DCNL 'Ensure other greenthreads get a chance to be executed. DCNL Force a context switch. With common database backends (eg MySQLdb and DCNL sqlite), there is no implicit yield caused by network I/O since they are DCNL implemented by C libraries that eventlet cannot monkey patch.'
def _ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def _is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def create_engine(sql_connection, sqlite_fk=False): DCNL 'Return a new SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def _patch_mysqldb_with_stacktrace_comments(): DCNL 'Adds current stack trace as a comment in queries. DCNL Patches MySQLdb.cursors.BaseCursor._do_query.'
def _assert_matching_drivers(): DCNL 'Make sure slave handle and normal handle have the same driver.'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Translates the old list-of-lists syntax into a tree of Check objects. DCNL Provided for backwards compatibility.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods. DCNL Arguments are a sequence of tokens, in order, which should trigger running DCNL this reduction method.'
def _parse_text_rule(rule): DCNL 'Parses policy to the tree. DCNL Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL :param lock_file_prefix: The lock_file_prefix argument is used to provide DCNL lock files on disk with a meaningful prefix. The prefix should end with a DCNL hyphen (\'-\') if specified. DCNL :param external: The external keyword argument denotes whether this lock DCNL should work across multiple processes. This means that if two different DCNL workers both run a a method decorated with @synchronized(\'mylock\', DCNL external=True), only one of them will execute at a time. DCNL :param lock_path: The lock_path keyword argument is used to specify a DCNL special location for external lock files to live. If nothing is set, then DCNL CONF.lock_path is used as a default.'
def synchronized_with_prefix(lock_file_prefix): DCNL 'Partial object generator for the synchronization decorator. DCNL Redefine @synchronized in each project like so:: DCNL (in nova/utils.py) DCNL from nova.openstack.common import lockutils DCNL synchronized = lockutils.synchronized_with_prefix(\'nova-\') DCNL (in nova/foo.py) DCNL from nova import utils DCNL @utils.synchronized(\'mylock\') DCNL def bar(self, *args): DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified.'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
def install(domain): DCNL 'Install a _() function using the given translation domain. DCNL Given a translation domain, install a _() function using gettext\'s DCNL install() function. DCNL The main difference from gettext.install() is that we allow DCNL overriding the default localedir (e.g. /usr/share/locale) using DCNL a translation-domain-specific environment variable (e.g. DCNL NOVA_LOCALEDIR).'
def get_lazy_gettext(domain): DCNL 'Assemble and return a lazy gettext function for a given domain. DCNL Factory method for a project/module to get a lazy gettext function DCNL for its own translation domain (i.e. nova, glance, cinder, etc.)'
def _is_in_group(opt, group): DCNL 'Check if opt is in group.'
def _sanitize_default(s): DCNL 'Set up a reasonably sensible default for pybasedir, my_ip and host.'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def notify(context, message): DCNL 'Sends a notification via RPC.'
def _get_drivers(): DCNL 'Instantiates and returns drivers based on the flag values.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def remove_driver(notification_driver): DCNL 'Remove a notification driver at runtime.'
def notify(context, message): DCNL 'Passes notification to multiple notifiers in a list.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system.'
def notify(context, message): DCNL 'Sends a notification via RPC.'
def notify_decorator(name, fn): DCNL 'Decorator for notify which is used from utils.monkey_patch(). DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model.'
def import_class(import_str): DCNL 'Returns a class from a string including module and class.'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Tries to import object from default namespace. DCNL Imports a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def execute(*cmd, **kwargs): DCNL 'Helper method to shell out and execute a command through subprocess with DCNL optional retry. DCNL :param cmd:             Passed to subprocess.Popen. DCNL :type cmd:              string DCNL :param process_input:   Send to opened process. DCNL :type proces_input:     string DCNL :param check_exit_code: Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL :class:`ProcessExecutionError` unless DCNL program exits with one of these code. DCNL :type check_exit_code:  boolean, int, or [int] DCNL :param delay_on_retry:  True | False. Defaults to True. If set to True, DCNL wait a short amount of time before retrying. DCNL :type delay_on_retry:   boolean DCNL :param attempts:        How many times to retry cmd. DCNL :type attempts:         int DCNL :param run_as_root:     True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper kwarg. DCNL :type run_as_root:      boolean DCNL :param root_helper:     command to prefix to commands called with DCNL run_as_root=True DCNL :type root_helper:      string DCNL :param shell:           whether or not there should be a shell used to DCNL execute this command. Defaults to false. DCNL :type shell:            boolean DCNL :returns:               (stdout, stderr) from process execution DCNL :raises:                :class:`UnknownArgumentError` on DCNL receiving unknown arguments DCNL :raises:                :class:`ProcessExecutionError`'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def iter_period(start, end, period): DCNL 'Split a time from start to end in periods of a number of seconds. This DCNL function yield the (start, end) time for each period composing the time DCNL passed as argument. DCNL :param start: When the period set start. DCNL :param end: When the period end starts. DCNL :param period: The duration of the period.'
def register_opts(conf): DCNL 'Register any options for the storage system.'
def get_engine(conf): DCNL 'Load the configured engine and return an instance.'
def get_connection(conf): DCNL 'Return an open connection to the database.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def make_query_from_filter(query, sample_filter, require_meter=True): DCNL 'Return a query dictionary based on the settings in the filter. DCNL :param filter: SampleFilter instance DCNL :param require_meter: If true and the filter does not have a meter, DCNL raise an error.'
def make_timestamp_range(start, end): DCNL 'Given two possible datetimes, create the query DCNL document to find timestamps within that range DCNL using $gte for the lower bound and $lt for the DCNL upper bound.'
def make_query_from_filter(sample_filter, require_meter=True): DCNL 'Return a query dictionary based on the settings in the filter. DCNL :param filter: SampleFilter instance DCNL :param require_meter: If true and the filter does not have a meter, DCNL raise an error.'
def require_map_reduce(conn): DCNL 'Raises SkipTest if the connection is using mim.'
def reverse_timestamp(dt): DCNL 'Reverse timestamp so that newer timestamps are represented by smaller DCNL numbers than older ones. DCNL Reverse timestamps is a technique used in HBase rowkey design. When period DCNL queries are required the HBase rowkeys must include timestamps, but as DCNL rowkeys in HBase are ordered lexicographically, the timestamps must be DCNL reversed.'
def make_query(user=None, project=None, meter=None, resource=None, source=None, start=None, end=None, require_meter=True, query_only=False): DCNL 'Return a filter query string based on the selected parameters. DCNL :param user: Optional user-id DCNL :param project: Optional project-id DCNL :param meter: Optional counter-name DCNL :param resource: Optional resource-id DCNL :param source: Optional source-id DCNL :param start: Optional start timestamp DCNL :param end: Optional end timestamp DCNL :param require_meter: If true and the filter does not have a meter, DCNL raise an error. DCNL :param query_only: If true only returns the filter query, DCNL otherwise also returns start and stop rowkeys'
def make_query_from_filter(sample_filter, require_meter=True): DCNL 'Return a query dictionary based on the settings in the filter. DCNL :param sample_filter: SampleFilter instance DCNL :param require_meter: If true and the filter does not have a meter, DCNL raise an error.'
def _make_rowkey_scan(meter, rts_start=None, rts_end=None): DCNL 'If it\'s meter filter without start and end, DCNL start_row = meter while end_row = meter + MAX_BYTE'
def _load_hbase_list(d, prefix): DCNL 'Deserialise dict stored as HBase column family'
def _instance_name(instance): DCNL 'Shortcut to get instance name.'
def initialize_gatherer(gatherer=None): DCNL 'Set the callable used to gather stats for the instance. DCNL gatherer should be a callable accepting one argument (the instance DCNL ref), or None to have a default gatherer used'
def get_metadata_from_object(instance): DCNL 'Return a metadata dictionary for the instance.'
def get_config(section_name=None, defaults=None): DCNL 'Attempt to get a test config dictionary. DCNL :param section_name: the section to read (all sections if not defined) DCNL :param defaults: an optional dictionary namespace of defaults'
def retry(func, *args, **kwargs): DCNL 'You can use the kwargs to override the \'retries\' (default: 5) and DCNL \'use_account\' (default: 1).'
def teardown_module(): DCNL 'clean up my monkey patching'
def premetadata_create_container_stat_table(self, conn, put_timestamp=None): DCNL 'Copied from swift.common.db.ContainerBroker before the metadata column was DCNL added; used for testing with TestContainerBrokerBeforeMetadata. DCNL Create the container_stat table which is specifc to the container DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'
def prexsync_create_container_stat_table(self, conn, put_timestamp=None): DCNL 'Copied from swift.common.db.ContainerBroker before the DCNL x_container_sync_point[12] columns were added; used for testing with DCNL TestContainerBrokerBeforeXSync. DCNL Create the container_stat table which is specifc to the container DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'
def premetadata_create_account_stat_table(self, conn, put_timestamp): DCNL 'Copied from swift.common.db.AccountBroker before the metadata column was DCNL added; used for testing with TestAccountBrokerBeforeMetadata. DCNL Create account_stat table which is specific to the account DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'
def pop_stream(f): DCNL 'read everything out of file from the top and clear it out'
def sortHeaderNames(headerNames): DCNL 'Return the given string of header names sorted. DCNL headerName: a comma-delimited list of header names'
def app_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI container server apps'
def dict_factory(crs, row): DCNL 'This should only be used when you need a real dict, DCNL i.e. when you\'re going to serialize the results.'
def chexor(old, name, timestamp): DCNL 'Each entry in the account and container databases is XORed by the 128-bit DCNL hash on insert or delete.  This serves as a rolling, order-independent hash DCNL of the contents. (check + XOR) DCNL :param old: hex representation of the current DB hash DCNL :param name: name of the object or container being inserted DCNL :param timestamp: timestamp of the new record DCNL :returns: a hex representation of the new hash value'
def get_db_connection(path, timeout=30, okay_to_create=False): DCNL 'Returns a properly configured SQLite database connection. DCNL :param path: path to DB DCNL :param timeout: timeout for connection DCNL :param okay_to_create: if True, create the DB if it doesn\'t exist DCNL :returns: DB connection object'
def run_daemon(klass, conf_file, section_name='', once=False, **kwargs): DCNL 'Loads settings from conf, then instantiates daemon "klass" and runs the DCNL daemon with the specified once kwarg.  The section_name will be derived DCNL from the daemon "klass" if not provided (e.g. ObjectReplicator => DCNL object-replicator). DCNL :param klass: Class to instantiate, subclass of common.daemon.Daemon DCNL :param conf_file: Path to configuration file DCNL :param section_name: Section name from conf file to load config from DCNL :param once: Passed to daemon run method'
def http_connect(ipaddr, port, device, partition, method, path, headers=None, query_string=None, ssl=False): DCNL 'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection DCNL will be used, which is buffered for backend Swift services. DCNL :param ipaddr: IPv4 address to connect to DCNL :param port: port to connect to DCNL :param device: device of the node to query DCNL :param partition: partition on the device DCNL :param method: HTTP method to request (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: request path DCNL :param headers: dictionary of headers DCNL :param query_string: request query string DCNL :param ssl: set True if SSL should be used (default: False) DCNL :returns: HTTPConnection object'
def http_connect_raw(ipaddr, port, method, path, headers=None, query_string=None, ssl=False): DCNL 'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection DCNL will be used, which is buffered for backend Swift services. DCNL :param ipaddr: IPv4 address to connect to DCNL :param port: port to connect to DCNL :param method: HTTP method to request (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: request path DCNL :param headers: dictionary of headers DCNL :param query_string: request query string DCNL :param ssl: set True if SSL should be used (default: False) DCNL :returns: HTTPConnection object'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def quote(value, safe='/'): DCNL 'Patched version of urllib.quote that encodes utf-8 strings before quoting'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a Static Web WSGI filter for use with paste.deploy.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns the WSGI filter for use with paste.deploy.'
def parse_input(raw_data): DCNL 'Given a request will parse the body and return a list of dictionaries DCNL :raises: HTTPException on parse errors DCNL :returns: a list of dictionaries on success'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def clean_acl(name, value): DCNL 'Returns a cleaned ACL header value, validating that it meets the formatting DCNL requirements for standard Swift ACL strings. DCNL The ACL format is:: DCNL [item[,item...]] DCNL Each item can be a group name to give access to or a referrer designation DCNL to grant or deny based on the HTTP Referer header. DCNL The referrer designation format is:: DCNL .r:[-]value DCNL The ``.r`` can also be ``.ref``, ``.referer``, or ``.referrer``; though it DCNL will be shortened to just ``.r`` for decreased character count usage. DCNL The value can be ``*`` to specify any referrer host is allowed access, a DCNL specific host name like ``www.example.com``, or if it has a leading period DCNL ``.`` or leading ``*.`` it is a domain name specification, like DCNL ``.example.com`` or ``*.example.com``. The leading minus sign ``-`` DCNL indicates referrer hosts that should be denied access. DCNL Referrer access is applied in the order they are specified. For example, DCNL .r:.example.com,.r:-thief.example.com would allow all hosts ending with DCNL .example.com except for the specific host thief.example.com. DCNL Example valid ACLs:: DCNL .r:* DCNL .r:*,.r:-.thief.com DCNL .r:*,.r:.example.com,.r:-thief.example.com DCNL .r:*,.r:-.thief.com,bobs_account,sues_account:sue DCNL bobs_account,sues_account:sue DCNL Example invalid ACLs:: DCNL .r: DCNL .r:- DCNL By default, allowing read access via .r will not allow listing objects in DCNL the container -- just retrieving objects from the container. To turn on DCNL listings, use the .rlistings directive. DCNL Also, .r designations aren\'t allowed in headers whose names include the DCNL word \'write\'. DCNL ACLs that are "messy" will be cleaned up. Examples: DCNL Original                Cleaned DCNL ``bob, sue``            ``bob,sue`` DCNL ``bob , sue``           ``bob,sue`` DCNL ``bob,,,sue``           ``bob,sue`` DCNL ``.referrer : *``       ``.r:*`` DCNL ``.ref:*.example.com``  ``.r:.example.com`` DCNL ``.r:*, .rlistings``    ``.r:*,.rlistings`` DCNL :param name: The name of the header being cleaned, such as X-Container-Read DCNL or X-Container-Write. DCNL :param value: The value of the header being cleaned. DCNL :returns: The value, cleaned of extraneous formatting. DCNL :raises ValueError: If the value does not meet the ACL formatting DCNL requirements; the error message will indicate why.'
def parse_acl(acl_string): DCNL 'Parses a standard Swift ACL string into a referrers list and groups list. DCNL See :func:`clean_acl` for documentation of the standard Swift ACL format. DCNL :param acl_string: The standard Swift ACL string to parse. DCNL :returns: A tuple of (referrers, groups) where referrers is a list of DCNL referrer designations (without the leading .r:) and groups is a DCNL list of groups to allow access.'
def referrer_allowed(referrer, referrer_acl): DCNL 'Returns True if the referrer should be allowed based on the referrer_acl DCNL list (as returned by :func:`parse_acl`). DCNL See :func:`clean_acl` for documentation of the standard Swift ACL format. DCNL :param referrer: The value of the HTTP Referer header. DCNL :param referrer_acl: The list of referrer designations as returned by DCNL :func:`parse_acl`. DCNL :returns: True if the referrer should be allowed; False if not.'
def filter_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI proxy apps.'
def lookup_cname(domain): DCNL 'Given a domain, returns its DNS CNAME mapping and DNS ttl. DCNL :param domain: domain to query on DCNL :returns: (ttl, result)'
def _parse_attrs(header): DCNL 'Given the value of a header like: DCNL Content-Disposition: form-data; name="somefile"; filename="test.html" DCNL Return data like DCNL ("form-data", {"name": "somefile", "filename": "test.html"}) DCNL :param header: Value of a header (the part after the \': \'). DCNL :returns: (value name, dict) of the attribute data parsed (see above).'
def _iter_requests(wsgi_input, boundary): DCNL 'Given a multi-part mime encoded input file object and boundary, DCNL yield file-like objects for each part. DCNL :param wsgi_input: The file-like object to read from. DCNL :param boundary: The mime boundary to separate new file-like DCNL objects on. DCNL :returns: A generator of file-like objects for each part.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns the WSGI filter for use with paste.deploy.'
def get_response_body(data_format, data_dict, error_list): DCNL 'Returns a properly formatted response body according to format. DCNL :params data_format: resulting format DCNL :params data_dict: generated data about results. DCNL :params error_list: list of quoted filenames that failed'
def backward(f, blocksize=4096): DCNL 'A generator returning lines from a file starting with the last line, DCNL then the second last line, etc. i.e., it reads lines backwards. DCNL Stops when the first line (if any) is read. DCNL This is useful when searching for recent activity in very DCNL large files. DCNL :param f: file object to read DCNL :param blocksize: no of characters to go backwards at each block'
def config_true_value(value): DCNL 'Returns True if the value is either True or a string in TRUE_VALUES. DCNL Returns False otherwise.'
def load_libc_function(func_name, log_error=True): DCNL 'Attempt to find the function in libc, otherwise return a no-op func. DCNL :param func_name: name of the function to pull from libc.'
def get_param(req, name, default=None): DCNL 'Get parameters from an HTTP request ensuring proper handling UTF-8 DCNL encoding. DCNL :param req: request object DCNL :param name: parameter name DCNL :param default: result to return if the parameter is not found DCNL :returns: HTTP request parameter value'
def fallocate(fd, size): DCNL 'Pre-allocate disk space for a file. DCNL :param fd: file descriptor DCNL :param size: size to allocate (in bytes)'
def fsync(fd): DCNL 'Sync modified file data and metadata to disk. DCNL :param fd: file descriptor'
def fdatasync(fd): DCNL 'Sync modified file data to disk. DCNL :param fd: file descriptor'
def drop_buffer_cache(fd, offset, length): DCNL 'Drop \'buffer\' cache for the given range of the given file. DCNL :param fd: file descriptor DCNL :param offset: start offset DCNL :param length: length'
def normalize_timestamp(timestamp): DCNL 'Format a timestamp (string or numeric) into a standardized DCNL xxxxxxxxxx.xxxxx format. DCNL :param timestamp: unix timestamp DCNL :returns: normalized timestamp as a string'
def mkdirs(path): DCNL 'Ensures the path is a directory or makes it if not. Errors if the path DCNL exists but is a file or on permissions failure. DCNL :param path: path to create'
def renamer(old, new): DCNL 'Attempt to fix / hide race conditions like empty object directories DCNL being removed by backend processes during uploads, by retrying. DCNL :param old: old path to be renamed DCNL :param new: new path to be renamed to'
def split_path(path, minsegs=1, maxsegs=None, rest_with_last=False): DCNL 'Validate and split the given HTTP request path. DCNL **Examples**:: DCNL [\'a\'] = split_path(\'/a\') DCNL [\'a\', None] = split_path(\'/a\', 1, 2) DCNL [\'a\', \'c\'] = split_path(\'/a/c\', 1, 2) DCNL [\'a\', \'c\', \'o/r\'] = split_path(\'/a/c/o/r\', 1, 3, True) DCNL :param path: HTTP Request path to be split DCNL :param minsegs: Minimum number of segments to be extracted DCNL :param maxsegs: Maximum number of segments to be extracted DCNL :param rest_with_last: If True, trailing data will be returned as part DCNL of last segment.  If False, and there is DCNL trailing data, raises ValueError. DCNL :returns: list of segments with a length of maxsegs (non-existant DCNL segments will return as None) DCNL :raises: ValueError if given an invalid path'
def validate_device_partition(device, partition): DCNL 'Validate that a device and a partition are valid and won\'t lead to DCNL directory traversal when used. DCNL :param device: device to validate DCNL :param partition: partition to validate DCNL :raises: ValueError if given an invalid device or partition'
def timing_stats(**dec_kwargs): DCNL 'Returns a decorator that logs timing events or errors for public methods in DCNL swift\'s wsgi server controllers, based on response code.'
def get_logger(conf, name=None, log_to_console=False, log_route=None, fmt='%(server)s DCSP %(message)s'): DCNL 'Get the current system logger using config settings. DCNL **Log config and defaults**:: DCNL log_facility = LOG_LOCAL0 DCNL log_level = INFO DCNL log_name = swift DCNL log_udp_host = (disabled) DCNL log_udp_port = logging.handlers.SYSLOG_UDP_PORT DCNL log_address = /dev/log DCNL log_statsd_host = (disabled) DCNL log_statsd_port = 8125 DCNL log_statsd_default_sample_rate = 1.0 DCNL log_statsd_sample_rate_factor = 1.0 DCNL log_statsd_metric_prefix = (empty-string) DCNL :param conf: Configuration dict to read settings from DCNL :param name: Name of the logger DCNL :param log_to_console: Add handler which writes to console on stderr DCNL :param log_route: Route for the logging, not emitted to the log, just used DCNL to separate logging configurations DCNL :param fmt: Override log format'
def get_hub(): DCNL 'Checks whether poll is available and falls back DCNL on select if it isn\'t. DCNL Note about epoll: DCNL Review: https://review.openstack.org/#/c/18806/ DCNL There was a problem where once out of every 30 quadrillion DCNL connections, a coroutine wouldn\'t wake up when the client DCNL closed its end. Epoll was not reporting the event or it was DCNL getting swallowed somewhere. Then when that file descriptor DCNL was re-used, eventlet would freak right out because it still DCNL thought it was waiting for activity from it in some other coro.'
def drop_privileges(user): DCNL 'Sets the userid/groupid of the current process, get session leader, etc. DCNL :param user: User name to change privileges to'
def capture_stdio(logger, **kwargs): DCNL 'Log unhandled exceptions, close stdio, capture stdout and stderr. DCNL param logger: Logger object to use'
def parse_options(parser=None, once=False, test_args=None): DCNL 'Parse standard swift server/daemon options with optparse.OptionParser. DCNL :param parser: OptionParser to use. If not sent one will be created. DCNL :param once: Boolean indicating the "once" option is available DCNL :param test_args: Override sys.argv; used in testing DCNL :returns : Tuple of (config, options); config is an absolute path to the DCNL config file, options is the parser options as a dictionary. DCNL :raises SystemExit: First arg (CONFIG) is required, file must exist'
def whataremyips(): DCNL 'Get the machine\'s ip addresses DCNL :returns: list of Strings of ip addresses'
def storage_directory(datadir, partition, hash): DCNL 'Get the storage directory DCNL :param datadir: Base data directory DCNL :param partition: Partition DCNL :param hash: Account, container or object hash DCNL :returns: Storage directory'
def hash_path(account, container=None, object=None, raw_digest=False): DCNL 'Get the connonical hash for an account/container/object DCNL :param account: Account DCNL :param container: Container DCNL :param object: Object DCNL :param raw_digest: If True, return the raw version rather than a hex digest DCNL :returns: hash string'
@contextmanager DCNL def lock_path(directory, timeout=10): DCNL 'Context manager that acquires a lock on a directory.  This will block until DCNL the lock can be acquired, or the timeout time has expired (whichever occurs DCNL first). DCNL For locking exclusively, file or directory has to be opened in Write mode. DCNL Python doesn\'t allow directories to be opened in Write Mode. So we DCNL workaround by locking a hidden file in the directory. DCNL :param directory: directory to be locked DCNL :param timeout: timeout (in seconds)'
@contextmanager DCNL def lock_file(filename, timeout=10, append=False, unlink=True): DCNL 'Context manager that acquires a lock on a file.  This will block until DCNL the lock can be acquired, or the timeout time has expired (whichever occurs DCNL first). DCNL :param filename: file to be locked DCNL :param timeout: timeout (in seconds) DCNL :param append: True if file should be opened in append mode DCNL :param unlink: True if the file should be unlinked at the end'
def lock_parent_directory(filename, timeout=10): DCNL 'Context manager that acquires a lock on the parent directory of the given DCNL file path.  This will block until the lock can be acquired, or the timeout DCNL time has expired (whichever occurs first). DCNL :param filename: file path of the parent directory to be locked DCNL :param timeout: timeout (in seconds)'
def get_time_units(time_amount): DCNL 'Get a nomralized length of time in the largest unit of time (hours, DCNL minutes, or seconds.) DCNL :param time_amount: length of time in seconds DCNL :returns: A touple of (length of time, unit of time) where unit of time is DCNL one of (\'h\', \'m\', \'s\')'
def compute_eta(start_time, current_value, final_value): DCNL 'Compute an ETA.  Now only if we could also have a progress bar... DCNL :param start_time: Unix timestamp when the operation began DCNL :param current_value: Current value DCNL :param final_value: Final value DCNL :returns: ETA as a tuple of (length of time, unit of time) where unit of DCNL time is one of (\'h\', \'m\', \'s\')'
def iter_devices_partitions(devices_dir, item_type): DCNL 'Iterate over partitions across all devices. DCNL :param devices_dir: Path to devices DCNL :param item_type: One of \'accounts\', \'containers\', or \'objects\' DCNL :returns: Each iteration returns a tuple of (device, partition)'
def unlink_older_than(path, mtime): DCNL 'Remove any file in a given path that that was last modified before mtime. DCNL :param path: path to remove file from DCNL :mtime: timestamp of oldest file to keep'
def item_from_env(env, item_name): DCNL 'Get a value from the wsgi environment DCNL :param env: wsgi environment dict DCNL :param item_name: name of item to get DCNL :returns: the value from the environment'
def cache_from_env(env): DCNL 'Get memcache connection pool from the environment (which had been DCNL previously set by the memcache middleware DCNL :param env: wsgi environment dict DCNL :returns: swift.common.memcached.MemcacheRing from environment'
def readconf(conffile, section_name=None, log_name=None, defaults=None, raw=False): DCNL 'Read config file and return config items as a dict DCNL :param conffile: path to config file, or a file-like object (hasattr DCNL readline) DCNL :param section_name: config section to read (will return all sections if DCNL not defined) DCNL :param log_name: name to be used with logging (will use section_name if DCNL not defined) DCNL :param defaults: dict of default values to pre-populate the config with DCNL :returns: dict of config items'
def write_pickle(obj, dest, tmp=None, pickle_protocol=0): DCNL 'Ensure that a pickle file gets written to disk.  The file DCNL is first written to a tmp location, ensure it is synced to disk, then DCNL perform a move to its final location DCNL :param obj: python object to be pickled DCNL :param dest: path of final destination file DCNL :param tmp: path to tmp to use, defaults to None DCNL :param pickle_protocol: protocol to pickle the obj with, defaults to 0'
def search_tree(root, glob_match, ext): DCNL 'Look in root, for any files/dirs matching glob, recurively traversing DCNL any found directories looking for files ending with ext DCNL :param root: start of search path DCNL :param glob_match: glob to match in root, matching dirs are traversed with DCNL os.walk DCNL :param ext: only files that end in ext will be returned DCNL :returns: list of full paths to matching files, sorted'
def write_file(path, contents): DCNL 'Write contents to file at path DCNL :param path: any path, subdirs will be created as needed DCNL :param contents: data to write to file, will be converted to string'
def remove_file(path): DCNL 'Quiet wrapper for os.unlink, OSErrors are suppressed DCNL :param path: first and only argument passed to os.unlink'
def audit_location_generator(devices, datadir, mount_check=True, logger=None): DCNL 'Given a devices path and a data directory, yield (path, device, DCNL partition) for all files in that directory DCNL :param devices: parent directory of the devices to be audited DCNL :param datadir: a directory located under self.devices. This should be DCNL one of the DATADIR constants defined in the account, DCNL container, and object servers. DCNL :param mount_check: Flag to check if a mount check should be performed DCNL on devices DCNL :param logger: a logger object'
def ratelimit_sleep(running_time, max_rate, incr_by=1, rate_buffer=5): DCNL 'Will eventlet.sleep() for the appropriate time so that the max_rate DCNL is never exceeded.  If max_rate is 0, will not ratelimit.  The DCNL maximum recommended rate should not exceed (1000 * incr_by) a second DCNL as eventlet.sleep() does involve some overhead.  Returns running_time DCNL that should be used for subsequent calls. DCNL :param running_time: the running time of the next allowable request. Best DCNL to start at zero. DCNL :param max_rate: The maximum rate per second allowed for the process. DCNL :param incr_by: How much to increment the counter.  Useful if you want DCNL to ratelimit 1024 bytes/sec and have differing sizes DCNL of requests. Must be >= 0. DCNL :param rate_buffer: Number of seconds the rate counter can drop and be DCNL allowed to catch up (at a faster than listed rate). DCNL A larger number will result in larger spikes in rate DCNL but better average accuracy.'
def urlparse(url): DCNL 'urlparse augmentation. DCNL This is necessary because urlparse can\'t handle RFC 2732 URLs. DCNL :param url: URL to parse.'
def human_readable(value): DCNL 'Returns the number in a human readable format; for example 1048576 = "1Mi".'
def dump_recon_cache(cache_dict, cache_file, logger, lock_timeout=2): DCNL 'Update recon cache values DCNL :param cache_dict: Dictionary of cache key/value pairs to write out DCNL :param cache_file: cache file to update DCNL :param logger: the logger to use to log an encountered error DCNL :param lock_timeout: timeout (in seconds)'
def streq_const_time(s1, s2): DCNL 'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.'
def public(func): DCNL 'Decorator to declare which methods are publicly accessible as HTTP DCNL requests DCNL :param func: function to make public'
def rsync_ip(ip): DCNL 'Transform ip string to an rsync-compatible form DCNL Will return ipv4 addresses unchanged, but will nest ipv6 addresses DCNL inside square brackets. DCNL :param ip: an ip string (ipv4 or ipv6) DCNL :returns: a string ip address'
def get_valid_utf8_str(str_or_unicode): DCNL 'Get valid parts of utf-8 str from str, unicode and even invalid utf-8 str DCNL :param str_or_unicode: a string or an unicode which can be invalid utf-8'
def list_from_csv(comma_separated_str): DCNL 'Splits the str given and returns a properly stripped list of the comma DCNL separated values.'
def csv_append(csv_string, item): DCNL 'Appends an item to a comma-separated string. DCNL If the comma-separated string is empty/None, just returns item.'
def reiterate(iterable): DCNL 'Consume the first item from an iterator, then re-chain it to the rest of DCNL the iterator.  This is useful when you want to make sure the prologue to DCNL downstream generators have been executed before continuing. DCNL :param iterable: an iterable object'
def tiers_for_dev(dev): DCNL 'Returns a tuple of tiers for a given device in ascending order by DCNL length. DCNL :returns: tuple of tiers'
def build_tier_tree(devices): DCNL 'Construct the tier tree from the zone layout. DCNL The tier tree is a dictionary that maps tiers to their child tiers. DCNL A synthetic root node of () is generated so that there\'s one tree, DCNL not a forest. DCNL Example: DCNL region 1 -+---- zone 1 -+---- 192.168.101.1:6000 -+---- device id 0 DCNL |             |                         +---- device id 1 DCNL |             |                         +---- device id 2 DCNL |             +---- 192.168.101.2:6000 -+---- device id 3 DCNL |                                       +---- device id 4 DCNL |                                       +---- device id 5 DCNL +---- zone 2 -+---- 192.168.102.1:6000 -+---- device id 6 DCNL |                         +---- device id 7 DCNL |                         +---- device id 8 DCNL +---- 192.168.102.2:6000 -+---- device id 9 DCNL +---- device id 10 DCNL region 2 -+---- zone 1 -+---- 192.168.201.1:6000 -+---- device id 12 DCNL |                         +---- device id 13 DCNL |                         +---- device id 14 DCNL +---- 192.168.201.2:6000 -+---- device id 15 DCNL +---- device id 16 DCNL +---- device id 17 DCNL The tier tree would look like: DCNL (): [(1,), (2,)], DCNL (1,): [(1, 1), (1, 2)], DCNL (2,): [(2, 1)], DCNL (1, 1): [(1, 1, 192.168.101.1:6000), DCNL (1, 1, 192.168.101.2:6000)], DCNL (1, 2): [(1, 2, 192.168.102.1:6000), DCNL (1, 2, 192.168.102.2:6000)], DCNL (2, 1): [(2, 1, 192.168.201.1:6000), DCNL (2, 1, 192.168.201.2:6000)], DCNL (1, 1, 192.168.101.1:6000): [(1, 1, 192.168.101.1:6000, 0), DCNL (1, 1, 192.168.101.1:6000, 1), DCNL (1, 1, 192.168.101.1:6000, 2)], DCNL (1, 1, 192.168.101.2:6000): [(1, 1, 192.168.101.2:6000, 3), DCNL (1, 1, 192.168.101.2:6000, 4), DCNL (1, 1, 192.168.101.2:6000, 5)], DCNL (1, 2, 192.168.102.1:6000): [(1, 2, 192.168.102.1:6000, 6), DCNL (1, 2, 192.168.102.1:6000, 7), DCNL (1, 2, 192.168.102.1:6000, 8)], DCNL (1, 2, 192.168.102.2:6000): [(1, 2, 192.168.102.2:6000, 9), DCNL (1, 2, 192.168.102.2:6000, 10)], DCNL (2, 1, 192.168.201.1:6000): [(2, 1, 192.168.201.1:6000, 12), DCNL (2, 1, 192.168.201.1:6000, 13), DCNL (2, 1, 192.168.201.1:6000, 14)], DCNL (2, 1, 192.168.201.2:6000): [(2, 1, 192.168.201.2:6000, 15), DCNL (2, 1, 192.168.201.2:6000, 16), DCNL (2, 1, 192.168.201.2:6000, 17)], DCNL :devices: device dicts from which to generate the tree DCNL :returns: tier tree'
def check_metadata(req, target_type): DCNL 'Check metadata sent in the request headers. DCNL :param req: request object DCNL :param target_type: str: one of: object, container, or account: indicates DCNL which type the target storage for the metadata is DCNL :returns: HTTPBadRequest with bad metadata otherwise None'
def check_object_creation(req, object_name): DCNL 'Check to ensure that everything is alright about an object to be created. DCNL :param req: HTTP request object DCNL :param object_name: name of object to be created DCNL :returns HTTPRequestEntityTooLarge: the object is too large DCNL :returns HTTPLengthRequired: missing content-length header and not DCNL a chunked request DCNL :returns HTTPBadRequest: missing or bad content-type header, or DCNL bad metadata'
def check_mount(root, drive): DCNL 'Verify that the path to the device is a mount point and mounted.  This DCNL allows us to fast fail on drives that have been unmounted because of DCNL issues, and also prevents us for accidentally filling up the root DCNL partition. DCNL :param root:  base path where the devices are mounted DCNL :param drive: drive name to be checked DCNL :returns: True if it is a valid mounted device, False otherwise'
def check_float(string): DCNL 'Helper function for checking if a string can be converted to a float. DCNL :param string: string to be verified as a float DCNL :returns: True if the string can be converted to a float, False otherwise'
def check_utf8(string): DCNL 'Validate if a string is valid UTF-8 str or unicode and that it DCNL does not contain any null character. DCNL :param string: string to be validated DCNL :returns: True if the string is valid utf-8 str or unicode and DCNL contains no null characters, False otherwise'
def direct_get_account(node, part, account, marker=None, limit=None, prefix=None, delimiter=None, conn_timeout=5, response_timeout=15): DCNL 'Get listings directly from the account server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the account is on DCNL :param account: account name DCNL :param marker: marker query DCNL :param limit: query limit DCNL :param prefix: prefix query DCNL :param delimeter: delimeter for the query DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: a tuple of (response headers, a list of containers) The response DCNL headers will be a dict and all header names will be lowercase.'
def direct_head_container(node, part, account, container, conn_timeout=5, response_timeout=15): DCNL 'Request container information directly from the container server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: a dict containing the response\'s headers (all header names will DCNL be lowercase)'
def direct_get_container(node, part, account, container, marker=None, limit=None, prefix=None, delimiter=None, conn_timeout=5, response_timeout=15): DCNL 'Get container listings directly from the container server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param marker: marker query DCNL :param limit: query limit DCNL :param prefix: prefix query DCNL :param delimeter: delimeter for the query DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: a tuple of (response headers, a list of objects) The response DCNL headers will be a dict and all header names will be lowercase.'
def direct_head_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15): DCNL 'Request object information directly from the object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: a dict containing the response\'s headers (all header names will DCNL be lowercase)'
def direct_get_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15, resp_chunk_size=None, headers={}): DCNL 'Get object directly from the object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :param resp_chunk_size: if defined, chunk size of data to read. DCNL :param headers: dict to be passed into HTTPConnection headers DCNL :returns: a tuple of (response headers, the object\'s contents) The response DCNL headers will be a dict and all header names will be lowercase.'
def direct_put_object(node, part, account, container, name, contents, content_length=None, etag=None, content_type=None, headers=None, conn_timeout=5, response_timeout=15, resp_chunk_size=None): DCNL 'Put object directly from the object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param name: object name DCNL :param contents: an iterable or string to read object data from DCNL :param content_length: value to send as content-length header DCNL :param etag: etag of contents DCNL :param content_type: value to send as content-type header DCNL :param headers: additional headers to include in the request DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :param chunk_size: if defined, chunk size of data to send. DCNL :returns: etag from the server response'
def direct_post_object(node, part, account, container, name, headers, conn_timeout=5, response_timeout=15): DCNL 'Direct update to object metadata on object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param name: object name DCNL :param headers: headers to store as metadata DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :raises ClientException: HTTP POST request failed'
def direct_delete_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15, headers={}): DCNL 'Delete object directly from the object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: response from server'
def retry(func, *args, **kwargs): DCNL 'Helper function to retry a given function a number of times. DCNL :param func: callable to be called DCNL :param retries: number of retries DCNL :param error_log: logger for errors DCNL :param args: arguments to send to func DCNL :param kwargs: keyward arguments to send to func (if retries or DCNL error_log are sent, they will be deleted from kwargs DCNL before sending on to func) DCNL :returns: restult of func'
def quarantine_db(object_file, server_type): DCNL 'In the case that a corrupt file is found, move it to a quarantined area to DCNL allow replication to fix it. DCNL :param object_file: path to corrupt file DCNL :param server_type: type of file that is corrupt DCNL (\'container\' or \'account\')'
def roundrobin_datadirs(datadirs): DCNL 'Generator to walk the data dirs in a round robin manner, evenly DCNL hitting each device on the system, and yielding any .db files DCNL found (in their proper places). The partitions within each data DCNL dir are walked randomly, however. DCNL :param datadirs: a list of (path, node_id) to walk DCNL :returns: A generator of (partition, path_to_db_file, node_id)'
def setup_env(): DCNL 'Try to increase resource limits of the OS. Move PYTHON_EGG_CACHE to /tmp'
def command(func): DCNL 'Decorator to declare which methods are accessible as commands, commands DCNL always return 1 or 0, where 0 should indicate success. DCNL :param func: function to make public'
def watch_server_pids(server_pids, interval=1, **kwargs): DCNL 'Monitor a collection of server pids yielding back those pids that DCNL aren\'t responding to signals. DCNL :param server_pids: a dict, lists of pids [int,...] keyed on DCNL Server objects'
def sanitize_timeout(timeout): DCNL 'Sanitize a timeout value to use an absolute expiration time if the delta DCNL is greater than 30 days (in seconds). Note that the memcached server DCNL translates negative values to mean a delta of 30 days in seconds (and 1 DCNL additional second), client beware.'
def _func_on_containers(logger, conf, concurrency_key, func): DCNL 'Run a function on each container with concurrency.'
def delete_containers(logger, conf): DCNL 'Utility function to delete benchmark containers.'
def create_containers(logger, conf): DCNL 'Utility function to create benchmark containers.'
def monkey_patch_mimetools(): DCNL 'mimetools.Message defaults content-type to "text/plain" DCNL This changes it to default to None, so we can detect missing headers.'
def get_socket(conf, default_port=8080): DCNL 'Bind socket to bind ip:port in conf DCNL :param conf: Configuration dict to read settings from DCNL :param default_port: port to use if not specified in conf DCNL :returns : a socket object as returned from socket.listen or DCNL ssl.wrap_socket if conf specifies cert_file'
def run_wsgi(conf_file, app_section, *args, **kwargs): DCNL 'Runs the server using the specified number of workers. DCNL :param conf_file: Path to paste.deploy style configuration file DCNL :param app_section: App name from conf file to load config from'
def init_request_processor(conf_file, app_section, *args, **kwargs): DCNL 'Loads common settings from conf DCNL Sets the logger DCNL Loads the request processor DCNL :param conf_file: Path to paste.deploy style configuration file DCNL :param app_section: App name from conf file to load config from DCNL :returns: the loaded application entry point DCNL :raises ConfigFileError: Exception is raised for config file error'
def make_pre_authed_request(env, method=None, path=None, body=None, headers=None, agent='Swift', swift_source=None): DCNL 'Makes a new swob.Request based on the current env but with the DCNL parameters specified. Note that this request will be preauthorized. DCNL :param env: The WSGI environment to base the new request on. DCNL :param method: HTTP method of new request; default is from DCNL the original env. DCNL :param path: HTTP path of new request; default is from the DCNL original env. path should be compatible with what you DCNL would send to Request.blank. path should be quoted and it DCNL can include a query string. for example: DCNL \'/a%20space?unicode_str%E8%AA%9E=y%20es\' DCNL :param body: HTTP body of new request; empty by default. DCNL :param headers: Extra HTTP headers of new request; None by DCNL default. DCNL :param agent: The HTTP user agent to use; default \'Swift\'. You DCNL can put %(orig)s in the agent to have it replaced DCNL with the original env\'s HTTP_USER_AGENT, such as DCNL \'%(orig)s StaticWeb\'. You also set agent to None to DCNL use the original env\'s HTTP_USER_AGENT or \'\' to DCNL have no HTTP_USER_AGENT. DCNL :param swift_source: Used to mark the request as originating out of DCNL middleware. Will be logged in proxy logs. DCNL :returns: Fresh swob.Request object.'
def make_pre_authed_env(env, method=None, path=None, agent='Swift', query_string=None, swift_source=None): DCNL 'Returns a new fresh WSGI environment with escalated privileges to DCNL do backend checks, listings, etc. that the remote user wouldn\'t DCNL be able to accomplish directly. DCNL :param env: The WSGI environment to base the new environment on. DCNL :param method: The new REQUEST_METHOD or None to use the DCNL original. DCNL :param path: The new path_info or none to use the original. path DCNL should NOT be quoted. When building a url, a Webob DCNL Request (in accordance with wsgi spec) will quote DCNL env[\'PATH_INFO\'].  url += quote(environ[\'PATH_INFO\']) DCNL :param query_string: The new query_string or none to use the original. DCNL When building a url, a Webob Request will append DCNL the query string directly to the url. DCNL url += \'?\' + env[\'QUERY_STRING\'] DCNL :param agent: The HTTP user agent to use; default \'Swift\'. You DCNL can put %(orig)s in the agent to have it replaced DCNL with the original env\'s HTTP_USER_AGENT, such as DCNL \'%(orig)s StaticWeb\'. You also set agent to None to DCNL use the original env\'s HTTP_USER_AGENT or \'\' to DCNL have no HTTP_USER_AGENT. DCNL :param swift_source: Used to mark the request as originating out of DCNL middleware. Will be logged in proxy logs. DCNL :returns: Fresh WSGI environment.'
def _datetime_property(header): DCNL 'Set and retrieve the datetime value of self.headers[header] DCNL (Used by both request and response) DCNL The header is parsed on retrieval and a datetime object is returned. DCNL The header can be set using a datetime, numeric value, or str. DCNL If a value of None is given, the header is deleted. DCNL :param header: name of the header, e.g. "Content-Length"'
def _header_property(header): DCNL 'Set and retrieve the value of self.headers[header] DCNL (Used by both request and response) DCNL If a value of None is given, the header is deleted. DCNL :param header: name of the header, e.g. "Content-Length"'
def _header_int_property(header): DCNL 'Set and retrieve the value of self.headers[header] DCNL (Used by both request and response) DCNL On retrieval, it converts values to integers. DCNL If a value of None is given, the header is deleted. DCNL :param header: name of the header, e.g. "Content-Length"'
def _resp_status_property(): DCNL 'Set and retrieve the value of Response.status DCNL On retrieval, it concatenates status_int and title. DCNL When set to a str, it splits status_int and title apart. DCNL When set to an integer, retrieves the correct title for that DCNL response code from the RESPONSE_REASONS dict.'
def _resp_body_property(): DCNL 'Set and retrieve the value of Response.body DCNL If necessary, it will consume Response.app_iter to create a body. DCNL On assignment, encodes unicode values to utf-8, and sets the content-length DCNL to the length of the str.'
def _resp_etag_property(): DCNL 'Set and retrieve Response.etag DCNL This may be broken for etag use cases other than Swift\'s. DCNL Quotes strings when assigned and unquotes when read, for compatibility DCNL with webob.'
def _resp_content_type_property(): DCNL 'Set and retrieve Response.content_type DCNL Strips off any charset when retrieved -- that is accessible DCNL via Response.charset.'
def _resp_charset_property(): DCNL 'Set and retrieve Response.charset DCNL On retrieval, separates the charset from the content-type. DCNL On assignment, removes any existing charset from the content-type and DCNL appends the new one.'
def _resp_app_iter_property(): DCNL 'Set and retrieve Response.app_iter DCNL Mostly a pass-through to Response._app_iter; it\'s a property so it can zero DCNL out an existing content-length on assignment.'
def _req_fancy_property(cls, header, even_if_nonexistent=False): DCNL 'Set and retrieve "fancy" properties. DCNL On retrieval, these properties return a class that takes the value of the DCNL header as the only argument to their constructor. DCNL For assignment, those classes should implement a __str__ that converts them DCNL back to their header values. DCNL :param header: name of the header, e.g. "Accept" DCNL :param even_if_nonexistent: Return a value even if the header does not DCNL exist.  Classes using this should be prepared to accept None as a DCNL parameter.'
def _req_environ_property(environ_field): DCNL 'Set and retrieve value of the environ_field entry in self.environ. DCNL (Used by both request and response)'
def _req_body_property(): DCNL 'Set and retrieve the Request.body parameter.  It consumes wsgi.input and DCNL returns the results.  On assignment, uses a StringIO to create a new DCNL wsgi.input.'
def _host_url_property(): DCNL 'Retrieves the best guess that can be made for an absolute location up to DCNL the path, for example: https://host.com:1234'
def wsgify(func): DCNL 'A decorator for translating functions which take a swob Request object and DCNL return a Response object into WSGI callables.  Also catches any raised DCNL HTTPExceptions and treats them as a returned Response.'
def is_informational(status): DCNL 'Check if HTTP status code is informational. DCNL :param status: http status code DCNL :returns: True if status is successful, else False'
def is_success(status): DCNL 'Check if HTTP status code is successful. DCNL :param status: http status code DCNL :returns: True if status is successful, else False'
def is_redirection(status): DCNL 'Check if HTTP status code is redirection. DCNL :param status: http status code DCNL :returns: True if status is redirection, else False'
def is_client_error(status): DCNL 'Check if HTTP status code is client error. DCNL :param status: http status code DCNL :returns: True if status is client error, else False'
def is_server_error(status): DCNL 'Check if HTTP status code is server error. DCNL :param status: http status code DCNL :returns: True if status is server error, else False'
def read_metadata(fd): DCNL 'Helper function to read the pickled metadata from an object file. DCNL :param fd: file descriptor to load the metadata from DCNL :returns: dictionary of metadata'
def write_metadata(fd, metadata): DCNL 'Helper function to write pickled metadata for an object file. DCNL :param fd: file descriptor to write the metadata DCNL :param metadata: metadata to write'
def app_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI object server apps'
def quarantine_renamer(device_path, corrupted_file_path): DCNL 'In the case that a file is corrupted, move it to a quarantined DCNL area to allow replication to fix it. DCNL :params device_path: The path to the device the corrupted file is on. DCNL :params corrupted_file_path: The path to the file you want quarantined. DCNL :returns: path (str) of directory the file was moved to DCNL :raises OSError: re-raises non errno.EEXIST / errno.ENOTEMPTY DCNL exceptions from rename'
def hash_suffix(path, reclaim_age): DCNL 'Performs reclamation and returns an md5 of all (remaining) files. DCNL :param reclaim_age: age in seconds at which to remove tombstones DCNL :raises PathNotDir: if given path is not a valid directory DCNL :raises OSError: for non-ENOTDIR errors'
def invalidate_hash(suffix_dir): DCNL 'Invalidates the hash for a suffix_dir in the partition\'s hashes file. DCNL :param suffix_dir: absolute path to suffix dir whose hash needs DCNL invalidating'
def get_hashes(partition_dir, recalculate=[], do_listdir=False, reclaim_age=ONE_WEEK): DCNL 'Get a list of hashes for the suffix dir.  do_listdir causes it to mistrust DCNL the hash cache for suffix existence at the (unexpectedly high) cost of a DCNL listdir.  reclaim_age is just passed on to hash_suffix. DCNL :param partition_dir: absolute path of partition to get hashes for DCNL :param recalculate: list of suffixes which should be recalculated when got DCNL :param do_listdir: force existence check for all hashes in the partition DCNL :param reclaim_age: age at which to remove tombstones DCNL :returns: tuple of (number of suffix dirs hashed, dictionary of hashes)'
def tpool_reraise(func, *args, **kwargs): DCNL 'Hack to work around Eventlet\'s tpool not catching and reraising Timeouts.'
def app_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI proxy apps.'
def update_headers(response, headers): DCNL 'Helper function to update headers in the response. DCNL :param response: swob.Response object DCNL :param headers: dictionary headers'
def source_key(resp): DCNL 'Provide the timestamp of the swift http response as a floating DCNL point value.  Used as a sort key. DCNL :param resp: httplib response object'
def delay_denial(func): DCNL 'Decorator to declare which methods should have any swift.authorize call DCNL delayed. This is so the method can load the Request object up with DCNL additional information that may be needed by the authorization system. DCNL :param func: function for which authorization will be delayed'
def headers_to_account_info(headers, status_int=HTTP_OK): DCNL 'Construct a cacheable dict of account info based on response headers.'
def headers_to_container_info(headers, status_int=HTTP_OK): DCNL 'Construct a cacheable dict of container info based on response headers.'
def cors_validation(func): DCNL 'Decorator to check if the request is a CORS request and if so, if it\'s DCNL valid. DCNL :param func: function to check'
def get_container_info(env, app, swift_source=None): DCNL 'Get the info structure for a container, based on env and app. DCNL This is useful to middlewares. DCNL Note: This call bypasses auth. Success does not imply that the DCNL request has authorization to the container_info.'
def get_account_info(env, app, swift_source=None): DCNL 'Get the info structure for an account, based on env and app. DCNL This is useful to middlewares. DCNL Note: This call bypasses auth. Success does not imply that the DCNL request has authorization to the account_info.'
def copy_headers_into(from_r, to_r): DCNL 'Will copy desired headers from from_r to to_r DCNL :params from_r: a swob Request or Response DCNL :params to_r: a swob Request or Response'
def app_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI account server apps'
def _build_user_auth(token=None, user_id=None, username=None, password=None, tenant_id=None, tenant_name=None, trust_id=None): DCNL 'Build auth dictionary. DCNL It will create an auth dictionary based on all the arguments DCNL that it receives.'
def from_xml(xml): DCNL 'Deserialize XML to a dictionary.'
def to_xml(d, xmlns=None): DCNL 'Serialize a dictionary to XML.'
def http_connect(ipaddr, port, device, partition, method, path, headers=None, query_string=None, ssl=False, key_file=None, cert_file=None): DCNL 'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection DCNL will be used, which is buffered for backend Swift services. DCNL :param ipaddr: IPv4 address to connect to DCNL :param port: port to connect to DCNL :param device: device of the node to query DCNL :param partition: partition on the device DCNL :param method: HTTP method to request (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: request path DCNL :param headers: dictionary of headers DCNL :param query_string: request query string DCNL :param ssl: set True if SSL should be used (default: False) DCNL :param key_file Private key file (not needed if cert_file has private key) DCNL :param cert_file Certificate file (Keystore) DCNL :returns: HTTPConnection object'
def http_connect_raw(ipaddr, port, method, path, headers=None, query_string=None, ssl=False, key_file=None, cert_file=None): DCNL 'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection DCNL will be used, which is buffered for backend Swift services. DCNL :param ipaddr: IPv4 address to connect to DCNL :param port: port to connect to DCNL :param method: HTTP method to request (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: request path DCNL :param headers: dictionary of headers DCNL :param query_string: request query string DCNL :param ssl: set True if SSL should be used (default: False) DCNL :param key_file Private key file (not needed if cert_file has private key) DCNL :param cert_file Certificate file (Keystore) DCNL :returns: HTTPConnection object'
def fail_gracefully(f): DCNL 'Logs exceptions and aborts.'
def setup_logging(conf): DCNL 'Sets up the logging options for a log with supplied name DCNL :param conf: a cfg.ConfOpts object'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file.'
def trunc_password(password): DCNL 'Truncate passwords to the MAX_PASSWORD_LENGTH.'
def hash_user_password(user): DCNL 'Hash a user dict\'s password without modifying the passed-in dict'
def hash_ldap_user_password(user): DCNL 'Hash a user dict\'s password without modifying the passed-in dict'
def hash_password(password): DCNL 'Hash a password. Hard.'
def ldap_hash_password(password): DCNL 'Hash a password. Hard.'
def check_password(password, hashed): DCNL 'Check that a plaintext password matches hashed. DCNL hashpw returns the salt value concatenated with the actual hash value. DCNL It extracts the actual salt if this value is then passed as the salt.'
def check_output(*popenargs, **kwargs): DCNL 'Run command with arguments and return its output as a byte string. DCNL If the exit code was non-zero it raises a CalledProcessError.  The DCNL CalledProcessError object will have the return code in the returncode DCNL attribute and output in the output attribute. DCNL The arguments are the same as for the Popen constructor.  Example: DCNL >>> check_output([\'ls\', \'-l\', \'/dev/null\']) DCNL \'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n\' DCNL The stdout argument is not allowed as it is used internally. DCNL To capture standard error in the result, use stderr=STDOUT. DCNL >>> check_output([\'/bin/sh\', \'-c\', DCNL ...               \'ls -l non_existent_file ; exit 0\'], DCNL ...              stderr=STDOUT) DCNL \'ls: non_existent_file: No such file or directory\n\''
def unixtime(dt_obj): DCNL 'Format datetime object as unix timestamp DCNL :param dt_obj: datetime.datetime object DCNL :returns: float'
def auth_str_equal(provided, known): DCNL 'Constant-time string comparison. DCNL :params provided: the first string DCNL :params known: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.  When using the function for this purpose, always DCNL provide the user-provided password as the first argument.  The time this DCNL function will take is always a factor of the length of this string.'
def cms_verify(formatted, signing_cert_file_name, ca_file_name): DCNL 'verifies the signature of the contents IAW CMS syntax'
def is_ans1_token(token): DCNL 'thx to ayoung for sorting this out. DCNL base64 decoded hex representation of MII is 3082 DCNL In [3]: binascii.hexlify(base64.b64decode(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf DCNL pg4:  For tags from 0 to 30 the first octet is the identfier DCNL pg10: Hex 30 means sequence, followed by the length of that sequence. DCNL pg5:  Second octet is the length octet DCNL first bit indicates short or long form, next 7 bits encode the number DCNL of subsequent octets that make up the content length octets as an DCNL unsigned binary int DCNL 82 = 10000010 (first bit indicates long form) DCNL 0000010 = 2 octets of content length DCNL so read the next 2 octets to get the length of the content. DCNL In the case of a very large content length there could be a requirement to DCNL have more than 2 octets to designate the content length, therefore DCNL requiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encode(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encode(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI would become invalid at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encode(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 7FFF or 32767 DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only and ignore the case of larger tokens'
def cms_sign_text(text, signing_cert_file_name, signing_key_file_name): DCNL 'Uses OpenSSL to sign a document DCNL Produces a Base64 encoding of a DER formatted CMS Document DCNL http://en.wikipedia.org/wiki/Cryptographic_Message_Syntax'
def cms_hash_token(token_id): DCNL 'return: for ans1_token, returns the hash of the passed in token DCNL otherwise, returns what it was passed in.'
def provider(name): DCNL 'Register the wrapped dependency provider under the specified name.'
def requires(*dependencies): DCNL 'Inject specified dependencies from the registry into the instance.'
def _match_query(query, attrs): DCNL 'Match an ldap query to an attribute dictionary. DCNL The characters &, |, and ! are supported in the query. No syntax checking DCNL is performed, so malformed queries will not work correctly.'
def _paren_groups(source): DCNL 'Split a string into parenthesized groups.'
def _match(key, value, attrs): DCNL 'Match a given key and value against an attribute list.'
def _subs(value): DCNL 'Returns a list of subclass strings. DCNL The strings represent the ldap objectclass plus any subclasses that DCNL inherit from it. Fakeldap doesn\'t know about the ldap object structure, DCNL so subclasses need to be defined manually in the dictionary below.'
def render_response(body=None, status=None, headers=None): DCNL 'Forms a WSGI response.'
def render_exception(error): DCNL 'Forms a WSGI response based on the current error.'
def initialize_decorator(init): DCNL 'Ensure that the length of string field do not exceed the limit. DCNL This decorator check the initialize arguments, to make sure the DCNL length of string field do not exceed the length limit, or raise a DCNL \'StringLengthExceeded\' exception. DCNL Use decorator instead of inheritance, because the metaclass will DCNL check the __tablename__, primary key columns, etc. at the class DCNL definition.'
def handle_conflicts(type='object'): DCNL 'Converts IntegrityError into HTTP 409 Conflict.'
def upgrade(migrate_engine): DCNL 'Creates the default domain.'
def downgrade(migrate_engine): DCNL 'Delete the default domain.'
def upgrade(migrate_engine): DCNL 'Create API-version specific endpoint tables.'
def downgrade(migrate_engine): DCNL 'Replace API-version specific endpoint tables with one based on v2.'
def upgrade(migrate_engine): DCNL 'Replace API-version specific endpoint tables with one based on v3.'
def downgrade(migrate_engine): DCNL 'Create API-version specific endpoint tables.'
def upgrade(migrate_engine): DCNL 'Split each legacy endpoint into separate records for each interface.'
def downgrade(migrate_engine): DCNL 'Re-create the v2 endpoints table based on v3 endpoints.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def flatten(d, parent_key=''): DCNL 'Flatten a nested dictionary DCNL Converts a dictionary with nested values to a single level flat DCNL dictionary, with dotted notation for each key.'
def protected(f): DCNL 'Wraps API calls with role based access controls (RBAC).'
def filterprotected(*filters): DCNL 'Wraps filtered API calls with role based access controls (RBAC).'
def enforce(credentials, action, target, do_raise=True): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param credentials: user credentials DCNL :param action: string representing the action to be checked, which DCNL should be colon separated for clarity. DCNL :param target: dictionary representing the object of the action DCNL for object creation this should be a dictionary DCNL representing the location of the object e.g. DCNL {\'project_id\': object.project_id} DCNL :raises: `exception.Forbidden` if verification fails. DCNL Actions should be colon separated for clarity. For example: DCNL * identity:list_users'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def unique_id(token_id): DCNL 'Return a unique ID for a token. DCNL The returned value is useful as the primary key of a database table, DCNL memcache store, or other lookup table. DCNL :returns: Given a PKI token, returns it\'s hashed value. Otherwise, returns DCNL the passed-in value (such as a UUID token ID or an existing DCNL hash).'
def default_expire_time(): DCNL 'Determine when a fresh token should expire. DCNL Expiration time varies based on configuration (see ``[token] expiration``). DCNL :returns: a naive UTC datetime.datetime object'
def validate_auth_info(self, context, user_ref, tenant_ref): DCNL 'Validate user and tenant auth info. DCNL Validate the user and tenant auth into in order to ensure that user and DCNL tenant information is valid and not disabled. DCNL Consolidate the checks here to ensure consistency between token auth and DCNL ec2 auth. DCNL :params context: keystone\'s request context DCNL :params user_ref: the authenticating user DCNL :params tenant_ref: the scope of authorization, if any DCNL :raises Unauthorized: if any of the user, user\'s domain, tenant or DCNL tenant\'s domain are either disabled or otherwise invalid'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def set_rules(rules): DCNL 'Set the rules in use for policy checks.'
def reset(): DCNL 'Clear the rules used for policy checks.'
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL 'Checks authorization of a rule against the target and credentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operated DCNL on as possible, as a dictionary. DCNL :param creds: As much information about the user performing the DCNL action as possible, as a dictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passed to check() (both DCNL positional and keyword arguments) will be passed to DCNL the exception class.  If exc is not provided, returns DCNL False. DCNL :return: Returns False if the policy does not allow the action and DCNL exc is not provided; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specified string DCNL from the expression.'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Provided for backwards compatibility.  Translates the old DCNL list-of-lists syntax into a tree of Check objects.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods.  Arguments are a sequence of DCNL tokens, in order, which should trigger running this reduction DCNL method.'
def _parse_text_rule(rule): DCNL 'Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def to_primitive(value, convert_instances=False, level=0): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def filter_user(user_ref): DCNL 'Filter out private items in a user dict. DCNL \'password\', \'tenants\' and \'groups\' are never returned. DCNL :returns: user_ref'
def format_url(url, data): DCNL 'Helper Method for all Backend Catalog\'s to Deal with URLS'
def recreate_token_data(context, token_data=None, expires=None, user_ref=None, project_ref=None): DCNL 'Recreate token from an existing token. DCNL Repopulate the ephemeral data and return the new token data.'
def render_token_data_response(token_id, token_data, created=False): DCNL 'Render token data HTTP response. DCNL Stash token ID into the X-Auth-Token header.'
def run_command_with_code(cmd, redirect_output=True, check_exit_code=True): DCNL 'Runs a command in an out-of-process shell, returning the DCNL output of that command.  Working directory is ROOT.'
def create_virtualenv(venv=VENV, no_site_packages=True): DCNL 'Creates the virtual environment and installs PIP only into the DCNL virtual environment'
def parse_args(): DCNL 'Parse command-line arguments'
def getid(obj): DCNL 'Abstracts the common pattern of allowing both an object or an object\'s ID DCNL as a parameter when dealing with relationships.'
def cms_verify(formatted, signing_cert_file_name, ca_file_name): DCNL 'verifies the signature of the contents IAW CMS syntax'
def is_ans1_token(token): DCNL 'thx to ayoung for sorting this out. DCNL base64 decoded hex representation of MII is 3082 DCNL In [3]: binascii.hexlify(base64.b64decode(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf DCNL pg4:  For tags from 0 to 30 the first octet is the identfier DCNL pg10: Hex 30 means sequence, followed by the length of that sequence. DCNL pg5:  Second octet is the length octet DCNL first bit indicates short or long form, next 7 bits encode the number DCNL of subsequent octets that make up the content length octets as an DCNL unsigned binary int DCNL 82 = 10000010 (first bit indicates long form) DCNL 0000010 = 2 octets of content length DCNL so read the next 2 octets to get the length of the content. DCNL In the case of a very large content length there could be a requirement to DCNL have more than 2 octets to designate the content length, therefore DCNL requiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encode(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encode(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI would become invalid at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encode(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 7FFF or 32767 DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only and ignore the case of larger tokens'
def cms_sign_text(text, signing_cert_file_name, signing_key_file_name): DCNL 'Uses OpenSSL to sign a document DCNL Produces a Base64 encoding of a DER formatted CMS Document DCNL http://en.wikipedia.org/wiki/Cryptographic_Message_Syntax'
def cms_hash_token(token_id): DCNL 'return: for ans1_token, returns the hash of the passed in token DCNL otherwise, returns what it was passed in.'
def will_expire_soon(expiry): DCNL 'Determines if expiration is about to occur. DCNL :param expiry: a datetime of the expected expiration DCNL :returns: boolean : true if expiration is within 30 seconds'
def safe_quote(s): DCNL 'URL-encode strings that are not already URL-encoded.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def assert_crypto_availability(f): DCNL 'Ensure Crypto module is available.'
def generate_aes_key(token, secret): DCNL 'Generates and returns a 256 bit AES key, based on sha256 hash.'
def compute_mac(token, serialized_data): DCNL 'Computes and returns the base64 encoded MAC.'
def hash_data(data): DCNL 'Return the base64 encoded SHA1 hash of the data.'
def sign_data(token, data): DCNL 'MAC the data using SHA1.'
def verify_signed_data(token, data): DCNL 'Verify data integrity by ensuring MAC is valid.'
@assert_crypto_availability DCNL def encrypt_data(token, secret, data): DCNL 'Encryptes the data with the given secret key.'
@assert_crypto_availability DCNL def decrypt_data(token, secret, data): DCNL 'Decrypt the data with the given secret key.'
def arg(*args, **kwargs): DCNL 'Decorator for CLI args.'
def env(*vars, **kwargs): DCNL 'returns the first environment variable set DCNL if none are non-empty, defaults to \'\' or keyword arg default'
def add_arg(f, *args, **kwargs): DCNL 'Bind CLI arguments to a shell.py `do_foo` function.'
def add_resource_manager_extra_kwargs_hook(f, hook): DCNL 'Adds hook to bind CLI arguments to ResourceManager calls. DCNL The `do_foo` calls in shell.py will receive CLI args and then in turn pass DCNL them through to the ResourceManager. Before passing through the args, the DCNL hooks registered here will be called, giving us a chance to add extra DCNL kwargs (taken from the command-line) to what\'s passed to the DCNL ResourceManager.'
def get_resource_manager_extra_kwargs(f, args, allow_conflicts=False): DCNL 'Return extra_kwargs by calling resource manager kwargs hooks.'
def unauthenticated(f): DCNL 'Adds \'unauthenticated\' attribute to decorated function. DCNL Usage: DCNL @unauthenticated DCNL def mymethod(f):'
def isunauthenticated(f): DCNL 'Checks to see if the function is marked as not requiring authentication DCNL with the @unauthenticated decorator. Returns True if decorator is DCNL set to True, False otherwise.'
def service_type(stype): DCNL 'Adds \'service_type\' attribute to decorated function. DCNL Usage: DCNL @service_type(\'monitor\') DCNL def mymethod(f):'
def get_service_type(f): DCNL 'Retrieves service type from function'
def find_resource(manager, name_or_id): DCNL 'Helper for the _find_* methods.'
def safe_issubclass(*args): DCNL 'Like issubclass, but will just return False if not a class.'
def import_class(import_str): DCNL 'Returns a class from a string including module and class.'
def slugify(value): DCNL 'Normalizes string, converts to lowercase, removes non-alpha characters, DCNL and converts spaces to hyphens. DCNL From Django\'s "django/template/defaultfilters.py".'
def from_response(response, body): DCNL 'Return an instance of an ClientException or subclass DCNL based on an requests response. DCNL Usage:: DCNL resp, body = requests.request(...) DCNL if resp.status_code != 200: DCNL raise exception_from_response(resp, rest.text)'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def _poll_for_status(poll_fn, obj_id, action, final_ok_states, poll_period=5, show_progress=True): DCNL 'Block while an action is being performed, periodically printing DCNL progress.'
def _find_monitor(cs, monitor): DCNL 'Get a monitor by ID.'
def _find_monitor_snapshot(cs, snapshot): DCNL 'Get a monitor snapshot by ID.'
def _find_backup(cs, backup): DCNL 'Get a backup by ID.'
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.service_type('monitor') DCNL def do_list(cs, args): DCNL 'List all the monitors.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor.') DCNL @utils.service_type('monitor') DCNL def do_show(cs, args): DCNL 'Show details about a monitor.'
@utils.arg('size', metavar='<size>', type=int, help='Size DCSP of DCSP monitor DCSP in DCSP GB') DCNL @utils.arg('--snapshot-id', metavar='<snapshot-id>', default=None, help='Create DCSP monitor DCSP from DCSP snapshot DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--snapshot_id', help=argparse.SUPPRESS) DCNL @utils.arg('--source-volid', metavar='<source-volid>', default=None, help='Create DCSP monitor DCSP from DCSP monitor DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--source_volid', help=argparse.SUPPRESS) DCNL @utils.arg('--image-id', metavar='<image-id>', default=None, help='Create DCSP monitor DCSP from DCSP image DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--image_id', help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='ServiceManage DCSP name DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='ServiceManage DCSP description DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.arg('--monitor-type', metavar='<monitor-type>', default=None, help='ServiceManage DCSP type DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--monitor_type', help=argparse.SUPPRESS) DCNL @utils.arg('--availability-zone', metavar='<availability-zone>', default=None, help='Availability DCSP zone DCSP for DCSP monitor DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--availability_zone', help=argparse.SUPPRESS) DCNL @utils.arg('--metadata', type=str, nargs='*', metavar='<key=value>', help='Metadata DCSP key=value DCSP pairs DCSP (Optional, DCSP Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_create(cs, args): DCNL 'Add a new monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_delete(cs, args): DCNL 'Remove a monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_force_delete(cs, args): DCNL 'Attempt forced removal of a monitor, regardless of its state.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP rename.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP monitor.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP monitor DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_rename(cs, args): DCNL 'Rename a monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP update DCSP metadata DCSP on.') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='+', default=[], help='Metadata DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_metadata(cs, args): DCNL 'Set or Delete metadata on a monitor.'
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', default=None, help='Filter DCSP results DCSP by DCSP monitor-id') DCNL @utils.service_type('monitor') DCNL def do_snapshot_list(cs, args): DCNL 'List all the snapshots.'
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_show(cs, args): DCNL 'Show details about a snapshot.'
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='Optional DCSP snapshot DCSP description. DCSP (Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL def do_snapshot_create(cs, args): DCNL 'Add a new snapshot.'
@utils.arg('snapshot_id', metavar='<snapshot-id>', help='ID DCSP of DCSP the DCSP snapshot DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_delete(cs, args): DCNL 'Remove a snapshot.'
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP snapshot.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP snapshot DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_snapshot_rename(cs, args): DCNL 'Rename a snapshot.'
@utils.service_type('monitor') DCNL def do_type_list(cs, args): DCNL 'Print a list of available \'monitor types\'.'
@utils.service_type('monitor') DCNL def do_extra_specs_list(cs, args): DCNL 'Print a list of current \'monitor types and extra specs\' (Admin Only).'
@utils.arg('name', metavar='<name>', help='Name DCSP of DCSP the DCSP new DCSP monitor DCSP type') DCNL @utils.service_type('monitor') DCNL def do_type_create(cs, args): DCNL 'Create a new monitor type.'
@utils.arg('id', metavar='<id>', help='Unique DCSP ID DCSP of DCSP the DCSP monitor DCSP type DCSP to DCSP delete') DCNL @utils.service_type('monitor') DCNL def do_type_delete(cs, args): DCNL 'Delete a specific monitor type'
@utils.arg('vtype', metavar='<vtype>', help='Name DCSP or DCSP ID DCSP of DCSP the DCSP monitor DCSP type') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='*', default=None, help='Extra_specs DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_type_key(cs, args): DCNL 'Set or unset extra_spec for a monitor type.'
def do_endpoints(cs, args): DCNL 'Discover endpoints that get returned from the authenticate services'
def do_credentials(cs, args): DCNL 'Show user credentials returned from auth'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_show(cs, args): DCNL 'List the quotas for a tenant.'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP default DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_defaults(cs, args): DCNL 'List the default quotas for a tenant.'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_update(cs, args): DCNL 'Update the quotas for a tenant.'
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_show(cs, args): DCNL 'List the quotas for a quota class.'
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_update(cs, args): DCNL 'Update the quotas for a quota class.'
@utils.service_type('monitor') DCNL def do_absolute_limits(cs, args): DCNL 'Print a list of absolute limits for a user'
@utils.service_type('monitor') DCNL def do_rate_limits(cs, args): DCNL 'Print a list of rate limits for a user'
def _find_monitor_type(cs, vtype): DCNL 'Get a monitor type by name or ID.'
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP upload DCSP to DCSP an DCSP image') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP upload DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--container-format', metavar='<container-format>', help='Optional DCSP type DCSP for DCSP container DCSP format DCSP (Default=bare)', default='bare') DCNL @utils.arg('--disk-format', metavar='<disk-format>', help='Optional DCSP type DCSP for DCSP disk DCSP format DCSP (Default=raw)', default='raw') DCNL @utils.arg('image_name', metavar='<image-name>', help='Name DCSP for DCSP created DCSP image') DCNL @utils.service_type('monitor') DCNL def do_upload_to_image(cs, args): DCNL 'Upload monitor to image service as image.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP backup.') DCNL @utils.arg('--container', metavar='<container>', help='Optional DCSP Backup DCSP container DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-name', metavar='<display-name>', help='Optional DCSP backup DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP backup DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_create(cs, args): DCNL 'Creates a backup.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup.') DCNL @utils.service_type('monitor') DCNL def do_backup_show(cs, args): DCNL 'Show details about a backup.'
@utils.service_type('monitor') DCNL def do_backup_list(cs, args): DCNL 'List all the backups.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_backup_delete(cs, args): DCNL 'Remove a backup.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP restore.') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', help='Optional DCSP ID DCSP of DCSP the DCSP monitor DCSP to DCSP restore DCSP to.', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_restore(cs, args): DCNL 'Restore a backup.'
@utils.service_type('monitor') DCNL def do_list_extensions(client, _args): DCNL 'List all the os-api extensions that are available.'
def getid(obj): DCNL 'Abstracts the common pattern of allowing both an object or an object\'s ID DCNL as a parameter when dealing with relationships.'
def cms_verify(formatted, signing_cert_file_name, ca_file_name): DCNL 'verifies the signature of the contents IAW CMS syntax'
def is_ans1_token(token): DCNL 'thx to ayoung for sorting this out. DCNL base64 decoded hex representation of MII is 3082 DCNL In [3]: binascii.hexlify(base64.b64decode(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf DCNL pg4:  For tags from 0 to 30 the first octet is the identfier DCNL pg10: Hex 30 means sequence, followed by the length of that sequence. DCNL pg5:  Second octet is the length octet DCNL first bit indicates short or long form, next 7 bits encode the number DCNL of subsequent octets that make up the content length octets as an DCNL unsigned binary int DCNL 82 = 10000010 (first bit indicates long form) DCNL 0000010 = 2 octets of content length DCNL so read the next 2 octets to get the length of the content. DCNL In the case of a very large content length there could be a requirement to DCNL have more than 2 octets to designate the content length, therefore DCNL requiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encode(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encode(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI would become invalid at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encode(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 7FFF or 32767 DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only and ignore the case of larger tokens'
def cms_sign_text(text, signing_cert_file_name, signing_key_file_name): DCNL 'Uses OpenSSL to sign a document DCNL Produces a Base64 encoding of a DER formatted CMS Document DCNL http://en.wikipedia.org/wiki/Cryptographic_Message_Syntax'
def cms_hash_token(token_id): DCNL 'return: for ans1_token, returns the hash of the passed in token DCNL otherwise, returns what it was passed in.'
def will_expire_soon(expiry): DCNL 'Determines if expiration is about to occur. DCNL :param expiry: a datetime of the expected expiration DCNL :returns: boolean : true if expiration is within 30 seconds'
def safe_quote(s): DCNL 'URL-encode strings that are not already URL-encoded.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def assert_crypto_availability(f): DCNL 'Ensure Crypto module is available.'
def generate_aes_key(token, secret): DCNL 'Generates and returns a 256 bit AES key, based on sha256 hash.'
def compute_mac(token, serialized_data): DCNL 'Computes and returns the base64 encoded MAC.'
def hash_data(data): DCNL 'Return the base64 encoded SHA1 hash of the data.'
def sign_data(token, data): DCNL 'MAC the data using SHA1.'
def verify_signed_data(token, data): DCNL 'Verify data integrity by ensuring MAC is valid.'
@assert_crypto_availability DCNL def encrypt_data(token, secret, data): DCNL 'Encryptes the data with the given secret key.'
@assert_crypto_availability DCNL def decrypt_data(token, secret, data): DCNL 'Decrypt the data with the given secret key.'
def arg(*args, **kwargs): DCNL 'Decorator for CLI args.'
def env(*vars, **kwargs): DCNL 'returns the first environment variable set DCNL if none are non-empty, defaults to \'\' or keyword arg default'
def add_arg(f, *args, **kwargs): DCNL 'Bind CLI arguments to a shell.py `do_foo` function.'
def add_resource_manager_extra_kwargs_hook(f, hook): DCNL 'Adds hook to bind CLI arguments to ResourceManager calls. DCNL The `do_foo` calls in shell.py will receive CLI args and then in turn pass DCNL them through to the ResourceManager. Before passing through the args, the DCNL hooks registered here will be called, giving us a chance to add extra DCNL kwargs (taken from the command-line) to what\'s passed to the DCNL ResourceManager.'
def get_resource_manager_extra_kwargs(f, args, allow_conflicts=False): DCNL 'Return extra_kwargs by calling resource manager kwargs hooks.'
def unauthenticated(f): DCNL 'Adds \'unauthenticated\' attribute to decorated function. DCNL Usage: DCNL @unauthenticated DCNL def mymethod(f):'
def isunauthenticated(f): DCNL 'Checks to see if the function is marked as not requiring authentication DCNL with the @unauthenticated decorator. Returns True if decorator is DCNL set to True, False otherwise.'
def service_type(stype): DCNL 'Adds \'service_type\' attribute to decorated function. DCNL Usage: DCNL @service_type(\'monitor\') DCNL def mymethod(f):'
def get_service_type(f): DCNL 'Retrieves service type from function'
def find_resource(manager, name_or_id): DCNL 'Helper for the _find_* methods.'
def safe_issubclass(*args): DCNL 'Like issubclass, but will just return False if not a class.'
def import_class(import_str): DCNL 'Returns a class from a string including module and class.'
def slugify(value): DCNL 'Normalizes string, converts to lowercase, removes non-alpha characters, DCNL and converts spaces to hyphens. DCNL From Django\'s "django/template/defaultfilters.py".'
def from_response(response, body): DCNL 'Return an instance of an ClientException or subclass DCNL based on an requests response. DCNL Usage:: DCNL resp, body = requests.request(...) DCNL if resp.status_code != 200: DCNL raise exception_from_response(resp, rest.text)'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def _poll_for_status(poll_fn, obj_id, action, final_ok_states, poll_period=5, show_progress=True): DCNL 'Block while an action is being performed, periodically printing DCNL progress.'
def _find_monitor(cs, monitor): DCNL 'Get a monitor by ID.'
def _find_monitor_snapshot(cs, snapshot): DCNL 'Get a monitor snapshot by ID.'
def _find_backup(cs, backup): DCNL 'Get a backup by ID.'
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.service_type('monitor') DCNL def do_list(cs, args): DCNL 'List all the monitors.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor.') DCNL @utils.service_type('monitor') DCNL def do_show(cs, args): DCNL 'Show details about a monitor.'
@utils.arg('size', metavar='<size>', type=int, help='Size DCSP of DCSP monitor DCSP in DCSP GB') DCNL @utils.arg('--snapshot-id', metavar='<snapshot-id>', default=None, help='Create DCSP monitor DCSP from DCSP snapshot DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--snapshot_id', help=argparse.SUPPRESS) DCNL @utils.arg('--source-volid', metavar='<source-volid>', default=None, help='Create DCSP monitor DCSP from DCSP monitor DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--source_volid', help=argparse.SUPPRESS) DCNL @utils.arg('--image-id', metavar='<image-id>', default=None, help='Create DCSP monitor DCSP from DCSP image DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--image_id', help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='ServiceManage DCSP name DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='ServiceManage DCSP description DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.arg('--monitor-type', metavar='<monitor-type>', default=None, help='ServiceManage DCSP type DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--monitor_type', help=argparse.SUPPRESS) DCNL @utils.arg('--availability-zone', metavar='<availability-zone>', default=None, help='Availability DCSP zone DCSP for DCSP monitor DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--availability_zone', help=argparse.SUPPRESS) DCNL @utils.arg('--metadata', type=str, nargs='*', metavar='<key=value>', help='Metadata DCSP key=value DCSP pairs DCSP (Optional, DCSP Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_create(cs, args): DCNL 'Add a new monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_delete(cs, args): DCNL 'Remove a monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_force_delete(cs, args): DCNL 'Attempt forced removal of a monitor, regardless of its state.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP rename.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP monitor.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP monitor DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_rename(cs, args): DCNL 'Rename a monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP update DCSP metadata DCSP on.') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='+', default=[], help='Metadata DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_metadata(cs, args): DCNL 'Set or Delete metadata on a monitor.'
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', default=None, help='Filter DCSP results DCSP by DCSP monitor-id') DCNL @utils.service_type('monitor') DCNL def do_snapshot_list(cs, args): DCNL 'List all the snapshots.'
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_show(cs, args): DCNL 'Show details about a snapshot.'
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='Optional DCSP snapshot DCSP description. DCSP (Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL def do_snapshot_create(cs, args): DCNL 'Add a new snapshot.'
@utils.arg('snapshot_id', metavar='<snapshot-id>', help='ID DCSP of DCSP the DCSP snapshot DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_delete(cs, args): DCNL 'Remove a snapshot.'
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP snapshot.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP snapshot DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_snapshot_rename(cs, args): DCNL 'Rename a snapshot.'
@utils.service_type('monitor') DCNL def do_type_list(cs, args): DCNL 'Print a list of available \'monitor types\'.'
@utils.service_type('monitor') DCNL def do_extra_specs_list(cs, args): DCNL 'Print a list of current \'monitor types and extra specs\' (Admin Only).'
@utils.arg('name', metavar='<name>', help='Name DCSP of DCSP the DCSP new DCSP monitor DCSP type') DCNL @utils.service_type('monitor') DCNL def do_type_create(cs, args): DCNL 'Create a new monitor type.'
@utils.arg('id', metavar='<id>', help='Unique DCSP ID DCSP of DCSP the DCSP monitor DCSP type DCSP to DCSP delete') DCNL @utils.service_type('monitor') DCNL def do_type_delete(cs, args): DCNL 'Delete a specific monitor type'
@utils.arg('vtype', metavar='<vtype>', help='Name DCSP or DCSP ID DCSP of DCSP the DCSP monitor DCSP type') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='*', default=None, help='Extra_specs DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_type_key(cs, args): DCNL 'Set or unset extra_spec for a monitor type.'
def do_endpoints(cs, args): DCNL 'Discover endpoints that get returned from the authenticate services'
def do_credentials(cs, args): DCNL 'Show user credentials returned from auth'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_show(cs, args): DCNL 'List the quotas for a tenant.'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP default DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_defaults(cs, args): DCNL 'List the default quotas for a tenant.'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_update(cs, args): DCNL 'Update the quotas for a tenant.'
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_show(cs, args): DCNL 'List the quotas for a quota class.'
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_update(cs, args): DCNL 'Update the quotas for a quota class.'
@utils.service_type('monitor') DCNL def do_absolute_limits(cs, args): DCNL 'Print a list of absolute limits for a user'
@utils.service_type('monitor') DCNL def do_rate_limits(cs, args): DCNL 'Print a list of rate limits for a user'
def _find_monitor_type(cs, vtype): DCNL 'Get a monitor type by name or ID.'
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP upload DCSP to DCSP an DCSP image') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP upload DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--container-format', metavar='<container-format>', help='Optional DCSP type DCSP for DCSP container DCSP format DCSP (Default=bare)', default='bare') DCNL @utils.arg('--disk-format', metavar='<disk-format>', help='Optional DCSP type DCSP for DCSP disk DCSP format DCSP (Default=raw)', default='raw') DCNL @utils.arg('image_name', metavar='<image-name>', help='Name DCSP for DCSP created DCSP image') DCNL @utils.service_type('monitor') DCNL def do_upload_to_image(cs, args): DCNL 'Upload monitor to image service as image.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP backup.') DCNL @utils.arg('--container', metavar='<container>', help='Optional DCSP Backup DCSP container DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-name', metavar='<display-name>', help='Optional DCSP backup DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP backup DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_create(cs, args): DCNL 'Creates a backup.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup.') DCNL @utils.service_type('monitor') DCNL def do_backup_show(cs, args): DCNL 'Show details about a backup.'
@utils.service_type('monitor') DCNL def do_backup_list(cs, args): DCNL 'List all the backups.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_backup_delete(cs, args): DCNL 'Remove a backup.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP restore.') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', help='Optional DCSP ID DCSP of DCSP the DCSP monitor DCSP to DCSP restore DCSP to.', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_restore(cs, args): DCNL 'Restore a backup.'
@utils.service_type('monitor') DCNL def do_list_extensions(client, _args): DCNL 'List all the os-api extensions that are available.'
def _sanitize_default(s): DCNL 'Set up a reasonably sensible default for pybasedir, my_ip and host.'
def monitor_todo_format(physical_line): DCNL 'Check for \'TODO()\'. DCNL monitor HACKING guide recommendation for TODO: DCNL Include your name with TODOs as in "#TODO(termie)" DCNL N101'
def monitor_except_format(logical_line): DCNL 'Check for \'except:\'. DCNL monitor HACKING guide recommends not using except: DCNL Do not write "except:", use "except Exception:" at the very least DCNL N201'
def monitor_except_format_assert(logical_line): DCNL 'Check for \'assertRaises(Exception\'. DCNL monitor HACKING guide recommends not using assertRaises(Exception...): DCNL Do not use overly broad Exception type DCNL N202'
def monitor_one_import_per_line(logical_line): DCNL 'Check for import format. DCNL monitor HACKING guide recommends one import per line: DCNL Do not import more than one module per line DCNL Examples: DCNL BAD: from monitor.rpc.common import RemoteError, LOG DCNL N301'
def monitor_import_module_only(logical_line): DCNL 'Check for import module only. DCNL monitor HACKING guide recommends importing only modules: DCNL Do not import objects, only modules DCNL N302 import only modules DCNL N303 Invalid Import DCNL N304 Relative Import'
def monitor_import_alphabetical(physical_line, line_number, lines): DCNL 'Check for imports in alphabetical order. DCNL monitor HACKING guide recommendation for imports: DCNL imports in human alphabetical order DCNL N306'
def monitor_docstring_start_space(physical_line): DCNL 'Check for docstring not start with space. DCNL monitor HACKING guide recommendation for docstring: DCNL Docstring should not start with space DCNL N401'
def monitor_docstring_one_line(physical_line): DCNL 'Check one line docstring end. DCNL monitor HACKING guide recommendation for one line docstring: DCNL A one line docstring looks like this and ends in a period. DCNL N402'
def monitor_docstring_multiline_end(physical_line): DCNL 'Check multi line docstring end. DCNL monitor HACKING guide recommendation for docstring: DCNL Docstring should end on a new line DCNL N403'
def check_l18n(): DCNL 'Generator that checks token stream for localization errors. DCNL Expects tokens to be ``send``ed one by one. DCNL Raises LocalizationError if some error is found.'
def monitor_localization_strings(logical_line, tokens): DCNL 'Check localization in line. DCNL N701: bad localization call DCNL N702: complex expression instead of string as argument to _() DCNL N703: multiple positional placeholders'
def readlines(filename): DCNL 'Record the current file being tested.'
def add_monitor(): DCNL 'Monkey patch in monitor guidelines. DCNL Look for functions that start with monitor_  and have arguments DCNL and add them to pep8 module DCNL Assumes you know how to write pep8.py checks'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'A paste pipeline replica that keys off of auth_strategy.'
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL 'Registers all standard API extensions.'
def get_pagination_params(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specified, 0, or DCNL > max_limit, we default to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBadRequest() exceptions to be raised.'
def _get_limit_param(request): DCNL 'Extract integer limit from request or fail'
def _get_marker_param(request): DCNL 'Extract marker id from request or fail'
def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to requested offset and limit. DCNL :param items: A sliceable entity DCNL :param request: ``wsgi.Request`` possibly containing \'offset\' and \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL and \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specified, 0, or > max_limit, we default DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBadRequest() exceptions to be raised. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''
def limited_by_marker(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to the requested marker and limit.'
def remove_version_from_href(href): DCNL 'Removes the first api version from the href. DCNL Given: \'http://www.monitor.com/v1.1/123\' DCNL Returns: \'http://www.monitor.com/123\' DCNL Given: \'http://www.monitor.com/v1.1\' DCNL Returns: \'http://www.monitor.com\''
def get_items(obj): DCNL 'Get items in obj.'
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Create a template element as a child of another. DCNL Corresponds to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the addition of the parent.'
def make_links(parent, selector=None): DCNL 'Attach an Atom <links> element to the parent.'
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL 'Utility for simple XML templates that traditionally used DCNL XMLDictSerializer with no metadata.  Returns a template element DCNL where the top-level element has the given tag name, and where DCNL sub-elements have tag names derived from the object\'s keys and DCNL text derived from the object\'s values.  This only works for flat DCNL dictionary objects, not dictionaries containing nested lists or DCNL dictionaries.'
def serializers(**serializers): DCNL 'Attaches serializers to a method. DCNL This decorator associates a dictionary of serializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def deserializers(**deserializers): DCNL 'Attaches deserializers to a method. DCNL This decorator associates a dictionary of deserializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def response(code): DCNL 'Attaches response code to a method. DCNL This decorator associates a response code with a method.  Note DCNL that the function attributes are directly manipulated; the method DCNL is not wrapped.'
def action_peek_json(body): DCNL 'Determine action to invoke.'
def action_peek_xml(body): DCNL 'Determine action to invoke.'
def action(name): DCNL 'Mark a function as an action. DCNL The given name will be taken as the action key in the body. DCNL This is also overloaded to allow extensions to provide DCNL non-extending definitions of create and delete operations.'
def extends(*args, **kwargs): DCNL 'Indicate a function extends an operation. DCNL Can be used as either:: DCNL @extends DCNL def index(...): DCNL pass DCNL or as:: DCNL @extends(action=\'resize\') DCNL def _action_resize(...): DCNL pass'
def unquote_header_value(value): DCNL 'Unquotes a header value. DCNL This does not use the real unquoting but what browsers are actually DCNL using for quoting. DCNL :param value: the header value to unquote.'
def parse_list_header(value): DCNL 'Parse lists as described by RFC 2068 Section 2. DCNL In particular, parse comma-separated lists where the elements of DCNL the list may include quoted-strings.  A quoted-string could DCNL contain a comma.  A non-quoted string could have quotes in the DCNL middle.  Quotes are removed automatically after parsing. DCNL The return value is a standard :class:`list`: DCNL >>> parse_list_header(\'token, "quoted value"\') DCNL [\'token\', \'quoted value\'] DCNL :param value: a string with a list header. DCNL :return: :class:`list`'
def parse_options_header(value): DCNL 'Parse a ``Content-Type`` like header into a tuple with the content DCNL type and the options: DCNL >>> parse_options_header(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the header to parse. DCNL :return: (str, options)'
def _list_hosts(req, service=None): DCNL 'Returns a summary list of hosts.'
def check_host(fn): DCNL 'Makes sure that the host exists.'
def register_models(): DCNL 'Register Models and create metadata. DCNL Called from monitor.db.sqlalchemy.__init__ as part of loading the driver, DCNL it will never need to be called explicitly elsewhere unless the DCNL connection is lost and needs to be reestablished.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def is_admin_context(context): DCNL 'Indicates if the request context is an administrator.'
def is_user_context(context): DCNL 'Indicates if the request context is a normal user.'
def authorize_project_context(context, project_id): DCNL 'Ensures a request has permission to access the given project.'
def authorize_user_context(context, user_id): DCNL 'Ensures a request has permission to access the given user.'
def authorize_quota_class_context(context, class_name): DCNL 'Ensures a request has permission to access the given quota class.'
def require_admin_context(f): DCNL 'Decorator to require admin request context. DCNL The first argument to the wrapped function must be the context.'
def require_context(f): DCNL 'Decorator to require *any* user or admin context. DCNL This does no authorization for user or project access matching, see DCNL :py:func:`authorize_project_context` and DCNL :py:func:`authorize_user_context`. DCNL The first argument to the wrapped function must be the context.'
def model_query(context, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id.'
def exact_filter(query, model, filters, legal_keys): DCNL 'Applies exact match filtering to a query. DCNL Returns the updated query.  Modifies filters argument to remove DCNL filters consumed. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to, for IN-style DCNL filtering DCNL :param filters: dictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performed, while exact matching (\'==\' operator) DCNL is used for other values DCNL :param legal_keys: list of keys to apply exact filtering to'
def _get_host_utilization(context, host, ram_mb, disk_gb): DCNL 'Compute the current utilization of a given host.'
@require_admin_context DCNL def compute_node_create(context, values, session=None): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
@require_admin_context DCNL def compute_node_update(context, compute_id, values, auto_adjust): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
def compute_node_get_by_host(context, host): DCNL 'Get all capacity entries for the given host.'
def compute_node_utilization_update(context, host, free_ram_mb_delta=0, free_disk_gb_delta=0, work_delta=0, vm_delta=0): DCNL 'Update a specific ComputeNode entry by a series of deltas. DCNL Do this as a single atomic action and lock the row for the DCNL duration of the operation. Requires that ComputeNode record exist.'
def compute_node_utilization_set(context, host, free_ram_mb=None, free_disk_gb=None, work=None, vms=None): DCNL 'Like compute_node_utilization_update() modify a specific host DCNL entry. But this function will set the metrics absolutely DCNL (vs. a delta update).'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def service_destroy(context, service_id): DCNL 'Destroy the service or raise if it does not exist.'
def service_get(context, service_id): DCNL 'Get a service or raise if it does not exist.'
def service_get_by_host_and_topic(context, host, topic): DCNL 'Get a service by host it\'s on and topic it listens to.'
def service_get_all(context, disabled=None): DCNL 'Get all services.'
def service_get_all_by_topic(context, topic): DCNL 'Get all services for a given topic.'
def service_get_all_by_host(context, host): DCNL 'Get all services for a given host.'
def service_get_all_bmc_by_host(context, host): DCNL 'Get all compute services for a given host.'
def service_get_all_servicemanage_sorted(context): DCNL 'Get all servicemanage services sorted by servicemanage count. DCNL :returns: a list of (Service, servicemanage_count) tuples.'
def service_get_by_args(context, host, binary): DCNL 'Get the state of an service by node name and binary.'
def service_create(context, values): DCNL 'Create a service from the values dictionary.'
def service_update(context, service_id, values): DCNL 'Set the given properties on an service and update it. DCNL Raises NotFound if service does not exist.'
def compute_node_get(context, compute_id): DCNL 'Get an computeNode or raise if it does not exist.'
def compute_node_get_all(context): DCNL 'Get all computeNodes.'
def compute_node_create(context, values): DCNL 'Create a computeNode from the values dictionary.'
def compute_node_update(context, compute_id, values, auto_adjust=True): DCNL 'Set the given properties on an computeNode and update it. DCNL Raises NotFound if computeNode does not exist.'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def find_config(config_path): DCNL 'Find a configuration file using the given hint. DCNL :param config_path: Full or relative path to the config. DCNL :returns: Full path of the config, if it exists. DCNL :raises: `monitor.exception.ConfigNotFound`'
def execute(*cmd, **kwargs): DCNL 'Helper method to execute command with optional retry. DCNL If you add a run_as_root=True command, don\'t forget to add the DCNL corresponding filter to etc/monitor/rootwrap.d ! DCNL :param cmd:                Passed to subprocess.Popen. DCNL :param process_input:      Send to opened process. DCNL :param check_exit_code:    Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these code. DCNL :param delay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmd. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper FLAG. DCNL :raises exception.Error: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stdout, stderr) from the spawned process, or None if DCNL the command fails.'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def last_completed_audit_period(unit=None): DCNL 'This method gives you the most recently *completed* audit period. DCNL arguments: DCNL units: string, one of \'hour\', \'day\', \'month\', \'year\' DCNL Periods normally begin at the beginning (UTC) of the DCNL period unit (So a \'day\' period begins at midnight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appended with an optional offset DCNL like so:  \'day@18\'  This will begin the period at 18:00 DCNL UTC.  \'month@15\' starts a monthly period on the 15th, DCNL and year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of datetimes (begin, end) DCNL The begin timestamp of this audit period is the same as the DCNL end of the previous.'
def generate_password(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL 'Generate a random password from the supplied symbol groups. DCNL At least one symbol from each group will be included. Unpredictable DCNL results if length is less than the number of symbol groups. DCNL Believed to be reasonably secure (with a reasonable password length!)'
def safe_minidom_parse_string(xml_string): DCNL 'Parse an XML string using minidom safely.'
def xhtml_escape(value): DCNL 'Escapes a string so it is valid within XML or XHTML.'
def utf8(value): DCNL 'Try to turn a string into utf-8 if possible. DCNL Code is directly from the utf8 function in DCNL http://github.com/facebook/tornado/blob/master/tornado/escape.py'
def delete_if_exists(pathname): DCNL 'delete a file, but ignore file not found error'
def get_from_path(items, path): DCNL 'Returns a list of items matching the specified path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, and for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermediate results are lists it will treat each list item individually. DCNL A \'None\' in items or any child expressions will be ignored, this function DCNL will not throw because of None (anywhere) in items.  The returned list DCNL will contain no None values.'
def flatten_dict(dict_, flattened=None): DCNL 'Recursively flatten a nested dictionary.'
def partition_dict(dict_, keys): DCNL 'Return two dicts, one with `keys` the other with everything else.'
def map_dict_keys(dict_, key_map): DCNL 'Return a dict in which the dictionaries keys are mapped to new keys.'
def subset_dict(dict_, keys): DCNL 'Return a dict that only contains a subset of keys.'
def check_isinstance(obj, cls): DCNL 'Checks that obj is of type cls, and lets PyLint infer types.'
def bool_from_str(val): DCNL 'Convert a string representation of a bool into a bool value'
def is_valid_boolstr(val): DCNL 'Check if the provided string is a valid bool string or not.'
def is_valid_ipv4(address): DCNL 'valid the address strictly as per format xxx.xxx.xxx.xxx. DCNL where xxx is a value between 0 and 255.'
def monkey_patch(): DCNL 'If the Flags.monkey_patch set as True, DCNL this function patches a decorator DCNL for all functions in specified modules. DCNL You can set decorators for each modules DCNL using FLAGS.monkey_patch_modules. DCNL The format is "Module path:Decorator function". DCNL Example: \'monitor.api.ec2.cloud:\'      monitor.openstack.common.notifier.api.notify_decorator\' DCNL Parameters of the decorator is as follows. DCNL (See monitor.openstack.common.notifier.api.notify_decorator) DCNL name - name of the function DCNL function - object of the function'
def convert_to_list_dict(lst, label): DCNL 'Convert a value or list into a list of dicts'
def timefunc(func): DCNL 'Decorator that logs how long a particular function took to execute'
def generate_glance_url(): DCNL 'Generate the URL to glance.'
@contextlib.contextmanager DCNL def logging_error(message): DCNL 'Catches exception, write message to the log, re-raise. DCNL This is a common refinement of save_and_reraise that writes a specific DCNL message to the log.'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed.'
def make_dev_path(dev, partition=None, base='/dev'): DCNL 'Return a path to a particular device. DCNL >>> make_dev_path(\'xvdc\') DCNL /dev/xvdc DCNL >>> make_dev_path(\'xvdc\', 1) DCNL /dev/xvdc1'
def total_seconds(td): DCNL 'Local total_seconds implementation for compatibility with python 2.6'
def sanitize_hostname(hostname): DCNL 'Return a hostname which conforms to RFC-952 and RFC-1123 specs.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def hash_file(file_like_object): DCNL 'Generate a hash for the contents of a file.'
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL 'Temporarily set the attr on a particular object to a given value then DCNL revert when finished. DCNL One use of this is to temporarily set the read_deleted flag on a context DCNL object: DCNL with temporary_mutation(context, read_deleted="yes"): DCNL do_something_that_needed_deleted_objects()'
def service_is_up(service): DCNL 'Check whether a service is up based on last heartbeat.'
def generate_mac_address(): DCNL 'Generate an Ethernet MAC address.'
def read_file_as_root(file_path): DCNL 'Secure helper to read file as root.'
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL 'Temporarily chown a path. DCNL :params owner_uid: UID of temporary owner (defaults to current user)'
def strcmp_const_time(s1, s2): DCNL 'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.'
def walk_class_hierarchy(clazz, encountered=None): DCNL 'Walk class hierarchy, yielding most derived classes first'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def to_bytes(text, default=0): DCNL 'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to determine what conversion is needed to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the end)'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def enforce(context, action, target): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: monitor context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_servicemanage``, DCNL ``servicemanage:attach_servicemanage`` DCNL :param object: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :raises monitor.exception.PolicyNotAuthorized: if verification fails.'
def check_is_admin(roles): DCNL 'Whether or not roles contains \'admin\' role according to policy setting.'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def setup(product_name): DCNL 'Setup logging.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def set_brain(brain): DCNL 'Set the brain used by enforce(). DCNL Defaults use Brain() if not set.'
def reset(): DCNL 'Clear the brain used by enforce().'
def enforce(match_list, target_dict, credentials_dict, exc=None, *args, **kwargs): DCNL 'Enforces authorization of some rules against credentials. DCNL :param match_list: nested tuples of data to match against DCNL The basic brain supports three types of match lists: DCNL 1) rules DCNL looks like: ``(\'rule:compute:get_instance\',)`` DCNL Retrieves the named rule from the rules dict and recursively DCNL checks against the contents of the rule. DCNL 2) roles DCNL looks like: ``(\'role:compute:admin\',)`` DCNL Matches if the specified role is in credentials_dict[\'roles\']. DCNL 3) generic DCNL looks like: ``(\'tenant_id:%(tenant_id)s\',)`` DCNL Substitutes values from the target dict into the match using DCNL the % operator and matches them against the creds dict. DCNL Combining rules: DCNL The brain returns True if any of the outer tuple of rules DCNL match and also True if all of the inner tuples match. You DCNL can use this to perform simple boolean logic.  For DCNL example, the following rule would return True if the creds DCNL contain the role \'admin\' OR the if the tenant_id matches DCNL the target dict AND the the creds contains the role DCNL \'compute_sysadmin\': DCNL "rule:combined": ( DCNL \'role:admin\', DCNL (\'tenant_id:%(tenant_id)s\', \'role:compute_sysadmin\') DCNL Note that rule and role are reserved words in the credentials match, so DCNL you can\'t match against properties with those names. Custom brains may DCNL also add new reserved words. For example, the HttpBrain adds http as a DCNL reserved word. DCNL :param target_dict: dict of object properties DCNL Target dicts contain as much information as we can about the object being DCNL operated on. DCNL :param credentials_dict: dict of actor properties DCNL Credentials dicts contain as much information as we can about the user DCNL performing the action. DCNL :param exc: exception to raise DCNL Class of the exception to raise if the check fails.  Any remaining DCNL arguments passed to enforce() (both positional and keyword arguments) DCNL will be passed to the exception class.  If exc is not provided, returns DCNL False. DCNL :return: True if the policy allows the action DCNL :return: False if the policy does not allow the action and exc is not set'
def register(name, func=None): DCNL 'Register a function as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default function DCNL will be registered. DCNL :param func: If given, provides the function to register.  If not DCNL given, returns a function taking one argument to DCNL specify the function to register, allowing use as a DCNL decorator.'
@register('rule') DCNL def _check_rule(brain, match_kind, match, target_dict, cred_dict): DCNL 'Recursively checks credentials based on the brains rules.'
@register('role') DCNL def _check_role(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check that there is a matching role in the cred dict.'
@register('http') DCNL def _check_http(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response is DCNL exactly \'True\'. A custom brain using response codes could easily DCNL be implemented.'
@register(None) DCNL def _check_generic(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filters, userargs, exec_dirs=[]): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter. DCNL Raises NoFilterMatched if no filter matched. DCNL Raises FilterMatchNotExecutable if no executable was found for the DCNL best filter match.'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every tick DCNL of the periodic publisher. DCNL 2. With arguments, @periodic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic publisher.'
def short_cycle_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@short_cycle_task \', this will be run on every tick DCNL of the periodic publisher. DCNL 2. With arguments, @short_cycle_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic publisher.'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'A paste pipeline replica that keys off of auth_strategy.'
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL 'Registers all standard API extensions.'
def get_pagination_params(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specified, 0, or DCNL > max_limit, we default to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBadRequest() exceptions to be raised.'
def _get_limit_param(request): DCNL 'Extract integer limit from request or fail'
def _get_marker_param(request): DCNL 'Extract marker id from request or fail'
def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to requested offset and limit. DCNL :param items: A sliceable entity DCNL :param request: ``wsgi.Request`` possibly containing \'offset\' and \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL and \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specified, 0, or > max_limit, we default DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBadRequest() exceptions to be raised. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''
def limited_by_marker(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to the requested marker and limit.'
def remove_version_from_href(href): DCNL 'Removes the first api version from the href. DCNL Given: \'http://www.monitor.com/v1.1/123\' DCNL Returns: \'http://www.monitor.com/123\' DCNL Given: \'http://www.monitor.com/v1.1\' DCNL Returns: \'http://www.monitor.com\''
def get_items(obj): DCNL 'Get items in obj.'
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Create a template element as a child of another. DCNL Corresponds to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the addition of the parent.'
def make_links(parent, selector=None): DCNL 'Attach an Atom <links> element to the parent.'
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL 'Utility for simple XML templates that traditionally used DCNL XMLDictSerializer with no metadata.  Returns a template element DCNL where the top-level element has the given tag name, and where DCNL sub-elements have tag names derived from the object\'s keys and DCNL text derived from the object\'s values.  This only works for flat DCNL dictionary objects, not dictionaries containing nested lists or DCNL dictionaries.'
def serializers(**serializers): DCNL 'Attaches serializers to a method. DCNL This decorator associates a dictionary of serializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def deserializers(**deserializers): DCNL 'Attaches deserializers to a method. DCNL This decorator associates a dictionary of deserializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def response(code): DCNL 'Attaches response code to a method. DCNL This decorator associates a response code with a method.  Note DCNL that the function attributes are directly manipulated; the method DCNL is not wrapped.'
def action_peek_json(body): DCNL 'Determine action to invoke.'
def action_peek_xml(body): DCNL 'Determine action to invoke.'
def action(name): DCNL 'Mark a function as an action. DCNL The given name will be taken as the action key in the body. DCNL This is also overloaded to allow extensions to provide DCNL non-extending definitions of create and delete operations.'
def extends(*args, **kwargs): DCNL 'Indicate a function extends an operation. DCNL Can be used as either:: DCNL @extends DCNL def index(...): DCNL pass DCNL or as:: DCNL @extends(action=\'resize\') DCNL def _action_resize(...): DCNL pass'
def _translate_attachment_detail_view(_context, vol): DCNL 'Maps keys for attachment details view.'
def _translate_attachment_summary_view(_context, vol): DCNL 'Maps keys for attachment summary view.'
def _translate_conductor_detail_view(context, vol, image_id=None): DCNL 'Maps keys for conductors details view.'
def _translate_conductor_summary_view(context, vol, image_id=None): DCNL 'Maps keys for conductors summary view.'
def remove_invalid_options(context, search_options, allowed_search_options): DCNL 'Remove search options that are not valid for non-admin API/context.'
def unquote_header_value(value): DCNL 'Unquotes a header value. DCNL This does not use the real unquoting but what browsers are actually DCNL using for quoting. DCNL :param value: the header value to unquote.'
def parse_list_header(value): DCNL 'Parse lists as described by RFC 2068 Section 2. DCNL In particular, parse comma-separated lists where the elements of DCNL the list may include quoted-strings.  A quoted-string could DCNL contain a comma.  A non-quoted string could have quotes in the DCNL middle.  Quotes are removed automatically after parsing. DCNL The return value is a standard :class:`list`: DCNL >>> parse_list_header(\'token, "quoted value"\') DCNL [\'token\', \'quoted value\'] DCNL :param value: a string with a list header. DCNL :return: :class:`list`'
def parse_options_header(value): DCNL 'Parse a ``Content-Type`` like header into a tuple with the content DCNL type and the options: DCNL >>> parse_options_header(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the header to parse. DCNL :return: (str, options)'
def _list_hosts(req, service=None): DCNL 'Returns a summary list of hosts.'
def check_host(fn): DCNL 'Makes sure that the host exists.'
def register_models(): DCNL 'Register Models and create metadata. DCNL Called from monitor.db.sqlalchemy.__init__ as part of loading the driver, DCNL it will never need to be called explicitly elsewhere unless the DCNL connection is lost and needs to be reestablished.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def is_admin_context(context): DCNL 'Indicates if the request context is an administrator.'
def is_user_context(context): DCNL 'Indicates if the request context is a normal user.'
def authorize_project_context(context, project_id): DCNL 'Ensures a request has permission to access the given project.'
def authorize_user_context(context, user_id): DCNL 'Ensures a request has permission to access the given user.'
def authorize_quota_class_context(context, class_name): DCNL 'Ensures a request has permission to access the given quota class.'
def require_admin_context(f): DCNL 'Decorator to require admin request context. DCNL The first argument to the wrapped function must be the context.'
def require_context(f): DCNL 'Decorator to require *any* user or admin context. DCNL This does no authorization for user or project access matching, see DCNL :py:func:`authorize_project_context` and DCNL :py:func:`authorize_user_context`. DCNL The first argument to the wrapped function must be the context.'
def model_query(context, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id.'
def exact_filter(query, model, filters, legal_keys): DCNL 'Applies exact match filtering to a query. DCNL Returns the updated query.  Modifies filters argument to remove DCNL filters consumed. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to, for IN-style DCNL filtering DCNL :param filters: dictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performed, while exact matching (\'==\' operator) DCNL is used for other values DCNL :param legal_keys: list of keys to apply exact filtering to'
def _get_host_utilization(context, host, ram_mb, disk_gb): DCNL 'Compute the current utilization of a given host.'
@require_admin_context DCNL def compute_node_create(context, values, session=None): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
@require_admin_context DCNL def compute_node_update(context, compute_id, values, auto_adjust): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
def compute_node_get_by_host(context, host): DCNL 'Get all capacity entries for the given host.'
def compute_node_utilization_update(context, host, free_ram_mb_delta=0, free_disk_gb_delta=0, work_delta=0, vm_delta=0): DCNL 'Update a specific ComputeNode entry by a series of deltas. DCNL Do this as a single atomic action and lock the row for the DCNL duration of the operation. Requires that ComputeNode record exist.'
def compute_node_utilization_set(context, host, free_ram_mb=None, free_disk_gb=None, work=None, vms=None): DCNL 'Like compute_node_utilization_update() modify a specific host DCNL entry. But this function will set the metrics absolutely DCNL (vs. a delta update).'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def service_destroy(context, service_id): DCNL 'Destroy the service or raise if it does not exist.'
def service_get(context, service_id): DCNL 'Get a service or raise if it does not exist.'
def service_get_by_host_and_topic(context, host, topic): DCNL 'Get a service by host it\'s on and topic it listens to.'
def service_get_all(context, disabled=None): DCNL 'Get all services.'
def service_get_all_by_topic(context, topic): DCNL 'Get all services for a given topic.'
def service_get_all_by_host(context, host): DCNL 'Get all services for a given host.'
def service_get_all_bmc_by_host(context, host): DCNL 'Get all compute services for a given host.'
def service_get_all_servicemanage_sorted(context): DCNL 'Get all servicemanage services sorted by servicemanage count. DCNL :returns: a list of (Service, servicemanage_count) tuples.'
def service_get_by_args(context, host, binary): DCNL 'Get the state of an service by node name and binary.'
def service_create(context, values): DCNL 'Create a service from the values dictionary.'
def service_update(context, service_id, values): DCNL 'Set the given properties on an service and update it. DCNL Raises NotFound if service does not exist.'
def compute_node_get(context, compute_id): DCNL 'Get an computeNode or raise if it does not exist.'
def compute_node_get_all(context): DCNL 'Get all computeNodes.'
def compute_node_create(context, values): DCNL 'Create a computeNode from the values dictionary.'
def compute_node_update(context, compute_id, values, auto_adjust=True): DCNL 'Set the given properties on an computeNode and update it. DCNL Raises NotFound if computeNode does not exist.'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def find_config(config_path): DCNL 'Find a configuration file using the given hint. DCNL :param config_path: Full or relative path to the config. DCNL :returns: Full path of the config, if it exists. DCNL :raises: `monitor.exception.ConfigNotFound`'
def execute(*cmd, **kwargs): DCNL 'Helper method to execute command with optional retry. DCNL If you add a run_as_root=True command, don\'t forget to add the DCNL corresponding filter to etc/monitor/rootwrap.d ! DCNL :param cmd:                Passed to subprocess.Popen. DCNL :param process_input:      Send to opened process. DCNL :param check_exit_code:    Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these code. DCNL :param delay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmd. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper FLAG. DCNL :raises exception.Error: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stdout, stderr) from the spawned process, or None if DCNL the command fails.'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def last_completed_audit_period(unit=None): DCNL 'This method gives you the most recently *completed* audit period. DCNL arguments: DCNL units: string, one of \'hour\', \'day\', \'month\', \'year\' DCNL Periods normally begin at the beginning (UTC) of the DCNL period unit (So a \'day\' period begins at midnight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appended with an optional offset DCNL like so:  \'day@18\'  This will begin the period at 18:00 DCNL UTC.  \'month@15\' starts a monthly period on the 15th, DCNL and year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of datetimes (begin, end) DCNL The begin timestamp of this audit period is the same as the DCNL end of the previous.'
def generate_password(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL 'Generate a random password from the supplied symbol groups. DCNL At least one symbol from each group will be included. Unpredictable DCNL results if length is less than the number of symbol groups. DCNL Believed to be reasonably secure (with a reasonable password length!)'
def safe_minidom_parse_string(xml_string): DCNL 'Parse an XML string using minidom safely.'
def xhtml_escape(value): DCNL 'Escapes a string so it is valid within XML or XHTML.'
def utf8(value): DCNL 'Try to turn a string into utf-8 if possible. DCNL Code is directly from the utf8 function in DCNL http://github.com/facebook/tornado/blob/master/tornado/escape.py'
def delete_if_exists(pathname): DCNL 'delete a file, but ignore file not found error'
def get_from_path(items, path): DCNL 'Returns a list of items matching the specified path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, and for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermediate results are lists it will treat each list item individually. DCNL A \'None\' in items or any child expressions will be ignored, this function DCNL will not throw because of None (anywhere) in items.  The returned list DCNL will contain no None values.'
def flatten_dict(dict_, flattened=None): DCNL 'Recursively flatten a nested dictionary.'
def partition_dict(dict_, keys): DCNL 'Return two dicts, one with `keys` the other with everything else.'
def map_dict_keys(dict_, key_map): DCNL 'Return a dict in which the dictionaries keys are mapped to new keys.'
def subset_dict(dict_, keys): DCNL 'Return a dict that only contains a subset of keys.'
def check_isinstance(obj, cls): DCNL 'Checks that obj is of type cls, and lets PyLint infer types.'
def bool_from_str(val): DCNL 'Convert a string representation of a bool into a bool value'
def is_valid_boolstr(val): DCNL 'Check if the provided string is a valid bool string or not.'
def is_valid_ipv4(address): DCNL 'valid the address strictly as per format xxx.xxx.xxx.xxx. DCNL where xxx is a value between 0 and 255.'
def monkey_patch(): DCNL 'If the Flags.monkey_patch set as True, DCNL this function patches a decorator DCNL for all functions in specified modules. DCNL You can set decorators for each modules DCNL using FLAGS.monkey_patch_modules. DCNL The format is "Module path:Decorator function". DCNL Example: \'monitor.api.ec2.cloud:\'      monitor.openstack.common.notifier.api.notify_decorator\' DCNL Parameters of the decorator is as follows. DCNL (See monitor.openstack.common.notifier.api.notify_decorator) DCNL name - name of the function DCNL function - object of the function'
def convert_to_list_dict(lst, label): DCNL 'Convert a value or list into a list of dicts'
def timefunc(func): DCNL 'Decorator that logs how long a particular function took to execute'
def generate_glance_url(): DCNL 'Generate the URL to glance.'
@contextlib.contextmanager DCNL def logging_error(message): DCNL 'Catches exception, write message to the log, re-raise. DCNL This is a common refinement of save_and_reraise that writes a specific DCNL message to the log.'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed.'
def make_dev_path(dev, partition=None, base='/dev'): DCNL 'Return a path to a particular device. DCNL >>> make_dev_path(\'xvdc\') DCNL /dev/xvdc DCNL >>> make_dev_path(\'xvdc\', 1) DCNL /dev/xvdc1'
def total_seconds(td): DCNL 'Local total_seconds implementation for compatibility with python 2.6'
def sanitize_hostname(hostname): DCNL 'Return a hostname which conforms to RFC-952 and RFC-1123 specs.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def hash_file(file_like_object): DCNL 'Generate a hash for the contents of a file.'
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL 'Temporarily set the attr on a particular object to a given value then DCNL revert when finished. DCNL One use of this is to temporarily set the read_deleted flag on a context DCNL object: DCNL with temporary_mutation(context, read_deleted="yes"): DCNL do_something_that_needed_deleted_objects()'
def service_is_up(service): DCNL 'Check whether a service is up based on last heartbeat.'
def generate_mac_address(): DCNL 'Generate an Ethernet MAC address.'
def read_file_as_root(file_path): DCNL 'Secure helper to read file as root.'
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL 'Temporarily chown a path. DCNL :params owner_uid: UID of temporary owner (defaults to current user)'
def strcmp_const_time(s1, s2): DCNL 'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.'
def walk_class_hierarchy(clazz, encountered=None): DCNL 'Walk class hierarchy, yielding most derived classes first'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def to_bytes(text, default=0): DCNL 'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to determine what conversion is needed to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the end)'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def enforce(context, action, target): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: monitor context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_servicemanage``, DCNL ``servicemanage:attach_servicemanage`` DCNL :param object: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :raises monitor.exception.PolicyNotAuthorized: if verification fails.'
def check_is_admin(roles): DCNL 'Whether or not roles contains \'admin\' role according to policy setting.'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def setup(product_name): DCNL 'Setup logging.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def set_brain(brain): DCNL 'Set the brain used by enforce(). DCNL Defaults use Brain() if not set.'
def reset(): DCNL 'Clear the brain used by enforce().'
def enforce(match_list, target_dict, credentials_dict, exc=None, *args, **kwargs): DCNL 'Enforces authorization of some rules against credentials. DCNL :param match_list: nested tuples of data to match against DCNL The basic brain supports three types of match lists: DCNL 1) rules DCNL looks like: ``(\'rule:compute:get_instance\',)`` DCNL Retrieves the named rule from the rules dict and recursively DCNL checks against the contents of the rule. DCNL 2) roles DCNL looks like: ``(\'role:compute:admin\',)`` DCNL Matches if the specified role is in credentials_dict[\'roles\']. DCNL 3) generic DCNL looks like: ``(\'tenant_id:%(tenant_id)s\',)`` DCNL Substitutes values from the target dict into the match using DCNL the % operator and matches them against the creds dict. DCNL Combining rules: DCNL The brain returns True if any of the outer tuple of rules DCNL match and also True if all of the inner tuples match. You DCNL can use this to perform simple boolean logic.  For DCNL example, the following rule would return True if the creds DCNL contain the role \'admin\' OR the if the tenant_id matches DCNL the target dict AND the the creds contains the role DCNL \'compute_sysadmin\': DCNL "rule:combined": ( DCNL \'role:admin\', DCNL (\'tenant_id:%(tenant_id)s\', \'role:compute_sysadmin\') DCNL Note that rule and role are reserved words in the credentials match, so DCNL you can\'t match against properties with those names. Custom brains may DCNL also add new reserved words. For example, the HttpBrain adds http as a DCNL reserved word. DCNL :param target_dict: dict of object properties DCNL Target dicts contain as much information as we can about the object being DCNL operated on. DCNL :param credentials_dict: dict of actor properties DCNL Credentials dicts contain as much information as we can about the user DCNL performing the action. DCNL :param exc: exception to raise DCNL Class of the exception to raise if the check fails.  Any remaining DCNL arguments passed to enforce() (both positional and keyword arguments) DCNL will be passed to the exception class.  If exc is not provided, returns DCNL False. DCNL :return: True if the policy allows the action DCNL :return: False if the policy does not allow the action and exc is not set'
def register(name, func=None): DCNL 'Register a function as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default function DCNL will be registered. DCNL :param func: If given, provides the function to register.  If not DCNL given, returns a function taking one argument to DCNL specify the function to register, allowing use as a DCNL decorator.'
@register('rule') DCNL def _check_rule(brain, match_kind, match, target_dict, cred_dict): DCNL 'Recursively checks credentials based on the brains rules.'
@register('role') DCNL def _check_role(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check that there is a matching role in the cred dict.'
@register('http') DCNL def _check_http(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response is DCNL exactly \'True\'. A custom brain using response codes could easily DCNL be implemented.'
@register(None) DCNL def _check_generic(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filters, userargs, exec_dirs=[]): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter. DCNL Raises NoFilterMatched if no filter matched. DCNL Raises FilterMatchNotExecutable if no executable was found for the DCNL best filter match.'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every tick DCNL of the periodic publisher. DCNL 2. With arguments, @periodic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic publisher.'
def short_cycle_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@short_cycle_task \', this will be run on every tick DCNL of the periodic publisher. DCNL 2. With arguments, @short_cycle_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic publisher.'
