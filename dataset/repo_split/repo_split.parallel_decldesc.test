def test_driver(): DCNL 'Assert that the TPOT driver outputs normal result in mode mode.'
def test_read_data_file(): DCNL 'Assert that _read_data_file raises ValueError when the targe column is missing.'
def test_init_custom_parameters(): DCNL 'Assert that the TPOT instantiator stores the TPOT variables properly.'
def test_init_default_scoring(): DCNL 'Assert that TPOT intitializes with the correct default scoring function.'
def test_init_default_scoring_2(): DCNL 'Assert that TPOT intitializes with the correct customized scoring function.'
def test_invaild_score_warning(): DCNL 'Assert that the TPOT intitializes raises a ValueError when the scoring metrics is not available in SCORERS.'
def test_invaild_dataset_warning(): DCNL 'Assert that the TPOT fit function raises a ValueError when dataset is not in right format.'
def test_invaild_subsample_ratio_warning(): DCNL 'Assert that the TPOT intitializes raises a ValueError when subsample ratio is not in the range (0.0, 1.0].'
def test_invaild_mut_rate_plus_xo_rate(): DCNL 'Assert that the TPOT intitializes raises a ValueError when the sum of crossover and mutation probabilities is large than 1.'
def test_init_max_time_mins(): DCNL 'Assert that the TPOT init stores max run time and sets generations to 1000000.'
def test_init_n_jobs(): DCNL 'Assert that the TPOT init stores current number of processes'
def test_timeout(): DCNL 'Assert that _wrapped_cross_val_score return Timeout in a time limit'
def test_balanced_accuracy(): DCNL 'Assert that the balanced_accuracy in TPOT returns correct accuracy.'
def test_get_params(): DCNL 'Assert that get_params returns the exact dictionary of parameters used by TPOT.'
def test_set_params(): DCNL 'Assert that set_params returns a reference to the TPOT instance.'
def test_set_params_2(): DCNL 'Assert that set_params updates TPOT\'s instance variables.'
def test_TPOTBase(): DCNL 'Assert that TPOTBase class raises RuntimeError when using it directly.'
def test_conf_dict(): DCNL 'Assert that TPOT uses the pre-configured dictionary of operators when config_dict is \'TPOT light\' or \'TPOT MDR\'.'
def test_conf_dict_2(): DCNL 'Assert that TPOT uses a custom dictionary of operators when config_dict is Python dictionary.'
def test_conf_dict_3(): DCNL 'Assert that TPOT uses a custom dictionary of operators when config_dict is the path of Python dictionary.'
def test_random_ind(): DCNL 'Assert that the TPOTClassifier can generate the same pipeline with same random seed.'
def test_random_ind_2(): DCNL 'Assert that the TPOTClassifier can generate the same pipeline export with random seed of 39.'
def test_score(): DCNL 'Assert that the TPOT score function raises a RuntimeError when no optimized pipeline exists.'
def test_score_2(): DCNL 'Assert that the TPOTClassifier score function outputs a known score for a fixed pipeline.'
def test_score_3(): DCNL 'Assert that the TPOTRegressor score function outputs a known score for a fixed pipeline.'
def test_sample_weight_func(): DCNL 'Assert that the TPOTRegressor score function outputs a known score for a fixed pipeline with sample weights.'
def test_fit_GroupKFold(): DCNL 'Assert that TPOT properly handles the group parameter when using GroupKFold'
def test_predict(): DCNL 'Assert that the TPOT predict function raises a RuntimeError when no optimized pipeline exists.'
def test_predict_2(): DCNL 'Assert that the TPOT predict function returns a numpy matrix of shape (num_testing_rows,).'
def test_predict_proba(): DCNL 'Assert that the TPOT predict_proba function returns a numpy matrix of shape (num_testing_rows, num_testing_target).'
def test_predict_proba2(): DCNL 'Assert that the TPOT predict_proba function returns a numpy matrix filled with probabilities (float).'
def test_warm_start(): DCNL 'Assert that the TPOT warm_start flag stores the pop and pareto_front from the first run.'
def test_fit(): DCNL 'Assert that the TPOT fit function provides an optimized pipeline.'
def test_fit2(): DCNL 'Assert that the TPOT fit function provides an optimized pipeline when config_dict is \'TPOT light\'.'
def test_fit3(): DCNL 'Assert that the TPOT fit function provides an optimized pipeline with subsample is 0.8'
def test_evaluated_individuals_(): DCNL 'Assert that evaluated_individuals_ stores corrent pipelines and their CV scores.'
def test_evaluate_individuals(): DCNL 'Assert that _evaluate_individuals returns operator_counts and CV scores in correct order.'
def test_imputer(): DCNL 'Assert that the TPOT fit function will not raise a ValueError in a dataset where NaNs are present.'
def test_imputer2(): DCNL 'Assert that the TPOT predict function will not raise a ValueError in a dataset where NaNs are present.'
def test_imputer3(): DCNL 'Assert that the TPOT _impute_values function returns a feature matrix with imputed NaN values.'
def test_tpot_operator_factory_class(): DCNL 'Assert that the TPOT operators class factory.'
def check_export(op, tpot_obj): DCNL 'Assert that a TPOT operator exports as expected.'
def test_operators(): DCNL 'Assert that the TPOT operators match the output of their sklearn counterparts.'
def test_export(): DCNL 'Assert that TPOT\'s export function throws a RuntimeError when no optimized pipeline exists.'
def test_generate_pipeline_code(): DCNL 'Assert that generate_pipeline_code() returns the correct code given a specific pipeline.'
def test_generate_import_code(): DCNL 'Assert that generate_import_code() returns the correct set of dependancies for a given pipeline.'
def test_generate_import_code_2(): DCNL 'Assert that generate_import_code() returns the correct set of dependancies and dependancies are importable.'
def test_PolynomialFeatures_exception(): DCNL 'Assert that TPOT allows only one PolynomialFeatures operator in a pipeline'
def test_mutNodeReplacement(): DCNL 'Assert that mutNodeReplacement() returns the correct type of mutation node in a fixed pipeline.'
def test_export_pipeline(): DCNL 'Assert that exported_pipeline() generated a compile source file as expected given a fixed pipeline.'
def test_export_pipeline_2(): DCNL 'Assert that exported_pipeline() generated a compile source file as expected given a fixed simple pipeline (only one classifier).'
def test_export_pipeline_3(): DCNL 'Assert that exported_pipeline() generated a compile source file as expected given a fixed simple pipeline with a preprocessor.'
def test_export_pipeline_4(): DCNL 'Assert that exported_pipeline() generated a compile source file as expected given a fixed simple pipeline with input_matrix in CombineDFs.'
def test_operator_export(): DCNL 'Assert that a TPOT operator can export properly with a function as a parameter to a classifier.'
def test_indent(): DCNL 'Assert that indenting a multiline string by 4 spaces prepends 4 spaces before each new line.'
def test_operator_type(): DCNL 'Assert that TPOT operators return their type, e.g. \'Classifier\', \'Preprocessor\'.'
def test_get_by_name(): DCNL 'Assert that the Operator class returns operators by name appropriately.'
def test_gen(): DCNL 'Assert that TPOT\'s gen_grow_safe function returns a pipeline of expected structure.'
def test_positive_integer(): DCNL 'Assert that the TPOT CLI interface\'s integer parsing throws an exception when n < 0.'
def test_positive_integer_2(): DCNL 'Assert that the TPOT CLI interface\'s integer parsing returns the integer value of a string encoded integer when n > 0.'
def test_positive_integer_3(): DCNL 'Assert that the TPOT CLI interface\'s integer parsing throws an exception when n is not an integer.'
def test_float_range(): DCNL 'Assert that the TPOT CLI interface\'s float range returns a float with input is in 0. - 1.0.'
def test_float_range_2(): DCNL 'Assert that the TPOT CLI interface\'s float range throws an exception when input it out of range.'
def test_float_range_3(): DCNL 'Assert that the TPOT CLI interface\'s float range throws an exception when input is not a float.'
def test_StackingEstimator_1(): DCNL 'Assert that the StackingEstimator returns transformed X with synthetic features in classification.'
def test_StackingEstimator_2(): DCNL 'Assert that the StackingEstimator returns transformed X with a synthetic feature in regression.'
def test_StackingEstimator_3(): DCNL 'Assert that the StackingEstimator worked as expected in scikit-learn pipeline in classification'
def test_StackingEstimator_4(): DCNL 'Assert that the StackingEstimator worked as expected in scikit-learn pipeline in regression'
def test_ZeroCount(): DCNL 'Assert that ZeroCount operator returns correct transformed X'
def positive_integer(value): DCNL 'Ensure that the provided value is a positive integer. DCNL Parameters DCNL value: int DCNL The number to evaluate DCNL Returns DCNL value: int DCNL Returns a positive integer'
def float_range(value): DCNL 'Ensure that the provided value is a float integer in the range [0., 1.]. DCNL Parameters DCNL value: float DCNL The number to evaluate DCNL Returns DCNL value: float DCNL Returns a float in the range (0., 1.)'
def _get_arg_parser(): DCNL 'Main function that is called when TPOT is run on the command line.'
def main(): DCNL 'Perform a TPOT run.'
def source_decode(sourcecode): DCNL 'Decode operator source and import operator class. DCNL Parameters DCNL sourcecode: string DCNL a string of operator source (e.g \'sklearn.feature_selection.RFE\') DCNL Returns DCNL import_str: string DCNL a string of operator class source (e.g. \'sklearn.feature_selection\') DCNL op_str: string DCNL a string of operator class (e.g. \'RFE\') DCNL op_obj: object DCNL operator class (e.g. RFE)'
def set_sample_weight(pipeline_steps, sample_weight=None): DCNL 'Recursively iterates through all objects in the pipeline and sets sample weight. DCNL Parameters DCNL pipeline_steps: array-like DCNL List of (str, obj) tuples from a scikit-learn pipeline or related object DCNL sample_weight: array-like DCNL List of sample weight DCNL Returns DCNL sample_weight_dict: DCNL A dictionary of sample_weight'
def ARGTypeClassFactory(classname, prange, BaseClass=ARGType): DCNL 'Dynamically create parameter type class.'
def TPOTOperatorClassFactory(opsourse, opdict, BaseClass=Operator, ArgBaseClass=ARGType): DCNL 'Dynamically create operator class. DCNL Parameters DCNL opsourse: string DCNL operator source in config dictionary (key) DCNL opdict: dictionary DCNL operator params in config dictionary (value) DCNL regression: bool DCNL True if it can be used in TPOTRegressor DCNL classification: bool DCNL True if it can be used in TPOTClassifier DCNL BaseClass: Class DCNL inherited BaseClass DCNL Returns DCNL op_class: Class DCNL a new class for a operator DCNL arg_types: list DCNL a list of parameter class'
def balanced_accuracy(y_true, y_pred): DCNL 'Default scoring function: balanced accuracy. DCNL Balanced accuracy computes each class\' accuracy on a per-class basis using a DCNL one-vs-rest encoding, then computes an unweighted average of the class accuracies. DCNL Parameters DCNL y_true: numpy.ndarray {n_samples} DCNL True class labels DCNL y_pred: numpy.ndarray {n_samples} DCNL Predicted class labels by the estimator DCNL Returns DCNL fitness: float DCNL Returns a float value indicating the individual\'s balanced accuracy DCNL 0.5 is as good as chance, and 1.0 is perfect predictive accuracy'
def get_by_name(opname, operators): DCNL 'Return operator class instance by name. DCNL Parameters DCNL opname: str DCNL Name of the sklearn class that belongs to a TPOT operator DCNL operators: list DCNL List of operator classes from operator library DCNL Returns DCNL ret_op_class: class DCNL An operator class'
def export_pipeline(exported_pipeline, operators, pset): DCNL 'Generate source code for a TPOT Pipeline. DCNL Parameters DCNL exported_pipeline: deap.creator.Individual DCNL The pipeline that is being exported DCNL operators: DCNL List of operator classes from operator library DCNL Returns DCNL pipeline_text: str DCNL The source code representing the pipeline'
def expr_to_tree(ind, pset): DCNL 'Convert the unstructured DEAP pipeline into a tree data-structure. DCNL Parameters DCNL ind: deap.creator.Individual DCNL The pipeline that is being exported DCNL Returns DCNL pipeline_tree: list DCNL List of operators in the current optimized pipeline DCNL EXAMPLE: DCNL pipeline: DCNL "DecisionTreeClassifier(input_matrix, 28.0)" DCNL pipeline_tree: DCNL [\'DecisionTreeClassifier\', \'input_matrix\', 28.0]'
def generate_import_code(pipeline, operators): DCNL 'Generate all library import calls for use in TPOT.export(). DCNL Parameters DCNL pipeline: List DCNL List of operators in the current optimized pipeline DCNL operators: DCNL List of operator class from operator library DCNL Returns DCNL pipeline_text: String DCNL The Python code that imports all required library used in the current DCNL optimized pipeline'
def pipeline_code_wrapper(pipeline_code): DCNL 'Generate code specific to the execution of the sklearn pipeline. DCNL Parameters DCNL pipeline_code: str DCNL Code that defines the final sklearn pipeline DCNL Returns DCNL Source code for the sklearn pipeline and calls to fit and predict'
def generate_pipeline_code(pipeline_tree, operators): DCNL 'Generate code specific to the construction of the sklearn Pipeline. DCNL Parameters DCNL pipeline_tree: list DCNL List of operators in the current optimized pipeline DCNL Returns DCNL Source code for the sklearn pipeline'
def generate_export_pipeline_code(pipeline_tree, operators): DCNL 'Generate code specific to the construction of the sklearn Pipeline for export_pipeline. DCNL Parameters DCNL pipeline_tree: list DCNL List of operators in the current optimized pipeline DCNL Returns DCNL Source code for the sklearn pipeline'
def _indent(text, amount): DCNL 'Indent a multiline string by some number of spaces. DCNL Parameters DCNL text: str DCNL The text to be indented DCNL amount: int DCNL The number of spaces to indent the text DCNL Returns DCNL indented_text'
def _pre_test(func): DCNL 'Check if the wrapped function works with a pretest data set. DCNL Reruns the wrapped function until it generates a good pipeline, for a max of DCNL NUM_TESTS times. DCNL Parameters DCNL func: function DCNL The decorated function. DCNL Returns DCNL check_pipeline: function DCNL A wrapper function around the func parameter'
def varOr(population, toolbox, lambda_, cxpb, mutpb): DCNL 'Part of an evolutionary algorithm applying only the variation part DCNL (crossover, mutation **or** reproduction). The modified individuals have DCNL their fitness invalidated. The individuals are cloned so returned DCNL population is independent of the input population. DCNL :param population: A list of individuals to vary. DCNL :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution DCNL operators. DCNL :param lambda\_: The number of children to produce DCNL :param cxpb: The probability of mating two individuals. DCNL :param mutpb: The probability of mutating an individual. DCNL :returns: The final population DCNL :returns: A class:`~deap.tools.Logbook` with the statistics of the DCNL evolution DCNL The variation goes as follow. On each of the *lambda_* iteration, it DCNL selects one of the three operations; crossover, mutation or reproduction. DCNL In the case of a crossover, two individuals are selected at random from DCNL the parental population :math:`P_\mathrm{p}`, those individuals are cloned DCNL using the :meth:`toolbox.clone` method and then mated using the DCNL :meth:`toolbox.mate` method. Only the first child is appended to the DCNL offspring population :math:`P_\mathrm{o}`, the second child is discarded. DCNL In the case of a mutation, one individual is selected at random from DCNL :math:`P_\mathrm{p}`, it is cloned and then mutated using using the DCNL :meth:`toolbox.mutate` method. The resulting mutant is appended to DCNL :math:`P_\mathrm{o}`. In the case of a reproduction, one individual is DCNL selected at random from :math:`P_\mathrm{p}`, cloned and appended to DCNL :math:`P_\mathrm{o}`. DCNL This variation is named *Or* beceause an offspring will never result from DCNL both operations crossover and mutation. The sum of both probabilities DCNL shall be in :math:`[0, 1]`, the reproduction probability is DCNL 1 - *cxpb* - *mutpb*.'
def eaMuPlusLambda(population, toolbox, mu, lambda_, cxpb, mutpb, ngen, pbar, stats=None, halloffame=None, verbose=0, max_time_mins=None): DCNL 'This is the :math:`(\mu + \lambda)` evolutionary algorithm. DCNL :param population: A list of individuals. DCNL :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution DCNL operators. DCNL :param mu: The number of individuals to select for the next generation. DCNL :param lambda\_: The number of children to produce at each generation. DCNL :param cxpb: The probability that an offspring is produced by crossover. DCNL :param mutpb: The probability that an offspring is produced by mutation. DCNL :param ngen: The number of generation. DCNL :param pbar: processing bar DCNL :param stats: A :class:`~deap.tools.Statistics` object that is updated DCNL inplace, optional. DCNL :param halloffame: A :class:`~deap.tools.HallOfFame` object that will DCNL contain the best individuals, optional. DCNL :param verbose: Whether or not to log the statistics. DCNL :returns: The final population DCNL :returns: A class:`~deap.tools.Logbook` with the statistics of the DCNL evolution. DCNL The algorithm takes in a population and evolves it in place using the DCNL :func:`varOr` function. It returns the optimized population and a DCNL :class:`~deap.tools.Logbook` with the statistics of the evolution. The DCNL logbook will contain the generation number, the number of evalutions for DCNL each generation and the statistics if a :class:`~deap.tools.Statistics` is DCNL given as argument. The *cxpb* and *mutpb* arguments are passed to the DCNL :func:`varOr` function. The pseudocode goes as follow :: DCNL evaluate(population) DCNL for g in range(ngen): DCNL offspring = varOr(population, toolbox, lambda_, cxpb, mutpb) DCNL evaluate(offspring) DCNL population = select(population + offspring, mu) DCNL First, the individuals having an invalid fitness are evaluated. Second, DCNL the evolutionary loop begins by producing *lambda_* offspring from the DCNL population, the offspring are generated by the :func:`varOr` function. The DCNL offspring are then evaluated and the next generation population is DCNL selected from both the offspring **and** the population. Finally, when DCNL *ngen* generations are done, the algorithm returns a tuple with the final DCNL population and a :class:`~deap.tools.Logbook` of the evolution. DCNL This function expects :meth:`toolbox.mate`, :meth:`toolbox.mutate`, DCNL :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be DCNL registered in the toolbox. This algorithm uses the :func:`varOr` DCNL variation.'
def cxOnePoint(ind1, ind2): DCNL 'Randomly select in each individual and exchange each subtree with the DCNL point as root between each individual. DCNL :param ind1: First tree participating in the crossover. DCNL :param ind2: Second tree participating in the crossover. DCNL :returns: A tuple of two trees.'
def mutNodeReplacement(individual, pset): DCNL 'Replaces a randomly chosen primitive from *individual* by a randomly DCNL chosen primitive no matter if it has the same number of arguments from the :attr:`pset` DCNL attribute of the individual. DCNL Parameters DCNL individual: DEAP individual DCNL A list of pipeline operators and model parameters that can be DCNL compiled by DEAP into a callable function DCNL Returns DCNL individual: DEAP individual DCNL Returns the individual with one of point mutation applied to it'
def regions(): DCNL 'Get all available regions for the Amazon S3 service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def get_cur_file_size(fp, position_to_eof=False): DCNL 'Returns size of file, optionally leaving fp positioned at EOF.'
def check_lowercase_bucketname(n): DCNL 'Bucket names must not contain uppercase characters. We check for DCNL this by appending a lowercase character and testing with islower(). DCNL Note this also covers cases like numeric bucket names with dashes. DCNL >>> check_lowercase_bucketname("Aaaa") DCNL Traceback (most recent call last): DCNL BotoClientError: S3Error: Bucket names cannot contain upper-case DCNL characters when using either the sub-domain or virtual hosting calling DCNL format. DCNL >>> check_lowercase_bucketname("1234-5678-9123") DCNL True DCNL >>> check_lowercase_bucketname("abcdefg1234") DCNL True'
def bucket_lister(bucket, prefix='', delimiter='', marker='', headers=None, encoding_type=None): DCNL 'A generator function for listing keys in a bucket.'
def versioned_bucket_lister(bucket, prefix='', delimiter='', key_marker='', version_id_marker='', headers=None, encoding_type=None): DCNL 'A generator function for listing versions in a bucket.'
def multipart_upload_lister(bucket, key_marker='', upload_id_marker='', headers=None, encoding_type=None): DCNL 'A generator function for listing multipart uploads in a bucket.'
def part_lister(mpupload, part_number_marker=None): DCNL 'A generator function for listing parts of a multipart upload.'
def regions(): DCNL 'Get all available regions for the AWS Lambda service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def versioned_bucket_lister(bucket, prefix='', delimiter='', marker='', generation_marker='', headers=None): DCNL 'A generator function for listing versioned objects.'
def regions(): DCNL 'Get all available regions for the AWS DirectConnect service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the Amazon DynamoDB service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the AWS Redshift service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the CloudWatch Logs service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the Amazon EC2 Container Service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def canonical_string(method, path, headers, expires=None, provider=None): DCNL 'Generates the aws canonical string for the given parameters'
def retry_url(url, retry_on_404=True, num_retries=10, timeout=None): DCNL 'Retry a url.  This is specifically used for accessing the metadata DCNL service on an instance.  Since this address should never be proxied DCNL (for security reasons), we create a ProxyHandler with a NULL DCNL dictionary to override any proxy settings in the environment.'
def _build_instance_metadata_url(url, version, path): DCNL 'Builds an EC2 metadata URL for fetching information about an instance. DCNL Example: DCNL >>> _build_instance_metadata_url(\'http://169.254.169.254\', \'latest\', \'meta-data/\') DCNL http://169.254.169.254/latest/meta-data/ DCNL :type url: string DCNL :param url: URL to metadata service, e.g. \'http://169.254.169.254\' DCNL :type version: string DCNL :param version: Version of the metadata to get, e.g. \'latest\' DCNL :type path: string DCNL :param path: Path of the metadata to get, e.g. \'meta-data/\'. If a trailing DCNL slash is required it must be passed in with the path. DCNL :return: The full metadata URL'
def get_instance_metadata(version='latest', url='http://169.254.169.254', data='meta-data/', timeout=None, num_retries=5): DCNL 'Returns the instance metadata as a nested Python dictionary. DCNL Simple values (e.g. local_hostname, hostname, etc.) will be DCNL stored as string values.  Values such as ancestor-ami-ids will DCNL be stored in the dict as a list of string values.  More complex DCNL fields such as public-keys and will be stored as nested dicts. DCNL If the timeout is specified, the connection to the specified url DCNL will time out after the specified number of seconds.'
def get_instance_identity(version='latest', url='http://169.254.169.254', timeout=None, num_retries=5): DCNL 'Returns the instance identity as a nested Python dictionary.'
@contextmanager DCNL def setlocale(name): DCNL 'A context manager to set the locale in a threadsafe manner.'
def update_dme(username, password, dme_id, ip_address): DCNL 'Update your Dynamic DNS record with DNSMadeEasy.com'
def fetch_file(uri, file=None, username=None, password=None): DCNL 'Fetch a file based on the URI provided. DCNL If you do not pass in a file pointer a tempfile.NamedTemporaryFile, DCNL or None if the file could not be retrieved is returned. DCNL The URI can be either an HTTP url, or "s3://bucket_name/key_name"'
def pythonize_name(name): DCNL 'Convert camel case to a "pythonic" name. DCNL Examples:: DCNL pythonize_name(\'CamelCase\') -> \'camel_case\' DCNL pythonize_name(\'already_pythonized\') -> \'already_pythonized\' DCNL pythonize_name(\'HTTPRequest\') -> \'http_request\' DCNL pythonize_name(\'HTTPStatus200Ok\') -> \'http_status_200_ok\' DCNL pythonize_name(\'UPPER\') -> \'upper\' DCNL pythonize_name(\'\') -> \'\''
def write_mime_multipart(content, compress=False, deftype='text/plain', delimiter=':'): DCNL 'Description: DCNL :param content: A list of tuples of name-content pairs. This is used DCNL instead of a dict to ensure that scripts run in order DCNL :type list of tuples: DCNL :param compress: Use gzip to compress the scripts, defaults to no compression DCNL :type bool: DCNL :param deftype: The type that should be assumed if nothing else can be figured out DCNL :type str: DCNL :param delimiter: mime delimiter DCNL :type str: DCNL :return: Final mime multipart DCNL :rtype: str:'
def guess_mime_type(content, deftype): DCNL 'Description: Guess the mime type of a block of text DCNL :param content: content we\'re finding the type of DCNL :type str: DCNL :param deftype: Default mime type DCNL :type str: DCNL :rtype: <type>: DCNL :return: <description>'
def compute_md5(fp, buf_size=8192, size=None): DCNL 'Compute MD5 hash on passed file and return results in a tuple of values. DCNL :type fp: file DCNL :param fp: File pointer to the file to MD5 hash.  The file pointer DCNL will be reset to its current location before the DCNL method returns. DCNL :type buf_size: integer DCNL :param buf_size: Number of bytes per read request. DCNL :type size: int DCNL :param size: (optional) The Maximum number of bytes to read from DCNL the file pointer (fp). This is useful when uploading DCNL a file in multiple parts where the file is being DCNL split inplace into different parts. Less bytes may DCNL be available. DCNL :rtype: tuple DCNL :return: A tuple containing the hex digest version of the MD5 hash DCNL as the first element, the base64 encoded version of the DCNL plain digest as the second element and the data size as DCNL the third element.'
def find_matching_headers(name, headers): DCNL 'Takes a specific header name and a dict of headers {"name": "value"}. DCNL Returns a list of matching header names, case-insensitive.'
def merge_headers_by_name(name, headers): DCNL 'Takes a specific header name and a dict of headers {"name": "value"}. DCNL Returns a string of all header values, comma-separated, that match the DCNL input header name, case-insensitive.'
def host_is_ipv6(hostname): DCNL 'Detect (naively) if the hostname is an IPV6 host. DCNL Return a boolean.'
def parse_host(hostname): DCNL 'Given a hostname that may have a port name, ensure that the port is trimmed DCNL returning only the host, including hostnames that are IPV6 and may include DCNL brackets.'
def regions(): DCNL 'Get all available regions for the AWS Cloudtrail service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(**kw_params): DCNL 'Get all available regions for the Amazon Simple Workflow service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def set_default_credentials(aws_access_key_id, aws_secret_access_key): DCNL 'Set default credentials.'
def regions(): DCNL 'Get all available regions for the RDS service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.rds2.layer1.RDSConnection`. DCNL Any additional parameters after the region_name are passed on to DCNL the connect method of the region object. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.rds2.layer1.RDSConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def connect_sqs(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.sqs.connection.SQSConnection` DCNL :return: A connection to Amazon\'s SQS'
def connect_s3(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.s3.connection.S3Connection` DCNL :return: A connection to Amazon\'s S3'
def connect_gs(gs_access_key_id=None, gs_secret_access_key=None, **kwargs): DCNL '@type gs_access_key_id: string DCNL @param gs_access_key_id: Your Google Cloud Storage Access Key ID DCNL @type gs_secret_access_key: string DCNL @param gs_secret_access_key: Your Google Cloud Storage Secret Access Key DCNL @rtype: L{GSConnection<boto.gs.connection.GSConnection>} DCNL @return: A connection to Google\'s Storage service'
def connect_ec2(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ec2.connection.EC2Connection` DCNL :return: A connection to Amazon\'s EC2'
def connect_elb(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ec2.elb.ELBConnection` DCNL :return: A connection to Amazon\'s Load Balancing Service'
def connect_autoscale(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ec2.autoscale.AutoScaleConnection` DCNL :return: A connection to Amazon\'s Auto Scaling Service DCNL :type use_block_device_types bool DCNL :param use_block_device_types: Specifies whether to return described Launch Configs with block device mappings containing DCNL block device types, or a list of old style block device mappings (deprecated).  This defaults to false for compatability DCNL with the old incorrect style.'
def connect_cloudwatch(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ec2.cloudwatch.CloudWatchConnection` DCNL :return: A connection to Amazon\'s EC2 Monitoring service'
def connect_sdb(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.sdb.connection.SDBConnection` DCNL :return: A connection to Amazon\'s SDB'
def connect_fps(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.fps.connection.FPSConnection` DCNL :return: A connection to FPS'
def connect_mturk(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.mturk.connection.MTurkConnection` DCNL :return: A connection to MTurk'
def connect_cloudfront(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.fps.connection.FPSConnection` DCNL :return: A connection to FPS'
def connect_vpc(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.vpc.VPCConnection` DCNL :return: A connection to VPC'
def connect_rds(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.rds.RDSConnection` DCNL :return: A connection to RDS'
def connect_rds2(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.rds2.layer1.RDSConnection` DCNL :return: A connection to RDS'
def connect_emr(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.emr.EmrConnection` DCNL :return: A connection to Elastic mapreduce'
def connect_sns(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.sns.SNSConnection` DCNL :return: A connection to Amazon\'s SNS'
def connect_iam(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.iam.IAMConnection` DCNL :return: A connection to Amazon\'s IAM'
def connect_route53(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.dns.Route53Connection` DCNL :return: A connection to Amazon\'s Route53 DNS Service'
def connect_cloudformation(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.cloudformation.CloudFormationConnection` DCNL :return: A connection to Amazon\'s CloudFormation Service'
def connect_euca(host=None, aws_access_key_id=None, aws_secret_access_key=None, port=8773, path='/services/Eucalyptus', is_secure=False, **kwargs): DCNL 'Connect to a Eucalyptus service. DCNL :type host: string DCNL :param host: the host name or ip address of the Eucalyptus server DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ec2.connection.EC2Connection` DCNL :return: A connection to Eucalyptus server'
def connect_glacier(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.glacier.layer2.Layer2` DCNL :return: A connection to Amazon\'s Glacier Service'
def connect_ec2_endpoint(url, aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to an EC2 Api endpoint.  Additional arguments are passed DCNL through to connect_ec2. DCNL :type url: string DCNL :param url: A url for the ec2 api endpoint to connect to DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ec2.connection.EC2Connection` DCNL :return: A connection to Eucalyptus server'
def connect_walrus(host=None, aws_access_key_id=None, aws_secret_access_key=None, port=8773, path='/services/Walrus', is_secure=False, **kwargs): DCNL 'Connect to a Walrus service. DCNL :type host: string DCNL :param host: the host name or ip address of the Walrus server DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.s3.connection.S3Connection` DCNL :return: A connection to Walrus'
def connect_ses(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ses.SESConnection` DCNL :return: A connection to Amazon\'s SES'
def connect_sts(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.sts.STSConnection` DCNL :return: A connection to Amazon\'s STS'
def connect_ia(ia_access_key_id=None, ia_secret_access_key=None, is_secure=False, **kwargs): DCNL 'Connect to the Internet Archive via their S3-like API. DCNL :type ia_access_key_id: string DCNL :param ia_access_key_id: Your IA Access Key ID.  This will also look DCNL in your boto config file for an entry in the Credentials DCNL section called "ia_access_key_id" DCNL :type ia_secret_access_key: string DCNL :param ia_secret_access_key: Your IA Secret Access Key.  This will also DCNL look in your boto config file for an entry in the Credentials DCNL section called "ia_secret_access_key" DCNL :rtype: :class:`boto.s3.connection.S3Connection` DCNL :return: A connection to the Internet Archive'
def connect_dynamodb(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.dynamodb.layer2.Layer2` DCNL :return: A connection to the Layer2 interface for DynamoDB.'
def connect_swf(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.swf.layer1.Layer1` DCNL :return: A connection to the Layer1 interface for SWF.'
def connect_cloudsearch(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.cloudsearch.layer2.Layer2` DCNL :return: A connection to Amazon\'s CloudSearch service'
def connect_cloudsearch2(aws_access_key_id=None, aws_secret_access_key=None, sign_request=False, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :type sign_request: bool DCNL :param sign_request: whether or not to sign search and DCNL upload requests DCNL :rtype: :class:`boto.cloudsearch2.layer2.Layer2` DCNL :return: A connection to Amazon\'s CloudSearch2 service'
def connect_cloudsearchdomain(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.cloudsearchdomain.layer1.CloudSearchDomainConnection` DCNL :return: A connection to Amazon\'s CloudSearch Domain service'
def connect_beanstalk(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.beanstalk.layer1.Layer1` DCNL :return: A connection to Amazon\'s Elastic Beanstalk service'
def connect_elastictranscoder(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ets.layer1.ElasticTranscoderConnection` DCNL :return: A connection to Amazon\'s Elastic Transcoder service'
def connect_redshift(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.redshift.layer1.RedshiftConnection` DCNL :return: A connection to Amazon\'s Redshift service'
def connect_support(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.support.layer1.SupportConnection` DCNL :return: A connection to Amazon\'s Support service'
def connect_cloudtrail(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to AWS CloudTrail DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.cloudtrail.layer1.CloudtrailConnection` DCNL :return: A connection to the AWS Cloudtrail service'
def connect_directconnect(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to AWS DirectConnect DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.directconnect.layer1.DirectConnectConnection` DCNL :return: A connection to the AWS DirectConnect service'
def connect_kinesis(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to Amazon Kinesis DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.kinesis.layer1.KinesisConnection` DCNL :return: A connection to the Amazon Kinesis service'
def connect_logs(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to Amazon CloudWatch Logs DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.kinesis.layer1.CloudWatchLogsConnection` DCNL :return: A connection to the Amazon CloudWatch Logs service'
def connect_route53domains(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to Amazon Route 53 Domains DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.route53.domains.layer1.Route53DomainsConnection` DCNL :return: A connection to the Amazon Route 53 Domains service'
def connect_cognito_identity(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to Amazon Cognito Identity DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.cognito.identity.layer1.CognitoIdentityConnection` DCNL :return: A connection to the Amazon Cognito Identity service'
def connect_cognito_sync(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to Amazon Cognito Sync DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.cognito.sync.layer1.CognitoSyncConnection` DCNL :return: A connection to the Amazon Cognito Sync service'
def connect_kms(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to AWS Key Management Service DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.kms.layer1.KMSConnection` DCNL :return: A connection to the AWS Key Management Service'
def connect_awslambda(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to AWS Lambda DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.awslambda.layer1.AWSLambdaConnection` DCNL :return: A connection to the AWS Lambda service'
def connect_codedeploy(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to AWS CodeDeploy DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.cognito.sync.layer1.CodeDeployConnection` DCNL :return: A connection to the AWS CodeDeploy service'
def connect_configservice(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to AWS Config DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.kms.layer1.ConfigServiceConnection` DCNL :return: A connection to the AWS Config service'
def connect_cloudhsm(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to AWS CloudHSM DCNL :type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.cloudhsm.layer1.CloudHSMConnection` DCNL :return: A connection to the AWS CloudHSM service'
def connect_ec2containerservice(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to Amazon EC2 Container Service DCNL rtype: :class:`boto.ec2containerservice.layer1.EC2ContainerServiceConnection` DCNL :return: A connection to the Amazon EC2 Container Service'
def connect_machinelearning(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL 'Connect to Amazon Machine Learning service DCNL rtype: :class:`boto.machinelearning.layer1.MachineLearningConnection` DCNL :return: A connection to the Amazon Machine Learning service'
def storage_uri(uri_str, default_scheme='file', debug=0, validate=True, bucket_storage_uri_class=BucketStorageUri, suppress_consec_slashes=True, is_latest=False): DCNL 'Instantiate a StorageUri from a URI string. DCNL :type uri_str: string DCNL :param uri_str: URI naming bucket + optional object. DCNL :type default_scheme: string DCNL :param default_scheme: default scheme for scheme-less URIs. DCNL :type debug: int DCNL :param debug: debug level to pass in to boto connection (range 0..2). DCNL :type validate: bool DCNL :param validate: whether to check for bucket name validity. DCNL :type bucket_storage_uri_class: BucketStorageUri interface. DCNL :param bucket_storage_uri_class: Allows mocking for unit tests. DCNL :param suppress_consec_slashes: If provided, controls whether DCNL consecutive slashes will be suppressed in key paths. DCNL :type is_latest: bool DCNL :param is_latest: whether this versioned object represents the DCNL current version. DCNL We allow validate to be disabled to allow caller DCNL to implement bucket-level wildcarding (outside the boto library; DCNL see gsutil). DCNL :rtype: :class:`boto.StorageUri` subclass DCNL :return: StorageUri subclass for given URI. DCNL ``uri_str`` must be one of the following formats: DCNL * gs://bucket/name DCNL * gs://bucket/name#ver DCNL * s3://bucket/name DCNL * gs://bucket DCNL * s3://bucket DCNL * filename (which could be a Unix path like /a/b/c or a Windows path like DCNL C:\c) DCNL The last example uses the default scheme (\'file\', unless overridden).'
def storage_uri_for_key(key): DCNL 'Returns a StorageUri for the given key. DCNL :type key: :class:`boto.s3.key.Key` or subclass DCNL :param key: URI naming bucket + optional object.'
def fib(cv=1, lv=0): DCNL 'The fibonacci sequence, this incrementer uses the DCNL last value'
def get_manager(cls): DCNL 'Returns the appropriate Manager class for a given Model class.  It DCNL does this by looking in the boto config for a section like this:: DCNL [DB] DCNL db_type = SimpleDB DCNL db_user = <aws access key id> DCNL db_passwd = <aws secret access key> DCNL db_name = my_domain DCNL [DB_TestBasic] DCNL db_type = SimpleDB DCNL db_user = <another aws access key id> DCNL db_passwd = <another aws secret access key> DCNL db_name = basic_domain DCNL db_port = 1111 DCNL The values in the DB section are "generic values" that will be used DCNL if nothing more specific is found.  You can also create a section for DCNL a specific Model class that gives the db info for that class. DCNL In the example above, TestBasic is a Model subclass.'
def regions(): DCNL 'Get all available regions for the SDB service. DCNL :rtype: list DCNL :return: A list of :class:`boto.sdb.regioninfo.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.sdb.connection.SDBConnection`. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.sdb.connection.SDBConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def GetValidHostsForCert(cert): DCNL 'Returns a list of valid host globs for an SSL certificate. DCNL Args: DCNL cert: A dictionary representing an SSL certificate. DCNL Returns: DCNL list: A list of valid host globs.'
def ValidateCertificateHostname(cert, hostname): DCNL 'Validates that a given hostname is valid for an SSL certificate. DCNL Args: DCNL cert: A dictionary representing an SSL certificate. DCNL hostname: The hostname to test. DCNL Returns: DCNL bool: Whether or not the hostname is valid for this certificate.'
def regions(): DCNL 'Get all available regions for the Amazon CloudSearch service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the CloudWatch service. DCNL :rtype: list DCNL :return: A list of :class:`boto.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.ec2.cloudwatch.CloudWatchConnection`. DCNL :param str region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.ec2.CloudWatchConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def regions(**kw_params): DCNL 'Get all available regions for the EC2 service. DCNL You may pass any of the arguments accepted by the EC2Connection DCNL object\'s constructor as keyword arguments and they will be DCNL passed along to the EC2Connection object. DCNL :rtype: list DCNL :return: A list of :class:`boto.ec2.regioninfo.RegionInfo`'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.ec2.connection.EC2Connection`. DCNL Any additional parameters after the region_name are passed on to DCNL the connect method of the region object. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.ec2.connection.EC2Connection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def get_region(region_name, **kw_params): DCNL 'Find and return a :class:`boto.ec2.regioninfo.RegionInfo` object DCNL given a region name. DCNL :type: str DCNL :param: The name of the region. DCNL :rtype: :class:`boto.ec2.regioninfo.RegionInfo` DCNL :return: The RegionInfo object for the given region or None if DCNL an invalid region name is provided.'
def regions(): DCNL 'Get all available regions for the Auto Scaling service. DCNL :rtype: list DCNL :return: A list of :class:`boto.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.ec2.autoscale.AutoScaleConnection`. DCNL :param str region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.ec2.AutoScaleConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def regions(): DCNL 'Get all available regions for the ELB service. DCNL :rtype: list DCNL :return: A list of :class:`boto.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.ec2.elb.ELBConnection`. DCNL :param str region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.ec2.ELBConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def regions(): DCNL 'Get all available regions for the Amazon OpsWorks service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the AWS Config service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the RDS service. DCNL :rtype: list DCNL :return: A list of :class:`boto.rds.regioninfo.RDSRegionInfo`'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.rds.RDSConnection`. DCNL Any additional parameters after the region_name are passed on to DCNL the connect method of the region object. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.rds.RDSConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def get_auth_handler(host, config, provider, requested_capability=None): DCNL 'Finds an AuthHandler that is ready to authenticate. DCNL Lists through all the registered AuthHandlers to find one that is willing DCNL to handle for the requested capabilities, config and provider. DCNL :type host: string DCNL :param host: The name of the host DCNL :type config: DCNL :param config: DCNL :type provider: DCNL :param provider: DCNL Returns: DCNL An implementation of AuthHandler. DCNL Raises: DCNL boto.exception.NoAuthHandlerFound'
def regions(): DCNL 'Get all available regions for the Route53 service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.route53.connection.Route53Connection`. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.route53.connection.Route53Connection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def regions(): DCNL 'Get all available regions for the Amazon Route 53 Domains service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the Amazon CloudSearch Domain service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the STS service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.sts.connection.STSConnection`. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.sts.connection.STSConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def regions(): DCNL 'Get all available regions for the Amazon Machine Learning. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the AWS Key Management Service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the Amazon Cognito Sync service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the Amazon Cognito Identity service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the IAM service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.iam.connection.IAMConnection`. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.iam.connection.IAMConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def regions(): DCNL 'Get all available regions for the SES service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.ses.connection.SESConnection`. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.ses.connection.SESConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def load_endpoint_json(path): DCNL 'Loads a given JSON file & returns it. DCNL :param path: The path to the JSON file DCNL :type path: string DCNL :returns: The loaded data'
def _load_json_file(path): DCNL 'Loads a given JSON file & returns it. DCNL :param path: The path to the JSON file DCNL :type path: string DCNL :returns: The loaded data'
def merge_endpoints(defaults, additions): DCNL 'Given an existing set of endpoint data, this will deep-update it with DCNL any similarly structured data in the additions. DCNL :param defaults: The existing endpoints data DCNL :type defaults: dict DCNL :param defaults: The additional endpoints data DCNL :type defaults: dict DCNL :returns: The modified endpoints data DCNL :rtype: dict'
def load_regions(): DCNL 'Actually load the region/endpoint information from the JSON files. DCNL By default, this loads from the default included ``boto/endpoints.json`` DCNL file. DCNL Users can override/extend this by supplying either a ``BOTO_ENDPOINTS`` DCNL environment variable or a ``endpoints_path`` config variable, either of DCNL which should be an absolute path to the user\'s JSON file. DCNL :returns: The endpoints data DCNL :rtype: dict'
def _load_builtin_endpoints(_cache=_endpoints_cache): DCNL 'Loads the builtin endpoints in the legacy format.'
def get_regions(service_name, region_cls=None, connection_cls=None): DCNL 'Given a service name (like ``ec2``), returns a list of ``RegionInfo`` DCNL objects for that service. DCNL This leverages the ``endpoints.json`` file (+ optional user overrides) to DCNL configure/construct all the objects. DCNL :param service_name: The name of the service to construct the ``RegionInfo`` DCNL objects for. Ex: ``ec2``, ``s3``, ``sns``, etc. DCNL :type service_name: string DCNL :param region_cls: (Optional) The class to use when constructing. By DCNL default, this is ``RegionInfo``. DCNL :type region_cls: class DCNL :param connection_cls: (Optional) The connection class for the DCNL ``RegionInfo`` object. Providing this allows the ``connect`` method on DCNL the ``RegionInfo`` to work. Default is ``None`` (no connection). DCNL :type connection_cls: class DCNL :returns: A list of configured ``RegionInfo`` objects DCNL :rtype: list'
def connect(service_name, region_name, region_cls=None, connection_cls=None, **kw_params): DCNL 'Create a connection class for a given service in a given region. DCNL :param service_name: The name of the service to construct the DCNL ``RegionInfo`` object for, e.g. ``ec2``, ``s3``, etc. DCNL :type service_name: str DCNL :param region_name: The name of the region to connect to, e.g. DCNL ``us-west-2``, ``eu-central-1``, etc. DCNL :type region_name: str DCNL :param region_cls: (Optional) The class to use when constructing. By DCNL default, this is ``RegionInfo``. DCNL :type region_cls: class DCNL :param connection_cls: (Optional) The connection class for the DCNL ``RegionInfo`` object. Providing this allows the ``connect`` method on DCNL the ``RegionInfo`` to work. Default is ``None`` (no connection). DCNL :type connection_cls: class DCNL :returns: A configured connection class.'
def _get_region(service_name, region_name, region_cls=None, connection_cls=None): DCNL 'Finds the region by searching through the known regions.'
def _get_region_with_heuristics(service_name, region_name, region_cls=None, connection_cls=None): DCNL 'Finds the region using known regions and heuristics.'
def regions(): DCNL 'Get all available regions for the CloudFormation service. DCNL :rtype: list DCNL :return: A list of :class:`boto.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.cloudformation.CloudFormationConnection`. DCNL :param str region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.cloudformation.CloudFormationConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def start(server): DCNL 'Connect to the specified server. DCNL :return: If the server is local, the function returns a DCNL :class:`boto.manage.cmdshell.LocalClient` object. DCNL If the server is remote, the function returns a DCNL :class:`boto.manage.cmdshell.SSHClient` object.'
def sshclient_from_instance(instance, ssh_key_file, host_key_file='~/.ssh/known_hosts', user_name='root', ssh_pwd=None): DCNL 'Create and return an SSHClient object given an DCNL instance object. DCNL :type instance: :class`boto.ec2.instance.Instance` object DCNL :param instance: The instance object. DCNL :type ssh_key_file: string DCNL :param ssh_key_file: A path to the private key file that is DCNL used to log into the instance. DCNL :type host_key_file: string DCNL :param host_key_file: A path to the known_hosts file used DCNL by the SSH client. DCNL Defaults to ~/.ssh/known_hosts DCNL :type user_name: string DCNL :param user_name: The username to use when logging into DCNL the instance.  Defaults to root. DCNL :type ssh_pwd: string DCNL :param ssh_pwd: The passphrase, if any, associated with DCNL private key.'
def regions(): DCNL 'Get all available regions for the Amazon Kinesis service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def minimum_part_size(size_in_bytes, default_part_size=DEFAULT_PART_SIZE): DCNL 'Calculate the minimum part size needed for a multipart upload. DCNL Glacier allows a maximum of 10,000 parts per upload.  It also DCNL states that the maximum archive size is 10,000 * 4 GB, which means DCNL the part size can range from 1MB to 4GB (provided it is one 1MB DCNL multiplied by a power of 2). DCNL This function will compute what the minimum part size must be in DCNL order to upload a file of size ``size_in_bytes``. DCNL It will first check if ``default_part_size`` is sufficient for DCNL a part size given the ``size_in_bytes``.  If this is not the case, DCNL then the smallest part size than can accomodate a file of size DCNL ``size_in_bytes`` will be returned. DCNL If the file size is greater than the maximum allowed archive DCNL size of 10,000 * 4GB, a ``ValueError`` will be raised.'
def tree_hash(fo): DCNL 'Given a hash of each 1MB chunk (from chunk_hashes) this will hash DCNL together adjacent hashes until it ends up with one big one. So a DCNL tree of hashes.'
def compute_hashes_from_fileobj(fileobj, chunk_size=(1024 * 1024)): DCNL 'Compute the linear and tree hash from a fileobj. DCNL This function will compute the linear/tree hash of a fileobj DCNL in a single pass through the fileobj. DCNL :param fileobj: A file like object. DCNL :param chunk_size: The size of the chunks to use for the tree DCNL hash.  This is also the buffer size used to read from DCNL `fileobj`. DCNL :rtype: tuple DCNL :return: A tuple of (linear_hash, tree_hash).  Both hashes DCNL are returned in hex.'
def tree_hash_from_str(str_as_bytes): DCNL ':type str_as_bytes: str DCNL :param str_as_bytes: The string for which to compute the tree hash. DCNL :rtype: str DCNL :return: The computed tree hash, returned as hex.'
def regions(): DCNL 'Get all available regions for the Amazon Glacier service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def resume_file_upload(vault, upload_id, part_size, fobj, part_hash_map, chunk_size=_ONE_MEGABYTE): DCNL 'Resume upload of a file already part-uploaded to Glacier. DCNL The resumption of an upload where the part-uploaded section is empty is a DCNL valid degenerate case that this function can handle. In this case, DCNL part_hash_map should be an empty dict. DCNL :param vault: boto.glacier.vault.Vault object. DCNL :param upload_id: existing Glacier upload id of upload being resumed. DCNL :param part_size: part size of existing upload. DCNL :param fobj: file object containing local data to resume. This must read DCNL from the start of the entire upload, not just from the point being DCNL resumed. Use fobj.seek(0) to achieve this if necessary. DCNL :param part_hash_map: {part_index: part_tree_hash, ...} of data already DCNL uploaded. Each supplied part_tree_hash will be verified and the part DCNL re-uploaded if there is a mismatch. DCNL :param chunk_size: chunk size of tree hash calculation. This must be DCNL 1 MiB for Amazon.'
def regions(): DCNL 'Get all available regions for the AWS Datapipeline service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the AWS CodeDeploy service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the Amazon Support service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the AWS Elastic Transcoder service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the SQS service. DCNL :rtype: list DCNL :return: A list of :class:`boto.sqs.regioninfo.RegionInfo`'
def regions(**kw_params): DCNL 'Get all available regions for the EC2 service. DCNL You may pass any of the arguments accepted by the VPCConnection DCNL object\'s constructor as keyword arguments and they will be DCNL passed along to the VPCConnection object. DCNL :rtype: list DCNL :return: A list of :class:`boto.ec2.regioninfo.RegionInfo`'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.vpc.VPCConnection`. DCNL Any additional parameters after the region_name are passed on to DCNL the connect method of the region object. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.vpc.VPCConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def regions(): DCNL 'Get all available regions for the AWS Elastic Beanstalk service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the AWS CloudHSM service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the AWS ElastiCache service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the Amazon Elastic MapReduce service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the Amazon CloudSearch service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def regions(): DCNL 'Get all available regions for the SNS service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo` instances'
def connect_to_region(region_name, **kw_params): DCNL 'Given a valid region name, return a DCNL :class:`boto.sns.connection.SNSConnection`. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.sns.connection.SNSConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invalid region DCNL name is given'
def regions(): DCNL 'Get all available regions for the Amazon DynamoDB service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'
def serialize_num(val): DCNL 'Cast a number to a string and perform DCNL validation to ensure no loss of precision.'
def get_dynamodb_type(val, use_boolean=True): DCNL 'Take a scalar Python value and return a string representing DCNL the corresponding Amazon DynamoDB type.  If the value passed in is DCNL not a supported type, raise a TypeError.'
def dynamize_value(val): DCNL 'Take a scalar Python value and return a dict consisting DCNL of the Amazon DynamoDB type specification and the value that DCNL needs to be sent to Amazon DynamoDB.  If the type of the value DCNL is not supported, raise a TypeError'
def item_object_hook(dct): DCNL 'A custom object hook for use when decoding JSON item bodys. DCNL This hook will transform Amazon DynamoDB JSON responses to something DCNL that maps directly to native Python types.'
def _add_doc(func, doc): DCNL 'Add documentation to a function.'
def _import_module(name): DCNL 'Import module, returning the module after the last dot.'
def add_move(move): DCNL 'Add an item to six.moves.'
def remove_move(name): DCNL 'Remove item from six.moves.'
def with_metaclass(meta, *bases): DCNL 'Create a base class with a metaclass.'
def add_metaclass(metaclass): DCNL 'Class decorator for creating a class with a metaclass.'
def python_2_unicode_compatible(klass): DCNL 'A decorator that defines __unicode__ and __str__ methods under Python 2. DCNL Under Python 3 it does nothing. DCNL To support Python 2 and 3 with a single code base, define a __str__ method DCNL returning text and apply this decorator to the class.'
def spawn(function, *args, **kwargs): DCNL 'Spawns a new thread.  API is the same as DCNL gevent.greenlet.Greenlet.spawn.'
def test_close_connections(): DCNL 'A test that exposes the problem where connections are returned to the DCNL connection pool (and closed) before the caller reads the response. DCNL I couldn\'t think of a way to test it without greenlets, so this test DCNL doesn\'t run as part of the standard test suite.  That way, no more DCNL dependencies are added to the test suite.'
def test_reuse_connections(): DCNL 'This test is an attempt to expose problems because of the fact DCNL that boto returns connections to the connection pool before DCNL reading the response.  The strategy is to start a couple big reads DCNL from S3, where it will take time to read the response, and then DCNL start other requests that will reuse the same connection from the DCNL pool while the big response is still being read. DCNL The test passes because of an interesting combination of factors. DCNL I was expecting that it would fail because two threads would be DCNL reading the same connection at the same time.  That doesn\'t happen DCNL because httplib catches the problem before it happens and raises DCNL an exception. DCNL Here\'s the sequence of events: DCNL - Thread 1: Send a request to read a big S3 object. DCNL - Thread 1: Returns connection to pool. DCNL - Thread 1: Start reading the body if the response. DCNL - Thread 2: Get the same connection from the pool. DCNL - Thread 2: Send another request on the same connection. DCNL - Thread 2: Try to read the response, but DCNL HTTPConnection.get_response notices that the DCNL previous response isn\'t done reading yet, and DCNL raises a ResponseNotReady exception. DCNL - Thread 2: _mexe catches the exception, does not return the DCNL connection to the pool, gets a new connection, and DCNL retries. DCNL - Thread 1: Finish reading the body of its response. DCNL - Server:   Gets the second request on the connection, and DCNL sends a response.  This response is ignored because DCNL the connection has been dropped on the client end. DCNL If you add a print statement in HTTPConnection.get_response at the DCNL point where it raises ResponseNotReady, and then run this test, DCNL you can see that it\'s happening.'
def retry(ExceptionToCheck, tries=4, delay=3, backoff=2, logger=None): DCNL 'Retry calling the decorated function using an exponential backoff. DCNL Taken from: DCNL https://github.com/saltycrane/retry-decorator DCNL Licensed under BSD: DCNL https://github.com/saltycrane/retry-decorator/blob/master/LICENSE DCNL :param ExceptionToCheck: the exception to check. may be a tuple of DCNL exceptions to check DCNL :type ExceptionToCheck: Exception or tuple DCNL :param tries: number of times to try (not retry) before giving up DCNL :type tries: int DCNL :param delay: initial delay between retries in seconds DCNL :type delay: int DCNL :param backoff: backoff multiplier e.g. value of 2 will double the delay DCNL each retry DCNL :type backoff: int DCNL :param logger: logger to use. If None, print DCNL :type logger: logging.Logger instance'
def fake_loads_value_error(content, *args, **kwargs): DCNL 'Callable to generate a fake ValueError'
def fake_loads_json_error(content, *args, **kwargs): DCNL 'Callable to generate a fake JSONDecodeError'
def _yield_all_region_tests(region, expected_signature_version='hmac-v4-s3', dns_suffix='.amazonaws.com'): DCNL 'Yield tests for every variation of a region\'s endpoints.'
def fake_loads_value_error(content, *args, **kwargs): DCNL 'Callable to generate a fake ValueError'
def fake_loads_json_error(content, *args, **kwargs): DCNL 'Callable to generate a fake JSONDecodeError'
def cleanup(): DCNL 'Remove any boto test related HIT\'s'
def has_permission(permission, context, request): DCNL 'A function that calls :meth:`pyramid.request.Request.has_permission` DCNL and returns its result. DCNL .. deprecated:: 1.5 DCNL Use :meth:`pyramid.request.Request.has_permission` instead. DCNL .. versionchanged:: 1.5a3 DCNL If context is None, then attempt to use the context attribute of self; DCNL if not set, then the AttributeError is propagated.'
def authenticated_userid(request): DCNL 'A function that returns the value of the property DCNL :attr:`pyramid.request.Request.authenticated_userid`. DCNL .. deprecated:: 1.5 DCNL Use :attr:`pyramid.request.Request.authenticated_userid` instead.'
def unauthenticated_userid(request): DCNL 'A function that returns the value of the property DCNL :attr:`pyramid.request.Request.unauthenticated_userid`. DCNL .. deprecated:: 1.5 DCNL Use :attr:`pyramid.request.Request.unauthenticated_userid` instead.'
def effective_principals(request): DCNL 'A function that returns the value of the property DCNL :attr:`pyramid.request.Request.effective_principals`. DCNL .. deprecated:: 1.5 DCNL Use :attr:`pyramid.request.Request.effective_principals` instead.'
def remember(request, userid=_marker, **kw): DCNL 'Returns a sequence of header tuples (e.g. ``[(\'Set-Cookie\', \'foo=abc\')]``) DCNL on this request\'s response. DCNL These headers are suitable for \'remembering\' a set of credentials DCNL implied by the data passed as ``userid`` and ``*kw`` using the DCNL current :term:`authentication policy`.  Common usage might look DCNL like so within the body of a view function (``response`` is DCNL assumed to be a :term:`WebOb` -style :term:`response` object DCNL computed previously by the view code): DCNL .. code-block:: python DCNL from pyramid.security import remember DCNL headers = remember(request, \'chrism\', password=\'123\', max_age=\'86400\') DCNL response = request.response DCNL response.headerlist.extend(headers) DCNL return response DCNL If no :term:`authentication policy` is in use, this function will DCNL always return an empty sequence. If used, the composition and DCNL meaning of ``**kw`` must be agreed upon by the calling code and DCNL the effective authentication policy. DCNL .. deprecated:: 1.6 DCNL Renamed the ``principal`` argument to ``userid`` to clarify its DCNL purpose.'
def forget(request): DCNL 'Return a sequence of header tuples (e.g. ``[(\'Set-Cookie\', DCNL \'foo=abc\')]``) suitable for \'forgetting\' the set of credentials DCNL possessed by the currently authenticated user.  A common usage DCNL might look like so within the body of a view function DCNL (``response`` is assumed to be an :term:`WebOb` -style DCNL :term:`response` object computed previously by the view code): DCNL .. code-block:: python DCNL from pyramid.security import forget DCNL headers = forget(request) DCNL response.headerlist.extend(headers) DCNL return response DCNL If no :term:`authentication policy` is in use, this function will DCNL always return an empty sequence.'
def principals_allowed_by_permission(context, permission): DCNL 'Provided a ``context`` (a resource object), and a ``permission`` DCNL (a string or unicode object), if a :term:`authorization policy` is DCNL in effect, return a sequence of :term:`principal` ids that possess DCNL the permission in the ``context``.  If no authorization policy is DCNL in effect, this will return a sequence with the single value DCNL :mod:`pyramid.security.Everyone` (the special principal DCNL identifier representing all principals). DCNL .. note:: DCNL even if an :term:`authorization policy` is in effect, DCNL some (exotic) authorization policies may not implement the DCNL required machinery for this function; those will cause a DCNL :exc:`NotImplementedError` exception to be raised when this DCNL function is invoked.'
def view_execution_permitted(context, request, name=''): DCNL 'If the view specified by ``context`` and ``name`` is protected DCNL by a :term:`permission`, check the permission associated with the DCNL view using the effective authentication/authorization policies and DCNL the ``request``.  Return a boolean result.  If no DCNL :term:`authorization policy` is in effect, or if the view is not DCNL protected by a permission, return ``True``. If no view can view found, DCNL an exception will be raised. DCNL .. versionchanged:: 1.4a4 DCNL An exception is raised if no view is found.'
def get_current_request(): DCNL 'Return the currently active request or ``None`` if no request DCNL is currently active. DCNL This function should be used *extremely sparingly*, usually only DCNL in unit testing code.  It\'s almost always usually a mistake to use DCNL ``get_current_request`` outside a testing context because its DCNL usage makes it possible to write code that can be neither easily DCNL tested nor scripted.'
def get_current_registry(context=None): DCNL 'Return the currently active :term:`application registry` or the DCNL global application registry if no request is currently active. DCNL This function should be used *extremely sparingly*, usually only DCNL in unit testing code.  It\'s almost always usually a mistake to use DCNL ``get_current_registry`` outside a testing context because its DCNL usage makes it possible to write code that can be neither easily DCNL tested nor scripted.'
def render_view_to_response(context, request, name='', secure=True): DCNL 'Call the :term:`view callable` configured with a :term:`view DCNL configuration` that matches the :term:`view name` ``name`` DCNL registered against the specified ``context`` and ``request`` and DCNL return a :term:`response` object.  This function will return DCNL ``None`` if a corresponding :term:`view callable` cannot be found DCNL (when no :term:`view configuration` matches the combination of DCNL ``name`` / ``context`` / and ``request``). DCNL If `secure`` is ``True``, and the :term:`view callable` found is DCNL protected by a permission, the permission will be checked before calling DCNL the view function.  If the permission check disallows view execution DCNL (based on the current :term:`authorization policy`), a DCNL :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised. DCNL The exception\'s ``args`` attribute explains why the view access was DCNL disallowed. DCNL If ``secure`` is ``False``, no permission checking is done.'
def render_view_to_iterable(context, request, name='', secure=True): DCNL 'Call the :term:`view callable` configured with a :term:`view DCNL configuration` that matches the :term:`view name` ``name`` DCNL registered against the specified ``context`` and ``request`` and DCNL return an iterable object which represents the body of a response. DCNL This function will return ``None`` if a corresponding :term:`view DCNL callable` cannot be found (when no :term:`view configuration` DCNL matches the combination of ``name`` / ``context`` / and DCNL ``request``).  Additionally, this function will raise a DCNL :exc:`ValueError` if a view function is found and called but the DCNL view function\'s result does not have an ``app_iter`` attribute. DCNL You can usually get the bytestring representation of the return value of DCNL this function by calling ``b\'\'.join(iterable)``, or just use DCNL :func:`pyramid.view.render_view` instead. DCNL If ``secure`` is ``True``, and the view is protected by a permission, the DCNL permission will be checked before the view function is invoked.  If the DCNL permission check disallows view execution (based on the current DCNL :term:`authentication policy`), a DCNL :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised; its DCNL ``args`` attribute explains why the view access was disallowed. DCNL If ``secure`` is ``False``, no permission checking is DCNL done.'
def render_view(context, request, name='', secure=True): DCNL 'Call the :term:`view callable` configured with a :term:`view DCNL configuration` that matches the :term:`view name` ``name`` DCNL registered against the specified ``context`` and ``request`` DCNL and unwind the view response\'s ``app_iter`` (see DCNL :ref:`the_response`) into a single bytestring.  This function will DCNL return ``None`` if a corresponding :term:`view callable` cannot be DCNL found (when no :term:`view configuration` matches the combination DCNL of ``name`` / ``context`` / and ``request``).  Additionally, this DCNL function will raise a :exc:`ValueError` if a view function is DCNL found and called but the view function\'s result does not have an DCNL ``app_iter`` attribute. This function will return ``None`` if a DCNL corresponding view cannot be found. DCNL If ``secure`` is ``True``, and the view is protected by a permission, the DCNL permission will be checked before the view is invoked.  If the permission DCNL check disallows view execution (based on the current :term:`authorization DCNL policy`), a :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be DCNL raised; its ``args`` attribute explains why the view access was DCNL disallowed. DCNL If ``secure`` is ``False``, no permission checking is done.'
def exception_response(status_code, **kw): DCNL 'Creates an HTTP exception based on a status code. Example:: DCNL raise exception_response(404) # raises an HTTPNotFound exception. DCNL The values passed as ``kw`` are provided to the exception\'s constructor.'
def _get_response_factory(registry): DCNL 'Obtain a :class: `pyramid.response.Response` using the DCNL `pyramid.interfaces.IResponseFactory`.'
def asset_spec_from_abspath(abspath, package): DCNL 'Try to convert an absolute path to a resource in a package to DCNL a resource specification if possible; otherwise return the DCNL absolute path.'
def get_root(app, request=None): DCNL 'Return a tuple composed of ``(root, closer)`` when provided a DCNL :term:`router` instance as the ``app`` argument.  The ``root`` DCNL returned is the application root object.  The ``closer`` returned DCNL is a callable (accepting no arguments) that should be called when DCNL your scripting application is finished using the root. DCNL ``request`` is passed to the :app:`Pyramid` application root DCNL factory to compute the root. If ``request`` is None, a default DCNL will be constructed using the registry\'s :term:`Request Factory` DCNL via the :meth:`pyramid.interfaces.IRequestFactory.blank` method.'
def prepare(request=None, registry=None): DCNL 'This function pushes data onto the Pyramid threadlocal stack DCNL (request and registry), making those objects \'current\'.  It DCNL returns a dictionary useful for bootstrapping a Pyramid DCNL application in a scripting environment. DCNL ``request`` is passed to the :app:`Pyramid` application root DCNL factory to compute the root. If ``request`` is None, a default DCNL will be constructed using the registry\'s :term:`Request Factory` DCNL via the :meth:`pyramid.interfaces.IRequestFactory.blank` method. DCNL If ``registry`` is not supplied, the last registry loaded from DCNL :attr:`pyramid.config.global_registries` will be used. If you DCNL have loaded more than one :app:`Pyramid` application in the DCNL current process, you may not want to use the last registry DCNL loaded, thus you can search the ``global_registries`` and supply DCNL the appropriate one based on your own criteria. DCNL The function returns a dictionary composed of ``root``, DCNL ``closer``, ``registry``, ``request`` and ``root_factory``.  The DCNL ``root`` returned is the application\'s root resource object.  The DCNL ``closer`` returned is a callable (accepting no arguments) that DCNL should be called when your scripting application is finished DCNL using the root.  ``registry`` is the resolved registry object. DCNL ``request`` is the request object passed or the constructed request DCNL if no request is passed.  ``root_factory`` is the root factory used DCNL to construct the root. DCNL This function may be used as a context manager to call the ``closer`` DCNL automatically: DCNL .. code-block:: python DCNL registry = config.registry DCNL with prepare(registry) as env: DCNL request = env[\'request\'] DCNL .. versionchanged:: 1.8 DCNL Added the ability to use the return value as a context manager.'
def _make_request(path, registry=None): DCNL 'Return a :meth:`pyramid.request.Request` object anchored at a DCNL given path. The object returned will be generated from the supplied DCNL registry\'s :term:`Request Factory` using the DCNL :meth:`pyramid.interfaces.IRequestFactory.blank` method. DCNL This request object can be passed to :meth:`pyramid.scripting.get_root` DCNL or :meth:`pyramid.scripting.prepare` to initialize an application in DCNL preparation for executing a script with a proper environment setup. DCNL URLs can then be generated with the object, as well as rendering DCNL templates. DCNL If ``registry`` is not supplied, the last registry loaded from DCNL :attr:`pyramid.config.global_registries` will be used. If you have DCNL loaded more than one :app:`Pyramid` application in the current DCNL process, you may not want to use the last registry loaded, thus DCNL you can search the ``global_registries`` and supply the appropriate DCNL one based on your own criteria.'
def strings_differ(string1, string2, compare_digest=compare_digest): DCNL 'Check whether two strings differ while avoiding timing attacks. DCNL This function returns True if the given strings differ and False DCNL if they are equal.  It\'s careful not to leak information about *where* DCNL they differ as a result of its running time, which can be very important DCNL to avoid certain timing-related crypto attacks: DCNL http://seb.dbzteam.org/crypto/python-oauth-timing-hmac.pdf DCNL .. versionchanged:: 1.6 DCNL Support :func:`hmac.compare_digest` if it is available (Python 2.7.7+ DCNL and Python 3.3+).'
def object_description(object): DCNL 'Produce a human-consumable text description of ``object``, DCNL usually involving a Python dotted name. For example: DCNL >>> object_description(None) DCNL u\'None\' DCNL >>> from xml.dom import minidom DCNL >>> object_description(minidom) DCNL u\'module xml.dom.minidom\' DCNL >>> object_description(minidom.Attr) DCNL u\'class xml.dom.minidom.Attr\' DCNL >>> object_description(minidom.Attr.appendChild) DCNL u\'method appendChild of class xml.dom.minidom.Attr\' DCNL If this method cannot identify the type of the object, a generic DCNL description ala ``object <object.__name__>`` will be returned. DCNL If the object passed is already a string, it is simply returned.  If it DCNL is a boolean, an integer, a list, a tuple, a set, or ``None``, a DCNL (possibly shortened) string representation is returned.'
def viewdefaults(wrapped): DCNL 'Decorator for add_view-like methods which takes into account DCNL __view_defaults__ attached to view it is passed.  Not a documented API but DCNL used by some external systems.'
def action_method(wrapped): DCNL 'Wrapper to provide the right conflict info report data when a method DCNL that calls Configurator.action calls another that does the same.  Not a DCNL documented API but used by some external systems.'
def get_callable_name(name): DCNL 'Verifies that the ``name`` is ascii and will raise a ``ConfigurationError`` DCNL if it is not.'
@contextlib.contextmanager DCNL def hide_attrs(obj, *attrs): DCNL 'Temporarily delete object attrs and restore afterward.'
def is_same_domain(host, pattern): DCNL 'Return ``True`` if the host is either an exact match or a match DCNL to the wildcard pattern. DCNL Any pattern beginning with a period matches a domain and all of its DCNL subdomains. (e.g. ``.example.com`` matches ``example.com`` and DCNL ``foo.example.com``). Anything else is an exact string match.'
def package_name(pkg_or_module): DCNL 'If this function is passed a module, return the dotted Python DCNL package name of the package in which the module lives.  If this DCNL function is passed a package, return the dotted Python package DCNL name of the package itself.'
def package_of(pkg_or_module): DCNL 'Return the package of a module or return the package itself'
def route_view(request): DCNL ''
def global_view(request): DCNL ''
def global2_view(request): DCNL ''
def route2_view(request): DCNL ''
def exception_view(request): DCNL ''
def exception2_view(request): DCNL ''
def erroneous_view(request): DCNL ''
def erroneous_sub_view(request): DCNL ''
def rdf_view(request): DCNL ''
def juri_view(request): DCNL ''
def fixture_view(context, request): DCNL ''
def erroneous_view(context, request): DCNL ''
def exception_view(context, request): DCNL ''
def protected_view(context, request): DCNL ''
@view_config(for_=INothing) DCNL @wsgiapp DCNL def wsgiapptest(environ, start_response): DCNL ''
def default_locale_negotiator(request): DCNL 'The default :term:`locale negotiator`.  Returns a locale name DCNL or ``None``. DCNL - First, the negotiator looks for the ``_LOCALE_`` attribute of DCNL the request object (possibly set by a view or a listener for an DCNL :term:`event`). If the attribute exists and it is not ``None``, DCNL its value will be used. DCNL - Then it looks for the ``request.params[\'_LOCALE_\']`` value. DCNL - Then it looks for the ``request.cookies[\'_LOCALE_\']`` value. DCNL - Finally, the negotiator returns ``None`` if the locale could not DCNL be determined via any of the previous checks (when a locale DCNL negotiator returns ``None``, it signifies that the DCNL :term:`default locale name` should be used.)'
def negotiate_locale_name(request): DCNL 'Negotiate and return the :term:`locale name` associated with DCNL the current request.'
def get_locale_name(request): DCNL '.. deprecated:: 1.5 DCNL Use :attr:`pyramid.request.Request.locale_name` directly instead. DCNL Return the :term:`locale name` associated with the current request.'
def make_localizer(current_locale_name, translation_directories): DCNL 'Create a :class:`pyramid.i18n.Localizer` object DCNL corresponding to the provided locale name from the DCNL translations found in the list of translation directories.'
def get_localizer(request): DCNL '.. deprecated:: 1.5 DCNL Use the :attr:`pyramid.request.Request.localizer` attribute directly DCNL instead.  Retrieve a :class:`pyramid.i18n.Localizer` object DCNL corresponding to the current request\'s locale name.'
def urlencode(query, doseq=True, quote_via=quote_plus): DCNL 'An alternate implementation of Python\'s stdlib DCNL :func:`urllib.parse.urlencode` function which accepts unicode keys and DCNL values within the ``query`` dict/sequence; all Unicode keys and values are DCNL first converted to UTF-8 before being used to compose the query string. DCNL The value of ``query`` must be a sequence of two-tuples DCNL representing key/value pairs *or* an object (often a dictionary) DCNL with an ``.items()`` method that returns a sequence of two-tuples DCNL representing key/value pairs. DCNL For minimal calling convention backwards compatibility, this DCNL version of urlencode accepts *but ignores* a second argument DCNL conventionally named ``doseq``.  The Python stdlib version behaves DCNL differently when ``doseq`` is False and when a sequence is DCNL presented as one of the values.  This version always behaves in DCNL the ``doseq=True`` mode, no matter what the value of the second DCNL argument. DCNL Both the key and value are encoded using the ``quote_via`` function which DCNL by default is using a similar algorithm to :func:`urllib.parse.quote_plus` DCNL which converts spaces into \'+\' characters and \'/\' into \'%2F\'. DCNL .. versionchanged:: 1.5 DCNL In a key/value pair, if the value is ``None`` then it will be DCNL dropped from the resulting output. DCNL .. versionchanged:: 1.9 DCNL Added the ``quote_via`` argument to allow alternate quoting algorithms DCNL to be used.'
def find_root(resource): DCNL 'Find the root node in the resource tree to which ``resource`` DCNL belongs. Note that ``resource`` should be :term:`location`-aware. DCNL Note that the root resource is available in the request object by DCNL accessing the ``request.root`` attribute.'
def find_resource(resource, path): DCNL 'Given a resource object and a string or tuple representing a path DCNL (such as the return value of :func:`pyramid.traversal.resource_path` or DCNL :func:`pyramid.traversal.resource_path_tuple`), return a resource in this DCNL application\'s resource tree at the specified path.  The resource passed DCNL in *must* be :term:`location`-aware.  If the path cannot be resolved (if DCNL the respective node in the resource tree does not exist), a DCNL :exc:`KeyError` will be raised. DCNL This function is the logical inverse of DCNL :func:`pyramid.traversal.resource_path` and DCNL :func:`pyramid.traversal.resource_path_tuple`; it can resolve any DCNL path string or tuple generated by either of those functions. DCNL Rules for passing a *string* as the ``path`` argument: if the DCNL first character in the path string is the ``/`` DCNL character, the path is considered absolute and the resource tree DCNL traversal will start at the root resource.  If the first character DCNL of the path string is *not* the ``/`` character, the path is DCNL considered relative and resource tree traversal will begin at the resource DCNL object supplied to the function as the ``resource`` argument.  If an DCNL empty string is passed as ``path``, the ``resource`` passed in will DCNL be returned.  Resource path strings must be escaped in the following DCNL manner: each Unicode path segment must be encoded as UTF-8 and as DCNL each path segment must escaped via Python\'s :mod:`urllib.quote`. DCNL For example, ``/path/to%20the/La%20Pe%C3%B1a`` (absolute) or DCNL ``to%20the/La%20Pe%C3%B1a`` (relative).  The DCNL :func:`pyramid.traversal.resource_path` function generates strings DCNL which follow these rules (albeit only absolute ones). DCNL Rules for passing *text* (Unicode) as the ``path`` argument are the same DCNL as those for a string.  In particular, the text may not have any nonascii DCNL characters in it. DCNL Rules for passing a *tuple* as the ``path`` argument: if the first DCNL element in the path tuple is the empty string (for example ``(\'\', DCNL \'a\', \'b\', \'c\')``, the path is considered absolute and the resource tree DCNL traversal will start at the resource tree root object.  If the first DCNL element in the path tuple is not the empty string (for example DCNL ``(\'a\', \'b\', \'c\')``), the path is considered relative and resource tree DCNL traversal will begin at the resource object supplied to the function DCNL as the ``resource`` argument.  If an empty sequence is passed as DCNL ``path``, the ``resource`` passed in itself will be returned.  No DCNL URL-quoting or UTF-8-encoding of individual path segments within DCNL the tuple is required (each segment may be any string or unicode DCNL object representing a resource name).  Resource path tuples generated by DCNL :func:`pyramid.traversal.resource_path_tuple` can always be DCNL resolved by ``find_resource``.'
def find_interface(resource, class_or_interface): DCNL 'Return the first resource found in the :term:`lineage` of ``resource`` DCNL which, a) if ``class_or_interface`` is a Python class object, is an DCNL instance of the class or any subclass of that class or b) if DCNL ``class_or_interface`` is a :term:`interface`, provides the specified DCNL interface.  Return ``None`` if no resource providing ``interface_or_class`` DCNL can be found in the lineage.  The ``resource`` passed in *must* be DCNL :term:`location`-aware.'
def resource_path(resource, *elements): DCNL 'Return a string object representing the absolute physical path of the DCNL resource object based on its position in the resource tree, e.g DCNL ``/foo/bar``.  Any positional arguments passed in as ``elements`` will be DCNL appended as path segments to the end of the resource path.  For instance, DCNL if the resource\'s path is ``/foo/bar`` and ``elements`` equals ``(\'a\', DCNL \'b\')``, the returned string will be ``/foo/bar/a/b``.  The first DCNL character in the string will always be the ``/`` character (a leading DCNL ``/`` character in a path string represents that the path is absolute). DCNL Resource path strings returned will be escaped in the following DCNL manner: each unicode path segment will be encoded as UTF-8 and DCNL each path segment will be escaped via Python\'s :mod:`urllib.quote`. DCNL For example, ``/path/to%20the/La%20Pe%C3%B1a``. DCNL This function is a logical inverse of DCNL :mod:`pyramid.traversal.find_resource`: it can be used to generate DCNL path references that can later be resolved via that function. DCNL The ``resource`` passed in *must* be :term:`location`-aware. DCNL .. note:: DCNL Each segment in the path string returned will use the ``__name__`` DCNL attribute of the resource it represents within the resource tree.  Each DCNL of these segments *should* be a unicode or string object (as per the DCNL contract of :term:`location`-awareness).  However, no conversion or DCNL safety checking of resource names is performed.  For instance, if one of DCNL the resources in your tree has a ``__name__`` which (by error) is a DCNL dictionary, the :func:`pyramid.traversal.resource_path` function will DCNL attempt to append it to a string and it will cause a DCNL :exc:`pyramid.exceptions.URLDecodeError`. DCNL .. note:: DCNL The :term:`root` resource *must* have a ``__name__`` attribute with a DCNL value of either ``None`` or the empty string for paths to be generated DCNL properly.  If the root resource has a non-null ``__name__`` attribute, DCNL its name will be prepended to the generated path rather than a single DCNL leading \'/\' character.'
def traverse(resource, path): DCNL 'Given a resource object as ``resource`` and a string or tuple DCNL representing a path as ``path`` (such as the return value of DCNL :func:`pyramid.traversal.resource_path` or DCNL :func:`pyramid.traversal.resource_path_tuple` or the value of DCNL ``request.environ[\'PATH_INFO\']``), return a dictionary with the DCNL keys ``context``, ``root``, ``view_name``, ``subpath``, DCNL ``traversed``, ``virtual_root``, and ``virtual_root_path``. DCNL A definition of each value in the returned dictionary: DCNL - ``context``: The :term:`context` (a :term:`resource` object) found DCNL via traversal or url dispatch.  If the ``path`` passed in is the DCNL empty string, the value of the ``resource`` argument passed to this DCNL function is returned. DCNL - ``root``: The resource object at which :term:`traversal` begins. DCNL If the ``resource`` passed in was found via url dispatch or if the DCNL ``path`` passed in was relative (non-absolute), the value of the DCNL ``resource`` argument passed to this function is returned. DCNL - ``view_name``: The :term:`view name` found during DCNL :term:`traversal` or :term:`url dispatch`; if the ``resource`` was DCNL found via traversal, this is usually a representation of the DCNL path segment which directly follows the path to the ``context`` DCNL in the ``path``.  The ``view_name`` will be a Unicode object or DCNL the empty string.  The ``view_name`` will be the empty string if DCNL there is no element which follows the ``context`` path.  An DCNL example: if the path passed is ``/foo/bar``, and a resource DCNL object is found at ``/foo`` (but not at ``/foo/bar``), the \'view DCNL name\' will be ``u\'bar\'``.  If the ``resource`` was found via DCNL urldispatch, the view_name will be the name the route found was DCNL registered with. DCNL - ``subpath``: For a ``resource`` found via :term:`traversal`, this DCNL is a sequence of path segments found in the ``path`` that follow DCNL the ``view_name`` (if any).  Each of these items is a Unicode DCNL object.  If no path segments follow the ``view_name``, the DCNL subpath will be the empty sequence.  An example: if the path DCNL passed is ``/foo/bar/baz/buz``, and a resource object is found at DCNL ``/foo`` (but not ``/foo/bar``), the \'view name\' will be DCNL ``u\'bar\'`` and the :term:`subpath` will be ``[u\'baz\', u\'buz\']``. DCNL For a ``resource`` found via url dispatch, the subpath will be a DCNL sequence of values discerned from ``*subpath`` in the route DCNL pattern matched or the empty sequence. DCNL - ``traversed``: The sequence of path elements traversed from the DCNL root to find the ``context`` object during :term:`traversal`. DCNL Each of these items is a Unicode object.  If no path segments DCNL were traversed to find the ``context`` object (e.g. if the DCNL ``path`` provided is the empty string), the ``traversed`` value DCNL will be the empty sequence.  If the ``resource`` is a resource found DCNL via :term:`url dispatch`, traversed will be None. DCNL - ``virtual_root``: A resource object representing the \'virtual\' root DCNL of the resource tree being traversed during :term:`traversal`. DCNL See :ref:`vhosting_chapter` for a definition of the virtual root DCNL object.  If no virtual hosting is in effect, and the ``path`` DCNL passed in was absolute, the ``virtual_root`` will be the DCNL *physical* root resource object (the object at which :term:`traversal` DCNL begins).  If the ``resource`` passed in was found via :term:`URL DCNL dispatch` or if the ``path`` passed in was relative, the DCNL ``virtual_root`` will always equal the ``root`` object (the DCNL resource passed in). DCNL - ``virtual_root_path`` -- If :term:`traversal` was used to find DCNL the ``resource``, this will be the sequence of path elements DCNL traversed to find the ``virtual_root`` resource.  Each of these DCNL items is a Unicode object.  If no path segments were traversed DCNL to find the ``virtual_root`` resource (e.g. if virtual hosting is DCNL not in effect), the ``traversed`` value will be the empty list. DCNL If url dispatch was used to find the ``resource``, this will be DCNL ``None``. DCNL If the path cannot be resolved, a :exc:`KeyError` will be raised. DCNL Rules for passing a *string* as the ``path`` argument: if the DCNL first character in the path string is the with the ``/`` DCNL character, the path will considered absolute and the resource tree DCNL traversal will start at the root resource.  If the first character DCNL of the path string is *not* the ``/`` character, the path is DCNL considered relative and resource tree traversal will begin at the resource DCNL object supplied to the function as the ``resource`` argument.  If an DCNL empty string is passed as ``path``, the ``resource`` passed in will DCNL be returned.  Resource path strings must be escaped in the following DCNL manner: each Unicode path segment must be encoded as UTF-8 and DCNL each path segment must escaped via Python\'s :mod:`urllib.quote`. DCNL For example, ``/path/to%20the/La%20Pe%C3%B1a`` (absolute) or DCNL ``to%20the/La%20Pe%C3%B1a`` (relative).  The DCNL :func:`pyramid.traversal.resource_path` function generates strings DCNL which follow these rules (albeit only absolute ones). DCNL Rules for passing a *tuple* as the ``path`` argument: if the first DCNL element in the path tuple is the empty string (for example ``(\'\', DCNL \'a\', \'b\', \'c\')``, the path is considered absolute and the resource tree DCNL traversal will start at the resource tree root object.  If the first DCNL element in the path tuple is not the empty string (for example DCNL ``(\'a\', \'b\', \'c\')``), the path is considered relative and resource tree DCNL traversal will begin at the resource object supplied to the function DCNL as the ``resource`` argument.  If an empty sequence is passed as DCNL ``path``, the ``resource`` passed in itself will be returned.  No DCNL URL-quoting or UTF-8-encoding of individual path segments within DCNL the tuple is required (each segment may be any string or unicode DCNL object representing a resource name). DCNL Explanation of the conversion of ``path`` segment values to DCNL Unicode during traversal: Each segment is URL-unquoted, and DCNL decoded into Unicode. Each segment is assumed to be encoded using DCNL the UTF-8 encoding (or a subset, such as ASCII); a DCNL :exc:`pyramid.exceptions.URLDecodeError` is raised if a segment DCNL cannot be decoded.  If a segment name is empty or if it is ``.``, DCNL it is ignored.  If a segment name is ``..``, the previous segment DCNL is deleted, and the ``..`` is ignored.  As a result of this DCNL process, the return values ``view_name``, each element in the DCNL ``subpath``, each element in ``traversed``, and each element in DCNL the ``virtual_root_path`` will be Unicode as opposed to a string, DCNL and will be URL-decoded.'
def resource_path_tuple(resource, *elements): DCNL 'Return a tuple representing the absolute physical path of the DCNL ``resource`` object based on its position in a resource tree, e.g DCNL ``(\'\', \'foo\', \'bar\')``.  Any positional arguments passed in as DCNL ``elements`` will be appended as elements in the tuple DCNL representing the resource path.  For instance, if the resource\'s DCNL path is ``(\'\', \'foo\', \'bar\')`` and elements equals ``(\'a\', \'b\')``, DCNL the returned tuple will be ``(\'\', \'foo\', \'bar\', \'a\', \'b\')``.  The DCNL first element of this tuple will always be the empty string (a DCNL leading empty string element in a path tuple represents that the DCNL path is absolute). DCNL This function is a logical inverse of DCNL :func:`pyramid.traversal.find_resource`: it can be used to DCNL generate path references that can later be resolved by that function. DCNL The ``resource`` passed in *must* be :term:`location`-aware. DCNL .. note:: DCNL Each segment in the path tuple returned will equal the ``__name__`` DCNL attribute of the resource it represents within the resource tree.  Each DCNL of these segments *should* be a unicode or string object (as per the DCNL contract of :term:`location`-awareness).  However, no conversion or DCNL safety checking of resource names is performed.  For instance, if one of DCNL the resources in your tree has a ``__name__`` which (by error) is a DCNL dictionary, that dictionary will be placed in the path tuple; no warning DCNL or error will be given. DCNL .. note:: DCNL The :term:`root` resource *must* have a ``__name__`` attribute with a DCNL value of either ``None`` or the empty string for path tuples to be DCNL generated properly.  If the root resource has a non-null ``__name__`` DCNL attribute, its name will be the first element in the generated path tuple DCNL rather than the empty string.'
def _resource_path_list(resource, *elements): DCNL 'Implementation detail shared by resource_path and resource_path_tuple'
def virtual_root(resource, request): DCNL 'Provided any :term:`resource` and a :term:`request` object, return DCNL the resource object representing the :term:`virtual root` of the DCNL current :term:`request`.  Using a virtual root in a DCNL :term:`traversal` -based :app:`Pyramid` application permits DCNL rooting. For example, the resource at the traversal path ``/cms`` will DCNL be found at ``http://example.com/`` instead of rooting it at DCNL ``http://example.com/cms/``. DCNL If the ``resource`` passed in is a context obtained via DCNL :term:`traversal`, and if the ``HTTP_X_VHM_ROOT`` key is in the DCNL WSGI environment, the value of this key will be treated as a DCNL \'virtual root path\': the :func:`pyramid.traversal.find_resource` DCNL API will be used to find the virtual root resource using this path; DCNL if the resource is found, it will be returned.  If the DCNL ``HTTP_X_VHM_ROOT`` key is not present in the WSGI environment, DCNL the physical :term:`root` of the resource tree will be returned instead. DCNL Virtual roots are not useful at all in applications that use DCNL :term:`URL dispatch`. Contexts obtained via URL dispatch don\'t DCNL really support being virtually rooted (each URL dispatch context DCNL is both its own physical and virtual root).  However if this API DCNL is called with a ``resource`` argument which is a context obtained DCNL via URL dispatch, the resource passed in will be returned DCNL unconditionally.'
def traversal_path(path): DCNL 'Variant of :func:`pyramid.traversal.traversal_path_info` suitable for DCNL decoding paths that are URL-encoded. DCNL If this function is passed a Unicode object instead of a sequence of DCNL bytes as ``path``, that Unicode object *must* directly encodeable to DCNL ASCII.  For example, u\'/foo\' will work but u\'/<unprintable unicode>\' (a DCNL Unicode object with characters that cannot be encoded to ascii) will DCNL not. A :exc:`UnicodeEncodeError` will be raised if the Unicode cannot be DCNL encoded directly to ASCII.'
@lru_cache(1000) DCNL def traversal_path_info(path): DCNL 'Given``path``, return a tuple representing that path which can be DCNL used to traverse a resource tree.  ``path`` is assumed to be an DCNL already-URL-decoded ``str`` type as if it had come to us from an upstream DCNL WSGI server as the ``PATH_INFO`` environ variable. DCNL The ``path`` is first decoded to from its WSGI representation to Unicode; DCNL it is decoded differently depending on platform: DCNL - On Python 2, ``path`` is decoded to Unicode from bytes using the UTF-8 DCNL decoding directly; a :exc:`pyramid.exc.URLDecodeError` is raised if a the DCNL URL cannot be decoded. DCNL - On Python 3, as per the PEP 3333 spec, ``path`` is first encoded to DCNL bytes using the Latin-1 encoding; the resulting set of bytes is DCNL subsequently decoded to text using the UTF-8 encoding; a DCNL :exc:`pyramid.exc.URLDecodeError` is raised if a the URL cannot be DCNL decoded. DCNL The ``path`` is split on slashes, creating a list of segments.  If a DCNL segment name is empty or if it is ``.``, it is ignored.  If a segment DCNL name is ``..``, the previous segment is deleted, and the ``..`` is DCNL ignored. DCNL Examples: DCNL ``/foo/bar/baz`` DCNL (u\'foo\', u\'bar\', u\'baz\') DCNL ``foo/bar/baz`` DCNL (u\'foo\', u\'bar\', u\'baz\') DCNL ``/foo/bar/baz/`` DCNL (u\'foo\', u\'bar\', u\'baz\') DCNL ``/foo//bar//baz/`` DCNL (u\'foo\', u\'bar\', u\'baz\') DCNL ``/foo/bar/baz/..`` DCNL (u\'foo\', u\'bar\') DCNL ``/my%20archives/hello`` DCNL (u\'my archives\', u\'hello\') DCNL ``/archives/La%20Pe%C3%B1a`` DCNL (u\'archives\', u\'<unprintable unicode>\') DCNL .. note:: DCNL This function does not generate the same type of tuples that DCNL :func:`pyramid.traversal.resource_path_tuple` does.  In particular, the DCNL leading empty string is not present in the tuple it returns, unlike tuples DCNL returned by :func:`pyramid.traversal.resource_path_tuple`.  As a result, DCNL tuples generated by ``traversal_path`` are not resolveable by the DCNL :func:`pyramid.traversal.find_resource` API.  ``traversal_path`` is a DCNL function mostly used by the internals of :app:`Pyramid` and by people DCNL writing their own traversal machinery, as opposed to users writing DCNL applications in :app:`Pyramid`.'
def resolveConflicts(actions, state=None): DCNL 'Resolve conflicting actions DCNL Given an actions list, identify and try to resolve conflicting actions. DCNL Actions conflict if they have the same non-None discriminator. DCNL Conflicting actions can be resolved if the include path of one of DCNL the actions is a prefix of the includepaths of the other DCNL conflicting actions and is unequal to the include paths in the DCNL other conflicting actions. DCNL Actions are resolved on a per-order basis because some discriminators DCNL cannot be computed until earlier actions have executed. An action in an DCNL earlier order may execute successfully only to find out later that it was DCNL overridden by another action with a smaller include path. This will result DCNL in a conflict as there is no way to revert the original action. DCNL ``state`` may be an instance of ``ConflictResolverState`` that DCNL can be used to resume execution and resolve the new actions against the DCNL list of executed actions from a previous call.'
def normalize_actions(actions): DCNL 'Convert old-style tuple actions to new-style dicts.'
def Settings(d=None, _environ_=os.environ, **kw): DCNL 'Deployment settings.  Update application settings (usually DCNL from PasteDeploy keywords) with framework-specific key/value pairs DCNL (e.g. find ``PYRAMID_DEBUG_AUTHORIZATION`` in os.environ and jam into DCNL keyword args).'
def asbool(s): DCNL 'Return the boolean value ``True`` if the case-lowered value of string DCNL input ``s`` is a :term:`truthy string`. If ``s`` is already one of the DCNL boolean values ``True`` or ``False``, return it.'
def aslist(value, flatten=True): DCNL 'Return a list of strings, separating the input based on newlines DCNL and, if flatten=True (the default), also split on spaces within DCNL each line.'
def manage_accessed(wrapped): DCNL 'Decorator which causes a cookie to be renewed when an accessor DCNL method is called.'
def manage_changed(wrapped): DCNL 'Decorator which causes a cookie to be set when a setter method DCNL is called.'
def signed_serialize(data, secret): DCNL 'Serialize any pickleable structure (``data``) and sign it DCNL using the ``secret`` (must be a string).  Return the DCNL serialization, which includes the signature as its first 40 bytes. DCNL The ``signed_deserialize`` method will deserialize such a value. DCNL This function is useful for creating signed cookies.  For example: DCNL .. code-block:: python DCNL cookieval = signed_serialize({\'a\':1}, \'secret\') DCNL response.set_cookie(\'signed_cookie\', cookieval)'
def signed_deserialize(serialized, secret, hmac=hmac): DCNL 'Deserialize the value returned from ``signed_serialize``.  If DCNL the value cannot be deserialized for any reason, a DCNL :exc:`ValueError` exception will be raised. DCNL This function is useful for deserializing a signed cookie value DCNL created by ``signed_serialize``.  For example: DCNL .. code-block:: python DCNL cookieval = request.cookies[\'signed_cookie\'] DCNL data = signed_deserialize(cookieval, \'secret\')'
def BaseCookieSessionFactory(serializer, cookie_name='session', max_age=None, path='/', domain=None, secure=False, httponly=False, timeout=1200, reissue_time=0, set_on_exception=True): DCNL '.. versionadded:: 1.5 DCNL Configure a :term:`session factory` which will provide cookie-based DCNL sessions.  The return value of this function is a :term:`session factory`, DCNL which may be provided as the ``session_factory`` argument of a DCNL :class:`pyramid.config.Configurator` constructor, or used as the DCNL ``session_factory`` argument of the DCNL :meth:`pyramid.config.Configurator.set_session_factory` method. DCNL The session factory returned by this function will create sessions DCNL which are limited to storing fewer than 4000 bytes of data (as the DCNL payload must fit into a single cookie). DCNL .. warning: DCNL This class provides no protection from tampering and is only intended DCNL to be used by framework authors to create their own cookie-based DCNL session factories. DCNL Parameters: DCNL ``serializer`` DCNL An object with two methods: ``loads`` and ``dumps``.  The ``loads`` DCNL method should accept bytes and return a Python object.  The ``dumps`` DCNL method should accept a Python object and return bytes.  A ``ValueError`` DCNL should be raised for malformed inputs. DCNL ``cookie_name`` DCNL The name of the cookie used for sessioning. Default: ``\'session\'``. DCNL ``max_age`` DCNL The maximum age of the cookie used for sessioning (in seconds). DCNL Default: ``None`` (browser scope). DCNL ``path`` DCNL The path used for the session cookie. Default: ``\'/\'``. DCNL ``domain`` DCNL The domain used for the session cookie.  Default: ``None`` (no domain). DCNL ``secure`` DCNL The \'secure\' flag of the session cookie. Default: ``False``. DCNL ``httponly`` DCNL Hide the cookie from Javascript by setting the \'HttpOnly\' flag of the DCNL session cookie. Default: ``False``. DCNL ``timeout`` DCNL A number of seconds of inactivity before a session times out. If DCNL ``None`` then the cookie never expires. This lifetime only applies DCNL to the *value* within the cookie. Meaning that if the cookie expires DCNL due to a lower ``max_age``, then this setting has no effect. DCNL Default: ``1200``. DCNL ``reissue_time`` DCNL The number of seconds that must pass before the cookie is automatically DCNL reissued as the result of a request which accesses the session. The DCNL duration is measured as the number of seconds since the last session DCNL cookie was issued and \'now\'.  If this value is ``0``, a new cookie DCNL will be reissued on every request accessing the session. If ``None`` DCNL then the cookie\'s lifetime will never be extended. DCNL A good rule of thumb: if you want auto-expired cookies based on DCNL inactivity: set the ``timeout`` value to 1200 (20 mins) and set the DCNL ``reissue_time`` value to perhaps a tenth of the ``timeout`` value DCNL (120 or 2 mins).  It\'s nonsensical to set the ``timeout`` value lower DCNL than the ``reissue_time`` value, as the ticket will never be reissued. DCNL However, such a configuration is not explicitly prevented. DCNL Default: ``0``. DCNL ``set_on_exception`` DCNL If ``True``, set a session cookie even if an exception occurs DCNL while rendering a view. Default: ``True``. DCNL .. versionadded: 1.5a3'
def UnencryptedCookieSessionFactoryConfig(secret, timeout=1200, cookie_name='session', cookie_max_age=None, cookie_path='/', cookie_domain=None, cookie_secure=False, cookie_httponly=False, cookie_on_exception=True, signed_serialize=signed_serialize, signed_deserialize=signed_deserialize): DCNL '.. deprecated:: 1.5 DCNL Use :func:`pyramid.session.SignedCookieSessionFactory` instead. DCNL Caveat: Cookies generated using ``SignedCookieSessionFactory`` are not DCNL compatible with cookies generated using DCNL ``UnencryptedCookieSessionFactory``, so existing user session data DCNL will be destroyed if you switch to it. DCNL Configure a :term:`session factory` which will provide unencrypted DCNL (but signed) cookie-based sessions.  The return value of this DCNL function is a :term:`session factory`, which may be provided as DCNL the ``session_factory`` argument of a DCNL :class:`pyramid.config.Configurator` constructor, or used DCNL as the ``session_factory`` argument of the DCNL :meth:`pyramid.config.Configurator.set_session_factory` DCNL method. DCNL The session factory returned by this function will create sessions DCNL which are limited to storing fewer than 4000 bytes of data (as the DCNL payload must fit into a single cookie). DCNL Parameters: DCNL ``secret`` DCNL A string which is used to sign the cookie. DCNL ``timeout`` DCNL A number of seconds of inactivity before a session times out. DCNL ``cookie_name`` DCNL The name of the cookie used for sessioning. DCNL ``cookie_max_age`` DCNL The maximum age of the cookie used for sessioning (in seconds). DCNL Default: ``None`` (browser scope). DCNL ``cookie_path`` DCNL The path used for the session cookie. DCNL ``cookie_domain`` DCNL The domain used for the session cookie.  Default: ``None`` (no domain). DCNL ``cookie_secure`` DCNL The \'secure\' flag of the session cookie. DCNL ``cookie_httponly`` DCNL The \'httpOnly\' flag of the session cookie. DCNL ``cookie_on_exception`` DCNL If ``True``, set a session cookie even if an exception occurs DCNL while rendering a view. DCNL ``signed_serialize`` DCNL A callable which takes more or less arbitrary Python data structure and DCNL a secret and returns a signed serialization in bytes. DCNL Default: ``signed_serialize`` (using pickle). DCNL ``signed_deserialize`` DCNL A callable which takes a signed and serialized data structure in bytes DCNL and a secret and returns the original data structure if the signature DCNL is valid. Default: ``signed_deserialize`` (using pickle).'
def SignedCookieSessionFactory(secret, cookie_name='session', max_age=None, path='/', domain=None, secure=False, httponly=False, set_on_exception=True, timeout=1200, reissue_time=0, hashalg='sha512', salt='pyramid.session.', serializer=None): DCNL '.. versionadded:: 1.5 DCNL Configure a :term:`session factory` which will provide signed DCNL cookie-based sessions.  The return value of this DCNL function is a :term:`session factory`, which may be provided as DCNL the ``session_factory`` argument of a DCNL :class:`pyramid.config.Configurator` constructor, or used DCNL as the ``session_factory`` argument of the DCNL :meth:`pyramid.config.Configurator.set_session_factory` DCNL method. DCNL The session factory returned by this function will create sessions DCNL which are limited to storing fewer than 4000 bytes of data (as the DCNL payload must fit into a single cookie). DCNL Parameters: DCNL ``secret`` DCNL A string which is used to sign the cookie. The secret should be at DCNL least as long as the block size of the selected hash algorithm. For DCNL ``sha512`` this would mean a 128 bit (64 character) secret.  It should DCNL be unique within the set of secret values provided to Pyramid for DCNL its various subsystems (see :ref:`admonishment_against_secret_sharing`). DCNL ``hashalg`` DCNL The HMAC digest algorithm to use for signing. The algorithm must be DCNL supported by the :mod:`hashlib` library. Default: ``\'sha512\'``. DCNL ``salt`` DCNL A namespace to avoid collisions between different uses of a shared DCNL secret. Reusing a secret for different parts of an application is DCNL strongly discouraged (see :ref:`admonishment_against_secret_sharing`). DCNL Default: ``\'pyramid.session.\'``. DCNL ``cookie_name`` DCNL The name of the cookie used for sessioning. Default: ``\'session\'``. DCNL ``max_age`` DCNL The maximum age of the cookie used for sessioning (in seconds). DCNL Default: ``None`` (browser scope). DCNL ``path`` DCNL The path used for the session cookie. Default: ``\'/\'``. DCNL ``domain`` DCNL The domain used for the session cookie.  Default: ``None`` (no domain). DCNL ``secure`` DCNL The \'secure\' flag of the session cookie. Default: ``False``. DCNL ``httponly`` DCNL Hide the cookie from Javascript by setting the \'HttpOnly\' flag of the DCNL session cookie. Default: ``False``. DCNL ``timeout`` DCNL A number of seconds of inactivity before a session times out. If DCNL ``None`` then the cookie never expires. This lifetime only applies DCNL to the *value* within the cookie. Meaning that if the cookie expires DCNL due to a lower ``max_age``, then this setting has no effect. DCNL Default: ``1200``. DCNL ``reissue_time`` DCNL The number of seconds that must pass before the cookie is automatically DCNL reissued as the result of accessing the session. The DCNL duration is measured as the number of seconds since the last session DCNL cookie was issued and \'now\'.  If this value is ``0``, a new cookie DCNL will be reissued on every request accessing the session. If ``None`` DCNL then the cookie\'s lifetime will never be extended. DCNL A good rule of thumb: if you want auto-expired cookies based on DCNL inactivity: set the ``timeout`` value to 1200 (20 mins) and set the DCNL ``reissue_time`` value to perhaps a tenth of the ``timeout`` value DCNL (120 or 2 mins).  It\'s nonsensical to set the ``timeout`` value lower DCNL than the ``reissue_time`` value, as the ticket will never be reissued. DCNL However, such a configuration is not explicitly prevented. DCNL Default: ``0``. DCNL ``set_on_exception`` DCNL If ``True``, set a session cookie even if an exception occurs DCNL while rendering a view. Default: ``True``. DCNL ``serializer`` DCNL An object with two methods: ``loads`` and ``dumps``.  The ``loads`` DCNL method should accept bytes and return a Python object.  The ``dumps`` DCNL method should accept a Python object and return bytes.  A ``ValueError`` DCNL should be raised for malformed inputs.  If a serializer is not passed, DCNL the :class:`pyramid.session.PickleSerializer` serializer will be used. DCNL .. versionadded: 1.5a3'
def setUp(registry=None, request=None, hook_zca=True, autocommit=True, settings=None, package=None): DCNL 'Set :app:`Pyramid` registry and request thread locals for the DCNL duration of a single unit test. DCNL Use this function in the ``setUp`` method of a unittest test case DCNL which directly or indirectly uses: DCNL - any method of the :class:`pyramid.config.Configurator` DCNL object returned by this function. DCNL - the :func:`pyramid.threadlocal.get_current_registry` or DCNL :func:`pyramid.threadlocal.get_current_request` functions. DCNL If you use the ``get_current_*`` functions (or call :app:`Pyramid` code DCNL that uses these functions) without calling ``setUp``, DCNL :func:`pyramid.threadlocal.get_current_registry` will return a *global* DCNL :term:`application registry`, which may cause unit tests to not be DCNL isolated with respect to registrations they perform. DCNL If the ``registry`` argument is ``None``, a new empty DCNL :term:`application registry` will be created (an instance of the DCNL :class:`pyramid.registry.Registry` class).  If the ``registry`` DCNL argument is not ``None``, the value passed in should be an DCNL instance of the :class:`pyramid.registry.Registry` class or a DCNL suitable testing analogue. DCNL After ``setUp`` is finished, the registry returned by the DCNL :func:`pyramid.threadlocal.get_current_registry` function will DCNL be the passed (or constructed) registry until DCNL :func:`pyramid.testing.tearDown` is called (or DCNL :func:`pyramid.testing.setUp` is called again) . DCNL If the ``hook_zca`` argument is ``True``, ``setUp`` will attempt DCNL to perform the operation ``zope.component.getSiteManager.sethook( DCNL pyramid.threadlocal.get_current_registry)``, which will cause DCNL the :term:`Zope Component Architecture` global API DCNL (e.g. :func:`zope.component.getSiteManager`, DCNL :func:`zope.component.getAdapter`, and so on) to use the registry DCNL constructed by ``setUp`` as the value it returns from DCNL :func:`zope.component.getSiteManager`.  If the DCNL :mod:`zope.component` package cannot be imported, or if DCNL ``hook_zca`` is ``False``, the hook will not be set. DCNL If ``settings`` is not ``None``, it must be a dictionary representing the DCNL values passed to a Configurator as its ``settings=`` argument. DCNL If ``package`` is ``None`` it will be set to the caller\'s package. The DCNL ``package`` setting in the :class:`pyramid.config.Configurator` will DCNL affect any relative imports made via DCNL :meth:`pyramid.config.Configurator.include` or DCNL :meth:`pyramid.config.Configurator.maybe_dotted`. DCNL This function returns an instance of the DCNL :class:`pyramid.config.Configurator` class, which can be DCNL used for further configuration to set up an environment suitable DCNL for a unit or integration test.  The ``registry`` attribute DCNL attached to the Configurator instance represents the \'current\' DCNL :term:`application registry`; the same registry will be returned DCNL by :func:`pyramid.threadlocal.get_current_registry` during the DCNL execution of the test.'
def tearDown(unhook_zca=True): DCNL 'Undo the effects of :func:`pyramid.testing.setUp`.  Use this DCNL function in the ``tearDown`` method of a unit test that uses DCNL :func:`pyramid.testing.setUp` in its ``setUp`` method. DCNL If the ``unhook_zca`` argument is ``True`` (the default), call DCNL :func:`zope.component.getSiteManager.reset`.  This undoes the DCNL action of :func:`pyramid.testing.setUp` when called with the DCNL argument ``hook_zca=True``.  If :mod:`zope.component` cannot be DCNL imported, ``unhook_zca`` is set to ``False``.'
def cleanUp(*arg, **kw): DCNL 'An alias for :func:`pyramid.testing.setUp`.'
@contextmanager DCNL def testConfig(registry=None, request=None, hook_zca=True, autocommit=True, settings=None): DCNL 'Returns a context manager for test set up. DCNL This context manager calls :func:`pyramid.testing.setUp` when DCNL entering and :func:`pyramid.testing.tearDown` when exiting. DCNL All arguments are passed directly to :func:`pyramid.testing.setUp`. DCNL If the ZCA is hooked, it will always be un-hooked in tearDown. DCNL This context manager allows you to write test code like this: DCNL .. code-block:: python DCNL :linenos: DCNL with testConfig() as config: DCNL config.add_route(\'bar\', \'/bar/{id}\') DCNL req = DummyRequest() DCNL resp = myview(req),'
def parse_vars(args): DCNL 'Given variables like ``[\'a=b\', \'c=d\']`` turns it into ``{\'a\': DCNL \'b\', \'c\': \'d\'}``'
def get_config_loader(config_uri): DCNL 'Find a ``plaster.ILoader`` object supporting the "wsgi" protocol.'
def cherrypy_server_runner(app, global_conf=None, host='127.0.0.1', port=None, ssl_pem=None, protocol_version=None, numthreads=None, server_name=None, max=None, request_queue_size=None, timeout=None): DCNL 'Entry point for CherryPy\'s WSGI server DCNL Serves the specified WSGI app via CherryPyWSGIServer. DCNL ``app`` DCNL The WSGI \'application callable\'; multiple WSGI applications DCNL may be passed as (script_name, callable) pairs. DCNL ``host`` DCNL This is the ipaddress to bind to (or a hostname if your DCNL nameserver is properly configured).  This defaults to DCNL 127.0.0.1, which is not a public interface. DCNL ``port`` DCNL The port to run on, defaults to 8080 for HTTP, or 4443 for DCNL HTTPS. This can be a string or an integer value. DCNL ``ssl_pem`` DCNL This an optional SSL certificate file (via OpenSSL) You can DCNL generate a self-signed test PEM certificate file as follows: DCNL $ openssl genrsa 1024 > host.key DCNL $ chmod 400 host.key DCNL $ openssl req -new -x509 -nodes -sha1 -days 365  \ DCNL -key host.key > host.cert DCNL $ cat host.cert host.key > host.pem DCNL $ chmod 400 host.pem DCNL ``protocol_version`` DCNL The protocol used by the server, by default ``HTTP/1.1``. DCNL ``numthreads`` DCNL The number of worker threads to create. DCNL ``server_name`` DCNL The string to set for WSGI\'s SERVER_NAME environ entry. DCNL ``max`` DCNL The maximum number of queued requests. (defaults to -1 = no DCNL limit). DCNL ``request_queue_size`` DCNL The \'backlog\' argument to socket.listen(); specifies the DCNL maximum number of queued connections. DCNL ``timeout`` DCNL The timeout in seconds for accepted connections.'
def inside(resource1, resource2): DCNL 'Is ``resource1`` \'inside\' ``resource2``?  Return ``True`` if so, else DCNL ``False``. DCNL ``resource1`` is \'inside\' ``resource2`` if ``resource2`` is a DCNL :term:`lineage` ancestor of ``resource1``.  It is a lineage ancestor DCNL if its parent (or one of its parent\'s parents, etc.) is an DCNL ancestor.'
def lineage(resource): DCNL 'Return a generator representing the :term:`lineage` of the DCNL :term:`resource` object implied by the ``resource`` argument.  The DCNL generator first returns ``resource`` unconditionally.  Then, if DCNL ``resource`` supplies a ``__parent__`` attribute, return the resource DCNL represented by ``resource.__parent__``.  If *that* resource has a DCNL ``__parent__`` attribute, return that resource\'s parent, and so on, DCNL until the resource being inspected either has no ``__parent__`` DCNL attribute or which has a ``__parent__`` attribute of ``None``. DCNL For example, if the resource tree is:: DCNL thing1 = Thing() DCNL thing2 = Thing() DCNL thing2.__parent__ = thing1 DCNL Calling ``lineage(thing2)`` will return a generator.  When we turn DCNL it into a list, we will get:: DCNL list(lineage(thing2)) DCNL [ <Thing object at thing2>, <Thing object at thing1> ]'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def copy_dir(source, dest, vars, verbosity, simulate, indent=0, sub_vars=True, interactive=False, overwrite=True, template_renderer=None, out_=sys.stdout): DCNL 'Copies the ``source`` directory to the ``dest`` directory. DCNL ``vars``: A dictionary of variables to use in any substitutions. DCNL ``verbosity``: Higher numbers will show more about what is happening. DCNL ``simulate``: If true, then don\'t actually *do* anything. DCNL ``indent``: Indent any messages by this amount. DCNL ``sub_vars``: If true, variables in ``_tmpl`` files and ``+var+`` DCNL in filenames will be substituted. DCNL ``overwrite``: If false, then don\'t every overwrite anything. DCNL ``interactive``: If you are overwriting a file and interactive is DCNL true, then ask before overwriting. DCNL ``template_renderer``: This is a function for rendering templates (if you DCNL don\'t want to use string.Template).  It should have the signature DCNL ``template_renderer(content_as_string, vars_as_dict, DCNL filename=filename)``.'
def should_skip_file(name): DCNL 'Checks if a file should be skipped based on its name. DCNL If it should be skipped, returns the reason, otherwise returns DCNL None.'
def skip_template(condition=True, *args): DCNL 'Raise SkipTemplate, which causes copydir to skip the template DCNL being processed.  If you pass in a condition, only raise if that DCNL condition is true (allows you to use this with string.Template) DCNL If you pass any additional arguments, they will be used to DCNL instantiate SkipTemplate (generally use like DCNL ``skip_template(license==\'GPL\', \'Skipping file; not using GPL\')``)'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def wsgiapp(wrapped): DCNL 'Decorator to turn a WSGI application into a :app:`Pyramid` DCNL :term:`view callable`.  This decorator differs from the DCNL :func:`pyramid.wsgi.wsgiapp2` decorator inasmuch as fixups of DCNL ``PATH_INFO`` and ``SCRIPT_NAME`` within the WSGI environment *are DCNL not* performed before the application is invoked. DCNL E.g., the following in a ``views.py`` module:: DCNL @wsgiapp DCNL def hello_world(environ, start_response): DCNL body = \'Hello world\' DCNL start_response(\'200 OK\', [ (\'Content-Type\', \'text/plain\'), DCNL (\'Content-Length\', len(body)) ] ) DCNL return [body] DCNL Allows the following call to DCNL :meth:`pyramid.config.Configurator.add_view`:: DCNL from views import hello_world DCNL config.add_view(hello_world, name=\'hello_world.txt\') DCNL The ``wsgiapp`` decorator will convert the result of the WSGI DCNL application to a :term:`Response` and return it to DCNL :app:`Pyramid` as if the WSGI app were a :app:`Pyramid` DCNL view.'
def wsgiapp2(wrapped): DCNL 'Decorator to turn a WSGI application into a :app:`Pyramid` DCNL view callable.  This decorator differs from the DCNL :func:`pyramid.wsgi.wsgiapp` decorator inasmuch as fixups of DCNL ``PATH_INFO`` and ``SCRIPT_NAME`` within the WSGI environment DCNL *are* performed before the application is invoked. DCNL E.g. the following in a ``views.py`` module:: DCNL @wsgiapp2 DCNL def hello_world(environ, start_response): DCNL body = \'Hello world\' DCNL start_response(\'200 OK\', [ (\'Content-Type\', \'text/plain\'), DCNL (\'Content-Length\', len(body)) ] ) DCNL return [body] DCNL Allows the following call to DCNL :meth:`pyramid.config.Configurator.add_view`:: DCNL from views import hello_world DCNL config.add_view(hello_world, name=\'hello_world.txt\') DCNL The ``wsgiapp2`` decorator will convert the result of the WSGI DCNL application to a Response and return it to :app:`Pyramid` as if the WSGI DCNL app were a :app:`Pyramid` view.  The ``SCRIPT_NAME`` and ``PATH_INFO`` DCNL values present in the WSGI environment are fixed up before the DCNL application is invoked.  In particular, a new WSGI environment is DCNL generated, and the :term:`subpath` of the request passed to ``wsgiapp2`` DCNL is used as the new request\'s ``PATH_INFO`` and everything preceding the DCNL subpath is used as the ``SCRIPT_NAME``.  The new environment is passed to DCNL the downstream WSGI application.'
def setup_logging(config_uri, global_conf=None): DCNL 'Set up Python logging with the filename specified via ``config_uri`` DCNL (a string in the form ``filename#sectionname``). DCNL Extra defaults can optionally be specified as a dict in ``global_conf``.'
def get_app(config_uri, name=None, options=None): DCNL 'Return the WSGI application named ``name`` in the PasteDeploy DCNL config file specified by ``config_uri``. DCNL ``options``, if passed, should be a dictionary used as variable assignments DCNL like ``{\'http_port\': 8080}``.  This is useful if e.g. ``%(http_port)s`` is DCNL used in the config file. DCNL If the ``name`` is None, this will attempt to parse the name from DCNL the ``config_uri`` string expecting the format ``inifile#name``. DCNL If no name is found, the name will default to "main".'
def get_appsettings(config_uri, name=None, options=None): DCNL 'Return a dictionary representing the key/value pairs in an ``app`` DCNL section within the file represented by ``config_uri``. DCNL ``options``, if passed, should be a dictionary used as variable assignments DCNL like ``{\'http_port\': 8080}``.  This is useful if e.g. ``%(http_port)s`` is DCNL used in the config file. DCNL If the ``name`` is None, this will attempt to parse the name from DCNL the ``config_uri`` string expecting the format ``inifile#name``. DCNL If no name is found, the name will default to "main".'
def bootstrap(config_uri, request=None, options=None): DCNL 'Load a WSGI application from the PasteDeploy config file specified DCNL by ``config_uri``. The environment will be configured as if it is DCNL currently serving ``request``, leaving a natural environment in place DCNL to write scripts that can generate URLs and utilize renderers. DCNL This function returns a dictionary with ``app``, ``root``, ``closer``, DCNL ``request``, and ``registry`` keys.  ``app`` is the WSGI app loaded DCNL (based on the ``config_uri``), ``root`` is the traversal root resource DCNL of the Pyramid application, and ``closer`` is a parameterless callback DCNL that may be called when your script is complete (it pops a threadlocal DCNL stack). DCNL .. note:: DCNL Most operations within :app:`Pyramid` expect to be invoked within the DCNL context of a WSGI request, thus it\'s important when loading your DCNL application to anchor it when executing scripts and other code that is DCNL not normally invoked during active WSGI requests. DCNL .. note:: DCNL For a complex config file containing multiple :app:`Pyramid` DCNL applications, this function will setup the environment under the context DCNL of the last-loaded :app:`Pyramid` application. You may load a specific DCNL application yourself by using the lower-level functions DCNL :meth:`pyramid.paster.get_app` and :meth:`pyramid.scripting.prepare` in DCNL conjunction with :attr:`pyramid.config.global_registries`. DCNL ``config_uri`` -- specifies the PasteDeploy config file to use for the DCNL interactive shell. The format is ``inifile#name``. If the name is left DCNL off, ``main`` will be assumed. DCNL ``request`` -- specified to anchor the script to a given set of WSGI DCNL parameters. For example, most people would want to specify the host, DCNL scheme and port such that their script will generate URLs in relation DCNL to those parameters. A request with default parameters is constructed DCNL for you if none is provided. You can mutate the request\'s ``environ`` DCNL later to setup a specific host/port/scheme/etc. DCNL ``options`` Is passed to get_app for use as variable assignments like DCNL {\'http_port\': 8080} and then use %(http_port)s in the DCNL config file. DCNL This function may be used as a context manager to call the ``closer`` DCNL automatically: DCNL .. code-block:: python DCNL with bootstrap(\'development.ini\') as env: DCNL request = env[\'request\'] DCNL See :ref:`writing_a_script` for more information about how to use this DCNL function. DCNL .. versionchanged:: 1.8 DCNL Added the ability to use the return value as a context manager.'
def render(renderer_name, value, request=None, package=None): DCNL 'Using the renderer ``renderer_name`` (a template DCNL or a static renderer), render the value (or set of values) present DCNL in ``value``. Return the result of the renderer\'s ``__call__`` DCNL method (usually a string or Unicode). DCNL If the ``renderer_name`` refers to a file on disk, such as when the DCNL renderer is a template, it\'s usually best to supply the name as an DCNL :term:`asset specification` DCNL (e.g. ``packagename:path/to/template.pt``). DCNL You may supply a relative asset spec as ``renderer_name``.  If DCNL the ``package`` argument is supplied, a relative renderer path DCNL will be converted to an absolute asset specification by DCNL combining the package ``package`` with the relative DCNL asset specification ``renderer_name``.  If ``package`` DCNL is ``None`` (the default), the package name of the *caller* of DCNL this function will be used as the package. DCNL The ``value`` provided will be supplied as the input to the DCNL renderer.  Usually, for template renderings, this should be a DCNL dictionary.  For other renderers, this will need to be whatever DCNL sort of value the renderer expects. DCNL The \'system\' values supplied to the renderer will include a basic set of DCNL top-level system names, such as ``request``, ``context``, DCNL ``renderer_name``, and ``view``.  See :ref:`renderer_system_values` for DCNL the full list.  If :term:`renderer globals` have been specified, these DCNL will also be used to augment the value. DCNL Supply a ``request`` parameter in order to provide the renderer DCNL with the most correct \'system\' values (``request`` and ``context`` DCNL in particular).'
def render_to_response(renderer_name, value, request=None, package=None, response=None): DCNL 'Using the renderer ``renderer_name`` (a template DCNL or a static renderer), render the value (or set of values) using DCNL the result of the renderer\'s ``__call__`` method (usually a string DCNL or Unicode) as the response body. DCNL If the renderer name refers to a file on disk (such as when the DCNL renderer is a template), it\'s usually best to supply the name as a DCNL :term:`asset specification`. DCNL You may supply a relative asset spec as ``renderer_name``.  If DCNL the ``package`` argument is supplied, a relative renderer name DCNL will be converted to an absolute asset specification by DCNL combining the package ``package`` with the relative DCNL asset specification ``renderer_name``.  If you do DCNL not supply a ``package`` (or ``package`` is ``None``) the package DCNL name of the *caller* of this function will be used as the package. DCNL The ``value`` provided will be supplied as the input to the DCNL renderer.  Usually, for template renderings, this should be a DCNL dictionary.  For other renderers, this will need to be whatever DCNL sort of value the renderer expects. DCNL The \'system\' values supplied to the renderer will include a basic set of DCNL top-level system names, such as ``request``, ``context``, DCNL ``renderer_name``, and ``view``.  See :ref:`renderer_system_values` for DCNL the full list.  If :term:`renderer globals` have been specified, these DCNL will also be used to argument the value. DCNL Supply a ``request`` parameter in order to provide the renderer DCNL with the most correct \'system\' values (``request`` and ``context`` DCNL in particular). Keep in mind that any changes made to ``request.response`` DCNL prior to calling this function will not be reflected in the resulting DCNL response object. A new response object will be created for each call DCNL unless one is passed as the ``response`` argument. DCNL .. versionchanged:: 1.6 DCNL In previous versions, any changes made to ``request.response`` outside DCNL of this function call would affect the returned response. This is no DCNL longer the case. If you wish to send in a pre-initialized response DCNL then you may pass one in the ``response`` argument.'
def get_renderer(renderer_name, package=None): DCNL 'Return the renderer object for the renderer ``renderer_name``. DCNL You may supply a relative asset spec as ``renderer_name``.  If DCNL the ``package`` argument is supplied, a relative renderer name DCNL will be converted to an absolute asset specification by DCNL combining the package ``package`` with the relative DCNL asset specification ``renderer_name``.  If ``package`` is ``None`` DCNL (the default), the package name of the *caller* of this function DCNL will be used as the package.'
def parse_ticket(secret, ticket, ip, hashalg='md5'): DCNL 'Parse the ticket, returning (timestamp, userid, tokens, user_data). DCNL If the ticket cannot be parsed, a ``BadTicket`` exception will be raised DCNL with an explanation.'
def extract_http_basic_credentials(request): DCNL 'A helper function for extraction of HTTP Basic credentials DCNL from a given :term:`request`. DCNL Returns a :class:`.HTTPBasicCredentials` 2-tuple with ``username`` and DCNL ``password`` attributes or ``None`` if no credentials could be found.'
def get_csrf_token(request): DCNL 'Get the currently active CSRF token for the request passed, generating DCNL a new one using ``new_csrf_token(request)`` if one does not exist. This DCNL calls the equivalent method in the chosen CSRF protection implementation. DCNL .. versionadded :: 1.9'
def new_csrf_token(request): DCNL 'Generate a new CSRF token for the request passed and persist it in an DCNL implementation defined manner. This calls the equivalent method in the DCNL chosen CSRF protection implementation. DCNL .. versionadded :: 1.9'
def check_csrf_token(request, token='csrf_token', header='X-CSRF-Token', raises=True): DCNL 'Check the CSRF token returned by the DCNL :class:`pyramid.interfaces.ICSRFStoragePolicy` implementation against the DCNL value in ``request.POST.get(token)`` (if a POST request) or DCNL ``request.headers.get(header)``. If a ``token`` keyword is not supplied to DCNL this function, the string ``csrf_token`` will be used to look up the token DCNL in ``request.POST``. If a ``header`` keyword is not supplied to this DCNL function, the string ``X-CSRF-Token`` will be used to look up the token in DCNL ``request.headers``. DCNL If the value supplied by post or by header cannot be verified by the DCNL :class:`pyramid.interfaces.ICSRFStoragePolicy`, and ``raises`` is DCNL ``True``, this function will raise an DCNL :exc:`pyramid.exceptions.BadCSRFToken` exception. If the values differ DCNL and ``raises`` is ``False``, this function will return ``False``.  If the DCNL CSRF check is successful, this function will return ``True`` DCNL unconditionally. DCNL See :ref:`auto_csrf_checking` for information about how to secure your DCNL application automatically against CSRF attacks. DCNL .. versionadded:: 1.4a2 DCNL .. versionchanged:: 1.7a1 DCNL A CSRF token passed in the query string of the request is no longer DCNL considered valid. It must be passed in either the request body or DCNL a header. DCNL .. versionchanged:: 1.9 DCNL Moved from :mod:`pyramid.session` to :mod:`pyramid.csrf` and updated DCNL to use the configured :class:`pyramid.interfaces.ICSRFStoragePolicy` to DCNL verify the CSRF token.'
def check_csrf_origin(request, trusted_origins=None, raises=True): DCNL 'Check the ``Origin`` of the request to see if it is a cross site request or DCNL not. DCNL If the value supplied by the ``Origin`` or ``Referer`` header isn\'t one of the DCNL trusted origins and ``raises`` is ``True``, this function will raise a DCNL :exc:`pyramid.exceptions.BadCSRFOrigin` exception, but if ``raises`` is DCNL ``False``, this function will return ``False`` instead. If the CSRF origin DCNL checks are successful this function will return ``True`` unconditionally. DCNL Additional trusted origins may be added by passing a list of domain (and DCNL ports if non-standard like ``[\'example.com\', \'dev.example.com:8080\']``) in DCNL with the ``trusted_origins`` parameter. If ``trusted_origins`` is ``None`` DCNL (the default) this list of additional domains will be pulled from the DCNL ``pyramid.csrf_trusted_origins`` setting. DCNL Note that this function will do nothing if ``request.scheme`` is not DCNL ``https``. DCNL .. versionadded:: 1.7 DCNL .. versionchanged:: 1.9 DCNL Moved from :mod:`pyramid.session` to :mod:`pyramid.csrf`'
def excview_tween_factory(handler, registry): DCNL 'A :term:`tween` factory which produces a tween that catches an DCNL exception raised by downstream tweens (or the main Pyramid request DCNL handler) and, if possible, converts it into a Response using an DCNL :term:`exception view`. DCNL .. versionchanged:: 1.9 DCNL The ``request.response`` will be remain unchanged even if the tween DCNL handles an exception. Previously it was deleted after handling an DCNL exception. DCNL Also, ``request.exception`` and ``request.exc_info`` are only set if DCNL the tween handles an exception and returns a response otherwise they DCNL are left at their original values.'
def parse_url_overrides(request, kw): DCNL 'Parse special arguments passed when generating urls. DCNL The supplied dictionary is mutated when we pop arguments. DCNL Returns a 3-tuple of the format: DCNL ``(app_url, qs, anchor)``.'
def route_url(route_name, request, *elements, **kw): DCNL 'This is a backwards compatibility function.  Its result is the same as DCNL calling:: DCNL request.route_url(route_name, *elements, **kw) DCNL See :meth:`pyramid.request.Request.route_url` for more information.'
def route_path(route_name, request, *elements, **kw): DCNL 'This is a backwards compatibility function.  Its result is the same as DCNL calling:: DCNL request.route_path(route_name, *elements, **kw) DCNL See :meth:`pyramid.request.Request.route_path` for more information.'
def resource_url(resource, request, *elements, **kw): DCNL 'This is a backwards compatibility function.  Its result is the same as DCNL calling:: DCNL request.resource_url(resource, *elements, **kw) DCNL See :meth:`pyramid.request.Request.resource_url` for more information.'
def static_url(path, request, **kw): DCNL 'This is a backwards compatibility function.  Its result is the same as DCNL calling:: DCNL request.static_url(path, **kw) DCNL See :meth:`pyramid.request.Request.static_url` for more information.'
def static_path(path, request, **kw): DCNL 'This is a backwards compatibility function.  Its result is the same as DCNL calling:: DCNL request.static_path(path, **kw) DCNL See :meth:`pyramid.request.Request.static_path` for more information.'
def current_route_url(request, *elements, **kw): DCNL 'This is a backwards compatibility function.  Its result is the same as DCNL calling:: DCNL request.current_route_url(*elements, **kw) DCNL See :meth:`pyramid.request.Request.current_route_url` for more DCNL information.'
def current_route_path(request, *elements, **kw): DCNL 'This is a backwards compatibility function.  Its result is the same as DCNL calling:: DCNL request.current_route_path(*elements, **kw) DCNL See :meth:`pyramid.request.Request.current_route_path` for more DCNL information.'
def undefer(v): DCNL 'Function which accepts an object and returns it unless it is a DCNL :class:`pyramid.registry.Deferred` instance.  If it is an instance of DCNL that class, its ``resolve`` method is called, and the result of the DCNL method is returned.'
def text_(s, encoding='latin-1', errors='strict'): DCNL 'If ``s`` is an instance of ``binary_type``, return DCNL ``s.decode(encoding, errors)``, otherwise return ``s``'
def bytes_(s, encoding='latin-1', errors='strict'): DCNL 'If ``s`` is an instance of ``text_type``, return DCNL ``s.encode(encoding, errors)``, otherwise return ``s``'
def is_unbound_method(fn): DCNL 'This consistently verifies that the callable is bound to a DCNL class.'
def apply_request_extensions(request, extensions=None): DCNL 'Apply request extensions (methods and properties) to an instance of DCNL :class:`pyramid.interfaces.IRequest`. This method is dependent on the DCNL ``request`` containing a properly initialized registry. DCNL After invoking this method, the ``request`` should have the methods DCNL and properties that were defined using DCNL :meth:`pyramid.config.Configurator.add_request_method`.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def get_tm_session(session_factory, transaction_manager): DCNL 'Get a ``sqlalchemy.orm.Session`` instance backed by a transaction. DCNL This function will hook the session to the transaction manager which DCNL will take care of committing any changes. DCNL - When using pyramid_tm it will automatically be committed or aborted DCNL depending on whether an exception is raised. DCNL - When using scripts you should wrap the session in a manager yourself. DCNL For example:: DCNL import transaction DCNL engine = get_engine(settings) DCNL session_factory = get_session_factory(engine) DCNL with transaction.manager: DCNL dbsession = get_tm_session(session_factory, transaction.manager)'
def includeme(config): DCNL 'Initialize the model for a Pyramid app. DCNL Activate this setup using ``config.include(\'tutorial.models\')``.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def get_tm_session(session_factory, transaction_manager): DCNL 'Get a ``sqlalchemy.orm.Session`` instance backed by a transaction. DCNL This function will hook the session to the transaction manager which DCNL will take care of committing any changes. DCNL - When using pyramid_tm it will automatically be committed or aborted DCNL depending on whether an exception is raised. DCNL - When using scripts you should wrap the session in a manager yourself. DCNL For example:: DCNL import transaction DCNL engine = get_engine(settings) DCNL session_factory = get_session_factory(engine) DCNL with transaction.manager: DCNL dbsession = get_tm_session(session_factory, transaction.manager)'
def includeme(config): DCNL 'Initialize the model for a Pyramid app. DCNL Activate this setup using ``config.include(\'tutorial.models\')``.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def get_tm_session(session_factory, transaction_manager): DCNL 'Get a ``sqlalchemy.orm.Session`` instance backed by a transaction. DCNL This function will hook the session to the transaction manager which DCNL will take care of committing any changes. DCNL - When using pyramid_tm it will automatically be committed or aborted DCNL depending on whether an exception is raised. DCNL - When using scripts you should wrap the session in a manager yourself. DCNL For example:: DCNL import transaction DCNL engine = get_engine(settings) DCNL session_factory = get_session_factory(engine) DCNL with transaction.manager: DCNL dbsession = get_tm_session(session_factory, transaction.manager)'
def includeme(config): DCNL 'Initialize the model for a Pyramid app. DCNL Activate this setup using ``config.include(\'tutorial.models\')``.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def get_tm_session(session_factory, transaction_manager): DCNL 'Get a ``sqlalchemy.orm.Session`` instance backed by a transaction. DCNL This function will hook the session to the transaction manager which DCNL will take care of committing any changes. DCNL - When using pyramid_tm it will automatically be committed or aborted DCNL depending on whether an exception is raised. DCNL - When using scripts you should wrap the session in a manager yourself. DCNL For example:: DCNL import transaction DCNL engine = get_engine(settings) DCNL session_factory = get_session_factory(engine) DCNL with transaction.manager: DCNL dbsession = get_tm_session(session_factory, transaction.manager)'
def includeme(config): DCNL 'Initialize the model for a Pyramid app. DCNL Activate this setup using ``config.include(\'tutorial.models\')``.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def get_tm_session(session_factory, transaction_manager): DCNL 'Get a ``sqlalchemy.orm.Session`` instance backed by a transaction. DCNL This function will hook the session to the transaction manager which DCNL will take care of committing any changes. DCNL - When using pyramid_tm it will automatically be committed or aborted DCNL depending on whether an exception is raised. DCNL - When using scripts you should wrap the session in a manager yourself. DCNL For example:: DCNL import transaction DCNL engine = get_engine(settings) DCNL session_factory = get_session_factory(engine) DCNL with transaction.manager: DCNL dbsession = get_tm_session(session_factory, transaction.manager)'
def includeme(config): DCNL 'Initialize the model for a Pyramid app. DCNL Activate this setup using ``config.include(\'tutorial.models\')``.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def get_tm_session(session_factory, transaction_manager): DCNL 'Get a ``sqlalchemy.orm.Session`` instance backed by a transaction. DCNL This function will hook the session to the transaction manager which DCNL will take care of committing any changes. DCNL - When using pyramid_tm it will automatically be committed or aborted DCNL depending on whether an exception is raised. DCNL - When using scripts you should wrap the session in a manager yourself. DCNL For example:: DCNL import transaction DCNL engine = get_engine(settings) DCNL session_factory = get_session_factory(engine) DCNL with transaction.manager: DCNL dbsession = get_tm_session(session_factory, transaction.manager)'
def includeme(config): DCNL 'Initialize the model for a Pyramid app. DCNL Activate this setup using ``config.include(\'tutorial.models\')``.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def get_tm_session(session_factory, transaction_manager): DCNL 'Get a ``sqlalchemy.orm.Session`` instance backed by a transaction. DCNL This function will hook the session to the transaction manager which DCNL will take care of committing any changes. DCNL - When using pyramid_tm it will automatically be committed or aborted DCNL depending on whether an exception is raised. DCNL - When using scripts you should wrap the session in a manager yourself. DCNL For example:: DCNL import transaction DCNL engine = get_engine(settings) DCNL session_factory = get_session_factory(engine) DCNL with transaction.manager: DCNL dbsession = get_tm_session(session_factory, transaction.manager)'
def includeme(config): DCNL 'Initialize the model for a Pyramid app. DCNL Activate this setup using ``config.include(\'tutorial.models\')``.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def app_role(role, rawtext, text, lineno, inliner, options={}, content=[]): DCNL 'custom role for :app: marker, does nothing in particular except allow DCNL :app:`Pyramid` to work (for later search and replace).'
def resig(app, what, name, obj, options, signature, return_annotation): DCNL 'Allow for preservation of ``@action_method`` decorated methods DCNL in configurator'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def get_tm_session(session_factory, transaction_manager): DCNL 'Get a ``sqlalchemy.orm.Session`` instance backed by a transaction. DCNL This function will hook the session to the transaction manager which DCNL will take care of committing any changes. DCNL - When using pyramid_tm it will automatically be committed or aborted DCNL depending on whether an exception is raised. DCNL - When using scripts you should wrap the session in a manager yourself. DCNL For example:: DCNL import transaction DCNL engine = get_engine(settings) DCNL session_factory = get_session_factory(engine) DCNL with transaction.manager: DCNL dbsession = get_tm_session(session_factory, transaction.manager)'
def includeme(config): DCNL 'Initialize the model for a Pyramid app. DCNL Activate this setup using ``config.include(\'sqla_demo.models\')``.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def main(global_config, **settings): DCNL 'This function returns a Pyramid WSGI application.'
def _get_job_dict_from_job_model(model): DCNL 'Converts an ndb.Model representing a job to a dict. DCNL Args: DCNL model: ndb.Model. The model to extract job info from. DCNL Returns: DCNL dict. The dict contains the following keys: DCNL id: str. The ID of the job. DCNL time_started_msec: float. When the job was started, in milliseconds DCNL since the epoch. DCNL time_finished_msec: float. When the job was finished, in DCNL milliseconds since the epoch. DCNL status_code: str. The current status of the job. DCNL job_type: str. The type of this job. DCNL is_cancelable: bool. Whether the job can be canceled. DCNL error: str. Any errors pertaining to this job. DCNL human_readable_time_started: str or None. A human-readable string DCNL representing the time the job started, or None if DCNL time_started_msec is None. DCNL human_readable_time_finished: str or None. A human-readable string DCNL representing the time the job finished, or None if DCNL time_finished_msec is None.'
def get_data_for_recent_jobs(recency_msec=DEFAULT_RECENCY_MSEC): DCNL 'Get a list containing data about recent jobs. DCNL This list is arranged in descending order based on the time the job DCNL was enqueued. At most NUM_JOBS_IN_DASHBOARD_LIMIT job descriptions are DCNL returned. DCNL Args: DCNL recency_msec: int. The threshold for a recent job, in milliseconds. DCNL Returns: DCNL list(dict). Each dict contains the following keys: DCNL id: str. The ID of the job. DCNL time_started_msec: float. When the job was started, in milliseconds DCNL since the epoch. DCNL time_finished_msec: float. When the job was finished, in DCNL milliseconds since the epoch. DCNL status_code: str. The current status of the job. DCNL job_type: str. The type of this job. DCNL is_cancelable: bool. Whether the job can be canceled. DCNL error: str. Any errors pertaining to this job. DCNL human_readable_time_started: str or None. A human-readable string DCNL representing the time the job started, or None if DCNL time_started_msec is None. DCNL human_readable_time_finished: str or None. A human-readable string DCNL representing the time the job finished, or None if DCNL time_finished_msec is None.'
def get_data_for_unfinished_jobs(): DCNL 'Returns a list of dicts containing data about all unfinished jobs. DCNL Returns: DCNL list(dict). Each dict represents a continuous computation and contains DCNL the following keys: DCNL computation_type: str. The type of the computation. DCNL status_code: str. The current status of the computation. DCNL last_started_msec: float or None. When a batch job for the DCNL computation was last started, in milliseconds since the DCNL epoch. DCNL last_finished_msec: float or None. When a batch job for the DCNL computation last finished, in milliseconds since the epoch. DCNL last_stopped_msec: float or None. When a batch job for the DCNL computation was last stopped, in milliseconds since the DCNL epoch. DCNL active_realtime_layer_index: int or None. The index of the DCNL active realtime layer. DCNL is_startable: bool. Whether an admin should be allowed to start DCNL this computation. DCNL is_stoppable: bool. Whether an admin should be allowed to stop DCNL this computation.'
def get_job_output(job_id): DCNL 'Returns the output of a job. DCNL Args: DCNL job_id: str. The ID of the job to query. DCNL Returns: DCNL str. The result of the job.'
def get_continuous_computations_info(cc_classes): DCNL 'Returns data about the given computations. DCNL Args: DCNL cc_classes: list(BaseContinuousComputationManager). List of continuous DCNL computation subclasses. DCNL Returns: DCNL list(dict). Each dict represents a continuous computation and contains DCNL the following keys: DCNL computation_type: str. The type of the computation. DCNL status_code: str. The current status of the computation. DCNL last_started_msec: float or None. When a batch job for the DCNL computation was last started, in milliseconds since the DCNL epoch. DCNL last_finished_msec: float or None. When a batch job for the DCNL computation last finished, in milliseconds since the epoch. DCNL last_stopped_msec: float or None. When a batch job for the DCNL computation was last stopped, in milliseconds since the DCNL epoch. DCNL active_realtime_layer_index: int or None. The index of the DCNL active realtime layer. DCNL is_startable: bool. Whether an admin should be allowed to start DCNL this computation. DCNL is_stoppable: bool. Whether an admin should be allowed to stop DCNL this computation.'
def get_stuck_jobs(recency_msecs): DCNL 'Returns a list of jobs which were last updated at most recency_msecs DCNL milliseconds ago and have experienced more than one retry. DCNL Returns: DCNL list(job_models.JobModel). Jobs which have retried at least once and DCNL haven\'t finished yet.'
def create_login_url(slug): DCNL 'Creates a login url.'
def create_logout_url(slug): DCNL 'Creates a logout url.'
def get_current_user(): DCNL 'Returns the current user.'
def is_current_user_super_admin(): DCNL 'Checks whether the current user owns this app.'
def get_user_id_from_email(email): DCNL 'Given an email address, returns a user id. DCNL Returns None if the email address does not correspond to a valid user id.'
def get_user_id(user): DCNL 'Given an user object, get the user id.'
def get_user_email(user): DCNL 'Given an user object, get the user\'s email.'
def defer(fn, *args, **kwargs): DCNL 'Adds a new task to the default deferred queue.'
def defer_to_events_queue(fn, *args, **kwargs): DCNL 'Adds a new task to the deferred queue for processing events.'
def enqueue_task(url, params, countdown): DCNL 'Adds a new task for sending email. DCNL Args: DCNL - url: url of the handler function. DCNL - params: parameters that will be passed as payload to handler DCNL function. DCNL - countdown: amount of time, in seconds, to wait before executing task.'
def send_mail(sender_email, recipient_email, subject, plaintext_body, html_body, bcc_admin=False, reply_to_id=None): DCNL 'Sends an email. The client is responsible for recording any audit logs. DCNL In general this function should only be called from DCNL email_manager._send_email(). DCNL Args: DCNL - sender_email: str. the email address of the sender. This should be in DCNL the form \'SENDER_NAME <SENDER_EMAIL_ADDRESS>\'. DCNL - recipient_email: str. the email address of the recipient. DCNL - subject: str. The subject line of the email. DCNL - plaintext_body: str. The plaintext body of the email. DCNL - html_body: str. The HTML body of the email. Must fit in a datastore DCNL entity. DCNL - bcc_admin: bool. Whether to bcc feconf.ADMIN_EMAIL_ADDRESS on the email. DCNL - reply_to_id: str or None. The unique reply-to id used in reply-to email DCNL sent to recipient. DCNL Raises: DCNL Exception: if the configuration in feconf.py forbids emails from being DCNL sent. DCNL ValueError: if \'sender_email\' or \'recipient_email\' is invalid, according DCNL to App Engine. DCNL (and possibly other exceptions, due to mail.send_mail() failures)'
def send_bulk_mail(sender_email, recipient_emails, subject, plaintext_body, html_body): DCNL 'Sends an email. The client is responsible for recording any audit logs. DCNL In general this function should only be called from DCNL email_manager._send_email(). DCNL Args: DCNL - sender_email: str. the email address of the sender. This should be in DCNL the form \'SENDER_NAME <SENDER_EMAIL_ADDRESS>\'. DCNL - recipient_email: str. the email address of the recipient. DCNL - subject: str. The subject line of the email. DCNL - plaintext_body: str. The plaintext body of the email. DCNL - html_body: str. The HTML body of the email. Must fit in a datastore DCNL entity. DCNL Raises: DCNL Exception: if the configuration in feconf.py forbids emails from being DCNL sent. DCNL ValueError: if \'sender_email\' or \'recipient_email\' is invalid, according DCNL to App Engine. DCNL (and possibly other exceptions, due to mail.send_mail() failures)'
def send_mail(sender_email, recipient_email, subject, plaintext_body, html_body, bcc_admin=False, reply_to_id=None): DCNL 'Sends an email using mailgun api. DCNL In general this function should only be called from DCNL email_manager._send_email(). DCNL Args: DCNL - sender_email: str. the email address of the sender. This should be in DCNL the form \'SENDER_NAME <SENDER_EMAIL_ADDRESS>\'. DCNL - recipient_email: str. the email address of the recipient. DCNL - subject: str. The subject line of the email. DCNL - plaintext_body: str. The plaintext body of the email. DCNL - html_body: str. The HTML body of the email. Must fit in a datastore DCNL entity. DCNL - bcc_admin: bool. Whether to bcc feconf.ADMIN_EMAIL_ADDRESS on the email. DCNL Raises: DCNL Exception: if the configuration in feconf.py forbids emails from being DCNL sent. DCNL Exception: if mailgun api key is not stored in feconf.MAILGUN_API_KEY. DCNL Exception: if mailgun domain name is not stored in DCNL feconf.MAILGUN_DOMAIN_NAME. DCNL (and possibly other exceptions, due to mail.send_mail() failures)'
def send_bulk_mail(sender_email, recipient_emails, subject, plaintext_body, html_body): DCNL 'Sends an email using mailgun api. DCNL In general this function should only be called from DCNL email_manager._send_email(). DCNL Args: DCNL - sender_email: str. the email address of the sender. This should be in DCNL the form \'SENDER_NAME <SENDER_EMAIL_ADDRESS>\'. DCNL - recipient_emails: list. list of the email addresses of recipients. DCNL - subject: str. The subject line of the email. DCNL - plaintext_body: str. The plaintext body of the email. DCNL - html_body: str. The HTML body of the email. Must fit in a datastore DCNL entity. DCNL - reply_to_id: str or None. The unique reply-to id used in reply-to email DCNL sent to recipient. DCNL Raises: DCNL Exception: if the configuration in feconf.py forbids emails from being DCNL sent. DCNL Exception: if mailgun api key is not stored in feconf.MAILGUN_API_KEY. DCNL Exception: if mailgun domain name is not stored in DCNL feconf.MAILGUN_DOMAIN_NAME. DCNL (and possibly other exceptions, due to mail.send_mail() failures)'
def get_multi(keys): DCNL 'Looks up a list of keys in memcache. DCNL Args: DCNL - keys: a list of keys (strings) to look up. DCNL Returns: DCNL A dict of key-value pairs for the keys/values that were present in DCNL memcache.'
def set_multi(key_value_mapping): DCNL 'Sets multiple keys\' values at once. DCNL Args: DCNL - key_value_mapping: a dict of {key: value} pairs. The key is a string DCNL and the value is anything that is serializable using the Python DCNL pickle module. The combined size of each key and value must be DCNL < 1 MB. The total size of key_value_mapping should be at most 32 MB. DCNL Returns: DCNL A list of the keys whose values were NOT set.'
def delete(key): DCNL 'Deletes a key in memcache. DCNL Args: DCNL - key: a key (string) to delete. DCNL Returns: DCNL 0 on network failure, 1 if the item does not exist, and 2 for a DCNL successful delete.'
def delete_multi(keys): DCNL 'Deletes multiple keys in memcache. DCNL Args: DCNL - keys: the keys (strings) to delete. DCNL Returns: DCNL True if all operations complete successfully; False otherwise.'
def get_application_id(): DCNL 'Returns the application\'s App Engine ID. DCNL For more information, see DCNL https://cloud.google.com/appengine/docs/python/appidentity/ DCNL Returns: DCNL str. The application ID.'
def add_documents_to_index(documents, index, retries=DEFAULT_NUM_RETRIES): DCNL 'Adds a document to an index. DCNL Args: DCNL - documents: a list of documents. Each document should be a dictionary. DCNL Every key in the document is a field name, and the corresponding DCNL value will be the field\'s value. DCNL If there is a key named \'id\', its value will be used as the DCNL document\'s id. DCNL If there is a key named \'rank\', its value will be used as DCNL the document\'s rank. DCNL By default, search results are returned ordered by descending rank. DCNL If there is a key named \'language_code\', its value will be used as DCNL the document\'s language. Otherwise, constants.DEFAULT_LANGUAGE_CODE is DCNL used. DCNL - index: the name of the index to insert the document into, a string. DCNL - retries: the number of times to retry inserting the documents. DCNL Returns: DCNL returns a list of document ids of the documents that were added. DCNL Raises: DCNL - SearchFailureError: raised when the indexing fails. If it fails for any DCNL document, none will be inserted. DCNL - ValueError: raised when invalid values are given.'
def _validate_list(key, value): DCNL 'Validates a list to be included as document fields. The key is just DCNL passed in to make better error messages.'
def delete_documents_from_index(doc_ids, index, retries=DEFAULT_NUM_RETRIES): DCNL 'Deletes documents from an index. DCNL Args: DCNL - doc_ids: a list of document ids of documents to be deleted from the DCNL index. DCNL - index: the name of the index to delete the document from, a string. DCNL - retries: the number of times to retry deleting the documents. DCNL Raises: DCNL - SearchFailureError: raised when the deletion fails. If it fails for any DCNL document, none will be deleted.'
def clear_index(index_name): DCNL 'Clears an index completely. DCNL WARNING: This does all the clearing in-request, and may therefore fail if DCNL there are too many entries in the index. DCNL Args: DCNL - index: the name of the index to delete the document from, a string.'
def search(query_string, index, cursor=None, limit=feconf.SEARCH_RESULTS_PAGE_SIZE, sort='', ids_only=False, retries=DEFAULT_NUM_RETRIES): DCNL 'Searches for documents in an index. DCNL Args: DCNL - query_string: the search query. DCNL The syntax used is described here: DCNL https://developers.google.com/appengine/docs/python/search/query_strings DCNL - index: the name of the index to search. DCNL - cursor: a cursor string, as returned by this function. Pass this in to DCNL get the next \'page\' of results. Leave as None to start at the DCNL beginning. DCNL - sort: a string indicating how to sort results. This should be a string DCNL of space separated values. Each value should start with a \'+\' or a DCNL \'-\' character indicating whether to sort in ascending or descending DCNL order respectively. This character should be followed by a field name DCNL to sort on. DCNL - limit: the maximum number of documents to return. DCNL - ids_only: whether to only return document ids. DCNL - retries: the number of times to retry searching the index. DCNL Returns: DCNL returns a tuple with two elements: DCNL - a list of dictionaries representing search documents. If ids_only is DCNL True, this will be a list of strings, doc_ids. DCNL - a cursor that you can pass back in to get the next page of results. DCNL This wil be a web safe string that you can use in urls. DCNL It will be None if there is no next page.'
def get_document_from_index(doc_id, index): DCNL 'Returns a document with a give doc_id(s) from the index. DCNL args: DCNL - doc_id: a doc_id as a string DCNL - index: the name of an index, a string. DCNL returns DCNL - the requested document as a dict'
def fetch_multiple_entities_by_ids_and_models(ids_and_models): DCNL 'Fetches the entities from the datastore corresponding to the given ids DCNL and models. DCNL Args: DCNL ids_and_models: list(tuple(str, list(str))). The ids and their DCNL corresponding model names for which we have to fetch entities. DCNL Returns: DCNL list(list(ndb.Model)). The model instances corresponding to the ids and DCNL models. The models corresponding to the same tuple in the input are DCNL grouped together.'
def run_in_transaction(fn, *args, **kwargs): DCNL 'Runs a function in a transaction. Either all of the operations in DCNL the transaction are applied, or none of them are applied. DCNL If an exception is raised, the transaction is likely not safe to DCNL commit, since TransactionOptions.ALLOWED is used. DCNL Args: DCNL fn: A function (or callable) to be called. DCNL *args: Variable length argument list passed to the callable. DCNL **kwargs: Arbitrary keyword arguments passed to the callable. DCNL Returns: DCNL Whatever fn() returns. DCNL Raises: DCNL *: Whatever fn() raises. DCNL datastore_errors.TransactionFailedError: The transaction failed.'
def toplevel_wrapper(*args, **kwargs): DCNL 'Enables a WSGI application to not exit until all its asynchronous DCNL requests have finished. DCNL For more information, see DCNL https://developers.google.com/appengine/docs/python/ndb/async#intro DCNL Args: DCNL *args: Variable length argument list. DCNL **kwargs: Arbitrary keyword arguments.'
def create_test_suites(test_target=None): DCNL 'Creates test suites. If test_dir is None, runs all tests.'
def main(): DCNL 'Runs the tests.'
def measure_runtime(func): DCNL 'A decorator that measures the amount of time func takes to run. DCNL Args: DCNL func: function. The function to be measured. DCNL Returns: DCNL function. The decorated function by this decorator.'
def _clear_login_cookies(response_headers): DCNL 'Clears login cookies from the given response headers.'
def get_matching_activity_dicts(query_string, search_cursor): DCNL 'Given a query string and a search cursor, returns a list of activity DCNL dicts that satisfy the search query.'
def require_maintenance_mode(handler): DCNL 'Decorator that checks whether maintenance mode is enabled in feconf.'
def assign_roles(changed_user_roles): DCNL 'Assigns roles to users based on given dict. DCNL Args: DCNL changed_user_roles: dict(str:str). Dict mapping usernames to roles. DCNL These are the changes that have to be applied to roles.'
def _require_valid_version(version_from_payload, collection_version): DCNL 'Check that the payload version matches the given collection version.'
def generate_signature(secret, message): DCNL 'Generates digital signature for given data. DCNL Args: DCNL secret: str. The secret used to communicate with Oppia-ml. DCNL message: dict. The message payload data. DCNL Returns: DCNL str. The signature of the payload data.'
def validate_job_result_message_dict(message): DCNL 'Validates the data-type of the message payload data. DCNL Args: DCNL message: dict. The message payload data. DCNL Returns: DCNL bool. Whether the payload dict is valid.'
def verify_signature(message, vm_id, received_signature): DCNL 'Function that checks if the signature received from the VM is valid. DCNL Args: DCNL message: dict. The message payload data. DCNL vm_id: str. The ID of the VM instance. DCNL received_signature: str. The signature received from the VM. DCNL Returns: DCNL bool. Whether the incoming request is valid.'
def get_value_generators_js(): DCNL 'Return a string that concatenates the JS for all value generators.'
def _require_valid_version(version_from_payload, exploration_version): DCNL 'Check that the payload version matches the given exploration version.'
def set_property(committer_id, name, value): DCNL 'Sets a property value. The property must already be registered.'
def revert_property(committer_id, name): DCNL 'Reverts a property value to the default value.'
def get_featured_activity_references(): DCNL 'Gets a list of ActivityReference domain models. DCNL Returns: DCNL A list of all ActivityReference domain objects that are DCNL currently featured.'
def update_featured_activity_references(featured_activity_references): DCNL 'Updates the current list of featured activity references. DCNL Args: DCNL featured_activity_references: A list of ActivityReference domain DCNL objects representing the full list of \'featured\' activities. DCNL Raises: DCNL Exception: The input list of ActivityReference DCNL domain objects has duplicates.'
def remove_featured_activity(activity_type, activity_id): DCNL 'Removes the specified activity reference from the DCNL list of featured activity references. DCNL Args: DCNL activity_type: str. The type of the activity to remove. DCNL activity_id: str. The id of the activity to remove.'
def split_by_type(activity_references): DCNL 'Given a list of activity references, returns two lists: the first list DCNL contains the exploration ids, and the second contains the collection ids. DCNL The elements in each of the returned lists are in the same order as those DCNL in the input list. DCNL Args: DCNL activity_references: A list of ActivityReference domain objects. DCNL Returns: DCNL A 2-tuple whose first element is a list of all exploration DCNL ids represented in the input list, and whose second element DCNL is a list of all collection ids represented in the input list. DCNL Raises: DCNL Exception: The activity reference type is invalid.'
def _create_models_for_thread_and_first_message(exploration_id, state_name, original_author_id, subject, text, has_suggestion): DCNL 'Creates a feedback thread and its first message. DCNL Args: DCNL exploration_id: str. The exploration id the thread belongs to. DCNL state_name: str or None. The state name for the thread. If None, DCNL this indicates that the thread pertains to the exploration as a DCNL whole. DCNL original_author_id: str. The author id who starts this thread. DCNL subject: str. The subject of this thread. DCNL text: str. The text of the feedback message. This may be \'\'. DCNL has_suggestion: bool. Whether this thread has a related DCNL learner suggestion. DCNL Returns: DCNL The thread id we created.'
def create_thread(exploration_id, state_name, original_author_id, subject, text): DCNL 'Creates a thread and its first message. DCNL Args: DCNL exploration_id: str. The exploration id the thread belongs to. DCNL state_name: str or None. The state name for the thread. If None, this DCNL indicates that the thread pertains to the exploration as a whole. DCNL original_author_id: str. The author id who starts this thread. DCNL subject: str. The subject of this thread. DCNL text: str. The text of the feedback message. This may be \'\'.'
def create_message(exploration_id, thread_id, author_id, updated_status, updated_subject, text, received_via_email=False): DCNL 'Creates a new message for the thread and subscribes the author to the DCNL thread. DCNL Args: DCNL exploration_id: str. The exploration id the thread belongs to. DCNL thread_id: str. The thread id the message belongs to. DCNL author_id: str. The author id who creates this message. DCNL updated_status: str, one of STATUS_CHOICES. New thread status. DCNL Must be supplied if this is the first message of a thread. For the DCNL rest of the thread, should exist only when the status changes. DCNL updated_subject: str. New thread subject. Must be supplied if this is DCNL the first message of a thread. For the rest of the thread, should DCNL exist only when the subject changes. DCNL text: str. The text of the feedback message. This may be \'\'. DCNL received_via_email: bool. Whether new message is received via email or DCNL web.'
def update_messages_read_by_the_user(user_id, exploration_id, thread_id, message_ids): DCNL 'Replaces the list of message ids read by the message ids given to the DCNL function. DCNL Args: DCNL exploration_id: str. The id of the exploration. DCNL thread_id. str. The id of the thread. DCNL user_id: str. The id of the user reading the messages, DCNL message_ids: list(int): The ids of the messages in the thread read by DCNL the user.'
def add_message_id_to_read_by_list(exploration_id, thread_id, user_id, message_id): DCNL 'Adds the message id to the list of message ids read by the user. DCNL Args: DCNL exploration_id: str. The id of the exploration. DCNL thread_id. str. The id of the thread. DCNL user_id: str. The id of the user reading the messages, DCNL message_id: int: The id of the message.'
def _get_message_from_model(message_model): DCNL 'Converts the FeedbackMessageModel to a FeedbackMessage. DCNL Args: DCNL message_model: FeedbackMessageModel. The FeedbackMessageModel to DCNL be converted. DCNL Returns: DCNL FeedbackMessage. The resulting FeedbackMessage domain object.'
def get_messages(exploration_id, thread_id): DCNL 'Fetches all messages of the given thread indexed by DCNL [exploration_id].[thread_id]. DCNL Args: DCNL exploration_id: str. DCNL thread_id: str. DCNL Returns: DCNL list of FeedbackMessage. Contains all the messages in the thread.'
def get_message(exploration_id, thread_id, message_id): DCNL 'Fetches the message indexed by [exploration_id].[thread_id].[message_id]. DCNL Args: DCNL exploration_id: str. DCNL thread_id: str. DCNL message_id: int. DCNL Returns: DCNL FeedbackMessage. The fetched message.'
def get_next_page_of_all_feedback_messages(page_size=feconf.FEEDBACK_TAB_PAGE_SIZE, urlsafe_start_cursor=None): DCNL 'Fetches a single page from the list of all feedback messages that have DCNL been posted to any exploration on the site. DCNL Args: DCNL page_size: int. The number of feedback messages to display per page. DCNL Defaults to feconf.FEEDBACK_TAB_PAGE_SIZE. DCNL urlsafe_start_cursor: str or None. The cursor which represents the DCNL current position to begin the fetch from. If None, the fetch is DCNL started from the beginning of the list of all messages. DCNL Returns: DCNL tuple of (messages, new_urlsafe_start_cursor, more), where DCNL messages: list of FeedbackMessage. Contains all the messages we DCNL want. DCNL new_urlsafe_start_cursor: str. The new cursor. DCNL more: bool. Whether there are more messages available to fetch after DCNL this batch.'
def get_thread_analytics_multi(exploration_ids): DCNL 'Fetches all FeedbackAnalytics, for all the given exploration ids. DCNL A FeedbackAnalytics contains the exploration id the analytics DCNL belongs to, how many open threads exist for the exploration, DCNL how many total threads exist for the exploration. DCNL Args: DCNL exploration_ids: list of str. A list of exploration ids. DCNL Returns: DCNL list of FeedbackAnalytics. It\'s in the the same order as the input DCNL list. If the exploration id is invalid, the number of threads in the DCNL corresponding FeedbackAnalytics object will be zero.'
def get_thread_analytics(exploration_id): DCNL 'Fetches the FeedbackAnalytics for the given exploration id. DCNL Args: DCNL exploration_id: str. DCNL Returns: DCNL list of FeedbackAnalytics.'
def get_total_open_threads(feedback_thread_analytics): DCNL 'Gets the count of all open threads for the given FeedbackThreadAnalytics DCNL domain object. DCNL Args: DCNL feedback_thread_analytics: FeedbackThreadAnalytics. DCNL Returns: DCNL int. The count of all open threads for the given FeedbackThreadAnalytics DCNL domain object.'
def create_suggestion(exploration_id, author_id, exploration_version, state_name, description, suggestion_content): DCNL 'Creates a new SuggestionModel and the corresponding FeedbackThreadModel DCNL domain object. DCNL Args: DCNL exploration_id: str. The exploration id the suggestion belongs to. DCNL author_id: str. ID of the user who submitted the suggestion. DCNL exploration_version: int. The exploration version for DCNL which the suggestion was made. DCNL state_name: str or None. The state name for the thread. If None, DCNL this indicates that the thread pertains to the exploration as a DCNL whole. DCNL description: str. Learner-provided description of suggestion changes. DCNL suggestion_content: dict. Only contains two keys, "type" and "value". DCNL For historical reasons, the value of "type" is always "text" while DCNL the value of "value" is the actual content of the suggestion.'
def _get_suggestion_from_model(suggestion_model): DCNL 'Converts the given SuggestionModel to a Suggestion object. DCNL Args: DCNL suggestion_model: SuggestionModel. DCNL Returns: DCNL Suggestion. The corresponding Suggestion domain object.'
def get_suggestion(exploration_id, thread_id): DCNL 'Fetches the Suggestion for the given thread. DCNL Args: DCNL exploration_id: str. The exploration id of the given thread. DCNL thread_id: str. The thread id of the given thread. DCNL Returns: DCNL Suggestion, or None if there\'s no associated suggestion.'
def _get_thread_from_model(thread_model): DCNL 'Converts the given FeedbackThreadModel to a FeedbackThread object. DCNL Args: DCNL thread_model: FeedbackThreadModel. DCNL Returns: DCNL FeedbackThread. The corresponding FeedbackThread domain object.'
def get_thread_summaries(user_id, full_thread_ids): DCNL 'Returns a list of summaries corresponding to each of the threads given. DCNL It also returns the number of threads that are currently not read by the DCNL user. DCNL Args: DCNL user_id: str. The id of the user. DCNL full_thread_ids: str. The complete ids of the threads for which we have DCNL to fetch the summaries. DCNL Returns: DCNL list(dict). A list of dictionaries containing the summaries of the DCNL threads given to it. Each dict has the following keys: DCNL - \'status\': str. The status of the thread. DCNL - \'original_author_id\': str. The id of the original author of the DCNL thread. DCNL - \'last_updated\': datetime.datetime. When was the thread last DCNL updated. DCNL - \'last_message_text\': str. The text of the last message. DCNL - \'total_message_count\': int. The total number of messages in the DCNL thread. DCNL - \'last_message_read\': boolean. Whether the last message is read by DCNL the user. DCNL - \'second_last_message_read\': boolean. Whether the second last DCNL message is read by the user, DCNL - \'author_last_message\': str. The name of the author of the last DCNL message. DCNL - \'author_second_last_message\': str. The name of the author of the DCNL second last message. DCNL - \'exploration_title\': str. The title of the exploration to which DCNL exploration belongs. DCNL int. The number of threads not read by the user.'
def get_most_recent_messages(exp_id): DCNL 'Fetch the most recently updated feedback threads for a given exploration, DCNL and then get the latest feedback message out of each thread. DCNL Args: DCNL exp_id: str. DCNL Returns: DCNL A list of FeedbackMessage.'
def get_threads(exploration_id): DCNL 'Fetches all the threads for the given exploration id. DCNL Args: DCNL exploration_id: str. DCNL Returns: DCNL list of FeedbackThread. The corresponding Suggestion domain object.'
def get_thread(exploration_id, thread_id): DCNL 'Fetches the thread for the given exploration id and thread id. DCNL Args: DCNL exploration_id: str. DCNL thread_id: str. DCNL Returns: DCNL FeedbackThread. The resulting FeedbackThread domain object.'
def get_open_threads(exploration_id, has_suggestion): DCNL 'Fetches all open threads for the given exploration id. DCNL Args: DCNL exploration_id: str. DCNL has_suggestion: bool. If it\'s True, return a list of all open threads DCNL that have a suggestion, otherwise return a list of all open threads DCNL that do not have a suggestion. DCNL Returns: DCNL list of FeedbackThread. The resulting FeedbackThread domain objects.'
def get_closed_threads(exploration_id, has_suggestion): DCNL 'Fetches all closed threads of the given exploration id. DCNL Args: DCNL exploration_id: str. DCNL has_suggestion: bool. If it\'s True, return a list of all closed threads DCNL that have a suggestion, otherwise return a list of all closed DCNL threads that do not have a suggestion. DCNL Returns: DCNL list of FeedbackThread. The resulting FeedbackThread domain objects.'
def get_all_threads(exploration_id, has_suggestion): DCNL 'Fetches all threads (regardless of their status) that correspond to the DCNL given exploration id. DCNL Args: DCNL exploration_id: str. DCNL has_suggestion: bool. If it\'s True, return a list of all threads DCNL that have a suggestion, otherwise return a list of all threads DCNL that do not have a suggestion. DCNL Returns: DCNL list of FeedbackThread. The resulting FeedbackThread domain objects.'
def get_all_thread_participants(exploration_id, thread_id): DCNL 'Fetches all participants of the given thread. DCNL Args: DCNL exploration_id: str. DCNL thread_id: str. DCNL Returns: DCNL set(str). A set containing all author_ids of participants in the thread.'
def enqueue_feedback_message_batch_email_task(user_id): DCNL 'Adds a \'send feedback email\' (batch) task into the task queue. DCNL Args: DCNL user_id: str. The user to be notified.'
def enqueue_feedback_message_instant_email_task(user_id, reference): DCNL 'Adds a \'send feedback email\' (instant) task into the task queue. DCNL Args: DCNL user_id: str. The user to be notified. DCNL reference: FeedbackMessageReference. A reference that contains DCNL the data needed to identify the feedback message.'
def _enqueue_feedback_thread_status_change_email_task(user_id, reference, old_status, new_status): DCNL 'Adds a task for sending email when a feedback thread status is changed. DCNL Args: DCNL user_id: str. The user to be notified. DCNL reference: FeedbackMessageReference. DCNL old_status: str, one of STATUS_CHOICES. DCNL new_status: str, one of STATUS_CHOICES.'
def _enqueue_suggestion_email_task(exploration_id, thread_id): DCNL 'Adds a \'send suggestion email\' task into the task queue. DCNL Args: DCNL exploration_id: str. DCNL thread_id: str.'
def get_feedback_message_references(user_id): DCNL 'Fetches all FeedbackMessageReference objects written by the given user。 DCNL Args: DCNL user_id: str. If the user id is invalid or there is no message for this DCNL user, return an empty list. DCNL Returns: DCNL list of FeedbackMessageReference. The resulting FeedbackMessageReference DCNL domain objects.'
def _add_feedback_message_reference(user_id, reference): DCNL 'Adds a new message to the feedback message buffer that is used to DCNL generate the next notification email to the given user. DCNL Args: DCNL user_id: str. If there\'s an UnsentFeedbackEmailModel for the given DCNL user, update the instance with given reference, otherwise DCNL create a new instance DCNL reference: FeedbackMessageReference. The new message reference to DCNL add to the buffer.'
def update_feedback_email_retries(user_id): DCNL 'If sufficient time has passed, increment the number of retries for DCNL the corresponding user\'s UnsentEmailFeedbackModel. DCNL Args: DCNL user_id: str.'
def pop_feedback_message_references(user_id, num_references_to_pop): DCNL 'Pops feedback message references of the given user DCNL which have been processed already. DCNL Args: DCNL user_id: str. DCNL num_references_to_pop: int. Number of feedback message references DCNL that have been processed already.'
def clear_feedback_message_references(user_id, exploration_id, thread_id): DCNL 'Removes feedback message references associated with a feedback thread. DCNL Args: DCNL user_id: str. The user who created this reference. DCNL exploration_id: str. DCNL thread_id: str.'
def _get_all_recipient_ids(exploration_id, thread_id, author_id): DCNL 'Fetches all authors of the exploration excluding the given author and DCNL all the other recipients. DCNL Args: DCNL exploration_id: str. DCNL thread_id: str. DCNL author_id: str. One author of the given exploration_id. DCNL Returns: DCNL tuple of (batch_recipients, other_recipients) DCNL batch_recipients: set(str). The user_ids of the authors excluding DCNL the given author. DCNL other_recipients: set(str). The user_ids of the other participants DCNL in this thread, excluding owners of the exploration and the DCNL given author.'
def _send_batch_emails(recipient_list, feedback_message_reference, exploration_id, has_suggestion): DCNL 'Adds the given FeedbackMessageReference to each of the DCNL recipient\'s email buffers. The collected messages will be DCNL sent out as a batch after a short delay. DCNL Args: DCNL recipient_list: list of str. A list of user_ids of all recipients DCNL of the email. DCNL feedback_message_reference: FeedbackMessageReference. DCNL The reference to add to each email buffer. DCNL exploration_id: str. ID of exploration that received new message. DCNL has_suggestion: bool. Whether this thread has a related DCNL learner suggestion.'
def _send_instant_emails(recipient_list, feedback_message_reference, exploration_id, has_suggestion): DCNL 'Adds the given FeedbackMessageReference to each of the DCNL recipient\'s email buffers. The collected messages will be DCNL sent out immediately. DCNL Args: DCNL recipient_list: list of str. A list of user_ids of all DCNL recipients of the email. DCNL feedback_message_reference: FeedbackMessageReference. DCNL exploration_id: str. ID of exploration that received new message. DCNL has_suggestion: bool. Whether this thread has a related DCNL learner suggestion.'
def _send_feedback_thread_status_change_emails(recipient_list, feedback_message_reference, old_status, new_status, exploration_id, has_suggestion): DCNL 'Notifies the given recipients about the status change. DCNL Args: DCNL recipient_list: list of str. A list of recipient ids. DCNL feedback_message_reference: FeedbackMessageReference DCNL old_status: str, one of STATUS_CHOICES DCNL new_status: str, one of STATUS_CHOICES DCNL exploration_id: str. ID of exploration that received new message. DCNL has_suggestion: bool. Whether this thread has a related DCNL learner suggestion.'
def _ensure_each_recipient_has_reply_to_id(user_ids, exploration_id, thread_id): DCNL 'Ensures that instance of FeedbackEmailReplyToIdModel exists DCNL for each user in user_ids. DCNL Args: DCNL user_ids: list of str. A list of user_ids. DCNL exploration_id: str. The id of exploration used to obtain DCNL FeedbackEmailReplyToIdModel for given user. DCNL thread_id: str. The id of thread used to obtain DCNL FeedbackEmailReplyToIdModel for given user.'
def _add_message_to_email_buffer(author_id, exploration_id, thread_id, message_id, message_length, old_status, new_status): DCNL 'Sends the given message to the recipients of the given thread. DCNL Sends the given message to the recipients of the given thread. If DCNL status has changed, notify the recipients as well. DCNL Args: DCNL author_id: str. ID of author of message. DCNL exploration_id: str. ID of exploration that received new message. DCNL thread_id: str. ID of thread that received new message. DCNL message_id: int. ID of new message. DCNL message_length: int. Length of the feedback message to be sent. DCNL old_status: str, one of STATUS_CHOICES. Value of old thread status. DCNL new_status: str, one of STATUS_CHOICES. Value of new thread status.'
def get_human_readable_contributors_summary(contributors_summary): DCNL 'Gets contributors summary in human readable form. DCNL Args: DCNL contributors_summary: dict. The keys are user ids and DCNL the values are the number of commits made by that user. DCNL Returns: DCNL dict. Dicts of contributors in human readable form; the keys are DCNL usernames and the values are a dict. Example: DCNL \'albert\': { DCNL \'num_commits\': 10,'
def get_learner_collection_dict_by_id(collection_id, user_id, strict=True, allow_invalid_explorations=False, version=None): DCNL 'Gets a dictionary representation of a collection given by the provided DCNL collection ID. This dict includes user-specific playthrough information. DCNL Args: DCNL collection_id: str. The id of the collection. DCNL user_id: str. The user_id of the learner. DCNL strict: bool. Whether to fail noisily if no collection with the given DCNL id exists in the datastore. DCNL allow_invalid_explorations: bool. Whether to also return explorations DCNL that are invalid, such as deleted/private explorations. DCNL version: str or None. The version number of the collection to be DCNL retrieved. If it is None, the latest version will be retrieved. DCNL Returns: DCNL dict. A dictionary that contains extra information along with the dict DCNL returned by collection_domain.Collection.to_dict() which includes useful DCNL data for the collection learner view. The information includes progress DCNL in the collection, information about explorations referenced within the DCNL collection, and a slightly nicer data structure for frontend work. DCNL Raises: DCNL ValidationError: If the collection retrieved using the given DCNL ID references non-existent explorations.'
def get_displayable_collection_summary_dicts_matching_ids(collection_ids): DCNL 'Returns a list of collection summary dicts corresponding to the given DCNL collection ids. DCNL Args: DCNL collection_ids: list(str). A list of collection ids. DCNL Return: DCNL list(dict). Each element in this list is a collection summary dict. DCNL These elements are returned in the same order as that given DCNL in collection_ids.'
def get_exp_metadata_dicts_matching_query(query_string, search_cursor, user_id): DCNL 'Given a query string and a search cursor, returns a list of exploration DCNL metadata dicts that satisfy the search query. DCNL Args: DCNL query_string: str. The search query for which the search is to be DCNL performed. DCNL search_cursor: str or None. The cursor location to start the search DCNL from. If None, the returned values are from the beginning DCNL of the results list. DCNL user_id: str or None. The id of the user performing the query. DCNL If not None, private explorations that are editable by this user DCNL are also returned. DCNL Returns: DCNL exploration_list: list(dict). A list of metadata dicts for explorations DCNL matching the query. DCNL new_search_cursor: str. New search cursor location.'
def get_exploration_metadata_dicts(exploration_ids, editor_user_id=None): DCNL 'Given a list of exploration ids, optionally filters the list for DCNL explorations that are currently non-private and not deleted, and returns a DCNL list of dicts of the corresponding exploration summaries for collection DCNL node search. DCNL Args: DCNL exploration_ids: list(str). A list of exploration ids for which DCNL exploration metadata dicts are to be returned. DCNL editor_user_id: str or None. The id of the user performing the query. DCNL If not None, private explorations that are editable by this user DCNL are also returned. DCNL Returns: DCNL list(dict). A list of metadata dicts corresponding to the given DCNL exploration ids. Each dict has three keys: DCNL \'id\': the exploration id; DCNL \'title\': the exploration title; DCNL \'objective\': the exploration objective.'
def get_displayable_exp_summary_dicts_matching_ids(exploration_ids, editor_user_id=None): DCNL 'Gets a summary of explorations in human readable form from DCNL exploration ids. DCNL Given a list of exploration ids, optionally filters the list for DCNL explorations that are currently non-private and not deleted, and returns a DCNL list of dicts of the corresponding exploration summaries. This function can DCNL also filter based on a user ID who has edit access to the corresponding DCNL exploration, where the editor ID is for private explorations. Please use DCNL this function when needing summary information to display on exploration DCNL summary tiles in the frontend. DCNL Args: DCNL exploration_ids: list(str). List of exploration ids. DCNL editor_user_id: str or None. If provided, the returned value is DCNL filtered based on a user ID who has edit access to the DCNL corresponding explorations. Otherwise, the returned list is not DCNL filtered. DCNL Return: DCNL list(dict). A list of exploration summary dicts in human readable form. DCNL Example: DCNL \'category\': u\'A category\', DCNL \'community_owned\': False, DCNL \'id\': \'eid2\', DCNL \'language_code\': \'en\', DCNL \'num_views\': 0, DCNL \'objective\': u\'An objective\', DCNL \'status\': \'public\', DCNL \'tags\': [], DCNL \'thumbnail_bg_color\': \'#a33f40\', DCNL \'thumbnail_icon_url\': self.get_static_asset_url( DCNL \'/images/subjects/Lightbulb.svg\'), DCNL \'title\': u\'Exploration 2 Albert title\','
def get_displayable_exp_summary_dicts(exploration_summaries): DCNL 'Gets a summary of explorations in human readable form. DCNL Given a list of exploration summary domain objects, returns a list, DCNL with the same number of elements, of the corresponding human-readable DCNL exploration summary dicts. DCNL This assumes that all the exploration summary domain objects passed in are DCNL valid (i.e., none of them are None). DCNL Args: DCNL exploration_summaries: list(ExplorationSummary). List of exploration DCNL summary objects. DCNL Return: DCNL list(dict). A list of exploration summary dicts in human readable form. DCNL Example: DCNL \'category\': u\'A category\', DCNL \'community_owned\': False, DCNL \'id\': \'eid2\', DCNL \'language_code\': \'en\', DCNL \'num_views\': 0, DCNL \'objective\': u\'An objective\', DCNL \'status\': \'public\', DCNL \'tags\': [], DCNL \'thumbnail_bg_color\': \'#a33f40\', DCNL \'thumbnail_icon_url\': self.get_static_asset_url( DCNL \'/images/subjects/Lightbulb.svg\'), DCNL \'title\': u\'Exploration 2 Albert title\','
def _get_displayable_collection_summary_dicts(collection_summaries): DCNL 'Gets a summary of collections in human readable form. DCNL Args: DCNL collection_summaries: list(CollectionSummary). List of collection DCNL summary domain object. DCNL Return: DCNL list(dict). A list of exploration summary dicts in human readable form. DCNL Example: DCNL \'category\': u\'A category\', DCNL \'community_owned\': False, DCNL \'id\': \'eid2\', DCNL \'language_code\': \'en\', DCNL \'num_views\': 0, DCNL \'objective\': u\'An objective\', DCNL \'status\': \'public\', DCNL \'tags\': [], DCNL \'thumbnail_bg_color\': \'#a33f40\', DCNL \'thumbnail_icon_url\': self.get_static_asset_url( DCNL \'/images/subjects/Lightbulb.svg\'), DCNL \'title\': u\'Exploration 2 Albert title\','
def get_library_groups(language_codes): DCNL 'Returns a list of groups for the library index page. Each group has a DCNL header and a list of dicts representing activity summaries. DCNL Args: DCNL language_codes: list(str). A list of language codes. Only explorations DCNL with these languages will be returned. DCNL Return: DCNL list(dict). A list of groups for the library index page. Each group is DCNL represented by a dict with the following keys and values: DCNL - activity_summary_dicts: list(dict). A list of dicts representing DCNL activity summaries. DCNL - categories: list(str). The list of group categories. DCNL - header_i18n_id: str. The i18n id for the header of the category. DCNL - has_full_results_page: bool. Whether the group header links to DCNL a "full results" page. This is always True for the DCNL "exploration category" groups. DCNL - full_results_url: str. The URL to the corresponding "full results" DCNL page.'
def require_activities_to_be_public(activity_references): DCNL 'Raises an exception if any activity reference in the list does not DCNL exist, or is not public. DCNL Args: DCNL activity_references: list(ActivityReference). A list of DCNL ActivityReference domain objects. DCNL Raises: DCNL Exception: Any activity reference in the list does not DCNL exist, or is not public.'
def get_featured_activity_summary_dicts(language_codes): DCNL 'Returns a list of featured activities with the given language codes. DCNL The return value is sorted according to the list stored in the datastore. DCNL Args: DCNL language_codes: list(str). A list of language codes. Only explorations DCNL with these languages will be returned. DCNL Return: DCNL list(dict). Each dict in this list represents a featured activity. DCNL For example: DCNL \'status\': \'public\', DCNL \'thumbnail_bg_color\': \'#a33f40\', DCNL \'community_owned\': False, DCNL \'tags\': [], DCNL \'thumbnail_icon_url\': self.get_static_asset_url( DCNL \'/images/subjects/Lightbulb.svg\'), DCNL \'language_code\': constants.DEFAULT_LANGUAGE_CODE, DCNL \'id\': \'eid2\', DCNL \'category\': \'A category\', DCNL \'ratings\': feconf.get_empty_ratings(), DCNL \'title\': \'A title\', DCNL \'num_views\': 0, DCNL \'objective\': \'An objective\','
def get_top_rated_exploration_summary_dicts(language_codes, limit): DCNL 'Returns a list of top rated explorations with the given language codes. DCNL The return value is sorted in decreasing order of average rating. DCNL Args: DCNL language_codes: list(str). A list of language codes. Only explorations DCNL with these languages will be returned. DCNL limit: int. The maximum number of explorations to return. DCNL Return: DCNL list(dict). Each dict in this list represents a exploration summary in DCNL human readable form. The list is sorted in decreasing order of average DCNL rating. For example: DCNL \'category\': u\'A category\', DCNL \'community_owned\': False, DCNL \'id\': \'eid2\', DCNL \'language_code\': \'en\', DCNL \'num_views\': 0, DCNL \'objective\': u\'An objective\', DCNL \'status\': \'public\', DCNL \'tags\': [], DCNL \'thumbnail_bg_color\': \'#a33f40\', DCNL \'thumbnail_icon_url\': self.get_static_asset_url( DCNL \'/images/subjects/Lightbulb.svg\'), DCNL \'title\': u\'Exploration 2 Albert title\','
def get_recently_published_exp_summary_dicts(limit): DCNL 'Returns a list of recently published explorations. DCNL Args: DCNL limit: int. The maximum number of explorations to return. DCNL Return: DCNL list(dict). Each dict in this list represents a featured activity in DCNL human readable form. For example: DCNL \'category\': u\'A category\', DCNL \'community_owned\': False, DCNL \'id\': \'eid2\', DCNL \'language_code\': \'en\', DCNL \'num_views\': 0, DCNL \'objective\': u\'An objective\', DCNL \'status\': \'public\', DCNL \'tags\': [], DCNL \'thumbnail_bg_color\': \'#a33f40\', DCNL \'thumbnail_icon_url\': self.get_static_asset_url( DCNL \'/images/subjects/Lightbulb.svg\'), DCNL \'title\': u\'Exploration 2 Albert title\','
def classify(state, answer): DCNL 'Classify the answer using the string classifier. DCNL This should only be called if the string classifier functionality is DCNL enabled, and the interaction is trainable. DCNL Normalize the answer and classifies the answer if the interaction has a DCNL classifier associated with it. Otherwise, classifies the answer to the DCNL default outcome. DCNL Returns a dict with the following keys: DCNL \'outcome\': A dict representing the outcome of the answer group matched. DCNL \'answer_group_index\': An index into the answer groups list indicating DCNL which one was selected as the group which this answer belongs to. DCNL This is equal to the number of answer groups if the default outcome DCNL was matched. DCNL \'rule_spec_index\': An index into the rule specs list of the matched DCNL answer group which was selected that indicates which rule spec was DCNL matched. This is equal to 0 if the default outcome is selected. DCNL When the default rule is matched, outcome is the default_outcome of the DCNL state\'s interaction.'
def classify_string_classifier_rule(state, normalized_answer): DCNL 'Run the classifier if no prediction has been made yet. Currently this DCNL is behind a development flag.'
def handle_trainable_states(exploration, state_names): DCNL 'Creates ClassifierTrainingJobModel instances for all the state names DCNL passed into the function. If this function is called with version number 1, DCNL we are creating jobs for all trainable states in the exploration. Otherwise, DCNL a new job is being created for the states where retraining is required. DCNL Args: DCNL exploration: Exploration. The Exploration domain object. DCNL state_names: list(str). List of state names.'
def handle_non_retrainable_states(exploration, state_names, new_to_old_state_names): DCNL 'Creates new TrainingJobExplorationMappingModel instances for all the DCNL state names passed into the function. The mapping is created from the DCNL state in the new version of the exploration to the ClassifierTrainingJob of DCNL the state in the older version of the exploration. If there\'s been a change DCNL in the state name, we retrieve the old state name and create the mapping DCNL accordingly. DCNL This method is called only from exp_services._save_exploration() method and DCNL is never called from exp_services._create_exploration(). DCNL In this method, the current_state_name refers to the name of the state in DCNL the current version of the exploration whereas the old_state_name refers to DCNL the name of the state in the previous version of the exploration. DCNL Args: DCNL exploration: Exploration. The Exploration domain object. DCNL state_names: list(str). List of state names. DCNL new_to_old_state_names: dict. Dict mapping new state names to their DCNL corresponding state names in previous version. DCNL Raises: DCNL Exception. This method should not be called by exploration with version DCNL number 1.'
def get_classifier_from_model(classifier_data_model): DCNL 'Gets a classifier domain object from a classifier data model. DCNL Args: DCNL classifier_data_model: Classifier data model instance in datastore. DCNL Returns: DCNL classifier: Domain object for the classifier.'
def get_classifier_by_id(classifier_id): DCNL 'Gets a classifier from a classifier id. DCNL Args: DCNL classifier_id: str. ID of the classifier. DCNL Returns: DCNL classifier: Domain object for the classifier. DCNL Raises: DCNL Exception: Entity for class ClassifierDataModel with id not found.'
def create_classifier(job_id, classifier_data): DCNL 'Creates classifier data model in the datastore given a classifier DCNL domain object. DCNL Args: DCNL job_id: str. ID of the ClassifierTrainingJob corresponding to the DCNL classifier. DCNL classifier_data: dict. The trained classifier data. DCNL Returns: DCNL classifier_id: str. ID of the classifier. DCNL Raises: DCNL Exception. The ClassifierDataModel corresponding to the job already DCNL exists. DCNL Exception. The algorithm_id of the job does not exist in the Interaction DCNL Classifier Mapping.'
def delete_classifier(classifier_id): DCNL 'Deletes classifier data model in the datastore given classifier_id. DCNL Args: DCNL classifier_id: str. ID of the classifier.'
def get_classifier_training_job_from_model(classifier_training_job_model): DCNL 'Gets a classifier training job domain object from a classifier DCNL training job model. DCNL Args: DCNL classifier_training_job_model: ClassifierTrainingJobModel. Classifier DCNL training job instance in datastore. DCNL Returns: DCNL classifier_training_job: ClassifierTrainingJob. Domain object for the DCNL classifier training job.'
def get_classifier_training_job_by_id(job_id): DCNL 'Gets a classifier training job by a job_id. DCNL Args: DCNL job_id: str. ID of the classifier training job. DCNL Returns: DCNL classifier_training_job: ClassifierTrainingJob. Domain object for the DCNL classifier training job. DCNL Raises: DCNL Exception: Entity for class ClassifierTrainingJobModel with id not DCNL found.'
def _update_classifier_training_job_status(job_id, status): DCNL 'Checks for the existence of the model and then updates it. DCNL Args: DCNL job_id: str. ID of the ClassifierTrainingJob domain object. DCNL status: str. The status to which the job needs to be updated. DCNL Raises: DCNL Exception. The ClassifierTrainingJobModel corresponding to the job_id DCNL of the ClassifierTrainingJob does not exist.'
def mark_training_job_complete(job_id): DCNL 'Updates the training job\'s status to complete. DCNL Args: DCNL job_id: str. ID of the ClassifierTrainingJob.'
def delete_classifier_training_job(job_id): DCNL 'Deletes classifier training job model in the datastore given job_id. DCNL Args: DCNL job_id: str. ID of the classifier training job.'
def get_classifier_training_jobs(exp_id, exp_version, state_names): DCNL 'Gets the classifier training job object from the exploration attributes. DCNL Args: DCNL exp_id: str. ID of the exploration. DCNL exp_version: int. The exploration version. DCNL state_names: list(str). The state names for which we retrieve the job. DCNL Returns: DCNL list(ClassifierTrainingJob). Domain objects for the Classifier training DCNL job model.'
def _require_sender_id_is_valid(intent, sender_id): DCNL 'Ensure that the sender ID is valid, based on the email\'s intent. DCNL Many emails are only allowed to be sent by a certain user or type of user, DCNL e.g. \'admin\' or an admin/moderator. This function will raise an exception DCNL if the given sender is not allowed to send this type of email. DCNL Args: DCNL intent: str. The intent string, i.e. the purpose of the email. DCNL Valid intent strings are defined in feconf.py. DCNL sender_id: str. The ID of the user sending the email. DCNL Raises: DCNL Exception: The email intent is invalid. DCNL Exception: The sender_id is not appropriate for the given intent.'
def _send_email(recipient_id, sender_id, intent, email_subject, email_html_body, sender_email, bcc_admin=False, sender_name=None, reply_to_id=None): DCNL 'Sends an email to the given recipient. DCNL This function should be used for sending all user-facing emails. DCNL Raises an Exception if the sender_id is not appropriate for the given DCNL intent. Currently we support only system-generated emails and emails DCNL initiated by moderator actions. DCNL Args: DCNL recipient_id: str. The user ID of the recipient. DCNL sender_id: str. The user ID of the sender. DCNL intent: str. The intent string for the email, i.e. the purpose/type. DCNL email_subject: str. The subject of the email. DCNL email_html_body: str. The body (message) of the email. DCNL sender_email: str. The sender\'s email address. DCNL bcc_admin: bool. Whether to send a copy of the email to the admin\'s DCNL email address. DCNL sender_name: str or None. The name to be shown in the "sender" field of DCNL the email. DCNL reply_to_id: str or None. The unique reply-to id used in reply-to email DCNL address sent to recipient.'
def _send_bulk_mail(recipient_ids, sender_id, intent, email_subject, email_html_body, sender_email, sender_name, instance_id=None): DCNL 'Sends an email to all given recipients. DCNL Args: DCNL recipient_ids: list(str). The user IDs of the email recipients. DCNL sender_id: str. The ID of the user sending the email. DCNL intent: str. The intent string, i.e. the purpose of the email. DCNL email_subject: str. The subject of the email. DCNL email_html_body: str. The body (message) of the email. DCNL sender_email: str. The sender\'s email address. DCNL sender_name: str. The name to be shown in the "sender" field of the DCNL email. DCNL instance_id: str or None. The ID of the BulkEmailModel entity instance.'
def send_mail_to_admin(email_subject, email_body): DCNL 'Send an email to the admin email address. DCNL The email is sent to the ADMIN_EMAIL_ADDRESS set in feconf.py. DCNL Args: DCNL email_subject: str. Subject of the email. DCNL email_body: str. Body (message) of the email.'
def send_post_signup_email(user_id): DCNL 'Sends a post-signup email to the given user. DCNL Raises an exception if emails are not allowed to be sent to users (i.e. DCNL feconf.CAN_SEND_EMAILS is False). DCNL Args: DCNL user_id: str. User ID of the user that signed up.'
def require_valid_intent(intent): DCNL 'Checks if the given intent is valid, and raises an exception if it is DCNL not. DCNL Raises: DCNL Exception: The given intent did not match an entry in DCNL feconf.VALID_MODERATOR_ACTIONS.'
def _get_email_config(intent): DCNL 'Return the default body for the email type matching the given moderator DCNL action intent. DCNL Args: DCNL intent: str. The intent string (cause/purpose) of the email. DCNL Returns: DCNL str. The default body for the email type matching the given moderator DCNL action intent.'
def get_draft_moderator_action_email(intent): DCNL 'Returns a draft of the text of the body for an email sent immediately DCNL following a moderator action. An empty body is a signal to the frontend DCNL that no email will be sent. DCNL Args: DCNL intent: str. The intent string (cause/purpose) of the email. DCNL Returns: DCNL str. Draft of the email body for an email sent after a moderator action, DCNL or an empty string if no email should be sent.'
def require_moderator_email_prereqs_are_satisfied(): DCNL 'Raises an exception if, for any reason, moderator emails cannot be sent. DCNL Raises: DCNL Exception: feconf.REQUIRE_EMAIL_ON_MODERATOR_ACTION is False. DCNL Exception: feconf.CAN_SEND_EMAILS is False.'
def send_moderator_action_email(sender_id, recipient_id, intent, exploration_title, email_body): DCNL 'Sends a email immediately following a moderator action (publicize, DCNL unpublish, delete) to the given user. DCNL Raises an exception if emails are not allowed to be sent to users (i.e. DCNL feconf.CAN_SEND_EMAILS is False). DCNL Args: DCNL sender_id: str. User ID of the sender. DCNL recipient_id: str. User ID of the recipient. DCNL intent: str. The intent string (cause/purpose) of the email. DCNL exploration_title: str. The title of the exploration on which the DCNL moderator action was taken. DCNL email_body: str. The email content/message.'
def send_role_notification_email(inviter_id, recipient_id, recipient_role, exploration_id, exploration_title): DCNL 'Sends a email when a new user is given activity rights (Manager, Editor, DCNL Viewer) to an exploration by creator of exploration. DCNL Email will only be sent if recipient wants to receive these emails (i.e. DCNL \'can_receive_editor_role_email\' is set True in recipent\'s preferences). DCNL Args: DCNL inviter_id: str. ID of the user who invited the recipient to the new DCNL role. DCNL recipient_id: str. User ID of the recipient. DCNL recipient_role: str. Role given to the recipient. Must be defined in DCNL EDITOR_ROLE_EMAIL_HTML_ROLES. DCNL exploration_id: str. ID of the exploration for which the recipient has DCNL been given the new role. DCNL exploration_title: str. Title of the exploration for which the recipient DCNL has been given the new role. DCNL Raises: DCNL Exception: The role is invalid (i.e. not defined in DCNL EDITOR_ROLE_EMAIL_HTML_ROLES).'
def send_emails_to_subscribers(creator_id, exploration_id, exploration_title): DCNL 'Sends an email to all the subscribers of the creators when the creator DCNL publishes an exploration. DCNL Args: DCNL creator_id: str. The id of the creator who has published an exploration DCNL and to whose subscribers we are sending emails. DCNL exploration_id: str. The id of the exploration which the creator has DCNL published. DCNL exploration_title: str. The title of the exploration which the creator DCNL has published.'
def send_feedback_message_email(recipient_id, feedback_messages): DCNL 'Sends an email when creator receives feedback message to an exploration. DCNL Args: DCNL recipient_id: str. User ID of recipient. DCNL feedback_messages: dict. Contains feedback messages. Example: DCNL \'exploration_id\': { DCNL \'title\': \'Exploration 1234\', DCNL \'messages\': [\'Feedback message 1\', \'Feedback message 2\']'
def can_users_receive_thread_email(recipient_ids, exploration_id, has_suggestion): DCNL 'Returns if users can receive email. DCNL Args: DCNL recipient_ids: list(str). IDs of persons that should receive the email. DCNL exploration_id: str. ID of exploration that received new message. DCNL has_suggestion: bool. True if thread contains suggestion. DCNL Returns: DCNL list(bool). True if user can receive the email, False otherwise.'
def send_suggestion_email(exploration_title, exploration_id, author_id, recipient_list): DCNL 'Send emails to notify the given recipients about new suggestion. DCNL Each recipient will only be emailed if their email preferences allow for DCNL incoming feedback message emails. DCNL Args: DCNL exploration_title: str. Title of the exploration with the new DCNL suggestion. DCNL exploration_id: str. The ID of the exploration with the new suggestion. DCNL author_id: str. The user ID of the author of the suggestion. DCNL recipient_list: list(str). The user IDs of the email recipients.'
def send_instant_feedback_message_email(recipient_id, sender_id, message, email_subject, exploration_title, exploration_id, thread_title, reply_to_id=None): DCNL 'Send an email when a new message is posted to a feedback thread, or when DCNL the thread\'s status is changed. DCNL Args: DCNL recipient_id: str. The user ID of the recipient. DCNL sender_id: str. The user ID of the sender. DCNL message: str. The message text or status change text from the sender. DCNL email_subject: str. The subject line to be sent in the email. DCNL exploration_title: str. The title of the exploration. DCNL exploration_id: str. ID of the exploration the feedback thread is about. DCNL thread_title: str. The title of the feedback thread. DCNL reply_to_id: str or None. The unique reply-to id used in reply-to email DCNL sent to recipient.'
def send_flag_exploration_email(exploration_title, exploration_id, reporter_id, report_text): DCNL 'Send an email to all moderators when an exploration is flagged. DCNL Args: DCNL exploration_title: str. The title of the flagged exporation. DCNL exploration_id: str. The ID of the flagged exploration. DCNL reporter_id: str. The user ID of the reporter. DCNL report_text: str. The message entered by the reporter.'
def send_query_completion_email(recipient_id, query_id): DCNL 'Send an email to the initiator of a bulk email query with a link to view DCNL the query results. DCNL Args: DCNL recipient_id: str. The recipient ID. DCNL query_id: str. The query ID.'
def send_query_failure_email(recipient_id, query_id, query_params): DCNL 'Send an email to the initiator of a failed bulk email query. DCNL Args: DCNL recipient_id: str. The recipient ID. DCNL query_id: str. The query ID. DCNL query_params: dict. The parameters of the query, as key:value.'
def subscribe_to_thread(user_id, feedback_thread_id): DCNL 'Subscribes a user to a feedback thread. DCNL Callers of this function should ensure that the user_id and DCNL feedback_thread_id are valid.'
def subscribe_to_exploration(user_id, exploration_id): DCNL 'Subscribes a user to an exploration (and, therefore, indirectly to all DCNL feedback threads for that exploration). DCNL Callers of this function should ensure that the user_id and exploration_id DCNL are valid.'
def subscribe_to_creator(user_id, creator_id): DCNL 'Subscribes a user (learner) to a creator. DCNL Callers of this function should ensure that the user_id and creator_id DCNL are valid.'
def unsubscribe_from_creator(user_id, creator_id): DCNL 'Unsubscribe a user from a creator. DCNL Callers of this function should ensure that the user_id and creator_id DCNL are valid.'
def get_all_threads_subscribed_to(user_id): DCNL 'Returns a list with ids of all the feedback and suggestion threads to DCNL which the user is subscribed. DCNL Callers of this function should ensure that the user_id is valid.'
def get_all_creators_subscribed_to(user_id): DCNL 'Returns a list with ids of all the creators to which this learner has DCNL subscribed. DCNL Callers of this function should ensure that the user_id is valid.'
def get_all_subscribers_of_creator(user_id): DCNL 'Returns a list with ids of all users who have subscribed to this DCNL creator. DCNL Callers of this function should ensure that the user_id is valid.'
def get_exploration_ids_subscribed_to(user_id): DCNL 'Returns a list with ids of all explorations that the given user DCNL subscribes to. DCNL Callers of this function should ensure that the user_id is valid.'
def subscribe_to_collection(user_id, collection_id): DCNL 'Subscribes a user to a collection. DCNL Callers of this function should ensure that the user_id and collection_id DCNL are valid.'
def get_collection_ids_subscribed_to(user_id): DCNL 'Returns a list with ids of all collections that the given user DCNL subscribes to. DCNL Callers of this function should ensure that the user_id is valid.'
def get_last_seen_notifications_msec(user_id): DCNL 'Returns the last time, in milliseconds since the Epoch, when the user DCNL checked their notifications in the dashboard page or the notifications DCNL dropdown. DCNL If the user has never checked the dashboard page or the notifications DCNL dropdown, returns None.'
def record_user_has_seen_notifications(user_id, last_seen_msecs): DCNL 'Updates the last_checked time for this user (which represents the time DCNL the user last saw the notifications in the dashboard page or the DCNL notifications dropdown).'
def is_username_taken(username): DCNL '"Returns whether the given username has already been taken. DCNL Args: DCNL username: str. Identifiable username to display in the UI. DCNL Returns: DCNL bool. Whether the given username is taken.'
def get_email_from_user_id(user_id): DCNL 'Gets the email from a given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL Returns: DCNL str. user_email corresponding to the given user_id. DCNL Raises: DCNL Exception: The user is not found.'
def get_email_from_username(username): DCNL 'Gets the email for a given username. DCNL Args: DCNL username: str. Identifiable username to display in the UI. DCNL Returns: DCNL str or None. If the user with given username does not exist, DCNL return None. Otherwise return the corresponding user_email.'
def get_user_id_from_username(username): DCNL 'Gets the user_id for a given username. DCNL Args: DCNL username: str. Identifiable username to display in the UI. DCNL Returns: DCNL str or None. If the user with given username does not exist, return DCNL None. Otherwise return the user_id corresponding to given username.'
def get_user_settings_from_username(username): DCNL 'Gets the user settings for a given username. DCNL Args: DCNL username: str. Identifiable username to display in the UI. DCNL Returns: DCNL UserSettingsModel or None. The UserSettingsModel instance corresponding DCNL to the given username, or None if no such model was found.'
def get_users_settings(user_ids): DCNL 'Gets domain objects representing the settings for the given user_ids. DCNL Args: DCNL user_ids: list(str). The list of user_ids to get UserSettings DCNL domain objects for. DCNL Returns: DCNL list(UserSettings|None). The UserSettings domain objects corresponding DCNL to the given user ids. If the given user_id does not exist, the DCNL corresponding entry in the returned list is None.'
def generate_initial_profile_picture(user_id): DCNL 'Generates a profile picture for a new user and DCNL updates the user\'s settings in the datastore. DCNL Args: DCNL user_id: str. The user id.'
def get_gravatar_url(email): DCNL 'Returns the gravatar url for the specified email. DCNL Args: DCNL email: str. The user email. DCNL Returns: DCNL str. The gravatar url for the specified email.'
def fetch_gravatar(email): DCNL 'Returns the gravatar corresponding to the user\'s email, or an DCNL identicon generated from the email if the gravatar doesn\'t exist. DCNL Args: DCNL email: str. The user email. DCNL Returns: DCNL str. The gravatar url corresponding to the given user email. If the call DCNL to the gravatar service fails, this returns DEFAULT_IDENTICON_DATA_URL DCNL and logs an error.'
def get_profile_pictures_by_user_ids(user_ids): DCNL 'Gets the profile_picture_data_url from the domain objects DCNL representing the settings for the given user_ids. DCNL Args: DCNL user_ids: list(str). The list of user_ids to get DCNL profile_picture_data_url for. DCNL Returns: DCNL dict. A dictionary whose keys are user_ids and whose corresponding DCNL values are their profile_picture_data_url entries. If a user_id does DCNL not exist, the corresponding value is None.'
def get_user_settings(user_id, strict=False): DCNL 'Return the user settings for a single user. DCNL Args: DCNL user_id: str. The user id. DCNL strict: bool. Whether to fail noisily if no user with the given DCNL id exists in the datastore. Defaults to False. DCNL Returns: DCNL UserSettings or None. If the given user_id does not exist and strict DCNL is False, returns None. Otherwise, returns the corresponding DCNL UserSettings domain object. DCNL Raises: DCNL Exception: strict is True and given user_id does not exist.'
def get_user_role_from_id(user_id): DCNL 'Returns role of the user with given user_id. DCNL Args: DCNL user_id: str. The User id. DCNL Returns: DCNL str. Role of the user with given id.'
def get_usernames_by_role(role): DCNL 'Get usernames of all the users with given role Id. DCNL Args: DCNL role: str. The role Id of users requested. DCNL Returns: DCNL list(str). List of usernames of users with given role Id.'
def _save_user_settings(user_settings): DCNL 'Commits a user settings object to the datastore. DCNL Args: DCNL user_settings: UserSettings domain object.'
def is_user_registered(user_id): DCNL 'Checks if a user is registered with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL Returns: DCNL bool. Whether a user with the given user_id is registered.'
def has_ever_registered(user_id): DCNL 'Checks if a user has ever been registered with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL Returns: DCNL bool. Whether a user with the given user_id has ever been registered.'
def has_fully_registered(user_id): DCNL 'Checks if a user has fully registered. DCNL Args: DCNL user_id: str. The user id. DCNL Returns: DCNL bool. Whether a user with the given user_id has fully registered.'
def create_new_user(user_id, email): DCNL 'Creates a new user. DCNL Args: DCNL user_id: str. The user id. DCNL email: str. The user email. DCNL Returns: DCNL UserSettings. The newly-created user settings domain object. DCNL Raises: DCNL Exception: If a user with the given user_id already exists.'
def get_username(user_id): DCNL 'Gets username corresponding to the given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL Returns: DCNL str. Username corresponding to the given user_id.'
def get_usernames(user_ids): DCNL 'Gets usernames corresponding to the given user_ids. DCNL Args: DCNL user_ids: list(str). The list of user_ids to get usernames for. DCNL Returns: DCNL list(str|None). Containing usernames based on given user_ids. DCNL If a user_id does not exist, the corresponding entry in the DCNL returned list is None.'
def set_username(user_id, new_username): DCNL 'Updates the username of the user with the given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL new_username: str. The new username to set. DCNL Raises: DCNL ValidationError: The new_username supplied is already taken.'
def record_agreement_to_terms(user_id): DCNL 'Records that the user with given user_id has agreed to the license terms. DCNL Args: DCNL user_id: str. The user id.'
def update_profile_picture_data_url(user_id, profile_picture_data_url): DCNL 'Updates profile_picture_data_url of user with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL profile_picture_data_url: str. New profile picture url to be set.'
def update_user_bio(user_id, user_bio): DCNL 'Updates user_bio of user with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL user_bio: str. New user biography to be set.'
def update_user_default_dashboard(user_id, default_dashboard): DCNL 'Updates the default dashboard of user with given user id. DCNL Args: DCNL user_id: str. The user id. DCNL default_dashboard: str. The dashboard the user wants.'
def update_subject_interests(user_id, subject_interests): DCNL 'Updates subject_interests of user with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL subject_interests: list(str). New subject interests to be set.'
def _update_first_contribution_msec(user_id, first_contribution_msec): DCNL 'Updates first_contribution_msec of user with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL first_contribution_msec: float. New time to set in milliseconds DCNL representing user\'s first contribution to Oppia.'
def update_first_contribution_msec_if_not_set(user_id, first_contribution_msec): DCNL 'Updates first_contribution_msec of user with given user_id DCNL if it is set to None. DCNL Args: DCNL user_id: str. The user id. DCNL first_contribution_msec: float. New time to set in milliseconds DCNL representing user\'s first contribution to Oppia.'
def update_preferred_language_codes(user_id, preferred_language_codes): DCNL 'Updates preferred_language_codes of user with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL preferred_language_codes: list(str). New exploration language DCNL preferences to set.'
def update_preferred_site_language_code(user_id, preferred_site_language_code): DCNL 'Updates preferred_site_language_code of user with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL preferred_site_language_code: str. New system language preference DCNL to set.'
def update_user_role(user_id, role): DCNL 'Updates the role of the user with given user_id. DCNL Args: DCNL user_id: str. Id of user whose role is to be updated. DCNL role: str. The role to be assigned to user with given id. DCNL Raises: DCNL Exception: The given role does not exist.'
def get_human_readable_user_ids(user_ids): DCNL 'Converts the given ids to usernames, or truncated email addresses. DCNL Requires all users to be known. DCNL Args: DCNL user_ids: list(str). The list of user_ids to get UserSettings domain DCNL objects for. DCNL Returns: DCNL list(str). List of usernames corresponding to given user_ids. If DCNL username does not exist, the corresponding entry in the returned DCNL list is the user\'s truncated email address. DCNL Raises: DCNL Exception: At least one of the user_ids does not correspond to a valid DCNL UserSettingsModel.'
def record_user_started_state_editor_tutorial(user_id): DCNL 'Updates last_started_state_editor_tutorial to the current datetime DCNL for the user with given user_id. DCNL Args: DCNL user_id: str. The user id.'
def record_user_logged_in(user_id): DCNL 'Updates last_logged_in to the current datetime for the user with DCNL given user_id. DCNL Args: DCNL user_id: str. The user id.'
def record_user_edited_an_exploration(user_id): DCNL 'Updates last_edited_an_exploration to the current datetime for DCNL the user with given user_id. DCNL Args: DCNL user_id: str. The user id.'
def record_user_created_an_exploration(user_id): DCNL 'Updates last_created_an_exploration to the current datetime for DCNL the user with given user_id. DCNL Args: DCNL user_id: str. The user id.'
def update_email_preferences(user_id, can_receive_email_updates, can_receive_editor_role_email, can_receive_feedback_email, can_receive_subscription_email): DCNL 'Updates whether the user has chosen to receive email updates. DCNL If no UserEmailPreferencesModel exists for this user, a new one will DCNL be created. DCNL Args: DCNL user_id: str. The user id. DCNL can_receive_email_updates: bool. Whether the given user can receive DCNL email updates. DCNL can_receive_editor_role_email: bool. Whether the given user can receive DCNL emails notifying them of role changes. DCNL can_receive_feedback_email: bool. Whether the given user can receive DCNL emails when users submit feedback to their explorations. DCNL can_receive_subscription_email: bool. Whether the given user can receive DCNL emails related to his/her creator subscriptions.'
def get_email_preferences(user_id): DCNL 'Gives email preferences of user with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL Returns: DCNL UserGlobalPrefs. Representing whether the user has chosen to receive DCNL email updates.'
def get_users_email_preferences(user_ids): DCNL 'Get email preferences for the list of users. DCNL Args: DCNL user_ids: list. A list of user IDs for whom we want to get email DCNL preferences. DCNL Returns: DCNL list(UserGlobalPrefs). Representing whether the users had chosen to DCNL receive email updates.'
def set_email_preferences_for_exploration(user_id, exploration_id, mute_feedback_notifications=None, mute_suggestion_notifications=None): DCNL 'Sets mute preferences for exploration with given exploration_id of user DCNL with given user_id. DCNL If no ExplorationUserDataModel exists for this user and exploration, DCNL a new one will be created. DCNL Args: DCNL user_id: str. The user id. DCNL exploration_id: str. The exploration id. DCNL mute_feedback_notifications: bool. Whether the given user has muted DCNL feedback emails. Defaults to None. DCNL mute_suggestion_notifications: bool. Whether the given user has muted DCNL suggestion emails. Defaults to None.'
def get_email_preferences_for_exploration(user_id, exploration_id): DCNL 'Gives mute preferences for exploration with given exploration_id of user DCNL with given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL exploration_id: str. The exploration id. DCNL Returns: DCNL UserExplorationPrefs. Representing whether the user has chosen to DCNL receive email updates for particular exploration.'
def get_users_email_preferences_for_exploration(user_ids, exploration_id): DCNL 'Gives mute preferences for exploration with given exploration_id of user DCNL with given user_id. DCNL Args: DCNL user_id: list. A list of user IDs for whom we want to get email DCNL preferences. DCNL exploration_id: str. The exploration id. DCNL Returns: DCNL list(UserExplorationPrefs). Representing whether the users has chosen to DCNL receive email updates for particular exploration.'
def get_user_contributions(user_id, strict=False): DCNL 'Gets domain object representing the contributions for the given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL strict: bool. Whether to fail noisily if no user with the given DCNL id exists in the datastore. Defaults to False. DCNL Returns: DCNL UserContributions or None. If the given user_id does not exist, return DCNL None. Otherwise, return the corresponding UserContributions domain DCNL object.'
def create_user_contributions(user_id, created_exploration_ids, edited_exploration_ids): DCNL 'Creates a new UserContributionsModel and returns the domain object. DCNL Args: DCNL user_id: str. The user id. DCNL created_exploration_ids: list(str). IDs of explorations that this DCNL user has created. DCNL edited_exploration_ids: list(str). IDs of explorations that this DCNL user has edited. DCNL Returns: DCNL UserContributions. The domain object representing the newly-created DCNL UserContributionsModel. DCNL Raises: DCNL Exception: The UserContributionsModel for the given user_id already DCNL exists.'
def update_user_contributions(user_id, created_exploration_ids, edited_exploration_ids): DCNL 'Updates an existing UserContributionsModel with new calculated DCNL contributions. DCNL Args: DCNL user_id: str. The user id. DCNL created_exploration_ids: list(str). IDs of explorations that this DCNL user has created. DCNL edited_exploration_ids: list(str). IDs of explorations that this DCNL user has edited. DCNL Raises: DCNL Exception: The UserContributionsModel for the given user_id does not DCNL exist.'
def add_created_exploration_id(user_id, exploration_id): DCNL 'Adds an exploration_id to a user_id\'s UserContributionsModel collection DCNL of created explorations. DCNL Args: DCNL user_id: str. The user id. DCNL exploration_id: str. The exploration id.'
def add_edited_exploration_id(user_id, exploration_id): DCNL 'Adds an exploration_id to a user_id\'s UserContributionsModel collection DCNL of edited explorations. DCNL Args: DCNL user_id: str. The user id. DCNL exploration_id: str. The exploration id.'
def _save_user_contributions(user_contributions): DCNL 'Commits a user contributions object to the datastore. DCNL Args: DCNL user_contributions: UserContributions. Value object representing DCNL a user\'s contributions.'
def _migrate_dashboard_stats_to_latest_schema(versioned_dashboard_stats): DCNL 'Holds responsibility of updating the structure of dashboard stats. DCNL Args: DCNL versioned_dashboard_stats: UserStatsModel. Value object representing DCNL user-specific statistics. DCNL Raises: DCNL Exception: If schema_version > CURRENT_DASHBOARD_STATS_SCHEMA_VERSION.'
def get_current_date_as_string(): DCNL 'Gets the current date. DCNL Returns: DCNL str. Current date as a string of format \'YYYY-MM-DD\'.'
def parse_date_from_string(datetime_str): DCNL 'Parses the given string, and returns the year, month and day of the DCNL date that it represents. DCNL Args: DCNL datetime_str: str. String representing datetime. DCNL Returns: DCNL dict. Representing date with year, month and day as keys.'
def get_user_impact_score(user_id): DCNL 'Gets the user impact score for the given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL Returns: DCNL float. The user impact score associated with the given user_id. DCNL Returns 0 if UserStatsModel does not exist for the given user_id.'
def get_weekly_dashboard_stats(user_id): DCNL 'Gets weekly dashboard stats for a given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL Returns: DCNL list(dict): The weekly dashboard stats for the given user. Each dict in DCNL the list denotes the dashboard stats of the user, keyed by a datetime DCNL string. The stats currently being saved are: DCNL - \'average ratings\': Average of ratings across all explorations of DCNL a user. DCNL - \'total plays\': Total number of plays across all explorations of DCNL a user. DCNL The format of returned value: DCNL {{datetime_string_1}}: { DCNL \'num_ratings\': (value), DCNL \'average_ratings\': (value), DCNL \'total_plays\': (value) DCNL {{datetime_string_2}}: { DCNL \'num_ratings\': (value), DCNL \'average_ratings\': (value), DCNL \'total_plays\': (value) DCNL If the user doesn\'t exist, then this function returns None.'
def get_last_week_dashboard_stats(user_id): DCNL 'Gets last week\'s dashboard stats for a given user_id. DCNL Args: DCNL user_id: str. The user id. DCNL Returns: DCNL list(dict): The weekly dashboard stats for the given user. Each dict DCNL in the list denotes dashboard stats of the user, keyed by a datetime DCNL string. If the user doesn\'t exist, then this function returns None.'
def update_dashboard_stats_log(user_id): DCNL 'Save statistics for creator dashboard of a user by appending to a list DCNL keyed by a datetime string. DCNL Args: DCNL user_id: str. The user id.'
def update_admin_ids(committer_id, admin_usernames): DCNL 'Refresh the list of admin user_ids based on the usernames entered.'
def update_moderator_ids(committer_id, moderator_usernames): DCNL 'Refresh the list of moderator user_ids based on the usernames DCNL entered.'
def _get_change_list(state_name, property_name, new_value): DCNL 'Generates a change list for a single state change.'
def _get_full_customization_args(customization_args, ca_specs): DCNL 'Populates the given customization_args dict with default values DCNL if any of the expected customization_args are missing. DCNL Args: DCNL customization_args: dict. The customization dict. The keys are names of DCNL customization_args and the values are dicts with a DCNL single key, \'value\', whose corresponding value is the value of DCNL the customization arg. DCNL ca_specs: list(dict). List of spec dictionaries. Is used to check if DCNL some keys are missing in customization_args. Dicts have the DCNL following structure: DCNL - name: str. The customization variable name. DCNL - description: str. The customization variable description. DCNL - default_value: *. The default value of the customization DCNL variable. DCNL Returns: DCNL dict. The customization_args dict where missing keys are populated with DCNL the default values.'
def _validate_customization_args_and_values(item_name, item_type, customization_args, ca_specs_to_validate_against): DCNL 'Validates the given `customization_args` dict against the specs set out DCNL in \'ca_specs_to_validate_against\'. \'item_name\' and \'item_type\' are used to DCNL populate any error messages that arise during validation. DCNL Note that this may modify the given customization_args dict, if it has DCNL extra or missing keys. It also normalizes any HTML in the DCNL customization_args dict. DCNL Args: DCNL item_name: str. The item_name is either \'interaction\', \'gadget\' or DCNL \'trigger\'. DCNL item_type: str. The item_type is the id/type of the DCNL interaction/gadget/trigger, respectively. DCNL customization_args: dict. The customization dict. The keys are names of DCNL customization_args and the values are dicts with a DCNL single key, \'value\', whose corresponding value is the value of DCNL the customization arg. DCNL ca_specs_to_validate_against: list(dict). List of spec dictionaries. Is DCNL used to check if some keys are missing in customization_args. Dicts DCNL have the following structure: DCNL - name: str. The customization variable name. DCNL - description: str. The customization variable description. DCNL - default_value: *. The default value of the customization DCNL variable. DCNL Raises: DCNL ValidationError: The given \'customization_args\' is not valid.'
def open_access(handler): DCNL 'Decorator to give access to everyone.'
def can_play_exploration(handler): DCNL 'Decorator to check whether user can play given exploration.'
def can_play_collection(handler): DCNL 'Decorator to check whether user can play given collection.'
def can_download_exploration(handler): DCNL 'Decorator to check whether user can download given exploration. DCNL If a user is authorized to play given exploration, they can download it.'
def can_view_exploration_stats(handler): DCNL 'Decorator to check whether user can view exploration stats. DCNL If a user is authorized to play given exploration, they can view its stats.'
def can_edit_collection(handler): DCNL 'Decorator to check whether the user can edit collection.'
def can_manage_email_dashboard(handler): DCNL 'Decorator to check whether user can access email dashboard.'
def can_access_moderator_page(handler): DCNL 'Decorator to check whether user can access moderator page.'
def can_send_moderator_emails(handler): DCNL 'Decorator to check whether user can send moderator emails.'
def can_manage_own_profile(handler): DCNL 'Decorator to check whether user can manage his profile.'
def can_access_admin_page(handler): DCNL 'Decorator that checks if the current user is a super admin.'
def can_upload_exploration(handler): DCNL 'Decorator that checks if the current user can upload exploration.'
def can_create_exploration(handler): DCNL 'Decorator to check whether the user can create an exploration.'
def can_create_collection(handler): DCNL 'Decorator to check whether the user can create a collection.'
def can_access_creator_dashboard(handler): DCNL 'Decorator to check whether the user can access creator dashboard DCNL page.'
def can_comment_on_feedback_thread(handler): DCNL 'Decorator to check whether the user can view feedback for a given DCNL exploration.'
def can_rate_exploration(handler): DCNL 'Decorator to check whether the user can give rating to given DCNL exploration.'
def can_flag_exploration(handler): DCNL 'Decorator to check whether user can flag given exploration.'
def can_subscribe_to_users(handler): DCNL 'Decorator to check whether user can subscribe/unsubscribe a creator.'
def can_edit_exploration(handler): DCNL 'Decorator to check whether the user can edit given exploration.'
def can_delete_exploration(handler): DCNL 'Decorator to check whether user can delete exploration.'
def can_suggest_changes_to_exploration(handler): DCNL 'Decorator to check whether a user can make suggestions to an DCNL exploration.'
def can_publish_exploration(handler): DCNL 'Decorator to check whether user can publish exploration.'
def can_manage_collection_publish_status(handler): DCNL 'Decorator to check whether user can publish exploration.'
def can_modify_exploration_roles(handler): DCNL 'Decorators to check whether user can manage rights related to an DCNL exploration.'
def can_perform_cron_tasks(handler): DCNL 'Decorator to ensure that the handler is being called by cron or by a DCNL superadmin of the application.'
def can_access_learner_dashboard(handler): DCNL 'Decorator to check access to learner dashboard.'
def require_user_id_else_redirect_to_homepage(handler): DCNL 'Decorator that checks if a user_id is associated to the current DCNL session. If not, the user is redirected to the main page. DCNL Note that the user may not yet have registered.'
def _get_node_change_list(exploration_id, property_name, new_value): DCNL 'Generates a change list for a single collection node change.'
def _get_collection_change_list(property_name, new_value): DCNL 'Generates a change list for a single collection property change.'
def _get_added_exploration_change_list(exploration_id): DCNL 'Generates a change list for adding an exploration to a collection.'
def _get_deleted_exploration_change_list(exploration_id): DCNL 'Generates a change list for deleting an exploration from a collection.'
def get_visualizations_info(exploration_id, state_name): DCNL 'Returns a list of visualization info. Each item in the list is a dict DCNL with keys \'data\' and \'options\'. DCNL Args: DCNL exploration_id: str. The exploration ID. DCNL state_name: str. Name of the state. DCNL Returns: DCNL list(dict). Each item in the list is a dict with keys representing DCNL - \'id\': str. The visualization ID. DCNL - \'data\': list(dict). A list of calculation IDs. DCNL - \'options\': dict. The visualization options. DCNL An example of the returned value may be: DCNL [{\'options\': {\'y_axis_label\': \'Count\', \'x_axis_label\': \'Answer\'}, DCNL \'id\': \'BarChart\', DCNL \'data\': [{u\'frequency\': 1, u\'answer\': 0}]}]'
def get_versions_for_exploration_stats(exploration_id): DCNL 'Returns a list of strings, each string representing a version of the DCNL given exploration_id for which statistics data exists. These versions are DCNL retrieved from ExplorationAnnotationsModel created when StatisticsAggregator DCNL job is run. DCNL An example of the return list may look like [u\'3\', u\'all\'] DCNL where \'3\' and \'all\' are versions of the given exploration ID from DCNL ExplorationAnnotationsModel. DCNL Args: DCNL exploration_id: str. The exploration ID. DCNL Returns: DCNL list(str). The versions of the given exploration for which statistics DCNL data exists. These may either be \'all\' (which indicates that the DCNL statistics have been aggregated over all versions), or specific DCNL (stringified) version numbers.'
def get_exploration_stats(exploration_id, exploration_version): DCNL 'Returns a dict with state statistics for the given exploration id. DCNL Args: DCNL exploration_id: str. The exploration ID. DCNL exploration_version: str. The version of the exploration from DCNL ExplorationAnnotationsModel. It can be \'all\' or version number as DCNL string like \'3\'. DCNL Returns: DCNL dict. A dict with state statistics for the given exploration ID. DCNL The keys and values of the dict are as follows: DCNL - \'last_updated\': float. Last updated timestamp of the exploration. DCNL - \'num_starts\': int. The number of "start exploration" events recorded. DCNL - \'num_completions\': int. The number of "complete exploration" events DCNL recorded. DCNL - \'state_stats\': dict(dict). Contains state stats of states DCNL contained in the given exploration ID. The keys of the dict are the DCNL names of the states and its values are dict containing the DCNL statistics data of the respective state in the key. DCNL The keys and values of the dict are as follows: DCNL - state_name: dict. The statistics data of the state. DCNL The keys and values of the statistics data dict are as follows: DCNL - "first_entry_count": int. The number of sessions which hit DCNL the state. DCNL - "name": str. The name of the state. DCNL - "total_entry_count": int. The total number of hits for the DCNL state. DCNL - "no_submitted_answer_count": int. The number of hits with DCNL no answer for this state.'
def record_answer(exploration_id, exploration_version, state_name, interaction_id, submitted_answer): DCNL 'Record an answer by storing it to the corresponding StateAnswers entity. DCNL Args: DCNL exploration_id: str. The exploration ID. DCNL exploration_version: int. The version of the exploration. DCNL state_name: str. The name of the state. DCNL interaction_id: str. The ID of the interaction. DCNL submitted_answer: SubmittedAnswer. The submitted answer.'
def record_answers(exploration_id, exploration_version, state_name, interaction_id, submitted_answer_list): DCNL 'Optimally record a group of answers using an already loaded exploration.. DCNL The submitted_answer_list is a list of SubmittedAnswer domain objects. DCNL Args: DCNL exploration_id: str. The exploration ID. DCNL exploration_version: int. The version of the exploration. DCNL state_name: str. The name of the state. DCNL interaction_id: str. The ID of the interaction. DCNL submitted_answer_list: list(SubmittedAnswer). The list of answers to be DCNL recorded.'
def get_state_answers(exploration_id, exploration_version, state_name): DCNL 'Returns a StateAnswers object containing all answers associated with the DCNL specified exploration state, or None if no such answers have yet been DCNL submitted. DCNL Args: DCNL exploration_id: str. The exploration ID. DCNL exploration_version: int. The version of the exploration to fetch DCNL answers for. DCNL state_name: str. The name of the state to fetch answers for. DCNL Returns: DCNL StateAnswers or None. A StateAnswers object containing all answers DCNL associated with the state, or None if no such answers exist.'
def get_sample_answers(exploration_id, exploration_version, state_name): DCNL 'Fetches a list of sample answers that were submitted to the specified DCNL exploration state (at the given version of the exploration). DCNL Args: DCNL exploration_id: str. The exploration ID. DCNL exploration_version: int. The version of the exploration to fetch DCNL answers for. DCNL state_name: str. The name of the state to fetch answers for. DCNL Returns: DCNL list(*). A list of some sample raw answers. At most 100 answers are DCNL returned.'
def get_default_object_values(): DCNL 'Returns a dictionary containing the default object values.'
def assign_rating_to_exploration(user_id, exploration_id, new_rating): DCNL 'Records the rating awarded by the user to the exploration in both the DCNL user-specific data and exploration summary. DCNL This function validates the exploration id but not the user id. DCNL Args: DCNL user_id: str. The id of the user assigning the rating. DCNL exploration_id: str. The id of the exploration that is DCNL assigned a rating. DCNL new_rating: int. Value of assigned rating, should be between DCNL 1 and 5 inclusive.'
def get_user_specific_rating_for_exploration(user_id, exploration_id): DCNL 'Fetches a rating for the specified exploration from the specified user DCNL if one exists. DCNL Args: DCNL user_id: str. The id of the user. DCNL exploration_id: str. The id of the exploration. DCNL Returns: DCNL int or None. An integer between 1 and 5 inclusive, or None if the user DCNL has not previously rated the exploration.'
def get_when_exploration_rated(user_id, exploration_id): DCNL 'Fetches the datetime the exploration was last rated by this user, or DCNL None if no rating has been awarded. DCNL Currently this function is only used for testing purposes. DCNL Args: DCNL user_id: str. The id of the user. DCNL exploration_id: str. The id of the exploration. DCNL Returns: DCNL datetime.datetime or None. When the exploration was last DCNL rated by the user, or None if the user has not previously DCNL rated the exploration.'
def get_overall_ratings_for_exploration(exploration_id): DCNL 'Fetches all ratings for an exploration. DCNL Args: DCNL exploration_id: str. The id of the exploration. DCNL Returns: DCNL a dict whose keys are \'1\', \'2\', \'3\', \'4\', \'5\' and whose DCNL values are nonnegative integers representing the frequency counts DCNL of each rating.'
def _get_activity_rights_from_model(activity_rights_model, activity_type): DCNL 'Constructs an ActivityRights object from the given activity rights model. DCNL Args: DCNL activity_rights_model: ActivityRightsModel. Activity rights from the DCNL datastore. DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL Returns: DCNL ActivityRights. The rights object created from the model.'
def _save_activity_rights(committer_id, activity_rights, activity_type, commit_message, commit_cmds): DCNL 'Saves an ExplorationRights or CollectionRights domain object to the DCNL datastore. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL activity_rights: ActivityRights. The rights object for the given DCNL activity. DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL commit_message: str. Descriptive message for the commit. DCNL commit_cmds: list(dict). A list of commands describing what kind of DCNL commit was done.'
def _update_exploration_summary(activity_rights): DCNL 'Updates the exploration summary for the activity associated with the DCNL given rights object. DCNL The ID of rights object is the same as the ID of associated activity. DCNL Args: DCNL activity_rights: ActivityRights. The rights object for the given DCNL activity.'
def _update_collection_summary(activity_rights): DCNL 'Updates the collection summary for the given activity associated with DCNL the given rights object. DCNL The ID of rights object is the same as the ID of associated activity. DCNL Args: DCNL activity_rights: ActivityRights. The rights object for the given DCNL activity.'
def _update_activity_summary(activity_type, activity_rights): DCNL 'Updates the activity summary for the given activity associated with DCNL the given rights object. DCNL The ID of rights object is the same as the ID of associated activity. DCNL Args: DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL activity_rights: ActivityRights. The rights object for the given DCNL activity.'
def update_activity_first_published_msec(activity_type, activity_id, first_published_msec): DCNL 'Updates the first_published_msec field for the given activity. DCNL The caller is responsible for ensuring that this value is not already DCNL set before updating it. DCNL Args: DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL activity_id: str. ID of the activity. DCNL first_published_msec: float. First publication time in milliseconds DCNL since the Epoch.'
def create_new_exploration_rights(exploration_id, committer_id): DCNL 'Creates a new exploration rights object and saves it to the datastore. DCNL Subscribes the committer to the new exploration. DCNL Args: DCNL exploration_id: str. ID of the exploration. DCNL committer_id: str. ID of the committer.'
def get_exploration_rights(exploration_id, strict=True): DCNL 'Retrieves the rights for this exploration from the datastore. DCNL Args: DCNL exploration_id: str. ID of the exploration. DCNL strict: bool. Whether to raise an error if there is no exploration DCNL matching the given ID. DCNL Returns: DCNL ActivityRights. The rights object for the given exploration. DCNL Raises: DCNL EntityNotFoundError. The exploration with ID exploration_id was not DCNL found in the datastore.'
def is_exploration_private(exploration_id): DCNL 'Returns whether exploration is private. DCNL Args: DCNL exploration_id: str. ID of the exploration. DCNL Returns: DCNL bool. Whether the exploration is private or not.'
def is_exploration_public(exploration_id): DCNL 'Returns whether exploration is public. DCNL Args: DCNL exploration_id: str. ID of the exploration. DCNL Returns: DCNL bool. Whether the exploration is public.'
def is_exploration_cloned(exploration_id): DCNL 'Returns whether the exploration is a clone of another exploration. DCNL Args: DCNL exploration_id: str. ID of the exploration. DCNL Returns: DCNL bool. Whether the exploration is a clone of another exploration.'
def create_new_collection_rights(collection_id, committer_id): DCNL 'Creates a new collection rights object and saves it to the datastore. DCNL Subscribes the committer to the new collection. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL committer_id: str. ID of the committer.'
def get_collection_rights(collection_id, strict=True): DCNL 'Retrieves the rights for this collection from the datastore. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL strict: bool. Whether to raise an error if ID is not found. DCNL Returns: DCNL ActivityRights. The rights object for the collection. DCNL Raises: DCNL EntityNotFoundError. The collection with ID collection_id is not found DCNL in the datastore.'
def get_collection_owner_names(collection_id): DCNL 'Retrieves the owners for this collection from the datastore. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL Returns: DCNL list(str). Human-readable usernames (or truncated email addresses) of DCNL owners for this collection.'
def is_collection_private(collection_id): DCNL 'Returns whether the collection is private. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL Returns: DCNL bool. Whether the collection is private.'
def is_collection_public(collection_id): DCNL 'Returns whether the collection is public. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL Returns: DCNL bool. Whether the collection is public.'
def _get_activity_rights(activity_type, activity_id): DCNL 'Retrieves the rights object for the given activity DCNL based on its type. DCNL Args: DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL activity_id: str. ID of the activity. DCNL Returns: DCNL ActivityRights. The rights object associated with the given activity. DCNL Raises: DCNL Exception. activity_type provided is unknown.'
def _assign_role(committer_id, assignee_id, new_role, activity_id, activity_type): DCNL 'Assigns a new role to the user. DCNL Args: DCNL committer_id: str. ID of the user who is performing the action. DCNL activity_rights: ExplorationRightsModel|CollectionRightsModel. The DCNL storage object for the rights of the given activity. DCNL assignee_id: str. ID of the user whose role is being changed. DCNL new_role: str. The name of the new role: One of DCNL ROLE_OWNER DCNL ROLE_EDITOR DCNL ROLE_VIEWER DCNL activity_id: str. ID of the activity. DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL Raises: DCNL Exception. The committer does not have rights to modify a role. DCNL Exception. The user already owns the activity. DCNL Exception. The user can already edit the activity. DCNL Exception. The activity is already publicly editable. DCNL Exception. The user can already view the activity. DCNL Exception. The activity is already publicly viewable. DCNL Exception. The role is invalid.'
def _release_ownership_of_activity(committer_id, activity_id, activity_type): DCNL 'Releases ownership of the given activity to the community. DCNL Args: DCNL committer_id: str. ID of the user who is performing the action. DCNL activity_id: str. ID of the activity. DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL Raise: DCNL Exception. The committer does not have release rights.'
def _change_activity_status(committer_id, activity_id, activity_type, new_status, commit_message): DCNL 'Changes the status of the given activity. DCNL Args: DCNL committer_id: str. ID of the user who is performing the update action. DCNL activity_id: str. ID of the activity. DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL new_status: str. The new status of the activity. DCNL commit_message: str. The human-written commit message for this change.'
def _publish_activity(committer_id, activity_id, activity_type): DCNL 'Publishes the given activity. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL activity_id: str. ID of the activity. DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL Raises: DCNL Exception. The committer does not have rights to publish the DCNL activity.'
def _unpublish_activity(committer_id, activity_id, activity_type): DCNL 'Unpublishes the given activity. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL activity_id: str. ID of the activity. DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL Raises: DCNL Exception. The committer does not have rights to unpublish the DCNL activity.'
def _publicize_activity(committer_id, activity_id, activity_type): DCNL 'Publicizes the given activity. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL activity_id: str. ID of the activity. DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL Raises: DCNL Exception. The committer does not have rights to publicize the activity.'
def _unpublicize_activity(committer_id, activity_id, activity_type): DCNL 'Unpublicizes the given activity. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL activity_id: str. ID of the activity. DCNL activity_type: str. The type of activity. Possible values: DCNL constants.ACTIVITY_TYPE_EXPLORATION DCNL constants.ACTIVITY_TYPE_COLLECTION DCNL Raises: DCNL Exception. The committer does not have rights to unpublicize the DCNL activity.'
def assign_role_for_exploration(committer_id, exploration_id, assignee_id, new_role): DCNL 'Assigns a user to the given role and subscribes the assignee to future DCNL exploration updates. DCNL The caller should ensure that assignee_id corresponds to a valid user in DCNL the system. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL exploration_id: str. ID of the exploration. DCNL assignee_id: str. ID of the user whose role is being changed. DCNL new_role: str. The name of the new role: One of DCNL ROLE_OWNER DCNL ROLE_EDITOR DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _assign_role.'
def release_ownership_of_exploration(committer_id, exploration_id): DCNL 'Releases ownership of the given exploration to the community. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL exploration_id: str. ID of the exploration. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _release_ownership_of_activity.'
def set_private_viewability_of_exploration(committer_id, exploration_id, viewable_if_private): DCNL 'Sets the viewable_if_private attribute for the given exploration\'s rights DCNL object. DCNL If viewable_if_private is True, this allows a private exploration DCNL to be viewed by anyone with the link. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL exploration_id: str. ID of the exploration. DCNL viewable_if_private: bool. Whether the exploration should be made DCNL viewable (by anyone with the link). DCNL Raises: DCNL Exception. The committer does not have the permission to perform change DCNL action. DCNL Exception. If the viewable_if_private property is already as desired.'
def publish_exploration(committer_id, exploration_id): DCNL 'Publishes the given exploration. DCNL It is the responsibility of the caller to check that the exploration is DCNL valid prior to publication. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL exploration_id: str. ID of the exploration. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _publish_activity.'
def unpublish_exploration(committer_id, exploration_id): DCNL 'Unpublishes the given exploration. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL exploration_id: str. ID of the exploration. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _unpublish_activity.'
def publicize_exploration(committer_id, exploration_id): DCNL 'Publicizes the given exploration. DCNL It is the responsibility of the caller to check that the exploration is DCNL valid prior to publicizing it. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL exploration_id: str. ID of the exploration. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _publicize_activity.'
def unpublicize_exploration(committer_id, exploration_id): DCNL 'Unpublicizes the given exploration. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL exploration_id: str. ID of the exploration. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _unpublicize_activity.'
def assign_role_for_collection(committer_id, collection_id, assignee_id, new_role): DCNL 'Assign the given user to the given role and subscribes the assignee DCNL to future collection updates. DCNL The caller should ensure that assignee_id corresponds to a valid user in DCNL the system. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection_id: str. ID of the collection. DCNL assignee_id: str. ID of the user whose role is being changed. DCNL new_role: str. The name of the new role: One of DCNL ROLE_OWNER DCNL ROLE_EDITOR DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _assign_role.'
def release_ownership_of_collection(committer_id, collection_id): DCNL 'Releases ownership of the given collection to the community. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection_id: str. ID of the collection. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _release_ownership_of_activity.'
def publish_collection(committer_id, collection_id): DCNL 'Publishes the given collection. DCNL It is the responsibility of the caller to check that the collection is DCNL valid prior to publication. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection_id: str. ID of the collection. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _publish_activity.'
def unpublish_collection(committer_id, collection_id): DCNL 'Unpublishes the given collection. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection_id: str. ID of the collection. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _unpublish_activity.'
def publicize_collection(committer_id, collection_id): DCNL 'Publicizes the given collection. DCNL It is the responsibility of the caller to check that the collection is DCNL valid prior to publicizing it. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection_id: str. ID of the collection. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _publicize_activity.'
def unpublicize_collection(committer_id, collection_id): DCNL 'Unpublicizes the given collection. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection_id: str. ID of the collection. DCNL Raises: DCNL Exception. This could potentially throw an exception from DCNL _unpublicize_activity.'
def check_can_access_activity(user_id, user_actions, activity_type, activity_rights): DCNL 'Checks whether the user can access given activity. DCNL Args: DCNL user_id: str or None. Id of the given user. DCNL user_actions: list(str). List of actions given user can perform. DCNL activity_type: str. Signifies whether activity is exploration or DCNL collection. DCNL activity_rights: rights_object or None. Rights object of the given DCNL activity. DCNL Returns: DCNL bool. Whether the given activity can be accessed.'
def check_can_edit_activity(user_id, user_actions, activity_type, activity_rights): DCNL 'Checks whether the user can edit given activity. DCNL Args: DCNL user_id: str or None. Id of the given user. DCNL user_actions: list(str). List of actions the user can perform. DCNL activity_type: str. Signifies whether activity is exploration or DCNL collection. DCNL activity_rights: rights_object or None. Rights object of the given DCNL activity. DCNL Returns: DCNL bool. Whether the given user can edit this activity.'
def check_can_unpublish_collection(user_actions, collection_rights): DCNL 'Checks whether the user can unpublish given collection. DCNL Args: DCNL user_actions: list(str). List of actions the user can perform. DCNL collection_rights: rights_object or None. Rights object of given DCNL collection. DCNL Returns: DCNL bool. Whether the user can unpublish given collection.'
def check_can_delete_exploration(user_id, user_actions, exploration_rights): DCNL 'Checks whether the user can delete given exploration. DCNL Args: DCNL user_id: str or None. Id of the user. DCNL user_actions: list(str). List of actions the user can perform. DCNL exploration_rights: rights_object or None. Rights object of given DCNL exploration. DCNL Returns: DCNL bool. Whether the user can delete given exploration.'
def check_can_modify_exploration_roles(user_id, user_actions, exploration_rights): DCNL 'Checks whether the user can modify roles for given exploration. DCNL Args: DCNL user_id: str or None. Id of the user. DCNL user_actions: list(str). List of actions the user can perform. DCNL exploration_rights: rights_object or None. Rights Object of given DCNL exploration. DCNL Returns: DCNL bool. Whether the user can modify roles for given exploration.'
def check_can_release_ownership(user_id, user_actions, exploration_rights): DCNL 'Checks whether the user can release ownership for given exploration. DCNL Args: DCNL user_id: str or None. Id of the user. DCNL user_actions: list(str). List of actions the user can perform. DCNL exploration_rights: rights_object or None. Rights Object of given DCNL exploration. DCNL Returns: DCNL bool. Whether the user can release ownership for given exploration.'
def check_can_publish_exploration(user_id, user_actions, exploration_rights): DCNL 'Checks whether the user can publish given exploration. DCNL Args: DCNL user_id: str or None. Id of the user. DCNL user_actions: list(str). List of actions the user can perform. DCNL exploration_rights: rights_object or None. Rights Object of given DCNL exploration. DCNL Returns: DCNL bool. Whether the user can publish given exploration.'
def check_can_publicize_exploration(user_actions, exploration_rights): DCNL 'Checks whether the user can publicize given exploration. DCNL Args: DCNL user_actions: list(str). List of actions the user can perform. DCNL exploration_rights: rights_object or None. Rights object of given DCNL exploration. DCNL Returns: DCNL bool. Whether the user can publicize given exploration.'
def check_can_unpublicize_exploration(user_actions, exploration_rights): DCNL 'Checks whether the user can unpublicize given exploration. DCNL Args: DCNL user_actions: list(str). List of actions the user can perform. DCNL exploration_rights: rights_object or None. Rights object of given DCNL exploration. DCNL Returns: DCNL bool. Whether the user can unpublicize given exploration.'
def check_can_unpublish_exploration(user_actions, exploration_rights): DCNL 'Checks whether the user can unpublish given exploration. DCNL Args: DCNL user_actions: list(str). List of actions the user can perform. DCNL exploration_rights: rights_object or None. Rights object of given DCNL exploration. DCNL Returns: DCNL bool. Whether the user can unpublish given exploration.'
def filter_a(name, value): DCNL 'Returns whether the described attribute of an anchor (\'a\') tag should be DCNL whitelisted. DCNL Args: DCNL name: str. The name of the attribute. DCNL value: str. The value of the attribute. DCNL Returns: DCNL bool. Whether the given attribute should be whitelisted.'
def clean(user_submitted_html): DCNL 'Cleans a piece of user submitted HTML. DCNL This only allows HTML from a restricted set of tags, attrs and styles. DCNL Args: DCNL user_submitted_html: str. An untrusted HTML string. DCNL Returns: DCNL str. The HTML string that results after stripping out unrecognized tags DCNL and attributes.'
def strip_html_tags(html): DCNL 'Strips all HTML markup from an HTML string. DCNL Args: DCNL html: str. An HTML string. DCNL Returns: DCNL str. The HTML string that results after all the tags and attributes are DCNL stripped out.'
def get_rte_components(html_string): DCNL 'Extracts the RTE components from an HTML string. DCNL Args: DCNL html: str. An HTML string. DCNL Returns: DCNL list(dict). A list of dictionaries, each representing an RTE component. DCNL Each dict in the list contains: DCNL - id: str. The name of the component, i.e. \'oppia-noninteractive-link\'. DCNL - customization_args: dict. Customization arg specs for the component.'
def enqueue_flag_exploration_email_task(exploration_id, report_text, reporter_id): DCNL 'Adds a \'send flagged exploration email\' task into taskqueue.'
def _migrate_collection_contents_to_latest_schema(versioned_collection_contents): DCNL 'Holds the responsibility of performing a step-by-step, sequential update DCNL of the collection structure based on the schema version of the input DCNL collection dictionary. This is very similar to the exploration migration DCNL process seen in exp_services. If any of the current collection schemas DCNL change, a new conversion function must be added and some code appended to DCNL this function to account for that new version. DCNL Args: DCNL versioned_collection_contents: A dict with two keys: DCNL - schema_version: str. The schema version for the collection. DCNL - collection_contents: dict. The dict comprising the collection DCNL contents. DCNL Raises: DCNL Exception: The schema version of the collection is outside of what is DCNL supported at present.'
def _get_collection_memcache_key(collection_id, version=None): DCNL 'Returns a memcache key for the collection. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL version: str. Schema version of the collection. DCNL Returns: DCNL str. The memcache key of the collection.'
def get_collection_from_model(collection_model, run_conversion=True): DCNL 'Returns a Collection domain object given a collection model loaded DCNL from the datastore. DCNL Args: DCNL collection_model: CollectionModel. The collection model loaded from the DCNL datastore. DCNL run_conversion: bool. If true, the the collection\'s schema version will DCNL be checked against the current schema version. If they do not match, DCNL the collection will be automatically updated to the latest schema DCNL version. DCNL IMPORTANT NOTE TO DEVELOPERS: In general, run_conversion should DCNL never be False. This option is only used for testing that the DCNL schema version migration works correctly, and it should never be DCNL changed otherwise. DCNL Returns: DCNL Collection. A Collection domain object corresponding to the given DCNL collection model.'
def get_collection_summary_from_model(collection_summary_model): DCNL 'Returns a domain object for an Oppia collection summary given a DCNL collection summary model. DCNL Args: DCNL collection_summary_model: CollectionSummaryModel. DCNL Returns: DCNL CollectionSummary.'
def get_collection_by_id(collection_id, strict=True, version=None): DCNL 'Returns a domain object representing a collection. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL strict: bool. Whether to fail noisily if no collection with the given DCNL id exists in the datastore. DCNL version: str or None. The version number of the collection to be DCNL retrieved. If it is None, the latest version will be retrieved. DCNL Returns: DCNL Collection or None. The domain object representing a collection with the DCNL given id, or None if it does not exist.'
def get_collection_summary_by_id(collection_id): DCNL 'Returns a domain object representing a collection summary. DCNL Args: DCNL collection_id: str. ID of the collection summary. DCNL Returns: DCNL CollectionSummary. The collection summary domain object corresponding to DCNL a collection with the given collection_id.'
def get_multiple_collections_by_id(collection_ids, strict=True): DCNL 'Returns a dict of domain objects representing collections with the DCNL given ids as keys. DCNL Args: DCNL collection_ids: list(str). A list of collection ids of collections to DCNL be retrieved. DCNL strict: bool. Whether to fail noisily if no collection with a given id DCNL exists in the datastore. DCNL Returns: DCNL A dict of domain objects representing collections with the given ids as DCNL keys. DCNL Raises: DCNL ValueError: \'strict\' is True, and one or more of the given collection DCNL ids are invalid.'
def get_new_collection_id(): DCNL 'Returns a new collection id. DCNL Returns: DCNL str. A new collection id.'
def get_collection_titles_and_categories(collection_ids): DCNL 'Returns collection titles and categories for the given ids. DCNL Args: DCNL collection_ids: list(str). IDs of the collections whose titles and DCNL categories are to be retrieved. DCNL Returns: DCNL A dict with collection ids as keys. The corresponding values DCNL are dicts with the keys \'title\' and \'category\'. DCNL Any invalid collection_ids will not be included in the return dict. No DCNL error will be raised.'
def get_completed_exploration_ids(user_id, collection_id): DCNL 'Returns a list of explorations the user has completed within the context DCNL of the provided collection. DCNL Args: DCNL user_id: str. ID of the given user. DCNL collection_id: str. ID of the collection. DCNL Returns: DCNL list(Exploration). A list of explorations that the user with the given DCNL user id has completed within the context of the provided collection with DCNL the given collection id. The list is empty if the user has not yet DCNL completed any explorations within the collection, or if either the DCNL collection and/or user do not exist. DCNL A progress model isn\'t added until the first exploration of a collection DCNL is completed, so, if a model is missing, there isn\'t enough information DCNL to infer whether that means the collection doesn\'t exist, the user DCNL doesn\'t exist, or if they just haven\'t mdae any progress in that DCNL collection yet. Thus, we just assume the user and collection exist for DCNL the sake of this call, so it returns an empty list, indicating that no DCNL progress has yet been made.'
def get_explorations_completed_in_collections(user_id, collection_ids): DCNL 'Returns the ids of the explorations completed in each of the collections. DCNL Args: DCNL user_id: str. ID of the given user. DCNL collection_ids: list(str). IDs of the collections. DCNL Returns: DCNL list(list(str)). List of the exploration ids completed in each DCNL collection.'
def get_valid_completed_exploration_ids(user_id, collection): DCNL 'Returns a filtered version of the return value of DCNL get_completed_exploration_ids, which only includes explorations found within DCNL the current version of the collection. DCNL Args: DCNL user_id: str. ID of the given user. DCNL collection: Collection. DCNL Returns: DCNL A filtered version of the return value of get_completed_exploration_ids DCNL which only includes explorations found within the current version of DCNL the collection.'
def get_next_exploration_ids_to_complete_by_user(user_id, collection_id): DCNL 'Returns a list of exploration IDs in the specified collection that the DCNL given user has not yet attempted and has the prerequisite skills to play. DCNL Args: DCNL user_id: str. ID of the user. DCNL collection_id: str. ID of the collection. DCNL Returns: DCNL list(str). A list of exploration IDs in the specified collection that DCNL the given user has not completed and has the prerequisite skills to DCNL play. Returns the collection\'s initial explorations if the user has yet DCNL to complete any explorations within the collection.'
def record_played_exploration_in_collection_context(user_id, collection_id, exploration_id): DCNL 'Records a exploration by a given user in a given collection DCNL context as having been played. DCNL Args: DCNL user_id: str. ID of the given user. DCNL collection_id: str. ID of the given collection. DCNL exploration_id: str. ID of the given exploration.'
def _get_collection_summary_dicts_from_models(collection_summary_models): DCNL 'Given an iterable of CollectionSummaryModel instances, create a dict DCNL containing corresponding collection summary domain objects, keyed by id. DCNL Args： DCNL collection_summary_models: An iterable of CollectionSummaryModel DCNL instances. DCNL Returns: DCNL A dict containing corresponding collection summary domain objects, keyed DCNL by id.'
def get_collection_summaries_matching_ids(collection_ids): DCNL 'Given a list of collection ids, return a list with the corresponding DCNL summary domain objects (or None if the corresponding summary does not DCNL exist). DCNL Args: DCNL collection_ids: A list of collection ids. DCNL Returns: DCNL list(CollectionSummary). A list with the corresponding summary domain DCNL objects.'
def get_collection_ids_matching_query(query_string, cursor=None): DCNL 'Returns a list with all collection ids matching the given search query DCNL string, as well as a search cursor for future fetches. DCNL Args: DCNL query_string: str. The search query string. DCNL cursor: str or None. Cursor indicating where, in the list of DCNL collections, to start the search from. DCNL Returns: DCNL 2-tuple of (returned_collection_ids, search_cursor), where: DCNL returned_collection_ids : list(str). A list with all collection ids DCNL matching the given search query string, as well as a search DCNL cursor for future fetches. The list contains exactly DCNL feconf.SEARCH_RESULTS_PAGE_SIZE results if there are at least DCNL that many, otherwise it contains all remaining results. (If this DCNL behaviour does not occur, an error will be logged.) DCNL search_cursor: str. Search cursor for future fetches.'
def apply_change_list(collection_id, change_list): DCNL 'Applies a changelist to a pristine collection and returns the result. DCNL Args: DCNL collection_id: str. ID of the given collection. DCNL change_list: list(dict). A change list to be applied to the given DCNL collection. Each entry in change_list is a dict that represents an DCNL CollectionChange. DCNL object. DCNL Returns: DCNL Collection. The resulting collection domain object.'
def validate_exps_in_collection_are_public(collection): DCNL 'Validates that explorations in a given collection are public. DCNL Args: DCNL collection: Collection. Collection to be validated. DCNL Raises: DCNL ValidationError: The collection contains at least one private DCNL exploration.'
def _save_collection(committer_id, collection, commit_message, change_list): DCNL 'Validates a collection and commits it to persistent storage. If DCNL successful, increments the version number of the incoming collection domain DCNL object by 1. DCNL Args: DCNL committer_id: str. ID of the given committer. DCNL collection: Collection. The collection domain object to be saved. DCNL commit_message: str. The commit message. DCNL change_list: list(dict). List of changes applied to a collection. Each DCNL entry in change_list is a dict that represents a CollectionChange. DCNL Raises: DCNL ValidationError: An invalid exploration was referenced in the DCNL collection. DCNL Exception: The collection model and the incoming collection domain DCNL object have different version numbers.'
def _create_collection(committer_id, collection, commit_message, commit_cmds): DCNL 'Creates a new collection, and ensures that rights for a new collection DCNL are saved first. This is because _save_collection() depends on the rights DCNL object being present to tell it whether to do strict validation or not. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection: Collection. collection domain object. DCNL commit_message: str. A description of changes made to the collection. DCNL commit_cmds: list(dict). A list of change commands made to the given DCNL collection.'
def save_new_collection(committer_id, collection): DCNL 'Saves a new collection. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection: Collection. Collection to be saved.'
def delete_collection(committer_id, collection_id, force_deletion=False): DCNL 'Deletes the collection with the given collection_id. DCNL IMPORTANT: Callers of this function should ensure that committer_id has DCNL permissions to delete this collection, prior to calling this function. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection_id: str. ID of the collection to be deleted. DCNL force_deletion: bool. If true, the collection and its history are fully DCNL deleted and are unrecoverable. Otherwise, the collection and all DCNL its history are marked as deleted, but the corresponding models are DCNL still retained in the datastore. This last option is the preferred DCNL one.'
def get_collection_snapshots_metadata(collection_id): DCNL 'Returns the snapshots for this collection, as dicts. DCNL Args: DCNL collection_id: str. The id of the collection in question. DCNL Returns: DCNL list of dicts, each representing a recent snapshot. Each dict has the DCNL following keys: committer_id, commit_message, commit_cmds, commit_type, DCNL created_on_ms, version_number. The version numbers are consecutive and DCNL in ascending order. There are collection.version_number items in the DCNL returned list.'
def publish_collection_and_update_user_profiles(committer_id, collection_id): DCNL 'Publishes the collection with publish_collection() function in DCNL rights_manager.py, as well as updates first_contribution_msec. DCNL It is the responsibility of the caller to check that the collection is DCNL valid prior to publication. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL collection_id: str. ID of the collection to be published.'
def update_collection(committer_id, collection_id, change_list, commit_message): DCNL 'Updates a collection. Commits changes. DCNL Args: DCNL - committer_id: str. The id of the user who is performing the update DCNL action. DCNL - collection_id: str. The collection id. DCNL - change_list: list of dicts, each representing a CollectionChange object. DCNL These changes are applied in sequence to produce the resulting DCNL collection. DCNL - commit_message: str or None. A description of changes made to the DCNL collection. For published collections, this must be present; for DCNL unpublished collections, it may be equal to None.'
def create_collection_summary(collection_id, contributor_id_to_add): DCNL 'Creates and stores a summary of the given collection. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL contributor_id_to_add: str. ID of the contributor to be added to the DCNL collection summary.'
def update_collection_summary(collection_id, contributor_id_to_add): DCNL 'Update the summary of an collection. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL contributor_id_to_add: str. ID of the contributor to be added to the DCNL collection summary.'
def compute_summary_of_collection(collection, contributor_id_to_add): DCNL 'Create a CollectionSummary domain object for a given Collection domain DCNL object and return it. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL contributor_id_to_add: str. ID of the contributor to be added to the DCNL collection summary. DCNL Returns: DCNL CollectionSummary. The computed summary for the given collection.'
def compute_collection_contributors_summary(collection_id): DCNL 'Computes the contributors\' summary for a given collection. DCNL Args: DCNL collection_id: str. ID of the collection. DCNL Returns: DCNL A dict whose keys are user_ids and whose values are the number of DCNL (non-revert) commits made to the given collection by that user_id. DCNL This does not count commits which have since been reverted.'
def save_collection_summary(collection_summary): DCNL 'Save a collection summary domain object as a CollectionSummaryModel DCNL entity in the datastore. DCNL Args: DCNL collection_summary: The collection summary object to be saved in the DCNL datastore.'
def delete_collection_summary(collection_id): DCNL 'Delete a collection summary model. DCNL Args: DCNL collection_id: str. ID of the collection whose collection summary is to DCNL be deleted.'
def save_new_collection_from_yaml(committer_id, yaml_content, collection_id): DCNL 'Saves a new collection from a yaml content string. DCNL Args: DCNL committer_id: str. ID of the committer. DCNL yaml_content: str. The yaml content string specifying a collection. DCNL collection_id: str. ID of the saved collection.'
def delete_demo(collection_id): DCNL 'Deletes a single demo collection. DCNL Args: DCNL collection_id: str. ID of the demo collection to be deleted.'
def load_demo(collection_id): DCNL 'Loads a demo collection. DCNL The resulting collection will have version 2 (one for its initial DCNL creation and one for its subsequent modification.) DCNL Args: DCNL collection_id: str. ID of the collection to be loaded.'
def get_next_page_of_all_commits(page_size=feconf.COMMIT_LIST_PAGE_SIZE, urlsafe_start_cursor=None): DCNL 'Returns a page of commits to all collections in reverse time order. DCNL Args: DCNL page_size: int. Number of pages of commits to be returned. DCNL urlsafe_start_cursor: str or None. If provided, the list of returned DCNL commits starts from this datastore cursor. Otherwise, the returned DCNL commits start from the beginning of the full list of commits. DCNL Returns: DCNL 3-tuple of (results, cursor, more) as described in fetch_page() at: DCNL https://developers.google.com/appengine/docs/python/ndb/queryclass, DCNL where: DCNL results: list(CollectionCommitLogEntry). List of query results. DCNL cursor: str or None. A query cursor pointing to the next batch of DCNL results. If there are no more results, this will be None. DCNL more: bool. Whether there are more results after this DCNL batch.'
def get_next_page_of_all_non_private_commits(page_size=feconf.COMMIT_LIST_PAGE_SIZE, urlsafe_start_cursor=None, max_age=None): DCNL 'Returns a page of non-private commits to all collections in reverse time DCNL order. DCNL Args: DCNL page_size: int. Number of pages of commits to be returned. DCNL urlsafe_start_cursor: str or None. If provided, the list of returned DCNL commits starts from this datastore cursor. Otherwise, the returned DCNL commits start from the beginning of the full list of commits. DCNL max_age: datetime.timedelta. The maximum age of a non-private commit to DCNL be included in the return page. It should be a datetime.timedelta DCNL instance. DCNL Returns: DCNL 3-tuple of (results, cursor, more) as described in fetch_page() at: DCNL https://developers.google.com/appengine/docs/python/ndb/queryclass, DCNL where: DCNL results: list(CollectionCommitLogEntry). List of query results. DCNL cursor: str or None. A query cursor pointing to the next batch of DCNL results. If there are no more results, this will be None. DCNL more: bool. Whether there are more results after this DCNL batch.'
def _collection_rights_to_search_dict(rights): DCNL 'Returns a search dict with information about the collection rights. This DCNL allows searches like "is:featured". DCNL Args: DCNL rights: ActivityRights. Rights object for a collection.'
def _should_index(collection): DCNL 'Checks if a particular collection should be indexed. DCNL Args: DCNL collection: Collection.'
def _get_search_rank(collection_id): DCNL 'Gets the search rank of a given collection. DCNL Args: DCNL collection_id: str. ID of the collection whose rank is to be retrieved. DCNL Returns: DCNL int. An integer determining the document\'s rank in search. DCNL Featured collections get a ranking bump, and so do collections that DCNL have been more recently updated.'
def _collection_to_search_dict(collection): DCNL 'Converts a collection domain object to a search dict. DCNL Args: DCNL collection: Collection. The collection domain object to be converted. DCNL Returns: DCNL The search dict of the collection domain object.'
def clear_search_index(): DCNL 'Clears the search index. DCNL WARNING: This runs in-request, and may therefore fail if there are too DCNL many entries in the index.'
def index_collections_given_ids(collection_ids): DCNL 'Adds the given collections to the search index. DCNL Args: DCNL collection_ids: list(str). List of collection ids whose collections are DCNL to be indexed.'
def patch_collection_search_document(collection_id, update): DCNL 'Patches an collection\'s current search document, with the values DCNL from the \'update\' dictionary. DCNL Args: DCNL collection_id: str. ID of the collection to be patched. DCNL update: dict. Key-value pairs to patch the current search document with.'
def update_collection_status_in_search(collection_id): DCNL 'Updates the status field of a collection in the search index. DCNL Args: DCNL collection_id: str. ID of the collection.'
def delete_documents_from_search_index(collection_ids): DCNL 'Removes the given collections from the search index. DCNL Args: DCNL collection_ids: list(str). List of IDs of the collections to be removed DCNL from the search index.'
def search_collections(query, limit, sort=None, cursor=None): DCNL 'Searches through the available collections. DCNL Args: DCNL query_string: str. the query string to search for. DCNL sort: str. This indicates how to sort results. This should be a string DCNL of space separated values. Each value should start with a \'+\' or a DCNL \'-\' character indicating whether to sort in ascending or descending DCNL order respectively. This character should be followed by a field DCNL name to sort on. When this is None, results are based on \'rank\'. See DCNL _get_search_rank to see how rank is determined. DCNL limit: int. the maximum number of results to return. DCNL cursor: str. A cursor, used to get the next page of results. DCNL If there are more documents that match the query than \'limit\', this DCNL function will return a cursor to get the next page. DCNL Returns: DCNL A 2-tuple with the following elements: DCNL - A list of collection ids that match the query. DCNL - A cursor if there are more matching collections to fetch, None DCNL otherwise. If a cursor is returned, it will be a web-safe string DCNL that can be used in URLs.'
def _get_completed_activities_from_model(completed_activities_model): DCNL 'Returns an activities completed domain object given a DCNL activities completed model loaded from the datastore. DCNL Args: DCNL completed_activities_model: CompletedActivitiesModel. The DCNL activities completed model loaded from the datastore. DCNL Returns: DCNL CompletedActivities. The domain object corresponding to the DCNL given model.'
def _get_incomplete_activities_from_model(incomplete_activities_model): DCNL 'Returns an incomplete activities domain object given an incomplete DCNL activities model loaded from the datastore. DCNL Args: DCNL incomplete_activities_model: IncompleteActivitiesModel. The DCNL incomplete activities model loaded from the datastore. DCNL Returns: DCNL IncompleteActivities. An IncompleteActivities domain object DCNL corresponding to the given model.'
def _get_last_playthrough_information(last_playthrough_model): DCNL 'Returns an ExpUserLastPlaythrough domain object given an DCNL ExpUserLastPlaythroughModel loaded from the datastore. DCNL Args: DCNL last_playthrough_model: ExpUserLastPlaythroughModel. The last DCNL last playthrough information loaded from the datastore. DCNL Returns: DCNL ExpUserLastPlaythrough. The last playthrough information domain object DCNL corresponding to the given model.'
def _save_completed_activities(activities_completed): DCNL 'Save an activities completed domain object as a DCNL CompletedActivitiesModel instance in the datastore. DCNL Args: DCNL activities_completed: CompletedActivities. The activities DCNL completed domain object to be saved in the datastore.'
def _save_incomplete_activities(incomplete_activities): DCNL 'Save an incomplete activities domain object as an DCNL IncompleteActivitiesModel instance in the datastore. DCNL Args: DCNL incomplete_activities: IncompleteActivities. The incomplete DCNL activities domain object to be saved in the datastore.'
def _save_last_playthrough_information(last_playthrough_information): DCNL 'Save an ExpUserLastPlaythrough domain object as an DCNL ExpUserLastPlaythroughModel instance in the datastore. DCNL Args: DCNL last_playthrough_information: ExpUserLastPlaythrough. The last DCNL playthrough information domain object to be saved in the datastore.'
def mark_exploration_as_completed(user_id, exp_id): DCNL 'Adds the exploration id to the completed list of the user unless the DCNL exploration has already been completed or has been created/edited by the DCNL user. It is also removed from the incomplete list and the learner playlist DCNL (if present). DCNL Args: DCNL user_id: str. The id of the user who has completed the exploration. DCNL exp_id: str. The id of the completed exploration.'
def mark_collection_as_completed(user_id, collection_id): DCNL 'Adds the collection id to the list of collections completed by the user DCNL unless the collection has already been completed or has been created/edited DCNL by the user. It is also removed from the incomplete list and the play later DCNL list (if present). DCNL Args: DCNL user_id: str. The id of the user who completed the collection. DCNL collection_id: str. The id of the completed collection.'
def mark_exploration_as_incomplete(user_id, exploration_id, state_name, exploration_version): DCNL 'Adds the exploration id to the incomplete list of the user unless the DCNL exploration has been already completed or has been created/edited by the DCNL user. If the exploration is already present in the incomplete list, just the DCNL details associated with it are updated. If the exploration is present in the DCNL learner playlist, it is removed. DCNL Args: DCNL user_id: str. The id of the user who partially completed the DCNL exploration. DCNL exploration_id: str. The id of the partially completed exploration. DCNL state_name: str. The name of the state at which the user left the DCNL exploration. DCNL exploration_version: str. The version of the exploration played by the DCNL learner.'
def mark_collection_as_incomplete(user_id, collection_id): DCNL 'Adds the collection id to the list of collections partially completed by DCNL the user unless the collection has already been completed or has been DCNL created/edited by the user or is already present in the incomplete list. DCNL If the collection is present in the learner playlist, it is removed. DCNL Args: DCNL user_id: str. The id of the user who partially completed the collection. DCNL collection_id: str. The id of the partially completed collection.'
def add_exp_to_learner_playlist(user_id, exploration_id, position_to_be_inserted=None): DCNL 'This function checks if the exploration exists in the completed list or DCNL the incomplete list. If it does not exist we call the function in learner DCNL playlist services to add the exploration to the play later list. DCNL Args: DCNL user_id: str. The id of the user. DCNL exploration_id: str. The id of the exploration to be added to the DCNL learner playlist. DCNL position_to_be_inserted: int|None. If this is specified the exploration DCNL gets inserted at the given position. Otherwise it gets added at the DCNL end.'
def add_collection_to_learner_playlist(user_id, collection_id, position_to_be_inserted=None): DCNL 'This function checks if the collection exists in the completed list or DCNL the incomplete list. If it does not exist we call the function in learner DCNL playlist services to add the collection to the play later list. DCNL Args: DCNL user_id: str. The id of the user. DCNL collection_id: str. The id of the collection to be added to the DCNL learner playlist. DCNL position_to_be_inserted: int|None. If this is specified the collection DCNL gets inserted at the given position. Otherwise it gets added at the DCNL end.'
def _remove_activity_ids_from_playlist(user_id, exploration_ids, collection_ids): DCNL 'Removes the explorations and collections from the playlist of the user. DCNL Args: DCNL user_id: str. The id of the user. DCNL exploration_ids: list(str). The ids of the explorations to be removed. DCNL collection_ids: list(str). The ids of the collections to be removed.'
def remove_exp_from_completed_list(user_id, exploration_id): DCNL 'Removes the exploration from the completed list of the user DCNL (if present). DCNL Args: DCNL user_id: str. The id of the user. DCNL exploration_id: str. The id of the exploration to be removed.'
def remove_collection_from_completed_list(user_id, collection_id): DCNL 'Removes the collection id from the list of completed collections DCNL (if present). DCNL Args: DCNL user_id: str. The id of the user. DCNL collection_id: str. The id of the collection to be removed.'
def _remove_activity_ids_from_completed_list(user_id, exploration_ids, collection_ids): DCNL 'Removes the explorations and collections from the completed list of the DCNL learner. DCNL Args: DCNL user_id: str. The id of the user. DCNL exploration_ids: list(str). The ids of the explorations to be removed. DCNL collection_ids: list(str). The ids of the collections to be removed.'
def remove_exp_from_incomplete_list(user_id, exploration_id): DCNL 'Removes the exploration from the incomplete list of the user DCNL (if present). DCNL Args: DCNL user_id: str. The id of the user. DCNL exploration_id: str. The id of the exploration to be removed.'
def remove_collection_from_incomplete_list(user_id, collection_id): DCNL 'Removes the collection id from the list of incomplete collections DCNL (if present). DCNL Args: DCNL user_id: str. The id of the user. DCNL collection_id: str. The id of the collection to be removed.'
def _remove_activity_ids_from_incomplete_list(user_id, exploration_ids=None, collection_ids=None): DCNL 'Removes the collections and explorations from the incomplete list of the DCNL user. DCNL Args: DCNL user_id: str. The id of the user. DCNL collection_ids: list(str). The ids of the collections to be removed. DCNL exploration_ids: list(str). The ids of the explorations to be removed.'
def get_all_completed_exp_ids(user_id): DCNL 'Returns a list with the ids of all the explorations completed by the DCNL user. DCNL Args: DCNL user_id: str. The id of the user. DCNL Returns: DCNL list(str). A list of the ids of the explorations completed by the DCNL learner.'
def _get_filtered_completed_exp_summaries(exploration_summaries, exploration_ids): DCNL 'Returns a list of summaries of the completed exploration ids and the DCNL ids of explorations that are no longer present. DCNL Args: DCNL exploration_summaries: list(ExplorationSummary). The list of exploration DCNL summary domain objects to be filtered. DCNL exploration_ids: list(str). The ids of the explorations corresponding to DCNL the exploration summary domain objects. DCNL Returns: DCNL tuple. A 2-tuple whose elements are as follows: DCNL - list(ExplorationSummary). Filtered list of ExplorationSummary domain DCNL objects of the completed explorations. DCNL - list(str). The ids of the explorations that are no longer present.'
def get_all_completed_collection_ids(user_id): DCNL 'Returns a list with the ids of all the collections completed by the DCNL user. DCNL Args: DCNL user_id: str. The id of the learner. DCNL Returns: DCNL list(str). A list of the ids of the collections completed by the DCNL learner.'
def _get_filtered_completed_collection_summaries(user_id, collection_summaries, collection_ids): DCNL 'Returns a list of summaries of the completed collection ids, the ids DCNL of collections that are no longer present and the summaries of the DCNL collections being shifted to the incomplete section on account of new DCNL addition of explorations. DCNL Args: DCNL user_id: str. The id of the learner. DCNL collection_summaries: list(CollectionSummary). The list of collection DCNL summary domain objects to be filtered. DCNL collection_ids: list(str). The ids of the collection corresponding to DCNL the collection summary domain objects. DCNL Returns: DCNL tuple. A 3-tuple whose elements are as follows: DCNL - list(CollectionSummary). A filtered list with the summary domain DCNL objects of the completed collections. DCNL - list(str). The ids of the collections that are no longer present. DCNL - list(CollectionSummary). The summaries corresponding to those DCNL collections which have been moved to the in progress section on DCNL account of new explorations being added to them.'
def get_all_incomplete_exp_ids(user_id): DCNL 'Returns a list with the ids of all the explorations partially completed DCNL by the user. DCNL Args: DCNL user_id: str. The id of the learner. DCNL Returns: DCNL list(str). A list of the ids of the explorations partially completed by DCNL the learner.'
def _get_filtered_incomplete_exp_summaries(exploration_summaries, exploration_ids): DCNL 'Returns a list of summaries of the incomplete exploration ids and the ids DCNL of explorations that are no longer present. DCNL Args: DCNL exploration_summaries: list(ExplorationSummary). The list of exploration DCNL summary domain objects to be filtered. DCNL exploration_ids: list(str). The ids of the explorations corresponding to DCNL the exploration summary domain objects. DCNL Returns: DCNL tuple. A 2-tuple whose elements are as follows: DCNL - list(ExplorationSummary). Filtered list of ExplorationSummary domain DCNL objects of the incomplete explorations. DCNL - list(str). The ids of the explorations that are no longer present.'
def get_all_incomplete_collection_ids(user_id): DCNL 'Returns a list with the ids of all the collections partially completed DCNL by the user. DCNL Args: DCNL user_id: str. The id of the learner. DCNL Returns: DCNL list(str). A list of the ids of the collections partially completed by DCNL the learner.'
def _get_filtered_incomplete_collection_summaries(collection_summaries, collection_ids): DCNL 'Returns a list of summaries of the incomplete collection ids and the ids DCNL of collections that are no longer present. DCNL Args: DCNL collection_summaries: list(CollectionSummary). The list of collection DCNL summary domain objects to be filtered. DCNL collection_ids: list(str). The ids of the collection corresponding to DCNL the collection summary domain objects. DCNL Returns: DCNL tuple. A 2-tuple whose elements are as follows: DCNL - list(CollectionSummary). A filtered list with the summary domain DCNL objects of the incomplete collections. DCNL - list(str). The ids of the collections that are no longer present.'
def _get_filtered_exp_playlist_summaries(exploration_summaries, exploration_ids): DCNL 'Returns a list of summaries of the explorations in the learner playlist DCNL and the ids of explorations that are no longer present. DCNL Args: DCNL exploration_summaries: list(ExplorationSummary). The list of exploration DCNL summary domain objects to be filtered. DCNL exploration_ids: list(str). The ids of the explorations corresponding to DCNL the exploration summary domain objects. DCNL Returns: DCNL tuple. A 2-tuple whose elements are as follows: DCNL - list(ExplorationSummary). Filtered list of ExplorationSummary domain DCNL objects of the explorations in the learner playlist. DCNL - list(str). The ids of the explorations that are no longer present.'
def _get_filtered_collection_playlist_summaries(collection_summaries, collection_ids): DCNL 'Returns a list of summaries of the collections in the learner playlist DCNL and the ids of collections that are no longer present. DCNL Args: DCNL collection_summaries: list(CollectionSummary). The list of collection DCNL summary domain objects to be filtered. DCNL collection_ids: list(str). The ids of the collections corresponding to DCNL the collection summary domain objects. DCNL Returns: DCNL tuple. A 2-tuple whose elements are as follows: DCNL - list(CollectionSummary). Filtered list of CollectionSummary domain DCNL objects of the collections in the learner playlist. DCNL - list(str). The ids of the collections that are no longer present.'
def get_collection_summary_dicts(collection_summaries): DCNL 'Returns a displayable summary dict of the the collection summaries DCNL given to it. DCNL Args: DCNL collection_summaries: list(CollectionSummary). A list of the DCNL summary domain objects. DCNL Returns: DCNL list(dict). The summary dict objects corresponding to the given summary DCNL domain objects.'
def get_activity_progress(user_id): DCNL 'Returns the progress of the learners - the explorations and collections DCNL completed by the user and those in progress. DCNL Args: DCNL user_id: str. The id of the learner. DCNL Returns: DCNL LearnerProgress. The learner progress domain object corresponding to the DCNL particular learner. DCNL dict. The numbers of the activities that are no longer present. It DCNL contains four keys: DCNL - incomplete_explorations: int. The number of incomplete DCNL explorations no longer present. DCNL - incomplete_collections: int. The number of incomplete collections DCNL no longer present. DCNL - completed_explorations: int. The number of completed explorations DCNL no longer present. DCNL - completed_collections: int. The number of completed collections no DCNL longer present. DCNL list(str). The titles of the collections to which new explorations have DCNL been added.'
def get_learner_playlist_from_model(learner_playlist_model): DCNL 'Returns the learner playlist domain object given the learner playlist DCNL model loaded from the datastore. DCNL Args: DCNL learner_playlist_model: LearnerPlaylistModel. The DCNL learner playlist model from the datastore. DCNL Returns: DCNL LearnerPlaylist. The learner playlist domain object corresponding to the DCNL given model.'
def save_learner_playlist(learner_playlist): DCNL 'Save a learner playlist domain object as an LearnerPlaylistModel entity DCNL in the datastore. DCNL Args: DCNL learner_playlist: LearnerPlaylist. The learner playlist domain object to DCNL be saved in the datastore.'
def mark_exploration_to_be_played_later(user_id, exploration_id, position_to_be_inserted=None): DCNL 'Adds the exploration id to the learner playlist of the user at the given DCNL position. If the position is not specified, the exploration gets added at DCNL the end. If the exploration is created or has been edited by the user it is DCNL not added as these appear on the creator dashboard of the creator. The DCNL maximum limit of the learner playlist is DCNL feconf.MAX_LEARNER_PLAYLIST_ACTIVITY_COUNT. If the count exceeds DCNL feconf.MAX_LEARNER_PLAYLIST_ACTIVITY_COUNT, the exploration is not added. DCNL Args: DCNL user_id: str. The id of the user. DCNL exploration_id: str. The id of the exploration to be added to the DCNL learner playlist. DCNL position_to_be_inserted: int|None. If this is specified the exploration DCNL gets inserted at the given position. Otherwise it gets added at the DCNL end.'
def mark_collection_to_be_played_later(user_id, collection_id, position_to_be_inserted=None): DCNL 'Adds the collection id to the learner playlist of the user at the given DCNL position. If the position is not specified, the collection gets added at DCNL the end. If the collection is created or has been edited by the user it is DCNL not added as these appear on the creator dashboard of the creator. The DCNL maximum limit of the learner playlist is DCNL feconf.MAX_LEARNER_PLAYLIST_ACTIVITY_COUNT. If the count exceeds DCNL feconf.MAX_LEARNER_PLAYLIST_ACTIVITY_COUNT, the collection is not added. DCNL Args: DCNL user_id: str. The id of the user. DCNL collection_id: str. The id of the collection to be added to the DCNL learner playlist. DCNL position_to_be_inserted: int|None. If this is specified the collection DCNL gets inserted at the given position. Otherwise it gets added at DCNL the end.'
def remove_exploration_from_learner_playlist(user_id, exploration_id): DCNL 'Removes the exploration from the learner playlist of the user DCNL (if present). DCNL Args: DCNL user_id: str. The id of the user. DCNL exploration_id: str. The id of the exploration to be removed.'
def remove_collection_from_learner_playlist(user_id, collection_id): DCNL 'Removes the collection from the learner playlist of the user DCNL (if present). DCNL Args: DCNL user_id: str. The id of the user. DCNL collection_id: str. The id of the collection to be removed.'
def get_all_exp_ids_in_learner_playlist(user_id): DCNL 'Returns a list with the ids of all the explorations that are in the DCNL playlist of the user. DCNL Args: DCNL user_id: str. The id of the user. DCNL Returns: DCNL list(str). A list of the ids of the explorations that are in the DCNL learner playlist of the user.'
def get_all_collection_ids_in_learner_playlist(user_id): DCNL 'Returns a list with the ids of all the collections that are in the DCNL playlist of the user. DCNL Args: DCNL user_id: str. The id of the user. DCNL Returns: DCNL list(str). A list of the ids of the collections that are in the DCNL learner playlist of the user.'
def send_email_to_qualified_users(query_id, email_subject, email_body, email_intent, max_recipients): DCNL 'Send email to maximum \'max_recipients\' qualified users. DCNL Args: DCNL query_id: str. ID of the UserQueryModel instance. DCNL email_subject: str. Subject of the email to be sent. DCNL email_body: str. Body of the email to be sent. DCNL email_intent: str. Intent of the email. DCNL max_recipients: int. Maximum number of recipients send emails to.'
def _migrate_states_schema(versioned_exploration_states): DCNL 'Holds the responsibility of performing a step-by-step, sequential update DCNL of an exploration states structure based on the schema version of the input DCNL exploration dictionary. This is very similar to the YAML conversion process DCNL found in exp_domain.py and, in fact, many of the conversion functions for DCNL states are also used in the YAML conversion pipeline. If the current DCNL exploration states schema version changes DCNL (feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION), a new conversion DCNL function must be added and some code appended to this function to account DCNL for that new version. DCNL Args: DCNL versioned_exploration_states: A dict with two keys: DCNL states_schema_version: int. the states schema version for the DCNL exploration. DCNL states: the dict of states comprising the exploration. The keys in DCNL this dict are state names. DCNL Raises: DCNL Exception: The given states_schema_version is invalid.'
def _get_exploration_memcache_key(exploration_id, version=None): DCNL 'Returns a memcache key for an exploration. DCNL Args: DCNL exploration_id: str. The id of the exploration whose memcache key DCNL is to be returned. DCNL version: int or None. If specified, the version of the exploration DCNL whose memcache key is to be returned. DCNL Returns: DCNL str. Memcache key for the given exploration (or exploration version).'
def get_exploration_from_model(exploration_model, run_conversion=True): DCNL 'Returns an Exploration domain object given an exploration model loaded DCNL from the datastore. DCNL If run_conversion is True, then the exploration\'s states schema version DCNL will be checked against the current states schema version. If they do not DCNL match, the exploration will be automatically updated to the latest states DCNL schema version. DCNL IMPORTANT NOTE TO DEVELOPERS: In general, run_conversion should never be DCNL False. This option is only used for testing that the states schema version DCNL migration works correctly, and it should never be changed otherwise. DCNL Args: DCNL exploration_model: An exploration storage model. DCNL run_conversion: bool. When True, updates the exploration to the latest DCNL states_schema_version if necessary. DCNL Returns: DCNL Exploration. The exploration domain object corresponding to the given DCNL exploration model.'
def get_exploration_summary_from_model(exp_summary_model): DCNL 'Returns an ExplorationSummary domain object. DCNL Args: DCNL exp_summary_model: ExplorationSummary. An ExplorationSummary model DCNL instance. DCNL Returns: DCNL ExplorationSummary. The summary domain object correspoding to the DCNL given exploration summary model.'
def get_exploration_by_id(exploration_id, strict=True, version=None): DCNL 'Returns an Exploration domain object. DCNL Args: DCNL exploration_id: str. The id of the exploration to be returned. DCNL strict: bool. Whether to fail noisily if no exploration with a given id DCNL exists. DCNL version: int or None. The version of the exploration to be returned. DCNL If None, the latest version of the exploration is returned. DCNL Returns: DCNL Exploration. The domain object corresponding to the given exploration.'
def get_exploration_summary_by_id(exploration_id): DCNL 'Returns a domain object representing an exploration summary. DCNL Args: DCNL exploration_id: str. The id of the ExplorationSummary to be returned. DCNL Returns: DCNL ExplorationSummary. The summary domain object corresponding to the DCNL given exploration.'
def get_multiple_explorations_by_id(exp_ids, strict=True): DCNL 'Returns a dict of domain objects representing explorations with the DCNL given ids as keys. If an exp_id is not present, it is not included in the DCNL return dict. DCNL Args: DCNL exp_ids: list(str). List of ids of the exploration to be returned. DCNL strict: bool. If True, a ValueError is raised when any exploration id DCNL is invalid. DCNL Returns: DCNL dict. Maps exploration ids to the corresponding Exploration domain DCNL objects. Any invalid exploration ids are omitted. DCNL Raises: DCNL ValueError: When strict is True and at least one of the given exp_ids DCNL is invalid.'
def get_new_exploration_id(): DCNL 'Returns a new exploration id. DCNL Returns: DCNL str. A new exploration id.'
def is_exp_summary_editable(exp_summary, user_id=None): DCNL 'Checks if a given user has permissions to edit the exploration. DCNL Args: DCNL exp_summary: ExplorationSummary. An ExplorationSummary domain object. DCNL user_id: str. The id of the user whose permissions are being checked. DCNL Returns: DCNL bool. Whether the user has permissions to edit the exploration.'
def get_exploration_titles_and_categories(exp_ids): DCNL 'Returns exploration titles and categories for the given ids. DCNL The result is a dict with exploration ids as keys. The corresponding values DCNL are dicts with the keys \'title\' and \'category\'. DCNL Any invalid exp_ids will not be included in the return dict. No error will DCNL be raised. DCNL Args: DCNL exp_ids: list(str). A list of exploration ids of exploration domain DCNL objects. DCNL Returns: DCNL dict. The keys are exploration ids and the corresponding values are DCNL dicts with the keys \'title\' and \'category\'. Any invalid exploration DCNL ids are excluded.'
def _get_exploration_summaries_from_models(exp_summary_models): DCNL 'Returns a dict with ExplorationSummary domain objects as values, DCNL keyed by their exploration id. DCNL Args: DCNL exp_summary_models: list(ExplorationSummary). List of ExplorationSummary DCNL model instances. DCNL Returns: DCNL dict. The keys are exploration ids and the values are the corresponding DCNL ExplorationSummary domain objects.'
def get_exploration_summaries_matching_ids(exp_ids): DCNL 'Returns a list of ExplorationSummary domain objects (or None if the DCNL corresponding summary does not exist) corresponding to the given DCNL list of exploration ids. DCNL Args: DCNL exp_ids: list(str). List of exploration ids. DCNL Returns: DCNL list(ExplorationSummary|None). List of ExplorationSummary domain objects DCNL corresponding to the given exploration ids. If an ExplorationSummary DCNL does not exist, the corresponding returned list element is None.'
def get_exploration_ids_matching_query(query_string, cursor=None): DCNL 'Returns a list with all exploration ids matching the given search query DCNL string, as well as a search cursor for future fetches. DCNL This method returns exactly feconf.SEARCH_RESULTS_PAGE_SIZE results if DCNL there are at least that many, otherwise it returns all remaining results. DCNL (If this behaviour does not occur, an error will be logged.) The method DCNL also returns a search cursor. DCNL Args: DCNL query_string: str. A search query string. DCNL cursor: str or None. Optional cursor from which to start the search DCNL query. If no cursor is supplied, the first N results matching DCNL the query are returned. DCNL Returns: DCNL list(str). A list of exploration ids matching the given search query.'
def get_non_private_exploration_summaries(): DCNL 'Returns a dict with all non-private exploration summary domain objects, DCNL keyed by their id. DCNL Returns: DCNL dict. The keys are exploration ids and the values are corresponding DCNL non-private ExplorationSummary domain objects.'
def get_top_rated_exploration_summaries(limit): DCNL 'Returns a dict with top rated exploration summary model instances, DCNL keyed by their id. At most \'limit\' entries are returned. DCNL Args: DCNL limit: int. The maximum number of exploration summary model instances to DCNL be returned. DCNL Returns: DCNL dict. The keys are exploration ids and the values are the corresponding DCNL top rated ExplorationSummary domain model instances.  At most limit DCNL entries are returned.'
def get_recently_published_exp_summaries(limit): DCNL 'Returns a dict with recently published ExplorationSummary model DCNL instances, keyed by their exploration id. At most \'limit\' entries are DCNL returned. DCNL Args: DCNL limit: int. The maximum number of exploration summary model instances to DCNL be returned. DCNL Returns: DCNL dict. The dict contains recently published ExplorationSummary model DCNL instances as a value keyed by their exploration id. At most \'limit\' DCNL entries are returned.'
def get_all_exploration_summaries(): DCNL 'Returns a dict with all exploration summary domain objects, DCNL keyed by their id. DCNL Returns: DCNL dict. A dict with all ExplorationSummary domain objects keyed by their DCNL exploration id.'
def export_to_zip_file(exploration_id, version=None): DCNL 'Returns a ZIP archive of the exploration. DCNL Args: DCNL exploration_id: str. The id of the exploration to export. DCNL version: int or None. If provided, this indicates which version of DCNL the exploration to export. Otherwise, the latest version of the DCNL exploration is exported. DCNL Returns: DCNL str. The contents of the ZIP archive of the exploration (which can be DCNL subsequently converted into a zip file via zipfile.ZipFile()).'
def convert_state_dict_to_yaml(state_dict, width): DCNL 'Converts the given state dict to yaml format. DCNL Args: DCNL state_dict: dict. A dict representing a state in an exploration. DCNL width: int. The maximum number of characters in a line for the DCNL returned YAML string. DCNL Returns: DCNL str. The YAML version of the state_dict. DCNL Raises: DCNL Exception: The state_dict does not represent a valid state.'
def export_states_to_yaml(exploration_id, version=None, width=80): DCNL 'Returns a dictionary of the exploration, whose keys are state DCNL names and values are yaml strings representing the state contents with DCNL lines wrapped at \'width\' characters. DCNL Args: DCNL exploration_id: str. The id of the exploration whose states should DCNL be exported. DCNL Returns: DCNL dict. The keys are state names, and the values are YAML strings DCNL representing the corresponding state\'s contents.'
def apply_change_list(exploration_id, change_list): DCNL 'Applies a changelist to a pristine exploration and returns the result. DCNL Each entry in change_list is a dict that represents an ExplorationChange DCNL object. DCNL Args: DCNL exploration_id: str. The id of the exploration to which the change list DCNL is to be applied. DCNL change_list: list(dict). The list of changes to apply. DCNL Returns: DCNL Exploration. The exploration domain object that results from applying DCNL the given changelist to the existing version of the exploration. DCNL Raises: DCNL Exception: Any entries in the changelist are invalid.'
def _save_exploration(committer_id, exploration, commit_message, change_list): DCNL 'Validates an exploration and commits it to persistent storage. DCNL If successful, increments the version number of the incoming exploration DCNL domain object by 1. DCNL Args: DCNL committer_id: str. The id of the user who made the commit. DCNL exploration: Exploration. The exploration to be saved. DCNL commit_message: str. The commit message. DCNL change_list: list(ExplorationChange). A list of changes introduced in DCNL this commit. DCNL Raises: DCNL Exception: The versions of the given exploration and the currently DCNL stored exploration model do not match.'
def _create_exploration(committer_id, exploration, commit_message, commit_cmds): DCNL 'Ensures that rights for a new exploration are saved first. DCNL This is because _save_exploration() depends on the rights object being DCNL present to tell it whether to do strict validation or not. DCNL Args: DCNL committer_id: str. The id of the user who made the commit. DCNL exploration: Exploration. The exploration domain object. DCNL commit_message: str. The commit description message. DCNL commit_cmds: list(dict). A list of commands, describing changes DCNL made in this model, which should give sufficient information to DCNL reconstruct the commit. Each dict always contains: DCNL cmd: str. Unique command. DCNL and additional arguments for that command.'
def save_new_exploration(committer_id, exploration): DCNL 'Saves a newly created exploration. DCNL Args: DCNL committer_id: str. The id of the user who made the commit. DCNL exploration: Exploration. The exploration domain object to be saved.'
def delete_exploration(committer_id, exploration_id, force_deletion=False): DCNL 'Deletes the exploration with the given exploration_id. DCNL IMPORTANT: Callers of this function should ensure that committer_id has DCNL permissions to delete this exploration, prior to calling this function. DCNL If force_deletion is True the exploration and its history are fully deleted DCNL and are unrecoverable. Otherwise, the exploration and all its history are DCNL marked as deleted, but the corresponding models are still retained in the DCNL datastore. This last option is the preferred one. DCNL Args: DCNL committer_id: str. The id of the user who made the commit. DCNL exploration_id: str. The id of the exploration to be deleted. DCNL force_deletion: bool. If True, completely deletes the storage models DCNL corresponding to the exploration. Otherwise, marks them as deleted DCNL but keeps the corresponding models in the datastore.'
def get_exploration_snapshots_metadata(exploration_id, allow_deleted=False): DCNL 'Returns the snapshots for this exploration, as dicts, up to and including DCNL the latest version of the exploration. DCNL Args: DCNL exploration_id: str. The id of the exploration whose snapshots_metadata DCNL is required. DCNL allow_deleted: bool. Whether to allow retrieval of deleted snapshots. DCNL Returns: DCNL list(dict). List of dicts, each representing a recent snapshot. Each DCNL dict has the following keys: committer_id, commit_message, commit_cmds, DCNL commit_type, created_on_ms, version_number. The version numbers are DCNL consecutive and in ascending order. There are exploration.version_number DCNL items in the returned list.'
def _get_last_updated_by_human_ms(exp_id): DCNL 'Return the last time, in milliseconds, when the given exploration was DCNL updated by a human. DCNL Args: DCNL exp_id: str. The id of the exploration. DCNL Returns: DCNL float. The last time in milliseconds when a given exploration was DCNL updated by a human.'
def publish_exploration_and_update_user_profiles(committer_id, exp_id): DCNL 'Publishes the exploration with publish_exploration() function in DCNL rights_manager.py, as well as updates first_contribution_msec. Sends an DCNL email to the subscribers of the commiter informing them that an exploration DCNL has been published. DCNL It is the responsibility of the caller to check that the exploration is DCNL valid prior to publication. DCNL Args: DCNL committer_id: str. The id of the user who made the commit. DCNL exp_id: str. The id of the exploration to be published.'
def update_exploration(committer_id, exploration_id, change_list, commit_message, is_suggestion=False): DCNL 'Update an exploration. Commits changes. DCNL Args: DCNL committer_id: str. The id of the user who is performing the update DCNL action. DCNL exploration_id: str. The id of the exploration to be updated. DCNL change_list: list(dict). A change list to be applied to the given DCNL exploration. Each entry in change_list is a dict that represents an DCNL ExplorationChange. DCNL commit_message: str or None. A description of changes made to the state. DCNL For published explorations, this must be present; for unpublished DCNL explorations, it should be equal to None. For suggestions that are DCNL being accepted, and only for such commits, it should start with DCNL feconf.COMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX. DCNL is_suggestion: bool. Whether the update is due to a suggestion being DCNL accepted. DCNL Raises: DCNL ValueError: No commit message is supplied and the exploration is public. DCNL ValueError: The update is due to a suggestion and the commit message is DCNL invalid. DCNL ValueError: The update is not due to a suggestion, and the commit DCNL message starts with the same prefix as the commit message for DCNL accepted suggestions.'
def create_exploration_summary(exploration_id, contributor_id_to_add): DCNL 'Create the summary model for an exploration, and store it in the DCNL datastore. DCNL Args: DCNL exploration_id: str. The id of the exploration. DCNL contributor_id_to_add: str or None. The user_id of user who have DCNL created the exploration will be added to the list of contributours DCNL for the exploration if the argument is not None and it is not a DCNL system id.'
def update_exploration_summary(exploration_id, contributor_id_to_add): DCNL 'Update the summary of an exploration. DCNL Args: DCNL exploration_id: str. The id of the exploration whose summary is DCNL to be updated. DCNL contributor_id_to_add: str or None. The user_id of user who have DCNL contributed (humans who have made a positive (not just a revert) DCNL update to the exploration\'s content) will be added to the list of DCNL contributours for the exploration if the argument is not None and it DCNL is not a system id.'
def compute_summary_of_exploration(exploration, contributor_id_to_add): DCNL 'Create an ExplorationSummary domain object for a given Exploration DCNL domain object and return it. contributor_id_to_add will be added to DCNL the list of contributors for the exploration if the argument is not DCNL None and if the id is not a system id. DCNL Args: DCNL exploration: Exploration. The exploration whose summary is to be DCNL computed. DCNL contributor_id_to_add: str or None. The user_id of user who have DCNL contributed (humans who have made a positive (not just a revert) DCNL change to the exploration\'s content) will be added to the list of DCNL contributours for the exploration if the argument is not None and it DCNL is not a system id. DCNL Returns: DCNL ExplorationSummary. The resulting exploration summary domain object.'
def compute_exploration_contributors_summary(exploration_id): DCNL 'Returns a dict whose keys are user_ids and whose values are DCNL the number of (non-revert) commits made to the given exploration DCNL by that user_id. This does not count commits which have since been reverted. DCNL Args: DCNL exploration_id: str. The id of the exploration. DCNL Returns: DCNL dict. The keys are all user_ids who have made commits to the given DCNL exploration. The corresponding values are the number of commits made by DCNL each user. Commits that revert to an earlier version, or forward DCNL commits which have since been reverted, are excluded.'
def save_exploration_summary(exp_summary): DCNL 'Save an exploration summary domain object as an ExpSummaryModel entity DCNL in the datastore. DCNL Args: DCNL exp_summary: ExplorationSummary. The exploration summary to save.'
def delete_exploration_summary(exploration_id): DCNL 'Delete an exploration summary model. DCNL Args: DCNL exploration_id: str. The id of the exploration summary to be DCNL deleted.'
def revert_exploration(committer_id, exploration_id, current_version, revert_to_version): DCNL 'Reverts an exploration to the given version number. Commits changes. DCNL Args: DCNL committer_id: str. The id of the user who made the commit. DCNL exploration_id: str. The id of the exploration to be reverted to the DCNL current version. DCNL current_version: int. The current version of the exploration. DCNL revert_to_version: int. The version to which the given exploration DCNL is to be reverted. DCNL Raises: DCNL Exception:  does not match the version of the currently-stored DCNL exploration model.'
def get_demo_exploration_components(demo_path): DCNL 'Gets the content of `demo_path` in the sample explorations folder. DCNL Args: DCNL demo_path: str. The file or folder path for the content of an DCNL exploration in SAMPLE_EXPLORATIONS_DIR. E.g.: \'adventure.yaml\' or DCNL \'tar/\'. DCNL Returns: DCNL tuple. A 2-tuple, the first element of which is a yaml string, and the DCNL second element of which is a list of (filepath, content) 2-tuples. The DCNL filepath does not include the assets/ prefix. DCNL Raises: DCNL Exception: The path of the file is unrecognized or does not exist.'
def save_new_exploration_from_yaml_and_assets(committer_id, yaml_content, exploration_id, assets_list): DCNL 'Note that the default title and category will be used if the YAML DCNL schema version is less than DCNL exp_domain.Exploration.LAST_UNTITLED_SCHEMA_VERSION, DCNL since in that case the YAML schema will not have a title and category DCNL present. DCNL Args: DCNL committer_id: str. The id of the user who made the commit. DCNL yaml_content: str. The YAML representation of the exploration. DCNL exploration_id: str. The id of the exploration. DCNL assets_list: list(list(str)). A list of lists of assets, which contains DCNL asset\'s filename and content. DCNL Raises: DCNL Exception: The yaml file is invalid due to a missing schema version.'
def delete_demo(exploration_id): DCNL 'Deletes a single demo exploration. DCNL Args: DCNL exploration_id: str. The id of the exploration to be deleted. DCNL Raises: DCNL Exception: The exploration id is invalid.'
def load_demo(exploration_id): DCNL 'Loads a demo exploration. DCNL The resulting exploration will have two commits in its history (one for DCNL its initial creation and one for its subsequent modification.) DCNL Args: DCNL exploration_id: str. The id of the demo exploration. DCNL Raises: DCNL Exception: The exploration id provided is invalid.'
def get_next_page_of_all_commits(page_size=feconf.COMMIT_LIST_PAGE_SIZE, urlsafe_start_cursor=None): DCNL 'Returns a page of commits to all explorations in reverse time order. DCNL The return value is a tuple (results, cursor, more) as described in DCNL fetch_page() at: DCNL https://developers.google.com/appengine/docs/python/ndb/queryclass DCNL Args: DCNL page_size: int. The maximum number of commits to return. DCNL urlsafe_start_cursor: str. If this is not None, then the returned DCNL commits start from the cursor location. Otherwise they start from DCNL the beginning of the list of commits. DCNL Returns: DCNL tuple. A 3-tuple consisting of: DCNL - list(ExplorationCommitLogEntry). A list containing DCNL ExplorationCommitlogEntry domain objects. DCNL - str. The postion of the cursor. DCNL - bool. indicating whether there are (likely) more results after DCNL this batch. If False, there are no more results; if True, there DCNL are probably more results.'
def get_next_page_of_all_non_private_commits(page_size=feconf.COMMIT_LIST_PAGE_SIZE, urlsafe_start_cursor=None, max_age=None): DCNL 'Returns a page of non-private commits in reverse time order. If max_age DCNL is given, it should be a datetime.timedelta instance. DCNL The return value is a tuple (results, cursor, more) as described in DCNL fetch_page() at: DCNL https://developers.google.com/appengine/docs/python/ndb/queryclass DCNL Args: DCNL page_size: int. Number of commits that are in the commit list page. DCNL urlsafe_start_cursor: str. If this is not None, then the returned DCNL commits start from cursor location. Otherwise they start from the DCNL beginning of the list of commits. DCNL Returns: DCNL tuple. A 3-tuple consisting of: DCNL - list(ExplorationCommitLogEntry). A list containing DCNL ExplorationCommitlogEntry domain objects. DCNL - str. The postion of the cursor. DCNL - bool. indicating whether there are (likely) more results after DCNL this batch. If False, there are no more results; if True, there DCNL are probably more results. DCNL Raises: DCNL ValueError: The argument max_age is not datetime.timedelta or None.'
def _exp_rights_to_search_dict(rights): DCNL 'Returns a search dict with information about the exploration rights. This DCNL allows searches like "is:featured". DCNL Args: DCNL rights: ActivityRights. Domain object for the rights/publication status DCNL of the exploration. DCNL Returns: DCNL dict. If the status of the given exploration is publicized then it DCNL returns a dict with a key "is", and the value "featured". Otherwise, it DCNL returns an empty dict.'
def _should_index(exp): DCNL 'Returns whether the given exploration should be indexed for future DCNL search queries. DCNL Args: DCNL exp: Exploration domain object.'
def get_number_of_ratings(ratings): DCNL 'Gets the total number of ratings represented by the given ratings DCNL object. DCNL Args: DCNL ratings: dict. A dict whose keys are \'1\', \'2\', \'3\', \'4\', \'5\' and whose DCNL values are nonnegative integers representing frequency counts. DCNL Returns: DCNL int. The total number of ratings given.'
def get_average_rating(ratings): DCNL 'Returns the average rating of the ratings as a float. DCNL If there are no ratings, it will return 0. DCNL Args: DCNL ratings: dict. A dict whose keys are \'1\', \'2\', \'3\', \'4\', \'5\' and whose DCNL values are nonnegative integers representing frequency counts. DCNL Returns: DCNL float. The average of the all the ratings given, or 0 DCNL if there are no rating.'
def get_scaled_average_rating(ratings): DCNL 'Returns the lower bound wilson score of the ratings. If there are DCNL no ratings, it will return 0. The confidence of this result is 95%. DCNL Args: DCNL ratings: dict. A dict whose keys are \'1\', \'2\', \'3\', \'4\', \'5\' and whose DCNL values are nonnegative integers representing frequency counts. DCNL Returns: DCNL float. The lower bound wilson score of the ratings.'
def get_search_rank_from_exp_summary(exp_summary): DCNL 'Returns an integer determining the document\'s rank in search. DCNL Featured explorations get a ranking bump, and so do explorations that DCNL have been more recently updated. Good ratings will increase the ranking DCNL and bad ones will lower it. DCNL Args: DCNL exp_summary: ExplorationSummary. ExplorationSummary domain object. DCNL Returns: DCNL int. Document\'s rank in search.'
def get_search_rank(exp_id): DCNL 'Returns the search rank. DCNL Args: DCNL exp_id: str. The id of the exploration. DCNL Returns: DCNL int. The rank of the exploration.'
def _exp_to_search_dict(exp): DCNL 'Updates the dict to be returned, whether the given exploration is to DCNL be indexed for further queries or not. DCNL Args: DCNL exp: Exploration. Exploration domain object. DCNL Returns: DCNL dict. The representation of the given exploration, in a form that can DCNL be used by the search index.'
def clear_search_index(): DCNL 'WARNING: This runs in-request, and may therefore fail if there are too DCNL many entries in the index.'
def index_explorations_given_ids(exp_ids): DCNL 'Indexes the explorations corresponding to the given exploration ids. DCNL Args: DCNL exp_ids: list(str). List of ids of the explorations to be indexed.'
def patch_exploration_search_document(exp_id, update): DCNL 'Patches an exploration\'s current search document, with the values DCNL from the \'update\' dictionary. DCNL Args: DCNL exp_id: str. The id of the exploration to be patched. DCNL update: dict. Key-value pairs to patch the exploration\'s search DCNL document with.'
def update_exploration_status_in_search(exp_id): DCNL 'Updates the exploration status in its search doc. DCNL Args: DCNL exp_id: str. The id of the exploration whose status is to be DCNL updated.'
def delete_documents_from_search_index(exploration_ids): DCNL 'Deletes the documents corresponding to these exploration_ids from the DCNL search index. DCNL Args: DCNL exploration_ids: list(str). A list of exploration ids whose DCNL documents are to be deleted from the search index.'
def search_explorations(query, limit, sort=None, cursor=None): DCNL 'Searches through the available explorations. DCNL Args: DCNL query_string: str. The query string to search for. DCNL limit: int. The maximum number of results to return. DCNL sort: str. A string indicating how to sort results. This should be a DCNL string of space separated values. Each value should start with a DCNL \'+\' or a \'-\' character indicating whether to sort in ascending or DCNL descending order respectively. This character should be followed by DCNL a field name to sort on. When this is None, results are based on DCNL \'rank\'. See get_search_rank to see how rank is determined. DCNL cursor: str or None. A cursor, used to get the next page of results. If DCNL there are more documents that match the query than \'limit\', this DCNL function will return a cursor to get the next page. DCNL Returns: DCNL tuple. A 2-tuple consisting of: DCNL - list(str). A list of exploration ids that match the query. DCNL - str or None. A cursor if there are more matching explorations to DCNL fetch, None otherwise. If a cursor is returned, it will be a DCNL web-safe string that can be used in URLs.'
def _is_suggestion_valid(thread_id, exploration_id): DCNL 'Check if the suggestion is still valid. A suggestion is considered DCNL invalid if the name of the state that the suggestion was made for has DCNL changed since. DCNL Args: DCNL thread_id: str. Thread id of the feedback thread containing the DCNL suggestion. DCNL exploration_id: str. The id of the exploration. DCNL Returns: DCNL bool. Whether the suggestion is still valid.'
def _is_suggestion_handled(thread_id, exploration_id): DCNL 'Checks if the current suggestion has already been accepted/rejected. DCNL Args: DCNL thread_id: str. Thread id of the feedback thread containing the DCNL suggestion. DCNL exploration_id: str. The id of the exploration. DCNL Returns: DCNL bool. Whether the current suggestion has already been acted upon (i.e., DCNL accepted or rejected).'
def _create_change_list_from_suggestion(suggestion, old_content, audio_update_required): DCNL 'Creates a change list from a suggestion object. DCNL Args: DCNL suggestion: Suggestion. The given Suggestion domain object. DCNL old_content: SubtitledHtml. A SubtitledHtml domain object representing DCNL the content of the old state. DCNL audio_update_required: bool. Whether the audio for the state content DCNL should be marked as needing an update. DCNL Returns: DCNL list(dict). A dict containing a single change that represents an edit to DCNL the state\'s content. The dict contains value and key (str.) pairs as DCNL follows: DCNL cmd: list(dict). The changelist corresponding to the given DCNL suggestion domain object. DCNL state_name: str or None. The state name for the thread. If None, DCNL this indicates that the thread pertains to the exploration as a DCNL whole. DCNL new_value: list(str). List of the state content of the suggestion DCNL object.'
def _get_commit_message_for_suggestion(suggestion_author_username, commit_message): DCNL 'Returns a modified commit message for an accepted suggestion. DCNL NOTE TO DEVELOPERS: This should not be changed, since in the future we may DCNL want to determine and credit the original authors of suggestions, and in DCNL order to do so we will look for commit messages that follow this format. DCNL Args: DCNL suggestion_author_username: str. Username of the suggestion author. DCNL commit_message: str. The original commit message submitted by the DCNL suggestion author. DCNL Returns: DCNL str. The modified commit message to be used in the exploration commit DCNL logs.'
def accept_suggestion(editor_id, thread_id, exploration_id, commit_message, audio_update_required): DCNL 'If the suggestion is valid, accepts it by updating the exploration. DCNL Raises an exception if the suggestion is not valid. DCNL Args: DCNL editor_id: str. The user id of the editor. DCNL thread_id: str. The id of the suggestion thread. DCNL exploration_id: str. The id of the exploration that the suggestion is DCNL for. DCNL commit_message: str. The commit message. DCNL audio_update_required: bool. Whether the audio subtitles for the DCNL content need to be updated. DCNL Raises: DCNL Exception: The suggestion is not valid. DCNL Exception: The commit message is empty. DCNL Exception: The suggestion has already been accepted or rejected.'
def reject_suggestion(editor_id, thread_id, exploration_id): DCNL 'Set the status of a suggestion to REJECTED. DCNL Args: DCNL editor_id: str. User id of the editor. DCNL thread_id: str. The id of the suggestion thread. DCNL exploration_id: str. The id of the exploration that the suggestion is DCNL for. DCNL Raises: DCNL Exception: The suggestion has already been accepted or rejected.'
def is_version_of_draft_valid(exp_id, version): DCNL 'Checks if the draft version is the same as the latest version of the DCNL exploration. DCNL Args: DCNL exp_id: str. The id of the exploration. DCNL version: int. The draft version which is to be validate. DCNL Returns: DCNL bool. Whether the given version number is the same as the current DCNL version number of the exploration in the datastore.'
def create_or_update_draft(exp_id, user_id, change_list, exp_version, current_datetime): DCNL 'Create a draft with the given change list, or update the change list DCNL of the draft if it already exists. A draft is updated only if the change DCNL list timestamp of the new change list is greater than the change list DCNL timestamp of the draft. DCNL The method assumes that a ExplorationUserDataModel object exists for the DCNL given user and exploration. DCNL Args: DCNL exp_id: str. The id of the exploration. DCNL user_id: str. The id of the user. DCNL change_list: list(str). A list that contains the changes to be made to DCNL the ExplorationUserDataModel object. DCNL exp_version: int. The current version of the exploration. DCNL current_datetime: datetime.datetime. The current date and time.'
def get_exp_with_draft_applied(exp_id, user_id): DCNL 'If a draft exists for the given user and exploration, DCNL apply it to the exploration. DCNL Args: DCNL exp_id: str. The id of the exploration. DCNL user_id: str. The id of the user whose draft is to be applied.'
def discard_draft(exp_id, user_id): DCNL 'Discard the draft for the given user and exploration. DCNL Args: DCNL exp_id: str. The id of the exploration. DCNL user_id: str. The id of the user whose draft is to be discarded.'
def get_topic_similarities_dict(): DCNL 'Returns a 2d dict of topic similarities. Creates the default similarity DCNL dict if it does not exist yet.'
def save_topic_similarities(topic_similarities): DCNL 'Stores topic similarities in the datastore. Returns the newly created or DCNL changed entity.'
def _create_default_topic_similarities(): DCNL 'Creates the default topic similarities, and stores them in the datastore. DCNL The keys are names of the default categories, and values are DCNL DEFAULT_TOPIC_SIMILARITY if the keys are different and DCNL SAME_TOPIC_SIMILARITY if the keys are the same. DCNL Returns the newly created TopicSimilaritiesModel.'
def get_topic_similarity(topic_1, topic_2): DCNL 'Gets the similarity between two topics, as a float between 0 and 1. DCNL It checks whether the two topics are in the list of default topics. If DCNL not, it returns the default similarity if the topics are different or 1 if DCNL the topics are the same.'
def get_topic_similarities_as_csv(): DCNL 'Downloads all similarities corresponding to the current topics as a DCNL string which contains the contents of a csv file. DCNL The first line is a list of the current topics. The next lines are an DCNL adjacency matrix of similarities.'
def _validate_topic_similarities(data): DCNL 'Validates topic similarities given by data, which should be a string DCNL of comma-separated values. DCNL The first line of data should be a list of topic names. The next lines DCNL should be a symmetric adjacency matrix of similarities, which are floats DCNL between 0.0 and 1.0. DCNL This function checks whether topics belong in the current list of DCNL known topics, and if the adjacency matrix is valid.'
def update_topic_similarities(data): DCNL 'Updates all topic similarity pairs given by data, which should be a DCNL string of comma-separated values. DCNL The first line of data should be a list of topic names. The next lines DCNL should be a symmetric adjacency matrix of similarities, which are floats DCNL between 0.0 and 1.0. DCNL The topic names should belong to the current list of topics, but they need DCNL not include every current topic. If a topic name is not in the data, its DCNL similarities remain as the previous value or the default.'
def get_item_similarity(reference_exp_category, reference_exp_language_code, reference_exp_owner_ids, compared_exp_category, compared_exp_language_code, compared_exp_last_updated, compared_exp_owner_ids, compared_exp_status): DCNL 'Returns the ranking of compared_exp to reference_exp as a DCNL recommendation. This returns a value between 0.0 to 10.0. A higher value DCNL indicates the compared_exp is a better recommendation as an exploration to DCNL start after completing reference_exp. DCNL Comparison of similarity is based on the similarity of exploration topics, DCNL whether the explorations have the same language or author. The ranking of DCNL compared_exp is increased if it is publicized or is newly updated. It DCNL returns 0.0 if compared_exp is private.'
def set_recommendations(exp_id, new_recommendations): DCNL 'Stores a list of exploration ids of recommended explorations to play DCNL after completing the exploration keyed by exp_id.'
def get_exploration_recommendations(exp_id): DCNL 'Gets a list of ids of at most 10 recommended explorations to play DCNL after completing the exploration keyed by exp_id.'
def get_all_actions(role): DCNL 'Returns a list of all actions (including inherited actions) DCNL that can be performed by the given role. DCNL Args: DCNL role: str. A string defining user role. It should be a key of DCNL PARENT_ROLES. DCNL Returns: DCNL list(str). A list of actions accessible to the role. DCNL Raises: DCNL Exception: The given role does not exist.'
def get_role_graph_data(): DCNL 'Returns dict for displaying roles graph. DCNL Returns: DCNL dict. A dict containing data in following format: DCNL links: list(dict(str:str)). List of dicts defing each edge in DCNL following format: DCNL source: Role Id from which edge is going out. DCNL target: Role Id to which edge is incoming. DCNL nodes: dict(str:str). Mapping of role Id to its human readable DCNL format.'
def log_role_query(user_id, intent, role=None, username=None): DCNL 'Stores the query to role structure in RoleQueryAuditModel.'
def get_max_priority_role(role_list): DCNL 'Returns the role with maximum priority among the given list DCNL of roles. DCNL Args: DCNL role_list: list(str). List of roles. DCNL Returns: DCNL str. Role with highest priority among given roles.'
def get_role_changes(old_config_properties, new_config_properties): DCNL 'This function takes old and new versions of config property values DCNL and returns the resultant roles for users in terms of new system. DCNL Args: DCNL old_config_properties: dict(str:list). Dict mapping config property ids DCNL to their values. DCNL new_config_properties: dict(str:list). Dict mapping config property ids DCNL to their values. DCNL Returns: DCNL dict(str:str). Dict mapping usernames to roles in terms of new system.'
def register_module(): DCNL 'Registers this module in the registry.'
def get_file_contents(filepath, raw_bytes=False, mode='r'): DCNL 'Gets the contents of a file, given a relative filepath from oppia/.'
def get_exploration_components_from_dir(dir_path): DCNL 'Gets the (yaml, assets) from the contents of an exploration data dir. DCNL Args: DCNL dir_path: a full path to the exploration root directory. DCNL Returns: DCNL a 2-tuple, the first element of which is a yaml string, and the second DCNL element of which is a list of (filepath, content) 2-tuples. The filepath DCNL does not include the assets/ prefix. DCNL Raises: DCNL Exception: if the following condition doesn\'t hold: "There is exactly one DCNL file not in assets/, and this file has a .yaml suffix".'
def get_exploration_components_from_zip(zip_file_contents): DCNL 'Gets the (yaml, assets) from the contents of an exploration zip file. DCNL Args: DCNL zip_file_contents: a string of raw bytes representing the contents of DCNL a zip file that comprises the exploration. DCNL Returns: DCNL a 2-tuple, the first element of which is a yaml string, and the second DCNL element of which is a list of (filepath, content) 2-tuples. The filepath DCNL does not include the assets/ prefix. DCNL Raises: DCNL Exception: if the following condition doesn\'t hold: "There is exactly one DCNL file not in assets/, and this file has a .yaml suffix".'
def get_comma_sep_string_from_list(items): DCNL 'Turns a list of items into a comma-separated string.'
def to_ascii(input_string): DCNL 'Change unicode characters in a string to ascii if possible.'
def yaml_from_dict(dictionary, width=80): DCNL 'Gets the YAML representation of a dict.'
def dict_from_yaml(yaml_str): DCNL 'Gets the dict representation of a YAML string.'
def recursively_remove_key(obj, key_to_remove): DCNL 'Recursively removes keys from a list or dict.'
def get_random_int(upper_bound): DCNL 'Returns a random integer in [0, upper_bound).'
def get_random_choice(alist): DCNL 'Gets a random element from a list.'
def convert_png_binary_to_data_url(content): DCNL 'Converts a png image string (represented by \'content\') to a data URL.'
def convert_png_to_data_url(filepath): DCNL 'Converts the png file at filepath to a data URL.'
def set_url_query_parameter(url, param_name, param_value): DCNL 'Set or replace a query parameter, and return the modified URL.'
def convert_to_hash(input_string, max_length): DCNL 'Convert a string to a SHA1 hash.'
def get_time_in_millisecs(datetime_obj): DCNL 'Returns time in milliseconds since the Epoch. DCNL Args: DCNL datetime_obj: An object of type datetime.datetime.'
def get_current_time_in_millisecs(): DCNL 'Returns time in milliseconds since the Epoch.'
def get_human_readable_time_string(time_msec): DCNL 'Given a time in milliseconds since the epoch, get a human-readable DCNL time string for the admin dashboard.'
def are_datetimes_close(later_datetime, earlier_datetime): DCNL 'Given two datetimes, determines whether they are separated by less than DCNL feconf.PROXIMAL_TIMEDELTA_SECS seconds.'
def vfs_construct_path(base_path, *path_components): DCNL 'Mimics behavior of os.path.join on Posix machines.'
def vfs_normpath(path): DCNL 'Normalize path from posixpath.py, eliminating double slashes, etc.'
def require_valid_name(name, name_type, allow_empty=False): DCNL 'Generic name validation. DCNL Args: DCNL name: the name to validate. DCNL name_type: a human-readable string, like \'the exploration title\' or DCNL \'a state name\'. This will be shown in error messages. DCNL allow_empty: if True, empty strings are allowed.'
def capitalize_string(input_string): DCNL 'Converts the first character of a string to its uppercase equivalent (if DCNL it\'s a letter), and returns the result.'
def _get_short_language_description(full_language_description): DCNL 'Given one of the descriptions in constants.ALL_LANGUAGE_CODES, generates DCNL the corresponding short description.'
def unescape_encoded_uri_component(escaped_string): DCNL 'Unescape a string that is encoded with encodeURIComponent.'
def get_asset_dir_prefix(): DCNL 'Returns prefix for asset directory depending whether dev or prod. DCNL It is used as a prefix in urls for images, css and script files.'
def get_template_dir_prefix(): DCNL 'Returns prefix for template directory depending whether dev or prod. DCNL It is used as a prefix in urls for js script files under the templates DCNL directory.'
def convert_to_str(string_to_convert): DCNL 'Converts the given unicode string to a string. If the string is not DCNL unicode, we return the string. DCNL Args: DCNL string_to_convert: unicode|str. DCNL Returns: DCNL str. The encoded string.'
def register_module(): DCNL 'Registers this module in the registry.'
def register_module(): DCNL 'Registers this module in the registry.'
def get_redirect_route(regex_route, handler, defaults=None): DCNL 'Returns a route that redirects /foo/ to /foo. DCNL Warning: this method strips off parameters after the trailing slash. URLs DCNL with parameters should be formulated without the trailing slash.'
def webapp_add_wsgi_middleware(app): DCNL 'Add AppStats recording. DCNL This also sets the level of appstats log messages to \'debug\' by DCNL monkey-patching. For details, see: DCNL https://stackoverflow.com/questions/4305243/disable-appstats-logging'
def _is_filename_excluded_for_bad_patterns_check(pattern, filename): DCNL 'Checks if file is excluded from the bad patterns check. DCNL Args: DCNL pattern: str. The pattern to be checked against. DCNL filename: str. Name of the file. DCNL Returns: DCNL bool: Whether to exclude the given file from this DCNL particular pattern check.'
def _get_changed_filenames(): DCNL 'Returns a list of modified files (both staged and unstaged) DCNL Returns: DCNL a list of filenames of modified files.'
def _get_glob_patterns_excluded_from_eslint(eslintignore_path): DCNL 'Collects excludeFiles from .eslintignore file. DCNL Args: DCNL eslintignore_path: str. Path to .eslintignore file. DCNL Returns: DCNL a list of files in excludeFiles.'
def _get_all_files_in_directory(dir_path, excluded_glob_patterns): DCNL 'Recursively collects all files in directory and DCNL subdirectories of specified path. DCNL Args: DCNL dir_path: str. Path to the folder to be linted. DCNL excluded_glob_patterns: set(str). Set of all glob patterns DCNL to be excluded. DCNL Returns: DCNL a list of files in directory and subdirectories without excluded files.'
def _lint_js_files(node_path, eslint_path, files_to_lint, stdout, result): DCNL 'Prints a list of lint errors in the given list of JavaScript files. DCNL Args: DCNL node_path: str. Path to the node binary. DCNL eslint_path: str. Path to the ESLint binary. DCNL files_to_lint: list(str). A list of filepaths to lint. DCNL stdout:  multiprocessing.Queue. A queue to store ESLint outputs. DCNL result: multiprocessing.Queue. A queue to put results of test. DCNL Returns: DCNL None'
def _lint_py_files(config_pylint, files_to_lint, result): DCNL 'Prints a list of lint errors in the given list of Python files. DCNL Args: DCNL config_pylint: str. Path to the .pylintrc file. DCNL files_to_lint: list(str). A list of filepaths to lint. DCNL result: multiprocessing.Queue. A queue to put results of test. DCNL Returns: DCNL None'
def _get_all_files(): DCNL 'This function is used to check if this script is ran from DCNL root directory and to return a list of all the files for linting and DCNL pattern checks.'
def _pre_commit_linter(all_files): DCNL 'This function is used to check if node-eslint dependencies are installed DCNL and pass ESLint binary path.'
def _check_newline_character(all_files): DCNL 'This function is used to check that each file DCNL ends with a single newline character.'
def _check_bad_patterns(all_files): DCNL 'This function is used for detecting bad patterns.'
def log(message, show_time=False): DCNL 'Logs a message to the terminal. DCNL If show_time is True, prefixes the message with the current time.'
def run_shell_cmd(exe, stdout=subprocess.PIPE, stderr=subprocess.PIPE): DCNL 'Runs a shell command and captures the stdout and stderr output. DCNL If the cmd fails, raises Exception. Otherwise, returns a string containing DCNL the concatenation of the stdout and stderr logs.'
def _check_all_tasks(tasks): DCNL 'Checks the results of all tasks.'
def _execute_tasks(tasks, batch_size=24): DCNL 'Starts all tasks and checks the results. DCNL Runs no more than \'batch_size\' tasks at a time.'
def _get_all_test_targets(test_path=None): DCNL 'Returns a list of test targets for all classes under test_path DCNL containing tests.'
def main(): DCNL 'Run the tests.'
def _run_cmd(cmd_str): DCNL 'Runs the command and returns the output. DCNL Raises subprocess.CalledProcessError upon failure. DCNL Args: DCNL cmd_str (str): The command string to execute DCNL Returns: DCNL (str): The output of the command.'
def _gather_logs(start, stop='HEAD'): DCNL 'Gathers the logs between the start and endpoint. DCNL Args: DCNL start (str): Tag, Branch or SHA1 of start point DCNL stop (str):  Tag, Branch or SHA1 of end point, defaults to HEAD DCNL Returns: DCNL list[Log]: List of Logs'
def _extract_issues(logs): DCNL 'Extract references to issues out of a list of Logs DCNL Args: DCNL logs (list[Log]): List of Logs to parse DCNL Returns: DCNL set[str]: Set of found issues as links to Github'
def _check_versions(current_release): DCNL 'Checks if the versions for the exploration or collection schemas have DCNL changed. DCNL Args: DCNL current_release (str): The current release tag to diff against. DCNL Returns: DCNL List of variable names that changed'
def _git_diff_names_only(left, right='HEAD'): DCNL 'Get names of changed files from git. DCNL Args: DCNL left (str): Lefthand timepoint DCNL right (str): rightand timepoint DCNL Returns: DCNL (list): List of files that are different between the two points.'
def _check_setup_scripts(base_release_tag, changed_only=True): DCNL 'Check if setup scripts have changed. DCNL Args: DCNL base_release_tag (str): The current release tag to diff against. DCNL changed_only (bool): If set to False will return all tested files DCNL instead of just the changed ones. DCNL Returns: DCNL dict consisting of script --> boolean indicating whether or not it has DCNL changed (filtered by default to those that are modified).'
def _check_storage_models(current_release): DCNL 'Check if files in core/storage have changed and returns them. DCNL Args: DCNL current_release: The current release version DCNL Returns: DCNL (list): The changed files (if any)'
def main(): DCNL 'Collects necessary info and dumps it to disk.'
def ensure_directory_exists(d): DCNL 'Creates the given directory if it does not already exist.'
def require_cwd_to_be_oppia(allow_deploy_dir=False): DCNL 'Ensures that the current working directory ends in \'oppia\'. DCNL If allow_deploy_dir is True, this also allows the cwd to be a directory DCNL called \'deploy-*\' which is a sibling of the oppia/ directory.'
def _minify(source_path, target_path): DCNL 'Runs the given file through a minifier and outputs it to target_path. DCNL Args: DCNL source_path: str. Absolute path to file to be minified. DCNL target_path: str. Absolute path to location where to copy DCNL the minified file.'
def _insert_hash(filepath, file_hash): DCNL 'Inserts hash into filepath before the file extension. DCNL Args: DCNL filepath: str. Path where the hash should be inserted. DCNL file_hash: str. Hash to be inserted into the path. DCNL Returns: DCNL str. Filepath with hash inserted.'
def ensure_directory_exists(filepath): DCNL 'Ensures if directory tree exists, if not creates the directories. DCNL Args: DCNL filepath: str. Path to file located in directory that we want to DCNL ensure exists.'
def process_html(source_path, target_path, file_hashes): DCNL 'Copies contents of HTML file, while removing whitespace and DCNL replacing paths inside the file with paths with hashes. DCNL Args: DCNL source_path: str. Absolute path to file to be processed. DCNL target_path: str. Absolute path to location where to copy DCNL the processed file. DCNL file_hashes: dict(str, str). Dictionary of file hashes.'
def process_css(source_path, target_path): DCNL 'Runs the given CSS file through a minifier and outputs it to target_path. DCNL Args: DCNL source_path: str. Absolute path to file to be minified. DCNL target_path: str. Absolute path to location where to copy DCNL the minified file.'
def process_js(source_path, target_path): DCNL 'Runs the given JS file through a minifier and outputs it to target_path. DCNL Args: DCNL source_path: str. Absolute path to file to be minified. DCNL target_path: str. Absolute path to location where to copy DCNL the minified file.'
def build_minified_third_party_libs(output_directory): DCNL 'Generates third party files via Gulp. DCNL Args: DCNL output_directory: str. Path to directory where to generate files.'
def hash_should_be_inserted(filepath): DCNL 'Returns if the file should be renamed to include hash in DCNL the path. DCNL Args: DCNL filepath: str. Path relative to directory we are currently building. DCNL Returns: DCNL bool. True if filepath should contain hash else False.'
def copy_files_source_to_target(source, target, file_hashes): DCNL 'Copies all files in source directory to target directory and renames DCNL them to include hash in their name. DCNL Args: DCNL source: str. Path relative to /oppia directory of directory DCNL containing files and directories to be copied. DCNL target: str. Path relative to /oppia directory of directory where DCNL to copy the files and directories. DCNL file_hashes: dict(str, str). Dictionary of file hashes.'
def is_file_hash_provided_to_frontend(filepath): DCNL 'Returns if the hash for the filepath should be provided to the frontend. DCNL Args: DCNL filepath: str. Relative path to the file. DCNL Returns: DCNL bool. True if file hash should be provided to the frontend else False.'
def generate_md5_hash(filepath): DCNL 'Returns md5 hash of file. DCNL Args: DCNL filepath: str. Absolute path to the file. DCNL Returns: DCNL str. Hexadecimal hash of specified file.'
def get_file_hashes(directory_path): DCNL 'Returns hashes of all files in directory tree. DCNL Args: DCNL directory_path: str. Root directory of the tree. DCNL Returns: DCNL dict(str, str). Dictionary with keys specifying file paths and values DCNL specifying file hashes.'
def filter_hashes(file_hashes): DCNL 'Filters hashes that should be provided to the frontend DCNL and prefixes / in front of the keys. DCNL Args: DCNL file_hashes: dict(str, str). Dictionary of file hashes. DCNL Returns: DCNL dict(str, str). Filtered dictionary of file hashes.'
def get_hashes_json_file_contents(file_hashes): DCNL 'Return JS code that loads hashes needed for frontend into variable. DCNL Args: DCNL file_hashes: dict(str, str). Dictionary of file hashes. DCNL Returns: DCNL str. JS code loading hashes as JSON into variable.'
def save_hashes_as_json(target_filepath, file_hashes): DCNL 'Save hashes in JS file containing JSON for files that DCNL are to be interpolated in the frontend. DCNL Args: DCNL target_filepath: str. Path relative to /oppia directory defining DCNL location where to save the JS file with hashes. The final location DCNL path would also contain hash. DCNL file_hashes: dict(str, str). Dictionary of file hashes.'
def build_files(source, target, file_hashes): DCNL 'Minifies all CSS and JS files, removes whitespace from HTML and DCNL interpolates paths in HTML to include hashes in source DCNL directory and copies it to target. DCNL Args: DCNL source: str. Path relative to /oppia directory of directory DCNL containing files and directories to be copied. DCNL target: str. Path relative to /oppia directory of directory where DCNL to copy the files and directories. DCNL file_hashes: dict(str, str). Dictionary of file hashes.'
def generate_build_directory(): DCNL 'Generates hashes for files. Minifies files and interpolates paths DCNL in HTMLs to include hashes. Renames the files to include hashes and copies DCNL them into build directory.'
def download_files(source_url_root, target_dir, source_filenames): DCNL 'Downloads a group of files and saves them to a given directory. DCNL Each file is downloaded only if it does not already exist. DCNL Args: DCNL source_url_root: the URL to prepend to all the filenames. DCNL target_dir: the directory to save the files to. DCNL source_filenames: a list of filenames. Each filename is appended to the DCNL end of the source_url_root in order to give the URL from which to DCNL download the file. The downloaded file is then placed in target_dir, DCNL and retains the same filename.'
def download_and_unzip_files(source_url, target_parent_dir, zip_root_name, target_root_name): DCNL 'Downloads a zip file, unzips it, and saves the result in a given dir. DCNL The download occurs only if the target directory that the zip file unzips DCNL to does not exist. DCNL NB: This function assumes that the root level of the zip file has exactly DCNL one folder. DCNL Args: DCNL source_url: the URL from which to download the zip file. DCNL target_parent_dir: the directory to save the contents of the zip file to. DCNL zip_root_name: the name of the top-level folder in the zip directory. DCNL target_root_name: the name that the top-level folder should be renamed to DCNL in the local directory.'
def download_and_untar_files(source_url, target_parent_dir, tar_root_name, target_root_name): DCNL 'Downloads a tar file, untars it, and saves the result in a given dir. DCNL The download occurs only if the target directory that the tar file untars DCNL to does not exist. DCNL NB: This function assumes that the root level of the tar file has exactly DCNL one folder. DCNL Args: DCNL source_url: the URL from which to download the tar file. DCNL target_parent_dir: the directory to save the contents of the tar file to. DCNL tar_root_name: the name of the top-level folder in the tar directory. DCNL target_root_name: the name that the top-level folder should be renamed to DCNL in the local directory.'
def get_file_contents(filepath, mode='r'): DCNL 'Gets the contents of a file, given a relative filepath from oppia/.'
def return_json(filepath): DCNL 'Return json object when provided url DCNL Args: DCNL filepath: the path to the json file. DCNL Return: DCNL a parsed json objects'
def test_manifest_syntax(dependency_type, dependency_dict): DCNL 'This checks syntax of the manifest.json dependencies. DCNL Display warning message when there is an error and terminate the program. DCNL Args: DCNL dependency_type: dependency download format. DCNL dependency_dict: manifest.json dependency dict'
def validate_manifest(filepath): DCNL 'This validates syntax of the manifest.json DCNL Args: DCNL filepath: the path to the json file.'
def download_manifest_files(filepath): DCNL 'This download all files to the required folders DCNL Args: DCNL filepath: the path to the json file.'
def preprocess_release(): DCNL 'Pre-processes release files. DCNL This function should be called from within RELEASE_DIR_NAME. Currently it DCNL does the following: DCNL (1) Changes the app name in app.yaml to APP_NAME. DCNL (2) Substitutes image files in the images/ directory.'
def get_unique_id(): DCNL 'Returns a unique id.'
def preprocess_release(): DCNL 'Pre-processes release files. DCNL This function should be called from within RELEASE_DIR_NAME. Currently it DCNL does the following: DCNL (1) Changes the app name in app.yaml to APP_NAME.'
def _start_subprocess_for_result(cmd): DCNL 'Starts subprocess and returns (stdout, stderr)'
def _git_diff_name_status(left, right, diff_filter=''): DCNL 'Compare two branches/commits etc with git. DCNL Parameter: DCNL left: the lefthand comperator DCNL right: the righthand comperator DCNL diff_filter: arguments given to --diff-filter (ACMRTD...) DCNL Returns: DCNL List of FileDiffs (tuple with name/status) DCNL Raises: DCNL ValueError if git command fails'
def _compare_to_remote(remote, local_branch, remote_branch=None): DCNL 'Compare local with remote branch with git diff. DCNL Parameter: DCNL remote: Git remote being pushed to DCNL local_branch: Git branch being pushed to DCNL remote_branch: The branch on the remote to test against. If None same DCNL as local branch. DCNL Returns: DCNL List of file names that are modified, changed, renamed or added DCNL but not deleted DCNL Raises: DCNL ValueError if git command fails'
def _extract_files_to_lint(file_diffs): DCNL 'Grab only files out of a list of FileDiffs that have a ACMRT status'
def _collect_files_being_pushed(ref_list, remote): DCNL 'Collect modified files and filter those that need linting. DCNL Parameter: DCNL ref_list: list of references to parse (provided by git in stdin) DCNL remote: the remote being pushed to DCNL Returns: DCNL dict: Dict mapping branch names to 2-tuples of the form (list of DCNL changed files, list of files to lint)'
def _has_uncommitted_files(): DCNL 'Returns true if the repo contains modified files that are uncommitted. DCNL Ignores untracked files.'
def normalize_against_schema(obj, schema, apply_custom_validators=True): DCNL 'Validate the given object using the schema, normalizing if necessary. DCNL Returns: DCNL the normalized object. DCNL Raises: DCNL AssertionError: if the object fails to validate against the schema.'
def _get_hashable_value(value): DCNL 'This function returns a hashable version of the input value. If the DCNL value itself is hashable, it simply returns that value. If it\'s a list, it DCNL will return a tuple with all of the list\'s elements converted to hashable DCNL types. If it\'s a dictionary, it will first convert it to a list of pairs, DCNL where the key and value of the pair are converted to hashable types, then DCNL it will convert this list as any other list would be converted.'
def _count_answers(answer_dicts_list): DCNL 'Count an input list of answer objects using collections.Counter. This DCNL returns a list of pairs with the first element being an answer object and DCNL the second being the number of times it shows up in the input list.'
def _calculate_top_answer_frequencies(state_answers_dict, num_results): DCNL 'Computes the number of occurrences of each answer, keeping only the top DCNL num_results answers, and returns a list of dicts; each dict has keys DCNL \'answer\' and \'frequency\'. DCNL This method is run from within the context of a MapReduce job.'
def _validate_ui_config(obj_type, ui_config): DCNL 'Validates the value of a UI configuration.'
def _validate_validator(obj_type, validator): DCNL 'Validates the value of a \'validator\' field.'
def _validate_dict_keys(dict_to_check, required_keys, optional_keys): DCNL 'Checks that all of the required keys, and possibly some of the optional DCNL keys, are in the given dict. DCNL Raises: DCNL AssertionError: if the validation fails.'
def validate_schema(schema): DCNL 'Validates a schema. DCNL This is meant to be a utility function that should be used by tests to DCNL ensure that all schema definitions in the codebase are valid. DCNL Each schema is a dict with at least a key called \'type\'. The \'type\' can DCNL take one of the SCHEMA_TYPE_* values declared above. In addition, there DCNL may be additional keys for specific types: DCNL - \'list\' requires an additional \'items\' property, which specifies the type DCNL of the elements in the list. It also allows for an optional \'len\' DCNL property which specifies the len of the list. DCNL - \'dict\' requires an additional \'properties\' property, which specifies the DCNL names of the keys in the dict, and schema definitions for their values. DCNL There may also be an optional \'post_normalizers\' key whose value is a list DCNL of normalizers. DCNL Raises: DCNL AssertionError: if the schema is not valid.'
def _js_string_filter(value): DCNL 'Converts a value to a JSON string for use in JavaScript code.'
def _log2_floor_filter(value): DCNL 'Returns the logarithm base 2 of the given value, rounded down.'
def parse_string(string, params, autoescape=True): DCNL 'Parses a string using Jinja templating. DCNL Args: DCNL string: the string to be parsed. DCNL params: the parameters to parse the string with. DCNL autoescape: whether to enable autoescaping when parsing. DCNL Returns: DCNL the parsed string, or None if the string could not be parsed.'
def evaluate_object(obj, params): DCNL 'Returns a copy of `obj` after parsing strings in it using `params`.'
def interpolate_cache_slug(string): DCNL 'Parses the cache slug in the input string. DCNL Returns: DCNL the parsed string, or None if the string could not be parsed.'
def memoize(obj): DCNL 'An expensive memoizer that works with unhashables'
def hashable(a): DCNL 'Turn some unhashable objects into hashable ones.'
def assign_step_methods(model, step=None, methods=STEP_METHODS, step_kwargs=None): DCNL 'Assign model variables to appropriate step methods. DCNL Passing a specified model will auto-assign its constituent stochastic DCNL variables to step methods based on the characteristics of the variables. DCNL This function is intended to be called automatically from `sample()`, but DCNL may be called manually. Each step method passed should have a DCNL `competence()` method that returns an ordinal competence value DCNL corresponding to the variable passed to it. This value quantifies the DCNL appropriateness of the step method for sampling the variable. DCNL Parameters DCNL model : Model object DCNL A fully-specified model object DCNL step : step function or vector of step functions DCNL One or more step functions that have been assigned to some subset of DCNL the model\'s parameters. Defaults to None (no assigned variables). DCNL methods : vector of step method classes DCNL The set of step methods from which the function may choose. Defaults DCNL to the main step methods provided by PyMC3. DCNL step_kwargs : dict DCNL Parameters for the samplers. Keys are the lower case names of DCNL the step method, values a dict of arguments. DCNL Returns DCNL methods : list DCNL List of step methods associated with the model\'s variables.'
def sample(draws=500, step=None, init='auto', n_init=200000, start=None, trace=None, chain=0, njobs=1, tune=500, nuts_kwargs=None, step_kwargs=None, progressbar=True, model=None, random_seed=(-1), live_plot=False, discard_tuned_samples=True, live_plot_kwargs=None, **kwargs): DCNL 'Draw samples from the posterior using the given step methods. DCNL Multiple step methods are supported via compound step methods. DCNL Parameters DCNL draws : int DCNL The number of samples to draw. Defaults to 500. The number of tuned DCNL samples are discarded by default. See discard_tuned_samples. DCNL step : function or iterable of functions DCNL A step function or collection of functions. If there are variables DCNL without a step methods, step methods for those variables will DCNL be assigned automatically. DCNL init : str DCNL Initialization method to use for auto-assigned NUTS samplers. DCNL * auto : Choose a default initialization method automatically. DCNL Currently, this is `\'unif+adapt_diag\'`, but this can change in DCNL the future. If you depend on the exact behaviour, choose an DCNL initialization method explicitly. DCNL * adapt_diag : Start with a identity mass matrix and then adapt DCNL a diagonal based on the variance of the tuning samples. All DCNL chains use the test value (usually the prior mean) as starting DCNL point. DCNL * jitter+adapt_diag : Same as `adapt_diag`, but add uniform jitter DCNL in [-1, 1] to the starting point in each chain. DCNL * advi+adapt_diag : Run ADVI and then adapt the resulting diagonal DCNL mass matrix based on the sample variance of the tuning samples. DCNL * advi+adapt_diag_grad : Run ADVI and then adapt the resulting DCNL diagonal mass matrix based on the variance of the gradients DCNL during tuning. This is **experimental** and might be removed DCNL in a future release. DCNL * advi : Run ADVI to estimate posterior mean and diagonal mass DCNL matrix. DCNL * advi_map: Initialize ADVI with MAP and use MAP as starting point. DCNL * map : Use the MAP as starting point. This is discouraged. DCNL * nuts : Run NUTS and estimate posterior mean and mass matrix from DCNL the trace. DCNL n_init : int DCNL Number of iterations of initializer DCNL If \'ADVI\', number of iterations, if \'nuts\', number of draws. DCNL start : dict, or array of dict DCNL Starting point in parameter space (or partial point) DCNL Defaults to trace.point(-1)) if there is a trace provided and DCNL model.test_point if not (defaults to empty dict). DCNL trace : backend, list, or MultiTrace DCNL This should be a backend instance, a list of variables to track, DCNL or a MultiTrace object with past values. If a MultiTrace object DCNL is given, it must contain samples for the chain number `chain`. DCNL If None or a list of variables, the NDArray backend is used. DCNL Passing either "text" or "sqlite" is taken as a shortcut to set DCNL up the corresponding backend (with "mcmc" used as the base DCNL name). DCNL chain : int DCNL Chain number used to store sample in backend. If `njobs` is DCNL greater than one, chain numbers will start here. DCNL njobs : int DCNL Number of parallel jobs to start. If None, set to number of cpus DCNL in the system - 2. DCNL tune : int DCNL Number of iterations to tune, if applicable (defaults to 500). DCNL These samples will be drawn in addition to samples and discarded DCNL unless discard_tuned_samples is set to True. DCNL nuts_kwargs : dict DCNL Options for the NUTS sampler. See the docstring of NUTS DCNL for a complete list of options. Common options are DCNL * target_accept: float in [0, 1]. The step size is tuned such DCNL that we approximate this acceptance rate. Higher values like 0.9 DCNL or 0.95 often work better for problematic posteriors. DCNL * max_treedepth: The maximum depth of the trajectory tree. DCNL * step_scale: float, default 0.25 DCNL The initial guess for the step size scaled down by `1/n**(1/4)`. DCNL If you want to pass options to other step methods, please use DCNL `step_kwargs`. DCNL step_kwargs : dict DCNL Options for step methods. Keys are the lower case names of DCNL the step method, values are dicts of keyword arguments. DCNL You can find a full list of arguments in the docstring of DCNL the step methods. If you want to pass arguments only to nuts, DCNL you can use `nuts_kwargs`. DCNL progressbar : bool DCNL Whether or not to display a progress bar in the command line. The DCNL bar shows the percentage of completion, the sampling speed in DCNL samples per second (SPS), and the estimated remaining time until DCNL completion ("expected time of arrival"; ETA). DCNL model : Model (optional if in `with` context) DCNL random_seed : int or list of ints DCNL A list is accepted if more if `njobs` is greater than one. DCNL live_plot : bool DCNL Flag for live plotting the trace while sampling DCNL live_plot_kwargs : dict DCNL Options for traceplot. Example: live_plot_kwargs={\'varnames\': [\'x\']} DCNL discard_tuned_samples : bool DCNL Whether to discard posterior samples of the tune interval. DCNL Returns DCNL trace : pymc3.backends.base.MultiTrace DCNL A `MultiTrace` object that contains the samples. DCNL Examples DCNL .. code:: ipython DCNL >>> import pymc3 as pm DCNL ... n = 100 DCNL ... h = 61 DCNL ... alpha = 2 DCNL ... beta = 2 DCNL .. code:: ipython DCNL >>> with pm.Model() as model: # context management DCNL ...     p = pm.Beta(\'p\', alpha=alpha, beta=beta) DCNL ...     y = pm.Binomial(\'y\', n=n, p=p, observed=h) DCNL ...     trace = pm.sample(2000, tune=1000, njobs=4) DCNL >>> pm.df_summary(trace) DCNL mean        sd  mc_error   hpd_2.5  hpd_97.5 DCNL p  0.604625  0.047086   0.00078  0.510498  0.694774'
def iter_sample(draws, step, start=None, trace=None, chain=0, tune=None, model=None, random_seed=(-1)): DCNL 'Generator that returns a trace on each iteration using the given DCNL step method.  Multiple step methods supported via compound step DCNL method returns the amount of time taken. DCNL Parameters DCNL draws : int DCNL The number of samples to draw DCNL step : function DCNL Step function DCNL start : dict DCNL Starting point in parameter space (or partial point) DCNL Defaults to trace.point(-1)) if there is a trace provided and DCNL model.test_point if not (defaults to empty dict) DCNL trace : backend, list, or MultiTrace DCNL This should be a backend instance, a list of variables to track, DCNL or a MultiTrace object with past values. If a MultiTrace object DCNL is given, it must contain samples for the chain number `chain`. DCNL If None or a list of variables, the NDArray backend is used. DCNL chain : int DCNL Chain number used to store sample in backend. If `njobs` is DCNL greater than one, chain numbers will start here. DCNL tune : int DCNL Number of iterations to tune, if applicable (defaults to None) DCNL model : Model (optional if in `with` context) DCNL random_seed : int or list of ints DCNL A list is accepted if more if `njobs` is greater than one. DCNL Example DCNL for trace in iter_sample(500, step):'
def stop_tuning(step): DCNL 'stop tuning the current step method'
def sample_ppc(trace, samples=None, model=None, vars=None, size=None, random_seed=None, progressbar=True): DCNL 'Generate posterior predictive samples from a model given a trace. DCNL Parameters DCNL trace : backend, list, or MultiTrace DCNL Trace generated from MCMC sampling. DCNL samples : int DCNL Number of posterior predictive samples to generate. Defaults to the DCNL length of `trace` DCNL model : Model (optional if in `with` context) DCNL Model used to generate `trace` DCNL vars : iterable DCNL Variables for which to compute the posterior predictive samples. DCNL Defaults to `model.observed_RVs`. DCNL size : int DCNL The number of random draws from the distribution specified by the DCNL parameters in each sample of the trace. DCNL random_seed : int DCNL Seed for the random number generator. DCNL progressbar : bool DCNL Whether or not to display a progress bar in the command line. The DCNL bar shows the percentage of completion, the sampling speed in DCNL samples per second (SPS), and the estimated remaining time until DCNL completion ("expected time of arrival"; ETA). DCNL Returns DCNL samples : dict DCNL Dictionary with the variables as keys. The values corresponding to the DCNL posterior predictive samples.'
def sample_ppc_w(traces, samples=None, models=None, size=None, weights=None, random_seed=None, progressbar=True): DCNL 'Generate weighted posterior predictive samples from a list of models and DCNL a list of traces according to a set of weights. DCNL Parameters DCNL traces : list DCNL List of traces generated from MCMC sampling. The number of traces should DCNL be equal to the number of weights. DCNL samples : int DCNL Number of posterior predictive samples to generate. Defaults to the DCNL length of the shorter trace in traces. DCNL models : list DCNL List of models used to generate the list of traces. The number of models DCNL should be equal to the number of weights and the number of observed RVs DCNL should be the same for all models. DCNL By default a single model will be inferred from `with` context, in this DCNL case results will only be meaningful if all models share the same DCNL distributions for the observed RVs. DCNL size : int DCNL The number of random draws from the distributions specified by the DCNL parameters in each sample of the trace. DCNL weights: array-like DCNL Individual weights for each trace. Default, same weight for each model. DCNL random_seed : int DCNL Seed for the random number generator. DCNL progressbar : bool DCNL Whether or not to display a progress bar in the command line. The DCNL bar shows the percentage of completion, the sampling speed in DCNL samples per second (SPS), and the estimated remaining time until DCNL completion ("expected time of arrival"; ETA). DCNL Returns DCNL samples : dict DCNL Dictionary with the variables as keys. The values corresponding to the DCNL posterior predictive samples from the weighted models.'
def init_nuts(init='auto', njobs=1, n_init=500000, model=None, random_seed=(-1), progressbar=True, **kwargs): DCNL 'Set up the mass matrix initialization for NUTS. DCNL NUTS convergence and sampling speed is extremely dependent on the DCNL choice of mass/scaling matrix. This function implements different DCNL methods for choosing or adapting the mass matrix. DCNL Parameters DCNL init : str DCNL Initialization method to use. DCNL * auto : Choose a default initialization method automatically. DCNL Currently, this is `\'unif+adapt_diag\'`, but this can change in DCNL the future. If you depend on the exact behaviour, choose an DCNL initialization method explicitly. DCNL * adapt_diag : Start with a identity mass matrix and then adapt DCNL a diagonal based on the variance of the tuning samples. All DCNL chains use the test value (usually the prior mean) as starting DCNL point. DCNL * jitter+adapt_diag : Same as `adapt_diag`, but add uniform jitter DCNL in [-1, 1] to the starting point in each chain. DCNL * advi+adapt_diag : Run ADVI and then adapt the resulting diagonal DCNL mass matrix based on the sample variance of the tuning samples. DCNL * advi+adapt_diag_grad : Run ADVI and then adapt the resulting DCNL diagonal mass matrix based on the variance of the gradients DCNL during tuning. This is **experimental** and might be removed DCNL in a future release. DCNL * advi : Run ADVI to estimate posterior mean and diagonal mass DCNL matrix. DCNL * advi_map: Initialize ADVI with MAP and use MAP as starting point. DCNL * map : Use the MAP as starting point. This is discouraged. DCNL * nuts : Run NUTS and estimate posterior mean and mass matrix from DCNL the trace. DCNL njobs : int DCNL Number of parallel jobs to start. DCNL n_init : int DCNL Number of iterations of initializer DCNL If \'ADVI\', number of iterations, if \'nuts\', number of draws. DCNL model : Model (optional if in `with` context) DCNL progressbar : bool DCNL Whether or not to display a progressbar for advi sampling. DCNL **kwargs : keyword arguments DCNL Extra keyword arguments are forwarded to pymc3.NUTS. DCNL Returns DCNL start : pymc3.model.Point DCNL Starting point for sampler DCNL nuts_sampler : pymc3.step_methods.NUTS DCNL Instantiated and initialized NUTS sampler object'
def load(name, model=None): DCNL 'Load SQLite database. DCNL Parameters DCNL name : str DCNL Path to SQLite database file DCNL model : Model DCNL If None, the model is taken from the `with` context. DCNL Returns DCNL A MultiTrace instance'
def _get_table_list(cursor): DCNL 'Return a list of table names in the current database.'
def _get_chain_list(cursor, varname): DCNL 'Return a list of sorted chains for `varname`.'
def _rows_to_ndarray(cursor): DCNL 'Convert SQL row to NDArray.'
def load(name, model=None): DCNL 'Load HDF5 arrays. DCNL Parameters DCNL name : str DCNL Path to HDF5 arrays file DCNL model : Model DCNL If None, the model is taken from the `with` context. DCNL Returns DCNL A MultiTrace instance'
def merge_traces(mtraces): DCNL 'Merge MultiTrace objects. DCNL Parameters DCNL mtraces : list of MultiTraces DCNL Each instance should have unique chain numbers. DCNL Raises DCNL A ValueError is raised if any traces have overlapping chain numbers. DCNL Returns DCNL A MultiTrace instance with merged chains'
def _squeeze_cat(results, combine, squeeze): DCNL 'Squeeze and concatenate the results depending on values of DCNL `combine` and `squeeze`.'
def load(name, model=None): DCNL 'Load Text database. DCNL Parameters DCNL name : str DCNL Name of directory with files (one per chain) DCNL model : Model DCNL If None, the model is taken from the `with` context. DCNL Returns DCNL A MultiTrace instance'
def dump(name, trace, chains=None): DCNL 'Store values from NDArray trace as CSV files. DCNL Parameters DCNL name : str DCNL Name of directory to store CSV files in DCNL trace : MultiTrace of NDArray traces DCNL Result of MCMC run with default NDArray backend DCNL chains : list DCNL Chains to dump. If None, all chains are dumped.'
def paripool(function, work, nprocs=None, chunksize=1): DCNL 'Initialise a pool of workers and execute a function in parallel by DCNL forking the process. Does forking once during initialisation. DCNL Parameters DCNL function : callable DCNL python function to be executed in parallel DCNL work : list DCNL of iterables that are to be looped over/ executed in parallel usually DCNL these objects are different for each task. DCNL nprocs : int DCNL number of processors to be used in parallel process DCNL chunksize : int DCNL number of work packages to throw at workers in each instance'
def trace_to_dataframe(trace, chains=None, varnames=None, include_transformed=False): DCNL 'Convert trace to Pandas DataFrame. DCNL Parameters DCNL trace : NDarray trace DCNL chains : int or list of ints DCNL Chains to include. If None, all chains are used. A single DCNL chain value can also be given. DCNL varnames : list of variable names DCNL Variables to be included in the DataFrame, if None all variable are DCNL included. DCNL include_transformed: boolean DCNL If true transformed variables will be included in the resulting DCNL DataFrame.'
def create_flat_names(varname, shape): DCNL 'Return flat variable names for `varname` of `shape`. DCNL Examples DCNL >>> create_flat_names(\'x\', (5,)) DCNL [\'x__0\', \'x__1\', \'x__2\', \'x__3\', \'x__4\'] DCNL >>> create_flat_names(\'x\', (2, 2)) DCNL [\'x__0_0\', \'x__0_1\', \'x__1_0\', \'x__1_1\']'
def _create_shape(flat_names): DCNL 'Determine shape from `create_flat_names` output.'
def all_discrete(comp_dists): DCNL 'Determine if all distributions in comp_dists are discrete'
def draw_values(params, point=None): DCNL 'Draw (fix) parameter values. Handles a number of cases: DCNL 1) The parameter is a scalar DCNL 2) The parameter is an *RV DCNL a) parameter can be fixed to the value in the point DCNL b) parameter can be fixed by sampling from the *RV DCNL c) parameter can be fixed using tag.test_value (last resort) DCNL 3) The parameter is a tensor variable/constant. Can be evaluated using DCNL theano.function, but a variable may contain nodes which DCNL a) are named parameters in the point DCNL b) are *RVs with a random method'
@memoize DCNL def _compile_theano_function(param, vars, givens=None): DCNL 'Compile theano function for a given parameter and input variables. DCNL This function is memoized to avoid repeating costly theano compilations DCNL when repeatedly drawing values, which is done when generating posterior DCNL predictive samples. DCNL Parameters DCNL param : Model variable from which to draw value DCNL vars : Children variables of `param` DCNL givens : Variables to be replaced in the Theano graph DCNL Returns DCNL A compiled theano function that takes the values of `vars` as input DCNL positional args'
def _draw_value(param, point=None, givens=None): DCNL 'Draw a random value from a distribution or return a constant. DCNL Parameters DCNL param : number, array like, theano variable or pymc3 random variable DCNL The value or distribution. Constants or shared variables DCNL will be converted to an array and returned. Theano variables DCNL are evaluated. If `param` is a pymc3 random variables, draw DCNL a new value from it and return that, unless a value is specified DCNL in `point`. DCNL point : dict, optional DCNL A dictionary from pymc3 variable names to their values. DCNL givens : dict, optional DCNL A dictionary from theano variables to their values. These values DCNL are used to evaluate `param` if it is a theano variable.'
def broadcast_shapes(*args): DCNL 'Return the shape resulting from broadcasting multiple shapes. DCNL Represents numpy\'s broadcasting rules. DCNL Parameters DCNL *args : array-like of int DCNL Tuples or arrays or lists representing the shapes of arrays to be broadcast. DCNL Returns DCNL Resulting shape or None if broadcasting is not possible.'
def generate_samples(generator, *args, **kwargs): DCNL 'Generate samples from the distribution of a random variable. DCNL Parameters DCNL generator : function DCNL Function to generate the random samples. The function is DCNL expected take parameters for generating samples and DCNL a keyword argument `size` which determines the shape DCNL of the samples. DCNL The *args and **kwargs (stripped of the keywords below) will be DCNL passed to the generator function. DCNL keyword arguments DCNL dist_shape : int or tuple of int DCNL The shape of the random variable (i.e., the shape attribute). DCNL size : int or tuple of int DCNL The required shape of the samples. DCNL broadcast_shape: tuple of int or None DCNL The shape resulting from the broadcasting of the parameters. DCNL If not specified it will be inferred from the shape of the DCNL parameters. This may be required when the parameter shape DCNL does not determine the shape of a single sample, for example, DCNL the shape of the probabilities in the Categorical distribution. DCNL Any remaining *args and **kwargs are passed on to the generator function.'
def WishartBartlett(name, S, nu, is_cholesky=False, return_cholesky=False, testval=None): DCNL 'Bartlett decomposition of the Wishart distribution. As the Wishart DCNL distribution requires the matrix to be symmetric positive semi-definite DCNL it is impossible for MCMC to ever propose acceptable matrices. DCNL Instead, we can use the Barlett decomposition which samples a lower DCNL diagonal matrix. Specifically: DCNL .. math:: DCNL \text{If} L \sim \begin{pmatrix} DCNL \sqrt{c_1} & 0 & 0 \\ DCNL z_{21} & \sqrt{c_2} & 0 \\ DCNL z_{31} & z_{32} & \sqrt{c_3} DCNL \end{pmatrix} DCNL \text{with} c_i \sim \chi^2(n-i+1) \text{ and } n_{ij} \sim \mathcal{N}(0, 1), \text{then} \\ DCNL L \times A \times A.T \times L.T \sim \text{Wishart}(L \times L.T, \nu) DCNL See http://en.wikipedia.org/wiki/Wishart_distribution#Bartlett_decomposition DCNL for more information. DCNL Parameters DCNL S : ndarray DCNL p x p positive definite matrix DCNL Or: DCNL p x p lower-triangular matrix that is the Cholesky factor DCNL of the covariance matrix. DCNL nu : int DCNL Degrees of freedom, > dim(S). DCNL is_cholesky : bool (default=False) DCNL Input matrix S is already Cholesky decomposed as S.T * S DCNL return_cholesky : bool (default=False) DCNL Only return the Cholesky decomposed matrix. DCNL testval : ndarray DCNL p x p positive definite matrix used to initialize DCNL Note DCNL This is not a standard Distribution class but follows a similar DCNL interface. Besides the Wishart distribution, it will add RVs DCNL c and z to your model which make up the matrix. DCNL This distribution is usually a bad idea to use as a prior for multivariate DCNL normal. You should instead use LKJCholeskyCov or LKJCorr.'
def bound(logp, *conditions, **kwargs): DCNL 'Bounds a log probability density with several conditions. DCNL Parameters DCNL logp : float DCNL *conditions : booleans DCNL broadcast_conditions : bool (optional, default=True) DCNL If True, broadcasts logp to match the largest shape of the conditions. DCNL This is used e.g. in DiscreteUniform where logp is a scalar constant and the shape DCNL is specified via the conditions. DCNL If False, will return the same shape as logp. DCNL This is used e.g. in Multinomial where broadcasting can lead to differences in the logp. DCNL Returns DCNL logp with elements set to -inf where any condition is False'
def logpow(x, m): DCNL 'Calculates log(x**m) since m*log(x) will fail when m, x = 0.'
def std_cdf(x): DCNL 'Calculates the standard normal cumulative distribution function.'
def i0(x): DCNL 'Calculates the 0 order modified Bessel function of the first kind""'
def i1(x): DCNL 'Calculates the 1 order modified Bessel function of the first kind""'
def sd2rho(sd): DCNL '`sd -> rho` theano converter DCNL :math:`mu + sd*e = mu + log(1+exp(rho))*e`'
def rho2sd(rho): DCNL '`rho -> sd` theano converter DCNL :math:`mu + sd*e = mu + log(1+exp(rho))*e`'
def log_normal(x, mean, **kwargs): DCNL 'Calculate logarithm of normal distribution at point `x` DCNL with given `mean` and `std` DCNL Parameters DCNL x : Tensor DCNL point of evaluation DCNL mean : Tensor DCNL mean of normal distribution DCNL kwargs : one of parameters `{sd, tau, w, rho}` DCNL Notes DCNL There are four variants for density parametrization. DCNL They are: DCNL 1) standard deviation - `std` DCNL 2) `w`, logarithm of `std` :math:`w = log(std)` DCNL 3) `rho` that follows this equation :math:`rho = log(exp(std) - 1)` DCNL 4) `tau` that follows this equation :math:`tau = std^{-1}`'
def MvNormalLogp(): DCNL 'Compute the log pdf of a multivariate normal distribution. DCNL This should be used in MvNormal.logp once Theano#5908 is released. DCNL Parameters DCNL cov : tt.matrix DCNL The covariance matrix. DCNL delta : tt.matrix DCNL Array of deviations from the mean.'
def get_tau_sd(tau=None, sd=None): DCNL 'Find precision and standard deviation DCNL .. math:: DCNL au = rac{1}{\sigma^2} DCNL Parameters DCNL tau : array-like, optional DCNL sd : array-like, optional DCNL Results DCNL Returns tuple (tau, sd) DCNL Notes DCNL If neither tau nor sd is provided, returns (1., 1.)'
def multigammaln(a, p): DCNL 'Multivariate Log Gamma DCNL :Parameters: DCNL a : tensor like DCNL p : int degrees of freedom DCNL p > 0'
def escape_latex(strng): DCNL 'Consistently escape LaTeX special characters for _repr_latex_ in IPython DCNL Implementation taken from the IPython magic `format_latex` DCNL Example DCNL escape_latex(\'disease_rate\')  # \'disease\_rate\' DCNL Parameters DCNL strng : str DCNL string to escape LaTeX characters DCNL Returns DCNL str DCNL A string with LaTeX escaped'
def get_transformed_name(name, transform): DCNL 'Consistent way of transforming names DCNL Parameters DCNL name : str DCNL Name to transform DCNL transform : transforms.Transform DCNL Should be a subclass of `transforms.Transform` DCNL Returns DCNL str DCNL A string to use for the transformed variable'
def is_transformed_name(name): DCNL 'Quickly check if a name was transformed with `get_transormed_name` DCNL Parameters DCNL name : str DCNL Name to check DCNL Returns DCNL bool DCNL Boolean, whether the string could have been produced by `get_transormed_name`'
def get_untransformed_name(name): DCNL 'Undo transformation in `get_transformed_name`. Throws ValueError if name wasn\'t transformed DCNL Parameters DCNL name : str DCNL Name to untransform DCNL Returns DCNL str DCNL String with untransformed version of the name.'
def get_default_varnames(var_iterator, include_transformed): DCNL 'Helper to extract default varnames from a trace. DCNL Parameters DCNL varname_iterator : iterator DCNL Elements will be cast to string to check whether it is transformed, and optionally filtered DCNL include_transformed : boolean DCNL Should transformed variable names be included in return value DCNL Returns DCNL list DCNL List of variables, possibly filtered'
def get_variable_name(variable): DCNL 'Returns the variable data type if it is a constant, otherwise DCNL returns the argument name.'
def update_start_vals(a, b, model): DCNL 'Update a with b, without overwriting existing keys. Values specified for DCNL transformed variables on the original scale are also transformed and inserted.'
def get_data(filename): DCNL 'Returns a BytesIO object for a package data file. DCNL Parameters DCNL filename : str DCNL file to load DCNL Returns DCNL BytesIO of the data'
def get_lkj_cases(): DCNL 'Log probabilities calculated using the formulas in: DCNL http://www.sciencedirect.com/science/article/pii/S0047259X09000876'
def product(domains, n_samples=(-1)): DCNL 'Get an iterator over a product of domains. DCNL Args: DCNL domains: a dictionary of (name, object) pairs, where the objects DCNL must be "domain-like", as in, have a `.vals` property DCNL n_samples: int, maximum samples to return.  -1 to return whole product DCNL Returns: DCNL list of the cartesian product of the domains'
def scipy_exponweib_sucks(value, alpha, beta): DCNL 'This function is required because SciPy\'s implementation of DCNL the Weibull PDF fails for some valid combinations of parameters, while the DCNL log-PDF fails for others.'
def test_posdef_symmetric3(): DCNL 'The test return 0 if the matrix has 0 eigenvalue. DCNL Is this correct?'
def select_by_precision(float64, float32): DCNL 'Helper function to choose reasonable decimal cutoffs for different floatX modes.'
def get_city_data(): DCNL 'Helper to get city data'
def inputvars(a): DCNL 'Get the inputs into a theano variables DCNL Parameters DCNL a : theano variable DCNL Returns DCNL r : list of tensor variables that are inputs'
def cont_inputs(f): DCNL 'Get the continuous inputs into a theano variables DCNL Parameters DCNL a : theano variable DCNL Returns DCNL r : list of tensor variables that are continuous inputs'
def floatX(X): DCNL 'Convert a theano tensor or numpy array to theano.config.floatX type.'
def smartfloatX(x): DCNL 'Convert non int types to floatX'
def gradient1(f, v): DCNL 'flat gradient of f wrt v'
def jacobian1(f, v): DCNL 'jacobian of f wrt v'
def make_shared_replacements(vars, model): DCNL 'Makes shared replacements for all *other* variables than the ones passed. DCNL This way functions can be called many times without setting unchanging variables. Allows us DCNL to use func.trust_input by removing the need for DictToArrayBijection and kwargs. DCNL Parameters DCNL vars : list of variables not to make shared DCNL model : model DCNL Returns DCNL Dict of variable -> new shared variable'
def join_nonshared_inputs(xs, vars, shared, make_shared=False): DCNL 'Takes a list of theano Variables and joins their non shared inputs into a single input. DCNL Parameters DCNL xs : list of theano tensors DCNL vars : list of variables to join DCNL Returns DCNL tensors, inarray DCNL tensors : list of same tensors but with inarray as input DCNL inarray : vector of inputs'
def reshape_t(x, shape): DCNL 'Work around fact that x.reshape(()) doesn\'t work'
def generator(gen, default=None): DCNL 'Generator variable with possibility to set default value and new generator. DCNL If generator is exhausted variable will produce default value if it is not None, DCNL else raises `StopIteration` exception that can be caught on runtime. DCNL Parameters DCNL gen : generator that implements __next__ (py3) or next (py2) method DCNL and yields np.arrays with same types DCNL default : np.array with the same type as generator produces DCNL Returns DCNL TensorVariable DCNL It has 2 new methods DCNL - var.set_gen(gen) : sets new generator DCNL - var.set_default(value) : sets new default value (None erases default value)'
def tt_rng(random_seed=None): DCNL 'Get the package-level random number generator or new with specified seed. DCNL Parameters DCNL random_seed : int DCNL If not None DCNL returns *new* theano random generator without replacing package global one DCNL Returns DCNL `theano.sandbox.rng_mrg.MRG_RandomStreams` instance DCNL `theano.sandbox.rng_mrg.MRG_RandomStreams` DCNL instance passed to the most recent call of `set_tt_rng`'
def set_tt_rng(new_rng): DCNL 'Set the package-level random number generator. DCNL Parameters DCNL new_rng : `theano.sandbox.rng_mrg.MRG_RandomStreams` instance DCNL The random number generator to use.'
def set_theano_conf(values): DCNL 'Change the theano configuration and return old values. DCNL This is similar to `theano.configparser.change_flags`, but it DCNL returns the original values in a pickleable form.'
def ix_(*args): DCNL 'Theano np.ix_ analog DCNL See numpy.lib.index_tricks.ix_ for reference'
def compute_sigma_level(trace1, trace2, nbins=20): DCNL 'From a set of traces, bin by number of standard deviations'
def plot_MCMC_trace(ax, xdata, ydata, trace, scatter=False, **kwargs): DCNL 'Plot traces and contours'
def plot_MCMC_model(ax, xdata, ydata, trace): DCNL 'Plot the linear model and 2sigma contours'
def plot_MCMC_results(xdata, ydata, trace, colors='k'): DCNL 'Plot both the trace and the model together'
def tune(scale, acc_rate): DCNL 'Tunes the scaling parameter for the proposal distribution DCNL according to the acceptance rate over the last tune_interval: DCNL Rate    Variance adaptation DCNL <0.001        x 0.1 DCNL <0.05         x 0.5 DCNL <0.2          x 0.9 DCNL >0.5          x 1.1 DCNL >0.75         x 2 DCNL >0.95         x 10'
def choose_proposal(proposal_name, scale=1.0): DCNL 'Initialise and select proposal distribution. DCNL Parameters DCNL proposal_name : string DCNL Name of the proposal distribution to initialise DCNL scale : float or :class:`numpy.ndarray` DCNL Returns DCNL class:`pymc3.Proposal` Object'
def sample_smc(n_steps, n_chains=100, step=None, start=None, homepath=None, stage=0, n_jobs=1, tune_interval=10, tune=None, progressbar=False, model=None, random_seed=(-1), rm_flag=True): DCNL 'Sequential Monte Carlo sampling DCNL Samples the solution space with n_chains of Metropolis chains, where each DCNL chain has n_steps iterations. Once finished, the sampled traces are DCNL evaluated: DCNL (1) Based on the likelihoods of the final samples, chains are weighted DCNL (2) the weighted covariance of the ensemble is calculated and set as new DCNL proposal distribution DCNL (3) the variation in the ensemble is calculated and the next tempering DCNL parameter (beta) calculated DCNL (4) New n_chains Metropolis chains are seeded on the traces with high DCNL weight for n_steps iterations DCNL (5) Repeat until beta > 1. DCNL Parameters DCNL n_steps : int DCNL The number of samples to draw for each Markov-chain per stage DCNL n_chains : int DCNL Number of chains used to store samples in backend. DCNL step : :class:`SMC` DCNL SMC initialisation object DCNL start : List of dictionaries DCNL with length of (n_chains) DCNL Starting points in parameter space (or partial point) DCNL Defaults to random draws from variables (defaults to empty dict) DCNL homepath : string DCNL Result_folder for storing stages, will be created if not existing. DCNL stage : int DCNL Stage where to start or continue the calculation. It is possible to DCNL continue after completed stages (stage should be the number of the DCNL completed stage + 1). If None the start will be at stage = 0. DCNL n_jobs : int DCNL The number of cores to be used in parallel. Be aware that theano has DCNL internal parallelisation. Sometimes this is more efficient especially DCNL for simple models. DCNL step.n_chains / n_jobs has to be an integer number! DCNL tune_interval : int DCNL Number of steps to tune for DCNL tune : int DCNL Number of iterations to tune, if applicable (defaults to None) DCNL progressbar : bool DCNL Flag for displaying a progress bar DCNL model : :class:`pymc3.Model` DCNL (optional if in `with` context) has to contain deterministic DCNL variable name defined under step.likelihood_name\' that contains the DCNL model likelihood DCNL random_seed : int or list of ints DCNL A list is accepted, more if `n_jobs` is greater than one. DCNL rm_flag : bool DCNL If True existing stage result folders are being deleted prior to DCNL sampling. DCNL References DCNL .. [Minson2013] Minson, S. E. and Simons, M. and Beck, J. L., (2013), DCNL Bayesian inversion for finite fault earthquake source models DCNL I- Theory and algorithm. Geophysical Journal International, 2013, DCNL 194(3), pp.1701-1726, DCNL `link <https://gji.oxfordjournals.org/content/194/3/1701.full>`__'
def _iter_sample(draws, step, start=None, trace=None, chain=0, tune=None, model=None, random_seed=(-1)): DCNL 'Modified from :func:`pymc3.sampling._iter_sample` to be more efficient with SMC algorithm.'
def _work_chain(work): DCNL 'Wrapper function for parallel execution of _sample i.e. the Markov Chains. DCNL Parameters DCNL work : List DCNL Containing all the information that is unique for each Markov Chain DCNL i.e. [:class:\'SMC\', chain_number(int), DCNL sampling index(int), start_point(dictionary)] DCNL Returns DCNL chain : int DCNL Index of chain that has been sampled'
def _iter_parallel_chains(draws, step, stage_path, progressbar, model, n_jobs, chains=None): DCNL 'Do Metropolis sampling over all the chains with each chain being DCNL sampled \'draws\' times. Parallel execution according to n_jobs.'
def tune(acc_rate): DCNL 'Tune adaptively based on the acceptance rate. DCNL Parameters DCNL acc_rate: scalar, float DCNL Acceptance rate of the Metropolis sampling DCNL Returns DCNL scaling: scalar float'
def logp_forw(out_vars, vars, shared): DCNL 'Compile Theano function of the model and the input and output variables. DCNL Parameters DCNL out_vars : List DCNL containing :class:`pymc3.Distribution` for the output variables DCNL vars : List DCNL containing :class:`pymc3.Distribution` for the input variables DCNL shared : List DCNL containing :class:`theano.tensor.Tensor` for dependend shared data'
def _theano_hamiltonian(model_vars, shared, logpt, potential): DCNL 'Create a Hamiltonian with shared inputs. DCNL Parameters DCNL model_vars : array of variables to be sampled DCNL shared : theano tensors that are already shared DCNL logpt : model log probability DCNL potential : hamiltonian potential DCNL Returns DCNL Hamiltonian : namedtuple with log pdf, gradient of log pdf, and potential functions DCNL q : Initial position for Hamiltonian Monte Carlo DCNL dlogp_func: theano function that computes the gradient of a log pdf at a point'
def _theano_energy_function(H, q, **theano_kwargs): DCNL 'Create a theano function for computing energy at a point in parameter space. DCNL Parameters DCNL H : Hamiltonian namedtuple DCNL q : theano variable, starting position DCNL theano_kwargs : passed to theano.function DCNL Returns DCNL energy_function : theano function that computes the energy at a point (p, q) in phase space DCNL p : Starting momentum variable.'
def _theano_leapfrog_integrator(H, q, p, **theano_kwargs): DCNL 'Compute a theano function that computes one leapfrog step. DCNL Returns not only the new positiona and momentum, but also the energy. DCNL Parameters DCNL H : Hamiltonian DCNL q : theano.tensor DCNL p : theano.tensor DCNL theano_kwargs : passed to theano.function DCNL Returns DCNL theano function which returns DCNL q_new, p_new, energy_new'
def get_theano_hamiltonian_functions(model_vars, shared, logpt, potential, use_single_leapfrog=False, integrator='leapfrog', **theano_kwargs): DCNL 'Construct theano functions for the Hamiltonian, energy, and leapfrog integrator. DCNL Parameters DCNL model_vars : array of variables to be sampled DCNL shared : theano tensors that are already shared DCNL logpt : model log probability DCNL potential : Hamiltonian potential DCNL theano_kwargs : dictionary of keyword arguments to pass to theano functions DCNL use_single_leapfrog : bool DCNL if only 1 integration step is done at a time (as in NUTS), this DCNL provides a ~2x speedup DCNL integrator : str DCNL Integration scheme to use. One of "leapfog", "two-stage", or DCNL "three-stage". DCNL Returns DCNL H : Hamiltonian namedtuple DCNL energy_function : theano function computing energy at a point in phase space DCNL leapfrog_integrator : theano function integrating the Hamiltonian from a point in phase space DCNL theano_variables : dictionary of variables used in the computation graph which may be useful'
def energy(H, q, p): DCNL 'Compute the total energy for the Hamiltonian at a given position/momentum.'
def leapfrog(H, q, p, epsilon, n_steps): DCNL 'Leapfrog integrator. DCNL Estimates `p(t)` and `q(t)` at time :math:`t = n \cdot e`, by integrating the DCNL Hamiltonian equations DCNL .. math:: DCNL \frac{dq_i}{dt} = \frac{\partial H}{\partial p_i} DCNL \frac{dp_i}{dt} = \frac{\partial H}{\partial q_i} DCNL with :math:`p(0) = p`, :math:`q(0) = q` DCNL Parameters DCNL H : Hamiltonian instance. DCNL Tuple of `logp, dlogp, potential`. DCNL q : Theano.tensor DCNL initial position vector DCNL p : Theano.tensor DCNL initial momentum vector DCNL epsilon : float, step size DCNL n_steps : int, number of iterations DCNL Returns DCNL position : Theano.tensor DCNL position estimate at time :math:`n \cdot e`. DCNL momentum : Theano.tensor DCNL momentum estimate at time :math:`n \cdot e`.'
def _theano_single_threestage(H, q, p, q_grad, **theano_kwargs): DCNL 'Perform a single step of a third order symplectic integration scheme. DCNL References DCNL Blanes, Sergio, Fernando Casas, and J. M. Sanz-Serna. "Numerical DCNL Integrators for the Hybrid Monte Carlo Method." SIAM Journal on DCNL Scientific Computing 36, no. 4 (January 2014): A1556-80. DCNL doi:10.1137/130932740. DCNL Mannseth, Janne, Tore Selland Kleppe, and Hans J. Skaug. "On the DCNL Application of Higher Order Symplectic Integrators in DCNL Hamiltonian Monte Carlo." arXiv:1608.07048 [Stat], DCNL August 25, 2016. http://arxiv.org/abs/1608.07048.'
def _theano_single_twostage(H, q, p, q_grad, **theano_kwargs): DCNL 'Perform a single step of a second order symplectic integration scheme. DCNL References DCNL Blanes, Sergio, Fernando Casas, and J. M. Sanz-Serna. "Numerical DCNL Integrators for the Hybrid Monte Carlo Method." SIAM Journal on DCNL Scientific Computing 36, no. 4 (January 2014): A1556-80. DCNL doi:10.1137/130932740. DCNL Mannseth, Janne, Tore Selland Kleppe, and Hans J. Skaug. "On the DCNL Application of Higher Order Symplectic Integrators in DCNL Hamiltonian Monte Carlo." arXiv:1608.07048 [Stat], DCNL August 25, 2016. http://arxiv.org/abs/1608.07048.'
def _theano_single_leapfrog(H, q, p, q_grad, **theano_kwargs): DCNL 'Leapfrog integrator for a single step. DCNL See above for documentation.  This is optimized for the case where only a single step is DCNL needed, in case of, for example, a recursive algorithm.'
def quad_potential(C, is_cov): DCNL 'Compute a QuadPotential object from a scaling matrix. DCNL Parameters DCNL C : arraylike, 0 <= ndim <= 2 DCNL scaling matrix for the potential DCNL vector treated as diagonal matrix. DCNL is_cov : Boolean DCNL whether C is provided as a covariance matrix or hessian DCNL Returns DCNL q : Quadpotential'
def partial_check_positive_definite(C): DCNL 'Make a simple but partial check for Positive Definiteness.'
def isquadpotential(value): DCNL 'Check whether an object might be a QuadPotential object.'
def _value_error(cond, str): DCNL 'Throws ValueError if cond is False'
def prior_dlogp(vars, model, flat_view): DCNL 'Returns the gradient of the prior on the parameters as a vector of size D x 1'
def elemwise_dlogL(vars, model, flat_view): DCNL 'Returns Jacobian of the log likelihood for each training datum wrt vars DCNL as a matrix of size N x D'
def metrop_select(mr, q, q0): DCNL 'Perform rejection/acceptance step for Metropolis class samplers. DCNL Returns the new sample q if a uniform random number is less than the DCNL metropolis acceptance rate (`mr`), and the old sample otherwise, along DCNL with a boolean indicating whether the sample was accepted. DCNL Parameters DCNL mr : float, Metropolis acceptance rate DCNL q : proposed sample DCNL q0 : current sample DCNL Returns DCNL q or q0'
def get_chol(cov, chol): DCNL 'Get Cholesky decomposition of the prior covariance. DCNL Ensure that exactly one of the prior covariance or Cholesky DCNL decomposition is passed. If the prior covariance was passed, then DCNL return its Cholesky decomposition. DCNL Parameters DCNL cov : array, optional DCNL Covariance matrix of the multivariate Gaussian prior. DCNL chol : array, optional DCNL Cholesky decomposition of the covariance matrix of the DCNL multivariate Gaussian prior.'
def _get_rvss(minibatch_RVs, local_RVs, observed_RVs, minibatch_tensors, total_size): DCNL 'Returns local_RVs and observed_RVs. DCNL This function is used for backward compatibility of how input arguments are DCNL given.'
def _make_logpt(global_RVs, local_RVs, observed_RVs, potentials): DCNL 'Return expression of log probability.'
def _elbo_t(logp, uw_g, uw_l, inarray_g, inarray_l, c_g, c_l, n_mcsamples, random_seed): DCNL 'Return expression of approximate ELBO based on Monte Carlo sampling.'
@change_flags(compute_test_value='ignore') DCNL def advi_minibatch(vars=None, start=None, model=None, n=5000, n_mcsamples=1, minibatch_RVs=None, minibatch_tensors=None, minibatches=None, global_RVs=None, local_RVs=None, observed_RVs=None, encoder_params=None, total_size=None, optimizer=None, learning_rate=0.001, epsilon=0.1, random_seed=None, mode=None): DCNL 'Perform mini-batch ADVI. DCNL This function implements a mini-batch automatic differentiation variational DCNL inference (ADVI; Kucukelbir et al., 2015) with the meanfield DCNL approximation. Autoencoding variational Bayes (AEVB; Kingma and Welling, DCNL 2014) is also supported. DCNL For explanation, we classify random variables in probabilistic models into DCNL three types. Observed random variables DCNL :math:`{\cal Y}=\{\mathbf{y}_{i}\}_{i=1}^{N}` are :math:`N` observations. DCNL Each :math:`\mathbf{y}_{i}` can be a set of observed random variables, DCNL i.e., :math:`\mathbf{y}_{i}=\{\mathbf{y}_{i}^{k}\}_{k=1}^{V_{o}}`, where DCNL :math:`V_{k}` is the number of the types of observed random variables DCNL in the model. DCNL The next ones are global random variables DCNL :math:`\Theta=\{\theta^{k}\}_{k=1}^{V_{g}}`, which are used to calculate DCNL the probabilities for all observed samples. DCNL The last ones are local random variables DCNL :math:`{\cal Z}=\{\mathbf{z}_{i}\}_{i=1}^{N}`, where DCNL :math:`\mathbf{z}_{i}=\{\mathbf{z}_{i}^{k}\}_{k=1}^{V_{l}}`. DCNL These RVs are used only in AEVB. DCNL The goal of ADVI is to approximate the posterior distribution DCNL :math:`p(\Theta,{\cal Z}|{\cal Y})` by variational posterior DCNL :math:`q(\Theta)\prod_{i=1}^{N}q(\mathbf{z}_{i})`. All of these terms DCNL are normal distributions (mean-field approximation). DCNL :math:`q(\Theta)` is parametrized with its means and standard deviations. DCNL These parameters are denoted as :math:`\gamma`. While :math:`\gamma` is DCNL a constant, the parameters of :math:`q(\mathbf{z}_{i})` are dependent on DCNL each observation. Therefore these parameters are denoted as DCNL :math:`\xi(\mathbf{y}_{i}; \nu)`, where :math:`\nu` is the parameters DCNL of :math:`\xi(\cdot)`. For example, :math:`\xi(\cdot)` can be a DCNL multilayer perceptron or convolutional neural network. DCNL In addition to :math:`\xi(\cdot)`, we can also include deterministic DCNL mappings for the likelihood of observations. We denote the parameters of DCNL the deterministic mappings as :math:`\eta`. An example of such mappings is DCNL the deconvolutional neural network used in the convolutional VAE example DCNL in the PyMC3 notebook directory. DCNL This function maximizes the evidence lower bound (ELBO) DCNL :math:`{\cal L}(\gamma, \nu, \eta)` defined as follows: DCNL .. math:: DCNL {\cal L}(\gamma,\nu,\eta) & = DCNL \mathbf{c}_{o}\mathbb{E}_{q(\Theta)}\left[ DCNL \sum_{i=1}^{N}\mathbb{E}_{q(\mathbf{z}_{i})}\left[ DCNL \log p(\mathbf{y}_{i}|\mathbf{z}_{i},\Theta,\eta) DCNL \right]\right] \\ & DCNL - \mathbf{c}_{g}KL\left[q(\Theta)||p(\Theta)\right] DCNL - \mathbf{c}_{l}\sum_{i=1}^{N} DCNL KL\left[q(\mathbf{z}_{i})||p(\mathbf{z}_{i})\right], DCNL where :math:`KL[q(v)||p(v)]` is the Kullback-Leibler divergence DCNL .. math:: DCNL KL[q(v)||p(v)] = \int q(v)\log\frac{q(v)}{p(v)}dv, DCNL :math:`\mathbf{c}_{o/g/l}` are vectors for weighting each term of ELBO. DCNL More precisely, we can write each of the terms in ELBO as follows: DCNL .. math:: DCNL \mathbf{c}_{o}\log p(\mathbf{y}_{i}|\mathbf{z}_{i},\Theta,\eta) & = & DCNL \sum_{k=1}^{V_{o}}c_{o}^{k} DCNL \log p(\mathbf{y}_{i}^{k}| DCNL {\rm pa}(\mathbf{y}_{i}^{k},\Theta,\eta)) \\ DCNL \mathbf{c}_{g}KL\left[q(\Theta)||p(\Theta)\right] & = & DCNL \sum_{k=1}^{V_{g}}c_{g}^{k}KL\left[ DCNL q(\theta^{k})||p(\theta^{k}|{\rm pa(\theta^{k})})\right] \\ DCNL \mathbf{c}_{l}KL\left[q(\mathbf{z}_{i}||p(\mathbf{z}_{i})\right] & = & DCNL \sum_{k=1}^{V_{l}}c_{l}^{k}KL\left[ DCNL q(\mathbf{z}_{i}^{k})|| DCNL p(\mathbf{z}_{i}^{k}|{\rm pa}(\mathbf{z}_{i}^{k}))\right], DCNL where :math:`{\rm pa}(v)` denotes the set of parent variables of :math:`v` DCNL in the directed acyclic graph of the model. DCNL When using mini-batches, :math:`c_{o}^{k}` and :math:`c_{l}^{k}` should be DCNL set to :math:`N/M`, where :math:`M` is the number of observations in each DCNL mini-batch. Another weighting scheme was proposed in DCNL (Blundell et al., 2015) for accelarating model fitting. DCNL For working with ADVI, we need to give the probabilistic model DCNL (:code:`model`), the three types of RVs (:code:`observed_RVs`, DCNL :code:`global_RVs` and :code:`local_RVs`), the tensors to which DCNL mini-bathced samples are supplied (:code:`minibatches`) and DCNL parameters of deterministic mappings :math:`\xi` and :math:`\eta` DCNL (:code:`encoder_params`) as input arguments. DCNL :code:`observed_RVs` is a :code:`OrderedDict` of the form DCNL :code:`{y_k: c_k}`, where :code:`y_k` is a random variable defined in the DCNL PyMC3 model. :code:`c_k` is a scalar (:math:`c_{o}^{k}`) and it can be a DCNL shared variable. DCNL :code:`global_RVs` is a :code:`OrderedDict` of the form DCNL :code:`{t_k: c_k}`, where :code:`t_k` is a random variable defined in the DCNL PyMC3 model. :code:`c_k` is a scalar (:math:`c_{g}^{k}`) and it can be a DCNL shared variable. DCNL :code:`local_RVs` is a :code:`OrderedDict` of the form DCNL :code:`{z_k: ((m_k, s_k), c_k)}`, where :code:`z_k` is a random variable DCNL defined in the PyMC3 model. :code:`c_k` is a scalar (:math:`c_{l}^{k}`) DCNL and it can be a shared variable. :code:`(m_k, s_k)` is a pair of tensors DCNL of means and log standard deviations of the variational distribution; DCNL samples drawn from the variational distribution replaces :code:`z_k`. DCNL It should be noted that if :code:`z_k` has a transformation that changes DCNL the dimension (e.g., StickBreakingTransform), the variational distribution DCNL must have the same dimension. For example, if :code:`z_k` is distributed DCNL with Dirichlet distribution with :code:`p` choices, :math:`m_k` and DCNL :code:`s_k` has the shape :code:`(n_samples_in_minibatch, p - 1)`. DCNL :code:`minibatch_tensors` is a list of tensors (can be shared variables) DCNL to which mini-batch samples are set during the optimization. DCNL These tensors are observations (:code:`obs=`) in :code:`observed_RVs`. DCNL :code:`minibatches` is a generator of a list of :code:`numpy.ndarray`. DCNL Each item of the list will be set to tensors in :code:`minibatch_tensors`. DCNL :code:`encoder_params` is a list of shared variables of the parameters DCNL :math:`\nu` and :math:`\eta`. We do not need to include the variational DCNL parameters of the global variables, :math:`\gamma`, because these are DCNL automatically created and updated in this function. DCNL The following is a list of example notebooks using advi_minibatch: DCNL - docs/source/notebooks/GLM-hierarchical-advi-minibatch.ipynb DCNL - docs/source/notebooks/bayesian_neural_network_advi.ipynb DCNL - docs/source/notebooks/convolutional_vae_keras_advi.ipynb DCNL - docs/source/notebooks/gaussian-mixture-model-advi.ipynb DCNL - docs/source/notebooks/lda-advi-aevb.ipynb DCNL Parameters DCNL vars : object DCNL List of random variables. If None, variational posteriors (normal DCNL distribution) are fit for all RVs in the given model. DCNL start : Dict or None DCNL Initial values of parameters (variational means). DCNL model : Model DCNL Probabilistic model. DCNL n : int DCNL Number of iterations updating parameters. DCNL n_mcsamples : int DCNL Number of Monte Carlo samples to approximate ELBO. DCNL minibatch_RVs : list of ObservedRVs DCNL Random variables in the model for which mini-batch tensors are set. DCNL When this argument is given, both of arguments local_RVs and DCNL observed_RVs must be None. DCNL minibatch_tensors : list of (tensors or shared variables) DCNL Tensors used to create ObservedRVs in minibatch_RVs. DCNL minibatches : generator of list DCNL Generates a set of minibatches when calling next(). DCNL The length of the returned list must be the same with the number of DCNL random variables in `minibatch_tensors`. DCNL total_size : int DCNL Total size of training samples. This is used to appropriately scale the DCNL log likelihood terms corresponding to mini-batches in ELBO. DCNL observed_RVs : Ordered dict DCNL Include a scaling constant for the corresponding RV. See the above DCNL description. DCNL global_RVs : Ordered dict or None DCNL Include a scaling constant for the corresponding RV. See the above DCNL description. If :code:`None`, it is set to DCNL :code:`{v: 1 for v in grvs}`, where :code:`grvs` is DCNL :code:`list(set(vars) - set(list(local_RVs) + list(observed_RVs)))`. DCNL local_RVs : Ordered dict or None DCNL Include encoded variational parameters and a scaling constant for DCNL the corresponding RV. See the above description. DCNL encoder_params : list of theano shared variables DCNL Parameters of encoder. DCNL optimizer : (loss, list of shared variables) -> dict or OrderedDict DCNL A function that returns parameter updates given loss and shared DCNL variables of parameters. If :code:`None` (default), a default DCNL Adagrad optimizer is used with parameters :code:`learning_rate` DCNL and :code:`epsilon` below. DCNL learning_rate: float DCNL Base learning rate for adagrad. DCNL This parameter is ignored when :code:`optimizer` is set. DCNL epsilon : float DCNL Offset in denominator of the scale of learning rate in Adagrad. DCNL This parameter is ignored when :code:`optimizer` is set. DCNL random_seed : int DCNL Seed to initialize random state. DCNL Returns DCNL ADVIFit DCNL Named tuple, which includes \'means\', \'stds\', and \'elbo_vals\'. DCNL References DCNL - Kingma, D. P., & Welling, M. (2014). DCNL Auto-Encoding Variational Bayes. stat, 1050, 1. DCNL - Kucukelbir, A., Ranganath, R., Gelman, A., & Blei, D. (2015). DCNL Automatic variational inference in Stan. In Advances in neural DCNL information processing systems (pp. 568-576). DCNL - Blundell, C., Cornebise, J., Kavukcuoglu, K., & Wierstra, D. (2015). DCNL Weight Uncertainty in Neural Network. In Proceedings of the 32nd DCNL International Conference on Machine Learning (ICML-15) (pp. 1613-1622).'
def gen_random_state(): DCNL 'Helper to generate a random state for MRG_RandomStreams'
def advi(vars=None, start=None, model=None, n=5000, accurate_elbo=False, optimizer=None, learning_rate=0.001, epsilon=0.1, mode=None, tol_obj=0.01, eval_elbo=100, random_seed=None, progressbar=True): DCNL 'Perform automatic differentiation variational inference (ADVI). DCNL This function implements the meanfield ADVI, where the variational DCNL posterior distribution is assumed to be spherical Gaussian without DCNL correlation of parameters and fit to the true posterior distribution. DCNL The means and standard deviations of the variational posterior are referred DCNL to as variational parameters. DCNL The return value of this function is an :code:`ADVIfit` object, which has DCNL variational parameters. If you want to draw samples from the variational DCNL posterior, you need to pass the :code:`ADVIfit` object to DCNL :code:`pymc3.variational.sample_vp()`. DCNL The variational parameters are defined on the transformed space, which is DCNL required to do ADVI on an unconstrained parameter space as described in DCNL [KTR+2016]. The parameters in the :code:`ADVIfit` object are in the DCNL transformed space, while traces returned by :code:`sample_vp()` are in DCNL the original space as obtained by MCMC sampling methods in PyMC3. DCNL The variational parameters are optimized with given optimizer, which is a DCNL function that returns a dictionary of parameter updates as provided to DCNL Theano function. If no optimizer is provided, optimization is performed DCNL with a modified version of adagrad, where only the last (n_window) gradient DCNL vectors are used to control the learning rate and older gradient vectors DCNL are ignored. n_window denotes the size of time window and fixed to 10. DCNL Parameters DCNL vars : object DCNL Random variables. DCNL start : Dict or None DCNL Initial values of parameters (variational means). DCNL model : Model DCNL Probabilistic model. DCNL n : int DCNL Number of interations updating parameters. DCNL accurate_elbo : bool DCNL If true, 100 MC samples are used for accurate calculation of ELBO. DCNL optimizer : (loss, tensor) -> dict or OrderedDict DCNL A function that returns parameter updates given loss and parameter DCNL tensor. If :code:`None` (default), a default Adagrad optimizer is DCNL used with parameters :code:`learning_rate` and :code:`epsilon` below. DCNL learning_rate: float DCNL Base learning rate for adagrad. This parameter is ignored when DCNL optimizer is given. DCNL epsilon : float DCNL Offset in denominator of the scale of learning rate in Adagrad. DCNL This parameter is ignored when optimizer is given. DCNL tol_obj : float DCNL Relative tolerance for testing convergence of ELBO. DCNL eval_elbo : int DCNL Window for checking convergence of ELBO. Convergence will be checked DCNL for every multiple of eval_elbo. DCNL random_seed : int or None DCNL Seed to initialize random state. None uses current seed. DCNL mode :  string or `Mode` instance. DCNL Compilation mode passed to Theano functions DCNL progressbar : bool DCNL Whether or not to display a progress bar in the command line. The DCNL bar shows the percentage of completion, the sampling speed in DCNL samples per second (SPS), the estimated remaining time until DCNL completion ("expected time of arrival"; ETA), and the current ELBO. DCNL Returns DCNL ADVIFit DCNL Named tuple, which includes \'means\', \'stds\', and \'elbo_vals\'. DCNL \'means\' is the mean. \'stds\' is the standard deviation. DCNL \'elbo_vals\' is the trace of ELBO values during optimizaiton. DCNL References DCNL .. [KTR+2016] Kucukelbir, A., Tran, D., Ranganath, R., Gelman, A., DCNL and Blei, D. M. (2016). Automatic Differentiation Variational DCNL Inference. arXiv preprint arXiv:1603.00788.'
def _calc_elbo(vars, model, n_mcsamples, random_seed): DCNL 'Calculate approximate ELBO.'
def _elbo_t(logp, uw, inarray, n_mcsamples, random_seed): DCNL 'Create Theano tensor of approximate ELBO by Monte Carlo sampling.'
def adagrad_optimizer(learning_rate, epsilon, n_win=10): DCNL 'Returns a function that returns parameter updates. DCNL Parameter DCNL learning_rate : float DCNL Learning rate. DCNL epsilon : float DCNL Offset to avoid zero-division in the normalizer of adagrad. DCNL n_win : int DCNL Number of past steps to calculate scales of parameter gradients. DCNL Returns DCNL A function (loss, param) -> updates. DCNL loss : Theano scalar DCNL Loss function to be minimized (e.g., negative ELBO). DCNL param : List of shared variables DCNL Parameters to be optimized. DCNL updates : OrderedDict DCNL Parameter updates used in Theano functions.'
def sample_vp(vparams, draws=1000, model=None, local_RVs=None, random_seed=None, include_transformed=False, progressbar=True): DCNL 'Draw samples from variational posterior. DCNL Parameters DCNL vparams : dict or pymc3.variational.ADVIFit DCNL Estimated variational parameters of the model. DCNL draws : int DCNL Number of random samples. DCNL model : pymc3.Model DCNL Probabilistic model. DCNL random_seed : int or None DCNL Seed of random number generator.  None to use current seed. DCNL include_transformed : bool DCNL If True, transformed variables are also sampled. Default is False. DCNL Returns DCNL trace : pymc3.backends.base.MultiTrace DCNL Samples drawn from the variational posterior.'
def infmean(input_array): DCNL 'Return the mean of the finite values of the array'
def node_property(f): DCNL 'A shortcut for wrapping method to accessible tensor'
def collect_shared_to_list(params): DCNL 'Helper function for getting a list from DCNL usable representation of parameters DCNL Parameters DCNL params : {dict|None} DCNL Returns DCNL list'
def sample_approx(approx, draws=100, include_transformed=True): DCNL 'Draw samples from variational posterior. DCNL Parameters DCNL approx : :class:`Approximation` DCNL Approximation to sample from DCNL draws : `int` DCNL Number of random samples. DCNL include_transformed : `bool` DCNL If True, transformed variables are also sampled. Default is True. DCNL Returns DCNL trace : class:`pymc3.backends.base.MultiTrace` DCNL Samples drawn from variational posterior.'
def fit(n=10000, local_rv=None, method='advi', model=None, random_seed=None, start=None, inf_kwargs=None, **kwargs): DCNL 'Handy shortcut for using inference methods in functional way DCNL Parameters DCNL n : `int` DCNL number of iterations DCNL local_rv : dict[var->tuple] DCNL mapping {model_variable -> local_variable (:math:`\mu`, :math:`\rho`)} DCNL Local Vars are used for Autoencoding Variational Bayes DCNL See (AEVB; Kingma and Welling, 2014) for details DCNL method : str or :class:`Inference` DCNL string name is case insensitive in: DCNL -   \'advi\'  for ADVI DCNL -   \'fullrank_advi\'  for FullRankADVI DCNL -   \'advi->fullrank_advi\'  for fitting ADVI first and then FullRankADVI DCNL -   \'svgd\'  for Stein Variational Gradient Descent DCNL -   \'asvgd\'  for Amortized Stein Variational Gradient Descent DCNL -   \'nfvi\'  for Normalizing Flow DCNL -   \'nfvi=formula\'  for Normalizing Flow using formula DCNL model : :class:`Model` DCNL PyMC3 model for inference DCNL random_seed : None or int DCNL leave None to use package global RandomStream or other DCNL valid value to create instance specific one DCNL inf_kwargs : dict DCNL additional kwargs passed to :class:`Inference` DCNL start : `Point` DCNL starting point for inference DCNL Other Parameters DCNL frac : `float` DCNL if method is \'advi->fullrank_advi\' represents advi fraction when training DCNL kwargs : kwargs DCNL additional kwargs for :func:`Inference.fit` DCNL Returns DCNL :class:`Approximation`'
def get_or_compute_grads(loss_or_grads, params): DCNL 'Helper function returning a list of gradients DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to return the gradients for DCNL Returns DCNL list of expressions DCNL If `loss_or_grads` is a list, it is assumed to be a list of DCNL gradients and returned as is, unless it does not match the length DCNL of `params`, in which case a `ValueError` is raised. DCNL Otherwise, `loss_or_grads` is assumed to be a cost expression and DCNL the function returns `theano.grad(loss_or_grads, params)`. DCNL Raises DCNL ValueError DCNL If `loss_or_grads` is a list of a different length than `params`, or if DCNL any element of `params` is not a shared variable (while we could still DCNL compute its gradient, we can never update it and want to fail early).'
def sgd(loss_or_grads=None, params=None, learning_rate=0.001): DCNL 'Stochastic Gradient Descent (SGD) updates DCNL Generates update expressions of the form: DCNL * ``param := param - learning_rate * gradient`` DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL Optimizer can be called without both loss_or_grads and params DCNL in that case partial function is returned DCNL Examples DCNL >>> a = theano.shared(1.) DCNL >>> b = a*2 DCNL >>> updates = sgd(b, [a], learning_rate=.01) DCNL >>> isinstance(updates, dict) DCNL True DCNL >>> optimizer = sgd(learning_rate=.01) DCNL >>> callable(optimizer) DCNL True DCNL >>> updates = optimizer(b, [a]) DCNL >>> isinstance(updates, dict) DCNL True'
def apply_momentum(updates, params=None, momentum=0.9): DCNL 'Returns a modified update dictionary including momentum DCNL Generates update expressions of the form: DCNL * ``velocity := momentum * velocity + updates[param] - param`` DCNL * ``param := param + velocity`` DCNL Parameters DCNL updates : OrderedDict DCNL A dictionary mapping parameters to update expressions DCNL params : iterable of shared variables, optional DCNL The variables to apply momentum to. If omitted, will apply DCNL momentum to all `updates.keys()`. DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more update steps. Defaults to 0.9. DCNL Returns DCNL OrderedDict DCNL A copy of `updates` with momentum updates for all `params`. DCNL Notes DCNL Higher momentum also results in larger update steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL See Also DCNL momentum : Shortcut applying momentum to SGD updates'
def momentum(loss_or_grads=None, params=None, learning_rate=0.001, momentum=0.9): DCNL 'Stochastic Gradient Descent (SGD) updates with momentum DCNL Generates update expressions of the form: DCNL * ``velocity := momentum * velocity - learning_rate * gradient`` DCNL * ``param := param + velocity`` DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more update steps. Defaults to 0.9. DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL Higher momentum also results in larger update steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL Optimizer can be called without both loss_or_grads and params DCNL in that case partial function is returned DCNL See Also DCNL apply_momentum : Generic function applying momentum to updates DCNL nesterov_momentum : Nesterov\'s variant of SGD with momentum DCNL Examples DCNL >>> a = theano.shared(1.) DCNL >>> b = a*2 DCNL >>> updates = momentum(b, [a], learning_rate=.01) DCNL >>> isinstance(updates, dict) DCNL True DCNL >>> optimizer = momentum(learning_rate=.01) DCNL >>> callable(optimizer) DCNL True DCNL >>> updates = optimizer(b, [a]) DCNL >>> isinstance(updates, dict) DCNL True'
def apply_nesterov_momentum(updates, params=None, momentum=0.9): DCNL 'Returns a modified update dictionary including Nesterov momentum DCNL Generates update expressions of the form: DCNL * ``velocity := momentum * velocity + updates[param] - param`` DCNL * ``param := param + momentum * velocity + updates[param] - param`` DCNL Parameters DCNL updates : OrderedDict DCNL A dictionary mapping parameters to update expressions DCNL params : iterable of shared variables, optional DCNL The variables to apply momentum to. If omitted, will apply DCNL momentum to all `updates.keys()`. DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more update steps. Defaults to 0.9. DCNL Returns DCNL OrderedDict DCNL A copy of `updates` with momentum updates for all `params`. DCNL Notes DCNL Higher momentum also results in larger update steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL The classic formulation of Nesterov momentum (or Nesterov accelerated DCNL gradient) requires the gradient to be evaluated at the predicted next DCNL position in parameter space. Here, we use the formulation described at DCNL https://github.com/lisa-lab/pylearn2/pull/136#issuecomment-10381617, DCNL which allows the gradient to be evaluated at the current parameters. DCNL See Also DCNL nesterov_momentum : Shortcut applying Nesterov momentum to SGD updates'
def nesterov_momentum(loss_or_grads=None, params=None, learning_rate=0.001, momentum=0.9): DCNL 'Stochastic Gradient Descent (SGD) updates with Nesterov momentum DCNL Generates update expressions of the form: DCNL * ``velocity := momentum * velocity - learning_rate * gradient`` DCNL * ``param := param + momentum * velocity - learning_rate * gradient`` DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more update steps. Defaults to 0.9. DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL Higher momentum also results in larger update steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL The classic formulation of Nesterov momentum (or Nesterov accelerated DCNL gradient) requires the gradient to be evaluated at the predicted next DCNL position in parameter space. Here, we use the formulation described at DCNL https://github.com/lisa-lab/pylearn2/pull/136#issuecomment-10381617, DCNL which allows the gradient to be evaluated at the current parameters. DCNL Optimizer can be called without both loss_or_grads and params DCNL in that case partial function is returned DCNL See Also DCNL apply_nesterov_momentum : Function applying momentum to updates DCNL Examples DCNL >>> a = theano.shared(1.) DCNL >>> b = a*2 DCNL >>> updates = nesterov_momentum(b, [a], learning_rate=.01) DCNL >>> isinstance(updates, dict) DCNL True DCNL >>> optimizer = nesterov_momentum(learning_rate=.01) DCNL >>> callable(optimizer) DCNL True DCNL >>> updates = optimizer(b, [a]) DCNL >>> isinstance(updates, dict) DCNL True'
def adagrad(loss_or_grads=None, params=None, learning_rate=1.0, epsilon=1e-06): DCNL 'Adagrad updates DCNL Scale learning rates by dividing with the square root of accumulated DCNL squared gradients. See [1]_ for further description. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL epsilon : float or symbolic scalar DCNL Small value added for numerical stability DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL Using step size eta Adagrad calculates the learning rate for feature i at DCNL time step t as: DCNL .. math:: \eta_{t,i} = \frac{\eta} DCNL {\sqrt{\sum^t_{t^\prime} g^2_{t^\prime,i}+\epsilon}} g_{t,i} DCNL as such the learning rate is monotonically decreasing. DCNL Epsilon is not included in the typical formula, see [2]_. DCNL Optimizer can be called without both loss_or_grads and params DCNL in that case partial function is returned DCNL References DCNL .. [1] Duchi, J., Hazan, E., & Singer, Y. (2011): DCNL Adaptive subgradient methods for online learning and stochastic DCNL optimization. JMLR, 12:2121-2159. DCNL .. [2] Chris Dyer: DCNL Notes on AdaGrad. http://www.ark.cs.cmu.edu/cdyer/adagrad.pdf DCNL Examples DCNL >>> a = theano.shared(1.) DCNL >>> b = a*2 DCNL >>> updates = adagrad(b, [a], learning_rate=.01) DCNL >>> isinstance(updates, dict) DCNL True DCNL >>> optimizer = adagrad(learning_rate=.01) DCNL >>> callable(optimizer) DCNL True DCNL >>> updates = optimizer(b, [a]) DCNL >>> isinstance(updates, dict) DCNL True'
def adagrad_window(loss_or_grads=None, params=None, learning_rate=0.001, epsilon=0.1, n_win=10): DCNL 'Returns a function that returns parameter updates. DCNL Instead of accumulated estimate, uses running window DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float DCNL Learning rate. DCNL epsilon : float DCNL Offset to avoid zero-division in the normalizer of adagrad. DCNL n_win : int DCNL Number of past steps to calculate scales of parameter gradients. DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression'
def rmsprop(loss_or_grads=None, params=None, learning_rate=1.0, rho=0.9, epsilon=1e-06): DCNL 'RMSProp updates DCNL Scale learning rates by dividing with the moving average of the root mean DCNL squared (RMS) gradients. See [1]_ for further description. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL rho : float or symbolic scalar DCNL Gradient moving average decay factor DCNL epsilon : float or symbolic scalar DCNL Small value added for numerical stability DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL `rho` should be between 0 and 1. A value of `rho` close to 1 will decay the DCNL moving average slowly and a value close to 0 will decay the moving average DCNL fast. DCNL Using the step size :math:`\eta` and a decay factor :math:`\rho` the DCNL learning rate :math:`\eta_t` is calculated as: DCNL .. math:: DCNL r_t &= \rho r_{t-1} + (1-\rho)*g^2\\ DCNL \eta_t &= \frac{\eta}{\sqrt{r_t + \epsilon}} DCNL Optimizer can be called without both loss_or_grads and params DCNL in that case partial function is returned DCNL References DCNL .. [1] Tieleman, tt. and Hinton, G. (2012): DCNL Neural Networks for Machine Learning, Lecture 6.5 - rmsprop. DCNL Coursera. http://www.youtube.com/watch?v=O3sxAc4hxZU (formula @5:20) DCNL Examples DCNL >>> a = theano.shared(1.) DCNL >>> b = a*2 DCNL >>> updates = rmsprop(b, [a], learning_rate=.01) DCNL >>> isinstance(updates, dict) DCNL True DCNL >>> optimizer = rmsprop(learning_rate=.01) DCNL >>> callable(optimizer) DCNL True DCNL >>> updates = optimizer(b, [a]) DCNL >>> isinstance(updates, dict) DCNL True'
def adadelta(loss_or_grads=None, params=None, learning_rate=1.0, rho=0.95, epsilon=1e-06): DCNL 'Adadelta updates DCNL Scale learning rates by the ratio of accumulated gradients to accumulated DCNL updates, see [1]_ and notes for further description. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL rho : float or symbolic scalar DCNL Squared gradient moving average decay factor DCNL epsilon : float or symbolic scalar DCNL Small value added for numerical stability DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL rho should be between 0 and 1. A value of rho close to 1 will decay the DCNL moving average slowly and a value close to 0 will decay the moving average DCNL fast. DCNL rho = 0.95 and epsilon=1e-6 are suggested in the paper and reported to DCNL work for multiple datasets (MNIST, speech). DCNL In the paper, no learning rate is considered (so learning_rate=1.0). DCNL Probably best to keep it at this value. DCNL epsilon is important for the very first update (so the numerator does DCNL not become 0). DCNL Using the step size eta and a decay factor rho the learning rate is DCNL calculated as: DCNL .. math:: DCNL r_t &= \rho r_{t-1} + (1-\rho)*g^2\\ DCNL \eta_t &= \eta \frac{\sqrt{s_{t-1} + \epsilon}} DCNL {\sqrt{r_t + \epsilon}}\\ DCNL s_t &= \rho s_{t-1} + (1-\rho)*(\eta_t*g)^2 DCNL Optimizer can be called without both loss_or_grads and params DCNL in that case partial function is returned DCNL References DCNL .. [1] Zeiler, M. D. (2012): DCNL ADADELTA: An Adaptive Learning Rate Method. DCNL arXiv Preprint arXiv:1212.5701. DCNL Examples DCNL >>> a = theano.shared(1.) DCNL >>> b = a*2 DCNL >>> updates = adadelta(b, [a], learning_rate=.01) DCNL >>> isinstance(updates, dict) DCNL True DCNL >>> optimizer = adadelta(learning_rate=.01) DCNL >>> callable(optimizer) DCNL True DCNL >>> updates = optimizer(b, [a]) DCNL >>> isinstance(updates, dict) DCNL True'
def adam(loss_or_grads=None, params=None, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08): DCNL 'Adam updates DCNL Adam updates implemented as in [1]_. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float DCNL Learning rate DCNL beta1 : float DCNL Exponential decay rate for the first moment estimates. DCNL beta2 : float DCNL Exponential decay rate for the second moment estimates. DCNL epsilon : float DCNL Constant for numerical stability. DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL The paper [1]_ includes an additional hyperparameter lambda. This is only DCNL needed to prove convergence of the algorithm and has no practical use DCNL (personal communication with the authors), it is therefore omitted here. DCNL Optimizer can be called without both loss_or_grads and params DCNL in that case partial function is returned DCNL References DCNL .. [1] Kingma, Diederik, and Jimmy Ba (2014): DCNL Adam: A Method for Stochastic Optimization. DCNL arXiv preprint arXiv:1412.6980. DCNL Examples DCNL >>> a = theano.shared(1.) DCNL >>> b = a*2 DCNL >>> updates = adam(b, [a], learning_rate=.01) DCNL >>> isinstance(updates, dict) DCNL True DCNL >>> optimizer = adam(learning_rate=.01) DCNL >>> callable(optimizer) DCNL True DCNL >>> updates = optimizer(b, [a]) DCNL >>> isinstance(updates, dict) DCNL True'
def adamax(loss_or_grads=None, params=None, learning_rate=0.002, beta1=0.9, beta2=0.999, epsilon=1e-08): DCNL 'Adamax updates DCNL Adamax updates implemented as in [1]_. This is a variant of of the Adam DCNL algorithm based on the infinity norm. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float DCNL Learning rate DCNL beta1 : float DCNL Exponential decay rate for the first moment estimates. DCNL beta2 : float DCNL Exponential decay rate for the weighted infinity norm estimates. DCNL epsilon : float DCNL Constant for numerical stability. DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL Optimizer can be called without both loss_or_grads and params DCNL in that case partial function is returned DCNL References DCNL .. [1] Kingma, Diederik, and Jimmy Ba (2014): DCNL Adam: A Method for Stochastic Optimization. DCNL arXiv preprint arXiv:1412.6980. DCNL Examples DCNL >>> a = theano.shared(1.) DCNL >>> b = a*2 DCNL >>> updates = adamax(b, [a], learning_rate=.01) DCNL >>> isinstance(updates, dict) DCNL True DCNL >>> optimizer = adamax(learning_rate=.01) DCNL >>> callable(optimizer) DCNL True DCNL >>> updates = optimizer(b, [a]) DCNL >>> isinstance(updates, dict) DCNL True'
def norm_constraint(tensor_var, max_norm, norm_axes=None, epsilon=1e-07): DCNL 'Max weight norm constraints and gradient clipping DCNL This takes a TensorVariable and rescales it so that incoming weight DCNL norms are below a specified constraint value. Vectors violating the DCNL constraint are rescaled so that they are within the allowed range. DCNL Parameters DCNL tensor_var : TensorVariable DCNL Theano expression for update, gradient, or other quantity. DCNL max_norm : scalar DCNL This value sets the maximum allowed value of any norm in DCNL `tensor_var`. DCNL norm_axes : sequence (list or tuple) DCNL The axes over which to compute the norm.  This overrides the DCNL default norm axes defined for the number of dimensions DCNL in `tensor_var`. When this is not specified and `tensor_var` is a DCNL matrix (2D), this is set to `(0,)`. If `tensor_var` is a 3D, 4D or DCNL 5D tensor, it is set to a tuple listing all axes but axis 0. The DCNL former default is useful for working with dense layers, the latter DCNL is useful for 1D, 2D and 3D convolutional layers. DCNL (Optional) DCNL epsilon : scalar, optional DCNL Value used to prevent numerical instability when dividing by DCNL very small or zero norms. DCNL Returns DCNL TensorVariable DCNL Input `tensor_var` with rescaling applied to weight vectors DCNL that violate the specified constraints. DCNL Examples DCNL >>> param = theano.shared( DCNL ...     np.random.randn(100, 200).astype(theano.config.floatX)) DCNL >>> update = param + 100 DCNL >>> update = norm_constraint(update, 10) DCNL >>> func = theano.function([], [], updates=[(param, update)]) DCNL >>> # Apply constrained update DCNL >>> _ = func() DCNL >>> from lasagne.utils import compute_norms DCNL >>> norms = compute_norms(param.get_value()) DCNL >>> np.isclose(np.max(norms), 10) DCNL True DCNL Notes DCNL When `norm_axes` is not specified, the axes over which the norm is DCNL computed depend on the dimensionality of the input variable. If it is DCNL 2D, it is assumed to come from a dense layer, and the norm is computed DCNL over axis 0. If it is 3D, 4D or 5D, it is assumed to come from a DCNL convolutional layer and the norm is computed over all trailing axes DCNL beyond axis 0. For other uses, you should explicitly specify the axes DCNL over which to compute the norm using `norm_axes`.'
def total_norm_constraint(tensor_vars, max_norm, epsilon=1e-07, return_norm=False): DCNL 'Rescales a list of tensors based on their combined norm DCNL If the combined norm of the input tensors exceeds the threshold then all DCNL tensors are rescaled such that the combined norm is equal to the threshold. DCNL Scaling the norms of the gradients is often used when training recurrent DCNL neural networks [1]_. DCNL Parameters DCNL tensor_vars : List of TensorVariables. DCNL Tensors to be rescaled. DCNL max_norm : float DCNL Threshold value for total norm. DCNL epsilon : scalar, optional DCNL Value used to prevent numerical instability when dividing by DCNL very small or zero norms. DCNL return_norm : bool DCNL If true the total norm is also returned. DCNL Returns DCNL tensor_vars_scaled : list of TensorVariables DCNL The scaled tensor variables. DCNL norm : Theano scalar DCNL The combined norms of the input variables prior to rescaling, DCNL only returned if ``return_norms=True``. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> import lasagne DCNL >>> from lasagne.updates import sgd, total_norm_constraint DCNL >>> x = tt.matrix() DCNL >>> y = tt.ivector() DCNL >>> l_in = InputLayer((5, 10)) DCNL >>> l1 = DenseLayer(l_in, num_units=7, nonlinearity=tt.nnet.softmax) DCNL >>> output = lasagne.layers.get_output(l1, x) DCNL >>> cost = tt.mean(tt.nnet.categorical_crossentropy(output, y)) DCNL >>> all_params = lasagne.layers.get_all_params(l1) DCNL >>> all_grads = tt.grad(cost, all_params) DCNL >>> scaled_grads = total_norm_constraint(all_grads, 5) DCNL >>> updates = sgd(scaled_grads, all_params, learning_rate=0.1) DCNL Notes DCNL The total norm can be used to monitor training. DCNL References DCNL .. [1] Sutskever, I., Vinyals, O., & Le, Q. V. (2014): Sequence to sequence DCNL learning with neural networks. In Advances in Neural Information DCNL Processing Systems (pp. 3104-3112).'
@statfunc DCNL def geweke(x, first=0.1, last=0.5, intervals=20): DCNL 'Return z-scores for convergence diagnostics. DCNL Compare the mean of the first % of series with the mean of the last % of DCNL series. x is divided into a number of segments for which this difference is DCNL computed. If the series is converged, this score should oscillate between DCNL -1 and 1. DCNL Parameters DCNL x : array-like DCNL The trace of some stochastic parameter. DCNL first : float DCNL The fraction of series at the beginning of the trace. DCNL last : float DCNL The fraction of series at the end to be compared with the section DCNL at the beginning. DCNL intervals : int DCNL The number of segments. DCNL Returns DCNL scores : list [[]] DCNL Return a list of [i, score], where i is the starting index for each DCNL interval and score the Geweke score on the interval. DCNL Notes DCNL The Geweke score on some series x is computed by: DCNL .. math:: \frac{E[x_s] - E[x_e]}{\sqrt{V[x_s] + V[x_e]}} DCNL where :math:`E` stands for the mean, :math:`V` the variance, DCNL :math:`x_s` a section at the start of the series and DCNL :math:`x_e` a section at the end of the series. DCNL References DCNL Geweke (1992)'
def gelman_rubin(mtrace): DCNL 'Returns estimate of R for a set of traces. DCNL The Gelman-Rubin diagnostic tests for lack of convergence by comparing DCNL the variance between multiple chains to the variance within each chain. DCNL If convergence has been achieved, the between-chain and within-chain DCNL variances should be identical. To be most effective in detecting evidence DCNL for nonconvergence, each chain should have been initialized to starting DCNL values that are dispersed relative to the target distribution. DCNL Parameters DCNL mtrace : MultiTrace DCNL A MultiTrace object containing parallel traces (minimum 2) DCNL of one or more stochastic parameters. DCNL Returns DCNL Rhat : dict DCNL Returns dictionary of the potential scale reduction DCNL factors, :math:`\hat{R}` DCNL Notes DCNL The diagnostic is computed by: DCNL .. math:: \hat{R} = \frac{\hat{V}}{W} DCNL where :math:`W` is the within-chain variance and :math:`\hat{V}` is DCNL the posterior variance estimate for the pooled traces. This is the DCNL potential scale reduction factor, which converges to unity when each DCNL of the traces is a sample from the target posterior. Values greater DCNL than one indicate that one or more chains have not yet converged. DCNL References DCNL Brooks and Gelman (1998) DCNL Gelman and Rubin (1992)'
def effective_n(mtrace): DCNL 'Returns estimate of the effective sample size of a set of traces. DCNL Parameters DCNL mtrace : MultiTrace DCNL A MultiTrace object containing parallel traces (minimum 2) DCNL of one or more stochastic parameters. DCNL Returns DCNL n_eff : float DCNL Return the effective sample size, :math:`\hat{n}_{eff}` DCNL Notes DCNL The diagnostic is computed by: DCNL .. math:: \hat{n}_{eff} = \frac{mn}{1 + 2 \sum_{t=1}^T \hat{\rho}_t} DCNL where :math:`\hat{\rho}_t` is the estimated autocorrelation at lag t, and T DCNL is the first odd positive integer for which the sum DCNL :math:`\hat{\rho}_{T+1} + \hat{\rho}_{T+1}` is negative. DCNL References DCNL Gelman et al. (2014)'
def incorporate_methods(source, destination, methods, default=None, wrapper=None, override=False): DCNL 'Add attributes to a destination object which points to DCNL methods from from a source object. DCNL Parameters DCNL source : object DCNL The source object containing the methods. DCNL destination : object DCNL The destination object for the methods. DCNL methods : list of str DCNL Names of methods to incorporate. DCNL default : object DCNL The value used if the source does not have one of the listed methods. DCNL wrapper : function DCNL An optional function to allow the source method to be DCNL wrapped. Should take the form my_wrapper(source, method_name) DCNL and return a single value. DCNL override : bool DCNL If the destination object already has a method/attribute DCNL an AttributeError will be raised if override is False (the default).'
def get_named_nodes(graph): DCNL 'Get the named nodes in a theano graph DCNL (i.e., nodes whose name attribute is not None). DCNL Parameters DCNL graph - a theano node DCNL Returns: DCNL A dictionary of name:node pairs.'
def modelcontext(model): DCNL 'return the given model or try to find it in the context if there was DCNL none supplied.'
def withparent(meth): DCNL 'Helper wrapper that passes calls to parent\'s instance'
def fn(outs, mode=None, model=None, *args, **kwargs): DCNL 'Compiles a Theano function which returns the values of `outs` and DCNL takes values of model vars as arguments. DCNL Parameters DCNL outs : Theano variable or iterable of Theano variables DCNL mode : Theano compilation mode DCNL Returns DCNL Compiled Theano function'
def fastfn(outs, mode=None, model=None): DCNL 'Compiles a Theano function which returns `outs` and takes values of model DCNL vars as a dict as an argument. DCNL Parameters DCNL outs : Theano variable or iterable of Theano variables DCNL mode : Theano compilation mode DCNL Returns DCNL Compiled Theano function as point function.'
def Point(*args, **kwargs): DCNL 'Build a point. Uses same args as dict() does. DCNL Filters out variables not in the model. All keys are strings. DCNL Parameters DCNL *args, **kwargs DCNL arguments to build a dict'
def _get_scaling(total_size, shape, ndim): DCNL 'Gets scaling constant for logp DCNL Parameters DCNL total_size : int or list[int] DCNL shape : shape DCNL shape to scale DCNL ndim : int DCNL ndim hint DCNL Returns DCNL scalar'
def _walk_up_rv(rv): DCNL 'Walk up theano graph to get inputs for deterministic RV.'
def _latex_repr_rv(rv): DCNL 'Make latex string for a Deterministic variable'
def Deterministic(name, var, model=None): DCNL 'Create a named deterministic variable DCNL Parameters DCNL name : str DCNL var : theano variables DCNL Returns DCNL var : var, with name attribute'
def Potential(name, var, model=None): DCNL 'Add an arbitrary factor potential to the model likelihood DCNL Parameters DCNL name : str DCNL var : theano variables DCNL Returns DCNL var : var, with name attribute'
def all_continuous(vars): DCNL 'Check that vars not include discrete variables, excepting ObservedRVs.'
def sample_gp(trace, gp, X_values, samples=None, obs_noise=True, model=None, random_seed=None, progressbar=True, chol_const=True): DCNL 'Generate samples from a posterior Gaussian process. DCNL Parameters DCNL trace : backend, list, or MultiTrace DCNL Trace generated from MCMC sampling. DCNL gp : Gaussian process object DCNL The GP variable to sample from. DCNL X_values : array DCNL Grid of values at which to sample GP. DCNL samples : int DCNL Number of posterior predictive samples to generate. Defaults to the DCNL length of `trace` DCNL obs_noise : bool DCNL Flag for including observation noise in sample. Defaults to True. DCNL model : Model DCNL Model used to generate `trace`. Optional if in `with` context manager. DCNL random_seed : integer > 0 DCNL Random number seed for sampling. DCNL progressbar : bool DCNL Flag for showing progress bar. DCNL chol_const : bool DCNL Flag to a small diagonal to the posterior covariance DCNL for numerical stability DCNL Returns DCNL Array of samples from posterior GP evaluated at Z.'
def any_to_tensor_and_labels(x, labels=None): DCNL 'Util for converting input x to tensor trying to DCNL create labels for columns if they are not provided. DCNL Default names for columns are [\'x0\', \'x1\', ...], for mappable DCNL arrays (e.g. pd.DataFrame) their names are treated as labels. DCNL You can override them with `labels` argument. DCNL If you have tensor input you should provide labels as we DCNL cannot get their shape directly DCNL If you pass dict input we cannot rely on labels order thus dict DCNL keys are treated as labels anyway DCNL Parameters DCNL x : np.ndarray | pd.DataFrame | tt.Variable | dict | list DCNL labels : list - names for columns of output tensor DCNL Returns DCNL (x, labels) - tensor and labels for its columns'
def identity_transform(x): DCNL 'f(x) = x'
def get_axis(ax, default_rows, default_columns, **default_kwargs): DCNL 'Verifies the provided axis is of the correct shape, and creates one if needed. DCNL Args: DCNL ax: matplotlib axis or None DCNL default_rows: int, expected rows in axis DCNL default_columns: int, expected columns in axis DCNL **default_kwargs: keyword arguments to pass to plt.subplot DCNL Returns: DCNL axis, or raises an error'
def make_2d(a): DCNL 'Ravel the dimensions after the first.'
def _var_str(name, shape): DCNL 'Return a sequence of strings naming the element of the tallyable object. DCNL :Example: DCNL >>> _var_str(\'theta\', (4,)) DCNL [\'theta[1]\', \'theta[2]\', \'theta[3]\', \'theta[4]\']'
def _make_rhat_plot(trace, ax, title, labels, varnames, include_transformed): DCNL 'Helper to plot rhat for multiple chains. DCNL Parameters DCNL trace: pymc3 trace DCNL ax: Matplotlib.Axes DCNL title: str DCNL labels: iterable DCNL Same length as the number of chains DCNL include_transformed: bool DCNL Whether to include the transformed variables DCNL Returns DCNL Matplotlib.Axes with a single error bar added'
def _plot_tree(ax, y, ntiles, show_quartiles, **plot_kwargs): DCNL 'Helper to plot errorbars for the forestplot. DCNL Parameters DCNL ax: Matplotlib.Axes DCNL y: float DCNL y value to add error bar to DCNL ntiles: iterable DCNL A list or array of length 5 or 3 DCNL show_quartiles: boolean DCNL Whether to plot the interquartile range DCNL Returns DCNL Matplotlib.Axes with a single error bar added'
def forestplot(trace_obj, varnames=None, transform=identity_transform, alpha=0.05, quartiles=True, rhat=True, main=None, xtitle=None, xlim=None, ylabels=None, chain_spacing=0.05, vline=0, gs=None, plot_transformed=False, **plot_kwargs): DCNL 'Forest plot (model summary plot). DCNL Generates a "forest plot" of 100*(1-alpha)% credible intervals for either DCNL the set of variables in a given model, or a specified set of nodes. DCNL Parameters DCNL trace_obj: NpTrace or MultiTrace object DCNL Trace(s) from an MCMC sample. DCNL varnames: list DCNL List of variables to plot (defaults to None, which results in all DCNL variables plotted). DCNL transform : callable DCNL Function to transform data (defaults to identity) DCNL alpha (optional): float DCNL Alpha value for (1-alpha)*100% credible intervals (defaults to 0.05). DCNL quartiles (optional): bool DCNL Flag for plotting the interquartile range, in addition to the DCNL (1-alpha)*100% intervals (defaults to True). DCNL rhat (optional): bool DCNL Flag for plotting Gelman-Rubin statistics. Requires 2 or more chains DCNL (defaults to True). DCNL main (optional): string DCNL Title for main plot. Passing False results in titles being suppressed; DCNL passing None (default) results in default titles. DCNL xtitle (optional): string DCNL Label for x-axis. Defaults to no label DCNL xlim (optional): list or tuple DCNL Range for x-axis. Defaults to matplotlib\'s best guess. DCNL ylabels (optional): list or array DCNL User-defined labels for each variable. If not provided, the node DCNL __name__ attributes are used. DCNL chain_spacing (optional): float DCNL Plot spacing between chains (defaults to 0.05). DCNL vline (optional): numeric DCNL Location of vertical reference line (defaults to 0). DCNL gs : GridSpec DCNL Matplotlib GridSpec object. Defaults to None. DCNL plot_transformed : bool DCNL Flag for plotting automatically transformed variables in addition to DCNL original variables (defaults to False). DCNL plot_kwargs : dict DCNL Optional arguments for plot elements. Currently accepts \'fontsize\', DCNL \'linewidth\', \'color\', \'marker\', and \'markersize\'. DCNL Returns DCNL gs : matplotlib GridSpec'
def compareplot(comp_df, ax=None): DCNL 'Model comparison summary plot in the style of the one used in the book DCNL Statistical Rethinking by Richard McElreath. DCNL Parameters DCNL comp_df: DataFrame DCNL The result of the pm.compare() function DCNL ax : axes DCNL Matplotlib axes. Defaults to None. DCNL Returns DCNL ax : matplotlib axes'
def _histplot_bins(column, bins=100): DCNL 'Helper to get bins for histplot.'
def histplot_op(ax, data, alpha=0.35): DCNL 'Add a histogram for each column of the data to the provided axes.'
def kdeplot_op(ax, data, prior=None, prior_alpha=1, prior_style='--'): DCNL 'Get a list of density and likelihood plots, if a prior is provided.'
def plot_posterior_op(trace_values, ax, kde_plot, point_estimate, round_to, alpha_level, ref_val, rope, text_size=16, **kwargs): DCNL 'Artist to draw posterior.'
def fast_kde(x): DCNL 'A fft-based Gaussian kernel density estimate (KDE) for computing DCNL the KDE on a regular grid. DCNL The code was adapted from https://github.com/mfouesneau/faststats DCNL Parameters DCNL x : Numpy array or list DCNL Returns DCNL grid: A gridded 1D KDE of the input points (x). DCNL xmin: minimum value of x DCNL xmax: maximum value of x'
def plot_posterior(trace, varnames=None, transform=identity_transform, figsize=None, text_size=16, alpha_level=0.05, round_to=3, point_estimate='mean', rope=None, ref_val=None, kde_plot=False, plot_transformed=False, ax=None, **kwargs): DCNL 'Plot Posterior densities in style of John K. Kruschke book. DCNL Parameters DCNL trace : result of MCMC run DCNL varnames : list of variable names DCNL Variables to be plotted, if None all variable are plotted DCNL transform : callable DCNL Function to transform data (defaults to identity) DCNL figsize : figure size tuple DCNL If None, size is (12, num of variables * 2) inch DCNL text_size : int DCNL Text size of the point_estimates, axis ticks, and HPD (Default:16) DCNL alpha_level : float DCNL Defines range for High Posterior Density DCNL round_to : int DCNL Controls formatting for floating point numbers DCNL point_estimate: str DCNL Must be in (\'mode\', \'mean\', \'median\') DCNL rope: list or numpy array DCNL Lower and upper values of the Region Of Practical Equivalence DCNL ref_val: float or list-like DCNL display the percentage below and above the values in ref_val. DCNL If a list is provided, its length should match the number of variables. DCNL kde_plot: bool DCNL if True plot a KDE instead of a histogram. For discrete variables this DCNL argument is ignored. DCNL plot_transformed : bool DCNL Flag for plotting automatically transformed variables in addition to DCNL original variables (defaults to False). DCNL ax : axes DCNL Matplotlib axes. Defaults to None. DCNL **kwargs DCNL Passed as-is to plt.hist() or plt.plot() function, depending on the DCNL value of the argument kde_plot DCNL Some defaults are added, if not specified DCNL color=\'#87ceeb\' will match the style in the book DCNL Returns DCNL ax : matplotlib axes'
def plot_posterior_predictive_glm(trace, eval=None, lm=None, samples=30, **kwargs): DCNL 'Plot posterior predictive of a linear model. DCNL :Arguments: DCNL trace : <array> DCNL Array of posterior samples with columns DCNL eval : <array> DCNL Array over which to evaluate lm DCNL lm : function <default: linear function> DCNL Function mapping parameters at different points DCNL to their respective outputs. DCNL input: point, sample DCNL output: estimated value DCNL samples : int <default=30> DCNL How many posterior samples to draw. DCNL Additional keyword arguments are passed to pylab.plot().'
def traceplot(trace, varnames=None, transform=identity_transform, figsize=None, lines=None, combined=False, plot_transformed=False, grid=False, alpha=0.35, priors=None, prior_alpha=1, prior_style='--', ax=None, live_plot=False, skip_first=0, refresh_every=100, roll_over=1000): DCNL 'Plot samples histograms and values. DCNL Parameters DCNL trace : result of MCMC run DCNL varnames : list of variable names DCNL Variables to be plotted, if None all variable are plotted DCNL transform : callable DCNL Function to transform data (defaults to identity) DCNL figsize : figure size tuple DCNL If None, size is (12, num of variables * 2) inch DCNL lines : dict DCNL Dictionary of variable name / value  to be overplotted as vertical DCNL lines to the posteriors and horizontal lines on sample values DCNL e.g. mean of posteriors, true values of a simulation. DCNL If an array of values, line colors are matched to posterior colors. DCNL Otherwise, a default red line DCNL combined : bool DCNL Flag for combining multiple chains into a single chain. If False DCNL (default), chains will be plotted separately. DCNL plot_transformed : bool DCNL Flag for plotting automatically transformed variables in addition to DCNL original variables (defaults to False). DCNL grid : bool DCNL Flag for adding gridlines to histogram. Defaults to True. DCNL alpha : float DCNL Alpha value for plot line. Defaults to 0.35. DCNL priors : iterable of PyMC distributions DCNL PyMC prior distribution(s) to be plotted alongside posterior. Defaults DCNL to None (no prior plots). DCNL prior_alpha : float DCNL Alpha value for prior plot. Defaults to 1. DCNL prior_style : str DCNL Line style for prior plot. Defaults to \'--\' (dashed line). DCNL ax : axes DCNL Matplotlib axes. Accepts an array of axes, e.g.: DCNL live_plot: bool DCNL Flag for updating the current figure while sampling DCNL skip_first : int DCNL Number of first samples not shown in plots (burn-in). This affects DCNL frequency and stream plots. DCNL refresh_every : int DCNL Period of plot updates (in sample number) DCNL roll_over : int DCNL Width of the sliding window for the sample stream plots: last roll_over DCNL samples are shown (no effect on frequency plots). DCNL >>> fig, axs = plt.subplots(3, 2) # 3 RVs DCNL >>> pymc3.traceplot(trace, ax=axs) DCNL Creates own axes by default. DCNL Returns DCNL ax : matplotlib axes'
def autocorrplot(trace, varnames=None, max_lag=100, burn=0, plot_transformed=False, symmetric_plot=False, ax=None, figsize=None): DCNL 'Bar plot of the autocorrelation function for a trace. DCNL Parameters DCNL trace : result of MCMC run DCNL varnames : list of variable names DCNL Variables to be plotted, if None all variable are plotted. DCNL Vector-value stochastics are handled automatically. DCNL max_lag : int DCNL Maximum lag to calculate autocorrelation. Defaults to 100. DCNL burn : int DCNL Number of samples to discard from the beginning of the trace. DCNL Defaults to 0. DCNL plot_transformed : bool DCNL Flag for plotting automatically transformed variables in addition to DCNL original variables (defaults to False). DCNL symmetric_plot : boolean DCNL Plot from either [0, +lag] or [-lag, lag]. Defaults to False, [-, +lag]. DCNL ax : axes DCNL Matplotlib axes. Defaults to None. DCNL figsize : figure size tuple DCNL If None, size is (12, num of variables * 2) inches. DCNL Note this is not used if ax is supplied. DCNL Returns DCNL ax : matplotlib axes'
def energyplot(trace, kind='kde', figsize=None, ax=None, legend=True, lw=0, alpha=0.35, frame=True, **kwargs): DCNL 'Plot energy transition distribution and marginal energy distribution in order DCNL to diagnose poor exploration by HMC algorithms. DCNL Parameters DCNL trace : result of MCMC run DCNL kind : str DCNL Type of plot to display (kde or histogram) DCNL figsize : figure size tuple DCNL If None, size is (8 x 6) DCNL ax : axes DCNL Matplotlib axes. DCNL legend : bool DCNL Flag for plotting legend (defaults to True) DCNL lw : int DCNL Line width DCNL alpha : float DCNL Alpha value for plot line. Defaults to 0.35. DCNL frame : bool DCNL Flag for plotting frame around figure. DCNL Returns DCNL ax : matplotlib axes'
def statfunc(f): DCNL 'Decorator for statistical utility function to automatically DCNL extract the trace array from whatever object is passed.'
@statfunc DCNL def autocorr(x, lag=1): DCNL 'Sample autocorrelation at specified lag. DCNL Parameters DCNL x : Numpy array DCNL An array containing MCMC samples DCNL lag : int DCNL The desidered lag to take in consideration'
@statfunc DCNL def autocov(x, lag=1): DCNL 'Sample autocovariance at specified lag. DCNL Parameters DCNL x : Numpy array DCNL An array containing MCMC samples DCNL lag : int DCNL The desidered lag to take in consideration DCNL Returns DCNL 2x2 matrix with the variances of DCNL x[:-lag] and x[lag:] in the diagonal and the autocovariance DCNL on the off-diagonal.'
def dic(trace, model=None): DCNL 'Calculate the deviance information criterion of the samples in trace from model DCNL Read more theory here - in a paper by some of the leading authorities on Model Selection - DCNL dx.doi.org/10.1111/1467-9868.00353 DCNL Parameters DCNL trace : result of MCMC run DCNL model : PyMC Model DCNL Optional model. Default None, taken from context. DCNL Returns DCNL `float` representing the deviance information criterion of the model and trace'
def _log_post_trace(trace, model, progressbar=False): DCNL 'Calculate the elementwise log-posterior for the sampled trace. DCNL Parameters DCNL trace : result of MCMC run DCNL model : PyMC Model DCNL Optional model. Default None, taken from context. DCNL progressbar: bool DCNL Whether or not to display a progress bar in the command line. The DCNL bar shows the percentage of completion, the evaluation speed, and DCNL the estimated time to completion DCNL Returns DCNL logp : array of shape (n_samples, n_observations) DCNL The contribution of the observations to the logp of the whole model.'
def waic(trace, model=None, pointwise=False, progressbar=False): DCNL 'Calculate the widely available information criterion, its standard error DCNL and the effective number of parameters of the samples in trace from model. DCNL Read more theory here - in a paper by some of the leading authorities on DCNL Model Selection - dx.doi.org/10.1111/1467-9868.00353 DCNL Parameters DCNL trace : result of MCMC run DCNL model : PyMC Model DCNL Optional model. Default None, taken from context. DCNL pointwise: bool DCNL if True the pointwise predictive accuracy will be returned. DCNL Default False DCNL progressbar: bool DCNL Whether or not to display a progress bar in the command line. The DCNL bar shows the percentage of completion, the evaluation speed, and DCNL the estimated time to completion DCNL Returns DCNL namedtuple with the following elements: DCNL waic: widely available information criterion DCNL waic_se: standard error of waic DCNL p_waic: effective number parameters DCNL waic_i: and array of the pointwise predictive accuracy, only if pointwise True'
def loo(trace, model=None, pointwise=False, progressbar=False): DCNL 'Calculates leave-one-out (LOO) cross-validation for out of sample predictive DCNL model fit, following Vehtari et al. (2015). Cross-validation is computed using DCNL Pareto-smoothed importance sampling (PSIS). DCNL Parameters DCNL trace : result of MCMC run DCNL model : PyMC Model DCNL Optional model. Default None, taken from context. DCNL pointwise: bool DCNL if True the pointwise predictive accuracy will be returned. DCNL Default False DCNL progressbar: bool DCNL Whether or not to display a progress bar in the command line. The DCNL bar shows the percentage of completion, the evaluation speed, and DCNL the estimated time to completion DCNL Returns DCNL namedtuple with the following elements: DCNL loo: approximated Leave-one-out cross-validation DCNL loo_se: standard error of loo DCNL p_loo: effective number of parameters DCNL loo_i: and array of the pointwise predictive accuracy, only if pointwise True'
def bpic(trace, model=None): DCNL 'Calculates Bayesian predictive information criterion n of the samples in trace from model DCNL Read more theory here - in a paper by some of the leading authorities on Model Selection - DCNL dx.doi.org/10.1111/1467-9868.00353 DCNL Parameters DCNL trace : result of MCMC run DCNL model : PyMC Model DCNL Optional model. Default None, taken from context.'
def compare(traces, models, ic='WAIC', bootstrap=True, b_samples=1000, alpha=1, seed=None): DCNL 'Compare models based on the widely available information criterion (WAIC) DCNL or leave-one-out (LOO) cross-validation. DCNL Read more theory here - in a paper by some of the leading authorities on DCNL Model Selection - dx.doi.org/10.1111/1467-9868.00353 DCNL Parameters DCNL traces : list of PyMC3 traces DCNL models : list of PyMC3 models DCNL in the same order as traces. DCNL ic : string DCNL Information Criterion (WAIC or LOO) used to compare models. DCNL Default WAIC. DCNL bootstrap : boolean DCNL If True a Bayesian bootstrap will be used to compute the weights and DCNL the standard error of the IC estimate (SE). DCNL b_samples: int DCNL Number of samples taken by the Bayesian bootstrap estimation DCNL alpha : float DCNL The shape parameter in the Dirichlet distribution used for the DCNL Bayesian bootstrap. When alpha=1 (default), the distribution is uniform DCNL on the simplex. A smaller alpha will keeps the final weights DCNL more away from 0 and 1. DCNL seed : int or np.random.RandomState instance DCNL If int or RandomState, use it for seeding Bayesian bootstrap. DCNL Default None the global np.random state is used. DCNL Returns DCNL A DataFrame, ordered from lowest to highest IC. The index reflects DCNL the order in which the models are passed to this function. The columns are: DCNL IC : Information Criteria (WAIC or LOO). DCNL Smaller IC indicates higher out-of-sample predictive fit ("better" model). DCNL Default WAIC. DCNL pIC : Estimated effective number of parameters. DCNL dIC : Relative difference between each IC (WAIC or LOO) DCNL and the lowest IC (WAIC or LOO). DCNL It\'s always 0 for the top-ranked model. DCNL weight: Akaike-like weights for each model. DCNL This can be loosely interpreted as the probability of each model DCNL (among the compared model) given the data. By default the uncertainty DCNL in the weights estimation is considered using Bayesian bootstrap. DCNL SE : Standard error of the IC estimate. DCNL By default these values are estimated using Bayesian bootstrap (best DCNL option) or, if bootstrap=False, using a Gaussian approximation DCNL dSE : Standard error of the difference in IC between each model and DCNL the top-ranked model. DCNL It\'s always 0 for the top-ranked model. DCNL warning : A value of 1 indicates that the computation of the IC may not be DCNL reliable see http://arxiv.org/abs/1507.04544 for details.'
def calc_min_interval(x, alpha): DCNL 'Internal method to determine the minimum interval of DCNL a given width DCNL Assumes that x is sorted numpy array.'
@statfunc DCNL def hpd(x, alpha=0.05, transform=(lambda x: x)): DCNL 'Calculate highest posterior density (HPD) of array for given alpha. The HPD is the DCNL minimum width Bayesian credible interval (BCI). DCNL :Arguments: DCNL x : Numpy array DCNL An array containing MCMC samples DCNL alpha : float DCNL Desired probability of type I error (defaults to 0.05) DCNL transform : callable DCNL Function to transform data (defaults to identity)'
@statfunc DCNL def mc_error(x, batches=5): DCNL 'Calculates the simulation standard error, accounting for non-independent DCNL samples. The trace is divided into batches, and the standard deviation of DCNL the batch means is calculated. DCNL Parameters DCNL x : Numpy array DCNL An array containing MCMC samples DCNL batches : integer DCNL Number of batches DCNL Returns DCNL `float` representing the error'
@statfunc DCNL def quantiles(x, qlist=(2.5, 25, 50, 75, 97.5), transform=(lambda x: x)): DCNL 'Returns a dictionary of requested quantiles from array DCNL Parameters DCNL x : Numpy array DCNL An array containing MCMC samples DCNL qlist : tuple or list DCNL A list of desired quantiles (defaults to (2.5, 25, 50, 75, 97.5)) DCNL transform : callable DCNL Function to transform data (defaults to identity) DCNL Returns DCNL `dictionary` with the quantiles {quantile: value}'
def df_summary(trace, varnames=None, transform=(lambda x: x), stat_funcs=None, extend=False, include_transformed=False, alpha=0.05, start=0, batches=None): DCNL 'Create a data frame with summary statistics. DCNL Parameters DCNL trace : MultiTrace instance DCNL varnames : list DCNL Names of variables to include in summary DCNL transform : callable DCNL Function to transform data (defaults to identity) DCNL stat_funcs : None or list DCNL A list of functions used to calculate statistics. By default, DCNL the mean, standard deviation, simulation standard error, and DCNL highest posterior density intervals are included. DCNL The functions will be given one argument, the samples for a DCNL variable as a 2 dimensional array, where the first axis DCNL corresponds to sampling iterations and the second axis DCNL represents the flattened variable (e.g., x__0, x__1,...). Each DCNL function should return either DCNL 1) A `pandas.Series` instance containing the result of DCNL calculating the statistic along the first axis. The name DCNL attribute will be taken as the name of the statistic. DCNL 2) A `pandas.DataFrame` where each column contains the DCNL result of calculating the statistic along the first axis. DCNL The column names will be taken as the names of the DCNL statistics. DCNL extend : boolean DCNL If True, use the statistics returned by `stat_funcs` in DCNL addition to, rather than in place of, the default statistics. DCNL This is only meaningful when `stat_funcs` is not None. DCNL include_transformed : bool DCNL Flag for reporting automatically transformed variables in addition DCNL to original variables (defaults to False). DCNL alpha : float DCNL The alpha level for generating posterior intervals. Defaults DCNL to 0.05. This is only meaningful when `stat_funcs` is None. DCNL start : int DCNL The starting index from which to summarize (each) chain. Defaults DCNL to zero. DCNL batches : None or int DCNL Batch size for calculating standard deviation for non-independent DCNL samples. Defaults to the smaller of 100 or the number of samples. DCNL This is only meaningful when `stat_funcs` is None. DCNL See also DCNL summary : Generate a pretty-printed summary of a trace. DCNL Returns DCNL `pandas.DataFrame` with summary statistics for each variable DCNL Examples DCNL .. code:: ipython DCNL >>> import pymc3 as pm DCNL >>> trace.mu.shape DCNL (1000, 2) DCNL >>> pm.df_summary(trace, [\'mu\']) DCNL mean        sd  mc_error     hpd_5    hpd_95 DCNL mu__0  0.106897  0.066473  0.001818 -0.020612  0.231626 DCNL mu__1 -0.046597  0.067513  0.002048 -0.174753  0.081924 DCNL Other statistics can be calculated by passing a list of functions. DCNL .. code:: ipython DCNL >>> import pandas as pd DCNL >>> def trace_sd(x): DCNL ...     return pd.Series(np.std(x, 0), name=\'sd\') DCNL >>> def trace_quantiles(x): DCNL ...     return pd.DataFrame(pm.quantiles(x, [5, 50, 95])) DCNL >>> pm.df_summary(trace, [\'mu\'], stat_funcs=[trace_sd, trace_quantiles]) DCNL sd         5        50        95 DCNL mu__0  0.066473  0.000312  0.105039  0.214242 DCNL mu__1  0.067513 -0.159097 -0.045637  0.062912'
def summary(trace, varnames=None, transform=(lambda x: x), alpha=0.05, start=0, batches=None, roundto=3, include_transformed=False, to_file=None): DCNL 'Generate a pretty-printed summary of the node. DCNL Parameters DCNL trace : Trace object DCNL Trace containing MCMC sample DCNL varnames : list of strings DCNL List of variables to summarize. Defaults to None, which results DCNL in all variables summarized. DCNL transform : callable DCNL Function to transform data (defaults to identity) DCNL alpha : float DCNL The alpha level for generating posterior intervals. Defaults to DCNL 0.05. DCNL start : int DCNL The starting index from which to summarize (each) chain. Defaults DCNL to zero. DCNL batches : None or int DCNL Batch size for calculating standard deviation for non-independent DCNL samples. Defaults to the smaller of 100 or the number of samples. DCNL This is only meaningful when `stat_funcs` is None. DCNL roundto : int DCNL The number of digits to round posterior statistics. DCNL include_transformed : bool DCNL Flag for summarizing automatically transformed variables in addition to DCNL original variables (defaults to False). DCNL to_file : None or string DCNL File to write results to. If not given, print to stdout.'
def _groupby_leading_idxs(shape): DCNL 'Group the indices for `shape` by the leading indices of `shape`. DCNL All dimensions except for the rightmost dimension are used to create DCNL groups. DCNL A 3d shape will be grouped by the indices for the two leading DCNL dimensions. DCNL >>> for key, idxs in _groupby_leading_idxs((3, 2, 2)): DCNL ...     print(\'key: {}\'.format(key)) DCNL ...     print(list(idxs)) DCNL key: (0, 0) DCNL [(0, 0, 0), (0, 0, 1)] DCNL key: (0, 1) DCNL [(0, 1, 0), (0, 1, 1)] DCNL key: (1, 0) DCNL [(1, 0, 0), (1, 0, 1)] DCNL key: (1, 1) DCNL [(1, 1, 0), (1, 1, 1)] DCNL key: (2, 0) DCNL [(2, 0, 0), (2, 0, 1)] DCNL key: (2, 1) DCNL [(2, 1, 0), (2, 1, 1)] DCNL A 1d shape will only have one group. DCNL >>> for key, idxs in _groupby_leading_idxs((2,)): DCNL ...     print(\'key: {}\'.format(key)) DCNL ...     print(list(idxs)) DCNL key: () DCNL [(0,), (1,)]'
def bfmi(trace): DCNL 'Calculate the estimated Bayesian fraction of missing information (BFMI). DCNL BFMI quantifies how well momentum resampling matches the marginal energy DCNL distribution.  For more information on BFMI, see DCNL https://arxiv.org/pdf/1604.00695.pdf.  The current advice is that values DCNL smaller than 0.2 indicate poor sampling.  However, this threshold is DCNL provisional and may change.  See DCNL http://mc-stan.org/users/documentation/case-studies/pystan_workflow.html DCNL for more information. DCNL Parameters DCNL trace : result of an HMC/NUTS run, must contain energy information DCNL Returns DCNL `float` representing the estimated BFMI.'
def eval_univariate(f, var, idx, point, x): DCNL 'Evaluate a function as a at a specific point and only varying values at one index. DCNL Useful for debugging misspecified likelihoods. DCNL Parameters DCNL f : function : dict -> val DCNL var : variable DCNL idx : index into variable DCNL point : point at which to center DCNL x : array points at which to evaluate x'
def approx_hessian(point, vars=None, model=None): DCNL 'Returns an approximation of the Hessian at the current chain location. DCNL Parameters DCNL model : Model (optional if in `with` context) DCNL point : dict DCNL vars : list DCNL Variables for which Hessian is to be calculated.'
def fixed_hessian(point, vars=None, model=None): DCNL 'Returns a fixed Hessian for any chain location. DCNL Parameters DCNL model : Model (optional if in `with` context) DCNL point : dict DCNL vars : list DCNL Variables for which Hessian is to be calculated.'
def find_hessian(point, vars=None, model=None): DCNL 'Returns Hessian of logp at the point passed. DCNL Parameters DCNL model : Model (optional if in `with` context) DCNL point : dict DCNL vars : list DCNL Variables for which Hessian is to be calculated.'
def find_hessian_diag(point, vars=None, model=None): DCNL 'Returns Hessian of logp at the point passed. DCNL Parameters DCNL model : Model (optional if in `with` context) DCNL point : dict DCNL vars : list DCNL Variables for which Hessian is to be calculated.'
def trace_cov(trace, vars=None, model=None): DCNL 'Calculate the flattened covariance matrix using a sample trace DCNL Useful if you want to base your covariance matrix for further sampling on some initial samples. DCNL Parameters DCNL trace : Trace DCNL vars : list DCNL variables for which to calculate covariance matrix DCNL Returns DCNL r : array (n,n) DCNL covariance matrix'
def find_MAP(start=None, vars=None, fmin=None, return_raw=False, model=None, live_disp=False, callback=None, *args, **kwargs): DCNL 'Sets state to the local maximum a posteriori point given a model. DCNL Current default of fmin_Hessian does not deal well with optimizing close DCNL to sharp edges, especially if they are the minimum. DCNL Parameters DCNL start : `dict` of parameter values (Defaults to `model.test_point`) DCNL vars : list DCNL List of variables to set to MAP point (Defaults to all continuous). DCNL fmin : function DCNL Optimization algorithm (Defaults to `scipy.optimize.fmin_bfgs` unless DCNL discrete variables are specified in `vars`, then DCNL `scipy.optimize.fmin_powell` which will perform better). DCNL return_raw : Bool DCNL Whether to return extra value returned by fmin (Defaults to `False`) DCNL model : Model (optional if in `with` context) DCNL live_disp : Bool DCNL Display table tracking optimization progress when run from within DCNL an IPython notebook. DCNL callback : callable DCNL Callback function to pass to scipy optimization routine.  Overrides DCNL live_disp if callback is given. DCNL *args, **kwargs DCNL Extra args passed to fmin'
def tround(*args, **kwargs): DCNL 'Temporary function to silence round warning in Theano. Please remove DCNL when the warning disappears.'
def expand_packed_triangular(n, packed, lower=True, diagonal_only=False): DCNL 'Convert a packed triangular matrix into a two dimensional array. DCNL Triangular matrices can be stored with better space efficiancy by DCNL storing the non-zero values in a one-dimensional array. We number DCNL the elements by row like this (for lower or upper triangular matrices):: DCNL [[0 - - -]     [[0 1 2 3] DCNL [1 2 - -]      [- 4 5 6] DCNL [3 4 5 -]      [- - 7 8] DCNL [6 7 8 9]]     [- - - 9] DCNL Parameters DCNL n : int DCNL The number of rows of the triangular matrix. DCNL packed : theano.vector DCNL The matrix in packed format. DCNL lower : bool, default=True DCNL If true, assume that the matrix is lower triangular. DCNL diagonal_only : bool DCNL If true, return only the diagonal of the matrix.'
@pytest.fixture() DCNL def node(Ansible, Interface, Command, request): DCNL 'This fixture represents a single node in the ceph cluster. Using the DCNL Ansible fixture provided by testinfra it can access all the ansible variables DCNL provided to it by the specific test scenario being ran. DCNL You must include this fixture on any tests that operate on specific type of node DCNL because it contains the logic to manage which tests a node should run.'
def _convert_2_string(item): DCNL 'Return byte strings for all items. DCNL This will convert everything within a dict, list or unicode string such DCNL that the values will be encode(\'utf-8\') where applicable.'
def _convert_2_string(item): DCNL 'Return byte strings for all items. DCNL This will convert everything within a dict, list or unicode string such DCNL that the values will be encode(\'utf-8\') where applicable.'
def train(sess, minimize_ops, num_epochs, num_unrolls): DCNL 'L2L training.'
def run_epoch(sess, cost_op, ops, reset, num_unrolls): DCNL 'Runs one optimization epoch.'
def print_stats(header, total_error, total_time, n): DCNL 'Prints experiment statistics.'
def get_config(problem_name, path=None): DCNL 'Returns problem configuration.'
def _nested_assign(ref, value): DCNL 'Returns a nested collection of TensorFlow assign operations. DCNL Args: DCNL ref: Nested collection of TensorFlow variables. DCNL value: Values to be assigned to the variables. Must have the same structure DCNL as `ref`. DCNL Returns: DCNL Nested collection (same structure as `ref`) of TensorFlow assign operations. DCNL Raises: DCNL ValueError: If `ref` and `values` have different structures.'
def _nested_variable(init, name=None, trainable=False): DCNL 'Returns a nested collection of TensorFlow variables. DCNL Args: DCNL init: Nested collection of TensorFlow initializers. DCNL name: Variable name. DCNL trainable: Make variables trainable (`False` by default). DCNL Returns: DCNL Nested collection (same structure as `init`) of TensorFlow variables.'
def _wrap_variable_creation(func, custom_getter): DCNL 'Provides a custom getter for all variable creations.'
def _get_variables(func): DCNL 'Calls func, returning any variables created, but ignoring its return value. DCNL Args: DCNL func: Function to be called. DCNL Returns: DCNL A tuple (variables, constants) where the first element is a list of DCNL trainable variables and the second is the non-trainable variables.'
def _make_with_custom_variables(func, variables): DCNL 'Calls func and replaces any trainable variables. DCNL This returns the output of func, but whenever `get_variable` is called it DCNL will replace any trainable variables with the tensors in `variables`, in the DCNL same order. Non-trainable variables will re-use any variables already DCNL created. DCNL Args: DCNL func: Function to be called. DCNL variables: A list of tensors replacing the trainable variables. DCNL Returns: DCNL The return value of func is returned.'
def _make_nets(variables, config, net_assignments): DCNL 'Creates the optimizer networks. DCNL Args: DCNL variables: A list of variables to be optimized. DCNL config: A dictionary of network configurations, each of which will be DCNL passed to networks.Factory to construct a single optimizer net. DCNL net_assignments: A list of tuples where each tuple is of the form (netid, DCNL variable_names) and is used to assign variables to networks. netid must DCNL be a key in config. DCNL Returns: DCNL A tuple (nets, keys, subsets) where nets is a dictionary of created DCNL optimizer nets such that the net with key keys[i] should be applied to the DCNL subset of variables listed in subsets[i]. DCNL Raises: DCNL ValueError: If net_assignments is None and the configuration defines more DCNL than one network.'
def simple(): DCNL 'Simple problem: f(x) = x^2.'
def simple_multi_optimizer(num_dims=2): DCNL 'Multidimensional simple problem.'
def quadratic(batch_size=128, num_dims=10, stddev=0.01, dtype=tf.float32): DCNL 'Quadratic problem: f(x) = ||Wx - y||.'
def ensemble(problems, weights=None): DCNL 'Ensemble of problems. DCNL Args: DCNL problems: List of problems. Each problem is specified by a dict containing DCNL the keys \'name\' and \'options\'. DCNL weights: Optional list of weights for each problem. DCNL Returns: DCNL Sum of (weighted) losses. DCNL Raises: DCNL ValueError: If weights has an incorrect length.'
def mnist(layers, activation='sigmoid', batch_size=128, mode='train'): DCNL 'Mnist classification with a multi-layer perceptron.'
def _maybe_download_cifar10(path): DCNL 'Download and extract the tarball from Alex\'s website.'
def cifar10(path, conv_channels=None, linear_layers=None, batch_norm=True, batch_size=128, num_threads=4, min_queue_examples=1000, mode='train'): DCNL 'Cifar10 classification with a convolutional network.'
def factory(net, net_options=(), net_path=None): DCNL 'Network factory.'
def save(network, sess, filename=None): DCNL 'Save the variables contained by a network to disk.'
def _convert_to_initializer(initializer): DCNL 'Returns a TensorFlow initializer. DCNL * Corresponding TensorFlow initializer when the argument is a string (e.g. DCNL "zeros" -> `tf.zeros_initializer`). DCNL * `tf.constant_initializer` when the argument is a `numpy` `array`. DCNL * Identity when the argument is a TensorFlow initializer. DCNL Args: DCNL initializer: `string`, `numpy` `array` or TensorFlow initializer. DCNL Returns: DCNL TensorFlow initializer.'
def _get_initializers(initializers, fields): DCNL 'Produces a nn initialization `dict` (see Linear docs for a example). DCNL Grabs initializers for relevant fields if the first argument is a `dict` or DCNL reuses the same initializer for all fields otherwise. All initializers are DCNL processed using `_convert_to_initializer`. DCNL Args: DCNL initializers: Initializer or <variable, initializer> dictionary. DCNL fields: Fields nn is expecting for module initialization. DCNL Returns: DCNL nn initialization dictionary.'
def _get_layer_initializers(initializers, layer_name, fields): DCNL 'Produces a nn initialization dictionary for a layer. DCNL Calls `_get_initializers using initializers[layer_name]` if `layer_name` is a DCNL valid key or using initializers otherwise (reuses initializers between DCNL layers). DCNL Args: DCNL initializers: Initializer, <variable, initializer> dictionary, DCNL <layer, initializer> dictionary. DCNL layer_name: Layer name. DCNL fields: Fields nn is expecting for module initialization. DCNL Returns: DCNL nn initialization dictionary.'
def train(sess, minimize_ops, num_epochs, num_unrolls): DCNL 'L2L training.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def dummyModelParams(perm): DCNL 'This function can be used for Hypersearch algorithm development. When DCNL present, we don\'t actually run the CLA model in the OPF, but instead run DCNL a dummy model. This function returns the dummy model params that will be DCNL used. See the OPFDummyModelRunner class source code (in DCNL nupic.swarming.ModelRunner) for a description of the schema for DCNL the dummy model params.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def dummyModelParams(perm): DCNL 'This function can be used for Hypersearch algorithm development. When DCNL present, Hypersearch doesn\'t actually run the CLA model in the OPF, but DCNL instead runs a dummy model. This function returns the dummy model params that DCNL will be used. See the OPFDummyModelRunner class source code (in DCNL nupic.swarming.ModelRunner) for a description of the schema DCNL for the dummy model params.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def dummyModelParams(perm): DCNL 'This function can be used for Hypersearch algorithm development. When DCNL present, Hypersearch doesn\'t actually run the CLA model in the OPF, but instead run DCNL a dummy model. This function returns the dummy model params that will be DCNL used. See the OPFDummyModelRunner class source code (in DCNL nupic.swarming.ModelRunner) for a description of the schema for DCNL the dummy model params.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def dummyModelParams(perm): DCNL 'This function can be used for Hypersearch algorithm development. When DCNL present, Hypersearch doesn\'t actually run the CLA model in the OPF, but DCNL instead runs a dummy model. This function returns the dummy model params that DCNL will be used. See the OPFDummyModelRunner class source code (in DCNL nupic.swarming.ModelRunner) for a description of the schema DCNL for the dummy model params.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def dummyModelParams(perm): DCNL 'This function can be used for Hypersearch algorithm development. When DCNL present, we don\'t actually run the CLA model in the OPF, but instead run DCNL a dummy model. This function returns the dummy model params that will be DCNL used. See the OPFDummyModelRunner class source code (in DCNL nupic.swarming.ModelRunner) for a description of the schema for DCNL the dummy model params.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def dummyModelParams(perm): DCNL 'This function can be used for Hypersearch algorithm development. When DCNL present, Hypersearch doesn\'t actually run the CLA model in the OPF, but instead run DCNL a dummy model. This function returns the dummy model params that will be DCNL used. See the OPFDummyModelRunner class source code (in DCNL nupic.swarming.ModelRunner) for a description of the schema for DCNL the dummy model params.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def dummyModelParams(perm): DCNL 'This function can be used for Hypersearch algorithm development. When DCNL present, we don\'t actually run the CLA model in the OPF, but instead run DCNL a dummy model. This function returns the dummy model params that will be DCNL used. See the OPFDummyModelRunner class source code (in DCNL nupic.swarming.ModelRunner) for a description of the schema for DCNL the dummy model params.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def dummyModelParams(perm): DCNL 'This function can be used for Hypersearch algorithm development. When DCNL present, Hypersearch doesn\'t actually run the CLA model in the OPF, but DCNL instead runs a dummy model. This function returns the dummy model params that DCNL will be used. See the OPFDummyModelRunner class source code (in DCNL nupic.swarming.ModelRunner) for a description of the schema DCNL for the dummy model params.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def dummyModelParams(perm): DCNL 'This function can be used for Hypersearch algorithm development. When DCNL present, we don\'t actually run the CLA model in the OPF, but instead run DCNL a dummy model. This function returns the dummy model params that will be DCNL used. See the OPFDummyModelRunner class source code (in DCNL nupic.swarming.ModelRunner) for a description of the schema for DCNL the dummy model params.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def getHypersearchWinningModelID(jobID): DCNL 'Parameters: DCNL jobID:            jobID of successfully-completed Hypersearch job DCNL retval:           modelID of the winning model'
def _executeExternalCmdAndReapStdout(args): DCNL 'args:     Args list as defined for the args parameter in subprocess.Popen() DCNL Returns:  result dicionary: DCNL \'exitStatus\':<exit-status-of-external-command>, DCNL \'stdoutData\':"string", DCNL \'stderrData\':"string"'
def _getTestList(): DCNL 'Get the list of tests that can be run from this module'
def _getSimplePatterns(numOnes, numPatterns): DCNL 'Very simple patterns. Each pattern has numOnes consecutive DCNL bits on. There are numPatterns*numOnes bits in the vector.'
def _buildLikelihoodTrainingSet(numOnes=5, relativeFrequencies=None): DCNL 'Two very simple high order sequences for debugging. Each pattern in the DCNL sequence has a series of 1\'s in a specific set of columns.'
def _createTMs(numCols, cellsPerColumn=4, checkSynapseConsistency=True): DCNL 'Create TM and BacktrackingTMCPP instances with identical parameters.'
def _computeTMMetric(tm=None, sequences=None, useResets=True, verbosity=1): DCNL 'Given a trained TM and a list of sequences, compute the temporal memory DCNL performance metric on those sequences. DCNL Parameters: DCNL tm:               A trained temporal memory. DCNL sequences:        A list of sequences. Each sequence is a list of numpy DCNL vectors. DCNL useResets:        If True, the TM\'s reset method will be called before the DCNL the start of each new sequence. DCNL verbosity:        An integer controlling the level of printouts. The higher DCNL the number the more debug printouts. DCNL Return value: DCNL The following pair is returned:  (score, numPredictions) DCNL score:            The average prediction score per pattern. DCNL numPredictions:   The total number of predictions that were made.'
def _createDataset(numSequences, originalSequences, relativeFrequencies): DCNL 'Given a set of sequences, create a dataset consisting of numSequences DCNL sequences. The i\'th pattern in this dataset is chosen from originalSequences DCNL according to the relative frequencies specified in relativeFrequencies.'
def generatePattern(numCols=100, minOnes=21, maxOnes=25, colSet=[], prevPattern=numpy.array([])): DCNL 'Generate a single test pattern with given parameters. DCNL Parameters: DCNL numCols:                Number of columns in each pattern. DCNL minOnes:                The minimum number of 1\'s in each pattern. DCNL maxOnes:                The maximum number of 1\'s in each pattern. DCNL colSet:                 The set of column indices for the pattern. DCNL prevPattern:            Pattern to avoid (null intersection).'
def buildTrainingSet(numSequences=2, sequenceLength=100, pctShared=0.2, seqGenMode='shared DCSP sequence', subsequenceStartPos=10, numCols=100, minOnes=21, maxOnes=25, disjointConsecutive=True): DCNL 'Build random high order test sequences. DCNL Parameters: DCNL numSequences:           The number of sequences created. DCNL sequenceLength:         The length of each sequence. DCNL pctShared:              The percentage of sequenceLength that is shared across DCNL every sequence. If sequenceLength is 100 and pctShared DCNL is 0.2, then a subsequence consisting of 20 patterns DCNL will be in every sequence. Can also be the keyword DCNL \'one pattern\', in which case a single time step is shared. DCNL seqGenMode:             What kind of sequence to generate. If contains \'shared\' DCNL generates shared subsequence. If contains \'no shared\', DCNL does not generate any shared subsequence. If contains DCNL \'shuffle\', will use common patterns shuffle among the DCNL different sequences. If contains \'beginning\', will DCNL place shared subsequence at the beginning. DCNL subsequenceStartPos:    The position where the shared subsequence starts DCNL numCols:                Number of columns in each pattern. DCNL minOnes:                The minimum number of 1\'s in each pattern. DCNL maxOnes:                The maximum number of 1\'s in each pattern. DCNL disjointConsecutive:    Whether to generate disjoint consecutive patterns or not.'
def getSimplePatterns(numOnes, numPatterns): DCNL 'Very simple patterns. Each pattern has numOnes consecutive DCNL bits on. There are numPatterns*numOnes bits in the vector.'
def buildSimpleTrainingSet(numOnes=5): DCNL 'Two very simple high order sequences for debugging. Each pattern in the DCNL sequence has a series of 1\'s in a specific set of columns.'
def buildAlternatingTrainingSet(numOnes=5): DCNL 'High order sequences that alternate elements. Pattern i has one\'s in DCNL i*numOnes to (i+1)*numOnes. DCNL The sequences are: DCNL A B A B A C DCNL A B A B D E DCNL A B F G H I DCNL A J K L M N'
def buildHL0aTrainingSet(numOnes=5): DCNL 'Simple sequences for HL0. Each pattern in the sequence has a series of 1\'s DCNL in a specific set of columns. DCNL There are 23 patterns, p0 to p22. DCNL The sequence we want to learn is p0->p1->p2 DCNL We create a very long sequence consisting of N N p0 p1 p2 N N p0 p1 p2 DCNL N is randomly chosen from p3 to p22'
def buildHL0bTrainingSet(numOnes=5): DCNL 'Simple sequences for HL0b. Each pattern in the sequence has a series of 1\'s DCNL in a specific set of columns. DCNL There are 23 patterns, p0 to p22. DCNL The sequences we want to learn are p1->p2->p3 and p0->p1->p2->p4. DCNL We create a very long sequence consisting of these two sub-sequences DCNL intermixed with noise, such as: DCNL N N p0 p1 p2 p4 N N p1 p2 p3 N N p1 p2 p3 DCNL N is randomly chosen from p5 to p22'
def findAcceptablePatterns(tm, t, whichSequence, trainingSequences, nAcceptable=1): DCNL 'Tries to infer the set of acceptable patterns for prediction at the given DCNL time step and for the give sequence. Acceptable patterns are: the current one, DCNL plus a certain number of patterns after timeStep, in the sequence that the TM DCNL is currently tracking. Any other pattern is not acceptable. DCNL TODO: DCNL - Doesn\'t work for noise cases. DCNL - Might run in trouble if shared subsequence at the beginning. DCNL Parameters: DCNL tm                       the whole TM, so that we can look at its parameters DCNL t                        the current time step DCNL whichSequence            the sequence we are currently tracking DCNL trainingSequences        all the training sequences DCNL nAcceptable              the number of steps forward from the current timeStep DCNL we are willing to consider acceptable. In the case of DCNL pooling, it is less than or equal to the min of the DCNL number of training reps and the segUpdateValidDuration DCNL parameter of the TM, depending on the test case. DCNL The default value is 1, because by default, the pattern DCNL after the current one should always be predictable. DCNL Return value: DCNL acceptablePatterns       A list of acceptable patterns for prediction.'
def _testSequence(trainingSequences, nTrainingReps=1, numberOfCols=40, cellsPerColumn=5, initialPerm=0.8, connectedPerm=0.7, minThreshold=11, newSynapseCount=5, permanenceInc=0.4, permanenceDec=0.0, permanenceMax=1, globalDecay=0.0, pamLength=1000, activationThreshold=5, acceptablePatterns=[], doPooling=False, nAcceptable=(-1), noiseModel=None, noiseLevel=0, doResets=True, shouldFail=False, testSequences=None, predJustAfterHubOnly=None, compareToPy=False, nMultiStepPrediction=0, highOrder=False): DCNL 'Test a single set of sequences once and return the number of DCNL prediction failures, the number of errors, and the number of perfect DCNL predictions'
def TestH2a(sequenceLength, nTests, cellsPerColumn, numCols=100, nSequences=[2], pctShared=0.02, seqGenMode='shared DCSP sequence', shouldFail=False): DCNL 'Still need to test: DCNL Two overlapping sequences. OK to get new segments but check that we can DCNL get correct high order prediction after multiple reps.'
def worker(x): DCNL 'Worker function to use in parallel hub capacity test below.'
def hubCapacity(): DCNL 'Study hub capacity. Figure out how many sequences can share a pattern DCNL for a given number of cells per column till we the system fails. DCNL DON\'T RUN IN BUILD SYSTEM!!! (takes too long)'
def printOneTrainingVector(x): DCNL 'Print a single vector succinctly.'
def getSimplePatterns(numOnes, numPatterns, patternOverlap=0): DCNL 'Very simple patterns. Each pattern has numOnes consecutive DCNL bits on. The amount of overlap between consecutive patterns is DCNL configurable, via the patternOverlap parameter. DCNL Parameters: DCNL numOnes:        Number of bits ON in each pattern DCNL numPatterns:    Number of unique patterns to generate DCNL patternOverlap: Number of bits of overlap between each successive pattern DCNL retval:         patterns'
def buildOverlappedSequences(numSequences=2, seqLen=5, sharedElements=[3, 4], numOnBitsPerPattern=3, patternOverlap=0, seqOverlap=0, **kwargs): DCNL 'Create training sequences that share some elements in the middle. DCNL Parameters: DCNL numSequences:         Number of unique training sequences to generate DCNL seqLen:               Overall length of each sequence DCNL sharedElements:       Which element indices of each sequence are shared. These DCNL will be in the range between 0 and seqLen-1 DCNL numOnBitsPerPattern:  Number of ON bits in each TM input pattern DCNL patternOverlap:       Max number of bits of overlap between any 2 patterns DCNL retval:               (numCols, trainingSequences) DCNL numCols - width of the patterns DCNL trainingSequences - a list of training sequences'
def buildSequencePool(numSequences=10, seqLen=[2, 3, 4], numPatterns=5, numOnBitsPerPattern=3, patternOverlap=0, **kwargs): DCNL 'Create a bunch of sequences of various lengths, all built from DCNL a fixed set of patterns. DCNL Parameters: DCNL numSequences:         Number of training sequences to generate DCNL seqLen:               List of possible sequence lengths DCNL numPatterns:          How many possible patterns there are to use within DCNL sequences DCNL numOnBitsPerPattern:  Number of ON bits in each TM input pattern DCNL patternOverlap:       Max number of bits of overlap between any 2 patterns DCNL retval:               (numCols, trainingSequences) DCNL numCols - width of the patterns DCNL trainingSequences - a list of training sequences'
def createTMs(includeCPP=True, includePy=True, numCols=100, cellsPerCol=4, activationThreshold=3, minThreshold=3, newSynapseCount=3, initialPerm=0.6, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, checkSynapseConsistency=True, maxInfBacktrack=0, maxLrnBacktrack=0, **kwargs): DCNL 'Create one or more TM instances, placing each into a dict keyed by DCNL name. DCNL Parameters: DCNL retval:   tms - dict of TM instances'
def assertNoTMDiffs(tms): DCNL 'Check for diffs among the TM instances in the passed in tms dict and DCNL raise an assert if any are detected DCNL Parameters: DCNL tms:                  dict of TM instances'
def evalSequences(tms, trainingSequences, testSequences=None, nTrainRepetitions=1, doResets=True, **kwargs): DCNL 'Train the TMs on the entire training set for nTrainRepetitions in a row. DCNL Then run the test set through inference once and return the inference stats. DCNL Parameters: DCNL tms:                  dict of TM instances DCNL trainingSequences:    list of training sequences. Each sequence is a list DCNL of TM input patterns DCNL testSequences:        list of test sequences. If None, we will test against DCNL the trainingSequences DCNL nTrainRepetitions:    Number of times to run the training set through the TM DCNL doResets:             If true, send a reset to the TM between each sequence'
def _testConfig(baseParams, expMissingMin=0, expMissingMax=0, **mods): DCNL 'Build up a set of sequences, create the TM(s), train them, test them, DCNL and check that we got the expected number of missing predictions during DCNL inference. DCNL Parameters: DCNL baseParams:     dict of all of the parameters for building sequences, DCNL creating the TMs, and training and testing them. This DCNL gets updated from \'mods\' before we use it. DCNL expMissingMin:   Minimum number of expected missing predictions during testing. DCNL expMissingMax:   Maximum number of expected missing predictions during testing. DCNL mods:           dict of modifications to make to the baseParams.'
def simulateKMoreThanOne(): DCNL 'A small test with k=3'
def simulateClassifier(knn, patternDict, testName, testDict=None): DCNL 'Train this classifier instance with the given patterns.'
def getNumTestPatterns(short=0): DCNL 'Return the number of patterns and classes the test should use.'
def simulateCategories(numSamples=100, numDimensions=500): DCNL 'Simulate running KNN classifier on many disjoint categories'
def createPattern(c, numDimensions): DCNL 'Create a sparse pattern from category c with the given number of dimensions. DCNL The pattern is created by setting element c to be a high random number. DCNL Element c-1 and c+1 are set to low random numbers. numDimensions must be > c.'
def _getTempFileName(): DCNL 'Creates unique test csv file name.'
def _getTempFileName(): DCNL 'Creates unique test csv file name.'
def _executeExternalCmdAndReapOutputs(args): DCNL 'args:     Args list as defined for the args parameter in subprocess.Popen() DCNL Returns:  result dicionary: DCNL \'exitStatus\':<exit-status-of-external-command>, DCNL \'stdoutData\':"string", DCNL \'stderrData\':"string"'
def whoisCallersCaller(): DCNL 'Returns: Traceback namedtuple for our caller\'s caller'
def _executeExternalCmdAndReapStdout(args): DCNL 'args:     Args list as defined for the args parameter in subprocess.Popen() DCNL Returns:  result dicionary: DCNL \'exitStatus\':<exit-status-of-external-command>, DCNL \'stdoutData\':"string", DCNL \'stderrData\':"string"'
def _getTestList(): DCNL 'Get the list of tests that can be run from this module'
def getAllDirectoriesWithFile(path, filename, excludeDirs): DCNL 'Returns a list of directories in the <path> with a given <filename>, excluding DCNL <excludeDirs>'
def getAllExperimentDirectories(excludedExperiments=[]): DCNL 'Experiment directories are the directories with a description.py file'
def runReducedExperiment(path, reduced=True): DCNL 'Run the experiment in the <path> with a reduced iteration count'
def _setupTempDirectory(filename): DCNL 'Create a temp directory, and return path to filename in that directory'
def _createEncoder(): DCNL 'Create the encoder instance for our test and return it.'
def _createOPFNetwork(addSP=True, addTP=False): DCNL 'Create a \'new-style\' network ala OPF and return it. DCNL If addSP is true, an SPRegion will be added named \'level1SP\'. DCNL If addTP is true, a TMRegion will be added named \'level1TP\''
def _aggregate(input, options, output, timeFieldName): DCNL 'Aggregate the input stream and write aggregated records to the output DCNL stream'
def createEncoder(): DCNL 'Create the encoder instance for our test and return it.'
def createNetwork(dataSource, enableTP=False, temporalImp='py'): DCNL 'Create the Network instance. DCNL The network has a sensor region reading data from `dataSource` and passing DCNL the encoded representation to an SPRegion. The SPRegion output is passed to DCNL a TMRegion. DCNL :param dataSource: a RecordStream instance to get data from DCNL :returns: a Network instance ready to run'
def _sampleDistribution(params, numSamples, verbosity=0): DCNL 'Given the parameters of a distribution, generate numSamples points from it. DCNL This routine is mostly for testing. DCNL :returns: A numpy array of samples.'
def _generateSampleData(mean=0.2, variance=0.2, metricMean=0.2, metricVariance=0.2): DCNL 'Generate 1440 samples of fake metrics data with a particular distribution DCNL of anomaly scores and metric values. Here we generate values every minute.'
def _getDateList(numSamples, startDatetime): DCNL 'Generate a sequence of sample dates starting at startDatetime and incrementing DCNL every minute.'
def _printOneTrainingVector(x): DCNL 'Print a single vector succinctly.'
def _getSimplePatterns(numOnes, numPatterns): DCNL 'Very simple patterns. Each pattern has numOnes consecutive DCNL bits on. There are numPatterns*numOnes bits in the vector. These patterns DCNL are used as elements of sequences when building up a training set.'
def _createTms(numCols): DCNL 'Create two instances of temporal poolers (backtracking_tm.py DCNL and backtracking_tm_cpp.py) with identical parameter settings.'
def _computeOverlap(x, y): DCNL 'Given two binary arrays, compute their overlap. The overlap is the number DCNL of bits where x[i] and y[i] are both 1'
def _areAllSDRsUnique(sdrDict): DCNL 'Return True iff all the SDR\'s in the dict are unique.'
def checkCell0(tm): DCNL 'Check that cell 0 has no incoming segments'
def setVerbosity(verbosity, tm, tmPy): DCNL 'Set verbosity levels of the TM\'s'
def _createNetwork(): DCNL 'Create network with one RecordSensor region.'
def _createNetwork(): DCNL 'Create a network with a RecordSensor region and a SDRClassifier region'
def _createSensorToClassifierLinks(network, sensorRegionName, classifierRegionName): DCNL 'Create links from sensor region to classifier region.'
def computeOverlap(x, y): DCNL 'Given two binary arrays, compute their overlap. The overlap is the number DCNL of bits where x[i] and y[i] are both 1'
def validateEncoder(encoder, subsampling): DCNL 'Given an encoder, calculate overlaps statistics and ensure everything is ok. DCNL We don\'t check every possible combination for speed reasons.'
def overlapsForRelativeAreas(n, w, initPosition, initRadius, dPosition=None, dRadius=0, num=100, verbose=False): DCNL 'Return overlaps between an encoding and other encodings relative to it DCNL :param n: the size of the encoder output DCNL :param w: the number of active bits in the encoder output DCNL :param initPosition: the position of the first encoding DCNL :param initRadius: the radius of the first encoding DCNL :param dPosition: the offset to apply to each subsequent position DCNL :param dRadius: the offset to apply to each subsequent radius DCNL :param num: the number of encodings to generate DCNL :param verbose: whether to print verbose output'
def overlapsForUnrelatedAreas(n, w, radius, repetitions=100, verbose=False): DCNL 'Return overlaps between an encoding and other, unrelated encodings'
def _getPredictionsGenerator(examplesDir, exampleName): DCNL 'Get predictions generator for one of the quick-start example. DCNL .. note:: DCNL The examples are not part of the nupic package so we need to manually DCNL append the example module path to syspath. DCNL :param examplesDir: DCNL (str) path to the example parent directory. DCNL :param exampleName: DCNL (str) name of the example. E.g: "opf", "network", "algo". DCNL :return predictionsGenerator: DCNL (function) predictions generator functions.'
def _getTempFileName(): DCNL 'Creates unique file name that starts with \'test\' and ends with \'.txt\'.'
def memorized_timedelta(seconds): DCNL 'Create only one instance of each distinct timedelta'
def memorized_datetime(seconds): DCNL 'Create only one instance of each distinct datetime'
def memorized_ttinfo(*args): DCNL 'Create only one instance of each distinct tuple'
def _to_seconds(td): DCNL 'Convert a timedelta to seconds'
def unpickler(zone, utcoffset=None, dstoffset=None, tzname=None): DCNL 'Factory function for unpickling pytz tzinfo instances. DCNL This is shared for both StaticTzInfo and DstTzInfo instances, because DCNL database changes could cause a zones implementation to switch between DCNL these two base classes and we can\'t break pickles on a pytz version DCNL upgrade.'
def open_resource(name): DCNL 'Open a resource from the zoneinfo subdir for reading. DCNL Uses the pkg_resources module if available.'
def timezone(zone): DCNL 'Return a datetime.tzinfo implementation for the given timezone DCNL >>> from datetime import datetime, timedelta DCNL >>> utc = timezone(\'UTC\') DCNL >>> eastern = timezone(\'US/Eastern\') DCNL >>> eastern.zone DCNL \'US/Eastern\' DCNL >>> timezone(u\'US/Eastern\') is eastern DCNL True DCNL >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc) DCNL >>> loc_dt = utc_dt.astimezone(eastern) DCNL >>> fmt = \'%Y-%m-%d %H:%M:%S %Z (%z)\' DCNL >>> loc_dt.strftime(fmt) DCNL \'2002-10-27 01:00:00 EST (-0500)\' DCNL >>> (loc_dt - timedelta(minutes=10)).strftime(fmt) DCNL \'2002-10-27 00:50:00 EST (-0500)\' DCNL >>> eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt) DCNL \'2002-10-27 01:50:00 EDT (-0400)\' DCNL >>> (loc_dt + timedelta(minutes=10)).strftime(fmt) DCNL \'2002-10-27 01:10:00 EST (-0500)\' DCNL Raises UnknownTimeZoneError if passed an unknown zone. DCNL >>> timezone(\'Asia/Shangri-La\') DCNL Traceback (most recent call last): DCNL UnknownTimeZoneError: \'Asia/Shangri-La\' DCNL >>> timezone(u\'\N{TRADE MARK SIGN}\') DCNL Traceback (most recent call last): DCNL UnknownTimeZoneError: u\'\u2122\''
def _unmunge_zone(zone): DCNL 'Undo the time zone name munging done by older versions of pytz.'
def _UTC(): DCNL 'Factory function for utc unpickling. DCNL Makes sure that unpickling a utc instance always returns the same DCNL module global. DCNL These examples belong in the UTC class above, but it is obscured; or in DCNL the README.txt, but we are not depending on Python 2.4 so integrating DCNL the README.txt examples with the unit tests is not trivial. DCNL >>> import datetime, pickle DCNL >>> dt = datetime.datetime(2005, 3, 1, 14, 13, 21, tzinfo=utc) DCNL >>> naive = dt.replace(tzinfo=None) DCNL >>> p = pickle.dumps(dt, 1) DCNL >>> naive_p = pickle.dumps(naive, 1) DCNL >>> len(p), len(naive_p), len(p) - len(naive_p) DCNL (60, 43, 17) DCNL >>> new = pickle.loads(p) DCNL >>> new == dt DCNL True DCNL >>> new is dt DCNL False DCNL >>> new.tzinfo is dt.tzinfo DCNL True DCNL >>> utc is UTC is timezone(\'UTC\') DCNL True DCNL >>> utc is timezone(\'GMT\') DCNL False'
def _p(*args): DCNL 'Factory function for unpickling pytz tzinfo instances. DCNL Just a wrapper around tzinfo.unpickler to save a few bytes in each pickle DCNL by shortening the path.'
def country_timezones(iso3166_code): DCNL 'Return a list of timezones used in a particular country. DCNL iso3166_code is the two letter code used to identify the country. DCNL >>> country_timezones(\'ch\') DCNL [\'Europe/Zurich\'] DCNL >>> country_timezones(\'CH\') DCNL [\'Europe/Zurich\'] DCNL >>> country_timezones(u\'ch\') DCNL [\'Europe/Zurich\'] DCNL >>> country_timezones(\'XXX\') DCNL Traceback (most recent call last): DCNL KeyError: \'XXX\''
def FixedOffset(offset, _tzinfos={}): DCNL 'return a fixed-offset timezone based off a number of minutes. DCNL >>> one = FixedOffset(-330) DCNL >>> one DCNL pytz.FixedOffset(-330) DCNL >>> one.utcoffset(datetime.datetime.now()) DCNL datetime.timedelta(-1, 66600) DCNL >>> two = FixedOffset(1380) DCNL >>> two DCNL pytz.FixedOffset(1380) DCNL >>> two.utcoffset(datetime.datetime.now()) DCNL datetime.timedelta(0, 82800) DCNL The datetime.timedelta must be between the range of -1 and 1 day, DCNL non-inclusive. DCNL >>> FixedOffset(1440) DCNL Traceback (most recent call last): DCNL ValueError: (\'absolute offset is too large\', 1440) DCNL >>> FixedOffset(-1440) DCNL Traceback (most recent call last): DCNL ValueError: (\'absolute offset is too large\', -1440) DCNL An offset of 0 is special-cased to return UTC. DCNL >>> FixedOffset(0) is UTC DCNL True DCNL There should always be only one instance of a FixedOffset per timedelta. DCNL This should be true for multiple creation calls. DCNL >>> FixedOffset(-330) is one DCNL True DCNL >>> FixedOffset(1380) is two DCNL True DCNL It should also be true for pickling. DCNL >>> import pickle DCNL >>> pickle.loads(pickle.dumps(one)) is one DCNL True DCNL >>> pickle.loads(pickle.dumps(two)) is two DCNL True'
def get_supported_platform(): DCNL 'Return this platform\'s maximum compatible version. DCNL distutils.util.get_platform() normally reports the minimum version DCNL of Mac OS X that would be required to *use* extensions produced by DCNL distutils.  But what we want when checking compatibility is to know the DCNL version of Mac OS X that we are *running*.  To allow usage of packages that DCNL explicitly require a newer version of Mac OS X, we must also know the DCNL current version of the OS. DCNL If this condition occurs for any other platform with a version in its DCNL platform strings, this function should be extended accordingly.'
def register_loader_type(loader_type, provider_factory): DCNL 'Register `provider_factory` to make providers for `loader_type` DCNL `loader_type` is the type or class of a PEP 302 ``module.__loader__``, DCNL and `provider_factory` is a function that, passed a *module* object, DCNL returns an ``IResourceProvider`` for that module.'
def get_provider(moduleOrReq): DCNL 'Return an IResourceProvider for the named module or requirement'
def get_build_platform(): DCNL 'Return this platform\'s string for platform-specific distributions DCNL XXX Currently this is the same as ``distutils.util.get_platform()``, but it DCNL needs some hacks for Linux and Mac OS X.'
def compatible_platforms(provided, required): DCNL 'Can code for the `provided` platform run on the `required` platform? DCNL Returns true if either platform is ``None``, or the platforms are equal. DCNL XXX Needs compatibility checks for Linux and other unixy OSes.'
def run_script(dist_spec, script_name): DCNL 'Locate distribution `dist_spec` and run its `script_name` script'
def get_distribution(dist): DCNL 'Return a current distribution object for a Requirement or string'
def load_entry_point(dist, group, name): DCNL 'Return `name` entry point of `group` for `dist` or raise ImportError'
def get_entry_map(dist, group=None): DCNL 'Return the entry point map for `group`, or the full entry map'
def get_entry_info(dist, group, name): DCNL 'Return the EntryPoint object for `group`+`name`, or ``None``'
def get_default_cache(): DCNL 'Determine the default cache location DCNL This returns the ``PYTHON_EGG_CACHE`` environment variable, if set. DCNL Otherwise, on Windows, it returns a "Python-Eggs" subdirectory of the DCNL "Application Data" directory.  On all other systems, it\'s "~/.python-eggs".'
def safe_name(name): DCNL 'Convert an arbitrary string to a standard distribution name DCNL Any runs of non-alphanumeric/. characters are replaced with a single \'-\'.'
def safe_version(version): DCNL 'Convert an arbitrary string to a standard version string DCNL Spaces become dots, and all other non-alphanumeric characters become DCNL dashes, with runs of multiple dashes condensed to a single dash.'
def safe_extra(extra): DCNL 'Convert an arbitrary string to a standard \'extra\' name DCNL Any runs of non-alphanumeric characters are replaced with a single \'_\', DCNL and the result is always lowercased.'
def to_filename(name): DCNL 'Convert a project or version name to its filename-escaped form DCNL Any \'-\' characters are currently replaced with \'_\'.'
def get_importer(path_item): DCNL 'Retrieve a PEP 302 "importer" for the given path item DCNL If there is no importer, this returns a wrapper around the builtin import DCNL machinery.  The returned importer is only cached if it was created by a DCNL path hook.'
def register_finder(importer_type, distribution_finder): DCNL 'Register `distribution_finder` to find distributions in sys.path items DCNL `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item DCNL handler), and `distribution_finder` is a callable that, passed a path DCNL item and the importer instance, yields ``Distribution`` instances found on DCNL that path item.  See ``pkg_resources.find_on_path`` for an example.'
def find_distributions(path_item, only=False): DCNL 'Yield distributions accessible via `path_item`'
def StringIO(*args, **kw): DCNL 'Thunk to load the real StringIO on demand'
def find_on_path(importer, path_item, only=False): DCNL 'Yield distributions accessible on a sys.path directory'
def register_namespace_handler(importer_type, namespace_handler): DCNL 'Register `namespace_handler` to declare namespace packages DCNL `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item DCNL handler), and `namespace_handler` is a callable like this:: DCNL def namespace_handler(importer,path_entry,moduleName,module): DCNL # return a path_entry to use for child packages DCNL Namespace handlers are only called if the importer object has already DCNL agreed that it can handle the relevant path item, and they should only DCNL return a subpath if the module __path__ does not already contain an DCNL equivalent subpath.  For an example namespace handler, see DCNL ``pkg_resources.file_ns_handler``.'
def _handle_ns(packageName, path_item): DCNL 'Ensure that named package includes a subpath of path_item (if needed)'
def declare_namespace(packageName): DCNL 'Declare that package \'packageName\' is a namespace package'
def fixup_namespace_packages(path_item, parent=None): DCNL 'Ensure that previously-declared namespace packages include path_item'
def file_ns_handler(importer, path_item, packageName, module): DCNL 'Compute an ns-package subpath for a filesystem or zipfile importer'
def normalize_path(filename): DCNL 'Normalize a file/dir name for comparison purposes'
def yield_lines(strs): DCNL 'Yield non-empty/non-comment lines of a ``basestring`` or sequence'
def parse_version(s): DCNL 'Convert a version string to a chronologically-sortable key DCNL This is a rough cross between distutils\' StrictVersion and LooseVersion; DCNL if you give it versions that would work with StrictVersion, then it behaves DCNL the same; otherwise it acts like a slightly-smarter LooseVersion. It is DCNL *possible* to create pathological version coding schemes that will fool DCNL this parser, but they should be very rare in practice. DCNL The returned value will be a tuple of strings.  Numeric portions of the DCNL version are padded to 8 digits so they will compare numerically, but DCNL without relying on how numbers compare relative to strings.  Dots are DCNL dropped, but dashes are retained.  Trailing zeros between alpha segments DCNL or dashes are suppressed, so that e.g. "2.4.0" is considered the same as DCNL "2.4". Alphanumeric parts are lower-cased. DCNL The algorithm assumes that strings like "-" and any alpha string that DCNL alphabetically follows "final"  represents a "patch level".  So, "2.4-1" DCNL is assumed to be a branch or patch of "2.4", and therefore "2.4.1" is DCNL considered newer than "2.4-1", whic in turn is newer than "2.4". DCNL Strings like "a", "b", "c", "alpha", "beta", "candidate" and so on (that DCNL come before "final" alphabetically) are assumed to be pre-release versions, DCNL so that the version "2.4" is considered newer than "2.4a1". DCNL Finally, to handle miscellaneous cases, the strings "pre", "preview", and DCNL "rc" are treated as if they were "c", i.e. as though they were release DCNL candidates, and therefore are not as new as a version string that does not DCNL contain them.'
def parse_requirements(strs): DCNL 'Yield ``Requirement`` objects for each specification in `strs` DCNL `strs` must be an instance of ``basestring``, or a (possibly-nested) DCNL iterable thereof.'
def _get_mro(cls): DCNL 'Get an mro for a type or classic class'
def _find_adapter(registry, ob): DCNL 'Return an adapter factory for `ob` from `registry`'
def ensure_directory(path): DCNL 'Ensure that the parent directory of `path` exists'
def split_sections(s): DCNL 'Split a string or iterable thereof into (section,content) pairs DCNL Each ``section`` is a stripped version of the section header ("[section]") DCNL and each ``content`` is a list of stripped lines excluding blank lines and DCNL comment-only lines.  If there are any such lines before the first section DCNL header, they\'re returned in a first ``section`` of ``None``.'
def table(ax, cellText=None, cellColours=None, cellLoc='right', colWidths=None, rowLabels=None, rowColours=None, rowLoc='left', colLabels=None, colColours=None, colLoc='center', loc='bottom', bbox=None): DCNL 'TABLE(cellText=None, cellColours=None, DCNL cellLoc=\'right\', colWidths=None, DCNL rowLabels=None, rowColours=None, rowLoc=\'left\', DCNL colLabels=None, colColours=None, colLoc=\'center\', DCNL loc=\'bottom\', bbox=None) DCNL Factory function to generate a Table instance. DCNL Thanks to John Gill for providing the class and table.'
def slice2gridspec(key): DCNL 'Convert a 2-tuple of slices to start,stop,steps for x and y. DCNL key -- (slice(ystart,ystop,ystep), slice(xtart, xstop, xstep)) DCNL For now, the only accepted step values are imaginary integers (interpreted DCNL in the same way numpy.mgrid, etc. do).'
def quality(func, mesh, interpolator='nn', n=33): DCNL 'Compute a quality factor (the quantity r**2 from TOMS792). DCNL interpolator must be in (\'linear\', \'nn\').'
def debug_on_error(type, value, tb): DCNL 'Code due to Thomas Heller - published in Python Cookbook (O\'Reilley)'
def error_msg_wx(msg, parent=None): DCNL 'Signal an error condition -- in a GUI, popup a error dialog'
def raise_msg_to_str(msg): DCNL 'msg is a return arg from a raise.  Join with new lines'
def _create_wx_app(): DCNL 'Creates a wx.PySimpleApp instance if a wx.App has not been created.'
def draw_if_interactive(): DCNL 'This should be overriden in a windowing environment if drawing DCNL should be done in interactive python mode'
def show(): DCNL 'Current implementation assumes that matplotlib is executed in a PyCrust DCNL shell. It appears to be possible to execute wxPython applications from DCNL within a PyCrust without having to ensure that wxPython has been created DCNL in a secondary thread (e.g. SciPy gui_thread). DCNL Unfortunately, gui_thread seems to introduce a number of further DCNL dependencies on SciPy modules, which I do not wish to introduce DCNL into the backend at this point. If there is a need I will look DCNL into this in a later release.'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def _load_bitmap(filename): DCNL 'Load a bitmap file from the backends/images subdirectory in which the DCNL matplotlib library is installed. The filename parameter should not DCNL contain any path information as this is determined automatically. DCNL Returns a wx.Bitmap object'
def fill(strings, linelen=75): DCNL 'Make one string from sequence of strings, with whitespace DCNL in between. The whitespace is chosen to form lines of at most DCNL linelen characters, if possible.'
def pdfRepr(obj): DCNL 'Map Python objects to PDF syntax.'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def quote_ps_string(s): DCNL 'Quote dangerous characters of S for use in a PostScript string constant.'
def seq_allequal(seq1, seq2): DCNL 'seq1 and seq2 are either None or sequences or numerix arrays DCNL Return True if both are None or both are seqs with identical DCNL elements'
def convert_psfrags(tmpfile, psfrags, font_preamble, custom_preamble, paperWidth, paperHeight, orientation): DCNL 'When we want to use the LaTeX backend with postscript, we write PSFrag tags DCNL to a temporary postscript file, each one marking a position for LaTeX to DCNL render some text. convert_psfrags generates a LaTeX document containing the DCNL commands to convert those tags to text. LaTeX/dvips produces the postscript DCNL file that includes the actual text.'
def gs_distill(tmpfile, eps=False, ptype='letter', bbox=None): DCNL 'Use ghostscript\'s pswrite or epswrite device to distill a file. DCNL This yields smaller files without illegal encapsulated postscript DCNL operators. The output is low-level, converting text to outlines.'
def xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None): DCNL 'Use ghostscript\'s ps2pdf and xpdf\'s/poppler\'s pdftops to distill a file. DCNL This yields smaller files without illegal encapsulated postscript DCNL operators. This distiller is preferred, generating high-level postscript DCNL output that treats text as text.'
def get_bbox(tmpfile, bbox): DCNL 'Use ghostscript\'s bbox device to find the center of the bounding box. Return DCNL an appropriately sized bbox centered around that point. A bit of a hack.'
def pstoeps(tmpfile, bbox): DCNL 'Convert the postscript to encapsulated postscript.'
def draw_if_interactive(): DCNL 'Is called after every pylab drawing command'
def show(mainloop=True): DCNL 'Show all the figures and enter the gtk main loop DCNL This should be the last line of your script'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def draw_if_interactive(): DCNL 'For image backends - is not required DCNL For GUI backends - this should be overriden if drawing should be done in DCNL interactive python mode'
def show(): DCNL 'For image backends - is not required DCNL For GUI backends - show() is usually the last line of a pylab script and DCNL tells the backend that it is time to draw.  In interactive mode, this may DCNL be a do nothing func.  See the GTK backend for an example of how to handle DCNL interactive versus batch mode'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def pylab_setup(): DCNL 'return new_figure_manager, draw_if_interactive and show for pylab'
def draw_if_interactive(): DCNL 'For image backends - is not required DCNL For GUI backends - this should be overriden if drawing should be done in DCNL interactive python mode'
def show(): DCNL 'For image backends - is not required DCNL For GUI backends - show() is usually the last line of a pylab script and DCNL tells the backend that it is time to draw.  In interactive mode, this may DCNL be a do nothing func.  See the GTK backend for an example of how to handle DCNL interactive versus batch mode'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def raise_msg_to_str(msg): DCNL 'msg is a return arg from a raise.  Join with new lines'
def show(): DCNL 'Show all the figures and enter the gtk mainloop DCNL This should be the last line of your script.  This function sets DCNL interactive mode to True, as detailed on DCNL http://matplotlib.sf.net/interactive.html'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def draw_if_interactive(): DCNL 'Is called after every pylab drawing command'
def _create_qApp(): DCNL 'Only one qApp can exist at a time, so check before creating one'
def show(): DCNL 'Show all the figures and enter the qt main loop DCNL This should be the last line of your script'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def exception_handler(type, value, tb): DCNL 'Handle uncaught exceptions DCNL It does not catch SystemExit'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def _py_convert_agg_to_wx_image(agg, bbox): DCNL 'Convert the region of the agg buffer bounded by bbox to a wx.Image.  If DCNL bbox is None, the entire buffer is converted. DCNL Note: agg must be a backend_agg.RendererAgg instance.'
def _py_convert_agg_to_wx_bitmap(agg, bbox): DCNL 'Convert the region of the agg buffer bounded by bbox to a wx.Bitmap.  If DCNL bbox is None, the entire buffer is converted. DCNL Note: agg must be a backend_agg.RendererAgg instance.'
def _clipped_image_as_bitmap(image, bbox): DCNL 'Convert the region of a wx.Image bounded by bbox to a wx.Bitmap.'
def _py_WX28_convert_agg_to_wx_image(agg, bbox): DCNL 'Convert the region of the agg buffer bounded by bbox to a wx.Image.  If DCNL bbox is None, the entire buffer is converted. DCNL Note: agg must be a backend_agg.RendererAgg instance.'
def _py_WX28_convert_agg_to_wx_bitmap(agg, bbox): DCNL 'Convert the region of the agg buffer bounded by bbox to a wx.Bitmap.  If DCNL bbox is None, the entire buffer is converted. DCNL Note: agg must be a backend_agg.RendererAgg instance.'
def _WX28_clipped_agg_as_bitmap(agg, bbox): DCNL 'Convert the region of a the agg buffer bounded by bbox to a wx.Bitmap. DCNL Note: agg must be a backend_agg.RendererAgg instance.'
def _use_accelerator(state): DCNL 'Enable or disable the WXAgg accelerator, if it is present and is also DCNL compatible with whatever version of wxPython is in use.'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def ishow(): DCNL 'Show all the figures and enter the fltk mainloop in another thread DCNL This allows to keep hand in interractive python session DCNL Warning: does not work under windows DCNL This should be the last line of your script'
def show(): DCNL 'Show all the figures and enter the fltk mainloop DCNL This should be the last line of your script'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def show(): DCNL 'Show all the figures and enter the Cocoa mainloop. DCNL This function will not return until all windows are closed or DCNL the interpreter exits.'
def draw_if_interactive(): DCNL 'For performance reasons, we don\'t want to redraw the figure after DCNL each draw command. Instead, we mark the figure as invalid, so that DCNL it will be redrawn as soon as the event loop resumes via PyOS_InputHook. DCNL This function should be called after each draw event, even if DCNL matplotlib is not running interactively.'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def draw_if_interactive(): DCNL 'Is called after every pylab drawing command'
def _create_qApp(): DCNL 'Only one qApp can exist at a time, so check before creating one.'
def show(): DCNL 'Show all the figures and enter the qt main loop DCNL This should be the last line of your script'
def new_figure_manager(num, *args, **kwargs): DCNL 'Create a new figure manager instance'
def exception_handler(type, value, tb): DCNL 'Handle uncaught exceptions DCNL It does not catch SystemExit'
def strip_math(s): DCNL 'remove latex formatting from mathtext'
def unique(x): DCNL 'Return a list of unique elements of *x*'
def iterable(obj): DCNL 'return true if *obj* is iterable'
def is_string_like(obj): DCNL 'Return True if *obj* looks like a string'
def is_sequence_of_strings(obj): DCNL 'Returns true if *obj* is iterable and contains strings'
def is_writable_file_like(obj): DCNL 'return true if *obj* looks like a file object with a *write* method'
def is_scalar(obj): DCNL 'return true if *obj* is not string like and is not iterable'
def is_numlike(obj): DCNL 'return true if *obj* looks like a number'
def to_filehandle(fname, flag='r', return_opened=False): DCNL '*fname* can be a filename or a file handle.  Support for gzipped DCNL files is automatic, if the filename ends in .gz.  *flag* is a DCNL read/write flag for :func:`file`'
def flatten(seq, scalarp=is_scalar_or_string): DCNL 'this generator flattens nested containers such as DCNL >>> l=( (\'John\', \'Hunter\'), (1,23), [[[[42,(5,23)]]]]) DCNL so that DCNL >>> for i in flatten(l): print i, DCNL John Hunter 1 23 42 5 23 DCNL By: Composite of Holger Krekel and Luther Blissett DCNL From: http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/121294 DCNL and Recipe 1.12 in cookbook'
def soundex(name, len=4): DCNL 'soundex module conforming to Odell-Russell algorithm'
def mkdirs(newdir, mode=511): DCNL 'make directory *newdir* recursively, and set *mode*.  Equivalent to :: DCNL > mkdir -p NEWDIR DCNL > chmod MODE NEWDIR'
def dict_delall(d, keys): DCNL 'delete all of the *keys* from the :class:`dict` *d*'
def get_split_ind(seq, N): DCNL '*seq* is a list of words.  Return the index into seq such that:: DCNL len(\' \'.join(seq[:ind])<=N'
def wrap(prefix, text, cols): DCNL 'wrap *text* with *prefix* at length *cols*'
def dedent(s): DCNL 'Remove excess indentation from docstring *s*. DCNL Discards any leading blank lines, then removes up to n whitespace DCNL characters from each line, where n is the number of leading DCNL whitespace characters in the first line. It differs from DCNL textwrap.dedent in its deletion of leading blank lines and its use DCNL of the first non-blank line to determine the indentation. DCNL It is also faster in most cases.'
def listFiles(root, patterns='*', recurse=1, return_folders=0): DCNL 'Recursively list files DCNL from Parmar and Martelli in the Python Cookbook'
def get_recursive_filelist(args): DCNL 'Recurs all the files and dirs in *args* ignoring symbolic links DCNL and return the files as a list of strings'
def pieces(seq, num=2): DCNL 'Break up the *seq* into *num* tuples'
def allequal(seq): DCNL 'Return *True* if all elements of *seq* compare equal.  If *seq* is DCNL 0 or 1 length, return *True*'
def alltrue(seq): DCNL 'Return *True* if all elements of *seq* evaluate to *True*.  If DCNL *seq* is empty, return *False*.'
def onetrue(seq): DCNL 'Return *True* if one element of *seq* is *True*.  It *seq* is DCNL empty, return *False*.'
def allpairs(x): DCNL 'return all possible pairs in sequence *x* DCNL Condensed by Alex Martelli from this thread_ on c.l.python DCNL .. _thread: http://groups.google.com/groups?q=all+pairs+group:*python*&hl=en&lr=&ie=UTF-8&selm=mailman.4028.1096403649.5135.python-list%40python.org&rnum=1'
def popd(d, *args): DCNL 'Should behave like python2.3 :meth:`dict.pop` method; *d* is a DCNL :class:`dict`:: DCNL # returns value for key and deletes item; raises a KeyError if key DCNL # is not in dict DCNL val = popd(d, key) DCNL # returns value for key if key exists, else default.  Delete key, DCNL # val item if it exists.  Will not raise a KeyError DCNL val = popd(d, key, default)'
def popall(seq): DCNL 'empty a list'
def finddir(o, match, case=False): DCNL 'return all attributes of *o* which match string in match.  if case DCNL is True require an exact case match.'
def reverse_dict(d): DCNL 'reverse the dictionary -- may lose data if values are not unique!'
def report_memory(i=0): DCNL 'return the memory consumed by process'
def safezip(*args): DCNL 'make sure *args* are equal len before zipping'
def issubclass_safe(x, klass): DCNL 'return issubclass(x, klass) and return False on a TypeError'
def print_cycles(objects, outstream=sys.stdout, show_progress=False): DCNL '*objects* DCNL A list of objects to find cycles in.  It is often useful to DCNL pass in gc.garbage to find the cycles that are preventing some DCNL objects from being garbage collected. DCNL *outstream* DCNL The stream for output. DCNL *show_progress* DCNL If True, print the number of objects reached as they are found.'
def delete_masked_points(*args): DCNL 'Find all masked and/or non-finite points in a set of arguments, DCNL and return the arguments with only the unmasked points remaining. DCNL Arguments can be in any of 5 categories: DCNL 1) 1-D masked arrays DCNL 2) 1-D ndarrays DCNL 3) ndarrays with more than one dimension DCNL 4) other non-string iterables DCNL 5) anything else DCNL The first argument must be in one of the first four categories; DCNL any argument with a length differing from that of the first DCNL argument (and hence anything in category 5) then will be DCNL passed through unchanged. DCNL Masks are obtained from all arguments of the correct length DCNL in categories 1, 2, and 4; a point is bad if masked in a masked DCNL array or if it is a nan or inf.  No attempt is made to DCNL extract a mask from categories 2, 3, and 4 if :meth:`np.isfinite` DCNL does not yield a Boolean array. DCNL All input arguments that are not passed unchanged are returned DCNL as ndarrays after removing the points or rows corresponding to DCNL masks in any of the arguments. DCNL A vastly simpler version of this function was originally DCNL written as a helper for Axes.scatter().'
def unmasked_index_ranges(mask, compressed=True): DCNL 'Find index ranges where *mask* is *False*. DCNL *mask* will be flattened if it is not already 1-D. DCNL Returns Nx2 :class:`numpy.ndarray` with each row the start and stop DCNL indices for slices of the compressed :class:`numpy.ndarray` DCNL corresponding to each of *N* uninterrupted runs of unmasked DCNL values.  If optional argument *compressed* is *False*, it returns DCNL the start and stop indices into the original :class:`numpy.ndarray`, DCNL not the compressed :class:`numpy.ndarray`.  Returns *None* if there DCNL are no unmasked values. DCNL Example:: DCNL y = ma.array(np.arange(5), mask = [0,0,1,0,0]) DCNL ii = unmasked_index_ranges(ma.getmaskarray(y)) DCNL # returns array [[0,2,] [2,4,]] DCNL y.compressed()[ii[1,0]:ii[1,1]] DCNL # returns array [3,4,] DCNL ii = unmasked_index_ranges(ma.getmaskarray(y), compressed=False) DCNL # returns array [[0, 2], [3, 5]] DCNL y.filled()[ii[1,0]:ii[1,1]] DCNL # returns array [3,4,] DCNL Prior to the transforms refactoring, this was used to support DCNL masked arrays in Line2D.'
def less_simple_linear_interpolation(x, y, xi, extrap=False): DCNL 'This function has been moved to matplotlib.mlab -- please import DCNL it from there'
def isvector(X): DCNL 'This function has been moved to matplotlib.mlab -- please import DCNL it from there'
def vector_lengths(X, P=2.0, axis=None): DCNL 'This function has been moved to matplotlib.mlab -- please import DCNL it from there'
def distances_along_curve(X): DCNL 'This function has been moved to matplotlib.mlab -- please import DCNL it from there'
def path_length(X): DCNL 'This function has been moved to matplotlib.mlab -- please import DCNL it from there'
def is_closed_polygon(X): DCNL 'This function has been moved to matplotlib.mlab -- please import DCNL it from there'
def quad2cubic(q0x, q0y, q1x, q1y, q2x, q2y): DCNL 'This function has been moved to matplotlib.mlab -- please import DCNL it from there'
def _import_fail_message(module, version): DCNL 'Prints a message when the array package specific version of an extension DCNL fails to import correctly.'
def isnan(a): DCNL 'y = isnan(x) returns True where x is Not-A-Number'
def all(a, axis=None): DCNL 'Numpy-compatible version of all()'
def all(a, axis=None): DCNL 'Numpy-compatible version of all()'
def Matrix(data, typecode=None, copy=1, savespace=0): DCNL 'Matrix constructs new matrices from 2D nested lists of numbers'
def _mask_non_positives(a): DCNL 'Return a Numpy masked array where all non-positive values are DCNL masked.  If there are no non-positive values, the original array DCNL is returned.'
def scale_factory(scale, axis, **kwargs): DCNL 'Return a scale class by name. DCNL ACCEPTS: [ %(names)s ]'
def register_scale(scale_class): DCNL 'Register a new kind of scale. DCNL *scale_class* must be a subclass of :class:`ScaleBase`.'
def get_scale_docs(): DCNL 'Helper function for generating docstrings related to scales.'
def _is_writable_dir(p): DCNL 'p is a string pointing to a putative writable dir -- return True p DCNL is such a string, else False'
def compare_versions(a, b): DCNL 'return True if a is greater than or equal to b'
def _get_home(): DCNL 'Find user\'s home directory if possible. DCNL Otherwise raise error. DCNL :see:  http://mail.python.org/pipermail/python-list/2005-February/263921.html'
def _get_configdir(): DCNL 'Return the string representing the configuration dir. DCNL default is HOME/.matplotlib.  you can override this with the DCNL MPLCONFIGDIR environment variable'
def _get_data_path(): DCNL 'get the path to matplotlib data'
def get_example_data(fname): DCNL 'return a filehandle to one of the example files in mpl-data/example DCNL *fname* DCNL the name of one of the files in mpl-data/example'
def matplotlib_fname(): DCNL 'Return the path to the rc file DCNL Search order: DCNL * current working dir DCNL * environ var MATPLOTLIBRC DCNL * HOME/.matplotlib/matplotlibrc DCNL * MATPLOTLIBDATA/matplotlibrc'
def rc_params(fail_on_error=False): DCNL 'Return the default params updated from the values in the rc file'
def rc(group, **kwargs): DCNL 'Set the current rc params.  Group is the grouping for the rc, eg. DCNL for ``lines.linewidth`` the group is ``lines``, for DCNL ``axes.facecolor``, the group is ``axes``, and so on.  Group may DCNL also be a list or tuple of group names, eg. (*xtick*, *ytick*). DCNL *kwargs* is a dictionary attribute name/value pairs, eg:: DCNL rc(\'lines\', linewidth=2, color=\'r\') DCNL sets the current rc params and is equivalent to:: DCNL rcParams[\'lines.linewidth\'] = 2 DCNL rcParams[\'lines.color\'] = \'r\' DCNL The following aliases are available to save typing for interactive DCNL users: DCNL Alias   Property DCNL \'lw\'    \'linewidth\' DCNL \'ls\'    \'linestyle\' DCNL \'c\'     \'color\' DCNL \'fc\'    \'facecolor\' DCNL \'ec\'    \'edgecolor\' DCNL \'mew\'   \'markeredgewidth\' DCNL \'aa\'    \'antialiased\' DCNL Thus you could abbreviate the above rc command as:: DCNL rc(\'lines\', lw=2, c=\'r\') DCNL Note you can use python\'s kwargs dictionary facility to store DCNL dictionaries of default parameters.  Eg, you can customize the DCNL font rc as follows:: DCNL font = {\'family\' : \'monospace\', DCNL \'weight\' : \'bold\', DCNL \'size\'   : \'larger\'} DCNL rc(\'font\', **font)  # pass in the font dict as kwargs DCNL This enables you to easily switch between several configurations. DCNL Use :func:`~matplotlib.pyplot.rcdefaults` to restore the default DCNL rc params after changes.'
def rcdefaults(): DCNL 'Restore the default rc params - the ones that were created at DCNL matplotlib load time.'
def use(arg, warn=True): DCNL 'Set the matplotlib backend to one of the known backends. DCNL The argument is case-insensitive.  For the Cairo backend, DCNL the argument can have an extension to indicate the type of DCNL output.  Example: DCNL use(\'cairo.pdf\') DCNL will specify a default of pdf output generated by Cairo. DCNL Note: this function must be called *before* importing pylab for DCNL the first time; or, if you are not using pylab, it must be called DCNL before importing matplotlib.backends.  If warn is True, a warning DCNL is issued if you try and callthis after pylab or pyplot have been DCNL loaded.  In certain black magic use cases, eg DCNL pyplot.switch_backends, we are doing the reloading necessary to DCNL make the backend switch work (in some cases, eg pure image DCNL backends) so one can set warn=False to supporess the warnings'
def get_backend(): DCNL 'Returns the current backend'
def interactive(b): DCNL 'Set interactive mode to boolean b. DCNL If b is True, then draw after every plotting command, eg, after xlabel'
def is_interactive(): DCNL 'Return true if plot mode is interactive'
def tk_window_focus(): DCNL 'Return true if focus maintenance under TkAgg on win32 is on. DCNL This currently works only for python.exe and IPython.exe. DCNL Both IDLE and Pythonwin.exe fail badly when tk_window_focus is on.'
def get_intersection(cx1, cy1, cos_t1, sin_t1, cx2, cy2, cos_t2, sin_t2): DCNL 'return a intersecting point between a line through (cx1, cy1) DCNL and having angle t1 and a line through (cx2, cy2) and angle t2.'
def get_normal_points(cx, cy, cos_t, sin_t, length): DCNL 'For a line passing through (*cx*, *cy*) and having a angle *t*, DCNL return locations of the two points located along its perpendicular line at the distance of *length*.'
def split_de_casteljau(beta, t): DCNL 'split a bezier segment defined by its controlpoints *beta* DCNL into two separate segment divided at *t* and return their control points.'
def find_bezier_t_intersecting_with_closedpath(bezier_point_at_t, inside_closedpath, t0=0.0, t1=1.0, tolerence=0.01): DCNL 'Find a parameter t0 and t1 of the given bezier path which DCNL bounds the intersecting points with a provided closed DCNL path(*inside_closedpath*). Search starts from *t0* and *t1* and it DCNL uses a simple bisecting algorithm therefore one of the end point DCNL must be inside the path while the orther doesn\'t. The search stop DCNL when |t0-t1| gets smaller than the given tolerence. DCNL value for DCNL - bezier_point_at_t : a function which returns x, y coordinates at *t* DCNL - inside_closedpath : return True if the point is insed the path'
def split_bezier_intersecting_with_closedpath(bezier, inside_closedpath, tolerence=0.01): DCNL 'bezier : control points of the bezier segment DCNL inside_closedpath : a function which returns true if the point is inside the path'
def find_r_to_boundary_of_closedpath(inside_closedpath, xy, cos_t, sin_t, rmin=0.0, rmax=1.0, tolerence=0.01): DCNL 'Find a radius r (centered at *xy*) between *rmin* and *rmax* at DCNL which it intersect with the path. DCNL inside_closedpath : function DCNL cx, cy : center DCNL cos_t, sin_t : cosine and sine for the angle DCNL rmin, rmax :'
def split_path_inout(path, inside, tolerence=0.01, reorder_inout=False): DCNL 'divide a path into two segment at the point where inside(x, y) DCNL becomes False.'
def get_parallels(bezier2, width): DCNL 'Given the quadraitc bezier control points *bezier2*, returns DCNL control points of quadrativ bezier lines roughly parralel to given DCNL one separated by *width*.'
def make_wedged_bezier2(bezier2, length, shrink_factor=0.5): DCNL 'Being similar to get_parallels, returns DCNL control points of two quadrativ bezier lines having a width roughly parralel to given DCNL one separated by *width*.'
def find_control_points(c1x, c1y, mmx, mmy, c2x, c2y): DCNL 'Find control points of the bezier line throught c1, mm, c2. We DCNL simply assume that c1, mm, c2 which have parameteric value 0, 0.5, and 1.'
def make_wedged_bezier2(bezier2, width, w1=1.0, wm=0.5, w2=0.0): DCNL 'Being similar to get_parallels, returns DCNL control points of two quadrativ bezier lines having a width roughly parralel to given DCNL one separated by *width*.'
def get_path_collection_extents(*args): DCNL 'Given a sequence of :class:`Path` objects, returns the bounding DCNL box that encapsulates all of them.'
def get_unicode_index(symbol): DCNL 'get_unicode_index(symbol) -> integer DCNL Return the integer index (from the Unicode table) of symbol.  *symbol* DCNL can be a single unicode character, a TeX command (i.e. r\'\pi\'), or a DCNL Type1 symbol name (i.e. \'phi\').'
def MathtextBackendBitmap(): DCNL 'A backend to generate standalone mathtext images.  No additional DCNL matplotlib backend is required.'
def Error(msg): DCNL 'Helper class to raise parser errors.'
def is_color_like(c): DCNL 'Return *True* if *c* can be converted to *RGB*'
def rgb2hex(rgb): DCNL 'Given a len 3 rgb tuple of 0-1 floats, return the hex string'
def hex2color(s): DCNL 'Take a hex string *s* and return the corresponding rgb 3-tuple DCNL Example: #efefef -> (0.93725, 0.93725, 0.93725)'
def makeMappingArray(N, data): DCNL 'Create an *N* -element 1-d lookup table DCNL *data* represented by a list of x,y0,y1 mapping correspondences. DCNL Each element in this list represents how a value between 0 and 1 DCNL (inclusive) represented by x is mapped to a corresponding value DCNL between 0 and 1 (inclusive). The two values of y are to allow DCNL for discontinuous mapping functions (say as might be found in a DCNL sawtooth) where y0 represents the value of y for values of x DCNL <= to that given, and y1 is the value to be used for x > than DCNL that given). The list must start with x=0, end with x=1, and DCNL all values of x must be in increasing order. Values between DCNL the given mapping points are determined by simple linear interpolation. DCNL The function returns an array "result" where ``result[x*(N-1)]`` DCNL gives the closest value for values of x between 0 and 1.'
def get_cmap(name=None, lut=None): DCNL 'Get a colormap instance, defaulting to rc values if *name* is None'
def validate_path_exists(s): DCNL 'If s is a path, return s, else False'
def validate_bool(b): DCNL 'Convert b to a boolean or raise'
def validate_bool_maybe_none(b): DCNL 'Convert b to a boolean or raise'
def validate_float(s): DCNL 'convert s to float or raise'
def validate_int(s): DCNL 'convert s to int or raise'
def validate_fonttype(s): DCNL 'confirm that this is a Postscript of PDF font type that we know how to convert to'
def validate_color(s): DCNL 'return a valid color arg'
def validate_stringlist(s): DCNL 'return a list'
def get_projection_class(projection=None): DCNL 'Get a projection class from its name. DCNL If *projection* is None, a standard rectilinear projection is DCNL returned.'
def projection_factory(projection, figure, rect, **kwargs): DCNL 'Get a new projection instance. DCNL *projection* is a projection name. DCNL *figure* is a figure to add the axes to. DCNL *rect* is a :class:`~matplotlib.transforms.Bbox` object specifying DCNL the location of the axes within the figure. DCNL Any other kwargs are passed along to the specific projection DCNL constructor being used.'
def get_projection_names(): DCNL 'Get a list of acceptable projection names.'
def figaspect(arg): DCNL 'Create a figure with specified aspect ratio.  If *arg* is a number, DCNL use that aspect ratio.  If *arg* is an array, figaspect will DCNL determine the width and height for a figure that would fit array DCNL preserving aspect ratio.  The figure width, height in inches are DCNL returned.  Be sure to create an axes with equal with and height, DCNL eg DCNL Example usage:: DCNL # make a figure twice as tall as it is wide DCNL w, h = figaspect(2.) DCNL fig = Figure(figsize=(w,h)) DCNL ax = fig.add_axes([0.1, 0.1, 0.8, 0.8]) DCNL ax.imshow(A, **kwargs) DCNL # make a figure with the proper aspect for an array DCNL A = rand(5,3) DCNL w, h = figaspect(A) DCNL fig = Figure(figsize=(w,h)) DCNL ax = fig.add_axes([0.1, 0.1, 0.8, 0.8]) DCNL ax.imshow(A, **kwargs) DCNL Thanks to Fernando Perez for this function'
def _backend_selection(): DCNL 'If rcParams[\'backend_fallback\'] is true, check to see if the DCNL current backend is compatible with the current running event DCNL loop, and if not switches to a compatible one.'
def switch_backend(newbackend): DCNL 'Switch the default backend to newbackend.  This feature is DCNL **experimental**, and is only expected to work switching to an DCNL image backend.  Eg, if you have a bunch of PostScript scripts that DCNL you want to run from an interactive ipython session, you may want DCNL to switch to the PS backend before running them to avoid having a DCNL bunch of GUI windows popup.  If you try to interactively switch DCNL from one GUI backend to another, you will explode. DCNL Calling this command will close all open windows.'
def isinteractive(): DCNL 'Return the interactive status'
def ioff(): DCNL 'Turn interactive mode off.'
def ion(): DCNL 'Turn interactive mode on.'
def gci(): DCNL 'Get the current :class:`~matplotlib.cm.ScalarMappable` instance DCNL (image or patch collection), or *None* if no images or patch DCNL collections have been defined.  The commands DCNL :func:`~matplotlib.pyplot.imshow` and DCNL :func:`~matplotlib.pyplot.figimage` create DCNL :class:`~matplotlib.image.Image` instances, and the commands DCNL :func:`~matplotlib.pyplot.pcolor` and DCNL :func:`~matplotlib.pyplot.scatter` create DCNL :class:`~matplotlib.collections.Collection` instances.'
def sci(im): DCNL 'Set the current image (target of colormap commands like DCNL :func:`~matplotlib.pyplot.jet`, :func:`~matplotlib.pyplot.hot` or DCNL :func:`~matplotlib.pyplot.clim`).'
def figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=Figure, **kwargs): DCNL 'call signature:: DCNL figure(num=None, figsize=(8, 6), dpi=80, facecolor=\'w\', edgecolor=\'k\') DCNL Create a new figure and return a :class:`matplotlib.figure.Figure` DCNL instance.  If *num* = *None*, the figure number will be incremented and DCNL a new figure will be created.  The returned figure objects have a DCNL *number* attribute holding this number. DCNL If *num* is an integer, and ``figure(num)`` already exists, make it DCNL active and return the handle to it.  If ``figure(num)`` does not exist DCNL it will be created.  Numbering starts at 1, matlab style:: DCNL figure(1) DCNL If you are creating many figures, make sure you explicitly call "close" DCNL on the figures you are not using, because this will enable pylab DCNL to properly clean up the memory. DCNL Optional keyword arguments: DCNL Keyword     Description DCNL figsize     width x height in inches; defaults to rc figure.figsize DCNL dpi         resolution; defaults to rc figure.dpi DCNL facecolor   the background color; defaults to rc figure.facecolor DCNL edgecolor   the border color; defaults to rc figure.edgecolor DCNL rcParams defines the default values, which can be modified in the DCNL matplotlibrc file DCNL *FigureClass* is a :class:`~matplotlib.figure.Figure` or derived DCNL class that will be passed on to :meth:`new_figure_manager` in the DCNL backends which allows you to hook custom Figure classes into the DCNL pylab interface.  Additional kwargs will be passed on to your DCNL figure init function.'
def gcf(): DCNL 'Return a handle to the current figure.'
def close(*args): DCNL 'Close a figure window DCNL ``close()`` by itself closes the current figure DCNL ``close(num)`` closes figure number *num* DCNL ``close(h)`` where *h* is a :class:`Figure` instance, closes that figure DCNL ``close(\'all\')`` closes all the figure windows'
def clf(): DCNL 'Clear the current figure'
def draw(): DCNL 'redraw the current figure'
def ginput(*args, **kwargs): DCNL 'Blocking call to interact with the figure. DCNL This will wait for *n* clicks from the user and return a list of the DCNL coordinates of each click. DCNL If *timeout* is negative, does not timeout.'
def waitforbuttonpress(*args, **kwargs): DCNL 'Blocking call to interact with the figure. DCNL This will wait for *n* key or mouse clicks from the user and DCNL return a list containing True\'s for keyboard clicks and False\'s DCNL for mouse clicks. DCNL If *timeout* is negative, does not timeout.'
def figlegend(handles, labels, loc, **kwargs): DCNL 'Place a legend in the figure. DCNL *labels* DCNL a sequence of strings DCNL *handles* DCNL a sequence of :class:`~matplotlib.lines.Line2D` or DCNL :class:`~matplotlib.patches.Patch` instances DCNL *loc* DCNL can be a string or an integer specifying the legend DCNL location DCNL A :class:`matplotlib.legend.Legend` instance is returned. DCNL Example:: DCNL figlegend( (line1, line2, line3), DCNL (\'label1\', \'label2\', \'label3\'), DCNL \'upper right\' ) DCNL .. seealso:: DCNL :func:`~matplotlib.pyplot.legend`: DCNL For information about the location codes'
def hold(b=None): DCNL 'Set the hold state.  If *b* is None (default), toggle the DCNL hold state, else set the hold state to boolean value *b*:: DCNL hold()      # toggle hold DCNL hold(True)  # hold is on DCNL hold(False) # hold is off DCNL When *hold* is *True*, subsequent plot commands will be added to DCNL the current axes.  When *hold* is *False*, the current axes and DCNL figure will be cleared on the next plot command.'
def ishold(): DCNL 'Return the hold status of the current axes'
def over(func, *args, **kwargs): DCNL 'over calls:: DCNL func(*args, **kwargs) DCNL with ``hold(True)`` and then restores the hold state.'
def axes(*args, **kwargs): DCNL 'Add an axes at position rect specified by: DCNL - ``axes()`` by itself creates a default full ``subplot(111)`` window axis. DCNL - ``axes(rect, axisbg=\'w\')`` where *rect* = [left, bottom, width, DCNL height] in normalized (0, 1) units.  *axisbg* is the background DCNL color for the axis, default white. DCNL - ``axes(h)`` where *h* is an axes instance makes *h* the current DCNL axis.  An :class:`~matplotlib.axes.Axes` instance is returned. DCNL kwarg     Accepts        Desctiption DCNL axisbg    color          the axes background color DCNL frameon   [True|False]   display the frame? DCNL sharex    otherax        current axes shares xaxis attribute with otherax DCNL sharey    otherax        current axes shares yaxis attribute with otherax DCNL polar     [True|False]   use a polar axes? DCNL Examples: DCNL * :file:`examples/pylab_examples/axes_demo.py` places custom axes. DCNL * :file:`examples/pylab_examples/shared_axis_demo.py` uses DCNL *sharex* and *sharey*.'
def delaxes(*args): DCNL '``delaxes(ax)``: remove *ax* from the current figure.  If *ax* DCNL doesn\'t exist, an error will be raised. DCNL ``delaxes()``: delete the current axes'
def gca(**kwargs): DCNL 'Return the current axis instance.  This can be used to control DCNL axis properties either using set or the DCNL :class:`~matplotlib.axes.Axes` methods, for example, setting the DCNL xaxis range:: DCNL plot(t,s) DCNL set(gca(), \'xlim\', [0,10]) DCNL or:: DCNL plot(t,s) DCNL a = gca() DCNL a.set_xlim([0,10])'
def subplot(*args, **kwargs): DCNL 'Create a subplot command, creating axes with:: DCNL subplot(numRows, numCols, plotNum) DCNL where *plotNum* = 1 is the first plot number and increasing *plotNums* DCNL fill rows first.  max(*plotNum*) == *numRows* * *numCols* DCNL You can leave out the commas if *numRows* <= *numCols* <= DCNL *plotNum* < 10, as in:: DCNL subplot(211)    # 2 rows, 1 column, first (upper) plot DCNL ``subplot(111)`` is the default axis. DCNL New subplots that overlap old will delete the old axes.  If you do DCNL not want this behavior, use DCNL :meth:`matplotlib.figure.Figure.add_subplot` or the DCNL :func:`~matplotlib.pyplot.axes` command.  Eg.:: DCNL from pylab import * DCNL plot([1,2,3])  # implicitly creates subplot(111) DCNL subplot(211)   # overlaps, subplot(111) is killed DCNL plot(rand(12), rand(12)) DCNL subplot(212, axisbg=\'y\') # creates 2nd subplot with yellow background DCNL Keyword arguments: DCNL *axisbg*: DCNL The background color of the subplot, which can be any valid DCNL color specifier.  See :mod:`matplotlib.colors` for more DCNL information. DCNL *polar*: DCNL A boolean flag indicating whether the subplot plot should be DCNL a polar projection.  Defaults to False. DCNL *projection*: DCNL A string giving the name of a custom projection to be used DCNL for the subplot. This projection must have been previously DCNL registered. See :func:`matplotlib.projections.register_projection` DCNL .. seealso:: DCNL :func:`~matplotlib.pyplot.axes`: DCNL For additional information on :func:`axes` and DCNL :func:`subplot` keyword arguments. DCNL :file:`examples/pylab_examples/polar_scatter.py` DCNL **Example:** DCNL .. plot:: mpl_examples/pylab_examples/subplot_demo.py'
def twinx(ax=None): DCNL 'Make a second axes overlay *ax* (or the current axes if *ax* is DCNL *None*) sharing the xaxis.  The ticks for *ax2* will be placed on DCNL the right, and the *ax2* instance is returned. DCNL .. seealso:: DCNL :file:`examples/api_examples/two_scales.py`'
def twiny(ax=None): DCNL 'Make a second axes overlay *ax* (or the current axes if *ax* is DCNL *None*) sharing the yaxis.  The ticks for *ax2* will be placed on DCNL the top, and the *ax2* instance is returned.'
def subplots_adjust(*args, **kwargs): DCNL 'call signature:: DCNL subplots_adjust(left=None, bottom=None, right=None, top=None, DCNL wspace=None, hspace=None) DCNL Tune the subplot layout via the DCNL :class:`matplotlib.figure.SubplotParams` mechanism.  The parameter DCNL meanings (and suggested defaults) are:: DCNL left  = 0.125  # the left side of the subplots of the figure DCNL right = 0.9    # the right side of the subplots of the figure DCNL bottom = 0.1   # the bottom of the subplots of the figure DCNL top = 0.9      # the top of the subplots of the figure DCNL wspace = 0.2   # the amount of width reserved for blank space between subplots DCNL hspace = 0.2   # the amount of height reserved for white space between subplots DCNL The actual defaults are controlled by the rc file'
def subplot_tool(targetfig=None): DCNL 'Launch a subplot tool window for *targetfig* (default gcf). DCNL A :class:`matplotlib.widgets.SubplotTool` instance is returned.'
def box(on=None): DCNL 'Turn the axes box on or off according to *on*. DCNL If *on* is *None*, toggle state.'
def title(s, *args, **kwargs): DCNL 'Set the title of the current axis to *s*. DCNL Default font override is:: DCNL override = {\'fontsize\': \'medium\', DCNL \'verticalalignment\': \'bottom\', DCNL \'horizontalalignment\': \'center\'} DCNL .. seealso:: DCNL :func:`~matplotlib.pyplot.text`: DCNL for information on how override and the optional args work.'
def axis(*v, **kwargs): DCNL 'Set/Get the axis properties: DCNL >>> axis() DCNL returns the current axes limits ``[xmin, xmax, ymin, ymax]``. DCNL >>> axis(v) DCNL sets the min and max of the x and y axes, with DCNL ``v = [xmin, xmax, ymin, ymax]``. DCNL >>> axis(\'off\') DCNL turns off the axis lines and labels. DCNL >>> axis(\'equal\') DCNL changes limits of *x* or *y* axis so that equal increments of *x* DCNL and *y* have the same length; a circle is circular. DCNL >>> axis(\'scaled\') DCNL achieves the same result by changing the dimensions of the plot box instead DCNL of the axis data limits. DCNL >>> axis(\'tight\') DCNL changes *x* and *y* axis limits such that all data is shown. If DCNL all data is already shown, it will move it to the center of the DCNL figure without modifying (*xmax* - *xmin*) or (*ymax* - DCNL *ymin*). Note this is slightly different than in matlab. DCNL >>> axis(\'image\') DCNL is \'scaled\' with the axis limits equal to the data limits. DCNL >>> axis(\'auto\') DCNL and DCNL >>> axis(\'normal\') DCNL are deprecated. They restore default behavior; axis limits are automatically DCNL scaled to make the data fit comfortably within the plot box. DCNL if ``len(*v)==0``, you can pass in *xmin*, *xmax*, *ymin*, *ymax* DCNL as kwargs selectively to alter just those limits without changing DCNL the others. DCNL The xmin, xmax, ymin, ymax tuple is returned DCNL .. seealso:: DCNL :func:`xlim`, :func:`ylim`'
def xlabel(s, *args, **kwargs): DCNL 'Set the *x* axis label of the current axis to *s* DCNL Default override is:: DCNL override = { DCNL \'fontsize\'            : \'small\', DCNL \'verticalalignment\'   : \'top\', DCNL \'horizontalalignment\' : \'center\' DCNL .. seealso:: DCNL :func:`~matplotlib.pyplot.text`: DCNL For information on how override and the optional args work'
def ylabel(s, *args, **kwargs): DCNL 'Set the *y* axis label of the current axis to *s*. DCNL Defaults override is:: DCNL override = { DCNL \'fontsize\'            : \'small\', DCNL \'verticalalignment\'   : \'center\', DCNL \'horizontalalignment\' : \'right\', DCNL \'rotation\'=\'vertical\' : } DCNL .. seealso:: DCNL :func:`~matplotlib.pyplot.text`: DCNL For information on how override and the optional args DCNL work.'
def xlim(*args, **kwargs): DCNL 'Set/Get the xlimits of the current axes:: DCNL xmin, xmax = xlim()   # return the current xlim DCNL xlim( (xmin, xmax) )  # set the xlim to xmin, xmax DCNL xlim( xmin, xmax )    # set the xlim to xmin, xmax DCNL If you do not specify args, you can pass the xmin and xmax as DCNL kwargs, eg.:: DCNL xlim(xmax=3) # adjust the max leaving min unchanged DCNL xlim(xmin=1) # adjust the min leaving max unchanged DCNL The new axis limits are returned as a length 2 tuple.'
def ylim(*args, **kwargs): DCNL 'Set/Get the ylimits of the current axes:: DCNL ymin, ymax = ylim()   # return the current ylim DCNL ylim( (ymin, ymax) )  # set the ylim to ymin, ymax DCNL ylim( ymin, ymax )    # set the ylim to ymin, ymax DCNL If you do not specify args, you can pass the *ymin* and *ymax* as DCNL kwargs, eg.:: DCNL ylim(ymax=3) # adjust the max leaving min unchanged DCNL ylim(ymin=1) # adjust the min leaving max unchanged DCNL The new axis limits are returned as a length 2 tuple.'
def xscale(*args, **kwargs): DCNL 'call signature:: DCNL xscale(scale, **kwargs) DCNL Set the scaling for the x-axis: %(scale)s DCNL Different keywords may be accepted, depending on the scale: DCNL %(scale_docs)s'
def yscale(*args, **kwargs): DCNL 'call signature:: DCNL xscale(scale, **kwargs) DCNL Set the scaling for the y-axis: %(scale)s DCNL Different keywords may be accepted, depending on the scale: DCNL %(scale_docs)s'
def xticks(*args, **kwargs): DCNL 'Set/Get the xlimits of the current ticklocs and labels:: DCNL # return locs, labels where locs is an array of tick locations and DCNL # labels is an array of tick labels. DCNL locs, labels = xticks() DCNL # set the locations of the xticks DCNL xticks( arange(6) ) DCNL # set the locations and labels of the xticks DCNL xticks( arange(5), (\'Tom\', \'Dick\', \'Harry\', \'Sally\', \'Sue\') ) DCNL The keyword args, if any, are :class:`~matplotlib.text.Text` DCNL properties.'
def yticks(*args, **kwargs): DCNL 'Set/Get the ylimits of the current ticklocs and labels:: DCNL # return locs, labels where locs is an array of tick locations and DCNL # labels is an array of tick labels. DCNL locs, labels = yticks() DCNL # set the locations of the yticks DCNL yticks( arange(6) ) DCNL # set the locations and labels of the yticks DCNL yticks( arange(5), (\'Tom\', \'Dick\', \'Harry\', \'Sally\', \'Sue\') ) DCNL The keyword args, if any, are :class:`~matplotlib.text.Text` DCNL properties.'
def rgrids(*args, **kwargs): DCNL 'Set/Get the radial locations of the gridlines and ticklabels on a DCNL polar plot. DCNL call signatures:: DCNL lines, labels = rgrids() DCNL lines, labels = rgrids(radii, labels=None, angle=22.5, **kwargs) DCNL When called with no arguments, :func:`rgrid` simply returns the DCNL tuple (*lines*, *labels*), where *lines* is an array of radial DCNL gridlines (:class:`~matplotlib.lines.Line2D` instances) and DCNL *labels* is an array of tick labels DCNL (:class:`~matplotlib.text.Text` instances). When called with DCNL arguments, the labels will appear at the specified radial DCNL distances and angles. DCNL *labels*, if not *None*, is a len(*radii*) list of strings of the DCNL labels to use at each angle. DCNL If *labels* is None, the rformatter will be used DCNL Examples:: DCNL # set the locations of the radial gridlines and labels DCNL lines, labels = rgrids( (0.25, 0.5, 1.0) ) DCNL # set the locations and labels of the radial gridlines and labels DCNL lines, labels = rgrids( (0.25, 0.5, 1.0), (\'Tom\', \'Dick\', \'Harry\' )'
def thetagrids(*args, **kwargs): DCNL 'Set/Get the theta locations of the gridlines and ticklabels. DCNL If no arguments are passed, return a tuple (*lines*, *labels*) DCNL where *lines* is an array of radial gridlines DCNL (:class:`~matplotlib.lines.Line2D` instances) and *labels* is an DCNL array of tick labels (:class:`~matplotlib.text.Text` instances):: DCNL lines, labels = thetagrids() DCNL Otherwise the syntax is:: DCNL lines, labels = thetagrids(angles, labels=None, fmt=\'%d\', frac = 1.1) DCNL set the angles at which to place the theta grids (these gridlines DCNL are equal along the theta dimension). DCNL *angles* is in degrees. DCNL *labels*, if not *None*, is a len(angles) list of strings of the DCNL labels to use at each angle. DCNL If *labels* is *None*, the labels will be ``fmt%angle``. DCNL *frac* is the fraction of the polar axes radius at which to place DCNL the label (1 is the edge). Eg. 1.05 is outside the axes and 0.95 DCNL is inside the axes. DCNL Return value is a list of tuples (*lines*, *labels*): DCNL - *lines* are :class:`~matplotlib.lines.Line2D` instances DCNL - *labels* are :class:`~matplotlib.text.Text` instances. DCNL Note that on input, the *labels* argument is a list of strings, DCNL and on output it is a list of :class:`~matplotlib.text.Text` DCNL instances. DCNL Examples:: DCNL # set the locations of the radial gridlines and labels DCNL lines, labels = thetagrids( range(45,360,90) ) DCNL # set the locations and labels of the radial gridlines and labels DCNL lines, labels = thetagrids( range(45,360,90), (\'NE\', \'NW\', \'SW\',\'SE\') )'
def plotting(): DCNL 'Plotting commands DCNL Command         Description DCNL axes            Create a new axes DCNL axis            Set or return the current axis limits DCNL bar             make a bar chart DCNL boxplot         make a box and whiskers chart DCNL cla             clear current axes DCNL clabel          label a contour plot DCNL clf             clear a figure window DCNL close           close a figure window DCNL colorbar        add a colorbar to the current figure DCNL cohere          make a plot of coherence DCNL contour         make a contour plot DCNL contourf        make a filled contour plot DCNL csd             make a plot of cross spectral density DCNL draw            force a redraw of the current figure DCNL errorbar        make an errorbar graph DCNL figlegend       add a legend to the figure DCNL figimage        add an image to the figure, w/o resampling DCNL figtext         add text in figure coords DCNL figure          create or change active figure DCNL fill            make filled polygons DCNL fill_between    make filled polygons DCNL gca             return the current axes DCNL gcf             return the current figure DCNL gci             get the current image, or None DCNL getp            get a handle graphics property DCNL hist            make a histogram DCNL hold            set the hold state on current axes DCNL legend          add a legend to the axes DCNL loglog          a log log plot DCNL imread          load image file into array DCNL imshow          plot image data DCNL matshow         display a matrix in a new figure preserving aspect DCNL pcolor          make a pseudocolor plot DCNL plot            make a line plot DCNL plotfile        plot data from a flat file DCNL psd             make a plot of power spectral density DCNL quiver          make a direction field (arrows) plot DCNL rc              control the default params DCNL savefig         save the current figure DCNL scatter         make a scatter plot DCNL setp            set a handle graphics property DCNL semilogx        log x axis DCNL semilogy        log y axis DCNL show            show the figures DCNL specgram        a spectrogram plot DCNL stem            make a stem plot DCNL subplot         make a subplot (numrows, numcols, axesnum) DCNL table           add a table to the axes DCNL text            add some text at location x,y to the current axes DCNL title           add a title to the current axes DCNL xlabel          add an xlabel to the current axes DCNL ylabel          add a ylabel to the current axes DCNL The following commands will set the default colormap accordingly: DCNL * autumn DCNL * bone DCNL * cool DCNL * copper DCNL * flag DCNL * gray DCNL * hot DCNL * hsv DCNL * jet DCNL * pink DCNL * prism DCNL * spring DCNL * summer DCNL * winter DCNL * spectral'
def colors(): DCNL 'This is a do nothing function to provide you with help on how DCNL matplotlib handles colors. DCNL Commands which take color arguments can use several formats to DCNL specify the colors.  For the basic builtin colors, you can use a DCNL single letter DCNL Alias   Color DCNL \'b\'     blue DCNL \'g\'     green DCNL \'r\'     red DCNL \'c\'     cyan DCNL \'m\'     magenta DCNL \'y\'     yellow DCNL \'k\'     black DCNL \'w\'     white DCNL For a greater range of colors, you have two options.  You can DCNL specify the color using an html hex string, as in:: DCNL color = \'#eeefff\' DCNL or you can pass an R,G,B tuple, where each of R,G,B are in the DCNL range [0,1]. DCNL You can also use any legal html name for a color, for example:: DCNL color = \'red\', DCNL color = \'burlywood\' DCNL color = \'chartreuse\' DCNL The example below creates a subplot with a dark DCNL slate gray background DCNL subplot(111, axisbg=(0.1843, 0.3098, 0.3098)) DCNL Here is an example that creates a pale turqoise title:: DCNL title(\'Is this the best color?\', color=\'#afeeee\')'
def colormaps(): DCNL 'matplotlib provides the following colormaps. DCNL * autumn DCNL * bone DCNL * cool DCNL * copper DCNL * flag DCNL * gray DCNL * hot DCNL * hsv DCNL * jet DCNL * pink DCNL * prism DCNL * spring DCNL * summer DCNL * winter DCNL * spectral DCNL You can set the colormap for an image, pcolor, scatter, etc, DCNL either as a keyword argument:: DCNL imshow(X, cmap=cm.hot) DCNL or post-hoc using the corresponding pylab interface function:: DCNL imshow(X) DCNL hot() DCNL jet() DCNL In interactive mode, this will update the colormap allowing you to DCNL see which one works best for your data.'
def clim(vmin=None, vmax=None): DCNL 'Set the color limits of the current image DCNL To apply clim to all axes images do:: DCNL clim(0, 0.5) DCNL If either *vmin* or *vmax* is None, the image min/max respectively DCNL will be used for color scaling. DCNL If you want to set the clim of multiple images, DCNL use, for example:: DCNL for im in gca().get_images(): DCNL im.set_clim(0, 0.05)'
def matshow(A, fignum=None, **kw): DCNL 'Display an array as a matrix in a new figure window. DCNL The origin is set at the upper left hand corner and rows (first DCNL dimension of the array) are displayed horizontally.  The aspect DCNL ratio of the figure window is that of the array, unless this would DCNL make an excessively short or narrow figure. DCNL Tick labels for the xaxis are placed on top. DCNL With the exception of fignum, keyword arguments are passed to DCNL :func:`~matplotlib.pyplot.imshow`. DCNL *fignum*: [ None | integer | False ] DCNL By default, :func:`matshow` creates a new figure window with DCNL automatic numbering.  If *fignum* is given as an integer, the DCNL created figure will use this figure number.  Because of how DCNL :func:`matshow` tries to set the figure aspect ratio to be the DCNL one of the array, if you provide the number of an already DCNL existing figure, strange things may happen. DCNL If *fignum* is *False* or 0, a new figure window will **NOT** be created.'
def polar(*args, **kwargs): DCNL 'call signature:: DCNL polar(theta, r, **kwargs) DCNL Make a polar plot.  Multiple *theta*, *r* arguments are supported, DCNL with format strings, as in :func:`~matplotlib.pyplot.plot`.'
def plotfile(fname, cols=(0,), plotfuncs=None, comments='#', skiprows=0, checkrows=5, delimiter=',', **kwargs): DCNL 'Plot the data in *fname* DCNL *cols* is a sequence of column identifiers to plot.  An identifier DCNL is either an int or a string.  If it is an int, it indicates the DCNL column number.  If it is a string, it indicates the column header. DCNL matplotlib will make column headers lower case, replace spaces with DCNL underscores, and remove all illegal characters; so ``\'Adj Close*\'`` DCNL will have name ``\'adj_close\'``. DCNL - If len(*cols*) == 1, only that column will be plotted on the *y* axis. DCNL - If len(*cols*) > 1, the first element will be an identifier for DCNL data for the *x* axis and the remaining elements will be the DCNL column indexes for multiple subplots DCNL *plotfuncs*, if not *None*, is a dictionary mapping identifier to DCNL an :class:`~matplotlib.axes.Axes` plotting function as a string. DCNL Default is \'plot\', other choices are \'semilogy\', \'fill\', \'bar\', DCNL etc.  You must use the same type of identifier in the *cols* DCNL vector as you use in the *plotfuncs* dictionary, eg., integer DCNL column numbers in both or column names in both. DCNL *comments*, *skiprows*, *checkrows*, and *delimiter* are all passed on to DCNL :func:`matplotlib.pylab.csv2rec` to load the data into a record array. DCNL kwargs are passed on to plotting functions. DCNL Example usage:: DCNL # plot the 2nd and 4th column against the 1st in two subplots DCNL plotfile(fname, (0,1,3)) DCNL # plot using column names; specify an alternate plot type for volume DCNL plotfile(fname, (\'date\', \'volume\', \'adj_close\'), plotfuncs={\'volume\': \'semilogy\'})'
def autumn(): DCNL 'set the default colormap to autumn and apply to current image if any. DCNL See help(colormaps) for more information'
def bone(): DCNL 'set the default colormap to bone and apply to current image if any. DCNL See help(colormaps) for more information'
def cool(): DCNL 'set the default colormap to cool and apply to current image if any. DCNL See help(colormaps) for more information'
def copper(): DCNL 'set the default colormap to copper and apply to current image if any. DCNL See help(colormaps) for more information'
def flag(): DCNL 'set the default colormap to flag and apply to current image if any. DCNL See help(colormaps) for more information'
def gray(): DCNL 'set the default colormap to gray and apply to current image if any. DCNL See help(colormaps) for more information'
def hot(): DCNL 'set the default colormap to hot and apply to current image if any. DCNL See help(colormaps) for more information'
def hsv(): DCNL 'set the default colormap to hsv and apply to current image if any. DCNL See help(colormaps) for more information'
def jet(): DCNL 'set the default colormap to jet and apply to current image if any. DCNL See help(colormaps) for more information'
def pink(): DCNL 'set the default colormap to pink and apply to current image if any. DCNL See help(colormaps) for more information'
def prism(): DCNL 'set the default colormap to prism and apply to current image if any. DCNL See help(colormaps) for more information'
def spring(): DCNL 'set the default colormap to spring and apply to current image if any. DCNL See help(colormaps) for more information'
def summer(): DCNL 'set the default colormap to summer and apply to current image if any. DCNL See help(colormaps) for more information'
def winter(): DCNL 'set the default colormap to winter and apply to current image if any. DCNL See help(colormaps) for more information'
def spectral(): DCNL 'set the default colormap to spectral and apply to current image if any. DCNL See help(colormaps) for more information'
def _process_text_args(override, fontdict=None, **kwargs): DCNL 'Return an override dict.  See :func:`~pyplot.text\' docstring for info'
def get_rotation(rotation): DCNL 'Return the text angle as float. DCNL *rotation* may be \'horizontal\', \'vertical\', or a numeric value in degrees.'
def _get_textbox(text, renderer): DCNL 'Calculate the bounding box of the text. Unlike DCNL :meth:`matplotlib.text.Text.get_extents` method, The bbox size of DCNL the text before the rotation is calculated.'
def _to_ordinalf(dt): DCNL 'Convert :mod:`datetime` to the Gregorian date as UTC float days, DCNL preserving hours, minutes, seconds and microseconds.  Return value DCNL is a :func:`float`.'
def _from_ordinalf(x, tz=None): DCNL 'Convert Gregorian float of the date, preserving hours, minutes, DCNL seconds and microseconds.  Return value is a :class:`datetime`.'
def datestr2num(d): DCNL 'Convert a date string to a datenum using DCNL :func:`dateutil.parser.parse`.  *d* can be a single string or a DCNL sequence of strings.'
def date2num(d): DCNL '*d* is either a :class:`datetime` instance or a sequence of datetimes. DCNL Return value is a floating point number (or sequence of floats) DCNL which gives number of days (fraction part represents hours, DCNL minutes, seconds) since 0001-01-01 00:00:00 UTC.'
def julian2num(j): DCNL 'Convert a Julian date (or sequence) to a matplotlib date (or sequence).'
def num2julian(n): DCNL 'Convert a matplotlib date (or sequence) to a Julian date (or sequence).'
def num2date(x, tz=None): DCNL '*x* is a float value which gives number of days (fraction part DCNL represents hours, minutes, seconds) since 0001-01-01 00:00:00 UTC. DCNL Return value is a :class:`datetime` instance in timezone *tz* (default to DCNL rcparams TZ value). DCNL If *x* is a sequence, a sequence of :class:`datetime` objects will DCNL be returned.'
def drange(dstart, dend, delta): DCNL 'Return a date range as float Gregorian ordinals.  *dstart* and DCNL *dend* are :class:`datetime` instances.  *delta* is a DCNL :class:`datetime.timedelta` instance.'
def _close_to_dt(d1, d2, epsilon=5): DCNL 'Assert that datetimes *d1* and *d2* are within *epsilon* microseconds.'
def _close_to_num(o1, o2, epsilon=5): DCNL 'Assert that float ordinals *o1* and *o2* are within *epsilon* microseconds.'
def epoch2num(e): DCNL 'Convert an epoch or sequence of epochs to the new date format, DCNL that is days since 0001.'
def num2epoch(d): DCNL 'Convert days since 0001 to epoch.  *d* can be a number or sequence.'
def mx2num(mxdates): DCNL 'Convert mx :class:`datetime` instance (or sequence of mx DCNL instances) to the new date format.'
def date_ticker_factory(span, tz=None, numticks=5): DCNL 'Create a date locator with *numticks* (approx) and a date formatter DCNL for *span* in days.  Return value is (locator, formatter).'
def seconds(s): DCNL 'Return seconds as days.'
def minutes(m): DCNL 'Return minutes as days.'
def hours(h): DCNL 'Return hours as days.'
def weeks(w): DCNL 'Return weeks as days.'
def _get_packed_offsets(wd_list, total, sep, mode='fixed'): DCNL 'Geiven a list of (width, xdescent) of each boxes, calculate the DCNL total width and the x-offset positions of each items according to DCNL *mode*. xdescent is analagous to the usual descent, but along the DCNL x-direction. xdescent values are currently ignored. DCNL *wd_list* : list of (width, xdescent) of boxes to be packed. DCNL *sep* : spacing between boxes DCNL *total* : Intended total length. None if not used. DCNL *mode* : packing mode. \'fixed\', \'expand\', or \'equal\'.'
def _get_aligned_offsets(hd_list, height, align='baseline'): DCNL 'Geiven a list of (height, descent) of each boxes, align the boxes DCNL with *align* and calculate the y-offsets of each boxes. DCNL total width and the offset positions of each items according to DCNL *mode*. xdescent is analagous to the usual descent, but along the DCNL x-direction. xdescent values are currently ignored. DCNL *hd_list* : list of (width, xdescent) of boxes to be aligned. DCNL *sep* : spacing between boxes DCNL *height* : Intended total length. None if not used. DCNL *align* : align mode. \'baseline\', \'top\', \'bottom\', or \'center\'.'
def decade_down(x, base=10): DCNL 'floor x to the nearest lower decade'
def decade_up(x, base=10): DCNL 'ceil x to the nearest higher decade'
def generate_fontconfig_pattern(d): DCNL 'Given a dictionary of key/value pairs, generates a fontconfig DCNL pattern string.'
def _norm(x): DCNL 'return sqrt(x dot x)'
def window_hanning(x): DCNL 'return x times the hanning window of len(x)'
def window_none(x): DCNL 'No window function; simply return x'
def conv(x, y, mode=2): DCNL 'convolve x with y'
def demean(x, axis=0): DCNL 'Return x minus its mean along the specified axis'
def detrend_mean(x): DCNL 'Return x minus the mean(x)'
def detrend_none(x): DCNL 'Return x: no detrending'
def detrend_linear(y): DCNL 'Return y minus best fit line; \'linear\' detrending'
def psd(x, NFFT=256, Fs=2, detrend=detrend_none, window=window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None): DCNL 'The power spectral density by Welch\'s average periodogram method. DCNL The vector *x* is divided into *NFFT* length blocks.  Each block DCNL is detrended by the function *detrend* and windowed by the function DCNL *window*.  *noverlap* gives the length of the overlap between blocks. DCNL The absolute(fft(block))**2 of each segment are averaged to compute DCNL *Pxx*, with a scaling to correct for power loss due to windowing. DCNL If len(*x*) < *NFFT*, it will be zero padded to *NFFT*. DCNL *x* DCNL Array or sequence containing the data DCNL %(PSD)s DCNL Returns the tuple (*Pxx*, *freqs*). DCNL Refs: DCNL Bendat & Piersol -- Random Data: Analysis and Measurement DCNL Procedures, John Wiley & Sons (1986)'
def csd(x, y, NFFT=256, Fs=2, detrend=detrend_none, window=window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None): DCNL 'The cross power spectral density by Welch\'s average periodogram DCNL method.  The vectors *x* and *y* are divided into *NFFT* length DCNL blocks.  Each block is detrended by the function *detrend* and DCNL windowed by the function *window*.  *noverlap* gives the length DCNL of the overlap between blocks.  The product of the direct FFTs DCNL of *x* and *y* are averaged over each segment to compute *Pxy*, DCNL with a scaling to correct for power loss due to windowing. DCNL If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero DCNL padded to *NFFT*. DCNL *x*, *y* DCNL Array or sequence containing the data DCNL %(PSD)s DCNL Returns the tuple (*Pxy*, *freqs*). DCNL Refs: DCNL Bendat & Piersol -- Random Data: Analysis and Measurement DCNL Procedures, John Wiley & Sons (1986)'
def specgram(x, NFFT=256, Fs=2, detrend=detrend_none, window=window_hanning, noverlap=128, pad_to=None, sides='default', scale_by_freq=None): DCNL 'Compute a spectrogram of data in *x*.  Data are split into *NFFT* DCNL length segements and the PSD of each section is computed.  The DCNL windowing function *window* is applied to each segment, and the DCNL amount of overlap of each segment is specified with *noverlap*. DCNL If *x* is real (i.e. non-complex) only the spectrum of the positive DCNL frequencie is returned.  If *x* is complex then the complete DCNL spectrum is returned. DCNL %(PSD)s DCNL Returns a tuple (*Pxx*, *freqs*, *t*): DCNL - *Pxx*: 2-D array, columns are the periodograms of DCNL successive segments DCNL - *freqs*: 1-D array of frequencies corresponding to the rows DCNL in Pxx DCNL - *t*: 1-D array of times corresponding to midpoints of DCNL segments. DCNL .. seealso:: DCNL :func:`psd`: DCNL :func:`psd` differs in the default overlap; in returning DCNL the mean of the segment periodograms; and in not returning DCNL times.'
def cohere(x, y, NFFT=256, Fs=2, detrend=detrend_none, window=window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None): DCNL 'The coherence between *x* and *y*.  Coherence is the normalized DCNL cross spectral density: DCNL .. math:: DCNL C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}} DCNL *x*, *y* DCNL Array or sequence containing the data DCNL %(PSD)s DCNL The return value is the tuple (*Cxy*, *f*), where *f* are the DCNL frequencies of the coherence vector. For cohere, scaling the DCNL individual densities by the sampling frequency has no effect, since DCNL the factors cancel out. DCNL .. seealso:: DCNL :func:`psd` and :func:`csd`: DCNL For information about the methods used to compute DCNL :math:`P_{xy}`, :math:`P_{xx}` and :math:`P_{yy}`.'
def corrcoef(*args): DCNL 'corrcoef(*X*) where *X* is a matrix returns a matrix of correlation DCNL coefficients for the columns of *X* DCNL corrcoef(*x*, *y*) where *x* and *y* are vectors returns the matrix of DCNL correlation coefficients for *x* and *y*. DCNL Numpy arrays can be real or complex. DCNL The correlation matrix is defined from the covariance matrix *C* DCNL as DCNL .. math:: DCNL r_{ij} = \frac{C_{ij}}{\sqrt{C_{ii}C_{jj}}}'
def get_fontext_synonyms(fontext): DCNL 'Return a list of file extensions extensions that are synonyms for DCNL the given file extension *fileext*.'
def win32FontDirectory(): DCNL 'Return the user-specified font directory for Win32.  This is DCNL looked up from the registry key:: DCNL \HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\Fonts DCNL If the key is not found, $WINDIR/Fonts will be returned.'
def win32InstalledFonts(directory=None, fontext='ttf'): DCNL 'Search for fonts in the specified font directory, or use the DCNL system directories if none given.  A list of TrueType font DCNL filenames are returned by default, or AFM fonts if *fontext* == DCNL \'afm\'.'
def OSXFontDirectory(): DCNL 'Return the system font directories for OS X.  This is done by DCNL starting at the list of hardcoded paths in DCNL :attr:`OSXFontDirectories` and returning all nested directories DCNL within them.'
def OSXInstalledFonts(directory=None, fontext='ttf'): DCNL 'Get list of font files on OS X - ignores font suffix by default.'
def x11FontDirectory(): DCNL 'Return the system font directories for X11.  This is done by DCNL starting at the list of hardcoded paths in DCNL :attr:`X11FontDirectories` and returning all nested directories DCNL within them.'
def get_fontconfig_fonts(fontext='ttf'): DCNL 'Grab a list of all the fonts that are being tracked by fontconfig DCNL by making a system call to ``fc-list``.  This is an easy way to DCNL grab all of the fonts the user wants to be made available to DCNL applications, without needing knowing where all of them reside.'
def findSystemFonts(fontpaths=None, fontext='ttf'): DCNL 'Search for fonts in the specified font paths.  If no paths are DCNL given, will use a standard set of system paths, as well as the DCNL list of fonts tracked by fontconfig if fontconfig is installed and DCNL available.  A list of TrueType fonts are returned by default with DCNL AFM fonts as an option.'
def weight_as_number(weight): DCNL 'Return the weight property as a numeric value.  String values DCNL are converted to their corresponding numeric value.'
def ttfFontProperty(font): DCNL 'A function for populating the :class:`FontKey` by extracting DCNL information from the TrueType font file. DCNL *font* is a :class:`FT2Font` instance.'
def afmFontProperty(fontpath, font): DCNL 'A function for populating a :class:`FontKey` instance by DCNL extracting information from the AFM font file. DCNL *font* is a class:`AFM` instance.'
def createFontList(fontfiles, fontext='ttf'): DCNL 'A function to create a font lookup list.  The default is to create DCNL a list of TrueType fonts.  An AFM font list can optionally be DCNL created.'
def ttfdict_to_fnames(d): DCNL 'flatten a ttfdict to all the filenames it contains'
def pickle_dump(data, filename): DCNL 'Equivalent to pickle.dump(data, open(filename, \'w\')) DCNL but closes the file to prevent filehandle leakage.'
def pickle_load(filename): DCNL 'Equivalent to pickle.load(open(filename, \'r\')) DCNL but closes the file to prevent filehandle leakage.'
def is_opentype_cff_font(filename): DCNL 'Returns True if the given font is a Postscript Compact Font Format DCNL Font embedded in an OpenType wrapper.  Used by the PostScript and DCNL PDF backends that can not subset these fonts.'
def __patch__init__(self, edgecolor=None, facecolor=None, linewidth=None, linestyle=None, antialiased=None, hatch=None, fill=True, **kwargs): DCNL 'The following kwarg properties are supported DCNL %(Patch)s'
def bbox_artist(artist, renderer, props=None, fill=True): DCNL 'This is a debug function to draw a rectangle around the bounding DCNL box returned by DCNL :meth:`~matplotlib.artist.Artist.get_window_extent` of an artist, DCNL to test whether the artist is returning the correct bbox. DCNL *props* is a dict of rectangle props with the additional property DCNL \'pad\' that sets the padding around the bbox in points.'
def draw_bbox(bbox, renderer, color='k', trans=None): DCNL 'This is a debug function to draw a rectangle around the bounding DCNL box returned by DCNL :meth:`~matplotlib.artist.Artist.get_window_extent` of an artist, DCNL to test whether the artist is returning the correct bbox.'
def _pprint_table(_table, leadingspace=2): DCNL 'Given the list of list of strings, return a string of REST table format.'
def _pprint_styles(_styles, leadingspace=2): DCNL 'A helper function for the _Style class.  Given the dictionary of DCNL (stylename : styleclass), return a formatted string listing all the DCNL styles. Used to update the documentation.'
def parse_yahoo_historical(fh, asobject=False, adjusted=True): DCNL 'Parse the historical data in file handle fh from yahoo finance and return DCNL results as a list of DCNL d, open, close, high, low, volume DCNL where d is a floating poing representation of date, as returned by date2num DCNL if adjust=True, use adjusted prices'
def fetch_historical_yahoo(ticker, date1, date2, cachename=None): DCNL 'Fetch historical data for ticker between date1 and date2.  date1 and DCNL date2 are datetime instances DCNL Ex: DCNL fh = fetch_historical_yahoo(\'^GSPC\', d1, d2) DCNL cachename is the name of the local file cache.  If None, will DCNL default to the md5 hash or the url (which incorporates the ticker DCNL and date range) DCNL a file handle is returned'
def quotes_historical_yahoo(ticker, date1, date2, asobject=False, adjusted=True, cachename=None): DCNL 'Get historical data for ticker between date1 and date2.  date1 and DCNL date2 are datetime instances DCNL results are a list of tuples DCNL (d, open, close, high, low, volume) DCNL where d is a floating poing representation of date, as returned by date2num DCNL if asobject is True, the return val is an object with attrs date, DCNL open, close, high, low, volume, which are equal length arrays DCNL if adjust=True, use adjusted prices DCNL Ex: DCNL sp = f.quotes_historical_yahoo(\'^GSPC\', d1, d2, asobject=True, adjusted=True) DCNL returns = (sp.open[1:] - sp.open[:-1])/sp.open[1:] DCNL [n,bins,patches] = hist(returns, 100) DCNL mu = mean(returns) DCNL sigma = std(returns) DCNL x = normpdf(bins, mu, sigma) DCNL plot(bins, x, color=\'red\', lw=2) DCNL cachename is the name of the local file cache.  If None, will DCNL default to the md5 hash or the url (which incorporates the ticker DCNL and date range)'
def plot_day_summary(ax, quotes, ticksize=3, colorup='k', colordown='r'): DCNL 'quotes is a list of (time, open, close, high, low, ...) tuples DCNL Represent the time, open, close, high, low as a vertical line DCNL ranging from low to high.  The left tick is the open and the right DCNL tick is the close. DCNL time must be in float date format - see date2num DCNL ax          : an Axes instance to plot to DCNL ticksize    : open/close tick marker in points DCNL colorup     : the color of the lines where close >= open DCNL colordown   : the color of the lines where close <  open DCNL return value is a list of lines added'
def candlestick(ax, quotes, width=0.2, colorup='k', colordown='r', alpha=1.0): DCNL 'quotes is a list of (time, open, close, high, low, ...)  tuples. DCNL As long as the first 5 elements of the tuples are these values, DCNL the tuple can be as long as you want (eg it may store volume). DCNL time must be in float days format - see date2num DCNL Plot the time, open, close, high, low as a vertical line ranging DCNL from low to high.  Use a rectangular bar to represent the DCNL open-close span.  If close >= open, use colorup to color the bar, DCNL otherwise use colordown DCNL ax          : an Axes instance to plot to DCNL width       : fraction of a day for the rectangle width DCNL colorup     : the color of the rectangle where close >= open DCNL colordown   : the color of the rectangle where close <  open DCNL alpha       : the rectangle alpha level DCNL return value is lines, patches where lines is a list of lines DCNL added and patches is a list of the rectangle patches added'
def plot_day_summary2(ax, opens, closes, highs, lows, ticksize=4, colorup='k', colordown='r'): DCNL 'Represent the time, open, close, high, low as a vertical line DCNL ranging from low to high.  The left tick is the open and the right DCNL tick is the close. DCNL ax          : an Axes instance to plot to DCNL ticksize    : size of open and close ticks in points DCNL colorup     : the color of the lines where close >= open DCNL colordown   : the color of the lines where close <  open DCNL return value is a list of lines added'
def candlestick2(ax, opens, closes, highs, lows, width=4, colorup='k', colordown='r', alpha=0.75): DCNL 'Represent the open, close as a bar line and high low range as a DCNL vertical line. DCNL ax          : an Axes instance to plot to DCNL width       : the bar width in points DCNL colorup     : the color of the lines where close >= open DCNL colordown   : the color of the lines where close <  open DCNL alpha       : bar transparency DCNL return value is lineCollection, barCollection'
def volume_overlay(ax, opens, closes, volumes, colorup='k', colordown='r', width=4, alpha=1.0): DCNL 'Add a volume overlay to the current axes.  The opens and closes DCNL are used to determine the color of the bar.  -1 is missing.  If a DCNL value is missing on one it must be missing on all DCNL ax          : an Axes instance to plot to DCNL width       : the bar width in points DCNL colorup     : the color of the lines where close >= open DCNL colordown   : the color of the lines where close <  open DCNL alpha       : bar transparency'
def volume_overlay2(ax, closes, volumes, colorup='k', colordown='r', width=4, alpha=1.0): DCNL 'Add a volume overlay to the current axes.  The closes are used to DCNL determine the color of the bar.  -1 is missing.  If a value is DCNL missing on one it must be missing on all DCNL ax          : an Axes instance to plot to DCNL width       : the bar width in points DCNL colorup     : the color of the lines where close >= open DCNL colordown   : the color of the lines where close <  open DCNL alpha       : bar transparency DCNL nb: first point is not displayed - it is used only for choosing the DCNL right color'
def volume_overlay3(ax, quotes, colorup='k', colordown='r', width=4, alpha=1.0): DCNL 'Add a volume overlay to the current axes.  quotes is a list of (d, DCNL open, close, high, low, volume) and close-open is used to DCNL determine the color of the bar DCNL kwarg DCNL width       : the bar width in points DCNL colorup     : the color of the lines where close1 >= close0 DCNL colordown   : the color of the lines where close1 <  close0 DCNL alpha       : bar transparency'
def index_bar(ax, vals, facecolor='b', edgecolor='l', width=4, alpha=1.0): DCNL 'Add a bar collection graph with height vals (-1 is missing). DCNL ax          : an Axes instance to plot to DCNL width       : the bar width in points DCNL alpha       : bar transparency'
def segment_hits(cx, cy, x, y, radius): DCNL 'Determine if any line segments are within radius of a DCNL point. Returns the list of line segments that are within that DCNL radius.'
def blended_transform_factory(x_transform, y_transform): DCNL 'Create a new "blended" transform using *x_transform* to transform DCNL the *x*-axis and *y_transform* to transform the *y*-axis. DCNL A faster version of the blended transform is returned for the case DCNL where both child transforms are affine.'
def composite_transform_factory(a, b): DCNL 'Create a new composite transform that is the result of applying DCNL transform a then transform b. DCNL Shortcut versions of the blended transform are provided for the DCNL case where both child transforms are affine, or one or the other DCNL is the identity transform. DCNL Composite transforms may also be created using the \'+\' operator, DCNL e.g.:: DCNL c = a + b'
def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True): DCNL 'Ensure the endpoints of a range are finite and not too close together. DCNL "too close" means the interval is smaller than \'tiny\' times DCNL the maximum absolute value. DCNL If they are too close, each will be moved by the \'expander\'. DCNL If \'increasing\' is True and vmin > vmax, they will be swapped, DCNL regardless of whether they are too close. DCNL If either is inf or -inf or nan, return - expander, expander.'
def offset_copy(trans, fig, x=0.0, y=0.0, units='inches'): DCNL 'Return a new transform with an added offset. DCNL args: DCNL trans is any transform DCNL kwargs: DCNL fig is the current figure; it can be None if units are \'dots\' DCNL x, y give the offset DCNL units is \'inches\', \'points\' or \'dots\''
def imread(fname): DCNL 'Return image file in *fname* as :class:`numpy.array`. DCNL Return value is a :class:`numpy.array`.  For grayscale images, the DCNL return array is MxN.  For RGB images, the return value is MxNx3. DCNL For RGBA images the return value is MxNx4. DCNL matplotlib can only read PNGs natively, but if `PIL DCNL <http://www.pythonware.com/products/pil/>`_ is installed, it will DCNL use it to load the image and return an array (if possible) which DCNL can be used with :func:`~matplotlib.pyplot.imshow`. DCNL TODO: support RGB and grayscale return values in _image.readpng'
def pil_to_array(pilImage): DCNL 'load a PIL image and return it as a numpy array of uint8.  For DCNL grayscale images, the return array is MxN.  For RGB images, the DCNL return value is MxNx3.  For RGBA images the return value is MxNx4'
def thumbnail(infile, thumbfile, scale=0.1, interpolation='bilinear', preview=False): DCNL 'make a thumbnail of image in *infile* with output filename DCNL *thumbfile*. DCNL *infile* the image file -- must be PNG or PIL readable if you DCNL have `PIL <http://www.pythonware.com/products/pil/>`_ installed DCNL *thumbfile* DCNL the thumbnail filename DCNL *scale* DCNL the scale factor for the thumbnail DCNL *interpolation* DCNL the interpolation scheme used in the resampling DCNL *preview* DCNL if True, the default backend (presumably a user interface DCNL backend) will be used which will cause a figure to be raised DCNL if :func:`~matplotlib.pyplot.show` is called.  If it is False, DCNL a pure image backend will be used depending on the extension, DCNL \'png\'->FigureCanvasAgg, \'pdf\'->FigureCanvasPDF, DCNL \'svg\'->FigureCanvasSVG DCNL See examples/misc/image_thumbnail.py. DCNL .. htmlonly:: DCNL :ref:`misc-image_thumbnail` DCNL Return value is the figure instance containing the thumbnail'
def _process_plot_format(fmt): DCNL 'Process a matlab(TM) style color/line style format string.  Return a DCNL (*linestyle*, *color*) tuple as a result of the processing.  Default DCNL values are (\'-\', \'b\').  Example format strings include: DCNL * \'ko\': black circles DCNL * \'.b\': blue dots DCNL * \'r--\': red dashed lines DCNL .. seealso:: DCNL :func:`~matplotlib.Line2D.lineStyles` and DCNL :func:`~matplotlib.pyplot.colors`: DCNL for all possible styles and color format string.'
def set_default_color_cycle(clist): DCNL 'Change the default cycle of colors that will be used by the plot DCNL command.  This must be called before creating the DCNL :class:`Axes` to which it will apply; it will DCNL apply to all future axes. DCNL *clist* is a sequence of mpl color specifiers'
def _fix2comp(num): DCNL 'Convert from two\'s complement to negative.'
def _mul2012(num1, num2): DCNL 'Multiply two numbers in 20.12 fixed point format.'
def find_tex_file(filename, format=None): DCNL 'Call kpsewhich to find a file in the texmf tree. DCNL If format is not None, it is used as the value for the --format option. DCNL See the kpathsea documentation for more information. DCNL Apparently most existing TeX distributions on Unix-like systems DCNL use kpathsea. I hear MikTeX (a popular distribution on Windows) DCNL doesn\'t use kpathsea, so what do we do? (TODO)'
def _sanity_check(fh): DCNL 'Check if the file at least looks like AFM. DCNL If not, raise :exc:`RuntimeError`.'
def _parse_header(fh): DCNL 'Reads the font metrics header (up to the char metrics) and returns DCNL a dictionary mapping *key* to *val*.  *val* will be converted to the DCNL appropriate python type as necessary; eg: DCNL * \'False\'->False DCNL * \'0\'->0 DCNL * \'-168 -218 1000 898\'-> [-168, -218, 1000, 898] DCNL Dictionary keys are DCNL StartFontMetrics, FontName, FullName, FamilyName, Weight, DCNL ItalicAngle, IsFixedPitch, FontBBox, UnderlinePosition, DCNL UnderlineThickness, Version, Notice, EncodingScheme, CapHeight, DCNL XHeight, Ascender, Descender, StartCharMetrics'
def _parse_char_metrics(fh): DCNL 'Return a character metric dictionary.  Keys are the ASCII num of DCNL the character, values are a (*wx*, *name*, *bbox*) tuple, where DCNL *wx* is the character width, *name* is the postscript language DCNL name, and *bbox* is a (*llx*, *lly*, *urx*, *ury*) tuple. DCNL This function is incomplete per the standard, but thus far parses DCNL all the sample afm files tried.'
def _parse_kern_pairs(fh): DCNL 'Return a kern pairs dictionary; keys are (*char1*, *char2*) tuples and DCNL values are the kern pair value.  For example, a kern pairs line like DCNL ``KPX A y -50`` DCNL will be represented as:: DCNL d[ (\'A\', \'y\') ] = -50'
def _parse_composites(fh): DCNL 'Return a composites dictionary.  Keys are the names of the DCNL composites.  Values are a num parts list of composite information, DCNL with each element being a (*name*, *dx*, *dy*) tuple.  Thus a DCNL composites line reading: DCNL CC Aacute 2 ; PCC A 0 0 ; PCC acute 160 170 ; DCNL will be represented as:: DCNL d[\'Aacute\'] = [ (\'A\', 0, 0), (\'acute\', 160, 170) ]'
def _parse_optional(fh): DCNL 'Parse the optional fields for kern pair data and composites DCNL return value is a (*kernDict*, *compositeDict*) which are the DCNL return values from :func:`_parse_kern_pairs`, and DCNL :func:`_parse_composites` if the data exists, or empty dicts DCNL otherwise'
def parse_afm(fh): DCNL 'Parse the Adobe Font Metics file in file handle *fh*. Return value DCNL is a (*dhead*, *dcmetrics*, *dkernpairs*, *dcomposite*) tuple where DCNL *dhead* is a :func:`_parse_header` dict, *dcmetrics* is a DCNL :func:`_parse_composites` dict, *dkernpairs* is a DCNL :func:`_parse_kern_pairs` dict (possibly {}), and *dcomposite* is a DCNL :func:`_parse_composites` dict (possibly {})'
def getp(o, property=None): DCNL 'Return the value of handle property.  property is an optional string DCNL for the property you want to return DCNL Example usage:: DCNL getp(o)  # get all the object properties DCNL getp(o, \'linestyle\')  # get the linestyle property DCNL *o* is a :class:`Artist` instance, eg DCNL :class:`~matplotllib.lines.Line2D` or an instance of a DCNL :class:`~matplotlib.axes.Axes` or :class:`matplotlib.text.Text`. DCNL If the *property* is \'somename\', this function returns DCNL o.get_somename() DCNL :func:`getp` can be used to query all the gettable properties with DCNL ``getp(o)``. Many properties have aliases for shorter typing, e.g. DCNL \'lw\' is an alias for \'linewidth\'.  In the output, aliases and full DCNL property names will be listed as: DCNL property or alias = value DCNL e.g.: DCNL linewidth or lw = 2'
def setp(h, *args, **kwargs): DCNL 'matplotlib supports the use of :func:`setp` ("set property") and DCNL :func:`getp` to set and get object properties, as well as to do DCNL introspection on the object.  For example, to set the linestyle of a DCNL line to be dashed, you can do:: DCNL >>> line, = plot([1,2,3]) DCNL >>> setp(line, linestyle=\'--\') DCNL If you want to know the valid types of arguments, you can provide the DCNL name of the property you want to set without a value:: DCNL >>> setp(line, \'linestyle\') DCNL linestyle: [ \'-\' | \'--\' | \'-.\' | \':\' | \'steps\' | \'None\' ] DCNL If you want to see all the properties that can be set, and their DCNL possible values, you can do:: DCNL >>> setp(line) DCNL ... long output listing omitted DCNL :func:`setp` operates on a single instance or a list of instances. DCNL If you are in query mode introspecting the possible values, only DCNL the first instance in the sequence is used.  When actually setting DCNL values, all the instances will be set.  E.g., suppose you have a DCNL list of two lines, the following will make both lines thicker and DCNL red:: DCNL >>> x = arange(0,1.0,0.01) DCNL >>> y1 = sin(2*pi*x) DCNL >>> y2 = sin(4*pi*x) DCNL >>> lines = plot(x, y1, x, y2) DCNL >>> setp(lines, linewidth=2, color=\'r\') DCNL :func:`setp` works with the matlab(TM) style string/value pairs or DCNL with python kwargs.  For example, the following are equivalent:: DCNL >>> setp(lines, \'linewidth\', 2, \'color\', r\')  # matlab style DCNL >>> setp(lines, linewidth=2, color=\'r\')       # python style'
def col(loc, strg): DCNL 'Returns current column within a string, counting newlines as line separators. DCNL The first column is number 1. DCNL Note: the default parsing behavior is to expand tabs in the input string DCNL before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information DCNL on parsing strings containing <TAB>s, and suggested methods to maintain a DCNL consistent view of the parsed string, the parse location, and line and column DCNL positions within the parsed string.'
def lineno(loc, strg): DCNL 'Returns current line number within a string, counting newlines as line separators. DCNL The first line is number 1. DCNL Note: the default parsing behavior is to expand tabs in the input string DCNL before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information DCNL on parsing strings containing <TAB>s, and suggested methods to maintain a DCNL consistent view of the parsed string, the parse location, and line and column DCNL positions within the parsed string.'
def line(loc, strg): DCNL 'Returns the line of text containing loc within a string, counting newlines as line separators.'
def nullDebugAction(*args): DCNL '\'Do-nothing\' debug action, to suppress debugging output during parsing.'
def traceParseAction(f): DCNL 'Decorator for debugging parse actions.'
def delimitedList(expr, delim=',', combine=False): DCNL 'Helper to define a delimited list of expressions - the delimiter defaults to \',\'. DCNL By default, the list elements and delimiters can have intervening whitespace, and DCNL comments, but this can be overridden by passing \'combine=True\' in the constructor. DCNL If combine is set to True, the matching tokens are returned as a single token DCNL string, with the delimiters included; otherwise, the matching tokens are returned DCNL as a list of tokens, with the delimiters suppressed.'
def countedArray(expr): DCNL 'Helper to define a counted list of expressions. DCNL This helper defines a pattern of the form:: DCNL integer expr expr expr... DCNL where the leading integer tells how many expr expressions follow. DCNL The matched tokens returns the array of expr tokens as a list - the leading count token is suppressed.'
def matchPreviousLiteral(expr): DCNL 'Helper to define an expression that is indirectly defined from DCNL the tokens matched in a previous expression, that is, it looks DCNL for a \'repeat\' of a previous expression.  For example:: DCNL first = Word(nums) DCNL second = matchPreviousLiteral(first) DCNL matchExpr = first + ":" + second DCNL will match "1:1", but not "1:2".  Because this matches a DCNL previous literal, will also match the leading "1:1" in "1:10". DCNL If this is not desired, use matchPreviousExpr. DCNL Do *not* use with packrat parsing enabled.'
def matchPreviousExpr(expr): DCNL 'Helper to define an expression that is indirectly defined from DCNL the tokens matched in a previous expression, that is, it looks DCNL for a \'repeat\' of a previous expression.  For example:: DCNL first = Word(nums) DCNL second = matchPreviousExpr(first) DCNL matchExpr = first + ":" + second DCNL will match "1:1", but not "1:2".  Because this matches by DCNL expressions, will *not* match the leading "1:1" in "1:10"; DCNL the expressions are evaluated first, and then compared, so DCNL "1" is compared with "10". DCNL Do *not* use with packrat parsing enabled.'
def oneOf(strs, caseless=False, useRegex=True): DCNL 'Helper to quickly define a set of alternative Literals, and makes sure to do DCNL longest-first testing when there is a conflict, regardless of the input order, DCNL but returns a MatchFirst for best performance. DCNL Parameters: DCNL - strs - a string of space-delimited literals, or a list of string literals DCNL - caseless - (default=False) - treat all literals as caseless DCNL - useRegex - (default=True) - as an optimization, will generate a Regex DCNL object; otherwise, will generate a MatchFirst object (if caseless=True, or DCNL if creating a Regex raises an exception)'
def dictOf(key, value): DCNL 'Helper to easily and clearly define a dictionary by specifying the respective patterns DCNL for the key and value.  Takes care of defining the Dict, ZeroOrMore, and Group tokens DCNL in the proper order.  The key pattern can include delimiting markers or punctuation, DCNL as long as they are suppressed, thereby leaving the significant key text.  The value DCNL pattern can include named results, so that the Dict results can include named token DCNL fields.'
def srange(s): DCNL 'Helper to easily define string ranges for use in Word construction.  Borrows DCNL syntax from regexp \'[]\' string range definitions:: DCNL srange("[0-9]")   -> "0123456789" DCNL srange("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz" DCNL srange("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_" DCNL The input string must be enclosed in []\'s, and the returned string is the expanded DCNL character set joined into a single string. DCNL The values enclosed in the []\'s may be:: DCNL a single character DCNL an escaped character with a leading backslash (such as \- or \]) DCNL an escaped hex character with a leading \'\0x\' (\0x21, which is a \'!\' character) DCNL an escaped octal character with a leading \'\0\' (\041, which is a \'!\' character) DCNL a range of any of the above, separated by a dash (\'a-z\', etc.) DCNL any combination of the above (\'aeiouy\', \'a-zA-Z0-9_$\', etc.)'
def matchOnlyAtCol(n): DCNL 'Helper method for defining parse actions that require matching at a specific DCNL column in the input text.'
def replaceWith(replStr): DCNL 'Helper method for common parse actions that simply return a literal value.  Especially DCNL useful when used with transformString().'
def removeQuotes(s, l, t): DCNL 'Helper parse action for removing quotation marks from parsed quoted strings. DCNL To use, add this parse action to quoted string using:: DCNL quotedString.setParseAction( removeQuotes )'
def upcaseTokens(s, l, t): DCNL 'Helper parse action to convert tokens to upper case.'
def downcaseTokens(s, l, t): DCNL 'Helper parse action to convert tokens to lower case.'
def keepOriginalText(s, startLoc, t): DCNL 'Helper parse action to preserve original parsed text, DCNL overriding any nested parse actions.'
def getTokensEndLoc(): DCNL 'Method to be called from within a parse action to determine the end DCNL location of the parsed tokens.'
def _makeTags(tagStr, xml): DCNL 'Internal helper to construct opening and closing tag expressions, given a tag name'
def makeHTMLTags(tagStr): DCNL 'Helper to construct opening and closing tag expressions for HTML, given a tag name'
def makeXMLTags(tagStr): DCNL 'Helper to construct opening and closing tag expressions for XML, given a tag name'
def withAttribute(*args, **attrDict): DCNL 'Helper to create a validating parse action to be used with start tags created DCNL with makeXMLTags or makeHTMLTags. Use withAttribute to qualify a starting tag DCNL with a required attribute value, to avoid false matches on common tags such as DCNL <TD> or <DIV>. DCNL Call withAttribute with a series of attribute names and values. Specify the list DCNL of filter attributes names and values as: DCNL - keyword arguments, as in (class="Customer",align="right"), or DCNL - a list of name-value tuples, as in ( ("ns1:class", "Customer"), ("ns2:align","right") ) DCNL For attribute names with a namespace prefix, you must use the second form.  Attribute DCNL names are matched insensitive to upper/lower case. DCNL To verify that the attribute exists, but without specifying a value, pass DCNL withAttribute.ANY_VALUE as the value.'
def operatorPrecedence(baseExpr, opList): DCNL 'Helper method for constructing grammars of expressions made up of DCNL operators working in a precedence hierarchy.  Operators may be unary or DCNL binary, left- or right-associative.  Parse actions can also be attached DCNL to operator expressions. DCNL Parameters: DCNL - baseExpr - expression representing the most basic element for the nested DCNL - opList - list of tuples, one for each operator precedence level in the DCNL expression grammar; each tuple is of the form DCNL (opExpr, numTerms, rightLeftAssoc, parseAction), where: DCNL - opExpr is the pyparsing expression for the operator; DCNL may also be a string, which will be converted to a Literal; DCNL if numTerms is 3, opExpr is a tuple of two expressions, for the DCNL two operators separating the 3 terms DCNL - numTerms is the number of terms for this operator (must DCNL be 1, 2, or 3) DCNL - rightLeftAssoc is the indicator whether the operator is DCNL right or left associative, using the pyparsing-defined DCNL constants opAssoc.RIGHT and opAssoc.LEFT. DCNL - parseAction is the parse action to be associated with DCNL expressions matching this operator expression (the DCNL parse action tuple member may be omitted)'
def nestedExpr(opener='(', closer=')', content=None, ignoreExpr=quotedString): DCNL 'Helper method for defining nested lists enclosed in opening and closing DCNL delimiters ("(" and ")" are the default). DCNL Parameters: DCNL - opener - opening character for a nested list (default="("); can also be a pyparsing expression DCNL - closer - closing character for a nested list (default=")"); can also be a pyparsing expression DCNL - content - expression for items within the nested lists (default=None) DCNL - ignoreExpr - expression for ignoring opening and closing delimiters (default=quotedString) DCNL If an expression is not provided for the content argument, the nested DCNL expression will capture all whitespace-delimited content between delimiters DCNL as a list of separate values. DCNL Use the ignoreExpr argument to define expressions that may contain DCNL opening or closing characters that should not be treated as opening DCNL or closing characters for nesting, such as quotedString or a comment DCNL expression.  Specify multiple expressions using an Or or MatchFirst. DCNL The default is quotedString, but if no expressions are to be ignored, DCNL then pass None for this argument.'
def indentedBlock(blockStatementExpr, indentStack, indent=True): DCNL 'Helper method for defining space-delimited indentation blocks, such as DCNL those used to define block statements in Python source code. DCNL Parameters: DCNL - blockStatementExpr - expression defining syntax of statement that DCNL is repeated within the indented block DCNL - indentStack - list created by caller to manage indentation stack DCNL (multiple statementWithIndentedBlock expressions within a single grammar DCNL should share a common indentStack) DCNL - indent - boolean indicating whether block must be indented beyond the DCNL the current level; set to False for block of left-most statements DCNL (default=True) DCNL A valid block must contain at least one blockStatement.'
def getFileUsed(): DCNL 'Determine which NuPIC configuration file is being used and returns the DCNL name of the configuration file it is using. Either DEFAULT_CONFIG or DCNL USER_CONFIG.'
def testDbConnection(host, port, user, passwd): DCNL 'Determine if the specified host, port, user, passwd is able to connect DCNL to a running mysql database, create test database, create a test table, DCNL insert something into the table, delete the table, and delete the database. DCNL returns true if this is successful, false if there is an error in this DCNL process.'
def dbValidator(): DCNL 'Let the user know what NuPIC config file is being used DCNL and whether or not they have mysql set up correctly for DCNL swarming.'
def filter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called for every possible permutation of the variables DCNL in the permutations dict. It should return True for valid a combination of DCNL permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def printMatrix(inputs, spOutput): DCNL '(i,j)th cell of the diff matrix will have the number of inputs for which the input and output DCNL pattern differ by i bits and the cells activated differ at j places. DCNL Parameters: DCNL inputs:                the input encodings DCNL spOutput:              the coincidences activated in response to each input'
def _hammingDistance(s1, s2): DCNL 'Hamming distance between two numpy arrays s1 and s2'
def analyzeOverlaps(activeCoincsFile, encodingsFile, dataset): DCNL 'Mirror Image Visualization: Shows the encoding space juxtaposed against the DCNL coincidence space. The encoding space is the bottom-up sensory encoding and DCNL the coincidence space depicts the corresponding activation of coincidences in DCNL the SP. Hence, the mirror image visualization is a visual depiction of the DCNL mapping of SP cells to the input representations. DCNL Note: DCNL * The files spBUOut and sensorBUOut are assumed to be in the output format DCNL used for LPF experiment outputs. DCNL * BU outputs for some sample datasets are provided. Specify the name of the DCNL dataset as an option while running this script.'
def drawFile(dataset, matrix, patterns, cells, w, fnum): DCNL 'The similarity of two patterns in the bit-encoding space is displayed alongside DCNL their similarity in the sp-coinc space.'
def printOverlaps(comparedTo, coincs, seen): DCNL 'Compare the results and return True if success, False if failure DCNL Parameters: DCNL coincs:               Which cells are we comparing? DCNL comparedTo:           The set of 40 cells we being compared to (they have no overlap with seen) DCNL seen:                 Which of the cells we are comparing to have already been encountered. DCNL This helps glue together the unique and reused coincs'
def generatePlot(outputs, origData): DCNL 'Generates a table where each cell represent a frequency of pairs DCNL as described below. DCNL x coordinate is the % difference between input records (origData list), DCNL y coordinate is the % difference between corresponding output records.'
def generateRandomInput(numRecords, elemSize=400, numSet=42): DCNL 'Generates a set of input record DCNL Params: DCNL numRecords - how many records to generate DCNL elemSize - the size of each record (num 0s or 1s) DCNL numSet - how many 1s in each record DCNL Returns: a list of inputs'
def appendInputWithSimilarValues(inputs): DCNL 'Creates an \'one-off\' record for each record in the inputs. Appends new DCNL records to the same inputs list.'
def appendInputWithNSimilarValues(inputs, numNear=10): DCNL 'Creates a neighboring record for each record in the inputs and adds DCNL new records at the end of the inputs list'
def modifyBits(inputVal, maxChanges): DCNL 'Modifies up to maxChanges number of bits in the inputVal'
def getRandomWithMods(inputSpace, maxChanges): DCNL 'Returns a random selection from the inputSpace with randomly modified DCNL up to maxChanges number of bits.'
def testSP(): DCNL 'Run a SP test'
def testSPNew(): DCNL 'New version of the test'
def testSPFile(): DCNL 'Run test on the data file - the file has records previously encoded.'
def _generateCategory(filename='simple.csv', numSequences=2, elementsPerSeq=1, numRepeats=10): DCNL 'Generate a simple dataset. This contains a bunch of non-overlapping DCNL sequences. DCNL Parameters: DCNL filename:       name of the file to produce, including extension. It will DCNL be created in a \'datasets\' sub-directory within the DCNL directory containing this script. DCNL numSequences:   how many sequences to generate DCNL elementsPerSeq: length of each sequence DCNL numRepeats:     how many times to repeat each sequence in the output'
def _generateScalar(filename='simple.csv', numSequences=2, elementsPerSeq=1, numRepeats=10, stepSize=0.1, includeRandom=False): DCNL 'Generate a simple dataset. This contains a bunch of non-overlapping DCNL sequences of scalar values. DCNL Parameters: DCNL filename:       name of the file to produce, including extension. It will DCNL be created in a \'datasets\' sub-directory within the DCNL directory containing this script. DCNL numSequences:   how many sequences to generate DCNL elementsPerSeq: length of each sequence DCNL numRepeats:     how many times to repeat each sequence in the output DCNL stepSize:       how far apart each scalar is DCNL includeRandom:  if true, include another random field'
def getSearch(rootDir): DCNL 'This method returns search description. See the following file for the DCNL schema of the dictionary this method returns: DCNL py/nupic/swarming/exp_generator/experimentDescriptionSchema.json DCNL The streamDef element defines the stream for this model. The schema for this DCNL element can be found at: DCNL py/nupicengine/cluster/database/StreamDef.json'
def chunk(l, n): DCNL 'Yield n successive chunks from l.'
def slice_sampler(px, N=1, x=None): DCNL 'Provides samples from a user-defined distribution. DCNL slice_sampler(px, N = 1, x = None) DCNL Inputs: DCNL px = A discrete probability distribution. DCNL N  = Number of samples to return, default is 1 DCNL x  = Optional list/array of observation values to return, where prob(x) = px. DCNL Outputs: DCNL If x=None (default) or if len(x) != len(px), it will return an array of integers DCNL between 0 and len(px)-1. If x is supplied, it will return the DCNL samples from x according to the distribution px.'
def _generateCategory(filename='simple.csv', numSequences=2, elementsPerSeq=1, numRepeats=10, resets=False): DCNL 'Generate a simple dataset. This contains a bunch of non-overlapping DCNL sequences. DCNL Parameters: DCNL filename:       name of the file to produce, including extension. It will DCNL be created in a \'datasets\' sub-directory within the DCNL directory containing this script. DCNL numSequences:   how many sequences to generate DCNL elementsPerSeq: length of each sequence DCNL numRepeats:     how many times to repeat each sequence in the output DCNL resets:         if True, turn on reset at start of each sequence'
def _generateScalar(filename='simple.csv', numSequences=2, elementsPerSeq=1, numRepeats=10, stepSize=0.1, resets=False): DCNL 'Generate a simple dataset. This contains a bunch of non-overlapping DCNL sequences of scalar values. DCNL Parameters: DCNL filename:       name of the file to produce, including extension. It will DCNL be created in a \'datasets\' sub-directory within the DCNL directory containing this script. DCNL numSequences:   how many sequences to generate DCNL elementsPerSeq: length of each sequence DCNL numRepeats:     how many times to repeat each sequence in the output DCNL stepSize:       how far apart each scalar is DCNL resets:         if True, turn on reset at start of each sequence'
def _generateOverlapping(filename='overlap.csv', numSequences=2, elementsPerSeq=3, numRepeats=10, hub=[0, 1], hubOffset=1, resets=False): DCNL 'Generate a temporal dataset containing sequences that overlap one or more DCNL elements with other sequences. DCNL Parameters: DCNL filename:       name of the file to produce, including extension. It will DCNL be created in a \'datasets\' sub-directory within the DCNL directory containing this script. DCNL numSequences:   how many sequences to generate DCNL elementsPerSeq: length of each sequence DCNL numRepeats:     how many times to repeat each sequence in the output DCNL hub:            sub-sequence to place within each other sequence DCNL hubOffset:      where, within each sequence, to place the hub DCNL resets:         if True, turn on reset at start of each sequence'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def permutationFilter(perm): DCNL 'This function can be used to selectively filter out specific permutation DCNL combinations. It is called by RunPermutations for every possible permutation DCNL of the variables in the permutations dict. It should return True for valid a DCNL combination of permutation values and False for an invalid one. DCNL Parameters: DCNL perm: dict of one possible combination of name:value DCNL pairs chosen from permutations.'
def _generateSimple(filename='simple.csv', numSequences=2, elementsPerSeq=1, numRepeats=10, resets=False): DCNL 'Generate a simple dataset. This contains a bunch of non-overlapping DCNL sequences. DCNL Parameters: DCNL filename:       name of the file to produce, including extension. It will DCNL be created in a \'datasets\' sub-directory within the DCNL directory containing this script. DCNL numSequences:   how many sequences to generate DCNL elementsPerSeq: length of each sequence DCNL numRepeats:     how many times to repeat each sequence in the output DCNL resets:         if True, turn on reset at start of each sequence'
def _generateOverlapping(filename='overlap.csv', numSequences=2, elementsPerSeq=3, numRepeats=10, hub=[0, 1], hubOffset=1, resets=False): DCNL 'Generate a temporal dataset containing sequences that overlap one or more DCNL elements with other sequences. DCNL Parameters: DCNL filename:       name of the file to produce, including extension. It will DCNL be created in a \'datasets\' sub-directory within the DCNL directory containing this script. DCNL numSequences:   how many sequences to generate DCNL elementsPerSeq: length of each sequence DCNL numRepeats:     how many times to repeat each sequence in the output DCNL hub:            sub-sequence to place within each other sequence DCNL hubOffset:      where, within each sequence, to place the hub DCNL resets:         if True, turn on reset at start of each sequence'
def _generateFirstOrder0(): DCNL 'Generate the initial, first order, and second order transition DCNL probabilities for \'probability0\'. For this model, we generate the following DCNL set of sequences: DCNL .1   .75 DCNL 0----1-----2 DCNL \    \  .25 DCNL \    \-----3 DCNL \ .9     .5 DCNL \--- 4--------- 2 DCNL \   .5 DCNL \---------3 DCNL Parameters: DCNL retval: (initProb, firstOrder, secondOrder, seqLen) DCNL initProb:     Initial probability for each category. This is a vector DCNL of length len(categoryList). DCNL firstOrder:   A dictionary of the 1st order probabilities. The key DCNL is the 1st element of the sequence, the value is DCNL the probability of each 2nd element given the first. DCNL secondOrder:  A dictionary of the 2nd order probabilities. The key DCNL is the first 2 elements of the sequence, the value is DCNL the probability of each possible 3rd element given the DCNL first two. DCNL seqLen:       Desired length of each sequence. The 1st element will DCNL be generated using the initProb, the 2nd element by the DCNL firstOrder table, and the 3rd and all successive DCNL elements by the secondOrder table. DCNL categoryList:  list of category names to use DCNL Here is an example of some return values when there are 3 categories DCNL initProb:         [0.7, 0.2, 0.1] DCNL firstOrder:       {\'[0]\': [0.3, 0.3, 0.4], DCNL \'[1]\': [0.3, 0.3, 0.4], DCNL \'[2]\': [0.3, 0.3, 0.4]} DCNL secondOrder:      {\'[0,0]\': [0.3, 0.3, 0.4], DCNL \'[0,1]\': [0.3, 0.3, 0.4], DCNL \'[0,2]\': [0.3, 0.3, 0.4], DCNL \'[1,0]\': [0.3, 0.3, 0.4], DCNL \'[1,1]\': [0.3, 0.3, 0.4], DCNL \'[1,2]\': [0.3, 0.3, 0.4], DCNL \'[2,0]\': [0.3, 0.3, 0.4], DCNL \'[2,1]\': [0.3, 0.3, 0.4], DCNL \'[2,2]\': [0.3, 0.3, 0.4]}'
def _generateFileFromProb(filename, numRecords, categoryList, initProb, firstOrderProb, secondOrderProb, seqLen, numNoise=0, resetsEvery=None): DCNL 'Generate a set of records reflecting a set of probabilities. DCNL Parameters: DCNL filename:         name of .csv file to generate DCNL numRecords:       number of records to generate DCNL categoryList:     list of category names DCNL initProb:         Initial probability for each category. This is a vector DCNL of length len(categoryList). DCNL firstOrderProb:   A dictionary of the 1st order probabilities. The key DCNL is the 1st element of the sequence, the value is DCNL the probability of each 2nd element given the first. DCNL secondOrderProb:  A dictionary of the 2nd order probabilities. The key DCNL is the first 2 elements of the sequence, the value is DCNL the probability of each possible 3rd element given the DCNL first two. If this is None, then the sequences will be DCNL first order only. DCNL seqLen:           Desired length of each sequence. The 1st element will DCNL be generated using the initProb, the 2nd element by the DCNL firstOrder table, and the 3rd and all successive DCNL elements by the secondOrder table. None means infinite DCNL length. DCNL numNoise:         Number of noise elements to place between each DCNL sequence. The noise elements are evenly distributed from DCNL all categories. DCNL resetsEvery:      If not None, generate a reset every N records DCNL Here is an example of some parameters: DCNL categoryList:     [\'cat1\', \'cat2\', \'cat3\'] DCNL initProb:         [0.7, 0.2, 0.1] DCNL firstOrderProb:   {\'[0]\': [0.3, 0.3, 0.4], DCNL \'[1]\': [0.3, 0.3, 0.4], DCNL \'[2]\': [0.3, 0.3, 0.4]} DCNL secondOrderProb:  {\'[0,0]\': [0.3, 0.3, 0.4], DCNL \'[0,1]\': [0.3, 0.3, 0.4], DCNL \'[0,2]\': [0.3, 0.3, 0.4], DCNL \'[1,0]\': [0.3, 0.3, 0.4], DCNL \'[1,1]\': [0.3, 0.3, 0.4], DCNL \'[1,2]\': [0.3, 0.3, 0.4], DCNL \'[2,0]\': [0.3, 0.3, 0.4], DCNL \'[2,1]\': [0.3, 0.3, 0.4], DCNL \'[2,2]\': [0.3, 0.3, 0.4]}'
def _generateSimple(filename='simple.csv', numSequences=1, elementsPerSeq=3, numRepeats=10): DCNL 'Generate a simple dataset. This contains a bunch of non-overlapping DCNL sequences. DCNL At the end of the dataset, we introduce missing records so that test DCNL code can insure that the model didn\'t get confused by them. DCNL Parameters: DCNL filename:       name of the file to produce, including extension. It will DCNL be created in a \'datasets\' sub-directory within the DCNL directory containing this script. DCNL numSequences:   how many sequences to generate DCNL elementsPerSeq: length of each sequence DCNL numRepeats:     how many times to repeat each sequence in the output'
def runCPU(): DCNL 'Poll CPU usage, make predictions, and plot the results. Runs forever.'
def createModel(modelParams): DCNL 'Given a model params dictionary, create a CLA Model. Automatically enables DCNL inference for kw_energy_consumption. DCNL :param modelParams: Model params dict DCNL :return: OPF Model object'
def getModelParamsFromName(gymName): DCNL 'Given a gym name, assumes a matching model params python module exists within DCNL the model_params directory and attempts to import it. DCNL :param gymName: Gym name, used to guess the model params module name. DCNL :return: OPF Model params dictionary'
def runIoThroughNupic(inputData, model, gymName, plot): DCNL 'Handles looping over the input data and passing each row into the given model DCNL object, as well as extracting the result object and passing it into an output DCNL handler. DCNL :param inputData: file path to input data CSV DCNL :param model: OPF Model object DCNL :param gymName: Gym name, used for output handler naming DCNL :param plot: Whether to use matplotlib or not. If false, uses file output.'
def runModel(gymName, plot=False): DCNL 'Assumes the gynName corresponds to both a like-named model_params file in the DCNL model_params directory, and that the data exists in a like-named CSV file in DCNL the current directory. DCNL :param gymName: Important for finding model params and input CSV file DCNL :param plot: Plot in matplotlib? Don\'t use this unless matplotlib is DCNL installed.'
def _setRandomEncoderResolution(minResolution=0.001): DCNL 'Given model params, figure out the correct resolution for the DCNL RandomDistributed encoder. Modifies params in place.'
def percentOverlap(x1, x2, size): DCNL 'Computes the percentage of overlap between vectors x1 and x2. DCNL @param x1   (array) binary vector DCNL @param x2   (array) binary vector DCNL @param size (int)   length of binary vectors DCNL @return percentOverlap (float) percentage overlap between x1 and x2'
def corruptVector(vector, noiseLevel): DCNL 'Corrupts a binary vector by inverting noiseLevel percent of its bits. DCNL @param vector     (array) binary vector to be corrupted DCNL @param noiseLevel (float) amount of noise to be applied on the vector.'
def resetVector(x1, x2): DCNL 'Copies the contents of vector x1 into vector x2. DCNL @param x1 (array) binary vector to be copied DCNL @param x2 (array) binary vector where x1 is copied'
def createEncoder(): DCNL 'Creates and returns a #MultiEncoder including a ScalarEncoder for DCNL energy consumption and a DateEncoder for the time of the day. DCNL @see nupic/encoders/__init__.py for type to file-name mapping DCNL @see nupic/encoders for encoder source files'
def createRecordSensor(network, name, dataSource): DCNL 'Creates a RecordSensor region that allows us to specify a file record DCNL stream as the input source.'
def createNetwork(dataSource): DCNL 'Creates and returns a new Network with a sensor region reading data from DCNL \'dataSource\'. There are two hierarchical levels, each with one SP and one TM. DCNL @param dataSource - A RecordStream containing the input data DCNL @returns a Network ready to run'
def runNetwork(network, numRecords, writer): DCNL 'Runs specified Network writing the ensuing anomaly DCNL scores to writer. DCNL @param network: The Network instance to be run DCNL @param writer: A csv.writer used to write to output file.'
def createEncoder(): DCNL 'Create the encoder instance for our test and return it.'
def createNetwork(dataSource): DCNL 'Create the Network instance. DCNL The network has a sensor region reading data from `dataSource` and passing DCNL the encoded representation to an Identity Region. DCNL :param dataSource: a RecordStream instance to get data from DCNL :returns: a Network instance ready to run'
def runNetwork(network, writer): DCNL 'Run the network and write output to writer. DCNL :param network: a Network instance to run DCNL :param writer: a csv.writer instance to write output to'
def createEncoder(): DCNL 'Create the encoder instance for our test and return it.'
def createNetwork(dataSource): DCNL 'Create the Network instance. DCNL The network has a sensor region reading data from `dataSource` and passing DCNL the encoded representation to an SPRegion. The SPRegion output is passed to DCNL a TMRegion. DCNL :param dataSource: a RecordStream instance to get data from DCNL :returns: a Network instance ready to run'
def runNetwork(network, writer): DCNL 'Run the network and write output to writer. DCNL :param network: a Network instance to run DCNL :param writer: a csv.writer instance to write output to'
def createTemporalAnomaly(recordParams, spatialParams=_SP_PARAMS, temporalParams=_TM_PARAMS, verbosity=_VERBOSITY): DCNL 'Generates a Network with connected RecordSensor, SP, TM. DCNL This function takes care of generating regions and the canonical links. DCNL The network has a sensor region reading data from a specified input and DCNL passing the encoded representation to an SPRegion. DCNL The SPRegion output is passed to a TMRegion. DCNL Note: this function returns a network that needs to be initialized. This DCNL allows the user to extend the network by adding further regions and DCNL connections. DCNL :param recordParams: a dict with parameters for creating RecordSensor region. DCNL :param spatialParams: a dict with parameters for creating SPRegion. DCNL :param temporalParams: a dict with parameters for creating TMRegion. DCNL :param verbosity: an integer representing how chatty the network will be.'
def runNetwork(network, writer): DCNL 'Run the network and write output to writer. DCNL :param network: a Network instance to run DCNL :param writer: a csv.writer instance to write output to'
def accuracy(current, predicted): DCNL 'Computes the accuracy of the TM at time-step t based on the prediction DCNL at time-step t-1 and the current active columns at time-step t. DCNL @param current (array) binary vector containing current active columns DCNL @param predicted (array) binary vector containing predicted active columns DCNL @return acc (float) prediction accuracy of the TM at time-step t'
def corruptVector(v1, noiseLevel, numActiveCols): DCNL 'Corrupts a copy of a binary vector by inverting noiseLevel percent of its bits. DCNL @param v1      (array) binary vector whose copy will be corrupted DCNL @param noiseLevel  (float) amount of noise to be applied on the new vector DCNL @param numActiveCols (int)   number of sparse columns that represent an input DCNL @return v2 (array) corrupted binary vector'
def showPredictions(): DCNL 'Shows predictions of the TM when presented with the characters A, B, C, D, X, and DCNL Y without any contextual information, that is, not embedded within a sequence.'
def trainTM(sequence, timeSteps, noiseLevel): DCNL 'Trains the TM with given sequence for a given number of time steps and level of input DCNL corruption DCNL @param sequence   (array) array whose rows are the input characters DCNL @param timeSteps  (int)   number of time steps in which the TM will be presented with sequence DCNL @param noiseLevel (float) amount of noise to be applied on the characters in the sequence'
def generatePattern(numCols=100, minOnes=21, maxOnes=25, colSet=[], prevPattern=numpy.array([])): DCNL 'Generate a single test pattern with given parameters. DCNL Parameters: DCNL numCols:                Number of columns in each pattern. DCNL minOnes:                The minimum number of 1\'s in each pattern. DCNL maxOnes:                The maximum number of 1\'s in each pattern. DCNL colSet:                 The set of column indices for the pattern. DCNL prevPattern:            Pattern to avoid (null intersection).'
def buildTrainingSet(numSequences=2, sequenceLength=100, pctShared=0.2, seqGenMode='shared DCSP sequence', subsequenceStartPos=10, numCols=100, minOnes=21, maxOnes=25, disjointConsecutive=True): DCNL 'Build random high order test sequences. DCNL Parameters: DCNL numSequences:           The number of sequences created. DCNL sequenceLength:         The length of each sequence. DCNL pctShared:              The percentage of sequenceLength that is shared across DCNL every sequence. If sequenceLength is 100 and pctShared DCNL is 0.2, then a subsequence consisting of 20 patterns DCNL will be in every sequence. Can also be the keyword DCNL \'one pattern\', in which case a single time step is DCNL shared. DCNL seqGenMode:             What kind of sequence to generate. If contains \'shared\' DCNL generates shared subsequence. If contains \'no shared\', DCNL does not generate any shared subsequence. If contains DCNL \'shuffle\', will use common patterns shuffle among the DCNL different sequences. If contains \'beginning\', will DCNL place shared subsequence at the beginning. DCNL subsequenceStartPos:    The position where the shared subsequence starts DCNL numCols:                Number of columns in each pattern. DCNL minOnes:                The minimum number of 1\'s in each pattern. DCNL maxOnes:                The maximum number of 1\'s in each pattern. DCNL disjointConsecutive:    Whether to generate disjoint consecutive patterns or not.'
def getSimplePatterns(numOnes, numPatterns): DCNL 'Very simple patterns. Each pattern has numOnes consecutive DCNL bits on. There are numPatterns*numOnes bits in the vector.'
def buildSimpleTrainingSet(numOnes=5): DCNL 'Two very simple high order sequences for debugging. Each pattern in the DCNL sequence has a series of 1\'s in a specific set of columns.'
def buildAlternatingTrainingSet(numOnes=5): DCNL 'High order sequences that alternate elements. Pattern i has one\'s in DCNL i*numOnes to (i+1)*numOnes. DCNL The sequences are: DCNL A B A B A C DCNL A B A B D E DCNL A B F G H I DCNL A J K L M N'
def buildHL0aTrainingSet(numOnes=5): DCNL 'Simple sequences for HL0. Each pattern in the sequence has a series of 1\'s DCNL in a specific set of columns. DCNL There are 23 patterns, p0 to p22. DCNL The sequence we want to learn is p0->p1->p2 DCNL We create a very long sequence consisting of N N p0 p1 p2 N N p0 p1 p2 DCNL N is randomly chosen from p3 to p22'
def buildHL0bTrainingSet(numOnes=5): DCNL 'Simple sequences for HL0b. Each pattern in the sequence has a series of 1\'s DCNL in a specific set of columns. DCNL There are 23 patterns, p0 to p22. DCNL The sequences we want to learn are p1->p2->p3 and p0->p1->p2->p4. DCNL We create a very long sequence consisting of these two sub-sequences DCNL intermixed with noise, such as: DCNL N N p0 p1 p2 p4 N N p1 p2 p3 N N p1 p2 p3 DCNL N is randomly chosen from p5 to p22'
def findAcceptablePatterns(tm, t, whichSequence, trainingSequences, nAcceptable=1): DCNL 'Tries to infer the set of acceptable patterns for prediction at the given DCNL time step and for the give sequence. Acceptable patterns are: the current one, DCNL plus a certain number of patterns after timeStep, in the sequence that the TM DCNL is currently tracking. Any other pattern is not acceptable. DCNL TODO: DCNL - Doesn\'t work for noise cases. DCNL - Might run in trouble if shared subsequence at the beginning. DCNL Parameters: DCNL tm                       the whole TM, so that we can look at its parameters DCNL t                        the current time step DCNL whichSequence            the sequence we are currently tracking DCNL trainingSequences        all the training sequences DCNL nAcceptable              the number of steps forward from the current timeStep DCNL we are willing to consider acceptable. In the case of DCNL pooling, it is less than or equal to the min of the DCNL number of training reps and the segUpdateValidDuration DCNL parameter of the TM, depending on the test case. DCNL The default value is 1, because by default, the pattern DCNL after the current one should always be predictable. DCNL Return value: DCNL acceptablePatterns       A list of acceptable patterns for prediction.'
def testSequence(trainingSequences, nTrainingReps=1, numberOfCols=40, cellsPerColumn=5, initialPerm=0.8, connectedPerm=0.7, minThreshold=11, newSynapseCount=5, permanenceInc=0.4, permanenceDec=0.0, permanenceMax=1, globalDecay=0.0, pamLength=1000, activationThreshold=5, acceptablePatterns=[], doPooling=False, nAcceptable=(-1), noiseModel=None, noiseLevel=0, doResets=True, shouldFail=False, testSequences=None, predJustAfterHubOnly=None, compareToPy=False, nMultiStepPrediction=0, highOrder=False): DCNL 'Test a single set of sequences once and return the number of DCNL prediction failures, the number of errors, and the number of perfect DCNL predictions'
def TestH2a(sequenceLength, nTests, cellsPerColumn, numCols=100, nSequences=[2], pctShared=0.02, seqGenMode='shared DCSP sequence', shouldFail=False): DCNL 'Still need to test: DCNL Two overlapping sequences. OK to get new segments but check that we can DCNL get correct high order prediction after multiple reps.'
def worker(x): DCNL 'Worker function to use in parallel hub capacity test below.'
def hubCapacity(): DCNL 'Study hub capacity. Figure out how many sequences can share a pattern DCNL for a given number of cells per column till we the system fails. DCNL DON\'T RUN IN BUILD SYSTEM!!! (takes too long)'
def printOneTrainingVector(x): DCNL 'Print a single vector succinctly.'
def getSimplePatterns(numOnes, numPatterns, patternOverlap=0): DCNL 'Very simple patterns. Each pattern has numOnes consecutive DCNL bits on. The amount of overlap between consecutive patterns is DCNL configurable, via the patternOverlap parameter. DCNL Parameters: DCNL numOnes:        Number of bits ON in each pattern DCNL numPatterns:    Number of unique patterns to generate DCNL patternOverlap: Number of bits of overlap between each successive pattern DCNL retval:         patterns'
def buildOverlappedSequences(numSequences=2, seqLen=5, sharedElements=[3, 4], numOnBitsPerPattern=3, patternOverlap=0, seqOverlap=0, **kwargs): DCNL 'Create training sequences that share some elements in the middle. DCNL Parameters: DCNL numSequences:         Number of unique training sequences to generate DCNL seqLen:               Overall length of each sequence DCNL sharedElements:       Which element indices of each sequence are shared. These DCNL will be in the range between 0 and seqLen-1 DCNL numOnBitsPerPattern:  Number of ON bits in each TM input pattern DCNL patternOverlap:       Max number of bits of overlap between any 2 patterns DCNL retval:               (numCols, trainingSequences) DCNL numCols - width of the patterns DCNL trainingSequences - a list of training sequences'
def buildSequencePool(numSequences=10, seqLen=[2, 3, 4], numPatterns=5, numOnBitsPerPattern=3, patternOverlap=0, **kwargs): DCNL 'Create a bunch of sequences of various lengths, all built from DCNL a fixed set of patterns. DCNL Parameters: DCNL numSequences:         Number of training sequences to generate DCNL seqLen:               List of possible sequence lengths DCNL numPatterns:          How many possible patterns there are to use within DCNL sequences DCNL numOnBitsPerPattern:  Number of ON bits in each TM input pattern DCNL patternOverlap:       Max number of bits of overlap between any 2 patterns DCNL retval:               (numCols, trainingSequences) DCNL numCols - width of the patterns DCNL trainingSequences - a list of training sequences'
def createTMs(includeCPP=True, includePy=True, numCols=100, cellsPerCol=4, activationThreshold=3, minThreshold=3, newSynapseCount=3, initialPerm=0.6, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, checkSynapseConsistency=True, maxInfBacktrack=0, maxLrnBacktrack=0, **kwargs): DCNL 'Create one or more TM instances, placing each into a dict keyed by DCNL name. DCNL Parameters: DCNL retval:   tms - dict of TM instances'
def assertNoTMDiffs(tms): DCNL 'Check for diffs among the TM instances in the passed in tms dict and DCNL raise an assert if any are detected DCNL Parameters: DCNL tms:                  dict of TM instances'
def evalSequences(tms, trainingSequences, testSequences=None, nTrainRepetitions=1, doResets=True, **kwargs): DCNL 'Train the TMs on the entire training set for nTrainRepetitions in a row. DCNL Then run the test set through inference once and return the inference stats. DCNL Parameters: DCNL tms:                  dict of TM instances DCNL trainingSequences:    list of training sequences. Each sequence is a list DCNL of TM input patterns DCNL testSequences:        list of test sequences. If None, we will test against DCNL the trainingSequences DCNL nTrainRepetitions:    Number of times to run the training set through the TM DCNL doResets:             If true, send a reset to the TM between each sequence'
def testConfig(baseParams, expMissingMin=0, expMissingMax=0, **mods): DCNL 'Build up a set of sequences, create the TM(s), train them, test them, DCNL and check that we got the expected number of missing predictions during DCNL inference. DCNL Parameters: DCNL baseParams:     dict of all of the parameters for building sequences, DCNL creating the TMs, and training and testing them. This DCNL gets updated from \'mods\' before we use it. DCNL expMissingMin:   Minimum number of expected missing predictions during testing. DCNL expMissingMax:   Maximum number of expected missing predictions during testing. DCNL mods:           dict of modifications to make to the baseParams.'
def _printOneTrainingVector(x): DCNL 'Print a single vector succinctly.'
def _getSimplePatterns(numOnes, numPatterns): DCNL 'Very simple patterns. Each pattern has numOnes consecutive DCNL bits on. There are numPatterns*numOnes bits in the vector. These patterns DCNL are used as elements of sequences when building up a training set.'
def _createTms(numCols): DCNL 'Create two instances of temporal poolers (backtracking_tm.py DCNL and backtracking_tm_cpp.py) with identical parameter settings.'
def getVersion(): DCNL 'Get version from local file.'
def nupicBindingsPrereleaseInstalled(): DCNL 'Make an attempt to determine if a pre-release version of nupic.bindings is DCNL installed already. DCNL @return: boolean'
def findRequirements(): DCNL 'Read the requirements.txt file and parse into requirements for setup\'s DCNL install_requirements option.'
def runPermutations(args): DCNL 'The main function of the RunPermutations utility. DCNL This utility will automatically generate and run multiple prediction framework DCNL experiments that are permutations of a base experiment via the Grok engine. DCNL For example, if you have an experiment that you want to test with 3 possible DCNL values of variable A and 2 possible values of variable B, this utility will DCNL automatically generate the experiment directories and description files for DCNL each of the 6 different experiments. DCNL Here is an example permutations file which is read by this script below. The DCNL permutations file must be in the same directory as the description.py for the DCNL base experiment that you want to permute. It contains a permutations dict, an DCNL optional list of the result items to report on for each experiment, and an DCNL optional result item to optimize for. DCNL When an \'optimize\' entry is provided, this tool will attempt to prioritize the DCNL order in which the various permutations are run in order to improve the odds DCNL of running the best permutations sooner. It does this by watching the results DCNL for various parameter values and putting parameter values that give generally DCNL better results at the head of the queue. DCNL In addition, when the optimize key is provided, we periodically update the UI DCNL with the best results obtained so far on that metric. DCNL permutations = dict( DCNL iterationCount = [1000, 5000], DCNL coincCount = [50, 100], DCNL trainTP = [False], DCNL report = [\'.*reconstructErrAvg\', DCNL \'.*inputPredScore.*\', DCNL optimize = \'postProc_gym1_baseline:inputPredScore\' DCNL Parameters: DCNL args:           Command-line args; the equivalent of sys.argv[1:] DCNL retval:         for the actions \'run\', \'pickup\', and \'dryRun\', returns the DCNL Hypersearch job ID (in ClinetJobs table); otherwise returns DCNL None'
def main(): DCNL 'Run according to options in sys.argv and diff classifiers.'
def collect_set(option, opt_str, value, parser): DCNL 'Collect multiple option values into a single set.  Used in conjunction DCNL with callback argument to OptionParser.add_option().'
def collect_list(option, opt_str, value, parser): DCNL 'Collect multiple option values into a single list.  Used in conjunction DCNL with callback argument to OptionParser.add_option().'
def main(parser, parse_args): DCNL 'Parse CLI options and execute tests'
def profileSP(spClass, spDim, nRuns): DCNL 'profiling performance of SpatialPooler (SP) DCNL using the python cProfile module and ordered by cumulative time, DCNL see how to run on command-line above. DCNL @param spClass implementation of SP (cpp, py, ..) DCNL @param spDim number of columns in SP (in 1D, for 2D see colDim in code) DCNL @param nRuns number of calls of the profiled code (epochs)'
def profileTM(tmClass, tmDim, nRuns): DCNL 'profiling performance of TemporalMemory (TM) DCNL using the python cProfile module and ordered by cumulative time, DCNL see how to run on command-line above. DCNL @param tmClass implementation of TM (cpp, py, ..) DCNL @param tmDim number of columns in TM DCNL @param nRuns number of calls of the profiled code (epochs)'
def _paramsFileHead(): DCNL 'This is the first portion of every sub-experiment params file we generate. Between DCNL the head and the tail are the experiment specific options.'
def _paramsFileTail(): DCNL 'This is the tail of every params file we generate. Between the head and the tail DCNL are the experiment specific options.'
def _appendReportKeys(keys, prefix, results): DCNL 'Generate a set of possible report keys for an experiment\'s results. DCNL A report key is a string of key names separated by colons, each key being one DCNL level deeper into the experiment results dict. For example, \'key1:key2\'. DCNL This routine is called recursively to build keys that are multiple levels DCNL deep from the results dict. DCNL Parameters: DCNL keys:         Set of report keys accumulated so far DCNL prefix:       prefix formed so far, this is the colon separated list of key DCNL names that led up to the dict passed in results DCNL results:      dictionary of results at this level.'
def _matchReportKeys(reportKeyREs=[], allReportKeys=[]): DCNL 'Extract all items from the \'allKeys\' list whose key matches one of the regular DCNL expressions passed in \'reportKeys\'. DCNL Parameters: DCNL reportKeyREs:     List of regular expressions DCNL allReportKeys:    List of all keys DCNL retval:         list of keys from allReportKeys that match the regular expressions DCNL in \'reportKeyREs\' DCNL If an invalid regular expression was included in \'reportKeys\', DCNL then BadKeyError() is raised'
def _getReportItem(itemName, results): DCNL 'Get a specific item by name out of the results dict. DCNL The format of itemName is a string of dictionary keys separated by colons, DCNL each key being one level deeper into the results dict. For example, DCNL \'key1:key2\' would fetch results[\'key1\'][\'key2\']. DCNL If itemName is not found in results, then None is returned'
def filterResults(allResults, reportKeys, optimizeKey=None): DCNL 'Given the complete set of results generated by an experiment (passed in DCNL \'results\'), filter out and return only the ones the caller wants, as DCNL specified through \'reportKeys\' and \'optimizeKey\'. DCNL A report key is a string of key names separated by colons, each key being one DCNL level deeper into the experiment results dict. For example, \'key1:key2\'. DCNL Parameters: DCNL results:             dict of all results generated by an experiment DCNL reportKeys:          list of items from the results dict to include in DCNL the report. These can be regular expressions. DCNL optimizeKey:         Which report item, if any, we will be optimizing for. This can DCNL also be a regular expression, but is an error if it matches DCNL more than one key from the experiment\'s results. DCNL retval:  (reportDict, optimizeDict) DCNL reportDict: a dictionary of the metrics named by desiredReportKeys DCNL optimizeDict: A dictionary containing 1 item: the full name and DCNL value of the metric identified by the optimizeKey'
def _quoteAndEscape(string): DCNL 'string:   input string (ascii or unicode) DCNL Returns:  a quoted string with characters that are represented in python via DCNL escape sequences converted to those escape sequences'
def _handleModelRunnerException(jobID, modelID, jobsDAO, experimentDir, logger, e): DCNL 'Perform standard handling of an exception that occurs while running DCNL a model. DCNL Parameters: DCNL jobID:                ID for this hypersearch job in the jobs table DCNL modelID:              model ID DCNL jobsDAO:              ClientJobsDAO instance DCNL experimentDir:        directory containing the experiment DCNL logger:               the logger to use DCNL e:                    the exception that occurred DCNL retval:               (completionReason, completionMsg)'
def runModelGivenBaseAndParams(modelID, jobID, baseDescription, params, predictedField, reportKeys, optimizeKey, jobsDAO, modelCheckpointGUID, logLevel=None, predictionCacheMaxRecords=None): DCNL 'This creates an experiment directory with a base.py description file DCNL created from \'baseDescription\' and a description.py generated from the DCNL given params dict and then runs the experiment. DCNL Parameters: DCNL modelID:              ID for this model in the models table DCNL jobID:                ID for this hypersearch job in the jobs table DCNL baseDescription:      Contents of a description.py with the base experiment DCNL description DCNL params:               Dictionary of specific parameters to override within DCNL the baseDescriptionFile. DCNL predictedField:       Name of the input field for which this model is being DCNL optimized DCNL reportKeys:           Which metrics of the experiment to store into the DCNL results dict of the model\'s database entry DCNL optimizeKey:          Which metric we are optimizing for DCNL jobsDAO               Jobs data access object - the interface to the DCNL jobs database which has the model\'s table. DCNL modelCheckpointGUID:  A persistent, globally-unique identifier for DCNL constructing the model checkpoint key DCNL logLevel:             override logging level to this value, if not None DCNL retval:               (completionReason, completionMsg)'
def generatePersistentJobGUID(): DCNL 'Generates a "persistentJobGUID" value. DCNL Parameters: DCNL retval:          A persistentJobGUID value'
def rCopy(d, f=identityConversion, discardNoneKeys=True, deepCopy=True): DCNL 'Recursively copies a dict and returns the result. DCNL Args: DCNL d: The dict to copy. DCNL f: A function to apply to values when copying that takes the value and the DCNL list of keys from the root of the dict to the value and returns a value DCNL for the new dict. DCNL discardNoneKeys: If True, discard key-value pairs when f returns None for DCNL the value. DCNL deepCopy: If True, all values in returned dict are true copies (not the DCNL same object). DCNL Returns: DCNL A new dict with keys and values from d replaced with the result of f.'
def rApply(d, f): DCNL 'Recursively applies f to the values in dict d. DCNL Args: DCNL d: The dict to recurse over. DCNL f: A function to apply to values in d that takes the value and a list of DCNL keys from the root of the dict to the value.'
def clippedObj(obj, maxElementSize=64): DCNL 'Return a clipped version of obj suitable for printing, This DCNL is useful when generating log messages by printing data structures, but DCNL don\'t want the message to be too long. DCNL If passed in a dict, list, or namedtuple, each element of the structure\'s DCNL string representation will be limited to \'maxElementSize\' characters. This DCNL will return a new object where the string representation of each element DCNL has been truncated to fit within maxElementSize.'
def validate(value, **kwds): DCNL 'Validate a python value against json schema: DCNL validate(value, schemaPath) DCNL validate(value, schemaDict) DCNL value:          python object to validate against the schema DCNL The json schema may be specified either as a path of the file containing DCNL the json schema or as a python dictionary using one of the DCNL following keywords as arguments: DCNL schemaPath:     Path of file containing the json schema object. DCNL schemaDict:     Python dictionary containing the json schema object DCNL Returns: nothing DCNL Raises: DCNL ValidationError when value fails json validation'
def loadJsonValueFromFile(inputFilePath): DCNL 'Loads a json value from a file and converts it to the corresponding python DCNL object. DCNL inputFilePath: DCNL Path of the json file; DCNL Returns: DCNL python value that represents the loaded json value'
def sortedJSONDumpS(obj): DCNL 'Return a JSON representation of obj with sorted keys on any embedded dicts. DCNL This insures that the same object will always be represented by the same DCNL string even if it contains dicts (where the sort order of the keys is DCNL normally undefined).'
def _makeUsageErrorStr(errorString, usageString): DCNL 'Combines an error string and usage string into a regular format, so they DCNL all look consistent.'
def _handleShowSchemaOption(): DCNL 'Displays command schema to stdout and exit program'
def _handleDescriptionOption(cmdArgStr, outDir, usageStr, hsVersion, claDescriptionTemplateFile): DCNL 'Parses and validates the --description option args and executes the DCNL request DCNL Parameters: DCNL cmdArgStr:  JSON string compatible with _gExperimentDescriptionSchema DCNL outDir:     where to place generated experiment files DCNL usageStr:   program usage string DCNL hsVersion:  which version of hypersearch permutations file to generate, can DCNL be \'v1\' or \'v2\' DCNL claDescriptionTemplateFile: Filename containing the template description DCNL retval:     nothing'
def _handleDescriptionFromFileOption(filename, outDir, usageStr, hsVersion, claDescriptionTemplateFile): DCNL 'Parses and validates the --descriptionFromFile option and executes the DCNL request DCNL Parameters: DCNL filename:   File from which we\'ll extract description JSON DCNL outDir:     where to place generated experiment files DCNL usageStr:   program usage string DCNL hsVersion:  which version of hypersearch permutations file to generate, can DCNL be \'v1\' or \'v2\' DCNL claDescriptionTemplateFile: Filename containing the template description DCNL retval:     nothing'
def _isInt(x, precision=0.0001): DCNL 'Return (isInt, intValue) for a given floating point number. DCNL Parameters: DCNL x:  floating point number to evaluate DCNL precision: desired precision DCNL retval:   (isInt, intValue) DCNL isInt: True if x is close enough to an integer value DCNL intValue: x as an integer'
def _isString(obj): DCNL 'returns whether or not the object is a string'
def _quoteAndEscape(string): DCNL 'string:   input string (ascii or unicode) DCNL Returns:  a quoted string with characters that are represented in python via DCNL escape sequences converted to those escape sequences'
def _indentLines(str, indentLevels=1, indentFirstLine=True): DCNL 'Indent all lines in the given string DCNL str:          input string DCNL indentLevels: number of levels of indentation to apply DCNL indentFirstLine: if False, the 1st line will not be indented DCNL Returns:      The result string with all lines indented'
def _isCategory(fieldType): DCNL 'Prediction function for determining whether a function is a categorical DCNL variable or a scalar variable.  Mainly used for determining the appropriate DCNL metrics.'
def _generateMetricSpecString(inferenceElement, metric, params=None, field=None, returnLabel=False): DCNL 'Generates the string representation of a MetricSpec object, and returns DCNL the metric key associated with the metric. DCNL Parameters: DCNL inferenceElement: DCNL An InferenceElement value that indicates which part of the inference this DCNL metric is computed on DCNL metric: DCNL The type of the metric being computed (e.g. aae, avg_error) DCNL params: DCNL A dictionary of parameters for the metric. The keys are the parameter names DCNL and the values should be the parameter values (e.g. window=200) DCNL field: DCNL The name of the field for which this metric is being computed DCNL returnLabel: DCNL If True, returns the label of the MetricSpec that was generated'
def _generateFileFromTemplates(templateFileNames, outputFilePath, replacementDict): DCNL 'Generates a file by applying token replacements to the given template DCNL file DCNL templateFileName: DCNL A list of template file names; these files are assumed to be in DCNL the same directory as the running experiment_generator.py script. DCNL ExpGenerator will perform the substitution and concanetate DCNL the files in the order they are specified DCNL outputFilePath: Absolute path of the output file DCNL replacementDict: DCNL A dictionary of token/replacement pairs'
def _generateEncoderChoicesV1(fieldInfo): DCNL 'Return a list of possible encoder parameter combinations for the given DCNL field and the default aggregation function to use. Each parameter combination DCNL is a dict defining the parameters for the encoder. Here is an example DCNL return value for the encoderChoicesList: DCNL None, DCNL {\'fieldname\':\'timestamp\', DCNL \'name\': \'timestamp_timeOfDay\', DCNL \'type\':\'DateEncoder\' DCNL \'dayOfWeek\': (7,1) DCNL {\'fieldname\':\'timestamp\', DCNL \'name\': \'timestamp_timeOfDay\', DCNL \'type\':\'DateEncoder\' DCNL \'dayOfWeek\': (7,3) DCNL Parameters: DCNL fieldInfo:      item from the \'includedFields\' section of the DCNL description JSON object DCNL retval:  (encoderChoicesList, aggFunction) DCNL encoderChoicesList: a list of encoder choice lists for this field. DCNL Most fields will generate just 1 encoder choice list. DCNL DateTime fields can generate 2 or more encoder choice lists, DCNL one for dayOfWeek, one for timeOfDay, etc. DCNL aggFunction: name of aggregation function to use for this DCNL field type'
def _generateEncoderStringsV1(includedFields): DCNL 'Generate and return the following encoder related substitution variables: DCNL encoderSpecsStr: DCNL For the base description file, this string defines the default DCNL encoding dicts for each encoder. For example: DCNL \'__gym_encoder\' : {   \'fieldname\': \'gym\', DCNL \'n\': 13, DCNL \'name\': \'gym\', DCNL \'type\': \'SDRCategoryEncoder\', DCNL \'w\': 7}, DCNL \'__address_encoder\' : {   \'fieldname\': \'address\', DCNL \'n\': 13, DCNL \'name\': \'address\', DCNL \'type\': \'SDRCategoryEncoder\', DCNL \'w\': 7} DCNL encoderSchemaStr: DCNL For the base description file, this is a list containing a DCNL DeferredDictLookup entry for each encoder. For example: DCNL [DeferredDictLookup(\'__gym_encoder\'), DCNL DeferredDictLookup(\'__address_encoder\'), DCNL DeferredDictLookup(\'__timestamp_timeOfDay_encoder\'), DCNL DeferredDictLookup(\'__timestamp_dayOfWeek_encoder\'), DCNL DeferredDictLookup(\'__consumption_encoder\')], DCNL permEncoderChoicesStr: DCNL For the permutations file, this defines the possible DCNL encoder dicts for each encoder. For example: DCNL \'__timestamp_dayOfWeek_encoder\': [ DCNL None, DCNL {\'fieldname\':\'timestamp\', DCNL \'name\': \'timestamp_timeOfDay\', DCNL \'type\':\'DateEncoder\' DCNL \'dayOfWeek\': (7,1) DCNL {\'fieldname\':\'timestamp\', DCNL \'name\': \'timestamp_timeOfDay\', DCNL \'type\':\'DateEncoder\' DCNL \'dayOfWeek\': (7,3) DCNL \'__field_consumption_encoder\': [ DCNL None, DCNL {\'fieldname\':\'consumption\', DCNL \'name\': \'consumption\', DCNL \'type\':\'AdaptiveScalarEncoder\', DCNL \'n\': 13, DCNL \'w\': 7, DCNL Parameters: DCNL includedFields:  item from the \'includedFields\' section of the DCNL description JSON object. This is a list of dicts, each DCNL dict defining the field name, type, and optional min DCNL and max values. DCNL retval:  (encoderSpecsStr, encoderSchemaStr permEncoderChoicesStr)'
def _generatePermEncoderStr(options, encoderDict): DCNL 'Generate the string that defines the permutations to apply for a given DCNL encoder. DCNL Parameters: DCNL options: experiment params DCNL encoderDict: the encoder dict, which gets placed into the description.py DCNL For example, if the encoderDict contains: DCNL \'consumption\':     { DCNL \'clipInput\': True, DCNL \'fieldname\': u\'consumption\', DCNL \'n\': 100, DCNL \'name\': u\'consumption\', DCNL \'type\': \'AdaptiveScalarEncoder\', DCNL \'w\': 21}, DCNL The return string will contain: DCNL "PermuteEncoder(fieldName=\'consumption\', DCNL encoderClass=\'AdaptiveScalarEncoder\', DCNL w=21, DCNL n=PermuteInt(28, 521), DCNL clipInput=True)"'
def _generateEncoderStringsV2(includedFields, options): DCNL 'Generate and return the following encoder related substitution variables: DCNL encoderSpecsStr: DCNL For the base description file, this string defines the default DCNL encoding dicts for each encoder. For example: DCNL __gym_encoder = {   \'fieldname\': \'gym\', DCNL \'n\': 13, DCNL \'name\': \'gym\', DCNL \'type\': \'SDRCategoryEncoder\', DCNL \'w\': 7}, DCNL __address_encoder = {   \'fieldname\': \'address\', DCNL \'n\': 13, DCNL \'name\': \'address\', DCNL \'type\': \'SDRCategoryEncoder\', DCNL \'w\': 7} DCNL permEncoderChoicesStr: DCNL For the permutations file, this defines the possible DCNL encoder dicts for each encoder. For example: DCNL \'__gym_encoder\' : PermuteEncoder(\'gym\', \'SDRCategoryEncoder\', w=7, DCNL n=100), DCNL \'__address_encoder\' : PermuteEncoder(\'address\', \'SDRCategoryEncoder\', DCNL w=7, n=100), DCNL \'__timestamp_dayOfWeek_encoder\' : PermuteEncoder(\'timestamp\', DCNL \'DateEncoder.timeOfDay\', w=7, radius=PermuteChoices([1, 8])), DCNL \'__consumption_encoder\': PermuteEncoder(\'consumption\', \'AdaptiveScalarEncoder\', DCNL w=7, n=PermuteInt(13, 500, 20), minval=0, DCNL maxval=PermuteInt(100, 300, 25)), DCNL Parameters: DCNL includedFields:  item from the \'includedFields\' section of the DCNL description JSON object. This is a list of dicts, each DCNL dict defining the field name, type, and optional min DCNL and max values. DCNL retval:  (encoderSpecsStr permEncoderChoicesStr)'
def _handleJAVAParameters(options): DCNL 'Handle legacy options (TEMPORARY)'
def _getPropertyValue(schema, propertyName, options): DCNL 'Checks to see if property is specified in \'options\'. If not, reads the DCNL default value from the schema'
def _getExperimentDescriptionSchema(): DCNL 'Returns the experiment description schema. This implementation loads it in DCNL from file experimentDescriptionSchema.json. DCNL Parameters: DCNL Returns:    returns a dict representing the experiment description schema.'
def _generateExperiment(options, outputDirPath, hsVersion, claDescriptionTemplateFile): DCNL 'Executes the --description option, which includes: DCNL 1. Perform provider compatibility checks DCNL 2. Preprocess the training and testing datasets (filter, join providers) DCNL 3. If test dataset omitted, split the training dataset into training DCNL and testing datasets. DCNL 4. Gather statistics about the training and testing datasets. DCNL 5. Generate experiment scripts (description.py, permutaions.py) DCNL Parameters: DCNL options:  dictionary that matches the schema defined by the return value of DCNL _getExperimentDescriptionSchema();  NOTE: this arg may be modified DCNL by this function. DCNL outputDirPath:  where to place generated files DCNL hsVersion:  which version of hypersearch permutations file to generate, can DCNL be \'v1\' or \'v2\' DCNL claDescriptionTemplateFile: Filename containing the template description DCNL Returns:    on success, returns a dictionary per _experimentResultsJSONSchema; DCNL raises exception on error DCNL Assumption1: input train and test files have identical field metadata'
def _generateMetricsSubstitutions(options, tokenReplacements): DCNL 'Generate the token substitution for metrics related fields. DCNL This includes: DCNL \$METRICS DCNL \$LOGGED_METRICS DCNL \$PERM_OPTIMIZE_SETTING'
def _generateMetricSpecs(options): DCNL 'Generates the Metrics for a given InferenceType DCNL Parameters: DCNL options: ExpGenerator options DCNL retval: (metricsList, optimizeMetricLabel) DCNL metricsList: list of metric string names DCNL optimizeMetricLabel: Name of the metric which to optimize over'
def _generateExtraMetricSpecs(options): DCNL 'Generates the non-default metrics specified by the expGenerator params'
def _getPredictedField(options): DCNL 'Gets the predicted field and it\'s datatype from the options dictionary DCNL Returns: (predictedFieldName, predictedFieldType)'
def _generateInferenceArgs(options, tokenReplacements): DCNL 'Generates the token substitutions related to the predicted field DCNL and the supplemental arguments for prediction'
def expGenerator(args): DCNL 'Parses, validates, and executes command-line options; DCNL On success: Performs requested operation and exits program normally DCNL On Error:   Dumps exception/error info in JSON format to stdout and exits the DCNL program with non-zero status.'
def main(argv): DCNL 'The main function of the HypersearchWorker script. This parses the command DCNL line arguments, instantiates a HypersearchWorker instance, and then DCNL runs it. DCNL Parameters: DCNL retval:     jobID of the job we ran. This is used by unit test code DCNL when calling this working using the --params command DCNL line option (which tells this worker to insert the job DCNL itself).'
def clean(s): DCNL 'Removes trailing whitespace on each line.'
def Enum(*args, **kwargs): DCNL 'Utility function for creating enumerations in python DCNL Example Usage: DCNL >> Color = Enum("Red", "Green", "Blue", "Magenta") DCNL >> print Color.Red DCNL >> 0 DCNL >> print Color.Green DCNL >> 1 DCNL >> print Color.Blue DCNL >> 2 DCNL >> print Color.Magenta DCNL >> 3 DCNL >> Color.Violet DCNL >> \'violet\' DCNL >> Color.getLabel(Color.Red) DCNL >> \'Red\' DCNL >> Color.getLabel(2) DCNL >> \'Blue\''
def makeDirectoryFromAbsolutePath(absDirPath): DCNL 'Makes directory for the given directory path with default permissions. DCNL If the directory already exists, it is treated as success. DCNL absDirPath:   absolute path of the directory to create. DCNL Returns:      absDirPath arg DCNL Exceptions:         OSError if directory creation fails'
def createAndStartSwarm(client, clientInfo='', clientKey='', params='', minimumWorkers=None, maximumWorkers=None, alreadyRunning=False): DCNL 'Create and start a swarm job. DCNL Args: DCNL client - A string identifying the calling client. There is a small limit DCNL for the length of the value. See ClientJobsDAO.CLIENT_MAX_LEN. DCNL clientInfo - JSON encoded dict of client specific information. DCNL clientKey - Foreign key. Limited in length, see ClientJobsDAO._initTables. DCNL params - JSON encoded dict of the parameters for the job. This can be DCNL fetched out of the database by the worker processes based on the jobID. DCNL minimumWorkers - The minimum workers to allocate to the swarm. Set to None DCNL to use the default. DCNL maximumWorkers - The maximum workers to allocate to the swarm. Set to None DCNL to use the swarm default. Set to 0 to use the maximum scheduler value. DCNL alreadyRunning - Insert a job record for an already running process. Used DCNL for testing.'
def getSwarmModelParams(modelID): DCNL 'Retrieve the Engine-level model params from a Swarm model DCNL Args: DCNL modelID - Engine-level model ID of the Swarm model DCNL Returns: DCNL JSON-encoded string containing Model Params'
def _escape(s): DCNL 'Escape commas, tabs, newlines and dashes in a string DCNL Commas are encoded as tabs'
def _engineServicesRunning(): DCNL 'Return true if the engine services are running'
def runWithConfig(swarmConfig, options, outDir=None, outputLabel='default', permWorkDir=None, verbosity=1): DCNL 'Starts a swarm, given an dictionary configuration. DCNL @param swarmConfig {dict} A complete [swarm description](http://nupic.docs.numenta.org/0.7.0.dev0/guides/swarming/running.html#the-swarm-description) object. DCNL @param outDir {string} Optional path to write swarm details (defaults to DCNL current working directory). DCNL @param outputLabel {string} Optional label for output (defaults to "default"). DCNL @param permWorkDir {string} Optional location of working directory (defaults DCNL to current working directory). DCNL @param verbosity {int} Optional (1,2,3) increasing verbosity of output. DCNL @returns {object} Model parameters'
def runWithJsonFile(expJsonFilePath, options, outputLabel, permWorkDir): DCNL 'Starts a swarm, given a path to a JSON file containing configuration. DCNL This function is meant to be used with a CLI wrapper that passes command line DCNL arguments in through the options parameter. DCNL @param expJsonFilePath {string} Path to a JSON file containing the complete DCNL [swarm description](http://nupic.docs.numenta.org/0.7.0.dev0/guides/swarming/running.html#the-swarm-description). DCNL @param options {dict} CLI options. DCNL @param outputLabel {string} Label for output. DCNL @param permWorkDir {string} Location of working directory. DCNL @returns {int} Swarm job id.'
def runWithPermutationsScript(permutationsFilePath, options, outputLabel, permWorkDir): DCNL 'Starts a swarm, given a path to a permutations.py script. DCNL This function is meant to be used with a CLI wrapper that passes command line DCNL arguments in through the options parameter. DCNL @param permutationsFilePath {string} Path to permutations.py. DCNL @param options {dict} CLI options. DCNL @param outputLabel {string} Label for output. DCNL @param permWorkDir {string} Location of working directory. DCNL @returns {object} Model parameters.'
def runPermutations(_): DCNL 'DEPRECATED. Use @ref runWithConfig.'
def _clientJobsDB(): DCNL 'Returns: The shared cjdao.ClientJobsDAO instance'
def _nupicHyperSearchHasErrors(hyperSearchJob): DCNL 'Check whether any experiments failed in our latest hypersearch DCNL Parameters: DCNL hyperSearchJob: _HyperSearchJob instance; if None, will get it from saved DCNL jobID, if any DCNL Returns: False if all models succeeded, True if one or more had errors'
def _backupFile(filePath): DCNL 'Back up a file DCNL Parameters: DCNL retval:         Filepath of the back-up'
def _getOneModelInfo(nupicModelID): DCNL 'A convenience function that retrieves inforamtion about a single model DCNL See also: _iterModels() DCNL Parameters: DCNL nupicModelID:      Nupic modelID DCNL retval:           _NupicModelInfo instance for the given nupicModelID.'
def _iterModels(modelIDs): DCNL 'Creates an iterator that returns ModelInfo elements for the given modelIDs DCNL WARNING:      The order of ModelInfo elements returned by the iterator DCNL may not match the order of the given modelIDs DCNL Parameters: DCNL modelIDs:       A sequence of model identifiers (e.g., as returned by DCNL _HyperSearchJob.queryModelIDs()). DCNL retval:         Iterator that returns ModelInfo elements for the given DCNL modelIDs (NOTE:possibly in a different order)'
def htmPredictionModelControlEnableSPLearningCb(htmPredictionModel): DCNL 'Enables learning in the HTMPredictionModel\'s Spatial Pooler DCNL See also htmPredictionModelControlDisableSPLearningCb. DCNL htmPredictionModel:  pointer to a HTMPredictionModel instance DCNL Returns: nothing'
def htmPredictionModelControlDisableSPLearningCb(htmPredictionModel): DCNL 'Disables learning in the HTMPredictionModel\'s Spatial Pooler, while DCNL retaining the ability to re-enable SP learning in the future. DCNL See also: htmPredictionModelControlEnableSPLearningCb. DCNL See also: model_callbacks.modelControlFinishLearningCb. DCNL htmPredictionModel:  pointer to a HTMPredictionModel instance DCNL Returns: nothing'
def htmPredictionModelControlEnableTPLearningCb(htmPredictionModel): DCNL 'Enables learning in the HTMPredictionModel\'s Temporal Pooler DCNL See also htmPredictionModelControlDisableTPLearningCb. DCNL htmPredictionModel:  pointer to a HTMPredictionModel instance DCNL Returns: nothing'
def htmPredictionModelControlDisableTPLearningCb(htmPredictionModel): DCNL 'Disables learning in the HTMPredictionModel\'s Temporal Pooler, while DCNL retaining the ability to re-enable TM learning in the future. DCNL See also: htmPredictionModelControlEnableTPLearningCb. DCNL See also: model_callbacks.modelControlFinishLearningCb. DCNL htmPredictionModel:  pointer to a HTMPredictionModel instance DCNL Returns: nothing'
def _testTemporalShift(): DCNL 'Test to see if the metrics manager correctly shifts records for multistep DCNL prediction cases'
def getModule(metricSpec): DCNL 'Factory method to return an appropriate :class:`MetricsIface` module. DCNL - ``rmse``: :class:`MetricRMSE` DCNL - ``nrmse``: :class:`MetricNRMSE` DCNL - ``aae``: :class:`MetricAAE` DCNL - ``acc``: :class:`MetricAccuracy` DCNL - ``avg_err``: :class:`MetricAveError` DCNL - ``trivial``: :class:`MetricTrivial` DCNL - ``two_gram``: :class:`MetricTwoGram` DCNL - ``moving_mean``: :class:`MetricMovingMean` DCNL - ``moving_mode``: :class:`MetricMovingMode` DCNL - ``neg_auc``: :class:`MetricNegAUC` DCNL - ``custom_error_metric``: :class:`CustomErrorMetric` DCNL - ``multiStep``: :class:`MetricMultiStep` DCNL - ``ms_aae``: :class:`MetricMultiStepAAE` DCNL - ``ms_avg_err``: :class:`MetricMultiStepAveError` DCNL - ``passThruPrediction``: :class:`MetricPassThruPrediction` DCNL - ``altMAPE``: :class:`MetricAltMAPE` DCNL - ``MAPE``: :class:`MetricMAPE` DCNL - ``multi``: :class:`MetricMulti` DCNL - ``negativeLogLikelihood``: :class:`MetricNegativeLogLikelihood` DCNL :param metricSpec: (:class:`MetricSpec`) metric to find module for. DCNL ``metricSpec.metric`` must be in the list above. DCNL :returns: (:class:`AggregateMetric`) an appropriate metric module'
def runExperiment(args, model=None): DCNL 'Run a single OPF experiment. DCNL .. note:: The caller is responsible for initializing python logging before DCNL calling this function (e.g., import :mod:`nupic.support`; DCNL :meth:`nupic.support.initLogging`) DCNL See also: :meth:`.initExperimentPrng`. DCNL :param args: (string) Experiment command-line args list. Too see all options, DCNL run with ``--help``: DCNL .. code-block:: text DCNL Options: DCNL -h, --help           show this help message and exit DCNL -c <CHECKPOINT>      Create a model and save it under the given <CHECKPOINT> DCNL name, but don\'t run it DCNL --listCheckpoints    List all available checkpoints DCNL --listTasks          List all task labels in description.py DCNL --load=<CHECKPOINT>  Load a model from the given <CHECKPOINT> and run it. DCNL Run with --listCheckpoints flag for more details. DCNL --newSerialization   Use new capnproto serialization DCNL --tasks              Run the tasks with the given TASK LABELS in the order DCNL they are given.  Either end of arg-list, or a DCNL standalone dot (\'.\') arg or the next short or long DCNL option name (-a or --blah) terminates the list. NOTE: DCNL FAILS TO RECOGNIZE task label names with one or more DCNL leading dashes. [default: run all of the tasks in DCNL description.py] DCNL --testMode           Reduce iteration count for testing DCNL --noCheckpoint       Don\'t checkpoint the model after running each task. DCNL :param model: (:class:`~nupic.frameworks.opf.model.Model`) For testing, may DCNL pass in an existing OPF Model to use instead of creating a new one. DCNL :returns: (:class:`~nupic.frameworks.opf.model.Model`) DCNL reference to OPF Model instance that was constructed (this DCNL is provided to aid with debugging) or None, if none was DCNL created.'
def initExperimentPrng(): DCNL 'Initialize PRNGs that may be used by other modules in the experiment stack. DCNL .. note:: User may call this function to initialize PRNGs that are used by the DCNL experiment stack before calling runExperiment(), unless user has its own DCNL own logic for initializing these PRNGs.'
def _parseCommandLineOptions(args): DCNL 'Parse command line options DCNL Args: DCNL args: command line arguments (not including sys.argv[0]) DCNL Returns: DCNL namedtuple ParseCommandLineOptionsResult'
def reapVarArgsCallback(option, optStr, value, parser): DCNL 'Used as optparse callback for reaping a variable number of option args. DCNL The option may be specified multiple times, and all the args associated with DCNL that option name will be accumulated in the order that they are encountered'
def _reportCommandLineUsageErrorAndExit(parser, message): DCNL 'Report usage error and exit program with error indication.'
def _runExperimentImpl(options, model=None): DCNL 'Creates and runs the experiment DCNL Args: DCNL options: namedtuple ParseCommandLineOptionsResult DCNL model: For testing: may pass in an existing OPF Model instance DCNL to use instead of creating a new one. DCNL Returns: reference to OPFExperiment instance that was constructed (this DCNL is provided to aid with debugging) or None, if none was DCNL created.'
def _saveModel(model, experimentDir, checkpointLabel, newSerialization=False): DCNL 'Save model'
def _getModelCheckpointDir(experimentDir, checkpointLabel): DCNL 'Creates directory for serialization of the model DCNL checkpointLabel: DCNL Checkpoint label (string) DCNL Returns: DCNL absolute path to the serialization directory'
def getCheckpointParentDir(experimentDir): DCNL 'Get checkpoint parent dir. DCNL Returns: absolute path to the base serialization directory within which DCNL model checkpoints for this experiment are created'
def _checkpointLabelFromCheckpointDir(checkpointDir): DCNL 'Returns a checkpoint label string for the given model checkpoint directory DCNL checkpointDir: relative or absolute model checkpoint directory path'
def _isCheckpointDir(checkpointDir): DCNL 'Return true iff checkpointDir appears to be a checkpoint directory.'
def _printAvailableCheckpoints(experimentDir): DCNL 'List available checkpoints for the specified experiment.'
def main(): DCNL 'Module-level entry point.  Run according to options in sys.argv DCNL Usage: python -m python -m nupic.frameworks.opf.experiment_runner'
def loadExperiment(path): DCNL 'Loads the experiment description file from the path. DCNL :param path: (string) The path to a directory containing a description.py file DCNL or the file itself. DCNL :returns: (config, control)'
def loadExperimentDescriptionScriptFromDir(experimentDir): DCNL 'Loads the experiment description python script from the given experiment DCNL directory. DCNL :param experimentDir: (string) experiment directory path DCNL :returns:        module of the loaded experiment description scripts'
def getExperimentDescriptionInterfaceFromModule(module): DCNL ':param module: imported description.py module DCNL :returns: (:class:`nupic.frameworks.opf.exp_description_api.DescriptionIface`) DCNL represents the experiment description'
def _loadDescriptionFile(descriptionPyPath): DCNL 'Loads a description file and returns it as a module. DCNL descriptionPyPath: path of description.py file to load'
def getScalarMetricWithTimeOfDayAnomalyParams(metricData, minVal=None, maxVal=None, minResolution=None, tmImplementation='cpp'): DCNL 'Return a dict that can be used to create an anomaly model via DCNL :meth:`nupic.frameworks.opf.model_factory.ModelFactory.create`. DCNL Example: DCNL .. code-block:: python DCNL from nupic.frameworks.opf.model_factory import ModelFactory DCNL from nupic.frameworks.opf.common_models.cluster_params import ( DCNL getScalarMetricWithTimeOfDayAnomalyParams) DCNL params = getScalarMetricWithTimeOfDayAnomalyParams( DCNL metricData=[0], DCNL tmImplementation="cpp", DCNL minVal=0.0, DCNL maxVal=100.0) DCNL model = ModelFactory.create(modelConfig=params["modelConfig"]) DCNL model.enableLearning() DCNL model.enableInference(params["inferenceArgs"]) DCNL :param metricData: numpy array of metric data. Used to calculate ``minVal`` DCNL and ``maxVal`` if either is unspecified DCNL :param minVal: minimum value of metric. Used to set up encoders. If ``None`` DCNL will be derived from ``metricData``. DCNL :param maxVal: maximum value of metric. Used to set up input encoders. If DCNL ``None`` will be derived from ``metricData`` DCNL :param minResolution: minimum resolution of metric. Used to set up DCNL encoders.  If ``None``, will use default value of ``0.001``. DCNL :param tmImplementation: (string) specifying type of temporal memory DCNL implementation. Valid strings : ``["cpp", "tm_cpp"]`` DCNL :returns: (dict) containing ``modelConfig`` and ``inferenceArgs`` top-level DCNL properties. The value of the ``modelConfig`` property is for passing to DCNL :meth:`~nupic.frameworks.opf.model_factory.ModelFactory.create` method as DCNL the ``modelConfig`` parameter. The ``inferenceArgs`` property is for passing DCNL to the resulting model\'s DCNL :meth:`~nupic.frameworks.opf.model.Model.enableInference` method as the DCNL ``inferenceArgs`` parameter. DCNL .. note:: The timestamp field corresponds to input ``c0``; the predicted DCNL field corresponds to input ``c1``.'
def _rangeGen(data, std=1): DCNL 'Return reasonable min/max values to use given the data.'
def _fixupRandomEncoderParams(params, minVal, maxVal, minResolution): DCNL 'Given model params, figure out the correct parameters for the DCNL RandomDistributed encoder. Modifies params in place.'
def validateOpfJsonValue(value, opfJsonSchemaFilename): DCNL 'Validate a python object against an OPF json schema file DCNL :param value: target python object to validate (typically a dictionary) DCNL :param opfJsonSchemaFilename: (string) OPF json schema filename containing the DCNL json schema object. (e.g., opfTaskControlSchema.json) DCNL :raises: jsonhelpers.ValidationError when value fails json validation'
def initLogger(obj): DCNL 'Helper function to create a logger object for the current object with DCNL the standard Numenta prefix. DCNL :param obj: (object) to add a logger to'
def matchPatterns(patterns, keys): DCNL 'Returns a subset of the keys that match any of the given patterns DCNL :param patterns: (list) regular expressions to match DCNL :param keys: (list) keys to search for matches'
def applyValueGettersToContainer(container): DCNL ''
def _applyValueGettersImpl(container, currentObj, recursionStack): DCNL ''
def requireAnomalyModel(func): DCNL 'Decorator for functions that require anomaly models.'
def modelControlFinishLearningCb(model): DCNL 'Passes the "finish learning" command to the model.  NOTE: Upon completion DCNL of this command, learning may not be resumed on the given instance of DCNL the model (e.g., the implementation may prune data structures that are DCNL necessary for learning) DCNL model:  pointer to the Model instance DCNL Returns: nothing'
def setRandomSeed(seed): DCNL 'Set the random seeds. Helpful to make unit tests repeatable'
def addNoise(input, noise=0.1, doForeground=True, doBackground=True): DCNL 'Add noise to the given input. DCNL Parameters: DCNL input:         the input to add noise to DCNL noise:         how much noise to add DCNL doForeground:  If true, turn off some of the 1 bits in the input DCNL doBackground:  If true, turn on some of the 0 bits in the input'
def generateCoincMatrix(nCoinc=10, length=500, activity=50): DCNL 'Generate a coincidence matrix. This is used to generate random inputs to the DCNL temporal learner and to compare the predicted output against. DCNL It generates a matrix of nCoinc rows, each row has length \'length\' and has DCNL a total of \'activity\' bits on. DCNL Parameters: DCNL nCoinc:        the number of rows to generate DCNL length:        the length of each row DCNL activity:      the number of ones to put into each row.'
def generateVectors(numVectors=100, length=500, activity=50): DCNL 'Generate a list of random sparse distributed vectors.  This is used to generate DCNL training vectors to the spatial or temporal learner and to compare the predicted DCNL output against. DCNL It generates a list of \'numVectors\' elements, each element has length \'length\' DCNL and has a total of \'activity\' bits on. DCNL Parameters: DCNL numVectors:    the number of vectors to generate DCNL length:        the length of each row DCNL activity:      the number of ones to put into each row.'
def generateSimpleSequences(nCoinc=10, seqLength=[5, 6, 7], nSeq=100): DCNL 'Generate a set of simple sequences. The elements of the sequences will be DCNL integers from 0 to \'nCoinc\'-1. The length of each sequence will be DCNL randomly chosen from the \'seqLength\' list. DCNL Parameters: DCNL nCoinc:      the number of elements available to use in the sequences DCNL seqLength:   a list of possible sequence lengths. The length of each DCNL sequence will be randomly chosen from here. DCNL nSeq:        The number of sequences to generate DCNL retval:      a list of sequences. Each sequence is itself a list DCNL containing the coincidence indices for that sequence.'
def generateHubSequences(nCoinc=10, hubs=[2, 6], seqLength=[5, 6, 7], nSeq=100): DCNL 'Generate a set of hub sequences. These are sequences which contain a hub DCNL element in the middle. The elements of the sequences will be integers DCNL from 0 to \'nCoinc\'-1. The hub elements will only appear in the middle of DCNL each sequence. The length of each sequence will be randomly chosen from the DCNL \'seqLength\' list. DCNL Parameters: DCNL nCoinc:        the number of elements available to use in the sequences DCNL hubs:          which of the elements will be used as hubs. DCNL seqLength:     a list of possible sequence lengths. The length of each DCNL sequence will be randomly chosen from here. DCNL nSeq:          The number of sequences to generate DCNL retval:        a list of sequences. Each sequence is itself a list DCNL containing the coincidence indices for that sequence.'
def genTestSeqsForLookback(nPatterns=10, patternLen=500, patternActivity=50, seqLength=[5, 6, 7], nSequences=50): DCNL 'Generate two sets of sequences. The first set of sequences is used to train DCNL the sequence learner till it fills up capacity. The second set is then used DCNL to further train the system to test its generalization capability using the DCNL one step look back idea. The second set of sequences are generated by modifying DCNL the first set DCNL Parameters: DCNL nPatterns:        the number of patterns to use in the sequences. DCNL patternLen:       The number of elements in each pattern DCNL patternActivity:  The number of elements that should be active in DCNL each pattern DCNL seqLength:        a list of possible sequence lengths. The length of each DCNL sequence will be randomly chosen from here. DCNL nSequences: The number of simple sequences in the first set DCNL retval:           (seqList1, seqList2, patterns) DCNL seqList1, seqList2: a list of sequences. Each sequence is itself a list DCNL containing the input pattern indices for that sequence. DCNL patterns: the input patterns used in the seqList.'
def generateSimpleCoincMatrix(nCoinc=10, length=500, activity=50): DCNL 'Generate a non overlapping coincidence matrix. This is used to generate random DCNL inputs to the temporal learner and to compare the predicted output against. DCNL It generates a matrix of nCoinc rows, each row has length \'length\' and has DCNL a total of \'activity\' bits on. DCNL Parameters: DCNL nCoinc:        the number of rows to generate DCNL length:        the length of each row DCNL activity:      the number of ones to put into each row.'
def generateSequences(nPatterns=10, patternLen=500, patternActivity=50, hubs=[2, 6], seqLength=[5, 6, 7], nSimpleSequences=50, nHubSequences=50): DCNL 'Generate a set of simple and hub sequences. A simple sequence contains DCNL a randomly chosen set of elements from 0 to \'nCoinc-1\'. A hub sequence DCNL always contains a hub element in the middle of it. DCNL Parameters: DCNL nPatterns:        the number of patterns to use in the sequences. DCNL patternLen:       The number of elements in each pattern DCNL patternActivity:  The number of elements that should be active in DCNL each pattern DCNL hubs:             which of the elements will be used as hubs. DCNL seqLength:        a list of possible sequence lengths. The length of each DCNL sequence will be randomly chosen from here. DCNL nSimpleSequences: The number of simple sequences to generate DCNL nHubSequences:    The number of hub sequences to generate DCNL retval:           (seqList, patterns) DCNL seqList: a list of sequences. Each sequence is itself a list DCNL containing the input pattern indices for that sequence. DCNL patterns: the input patterns used in the seqList.'
def generateL2Sequences(nL1Patterns=10, l1Hubs=[2, 6], l1SeqLength=[5, 6, 7], nL1SimpleSequences=50, nL1HubSequences=50, l1Pooling=4, perfectStability=False, spHysteresisFactor=1.0, patternLen=500, patternActivity=50): DCNL 'Generate the simulated output from a spatial pooler that\'s sitting DCNL on top of another spatial pooler / temporal memory pair.  The average on-time DCNL of the outputs from the simulated TM is given by the l1Pooling argument. DCNL In this routine, L1 refers to the first spatial and temporal memory and L2 DCNL refers to the spatial pooler above that. DCNL Parameters: DCNL nL1Patterns:          the number of patterns to use in the L1 sequences. DCNL l1Hubs:               which of the elements will be used as hubs. DCNL l1SeqLength:          a list of possible sequence lengths. The length of each DCNL sequence will be randomly chosen from here. DCNL nL1SimpleSequences:   The number of simple sequences to generate for L1 DCNL nL1HubSequences:      The number of hub sequences to generate for L1 DCNL l1Pooling:            The number of time steps to pool over in the L1 temporal DCNL pooler DCNL perfectStability:     If true, then the input patterns represented by the DCNL sequences generated will have perfect stability over DCNL l1Pooling time steps. This is the best case ideal input DCNL to a TM. In actual situations, with an actual SP DCNL providing input, the stability will always be less than DCNL this. DCNL spHystereisFactor:    The hysteresisFactor to use in the L2 spatial pooler. DCNL Only used when perfectStability is  False DCNL patternLen:           The number of elements in each pattern output by L2 DCNL patternActivity:      The number of elements that should be active in DCNL each pattern DCNL @retval:              (seqList, patterns) DCNL seqList: a list of sequences output from L2. Each sequence is DCNL itself a list containing the input pattern indices for that DCNL sequence. DCNL patterns: the input patterns used in the L2 seqList.'
def vectorsFromSeqList(seqList, patternMatrix): DCNL 'Convert a list of sequences of pattern indices, and a pattern lookup table DCNL into a an array of patterns DCNL Parameters: DCNL seq:            the sequence, given as indices into the patternMatrix DCNL patternMatrix:  a SparseMatrix contaning the possible patterns used in DCNL the sequence.'
def sameTMParams(tp1, tp2): DCNL 'Given two TM instances, see if any parameters are different.'
def sameSynapse(syn, synapses): DCNL 'Given a synapse and a list of synapses, check whether this synapse DCNL exist in the list.  A synapse is represented as [col, cell, permanence]. DCNL A synapse matches if col and cell are identical and the permanence value is DCNL within 0.001.'
def sameSegment(seg1, seg2): DCNL 'Return True if seg1 and seg2 are identical, ignoring order of synapses'
def tmDiff(tm1, tm2, verbosity=0, relaxSegmentTests=True): DCNL 'Given two TM instances, list the difference between them and returns False DCNL if there is a difference. This function checks the major parameters. If this DCNL passes (and checkLearn is true) it checks the number of segments on DCNL each cell. If this passes, checks each synapse on each segment. DCNL When comparing C++ and Py, the segments are usually in different orders in the DCNL cells. tmDiff ignores segment order when comparing TM\'s.'
def tmDiff2(tm1, tm2, verbosity=0, relaxSegmentTests=True, checkLearn=True, checkStates=True): DCNL 'Given two TM instances, list the difference between them and returns False DCNL if there is a difference. This function checks the major parameters. If this DCNL passes (and checkLearn is true) it checks the number of segments on each cell. DCNL If this passes, checks each synapse on each segment. DCNL When comparing C++ and Py, the segments are usually in different orders in the DCNL cells. tmDiff ignores segment order when comparing TM\'s. DCNL If checkLearn is True, will check learn states as well as all the segments DCNL If checkStates is True, will check the various state arrays'
def spDiff(SP1, SP2): DCNL 'Function that compares two spatial pooler instances. Compares the DCNL static variables between the two poolers to make sure that they are equivalent. DCNL Parameters DCNL SP1 first spatial pooler to be compared DCNL SP2 second spatial pooler to be compared DCNL To establish equality, this function does the following: DCNL 1.Compares the connected synapse matrices for each coincidence DCNL 2.Compare the potential synapse matrices for each coincidence DCNL 3.Compare the permanence matrices for each coincidence DCNL 4.Compare the firing boosts between the two poolers. DCNL 5.Compare the duty cycles before and after inhibition for both poolers'
def removeSeqStarts(vectors, resets, numSteps=1): DCNL 'Convert a list of sequences of pattern indices, and a pattern lookup table DCNL into a an array of patterns DCNL Parameters: DCNL vectors:          the data vectors. Row 0 contains the outputs from time DCNL step 0, row 1 from time step 1, etc. DCNL resets:           the reset signal. This is a vector of booleans DCNL the same length as the number of rows in \'vectors\'. It DCNL has a 1 where a sequence started and a 0 otherwise. The DCNL first \'numSteps\' rows of \'vectors\' of each sequence will DCNL not be included in the return result. DCNL numSteps          Number of samples to remove from the start of each sequence DCNL retval:           copy of vectors, with the first \'numSteps\' samples at the DCNL start of each sequence removed.'
def _accumulateFrequencyCounts(values, freqCounts=None): DCNL 'Accumulate a list of values \'values\' into the frequency counts \'freqCounts\', DCNL and return the updated frequency counts DCNL For example, if values contained the following: [1,1,3,5,1,3,5], and the initial DCNL freqCounts was None, then the return value would be: DCNL [0,3,0,2,0,2] DCNL which corresponds to how many of each value we saw in the input, i.e. there DCNL were 0 0\'s, 3 1\'s, 0 2\'s, 2 3\'s, 0 4\'s, and 2 5\'s. DCNL If freqCounts is not None, the values will be added to the existing counts and DCNL the length of the frequency Counts will be automatically extended as necessary DCNL Parameters: DCNL values:         The values to accumulate into the frequency counts DCNL freqCounts:     Accumulated frequency counts so far, or none'
def _listOfOnTimesInVec(vector): DCNL 'Returns 3 things for a vector: DCNL * the total on time DCNL * the number of runs DCNL * a list of the durations of each run. DCNL Parameters: DCNL input stream: 11100000001100000000011111100000 DCNL return value: (11, 3, [3, 2, 6])'
def _fillInOnTimes(vector, durations): DCNL 'Helper function used by averageOnTimePerTimestep. \'durations\' is a vector DCNL which must be the same len as vector. For each "on" in vector, it fills in DCNL the corresponding element of duration with the duration of that "on" signal DCNL up until that time DCNL Parameters: DCNL vector:     vector of output values over time DCNL durations:  vector same length as \'vector\', initialized to 0\'s. DCNL This is filled in with the durations of each \'on" signal. DCNL Example: DCNL vector:     11100000001100000000011111100000 DCNL durations:  12300000001200000000012345600000'
def averageOnTimePerTimestep(vectors, numSamples=None): DCNL 'Computes the average on-time of the outputs that are on at each time step, and DCNL then averages this over all time steps. DCNL This metric is resiliant to the number of outputs that are on at each time DCNL step. That is, if time step 0 has many more outputs on than time step 100, it DCNL won\'t skew the results. This is particularly useful when measuring the DCNL average on-time of things like the temporal memory output where you might DCNL have many columns bursting at the start of a sequence - you don\'t want those DCNL start of sequence bursts to over-influence the calculated average on-time. DCNL Parameters: DCNL vectors:          the vectors for which the onTime is calculated. Row 0 DCNL contains the outputs from time step 0, row 1 from time step DCNL 1, etc. DCNL numSamples:       the number of elements for which on-time is calculated. DCNL If not specified, then all elements are looked at. DCNL Returns  (scalar average on-time over all time steps, DCNL list containing frequency counts of each encountered on-time)'
def averageOnTime(vectors, numSamples=None): DCNL 'Returns the average on-time, averaged over all on-time runs. DCNL Parameters: DCNL vectors:          the vectors for which the onTime is calculated. Row 0 DCNL contains the outputs from time step 0, row 1 from time step DCNL 1, etc. DCNL numSamples:       the number of elements for which on-time is calculated. DCNL If not specified, then all elements are looked at. DCNL Returns:    (scalar average on-time of all outputs, DCNL list containing frequency counts of each encountered on-time)'
def plotOutputsOverTime(vectors, buVectors=None, title='On-times'): DCNL 'Generate a figure that shows each output over time. Time goes left to right, DCNL and each output is plotted on a different line, allowing you to see the overlap DCNL in the outputs, when they turn on/off, etc. DCNL Parameters: DCNL vectors:            the vectors to plot DCNL buVectors:          These are normally specified when plotting the pooling DCNL outputs of the temporal memory over time. The \'buVectors\' DCNL are the sequence outputs and the \'vectors\' are the DCNL pooling outputs. The buVector (sequence) outputs will be drawn DCNL in a darker color than the vector (pooling) outputs to DCNL distinguish where the cell is outputting due to pooling vs. DCNL sequence memory. DCNL title:              title for the plot DCNL avgOnTime:          The average on-time measurement. If not supplied, DCNL then it will be calculated from the passed in vectors.'
def plotHistogram(freqCounts, title='On-Times DCSP Histogram', xLabel='On-Time'): DCNL 'This is usually used to display a histogram of the on-times encountered DCNL in a particular output. DCNL The freqCounts is a vector containg the frequency counts of each on-time DCNL (starting at an on-time of 0 and going to an on-time = len(freqCounts)-1) DCNL The freqCounts are typically generated from the averageOnTimePerTimestep DCNL or averageOnTime methods of this module. DCNL Parameters: DCNL freqCounts:       The frequency counts to plot DCNL title:            Title of the plot'
def populationStability(vectors, numSamples=None): DCNL 'Returns the stability for the population averaged over multiple time steps DCNL Parameters: DCNL vectors:          the vectors for which the stability is calculated DCNL numSamples        the number of time steps where stability is counted DCNL At each time step, count the fraction of the active elements which are stable DCNL from the previous step DCNL Average all the fraction'
def percentOutputsStableOverNTimeSteps(vectors, numSamples=None): DCNL 'Returns the percent of the outputs that remain completely stable over DCNL N time steps. DCNL Parameters: DCNL vectors:        the vectors for which the stability is calculated DCNL numSamples:     the number of time steps where stability is counted DCNL For each window of numSamples, count how many outputs are active during DCNL the entire window.'
def computeSaturationLevels(outputs, outputsShape, sparseForm=False): DCNL 'Compute the saturation for a continuous level. This breaks the level into DCNL multiple regions and computes the saturation level for each region. DCNL Parameters: DCNL outputs:      output of the level. If sparseForm is True, this is a list of DCNL the non-zeros. If sparseForm is False, it is the dense DCNL representation DCNL outputsShape: The shape of the outputs of the level (height, width) DCNL retval:       (sat, innerSat): DCNL sat: list of the saturation levels of each non-empty DCNL region of the level (each 0 -> 1.0) DCNL innerSat: list of the saturation level of each non-empty region DCNL that is not near an edge (each 0 -> 1.0)'
def checkMatch(input, prediction, sparse=True, verbosity=0): DCNL 'Compares the actual input with the predicted input and returns results DCNL Parameters: DCNL input:          The actual input DCNL prediction:     the predicted input DCNL verbosity:        If > 0, print debugging messages DCNL sparse:         If true, they are in sparse form (list of DCNL active indices) DCNL retval         (foundInInput, totalActiveInInput, missingFromInput, DCNL totalActiveInPrediction) DCNL foundInInput:       The number of predicted active elements that were DCNL found in the actual input DCNL totalActiveInInput: The total number of active elements in the input. DCNL missingFromInput:   The number of predicted active elements that were not DCNL found in the actual input DCNL totalActiveInPrediction:  The total number of active elements in the prediction'
def predictionExtent(inputs, resets, outputs, minOverlapPct=100.0): DCNL 'Computes the predictive ability of a temporal memory (TM). This routine returns DCNL a value which is the average number of time steps of prediction provided DCNL by the TM. It accepts as input the inputs, outputs, and resets provided to DCNL the TM as well as a \'minOverlapPct\' used to evalulate whether or not a DCNL prediction is a good enough match to the actual input. DCNL The \'outputs\' are the pooling outputs of the TM. This routine treats each output DCNL as a "manifold" that includes the active columns that should be present in the DCNL next N inputs. It then looks at each successive input and sees if it\'s active DCNL columns are within the manifold. For each output sample, it computes how DCNL many time steps it can go forward on the input before the input overlap with DCNL the manifold is less then \'minOverlapPct\'. It returns the average number of DCNL time steps calculated for each output. DCNL Parameters: DCNL inputs:          The inputs to the TM. Row 0 contains the inputs from time DCNL step 0, row 1 from time step 1, etc. DCNL resets:          The reset input to the TM. Element 0 contains the reset from DCNL time step 0, element 1 from time step 1, etc. DCNL outputs:         The pooling outputs from the TM. Row 0 contains the outputs DCNL from time step 0, row 1 from time step 1, etc. DCNL minOverlapPct:   How much each input\'s columns must overlap with the pooling DCNL output\'s columns to be considered a valid prediction. DCNL retval:          (Average number of time steps of prediction over all output DCNL samples, DCNL Average number of time steps of prediction when we aren\'t DCNL cut short by the end of the sequence, DCNL List containing frequency counts of each encountered DCNL prediction time)'
def getCentreAndSpreadOffsets(spaceShape, spreadShape, stepSize=1): DCNL 'Generates centre offsets and spread offsets for block-mode based training DCNL regimes - star, cross, block. DCNL Parameters: DCNL spaceShape:   The (height, width) of the 2-D space to explore. This DCNL sets the number of center-points. DCNL spreadShape:  The shape (height, width) of the area around each center-point DCNL to explore. DCNL stepSize:     The step size. How big each step is, in pixels. This controls DCNL *both* the spacing of the center-points within the block and the DCNL points we explore around each center-point DCNL retval:       (centreOffsets, spreadOffsets)'
def makeCloneMap(columnsShape, outputCloningWidth, outputCloningHeight=(-1)): DCNL 'Make a two-dimensional clone map mapping columns to clone master. DCNL This makes a map that is (numColumnsHigh, numColumnsWide) big that can DCNL be used to figure out which clone master to use for each column.  Here are DCNL a few sample calls DCNL >>> makeCloneMap(columnsShape=(10, 6), outputCloningWidth=4) DCNL (array([[ 0,  1,  2,  3,  0,  1], DCNL [ 4,  5,  6,  7,  4,  5], DCNL [ 8,  9, 10, 11,  8,  9], DCNL [12, 13, 14, 15, 12, 13], DCNL [ 0,  1,  2,  3,  0,  1], DCNL [ 4,  5,  6,  7,  4,  5], DCNL [ 8,  9, 10, 11,  8,  9], DCNL [12, 13, 14, 15, 12, 13], DCNL [ 0,  1,  2,  3,  0,  1], DCNL [ 4,  5,  6,  7,  4,  5]], dtype=uint32), 16) DCNL >>> makeCloneMap(columnsShape=(7, 8), outputCloningWidth=3) DCNL (array([[0, 1, 2, 0, 1, 2, 0, 1], DCNL [3, 4, 5, 3, 4, 5, 3, 4], DCNL [6, 7, 8, 6, 7, 8, 6, 7], DCNL [0, 1, 2, 0, 1, 2, 0, 1], DCNL [3, 4, 5, 3, 4, 5, 3, 4], DCNL [6, 7, 8, 6, 7, 8, 6, 7], DCNL [0, 1, 2, 0, 1, 2, 0, 1]], dtype=uint32), 9) DCNL >>> makeCloneMap(columnsShape=(7, 11), outputCloningWidth=5) DCNL (array([[ 0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0], DCNL [ 5,  6,  7,  8,  9,  5,  6,  7,  8,  9,  5], DCNL [10, 11, 12, 13, 14, 10, 11, 12, 13, 14, 10], DCNL [15, 16, 17, 18, 19, 15, 16, 17, 18, 19, 15], DCNL [20, 21, 22, 23, 24, 20, 21, 22, 23, 24, 20], DCNL [ 0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0], DCNL [ 5,  6,  7,  8,  9,  5,  6,  7,  8,  9,  5]], dtype=uint32), 25) DCNL >>> makeCloneMap(columnsShape=(7, 8), outputCloningWidth=3, outputCloningHeight=4) DCNL (array([[ 0,  1,  2,  0,  1,  2,  0,  1], DCNL [ 3,  4,  5,  3,  4,  5,  3,  4], DCNL [ 6,  7,  8,  6,  7,  8,  6,  7], DCNL [ 9, 10, 11,  9, 10, 11,  9, 10], DCNL [ 0,  1,  2,  0,  1,  2,  0,  1], DCNL [ 3,  4,  5,  3,  4,  5,  3,  4], DCNL [ 6,  7,  8,  6,  7,  8,  6,  7]], dtype=uint32), 12) DCNL The basic idea with this map is that, if you imagine things stretching off DCNL to infinity, every instance of a given clone master is seeing the exact DCNL same thing in all directions.  That includes: DCNL - All neighbors must be the same DCNL - The "meaning" of the input to each of the instances of the same clone DCNL master must be the same.  If input is pixels and we have translation DCNL invariance--this is easy.  At higher levels where input is the output DCNL of lower levels, this can be much harder. DCNL - The "meaning" of the inputs to neighbors of a clone master must be the DCNL same for each instance of the same clone master. DCNL The best way to think of this might be in terms of \'inputCloningWidth\' and DCNL \'outputCloningWidth\'. DCNL - The \'outputCloningWidth\' is the number of columns you\'d have to move DCNL horizontally (or vertically) before you get back to the same the same DCNL clone that you started with.  MUST BE INTEGRAL! DCNL - The \'inputCloningWidth\' is the \'outputCloningWidth\' of the node below us. DCNL If we\'re getting input from an sensor where every element just represents DCNL a shift of every other element, this is 1. DCNL At a conceptual level, it means that if two different inputs are shown DCNL to the node and the only difference between them is that one is shifted DCNL horizontally (or vertically) by this many pixels, it means we are looking DCNL at the exact same real world input, but shifted by some number of pixels DCNL (doesn\'t have to be 1).  MUST BE INTEGRAL! DCNL At level 1, I think you could have this: DCNL * inputCloningWidth = 1 DCNL * sqrt(coincToInputRatio^2) = 2.5 DCNL * outputCloningWidth = 5 DCNL ...in this case, you\'d end up with 25 masters. DCNL Let\'s think about this case: DCNL input:    - - -  0     1     2     3     4     5     -     -   - - - DCNL columns:        0 1  2 3 4  0 1  2 3 4  0 1  2 3 4  0 1  2 3 4 DCNL ...in other words, input 0 is fed to both column 0 and column 1.  Input 1 DCNL is fed to columns 2, 3, and 4, etc.  Hopefully, you can see that you\'ll DCNL get the exact same output (except shifted) with: DCNL input:    - - -  -     -     0     1     2     3     4     5   - - - DCNL columns:        0 1  2 3 4  0 1  2 3 4  0 1  2 3 4  0 1  2 3 4 DCNL ...in other words, we\'ve shifted the input 2 spaces and the output shifted DCNL 5 spaces. DCNL *** The outputCloningWidth MUST ALWAYS be an integral multiple of the *** DCNL *** inputCloningWidth in order for all of our rules to apply.         *** DCNL *** NOTE: inputCloningWidth isn\'t passed here, so it\'s the caller\'s   *** DCNL ***       responsibility to ensure that this is true.                *** DCNL *** The outputCloningWidth MUST ALWAYS be an integral multiple of     *** DCNL *** sqrt(coincToInputRatio^2), too.                                  *** DCNL @param  columnsShape         The shape (height, width) of the columns. DCNL @param  outputCloningWidth   See docstring above. DCNL @param  outputCloningHeight  If non-negative, can be used to make DCNL rectangular (instead of square) cloning fields. DCNL @return cloneMap             An array (numColumnsHigh, numColumnsWide) that DCNL contains the clone index to use for each DCNL column. DCNL @return numDistinctClones    The number of distinct clones in the map.  This DCNL is just outputCloningWidth*outputCloningHeight.'
def numpyStr(array, format='%f', includeIndices=False, includeZeros=True): DCNL 'Pretty print a numpy matrix using the given format string for each DCNL value. Return the string representation DCNL Parameters: DCNL array:    The numpy array to print. This can be either a 1D vector or 2D matrix DCNL format:   The format string to use for each value DCNL includeIndices: If true, include [row,col] label for each value DCNL includeZeros:   Can only be set to False if includeIndices is on. DCNL If True, include 0 values in the print-out DCNL If False, exclude 0 values from the print-out.'
def _labeledInput(activeInputs, cellsPerCol=32): DCNL 'Print the list of [column, cellIdx] indices for each of the active DCNL cells in activeInputs.'
def computeRawAnomalyScore(activeColumns, prevPredictedColumns): DCNL 'Computes the raw anomaly score. DCNL The raw anomaly score is the fraction of active columns not predicted. DCNL :param activeColumns: array of active column indices DCNL :param prevPredictedColumns: array of columns indices predicted in prev step DCNL :returns: anomaly score 0..1 (float)'
def importAndRunFunction(path, moduleName, funcName, **keywords): DCNL 'Run a named function specified by a filesystem path, module name DCNL and function name. DCNL Returns the value returned by the imported function. DCNL Use this when access is needed to code that has DCNL not been added to a package accessible from the ordinary Python DCNL path. Encapsulates the multiple lines usually needed to DCNL safely manipulate and restore the Python path. DCNL Parameters DCNL path: filesystem path DCNL Path to the directory where the desired module is stored. DCNL This will be used to temporarily augment the Python path. DCNL moduleName: basestring DCNL Name of the module, without trailing extension, where the desired DCNL function is stored. This module should be in the directory specified DCNL with path. DCNL funcName: basestring DCNL Name of the function to import and call. DCNL keywords: DCNL Keyword arguments to be passed to the imported function.'
def getLockedHandle(runtimeElement, expression): DCNL 'Calls runtimeElement.interpret(expression) and wraps the result DCNL in a call to nupic.bindings.research.lockHandle().'
def transferCoincidences(network, fromElementName, toElementName): DCNL 'Gets the coincidence matrix from one element and sets it on DCNL another element DCNL (using locked handles, a la nupic.bindings.research.lockHandle). DCNL TODO: Generalize to more node types, parameter name pairs, etc. DCNL Does not work across processes.'
def _extractCallingMethodArgs(): DCNL 'Returns args dictionary from the calling method'
def estimateAnomalyLikelihoods(anomalyScores, averagingWindow=10, skipRecords=0, verbosity=0): DCNL 'Given a series of anomaly scores, compute the likelihood for each score. This DCNL function should be called once on a bunch of historical anomaly scores for an DCNL initial estimate of the distribution. It should be called again every so often DCNL (say every 50 records) to update the estimate. DCNL :param anomalyScores: a list of records. Each record is a list with the DCNL following three elements: [timestamp, value, score] DCNL Example:: DCNL [datetime.datetime(2013, 8, 10, 23, 0), 6.0, 1.0] DCNL For best results, the list should be between 1000 DCNL and 10,000 records DCNL :param averagingWindow: integer number of records to average over DCNL :param skipRecords: integer specifying number of records to skip when DCNL estimating distributions. If skip records are >= DCNL len(anomalyScores), a very broad distribution is returned DCNL that makes everything pretty likely. DCNL :param verbosity: integer controlling extent of printouts for debugging DCNL 0 = none DCNL 1 = occasional information DCNL 2 = print every record DCNL :returns: 3-tuple consisting of: DCNL - likelihoods DCNL numpy array of likelihoods, one for each aggregated point DCNL - avgRecordList DCNL list of averaged input records DCNL - params DCNL a small JSON dict that contains the state of the estimator'
def updateAnomalyLikelihoods(anomalyScores, params, verbosity=0): DCNL 'Compute updated probabilities for anomalyScores using the given params. DCNL :param anomalyScores: a list of records. Each record is a list with the DCNL following three elements: [timestamp, value, score] DCNL Example:: DCNL [datetime.datetime(2013, 8, 10, 23, 0), 6.0, 1.0] DCNL :param params: the JSON dict returned by estimateAnomalyLikelihoods DCNL :param verbosity: integer controlling extent of printouts for debugging DCNL :type verbosity: int DCNL :returns: 3-tuple consisting of: DCNL - likelihoods DCNL numpy array of likelihoods, one for each aggregated point DCNL - avgRecordList DCNL list of averaged input records DCNL - params DCNL an updated JSON object containing the state of this metric.'
def _filterLikelihoods(likelihoods, redThreshold=0.99999, yellowThreshold=0.999): DCNL 'Filter the list of raw (pre-filtered) likelihoods so that we only preserve DCNL sharp increases in likelihood. \'likelihoods\' can be a numpy array of floats or DCNL a list of floats. DCNL :returns: A new list of floats likelihoods containing the filtered values.'
def _anomalyScoreMovingAverage(anomalyScores, windowSize=10, verbosity=0): DCNL 'Given a list of anomaly scores return a list of averaged records. DCNL anomalyScores is assumed to be a list of records of the form: DCNL [datetime.datetime(2013, 8, 10, 23, 0), 6.0, 1.0] DCNL Each record in the returned list list contains: DCNL [datetime, value, averagedScore] DCNL *Note:* we only average the anomaly score.'
def estimateNormal(sampleData, performLowerBoundCheck=True): DCNL ':param sampleData: DCNL :type sampleData: Numpy array. DCNL :param performLowerBoundCheck: DCNL :type performLowerBoundCheck: bool DCNL :returns: A dict containing the parameters of a normal distribution based on DCNL the ``sampleData``.'
def nullDistribution(verbosity=0): DCNL ':param verbosity: integer controlling extent of printouts for debugging DCNL :type verbosity: int DCNL :returns: A distribution that is very broad and makes every anomaly score DCNL between 0 and 1 pretty likely.'
def tailProbability(x, distributionParams): DCNL 'Given the normal distribution specified by the mean and standard deviation DCNL in distributionParams, return the probability of getting samples further DCNL from the mean. For values above the mean, this is the probability of getting DCNL samples > x and for values below the mean, the probability of getting DCNL samples < x. This is the Q-function: the tail probability of the normal distribution. DCNL :param distributionParams: dict with \'mean\' and \'stdev\' of the distribution'
def isValidEstimatorParams(p): DCNL ':returns: ``True`` if ``p`` is a valid estimator params as might be returned DCNL by ``estimateAnomalyLikelihoods()`` or ``updateAnomalyLikelihoods``, DCNL ``False`` otherwise.  Just does some basic validation.'
def _pFormatArray(array_, fmt='%.2f'): DCNL 'Return a string with pretty-print of a numpy array using the given format DCNL for each element'
def binSearch(arr, val): DCNL 'Function for running binary search on a sorted list. DCNL :param arr: (list) a sorted list of integers to search DCNL :param val: (int)  a integer to search for in the sorted array DCNL :returns: (int) the index of the element if it is found and -1 otherwise.'
def whois_callers_caller(): DCNL 'Returns: Traceback namedtuple for our caller\'s caller'
def getDefaultSPImp(): DCNL 'Return the default spatial pooler implementation for this region.'
def getSPClass(spatialImp): DCNL 'Return the class corresponding to the given spatialImp string'
def _buildArgs(f, self=None, kwargs={}): DCNL 'Get the default arguments from the function and assign as instance vars. DCNL Return a list of 3-tuples with (name, description, defaultValue) for each DCNL argument to the function. DCNL Assigns all arguments to the function as instance variables of SPRegion. DCNL If the argument was not provided, uses the default value. DCNL Pops any values from kwargs that go to the function.'
def _getAdditionalSpecs(spatialImp, kwargs={}): DCNL 'Build the additional specs in three groups (for the inspector) DCNL Use the type of the default argument to set the Spec type, defaulting DCNL to \'Byte\' for None and complex types DCNL Determines the spatial parameters based on the selected implementation. DCNL It defaults to SpatialPooler.'
def _getTPClass(temporalImp): DCNL 'Return the class corresponding to the given temporalImp string'
def _buildArgs(f, self=None, kwargs={}): DCNL 'Get the default arguments from the function and assign as instance vars. DCNL Return a list of 3-tuples with (name, description, defaultValue) for each DCNL argument to the function. DCNL Assigns all arguments to the function as instance variables of TMRegion. DCNL If the argument was not provided, uses the default value. DCNL Pops any values from kwargs that go to the function.'
def _getAdditionalSpecs(temporalImp, kwargs={}): DCNL 'Build the additional specs in three groups (for the inspector) DCNL Use the type of the default argument to set the Spec type, defaulting DCNL to \'Byte\' for None and complex types DCNL Determines the spatial parameters based on the selected implementation. DCNL It defaults to TemporalMemory. DCNL Determines the temporal parameters based on the temporalImp'
def processClubAttendance(f, clubs): DCNL 'Process the attendance data of one club DCNL If the club already exists in the list update its data. DCNL If the club is new create a new Club object and add it to the dict DCNL The next step is to iterate over all the lines and add a record for each line. DCNL When reaching an empty line it means there are no more records for this club. DCNL Along the way some redundant lines are skipped. When the file ends the f.next() DCNL call raises a StopIteration exception and that\'s the sign to return False, DCNL which indicates to the caller that there are no more clubs to process.'
def processClubConsumption(f, clubs): DCNL 'Process the consumption a club DCNL - Skip the header line DCNL - Iterate over lines DCNL - Read 4 records at a time DCNL - Parse each line: club, date, time, consumption DCNL - Get club object from dictionary if needed DCNL - Aggregate consumption DCNL - Call club.processConsumption() with data'
def processConsumptionFiles(clubs): DCNL ''
def makeDataset(): DCNL ''
def _generateLinearModel(numTrainingRecords, numTestingRecords, coefficients=[1], noiseLevel=0.1, dataScale=[0, 100]): DCNL ''
def _generateFile(filename, data): DCNL 'Parameters: DCNL filename:         name of .csv file to generate'
def generate(model, filenameTrain, filenameTest, numTrainingRecords=10000, numTestingRecords=1000): DCNL ''
def _generateModel0(numCategories): DCNL 'Generate the initial, first order, and second order transition DCNL probabilities for \'model0\'. For this model, we generate the following DCNL set of sequences: DCNL 1-2-3   (4X) DCNL 1-2-4   (1X) DCNL 5-2-3   (1X) DCNL 5-2-4   (4X) DCNL Parameters: DCNL numCategories:      Number of categories DCNL retval: (initProb, firstOrder, secondOrder, seqLen) DCNL initProb:     Initial probability for each category. This is a vector DCNL of length len(categoryList). DCNL firstOrder:   A dictionary of the 1st order probabilities. The key DCNL is the 1st element of the sequence, the value is DCNL the probability of each 2nd element given the first. DCNL secondOrder:  A dictionary of the 2nd order probabilities. The key DCNL is the first 2 elements of the sequence, the value is DCNL the probability of each possible 3rd element given the DCNL first two. DCNL seqLen:       Desired length of each sequence. The 1st element will DCNL be generated using the initProb, the 2nd element by the DCNL firstOrder table, and the 3rd and all successive DCNL elements by the secondOrder table. DCNL Here is an example of some return values: DCNL initProb:         [0.7, 0.2, 0.1] DCNL firstOrder:       {\'[0]\': [0.3, 0.3, 0.4], DCNL \'[1]\': [0.3, 0.3, 0.4], DCNL \'[2]\': [0.3, 0.3, 0.4]} DCNL secondOrder:      {\'[0,0]\': [0.3, 0.3, 0.4], DCNL \'[0,1]\': [0.3, 0.3, 0.4], DCNL \'[0,2]\': [0.3, 0.3, 0.4], DCNL \'[1,0]\': [0.3, 0.3, 0.4], DCNL \'[1,1]\': [0.3, 0.3, 0.4], DCNL \'[1,2]\': [0.3, 0.3, 0.4], DCNL \'[2,0]\': [0.3, 0.3, 0.4], DCNL \'[2,1]\': [0.3, 0.3, 0.4], DCNL \'[2,2]\': [0.3, 0.3, 0.4]}'
def _generateModel1(numCategories): DCNL 'Generate the initial, first order, and second order transition DCNL probabilities for \'model1\'. For this model, we generate the following DCNL set of sequences: DCNL 0-10-15 (1X) DCNL 0-11-16 (1X) DCNL 0-12-17 (1X) DCNL 0-13-18 (1X) DCNL 0-14-19 (1X) DCNL 1-10-20 (1X) DCNL 1-11-21 (1X) DCNL 1-12-22 (1X) DCNL 1-13-23 (1X) DCNL 1-14-24 (1X) DCNL Parameters: DCNL numCategories:      Number of categories DCNL retval: (initProb, firstOrder, secondOrder, seqLen) DCNL initProb:     Initial probability for each category. This is a vector DCNL of length len(categoryList). DCNL firstOrder:   A dictionary of the 1st order probabilities. The key DCNL is the 1st element of the sequence, the value is DCNL the probability of each 2nd element given the first. DCNL secondOrder:  A dictionary of the 2nd order probabilities. The key DCNL is the first 2 elements of the sequence, the value is DCNL the probability of each possible 3rd element given the DCNL first two. DCNL seqLen:       Desired length of each sequence. The 1st element will DCNL be generated using the initProb, the 2nd element by the DCNL firstOrder table, and the 3rd and all successive DCNL elements by the secondOrder table. DCNL Here is an example of some return values: DCNL initProb:         [0.7, 0.2, 0.1] DCNL firstOrder:       {\'[0]\': [0.3, 0.3, 0.4], DCNL \'[1]\': [0.3, 0.3, 0.4], DCNL \'[2]\': [0.3, 0.3, 0.4]} DCNL secondOrder:      {\'[0,0]\': [0.3, 0.3, 0.4], DCNL \'[0,1]\': [0.3, 0.3, 0.4], DCNL \'[0,2]\': [0.3, 0.3, 0.4], DCNL \'[1,0]\': [0.3, 0.3, 0.4], DCNL \'[1,1]\': [0.3, 0.3, 0.4], DCNL \'[1,2]\': [0.3, 0.3, 0.4], DCNL \'[2,0]\': [0.3, 0.3, 0.4], DCNL \'[2,1]\': [0.3, 0.3, 0.4], DCNL \'[2,2]\': [0.3, 0.3, 0.4]}'
def _generateModel2(numCategories, alpha=0.25): DCNL 'Generate the initial, first order, and second order transition DCNL probabilities for \'model2\'. For this model, we generate peaked random DCNL transitions using dirichlet distributions. DCNL Parameters: DCNL numCategories:      Number of categories DCNL alpha:              Determines the peakedness of the transitions. Low alpha DCNL values (alpha=0.01) place the entire weight on a single DCNL transition. Large alpha values (alpha=10) distribute the DCNL evenly among all transitions. Intermediate values (alpha=0.5) DCNL give a moderately peaked transitions. DCNL retval: (initProb, firstOrder, secondOrder, seqLen) DCNL initProb:     Initial probability for each category. This is a vector DCNL of length len(categoryList). DCNL firstOrder:   A dictionary of the 1st order probabilities. The key DCNL is the 1st element of the sequence, the value is DCNL the probability of each 2nd element given the first. DCNL secondOrder:  A dictionary of the 2nd order probabilities. The key DCNL is the first 2 elements of the sequence, the value is DCNL the probability of each possible 3rd element given the DCNL first two. DCNL seqLen:       Desired length of each sequence. The 1st element will DCNL be generated using the initProb, the 2nd element by the DCNL firstOrder table, and the 3rd and all successive DCNL elements by the secondOrder table. None means infinite DCNL length. DCNL Here is an example of some return values for an intermediate alpha value: DCNL initProb:         [0.33, 0.33, 0.33] DCNL firstOrder:       {\'[0]\': [0.2, 0.7, 0.1], DCNL \'[1]\': [0.1, 0.1, 0.8], DCNL \'[2]\': [0.1, 0.0, 0.9]} DCNL secondOrder:      {\'[0,0]\': [0.1, 0.0, 0.9], DCNL \'[0,1]\': [0.0, 0.2, 0.8], DCNL \'[0,2]\': [0.1, 0.8, 0.1], DCNL \'[2,2]\': [0.8, 0.2, 0.0]}'
def _generateFile(filename, numRecords, categoryList, initProb, firstOrderProb, secondOrderProb, seqLen, numNoise=0, resetsEvery=None): DCNL 'Generate a set of records reflecting a set of probabilities. DCNL Parameters: DCNL filename:         name of .csv file to generate DCNL numRecords:       number of records to generate DCNL categoryList:     list of category names DCNL initProb:         Initial probability for each category. This is a vector DCNL of length len(categoryList). DCNL firstOrderProb:   A dictionary of the 1st order probabilities. The key DCNL is the 1st element of the sequence, the value is DCNL the probability of each 2nd element given the first. DCNL secondOrderProb:  A dictionary of the 2nd order probabilities. The key DCNL is the first 2 elements of the sequence, the value is DCNL the probability of each possible 3rd element given the DCNL first two. DCNL seqLen:           Desired length of each sequence. The 1st element will DCNL be generated using the initProb, the 2nd element by the DCNL firstOrder table, and the 3rd and all successive DCNL elements by the secondOrder table. None means infinite DCNL length. DCNL numNoise:         Number of noise elements to place between each DCNL sequence. The noise elements are evenly distributed from DCNL all categories. DCNL resetsEvery:      If not None, generate a reset every N records DCNL Here is an example of some parameters: DCNL categoryList:     [\'cat1\', \'cat2\', \'cat3\'] DCNL initProb:         [0.7, 0.2, 0.1] DCNL firstOrderProb:   {\'[0]\': [0.3, 0.3, 0.4], DCNL \'[1]\': [0.3, 0.3, 0.4], DCNL \'[2]\': [0.3, 0.3, 0.4]} DCNL secondOrderProb:  {\'[0,0]\': [0.3, 0.3, 0.4], DCNL \'[0,1]\': [0.3, 0.3, 0.4], DCNL \'[0,2]\': [0.3, 0.3, 0.4], DCNL \'[1,0]\': [0.3, 0.3, 0.4], DCNL \'[1,1]\': [0.3, 0.3, 0.4], DCNL \'[1,2]\': [0.3, 0.3, 0.4], DCNL \'[2,0]\': [0.3, 0.3, 0.4], DCNL \'[2,1]\': [0.3, 0.3, 0.4], DCNL \'[2,2]\': [0.3, 0.3, 0.4]}'
def makeDataset(): DCNL ''
def writeSimpleTest1(filePath, numRecords, testNumber): DCNL 'Generates requested number of records and saves in a csv file'
def _abbreviate(text, threshold): DCNL 'Abbreviate the given text to threshold chars and append an ellipsis if its DCNL length exceeds threshold; used for logging; DCNL NOTE: the resulting text could be longer than threshold due to the ellipsis'
def enableConcurrencyChecks(maxConcurrency, raiseException=True): DCNL 'Enable the diagnostic feature for debugging unexpected concurrency in DCNL acquiring ConnectionWrapper instances. DCNL NOTE: This MUST be done early in your application\'s execution, BEFORE any DCNL accesses to ConnectionFactory or connection policies from your application DCNL (including imports and sub-imports of your app). DCNL Parameters: DCNL maxConcurrency:   A non-negative integer that represents the maximum expected DCNL number of outstanding connections.  When this value is DCNL exceeded, useful information will be logged and, depending DCNL on the value of the raiseException arg, DCNL ConcurrencyExceededError may be raised. DCNL raiseException:   If true, ConcurrencyExceededError will be raised when DCNL maxConcurrency is exceeded.'
def _getCommonSteadyDBArgsDict(): DCNL 'Returns a dictionary of arguments for DBUtils.SteadyDB.SteadyDBConnection DCNL constructor.'
def _getLogger(cls, logLevel=None): DCNL 'Gets a logger for the given class in this module'
def _isSequence(obj): DCNL 'Helper function to determine if a function is a list or sequence.'
def bitsToString(arr): DCNL 'Returns a string representing a numpy array of 0\'s and 1\'s'
def _allow_new_attributes(f): DCNL 'A decorator that maintains the attribute lock state of an object DCNL It coperates with the LockAttributesMetaclass (see bellow) that replaces DCNL the __setattr__ method with a custom one that checks the _canAddAttributes DCNL counter and allows setting new attributes only if _canAddAttributes > 0. DCNL New attributes can be set only from methods decorated DCNL with this decorator (should be only __init__ and __setstate__ normally) DCNL The decorator is reentrant (e.g. if from inside a decorated function another DCNL decorated function is invoked). Before invoking the target function it DCNL increments the counter (or sets it to 1). After invoking the target function DCNL it decrements the counter and if it\'s 0 it removed the counter.'
def _simple_init(self, *args, **kw): DCNL 'trivial init method that just calls base class\'s __init__() DCNL This method is attached to classes that don\'t define __init__(). It is needed DCNL because LockAttributesMetaclass must decorate the __init__() method of DCNL its target class.'
def longTest(testMethod): DCNL 'Decorator for specifying tests that only run when --long is specified.'
def tagTest(tag, comment=None): DCNL 'A decorator for tagging a test class or test method with the given tag DCNL string DCNL tag: test tag string DCNL comment: reason for the tag; string; optional DCNL Examples: DCNL @tagTest("slowTests", "takes a long time to execute") DCNL class ClusterTests(TestCase): DCNL def testSwarmWithAggregation(self): DCNL pass DCNL def testSwarmWithoutAggregation(self): DCNL pass DCNL or DCNL class MiscTests(TestCase): DCNL def testOnePlusOne(self): DCNL pass DCNL @tagTest("slowTests") DCNL def testSwarm(self): DCNL pass'
def getNumpyRandomGenerator(seed=None): DCNL 'Return a numpy random number generator with the given seed. DCNL If seed is None, set it randomly based on time. Regardless we log DCNL the actual seed and stack trace so that test failures are replicable.'
def convertPermanences(sourceSP, destSP): DCNL 'Transfer the permanences from source to dest SP\'s. This is used in test DCNL routines to counteract some drift between implementations. DCNL We assume the two SP\'s have identical configurations/parameters.'
def getSeed(): DCNL 'Generate and log a 32-bit compatible seed value.'
def convertSP(pySp, newSeed): DCNL 'Given an instance of a python spatial_pooler return an instance of the CPP DCNL spatial_pooler with identical parameters.'
def CreateSP(imp, params): DCNL 'Helper class for creating an instance of the appropriate spatial pooler using DCNL given parameters. DCNL Parameters: DCNL imp:       Either \'py\' or \'cpp\' for creating the appropriate instance. DCNL params:    A dict for overriding constructor parameters. The keys must DCNL correspond to contructor parameter names. DCNL Returns the SP object.'
def getCallerInfo(depth=2): DCNL 'Utility function to get information about function callers DCNL The information is the tuple (function/method name, filename, class) DCNL The class will be None if the caller is just a function and not an object DCNL method. DCNL :param depth: (int) how far back in the callstack to go to extract the caller DCNL info'
def title(s=None, additional='', stream=sys.stdout): DCNL 'Utility function to display nice titles DCNL It automatically extracts the name of the function/method it is called from DCNL and you can add additional text. title() will then print the name DCNL of the function/method and the additional text surrounded by tow lines DCNL of dashes. If you don\'t want the name of the function, you can provide DCNL alternative text (regardless of the additional text) DCNL :param s: (string) text to display, uses the function name and arguments by DCNL default DCNL :param additional: (string) extra text to display (not needed if s is not DCNL None) DCNL :param stream: (stream) the stream to print to. Ny default goes to standard DCNL output DCNL Examples: DCNL .. code-block:: python DCNL def foo(): DCNL title() DCNL will display: DCNL .. code-block:: text DCNL foo DCNL .. code-block:: python DCNL def foo(): DCNL title(additional=\'(), this is cool!!!\') DCNL will display: DCNL .. code-block:: text DCNL foo(), this is cool!!! DCNL .. code-block:: python DCNL def foo(): DCNL title(\'No function name here!\') DCNL will display: DCNL .. code-block:: text DCNL No function name here!'
def getArgumentDescriptions(f): DCNL 'Get the arguments, default values, and argument descriptions for a function. DCNL Parses the argument descriptions out of the function docstring, using a DCNL format something lke this: DCNL [junk] DCNL argument_name:     description... DCNL description... DCNL description... DCNL [junk] DCNL [more arguments] DCNL It will find an argument as long as the exact argument name starts the line. DCNL It will then strip a trailing colon, if present, then strip the rest of the DCNL line and use it to start the description. It will then strip and append any DCNL subsequent lines with a greater indent level than the original argument name. DCNL :param f: (function) to inspect DCNL :returns: (list of tuples) (``argName``, ``argDescription``, ``defaultValue``) DCNL If an argument has no default value, the tuple is only two elements long (as DCNL ``None`` cannot be used, since it could be a default value itself).'
def initLogging(verbose=False, console='stdout', consoleLevel='DEBUG'): DCNL 'Initilize NuPic logging by reading in from the logging configuration file. The DCNL logging configuration file is named ``nupic-logging.conf`` and is expected to DCNL be in the format defined by the python logging module. DCNL If the environment variable ``NTA_CONF_PATH`` is defined, then the logging DCNL configuration file is expected to be in the ``NTA_CONF_PATH`` directory. If DCNL ``NTA_CONF_PATH`` is not defined, then it is found in the \'conf/default\' DCNL subdirectory of the NuPic installation directory (typically DCNL ~/nupic/current/conf/default) DCNL The logging configuration file can use the environment variable DCNL ``NTA_LOG_DIR`` to set the locations of log files. If this variable is not DCNL defined, logging to files will be disabled. DCNL :param console: Defines console output for the default "root" logging DCNL configuration; this may be one of \'stdout\', \'stderr\', or None; DCNL Use None to suppress console logging output DCNL :param consoleLevel: DCNL Logging-level filter string for console output corresponding to DCNL logging levels in the logging module; may be one of: DCNL \'DEBUG\', \'INFO\', \'WARNING\', \'ERROR\', or \'CRITICAL\'. DCNL E.g.,  a value of\'WARNING\' suppresses DEBUG and INFO level output DCNL to console, but allows WARNING, ERROR, and CRITICAL'
def _genLoggingFilePath(): DCNL 'Generate a filepath for the calling app'
def aggregationToMonthsSeconds(interval): DCNL 'Return the number of months and seconds from an aggregation dict that DCNL represents a date and time. DCNL Interval is a dict that contain one or more of the following keys: \'years\', DCNL \'months\', \'weeks\', \'days\', \'hours\', \'minutes\', seconds\', \'milliseconds\', DCNL \'microseconds\'. DCNL For example: DCNL aggregationMicroseconds({\'years\': 1, \'hours\': 4, \'microseconds\':42}) == DCNL {\'months\':12, \'seconds\':14400.000042} DCNL :param interval: (dict) The aggregation interval representing a date and time DCNL :returns: (dict) number of months and seconds in the interval: DCNL ``{months\': XX, \'seconds\': XX}``. The seconds is DCNL a floating point that can represent resolutions down to a DCNL microsecond.'
def aggregationDivide(dividend, divisor): DCNL 'Return the result from dividing two dicts that represent date and time. DCNL Both dividend and divisor are dicts that contain one or more of the following DCNL keys: \'years\', \'months\', \'weeks\', \'days\', \'hours\', \'minutes\', seconds\', DCNL \'milliseconds\', \'microseconds\'. DCNL For example: DCNL aggregationDivide({\'hours\': 4}, {\'minutes\': 15}) == 16 DCNL :param dividend: (dict) The numerator, as a dict representing a date and time DCNL :param divisor: (dict) the denominator, as a dict representing a date and time DCNL :returns: (float) number of times divisor goes into dividend'
def makeDirectoryFromAbsolutePath(absDirPath): DCNL 'Makes directory for the given directory path with default permissions. DCNL If the directory already exists, it is treated as success. DCNL :param absDirPath: (string) absolute path of the directory to create. DCNL :raises: OSError if directory creation fails DCNL :returns: (string) absolute path provided'
def groupby2(*args): DCNL 'Like itertools.groupby, with the following additions: DCNL - Supports multiple sequences. Instead of returning (k, g), each iteration DCNL returns (k, g0, g1, ...), with one `g` for each input sequence. The value of DCNL each `g` is either a non-empty iterator or `None`. DCNL - It treats the value `None` as an empty sequence. So you can make subsequent DCNL calls to groupby2 on any `g` value. DCNL .. note:: Read up on groupby here: DCNL https://docs.python.org/dev/library/itertools.html#itertools.groupby DCNL :param args: (list) Parameters alternating between sorted lists and their DCNL respective key functions. The lists should be sorted with DCNL respect to their key function. DCNL :returns: (tuple) A n + 1 dimensional tuple, where the first element is the DCNL key of the iteration, and the other n entries are groups of DCNL objects that share this key. Each group corresponds to the an DCNL input sequence. `groupby2` is a generator that returns a tuple DCNL for every iteration. If an input sequence has no members with DCNL the current key, None is returned in place of a generator.'
def Enum(*args, **kwargs): DCNL 'Utility function for creating enumerations in python DCNL Example Usage: DCNL >> Color = Enum("Red", "Green", "Blue", "Magenta") DCNL >> print Color.Red DCNL >> 0 DCNL >> print Color.Green DCNL >> 1 DCNL >> print Color.Blue DCNL >> 2 DCNL >> print Color.Magenta DCNL >> 3 DCNL >> Color.Violet DCNL >> \'violet\' DCNL >> Color.getLabel(Color.Red) DCNL >> \'Red\' DCNL >> Color.getLabel(2) DCNL >> \'Blue\''
def logExceptions(logger=None): DCNL 'Returns a closure suitable for use as function/method decorator for DCNL logging exceptions that leave the scope of the decorated function. Exceptions DCNL are logged at ERROR level. DCNL logger:    user-supplied logger instance. Defaults to logging.getLogger. DCNL Usage Example: DCNL NOTE: logging must be initialized *before* any loggers are created, else DCNL there will be no output; see nupic.support.initLogging() DCNL @logExceptions() DCNL def myFunctionFoo(): DCNL raise RuntimeError("something bad happened")'
def logEntryExit(getLoggerCallback=logging.getLogger, entryExitLogLevel=logging.DEBUG, logArgs=False, logTraceback=False): DCNL 'Returns a closure suitable for use as function/method decorator for DCNL logging entry/exit of function/method. DCNL getLoggerCallback:    user-supplied callback function that takes no args and DCNL returns the logger instance to use for logging. DCNL entryExitLogLevel:    Log level for logging entry/exit of decorated function; DCNL e.g., logging.DEBUG; pass None to disable entry/exit DCNL logging. DCNL logArgs:              If True, also log args DCNL logTraceback:         If True, also log Traceback information DCNL Usage Examples: DCNL NOTE: logging must be initialized *before* any loggers are created, else DCNL there will be no output; see nupic.support.initLogging() DCNL @logEntryExit() DCNL def myFunctionBar(): DCNL @logEntryExit(logTraceback=True) DCNL @logExceptions() DCNL def myFunctionGamma(): DCNL raise RuntimeError("something bad happened")'
def retry(timeoutSec, initialRetryDelaySec, maxRetryDelaySec, retryExceptions=(Exception,), retryFilter=(lambda e, args, kwargs: True), logger=None, clientLabel=''): DCNL 'Returns a closure suitable for use as function/method decorator for DCNL retrying a function being decorated. DCNL timeoutSec:           How many seconds from time of initial call to stop DCNL retrying (floating point); 0 = no retries DCNL initialRetryDelaySec: Number of seconds to wait for first retry. DCNL Subsequent retries will occur at geometrically DCNL doubling intervals up to a maximum interval of DCNL maxRetryDelaySec (floating point) DCNL maxRetryDelaySec:     Maximum amount of seconds to wait between retries DCNL (floating point) DCNL retryExceptions:      A tuple (must be a tuple) of exception classes that, DCNL including their subclasses, should trigger retries; DCNL Default: any Exception-based exception will trigger DCNL retries DCNL retryFilter:          Optional filter function used to further filter the DCNL exceptions in the retryExceptions tuple; called if the DCNL current exception meets the retryExceptions criteria: DCNL takes the current exception instance, args, and kwargs DCNL that were passed to the decorated function, and returns DCNL True to retry, False to allow the exception to be DCNL re-raised without retrying. Default: permits any DCNL exception that matches retryExceptions to be retried. DCNL logger:               User-supplied logger instance to use for logging. DCNL None=defaults to logging.getLogger(__name__). DCNL Usage Example: DCNL NOTE: logging must be initialized *before* any loggers are created, else DCNL there will be no output; see nupic.support.initLogging() DCNL _retry = retry(timeoutSec=300, initialRetryDelaySec=0.2, DCNL maxRetryDelaySec=10, retryExceptions=[socket.error]) DCNL @_retry DCNL def myFunctionFoo(): DCNL raise RuntimeError("something bad happened")'
def retrySQL(timeoutSec=(60 * 5), logger=None): DCNL 'Return a closure suitable for use as a decorator for DCNL retrying a pymysql DAO function on certain failures that warrant retries ( DCNL e.g., RDS/MySQL server down temporarily, transaction deadlock, etc.). DCNL We share this function across multiple scripts (e.g., ClientJobsDAO, DCNL StreamMgr) for consitent behavior. DCNL .. note:: Please ensure that the operation being retried is idempotent. DCNL .. note:: logging must be initialized *before* any loggers are created, else DCNL there will be no output; see nupic.support.initLogging() DCNL Usage Example: DCNL .. code-block:: python DCNL @retrySQL() DCNL def jobInfo(self, jobID): DCNL :param timeoutSec:       How many seconds from time of initial call to stop retrying DCNL (floating point) DCNL :param logger:           User-supplied logger instance.'
def lscsum(lx, epsilon=None): DCNL 'Accepts log-values as input, exponentiates them, computes the sum, DCNL then converts the sum back to log-space and returns the result. DCNL Handles underflow by rescaling so that the largest values is exactly 1.0.'
def lscsum0(lx): DCNL 'Accepts log-values as input, exponentiates them, sums down the rows DCNL (first dimension), then converts the sum back to log-space and returns the result. DCNL Handles underflow by rescaling so that the largest values is exactly 1.0.'
def normalize(lx): DCNL 'Accepts log-values as input, exponentiates them, DCNL normalizes and returns the result. DCNL Handles underflow by rescaling so that the largest values is exactly 1.0.'
def nsum0(lx): DCNL 'Accepts log-values as input, exponentiates them, sums down the rows DCNL (first dimension), normalizes and returns the result. DCNL Handles underflow by rescaling so that the largest values is exactly 1.0.'
def lnsum0(lx): DCNL 'Accepts log-values as input, exponentiates them, sums down the rows DCNL (first dimension), normalizes, then converts the sum back to DCNL log-space and returns the result. DCNL Handles underflow by rescaling so that the largest values is exactly 1.0.'
def logSumExp(A, B, out=None): DCNL 'returns log(exp(A) + exp(B)). A and B are numpy arrays'
def logDiffExp(A, B, out=None): DCNL 'returns log(exp(A) - exp(B)). A and B are numpy arrays. values in A should be DCNL greater than or equal to corresponding values in B'
def ROCCurve(y_true, y_score): DCNL 'compute Receiver operating characteristic (ROC) DCNL Note: this implementation is restricted to the binary classification task. DCNL Parameters DCNL y_true : array, shape = [n_samples] DCNL true binary labels DCNL y_score : array, shape = [n_samples] DCNL target scores, can either be probability estimates of DCNL the positive class, confidence values, or binary decisions. DCNL Returns DCNL fpr : array, shape = [>2] DCNL False Positive Rates DCNL tpr : array, shape = [>2] DCNL True Positive Rates DCNL thresholds : array, shape = [>2] DCNL Thresholds on y_score used to compute fpr and tpr DCNL Examples DCNL >>> import numpy as np DCNL >>> from sklearn import metrics DCNL >>> y = np.array([1, 1, 2, 2]) DCNL >>> scores = np.array([0.1, 0.4, 0.35, 0.8]) DCNL >>> fpr, tpr, thresholds = metrics.roc_curve(y, scores) DCNL >>> fpr DCNL array([ 0. ,  0.5,  0.5,  1. ]) DCNL References DCNL http://en.wikipedia.org/wiki/Receiver_operating_characteristic'
def AreaUnderCurve(x, y): DCNL 'Compute Area Under the Curve (AUC) using the trapezoidal rule DCNL Parameters DCNL x : array, shape = [n] DCNL x coordinates DCNL y : array, shape = [n] DCNL y coordinates DCNL Returns DCNL auc : float DCNL Examples DCNL >>> import numpy as np DCNL >>> from sklearn import metrics DCNL >>> y = np.array([1, 1, 2, 2]) DCNL >>> pred = np.array([0.1, 0.4, 0.35, 0.8]) DCNL >>> fpr, tpr, thresholds = metrics.roc_curve(y, pred) DCNL >>> metrics.auc(fpr, tpr) DCNL 0.75'
def _test(): DCNL 'This is a toy example, to show the basic functionality: DCNL The dataset is: DCNL actual    prediction DCNL 0          0.1 DCNL 0          0.4 DCNL 1          0.5 DCNL 1          0.3 DCNL 1          0.45 DCNL Some ROC terminology: DCNL A True Positive (TP) is when we predict TRUE and the actual value is 1. DCNL A False Positive (FP) is when we predict TRUE, but the actual value is 0. DCNL The True Positive Rate (TPR) is TP/P, where P is the total number of actual DCNL positives (3 in this example, the last 3 samples). DCNL The False Positive Rate (FPR) is FP/N, where N is the total number of actual DCNL negatives (2 in this example, the first 2 samples) DCNL Here are the classifications at various choices for the threshold. The DCNL prediction is TRUE if the predicted value is >= threshold and FALSE otherwise. DCNL actual    pred      0.50    0.45    0.40    0.30    0.10 DCNL 0          0.1      0        0      0        0      1 DCNL 0          0.4      0        0      1        1      1 DCNL 1          0.5      1        1      1        1      1 DCNL 1          0.3      0        0      0        1      1 DCNL 1          0.45     0        1      1        1      1 DCNL TruePos(TP)         1        2      2        3      3 DCNL FalsePos(FP)        0        0      1        1      2 DCNL TruePosRate(TPR)    1/3      2/3    2/3      3/3    3/3 DCNL FalsePosRate(FPR)   0/2      0/2    1/2      1/2    2/2 DCNL The ROC curve is a plot of FPR on the x-axis and TPR on the y-axis. Basically, DCNL one can pick any operating point along this curve to run, the operating point DCNL determined by which threshold you want to use. By changing the threshold, you DCNL tradeoff TP\'s for FPs. DCNL The more area under this curve, the better the classification algorithm is. DCNL The AreaUnderCurve() function can be used to compute the area under this DCNL curve.'
def logFactorial(x): DCNL 'Approximation to the log of the factorial function.'
def pickByDistribution(distribution, r=None): DCNL 'Pick a value according to the provided distribution. DCNL Example: DCNL pickByDistribution([.2, .1]) DCNL Returns 0 two thirds of the time and 1 one third of the time. DCNL :param distribution: Probability distribution. Need not be normalized. DCNL :param r: Instance of random.Random. Uses the system instance if one is DCNL not provided.'
def Indicator(pos, size, dtype): DCNL 'Returns an array of length size and type dtype that is everywhere 0, DCNL except in the index in pos. DCNL :param pos: (int) specifies the position of the one entry that will be set. DCNL :param size: (int) The total size of the array to be returned. DCNL :param dtype: The element type (compatible with NumPy array()) DCNL of the array to be returned. DCNL :returns: (list) of length ``size`` and element type ``dtype``.'
def MultiArgMax(x): DCNL 'Get tuple (actually a generator) of indices where the max value of DCNL array x occurs. Requires that x have a max() method, as x.max() DCNL (in the case of NumPy) is much faster than max(x). DCNL For a simpler, faster argmax when there is only a single maximum entry, DCNL or when knowing only the first index where the maximum occurs, DCNL call argmax() on a NumPy array. DCNL :param x: Any sequence that has a max() method. DCNL :returns: Generator with the indices where the max value occurs.'
def Any(sequence): DCNL 'Tests much faster (30%) than bool(sum(bool(x) for x in sequence)). DCNL :returns: (bool) true if any element of the sequence satisfies True. DCNL :param sequence: Any sequence whose elements can be evaluated as booleans.'
def All(sequence): DCNL ':param sequence: Any sequence whose elements can be evaluated as booleans. DCNL :returns: true if all elements of the sequence satisfy True and x.'
def Product(sequence): DCNL 'Returns the product of the elements of the sequence. DCNL Use numpy.prod() if the sequence is an array, as it will be faster. DCNL Remember that the product of many numbers may rapidly overflow or DCNL underflow the numeric precision of the computer. DCNL Use a sum of the logs of the sequence elements instead when precision DCNL should be maintained. DCNL :param sequence: Any sequence whose elements can be multiplied by their DCNL neighbors. DCNL :returns: A single value that is the product of all the sequence elements.'
def MultiIndicator(pos, size, dtype): DCNL 'Returns an array of length size and type dtype that is everywhere 0, DCNL except in the indices listed in sequence pos. DCNL :param pos:   A single integer or sequence of integers that specify DCNL the position of ones to be set. DCNL :param size:  The total size of the array to be returned. DCNL :param dtype: The element type (compatible with NumPy array()) DCNL of the array to be returned. DCNL :returns: An array of length size and element type dtype.'
def Distribution(pos, size, counts, dtype): DCNL 'Returns an array of length size and type dtype that is everywhere 0, DCNL except in the indices listed in sequence pos.  The non-zero indices DCNL contain a normalized distribution based on the counts. DCNL :param pos:    A single integer or sequence of integers that specify DCNL the position of ones to be set. DCNL :param size:   The total size of the array to be returned. DCNL :param counts: The number of times we have observed each index. DCNL :param dtype:  The element type (compatible with NumPy array()) DCNL of the array to be returned. DCNL :returns: An array of length size and element type dtype.'
def cross_list(*sequences): DCNL 'From: http://book.opensourceproject.org.cn/lamp/python/pythoncook2/opensource/0596007973/pythoncook2-chp-19-sect-9.html'
def cross(*sequences): DCNL 'From: http://book.opensourceproject.org.cn/lamp/python/pythoncook2/opensource/0596007973/pythoncook2-chp-19-sect-9.html'
def dcross(**keywords): DCNL 'Similar to cross(), but generates output dictionaries instead of tuples.'
def coordinatesFromIndex(index, dimensions): DCNL 'Translate an index into coordinates, using the given coordinate system. DCNL Similar to ``numpy.unravel_index``. DCNL :param index: (int) The index of the point. The coordinates are expressed as a DCNL single index by using the dimensions as a mixed radix definition. For DCNL example, in dimensions 42x10, the point [1, 4] is index DCNL 1*420 + 4*10 = 460. DCNL :param dimensions (list of ints) The coordinate system. DCNL :returns: (list) of coordinates of length ``len(dimensions)``.'
def indexFromCoordinates(coordinates, dimensions): DCNL 'Translate coordinates into an index, using the given coordinate system. DCNL Similar to ``numpy.ravel_multi_index``. DCNL :param coordinates: (list of ints) A list of coordinates of length DCNL ``dimensions.size()``. DCNL :param dimensions: (list of ints) The coordinate system. DCNL :returns: (int) The index of the point. The coordinates are expressed as a DCNL single index by using the dimensions as a mixed radix definition. DCNL For example, in dimensions 42x10, the point [1, 4] is index DCNL 1*420 + 4*10 = 460.'
def neighborhood(centerIndex, radius, dimensions): DCNL 'Get the points in the neighborhood of a point. DCNL A point\'s neighborhood is the n-dimensional hypercube with sides ranging DCNL [center - radius, center + radius], inclusive. For example, if there are two DCNL dimensions and the radius is 3, the neighborhood is 6x6. Neighborhoods are DCNL truncated when they are near an edge. DCNL This is designed to be fast. In C++ it\'s fastest to iterate through neighbors DCNL one by one, calculating them on-demand rather than creating a list of them. DCNL But in Python it\'s faster to build up the whole list in batch via a few calls DCNL to C code rather than calculating them on-demand with lots of calls to Python DCNL code. DCNL :param centerIndex: (int) The index of the point. The coordinates are DCNL expressed as a single index by using the dimensions as a mixed radix DCNL definition. For example, in dimensions 42x10, the point [1, 4] is index DCNL 1*420 + 4*10 = 460. DCNL :param radius: (int) The radius of this neighborhood about the DCNL ``centerIndex``. DCNL :param dimensions: (indexable sequence) The dimensions of the world outside DCNL this neighborhood. DCNL :returns: (numpy array) The points in the neighborhood, including DCNL ``centerIndex``.'
def wrappingNeighborhood(centerIndex, radius, dimensions): DCNL 'Like :meth:`neighborhood`, except that the neighborhood isn\'t truncated when DCNL it\'s near an edge. It wraps around to the other side. DCNL :param centerIndex: (int) The index of the point. The coordinates are DCNL expressed as a single index by using the dimensions as a mixed radix DCNL definition. For example, in dimensions 42x10, the point [1, 4] is index DCNL 1*420 + 4*10 = 460. DCNL :param radius: (int) The radius of this neighborhood about the DCNL ``centerIndex``. DCNL :param dimensions: (indexable sequence) The dimensions of the world outside DCNL this neighborhood. DCNL :returns: (numpy array) The points in the neighborhood, including DCNL ``centerIndex``.'
def add(reader, writer, column, start, stop, value): DCNL 'Adds a value over a range of rows. DCNL Args: DCNL reader: A FileRecordStream object with input data. DCNL writer: A FileRecordStream object to write output data to. DCNL column: The column of data to modify. DCNL start: The first row in the range to modify. DCNL end: The last row in the range to modify. DCNL value: The value to add.'
def scale(reader, writer, column, start, stop, multiple): DCNL 'Multiplies a value over a range of rows. DCNL Args: DCNL reader: A FileRecordStream object with input data. DCNL writer: A FileRecordStream  object to write output data to. DCNL column: The column of data to modify. DCNL start: The first row in the range to modify. DCNL end: The last row in the range to modify. DCNL multiple: The value to scale/multiply by.'
def copy(reader, writer, start, stop, insertLocation=None, tsCol=None): DCNL 'Copies a range of values to a new location in the data set. DCNL Args: DCNL reader: A FileRecordStream object with input data. DCNL writer: A FileRecordStream object to write output data to. DCNL start: The first row in the range to copy. DCNL stop: The last row in the range to copy. DCNL insertLocation: The location to insert the copied range. If not specified, DCNL the range is inserted immediately following itself.'
def sample(reader, writer, n, start=None, stop=None, tsCol=None, writeSampleOnly=True): DCNL 'Samples n rows. DCNL Args: DCNL reader: A FileRecordStream object with input data. DCNL writer: A FileRecordStream object to write output data to. DCNL n: The number of elements to sample. DCNL start: The first row in the range to sample from. DCNL stop: The last row in the range to sample from. DCNL tsCol: If specified, the timestamp column to update. DCNL writeSampleOnly: If False, the rows before start are written before the DCNL sample and the rows after stop are written after the sample.'
def parseTimestamp(s): DCNL 'Parses a textual datetime format and return a Python datetime object. DCNL The supported format is: ``yyyy-mm-dd h:m:s.ms`` DCNL The time component is optional. DCNL - hours are 00..23 (no AM/PM) DCNL - minutes are 00..59 DCNL - seconds are 00..59 DCNL - micro-seconds are 000000..999999 DCNL :param s: (string) input time text DCNL :return: (datetime.datetime)'
def serializeTimestamp(t): DCNL 'Turns a datetime object into a string. DCNL :param t: (datetime.datetime) DCNL :return: (string) in default format (see DCNL :const:`~nupic.data.utils.DATETIME_FORMATS` [0])'
def serializeTimestampNoMS(t): DCNL 'Turns a datetime object into a string ignoring milliseconds. DCNL :param t: (datetime.datetime) DCNL :return: (string) in default format (see DCNL :const:`~nupic.data.utils.DATETIME_FORMATS` [2])'
def parseBool(s): DCNL 'String to boolean DCNL :param s: (string) DCNL :return: (bool)'
def floatOrNone(f): DCNL 'Tries to convert input to a float input or returns ``None``. DCNL :param f: (object) thing to convert to a float DCNL :return: (float or ``None``)'
def intOrNone(i): DCNL 'Tries to convert input to a int input or returns ``None``. DCNL :param f: (object) thing to convert to a int DCNL :return: (int or ``None``)'
def escape(s): DCNL 'Escape commas, tabs, newlines and dashes in a string DCNL Commas are encoded as tabs. DCNL :param s: (string) to escape DCNL :returns: (string) escaped string'
def unescape(s): DCNL 'Unescapes a string that may contain commas, tabs, newlines and dashes DCNL Commas are decoded from tabs. DCNL :param s: (string) to unescape DCNL :returns: (string) unescaped string'
def parseSdr(s): DCNL 'Parses a string containing only 0\'s and 1\'s and return a Python list object. DCNL :param s: (string) string to parse DCNL :returns: (list) SDR out'
def serializeSdr(sdr): DCNL 'Serialize Python list object containing only 0\'s and 1\'s to string. DCNL :param sdr: (list) binary DCNL :returns: (string) SDR out'
def parseStringList(s): DCNL 'Parse a string of space-separated numbers, returning a Python list. DCNL :param s: (string) to parse DCNL :returns: (list) binary SDR'
def stripList(listObj): DCNL 'Convert a list of numbers to a string of space-separated values. DCNL :param listObj: (list) to convert DCNL :returns: (string) of space-separated values'
def sort(filename, key, outputFile, fields=None, watermark=((1024 * 1024) * 100)): DCNL 'Sort a potentially big file DCNL filename - the input file (standard File format) DCNL key - a list of field names to sort by DCNL outputFile - the name of the output file DCNL fields - a list of fields that should be included (all fields if None) DCNL watermark - when available memory goes bellow the watermark create a new chunk DCNL sort() works by reading as records from the file into memory DCNL and calling _sortChunk() on each chunk. In the process it gets DCNL rid of unneeded fields if any. Once all the chunks have been sorted and DCNL written to chunk files it calls _merge() to merge all the chunks into a DCNL single sorted file. DCNL Note, that sort() gets a key that contains field names, which it converts DCNL into field indices for _sortChunk() becuase _sortChunk() doesn\'t need to know DCNL the field name. DCNL sort() figures out by itself how many chunk files to use by reading records DCNL from the file until the low watermark value of availabel memory is hit and DCNL then it sorts the current records, generates a chunk file, clears the sorted DCNL records and starts on a new chunk. DCNL The key field names are turned into indices'
def _sortChunk(records, key, chunkIndex, fields): DCNL 'Sort in memory chunk of records DCNL records - a list of records read from the original dataset DCNL key - a list of indices to sort the records by DCNL chunkIndex - the index of the current chunk DCNL The records contain only the fields requested by the user. DCNL _sortChunk() will write the sorted records to a standard File DCNL named "chunk_<chunk index>.csv" (chunk_0.csv, chunk_1.csv,...).'
def _mergeFiles(key, chunkCount, outputFile, fields): DCNL 'Merge sorted chunk files into a sorted output file DCNL chunkCount - the number of available chunk files DCNL outputFile the name of the sorted output file DCNL _mergeFiles()'
def generateStats(filename, maxSamples=None): DCNL 'Collect statistics for each of the fields in the user input data file and DCNL return a stats dict object. DCNL Parameters: DCNL filename:             The path and name of the data file. DCNL maxSamples:           Upper bound on the number of rows to be processed DCNL retval:               A dictionary of dictionaries. The top level keys are the DCNL field names and the corresponding values are the statistics DCNL collected for the individual file. DCNL Example: DCNL \'consumption\':{\'min\':0,\'max\':90,\'mean\':50,...}, DCNL \'gym\':{\'numDistinctCategories\':10,...},'
def initFilter(input, filterInfo=None): DCNL 'Initializes internal filter variables for further processing. DCNL Returns a tuple (function to call,parameters for the filter call) DCNL The filterInfo is a dict. Here is an example structure: DCNL {fieldName: {\'min\': x, DCNL \'max\': y, DCNL \'type\': \'category\', # or \'number\' DCNL \'acceptValues\': [\'foo\', \'bar\'], DCNL This returns the following: DCNL (filterFunc, ((fieldIdx, fieldFilterFunc, filterDict), DCNL Where fieldIdx is the index of the field within each record DCNL fieldFilterFunc returns True if the value is "OK" (within min, max or DCNL part of acceptValues) DCNL fieldDict is a dict containing \'type\', \'min\', max\', \'acceptValues\''
def _filterRecord(filterList, record): DCNL 'Takes a record and returns true if record meets filter criteria, DCNL false otherwise'
def _aggr_first(inList): DCNL 'Returns first non-None element in the list, or None if all are None'
def _aggr_last(inList): DCNL 'Returns last non-None element in the list, or None if all are None'
def _aggr_sum(inList): DCNL 'Returns sum of the elements in the list. Missing items are replaced with DCNL the mean value'
def _aggr_mean(inList): DCNL 'Returns mean of non-None elements of the list'
def _aggr_mode(inList): DCNL 'Returns most common value seen in the non-None elements of the list'
def _aggr_weighted_mean(inList, params): DCNL 'Weighted mean uses params (must be the same size as inList) and DCNL makes weighed mean of inList'
def generateDataset(aggregationInfo, inputFilename, outputFilename=None): DCNL 'Generate a dataset of aggregated values DCNL Parameters: DCNL aggregationInfo: a dictionary that contains the following entries DCNL - fields: a list of pairs. Each pair is a field name and an DCNL aggregation function (e.g. sum). The function will be used to aggregate DCNL multiple values during the aggregation period. DCNL aggregation period: 0 or more of unit=value fields; allowed units are: DCNL [years months] | DCNL [weeks days hours minutes seconds milliseconds microseconds] DCNL NOTE: years and months are mutually-exclusive with the other units. DCNL See getEndTime() and _aggregate() for more details. DCNL Example1: years=1, months=6, DCNL Example2: hours=1, minutes=30, DCNL If none of the period fields are specified or if all that are specified DCNL have values of 0, then aggregation will be suppressed, and the given DCNL inputFile parameter value will be returned. DCNL inputFilename: filename of the input dataset within examples/prediction/data DCNL outputFilename: name for the output file. If not given, a name will be DCNL generated based on the input filename and the aggregation params DCNL retval: Name of the generated output file. This will be the same as the input DCNL file name if no aggregation needed to be performed DCNL If the input file contained a time field, sequence id field or reset field DCNL that were not specified in aggregationInfo fields, those fields will be DCNL added automatically with the following rules: DCNL 1. The order will be R, S, T, rest of the fields DCNL 2. The aggregation function for all will be to pick the first: lambda x: x[0] DCNL Returns: the path of the aggregated data file if aggregation was performed DCNL (in the same directory as the given input file); if aggregation did not DCNL need to be performed, then the given inputFile argument value is returned.'
def getFilename(aggregationInfo, inputFile): DCNL 'Generate the filename for aggregated dataset DCNL The filename is based on the input filename and the DCNL aggregation period. DCNL Returns the inputFile if no aggregation required (aggregation DCNL info has all 0\'s)'
def rUpdate(original, updates): DCNL 'Recursively updates the values in original with the values from updates.'
def rApply(d, f): DCNL 'Recursively applies f to the values in dict d. DCNL Args: DCNL d: The dict to recurse over. DCNL f: A function to apply to values in d that takes the value and a list of DCNL keys from the root of the dict to the value.'
def dictDiffAndReport(da, db): DCNL 'Compares two python dictionaries at the top level and report differences, DCNL if any, to stdout DCNL da:             first dictionary DCNL db:             second dictionary DCNL Returns:        The same value as returned by dictDiff() for the given args'
def dictDiff(da, db): DCNL 'Compares two python dictionaries at the top level and return differences DCNL da:             first dictionary DCNL db:             second dictionary DCNL Returns:        None if dictionaries test equal; otherwise returns a DCNL dictionary as follows: DCNL \'inAButNotInB\': DCNL <sequence of keys that are in da but not in db> DCNL \'inBButNotInA\': DCNL <sequence of keys that are in db but not in da> DCNL \'differentValues\': DCNL <sequence of keys whose corresponding values differ DCNL between da and db>'
def generateStats(filename, statsInfo, maxSamples=None, filters=[], cache=True): DCNL 'Generate requested statistics for a dataset and cache to a file. DCNL If filename is None, then don\'t cache to a file'
def _getFieldIndexBySpecial(fields, special): DCNL 'Return index of the field matching the field meta special value. DCNL :param fields: sequence of nupic.data.fieldmeta.FieldMetaInfo objects DCNL representing the fields of a stream DCNL :param special: one of the special field attribute values from DCNL nupic.data.fieldmeta.FieldMetaSpecial DCNL :returns: first zero-based index of the field tagged with the target field DCNL meta special attribute; None if no such field'
def validate(value, **kwds): DCNL 'Validate a python value against json schema: DCNL validate(value, schemaPath) DCNL validate(value, schemaDict) DCNL value:          python object to validate against the schema DCNL The json schema may be specified either as a path of the file containing DCNL the json schema or as a python dictionary using one of the DCNL following keywords as arguments: DCNL schemaPath:     Path of file containing the json schema object. DCNL schemaDict:     Python dictionary containing the json schema object DCNL Returns: nothing DCNL Raises: DCNL ValidationError when value fails json validation'
def loadJsonValueFromFile(inputFilePath): DCNL 'Loads a json value from a file and converts it to the corresponding python DCNL object. DCNL inputFilePath: DCNL Path of the json file; DCNL Returns: DCNL python value that represents the loaded json value'
def test(): DCNL ''
def Array(dtype, size=None, ref=False): DCNL 'Factory function that creates typed Array or ArrayRef objects DCNL dtype - the data type of the array (as string). DCNL Supported types are: Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Real32, Real64 DCNL size - the size of the array. Must be positive integer.'
def createDataOutLink(network, sensorRegionName, regionName): DCNL 'Link sensor region to other region so that it can pass it data.'
def createFeedForwardLink(network, regionName1, regionName2): DCNL 'Create a feed-forward link between 2 regions: regionName1 -> regionName2'
def createSensorToClassifierLinks(network, sensorRegionName, classifierRegionName): DCNL 'Create required links from a sensor region to a classifier region.'
def getPredictionResults(network, clRegionName): DCNL 'Helper function to extract results for all prediction steps.'
def createDataOutLink(network, sensorRegionName, regionName): DCNL 'Link sensor region to other region so that it can pass it data.'
def createFeedForwardLink(network, regionName1, regionName2): DCNL 'Create a feed-forward link between 2 regions: regionName1 -> regionName2'
def createResetLink(network, sensorRegionName, regionName): DCNL 'Create a reset link from a sensor region: sensorRegionName -> regionName'
def createSensorToClassifierLinks(network, sensorRegionName, classifierRegionName): DCNL 'Create required links from a sensor region to a classifier region.'
def createEncoder(encoderParams): DCNL 'Create a multi-encoder from params.'
def createNetwork(dataSource): DCNL 'Create and initialize a network.'
def getPredictionResults(network, clRegionName): DCNL 'Get prediction results for all prediction steps.'
def runHotgym(numRecords): DCNL 'Run the Hot Gym example.'
