def test_default_param(self): DCNL DCSP args = self.parser.parse_args(['tests.csv']) DCNL DCSP self.assertEqual(args.CROSSOVER_RATE, 0.1) DCNL DCSP self.assertEqual(args.DISABLE_UPDATE_CHECK, False) DCNL DCSP self.assertEqual(args.GENERATIONS, 100) DCNL DCSP self.assertEqual(args.INPUT_FILE, 'tests.csv') DCNL DCSP self.assertEqual(args.INPUT_SEPARATOR, ' DCTB ') DCNL DCSP self.assertEqual(args.MAX_EVAL_MINS, 5) DCNL DCSP self.assertEqual(args.MUTATION_RATE, 0.9) DCNL DCSP self.assertEqual(args.NUM_CV_FOLDS, 5) DCNL DCSP self.assertEqual(args.NUM_JOBS, 1) DCNL DCSP self.assertEqual(args.OFFSPRING_SIZE, None) DCNL DCSP self.assertEqual(args.OUTPUT_FILE, '') DCNL DCSP self.assertEqual(args.POPULATION_SIZE, 100) DCNL DCSP self.assertEqual(args.RANDOM_STATE, None) DCNL DCSP self.assertEqual(args.SUBSAMPLE, 1.0) DCNL DCSP self.assertEqual(args.SCORING_FN, None) DCNL DCSP self.assertEqual(args.TARGET_NAME, 'class') DCNL DCSP self.assertEqual(args.TPOT_MODE, 'classification') DCNL DCSP self.assertEqual(args.VERBOSITY, 1)
def test_print_args(self): DCNL DCSP args = self.parser.parse_args(['tests.csv']) DCNL DCSP with captured_output() as (out, err): DCNL DCSP  DCSP _print_args(args) DCNL DCSP output = out.getvalue() DCNL DCSP expected_output = '\nTPOT DCSP settings:\nCONFIG_FILE DCTB = DCTB None\nCROSSOVER_RATE DCTB = DCTB 0.1\nGENERATIONS DCTB = DCTB 100\nINPUT_FILE DCTB = DCTB tests.csv\nINPUT_SEPARATOR DCTB = DCTB  DCTB \nMAX_EVAL_MINS DCTB = DCTB 5\nMAX_TIME_MINS DCTB = DCTB None\nMUTATION_RATE DCTB = DCTB 0.9\nNUM_CV_FOLDS DCTB = DCTB 5\nNUM_JOBS DCTB = DCTB 1\nOFFSPRING_SIZE DCTB = DCTB 100\nOUTPUT_FILE DCTB = DCTB \nPOPULATION_SIZE DCTB = DCTB 100\nRANDOM_STATE DCTB = DCTB None\nSCORING_FN DCTB = DCTB accuracy\nSUBSAMPLE DCTB = DCTB 1.0\nTARGET_NAME DCTB = DCTB class\nTPOT_MODE DCTB = DCTB classification\nVERBOSITY DCTB = DCTB 1\n\n' DCNL DCSP self.assertEqual(_sort_lines(expected_output), _sort_lines(output))
@property DCNL def __name__(self): DCNL DCSP return self.__class__.__name__
def fit(self, X, y=None): DCNL DCSP return self
def transform(self, X, y=None): DCNL DCSP X = check_array(X) DCNL DCSP n_features = X.shape[1] DCNL DCSP X_transformed = np.copy(X) DCNL DCSP non_zero_vector = np.count_nonzero(X_transformed, axis=1) DCNL DCSP non_zero = np.reshape(non_zero_vector, ((-1), 1)) DCNL DCSP zero_col = np.reshape((n_features - non_zero_vector), ((-1), 1)) DCNL DCSP X_transformed = np.hstack((non_zero, X_transformed)) DCNL DCSP X_transformed = np.hstack((zero_col, X_transformed)) DCNL DCSP return X_transformed
def __init__(self, estimator): DCNL DCSP self.estimator = estimator
def fit(self, X, y=None, **fit_params): DCNL DCSP self.estimator.fit(X, y, **fit_params) DCNL DCSP return self
def transform(self, X): DCNL DCSP X = check_array(X) DCNL DCSP X_transformed = np.copy(X) DCNL DCSP if (issubclass(self.estimator.__class__, ClassifierMixin) and hasattr(self.estimator, 'predict_proba')): DCNL DCSP  DCSP X_transformed = np.hstack((self.estimator.predict_proba(X), X)) DCNL DCSP X_transformed = np.hstack((np.reshape(self.estimator.predict(X), ((-1), 1)), X_transformed)) DCNL DCSP return X_transformed
def __init__(self, generations=100, population_size=100, offspring_size=None, mutation_rate=0.9, crossover_rate=0.1, scoring=None, cv=5, subsample=1.0, n_jobs=1, max_time_mins=None, max_eval_time_mins=5, random_state=None, config_dict=None, warm_start=False, verbosity=0, disable_update_check=False): DCNL DCSP if (self.__class__.__name__ == 'TPOTBase'): DCNL DCSP  DCSP raise RuntimeError('Do DCSP not DCSP instantiate DCSP the DCSP TPOTBase DCSP class DCSP directly; DCSP use DCSP TPOTRegressor DCSP or DCSP TPOTClassifier DCSP instead.') DCNL DCSP self.disable_update_check = disable_update_check DCNL DCSP if (not self.disable_update_check): DCNL DCSP  DCSP update_check('tpot', __version__) DCNL DCSP self._pareto_front = None DCNL DCSP self._optimized_pipeline = None DCNL DCSP self.fitted_pipeline_ = None DCNL DCSP self._fitted_imputer = None DCNL DCSP self._pop = None DCNL DCSP self.warm_start = warm_start DCNL DCSP self.population_size = population_size DCNL DCSP self.generations = generations DCNL DCSP self.max_time_mins = max_time_mins DCNL DCSP self.max_eval_time_mins = max_eval_time_mins DCNL DCSP if offspring_size: DCNL DCSP  DCSP self.offspring_size = offspring_size DCNL DCSP else: DCNL DCSP  DCSP self.offspring_size = population_size DCNL DCSP self._setup_config(config_dict) DCNL DCSP self.operators = [] DCNL DCSP self.arguments = [] DCNL DCSP for key in sorted(self.config_dict.keys()): DCNL DCSP  DCSP (op_class, arg_types) = TPOTOperatorClassFactory(key, self.config_dict[key], BaseClass=Operator, ArgBaseClass=ARGType) DCNL DCSP  DCSP if op_class: DCNL DCSP  DCSP  DCSP self.operators.append(op_class) DCNL DCSP  DCSP  DCSP self.arguments += arg_types DCNL DCSP if (max_time_mins is not None): DCNL DCSP  DCSP self.generations = 1000000 DCNL DCSP self.mutation_rate = mutation_rate DCNL DCSP self.crossover_rate = crossover_rate DCNL DCSP if ((self.mutation_rate + self.crossover_rate) > 1): DCNL DCSP  DCSP raise ValueError('The DCSP sum DCSP of DCSP the DCSP crossover DCSP and DCSP mutation DCSP probabilities DCSP must DCSP be DCSP <= DCSP 1.0.') DCNL DCSP self.verbosity = verbosity DCNL DCSP self.operators_context = {'make_pipeline': make_pipeline, 'make_union': make_union, 'StackingEstimator': StackingEstimator, 'FunctionTransformer': FunctionTransformer, 'copy': copy} DCNL DCSP self._pbar = None DCNL DCSP self.evaluated_individuals_ = {} DCNL DCSP self.random_state = random_state DCNL DCSP if scoring: DCNL DCSP  DCSP if hasattr(scoring, '__call__'): DCNL DCSP  DCSP  DCSP scoring_name = scoring.__name__ DCNL DCSP  DCSP  DCSP greater_is_better = (('loss' not in scoring_name) and ('error' not in scoring_name)) DCNL DCSP  DCSP  DCSP SCORERS[scoring_name] = make_scorer(scoring, greater_is_better=greater_is_better) DCNL DCSP  DCSP  DCSP self.scoring_function = scoring_name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (scoring not in SCORERS): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('The DCSP scoring DCSP function DCSP {} DCSP is DCSP not DCSP available. DCSP Please DCSP choose DCSP a DCSP valid DCSP scoring DCSP function DCSP from DCSP the DCSP TPOT DCSP documentation.'.format(scoring)) DCNL DCSP  DCSP  DCSP self.scoring_function = scoring DCNL DCSP self.cv = cv DCNL DCSP self.subsample = subsample DCNL DCSP if ((self.subsample <= 0.0) or (self.subsample > 1.0)): DCNL DCSP  DCSP raise ValueError('The DCSP subsample DCSP ratio DCSP of DCSP the DCSP training DCSP instance DCSP must DCSP be DCSP in DCSP the DCSP range DCSP (0.0, DCSP 1.0].') DCNL DCSP if (sys.platform.startswith('win') and (n_jobs != 1)): DCNL DCSP  DCSP print('Warning: DCSP Although DCSP parallelization DCSP is DCSP currently DCSP supported DCSP in DCSP TPOT DCSP for DCSP Windows, DCSP pressing DCSP Ctrl+C DCSP will DCSP freeze DCSP the DCSP optimization DCSP process DCSP without DCSP saving DCSP the DCSP best DCSP pipeline! DCSP Thus, DCSP Please DCSP DO DCSP NOT DCSP press DCSP Ctrl+C DCSP during DCSP the DCSP optimization DCSP procss DCSP if DCSP n_jobs DCSP is DCSP not DCSP equal DCSP to DCSP 1. DCSP For DCSP quick DCSP test DCSP in DCSP Windows, DCSP please DCSP set DCSP n_jobs DCSP to DCSP 1 DCSP for DCSP saving DCSP the DCSP best DCSP pipeline DCSP in DCSP the DCSP middle DCSP of DCSP the DCSP optimization DCSP process DCSP via DCSP Ctrl+C.') DCNL DCSP if (n_jobs == (-1)): DCNL DCSP  DCSP self.n_jobs = cpu_count() DCNL DCSP else: DCNL DCSP  DCSP self.n_jobs = n_jobs DCNL DCSP self._setup_pset() DCNL DCSP self._setup_toolbox()
def fit(self, features, target, sample_weight=None, groups=None): DCNL DCSP features = features.astype(np.float64) DCNL DCSP self._fitted_imputer = None DCNL DCSP if np.any(np.isnan(features)): DCNL DCSP  DCSP features = self._impute_values(features) DCNL DCSP self._check_dataset(features, target) DCNL DCSP if (self.subsample < 1.0): DCNL DCSP  DCSP (features, _, target, _) = train_test_split(features, target, train_size=self.subsample, random_state=self.random_state) DCNL DCSP  DCSP if (features.shape[0] < 1500): DCNL DCSP  DCSP  DCSP print('Warning: DCSP Although DCSP subsample DCSP can DCSP accelerate DCSP pipeline DCSP optimization DCSP process, DCSP too DCSP small DCSP training DCSP sample DCSP size DCSP may DCSP cause DCSP unpredictable DCSP effect DCSP on DCSP maximizing DCSP score DCSP in DCSP pipeline DCSP optimization DCSP process. DCSP Increasing DCSP subsample DCSP ratio DCSP may DCSP get DCSP a DCSP more DCSP reasonable DCSP outcome DCSP from DCSP optimization DCSP process DCSP in DCSP TPOT.') DCNL DCSP if (self.random_state is not None): DCNL DCSP  DCSP random.seed(self.random_state) DCNL DCSP  DCSP np.random.seed(self.random_state) DCNL DCSP self._start_datetime = datetime.now() DCNL DCSP self._toolbox.register('evaluate', self._evaluate_individuals, features=features, target=target, sample_weight=sample_weight, groups=groups) DCNL DCSP if self._pop: DCNL DCSP  DCSP pop = self._pop DCNL DCSP else: DCNL DCSP  DCSP pop = self._toolbox.population(n=self.population_size) DCNL DCSP def pareto_eq(ind1, ind2): DCNL DCSP  DCSP 'Determine DCSP whether DCSP two DCSP individuals DCSP are DCSP equal DCSP on DCSP the DCSP Pareto DCSP front.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parameters\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ----------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ind1: DCSP DEAP DCSP individual DCSP from DCSP the DCSP GP DCSP population\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP First DCSP individual DCSP to DCSP compare\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ind2: DCSP DEAP DCSP individual DCSP from DCSP the DCSP GP DCSP population\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Second DCSP individual DCSP to DCSP compare\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ----------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP individuals_equal: DCSP bool\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Boolean DCSP indicating DCSP whether DCSP the DCSP two DCSP individuals DCSP are DCSP equal DCSP on\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP Pareto DCSP front\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return np.allclose(ind1.fitness.values, ind2.fitness.values) DCNL DCSP if ((not self.warm_start) or (not self._pareto_front)): DCNL DCSP  DCSP self._pareto_front = tools.ParetoFront(similar=pareto_eq) DCNL DCSP if self.max_time_mins: DCNL DCSP  DCSP total_evals = self.population_size DCNL DCSP else: DCNL DCSP  DCSP total_evals = ((self.offspring_size * self.generations) + self.population_size) DCNL DCSP self._pbar = tqdm(total=total_evals, unit='pipeline', leave=False, disable=(not (self.verbosity >= 2)), desc='Optimization DCSP Progress') DCNL DCSP try: DCNL DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP warnings.simplefilter('ignore') DCNL DCSP  DCSP  DCSP (pop, _) = eaMuPlusLambda(population=pop, toolbox=self._toolbox, mu=self.population_size, lambda_=self.offspring_size, cxpb=self.crossover_rate, mutpb=self.mutation_rate, ngen=self.generations, pbar=self._pbar, halloffame=self._pareto_front, verbose=self.verbosity, max_time_mins=self.max_time_mins) DCNL DCSP  DCSP if self.warm_start: DCNL DCSP  DCSP  DCSP self._pop = pop DCNL DCSP except (KeyboardInterrupt, SystemExit): DCNL DCSP  DCSP if (self.verbosity > 0): DCNL DCSP  DCSP  DCSP self._pbar.write('') DCNL DCSP  DCSP  DCSP self._pbar.write('TPOT DCSP closed DCSP prematurely. DCSP Will DCSP use DCSP the DCSP current DCSP best DCSP pipeline.') DCNL DCSP finally: DCNL DCSP  DCSP attempts = 10 DCNL DCSP  DCSP for attempt in range(attempts): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(self._pbar, type(None))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._pbar.close() DCNL DCSP  DCSP  DCSP  DCSP if self._pareto_front: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._update_top_pipeline() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not self._optimized_pipeline): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print('There DCSP was DCSP an DCSP error DCSP in DCSP the DCSP TPOT DCSP optimization DCSP process. DCSP This DCSP could DCSP be DCSP because DCSP the DCSP data DCSP was DCSP not DCSP formatted DCSP properly, DCSP or DCSP because DCSP data DCSP for DCSP a DCSP regression DCSP problem DCSP was DCSP provided DCSP to DCSP the DCSP TPOTClassifier DCSP object. DCSP Please DCSP make DCSP sure DCSP you DCSP passed DCSP the DCSP data DCSP to DCSP TPOT DCSP correctly.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.fitted_pipeline_ = self._toolbox.compile(expr=self._optimized_pipeline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnings.simplefilter('ignore') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.fitted_pipeline_.fit(features, target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (self.verbosity in [1, 2]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print('') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print('Best DCSP pipeline: DCSP {}'.format(self._optimized_pipeline)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.pareto_front_fitted_pipelines_ = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for pipeline in self._pareto_front.items: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.pareto_front_fitted_pipelines_[str(pipeline)] = self._toolbox.compile(expr=pipeline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnings.simplefilter('ignore') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.pareto_front_fitted_pipelines_[str(pipeline)].fit(features, target) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except (KeyboardInterrupt, SystemExit, Exception) as e: DCNL DCSP  DCSP  DCSP  DCSP if (attempt == (attempts - 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP return self
def _update_top_pipeline(self): DCNL DCSP if self._pareto_front: DCNL DCSP  DCSP top_score = (- float('inf')) DCNL DCSP  DCSP for (pipeline, pipeline_scores) in zip(self._pareto_front.items, reversed(self._pareto_front.keys)): DCNL DCSP  DCSP  DCSP if (pipeline_scores.wvalues[1] > top_score): DCNL DCSP  DCSP  DCSP  DCSP self._optimized_pipeline = pipeline DCNL DCSP  DCSP  DCSP  DCSP top_score = pipeline_scores.wvalues[1]
def predict(self, features): DCNL DCSP if (not self.fitted_pipeline_): DCNL DCSP  DCSP raise RuntimeError('A DCSP pipeline DCSP has DCSP not DCSP yet DCSP been DCSP optimized. DCSP Please DCSP call DCSP fit() DCSP first.') DCNL DCSP features = features.astype(np.float64) DCNL DCSP if np.any(np.isnan(features)): DCNL DCSP  DCSP features = self._impute_values(features) DCNL DCSP return self.fitted_pipeline_.predict(features)
def fit_predict(self, features, target): DCNL DCSP self.fit(features, target) DCNL DCSP return self.predict(features)
def score(self, testing_features, testing_target): DCNL DCSP if (self.fitted_pipeline_ is None): DCNL DCSP  DCSP raise RuntimeError('A DCSP pipeline DCSP has DCSP not DCSP yet DCSP been DCSP optimized. DCSP Please DCSP call DCSP fit() DCSP first.') DCNL DCSP score = SCORERS[self.scoring_function](self.fitted_pipeline_, testing_features.astype(np.float64), testing_target.astype(np.float64)) DCNL DCSP return abs(score)
def predict_proba(self, features): DCNL DCSP if (not self.fitted_pipeline_): DCNL DCSP  DCSP raise RuntimeError('A DCSP pipeline DCSP has DCSP not DCSP yet DCSP been DCSP optimized. DCSP Please DCSP call DCSP fit() DCSP first.') DCNL DCSP else: DCNL DCSP  DCSP if (not hasattr(self.fitted_pipeline_, 'predict_proba')): DCNL DCSP  DCSP  DCSP raise RuntimeError('The DCSP fitted DCSP pipeline DCSP does DCSP not DCSP have DCSP the DCSP predict_proba() DCSP function.') DCNL DCSP  DCSP return self.fitted_pipeline_.predict_proba(features.astype(np.float64))
def set_params(self, **params): DCNL DCSP self.__init__(**params) DCNL DCSP return self
def export(self, output_file_name): DCNL DCSP if (self._optimized_pipeline is None): DCNL DCSP  DCSP raise RuntimeError('A DCSP pipeline DCSP has DCSP not DCSP yet DCSP been DCSP optimized. DCSP Please DCSP call DCSP fit() DCSP first.') DCNL DCSP with open(output_file_name, 'w') as output_file: DCNL DCSP  DCSP output_file.write(export_pipeline(self._optimized_pipeline, self.operators, self._pset))
def _impute_values(self, features): DCNL DCSP if (self.verbosity > 1): DCNL DCSP  DCSP print('Imputing DCSP missing DCSP values DCSP in DCSP feature DCSP set') DCNL DCSP if (self._fitted_imputer is None): DCNL DCSP  DCSP self._fitted_imputer = Imputer(strategy='median', axis=1) DCNL DCSP  DCSP self._fitted_imputer.fit(features) DCNL DCSP return self._fitted_imputer.transform(features)
def _check_dataset(self, features, target): DCNL DCSP try: DCNL DCSP  DCSP check_X_y(features, target, accept_sparse=False) DCNL DCSP except (AssertionError, ValueError): DCNL DCSP  DCSP raise ValueError('Error: DCSP Input DCSP data DCSP is DCSP not DCSP in DCSP a DCSP valid DCSP format. DCSP Please DCSP confirm DCSP that DCSP the DCSP input DCSP data DCSP is DCSP scikit-learn DCSP compatible. DCSP For DCSP example, DCSP the DCSP features DCSP must DCSP be DCSP a DCSP 2-D DCSP array DCSP and DCSP target DCSP labels DCSP must DCSP be DCSP a DCSP 1-D DCSP array.')
def _compile_to_sklearn(self, expr): DCNL DCSP sklearn_pipeline = generate_pipeline_code(expr_to_tree(expr, self._pset), self.operators) DCNL DCSP return eval(sklearn_pipeline, self.operators_context)
def _set_param_recursive(self, pipeline_steps, parameter, value): DCNL DCSP for (_, obj) in pipeline_steps: DCNL DCSP  DCSP recursive_attrs = ['steps', 'transformer_list', 'estimators'] DCNL DCSP  DCSP for attr in recursive_attrs: DCNL DCSP  DCSP  DCSP if hasattr(obj, attr): DCNL DCSP  DCSP  DCSP  DCSP self._set_param_recursive(getattr(obj, attr), parameter, value) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if hasattr(obj, parameter): DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, parameter, value)
def _evaluate_individuals(self, individuals, features, target, sample_weight=None, groups=None): DCNL DCSP if self.max_time_mins: DCNL DCSP  DCSP total_mins_elapsed = ((datetime.now() - self._start_datetime).total_seconds() / 60.0) DCNL DCSP  DCSP if (total_mins_elapsed >= self.max_time_mins): DCNL DCSP  DCSP  DCSP raise KeyboardInterrupt('{} DCSP minutes DCSP have DCSP elapsed. DCSP TPOT DCSP will DCSP close DCSP down.'.format(total_mins_elapsed)) DCNL DCSP (_, unique_individual_indices) = np.unique([str(ind) for ind in individuals], return_index=True) DCNL DCSP unique_individuals = [ind for (i, ind) in enumerate(individuals) if (i in unique_individual_indices)] DCNL DCSP operator_counts = {} DCNL DCSP eval_individuals_str = [] DCNL DCSP sklearn_pipeline_list = [] DCNL DCSP for individual in unique_individuals: DCNL DCSP  DCSP individual_str = str(individual) DCNL DCSP  DCSP sklearn_pipeline_str = generate_pipeline_code(expr_to_tree(individual, self._pset), self.operators) DCNL DCSP  DCSP if (sklearn_pipeline_str.count('PolynomialFeatures') > 1): DCNL DCSP  DCSP  DCSP if (self.verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP self._pbar.write('Invalid DCSP pipeline DCSP encountered. DCSP Skipping DCSP its DCSP evaluation.') DCNL DCSP  DCSP  DCSP self.evaluated_individuals_[individual_str] = (5000.0, (- float('inf'))) DCNL DCSP  DCSP  DCSP if (not self._pbar.disable): DCNL DCSP  DCSP  DCSP  DCSP self._pbar.update(1) DCNL DCSP  DCSP elif (individual_str in self.evaluated_individuals_): DCNL DCSP  DCSP  DCSP if (self.verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP self._pbar.write('Pipeline DCSP encountered DCSP that DCSP has DCSP previously DCSP been DCSP evaluated DCSP during DCSP the DCSP optimization DCSP process. DCSP Using DCSP the DCSP score DCSP from DCSP the DCSP previous DCSP evaluation.') DCNL DCSP  DCSP  DCSP if (not self._pbar.disable): DCNL DCSP  DCSP  DCSP  DCSP self._pbar.update(1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP sklearn_pipeline = self._toolbox.compile(expr=individual) DCNL DCSP  DCSP  DCSP  DCSP self._set_param_recursive(sklearn_pipeline.steps, 'random_state', 42) DCNL DCSP  DCSP  DCSP  DCSP if ('XGB' in sklearn_pipeline_str): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._set_param_recursive(sklearn_pipeline.steps, 'seed', 42) DCNL DCSP  DCSP  DCSP  DCSP operator_count = self._operator_count(individual) DCNL DCSP  DCSP  DCSP  DCSP operator_counts[individual_str] = max(1, operator_count) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP self.evaluated_individuals_[individual_str] = (5000.0, (- float('inf'))) DCNL DCSP  DCSP  DCSP  DCSP if (not self._pbar.disable): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._pbar.update(1) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP eval_individuals_str.append(individual_str) DCNL DCSP  DCSP  DCSP sklearn_pipeline_list.append(sklearn_pipeline) DCNL DCSP resulting_score_list = [] DCNL DCSP for chunk_idx in range(0, len(sklearn_pipeline_list), (self.n_jobs * 4)): DCNL DCSP  DCSP jobs = [] DCNL DCSP  DCSP for sklearn_pipeline in sklearn_pipeline_list[chunk_idx:(chunk_idx + (self.n_jobs * 4))]: DCNL DCSP  DCSP  DCSP job = delayed(_wrapped_cross_val_score)(sklearn_pipeline=sklearn_pipeline, features=features, target=target, cv=self.cv, scoring_function=self.scoring_function, sample_weight=sample_weight, max_eval_time_mins=self.max_eval_time_mins, groups=groups) DCNL DCSP  DCSP  DCSP jobs.append(job) DCNL DCSP  DCSP parallel = Parallel(n_jobs=self.n_jobs, verbose=0, pre_dispatch='2*n_jobs') DCNL DCSP  DCSP tmp_result_score = parallel(jobs) DCNL DCSP  DCSP for val in tmp_result_score: DCNL DCSP  DCSP  DCSP if (not self._pbar.disable): DCNL DCSP  DCSP  DCSP  DCSP self._pbar.update(1) DCNL DCSP  DCSP  DCSP if (val == 'Timeout'): DCNL DCSP  DCSP  DCSP  DCSP if (self.verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._pbar.write('Skipped DCSP pipeline DCSP #{0} DCSP due DCSP to DCSP time DCSP out. DCSP Continuing DCSP to DCSP the DCSP next DCSP pipeline.'.format(self._pbar.n)) DCNL DCSP  DCSP  DCSP  DCSP resulting_score_list.append((- float('inf'))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP resulting_score_list.append(val) DCNL DCSP for (resulting_score, individual_str) in zip(resulting_score_list, eval_individuals_str): DCNL DCSP  DCSP if (type(resulting_score) in [float, np.float64, np.float32]): DCNL DCSP  DCSP  DCSP self.evaluated_individuals_[individual_str] = (operator_counts[individual_str], resulting_score) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('Scoring DCSP function DCSP does DCSP not DCSP return DCSP a DCSP float.') DCNL DCSP return [self.evaluated_individuals_[str(individual)] for individual in individuals]
@_pre_test DCNL def _random_mutation_operator(self, individual): DCNL DCSP mutation_techniques = [partial(gp.mutInsert, pset=self._pset), partial(mutNodeReplacement, pset=self._pset), partial(gp.mutShrink)] DCNL DCSP return np.random.choice(mutation_techniques)(individual)
def _gen_grow_safe(self, pset, min_, max_, type_=None): DCNL DCSP def condition(height, depth, type_): DCNL DCSP  DCSP 'Stop DCSP when DCSP the DCSP depth DCSP is DCSP equal DCSP to DCSP height DCSP or DCSP when DCSP a DCSP node DCSP should DCSP be DCSP a DCSP terminal.' DCNL DCSP  DCSP return ((type_ not in [np.ndarray, Output_Array]) or (depth == height)) DCNL DCSP return self._generate(pset, min_, max_, condition, type_)
@_pre_test DCNL def _generate(self, pset, min_, max_, condition, type_=None): DCNL DCSP if (type_ is None): DCNL DCSP  DCSP type_ = pset.ret DCNL DCSP expr = [] DCNL DCSP height = np.random.randint(min_, max_) DCNL DCSP stack = [(0, type_)] DCNL DCSP while (len(stack) != 0): DCNL DCSP  DCSP (depth, type_) = stack.pop() DCNL DCSP  DCSP if condition(height, depth, type_): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP term = np.random.choice(pset.terminals[type_]) DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP (_, _, traceback) = sys.exc_info() DCNL DCSP  DCSP  DCSP  DCSP raise IndexError('The DCSP gp.generate DCSP function DCSP tried DCSP to DCSP add DCSP a DCSP terminal DCSP of DCSP type DCSP {}, DCSP but DCSP there DCSP isnone DCSP available. DCSP {}'.format(type_, traceback)) DCNL DCSP  DCSP  DCSP if inspect.isclass(term): DCNL DCSP  DCSP  DCSP  DCSP term = term() DCNL DCSP  DCSP  DCSP expr.append(term) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP prim = np.random.choice(pset.primitives[type_]) DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP (_, _, traceback) = sys.exc_info() DCNL DCSP  DCSP  DCSP  DCSP raise IndexError('The DCSP gp.generate DCSP function DCSP tried DCSP to DCSP add DCSP a DCSP primitive DCSP of DCSP type DCSP {}, DCSP but DCSP there DCSP isnone DCSP available. DCSP {}'.format(type_, traceback)) DCNL DCSP  DCSP  DCSP expr.append(prim) DCNL DCSP  DCSP  DCSP for arg in reversed(prim.args): DCNL DCSP  DCSP  DCSP  DCSP stack.append(((depth + 1), arg)) DCNL DCSP return expr
def add_rule(self, rule): DCNL DCSP self.append(rule) DCNL DCSP return self
def to_xml(self): DCNL DCSP s = '' DCNL DCSP for transition in self: DCNL DCSP  DCSP s += transition.to_xml() DCNL DCSP return s
def add_transition(self, days=None, date=None, storage_class=None): DCNL DCSP transition = Transition(days, date, storage_class) DCNL DCSP self.append(transition)
def to_xml(self): DCNL DCSP s = '<?xml DCSP version="1.0" DCSP encoding="UTF-8"?>' DCNL DCSP s += '<LifecycleConfiguration>' DCNL DCSP for rule in self: DCNL DCSP  DCSP s += rule.to_xml() DCNL DCSP s += '</LifecycleConfiguration>' DCNL DCSP return s
def add_rule(self, id=None, prefix='', status='Enabled', expiration=None, transition=None): DCNL DCSP rule = Rule(id, prefix, status, expiration, transition) DCNL DCSP self.append(rule)
def connect(self, **kw_params): DCNL DCSP if self.connection_cls: DCNL DCSP  DCSP return self.connection_cls(host=self.endpoint, **kw_params)
def set_key_class(self, key_class): DCNL DCSP self.key_class = key_class
def lookup(self, key_name, headers=None): DCNL DCSP return self.get_key(key_name, headers=headers)
def get_key(self, key_name, headers=None, version_id=None, response_headers=None, validate=True): DCNL DCSP if (validate is False): DCNL DCSP  DCSP if (headers or version_id or response_headers): DCNL DCSP  DCSP  DCSP raise BotoClientError(("When DCSP providing DCSP 'validate=False', DCSP no DCSP other DCSP params DCSP " + 'are DCSP allowed.')) DCNL DCSP  DCSP return self.new_key(key_name) DCNL DCSP query_args_l = [] DCNL DCSP if version_id: DCNL DCSP  DCSP query_args_l.append(('versionId=%s' % version_id)) DCNL DCSP if response_headers: DCNL DCSP  DCSP for (rk, rv) in six.iteritems(response_headers): DCNL DCSP  DCSP  DCSP query_args_l.append(('%s=%s' % (rk, urllib.parse.quote(rv)))) DCNL DCSP (key, resp) = self._get_key_internal(key_name, headers, query_args_l) DCNL DCSP return key
def list(self, prefix='', delimiter='', marker='', headers=None, encoding_type=None): DCNL DCSP return BucketListResultSet(self, prefix, delimiter, marker, headers, encoding_type=encoding_type)
def list_versions(self, prefix='', delimiter='', key_marker='', version_id_marker='', headers=None, encoding_type=None): DCNL DCSP return VersionedBucketListResultSet(self, prefix, delimiter, key_marker, version_id_marker, headers, encoding_type=encoding_type)
def list_multipart_uploads(self, key_marker='', upload_id_marker='', headers=None, encoding_type=None): DCNL DCSP return MultiPartUploadListResultSet(self, key_marker, upload_id_marker, headers, encoding_type=encoding_type)
def validate_kwarg_names(self, kwargs, names): DCNL DCSP for kwarg in kwargs: DCNL DCSP  DCSP if (kwarg not in names): DCNL DCSP  DCSP  DCSP raise TypeError(('Invalid DCSP argument DCSP "%s"!' % kwarg))
def get_all_keys(self, headers=None, **params): DCNL DCSP self.validate_kwarg_names(params, ['maxkeys', 'max_keys', 'prefix', 'marker', 'delimiter', 'encoding_type']) DCNL DCSP return self._get_all([('Contents', self.key_class), ('CommonPrefixes', Prefix)], '', headers, **params)
def get_all_versions(self, headers=None, **params): DCNL DCSP self.validate_get_all_versions_params(params) DCNL DCSP return self._get_all([('Version', self.key_class), ('CommonPrefixes', Prefix), ('DeleteMarker', DeleteMarker)], 'versions', headers, **params)
def validate_get_all_versions_params(self, params): DCNL DCSP self.validate_kwarg_names(params, ['maxkeys', 'max_keys', 'prefix', 'key_marker', 'version_id_marker', 'delimiter', 'encoding_type'])
def get_all_multipart_uploads(self, headers=None, **params): DCNL DCSP self.validate_kwarg_names(params, ['max_uploads', 'key_marker', 'upload_id_marker', 'encoding_type', 'delimiter', 'prefix']) DCNL DCSP return self._get_all([('Upload', MultiPartUpload), ('CommonPrefixes', Prefix)], 'uploads', headers, **params)
def new_key(self, key_name=None): DCNL DCSP if (not key_name): DCNL DCSP  DCSP raise ValueError('Empty DCSP key DCSP names DCSP are DCSP not DCSP allowed') DCNL DCSP return self.key_class(self, key_name)
def delete_keys(self, keys, quiet=False, mfa_token=None, headers=None): DCNL DCSP ikeys = iter(keys) DCNL DCSP result = MultiDeleteResult(self) DCNL DCSP provider = self.connection.provider DCNL DCSP query_args = 'delete' DCNL DCSP def delete_keys2(hdrs): DCNL DCSP  DCSP hdrs = (hdrs or {}) DCNL DCSP  DCSP data = u'<?xml DCSP version="1.0" DCSP encoding="UTF-8"?>' DCNL DCSP  DCSP data += u'<Delete>' DCNL DCSP  DCSP if quiet: DCNL DCSP  DCSP  DCSP data += u'<Quiet>true</Quiet>' DCNL DCSP  DCSP count = 0 DCNL DCSP  DCSP while (count < 1000): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP key = next(ikeys) DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if isinstance(key, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP key_name = key DCNL DCSP  DCSP  DCSP  DCSP version_id = None DCNL DCSP  DCSP  DCSP elif (isinstance(key, tuple) and (len(key) == 2)): DCNL DCSP  DCSP  DCSP  DCSP (key_name, version_id) = key DCNL DCSP  DCSP  DCSP elif ((isinstance(key, Key) or isinstance(key, DeleteMarker)) and key.name): DCNL DCSP  DCSP  DCSP  DCSP key_name = key.name DCNL DCSP  DCSP  DCSP  DCSP version_id = key.version_id DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(key, Prefix): DCNL DCSP  DCSP  DCSP  DCSP  DCSP key_name = key.name DCNL DCSP  DCSP  DCSP  DCSP  DCSP code = 'PrefixSkipped' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP key_name = repr(key) DCNL DCSP  DCSP  DCSP  DCSP  DCSP code = 'InvalidArgument' DCNL DCSP  DCSP  DCSP  DCSP message = 'Invalid. DCSP No DCSP delete DCSP action DCSP taken DCSP for DCSP this DCSP object.' DCNL DCSP  DCSP  DCSP  DCSP error = Error(key_name, code=code, message=message) DCNL DCSP  DCSP  DCSP  DCSP result.errors.append(error) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP  DCSP data += (u'<Object><Key>%s</Key>' % xml.sax.saxutils.escape(key_name)) DCNL DCSP  DCSP  DCSP if version_id: DCNL DCSP  DCSP  DCSP  DCSP data += (u'<VersionId>%s</VersionId>' % version_id) DCNL DCSP  DCSP  DCSP data += u'</Object>' DCNL DCSP  DCSP data += u'</Delete>' DCNL DCSP  DCSP if (count <= 0): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP data = data.encode('utf-8') DCNL DCSP  DCSP fp = BytesIO(data) DCNL DCSP  DCSP md5 = boto.utils.compute_md5(fp) DCNL DCSP  DCSP hdrs['Content-MD5'] = md5[1] DCNL DCSP  DCSP hdrs['Content-Type'] = 'text/xml' DCNL DCSP  DCSP if mfa_token: DCNL DCSP  DCSP  DCSP hdrs[provider.mfa_header] = ' DCSP '.join(mfa_token) DCNL DCSP  DCSP response = self.connection.make_request('POST', self.name, headers=hdrs, query_args=query_args, data=data) DCNL DCSP  DCSP body = response.read() DCNL DCSP  DCSP if (response.status == 200): DCNL DCSP  DCSP  DCSP h = handler.XmlHandler(result, self) DCNL DCSP  DCSP  DCSP if (not isinstance(body, bytes)): DCNL DCSP  DCSP  DCSP  DCSP body = body.encode('utf-8') DCNL DCSP  DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP  DCSP return (count >= 1000) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise provider.storage_response_error(response.status, response.reason, body) DCNL DCSP while delete_keys2(headers): DCNL DCSP  DCSP pass DCNL DCSP return result
def delete_key(self, key_name, headers=None, version_id=None, mfa_token=None): DCNL DCSP if (not key_name): DCNL DCSP  DCSP raise ValueError('Empty DCSP key DCSP names DCSP are DCSP not DCSP allowed') DCNL DCSP return self._delete_key_internal(key_name, headers=headers, version_id=version_id, mfa_token=mfa_token, query_args_l=None)
def copy_key(self, new_key_name, src_bucket_name, src_key_name, metadata=None, src_version_id=None, storage_class='STANDARD', preserve_acl=False, encrypt_key=False, headers=None, query_args=None): DCNL DCSP headers = (headers or {}) DCNL DCSP provider = self.connection.provider DCNL DCSP src_key_name = boto.utils.get_utf8_value(src_key_name) DCNL DCSP if preserve_acl: DCNL DCSP  DCSP if (self.name == src_bucket_name): DCNL DCSP  DCSP  DCSP src_bucket = self DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP src_bucket = self.connection.get_bucket(src_bucket_name, validate=False) DCNL DCSP  DCSP acl = src_bucket.get_xml_acl(src_key_name) DCNL DCSP if encrypt_key: DCNL DCSP  DCSP headers[provider.server_side_encryption_header] = 'AES256' DCNL DCSP src = ('%s/%s' % (src_bucket_name, urllib.parse.quote(src_key_name))) DCNL DCSP if src_version_id: DCNL DCSP  DCSP src += ('?versionId=%s' % src_version_id) DCNL DCSP headers[provider.copy_source_header] = str(src) DCNL DCSP if (provider.storage_class_header and storage_class): DCNL DCSP  DCSP headers[provider.storage_class_header] = storage_class DCNL DCSP if (metadata is not None): DCNL DCSP  DCSP headers[provider.metadata_directive_header] = 'REPLACE' DCNL DCSP  DCSP headers = boto.utils.merge_meta(headers, metadata, provider) DCNL DCSP elif (not query_args): DCNL DCSP  DCSP headers[provider.metadata_directive_header] = 'COPY' DCNL DCSP response = self.connection.make_request('PUT', self.name, new_key_name, headers=headers, query_args=query_args) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP key = self.new_key(new_key_name) DCNL DCSP  DCSP h = handler.XmlHandler(key, self) DCNL DCSP  DCSP if (not isinstance(body, bytes)): DCNL DCSP  DCSP  DCSP body = body.encode('utf-8') DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP if hasattr(key, 'Error'): DCNL DCSP  DCSP  DCSP raise provider.storage_copy_error(key.Code, key.Message, body) DCNL DCSP  DCSP key.handle_version_headers(response) DCNL DCSP  DCSP key.handle_addl_headers(response.getheaders()) DCNL DCSP  DCSP if preserve_acl: DCNL DCSP  DCSP  DCSP self.set_xml_acl(acl, new_key_name) DCNL DCSP  DCSP return key DCNL DCSP else: DCNL DCSP  DCSP raise provider.storage_response_error(response.status, response.reason, body)
def set_subresource(self, subresource, value, key_name='', headers=None, version_id=None): DCNL DCSP if (not subresource): DCNL DCSP  DCSP raise TypeError('set_subresource DCSP called DCSP with DCSP subresource=None') DCNL DCSP query_args = subresource DCNL DCSP if version_id: DCNL DCSP  DCSP query_args += ('&versionId=%s' % version_id) DCNL DCSP if (not isinstance(value, bytes)): DCNL DCSP  DCSP value = value.encode('utf-8') DCNL DCSP response = self.connection.make_request('PUT', self.name, key_name, data=value, query_args=query_args, headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def get_subresource(self, subresource, key_name='', headers=None, version_id=None): DCNL DCSP if (not subresource): DCNL DCSP  DCSP raise TypeError('get_subresource DCSP called DCSP with DCSP subresource=None') DCNL DCSP query_args = subresource DCNL DCSP if version_id: DCNL DCSP  DCSP query_args += ('&versionId=%s' % version_id) DCNL DCSP response = self.connection.make_request('GET', self.name, key_name, query_args=query_args, headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body) DCNL DCSP return body
def add_email_grant(self, permission, email_address, recursive=False, headers=None): DCNL DCSP if (permission not in S3Permissions): DCNL DCSP  DCSP raise self.connection.provider.storage_permissions_error(('Unknown DCSP Permission: DCSP %s' % permission)) DCNL DCSP policy = self.get_acl(headers=headers) DCNL DCSP policy.acl.add_email_grant(permission, email_address) DCNL DCSP self.set_acl(policy, headers=headers) DCNL DCSP if recursive: DCNL DCSP  DCSP for key in self: DCNL DCSP  DCSP  DCSP key.add_email_grant(permission, email_address, headers=headers)
def add_user_grant(self, permission, user_id, recursive=False, headers=None, display_name=None): DCNL DCSP if (permission not in S3Permissions): DCNL DCSP  DCSP raise self.connection.provider.storage_permissions_error(('Unknown DCSP Permission: DCSP %s' % permission)) DCNL DCSP policy = self.get_acl(headers=headers) DCNL DCSP policy.acl.add_user_grant(permission, user_id, display_name=display_name) DCNL DCSP self.set_acl(policy, headers=headers) DCNL DCSP if recursive: DCNL DCSP  DCSP for key in self: DCNL DCSP  DCSP  DCSP key.add_user_grant(permission, user_id, headers=headers, display_name=display_name)
def get_location(self): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='location') DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP rs = ResultSet(self) DCNL DCSP  DCSP h = handler.XmlHandler(rs, self) DCNL DCSP  DCSP if (not isinstance(body, bytes)): DCNL DCSP  DCSP  DCSP body = body.encode('utf-8') DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return rs.LocationConstraint DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def set_xml_logging(self, logging_str, headers=None): DCNL DCSP body = logging_str DCNL DCSP if (not isinstance(body, bytes)): DCNL DCSP  DCSP body = body.encode('utf-8') DCNL DCSP response = self.connection.make_request('PUT', self.name, data=body, query_args='logging', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def enable_logging(self, target_bucket, target_prefix='', grants=None, headers=None): DCNL DCSP if isinstance(target_bucket, Bucket): DCNL DCSP  DCSP target_bucket = target_bucket.name DCNL DCSP blogging = BucketLogging(target=target_bucket, prefix=target_prefix, grants=grants) DCNL DCSP return self.set_xml_logging(blogging.to_xml(), headers=headers)
def disable_logging(self, headers=None): DCNL DCSP blogging = BucketLogging() DCNL DCSP return self.set_xml_logging(blogging.to_xml(), headers=headers)
def get_logging_status(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='logging', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP blogging = BucketLogging() DCNL DCSP  DCSP h = handler.XmlHandler(blogging, self) DCNL DCSP  DCSP if (not isinstance(body, bytes)): DCNL DCSP  DCSP  DCSP body = body.encode('utf-8') DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return blogging DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def set_as_logging_target(self, headers=None): DCNL DCSP policy = self.get_acl(headers=headers) DCNL DCSP g1 = Grant(permission='WRITE', type='Group', uri=self.LoggingGroup) DCNL DCSP g2 = Grant(permission='READ_ACP', type='Group', uri=self.LoggingGroup) DCNL DCSP policy.acl.add_grant(g1) DCNL DCSP policy.acl.add_grant(g2) DCNL DCSP self.set_acl(policy, headers=headers)
def configure_versioning(self, versioning, mfa_delete=False, mfa_token=None, headers=None): DCNL DCSP if versioning: DCNL DCSP  DCSP ver = 'Enabled' DCNL DCSP else: DCNL DCSP  DCSP ver = 'Suspended' DCNL DCSP if mfa_delete: DCNL DCSP  DCSP mfa = 'Enabled' DCNL DCSP else: DCNL DCSP  DCSP mfa = 'Disabled' DCNL DCSP body = (self.VersioningBody % (ver, mfa)) DCNL DCSP if mfa_token: DCNL DCSP  DCSP if (not headers): DCNL DCSP  DCSP  DCSP headers = {} DCNL DCSP  DCSP provider = self.connection.provider DCNL DCSP  DCSP headers[provider.mfa_header] = ' DCSP '.join(mfa_token) DCNL DCSP response = self.connection.make_request('PUT', self.name, data=body, query_args='versioning', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def get_versioning_status(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='versioning', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (not isinstance(body, six.string_types)): DCNL DCSP  DCSP body = body.decode('utf-8') DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP d = {} DCNL DCSP  DCSP ver = re.search(self.VersionRE, body) DCNL DCSP  DCSP if ver: DCNL DCSP  DCSP  DCSP d['Versioning'] = ver.group(1) DCNL DCSP  DCSP mfa = re.search(self.MFADeleteRE, body) DCNL DCSP  DCSP if mfa: DCNL DCSP  DCSP  DCSP d['MfaDelete'] = mfa.group(1) DCNL DCSP  DCSP return d DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def configure_lifecycle(self, lifecycle_config, headers=None): DCNL DCSP xml = lifecycle_config.to_xml() DCNL DCSP fp = StringIO(xml) DCNL DCSP md5 = boto.utils.compute_md5(fp) DCNL DCSP if (headers is None): DCNL DCSP  DCSP headers = {} DCNL DCSP headers['Content-MD5'] = md5[1] DCNL DCSP headers['Content-Type'] = 'text/xml' DCNL DCSP response = self.connection.make_request('PUT', self.name, data=fp.getvalue(), query_args='lifecycle', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def get_lifecycle_config(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='lifecycle', headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP lifecycle = Lifecycle() DCNL DCSP  DCSP h = handler.XmlHandler(lifecycle, self) DCNL DCSP  DCSP if (not isinstance(body, bytes)): DCNL DCSP  DCSP  DCSP body = body.encode('utf-8') DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return lifecycle DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def delete_lifecycle_configuration(self, headers=None): DCNL DCSP response = self.connection.make_request('DELETE', self.name, query_args='lifecycle', headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 204): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def configure_website(self, suffix=None, error_key=None, redirect_all_requests_to=None, routing_rules=None, headers=None): DCNL DCSP config = website.WebsiteConfiguration(suffix, error_key, redirect_all_requests_to, routing_rules) DCNL DCSP return self.set_website_configuration(config, headers=headers)
def set_website_configuration(self, config, headers=None): DCNL DCSP return self.set_website_configuration_xml(config.to_xml(), headers=headers)
def set_website_configuration_xml(self, xml, headers=None): DCNL DCSP response = self.connection.make_request('PUT', self.name, data=xml, query_args='website', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def get_website_configuration(self, headers=None): DCNL DCSP return self.get_website_configuration_with_xml(headers)[0]
def get_website_configuration_obj(self, headers=None): DCNL DCSP config_xml = self.get_website_configuration_xml(headers=headers) DCNL DCSP config = website.WebsiteConfiguration() DCNL DCSP h = handler.XmlHandler(config, self) DCNL DCSP xml.sax.parseString(config_xml, h) DCNL DCSP return config
def get_website_configuration_with_xml(self, headers=None): DCNL DCSP body = self.get_website_configuration_xml(headers=headers) DCNL DCSP e = boto.jsonresponse.Element() DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return (e, body)
def get_website_configuration_xml(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='website', headers=headers) DCNL DCSP body = response.read().decode('utf-8') DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body) DCNL DCSP return body
def delete_website_configuration(self, headers=None): DCNL DCSP response = self.connection.make_request('DELETE', self.name, query_args='website', headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 204): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def get_website_endpoint(self): DCNL DCSP l = [self.name] DCNL DCSP l.append(S3WebsiteEndpointTranslate.translate_region(self.get_location())) DCNL DCSP l.append('.'.join(self.connection.host.split('.')[(-2):])) DCNL DCSP return '.'.join(l)
def get_policy(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='policy', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return body DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def set_policy(self, policy, headers=None): DCNL DCSP response = self.connection.make_request('PUT', self.name, data=policy, query_args='policy', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if ((response.status >= 200) and (response.status <= 204)): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def set_cors_xml(self, cors_xml, headers=None): DCNL DCSP fp = StringIO(cors_xml) DCNL DCSP md5 = boto.utils.compute_md5(fp) DCNL DCSP if (headers is None): DCNL DCSP  DCSP headers = {} DCNL DCSP headers['Content-MD5'] = md5[1] DCNL DCSP headers['Content-Type'] = 'text/xml' DCNL DCSP response = self.connection.make_request('PUT', self.name, data=fp.getvalue(), query_args='cors', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def set_cors(self, cors_config, headers=None): DCNL DCSP return self.set_cors_xml(cors_config.to_xml())
def get_cors_xml(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='cors', headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return body DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def get_cors(self, headers=None): DCNL DCSP body = self.get_cors_xml(headers) DCNL DCSP cors = CORSConfiguration() DCNL DCSP h = handler.XmlHandler(cors, self) DCNL DCSP xml.sax.parseString(body, h) DCNL DCSP return cors
def delete_cors(self, headers=None): DCNL DCSP response = self.connection.make_request('DELETE', self.name, query_args='cors', headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 204): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def initiate_multipart_upload(self, key_name, headers=None, reduced_redundancy=False, metadata=None, encrypt_key=False, policy=None): DCNL DCSP query_args = 'uploads' DCNL DCSP provider = self.connection.provider DCNL DCSP headers = (headers or {}) DCNL DCSP if policy: DCNL DCSP  DCSP headers[provider.acl_header] = policy DCNL DCSP if reduced_redundancy: DCNL DCSP  DCSP storage_class_header = provider.storage_class_header DCNL DCSP  DCSP if storage_class_header: DCNL DCSP  DCSP  DCSP headers[storage_class_header] = 'REDUCED_REDUNDANCY' DCNL DCSP if encrypt_key: DCNL DCSP  DCSP headers[provider.server_side_encryption_header] = 'AES256' DCNL DCSP if (metadata is None): DCNL DCSP  DCSP metadata = {} DCNL DCSP headers = boto.utils.merge_meta(headers, metadata, self.connection.provider) DCNL DCSP response = self.connection.make_request('POST', self.name, key_name, query_args=query_args, headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP resp = MultiPartUpload(self) DCNL DCSP  DCSP h = handler.XmlHandler(resp, self) DCNL DCSP  DCSP if (not isinstance(body, bytes)): DCNL DCSP  DCSP  DCSP body = body.encode('utf-8') DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return resp DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def complete_multipart_upload(self, key_name, upload_id, xml_body, headers=None): DCNL DCSP query_args = ('uploadId=%s' % upload_id) DCNL DCSP if (headers is None): DCNL DCSP  DCSP headers = {} DCNL DCSP headers['Content-Type'] = 'text/xml' DCNL DCSP response = self.connection.make_request('POST', self.name, key_name, query_args=query_args, headers=headers, data=xml_body) DCNL DCSP contains_error = False DCNL DCSP body = response.read().decode('utf-8') DCNL DCSP if (body.find('<Error>') > 0): DCNL DCSP  DCSP contains_error = True DCNL DCSP boto.log.debug(body) DCNL DCSP if ((response.status == 200) and (not contains_error)): DCNL DCSP  DCSP resp = CompleteMultiPartUpload(self) DCNL DCSP  DCSP h = handler.XmlHandler(resp, self) DCNL DCSP  DCSP if (not isinstance(body, bytes)): DCNL DCSP  DCSP  DCSP body = body.encode('utf-8') DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP k = self.key_class(self) DCNL DCSP  DCSP k.handle_version_headers(response) DCNL DCSP  DCSP k.handle_encryption_headers(response) DCNL DCSP  DCSP resp.version_id = k.version_id DCNL DCSP  DCSP resp.encrypted = k.encrypted DCNL DCSP  DCSP return resp DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def cancel_multipart_upload(self, key_name, upload_id, headers=None): DCNL DCSP query_args = ('uploadId=%s' % upload_id) DCNL DCSP response = self.connection.make_request('DELETE', self.name, key_name, query_args=query_args, headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status != 204): DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def __init__(self, tracker_file_name=None, num_retries=None): DCNL DCSP self.tracker_file_name = tracker_file_name DCNL DCSP self.num_retries = num_retries DCNL DCSP self.etag_value_for_current_download = None DCNL DCSP if tracker_file_name: DCNL DCSP  DCSP self._load_tracker_file_etag() DCNL DCSP self.download_start_point = None
def _attempt_resumable_download(self, key, fp, headers, cb, num_cb, torrent, version_id, hash_algs): DCNL DCSP cur_file_size = get_cur_file_size(fp, position_to_eof=True) DCNL DCSP if (cur_file_size and self.etag_value_for_current_download and (self.etag_value_for_current_download == key.etag.strip('"\''))): DCNL DCSP  DCSP if (cur_file_size > key.size): DCNL DCSP  DCSP  DCSP raise ResumableDownloadException(('%s DCSP is DCSP larger DCSP (%d) DCSP than DCSP %s DCSP (%d).\nDeleting DCSP tracker DCSP file, DCSP so DCSP if DCSP you DCSP re-try DCSP this DCSP download DCSP it DCSP will DCSP start DCSP from DCSP scratch' % (fp.name, cur_file_size, str(storage_uri_for_key(key)), key.size)), ResumableTransferDisposition.ABORT) DCNL DCSP  DCSP elif (cur_file_size == key.size): DCNL DCSP  DCSP  DCSP if (key.bucket.connection.debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP print 'Download DCSP complete.' DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (key.bucket.connection.debug >= 1): DCNL DCSP  DCSP  DCSP print 'Resuming DCSP download.' DCNL DCSP  DCSP headers = headers.copy() DCNL DCSP  DCSP headers['Range'] = ('bytes=%d-%d' % (cur_file_size, (key.size - 1))) DCNL DCSP  DCSP cb = ByteTranslatingCallbackHandler(cb, cur_file_size).call DCNL DCSP  DCSP self.download_start_point = cur_file_size DCNL DCSP else: DCNL DCSP  DCSP if (key.bucket.connection.debug >= 1): DCNL DCSP  DCSP  DCSP print 'Starting DCSP new DCSP resumable DCSP download.' DCNL DCSP  DCSP self._save_tracker_info(key) DCNL DCSP  DCSP self.download_start_point = 0 DCNL DCSP  DCSP fp.truncate(0) DCNL DCSP if isinstance(key, GSKey): DCNL DCSP  DCSP key.get_file(fp, headers, cb, num_cb, torrent, version_id, override_num_retries=0, hash_algs=hash_algs) DCNL DCSP else: DCNL DCSP  DCSP key.get_file(fp, headers, cb, num_cb, torrent, version_id, override_num_retries=0) DCNL DCSP fp.flush()
def get_file(self, key, fp, headers, cb=None, num_cb=10, torrent=False, version_id=None, hash_algs=None): DCNL DCSP debug = key.bucket.connection.debug DCNL DCSP if (not headers): DCNL DCSP  DCSP headers = {} DCNL DCSP if (self.num_retries is None): DCNL DCSP  DCSP self.num_retries = config.getint('Boto', 'num_retries', 6) DCNL DCSP progress_less_iterations = 0 DCNL DCSP while True: DCNL DCSP  DCSP had_file_bytes_before_attempt = get_cur_file_size(fp) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self._attempt_resumable_download(key, fp, headers, cb, num_cb, torrent, version_id, hash_algs) DCNL DCSP  DCSP  DCSP self._remove_tracker_file() DCNL DCSP  DCSP  DCSP if (debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP print 'Resumable DCSP download DCSP complete.' DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except self.RETRYABLE_EXCEPTIONS as e: DCNL DCSP  DCSP  DCSP if (debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP print ('Caught DCSP exception DCSP (%s)' % e.__repr__()) DCNL DCSP  DCSP  DCSP if (isinstance(e, IOError) and (e.errno == errno.EPIPE)): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(key, GSKey): DCNL DCSP  DCSP  DCSP  DCSP  DCSP key.get_file(fp, headers, cb, num_cb, torrent, version_id, override_num_retries=0, hash_algs=hash_algs) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP key.get_file(fp, headers, cb, num_cb, torrent, version_id, override_num_retries=0) DCNL DCSP  DCSP except ResumableDownloadException as e: DCNL DCSP  DCSP  DCSP if (e.disposition == ResumableTransferDisposition.ABORT_CUR_PROCESS): DCNL DCSP  DCSP  DCSP  DCSP if (debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('Caught DCSP non-retryable DCSP ResumableDownloadException DCSP (%s)' % e.message) DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP elif (e.disposition == ResumableTransferDisposition.ABORT): DCNL DCSP  DCSP  DCSP  DCSP if (debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('Caught DCSP non-retryable DCSP ResumableDownloadException DCSP (%s); DCSP aborting DCSP and DCSP removing DCSP tracker DCSP file' % e.message) DCNL DCSP  DCSP  DCSP  DCSP self._remove_tracker_file() DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP elif (debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP print ('Caught DCSP ResumableDownloadException DCSP (%s) DCSP - DCSP will DCSP retry' % e.message) DCNL DCSP  DCSP if (get_cur_file_size(fp) > had_file_bytes_before_attempt): DCNL DCSP  DCSP  DCSP progress_less_iterations = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP progress_less_iterations += 1 DCNL DCSP  DCSP if (progress_less_iterations > self.num_retries): DCNL DCSP  DCSP  DCSP raise ResumableDownloadException('Too DCSP many DCSP resumable DCSP download DCSP attempts DCSP failed DCSP without DCSP progress. DCSP You DCSP might DCSP try DCSP this DCSP download DCSP again DCSP later', ResumableTransferDisposition.ABORT_CUR_PROCESS) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP key.close() DCNL DCSP  DCSP except httplib.IncompleteRead: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP sleep_time_secs = (2 ** progress_less_iterations) DCNL DCSP  DCSP if (debug >= 1): DCNL DCSP  DCSP  DCSP print ('Got DCSP retryable DCSP failure DCSP (%d DCSP progress-less DCSP in DCSP a DCSP row).\nSleeping DCSP %d DCSP seconds DCSP before DCSP re-trying' % (progress_less_iterations, sleep_time_secs)) DCNL DCSP  DCSP time.sleep(sleep_time_secs)
def set_bucket_class(self, bucket_class): DCNL DCSP self.bucket_class = bucket_class
def build_post_policy(self, expiration_time, conditions): DCNL DCSP assert isinstance(expiration_time, time.struct_time), 'Policy DCSP document DCSP must DCSP include DCSP a DCSP valid DCSP expiration DCSP Time DCSP object' DCNL DCSP return ('{"expiration": DCSP "%s",\n"conditions": DCSP [%s]}' % (time.strftime(boto.utils.ISO8601, expiration_time), ','.join(conditions)))
def build_post_form_args(self, bucket_name, key, expires_in=6000, acl=None, success_action_redirect=None, max_content_length=None, http_method='http', fields=None, conditions=None, storage_class='STANDARD', server_side_encryption=None): DCNL DCSP if (fields is None): DCNL DCSP  DCSP fields = [] DCNL DCSP if (conditions is None): DCNL DCSP  DCSP conditions = [] DCNL DCSP expiration = time.gmtime(int((time.time() + expires_in))) DCNL DCSP conditions.append(('{"bucket": DCSP "%s"}' % bucket_name)) DCNL DCSP if key.endswith('${filename}'): DCNL DCSP  DCSP conditions.append(('["starts-with", DCSP "$key", DCSP "%s"]' % key[:(- len('${filename}'))])) DCNL DCSP else: DCNL DCSP  DCSP conditions.append(('{"key": DCSP "%s"}' % key)) DCNL DCSP if acl: DCNL DCSP  DCSP conditions.append(('{"acl": DCSP "%s"}' % acl)) DCNL DCSP  DCSP fields.append({'name': 'acl', 'value': acl}) DCNL DCSP if success_action_redirect: DCNL DCSP  DCSP conditions.append(('{"success_action_redirect": DCSP "%s"}' % success_action_redirect)) DCNL DCSP  DCSP fields.append({'name': 'success_action_redirect', 'value': success_action_redirect}) DCNL DCSP if max_content_length: DCNL DCSP  DCSP conditions.append(('["content-length-range", DCSP 0, DCSP %i]' % max_content_length)) DCNL DCSP if self.provider.security_token: DCNL DCSP  DCSP fields.append({'name': 'x-amz-security-token', 'value': self.provider.security_token}) DCNL DCSP  DCSP conditions.append(('{"x-amz-security-token": DCSP "%s"}' % self.provider.security_token)) DCNL DCSP if storage_class: DCNL DCSP  DCSP fields.append({'name': 'x-amz-storage-class', 'value': storage_class}) DCNL DCSP  DCSP conditions.append(('{"x-amz-storage-class": DCSP "%s"}' % storage_class)) DCNL DCSP if server_side_encryption: DCNL DCSP  DCSP fields.append({'name': 'x-amz-server-side-encryption', 'value': server_side_encryption}) DCNL DCSP  DCSP conditions.append(('{"x-amz-server-side-encryption": DCSP "%s"}' % server_side_encryption)) DCNL DCSP policy = self.build_post_policy(expiration, conditions) DCNL DCSP policy_b64 = base64.b64encode(policy) DCNL DCSP fields.append({'name': 'policy', 'value': policy_b64}) DCNL DCSP fields.append({'name': 'AWSAccessKeyId', 'value': self.aws_access_key_id}) DCNL DCSP signature = self._auth_handler.sign_string(policy_b64) DCNL DCSP fields.append({'name': 'signature', 'value': signature}) DCNL DCSP fields.append({'name': 'key', 'value': key}) DCNL DCSP url = ('%s://%s/' % (http_method, self.calling_format.build_host(self.server_name(), bucket_name))) DCNL DCSP return {'action': url, 'fields': fields}
def get_canonical_user_id(self, headers=None): DCNL DCSP rs = self.get_all_buckets(headers=headers) DCNL DCSP return rs.owner.id
def get_bucket(self, bucket_name, validate=True, headers=None): DCNL DCSP if validate: DCNL DCSP  DCSP return self.head_bucket(bucket_name, headers=headers) DCNL DCSP else: DCNL DCSP  DCSP return self.bucket_class(self, bucket_name)
def head_bucket(self, bucket_name, headers=None): DCNL DCSP response = self.make_request('HEAD', bucket_name, headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return self.bucket_class(self, bucket_name) DCNL DCSP elif (response.status == 403): DCNL DCSP  DCSP err = self.provider.storage_response_error(response.status, response.reason, body) DCNL DCSP  DCSP err.error_code = 'AccessDenied' DCNL DCSP  DCSP err.error_message = 'Access DCSP Denied' DCNL DCSP  DCSP raise err DCNL DCSP elif (response.status == 404): DCNL DCSP  DCSP err = self.provider.storage_response_error(response.status, response.reason, body) DCNL DCSP  DCSP err.error_code = 'NoSuchBucket' DCNL DCSP  DCSP err.error_message = 'The DCSP specified DCSP bucket DCSP does DCSP not DCSP exist' DCNL DCSP  DCSP raise err DCNL DCSP else: DCNL DCSP  DCSP raise self.provider.storage_response_error(response.status, response.reason, body)
def lookup(self, bucket_name, validate=True, headers=None): DCNL DCSP try: DCNL DCSP  DCSP bucket = self.get_bucket(bucket_name, validate, headers=headers) DCNL DCSP except: DCNL DCSP  DCSP bucket = None DCNL DCSP return bucket
def create_bucket(self, bucket_name, headers=None, location=Location.DEFAULT, policy=None): DCNL DCSP check_lowercase_bucketname(bucket_name) DCNL DCSP if policy: DCNL DCSP  DCSP if headers: DCNL DCSP  DCSP  DCSP headers[self.provider.acl_header] = policy DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP headers = {self.provider.acl_header: policy} DCNL DCSP if (location == Location.DEFAULT): DCNL DCSP  DCSP data = '' DCNL DCSP else: DCNL DCSP  DCSP data = (('<CreateBucketConfiguration><LocationConstraint>' + location) + '</LocationConstraint></CreateBucketConfiguration>') DCNL DCSP response = self.make_request('PUT', bucket_name, headers=headers, data=data) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 409): DCNL DCSP  DCSP raise self.provider.storage_create_error(response.status, response.reason, body) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return self.bucket_class(self, bucket_name) DCNL DCSP else: DCNL DCSP  DCSP raise self.provider.storage_response_error(response.status, response.reason, body)
def delete_bucket(self, bucket, headers=None): DCNL DCSP response = self.make_request('DELETE', bucket, headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status != 204): DCNL DCSP  DCSP raise self.provider.storage_response_error(response.status, response.reason, body)
def get_md5_from_hexdigest(self, md5_hexdigest): DCNL DCSP digest = binascii.unhexlify(md5_hexdigest) DCNL DCSP base64md5 = encodebytes(digest) DCNL DCSP if (base64md5[(-1)] == '\n'): DCNL DCSP  DCSP base64md5 = base64md5[0:(-1)] DCNL DCSP return (md5_hexdigest, base64md5)
def handle_addl_headers(self, headers): DCNL DCSP pass
def open_read(self, headers=None, query_args='', override_num_retries=None, response_headers=None): DCNL DCSP if (self.resp is None): DCNL DCSP  DCSP self.mode = 'r' DCNL DCSP  DCSP provider = self.bucket.connection.provider DCNL DCSP  DCSP self.resp = self.bucket.connection.make_request('GET', self.bucket.name, self.name, headers, query_args=query_args, override_num_retries=override_num_retries) DCNL DCSP  DCSP if ((self.resp.status < 199) or (self.resp.status > 299)): DCNL DCSP  DCSP  DCSP body = self.resp.read() DCNL DCSP  DCSP  DCSP raise provider.storage_response_error(self.resp.status, self.resp.reason, body) DCNL DCSP  DCSP response_headers = self.resp.msg DCNL DCSP  DCSP self.metadata = boto.utils.get_aws_metadata(response_headers, provider) DCNL DCSP  DCSP for (name, value) in response_headers.items(): DCNL DCSP  DCSP  DCSP if ((name.lower() == 'content-length') and ('Content-Range' not in response_headers)): DCNL DCSP  DCSP  DCSP  DCSP self.size = int(value) DCNL DCSP  DCSP  DCSP elif (name.lower() == 'content-range'): DCNL DCSP  DCSP  DCSP  DCSP end_range = re.sub('.*/(.*)', '\\1', value) DCNL DCSP  DCSP  DCSP  DCSP self.size = int(end_range) DCNL DCSP  DCSP  DCSP elif (name.lower() in Key.base_fields): DCNL DCSP  DCSP  DCSP  DCSP self.__dict__[name.lower().replace('-', '_')] = value DCNL DCSP  DCSP self.handle_version_headers(self.resp) DCNL DCSP  DCSP self.handle_encryption_headers(self.resp) DCNL DCSP  DCSP self.handle_restore_headers(self.resp) DCNL DCSP  DCSP self.handle_addl_headers(self.resp.getheaders())
def open_write(self, headers=None, override_num_retries=None): DCNL DCSP raise BotoClientError('Not DCSP Implemented')
def close(self, fast=False): DCNL DCSP if (self.resp and (not fast)): DCNL DCSP  DCSP self.resp.read() DCNL DCSP self.resp = None DCNL DCSP self.mode = None DCNL DCSP self.closed = True
def next(self): DCNL DCSP self.open_read() DCNL DCSP data = self.resp.read(self.BufferSize) DCNL DCSP if (not data): DCNL DCSP  DCSP self.close() DCNL DCSP  DCSP raise StopIteration DCNL DCSP return data
def change_storage_class(self, new_storage_class, dst_bucket=None, validate_dst_bucket=True): DCNL DCSP bucket_name = (dst_bucket or self.bucket.name) DCNL DCSP if (new_storage_class == 'STANDARD'): DCNL DCSP  DCSP return self.copy(bucket_name, self.name, reduced_redundancy=False, preserve_acl=True, validate_dst_bucket=validate_dst_bucket) DCNL DCSP elif (new_storage_class == 'REDUCED_REDUNDANCY'): DCNL DCSP  DCSP return self.copy(bucket_name, self.name, reduced_redundancy=True, preserve_acl=True, validate_dst_bucket=validate_dst_bucket) DCNL DCSP else: DCNL DCSP  DCSP raise BotoClientError(('Invalid DCSP storage DCSP class: DCSP %s' % new_storage_class))
def copy(self, dst_bucket, dst_key, metadata=None, reduced_redundancy=False, preserve_acl=False, encrypt_key=False, validate_dst_bucket=True): DCNL DCSP dst_bucket = self.bucket.connection.lookup(dst_bucket, validate_dst_bucket) DCNL DCSP if reduced_redundancy: DCNL DCSP  DCSP storage_class = 'REDUCED_REDUNDANCY' DCNL DCSP else: DCNL DCSP  DCSP storage_class = self.storage_class DCNL DCSP return dst_bucket.copy_key(dst_key, self.bucket.name, self.name, metadata, storage_class=storage_class, preserve_acl=preserve_acl, encrypt_key=encrypt_key, src_version_id=self.version_id)
def exists(self, headers=None): DCNL DCSP return bool(self.bucket.lookup(self.name, headers=headers))
def delete(self, headers=None): DCNL DCSP return self.bucket.delete_key(self.name, version_id=self.version_id, headers=headers)
def get_redirect(self): DCNL DCSP response = self.bucket.connection.make_request('HEAD', self.bucket.name, self.name) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return response.getheader('x-amz-website-redirect-location') DCNL DCSP else: DCNL DCSP  DCSP raise self.provider.storage_response_error(response.status, response.reason, response.read())
def set_redirect(self, redirect_location, headers=None): DCNL DCSP if (headers is None): DCNL DCSP  DCSP headers = {} DCNL DCSP else: DCNL DCSP  DCSP headers = headers.copy() DCNL DCSP headers['x-amz-website-redirect-location'] = redirect_location DCNL DCSP response = self.bucket.connection.make_request('PUT', self.bucket.name, self.name, headers) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.provider.storage_response_error(response.status, response.reason, response.read())
def generate_url(self, expires_in, method='GET', headers=None, query_auth=True, force_http=False, response_headers=None, expires_in_absolute=False, version_id=None, policy=None, reduced_redundancy=False, encrypt_key=False): DCNL DCSP provider = self.bucket.connection.provider DCNL DCSP version_id = (version_id or self.version_id) DCNL DCSP if (headers is None): DCNL DCSP  DCSP headers = {} DCNL DCSP else: DCNL DCSP  DCSP headers = headers.copy() DCNL DCSP if policy: DCNL DCSP  DCSP headers[provider.acl_header] = policy DCNL DCSP if reduced_redundancy: DCNL DCSP  DCSP self.storage_class = 'REDUCED_REDUNDANCY' DCNL DCSP  DCSP if provider.storage_class_header: DCNL DCSP  DCSP  DCSP headers[provider.storage_class_header] = self.storage_class DCNL DCSP if encrypt_key: DCNL DCSP  DCSP headers[provider.server_side_encryption_header] = 'AES256' DCNL DCSP headers = boto.utils.merge_meta(headers, self.metadata, provider) DCNL DCSP return self.bucket.connection.generate_url(expires_in, method, self.bucket.name, self.name, headers, query_auth, force_http, response_headers, expires_in_absolute, version_id)
def send_file(self, fp, headers=None, cb=None, num_cb=10, query_args=None, chunked_transfer=False, size=None): DCNL DCSP self._send_file_internal(fp, headers=headers, cb=cb, num_cb=num_cb, query_args=query_args, chunked_transfer=chunked_transfer, size=size)
def compute_md5(self, fp, size=None): DCNL DCSP (hex_digest, b64_digest, data_size) = compute_md5(fp, size=size) DCNL DCSP self.size = data_size DCNL DCSP return (hex_digest, b64_digest)
def set_contents_from_stream(self, fp, headers=None, replace=True, cb=None, num_cb=10, policy=None, reduced_redundancy=False, query_args=None, size=None): DCNL DCSP provider = self.bucket.connection.provider DCNL DCSP if (not provider.supports_chunked_transfer()): DCNL DCSP  DCSP raise BotoClientError(('%s DCSP does DCSP not DCSP support DCSP chunked DCSP transfer' % provider.get_provider_name())) DCNL DCSP if ((not self.name) or (self.name == '')): DCNL DCSP  DCSP raise BotoClientError('Cannot DCSP determine DCSP the DCSP destination DCSP object DCSP name DCSP for DCSP the DCSP given DCSP stream') DCNL DCSP if (headers is None): DCNL DCSP  DCSP headers = {} DCNL DCSP if policy: DCNL DCSP  DCSP headers[provider.acl_header] = policy DCNL DCSP if reduced_redundancy: DCNL DCSP  DCSP self.storage_class = 'REDUCED_REDUNDANCY' DCNL DCSP  DCSP if provider.storage_class_header: DCNL DCSP  DCSP  DCSP headers[provider.storage_class_header] = self.storage_class DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP if (not replace): DCNL DCSP  DCSP  DCSP if self.bucket.lookup(self.name): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP self.send_file(fp, headers, cb, num_cb, query_args, chunked_transfer=True, size=size)
def set_contents_from_file(self, fp, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, reduced_redundancy=False, query_args=None, encrypt_key=False, size=None, rewind=False): DCNL DCSP provider = self.bucket.connection.provider DCNL DCSP headers = (headers or {}) DCNL DCSP if policy: DCNL DCSP  DCSP headers[provider.acl_header] = policy DCNL DCSP if encrypt_key: DCNL DCSP  DCSP headers[provider.server_side_encryption_header] = 'AES256' DCNL DCSP if rewind: DCNL DCSP  DCSP fp.seek(0, os.SEEK_SET) DCNL DCSP elif (not isinstance(fp, KeyFile)): DCNL DCSP  DCSP spos = fp.tell() DCNL DCSP  DCSP fp.seek(0, os.SEEK_END) DCNL DCSP  DCSP if (fp.tell() == spos): DCNL DCSP  DCSP  DCSP fp.seek(0, os.SEEK_SET) DCNL DCSP  DCSP  DCSP if (fp.tell() != spos): DCNL DCSP  DCSP  DCSP  DCSP fp.seek(spos) DCNL DCSP  DCSP  DCSP  DCSP raise AttributeError('fp DCSP is DCSP at DCSP EOF. DCSP Use DCSP rewind DCSP option DCSP or DCSP seek() DCSP to DCSP data DCSP start.') DCNL DCSP  DCSP fp.seek(spos) DCNL DCSP if reduced_redundancy: DCNL DCSP  DCSP self.storage_class = 'REDUCED_REDUNDANCY' DCNL DCSP  DCSP if provider.storage_class_header: DCNL DCSP  DCSP  DCSP headers[provider.storage_class_header] = self.storage_class DCNL DCSP if hasattr(fp, 'name'): DCNL DCSP  DCSP self.path = fp.name DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP if ((not md5) and provider.supports_chunked_transfer()): DCNL DCSP  DCSP  DCSP chunked_transfer = True DCNL DCSP  DCSP  DCSP self.size = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP chunked_transfer = False DCNL DCSP  DCSP  DCSP if isinstance(fp, KeyFile): DCNL DCSP  DCSP  DCSP  DCSP key = fp.getkey() DCNL DCSP  DCSP  DCSP  DCSP size = (key.size - fp.tell()) DCNL DCSP  DCSP  DCSP  DCSP self.size = size DCNL DCSP  DCSP  DCSP  DCSP if re.match('^"[a-fA-F0-9]{32}"$', key.etag): DCNL DCSP  DCSP  DCSP  DCSP  DCSP etag = key.etag.strip('"') DCNL DCSP  DCSP  DCSP  DCSP  DCSP md5 = (etag, base64.b64encode(binascii.unhexlify(etag))) DCNL DCSP  DCSP  DCSP if (not md5): DCNL DCSP  DCSP  DCSP  DCSP md5 = self.compute_md5(fp, size) DCNL DCSP  DCSP  DCSP  DCSP size = self.size DCNL DCSP  DCSP  DCSP elif size: DCNL DCSP  DCSP  DCSP  DCSP self.size = size DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP spos = fp.tell() DCNL DCSP  DCSP  DCSP  DCSP fp.seek(0, os.SEEK_END) DCNL DCSP  DCSP  DCSP  DCSP self.size = (fp.tell() - spos) DCNL DCSP  DCSP  DCSP  DCSP fp.seek(spos) DCNL DCSP  DCSP  DCSP  DCSP size = self.size DCNL DCSP  DCSP  DCSP self.md5 = md5[0] DCNL DCSP  DCSP  DCSP self.base64md5 = md5[1] DCNL DCSP  DCSP if (self.name is None): DCNL DCSP  DCSP  DCSP self.name = self.md5 DCNL DCSP  DCSP if (not replace): DCNL DCSP  DCSP  DCSP if self.bucket.lookup(self.name): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP self.send_file(fp, headers=headers, cb=cb, num_cb=num_cb, query_args=query_args, chunked_transfer=chunked_transfer, size=size) DCNL DCSP  DCSP return self.size
def set_contents_from_filename(self, filename, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, reduced_redundancy=False, encrypt_key=False): DCNL DCSP with open(filename, 'rb') as fp: DCNL DCSP  DCSP return self.set_contents_from_file(fp, headers, replace, cb, num_cb, policy, md5, reduced_redundancy, encrypt_key=encrypt_key)
def set_contents_from_string(self, string_data, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, reduced_redundancy=False, encrypt_key=False): DCNL DCSP if (not isinstance(string_data, bytes)): DCNL DCSP  DCSP string_data = string_data.encode('utf-8') DCNL DCSP fp = BytesIO(string_data) DCNL DCSP r = self.set_contents_from_file(fp, headers, replace, cb, num_cb, policy, md5, reduced_redundancy, encrypt_key=encrypt_key) DCNL DCSP fp.close() DCNL DCSP return r
def get_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, override_num_retries=None, response_headers=None): DCNL DCSP self._get_file_internal(fp, headers=headers, cb=cb, num_cb=num_cb, torrent=torrent, version_id=version_id, override_num_retries=override_num_retries, response_headers=response_headers, hash_algs=None, query_args=None)
def get_torrent_file(self, fp, headers=None, cb=None, num_cb=10): DCNL DCSP return self.get_file(fp, headers, cb, num_cb, torrent=True)
def get_contents_to_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, res_download_handler=None, response_headers=None): DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP if res_download_handler: DCNL DCSP  DCSP  DCSP res_download_handler.get_file(self, fp, headers, cb, num_cb, torrent=torrent, version_id=version_id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.get_file(fp, headers, cb, num_cb, torrent=torrent, version_id=version_id, response_headers=response_headers)
def get_contents_to_filename(self, filename, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, res_download_handler=None, response_headers=None): DCNL DCSP try: DCNL DCSP  DCSP with open(filename, 'wb') as fp: DCNL DCSP  DCSP  DCSP self.get_contents_to_file(fp, headers, cb, num_cb, torrent=torrent, version_id=version_id, res_download_handler=res_download_handler, response_headers=response_headers) DCNL DCSP except Exception: DCNL DCSP  DCSP os.remove(filename) DCNL DCSP  DCSP raise DCNL DCSP if (self.last_modified is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP modified_tuple = email.utils.parsedate_tz(self.last_modified) DCNL DCSP  DCSP  DCSP modified_stamp = int(email.utils.mktime_tz(modified_tuple)) DCNL DCSP  DCSP  DCSP os.utime(fp.name, (modified_stamp, modified_stamp)) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
def get_contents_as_string(self, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, response_headers=None, encoding=None): DCNL DCSP fp = BytesIO() DCNL DCSP self.get_contents_to_file(fp, headers, cb, num_cb, torrent=torrent, version_id=version_id, response_headers=response_headers) DCNL DCSP value = fp.getvalue() DCNL DCSP if (encoding is not None): DCNL DCSP  DCSP value = value.decode(encoding) DCNL DCSP return value
def add_email_grant(self, permission, email_address, headers=None): DCNL DCSP policy = self.get_acl(headers=headers) DCNL DCSP policy.acl.add_email_grant(permission, email_address) DCNL DCSP self.set_acl(policy, headers=headers)
def add_user_grant(self, permission, user_id, headers=None, display_name=None): DCNL DCSP policy = self.get_acl(headers=headers) DCNL DCSP policy.acl.add_user_grant(permission, user_id, display_name=display_name) DCNL DCSP self.set_acl(policy, headers=headers)
def _get_remote_metadata(self, headers=None): DCNL DCSP metadata = {} DCNL DCSP for underscore_name in self._underscore_base_user_settable_fields: DCNL DCSP  DCSP if hasattr(self, underscore_name): DCNL DCSP  DCSP  DCSP value = getattr(self, underscore_name) DCNL DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP field_name = underscore_name.replace('_', '-') DCNL DCSP  DCSP  DCSP  DCSP metadata[field_name.lower()] = value DCNL DCSP prefix = self.provider.metadata_prefix DCNL DCSP for underscore_name in self.metadata: DCNL DCSP  DCSP field_name = underscore_name.replace('_', '-') DCNL DCSP  DCSP metadata[('%s%s' % (prefix, field_name.lower()))] = self.metadata[underscore_name] DCNL DCSP return metadata
def restore(self, days, headers=None): DCNL DCSP response = self.bucket.connection.make_request('POST', self.bucket.name, self.name, data=(self.RestoreBody % days), headers=headers, query_args='restore') DCNL DCSP if (response.status not in (200, 202)): DCNL DCSP  DCSP provider = self.bucket.connection.provider DCNL DCSP  DCSP raise provider.storage_response_error(response.status, response.reason, response.read())
def to_xml(self): DCNL DCSP s = '<CORSConfiguration>' DCNL DCSP for rule in self: DCNL DCSP  DCSP s += rule.to_xml() DCNL DCSP s += '</CORSConfiguration>' DCNL DCSP return s
def add_rule(self, allowed_method, allowed_origin, id=None, allowed_header=None, max_age_seconds=None, expose_header=None): DCNL DCSP if (not isinstance(allowed_method, (list, tuple))): DCNL DCSP  DCSP allowed_method = [allowed_method] DCNL DCSP if (not isinstance(allowed_origin, (list, tuple))): DCNL DCSP  DCSP allowed_origin = [allowed_origin] DCNL DCSP if (not isinstance(allowed_origin, (list, tuple))): DCNL DCSP  DCSP if (allowed_origin is None): DCNL DCSP  DCSP  DCSP allowed_origin = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP allowed_origin = [allowed_origin] DCNL DCSP if (not isinstance(expose_header, (list, tuple))): DCNL DCSP  DCSP if (expose_header is None): DCNL DCSP  DCSP  DCSP expose_header = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP expose_header = [expose_header] DCNL DCSP rule = CORSRule(allowed_method, allowed_origin, id, allowed_header, max_age_seconds, expose_header) DCNL DCSP self.append(rule)
def get_all_parts(self, max_parts=None, part_number_marker=None, encoding_type=None): DCNL DCSP self._parts = [] DCNL DCSP query_args = ('uploadId=%s' % self.id) DCNL DCSP if max_parts: DCNL DCSP  DCSP query_args += ('&max-parts=%d' % max_parts) DCNL DCSP if part_number_marker: DCNL DCSP  DCSP query_args += ('&part-number-marker=%s' % part_number_marker) DCNL DCSP if encoding_type: DCNL DCSP  DCSP query_args += ('&encoding-type=%s' % encoding_type) DCNL DCSP response = self.bucket.connection.make_request('GET', self.bucket.name, self.key_name, query_args=query_args) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP h = handler.XmlHandler(self, self) DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return self._parts
def upload_part_from_file(self, fp, part_num, headers=None, replace=True, cb=None, num_cb=10, md5=None, size=None): DCNL DCSP if (part_num < 1): DCNL DCSP  DCSP raise ValueError('Part DCSP numbers DCSP must DCSP be DCSP greater DCSP than DCSP zero') DCNL DCSP query_args = ('uploadId=%s&partNumber=%d' % (self.id, part_num)) DCNL DCSP key = self.bucket.new_key(self.key_name) DCNL DCSP key.set_contents_from_file(fp, headers=headers, replace=replace, cb=cb, num_cb=num_cb, md5=md5, reduced_redundancy=False, query_args=query_args, size=size) DCNL DCSP return key
def copy_part_from_key(self, src_bucket_name, src_key_name, part_num, start=None, end=None, src_version_id=None, headers=None): DCNL DCSP if (part_num < 1): DCNL DCSP  DCSP raise ValueError('Part DCSP numbers DCSP must DCSP be DCSP greater DCSP than DCSP zero') DCNL DCSP query_args = ('uploadId=%s&partNumber=%d' % (self.id, part_num)) DCNL DCSP if ((start is not None) and (end is not None)): DCNL DCSP  DCSP rng = ('bytes=%s-%s' % (start, end)) DCNL DCSP  DCSP provider = self.bucket.connection.provider DCNL DCSP  DCSP if (headers is None): DCNL DCSP  DCSP  DCSP headers = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP headers = headers.copy() DCNL DCSP  DCSP headers[provider.copy_source_range_header] = rng DCNL DCSP return self.bucket.copy_key(self.key_name, src_bucket_name, src_key_name, src_version_id=src_version_id, storage_class=None, headers=headers, query_args=query_args)
def complete_upload(self): DCNL DCSP xml = self.to_xml() DCNL DCSP return self.bucket.complete_multipart_upload(self.key_name, self.id, xml)
def cancel_upload(self): DCNL DCSP self.bucket.cancel_multipart_upload(self.key_name, self.id)
def add_event_source(self, event_source, function_name, role, batch_size=None, parameters=None): DCNL DCSP uri = '/2014-11-13/event-source-mappings/' DCNL DCSP params = {'EventSource': event_source, 'FunctionName': function_name, 'Role': role} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (batch_size is not None): DCNL DCSP  DCSP params['BatchSize'] = batch_size DCNL DCSP if (parameters is not None): DCNL DCSP  DCSP params['Parameters'] = parameters DCNL DCSP return self.make_request('POST', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def delete_function(self, function_name): DCNL DCSP uri = '/2014-11-13/functions/{0}'.format(function_name) DCNL DCSP return self.make_request('DELETE', uri, expected_status=204)
def get_event_source(self, uuid): DCNL DCSP uri = '/2014-11-13/event-source-mappings/{0}'.format(uuid) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def get_function(self, function_name): DCNL DCSP uri = '/2014-11-13/functions/{0}'.format(function_name) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def get_function_configuration(self, function_name): DCNL DCSP uri = '/2014-11-13/functions/{0}/configuration'.format(function_name) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def invoke_async(self, function_name, invoke_args): DCNL DCSP uri = '/2014-11-13/functions/{0}/invoke-async/'.format(function_name) DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP try: DCNL DCSP  DCSP content_length = str(len(invoke_args)) DCNL DCSP except (TypeError, AttributeError): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP invoke_args.tell() DCNL DCSP  DCSP except (AttributeError, OSError, IOError): DCNL DCSP  DCSP  DCSP raise TypeError('File-like DCSP object DCSP passed DCSP to DCSP parameter DCSP ``invoke_args`` DCSP must DCSP be DCSP seekable.') DCNL DCSP  DCSP content_length = str(os.fstat(invoke_args.fileno()).st_size) DCNL DCSP headers['Content-Length'] = content_length DCNL DCSP return self.make_request('POST', uri, expected_status=202, data=invoke_args, headers=headers, params=query_params)
def list_event_sources(self, event_source_arn=None, function_name=None, marker=None, max_items=None): DCNL DCSP uri = '/2014-11-13/event-source-mappings/' DCNL DCSP params = {} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (event_source_arn is not None): DCNL DCSP  DCSP query_params['EventSource'] = event_source_arn DCNL DCSP if (function_name is not None): DCNL DCSP  DCSP query_params['FunctionName'] = function_name DCNL DCSP if (marker is not None): DCNL DCSP  DCSP query_params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP query_params['MaxItems'] = max_items DCNL DCSP return self.make_request('GET', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def list_functions(self, marker=None, max_items=None): DCNL DCSP uri = '/2014-11-13/functions/' DCNL DCSP params = {} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (marker is not None): DCNL DCSP  DCSP query_params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP query_params['MaxItems'] = max_items DCNL DCSP return self.make_request('GET', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def remove_event_source(self, uuid): DCNL DCSP uri = '/2014-11-13/event-source-mappings/{0}'.format(uuid) DCNL DCSP return self.make_request('DELETE', uri, expected_status=204)
def update_function_configuration(self, function_name, role=None, handler=None, description=None, timeout=None, memory_size=None): DCNL DCSP uri = '/2014-11-13/functions/{0}/configuration'.format(function_name) DCNL DCSP params = {} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (role is not None): DCNL DCSP  DCSP query_params['Role'] = role DCNL DCSP if (handler is not None): DCNL DCSP  DCSP query_params['Handler'] = handler DCNL DCSP if (description is not None): DCNL DCSP  DCSP query_params['Description'] = description DCNL DCSP if (timeout is not None): DCNL DCSP  DCSP query_params['Timeout'] = timeout DCNL DCSP if (memory_size is not None): DCNL DCSP  DCSP query_params['MemorySize'] = memory_size DCNL DCSP return self.make_request('PUT', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def upload_function(self, function_name, function_zip, runtime, role, handler, mode, description=None, timeout=None, memory_size=None): DCNL DCSP uri = '/2014-11-13/functions/{0}'.format(function_name) DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (runtime is not None): DCNL DCSP  DCSP query_params['Runtime'] = runtime DCNL DCSP if (role is not None): DCNL DCSP  DCSP query_params['Role'] = role DCNL DCSP if (handler is not None): DCNL DCSP  DCSP query_params['Handler'] = handler DCNL DCSP if (mode is not None): DCNL DCSP  DCSP query_params['Mode'] = mode DCNL DCSP if (description is not None): DCNL DCSP  DCSP query_params['Description'] = description DCNL DCSP if (timeout is not None): DCNL DCSP  DCSP query_params['Timeout'] = timeout DCNL DCSP if (memory_size is not None): DCNL DCSP  DCSP query_params['MemorySize'] = memory_size DCNL DCSP try: DCNL DCSP  DCSP content_length = str(len(function_zip)) DCNL DCSP except (TypeError, AttributeError): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP function_zip.tell() DCNL DCSP  DCSP except (AttributeError, OSError, IOError): DCNL DCSP  DCSP  DCSP raise TypeError('File-like DCSP object DCSP passed DCSP to DCSP parameter DCSP ``function_zip`` DCSP must DCSP be DCSP seekable.') DCNL DCSP  DCSP content_length = str(os.fstat(function_zip.fileno()).st_size) DCNL DCSP headers['Content-Length'] = content_length DCNL DCSP return self.make_request('PUT', uri, expected_status=201, data=function_zip, headers=headers, params=query_params)
def load_credential_file(self, path): DCNL DCSP c_data = StringIO() DCNL DCSP c_data.write('[Credentials]\n') DCNL DCSP for line in open(path, 'r').readlines(): DCNL DCSP  DCSP c_data.write(line.replace('AWSAccessKeyId', 'aws_access_key_id').replace('AWSSecretKey', 'aws_secret_access_key')) DCNL DCSP c_data.seek(0) DCNL DCSP self.readfp(c_data)
def save_option(self, path, section, option, value): DCNL DCSP config = ConfigParser() DCNL DCSP config.read(path) DCNL DCSP if (not config.has_section(section)): DCNL DCSP  DCSP config.add_section(section) DCNL DCSP config.set(section, option, value) DCNL DCSP fp = open(path, 'w') DCNL DCSP config.write(fp) DCNL DCSP fp.close() DCNL DCSP if (not self.has_section(section)): DCNL DCSP  DCSP self.add_section(section) DCNL DCSP self.set(section, option, value)
def add_cron(self, name, minute, hour, mday, month, wday, who, command, env=None): DCNL DCSP raise NotImplementedError
def add_env(self, key, value): DCNL DCSP raise NotImplementedError
def stop(self, service_name): DCNL DCSP raise NotImplementedError
def start(self, service_name): DCNL DCSP raise NotImplementedError
def install(self): DCNL DCSP raise NotImplementedError
def add_cron(self, name, command, minute='*', hour='*', mday='*', month='*', wday='*', who='root', env=None): DCNL DCSP if (minute == 'random'): DCNL DCSP  DCSP minute = str(random.randrange(60)) DCNL DCSP if (hour == 'random'): DCNL DCSP  DCSP hour = str(random.randrange(24)) DCNL DCSP fp = open(('/etc/cron.d/%s' % name), 'w') DCNL DCSP if env: DCNL DCSP  DCSP for (key, value) in env.items(): DCNL DCSP  DCSP  DCSP fp.write(('%s=%s\n' % (key, value))) DCNL DCSP fp.write(('%s DCSP %s DCSP %s DCSP %s DCSP %s DCSP %s DCSP %s\n' % (minute, hour, mday, month, wday, who, command))) DCNL DCSP fp.close()
def add_init_script(self, file, name): DCNL DCSP f_path = os.path.join('/etc/init.d', name) DCNL DCSP f = open(f_path, 'w') DCNL DCSP f.write(file) DCNL DCSP f.close() DCNL DCSP os.chmod(f_path, ((stat.S_IREAD | stat.S_IWRITE) | stat.S_IEXEC)) DCNL DCSP self.run(('/usr/sbin/update-rc.d DCSP %s DCSP defaults' % name))
def add_env(self, key, value): DCNL DCSP boto.log.info(('Adding DCSP env DCSP variable: DCSP %s=%s' % (key, value))) DCNL DCSP if (not os.path.exists('/etc/environment.orig')): DCNL DCSP  DCSP self.run('cp DCSP /etc/environment DCSP /etc/environment.orig', notify=False, exit_on_error=False) DCNL DCSP fp = open('/etc/environment', 'a') DCNL DCSP fp.write(('\n%s="%s"' % (key, value))) DCNL DCSP fp.close() DCNL DCSP os.environ[key] = value
def create_user(self, user): DCNL DCSP self.run(('useradd DCSP -m DCSP %s' % user)) DCNL DCSP usr = getpwnam(user) DCNL DCSP return usr
def install(self): DCNL DCSP raise NotImplementedError
def validateStartTag(self, tag, parent): DCNL DCSP if (self.current_tag != parent): DCNL DCSP  DCSP raise InvalidLifecycleConfigError(('Invalid DCSP tag DCSP %s DCSP found DCSP inside DCSP %s DCSP tag' % (tag, self.current_tag)))
def validateEndTag(self, tag): DCNL DCSP if (tag != self.current_tag): DCNL DCSP  DCSP raise InvalidLifecycleConfigError(('Mismatched DCSP start DCSP and DCSP end DCSP tags DCSP (%s/%s)' % (self.current_tag, tag)))
def validate(self): DCNL DCSP if (not self.action): DCNL DCSP  DCSP raise InvalidLifecycleConfigError('No DCSP action DCSP was DCSP specified DCSP in DCSP the DCSP rule') DCNL DCSP if (not self.conditions): DCNL DCSP  DCSP raise InvalidLifecycleConfigError(('No DCSP condition DCSP was DCSP specified DCSP for DCSP action DCSP %s' % self.action))
def to_xml(self): DCNL DCSP s = [(('<' + RULE) + '>')] DCNL DCSP s.append((('<' + ACTION) + '>')) DCNL DCSP if self.action_text: DCNL DCSP  DCSP s.extend([(('<' + self.action) + '>'), self.action_text, (('</' + self.action) + '>')]) DCNL DCSP else: DCNL DCSP  DCSP s.append((('<' + self.action) + '/>')) DCNL DCSP s.append((('</' + ACTION) + '>')) DCNL DCSP s.append((('<' + CONDITION) + '>')) DCNL DCSP for condition_name in self.conditions: DCNL DCSP  DCSP if (condition_name not in LEGAL_CONDITIONS): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (condition_name in LEGAL_REPEATABLE_CONDITIONS): DCNL DCSP  DCSP  DCSP condition_values = self.conditions[condition_name] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP condition_values = [self.conditions[condition_name]] DCNL DCSP  DCSP for condition_value in condition_values: DCNL DCSP  DCSP  DCSP s.extend([(('<' + condition_name) + '>'), condition_value, (('</' + condition_name) + '>')]) DCNL DCSP s.append((('</' + CONDITION) + '>')) DCNL DCSP s.append((('</' + RULE) + '>')) DCNL DCSP return ''.join(s)
def to_xml(self): DCNL DCSP s = ['<?xml DCSP version="1.0" DCSP encoding="UTF-8"?>'] DCNL DCSP s.append((('<' + LIFECYCLE_CONFIG) + '>')) DCNL DCSP for rule in self: DCNL DCSP  DCSP s.append(rule.to_xml()) DCNL DCSP s.append((('</' + LIFECYCLE_CONFIG) + '>')) DCNL DCSP return ''.join(s)
def add_rule(self, action, action_text, conditions): DCNL DCSP rule = Rule(action, action_text, conditions) DCNL DCSP self.append(rule)
def get_key(self, key_name, headers=None, version_id=None, response_headers=None, generation=None): DCNL DCSP query_args_l = [] DCNL DCSP if generation: DCNL DCSP  DCSP query_args_l.append(('generation=%s' % generation)) DCNL DCSP if response_headers: DCNL DCSP  DCSP for (rk, rv) in six.iteritems(response_headers): DCNL DCSP  DCSP  DCSP query_args_l.append(('%s=%s' % (rk, urllib.quote(rv)))) DCNL DCSP try: DCNL DCSP  DCSP (key, resp) = self._get_key_internal(key_name, headers, query_args_l=query_args_l) DCNL DCSP except GSResponseError as e: DCNL DCSP  DCSP if ((e.status == 403) and ('Forbidden' in e.reason)): DCNL DCSP  DCSP  DCSP e.reason = ("Access DCSP denied DCSP to DCSP 'gs://%s/%s'." % (self.name, key_name)) DCNL DCSP  DCSP raise DCNL DCSP return key
def copy_key(self, new_key_name, src_bucket_name, src_key_name, metadata=None, src_version_id=None, storage_class='STANDARD', preserve_acl=False, encrypt_key=False, headers=None, query_args=None, src_generation=None): DCNL DCSP if src_generation: DCNL DCSP  DCSP headers = (headers or {}) DCNL DCSP  DCSP headers['x-goog-copy-source-generation'] = str(src_generation) DCNL DCSP return super(Bucket, self).copy_key(new_key_name, src_bucket_name, src_key_name, metadata=metadata, storage_class=storage_class, preserve_acl=preserve_acl, encrypt_key=encrypt_key, headers=headers, query_args=query_args)
def list_versions(self, prefix='', delimiter='', marker='', generation_marker='', headers=None): DCNL DCSP return VersionedBucketListResultSet(self, prefix, delimiter, marker, generation_marker, headers)
def validate_get_all_versions_params(self, params): DCNL DCSP self.validate_kwarg_names(params, ['version_id_marker', 'delimiter', 'marker', 'generation_marker', 'prefix', 'max_keys'])
def delete_key(self, key_name, headers=None, version_id=None, mfa_token=None, generation=None): DCNL DCSP query_args_l = [] DCNL DCSP if generation: DCNL DCSP  DCSP query_args_l.append(('generation=%s' % generation)) DCNL DCSP self._delete_key_internal(key_name, headers=headers, version_id=version_id, mfa_token=mfa_token, query_args_l=query_args_l)
def set_acl(self, acl_or_str, key_name='', headers=None, version_id=None, generation=None, if_generation=None, if_metageneration=None): DCNL DCSP if isinstance(acl_or_str, Policy): DCNL DCSP  DCSP raise InvalidAclError('Attempt DCSP to DCSP set DCSP S3 DCSP Policy DCSP on DCSP GS DCSP ACL') DCNL DCSP elif isinstance(acl_or_str, ACL): DCNL DCSP  DCSP self.set_xml_acl(acl_or_str.to_xml(), key_name, headers=headers, generation=generation, if_generation=if_generation, if_metageneration=if_metageneration) DCNL DCSP else: DCNL DCSP  DCSP self.set_canned_acl(acl_or_str, key_name, headers=headers, generation=generation, if_generation=if_generation, if_metageneration=if_metageneration)
def set_def_acl(self, acl_or_str, headers=None): DCNL DCSP if isinstance(acl_or_str, Policy): DCNL DCSP  DCSP raise InvalidAclError('Attempt DCSP to DCSP set DCSP S3 DCSP Policy DCSP on DCSP GS DCSP ACL') DCNL DCSP elif isinstance(acl_or_str, ACL): DCNL DCSP  DCSP self.set_def_xml_acl(acl_or_str.to_xml(), headers=headers) DCNL DCSP else: DCNL DCSP  DCSP self.set_def_canned_acl(acl_or_str, headers=headers)
def _get_xml_acl_helper(self, key_name, headers, query_args): DCNL DCSP response = self.connection.make_request('GET', self.name, key_name, query_args=query_args, headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP if (response.status == 403): DCNL DCSP  DCSP  DCSP match = ERROR_DETAILS_REGEX.search(body) DCNL DCSP  DCSP  DCSP details = (match.group('details') if match else None) DCNL DCSP  DCSP  DCSP if details: DCNL DCSP  DCSP  DCSP  DCSP details = ('<Details>%s. DCSP Note DCSP that DCSP Full DCSP Control DCSP access DCSP is DCSP required DCSP to DCSP access DCSP ACLs.</Details>' % details) DCNL DCSP  DCSP  DCSP  DCSP body = re.sub(ERROR_DETAILS_REGEX, details, body) DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body) DCNL DCSP return body
def _get_acl_helper(self, key_name, headers, query_args): DCNL DCSP body = self._get_xml_acl_helper(key_name, headers, query_args) DCNL DCSP acl = ACL(self) DCNL DCSP h = handler.XmlHandler(acl, self) DCNL DCSP xml.sax.parseString(body, h) DCNL DCSP return acl
def get_acl(self, key_name='', headers=None, version_id=None, generation=None): DCNL DCSP query_args = STANDARD_ACL DCNL DCSP if generation: DCNL DCSP  DCSP query_args += ('&generation=%s' % generation) DCNL DCSP return self._get_acl_helper(key_name, headers, query_args)
def get_xml_acl(self, key_name='', headers=None, version_id=None, generation=None): DCNL DCSP query_args = STANDARD_ACL DCNL DCSP if generation: DCNL DCSP  DCSP query_args += ('&generation=%s' % generation) DCNL DCSP return self._get_xml_acl_helper(key_name, headers, query_args)
def get_def_acl(self, headers=None): DCNL DCSP return self._get_acl_helper('', headers, DEF_OBJ_ACL)
def _set_acl_helper(self, acl_or_str, key_name, headers, query_args, generation, if_generation, if_metageneration, canned=False): DCNL DCSP headers = (headers or {}) DCNL DCSP data = '' DCNL DCSP if canned: DCNL DCSP  DCSP headers[self.connection.provider.acl_header] = acl_or_str DCNL DCSP else: DCNL DCSP  DCSP data = acl_or_str DCNL DCSP if generation: DCNL DCSP  DCSP query_args += ('&generation=%s' % generation) DCNL DCSP if ((if_metageneration is not None) and (if_generation is None)): DCNL DCSP  DCSP raise ValueError('Received DCSP if_metageneration DCSP argument DCSP with DCSP no DCSP if_generation DCSP argument. DCSP A DCSP metageneration DCSP has DCSP no DCSP meaning DCSP without DCSP a DCSP content DCSP generation.') DCNL DCSP if ((not key_name) and (if_generation or if_metageneration)): DCNL DCSP  DCSP raise ValueError('Received DCSP if_generation DCSP or DCSP if_metageneration DCSP parameter DCSP while DCSP setting DCSP the DCSP ACL DCSP of DCSP a DCSP bucket.') DCNL DCSP if (if_generation is not None): DCNL DCSP  DCSP headers['x-goog-if-generation-match'] = str(if_generation) DCNL DCSP if (if_metageneration is not None): DCNL DCSP  DCSP headers['x-goog-if-metageneration-match'] = str(if_metageneration) DCNL DCSP response = self.connection.make_request('PUT', get_utf8_value(self.name), get_utf8_value(key_name), data=get_utf8_value(data), headers=headers, query_args=query_args) DCNL DCSP body = response.read() DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def set_xml_acl(self, acl_str, key_name='', headers=None, version_id=None, query_args='acl', generation=None, if_generation=None, if_metageneration=None): DCNL DCSP return self._set_acl_helper(acl_str, key_name=key_name, headers=headers, query_args=query_args, generation=generation, if_generation=if_generation, if_metageneration=if_metageneration)
def set_canned_acl(self, acl_str, key_name='', headers=None, version_id=None, generation=None, if_generation=None, if_metageneration=None): DCNL DCSP if (acl_str not in CannedACLStrings): DCNL DCSP  DCSP raise ValueError(('Provided DCSP canned DCSP ACL DCSP string DCSP (%s) DCSP is DCSP not DCSP valid.' % acl_str)) DCNL DCSP query_args = STANDARD_ACL DCNL DCSP return self._set_acl_helper(acl_str, key_name, headers, query_args, generation, if_generation, if_metageneration, canned=True)
def set_def_canned_acl(self, acl_str, headers=None): DCNL DCSP if (acl_str not in CannedACLStrings): DCNL DCSP  DCSP raise ValueError(('Provided DCSP canned DCSP ACL DCSP string DCSP (%s) DCSP is DCSP not DCSP valid.' % acl_str)) DCNL DCSP query_args = DEF_OBJ_ACL DCNL DCSP return self._set_acl_helper(acl_str, '', headers, query_args, generation=None, if_generation=None, if_metageneration=None, canned=True)
def set_def_xml_acl(self, acl_str, headers=None): DCNL DCSP return self.set_xml_acl(acl_str, '', headers, query_args=DEF_OBJ_ACL)
def get_cors(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args=CORS_ARG, headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP cors = Cors() DCNL DCSP  DCSP h = handler.XmlHandler(cors, self) DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return cors DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def set_cors(self, cors, headers=None): DCNL DCSP response = self.connection.make_request('PUT', get_utf8_value(self.name), data=get_utf8_value(cors), query_args=CORS_ARG, headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def get_storage_class(self): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args=STORAGE_CLASS_ARG) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP rs = ResultSet(self) DCNL DCSP  DCSP h = handler.XmlHandler(rs, self) DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return rs.StorageClass DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def set_storage_class(self, storage_class, headers=None): DCNL DCSP req_body = (self.StorageClassBody % get_utf8_value(storage_class)) DCNL DCSP self.set_subresource(STORAGE_CLASS_ARG, req_body, headers=headers)
def add_email_grant(self, permission, email_address, recursive=False, headers=None): DCNL DCSP if (permission not in GSPermissions): DCNL DCSP  DCSP raise self.connection.provider.storage_permissions_error(('Unknown DCSP Permission: DCSP %s' % permission)) DCNL DCSP acl = self.get_acl(headers=headers) DCNL DCSP acl.add_email_grant(permission, email_address) DCNL DCSP self.set_acl(acl, headers=headers) DCNL DCSP if recursive: DCNL DCSP  DCSP for key in self: DCNL DCSP  DCSP  DCSP key.add_email_grant(permission, email_address, headers=headers)
def add_user_grant(self, permission, user_id, recursive=False, headers=None): DCNL DCSP if (permission not in GSPermissions): DCNL DCSP  DCSP raise self.connection.provider.storage_permissions_error(('Unknown DCSP Permission: DCSP %s' % permission)) DCNL DCSP acl = self.get_acl(headers=headers) DCNL DCSP acl.add_user_grant(permission, user_id) DCNL DCSP self.set_acl(acl, headers=headers) DCNL DCSP if recursive: DCNL DCSP  DCSP for key in self: DCNL DCSP  DCSP  DCSP key.add_user_grant(permission, user_id, headers=headers)
def add_group_email_grant(self, permission, email_address, recursive=False, headers=None): DCNL DCSP if (permission not in GSPermissions): DCNL DCSP  DCSP raise self.connection.provider.storage_permissions_error(('Unknown DCSP Permission: DCSP %s' % permission)) DCNL DCSP acl = self.get_acl(headers=headers) DCNL DCSP acl.add_group_email_grant(permission, email_address) DCNL DCSP self.set_acl(acl, headers=headers) DCNL DCSP if recursive: DCNL DCSP  DCSP for key in self: DCNL DCSP  DCSP  DCSP key.add_group_email_grant(permission, email_address, headers=headers)
def list_grants(self, headers=None): DCNL DCSP acl = self.get_acl(headers=headers) DCNL DCSP return acl.entries
def disable_logging(self, headers=None): DCNL DCSP xml_str = '<?xml DCSP version="1.0" DCSP encoding="UTF-8"?><Logging/>' DCNL DCSP self.set_subresource('logging', xml_str, headers=headers)
def enable_logging(self, target_bucket, target_prefix=None, headers=None): DCNL DCSP if isinstance(target_bucket, Bucket): DCNL DCSP  DCSP target_bucket = target_bucket.name DCNL DCSP xml_str = '<?xml DCSP version="1.0" DCSP encoding="UTF-8"?><Logging>' DCNL DCSP xml_str = (xml_str + ('<LogBucket>%s</LogBucket>' % target_bucket)) DCNL DCSP if target_prefix: DCNL DCSP  DCSP xml_str = (xml_str + ('<LogObjectPrefix>%s</LogObjectPrefix>' % target_prefix)) DCNL DCSP xml_str = (xml_str + '</Logging>') DCNL DCSP self.set_subresource('logging', xml_str, headers=headers)
def get_logging_config_with_xml(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='logging', headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element() DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return (e, body)
def get_logging_config(self, headers=None): DCNL DCSP return self.get_logging_config_with_xml(headers)[0]
def configure_website(self, main_page_suffix=None, error_key=None, headers=None): DCNL DCSP if main_page_suffix: DCNL DCSP  DCSP main_page_frag = (self.WebsiteMainPageFragment % main_page_suffix) DCNL DCSP else: DCNL DCSP  DCSP main_page_frag = '' DCNL DCSP if error_key: DCNL DCSP  DCSP error_frag = (self.WebsiteErrorFragment % error_key) DCNL DCSP else: DCNL DCSP  DCSP error_frag = '' DCNL DCSP body = (self.WebsiteBody % (main_page_frag, error_frag)) DCNL DCSP response = self.connection.make_request('PUT', get_utf8_value(self.name), data=get_utf8_value(body), query_args='websiteConfig', headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def get_website_configuration(self, headers=None): DCNL DCSP return self.get_website_configuration_with_xml(headers)[0]
def get_website_configuration_with_xml(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='websiteConfig', headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element() DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return (e, body)
def delete_website_configuration(self, headers=None): DCNL DCSP self.configure_website(headers=headers)
def get_versioning_status(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args='versioning', headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body) DCNL DCSP resp_json = boto.jsonresponse.Element() DCNL DCSP boto.jsonresponse.XmlHandler(resp_json, None).parse(body) DCNL DCSP resp_json = resp_json['VersioningConfiguration'] DCNL DCSP return (('Status' in resp_json) and (resp_json['Status'] == 'Enabled'))
def configure_versioning(self, enabled, headers=None): DCNL DCSP if (enabled == True): DCNL DCSP  DCSP req_body = (self.VersioningBody % 'Enabled') DCNL DCSP else: DCNL DCSP  DCSP req_body = (self.VersioningBody % 'Suspended') DCNL DCSP self.set_subresource('versioning', req_body, headers=headers)
def get_lifecycle_config(self, headers=None): DCNL DCSP response = self.connection.make_request('GET', self.name, query_args=LIFECYCLE_ARG, headers=headers) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP lifecycle_config = LifecycleConfig() DCNL DCSP  DCSP h = handler.XmlHandler(lifecycle_config, self) DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return lifecycle_config DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def configure_lifecycle(self, lifecycle_config, headers=None): DCNL DCSP xml = lifecycle_config.to_xml() DCNL DCSP response = self.connection.make_request('PUT', get_utf8_value(self.name), data=get_utf8_value(xml), query_args=LIFECYCLE_ARG, headers=headers) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise self.connection.provider.storage_response_error(response.status, response.reason, body)
def __init__(self, tracker_file_name=None, num_retries=None): DCNL DCSP self.tracker_file_name = tracker_file_name DCNL DCSP self.num_retries = num_retries DCNL DCSP self.server_has_bytes = 0 DCNL DCSP self.tracker_uri = None DCNL DCSP if tracker_file_name: DCNL DCSP  DCSP self._load_tracker_uri_from_file() DCNL DCSP self.upload_start_point = None
def _save_tracker_uri_to_file(self): DCNL DCSP if (not self.tracker_file_name): DCNL DCSP  DCSP return DCNL DCSP f = None DCNL DCSP try: DCNL DCSP  DCSP with os.fdopen(os.open(self.tracker_file_name, (os.O_WRONLY | os.O_CREAT), 384), 'w') as f: DCNL DCSP  DCSP  DCSP f.write(self.tracker_uri) DCNL DCSP except IOError as e: DCNL DCSP  DCSP raise ResumableUploadException(("Couldn't DCSP write DCSP URI DCSP tracker DCSP file DCSP (%s): DCSP %s.\nThis DCSP can DCSP happenif DCSP you're DCSP using DCSP an DCSP incorrectly DCSP configured DCSP upload DCSP tool\n(e.g., DCSP gsutil DCSP configured DCSP to DCSP save DCSP tracker DCSP files DCSP to DCSP an DCSP unwritable DCSP directory)" % (self.tracker_file_name, e.strerror)), ResumableTransferDisposition.ABORT)
def _set_tracker_uri(self, uri): DCNL DCSP parse_result = urlparse.urlparse(uri) DCNL DCSP if ((parse_result.scheme.lower() not in ['http', 'https']) or (not parse_result.netloc)): DCNL DCSP  DCSP raise InvalidUriError(('Invalid DCSP tracker DCSP URI DCSP (%s)' % uri)) DCNL DCSP self.tracker_uri = uri DCNL DCSP self.tracker_uri_host = parse_result.netloc DCNL DCSP self.tracker_uri_path = ('%s?%s' % (parse_result.path, parse_result.query)) DCNL DCSP self.server_has_bytes = 0
def get_tracker_uri(self): DCNL DCSP return self.tracker_uri
def get_upload_id(self): DCNL DCSP delim = '?upload_id=' DCNL DCSP if (self.tracker_uri and (delim in self.tracker_uri)): DCNL DCSP  DCSP return self.tracker_uri[(self.tracker_uri.index(delim) + len(delim)):] DCNL DCSP else: DCNL DCSP  DCSP return None
def _query_server_state(self, conn, file_length): DCNL DCSP put_headers = {} DCNL DCSP put_headers['Content-Range'] = self._build_content_range_header('*', file_length) DCNL DCSP put_headers['Content-Length'] = '0' DCNL DCSP return AWSAuthConnection.make_request(conn, 'PUT', path=self.tracker_uri_path, auth_path=self.tracker_uri_path, headers=put_headers, host=self.tracker_uri_host)
def _query_server_pos(self, conn, file_length): DCNL DCSP resp = self._query_server_state(conn, file_length) DCNL DCSP if (resp.status == 200): DCNL DCSP  DCSP return (0, (file_length - 1)) DCNL DCSP if (resp.status != 308): DCNL DCSP  DCSP raise ResumableUploadException(('Got DCSP non-308 DCSP response DCSP (%s) DCSP from DCSP server DCSP state DCSP query' % resp.status), ResumableTransferDisposition.START_OVER) DCNL DCSP got_valid_response = False DCNL DCSP range_spec = resp.getheader('range') DCNL DCSP if range_spec: DCNL DCSP  DCSP m = re.search('bytes=(\\d+)-(\\d+)', range_spec) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP server_start = long(m.group(1)) DCNL DCSP  DCSP  DCSP server_end = long(m.group(2)) DCNL DCSP  DCSP  DCSP got_valid_response = True DCNL DCSP else: DCNL DCSP  DCSP return self.SERVER_HAS_NOTHING DCNL DCSP if (not got_valid_response): DCNL DCSP  DCSP raise ResumableUploadException(("Couldn't DCSP parse DCSP upload DCSP server DCSP state DCSP query DCSP response DCSP (%s)" % str(resp.getheaders())), ResumableTransferDisposition.START_OVER) DCNL DCSP if (conn.debug >= 1): DCNL DCSP  DCSP print ('Server DCSP has: DCSP Range: DCSP %d DCSP - DCSP %d.' % (server_start, server_end)) DCNL DCSP return (server_start, server_end)
def _start_new_resumable_upload(self, key, headers=None): DCNL DCSP conn = key.bucket.connection DCNL DCSP if (conn.debug >= 1): DCNL DCSP  DCSP print 'Starting DCSP new DCSP resumable DCSP upload.' DCNL DCSP self.server_has_bytes = 0 DCNL DCSP post_headers = {} DCNL DCSP for k in headers: DCNL DCSP  DCSP if (k.lower() == 'content-length'): DCNL DCSP  DCSP  DCSP raise ResumableUploadException('Attempt DCSP to DCSP specify DCSP Content-Length DCSP header DCSP (disallowed)', ResumableTransferDisposition.ABORT) DCNL DCSP  DCSP post_headers[k] = headers[k] DCNL DCSP post_headers[conn.provider.resumable_upload_header] = 'start' DCNL DCSP resp = conn.make_request('POST', key.bucket.name, key.name, post_headers) DCNL DCSP body = resp.read() DCNL DCSP if (resp.status in [500, 503]): DCNL DCSP  DCSP raise ResumableUploadException(('Got DCSP status DCSP %d DCSP from DCSP attempt DCSP to DCSP start DCSP resumable DCSP upload. DCSP Will DCSP wait/retry' % resp.status), ResumableTransferDisposition.WAIT_BEFORE_RETRY) DCNL DCSP elif ((resp.status != 200) and (resp.status != 201)): DCNL DCSP  DCSP raise ResumableUploadException(('Got DCSP status DCSP %d DCSP from DCSP attempt DCSP to DCSP start DCSP resumable DCSP upload. DCSP Aborting' % resp.status), ResumableTransferDisposition.ABORT) DCNL DCSP tracker_uri = resp.getheader('Location') DCNL DCSP if (not tracker_uri): DCNL DCSP  DCSP raise ResumableUploadException(('No DCSP resumable DCSP tracker DCSP URI DCSP found DCSP in DCSP resumable DCSP initiation DCSP POST DCSP response DCSP (%s)' % body), ResumableTransferDisposition.WAIT_BEFORE_RETRY) DCNL DCSP self._set_tracker_uri(tracker_uri) DCNL DCSP self._save_tracker_uri_to_file()
def _upload_file_bytes(self, conn, http_conn, fp, file_length, total_bytes_uploaded, cb, num_cb, headers): DCNL DCSP buf = fp.read(self.BUFFER_SIZE) DCNL DCSP if cb: DCNL DCSP  DCSP if (num_cb > 2): DCNL DCSP  DCSP  DCSP cb_count = ((file_length / self.BUFFER_SIZE) / (num_cb - 2)) DCNL DCSP  DCSP elif (num_cb < 0): DCNL DCSP  DCSP  DCSP cb_count = (-1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cb_count = 0 DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP cb(total_bytes_uploaded, file_length) DCNL DCSP if (not headers): DCNL DCSP  DCSP put_headers = {} DCNL DCSP else: DCNL DCSP  DCSP put_headers = headers.copy() DCNL DCSP if file_length: DCNL DCSP  DCSP if (total_bytes_uploaded == file_length): DCNL DCSP  DCSP  DCSP range_header = self._build_content_range_header('*', file_length) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP range_header = self._build_content_range_header(('%d-%d' % (total_bytes_uploaded, (file_length - 1))), file_length) DCNL DCSP  DCSP put_headers['Content-Range'] = range_header DCNL DCSP put_headers['Content-Length'] = str((file_length - total_bytes_uploaded)) DCNL DCSP http_request = AWSAuthConnection.build_base_http_request(conn, 'PUT', path=self.tracker_uri_path, auth_path=None, headers=put_headers, host=self.tracker_uri_host) DCNL DCSP http_conn.putrequest('PUT', http_request.path) DCNL DCSP for k in put_headers: DCNL DCSP  DCSP http_conn.putheader(k, put_headers[k]) DCNL DCSP http_conn.endheaders() DCNL DCSP http_conn.set_debuglevel(0) DCNL DCSP while buf: DCNL DCSP  DCSP http_conn.send(buf) DCNL DCSP  DCSP for alg in self.digesters: DCNL DCSP  DCSP  DCSP self.digesters[alg].update(buf) DCNL DCSP  DCSP total_bytes_uploaded += len(buf) DCNL DCSP  DCSP if cb: DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP if ((i == cb_count) or (cb_count == (-1))): DCNL DCSP  DCSP  DCSP  DCSP cb(total_bytes_uploaded, file_length) DCNL DCSP  DCSP  DCSP  DCSP i = 0 DCNL DCSP  DCSP buf = fp.read(self.BUFFER_SIZE) DCNL DCSP http_conn.set_debuglevel(conn.debug) DCNL DCSP if cb: DCNL DCSP  DCSP cb(total_bytes_uploaded, file_length) DCNL DCSP if (total_bytes_uploaded != file_length): DCNL DCSP  DCSP raise ResumableUploadException(('File DCSP changed DCSP during DCSP upload: DCSP EOF DCSP at DCSP %d DCSP bytes DCSP of DCSP %d DCSP byte DCSP file.' % (total_bytes_uploaded, file_length)), ResumableTransferDisposition.ABORT) DCNL DCSP resp = http_conn.getresponse() DCNL DCSP http_conn.set_debuglevel(conn.debug) DCNL DCSP if (resp.status == 200): DCNL DCSP  DCSP return (resp.getheader('etag'), resp.getheader('x-goog-generation'), resp.getheader('x-goog-metageneration')) DCNL DCSP elif (resp.status in [408, 500, 503]): DCNL DCSP  DCSP disposition = ResumableTransferDisposition.WAIT_BEFORE_RETRY DCNL DCSP else: DCNL DCSP  DCSP disposition = ResumableTransferDisposition.ABORT DCNL DCSP raise ResumableUploadException(('Got DCSP response DCSP code DCSP %d DCSP while DCSP attempting DCSP upload DCSP (%s)' % (resp.status, resp.reason)), disposition)
def _attempt_resumable_upload(self, key, fp, file_length, headers, cb, num_cb): DCNL DCSP (server_start, server_end) = self.SERVER_HAS_NOTHING DCNL DCSP conn = key.bucket.connection DCNL DCSP if self.tracker_uri: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (server_start, server_end) = self._query_server_pos(conn, file_length) DCNL DCSP  DCSP  DCSP self.server_has_bytes = server_start DCNL DCSP  DCSP  DCSP if server_end: DCNL DCSP  DCSP  DCSP  DCSP print 'Catching DCSP up DCSP hash DCSP digest(s) DCSP for DCSP resumed DCSP upload' DCNL DCSP  DCSP  DCSP  DCSP fp.seek(0) DCNL DCSP  DCSP  DCSP  DCSP bytes_to_go = (server_end + 1) DCNL DCSP  DCSP  DCSP  DCSP while bytes_to_go: DCNL DCSP  DCSP  DCSP  DCSP  DCSP chunk = fp.read(min(key.BufferSize, bytes_to_go)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not chunk): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ResumableUploadException('Hit DCSP end DCSP of DCSP file DCSP during DCSP resumable DCSP upload DCSP hash DCSP catchup. DCSP This DCSP should DCSP not DCSP happen DCSP under\nnormal DCSP circumstances, DCSP as DCSP it DCSP indicates DCSP the DCSP server DCSP has DCSP more DCSP bytes DCSP of DCSP this DCSP transfer\nthan DCSP the DCSP current DCSP file DCSP size. DCSP Restarting DCSP upload.', ResumableTransferDisposition.START_OVER) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for alg in self.digesters: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.digesters[alg].update(chunk) DCNL DCSP  DCSP  DCSP  DCSP  DCSP bytes_to_go -= len(chunk) DCNL DCSP  DCSP  DCSP if (conn.debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP print 'Resuming DCSP transfer.' DCNL DCSP  DCSP except ResumableUploadException as e: DCNL DCSP  DCSP  DCSP if (conn.debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP print ('Unable DCSP to DCSP resume DCSP transfer DCSP (%s).' % e.message) DCNL DCSP  DCSP  DCSP self._start_new_resumable_upload(key, headers) DCNL DCSP else: DCNL DCSP  DCSP self._start_new_resumable_upload(key, headers) DCNL DCSP if (self.upload_start_point is None): DCNL DCSP  DCSP self.upload_start_point = server_end DCNL DCSP total_bytes_uploaded = (server_end + 1) DCNL DCSP if (file_length < total_bytes_uploaded): DCNL DCSP  DCSP fp.seek(total_bytes_uploaded) DCNL DCSP conn = key.bucket.connection DCNL DCSP http_conn = conn.new_http_connection(self.tracker_uri_host, conn.port, conn.is_secure) DCNL DCSP http_conn.set_debuglevel(conn.debug) DCNL DCSP try: DCNL DCSP  DCSP return self._upload_file_bytes(conn, http_conn, fp, file_length, total_bytes_uploaded, cb, num_cb, headers) DCNL DCSP except (ResumableUploadException, socket.error): DCNL DCSP  DCSP resp = self._query_server_state(conn, file_length) DCNL DCSP  DCSP if (resp.status == 400): DCNL DCSP  DCSP  DCSP raise ResumableUploadException('Got DCSP 400 DCSP response DCSP from DCSP server DCSP state DCSP query DCSP after DCSP failed DCSP resumable DCSP upload DCSP attempt. DCSP This DCSP can DCSP happen DCSP for DCSP various DCSP reasons, DCSP including DCSP specifying DCSP an DCSP invalid DCSP request DCSP (e.g., DCSP an DCSP invalid DCSP canned DCSP ACL) DCSP or DCSP if DCSP the DCSP file DCSP size DCSP changed DCSP between DCSP upload DCSP attempts', ResumableTransferDisposition.ABORT) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP finally: DCNL DCSP  DCSP http_conn.close()
def _check_final_md5(self, key, etag): DCNL DCSP if (key.bucket.connection.debug >= 1): DCNL DCSP  DCSP print 'Checking DCSP md5 DCSP against DCSP etag.' DCNL DCSP if (key.md5 != etag.strip('"\'')): DCNL DCSP  DCSP key.open_read() DCNL DCSP  DCSP key.close() DCNL DCSP  DCSP key.delete() DCNL DCSP  DCSP raise ResumableUploadException("File DCSP changed DCSP during DCSP upload: DCSP md5 DCSP signature DCSP doesn't DCSP match DCSP etag DCSP (incorrect DCSP uploaded DCSP object DCSP deleted)", ResumableTransferDisposition.ABORT)
def send_file(self, key, fp, headers, cb=None, num_cb=10, hash_algs=None): DCNL DCSP if (not headers): DCNL DCSP  DCSP headers = {} DCNL DCSP CT = 'Content-Type' DCNL DCSP if ((CT in headers) and (headers[CT] is None)): DCNL DCSP  DCSP del headers[CT] DCNL DCSP headers['User-Agent'] = UserAgent DCNL DCSP if isinstance(fp, KeyFile): DCNL DCSP  DCSP file_length = fp.getkey().size DCNL DCSP else: DCNL DCSP  DCSP fp.seek(0, os.SEEK_END) DCNL DCSP  DCSP file_length = fp.tell() DCNL DCSP  DCSP fp.seek(0) DCNL DCSP debug = key.bucket.connection.debug DCNL DCSP if (hash_algs is None): DCNL DCSP  DCSP hash_algs = {'md5': md5} DCNL DCSP self.digesters = dict(((alg, hash_algs[alg]()) for alg in (hash_algs or {}))) DCNL DCSP if (self.num_retries is None): DCNL DCSP  DCSP self.num_retries = config.getint('Boto', 'num_retries', 6) DCNL DCSP self.progress_less_iterations = 0 DCNL DCSP while True: DCNL DCSP  DCSP server_had_bytes_before_attempt = self.server_has_bytes DCNL DCSP  DCSP self.digesters_before_attempt = dict(((alg, self.digesters[alg].copy()) for alg in self.digesters)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (etag, self.generation, self.metageneration) = self._attempt_resumable_upload(key, fp, file_length, headers, cb, num_cb) DCNL DCSP  DCSP  DCSP for alg in self.digesters: DCNL DCSP  DCSP  DCSP  DCSP key.local_hashes[alg] = self.digesters[alg].digest() DCNL DCSP  DCSP  DCSP self._remove_tracker_file() DCNL DCSP  DCSP  DCSP self._check_final_md5(key, etag) DCNL DCSP  DCSP  DCSP key.generation = self.generation DCNL DCSP  DCSP  DCSP if (debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP print 'Resumable DCSP upload DCSP complete.' DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except self.RETRYABLE_EXCEPTIONS as e: DCNL DCSP  DCSP  DCSP if (debug >= 1): DCNL DCSP  DCSP  DCSP  DCSP print ('Caught DCSP exception DCSP (%s)' % e.__repr__()) DCNL DCSP  DCSP  DCSP if (isinstance(e, IOError) and (e.errno == errno.EPIPE)): DCNL DCSP  DCSP  DCSP  DCSP key.bucket.connection.connection.close() DCNL DCSP  DCSP except ResumableUploadException as e: DCNL DCSP  DCSP  DCSP self.handle_resumable_upload_exception(e, debug) DCNL DCSP  DCSP self.track_progress_less_iterations(server_had_bytes_before_attempt, True, debug)
def create_bucket(self, bucket_name, headers=None, location=Location.DEFAULT, policy=None, storage_class='STANDARD'): DCNL DCSP check_lowercase_bucketname(bucket_name) DCNL DCSP if policy: DCNL DCSP  DCSP if headers: DCNL DCSP  DCSP  DCSP headers[self.provider.acl_header] = policy DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP headers = {self.provider.acl_header: policy} DCNL DCSP if (not location): DCNL DCSP  DCSP location = Location.DEFAULT DCNL DCSP location_elem = ('<LocationConstraint>%s</LocationConstraint>' % location) DCNL DCSP if storage_class: DCNL DCSP  DCSP storage_class_elem = ('<StorageClass>%s</StorageClass>' % storage_class) DCNL DCSP else: DCNL DCSP  DCSP storage_class_elem = '' DCNL DCSP data = ('<CreateBucketConfiguration>%s%s</CreateBucketConfiguration>' % (location_elem, storage_class_elem)) DCNL DCSP response = self.make_request('PUT', get_utf8_value(bucket_name), headers=headers, data=get_utf8_value(data)) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 409): DCNL DCSP  DCSP raise self.provider.storage_create_error(response.status, response.reason, body) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP return self.bucket_class(self, bucket_name) DCNL DCSP else: DCNL DCSP  DCSP raise self.provider.storage_response_error(response.status, response.reason, body)
def get_bucket(self, bucket_name, validate=True, headers=None): DCNL DCSP bucket = self.bucket_class(self, bucket_name) DCNL DCSP if validate: DCNL DCSP  DCSP bucket.get_all_keys(headers, maxkeys=0) DCNL DCSP return bucket
def open_read(self, headers=None, query_args='', override_num_retries=None, response_headers=None): DCNL DCSP if self.generation: DCNL DCSP  DCSP if query_args: DCNL DCSP  DCSP  DCSP query_args += '&' DCNL DCSP  DCSP query_args += ('generation=%s' % self.generation) DCNL DCSP super(Key, self).open_read(headers=headers, query_args=query_args, override_num_retries=override_num_retries, response_headers=response_headers)
def get_contents_to_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, res_download_handler=None, response_headers=None, hash_algs=None): DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP if res_download_handler: DCNL DCSP  DCSP  DCSP res_download_handler.get_file(self, fp, headers, cb, num_cb, torrent=torrent, version_id=version_id, hash_algs=hash_algs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.get_file(fp, headers, cb, num_cb, torrent=torrent, version_id=version_id, response_headers=response_headers, hash_algs=hash_algs)
def compute_hash(self, fp, algorithm, size=None): DCNL DCSP (hex_digest, b64_digest, data_size) = compute_hash(fp, size=size, hash_algorithm=algorithm) DCNL DCSP self.size = data_size DCNL DCSP return (hex_digest, b64_digest)
def send_file(self, fp, headers=None, cb=None, num_cb=10, query_args=None, chunked_transfer=False, size=None, hash_algs=None): DCNL DCSP self._send_file_internal(fp, headers=headers, cb=cb, num_cb=num_cb, query_args=query_args, chunked_transfer=chunked_transfer, size=size, hash_algs=hash_algs)
def add_email_grant(self, permission, email_address): DCNL DCSP acl = self.get_acl() DCNL DCSP acl.add_email_grant(permission, email_address) DCNL DCSP self.set_acl(acl)
def add_user_grant(self, permission, user_id): DCNL DCSP acl = self.get_acl() DCNL DCSP acl.add_user_grant(permission, user_id) DCNL DCSP self.set_acl(acl)
def add_group_email_grant(self, permission, email_address, headers=None): DCNL DCSP acl = self.get_acl(headers=headers) DCNL DCSP acl.add_group_email_grant(permission, email_address) DCNL DCSP self.set_acl(acl, headers=headers)
def add_group_grant(self, permission, group_id): DCNL DCSP acl = self.get_acl() DCNL DCSP acl.add_group_grant(permission, group_id) DCNL DCSP self.set_acl(acl)
def set_contents_from_file(self, fp, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, res_upload_handler=None, size=None, rewind=False, if_generation=None): DCNL DCSP provider = self.bucket.connection.provider DCNL DCSP if (res_upload_handler and size): DCNL DCSP  DCSP raise BotoClientError('"size" DCSP param DCSP not DCSP supported DCSP for DCSP resumable DCSP uploads.') DCNL DCSP headers = (headers or {}) DCNL DCSP if policy: DCNL DCSP  DCSP headers[provider.acl_header] = policy DCNL DCSP if rewind: DCNL DCSP  DCSP fp.seek(0, os.SEEK_SET) DCNL DCSP elif (not isinstance(fp, KeyFile)): DCNL DCSP  DCSP spos = fp.tell() DCNL DCSP  DCSP fp.seek(0, os.SEEK_END) DCNL DCSP  DCSP if (fp.tell() == spos): DCNL DCSP  DCSP  DCSP fp.seek(0, os.SEEK_SET) DCNL DCSP  DCSP  DCSP if (fp.tell() != spos): DCNL DCSP  DCSP  DCSP  DCSP fp.seek(spos) DCNL DCSP  DCSP  DCSP  DCSP raise AttributeError('fp DCSP is DCSP at DCSP EOF. DCSP Use DCSP rewind DCSP option DCSP or DCSP seek() DCSP to DCSP data DCSP start.') DCNL DCSP  DCSP fp.seek(spos) DCNL DCSP if hasattr(fp, 'name'): DCNL DCSP  DCSP self.path = fp.name DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP if isinstance(fp, KeyFile): DCNL DCSP  DCSP  DCSP key = fp.getkey() DCNL DCSP  DCSP  DCSP size = (key.size - fp.tell()) DCNL DCSP  DCSP  DCSP self.size = size DCNL DCSP  DCSP  DCSP if re.match('^"[a-fA-F0-9]{32}"$', key.etag): DCNL DCSP  DCSP  DCSP  DCSP etag = key.etag.strip('"') DCNL DCSP  DCSP  DCSP  DCSP md5 = (etag, base64.b64encode(binascii.unhexlify(etag))) DCNL DCSP  DCSP if size: DCNL DCSP  DCSP  DCSP self.size = size DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP spos = fp.tell() DCNL DCSP  DCSP  DCSP fp.seek(0, os.SEEK_END) DCNL DCSP  DCSP  DCSP self.size = (fp.tell() - spos) DCNL DCSP  DCSP  DCSP fp.seek(spos) DCNL DCSP  DCSP  DCSP size = self.size DCNL DCSP  DCSP if (md5 is None): DCNL DCSP  DCSP  DCSP md5 = self.compute_md5(fp, size) DCNL DCSP  DCSP self.md5 = md5[0] DCNL DCSP  DCSP self.base64md5 = md5[1] DCNL DCSP  DCSP if (self.name is None): DCNL DCSP  DCSP  DCSP self.name = self.md5 DCNL DCSP  DCSP if (not replace): DCNL DCSP  DCSP  DCSP if self.bucket.lookup(self.name): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (if_generation is not None): DCNL DCSP  DCSP  DCSP headers['x-goog-if-generation-match'] = str(if_generation) DCNL DCSP  DCSP if res_upload_handler: DCNL DCSP  DCSP  DCSP res_upload_handler.send_file(self, fp, headers, cb, num_cb) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.send_file(fp, headers, cb, num_cb, size=size)
def set_contents_from_filename(self, filename, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, reduced_redundancy=None, res_upload_handler=None, if_generation=None): DCNL DCSP self.local_hashes = {} DCNL DCSP with open(filename, 'rb') as fp: DCNL DCSP  DCSP self.set_contents_from_file(fp, headers, replace, cb, num_cb, policy, md5, res_upload_handler, if_generation=if_generation)
def set_contents_from_string(self, s, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, if_generation=None): DCNL DCSP self.md5 = None DCNL DCSP self.base64md5 = None DCNL DCSP fp = StringIO(get_utf8_value(s)) DCNL DCSP r = self.set_contents_from_file(fp, headers, replace, cb, num_cb, policy, md5, if_generation=if_generation) DCNL DCSP fp.close() DCNL DCSP return r
def set_contents_from_stream(self, *args, **kwargs): DCNL DCSP if_generation = kwargs.pop('if_generation', None) DCNL DCSP if (if_generation is not None): DCNL DCSP  DCSP headers = kwargs.get('headers', {}) DCNL DCSP  DCSP headers['x-goog-if-generation-match'] = str(if_generation) DCNL DCSP  DCSP kwargs['headers'] = headers DCNL DCSP super(Key, self).set_contents_from_stream(*args, **kwargs)
def set_acl(self, acl_or_str, headers=None, generation=None, if_generation=None, if_metageneration=None): DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP self.bucket.set_acl(acl_or_str, self.name, headers=headers, generation=generation, if_generation=if_generation, if_metageneration=if_metageneration)
def get_acl(self, headers=None, generation=None): DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP return self.bucket.get_acl(self.name, headers=headers, generation=generation)
def get_xml_acl(self, headers=None, generation=None): DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP return self.bucket.get_xml_acl(self.name, headers=headers, generation=generation)
def set_xml_acl(self, acl_str, headers=None, generation=None, if_generation=None, if_metageneration=None): DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP return self.bucket.set_xml_acl(acl_str, self.name, headers=headers, generation=generation, if_generation=if_generation, if_metageneration=if_metageneration)
def set_canned_acl(self, acl_str, headers=None, generation=None, if_generation=None, if_metageneration=None): DCNL DCSP if (self.bucket is not None): DCNL DCSP  DCSP return self.bucket.set_canned_acl(acl_str, self.name, headers=headers, generation=generation, if_generation=if_generation, if_metageneration=if_metageneration)
def compose(self, components, content_type=None, headers=None): DCNL DCSP compose_req = [] DCNL DCSP for key in components: DCNL DCSP  DCSP if (key.bucket.name != self.bucket.name): DCNL DCSP  DCSP  DCSP raise BotoClientError('GCS DCSP does DCSP not DCSP support DCSP inter-bucket DCSP composing') DCNL DCSP  DCSP generation_tag = '' DCNL DCSP  DCSP if key.generation: DCNL DCSP  DCSP  DCSP generation_tag = ('<Generation>%s</Generation>' % str(key.generation)) DCNL DCSP  DCSP compose_req.append(('<Component><Name>%s</Name>%s</Component>' % (key.name, generation_tag))) DCNL DCSP compose_req_xml = ('<ComposeRequest>%s</ComposeRequest>' % ''.join(compose_req)) DCNL DCSP headers = (headers or {}) DCNL DCSP if content_type: DCNL DCSP  DCSP headers['Content-Type'] = content_type DCNL DCSP resp = self.bucket.connection.make_request('PUT', get_utf8_value(self.bucket.name), get_utf8_value(self.name), headers=headers, query_args='compose', data=get_utf8_value(compose_req_xml)) DCNL DCSP if ((resp.status < 200) or (resp.status > 299)): DCNL DCSP  DCSP raise self.bucket.connection.provider.storage_response_error(resp.status, resp.reason, resp.read()) DCNL DCSP return resp.getheader('x-goog-generation')
def validateParseLevel(self, tag, level): DCNL DCSP if (self.parse_level != level): DCNL DCSP  DCSP raise InvalidCorsError(('Invalid DCSP tag DCSP %s DCSP at DCSP parse DCSP level DCSP %d: DCSP ' % (tag, self.parse_level)))
def startElement(self, name, attrs, connection): DCNL DCSP if (name == CORS_CONFIG): DCNL DCSP  DCSP self.validateParseLevel(name, 0) DCNL DCSP  DCSP self.parse_level += 1 DCNL DCSP elif (name == CORS): DCNL DCSP  DCSP self.validateParseLevel(name, 1) DCNL DCSP  DCSP self.parse_level += 1 DCNL DCSP elif (name in self.legal_collections): DCNL DCSP  DCSP self.validateParseLevel(name, 2) DCNL DCSP  DCSP self.parse_level += 1 DCNL DCSP  DCSP self.collection = name DCNL DCSP elif (name in self.legal_elements): DCNL DCSP  DCSP self.validateParseLevel(name, 3) DCNL DCSP  DCSP if (self.collection is None): DCNL DCSP  DCSP  DCSP raise InvalidCorsError(('Tag DCSP %s DCSP found DCSP outside DCSP collection' % name)) DCNL DCSP  DCSP if (name not in self.legal_collections[self.collection]): DCNL DCSP  DCSP  DCSP raise InvalidCorsError(('Tag DCSP %s DCSP not DCSP allowed DCSP in DCSP %s DCSP collection' % (name, self.collection))) DCNL DCSP  DCSP self.element = name DCNL DCSP else: DCNL DCSP  DCSP raise InvalidCorsError(('Unsupported DCSP tag DCSP ' + name))
def endElement(self, name, value, connection): DCNL DCSP if (name == CORS_CONFIG): DCNL DCSP  DCSP self.validateParseLevel(name, 1) DCNL DCSP  DCSP self.parse_level -= 1 DCNL DCSP elif (name == CORS): DCNL DCSP  DCSP self.validateParseLevel(name, 2) DCNL DCSP  DCSP self.parse_level -= 1 DCNL DCSP  DCSP self.cors.append(self.collections) DCNL DCSP  DCSP self.collections = [] DCNL DCSP elif (name in self.legal_collections): DCNL DCSP  DCSP self.validateParseLevel(name, 3) DCNL DCSP  DCSP if (name != self.collection): DCNL DCSP  DCSP  DCSP raise InvalidCorsError(('Mismatched DCSP start DCSP and DCSP end DCSP tags DCSP (%s/%s)' % (self.collection, name))) DCNL DCSP  DCSP self.parse_level -= 1 DCNL DCSP  DCSP if (not self.legal_collections[name]): DCNL DCSP  DCSP  DCSP self.collections.append((name, value.strip())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.collections.append((name, self.elements)) DCNL DCSP  DCSP self.elements = [] DCNL DCSP  DCSP self.collection = None DCNL DCSP elif (name in self.legal_elements): DCNL DCSP  DCSP self.validateParseLevel(name, 3) DCNL DCSP  DCSP if (self.collection is None): DCNL DCSP  DCSP  DCSP raise InvalidCorsError(('Tag DCSP %s DCSP found DCSP outside DCSP collection' % name)) DCNL DCSP  DCSP if (name not in self.legal_collections[self.collection]): DCNL DCSP  DCSP  DCSP raise InvalidCorsError(('Tag DCSP %s DCSP not DCSP allowed DCSP in DCSP %s DCSP collection' % (name, self.collection))) DCNL DCSP  DCSP if (name != self.element): DCNL DCSP  DCSP  DCSP raise InvalidCorsError(('Mismatched DCSP start DCSP and DCSP end DCSP tags DCSP (%s/%s)' % (self.element, name))) DCNL DCSP  DCSP self.elements.append((name, value.strip())) DCNL DCSP  DCSP self.element = None DCNL DCSP else: DCNL DCSP  DCSP raise InvalidCorsError(('Unsupported DCSP end DCSP tag DCSP ' + name))
def to_xml(self): DCNL DCSP s = (('<' + CORS_CONFIG) + '>') DCNL DCSP for collections in self.cors: DCNL DCSP  DCSP s += (('<' + CORS) + '>') DCNL DCSP  DCSP for (collection, elements_or_value) in collections: DCNL DCSP  DCSP  DCSP assert (collection is not None) DCNL DCSP  DCSP  DCSP s += (('<' + collection) + '>') DCNL DCSP  DCSP  DCSP if isinstance(elements_or_value, str): DCNL DCSP  DCSP  DCSP  DCSP s += elements_or_value DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for (name, value) in elements_or_value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (name is not None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (value is not None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP s += (((((('<' + name) + '>') + value) + '</') + name) + '>') DCNL DCSP  DCSP  DCSP s += (('</' + collection) + '>') DCNL DCSP  DCSP s += (('</' + CORS) + '>') DCNL DCSP s += (('</' + CORS_CONFIG) + '>') DCNL DCSP return s
def allocate_connection_on_interconnect(self, bandwidth, connection_name, owner_account, interconnect_id, vlan): DCNL DCSP params = {'bandwidth': bandwidth, 'connectionName': connection_name, 'ownerAccount': owner_account, 'interconnectId': interconnect_id, 'vlan': vlan} DCNL DCSP return self.make_request(action='AllocateConnectionOnInterconnect', body=json.dumps(params))
def allocate_private_virtual_interface(self, connection_id, owner_account, new_private_virtual_interface_allocation): DCNL DCSP params = {'connectionId': connection_id, 'ownerAccount': owner_account, 'newPrivateVirtualInterfaceAllocation': new_private_virtual_interface_allocation} DCNL DCSP return self.make_request(action='AllocatePrivateVirtualInterface', body=json.dumps(params))
def allocate_public_virtual_interface(self, connection_id, owner_account, new_public_virtual_interface_allocation): DCNL DCSP params = {'connectionId': connection_id, 'ownerAccount': owner_account, 'newPublicVirtualInterfaceAllocation': new_public_virtual_interface_allocation} DCNL DCSP return self.make_request(action='AllocatePublicVirtualInterface', body=json.dumps(params))
def confirm_connection(self, connection_id): DCNL DCSP params = {'connectionId': connection_id} DCNL DCSP return self.make_request(action='ConfirmConnection', body=json.dumps(params))
def confirm_private_virtual_interface(self, virtual_interface_id, virtual_gateway_id): DCNL DCSP params = {'virtualInterfaceId': virtual_interface_id, 'virtualGatewayId': virtual_gateway_id} DCNL DCSP return self.make_request(action='ConfirmPrivateVirtualInterface', body=json.dumps(params))
def confirm_public_virtual_interface(self, virtual_interface_id): DCNL DCSP params = {'virtualInterfaceId': virtual_interface_id} DCNL DCSP return self.make_request(action='ConfirmPublicVirtualInterface', body=json.dumps(params))
def create_connection(self, location, bandwidth, connection_name): DCNL DCSP params = {'location': location, 'bandwidth': bandwidth, 'connectionName': connection_name} DCNL DCSP return self.make_request(action='CreateConnection', body=json.dumps(params))
def create_interconnect(self, interconnect_name, bandwidth, location): DCNL DCSP params = {'interconnectName': interconnect_name, 'bandwidth': bandwidth, 'location': location} DCNL DCSP return self.make_request(action='CreateInterconnect', body=json.dumps(params))
def create_private_virtual_interface(self, connection_id, new_private_virtual_interface): DCNL DCSP params = {'connectionId': connection_id, 'newPrivateVirtualInterface': new_private_virtual_interface} DCNL DCSP return self.make_request(action='CreatePrivateVirtualInterface', body=json.dumps(params))
def create_public_virtual_interface(self, connection_id, new_public_virtual_interface): DCNL DCSP params = {'connectionId': connection_id, 'newPublicVirtualInterface': new_public_virtual_interface} DCNL DCSP return self.make_request(action='CreatePublicVirtualInterface', body=json.dumps(params))
def delete_connection(self, connection_id): DCNL DCSP params = {'connectionId': connection_id} DCNL DCSP return self.make_request(action='DeleteConnection', body=json.dumps(params))
def delete_interconnect(self, interconnect_id): DCNL DCSP params = {'interconnectId': interconnect_id} DCNL DCSP return self.make_request(action='DeleteInterconnect', body=json.dumps(params))
def delete_virtual_interface(self, virtual_interface_id): DCNL DCSP params = {'virtualInterfaceId': virtual_interface_id} DCNL DCSP return self.make_request(action='DeleteVirtualInterface', body=json.dumps(params))
def describe_connections(self, connection_id=None): DCNL DCSP params = {} DCNL DCSP if (connection_id is not None): DCNL DCSP  DCSP params['connectionId'] = connection_id DCNL DCSP return self.make_request(action='DescribeConnections', body=json.dumps(params))
def describe_connections_on_interconnect(self, interconnect_id): DCNL DCSP params = {'interconnectId': interconnect_id} DCNL DCSP return self.make_request(action='DescribeConnectionsOnInterconnect', body=json.dumps(params))
def describe_interconnects(self, interconnect_id=None): DCNL DCSP params = {} DCNL DCSP if (interconnect_id is not None): DCNL DCSP  DCSP params['interconnectId'] = interconnect_id DCNL DCSP return self.make_request(action='DescribeInterconnects', body=json.dumps(params))
def describe_locations(self): DCNL DCSP params = {} DCNL DCSP return self.make_request(action='DescribeLocations', body=json.dumps(params))
def describe_virtual_gateways(self): DCNL DCSP params = {} DCNL DCSP return self.make_request(action='DescribeVirtualGateways', body=json.dumps(params))
def describe_virtual_interfaces(self, connection_id=None, virtual_interface_id=None): DCNL DCSP params = {} DCNL DCSP if (connection_id is not None): DCNL DCSP  DCSP params['connectionId'] = connection_id DCNL DCSP if (virtual_interface_id is not None): DCNL DCSP  DCSP params['virtualInterfaceId'] = virtual_interface_id DCNL DCSP return self.make_request(action='DescribeVirtualInterfaces', body=json.dumps(params))
def __init__(self, table_name, schema=None, throughput=None, indexes=None, global_indexes=None, connection=None): DCNL DCSP self.table_name = table_name DCNL DCSP self.connection = connection DCNL DCSP self.throughput = {'read': 5, 'write': 5} DCNL DCSP self.schema = schema DCNL DCSP self.indexes = indexes DCNL DCSP self.global_indexes = global_indexes DCNL DCSP if (self.connection is None): DCNL DCSP  DCSP self.connection = DynamoDBConnection() DCNL DCSP if (throughput is not None): DCNL DCSP  DCSP self.throughput = throughput DCNL DCSP self._dynamizer = NonBooleanDynamizer()
@classmethod DCNL def create(cls, table_name, schema, throughput=None, indexes=None, global_indexes=None, connection=None): DCNL DCSP table = cls(table_name=table_name, connection=connection) DCNL DCSP table.schema = schema DCNL DCSP if (throughput is not None): DCNL DCSP  DCSP table.throughput = throughput DCNL DCSP if (indexes is not None): DCNL DCSP  DCSP table.indexes = indexes DCNL DCSP if (global_indexes is not None): DCNL DCSP  DCSP table.global_indexes = global_indexes DCNL DCSP raw_schema = [] DCNL DCSP attr_defs = [] DCNL DCSP seen_attrs = set() DCNL DCSP for field in table.schema: DCNL DCSP  DCSP raw_schema.append(field.schema()) DCNL DCSP  DCSP seen_attrs.add(field.name) DCNL DCSP  DCSP attr_defs.append(field.definition()) DCNL DCSP raw_throughput = {'ReadCapacityUnits': int(table.throughput['read']), 'WriteCapacityUnits': int(table.throughput['write'])} DCNL DCSP kwargs = {} DCNL DCSP kwarg_map = {'indexes': 'local_secondary_indexes', 'global_indexes': 'global_secondary_indexes'} DCNL DCSP for index_attr in ('indexes', 'global_indexes'): DCNL DCSP  DCSP table_indexes = getattr(table, index_attr) DCNL DCSP  DCSP if table_indexes: DCNL DCSP  DCSP  DCSP raw_indexes = [] DCNL DCSP  DCSP  DCSP for index_field in table_indexes: DCNL DCSP  DCSP  DCSP  DCSP raw_indexes.append(index_field.schema()) DCNL DCSP  DCSP  DCSP  DCSP for field in index_field.parts: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (field.name not in seen_attrs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_attrs.add(field.name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP attr_defs.append(field.definition()) DCNL DCSP  DCSP  DCSP kwargs[kwarg_map[index_attr]] = raw_indexes DCNL DCSP table.connection.create_table(table_name=table.table_name, attribute_definitions=attr_defs, key_schema=raw_schema, provisioned_throughput=raw_throughput, **kwargs) DCNL DCSP return table
def _introspect_schema(self, raw_schema, raw_attributes=None): DCNL DCSP schema = [] DCNL DCSP sane_attributes = {} DCNL DCSP if raw_attributes: DCNL DCSP  DCSP for field in raw_attributes: DCNL DCSP  DCSP  DCSP sane_attributes[field['AttributeName']] = field['AttributeType'] DCNL DCSP for field in raw_schema: DCNL DCSP  DCSP data_type = sane_attributes.get(field['AttributeName'], STRING) DCNL DCSP  DCSP if (field['KeyType'] == 'HASH'): DCNL DCSP  DCSP  DCSP schema.append(HashKey(field['AttributeName'], data_type=data_type)) DCNL DCSP  DCSP elif (field['KeyType'] == 'RANGE'): DCNL DCSP  DCSP  DCSP schema.append(RangeKey(field['AttributeName'], data_type=data_type)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise exceptions.UnknownSchemaFieldError(('%s DCSP was DCSP seen, DCSP but DCSP is DCSP unknown. DCSP Please DCSP report DCSP this DCSP at DCSP https://github.com/boto/boto/issues.' % field['KeyType'])) DCNL DCSP return schema
def _introspect_all_indexes(self, raw_indexes, map_indexes_projection): DCNL DCSP indexes = [] DCNL DCSP for field in raw_indexes: DCNL DCSP  DCSP index_klass = map_indexes_projection.get('ALL') DCNL DCSP  DCSP kwargs = {'parts': []} DCNL DCSP  DCSP if (field['Projection']['ProjectionType'] == 'ALL'): DCNL DCSP  DCSP  DCSP index_klass = map_indexes_projection.get('ALL') DCNL DCSP  DCSP elif (field['Projection']['ProjectionType'] == 'KEYS_ONLY'): DCNL DCSP  DCSP  DCSP index_klass = map_indexes_projection.get('KEYS_ONLY') DCNL DCSP  DCSP elif (field['Projection']['ProjectionType'] == 'INCLUDE'): DCNL DCSP  DCSP  DCSP index_klass = map_indexes_projection.get('INCLUDE') DCNL DCSP  DCSP  DCSP kwargs['includes'] = field['Projection']['NonKeyAttributes'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise exceptions.UnknownIndexFieldError(('%s DCSP was DCSP seen, DCSP but DCSP is DCSP unknown. DCSP Please DCSP report DCSP this DCSP at DCSP https://github.com/boto/boto/issues.' % field['Projection']['ProjectionType'])) DCNL DCSP  DCSP name = field['IndexName'] DCNL DCSP  DCSP kwargs['parts'] = self._introspect_schema(field['KeySchema'], None) DCNL DCSP  DCSP indexes.append(index_klass(name, **kwargs)) DCNL DCSP return indexes
def _introspect_indexes(self, raw_indexes): DCNL DCSP return self._introspect_all_indexes(raw_indexes, self._PROJECTION_TYPE_TO_INDEX.get('local_indexes'))
def _introspect_global_indexes(self, raw_global_indexes): DCNL DCSP return self._introspect_all_indexes(raw_global_indexes, self._PROJECTION_TYPE_TO_INDEX.get('global_indexes'))
def describe(self): DCNL DCSP result = self.connection.describe_table(self.table_name) DCNL DCSP raw_throughput = result['Table']['ProvisionedThroughput'] DCNL DCSP self.throughput['read'] = int(raw_throughput['ReadCapacityUnits']) DCNL DCSP self.throughput['write'] = int(raw_throughput['WriteCapacityUnits']) DCNL DCSP if (not self.schema): DCNL DCSP  DCSP raw_schema = result['Table'].get('KeySchema', []) DCNL DCSP  DCSP raw_attributes = result['Table'].get('AttributeDefinitions', []) DCNL DCSP  DCSP self.schema = self._introspect_schema(raw_schema, raw_attributes) DCNL DCSP if (not self.indexes): DCNL DCSP  DCSP raw_indexes = result['Table'].get('LocalSecondaryIndexes', []) DCNL DCSP  DCSP self.indexes = self._introspect_indexes(raw_indexes) DCNL DCSP raw_global_indexes = result['Table'].get('GlobalSecondaryIndexes', []) DCNL DCSP self.global_indexes = self._introspect_global_indexes(raw_global_indexes) DCNL DCSP return result
def update(self, throughput=None, global_indexes=None): DCNL DCSP data = None DCNL DCSP if throughput: DCNL DCSP  DCSP self.throughput = throughput DCNL DCSP  DCSP data = {'ReadCapacityUnits': int(self.throughput['read']), 'WriteCapacityUnits': int(self.throughput['write'])} DCNL DCSP gsi_data = None DCNL DCSP if global_indexes: DCNL DCSP  DCSP gsi_data = [] DCNL DCSP  DCSP for (gsi_name, gsi_throughput) in global_indexes.items(): DCNL DCSP  DCSP  DCSP gsi_data.append({'Update': {'IndexName': gsi_name, 'ProvisionedThroughput': {'ReadCapacityUnits': int(gsi_throughput['read']), 'WriteCapacityUnits': int(gsi_throughput['write'])}}}) DCNL DCSP if (throughput or global_indexes): DCNL DCSP  DCSP self.connection.update_table(self.table_name, provisioned_throughput=data, global_secondary_index_updates=gsi_data) DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP msg = 'You DCSP need DCSP to DCSP provide DCSP either DCSP the DCSP throughput DCSP or DCSP the DCSP global_indexes DCSP to DCSP update DCSP method' DCNL DCSP  DCSP boto.log.error(msg) DCNL DCSP  DCSP return False
def create_global_secondary_index(self, global_index): DCNL DCSP if global_index: DCNL DCSP  DCSP gsi_data = [] DCNL DCSP  DCSP gsi_data_attr_def = [] DCNL DCSP  DCSP gsi_data.append({'Create': global_index.schema()}) DCNL DCSP  DCSP for attr_def in global_index.parts: DCNL DCSP  DCSP  DCSP gsi_data_attr_def.append(attr_def.definition()) DCNL DCSP  DCSP self.connection.update_table(self.table_name, global_secondary_index_updates=gsi_data, attribute_definitions=gsi_data_attr_def) DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP msg = 'You DCSP need DCSP to DCSP provide DCSP the DCSP global_index DCSP to DCSP create_global_secondary_index DCSP method' DCNL DCSP  DCSP boto.log.error(msg) DCNL DCSP  DCSP return False
def delete_global_secondary_index(self, global_index_name): DCNL DCSP if global_index_name: DCNL DCSP  DCSP gsi_data = [{'Delete': {'IndexName': global_index_name}}] DCNL DCSP  DCSP self.connection.update_table(self.table_name, global_secondary_index_updates=gsi_data) DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP msg = 'You DCSP need DCSP to DCSP provide DCSP the DCSP global DCSP index DCSP name DCSP to DCSP delete_global_secondary_index DCSP method' DCNL DCSP  DCSP boto.log.error(msg) DCNL DCSP  DCSP return False
def update_global_secondary_index(self, global_indexes): DCNL DCSP if global_indexes: DCNL DCSP  DCSP gsi_data = [] DCNL DCSP  DCSP for (gsi_name, gsi_throughput) in global_indexes.items(): DCNL DCSP  DCSP  DCSP gsi_data.append({'Update': {'IndexName': gsi_name, 'ProvisionedThroughput': {'ReadCapacityUnits': int(gsi_throughput['read']), 'WriteCapacityUnits': int(gsi_throughput['write'])}}}) DCNL DCSP  DCSP self.connection.update_table(self.table_name, global_secondary_index_updates=gsi_data) DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP msg = 'You DCSP need DCSP to DCSP provide DCSP the DCSP global DCSP indexes DCSP to DCSP update_global_secondary_index DCSP method' DCNL DCSP  DCSP boto.log.error(msg) DCNL DCSP  DCSP return False
def delete(self): DCNL DCSP self.connection.delete_table(self.table_name) DCNL DCSP return True
def _encode_keys(self, keys): DCNL DCSP raw_key = {} DCNL DCSP for (key, value) in keys.items(): DCNL DCSP  DCSP raw_key[key] = self._dynamizer.encode(value) DCNL DCSP return raw_key
def get_item(self, consistent=False, attributes=None, **kwargs): DCNL DCSP raw_key = self._encode_keys(kwargs) DCNL DCSP item_data = self.connection.get_item(self.table_name, raw_key, attributes_to_get=attributes, consistent_read=consistent) DCNL DCSP if ('Item' not in item_data): DCNL DCSP  DCSP raise exceptions.ItemNotFound(("Item DCSP %s DCSP couldn't DCSP be DCSP found." % kwargs)) DCNL DCSP item = Item(self) DCNL DCSP item.load(item_data) DCNL DCSP return item
def has_item(self, **kwargs): DCNL DCSP try: DCNL DCSP  DCSP self.get_item(**kwargs) DCNL DCSP except (JSONResponseError, exceptions.ItemNotFound): DCNL DCSP  DCSP return False DCNL DCSP return True
def lookup(self, *args, **kwargs): DCNL DCSP if (not self.schema): DCNL DCSP  DCSP self.describe() DCNL DCSP for (x, arg) in enumerate(args): DCNL DCSP  DCSP kwargs[self.schema[x].name] = arg DCNL DCSP ret = self.get_item(**kwargs) DCNL DCSP if (not ret.keys()): DCNL DCSP  DCSP return None DCNL DCSP return ret
def new_item(self, *args): DCNL DCSP if (not self.schema): DCNL DCSP  DCSP self.describe() DCNL DCSP data = {} DCNL DCSP for (x, arg) in enumerate(args): DCNL DCSP  DCSP data[self.schema[x].name] = arg DCNL DCSP return Item(self, data=data)
def put_item(self, data, overwrite=False): DCNL DCSP item = Item(self, data=data) DCNL DCSP return item.save(overwrite=overwrite)
def _put_item(self, item_data, expects=None): DCNL DCSP kwargs = {} DCNL DCSP if (expects is not None): DCNL DCSP  DCSP kwargs['expected'] = expects DCNL DCSP self.connection.put_item(self.table_name, item_data, **kwargs) DCNL DCSP return True
def _update_item(self, key, item_data, expects=None): DCNL DCSP raw_key = self._encode_keys(key) DCNL DCSP kwargs = {} DCNL DCSP if (expects is not None): DCNL DCSP  DCSP kwargs['expected'] = expects DCNL DCSP self.connection.update_item(self.table_name, raw_key, item_data, **kwargs) DCNL DCSP return True
def delete_item(self, expected=None, conditional_operator=None, **kwargs): DCNL DCSP expected = self._build_filters(expected, using=FILTER_OPERATORS) DCNL DCSP raw_key = self._encode_keys(kwargs) DCNL DCSP try: DCNL DCSP  DCSP self.connection.delete_item(self.table_name, raw_key, expected=expected, conditional_operator=conditional_operator) DCNL DCSP except exceptions.ConditionalCheckFailedException: DCNL DCSP  DCSP return False DCNL DCSP return True
def get_key_fields(self): DCNL DCSP if (not self.schema): DCNL DCSP  DCSP self.describe() DCNL DCSP return [field.name for field in self.schema]
def batch_write(self): DCNL DCSP return BatchTable(self)
def _build_filters(self, filter_kwargs, using=QUERY_OPERATORS): DCNL DCSP if (filter_kwargs is None): DCNL DCSP  DCSP return DCNL DCSP filters = {} DCNL DCSP for (field_and_op, value) in filter_kwargs.items(): DCNL DCSP  DCSP field_bits = field_and_op.split('__') DCNL DCSP  DCSP fieldname = '__'.join(field_bits[:(-1)]) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP op = using[field_bits[(-1)]] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise exceptions.UnknownFilterTypeError(("Operator DCSP '%s' DCSP from DCSP '%s' DCSP is DCSP not DCSP recognized." % (field_bits[(-1)], field_and_op))) DCNL DCSP  DCSP lookup = {'AttributeValueList': [], 'ComparisonOperator': op} DCNL DCSP  DCSP if (field_bits[(-1)] == 'null'): DCNL DCSP  DCSP  DCSP del lookup['AttributeValueList'] DCNL DCSP  DCSP  DCSP if (value is False): DCNL DCSP  DCSP  DCSP  DCSP lookup['ComparisonOperator'] = 'NOT_NULL' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP lookup['ComparisonOperator'] = 'NULL' DCNL DCSP  DCSP elif (field_bits[(-1)] == 'between'): DCNL DCSP  DCSP  DCSP if ((len(value) == 2) and isinstance(value, (list, tuple))): DCNL DCSP  DCSP  DCSP  DCSP lookup['AttributeValueList'].append(self._dynamizer.encode(value[0])) DCNL DCSP  DCSP  DCSP  DCSP lookup['AttributeValueList'].append(self._dynamizer.encode(value[1])) DCNL DCSP  DCSP elif (field_bits[(-1)] == 'in'): DCNL DCSP  DCSP  DCSP for val in value: DCNL DCSP  DCSP  DCSP  DCSP lookup['AttributeValueList'].append(self._dynamizer.encode(val)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP  DCSP value = set(value) DCNL DCSP  DCSP  DCSP lookup['AttributeValueList'].append(self._dynamizer.encode(value)) DCNL DCSP  DCSP filters[fieldname] = lookup DCNL DCSP return filters
def query(self, limit=None, index=None, reverse=False, consistent=False, attributes=None, max_page_size=None, **filter_kwargs): DCNL DCSP reverse = (not reverse) DCNL DCSP return self.query_2(limit=limit, index=index, reverse=reverse, consistent=consistent, attributes=attributes, max_page_size=max_page_size, **filter_kwargs)
def query_2(self, limit=None, index=None, reverse=False, consistent=False, attributes=None, max_page_size=None, query_filter=None, conditional_operator=None, **filter_kwargs): DCNL DCSP if self.schema: DCNL DCSP  DCSP if (len(self.schema) == 1): DCNL DCSP  DCSP  DCSP if (len(filter_kwargs) <= 1): DCNL DCSP  DCSP  DCSP  DCSP if ((not self.global_indexes) or (not len(self.global_indexes))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exceptions.QueryError('You DCSP must DCSP specify DCSP more DCSP than DCSP one DCSP key DCSP to DCSP filter DCSP on.') DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP select = 'SPECIFIC_ATTRIBUTES' DCNL DCSP else: DCNL DCSP  DCSP select = None DCNL DCSP results = ResultSet(max_page_size=max_page_size) DCNL DCSP kwargs = filter_kwargs.copy() DCNL DCSP kwargs.update({'limit': limit, 'index': index, 'reverse': reverse, 'consistent': consistent, 'select': select, 'attributes_to_get': attributes, 'query_filter': query_filter, 'conditional_operator': conditional_operator}) DCNL DCSP results.to_call(self._query, **kwargs) DCNL DCSP return results
def query_count(self, index=None, consistent=False, conditional_operator=None, query_filter=None, scan_index_forward=True, limit=None, exclusive_start_key=None, **filter_kwargs): DCNL DCSP key_conditions = self._build_filters(filter_kwargs, using=QUERY_OPERATORS) DCNL DCSP built_query_filter = self._build_filters(query_filter, using=FILTER_OPERATORS) DCNL DCSP count_buffer = 0 DCNL DCSP last_evaluated_key = exclusive_start_key DCNL DCSP while True: DCNL DCSP  DCSP raw_results = self.connection.query(self.table_name, index_name=index, consistent_read=consistent, select='COUNT', key_conditions=key_conditions, query_filter=built_query_filter, conditional_operator=conditional_operator, limit=limit, scan_index_forward=scan_index_forward, exclusive_start_key=last_evaluated_key) DCNL DCSP  DCSP count_buffer += int(raw_results.get('Count', 0)) DCNL DCSP  DCSP last_evaluated_key = raw_results.get('LastEvaluatedKey') DCNL DCSP  DCSP if ((not last_evaluated_key) or (count_buffer < 1)): DCNL DCSP  DCSP  DCSP break DCNL DCSP return count_buffer
def _query(self, limit=None, index=None, reverse=False, consistent=False, exclusive_start_key=None, select=None, attributes_to_get=None, query_filter=None, conditional_operator=None, **filter_kwargs): DCNL DCSP kwargs = {'limit': limit, 'index_name': index, 'consistent_read': consistent, 'select': select, 'attributes_to_get': attributes_to_get, 'conditional_operator': conditional_operator} DCNL DCSP if reverse: DCNL DCSP  DCSP kwargs['scan_index_forward'] = False DCNL DCSP if exclusive_start_key: DCNL DCSP  DCSP kwargs['exclusive_start_key'] = {} DCNL DCSP  DCSP for (key, value) in exclusive_start_key.items(): DCNL DCSP  DCSP  DCSP kwargs['exclusive_start_key'][key] = self._dynamizer.encode(value) DCNL DCSP kwargs['key_conditions'] = self._build_filters(filter_kwargs, using=QUERY_OPERATORS) DCNL DCSP kwargs['query_filter'] = self._build_filters(query_filter, using=FILTER_OPERATORS) DCNL DCSP raw_results = self.connection.query(self.table_name, **kwargs) DCNL DCSP results = [] DCNL DCSP last_key = None DCNL DCSP for raw_item in raw_results.get('Items', []): DCNL DCSP  DCSP item = Item(self) DCNL DCSP  DCSP item.load({'Item': raw_item}) DCNL DCSP  DCSP results.append(item) DCNL DCSP if raw_results.get('LastEvaluatedKey', None): DCNL DCSP  DCSP last_key = {} DCNL DCSP  DCSP for (key, value) in raw_results['LastEvaluatedKey'].items(): DCNL DCSP  DCSP  DCSP last_key[key] = self._dynamizer.decode(value) DCNL DCSP return {'results': results, 'last_key': last_key}
def scan(self, limit=None, segment=None, total_segments=None, max_page_size=None, attributes=None, conditional_operator=None, **filter_kwargs): DCNL DCSP results = ResultSet(max_page_size=max_page_size) DCNL DCSP kwargs = filter_kwargs.copy() DCNL DCSP kwargs.update({'limit': limit, 'segment': segment, 'total_segments': total_segments, 'attributes': attributes, 'conditional_operator': conditional_operator}) DCNL DCSP results.to_call(self._scan, **kwargs) DCNL DCSP return results
def _scan(self, limit=None, exclusive_start_key=None, segment=None, total_segments=None, attributes=None, conditional_operator=None, **filter_kwargs): DCNL DCSP kwargs = {'limit': limit, 'segment': segment, 'total_segments': total_segments, 'attributes_to_get': attributes, 'conditional_operator': conditional_operator} DCNL DCSP if exclusive_start_key: DCNL DCSP  DCSP kwargs['exclusive_start_key'] = {} DCNL DCSP  DCSP for (key, value) in exclusive_start_key.items(): DCNL DCSP  DCSP  DCSP kwargs['exclusive_start_key'][key] = self._dynamizer.encode(value) DCNL DCSP kwargs['scan_filter'] = self._build_filters(filter_kwargs, using=FILTER_OPERATORS) DCNL DCSP raw_results = self.connection.scan(self.table_name, **kwargs) DCNL DCSP results = [] DCNL DCSP last_key = None DCNL DCSP for raw_item in raw_results.get('Items', []): DCNL DCSP  DCSP item = Item(self) DCNL DCSP  DCSP item.load({'Item': raw_item}) DCNL DCSP  DCSP results.append(item) DCNL DCSP if raw_results.get('LastEvaluatedKey', None): DCNL DCSP  DCSP last_key = {} DCNL DCSP  DCSP for (key, value) in raw_results['LastEvaluatedKey'].items(): DCNL DCSP  DCSP  DCSP last_key[key] = self._dynamizer.decode(value) DCNL DCSP return {'results': results, 'last_key': last_key}
def batch_get(self, keys, consistent=False, attributes=None): DCNL DCSP results = BatchGetResultSet(keys=keys, max_batch_get=self.max_batch_get) DCNL DCSP results.to_call(self._batch_get, consistent=consistent, attributes=attributes) DCNL DCSP return results
def _batch_get(self, keys, consistent=False, attributes=None): DCNL DCSP items = {self.table_name: {'Keys': []}} DCNL DCSP if consistent: DCNL DCSP  DCSP items[self.table_name]['ConsistentRead'] = True DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP items[self.table_name]['AttributesToGet'] = attributes DCNL DCSP for key_data in keys: DCNL DCSP  DCSP raw_key = {} DCNL DCSP  DCSP for (key, value) in key_data.items(): DCNL DCSP  DCSP  DCSP raw_key[key] = self._dynamizer.encode(value) DCNL DCSP  DCSP items[self.table_name]['Keys'].append(raw_key) DCNL DCSP raw_results = self.connection.batch_get_item(request_items=items) DCNL DCSP results = [] DCNL DCSP unprocessed_keys = [] DCNL DCSP for raw_item in raw_results['Responses'].get(self.table_name, []): DCNL DCSP  DCSP item = Item(self) DCNL DCSP  DCSP item.load({'Item': raw_item}) DCNL DCSP  DCSP results.append(item) DCNL DCSP raw_unprocessed = raw_results.get('UnprocessedKeys', {}).get(self.table_name, {}) DCNL DCSP for raw_key in raw_unprocessed.get('Keys', []): DCNL DCSP  DCSP py_key = {} DCNL DCSP  DCSP for (key, value) in raw_key.items(): DCNL DCSP  DCSP  DCSP py_key[key] = self._dynamizer.decode(value) DCNL DCSP  DCSP unprocessed_keys.append(py_key) DCNL DCSP return {'results': results, 'last_key': None, 'unprocessed_keys': unprocessed_keys}
def count(self): DCNL DCSP info = self.describe() DCNL DCSP return info['Table'].get('ItemCount', 0)
def __init__(self, name, data_type=STRING): DCNL DCSP self.name = name DCNL DCSP self.data_type = data_type
def definition(self): DCNL DCSP return {'AttributeName': self.name, 'AttributeType': self.data_type}
def schema(self): DCNL DCSP return {'AttributeName': self.name, 'KeyType': self.attr_type}
def definition(self): DCNL DCSP definition = [] DCNL DCSP for part in self.parts: DCNL DCSP  DCSP definition.append({'AttributeName': part.name, 'AttributeType': part.data_type}) DCNL DCSP return definition
def schema(self): DCNL DCSP key_schema = [] DCNL DCSP for part in self.parts: DCNL DCSP  DCSP key_schema.append(part.schema()) DCNL DCSP return {'IndexName': self.name, 'KeySchema': key_schema, 'Projection': {'ProjectionType': self.projection_type}}
def schema(self): DCNL DCSP schema_data = super(GlobalBaseIndexField, self).schema() DCNL DCSP schema_data['ProvisionedThroughput'] = {'ReadCapacityUnits': int(self.throughput['read']), 'WriteCapacityUnits': int(self.throughput['write'])} DCNL DCSP return schema_data
def batch_get_item(self, request_items, return_consumed_capacity=None): DCNL DCSP params = {'RequestItems': request_items} DCNL DCSP if (return_consumed_capacity is not None): DCNL DCSP  DCSP params['ReturnConsumedCapacity'] = return_consumed_capacity DCNL DCSP return self.make_request(action='BatchGetItem', body=json.dumps(params))
def batch_write_item(self, request_items, return_consumed_capacity=None, return_item_collection_metrics=None): DCNL DCSP params = {'RequestItems': request_items} DCNL DCSP if (return_consumed_capacity is not None): DCNL DCSP  DCSP params['ReturnConsumedCapacity'] = return_consumed_capacity DCNL DCSP if (return_item_collection_metrics is not None): DCNL DCSP  DCSP params['ReturnItemCollectionMetrics'] = return_item_collection_metrics DCNL DCSP return self.make_request(action='BatchWriteItem', body=json.dumps(params))
def create_table(self, attribute_definitions, table_name, key_schema, provisioned_throughput, local_secondary_indexes=None, global_secondary_indexes=None): DCNL DCSP params = {'AttributeDefinitions': attribute_definitions, 'TableName': table_name, 'KeySchema': key_schema, 'ProvisionedThroughput': provisioned_throughput} DCNL DCSP if (local_secondary_indexes is not None): DCNL DCSP  DCSP params['LocalSecondaryIndexes'] = local_secondary_indexes DCNL DCSP if (global_secondary_indexes is not None): DCNL DCSP  DCSP params['GlobalSecondaryIndexes'] = global_secondary_indexes DCNL DCSP return self.make_request(action='CreateTable', body=json.dumps(params))
def delete_item(self, table_name, key, expected=None, conditional_operator=None, return_values=None, return_consumed_capacity=None, return_item_collection_metrics=None, condition_expression=None, expression_attribute_names=None, expression_attribute_values=None): DCNL DCSP params = {'TableName': table_name, 'Key': key} DCNL DCSP if (expected is not None): DCNL DCSP  DCSP params['Expected'] = expected DCNL DCSP if (conditional_operator is not None): DCNL DCSP  DCSP params['ConditionalOperator'] = conditional_operator DCNL DCSP if (return_values is not None): DCNL DCSP  DCSP params['ReturnValues'] = return_values DCNL DCSP if (return_consumed_capacity is not None): DCNL DCSP  DCSP params['ReturnConsumedCapacity'] = return_consumed_capacity DCNL DCSP if (return_item_collection_metrics is not None): DCNL DCSP  DCSP params['ReturnItemCollectionMetrics'] = return_item_collection_metrics DCNL DCSP if (condition_expression is not None): DCNL DCSP  DCSP params['ConditionExpression'] = condition_expression DCNL DCSP if (expression_attribute_names is not None): DCNL DCSP  DCSP params['ExpressionAttributeNames'] = expression_attribute_names DCNL DCSP if (expression_attribute_values is not None): DCNL DCSP  DCSP params['ExpressionAttributeValues'] = expression_attribute_values DCNL DCSP return self.make_request(action='DeleteItem', body=json.dumps(params))
def delete_table(self, table_name): DCNL DCSP params = {'TableName': table_name} DCNL DCSP return self.make_request(action='DeleteTable', body=json.dumps(params))
def describe_table(self, table_name): DCNL DCSP params = {'TableName': table_name} DCNL DCSP return self.make_request(action='DescribeTable', body=json.dumps(params))
def get_item(self, table_name, key, attributes_to_get=None, consistent_read=None, return_consumed_capacity=None, projection_expression=None, expression_attribute_names=None): DCNL DCSP params = {'TableName': table_name, 'Key': key} DCNL DCSP if (attributes_to_get is not None): DCNL DCSP  DCSP params['AttributesToGet'] = attributes_to_get DCNL DCSP if (consistent_read is not None): DCNL DCSP  DCSP params['ConsistentRead'] = consistent_read DCNL DCSP if (return_consumed_capacity is not None): DCNL DCSP  DCSP params['ReturnConsumedCapacity'] = return_consumed_capacity DCNL DCSP if (projection_expression is not None): DCNL DCSP  DCSP params['ProjectionExpression'] = projection_expression DCNL DCSP if (expression_attribute_names is not None): DCNL DCSP  DCSP params['ExpressionAttributeNames'] = expression_attribute_names DCNL DCSP return self.make_request(action='GetItem', body=json.dumps(params))
def list_tables(self, exclusive_start_table_name=None, limit=None): DCNL DCSP params = {} DCNL DCSP if (exclusive_start_table_name is not None): DCNL DCSP  DCSP params['ExclusiveStartTableName'] = exclusive_start_table_name DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP return self.make_request(action='ListTables', body=json.dumps(params))
def put_item(self, table_name, item, expected=None, return_values=None, return_consumed_capacity=None, return_item_collection_metrics=None, conditional_operator=None, condition_expression=None, expression_attribute_names=None, expression_attribute_values=None): DCNL DCSP params = {'TableName': table_name, 'Item': item} DCNL DCSP if (expected is not None): DCNL DCSP  DCSP params['Expected'] = expected DCNL DCSP if (return_values is not None): DCNL DCSP  DCSP params['ReturnValues'] = return_values DCNL DCSP if (return_consumed_capacity is not None): DCNL DCSP  DCSP params['ReturnConsumedCapacity'] = return_consumed_capacity DCNL DCSP if (return_item_collection_metrics is not None): DCNL DCSP  DCSP params['ReturnItemCollectionMetrics'] = return_item_collection_metrics DCNL DCSP if (conditional_operator is not None): DCNL DCSP  DCSP params['ConditionalOperator'] = conditional_operator DCNL DCSP if (condition_expression is not None): DCNL DCSP  DCSP params['ConditionExpression'] = condition_expression DCNL DCSP if (expression_attribute_names is not None): DCNL DCSP  DCSP params['ExpressionAttributeNames'] = expression_attribute_names DCNL DCSP if (expression_attribute_values is not None): DCNL DCSP  DCSP params['ExpressionAttributeValues'] = expression_attribute_values DCNL DCSP return self.make_request(action='PutItem', body=json.dumps(params))
def query(self, table_name, key_conditions, index_name=None, select=None, attributes_to_get=None, limit=None, consistent_read=None, query_filter=None, conditional_operator=None, scan_index_forward=None, exclusive_start_key=None, return_consumed_capacity=None, projection_expression=None, filter_expression=None, expression_attribute_names=None, expression_attribute_values=None): DCNL DCSP params = {'TableName': table_name, 'KeyConditions': key_conditions} DCNL DCSP if (index_name is not None): DCNL DCSP  DCSP params['IndexName'] = index_name DCNL DCSP if (select is not None): DCNL DCSP  DCSP params['Select'] = select DCNL DCSP if (attributes_to_get is not None): DCNL DCSP  DCSP params['AttributesToGet'] = attributes_to_get DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP if (consistent_read is not None): DCNL DCSP  DCSP params['ConsistentRead'] = consistent_read DCNL DCSP if (query_filter is not None): DCNL DCSP  DCSP params['QueryFilter'] = query_filter DCNL DCSP if (conditional_operator is not None): DCNL DCSP  DCSP params['ConditionalOperator'] = conditional_operator DCNL DCSP if (scan_index_forward is not None): DCNL DCSP  DCSP params['ScanIndexForward'] = scan_index_forward DCNL DCSP if (exclusive_start_key is not None): DCNL DCSP  DCSP params['ExclusiveStartKey'] = exclusive_start_key DCNL DCSP if (return_consumed_capacity is not None): DCNL DCSP  DCSP params['ReturnConsumedCapacity'] = return_consumed_capacity DCNL DCSP if (projection_expression is not None): DCNL DCSP  DCSP params['ProjectionExpression'] = projection_expression DCNL DCSP if (filter_expression is not None): DCNL DCSP  DCSP params['FilterExpression'] = filter_expression DCNL DCSP if (expression_attribute_names is not None): DCNL DCSP  DCSP params['ExpressionAttributeNames'] = expression_attribute_names DCNL DCSP if (expression_attribute_values is not None): DCNL DCSP  DCSP params['ExpressionAttributeValues'] = expression_attribute_values DCNL DCSP return self.make_request(action='Query', body=json.dumps(params))
def scan(self, table_name, attributes_to_get=None, limit=None, select=None, scan_filter=None, conditional_operator=None, exclusive_start_key=None, return_consumed_capacity=None, total_segments=None, segment=None, projection_expression=None, filter_expression=None, expression_attribute_names=None, expression_attribute_values=None): DCNL DCSP params = {'TableName': table_name} DCNL DCSP if (attributes_to_get is not None): DCNL DCSP  DCSP params['AttributesToGet'] = attributes_to_get DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP if (select is not None): DCNL DCSP  DCSP params['Select'] = select DCNL DCSP if (scan_filter is not None): DCNL DCSP  DCSP params['ScanFilter'] = scan_filter DCNL DCSP if (conditional_operator is not None): DCNL DCSP  DCSP params['ConditionalOperator'] = conditional_operator DCNL DCSP if (exclusive_start_key is not None): DCNL DCSP  DCSP params['ExclusiveStartKey'] = exclusive_start_key DCNL DCSP if (return_consumed_capacity is not None): DCNL DCSP  DCSP params['ReturnConsumedCapacity'] = return_consumed_capacity DCNL DCSP if (total_segments is not None): DCNL DCSP  DCSP params['TotalSegments'] = total_segments DCNL DCSP if (segment is not None): DCNL DCSP  DCSP params['Segment'] = segment DCNL DCSP if (projection_expression is not None): DCNL DCSP  DCSP params['ProjectionExpression'] = projection_expression DCNL DCSP if (filter_expression is not None): DCNL DCSP  DCSP params['FilterExpression'] = filter_expression DCNL DCSP if (expression_attribute_names is not None): DCNL DCSP  DCSP params['ExpressionAttributeNames'] = expression_attribute_names DCNL DCSP if (expression_attribute_values is not None): DCNL DCSP  DCSP params['ExpressionAttributeValues'] = expression_attribute_values DCNL DCSP return self.make_request(action='Scan', body=json.dumps(params))
def update_item(self, table_name, key, attribute_updates=None, expected=None, conditional_operator=None, return_values=None, return_consumed_capacity=None, return_item_collection_metrics=None, update_expression=None, condition_expression=None, expression_attribute_names=None, expression_attribute_values=None): DCNL DCSP params = {'TableName': table_name, 'Key': key} DCNL DCSP if (attribute_updates is not None): DCNL DCSP  DCSP params['AttributeUpdates'] = attribute_updates DCNL DCSP if (expected is not None): DCNL DCSP  DCSP params['Expected'] = expected DCNL DCSP if (conditional_operator is not None): DCNL DCSP  DCSP params['ConditionalOperator'] = conditional_operator DCNL DCSP if (return_values is not None): DCNL DCSP  DCSP params['ReturnValues'] = return_values DCNL DCSP if (return_consumed_capacity is not None): DCNL DCSP  DCSP params['ReturnConsumedCapacity'] = return_consumed_capacity DCNL DCSP if (return_item_collection_metrics is not None): DCNL DCSP  DCSP params['ReturnItemCollectionMetrics'] = return_item_collection_metrics DCNL DCSP if (update_expression is not None): DCNL DCSP  DCSP params['UpdateExpression'] = update_expression DCNL DCSP if (condition_expression is not None): DCNL DCSP  DCSP params['ConditionExpression'] = condition_expression DCNL DCSP if (expression_attribute_names is not None): DCNL DCSP  DCSP params['ExpressionAttributeNames'] = expression_attribute_names DCNL DCSP if (expression_attribute_values is not None): DCNL DCSP  DCSP params['ExpressionAttributeValues'] = expression_attribute_values DCNL DCSP return self.make_request(action='UpdateItem', body=json.dumps(params))
def update_table(self, table_name, provisioned_throughput=None, global_secondary_index_updates=None, attribute_definitions=None): DCNL DCSP params = {'TableName': table_name} DCNL DCSP if (attribute_definitions is not None): DCNL DCSP  DCSP params['AttributeDefinitions'] = attribute_definitions DCNL DCSP if (provisioned_throughput is not None): DCNL DCSP  DCSP params['ProvisionedThroughput'] = provisioned_throughput DCNL DCSP if (global_secondary_index_updates is not None): DCNL DCSP  DCSP params['GlobalSecondaryIndexUpdates'] = global_secondary_index_updates DCNL DCSP return self.make_request(action='UpdateTable', body=json.dumps(params))
def __init__(self, table, data=None, loaded=False): DCNL DCSP self.table = table DCNL DCSP self._loaded = loaded DCNL DCSP self._orig_data = {} DCNL DCSP self._data = data DCNL DCSP self._dynamizer = table._dynamizer DCNL DCSP if isinstance(self._data, Item): DCNL DCSP  DCSP self._data = self._data._data DCNL DCSP if (self._data is None): DCNL DCSP  DCSP self._data = {} DCNL DCSP if self._loaded: DCNL DCSP  DCSP self._orig_data = deepcopy(self._data)
def _determine_alterations(self): DCNL DCSP alterations = {'adds': {}, 'changes': {}, 'deletes': []} DCNL DCSP orig_keys = set(self._orig_data.keys()) DCNL DCSP data_keys = set(self._data.keys()) DCNL DCSP for key in orig_keys.intersection(data_keys): DCNL DCSP  DCSP if (self._data[key] != self._orig_data[key]): DCNL DCSP  DCSP  DCSP if self._is_storable(self._data[key]): DCNL DCSP  DCSP  DCSP  DCSP alterations['changes'][key] = self._data[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP alterations['deletes'].append(key) DCNL DCSP for key in data_keys.difference(orig_keys): DCNL DCSP  DCSP if self._is_storable(self._data[key]): DCNL DCSP  DCSP  DCSP alterations['adds'][key] = self._data[key] DCNL DCSP for key in orig_keys.difference(data_keys): DCNL DCSP  DCSP alterations['deletes'].append(key) DCNL DCSP return alterations
def needs_save(self, data=None): DCNL DCSP if (data is None): DCNL DCSP  DCSP data = self._determine_alterations() DCNL DCSP needs_save = False DCNL DCSP for kind in ['adds', 'changes', 'deletes']: DCNL DCSP  DCSP if len(data[kind]): DCNL DCSP  DCSP  DCSP needs_save = True DCNL DCSP  DCSP  DCSP break DCNL DCSP return needs_save
def mark_clean(self): DCNL DCSP self._orig_data = deepcopy(self._data)
def mark_dirty(self): DCNL DCSP return
def load(self, data): DCNL DCSP self._data = {} DCNL DCSP for (field_name, field_value) in data.get('Item', {}).items(): DCNL DCSP  DCSP self[field_name] = self._dynamizer.decode(field_value) DCNL DCSP self._loaded = True DCNL DCSP self._orig_data = deepcopy(self._data)
def get_keys(self): DCNL DCSP key_fields = self.table.get_key_fields() DCNL DCSP key_data = {} DCNL DCSP for key in key_fields: DCNL DCSP  DCSP key_data[key] = self[key] DCNL DCSP return key_data
def get_raw_keys(self): DCNL DCSP raw_key_data = {} DCNL DCSP for (key, value) in self.get_keys().items(): DCNL DCSP  DCSP raw_key_data[key] = self._dynamizer.encode(value) DCNL DCSP return raw_key_data
def build_expects(self, fields=None): DCNL DCSP expects = {} DCNL DCSP if (fields is None): DCNL DCSP  DCSP fields = (list(self._data.keys()) + list(self._orig_data.keys())) DCNL DCSP fields = set(fields) DCNL DCSP for key in fields: DCNL DCSP  DCSP expects[key] = {'Exists': True} DCNL DCSP  DCSP value = None DCNL DCSP  DCSP if ((not (key in self._orig_data)) and (not (key in self._data))): DCNL DCSP  DCSP  DCSP raise ValueError(('Unknown DCSP key DCSP %s DCSP provided.' % key)) DCNL DCSP  DCSP orig_value = self._orig_data.get(key, NEWVALUE) DCNL DCSP  DCSP current_value = self._data.get(key, NEWVALUE) DCNL DCSP  DCSP if (orig_value == current_value): DCNL DCSP  DCSP  DCSP value = current_value DCNL DCSP  DCSP elif (key in self._data): DCNL DCSP  DCSP  DCSP if (not (key in self._orig_data)): DCNL DCSP  DCSP  DCSP  DCSP expects[key]['Exists'] = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = orig_value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = orig_value DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP expects[key]['Value'] = self._dynamizer.encode(value) DCNL DCSP return expects
def prepare_full(self): DCNL DCSP final_data = {} DCNL DCSP for (key, value) in self._data.items(): DCNL DCSP  DCSP if (not self._is_storable(value)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP final_data[key] = self._dynamizer.encode(value) DCNL DCSP return final_data
def prepare_partial(self): DCNL DCSP final_data = {} DCNL DCSP fields = set() DCNL DCSP alterations = self._determine_alterations() DCNL DCSP for (key, value) in alterations['adds'].items(): DCNL DCSP  DCSP final_data[key] = {'Action': 'PUT', 'Value': self._dynamizer.encode(self._data[key])} DCNL DCSP  DCSP fields.add(key) DCNL DCSP for (key, value) in alterations['changes'].items(): DCNL DCSP  DCSP final_data[key] = {'Action': 'PUT', 'Value': self._dynamizer.encode(self._data[key])} DCNL DCSP  DCSP fields.add(key) DCNL DCSP for key in alterations['deletes']: DCNL DCSP  DCSP final_data[key] = {'Action': 'DELETE'} DCNL DCSP  DCSP fields.add(key) DCNL DCSP return (final_data, fields)
def partial_save(self): DCNL DCSP key = self.get_keys() DCNL DCSP (final_data, fields) = self.prepare_partial() DCNL DCSP if (not final_data): DCNL DCSP  DCSP return False DCNL DCSP for (fieldname, value) in key.items(): DCNL DCSP  DCSP if (fieldname in final_data): DCNL DCSP  DCSP  DCSP del final_data[fieldname] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fields.remove(fieldname) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP expects = self.build_expects(fields=fields) DCNL DCSP returned = self.table._update_item(key, final_data, expects=expects) DCNL DCSP self.mark_clean() DCNL DCSP return returned
def save(self, overwrite=False): DCNL DCSP if ((not self.needs_save()) and (not overwrite)): DCNL DCSP  DCSP return False DCNL DCSP final_data = self.prepare_full() DCNL DCSP expects = None DCNL DCSP if (overwrite is False): DCNL DCSP  DCSP expects = self.build_expects() DCNL DCSP returned = self.table._put_item(final_data, expects=expects) DCNL DCSP self.mark_clean() DCNL DCSP return returned
def delete(self): DCNL DCSP key_data = self.get_keys() DCNL DCSP return self.table.delete_item(**key_data)
def _reset(self): DCNL DCSP self._results = [] DCNL DCSP self._offset = 0
def to_call(self, the_callable, *args, **kwargs): DCNL DCSP if (not callable(the_callable)): DCNL DCSP  DCSP raise ValueError('You DCSP must DCSP supply DCSP an DCSP object DCSP or DCSP function DCSP to DCSP be DCSP called.') DCNL DCSP self._limit = kwargs.pop('limit', None) DCNL DCSP if ((self._limit is not None) and (self._limit < 0)): DCNL DCSP  DCSP self._limit = None DCNL DCSP self.the_callable = the_callable DCNL DCSP self.call_args = args DCNL DCSP self.call_kwargs = kwargs
def fetch_more(self): DCNL DCSP self._reset() DCNL DCSP args = self.call_args[:] DCNL DCSP kwargs = self.call_kwargs.copy() DCNL DCSP if (self._last_key_seen is not None): DCNL DCSP  DCSP kwargs[self.first_key] = self._last_key_seen DCNL DCSP if (self._limit and self._max_page_size and (self._max_page_size > self._limit)): DCNL DCSP  DCSP self._max_page_size = self._limit DCNL DCSP if (self._max_page_size is not None): DCNL DCSP  DCSP kwargs['limit'] = self._max_page_size DCNL DCSP elif (self._limit is not None): DCNL DCSP  DCSP kwargs['limit'] = self._limit DCNL DCSP results = self.the_callable(*args, **kwargs) DCNL DCSP self._fetches += 1 DCNL DCSP new_results = results.get('results', []) DCNL DCSP self._last_key_seen = results.get('last_key', None) DCNL DCSP if len(new_results): DCNL DCSP  DCSP self._results.extend(results['results']) DCNL DCSP if ((self._limit is not None) and (self._limit >= 0)): DCNL DCSP  DCSP limit = self._limit DCNL DCSP  DCSP limit -= len(results['results']) DCNL DCSP  DCSP if (limit <= 0): DCNL DCSP  DCSP  DCSP self._results_left = False DCNL DCSP if (self._last_key_seen is None): DCNL DCSP  DCSP self._results_left = False
def authorize_cluster_security_group_ingress(self, cluster_security_group_name, cidrip=None, ec2_security_group_name=None, ec2_security_group_owner_id=None): DCNL DCSP params = {'ClusterSecurityGroupName': cluster_security_group_name} DCNL DCSP if (cidrip is not None): DCNL DCSP  DCSP params['CIDRIP'] = cidrip DCNL DCSP if (ec2_security_group_name is not None): DCNL DCSP  DCSP params['EC2SecurityGroupName'] = ec2_security_group_name DCNL DCSP if (ec2_security_group_owner_id is not None): DCNL DCSP  DCSP params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id DCNL DCSP return self._make_request(action='AuthorizeClusterSecurityGroupIngress', verb='POST', path='/', params=params)
def authorize_snapshot_access(self, snapshot_identifier, account_with_restore_access, snapshot_cluster_identifier=None): DCNL DCSP params = {'SnapshotIdentifier': snapshot_identifier, 'AccountWithRestoreAccess': account_with_restore_access} DCNL DCSP if (snapshot_cluster_identifier is not None): DCNL DCSP  DCSP params['SnapshotClusterIdentifier'] = snapshot_cluster_identifier DCNL DCSP return self._make_request(action='AuthorizeSnapshotAccess', verb='POST', path='/', params=params)
def copy_cluster_snapshot(self, source_snapshot_identifier, target_snapshot_identifier, source_snapshot_cluster_identifier=None): DCNL DCSP params = {'SourceSnapshotIdentifier': source_snapshot_identifier, 'TargetSnapshotIdentifier': target_snapshot_identifier} DCNL DCSP if (source_snapshot_cluster_identifier is not None): DCNL DCSP  DCSP params['SourceSnapshotClusterIdentifier'] = source_snapshot_cluster_identifier DCNL DCSP return self._make_request(action='CopyClusterSnapshot', verb='POST', path='/', params=params)
def create_cluster(self, cluster_identifier, node_type, master_username, master_user_password, db_name=None, cluster_type=None, cluster_security_groups=None, vpc_security_group_ids=None, cluster_subnet_group_name=None, availability_zone=None, preferred_maintenance_window=None, cluster_parameter_group_name=None, automated_snapshot_retention_period=None, port=None, cluster_version=None, allow_version_upgrade=None, number_of_nodes=None, publicly_accessible=None, encrypted=None, hsm_client_certificate_identifier=None, hsm_configuration_identifier=None, elastic_ip=None): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier, 'NodeType': node_type, 'MasterUsername': master_username, 'MasterUserPassword': master_user_password} DCNL DCSP if (db_name is not None): DCNL DCSP  DCSP params['DBName'] = db_name DCNL DCSP if (cluster_type is not None): DCNL DCSP  DCSP params['ClusterType'] = cluster_type DCNL DCSP if (cluster_security_groups is not None): DCNL DCSP  DCSP self.build_list_params(params, cluster_security_groups, 'ClusterSecurityGroups.member') DCNL DCSP if (vpc_security_group_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, vpc_security_group_ids, 'VpcSecurityGroupIds.member') DCNL DCSP if (cluster_subnet_group_name is not None): DCNL DCSP  DCSP params['ClusterSubnetGroupName'] = cluster_subnet_group_name DCNL DCSP if (availability_zone is not None): DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (preferred_maintenance_window is not None): DCNL DCSP  DCSP params['PreferredMaintenanceWindow'] = preferred_maintenance_window DCNL DCSP if (cluster_parameter_group_name is not None): DCNL DCSP  DCSP params['ClusterParameterGroupName'] = cluster_parameter_group_name DCNL DCSP if (automated_snapshot_retention_period is not None): DCNL DCSP  DCSP params['AutomatedSnapshotRetentionPeriod'] = automated_snapshot_retention_period DCNL DCSP if (port is not None): DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if (cluster_version is not None): DCNL DCSP  DCSP params['ClusterVersion'] = cluster_version DCNL DCSP if (allow_version_upgrade is not None): DCNL DCSP  DCSP params['AllowVersionUpgrade'] = str(allow_version_upgrade).lower() DCNL DCSP if (number_of_nodes is not None): DCNL DCSP  DCSP params['NumberOfNodes'] = number_of_nodes DCNL DCSP if (publicly_accessible is not None): DCNL DCSP  DCSP params['PubliclyAccessible'] = str(publicly_accessible).lower() DCNL DCSP if (encrypted is not None): DCNL DCSP  DCSP params['Encrypted'] = str(encrypted).lower() DCNL DCSP if (hsm_client_certificate_identifier is not None): DCNL DCSP  DCSP params['HsmClientCertificateIdentifier'] = hsm_client_certificate_identifier DCNL DCSP if (hsm_configuration_identifier is not None): DCNL DCSP  DCSP params['HsmConfigurationIdentifier'] = hsm_configuration_identifier DCNL DCSP if (elastic_ip is not None): DCNL DCSP  DCSP params['ElasticIp'] = elastic_ip DCNL DCSP return self._make_request(action='CreateCluster', verb='POST', path='/', params=params)
def create_cluster_parameter_group(self, parameter_group_name, parameter_group_family, description): DCNL DCSP params = {'ParameterGroupName': parameter_group_name, 'ParameterGroupFamily': parameter_group_family, 'Description': description} DCNL DCSP return self._make_request(action='CreateClusterParameterGroup', verb='POST', path='/', params=params)
def create_cluster_security_group(self, cluster_security_group_name, description): DCNL DCSP params = {'ClusterSecurityGroupName': cluster_security_group_name, 'Description': description} DCNL DCSP return self._make_request(action='CreateClusterSecurityGroup', verb='POST', path='/', params=params)
def create_cluster_snapshot(self, snapshot_identifier, cluster_identifier): DCNL DCSP params = {'SnapshotIdentifier': snapshot_identifier, 'ClusterIdentifier': cluster_identifier} DCNL DCSP return self._make_request(action='CreateClusterSnapshot', verb='POST', path='/', params=params)
def create_cluster_subnet_group(self, cluster_subnet_group_name, description, subnet_ids): DCNL DCSP params = {'ClusterSubnetGroupName': cluster_subnet_group_name, 'Description': description} DCNL DCSP self.build_list_params(params, subnet_ids, 'SubnetIds.member') DCNL DCSP return self._make_request(action='CreateClusterSubnetGroup', verb='POST', path='/', params=params)
def create_event_subscription(self, subscription_name, sns_topic_arn, source_type=None, source_ids=None, event_categories=None, severity=None, enabled=None): DCNL DCSP params = {'SubscriptionName': subscription_name, 'SnsTopicArn': sns_topic_arn} DCNL DCSP if (source_type is not None): DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP if (source_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, source_ids, 'SourceIds.member') DCNL DCSP if (event_categories is not None): DCNL DCSP  DCSP self.build_list_params(params, event_categories, 'EventCategories.member') DCNL DCSP if (severity is not None): DCNL DCSP  DCSP params['Severity'] = severity DCNL DCSP if (enabled is not None): DCNL DCSP  DCSP params['Enabled'] = str(enabled).lower() DCNL DCSP return self._make_request(action='CreateEventSubscription', verb='POST', path='/', params=params)
def create_hsm_client_certificate(self, hsm_client_certificate_identifier): DCNL DCSP params = {'HsmClientCertificateIdentifier': hsm_client_certificate_identifier} DCNL DCSP return self._make_request(action='CreateHsmClientCertificate', verb='POST', path='/', params=params)
def create_hsm_configuration(self, hsm_configuration_identifier, description, hsm_ip_address, hsm_partition_name, hsm_partition_password, hsm_server_public_certificate): DCNL DCSP params = {'HsmConfigurationIdentifier': hsm_configuration_identifier, 'Description': description, 'HsmIpAddress': hsm_ip_address, 'HsmPartitionName': hsm_partition_name, 'HsmPartitionPassword': hsm_partition_password, 'HsmServerPublicCertificate': hsm_server_public_certificate} DCNL DCSP return self._make_request(action='CreateHsmConfiguration', verb='POST', path='/', params=params)
def delete_cluster(self, cluster_identifier, skip_final_cluster_snapshot=None, final_cluster_snapshot_identifier=None): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier} DCNL DCSP if (skip_final_cluster_snapshot is not None): DCNL DCSP  DCSP params['SkipFinalClusterSnapshot'] = str(skip_final_cluster_snapshot).lower() DCNL DCSP if (final_cluster_snapshot_identifier is not None): DCNL DCSP  DCSP params['FinalClusterSnapshotIdentifier'] = final_cluster_snapshot_identifier DCNL DCSP return self._make_request(action='DeleteCluster', verb='POST', path='/', params=params)
def delete_cluster_parameter_group(self, parameter_group_name): DCNL DCSP params = {'ParameterGroupName': parameter_group_name} DCNL DCSP return self._make_request(action='DeleteClusterParameterGroup', verb='POST', path='/', params=params)
def delete_cluster_security_group(self, cluster_security_group_name): DCNL DCSP params = {'ClusterSecurityGroupName': cluster_security_group_name} DCNL DCSP return self._make_request(action='DeleteClusterSecurityGroup', verb='POST', path='/', params=params)
def delete_cluster_snapshot(self, snapshot_identifier, snapshot_cluster_identifier=None): DCNL DCSP params = {'SnapshotIdentifier': snapshot_identifier} DCNL DCSP if (snapshot_cluster_identifier is not None): DCNL DCSP  DCSP params['SnapshotClusterIdentifier'] = snapshot_cluster_identifier DCNL DCSP return self._make_request(action='DeleteClusterSnapshot', verb='POST', path='/', params=params)
def delete_cluster_subnet_group(self, cluster_subnet_group_name): DCNL DCSP params = {'ClusterSubnetGroupName': cluster_subnet_group_name} DCNL DCSP return self._make_request(action='DeleteClusterSubnetGroup', verb='POST', path='/', params=params)
def delete_event_subscription(self, subscription_name): DCNL DCSP params = {'SubscriptionName': subscription_name} DCNL DCSP return self._make_request(action='DeleteEventSubscription', verb='POST', path='/', params=params)
def delete_hsm_client_certificate(self, hsm_client_certificate_identifier): DCNL DCSP params = {'HsmClientCertificateIdentifier': hsm_client_certificate_identifier} DCNL DCSP return self._make_request(action='DeleteHsmClientCertificate', verb='POST', path='/', params=params)
def delete_hsm_configuration(self, hsm_configuration_identifier): DCNL DCSP params = {'HsmConfigurationIdentifier': hsm_configuration_identifier} DCNL DCSP return self._make_request(action='DeleteHsmConfiguration', verb='POST', path='/', params=params)
def describe_cluster_parameter_groups(self, parameter_group_name=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (parameter_group_name is not None): DCNL DCSP  DCSP params['ParameterGroupName'] = parameter_group_name DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeClusterParameterGroups', verb='POST', path='/', params=params)
def describe_cluster_parameters(self, parameter_group_name, source=None, max_records=None, marker=None): DCNL DCSP params = {'ParameterGroupName': parameter_group_name} DCNL DCSP if (source is not None): DCNL DCSP  DCSP params['Source'] = source DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeClusterParameters', verb='POST', path='/', params=params)
def describe_cluster_security_groups(self, cluster_security_group_name=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (cluster_security_group_name is not None): DCNL DCSP  DCSP params['ClusterSecurityGroupName'] = cluster_security_group_name DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeClusterSecurityGroups', verb='POST', path='/', params=params)
def describe_cluster_snapshots(self, cluster_identifier=None, snapshot_identifier=None, snapshot_type=None, start_time=None, end_time=None, max_records=None, marker=None, owner_account=None): DCNL DCSP params = {} DCNL DCSP if (cluster_identifier is not None): DCNL DCSP  DCSP params['ClusterIdentifier'] = cluster_identifier DCNL DCSP if (snapshot_identifier is not None): DCNL DCSP  DCSP params['SnapshotIdentifier'] = snapshot_identifier DCNL DCSP if (snapshot_type is not None): DCNL DCSP  DCSP params['SnapshotType'] = snapshot_type DCNL DCSP if (start_time is not None): DCNL DCSP  DCSP params['StartTime'] = start_time DCNL DCSP if (end_time is not None): DCNL DCSP  DCSP params['EndTime'] = end_time DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (owner_account is not None): DCNL DCSP  DCSP params['OwnerAccount'] = owner_account DCNL DCSP return self._make_request(action='DescribeClusterSnapshots', verb='POST', path='/', params=params)
def describe_cluster_subnet_groups(self, cluster_subnet_group_name=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (cluster_subnet_group_name is not None): DCNL DCSP  DCSP params['ClusterSubnetGroupName'] = cluster_subnet_group_name DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeClusterSubnetGroups', verb='POST', path='/', params=params)
def describe_cluster_versions(self, cluster_version=None, cluster_parameter_group_family=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (cluster_version is not None): DCNL DCSP  DCSP params['ClusterVersion'] = cluster_version DCNL DCSP if (cluster_parameter_group_family is not None): DCNL DCSP  DCSP params['ClusterParameterGroupFamily'] = cluster_parameter_group_family DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeClusterVersions', verb='POST', path='/', params=params)
def describe_clusters(self, cluster_identifier=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (cluster_identifier is not None): DCNL DCSP  DCSP params['ClusterIdentifier'] = cluster_identifier DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeClusters', verb='POST', path='/', params=params)
def describe_default_cluster_parameters(self, parameter_group_family, max_records=None, marker=None): DCNL DCSP params = {'ParameterGroupFamily': parameter_group_family} DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeDefaultClusterParameters', verb='POST', path='/', params=params)
def describe_event_categories(self, source_type=None): DCNL DCSP params = {} DCNL DCSP if (source_type is not None): DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP return self._make_request(action='DescribeEventCategories', verb='POST', path='/', params=params)
def describe_event_subscriptions(self, subscription_name=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (subscription_name is not None): DCNL DCSP  DCSP params['SubscriptionName'] = subscription_name DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeEventSubscriptions', verb='POST', path='/', params=params)
def describe_events(self, source_identifier=None, source_type=None, start_time=None, end_time=None, duration=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (source_identifier is not None): DCNL DCSP  DCSP params['SourceIdentifier'] = source_identifier DCNL DCSP if (source_type is not None): DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP if (start_time is not None): DCNL DCSP  DCSP params['StartTime'] = start_time DCNL DCSP if (end_time is not None): DCNL DCSP  DCSP params['EndTime'] = end_time DCNL DCSP if (duration is not None): DCNL DCSP  DCSP params['Duration'] = duration DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeEvents', verb='POST', path='/', params=params)
def describe_hsm_client_certificates(self, hsm_client_certificate_identifier=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (hsm_client_certificate_identifier is not None): DCNL DCSP  DCSP params['HsmClientCertificateIdentifier'] = hsm_client_certificate_identifier DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeHsmClientCertificates', verb='POST', path='/', params=params)
def describe_hsm_configurations(self, hsm_configuration_identifier=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (hsm_configuration_identifier is not None): DCNL DCSP  DCSP params['HsmConfigurationIdentifier'] = hsm_configuration_identifier DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeHsmConfigurations', verb='POST', path='/', params=params)
def describe_logging_status(self, cluster_identifier): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier} DCNL DCSP return self._make_request(action='DescribeLoggingStatus', verb='POST', path='/', params=params)
def describe_orderable_cluster_options(self, cluster_version=None, node_type=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (cluster_version is not None): DCNL DCSP  DCSP params['ClusterVersion'] = cluster_version DCNL DCSP if (node_type is not None): DCNL DCSP  DCSP params['NodeType'] = node_type DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeOrderableClusterOptions', verb='POST', path='/', params=params)
def describe_reserved_node_offerings(self, reserved_node_offering_id=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (reserved_node_offering_id is not None): DCNL DCSP  DCSP params['ReservedNodeOfferingId'] = reserved_node_offering_id DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeReservedNodeOfferings', verb='POST', path='/', params=params)
def describe_reserved_nodes(self, reserved_node_id=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (reserved_node_id is not None): DCNL DCSP  DCSP params['ReservedNodeId'] = reserved_node_id DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeReservedNodes', verb='POST', path='/', params=params)
def describe_resize(self, cluster_identifier): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier} DCNL DCSP return self._make_request(action='DescribeResize', verb='POST', path='/', params=params)
def disable_logging(self, cluster_identifier): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier} DCNL DCSP return self._make_request(action='DisableLogging', verb='POST', path='/', params=params)
def disable_snapshot_copy(self, cluster_identifier): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier} DCNL DCSP return self._make_request(action='DisableSnapshotCopy', verb='POST', path='/', params=params)
def enable_logging(self, cluster_identifier, bucket_name, s3_key_prefix=None): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier, 'BucketName': bucket_name} DCNL DCSP if (s3_key_prefix is not None): DCNL DCSP  DCSP params['S3KeyPrefix'] = s3_key_prefix DCNL DCSP return self._make_request(action='EnableLogging', verb='POST', path='/', params=params)
def enable_snapshot_copy(self, cluster_identifier, destination_region, retention_period=None): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier, 'DestinationRegion': destination_region} DCNL DCSP if (retention_period is not None): DCNL DCSP  DCSP params['RetentionPeriod'] = retention_period DCNL DCSP return self._make_request(action='EnableSnapshotCopy', verb='POST', path='/', params=params)
def modify_cluster(self, cluster_identifier, cluster_type=None, node_type=None, number_of_nodes=None, cluster_security_groups=None, vpc_security_group_ids=None, master_user_password=None, cluster_parameter_group_name=None, automated_snapshot_retention_period=None, preferred_maintenance_window=None, cluster_version=None, allow_version_upgrade=None, hsm_client_certificate_identifier=None, hsm_configuration_identifier=None, new_cluster_identifier=None): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier} DCNL DCSP if (cluster_type is not None): DCNL DCSP  DCSP params['ClusterType'] = cluster_type DCNL DCSP if (node_type is not None): DCNL DCSP  DCSP params['NodeType'] = node_type DCNL DCSP if (number_of_nodes is not None): DCNL DCSP  DCSP params['NumberOfNodes'] = number_of_nodes DCNL DCSP if (cluster_security_groups is not None): DCNL DCSP  DCSP self.build_list_params(params, cluster_security_groups, 'ClusterSecurityGroups.member') DCNL DCSP if (vpc_security_group_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, vpc_security_group_ids, 'VpcSecurityGroupIds.member') DCNL DCSP if (master_user_password is not None): DCNL DCSP  DCSP params['MasterUserPassword'] = master_user_password DCNL DCSP if (cluster_parameter_group_name is not None): DCNL DCSP  DCSP params['ClusterParameterGroupName'] = cluster_parameter_group_name DCNL DCSP if (automated_snapshot_retention_period is not None): DCNL DCSP  DCSP params['AutomatedSnapshotRetentionPeriod'] = automated_snapshot_retention_period DCNL DCSP if (preferred_maintenance_window is not None): DCNL DCSP  DCSP params['PreferredMaintenanceWindow'] = preferred_maintenance_window DCNL DCSP if (cluster_version is not None): DCNL DCSP  DCSP params['ClusterVersion'] = cluster_version DCNL DCSP if (allow_version_upgrade is not None): DCNL DCSP  DCSP params['AllowVersionUpgrade'] = str(allow_version_upgrade).lower() DCNL DCSP if (hsm_client_certificate_identifier is not None): DCNL DCSP  DCSP params['HsmClientCertificateIdentifier'] = hsm_client_certificate_identifier DCNL DCSP if (hsm_configuration_identifier is not None): DCNL DCSP  DCSP params['HsmConfigurationIdentifier'] = hsm_configuration_identifier DCNL DCSP if (new_cluster_identifier is not None): DCNL DCSP  DCSP params['NewClusterIdentifier'] = new_cluster_identifier DCNL DCSP return self._make_request(action='ModifyCluster', verb='POST', path='/', params=params)
def modify_cluster_parameter_group(self, parameter_group_name, parameters): DCNL DCSP params = {'ParameterGroupName': parameter_group_name} DCNL DCSP self.build_complex_list_params(params, parameters, 'Parameters.member', ('ParameterName', 'ParameterValue', 'Description', 'Source', 'DataType', 'AllowedValues', 'IsModifiable', 'MinimumEngineVersion')) DCNL DCSP return self._make_request(action='ModifyClusterParameterGroup', verb='POST', path='/', params=params)
def modify_cluster_subnet_group(self, cluster_subnet_group_name, subnet_ids, description=None): DCNL DCSP params = {'ClusterSubnetGroupName': cluster_subnet_group_name} DCNL DCSP self.build_list_params(params, subnet_ids, 'SubnetIds.member') DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['Description'] = description DCNL DCSP return self._make_request(action='ModifyClusterSubnetGroup', verb='POST', path='/', params=params)
def modify_event_subscription(self, subscription_name, sns_topic_arn=None, source_type=None, source_ids=None, event_categories=None, severity=None, enabled=None): DCNL DCSP params = {'SubscriptionName': subscription_name} DCNL DCSP if (sns_topic_arn is not None): DCNL DCSP  DCSP params['SnsTopicArn'] = sns_topic_arn DCNL DCSP if (source_type is not None): DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP if (source_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, source_ids, 'SourceIds.member') DCNL DCSP if (event_categories is not None): DCNL DCSP  DCSP self.build_list_params(params, event_categories, 'EventCategories.member') DCNL DCSP if (severity is not None): DCNL DCSP  DCSP params['Severity'] = severity DCNL DCSP if (enabled is not None): DCNL DCSP  DCSP params['Enabled'] = str(enabled).lower() DCNL DCSP return self._make_request(action='ModifyEventSubscription', verb='POST', path='/', params=params)
def modify_snapshot_copy_retention_period(self, cluster_identifier, retention_period): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier, 'RetentionPeriod': retention_period} DCNL DCSP return self._make_request(action='ModifySnapshotCopyRetentionPeriod', verb='POST', path='/', params=params)
def purchase_reserved_node_offering(self, reserved_node_offering_id, node_count=None): DCNL DCSP params = {'ReservedNodeOfferingId': reserved_node_offering_id} DCNL DCSP if (node_count is not None): DCNL DCSP  DCSP params['NodeCount'] = node_count DCNL DCSP return self._make_request(action='PurchaseReservedNodeOffering', verb='POST', path='/', params=params)
def reboot_cluster(self, cluster_identifier): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier} DCNL DCSP return self._make_request(action='RebootCluster', verb='POST', path='/', params=params)
def reset_cluster_parameter_group(self, parameter_group_name, reset_all_parameters=None, parameters=None): DCNL DCSP params = {'ParameterGroupName': parameter_group_name} DCNL DCSP if (reset_all_parameters is not None): DCNL DCSP  DCSP params['ResetAllParameters'] = str(reset_all_parameters).lower() DCNL DCSP if (parameters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, parameters, 'Parameters.member', ('ParameterName', 'ParameterValue', 'Description', 'Source', 'DataType', 'AllowedValues', 'IsModifiable', 'MinimumEngineVersion')) DCNL DCSP return self._make_request(action='ResetClusterParameterGroup', verb='POST', path='/', params=params)
def restore_from_cluster_snapshot(self, cluster_identifier, snapshot_identifier, snapshot_cluster_identifier=None, port=None, availability_zone=None, allow_version_upgrade=None, cluster_subnet_group_name=None, publicly_accessible=None, owner_account=None, hsm_client_certificate_identifier=None, hsm_configuration_identifier=None, elastic_ip=None, cluster_parameter_group_name=None, cluster_security_groups=None, vpc_security_group_ids=None, preferred_maintenance_window=None, automated_snapshot_retention_period=None): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier, 'SnapshotIdentifier': snapshot_identifier} DCNL DCSP if (snapshot_cluster_identifier is not None): DCNL DCSP  DCSP params['SnapshotClusterIdentifier'] = snapshot_cluster_identifier DCNL DCSP if (port is not None): DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if (availability_zone is not None): DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (allow_version_upgrade is not None): DCNL DCSP  DCSP params['AllowVersionUpgrade'] = str(allow_version_upgrade).lower() DCNL DCSP if (cluster_subnet_group_name is not None): DCNL DCSP  DCSP params['ClusterSubnetGroupName'] = cluster_subnet_group_name DCNL DCSP if (publicly_accessible is not None): DCNL DCSP  DCSP params['PubliclyAccessible'] = str(publicly_accessible).lower() DCNL DCSP if (owner_account is not None): DCNL DCSP  DCSP params['OwnerAccount'] = owner_account DCNL DCSP if (hsm_client_certificate_identifier is not None): DCNL DCSP  DCSP params['HsmClientCertificateIdentifier'] = hsm_client_certificate_identifier DCNL DCSP if (hsm_configuration_identifier is not None): DCNL DCSP  DCSP params['HsmConfigurationIdentifier'] = hsm_configuration_identifier DCNL DCSP if (elastic_ip is not None): DCNL DCSP  DCSP params['ElasticIp'] = elastic_ip DCNL DCSP if (cluster_parameter_group_name is not None): DCNL DCSP  DCSP params['ClusterParameterGroupName'] = cluster_parameter_group_name DCNL DCSP if (cluster_security_groups is not None): DCNL DCSP  DCSP self.build_list_params(params, cluster_security_groups, 'ClusterSecurityGroups.member') DCNL DCSP if (vpc_security_group_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, vpc_security_group_ids, 'VpcSecurityGroupIds.member') DCNL DCSP if (preferred_maintenance_window is not None): DCNL DCSP  DCSP params['PreferredMaintenanceWindow'] = preferred_maintenance_window DCNL DCSP if (automated_snapshot_retention_period is not None): DCNL DCSP  DCSP params['AutomatedSnapshotRetentionPeriod'] = automated_snapshot_retention_period DCNL DCSP return self._make_request(action='RestoreFromClusterSnapshot', verb='POST', path='/', params=params)
def revoke_cluster_security_group_ingress(self, cluster_security_group_name, cidrip=None, ec2_security_group_name=None, ec2_security_group_owner_id=None): DCNL DCSP params = {'ClusterSecurityGroupName': cluster_security_group_name} DCNL DCSP if (cidrip is not None): DCNL DCSP  DCSP params['CIDRIP'] = cidrip DCNL DCSP if (ec2_security_group_name is not None): DCNL DCSP  DCSP params['EC2SecurityGroupName'] = ec2_security_group_name DCNL DCSP if (ec2_security_group_owner_id is not None): DCNL DCSP  DCSP params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id DCNL DCSP return self._make_request(action='RevokeClusterSecurityGroupIngress', verb='POST', path='/', params=params)
def revoke_snapshot_access(self, snapshot_identifier, account_with_restore_access, snapshot_cluster_identifier=None): DCNL DCSP params = {'SnapshotIdentifier': snapshot_identifier, 'AccountWithRestoreAccess': account_with_restore_access} DCNL DCSP if (snapshot_cluster_identifier is not None): DCNL DCSP  DCSP params['SnapshotClusterIdentifier'] = snapshot_cluster_identifier DCNL DCSP return self._make_request(action='RevokeSnapshotAccess', verb='POST', path='/', params=params)
def rotate_encryption_key(self, cluster_identifier): DCNL DCSP params = {'ClusterIdentifier': cluster_identifier} DCNL DCSP return self._make_request(action='RotateEncryptionKey', verb='POST', path='/', params=params)
def create_log_group(self, log_group_name): DCNL DCSP params = {'logGroupName': log_group_name} DCNL DCSP return self.make_request(action='CreateLogGroup', body=json.dumps(params))
def create_log_stream(self, log_group_name, log_stream_name): DCNL DCSP params = {'logGroupName': log_group_name, 'logStreamName': log_stream_name} DCNL DCSP return self.make_request(action='CreateLogStream', body=json.dumps(params))
def delete_log_group(self, log_group_name): DCNL DCSP params = {'logGroupName': log_group_name} DCNL DCSP return self.make_request(action='DeleteLogGroup', body=json.dumps(params))
def delete_log_stream(self, log_group_name, log_stream_name): DCNL DCSP params = {'logGroupName': log_group_name, 'logStreamName': log_stream_name} DCNL DCSP return self.make_request(action='DeleteLogStream', body=json.dumps(params))
def delete_metric_filter(self, log_group_name, filter_name): DCNL DCSP params = {'logGroupName': log_group_name, 'filterName': filter_name} DCNL DCSP return self.make_request(action='DeleteMetricFilter', body=json.dumps(params))
def delete_retention_policy(self, log_group_name): DCNL DCSP params = {'logGroupName': log_group_name} DCNL DCSP return self.make_request(action='DeleteRetentionPolicy', body=json.dumps(params))
def describe_log_groups(self, log_group_name_prefix=None, next_token=None, limit=None): DCNL DCSP params = {} DCNL DCSP if (log_group_name_prefix is not None): DCNL DCSP  DCSP params['logGroupNamePrefix'] = log_group_name_prefix DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP return self.make_request(action='DescribeLogGroups', body=json.dumps(params))
def describe_log_streams(self, log_group_name, log_stream_name_prefix=None, next_token=None, limit=None): DCNL DCSP params = {'logGroupName': log_group_name} DCNL DCSP if (log_stream_name_prefix is not None): DCNL DCSP  DCSP params['logStreamNamePrefix'] = log_stream_name_prefix DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP return self.make_request(action='DescribeLogStreams', body=json.dumps(params))
def describe_metric_filters(self, log_group_name, filter_name_prefix=None, next_token=None, limit=None): DCNL DCSP params = {'logGroupName': log_group_name} DCNL DCSP if (filter_name_prefix is not None): DCNL DCSP  DCSP params['filterNamePrefix'] = filter_name_prefix DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP return self.make_request(action='DescribeMetricFilters', body=json.dumps(params))
def get_log_events(self, log_group_name, log_stream_name, start_time=None, end_time=None, next_token=None, limit=None, start_from_head=None): DCNL DCSP params = {'logGroupName': log_group_name, 'logStreamName': log_stream_name} DCNL DCSP if (start_time is not None): DCNL DCSP  DCSP params['startTime'] = start_time DCNL DCSP if (end_time is not None): DCNL DCSP  DCSP params['endTime'] = end_time DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP if (start_from_head is not None): DCNL DCSP  DCSP params['startFromHead'] = start_from_head DCNL DCSP return self.make_request(action='GetLogEvents', body=json.dumps(params))
def put_log_events(self, log_group_name, log_stream_name, log_events, sequence_token=None): DCNL DCSP params = {'logGroupName': log_group_name, 'logStreamName': log_stream_name, 'logEvents': log_events} DCNL DCSP if (sequence_token is not None): DCNL DCSP  DCSP params['sequenceToken'] = sequence_token DCNL DCSP return self.make_request(action='PutLogEvents', body=json.dumps(params))
def put_metric_filter(self, log_group_name, filter_name, filter_pattern, metric_transformations): DCNL DCSP params = {'logGroupName': log_group_name, 'filterName': filter_name, 'filterPattern': filter_pattern, 'metricTransformations': metric_transformations} DCNL DCSP return self.make_request(action='PutMetricFilter', body=json.dumps(params))
def put_retention_policy(self, log_group_name, retention_in_days): DCNL DCSP params = {'logGroupName': log_group_name, 'retentionInDays': retention_in_days} DCNL DCSP return self.make_request(action='PutRetentionPolicy', body=json.dumps(params))
def set_retention(self, log_group_name, retention_in_days): DCNL DCSP params = {'logGroupName': log_group_name, 'retentionInDays': retention_in_days} DCNL DCSP return self.make_request(action='SetRetention', body=json.dumps(params))
def test_metric_filter(self, filter_pattern, log_event_messages): DCNL DCSP params = {'filterPattern': filter_pattern, 'logEventMessages': log_event_messages} DCNL DCSP return self.make_request(action='TestMetricFilter', body=json.dumps(params))
def create_cluster(self, cluster_name=None): DCNL DCSP params = {} DCNL DCSP if (cluster_name is not None): DCNL DCSP  DCSP params['clusterName'] = cluster_name DCNL DCSP return self._make_request(action='CreateCluster', verb='POST', path='/', params=params)
def delete_cluster(self, cluster): DCNL DCSP params = {'cluster': cluster} DCNL DCSP return self._make_request(action='DeleteCluster', verb='POST', path='/', params=params)
def deregister_container_instance(self, container_instance, cluster=None, force=None): DCNL DCSP params = {'containerInstance': container_instance} DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP if (force is not None): DCNL DCSP  DCSP params['force'] = str(force).lower() DCNL DCSP return self._make_request(action='DeregisterContainerInstance', verb='POST', path='/', params=params)
def deregister_task_definition(self, task_definition): DCNL DCSP params = {'taskDefinition': task_definition} DCNL DCSP return self._make_request(action='DeregisterTaskDefinition', verb='POST', path='/', params=params)
def describe_clusters(self, clusters=None): DCNL DCSP params = {} DCNL DCSP if (clusters is not None): DCNL DCSP  DCSP self.build_list_params(params, clusters, 'clusters.member') DCNL DCSP return self._make_request(action='DescribeClusters', verb='POST', path='/', params=params)
def describe_container_instances(self, container_instances, cluster=None): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, container_instances, 'containerInstances.member') DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP return self._make_request(action='DescribeContainerInstances', verb='POST', path='/', params=params)
def describe_task_definition(self, task_definition): DCNL DCSP params = {'taskDefinition': task_definition} DCNL DCSP return self._make_request(action='DescribeTaskDefinition', verb='POST', path='/', params=params)
def describe_tasks(self, tasks, cluster=None): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, tasks, 'tasks.member') DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP return self._make_request(action='DescribeTasks', verb='POST', path='/', params=params)
def discover_poll_endpoint(self, container_instance=None): DCNL DCSP params = {} DCNL DCSP if (container_instance is not None): DCNL DCSP  DCSP params['containerInstance'] = container_instance DCNL DCSP return self._make_request(action='DiscoverPollEndpoint', verb='POST', path='/', params=params)
def list_clusters(self, next_token=None, max_results=None): DCNL DCSP params = {} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['maxResults'] = max_results DCNL DCSP return self._make_request(action='ListClusters', verb='POST', path='/', params=params)
def list_container_instances(self, cluster=None, next_token=None, max_results=None): DCNL DCSP params = {} DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['maxResults'] = max_results DCNL DCSP return self._make_request(action='ListContainerInstances', verb='POST', path='/', params=params)
def list_task_definitions(self, family_prefix=None, next_token=None, max_results=None): DCNL DCSP params = {} DCNL DCSP if (family_prefix is not None): DCNL DCSP  DCSP params['familyPrefix'] = family_prefix DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['maxResults'] = max_results DCNL DCSP return self._make_request(action='ListTaskDefinitions', verb='POST', path='/', params=params)
def list_tasks(self, cluster=None, container_instance=None, family=None, next_token=None, max_results=None): DCNL DCSP params = {} DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP if (container_instance is not None): DCNL DCSP  DCSP params['containerInstance'] = container_instance DCNL DCSP if (family is not None): DCNL DCSP  DCSP params['family'] = family DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['maxResults'] = max_results DCNL DCSP return self._make_request(action='ListTasks', verb='POST', path='/', params=params)
def register_container_instance(self, cluster=None, instance_identity_document=None, instance_identity_document_signature=None, total_resources=None): DCNL DCSP params = {} DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP if (instance_identity_document is not None): DCNL DCSP  DCSP params['instanceIdentityDocument'] = instance_identity_document DCNL DCSP if (instance_identity_document_signature is not None): DCNL DCSP  DCSP params['instanceIdentityDocumentSignature'] = instance_identity_document_signature DCNL DCSP if (total_resources is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, total_resources, 'totalResources.member', ('name', 'type', 'doubleValue', 'longValue', 'integerValue', 'stringSetValue')) DCNL DCSP return self._make_request(action='RegisterContainerInstance', verb='POST', path='/', params=params)
def register_task_definition(self, family, container_definitions): DCNL DCSP params = {'family': family} DCNL DCSP self.build_complex_list_params(params, container_definitions, 'containerDefinitions.member', ('name', 'image', 'cpu', 'memory', 'links', 'portMappings', 'essential', 'entryPoint', 'command', 'environment')) DCNL DCSP return self._make_request(action='RegisterTaskDefinition', verb='POST', path='/', params=params)
def run_task(self, task_definition, cluster=None, overrides=None, count=None): DCNL DCSP params = {'taskDefinition': task_definition} DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP if (overrides is not None): DCNL DCSP  DCSP params['overrides'] = overrides DCNL DCSP if (count is not None): DCNL DCSP  DCSP params['count'] = count DCNL DCSP return self._make_request(action='RunTask', verb='POST', path='/', params=params)
def start_task(self, task_definition, container_instances, cluster=None, overrides=None): DCNL DCSP params = {'taskDefinition': task_definition} DCNL DCSP self.build_list_params(params, container_instances, 'containerInstances.member') DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP if (overrides is not None): DCNL DCSP  DCSP params['overrides'] = overrides DCNL DCSP return self._make_request(action='StartTask', verb='POST', path='/', params=params)
def stop_task(self, task, cluster=None): DCNL DCSP params = {'task': task} DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP return self._make_request(action='StopTask', verb='POST', path='/', params=params)
def submit_container_state_change(self, cluster=None, task=None, container_name=None, status=None, exit_code=None, reason=None, network_bindings=None): DCNL DCSP params = {} DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP if (task is not None): DCNL DCSP  DCSP params['task'] = task DCNL DCSP if (container_name is not None): DCNL DCSP  DCSP params['containerName'] = container_name DCNL DCSP if (status is not None): DCNL DCSP  DCSP params['status'] = status DCNL DCSP if (exit_code is not None): DCNL DCSP  DCSP params['exitCode'] = exit_code DCNL DCSP if (reason is not None): DCNL DCSP  DCSP params['reason'] = reason DCNL DCSP if (network_bindings is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, network_bindings, 'networkBindings.member', ('bindIP', 'containerPort', 'hostPort')) DCNL DCSP return self._make_request(action='SubmitContainerStateChange', verb='POST', path='/', params=params)
def submit_task_state_change(self, cluster=None, task=None, status=None, reason=None): DCNL DCSP params = {} DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP params['cluster'] = cluster DCNL DCSP if (task is not None): DCNL DCSP  DCSP params['task'] = task DCNL DCSP if (status is not None): DCNL DCSP  DCSP params['status'] = status DCNL DCSP if (reason is not None): DCNL DCSP  DCSP params['reason'] = reason DCNL DCSP return self._make_request(action='SubmitTaskStateChange', verb='POST', path='/', params=params)
def __init__(self, mailhost, username, password, fromaddr, toaddrs, subject): DCNL DCSP super(AuthSMTPHandler, self).__init__(mailhost, fromaddr, toaddrs, subject) DCNL DCSP self.username = username DCNL DCSP self.password = password
def emit(self, record): DCNL DCSP try: DCNL DCSP  DCSP port = self.mailport DCNL DCSP  DCSP if (not port): DCNL DCSP  DCSP  DCSP port = smtplib.SMTP_PORT DCNL DCSP  DCSP smtp = smtplib.SMTP(self.mailhost, port) DCNL DCSP  DCSP smtp.login(self.username, self.password) DCNL DCSP  DCSP msg = self.format(record) DCNL DCSP  DCSP msg = ('From: DCSP %s\r\nTo: DCSP %s\r\nSubject: DCSP %s\r\nDate: DCSP %s\r\n\r\n%s' % (self.fromaddr, ','.join(self.toaddrs), self.getSubject(record), email.utils.formatdate(), msg)) DCNL DCSP  DCSP smtp.sendmail(self.fromaddr, self.toaddrs, msg) DCNL DCSP  DCSP smtp.quit() DCNL DCSP except (KeyboardInterrupt, SystemExit): DCNL DCSP  DCSP raise DCNL DCSP except: DCNL DCSP  DCSP self.handleError(record)
def __init__(self, str=None, hashfunc=None): DCNL DCSP self.str = str DCNL DCSP if hashfunc: DCNL DCSP  DCSP self.hashfunc = hashfunc
def create_trail(self, name, s3_bucket_name, s3_key_prefix=None, sns_topic_name=None, include_global_service_events=None, cloud_watch_logs_log_group_arn=None, cloud_watch_logs_role_arn=None): DCNL DCSP params = {'Name': name, 'S3BucketName': s3_bucket_name} DCNL DCSP if (s3_key_prefix is not None): DCNL DCSP  DCSP params['S3KeyPrefix'] = s3_key_prefix DCNL DCSP if (sns_topic_name is not None): DCNL DCSP  DCSP params['SnsTopicName'] = sns_topic_name DCNL DCSP if (include_global_service_events is not None): DCNL DCSP  DCSP params['IncludeGlobalServiceEvents'] = include_global_service_events DCNL DCSP if (cloud_watch_logs_log_group_arn is not None): DCNL DCSP  DCSP params['CloudWatchLogsLogGroupArn'] = cloud_watch_logs_log_group_arn DCNL DCSP if (cloud_watch_logs_role_arn is not None): DCNL DCSP  DCSP params['CloudWatchLogsRoleArn'] = cloud_watch_logs_role_arn DCNL DCSP return self.make_request(action='CreateTrail', body=json.dumps(params))
def delete_trail(self, name): DCNL DCSP params = {'Name': name} DCNL DCSP return self.make_request(action='DeleteTrail', body=json.dumps(params))
def describe_trails(self, trail_name_list=None): DCNL DCSP params = {} DCNL DCSP if (trail_name_list is not None): DCNL DCSP  DCSP params['trailNameList'] = trail_name_list DCNL DCSP return self.make_request(action='DescribeTrails', body=json.dumps(params))
def get_trail_status(self, name): DCNL DCSP params = {'Name': name} DCNL DCSP return self.make_request(action='GetTrailStatus', body=json.dumps(params))
def lookup_events(self, lookup_attributes=None, start_time=None, end_time=None, max_results=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if (lookup_attributes is not None): DCNL DCSP  DCSP params['LookupAttributes'] = lookup_attributes DCNL DCSP if (start_time is not None): DCNL DCSP  DCSP params['StartTime'] = start_time DCNL DCSP if (end_time is not None): DCNL DCSP  DCSP params['EndTime'] = end_time DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['MaxResults'] = max_results DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.make_request(action='LookupEvents', body=json.dumps(params))
def start_logging(self, name): DCNL DCSP params = {'Name': name} DCNL DCSP return self.make_request(action='StartLogging', body=json.dumps(params))
def stop_logging(self, name): DCNL DCSP params = {'Name': name} DCNL DCSP return self.make_request(action='StopLogging', body=json.dumps(params))
def update_trail(self, name, s3_bucket_name=None, s3_key_prefix=None, sns_topic_name=None, include_global_service_events=None, cloud_watch_logs_log_group_arn=None, cloud_watch_logs_role_arn=None): DCNL DCSP params = {'Name': name} DCNL DCSP if (s3_bucket_name is not None): DCNL DCSP  DCSP params['S3BucketName'] = s3_bucket_name DCNL DCSP if (s3_key_prefix is not None): DCNL DCSP  DCSP params['S3KeyPrefix'] = s3_key_prefix DCNL DCSP if (sns_topic_name is not None): DCNL DCSP  DCSP params['SnsTopicName'] = sns_topic_name DCNL DCSP if (include_global_service_events is not None): DCNL DCSP  DCSP params['IncludeGlobalServiceEvents'] = include_global_service_events DCNL DCSP if (cloud_watch_logs_log_group_arn is not None): DCNL DCSP  DCSP params['CloudWatchLogsLogGroupArn'] = cloud_watch_logs_log_group_arn DCNL DCSP if (cloud_watch_logs_role_arn is not None): DCNL DCSP  DCSP params['CloudWatchLogsRoleArn'] = cloud_watch_logs_role_arn DCNL DCSP return self.make_request(action='UpdateTrail', body=json.dumps(params))
@classmethod DCNL def _normalize_request_dict(cls, data): DCNL DCSP for item in list(data.keys()): DCNL DCSP  DCSP if isinstance(data[item], dict): DCNL DCSP  DCSP  DCSP cls._normalize_request_dict(data[item]) DCNL DCSP  DCSP if (data[item] in (None, {})): DCNL DCSP  DCSP  DCSP del data[item]
def json_request(self, action, data, object_hook=None): DCNL DCSP self._normalize_request_dict(data) DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request(action, json_input, object_hook)
def make_request(self, action, body='', object_hook=None): DCNL DCSP headers = {'X-Amz-Target': ('%s.%s' % (self.ServiceName, action)), 'Host': self.region.endpoint, 'Content-Type': 'application/json; DCSP charset=UTF-8', 'Content-Encoding': 'amz-1.0', 'Content-Length': str(len(body))} DCNL DCSP http_request = self.build_base_http_request('POST', '/', '/', {}, headers, body, None) DCNL DCSP response = self._mexe(http_request, sender=None, override_num_retries=10) DCNL DCSP response_body = response.read().decode('utf-8') DCNL DCSP boto.log.debug(response_body) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP if response_body: DCNL DCSP  DCSP  DCSP return json.loads(response_body, object_hook=object_hook) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP json_body = json.loads(response_body) DCNL DCSP  DCSP fault_name = json_body.get('__type', None) DCNL DCSP  DCSP excp_cls = self._fault_excp.get(fault_name, self.ResponseError) DCNL DCSP  DCSP raise excp_cls(response.status, response.reason, body=json_body)
def poll_for_activity_task(self, domain, task_list, identity=None): DCNL DCSP return self.json_request('PollForActivityTask', {'domain': domain, 'taskList': {'name': task_list}, 'identity': identity})
def respond_activity_task_completed(self, task_token, result=None): DCNL DCSP return self.json_request('RespondActivityTaskCompleted', {'taskToken': task_token, 'result': result})
def respond_activity_task_failed(self, task_token, details=None, reason=None): DCNL DCSP return self.json_request('RespondActivityTaskFailed', {'taskToken': task_token, 'details': details, 'reason': reason})
def respond_activity_task_canceled(self, task_token, details=None): DCNL DCSP return self.json_request('RespondActivityTaskCanceled', {'taskToken': task_token, 'details': details})
def record_activity_task_heartbeat(self, task_token, details=None): DCNL DCSP return self.json_request('RecordActivityTaskHeartbeat', {'taskToken': task_token, 'details': details})
def poll_for_decision_task(self, domain, task_list, identity=None, maximum_page_size=None, next_page_token=None, reverse_order=None): DCNL DCSP return self.json_request('PollForDecisionTask', {'domain': domain, 'taskList': {'name': task_list}, 'identity': identity, 'maximumPageSize': maximum_page_size, 'nextPageToken': next_page_token, 'reverseOrder': reverse_order})
def respond_decision_task_completed(self, task_token, decisions=None, execution_context=None): DCNL DCSP return self.json_request('RespondDecisionTaskCompleted', {'taskToken': task_token, 'decisions': decisions, 'executionContext': execution_context})
def request_cancel_workflow_execution(self, domain, workflow_id, run_id=None): DCNL DCSP return self.json_request('RequestCancelWorkflowExecution', {'domain': domain, 'workflowId': workflow_id, 'runId': run_id})
def start_workflow_execution(self, domain, workflow_id, workflow_name, workflow_version, task_list=None, child_policy=None, execution_start_to_close_timeout=None, input=None, tag_list=None, task_start_to_close_timeout=None): DCNL DCSP return self.json_request('StartWorkflowExecution', {'domain': domain, 'workflowId': workflow_id, 'workflowType': {'name': workflow_name, 'version': workflow_version}, 'taskList': {'name': task_list}, 'childPolicy': child_policy, 'executionStartToCloseTimeout': execution_start_to_close_timeout, 'input': input, 'tagList': tag_list, 'taskStartToCloseTimeout': task_start_to_close_timeout})
def signal_workflow_execution(self, domain, signal_name, workflow_id, input=None, run_id=None): DCNL DCSP return self.json_request('SignalWorkflowExecution', {'domain': domain, 'signalName': signal_name, 'workflowId': workflow_id, 'input': input, 'runId': run_id})
def terminate_workflow_execution(self, domain, workflow_id, child_policy=None, details=None, reason=None, run_id=None): DCNL DCSP return self.json_request('TerminateWorkflowExecution', {'domain': domain, 'workflowId': workflow_id, 'childPolicy': child_policy, 'details': details, 'reason': reason, 'runId': run_id})
def register_activity_type(self, domain, name, version, task_list=None, default_task_heartbeat_timeout=None, default_task_schedule_to_close_timeout=None, default_task_schedule_to_start_timeout=None, default_task_start_to_close_timeout=None, description=None): DCNL DCSP return self.json_request('RegisterActivityType', {'domain': domain, 'name': name, 'version': version, 'defaultTaskList': {'name': task_list}, 'defaultTaskHeartbeatTimeout': default_task_heartbeat_timeout, 'defaultTaskScheduleToCloseTimeout': default_task_schedule_to_close_timeout, 'defaultTaskScheduleToStartTimeout': default_task_schedule_to_start_timeout, 'defaultTaskStartToCloseTimeout': default_task_start_to_close_timeout, 'description': description})
def deprecate_activity_type(self, domain, activity_name, activity_version): DCNL DCSP return self.json_request('DeprecateActivityType', {'domain': domain, 'activityType': {'name': activity_name, 'version': activity_version}})
def register_workflow_type(self, domain, name, version, task_list=None, default_child_policy=None, default_execution_start_to_close_timeout=None, default_task_start_to_close_timeout=None, description=None): DCNL DCSP return self.json_request('RegisterWorkflowType', {'domain': domain, 'name': name, 'version': version, 'defaultTaskList': {'name': task_list}, 'defaultChildPolicy': default_child_policy, 'defaultExecutionStartToCloseTimeout': default_execution_start_to_close_timeout, 'defaultTaskStartToCloseTimeout': default_task_start_to_close_timeout, 'description': description})
def deprecate_workflow_type(self, domain, workflow_name, workflow_version): DCNL DCSP return self.json_request('DeprecateWorkflowType', {'domain': domain, 'workflowType': {'name': workflow_name, 'version': workflow_version}})
def register_domain(self, name, workflow_execution_retention_period_in_days, description=None): DCNL DCSP return self.json_request('RegisterDomain', {'name': name, 'workflowExecutionRetentionPeriodInDays': workflow_execution_retention_period_in_days, 'description': description})
def deprecate_domain(self, name): DCNL DCSP return self.json_request('DeprecateDomain', {'name': name})
def list_activity_types(self, domain, registration_status, name=None, maximum_page_size=None, next_page_token=None, reverse_order=None): DCNL DCSP return self.json_request('ListActivityTypes', {'domain': domain, 'name': name, 'registrationStatus': registration_status, 'maximumPageSize': maximum_page_size, 'nextPageToken': next_page_token, 'reverseOrder': reverse_order})
def describe_activity_type(self, domain, activity_name, activity_version): DCNL DCSP return self.json_request('DescribeActivityType', {'domain': domain, 'activityType': {'name': activity_name, 'version': activity_version}})
def list_workflow_types(self, domain, registration_status, maximum_page_size=None, name=None, next_page_token=None, reverse_order=None): DCNL DCSP return self.json_request('ListWorkflowTypes', {'domain': domain, 'name': name, 'registrationStatus': registration_status, 'maximumPageSize': maximum_page_size, 'nextPageToken': next_page_token, 'reverseOrder': reverse_order})
def describe_workflow_type(self, domain, workflow_name, workflow_version): DCNL DCSP return self.json_request('DescribeWorkflowType', {'domain': domain, 'workflowType': {'name': workflow_name, 'version': workflow_version}})
def describe_workflow_execution(self, domain, run_id, workflow_id): DCNL DCSP return self.json_request('DescribeWorkflowExecution', {'domain': domain, 'execution': {'runId': run_id, 'workflowId': workflow_id}})
def get_workflow_execution_history(self, domain, run_id, workflow_id, maximum_page_size=None, next_page_token=None, reverse_order=None): DCNL DCSP return self.json_request('GetWorkflowExecutionHistory', {'domain': domain, 'execution': {'runId': run_id, 'workflowId': workflow_id}, 'maximumPageSize': maximum_page_size, 'nextPageToken': next_page_token, 'reverseOrder': reverse_order})
def count_open_workflow_executions(self, domain, latest_date, oldest_date, tag=None, workflow_id=None, workflow_name=None, workflow_version=None): DCNL DCSP return self.json_request('CountOpenWorkflowExecutions', {'domain': domain, 'startTimeFilter': {'oldestDate': oldest_date, 'latestDate': latest_date}, 'typeFilter': {'name': workflow_name, 'version': workflow_version}, 'executionFilter': {'workflowId': workflow_id}, 'tagFilter': {'tag': tag}})
def list_open_workflow_executions(self, domain, oldest_date, latest_date=None, tag=None, workflow_id=None, workflow_name=None, workflow_version=None, maximum_page_size=None, next_page_token=None, reverse_order=None): DCNL DCSP return self.json_request('ListOpenWorkflowExecutions', {'domain': domain, 'startTimeFilter': {'oldestDate': oldest_date, 'latestDate': latest_date}, 'tagFilter': {'tag': tag}, 'typeFilter': {'name': workflow_name, 'version': workflow_version}, 'executionFilter': {'workflowId': workflow_id}, 'maximumPageSize': maximum_page_size, 'nextPageToken': next_page_token, 'reverseOrder': reverse_order})
def count_closed_workflow_executions(self, domain, start_latest_date=None, start_oldest_date=None, close_latest_date=None, close_oldest_date=None, close_status=None, tag=None, workflow_id=None, workflow_name=None, workflow_version=None): DCNL DCSP return self.json_request('CountClosedWorkflowExecutions', {'domain': domain, 'startTimeFilter': {'oldestDate': start_oldest_date, 'latestDate': start_latest_date}, 'closeTimeFilter': {'oldestDate': close_oldest_date, 'latestDate': close_latest_date}, 'closeStatusFilter': {'status': close_status}, 'tagFilter': {'tag': tag}, 'typeFilter': {'name': workflow_name, 'version': workflow_version}, 'executionFilter': {'workflowId': workflow_id}})
def list_closed_workflow_executions(self, domain, start_latest_date=None, start_oldest_date=None, close_latest_date=None, close_oldest_date=None, close_status=None, tag=None, workflow_id=None, workflow_name=None, workflow_version=None, maximum_page_size=None, next_page_token=None, reverse_order=None): DCNL DCSP return self.json_request('ListClosedWorkflowExecutions', {'domain': domain, 'startTimeFilter': {'oldestDate': start_oldest_date, 'latestDate': start_latest_date}, 'closeTimeFilter': {'oldestDate': close_oldest_date, 'latestDate': close_latest_date}, 'executionFilter': {'workflowId': workflow_id}, 'closeStatusFilter': {'status': close_status}, 'tagFilter': {'tag': tag}, 'typeFilter': {'name': workflow_name, 'version': workflow_version}, 'maximumPageSize': maximum_page_size, 'nextPageToken': next_page_token, 'reverseOrder': reverse_order})
def list_domains(self, registration_status, maximum_page_size=None, next_page_token=None, reverse_order=None): DCNL DCSP return self.json_request('ListDomains', {'registrationStatus': registration_status, 'maximumPageSize': maximum_page_size, 'nextPageToken': next_page_token, 'reverseOrder': reverse_order})
def describe_domain(self, name): DCNL DCSP return self.json_request('DescribeDomain', {'name': name})
def count_pending_decision_tasks(self, domain, task_list): DCNL DCSP return self.json_request('CountPendingDecisionTasks', {'domain': domain, 'taskList': {'name': task_list}})
def count_pending_activity_tasks(self, domain, task_list): DCNL DCSP return self.json_request('CountPendingActivityTasks', {'domain': domain, 'taskList': {'name': task_list}})
def schedule_activity_task(self, activity_id, activity_type_name, activity_type_version, task_list=None, control=None, heartbeat_timeout=None, schedule_to_close_timeout=None, schedule_to_start_timeout=None, start_to_close_timeout=None, input=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'ScheduleActivityTask' DCNL DCSP attrs = o['scheduleActivityTaskDecisionAttributes'] = {} DCNL DCSP attrs['activityId'] = activity_id DCNL DCSP attrs['activityType'] = {'name': activity_type_name, 'version': activity_type_version} DCNL DCSP if (task_list is not None): DCNL DCSP  DCSP attrs['taskList'] = {'name': task_list} DCNL DCSP if (control is not None): DCNL DCSP  DCSP attrs['control'] = control DCNL DCSP if (heartbeat_timeout is not None): DCNL DCSP  DCSP attrs['heartbeatTimeout'] = heartbeat_timeout DCNL DCSP if (schedule_to_close_timeout is not None): DCNL DCSP  DCSP attrs['scheduleToCloseTimeout'] = schedule_to_close_timeout DCNL DCSP if (schedule_to_start_timeout is not None): DCNL DCSP  DCSP attrs['scheduleToStartTimeout'] = schedule_to_start_timeout DCNL DCSP if (start_to_close_timeout is not None): DCNL DCSP  DCSP attrs['startToCloseTimeout'] = start_to_close_timeout DCNL DCSP if (input is not None): DCNL DCSP  DCSP attrs['input'] = input DCNL DCSP self._data.append(o)
def request_cancel_activity_task(self, activity_id): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'RequestCancelActivityTask' DCNL DCSP attrs = o['requestCancelActivityTaskDecisionAttributes'] = {} DCNL DCSP attrs['activityId'] = activity_id DCNL DCSP self._data.append(o)
def record_marker(self, marker_name, details=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'RecordMarker' DCNL DCSP attrs = o['recordMarkerDecisionAttributes'] = {} DCNL DCSP attrs['markerName'] = marker_name DCNL DCSP if (details is not None): DCNL DCSP  DCSP attrs['details'] = details DCNL DCSP self._data.append(o)
def complete_workflow_execution(self, result=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'CompleteWorkflowExecution' DCNL DCSP attrs = o['completeWorkflowExecutionDecisionAttributes'] = {} DCNL DCSP if (result is not None): DCNL DCSP  DCSP attrs['result'] = result DCNL DCSP self._data.append(o)
def fail_workflow_execution(self, reason=None, details=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'FailWorkflowExecution' DCNL DCSP attrs = o['failWorkflowExecutionDecisionAttributes'] = {} DCNL DCSP if (reason is not None): DCNL DCSP  DCSP attrs['reason'] = reason DCNL DCSP if (details is not None): DCNL DCSP  DCSP attrs['details'] = details DCNL DCSP self._data.append(o)
def cancel_workflow_executions(self, details=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'CancelWorkflowExecution' DCNL DCSP attrs = o['cancelWorkflowExecutionsDecisionAttributes'] = {} DCNL DCSP if (details is not None): DCNL DCSP  DCSP attrs['details'] = details DCNL DCSP self._data.append(o)
def continue_as_new_workflow_execution(self, child_policy=None, execution_start_to_close_timeout=None, input=None, tag_list=None, task_list=None, start_to_close_timeout=None, workflow_type_version=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'ContinueAsNewWorkflowExecution' DCNL DCSP attrs = o['continueAsNewWorkflowExecutionDecisionAttributes'] = {} DCNL DCSP if (child_policy is not None): DCNL DCSP  DCSP attrs['childPolicy'] = child_policy DCNL DCSP if (execution_start_to_close_timeout is not None): DCNL DCSP  DCSP attrs['executionStartToCloseTimeout'] = execution_start_to_close_timeout DCNL DCSP if (input is not None): DCNL DCSP  DCSP attrs['input'] = input DCNL DCSP if (tag_list is not None): DCNL DCSP  DCSP attrs['tagList'] = tag_list DCNL DCSP if (task_list is not None): DCNL DCSP  DCSP attrs['taskList'] = {'name': task_list} DCNL DCSP if (start_to_close_timeout is not None): DCNL DCSP  DCSP attrs['taskStartToCloseTimeout'] = start_to_close_timeout DCNL DCSP if (workflow_type_version is not None): DCNL DCSP  DCSP attrs['workflowTypeVersion'] = workflow_type_version DCNL DCSP self._data.append(o)
def start_timer(self, start_to_fire_timeout, timer_id, control=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'StartTimer' DCNL DCSP attrs = o['startTimerDecisionAttributes'] = {} DCNL DCSP attrs['startToFireTimeout'] = start_to_fire_timeout DCNL DCSP attrs['timerId'] = timer_id DCNL DCSP if (control is not None): DCNL DCSP  DCSP attrs['control'] = control DCNL DCSP self._data.append(o)
def cancel_timer(self, timer_id): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'CancelTimer' DCNL DCSP attrs = o['cancelTimerDecisionAttributes'] = {} DCNL DCSP attrs['timerId'] = timer_id DCNL DCSP self._data.append(o)
def signal_external_workflow_execution(self, workflow_id, signal_name, run_id=None, control=None, input=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'SignalExternalWorkflowExecution' DCNL DCSP attrs = o['signalExternalWorkflowExecutionDecisionAttributes'] = {} DCNL DCSP attrs['workflowId'] = workflow_id DCNL DCSP attrs['signalName'] = signal_name DCNL DCSP if (run_id is not None): DCNL DCSP  DCSP attrs['runId'] = run_id DCNL DCSP if (control is not None): DCNL DCSP  DCSP attrs['control'] = control DCNL DCSP if (input is not None): DCNL DCSP  DCSP attrs['input'] = input DCNL DCSP self._data.append(o)
def request_cancel_external_workflow_execution(self, workflow_id, control=None, run_id=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'RequestCancelExternalWorkflowExecution' DCNL DCSP attrs = o['requestCancelExternalWorkflowExecutionDecisionAttributes'] = {} DCNL DCSP attrs['workflowId'] = workflow_id DCNL DCSP if (control is not None): DCNL DCSP  DCSP attrs['control'] = control DCNL DCSP if (run_id is not None): DCNL DCSP  DCSP attrs['runId'] = run_id DCNL DCSP self._data.append(o)
def start_child_workflow_execution(self, workflow_type_name, workflow_type_version, workflow_id, child_policy=None, control=None, execution_start_to_close_timeout=None, input=None, tag_list=None, task_list=None, task_start_to_close_timeout=None): DCNL DCSP o = {} DCNL DCSP o['decisionType'] = 'StartChildWorkflowExecution' DCNL DCSP attrs = o['startChildWorkflowExecutionDecisionAttributes'] = {} DCNL DCSP attrs['workflowType'] = {'name': workflow_type_name, 'version': workflow_type_version} DCNL DCSP attrs['workflowId'] = workflow_id DCNL DCSP if (child_policy is not None): DCNL DCSP  DCSP attrs['childPolicy'] = child_policy DCNL DCSP if (control is not None): DCNL DCSP  DCSP attrs['control'] = control DCNL DCSP if (execution_start_to_close_timeout is not None): DCNL DCSP  DCSP attrs['executionStartToCloseTimeout'] = execution_start_to_close_timeout DCNL DCSP if (input is not None): DCNL DCSP  DCSP attrs['input'] = input DCNL DCSP if (tag_list is not None): DCNL DCSP  DCSP attrs['tagList'] = tag_list DCNL DCSP if (task_list is not None): DCNL DCSP  DCSP attrs['taskList'] = {'name': task_list} DCNL DCSP if (task_start_to_close_timeout is not None): DCNL DCSP  DCSP attrs['taskStartToCloseTimeout'] = task_start_to_close_timeout DCNL DCSP self._data.append(o)
@wraps(Layer1.describe_domain) DCNL def describe(self): DCNL DCSP return self._swf.describe_domain(self.name)
@wraps(Layer1.deprecate_domain) DCNL def deprecate(self): DCNL DCSP self._swf.deprecate_domain(self.name)
@wraps(Layer1.register_domain) DCNL def register(self): DCNL DCSP self._swf.register_domain(self.name, str(self.retention), self.description)
@wraps(Layer1.list_activity_types) DCNL def activities(self, status='REGISTERED', **kwargs): DCNL DCSP act_types = self._swf.list_activity_types(self.name, status, **kwargs) DCNL DCSP act_objects = [] DCNL DCSP for act_args in act_types['typeInfos']: DCNL DCSP  DCSP act_ident = act_args['activityType'] DCNL DCSP  DCSP del act_args['activityType'] DCNL DCSP  DCSP act_args.update(act_ident) DCNL DCSP  DCSP act_args.update({'aws_access_key_id': self.aws_access_key_id, 'aws_secret_access_key': self.aws_secret_access_key, 'domain': self.name, 'region': self.region}) DCNL DCSP  DCSP act_objects.append(ActivityType(**act_args)) DCNL DCSP return act_objects
@wraps(Layer1.list_workflow_types) DCNL def workflows(self, status='REGISTERED', **kwargs): DCNL DCSP wf_types = self._swf.list_workflow_types(self.name, status, **kwargs) DCNL DCSP wf_objects = [] DCNL DCSP for wf_args in wf_types['typeInfos']: DCNL DCSP  DCSP wf_ident = wf_args['workflowType'] DCNL DCSP  DCSP del wf_args['workflowType'] DCNL DCSP  DCSP wf_args.update(wf_ident) DCNL DCSP  DCSP wf_args.update({'aws_access_key_id': self.aws_access_key_id, 'aws_secret_access_key': self.aws_secret_access_key, 'domain': self.name, 'region': self.region}) DCNL DCSP  DCSP wf_objects.append(WorkflowType(**wf_args)) DCNL DCSP return wf_objects
def executions(self, closed=False, **kwargs): DCNL DCSP if closed: DCNL DCSP  DCSP executions = self._swf.list_closed_workflow_executions(self.name, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP if ('oldest_date' not in kwargs): DCNL DCSP  DCSP  DCSP kwargs['oldest_date'] = (time.time() - (3600 * 24)) DCNL DCSP  DCSP executions = self._swf.list_open_workflow_executions(self.name, **kwargs) DCNL DCSP exe_objects = [] DCNL DCSP for exe_args in executions['executionInfos']: DCNL DCSP  DCSP for nested_key in ('execution', 'workflowType'): DCNL DCSP  DCSP  DCSP nested_dict = exe_args[nested_key] DCNL DCSP  DCSP  DCSP del exe_args[nested_key] DCNL DCSP  DCSP  DCSP exe_args.update(nested_dict) DCNL DCSP  DCSP exe_args.update({'aws_access_key_id': self.aws_access_key_id, 'aws_secret_access_key': self.aws_secret_access_key, 'domain': self.name, 'region': self.region}) DCNL DCSP  DCSP exe_objects.append(WorkflowExecution(**exe_args)) DCNL DCSP return exe_objects
@wraps(Layer1.count_pending_activity_tasks) DCNL def count_pending_activity_tasks(self, task_list): DCNL DCSP return self._swf.count_pending_activity_tasks(self.name, task_list)
@wraps(Layer1.count_pending_decision_tasks) DCNL def count_pending_decision_tasks(self, task_list): DCNL DCSP return self._swf.count_pending_decision_tasks(self.name, task_list)
def run(self): DCNL DCSP raise NotImplementedError()
@wraps(Layer1.respond_activity_task_canceled) DCNL def cancel(self, task_token=None, details=None): DCNL DCSP if (task_token is None): DCNL DCSP  DCSP task_token = self.last_tasktoken DCNL DCSP return self._swf.respond_activity_task_canceled(task_token, details)
@wraps(Layer1.respond_activity_task_completed) DCNL def complete(self, task_token=None, result=None): DCNL DCSP if (task_token is None): DCNL DCSP  DCSP task_token = self.last_tasktoken DCNL DCSP return self._swf.respond_activity_task_completed(task_token, result)
@wraps(Layer1.respond_activity_task_failed) DCNL def fail(self, task_token=None, details=None, reason=None): DCNL DCSP if (task_token is None): DCNL DCSP  DCSP task_token = self.last_tasktoken DCNL DCSP return self._swf.respond_activity_task_failed(task_token, details, reason)
@wraps(Layer1.record_activity_task_heartbeat) DCNL def heartbeat(self, task_token=None, details=None): DCNL DCSP if (task_token is None): DCNL DCSP  DCSP task_token = self.last_tasktoken DCNL DCSP return self._swf.record_activity_task_heartbeat(task_token, details)
@wraps(Layer1.poll_for_activity_task) DCNL def poll(self, **kwargs): DCNL DCSP task_list = self.task_list DCNL DCSP if ('task_list' in kwargs): DCNL DCSP  DCSP task_list = kwargs.get('task_list') DCNL DCSP  DCSP del kwargs['task_list'] DCNL DCSP task = self._swf.poll_for_activity_task(self.domain, task_list, **kwargs) DCNL DCSP self.last_tasktoken = task.get('taskToken') DCNL DCSP return task
@wraps(Layer1.respond_decision_task_completed) DCNL def complete(self, task_token=None, decisions=None, **kwargs): DCNL DCSP if isinstance(decisions, Layer1Decisions): DCNL DCSP  DCSP decisions = decisions._data DCNL DCSP if (task_token is None): DCNL DCSP  DCSP task_token = self.last_tasktoken DCNL DCSP return self._swf.respond_decision_task_completed(task_token, decisions, **kwargs)
@wraps(Layer1.poll_for_decision_task) DCNL def poll(self, **kwargs): DCNL DCSP task_list = self.task_list DCNL DCSP if ('task_list' in kwargs): DCNL DCSP  DCSP task_list = kwargs.get('task_list') DCNL DCSP  DCSP del kwargs['task_list'] DCNL DCSP decision_task = self._swf.poll_for_decision_task(self.domain, task_list, **kwargs) DCNL DCSP self.last_tasktoken = decision_task.get('taskToken') DCNL DCSP return decision_task
@wraps(Layer1.describe_workflow_type) DCNL def describe(self): DCNL DCSP return self._swf.describe_workflow_type(self.domain, self.name, self.version)
@wraps(Layer1.register_workflow_type) DCNL def register(self, **kwargs): DCNL DCSP args = {'default_execution_start_to_close_timeout': '3600', 'default_task_start_to_close_timeout': '300', 'default_child_policy': 'TERMINATE'} DCNL DCSP args.update(kwargs) DCNL DCSP self._swf.register_workflow_type(self.domain, self.name, self.version, **args)
@wraps(Layer1.deprecate_workflow_type) DCNL def deprecate(self): DCNL DCSP self._swf.deprecate_workflow_type(self.domain, self.name, self.version)
@wraps(Layer1.start_workflow_execution) DCNL def start(self, **kwargs): DCNL DCSP if ('workflow_id' in kwargs): DCNL DCSP  DCSP workflow_id = kwargs['workflow_id'] DCNL DCSP  DCSP del kwargs['workflow_id'] DCNL DCSP else: DCNL DCSP  DCSP workflow_id = ('%s-%s-%i' % (self.name, self.version, time.time())) DCNL DCSP for def_attr in ('task_list', 'child_policy'): DCNL DCSP  DCSP kwargs[def_attr] = kwargs.get(def_attr, getattr(self, def_attr)) DCNL DCSP run_id = self._swf.start_workflow_execution(self.domain, workflow_id, self.name, self.version, **kwargs)['runId'] DCNL DCSP return WorkflowExecution(name=self.name, version=self.version, runId=run_id, domain=self.domain, workflowId=workflow_id, aws_access_key_id=self.aws_access_key_id, aws_secret_access_key=self.aws_secret_access_key)
@wraps(Layer1.signal_workflow_execution) DCNL def signal(self, signame, **kwargs): DCNL DCSP self._swf.signal_workflow_execution(self.domain, signame, self.workflowId, **kwargs)
@wraps(Layer1.terminate_workflow_execution) DCNL def terminate(self, **kwargs): DCNL DCSP return self._swf.terminate_workflow_execution(self.domain, self.workflowId, **kwargs)
@wraps(Layer1.get_workflow_execution_history) DCNL def history(self, **kwargs): DCNL DCSP return self._swf.get_workflow_execution_history(self.domain, self.runId, self.workflowId, **kwargs)['events']
@wraps(Layer1.describe_workflow_execution) DCNL def describe(self): DCNL DCSP return self._swf.describe_workflow_execution(self.domain, self.runId, self.workflowId)
@wraps(Layer1.request_cancel_workflow_execution) DCNL def request_cancel(self): DCNL DCSP return self._swf.request_cancel_workflow_execution(self.domain, self.workflowId, self.runId)
@wraps(Layer1.deprecate_activity_type) DCNL def deprecate(self): DCNL DCSP return self._swf.deprecate_activity_type(self.domain, self.name, self.version)
@wraps(Layer1.describe_activity_type) DCNL def describe(self): DCNL DCSP return self._swf.describe_activity_type(self.domain, self.name, self.version)
@wraps(Layer1.register_activity_type) DCNL def register(self, **kwargs): DCNL DCSP args = {'default_task_heartbeat_timeout': '600', 'default_task_schedule_to_close_timeout': '3900', 'default_task_schedule_to_start_timeout': '300', 'default_task_start_to_close_timeout': '3600'} DCNL DCSP args.update(kwargs) DCNL DCSP self._swf.register_activity_type(self.domain, self.name, self.version, **args)
@classmethod DCNL def Inventory(cls): DCNL DCSP l = ServerSet() DCNL DCSP rs = cls.find() DCNL DCSP for server in rs: DCNL DCSP  DCSP l.append(server) DCNL DCSP return l
def set_config(self, config): DCNL DCSP self._config = config DCNL DCSP self._config.dump_to_sdb('botoConfigs', self.id)
def attach_volume(self, volume, device='/dev/sdp'): DCNL DCSP if hasattr(volume, 'id'): DCNL DCSP  DCSP volume_id = volume.id DCNL DCSP else: DCNL DCSP  DCSP volume_id = volume DCNL DCSP return self.ec2.attach_volume(volume_id=volume_id, instance_id=self.instance_id, device=device)
def detach_volume(self, volume): DCNL DCSP if hasattr(volume, 'id'): DCNL DCSP  DCSP volume_id = volume.id DCNL DCSP else: DCNL DCSP  DCSP volume_id = volume DCNL DCSP return self.ec2.detach_volume(volume_id=volume_id, instance_id=self.instance_id)
def add_source_identifier_to_subscription(self, subscription_name, source_identifier): DCNL DCSP params = {'SubscriptionName': subscription_name, 'SourceIdentifier': source_identifier} DCNL DCSP return self._make_request(action='AddSourceIdentifierToSubscription', verb='POST', path='/', params=params)
def add_tags_to_resource(self, resource_name, tags): DCNL DCSP params = {'ResourceName': resource_name} DCNL DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='AddTagsToResource', verb='POST', path='/', params=params)
def authorize_db_security_group_ingress(self, db_security_group_name, cidrip=None, ec2_security_group_name=None, ec2_security_group_id=None, ec2_security_group_owner_id=None): DCNL DCSP params = {'DBSecurityGroupName': db_security_group_name} DCNL DCSP if (cidrip is not None): DCNL DCSP  DCSP params['CIDRIP'] = cidrip DCNL DCSP if (ec2_security_group_name is not None): DCNL DCSP  DCSP params['EC2SecurityGroupName'] = ec2_security_group_name DCNL DCSP if (ec2_security_group_id is not None): DCNL DCSP  DCSP params['EC2SecurityGroupId'] = ec2_security_group_id DCNL DCSP if (ec2_security_group_owner_id is not None): DCNL DCSP  DCSP params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id DCNL DCSP return self._make_request(action='AuthorizeDBSecurityGroupIngress', verb='POST', path='/', params=params)
def copy_db_snapshot(self, source_db_snapshot_identifier, target_db_snapshot_identifier, tags=None): DCNL DCSP params = {'SourceDBSnapshotIdentifier': source_db_snapshot_identifier, 'TargetDBSnapshotIdentifier': target_db_snapshot_identifier} DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='CopyDBSnapshot', verb='POST', path='/', params=params)
def create_db_instance(self, db_instance_identifier, allocated_storage, db_instance_class, engine, master_username, master_user_password, db_name=None, db_security_groups=None, vpc_security_group_ids=None, availability_zone=None, db_subnet_group_name=None, preferred_maintenance_window=None, db_parameter_group_name=None, backup_retention_period=None, preferred_backup_window=None, port=None, multi_az=None, engine_version=None, auto_minor_version_upgrade=None, license_model=None, iops=None, option_group_name=None, character_set_name=None, publicly_accessible=None, tags=None): DCNL DCSP params = {'DBInstanceIdentifier': db_instance_identifier, 'AllocatedStorage': allocated_storage, 'DBInstanceClass': db_instance_class, 'Engine': engine, 'MasterUsername': master_username, 'MasterUserPassword': master_user_password} DCNL DCSP if (db_name is not None): DCNL DCSP  DCSP params['DBName'] = db_name DCNL DCSP if (db_security_groups is not None): DCNL DCSP  DCSP self.build_list_params(params, db_security_groups, 'DBSecurityGroups.member') DCNL DCSP if (vpc_security_group_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, vpc_security_group_ids, 'VpcSecurityGroupIds.member') DCNL DCSP if (availability_zone is not None): DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (db_subnet_group_name is not None): DCNL DCSP  DCSP params['DBSubnetGroupName'] = db_subnet_group_name DCNL DCSP if (preferred_maintenance_window is not None): DCNL DCSP  DCSP params['PreferredMaintenanceWindow'] = preferred_maintenance_window DCNL DCSP if (db_parameter_group_name is not None): DCNL DCSP  DCSP params['DBParameterGroupName'] = db_parameter_group_name DCNL DCSP if (backup_retention_period is not None): DCNL DCSP  DCSP params['BackupRetentionPeriod'] = backup_retention_period DCNL DCSP if (preferred_backup_window is not None): DCNL DCSP  DCSP params['PreferredBackupWindow'] = preferred_backup_window DCNL DCSP if (port is not None): DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if (multi_az is not None): DCNL DCSP  DCSP params['MultiAZ'] = str(multi_az).lower() DCNL DCSP if (engine_version is not None): DCNL DCSP  DCSP params['EngineVersion'] = engine_version DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower() DCNL DCSP if (license_model is not None): DCNL DCSP  DCSP params['LicenseModel'] = license_model DCNL DCSP if (iops is not None): DCNL DCSP  DCSP params['Iops'] = iops DCNL DCSP if (option_group_name is not None): DCNL DCSP  DCSP params['OptionGroupName'] = option_group_name DCNL DCSP if (character_set_name is not None): DCNL DCSP  DCSP params['CharacterSetName'] = character_set_name DCNL DCSP if (publicly_accessible is not None): DCNL DCSP  DCSP params['PubliclyAccessible'] = str(publicly_accessible).lower() DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='CreateDBInstance', verb='POST', path='/', params=params)
def create_db_instance_read_replica(self, db_instance_identifier, source_db_instance_identifier, db_instance_class=None, availability_zone=None, port=None, auto_minor_version_upgrade=None, iops=None, option_group_name=None, publicly_accessible=None, tags=None): DCNL DCSP params = {'DBInstanceIdentifier': db_instance_identifier, 'SourceDBInstanceIdentifier': source_db_instance_identifier} DCNL DCSP if (db_instance_class is not None): DCNL DCSP  DCSP params['DBInstanceClass'] = db_instance_class DCNL DCSP if (availability_zone is not None): DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (port is not None): DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower() DCNL DCSP if (iops is not None): DCNL DCSP  DCSP params['Iops'] = iops DCNL DCSP if (option_group_name is not None): DCNL DCSP  DCSP params['OptionGroupName'] = option_group_name DCNL DCSP if (publicly_accessible is not None): DCNL DCSP  DCSP params['PubliclyAccessible'] = str(publicly_accessible).lower() DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='CreateDBInstanceReadReplica', verb='POST', path='/', params=params)
def create_db_parameter_group(self, db_parameter_group_name, db_parameter_group_family, description, tags=None): DCNL DCSP params = {'DBParameterGroupName': db_parameter_group_name, 'DBParameterGroupFamily': db_parameter_group_family, 'Description': description} DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='CreateDBParameterGroup', verb='POST', path='/', params=params)
def create_db_security_group(self, db_security_group_name, db_security_group_description, tags=None): DCNL DCSP params = {'DBSecurityGroupName': db_security_group_name, 'DBSecurityGroupDescription': db_security_group_description} DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='CreateDBSecurityGroup', verb='POST', path='/', params=params)
def create_db_snapshot(self, db_snapshot_identifier, db_instance_identifier, tags=None): DCNL DCSP params = {'DBSnapshotIdentifier': db_snapshot_identifier, 'DBInstanceIdentifier': db_instance_identifier} DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='CreateDBSnapshot', verb='POST', path='/', params=params)
def create_db_subnet_group(self, db_subnet_group_name, db_subnet_group_description, subnet_ids, tags=None): DCNL DCSP params = {'DBSubnetGroupName': db_subnet_group_name, 'DBSubnetGroupDescription': db_subnet_group_description} DCNL DCSP self.build_list_params(params, subnet_ids, 'SubnetIds.member') DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='CreateDBSubnetGroup', verb='POST', path='/', params=params)
def create_event_subscription(self, subscription_name, sns_topic_arn, source_type=None, event_categories=None, source_ids=None, enabled=None, tags=None): DCNL DCSP params = {'SubscriptionName': subscription_name, 'SnsTopicArn': sns_topic_arn} DCNL DCSP if (source_type is not None): DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP if (event_categories is not None): DCNL DCSP  DCSP self.build_list_params(params, event_categories, 'EventCategories.member') DCNL DCSP if (source_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, source_ids, 'SourceIds.member') DCNL DCSP if (enabled is not None): DCNL DCSP  DCSP params['Enabled'] = str(enabled).lower() DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='CreateEventSubscription', verb='POST', path='/', params=params)
def create_option_group(self, option_group_name, engine_name, major_engine_version, option_group_description, tags=None): DCNL DCSP params = {'OptionGroupName': option_group_name, 'EngineName': engine_name, 'MajorEngineVersion': major_engine_version, 'OptionGroupDescription': option_group_description} DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='CreateOptionGroup', verb='POST', path='/', params=params)
def delete_db_instance(self, db_instance_identifier, skip_final_snapshot=None, final_db_snapshot_identifier=None): DCNL DCSP params = {'DBInstanceIdentifier': db_instance_identifier} DCNL DCSP if (skip_final_snapshot is not None): DCNL DCSP  DCSP params['SkipFinalSnapshot'] = str(skip_final_snapshot).lower() DCNL DCSP if (final_db_snapshot_identifier is not None): DCNL DCSP  DCSP params['FinalDBSnapshotIdentifier'] = final_db_snapshot_identifier DCNL DCSP return self._make_request(action='DeleteDBInstance', verb='POST', path='/', params=params)
def delete_db_parameter_group(self, db_parameter_group_name): DCNL DCSP params = {'DBParameterGroupName': db_parameter_group_name} DCNL DCSP return self._make_request(action='DeleteDBParameterGroup', verb='POST', path='/', params=params)
def delete_db_security_group(self, db_security_group_name): DCNL DCSP params = {'DBSecurityGroupName': db_security_group_name} DCNL DCSP return self._make_request(action='DeleteDBSecurityGroup', verb='POST', path='/', params=params)
def delete_db_snapshot(self, db_snapshot_identifier): DCNL DCSP params = {'DBSnapshotIdentifier': db_snapshot_identifier} DCNL DCSP return self._make_request(action='DeleteDBSnapshot', verb='POST', path='/', params=params)
def delete_db_subnet_group(self, db_subnet_group_name): DCNL DCSP params = {'DBSubnetGroupName': db_subnet_group_name} DCNL DCSP return self._make_request(action='DeleteDBSubnetGroup', verb='POST', path='/', params=params)
def delete_event_subscription(self, subscription_name): DCNL DCSP params = {'SubscriptionName': subscription_name} DCNL DCSP return self._make_request(action='DeleteEventSubscription', verb='POST', path='/', params=params)
def delete_option_group(self, option_group_name): DCNL DCSP params = {'OptionGroupName': option_group_name} DCNL DCSP return self._make_request(action='DeleteOptionGroup', verb='POST', path='/', params=params)
def describe_db_engine_versions(self, engine=None, engine_version=None, db_parameter_group_family=None, max_records=None, marker=None, default_only=None, list_supported_character_sets=None): DCNL DCSP params = {} DCNL DCSP if (engine is not None): DCNL DCSP  DCSP params['Engine'] = engine DCNL DCSP if (engine_version is not None): DCNL DCSP  DCSP params['EngineVersion'] = engine_version DCNL DCSP if (db_parameter_group_family is not None): DCNL DCSP  DCSP params['DBParameterGroupFamily'] = db_parameter_group_family DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (default_only is not None): DCNL DCSP  DCSP params['DefaultOnly'] = str(default_only).lower() DCNL DCSP if (list_supported_character_sets is not None): DCNL DCSP  DCSP params['ListSupportedCharacterSets'] = str(list_supported_character_sets).lower() DCNL DCSP return self._make_request(action='DescribeDBEngineVersions', verb='POST', path='/', params=params)
def describe_db_instances(self, db_instance_identifier=None, filters=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (db_instance_identifier is not None): DCNL DCSP  DCSP params['DBInstanceIdentifier'] = db_instance_identifier DCNL DCSP if (filters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, filters, 'Filters.member', ('FilterName', 'FilterValue')) DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeDBInstances', verb='POST', path='/', params=params)
def describe_db_log_files(self, db_instance_identifier, filename_contains=None, file_last_written=None, file_size=None, max_records=None, marker=None): DCNL DCSP params = {'DBInstanceIdentifier': db_instance_identifier} DCNL DCSP if (filename_contains is not None): DCNL DCSP  DCSP params['FilenameContains'] = filename_contains DCNL DCSP if (file_last_written is not None): DCNL DCSP  DCSP params['FileLastWritten'] = file_last_written DCNL DCSP if (file_size is not None): DCNL DCSP  DCSP params['FileSize'] = file_size DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeDBLogFiles', verb='POST', path='/', params=params)
def describe_db_parameter_groups(self, db_parameter_group_name=None, filters=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (db_parameter_group_name is not None): DCNL DCSP  DCSP params['DBParameterGroupName'] = db_parameter_group_name DCNL DCSP if (filters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, filters, 'Filters.member', ('FilterName', 'FilterValue')) DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeDBParameterGroups', verb='POST', path='/', params=params)
def describe_db_parameters(self, db_parameter_group_name, source=None, max_records=None, marker=None): DCNL DCSP params = {'DBParameterGroupName': db_parameter_group_name} DCNL DCSP if (source is not None): DCNL DCSP  DCSP params['Source'] = source DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeDBParameters', verb='POST', path='/', params=params)
def describe_db_security_groups(self, db_security_group_name=None, filters=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (db_security_group_name is not None): DCNL DCSP  DCSP params['DBSecurityGroupName'] = db_security_group_name DCNL DCSP if (filters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, filters, 'Filters.member', ('FilterName', 'FilterValue')) DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeDBSecurityGroups', verb='POST', path='/', params=params)
def describe_db_snapshots(self, db_instance_identifier=None, db_snapshot_identifier=None, snapshot_type=None, filters=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (db_instance_identifier is not None): DCNL DCSP  DCSP params['DBInstanceIdentifier'] = db_instance_identifier DCNL DCSP if (db_snapshot_identifier is not None): DCNL DCSP  DCSP params['DBSnapshotIdentifier'] = db_snapshot_identifier DCNL DCSP if (snapshot_type is not None): DCNL DCSP  DCSP params['SnapshotType'] = snapshot_type DCNL DCSP if (filters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, filters, 'Filters.member', ('FilterName', 'FilterValue')) DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeDBSnapshots', verb='POST', path='/', params=params)
def describe_db_subnet_groups(self, db_subnet_group_name=None, filters=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (db_subnet_group_name is not None): DCNL DCSP  DCSP params['DBSubnetGroupName'] = db_subnet_group_name DCNL DCSP if (filters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, filters, 'Filters.member', ('FilterName', 'FilterValue')) DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeDBSubnetGroups', verb='POST', path='/', params=params)
def describe_engine_default_parameters(self, db_parameter_group_family, max_records=None, marker=None): DCNL DCSP params = {'DBParameterGroupFamily': db_parameter_group_family} DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeEngineDefaultParameters', verb='POST', path='/', params=params)
def describe_event_categories(self, source_type=None): DCNL DCSP params = {} DCNL DCSP if (source_type is not None): DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP return self._make_request(action='DescribeEventCategories', verb='POST', path='/', params=params)
def describe_event_subscriptions(self, subscription_name=None, filters=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (subscription_name is not None): DCNL DCSP  DCSP params['SubscriptionName'] = subscription_name DCNL DCSP if (filters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, filters, 'Filters.member', ('FilterName', 'FilterValue')) DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeEventSubscriptions', verb='POST', path='/', params=params)
def describe_events(self, source_identifier=None, source_type=None, start_time=None, end_time=None, duration=None, event_categories=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (source_identifier is not None): DCNL DCSP  DCSP params['SourceIdentifier'] = source_identifier DCNL DCSP if (source_type is not None): DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP if (start_time is not None): DCNL DCSP  DCSP params['StartTime'] = start_time DCNL DCSP if (end_time is not None): DCNL DCSP  DCSP params['EndTime'] = end_time DCNL DCSP if (duration is not None): DCNL DCSP  DCSP params['Duration'] = duration DCNL DCSP if (event_categories is not None): DCNL DCSP  DCSP self.build_list_params(params, event_categories, 'EventCategories.member') DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeEvents', verb='POST', path='/', params=params)
def describe_option_group_options(self, engine_name, major_engine_version=None, max_records=None, marker=None): DCNL DCSP params = {'EngineName': engine_name} DCNL DCSP if (major_engine_version is not None): DCNL DCSP  DCSP params['MajorEngineVersion'] = major_engine_version DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeOptionGroupOptions', verb='POST', path='/', params=params)
def describe_option_groups(self, option_group_name=None, filters=None, marker=None, max_records=None, engine_name=None, major_engine_version=None): DCNL DCSP params = {} DCNL DCSP if (option_group_name is not None): DCNL DCSP  DCSP params['OptionGroupName'] = option_group_name DCNL DCSP if (filters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, filters, 'Filters.member', ('FilterName', 'FilterValue')) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (engine_name is not None): DCNL DCSP  DCSP params['EngineName'] = engine_name DCNL DCSP if (major_engine_version is not None): DCNL DCSP  DCSP params['MajorEngineVersion'] = major_engine_version DCNL DCSP return self._make_request(action='DescribeOptionGroups', verb='POST', path='/', params=params)
def describe_orderable_db_instance_options(self, engine, engine_version=None, db_instance_class=None, license_model=None, vpc=None, max_records=None, marker=None): DCNL DCSP params = {'Engine': engine} DCNL DCSP if (engine_version is not None): DCNL DCSP  DCSP params['EngineVersion'] = engine_version DCNL DCSP if (db_instance_class is not None): DCNL DCSP  DCSP params['DBInstanceClass'] = db_instance_class DCNL DCSP if (license_model is not None): DCNL DCSP  DCSP params['LicenseModel'] = license_model DCNL DCSP if (vpc is not None): DCNL DCSP  DCSP params['Vpc'] = str(vpc).lower() DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeOrderableDBInstanceOptions', verb='POST', path='/', params=params)
def describe_reserved_db_instances(self, reserved_db_instance_id=None, reserved_db_instances_offering_id=None, db_instance_class=None, duration=None, product_description=None, offering_type=None, multi_az=None, filters=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (reserved_db_instance_id is not None): DCNL DCSP  DCSP params['ReservedDBInstanceId'] = reserved_db_instance_id DCNL DCSP if (reserved_db_instances_offering_id is not None): DCNL DCSP  DCSP params['ReservedDBInstancesOfferingId'] = reserved_db_instances_offering_id DCNL DCSP if (db_instance_class is not None): DCNL DCSP  DCSP params['DBInstanceClass'] = db_instance_class DCNL DCSP if (duration is not None): DCNL DCSP  DCSP params['Duration'] = duration DCNL DCSP if (product_description is not None): DCNL DCSP  DCSP params['ProductDescription'] = product_description DCNL DCSP if (offering_type is not None): DCNL DCSP  DCSP params['OfferingType'] = offering_type DCNL DCSP if (multi_az is not None): DCNL DCSP  DCSP params['MultiAZ'] = str(multi_az).lower() DCNL DCSP if (filters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, filters, 'Filters.member', ('FilterName', 'FilterValue')) DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeReservedDBInstances', verb='POST', path='/', params=params)
def describe_reserved_db_instances_offerings(self, reserved_db_instances_offering_id=None, db_instance_class=None, duration=None, product_description=None, offering_type=None, multi_az=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (reserved_db_instances_offering_id is not None): DCNL DCSP  DCSP params['ReservedDBInstancesOfferingId'] = reserved_db_instances_offering_id DCNL DCSP if (db_instance_class is not None): DCNL DCSP  DCSP params['DBInstanceClass'] = db_instance_class DCNL DCSP if (duration is not None): DCNL DCSP  DCSP params['Duration'] = duration DCNL DCSP if (product_description is not None): DCNL DCSP  DCSP params['ProductDescription'] = product_description DCNL DCSP if (offering_type is not None): DCNL DCSP  DCSP params['OfferingType'] = offering_type DCNL DCSP if (multi_az is not None): DCNL DCSP  DCSP params['MultiAZ'] = str(multi_az).lower() DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeReservedDBInstancesOfferings', verb='POST', path='/', params=params)
def download_db_log_file_portion(self, db_instance_identifier, log_file_name, marker=None, number_of_lines=None): DCNL DCSP params = {'DBInstanceIdentifier': db_instance_identifier, 'LogFileName': log_file_name} DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (number_of_lines is not None): DCNL DCSP  DCSP params['NumberOfLines'] = number_of_lines DCNL DCSP return self._make_request(action='DownloadDBLogFilePortion', verb='POST', path='/', params=params)
def list_tags_for_resource(self, resource_name): DCNL DCSP params = {'ResourceName': resource_name} DCNL DCSP return self._make_request(action='ListTagsForResource', verb='POST', path='/', params=params)
def modify_db_instance(self, db_instance_identifier, allocated_storage=None, db_instance_class=None, db_security_groups=None, vpc_security_group_ids=None, apply_immediately=None, master_user_password=None, db_parameter_group_name=None, backup_retention_period=None, preferred_backup_window=None, preferred_maintenance_window=None, multi_az=None, engine_version=None, allow_major_version_upgrade=None, auto_minor_version_upgrade=None, iops=None, option_group_name=None, new_db_instance_identifier=None): DCNL DCSP params = {'DBInstanceIdentifier': db_instance_identifier} DCNL DCSP if (allocated_storage is not None): DCNL DCSP  DCSP params['AllocatedStorage'] = allocated_storage DCNL DCSP if (db_instance_class is not None): DCNL DCSP  DCSP params['DBInstanceClass'] = db_instance_class DCNL DCSP if (db_security_groups is not None): DCNL DCSP  DCSP self.build_list_params(params, db_security_groups, 'DBSecurityGroups.member') DCNL DCSP if (vpc_security_group_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, vpc_security_group_ids, 'VpcSecurityGroupIds.member') DCNL DCSP if (apply_immediately is not None): DCNL DCSP  DCSP params['ApplyImmediately'] = str(apply_immediately).lower() DCNL DCSP if (master_user_password is not None): DCNL DCSP  DCSP params['MasterUserPassword'] = master_user_password DCNL DCSP if (db_parameter_group_name is not None): DCNL DCSP  DCSP params['DBParameterGroupName'] = db_parameter_group_name DCNL DCSP if (backup_retention_period is not None): DCNL DCSP  DCSP params['BackupRetentionPeriod'] = backup_retention_period DCNL DCSP if (preferred_backup_window is not None): DCNL DCSP  DCSP params['PreferredBackupWindow'] = preferred_backup_window DCNL DCSP if (preferred_maintenance_window is not None): DCNL DCSP  DCSP params['PreferredMaintenanceWindow'] = preferred_maintenance_window DCNL DCSP if (multi_az is not None): DCNL DCSP  DCSP params['MultiAZ'] = str(multi_az).lower() DCNL DCSP if (engine_version is not None): DCNL DCSP  DCSP params['EngineVersion'] = engine_version DCNL DCSP if (allow_major_version_upgrade is not None): DCNL DCSP  DCSP params['AllowMajorVersionUpgrade'] = str(allow_major_version_upgrade).lower() DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower() DCNL DCSP if (iops is not None): DCNL DCSP  DCSP params['Iops'] = iops DCNL DCSP if (option_group_name is not None): DCNL DCSP  DCSP params['OptionGroupName'] = option_group_name DCNL DCSP if (new_db_instance_identifier is not None): DCNL DCSP  DCSP params['NewDBInstanceIdentifier'] = new_db_instance_identifier DCNL DCSP return self._make_request(action='ModifyDBInstance', verb='POST', path='/', params=params)
def modify_db_parameter_group(self, db_parameter_group_name, parameters): DCNL DCSP params = {'DBParameterGroupName': db_parameter_group_name} DCNL DCSP self.build_complex_list_params(params, parameters, 'Parameters.member', ('ParameterName', 'ParameterValue', 'Description', 'Source', 'ApplyType', 'DataType', 'AllowedValues', 'IsModifiable', 'MinimumEngineVersion', 'ApplyMethod')) DCNL DCSP return self._make_request(action='ModifyDBParameterGroup', verb='POST', path='/', params=params)
def modify_db_subnet_group(self, db_subnet_group_name, subnet_ids, db_subnet_group_description=None): DCNL DCSP params = {'DBSubnetGroupName': db_subnet_group_name} DCNL DCSP self.build_list_params(params, subnet_ids, 'SubnetIds.member') DCNL DCSP if (db_subnet_group_description is not None): DCNL DCSP  DCSP params['DBSubnetGroupDescription'] = db_subnet_group_description DCNL DCSP return self._make_request(action='ModifyDBSubnetGroup', verb='POST', path='/', params=params)
def modify_event_subscription(self, subscription_name, sns_topic_arn=None, source_type=None, event_categories=None, enabled=None): DCNL DCSP params = {'SubscriptionName': subscription_name} DCNL DCSP if (sns_topic_arn is not None): DCNL DCSP  DCSP params['SnsTopicArn'] = sns_topic_arn DCNL DCSP if (source_type is not None): DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP if (event_categories is not None): DCNL DCSP  DCSP self.build_list_params(params, event_categories, 'EventCategories.member') DCNL DCSP if (enabled is not None): DCNL DCSP  DCSP params['Enabled'] = str(enabled).lower() DCNL DCSP return self._make_request(action='ModifyEventSubscription', verb='POST', path='/', params=params)
def modify_option_group(self, option_group_name, options_to_include=None, options_to_remove=None, apply_immediately=None): DCNL DCSP params = {'OptionGroupName': option_group_name} DCNL DCSP if (options_to_include is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, options_to_include, 'OptionsToInclude.member', ('OptionName', 'Port', 'DBSecurityGroupMemberships', 'VpcSecurityGroupMemberships', 'OptionSettings')) DCNL DCSP if (options_to_remove is not None): DCNL DCSP  DCSP self.build_list_params(params, options_to_remove, 'OptionsToRemove.member') DCNL DCSP if (apply_immediately is not None): DCNL DCSP  DCSP params['ApplyImmediately'] = str(apply_immediately).lower() DCNL DCSP return self._make_request(action='ModifyOptionGroup', verb='POST', path='/', params=params)
def promote_read_replica(self, db_instance_identifier, backup_retention_period=None, preferred_backup_window=None): DCNL DCSP params = {'DBInstanceIdentifier': db_instance_identifier} DCNL DCSP if (backup_retention_period is not None): DCNL DCSP  DCSP params['BackupRetentionPeriod'] = backup_retention_period DCNL DCSP if (preferred_backup_window is not None): DCNL DCSP  DCSP params['PreferredBackupWindow'] = preferred_backup_window DCNL DCSP return self._make_request(action='PromoteReadReplica', verb='POST', path='/', params=params)
def purchase_reserved_db_instances_offering(self, reserved_db_instances_offering_id, reserved_db_instance_id=None, db_instance_count=None, tags=None): DCNL DCSP params = {'ReservedDBInstancesOfferingId': reserved_db_instances_offering_id} DCNL DCSP if (reserved_db_instance_id is not None): DCNL DCSP  DCSP params['ReservedDBInstanceId'] = reserved_db_instance_id DCNL DCSP if (db_instance_count is not None): DCNL DCSP  DCSP params['DBInstanceCount'] = db_instance_count DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='PurchaseReservedDBInstancesOffering', verb='POST', path='/', params=params)
def reboot_db_instance(self, db_instance_identifier, force_failover=None): DCNL DCSP params = {'DBInstanceIdentifier': db_instance_identifier} DCNL DCSP if (force_failover is not None): DCNL DCSP  DCSP params['ForceFailover'] = str(force_failover).lower() DCNL DCSP return self._make_request(action='RebootDBInstance', verb='POST', path='/', params=params)
def remove_source_identifier_from_subscription(self, subscription_name, source_identifier): DCNL DCSP params = {'SubscriptionName': subscription_name, 'SourceIdentifier': source_identifier} DCNL DCSP return self._make_request(action='RemoveSourceIdentifierFromSubscription', verb='POST', path='/', params=params)
def remove_tags_from_resource(self, resource_name, tag_keys): DCNL DCSP params = {'ResourceName': resource_name} DCNL DCSP self.build_list_params(params, tag_keys, 'TagKeys.member') DCNL DCSP return self._make_request(action='RemoveTagsFromResource', verb='POST', path='/', params=params)
def reset_db_parameter_group(self, db_parameter_group_name, reset_all_parameters=None, parameters=None): DCNL DCSP params = {'DBParameterGroupName': db_parameter_group_name} DCNL DCSP if (reset_all_parameters is not None): DCNL DCSP  DCSP params['ResetAllParameters'] = str(reset_all_parameters).lower() DCNL DCSP if (parameters is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, parameters, 'Parameters.member', ('ParameterName', 'ParameterValue', 'Description', 'Source', 'ApplyType', 'DataType', 'AllowedValues', 'IsModifiable', 'MinimumEngineVersion', 'ApplyMethod')) DCNL DCSP return self._make_request(action='ResetDBParameterGroup', verb='POST', path='/', params=params)
def restore_db_instance_from_db_snapshot(self, db_instance_identifier, db_snapshot_identifier, db_instance_class=None, port=None, availability_zone=None, db_subnet_group_name=None, multi_az=None, publicly_accessible=None, auto_minor_version_upgrade=None, license_model=None, db_name=None, engine=None, iops=None, option_group_name=None, tags=None): DCNL DCSP params = {'DBInstanceIdentifier': db_instance_identifier, 'DBSnapshotIdentifier': db_snapshot_identifier} DCNL DCSP if (db_instance_class is not None): DCNL DCSP  DCSP params['DBInstanceClass'] = db_instance_class DCNL DCSP if (port is not None): DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if (availability_zone is not None): DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (db_subnet_group_name is not None): DCNL DCSP  DCSP params['DBSubnetGroupName'] = db_subnet_group_name DCNL DCSP if (multi_az is not None): DCNL DCSP  DCSP params['MultiAZ'] = str(multi_az).lower() DCNL DCSP if (publicly_accessible is not None): DCNL DCSP  DCSP params['PubliclyAccessible'] = str(publicly_accessible).lower() DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower() DCNL DCSP if (license_model is not None): DCNL DCSP  DCSP params['LicenseModel'] = license_model DCNL DCSP if (db_name is not None): DCNL DCSP  DCSP params['DBName'] = db_name DCNL DCSP if (engine is not None): DCNL DCSP  DCSP params['Engine'] = engine DCNL DCSP if (iops is not None): DCNL DCSP  DCSP params['Iops'] = iops DCNL DCSP if (option_group_name is not None): DCNL DCSP  DCSP params['OptionGroupName'] = option_group_name DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='RestoreDBInstanceFromDBSnapshot', verb='POST', path='/', params=params)
def restore_db_instance_to_point_in_time(self, source_db_instance_identifier, target_db_instance_identifier, restore_time=None, use_latest_restorable_time=None, db_instance_class=None, port=None, availability_zone=None, db_subnet_group_name=None, multi_az=None, publicly_accessible=None, auto_minor_version_upgrade=None, license_model=None, db_name=None, engine=None, iops=None, option_group_name=None, tags=None): DCNL DCSP params = {'SourceDBInstanceIdentifier': source_db_instance_identifier, 'TargetDBInstanceIdentifier': target_db_instance_identifier} DCNL DCSP if (restore_time is not None): DCNL DCSP  DCSP params['RestoreTime'] = restore_time DCNL DCSP if (use_latest_restorable_time is not None): DCNL DCSP  DCSP params['UseLatestRestorableTime'] = str(use_latest_restorable_time).lower() DCNL DCSP if (db_instance_class is not None): DCNL DCSP  DCSP params['DBInstanceClass'] = db_instance_class DCNL DCSP if (port is not None): DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if (availability_zone is not None): DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (db_subnet_group_name is not None): DCNL DCSP  DCSP params['DBSubnetGroupName'] = db_subnet_group_name DCNL DCSP if (multi_az is not None): DCNL DCSP  DCSP params['MultiAZ'] = str(multi_az).lower() DCNL DCSP if (publicly_accessible is not None): DCNL DCSP  DCSP params['PubliclyAccessible'] = str(publicly_accessible).lower() DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower() DCNL DCSP if (license_model is not None): DCNL DCSP  DCSP params['LicenseModel'] = license_model DCNL DCSP if (db_name is not None): DCNL DCSP  DCSP params['DBName'] = db_name DCNL DCSP if (engine is not None): DCNL DCSP  DCSP params['Engine'] = engine DCNL DCSP if (iops is not None): DCNL DCSP  DCSP params['Iops'] = iops DCNL DCSP if (option_group_name is not None): DCNL DCSP  DCSP params['OptionGroupName'] = option_group_name DCNL DCSP if (tags is not None): DCNL DCSP  DCSP self.build_complex_list_params(params, tags, 'Tags.member', ('Key', 'Value')) DCNL DCSP return self._make_request(action='RestoreDBInstanceToPointInTime', verb='POST', path='/', params=params)
def revoke_db_security_group_ingress(self, db_security_group_name, cidrip=None, ec2_security_group_name=None, ec2_security_group_id=None, ec2_security_group_owner_id=None): DCNL DCSP params = {'DBSecurityGroupName': db_security_group_name} DCNL DCSP if (cidrip is not None): DCNL DCSP  DCSP params['CIDRIP'] = cidrip DCNL DCSP if (ec2_security_group_name is not None): DCNL DCSP  DCSP params['EC2SecurityGroupName'] = ec2_security_group_name DCNL DCSP if (ec2_security_group_id is not None): DCNL DCSP  DCSP params['EC2SecurityGroupId'] = ec2_security_group_id DCNL DCSP if (ec2_security_group_owner_id is not None): DCNL DCSP  DCSP params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id DCNL DCSP return self._make_request(action='RevokeDBSecurityGroupIngress', verb='POST', path='/', params=params)
def put_attributes(self, item_name, attributes, replace=True, expected_value=None): DCNL DCSP return self.connection.put_attributes(self, item_name, attributes, replace, expected_value)
def batch_put_attributes(self, items, replace=True): DCNL DCSP return self.connection.batch_put_attributes(self, items, replace)
def get_attributes(self, item_name, attribute_name=None, consistent_read=False, item=None): DCNL DCSP return self.connection.get_attributes(self, item_name, attribute_name, consistent_read, item)
def delete_attributes(self, item_name, attributes=None, expected_values=None): DCNL DCSP return self.connection.delete_attributes(self, item_name, attributes, expected_values)
def batch_delete_attributes(self, items): DCNL DCSP return self.connection.batch_delete_attributes(self, items)
def select(self, query='', next_token=None, consistent_read=False, max_items=None): DCNL DCSP return SelectResultSet(self, query, max_items=max_items, next_token=next_token, consistent_read=consistent_read)
def get_item(self, item_name, consistent_read=False): DCNL DCSP item = self.get_attributes(item_name, consistent_read=consistent_read) DCNL DCSP if item: DCNL DCSP  DCSP item.domain = self DCNL DCSP  DCSP return item DCNL DCSP else: DCNL DCSP  DCSP return None
def to_xml(self, f=None): DCNL DCSP if (not f): DCNL DCSP  DCSP from tempfile import TemporaryFile DCNL DCSP  DCSP f = TemporaryFile() DCNL DCSP print('<?xml DCSP version="1.0" DCSP encoding="UTF-8"?>', file=f) DCNL DCSP print(('<Domain DCSP id="%s">' % self.name), file=f) DCNL DCSP for item in self: DCNL DCSP  DCSP print((' DCTB <Item DCSP id="%s">' % item.name), file=f) DCNL DCSP  DCSP for k in item: DCNL DCSP  DCSP  DCSP print((' DCTB  DCTB <attribute DCSP id="%s">' % k), file=f) DCNL DCSP  DCSP  DCSP values = item[k] DCNL DCSP  DCSP  DCSP if (not isinstance(values, list)): DCNL DCSP  DCSP  DCSP  DCSP values = [values] DCNL DCSP  DCSP  DCSP for value in values: DCNL DCSP  DCSP  DCSP  DCSP print(' DCTB  DCTB  DCTB <value><![CDATA[', end=' DCSP ', file=f) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, six.text_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = value.encode('utf-8', 'replace') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = six.text_type(value, errors='replace').encode('utf-8', 'replace') DCNL DCSP  DCSP  DCSP  DCSP f.write(value) DCNL DCSP  DCSP  DCSP  DCSP print(']]></value>', file=f) DCNL DCSP  DCSP  DCSP print(' DCTB  DCTB </attribute>', file=f) DCNL DCSP  DCSP print(' DCTB </Item>', file=f) DCNL DCSP print('</Domain>', file=f) DCNL DCSP f.flush() DCNL DCSP f.seek(0) DCNL DCSP return f
def from_xml(self, doc): DCNL DCSP import xml.sax DCNL DCSP handler = DomainDumpParser(self) DCNL DCSP xml.sax.parse(doc, handler) DCNL DCSP return handler
def delete(self): DCNL DCSP return self.connection.delete_domain(self)
def __init__(self, sequence_string, rollover=False): DCNL DCSP self.sequence_string = sequence_string DCNL DCSP self.sequence_length = len(sequence_string[0]) DCNL DCSP self.rollover = rollover DCNL DCSP self.last_item = sequence_string[(-1)] DCNL DCSP self.__name__ = ("%s('%s')" % (self.__class__.__name__, sequence_string))
def __call__(self, val, last=None): DCNL DCSP if ((val is None) or (len(val) < self.sequence_length)): DCNL DCSP  DCSP return self.sequence_string[0] DCNL DCSP last_value = val[(- self.sequence_length):] DCNL DCSP if ((not self.rollover) and (last_value == self.last_item)): DCNL DCSP  DCSP val = ('%s%s' % (self(val[:(- self.sequence_length)]), self._inc(last_value))) DCNL DCSP else: DCNL DCSP  DCSP val = ('%s%s' % (val[:(- self.sequence_length)], self._inc(last_value))) DCNL DCSP return val
def _inc(self, val): DCNL DCSP assert (len(val) == self.sequence_length) DCNL DCSP return self.sequence_string[((self.sequence_string.index(val) + 1) % len(self.sequence_string))]
def __init__(self, id=None, domain_name=None, fnc=increment_by_one, init_val=None): DCNL DCSP self._db = None DCNL DCSP self._value = None DCNL DCSP self.last_value = None DCNL DCSP self.domain_name = domain_name DCNL DCSP self.id = id DCNL DCSP if (init_val is None): DCNL DCSP  DCSP init_val = fnc(init_val) DCNL DCSP if (self.id is None): DCNL DCSP  DCSP import uuid DCNL DCSP  DCSP self.id = str(uuid.uuid4()) DCNL DCSP self.item_type = type(fnc(None)) DCNL DCSP self.timestamp = None DCNL DCSP if isinstance(fnc, six.string_types): DCNL DCSP  DCSP from boto.utils import find_class DCNL DCSP  DCSP fnc = find_class(fnc) DCNL DCSP self.fnc = fnc DCNL DCSP if (not self.val): DCNL DCSP  DCSP self.val = init_val
def set(self, val): DCNL DCSP import time DCNL DCSP now = time.time() DCNL DCSP expected_value = [] DCNL DCSP new_val = {} DCNL DCSP new_val['timestamp'] = now DCNL DCSP if (self._value is not None): DCNL DCSP  DCSP new_val['last_value'] = self._value DCNL DCSP  DCSP expected_value = ['current_value', str(self._value)] DCNL DCSP new_val['current_value'] = val DCNL DCSP try: DCNL DCSP  DCSP self.db.put_attributes(self.id, new_val, expected_value=expected_value) DCNL DCSP  DCSP self.timestamp = new_val['timestamp'] DCNL DCSP except SDBResponseError as e: DCNL DCSP  DCSP if (e.status == 409): DCNL DCSP  DCSP  DCSP raise ValueError('Sequence DCSP out DCSP of DCSP sync') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def get(self): DCNL DCSP val = self.db.get_attributes(self.id, consistent_read=True) DCNL DCSP if val: DCNL DCSP  DCSP if ('timestamp' in val): DCNL DCSP  DCSP  DCSP self.timestamp = val['timestamp'] DCNL DCSP  DCSP if ('current_value' in val): DCNL DCSP  DCSP  DCSP self._value = self.item_type(val['current_value']) DCNL DCSP  DCSP if (('last_value' in val) and (val['last_value'] is not None)): DCNL DCSP  DCSP  DCSP self.last_value = self.item_type(val['last_value']) DCNL DCSP return self._value
def _connect(self): DCNL DCSP if (not self._db): DCNL DCSP  DCSP import boto DCNL DCSP  DCSP sdb = boto.connect_sdb() DCNL DCSP  DCSP if (not self.domain_name): DCNL DCSP  DCSP  DCSP self.domain_name = boto.config.get('DB', 'sequence_db', boto.config.get('DB', 'db_name', 'default')) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self._db = sdb.get_domain(self.domain_name) DCNL DCSP  DCSP except SDBResponseError as e: DCNL DCSP  DCSP  DCSP if (e.status == 400): DCNL DCSP  DCSP  DCSP  DCSP self._db = sdb.create_domain(self.domain_name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return self._db
def delete(self): DCNL DCSP self.db.delete_attributes(self.id)
def fetch(self, limit, offset=0): DCNL DCSP self.limit = limit DCNL DCSP self.offset = offset DCNL DCSP return self
def put(self, expected_value=None): DCNL DCSP self._manager.save_object(self, expected_value) DCNL DCSP return self
def put_attributes(self, attrs): DCNL DCSP assert isinstance(attrs, dict), 'Argument DCSP must DCSP be DCSP a DCSP dict DCSP of DCSP key->values DCSP to DCSP save' DCNL DCSP for prop_name in attrs: DCNL DCSP  DCSP value = attrs[prop_name] DCNL DCSP  DCSP prop = self.find_property(prop_name) DCNL DCSP  DCSP assert prop, ('Property DCSP not DCSP found: DCSP %s' % prop_name) DCNL DCSP  DCSP self._manager.set_property(prop, self, prop_name, value) DCNL DCSP self.reload() DCNL DCSP return self
def delete_attributes(self, attrs): DCNL DCSP assert isinstance(attrs, list), 'Argument DCSP must DCSP be DCSP a DCSP list DCSP of DCSP names DCSP of DCSP keys DCSP to DCSP delete.' DCNL DCSP self._manager.domain.delete_attributes(self.id, attrs) DCNL DCSP self.reload() DCNL DCSP return self
@classmethod DCNL def find_subclass(cls, name): DCNL DCSP if (name == cls.__name__): DCNL DCSP  DCSP return cls DCNL DCSP for sc in cls.__sub_classes__: DCNL DCSP  DCSP r = sc.find_subclass(name) DCNL DCSP  DCSP if (r is not None): DCNL DCSP  DCSP  DCSP return r
def __init__(self, verbose_name=None, name=None, default='', required=False, validator=None, choices=None, unique=False, hashfunc=None): DCNL DCSP super(PasswordProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique) DCNL DCSP self.hashfunc = hashfunc
def __set__(self, obj, value): DCNL DCSP if ((value is not None) and ((obj.id == value) or (hasattr(value, 'id') and (obj.id == value.id)))): DCNL DCSP  DCSP raise ValueError('Can DCSP not DCSP associate DCSP an DCSP object DCSP with DCSP itself!') DCNL DCSP return super(ReferenceProperty, self).__set__(obj, value)
def __get__(self, model_instance, model_class): DCNL DCSP if (model_instance is not None): DCNL DCSP  DCSP query = Query(self.__model) DCNL DCSP  DCSP if isinstance(self.__property, list): DCNL DCSP  DCSP  DCSP props = [] DCNL DCSP  DCSP  DCSP for prop in self.__property: DCNL DCSP  DCSP  DCSP  DCSP props.append(('%s DCSP =' % prop)) DCNL DCSP  DCSP  DCSP return query.filter(props, model_instance) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return query.filter((self.__property + ' DCSP ='), model_instance) DCNL DCSP else: DCNL DCSP  DCSP return self
def __set__(self, model_instance, value): DCNL DCSP raise ValueError('Virtual DCSP property DCSP is DCSP read-only')
def __set__(self, obj, value): DCNL DCSP pass
def __set__(self, obj, value): DCNL DCSP if (self.item_type in six.integer_types): DCNL DCSP  DCSP item_type = six.integer_types DCNL DCSP elif (self.item_type in six.string_types): DCNL DCSP  DCSP item_type = six.string_types DCNL DCSP else: DCNL DCSP  DCSP item_type = self.item_type DCNL DCSP if isinstance(value, item_type): DCNL DCSP  DCSP value = [value] DCNL DCSP elif (value is None): DCNL DCSP  DCSP value = [] DCNL DCSP return super(ListProperty, self).__set__(obj, value)
def _make_request(self, method, url, post_data=None, body=None): DCNL DCSP if (not self.connection): DCNL DCSP  DCSP self._connect() DCNL DCSP try: DCNL DCSP  DCSP self.connection.close() DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP self.connection.connect() DCNL DCSP headers = {} DCNL DCSP if self.auth_header: DCNL DCSP  DCSP headers['Authorization'] = self.auth_header DCNL DCSP self.connection.request(method, url, body, headers) DCNL DCSP resp = self.connection.getresponse() DCNL DCSP return resp
def get_props_from_doc(self, cls, id, doc): DCNL DCSP obj_node = doc.getElementsByTagName('object')[0] DCNL DCSP if (not cls): DCNL DCSP  DCSP class_name = obj_node.getAttribute('class') DCNL DCSP  DCSP cls = find_class(class_name) DCNL DCSP if (not id): DCNL DCSP  DCSP id = obj_node.getAttribute('id') DCNL DCSP props = {} DCNL DCSP for prop_node in obj_node.getElementsByTagName('property'): DCNL DCSP  DCSP prop_name = prop_node.getAttribute('name') DCNL DCSP  DCSP prop = cls.find_property(prop_name) DCNL DCSP  DCSP value = self.decode_value(prop, prop_node) DCNL DCSP  DCSP value = prop.make_value_from_datastore(value) DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP props[prop.name] = value DCNL DCSP return (cls, props, id)
def save_object(self, obj, expected_value=None): DCNL DCSP doc = self.marshal_object(obj) DCNL DCSP if obj.id: DCNL DCSP  DCSP url = ('/%s/%s' % (self.db_name, obj.id)) DCNL DCSP else: DCNL DCSP  DCSP url = ('/%s' % self.db_name) DCNL DCSP resp = self._make_request('PUT', url, body=doc.toxml()) DCNL DCSP new_obj = self.get_object_from_doc(obj.__class__, None, parse(resp)) DCNL DCSP obj.id = new_obj.id DCNL DCSP for prop in obj.properties(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP propname = prop.name DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP propname = None DCNL DCSP  DCSP if propname: DCNL DCSP  DCSP  DCSP value = getattr(new_obj, prop.name) DCNL DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, prop.name, value) DCNL DCSP return obj
def unmarshal_props(self, fp, cls=None, id=None): DCNL DCSP if isinstance(fp, six.string_types): DCNL DCSP  DCSP doc = parseString(fp) DCNL DCSP else: DCNL DCSP  DCSP doc = parse(fp) DCNL DCSP return self.get_props_from_doc(cls, id, doc)
def decode_map_element(self, item_type, value): DCNL DCSP import urllib DCNL DCSP key = value DCNL DCSP if (':' in value): DCNL DCSP  DCSP (key, value) = value.split(':', 1) DCNL DCSP  DCSP key = urllib.unquote(key) DCNL DCSP if (self.model_class in item_type.mro()): DCNL DCSP  DCSP value = item_type(id=value) DCNL DCSP else: DCNL DCSP  DCSP value = self.decode(item_type, value) DCNL DCSP return (key, value)
def encode_float(self, value): DCNL DCSP s = ('%e' % value) DCNL DCSP l = s.split('e') DCNL DCSP mantissa = l[0].ljust(18, '0') DCNL DCSP exponent = l[1] DCNL DCSP if (value == 0.0): DCNL DCSP  DCSP case = '3' DCNL DCSP  DCSP exponent = '000' DCNL DCSP elif ((mantissa[0] != '-') and (exponent[0] == '+')): DCNL DCSP  DCSP case = '5' DCNL DCSP  DCSP exponent = exponent[1:].rjust(3, '0') DCNL DCSP elif ((mantissa[0] != '-') and (exponent[0] == '-')): DCNL DCSP  DCSP case = '4' DCNL DCSP  DCSP exponent = (999 + int(exponent)) DCNL DCSP  DCSP exponent = ('%03d' % exponent) DCNL DCSP elif ((mantissa[0] == '-') and (exponent[0] == '-')): DCNL DCSP  DCSP case = '2' DCNL DCSP  DCSP mantissa = ('%f' % (10 + float(mantissa))) DCNL DCSP  DCSP mantissa = mantissa.ljust(18, '0') DCNL DCSP  DCSP exponent = exponent[1:].rjust(3, '0') DCNL DCSP else: DCNL DCSP  DCSP case = '1' DCNL DCSP  DCSP mantissa = ('%f' % (10 + float(mantissa))) DCNL DCSP  DCSP mantissa = mantissa.ljust(18, '0') DCNL DCSP  DCSP exponent = (999 - int(exponent)) DCNL DCSP  DCSP exponent = ('%03d' % exponent) DCNL DCSP return ('%s DCSP %s DCSP %s' % (case, exponent, mantissa))
def decode_datetime(self, value): DCNL DCSP if (value is None): DCNL DCSP  DCSP return value DCNL DCSP try: DCNL DCSP  DCSP if ('T' in value): DCNL DCSP  DCSP  DCSP if ('.' in value): DCNL DCSP  DCSP  DCSP  DCSP return datetime.strptime(value.split('.')[0], '%Y-%m-%dT%H:%M:%S') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return datetime.strptime(value, ISO8601) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = value.split('-') DCNL DCSP  DCSP  DCSP return date(int(value[0]), int(value[1]), int(value[2])) DCNL DCSP except Exception: DCNL DCSP  DCSP return None
def decode_time(self, value): DCNL DCSP if (('-' in value) or ('+' in value)): DCNL DCSP  DCSP raise TimeDecodeError(("Can't DCSP handle DCSP timezone DCSP aware DCSP objects: DCSP %r" % value)) DCNL DCSP tmp = value.split('.') DCNL DCSP arg = map(int, tmp[0].split(':')) DCNL DCSP if (len(tmp) == 2): DCNL DCSP  DCSP arg.append(int(tmp[1])) DCNL DCSP return time(*arg)
def encode_string(self, value): DCNL DCSP if (not isinstance(value, str)): DCNL DCSP  DCSP return value DCNL DCSP try: DCNL DCSP  DCSP return six.text_type(value, 'utf-8') DCNL DCSP except: DCNL DCSP  DCSP arr = [] DCNL DCSP  DCSP for ch in value: DCNL DCSP  DCSP  DCSP arr.append(six.unichr(ord(ch))) DCNL DCSP  DCSP return u''.join(arr)
def decode_string(self, value): DCNL DCSP return value
def count(self, cls, filters, quick=True, sort_by=None, select=None): DCNL DCSP query = ('select DCSP count(*) DCSP from DCSP `%s` DCSP %s' % (self.domain.name, self._build_filter_part(cls, filters, sort_by, select))) DCNL DCSP count = 0 DCNL DCSP for row in self.domain.select(query): DCNL DCSP  DCSP count += int(row['Count']) DCNL DCSP  DCSP if quick: DCNL DCSP  DCSP  DCSP return count DCNL DCSP return count
def _build_filter_part(self, cls, filters, order_by=None, select=None): DCNL DCSP import types DCNL DCSP query_parts = [] DCNL DCSP order_by_filtered = False DCNL DCSP if order_by: DCNL DCSP  DCSP if (order_by[0] == '-'): DCNL DCSP  DCSP  DCSP order_by_method = 'DESC' DCNL DCSP  DCSP  DCSP order_by = order_by[1:] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP order_by_method = 'ASC' DCNL DCSP if select: DCNL DCSP  DCSP if (order_by and (order_by in select)): DCNL DCSP  DCSP  DCSP order_by_filtered = True DCNL DCSP  DCSP query_parts.append(('(%s)' % select)) DCNL DCSP if isinstance(filters, six.string_types): DCNL DCSP  DCSP query = ("WHERE DCSP %s DCSP AND DCSP `__type__` DCSP = DCSP '%s'" % (filters, cls.__name__)) DCNL DCSP  DCSP if (order_by in ['__id__', 'itemName()']): DCNL DCSP  DCSP  DCSP query += (' DCSP ORDER DCSP BY DCSP itemName() DCSP %s' % order_by_method) DCNL DCSP  DCSP elif (order_by is not None): DCNL DCSP  DCSP  DCSP query += (' DCSP ORDER DCSP BY DCSP `%s` DCSP %s' % (order_by, order_by_method)) DCNL DCSP  DCSP return query DCNL DCSP for filter in filters: DCNL DCSP  DCSP filter_parts = [] DCNL DCSP  DCSP filter_props = filter[0] DCNL DCSP  DCSP if (not isinstance(filter_props, list)): DCNL DCSP  DCSP  DCSP filter_props = [filter_props] DCNL DCSP  DCSP for filter_prop in filter_props: DCNL DCSP  DCSP  DCSP (name, op) = filter_prop.strip().split(' DCSP ', 1) DCNL DCSP  DCSP  DCSP value = filter[1] DCNL DCSP  DCSP  DCSP property = cls.find_property(name) DCNL DCSP  DCSP  DCSP if (name == order_by): DCNL DCSP  DCSP  DCSP  DCSP order_by_filtered = True DCNL DCSP  DCSP  DCSP if (types.TypeType(value) == list): DCNL DCSP  DCSP  DCSP  DCSP filter_parts_sub = [] DCNL DCSP  DCSP  DCSP  DCSP for val in value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP val = self.encode_value(property, val) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(val, list): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for v in val: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP filter_parts_sub.append(self._build_filter(property, name, op, v)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP filter_parts_sub.append(self._build_filter(property, name, op, val)) DCNL DCSP  DCSP  DCSP  DCSP filter_parts.append(('(%s)' % ' DCSP OR DCSP '.join(filter_parts_sub))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP val = self.encode_value(property, value) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(val, list): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for v in val: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP filter_parts.append(self._build_filter(property, name, op, v)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP filter_parts.append(self._build_filter(property, name, op, val)) DCNL DCSP  DCSP query_parts.append(('(%s)' % ' DCSP or DCSP '.join(filter_parts))) DCNL DCSP type_query = ("(`__type__` DCSP = DCSP '%s'" % cls.__name__) DCNL DCSP for subclass in self._get_all_decendents(cls).keys(): DCNL DCSP  DCSP type_query += (" DCSP or DCSP `__type__` DCSP = DCSP '%s'" % subclass) DCNL DCSP type_query += ')' DCNL DCSP query_parts.append(type_query) DCNL DCSP order_by_query = '' DCNL DCSP if order_by: DCNL DCSP  DCSP if (not order_by_filtered): DCNL DCSP  DCSP  DCSP query_parts.append(("`%s` DCSP LIKE DCSP '%%'" % order_by)) DCNL DCSP  DCSP if (order_by in ['__id__', 'itemName()']): DCNL DCSP  DCSP  DCSP order_by_query = (' DCSP ORDER DCSP BY DCSP itemName() DCSP %s' % order_by_method) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP order_by_query = (' DCSP ORDER DCSP BY DCSP `%s` DCSP %s' % (order_by, order_by_method)) DCNL DCSP if (len(query_parts) > 0): DCNL DCSP  DCSP return ('WHERE DCSP %s DCSP %s' % (' DCSP AND DCSP '.join(query_parts), order_by_query)) DCNL DCSP else: DCNL DCSP  DCSP return ''
def _get_all_decendents(self, cls): DCNL DCSP decendents = {} DCNL DCSP for sc in cls.__sub_classes__: DCNL DCSP  DCSP decendents[sc.__name__] = sc DCNL DCSP  DCSP decendents.update(self._get_all_decendents(sc)) DCNL DCSP return decendents
def __init__(self, domain, name='', active=False): DCNL DCSP dict.__init__(self) DCNL DCSP self.domain = domain DCNL DCSP self.name = name DCNL DCSP self.active = active DCNL DCSP self.request_id = None DCNL DCSP self.encoding = None DCNL DCSP self.in_attribute = False DCNL DCSP self.converter = self.domain.connection.converter
def load(self): DCNL DCSP self.domain.get_attributes(self.name, item=self)
def save(self, replace=True): DCNL DCSP self.domain.put_attributes(self.name, self, replace) DCNL DCSP if replace: DCNL DCSP  DCSP del_attrs = [] DCNL DCSP  DCSP for name in self: DCNL DCSP  DCSP  DCSP if (self[name] is None): DCNL DCSP  DCSP  DCSP  DCSP del_attrs.append(name) DCNL DCSP  DCSP if (len(del_attrs) > 0): DCNL DCSP  DCSP  DCSP self.domain.delete_attributes(self.name, del_attrs)
def add_value(self, key, value): DCNL DCSP if (key in self): DCNL DCSP  DCSP if (not isinstance(self[key], list)): DCNL DCSP  DCSP  DCSP self[key] = [self[key]] DCNL DCSP  DCSP self[key].append(value) DCNL DCSP else: DCNL DCSP  DCSP self[key] = value
def delete(self): DCNL DCSP self.domain.delete_item(self)
def __init__(self, name, domain_name, item_names): DCNL DCSP super(ItemThread, self).__init__(name=name) DCNL DCSP self.domain_name = domain_name DCNL DCSP self.conn = SDBConnection() DCNL DCSP self.item_names = item_names DCNL DCSP self.items = []
def run(self): DCNL DCSP for item_name in self.item_names: DCNL DCSP  DCSP item = self.conn.get_attributes(self.domain_name, item_name) DCNL DCSP  DCSP self.items.append(item)
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', converter=None, security_token=None, validate_certs=True, profile_name=None): DCNL DCSP if (not region): DCNL DCSP  DCSP region_name = boto.config.get('SDB', 'region', self.DefaultRegionName) DCNL DCSP  DCSP for reg in boto.sdb.regions(): DCNL DCSP  DCSP  DCSP if (reg.name == region_name): DCNL DCSP  DCSP  DCSP  DCSP region = reg DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP self.region = region DCNL DCSP super(SDBConnection, self).__init__(aws_access_key_id, aws_secret_access_key, is_secure, port, proxy, proxy_port, proxy_user, proxy_pass, self.region.endpoint, debug, https_connection_factory, path, security_token=security_token, validate_certs=validate_certs, profile_name=profile_name) DCNL DCSP self.box_usage = 0.0 DCNL DCSP self.converter = converter DCNL DCSP self.item_cls = Item
def set_item_cls(self, cls): DCNL DCSP self.item_cls = cls
def get_usage(self): DCNL DCSP return self.box_usage
def print_usage(self): DCNL DCSP print ('Total DCSP Usage: DCSP %f DCSP compute DCSP seconds' % self.box_usage) DCNL DCSP cost = (self.box_usage * 0.14) DCNL DCSP print ('Approximate DCSP Cost: DCSP $%f' % cost)
def get_domain(self, domain_name, validate=True): DCNL DCSP domain = Domain(self, domain_name) DCNL DCSP if validate: DCNL DCSP  DCSP self.select(domain, ('select DCSP * DCSP from DCSP `%s` DCSP limit DCSP 1' % domain_name)) DCNL DCSP return domain
def lookup(self, domain_name, validate=True): DCNL DCSP try: DCNL DCSP  DCSP domain = self.get_domain(domain_name, validate) DCNL DCSP except: DCNL DCSP  DCSP domain = None DCNL DCSP return domain
def get_all_domains(self, max_domains=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if max_domains: DCNL DCSP  DCSP params['MaxNumberOfDomains'] = max_domains DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('ListDomains', params, [('DomainName', Domain)])
def create_domain(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP d = self.get_object('CreateDomain', params, Domain) DCNL DCSP d.name = domain_name DCNL DCSP return d
def get_domain_and_name(self, domain_or_name): DCNL DCSP if isinstance(domain_or_name, Domain): DCNL DCSP  DCSP return (domain_or_name, domain_or_name.name) DCNL DCSP else: DCNL DCSP  DCSP return (self.get_domain(domain_or_name), domain_or_name)
def delete_domain(self, domain_or_name): DCNL DCSP (domain, domain_name) = self.get_domain_and_name(domain_or_name) DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.get_status('DeleteDomain', params)
def domain_metadata(self, domain_or_name): DCNL DCSP (domain, domain_name) = self.get_domain_and_name(domain_or_name) DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP d = self.get_object('DomainMetadata', params, DomainMetaData) DCNL DCSP d.domain = domain DCNL DCSP return d
def put_attributes(self, domain_or_name, item_name, attributes, replace=True, expected_value=None): DCNL DCSP (domain, domain_name) = self.get_domain_and_name(domain_or_name) DCNL DCSP params = {'DomainName': domain_name, 'ItemName': item_name} DCNL DCSP self._build_name_value_list(params, attributes, replace) DCNL DCSP if expected_value: DCNL DCSP  DCSP self._build_expected_value(params, expected_value) DCNL DCSP return self.get_status('PutAttributes', params)
def batch_put_attributes(self, domain_or_name, items, replace=True): DCNL DCSP (domain, domain_name) = self.get_domain_and_name(domain_or_name) DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP self._build_batch_list(params, items, replace) DCNL DCSP return self.get_status('BatchPutAttributes', params, verb='POST')
def get_attributes(self, domain_or_name, item_name, attribute_names=None, consistent_read=False, item=None): DCNL DCSP (domain, domain_name) = self.get_domain_and_name(domain_or_name) DCNL DCSP params = {'DomainName': domain_name, 'ItemName': item_name} DCNL DCSP if consistent_read: DCNL DCSP  DCSP params['ConsistentRead'] = 'true' DCNL DCSP if attribute_names: DCNL DCSP  DCSP if (not isinstance(attribute_names, list)): DCNL DCSP  DCSP  DCSP attribute_names = [attribute_names] DCNL DCSP  DCSP self.build_list_params(params, attribute_names, 'AttributeName') DCNL DCSP response = self.make_request('GetAttributes', params) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP item = self.item_cls(domain, item_name) DCNL DCSP  DCSP h = handler.XmlHandler(item, self) DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return item DCNL DCSP else: DCNL DCSP  DCSP raise SDBResponseError(response.status, response.reason, body)
def delete_attributes(self, domain_or_name, item_name, attr_names=None, expected_value=None): DCNL DCSP (domain, domain_name) = self.get_domain_and_name(domain_or_name) DCNL DCSP params = {'DomainName': domain_name, 'ItemName': item_name} DCNL DCSP if attr_names: DCNL DCSP  DCSP if isinstance(attr_names, list): DCNL DCSP  DCSP  DCSP self._build_name_list(params, attr_names) DCNL DCSP  DCSP elif (isinstance(attr_names, dict) or isinstance(attr_names, self.item_cls)): DCNL DCSP  DCSP  DCSP self._build_name_value_list(params, attr_names) DCNL DCSP if expected_value: DCNL DCSP  DCSP self._build_expected_value(params, expected_value) DCNL DCSP return self.get_status('DeleteAttributes', params)
def batch_delete_attributes(self, domain_or_name, items): DCNL DCSP (domain, domain_name) = self.get_domain_and_name(domain_or_name) DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP self._build_batch_list(params, items, False) DCNL DCSP return self.get_status('BatchDeleteAttributes', params, verb='POST')
def select(self, domain_or_name, query='', next_token=None, consistent_read=False): DCNL DCSP (domain, domain_name) = self.get_domain_and_name(domain_or_name) DCNL DCSP params = {'SelectExpression': query} DCNL DCSP if consistent_read: DCNL DCSP  DCSP params['ConsistentRead'] = 'true' DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP try: DCNL DCSP  DCSP return self.get_list('Select', params, [('Item', self.item_cls)], parent=domain) DCNL DCSP except SDBResponseError as e: DCNL DCSP  DCSP e.body = ('Query: DCSP %s\n%s' % (query, e.body)) DCNL DCSP  DCSP raise e
def __init__(self, host, cert, reason): DCNL DCSP http_client.HTTPException.__init__(self) DCNL DCSP self.host = host DCNL DCSP self.cert = cert DCNL DCSP self.reason = reason
def __init__(self, host, port=default_port, key_file=None, cert_file=None, ca_certs=None, strict=None, **kwargs): DCNL DCSP if six.PY2: DCNL DCSP  DCSP kwargs['strict'] = strict DCNL DCSP http_client.HTTPConnection.__init__(self, host=host, port=port, **kwargs) DCNL DCSP self.key_file = key_file DCNL DCSP self.cert_file = cert_file DCNL DCSP self.ca_certs = ca_certs
def connect(self): DCNL DCSP if hasattr(self, 'timeout'): DCNL DCSP  DCSP sock = socket.create_connection((self.host, self.port), self.timeout) DCNL DCSP else: DCNL DCSP  DCSP sock = socket.create_connection((self.host, self.port)) DCNL DCSP msg = 'wrapping DCSP ssl DCSP socket; DCSP ' DCNL DCSP if self.ca_certs: DCNL DCSP  DCSP msg += ('CA DCSP certificate DCSP file=%s' % self.ca_certs) DCNL DCSP else: DCNL DCSP  DCSP msg += 'using DCSP system DCSP provided DCSP SSL DCSP certs' DCNL DCSP boto.log.debug(msg) DCNL DCSP self.sock = ssl.wrap_socket(sock, keyfile=self.key_file, certfile=self.cert_file, cert_reqs=ssl.CERT_REQUIRED, ca_certs=self.ca_certs) DCNL DCSP cert = self.sock.getpeercert() DCNL DCSP hostname = self.host.split(':', 0)[0] DCNL DCSP if (not ValidateCertificateHostname(cert, hostname)): DCNL DCSP  DCSP raise InvalidCertificateException(hostname, cert, ('remote DCSP hostname DCSP "%s" DCSP does DCSP not DCSP match DCSP certificate' % hostname))
def _post_request(self, request, params, parser, body='', headers=None): DCNL DCSP headers = (headers or {}) DCNL DCSP path = self._sandboxify(request['path']) DCNL DCSP request = self.build_base_http_request('POST', path, None, data=body, params=params, headers=headers, host=self.host) DCNL DCSP try: DCNL DCSP  DCSP response = self._mexe(request, override_num_retries=None) DCNL DCSP except BotoServerError as bs: DCNL DCSP  DCSP raise self._response_error_factory(bs.status, bs.reason, bs.body) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (not body): DCNL DCSP  DCSP boto.log.error(('Null DCSP body DCSP %s' % body)) DCNL DCSP  DCSP raise self._response_error_factory(response.status, response.reason, body) DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP boto.log.error(('%s DCSP %s' % (response.status, response.reason))) DCNL DCSP  DCSP boto.log.error(('%s' % body)) DCNL DCSP  DCSP raise self._response_error_factory(response.status, response.reason, body) DCNL DCSP digest = response.getheader('Content-MD5') DCNL DCSP if (digest is not None): DCNL DCSP  DCSP assert (content_md5(body) == digest) DCNL DCSP contenttype = response.getheader('Content-Type') DCNL DCSP return self._parse_response(parser, contenttype, body)
def method_for(self, name): DCNL DCSP action = ((('_' in name) and string.capwords(name, '_')) or name) DCNL DCSP if (action in api_call_map): DCNL DCSP  DCSP return getattr(self, api_call_map[action]) DCNL DCSP return None
def iter_call(self, call, *args, **kw): DCNL DCSP method = self.method_for(call) DCNL DCSP assert method, 'No DCSP call DCSP named DCSP "{0}"'.format(call) DCNL DCSP return self.iter_response(method(*args, **kw))
def iter_response(self, response): DCNL DCSP (yield response) DCNL DCSP more = self.method_for((response._action + 'ByNextToken')) DCNL DCSP while (more and (response._result.HasNext == 'true')): DCNL DCSP  DCSP response = more(NextToken=response._result.NextToken) DCNL DCSP  DCSP (yield response)
@requires(['FeedType']) DCNL @boolean_arguments('PurgeAndReplace') DCNL @http_body('FeedContent') DCNL @structured_lists('MarketplaceIdList.Id') DCNL @api_action('Feeds', 15, 120) DCNL def submit_feed(self, request, response, headers=None, body='', **kw): DCNL DCSP headers = (headers or {}) DCNL DCSP return self._post_request(request, kw, response, body=body, headers=headers)
@structured_lists('FeedSubmissionIdList.Id', 'FeedTypeList.Type', 'FeedProcessingStatusList.Status') DCNL @api_action('Feeds', 10, 45) DCNL def get_feed_submission_list(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Feeds', 0, 0) DCNL def get_feed_submission_list_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@structured_lists('FeedTypeList.Type', 'FeedProcessingStatusList.Status') DCNL @api_action('Feeds', 10, 45) DCNL def get_feed_submission_count(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@structured_lists('FeedSubmissionIdList.Id', 'FeedTypeList.Type') DCNL @api_action('Feeds', 10, 45) DCNL def cancel_feed_submissions(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['FeedSubmissionId']) DCNL @api_action('Feeds', 15, 60) DCNL def get_feed_submission_result(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
def get_service_status(self, **kw): DCNL DCSP sections = ', DCSP '.join(map(str.lower, api_version_path.keys())) DCNL DCSP message = 'Use DCSP {0}.get_(section)_service_status(), DCSP where DCSP (section) DCSP is DCSP one DCSP of DCSP the DCSP following: DCSP {1}'.format(self.__class__.__name__, sections) DCNL DCSP raise AttributeError(message)
@requires(['ReportType']) DCNL @structured_lists('MarketplaceIdList.Id') DCNL @boolean_arguments('ReportOptions=ShowSalesChannel') DCNL @api_action('Reports', 15, 60) DCNL def request_report(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@structured_lists('ReportRequestIdList.Id', 'ReportTypeList.Type', 'ReportProcessingStatusList.Status') DCNL @api_action('Reports', 10, 45) DCNL def get_report_request_list(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Reports', 0, 0) DCNL def get_report_request_list_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@structured_lists('ReportTypeList.Type', 'ReportProcessingStatusList.Status') DCNL @api_action('Reports', 10, 45) DCNL def get_report_request_count(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Reports', 10, 45) DCNL def cancel_report_requests(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@boolean_arguments('Acknowledged') DCNL @structured_lists('ReportRequestIdList.Id', 'ReportTypeList.Type') DCNL @api_action('Reports', 10, 60) DCNL def get_report_list(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Reports', 0, 0) DCNL def get_report_list_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@boolean_arguments('Acknowledged') DCNL @structured_lists('ReportTypeList.Type') DCNL @api_action('Reports', 10, 45) DCNL def get_report_count(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['ReportId']) DCNL @api_action('Reports', 15, 60) DCNL def get_report(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['ReportType', 'Schedule']) DCNL @api_action('Reports', 10, 45) DCNL def manage_report_schedule(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@structured_lists('ReportTypeList.Type') DCNL @api_action('Reports', 10, 45) DCNL def get_report_schedule_list(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Reports', 0, 0) DCNL def get_report_schedule_list_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@structured_lists('ReportTypeList.Type') DCNL @api_action('Reports', 10, 45) DCNL def get_report_schedule_count(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['ReportIdList']) DCNL @boolean_arguments('Acknowledged') DCNL @structured_lists('ReportIdList.Id') DCNL @api_action('Reports', 10, 45) DCNL def update_report_acknowledgements(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['ShipFromAddress', 'InboundShipmentPlanRequestItems']) DCNL @structured_objects('ShipFromAddress', 'InboundShipmentPlanRequestItems') DCNL @api_action('Inbound', 30, 0.5) DCNL def create_inbound_shipment_plan(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['ShipmentId', 'InboundShipmentHeader', 'InboundShipmentItems']) DCNL @structured_objects('InboundShipmentHeader', 'InboundShipmentItems') DCNL @api_action('Inbound', 30, 0.5) DCNL def create_inbound_shipment(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['ShipmentId']) DCNL @structured_objects('InboundShipmentHeader', 'InboundShipmentItems') DCNL @api_action('Inbound', 30, 0.5) DCNL def update_inbound_shipment(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires_some_of('ShipmentIdList', 'ShipmentStatusList') DCNL @structured_lists('ShipmentIdList.Id', 'ShipmentStatusList.Status') DCNL @api_action('Inbound', 30, 0.5) DCNL def list_inbound_shipments(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Inbound', 30, 0.5) DCNL def list_inbound_shipments_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['ShipmentId'], ['LastUpdatedAfter', 'LastUpdatedBefore']) DCNL @api_action('Inbound', 30, 0.5) DCNL def list_inbound_shipment_items(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Inbound', 30, 0.5) DCNL def list_inbound_shipment_items_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Inbound', 2, 300, 'GetServiceStatus') DCNL def get_inbound_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['SellerSkus'], ['QueryStartDateTime']) DCNL @structured_lists('SellerSkus.member') DCNL @api_action('Inventory', 30, 0.5) DCNL def list_inventory_supply(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Inventory', 30, 0.5) DCNL def list_inventory_supply_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Inventory', 2, 300, 'GetServiceStatus') DCNL def get_inventory_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['PackageNumber']) DCNL @api_action('Outbound', 30, 0.5) DCNL def get_package_tracking_details(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['Address', 'Items']) DCNL @structured_objects('Address', 'Items') DCNL @api_action('Outbound', 30, 0.5) DCNL def get_fulfillment_preview(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['SellerFulfillmentOrderId', 'DisplayableOrderId', 'ShippingSpeedCategory', 'DisplayableOrderDateTime', 'DestinationAddress', 'DisplayableOrderComment', 'Items']) DCNL @structured_objects('DestinationAddress', 'Items') DCNL @api_action('Outbound', 30, 0.5) DCNL def create_fulfillment_order(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['SellerFulfillmentOrderId']) DCNL @api_action('Outbound', 30, 0.5) DCNL def get_fulfillment_order(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Outbound', 30, 0.5) DCNL def list_all_fulfillment_orders(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Outbound', 30, 0.5) DCNL def list_all_fulfillment_orders_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['SellerFulfillmentOrderId']) DCNL @api_action('Outbound', 30, 0.5) DCNL def cancel_fulfillment_order(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Outbound', 2, 300, 'GetServiceStatus') DCNL def get_outbound_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['CreatedAfter'], ['LastUpdatedAfter']) DCNL @requires(['MarketplaceId']) DCNL @exclusive(['CreatedAfter'], ['LastUpdatedAfter']) DCNL @dependent('CreatedBefore', ['CreatedAfter']) DCNL @exclusive(['LastUpdatedAfter'], ['BuyerEmail'], ['SellerOrderId']) DCNL @dependent('LastUpdatedBefore', ['LastUpdatedAfter']) DCNL @exclusive(['CreatedAfter'], ['LastUpdatedBefore']) DCNL @structured_objects('OrderTotal', 'ShippingAddress', 'PaymentExecutionDetail') DCNL @structured_lists('MarketplaceId.Id', 'OrderStatus.Status', 'FulfillmentChannel.Channel', 'PaymentMethod.') DCNL @api_action('Orders', 6, 60) DCNL def list_orders(self, request, response, **kw): DCNL DCSP toggle = set(('FulfillmentChannel.Channel.1', 'OrderStatus.Status.1', 'PaymentMethod.1', 'LastUpdatedAfter', 'LastUpdatedBefore')) DCNL DCSP for (do, dont) in {'BuyerEmail': toggle.union(['SellerOrderId']), 'SellerOrderId': toggle.union(['BuyerEmail'])}.items(): DCNL DCSP  DCSP if ((do in kw) and any(((i in dont) for i in kw))): DCNL DCSP  DCSP  DCSP message = "Don't DCSP include DCSP {0} DCSP when DCSP specifying DCSP {1}".format(' DCSP or DCSP '.join(dont), do) DCNL DCSP  DCSP  DCSP raise AssertionError(message) DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Orders', 6, 60) DCNL def list_orders_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonOrderId']) DCNL @structured_lists('AmazonOrderId.Id') DCNL @api_action('Orders', 6, 60) DCNL def get_order(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonOrderId']) DCNL @api_action('Orders', 30, 2) DCNL def list_order_items(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Orders', 30, 2) DCNL def list_order_items_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Orders', 2, 300, 'GetServiceStatus') DCNL def get_orders_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'Query']) DCNL @api_action('Products', 20, 20) DCNL def list_matching_products(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'ASINList']) DCNL @structured_lists('ASINList.ASIN') DCNL @api_action('Products', 20, 20) DCNL def get_matching_product(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'IdType', 'IdList']) DCNL @structured_lists('IdList.Id') DCNL @api_action('Products', 20, 20) DCNL def get_matching_product_for_id(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'SellerSKUList']) DCNL @structured_lists('SellerSKUList.SellerSKU') DCNL @api_action('Products', 20, 10, 'GetCompetitivePricingForSKU') DCNL def get_competitive_pricing_for_sku(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'ASINList']) DCNL @structured_lists('ASINList.ASIN') DCNL @api_action('Products', 20, 10, 'GetCompetitivePricingForASIN') DCNL def get_competitive_pricing_for_asin(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'SellerSKUList']) DCNL @structured_lists('SellerSKUList.SellerSKU') DCNL @api_action('Products', 20, 5, 'GetLowestOfferListingsForSKU') DCNL def get_lowest_offer_listings_for_sku(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'ASINList']) DCNL @structured_lists('ASINList.ASIN') DCNL @api_action('Products', 20, 5, 'GetLowestOfferListingsForASIN') DCNL def get_lowest_offer_listings_for_asin(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'SellerSKU']) DCNL @api_action('Products', 20, 20, 'GetProductCategoriesForSKU') DCNL def get_product_categories_for_sku(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'ASIN']) DCNL @api_action('Products', 20, 20, 'GetProductCategoriesForASIN') DCNL def get_product_categories_for_asin(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Products', 2, 300, 'GetServiceStatus') DCNL def get_products_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'SellerSKUList']) DCNL @structured_lists('SellerSKUList.SellerSKU') DCNL @api_action('Products', 20, 10, 'GetMyPriceForSKU') DCNL def get_my_price_for_sku(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'ASINList']) DCNL @structured_lists('ASINList.ASIN') DCNL @api_action('Products', 20, 10, 'GetMyPriceForASIN') DCNL def get_my_price_for_asin(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Sellers', 15, 60) DCNL def list_marketplace_participations(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Sellers', 15, 60) DCNL def list_marketplace_participations_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId']) DCNL @api_action('Recommendations', 5, 2) DCNL def get_last_updated_time_for_recommendations(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId']) DCNL @structured_lists('CategoryQueryList.CategoryQuery') DCNL @api_action('Recommendations', 5, 2) DCNL def list_recommendations(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('Recommendations', 5, 2) DCNL def list_recommendations_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Recommendations', 2, 300, 'GetServiceStatus') DCNL def get_recommendations_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('CustomerInfo', 15, 12) DCNL def list_customers(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('CustomerInfo', 50, 3) DCNL def list_customers_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['CustomerIdList']) DCNL @structured_lists('CustomerIdList.CustomerId') DCNL @api_action('CustomerInfo', 15, 12) DCNL def get_customers_for_customer_id(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('CustomerInfo', 2, 300, 'GetServiceStatus') DCNL def get_customerinfo_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['DateRangeStart']) DCNL @api_action('CartInfo', 15, 12) DCNL def list_carts(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['NextToken']) DCNL @api_action('CartInfo', 50, 3) DCNL def list_carts_by_next_token(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['CartIdList']) DCNL @structured_lists('CartIdList.CartId') DCNL @api_action('CartInfo', 15, 12) DCNL def get_carts(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('CartInfo', 2, 300, 'GetServiceStatus') DCNL def get_cartinfo_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def register_destination(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def deregister_destination(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId']) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def list_registered_destinations(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def send_test_notification_to_destination(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'Subscription']) DCNL @structured_objects('Subscription', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def create_subscription(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'NotificationType', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def get_subscription(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'NotificationType', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def delete_subscription(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId']) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def list_subscriptions(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['MarketplaceId', 'Subscription']) DCNL @structured_objects('Subscription', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def update_subscription(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('Subscriptions', 2, 300, 'GetServiceStatus') DCNL def get_subscriptions_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonOrderReferenceId', 'OrderReferenceAttributes']) DCNL @structured_objects('OrderReferenceAttributes') DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def set_order_reference_details(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonOrderReferenceId']) DCNL @api_action('OffAmazonPayments', 20, 2) DCNL def get_order_reference_details(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonOrderReferenceId']) DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def confirm_order_reference(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonOrderReferenceId']) DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def cancel_order_reference(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonOrderReferenceId']) DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def close_order_reference(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonOrderReferenceId', 'AuthorizationReferenceId', 'AuthorizationAmount']) DCNL @structured_objects('AuthorizationAmount') DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def authorize(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonAuthorizationId']) DCNL @api_action('OffAmazonPayments', 20, 2) DCNL def get_authorization_details(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonAuthorizationId', 'CaptureReferenceId', 'CaptureAmount']) DCNL @structured_objects('CaptureAmount') DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def capture(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonCaptureId']) DCNL @api_action('OffAmazonPayments', 20, 2) DCNL def get_capture_details(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonAuthorizationId']) DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def close_authorization(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonCaptureId', 'RefundReferenceId', 'RefundAmount']) DCNL @structured_objects('RefundAmount') DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def refund(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@requires(['AmazonRefundId']) DCNL @api_action('OffAmazonPayments', 20, 2) DCNL def get_refund_details(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
@api_action('OffAmazonPayments', 2, 300, 'GetServiceStatus') DCNL def get_offamazonpayments_service_status(self, request, response, **kw): DCNL DCSP return self._post_request(request, kw, response)
def __init__(self, layer1, data): DCNL DCSP self.layer1 = layer1 DCNL DCSP self.update_from_data(data)
def delete(self): DCNL DCSP return self.layer1.delete_domain(self.name)
def get_analysis_schemes(self): DCNL DCSP return self.layer1.describe_analysis_schemes(self.name)
def get_availability_options(self): DCNL DCSP return AvailabilityOptionsStatus(self, refresh_fn=self.layer1.describe_availability_options, refresh_key=['DescribeAvailabilityOptionsResponse', 'DescribeAvailabilityOptionsResult', 'AvailabilityOptions'], save_fn=self.layer1.update_availability_options)
def get_scaling_options(self): DCNL DCSP return ScalingParametersStatus(self, refresh_fn=self.layer1.describe_scaling_parameters, refresh_key=['DescribeScalingParametersResponse', 'DescribeScalingParametersResult', 'ScalingParameters'], save_fn=self.layer1.update_scaling_parameters)
def get_access_policies(self): DCNL DCSP return ServicePoliciesStatus(self, refresh_fn=self.layer1.describe_service_access_policies, refresh_key=['DescribeServiceAccessPoliciesResponse', 'DescribeServiceAccessPoliciesResult', 'AccessPolicies'], save_fn=self.layer1.update_service_access_policies)
def index_documents(self): DCNL DCSP self.layer1.index_documents(self.name)
def get_index_fields(self, field_names=None): DCNL DCSP data = self.layer1.describe_index_fields(self.name, field_names) DCNL DCSP data = data['DescribeIndexFieldsResponse']['DescribeIndexFieldsResult']['IndexFields'] DCNL DCSP return [IndexFieldStatus(self, d) for d in data]
def create_index_field(self, field_name, field_type, default='', facet=False, returnable=False, searchable=False, sortable=False, highlight=False, source_field=None, analysis_scheme=None): DCNL DCSP index = {'IndexFieldName': field_name, 'IndexFieldType': field_type} DCNL DCSP if (field_type == 'literal'): DCNL DCSP  DCSP index['LiteralOptions'] = {'FacetEnabled': facet, 'ReturnEnabled': returnable, 'SearchEnabled': searchable, 'SortEnabled': sortable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['LiteralOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['LiteralOptions']['SourceField'] = source_field DCNL DCSP elif (field_type == 'literal-array'): DCNL DCSP  DCSP index['LiteralArrayOptions'] = {'FacetEnabled': facet, 'ReturnEnabled': returnable, 'SearchEnabled': searchable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['LiteralArrayOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['LiteralArrayOptions']['SourceFields'] = ','.join(source_field) DCNL DCSP elif (field_type == 'int'): DCNL DCSP  DCSP index['IntOptions'] = {'DefaultValue': default, 'FacetEnabled': facet, 'ReturnEnabled': returnable, 'SearchEnabled': searchable, 'SortEnabled': sortable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['IntOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['IntOptions']['SourceField'] = source_field DCNL DCSP elif (field_type == 'int-array'): DCNL DCSP  DCSP index['IntArrayOptions'] = {'FacetEnabled': facet, 'ReturnEnabled': returnable, 'SearchEnabled': searchable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['IntArrayOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['IntArrayOptions']['SourceFields'] = ','.join(source_field) DCNL DCSP elif (field_type == 'date'): DCNL DCSP  DCSP index['DateOptions'] = {'FacetEnabled': facet, 'ReturnEnabled': returnable, 'SearchEnabled': searchable, 'SortEnabled': sortable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['DateOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['DateOptions']['SourceField'] = source_field DCNL DCSP elif (field_type == 'date-array'): DCNL DCSP  DCSP index['DateArrayOptions'] = {'FacetEnabled': facet, 'ReturnEnabled': returnable, 'SearchEnabled': searchable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['DateArrayOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['DateArrayOptions']['SourceFields'] = ','.join(source_field) DCNL DCSP elif (field_type == 'double'): DCNL DCSP  DCSP index['DoubleOptions'] = {'FacetEnabled': facet, 'ReturnEnabled': returnable, 'SearchEnabled': searchable, 'SortEnabled': sortable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['DoubleOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['DoubleOptions']['SourceField'] = source_field DCNL DCSP elif (field_type == 'double-array'): DCNL DCSP  DCSP index['DoubleArrayOptions'] = {'FacetEnabled': facet, 'ReturnEnabled': returnable, 'SearchEnabled': searchable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['DoubleArrayOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['DoubleArrayOptions']['SourceFields'] = ','.join(source_field) DCNL DCSP elif (field_type == 'text'): DCNL DCSP  DCSP index['TextOptions'] = {'ReturnEnabled': returnable, 'HighlightEnabled': highlight, 'SortEnabled': sortable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['TextOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['TextOptions']['SourceField'] = source_field DCNL DCSP  DCSP if analysis_scheme: DCNL DCSP  DCSP  DCSP index['TextOptions']['AnalysisScheme'] = analysis_scheme DCNL DCSP elif (field_type == 'text-array'): DCNL DCSP  DCSP index['TextArrayOptions'] = {'ReturnEnabled': returnable, 'HighlightEnabled': highlight} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['TextArrayOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['TextArrayOptions']['SourceFields'] = ','.join(source_field) DCNL DCSP  DCSP if analysis_scheme: DCNL DCSP  DCSP  DCSP index['TextArrayOptions']['AnalysisScheme'] = analysis_scheme DCNL DCSP elif (field_type == 'latlon'): DCNL DCSP  DCSP index['LatLonOptions'] = {'FacetEnabled': facet, 'ReturnEnabled': returnable, 'SearchEnabled': searchable, 'SortEnabled': sortable} DCNL DCSP  DCSP if default: DCNL DCSP  DCSP  DCSP index['LatLonOptions']['DefaultValue'] = default DCNL DCSP  DCSP if source_field: DCNL DCSP  DCSP  DCSP index['LatLonOptions']['SourceField'] = source_field DCNL DCSP data = self.layer1.define_index_field(self.name, index) DCNL DCSP data = data['DefineIndexFieldResponse']['DefineIndexFieldResult']['IndexField'] DCNL DCSP return IndexFieldStatus(self, data, self.layer1.describe_index_fields)
def get_expressions(self, names=None): DCNL DCSP fn = self.layer1.describe_expressions DCNL DCSP data = fn(self.name, names) DCNL DCSP data = data['DescribeExpressionsResponse']['DescribeExpressionsResult']['Expressions'] DCNL DCSP return [ExpressionStatus(self, d, fn) for d in data]
def create_expression(self, name, value): DCNL DCSP data = self.layer1.define_expression(self.name, name, value) DCNL DCSP data = data['DefineExpressionResponse']['DefineExpressionResult']['Expression'] DCNL DCSP return ExpressionStatus(self, data, self.layer1.describe_expressions)
def next_page(self): DCNL DCSP if (self.query.page <= self.num_pages_needed): DCNL DCSP  DCSP self.query.start += self.query.real_size DCNL DCSP  DCSP self.query.page += 1 DCNL DCSP  DCSP return self.search_service(self.query) DCNL DCSP else: DCNL DCSP  DCSP raise StopIteration
def to_params(self): DCNL DCSP params = {'start': self.start, 'size': self.real_size} DCNL DCSP if self.q: DCNL DCSP  DCSP params['q'] = self.q DCNL DCSP if self.parser: DCNL DCSP  DCSP params['q.parser'] = self.parser DCNL DCSP if self.fq: DCNL DCSP  DCSP params['fq'] = self.fq DCNL DCSP if self.expr: DCNL DCSP  DCSP for (k, v) in six.iteritems(self.expr): DCNL DCSP  DCSP  DCSP params[('expr.%s' % k)] = v DCNL DCSP if self.facet: DCNL DCSP  DCSP for (k, v) in six.iteritems(self.facet): DCNL DCSP  DCSP  DCSP if (not isinstance(v, six.string_types)): DCNL DCSP  DCSP  DCSP  DCSP v = json.dumps(v) DCNL DCSP  DCSP  DCSP params[('facet.%s' % k)] = v DCNL DCSP if self.highlight: DCNL DCSP  DCSP for (k, v) in six.iteritems(self.highlight): DCNL DCSP  DCSP  DCSP params[('highlight.%s' % k)] = v DCNL DCSP if self.options: DCNL DCSP  DCSP params['q.options'] = self.options DCNL DCSP if self.return_fields: DCNL DCSP  DCSP params['return'] = ','.join(self.return_fields) DCNL DCSP if (self.partial is not None): DCNL DCSP  DCSP params['partial'] = self.partial DCNL DCSP if self.sort: DCNL DCSP  DCSP params['sort'] = ','.join(self.sort) DCNL DCSP return params
def to_domain_connection_params(self): DCNL DCSP params = {'start': self.start, 'size': self.real_size} DCNL DCSP if self.q: DCNL DCSP  DCSP params['q'] = self.q DCNL DCSP if self.parser: DCNL DCSP  DCSP params['query_parser'] = self.parser DCNL DCSP if self.fq: DCNL DCSP  DCSP params['filter_query'] = self.fq DCNL DCSP if self.expr: DCNL DCSP  DCSP expr = {} DCNL DCSP  DCSP for (k, v) in six.iteritems(self.expr): DCNL DCSP  DCSP  DCSP expr[('expr.%s' % k)] = v DCNL DCSP  DCSP params['expr'] = expr DCNL DCSP if self.facet: DCNL DCSP  DCSP facet = {} DCNL DCSP  DCSP for (k, v) in six.iteritems(self.facet): DCNL DCSP  DCSP  DCSP if (not isinstance(v, six.string_types)): DCNL DCSP  DCSP  DCSP  DCSP v = json.dumps(v) DCNL DCSP  DCSP  DCSP facet[('facet.%s' % k)] = v DCNL DCSP  DCSP params['facet'] = facet DCNL DCSP if self.highlight: DCNL DCSP  DCSP highlight = {} DCNL DCSP  DCSP for (k, v) in six.iteritems(self.highlight): DCNL DCSP  DCSP  DCSP highlight[('highlight.%s' % k)] = v DCNL DCSP  DCSP params['highlight'] = highlight DCNL DCSP if self.options: DCNL DCSP  DCSP params['query_options'] = self.options DCNL DCSP if self.return_fields: DCNL DCSP  DCSP params['ret'] = ','.join(self.return_fields) DCNL DCSP if (self.partial is not None): DCNL DCSP  DCSP params['partial'] = self.partial DCNL DCSP if self.sort: DCNL DCSP  DCSP params['sort'] = ','.join(self.sort) DCNL DCSP return params
def search(self, q=None, parser=None, fq=None, rank=None, return_fields=None, size=10, start=0, facet=None, highlight=None, sort=None, partial=None, options=None): DCNL DCSP query = self.build_query(q=q, parser=parser, fq=fq, rank=rank, return_fields=return_fields, size=size, start=start, facet=facet, highlight=highlight, sort=sort, partial=partial, options=options) DCNL DCSP return self(query)
def __call__(self, query): DCNL DCSP api_version = '2013-01-01' DCNL DCSP if (self.domain and self.domain.layer1): DCNL DCSP  DCSP api_version = self.domain.layer1.APIVersion DCNL DCSP if self.sign_request: DCNL DCSP  DCSP data = self._search_with_auth(query.to_domain_connection_params()) DCNL DCSP else: DCNL DCSP  DCSP r = self._search_without_auth(query.to_params(), api_version) DCNL DCSP  DCSP _body = r['body'] DCNL DCSP  DCSP _status_code = r['status_code'] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = json.loads(_body) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if (_status_code == 403): DCNL DCSP  DCSP  DCSP  DCSP msg = '' DCNL DCSP  DCSP  DCSP  DCSP import re DCNL DCSP  DCSP  DCSP  DCSP g = re.search('<html><body><h1>403 DCSP Forbidden</h1>([^<]+)<', _body) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (': DCSP %s' % g.groups()[0].strip()) DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP raise SearchServiceException(('Authentication DCSP error DCSP from DCSP Amazon%s' % msg)) DCNL DCSP  DCSP  DCSP raise SearchServiceException(('Got DCSP non-json DCSP response DCSP from DCSP Amazon. DCSP %s' % _body), query) DCNL DCSP if (('messages' in data) and ('error' in data)): DCNL DCSP  DCSP for m in data['messages']: DCNL DCSP  DCSP  DCSP if (m['severity'] == 'fatal'): DCNL DCSP  DCSP  DCSP  DCSP raise SearchServiceException(('Error DCSP processing DCSP search DCSP %s DCSP => DCSP %s' % (params, m['message'])), query) DCNL DCSP elif ('error' in data): DCNL DCSP  DCSP raise SearchServiceException(('Unknown DCSP error DCSP processing DCSP search DCSP %s' % json.dumps(data)), query) DCNL DCSP data['query'] = query DCNL DCSP data['search_service'] = self DCNL DCSP return SearchResults(**data)
def get_all_paged(self, query, per_page): DCNL DCSP query.update_size(per_page) DCNL DCSP page = 0 DCNL DCSP num_pages_needed = 0 DCNL DCSP while (page <= num_pages_needed): DCNL DCSP  DCSP results = self(query) DCNL DCSP  DCSP num_pages_needed = results.num_pages_needed DCNL DCSP  DCSP (yield results) DCNL DCSP  DCSP query.start += query.real_size DCNL DCSP  DCSP page += 1
def get_all_hits(self, query): DCNL DCSP page = 0 DCNL DCSP num_pages_needed = 0 DCNL DCSP while (page <= num_pages_needed): DCNL DCSP  DCSP results = self(query) DCNL DCSP  DCSP num_pages_needed = results.num_pages_needed DCNL DCSP  DCSP for doc in results: DCNL DCSP  DCSP  DCSP (yield doc) DCNL DCSP  DCSP query.start += query.real_size DCNL DCSP  DCSP page += 1
def get_num_hits(self, query): DCNL DCSP query.update_size(1) DCNL DCSP return self(query).hits
def build_suggesters(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self._make_request(action='BuildSuggesters', verb='POST', path='/', params=params)
def create_domain(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self._make_request(action='CreateDomain', verb='POST', path='/', params=params)
def define_analysis_scheme(self, domain_name, analysis_scheme): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP self.build_complex_param(params, 'AnalysisScheme', analysis_scheme) DCNL DCSP return self._make_request(action='DefineAnalysisScheme', verb='POST', path='/', params=params)
def define_expression(self, domain_name, expression): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP self.build_complex_param(params, 'Expression', expression) DCNL DCSP return self._make_request(action='DefineExpression', verb='POST', path='/', params=params)
def define_index_field(self, domain_name, index_field): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP self.build_complex_param(params, 'IndexField', index_field) DCNL DCSP return self._make_request(action='DefineIndexField', verb='POST', path='/', params=params)
def define_suggester(self, domain_name, suggester): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP self.build_complex_param(params, 'Suggester', suggester) DCNL DCSP return self._make_request(action='DefineSuggester', verb='POST', path='/', params=params)
def delete_analysis_scheme(self, domain_name, analysis_scheme_name): DCNL DCSP params = {'DomainName': domain_name, 'AnalysisSchemeName': analysis_scheme_name} DCNL DCSP return self._make_request(action='DeleteAnalysisScheme', verb='POST', path='/', params=params)
def delete_domain(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self._make_request(action='DeleteDomain', verb='POST', path='/', params=params)
def delete_expression(self, domain_name, expression_name): DCNL DCSP params = {'DomainName': domain_name, 'ExpressionName': expression_name} DCNL DCSP return self._make_request(action='DeleteExpression', verb='POST', path='/', params=params)
def delete_index_field(self, domain_name, index_field_name): DCNL DCSP params = {'DomainName': domain_name, 'IndexFieldName': index_field_name} DCNL DCSP return self._make_request(action='DeleteIndexField', verb='POST', path='/', params=params)
def delete_suggester(self, domain_name, suggester_name): DCNL DCSP params = {'DomainName': domain_name, 'SuggesterName': suggester_name} DCNL DCSP return self._make_request(action='DeleteSuggester', verb='POST', path='/', params=params)
def describe_analysis_schemes(self, domain_name, analysis_scheme_names=None, deployed=None): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if (analysis_scheme_names is not None): DCNL DCSP  DCSP self.build_list_params(params, analysis_scheme_names, 'AnalysisSchemeNames.member') DCNL DCSP if (deployed is not None): DCNL DCSP  DCSP params['Deployed'] = str(deployed).lower() DCNL DCSP return self._make_request(action='DescribeAnalysisSchemes', verb='POST', path='/', params=params)
def describe_availability_options(self, domain_name, deployed=None): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if (deployed is not None): DCNL DCSP  DCSP params['Deployed'] = str(deployed).lower() DCNL DCSP return self._make_request(action='DescribeAvailabilityOptions', verb='POST', path='/', params=params)
def describe_domains(self, domain_names=None): DCNL DCSP params = {} DCNL DCSP if (domain_names is not None): DCNL DCSP  DCSP self.build_list_params(params, domain_names, 'DomainNames.member') DCNL DCSP return self._make_request(action='DescribeDomains', verb='POST', path='/', params=params)
def describe_expressions(self, domain_name, expression_names=None, deployed=None): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if (expression_names is not None): DCNL DCSP  DCSP self.build_list_params(params, expression_names, 'ExpressionNames.member') DCNL DCSP if (deployed is not None): DCNL DCSP  DCSP params['Deployed'] = str(deployed).lower() DCNL DCSP return self._make_request(action='DescribeExpressions', verb='POST', path='/', params=params)
def describe_index_fields(self, domain_name, field_names=None, deployed=None): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if (field_names is not None): DCNL DCSP  DCSP self.build_list_params(params, field_names, 'FieldNames.member') DCNL DCSP if (deployed is not None): DCNL DCSP  DCSP params['Deployed'] = str(deployed).lower() DCNL DCSP return self._make_request(action='DescribeIndexFields', verb='POST', path='/', params=params)
def describe_scaling_parameters(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self._make_request(action='DescribeScalingParameters', verb='POST', path='/', params=params)
def describe_service_access_policies(self, domain_name, deployed=None): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if (deployed is not None): DCNL DCSP  DCSP params['Deployed'] = str(deployed).lower() DCNL DCSP return self._make_request(action='DescribeServiceAccessPolicies', verb='POST', path='/', params=params)
def describe_suggesters(self, domain_name, suggester_names=None, deployed=None): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if (suggester_names is not None): DCNL DCSP  DCSP self.build_list_params(params, suggester_names, 'SuggesterNames.member') DCNL DCSP if (deployed is not None): DCNL DCSP  DCSP params['Deployed'] = str(deployed).lower() DCNL DCSP return self._make_request(action='DescribeSuggesters', verb='POST', path='/', params=params)
def index_documents(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self._make_request(action='IndexDocuments', verb='POST', path='/', params=params)
def list_domain_names(self): DCNL DCSP params = {} DCNL DCSP return self._make_request(action='ListDomainNames', verb='POST', path='/', params=params)
def update_availability_options(self, domain_name, multi_az): DCNL DCSP params = {'DomainName': domain_name, 'MultiAZ': multi_az} DCNL DCSP return self._make_request(action='UpdateAvailabilityOptions', verb='POST', path='/', params=params)
def update_scaling_parameters(self, domain_name, scaling_parameters): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP self.build_complex_param(params, 'ScalingParameters', scaling_parameters) DCNL DCSP return self._make_request(action='UpdateScalingParameters', verb='POST', path='/', params=params)
def update_service_access_policies(self, domain_name, access_policies): DCNL DCSP params = {'DomainName': domain_name, 'AccessPolicies': access_policies} DCNL DCSP return self._make_request(action='UpdateServiceAccessPolicies', verb='POST', path='/', params=params)
def build_complex_param(self, params, label, value): DCNL DCSP for (k, v) in value.items(): DCNL DCSP  DCSP if isinstance(v, dict): DCNL DCSP  DCSP  DCSP for (k2, v2) in v.items(): DCNL DCSP  DCSP  DCSP  DCSP self.build_complex_param(params, ((label + '.') + k), v) DCNL DCSP  DCSP elif isinstance(v, bool): DCNL DCSP  DCSP  DCSP params[('%s.%s' % (label, k))] = ((v and 'true') or 'false') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params[('%s.%s' % (label, k))] = v
def refresh(self, data=None): DCNL DCSP if (not data): DCNL DCSP  DCSP if self.refresh_fn: DCNL DCSP  DCSP  DCSP data = self.refresh_fn(self.domain.name) DCNL DCSP  DCSP  DCSP if (data and self.refresh_key): DCNL DCSP  DCSP  DCSP  DCSP for key in self.refresh_key: DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = data[key] DCNL DCSP if data: DCNL DCSP  DCSP self._update_status(data['Status']) DCNL DCSP  DCSP self._update_options(data['Options'])
def to_json(self): DCNL DCSP return json.dumps(self)
def save(self): DCNL DCSP if self.save_fn: DCNL DCSP  DCSP data = self.save_fn(self.domain.name, self.to_json()) DCNL DCSP  DCSP self.refresh(data)
def new_statement(self, arn, ip): DCNL DCSP return {'Effect': 'Allow', 'Action': '*', 'Resource': arn, 'Condition': {'IpAddress': {'aws:SourceIp': [ip]}}}
def allow_search_ip(self, ip): DCNL DCSP arn = self.domain.service_arn DCNL DCSP self._allow_ip(arn, ip)
def allow_doc_ip(self, ip): DCNL DCSP arn = self.domain.service_arn DCNL DCSP self._allow_ip(arn, ip)
def disallow_search_ip(self, ip): DCNL DCSP arn = self.domain.service_arn DCNL DCSP self._disallow_ip(arn, ip)
def disallow_doc_ip(self, ip): DCNL DCSP arn = self.domain.service_arn DCNL DCSP self._disallow_ip(arn, ip)
def add(self, _id, fields): DCNL DCSP d = {'type': 'add', 'id': _id, 'fields': fields} DCNL DCSP self.documents_batch.append(d)
def delete(self, _id): DCNL DCSP d = {'type': 'delete', 'id': _id} DCNL DCSP self.documents_batch.append(d)
def get_sdf(self): DCNL DCSP return (self._sdf if self._sdf else json.dumps(self.documents_batch))
def clear_sdf(self): DCNL DCSP self._sdf = None DCNL DCSP self.documents_batch = []
def add_sdf_from_s3(self, key_obj): DCNL DCSP self._sdf = key_obj.get_contents_as_string()
def commit(self): DCNL DCSP sdf = self.get_sdf() DCNL DCSP if (': DCSP null' in sdf): DCNL DCSP  DCSP boto.log.error('null DCSP value DCSP in DCSP sdf DCSP detected. DCSP This DCSP will DCSP probably DCSP raise DCSP 500 DCSP error.') DCNL DCSP  DCSP index = sdf.index(': DCSP null') DCNL DCSP  DCSP boto.log.error(sdf[(index - 100):(index + 100)]) DCNL DCSP api_version = '2013-01-01' DCNL DCSP if (self.domain and self.domain.layer1): DCNL DCSP  DCSP api_version = self.domain.layer1.APIVersion DCNL DCSP if self.sign_request: DCNL DCSP  DCSP r = self._commit_with_auth(sdf, api_version) DCNL DCSP else: DCNL DCSP  DCSP r = self._commit_without_auth(sdf, api_version) DCNL DCSP return CommitResponse(r, self, sdf, signed_request=self.sign_request)
def _check_num_ops(self, type_, response_num): DCNL DCSP commit_num = len([d for d in self.doc_service.documents_batch if (d['type'] == type_)]) DCNL DCSP if (response_num != commit_num): DCNL DCSP  DCSP if self.signed_request: DCNL DCSP  DCSP  DCSP boto.log.debug(self.response) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP boto.log.debug(self.response.content) DCNL DCSP  DCSP exc = CommitMismatchError('Incorrect DCSP number DCSP of DCSP {0}s DCSP returned. DCSP Commit: DCSP {1} DCSP Response: DCSP {2}'.format(type_, commit_num, response_num)) DCNL DCSP  DCSP exc.errors = self.errors DCNL DCSP  DCSP raise exc
def list_domains(self, domain_names=None): DCNL DCSP domain_data = self.layer1.describe_domains(domain_names) DCNL DCSP domain_data = domain_data['DescribeDomainsResponse']['DescribeDomainsResult']['DomainStatusList'] DCNL DCSP return [Domain(self.layer1, data) for data in domain_data]
def create_domain(self, domain_name): DCNL DCSP data = self.layer1.create_domain(domain_name) DCNL DCSP return Domain(self.layer1, data['CreateDomainResponse']['CreateDomainResult']['DomainStatus'])
def lookup(self, domain_name): DCNL DCSP domains = self.list_domains(domain_names=[domain_name]) DCNL DCSP if (len(domains) > 0): DCNL DCSP  DCSP return domains[0]
def __init__(self, connection=None): DCNL DCSP dict.__init__(self) DCNL DCSP self.connection = connection DCNL DCSP self.current_name = None DCNL DCSP self.current_value = None
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', security_token=None, validate_certs=True, profile_name=None): DCNL DCSP if (not region): DCNL DCSP  DCSP region = RegionInfo(self, self.DefaultRegionName, self.DefaultRegionEndpoint) DCNL DCSP self.region = region DCNL DCSP if (self.region.name == 'eu-west-1'): DCNL DCSP  DCSP validate_certs = False DCNL DCSP super(CloudWatchConnection, self).__init__(aws_access_key_id, aws_secret_access_key, is_secure, port, proxy, proxy_port, proxy_user, proxy_pass, self.region.endpoint, debug, https_connection_factory, path, security_token, validate_certs=validate_certs, profile_name=profile_name)
def get_metric_statistics(self, period, start_time, end_time, metric_name, namespace, statistics, dimensions=None, unit=None): DCNL DCSP params = {'Period': period, 'MetricName': metric_name, 'Namespace': namespace, 'StartTime': start_time.isoformat(), 'EndTime': end_time.isoformat()} DCNL DCSP self.build_list_params(params, statistics, 'Statistics.member.%d') DCNL DCSP if dimensions: DCNL DCSP  DCSP self.build_dimension_param(dimensions, params) DCNL DCSP if unit: DCNL DCSP  DCSP params['Unit'] = unit DCNL DCSP return self.get_list('GetMetricStatistics', params, [('member', Datapoint)])
def list_metrics(self, next_token=None, dimensions=None, metric_name=None, namespace=None): DCNL DCSP params = {} DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if dimensions: DCNL DCSP  DCSP self.build_dimension_param(dimensions, params) DCNL DCSP if metric_name: DCNL DCSP  DCSP params['MetricName'] = metric_name DCNL DCSP if namespace: DCNL DCSP  DCSP params['Namespace'] = namespace DCNL DCSP return self.get_list('ListMetrics', params, [('member', Metric)])
def put_metric_data(self, namespace, name, value=None, timestamp=None, unit=None, dimensions=None, statistics=None): DCNL DCSP params = {'Namespace': namespace} DCNL DCSP self.build_put_params(params, name, value=value, timestamp=timestamp, unit=unit, dimensions=dimensions, statistics=statistics) DCNL DCSP return self.get_status('PutMetricData', params, verb='POST')
def describe_alarms(self, action_prefix=None, alarm_name_prefix=None, alarm_names=None, max_records=None, state_value=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if action_prefix: DCNL DCSP  DCSP params['ActionPrefix'] = action_prefix DCNL DCSP if alarm_name_prefix: DCNL DCSP  DCSP params['AlarmNamePrefix'] = alarm_name_prefix DCNL DCSP elif alarm_names: DCNL DCSP  DCSP self.build_list_params(params, alarm_names, 'AlarmNames.member.%s') DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if state_value: DCNL DCSP  DCSP params['StateValue'] = state_value DCNL DCSP result = self.get_list('DescribeAlarms', params, [('MetricAlarms', MetricAlarms)]) DCNL DCSP ret = result[0] DCNL DCSP ret.next_token = result.next_token DCNL DCSP return ret
def describe_alarm_history(self, alarm_name=None, start_date=None, end_date=None, max_records=None, history_item_type=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if alarm_name: DCNL DCSP  DCSP params['AlarmName'] = alarm_name DCNL DCSP if start_date: DCNL DCSP  DCSP params['StartDate'] = start_date.isoformat() DCNL DCSP if end_date: DCNL DCSP  DCSP params['EndDate'] = end_date.isoformat() DCNL DCSP if history_item_type: DCNL DCSP  DCSP params['HistoryItemType'] = history_item_type DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('DescribeAlarmHistory', params, [('member', AlarmHistoryItem)])
def describe_alarms_for_metric(self, metric_name, namespace, period=None, statistic=None, dimensions=None, unit=None): DCNL DCSP params = {'MetricName': metric_name, 'Namespace': namespace} DCNL DCSP if period: DCNL DCSP  DCSP params['Period'] = period DCNL DCSP if statistic: DCNL DCSP  DCSP params['Statistic'] = statistic DCNL DCSP if dimensions: DCNL DCSP  DCSP self.build_dimension_param(dimensions, params) DCNL DCSP if unit: DCNL DCSP  DCSP params['Unit'] = unit DCNL DCSP return self.get_list('DescribeAlarmsForMetric', params, [('member', MetricAlarm)])
def put_metric_alarm(self, alarm): DCNL DCSP params = {'AlarmName': alarm.name, 'MetricName': alarm.metric, 'Namespace': alarm.namespace, 'Statistic': alarm.statistic, 'ComparisonOperator': alarm.comparison, 'Threshold': alarm.threshold, 'EvaluationPeriods': alarm.evaluation_periods, 'Period': alarm.period} DCNL DCSP if (alarm.actions_enabled is not None): DCNL DCSP  DCSP params['ActionsEnabled'] = alarm.actions_enabled DCNL DCSP if alarm.alarm_actions: DCNL DCSP  DCSP self.build_list_params(params, alarm.alarm_actions, 'AlarmActions.member.%s') DCNL DCSP if alarm.description: DCNL DCSP  DCSP params['AlarmDescription'] = alarm.description DCNL DCSP if alarm.dimensions: DCNL DCSP  DCSP self.build_dimension_param(alarm.dimensions, params) DCNL DCSP if alarm.insufficient_data_actions: DCNL DCSP  DCSP self.build_list_params(params, alarm.insufficient_data_actions, 'InsufficientDataActions.member.%s') DCNL DCSP if alarm.ok_actions: DCNL DCSP  DCSP self.build_list_params(params, alarm.ok_actions, 'OKActions.member.%s') DCNL DCSP if alarm.unit: DCNL DCSP  DCSP params['Unit'] = alarm.unit DCNL DCSP alarm.connection = self DCNL DCSP return self.get_status('PutMetricAlarm', params)
def delete_alarms(self, alarms): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, alarms, 'AlarmNames.member.%s') DCNL DCSP return self.get_status('DeleteAlarms', params)
def set_alarm_state(self, alarm_name, state_reason, state_value, state_reason_data=None): DCNL DCSP params = {'AlarmName': alarm_name, 'StateReason': state_reason, 'StateValue': state_value} DCNL DCSP if state_reason_data: DCNL DCSP  DCSP params['StateReasonData'] = json.dumps(state_reason_data) DCNL DCSP return self.get_status('SetAlarmState', params)
def enable_alarm_actions(self, alarm_names): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, alarm_names, 'AlarmNames.member.%s') DCNL DCSP return self.get_status('EnableAlarmActions', params)
def disable_alarm_actions(self, alarm_names): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, alarm_names, 'AlarmNames.member.%s') DCNL DCSP return self.get_status('DisableAlarmActions', params)
def __init__(self, connection=None): DCNL DCSP list.__init__(self) DCNL DCSP self.connection = connection
def __init__(self, connection=None, name=None, metric=None, namespace=None, statistic=None, comparison=None, threshold=None, period=None, evaluation_periods=None, unit=None, description='', dimensions=None, alarm_actions=None, insufficient_data_actions=None, ok_actions=None): DCNL DCSP self.name = name DCNL DCSP self.connection = connection DCNL DCSP self.metric = metric DCNL DCSP self.namespace = namespace DCNL DCSP self.statistic = statistic DCNL DCSP if (threshold is not None): DCNL DCSP  DCSP self.threshold = float(threshold) DCNL DCSP else: DCNL DCSP  DCSP self.threshold = None DCNL DCSP self.comparison = self._cmp_map.get(comparison) DCNL DCSP if (period is not None): DCNL DCSP  DCSP self.period = int(period) DCNL DCSP else: DCNL DCSP  DCSP self.period = None DCNL DCSP if (evaluation_periods is not None): DCNL DCSP  DCSP self.evaluation_periods = int(evaluation_periods) DCNL DCSP else: DCNL DCSP  DCSP self.evaluation_periods = None DCNL DCSP self.actions_enabled = None DCNL DCSP self.alarm_arn = None DCNL DCSP self.last_updated = None DCNL DCSP self.description = description DCNL DCSP self.dimensions = dimensions DCNL DCSP self.state_reason = None DCNL DCSP self.state_value = None DCNL DCSP self.unit = unit DCNL DCSP self.alarm_actions = alarm_actions DCNL DCSP self.insufficient_data_actions = insufficient_data_actions DCNL DCSP self.ok_actions = ok_actions
def set_state(self, value, reason, data=None): DCNL DCSP return self.connection.set_alarm_state(self.name, reason, value, data)
def add_alarm_action(self, action_arn=None): DCNL DCSP if (not action_arn): DCNL DCSP  DCSP return DCNL DCSP self.actions_enabled = 'true' DCNL DCSP self.alarm_actions.append(action_arn)
def add_insufficient_data_action(self, action_arn=None): DCNL DCSP if (not action_arn): DCNL DCSP  DCSP return DCNL DCSP self.actions_enabled = 'true' DCNL DCSP self.insufficient_data_actions.append(action_arn)
def add_ok_action(self, action_arn=None): DCNL DCSP if (not action_arn): DCNL DCSP  DCSP return DCNL DCSP self.actions_enabled = 'true' DCNL DCSP self.ok_actions.append(action_arn)
def query(self, start_time, end_time, statistics, unit=None, period=60): DCNL DCSP if (not isinstance(statistics, list)): DCNL DCSP  DCSP statistics = [statistics] DCNL DCSP return self.connection.get_metric_statistics(period, start_time, end_time, self.name, self.namespace, statistics, self.dimensions, unit)
def create_alarm(self, name, comparison, threshold, period, evaluation_periods, statistic, enabled=True, description=None, dimensions=None, alarm_actions=None, ok_actions=None, insufficient_data_actions=None, unit=None): DCNL DCSP if (not dimensions): DCNL DCSP  DCSP dimensions = self.dimensions DCNL DCSP alarm = MetricAlarm(self.connection, name, self.name, self.namespace, statistic, comparison, threshold, period, evaluation_periods, unit, description, dimensions, alarm_actions, insufficient_data_actions, ok_actions) DCNL DCSP if self.connection.put_metric_alarm(alarm): DCNL DCSP  DCSP return alarm
def describe_alarms(self, period=None, statistic=None, dimensions=None, unit=None): DCNL DCSP return self.connection.describe_alarms_for_metric(self.name, self.namespace, period, statistic, dimensions, unit)
def delete(self, dry_run=False): DCNL DCSP return self.connection.delete_key_pair(self.name, dry_run=dry_run)
def save(self, directory_path): DCNL DCSP if self.material: DCNL DCSP  DCSP directory_path = os.path.expanduser(directory_path) DCNL DCSP  DCSP file_path = os.path.join(directory_path, ('%s.pem' % self.name)) DCNL DCSP  DCSP if os.path.exists(file_path): DCNL DCSP  DCSP  DCSP raise BotoClientError(('%s DCSP already DCSP exists, DCSP it DCSP will DCSP not DCSP be DCSP overwritten' % file_path)) DCNL DCSP  DCSP fp = open(file_path, 'wb') DCNL DCSP  DCSP fp.write(self.material) DCNL DCSP  DCSP fp.close() DCNL DCSP  DCSP os.chmod(file_path, 384) DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise BotoClientError('KeyPair DCSP contains DCSP no DCSP material')
def copy_to_region(self, region, dry_run=False): DCNL DCSP if (region.name == self.region): DCNL DCSP  DCSP raise BotoClientError('Unable DCSP to DCSP copy DCSP to DCSP the DCSP same DCSP Region') DCNL DCSP conn_params = self.connection.get_params() DCNL DCSP rconn = region.connect(**conn_params) DCNL DCSP kp = rconn.create_key_pair(self.name, dry_run=dry_run) DCNL DCSP return kp
def add_tag(self, key, value='', dry_run=False): DCNL DCSP self.add_tags({key: value}, dry_run)
def add_tags(self, tags, dry_run=False): DCNL DCSP status = self.connection.create_tags([self.id], tags, dry_run=dry_run) DCNL DCSP if (self.tags is None): DCNL DCSP  DCSP self.tags = TagSet() DCNL DCSP self.tags.update(tags)
def remove_tag(self, key, value=None, dry_run=False): DCNL DCSP self.remove_tags({key: value}, dry_run)
def remove_tags(self, tags, dry_run=False): DCNL DCSP status = self.connection.delete_tags([self.id], tags, dry_run=dry_run) DCNL DCSP for (key, value) in tags.items(): DCNL DCSP  DCSP if (key in self.tags): DCNL DCSP  DCSP  DCSP if ((value is None) or (value == self.tags[key])): DCNL DCSP  DCSP  DCSP  DCSP del self.tags[key]
def __init__(self, connection=None, name=None, launch_config=None, availability_zones=None, load_balancers=None, default_cooldown=None, health_check_type=None, health_check_period=None, placement_group=None, vpc_zone_identifier=None, desired_capacity=None, min_size=None, max_size=None, tags=None, termination_policies=None, instance_id=None, **kwargs): DCNL DCSP self.name = (name or kwargs.get('group_name')) DCNL DCSP self.connection = connection DCNL DCSP self.min_size = (int(min_size) if (min_size is not None) else None) DCNL DCSP self.max_size = (int(max_size) if (max_size is not None) else None) DCNL DCSP self.created_time = None DCNL DCSP default_cooldown = (default_cooldown or kwargs.get('cooldown')) DCNL DCSP if (default_cooldown is not None): DCNL DCSP  DCSP default_cooldown = int(default_cooldown) DCNL DCSP self.default_cooldown = default_cooldown DCNL DCSP self.launch_config_name = launch_config DCNL DCSP if (launch_config and isinstance(launch_config, LaunchConfiguration)): DCNL DCSP  DCSP self.launch_config_name = launch_config.name DCNL DCSP self.desired_capacity = desired_capacity DCNL DCSP lbs = (load_balancers or []) DCNL DCSP self.load_balancers = ListElement(lbs) DCNL DCSP zones = (availability_zones or []) DCNL DCSP self.availability_zones = ListElement(zones) DCNL DCSP self.health_check_period = health_check_period DCNL DCSP self.health_check_type = health_check_type DCNL DCSP self.placement_group = placement_group DCNL DCSP self.autoscaling_group_arn = None DCNL DCSP if (type(vpc_zone_identifier) is list): DCNL DCSP  DCSP vpc_zone_identifier = ','.join(vpc_zone_identifier) DCNL DCSP self.vpc_zone_identifier = vpc_zone_identifier DCNL DCSP self.instances = None DCNL DCSP self.tags = (tags or None) DCNL DCSP termination_policies = (termination_policies or []) DCNL DCSP self.termination_policies = ListElement(termination_policies) DCNL DCSP self.instance_id = instance_id
def set_capacity(self, capacity): DCNL DCSP params = {'AutoScalingGroupName': self.name, 'DesiredCapacity': capacity} DCNL DCSP req = self.connection.get_object('SetDesiredCapacity', params, Request) DCNL DCSP self.connection.last_request = req DCNL DCSP return req
def update(self): DCNL DCSP return self.connection._update_group('UpdateAutoScalingGroup', self)
def shutdown_instances(self): DCNL DCSP self.min_size = 0 DCNL DCSP self.max_size = 0 DCNL DCSP self.desired_capacity = 0 DCNL DCSP self.update()
def delete(self, force_delete=False): DCNL DCSP return self.connection.delete_auto_scaling_group(self.name, force_delete)
def get_activities(self, activity_ids=None, max_records=50): DCNL DCSP return self.connection.get_all_activities(self, activity_ids, max_records)
def put_notification_configuration(self, topic, notification_types): DCNL DCSP return self.connection.put_notification_configuration(self, topic, notification_types)
def delete_notification_configuration(self, topic): DCNL DCSP return self.connection.delete_notification_configuration(self, topic)
def suspend_processes(self, scaling_processes=None): DCNL DCSP return self.connection.suspend_processes(self.name, scaling_processes)
def resume_processes(self, scaling_processes=None): DCNL DCSP return self.connection.resume_processes(self.name, scaling_processes)
def build_params(self, params, i): DCNL DCSP prefix = ('Tags.member.%d.' % i) DCNL DCSP params[(prefix + 'ResourceId')] = self.resource_id DCNL DCSP params[(prefix + 'ResourceType')] = self.resource_type DCNL DCSP params[(prefix + 'Key')] = self.key DCNL DCSP params[(prefix + 'Value')] = self.value DCNL DCSP if self.propagate_at_launch: DCNL DCSP  DCSP params[(prefix + 'PropagateAtLaunch')] = 'true' DCNL DCSP else: DCNL DCSP  DCSP params[(prefix + 'PropagateAtLaunch')] = 'false'
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', security_token=None, validate_certs=True, profile_name=None, use_block_device_types=False): DCNL DCSP if (not region): DCNL DCSP  DCSP region = RegionInfo(self, self.DefaultRegionName, self.DefaultRegionEndpoint, AutoScaleConnection) DCNL DCSP self.region = region DCNL DCSP self.use_block_device_types = use_block_device_types DCNL DCSP super(AutoScaleConnection, self).__init__(aws_access_key_id, aws_secret_access_key, is_secure, port, proxy, proxy_port, proxy_user, proxy_pass, self.region.endpoint, debug, https_connection_factory, path=path, security_token=security_token, validate_certs=validate_certs, profile_name=profile_name)
def build_list_params(self, params, items, label): DCNL DCSP for i in range(1, (len(items) + 1)): DCNL DCSP  DCSP if isinstance(items[(i - 1)], dict): DCNL DCSP  DCSP  DCSP for (k, v) in six.iteritems(items[(i - 1)]): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(v, dict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (kk, vv) in six.iteritems(v): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP params[('%s.member.%d.%s.%s' % (label, i, k, kk))] = vv DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[('%s.member.%d.%s' % (label, i, k))] = v DCNL DCSP  DCSP elif isinstance(items[(i - 1)], six.string_types): DCNL DCSP  DCSP  DCSP params[('%s.member.%d' % (label, i))] = items[(i - 1)]
def attach_instances(self, name, instance_ids): DCNL DCSP params = {'AutoScalingGroupName': name} DCNL DCSP self.build_list_params(params, instance_ids, 'InstanceIds') DCNL DCSP return self.get_status('AttachInstances', params)
def detach_instances(self, name, instance_ids, decrement_capacity=True): DCNL DCSP params = {'AutoScalingGroupName': name} DCNL DCSP params['ShouldDecrementDesiredCapacity'] = ('true' if decrement_capacity else 'false') DCNL DCSP self.build_list_params(params, instance_ids, 'InstanceIds') DCNL DCSP return self.get_status('DetachInstances', params)
def create_auto_scaling_group(self, as_group): DCNL DCSP return self._update_group('CreateAutoScalingGroup', as_group)
def delete_auto_scaling_group(self, name, force_delete=False): DCNL DCSP if force_delete: DCNL DCSP  DCSP params = {'AutoScalingGroupName': name, 'ForceDelete': 'true'} DCNL DCSP else: DCNL DCSP  DCSP params = {'AutoScalingGroupName': name} DCNL DCSP return self.get_object('DeleteAutoScalingGroup', params, Request)
def create_launch_configuration(self, launch_config): DCNL DCSP params = {'ImageId': launch_config.image_id, 'LaunchConfigurationName': launch_config.name, 'InstanceType': launch_config.instance_type} DCNL DCSP if launch_config.key_name: DCNL DCSP  DCSP params['KeyName'] = launch_config.key_name DCNL DCSP if launch_config.user_data: DCNL DCSP  DCSP user_data = launch_config.user_data DCNL DCSP  DCSP if isinstance(user_data, six.text_type): DCNL DCSP  DCSP  DCSP user_data = user_data.encode('utf-8') DCNL DCSP  DCSP params['UserData'] = base64.b64encode(user_data).decode('utf-8') DCNL DCSP if launch_config.kernel_id: DCNL DCSP  DCSP params['KernelId'] = launch_config.kernel_id DCNL DCSP if launch_config.ramdisk_id: DCNL DCSP  DCSP params['RamdiskId'] = launch_config.ramdisk_id DCNL DCSP if launch_config.block_device_mappings: DCNL DCSP  DCSP [x.autoscale_build_list_params(params) for x in launch_config.block_device_mappings] DCNL DCSP if launch_config.security_groups: DCNL DCSP  DCSP self.build_list_params(params, launch_config.security_groups, 'SecurityGroups') DCNL DCSP if launch_config.instance_monitoring: DCNL DCSP  DCSP params['InstanceMonitoring.Enabled'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP params['InstanceMonitoring.Enabled'] = 'false' DCNL DCSP if (launch_config.spot_price is not None): DCNL DCSP  DCSP params['SpotPrice'] = str(launch_config.spot_price) DCNL DCSP if (launch_config.instance_profile_name is not None): DCNL DCSP  DCSP params['IamInstanceProfile'] = launch_config.instance_profile_name DCNL DCSP if launch_config.ebs_optimized: DCNL DCSP  DCSP params['EbsOptimized'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP params['EbsOptimized'] = 'false' DCNL DCSP if (launch_config.associate_public_ip_address is True): DCNL DCSP  DCSP params['AssociatePublicIpAddress'] = 'true' DCNL DCSP elif (launch_config.associate_public_ip_address is False): DCNL DCSP  DCSP params['AssociatePublicIpAddress'] = 'false' DCNL DCSP if launch_config.volume_type: DCNL DCSP  DCSP params['VolumeType'] = launch_config.volume_type DCNL DCSP if launch_config.delete_on_termination: DCNL DCSP  DCSP params['DeleteOnTermination'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP params['DeleteOnTermination'] = 'false' DCNL DCSP if launch_config.iops: DCNL DCSP  DCSP params['Iops'] = launch_config.iops DCNL DCSP if launch_config.classic_link_vpc_id: DCNL DCSP  DCSP params['ClassicLinkVPCId'] = launch_config.classic_link_vpc_id DCNL DCSP if launch_config.classic_link_vpc_security_groups: DCNL DCSP  DCSP self.build_list_params(params, launch_config.classic_link_vpc_security_groups, 'ClassicLinkVPCSecurityGroups') DCNL DCSP return self.get_object('CreateLaunchConfiguration', params, Request, verb='POST')
def get_account_limits(self): DCNL DCSP params = {} DCNL DCSP return self.get_object('DescribeAccountLimits', params, AccountLimits)
def create_scaling_policy(self, scaling_policy): DCNL DCSP params = {'AdjustmentType': scaling_policy.adjustment_type, 'AutoScalingGroupName': scaling_policy.as_name, 'PolicyName': scaling_policy.name, 'ScalingAdjustment': scaling_policy.scaling_adjustment} DCNL DCSP if ((scaling_policy.adjustment_type == 'PercentChangeInCapacity') and (scaling_policy.min_adjustment_step is not None)): DCNL DCSP  DCSP params['MinAdjustmentStep'] = scaling_policy.min_adjustment_step DCNL DCSP if (scaling_policy.cooldown is not None): DCNL DCSP  DCSP params['Cooldown'] = scaling_policy.cooldown DCNL DCSP return self.get_object('PutScalingPolicy', params, Request)
def delete_launch_configuration(self, launch_config_name): DCNL DCSP params = {'LaunchConfigurationName': launch_config_name} DCNL DCSP return self.get_object('DeleteLaunchConfiguration', params, Request)
def get_all_groups(self, names=None, max_records=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if names: DCNL DCSP  DCSP self.build_list_params(params, names, 'AutoScalingGroupNames') DCNL DCSP return self.get_list('DescribeAutoScalingGroups', params, [('member', AutoScalingGroup)])
def get_all_launch_configurations(self, **kwargs): DCNL DCSP params = {} DCNL DCSP max_records = kwargs.get('max_records', None) DCNL DCSP names = kwargs.get('names', None) DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if names: DCNL DCSP  DCSP self.build_list_params(params, names, 'LaunchConfigurationNames') DCNL DCSP next_token = kwargs.get('next_token') DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('DescribeLaunchConfigurations', params, [('member', LaunchConfiguration)])
def get_all_activities(self, autoscale_group, activity_ids=None, max_records=None, next_token=None): DCNL DCSP name = autoscale_group DCNL DCSP if isinstance(autoscale_group, AutoScalingGroup): DCNL DCSP  DCSP name = autoscale_group.name DCNL DCSP params = {'AutoScalingGroupName': name} DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if activity_ids: DCNL DCSP  DCSP self.build_list_params(params, activity_ids, 'ActivityIds') DCNL DCSP return self.get_list('DescribeScalingActivities', params, [('member', Activity)])
def get_termination_policies(self): DCNL DCSP return self.get_object('DescribeTerminationPolicyTypes', {}, TerminationPolicies)
def delete_scheduled_action(self, scheduled_action_name, autoscale_group=None): DCNL DCSP params = {'ScheduledActionName': scheduled_action_name} DCNL DCSP if autoscale_group: DCNL DCSP  DCSP params['AutoScalingGroupName'] = autoscale_group DCNL DCSP return self.get_status('DeleteScheduledAction', params)
def terminate_instance(self, instance_id, decrement_capacity=True): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP if decrement_capacity: DCNL DCSP  DCSP params['ShouldDecrementDesiredCapacity'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP params['ShouldDecrementDesiredCapacity'] = 'false' DCNL DCSP return self.get_object('TerminateInstanceInAutoScalingGroup', params, Activity)
def delete_policy(self, policy_name, autoscale_group=None): DCNL DCSP params = {'PolicyName': policy_name} DCNL DCSP if autoscale_group: DCNL DCSP  DCSP params['AutoScalingGroupName'] = autoscale_group DCNL DCSP return self.get_status('DeletePolicy', params)
def get_all_autoscaling_instances(self, instance_ids=None, max_records=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if instance_ids: DCNL DCSP  DCSP self.build_list_params(params, instance_ids, 'InstanceIds') DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('DescribeAutoScalingInstances', params, [('member', Instance)])
def get_all_metric_collection_types(self): DCNL DCSP return self.get_object('DescribeMetricCollectionTypes', {}, MetricCollectionTypes)
def get_all_policies(self, as_group=None, policy_names=None, max_records=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if as_group: DCNL DCSP  DCSP params['AutoScalingGroupName'] = as_group DCNL DCSP if policy_names: DCNL DCSP  DCSP self.build_list_params(params, policy_names, 'PolicyNames') DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('DescribePolicies', params, [('member', ScalingPolicy)])
def get_all_scaling_process_types(self): DCNL DCSP return self.get_list('DescribeScalingProcessTypes', {}, [('member', ProcessType)])
def suspend_processes(self, as_group, scaling_processes=None): DCNL DCSP params = {'AutoScalingGroupName': as_group} DCNL DCSP if scaling_processes: DCNL DCSP  DCSP self.build_list_params(params, scaling_processes, 'ScalingProcesses') DCNL DCSP return self.get_status('SuspendProcesses', params)
def resume_processes(self, as_group, scaling_processes=None): DCNL DCSP params = {'AutoScalingGroupName': as_group} DCNL DCSP if scaling_processes: DCNL DCSP  DCSP self.build_list_params(params, scaling_processes, 'ScalingProcesses') DCNL DCSP return self.get_status('ResumeProcesses', params)
def create_scheduled_group_action(self, as_group, name, time=None, desired_capacity=None, min_size=None, max_size=None, start_time=None, end_time=None, recurrence=None): DCNL DCSP params = {'AutoScalingGroupName': as_group, 'ScheduledActionName': name} DCNL DCSP if (start_time is not None): DCNL DCSP  DCSP params['StartTime'] = start_time.isoformat() DCNL DCSP if (end_time is not None): DCNL DCSP  DCSP params['EndTime'] = end_time.isoformat() DCNL DCSP if (recurrence is not None): DCNL DCSP  DCSP params['Recurrence'] = recurrence DCNL DCSP if time: DCNL DCSP  DCSP params['Time'] = time.isoformat() DCNL DCSP if (desired_capacity is not None): DCNL DCSP  DCSP params['DesiredCapacity'] = desired_capacity DCNL DCSP if (min_size is not None): DCNL DCSP  DCSP params['MinSize'] = min_size DCNL DCSP if (max_size is not None): DCNL DCSP  DCSP params['MaxSize'] = max_size DCNL DCSP return self.get_status('PutScheduledUpdateGroupAction', params)
def disable_metrics_collection(self, as_group, metrics=None): DCNL DCSP params = {'AutoScalingGroupName': as_group} DCNL DCSP if metrics: DCNL DCSP  DCSP self.build_list_params(params, metrics, 'Metrics') DCNL DCSP return self.get_status('DisableMetricsCollection', params)
def enable_metrics_collection(self, as_group, granularity, metrics=None): DCNL DCSP params = {'AutoScalingGroupName': as_group, 'Granularity': granularity} DCNL DCSP if metrics: DCNL DCSP  DCSP self.build_list_params(params, metrics, 'Metrics') DCNL DCSP return self.get_status('EnableMetricsCollection', params)
def put_notification_configuration(self, autoscale_group, topic, notification_types): DCNL DCSP name = autoscale_group DCNL DCSP if isinstance(autoscale_group, AutoScalingGroup): DCNL DCSP  DCSP name = autoscale_group.name DCNL DCSP params = {'AutoScalingGroupName': name, 'TopicARN': topic} DCNL DCSP self.build_list_params(params, notification_types, 'NotificationTypes') DCNL DCSP return self.get_status('PutNotificationConfiguration', params)
def delete_notification_configuration(self, autoscale_group, topic): DCNL DCSP name = autoscale_group DCNL DCSP if isinstance(autoscale_group, AutoScalingGroup): DCNL DCSP  DCSP name = autoscale_group.name DCNL DCSP params = {'AutoScalingGroupName': name, 'TopicARN': topic} DCNL DCSP return self.get_status('DeleteNotificationConfiguration', params)
def set_instance_health(self, instance_id, health_status, should_respect_grace_period=True): DCNL DCSP params = {'InstanceId': instance_id, 'HealthStatus': health_status} DCNL DCSP if should_respect_grace_period: DCNL DCSP  DCSP params['ShouldRespectGracePeriod'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP params['ShouldRespectGracePeriod'] = 'false' DCNL DCSP return self.get_status('SetInstanceHealth', params)
def set_desired_capacity(self, group_name, desired_capacity, honor_cooldown=False): DCNL DCSP params = {'AutoScalingGroupName': group_name, 'DesiredCapacity': desired_capacity} DCNL DCSP if honor_cooldown: DCNL DCSP  DCSP params['HonorCooldown'] = 'true' DCNL DCSP return self.get_status('SetDesiredCapacity', params)
def get_all_tags(self, filters=None, max_records=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('DescribeTags', params, [('member', Tag)])
def create_or_update_tags(self, tags): DCNL DCSP params = {} DCNL DCSP for (i, tag) in enumerate(tags): DCNL DCSP  DCSP tag.build_params(params, (i + 1)) DCNL DCSP return self.get_status('CreateOrUpdateTags', params, verb='POST')
def delete_tags(self, tags): DCNL DCSP params = {} DCNL DCSP for (i, tag) in enumerate(tags): DCNL DCSP  DCSP tag.build_params(params, (i + 1)) DCNL DCSP return self.get_status('DeleteTags', params, verb='POST')
def __init__(self, connection=None, **kwargs): DCNL DCSP self.name = kwargs.get('name', None) DCNL DCSP self.adjustment_type = kwargs.get('adjustment_type', None) DCNL DCSP self.as_name = kwargs.get('as_name', None) DCNL DCSP self.scaling_adjustment = kwargs.get('scaling_adjustment', None) DCNL DCSP self.cooldown = kwargs.get('cooldown', None) DCNL DCSP self.connection = connection DCNL DCSP self.min_adjustment_step = kwargs.get('min_adjustment_step', None)
def __init__(self, connection=None, name=None, image_id=None, key_name=None, security_groups=None, user_data=None, instance_type='m1.small', kernel_id=None, ramdisk_id=None, block_device_mappings=None, instance_monitoring=False, spot_price=None, instance_profile_name=None, ebs_optimized=False, associate_public_ip_address=None, volume_type=None, delete_on_termination=True, iops=None, use_block_device_types=False, classic_link_vpc_id=None, classic_link_vpc_security_groups=None): DCNL DCSP self.connection = connection DCNL DCSP self.name = name DCNL DCSP self.instance_type = instance_type DCNL DCSP self.block_device_mappings = block_device_mappings DCNL DCSP self.key_name = key_name DCNL DCSP sec_groups = (security_groups or []) DCNL DCSP self.security_groups = ListElement(sec_groups) DCNL DCSP self.image_id = image_id DCNL DCSP self.ramdisk_id = ramdisk_id DCNL DCSP self.created_time = None DCNL DCSP self.kernel_id = kernel_id DCNL DCSP self.user_data = user_data DCNL DCSP self.created_time = None DCNL DCSP self.instance_monitoring = instance_monitoring DCNL DCSP self.spot_price = spot_price DCNL DCSP self.instance_profile_name = instance_profile_name DCNL DCSP self.launch_configuration_arn = None DCNL DCSP self.ebs_optimized = ebs_optimized DCNL DCSP self.associate_public_ip_address = associate_public_ip_address DCNL DCSP self.volume_type = volume_type DCNL DCSP self.delete_on_termination = delete_on_termination DCNL DCSP self.iops = iops DCNL DCSP self.use_block_device_types = use_block_device_types DCNL DCSP self.classic_link_vpc_id = classic_link_vpc_id DCNL DCSP classic_link_vpc_sec_groups = (classic_link_vpc_security_groups or []) DCNL DCSP self.classic_link_vpc_security_groups = ListElement(classic_link_vpc_sec_groups) DCNL DCSP if (connection is not None): DCNL DCSP  DCSP self.use_block_device_types = connection.use_block_device_types
def delete(self): DCNL DCSP return self.connection.delete_launch_configuration(self.name)
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, host=None, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', api_version=None, security_token=None, validate_certs=True, profile_name=None): DCNL DCSP if (not region): DCNL DCSP  DCSP region = RegionInfo(self, self.DefaultRegionName, self.DefaultRegionEndpoint) DCNL DCSP self.region = region DCNL DCSP super(EC2Connection, self).__init__(aws_access_key_id, aws_secret_access_key, is_secure, port, proxy, proxy_port, proxy_user, proxy_pass, self.region.endpoint, debug, https_connection_factory, path, security_token, validate_certs=validate_certs, profile_name=profile_name) DCNL DCSP if api_version: DCNL DCSP  DCSP self.APIVersion = api_version
def get_params(self): DCNL DCSP param_names = ['aws_access_key_id', 'aws_secret_access_key', 'is_secure', 'port', 'proxy', 'proxy_port', 'proxy_user', 'proxy_pass', 'debug', 'https_connection_factory'] DCNL DCSP params = {} DCNL DCSP for name in param_names: DCNL DCSP  DCSP params[name] = getattr(self, name) DCNL DCSP return params
def get_all_images(self, image_ids=None, owners=None, executable_by=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if image_ids: DCNL DCSP  DCSP self.build_list_params(params, image_ids, 'ImageId') DCNL DCSP if owners: DCNL DCSP  DCSP self.build_list_params(params, owners, 'Owner') DCNL DCSP if executable_by: DCNL DCSP  DCSP self.build_list_params(params, executable_by, 'ExecutableBy') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeImages', params, [('item', Image)], verb='POST')
def get_all_kernels(self, kernel_ids=None, owners=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if kernel_ids: DCNL DCSP  DCSP self.build_list_params(params, kernel_ids, 'ImageId') DCNL DCSP if owners: DCNL DCSP  DCSP self.build_list_params(params, owners, 'Owner') DCNL DCSP filter = {'image-type': 'kernel'} DCNL DCSP self.build_filter_params(params, filter) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeImages', params, [('item', Image)], verb='POST')
def get_all_ramdisks(self, ramdisk_ids=None, owners=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if ramdisk_ids: DCNL DCSP  DCSP self.build_list_params(params, ramdisk_ids, 'ImageId') DCNL DCSP if owners: DCNL DCSP  DCSP self.build_list_params(params, owners, 'Owner') DCNL DCSP filter = {'image-type': 'ramdisk'} DCNL DCSP self.build_filter_params(params, filter) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeImages', params, [('item', Image)], verb='POST')
def get_image(self, image_id, dry_run=False): DCNL DCSP try: DCNL DCSP  DCSP return self.get_all_images(image_ids=[image_id], dry_run=dry_run)[0] DCNL DCSP except IndexError: DCNL DCSP  DCSP return None
def register_image(self, name=None, description=None, image_location=None, architecture=None, kernel_id=None, ramdisk_id=None, root_device_name=None, block_device_map=None, dry_run=False, virtualization_type=None, sriov_net_support=None, snapshot_id=None, delete_root_volume_on_termination=False): DCNL DCSP params = {} DCNL DCSP if name: DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if architecture: DCNL DCSP  DCSP params['Architecture'] = architecture DCNL DCSP if kernel_id: DCNL DCSP  DCSP params['KernelId'] = kernel_id DCNL DCSP if ramdisk_id: DCNL DCSP  DCSP params['RamdiskId'] = ramdisk_id DCNL DCSP if image_location: DCNL DCSP  DCSP params['ImageLocation'] = image_location DCNL DCSP if root_device_name: DCNL DCSP  DCSP params['RootDeviceName'] = root_device_name DCNL DCSP if snapshot_id: DCNL DCSP  DCSP root_vol = BlockDeviceType(snapshot_id=snapshot_id, delete_on_termination=delete_root_volume_on_termination) DCNL DCSP  DCSP block_device_map = BlockDeviceMapping() DCNL DCSP  DCSP block_device_map[root_device_name] = root_vol DCNL DCSP if block_device_map: DCNL DCSP  DCSP block_device_map.ec2_build_list_params(params) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP if virtualization_type: DCNL DCSP  DCSP params['VirtualizationType'] = virtualization_type DCNL DCSP if sriov_net_support: DCNL DCSP  DCSP params['SriovNetSupport'] = sriov_net_support DCNL DCSP rs = self.get_object('RegisterImage', params, ResultSet, verb='POST') DCNL DCSP image_id = getattr(rs, 'imageId', None) DCNL DCSP return image_id
def deregister_image(self, image_id, delete_snapshot=False, dry_run=False): DCNL DCSP snapshot_id = None DCNL DCSP if delete_snapshot: DCNL DCSP  DCSP image = self.get_image(image_id) DCNL DCSP  DCSP for key in image.block_device_mapping: DCNL DCSP  DCSP  DCSP if (key == '/dev/sda1'): DCNL DCSP  DCSP  DCSP  DCSP snapshot_id = image.block_device_mapping[key].snapshot_id DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP params = {'ImageId': image_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP result = self.get_status('DeregisterImage', params, verb='POST') DCNL DCSP if (result and snapshot_id): DCNL DCSP  DCSP return (result and self.delete_snapshot(snapshot_id)) DCNL DCSP return result
def create_image(self, instance_id, name, description=None, no_reboot=False, block_device_mapping=None, dry_run=False): DCNL DCSP params = {'InstanceId': instance_id, 'Name': name} DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if no_reboot: DCNL DCSP  DCSP params['NoReboot'] = 'true' DCNL DCSP if block_device_mapping: DCNL DCSP  DCSP block_device_mapping.ec2_build_list_params(params) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP img = self.get_object('CreateImage', params, Image, verb='POST') DCNL DCSP return img.id
def get_image_attribute(self, image_id, attribute='launchPermission', dry_run=False): DCNL DCSP params = {'ImageId': image_id, 'Attribute': attribute} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('DescribeImageAttribute', params, ImageAttribute, verb='POST')
def modify_image_attribute(self, image_id, attribute='launchPermission', operation='add', user_ids=None, groups=None, product_codes=None, dry_run=False): DCNL DCSP params = {'ImageId': image_id, 'Attribute': attribute, 'OperationType': operation} DCNL DCSP if user_ids: DCNL DCSP  DCSP self.build_list_params(params, user_ids, 'UserId') DCNL DCSP if groups: DCNL DCSP  DCSP self.build_list_params(params, groups, 'UserGroup') DCNL DCSP if product_codes: DCNL DCSP  DCSP self.build_list_params(params, product_codes, 'ProductCode') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ModifyImageAttribute', params, verb='POST')
def reset_image_attribute(self, image_id, attribute='launchPermission', dry_run=False): DCNL DCSP params = {'ImageId': image_id, 'Attribute': attribute} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ResetImageAttribute', params, verb='POST')
def get_all_instances(self, instance_ids=None, filters=None, dry_run=False, max_results=None): DCNL DCSP warnings.warn('The DCSP current DCSP get_all_instances DCSP implementation DCSP will DCSP be DCSP replaced DCSP with DCSP get_all_reservations.', PendingDeprecationWarning) DCNL DCSP return self.get_all_reservations(instance_ids=instance_ids, filters=filters, dry_run=dry_run, max_results=max_results)
def get_only_instances(self, instance_ids=None, filters=None, dry_run=False, max_results=None): DCNL DCSP next_token = None DCNL DCSP retval = [] DCNL DCSP while True: DCNL DCSP  DCSP reservations = self.get_all_reservations(instance_ids=instance_ids, filters=filters, dry_run=dry_run, max_results=max_results, next_token=next_token) DCNL DCSP  DCSP retval.extend([instance for reservation in reservations for instance in reservation.instances]) DCNL DCSP  DCSP next_token = reservations.next_token DCNL DCSP  DCSP if (not next_token): DCNL DCSP  DCSP  DCSP break DCNL DCSP return retval
def get_all_reservations(self, instance_ids=None, filters=None, dry_run=False, max_results=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if instance_ids: DCNL DCSP  DCSP self.build_list_params(params, instance_ids, 'InstanceId') DCNL DCSP if filters: DCNL DCSP  DCSP if ('group-id' in filters): DCNL DCSP  DCSP  DCSP gid = filters.get('group-id') DCNL DCSP  DCSP  DCSP if ((not gid.startswith('sg-')) or (len(gid) != 11)): DCNL DCSP  DCSP  DCSP  DCSP warnings.warn("The DCSP group-id DCSP filter DCSP now DCSP requires DCSP a DCSP security DCSP group DCSP identifier DCSP (sg-*) DCSP instead DCSP of DCSP a DCSP group DCSP name. DCSP To DCSP filter DCSP by DCSP group DCSP name DCSP use DCSP the DCSP 'group-name' DCSP filter DCSP instead.", UserWarning) DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['MaxResults'] = max_results DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('DescribeInstances', params, [('item', Reservation)], verb='POST')
def get_all_instance_status(self, instance_ids=None, max_results=None, next_token=None, filters=None, dry_run=False, include_all_instances=False): DCNL DCSP params = {} DCNL DCSP if instance_ids: DCNL DCSP  DCSP self.build_list_params(params, instance_ids, 'InstanceId') DCNL DCSP if max_results: DCNL DCSP  DCSP params['MaxResults'] = max_results DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP if include_all_instances: DCNL DCSP  DCSP params['IncludeAllInstances'] = 'true' DCNL DCSP return self.get_object('DescribeInstanceStatus', params, InstanceStatusSet, verb='POST')
def run_instances(self, image_id, min_count=1, max_count=1, key_name=None, security_groups=None, user_data=None, addressing_type=None, instance_type='m1.small', placement=None, kernel_id=None, ramdisk_id=None, monitoring_enabled=False, subnet_id=None, block_device_map=None, disable_api_termination=False, instance_initiated_shutdown_behavior=None, private_ip_address=None, placement_group=None, client_token=None, security_group_ids=None, additional_info=None, instance_profile_name=None, instance_profile_arn=None, tenancy=None, ebs_optimized=False, network_interfaces=None, dry_run=False): DCNL DCSP params = {'ImageId': image_id, 'MinCount': min_count, 'MaxCount': max_count} DCNL DCSP if key_name: DCNL DCSP  DCSP params['KeyName'] = key_name DCNL DCSP if security_group_ids: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for group in security_group_ids: DCNL DCSP  DCSP  DCSP if isinstance(group, SecurityGroup): DCNL DCSP  DCSP  DCSP  DCSP l.append(group.id) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP l.append(group) DCNL DCSP  DCSP self.build_list_params(params, l, 'SecurityGroupId') DCNL DCSP if security_groups: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for group in security_groups: DCNL DCSP  DCSP  DCSP if isinstance(group, SecurityGroup): DCNL DCSP  DCSP  DCSP  DCSP l.append(group.name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP l.append(group) DCNL DCSP  DCSP self.build_list_params(params, l, 'SecurityGroup') DCNL DCSP if user_data: DCNL DCSP  DCSP if isinstance(user_data, six.text_type): DCNL DCSP  DCSP  DCSP user_data = user_data.encode('utf-8') DCNL DCSP  DCSP params['UserData'] = base64.b64encode(user_data).decode('utf-8') DCNL DCSP if addressing_type: DCNL DCSP  DCSP params['AddressingType'] = addressing_type DCNL DCSP if instance_type: DCNL DCSP  DCSP params['InstanceType'] = instance_type DCNL DCSP if placement: DCNL DCSP  DCSP params['Placement.AvailabilityZone'] = placement DCNL DCSP if placement_group: DCNL DCSP  DCSP params['Placement.GroupName'] = placement_group DCNL DCSP if tenancy: DCNL DCSP  DCSP params['Placement.Tenancy'] = tenancy DCNL DCSP if kernel_id: DCNL DCSP  DCSP params['KernelId'] = kernel_id DCNL DCSP if ramdisk_id: DCNL DCSP  DCSP params['RamdiskId'] = ramdisk_id DCNL DCSP if monitoring_enabled: DCNL DCSP  DCSP params['Monitoring.Enabled'] = 'true' DCNL DCSP if subnet_id: DCNL DCSP  DCSP params['SubnetId'] = subnet_id DCNL DCSP if private_ip_address: DCNL DCSP  DCSP params['PrivateIpAddress'] = private_ip_address DCNL DCSP if block_device_map: DCNL DCSP  DCSP block_device_map.ec2_build_list_params(params) DCNL DCSP if disable_api_termination: DCNL DCSP  DCSP params['DisableApiTermination'] = 'true' DCNL DCSP if instance_initiated_shutdown_behavior: DCNL DCSP  DCSP val = instance_initiated_shutdown_behavior DCNL DCSP  DCSP params['InstanceInitiatedShutdownBehavior'] = val DCNL DCSP if client_token: DCNL DCSP  DCSP params['ClientToken'] = client_token DCNL DCSP if additional_info: DCNL DCSP  DCSP params['AdditionalInfo'] = additional_info DCNL DCSP if instance_profile_name: DCNL DCSP  DCSP params['IamInstanceProfile.Name'] = instance_profile_name DCNL DCSP if instance_profile_arn: DCNL DCSP  DCSP params['IamInstanceProfile.Arn'] = instance_profile_arn DCNL DCSP if ebs_optimized: DCNL DCSP  DCSP params['EbsOptimized'] = 'true' DCNL DCSP if network_interfaces: DCNL DCSP  DCSP network_interfaces.build_list_params(params) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('RunInstances', params, Reservation, verb='POST')
def terminate_instances(self, instance_ids=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if instance_ids: DCNL DCSP  DCSP self.build_list_params(params, instance_ids, 'InstanceId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('TerminateInstances', params, [('item', Instance)], verb='POST')
def stop_instances(self, instance_ids=None, force=False, dry_run=False): DCNL DCSP params = {} DCNL DCSP if force: DCNL DCSP  DCSP params['Force'] = 'true' DCNL DCSP if instance_ids: DCNL DCSP  DCSP self.build_list_params(params, instance_ids, 'InstanceId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('StopInstances', params, [('item', Instance)], verb='POST')
def start_instances(self, instance_ids=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if instance_ids: DCNL DCSP  DCSP self.build_list_params(params, instance_ids, 'InstanceId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('StartInstances', params, [('item', Instance)], verb='POST')
def get_console_output(self, instance_id, dry_run=False): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, [instance_id], 'InstanceId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('GetConsoleOutput', params, ConsoleOutput, verb='POST')
def reboot_instances(self, instance_ids=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if instance_ids: DCNL DCSP  DCSP self.build_list_params(params, instance_ids, 'InstanceId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('RebootInstances', params)
def confirm_product_instance(self, product_code, instance_id, dry_run=False): DCNL DCSP params = {'ProductCode': product_code, 'InstanceId': instance_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP rs = self.get_object('ConfirmProductInstance', params, ResultSet, verb='POST') DCNL DCSP return (rs.status, rs.ownerId)
def get_instance_attribute(self, instance_id, attribute, dry_run=False): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP if attribute: DCNL DCSP  DCSP params['Attribute'] = attribute DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('DescribeInstanceAttribute', params, InstanceAttribute, verb='POST')
def modify_network_interface_attribute(self, interface_id, attr, value, attachment_id=None, dry_run=False): DCNL DCSP bool_reqs = ('deleteontermination', 'sourcedestcheck') DCNL DCSP if (attr.lower() in bool_reqs): DCNL DCSP  DCSP if isinstance(value, bool): DCNL DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP value = 'true' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = 'false' DCNL DCSP  DCSP elif (value not in ['true', 'false']): DCNL DCSP  DCSP  DCSP raise ValueError(('%s DCSP must DCSP be DCSP a DCSP boolean, DCSP "true", DCSP or DCSP "false"!' % attr)) DCNL DCSP params = {'NetworkInterfaceId': interface_id} DCNL DCSP if (attr.lower() == 'groupset'): DCNL DCSP  DCSP for (idx, sg) in enumerate(value): DCNL DCSP  DCSP  DCSP if isinstance(sg, SecurityGroup): DCNL DCSP  DCSP  DCSP  DCSP sg = sg.id DCNL DCSP  DCSP  DCSP params[('SecurityGroupId.%s' % (idx + 1))] = sg DCNL DCSP elif (attr.lower() == 'description'): DCNL DCSP  DCSP params['Description.Value'] = value DCNL DCSP elif (attr.lower() == 'sourcedestcheck'): DCNL DCSP  DCSP params['SourceDestCheck.Value'] = value DCNL DCSP elif (attr.lower() == 'deleteontermination'): DCNL DCSP  DCSP params['Attachment.DeleteOnTermination'] = value DCNL DCSP  DCSP if (not attachment_id): DCNL DCSP  DCSP  DCSP raise ValueError('You DCSP must DCSP also DCSP specify DCSP an DCSP attachment_id') DCNL DCSP  DCSP params['Attachment.AttachmentId'] = attachment_id DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP attribute DCSP "%s"' % (attr,))) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ModifyNetworkInterfaceAttribute', params, verb='POST')
def modify_instance_attribute(self, instance_id, attribute, value, dry_run=False): DCNL DCSP bool_reqs = ('disableapitermination', 'sourcedestcheck', 'ebsoptimized') DCNL DCSP if (attribute.lower() in bool_reqs): DCNL DCSP  DCSP if isinstance(value, bool): DCNL DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP value = 'true' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = 'false' DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP if (attribute.lower() == 'groupset'): DCNL DCSP  DCSP for (idx, sg) in enumerate(value): DCNL DCSP  DCSP  DCSP if isinstance(sg, SecurityGroup): DCNL DCSP  DCSP  DCSP  DCSP sg = sg.id DCNL DCSP  DCSP  DCSP params[('GroupId.%s' % (idx + 1))] = sg DCNL DCSP elif (attribute.lower() == 'blockdevicemapping'): DCNL DCSP  DCSP for (idx, kv) in enumerate(value): DCNL DCSP  DCSP  DCSP (dev_name, _, flag) = kv.partition('=') DCNL DCSP  DCSP  DCSP pre = ('BlockDeviceMapping.%d' % (idx + 1)) DCNL DCSP  DCSP  DCSP params[('%s.DeviceName' % pre)] = dev_name DCNL DCSP  DCSP  DCSP params[('%s.Ebs.DeleteOnTermination' % pre)] = (flag or 'true') DCNL DCSP else: DCNL DCSP  DCSP attribute = (attribute[0].upper() + attribute[1:]) DCNL DCSP  DCSP params[('%s.Value' % attribute)] = value DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ModifyInstanceAttribute', params, verb='POST')
def reset_instance_attribute(self, instance_id, attribute, dry_run=False): DCNL DCSP params = {'InstanceId': instance_id, 'Attribute': attribute} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ResetInstanceAttribute', params, verb='POST')
def get_all_spot_instance_requests(self, request_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if request_ids: DCNL DCSP  DCSP self.build_list_params(params, request_ids, 'SpotInstanceRequestId') DCNL DCSP if filters: DCNL DCSP  DCSP if ('launch.group-id' in filters): DCNL DCSP  DCSP  DCSP lgid = filters.get('launch.group-id') DCNL DCSP  DCSP  DCSP if ((not lgid.startswith('sg-')) or (len(lgid) != 11)): DCNL DCSP  DCSP  DCSP  DCSP warnings.warn("The DCSP 'launch.group-id' DCSP filter DCSP now DCSP requires DCSP a DCSP security DCSP group DCSP id DCSP (sg-*) DCSP and DCSP no DCSP longer DCSP supports DCSP filtering DCSP by DCSP group DCSP name. DCSP Please DCSP update DCSP your DCSP filters DCSP accordingly.", UserWarning) DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeSpotInstanceRequests', params, [('item', SpotInstanceRequest)], verb='POST')
def get_spot_price_history(self, start_time=None, end_time=None, instance_type=None, product_description=None, availability_zone=None, dry_run=False, max_results=None, next_token=None, filters=None): DCNL DCSP params = {} DCNL DCSP if start_time: DCNL DCSP  DCSP params['StartTime'] = start_time DCNL DCSP if end_time: DCNL DCSP  DCSP params['EndTime'] = end_time DCNL DCSP if instance_type: DCNL DCSP  DCSP params['InstanceType'] = instance_type DCNL DCSP if product_description: DCNL DCSP  DCSP params['ProductDescription'] = product_description DCNL DCSP if availability_zone: DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['MaxResults'] = max_results DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP return self.get_list('DescribeSpotPriceHistory', params, [('item', SpotPriceHistory)], verb='POST')
def request_spot_instances(self, price, image_id, count=1, type='one-time', valid_from=None, valid_until=None, launch_group=None, availability_zone_group=None, key_name=None, security_groups=None, user_data=None, addressing_type=None, instance_type='m1.small', placement=None, kernel_id=None, ramdisk_id=None, monitoring_enabled=False, subnet_id=None, placement_group=None, block_device_map=None, instance_profile_arn=None, instance_profile_name=None, security_group_ids=None, ebs_optimized=False, network_interfaces=None, dry_run=False): DCNL DCSP ls = 'LaunchSpecification' DCNL DCSP params = {('%s.ImageId' % ls): image_id, 'Type': type, 'SpotPrice': price} DCNL DCSP if count: DCNL DCSP  DCSP params['InstanceCount'] = count DCNL DCSP if valid_from: DCNL DCSP  DCSP params['ValidFrom'] = valid_from DCNL DCSP if valid_until: DCNL DCSP  DCSP params['ValidUntil'] = valid_until DCNL DCSP if launch_group: DCNL DCSP  DCSP params['LaunchGroup'] = launch_group DCNL DCSP if availability_zone_group: DCNL DCSP  DCSP params['AvailabilityZoneGroup'] = availability_zone_group DCNL DCSP if key_name: DCNL DCSP  DCSP params[('%s.KeyName' % ls)] = key_name DCNL DCSP if security_group_ids: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for group in security_group_ids: DCNL DCSP  DCSP  DCSP if isinstance(group, SecurityGroup): DCNL DCSP  DCSP  DCSP  DCSP l.append(group.id) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP l.append(group) DCNL DCSP  DCSP self.build_list_params(params, l, ('%s.SecurityGroupId' % ls)) DCNL DCSP if security_groups: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for group in security_groups: DCNL DCSP  DCSP  DCSP if isinstance(group, SecurityGroup): DCNL DCSP  DCSP  DCSP  DCSP l.append(group.name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP l.append(group) DCNL DCSP  DCSP self.build_list_params(params, l, ('%s.SecurityGroup' % ls)) DCNL DCSP if user_data: DCNL DCSP  DCSP params[('%s.UserData' % ls)] = base64.b64encode(user_data) DCNL DCSP if addressing_type: DCNL DCSP  DCSP params[('%s.AddressingType' % ls)] = addressing_type DCNL DCSP if instance_type: DCNL DCSP  DCSP params[('%s.InstanceType' % ls)] = instance_type DCNL DCSP if placement: DCNL DCSP  DCSP params[('%s.Placement.AvailabilityZone' % ls)] = placement DCNL DCSP if kernel_id: DCNL DCSP  DCSP params[('%s.KernelId' % ls)] = kernel_id DCNL DCSP if ramdisk_id: DCNL DCSP  DCSP params[('%s.RamdiskId' % ls)] = ramdisk_id DCNL DCSP if monitoring_enabled: DCNL DCSP  DCSP params[('%s.Monitoring.Enabled' % ls)] = 'true' DCNL DCSP if subnet_id: DCNL DCSP  DCSP params[('%s.SubnetId' % ls)] = subnet_id DCNL DCSP if placement_group: DCNL DCSP  DCSP params[('%s.Placement.GroupName' % ls)] = placement_group DCNL DCSP if block_device_map: DCNL DCSP  DCSP block_device_map.ec2_build_list_params(params, ('%s.' % ls)) DCNL DCSP if instance_profile_name: DCNL DCSP  DCSP params[('%s.IamInstanceProfile.Name' % ls)] = instance_profile_name DCNL DCSP if instance_profile_arn: DCNL DCSP  DCSP params[('%s.IamInstanceProfile.Arn' % ls)] = instance_profile_arn DCNL DCSP if ebs_optimized: DCNL DCSP  DCSP params[('%s.EbsOptimized' % ls)] = 'true' DCNL DCSP if network_interfaces: DCNL DCSP  DCSP network_interfaces.build_list_params(params, prefix=(ls + '.')) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('RequestSpotInstances', params, [('item', SpotInstanceRequest)], verb='POST')
def cancel_spot_instance_requests(self, request_ids, dry_run=False): DCNL DCSP params = {} DCNL DCSP if request_ids: DCNL DCSP  DCSP self.build_list_params(params, request_ids, 'SpotInstanceRequestId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('CancelSpotInstanceRequests', params, [('item', SpotInstanceRequest)], verb='POST')
def get_spot_datafeed_subscription(self, dry_run=False): DCNL DCSP params = {} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('DescribeSpotDatafeedSubscription', params, SpotDatafeedSubscription, verb='POST')
def create_spot_datafeed_subscription(self, bucket, prefix, dry_run=False): DCNL DCSP params = {'Bucket': bucket} DCNL DCSP if prefix: DCNL DCSP  DCSP params['Prefix'] = prefix DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateSpotDatafeedSubscription', params, SpotDatafeedSubscription, verb='POST')
def delete_spot_datafeed_subscription(self, dry_run=False): DCNL DCSP params = {} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteSpotDatafeedSubscription', params, verb='POST')
def get_all_zones(self, zones=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if zones: DCNL DCSP  DCSP self.build_list_params(params, zones, 'ZoneName') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeAvailabilityZones', params, [('item', Zone)], verb='POST')
def get_all_addresses(self, addresses=None, filters=None, allocation_ids=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if addresses: DCNL DCSP  DCSP self.build_list_params(params, addresses, 'PublicIp') DCNL DCSP if allocation_ids: DCNL DCSP  DCSP self.build_list_params(params, allocation_ids, 'AllocationId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeAddresses', params, [('item', Address)], verb='POST')
def allocate_address(self, domain=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (domain is not None): DCNL DCSP  DCSP params['Domain'] = domain DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('AllocateAddress', params, Address, verb='POST')
def assign_private_ip_addresses(self, network_interface_id=None, private_ip_addresses=None, secondary_private_ip_address_count=None, allow_reassignment=False, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (network_interface_id is not None): DCNL DCSP  DCSP params['NetworkInterfaceId'] = network_interface_id DCNL DCSP if (private_ip_addresses is not None): DCNL DCSP  DCSP self.build_list_params(params, private_ip_addresses, 'PrivateIpAddress') DCNL DCSP elif (secondary_private_ip_address_count is not None): DCNL DCSP  DCSP params['SecondaryPrivateIpAddressCount'] = secondary_private_ip_address_count DCNL DCSP if allow_reassignment: DCNL DCSP  DCSP params['AllowReassignment'] = 'true' DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('AssignPrivateIpAddresses', params, verb='POST')
def associate_address(self, instance_id=None, public_ip=None, allocation_id=None, network_interface_id=None, private_ip_address=None, allow_reassociation=False, dry_run=False): DCNL DCSP return self._associate_address(True, instance_id=instance_id, public_ip=public_ip, allocation_id=allocation_id, network_interface_id=network_interface_id, private_ip_address=private_ip_address, allow_reassociation=allow_reassociation, dry_run=dry_run)
def associate_address_object(self, instance_id=None, public_ip=None, allocation_id=None, network_interface_id=None, private_ip_address=None, allow_reassociation=False, dry_run=False): DCNL DCSP return self._associate_address(False, instance_id=instance_id, public_ip=public_ip, allocation_id=allocation_id, network_interface_id=network_interface_id, private_ip_address=private_ip_address, allow_reassociation=allow_reassociation, dry_run=dry_run)
def disassociate_address(self, public_ip=None, association_id=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (association_id is not None): DCNL DCSP  DCSP params['AssociationId'] = association_id DCNL DCSP elif (public_ip is not None): DCNL DCSP  DCSP params['PublicIp'] = public_ip DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DisassociateAddress', params, verb='POST')
def release_address(self, public_ip=None, allocation_id=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (public_ip is not None): DCNL DCSP  DCSP params['PublicIp'] = public_ip DCNL DCSP elif (allocation_id is not None): DCNL DCSP  DCSP params['AllocationId'] = allocation_id DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ReleaseAddress', params, verb='POST')
def unassign_private_ip_addresses(self, network_interface_id=None, private_ip_addresses=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (network_interface_id is not None): DCNL DCSP  DCSP params['NetworkInterfaceId'] = network_interface_id DCNL DCSP if (private_ip_addresses is not None): DCNL DCSP  DCSP self.build_list_params(params, private_ip_addresses, 'PrivateIpAddress') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('UnassignPrivateIpAddresses', params, verb='POST')
def get_all_volumes(self, volume_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if volume_ids: DCNL DCSP  DCSP self.build_list_params(params, volume_ids, 'VolumeId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeVolumes', params, [('item', Volume)], verb='POST')
def get_all_volume_status(self, volume_ids=None, max_results=None, next_token=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if volume_ids: DCNL DCSP  DCSP self.build_list_params(params, volume_ids, 'VolumeId') DCNL DCSP if max_results: DCNL DCSP  DCSP params['MaxResults'] = max_results DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('DescribeVolumeStatus', params, VolumeStatusSet, verb='POST')
def enable_volume_io(self, volume_id, dry_run=False): DCNL DCSP params = {'VolumeId': volume_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('EnableVolumeIO', params, verb='POST')
def get_volume_attribute(self, volume_id, attribute='autoEnableIO', dry_run=False): DCNL DCSP params = {'VolumeId': volume_id, 'Attribute': attribute} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('DescribeVolumeAttribute', params, VolumeAttribute, verb='POST')
def modify_volume_attribute(self, volume_id, attribute, new_value, dry_run=False): DCNL DCSP params = {'VolumeId': volume_id} DCNL DCSP if (attribute == 'AutoEnableIO'): DCNL DCSP  DCSP params['AutoEnableIO.Value'] = new_value DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ModifyVolumeAttribute', params, verb='POST')
def create_volume(self, size, zone, snapshot=None, volume_type=None, iops=None, encrypted=False, kms_key_id=None, dry_run=False): DCNL DCSP if isinstance(zone, Zone): DCNL DCSP  DCSP zone = zone.name DCNL DCSP params = {'AvailabilityZone': zone} DCNL DCSP if size: DCNL DCSP  DCSP params['Size'] = size DCNL DCSP if snapshot: DCNL DCSP  DCSP if isinstance(snapshot, Snapshot): DCNL DCSP  DCSP  DCSP snapshot = snapshot.id DCNL DCSP  DCSP params['SnapshotId'] = snapshot DCNL DCSP if volume_type: DCNL DCSP  DCSP params['VolumeType'] = volume_type DCNL DCSP if iops: DCNL DCSP  DCSP params['Iops'] = str(iops) DCNL DCSP if encrypted: DCNL DCSP  DCSP params['Encrypted'] = 'true' DCNL DCSP  DCSP if kms_key_id: DCNL DCSP  DCSP  DCSP params['KmsKeyId'] = kms_key_id DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateVolume', params, Volume, verb='POST')
def delete_volume(self, volume_id, dry_run=False): DCNL DCSP params = {'VolumeId': volume_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteVolume', params, verb='POST')
def attach_volume(self, volume_id, instance_id, device, dry_run=False): DCNL DCSP params = {'InstanceId': instance_id, 'VolumeId': volume_id, 'Device': device} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('AttachVolume', params, verb='POST')
def detach_volume(self, volume_id, instance_id=None, device=None, force=False, dry_run=False): DCNL DCSP params = {'VolumeId': volume_id} DCNL DCSP if instance_id: DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP if device: DCNL DCSP  DCSP params['Device'] = device DCNL DCSP if force: DCNL DCSP  DCSP params['Force'] = 'true' DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DetachVolume', params, verb='POST')
def get_all_snapshots(self, snapshot_ids=None, owner=None, restorable_by=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if snapshot_ids: DCNL DCSP  DCSP self.build_list_params(params, snapshot_ids, 'SnapshotId') DCNL DCSP if owner: DCNL DCSP  DCSP self.build_list_params(params, owner, 'Owner') DCNL DCSP if restorable_by: DCNL DCSP  DCSP self.build_list_params(params, restorable_by, 'RestorableBy') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeSnapshots', params, [('item', Snapshot)], verb='POST')
def create_snapshot(self, volume_id, description=None, dry_run=False): DCNL DCSP params = {'VolumeId': volume_id} DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description[0:255] DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP snapshot = self.get_object('CreateSnapshot', params, Snapshot, verb='POST') DCNL DCSP volume = self.get_all_volumes([volume_id], dry_run=dry_run)[0] DCNL DCSP volume_name = volume.tags.get('Name') DCNL DCSP if volume_name: DCNL DCSP  DCSP snapshot.add_tag('Name', volume_name) DCNL DCSP return snapshot
def delete_snapshot(self, snapshot_id, dry_run=False): DCNL DCSP params = {'SnapshotId': snapshot_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteSnapshot', params, verb='POST')
def copy_snapshot(self, source_region, source_snapshot_id, description=None, dry_run=False): DCNL DCSP params = {'SourceRegion': source_region, 'SourceSnapshotId': source_snapshot_id} DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP snapshot = self.get_object('CopySnapshot', params, Snapshot, verb='POST') DCNL DCSP return snapshot.id
def trim_snapshots(self, hourly_backups=8, daily_backups=7, weekly_backups=4, monthly_backups=True): DCNL DCSP now = datetime.utcnow() DCNL DCSP last_hour = datetime(now.year, now.month, now.day, now.hour) DCNL DCSP last_midnight = datetime(now.year, now.month, now.day) DCNL DCSP last_sunday = (datetime(now.year, now.month, now.day) - timedelta(days=((now.weekday() + 1) % 7))) DCNL DCSP start_of_month = datetime(now.year, now.month, 1) DCNL DCSP target_backup_times = [] DCNL DCSP oldest_snapshot_date = datetime(2007, 1, 1) DCNL DCSP for hour in range(0, hourly_backups): DCNL DCSP  DCSP target_backup_times.append((last_hour - timedelta(hours=hour))) DCNL DCSP for day in range(0, daily_backups): DCNL DCSP  DCSP target_backup_times.append((last_midnight - timedelta(days=day))) DCNL DCSP for week in range(0, weekly_backups): DCNL DCSP  DCSP target_backup_times.append((last_sunday - timedelta(weeks=week))) DCNL DCSP one_day = timedelta(days=1) DCNL DCSP monthly_snapshots_added = 0 DCNL DCSP while ((start_of_month > oldest_snapshot_date) and ((monthly_backups is True) or (monthly_snapshots_added < monthly_backups))): DCNL DCSP  DCSP target_backup_times.append(start_of_month) DCNL DCSP  DCSP monthly_snapshots_added += 1 DCNL DCSP  DCSP start_of_month -= one_day DCNL DCSP  DCSP start_of_month = datetime(start_of_month.year, start_of_month.month, 1) DCNL DCSP temp = [] DCNL DCSP for t in target_backup_times: DCNL DCSP  DCSP if (temp.__contains__(t) == False): DCNL DCSP  DCSP  DCSP temp.append(t) DCNL DCSP target_backup_times = sorted(temp) DCNL DCSP all_snapshots = self.get_all_snapshots(owner='self') DCNL DCSP all_snapshots.sort(key=(lambda x: x.start_time)) DCNL DCSP snaps_for_each_volume = {} DCNL DCSP for snap in all_snapshots: DCNL DCSP  DCSP volume_name = snap.tags.get('Name') DCNL DCSP  DCSP if volume_name: DCNL DCSP  DCSP  DCSP snaps_for_volume = snaps_for_each_volume.get(volume_name) DCNL DCSP  DCSP  DCSP if (not snaps_for_volume): DCNL DCSP  DCSP  DCSP  DCSP snaps_for_volume = [] DCNL DCSP  DCSP  DCSP  DCSP snaps_for_each_volume[volume_name] = snaps_for_volume DCNL DCSP  DCSP  DCSP snaps_for_volume.append(snap) DCNL DCSP for volume_name in snaps_for_each_volume: DCNL DCSP  DCSP snaps = snaps_for_each_volume[volume_name] DCNL DCSP  DCSP snaps = snaps[:(-1)] DCNL DCSP  DCSP time_period_number = 0 DCNL DCSP  DCSP snap_found_for_this_time_period = False DCNL DCSP  DCSP for snap in snaps: DCNL DCSP  DCSP  DCSP check_this_snap = True DCNL DCSP  DCSP  DCSP while (check_this_snap and (time_period_number < target_backup_times.__len__())): DCNL DCSP  DCSP  DCSP  DCSP snap_date = datetime.strptime(snap.start_time, '%Y-%m-%dT%H:%M:%S.000Z') DCNL DCSP  DCSP  DCSP  DCSP if (snap_date < target_backup_times[time_period_number]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (snap_found_for_this_time_period == True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not snap.tags.get('preserve_snapshot')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.delete_snapshot(snap.id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP boto.log.info(('Trimmed DCSP snapshot DCSP %s DCSP (%s)' % (snap.tags['Name'], snap.start_time))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except EC2ResponseError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP boto.log.error(('Attempt DCSP to DCSP trim DCSP snapshot DCSP %s DCSP (%s) DCSP failed. DCSP Possible DCSP result DCSP of DCSP a DCSP race DCSP condition DCSP with DCSP trimming DCSP on DCSP another DCSP server?' % (snap.tags['Name'], snap.start_time))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP snap_found_for_this_time_period = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP check_this_snap = False DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP time_period_number += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP snap_found_for_this_time_period = False
def get_snapshot_attribute(self, snapshot_id, attribute='createVolumePermission', dry_run=False): DCNL DCSP params = {'Attribute': attribute} DCNL DCSP if snapshot_id: DCNL DCSP  DCSP params['SnapshotId'] = snapshot_id DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('DescribeSnapshotAttribute', params, SnapshotAttribute, verb='POST')
def modify_snapshot_attribute(self, snapshot_id, attribute='createVolumePermission', operation='add', user_ids=None, groups=None, dry_run=False): DCNL DCSP params = {'SnapshotId': snapshot_id, 'Attribute': attribute, 'OperationType': operation} DCNL DCSP if user_ids: DCNL DCSP  DCSP self.build_list_params(params, user_ids, 'UserId') DCNL DCSP if groups: DCNL DCSP  DCSP self.build_list_params(params, groups, 'UserGroup') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ModifySnapshotAttribute', params, verb='POST')
def reset_snapshot_attribute(self, snapshot_id, attribute='createVolumePermission', dry_run=False): DCNL DCSP params = {'SnapshotId': snapshot_id, 'Attribute': attribute} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ResetSnapshotAttribute', params, verb='POST')
def get_all_key_pairs(self, keynames=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if keynames: DCNL DCSP  DCSP self.build_list_params(params, keynames, 'KeyName') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeKeyPairs', params, [('item', KeyPair)], verb='POST')
def get_key_pair(self, keyname, dry_run=False): DCNL DCSP try: DCNL DCSP  DCSP return self.get_all_key_pairs(keynames=[keyname], dry_run=dry_run)[0] DCNL DCSP except self.ResponseError as e: DCNL DCSP  DCSP if (e.code == 'InvalidKeyPair.NotFound'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def create_key_pair(self, key_name, dry_run=False): DCNL DCSP params = {'KeyName': key_name} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateKeyPair', params, KeyPair, verb='POST')
def delete_key_pair(self, key_name, dry_run=False): DCNL DCSP params = {'KeyName': key_name} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteKeyPair', params, verb='POST')
def import_key_pair(self, key_name, public_key_material, dry_run=False): DCNL DCSP public_key_material = base64.b64encode(public_key_material) DCNL DCSP params = {'KeyName': key_name, 'PublicKeyMaterial': public_key_material} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('ImportKeyPair', params, KeyPair, verb='POST')
def get_all_security_groups(self, groupnames=None, group_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (groupnames is not None): DCNL DCSP  DCSP self.build_list_params(params, groupnames, 'GroupName') DCNL DCSP if (group_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, group_ids, 'GroupId') DCNL DCSP if (filters is not None): DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeSecurityGroups', params, [('item', SecurityGroup)], verb='POST')
def create_security_group(self, name, description, vpc_id=None, dry_run=False): DCNL DCSP params = {'GroupName': name, 'GroupDescription': description} DCNL DCSP if (vpc_id is not None): DCNL DCSP  DCSP params['VpcId'] = vpc_id DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP group = self.get_object('CreateSecurityGroup', params, SecurityGroup, verb='POST') DCNL DCSP group.name = name DCNL DCSP group.description = description DCNL DCSP if (vpc_id is not None): DCNL DCSP  DCSP group.vpc_id = vpc_id DCNL DCSP return group
def delete_security_group(self, name=None, group_id=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['GroupName'] = name DCNL DCSP elif (group_id is not None): DCNL DCSP  DCSP params['GroupId'] = group_id DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteSecurityGroup', params, verb='POST')
def authorize_security_group_deprecated(self, group_name, src_security_group_name=None, src_security_group_owner_id=None, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, dry_run=False): DCNL DCSP params = {'GroupName': group_name} DCNL DCSP if src_security_group_name: DCNL DCSP  DCSP params['SourceSecurityGroupName'] = src_security_group_name DCNL DCSP if src_security_group_owner_id: DCNL DCSP  DCSP params['SourceSecurityGroupOwnerId'] = src_security_group_owner_id DCNL DCSP if ip_protocol: DCNL DCSP  DCSP params['IpProtocol'] = ip_protocol DCNL DCSP if from_port: DCNL DCSP  DCSP params['FromPort'] = from_port DCNL DCSP if to_port: DCNL DCSP  DCSP params['ToPort'] = to_port DCNL DCSP if cidr_ip: DCNL DCSP  DCSP params['CidrIp'] = cidr_ip DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('AuthorizeSecurityGroupIngress', params)
def authorize_security_group(self, group_name=None, src_security_group_name=None, src_security_group_owner_id=None, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, group_id=None, src_security_group_group_id=None, dry_run=False): DCNL DCSP if src_security_group_name: DCNL DCSP  DCSP if ((from_port is None) and (to_port is None) and (ip_protocol is None)): DCNL DCSP  DCSP  DCSP return self.authorize_security_group_deprecated(group_name, src_security_group_name, src_security_group_owner_id) DCNL DCSP params = {} DCNL DCSP if group_name: DCNL DCSP  DCSP params['GroupName'] = group_name DCNL DCSP if group_id: DCNL DCSP  DCSP params['GroupId'] = group_id DCNL DCSP if src_security_group_name: DCNL DCSP  DCSP param_name = 'IpPermissions.1.Groups.1.GroupName' DCNL DCSP  DCSP params[param_name] = src_security_group_name DCNL DCSP if src_security_group_owner_id: DCNL DCSP  DCSP param_name = 'IpPermissions.1.Groups.1.UserId' DCNL DCSP  DCSP params[param_name] = src_security_group_owner_id DCNL DCSP if src_security_group_group_id: DCNL DCSP  DCSP param_name = 'IpPermissions.1.Groups.1.GroupId' DCNL DCSP  DCSP params[param_name] = src_security_group_group_id DCNL DCSP if ip_protocol: DCNL DCSP  DCSP params['IpPermissions.1.IpProtocol'] = ip_protocol DCNL DCSP if (from_port is not None): DCNL DCSP  DCSP params['IpPermissions.1.FromPort'] = from_port DCNL DCSP if (to_port is not None): DCNL DCSP  DCSP params['IpPermissions.1.ToPort'] = to_port DCNL DCSP if cidr_ip: DCNL DCSP  DCSP if (not isinstance(cidr_ip, list)): DCNL DCSP  DCSP  DCSP cidr_ip = [cidr_ip] DCNL DCSP  DCSP for (i, single_cidr_ip) in enumerate(cidr_ip): DCNL DCSP  DCSP  DCSP params[('IpPermissions.1.IpRanges.%d.CidrIp' % (i + 1))] = single_cidr_ip DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('AuthorizeSecurityGroupIngress', params, verb='POST')
def authorize_security_group_egress(self, group_id, ip_protocol, from_port=None, to_port=None, src_group_id=None, cidr_ip=None, dry_run=False): DCNL DCSP params = {'GroupId': group_id, 'IpPermissions.1.IpProtocol': ip_protocol} DCNL DCSP if (from_port is not None): DCNL DCSP  DCSP params['IpPermissions.1.FromPort'] = from_port DCNL DCSP if (to_port is not None): DCNL DCSP  DCSP params['IpPermissions.1.ToPort'] = to_port DCNL DCSP if (src_group_id is not None): DCNL DCSP  DCSP params['IpPermissions.1.Groups.1.GroupId'] = src_group_id DCNL DCSP if (cidr_ip is not None): DCNL DCSP  DCSP params['IpPermissions.1.IpRanges.1.CidrIp'] = cidr_ip DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('AuthorizeSecurityGroupEgress', params, verb='POST')
def revoke_security_group_deprecated(self, group_name, src_security_group_name=None, src_security_group_owner_id=None, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, dry_run=False): DCNL DCSP params = {'GroupName': group_name} DCNL DCSP if src_security_group_name: DCNL DCSP  DCSP params['SourceSecurityGroupName'] = src_security_group_name DCNL DCSP if src_security_group_owner_id: DCNL DCSP  DCSP params['SourceSecurityGroupOwnerId'] = src_security_group_owner_id DCNL DCSP if ip_protocol: DCNL DCSP  DCSP params['IpProtocol'] = ip_protocol DCNL DCSP if from_port: DCNL DCSP  DCSP params['FromPort'] = from_port DCNL DCSP if to_port: DCNL DCSP  DCSP params['ToPort'] = to_port DCNL DCSP if cidr_ip: DCNL DCSP  DCSP params['CidrIp'] = cidr_ip DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('RevokeSecurityGroupIngress', params)
def revoke_security_group(self, group_name=None, src_security_group_name=None, src_security_group_owner_id=None, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, group_id=None, src_security_group_group_id=None, dry_run=False): DCNL DCSP if src_security_group_name: DCNL DCSP  DCSP if ((from_port is None) and (to_port is None) and (ip_protocol is None)): DCNL DCSP  DCSP  DCSP return self.revoke_security_group_deprecated(group_name, src_security_group_name, src_security_group_owner_id) DCNL DCSP params = {} DCNL DCSP if (group_name is not None): DCNL DCSP  DCSP params['GroupName'] = group_name DCNL DCSP if (group_id is not None): DCNL DCSP  DCSP params['GroupId'] = group_id DCNL DCSP if src_security_group_name: DCNL DCSP  DCSP param_name = 'IpPermissions.1.Groups.1.GroupName' DCNL DCSP  DCSP params[param_name] = src_security_group_name DCNL DCSP if src_security_group_group_id: DCNL DCSP  DCSP param_name = 'IpPermissions.1.Groups.1.GroupId' DCNL DCSP  DCSP params[param_name] = src_security_group_group_id DCNL DCSP if src_security_group_owner_id: DCNL DCSP  DCSP param_name = 'IpPermissions.1.Groups.1.UserId' DCNL DCSP  DCSP params[param_name] = src_security_group_owner_id DCNL DCSP if ip_protocol: DCNL DCSP  DCSP params['IpPermissions.1.IpProtocol'] = ip_protocol DCNL DCSP if (from_port is not None): DCNL DCSP  DCSP params['IpPermissions.1.FromPort'] = from_port DCNL DCSP if (to_port is not None): DCNL DCSP  DCSP params['IpPermissions.1.ToPort'] = to_port DCNL DCSP if cidr_ip: DCNL DCSP  DCSP params['IpPermissions.1.IpRanges.1.CidrIp'] = cidr_ip DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('RevokeSecurityGroupIngress', params, verb='POST')
def revoke_security_group_egress(self, group_id, ip_protocol, from_port=None, to_port=None, src_group_id=None, cidr_ip=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if group_id: DCNL DCSP  DCSP params['GroupId'] = group_id DCNL DCSP if ip_protocol: DCNL DCSP  DCSP params['IpPermissions.1.IpProtocol'] = ip_protocol DCNL DCSP if (from_port is not None): DCNL DCSP  DCSP params['IpPermissions.1.FromPort'] = from_port DCNL DCSP if (to_port is not None): DCNL DCSP  DCSP params['IpPermissions.1.ToPort'] = to_port DCNL DCSP if (src_group_id is not None): DCNL DCSP  DCSP params['IpPermissions.1.Groups.1.GroupId'] = src_group_id DCNL DCSP if cidr_ip: DCNL DCSP  DCSP params['IpPermissions.1.IpRanges.1.CidrIp'] = cidr_ip DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('RevokeSecurityGroupEgress', params, verb='POST')
def get_all_regions(self, region_names=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if region_names: DCNL DCSP  DCSP self.build_list_params(params, region_names, 'RegionName') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP regions = self.get_list('DescribeRegions', params, [('item', RegionInfo)], verb='POST') DCNL DCSP for region in regions: DCNL DCSP  DCSP region.connection_cls = EC2Connection DCNL DCSP return regions
def get_all_reserved_instances_offerings(self, reserved_instances_offering_ids=None, instance_type=None, availability_zone=None, product_description=None, filters=None, instance_tenancy=None, offering_type=None, include_marketplace=None, min_duration=None, max_duration=None, max_instance_count=None, next_token=None, max_results=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (reserved_instances_offering_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, reserved_instances_offering_ids, 'ReservedInstancesOfferingId') DCNL DCSP if instance_type: DCNL DCSP  DCSP params['InstanceType'] = instance_type DCNL DCSP if availability_zone: DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if product_description: DCNL DCSP  DCSP params['ProductDescription'] = product_description DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if (instance_tenancy is not None): DCNL DCSP  DCSP params['InstanceTenancy'] = instance_tenancy DCNL DCSP if (offering_type is not None): DCNL DCSP  DCSP params['OfferingType'] = offering_type DCNL DCSP if (include_marketplace is not None): DCNL DCSP  DCSP if include_marketplace: DCNL DCSP  DCSP  DCSP params['IncludeMarketplace'] = 'true' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params['IncludeMarketplace'] = 'false' DCNL DCSP if (min_duration is not None): DCNL DCSP  DCSP params['MinDuration'] = str(min_duration) DCNL DCSP if (max_duration is not None): DCNL DCSP  DCSP params['MaxDuration'] = str(max_duration) DCNL DCSP if (max_instance_count is not None): DCNL DCSP  DCSP params['MaxInstanceCount'] = str(max_instance_count) DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['MaxResults'] = str(max_results) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeReservedInstancesOfferings', params, [('item', ReservedInstancesOffering)], verb='POST')
def get_all_reserved_instances(self, reserved_instances_id=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if reserved_instances_id: DCNL DCSP  DCSP self.build_list_params(params, reserved_instances_id, 'ReservedInstancesId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeReservedInstances', params, [('item', ReservedInstance)], verb='POST')
def purchase_reserved_instance_offering(self, reserved_instances_offering_id, instance_count=1, limit_price=None, dry_run=False): DCNL DCSP params = {'ReservedInstancesOfferingId': reserved_instances_offering_id, 'InstanceCount': instance_count} DCNL DCSP if (limit_price is not None): DCNL DCSP  DCSP params['LimitPrice.Amount'] = str(limit_price[0]) DCNL DCSP  DCSP params['LimitPrice.CurrencyCode'] = str(limit_price[1]) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('PurchaseReservedInstancesOffering', params, ReservedInstance, verb='POST')
def create_reserved_instances_listing(self, reserved_instances_id, instance_count, price_schedules, client_token, dry_run=False): DCNL DCSP params = {'ReservedInstancesId': reserved_instances_id, 'InstanceCount': str(instance_count), 'ClientToken': client_token} DCNL DCSP for (i, schedule) in enumerate(price_schedules): DCNL DCSP  DCSP (price, term) = schedule DCNL DCSP  DCSP params[('PriceSchedules.%s.Price' % i)] = str(price) DCNL DCSP  DCSP params[('PriceSchedules.%s.Term' % i)] = str(term) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('CreateReservedInstancesListing', params, [('item', ReservedInstanceListing)], verb='POST')
def cancel_reserved_instances_listing(self, reserved_instances_listing_ids=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (reserved_instances_listing_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, reserved_instances_listing_ids, 'ReservedInstancesListingId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('CancelReservedInstancesListing', params, [('item', ReservedInstanceListing)], verb='POST')
def modify_reserved_instances(self, client_token, reserved_instance_ids, target_configurations): DCNL DCSP params = {} DCNL DCSP if (client_token is not None): DCNL DCSP  DCSP params['ClientToken'] = client_token DCNL DCSP if (reserved_instance_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, reserved_instance_ids, 'ReservedInstancesId') DCNL DCSP if (target_configurations is not None): DCNL DCSP  DCSP self.build_configurations_param_list(params, target_configurations) DCNL DCSP mrir = self.get_object('ModifyReservedInstances', params, ModifyReservedInstancesResult, verb='POST') DCNL DCSP return mrir.modification_id
def describe_reserved_instances_modifications(self, reserved_instances_modification_ids=None, next_token=None, filters=None): DCNL DCSP params = {} DCNL DCSP if reserved_instances_modification_ids: DCNL DCSP  DCSP self.build_list_params(params, reserved_instances_modification_ids, 'ReservedInstancesModificationId') DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP return self.get_list('DescribeReservedInstancesModifications', params, [('item', ReservedInstancesModification)], verb='POST')
def monitor_instances(self, instance_ids, dry_run=False): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, instance_ids, 'InstanceId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('MonitorInstances', params, [('item', InstanceInfo)], verb='POST')
def monitor_instance(self, instance_id, dry_run=False): DCNL DCSP return self.monitor_instances([instance_id], dry_run=dry_run)
def unmonitor_instances(self, instance_ids, dry_run=False): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, instance_ids, 'InstanceId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('UnmonitorInstances', params, [('item', InstanceInfo)], verb='POST')
def unmonitor_instance(self, instance_id, dry_run=False): DCNL DCSP return self.unmonitor_instances([instance_id], dry_run=dry_run)
def bundle_instance(self, instance_id, s3_bucket, s3_prefix, s3_upload_policy, dry_run=False): DCNL DCSP params = {'InstanceId': instance_id, 'Storage.S3.Bucket': s3_bucket, 'Storage.S3.Prefix': s3_prefix, 'Storage.S3.UploadPolicy': s3_upload_policy} DCNL DCSP s3auth = boto.auth.get_auth_handler(None, boto.config, self.provider, ['s3']) DCNL DCSP params['Storage.S3.AWSAccessKeyId'] = self.aws_access_key_id DCNL DCSP signature = s3auth.sign_string(s3_upload_policy) DCNL DCSP params['Storage.S3.UploadPolicySignature'] = signature DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('BundleInstance', params, BundleInstanceTask, verb='POST')
def get_all_bundle_tasks(self, bundle_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if bundle_ids: DCNL DCSP  DCSP self.build_list_params(params, bundle_ids, 'BundleId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeBundleTasks', params, [('item', BundleInstanceTask)], verb='POST')
def cancel_bundle_task(self, bundle_id, dry_run=False): DCNL DCSP params = {'BundleId': bundle_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CancelBundleTask', params, BundleInstanceTask, verb='POST')
def get_password_data(self, instance_id, dry_run=False): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP rs = self.get_object('GetPasswordData', params, ResultSet, verb='POST') DCNL DCSP return rs.passwordData
def get_all_placement_groups(self, groupnames=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if groupnames: DCNL DCSP  DCSP self.build_list_params(params, groupnames, 'GroupName') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribePlacementGroups', params, [('item', PlacementGroup)], verb='POST')
def create_placement_group(self, name, strategy='cluster', dry_run=False): DCNL DCSP params = {'GroupName': name, 'Strategy': strategy} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP group = self.get_status('CreatePlacementGroup', params, verb='POST') DCNL DCSP return group
def delete_placement_group(self, name, dry_run=False): DCNL DCSP params = {'GroupName': name} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeletePlacementGroup', params, verb='POST')
def get_all_tags(self, filters=None, dry_run=False, max_results=None): DCNL DCSP params = {} DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['MaxResults'] = max_results DCNL DCSP return self.get_list('DescribeTags', params, [('item', Tag)], verb='POST')
def create_tags(self, resource_ids, tags, dry_run=False): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, resource_ids, 'ResourceId') DCNL DCSP self.build_tag_param_list(params, tags) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('CreateTags', params, verb='POST')
def delete_tags(self, resource_ids, tags, dry_run=False): DCNL DCSP if isinstance(tags, list): DCNL DCSP  DCSP tags = {}.fromkeys(tags, None) DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, resource_ids, 'ResourceId') DCNL DCSP self.build_tag_param_list(params, tags) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteTags', params, verb='POST')
def get_all_network_interfaces(self, network_interface_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if network_interface_ids: DCNL DCSP  DCSP self.build_list_params(params, network_interface_ids, 'NetworkInterfaceId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeNetworkInterfaces', params, [('item', NetworkInterface)], verb='POST')
def create_network_interface(self, subnet_id, private_ip_address=None, description=None, groups=None, dry_run=False): DCNL DCSP params = {'SubnetId': subnet_id} DCNL DCSP if private_ip_address: DCNL DCSP  DCSP params['PrivateIpAddress'] = private_ip_address DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if groups: DCNL DCSP  DCSP ids = [] DCNL DCSP  DCSP for group in groups: DCNL DCSP  DCSP  DCSP if isinstance(group, SecurityGroup): DCNL DCSP  DCSP  DCSP  DCSP ids.append(group.id) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ids.append(group) DCNL DCSP  DCSP self.build_list_params(params, ids, 'SecurityGroupId') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateNetworkInterface', params, NetworkInterface, verb='POST')
def attach_network_interface(self, network_interface_id, instance_id, device_index, dry_run=False): DCNL DCSP params = {'NetworkInterfaceId': network_interface_id, 'InstanceId': instance_id, 'DeviceIndex': device_index} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('AttachNetworkInterface', params, verb='POST')
def detach_network_interface(self, attachment_id, force=False, dry_run=False): DCNL DCSP params = {'AttachmentId': attachment_id} DCNL DCSP if force: DCNL DCSP  DCSP params['Force'] = 'true' DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DetachNetworkInterface', params, verb='POST')
def delete_network_interface(self, network_interface_id, dry_run=False): DCNL DCSP params = {'NetworkInterfaceId': network_interface_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteNetworkInterface', params, verb='POST')
def get_all_instance_types(self): DCNL DCSP params = {} DCNL DCSP return self.get_list('DescribeInstanceTypes', params, [('item', InstanceType)], verb='POST')
def copy_image(self, source_region, source_image_id, name=None, description=None, client_token=None, dry_run=False, encrypted=None, kms_key_id=None): DCNL DCSP params = {'SourceRegion': source_region, 'SourceImageId': source_image_id} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if (client_token is not None): DCNL DCSP  DCSP params['ClientToken'] = client_token DCNL DCSP if (encrypted is not None): DCNL DCSP  DCSP params['Encrypted'] = ('true' if encrypted else 'false') DCNL DCSP if (kms_key_id is not None): DCNL DCSP  DCSP params['KmsKeyId'] = kms_key_id DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CopyImage', params, CopyImage, verb='POST')
def describe_account_attributes(self, attribute_names=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if (attribute_names is not None): DCNL DCSP  DCSP self.build_list_params(params, attribute_names, 'AttributeName') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeAccountAttributes', params, [('item', AccountAttribute)], verb='POST')
def describe_vpc_attribute(self, vpc_id, attribute=None, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id} DCNL DCSP if (attribute is not None): DCNL DCSP  DCSP params['Attribute'] = attribute DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('DescribeVpcAttribute', params, VPCAttribute, verb='POST')
def modify_vpc_attribute(self, vpc_id, enable_dns_support=None, enable_dns_hostnames=None, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id} DCNL DCSP if (enable_dns_support is not None): DCNL DCSP  DCSP params['EnableDnsSupport.Value'] = ('true' if enable_dns_support else 'false') DCNL DCSP if (enable_dns_hostnames is not None): DCNL DCSP  DCSP params['EnableDnsHostnames.Value'] = ('true' if enable_dns_hostnames else 'false') DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ModifyVpcAttribute', params, verb='POST')
def get_all_classic_link_instances(self, instance_ids=None, filters=None, dry_run=False, max_results=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if instance_ids: DCNL DCSP  DCSP self.build_list_params(params, instance_ids, 'InstanceId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['MaxResults'] = max_results DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('DescribeClassicLinkInstances', params, [('item', Instance)], verb='POST')
def __init__(self, load_balancer=None, description=None, state=None, instance_id=None, reason_code=None): DCNL DCSP self.load_balancer = load_balancer DCNL DCSP self.description = description DCNL DCSP self.state = state DCNL DCSP self.instance_id = instance_id DCNL DCSP self.reason_code = reason_code
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', security_token=None, validate_certs=True, profile_name=None): DCNL DCSP if (not region): DCNL DCSP  DCSP region = RegionInfo(self, self.DefaultRegionName, self.DefaultRegionEndpoint) DCNL DCSP self.region = region DCNL DCSP super(ELBConnection, self).__init__(aws_access_key_id, aws_secret_access_key, is_secure, port, proxy, proxy_port, proxy_user, proxy_pass, self.region.endpoint, debug, https_connection_factory, path, security_token, validate_certs=validate_certs, profile_name=profile_name)
def get_all_load_balancers(self, load_balancer_names=None, marker=None): DCNL DCSP params = {} DCNL DCSP if load_balancer_names: DCNL DCSP  DCSP self.build_list_params(params, load_balancer_names, 'LoadBalancerNames.member.%d') DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_list('DescribeLoadBalancers', params, [('member', LoadBalancer)])
def create_load_balancer(self, name, zones, listeners=None, subnets=None, security_groups=None, scheme='internet-facing', complex_listeners=None): DCNL DCSP if ((not listeners) and (not complex_listeners)): DCNL DCSP  DCSP return None DCNL DCSP params = {'LoadBalancerName': name, 'Scheme': scheme} DCNL DCSP if listeners: DCNL DCSP  DCSP for (index, listener) in enumerate(listeners): DCNL DCSP  DCSP  DCSP i = (index + 1) DCNL DCSP  DCSP  DCSP protocol = listener[2].upper() DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.LoadBalancerPort' % i)] = listener[0] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.InstancePort' % i)] = listener[1] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.Protocol' % i)] = listener[2] DCNL DCSP  DCSP  DCSP if ((protocol == 'HTTPS') or (protocol == 'SSL')): DCNL DCSP  DCSP  DCSP  DCSP params[('Listeners.member.%d.SSLCertificateId' % i)] = listener[3] DCNL DCSP if complex_listeners: DCNL DCSP  DCSP for (index, listener) in enumerate(complex_listeners): DCNL DCSP  DCSP  DCSP i = (index + 1) DCNL DCSP  DCSP  DCSP protocol = listener[2].upper() DCNL DCSP  DCSP  DCSP InstanceProtocol = listener[3].upper() DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.LoadBalancerPort' % i)] = listener[0] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.InstancePort' % i)] = listener[1] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.Protocol' % i)] = listener[2] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.InstanceProtocol' % i)] = listener[3] DCNL DCSP  DCSP  DCSP if ((protocol == 'HTTPS') or (protocol == 'SSL')): DCNL DCSP  DCSP  DCSP  DCSP params[('Listeners.member.%d.SSLCertificateId' % i)] = listener[4] DCNL DCSP if zones: DCNL DCSP  DCSP self.build_list_params(params, zones, 'AvailabilityZones.member.%d') DCNL DCSP if subnets: DCNL DCSP  DCSP self.build_list_params(params, subnets, 'Subnets.member.%d') DCNL DCSP if security_groups: DCNL DCSP  DCSP self.build_list_params(params, security_groups, 'SecurityGroups.member.%d') DCNL DCSP load_balancer = self.get_object('CreateLoadBalancer', params, LoadBalancer) DCNL DCSP load_balancer.name = name DCNL DCSP load_balancer.listeners = listeners DCNL DCSP load_balancer.availability_zones = zones DCNL DCSP load_balancer.subnets = subnets DCNL DCSP load_balancer.security_groups = security_groups DCNL DCSP return load_balancer
def create_load_balancer_listeners(self, name, listeners=None, complex_listeners=None): DCNL DCSP if ((not listeners) and (not complex_listeners)): DCNL DCSP  DCSP return None DCNL DCSP params = {'LoadBalancerName': name} DCNL DCSP if listeners: DCNL DCSP  DCSP for (index, listener) in enumerate(listeners): DCNL DCSP  DCSP  DCSP i = (index + 1) DCNL DCSP  DCSP  DCSP protocol = listener[2].upper() DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.LoadBalancerPort' % i)] = listener[0] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.InstancePort' % i)] = listener[1] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.Protocol' % i)] = listener[2] DCNL DCSP  DCSP  DCSP if ((protocol == 'HTTPS') or (protocol == 'SSL')): DCNL DCSP  DCSP  DCSP  DCSP params[('Listeners.member.%d.SSLCertificateId' % i)] = listener[3] DCNL DCSP if complex_listeners: DCNL DCSP  DCSP for (index, listener) in enumerate(complex_listeners): DCNL DCSP  DCSP  DCSP i = (index + 1) DCNL DCSP  DCSP  DCSP protocol = listener[2].upper() DCNL DCSP  DCSP  DCSP InstanceProtocol = listener[3].upper() DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.LoadBalancerPort' % i)] = listener[0] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.InstancePort' % i)] = listener[1] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.Protocol' % i)] = listener[2] DCNL DCSP  DCSP  DCSP params[('Listeners.member.%d.InstanceProtocol' % i)] = listener[3] DCNL DCSP  DCSP  DCSP if ((protocol == 'HTTPS') or (protocol == 'SSL')): DCNL DCSP  DCSP  DCSP  DCSP params[('Listeners.member.%d.SSLCertificateId' % i)] = listener[4] DCNL DCSP return self.get_status('CreateLoadBalancerListeners', params)
def delete_load_balancer(self, name): DCNL DCSP params = {'LoadBalancerName': name} DCNL DCSP return self.get_status('DeleteLoadBalancer', params)
def delete_load_balancer_listeners(self, name, ports): DCNL DCSP params = {'LoadBalancerName': name} DCNL DCSP for (index, port) in enumerate(ports): DCNL DCSP  DCSP params[('LoadBalancerPorts.member.%d' % (index + 1))] = port DCNL DCSP return self.get_status('DeleteLoadBalancerListeners', params)
def enable_availability_zones(self, load_balancer_name, zones_to_add): DCNL DCSP params = {'LoadBalancerName': load_balancer_name} DCNL DCSP self.build_list_params(params, zones_to_add, 'AvailabilityZones.member.%d') DCNL DCSP obj = self.get_object('EnableAvailabilityZonesForLoadBalancer', params, LoadBalancerZones) DCNL DCSP return obj.zones
def disable_availability_zones(self, load_balancer_name, zones_to_remove): DCNL DCSP params = {'LoadBalancerName': load_balancer_name} DCNL DCSP self.build_list_params(params, zones_to_remove, 'AvailabilityZones.member.%d') DCNL DCSP obj = self.get_object('DisableAvailabilityZonesForLoadBalancer', params, LoadBalancerZones) DCNL DCSP return obj.zones
def modify_lb_attribute(self, load_balancer_name, attribute, value): DCNL DCSP bool_reqs = ('crosszoneloadbalancing',) DCNL DCSP if (attribute.lower() in bool_reqs): DCNL DCSP  DCSP if isinstance(value, bool): DCNL DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP value = 'true' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = 'false' DCNL DCSP params = {'LoadBalancerName': load_balancer_name} DCNL DCSP if (attribute.lower() == 'crosszoneloadbalancing'): DCNL DCSP  DCSP params['LoadBalancerAttributes.CrossZoneLoadBalancing.Enabled'] = value DCNL DCSP elif (attribute.lower() == 'accesslog'): DCNL DCSP  DCSP params['LoadBalancerAttributes.AccessLog.Enabled'] = ((value.enabled and 'true') or 'false') DCNL DCSP  DCSP params['LoadBalancerAttributes.AccessLog.S3BucketName'] = value.s3_bucket_name DCNL DCSP  DCSP params['LoadBalancerAttributes.AccessLog.S3BucketPrefix'] = value.s3_bucket_prefix DCNL DCSP  DCSP params['LoadBalancerAttributes.AccessLog.EmitInterval'] = value.emit_interval DCNL DCSP elif (attribute.lower() == 'connectiondraining'): DCNL DCSP  DCSP params['LoadBalancerAttributes.ConnectionDraining.Enabled'] = ((value.enabled and 'true') or 'false') DCNL DCSP  DCSP params['LoadBalancerAttributes.ConnectionDraining.Timeout'] = value.timeout DCNL DCSP elif (attribute.lower() == 'connectingsettings'): DCNL DCSP  DCSP params['LoadBalancerAttributes.ConnectionSettings.IdleTimeout'] = value.idle_timeout DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('InvalidAttribute', attribute) DCNL DCSP return self.get_status('ModifyLoadBalancerAttributes', params, verb='GET')
def get_all_lb_attributes(self, load_balancer_name): DCNL DCSP from boto.ec2.elb.attributes import LbAttributes DCNL DCSP params = {'LoadBalancerName': load_balancer_name} DCNL DCSP return self.get_object('DescribeLoadBalancerAttributes', params, LbAttributes)
def get_lb_attribute(self, load_balancer_name, attribute): DCNL DCSP attributes = self.get_all_lb_attributes(load_balancer_name) DCNL DCSP if (attribute.lower() == 'accesslog'): DCNL DCSP  DCSP return attributes.access_log DCNL DCSP if (attribute.lower() == 'crosszoneloadbalancing'): DCNL DCSP  DCSP return attributes.cross_zone_load_balancing.enabled DCNL DCSP if (attribute.lower() == 'connectiondraining'): DCNL DCSP  DCSP return attributes.connection_draining DCNL DCSP if (attribute.lower() == 'connectingsettings'): DCNL DCSP  DCSP return attributes.connecting_settings DCNL DCSP return None
def register_instances(self, load_balancer_name, instances): DCNL DCSP params = {'LoadBalancerName': load_balancer_name} DCNL DCSP self.build_list_params(params, instances, 'Instances.member.%d.InstanceId') DCNL DCSP return self.get_list('RegisterInstancesWithLoadBalancer', params, [('member', InstanceInfo)])
def deregister_instances(self, load_balancer_name, instances): DCNL DCSP params = {'LoadBalancerName': load_balancer_name} DCNL DCSP self.build_list_params(params, instances, 'Instances.member.%d.InstanceId') DCNL DCSP return self.get_list('DeregisterInstancesFromLoadBalancer', params, [('member', InstanceInfo)])
def describe_instance_health(self, load_balancer_name, instances=None): DCNL DCSP params = {'LoadBalancerName': load_balancer_name} DCNL DCSP if instances: DCNL DCSP  DCSP self.build_list_params(params, instances, 'Instances.member.%d.InstanceId') DCNL DCSP return self.get_list('DescribeInstanceHealth', params, [('member', InstanceState)])
def configure_health_check(self, name, health_check): DCNL DCSP params = {'LoadBalancerName': name, 'HealthCheck.Timeout': health_check.timeout, 'HealthCheck.Target': health_check.target, 'HealthCheck.Interval': health_check.interval, 'HealthCheck.UnhealthyThreshold': health_check.unhealthy_threshold, 'HealthCheck.HealthyThreshold': health_check.healthy_threshold} DCNL DCSP return self.get_object('ConfigureHealthCheck', params, HealthCheck)
def set_lb_listener_SSL_certificate(self, lb_name, lb_port, ssl_certificate_id): DCNL DCSP params = {'LoadBalancerName': lb_name, 'LoadBalancerPort': lb_port, 'SSLCertificateId': ssl_certificate_id} DCNL DCSP return self.get_status('SetLoadBalancerListenerSSLCertificate', params)
def create_app_cookie_stickiness_policy(self, name, lb_name, policy_name): DCNL DCSP params = {'CookieName': name, 'LoadBalancerName': lb_name, 'PolicyName': policy_name} DCNL DCSP return self.get_status('CreateAppCookieStickinessPolicy', params)
def create_lb_cookie_stickiness_policy(self, cookie_expiration_period, lb_name, policy_name): DCNL DCSP params = {'LoadBalancerName': lb_name, 'PolicyName': policy_name} DCNL DCSP if (cookie_expiration_period is not None): DCNL DCSP  DCSP params['CookieExpirationPeriod'] = cookie_expiration_period DCNL DCSP return self.get_status('CreateLBCookieStickinessPolicy', params)
def create_lb_policy(self, lb_name, policy_name, policy_type, policy_attributes): DCNL DCSP params = {'LoadBalancerName': lb_name, 'PolicyName': policy_name, 'PolicyTypeName': policy_type} DCNL DCSP for (index, (name, value)) in enumerate(six.iteritems(policy_attributes), 1): DCNL DCSP  DCSP params[('PolicyAttributes.member.%d.AttributeName' % index)] = name DCNL DCSP  DCSP params[('PolicyAttributes.member.%d.AttributeValue' % index)] = value DCNL DCSP else: DCNL DCSP  DCSP params['PolicyAttributes'] = '' DCNL DCSP return self.get_status('CreateLoadBalancerPolicy', params)
def delete_lb_policy(self, lb_name, policy_name): DCNL DCSP params = {'LoadBalancerName': lb_name, 'PolicyName': policy_name} DCNL DCSP return self.get_status('DeleteLoadBalancerPolicy', params)
def set_lb_policies_of_listener(self, lb_name, lb_port, policies): DCNL DCSP params = {'LoadBalancerName': lb_name, 'LoadBalancerPort': lb_port} DCNL DCSP if len(policies): DCNL DCSP  DCSP self.build_list_params(params, policies, 'PolicyNames.member.%d') DCNL DCSP else: DCNL DCSP  DCSP params['PolicyNames'] = '' DCNL DCSP return self.get_status('SetLoadBalancerPoliciesOfListener', params)
def set_lb_policies_of_backend_server(self, lb_name, instance_port, policies): DCNL DCSP params = {'LoadBalancerName': lb_name, 'InstancePort': instance_port} DCNL DCSP if policies: DCNL DCSP  DCSP self.build_list_params(params, policies, 'PolicyNames.member.%d') DCNL DCSP else: DCNL DCSP  DCSP params['PolicyNames'] = '' DCNL DCSP return self.get_status('SetLoadBalancerPoliciesForBackendServer', params)
def apply_security_groups_to_lb(self, name, security_groups): DCNL DCSP params = {'LoadBalancerName': name} DCNL DCSP self.build_list_params(params, security_groups, 'SecurityGroups.member.%d') DCNL DCSP return self.get_list('ApplySecurityGroupsToLoadBalancer', params, None)
def attach_lb_to_subnets(self, name, subnets): DCNL DCSP params = {'LoadBalancerName': name} DCNL DCSP self.build_list_params(params, subnets, 'Subnets.member.%d') DCNL DCSP return self.get_list('AttachLoadBalancerToSubnets', params, None)
def detach_lb_from_subnets(self, name, subnets): DCNL DCSP params = {'LoadBalancerName': name} DCNL DCSP self.build_list_params(params, subnets, 'Subnets.member.%d') DCNL DCSP return self.get_list('DetachLoadBalancerFromSubnets', params, None)
def __init__(self, access_point=None, interval=30, target=None, healthy_threshold=3, timeout=5, unhealthy_threshold=5): DCNL DCSP self.access_point = access_point DCNL DCSP self.interval = interval DCNL DCSP self.target = target DCNL DCSP self.healthy_threshold = healthy_threshold DCNL DCSP self.timeout = timeout DCNL DCSP self.unhealthy_threshold = unhealthy_threshold
def update(self): DCNL DCSP if (not self.access_point): DCNL DCSP  DCSP return DCNL DCSP new_hc = self.connection.configure_health_check(self.access_point, self) DCNL DCSP self.interval = new_hc.interval DCNL DCSP self.target = new_hc.target DCNL DCSP self.healthy_threshold = new_hc.healthy_threshold DCNL DCSP self.unhealthy_threshold = new_hc.unhealthy_threshold DCNL DCSP self.timeout = new_hc.timeout
def __init__(self, connection=None, name=None, endpoints=None): DCNL DCSP self.connection = connection DCNL DCSP self.name = name DCNL DCSP self.listeners = None DCNL DCSP self.health_check = None DCNL DCSP self.policies = None DCNL DCSP self.dns_name = None DCNL DCSP self.created_time = None DCNL DCSP self.instances = None DCNL DCSP self.availability_zones = ListElement() DCNL DCSP self.canonical_hosted_zone_name = None DCNL DCSP self.canonical_hosted_zone_name_id = None DCNL DCSP self.source_security_group = None DCNL DCSP self.subnets = ListElement() DCNL DCSP self.security_groups = ListElement() DCNL DCSP self.vpc_id = None DCNL DCSP self.scheme = None DCNL DCSP self.backends = None DCNL DCSP self._attributes = None
def enable_zones(self, zones): DCNL DCSP if isinstance(zones, six.string_types): DCNL DCSP  DCSP zones = [zones] DCNL DCSP new_zones = self.connection.enable_availability_zones(self.name, zones) DCNL DCSP self.availability_zones = new_zones
def disable_zones(self, zones): DCNL DCSP if isinstance(zones, six.string_types): DCNL DCSP  DCSP zones = [zones] DCNL DCSP new_zones = self.connection.disable_availability_zones(self.name, zones) DCNL DCSP self.availability_zones = new_zones
def get_attributes(self, force=False): DCNL DCSP if ((not self._attributes) or force): DCNL DCSP  DCSP self._attributes = self.connection.get_all_lb_attributes(self.name) DCNL DCSP return self._attributes
def is_cross_zone_load_balancing(self, force=False): DCNL DCSP return self.get_attributes(force).cross_zone_load_balancing.enabled
def enable_cross_zone_load_balancing(self): DCNL DCSP success = self.connection.modify_lb_attribute(self.name, 'crossZoneLoadBalancing', True) DCNL DCSP if (success and self._attributes): DCNL DCSP  DCSP self._attributes.cross_zone_load_balancing.enabled = True DCNL DCSP return success
def disable_cross_zone_load_balancing(self): DCNL DCSP success = self.connection.modify_lb_attribute(self.name, 'crossZoneLoadBalancing', False) DCNL DCSP if (success and self._attributes): DCNL DCSP  DCSP self._attributes.cross_zone_load_balancing.enabled = False DCNL DCSP return success
def register_instances(self, instances): DCNL DCSP if isinstance(instances, six.string_types): DCNL DCSP  DCSP instances = [instances] DCNL DCSP new_instances = self.connection.register_instances(self.name, instances) DCNL DCSP self.instances = new_instances
def deregister_instances(self, instances): DCNL DCSP if isinstance(instances, six.string_types): DCNL DCSP  DCSP instances = [instances] DCNL DCSP new_instances = self.connection.deregister_instances(self.name, instances) DCNL DCSP self.instances = new_instances
def delete(self): DCNL DCSP return self.connection.delete_load_balancer(self.name)
def configure_health_check(self, health_check): DCNL DCSP return self.connection.configure_health_check(self.name, health_check)
def get_instance_health(self, instances=None): DCNL DCSP return self.connection.describe_instance_health(self.name, instances)
def delete_policy(self, policy_name): DCNL DCSP return self.connection.delete_lb_policy(self.name, policy_name)
def attach_subnets(self, subnets): DCNL DCSP if isinstance(subnets, six.string_types): DCNL DCSP  DCSP subnets = [subnets] DCNL DCSP new_subnets = self.connection.attach_lb_to_subnets(self.name, subnets) DCNL DCSP self.subnets = new_subnets
def detach_subnets(self, subnets): DCNL DCSP if isinstance(subnets, six.string_types): DCNL DCSP  DCSP subnets = [subnets] DCNL DCSP new_subnets = self.connection.detach_lb_from_subnets(self.name, subnets) DCNL DCSP self.subnets = new_subnets
def apply_security_groups(self, security_groups): DCNL DCSP if isinstance(security_groups, six.string_types): DCNL DCSP  DCSP security_groups = [security_groups] DCNL DCSP new_sgs = self.connection.apply_security_groups_to_lb(self.name, security_groups) DCNL DCSP self.security_groups = new_sgs
def update(self, validate=False, dry_run=False): DCNL DCSP rs = self.connection.get_all_network_interfaces([self.id], dry_run=dry_run) DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP self._update(rs[0]) DCNL DCSP elif validate: DCNL DCSP  DCSP raise ValueError(('%s DCSP is DCSP not DCSP a DCSP valid DCSP ENI DCSP ID' % self.id)) DCNL DCSP return self.status
def attach(self, instance_id, device_index, dry_run=False): DCNL DCSP return self.connection.attach_network_interface(self.id, instance_id, device_index, dry_run=dry_run)
def detach(self, force=False, dry_run=False): DCNL DCSP attachment_id = getattr(self.attachment, 'id', None) DCNL DCSP return self.connection.detach_network_interface(attachment_id, force, dry_run=dry_run)
def update(self, validate=False, dry_run=False): DCNL DCSP unfiltered_rs = self.connection.get_all_volumes([self.id], dry_run=dry_run) DCNL DCSP rs = [x for x in unfiltered_rs if (x.id == self.id)] DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP self._update(rs[0]) DCNL DCSP elif validate: DCNL DCSP  DCSP raise ValueError(('%s DCSP is DCSP not DCSP a DCSP valid DCSP Volume DCSP ID' % self.id)) DCNL DCSP return self.status
def delete(self, dry_run=False): DCNL DCSP return self.connection.delete_volume(self.id, dry_run=dry_run)
def attach(self, instance_id, device, dry_run=False): DCNL DCSP return self.connection.attach_volume(self.id, instance_id, device, dry_run=dry_run)
def detach(self, force=False, dry_run=False): DCNL DCSP instance_id = None DCNL DCSP if self.attach_data: DCNL DCSP  DCSP instance_id = self.attach_data.instance_id DCNL DCSP device = None DCNL DCSP if self.attach_data: DCNL DCSP  DCSP device = self.attach_data.device DCNL DCSP return self.connection.detach_volume(self.id, instance_id, device, force, dry_run=dry_run)
def create_snapshot(self, description=None, dry_run=False): DCNL DCSP return self.connection.create_snapshot(self.id, description, dry_run=dry_run)
def volume_state(self): DCNL DCSP return self.status
def attachment_state(self): DCNL DCSP state = None DCNL DCSP if self.attach_data: DCNL DCSP  DCSP state = self.attach_data.status DCNL DCSP return state
def snapshots(self, owner=None, restorable_by=None, dry_run=False): DCNL DCSP rs = self.connection.get_all_snapshots(owner=owner, restorable_by=restorable_by, dry_run=dry_run) DCNL DCSP mine = [] DCNL DCSP for snap in rs: DCNL DCSP  DCSP if (snap.volume_id == self.id): DCNL DCSP  DCSP  DCSP mine.append(snap) DCNL DCSP return mine
def update(self, validate=False, dry_run=False): DCNL DCSP rs = self.connection.get_all_snapshots([self.id], dry_run=dry_run) DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP self._update(rs[0]) DCNL DCSP elif validate: DCNL DCSP  DCSP raise ValueError(('%s DCSP is DCSP not DCSP a DCSP valid DCSP Snapshot DCSP ID' % self.id)) DCNL DCSP return self.progress
def create_volume(self, zone, size=None, volume_type=None, iops=None, dry_run=False): DCNL DCSP if isinstance(zone, Zone): DCNL DCSP  DCSP zone = zone.name DCNL DCSP return self.connection.create_volume(size, zone, self.id, volume_type, iops, self.encrypted, dry_run=dry_run)
def __init__(self, connection=None, id=None, state=None): DCNL DCSP self.connection = connection DCNL DCSP self.id = id DCNL DCSP self.state = state
def release(self, dry_run=False): DCNL DCSP if self.allocation_id: DCNL DCSP  DCSP return self.connection.release_address(allocation_id=self.allocation_id, dry_run=dry_run) DCNL DCSP else: DCNL DCSP  DCSP return self.connection.release_address(public_ip=self.public_ip, dry_run=dry_run)
def associate(self, instance_id=None, network_interface_id=None, private_ip_address=None, allow_reassociation=False, dry_run=False): DCNL DCSP if self.allocation_id: DCNL DCSP  DCSP return self.connection.associate_address(instance_id=instance_id, public_ip=self.public_ip, allocation_id=self.allocation_id, network_interface_id=network_interface_id, private_ip_address=private_ip_address, allow_reassociation=allow_reassociation, dry_run=dry_run) DCNL DCSP return self.connection.associate_address(instance_id=instance_id, public_ip=self.public_ip, network_interface_id=network_interface_id, private_ip_address=private_ip_address, allow_reassociation=allow_reassociation, dry_run=dry_run)
def disassociate(self, dry_run=False): DCNL DCSP if self.association_id: DCNL DCSP  DCSP return self.connection.disassociate_address(association_id=self.association_id, dry_run=dry_run) DCNL DCSP else: DCNL DCSP  DCSP return self.connection.disassociate_address(public_ip=self.public_ip, dry_run=dry_run)
def update(self, validate=False, dry_run=False): DCNL DCSP rs = self.connection.get_all_images([self.id], dry_run=dry_run) DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP img = rs[0] DCNL DCSP  DCSP if (img.id == self.id): DCNL DCSP  DCSP  DCSP self._update(img) DCNL DCSP elif validate: DCNL DCSP  DCSP raise ValueError(('%s DCSP is DCSP not DCSP a DCSP valid DCSP Image DCSP ID' % self.id)) DCNL DCSP return self.state
def run(self, min_count=1, max_count=1, key_name=None, security_groups=None, user_data=None, addressing_type=None, instance_type='m1.small', placement=None, kernel_id=None, ramdisk_id=None, monitoring_enabled=False, subnet_id=None, block_device_map=None, disable_api_termination=False, instance_initiated_shutdown_behavior=None, private_ip_address=None, placement_group=None, security_group_ids=None, additional_info=None, instance_profile_name=None, instance_profile_arn=None, tenancy=None, dry_run=False): DCNL DCSP return self.connection.run_instances(self.id, min_count, max_count, key_name, security_groups, user_data, addressing_type, instance_type, placement, kernel_id, ramdisk_id, monitoring_enabled, subnet_id, block_device_map, disable_api_termination, instance_initiated_shutdown_behavior, private_ip_address, placement_group, security_group_ids=security_group_ids, additional_info=additional_info, instance_profile_name=instance_profile_name, instance_profile_arn=instance_profile_arn, tenancy=tenancy, dry_run=dry_run)
def update(self, validate=False, dry_run=False): DCNL DCSP rs = self.connection.get_all_reservations([self.id], dry_run=dry_run) DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP r = rs[0] DCNL DCSP  DCSP for i in r.instances: DCNL DCSP  DCSP  DCSP if (i.id == self.id): DCNL DCSP  DCSP  DCSP  DCSP self._update(i) DCNL DCSP elif validate: DCNL DCSP  DCSP raise ValueError(('%s DCSP is DCSP not DCSP a DCSP valid DCSP Instance DCSP ID' % self.id)) DCNL DCSP return self.state
def terminate(self, dry_run=False): DCNL DCSP rs = self.connection.terminate_instances([self.id], dry_run=dry_run) DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP self._update(rs[0])
def stop(self, force=False, dry_run=False): DCNL DCSP rs = self.connection.stop_instances([self.id], force, dry_run=dry_run) DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP self._update(rs[0])
def start(self, dry_run=False): DCNL DCSP rs = self.connection.start_instances([self.id], dry_run=dry_run) DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP self._update(rs[0])
def get_console_output(self, dry_run=False): DCNL DCSP return self.connection.get_console_output(self.id, dry_run=dry_run)
def use_ip(self, ip_address, dry_run=False): DCNL DCSP if isinstance(ip_address, Address): DCNL DCSP  DCSP ip_address = ip_address.public_ip DCNL DCSP return self.connection.associate_address(self.id, ip_address, dry_run=dry_run)
def get_attribute(self, attribute, dry_run=False): DCNL DCSP return self.connection.get_instance_attribute(self.id, attribute, dry_run=dry_run)
def modify_attribute(self, attribute, value, dry_run=False): DCNL DCSP return self.connection.modify_instance_attribute(self.id, attribute, value, dry_run=dry_run)
def reset_attribute(self, attribute, dry_run=False): DCNL DCSP return self.connection.reset_instance_attribute(self.id, attribute, dry_run=dry_run)
def create_image(self, name, description=None, no_reboot=False, dry_run=False): DCNL DCSP return self.connection.create_image(self.id, name, description, no_reboot, dry_run=dry_run)
def add_rule(self, ip_protocol, from_port, to_port, src_group_name, src_group_owner_id, cidr_ip, src_group_group_id, dry_run=False): DCNL DCSP rule = IPPermissions(self) DCNL DCSP rule.ip_protocol = ip_protocol DCNL DCSP rule.from_port = from_port DCNL DCSP rule.to_port = to_port DCNL DCSP self.rules.append(rule) DCNL DCSP rule.add_grant(src_group_name, src_group_owner_id, cidr_ip, src_group_group_id, dry_run=dry_run)
def remove_rule(self, ip_protocol, from_port, to_port, src_group_name, src_group_owner_id, cidr_ip, src_group_group_id, dry_run=False): DCNL DCSP if (not self.rules): DCNL DCSP  DCSP raise ValueError('The DCSP security DCSP group DCSP has DCSP no DCSP rules') DCNL DCSP target_rule = None DCNL DCSP for rule in self.rules: DCNL DCSP  DCSP if (rule.ip_protocol == ip_protocol): DCNL DCSP  DCSP  DCSP if (rule.from_port == from_port): DCNL DCSP  DCSP  DCSP  DCSP if (rule.to_port == to_port): DCNL DCSP  DCSP  DCSP  DCSP  DCSP target_rule = rule DCNL DCSP  DCSP  DCSP  DCSP  DCSP target_grant = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP for grant in rule.grants: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((grant.name == src_group_name) or (grant.group_id == src_group_group_id)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (grant.owner_id == src_group_owner_id): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (grant.cidr_ip == cidr_ip): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP target_grant = grant DCNL DCSP  DCSP  DCSP  DCSP  DCSP if target_grant: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rule.grants.remove(target_grant) DCNL DCSP  DCSP if (len(rule.grants) == 0): DCNL DCSP  DCSP  DCSP self.rules.remove(target_rule)
def authorize(self, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, src_group=None, dry_run=False): DCNL DCSP group_name = None DCNL DCSP if (not self.vpc_id): DCNL DCSP  DCSP group_name = self.name DCNL DCSP group_id = None DCNL DCSP if self.vpc_id: DCNL DCSP  DCSP group_id = self.id DCNL DCSP src_group_name = None DCNL DCSP src_group_owner_id = None DCNL DCSP src_group_group_id = None DCNL DCSP if src_group: DCNL DCSP  DCSP cidr_ip = None DCNL DCSP  DCSP src_group_owner_id = src_group.owner_id DCNL DCSP  DCSP if (not self.vpc_id): DCNL DCSP  DCSP  DCSP src_group_name = src_group.name DCNL DCSP  DCSP elif hasattr(src_group, 'group_id'): DCNL DCSP  DCSP  DCSP src_group_group_id = src_group.group_id DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP src_group_group_id = src_group.id DCNL DCSP status = self.connection.authorize_security_group(group_name, src_group_name, src_group_owner_id, ip_protocol, from_port, to_port, cidr_ip, group_id, src_group_group_id, dry_run=dry_run) DCNL DCSP if status: DCNL DCSP  DCSP if (not isinstance(cidr_ip, list)): DCNL DCSP  DCSP  DCSP cidr_ip = [cidr_ip] DCNL DCSP  DCSP for single_cidr_ip in cidr_ip: DCNL DCSP  DCSP  DCSP self.add_rule(ip_protocol, from_port, to_port, src_group_name, src_group_owner_id, single_cidr_ip, src_group_group_id, dry_run=dry_run) DCNL DCSP return status
def copy_to_region(self, region, name=None, dry_run=False): DCNL DCSP if (region.name == self.region): DCNL DCSP  DCSP raise BotoClientError('Unable DCSP to DCSP copy DCSP to DCSP the DCSP same DCSP Region') DCNL DCSP conn_params = self.connection.get_params() DCNL DCSP rconn = region.connect(**conn_params) DCNL DCSP sg = rconn.create_security_group((name or self.name), self.description, dry_run=dry_run) DCNL DCSP source_groups = [] DCNL DCSP for rule in self.rules: DCNL DCSP  DCSP for grant in rule.grants: DCNL DCSP  DCSP  DCSP grant_nom = (grant.name or grant.group_id) DCNL DCSP  DCSP  DCSP if grant_nom: DCNL DCSP  DCSP  DCSP  DCSP if (grant_nom not in source_groups): DCNL DCSP  DCSP  DCSP  DCSP  DCSP source_groups.append(grant_nom) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sg.authorize(None, None, None, None, grant, dry_run=dry_run) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sg.authorize(rule.ip_protocol, rule.from_port, rule.to_port, grant.cidr_ip, dry_run=dry_run) DCNL DCSP return sg
def instances(self, dry_run=False): DCNL DCSP rs = [] DCNL DCSP if self.vpc_id: DCNL DCSP  DCSP rs.extend(self.connection.get_all_reservations(filters={'instance.group-id': self.id}, dry_run=dry_run)) DCNL DCSP else: DCNL DCSP  DCSP rs.extend(self.connection.get_all_reservations(filters={'group-id': self.id}, dry_run=dry_run)) DCNL DCSP instances = [i for r in rs for i in r.instances] DCNL DCSP return instances
def assign_instance(self, instance_id, layer_ids): DCNL DCSP params = {'InstanceId': instance_id, 'LayerIds': layer_ids} DCNL DCSP return self.make_request(action='AssignInstance', body=json.dumps(params))
def assign_volume(self, volume_id, instance_id=None): DCNL DCSP params = {'VolumeId': volume_id} DCNL DCSP if (instance_id is not None): DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP return self.make_request(action='AssignVolume', body=json.dumps(params))
def associate_elastic_ip(self, elastic_ip, instance_id=None): DCNL DCSP params = {'ElasticIp': elastic_ip} DCNL DCSP if (instance_id is not None): DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP return self.make_request(action='AssociateElasticIp', body=json.dumps(params))
def attach_elastic_load_balancer(self, elastic_load_balancer_name, layer_id): DCNL DCSP params = {'ElasticLoadBalancerName': elastic_load_balancer_name, 'LayerId': layer_id} DCNL DCSP return self.make_request(action='AttachElasticLoadBalancer', body=json.dumps(params))
def clone_stack(self, source_stack_id, service_role_arn, name=None, region=None, vpc_id=None, attributes=None, default_instance_profile_arn=None, default_os=None, hostname_theme=None, default_availability_zone=None, default_subnet_id=None, custom_json=None, configuration_manager=None, chef_configuration=None, use_custom_cookbooks=None, use_opsworks_security_groups=None, custom_cookbooks_source=None, default_ssh_key_name=None, clone_permissions=None, clone_app_ids=None, default_root_device_type=None): DCNL DCSP params = {'SourceStackId': source_stack_id, 'ServiceRoleArn': service_role_arn} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (region is not None): DCNL DCSP  DCSP params['Region'] = region DCNL DCSP if (vpc_id is not None): DCNL DCSP  DCSP params['VpcId'] = vpc_id DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP params['Attributes'] = attributes DCNL DCSP if (default_instance_profile_arn is not None): DCNL DCSP  DCSP params['DefaultInstanceProfileArn'] = default_instance_profile_arn DCNL DCSP if (default_os is not None): DCNL DCSP  DCSP params['DefaultOs'] = default_os DCNL DCSP if (hostname_theme is not None): DCNL DCSP  DCSP params['HostnameTheme'] = hostname_theme DCNL DCSP if (default_availability_zone is not None): DCNL DCSP  DCSP params['DefaultAvailabilityZone'] = default_availability_zone DCNL DCSP if (default_subnet_id is not None): DCNL DCSP  DCSP params['DefaultSubnetId'] = default_subnet_id DCNL DCSP if (custom_json is not None): DCNL DCSP  DCSP params['CustomJson'] = custom_json DCNL DCSP if (configuration_manager is not None): DCNL DCSP  DCSP params['ConfigurationManager'] = configuration_manager DCNL DCSP if (chef_configuration is not None): DCNL DCSP  DCSP params['ChefConfiguration'] = chef_configuration DCNL DCSP if (use_custom_cookbooks is not None): DCNL DCSP  DCSP params['UseCustomCookbooks'] = use_custom_cookbooks DCNL DCSP if (use_opsworks_security_groups is not None): DCNL DCSP  DCSP params['UseOpsworksSecurityGroups'] = use_opsworks_security_groups DCNL DCSP if (custom_cookbooks_source is not None): DCNL DCSP  DCSP params['CustomCookbooksSource'] = custom_cookbooks_source DCNL DCSP if (default_ssh_key_name is not None): DCNL DCSP  DCSP params['DefaultSshKeyName'] = default_ssh_key_name DCNL DCSP if (clone_permissions is not None): DCNL DCSP  DCSP params['ClonePermissions'] = clone_permissions DCNL DCSP if (clone_app_ids is not None): DCNL DCSP  DCSP params['CloneAppIds'] = clone_app_ids DCNL DCSP if (default_root_device_type is not None): DCNL DCSP  DCSP params['DefaultRootDeviceType'] = default_root_device_type DCNL DCSP return self.make_request(action='CloneStack', body=json.dumps(params))
def create_app(self, stack_id, name, type, shortname=None, description=None, data_sources=None, app_source=None, domains=None, enable_ssl=None, ssl_configuration=None, attributes=None, environment=None): DCNL DCSP params = {'StackId': stack_id, 'Name': name, 'Type': type} DCNL DCSP if (shortname is not None): DCNL DCSP  DCSP params['Shortname'] = shortname DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if (data_sources is not None): DCNL DCSP  DCSP params['DataSources'] = data_sources DCNL DCSP if (app_source is not None): DCNL DCSP  DCSP params['AppSource'] = app_source DCNL DCSP if (domains is not None): DCNL DCSP  DCSP params['Domains'] = domains DCNL DCSP if (enable_ssl is not None): DCNL DCSP  DCSP params['EnableSsl'] = enable_ssl DCNL DCSP if (ssl_configuration is not None): DCNL DCSP  DCSP params['SslConfiguration'] = ssl_configuration DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP params['Attributes'] = attributes DCNL DCSP if (environment is not None): DCNL DCSP  DCSP params['Environment'] = environment DCNL DCSP return self.make_request(action='CreateApp', body=json.dumps(params))
def create_deployment(self, stack_id, command, app_id=None, instance_ids=None, comment=None, custom_json=None): DCNL DCSP params = {'StackId': stack_id, 'Command': command} DCNL DCSP if (app_id is not None): DCNL DCSP  DCSP params['AppId'] = app_id DCNL DCSP if (instance_ids is not None): DCNL DCSP  DCSP params['InstanceIds'] = instance_ids DCNL DCSP if (comment is not None): DCNL DCSP  DCSP params['Comment'] = comment DCNL DCSP if (custom_json is not None): DCNL DCSP  DCSP params['CustomJson'] = custom_json DCNL DCSP return self.make_request(action='CreateDeployment', body=json.dumps(params))
def create_instance(self, stack_id, layer_ids, instance_type, auto_scaling_type=None, hostname=None, os=None, ami_id=None, ssh_key_name=None, availability_zone=None, virtualization_type=None, subnet_id=None, architecture=None, root_device_type=None, install_updates_on_boot=None, ebs_optimized=None): DCNL DCSP params = {'StackId': stack_id, 'LayerIds': layer_ids, 'InstanceType': instance_type} DCNL DCSP if (auto_scaling_type is not None): DCNL DCSP  DCSP params['AutoScalingType'] = auto_scaling_type DCNL DCSP if (hostname is not None): DCNL DCSP  DCSP params['Hostname'] = hostname DCNL DCSP if (os is not None): DCNL DCSP  DCSP params['Os'] = os DCNL DCSP if (ami_id is not None): DCNL DCSP  DCSP params['AmiId'] = ami_id DCNL DCSP if (ssh_key_name is not None): DCNL DCSP  DCSP params['SshKeyName'] = ssh_key_name DCNL DCSP if (availability_zone is not None): DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (virtualization_type is not None): DCNL DCSP  DCSP params['VirtualizationType'] = virtualization_type DCNL DCSP if (subnet_id is not None): DCNL DCSP  DCSP params['SubnetId'] = subnet_id DCNL DCSP if (architecture is not None): DCNL DCSP  DCSP params['Architecture'] = architecture DCNL DCSP if (root_device_type is not None): DCNL DCSP  DCSP params['RootDeviceType'] = root_device_type DCNL DCSP if (install_updates_on_boot is not None): DCNL DCSP  DCSP params['InstallUpdatesOnBoot'] = install_updates_on_boot DCNL DCSP if (ebs_optimized is not None): DCNL DCSP  DCSP params['EbsOptimized'] = ebs_optimized DCNL DCSP return self.make_request(action='CreateInstance', body=json.dumps(params))
def create_layer(self, stack_id, type, name, shortname, attributes=None, custom_instance_profile_arn=None, custom_security_group_ids=None, packages=None, volume_configurations=None, enable_auto_healing=None, auto_assign_elastic_ips=None, auto_assign_public_ips=None, custom_recipes=None, install_updates_on_boot=None, use_ebs_optimized_instances=None, lifecycle_event_configuration=None): DCNL DCSP params = {'StackId': stack_id, 'Type': type, 'Name': name, 'Shortname': shortname} DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP params['Attributes'] = attributes DCNL DCSP if (custom_instance_profile_arn is not None): DCNL DCSP  DCSP params['CustomInstanceProfileArn'] = custom_instance_profile_arn DCNL DCSP if (custom_security_group_ids is not None): DCNL DCSP  DCSP params['CustomSecurityGroupIds'] = custom_security_group_ids DCNL DCSP if (packages is not None): DCNL DCSP  DCSP params['Packages'] = packages DCNL DCSP if (volume_configurations is not None): DCNL DCSP  DCSP params['VolumeConfigurations'] = volume_configurations DCNL DCSP if (enable_auto_healing is not None): DCNL DCSP  DCSP params['EnableAutoHealing'] = enable_auto_healing DCNL DCSP if (auto_assign_elastic_ips is not None): DCNL DCSP  DCSP params['AutoAssignElasticIps'] = auto_assign_elastic_ips DCNL DCSP if (auto_assign_public_ips is not None): DCNL DCSP  DCSP params['AutoAssignPublicIps'] = auto_assign_public_ips DCNL DCSP if (custom_recipes is not None): DCNL DCSP  DCSP params['CustomRecipes'] = custom_recipes DCNL DCSP if (install_updates_on_boot is not None): DCNL DCSP  DCSP params['InstallUpdatesOnBoot'] = install_updates_on_boot DCNL DCSP if (use_ebs_optimized_instances is not None): DCNL DCSP  DCSP params['UseEbsOptimizedInstances'] = use_ebs_optimized_instances DCNL DCSP if (lifecycle_event_configuration is not None): DCNL DCSP  DCSP params['LifecycleEventConfiguration'] = lifecycle_event_configuration DCNL DCSP return self.make_request(action='CreateLayer', body=json.dumps(params))
def create_stack(self, name, region, service_role_arn, default_instance_profile_arn, vpc_id=None, attributes=None, default_os=None, hostname_theme=None, default_availability_zone=None, default_subnet_id=None, custom_json=None, configuration_manager=None, chef_configuration=None, use_custom_cookbooks=None, use_opsworks_security_groups=None, custom_cookbooks_source=None, default_ssh_key_name=None, default_root_device_type=None): DCNL DCSP params = {'Name': name, 'Region': region, 'ServiceRoleArn': service_role_arn, 'DefaultInstanceProfileArn': default_instance_profile_arn} DCNL DCSP if (vpc_id is not None): DCNL DCSP  DCSP params['VpcId'] = vpc_id DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP params['Attributes'] = attributes DCNL DCSP if (default_os is not None): DCNL DCSP  DCSP params['DefaultOs'] = default_os DCNL DCSP if (hostname_theme is not None): DCNL DCSP  DCSP params['HostnameTheme'] = hostname_theme DCNL DCSP if (default_availability_zone is not None): DCNL DCSP  DCSP params['DefaultAvailabilityZone'] = default_availability_zone DCNL DCSP if (default_subnet_id is not None): DCNL DCSP  DCSP params['DefaultSubnetId'] = default_subnet_id DCNL DCSP if (custom_json is not None): DCNL DCSP  DCSP params['CustomJson'] = custom_json DCNL DCSP if (configuration_manager is not None): DCNL DCSP  DCSP params['ConfigurationManager'] = configuration_manager DCNL DCSP if (chef_configuration is not None): DCNL DCSP  DCSP params['ChefConfiguration'] = chef_configuration DCNL DCSP if (use_custom_cookbooks is not None): DCNL DCSP  DCSP params['UseCustomCookbooks'] = use_custom_cookbooks DCNL DCSP if (use_opsworks_security_groups is not None): DCNL DCSP  DCSP params['UseOpsworksSecurityGroups'] = use_opsworks_security_groups DCNL DCSP if (custom_cookbooks_source is not None): DCNL DCSP  DCSP params['CustomCookbooksSource'] = custom_cookbooks_source DCNL DCSP if (default_ssh_key_name is not None): DCNL DCSP  DCSP params['DefaultSshKeyName'] = default_ssh_key_name DCNL DCSP if (default_root_device_type is not None): DCNL DCSP  DCSP params['DefaultRootDeviceType'] = default_root_device_type DCNL DCSP return self.make_request(action='CreateStack', body=json.dumps(params))
def create_user_profile(self, iam_user_arn, ssh_username=None, ssh_public_key=None, allow_self_management=None): DCNL DCSP params = {'IamUserArn': iam_user_arn} DCNL DCSP if (ssh_username is not None): DCNL DCSP  DCSP params['SshUsername'] = ssh_username DCNL DCSP if (ssh_public_key is not None): DCNL DCSP  DCSP params['SshPublicKey'] = ssh_public_key DCNL DCSP if (allow_self_management is not None): DCNL DCSP  DCSP params['AllowSelfManagement'] = allow_self_management DCNL DCSP return self.make_request(action='CreateUserProfile', body=json.dumps(params))
def delete_app(self, app_id): DCNL DCSP params = {'AppId': app_id} DCNL DCSP return self.make_request(action='DeleteApp', body=json.dumps(params))
def delete_instance(self, instance_id, delete_elastic_ip=None, delete_volumes=None): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP if (delete_elastic_ip is not None): DCNL DCSP  DCSP params['DeleteElasticIp'] = delete_elastic_ip DCNL DCSP if (delete_volumes is not None): DCNL DCSP  DCSP params['DeleteVolumes'] = delete_volumes DCNL DCSP return self.make_request(action='DeleteInstance', body=json.dumps(params))
def delete_layer(self, layer_id): DCNL DCSP params = {'LayerId': layer_id} DCNL DCSP return self.make_request(action='DeleteLayer', body=json.dumps(params))
def delete_stack(self, stack_id): DCNL DCSP params = {'StackId': stack_id} DCNL DCSP return self.make_request(action='DeleteStack', body=json.dumps(params))
def delete_user_profile(self, iam_user_arn): DCNL DCSP params = {'IamUserArn': iam_user_arn} DCNL DCSP return self.make_request(action='DeleteUserProfile', body=json.dumps(params))
def deregister_elastic_ip(self, elastic_ip): DCNL DCSP params = {'ElasticIp': elastic_ip} DCNL DCSP return self.make_request(action='DeregisterElasticIp', body=json.dumps(params))
def deregister_instance(self, instance_id): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP return self.make_request(action='DeregisterInstance', body=json.dumps(params))
def deregister_rds_db_instance(self, rds_db_instance_arn): DCNL DCSP params = {'RdsDbInstanceArn': rds_db_instance_arn} DCNL DCSP return self.make_request(action='DeregisterRdsDbInstance', body=json.dumps(params))
def deregister_volume(self, volume_id): DCNL DCSP params = {'VolumeId': volume_id} DCNL DCSP return self.make_request(action='DeregisterVolume', body=json.dumps(params))
def describe_apps(self, stack_id=None, app_ids=None): DCNL DCSP params = {} DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP if (app_ids is not None): DCNL DCSP  DCSP params['AppIds'] = app_ids DCNL DCSP return self.make_request(action='DescribeApps', body=json.dumps(params))
def describe_commands(self, deployment_id=None, instance_id=None, command_ids=None): DCNL DCSP params = {} DCNL DCSP if (deployment_id is not None): DCNL DCSP  DCSP params['DeploymentId'] = deployment_id DCNL DCSP if (instance_id is not None): DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP if (command_ids is not None): DCNL DCSP  DCSP params['CommandIds'] = command_ids DCNL DCSP return self.make_request(action='DescribeCommands', body=json.dumps(params))
def describe_deployments(self, stack_id=None, app_id=None, deployment_ids=None): DCNL DCSP params = {} DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP if (app_id is not None): DCNL DCSP  DCSP params['AppId'] = app_id DCNL DCSP if (deployment_ids is not None): DCNL DCSP  DCSP params['DeploymentIds'] = deployment_ids DCNL DCSP return self.make_request(action='DescribeDeployments', body=json.dumps(params))
def describe_elastic_ips(self, instance_id=None, stack_id=None, ips=None): DCNL DCSP params = {} DCNL DCSP if (instance_id is not None): DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP if (ips is not None): DCNL DCSP  DCSP params['Ips'] = ips DCNL DCSP return self.make_request(action='DescribeElasticIps', body=json.dumps(params))
def describe_elastic_load_balancers(self, stack_id=None, layer_ids=None): DCNL DCSP params = {} DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP if (layer_ids is not None): DCNL DCSP  DCSP params['LayerIds'] = layer_ids DCNL DCSP return self.make_request(action='DescribeElasticLoadBalancers', body=json.dumps(params))
def describe_instances(self, stack_id=None, layer_id=None, instance_ids=None): DCNL DCSP params = {} DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP if (layer_id is not None): DCNL DCSP  DCSP params['LayerId'] = layer_id DCNL DCSP if (instance_ids is not None): DCNL DCSP  DCSP params['InstanceIds'] = instance_ids DCNL DCSP return self.make_request(action='DescribeInstances', body=json.dumps(params))
def describe_layers(self, stack_id=None, layer_ids=None): DCNL DCSP params = {} DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP if (layer_ids is not None): DCNL DCSP  DCSP params['LayerIds'] = layer_ids DCNL DCSP return self.make_request(action='DescribeLayers', body=json.dumps(params))
def describe_load_based_auto_scaling(self, layer_ids): DCNL DCSP params = {'LayerIds': layer_ids} DCNL DCSP return self.make_request(action='DescribeLoadBasedAutoScaling', body=json.dumps(params))
def describe_my_user_profile(self): DCNL DCSP params = {} DCNL DCSP return self.make_request(action='DescribeMyUserProfile', body=json.dumps(params))
def describe_permissions(self, iam_user_arn=None, stack_id=None): DCNL DCSP params = {} DCNL DCSP if (iam_user_arn is not None): DCNL DCSP  DCSP params['IamUserArn'] = iam_user_arn DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP return self.make_request(action='DescribePermissions', body=json.dumps(params))
def describe_raid_arrays(self, instance_id=None, stack_id=None, raid_array_ids=None): DCNL DCSP params = {} DCNL DCSP if (instance_id is not None): DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP if (raid_array_ids is not None): DCNL DCSP  DCSP params['RaidArrayIds'] = raid_array_ids DCNL DCSP return self.make_request(action='DescribeRaidArrays', body=json.dumps(params))
def describe_rds_db_instances(self, stack_id, rds_db_instance_arns=None): DCNL DCSP params = {'StackId': stack_id} DCNL DCSP if (rds_db_instance_arns is not None): DCNL DCSP  DCSP params['RdsDbInstanceArns'] = rds_db_instance_arns DCNL DCSP return self.make_request(action='DescribeRdsDbInstances', body=json.dumps(params))
def describe_service_errors(self, stack_id=None, instance_id=None, service_error_ids=None): DCNL DCSP params = {} DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP if (instance_id is not None): DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP if (service_error_ids is not None): DCNL DCSP  DCSP params['ServiceErrorIds'] = service_error_ids DCNL DCSP return self.make_request(action='DescribeServiceErrors', body=json.dumps(params))
def describe_stack_provisioning_parameters(self, stack_id): DCNL DCSP params = {'StackId': stack_id} DCNL DCSP return self.make_request(action='DescribeStackProvisioningParameters', body=json.dumps(params))
def describe_stack_summary(self, stack_id): DCNL DCSP params = {'StackId': stack_id} DCNL DCSP return self.make_request(action='DescribeStackSummary', body=json.dumps(params))
def describe_stacks(self, stack_ids=None): DCNL DCSP params = {} DCNL DCSP if (stack_ids is not None): DCNL DCSP  DCSP params['StackIds'] = stack_ids DCNL DCSP return self.make_request(action='DescribeStacks', body=json.dumps(params))
def describe_time_based_auto_scaling(self, instance_ids): DCNL DCSP params = {'InstanceIds': instance_ids} DCNL DCSP return self.make_request(action='DescribeTimeBasedAutoScaling', body=json.dumps(params))
def describe_user_profiles(self, iam_user_arns=None): DCNL DCSP params = {} DCNL DCSP if (iam_user_arns is not None): DCNL DCSP  DCSP params['IamUserArns'] = iam_user_arns DCNL DCSP return self.make_request(action='DescribeUserProfiles', body=json.dumps(params))
def describe_volumes(self, instance_id=None, stack_id=None, raid_array_id=None, volume_ids=None): DCNL DCSP params = {} DCNL DCSP if (instance_id is not None): DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP if (stack_id is not None): DCNL DCSP  DCSP params['StackId'] = stack_id DCNL DCSP if (raid_array_id is not None): DCNL DCSP  DCSP params['RaidArrayId'] = raid_array_id DCNL DCSP if (volume_ids is not None): DCNL DCSP  DCSP params['VolumeIds'] = volume_ids DCNL DCSP return self.make_request(action='DescribeVolumes', body=json.dumps(params))
def detach_elastic_load_balancer(self, elastic_load_balancer_name, layer_id): DCNL DCSP params = {'ElasticLoadBalancerName': elastic_load_balancer_name, 'LayerId': layer_id} DCNL DCSP return self.make_request(action='DetachElasticLoadBalancer', body=json.dumps(params))
def disassociate_elastic_ip(self, elastic_ip): DCNL DCSP params = {'ElasticIp': elastic_ip} DCNL DCSP return self.make_request(action='DisassociateElasticIp', body=json.dumps(params))
def get_hostname_suggestion(self, layer_id): DCNL DCSP params = {'LayerId': layer_id} DCNL DCSP return self.make_request(action='GetHostnameSuggestion', body=json.dumps(params))
def reboot_instance(self, instance_id): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP return self.make_request(action='RebootInstance', body=json.dumps(params))
def register_elastic_ip(self, elastic_ip, stack_id): DCNL DCSP params = {'ElasticIp': elastic_ip, 'StackId': stack_id} DCNL DCSP return self.make_request(action='RegisterElasticIp', body=json.dumps(params))
def register_instance(self, stack_id, hostname=None, public_ip=None, private_ip=None, rsa_public_key=None, rsa_public_key_fingerprint=None, instance_identity=None): DCNL DCSP params = {'StackId': stack_id} DCNL DCSP if (hostname is not None): DCNL DCSP  DCSP params['Hostname'] = hostname DCNL DCSP if (public_ip is not None): DCNL DCSP  DCSP params['PublicIp'] = public_ip DCNL DCSP if (private_ip is not None): DCNL DCSP  DCSP params['PrivateIp'] = private_ip DCNL DCSP if (rsa_public_key is not None): DCNL DCSP  DCSP params['RsaPublicKey'] = rsa_public_key DCNL DCSP if (rsa_public_key_fingerprint is not None): DCNL DCSP  DCSP params['RsaPublicKeyFingerprint'] = rsa_public_key_fingerprint DCNL DCSP if (instance_identity is not None): DCNL DCSP  DCSP params['InstanceIdentity'] = instance_identity DCNL DCSP return self.make_request(action='RegisterInstance', body=json.dumps(params))
def register_rds_db_instance(self, stack_id, rds_db_instance_arn, db_user, db_password): DCNL DCSP params = {'StackId': stack_id, 'RdsDbInstanceArn': rds_db_instance_arn, 'DbUser': db_user, 'DbPassword': db_password} DCNL DCSP return self.make_request(action='RegisterRdsDbInstance', body=json.dumps(params))
def register_volume(self, stack_id, ec_2_volume_id=None): DCNL DCSP params = {'StackId': stack_id} DCNL DCSP if (ec_2_volume_id is not None): DCNL DCSP  DCSP params['Ec2VolumeId'] = ec_2_volume_id DCNL DCSP return self.make_request(action='RegisterVolume', body=json.dumps(params))
def set_load_based_auto_scaling(self, layer_id, enable=None, up_scaling=None, down_scaling=None): DCNL DCSP params = {'LayerId': layer_id} DCNL DCSP if (enable is not None): DCNL DCSP  DCSP params['Enable'] = enable DCNL DCSP if (up_scaling is not None): DCNL DCSP  DCSP params['UpScaling'] = up_scaling DCNL DCSP if (down_scaling is not None): DCNL DCSP  DCSP params['DownScaling'] = down_scaling DCNL DCSP return self.make_request(action='SetLoadBasedAutoScaling', body=json.dumps(params))
def set_permission(self, stack_id, iam_user_arn, allow_ssh=None, allow_sudo=None, level=None): DCNL DCSP params = {'StackId': stack_id, 'IamUserArn': iam_user_arn} DCNL DCSP if (allow_ssh is not None): DCNL DCSP  DCSP params['AllowSsh'] = allow_ssh DCNL DCSP if (allow_sudo is not None): DCNL DCSP  DCSP params['AllowSudo'] = allow_sudo DCNL DCSP if (level is not None): DCNL DCSP  DCSP params['Level'] = level DCNL DCSP return self.make_request(action='SetPermission', body=json.dumps(params))
def set_time_based_auto_scaling(self, instance_id, auto_scaling_schedule=None): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP if (auto_scaling_schedule is not None): DCNL DCSP  DCSP params['AutoScalingSchedule'] = auto_scaling_schedule DCNL DCSP return self.make_request(action='SetTimeBasedAutoScaling', body=json.dumps(params))
def start_instance(self, instance_id): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP return self.make_request(action='StartInstance', body=json.dumps(params))
def start_stack(self, stack_id): DCNL DCSP params = {'StackId': stack_id} DCNL DCSP return self.make_request(action='StartStack', body=json.dumps(params))
def stop_instance(self, instance_id): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP return self.make_request(action='StopInstance', body=json.dumps(params))
def stop_stack(self, stack_id): DCNL DCSP params = {'StackId': stack_id} DCNL DCSP return self.make_request(action='StopStack', body=json.dumps(params))
def unassign_instance(self, instance_id): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP return self.make_request(action='UnassignInstance', body=json.dumps(params))
def unassign_volume(self, volume_id): DCNL DCSP params = {'VolumeId': volume_id} DCNL DCSP return self.make_request(action='UnassignVolume', body=json.dumps(params))
def update_app(self, app_id, name=None, description=None, data_sources=None, type=None, app_source=None, domains=None, enable_ssl=None, ssl_configuration=None, attributes=None, environment=None): DCNL DCSP params = {'AppId': app_id} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if (data_sources is not None): DCNL DCSP  DCSP params['DataSources'] = data_sources DCNL DCSP if (type is not None): DCNL DCSP  DCSP params['Type'] = type DCNL DCSP if (app_source is not None): DCNL DCSP  DCSP params['AppSource'] = app_source DCNL DCSP if (domains is not None): DCNL DCSP  DCSP params['Domains'] = domains DCNL DCSP if (enable_ssl is not None): DCNL DCSP  DCSP params['EnableSsl'] = enable_ssl DCNL DCSP if (ssl_configuration is not None): DCNL DCSP  DCSP params['SslConfiguration'] = ssl_configuration DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP params['Attributes'] = attributes DCNL DCSP if (environment is not None): DCNL DCSP  DCSP params['Environment'] = environment DCNL DCSP return self.make_request(action='UpdateApp', body=json.dumps(params))
def update_elastic_ip(self, elastic_ip, name=None): DCNL DCSP params = {'ElasticIp': elastic_ip} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP return self.make_request(action='UpdateElasticIp', body=json.dumps(params))
def update_instance(self, instance_id, layer_ids=None, instance_type=None, auto_scaling_type=None, hostname=None, os=None, ami_id=None, ssh_key_name=None, architecture=None, install_updates_on_boot=None, ebs_optimized=None): DCNL DCSP params = {'InstanceId': instance_id} DCNL DCSP if (layer_ids is not None): DCNL DCSP  DCSP params['LayerIds'] = layer_ids DCNL DCSP if (instance_type is not None): DCNL DCSP  DCSP params['InstanceType'] = instance_type DCNL DCSP if (auto_scaling_type is not None): DCNL DCSP  DCSP params['AutoScalingType'] = auto_scaling_type DCNL DCSP if (hostname is not None): DCNL DCSP  DCSP params['Hostname'] = hostname DCNL DCSP if (os is not None): DCNL DCSP  DCSP params['Os'] = os DCNL DCSP if (ami_id is not None): DCNL DCSP  DCSP params['AmiId'] = ami_id DCNL DCSP if (ssh_key_name is not None): DCNL DCSP  DCSP params['SshKeyName'] = ssh_key_name DCNL DCSP if (architecture is not None): DCNL DCSP  DCSP params['Architecture'] = architecture DCNL DCSP if (install_updates_on_boot is not None): DCNL DCSP  DCSP params['InstallUpdatesOnBoot'] = install_updates_on_boot DCNL DCSP if (ebs_optimized is not None): DCNL DCSP  DCSP params['EbsOptimized'] = ebs_optimized DCNL DCSP return self.make_request(action='UpdateInstance', body=json.dumps(params))
def update_layer(self, layer_id, name=None, shortname=None, attributes=None, custom_instance_profile_arn=None, custom_security_group_ids=None, packages=None, volume_configurations=None, enable_auto_healing=None, auto_assign_elastic_ips=None, auto_assign_public_ips=None, custom_recipes=None, install_updates_on_boot=None, use_ebs_optimized_instances=None, lifecycle_event_configuration=None): DCNL DCSP params = {'LayerId': layer_id} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (shortname is not None): DCNL DCSP  DCSP params['Shortname'] = shortname DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP params['Attributes'] = attributes DCNL DCSP if (custom_instance_profile_arn is not None): DCNL DCSP  DCSP params['CustomInstanceProfileArn'] = custom_instance_profile_arn DCNL DCSP if (custom_security_group_ids is not None): DCNL DCSP  DCSP params['CustomSecurityGroupIds'] = custom_security_group_ids DCNL DCSP if (packages is not None): DCNL DCSP  DCSP params['Packages'] = packages DCNL DCSP if (volume_configurations is not None): DCNL DCSP  DCSP params['VolumeConfigurations'] = volume_configurations DCNL DCSP if (enable_auto_healing is not None): DCNL DCSP  DCSP params['EnableAutoHealing'] = enable_auto_healing DCNL DCSP if (auto_assign_elastic_ips is not None): DCNL DCSP  DCSP params['AutoAssignElasticIps'] = auto_assign_elastic_ips DCNL DCSP if (auto_assign_public_ips is not None): DCNL DCSP  DCSP params['AutoAssignPublicIps'] = auto_assign_public_ips DCNL DCSP if (custom_recipes is not None): DCNL DCSP  DCSP params['CustomRecipes'] = custom_recipes DCNL DCSP if (install_updates_on_boot is not None): DCNL DCSP  DCSP params['InstallUpdatesOnBoot'] = install_updates_on_boot DCNL DCSP if (use_ebs_optimized_instances is not None): DCNL DCSP  DCSP params['UseEbsOptimizedInstances'] = use_ebs_optimized_instances DCNL DCSP if (lifecycle_event_configuration is not None): DCNL DCSP  DCSP params['LifecycleEventConfiguration'] = lifecycle_event_configuration DCNL DCSP return self.make_request(action='UpdateLayer', body=json.dumps(params))
def update_my_user_profile(self, ssh_public_key=None): DCNL DCSP params = {} DCNL DCSP if (ssh_public_key is not None): DCNL DCSP  DCSP params['SshPublicKey'] = ssh_public_key DCNL DCSP return self.make_request(action='UpdateMyUserProfile', body=json.dumps(params))
def update_rds_db_instance(self, rds_db_instance_arn, db_user=None, db_password=None): DCNL DCSP params = {'RdsDbInstanceArn': rds_db_instance_arn} DCNL DCSP if (db_user is not None): DCNL DCSP  DCSP params['DbUser'] = db_user DCNL DCSP if (db_password is not None): DCNL DCSP  DCSP params['DbPassword'] = db_password DCNL DCSP return self.make_request(action='UpdateRdsDbInstance', body=json.dumps(params))
def update_stack(self, stack_id, name=None, attributes=None, service_role_arn=None, default_instance_profile_arn=None, default_os=None, hostname_theme=None, default_availability_zone=None, default_subnet_id=None, custom_json=None, configuration_manager=None, chef_configuration=None, use_custom_cookbooks=None, custom_cookbooks_source=None, default_ssh_key_name=None, default_root_device_type=None, use_opsworks_security_groups=None): DCNL DCSP params = {'StackId': stack_id} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP params['Attributes'] = attributes DCNL DCSP if (service_role_arn is not None): DCNL DCSP  DCSP params['ServiceRoleArn'] = service_role_arn DCNL DCSP if (default_instance_profile_arn is not None): DCNL DCSP  DCSP params['DefaultInstanceProfileArn'] = default_instance_profile_arn DCNL DCSP if (default_os is not None): DCNL DCSP  DCSP params['DefaultOs'] = default_os DCNL DCSP if (hostname_theme is not None): DCNL DCSP  DCSP params['HostnameTheme'] = hostname_theme DCNL DCSP if (default_availability_zone is not None): DCNL DCSP  DCSP params['DefaultAvailabilityZone'] = default_availability_zone DCNL DCSP if (default_subnet_id is not None): DCNL DCSP  DCSP params['DefaultSubnetId'] = default_subnet_id DCNL DCSP if (custom_json is not None): DCNL DCSP  DCSP params['CustomJson'] = custom_json DCNL DCSP if (configuration_manager is not None): DCNL DCSP  DCSP params['ConfigurationManager'] = configuration_manager DCNL DCSP if (chef_configuration is not None): DCNL DCSP  DCSP params['ChefConfiguration'] = chef_configuration DCNL DCSP if (use_custom_cookbooks is not None): DCNL DCSP  DCSP params['UseCustomCookbooks'] = use_custom_cookbooks DCNL DCSP if (custom_cookbooks_source is not None): DCNL DCSP  DCSP params['CustomCookbooksSource'] = custom_cookbooks_source DCNL DCSP if (default_ssh_key_name is not None): DCNL DCSP  DCSP params['DefaultSshKeyName'] = default_ssh_key_name DCNL DCSP if (default_root_device_type is not None): DCNL DCSP  DCSP params['DefaultRootDeviceType'] = default_root_device_type DCNL DCSP if (use_opsworks_security_groups is not None): DCNL DCSP  DCSP params['UseOpsworksSecurityGroups'] = use_opsworks_security_groups DCNL DCSP return self.make_request(action='UpdateStack', body=json.dumps(params))
def update_user_profile(self, iam_user_arn, ssh_username=None, ssh_public_key=None, allow_self_management=None): DCNL DCSP params = {'IamUserArn': iam_user_arn} DCNL DCSP if (ssh_username is not None): DCNL DCSP  DCSP params['SshUsername'] = ssh_username DCNL DCSP if (ssh_public_key is not None): DCNL DCSP  DCSP params['SshPublicKey'] = ssh_public_key DCNL DCSP if (allow_self_management is not None): DCNL DCSP  DCSP params['AllowSelfManagement'] = allow_self_management DCNL DCSP return self.make_request(action='UpdateUserProfile', body=json.dumps(params))
def update_volume(self, volume_id, name=None, mount_point=None): DCNL DCSP params = {'VolumeId': volume_id} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (mount_point is not None): DCNL DCSP  DCSP params['MountPoint'] = mount_point DCNL DCSP return self.make_request(action='UpdateVolume', body=json.dumps(params))
def delete_delivery_channel(self, delivery_channel_name): DCNL DCSP params = {'DeliveryChannelName': delivery_channel_name} DCNL DCSP return self.make_request(action='DeleteDeliveryChannel', body=json.dumps(params))
def deliver_config_snapshot(self, delivery_channel_name): DCNL DCSP params = {'deliveryChannelName': delivery_channel_name} DCNL DCSP return self.make_request(action='DeliverConfigSnapshot', body=json.dumps(params))
def describe_configuration_recorder_status(self, configuration_recorder_names=None): DCNL DCSP params = {} DCNL DCSP if (configuration_recorder_names is not None): DCNL DCSP  DCSP params['ConfigurationRecorderNames'] = configuration_recorder_names DCNL DCSP return self.make_request(action='DescribeConfigurationRecorderStatus', body=json.dumps(params))
def describe_configuration_recorders(self, configuration_recorder_names=None): DCNL DCSP params = {} DCNL DCSP if (configuration_recorder_names is not None): DCNL DCSP  DCSP params['ConfigurationRecorderNames'] = configuration_recorder_names DCNL DCSP return self.make_request(action='DescribeConfigurationRecorders', body=json.dumps(params))
def describe_delivery_channel_status(self, delivery_channel_names=None): DCNL DCSP params = {} DCNL DCSP if (delivery_channel_names is not None): DCNL DCSP  DCSP params['DeliveryChannelNames'] = delivery_channel_names DCNL DCSP return self.make_request(action='DescribeDeliveryChannelStatus', body=json.dumps(params))
def describe_delivery_channels(self, delivery_channel_names=None): DCNL DCSP params = {} DCNL DCSP if (delivery_channel_names is not None): DCNL DCSP  DCSP params['DeliveryChannelNames'] = delivery_channel_names DCNL DCSP return self.make_request(action='DescribeDeliveryChannels', body=json.dumps(params))
def get_resource_config_history(self, resource_type, resource_id, later_time=None, earlier_time=None, chronological_order=None, limit=None, next_token=None): DCNL DCSP params = {'resourceType': resource_type, 'resourceId': resource_id} DCNL DCSP if (later_time is not None): DCNL DCSP  DCSP params['laterTime'] = later_time DCNL DCSP if (earlier_time is not None): DCNL DCSP  DCSP params['earlierTime'] = earlier_time DCNL DCSP if (chronological_order is not None): DCNL DCSP  DCSP params['chronologicalOrder'] = chronological_order DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP return self.make_request(action='GetResourceConfigHistory', body=json.dumps(params))
def put_configuration_recorder(self, configuration_recorder): DCNL DCSP params = {'ConfigurationRecorder': configuration_recorder} DCNL DCSP return self.make_request(action='PutConfigurationRecorder', body=json.dumps(params))
def put_delivery_channel(self, delivery_channel): DCNL DCSP params = {'DeliveryChannel': delivery_channel} DCNL DCSP return self.make_request(action='PutDeliveryChannel', body=json.dumps(params))
def start_configuration_recorder(self, configuration_recorder_name): DCNL DCSP params = {'ConfigurationRecorderName': configuration_recorder_name} DCNL DCSP return self.make_request(action='StartConfigurationRecorder', body=json.dumps(params))
def stop_configuration_recorder(self, configuration_recorder_name): DCNL DCSP params = {'ConfigurationRecorderName': configuration_recorder_name} DCNL DCSP return self.make_request(action='StopConfigurationRecorder', body=json.dumps(params))
def get_all_dbinstances(self, instance_id=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if instance_id: DCNL DCSP  DCSP params['DBInstanceIdentifier'] = instance_id DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_list('DescribeDBInstances', params, [('DBInstance', DBInstance)])
def create_dbinstance(self, id, allocated_storage, instance_class, master_username, master_password, port=3306, engine='MySQL5.1', db_name=None, param_group=None, security_groups=None, availability_zone=None, preferred_maintenance_window=None, backup_retention_period=None, preferred_backup_window=None, multi_az=False, engine_version=None, auto_minor_version_upgrade=True, character_set_name=None, db_subnet_group_name=None, license_model=None, option_group_name=None, iops=None, vpc_security_groups=None): DCNL DCSP params = {'AllocatedStorage': allocated_storage, 'AutoMinorVersionUpgrade': (str(auto_minor_version_upgrade).lower() if auto_minor_version_upgrade else None), 'AvailabilityZone': availability_zone, 'BackupRetentionPeriod': backup_retention_period, 'CharacterSetName': character_set_name, 'DBInstanceClass': instance_class, 'DBInstanceIdentifier': id, 'DBName': db_name, 'DBParameterGroupName': (param_group.name if isinstance(param_group, ParameterGroup) else param_group), 'DBSubnetGroupName': db_subnet_group_name, 'Engine': engine, 'EngineVersion': engine_version, 'Iops': iops, 'LicenseModel': license_model, 'MasterUsername': master_username, 'MasterUserPassword': master_password, 'MultiAZ': (str(multi_az).lower() if multi_az else None), 'OptionGroupName': option_group_name, 'Port': port, 'PreferredBackupWindow': preferred_backup_window, 'PreferredMaintenanceWindow': preferred_maintenance_window} DCNL DCSP if security_groups: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for group in security_groups: DCNL DCSP  DCSP  DCSP if isinstance(group, DBSecurityGroup): DCNL DCSP  DCSP  DCSP  DCSP l.append(group.name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP l.append(group) DCNL DCSP  DCSP self.build_list_params(params, l, 'DBSecurityGroups.member') DCNL DCSP if vpc_security_groups: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for vpc_grp in vpc_security_groups: DCNL DCSP  DCSP  DCSP if isinstance(vpc_grp, VPCSecurityGroupMembership): DCNL DCSP  DCSP  DCSP  DCSP l.append(vpc_grp.vpc_group) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP l.append(vpc_grp) DCNL DCSP  DCSP self.build_list_params(params, l, 'VpcSecurityGroupIds.member') DCNL DCSP for (k, v) in list(params.items()): DCNL DCSP  DCSP if (v is None): DCNL DCSP  DCSP  DCSP del params[k] DCNL DCSP return self.get_object('CreateDBInstance', params, DBInstance)
def create_dbinstance_read_replica(self, id, source_id, instance_class=None, port=3306, availability_zone=None, auto_minor_version_upgrade=None): DCNL DCSP params = {'DBInstanceIdentifier': id, 'SourceDBInstanceIdentifier': source_id} DCNL DCSP if instance_class: DCNL DCSP  DCSP params['DBInstanceClass'] = instance_class DCNL DCSP if port: DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if availability_zone: DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP if (auto_minor_version_upgrade is True): DCNL DCSP  DCSP  DCSP params['AutoMinorVersionUpgrade'] = 'true' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params['AutoMinorVersionUpgrade'] = 'false' DCNL DCSP return self.get_object('CreateDBInstanceReadReplica', params, DBInstance)
def promote_read_replica(self, id, backup_retention_period=None, preferred_backup_window=None): DCNL DCSP params = {'DBInstanceIdentifier': id} DCNL DCSP if (backup_retention_period is not None): DCNL DCSP  DCSP params['BackupRetentionPeriod'] = backup_retention_period DCNL DCSP if preferred_backup_window: DCNL DCSP  DCSP params['PreferredBackupWindow'] = preferred_backup_window DCNL DCSP return self.get_object('PromoteReadReplica', params, DBInstance)
def modify_dbinstance(self, id, param_group=None, security_groups=None, preferred_maintenance_window=None, master_password=None, allocated_storage=None, instance_class=None, backup_retention_period=None, preferred_backup_window=None, multi_az=False, apply_immediately=False, iops=None, vpc_security_groups=None, new_instance_id=None): DCNL DCSP params = {'DBInstanceIdentifier': id} DCNL DCSP if param_group: DCNL DCSP  DCSP params['DBParameterGroupName'] = (param_group.name if isinstance(param_group, ParameterGroup) else param_group) DCNL DCSP if security_groups: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for group in security_groups: DCNL DCSP  DCSP  DCSP if isinstance(group, DBSecurityGroup): DCNL DCSP  DCSP  DCSP  DCSP l.append(group.name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP l.append(group) DCNL DCSP  DCSP self.build_list_params(params, l, 'DBSecurityGroups.member') DCNL DCSP if vpc_security_groups: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for vpc_grp in vpc_security_groups: DCNL DCSP  DCSP  DCSP if isinstance(vpc_grp, VPCSecurityGroupMembership): DCNL DCSP  DCSP  DCSP  DCSP l.append(vpc_grp.vpc_group) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP l.append(vpc_grp) DCNL DCSP  DCSP self.build_list_params(params, l, 'VpcSecurityGroupIds.member') DCNL DCSP if preferred_maintenance_window: DCNL DCSP  DCSP params['PreferredMaintenanceWindow'] = preferred_maintenance_window DCNL DCSP if master_password: DCNL DCSP  DCSP params['MasterUserPassword'] = master_password DCNL DCSP if allocated_storage: DCNL DCSP  DCSP params['AllocatedStorage'] = allocated_storage DCNL DCSP if instance_class: DCNL DCSP  DCSP params['DBInstanceClass'] = instance_class DCNL DCSP if (backup_retention_period is not None): DCNL DCSP  DCSP params['BackupRetentionPeriod'] = backup_retention_period DCNL DCSP if preferred_backup_window: DCNL DCSP  DCSP params['PreferredBackupWindow'] = preferred_backup_window DCNL DCSP if multi_az: DCNL DCSP  DCSP params['MultiAZ'] = 'true' DCNL DCSP if apply_immediately: DCNL DCSP  DCSP params['ApplyImmediately'] = 'true' DCNL DCSP if iops: DCNL DCSP  DCSP params['Iops'] = iops DCNL DCSP if new_instance_id: DCNL DCSP  DCSP params['NewDBInstanceIdentifier'] = new_instance_id DCNL DCSP return self.get_object('ModifyDBInstance', params, DBInstance)
def delete_dbinstance(self, id, skip_final_snapshot=False, final_snapshot_id=''): DCNL DCSP params = {'DBInstanceIdentifier': id} DCNL DCSP if skip_final_snapshot: DCNL DCSP  DCSP params['SkipFinalSnapshot'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP params['SkipFinalSnapshot'] = 'false' DCNL DCSP  DCSP params['FinalDBSnapshotIdentifier'] = final_snapshot_id DCNL DCSP return self.get_object('DeleteDBInstance', params, DBInstance)
def reboot_dbinstance(self, id): DCNL DCSP params = {'DBInstanceIdentifier': id} DCNL DCSP return self.get_object('RebootDBInstance', params, DBInstance)
def get_all_dbparameter_groups(self, groupname=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if groupname: DCNL DCSP  DCSP params['DBParameterGroupName'] = groupname DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_list('DescribeDBParameterGroups', params, [('DBParameterGroup', ParameterGroup)])
def get_all_dbparameters(self, groupname, source=None, max_records=None, marker=None): DCNL DCSP params = {'DBParameterGroupName': groupname} DCNL DCSP if source: DCNL DCSP  DCSP params['Source'] = source DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP pg = self.get_object('DescribeDBParameters', params, ParameterGroup) DCNL DCSP pg.name = groupname DCNL DCSP return pg
def create_parameter_group(self, name, engine='MySQL5.1', description=''): DCNL DCSP params = {'DBParameterGroupName': name, 'DBParameterGroupFamily': engine, 'Description': description} DCNL DCSP return self.get_object('CreateDBParameterGroup', params, ParameterGroup)
def modify_parameter_group(self, name, parameters=None): DCNL DCSP params = {'DBParameterGroupName': name} DCNL DCSP for i in range(0, len(parameters)): DCNL DCSP  DCSP parameter = parameters[i] DCNL DCSP  DCSP parameter.merge(params, (i + 1)) DCNL DCSP return self.get_list('ModifyDBParameterGroup', params, ParameterGroup, verb='POST')
def reset_parameter_group(self, name, reset_all_params=False, parameters=None): DCNL DCSP params = {'DBParameterGroupName': name} DCNL DCSP if reset_all_params: DCNL DCSP  DCSP params['ResetAllParameters'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP params['ResetAllParameters'] = 'false' DCNL DCSP  DCSP for i in range(0, len(parameters)): DCNL DCSP  DCSP  DCSP parameter = parameters[i] DCNL DCSP  DCSP  DCSP parameter.merge(params, (i + 1)) DCNL DCSP return self.get_status('ResetDBParameterGroup', params)
def delete_parameter_group(self, name): DCNL DCSP params = {'DBParameterGroupName': name} DCNL DCSP return self.get_status('DeleteDBParameterGroup', params)
def get_all_dbsecurity_groups(self, groupname=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if groupname: DCNL DCSP  DCSP params['DBSecurityGroupName'] = groupname DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_list('DescribeDBSecurityGroups', params, [('DBSecurityGroup', DBSecurityGroup)])
def create_dbsecurity_group(self, name, description=None): DCNL DCSP params = {'DBSecurityGroupName': name} DCNL DCSP if description: DCNL DCSP  DCSP params['DBSecurityGroupDescription'] = description DCNL DCSP group = self.get_object('CreateDBSecurityGroup', params, DBSecurityGroup) DCNL DCSP group.name = name DCNL DCSP group.description = description DCNL DCSP return group
def delete_dbsecurity_group(self, name): DCNL DCSP params = {'DBSecurityGroupName': name} DCNL DCSP return self.get_status('DeleteDBSecurityGroup', params)
def authorize_dbsecurity_group(self, group_name, cidr_ip=None, ec2_security_group_name=None, ec2_security_group_owner_id=None): DCNL DCSP params = {'DBSecurityGroupName': group_name} DCNL DCSP if ec2_security_group_name: DCNL DCSP  DCSP params['EC2SecurityGroupName'] = ec2_security_group_name DCNL DCSP if ec2_security_group_owner_id: DCNL DCSP  DCSP params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id DCNL DCSP if cidr_ip: DCNL DCSP  DCSP params['CIDRIP'] = urllib.quote(cidr_ip) DCNL DCSP return self.get_object('AuthorizeDBSecurityGroupIngress', params, DBSecurityGroup)
def revoke_dbsecurity_group(self, group_name, ec2_security_group_name=None, ec2_security_group_owner_id=None, cidr_ip=None): DCNL DCSP params = {'DBSecurityGroupName': group_name} DCNL DCSP if ec2_security_group_name: DCNL DCSP  DCSP params['EC2SecurityGroupName'] = ec2_security_group_name DCNL DCSP if ec2_security_group_owner_id: DCNL DCSP  DCSP params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id DCNL DCSP if cidr_ip: DCNL DCSP  DCSP params['CIDRIP'] = cidr_ip DCNL DCSP return self.get_object('RevokeDBSecurityGroupIngress', params, DBSecurityGroup)
def get_all_dbsnapshots(self, snapshot_id=None, instance_id=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if snapshot_id: DCNL DCSP  DCSP params['DBSnapshotIdentifier'] = snapshot_id DCNL DCSP if instance_id: DCNL DCSP  DCSP params['DBInstanceIdentifier'] = instance_id DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_list('DescribeDBSnapshots', params, [('DBSnapshot', DBSnapshot)])
def get_all_logs(self, dbinstance_id, max_records=None, marker=None, file_size=None, filename_contains=None, file_last_written=None): DCNL DCSP params = {'DBInstanceIdentifier': dbinstance_id} DCNL DCSP if file_size: DCNL DCSP  DCSP params['FileSize'] = file_size DCNL DCSP if filename_contains: DCNL DCSP  DCSP params['FilenameContains'] = filename_contains DCNL DCSP if file_last_written: DCNL DCSP  DCSP params['FileLastWritten'] = file_last_written DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP return self.get_list('DescribeDBLogFiles', params, [('DescribeDBLogFilesDetails', LogFile)])
def get_log_file(self, dbinstance_id, log_file_name, marker=None, number_of_lines=None, max_records=None): DCNL DCSP params = {'DBInstanceIdentifier': dbinstance_id, 'LogFileName': log_file_name} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if number_of_lines: DCNL DCSP  DCSP params['NumberOfLines'] = number_of_lines DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP logfile = self.get_object('DownloadDBLogFilePortion', params, LogFileObject) DCNL DCSP if logfile: DCNL DCSP  DCSP logfile.log_filename = log_file_name DCNL DCSP  DCSP logfile.dbinstance_id = dbinstance_id DCNL DCSP return logfile
def create_dbsnapshot(self, snapshot_id, dbinstance_id): DCNL DCSP params = {'DBSnapshotIdentifier': snapshot_id, 'DBInstanceIdentifier': dbinstance_id} DCNL DCSP return self.get_object('CreateDBSnapshot', params, DBSnapshot)
def copy_dbsnapshot(self, source_snapshot_id, target_snapshot_id): DCNL DCSP params = {'SourceDBSnapshotIdentifier': source_snapshot_id, 'TargetDBSnapshotIdentifier': target_snapshot_id} DCNL DCSP return self.get_object('CopyDBSnapshot', params, DBSnapshot)
def delete_dbsnapshot(self, identifier): DCNL DCSP params = {'DBSnapshotIdentifier': identifier} DCNL DCSP return self.get_object('DeleteDBSnapshot', params, DBSnapshot)
def restore_dbinstance_from_dbsnapshot(self, identifier, instance_id, instance_class, port=None, availability_zone=None, multi_az=None, auto_minor_version_upgrade=None, db_subnet_group_name=None): DCNL DCSP params = {'DBSnapshotIdentifier': identifier, 'DBInstanceIdentifier': instance_id, 'DBInstanceClass': instance_class} DCNL DCSP if port: DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if availability_zone: DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (multi_az is not None): DCNL DCSP  DCSP params['MultiAZ'] = str(multi_az).lower() DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower() DCNL DCSP if (db_subnet_group_name is not None): DCNL DCSP  DCSP params['DBSubnetGroupName'] = db_subnet_group_name DCNL DCSP return self.get_object('RestoreDBInstanceFromDBSnapshot', params, DBInstance)
def restore_dbinstance_from_point_in_time(self, source_instance_id, target_instance_id, use_latest=False, restore_time=None, dbinstance_class=None, port=None, availability_zone=None, db_subnet_group_name=None): DCNL DCSP params = {'SourceDBInstanceIdentifier': source_instance_id, 'TargetDBInstanceIdentifier': target_instance_id} DCNL DCSP if use_latest: DCNL DCSP  DCSP params['UseLatestRestorableTime'] = 'true' DCNL DCSP elif restore_time: DCNL DCSP  DCSP params['RestoreTime'] = restore_time.isoformat() DCNL DCSP if dbinstance_class: DCNL DCSP  DCSP params['DBInstanceClass'] = dbinstance_class DCNL DCSP if port: DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if availability_zone: DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if (db_subnet_group_name is not None): DCNL DCSP  DCSP params['DBSubnetGroupName'] = db_subnet_group_name DCNL DCSP return self.get_object('RestoreDBInstanceToPointInTime', params, DBInstance)
def get_all_events(self, source_identifier=None, source_type=None, start_time=None, end_time=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (source_identifier and source_type): DCNL DCSP  DCSP params['SourceIdentifier'] = source_identifier DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP if start_time: DCNL DCSP  DCSP params['StartTime'] = start_time.isoformat() DCNL DCSP if end_time: DCNL DCSP  DCSP params['EndTime'] = end_time.isoformat() DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_list('DescribeEvents', params, [('Event', Event)])
def create_db_subnet_group(self, name, desc, subnet_ids): DCNL DCSP params = {'DBSubnetGroupName': name, 'DBSubnetGroupDescription': desc} DCNL DCSP self.build_list_params(params, subnet_ids, 'SubnetIds.member') DCNL DCSP return self.get_object('CreateDBSubnetGroup', params, DBSubnetGroup)
def delete_db_subnet_group(self, name): DCNL DCSP params = {'DBSubnetGroupName': name} DCNL DCSP return self.get_object('DeleteDBSubnetGroup', params, DBSubnetGroup)
def get_all_db_subnet_groups(self, name=None, max_records=None, marker=None): DCNL DCSP params = dict() DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['DBSubnetGroupName'] = name DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_list('DescribeDBSubnetGroups', params, [('DBSubnetGroup', DBSubnetGroup)])
def modify_db_subnet_group(self, name, description=None, subnet_ids=None): DCNL DCSP params = {'DBSubnetGroupName': name} DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['DBSubnetGroupDescription'] = description DCNL DCSP if (subnet_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, subnet_ids, 'SubnetIds.member') DCNL DCSP return self.get_object('ModifyDBSubnetGroup', params, DBSubnetGroup)
def create_option_group(self, name, engine_name, major_engine_version, description=None): DCNL DCSP params = {'OptionGroupName': name, 'EngineName': engine_name, 'MajorEngineVersion': major_engine_version, 'OptionGroupDescription': description} DCNL DCSP group = self.get_object('CreateOptionGroup', params, OptionGroup) DCNL DCSP group.name = name DCNL DCSP group.engine_name = engine_name DCNL DCSP group.major_engine_version = major_engine_version DCNL DCSP group.description = description DCNL DCSP return group
def delete_option_group(self, name): DCNL DCSP params = {'OptionGroupName': name} DCNL DCSP return self.get_status('DeleteOptionGroup', params)
def describe_option_groups(self, name=None, engine_name=None, major_engine_version=None, max_records=100, marker=None): DCNL DCSP params = {} DCNL DCSP if name: DCNL DCSP  DCSP params['OptionGroupName'] = name DCNL DCSP elif (engine_name and major_engine_version): DCNL DCSP  DCSP params['EngineName'] = engine_name DCNL DCSP  DCSP params['MajorEngineVersion'] = major_engine_version DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = int(max_records) DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_list('DescribeOptionGroups', params, [('OptionGroup', OptionGroup)])
def describe_option_group_options(self, engine_name=None, major_engine_version=None, max_records=100, marker=None): DCNL DCSP params = {} DCNL DCSP if (engine_name and major_engine_version): DCNL DCSP  DCSP params['EngineName'] = engine_name DCNL DCSP  DCSP params['MajorEngineVersion'] = major_engine_version DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = int(max_records) DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_list('DescribeOptionGroupOptions', params, [('OptionGroupOptions', OptionGroupOption)])
def authorize(self, cidr_ip=None, ec2_group=None): DCNL DCSP if isinstance(ec2_group, SecurityGroup): DCNL DCSP  DCSP group_name = ec2_group.name DCNL DCSP  DCSP group_owner_id = ec2_group.owner_id DCNL DCSP else: DCNL DCSP  DCSP group_name = None DCNL DCSP  DCSP group_owner_id = None DCNL DCSP return self.connection.authorize_dbsecurity_group(self.name, cidr_ip, group_name, group_owner_id)
def revoke(self, cidr_ip=None, ec2_group=None): DCNL DCSP if isinstance(ec2_group, SecurityGroup): DCNL DCSP  DCSP group_name = ec2_group.name DCNL DCSP  DCSP group_owner_id = ec2_group.owner_id DCNL DCSP  DCSP return self.connection.revoke_dbsecurity_group(self.name, ec2_security_group_name=group_name, ec2_security_group_owner_id=group_owner_id) DCNL DCSP return self.connection.revoke_dbsecurity_group(self.name, cidr_ip=cidr_ip)
def update(self, validate=False): DCNL DCSP rs = self.connection.get_all_dbsnapshots(self.id) DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP for i in rs: DCNL DCSP  DCSP  DCSP if (i.id == self.id): DCNL DCSP  DCSP  DCSP  DCSP self.__dict__.update(i.__dict__) DCNL DCSP elif validate: DCNL DCSP  DCSP raise ValueError(('%s DCSP is DCSP not DCSP a DCSP valid DCSP Snapshot DCSP ID' % self.id)) DCNL DCSP return self.status
@property DCNL def security_group(self): DCNL DCSP if (len(self.security_groups) > 0): DCNL DCSP  DCSP return self.security_groups[(-1)] DCNL DCSP else: DCNL DCSP  DCSP return None
@property DCNL def parameter_group(self): DCNL DCSP if (len(self.parameter_groups) > 0): DCNL DCSP  DCSP return self.parameter_groups[(-1)] DCNL DCSP else: DCNL DCSP  DCSP return None
def snapshot(self, snapshot_id): DCNL DCSP return self.connection.create_dbsnapshot(snapshot_id, self.id)
def reboot(self): DCNL DCSP return self.connection.reboot_dbinstance(self.id)
def update(self, validate=False): DCNL DCSP rs = self.connection.get_all_dbinstances(self.id) DCNL DCSP if (len(rs) > 0): DCNL DCSP  DCSP for i in rs: DCNL DCSP  DCSP  DCSP if (i.id == self.id): DCNL DCSP  DCSP  DCSP  DCSP self.__dict__.update(i.__dict__) DCNL DCSP elif validate: DCNL DCSP  DCSP raise ValueError(('%s DCSP is DCSP not DCSP a DCSP valid DCSP Instance DCSP ID' % self.id)) DCNL DCSP return self.status
def stop(self, skip_final_snapshot=False, final_snapshot_id=''): DCNL DCSP return self.connection.delete_dbinstance(self.id, skip_final_snapshot, final_snapshot_id)
def modify(self, param_group=None, security_groups=None, preferred_maintenance_window=None, master_password=None, allocated_storage=None, instance_class=None, backup_retention_period=None, preferred_backup_window=None, multi_az=False, iops=None, vpc_security_groups=None, apply_immediately=False, new_instance_id=None): DCNL DCSP return self.connection.modify_dbinstance(self.id, param_group, security_groups, preferred_maintenance_window, master_password, allocated_storage, instance_class, backup_retention_period, preferred_backup_window, multi_az, apply_immediately, iops, vpc_security_groups, new_instance_id)
def headers_to_sign(self, http_request): DCNL DCSP headers_to_sign = {'Host': self.host} DCNL DCSP for (name, value) in http_request.headers.items(): DCNL DCSP  DCSP lname = name.lower() DCNL DCSP  DCSP if lname.startswith('x-amz'): DCNL DCSP  DCSP  DCSP headers_to_sign[name] = value DCNL DCSP return headers_to_sign
def canonical_headers(self, headers_to_sign): DCNL DCSP l = sorted([('%s:%s' % (n.lower().strip(), headers_to_sign[n].strip())) for n in headers_to_sign]) DCNL DCSP return '\n'.join(l)
def string_to_sign(self, http_request): DCNL DCSP headers_to_sign = self.headers_to_sign(http_request) DCNL DCSP canonical_headers = self.canonical_headers(headers_to_sign) DCNL DCSP string_to_sign = '\n'.join([http_request.method, http_request.auth_path, '', canonical_headers, '', http_request.body]) DCNL DCSP return (string_to_sign, headers_to_sign)
def add_auth(self, req, **kwargs): DCNL DCSP if ('X-Amzn-Authorization' in req.headers): DCNL DCSP  DCSP del req.headers['X-Amzn-Authorization'] DCNL DCSP req.headers['X-Amz-Date'] = formatdate(usegmt=True) DCNL DCSP if self._provider.security_token: DCNL DCSP  DCSP req.headers['X-Amz-Security-Token'] = self._provider.security_token DCNL DCSP (string_to_sign, headers_to_sign) = self.string_to_sign(req) DCNL DCSP boto.log.debug(('StringToSign:\n%s' % string_to_sign)) DCNL DCSP hash_value = sha256(string_to_sign.encode('utf-8')).digest() DCNL DCSP b64_hmac = self.sign_string(hash_value) DCNL DCSP s = ('AWS3 DCSP AWSAccessKeyId=%s,' % self._provider.access_key) DCNL DCSP s += ('Algorithm=%s,' % self.algorithm()) DCNL DCSP s += ('SignedHeaders=%s,' % ';'.join(headers_to_sign)) DCNL DCSP s += ('Signature=%s' % b64_hmac) DCNL DCSP req.headers['X-Amzn-Authorization'] = s
def headers_to_sign(self, http_request): DCNL DCSP host_header_value = self.host_header(self.host, http_request) DCNL DCSP if http_request.headers.get('Host'): DCNL DCSP  DCSP host_header_value = http_request.headers['Host'] DCNL DCSP headers_to_sign = {'Host': host_header_value} DCNL DCSP for (name, value) in http_request.headers.items(): DCNL DCSP  DCSP lname = name.lower() DCNL DCSP  DCSP if lname.startswith('x-amz'): DCNL DCSP  DCSP  DCSP if isinstance(value, bytes): DCNL DCSP  DCSP  DCSP  DCSP value = value.decode('utf-8') DCNL DCSP  DCSP  DCSP headers_to_sign[name] = value DCNL DCSP return headers_to_sign
def canonical_headers(self, headers_to_sign): DCNL DCSP canonical = [] DCNL DCSP for header in headers_to_sign: DCNL DCSP  DCSP c_name = header.lower().strip() DCNL DCSP  DCSP raw_value = str(headers_to_sign[header]) DCNL DCSP  DCSP if ('"' in raw_value): DCNL DCSP  DCSP  DCSP c_value = raw_value.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP c_value = ' DCSP '.join(raw_value.strip().split()) DCNL DCSP  DCSP canonical.append(('%s:%s' % (c_name, c_value))) DCNL DCSP return '\n'.join(sorted(canonical))
def string_to_sign(self, http_request, canonical_request): DCNL DCSP sts = ['AWS4-HMAC-SHA256'] DCNL DCSP sts.append(http_request.headers['X-Amz-Date']) DCNL DCSP sts.append(self.credential_scope(http_request)) DCNL DCSP sts.append(sha256(canonical_request.encode('utf-8')).hexdigest()) DCNL DCSP return '\n'.join(sts)
def add_auth(self, req, **kwargs): DCNL DCSP if ('X-Amzn-Authorization' in req.headers): DCNL DCSP  DCSP del req.headers['X-Amzn-Authorization'] DCNL DCSP now = datetime.datetime.utcnow() DCNL DCSP req.headers['X-Amz-Date'] = now.strftime('%Y%m%dT%H%M%SZ') DCNL DCSP if self._provider.security_token: DCNL DCSP  DCSP req.headers['X-Amz-Security-Token'] = self._provider.security_token DCNL DCSP qs = self.query_string(req) DCNL DCSP qs_to_post = qs DCNL DCSP if ('unmangled_req' in kwargs): DCNL DCSP  DCSP qs_to_post = self.query_string(kwargs['unmangled_req']) DCNL DCSP if (qs_to_post and (req.method == 'POST')): DCNL DCSP  DCSP req.body = qs_to_post DCNL DCSP  DCSP req.headers['Content-Type'] = 'application/x-www-form-urlencoded; DCSP charset=UTF-8' DCNL DCSP  DCSP req.headers['Content-Length'] = str(len(req.body)) DCNL DCSP else: DCNL DCSP  DCSP req.path = req.path.split('?')[0] DCNL DCSP  DCSP if qs: DCNL DCSP  DCSP  DCSP req.path = ((req.path + '?') + qs) DCNL DCSP canonical_request = self.canonical_request(req) DCNL DCSP boto.log.debug(('CanonicalRequest:\n%s' % canonical_request)) DCNL DCSP string_to_sign = self.string_to_sign(req, canonical_request) DCNL DCSP boto.log.debug(('StringToSign:\n%s' % string_to_sign)) DCNL DCSP signature = self.signature(req, string_to_sign) DCNL DCSP boto.log.debug(('Signature:\n%s' % signature)) DCNL DCSP headers_to_sign = self.headers_to_sign(req) DCNL DCSP l = [('AWS4-HMAC-SHA256 DCSP Credential=%s' % self.scope(req))] DCNL DCSP l.append(('SignedHeaders=%s' % self.signed_headers(headers_to_sign))) DCNL DCSP l.append(('Signature=%s' % signature)) DCNL DCSP req.headers['Authorization'] = ','.join(l)
def headers_to_sign(self, http_request): DCNL DCSP host_header_value = self.host_header(self.host, http_request) DCNL DCSP headers_to_sign = {'Host': host_header_value} DCNL DCSP for (name, value) in http_request.headers.items(): DCNL DCSP  DCSP lname = name.lower() DCNL DCSP  DCSP if (lname not in ['authorization']): DCNL DCSP  DCSP  DCSP headers_to_sign[name] = value DCNL DCSP return headers_to_sign
def mangle_path_and_params(self, req): DCNL DCSP modified_req = copy.copy(req) DCNL DCSP parsed_path = urllib.parse.urlparse(modified_req.auth_path) DCNL DCSP modified_req.auth_path = parsed_path.path DCNL DCSP if (modified_req.params is None): DCNL DCSP  DCSP modified_req.params = {} DCNL DCSP else: DCNL DCSP  DCSP copy_params = req.params.copy() DCNL DCSP  DCSP modified_req.params = copy_params DCNL DCSP raw_qs = parsed_path.query DCNL DCSP existing_qs = parse_qs_safe(raw_qs, keep_blank_values=True) DCNL DCSP for (key, value) in existing_qs.items(): DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP if (len(value) == 1): DCNL DCSP  DCSP  DCSP  DCSP existing_qs[key] = value[0] DCNL DCSP modified_req.params.update(existing_qs) DCNL DCSP return modified_req
def presign(self, req, expires, iso_date=None): DCNL DCSP if (iso_date is None): DCNL DCSP  DCSP iso_date = datetime.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ') DCNL DCSP region = self.determine_region_name(req.host) DCNL DCSP service = self.determine_service_name(req.host) DCNL DCSP params = {'X-Amz-Algorithm': 'AWS4-HMAC-SHA256', 'X-Amz-Credential': ('%s/%s/%s/%s/aws4_request' % (self._provider.access_key, iso_date[:8], region, service)), 'X-Amz-Date': iso_date, 'X-Amz-Expires': expires, 'X-Amz-SignedHeaders': 'host'} DCNL DCSP if self._provider.security_token: DCNL DCSP  DCSP params['X-Amz-Security-Token'] = self._provider.security_token DCNL DCSP headers_to_sign = self.headers_to_sign(req) DCNL DCSP l = sorted([('%s' % n.lower().strip()) for n in headers_to_sign]) DCNL DCSP params['X-Amz-SignedHeaders'] = ';'.join(l) DCNL DCSP req.params.update(params) DCNL DCSP cr = self.canonical_request(req) DCNL DCSP cr = ('\n'.join(cr.split('\n')[:(-1)]) + '\nUNSIGNED-PAYLOAD') DCNL DCSP req.headers['X-Amz-Date'] = iso_date DCNL DCSP sts = self.string_to_sign(req, cr) DCNL DCSP signature = self.signature(req, sts) DCNL DCSP req.params['X-Amz-Signature'] = signature DCNL DCSP return ('%s://%s%s?%s' % (req.protocol, req.host, req.path, urllib.parse.urlencode(req.params)))
def __init__(self, endpoint_data, service_rename_map=None): DCNL DCSP super(_CompatEndpointResolver, self).__init__(endpoint_data) DCNL DCSP if (service_rename_map is None): DCNL DCSP  DCSP service_rename_map = self._DEFAULT_SERVICE_RENAMES DCNL DCSP self._endpoint_prefix_map = service_rename_map DCNL DCSP self._service_name_map = dict(((v, k) for (k, v) in service_rename_map.items()))
def get_all_available_regions(self, service_name): DCNL DCSP regions = set() DCNL DCSP endpoint_prefix = self._endpoint_prefix(service_name) DCNL DCSP for partition_name in self.get_available_partitions(): DCNL DCSP  DCSP if self._is_global_service(service_name, partition_name): DCNL DCSP  DCSP  DCSP partition = self._get_partition_data(partition_name) DCNL DCSP  DCSP  DCSP regions.update(partition['regions'].keys()) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP regions.update(self.get_available_endpoints(endpoint_prefix, partition_name)) DCNL DCSP return list(regions)
def get_available_services(self): DCNL DCSP services = set() DCNL DCSP for partition in self._endpoint_data['partitions']: DCNL DCSP  DCSP services.update(partition['services'].keys()) DCNL DCSP return [self._service_name(s) for s in services]
def _is_global_service(self, service_name, partition_name='aws'): DCNL DCSP endpoint_prefix = self._endpoint_prefix(service_name) DCNL DCSP partition = self._get_partition_data(partition_name) DCNL DCSP service = partition['services'].get(endpoint_prefix, {}) DCNL DCSP return ('partitionEndpoint' in service)
def _get_partition_data(self, partition_name): DCNL DCSP for partition in self._endpoint_data['partitions']: DCNL DCSP  DCSP if (partition['partition'] == partition_name): DCNL DCSP  DCSP  DCSP return partition DCNL DCSP raise ValueError(('Could DCSP not DCSP find DCSP partition DCSP data DCSP for: DCSP %s' % partition_name))
def _endpoint_prefix(self, service_name): DCNL DCSP return self._endpoint_prefix_map.get(service_name, service_name)
def _service_name(self, endpoint_prefix): DCNL DCSP return self._service_name_map.get(endpoint_prefix, endpoint_prefix)
def __init__(self, endpoint_data, service_rename_map=None): DCNL DCSP self._resolver = _CompatEndpointResolver(endpoint_data, service_rename_map)
def resolve_hostname(self, service_name, region_name): DCNL DCSP endpoint = self._resolver.construct_endpoint(service_name, region_name) DCNL DCSP if (endpoint is None): DCNL DCSP  DCSP return None DCNL DCSP return endpoint.get('sslCommonName', endpoint['hostname'])
def get_all_available_regions(self, service_name): DCNL DCSP return self._resolver.get_all_available_regions(service_name)
def get_available_services(self): DCNL DCSP return self._resolver.get_available_services()
def __init__(self, resolver): DCNL DCSP self._resolver = resolver
def build_static_endpoints(self, service_names=None): DCNL DCSP if (service_names is None): DCNL DCSP  DCSP service_names = self._resolver.get_available_services() DCNL DCSP static_endpoints = {} DCNL DCSP for name in service_names: DCNL DCSP  DCSP endpoints_for_service = self._build_endpoints_for_service(name) DCNL DCSP  DCSP if endpoints_for_service: DCNL DCSP  DCSP  DCSP static_endpoints[name] = endpoints_for_service DCNL DCSP self._handle_special_cases(static_endpoints) DCNL DCSP return static_endpoints
def connect(self, **kw_params): DCNL DCSP if self.connection_cls: DCNL DCSP  DCSP return self.connection_cls(host=self.endpoint, **kw_params)
def __init__(self, ip_addr, port, hc_type, resource_path, fqdn=None, string_match=None, request_interval=30, failure_threshold=3): DCNL DCSP self.ip_addr = ip_addr DCNL DCSP self.port = port DCNL DCSP self.hc_type = hc_type DCNL DCSP self.resource_path = resource_path DCNL DCSP self.fqdn = fqdn DCNL DCSP self.string_match = string_match DCNL DCSP self.failure_threshold = failure_threshold DCNL DCSP if (request_interval in self.valid_request_intervals): DCNL DCSP  DCSP self.request_interval = request_interval DCNL DCSP else: DCNL DCSP  DCSP raise AttributeError(('Valid DCSP values DCSP for DCSP request_interval DCSP are: DCSP %s' % ','.join((str(i) for i in self.valid_request_intervals)))) DCNL DCSP if ((failure_threshold < 1) or (failure_threshold > 10)): DCNL DCSP  DCSP raise AttributeError('Valid DCSP values DCSP for DCSP failure_threshold DCSP are DCSP 1 DCSP - DCSP 10.')
def get_all_hosted_zones(self, start_marker=None, zone_list=None): DCNL DCSP params = {} DCNL DCSP if start_marker: DCNL DCSP  DCSP params = {'marker': start_marker} DCNL DCSP response = self.make_request('GET', ('/%s/hostedzone' % self.Version), params=params) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status >= 300): DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element(list_marker='HostedZones', item_marker=('HostedZone',)) DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP if zone_list: DCNL DCSP  DCSP e['ListHostedZonesResponse']['HostedZones'].extend(zone_list) DCNL DCSP while ('NextMarker' in e['ListHostedZonesResponse']): DCNL DCSP  DCSP next_marker = e['ListHostedZonesResponse']['NextMarker'] DCNL DCSP  DCSP zone_list = e['ListHostedZonesResponse']['HostedZones'] DCNL DCSP  DCSP e = self.get_all_hosted_zones(next_marker, zone_list) DCNL DCSP return e
def get_hosted_zone(self, hosted_zone_id): DCNL DCSP uri = ('/%s/hostedzone/%s' % (self.Version, hosted_zone_id)) DCNL DCSP response = self.make_request('GET', uri) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status >= 300): DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element(list_marker='NameServers', item_marker=('NameServer',)) DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return e
def get_hosted_zone_by_name(self, hosted_zone_name): DCNL DCSP if (hosted_zone_name[(-1)] != '.'): DCNL DCSP  DCSP hosted_zone_name += '.' DCNL DCSP all_hosted_zones = self.get_all_hosted_zones() DCNL DCSP for zone in all_hosted_zones['ListHostedZonesResponse']['HostedZones']: DCNL DCSP  DCSP if (zone['Name'] == hosted_zone_name): DCNL DCSP  DCSP  DCSP return self.get_hosted_zone(zone['Id'].split('/')[(-1)])
def create_hosted_zone(self, domain_name, caller_ref=None, comment='', private_zone=False, vpc_id=None, vpc_region=None): DCNL DCSP if (caller_ref is None): DCNL DCSP  DCSP caller_ref = str(uuid.uuid4()) DCNL DCSP if private_zone: DCNL DCSP  DCSP params = {'name': domain_name, 'caller_ref': caller_ref, 'comment': comment, 'vpc_id': vpc_id, 'vpc_region': vpc_region, 'xmlns': self.XMLNameSpace} DCNL DCSP  DCSP xml_body = (HZPXML % params) DCNL DCSP else: DCNL DCSP  DCSP params = {'name': domain_name, 'caller_ref': caller_ref, 'comment': comment, 'xmlns': self.XMLNameSpace} DCNL DCSP  DCSP xml_body = (HZXML % params) DCNL DCSP uri = ('/%s/hostedzone' % self.Version) DCNL DCSP response = self.make_request('POST', uri, {'Content-Type': 'text/xml'}, xml_body) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 201): DCNL DCSP  DCSP e = boto.jsonresponse.Element(list_marker='NameServers', item_marker=('NameServer',)) DCNL DCSP  DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP  DCSP h.parse(body) DCNL DCSP  DCSP return e DCNL DCSP else: DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body)
def delete_hosted_zone(self, hosted_zone_id): DCNL DCSP uri = ('/%s/hostedzone/%s' % (self.Version, hosted_zone_id)) DCNL DCSP response = self.make_request('DELETE', uri) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status not in (200, 204)): DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element() DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return e
def create_health_check(self, health_check, caller_ref=None): DCNL DCSP if (caller_ref is None): DCNL DCSP  DCSP caller_ref = str(uuid.uuid4()) DCNL DCSP uri = ('/%s/healthcheck' % self.Version) DCNL DCSP params = {'xmlns': self.XMLNameSpace, 'caller_ref': caller_ref, 'health_check': health_check.to_xml()} DCNL DCSP xml_body = (self.POSTHCXMLBody % params) DCNL DCSP response = self.make_request('POST', uri, {'Content-Type': 'text/xml'}, xml_body) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 201): DCNL DCSP  DCSP e = boto.jsonresponse.Element() DCNL DCSP  DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP  DCSP h.parse(body) DCNL DCSP  DCSP return e DCNL DCSP else: DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body)
def get_list_health_checks(self, maxitems=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (maxitems is not None): DCNL DCSP  DCSP params['maxitems'] = maxitems DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['marker'] = marker DCNL DCSP uri = ('/%s/healthcheck' % (self.Version,)) DCNL DCSP response = self.make_request('GET', uri, params=params) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status >= 300): DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element(list_marker='HealthChecks', item_marker=('HealthCheck',)) DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return e
def get_checker_ip_ranges(self): DCNL DCSP uri = ('/%s/checkeripranges' % self.Version) DCNL DCSP response = self.make_request('GET', uri) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status >= 300): DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element(list_marker='CheckerIpRanges', item_marker=('member',)) DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return e
def delete_health_check(self, health_check_id): DCNL DCSP uri = ('/%s/healthcheck/%s' % (self.Version, health_check_id)) DCNL DCSP response = self.make_request('DELETE', uri) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status not in (200, 204)): DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element() DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return e
def get_all_rrsets(self, hosted_zone_id, type=None, name=None, identifier=None, maxitems=None): DCNL DCSP params = {'type': type, 'name': name, 'identifier': identifier, 'maxitems': maxitems} DCNL DCSP uri = ('/%s/hostedzone/%s/rrset' % (self.Version, hosted_zone_id)) DCNL DCSP response = self.make_request('GET', uri, params=params) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status >= 300): DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body) DCNL DCSP rs = ResourceRecordSets(connection=self, hosted_zone_id=hosted_zone_id) DCNL DCSP h = handler.XmlHandler(rs, self) DCNL DCSP xml.sax.parseString(body, h) DCNL DCSP return rs
def change_rrsets(self, hosted_zone_id, xml_body): DCNL DCSP uri = ('/%s/hostedzone/%s/rrset' % (self.Version, hosted_zone_id)) DCNL DCSP response = self.make_request('POST', uri, {'Content-Type': 'text/xml'}, xml_body) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status >= 300): DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element() DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return e
def get_change(self, change_id): DCNL DCSP uri = ('/%s/change/%s' % (self.Version, change_id)) DCNL DCSP response = self.make_request('GET', uri) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status >= 300): DCNL DCSP  DCSP raise exception.DNSServerError(response.status, response.reason, body) DCNL DCSP e = boto.jsonresponse.Element() DCNL DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP h.parse(body) DCNL DCSP return e
def create_zone(self, name, private_zone=False, vpc_id=None, vpc_region=None): DCNL DCSP zone = self.create_hosted_zone(name, private_zone=private_zone, vpc_id=vpc_id, vpc_region=vpc_region) DCNL DCSP return Zone(self, zone['CreateHostedZoneResponse']['HostedZone'])
def get_zone(self, name): DCNL DCSP name = self._make_qualified(name) DCNL DCSP for zone in self.get_zones(): DCNL DCSP  DCSP if (name == zone.name): DCNL DCSP  DCSP  DCSP return zone
def get_zones(self): DCNL DCSP zones = self.get_all_hosted_zones() DCNL DCSP return [Zone(self, zone) for zone in zones['ListHostedZonesResponse']['HostedZones']]
def _make_qualified(self, value): DCNL DCSP if (type(value) in [list, tuple, set]): DCNL DCSP  DCSP new_list = [] DCNL DCSP  DCSP for record in value: DCNL DCSP  DCSP  DCSP if (record and (not (record[(-1)] == '.'))): DCNL DCSP  DCSP  DCSP  DCSP new_list.append(('%s.' % record)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new_list.append(record) DCNL DCSP  DCSP return new_list DCNL DCSP else: DCNL DCSP  DCSP value = value.strip() DCNL DCSP  DCSP if (value and (not (value[(-1)] == '.'))): DCNL DCSP  DCSP  DCSP value = ('%s.' % value) DCNL DCSP  DCSP return value
def update(self): DCNL DCSP status = self.route53connection.get_change(self.id)['GetChangeResponse']['ChangeInfo']['Status'] DCNL DCSP self.status = status DCNL DCSP return status
def _commit(self, changes): DCNL DCSP response = changes.commit() DCNL DCSP return response['ChangeResourceRecordSetsResponse']['ChangeInfo']
def _new_record(self, changes, resource_type, name, value, ttl, identifier, comment=''): DCNL DCSP weight = None DCNL DCSP region = None DCNL DCSP if (identifier is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP int(identifier[1]) DCNL DCSP  DCSP  DCSP weight = identifier[1] DCNL DCSP  DCSP  DCSP identifier = identifier[0] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP region = identifier[1] DCNL DCSP  DCSP  DCSP identifier = identifier[0] DCNL DCSP change = changes.add_change('CREATE', name, resource_type, ttl, identifier=identifier, weight=weight, region=region) DCNL DCSP if (type(value) in [list, tuple, set]): DCNL DCSP  DCSP for record in value: DCNL DCSP  DCSP  DCSP change.add_value(record) DCNL DCSP else: DCNL DCSP  DCSP change.add_value(value)
def add_record(self, resource_type, name, value, ttl=60, identifier=None, comment=''): DCNL DCSP changes = ResourceRecordSets(self.route53connection, self.id, comment) DCNL DCSP self._new_record(changes, resource_type, name, value, ttl, identifier, comment) DCNL DCSP return Status(self.route53connection, self._commit(changes))
def update_record(self, old_record, new_value, new_ttl=None, new_identifier=None, comment=''): DCNL DCSP new_ttl = (new_ttl or default_ttl) DCNL DCSP record = copy.copy(old_record) DCNL DCSP changes = ResourceRecordSets(self.route53connection, self.id, comment) DCNL DCSP changes.add_change_record('DELETE', record) DCNL DCSP self._new_record(changes, record.type, record.name, new_value, new_ttl, new_identifier, comment) DCNL DCSP return Status(self.route53connection, self._commit(changes))
def delete_record(self, record, comment=''): DCNL DCSP changes = ResourceRecordSets(self.route53connection, self.id, comment) DCNL DCSP if (type(record) in [list, tuple, set]): DCNL DCSP  DCSP for r in record: DCNL DCSP  DCSP  DCSP changes.add_change_record('DELETE', r) DCNL DCSP else: DCNL DCSP  DCSP changes.add_change_record('DELETE', record) DCNL DCSP return Status(self.route53connection, self._commit(changes))
def add_cname(self, name, value, ttl=None, identifier=None, comment=''): DCNL DCSP ttl = (ttl or default_ttl) DCNL DCSP name = self.route53connection._make_qualified(name) DCNL DCSP value = self.route53connection._make_qualified(value) DCNL DCSP return self.add_record(resource_type='CNAME', name=name, value=value, ttl=ttl, identifier=identifier, comment=comment)
def add_a(self, name, value, ttl=None, identifier=None, comment=''): DCNL DCSP ttl = (ttl or default_ttl) DCNL DCSP name = self.route53connection._make_qualified(name) DCNL DCSP return self.add_record(resource_type='A', name=name, value=value, ttl=ttl, identifier=identifier, comment=comment)
def add_mx(self, name, records, ttl=None, identifier=None, comment=''): DCNL DCSP ttl = (ttl or default_ttl) DCNL DCSP records = self.route53connection._make_qualified(records) DCNL DCSP return self.add_record(resource_type='MX', name=name, value=records, ttl=ttl, identifier=identifier, comment=comment)
def find_records(self, name, type, desired=1, all=False, identifier=None): DCNL DCSP name = self.route53connection._make_qualified(name) DCNL DCSP returned = self.route53connection.get_all_rrsets(self.id, name=name, type=type) DCNL DCSP results = [] DCNL DCSP for r in returned: DCNL DCSP  DCSP if ((r.name == name) and (r.type == type)): DCNL DCSP  DCSP  DCSP results.append(r) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP weight = None DCNL DCSP region = None DCNL DCSP if (identifier is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP int(identifier[1]) DCNL DCSP  DCSP  DCSP weight = identifier[1] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP region = identifier[1] DCNL DCSP if (weight is not None): DCNL DCSP  DCSP results = [r for r in results if ((r.weight == weight) and (r.identifier == identifier[0]))] DCNL DCSP if (region is not None): DCNL DCSP  DCSP results = [r for r in results if ((r.region == region) and (r.identifier == identifier[0]))] DCNL DCSP if ((not all) and (len(results) > desired)): DCNL DCSP  DCSP message = ('Search: DCSP name DCSP %s DCSP type DCSP %s' % (name, type)) DCNL DCSP  DCSP message += '\nFound: DCSP ' DCNL DCSP  DCSP message += ', DCSP '.join([('%s DCSP %s DCSP %s' % (r.name, r.type, r.to_print())) for r in results]) DCNL DCSP  DCSP raise TooManyRecordsException(message) DCNL DCSP elif (len(results) > 1): DCNL DCSP  DCSP return results DCNL DCSP elif (len(results) == 1): DCNL DCSP  DCSP return results[0] DCNL DCSP else: DCNL DCSP  DCSP return None
def get_cname(self, name, all=False): DCNL DCSP return self.find_records(name, 'CNAME', all=all)
def get_a(self, name, all=False): DCNL DCSP return self.find_records(name, 'A', all=all)
def get_mx(self, name, all=False): DCNL DCSP return self.find_records(name, 'MX', all=all)
def update_cname(self, name, value, ttl=None, identifier=None, comment=''): DCNL DCSP name = self.route53connection._make_qualified(name) DCNL DCSP value = self.route53connection._make_qualified(value) DCNL DCSP old_record = self.get_cname(name) DCNL DCSP ttl = (ttl or old_record.ttl) DCNL DCSP return self.update_record(old_record, new_value=value, new_ttl=ttl, new_identifier=identifier, comment=comment)
def update_a(self, name, value, ttl=None, identifier=None, comment=''): DCNL DCSP name = self.route53connection._make_qualified(name) DCNL DCSP old_record = self.get_a(name) DCNL DCSP ttl = (ttl or old_record.ttl) DCNL DCSP return self.update_record(old_record, new_value=value, new_ttl=ttl, new_identifier=identifier, comment=comment)
def update_mx(self, name, value, ttl=None, identifier=None, comment=''): DCNL DCSP name = self.route53connection._make_qualified(name) DCNL DCSP value = self.route53connection._make_qualified(value) DCNL DCSP old_record = self.get_mx(name) DCNL DCSP ttl = (ttl or old_record.ttl) DCNL DCSP return self.update_record(old_record, new_value=value, new_ttl=ttl, new_identifier=identifier, comment=comment)
def delete_cname(self, name, identifier=None, all=False): DCNL DCSP name = self.route53connection._make_qualified(name) DCNL DCSP record = self.find_records(name, 'CNAME', identifier=identifier, all=all) DCNL DCSP return self.delete_record(record)
def delete_a(self, name, identifier=None, all=False): DCNL DCSP name = self.route53connection._make_qualified(name) DCNL DCSP record = self.find_records(name, 'A', identifier=identifier, all=all) DCNL DCSP return self.delete_record(record)
def delete_mx(self, name, identifier=None, all=False): DCNL DCSP name = self.route53connection._make_qualified(name) DCNL DCSP record = self.find_records(name, 'MX', identifier=identifier, all=all) DCNL DCSP return self.delete_record(record)
def get_records(self): DCNL DCSP return self.route53connection.get_all_rrsets(self.id)
def delete(self): DCNL DCSP self.route53connection.delete_hosted_zone(self.id)
def get_nameservers(self): DCNL DCSP ns = self.find_records(self.name, 'NS') DCNL DCSP if (ns is not None): DCNL DCSP  DCSP ns = ns.resource_records DCNL DCSP return ns
def check_domain_availability(self, domain_name, idn_lang_code=None): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if (idn_lang_code is not None): DCNL DCSP  DCSP params['IdnLangCode'] = idn_lang_code DCNL DCSP return self.make_request(action='CheckDomainAvailability', body=json.dumps(params))
def disable_domain_transfer_lock(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.make_request(action='DisableDomainTransferLock', body=json.dumps(params))
def enable_domain_transfer_lock(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.make_request(action='EnableDomainTransferLock', body=json.dumps(params))
def get_domain_detail(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.make_request(action='GetDomainDetail', body=json.dumps(params))
def get_operation_detail(self, operation_id): DCNL DCSP params = {'OperationId': operation_id} DCNL DCSP return self.make_request(action='GetOperationDetail', body=json.dumps(params))
def list_domains(self, marker=None, max_items=None): DCNL DCSP params = {} DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.make_request(action='ListDomains', body=json.dumps(params))
def list_operations(self, marker=None, max_items=None): DCNL DCSP params = {} DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.make_request(action='ListOperations', body=json.dumps(params))
def register_domain(self, domain_name, duration_in_years, admin_contact, registrant_contact, tech_contact, idn_lang_code=None, auto_renew=None, privacy_protect_admin_contact=None, privacy_protect_registrant_contact=None, privacy_protect_tech_contact=None): DCNL DCSP params = {'DomainName': domain_name, 'DurationInYears': duration_in_years, 'AdminContact': admin_contact, 'RegistrantContact': registrant_contact, 'TechContact': tech_contact} DCNL DCSP if (idn_lang_code is not None): DCNL DCSP  DCSP params['IdnLangCode'] = idn_lang_code DCNL DCSP if (auto_renew is not None): DCNL DCSP  DCSP params['AutoRenew'] = auto_renew DCNL DCSP if (privacy_protect_admin_contact is not None): DCNL DCSP  DCSP params['PrivacyProtectAdminContact'] = privacy_protect_admin_contact DCNL DCSP if (privacy_protect_registrant_contact is not None): DCNL DCSP  DCSP params['PrivacyProtectRegistrantContact'] = privacy_protect_registrant_contact DCNL DCSP if (privacy_protect_tech_contact is not None): DCNL DCSP  DCSP params['PrivacyProtectTechContact'] = privacy_protect_tech_contact DCNL DCSP return self.make_request(action='RegisterDomain', body=json.dumps(params))
def retrieve_domain_auth_code(self, domain_name): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.make_request(action='RetrieveDomainAuthCode', body=json.dumps(params))
def transfer_domain(self, domain_name, duration_in_years, nameservers, admin_contact, registrant_contact, tech_contact, idn_lang_code=None, auth_code=None, auto_renew=None, privacy_protect_admin_contact=None, privacy_protect_registrant_contact=None, privacy_protect_tech_contact=None): DCNL DCSP params = {'DomainName': domain_name, 'DurationInYears': duration_in_years, 'Nameservers': nameservers, 'AdminContact': admin_contact, 'RegistrantContact': registrant_contact, 'TechContact': tech_contact} DCNL DCSP if (idn_lang_code is not None): DCNL DCSP  DCSP params['IdnLangCode'] = idn_lang_code DCNL DCSP if (auth_code is not None): DCNL DCSP  DCSP params['AuthCode'] = auth_code DCNL DCSP if (auto_renew is not None): DCNL DCSP  DCSP params['AutoRenew'] = auto_renew DCNL DCSP if (privacy_protect_admin_contact is not None): DCNL DCSP  DCSP params['PrivacyProtectAdminContact'] = privacy_protect_admin_contact DCNL DCSP if (privacy_protect_registrant_contact is not None): DCNL DCSP  DCSP params['PrivacyProtectRegistrantContact'] = privacy_protect_registrant_contact DCNL DCSP if (privacy_protect_tech_contact is not None): DCNL DCSP  DCSP params['PrivacyProtectTechContact'] = privacy_protect_tech_contact DCNL DCSP return self.make_request(action='TransferDomain', body=json.dumps(params))
def update_domain_contact(self, domain_name, admin_contact=None, registrant_contact=None, tech_contact=None): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if (admin_contact is not None): DCNL DCSP  DCSP params['AdminContact'] = admin_contact DCNL DCSP if (registrant_contact is not None): DCNL DCSP  DCSP params['RegistrantContact'] = registrant_contact DCNL DCSP if (tech_contact is not None): DCNL DCSP  DCSP params['TechContact'] = tech_contact DCNL DCSP return self.make_request(action='UpdateDomainContact', body=json.dumps(params))
def update_domain_contact_privacy(self, domain_name, admin_privacy=None, registrant_privacy=None, tech_privacy=None): DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if (admin_privacy is not None): DCNL DCSP  DCSP params['AdminPrivacy'] = admin_privacy DCNL DCSP if (registrant_privacy is not None): DCNL DCSP  DCSP params['RegistrantPrivacy'] = registrant_privacy DCNL DCSP if (tech_privacy is not None): DCNL DCSP  DCSP params['TechPrivacy'] = tech_privacy DCNL DCSP return self.make_request(action='UpdateDomainContactPrivacy', body=json.dumps(params))
def update_domain_nameservers(self, domain_name, nameservers): DCNL DCSP params = {'DomainName': domain_name, 'Nameservers': nameservers} DCNL DCSP return self.make_request(action='UpdateDomainNameservers', body=json.dumps(params))
def add_change(self, action, name, type, ttl=600, alias_hosted_zone_id=None, alias_dns_name=None, identifier=None, weight=None, region=None, alias_evaluate_target_health=None, health_check=None, failover=None): DCNL DCSP change = Record(name, type, ttl, alias_hosted_zone_id=alias_hosted_zone_id, alias_dns_name=alias_dns_name, identifier=identifier, weight=weight, region=region, alias_evaluate_target_health=alias_evaluate_target_health, health_check=health_check, failover=failover) DCNL DCSP self.changes.append([action, change]) DCNL DCSP return change
def add_change_record(self, action, change): DCNL DCSP self.changes.append([action, change]) DCNL DCSP return
def to_xml(self): DCNL DCSP changesXML = '' DCNL DCSP for change in self.changes: DCNL DCSP  DCSP changeParams = {'action': change[0], 'record': change[1].to_xml()} DCNL DCSP  DCSP changesXML += (self.ChangeXML % changeParams) DCNL DCSP params = {'comment': self.comment, 'changes': changesXML} DCNL DCSP return (self.ChangeResourceRecordSetsBody % params)
def commit(self): DCNL DCSP if (not self.connection): DCNL DCSP  DCSP import boto DCNL DCSP  DCSP self.connection = boto.connect_route53() DCNL DCSP return self.connection.change_rrsets(self.hosted_zone_id, self.to_xml())
def endElement(self, name, value, connection): DCNL DCSP if (name == 'NextRecordName'): DCNL DCSP  DCSP self.next_record_name = value DCNL DCSP elif (name == 'NextRecordType'): DCNL DCSP  DCSP self.next_record_type = value DCNL DCSP elif (name == 'NextRecordIdentifier'): DCNL DCSP  DCSP self.next_record_identifier = value DCNL DCSP else: DCNL DCSP  DCSP return super(ResourceRecordSets, self).endElement(name, value, connection)
def __iter__(self): DCNL DCSP results = super(ResourceRecordSets, self).__iter__() DCNL DCSP truncated = self.is_truncated DCNL DCSP while results: DCNL DCSP  DCSP for obj in results: DCNL DCSP  DCSP  DCSP (yield obj) DCNL DCSP  DCSP if self.is_truncated: DCNL DCSP  DCSP  DCSP self.is_truncated = False DCNL DCSP  DCSP  DCSP results = self.connection.get_all_rrsets(self.hosted_zone_id, name=self.next_record_name, type=self.next_record_type, identifier=self.next_record_identifier) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results = None DCNL DCSP  DCSP  DCSP self.is_truncated = truncated
def add_value(self, value): DCNL DCSP self.resource_records.append(value)
def set_alias(self, alias_hosted_zone_id, alias_dns_name, alias_evaluate_target_health=False): DCNL DCSP self.alias_hosted_zone_id = alias_hosted_zone_id DCNL DCSP self.alias_dns_name = alias_dns_name DCNL DCSP self.alias_evaluate_target_health = alias_evaluate_target_health
def to_xml(self): DCNL DCSP if ((self.alias_hosted_zone_id is not None) and (self.alias_dns_name is not None)): DCNL DCSP  DCSP if (self.alias_evaluate_target_health is not None): DCNL DCSP  DCSP  DCSP eval_target_health = (self.EvaluateTargetHealth % ('true' if self.alias_evaluate_target_health else 'false')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP eval_target_health = '' DCNL DCSP  DCSP body = (self.AliasBody % {'hosted_zone_id': self.alias_hosted_zone_id, 'dns_name': self.alias_dns_name, 'eval_target_health': eval_target_health}) DCNL DCSP else: DCNL DCSP  DCSP records = '' DCNL DCSP  DCSP for r in self.resource_records: DCNL DCSP  DCSP  DCSP records += (self.ResourceRecordBody % r) DCNL DCSP  DCSP body = (self.ResourceRecordsBody % {'ttl': self.ttl, 'records': records}) DCNL DCSP weight = '' DCNL DCSP if ((self.identifier is not None) and (self.weight is not None)): DCNL DCSP  DCSP weight = (self.WRRBody % {'identifier': self.identifier, 'weight': self.weight}) DCNL DCSP elif ((self.identifier is not None) and (self.region is not None)): DCNL DCSP  DCSP weight = (self.RRRBody % {'identifier': self.identifier, 'region': self.region}) DCNL DCSP elif ((self.identifier is not None) and (self.failover is not None)): DCNL DCSP  DCSP weight = (self.FailoverBody % {'identifier': self.identifier, 'failover': self.failover}) DCNL DCSP health_check = '' DCNL DCSP if (self.health_check is not None): DCNL DCSP  DCSP health_check = (self.HealthCheckBody % self.health_check) DCNL DCSP params = {'name': self.name, 'type': self.type, 'weight': weight, 'body': body, 'health_check': health_check} DCNL DCSP return (self.XMLBody % params)
def __init__(self): DCNL DCSP raise BotoClientError('Attempt DCSP to DCSP instantiate DCSP abstract DCSP StorageUri DCSP class')
def __repr__(self): DCNL DCSP return self.uri
def equals(self, uri): DCNL DCSP return (self.uri == uri.uri)
def connect(self, access_key_id=None, secret_access_key=None, **kwargs): DCNL DCSP connection_args = dict((self.connection_args or ())) DCNL DCSP if (hasattr(self, 'suppress_consec_slashes') and ('suppress_consec_slashes' not in connection_args)): DCNL DCSP  DCSP connection_args['suppress_consec_slashes'] = self.suppress_consec_slashes DCNL DCSP connection_args.update(kwargs) DCNL DCSP if (not self.connection): DCNL DCSP  DCSP if (self.scheme in self.provider_pool): DCNL DCSP  DCSP  DCSP self.connection = self.provider_pool[self.scheme] DCNL DCSP  DCSP elif (self.scheme == 's3'): DCNL DCSP  DCSP  DCSP from boto.s3.connection import S3Connection DCNL DCSP  DCSP  DCSP self.connection = S3Connection(access_key_id, secret_access_key, **connection_args) DCNL DCSP  DCSP  DCSP self.provider_pool[self.scheme] = self.connection DCNL DCSP  DCSP elif (self.scheme == 'gs'): DCNL DCSP  DCSP  DCSP from boto.gs.connection import GSConnection DCNL DCSP  DCSP  DCSP from boto.s3.connection import OrdinaryCallingFormat DCNL DCSP  DCSP  DCSP connection_args['calling_format'] = OrdinaryCallingFormat() DCNL DCSP  DCSP  DCSP self.connection = GSConnection(access_key_id, secret_access_key, **connection_args) DCNL DCSP  DCSP  DCSP self.provider_pool[self.scheme] = self.connection DCNL DCSP  DCSP elif (self.scheme == 'file'): DCNL DCSP  DCSP  DCSP from boto.file.connection import FileConnection DCNL DCSP  DCSP  DCSP self.connection = FileConnection(self) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InvalidUriError(('Unrecognized DCSP scheme DCSP "%s"' % self.scheme)) DCNL DCSP self.connection.debug = self.debug DCNL DCSP return self.connection
def __init__(self, scheme, bucket_name=None, object_name=None, debug=0, connection_args=None, suppress_consec_slashes=True, version_id=None, generation=None, is_latest=False): DCNL DCSP self.scheme = scheme DCNL DCSP self.bucket_name = bucket_name DCNL DCSP self.object_name = object_name DCNL DCSP self.debug = debug DCNL DCSP if connection_args: DCNL DCSP  DCSP self.connection_args = connection_args DCNL DCSP self.suppress_consec_slashes = suppress_consec_slashes DCNL DCSP self.version_id = version_id DCNL DCSP self.generation = (generation and int(generation)) DCNL DCSP self.is_latest = is_latest DCNL DCSP self.is_version_specific = (bool(self.generation) or bool(version_id)) DCNL DCSP self._build_uri_strings()
def clone_replace_name(self, new_name): DCNL DCSP self._check_bucket_uri('clone_replace_name') DCNL DCSP return BucketStorageUri(self.scheme, bucket_name=self.bucket_name, object_name=new_name, debug=self.debug, suppress_consec_slashes=self.suppress_consec_slashes)
def clone_replace_key(self, key): DCNL DCSP self._check_bucket_uri('clone_replace_key') DCNL DCSP version_id = None DCNL DCSP generation = None DCNL DCSP is_latest = False DCNL DCSP if hasattr(key, 'version_id'): DCNL DCSP  DCSP version_id = key.version_id DCNL DCSP if hasattr(key, 'generation'): DCNL DCSP  DCSP generation = key.generation DCNL DCSP if hasattr(key, 'is_latest'): DCNL DCSP  DCSP is_latest = key.is_latest DCNL DCSP return BucketStorageUri(key.provider.get_provider_name(), bucket_name=key.bucket.name, object_name=key.name, debug=self.debug, suppress_consec_slashes=self.suppress_consec_slashes, version_id=version_id, generation=generation, is_latest=is_latest)
def get_acl(self, validate=False, headers=None, version_id=None): DCNL DCSP self._check_bucket_uri('get_acl') DCNL DCSP bucket = self.get_bucket(validate, headers) DCNL DCSP key_name = (self.object_name or '') DCNL DCSP if (self.get_provider().name == 'aws'): DCNL DCSP  DCSP version_id = (version_id or self.version_id) DCNL DCSP  DCSP acl = bucket.get_acl(key_name, headers, version_id) DCNL DCSP else: DCNL DCSP  DCSP acl = bucket.get_acl(key_name, headers, generation=self.generation) DCNL DCSP self.check_response(acl, 'acl', self.uri) DCNL DCSP return acl
def get_def_acl(self, validate=False, headers=None): DCNL DCSP self._check_bucket_uri('get_def_acl') DCNL DCSP bucket = self.get_bucket(validate, headers) DCNL DCSP acl = bucket.get_def_acl(headers) DCNL DCSP self.check_response(acl, 'acl', self.uri) DCNL DCSP return acl
def get_cors(self, validate=False, headers=None): DCNL DCSP self._check_bucket_uri('get_cors') DCNL DCSP bucket = self.get_bucket(validate, headers) DCNL DCSP cors = bucket.get_cors(headers) DCNL DCSP self.check_response(cors, 'cors', self.uri) DCNL DCSP return cors
def set_cors(self, cors, validate=False, headers=None): DCNL DCSP self._check_bucket_uri('set_cors DCSP ') DCNL DCSP bucket = self.get_bucket(validate, headers) DCNL DCSP if (self.scheme == 's3'): DCNL DCSP  DCSP bucket.set_cors(cors, headers) DCNL DCSP else: DCNL DCSP  DCSP bucket.set_cors(cors.to_xml(), headers)
def set_storage_class(self, storage_class, validate=False, headers=None): DCNL DCSP self._check_bucket_uri('set_storage_class') DCNL DCSP if (self.scheme != 'gs'): DCNL DCSP  DCSP raise ValueError(('set_storage_class() DCSP not DCSP supported DCSP for DCSP %s DCSP URIs.' % self.scheme)) DCNL DCSP bucket = self.get_bucket(validate, headers) DCNL DCSP bucket.set_storage_class(storage_class, headers)
def is_file_uri(self): DCNL DCSP return False
def is_cloud_uri(self): DCNL DCSP return True
def names_container(self): DCNL DCSP return bool((not self.object_name))
def names_singleton(self): DCNL DCSP return bool(self.object_name)
def names_directory(self): DCNL DCSP return False
def names_provider(self): DCNL DCSP return bool((not self.bucket_name))
def names_bucket(self): DCNL DCSP return (bool(self.bucket_name) and bool((not self.object_name)))
def names_file(self): DCNL DCSP return False
def names_object(self): DCNL DCSP return self.names_singleton()
def is_stream(self): DCNL DCSP return False
def set_acl(self, acl_or_str, key_name='', validate=False, headers=None, version_id=None, if_generation=None, if_metageneration=None): DCNL DCSP self._check_bucket_uri('set_acl') DCNL DCSP key_name = (key_name or self.object_name or '') DCNL DCSP bucket = self.get_bucket(validate, headers) DCNL DCSP if self.generation: DCNL DCSP  DCSP bucket.set_acl(acl_or_str, key_name, headers, generation=self.generation, if_generation=if_generation, if_metageneration=if_metageneration) DCNL DCSP else: DCNL DCSP  DCSP version_id = (version_id or self.version_id) DCNL DCSP  DCSP bucket.set_acl(acl_or_str, key_name, headers, version_id)
def set_xml_acl(self, xmlstring, key_name='', validate=False, headers=None, version_id=None, if_generation=None, if_metageneration=None): DCNL DCSP self._check_bucket_uri('set_xml_acl') DCNL DCSP key_name = (key_name or self.object_name or '') DCNL DCSP bucket = self.get_bucket(validate, headers) DCNL DCSP if self.generation: DCNL DCSP  DCSP bucket.set_xml_acl(xmlstring, key_name, headers, generation=self.generation, if_generation=if_generation, if_metageneration=if_metageneration) DCNL DCSP else: DCNL DCSP  DCSP version_id = (version_id or self.version_id) DCNL DCSP  DCSP bucket.set_xml_acl(xmlstring, key_name, headers, version_id=version_id)
def set_def_xml_acl(self, xmlstring, validate=False, headers=None): DCNL DCSP self._check_bucket_uri('set_def_xml_acl') DCNL DCSP self.get_bucket(validate, headers).set_def_xml_acl(xmlstring, headers)
def set_def_acl(self, acl_or_str, validate=False, headers=None, version_id=None): DCNL DCSP self._check_bucket_uri('set_def_acl') DCNL DCSP self.get_bucket(validate, headers).set_def_acl(acl_or_str, headers)
def set_canned_acl(self, acl_str, validate=False, headers=None, version_id=None): DCNL DCSP self._check_object_uri('set_canned_acl') DCNL DCSP self._warn_about_args('set_canned_acl', version_id=version_id) DCNL DCSP key = self.get_key(validate, headers) DCNL DCSP self.check_response(key, 'key', self.uri) DCNL DCSP key.set_canned_acl(acl_str, headers)
def set_def_canned_acl(self, acl_str, validate=False, headers=None, version_id=None): DCNL DCSP self._check_bucket_uri('set_def_canned_acl DCSP ') DCNL DCSP key = self.get_key(validate, headers) DCNL DCSP self.check_response(key, 'key', self.uri) DCNL DCSP key.set_def_canned_acl(acl_str, headers, version_id)
def copy_key(self, src_bucket_name, src_key_name, metadata=None, src_version_id=None, storage_class='STANDARD', preserve_acl=False, encrypt_key=False, headers=None, query_args=None, src_generation=None): DCNL DCSP self._check_object_uri('copy_key') DCNL DCSP dst_bucket = self.get_bucket(validate=False, headers=headers) DCNL DCSP if src_generation: DCNL DCSP  DCSP return dst_bucket.copy_key(new_key_name=self.object_name, src_bucket_name=src_bucket_name, src_key_name=src_key_name, metadata=metadata, storage_class=storage_class, preserve_acl=preserve_acl, encrypt_key=encrypt_key, headers=headers, query_args=query_args, src_generation=src_generation) DCNL DCSP else: DCNL DCSP  DCSP return dst_bucket.copy_key(new_key_name=self.object_name, src_bucket_name=src_bucket_name, src_key_name=src_key_name, metadata=metadata, src_version_id=src_version_id, storage_class=storage_class, preserve_acl=preserve_acl, encrypt_key=encrypt_key, headers=headers, query_args=query_args)
def get_lifecycle_config(self, validate=False, headers=None): DCNL DCSP self._check_bucket_uri('get_lifecycle_config') DCNL DCSP bucket = self.get_bucket(validate, headers) DCNL DCSP lifecycle_config = bucket.get_lifecycle_config(headers) DCNL DCSP self.check_response(lifecycle_config, 'lifecycle', self.uri) DCNL DCSP return lifecycle_config
def configure_lifecycle(self, lifecycle_config, validate=False, headers=None): DCNL DCSP self._check_bucket_uri('configure_lifecycle') DCNL DCSP bucket = self.get_bucket(validate, headers) DCNL DCSP bucket.configure_lifecycle(lifecycle_config, headers)
def exists(self, headers=None): DCNL DCSP if (not self.object_name): DCNL DCSP  DCSP raise InvalidUriError(('exists DCSP on DCSP object-less DCSP URI DCSP (%s)' % self.uri)) DCNL DCSP bucket = self.get_bucket() DCNL DCSP key = bucket.get_key(self.object_name, headers=headers) DCNL DCSP return bool(key)
def __init__(self, object_name, debug, is_stream=False): DCNL DCSP self.scheme = 'file' DCNL DCSP self.bucket_name = '' DCNL DCSP self.object_name = object_name DCNL DCSP self.uri = ('file://' + object_name) DCNL DCSP self.debug = debug DCNL DCSP self.stream = is_stream
def clone_replace_name(self, new_name): DCNL DCSP return FileStorageUri(new_name, self.debug, self.stream)
def is_file_uri(self): DCNL DCSP return True
def is_cloud_uri(self): DCNL DCSP return False
def names_container(self): DCNL DCSP return self.names_directory()
def names_singleton(self): DCNL DCSP return (not self.names_container())
def names_directory(self): DCNL DCSP if self.stream: DCNL DCSP  DCSP return False DCNL DCSP return os.path.isdir(self.object_name)
def names_provider(self): DCNL DCSP return False
def names_bucket(self): DCNL DCSP return False
def names_file(self): DCNL DCSP return self.names_singleton()
def names_object(self): DCNL DCSP return False
def is_stream(self): DCNL DCSP return bool(self.stream)
def close(self): DCNL DCSP self.get_key().close()
def exists(self, _headers_not_used=None): DCNL DCSP return os.path.exists(self.object_name)
def search(self, query, cursor=None, expr=None, facet=None, filter_query=None, highlight=None, partial=None, query_options=None, query_parser=None, ret=None, size=None, sort=None, start=None): DCNL DCSP uri = '/2013-01-01/search' DCNL DCSP params = {} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (cursor is not None): DCNL DCSP  DCSP query_params['cursor'] = cursor DCNL DCSP if (expr is not None): DCNL DCSP  DCSP query_params['expr'] = expr DCNL DCSP if (facet is not None): DCNL DCSP  DCSP query_params['facet'] = facet DCNL DCSP if (filter_query is not None): DCNL DCSP  DCSP query_params['fq'] = filter_query DCNL DCSP if (highlight is not None): DCNL DCSP  DCSP query_params['highlight'] = highlight DCNL DCSP if (partial is not None): DCNL DCSP  DCSP query_params['partial'] = partial DCNL DCSP if (query is not None): DCNL DCSP  DCSP query_params['q'] = query DCNL DCSP if (query_options is not None): DCNL DCSP  DCSP query_params['q.options'] = query_options DCNL DCSP if (query_parser is not None): DCNL DCSP  DCSP query_params['q.parser'] = query_parser DCNL DCSP if (ret is not None): DCNL DCSP  DCSP query_params['return'] = ret DCNL DCSP if (size is not None): DCNL DCSP  DCSP query_params['size'] = size DCNL DCSP if (sort is not None): DCNL DCSP  DCSP query_params['sort'] = sort DCNL DCSP if (start is not None): DCNL DCSP  DCSP query_params['start'] = start DCNL DCSP return self.make_request('POST', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def suggest(self, query, suggester, size=None): DCNL DCSP uri = '/2013-01-01/suggest' DCNL DCSP params = {} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (query is not None): DCNL DCSP  DCSP query_params['q'] = query DCNL DCSP if (suggester is not None): DCNL DCSP  DCSP query_params['suggester'] = suggester DCNL DCSP if (size is not None): DCNL DCSP  DCSP query_params['size'] = size DCNL DCSP return self.make_request('GET', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def upload_documents(self, documents, content_type): DCNL DCSP uri = '/2013-01-01/documents/batch' DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP headers['Content-Type'] = content_type DCNL DCSP return self.make_request('POST', uri, expected_status=200, data=documents, headers=headers, params=query_params)
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', converter=None, validate_certs=True, anon=False, security_token=None, profile_name=None): DCNL DCSP if (not region): DCNL DCSP  DCSP region = RegionInfo(self, self.DefaultRegionName, self.DefaultRegionEndpoint, connection_cls=STSConnection) DCNL DCSP self.region = region DCNL DCSP self.anon = anon DCNL DCSP self._mutex = threading.Semaphore() DCNL DCSP provider = 'aws' DCNL DCSP if self.anon: DCNL DCSP  DCSP provider = Provider('aws', NO_CREDENTIALS_PROVIDED, NO_CREDENTIALS_PROVIDED, NO_CREDENTIALS_PROVIDED) DCNL DCSP super(STSConnection, self).__init__(aws_access_key_id, aws_secret_access_key, is_secure, port, proxy, proxy_port, proxy_user, proxy_pass, self.region.endpoint, debug, https_connection_factory, path, validate_certs=validate_certs, security_token=security_token, profile_name=profile_name, provider=provider)
def get_session_token(self, duration=None, force_new=False, mfa_serial_number=None, mfa_token=None): DCNL DCSP token_key = ('%s:%s' % (self.region.name, self.provider.access_key)) DCNL DCSP token = self._check_token_cache(token_key, duration) DCNL DCSP if (force_new or (not token)): DCNL DCSP  DCSP boto.log.debug(('fetching DCSP a DCSP new DCSP token DCSP for DCSP %s' % token_key)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self._mutex.acquire() DCNL DCSP  DCSP  DCSP token = self._get_session_token(duration, mfa_serial_number, mfa_token) DCNL DCSP  DCSP  DCSP _session_token_cache[token_key] = token DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP self._mutex.release() DCNL DCSP return token
def get_federation_token(self, name, duration=None, policy=None): DCNL DCSP params = {'Name': name} DCNL DCSP if duration: DCNL DCSP  DCSP params['DurationSeconds'] = duration DCNL DCSP if policy: DCNL DCSP  DCSP params['Policy'] = policy DCNL DCSP return self.get_object('GetFederationToken', params, FederationToken, verb='POST')
def assume_role(self, role_arn, role_session_name, policy=None, duration_seconds=None, external_id=None, mfa_serial_number=None, mfa_token=None): DCNL DCSP params = {'RoleArn': role_arn, 'RoleSessionName': role_session_name} DCNL DCSP if (policy is not None): DCNL DCSP  DCSP params['Policy'] = policy DCNL DCSP if (duration_seconds is not None): DCNL DCSP  DCSP params['DurationSeconds'] = duration_seconds DCNL DCSP if (external_id is not None): DCNL DCSP  DCSP params['ExternalId'] = external_id DCNL DCSP if (mfa_serial_number is not None): DCNL DCSP  DCSP params['SerialNumber'] = mfa_serial_number DCNL DCSP if (mfa_token is not None): DCNL DCSP  DCSP params['TokenCode'] = mfa_token DCNL DCSP return self.get_object('AssumeRole', params, AssumedRole, verb='POST')
def assume_role_with_saml(self, role_arn, principal_arn, saml_assertion, policy=None, duration_seconds=None): DCNL DCSP params = {'RoleArn': role_arn, 'PrincipalArn': principal_arn, 'SAMLAssertion': saml_assertion} DCNL DCSP if (policy is not None): DCNL DCSP  DCSP params['Policy'] = policy DCNL DCSP if (duration_seconds is not None): DCNL DCSP  DCSP params['DurationSeconds'] = duration_seconds DCNL DCSP return self.get_object('AssumeRoleWithSAML', params, AssumedRole, verb='POST')
def assume_role_with_web_identity(self, role_arn, role_session_name, web_identity_token, provider_id=None, policy=None, duration_seconds=None): DCNL DCSP params = {'RoleArn': role_arn, 'RoleSessionName': role_session_name, 'WebIdentityToken': web_identity_token} DCNL DCSP if (provider_id is not None): DCNL DCSP  DCSP params['ProviderId'] = provider_id DCNL DCSP if (policy is not None): DCNL DCSP  DCSP params['Policy'] = policy DCNL DCSP if (duration_seconds is not None): DCNL DCSP  DCSP params['DurationSeconds'] = duration_seconds DCNL DCSP return self.get_object('AssumeRoleWithWebIdentity', params, AssumedRole, verb='POST')
def decode_authorization_message(self, encoded_message): DCNL DCSP params = {'EncodedMessage': encoded_message} DCNL DCSP return self.get_object('DecodeAuthorizationMessage', params, DecodeAuthorizationMessage, verb='POST')
@classmethod DCNL def from_json(cls, json_doc): DCNL DCSP d = json.loads(json_doc) DCNL DCSP token = cls() DCNL DCSP token.__dict__.update(d) DCNL DCSP return token
@classmethod DCNL def load(cls, file_path): DCNL DCSP fp = open(file_path) DCNL DCSP json_doc = fp.read() DCNL DCSP fp.close() DCNL DCSP return cls.from_json(json_doc)
def to_dict(self): DCNL DCSP return {'access_key': self.access_key, 'secret_key': self.secret_key, 'session_token': self.session_token, 'expiration': self.expiration, 'request_id': self.request_id}
def save(self, file_path): DCNL DCSP fp = open(file_path, 'w') DCNL DCSP json.dump(self.to_dict(), fp) DCNL DCSP fp.close() DCNL DCSP os.chmod(file_path, 384)
def is_expired(self, time_offset_seconds=0): DCNL DCSP now = datetime.datetime.utcnow() DCNL DCSP if time_offset_seconds: DCNL DCSP  DCSP now = (now + datetime.timedelta(seconds=time_offset_seconds)) DCNL DCSP ts = boto.utils.parse_ts(self.expiration) DCNL DCSP delta = (ts - now) DCNL DCSP return (delta.total_seconds() <= 0)
def create_batch_prediction(self, batch_prediction_id, ml_model_id, batch_prediction_data_source_id, output_uri, batch_prediction_name=None): DCNL DCSP params = {'BatchPredictionId': batch_prediction_id, 'MLModelId': ml_model_id, 'BatchPredictionDataSourceId': batch_prediction_data_source_id, 'OutputUri': output_uri} DCNL DCSP if (batch_prediction_name is not None): DCNL DCSP  DCSP params['BatchPredictionName'] = batch_prediction_name DCNL DCSP return self.make_request(action='CreateBatchPrediction', body=json.dumps(params))
def create_data_source_from_rds(self, data_source_id, rds_data, role_arn, data_source_name=None, compute_statistics=None): DCNL DCSP params = {'DataSourceId': data_source_id, 'RDSData': rds_data, 'RoleARN': role_arn} DCNL DCSP if (data_source_name is not None): DCNL DCSP  DCSP params['DataSourceName'] = data_source_name DCNL DCSP if (compute_statistics is not None): DCNL DCSP  DCSP params['ComputeStatistics'] = compute_statistics DCNL DCSP return self.make_request(action='CreateDataSourceFromRDS', body=json.dumps(params))
def create_data_source_from_redshift(self, data_source_id, data_spec, role_arn, data_source_name=None, compute_statistics=None): DCNL DCSP params = {'DataSourceId': data_source_id, 'DataSpec': data_spec, 'RoleARN': role_arn} DCNL DCSP if (data_source_name is not None): DCNL DCSP  DCSP params['DataSourceName'] = data_source_name DCNL DCSP if (compute_statistics is not None): DCNL DCSP  DCSP params['ComputeStatistics'] = compute_statistics DCNL DCSP return self.make_request(action='CreateDataSourceFromRedshift', body=json.dumps(params))
def create_data_source_from_s3(self, data_source_id, data_spec, data_source_name=None, compute_statistics=None): DCNL DCSP params = {'DataSourceId': data_source_id, 'DataSpec': data_spec} DCNL DCSP if (data_source_name is not None): DCNL DCSP  DCSP params['DataSourceName'] = data_source_name DCNL DCSP if (compute_statistics is not None): DCNL DCSP  DCSP params['ComputeStatistics'] = compute_statistics DCNL DCSP return self.make_request(action='CreateDataSourceFromS3', body=json.dumps(params))
def create_evaluation(self, evaluation_id, ml_model_id, evaluation_data_source_id, evaluation_name=None): DCNL DCSP params = {'EvaluationId': evaluation_id, 'MLModelId': ml_model_id, 'EvaluationDataSourceId': evaluation_data_source_id} DCNL DCSP if (evaluation_name is not None): DCNL DCSP  DCSP params['EvaluationName'] = evaluation_name DCNL DCSP return self.make_request(action='CreateEvaluation', body=json.dumps(params))
def create_ml_model(self, ml_model_id, ml_model_type, training_data_source_id, ml_model_name=None, parameters=None, recipe=None, recipe_uri=None): DCNL DCSP params = {'MLModelId': ml_model_id, 'MLModelType': ml_model_type, 'TrainingDataSourceId': training_data_source_id} DCNL DCSP if (ml_model_name is not None): DCNL DCSP  DCSP params['MLModelName'] = ml_model_name DCNL DCSP if (parameters is not None): DCNL DCSP  DCSP params['Parameters'] = parameters DCNL DCSP if (recipe is not None): DCNL DCSP  DCSP params['Recipe'] = recipe DCNL DCSP if (recipe_uri is not None): DCNL DCSP  DCSP params['RecipeUri'] = recipe_uri DCNL DCSP return self.make_request(action='CreateMLModel', body=json.dumps(params))
def create_realtime_endpoint(self, ml_model_id): DCNL DCSP params = {'MLModelId': ml_model_id} DCNL DCSP return self.make_request(action='CreateRealtimeEndpoint', body=json.dumps(params))
def delete_batch_prediction(self, batch_prediction_id): DCNL DCSP params = {'BatchPredictionId': batch_prediction_id} DCNL DCSP return self.make_request(action='DeleteBatchPrediction', body=json.dumps(params))
def delete_data_source(self, data_source_id): DCNL DCSP params = {'DataSourceId': data_source_id} DCNL DCSP return self.make_request(action='DeleteDataSource', body=json.dumps(params))
def delete_evaluation(self, evaluation_id): DCNL DCSP params = {'EvaluationId': evaluation_id} DCNL DCSP return self.make_request(action='DeleteEvaluation', body=json.dumps(params))
def delete_ml_model(self, ml_model_id): DCNL DCSP params = {'MLModelId': ml_model_id} DCNL DCSP return self.make_request(action='DeleteMLModel', body=json.dumps(params))
def delete_realtime_endpoint(self, ml_model_id): DCNL DCSP params = {'MLModelId': ml_model_id} DCNL DCSP return self.make_request(action='DeleteRealtimeEndpoint', body=json.dumps(params))
def describe_batch_predictions(self, filter_variable=None, eq=None, gt=None, lt=None, ge=None, le=None, ne=None, prefix=None, sort_order=None, next_token=None, limit=None): DCNL DCSP params = {} DCNL DCSP if (filter_variable is not None): DCNL DCSP  DCSP params['FilterVariable'] = filter_variable DCNL DCSP if (eq is not None): DCNL DCSP  DCSP params['EQ'] = eq DCNL DCSP if (gt is not None): DCNL DCSP  DCSP params['GT'] = gt DCNL DCSP if (lt is not None): DCNL DCSP  DCSP params['LT'] = lt DCNL DCSP if (ge is not None): DCNL DCSP  DCSP params['GE'] = ge DCNL DCSP if (le is not None): DCNL DCSP  DCSP params['LE'] = le DCNL DCSP if (ne is not None): DCNL DCSP  DCSP params['NE'] = ne DCNL DCSP if (prefix is not None): DCNL DCSP  DCSP params['Prefix'] = prefix DCNL DCSP if (sort_order is not None): DCNL DCSP  DCSP params['SortOrder'] = sort_order DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP return self.make_request(action='DescribeBatchPredictions', body=json.dumps(params))
def describe_data_sources(self, filter_variable=None, eq=None, gt=None, lt=None, ge=None, le=None, ne=None, prefix=None, sort_order=None, next_token=None, limit=None): DCNL DCSP params = {} DCNL DCSP if (filter_variable is not None): DCNL DCSP  DCSP params['FilterVariable'] = filter_variable DCNL DCSP if (eq is not None): DCNL DCSP  DCSP params['EQ'] = eq DCNL DCSP if (gt is not None): DCNL DCSP  DCSP params['GT'] = gt DCNL DCSP if (lt is not None): DCNL DCSP  DCSP params['LT'] = lt DCNL DCSP if (ge is not None): DCNL DCSP  DCSP params['GE'] = ge DCNL DCSP if (le is not None): DCNL DCSP  DCSP params['LE'] = le DCNL DCSP if (ne is not None): DCNL DCSP  DCSP params['NE'] = ne DCNL DCSP if (prefix is not None): DCNL DCSP  DCSP params['Prefix'] = prefix DCNL DCSP if (sort_order is not None): DCNL DCSP  DCSP params['SortOrder'] = sort_order DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP return self.make_request(action='DescribeDataSources', body=json.dumps(params))
def describe_evaluations(self, filter_variable=None, eq=None, gt=None, lt=None, ge=None, le=None, ne=None, prefix=None, sort_order=None, next_token=None, limit=None): DCNL DCSP params = {} DCNL DCSP if (filter_variable is not None): DCNL DCSP  DCSP params['FilterVariable'] = filter_variable DCNL DCSP if (eq is not None): DCNL DCSP  DCSP params['EQ'] = eq DCNL DCSP if (gt is not None): DCNL DCSP  DCSP params['GT'] = gt DCNL DCSP if (lt is not None): DCNL DCSP  DCSP params['LT'] = lt DCNL DCSP if (ge is not None): DCNL DCSP  DCSP params['GE'] = ge DCNL DCSP if (le is not None): DCNL DCSP  DCSP params['LE'] = le DCNL DCSP if (ne is not None): DCNL DCSP  DCSP params['NE'] = ne DCNL DCSP if (prefix is not None): DCNL DCSP  DCSP params['Prefix'] = prefix DCNL DCSP if (sort_order is not None): DCNL DCSP  DCSP params['SortOrder'] = sort_order DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP return self.make_request(action='DescribeEvaluations', body=json.dumps(params))
def describe_ml_models(self, filter_variable=None, eq=None, gt=None, lt=None, ge=None, le=None, ne=None, prefix=None, sort_order=None, next_token=None, limit=None): DCNL DCSP params = {} DCNL DCSP if (filter_variable is not None): DCNL DCSP  DCSP params['FilterVariable'] = filter_variable DCNL DCSP if (eq is not None): DCNL DCSP  DCSP params['EQ'] = eq DCNL DCSP if (gt is not None): DCNL DCSP  DCSP params['GT'] = gt DCNL DCSP if (lt is not None): DCNL DCSP  DCSP params['LT'] = lt DCNL DCSP if (ge is not None): DCNL DCSP  DCSP params['GE'] = ge DCNL DCSP if (le is not None): DCNL DCSP  DCSP params['LE'] = le DCNL DCSP if (ne is not None): DCNL DCSP  DCSP params['NE'] = ne DCNL DCSP if (prefix is not None): DCNL DCSP  DCSP params['Prefix'] = prefix DCNL DCSP if (sort_order is not None): DCNL DCSP  DCSP params['SortOrder'] = sort_order DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP return self.make_request(action='DescribeMLModels', body=json.dumps(params))
def get_batch_prediction(self, batch_prediction_id): DCNL DCSP params = {'BatchPredictionId': batch_prediction_id} DCNL DCSP return self.make_request(action='GetBatchPrediction', body=json.dumps(params))
def get_data_source(self, data_source_id, verbose=None): DCNL DCSP params = {'DataSourceId': data_source_id} DCNL DCSP if (verbose is not None): DCNL DCSP  DCSP params['Verbose'] = verbose DCNL DCSP return self.make_request(action='GetDataSource', body=json.dumps(params))
def get_evaluation(self, evaluation_id): DCNL DCSP params = {'EvaluationId': evaluation_id} DCNL DCSP return self.make_request(action='GetEvaluation', body=json.dumps(params))
def get_ml_model(self, ml_model_id, verbose=None): DCNL DCSP params = {'MLModelId': ml_model_id} DCNL DCSP if (verbose is not None): DCNL DCSP  DCSP params['Verbose'] = verbose DCNL DCSP return self.make_request(action='GetMLModel', body=json.dumps(params))
def predict(self, ml_model_id, record, predict_endpoint): DCNL DCSP predict_host = urlsplit(predict_endpoint).hostname DCNL DCSP if (predict_host is None): DCNL DCSP  DCSP predict_host = predict_endpoint DCNL DCSP params = {'MLModelId': ml_model_id, 'Record': record, 'PredictEndpoint': predict_host} DCNL DCSP return self.make_request(action='Predict', body=json.dumps(params), host=predict_host)
def update_batch_prediction(self, batch_prediction_id, batch_prediction_name): DCNL DCSP params = {'BatchPredictionId': batch_prediction_id, 'BatchPredictionName': batch_prediction_name} DCNL DCSP return self.make_request(action='UpdateBatchPrediction', body=json.dumps(params))
def update_data_source(self, data_source_id, data_source_name): DCNL DCSP params = {'DataSourceId': data_source_id, 'DataSourceName': data_source_name} DCNL DCSP return self.make_request(action='UpdateDataSource', body=json.dumps(params))
def update_evaluation(self, evaluation_id, evaluation_name): DCNL DCSP params = {'EvaluationId': evaluation_id, 'EvaluationName': evaluation_name} DCNL DCSP return self.make_request(action='UpdateEvaluation', body=json.dumps(params))
def update_ml_model(self, ml_model_id, ml_model_name=None, score_threshold=None): DCNL DCSP params = {'MLModelId': ml_model_id} DCNL DCSP if (ml_model_name is not None): DCNL DCSP  DCSP params['MLModelName'] = ml_model_name DCNL DCSP if (score_threshold is not None): DCNL DCSP  DCSP params['ScoreThreshold'] = score_threshold DCNL DCSP return self.make_request(action='UpdateMLModel', body=json.dumps(params))
def create_alias(self, alias_name, target_key_id): DCNL DCSP params = {'AliasName': alias_name, 'TargetKeyId': target_key_id} DCNL DCSP return self.make_request(action='CreateAlias', body=json.dumps(params))
def create_grant(self, key_id, grantee_principal, retiring_principal=None, operations=None, constraints=None, grant_tokens=None): DCNL DCSP params = {'KeyId': key_id, 'GranteePrincipal': grantee_principal} DCNL DCSP if (retiring_principal is not None): DCNL DCSP  DCSP params['RetiringPrincipal'] = retiring_principal DCNL DCSP if (operations is not None): DCNL DCSP  DCSP params['Operations'] = operations DCNL DCSP if (constraints is not None): DCNL DCSP  DCSP params['Constraints'] = constraints DCNL DCSP if (grant_tokens is not None): DCNL DCSP  DCSP params['GrantTokens'] = grant_tokens DCNL DCSP return self.make_request(action='CreateGrant', body=json.dumps(params))
def create_key(self, policy=None, description=None, key_usage=None): DCNL DCSP params = {} DCNL DCSP if (policy is not None): DCNL DCSP  DCSP params['Policy'] = policy DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if (key_usage is not None): DCNL DCSP  DCSP params['KeyUsage'] = key_usage DCNL DCSP return self.make_request(action='CreateKey', body=json.dumps(params))
def decrypt(self, ciphertext_blob, encryption_context=None, grant_tokens=None): DCNL DCSP if (not isinstance(ciphertext_blob, six.binary_type)): DCNL DCSP  DCSP raise TypeError(('Value DCSP of DCSP argument DCSP ``ciphertext_blob`` DCSP must DCSP be DCSP of DCSP type DCSP %s.' % six.binary_type)) DCNL DCSP ciphertext_blob = base64.b64encode(ciphertext_blob) DCNL DCSP params = {'CiphertextBlob': ciphertext_blob.decode('utf-8')} DCNL DCSP if (encryption_context is not None): DCNL DCSP  DCSP params['EncryptionContext'] = encryption_context DCNL DCSP if (grant_tokens is not None): DCNL DCSP  DCSP params['GrantTokens'] = grant_tokens DCNL DCSP response = self.make_request(action='Decrypt', body=json.dumps(params)) DCNL DCSP if (response.get('Plaintext') is not None): DCNL DCSP  DCSP response['Plaintext'] = base64.b64decode(response['Plaintext'].encode('utf-8')) DCNL DCSP return response
def delete_alias(self, alias_name): DCNL DCSP params = {'AliasName': alias_name} DCNL DCSP return self.make_request(action='DeleteAlias', body=json.dumps(params))
def describe_key(self, key_id): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP return self.make_request(action='DescribeKey', body=json.dumps(params))
def disable_key(self, key_id): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP return self.make_request(action='DisableKey', body=json.dumps(params))
def disable_key_rotation(self, key_id): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP return self.make_request(action='DisableKeyRotation', body=json.dumps(params))
def enable_key(self, key_id): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP return self.make_request(action='EnableKey', body=json.dumps(params))
def enable_key_rotation(self, key_id): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP return self.make_request(action='EnableKeyRotation', body=json.dumps(params))
def encrypt(self, key_id, plaintext, encryption_context=None, grant_tokens=None): DCNL DCSP if (not isinstance(plaintext, six.binary_type)): DCNL DCSP  DCSP raise TypeError(('Value DCSP of DCSP argument DCSP ``plaintext`` DCSP must DCSP be DCSP of DCSP type DCSP %s.' % six.binary_type)) DCNL DCSP plaintext = base64.b64encode(plaintext) DCNL DCSP params = {'KeyId': key_id, 'Plaintext': plaintext.decode('utf-8')} DCNL DCSP if (encryption_context is not None): DCNL DCSP  DCSP params['EncryptionContext'] = encryption_context DCNL DCSP if (grant_tokens is not None): DCNL DCSP  DCSP params['GrantTokens'] = grant_tokens DCNL DCSP response = self.make_request(action='Encrypt', body=json.dumps(params)) DCNL DCSP if (response.get('CiphertextBlob') is not None): DCNL DCSP  DCSP response['CiphertextBlob'] = base64.b64decode(response['CiphertextBlob'].encode('utf-8')) DCNL DCSP return response
def generate_data_key(self, key_id, encryption_context=None, number_of_bytes=None, key_spec=None, grant_tokens=None): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP if (encryption_context is not None): DCNL DCSP  DCSP params['EncryptionContext'] = encryption_context DCNL DCSP if (number_of_bytes is not None): DCNL DCSP  DCSP params['NumberOfBytes'] = number_of_bytes DCNL DCSP if (key_spec is not None): DCNL DCSP  DCSP params['KeySpec'] = key_spec DCNL DCSP if (grant_tokens is not None): DCNL DCSP  DCSP params['GrantTokens'] = grant_tokens DCNL DCSP response = self.make_request(action='GenerateDataKey', body=json.dumps(params)) DCNL DCSP if (response.get('CiphertextBlob') is not None): DCNL DCSP  DCSP response['CiphertextBlob'] = base64.b64decode(response['CiphertextBlob'].encode('utf-8')) DCNL DCSP if (response.get('Plaintext') is not None): DCNL DCSP  DCSP response['Plaintext'] = base64.b64decode(response['Plaintext'].encode('utf-8')) DCNL DCSP return response
def generate_data_key_without_plaintext(self, key_id, encryption_context=None, key_spec=None, number_of_bytes=None, grant_tokens=None): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP if (encryption_context is not None): DCNL DCSP  DCSP params['EncryptionContext'] = encryption_context DCNL DCSP if (key_spec is not None): DCNL DCSP  DCSP params['KeySpec'] = key_spec DCNL DCSP if (number_of_bytes is not None): DCNL DCSP  DCSP params['NumberOfBytes'] = number_of_bytes DCNL DCSP if (grant_tokens is not None): DCNL DCSP  DCSP params['GrantTokens'] = grant_tokens DCNL DCSP response = self.make_request(action='GenerateDataKeyWithoutPlaintext', body=json.dumps(params)) DCNL DCSP if (response.get('CiphertextBlob') is not None): DCNL DCSP  DCSP response['CiphertextBlob'] = base64.b64decode(response['CiphertextBlob'].encode('utf-8')) DCNL DCSP return response
def generate_random(self, number_of_bytes=None): DCNL DCSP params = {} DCNL DCSP if (number_of_bytes is not None): DCNL DCSP  DCSP params['NumberOfBytes'] = number_of_bytes DCNL DCSP response = self.make_request(action='GenerateRandom', body=json.dumps(params)) DCNL DCSP if (response.get('Plaintext') is not None): DCNL DCSP  DCSP response['Plaintext'] = base64.b64decode(response['Plaintext'].encode('utf-8')) DCNL DCSP return response
def get_key_policy(self, key_id, policy_name): DCNL DCSP params = {'KeyId': key_id, 'PolicyName': policy_name} DCNL DCSP return self.make_request(action='GetKeyPolicy', body=json.dumps(params))
def get_key_rotation_status(self, key_id): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP return self.make_request(action='GetKeyRotationStatus', body=json.dumps(params))
def list_aliases(self, limit=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.make_request(action='ListAliases', body=json.dumps(params))
def list_grants(self, key_id, limit=None, marker=None): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.make_request(action='ListGrants', body=json.dumps(params))
def list_key_policies(self, key_id, limit=None, marker=None): DCNL DCSP params = {'KeyId': key_id} DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.make_request(action='ListKeyPolicies', body=json.dumps(params))
def list_keys(self, limit=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.make_request(action='ListKeys', body=json.dumps(params))
def put_key_policy(self, key_id, policy_name, policy): DCNL DCSP params = {'KeyId': key_id, 'PolicyName': policy_name, 'Policy': policy} DCNL DCSP return self.make_request(action='PutKeyPolicy', body=json.dumps(params))
def re_encrypt(self, ciphertext_blob, destination_key_id, source_encryption_context=None, destination_encryption_context=None, grant_tokens=None): DCNL DCSP if (not isinstance(ciphertext_blob, six.binary_type)): DCNL DCSP  DCSP raise TypeError(('Value DCSP of DCSP argument DCSP ``ciphertext_blob`` DCSP must DCSP be DCSP of DCSP type DCSP %s.' % six.binary_type)) DCNL DCSP ciphertext_blob = base64.b64encode(ciphertext_blob) DCNL DCSP params = {'CiphertextBlob': ciphertext_blob, 'DestinationKeyId': destination_key_id} DCNL DCSP if (source_encryption_context is not None): DCNL DCSP  DCSP params['SourceEncryptionContext'] = source_encryption_context DCNL DCSP if (destination_encryption_context is not None): DCNL DCSP  DCSP params['DestinationEncryptionContext'] = destination_encryption_context DCNL DCSP if (grant_tokens is not None): DCNL DCSP  DCSP params['GrantTokens'] = grant_tokens DCNL DCSP response = self.make_request(action='ReEncrypt', body=json.dumps(params)) DCNL DCSP if (response.get('CiphertextBlob') is not None): DCNL DCSP  DCSP response['CiphertextBlob'] = base64.b64decode(response['CiphertextBlob'].encode('utf-8')) DCNL DCSP return response
def retire_grant(self, grant_token): DCNL DCSP params = {'GrantToken': grant_token} DCNL DCSP return self.make_request(action='RetireGrant', body=json.dumps(params))
def revoke_grant(self, key_id, grant_id): DCNL DCSP params = {'KeyId': key_id, 'GrantId': grant_id} DCNL DCSP return self.make_request(action='RevokeGrant', body=json.dumps(params))
def update_key_description(self, key_id, description): DCNL DCSP params = {'KeyId': key_id, 'Description': description} DCNL DCSP return self.make_request(action='UpdateKeyDescription', body=json.dumps(params))
def delete_dataset(self, identity_pool_id, identity_id, dataset_name): DCNL DCSP uri = '/identitypools/{0}/identities/{1}/datasets/{2}'.format(identity_pool_id, identity_id, dataset_name) DCNL DCSP return self.make_request('DELETE', uri, expected_status=200)
def describe_dataset(self, identity_pool_id, identity_id, dataset_name): DCNL DCSP uri = '/identitypools/{0}/identities/{1}/datasets/{2}'.format(identity_pool_id, identity_id, dataset_name) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def describe_identity_pool_usage(self, identity_pool_id): DCNL DCSP uri = '/identitypools/{0}'.format(identity_pool_id) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def describe_identity_usage(self, identity_pool_id, identity_id): DCNL DCSP uri = '/identitypools/{0}/identities/{1}'.format(identity_pool_id, identity_id) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def get_identity_pool_configuration(self, identity_pool_id): DCNL DCSP uri = '/identitypools/{0}/configuration'.format(identity_pool_id) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def list_datasets(self, identity_pool_id, identity_id, next_token=None, max_results=None): DCNL DCSP uri = '/identitypools/{0}/identities/{1}/datasets'.format(identity_pool_id, identity_id) DCNL DCSP params = {} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP query_params['nextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP query_params['maxResults'] = max_results DCNL DCSP return self.make_request('GET', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def list_identity_pool_usage(self, next_token=None, max_results=None): DCNL DCSP uri = '/identitypools' DCNL DCSP params = {} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP query_params['nextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP query_params['maxResults'] = max_results DCNL DCSP return self.make_request('GET', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def list_records(self, identity_pool_id, identity_id, dataset_name, last_sync_count=None, next_token=None, max_results=None, sync_session_token=None): DCNL DCSP uri = '/identitypools/{0}/identities/{1}/datasets/{2}/records'.format(identity_pool_id, identity_id, dataset_name) DCNL DCSP params = {} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (last_sync_count is not None): DCNL DCSP  DCSP query_params['lastSyncCount'] = last_sync_count DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP query_params['nextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP query_params['maxResults'] = max_results DCNL DCSP if (sync_session_token is not None): DCNL DCSP  DCSP query_params['syncSessionToken'] = sync_session_token DCNL DCSP return self.make_request('GET', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def register_device(self, identity_pool_id, identity_id, platform, token): DCNL DCSP uri = '/identitypools/{0}/identity/{1}/device'.format(identity_pool_id, identity_id) DCNL DCSP params = {'Platform': platform, 'Token': token} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP return self.make_request('POST', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def set_identity_pool_configuration(self, identity_pool_id, push_sync=None): DCNL DCSP uri = '/identitypools/{0}/configuration'.format(identity_pool_id) DCNL DCSP params = {} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (push_sync is not None): DCNL DCSP  DCSP params['PushSync'] = push_sync DCNL DCSP return self.make_request('POST', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def subscribe_to_dataset(self, identity_pool_id, identity_id, dataset_name, device_id): DCNL DCSP uri = '/identitypools/{0}/identities/{1}/datasets/{2}/subscriptions/{3}'.format(identity_pool_id, identity_id, dataset_name, device_id) DCNL DCSP return self.make_request('POST', uri, expected_status=200)
def unsubscribe_from_dataset(self, identity_pool_id, identity_id, dataset_name, device_id): DCNL DCSP uri = '/identitypools/{0}/identities/{1}/datasets/{2}/subscriptions/{3}'.format(identity_pool_id, identity_id, dataset_name, device_id) DCNL DCSP return self.make_request('DELETE', uri, expected_status=200)
def update_records(self, identity_pool_id, identity_id, dataset_name, sync_session_token, device_id=None, record_patches=None, client_context=None): DCNL DCSP uri = '/identitypools/{0}/identities/{1}/datasets/{2}'.format(identity_pool_id, identity_id, dataset_name) DCNL DCSP params = {'SyncSessionToken': sync_session_token} DCNL DCSP headers = {} DCNL DCSP query_params = {} DCNL DCSP if (device_id is not None): DCNL DCSP  DCSP params['DeviceId'] = device_id DCNL DCSP if (record_patches is not None): DCNL DCSP  DCSP params['RecordPatches'] = record_patches DCNL DCSP if (client_context is not None): DCNL DCSP  DCSP headers['x-amz-Client-Context'] = client_context DCNL DCSP if (client_context is not None): DCNL DCSP  DCSP headers['x-amz-Client-Context'] = client_context DCNL DCSP return self.make_request('POST', uri, expected_status=200, data=json.dumps(params), headers=headers, params=query_params)
def create_identity_pool(self, identity_pool_name, allow_unauthenticated_identities, supported_login_providers=None, developer_provider_name=None, open_id_connect_provider_ar_ns=None): DCNL DCSP params = {'IdentityPoolName': identity_pool_name, 'AllowUnauthenticatedIdentities': allow_unauthenticated_identities} DCNL DCSP if (supported_login_providers is not None): DCNL DCSP  DCSP params['SupportedLoginProviders'] = supported_login_providers DCNL DCSP if (developer_provider_name is not None): DCNL DCSP  DCSP params['DeveloperProviderName'] = developer_provider_name DCNL DCSP if (open_id_connect_provider_ar_ns is not None): DCNL DCSP  DCSP params['OpenIdConnectProviderARNs'] = open_id_connect_provider_ar_ns DCNL DCSP return self.make_request(action='CreateIdentityPool', body=json.dumps(params))
def delete_identity_pool(self, identity_pool_id): DCNL DCSP params = {'IdentityPoolId': identity_pool_id} DCNL DCSP return self.make_request(action='DeleteIdentityPool', body=json.dumps(params))
def describe_identity_pool(self, identity_pool_id): DCNL DCSP params = {'IdentityPoolId': identity_pool_id} DCNL DCSP return self.make_request(action='DescribeIdentityPool', body=json.dumps(params))
def get_id(self, account_id, identity_pool_id, logins=None): DCNL DCSP params = {'AccountId': account_id, 'IdentityPoolId': identity_pool_id} DCNL DCSP if (logins is not None): DCNL DCSP  DCSP params['Logins'] = logins DCNL DCSP return self.make_request(action='GetId', body=json.dumps(params))
def get_open_id_token(self, identity_id, logins=None): DCNL DCSP params = {'IdentityId': identity_id} DCNL DCSP if (logins is not None): DCNL DCSP  DCSP params['Logins'] = logins DCNL DCSP return self.make_request(action='GetOpenIdToken', body=json.dumps(params))
def get_open_id_token_for_developer_identity(self, identity_pool_id, logins, identity_id=None, token_duration=None): DCNL DCSP params = {'IdentityPoolId': identity_pool_id, 'Logins': logins} DCNL DCSP if (identity_id is not None): DCNL DCSP  DCSP params['IdentityId'] = identity_id DCNL DCSP if (token_duration is not None): DCNL DCSP  DCSP params['TokenDuration'] = token_duration DCNL DCSP return self.make_request(action='GetOpenIdTokenForDeveloperIdentity', body=json.dumps(params))
def list_identities(self, identity_pool_id, max_results, next_token=None): DCNL DCSP params = {'IdentityPoolId': identity_pool_id, 'MaxResults': max_results} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.make_request(action='ListIdentities', body=json.dumps(params))
def list_identity_pools(self, max_results, next_token=None): DCNL DCSP params = {'MaxResults': max_results} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.make_request(action='ListIdentityPools', body=json.dumps(params))
def lookup_developer_identity(self, identity_pool_id, identity_id=None, developer_user_identifier=None, max_results=None, next_token=None): DCNL DCSP params = {'IdentityPoolId': identity_pool_id} DCNL DCSP if (identity_id is not None): DCNL DCSP  DCSP params['IdentityId'] = identity_id DCNL DCSP if (developer_user_identifier is not None): DCNL DCSP  DCSP params['DeveloperUserIdentifier'] = developer_user_identifier DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['MaxResults'] = max_results DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.make_request(action='LookupDeveloperIdentity', body=json.dumps(params))
def merge_developer_identities(self, source_user_identifier, destination_user_identifier, developer_provider_name, identity_pool_id): DCNL DCSP params = {'SourceUserIdentifier': source_user_identifier, 'DestinationUserIdentifier': destination_user_identifier, 'DeveloperProviderName': developer_provider_name, 'IdentityPoolId': identity_pool_id} DCNL DCSP return self.make_request(action='MergeDeveloperIdentities', body=json.dumps(params))
def unlink_developer_identity(self, identity_id, identity_pool_id, developer_provider_name, developer_user_identifier): DCNL DCSP params = {'IdentityId': identity_id, 'IdentityPoolId': identity_pool_id, 'DeveloperProviderName': developer_provider_name, 'DeveloperUserIdentifier': developer_user_identifier} DCNL DCSP return self.make_request(action='UnlinkDeveloperIdentity', body=json.dumps(params))
def unlink_identity(self, identity_id, logins, logins_to_remove): DCNL DCSP params = {'IdentityId': identity_id, 'Logins': logins, 'LoginsToRemove': logins_to_remove} DCNL DCSP return self.make_request(action='UnlinkIdentity', body=json.dumps(params))
def update_identity_pool(self, identity_pool_id, identity_pool_name, allow_unauthenticated_identities, supported_login_providers=None, developer_provider_name=None, open_id_connect_provider_ar_ns=None): DCNL DCSP params = {'IdentityPoolId': identity_pool_id, 'IdentityPoolName': identity_pool_name, 'AllowUnauthenticatedIdentities': allow_unauthenticated_identities} DCNL DCSP if (supported_login_providers is not None): DCNL DCSP  DCSP params['SupportedLoginProviders'] = supported_login_providers DCNL DCSP if (developer_provider_name is not None): DCNL DCSP  DCSP params['DeveloperProviderName'] = developer_provider_name DCNL DCSP if (open_id_connect_provider_ar_ns is not None): DCNL DCSP  DCSP params['OpenIdConnectProviderARNs'] = open_id_connect_provider_ar_ns DCNL DCSP return self.make_request(action='UpdateIdentityPool', body=json.dumps(params))
def connect(self, **kw_params): DCNL DCSP if self.connection_cls: DCNL DCSP  DCSP return self.connection_cls(host=self.endpoint, **kw_params)
def get_response(self, action, params, path='/', parent=None, verb='POST', list_marker='Set'): DCNL DCSP if (not parent): DCNL DCSP  DCSP parent = self DCNL DCSP response = self.make_request(action, params, path, verb) DCNL DCSP body = response.read() DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP if body: DCNL DCSP  DCSP  DCSP e = boto.jsonresponse.Element(list_marker=list_marker, pythonize_name=True) DCNL DCSP  DCSP  DCSP h = boto.jsonresponse.XmlHandler(e, parent) DCNL DCSP  DCSP  DCSP h.parse(body) DCNL DCSP  DCSP  DCSP return e DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {} DCNL DCSP else: DCNL DCSP  DCSP boto.log.error(('%s DCSP %s' % (response.status, response.reason))) DCNL DCSP  DCSP boto.log.error(('%s' % body)) DCNL DCSP  DCSP raise self.ResponseError(response.status, response.reason, body)
def get_all_groups(self, path_prefix='/', marker=None, max_items=None): DCNL DCSP params = {} DCNL DCSP if path_prefix: DCNL DCSP  DCSP params['PathPrefix'] = path_prefix DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListGroups', params, list_marker='Groups')
def get_group(self, group_name, marker=None, max_items=None): DCNL DCSP params = {'GroupName': group_name} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('GetGroup', params, list_marker='Users')
def create_group(self, group_name, path='/'): DCNL DCSP params = {'GroupName': group_name, 'Path': path} DCNL DCSP return self.get_response('CreateGroup', params)
def delete_group(self, group_name): DCNL DCSP params = {'GroupName': group_name} DCNL DCSP return self.get_response('DeleteGroup', params)
def update_group(self, group_name, new_group_name=None, new_path=None): DCNL DCSP params = {'GroupName': group_name} DCNL DCSP if new_group_name: DCNL DCSP  DCSP params['NewGroupName'] = new_group_name DCNL DCSP if new_path: DCNL DCSP  DCSP params['NewPath'] = new_path DCNL DCSP return self.get_response('UpdateGroup', params)
def add_user_to_group(self, group_name, user_name): DCNL DCSP params = {'GroupName': group_name, 'UserName': user_name} DCNL DCSP return self.get_response('AddUserToGroup', params)
def remove_user_from_group(self, group_name, user_name): DCNL DCSP params = {'GroupName': group_name, 'UserName': user_name} DCNL DCSP return self.get_response('RemoveUserFromGroup', params)
def put_group_policy(self, group_name, policy_name, policy_json): DCNL DCSP params = {'GroupName': group_name, 'PolicyName': policy_name, 'PolicyDocument': policy_json} DCNL DCSP return self.get_response('PutGroupPolicy', params, verb='POST')
def get_all_group_policies(self, group_name, marker=None, max_items=None): DCNL DCSP params = {'GroupName': group_name} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListGroupPolicies', params, list_marker='PolicyNames')
def get_group_policy(self, group_name, policy_name): DCNL DCSP params = {'GroupName': group_name, 'PolicyName': policy_name} DCNL DCSP return self.get_response('GetGroupPolicy', params, verb='POST')
def delete_group_policy(self, group_name, policy_name): DCNL DCSP params = {'GroupName': group_name, 'PolicyName': policy_name} DCNL DCSP return self.get_response('DeleteGroupPolicy', params, verb='POST')
def get_all_users(self, path_prefix='/', marker=None, max_items=None): DCNL DCSP params = {'PathPrefix': path_prefix} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListUsers', params, list_marker='Users')
def create_user(self, user_name, path='/'): DCNL DCSP params = {'UserName': user_name, 'Path': path} DCNL DCSP return self.get_response('CreateUser', params)
def delete_user(self, user_name): DCNL DCSP params = {'UserName': user_name} DCNL DCSP return self.get_response('DeleteUser', params)
def get_user(self, user_name=None): DCNL DCSP params = {} DCNL DCSP if user_name: DCNL DCSP  DCSP params['UserName'] = user_name DCNL DCSP return self.get_response('GetUser', params)
def update_user(self, user_name, new_user_name=None, new_path=None): DCNL DCSP params = {'UserName': user_name} DCNL DCSP if new_user_name: DCNL DCSP  DCSP params['NewUserName'] = new_user_name DCNL DCSP if new_path: DCNL DCSP  DCSP params['NewPath'] = new_path DCNL DCSP return self.get_response('UpdateUser', params)
def get_all_user_policies(self, user_name, marker=None, max_items=None): DCNL DCSP params = {'UserName': user_name} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListUserPolicies', params, list_marker='PolicyNames')
def put_user_policy(self, user_name, policy_name, policy_json): DCNL DCSP params = {'UserName': user_name, 'PolicyName': policy_name, 'PolicyDocument': policy_json} DCNL DCSP return self.get_response('PutUserPolicy', params, verb='POST')
def get_user_policy(self, user_name, policy_name): DCNL DCSP params = {'UserName': user_name, 'PolicyName': policy_name} DCNL DCSP return self.get_response('GetUserPolicy', params, verb='POST')
def delete_user_policy(self, user_name, policy_name): DCNL DCSP params = {'UserName': user_name, 'PolicyName': policy_name} DCNL DCSP return self.get_response('DeleteUserPolicy', params, verb='POST')
def get_groups_for_user(self, user_name, marker=None, max_items=None): DCNL DCSP params = {'UserName': user_name} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListGroupsForUser', params, list_marker='Groups')
def get_all_access_keys(self, user_name, marker=None, max_items=None): DCNL DCSP params = {'UserName': user_name} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListAccessKeys', params, list_marker='AccessKeyMetadata')
def create_access_key(self, user_name=None): DCNL DCSP params = {'UserName': user_name} DCNL DCSP return self.get_response('CreateAccessKey', params)
def update_access_key(self, access_key_id, status, user_name=None): DCNL DCSP params = {'AccessKeyId': access_key_id, 'Status': status} DCNL DCSP if user_name: DCNL DCSP  DCSP params['UserName'] = user_name DCNL DCSP return self.get_response('UpdateAccessKey', params)
def delete_access_key(self, access_key_id, user_name=None): DCNL DCSP params = {'AccessKeyId': access_key_id} DCNL DCSP if user_name: DCNL DCSP  DCSP params['UserName'] = user_name DCNL DCSP return self.get_response('DeleteAccessKey', params)
def get_all_signing_certs(self, marker=None, max_items=None, user_name=None): DCNL DCSP params = {} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP if user_name: DCNL DCSP  DCSP params['UserName'] = user_name DCNL DCSP return self.get_response('ListSigningCertificates', params, list_marker='Certificates')
def update_signing_cert(self, cert_id, status, user_name=None): DCNL DCSP params = {'CertificateId': cert_id, 'Status': status} DCNL DCSP if user_name: DCNL DCSP  DCSP params['UserName'] = user_name DCNL DCSP return self.get_response('UpdateSigningCertificate', params)
def upload_signing_cert(self, cert_body, user_name=None): DCNL DCSP params = {'CertificateBody': cert_body} DCNL DCSP if user_name: DCNL DCSP  DCSP params['UserName'] = user_name DCNL DCSP return self.get_response('UploadSigningCertificate', params, verb='POST')
def delete_signing_cert(self, cert_id, user_name=None): DCNL DCSP params = {'CertificateId': cert_id} DCNL DCSP if user_name: DCNL DCSP  DCSP params['UserName'] = user_name DCNL DCSP return self.get_response('DeleteSigningCertificate', params)
def list_server_certs(self, path_prefix='/', marker=None, max_items=None): DCNL DCSP params = {} DCNL DCSP if path_prefix: DCNL DCSP  DCSP params['PathPrefix'] = path_prefix DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListServerCertificates', params, list_marker='ServerCertificateMetadataList')
def update_server_cert(self, cert_name, new_cert_name=None, new_path=None): DCNL DCSP params = {'ServerCertificateName': cert_name} DCNL DCSP if new_cert_name: DCNL DCSP  DCSP params['NewServerCertificateName'] = new_cert_name DCNL DCSP if new_path: DCNL DCSP  DCSP params['NewPath'] = new_path DCNL DCSP return self.get_response('UpdateServerCertificate', params)
def upload_server_cert(self, cert_name, cert_body, private_key, cert_chain=None, path=None): DCNL DCSP params = {'ServerCertificateName': cert_name, 'CertificateBody': cert_body, 'PrivateKey': private_key} DCNL DCSP if cert_chain: DCNL DCSP  DCSP params['CertificateChain'] = cert_chain DCNL DCSP if path: DCNL DCSP  DCSP params['Path'] = path DCNL DCSP return self.get_response('UploadServerCertificate', params, verb='POST')
def get_server_certificate(self, cert_name): DCNL DCSP params = {'ServerCertificateName': cert_name} DCNL DCSP return self.get_response('GetServerCertificate', params)
def delete_server_cert(self, cert_name): DCNL DCSP params = {'ServerCertificateName': cert_name} DCNL DCSP return self.get_response('DeleteServerCertificate', params)
def get_all_mfa_devices(self, user_name, marker=None, max_items=None): DCNL DCSP params = {'UserName': user_name} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListMFADevices', params, list_marker='MFADevices')
def enable_mfa_device(self, user_name, serial_number, auth_code_1, auth_code_2): DCNL DCSP params = {'UserName': user_name, 'SerialNumber': serial_number, 'AuthenticationCode1': auth_code_1, 'AuthenticationCode2': auth_code_2} DCNL DCSP return self.get_response('EnableMFADevice', params)
def deactivate_mfa_device(self, user_name, serial_number): DCNL DCSP params = {'UserName': user_name, 'SerialNumber': serial_number} DCNL DCSP return self.get_response('DeactivateMFADevice', params)
def resync_mfa_device(self, user_name, serial_number, auth_code_1, auth_code_2): DCNL DCSP params = {'UserName': user_name, 'SerialNumber': serial_number, 'AuthenticationCode1': auth_code_1, 'AuthenticationCode2': auth_code_2} DCNL DCSP return self.get_response('ResyncMFADevice', params)
def get_login_profiles(self, user_name): DCNL DCSP params = {'UserName': user_name} DCNL DCSP return self.get_response('GetLoginProfile', params)
def create_login_profile(self, user_name, password): DCNL DCSP params = {'UserName': user_name, 'Password': password} DCNL DCSP return self.get_response('CreateLoginProfile', params)
def delete_login_profile(self, user_name): DCNL DCSP params = {'UserName': user_name} DCNL DCSP return self.get_response('DeleteLoginProfile', params)
def update_login_profile(self, user_name, password): DCNL DCSP params = {'UserName': user_name, 'Password': password} DCNL DCSP return self.get_response('UpdateLoginProfile', params)
def create_account_alias(self, alias): DCNL DCSP params = {'AccountAlias': alias} DCNL DCSP return self.get_response('CreateAccountAlias', params)
def delete_account_alias(self, alias): DCNL DCSP params = {'AccountAlias': alias} DCNL DCSP return self.get_response('DeleteAccountAlias', params)
def get_account_alias(self): DCNL DCSP return self.get_response('ListAccountAliases', {}, list_marker='AccountAliases')
def get_signin_url(self, service='ec2'): DCNL DCSP alias = self.get_account_alias() DCNL DCSP if (not alias): DCNL DCSP  DCSP raise Exception('No DCSP alias DCSP associated DCSP with DCSP this DCSP account. DCSP  DCSP Please DCSP use DCSP iam.create_account_alias() DCSP first.') DCNL DCSP resp = alias.get('list_account_aliases_response', {}) DCNL DCSP result = resp.get('list_account_aliases_result', {}) DCNL DCSP aliases = result.get('account_aliases', []) DCNL DCSP if (not len(aliases)): DCNL DCSP  DCSP raise Exception('No DCSP alias DCSP associated DCSP with DCSP this DCSP account. DCSP  DCSP Please DCSP use DCSP iam.create_account_alias() DCSP first.') DCNL DCSP alias = aliases[0] DCNL DCSP if (self.host == 'iam.us-gov.amazonaws.com'): DCNL DCSP  DCSP return ('https://%s.signin.amazonaws-us-gov.com/console/%s' % (alias, service)) DCNL DCSP elif self.host.endswith('amazonaws.com.cn'): DCNL DCSP  DCSP return ('https://%s.signin.amazonaws.cn/console/%s' % (alias, service)) DCNL DCSP else: DCNL DCSP  DCSP return ('https://%s.signin.aws.amazon.com/console/%s' % (alias, service))
def get_account_summary(self): DCNL DCSP return self.get_object('GetAccountSummary', {}, SummaryMap)
def add_role_to_instance_profile(self, instance_profile_name, role_name): DCNL DCSP return self.get_response('AddRoleToInstanceProfile', {'InstanceProfileName': instance_profile_name, 'RoleName': role_name})
def create_instance_profile(self, instance_profile_name, path=None): DCNL DCSP params = {'InstanceProfileName': instance_profile_name} DCNL DCSP if (path is not None): DCNL DCSP  DCSP params['Path'] = path DCNL DCSP return self.get_response('CreateInstanceProfile', params)
def create_role(self, role_name, assume_role_policy_document=None, path=None): DCNL DCSP params = {'RoleName': role_name, 'AssumeRolePolicyDocument': self._build_policy(assume_role_policy_document)} DCNL DCSP if (path is not None): DCNL DCSP  DCSP params['Path'] = path DCNL DCSP return self.get_response('CreateRole', params)
def delete_instance_profile(self, instance_profile_name): DCNL DCSP return self.get_response('DeleteInstanceProfile', {'InstanceProfileName': instance_profile_name})
def delete_role(self, role_name): DCNL DCSP return self.get_response('DeleteRole', {'RoleName': role_name})
def delete_role_policy(self, role_name, policy_name): DCNL DCSP return self.get_response('DeleteRolePolicy', {'RoleName': role_name, 'PolicyName': policy_name})
def get_instance_profile(self, instance_profile_name): DCNL DCSP return self.get_response('GetInstanceProfile', {'InstanceProfileName': instance_profile_name})
def get_role(self, role_name): DCNL DCSP return self.get_response('GetRole', {'RoleName': role_name})
def get_role_policy(self, role_name, policy_name): DCNL DCSP return self.get_response('GetRolePolicy', {'RoleName': role_name, 'PolicyName': policy_name})
def list_instance_profiles(self, path_prefix=None, marker=None, max_items=None): DCNL DCSP params = {} DCNL DCSP if (path_prefix is not None): DCNL DCSP  DCSP params['PathPrefix'] = path_prefix DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListInstanceProfiles', params, list_marker='InstanceProfiles')
def list_instance_profiles_for_role(self, role_name, marker=None, max_items=None): DCNL DCSP params = {'RoleName': role_name} DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListInstanceProfilesForRole', params, list_marker='InstanceProfiles')
def list_role_policies(self, role_name, marker=None, max_items=None): DCNL DCSP params = {'RoleName': role_name} DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListRolePolicies', params, list_marker='PolicyNames')
def list_roles(self, path_prefix=None, marker=None, max_items=None): DCNL DCSP params = {} DCNL DCSP if (path_prefix is not None): DCNL DCSP  DCSP params['PathPrefix'] = path_prefix DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListRoles', params, list_marker='Roles')
def put_role_policy(self, role_name, policy_name, policy_document): DCNL DCSP return self.get_response('PutRolePolicy', {'RoleName': role_name, 'PolicyName': policy_name, 'PolicyDocument': policy_document})
def remove_role_from_instance_profile(self, instance_profile_name, role_name): DCNL DCSP return self.get_response('RemoveRoleFromInstanceProfile', {'InstanceProfileName': instance_profile_name, 'RoleName': role_name})
def update_assume_role_policy(self, role_name, policy_document): DCNL DCSP return self.get_response('UpdateAssumeRolePolicy', {'RoleName': role_name, 'PolicyDocument': policy_document})
def create_saml_provider(self, saml_metadata_document, name): DCNL DCSP params = {'SAMLMetadataDocument': saml_metadata_document, 'Name': name} DCNL DCSP return self.get_response('CreateSAMLProvider', params)
def list_saml_providers(self): DCNL DCSP return self.get_response('ListSAMLProviders', {}, list_marker='SAMLProviderList')
def get_saml_provider(self, saml_provider_arn): DCNL DCSP params = {'SAMLProviderArn': saml_provider_arn} DCNL DCSP return self.get_response('GetSAMLProvider', params)
def update_saml_provider(self, saml_provider_arn, saml_metadata_document): DCNL DCSP params = {'SAMLMetadataDocument': saml_metadata_document, 'SAMLProviderArn': saml_provider_arn} DCNL DCSP return self.get_response('UpdateSAMLProvider', params)
def delete_saml_provider(self, saml_provider_arn): DCNL DCSP params = {'SAMLProviderArn': saml_provider_arn} DCNL DCSP return self.get_response('DeleteSAMLProvider', params)
def generate_credential_report(self): DCNL DCSP params = {} DCNL DCSP return self.get_response('GenerateCredentialReport', params)
def get_credential_report(self): DCNL DCSP params = {} DCNL DCSP return self.get_response('GetCredentialReport', params)
def create_virtual_mfa_device(self, path, device_name): DCNL DCSP params = {'Path': path, 'VirtualMFADeviceName': device_name} DCNL DCSP return self.get_response('CreateVirtualMFADevice', params)
def get_account_password_policy(self): DCNL DCSP params = {} DCNL DCSP return self.get_response('GetAccountPasswordPolicy', params)
def delete_account_password_policy(self): DCNL DCSP params = {} DCNL DCSP return self.get_response('DeleteAccountPasswordPolicy', params)
def update_account_password_policy(self, allow_users_to_change_password=None, hard_expiry=None, max_password_age=None, minimum_password_length=None, password_reuse_prevention=None, require_lowercase_characters=None, require_numbers=None, require_symbols=None, require_uppercase_characters=None): DCNL DCSP params = {} DCNL DCSP if ((allow_users_to_change_password is not None) and (type(allow_users_to_change_password) is bool)): DCNL DCSP  DCSP params['AllowUsersToChangePassword'] = str(allow_users_to_change_password).lower() DCNL DCSP if ((hard_expiry is not None) and (type(allow_users_to_change_password) is bool)): DCNL DCSP  DCSP params['HardExpiry'] = str(hard_expiry).lower() DCNL DCSP if (max_password_age is not None): DCNL DCSP  DCSP params['MaxPasswordAge'] = max_password_age DCNL DCSP if (minimum_password_length is not None): DCNL DCSP  DCSP params['MinimumPasswordLength'] = minimum_password_length DCNL DCSP if (password_reuse_prevention is not None): DCNL DCSP  DCSP params['PasswordReusePrevention'] = password_reuse_prevention DCNL DCSP if ((require_lowercase_characters is not None) and (type(allow_users_to_change_password) is bool)): DCNL DCSP  DCSP params['RequireLowercaseCharacters'] = str(require_lowercase_characters).lower() DCNL DCSP if ((require_numbers is not None) and (type(allow_users_to_change_password) is bool)): DCNL DCSP  DCSP params['RequireNumbers'] = str(require_numbers).lower() DCNL DCSP if ((require_symbols is not None) and (type(allow_users_to_change_password) is bool)): DCNL DCSP  DCSP params['RequireSymbols'] = str(require_symbols).lower() DCNL DCSP if ((require_uppercase_characters is not None) and (type(allow_users_to_change_password) is bool)): DCNL DCSP  DCSP params['RequireUppercaseCharacters'] = str(require_uppercase_characters).lower() DCNL DCSP return self.get_response('UpdateAccountPasswordPolicy', params)
def create_policy(self, policy_name, policy_document, path='/', description=None): DCNL DCSP params = {'PolicyName': policy_name, 'PolicyDocument': policy_document, 'Path': path} DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['Description'] = str(description) DCNL DCSP return self.get_response('CreatePolicy', params)
def create_policy_version(self, policy_arn, policy_document, set_as_default=None): DCNL DCSP params = {'PolicyArn': policy_arn, 'PolicyDocument': policy_document} DCNL DCSP if (type(set_as_default) == bool): DCNL DCSP  DCSP params['SetAsDefault'] = str(set_as_default).lower() DCNL DCSP return self.get_response('CreatePolicyVersion', params)
def delete_policy(self, policy_arn): DCNL DCSP params = {'PolicyArn': policy_arn} DCNL DCSP return self.get_response('DeletePolicy', params)
def delete_policy_version(self, policy_arn, version_id): DCNL DCSP params = {'PolicyArn': policy_arn, 'VersionId': version_id} DCNL DCSP return self.get_response('DeletePolicyVersion', params)
def get_policy(self, policy_arn): DCNL DCSP params = {'PolicyArn': policy_arn} DCNL DCSP return self.get_response('GetPolicy', params)
def get_policy_version(self, policy_arn, version_id): DCNL DCSP params = {'PolicyArn': policy_arn, 'VersionId': version_id} DCNL DCSP return self.get_response('GetPolicyVersion', params)
def list_policies(self, marker=None, max_items=None, only_attached=None, path_prefix=None, scope=None): DCNL DCSP params = {} DCNL DCSP if (path_prefix is not None): DCNL DCSP  DCSP params['PathPrefix'] = path_prefix DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP if (type(only_attached) == bool): DCNL DCSP  DCSP params['OnlyAttached'] = str(only_attached).lower() DCNL DCSP if (scope is not None): DCNL DCSP  DCSP params['Scope'] = scope DCNL DCSP return self.get_response('ListPolicies', params, list_marker='Policies')
def list_policy_versions(self, policy_arn, marker=None, max_items=None): DCNL DCSP params = {'PolicyArn': policy_arn} DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP return self.get_response('ListPolicyVersions', params, list_marker='Versions')
def set_default_policy_version(self, policy_arn, version_id): DCNL DCSP params = {'PolicyArn': policy_arn, 'VersionId': version_id} DCNL DCSP return self.get_response('SetDefaultPolicyVersion', params)
def list_entities_for_policy(self, policy_arn, path_prefix=None, marker=None, max_items=None, entity_filter=None): DCNL DCSP params = {'PolicyArn': policy_arn} DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (max_items is not None): DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP if (path_prefix is not None): DCNL DCSP  DCSP params['PathPrefix'] = path_prefix DCNL DCSP if (entity_filter is not None): DCNL DCSP  DCSP params['EntityFilter'] = entity_filter DCNL DCSP return self.get_response('ListEntitiesForPolicy', params, list_marker=('PolicyGroups', 'PolicyUsers', 'PolicyRoles'))
def attach_group_policy(self, policy_arn, group_name): DCNL DCSP params = {'PolicyArn': policy_arn, 'GroupName': group_name} DCNL DCSP return self.get_response('AttachGroupPolicy', params)
def attach_role_policy(self, policy_arn, role_name): DCNL DCSP params = {'PolicyArn': policy_arn, 'RoleName': role_name} DCNL DCSP return self.get_response('AttachRolePolicy', params)
def attach_user_policy(self, policy_arn, user_name): DCNL DCSP params = {'PolicyArn': policy_arn, 'UserName': user_name} DCNL DCSP return self.get_response('AttachUserPolicy', params)
def detach_group_policy(self, policy_arn, group_name): DCNL DCSP params = {'PolicyArn': policy_arn, 'GroupName': group_name} DCNL DCSP return self.get_response('DetachGroupPolicy', params)
def detach_role_policy(self, policy_arn, role_name): DCNL DCSP params = {'PolicyArn': policy_arn, 'RoleName': role_name} DCNL DCSP return self.get_response('DetachRolePolicy', params)
def detach_user_policy(self, policy_arn, user_name): DCNL DCSP params = {'PolicyArn': policy_arn, 'UserName': user_name} DCNL DCSP return self.get_response('DetachUserPolicy', params)
def _build_list_params(self, params, items, label): DCNL DCSP if isinstance(items, six.string_types): DCNL DCSP  DCSP items = [items] DCNL DCSP for i in range(1, (len(items) + 1)): DCNL DCSP  DCSP params[('%s.%d' % (label, i))] = items[(i - 1)]
def _make_request(self, action, params=None): DCNL DCSP ct = 'application/x-www-form-urlencoded; DCSP charset=UTF-8' DCNL DCSP headers = {'Content-Type': ct} DCNL DCSP params = (params or {}) DCNL DCSP params['Action'] = action DCNL DCSP for (k, v) in params.items(): DCNL DCSP  DCSP if isinstance(v, six.text_type): DCNL DCSP  DCSP  DCSP params[k] = v.encode('utf-8') DCNL DCSP response = super(SESConnection, self).make_request('POST', '/', headers=headers, data=urllib.parse.urlencode(params)) DCNL DCSP body = response.read().decode('utf-8') DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP list_markers = ('VerifiedEmailAddresses', 'Identities', 'DkimTokens', 'DkimAttributes', 'VerificationAttributes', 'SendDataPoints') DCNL DCSP  DCSP item_markers = ('member', 'item', 'entry') DCNL DCSP  DCSP e = boto.jsonresponse.Element(list_marker=list_markers, item_marker=item_markers) DCNL DCSP  DCSP h = boto.jsonresponse.XmlHandler(e, None) DCNL DCSP  DCSP h.parse(body) DCNL DCSP  DCSP return e DCNL DCSP else: DCNL DCSP  DCSP self._handle_error(response, body)
def _handle_error(self, response, body): DCNL DCSP boto.log.error(('%s DCSP %s' % (response.status, response.reason))) DCNL DCSP boto.log.error(('%s' % body)) DCNL DCSP if ('Address DCSP blacklisted.' in body): DCNL DCSP  DCSP ExceptionToRaise = ses_exceptions.SESAddressBlacklistedError DCNL DCSP  DCSP exc_reason = 'Address DCSP blacklisted.' DCNL DCSP elif ('Email DCSP address DCSP is DCSP not DCSP verified.' in body): DCNL DCSP  DCSP ExceptionToRaise = ses_exceptions.SESAddressNotVerifiedError DCNL DCSP  DCSP exc_reason = 'Email DCSP address DCSP is DCSP not DCSP verified.' DCNL DCSP elif ('Daily DCSP message DCSP quota DCSP exceeded.' in body): DCNL DCSP  DCSP ExceptionToRaise = ses_exceptions.SESDailyQuotaExceededError DCNL DCSP  DCSP exc_reason = 'Daily DCSP message DCSP quota DCSP exceeded.' DCNL DCSP elif ('Maximum DCSP sending DCSP rate DCSP exceeded.' in body): DCNL DCSP  DCSP ExceptionToRaise = ses_exceptions.SESMaxSendingRateExceededError DCNL DCSP  DCSP exc_reason = 'Maximum DCSP sending DCSP rate DCSP exceeded.' DCNL DCSP elif ('Domain DCSP ends DCSP with DCSP dot.' in body): DCNL DCSP  DCSP ExceptionToRaise = ses_exceptions.SESDomainEndsWithDotError DCNL DCSP  DCSP exc_reason = 'Domain DCSP ends DCSP with DCSP dot.' DCNL DCSP elif ('Local DCSP address DCSP contains DCSP control DCSP or DCSP whitespace' in body): DCNL DCSP  DCSP ExceptionToRaise = ses_exceptions.SESLocalAddressCharacterError DCNL DCSP  DCSP exc_reason = 'Local DCSP address DCSP contains DCSP control DCSP or DCSP whitespace.' DCNL DCSP elif ('Illegal DCSP address' in body): DCNL DCSP  DCSP ExceptionToRaise = ses_exceptions.SESIllegalAddressError DCNL DCSP  DCSP exc_reason = 'Illegal DCSP address' DCNL DCSP elif re.search('Identity.*is DCSP not DCSP verified', body): DCNL DCSP  DCSP ExceptionToRaise = ses_exceptions.SESIdentityNotVerifiedError DCNL DCSP  DCSP exc_reason = 'Identity DCSP is DCSP not DCSP verified.' DCNL DCSP elif ('ownership DCSP not DCSP confirmed' in body): DCNL DCSP  DCSP ExceptionToRaise = ses_exceptions.SESDomainNotConfirmedError DCNL DCSP  DCSP exc_reason = 'Domain DCSP ownership DCSP is DCSP not DCSP confirmed.' DCNL DCSP else: DCNL DCSP  DCSP ExceptionToRaise = self.ResponseError DCNL DCSP  DCSP exc_reason = response.reason DCNL DCSP raise ExceptionToRaise(response.status, exc_reason, body)
def send_email(self, source, subject, body, to_addresses, cc_addresses=None, bcc_addresses=None, format='text', reply_addresses=None, return_path=None, text_body=None, html_body=None): DCNL DCSP format = format.lower().strip() DCNL DCSP if (body is not None): DCNL DCSP  DCSP if (format == 'text'): DCNL DCSP  DCSP  DCSP if (text_body is not None): DCNL DCSP  DCSP  DCSP  DCSP raise Warning("You've DCSP passed DCSP in DCSP both DCSP a DCSP body DCSP and DCSP a DCSP text_body; DCSP please DCSP choose DCSP one DCSP or DCSP the DCSP other.") DCNL DCSP  DCSP  DCSP text_body = body DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (html_body is not None): DCNL DCSP  DCSP  DCSP  DCSP raise Warning("You've DCSP passed DCSP in DCSP both DCSP a DCSP body DCSP and DCSP an DCSP html_body; DCSP please DCSP choose DCSP one DCSP or DCSP the DCSP other.") DCNL DCSP  DCSP  DCSP html_body = body DCNL DCSP params = {'Source': source, 'Message.Subject.Data': subject} DCNL DCSP if return_path: DCNL DCSP  DCSP params['ReturnPath'] = return_path DCNL DCSP if (html_body is not None): DCNL DCSP  DCSP params['Message.Body.Html.Data'] = html_body DCNL DCSP if (text_body is not None): DCNL DCSP  DCSP params['Message.Body.Text.Data'] = text_body DCNL DCSP if (format not in ('text', 'html')): DCNL DCSP  DCSP raise ValueError("'format' DCSP argument DCSP must DCSP be DCSP 'text' DCSP or DCSP 'html'") DCNL DCSP if (not (html_body or text_body)): DCNL DCSP  DCSP raise ValueError('No DCSP text DCSP or DCSP html DCSP body DCSP found DCSP for DCSP mail') DCNL DCSP self._build_list_params(params, to_addresses, 'Destination.ToAddresses.member') DCNL DCSP if cc_addresses: DCNL DCSP  DCSP self._build_list_params(params, cc_addresses, 'Destination.CcAddresses.member') DCNL DCSP if bcc_addresses: DCNL DCSP  DCSP self._build_list_params(params, bcc_addresses, 'Destination.BccAddresses.member') DCNL DCSP if reply_addresses: DCNL DCSP  DCSP self._build_list_params(params, reply_addresses, 'ReplyToAddresses.member') DCNL DCSP return self._make_request('SendEmail', params)
def send_raw_email(self, raw_message, source=None, destinations=None): DCNL DCSP if isinstance(raw_message, six.text_type): DCNL DCSP  DCSP raw_message = raw_message.encode('utf-8') DCNL DCSP params = {'RawMessage.Data': base64.b64encode(raw_message)} DCNL DCSP if source: DCNL DCSP  DCSP params['Source'] = source DCNL DCSP if destinations: DCNL DCSP  DCSP self._build_list_params(params, destinations, 'Destinations.member') DCNL DCSP return self._make_request('SendRawEmail', params)
def list_verified_email_addresses(self): DCNL DCSP return self._make_request('ListVerifiedEmailAddresses')
def get_send_quota(self): DCNL DCSP return self._make_request('GetSendQuota')
def get_send_statistics(self): DCNL DCSP return self._make_request('GetSendStatistics')
def delete_verified_email_address(self, email_address): DCNL DCSP return self._make_request('DeleteVerifiedEmailAddress', {'EmailAddress': email_address})
def verify_email_address(self, email_address): DCNL DCSP return self._make_request('VerifyEmailAddress', {'EmailAddress': email_address})
def verify_domain_dkim(self, domain): DCNL DCSP return self._make_request('VerifyDomainDkim', {'Domain': domain})
def set_identity_dkim_enabled(self, identity, dkim_enabled): DCNL DCSP return self._make_request('SetIdentityDkimEnabled', {'Identity': identity, 'DkimEnabled': ('true' if dkim_enabled else 'false')})
def get_identity_dkim_attributes(self, identities): DCNL DCSP params = {} DCNL DCSP self._build_list_params(params, identities, 'Identities.member') DCNL DCSP return self._make_request('GetIdentityDkimAttributes', params)
def list_identities(self): DCNL DCSP return self._make_request('ListIdentities')
def get_identity_verification_attributes(self, identities): DCNL DCSP params = {} DCNL DCSP self._build_list_params(params, identities, 'Identities.member') DCNL DCSP return self._make_request('GetIdentityVerificationAttributes', params)
def verify_domain_identity(self, domain): DCNL DCSP return self._make_request('VerifyDomainIdentity', {'Domain': domain})
def verify_email_identity(self, email_address): DCNL DCSP return self._make_request('VerifyEmailIdentity', {'EmailAddress': email_address})
def delete_identity(self, identity): DCNL DCSP return self._make_request('DeleteIdentity', {'Identity': identity})
def set_identity_notification_topic(self, identity, notification_type, sns_topic=None): DCNL DCSP params = {'Identity': identity, 'NotificationType': notification_type} DCNL DCSP if sns_topic: DCNL DCSP  DCSP params['SnsTopic'] = sns_topic DCNL DCSP return self._make_request('SetIdentityNotificationTopic', params)
def set_identity_feedback_forwarding_enabled(self, identity, forwarding_enabled=True): DCNL DCSP return self._make_request('SetIdentityFeedbackForwardingEnabled', {'Identity': identity, 'ForwardingEnabled': ('true' if forwarding_enabled else 'false')})
def size(self): DCNL DCSP return len(self.queue)
def put(self, conn): DCNL DCSP self.queue.append((conn, time.time()))
def get(self): DCNL DCSP self.clean() DCNL DCSP for _ in range(len(self.queue)): DCNL DCSP  DCSP (conn, _) = self.queue.pop(0) DCNL DCSP  DCSP if self._conn_ready(conn): DCNL DCSP  DCSP  DCSP return conn DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.put(conn) DCNL DCSP return None
def _conn_ready(self, conn): DCNL DCSP if ON_APP_ENGINE: DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP response = getattr(conn, '_HTTPConnection__response', None) DCNL DCSP  DCSP return ((response is None) or response.isclosed())
def clean(self): DCNL DCSP while ((len(self.queue) > 0) and self._pair_stale(self.queue[0])): DCNL DCSP  DCSP self.queue.pop(0)
def _pair_stale(self, pair): DCNL DCSP (_conn, return_time) = pair DCNL DCSP now = time.time() DCNL DCSP return ((return_time + ConnectionPool.STALE_DURATION) < now)
def size(self): DCNL DCSP return sum((pool.size() for pool in self.host_to_pool.values()))
def get_http_connection(self, host, port, is_secure): DCNL DCSP self.clean() DCNL DCSP with self.mutex: DCNL DCSP  DCSP key = (host, port, is_secure) DCNL DCSP  DCSP if (key not in self.host_to_pool): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return self.host_to_pool[key].get()
def put_http_connection(self, host, port, is_secure, conn): DCNL DCSP with self.mutex: DCNL DCSP  DCSP key = (host, port, is_secure) DCNL DCSP  DCSP if (key not in self.host_to_pool): DCNL DCSP  DCSP  DCSP self.host_to_pool[key] = HostConnectionPool() DCNL DCSP  DCSP self.host_to_pool[key].put(conn)
def clean(self): DCNL DCSP with self.mutex: DCNL DCSP  DCSP now = time.time() DCNL DCSP  DCSP if ((self.last_clean_time + self.CLEAN_INTERVAL) < now): DCNL DCSP  DCSP  DCSP to_remove = [] DCNL DCSP  DCSP  DCSP for (host, pool) in self.host_to_pool.items(): DCNL DCSP  DCSP  DCSP  DCSP pool.clean() DCNL DCSP  DCSP  DCSP  DCSP if (pool.size() == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP to_remove.append(host) DCNL DCSP  DCSP  DCSP for host in to_remove: DCNL DCSP  DCSP  DCSP  DCSP del self.host_to_pool[host] DCNL DCSP  DCSP  DCSP self.last_clean_time = now
def __init__(self, method, protocol, host, port, path, auth_path, params, headers, body): DCNL DCSP self.method = method DCNL DCSP self.protocol = protocol DCNL DCSP self.host = host DCNL DCSP self.port = port DCNL DCSP self.path = path DCNL DCSP if (auth_path is None): DCNL DCSP  DCSP auth_path = path DCNL DCSP self.auth_path = auth_path DCNL DCSP self.params = params DCNL DCSP if (headers and ('Transfer-Encoding' in headers) and (headers['Transfer-Encoding'] == 'chunked') and (self.method != 'PUT')): DCNL DCSP  DCSP self.headers = headers.copy() DCNL DCSP  DCSP del self.headers['Transfer-Encoding'] DCNL DCSP else: DCNL DCSP  DCSP self.headers = headers DCNL DCSP self.body = body
def read(self, amt=None): DCNL DCSP if (amt is None): DCNL DCSP  DCSP if (not self._cached_response): DCNL DCSP  DCSP  DCSP self._cached_response = http_client.HTTPResponse.read(self) DCNL DCSP  DCSP return self._cached_response DCNL DCSP else: DCNL DCSP  DCSP return http_client.HTTPResponse.read(self, amt)
def __init__(self, host, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, path='/', provider='aws', security_token=None, suppress_consec_slashes=True, validate_certs=True, profile_name=None): DCNL DCSP self.suppress_consec_slashes = suppress_consec_slashes DCNL DCSP self.num_retries = 6 DCNL DCSP if config.has_option('Boto', 'is_secure'): DCNL DCSP  DCSP is_secure = config.getboolean('Boto', 'is_secure') DCNL DCSP self.is_secure = is_secure DCNL DCSP self.https_validate_certificates = config.getbool('Boto', 'https_validate_certificates', validate_certs) DCNL DCSP if (self.https_validate_certificates and (not HAVE_HTTPS_CONNECTION)): DCNL DCSP  DCSP raise BotoClientError('SSL DCSP server DCSP certificate DCSP validation DCSP is DCSP enabled DCSP in DCSP boto DCSP configuration, DCSP but DCSP Python DCSP dependencies DCSP required DCSP to DCSP support DCSP this DCSP feature DCSP are DCSP not DCSP available. DCSP Certificate DCSP validation DCSP is DCSP only DCSP supported DCSP when DCSP running DCSP under DCSP Python DCSP 2.6 DCSP or DCSP later.') DCNL DCSP certs_file = config.get_value('Boto', 'ca_certificates_file', DEFAULT_CA_CERTS_FILE) DCNL DCSP if (certs_file == 'system'): DCNL DCSP  DCSP certs_file = None DCNL DCSP self.ca_certificates_file = certs_file DCNL DCSP if port: DCNL DCSP  DCSP self.port = port DCNL DCSP else: DCNL DCSP  DCSP self.port = PORTS_BY_SECURITY[is_secure] DCNL DCSP self.handle_proxy(proxy, proxy_port, proxy_user, proxy_pass) DCNL DCSP self.http_exceptions = (http_client.HTTPException, socket.error, socket.gaierror, http_client.BadStatusLine) DCNL DCSP self.http_unretryable_exceptions = [] DCNL DCSP if HAVE_HTTPS_CONNECTION: DCNL DCSP  DCSP self.http_unretryable_exceptions.append(https_connection.InvalidCertificateException) DCNL DCSP self.socket_exception_values = (errno.EINTR,) DCNL DCSP if (https_connection_factory is not None): DCNL DCSP  DCSP self.https_connection_factory = https_connection_factory[0] DCNL DCSP  DCSP self.http_exceptions += https_connection_factory[1] DCNL DCSP else: DCNL DCSP  DCSP self.https_connection_factory = None DCNL DCSP if is_secure: DCNL DCSP  DCSP self.protocol = 'https' DCNL DCSP else: DCNL DCSP  DCSP self.protocol = 'http' DCNL DCSP self.host = host DCNL DCSP self.path = path DCNL DCSP if (not isinstance(debug, six.integer_types)): DCNL DCSP  DCSP debug = 0 DCNL DCSP self.debug = config.getint('Boto', 'debug', debug) DCNL DCSP self.host_header = None DCNL DCSP self.http_connection_kwargs = {} DCNL DCSP if ((sys.version_info[0], sys.version_info[1]) >= (2, 6)): DCNL DCSP  DCSP self.http_connection_kwargs['timeout'] = config.getint('Boto', 'http_socket_timeout', 70) DCNL DCSP if isinstance(provider, Provider): DCNL DCSP  DCSP self.provider = provider DCNL DCSP else: DCNL DCSP  DCSP self._provider_type = provider DCNL DCSP  DCSP self.provider = Provider(self._provider_type, aws_access_key_id, aws_secret_access_key, security_token, profile_name) DCNL DCSP if self.provider.host: DCNL DCSP  DCSP self.host = self.provider.host DCNL DCSP if self.provider.port: DCNL DCSP  DCSP self.port = self.provider.port DCNL DCSP if self.provider.host_header: DCNL DCSP  DCSP self.host_header = self.provider.host_header DCNL DCSP self._pool = ConnectionPool() DCNL DCSP self._connection = (self.host, self.port, self.is_secure) DCNL DCSP self._last_rs = None DCNL DCSP self._auth_handler = auth.get_auth_handler(host, config, self.provider, self._required_auth_capability()) DCNL DCSP if (getattr(self, 'AuthServiceName', None) is not None): DCNL DCSP  DCSP self.auth_service_name = self.AuthServiceName DCNL DCSP self.request_hook = None
def _mexe(self, request, sender=None, override_num_retries=None, retry_handler=None): DCNL DCSP boto.log.debug(('Method: DCSP %s' % request.method)) DCNL DCSP boto.log.debug(('Path: DCSP %s' % request.path)) DCNL DCSP boto.log.debug(('Data: DCSP %s' % request.body)) DCNL DCSP boto.log.debug(('Headers: DCSP %s' % request.headers)) DCNL DCSP boto.log.debug(('Host: DCSP %s' % request.host)) DCNL DCSP boto.log.debug(('Port: DCSP %s' % request.port)) DCNL DCSP boto.log.debug(('Params: DCSP %s' % request.params)) DCNL DCSP response = None DCNL DCSP body = None DCNL DCSP ex = None DCNL DCSP if (override_num_retries is None): DCNL DCSP  DCSP num_retries = config.getint('Boto', 'num_retries', self.num_retries) DCNL DCSP else: DCNL DCSP  DCSP num_retries = override_num_retries DCNL DCSP i = 0 DCNL DCSP connection = self.get_http_connection(request.host, request.port, self.is_secure) DCNL DCSP if ((not isinstance(request.body, bytes)) and hasattr(request.body, 'encode')): DCNL DCSP  DCSP request.body = request.body.encode('utf-8') DCNL DCSP while (i <= num_retries): DCNL DCSP  DCSP next_sleep = min((random.random() * (2 ** i)), boto.config.get('Boto', 'max_retry_delay', 60)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boto.log.debug(('Token: DCSP %s' % self.provider.security_token)) DCNL DCSP  DCSP  DCSP request.authorize(connection=self) DCNL DCSP  DCSP  DCSP if ('s3' not in self._required_auth_capability()): DCNL DCSP  DCSP  DCSP  DCSP if (not getattr(self, 'anon', False)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not request.headers.get('Host')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.set_host_header(request) DCNL DCSP  DCSP  DCSP boto.log.debug(('Final DCSP headers: DCSP %s' % request.headers)) DCNL DCSP  DCSP  DCSP request.start_time = datetime.now() DCNL DCSP  DCSP  DCSP if callable(sender): DCNL DCSP  DCSP  DCSP  DCSP response = sender(connection, request.method, request.path, request.body, request.headers) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP connection.request(request.method, request.path, request.body, request.headers) DCNL DCSP  DCSP  DCSP  DCSP response = connection.getresponse() DCNL DCSP  DCSP  DCSP boto.log.debug(('Response DCSP headers: DCSP %s' % response.getheaders())) DCNL DCSP  DCSP  DCSP location = response.getheader('location') DCNL DCSP  DCSP  DCSP if ((request.method == 'HEAD') and getattr(response, 'chunked', False)): DCNL DCSP  DCSP  DCSP  DCSP response.chunked = 0 DCNL DCSP  DCSP  DCSP if callable(retry_handler): DCNL DCSP  DCSP  DCSP  DCSP status = retry_handler(response, i, next_sleep) DCNL DCSP  DCSP  DCSP  DCSP if status: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (msg, i, next_sleep) = status DCNL DCSP  DCSP  DCSP  DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP boto.log.debug(msg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(next_sleep) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (response.status in [500, 502, 503, 504]): DCNL DCSP  DCSP  DCSP  DCSP msg = ('Received DCSP %d DCSP response. DCSP  DCSP ' % response.status) DCNL DCSP  DCSP  DCSP  DCSP msg += ('Retrying DCSP in DCSP %3.1f DCSP seconds' % next_sleep) DCNL DCSP  DCSP  DCSP  DCSP boto.log.debug(msg) DCNL DCSP  DCSP  DCSP  DCSP body = response.read() DCNL DCSP  DCSP  DCSP  DCSP if isinstance(body, bytes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP body = body.decode('utf-8') DCNL DCSP  DCSP  DCSP elif ((response.status < 300) or (response.status >= 400) or (not location)): DCNL DCSP  DCSP  DCSP  DCSP conn_header_value = response.getheader('connection') DCNL DCSP  DCSP  DCSP  DCSP if (conn_header_value == 'close'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP connection.close() DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.put_http_connection(request.host, request.port, self.is_secure, connection) DCNL DCSP  DCSP  DCSP  DCSP if (self.request_hook is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.request_hook.handle_request_data(request, response) DCNL DCSP  DCSP  DCSP  DCSP return response DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (scheme, request.host, request.path, params, query, fragment) = urlparse(location) DCNL DCSP  DCSP  DCSP  DCSP if query: DCNL DCSP  DCSP  DCSP  DCSP  DCSP request.path += ('?' + query) DCNL DCSP  DCSP  DCSP  DCSP if (':' in request.host): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (request.host, request.port) = request.host.split(':', 1) DCNL DCSP  DCSP  DCSP  DCSP msg = (('Redirecting: DCSP %s' % scheme) + '://') DCNL DCSP  DCSP  DCSP  DCSP msg += (request.host + request.path) DCNL DCSP  DCSP  DCSP  DCSP boto.log.debug(msg) DCNL DCSP  DCSP  DCSP  DCSP connection = self.get_http_connection(request.host, request.port, (scheme == 'https')) DCNL DCSP  DCSP  DCSP  DCSP response = None DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP except PleaseRetryException as e: DCNL DCSP  DCSP  DCSP boto.log.debug(('encountered DCSP a DCSP retry DCSP exception: DCSP %s' % e)) DCNL DCSP  DCSP  DCSP connection = self.new_http_connection(request.host, request.port, self.is_secure) DCNL DCSP  DCSP  DCSP response = e.response DCNL DCSP  DCSP  DCSP ex = e DCNL DCSP  DCSP except self.http_exceptions as e: DCNL DCSP  DCSP  DCSP for unretryable in self.http_unretryable_exceptions: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(e, unretryable): DCNL DCSP  DCSP  DCSP  DCSP  DCSP boto.log.debug(('encountered DCSP unretryable DCSP %s DCSP exception, DCSP re-raising' % e.__class__.__name__)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP boto.log.debug(('encountered DCSP %s DCSP exception, DCSP reconnecting' % e.__class__.__name__)) DCNL DCSP  DCSP  DCSP connection = self.new_http_connection(request.host, request.port, self.is_secure) DCNL DCSP  DCSP  DCSP ex = e DCNL DCSP  DCSP time.sleep(next_sleep) DCNL DCSP  DCSP i += 1 DCNL DCSP if (self.request_hook is not None): DCNL DCSP  DCSP self.request_hook.handle_request_data(request, response, error=True) DCNL DCSP if response: DCNL DCSP  DCSP raise BotoServerError(response.status, response.reason, body) DCNL DCSP elif ex: DCNL DCSP  DCSP raise ex DCNL DCSP else: DCNL DCSP  DCSP msg = 'Please DCSP report DCSP this DCSP exception DCSP as DCSP a DCSP Boto DCSP Issue!' DCNL DCSP  DCSP raise BotoClientError(msg)
def make_request(self, method, path, headers=None, data='', host=None, auth_path=None, sender=None, override_num_retries=None, params=None, retry_handler=None): DCNL DCSP if (params is None): DCNL DCSP  DCSP params = {} DCNL DCSP http_request = self.build_base_http_request(method, path, auth_path, params, headers, data, host) DCNL DCSP return self._mexe(http_request, sender, override_num_retries, retry_handler=retry_handler)
def close(self): DCNL DCSP boto.log.debug('closing DCSP all DCSP HTTP DCSP connections') DCNL DCSP self._connection = None
def build_complex_list_params(self, params, items, label, names): DCNL DCSP for (i, item) in enumerate(items, 1): DCNL DCSP  DCSP current_prefix = ('%s.%s' % (label, i)) DCNL DCSP  DCSP for (key, value) in zip(names, item): DCNL DCSP  DCSP  DCSP full_key = ('%s.%s' % (current_prefix, key)) DCNL DCSP  DCSP  DCSP params[full_key] = value
def connect(self, **kw_params): DCNL DCSP if self.connection_cls: DCNL DCSP  DCSP return self.connection_cls(region=self, **kw_params)
def get_policy(self): DCNL DCSP return self.connection.get_stack_policy(self.stack_id)
def set_policy(self, stack_policy_body=None, stack_policy_url=None): DCNL DCSP return self.connection.set_stack_policy(self.stack_id, stack_policy_body=stack_policy_body, stack_policy_url=stack_policy_url)
def _build_create_or_update_params(self, stack_name, template_body, template_url, parameters, disable_rollback, timeout_in_minutes, notification_arns, capabilities, on_failure, stack_policy_body, stack_policy_url, tags, use_previous_template=None, stack_policy_during_update_body=None, stack_policy_during_update_url=None): DCNL DCSP params = {'ContentType': 'JSON', 'StackName': stack_name, 'DisableRollback': self.encode_bool(disable_rollback)} DCNL DCSP if template_body: DCNL DCSP  DCSP params['TemplateBody'] = template_body DCNL DCSP if template_url: DCNL DCSP  DCSP params['TemplateURL'] = template_url DCNL DCSP if (use_previous_template is not None): DCNL DCSP  DCSP params['UsePreviousTemplate'] = self.encode_bool(use_previous_template) DCNL DCSP if (template_body and template_url): DCNL DCSP  DCSP boto.log.warning('If DCSP both DCSP TemplateBody DCSP and DCSP TemplateURL DCSP are DCSP specified, DCSP only DCSP TemplateBody DCSP will DCSP be DCSP honored DCSP by DCSP the DCSP API') DCNL DCSP if (parameters and (len(parameters) > 0)): DCNL DCSP  DCSP for (i, parameter_tuple) in enumerate(parameters): DCNL DCSP  DCSP  DCSP (key, value) = parameter_tuple[:2] DCNL DCSP  DCSP  DCSP use_previous = (parameter_tuple[2] if (len(parameter_tuple) > 2) else False) DCNL DCSP  DCSP  DCSP params[('Parameters.member.%d.ParameterKey' % (i + 1))] = key DCNL DCSP  DCSP  DCSP if use_previous: DCNL DCSP  DCSP  DCSP  DCSP params[('Parameters.member.%d.UsePreviousValue' % (i + 1))] = self.encode_bool(use_previous) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP params[('Parameters.member.%d.ParameterValue' % (i + 1))] = value DCNL DCSP if capabilities: DCNL DCSP  DCSP for (i, value) in enumerate(capabilities): DCNL DCSP  DCSP  DCSP params[('Capabilities.member.%d' % (i + 1))] = value DCNL DCSP if tags: DCNL DCSP  DCSP for (i, (key, value)) in enumerate(tags.items()): DCNL DCSP  DCSP  DCSP params[('Tags.member.%d.Key' % (i + 1))] = key DCNL DCSP  DCSP  DCSP params[('Tags.member.%d.Value' % (i + 1))] = value DCNL DCSP if (notification_arns and (len(notification_arns) > 0)): DCNL DCSP  DCSP self.build_list_params(params, notification_arns, 'NotificationARNs.member') DCNL DCSP if timeout_in_minutes: DCNL DCSP  DCSP params['TimeoutInMinutes'] = int(timeout_in_minutes) DCNL DCSP if (disable_rollback is not None): DCNL DCSP  DCSP params['DisableRollback'] = str(disable_rollback).lower() DCNL DCSP if (on_failure is not None): DCNL DCSP  DCSP params['OnFailure'] = on_failure DCNL DCSP if (stack_policy_body is not None): DCNL DCSP  DCSP params['StackPolicyBody'] = stack_policy_body DCNL DCSP if (stack_policy_url is not None): DCNL DCSP  DCSP params['StackPolicyURL'] = stack_policy_url DCNL DCSP if (stack_policy_during_update_body is not None): DCNL DCSP  DCSP params['StackPolicyDuringUpdateBody'] = stack_policy_during_update_body DCNL DCSP if (stack_policy_during_update_url is not None): DCNL DCSP  DCSP params['StackPolicyDuringUpdateURL'] = stack_policy_during_update_url DCNL DCSP return params
def _do_request(self, call, params, path, method): DCNL DCSP response = self.make_request(call, params, path, method) DCNL DCSP body = response.read().decode('utf-8') DCNL DCSP if (response.status == 200): DCNL DCSP  DCSP body = json.loads(body) DCNL DCSP  DCSP return body DCNL DCSP else: DCNL DCSP  DCSP boto.log.error(('%s DCSP %s' % (response.status, response.reason))) DCNL DCSP  DCSP boto.log.error(('%s' % body)) DCNL DCSP  DCSP raise self.ResponseError(response.status, response.reason, body=body)
def create_stack(self, stack_name, template_body=None, template_url=None, parameters=None, notification_arns=None, disable_rollback=None, timeout_in_minutes=None, capabilities=None, tags=None, on_failure=None, stack_policy_body=None, stack_policy_url=None): DCNL DCSP params = self._build_create_or_update_params(stack_name, template_body, template_url, parameters, disable_rollback, timeout_in_minutes, notification_arns, capabilities, on_failure, stack_policy_body, stack_policy_url, tags) DCNL DCSP body = self._do_request('CreateStack', params, '/', 'POST') DCNL DCSP return body['CreateStackResponse']['CreateStackResult']['StackId']
def update_stack(self, stack_name, template_body=None, template_url=None, parameters=None, notification_arns=None, disable_rollback=False, timeout_in_minutes=None, capabilities=None, tags=None, use_previous_template=None, stack_policy_during_update_body=None, stack_policy_during_update_url=None, stack_policy_body=None, stack_policy_url=None): DCNL DCSP params = self._build_create_or_update_params(stack_name, template_body, template_url, parameters, disable_rollback, timeout_in_minutes, notification_arns, capabilities, None, stack_policy_body, stack_policy_url, tags, use_previous_template, stack_policy_during_update_body, stack_policy_during_update_url) DCNL DCSP body = self._do_request('UpdateStack', params, '/', 'POST') DCNL DCSP return body['UpdateStackResponse']['UpdateStackResult']['StackId']
def delete_stack(self, stack_name_or_id): DCNL DCSP params = {'ContentType': 'JSON', 'StackName': stack_name_or_id} DCNL DCSP return self._do_request('DeleteStack', params, '/', 'GET')
def describe_stack_events(self, stack_name_or_id=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if stack_name_or_id: DCNL DCSP  DCSP params['StackName'] = stack_name_or_id DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('DescribeStackEvents', params, [('member', StackEvent)])
def describe_stack_resource(self, stack_name_or_id, logical_resource_id): DCNL DCSP params = {'ContentType': 'JSON', 'StackName': stack_name_or_id, 'LogicalResourceId': logical_resource_id} DCNL DCSP return self._do_request('DescribeStackResource', params, '/', 'GET')
def describe_stack_resources(self, stack_name_or_id=None, logical_resource_id=None, physical_resource_id=None): DCNL DCSP params = {} DCNL DCSP if stack_name_or_id: DCNL DCSP  DCSP params['StackName'] = stack_name_or_id DCNL DCSP if logical_resource_id: DCNL DCSP  DCSP params['LogicalResourceId'] = logical_resource_id DCNL DCSP if physical_resource_id: DCNL DCSP  DCSP params['PhysicalResourceId'] = physical_resource_id DCNL DCSP return self.get_list('DescribeStackResources', params, [('member', StackResource)])
def describe_stacks(self, stack_name_or_id=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if stack_name_or_id: DCNL DCSP  DCSP params['StackName'] = stack_name_or_id DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('DescribeStacks', params, [('member', Stack)])
def get_template(self, stack_name_or_id): DCNL DCSP params = {'ContentType': 'JSON', 'StackName': stack_name_or_id} DCNL DCSP return self._do_request('GetTemplate', params, '/', 'GET')
def list_stack_resources(self, stack_name_or_id, next_token=None): DCNL DCSP params = {'StackName': stack_name_or_id} DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.get_list('ListStackResources', params, [('member', StackResourceSummary)])
def list_stacks(self, stack_status_filters=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP if (stack_status_filters and (len(stack_status_filters) > 0)): DCNL DCSP  DCSP self.build_list_params(params, stack_status_filters, 'StackStatusFilter.member') DCNL DCSP return self.get_list('ListStacks', params, [('member', StackSummary)])
def validate_template(self, template_body=None, template_url=None): DCNL DCSP params = {} DCNL DCSP if template_body: DCNL DCSP  DCSP params['TemplateBody'] = template_body DCNL DCSP if template_url: DCNL DCSP  DCSP params['TemplateURL'] = template_url DCNL DCSP if (template_body and template_url): DCNL DCSP  DCSP boto.log.warning('If DCSP both DCSP TemplateBody DCSP and DCSP TemplateURL DCSP are DCSP specified, DCSP only DCSP TemplateBody DCSP will DCSP be DCSP honored DCSP by DCSP the DCSP API') DCNL DCSP return self.get_object('ValidateTemplate', params, Template, verb='POST')
def cancel_update_stack(self, stack_name_or_id=None): DCNL DCSP params = {} DCNL DCSP if stack_name_or_id: DCNL DCSP  DCSP params['StackName'] = stack_name_or_id DCNL DCSP return self.get_status('CancelUpdateStack', params)
def estimate_template_cost(self, template_body=None, template_url=None, parameters=None): DCNL DCSP params = {'ContentType': 'JSON'} DCNL DCSP if (template_body is not None): DCNL DCSP  DCSP params['TemplateBody'] = template_body DCNL DCSP if (template_url is not None): DCNL DCSP  DCSP params['TemplateURL'] = template_url DCNL DCSP if (parameters and (len(parameters) > 0)): DCNL DCSP  DCSP for (i, (key, value)) in enumerate(parameters): DCNL DCSP  DCSP  DCSP params[('Parameters.member.%d.ParameterKey' % (i + 1))] = key DCNL DCSP  DCSP  DCSP params[('Parameters.member.%d.ParameterValue' % (i + 1))] = value DCNL DCSP response = self._do_request('EstimateTemplateCost', params, '/', 'POST') DCNL DCSP return response['EstimateTemplateCostResponse']['EstimateTemplateCostResult']['Url']
def get_stack_policy(self, stack_name_or_id): DCNL DCSP params = {'ContentType': 'JSON', 'StackName': stack_name_or_id} DCNL DCSP response = self._do_request('GetStackPolicy', params, '/', 'POST') DCNL DCSP return response['GetStackPolicyResponse']['GetStackPolicyResult']['StackPolicyBody']
def set_stack_policy(self, stack_name_or_id, stack_policy_body=None, stack_policy_url=None): DCNL DCSP params = {'ContentType': 'JSON', 'StackName': stack_name_or_id} DCNL DCSP if (stack_policy_body is not None): DCNL DCSP  DCSP params['StackPolicyBody'] = stack_policy_body DCNL DCSP if (stack_policy_url is not None): DCNL DCSP  DCSP params['StackPolicyURL'] = stack_policy_url DCNL DCSP response = self._do_request('SetStackPolicy', params, '/', 'POST') DCNL DCSP return response['SetStackPolicyResponse']
@needs_caller_reference DCNL @complex_amounts('SettlementAmount') DCNL @requires(['CreditInstrumentId', 'SettlementAmount.Value', 'SenderTokenId', 'SettlementAmount.CurrencyCode']) DCNL @api_action() DCNL def settle_debt(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['TransactionId']) DCNL @api_action() DCNL def get_transaction_status(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['StartDate']) DCNL @api_action() DCNL def get_account_activity(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['TransactionId']) DCNL @api_action() DCNL def get_transaction(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@api_action() DCNL def get_outstanding_debt_balance(self, action, response): DCNL DCSP return self.get_object(action, {}, response)
@requires(['PrepaidInstrumentId']) DCNL @api_action() DCNL def get_prepaid_balance(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@api_action() DCNL def get_total_prepaid_liability(self, action, response): DCNL DCSP return self.get_object(action, {}, response)
@api_action() DCNL def get_account_balance(self, action, response): DCNL DCSP return self.get_object(action, {}, response)
@needs_caller_reference DCNL @requires(['PaymentInstruction', 'TokenType']) DCNL @api_action() DCNL def install_payment_instruction(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@needs_caller_reference DCNL @requires(['returnURL', 'pipelineName']) DCNL def cbui_url(self, **kw): DCNL DCSP sandbox = ((('sandbox' in self.host) and 'payments-sandbox') or 'payments') DCNL DCSP endpoint = 'authorize.{0}.amazon.com'.format(sandbox) DCNL DCSP base = '/cobranded-ui/actions/start' DCNL DCSP validpipelines = ('SingleUse', 'MultiUse', 'Recurring', 'Recipient', 'SetupPrepaid', 'SetupPostpaid', 'EditToken') DCNL DCSP assert (kw['pipelineName'] in validpipelines), 'Invalid DCSP pipelineName' DCNL DCSP kw.update({'signatureMethod': 'HmacSHA256', 'signatureVersion': '2'}) DCNL DCSP kw.setdefault('callerKey', self.aws_access_key_id) DCNL DCSP safestr = (lambda x: (((x is not None) and str(x)) or '')) DCNL DCSP safequote = (lambda x: urllib.quote(safestr(x), safe='~')) DCNL DCSP payload = sorted([(k, safequote(v)) for (k, v) in kw.items()]) DCNL DCSP encoded = (lambda p: '&'.join([((k + '=') + v) for (k, v) in p])) DCNL DCSP canonical = '\n'.join(['GET', endpoint, base, encoded(payload)]) DCNL DCSP signature = self._auth_handler.sign_string(canonical) DCNL DCSP payload += [('signature', safequote(signature))] DCNL DCSP payload.sort() DCNL DCSP return 'https://{0}{1}?{2}'.format(endpoint, base, encoded(payload))
@needs_caller_reference DCNL @complex_amounts('TransactionAmount') DCNL @requires(['SenderTokenId', 'TransactionAmount.Value', 'TransactionAmount.CurrencyCode']) DCNL @api_action() DCNL def reserve(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@needs_caller_reference DCNL @complex_amounts('TransactionAmount') DCNL @requires(['SenderTokenId', 'TransactionAmount.Value', 'TransactionAmount.CurrencyCode']) DCNL @api_action() DCNL def pay(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['TransactionId']) DCNL @api_action() DCNL def cancel(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@complex_amounts('TransactionAmount') DCNL @requires(['ReserveTransactionId', 'TransactionAmount.Value', 'TransactionAmount.CurrencyCode']) DCNL @api_action() DCNL def settle(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@complex_amounts('RefundAmount') DCNL @requires(['TransactionId', 'RefundAmount.Value', 'CallerReference', 'RefundAmount.CurrencyCode']) DCNL @api_action() DCNL def refund(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['RecipientTokenId']) DCNL @api_action() DCNL def get_recipient_verification_status(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['CallerReference'], ['TokenId']) DCNL @api_action() DCNL def get_token_by_caller(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['UrlEndPoint', 'HttpParameters']) DCNL @api_action() DCNL def verify_signature(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@api_action() DCNL def get_tokens(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['TokenId']) DCNL @api_action() DCNL def get_token_usage(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['TokenId']) DCNL @api_action() DCNL def cancel_token(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@needs_caller_reference DCNL @complex_amounts('FundingAmount') DCNL @requires(['PrepaidInstrumentId', 'FundingAmount.Value', 'SenderTokenId', 'FundingAmount.CurrencyCode']) DCNL @api_action() DCNL def fund_prepaid(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['CreditInstrumentId']) DCNL @api_action() DCNL def get_debt_balance(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@needs_caller_reference DCNL @complex_amounts('AdjustmentAmount') DCNL @requires(['CreditInstrumentId', 'AdjustmentAmount.Value', 'AdjustmentAmount.CurrencyCode']) DCNL @api_action() DCNL def write_off_debt(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['SubscriptionId']) DCNL @api_action() DCNL def get_transactions_for_subscription(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@requires(['SubscriptionId']) DCNL @api_action() DCNL def get_subscription_details(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
@needs_caller_reference DCNL @complex_amounts('RefundAmount') DCNL @requires(['SubscriptionId']) DCNL @api_action() DCNL def cancel_subscription_and_refund(self, action, response, **kw): DCNL DCSP message = 'If DCSP you DCSP specify DCSP a DCSP RefundAmount, DCSP you DCSP must DCSP specify DCSP CallerReference.' DCNL DCSP assert ((not ('RefundAmount.Value' in kw)) or ('CallerReference' in kw)), message DCNL DCSP return self.get_object(action, kw, response)
@requires(['TokenId']) DCNL @api_action() DCNL def get_payment_instruction(self, action, response, **kw): DCNL DCSP return self.get_object(action, kw, response)
def connect(self, num_retries=5): DCNL DCSP retry = 0 DCNL DCSP while (retry < num_retries): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self._ssh_client.connect(self.server.hostname, username=self.uname, pkey=self._pkey, timeout=self._timeout) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except socket.error as xxx_todo_changeme: DCNL DCSP  DCSP  DCSP (value, message) = xxx_todo_changeme.args DCNL DCSP  DCSP  DCSP if (value in (51, 61, 111)): DCNL DCSP  DCSP  DCSP  DCSP print 'SSH DCSP Connection DCSP refused, DCSP will DCSP retry DCSP in DCSP 5 DCSP seconds' DCNL DCSP  DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP  DCSP retry += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except paramiko.BadHostKeyException: DCNL DCSP  DCSP  DCSP print ("%s DCSP has DCSP an DCSP entry DCSP in DCSP ~/.ssh/known_hosts DCSP and DCSP it DCSP doesn't DCSP match" % self.server.hostname) DCNL DCSP  DCSP  DCSP print 'Edit DCSP that DCSP file DCSP to DCSP remove DCSP the DCSP entry DCSP and DCSP then DCSP hit DCSP return DCSP to DCSP try DCSP again' DCNL DCSP  DCSP  DCSP raw_input('Hit DCSP Enter DCSP when DCSP ready') DCNL DCSP  DCSP  DCSP retry += 1 DCNL DCSP  DCSP except EOFError: DCNL DCSP  DCSP  DCSP print 'Unexpected DCSP Error DCSP from DCSP SSH DCSP Connection, DCSP retry DCSP in DCSP 5 DCSP seconds' DCNL DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP retry += 1 DCNL DCSP print 'Could DCSP not DCSP establish DCSP SSH DCSP connection'
def open_sftp(self): DCNL DCSP return self._ssh_client.open_sftp()
def get_file(self, src, dst): DCNL DCSP sftp_client = self.open_sftp() DCNL DCSP sftp_client.get(src, dst)
def put_file(self, src, dst): DCNL DCSP sftp_client = self.open_sftp() DCNL DCSP sftp_client.put(src, dst)
def open(self, filename, mode='r', bufsize=(-1)): DCNL DCSP sftp_client = self.open_sftp() DCNL DCSP return sftp_client.open(filename, mode, bufsize)
def listdir(self, path): DCNL DCSP sftp_client = self.open_sftp() DCNL DCSP return sftp_client.listdir(path)
def isdir(self, path): DCNL DCSP status = self.run(('[ DCSP -d DCSP %s DCSP ] DCSP || DCSP echo DCSP "FALSE"' % path)) DCNL DCSP if status[1].startswith('FALSE'): DCNL DCSP  DCSP return 0 DCNL DCSP return 1
def exists(self, path): DCNL DCSP status = self.run(('[ DCSP -a DCSP %s DCSP ] DCSP || DCSP echo DCSP "FALSE"' % path)) DCNL DCSP if status[1].startswith('FALSE'): DCNL DCSP  DCSP return 0 DCNL DCSP return 1
def shell(self): DCNL DCSP channel = self._ssh_client.invoke_shell() DCNL DCSP interactive_shell(channel)
def run(self, command): DCNL DCSP boto.log.debug(('running:%s DCSP on DCSP %s' % (command, self.server.instance_id))) DCNL DCSP status = 0 DCNL DCSP try: DCNL DCSP  DCSP t = self._ssh_client.exec_command(command) DCNL DCSP except paramiko.SSHException: DCNL DCSP  DCSP status = 1 DCNL DCSP std_out = t[1].read() DCNL DCSP std_err = t[2].read() DCNL DCSP t[0].close() DCNL DCSP t[1].close() DCNL DCSP t[2].close() DCNL DCSP boto.log.debug(('stdout: DCSP %s' % std_out)) DCNL DCSP boto.log.debug(('stderr: DCSP %s' % std_err)) DCNL DCSP return (status, std_out, std_err)
def run_pty(self, command): DCNL DCSP boto.log.debug(('running:%s DCSP on DCSP %s' % (command, self.server.instance_id))) DCNL DCSP channel = self._ssh_client.get_transport().open_session() DCNL DCSP channel.get_pty() DCNL DCSP channel.exec_command(command) DCNL DCSP return channel
def close(self): DCNL DCSP transport = self._ssh_client.get_transport() DCNL DCSP transport.close() DCNL DCSP self.server.reset_cmdshell()
def get_file(self, src, dst): DCNL DCSP shutil.copyfile(src, dst)
def put_file(self, src, dst): DCNL DCSP shutil.copyfile(src, dst)
def listdir(self, path): DCNL DCSP return os.listdir(path)
def isdir(self, path): DCNL DCSP return os.path.isdir(path)
def exists(self, path): DCNL DCSP return os.path.exists(path)
def run(self): DCNL DCSP boto.log.info(('running:%s' % self.command)) DCNL DCSP log_fp = StringIO() DCNL DCSP process = subprocess.Popen(self.command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP while (process.poll() is None): DCNL DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP t = process.communicate() DCNL DCSP  DCSP log_fp.write(t[0]) DCNL DCSP  DCSP log_fp.write(t[1]) DCNL DCSP boto.log.info(log_fp.getvalue()) DCNL DCSP boto.log.info(('output: DCSP %s' % log_fp.getvalue())) DCNL DCSP return (process.returncode, log_fp.getvalue())
@classmethod DCNL def create(cls, config_file=None, logical_volume=None, cfg=None, **params): DCNL DCSP if config_file: DCNL DCSP  DCSP cfg = Config(path=config_file) DCNL DCSP if cfg.has_section('EC2'): DCNL DCSP  DCSP for option in cfg.options('EC2'): DCNL DCSP  DCSP  DCSP if (option not in params): DCNL DCSP  DCSP  DCSP  DCSP params[option] = cfg.get('EC2', option) DCNL DCSP getter = CommandLineGetter() DCNL DCSP getter.get(cls, params) DCNL DCSP region = params.get('region') DCNL DCSP ec2 = region.connect() DCNL DCSP cls.add_credentials(cfg, ec2.aws_access_key_id, ec2.aws_secret_access_key) DCNL DCSP ami = params.get('ami') DCNL DCSP kp = params.get('keypair') DCNL DCSP group = params.get('group') DCNL DCSP zone = params.get('zone') DCNL DCSP if (logical_volume != None): DCNL DCSP  DCSP cfg.set('EBS', 'logical_volume_name', logical_volume.name) DCNL DCSP cfg_fp = StringIO() DCNL DCSP cfg.write(cfg_fp) DCNL DCSP if isinstance(zone, Zone): DCNL DCSP  DCSP zone = zone.name DCNL DCSP if isinstance(kp, KeyPair): DCNL DCSP  DCSP kp = kp.name DCNL DCSP reservation = ami.run(min_count=1, max_count=params.get('quantity', 1), key_name=kp, security_groups=[group], instance_type=params.get('instance_type'), placement=zone, user_data=cfg_fp.getvalue()) DCNL DCSP l = [] DCNL DCSP i = 0 DCNL DCSP elastic_ip = params.get('elastic_ip') DCNL DCSP instances = reservation.instances DCNL DCSP if ((elastic_ip is not None) and (instances.__len__() > 0)): DCNL DCSP  DCSP instance = instances[0] DCNL DCSP  DCSP print 'Waiting DCSP for DCSP instance DCSP to DCSP start DCSP so DCSP we DCSP can DCSP set DCSP its DCSP elastic DCSP IP DCSP address...' DCNL DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP while (instance.update() != 'running'): DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP instance.use_ip(elastic_ip) DCNL DCSP  DCSP print ('set DCSP the DCSP elastic DCSP IP DCSP of DCSP the DCSP first DCSP instance DCSP to DCSP %s' % elastic_ip) DCNL DCSP for instance in instances: DCNL DCSP  DCSP s = cls() DCNL DCSP  DCSP s.ec2 = ec2 DCNL DCSP  DCSP s.name = ((params.get('name') + '') if (i == 0) else str(i)) DCNL DCSP  DCSP s.description = params.get('description') DCNL DCSP  DCSP s.region_name = region.name DCNL DCSP  DCSP s.instance_id = instance.id DCNL DCSP  DCSP if (elastic_ip and (i == 0)): DCNL DCSP  DCSP  DCSP s.elastic_ip = elastic_ip DCNL DCSP  DCSP s.put() DCNL DCSP  DCSP l.append(s) DCNL DCSP  DCSP i += 1 DCNL DCSP return l
def get_snapshots(self): DCNL DCSP ec2 = self.get_ec2_connection() DCNL DCSP rs = ec2.get_all_snapshots() DCNL DCSP all_vols = ([self.volume_id] + self.past_volume_ids) DCNL DCSP snaps = [] DCNL DCSP for snapshot in rs: DCNL DCSP  DCSP if (snapshot.volume_id in all_vols): DCNL DCSP  DCSP  DCSP if (snapshot.progress == '100%'): DCNL DCSP  DCSP  DCSP  DCSP snapshot.date = boto.utils.parse_ts(snapshot.start_time) DCNL DCSP  DCSP  DCSP  DCSP snapshot.keep = True DCNL DCSP  DCSP  DCSP  DCSP snaps.append(snapshot) DCNL DCSP snaps.sort(cmp=(lambda x, y: cmp(x.date, y.date))) DCNL DCSP return snaps
def trim_snapshots(self, delete=False): DCNL DCSP snaps = self.get_snapshots() DCNL DCSP if (len(snaps) <= 2): DCNL DCSP  DCSP return snaps DCNL DCSP snaps = snaps[1:(-1)] DCNL DCSP now = datetime.datetime.now(snaps[0].date.tzinfo) DCNL DCSP midnight = datetime.datetime(year=now.year, month=now.month, day=now.day, tzinfo=now.tzinfo) DCNL DCSP one_week = datetime.timedelta(days=7, seconds=(60 * 60)) DCNL DCSP print((midnight - one_week), midnight) DCNL DCSP previous_week = self.get_snapshot_range(snaps, (midnight - one_week), midnight) DCNL DCSP print(previous_week) DCNL DCSP if (not previous_week): DCNL DCSP  DCSP return snaps DCNL DCSP current_day = None DCNL DCSP for snap in previous_week: DCNL DCSP  DCSP if (current_day and (current_day == snap.date.day)): DCNL DCSP  DCSP  DCSP snap.keep = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP current_day = snap.date.day DCNL DCSP if previous_week: DCNL DCSP  DCSP week_boundary = previous_week[0].date DCNL DCSP  DCSP if (week_boundary.weekday() != 0): DCNL DCSP  DCSP  DCSP delta = datetime.timedelta(days=week_boundary.weekday()) DCNL DCSP  DCSP  DCSP week_boundary = (week_boundary - delta) DCNL DCSP partial_week = self.get_snapshot_range(snaps, week_boundary, previous_week[0].date) DCNL DCSP if (len(partial_week) > 1): DCNL DCSP  DCSP for snap in partial_week[1:]: DCNL DCSP  DCSP  DCSP snap.keep = False DCNL DCSP for i in range(0, 4): DCNL DCSP  DCSP weeks_worth = self.get_snapshot_range(snaps, (week_boundary - one_week), week_boundary) DCNL DCSP  DCSP if (len(weeks_worth) > 1): DCNL DCSP  DCSP  DCSP for snap in weeks_worth[1:]: DCNL DCSP  DCSP  DCSP  DCSP snap.keep = False DCNL DCSP  DCSP week_boundary = (week_boundary - one_week) DCNL DCSP remainder = self.get_snapshot_range(snaps, end_date=week_boundary) DCNL DCSP current_month = None DCNL DCSP for snap in remainder: DCNL DCSP  DCSP if (current_month and (current_month == snap.date.month)): DCNL DCSP  DCSP  DCSP snap.keep = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP current_month = snap.date.month DCNL DCSP if delete: DCNL DCSP  DCSP for snap in snaps: DCNL DCSP  DCSP  DCSP if (not snap.keep): DCNL DCSP  DCSP  DCSP  DCSP boto.log.info(('Deleting DCSP %s(%s) DCSP for DCSP %s' % (snap, snap.date, self.name))) DCNL DCSP  DCSP  DCSP  DCSP snap.delete() DCNL DCSP return snaps
def check(self): DCNL DCSP boto.log.info(('checking DCSP Task[%s]-now=%s, DCSP last=%s' % (self.name, self.now, self.last_executed))) DCNL DCSP if (self.hourly and (not self.last_executed)): DCNL DCSP  DCSP return 0 DCNL DCSP if (self.daily and (not self.last_executed)): DCNL DCSP  DCSP if (int(self.hour) == self.now.hour): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ((max((int(self.hour) - self.now.hour), (self.now.hour - int(self.hour))) * 60) * 60) DCNL DCSP delta = (self.now - self.last_executed) DCNL DCSP if self.hourly: DCNL DCSP  DCSP if (delta.seconds >= (60 * 60)): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ((60 * 60) - delta.seconds) DCNL DCSP elif (int(self.hour) == self.now.hour): DCNL DCSP  DCSP if (delta.days >= 1): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 82800 DCNL DCSP else: DCNL DCSP  DCSP return ((max((int(self.hour) - self.now.hour), (self.now.hour - int(self.hour))) * 60) * 60)
def add_tags_to_stream(self, stream_name, tags): DCNL DCSP params = {'StreamName': stream_name, 'Tags': tags} DCNL DCSP return self.make_request(action='AddTagsToStream', body=json.dumps(params))
def create_stream(self, stream_name, shard_count): DCNL DCSP params = {'StreamName': stream_name, 'ShardCount': shard_count} DCNL DCSP return self.make_request(action='CreateStream', body=json.dumps(params))
def delete_stream(self, stream_name): DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP return self.make_request(action='DeleteStream', body=json.dumps(params))
def describe_stream(self, stream_name, limit=None, exclusive_start_shard_id=None): DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP if (exclusive_start_shard_id is not None): DCNL DCSP  DCSP params['ExclusiveStartShardId'] = exclusive_start_shard_id DCNL DCSP return self.make_request(action='DescribeStream', body=json.dumps(params))
def get_records(self, shard_iterator, limit=None, b64_decode=True): DCNL DCSP params = {'ShardIterator': shard_iterator} DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP response = self.make_request(action='GetRecords', body=json.dumps(params)) DCNL DCSP if b64_decode: DCNL DCSP  DCSP for record in response.get('Records', []): DCNL DCSP  DCSP  DCSP record['Data'] = base64.b64decode(record['Data'].encode('utf-8')).decode('utf-8') DCNL DCSP return response
def get_shard_iterator(self, stream_name, shard_id, shard_iterator_type, starting_sequence_number=None): DCNL DCSP params = {'StreamName': stream_name, 'ShardId': shard_id, 'ShardIteratorType': shard_iterator_type} DCNL DCSP if (starting_sequence_number is not None): DCNL DCSP  DCSP params['StartingSequenceNumber'] = starting_sequence_number DCNL DCSP return self.make_request(action='GetShardIterator', body=json.dumps(params))
def list_streams(self, limit=None, exclusive_start_stream_name=None): DCNL DCSP params = {} DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP if (exclusive_start_stream_name is not None): DCNL DCSP  DCSP params['ExclusiveStartStreamName'] = exclusive_start_stream_name DCNL DCSP return self.make_request(action='ListStreams', body=json.dumps(params))
def list_tags_for_stream(self, stream_name, exclusive_start_tag_key=None, limit=None): DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP if (exclusive_start_tag_key is not None): DCNL DCSP  DCSP params['ExclusiveStartTagKey'] = exclusive_start_tag_key DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['Limit'] = limit DCNL DCSP return self.make_request(action='ListTagsForStream', body=json.dumps(params))
def merge_shards(self, stream_name, shard_to_merge, adjacent_shard_to_merge): DCNL DCSP params = {'StreamName': stream_name, 'ShardToMerge': shard_to_merge, 'AdjacentShardToMerge': adjacent_shard_to_merge} DCNL DCSP return self.make_request(action='MergeShards', body=json.dumps(params))
def put_record(self, stream_name, data, partition_key, explicit_hash_key=None, sequence_number_for_ordering=None, exclusive_minimum_sequence_number=None, b64_encode=True): DCNL DCSP params = {'StreamName': stream_name, 'Data': data, 'PartitionKey': partition_key} DCNL DCSP if (explicit_hash_key is not None): DCNL DCSP  DCSP params['ExplicitHashKey'] = explicit_hash_key DCNL DCSP if (sequence_number_for_ordering is not None): DCNL DCSP  DCSP params['SequenceNumberForOrdering'] = sequence_number_for_ordering DCNL DCSP if b64_encode: DCNL DCSP  DCSP if (not isinstance(params['Data'], six.binary_type)): DCNL DCSP  DCSP  DCSP params['Data'] = params['Data'].encode('utf-8') DCNL DCSP  DCSP params['Data'] = base64.b64encode(params['Data']).decode('utf-8') DCNL DCSP return self.make_request(action='PutRecord', body=json.dumps(params))
def put_records(self, records, stream_name, b64_encode=True): DCNL DCSP params = {'Records': records, 'StreamName': stream_name} DCNL DCSP if b64_encode: DCNL DCSP  DCSP for i in range(len(params['Records'])): DCNL DCSP  DCSP  DCSP data = params['Records'][i]['Data'] DCNL DCSP  DCSP  DCSP if (not isinstance(data, six.binary_type)): DCNL DCSP  DCSP  DCSP  DCSP data = data.encode('utf-8') DCNL DCSP  DCSP  DCSP params['Records'][i]['Data'] = base64.b64encode(data).decode('utf-8') DCNL DCSP return self.make_request(action='PutRecords', body=json.dumps(params))
def remove_tags_from_stream(self, stream_name, tag_keys): DCNL DCSP params = {'StreamName': stream_name, 'TagKeys': tag_keys} DCNL DCSP return self.make_request(action='RemoveTagsFromStream', body=json.dumps(params))
def split_shard(self, stream_name, shard_to_split, new_starting_hash_key): DCNL DCSP params = {'StreamName': stream_name, 'ShardToSplit': shard_to_split, 'NewStartingHashKey': new_starting_hash_key} DCNL DCSP return self.make_request(action='SplitShard', body=json.dumps(params))
def process_args(self, **args): DCNL DCSP self.args.update(args) DCNL DCSP self.connection_args = copy.copy(self.args) DCNL DCSP if (('debug' in self.args) and (self.args['debug'] >= 2)): DCNL DCSP  DCSP boto.set_stream_logger(self.name()) DCNL DCSP required = [p.name for p in (self.Params + self.Args) if (not p.optional)] DCNL DCSP for param in (self.Params + self.Args): DCNL DCSP  DCSP if param.long_name: DCNL DCSP  DCSP  DCSP python_name = param.long_name.replace('-', '_') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP python_name = boto.utils.pythonize_name(param.name, '_') DCNL DCSP  DCSP value = None DCNL DCSP  DCSP if (python_name in self.args): DCNL DCSP  DCSP  DCSP value = self.args[python_name] DCNL DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP value = param.default DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP if (param.name in required): DCNL DCSP  DCSP  DCSP  DCSP required.remove(param.name) DCNL DCSP  DCSP  DCSP if param.request_param: DCNL DCSP  DCSP  DCSP  DCSP if param.encoder: DCNL DCSP  DCSP  DCSP  DCSP  DCSP param.encoder(param, self.request_params, value) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP Encoder.encode(param, self.request_params, value) DCNL DCSP  DCSP if (python_name in self.args): DCNL DCSP  DCSP  DCSP del self.connection_args[python_name] DCNL DCSP if required: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for p in (self.Params + self.Args): DCNL DCSP  DCSP  DCSP if (p.name in required): DCNL DCSP  DCSP  DCSP  DCSP if (p.short_name and p.long_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.append(('(%s, DCSP %s)' % (p.optparse_short_name, p.optparse_long_name))) DCNL DCSP  DCSP  DCSP  DCSP elif p.short_name: DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.append(('(%s)' % p.optparse_short_name)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.append(('(%s)' % p.optparse_long_name)) DCNL DCSP  DCSP raise RequiredParamError(','.join(l)) DCNL DCSP boto.log.debug(('request_params: DCSP %s' % self.request_params)) DCNL DCSP self.process_markers(self.Response)
def cli_formatter(self, data): DCNL DCSP if data: DCNL DCSP  DCSP self._generic_cli_formatter(self.Response, data)
@classmethod DCNL def convert_boolean(cls, param, value): DCNL DCSP return True
def convert(self, value): DCNL DCSP return super(Param, self).convert(self, value)
def check_for_credential_file(self): DCNL DCSP if ('AWS_CREDENTIAL_FILE' in os.environ): DCNL DCSP  DCSP path = os.environ['AWS_CREDENTIAL_FILE'] DCNL DCSP  DCSP path = os.path.expanduser(path) DCNL DCSP  DCSP path = os.path.expandvars(path) DCNL DCSP  DCSP if os.path.isfile(path): DCNL DCSP  DCSP  DCSP fp = open(path) DCNL DCSP  DCSP  DCSP lines = fp.readlines() DCNL DCSP  DCSP  DCSP fp.close() DCNL DCSP  DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP  DCSP if (line[0] != '#'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('=' in line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (name, value) = line.split('=', 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (name.strip() == 'AWSAccessKeyId'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('aws_access_key_id' not in self.args): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = value.strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.args['aws_access_key_id'] = value DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (name.strip() == 'AWSSecretKey'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('aws_secret_access_key' not in self.args): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = value.strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.args['aws_secret_access_key'] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print('Warning: DCSP unable DCSP to DCSP read DCSP AWS_CREDENTIAL_FILE')
def check_for_env_url(self): DCNL DCSP url = self.args.get('url', None) DCNL DCSP if url: DCNL DCSP  DCSP del self.args['url'] DCNL DCSP if ((not url) and (self.EnvURL in os.environ)): DCNL DCSP  DCSP url = os.environ[self.EnvURL] DCNL DCSP if url: DCNL DCSP  DCSP rslt = urlparse.urlparse(url) DCNL DCSP  DCSP if ('is_secure' not in self.args): DCNL DCSP  DCSP  DCSP if (rslt.scheme == 'https'): DCNL DCSP  DCSP  DCSP  DCSP self.args['is_secure'] = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self.args['is_secure'] = False DCNL DCSP  DCSP host = rslt.netloc DCNL DCSP  DCSP port = None DCNL DCSP  DCSP l = host.split(':') DCNL DCSP  DCSP if (len(l) > 1): DCNL DCSP  DCSP  DCSP host = l[0] DCNL DCSP  DCSP  DCSP port = int(l[1]) DCNL DCSP  DCSP if ('host' not in self.args): DCNL DCSP  DCSP  DCSP self.args['host'] = host DCNL DCSP  DCSP if (port and ('port' not in self.args)): DCNL DCSP  DCSP  DCSP self.args['port'] = port DCNL DCSP  DCSP if (rslt.path and ('path' not in self.args)): DCNL DCSP  DCSP  DCSP self.args['path'] = rslt.path
def delete(self): DCNL DCSP self.layer1.delete_vault(self.name)
def upload_archive(self, filename, description=None): DCNL DCSP if (os.path.getsize(filename) > self.SingleOperationThreshold): DCNL DCSP  DCSP return self.create_archive_from_file(filename, description=description) DCNL DCSP return self._upload_archive_single_operation(filename, description)
def _upload_archive_single_operation(self, filename, description): DCNL DCSP with open(filename, 'rb') as fileobj: DCNL DCSP  DCSP (linear_hash, tree_hash) = compute_hashes_from_fileobj(fileobj) DCNL DCSP  DCSP fileobj.seek(0) DCNL DCSP  DCSP response = self.layer1.upload_archive(self.name, fileobj, linear_hash, tree_hash, description) DCNL DCSP return response['ArchiveId']
def create_archive_writer(self, part_size=DefaultPartSize, description=None): DCNL DCSP response = self.layer1.initiate_multipart_upload(self.name, part_size, description) DCNL DCSP return Writer(self, response['UploadId'], part_size=part_size)
def create_archive_from_file(self, filename=None, file_obj=None, description=None, upload_id_callback=None): DCNL DCSP part_size = self.DefaultPartSize DCNL DCSP if (not file_obj): DCNL DCSP  DCSP file_size = os.path.getsize(filename) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP part_size = minimum_part_size(file_size, part_size) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise UploadArchiveError('File DCSP size DCSP of DCSP %s DCSP bytes DCSP exceeds DCSP 40,000 DCSP GB DCSP archive DCSP limit DCSP of DCSP Glacier.') DCNL DCSP  DCSP file_obj = open(filename, 'rb') DCNL DCSP writer = self.create_archive_writer(description=description, part_size=part_size) DCNL DCSP if upload_id_callback: DCNL DCSP  DCSP upload_id_callback(writer.upload_id) DCNL DCSP while True: DCNL DCSP  DCSP data = file_obj.read(part_size) DCNL DCSP  DCSP if (not data): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP writer.write(data) DCNL DCSP writer.close() DCNL DCSP return writer.get_archive_id()
def resume_archive_from_file(self, upload_id, filename=None, file_obj=None): DCNL DCSP part_list_response = self.list_all_parts(upload_id) DCNL DCSP part_size = part_list_response['PartSizeInBytes'] DCNL DCSP part_hash_map = {} DCNL DCSP for part_desc in part_list_response['Parts']: DCNL DCSP  DCSP part_index = self._range_string_to_part_index(part_desc['RangeInBytes'], part_size) DCNL DCSP  DCSP part_tree_hash = codecs.decode(part_desc['SHA256TreeHash'], 'hex_codec') DCNL DCSP  DCSP part_hash_map[part_index] = part_tree_hash DCNL DCSP if (not file_obj): DCNL DCSP  DCSP file_obj = open(filename, 'rb') DCNL DCSP return resume_file_upload(self, upload_id, part_size, file_obj, part_hash_map)
def concurrent_create_archive_from_file(self, filename, description, **kwargs): DCNL DCSP uploader = ConcurrentUploader(self.layer1, self.name, **kwargs) DCNL DCSP archive_id = uploader.upload(filename, description) DCNL DCSP return archive_id
def retrieve_archive(self, archive_id, sns_topic=None, description=None): DCNL DCSP job_data = {'Type': 'archive-retrieval', 'ArchiveId': archive_id} DCNL DCSP if (sns_topic is not None): DCNL DCSP  DCSP job_data['SNSTopic'] = sns_topic DCNL DCSP if (description is not None): DCNL DCSP  DCSP job_data['Description'] = description DCNL DCSP response = self.layer1.initiate_job(self.name, job_data) DCNL DCSP return self.get_job(response['JobId'])
def retrieve_inventory(self, sns_topic=None, description=None, byte_range=None, start_date=None, end_date=None, limit=None): DCNL DCSP job_data = {'Type': 'inventory-retrieval'} DCNL DCSP if (sns_topic is not None): DCNL DCSP  DCSP job_data['SNSTopic'] = sns_topic DCNL DCSP if (description is not None): DCNL DCSP  DCSP job_data['Description'] = description DCNL DCSP if (byte_range is not None): DCNL DCSP  DCSP job_data['RetrievalByteRange'] = byte_range DCNL DCSP if ((start_date is not None) or (end_date is not None) or (limit is not None)): DCNL DCSP  DCSP rparams = {} DCNL DCSP  DCSP if (start_date is not None): DCNL DCSP  DCSP  DCSP rparams['StartDate'] = start_date.strftime('%Y-%m-%dT%H:%M:%S%Z') DCNL DCSP  DCSP if (end_date is not None): DCNL DCSP  DCSP  DCSP rparams['EndDate'] = end_date.strftime('%Y-%m-%dT%H:%M:%S%Z') DCNL DCSP  DCSP if (limit is not None): DCNL DCSP  DCSP  DCSP rparams['Limit'] = limit DCNL DCSP  DCSP job_data['InventoryRetrievalParameters'] = rparams DCNL DCSP response = self.layer1.initiate_job(self.name, job_data) DCNL DCSP return response['JobId']
def retrieve_inventory_job(self, **kwargs): DCNL DCSP job_id = self.retrieve_inventory(**kwargs) DCNL DCSP return self.get_job(job_id)
def delete_archive(self, archive_id): DCNL DCSP return self.layer1.delete_archive(self.name, archive_id)
def get_job(self, job_id): DCNL DCSP response_data = self.layer1.describe_job(self.name, job_id) DCNL DCSP return Job(self, response_data)
def list_jobs(self, completed=None, status_code=None): DCNL DCSP response_data = self.layer1.list_jobs(self.name, completed, status_code) DCNL DCSP return [Job(self, jd) for jd in response_data['JobList']]
def list_all_parts(self, upload_id): DCNL DCSP result = self.layer1.list_parts(self.name, upload_id) DCNL DCSP marker = result['Marker'] DCNL DCSP while marker: DCNL DCSP  DCSP additional_result = self.layer1.list_parts(self.name, upload_id, marker=marker) DCNL DCSP  DCSP result['Parts'].extend(additional_result['Parts']) DCNL DCSP  DCSP marker = additional_result['Marker'] DCNL DCSP result['Marker'] = None DCNL DCSP return result
def read(self, amt=None): DCNL DCSP return self.http_response.read(amt)
def get_output(self, byte_range=None, validate_checksum=False): DCNL DCSP response = self.vault.layer1.get_job_output(self.vault.name, self.id, byte_range) DCNL DCSP if (validate_checksum and ('TreeHash' in response)): DCNL DCSP  DCSP data = response.read() DCNL DCSP  DCSP actual_tree_hash = tree_hash_from_str(data) DCNL DCSP  DCSP if (response['TreeHash'] != actual_tree_hash): DCNL DCSP  DCSP  DCSP raise TreeHashDoesNotMatchError(('The DCSP calculated DCSP tree DCSP hash DCSP %s DCSP does DCSP not DCSP match DCSP the DCSP expected DCSP tree DCSP hash DCSP %s DCSP for DCSP the DCSP byte DCSP range DCSP %s' % (actual_tree_hash, response['TreeHash'], byte_range))) DCNL DCSP return response
def download_to_file(self, filename, chunk_size=DefaultPartSize, verify_hashes=True, retry_exceptions=(socket.error,)): DCNL DCSP num_chunks = self._calc_num_chunks(chunk_size) DCNL DCSP with open(filename, 'wb') as output_file: DCNL DCSP  DCSP self._download_to_fileob(output_file, num_chunks, chunk_size, verify_hashes, retry_exceptions)
def download_to_fileobj(self, output_file, chunk_size=DefaultPartSize, verify_hashes=True, retry_exceptions=(socket.error,)): DCNL DCSP num_chunks = self._calc_num_chunks(chunk_size) DCNL DCSP self._download_to_fileob(output_file, num_chunks, chunk_size, verify_hashes, retry_exceptions)
def list_vaults(self, limit=None, marker=None): DCNL DCSP params = {} DCNL DCSP if limit: DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP if marker: DCNL DCSP  DCSP params['marker'] = marker DCNL DCSP return self.make_request('GET', 'vaults', params=params)
def describe_vault(self, vault_name): DCNL DCSP uri = ('vaults/%s' % vault_name) DCNL DCSP return self.make_request('GET', uri)
def create_vault(self, vault_name): DCNL DCSP uri = ('vaults/%s' % vault_name) DCNL DCSP return self.make_request('PUT', uri, ok_responses=(201,), response_headers=[('Location', 'Location')])
def delete_vault(self, vault_name): DCNL DCSP uri = ('vaults/%s' % vault_name) DCNL DCSP return self.make_request('DELETE', uri, ok_responses=(204,))
def get_vault_notifications(self, vault_name): DCNL DCSP uri = ('vaults/%s/notification-configuration' % vault_name) DCNL DCSP return self.make_request('GET', uri)
def set_vault_notifications(self, vault_name, notification_config): DCNL DCSP uri = ('vaults/%s/notification-configuration' % vault_name) DCNL DCSP json_config = json.dumps(notification_config) DCNL DCSP return self.make_request('PUT', uri, data=json_config, ok_responses=(204,))
def delete_vault_notifications(self, vault_name): DCNL DCSP uri = ('vaults/%s/notification-configuration' % vault_name) DCNL DCSP return self.make_request('DELETE', uri, ok_responses=(204,))
def list_jobs(self, vault_name, completed=None, status_code=None, limit=None, marker=None): DCNL DCSP params = {} DCNL DCSP if limit: DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP if marker: DCNL DCSP  DCSP params['marker'] = marker DCNL DCSP if status_code: DCNL DCSP  DCSP params['statuscode'] = status_code DCNL DCSP if (completed is not None): DCNL DCSP  DCSP params['completed'] = ('true' if completed else 'false') DCNL DCSP uri = ('vaults/%s/jobs' % vault_name) DCNL DCSP return self.make_request('GET', uri, params=params)
def describe_job(self, vault_name, job_id): DCNL DCSP uri = ('vaults/%s/jobs/%s' % (vault_name, job_id)) DCNL DCSP return self.make_request('GET', uri, ok_responses=(200,))
def initiate_job(self, vault_name, job_data): DCNL DCSP uri = ('vaults/%s/jobs' % vault_name) DCNL DCSP response_headers = [('x-amz-job-id', u'JobId'), ('Location', u'Location')] DCNL DCSP json_job_data = json.dumps(job_data) DCNL DCSP return self.make_request('POST', uri, data=json_job_data, ok_responses=(202,), response_headers=response_headers)
def get_job_output(self, vault_name, job_id, byte_range=None): DCNL DCSP response_headers = [('x-amz-sha256-tree-hash', u'TreeHash'), ('Content-Range', u'ContentRange'), ('Content-Type', u'ContentType')] DCNL DCSP headers = None DCNL DCSP if byte_range: DCNL DCSP  DCSP headers = {'Range': ('bytes=%d-%d' % byte_range)} DCNL DCSP uri = ('vaults/%s/jobs/%s/output' % (vault_name, job_id)) DCNL DCSP response = self.make_request('GET', uri, headers=headers, ok_responses=(200, 206), response_headers=response_headers) DCNL DCSP return response
def upload_archive(self, vault_name, archive, linear_hash, tree_hash, description=None): DCNL DCSP response_headers = [('x-amz-archive-id', u'ArchiveId'), ('Location', u'Location'), ('x-amz-sha256-tree-hash', u'TreeHash')] DCNL DCSP uri = ('vaults/%s/archives' % vault_name) DCNL DCSP try: DCNL DCSP  DCSP content_length = str(len(archive)) DCNL DCSP except (TypeError, AttributeError): DCNL DCSP  DCSP content_length = str(os.fstat(archive.fileno()).st_size) DCNL DCSP headers = {'x-amz-content-sha256': linear_hash, 'x-amz-sha256-tree-hash': tree_hash, 'Content-Length': content_length} DCNL DCSP if description: DCNL DCSP  DCSP headers['x-amz-archive-description'] = description DCNL DCSP if self._is_file_like(archive): DCNL DCSP  DCSP sender = ResettingFileSender(archive) DCNL DCSP else: DCNL DCSP  DCSP sender = None DCNL DCSP return self.make_request('POST', uri, headers=headers, sender=sender, data=archive, ok_responses=(201,), response_headers=response_headers)
def delete_archive(self, vault_name, archive_id): DCNL DCSP uri = ('vaults/%s/archives/%s' % (vault_name, archive_id)) DCNL DCSP return self.make_request('DELETE', uri, ok_responses=(204,))
def initiate_multipart_upload(self, vault_name, part_size, description=None): DCNL DCSP response_headers = [('x-amz-multipart-upload-id', u'UploadId'), ('Location', u'Location')] DCNL DCSP headers = {'x-amz-part-size': str(part_size)} DCNL DCSP if description: DCNL DCSP  DCSP headers['x-amz-archive-description'] = description DCNL DCSP uri = ('vaults/%s/multipart-uploads' % vault_name) DCNL DCSP response = self.make_request('POST', uri, headers=headers, ok_responses=(201,), response_headers=response_headers) DCNL DCSP return response
def complete_multipart_upload(self, vault_name, upload_id, sha256_treehash, archive_size): DCNL DCSP response_headers = [('x-amz-archive-id', u'ArchiveId'), ('Location', u'Location')] DCNL DCSP headers = {'x-amz-sha256-tree-hash': sha256_treehash, 'x-amz-archive-size': str(archive_size)} DCNL DCSP uri = ('vaults/%s/multipart-uploads/%s' % (vault_name, upload_id)) DCNL DCSP response = self.make_request('POST', uri, headers=headers, ok_responses=(201,), response_headers=response_headers) DCNL DCSP return response
def abort_multipart_upload(self, vault_name, upload_id): DCNL DCSP uri = ('vaults/%s/multipart-uploads/%s' % (vault_name, upload_id)) DCNL DCSP return self.make_request('DELETE', uri, ok_responses=(204,))
def list_multipart_uploads(self, vault_name, limit=None, marker=None): DCNL DCSP params = {} DCNL DCSP if limit: DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP if marker: DCNL DCSP  DCSP params['marker'] = marker DCNL DCSP uri = ('vaults/%s/multipart-uploads' % vault_name) DCNL DCSP return self.make_request('GET', uri, params=params)
def list_parts(self, vault_name, upload_id, limit=None, marker=None): DCNL DCSP params = {} DCNL DCSP if limit: DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP if marker: DCNL DCSP  DCSP params['marker'] = marker DCNL DCSP uri = ('vaults/%s/multipart-uploads/%s' % (vault_name, upload_id)) DCNL DCSP return self.make_request('GET', uri, params=params)
def upload_part(self, vault_name, upload_id, linear_hash, tree_hash, byte_range, part_data): DCNL DCSP headers = {'x-amz-content-sha256': linear_hash, 'x-amz-sha256-tree-hash': tree_hash, 'Content-Range': ('bytes DCSP %d-%d/*' % byte_range)} DCNL DCSP response_headers = [('x-amz-sha256-tree-hash', u'TreeHash')] DCNL DCSP uri = ('vaults/%s/multipart-uploads/%s' % (str(vault_name), upload_id)) DCNL DCSP return self.make_request('PUT', uri, headers=headers, data=part_data, ok_responses=(204,), response_headers=response_headers)
def __init__(self, api, vault_name, part_size=DEFAULT_PART_SIZE, num_threads=10): DCNL DCSP super(ConcurrentUploader, self).__init__(part_size, num_threads) DCNL DCSP self._api = api DCNL DCSP self._vault_name = vault_name
def upload(self, filename, description=None): DCNL DCSP total_size = os.stat(filename).st_size DCNL DCSP (total_parts, part_size) = self._calculate_required_part_size(total_size) DCNL DCSP hash_chunks = ([None] * total_parts) DCNL DCSP worker_queue = Queue() DCNL DCSP result_queue = Queue() DCNL DCSP response = self._api.initiate_multipart_upload(self._vault_name, part_size, description) DCNL DCSP upload_id = response['UploadId'] DCNL DCSP self._add_work_items_to_queue(total_parts, worker_queue, part_size) DCNL DCSP self._start_upload_threads(result_queue, upload_id, worker_queue, filename) DCNL DCSP try: DCNL DCSP  DCSP self._wait_for_upload_threads(hash_chunks, result_queue, total_parts) DCNL DCSP except UploadArchiveError as e: DCNL DCSP  DCSP log.debug('An DCSP error DCSP occurred DCSP while DCSP uploading DCSP an DCSP archive, DCSP aborting DCSP multipart DCSP upload.') DCNL DCSP  DCSP self._api.abort_multipart_upload(self._vault_name, upload_id) DCNL DCSP  DCSP raise e DCNL DCSP log.debug('Completing DCSP upload.') DCNL DCSP response = self._api.complete_multipart_upload(self._vault_name, upload_id, bytes_to_hex(tree_hash(hash_chunks)), total_size) DCNL DCSP log.debug('Upload DCSP finished.') DCNL DCSP return response['ArchiveId']
def __init__(self, job, part_size=DEFAULT_PART_SIZE, num_threads=10): DCNL DCSP super(ConcurrentDownloader, self).__init__(part_size, num_threads) DCNL DCSP self._job = job
def download(self, filename): DCNL DCSP total_size = self._job.archive_size DCNL DCSP (total_parts, part_size) = self._calculate_required_part_size(total_size) DCNL DCSP worker_queue = Queue() DCNL DCSP result_queue = Queue() DCNL DCSP self._add_work_items_to_queue(total_parts, worker_queue, part_size) DCNL DCSP self._start_download_threads(result_queue, worker_queue) DCNL DCSP try: DCNL DCSP  DCSP self._wait_for_download_threads(filename, result_queue, total_parts) DCNL DCSP except DownloadArchiveError as e: DCNL DCSP  DCSP log.debug('An DCSP error DCSP occurred DCSP while DCSP downloading DCSP an DCSP archive: DCSP %s', e) DCNL DCSP  DCSP raise e DCNL DCSP log.debug('Download DCSP completed.')
def _wait_for_download_threads(self, filename, result_queue, total_parts): DCNL DCSP hash_chunks = ([None] * total_parts) DCNL DCSP with open(filename, 'wb') as f: DCNL DCSP  DCSP for _ in range(total_parts): DCNL DCSP  DCSP  DCSP result = result_queue.get() DCNL DCSP  DCSP  DCSP if isinstance(result, Exception): DCNL DCSP  DCSP  DCSP  DCSP log.debug('An DCSP error DCSP was DCSP found DCSP in DCSP the DCSP result DCSP queue, DCSP terminating DCSP threads: DCSP %s', result) DCNL DCSP  DCSP  DCSP  DCSP self._shutdown_threads() DCNL DCSP  DCSP  DCSP  DCSP raise DownloadArchiveError(('An DCSP error DCSP occurred DCSP while DCSP uploading DCSP an DCSP archive: DCSP %s' % result)) DCNL DCSP  DCSP  DCSP (part_number, part_size, actual_hash, data) = result DCNL DCSP  DCSP  DCSP hash_chunks[part_number] = actual_hash DCNL DCSP  DCSP  DCSP start_byte = (part_number * part_size) DCNL DCSP  DCSP  DCSP f.seek(start_byte) DCNL DCSP  DCSP  DCSP f.write(data) DCNL DCSP  DCSP  DCSP f.flush() DCNL DCSP final_hash = bytes_to_hex(tree_hash(hash_chunks)) DCNL DCSP log.debug('Verifying DCSP final DCSP tree DCSP hash DCSP of DCSP archive, DCSP expecting: DCSP %s, DCSP actual: DCSP %s', self._job.sha256_treehash, final_hash) DCNL DCSP if (self._job.sha256_treehash != final_hash): DCNL DCSP  DCSP self._shutdown_threads() DCNL DCSP  DCSP raise TreeHashDoesNotMatchError(('Tree DCSP hash DCSP for DCSP entire DCSP archive DCSP does DCSP not DCSP match, DCSP expected: DCSP %s, DCSP got: DCSP %s' % (self._job.sha256_treehash, final_hash))) DCNL DCSP self._shutdown_threads()
def __init__(self, job, worker_queue, result_queue, num_retries=5, time_between_retries=5, retry_exceptions=Exception): DCNL DCSP super(DownloadWorkerThread, self).__init__(worker_queue, result_queue) DCNL DCSP self._job = job DCNL DCSP self._num_retries = num_retries DCNL DCSP self._time_between_retries = time_between_retries DCNL DCSP self._retry_exceptions = retry_exceptions
def _process_chunk(self, work): DCNL DCSP result = None DCNL DCSP for _ in range(self._num_retries): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = self._download_chunk(work) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP except self._retry_exceptions as e: DCNL DCSP  DCSP  DCSP log.error('Exception DCSP caught DCSP downloading DCSP part DCSP number DCSP %s DCSP for DCSP job DCSP %s', work[0], self._job) DCNL DCSP  DCSP  DCSP time.sleep(self._time_between_retries) DCNL DCSP  DCSP  DCSP result = e DCNL DCSP return result
def _download_chunk(self, work): DCNL DCSP (part_number, part_size) = work DCNL DCSP start_byte = (part_number * part_size) DCNL DCSP byte_range = (start_byte, ((start_byte + part_size) - 1)) DCNL DCSP log.debug('Downloading DCSP chunk DCSP %s DCSP of DCSP size DCSP %s', part_number, part_size) DCNL DCSP response = self._job.get_output(byte_range) DCNL DCSP data = response.read() DCNL DCSP actual_hash = bytes_to_hex(tree_hash(chunk_hashes(data))) DCNL DCSP if (response['TreeHash'] != actual_hash): DCNL DCSP  DCSP raise TreeHashDoesNotMatchError(('Tree DCSP hash DCSP for DCSP part DCSP number DCSP %s DCSP does DCSP not DCSP match, DCSP expected: DCSP %s, DCSP got: DCSP %s' % (part_number, response['TreeHash'], actual_hash))) DCNL DCSP return (part_number, part_size, binascii.unhexlify(actual_hash), data)
def create_vault(self, name): DCNL DCSP self.layer1.create_vault(name) DCNL DCSP return self.get_vault(name)
def delete_vault(self, name): DCNL DCSP return self.layer1.delete_vault(name)
def get_vault(self, name): DCNL DCSP response_data = self.layer1.describe_vault(name) DCNL DCSP return Vault(self.layer1, response_data)
def list_vaults(self): DCNL DCSP vaults = [] DCNL DCSP marker = None DCNL DCSP while True: DCNL DCSP  DCSP response_data = self.layer1.list_vaults(marker=marker, limit=1000) DCNL DCSP  DCSP vaults.extend([Vault(self.layer1, rd) for rd in response_data['VaultList']]) DCNL DCSP  DCSP marker = response_data.get('Marker') DCNL DCSP  DCSP if (not marker): DCNL DCSP  DCSP  DCSP break DCNL DCSP return vaults
def upload_part(self, part_index, part_data): DCNL DCSP if self.closed: DCNL DCSP  DCSP raise ValueError('I/O DCSP operation DCSP on DCSP closed DCSP file') DCNL DCSP part_tree_hash = tree_hash(chunk_hashes(part_data, self.chunk_size)) DCNL DCSP self._insert_tree_hash(part_index, part_tree_hash) DCNL DCSP hex_tree_hash = bytes_to_hex(part_tree_hash) DCNL DCSP linear_hash = hashlib.sha256(part_data).hexdigest() DCNL DCSP start = (self.part_size * part_index) DCNL DCSP content_range = (start, ((start + len(part_data)) - 1)) DCNL DCSP response = self.vault.layer1.upload_part(self.vault.name, self.upload_id, linear_hash, hex_tree_hash, content_range, part_data) DCNL DCSP response.read() DCNL DCSP self._uploaded_size += len(part_data)
def skip_part(self, part_index, part_tree_hash, part_length): DCNL DCSP if self.closed: DCNL DCSP  DCSP raise ValueError('I/O DCSP operation DCSP on DCSP closed DCSP file') DCNL DCSP self._insert_tree_hash(part_index, part_tree_hash) DCNL DCSP self._uploaded_size += part_length
@property DCNL def current_tree_hash(self): DCNL DCSP return tree_hash(self.uploader._tree_hashes)
@property DCNL def current_uploaded_size(self): DCNL DCSP return self.uploader._uploaded_size
def activate_pipeline(self, pipeline_id): DCNL DCSP params = {'pipelineId': pipeline_id} DCNL DCSP return self.make_request(action='ActivatePipeline', body=json.dumps(params))
def create_pipeline(self, name, unique_id, description=None): DCNL DCSP params = {'name': name, 'uniqueId': unique_id} DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['description'] = description DCNL DCSP return self.make_request(action='CreatePipeline', body=json.dumps(params))
def delete_pipeline(self, pipeline_id): DCNL DCSP params = {'pipelineId': pipeline_id} DCNL DCSP return self.make_request(action='DeletePipeline', body=json.dumps(params))
def describe_objects(self, object_ids, pipeline_id, marker=None, evaluate_expressions=None): DCNL DCSP params = {'pipelineId': pipeline_id, 'objectIds': object_ids} DCNL DCSP if (evaluate_expressions is not None): DCNL DCSP  DCSP params['evaluateExpressions'] = evaluate_expressions DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['marker'] = marker DCNL DCSP return self.make_request(action='DescribeObjects', body=json.dumps(params))
def describe_pipelines(self, pipeline_ids): DCNL DCSP params = {'pipelineIds': pipeline_ids} DCNL DCSP return self.make_request(action='DescribePipelines', body=json.dumps(params))
def evaluate_expression(self, pipeline_id, expression, object_id): DCNL DCSP params = {'pipelineId': pipeline_id, 'objectId': object_id, 'expression': expression} DCNL DCSP return self.make_request(action='EvaluateExpression', body=json.dumps(params))
def get_pipeline_definition(self, pipeline_id, version=None): DCNL DCSP params = {'pipelineId': pipeline_id} DCNL DCSP if (version is not None): DCNL DCSP  DCSP params['version'] = version DCNL DCSP return self.make_request(action='GetPipelineDefinition', body=json.dumps(params))
def list_pipelines(self, marker=None): DCNL DCSP params = {} DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['marker'] = marker DCNL DCSP return self.make_request(action='ListPipelines', body=json.dumps(params))
def poll_for_task(self, worker_group, hostname=None, instance_identity=None): DCNL DCSP params = {'workerGroup': worker_group} DCNL DCSP if (hostname is not None): DCNL DCSP  DCSP params['hostname'] = hostname DCNL DCSP if (instance_identity is not None): DCNL DCSP  DCSP params['instanceIdentity'] = instance_identity DCNL DCSP return self.make_request(action='PollForTask', body=json.dumps(params))
def put_pipeline_definition(self, pipeline_objects, pipeline_id): DCNL DCSP params = {'pipelineId': pipeline_id, 'pipelineObjects': pipeline_objects} DCNL DCSP return self.make_request(action='PutPipelineDefinition', body=json.dumps(params))
def query_objects(self, pipeline_id, sphere, marker=None, query=None, limit=None): DCNL DCSP params = {'pipelineId': pipeline_id, 'sphere': sphere} DCNL DCSP if (query is not None): DCNL DCSP  DCSP params['query'] = query DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['marker'] = marker DCNL DCSP if (limit is not None): DCNL DCSP  DCSP params['limit'] = limit DCNL DCSP return self.make_request(action='QueryObjects', body=json.dumps(params))
def report_task_progress(self, task_id): DCNL DCSP params = {'taskId': task_id} DCNL DCSP return self.make_request(action='ReportTaskProgress', body=json.dumps(params))
def report_task_runner_heartbeat(self, taskrunner_id, worker_group=None, hostname=None): DCNL DCSP params = {'taskrunnerId': taskrunner_id} DCNL DCSP if (worker_group is not None): DCNL DCSP  DCSP params['workerGroup'] = worker_group DCNL DCSP if (hostname is not None): DCNL DCSP  DCSP params['hostname'] = hostname DCNL DCSP return self.make_request(action='ReportTaskRunnerHeartbeat', body=json.dumps(params))
def set_status(self, object_ids, status, pipeline_id): DCNL DCSP params = {'pipelineId': pipeline_id, 'objectIds': object_ids, 'status': status} DCNL DCSP return self.make_request(action='SetStatus', body=json.dumps(params))
def set_task_status(self, task_id, task_status, error_id=None, error_message=None, error_stack_trace=None): DCNL DCSP params = {'taskId': task_id, 'taskStatus': task_status} DCNL DCSP if (error_id is not None): DCNL DCSP  DCSP params['errorId'] = error_id DCNL DCSP if (error_message is not None): DCNL DCSP  DCSP params['errorMessage'] = error_message DCNL DCSP if (error_stack_trace is not None): DCNL DCSP  DCSP params['errorStackTrace'] = error_stack_trace DCNL DCSP return self.make_request(action='SetTaskStatus', body=json.dumps(params))
def validate_pipeline_definition(self, pipeline_objects, pipeline_id): DCNL DCSP params = {'pipelineId': pipeline_id, 'pipelineObjects': pipeline_objects} DCNL DCSP return self.make_request(action='ValidatePipelineDefinition', body=json.dumps(params))
def batch_get_applications(self, application_names=None): DCNL DCSP params = {} DCNL DCSP if (application_names is not None): DCNL DCSP  DCSP params['applicationNames'] = application_names DCNL DCSP return self.make_request(action='BatchGetApplications', body=json.dumps(params))
def batch_get_deployments(self, deployment_ids=None): DCNL DCSP params = {} DCNL DCSP if (deployment_ids is not None): DCNL DCSP  DCSP params['deploymentIds'] = deployment_ids DCNL DCSP return self.make_request(action='BatchGetDeployments', body=json.dumps(params))
def create_application(self, application_name): DCNL DCSP params = {'applicationName': application_name} DCNL DCSP return self.make_request(action='CreateApplication', body=json.dumps(params))
def create_deployment(self, application_name, deployment_group_name=None, revision=None, deployment_config_name=None, description=None, ignore_application_stop_failures=None): DCNL DCSP params = {'applicationName': application_name} DCNL DCSP if (deployment_group_name is not None): DCNL DCSP  DCSP params['deploymentGroupName'] = deployment_group_name DCNL DCSP if (revision is not None): DCNL DCSP  DCSP params['revision'] = revision DCNL DCSP if (deployment_config_name is not None): DCNL DCSP  DCSP params['deploymentConfigName'] = deployment_config_name DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['description'] = description DCNL DCSP if (ignore_application_stop_failures is not None): DCNL DCSP  DCSP params['ignoreApplicationStopFailures'] = ignore_application_stop_failures DCNL DCSP return self.make_request(action='CreateDeployment', body=json.dumps(params))
def create_deployment_config(self, deployment_config_name, minimum_healthy_hosts=None): DCNL DCSP params = {'deploymentConfigName': deployment_config_name} DCNL DCSP if (minimum_healthy_hosts is not None): DCNL DCSP  DCSP params['minimumHealthyHosts'] = minimum_healthy_hosts DCNL DCSP return self.make_request(action='CreateDeploymentConfig', body=json.dumps(params))
def create_deployment_group(self, application_name, deployment_group_name, deployment_config_name=None, ec_2_tag_filters=None, auto_scaling_groups=None, service_role_arn=None): DCNL DCSP params = {'applicationName': application_name, 'deploymentGroupName': deployment_group_name} DCNL DCSP if (deployment_config_name is not None): DCNL DCSP  DCSP params['deploymentConfigName'] = deployment_config_name DCNL DCSP if (ec_2_tag_filters is not None): DCNL DCSP  DCSP params['ec2TagFilters'] = ec_2_tag_filters DCNL DCSP if (auto_scaling_groups is not None): DCNL DCSP  DCSP params['autoScalingGroups'] = auto_scaling_groups DCNL DCSP if (service_role_arn is not None): DCNL DCSP  DCSP params['serviceRoleArn'] = service_role_arn DCNL DCSP return self.make_request(action='CreateDeploymentGroup', body=json.dumps(params))
def delete_application(self, application_name): DCNL DCSP params = {'applicationName': application_name} DCNL DCSP return self.make_request(action='DeleteApplication', body=json.dumps(params))
def delete_deployment_config(self, deployment_config_name): DCNL DCSP params = {'deploymentConfigName': deployment_config_name} DCNL DCSP return self.make_request(action='DeleteDeploymentConfig', body=json.dumps(params))
def delete_deployment_group(self, application_name, deployment_group_name): DCNL DCSP params = {'applicationName': application_name, 'deploymentGroupName': deployment_group_name} DCNL DCSP return self.make_request(action='DeleteDeploymentGroup', body=json.dumps(params))
def get_application(self, application_name): DCNL DCSP params = {'applicationName': application_name} DCNL DCSP return self.make_request(action='GetApplication', body=json.dumps(params))
def get_application_revision(self, application_name, revision): DCNL DCSP params = {'applicationName': application_name, 'revision': revision} DCNL DCSP return self.make_request(action='GetApplicationRevision', body=json.dumps(params))
def get_deployment(self, deployment_id): DCNL DCSP params = {'deploymentId': deployment_id} DCNL DCSP return self.make_request(action='GetDeployment', body=json.dumps(params))
def get_deployment_config(self, deployment_config_name): DCNL DCSP params = {'deploymentConfigName': deployment_config_name} DCNL DCSP return self.make_request(action='GetDeploymentConfig', body=json.dumps(params))
def get_deployment_group(self, application_name, deployment_group_name): DCNL DCSP params = {'applicationName': application_name, 'deploymentGroupName': deployment_group_name} DCNL DCSP return self.make_request(action='GetDeploymentGroup', body=json.dumps(params))
def get_deployment_instance(self, deployment_id, instance_id): DCNL DCSP params = {'deploymentId': deployment_id, 'instanceId': instance_id} DCNL DCSP return self.make_request(action='GetDeploymentInstance', body=json.dumps(params))
def list_application_revisions(self, application_name, sort_by=None, sort_order=None, s_3_bucket=None, s_3_key_prefix=None, deployed=None, next_token=None): DCNL DCSP params = {'applicationName': application_name} DCNL DCSP if (sort_by is not None): DCNL DCSP  DCSP params['sortBy'] = sort_by DCNL DCSP if (sort_order is not None): DCNL DCSP  DCSP params['sortOrder'] = sort_order DCNL DCSP if (s_3_bucket is not None): DCNL DCSP  DCSP params['s3Bucket'] = s_3_bucket DCNL DCSP if (s_3_key_prefix is not None): DCNL DCSP  DCSP params['s3KeyPrefix'] = s_3_key_prefix DCNL DCSP if (deployed is not None): DCNL DCSP  DCSP params['deployed'] = deployed DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP return self.make_request(action='ListApplicationRevisions', body=json.dumps(params))
def list_applications(self, next_token=None): DCNL DCSP params = {} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP return self.make_request(action='ListApplications', body=json.dumps(params))
def list_deployment_configs(self, next_token=None): DCNL DCSP params = {} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP return self.make_request(action='ListDeploymentConfigs', body=json.dumps(params))
def list_deployment_groups(self, application_name, next_token=None): DCNL DCSP params = {'applicationName': application_name} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP return self.make_request(action='ListDeploymentGroups', body=json.dumps(params))
def list_deployment_instances(self, deployment_id, next_token=None, instance_status_filter=None): DCNL DCSP params = {'deploymentId': deployment_id} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (instance_status_filter is not None): DCNL DCSP  DCSP params['instanceStatusFilter'] = instance_status_filter DCNL DCSP return self.make_request(action='ListDeploymentInstances', body=json.dumps(params))
def list_deployments(self, application_name=None, deployment_group_name=None, include_only_statuses=None, create_time_range=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if (application_name is not None): DCNL DCSP  DCSP params['applicationName'] = application_name DCNL DCSP if (deployment_group_name is not None): DCNL DCSP  DCSP params['deploymentGroupName'] = deployment_group_name DCNL DCSP if (include_only_statuses is not None): DCNL DCSP  DCSP params['includeOnlyStatuses'] = include_only_statuses DCNL DCSP if (create_time_range is not None): DCNL DCSP  DCSP params['createTimeRange'] = create_time_range DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP return self.make_request(action='ListDeployments', body=json.dumps(params))
def register_application_revision(self, application_name, revision, description=None): DCNL DCSP params = {'applicationName': application_name, 'revision': revision} DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['description'] = description DCNL DCSP return self.make_request(action='RegisterApplicationRevision', body=json.dumps(params))
def stop_deployment(self, deployment_id): DCNL DCSP params = {'deploymentId': deployment_id} DCNL DCSP return self.make_request(action='StopDeployment', body=json.dumps(params))
def update_application(self, application_name=None, new_application_name=None): DCNL DCSP params = {} DCNL DCSP if (application_name is not None): DCNL DCSP  DCSP params['applicationName'] = application_name DCNL DCSP if (new_application_name is not None): DCNL DCSP  DCSP params['newApplicationName'] = new_application_name DCNL DCSP return self.make_request(action='UpdateApplication', body=json.dumps(params))
def update_deployment_group(self, application_name, current_deployment_group_name, new_deployment_group_name=None, deployment_config_name=None, ec_2_tag_filters=None, auto_scaling_groups=None, service_role_arn=None): DCNL DCSP params = {'applicationName': application_name, 'currentDeploymentGroupName': current_deployment_group_name} DCNL DCSP if (new_deployment_group_name is not None): DCNL DCSP  DCSP params['newDeploymentGroupName'] = new_deployment_group_name DCNL DCSP if (deployment_config_name is not None): DCNL DCSP  DCSP params['deploymentConfigName'] = deployment_config_name DCNL DCSP if (ec_2_tag_filters is not None): DCNL DCSP  DCSP params['ec2TagFilters'] = ec_2_tag_filters DCNL DCSP if (auto_scaling_groups is not None): DCNL DCSP  DCSP params['autoScalingGroups'] = auto_scaling_groups DCNL DCSP if (service_role_arn is not None): DCNL DCSP  DCSP params['serviceRoleArn'] = service_role_arn DCNL DCSP return self.make_request(action='UpdateDeploymentGroup', body=json.dumps(params))
def add_attachments_to_set(self, attachments, attachment_set_id=None): DCNL DCSP params = {'attachments': attachments} DCNL DCSP if (attachment_set_id is not None): DCNL DCSP  DCSP params['attachmentSetId'] = attachment_set_id DCNL DCSP return self.make_request(action='AddAttachmentsToSet', body=json.dumps(params))
def add_communication_to_case(self, communication_body, case_id=None, cc_email_addresses=None, attachment_set_id=None): DCNL DCSP params = {'communicationBody': communication_body} DCNL DCSP if (case_id is not None): DCNL DCSP  DCSP params['caseId'] = case_id DCNL DCSP if (cc_email_addresses is not None): DCNL DCSP  DCSP params['ccEmailAddresses'] = cc_email_addresses DCNL DCSP if (attachment_set_id is not None): DCNL DCSP  DCSP params['attachmentSetId'] = attachment_set_id DCNL DCSP return self.make_request(action='AddCommunicationToCase', body=json.dumps(params))
def create_case(self, subject, communication_body, service_code=None, severity_code=None, category_code=None, cc_email_addresses=None, language=None, issue_type=None, attachment_set_id=None): DCNL DCSP params = {'subject': subject, 'communicationBody': communication_body} DCNL DCSP if (service_code is not None): DCNL DCSP  DCSP params['serviceCode'] = service_code DCNL DCSP if (severity_code is not None): DCNL DCSP  DCSP params['severityCode'] = severity_code DCNL DCSP if (category_code is not None): DCNL DCSP  DCSP params['categoryCode'] = category_code DCNL DCSP if (cc_email_addresses is not None): DCNL DCSP  DCSP params['ccEmailAddresses'] = cc_email_addresses DCNL DCSP if (language is not None): DCNL DCSP  DCSP params['language'] = language DCNL DCSP if (issue_type is not None): DCNL DCSP  DCSP params['issueType'] = issue_type DCNL DCSP if (attachment_set_id is not None): DCNL DCSP  DCSP params['attachmentSetId'] = attachment_set_id DCNL DCSP return self.make_request(action='CreateCase', body=json.dumps(params))
def describe_attachment(self, attachment_id): DCNL DCSP params = {'attachmentId': attachment_id} DCNL DCSP return self.make_request(action='DescribeAttachment', body=json.dumps(params))
def describe_cases(self, case_id_list=None, display_id=None, after_time=None, before_time=None, include_resolved_cases=None, next_token=None, max_results=None, language=None, include_communications=None): DCNL DCSP params = {} DCNL DCSP if (case_id_list is not None): DCNL DCSP  DCSP params['caseIdList'] = case_id_list DCNL DCSP if (display_id is not None): DCNL DCSP  DCSP params['displayId'] = display_id DCNL DCSP if (after_time is not None): DCNL DCSP  DCSP params['afterTime'] = after_time DCNL DCSP if (before_time is not None): DCNL DCSP  DCSP params['beforeTime'] = before_time DCNL DCSP if (include_resolved_cases is not None): DCNL DCSP  DCSP params['includeResolvedCases'] = include_resolved_cases DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['maxResults'] = max_results DCNL DCSP if (language is not None): DCNL DCSP  DCSP params['language'] = language DCNL DCSP if (include_communications is not None): DCNL DCSP  DCSP params['includeCommunications'] = include_communications DCNL DCSP return self.make_request(action='DescribeCases', body=json.dumps(params))
def describe_communications(self, case_id, before_time=None, after_time=None, next_token=None, max_results=None): DCNL DCSP params = {'caseId': case_id} DCNL DCSP if (before_time is not None): DCNL DCSP  DCSP params['beforeTime'] = before_time DCNL DCSP if (after_time is not None): DCNL DCSP  DCSP params['afterTime'] = after_time DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['nextToken'] = next_token DCNL DCSP if (max_results is not None): DCNL DCSP  DCSP params['maxResults'] = max_results DCNL DCSP return self.make_request(action='DescribeCommunications', body=json.dumps(params))
def describe_services(self, service_code_list=None, language=None): DCNL DCSP params = {} DCNL DCSP if (service_code_list is not None): DCNL DCSP  DCSP params['serviceCodeList'] = service_code_list DCNL DCSP if (language is not None): DCNL DCSP  DCSP params['language'] = language DCNL DCSP return self.make_request(action='DescribeServices', body=json.dumps(params))
def describe_severity_levels(self, language=None): DCNL DCSP params = {} DCNL DCSP if (language is not None): DCNL DCSP  DCSP params['language'] = language DCNL DCSP return self.make_request(action='DescribeSeverityLevels', body=json.dumps(params))
def describe_trusted_advisor_check_refresh_statuses(self, check_ids): DCNL DCSP params = {'checkIds': check_ids} DCNL DCSP return self.make_request(action='DescribeTrustedAdvisorCheckRefreshStatuses', body=json.dumps(params))
def describe_trusted_advisor_check_result(self, check_id, language=None): DCNL DCSP params = {'checkId': check_id} DCNL DCSP if (language is not None): DCNL DCSP  DCSP params['language'] = language DCNL DCSP return self.make_request(action='DescribeTrustedAdvisorCheckResult', body=json.dumps(params))
def describe_trusted_advisor_check_summaries(self, check_ids): DCNL DCSP params = {'checkIds': check_ids} DCNL DCSP return self.make_request(action='DescribeTrustedAdvisorCheckSummaries', body=json.dumps(params))
def describe_trusted_advisor_checks(self, language): DCNL DCSP params = {'language': language} DCNL DCSP return self.make_request(action='DescribeTrustedAdvisorChecks', body=json.dumps(params))
def refresh_trusted_advisor_check(self, check_id): DCNL DCSP params = {'checkId': check_id} DCNL DCSP return self.make_request(action='RefreshTrustedAdvisorCheck', body=json.dumps(params))
def resolve_case(self, case_id=None): DCNL DCSP params = {} DCNL DCSP if (case_id is not None): DCNL DCSP  DCSP params['caseId'] = case_id DCNL DCSP return self.make_request(action='ResolveCase', body=json.dumps(params))
def cancel_job(self, id=None): DCNL DCSP uri = '/2012-09-25/jobs/{0}'.format(id) DCNL DCSP return self.make_request('DELETE', uri, expected_status=202)
def create_job(self, pipeline_id=None, input_name=None, output=None, outputs=None, output_key_prefix=None, playlists=None): DCNL DCSP uri = '/2012-09-25/jobs' DCNL DCSP params = {} DCNL DCSP if (pipeline_id is not None): DCNL DCSP  DCSP params['PipelineId'] = pipeline_id DCNL DCSP if (input_name is not None): DCNL DCSP  DCSP params['Input'] = input_name DCNL DCSP if (output is not None): DCNL DCSP  DCSP params['Output'] = output DCNL DCSP if (outputs is not None): DCNL DCSP  DCSP params['Outputs'] = outputs DCNL DCSP if (output_key_prefix is not None): DCNL DCSP  DCSP params['OutputKeyPrefix'] = output_key_prefix DCNL DCSP if (playlists is not None): DCNL DCSP  DCSP params['Playlists'] = playlists DCNL DCSP return self.make_request('POST', uri, expected_status=201, data=json.dumps(params))
def create_pipeline(self, name=None, input_bucket=None, output_bucket=None, role=None, notifications=None, content_config=None, thumbnail_config=None): DCNL DCSP uri = '/2012-09-25/pipelines' DCNL DCSP params = {} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (input_bucket is not None): DCNL DCSP  DCSP params['InputBucket'] = input_bucket DCNL DCSP if (output_bucket is not None): DCNL DCSP  DCSP params['OutputBucket'] = output_bucket DCNL DCSP if (role is not None): DCNL DCSP  DCSP params['Role'] = role DCNL DCSP if (notifications is not None): DCNL DCSP  DCSP params['Notifications'] = notifications DCNL DCSP if (content_config is not None): DCNL DCSP  DCSP params['ContentConfig'] = content_config DCNL DCSP if (thumbnail_config is not None): DCNL DCSP  DCSP params['ThumbnailConfig'] = thumbnail_config DCNL DCSP return self.make_request('POST', uri, expected_status=201, data=json.dumps(params))
def create_preset(self, name=None, description=None, container=None, video=None, audio=None, thumbnails=None): DCNL DCSP uri = '/2012-09-25/presets' DCNL DCSP params = {} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (description is not None): DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if (container is not None): DCNL DCSP  DCSP params['Container'] = container DCNL DCSP if (video is not None): DCNL DCSP  DCSP params['Video'] = video DCNL DCSP if (audio is not None): DCNL DCSP  DCSP params['Audio'] = audio DCNL DCSP if (thumbnails is not None): DCNL DCSP  DCSP params['Thumbnails'] = thumbnails DCNL DCSP return self.make_request('POST', uri, expected_status=201, data=json.dumps(params))
def delete_pipeline(self, id=None): DCNL DCSP uri = '/2012-09-25/pipelines/{0}'.format(id) DCNL DCSP return self.make_request('DELETE', uri, expected_status=202)
def delete_preset(self, id=None): DCNL DCSP uri = '/2012-09-25/presets/{0}'.format(id) DCNL DCSP return self.make_request('DELETE', uri, expected_status=202)
def list_jobs_by_pipeline(self, pipeline_id=None, ascending=None, page_token=None): DCNL DCSP uri = '/2012-09-25/jobsByPipeline/{0}'.format(pipeline_id) DCNL DCSP params = {} DCNL DCSP if (pipeline_id is not None): DCNL DCSP  DCSP params['PipelineId'] = pipeline_id DCNL DCSP if (ascending is not None): DCNL DCSP  DCSP params['Ascending'] = ascending DCNL DCSP if (page_token is not None): DCNL DCSP  DCSP params['PageToken'] = page_token DCNL DCSP return self.make_request('GET', uri, expected_status=200, params=params)
def list_jobs_by_status(self, status=None, ascending=None, page_token=None): DCNL DCSP uri = '/2012-09-25/jobsByStatus/{0}'.format(status) DCNL DCSP params = {} DCNL DCSP if (status is not None): DCNL DCSP  DCSP params['Status'] = status DCNL DCSP if (ascending is not None): DCNL DCSP  DCSP params['Ascending'] = ascending DCNL DCSP if (page_token is not None): DCNL DCSP  DCSP params['PageToken'] = page_token DCNL DCSP return self.make_request('GET', uri, expected_status=200, params=params)
def list_pipelines(self, ascending=None, page_token=None): DCNL DCSP uri = '/2012-09-25/pipelines'.format() DCNL DCSP params = {} DCNL DCSP if (ascending is not None): DCNL DCSP  DCSP params['Ascending'] = ascending DCNL DCSP if (page_token is not None): DCNL DCSP  DCSP params['PageToken'] = page_token DCNL DCSP return self.make_request('GET', uri, expected_status=200, params=params)
def list_presets(self, ascending=None, page_token=None): DCNL DCSP uri = '/2012-09-25/presets'.format() DCNL DCSP params = {} DCNL DCSP if (ascending is not None): DCNL DCSP  DCSP params['Ascending'] = ascending DCNL DCSP if (page_token is not None): DCNL DCSP  DCSP params['PageToken'] = page_token DCNL DCSP return self.make_request('GET', uri, expected_status=200, params=params)
def read_job(self, id=None): DCNL DCSP uri = '/2012-09-25/jobs/{0}'.format(id) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def read_pipeline(self, id=None): DCNL DCSP uri = '/2012-09-25/pipelines/{0}'.format(id) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def read_preset(self, id=None): DCNL DCSP uri = '/2012-09-25/presets/{0}'.format(id) DCNL DCSP return self.make_request('GET', uri, expected_status=200)
def test_role(self, role=None, input_bucket=None, output_bucket=None, topics=None): DCNL DCSP uri = '/2012-09-25/roleTests' DCNL DCSP params = {} DCNL DCSP if (role is not None): DCNL DCSP  DCSP params['Role'] = role DCNL DCSP if (input_bucket is not None): DCNL DCSP  DCSP params['InputBucket'] = input_bucket DCNL DCSP if (output_bucket is not None): DCNL DCSP  DCSP params['OutputBucket'] = output_bucket DCNL DCSP if (topics is not None): DCNL DCSP  DCSP params['Topics'] = topics DCNL DCSP return self.make_request('POST', uri, expected_status=200, data=json.dumps(params))
def update_pipeline(self, id, name=None, input_bucket=None, role=None, notifications=None, content_config=None, thumbnail_config=None): DCNL DCSP uri = '/2012-09-25/pipelines/{0}'.format(id) DCNL DCSP params = {} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (input_bucket is not None): DCNL DCSP  DCSP params['InputBucket'] = input_bucket DCNL DCSP if (role is not None): DCNL DCSP  DCSP params['Role'] = role DCNL DCSP if (notifications is not None): DCNL DCSP  DCSP params['Notifications'] = notifications DCNL DCSP if (content_config is not None): DCNL DCSP  DCSP params['ContentConfig'] = content_config DCNL DCSP if (thumbnail_config is not None): DCNL DCSP  DCSP params['ThumbnailConfig'] = thumbnail_config DCNL DCSP return self.make_request('PUT', uri, expected_status=200, data=json.dumps(params))
def update_pipeline_notifications(self, id=None, notifications=None): DCNL DCSP uri = '/2012-09-25/pipelines/{0}/notifications'.format(id) DCNL DCSP params = {} DCNL DCSP if (id is not None): DCNL DCSP  DCSP params['Id'] = id DCNL DCSP if (notifications is not None): DCNL DCSP  DCSP params['Notifications'] = notifications DCNL DCSP return self.make_request('POST', uri, expected_status=200, data=json.dumps(params))
def update_pipeline_status(self, id=None, status=None): DCNL DCSP uri = '/2012-09-25/pipelines/{0}/status'.format(id) DCNL DCSP params = {} DCNL DCSP if (id is not None): DCNL DCSP  DCSP params['Id'] = id DCNL DCSP if (status is not None): DCNL DCSP  DCSP params['Status'] = status DCNL DCSP return self.make_request('POST', uri, expected_status=200, data=json.dumps(params))
def encode(self, value): DCNL DCSP (bucket_name, key_name) = self._get_bucket_key(self.s3_url) DCNL DCSP if (bucket_name and key_name): DCNL DCSP  DCSP return self.s3_url DCNL DCSP key_name = uuid.uuid4() DCNL DCSP s3_conn = boto.connect_s3() DCNL DCSP s3_bucket = s3_conn.get_bucket(bucket_name) DCNL DCSP key = s3_bucket.new_key(key_name) DCNL DCSP key.set_contents_from_file(value) DCNL DCSP self.s3_url = ('s3://%s/%s' % (bucket_name, key_name)) DCNL DCSP return self.s3_url
def set_message_class(self, message_class): DCNL DCSP self.message_class = message_class
def get_attributes(self, attributes='All'): DCNL DCSP return self.connection.get_queue_attributes(self, attributes)
def set_attribute(self, attribute, value): DCNL DCSP return self.connection.set_queue_attribute(self, attribute, value)
def get_timeout(self): DCNL DCSP a = self.get_attributes('VisibilityTimeout') DCNL DCSP return int(a['VisibilityTimeout'])
def set_timeout(self, visibility_timeout): DCNL DCSP retval = self.set_attribute('VisibilityTimeout', visibility_timeout) DCNL DCSP if retval: DCNL DCSP  DCSP self.visibility_timeout = visibility_timeout DCNL DCSP return retval
def add_permission(self, label, aws_account_id, action_name): DCNL DCSP return self.connection.add_permission(self, label, aws_account_id, action_name)
def remove_permission(self, label): DCNL DCSP return self.connection.remove_permission(self, label)
def read(self, visibility_timeout=None, wait_time_seconds=None, message_attributes=None): DCNL DCSP rs = self.get_messages(1, visibility_timeout, wait_time_seconds=wait_time_seconds, message_attributes=message_attributes) DCNL DCSP if (len(rs) == 1): DCNL DCSP  DCSP return rs[0] DCNL DCSP else: DCNL DCSP  DCSP return None
def write(self, message, delay_seconds=None): DCNL DCSP new_msg = self.connection.send_message(self, message.get_body_encoded(), delay_seconds=delay_seconds, message_attributes=message.message_attributes) DCNL DCSP message.id = new_msg.id DCNL DCSP message.md5 = new_msg.md5 DCNL DCSP return message
def write_batch(self, messages): DCNL DCSP return self.connection.send_message_batch(self, messages)
def new_message(self, body='', **kwargs): DCNL DCSP m = self.message_class(self, body, **kwargs) DCNL DCSP m.queue = self DCNL DCSP return m
def get_messages(self, num_messages=1, visibility_timeout=None, attributes=None, wait_time_seconds=None, message_attributes=None): DCNL DCSP return self.connection.receive_message(self, number_messages=num_messages, visibility_timeout=visibility_timeout, attributes=attributes, wait_time_seconds=wait_time_seconds, message_attributes=message_attributes)
def delete_message(self, message): DCNL DCSP return self.connection.delete_message(self, message)
def delete_message_batch(self, messages): DCNL DCSP return self.connection.delete_message_batch(self, messages)
def change_message_visibility_batch(self, messages): DCNL DCSP return self.connection.change_message_visibility_batch(self, messages)
def delete(self): DCNL DCSP return self.connection.delete_queue(self)
def purge(self): DCNL DCSP return self.connection.purge_queue(self)
def clear(self, page_size=10, vtimeout=10): DCNL DCSP return self.purge()
def count(self, page_size=10, vtimeout=10): DCNL DCSP a = self.get_attributes('ApproximateNumberOfMessages') DCNL DCSP return int(a['ApproximateNumberOfMessages'])
def count_slow(self, page_size=10, vtimeout=10): DCNL DCSP n = 0 DCNL DCSP l = self.get_messages(page_size, vtimeout) DCNL DCSP while l: DCNL DCSP  DCSP for m in l: DCNL DCSP  DCSP  DCSP n += 1 DCNL DCSP  DCSP l = self.get_messages(page_size, vtimeout) DCNL DCSP return n
def dump(self, file_name, page_size=10, vtimeout=10, sep='\n'): DCNL DCSP fp = open(file_name, 'wb') DCNL DCSP n = 0 DCNL DCSP l = self.get_messages(page_size, vtimeout) DCNL DCSP while l: DCNL DCSP  DCSP for m in l: DCNL DCSP  DCSP  DCSP fp.write(m.get_body()) DCNL DCSP  DCSP  DCSP if sep: DCNL DCSP  DCSP  DCSP  DCSP fp.write(sep) DCNL DCSP  DCSP  DCSP n += 1 DCNL DCSP  DCSP l = self.get_messages(page_size, vtimeout) DCNL DCSP fp.close() DCNL DCSP return n
def save_to_file(self, fp, sep='\n'): DCNL DCSP n = 0 DCNL DCSP m = self.read() DCNL DCSP while m: DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP fp.write(m.get_body()) DCNL DCSP  DCSP if sep: DCNL DCSP  DCSP  DCSP fp.write(sep) DCNL DCSP  DCSP self.delete_message(m) DCNL DCSP  DCSP m = self.read() DCNL DCSP return n
def save_to_filename(self, file_name, sep='\n'): DCNL DCSP fp = open(file_name, 'wb') DCNL DCSP n = self.save_to_file(fp, sep) DCNL DCSP fp.close() DCNL DCSP return n
def save_to_s3(self, bucket): DCNL DCSP n = 0 DCNL DCSP m = self.read() DCNL DCSP while m: DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP key = bucket.new_key(('%s/%s' % (self.id, m.id))) DCNL DCSP  DCSP key.set_contents_from_string(m.get_body()) DCNL DCSP  DCSP self.delete_message(m) DCNL DCSP  DCSP m = self.read() DCNL DCSP return n
def load_from_s3(self, bucket, prefix=None): DCNL DCSP n = 0 DCNL DCSP if prefix: DCNL DCSP  DCSP prefix = ('%s/' % prefix) DCNL DCSP else: DCNL DCSP  DCSP prefix = ('%s/' % self.id[1:]) DCNL DCSP rs = bucket.list(prefix=prefix) DCNL DCSP for key in rs: DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP m = self.new_message(key.get_contents_as_string()) DCNL DCSP  DCSP self.write(m) DCNL DCSP return n
def load_from_file(self, fp, sep='\n'): DCNL DCSP n = 0 DCNL DCSP body = '' DCNL DCSP l = fp.readline() DCNL DCSP while l: DCNL DCSP  DCSP if (l == sep): DCNL DCSP  DCSP  DCSP m = Message(self, body) DCNL DCSP  DCSP  DCSP self.write(m) DCNL DCSP  DCSP  DCSP n += 1 DCNL DCSP  DCSP  DCSP print ('writing DCSP message DCSP %d' % n) DCNL DCSP  DCSP  DCSP body = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP body = (body + l) DCNL DCSP  DCSP l = fp.readline() DCNL DCSP return n
def load_from_filename(self, file_name, sep='\n'): DCNL DCSP fp = open(file_name, 'rb') DCNL DCSP n = self.load_from_file(fp, sep) DCNL DCSP fp.close() DCNL DCSP return n
def create_queue(self, queue_name, visibility_timeout=None): DCNL DCSP params = {'QueueName': queue_name} DCNL DCSP if visibility_timeout: DCNL DCSP  DCSP params['Attribute.1.Name'] = 'VisibilityTimeout' DCNL DCSP  DCSP params['Attribute.1.Value'] = int(visibility_timeout) DCNL DCSP return self.get_object('CreateQueue', params, Queue)
def delete_queue(self, queue, force_deletion=False): DCNL DCSP return self.get_status('DeleteQueue', None, queue.id)
def purge_queue(self, queue): DCNL DCSP return self.get_status('PurgeQueue', None, queue.id)
def get_queue_attributes(self, queue, attribute='All'): DCNL DCSP params = {'AttributeName': attribute} DCNL DCSP return self.get_object('GetQueueAttributes', params, Attributes, queue.id)
def set_queue_attribute(self, queue, attribute, value): DCNL DCSP params = {'Attribute.Name': attribute, 'Attribute.Value': value} DCNL DCSP return self.get_status('SetQueueAttributes', params, queue.id)
def receive_message(self, queue, number_messages=1, visibility_timeout=None, attributes=None, wait_time_seconds=None, message_attributes=None): DCNL DCSP params = {'MaxNumberOfMessages': number_messages} DCNL DCSP if (visibility_timeout is not None): DCNL DCSP  DCSP params['VisibilityTimeout'] = visibility_timeout DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP self.build_list_params(params, attributes, 'AttributeName') DCNL DCSP if (wait_time_seconds is not None): DCNL DCSP  DCSP params['WaitTimeSeconds'] = wait_time_seconds DCNL DCSP if (message_attributes is not None): DCNL DCSP  DCSP self.build_list_params(params, message_attributes, 'MessageAttributeName') DCNL DCSP return self.get_list('ReceiveMessage', params, [('Message', queue.message_class)], queue.id, queue)
def delete_message(self, queue, message): DCNL DCSP params = {'ReceiptHandle': message.receipt_handle} DCNL DCSP return self.get_status('DeleteMessage', params, queue.id)
def delete_message_batch(self, queue, messages): DCNL DCSP params = {} DCNL DCSP for (i, msg) in enumerate(messages): DCNL DCSP  DCSP prefix = 'DeleteMessageBatchRequestEntry' DCNL DCSP  DCSP p_name = ('%s.%i.Id' % (prefix, (i + 1))) DCNL DCSP  DCSP params[p_name] = msg.id DCNL DCSP  DCSP p_name = ('%s.%i.ReceiptHandle' % (prefix, (i + 1))) DCNL DCSP  DCSP params[p_name] = msg.receipt_handle DCNL DCSP return self.get_object('DeleteMessageBatch', params, BatchResults, queue.id, verb='POST')
def delete_message_from_handle(self, queue, receipt_handle): DCNL DCSP params = {'ReceiptHandle': receipt_handle} DCNL DCSP return self.get_status('DeleteMessage', params, queue.id)
def send_message(self, queue, message_content, delay_seconds=None, message_attributes=None): DCNL DCSP params = {'MessageBody': message_content} DCNL DCSP if delay_seconds: DCNL DCSP  DCSP params['DelaySeconds'] = int(delay_seconds) DCNL DCSP if (message_attributes is not None): DCNL DCSP  DCSP keys = sorted(message_attributes.keys()) DCNL DCSP  DCSP for (i, name) in enumerate(keys, start=1): DCNL DCSP  DCSP  DCSP attribute = message_attributes[name] DCNL DCSP  DCSP  DCSP params[('MessageAttribute.%s.Name' % i)] = name DCNL DCSP  DCSP  DCSP if ('data_type' in attribute): DCNL DCSP  DCSP  DCSP  DCSP params[('MessageAttribute.%s.Value.DataType' % i)] = attribute['data_type'] DCNL DCSP  DCSP  DCSP if ('string_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP params[('MessageAttribute.%s.Value.StringValue' % i)] = attribute['string_value'] DCNL DCSP  DCSP  DCSP if ('binary_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP params[('MessageAttribute.%s.Value.BinaryValue' % i)] = attribute['binary_value'] DCNL DCSP  DCSP  DCSP if ('string_list_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP params[('MessageAttribute.%s.Value.StringListValue' % i)] = attribute['string_list_value'] DCNL DCSP  DCSP  DCSP if ('binary_list_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP params[('MessageAttribute.%s.Value.BinaryListValue' % i)] = attribute['binary_list_value'] DCNL DCSP return self.get_object('SendMessage', params, Message, queue.id, verb='POST')
def send_message_batch(self, queue, messages): DCNL DCSP params = {} DCNL DCSP for (i, msg) in enumerate(messages): DCNL DCSP  DCSP base = ('SendMessageBatchRequestEntry.%i' % (i + 1)) DCNL DCSP  DCSP params[('%s.Id' % base)] = msg[0] DCNL DCSP  DCSP params[('%s.MessageBody' % base)] = msg[1] DCNL DCSP  DCSP params[('%s.DelaySeconds' % base)] = msg[2] DCNL DCSP  DCSP if (len(msg) > 3): DCNL DCSP  DCSP  DCSP base += '.MessageAttribute' DCNL DCSP  DCSP  DCSP keys = sorted(msg[3].keys()) DCNL DCSP  DCSP  DCSP for (j, name) in enumerate(keys): DCNL DCSP  DCSP  DCSP  DCSP attribute = msg[3][name] DCNL DCSP  DCSP  DCSP  DCSP p_name = ('%s.%i.Name' % (base, (j + 1))) DCNL DCSP  DCSP  DCSP  DCSP params[p_name] = name DCNL DCSP  DCSP  DCSP  DCSP if ('data_type' in attribute): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_name = ('%s.%i.Value.DataType' % (base, (j + 1))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[p_name] = attribute['data_type'] DCNL DCSP  DCSP  DCSP  DCSP if ('string_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_name = ('%s.%i.Value.StringValue' % (base, (j + 1))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[p_name] = attribute['string_value'] DCNL DCSP  DCSP  DCSP  DCSP if ('binary_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_name = ('%s.%i.Value.BinaryValue' % (base, (j + 1))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[p_name] = attribute['binary_value'] DCNL DCSP  DCSP  DCSP  DCSP if ('string_list_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_name = ('%s.%i.Value.StringListValue' % (base, (j + 1))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[p_name] = attribute['string_list_value'] DCNL DCSP  DCSP  DCSP  DCSP if ('binary_list_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_name = ('%s.%i.Value.BinaryListValue' % (base, (j + 1))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[p_name] = attribute['binary_list_value'] DCNL DCSP return self.get_object('SendMessageBatch', params, BatchResults, queue.id, verb='POST')
def change_message_visibility(self, queue, receipt_handle, visibility_timeout): DCNL DCSP params = {'ReceiptHandle': receipt_handle, 'VisibilityTimeout': visibility_timeout} DCNL DCSP return self.get_status('ChangeMessageVisibility', params, queue.id)
def change_message_visibility_batch(self, queue, messages): DCNL DCSP params = {} DCNL DCSP for (i, t) in enumerate(messages): DCNL DCSP  DCSP prefix = 'ChangeMessageVisibilityBatchRequestEntry' DCNL DCSP  DCSP p_name = ('%s.%i.Id' % (prefix, (i + 1))) DCNL DCSP  DCSP params[p_name] = t[0].id DCNL DCSP  DCSP p_name = ('%s.%i.ReceiptHandle' % (prefix, (i + 1))) DCNL DCSP  DCSP params[p_name] = t[0].receipt_handle DCNL DCSP  DCSP p_name = ('%s.%i.VisibilityTimeout' % (prefix, (i + 1))) DCNL DCSP  DCSP params[p_name] = t[1] DCNL DCSP return self.get_object('ChangeMessageVisibilityBatch', params, BatchResults, queue.id, verb='POST')
def get_all_queues(self, prefix=''): DCNL DCSP params = {} DCNL DCSP if prefix: DCNL DCSP  DCSP params['QueueNamePrefix'] = prefix DCNL DCSP return self.get_list('ListQueues', params, [('QueueUrl', Queue)])
def get_queue(self, queue_name, owner_acct_id=None): DCNL DCSP params = {'QueueName': queue_name} DCNL DCSP if owner_acct_id: DCNL DCSP  DCSP params['QueueOwnerAWSAccountId'] = owner_acct_id DCNL DCSP try: DCNL DCSP  DCSP return self.get_object('GetQueueUrl', params, Queue) DCNL DCSP except SQSError: DCNL DCSP  DCSP return None
def get_dead_letter_source_queues(self, queue): DCNL DCSP params = {'QueueUrl': queue.url} DCNL DCSP return self.get_list('ListDeadLetterSourceQueues', params, [('QueueUrl', Queue)])
def add_permission(self, queue, label, aws_account_id, action_name): DCNL DCSP params = {'Label': label, 'AWSAccountId': aws_account_id, 'ActionName': action_name} DCNL DCSP return self.get_status('AddPermission', params, queue.id)
def remove_permission(self, queue, label): DCNL DCSP params = {'Label': label} DCNL DCSP return self.get_status('RemovePermission', params, queue.id)
def encode(self, value): DCNL DCSP return value
def decode(self, value): DCNL DCSP return value
def set_body(self, body): DCNL DCSP self._body = body
def get_body_encoded(self): DCNL DCSP return self.encode(self.get_body())
def get_response(self, action, params, page=0, itemSet=None): DCNL DCSP params['Service'] = 'AWSECommerceService' DCNL DCSP params['Operation'] = action DCNL DCSP if page: DCNL DCSP  DCSP params['ItemPage'] = page DCNL DCSP response = self.make_request(None, params, '/onca/xml') DCNL DCSP body = response.read().decode('utf-8') DCNL DCSP boto.log.debug(body) DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP boto.log.error(('%s DCSP %s' % (response.status, response.reason))) DCNL DCSP  DCSP boto.log.error(('%s' % body)) DCNL DCSP  DCSP raise BotoServerError(response.status, response.reason, body) DCNL DCSP if (itemSet is None): DCNL DCSP  DCSP rs = ItemSet(self, action, params, page) DCNL DCSP else: DCNL DCSP  DCSP rs = itemSet DCNL DCSP h = handler.XmlHandler(rs, self) DCNL DCSP xml.sax.parseString(body.encode('utf-8'), h) DCNL DCSP if (not rs.is_valid): DCNL DCSP  DCSP raise BotoServerError(response.status, '{Code}: DCSP {Message}'.format(**rs.errors[0])) DCNL DCSP return rs
def item_search(self, search_index, **params): DCNL DCSP params['SearchIndex'] = search_index DCNL DCSP return self.get_response('ItemSearch', params)
def item_lookup(self, **params): DCNL DCSP return self.get_response('ItemLookup', params)
def __init__(self, connection=None, nodename=None): DCNL DCSP self._connection = connection DCNL DCSP self._nodename = nodename DCNL DCSP self._nodepath = [] DCNL DCSP self._curobj = None DCNL DCSP self._xml = StringIO()
def __init__(self, connection=None): DCNL DCSP ResponseGroup.__init__(self, connection, 'Item')
def __next__(self): DCNL DCSP if (self.iter is None): DCNL DCSP  DCSP self.iter = iter(self.objs) DCNL DCSP try: DCNL DCSP  DCSP return next(self.iter) DCNL DCSP except StopIteration: DCNL DCSP  DCSP self.iter = None DCNL DCSP  DCSP self.objs = [] DCNL DCSP  DCSP if (int(self.page) < int(self.total_pages)): DCNL DCSP  DCSP  DCSP self.page += 1 DCNL DCSP  DCSP  DCSP self._connection.get_response(self.action, self.params, self.page, self) DCNL DCSP  DCSP  DCSP return next(self) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def to_xml(self): DCNL DCSP for item in self: DCNL DCSP  DCSP pass DCNL DCSP return ResponseGroup.to_xml(self)
def get_account_balance(self): DCNL DCSP params = {} DCNL DCSP return self._process_request('GetAccountBalance', params, [('AvailableBalance', Price), ('OnHoldBalance', Price)])
def register_hit_type(self, title, description, reward, duration, keywords=None, approval_delay=None, qual_req=None): DCNL DCSP params = dict(Title=title, Description=description, AssignmentDurationInSeconds=self.duration_as_seconds(duration)) DCNL DCSP params.update(MTurkConnection.get_price_as_price(reward).get_as_params('Reward')) DCNL DCSP if keywords: DCNL DCSP  DCSP params['Keywords'] = self.get_keywords_as_string(keywords) DCNL DCSP if (approval_delay is not None): DCNL DCSP  DCSP d = self.duration_as_seconds(approval_delay) DCNL DCSP  DCSP params['AutoApprovalDelayInSeconds'] = d DCNL DCSP if (qual_req is not None): DCNL DCSP  DCSP params.update(qual_req.get_as_params()) DCNL DCSP return self._process_request('RegisterHITType', params, [('HITTypeId', HITTypeId)])
def set_email_notification(self, hit_type, email, event_types=None): DCNL DCSP return self._set_notification(hit_type, 'Email', email, 'SetHITTypeNotification', event_types)
def set_rest_notification(self, hit_type, url, event_types=None): DCNL DCSP return self._set_notification(hit_type, 'REST', url, 'SetHITTypeNotification', event_types)
def set_sqs_notification(self, hit_type, queue_url, event_types=None): DCNL DCSP return self._set_notification(hit_type, 'SQS', queue_url, 'SetHITTypeNotification', event_types)
def send_test_event_notification(self, hit_type, url, event_types=None, test_event_type='Ping'): DCNL DCSP return self._set_notification(hit_type, 'REST', url, 'SendTestEventNotification', event_types, test_event_type)
def _set_notification(self, hit_type, transport, destination, request_type, event_types=None, test_event_type=None): DCNL DCSP params = {'HITTypeId': hit_type} DCNL DCSP notification_params = {'Destination': destination, 'Transport': transport, 'Version': boto.mturk.notification.NotificationMessage.NOTIFICATION_VERSION, 'Active': True} DCNL DCSP if event_types: DCNL DCSP  DCSP self.build_list_params(notification_params, event_types, 'EventType') DCNL DCSP notification_rest_params = {} DCNL DCSP num = 1 DCNL DCSP for key in notification_params: DCNL DCSP  DCSP notification_rest_params[('Notification.%d.%s' % (num, key))] = notification_params[key] DCNL DCSP params.update(notification_rest_params) DCNL DCSP if test_event_type: DCNL DCSP  DCSP params.update({'TestEventType': test_event_type}) DCNL DCSP return self._process_request(request_type, params)
def create_hit(self, hit_type=None, question=None, hit_layout=None, lifetime=datetime.timedelta(days=7), max_assignments=1, title=None, description=None, keywords=None, reward=None, duration=datetime.timedelta(days=7), approval_delay=None, annotation=None, questions=None, qualifications=None, layout_params=None, response_groups=None): DCNL DCSP params = {'LifetimeInSeconds': self.duration_as_seconds(lifetime), 'MaxAssignments': max_assignments} DCNL DCSP neither = ((question is None) and (questions is None)) DCNL DCSP if (hit_layout is None): DCNL DCSP  DCSP both = ((question is not None) and (questions is not None)) DCNL DCSP  DCSP if (neither or both): DCNL DCSP  DCSP  DCSP raise ValueError('Must DCSP specify DCSP question DCSP (single DCSP Question DCSP instance) DCSP or DCSP questions DCSP (list DCSP or DCSP QuestionForm DCSP instance), DCSP but DCSP not DCSP both') DCNL DCSP  DCSP if question: DCNL DCSP  DCSP  DCSP questions = [question] DCNL DCSP  DCSP question_param = QuestionForm(questions) DCNL DCSP  DCSP if isinstance(question, QuestionForm): DCNL DCSP  DCSP  DCSP question_param = question DCNL DCSP  DCSP elif isinstance(question, ExternalQuestion): DCNL DCSP  DCSP  DCSP question_param = question DCNL DCSP  DCSP elif isinstance(question, HTMLQuestion): DCNL DCSP  DCSP  DCSP question_param = question DCNL DCSP  DCSP params['Question'] = question_param.get_as_xml() DCNL DCSP else: DCNL DCSP  DCSP if (not neither): DCNL DCSP  DCSP  DCSP raise ValueError('Must DCSP not DCSP specify DCSP question DCSP (single DCSP Question DCSP instance) DCSP or DCSP questions DCSP (list DCSP or DCSP QuestionForm DCSP instance) DCSP when DCSP specifying DCSP hit_layout') DCNL DCSP  DCSP params['HITLayoutId'] = hit_layout DCNL DCSP  DCSP if layout_params: DCNL DCSP  DCSP  DCSP params.update(layout_params.get_as_params()) DCNL DCSP if hit_type: DCNL DCSP  DCSP params['HITTypeId'] = hit_type DCNL DCSP else: DCNL DCSP  DCSP final_keywords = MTurkConnection.get_keywords_as_string(keywords) DCNL DCSP  DCSP final_price = MTurkConnection.get_price_as_price(reward) DCNL DCSP  DCSP final_duration = self.duration_as_seconds(duration) DCNL DCSP  DCSP additional_params = dict(Title=title, Description=description, Keywords=final_keywords, AssignmentDurationInSeconds=final_duration) DCNL DCSP  DCSP additional_params.update(final_price.get_as_params('Reward')) DCNL DCSP  DCSP if (approval_delay is not None): DCNL DCSP  DCSP  DCSP d = self.duration_as_seconds(approval_delay) DCNL DCSP  DCSP  DCSP additional_params['AutoApprovalDelayInSeconds'] = d DCNL DCSP  DCSP params.update(additional_params) DCNL DCSP if (annotation is not None): DCNL DCSP  DCSP params['RequesterAnnotation'] = annotation DCNL DCSP if (qualifications is not None): DCNL DCSP  DCSP params.update(qualifications.get_as_params()) DCNL DCSP if response_groups: DCNL DCSP  DCSP self.build_list_params(params, response_groups, 'ResponseGroup') DCNL DCSP return self._process_request('CreateHIT', params, [('HIT', HIT)])
def change_hit_type_of_hit(self, hit_id, hit_type): DCNL DCSP params = {'HITId': hit_id, 'HITTypeId': hit_type} DCNL DCSP return self._process_request('ChangeHITTypeOfHIT', params)
def get_reviewable_hits(self, hit_type=None, status='Reviewable', sort_by='Expiration', sort_direction='Ascending', page_size=10, page_number=1): DCNL DCSP params = {'Status': status, 'SortProperty': sort_by, 'SortDirection': sort_direction, 'PageSize': page_size, 'PageNumber': page_number} DCNL DCSP if (hit_type is not None): DCNL DCSP  DCSP params.update({'HITTypeId': hit_type}) DCNL DCSP return self._process_request('GetReviewableHITs', params, [('HIT', HIT)])
@staticmethod DCNL def _get_pages(page_size, total_records): DCNL DCSP pages = ((total_records / page_size) + bool((total_records % page_size))) DCNL DCSP return list(range(1, (pages + 1)))
def get_all_hits(self): DCNL DCSP page_size = 100 DCNL DCSP search_rs = self.search_hits(page_size=page_size) DCNL DCSP total_records = int(search_rs.TotalNumResults) DCNL DCSP get_page_hits = (lambda page: self.search_hits(page_size=page_size, page_number=page)) DCNL DCSP page_nums = self._get_pages(page_size, total_records) DCNL DCSP hit_sets = itertools.imap(get_page_hits, page_nums) DCNL DCSP return itertools.chain.from_iterable(hit_sets)
def search_hits(self, sort_by='CreationTime', sort_direction='Ascending', page_size=10, page_number=1, response_groups=None): DCNL DCSP params = {'SortProperty': sort_by, 'SortDirection': sort_direction, 'PageSize': page_size, 'PageNumber': page_number} DCNL DCSP if response_groups: DCNL DCSP  DCSP self.build_list_params(params, response_groups, 'ResponseGroup') DCNL DCSP return self._process_request('SearchHITs', params, [('HIT', HIT)])
def get_assignment(self, assignment_id, response_groups=None): DCNL DCSP params = {'AssignmentId': assignment_id} DCNL DCSP if response_groups: DCNL DCSP  DCSP self.build_list_params(params, response_groups, 'ResponseGroup') DCNL DCSP return self._process_request('GetAssignment', params, [('Assignment', Assignment), ('HIT', HIT)])
def get_assignments(self, hit_id, status=None, sort_by='SubmitTime', sort_direction='Ascending', page_size=10, page_number=1, response_groups=None): DCNL DCSP params = {'HITId': hit_id, 'SortProperty': sort_by, 'SortDirection': sort_direction, 'PageSize': page_size, 'PageNumber': page_number} DCNL DCSP if (status is not None): DCNL DCSP  DCSP params['AssignmentStatus'] = status DCNL DCSP if response_groups: DCNL DCSP  DCSP self.build_list_params(params, response_groups, 'ResponseGroup') DCNL DCSP return self._process_request('GetAssignmentsForHIT', params, [('Assignment', Assignment)])
def approve_assignment(self, assignment_id, feedback=None): DCNL DCSP params = {'AssignmentId': assignment_id} DCNL DCSP if feedback: DCNL DCSP  DCSP params['RequesterFeedback'] = feedback DCNL DCSP return self._process_request('ApproveAssignment', params)
def reject_assignment(self, assignment_id, feedback=None): DCNL DCSP params = {'AssignmentId': assignment_id} DCNL DCSP if feedback: DCNL DCSP  DCSP params['RequesterFeedback'] = feedback DCNL DCSP return self._process_request('RejectAssignment', params)
def approve_rejected_assignment(self, assignment_id, feedback=None): DCNL DCSP params = {'AssignmentId': assignment_id} DCNL DCSP if feedback: DCNL DCSP  DCSP params['RequesterFeedback'] = feedback DCNL DCSP return self._process_request('ApproveRejectedAssignment', params)
def get_file_upload_url(self, assignment_id, question_identifier): DCNL DCSP params = {'AssignmentId': assignment_id, 'QuestionIdentifier': question_identifier} DCNL DCSP return self._process_request('GetFileUploadURL', params, [('FileUploadURL', FileUploadURL)])
def get_hit(self, hit_id, response_groups=None): DCNL DCSP params = {'HITId': hit_id} DCNL DCSP if response_groups: DCNL DCSP  DCSP self.build_list_params(params, response_groups, 'ResponseGroup') DCNL DCSP return self._process_request('GetHIT', params, [('HIT', HIT)])
def set_reviewing(self, hit_id, revert=None): DCNL DCSP params = {'HITId': hit_id} DCNL DCSP if revert: DCNL DCSP  DCSP params['Revert'] = revert DCNL DCSP return self._process_request('SetHITAsReviewing', params)
def disable_hit(self, hit_id, response_groups=None): DCNL DCSP params = {'HITId': hit_id} DCNL DCSP if response_groups: DCNL DCSP  DCSP self.build_list_params(params, response_groups, 'ResponseGroup') DCNL DCSP return self._process_request('DisableHIT', params)
def dispose_hit(self, hit_id): DCNL DCSP params = {'HITId': hit_id} DCNL DCSP return self._process_request('DisposeHIT', params)
def expire_hit(self, hit_id): DCNL DCSP params = {'HITId': hit_id} DCNL DCSP return self._process_request('ForceExpireHIT', params)
def extend_hit(self, hit_id, assignments_increment=None, expiration_increment=None): DCNL DCSP if (((assignments_increment is None) and (expiration_increment is None)) or ((assignments_increment is not None) and (expiration_increment is not None))): DCNL DCSP  DCSP raise ValueError('Must DCSP specify DCSP either DCSP assignments_increment DCSP or DCSP expiration_increment, DCSP but DCSP not DCSP both') DCNL DCSP params = {'HITId': hit_id} DCNL DCSP if assignments_increment: DCNL DCSP  DCSP params['MaxAssignmentsIncrement'] = assignments_increment DCNL DCSP if expiration_increment: DCNL DCSP  DCSP params['ExpirationIncrementInSeconds'] = expiration_increment DCNL DCSP return self._process_request('ExtendHIT', params)
def get_help(self, about, help_type='Operation'): DCNL DCSP params = {'About': about, 'HelpType': help_type} DCNL DCSP return self._process_request('Help', params)
def grant_bonus(self, worker_id, assignment_id, bonus_price, reason): DCNL DCSP params = bonus_price.get_as_params('BonusAmount', 1) DCNL DCSP params['WorkerId'] = worker_id DCNL DCSP params['AssignmentId'] = assignment_id DCNL DCSP params['Reason'] = reason DCNL DCSP return self._process_request('GrantBonus', params)
def block_worker(self, worker_id, reason): DCNL DCSP params = {'WorkerId': worker_id, 'Reason': reason} DCNL DCSP return self._process_request('BlockWorker', params)
def unblock_worker(self, worker_id, reason): DCNL DCSP params = {'WorkerId': worker_id, 'Reason': reason} DCNL DCSP return self._process_request('UnblockWorker', params)
def notify_workers(self, worker_ids, subject, message_text): DCNL DCSP params = {'Subject': subject, 'MessageText': message_text} DCNL DCSP self.build_list_params(params, worker_ids, 'WorkerId') DCNL DCSP return self._process_request('NotifyWorkers', params)
def create_qualification_type(self, name, description, status, keywords=None, retry_delay=None, test=None, answer_key=None, answer_key_xml=None, test_duration=None, auto_granted=False, auto_granted_value=1): DCNL DCSP params = {'Name': name, 'Description': description, 'QualificationTypeStatus': status} DCNL DCSP if (retry_delay is not None): DCNL DCSP  DCSP params['RetryDelayInSeconds'] = retry_delay DCNL DCSP if (test is not None): DCNL DCSP  DCSP assert isinstance(test, QuestionForm) DCNL DCSP  DCSP assert (test_duration is not None) DCNL DCSP  DCSP params['Test'] = test.get_as_xml() DCNL DCSP if (test_duration is not None): DCNL DCSP  DCSP params['TestDurationInSeconds'] = test_duration DCNL DCSP if (answer_key is not None): DCNL DCSP  DCSP if isinstance(answer_key, basestring): DCNL DCSP  DCSP  DCSP params['AnswerKey'] = answer_key DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError DCNL DCSP if auto_granted: DCNL DCSP  DCSP assert (test is None) DCNL DCSP  DCSP params['AutoGranted'] = True DCNL DCSP  DCSP params['AutoGrantedValue'] = auto_granted_value DCNL DCSP if keywords: DCNL DCSP  DCSP params['Keywords'] = self.get_keywords_as_string(keywords) DCNL DCSP return self._process_request('CreateQualificationType', params, [('QualificationType', QualificationType)])
def dispose_qualification_type(self, qualification_type_id): DCNL DCSP params = {'QualificationTypeId': qualification_type_id} DCNL DCSP return self._process_request('DisposeQualificationType', params)
def search_qualification_types(self, query=None, sort_by='Name', sort_direction='Ascending', page_size=10, page_number=1, must_be_requestable=True, must_be_owned_by_caller=True): DCNL DCSP params = {'Query': query, 'SortProperty': sort_by, 'SortDirection': sort_direction, 'PageSize': page_size, 'PageNumber': page_number, 'MustBeRequestable': must_be_requestable, 'MustBeOwnedByCaller': must_be_owned_by_caller} DCNL DCSP return self._process_request('SearchQualificationTypes', params, [('QualificationType', QualificationType)])
def get_qualification_requests(self, qualification_type_id, sort_by='Expiration', sort_direction='Ascending', page_size=10, page_number=1): DCNL DCSP params = {'QualificationTypeId': qualification_type_id, 'SortProperty': sort_by, 'SortDirection': sort_direction, 'PageSize': page_size, 'PageNumber': page_number} DCNL DCSP return self._process_request('GetQualificationRequests', params, [('QualificationRequest', QualificationRequest)])
def grant_qualification(self, qualification_request_id, integer_value=1): DCNL DCSP params = {'QualificationRequestId': qualification_request_id, 'IntegerValue': integer_value} DCNL DCSP return self._process_request('GrantQualification', params)
def revoke_qualification(self, subject_id, qualification_type_id, reason=None): DCNL DCSP params = {'SubjectId': subject_id, 'QualificationTypeId': qualification_type_id, 'Reason': reason} DCNL DCSP return self._process_request('RevokeQualification', params)
def get_qualification_score(self, qualification_type_id, worker_id): DCNL DCSP params = {'QualificationTypeId': qualification_type_id, 'SubjectId': worker_id} DCNL DCSP return self._process_request('GetQualificationScore', params, [('Qualification', Qualification)])
def update_qualification_score(self, qualification_type_id, worker_id, value): DCNL DCSP params = {'QualificationTypeId': qualification_type_id, 'SubjectId': worker_id, 'IntegerValue': value} DCNL DCSP return self._process_request('UpdateQualificationScore', params)
def _process_request(self, request_type, params, marker_elems=None): DCNL DCSP params['Operation'] = request_type DCNL DCSP response = self.make_request(None, params, verb='POST') DCNL DCSP return self._process_response(response, marker_elems)
def _process_response(self, response, marker_elems=None): DCNL DCSP body = response.read() DCNL DCSP if (self.debug == 2): DCNL DCSP  DCSP print body DCNL DCSP if ('<Errors>' not in body.decode('utf-8')): DCNL DCSP  DCSP rs = ResultSet(marker_elems) DCNL DCSP  DCSP h = handler.XmlHandler(rs, self) DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return rs DCNL DCSP else: DCNL DCSP  DCSP raise MTurkRequestError(response.status, response.reason, body)
@staticmethod DCNL def get_keywords_as_string(keywords): DCNL DCSP if isinstance(keywords, list): DCNL DCSP  DCSP keywords = ', DCSP '.join(keywords) DCNL DCSP if isinstance(keywords, str): DCNL DCSP  DCSP final_keywords = keywords DCNL DCSP elif isinstance(keywords, unicode): DCNL DCSP  DCSP final_keywords = keywords.encode('utf-8') DCNL DCSP elif (keywords is None): DCNL DCSP  DCSP final_keywords = '' DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('keywords DCSP argument DCSP must DCSP be DCSP a DCSP string DCSP or DCSP a DCSP list DCSP of DCSP strings; DCSP got DCSP a DCSP %s' % type(keywords))) DCNL DCSP return final_keywords
@staticmethod DCNL def get_price_as_price(reward): DCNL DCSP if isinstance(reward, Price): DCNL DCSP  DCSP final_price = reward DCNL DCSP else: DCNL DCSP  DCSP final_price = Price(reward) DCNL DCSP return final_price
def _has_expired(self): DCNL DCSP expired = False DCNL DCSP if hasattr(self, 'Expiration'): DCNL DCSP  DCSP now = datetime.datetime.utcnow() DCNL DCSP  DCSP expiration = datetime.datetime.strptime(self.Expiration, '%Y-%m-%dT%H:%M:%SZ') DCNL DCSP  DCSP expired = (now >= expiration) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('ERROR: DCSP Request DCSP for DCSP expired DCSP property, DCSP but DCSP no DCSP Expiration DCSP in DCSP HIT!') DCNL DCSP return expired
def __init__(self, d): DCNL DCSP self.signature = d['Signature'] DCNL DCSP self.timestamp = d['Timestamp'] DCNL DCSP self.version = d['Version'] DCNL DCSP assert (d['method'] == NotificationMessage.OPERATION_NAME), ("Method DCSP should DCSP be DCSP '%s'" % NotificationMessage.OPERATION_NAME) DCNL DCSP self.events = [] DCNL DCSP events_dict = {} DCNL DCSP if ('Event' in d): DCNL DCSP  DCSP events_dict = d['Event'] DCNL DCSP else: DCNL DCSP  DCSP for k in d: DCNL DCSP  DCSP  DCSP v = d[k] DCNL DCSP  DCSP  DCSP if k.startswith('Event.'): DCNL DCSP  DCSP  DCSP  DCSP ed = NotificationMessage.EVENT_RE.search(k).groupdict() DCNL DCSP  DCSP  DCSP  DCSP n = int(ed['n']) DCNL DCSP  DCSP  DCSP  DCSP param = str(ed['param']) DCNL DCSP  DCSP  DCSP  DCSP if (n not in events_dict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP events_dict[n] = {} DCNL DCSP  DCSP  DCSP  DCSP events_dict[n][param] = v DCNL DCSP for n in events_dict: DCNL DCSP  DCSP self.events.append(Event(events_dict[n]))
def verify(self, secret_key): DCNL DCSP verification_input = NotificationMessage.SERVICE_NAME DCNL DCSP verification_input += NotificationMessage.OPERATION_NAME DCNL DCSP verification_input += self.timestamp DCNL DCSP h = hmac.new(key=secret_key, digestmod=sha) DCNL DCSP h.update(verification_input) DCNL DCSP signature_calc = base64.b64encode(h.digest()) DCNL DCSP return (self.signature == signature_calc)
def get_all_vpcs(self, vpc_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if vpc_ids: DCNL DCSP  DCSP self.build_list_params(params, vpc_ids, 'VpcId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeVpcs', params, [('item', VPC)])
def create_vpc(self, cidr_block, instance_tenancy=None, dry_run=False): DCNL DCSP params = {'CidrBlock': cidr_block} DCNL DCSP if instance_tenancy: DCNL DCSP  DCSP params['InstanceTenancy'] = instance_tenancy DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateVpc', params, VPC)
def delete_vpc(self, vpc_id, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteVpc', params)
def modify_vpc_attribute(self, vpc_id, enable_dns_support=None, enable_dns_hostnames=None, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id} DCNL DCSP if (enable_dns_support is not None): DCNL DCSP  DCSP if enable_dns_support: DCNL DCSP  DCSP  DCSP params['EnableDnsSupport.Value'] = 'true' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params['EnableDnsSupport.Value'] = 'false' DCNL DCSP if (enable_dns_hostnames is not None): DCNL DCSP  DCSP if enable_dns_hostnames: DCNL DCSP  DCSP  DCSP params['EnableDnsHostnames.Value'] = 'true' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params['EnableDnsHostnames.Value'] = 'false' DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ModifyVpcAttribute', params)
def get_all_route_tables(self, route_table_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if route_table_ids: DCNL DCSP  DCSP self.build_list_params(params, route_table_ids, 'RouteTableId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeRouteTables', params, [('item', RouteTable)])
def associate_route_table(self, route_table_id, subnet_id, dry_run=False): DCNL DCSP params = {'RouteTableId': route_table_id, 'SubnetId': subnet_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP result = self.get_object('AssociateRouteTable', params, ResultSet) DCNL DCSP return result.associationId
def disassociate_route_table(self, association_id, dry_run=False): DCNL DCSP params = {'AssociationId': association_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DisassociateRouteTable', params)
def create_route_table(self, vpc_id, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateRouteTable', params, RouteTable)
def delete_route_table(self, route_table_id, dry_run=False): DCNL DCSP params = {'RouteTableId': route_table_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteRouteTable', params)
def _replace_route_table_association(self, association_id, route_table_id, dry_run=False): DCNL DCSP params = {'AssociationId': association_id, 'RouteTableId': route_table_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('ReplaceRouteTableAssociation', params, ResultSet)
def replace_route_table_assocation(self, association_id, route_table_id, dry_run=False): DCNL DCSP return self._replace_route_table_association(association_id, route_table_id, dry_run=dry_run).status
def replace_route_table_association_with_assoc(self, association_id, route_table_id, dry_run=False): DCNL DCSP return self._replace_route_table_association(association_id, route_table_id, dry_run=dry_run).newAssociationId
def create_route(self, route_table_id, destination_cidr_block, gateway_id=None, instance_id=None, interface_id=None, vpc_peering_connection_id=None, dry_run=False): DCNL DCSP params = {'RouteTableId': route_table_id, 'DestinationCidrBlock': destination_cidr_block} DCNL DCSP if (gateway_id is not None): DCNL DCSP  DCSP params['GatewayId'] = gateway_id DCNL DCSP elif (instance_id is not None): DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP elif (interface_id is not None): DCNL DCSP  DCSP params['NetworkInterfaceId'] = interface_id DCNL DCSP elif (vpc_peering_connection_id is not None): DCNL DCSP  DCSP params['VpcPeeringConnectionId'] = vpc_peering_connection_id DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('CreateRoute', params)
def replace_route(self, route_table_id, destination_cidr_block, gateway_id=None, instance_id=None, interface_id=None, vpc_peering_connection_id=None, dry_run=False): DCNL DCSP params = {'RouteTableId': route_table_id, 'DestinationCidrBlock': destination_cidr_block} DCNL DCSP if (gateway_id is not None): DCNL DCSP  DCSP params['GatewayId'] = gateway_id DCNL DCSP elif (instance_id is not None): DCNL DCSP  DCSP params['InstanceId'] = instance_id DCNL DCSP elif (interface_id is not None): DCNL DCSP  DCSP params['NetworkInterfaceId'] = interface_id DCNL DCSP elif (vpc_peering_connection_id is not None): DCNL DCSP  DCSP params['VpcPeeringConnectionId'] = vpc_peering_connection_id DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('ReplaceRoute', params)
def delete_route(self, route_table_id, destination_cidr_block, dry_run=False): DCNL DCSP params = {'RouteTableId': route_table_id, 'DestinationCidrBlock': destination_cidr_block} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteRoute', params)
def get_all_network_acls(self, network_acl_ids=None, filters=None): DCNL DCSP params = {} DCNL DCSP if network_acl_ids: DCNL DCSP  DCSP self.build_list_params(params, network_acl_ids, 'NetworkAclId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP return self.get_list('DescribeNetworkAcls', params, [('item', NetworkAcl)])
def associate_network_acl(self, network_acl_id, subnet_id): DCNL DCSP acl = self.get_all_network_acls(filters=[('association.subnet-id', subnet_id)])[0] DCNL DCSP association = [association for association in acl.associations if (association.subnet_id == subnet_id)][0] DCNL DCSP params = {'AssociationId': association.id, 'NetworkAclId': network_acl_id} DCNL DCSP result = self.get_object('ReplaceNetworkAclAssociation', params, ResultSet) DCNL DCSP return result.newAssociationId
def disassociate_network_acl(self, subnet_id, vpc_id=None): DCNL DCSP if (not vpc_id): DCNL DCSP  DCSP vpc_id = self.get_all_subnets([subnet_id])[0].vpc_id DCNL DCSP acls = self.get_all_network_acls(filters=[('vpc-id', vpc_id), ('default', 'true')]) DCNL DCSP default_acl_id = acls[0].id DCNL DCSP return self.associate_network_acl(default_acl_id, subnet_id)
def create_network_acl(self, vpc_id): DCNL DCSP params = {'VpcId': vpc_id} DCNL DCSP return self.get_object('CreateNetworkAcl', params, NetworkAcl)
def delete_network_acl(self, network_acl_id): DCNL DCSP params = {'NetworkAclId': network_acl_id} DCNL DCSP return self.get_status('DeleteNetworkAcl', params)
def create_network_acl_entry(self, network_acl_id, rule_number, protocol, rule_action, cidr_block, egress=None, icmp_code=None, icmp_type=None, port_range_from=None, port_range_to=None): DCNL DCSP params = {'NetworkAclId': network_acl_id, 'RuleNumber': rule_number, 'Protocol': protocol, 'RuleAction': rule_action, 'CidrBlock': cidr_block} DCNL DCSP if (egress is not None): DCNL DCSP  DCSP if isinstance(egress, bool): DCNL DCSP  DCSP  DCSP egress = str(egress).lower() DCNL DCSP  DCSP params['Egress'] = egress DCNL DCSP if (icmp_code is not None): DCNL DCSP  DCSP params['Icmp.Code'] = icmp_code DCNL DCSP if (icmp_type is not None): DCNL DCSP  DCSP params['Icmp.Type'] = icmp_type DCNL DCSP if (port_range_from is not None): DCNL DCSP  DCSP params['PortRange.From'] = port_range_from DCNL DCSP if (port_range_to is not None): DCNL DCSP  DCSP params['PortRange.To'] = port_range_to DCNL DCSP return self.get_status('CreateNetworkAclEntry', params)
def replace_network_acl_entry(self, network_acl_id, rule_number, protocol, rule_action, cidr_block, egress=None, icmp_code=None, icmp_type=None, port_range_from=None, port_range_to=None): DCNL DCSP params = {'NetworkAclId': network_acl_id, 'RuleNumber': rule_number, 'Protocol': protocol, 'RuleAction': rule_action, 'CidrBlock': cidr_block} DCNL DCSP if (egress is not None): DCNL DCSP  DCSP if isinstance(egress, bool): DCNL DCSP  DCSP  DCSP egress = str(egress).lower() DCNL DCSP  DCSP params['Egress'] = egress DCNL DCSP if (icmp_code is not None): DCNL DCSP  DCSP params['Icmp.Code'] = icmp_code DCNL DCSP if (icmp_type is not None): DCNL DCSP  DCSP params['Icmp.Type'] = icmp_type DCNL DCSP if (port_range_from is not None): DCNL DCSP  DCSP params['PortRange.From'] = port_range_from DCNL DCSP if (port_range_to is not None): DCNL DCSP  DCSP params['PortRange.To'] = port_range_to DCNL DCSP return self.get_status('ReplaceNetworkAclEntry', params)
def delete_network_acl_entry(self, network_acl_id, rule_number, egress=None): DCNL DCSP params = {'NetworkAclId': network_acl_id, 'RuleNumber': rule_number} DCNL DCSP if (egress is not None): DCNL DCSP  DCSP if isinstance(egress, bool): DCNL DCSP  DCSP  DCSP egress = str(egress).lower() DCNL DCSP  DCSP params['Egress'] = egress DCNL DCSP return self.get_status('DeleteNetworkAclEntry', params)
def get_all_internet_gateways(self, internet_gateway_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if internet_gateway_ids: DCNL DCSP  DCSP self.build_list_params(params, internet_gateway_ids, 'InternetGatewayId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeInternetGateways', params, [('item', InternetGateway)])
def create_internet_gateway(self, dry_run=False): DCNL DCSP params = {} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateInternetGateway', params, InternetGateway)
def delete_internet_gateway(self, internet_gateway_id, dry_run=False): DCNL DCSP params = {'InternetGatewayId': internet_gateway_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteInternetGateway', params)
def attach_internet_gateway(self, internet_gateway_id, vpc_id, dry_run=False): DCNL DCSP params = {'InternetGatewayId': internet_gateway_id, 'VpcId': vpc_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('AttachInternetGateway', params)
def detach_internet_gateway(self, internet_gateway_id, vpc_id, dry_run=False): DCNL DCSP params = {'InternetGatewayId': internet_gateway_id, 'VpcId': vpc_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DetachInternetGateway', params)
def get_all_customer_gateways(self, customer_gateway_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if customer_gateway_ids: DCNL DCSP  DCSP self.build_list_params(params, customer_gateway_ids, 'CustomerGatewayId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeCustomerGateways', params, [('item', CustomerGateway)])
def create_customer_gateway(self, type, ip_address, bgp_asn, dry_run=False): DCNL DCSP params = {'Type': type, 'IpAddress': ip_address, 'BgpAsn': bgp_asn} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateCustomerGateway', params, CustomerGateway)
def delete_customer_gateway(self, customer_gateway_id, dry_run=False): DCNL DCSP params = {'CustomerGatewayId': customer_gateway_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteCustomerGateway', params)
def get_all_vpn_gateways(self, vpn_gateway_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if vpn_gateway_ids: DCNL DCSP  DCSP self.build_list_params(params, vpn_gateway_ids, 'VpnGatewayId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeVpnGateways', params, [('item', VpnGateway)])
def create_vpn_gateway(self, type, availability_zone=None, dry_run=False): DCNL DCSP params = {'Type': type} DCNL DCSP if availability_zone: DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateVpnGateway', params, VpnGateway)
def delete_vpn_gateway(self, vpn_gateway_id, dry_run=False): DCNL DCSP params = {'VpnGatewayId': vpn_gateway_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteVpnGateway', params)
def attach_vpn_gateway(self, vpn_gateway_id, vpc_id, dry_run=False): DCNL DCSP params = {'VpnGatewayId': vpn_gateway_id, 'VpcId': vpc_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('AttachVpnGateway', params, Attachment)
def detach_vpn_gateway(self, vpn_gateway_id, vpc_id, dry_run=False): DCNL DCSP params = {'VpnGatewayId': vpn_gateway_id, 'VpcId': vpc_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DetachVpnGateway', params)
def get_all_subnets(self, subnet_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if subnet_ids: DCNL DCSP  DCSP self.build_list_params(params, subnet_ids, 'SubnetId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeSubnets', params, [('item', Subnet)])
def create_subnet(self, vpc_id, cidr_block, availability_zone=None, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id, 'CidrBlock': cidr_block} DCNL DCSP if availability_zone: DCNL DCSP  DCSP params['AvailabilityZone'] = availability_zone DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateSubnet', params, Subnet)
def delete_subnet(self, subnet_id, dry_run=False): DCNL DCSP params = {'SubnetId': subnet_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteSubnet', params)
def get_all_dhcp_options(self, dhcp_options_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if dhcp_options_ids: DCNL DCSP  DCSP self.build_list_params(params, dhcp_options_ids, 'DhcpOptionsId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeDhcpOptions', params, [('item', DhcpOptions)])
def create_dhcp_options(self, domain_name=None, domain_name_servers=None, ntp_servers=None, netbios_name_servers=None, netbios_node_type=None, dry_run=False): DCNL DCSP key_counter = 1 DCNL DCSP params = {} DCNL DCSP def insert_option(params, name, value): DCNL DCSP  DCSP params[('DhcpConfiguration.%d.Key' % (key_counter,))] = name DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP for (idx, value) in enumerate(value, 1): DCNL DCSP  DCSP  DCSP  DCSP key_name = ('DhcpConfiguration.%d.Value.%d' % (key_counter, idx)) DCNL DCSP  DCSP  DCSP  DCSP params[key_name] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP key_name = ('DhcpConfiguration.%d.Value.1' % (key_counter,)) DCNL DCSP  DCSP  DCSP params[key_name] = value DCNL DCSP  DCSP return (key_counter + 1) DCNL DCSP if domain_name: DCNL DCSP  DCSP key_counter = insert_option(params, 'domain-name', domain_name) DCNL DCSP if domain_name_servers: DCNL DCSP  DCSP key_counter = insert_option(params, 'domain-name-servers', domain_name_servers) DCNL DCSP if ntp_servers: DCNL DCSP  DCSP key_counter = insert_option(params, 'ntp-servers', ntp_servers) DCNL DCSP if netbios_name_servers: DCNL DCSP  DCSP key_counter = insert_option(params, 'netbios-name-servers', netbios_name_servers) DCNL DCSP if netbios_node_type: DCNL DCSP  DCSP key_counter = insert_option(params, 'netbios-node-type', netbios_node_type) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateDhcpOptions', params, DhcpOptions)
def delete_dhcp_options(self, dhcp_options_id, dry_run=False): DCNL DCSP params = {'DhcpOptionsId': dhcp_options_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteDhcpOptions', params)
def associate_dhcp_options(self, dhcp_options_id, vpc_id, dry_run=False): DCNL DCSP params = {'DhcpOptionsId': dhcp_options_id, 'VpcId': vpc_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('AssociateDhcpOptions', params)
def get_all_vpn_connections(self, vpn_connection_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if vpn_connection_ids: DCNL DCSP  DCSP self.build_list_params(params, vpn_connection_ids, 'VpnConnectionId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeVpnConnections', params, [('item', VpnConnection)])
def create_vpn_connection(self, type, customer_gateway_id, vpn_gateway_id, static_routes_only=None, dry_run=False): DCNL DCSP params = {'Type': type, 'CustomerGatewayId': customer_gateway_id, 'VpnGatewayId': vpn_gateway_id} DCNL DCSP if (static_routes_only is not None): DCNL DCSP  DCSP if isinstance(static_routes_only, bool): DCNL DCSP  DCSP  DCSP static_routes_only = str(static_routes_only).lower() DCNL DCSP  DCSP params['Options.StaticRoutesOnly'] = static_routes_only DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateVpnConnection', params, VpnConnection)
def delete_vpn_connection(self, vpn_connection_id, dry_run=False): DCNL DCSP params = {'VpnConnectionId': vpn_connection_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteVpnConnection', params)
def disable_vgw_route_propagation(self, route_table_id, gateway_id, dry_run=False): DCNL DCSP params = {'RouteTableId': route_table_id, 'GatewayId': gateway_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DisableVgwRoutePropagation', params)
def enable_vgw_route_propagation(self, route_table_id, gateway_id, dry_run=False): DCNL DCSP params = {'RouteTableId': route_table_id, 'GatewayId': gateway_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('EnableVgwRoutePropagation', params)
def create_vpn_connection_route(self, destination_cidr_block, vpn_connection_id, dry_run=False): DCNL DCSP params = {'DestinationCidrBlock': destination_cidr_block, 'VpnConnectionId': vpn_connection_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('CreateVpnConnectionRoute', params)
def delete_vpn_connection_route(self, destination_cidr_block, vpn_connection_id, dry_run=False): DCNL DCSP params = {'DestinationCidrBlock': destination_cidr_block, 'VpnConnectionId': vpn_connection_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteVpnConnectionRoute', params)
def get_all_vpc_peering_connections(self, vpc_peering_connection_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if vpc_peering_connection_ids: DCNL DCSP  DCSP self.build_list_params(params, vpc_peering_connection_ids, 'VpcPeeringConnectionId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, dict(filters)) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeVpcPeeringConnections', params, [('item', VpcPeeringConnection)])
def create_vpc_peering_connection(self, vpc_id, peer_vpc_id, peer_owner_id=None, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id, 'PeerVpcId': peer_vpc_id} DCNL DCSP if (peer_owner_id is not None): DCNL DCSP  DCSP params['PeerOwnerId'] = peer_owner_id DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('CreateVpcPeeringConnection', params, VpcPeeringConnection)
def delete_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False): DCNL DCSP params = {'VpcPeeringConnectionId': vpc_peering_connection_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DeleteVpcPeeringConnection', params)
def reject_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False): DCNL DCSP params = {'VpcPeeringConnectionId': vpc_peering_connection_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('RejectVpcPeeringConnection', params)
def accept_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False): DCNL DCSP params = {'VpcPeeringConnectionId': vpc_peering_connection_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_object('AcceptVpcPeeringConnection', params, VpcPeeringConnection)
def get_all_classic_link_vpcs(self, vpc_ids=None, filters=None, dry_run=False): DCNL DCSP params = {} DCNL DCSP if vpc_ids: DCNL DCSP  DCSP self.build_list_params(params, vpc_ids, 'VpcId') DCNL DCSP if filters: DCNL DCSP  DCSP self.build_filter_params(params, filters) DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_list('DescribeVpcClassicLink', params, [('item', VPC)], verb='POST')
def attach_classic_link_vpc(self, vpc_id, instance_id, groups, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id, 'InstanceId': instance_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP l = [] DCNL DCSP for group in groups: DCNL DCSP  DCSP if hasattr(group, 'id'): DCNL DCSP  DCSP  DCSP l.append(group.id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP l.append(group) DCNL DCSP self.build_list_params(params, l, 'SecurityGroupId') DCNL DCSP return self.get_status('AttachClassicLinkVpc', params)
def detach_classic_link_vpc(self, vpc_id, instance_id, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id, 'InstanceId': instance_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DetachClassicLinkVpc', params)
def disable_vpc_classic_link(self, vpc_id, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('DisableVpcClassicLink', params)
def enable_vpc_classic_link(self, vpc_id, dry_run=False): DCNL DCSP params = {'VpcId': vpc_id} DCNL DCSP if dry_run: DCNL DCSP  DCSP params['DryRun'] = 'true' DCNL DCSP return self.get_status('EnableVpcClassicLink', params)
def __init__(self, connection=None): DCNL DCSP super(VPC, self).__init__(connection) DCNL DCSP self.id = None DCNL DCSP self.dhcp_options_id = None DCNL DCSP self.state = None DCNL DCSP self.cidr_block = None DCNL DCSP self.is_default = None DCNL DCSP self.instance_tenancy = None DCNL DCSP self.classic_link_enabled = None
def update_classic_link_enabled(self, validate=False, dry_run=False): DCNL DCSP self._get_status_then_update_vpc(self.connection.get_all_classic_link_vpcs, validate=validate, dry_run=dry_run) DCNL DCSP return self.classic_link_enabled
def disable_classic_link(self, dry_run=False): DCNL DCSP return self.connection.disable_vpc_classic_link(self.id, dry_run=dry_run)
def enable_classic_link(self, dry_run=False): DCNL DCSP return self.connection.enable_vpc_classic_link(self.id, dry_run=dry_run)
def attach_classic_instance(self, instance_id, groups, dry_run=False): DCNL DCSP return self.connection.attach_classic_link_vpc(vpc_id=self.id, instance_id=instance_id, groups=groups, dry_run=dry_run)
def detach_classic_instance(self, instance_id, dry_run=False): DCNL DCSP return self.connection.detach_classic_link_vpc(vpc_id=self.id, instance_id=instance_id, dry_run=dry_run)
def __init__(self): DCNL DCSP self.vpc_id = None DCNL DCSP self.owner_id = None DCNL DCSP self.cidr_block = None
def __init__(self, connection=None): DCNL DCSP super(VpcPeeringConnection, self).__init__(connection) DCNL DCSP self.id = None DCNL DCSP self.accepter_vpc_info = VpcInfo() DCNL DCSP self.requester_vpc_info = VpcInfo() DCNL DCSP self.expiration_time = None DCNL DCSP self._status = VpcPeeringConnectionStatus()
@classmethod DCNL def is_capable(cls, requested_capability): DCNL DCSP for c in requested_capability: DCNL DCSP  DCSP if (c not in cls.capability): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
def get_obj(self, name): DCNL DCSP val = self.get(name) DCNL DCSP if (not val): DCNL DCSP  DCSP return None DCNL DCSP if (name.find('queue') >= 0): DCNL DCSP  DCSP obj = boto.lookup('sqs', val) DCNL DCSP  DCSP if obj: DCNL DCSP  DCSP  DCSP obj.set_message_class(ServiceMessage) DCNL DCSP elif (name.find('bucket') >= 0): DCNL DCSP  DCSP obj = boto.lookup('s3', val) DCNL DCSP elif (name.find('domain') >= 0): DCNL DCSP  DCSP obj = boto.lookup('sdb', val) DCNL DCSP else: DCNL DCSP  DCSP obj = None DCNL DCSP return obj
def check_dns_availability(self, cname_prefix): DCNL DCSP params = {'CNAMEPrefix': cname_prefix} DCNL DCSP return self._get_response('CheckDNSAvailability', params)
def create_application(self, application_name, description=None): DCNL DCSP params = {'ApplicationName': application_name} DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP return self._get_response('CreateApplication', params)
def create_application_version(self, application_name, version_label, description=None, s3_bucket=None, s3_key=None, auto_create_application=None): DCNL DCSP params = {'ApplicationName': application_name, 'VersionLabel': version_label} DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if (s3_bucket and s3_key): DCNL DCSP  DCSP params['SourceBundle.S3Bucket'] = s3_bucket DCNL DCSP  DCSP params['SourceBundle.S3Key'] = s3_key DCNL DCSP if auto_create_application: DCNL DCSP  DCSP params['AutoCreateApplication'] = self._encode_bool(auto_create_application) DCNL DCSP return self._get_response('CreateApplicationVersion', params)
def create_configuration_template(self, application_name, template_name, solution_stack_name=None, source_configuration_application_name=None, source_configuration_template_name=None, environment_id=None, description=None, option_settings=None): DCNL DCSP params = {'ApplicationName': application_name, 'TemplateName': template_name} DCNL DCSP if solution_stack_name: DCNL DCSP  DCSP params['SolutionStackName'] = solution_stack_name DCNL DCSP if source_configuration_application_name: DCNL DCSP  DCSP params['SourceConfiguration.ApplicationName'] = source_configuration_application_name DCNL DCSP if source_configuration_template_name: DCNL DCSP  DCSP params['SourceConfiguration.TemplateName'] = source_configuration_template_name DCNL DCSP if environment_id: DCNL DCSP  DCSP params['EnvironmentId'] = environment_id DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if option_settings: DCNL DCSP  DCSP self._build_list_params(params, option_settings, 'OptionSettings.member', ('Namespace', 'OptionName', 'Value')) DCNL DCSP return self._get_response('CreateConfigurationTemplate', params)
def create_environment(self, application_name, environment_name, version_label=None, template_name=None, solution_stack_name=None, cname_prefix=None, description=None, option_settings=None, options_to_remove=None, tier_name=None, tier_type=None, tier_version='1.0'): DCNL DCSP params = {'ApplicationName': application_name, 'EnvironmentName': environment_name} DCNL DCSP if version_label: DCNL DCSP  DCSP params['VersionLabel'] = version_label DCNL DCSP if template_name: DCNL DCSP  DCSP params['TemplateName'] = template_name DCNL DCSP if solution_stack_name: DCNL DCSP  DCSP params['SolutionStackName'] = solution_stack_name DCNL DCSP if cname_prefix: DCNL DCSP  DCSP params['CNAMEPrefix'] = cname_prefix DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if option_settings: DCNL DCSP  DCSP self._build_list_params(params, option_settings, 'OptionSettings.member', ('Namespace', 'OptionName', 'Value')) DCNL DCSP if options_to_remove: DCNL DCSP  DCSP self.build_list_params(params, options_to_remove, 'OptionsToRemove.member') DCNL DCSP if (tier_name and tier_type and tier_version): DCNL DCSP  DCSP params['Tier.Name'] = tier_name DCNL DCSP  DCSP params['Tier.Type'] = tier_type DCNL DCSP  DCSP params['Tier.Version'] = tier_version DCNL DCSP return self._get_response('CreateEnvironment', params)
def create_storage_location(self): DCNL DCSP return self._get_response('CreateStorageLocation', params={})
def delete_application(self, application_name, terminate_env_by_force=None): DCNL DCSP params = {'ApplicationName': application_name} DCNL DCSP if terminate_env_by_force: DCNL DCSP  DCSP params['TerminateEnvByForce'] = self._encode_bool(terminate_env_by_force) DCNL DCSP return self._get_response('DeleteApplication', params)
def delete_application_version(self, application_name, version_label, delete_source_bundle=None): DCNL DCSP params = {'ApplicationName': application_name, 'VersionLabel': version_label} DCNL DCSP if delete_source_bundle: DCNL DCSP  DCSP params['DeleteSourceBundle'] = self._encode_bool(delete_source_bundle) DCNL DCSP return self._get_response('DeleteApplicationVersion', params)
def delete_configuration_template(self, application_name, template_name): DCNL DCSP params = {'ApplicationName': application_name, 'TemplateName': template_name} DCNL DCSP return self._get_response('DeleteConfigurationTemplate', params)
def delete_environment_configuration(self, application_name, environment_name): DCNL DCSP params = {'ApplicationName': application_name, 'EnvironmentName': environment_name} DCNL DCSP return self._get_response('DeleteEnvironmentConfiguration', params)
def describe_application_versions(self, application_name=None, version_labels=None): DCNL DCSP params = {} DCNL DCSP if application_name: DCNL DCSP  DCSP params['ApplicationName'] = application_name DCNL DCSP if version_labels: DCNL DCSP  DCSP self.build_list_params(params, version_labels, 'VersionLabels.member') DCNL DCSP return self._get_response('DescribeApplicationVersions', params)
def describe_applications(self, application_names=None): DCNL DCSP params = {} DCNL DCSP if application_names: DCNL DCSP  DCSP self.build_list_params(params, application_names, 'ApplicationNames.member') DCNL DCSP return self._get_response('DescribeApplications', params)
def describe_configuration_options(self, application_name=None, template_name=None, environment_name=None, solution_stack_name=None, options=None): DCNL DCSP params = {} DCNL DCSP if application_name: DCNL DCSP  DCSP params['ApplicationName'] = application_name DCNL DCSP if template_name: DCNL DCSP  DCSP params['TemplateName'] = template_name DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP if solution_stack_name: DCNL DCSP  DCSP params['SolutionStackName'] = solution_stack_name DCNL DCSP if options: DCNL DCSP  DCSP self.build_list_params(params, options, 'Options.member') DCNL DCSP return self._get_response('DescribeConfigurationOptions', params)
def describe_configuration_settings(self, application_name, template_name=None, environment_name=None): DCNL DCSP params = {'ApplicationName': application_name} DCNL DCSP if template_name: DCNL DCSP  DCSP params['TemplateName'] = template_name DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP return self._get_response('DescribeConfigurationSettings', params)
def describe_environment_resources(self, environment_id=None, environment_name=None): DCNL DCSP params = {} DCNL DCSP if environment_id: DCNL DCSP  DCSP params['EnvironmentId'] = environment_id DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP return self._get_response('DescribeEnvironmentResources', params)
def describe_environments(self, application_name=None, version_label=None, environment_ids=None, environment_names=None, include_deleted=None, included_deleted_back_to=None): DCNL DCSP params = {} DCNL DCSP if application_name: DCNL DCSP  DCSP params['ApplicationName'] = application_name DCNL DCSP if version_label: DCNL DCSP  DCSP params['VersionLabel'] = version_label DCNL DCSP if environment_ids: DCNL DCSP  DCSP self.build_list_params(params, environment_ids, 'EnvironmentIds.member') DCNL DCSP if environment_names: DCNL DCSP  DCSP self.build_list_params(params, environment_names, 'EnvironmentNames.member') DCNL DCSP if include_deleted: DCNL DCSP  DCSP params['IncludeDeleted'] = self._encode_bool(include_deleted) DCNL DCSP if included_deleted_back_to: DCNL DCSP  DCSP params['IncludedDeletedBackTo'] = included_deleted_back_to DCNL DCSP return self._get_response('DescribeEnvironments', params)
def describe_events(self, application_name=None, version_label=None, template_name=None, environment_id=None, environment_name=None, request_id=None, severity=None, start_time=None, end_time=None, max_records=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if application_name: DCNL DCSP  DCSP params['ApplicationName'] = application_name DCNL DCSP if version_label: DCNL DCSP  DCSP params['VersionLabel'] = version_label DCNL DCSP if template_name: DCNL DCSP  DCSP params['TemplateName'] = template_name DCNL DCSP if environment_id: DCNL DCSP  DCSP params['EnvironmentId'] = environment_id DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP if request_id: DCNL DCSP  DCSP params['RequestId'] = request_id DCNL DCSP if severity: DCNL DCSP  DCSP params['Severity'] = severity DCNL DCSP if start_time: DCNL DCSP  DCSP params['StartTime'] = start_time DCNL DCSP if end_time: DCNL DCSP  DCSP params['EndTime'] = end_time DCNL DCSP if max_records: DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self._get_response('DescribeEvents', params)
def list_available_solution_stacks(self): DCNL DCSP return self._get_response('ListAvailableSolutionStacks', params={})
def rebuild_environment(self, environment_id=None, environment_name=None): DCNL DCSP params = {} DCNL DCSP if environment_id: DCNL DCSP  DCSP params['EnvironmentId'] = environment_id DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP return self._get_response('RebuildEnvironment', params)
def request_environment_info(self, info_type='tail', environment_id=None, environment_name=None): DCNL DCSP params = {'InfoType': info_type} DCNL DCSP if environment_id: DCNL DCSP  DCSP params['EnvironmentId'] = environment_id DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP return self._get_response('RequestEnvironmentInfo', params)
def restart_app_server(self, environment_id=None, environment_name=None): DCNL DCSP params = {} DCNL DCSP if environment_id: DCNL DCSP  DCSP params['EnvironmentId'] = environment_id DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP return self._get_response('RestartAppServer', params)
def retrieve_environment_info(self, info_type='tail', environment_id=None, environment_name=None): DCNL DCSP params = {'InfoType': info_type} DCNL DCSP if environment_id: DCNL DCSP  DCSP params['EnvironmentId'] = environment_id DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP return self._get_response('RetrieveEnvironmentInfo', params)
def swap_environment_cnames(self, source_environment_id=None, source_environment_name=None, destination_environment_id=None, destination_environment_name=None): DCNL DCSP params = {} DCNL DCSP if source_environment_id: DCNL DCSP  DCSP params['SourceEnvironmentId'] = source_environment_id DCNL DCSP if source_environment_name: DCNL DCSP  DCSP params['SourceEnvironmentName'] = source_environment_name DCNL DCSP if destination_environment_id: DCNL DCSP  DCSP params['DestinationEnvironmentId'] = destination_environment_id DCNL DCSP if destination_environment_name: DCNL DCSP  DCSP params['DestinationEnvironmentName'] = destination_environment_name DCNL DCSP return self._get_response('SwapEnvironmentCNAMEs', params)
def terminate_environment(self, environment_id=None, environment_name=None, terminate_resources=None): DCNL DCSP params = {} DCNL DCSP if environment_id: DCNL DCSP  DCSP params['EnvironmentId'] = environment_id DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP if terminate_resources: DCNL DCSP  DCSP params['TerminateResources'] = self._encode_bool(terminate_resources) DCNL DCSP return self._get_response('TerminateEnvironment', params)
def update_application(self, application_name, description=None): DCNL DCSP params = {'ApplicationName': application_name} DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP return self._get_response('UpdateApplication', params)
def update_application_version(self, application_name, version_label, description=None): DCNL DCSP params = {'ApplicationName': application_name, 'VersionLabel': version_label} DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP return self._get_response('UpdateApplicationVersion', params)
def update_configuration_template(self, application_name, template_name, description=None, option_settings=None, options_to_remove=None): DCNL DCSP params = {'ApplicationName': application_name, 'TemplateName': template_name} DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if option_settings: DCNL DCSP  DCSP self._build_list_params(params, option_settings, 'OptionSettings.member', ('Namespace', 'OptionName', 'Value')) DCNL DCSP if options_to_remove: DCNL DCSP  DCSP self.build_list_params(params, options_to_remove, 'OptionsToRemove.member') DCNL DCSP return self._get_response('UpdateConfigurationTemplate', params)
def update_environment(self, environment_id=None, environment_name=None, version_label=None, template_name=None, description=None, option_settings=None, options_to_remove=None, tier_name=None, tier_type=None, tier_version='1.0'): DCNL DCSP params = {} DCNL DCSP if environment_id: DCNL DCSP  DCSP params['EnvironmentId'] = environment_id DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP if version_label: DCNL DCSP  DCSP params['VersionLabel'] = version_label DCNL DCSP if template_name: DCNL DCSP  DCSP params['TemplateName'] = template_name DCNL DCSP if description: DCNL DCSP  DCSP params['Description'] = description DCNL DCSP if option_settings: DCNL DCSP  DCSP self._build_list_params(params, option_settings, 'OptionSettings.member', ('Namespace', 'OptionName', 'Value')) DCNL DCSP if options_to_remove: DCNL DCSP  DCSP self.build_list_params(params, options_to_remove, 'OptionsToRemove.member') DCNL DCSP if (tier_name and tier_type and tier_version): DCNL DCSP  DCSP params['Tier.Name'] = tier_name DCNL DCSP  DCSP params['Tier.Type'] = tier_type DCNL DCSP  DCSP params['Tier.Version'] = tier_version DCNL DCSP return self._get_response('UpdateEnvironment', params)
def validate_configuration_settings(self, application_name, option_settings, template_name=None, environment_name=None): DCNL DCSP params = {'ApplicationName': application_name} DCNL DCSP self._build_list_params(params, option_settings, 'OptionSettings.member', ('Namespace', 'OptionName', 'Value')) DCNL DCSP if template_name: DCNL DCSP  DCSP params['TemplateName'] = template_name DCNL DCSP if environment_name: DCNL DCSP  DCSP params['EnvironmentName'] = environment_name DCNL DCSP return self._get_response('ValidateConfigurationSettings', params)
def create_hapg(self, label): DCNL DCSP params = {'Label': label} DCNL DCSP return self.make_request(action='CreateHapg', body=json.dumps(params))
def create_hsm(self, subnet_id, ssh_key, iam_role_arn, subscription_type, eni_ip=None, external_id=None, client_token=None, syslog_ip=None): DCNL DCSP params = {'SubnetId': subnet_id, 'SshKey': ssh_key, 'IamRoleArn': iam_role_arn, 'SubscriptionType': subscription_type} DCNL DCSP if (eni_ip is not None): DCNL DCSP  DCSP params['EniIp'] = eni_ip DCNL DCSP if (external_id is not None): DCNL DCSP  DCSP params['ExternalId'] = external_id DCNL DCSP if (client_token is not None): DCNL DCSP  DCSP params['ClientToken'] = client_token DCNL DCSP if (syslog_ip is not None): DCNL DCSP  DCSP params['SyslogIp'] = syslog_ip DCNL DCSP return self.make_request(action='CreateHsm', body=json.dumps(params))
def create_luna_client(self, certificate, label=None): DCNL DCSP params = {'Certificate': certificate} DCNL DCSP if (label is not None): DCNL DCSP  DCSP params['Label'] = label DCNL DCSP return self.make_request(action='CreateLunaClient', body=json.dumps(params))
def delete_hapg(self, hapg_arn): DCNL DCSP params = {'HapgArn': hapg_arn} DCNL DCSP return self.make_request(action='DeleteHapg', body=json.dumps(params))
def delete_hsm(self, hsm_arn): DCNL DCSP params = {'HsmArn': hsm_arn} DCNL DCSP return self.make_request(action='DeleteHsm', body=json.dumps(params))
def delete_luna_client(self, client_arn): DCNL DCSP params = {'ClientArn': client_arn} DCNL DCSP return self.make_request(action='DeleteLunaClient', body=json.dumps(params))
def describe_hapg(self, hapg_arn): DCNL DCSP params = {'HapgArn': hapg_arn} DCNL DCSP return self.make_request(action='DescribeHapg', body=json.dumps(params))
def describe_hsm(self, hsm_arn=None, hsm_serial_number=None): DCNL DCSP params = {} DCNL DCSP if (hsm_arn is not None): DCNL DCSP  DCSP params['HsmArn'] = hsm_arn DCNL DCSP if (hsm_serial_number is not None): DCNL DCSP  DCSP params['HsmSerialNumber'] = hsm_serial_number DCNL DCSP return self.make_request(action='DescribeHsm', body=json.dumps(params))
def describe_luna_client(self, client_arn=None, certificate_fingerprint=None): DCNL DCSP params = {} DCNL DCSP if (client_arn is not None): DCNL DCSP  DCSP params['ClientArn'] = client_arn DCNL DCSP if (certificate_fingerprint is not None): DCNL DCSP  DCSP params['CertificateFingerprint'] = certificate_fingerprint DCNL DCSP return self.make_request(action='DescribeLunaClient', body=json.dumps(params))
def get_config(self, client_arn, client_version, hapg_list): DCNL DCSP params = {'ClientArn': client_arn, 'ClientVersion': client_version, 'HapgList': hapg_list} DCNL DCSP return self.make_request(action='GetConfig', body=json.dumps(params))
def list_available_zones(self): DCNL DCSP params = {} DCNL DCSP return self.make_request(action='ListAvailableZones', body=json.dumps(params))
def list_hapgs(self, next_token=None): DCNL DCSP params = {} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.make_request(action='ListHapgs', body=json.dumps(params))
def list_hsms(self, next_token=None): DCNL DCSP params = {} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.make_request(action='ListHsms', body=json.dumps(params))
def list_luna_clients(self, next_token=None): DCNL DCSP params = {} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self.make_request(action='ListLunaClients', body=json.dumps(params))
def modify_hapg(self, hapg_arn, label=None, partition_serial_list=None): DCNL DCSP params = {'HapgArn': hapg_arn} DCNL DCSP if (label is not None): DCNL DCSP  DCSP params['Label'] = label DCNL DCSP if (partition_serial_list is not None): DCNL DCSP  DCSP params['PartitionSerialList'] = partition_serial_list DCNL DCSP return self.make_request(action='ModifyHapg', body=json.dumps(params))
def modify_hsm(self, hsm_arn, subnet_id=None, eni_ip=None, iam_role_arn=None, external_id=None, syslog_ip=None): DCNL DCSP params = {'HsmArn': hsm_arn} DCNL DCSP if (subnet_id is not None): DCNL DCSP  DCSP params['SubnetId'] = subnet_id DCNL DCSP if (eni_ip is not None): DCNL DCSP  DCSP params['EniIp'] = eni_ip DCNL DCSP if (iam_role_arn is not None): DCNL DCSP  DCSP params['IamRoleArn'] = iam_role_arn DCNL DCSP if (external_id is not None): DCNL DCSP  DCSP params['ExternalId'] = external_id DCNL DCSP if (syslog_ip is not None): DCNL DCSP  DCSP params['SyslogIp'] = syslog_ip DCNL DCSP return self.make_request(action='ModifyHsm', body=json.dumps(params))
def modify_luna_client(self, client_arn, certificate): DCNL DCSP params = {'ClientArn': client_arn, 'Certificate': certificate} DCNL DCSP return self.make_request(action='ModifyLunaClient', body=json.dumps(params))
def authorize_cache_security_group_ingress(self, cache_security_group_name, ec2_security_group_name, ec2_security_group_owner_id): DCNL DCSP params = {'CacheSecurityGroupName': cache_security_group_name, 'EC2SecurityGroupName': ec2_security_group_name, 'EC2SecurityGroupOwnerId': ec2_security_group_owner_id} DCNL DCSP return self._make_request(action='AuthorizeCacheSecurityGroupIngress', verb='POST', path='/', params=params)
def create_cache_cluster(self, cache_cluster_id, num_cache_nodes=None, cache_node_type=None, engine=None, replication_group_id=None, engine_version=None, cache_parameter_group_name=None, cache_subnet_group_name=None, cache_security_group_names=None, security_group_ids=None, snapshot_arns=None, preferred_availability_zone=None, preferred_maintenance_window=None, port=None, notification_topic_arn=None, auto_minor_version_upgrade=None): DCNL DCSP params = {'CacheClusterId': cache_cluster_id} DCNL DCSP if (num_cache_nodes is not None): DCNL DCSP  DCSP params['NumCacheNodes'] = num_cache_nodes DCNL DCSP if (cache_node_type is not None): DCNL DCSP  DCSP params['CacheNodeType'] = cache_node_type DCNL DCSP if (engine is not None): DCNL DCSP  DCSP params['Engine'] = engine DCNL DCSP if (replication_group_id is not None): DCNL DCSP  DCSP params['ReplicationGroupId'] = replication_group_id DCNL DCSP if (engine_version is not None): DCNL DCSP  DCSP params['EngineVersion'] = engine_version DCNL DCSP if (cache_parameter_group_name is not None): DCNL DCSP  DCSP params['CacheParameterGroupName'] = cache_parameter_group_name DCNL DCSP if (cache_subnet_group_name is not None): DCNL DCSP  DCSP params['CacheSubnetGroupName'] = cache_subnet_group_name DCNL DCSP if (cache_security_group_names is not None): DCNL DCSP  DCSP self.build_list_params(params, cache_security_group_names, 'CacheSecurityGroupNames.member') DCNL DCSP if (security_group_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, security_group_ids, 'SecurityGroupIds.member') DCNL DCSP if (snapshot_arns is not None): DCNL DCSP  DCSP self.build_list_params(params, snapshot_arns, 'SnapshotArns.member') DCNL DCSP if (preferred_availability_zone is not None): DCNL DCSP  DCSP params['PreferredAvailabilityZone'] = preferred_availability_zone DCNL DCSP if (preferred_maintenance_window is not None): DCNL DCSP  DCSP params['PreferredMaintenanceWindow'] = preferred_maintenance_window DCNL DCSP if (port is not None): DCNL DCSP  DCSP params['Port'] = port DCNL DCSP if (notification_topic_arn is not None): DCNL DCSP  DCSP params['NotificationTopicArn'] = notification_topic_arn DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower() DCNL DCSP return self._make_request(action='CreateCacheCluster', verb='POST', path='/', params=params)
def create_cache_parameter_group(self, cache_parameter_group_name, cache_parameter_group_family, description): DCNL DCSP params = {'CacheParameterGroupName': cache_parameter_group_name, 'CacheParameterGroupFamily': cache_parameter_group_family, 'Description': description} DCNL DCSP return self._make_request(action='CreateCacheParameterGroup', verb='POST', path='/', params=params)
def create_cache_security_group(self, cache_security_group_name, description): DCNL DCSP params = {'CacheSecurityGroupName': cache_security_group_name, 'Description': description} DCNL DCSP return self._make_request(action='CreateCacheSecurityGroup', verb='POST', path='/', params=params)
def create_cache_subnet_group(self, cache_subnet_group_name, cache_subnet_group_description, subnet_ids): DCNL DCSP params = {'CacheSubnetGroupName': cache_subnet_group_name, 'CacheSubnetGroupDescription': cache_subnet_group_description} DCNL DCSP self.build_list_params(params, subnet_ids, 'SubnetIds.member') DCNL DCSP return self._make_request(action='CreateCacheSubnetGroup', verb='POST', path='/', params=params)
def create_replication_group(self, replication_group_id, primary_cluster_id, replication_group_description): DCNL DCSP params = {'ReplicationGroupId': replication_group_id, 'PrimaryClusterId': primary_cluster_id, 'ReplicationGroupDescription': replication_group_description} DCNL DCSP return self._make_request(action='CreateReplicationGroup', verb='POST', path='/', params=params)
def delete_cache_cluster(self, cache_cluster_id): DCNL DCSP params = {'CacheClusterId': cache_cluster_id} DCNL DCSP return self._make_request(action='DeleteCacheCluster', verb='POST', path='/', params=params)
def delete_cache_parameter_group(self, cache_parameter_group_name): DCNL DCSP params = {'CacheParameterGroupName': cache_parameter_group_name} DCNL DCSP return self._make_request(action='DeleteCacheParameterGroup', verb='POST', path='/', params=params)
def delete_cache_security_group(self, cache_security_group_name): DCNL DCSP params = {'CacheSecurityGroupName': cache_security_group_name} DCNL DCSP return self._make_request(action='DeleteCacheSecurityGroup', verb='POST', path='/', params=params)
def delete_cache_subnet_group(self, cache_subnet_group_name): DCNL DCSP params = {'CacheSubnetGroupName': cache_subnet_group_name} DCNL DCSP return self._make_request(action='DeleteCacheSubnetGroup', verb='POST', path='/', params=params)
def delete_replication_group(self, replication_group_id): DCNL DCSP params = {'ReplicationGroupId': replication_group_id} DCNL DCSP return self._make_request(action='DeleteReplicationGroup', verb='POST', path='/', params=params)
def describe_cache_clusters(self, cache_cluster_id=None, max_records=None, marker=None, show_cache_node_info=None): DCNL DCSP params = {} DCNL DCSP if (cache_cluster_id is not None): DCNL DCSP  DCSP params['CacheClusterId'] = cache_cluster_id DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (show_cache_node_info is not None): DCNL DCSP  DCSP params['ShowCacheNodeInfo'] = str(show_cache_node_info).lower() DCNL DCSP return self._make_request(action='DescribeCacheClusters', verb='POST', path='/', params=params)
def describe_cache_engine_versions(self, engine=None, engine_version=None, cache_parameter_group_family=None, max_records=None, marker=None, default_only=None): DCNL DCSP params = {} DCNL DCSP if (engine is not None): DCNL DCSP  DCSP params['Engine'] = engine DCNL DCSP if (engine_version is not None): DCNL DCSP  DCSP params['EngineVersion'] = engine_version DCNL DCSP if (cache_parameter_group_family is not None): DCNL DCSP  DCSP params['CacheParameterGroupFamily'] = cache_parameter_group_family DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if (default_only is not None): DCNL DCSP  DCSP params['DefaultOnly'] = str(default_only).lower() DCNL DCSP return self._make_request(action='DescribeCacheEngineVersions', verb='POST', path='/', params=params)
def describe_cache_parameter_groups(self, cache_parameter_group_name=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (cache_parameter_group_name is not None): DCNL DCSP  DCSP params['CacheParameterGroupName'] = cache_parameter_group_name DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeCacheParameterGroups', verb='POST', path='/', params=params)
def describe_cache_parameters(self, cache_parameter_group_name, source=None, max_records=None, marker=None): DCNL DCSP params = {'CacheParameterGroupName': cache_parameter_group_name} DCNL DCSP if (source is not None): DCNL DCSP  DCSP params['Source'] = source DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeCacheParameters', verb='POST', path='/', params=params)
def describe_cache_security_groups(self, cache_security_group_name=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (cache_security_group_name is not None): DCNL DCSP  DCSP params['CacheSecurityGroupName'] = cache_security_group_name DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeCacheSecurityGroups', verb='POST', path='/', params=params)
def describe_cache_subnet_groups(self, cache_subnet_group_name=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (cache_subnet_group_name is not None): DCNL DCSP  DCSP params['CacheSubnetGroupName'] = cache_subnet_group_name DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeCacheSubnetGroups', verb='POST', path='/', params=params)
def describe_engine_default_parameters(self, cache_parameter_group_family, max_records=None, marker=None): DCNL DCSP params = {'CacheParameterGroupFamily': cache_parameter_group_family} DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeEngineDefaultParameters', verb='POST', path='/', params=params)
def describe_events(self, source_identifier=None, source_type=None, start_time=None, end_time=None, duration=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (source_identifier is not None): DCNL DCSP  DCSP params['SourceIdentifier'] = source_identifier DCNL DCSP if (source_type is not None): DCNL DCSP  DCSP params['SourceType'] = source_type DCNL DCSP if (start_time is not None): DCNL DCSP  DCSP params['StartTime'] = start_time DCNL DCSP if (end_time is not None): DCNL DCSP  DCSP params['EndTime'] = end_time DCNL DCSP if (duration is not None): DCNL DCSP  DCSP params['Duration'] = duration DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeEvents', verb='POST', path='/', params=params)
def describe_replication_groups(self, replication_group_id=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (replication_group_id is not None): DCNL DCSP  DCSP params['ReplicationGroupId'] = replication_group_id DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeReplicationGroups', verb='POST', path='/', params=params)
def describe_reserved_cache_nodes(self, reserved_cache_node_id=None, reserved_cache_nodes_offering_id=None, cache_node_type=None, duration=None, product_description=None, offering_type=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (reserved_cache_node_id is not None): DCNL DCSP  DCSP params['ReservedCacheNodeId'] = reserved_cache_node_id DCNL DCSP if (reserved_cache_nodes_offering_id is not None): DCNL DCSP  DCSP params['ReservedCacheNodesOfferingId'] = reserved_cache_nodes_offering_id DCNL DCSP if (cache_node_type is not None): DCNL DCSP  DCSP params['CacheNodeType'] = cache_node_type DCNL DCSP if (duration is not None): DCNL DCSP  DCSP params['Duration'] = duration DCNL DCSP if (product_description is not None): DCNL DCSP  DCSP params['ProductDescription'] = product_description DCNL DCSP if (offering_type is not None): DCNL DCSP  DCSP params['OfferingType'] = offering_type DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeReservedCacheNodes', verb='POST', path='/', params=params)
def describe_reserved_cache_nodes_offerings(self, reserved_cache_nodes_offering_id=None, cache_node_type=None, duration=None, product_description=None, offering_type=None, max_records=None, marker=None): DCNL DCSP params = {} DCNL DCSP if (reserved_cache_nodes_offering_id is not None): DCNL DCSP  DCSP params['ReservedCacheNodesOfferingId'] = reserved_cache_nodes_offering_id DCNL DCSP if (cache_node_type is not None): DCNL DCSP  DCSP params['CacheNodeType'] = cache_node_type DCNL DCSP if (duration is not None): DCNL DCSP  DCSP params['Duration'] = duration DCNL DCSP if (product_description is not None): DCNL DCSP  DCSP params['ProductDescription'] = product_description DCNL DCSP if (offering_type is not None): DCNL DCSP  DCSP params['OfferingType'] = offering_type DCNL DCSP if (max_records is not None): DCNL DCSP  DCSP params['MaxRecords'] = max_records DCNL DCSP if (marker is not None): DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self._make_request(action='DescribeReservedCacheNodesOfferings', verb='POST', path='/', params=params)
def modify_cache_cluster(self, cache_cluster_id, num_cache_nodes=None, cache_node_ids_to_remove=None, cache_security_group_names=None, security_group_ids=None, preferred_maintenance_window=None, notification_topic_arn=None, cache_parameter_group_name=None, notification_topic_status=None, apply_immediately=None, engine_version=None, auto_minor_version_upgrade=None): DCNL DCSP params = {'CacheClusterId': cache_cluster_id} DCNL DCSP if (num_cache_nodes is not None): DCNL DCSP  DCSP params['NumCacheNodes'] = num_cache_nodes DCNL DCSP if (cache_node_ids_to_remove is not None): DCNL DCSP  DCSP self.build_list_params(params, cache_node_ids_to_remove, 'CacheNodeIdsToRemove.member') DCNL DCSP if (cache_security_group_names is not None): DCNL DCSP  DCSP self.build_list_params(params, cache_security_group_names, 'CacheSecurityGroupNames.member') DCNL DCSP if (security_group_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, security_group_ids, 'SecurityGroupIds.member') DCNL DCSP if (preferred_maintenance_window is not None): DCNL DCSP  DCSP params['PreferredMaintenanceWindow'] = preferred_maintenance_window DCNL DCSP if (notification_topic_arn is not None): DCNL DCSP  DCSP params['NotificationTopicArn'] = notification_topic_arn DCNL DCSP if (cache_parameter_group_name is not None): DCNL DCSP  DCSP params['CacheParameterGroupName'] = cache_parameter_group_name DCNL DCSP if (notification_topic_status is not None): DCNL DCSP  DCSP params['NotificationTopicStatus'] = notification_topic_status DCNL DCSP if (apply_immediately is not None): DCNL DCSP  DCSP params['ApplyImmediately'] = str(apply_immediately).lower() DCNL DCSP if (engine_version is not None): DCNL DCSP  DCSP params['EngineVersion'] = engine_version DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower() DCNL DCSP return self._make_request(action='ModifyCacheCluster', verb='POST', path='/', params=params)
def modify_cache_parameter_group(self, cache_parameter_group_name, parameter_name_values): DCNL DCSP params = {'CacheParameterGroupName': cache_parameter_group_name} DCNL DCSP self.build_complex_list_params(params, parameter_name_values, 'ParameterNameValues.member', ('ParameterName', 'ParameterValue')) DCNL DCSP return self._make_request(action='ModifyCacheParameterGroup', verb='POST', path='/', params=params)
def modify_cache_subnet_group(self, cache_subnet_group_name, cache_subnet_group_description=None, subnet_ids=None): DCNL DCSP params = {'CacheSubnetGroupName': cache_subnet_group_name} DCNL DCSP if (cache_subnet_group_description is not None): DCNL DCSP  DCSP params['CacheSubnetGroupDescription'] = cache_subnet_group_description DCNL DCSP if (subnet_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, subnet_ids, 'SubnetIds.member') DCNL DCSP return self._make_request(action='ModifyCacheSubnetGroup', verb='POST', path='/', params=params)
def modify_replication_group(self, replication_group_id, replication_group_description=None, cache_security_group_names=None, security_group_ids=None, preferred_maintenance_window=None, notification_topic_arn=None, cache_parameter_group_name=None, notification_topic_status=None, apply_immediately=None, engine_version=None, auto_minor_version_upgrade=None, primary_cluster_id=None): DCNL DCSP params = {'ReplicationGroupId': replication_group_id} DCNL DCSP if (replication_group_description is not None): DCNL DCSP  DCSP params['ReplicationGroupDescription'] = replication_group_description DCNL DCSP if (cache_security_group_names is not None): DCNL DCSP  DCSP self.build_list_params(params, cache_security_group_names, 'CacheSecurityGroupNames.member') DCNL DCSP if (security_group_ids is not None): DCNL DCSP  DCSP self.build_list_params(params, security_group_ids, 'SecurityGroupIds.member') DCNL DCSP if (preferred_maintenance_window is not None): DCNL DCSP  DCSP params['PreferredMaintenanceWindow'] = preferred_maintenance_window DCNL DCSP if (notification_topic_arn is not None): DCNL DCSP  DCSP params['NotificationTopicArn'] = notification_topic_arn DCNL DCSP if (cache_parameter_group_name is not None): DCNL DCSP  DCSP params['CacheParameterGroupName'] = cache_parameter_group_name DCNL DCSP if (notification_topic_status is not None): DCNL DCSP  DCSP params['NotificationTopicStatus'] = notification_topic_status DCNL DCSP if (apply_immediately is not None): DCNL DCSP  DCSP params['ApplyImmediately'] = str(apply_immediately).lower() DCNL DCSP if (engine_version is not None): DCNL DCSP  DCSP params['EngineVersion'] = engine_version DCNL DCSP if (auto_minor_version_upgrade is not None): DCNL DCSP  DCSP params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower() DCNL DCSP if (primary_cluster_id is not None): DCNL DCSP  DCSP params['PrimaryClusterId'] = primary_cluster_id DCNL DCSP return self._make_request(action='ModifyReplicationGroup', verb='POST', path='/', params=params)
def purchase_reserved_cache_nodes_offering(self, reserved_cache_nodes_offering_id, reserved_cache_node_id=None, cache_node_count=None): DCNL DCSP params = {'ReservedCacheNodesOfferingId': reserved_cache_nodes_offering_id} DCNL DCSP if (reserved_cache_node_id is not None): DCNL DCSP  DCSP params['ReservedCacheNodeId'] = reserved_cache_node_id DCNL DCSP if (cache_node_count is not None): DCNL DCSP  DCSP params['CacheNodeCount'] = cache_node_count DCNL DCSP return self._make_request(action='PurchaseReservedCacheNodesOffering', verb='POST', path='/', params=params)
def reboot_cache_cluster(self, cache_cluster_id, cache_node_ids_to_reboot): DCNL DCSP params = {'CacheClusterId': cache_cluster_id} DCNL DCSP self.build_list_params(params, cache_node_ids_to_reboot, 'CacheNodeIdsToReboot.member') DCNL DCSP return self._make_request(action='RebootCacheCluster', verb='POST', path='/', params=params)
def reset_cache_parameter_group(self, cache_parameter_group_name, parameter_name_values, reset_all_parameters=None): DCNL DCSP params = {'CacheParameterGroupName': cache_parameter_group_name} DCNL DCSP self.build_complex_list_params(params, parameter_name_values, 'ParameterNameValues.member', ('ParameterName', 'ParameterValue')) DCNL DCSP if (reset_all_parameters is not None): DCNL DCSP  DCSP params['ResetAllParameters'] = str(reset_all_parameters).lower() DCNL DCSP return self._make_request(action='ResetCacheParameterGroup', verb='POST', path='/', params=params)
def revoke_cache_security_group_ingress(self, cache_security_group_name, ec2_security_group_name, ec2_security_group_owner_id): DCNL DCSP params = {'CacheSecurityGroupName': cache_security_group_name, 'EC2SecurityGroupName': ec2_security_group_name, 'EC2SecurityGroupOwnerId': ec2_security_group_owner_id} DCNL DCSP return self._make_request(action='RevokeCacheSecurityGroupIngress', verb='POST', path='/', params=params)
def __init__(self, connection=None, origin=None, enabled=False, caller_reference='', cnames=None, comment='', trusted_signers=None, default_root_object=None, logging=None): DCNL DCSP self.connection = connection DCNL DCSP self.origin = origin DCNL DCSP self.enabled = enabled DCNL DCSP if caller_reference: DCNL DCSP  DCSP self.caller_reference = caller_reference DCNL DCSP else: DCNL DCSP  DCSP self.caller_reference = str(uuid.uuid4()) DCNL DCSP self.cnames = [] DCNL DCSP if cnames: DCNL DCSP  DCSP self.cnames = cnames DCNL DCSP self.comment = comment DCNL DCSP self.trusted_signers = trusted_signers DCNL DCSP self.logging = logging DCNL DCSP self.default_root_object = default_root_object
def update(self, enabled=None, cnames=None, comment=None): DCNL DCSP new_config = DistributionConfig(self.connection, self.config.origin, self.config.enabled, self.config.caller_reference, self.config.cnames, self.config.comment, self.config.trusted_signers, self.config.default_root_object) DCNL DCSP if (enabled is not None): DCNL DCSP  DCSP new_config.enabled = enabled DCNL DCSP if (cnames is not None): DCNL DCSP  DCSP new_config.cnames = cnames DCNL DCSP if (comment is not None): DCNL DCSP  DCSP new_config.comment = comment DCNL DCSP self.etag = self.connection.set_distribution_config(self.id, self.etag, new_config) DCNL DCSP self.config = new_config DCNL DCSP self._object_class = Object
def enable(self): DCNL DCSP self.update(enabled=True)
def disable(self): DCNL DCSP self.update(enabled=False)
def delete(self): DCNL DCSP self.connection.delete_distribution(self.id, self.etag)
def get_objects(self): DCNL DCSP bucket = self._get_bucket() DCNL DCSP objs = [] DCNL DCSP for key in bucket: DCNL DCSP  DCSP objs.append(key) DCNL DCSP return objs
def set_permissions(self, object, replace=False): DCNL DCSP if isinstance(self.config.origin, S3Origin): DCNL DCSP  DCSP if self.config.origin.origin_access_identity: DCNL DCSP  DCSP  DCSP id = self.config.origin.origin_access_identity.split('/')[(-1)] DCNL DCSP  DCSP  DCSP oai = self.connection.get_origin_access_identity_info(id) DCNL DCSP  DCSP  DCSP policy = object.get_acl() DCNL DCSP  DCSP  DCSP if replace: DCNL DCSP  DCSP  DCSP  DCSP policy.acl = ACL() DCNL DCSP  DCSP  DCSP policy.acl.add_user_grant('READ', oai.s3_user_id) DCNL DCSP  DCSP  DCSP object.set_acl(policy) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP object.set_canned_acl('public-read')
def set_permissions_all(self, replace=False): DCNL DCSP bucket = self._get_bucket() DCNL DCSP for key in bucket: DCNL DCSP  DCSP self.set_permissions(key, replace)
def add_object(self, name, content, headers=None, replace=True): DCNL DCSP if self.config.origin.origin_access_identity: DCNL DCSP  DCSP policy = 'private' DCNL DCSP else: DCNL DCSP  DCSP policy = 'public-read' DCNL DCSP bucket = self._get_bucket() DCNL DCSP object = bucket.new_key(name) DCNL DCSP object.set_contents_from_file(content, headers=headers, policy=policy) DCNL DCSP if self.config.origin.origin_access_identity: DCNL DCSP  DCSP self.set_permissions(object, replace) DCNL DCSP return object
def create_signed_url(self, url, keypair_id, expire_time=None, valid_after_time=None, ip_address=None, policy_url=None, private_key_file=None, private_key_string=None): DCNL DCSP params = self._create_signing_params(url=url, keypair_id=keypair_id, expire_time=expire_time, valid_after_time=valid_after_time, ip_address=ip_address, policy_url=policy_url, private_key_file=private_key_file, private_key_string=private_key_string) DCNL DCSP if ('?' in url): DCNL DCSP  DCSP sep = '&' DCNL DCSP else: DCNL DCSP  DCSP sep = '?' DCNL DCSP signed_url_params = [] DCNL DCSP for key in ['Expires', 'Policy', 'Signature', 'Key-Pair-Id']: DCNL DCSP  DCSP if (key in params): DCNL DCSP  DCSP  DCSP param = ('%s=%s' % (key, params[key])) DCNL DCSP  DCSP  DCSP signed_url_params.append(param) DCNL DCSP signed_url = ((url + sep) + '&'.join(signed_url_params)) DCNL DCSP return signed_url
def _create_signing_params(self, url, keypair_id, expire_time=None, valid_after_time=None, ip_address=None, policy_url=None, private_key_file=None, private_key_string=None): DCNL DCSP params = {} DCNL DCSP if (expire_time and (not valid_after_time) and (not ip_address) and (not policy_url)): DCNL DCSP  DCSP policy = self._canned_policy(url, expire_time) DCNL DCSP  DCSP params['Expires'] = str(expire_time) DCNL DCSP else: DCNL DCSP  DCSP if (policy_url is None): DCNL DCSP  DCSP  DCSP policy_url = url DCNL DCSP  DCSP policy = self._custom_policy(policy_url, expires=expire_time, valid_after=valid_after_time, ip_address=ip_address) DCNL DCSP  DCSP encoded_policy = self._url_base64_encode(policy) DCNL DCSP  DCSP params['Policy'] = encoded_policy DCNL DCSP signature = self._sign_string(policy, private_key_file, private_key_string) DCNL DCSP encoded_signature = self._url_base64_encode(signature) DCNL DCSP params['Signature'] = encoded_signature DCNL DCSP params['Key-Pair-Id'] = keypair_id DCNL DCSP return params
@staticmethod DCNL def _canned_policy(resource, expires): DCNL DCSP policy = ('{"Statement":[{"Resource":"%(resource)s","Condition":{"DateLessThan":{"AWS:EpochTime":%(expires)s}}}]}' % locals()) DCNL DCSP return policy
@staticmethod DCNL def _custom_policy(resource, expires=None, valid_after=None, ip_address=None): DCNL DCSP condition = {} DCNL DCSP if (not expires): DCNL DCSP  DCSP expires = (int(time.time()) + 86400) DCNL DCSP condition['DateLessThan'] = {'AWS:EpochTime': expires} DCNL DCSP if valid_after: DCNL DCSP  DCSP condition['DateGreaterThan'] = {'AWS:EpochTime': valid_after} DCNL DCSP if ip_address: DCNL DCSP  DCSP if ('/' not in ip_address): DCNL DCSP  DCSP  DCSP ip_address += '/32' DCNL DCSP  DCSP condition['IpAddress'] = {'AWS:SourceIp': ip_address} DCNL DCSP policy = {'Statement': [{'Resource': resource, 'Condition': condition}]} DCNL DCSP return json.dumps(policy, separators=(',', ':'))
@staticmethod DCNL def _sign_string(message, private_key_file=None, private_key_string=None): DCNL DCSP try: DCNL DCSP  DCSP import rsa DCNL DCSP except ImportError: DCNL DCSP  DCSP raise NotImplementedError('Boto DCSP depends DCSP on DCSP the DCSP python DCSP rsa DCSP library DCSP to DCSP generate DCSP signed DCSP URLs DCSP for DCSP CloudFront') DCNL DCSP if (private_key_file and private_key_string): DCNL DCSP  DCSP raise ValueError('Only DCSP specify DCSP the DCSP private_key_file DCSP or DCSP the DCSP private_key_string DCSP not DCSP both') DCNL DCSP if ((not private_key_file) and (not private_key_string)): DCNL DCSP  DCSP raise ValueError('You DCSP must DCSP specify DCSP one DCSP of DCSP private_key_file DCSP or DCSP private_key_string') DCNL DCSP if (private_key_string is None): DCNL DCSP  DCSP if isinstance(private_key_file, six.string_types): DCNL DCSP  DCSP  DCSP with open(private_key_file, 'r') as file_handle: DCNL DCSP  DCSP  DCSP  DCSP private_key_string = file_handle.read() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP private_key_string = private_key_file.read() DCNL DCSP private_key = rsa.PrivateKey.load_pkcs1(private_key_string) DCNL DCSP signature = rsa.sign(str(message), private_key, 'SHA-1') DCNL DCSP return signature
@staticmethod DCNL def _url_base64_encode(msg): DCNL DCSP msg_base64 = base64.b64encode(msg) DCNL DCSP msg_base64 = msg_base64.replace('+', '-') DCNL DCSP msg_base64 = msg_base64.replace('=', '_') DCNL DCSP msg_base64 = msg_base64.replace('/', '~') DCNL DCSP return msg_base64
def update(self, enabled=None, cnames=None, comment=None): DCNL DCSP new_config = StreamingDistributionConfig(self.connection, self.config.origin, self.config.enabled, self.config.caller_reference, self.config.cnames, self.config.comment, self.config.trusted_signers) DCNL DCSP if (enabled is not None): DCNL DCSP  DCSP new_config.enabled = enabled DCNL DCSP if (cnames is not None): DCNL DCSP  DCSP new_config.cnames = cnames DCNL DCSP if (comment is not None): DCNL DCSP  DCSP new_config.comment = comment DCNL DCSP self.etag = self.connection.set_streaming_distribution_config(self.id, self.etag, new_config) DCNL DCSP self.config = new_config DCNL DCSP self._object_class = StreamingObject
def create_invalidation_request(self, distribution_id, paths, caller_reference=None): DCNL DCSP if (not isinstance(paths, InvalidationBatch)): DCNL DCSP  DCSP paths = InvalidationBatch(paths) DCNL DCSP paths.connection = self DCNL DCSP uri = ('/%s/distribution/%s/invalidation' % (self.Version, distribution_id)) DCNL DCSP response = self.make_request('POST', uri, {'Content-Type': 'text/xml'}, data=paths.to_xml()) DCNL DCSP body = response.read() DCNL DCSP if (response.status == 201): DCNL DCSP  DCSP h = handler.XmlHandler(paths, self) DCNL DCSP  DCSP xml.sax.parseString(body, h) DCNL DCSP  DCSP return paths DCNL DCSP else: DCNL DCSP  DCSP raise CloudFrontServerError(response.status, response.reason, body)
def get_invalidation_requests(self, distribution_id, marker=None, max_items=None): DCNL DCSP uri = ('distribution/%s/invalidation' % distribution_id) DCNL DCSP params = dict() DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if max_items: DCNL DCSP  DCSP params['MaxItems'] = max_items DCNL DCSP if params: DCNL DCSP  DCSP uri += ('?%s=%s' % params.popitem()) DCNL DCSP  DCSP for (k, v) in params.items(): DCNL DCSP  DCSP  DCSP uri += ('&%s=%s' % (k, v)) DCNL DCSP tags = [('InvalidationSummary', InvalidationSummary)] DCNL DCSP rs_class = InvalidationListResultSet DCNL DCSP rs_kwargs = dict(connection=self, distribution_id=distribution_id, max_items=max_items, marker=marker) DCNL DCSP return self._get_all_objects(uri, tags, result_set_class=rs_class, result_set_kwargs=rs_kwargs)
def __init__(self, dns_name=None, origin_access_identity=None): DCNL DCSP self.dns_name = dns_name DCNL DCSP self.origin_access_identity = origin_access_identity
def __init__(self, dns_name=None, http_port=80, https_port=443, origin_protocol_policy=None): DCNL DCSP self.dns_name = dns_name DCNL DCSP self.http_port = http_port DCNL DCSP self.https_port = https_port DCNL DCSP self.origin_protocol_policy = origin_protocol_policy
def __init__(self, paths=None, connection=None, distribution=None, caller_reference=''): DCNL DCSP self.paths = (paths or []) DCNL DCSP self.distribution = distribution DCNL DCSP self.caller_reference = caller_reference DCNL DCSP if (not self.caller_reference): DCNL DCSP  DCSP self.caller_reference = str(uuid.uuid4()) DCNL DCSP if distribution: DCNL DCSP  DCSP self.connection = distribution DCNL DCSP else: DCNL DCSP  DCSP self.connection = connection
def add(self, path): DCNL DCSP return self.paths.append(path)
def remove(self, path): DCNL DCSP return self.paths.remove(path)
def escape(self, p): DCNL DCSP if (not (p[0] == '/')): DCNL DCSP  DCSP p = ('/%s' % p) DCNL DCSP return urllib.parse.quote(p, safe='/*')
def to_xml(self): DCNL DCSP assert (self.connection is not None) DCNL DCSP s = '<?xml DCSP version="1.0" DCSP encoding="UTF-8"?>\n' DCNL DCSP s += ('<InvalidationBatch DCSP xmlns="http://cloudfront.amazonaws.com/doc/%s/">\n' % self.connection.Version) DCNL DCSP for p in self.paths: DCNL DCSP  DCSP s += (' DCSP  DCSP  DCSP  DCSP <Path>%s</Path>\n' % self.escape(p)) DCNL DCSP s += (' DCSP  DCSP  DCSP  DCSP <CallerReference>%s</CallerReference>\n' % self.caller_reference) DCNL DCSP s += '</InvalidationBatch>\n' DCNL DCSP return s
def __iter__(self): DCNL DCSP conn = self.connection DCNL DCSP distribution_id = self.distribution_id DCNL DCSP result_set = self DCNL DCSP for inval in result_set._inval_cache: DCNL DCSP  DCSP (yield inval) DCNL DCSP if (not self.auto_paginate): DCNL DCSP  DCSP return DCNL DCSP while result_set.is_truncated: DCNL DCSP  DCSP result_set = conn.get_invalidation_requests(distribution_id, marker=result_set.next_marker, max_items=result_set.max_items) DCNL DCSP  DCSP for i in result_set._inval_cache: DCNL DCSP  DCSP  DCSP (yield i)
def get_distribution(self): DCNL DCSP return self.connection.get_distribution_info(self.distribution_id)
def get_invalidation_request(self): DCNL DCSP return self.connection.invalidation_request_status(self.distribution_id, self.id)
def describe_cluster(self, cluster_id): DCNL DCSP params = {'ClusterId': cluster_id} DCNL DCSP return self.get_object('DescribeCluster', params, Cluster)
def describe_jobflow(self, jobflow_id): DCNL DCSP jobflows = self.describe_jobflows(jobflow_ids=[jobflow_id]) DCNL DCSP if jobflows: DCNL DCSP  DCSP return jobflows[0]
def describe_jobflows(self, states=None, jobflow_ids=None, created_after=None, created_before=None): DCNL DCSP params = {} DCNL DCSP if states: DCNL DCSP  DCSP self.build_list_params(params, states, 'JobFlowStates.member') DCNL DCSP if jobflow_ids: DCNL DCSP  DCSP self.build_list_params(params, jobflow_ids, 'JobFlowIds.member') DCNL DCSP if created_after: DCNL DCSP  DCSP params['CreatedAfter'] = created_after.strftime(boto.utils.ISO8601) DCNL DCSP if created_before: DCNL DCSP  DCSP params['CreatedBefore'] = created_before.strftime(boto.utils.ISO8601) DCNL DCSP return self.get_list('DescribeJobFlows', params, [('member', JobFlow)])
def describe_step(self, cluster_id, step_id): DCNL DCSP params = {'ClusterId': cluster_id, 'StepId': step_id} DCNL DCSP return self.get_object('DescribeStep', params, HadoopStep)
def list_bootstrap_actions(self, cluster_id, marker=None): DCNL DCSP params = {'ClusterId': cluster_id} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_object('ListBootstrapActions', params, BootstrapActionList)
def list_clusters(self, created_after=None, created_before=None, cluster_states=None, marker=None): DCNL DCSP params = {} DCNL DCSP if created_after: DCNL DCSP  DCSP params['CreatedAfter'] = created_after.strftime(boto.utils.ISO8601) DCNL DCSP if created_before: DCNL DCSP  DCSP params['CreatedBefore'] = created_before.strftime(boto.utils.ISO8601) DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if cluster_states: DCNL DCSP  DCSP self.build_list_params(params, cluster_states, 'ClusterStates.member') DCNL DCSP return self.get_object('ListClusters', params, ClusterSummaryList)
def list_instance_groups(self, cluster_id, marker=None): DCNL DCSP params = {'ClusterId': cluster_id} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP return self.get_object('ListInstanceGroups', params, InstanceGroupList)
def list_instances(self, cluster_id, instance_group_id=None, instance_group_types=None, marker=None): DCNL DCSP params = {'ClusterId': cluster_id} DCNL DCSP if instance_group_id: DCNL DCSP  DCSP params['InstanceGroupId'] = instance_group_id DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if instance_group_types: DCNL DCSP  DCSP self.build_list_params(params, instance_group_types, 'InstanceGroupTypes.member') DCNL DCSP return self.get_object('ListInstances', params, InstanceList)
def list_steps(self, cluster_id, step_states=None, marker=None): DCNL DCSP params = {'ClusterId': cluster_id} DCNL DCSP if marker: DCNL DCSP  DCSP params['Marker'] = marker DCNL DCSP if step_states: DCNL DCSP  DCSP self.build_list_params(params, step_states, 'StepStates.member') DCNL DCSP return self.get_object('ListSteps', params, StepSummaryList)
def add_tags(self, resource_id, tags): DCNL DCSP assert isinstance(resource_id, six.string_types) DCNL DCSP params = {'ResourceId': resource_id} DCNL DCSP params.update(self._build_tag_list(tags)) DCNL DCSP return self.get_status('AddTags', params, verb='POST')
def remove_tags(self, resource_id, tags): DCNL DCSP params = {'ResourceId': resource_id} DCNL DCSP params.update(self._build_string_list('TagKeys', tags)) DCNL DCSP return self.get_status('RemoveTags', params, verb='POST')
def terminate_jobflow(self, jobflow_id): DCNL DCSP self.terminate_jobflows([jobflow_id])
def terminate_jobflows(self, jobflow_ids): DCNL DCSP params = {} DCNL DCSP self.build_list_params(params, jobflow_ids, 'JobFlowIds.member') DCNL DCSP return self.get_status('TerminateJobFlows', params, verb='POST')
def add_jobflow_steps(self, jobflow_id, steps): DCNL DCSP if (not isinstance(steps, list)): DCNL DCSP  DCSP steps = [steps] DCNL DCSP params = {} DCNL DCSP params['JobFlowId'] = jobflow_id DCNL DCSP step_args = [self._build_step_args(step) for step in steps] DCNL DCSP params.update(self._build_step_list(step_args)) DCNL DCSP return self.get_object('AddJobFlowSteps', params, JobFlowStepList, verb='POST')
def add_instance_groups(self, jobflow_id, instance_groups): DCNL DCSP if (not isinstance(instance_groups, list)): DCNL DCSP  DCSP instance_groups = [instance_groups] DCNL DCSP params = {} DCNL DCSP params['JobFlowId'] = jobflow_id DCNL DCSP params.update(self._build_instance_group_list_args(instance_groups)) DCNL DCSP return self.get_object('AddInstanceGroups', params, AddInstanceGroupsResponse, verb='POST')
def modify_instance_groups(self, instance_group_ids, new_sizes): DCNL DCSP if (not isinstance(instance_group_ids, list)): DCNL DCSP  DCSP instance_group_ids = [instance_group_ids] DCNL DCSP if (not isinstance(new_sizes, list)): DCNL DCSP  DCSP new_sizes = [new_sizes] DCNL DCSP instance_groups = zip(instance_group_ids, new_sizes) DCNL DCSP params = {} DCNL DCSP for (k, ig) in enumerate(instance_groups): DCNL DCSP  DCSP params[('InstanceGroups.member.%d.InstanceGroupId' % (k + 1))] = ig[0] DCNL DCSP  DCSP params[('InstanceGroups.member.%d.InstanceCount' % (k + 1))] = ig[1] DCNL DCSP return self.get_object('ModifyInstanceGroups', params, ModifyInstanceGroupsResponse, verb='POST')
def run_jobflow(self, name, log_uri=None, ec2_keyname=None, availability_zone=None, master_instance_type='m1.small', slave_instance_type='m1.small', num_instances=1, action_on_failure='TERMINATE_JOB_FLOW', keep_alive=False, enable_debugging=False, hadoop_version=None, steps=None, bootstrap_actions=[], instance_groups=None, additional_info=None, ami_version=None, api_params=None, visible_to_all_users=None, job_flow_role=None, service_role=None): DCNL DCSP steps = (steps or []) DCNL DCSP params = {} DCNL DCSP if action_on_failure: DCNL DCSP  DCSP params['ActionOnFailure'] = action_on_failure DCNL DCSP if log_uri: DCNL DCSP  DCSP params['LogUri'] = log_uri DCNL DCSP params['Name'] = name DCNL DCSP common_params = self._build_instance_common_args(ec2_keyname, availability_zone, keep_alive, hadoop_version) DCNL DCSP params.update(common_params) DCNL DCSP if (not instance_groups): DCNL DCSP  DCSP instance_params = self._build_instance_count_and_type_args(master_instance_type, slave_instance_type, num_instances) DCNL DCSP  DCSP params.update(instance_params) DCNL DCSP else: DCNL DCSP  DCSP list_args = self._build_instance_group_list_args(instance_groups) DCNL DCSP  DCSP instance_params = dict(((('Instances.%s' % k), v) for (k, v) in six.iteritems(list_args))) DCNL DCSP  DCSP params.update(instance_params) DCNL DCSP if enable_debugging: DCNL DCSP  DCSP debugging_step = JarStep(name='Setup DCSP Hadoop DCSP Debugging', action_on_failure='TERMINATE_JOB_FLOW', main_class=None, jar=self.DebuggingJar.format(region_name=self.region.name), step_args=self.DebuggingArgs.format(region_name=self.region.name)) DCNL DCSP  DCSP steps.insert(0, debugging_step) DCNL DCSP if steps: DCNL DCSP  DCSP step_args = [self._build_step_args(step) for step in steps] DCNL DCSP  DCSP params.update(self._build_step_list(step_args)) DCNL DCSP if bootstrap_actions: DCNL DCSP  DCSP bootstrap_action_args = [self._build_bootstrap_action_args(bootstrap_action) for bootstrap_action in bootstrap_actions] DCNL DCSP  DCSP params.update(self._build_bootstrap_action_list(bootstrap_action_args)) DCNL DCSP if ami_version: DCNL DCSP  DCSP params['AmiVersion'] = ami_version DCNL DCSP if (additional_info is not None): DCNL DCSP  DCSP params['AdditionalInfo'] = additional_info DCNL DCSP if api_params: DCNL DCSP  DCSP for (key, value) in six.iteritems(api_params): DCNL DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP params.pop(key, None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP params[key] = value DCNL DCSP if (visible_to_all_users is not None): DCNL DCSP  DCSP if visible_to_all_users: DCNL DCSP  DCSP  DCSP params['VisibleToAllUsers'] = 'true' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params['VisibleToAllUsers'] = 'false' DCNL DCSP if (job_flow_role is not None): DCNL DCSP  DCSP params['JobFlowRole'] = job_flow_role DCNL DCSP if (service_role is not None): DCNL DCSP  DCSP params['ServiceRole'] = service_role DCNL DCSP response = self.get_object('RunJobFlow', params, RunJobFlowResponse, verb='POST') DCNL DCSP return response.jobflowid
def set_termination_protection(self, jobflow_id, termination_protection_status): DCNL DCSP assert (termination_protection_status in (True, False)) DCNL DCSP params = {} DCNL DCSP params['TerminationProtected'] = ((termination_protection_status and 'true') or 'false') DCNL DCSP self.build_list_params(params, [jobflow_id], 'JobFlowIds.member') DCNL DCSP return self.get_status('SetTerminationProtection', params, verb='POST')
def set_visible_to_all_users(self, jobflow_id, visibility): DCNL DCSP assert (visibility in (True, False)) DCNL DCSP params = {} DCNL DCSP params['VisibleToAllUsers'] = ((visibility and 'true') or 'false') DCNL DCSP self.build_list_params(params, [jobflow_id], 'JobFlowIds.member') DCNL DCSP return self.get_status('SetVisibleToAllUsers', params, verb='POST')
def _build_instance_common_args(self, ec2_keyname, availability_zone, keep_alive, hadoop_version): DCNL DCSP params = {'Instances.KeepJobFlowAliveWhenNoSteps': str(keep_alive).lower()} DCNL DCSP if hadoop_version: DCNL DCSP  DCSP params['Instances.HadoopVersion'] = hadoop_version DCNL DCSP if ec2_keyname: DCNL DCSP  DCSP params['Instances.Ec2KeyName'] = ec2_keyname DCNL DCSP if availability_zone: DCNL DCSP  DCSP params['Instances.Placement.AvailabilityZone'] = availability_zone DCNL DCSP return params
def _build_instance_count_and_type_args(self, master_instance_type, slave_instance_type, num_instances): DCNL DCSP params = {'Instances.MasterInstanceType': master_instance_type, 'Instances.SlaveInstanceType': slave_instance_type, 'Instances.InstanceCount': num_instances} DCNL DCSP return params
def _build_instance_group_args(self, instance_group): DCNL DCSP params = {'InstanceCount': instance_group.num_instances, 'InstanceRole': instance_group.role, 'InstanceType': instance_group.type, 'Name': instance_group.name, 'Market': instance_group.market} DCNL DCSP if (instance_group.market == 'SPOT'): DCNL DCSP  DCSP params['BidPrice'] = instance_group.bidprice DCNL DCSP return params
def _build_instance_group_list_args(self, instance_groups): DCNL DCSP if (not isinstance(instance_groups, list)): DCNL DCSP  DCSP instance_groups = [instance_groups] DCNL DCSP params = {} DCNL DCSP for (i, instance_group) in enumerate(instance_groups): DCNL DCSP  DCSP ig_dict = self._build_instance_group_args(instance_group) DCNL DCSP  DCSP for (key, value) in six.iteritems(ig_dict): DCNL DCSP  DCSP  DCSP params[('InstanceGroups.member.%d.%s' % ((i + 1), key))] = value DCNL DCSP return params
def jar(self): DCNL DCSP raise NotImplemented()
def args(self): DCNL DCSP raise NotImplemented()
def main_class(self): DCNL DCSP raise NotImplemented()
def __init__(self, name, jar, main_class=None, action_on_failure='TERMINATE_JOB_FLOW', step_args=None): DCNL DCSP self.name = name DCNL DCSP self._jar = jar DCNL DCSP self._main_class = main_class DCNL DCSP self.action_on_failure = action_on_failure DCNL DCSP if isinstance(step_args, six.string_types): DCNL DCSP  DCSP step_args = [step_args] DCNL DCSP self.step_args = step_args
def __init__(self, name, mapper, reducer=None, combiner=None, action_on_failure='TERMINATE_JOB_FLOW', cache_files=None, cache_archives=None, step_args=None, input=None, output=None, jar='/home/hadoop/contrib/streaming/hadoop-streaming.jar'): DCNL DCSP self.name = name DCNL DCSP self.mapper = mapper DCNL DCSP self.reducer = reducer DCNL DCSP self.combiner = combiner DCNL DCSP self.action_on_failure = action_on_failure DCNL DCSP self.cache_files = cache_files DCNL DCSP self.cache_archives = cache_archives DCNL DCSP self.input = input DCNL DCSP self.output = output DCNL DCSP self._jar = jar DCNL DCSP if isinstance(step_args, six.string_types): DCNL DCSP  DCSP step_args = [step_args] DCNL DCSP self.step_args = step_args
def delete(self): DCNL DCSP return self.layer1.delete_domain(self.name)
def get_stemming(self): DCNL DCSP return OptionStatus(self, None, self.layer1.describe_stemming_options, self.layer1.update_stemming_options)
def get_stopwords(self): DCNL DCSP return OptionStatus(self, None, self.layer1.describe_stopword_options, self.layer1.update_stopword_options)
def get_synonyms(self): DCNL DCSP return OptionStatus(self, None, self.layer1.describe_synonym_options, self.layer1.update_synonym_options)
def get_access_policies(self): DCNL DCSP return ServicePoliciesStatus(self, None, self.layer1.describe_service_access_policies, self.layer1.update_service_access_policies)
def index_documents(self): DCNL DCSP self.layer1.index_documents(self.name)
def get_index_fields(self, field_names=None): DCNL DCSP data = self.layer1.describe_index_fields(self.name, field_names) DCNL DCSP return [IndexFieldStatus(self, d) for d in data]
def create_index_field(self, field_name, field_type, default='', facet=False, result=False, searchable=False, source_attributes=[]): DCNL DCSP data = self.layer1.define_index_field(self.name, field_name, field_type, default=default, facet=facet, result=result, searchable=searchable, source_attributes=source_attributes) DCNL DCSP return IndexFieldStatus(self, data, self.layer1.describe_index_fields)
def get_rank_expressions(self, rank_names=None): DCNL DCSP fn = self.layer1.describe_rank_expressions DCNL DCSP data = fn(self.name, rank_names) DCNL DCSP return [RankExpressionStatus(self, d, fn) for d in data]
def create_rank_expression(self, name, expression): DCNL DCSP data = self.layer1.define_rank_expression(self.name, name, expression) DCNL DCSP return RankExpressionStatus(self, data, self.layer1.describe_rank_expressions)
def next_page(self): DCNL DCSP if (self.query.page <= self.num_pages_needed): DCNL DCSP  DCSP self.query.start += self.query.real_size DCNL DCSP  DCSP self.query.page += 1 DCNL DCSP  DCSP return self.search_service(self.query) DCNL DCSP else: DCNL DCSP  DCSP raise StopIteration
def to_params(self): DCNL DCSP params = {'start': self.start, 'size': self.real_size} DCNL DCSP if self.q: DCNL DCSP  DCSP params['q'] = self.q DCNL DCSP if self.bq: DCNL DCSP  DCSP params['bq'] = self.bq DCNL DCSP if self.rank: DCNL DCSP  DCSP params['rank'] = ','.join(self.rank) DCNL DCSP if self.return_fields: DCNL DCSP  DCSP params['return-fields'] = ','.join(self.return_fields) DCNL DCSP if self.facet: DCNL DCSP  DCSP params['facet'] = ','.join(self.facet) DCNL DCSP if self.facet_constraints: DCNL DCSP  DCSP for (k, v) in six.iteritems(self.facet_constraints): DCNL DCSP  DCSP  DCSP params[('facet-%s-constraints' % k)] = v DCNL DCSP if self.facet_sort: DCNL DCSP  DCSP for (k, v) in six.iteritems(self.facet_sort): DCNL DCSP  DCSP  DCSP params[('facet-%s-sort' % k)] = v DCNL DCSP if self.facet_top_n: DCNL DCSP  DCSP for (k, v) in six.iteritems(self.facet_top_n): DCNL DCSP  DCSP  DCSP params[('facet-%s-top-n' % k)] = v DCNL DCSP if self.t: DCNL DCSP  DCSP for (k, v) in six.iteritems(self.t): DCNL DCSP  DCSP  DCSP params[('t-%s' % k)] = v DCNL DCSP return params
def search(self, q=None, bq=None, rank=None, return_fields=None, size=10, start=0, facet=None, facet_constraints=None, facet_sort=None, facet_top_n=None, t=None): DCNL DCSP query = self.build_query(q=q, bq=bq, rank=rank, return_fields=return_fields, size=size, start=start, facet=facet, facet_constraints=facet_constraints, facet_sort=facet_sort, facet_top_n=facet_top_n, t=t) DCNL DCSP return self(query)
def __call__(self, query): DCNL DCSP url = ('http://%s/2011-02-01/search' % self.endpoint) DCNL DCSP params = query.to_params() DCNL DCSP r = requests.get(url, params=params) DCNL DCSP body = r.content.decode('utf-8') DCNL DCSP try: DCNL DCSP  DCSP data = json.loads(body) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP if (r.status_code == 403): DCNL DCSP  DCSP  DCSP msg = '' DCNL DCSP  DCSP  DCSP import re DCNL DCSP  DCSP  DCSP g = re.search('<html><body><h1>403 DCSP Forbidden</h1>([^<]+)<', body) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP msg = (': DCSP %s' % g.groups()[0].strip()) DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP raise SearchServiceException(('Authentication DCSP error DCSP from DCSP Amazon%s' % msg)) DCNL DCSP  DCSP raise SearchServiceException(('Got DCSP non-json DCSP response DCSP from DCSP Amazon. DCSP %s' % body), query) DCNL DCSP if (('messages' in data) and ('error' in data)): DCNL DCSP  DCSP for m in data['messages']: DCNL DCSP  DCSP  DCSP if (m['severity'] == 'fatal'): DCNL DCSP  DCSP  DCSP  DCSP raise SearchServiceException(('Error DCSP processing DCSP search DCSP %s DCSP => DCSP %s' % (params, m['message'])), query) DCNL DCSP elif ('error' in data): DCNL DCSP  DCSP raise SearchServiceException(('Unknown DCSP error DCSP processing DCSP search DCSP %s' % json.dumps(data)), query) DCNL DCSP data['query'] = query DCNL DCSP data['search_service'] = self DCNL DCSP return SearchResults(**data)
def get_all_paged(self, query, per_page): DCNL DCSP query.update_size(per_page) DCNL DCSP page = 0 DCNL DCSP num_pages_needed = 0 DCNL DCSP while (page <= num_pages_needed): DCNL DCSP  DCSP results = self(query) DCNL DCSP  DCSP num_pages_needed = results.num_pages_needed DCNL DCSP  DCSP (yield results) DCNL DCSP  DCSP query.start += query.real_size DCNL DCSP  DCSP page += 1
def get_all_hits(self, query): DCNL DCSP page = 0 DCNL DCSP num_pages_needed = 0 DCNL DCSP while (page <= num_pages_needed): DCNL DCSP  DCSP results = self(query) DCNL DCSP  DCSP num_pages_needed = results.num_pages_needed DCNL DCSP  DCSP for doc in results: DCNL DCSP  DCSP  DCSP (yield doc) DCNL DCSP  DCSP query.start += query.real_size DCNL DCSP  DCSP page += 1
def get_num_hits(self, query): DCNL DCSP query.update_size(1) DCNL DCSP return self(query).hits
def create_domain(self, domain_name): DCNL DCSP doc_path = ('create_domain_response', 'create_domain_result', 'domain_status') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.get_response(doc_path, 'CreateDomain', params, verb='POST')
def define_index_field(self, domain_name, field_name, field_type, default='', facet=False, result=False, searchable=False, source_attributes=None): DCNL DCSP doc_path = ('define_index_field_response', 'define_index_field_result', 'index_field') DCNL DCSP params = {'DomainName': domain_name, 'IndexField.IndexFieldName': field_name, 'IndexField.IndexFieldType': field_type} DCNL DCSP if (field_type == 'literal'): DCNL DCSP  DCSP params['IndexField.LiteralOptions.DefaultValue'] = default DCNL DCSP  DCSP params['IndexField.LiteralOptions.FacetEnabled'] = do_bool(facet) DCNL DCSP  DCSP params['IndexField.LiteralOptions.ResultEnabled'] = do_bool(result) DCNL DCSP  DCSP params['IndexField.LiteralOptions.SearchEnabled'] = do_bool(searchable) DCNL DCSP elif (field_type == 'uint'): DCNL DCSP  DCSP params['IndexField.UIntOptions.DefaultValue'] = default DCNL DCSP elif (field_type == 'text'): DCNL DCSP  DCSP params['IndexField.TextOptions.DefaultValue'] = default DCNL DCSP  DCSP params['IndexField.TextOptions.FacetEnabled'] = do_bool(facet) DCNL DCSP  DCSP params['IndexField.TextOptions.ResultEnabled'] = do_bool(result) DCNL DCSP return self.get_response(doc_path, 'DefineIndexField', params, verb='POST')
def define_rank_expression(self, domain_name, rank_name, rank_expression): DCNL DCSP doc_path = ('define_rank_expression_response', 'define_rank_expression_result', 'rank_expression') DCNL DCSP params = {'DomainName': domain_name, 'RankExpression.RankExpression': rank_expression, 'RankExpression.RankName': rank_name} DCNL DCSP return self.get_response(doc_path, 'DefineRankExpression', params, verb='POST')
def delete_domain(self, domain_name): DCNL DCSP doc_path = ('delete_domain_response', 'delete_domain_result', 'domain_status') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.get_response(doc_path, 'DeleteDomain', params, verb='POST')
def delete_index_field(self, domain_name, field_name): DCNL DCSP doc_path = ('delete_index_field_response', 'delete_index_field_result', 'index_field') DCNL DCSP params = {'DomainName': domain_name, 'IndexFieldName': field_name} DCNL DCSP return self.get_response(doc_path, 'DeleteIndexField', params, verb='POST')
def delete_rank_expression(self, domain_name, rank_name): DCNL DCSP doc_path = ('delete_rank_expression_response', 'delete_rank_expression_result', 'rank_expression') DCNL DCSP params = {'DomainName': domain_name, 'RankName': rank_name} DCNL DCSP return self.get_response(doc_path, 'DeleteRankExpression', params, verb='POST')
def describe_default_search_field(self, domain_name): DCNL DCSP doc_path = ('describe_default_search_field_response', 'describe_default_search_field_result', 'default_search_field') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.get_response(doc_path, 'DescribeDefaultSearchField', params, verb='POST')
def describe_domains(self, domain_names=None): DCNL DCSP doc_path = ('describe_domains_response', 'describe_domains_result', 'domain_status_list') DCNL DCSP params = {} DCNL DCSP if domain_names: DCNL DCSP  DCSP for (i, domain_name) in enumerate(domain_names, 1): DCNL DCSP  DCSP  DCSP params[('DomainNames.member.%d' % i)] = domain_name DCNL DCSP return self.get_response(doc_path, 'DescribeDomains', params, verb='POST', list_marker='DomainStatusList')
def describe_index_fields(self, domain_name, field_names=None): DCNL DCSP doc_path = ('describe_index_fields_response', 'describe_index_fields_result', 'index_fields') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if field_names: DCNL DCSP  DCSP for (i, field_name) in enumerate(field_names, 1): DCNL DCSP  DCSP  DCSP params[('FieldNames.member.%d' % i)] = field_name DCNL DCSP return self.get_response(doc_path, 'DescribeIndexFields', params, verb='POST', list_marker='IndexFields')
def describe_rank_expressions(self, domain_name, rank_names=None): DCNL DCSP doc_path = ('describe_rank_expressions_response', 'describe_rank_expressions_result', 'rank_expressions') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP if rank_names: DCNL DCSP  DCSP for (i, rank_name) in enumerate(rank_names, 1): DCNL DCSP  DCSP  DCSP params[('RankNames.member.%d' % i)] = rank_name DCNL DCSP return self.get_response(doc_path, 'DescribeRankExpressions', params, verb='POST', list_marker='RankExpressions')
def describe_service_access_policies(self, domain_name): DCNL DCSP doc_path = ('describe_service_access_policies_response', 'describe_service_access_policies_result', 'access_policies') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.get_response(doc_path, 'DescribeServiceAccessPolicies', params, verb='POST')
def describe_stemming_options(self, domain_name): DCNL DCSP doc_path = ('describe_stemming_options_response', 'describe_stemming_options_result', 'stems') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.get_response(doc_path, 'DescribeStemmingOptions', params, verb='POST')
def describe_stopword_options(self, domain_name): DCNL DCSP doc_path = ('describe_stopword_options_response', 'describe_stopword_options_result', 'stopwords') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.get_response(doc_path, 'DescribeStopwordOptions', params, verb='POST')
def describe_synonym_options(self, domain_name): DCNL DCSP doc_path = ('describe_synonym_options_response', 'describe_synonym_options_result', 'synonyms') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.get_response(doc_path, 'DescribeSynonymOptions', params, verb='POST')
def index_documents(self, domain_name): DCNL DCSP doc_path = ('index_documents_response', 'index_documents_result', 'field_names') DCNL DCSP params = {'DomainName': domain_name} DCNL DCSP return self.get_response(doc_path, 'IndexDocuments', params, verb='POST', list_marker='FieldNames')
def update_default_search_field(self, domain_name, default_search_field): DCNL DCSP doc_path = ('update_default_search_field_response', 'update_default_search_field_result', 'default_search_field') DCNL DCSP params = {'DomainName': domain_name, 'DefaultSearchField': default_search_field} DCNL DCSP return self.get_response(doc_path, 'UpdateDefaultSearchField', params, verb='POST')
def update_service_access_policies(self, domain_name, access_policies): DCNL DCSP doc_path = ('update_service_access_policies_response', 'update_service_access_policies_result', 'access_policies') DCNL DCSP params = {'AccessPolicies': access_policies, 'DomainName': domain_name} DCNL DCSP return self.get_response(doc_path, 'UpdateServiceAccessPolicies', params, verb='POST')
def update_stemming_options(self, domain_name, stems): DCNL DCSP doc_path = ('update_stemming_options_response', 'update_stemming_options_result', 'stems') DCNL DCSP params = {'DomainName': domain_name, 'Stems': stems} DCNL DCSP return self.get_response(doc_path, 'UpdateStemmingOptions', params, verb='POST')
def update_stopword_options(self, domain_name, stopwords): DCNL DCSP doc_path = ('update_stopword_options_response', 'update_stopword_options_result', 'stopwords') DCNL DCSP params = {'DomainName': domain_name, 'Stopwords': stopwords} DCNL DCSP return self.get_response(doc_path, 'UpdateStopwordOptions', params, verb='POST')
def update_synonym_options(self, domain_name, synonyms): DCNL DCSP doc_path = ('update_synonym_options_response', 'update_synonym_options_result', 'synonyms') DCNL DCSP params = {'DomainName': domain_name, 'Synonyms': synonyms} DCNL DCSP return self.get_response(doc_path, 'UpdateSynonymOptions', params, verb='POST')
def refresh(self, data=None): DCNL DCSP if (not data): DCNL DCSP  DCSP if self.refresh_fn: DCNL DCSP  DCSP  DCSP data = self.refresh_fn(self.domain.name) DCNL DCSP if data: DCNL DCSP  DCSP self._update_status(data['status']) DCNL DCSP  DCSP self._update_options(data['options'])
def to_json(self): DCNL DCSP return json.dumps(self)
def save(self): DCNL DCSP if self.save_fn: DCNL DCSP  DCSP data = self.save_fn(self.domain.name, self.to_json()) DCNL DCSP  DCSP self.refresh(data)
def wait_for_state(self, state): DCNL DCSP while (self.state != state): DCNL DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP self.refresh()
def new_statement(self, arn, ip): DCNL DCSP return {'Effect': 'Allow', 'Action': '*', 'Resource': arn, 'Condition': {'IpAddress': {'aws:SourceIp': [ip]}}}
def allow_search_ip(self, ip): DCNL DCSP arn = self.domain.search_service_arn DCNL DCSP self._allow_ip(arn, ip)
def allow_doc_ip(self, ip): DCNL DCSP arn = self.domain.doc_service_arn DCNL DCSP self._allow_ip(arn, ip)
def disallow_search_ip(self, ip): DCNL DCSP arn = self.domain.search_service_arn DCNL DCSP self._disallow_ip(arn, ip)
def disallow_doc_ip(self, ip): DCNL DCSP arn = self.domain.doc_service_arn DCNL DCSP self._disallow_ip(arn, ip)
def add(self, _id, version, fields, lang='en'): DCNL DCSP d = {'type': 'add', 'id': _id, 'version': version, 'lang': lang, 'fields': fields} DCNL DCSP self.documents_batch.append(d)
def delete(self, _id, version): DCNL DCSP d = {'type': 'delete', 'id': _id, 'version': version} DCNL DCSP self.documents_batch.append(d)
def get_sdf(self): DCNL DCSP return (self._sdf if self._sdf else json.dumps(self.documents_batch))
def clear_sdf(self): DCNL DCSP self._sdf = None DCNL DCSP self.documents_batch = []
def add_sdf_from_s3(self, key_obj): DCNL DCSP self._sdf = key_obj.get_contents_as_string()
def commit(self): DCNL DCSP sdf = self.get_sdf() DCNL DCSP if (': DCSP null' in sdf): DCNL DCSP  DCSP boto.log.error('null DCSP value DCSP in DCSP sdf DCSP detected. DCSP  DCSP This DCSP will DCSP probably DCSP raise DCSP 500 DCSP error.') DCNL DCSP  DCSP index = sdf.index(': DCSP null') DCNL DCSP  DCSP boto.log.error(sdf[(index - 100):(index + 100)]) DCNL DCSP url = ('http://%s/2011-02-01/documents/batch' % self.endpoint) DCNL DCSP session = requests.Session() DCNL DCSP adapter = requests.adapters.HTTPAdapter(pool_connections=20, pool_maxsize=50, max_retries=5) DCNL DCSP session.mount('http://', adapter) DCNL DCSP session.mount('https://', adapter) DCNL DCSP r = session.post(url, data=sdf, headers={'Content-Type': 'application/json'}) DCNL DCSP return CommitResponse(r, self, sdf)
def _check_num_ops(self, type_, response_num): DCNL DCSP commit_num = len([d for d in self.doc_service.documents_batch if (d['type'] == type_)]) DCNL DCSP if (response_num != commit_num): DCNL DCSP  DCSP raise CommitMismatchError('Incorrect DCSP number DCSP of DCSP {0}s DCSP returned. DCSP Commit: DCSP {1} DCSP Response: DCSP {2}'.format(type_, commit_num, response_num))
def list_domains(self, domain_names=None): DCNL DCSP domain_data = self.layer1.describe_domains(domain_names) DCNL DCSP return [Domain(self.layer1, data) for data in domain_data]
def create_domain(self, domain_name): DCNL DCSP data = self.layer1.create_domain(domain_name) DCNL DCSP return Domain(self.layer1, data)
def lookup(self, domain_name): DCNL DCSP domains = self.list_domains(domain_names=[domain_name]) DCNL DCSP if (len(domains) > 0): DCNL DCSP  DCSP return domains[0]
def __init__(self, name, contained_key): DCNL DCSP self.name = name DCNL DCSP self.contained_key = contained_key
def delete_key(self, key_name, headers=None, version_id=None, mfa_token=None): DCNL DCSP os.remove(key_name)
def get_all_keys(self, headers=None, **params): DCNL DCSP key = Key(self.name, self.contained_key) DCNL DCSP return SimpleResultSet([key])
def get_key(self, key_name, headers=None, version_id=None, key_type=Key.KEY_REGULAR_FILE): DCNL DCSP if (key_name == '-'): DCNL DCSP  DCSP return Key(self.name, '-', key_type=Key.KEY_STREAM_READABLE) DCNL DCSP else: DCNL DCSP  DCSP fp = open(key_name, 'rb') DCNL DCSP  DCSP return Key(self.name, key_name, fp)
def new_key(self, key_name=None, key_type=Key.KEY_REGULAR_FILE): DCNL DCSP if (key_name == '-'): DCNL DCSP  DCSP return Key(self.name, '-', key_type=Key.KEY_STREAM_WRITABLE) DCNL DCSP else: DCNL DCSP  DCSP dir_name = os.path.dirname(key_name) DCNL DCSP  DCSP if (dir_name and (not os.path.exists(dir_name))): DCNL DCSP  DCSP  DCSP os.makedirs(dir_name) DCNL DCSP  DCSP fp = open(key_name, 'wb') DCNL DCSP  DCSP return Key(self.name, key_name, fp)
def get_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False): DCNL DCSP if (self.key_type & self.KEY_STREAM_WRITABLE): DCNL DCSP  DCSP raise BotoClientError('Stream DCSP is DCSP not DCSP readable') DCNL DCSP elif (self.key_type & self.KEY_STREAM_READABLE): DCNL DCSP  DCSP key_file = self.fp DCNL DCSP else: DCNL DCSP  DCSP key_file = open(self.full_path, 'rb') DCNL DCSP try: DCNL DCSP  DCSP shutil.copyfileobj(key_file, fp) DCNL DCSP finally: DCNL DCSP  DCSP key_file.close()
def set_contents_from_file(self, fp, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None): DCNL DCSP if (self.key_type & self.KEY_STREAM_READABLE): DCNL DCSP  DCSP raise BotoClientError('Stream DCSP is DCSP not DCSP writable') DCNL DCSP elif (self.key_type & self.KEY_STREAM_WRITABLE): DCNL DCSP  DCSP key_file = self.fp DCNL DCSP else: DCNL DCSP  DCSP if ((not replace) and os.path.exists(self.full_path)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP key_file = open(self.full_path, 'wb') DCNL DCSP try: DCNL DCSP  DCSP shutil.copyfileobj(fp, key_file) DCNL DCSP finally: DCNL DCSP  DCSP key_file.close()
def get_contents_to_file(self, fp, headers=None, cb=None, num_cb=None, torrent=False, version_id=None, res_download_handler=None, response_headers=None): DCNL DCSP shutil.copyfileobj(self.fp, fp)
def get_contents_as_string(self, headers=None, cb=None, num_cb=10, torrent=False): DCNL DCSP fp = StringIO() DCNL DCSP self.get_contents_to_file(fp) DCNL DCSP return fp.getvalue()
def close(self): DCNL DCSP self.fp.close()
def _build_dict_as_list_params(self, params, dictionary, name): DCNL DCSP items = sorted(dictionary.items(), key=(lambda x: x[0])) DCNL DCSP for (kv, index) in zip(items, list(range(1, (len(items) + 1)))): DCNL DCSP  DCSP (key, value) = kv DCNL DCSP  DCSP prefix = ('%s.entry.%s' % (name, index)) DCNL DCSP  DCSP params[('%s.key' % prefix)] = key DCNL DCSP  DCSP params[('%s.value' % prefix)] = value
def get_all_topics(self, next_token=None): DCNL DCSP params = {} DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self._make_request('ListTopics', params)
def get_topic_attributes(self, topic): DCNL DCSP params = {'TopicArn': topic} DCNL DCSP return self._make_request('GetTopicAttributes', params)
def set_topic_attributes(self, topic, attr_name, attr_value): DCNL DCSP params = {'TopicArn': topic, 'AttributeName': attr_name, 'AttributeValue': attr_value} DCNL DCSP return self._make_request('SetTopicAttributes', params)
def add_permission(self, topic, label, account_ids, actions): DCNL DCSP params = {'TopicArn': topic, 'Label': label} DCNL DCSP self.build_list_params(params, account_ids, 'AWSAccountId.member') DCNL DCSP self.build_list_params(params, actions, 'ActionName.member') DCNL DCSP return self._make_request('AddPermission', params)
def remove_permission(self, topic, label): DCNL DCSP params = {'TopicArn': topic, 'Label': label} DCNL DCSP return self._make_request('RemovePermission', params)
def create_topic(self, topic): DCNL DCSP params = {'Name': topic} DCNL DCSP return self._make_request('CreateTopic', params)
def delete_topic(self, topic): DCNL DCSP params = {'TopicArn': topic} DCNL DCSP return self._make_request('DeleteTopic', params, '/', 'GET')
def publish(self, topic=None, message=None, subject=None, target_arn=None, message_structure=None, message_attributes=None): DCNL DCSP if (message is None): DCNL DCSP  DCSP raise TypeError("'message' DCSP is DCSP a DCSP required DCSP parameter") DCNL DCSP params = {'Message': message} DCNL DCSP if (subject is not None): DCNL DCSP  DCSP params['Subject'] = subject DCNL DCSP if (topic is not None): DCNL DCSP  DCSP params['TopicArn'] = topic DCNL DCSP if (target_arn is not None): DCNL DCSP  DCSP params['TargetArn'] = target_arn DCNL DCSP if (message_structure is not None): DCNL DCSP  DCSP params['MessageStructure'] = message_structure DCNL DCSP if (message_attributes is not None): DCNL DCSP  DCSP keys = sorted(message_attributes.keys()) DCNL DCSP  DCSP for (i, name) in enumerate(keys, start=1): DCNL DCSP  DCSP  DCSP attribute = message_attributes[name] DCNL DCSP  DCSP  DCSP params['MessageAttributes.entry.{0}.Name'.format(i)] = name DCNL DCSP  DCSP  DCSP if ('data_type' in attribute): DCNL DCSP  DCSP  DCSP  DCSP params['MessageAttributes.entry.{0}.Value.DataType'.format(i)] = attribute['data_type'] DCNL DCSP  DCSP  DCSP if ('string_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP params['MessageAttributes.entry.{0}.Value.StringValue'.format(i)] = attribute['string_value'] DCNL DCSP  DCSP  DCSP if ('binary_value' in attribute): DCNL DCSP  DCSP  DCSP  DCSP params['MessageAttributes.entry.{0}.Value.BinaryValue'.format(i)] = attribute['binary_value'] DCNL DCSP return self._make_request('Publish', params, '/', 'POST')
def subscribe(self, topic, protocol, endpoint): DCNL DCSP params = {'TopicArn': topic, 'Protocol': protocol, 'Endpoint': endpoint} DCNL DCSP return self._make_request('Subscribe', params)
def subscribe_sqs_queue(self, topic, queue): DCNL DCSP t = queue.id.split('/') DCNL DCSP q_arn = queue.arn DCNL DCSP sid = hashlib.md5((topic + q_arn).encode('utf-8')).hexdigest() DCNL DCSP sid_exists = False DCNL DCSP resp = self.subscribe(topic, 'sqs', q_arn) DCNL DCSP attr = queue.get_attributes('Policy') DCNL DCSP if ('Policy' in attr): DCNL DCSP  DCSP policy = json.loads(attr['Policy']) DCNL DCSP else: DCNL DCSP  DCSP policy = {} DCNL DCSP if ('Version' not in policy): DCNL DCSP  DCSP policy['Version'] = '2008-10-17' DCNL DCSP if ('Statement' not in policy): DCNL DCSP  DCSP policy['Statement'] = [] DCNL DCSP for s in policy['Statement']: DCNL DCSP  DCSP if (s['Sid'] == sid): DCNL DCSP  DCSP  DCSP sid_exists = True DCNL DCSP if (not sid_exists): DCNL DCSP  DCSP statement = {'Action': 'SQS:SendMessage', 'Effect': 'Allow', 'Principal': {'AWS': '*'}, 'Resource': q_arn, 'Sid': sid, 'Condition': {'StringLike': {'aws:SourceArn': topic}}} DCNL DCSP  DCSP policy['Statement'].append(statement) DCNL DCSP queue.set_attribute('Policy', json.dumps(policy)) DCNL DCSP return resp
def confirm_subscription(self, topic, token, authenticate_on_unsubscribe=False): DCNL DCSP params = {'TopicArn': topic, 'Token': token} DCNL DCSP if authenticate_on_unsubscribe: DCNL DCSP  DCSP params['AuthenticateOnUnsubscribe'] = 'true' DCNL DCSP return self._make_request('ConfirmSubscription', params)
def unsubscribe(self, subscription): DCNL DCSP params = {'SubscriptionArn': subscription} DCNL DCSP return self._make_request('Unsubscribe', params)
def get_all_subscriptions(self, next_token=None): DCNL DCSP params = {} DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self._make_request('ListSubscriptions', params)
def get_all_subscriptions_by_topic(self, topic, next_token=None): DCNL DCSP params = {'TopicArn': topic} DCNL DCSP if next_token: DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self._make_request('ListSubscriptionsByTopic', params)
def create_platform_application(self, name=None, platform=None, attributes=None): DCNL DCSP params = {} DCNL DCSP if (name is not None): DCNL DCSP  DCSP params['Name'] = name DCNL DCSP if (platform is not None): DCNL DCSP  DCSP params['Platform'] = platform DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP self._build_dict_as_list_params(params, attributes, 'Attributes') DCNL DCSP return self._make_request(action='CreatePlatformApplication', params=params)
def set_platform_application_attributes(self, platform_application_arn=None, attributes=None): DCNL DCSP params = {} DCNL DCSP if (platform_application_arn is not None): DCNL DCSP  DCSP params['PlatformApplicationArn'] = platform_application_arn DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP self._build_dict_as_list_params(params, attributes, 'Attributes') DCNL DCSP return self._make_request(action='SetPlatformApplicationAttributes', params=params)
def get_platform_application_attributes(self, platform_application_arn=None): DCNL DCSP params = {} DCNL DCSP if (platform_application_arn is not None): DCNL DCSP  DCSP params['PlatformApplicationArn'] = platform_application_arn DCNL DCSP return self._make_request(action='GetPlatformApplicationAttributes', params=params)
def list_platform_applications(self, next_token=None): DCNL DCSP params = {} DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self._make_request(action='ListPlatformApplications', params=params)
def list_endpoints_by_platform_application(self, platform_application_arn=None, next_token=None): DCNL DCSP params = {} DCNL DCSP if (platform_application_arn is not None): DCNL DCSP  DCSP params['PlatformApplicationArn'] = platform_application_arn DCNL DCSP if (next_token is not None): DCNL DCSP  DCSP params['NextToken'] = next_token DCNL DCSP return self._make_request(action='ListEndpointsByPlatformApplication', params=params)
def delete_platform_application(self, platform_application_arn=None): DCNL DCSP params = {} DCNL DCSP if (platform_application_arn is not None): DCNL DCSP  DCSP params['PlatformApplicationArn'] = platform_application_arn DCNL DCSP return self._make_request(action='DeletePlatformApplication', params=params)
def create_platform_endpoint(self, platform_application_arn=None, token=None, custom_user_data=None, attributes=None): DCNL DCSP params = {} DCNL DCSP if (platform_application_arn is not None): DCNL DCSP  DCSP params['PlatformApplicationArn'] = platform_application_arn DCNL DCSP if (token is not None): DCNL DCSP  DCSP params['Token'] = token DCNL DCSP if (custom_user_data is not None): DCNL DCSP  DCSP params['CustomUserData'] = custom_user_data DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP self._build_dict_as_list_params(params, attributes, 'Attributes') DCNL DCSP return self._make_request(action='CreatePlatformEndpoint', params=params)
def delete_endpoint(self, endpoint_arn=None): DCNL DCSP params = {} DCNL DCSP if (endpoint_arn is not None): DCNL DCSP  DCSP params['EndpointArn'] = endpoint_arn DCNL DCSP return self._make_request(action='DeleteEndpoint', params=params)
def set_endpoint_attributes(self, endpoint_arn=None, attributes=None): DCNL DCSP params = {} DCNL DCSP if (endpoint_arn is not None): DCNL DCSP  DCSP params['EndpointArn'] = endpoint_arn DCNL DCSP if (attributes is not None): DCNL DCSP  DCSP self._build_dict_as_list_params(params, attributes, 'Attributes') DCNL DCSP return self._make_request(action='SetEndpointAttributes', params=params)
def get_endpoint_attributes(self, endpoint_arn=None): DCNL DCSP params = {} DCNL DCSP if (endpoint_arn is not None): DCNL DCSP  DCSP params['EndpointArn'] = endpoint_arn DCNL DCSP return self._make_request(action='GetEndpointAttributes', params=params)
def __init__(self, layer2, response): DCNL DCSP self.layer2 = layer2 DCNL DCSP self._dict = {} DCNL DCSP self.update_from_response(response)
@classmethod DCNL def create_from_schema(cls, layer2, name, schema): DCNL DCSP table = cls(layer2, {'Table': {'TableName': name}}) DCNL DCSP table._schema = schema DCNL DCSP return table
def update_from_response(self, response): DCNL DCSP if ('Table' in response): DCNL DCSP  DCSP self._dict.update(response['Table']) DCNL DCSP elif ('TableDescription' in response): DCNL DCSP  DCSP self._dict.update(response['TableDescription']) DCNL DCSP if ('KeySchema' in self._dict): DCNL DCSP  DCSP self._schema = Schema(self._dict['KeySchema'])
def refresh(self, wait_for_active=False, retry_seconds=5): DCNL DCSP done = False DCNL DCSP while (not done): DCNL DCSP  DCSP response = self.layer2.describe_table(self.name) DCNL DCSP  DCSP self.update_from_response(response) DCNL DCSP  DCSP if wait_for_active: DCNL DCSP  DCSP  DCSP if (self.status == 'ACTIVE'): DCNL DCSP  DCSP  DCSP  DCSP done = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP time.sleep(retry_seconds) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP done = True
def update_throughput(self, read_units, write_units): DCNL DCSP self.layer2.update_throughput(self, read_units, write_units)
def delete(self): DCNL DCSP self.layer2.delete_table(self)
def get_item(self, hash_key, range_key=None, attributes_to_get=None, consistent_read=False, item_class=Item): DCNL DCSP return self.layer2.get_item(self, hash_key, range_key, attributes_to_get, consistent_read, item_class)
def has_item(self, hash_key, range_key=None, consistent_read=False): DCNL DCSP try: DCNL DCSP  DCSP self.get_item(hash_key, range_key=range_key, attributes_to_get=[hash_key], consistent_read=consistent_read) DCNL DCSP except dynamodb_exceptions.DynamoDBKeyNotFoundError: DCNL DCSP  DCSP return False DCNL DCSP return True
def new_item(self, hash_key=None, range_key=None, attrs=None, item_class=Item): DCNL DCSP return item_class(self, hash_key, range_key, attrs)
def query(self, hash_key, *args, **kw): DCNL DCSP return self.layer2.query(self, hash_key, *args, **kw)
def scan(self, *args, **kw): DCNL DCSP return self.layer2.scan(self, *args, **kw)
def batch_get_item(self, keys, attributes_to_get=None): DCNL DCSP return TableBatchGenerator(self, keys, attributes_to_get)
def add_attribute(self, attr_name, attr_value): DCNL DCSP self._updates[attr_name] = ('ADD', attr_value)
def delete_attribute(self, attr_name, attr_value=None): DCNL DCSP self._updates[attr_name] = ('DELETE', attr_value)
def put_attribute(self, attr_name, attr_value): DCNL DCSP self._updates[attr_name] = ('PUT', attr_value)
def save(self, expected_value=None, return_values=None): DCNL DCSP return self.table.layer2.update_item(self, expected_value, return_values)
def delete(self, expected_value=None, return_values=None): DCNL DCSP return self.table.layer2.delete_item(self, expected_value, return_values)
def put(self, expected_value=None, return_values=None): DCNL DCSP return self.table.layer2.put_item(self, expected_value, return_values)
def __setitem__(self, key, value): DCNL DCSP if (self._updates is not None): DCNL DCSP  DCSP self.put_attribute(key, value) DCNL DCSP dict.__setitem__(self, key, value)
def __delitem__(self, key): DCNL DCSP if (self._updates is not None): DCNL DCSP  DCSP self.delete_attribute(key) DCNL DCSP dict.__delitem__(self, key)
def make_request(self, action, body='', object_hook=None): DCNL DCSP headers = {'X-Amz-Target': ('%s_%s.%s' % (self.ServiceName, self.Version, action)), 'Host': self.region.endpoint, 'Content-Type': 'application/x-amz-json-1.0', 'Content-Length': str(len(body))} DCNL DCSP http_request = self.build_base_http_request('POST', '/', '/', {}, headers, body, None) DCNL DCSP start = time.time() DCNL DCSP response = self._mexe(http_request, sender=None, override_num_retries=self.NumberRetries, retry_handler=self._retry_handler) DCNL DCSP elapsed = ((time.time() - start) * 1000) DCNL DCSP request_id = response.getheader('x-amzn-RequestId') DCNL DCSP boto.log.debug(('RequestId: DCSP %s' % request_id)) DCNL DCSP boto.perflog.debug('%s: DCSP id=%s DCSP time=%sms', headers['X-Amz-Target'], request_id, int(elapsed)) DCNL DCSP response_body = response.read().decode('utf-8') DCNL DCSP boto.log.debug(response_body) DCNL DCSP return json.loads(response_body, object_hook=object_hook)
def list_tables(self, limit=None, start_table=None): DCNL DCSP data = {} DCNL DCSP if limit: DCNL DCSP  DCSP data['Limit'] = limit DCNL DCSP if start_table: DCNL DCSP  DCSP data['ExclusiveStartTableName'] = start_table DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('ListTables', json_input)
def describe_table(self, table_name): DCNL DCSP data = {'TableName': table_name} DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('DescribeTable', json_input)
def create_table(self, table_name, schema, provisioned_throughput): DCNL DCSP data = {'TableName': table_name, 'KeySchema': schema, 'ProvisionedThroughput': provisioned_throughput} DCNL DCSP json_input = json.dumps(data) DCNL DCSP response_dict = self.make_request('CreateTable', json_input) DCNL DCSP return response_dict
def update_table(self, table_name, provisioned_throughput): DCNL DCSP data = {'TableName': table_name, 'ProvisionedThroughput': provisioned_throughput} DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('UpdateTable', json_input)
def delete_table(self, table_name): DCNL DCSP data = {'TableName': table_name} DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('DeleteTable', json_input)
def get_item(self, table_name, key, attributes_to_get=None, consistent_read=False, object_hook=None): DCNL DCSP data = {'TableName': table_name, 'Key': key} DCNL DCSP if attributes_to_get: DCNL DCSP  DCSP data['AttributesToGet'] = attributes_to_get DCNL DCSP if consistent_read: DCNL DCSP  DCSP data['ConsistentRead'] = True DCNL DCSP json_input = json.dumps(data) DCNL DCSP response = self.make_request('GetItem', json_input, object_hook=object_hook) DCNL DCSP if ('Item' not in response): DCNL DCSP  DCSP raise dynamodb_exceptions.DynamoDBKeyNotFoundError('Key DCSP does DCSP not DCSP exist.') DCNL DCSP return response
def batch_get_item(self, request_items, object_hook=None): DCNL DCSP if (not request_items): DCNL DCSP  DCSP return {} DCNL DCSP data = {'RequestItems': request_items} DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('BatchGetItem', json_input, object_hook=object_hook)
def batch_write_item(self, request_items, object_hook=None): DCNL DCSP data = {'RequestItems': request_items} DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('BatchWriteItem', json_input, object_hook=object_hook)
def put_item(self, table_name, item, expected=None, return_values=None, object_hook=None): DCNL DCSP data = {'TableName': table_name, 'Item': item} DCNL DCSP if expected: DCNL DCSP  DCSP data['Expected'] = expected DCNL DCSP if return_values: DCNL DCSP  DCSP data['ReturnValues'] = return_values DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('PutItem', json_input, object_hook=object_hook)
def update_item(self, table_name, key, attribute_updates, expected=None, return_values=None, object_hook=None): DCNL DCSP data = {'TableName': table_name, 'Key': key, 'AttributeUpdates': attribute_updates} DCNL DCSP if expected: DCNL DCSP  DCSP data['Expected'] = expected DCNL DCSP if return_values: DCNL DCSP  DCSP data['ReturnValues'] = return_values DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('UpdateItem', json_input, object_hook=object_hook)
def delete_item(self, table_name, key, expected=None, return_values=None, object_hook=None): DCNL DCSP data = {'TableName': table_name, 'Key': key} DCNL DCSP if expected: DCNL DCSP  DCSP data['Expected'] = expected DCNL DCSP if return_values: DCNL DCSP  DCSP data['ReturnValues'] = return_values DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('DeleteItem', json_input, object_hook=object_hook)
def query(self, table_name, hash_key_value, range_key_conditions=None, attributes_to_get=None, limit=None, consistent_read=False, scan_index_forward=True, exclusive_start_key=None, object_hook=None, count=False): DCNL DCSP data = {'TableName': table_name, 'HashKeyValue': hash_key_value} DCNL DCSP if range_key_conditions: DCNL DCSP  DCSP data['RangeKeyCondition'] = range_key_conditions DCNL DCSP if attributes_to_get: DCNL DCSP  DCSP data['AttributesToGet'] = attributes_to_get DCNL DCSP if limit: DCNL DCSP  DCSP data['Limit'] = limit DCNL DCSP if count: DCNL DCSP  DCSP data['Count'] = True DCNL DCSP if consistent_read: DCNL DCSP  DCSP data['ConsistentRead'] = True DCNL DCSP if scan_index_forward: DCNL DCSP  DCSP data['ScanIndexForward'] = True DCNL DCSP else: DCNL DCSP  DCSP data['ScanIndexForward'] = False DCNL DCSP if exclusive_start_key: DCNL DCSP  DCSP data['ExclusiveStartKey'] = exclusive_start_key DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('Query', json_input, object_hook=object_hook)
def scan(self, table_name, scan_filter=None, attributes_to_get=None, limit=None, exclusive_start_key=None, object_hook=None, count=False): DCNL DCSP data = {'TableName': table_name} DCNL DCSP if scan_filter: DCNL DCSP  DCSP data['ScanFilter'] = scan_filter DCNL DCSP if attributes_to_get: DCNL DCSP  DCSP data['AttributesToGet'] = attributes_to_get DCNL DCSP if limit: DCNL DCSP  DCSP data['Limit'] = limit DCNL DCSP if count: DCNL DCSP  DCSP data['Count'] = True DCNL DCSP if exclusive_start_key: DCNL DCSP  DCSP data['ExclusiveStartKey'] = exclusive_start_key DCNL DCSP json_input = json.dumps(data) DCNL DCSP return self.make_request('Scan', json_input, object_hook=object_hook)
def to_dict(self): DCNL DCSP batch_dict = {} DCNL DCSP key_list = [] DCNL DCSP for key in self.keys: DCNL DCSP  DCSP if isinstance(key, tuple): DCNL DCSP  DCSP  DCSP (hash_key, range_key) = key DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP hash_key = key DCNL DCSP  DCSP  DCSP range_key = None DCNL DCSP  DCSP k = self.table.layer2.build_key_from_values(self.table.schema, hash_key, range_key) DCNL DCSP  DCSP key_list.append(k) DCNL DCSP batch_dict['Keys'] = key_list DCNL DCSP if self.attributes_to_get: DCNL DCSP  DCSP batch_dict['AttributesToGet'] = self.attributes_to_get DCNL DCSP if self.consistent_read: DCNL DCSP  DCSP batch_dict['ConsistentRead'] = True DCNL DCSP else: DCNL DCSP  DCSP batch_dict['ConsistentRead'] = False DCNL DCSP return batch_dict
def to_dict(self): DCNL DCSP op_list = [] DCNL DCSP for item in self.puts: DCNL DCSP  DCSP d = {'Item': self.table.layer2.dynamize_item(item)} DCNL DCSP  DCSP d = {'PutRequest': d} DCNL DCSP  DCSP op_list.append(d) DCNL DCSP for key in self.deletes: DCNL DCSP  DCSP if isinstance(key, tuple): DCNL DCSP  DCSP  DCSP (hash_key, range_key) = key DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP hash_key = key DCNL DCSP  DCSP  DCSP range_key = None DCNL DCSP  DCSP k = self.table.layer2.build_key_from_values(self.table.schema, hash_key, range_key) DCNL DCSP  DCSP d = {'Key': k} DCNL DCSP  DCSP op_list.append({'DeleteRequest': d}) DCNL DCSP return (self.table.name, op_list)
def add_batch(self, table, keys, attributes_to_get=None, consistent_read=False): DCNL DCSP self.append(Batch(table, keys, attributes_to_get, consistent_read))
def resubmit(self): DCNL DCSP del self[:] DCNL DCSP if (not self.unprocessed): DCNL DCSP  DCSP return None DCNL DCSP for (table_name, table_req) in six.iteritems(self.unprocessed): DCNL DCSP  DCSP table_keys = table_req['Keys'] DCNL DCSP  DCSP table = self.layer2.get_table(table_name) DCNL DCSP  DCSP keys = [] DCNL DCSP  DCSP for key in table_keys: DCNL DCSP  DCSP  DCSP h = key['HashKeyElement'] DCNL DCSP  DCSP  DCSP r = None DCNL DCSP  DCSP  DCSP if ('RangeKeyElement' in key): DCNL DCSP  DCSP  DCSP  DCSP r = key['RangeKeyElement'] DCNL DCSP  DCSP  DCSP keys.append((h, r)) DCNL DCSP  DCSP attributes_to_get = None DCNL DCSP  DCSP if ('AttributesToGet' in table_req): DCNL DCSP  DCSP  DCSP attributes_to_get = table_req['AttributesToGet'] DCNL DCSP  DCSP self.add_batch(table, keys, attributes_to_get=attributes_to_get) DCNL DCSP return self.submit()
def to_dict(self): DCNL DCSP d = {} DCNL DCSP for batch in self: DCNL DCSP  DCSP b = batch.to_dict() DCNL DCSP  DCSP if b['Keys']: DCNL DCSP  DCSP  DCSP d[batch.table.name] = b DCNL DCSP return d
def add_batch(self, table, puts=None, deletes=None): DCNL DCSP self.append(BatchWrite(table, puts, deletes))
def to_dict(self): DCNL DCSP d = {} DCNL DCSP for batch in self: DCNL DCSP  DCSP (table_name, batch_dict) = batch.to_dict() DCNL DCSP  DCSP d[table_name] = batch_dict DCNL DCSP return d
@classmethod DCNL def create(cls, hash_key, range_key=None): DCNL DCSP reconstructed = {'HashKeyElement': {'AttributeName': hash_key[0], 'AttributeType': hash_key[1]}} DCNL DCSP if (range_key is not None): DCNL DCSP  DCSP reconstructed['RangeKeyElement'] = {'AttributeName': range_key[0], 'AttributeType': range_key[1]} DCNL DCSP instance = cls(None) DCNL DCSP instance._dict = reconstructed DCNL DCSP return instance
def encode(self, attr): DCNL DCSP dynamodb_type = self._get_dynamodb_type(attr) DCNL DCSP try: DCNL DCSP  DCSP encoder = getattr(self, ('_encode_%s' % dynamodb_type.lower())) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise ValueError(('Unable DCSP to DCSP encode DCSP dynamodb DCSP type: DCSP %s' % dynamodb_type)) DCNL DCSP return {dynamodb_type: encoder(attr)}
def decode(self, attr): DCNL DCSP if ((len(attr) > 1) or (not attr) or is_str(attr)): DCNL DCSP  DCSP return attr DCNL DCSP dynamodb_type = list(attr.keys())[0] DCNL DCSP if (dynamodb_type.lower() == dynamodb_type): DCNL DCSP  DCSP return attr DCNL DCSP try: DCNL DCSP  DCSP decoder = getattr(self, ('_decode_%s' % dynamodb_type.lower())) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return attr DCNL DCSP return decoder(attr[dynamodb_type])
@property DCNL def count(self): DCNL DCSP self.response DCNL DCSP return self._count
@property DCNL def scanned_count(self): DCNL DCSP self.response DCNL DCSP return self._scanned_count
@property DCNL def consumed_units(self): DCNL DCSP self.response DCNL DCSP return self._consumed_units
@property DCNL def response(self): DCNL DCSP return (self.next_response() if (self._response is None) else self._response)
def next_response(self): DCNL DCSP limit = self.kwargs.get('limit') DCNL DCSP if ((self.remaining > 0) and ((limit is None) or (limit > self.remaining))): DCNL DCSP  DCSP self.kwargs['limit'] = self.remaining DCNL DCSP self._response = self.callable(**self.kwargs) DCNL DCSP self.kwargs['limit'] = limit DCNL DCSP self._consumed_units += self._response.get('ConsumedCapacityUnits', 0.0) DCNL DCSP self._count += self._response.get('Count', 0) DCNL DCSP self._scanned_count += self._response.get('ScannedCount', 0) DCNL DCSP if ('LastEvaluatedKey' in self._response): DCNL DCSP  DCSP lek = self._response['LastEvaluatedKey'] DCNL DCSP  DCSP esk = self.table.layer2.dynamize_last_evaluated_key(lek) DCNL DCSP  DCSP self.kwargs['exclusive_start_key'] = esk DCNL DCSP  DCSP lektuple = (lek['HashKeyElement'],) DCNL DCSP  DCSP if ('RangeKeyElement' in lek): DCNL DCSP  DCSP  DCSP lektuple += (lek['RangeKeyElement'],) DCNL DCSP  DCSP self.last_evaluated_key = lektuple DCNL DCSP else: DCNL DCSP  DCSP self.last_evaluated_key = None DCNL DCSP return self._response
def use_decimals(self, use_boolean=False): DCNL DCSP self.dynamizer = (Dynamizer() if use_boolean else NonBooleanDynamizer())
def dynamize_attribute_updates(self, pending_updates): DCNL DCSP d = {} DCNL DCSP for attr_name in pending_updates: DCNL DCSP  DCSP (action, value) = pending_updates[attr_name] DCNL DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP d[attr_name] = {'Action': action} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP d[attr_name] = {'Action': action, 'Value': self.dynamizer.encode(value)} DCNL DCSP return d
def dynamize_range_key_condition(self, range_key_condition): DCNL DCSP return range_key_condition.to_dict()
def dynamize_scan_filter(self, scan_filter): DCNL DCSP d = None DCNL DCSP if scan_filter: DCNL DCSP  DCSP d = {} DCNL DCSP  DCSP for attr_name in scan_filter: DCNL DCSP  DCSP  DCSP condition = scan_filter[attr_name] DCNL DCSP  DCSP  DCSP d[attr_name] = condition.to_dict() DCNL DCSP return d
def dynamize_expected_value(self, expected_value): DCNL DCSP d = None DCNL DCSP if expected_value: DCNL DCSP  DCSP d = {} DCNL DCSP  DCSP for attr_name in expected_value: DCNL DCSP  DCSP  DCSP attr_value = expected_value[attr_name] DCNL DCSP  DCSP  DCSP if (attr_value is True): DCNL DCSP  DCSP  DCSP  DCSP attr_value = {'Exists': True} DCNL DCSP  DCSP  DCSP elif (attr_value is False): DCNL DCSP  DCSP  DCSP  DCSP attr_value = {'Exists': False} DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP val = self.dynamizer.encode(expected_value[attr_name]) DCNL DCSP  DCSP  DCSP  DCSP attr_value = {'Value': val} DCNL DCSP  DCSP  DCSP d[attr_name] = attr_value DCNL DCSP return d
def dynamize_last_evaluated_key(self, last_evaluated_key): DCNL DCSP d = None DCNL DCSP if last_evaluated_key: DCNL DCSP  DCSP hash_key = last_evaluated_key['HashKeyElement'] DCNL DCSP  DCSP d = {'HashKeyElement': self.dynamizer.encode(hash_key)} DCNL DCSP  DCSP if ('RangeKeyElement' in last_evaluated_key): DCNL DCSP  DCSP  DCSP range_key = last_evaluated_key['RangeKeyElement'] DCNL DCSP  DCSP  DCSP d['RangeKeyElement'] = self.dynamizer.encode(range_key) DCNL DCSP return d
def build_key_from_values(self, schema, hash_key, range_key=None): DCNL DCSP dynamodb_key = {} DCNL DCSP dynamodb_value = self.dynamizer.encode(hash_key) DCNL DCSP if (list(dynamodb_value.keys())[0] != schema.hash_key_type): DCNL DCSP  DCSP msg = ('Hashkey DCSP must DCSP be DCSP of DCSP type: DCSP %s' % schema.hash_key_type) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP dynamodb_key['HashKeyElement'] = dynamodb_value DCNL DCSP if (range_key is not None): DCNL DCSP  DCSP dynamodb_value = self.dynamizer.encode(range_key) DCNL DCSP  DCSP if (list(dynamodb_value.keys())[0] != schema.range_key_type): DCNL DCSP  DCSP  DCSP msg = ('RangeKey DCSP must DCSP be DCSP of DCSP type: DCSP %s' % schema.range_key_type) DCNL DCSP  DCSP  DCSP raise TypeError(msg) DCNL DCSP  DCSP dynamodb_key['RangeKeyElement'] = dynamodb_value DCNL DCSP return dynamodb_key
def new_batch_list(self): DCNL DCSP return BatchList(self)
def new_batch_write_list(self): DCNL DCSP return BatchWriteList(self)
def list_tables(self, limit=None): DCNL DCSP tables = [] DCNL DCSP start_table = None DCNL DCSP while ((not limit) or (len(tables) < limit)): DCNL DCSP  DCSP this_round_limit = None DCNL DCSP  DCSP if limit: DCNL DCSP  DCSP  DCSP this_round_limit = (limit - len(tables)) DCNL DCSP  DCSP  DCSP this_round_limit = min(this_round_limit, 100) DCNL DCSP  DCSP result = self.layer1.list_tables(limit=this_round_limit, start_table=start_table) DCNL DCSP  DCSP tables.extend(result.get('TableNames', [])) DCNL DCSP  DCSP start_table = result.get('LastEvaluatedTableName', None) DCNL DCSP  DCSP if (not start_table): DCNL DCSP  DCSP  DCSP break DCNL DCSP return tables
def describe_table(self, name): DCNL DCSP return self.layer1.describe_table(name)
def table_from_schema(self, name, schema): DCNL DCSP return Table.create_from_schema(self, name, schema)
def get_table(self, name): DCNL DCSP response = self.layer1.describe_table(name) DCNL DCSP return Table(self, response)
def create_table(self, name, schema, read_units, write_units): DCNL DCSP response = self.layer1.create_table(name, schema.dict, {'ReadCapacityUnits': read_units, 'WriteCapacityUnits': write_units}) DCNL DCSP return Table(self, response)
def update_throughput(self, table, read_units, write_units): DCNL DCSP response = self.layer1.update_table(table.name, {'ReadCapacityUnits': read_units, 'WriteCapacityUnits': write_units}) DCNL DCSP table.update_from_response(response)
def delete_table(self, table): DCNL DCSP response = self.layer1.delete_table(table.name) DCNL DCSP table.update_from_response(response)
def create_schema(self, hash_key_name, hash_key_proto_value, range_key_name=None, range_key_proto_value=None): DCNL DCSP hash_key = (hash_key_name, get_dynamodb_type(hash_key_proto_value)) DCNL DCSP if (range_key_name and (range_key_proto_value is not None)): DCNL DCSP  DCSP range_key = (range_key_name, get_dynamodb_type(range_key_proto_value)) DCNL DCSP else: DCNL DCSP  DCSP range_key = None DCNL DCSP return Schema.create(hash_key, range_key)
def get_item(self, table, hash_key, range_key=None, attributes_to_get=None, consistent_read=False, item_class=Item): DCNL DCSP key = self.build_key_from_values(table.schema, hash_key, range_key) DCNL DCSP response = self.layer1.get_item(table.name, key, attributes_to_get, consistent_read, object_hook=self.dynamizer.decode) DCNL DCSP item = item_class(table, hash_key, range_key, response['Item']) DCNL DCSP if ('ConsumedCapacityUnits' in response): DCNL DCSP  DCSP item.consumed_units = response['ConsumedCapacityUnits'] DCNL DCSP return item
def batch_get_item(self, batch_list): DCNL DCSP request_items = batch_list.to_dict() DCNL DCSP return self.layer1.batch_get_item(request_items, object_hook=self.dynamizer.decode)
def batch_write_item(self, batch_list): DCNL DCSP request_items = batch_list.to_dict() DCNL DCSP return self.layer1.batch_write_item(request_items, object_hook=self.dynamizer.decode)
def put_item(self, item, expected_value=None, return_values=None): DCNL DCSP expected_value = self.dynamize_expected_value(expected_value) DCNL DCSP response = self.layer1.put_item(item.table.name, self.dynamize_item(item), expected_value, return_values, object_hook=self.dynamizer.decode) DCNL DCSP if ('ConsumedCapacityUnits' in response): DCNL DCSP  DCSP item.consumed_units = response['ConsumedCapacityUnits'] DCNL DCSP return response
def update_item(self, item, expected_value=None, return_values=None): DCNL DCSP expected_value = self.dynamize_expected_value(expected_value) DCNL DCSP key = self.build_key_from_values(item.table.schema, item.hash_key, item.range_key) DCNL DCSP attr_updates = self.dynamize_attribute_updates(item._updates) DCNL DCSP response = self.layer1.update_item(item.table.name, key, attr_updates, expected_value, return_values, object_hook=self.dynamizer.decode) DCNL DCSP item._updates.clear() DCNL DCSP if ('ConsumedCapacityUnits' in response): DCNL DCSP  DCSP item.consumed_units = response['ConsumedCapacityUnits'] DCNL DCSP return response
def delete_item(self, item, expected_value=None, return_values=None): DCNL DCSP expected_value = self.dynamize_expected_value(expected_value) DCNL DCSP key = self.build_key_from_values(item.table.schema, item.hash_key, item.range_key) DCNL DCSP return self.layer1.delete_item(item.table.name, key, expected=expected_value, return_values=return_values, object_hook=self.dynamizer.decode)
def query(self, table, hash_key, range_key_condition=None, attributes_to_get=None, request_limit=None, max_results=None, consistent_read=False, scan_index_forward=True, exclusive_start_key=None, item_class=Item, count=False): DCNL DCSP if range_key_condition: DCNL DCSP  DCSP rkc = self.dynamize_range_key_condition(range_key_condition) DCNL DCSP else: DCNL DCSP  DCSP rkc = None DCNL DCSP if exclusive_start_key: DCNL DCSP  DCSP esk = self.build_key_from_values(table.schema, *exclusive_start_key) DCNL DCSP else: DCNL DCSP  DCSP esk = None DCNL DCSP kwargs = {'table_name': table.name, 'hash_key_value': self.dynamizer.encode(hash_key), 'range_key_conditions': rkc, 'attributes_to_get': attributes_to_get, 'limit': request_limit, 'count': count, 'consistent_read': consistent_read, 'scan_index_forward': scan_index_forward, 'exclusive_start_key': esk, 'object_hook': self.dynamizer.decode} DCNL DCSP return TableGenerator(table, self.layer1.query, max_results, item_class, kwargs)
def scan(self, table, scan_filter=None, attributes_to_get=None, request_limit=None, max_results=None, exclusive_start_key=None, item_class=Item, count=False): DCNL DCSP if exclusive_start_key: DCNL DCSP  DCSP esk = self.build_key_from_values(table.schema, *exclusive_start_key) DCNL DCSP else: DCNL DCSP  DCSP esk = None DCNL DCSP kwargs = {'table_name': table.name, 'scan_filter': self.dynamize_scan_filter(scan_filter), 'attributes_to_get': attributes_to_get, 'limit': request_limit, 'count': count, 'exclusive_start_key': esk, 'object_hook': self.dynamizer.decode} DCNL DCSP return TableGenerator(table, self.layer1.scan, max_results, item_class, kwargs)
def is_package(self, fullname): DCNL DCSP return hasattr(self.__get_module(fullname), '__path__')
def get_code(self, fullname): DCNL DCSP self.__get_module(fullname) DCNL DCSP return None
def construct_endpoint(self, service_name, region_name=None): DCNL DCSP raise NotImplementedError
def get_available_partitions(self): DCNL DCSP raise NotImplementedError
def get_available_endpoints(self, service_name, partition_name='aws', allow_non_regional=False): DCNL DCSP raise NotImplementedError
def __init__(self, endpoint_data): DCNL DCSP if ('partitions' not in endpoint_data): DCNL DCSP  DCSP raise ValueError('Missing DCSP "partitions" DCSP in DCSP endpoint DCSP data') DCNL DCSP self._endpoint_data = endpoint_data
def __init__(self, host, config, provider): DCNL DCSP pass
def add_auth(self, http_request): DCNL DCSP pass
def setup_class(cls): DCNL DCSP cls.objs = [] DCNL DCSP o = SimpleModel() DCNL DCSP o.name = 'Simple DCSP Object' DCNL DCSP o.strs = ['B', 'A', 'C', 'Foo'] DCNL DCSP o.num = 1 DCNL DCSP o.put() DCNL DCSP cls.objs.append(o) DCNL DCSP o2 = SimpleModel() DCNL DCSP o2.name = 'Referenced DCSP Object' DCNL DCSP o2.num = 2 DCNL DCSP o2.put() DCNL DCSP cls.objs.append(o2) DCNL DCSP o3 = SubModel() DCNL DCSP o3.name = 'Sub DCSP Object' DCNL DCSP o3.num = 3 DCNL DCSP o3.ref = o2 DCNL DCSP o3.put() DCNL DCSP cls.objs.append(o3) DCNL DCSP time.sleep(3)
def teardown_class(cls): DCNL DCSP for o in cls.objs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP o.delete() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass
def test_find(self): DCNL DCSP assert (SimpleModel.find(name='Simple DCSP Object').next().id == self.objs[0].id) DCNL DCSP assert (SimpleModel.find(name='Referenced DCSP Object').next().id == self.objs[1].id) DCNL DCSP assert (SimpleModel.find(name='Sub DCSP Object').next().id == self.objs[2].id)
def test_like_filter(self): DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('name DCSP like', '% DCSP Object') DCNL DCSP assert (query.count() == 3) DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('name DCSP not DCSP like', '% DCSP Object') DCNL DCSP assert (query.count() == 0)
def test_equals_filter(self): DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('name DCSP =', 'Simple DCSP Object') DCNL DCSP assert (query.count() == 1) DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('name DCSP !=', 'Simple DCSP Object') DCNL DCSP assert (query.count() == 2)
def test_or_filter(self): DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('name DCSP =', ['Simple DCSP Object', 'Sub DCSP Object']) DCNL DCSP assert (query.count() == 2)
def test_and_filter(self): DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('name DCSP like', '% DCSP Object') DCNL DCSP query.filter('name DCSP like', 'Simple DCSP %') DCNL DCSP assert (query.count() == 1)
def test_none_filter(self): DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('ref DCSP =', None) DCNL DCSP assert (query.count() == 2)
def test_greater_filter(self): DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('num DCSP >', 1) DCNL DCSP assert (query.count() == 2) DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('num DCSP >=', 1) DCNL DCSP assert (query.count() == 3)
def test_less_filter(self): DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('num DCSP <', 3) DCNL DCSP assert (query.count() == 2) DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('num DCSP <=', 3) DCNL DCSP assert (query.count() == 3)
def test_query_on_list(self): DCNL DCSP assert (SimpleModel.find(strs='A').next().id == self.objs[0].id) DCNL DCSP assert (SimpleModel.find(strs='B').next().id == self.objs[0].id) DCNL DCSP assert (SimpleModel.find(strs='C').next().id == self.objs[0].id)
def test_like(self): DCNL DCSP query = SimpleModel.all() DCNL DCSP query.filter('strs DCSP like', '%oo%') DCNL DCSP print query.get_query() DCNL DCSP assert (query.count() == 1)
def setup_class(cls): DCNL DCSP cls.objs = []
def teardown_class(cls): DCNL DCSP for o in cls.objs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP o.delete() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass
def test_list_order(self): DCNL DCSP t = SimpleListModel() DCNL DCSP t.nums = [5, 4, 1, 3, 2] DCNL DCSP t.strs = ['B', 'C', 'A', 'D', 'Foo'] DCNL DCSP t.put() DCNL DCSP self.objs.append(t) DCNL DCSP time.sleep(3) DCNL DCSP t = SimpleListModel.get_by_id(t.id) DCNL DCSP assert (t.nums == [5, 4, 1, 3, 2]) DCNL DCSP assert (t.strs == ['B', 'C', 'A', 'D', 'Foo'])
def test_old_compat(self): DCNL DCSP t = SimpleListModel() DCNL DCSP t.put() DCNL DCSP self.objs.append(t) DCNL DCSP time.sleep(3) DCNL DCSP item = t._get_raw_item() DCNL DCSP item['strs'] = ['A', 'B', 'C'] DCNL DCSP item.save() DCNL DCSP time.sleep(3) DCNL DCSP t = SimpleListModel.get_by_id(t.id) DCNL DCSP i1 = sorted(item['strs']) DCNL DCSP i2 = t.strs DCNL DCSP i2.sort() DCNL DCSP assert (i1 == i2)
def test_query_equals(self): DCNL DCSP t = SimpleListModel() DCNL DCSP t.strs = ['Bizzle', 'Bar'] DCNL DCSP t.put() DCNL DCSP self.objs.append(t) DCNL DCSP time.sleep(3) DCNL DCSP assert (SimpleListModel.find(strs='Bizzle').count() == 1) DCNL DCSP assert (SimpleListModel.find(strs='Bar').count() == 1) DCNL DCSP assert (SimpleListModel.find(strs=['Bar', 'Bizzle']).count() == 1)
def test_query_not_equals(self): DCNL DCSP t = SimpleListModel() DCNL DCSP t.strs = ['Fizzle'] DCNL DCSP t.put() DCNL DCSP self.objs.append(t) DCNL DCSP time.sleep(3) DCNL DCSP print SimpleListModel.all().filter('strs DCSP !=', 'Fizzle').get_query() DCNL DCSP for tt in SimpleListModel.all().filter('strs DCSP !=', 'Fizzle'): DCNL DCSP  DCSP print tt.strs DCNL DCSP  DCSP assert ('Fizzle' not in tt.strs)
def setup_class(cls): DCNL DCSP cls.sequences = []
def teardown_class(cls): DCNL DCSP for s in cls.sequences: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s.delete() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass
def test_sequence_generator_no_rollover(self): DCNL DCSP from boto.sdb.db.sequence import SequenceGenerator DCNL DCSP gen = SequenceGenerator('ABC') DCNL DCSP assert (gen('') == 'A') DCNL DCSP assert (gen('A') == 'B') DCNL DCSP assert (gen('B') == 'C') DCNL DCSP assert (gen('C') == 'AA') DCNL DCSP assert (gen('AC') == 'BA')
def test_sequence_generator_with_rollover(self): DCNL DCSP from boto.sdb.db.sequence import SequenceGenerator DCNL DCSP gen = SequenceGenerator('ABC', rollover=True) DCNL DCSP assert (gen('') == 'A') DCNL DCSP assert (gen('A') == 'B') DCNL DCSP assert (gen('B') == 'C') DCNL DCSP assert (gen('C') == 'A')
def test_sequence_simple_int(self): DCNL DCSP from boto.sdb.db.sequence import Sequence DCNL DCSP s = Sequence() DCNL DCSP self.sequences.append(s) DCNL DCSP assert (s.val == 0) DCNL DCSP assert (s.next() == 1) DCNL DCSP assert (s.next() == 2) DCNL DCSP s2 = Sequence(s.id) DCNL DCSP assert (s2.val == 2) DCNL DCSP assert (s.next() == 3) DCNL DCSP assert (s.val == 3) DCNL DCSP assert (s2.val == 3)
def test_fib(self): DCNL DCSP from boto.sdb.db.sequence import fib DCNL DCSP lv = 0 DCNL DCSP for v in [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]: DCNL DCSP  DCSP assert (fib(v, lv) == (lv + v)) DCNL DCSP  DCSP lv = fib(v, lv)
def test_sequence_fib(self): DCNL DCSP from boto.sdb.db.sequence import Sequence, fib DCNL DCSP s = Sequence(fnc=fib) DCNL DCSP s2 = Sequence(s.id) DCNL DCSP self.sequences.append(s) DCNL DCSP assert (s.val == 1) DCNL DCSP for v in [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]: DCNL DCSP  DCSP assert (s.next() == v) DCNL DCSP  DCSP assert (s.val == v) DCNL DCSP  DCSP assert (s2.val == v)
def test_sequence_string(self): DCNL DCSP from boto.sdb.db.sequence import Sequence, increment_string DCNL DCSP s = Sequence(fnc=increment_string) DCNL DCSP self.sequences.append(s) DCNL DCSP assert (s.val == 'A') DCNL DCSP assert (s.next() == 'B') DCNL DCSP s.val = 'Z' DCNL DCSP assert (s.val == 'Z') DCNL DCSP assert (s.next() == 'AA')
def set_etag(self): DCNL DCSP m = md5() DCNL DCSP if (not isinstance(self.data, bytes)): DCNL DCSP  DCSP m.update(self.data.encode('utf-8')) DCNL DCSP else: DCNL DCSP  DCSP m.update(self.data) DCNL DCSP hex_md5 = m.hexdigest() DCNL DCSP self.etag = hex_md5
def compute_md5(self, fp): DCNL DCSP tup = compute_md5(fp) DCNL DCSP self.size = tup[2] DCNL DCSP return tup[0:2]
def __repr__(self): DCNL DCSP return self.uri
def test_tagging_from_objects(self): DCNL DCSP t = Tags() DCNL DCSP tag_set = TagSet() DCNL DCSP tag_set.add_tag('akey', 'avalue') DCNL DCSP tag_set.add_tag('anotherkey', 'anothervalue') DCNL DCSP t.add_tag_set(tag_set) DCNL DCSP self.bucket.set_tags(t) DCNL DCSP response = self.bucket.get_tags() DCNL DCSP tags = sorted(response[0], key=(lambda tag: tag.key)) DCNL DCSP self.assertEqual(tags[0].key, 'akey') DCNL DCSP self.assertEqual(tags[0].value, 'avalue') DCNL DCSP self.assertEqual(tags[1].key, 'anotherkey') DCNL DCSP self.assertEqual(tags[1].value, 'anothervalue')
def testSetAclXml(self): DCNL DCSP b = self._MakeBucket() DCNL DCSP k = b.new_key('obj') DCNL DCSP k.set_contents_from_string('stringdata') DCNL DCSP bucket_uri = storage_uri(('gs://%s/' % b.name)) DCNL DCSP bucket_uri.object_name = 'obj' DCNL DCSP bucket_acl = bucket_uri.get_acl() DCNL DCSP bucket_uri.object_name = None DCNL DCSP all_users_read_permission = "<Entry><Scope DCSP type='AllUsers'/><Permission>READ</Permission></Entry>" DCNL DCSP acl_string = re.sub('</Entries>', (all_users_read_permission + '</Entries>'), bucket_acl.to_xml()) DCNL DCSP acl_no_owner_string = re.sub('<Owner>.*</Owner>', '', acl_string) DCNL DCSP bucket_uri.set_xml_acl(acl_string, 'obj') DCNL DCSP bucket_uri.set_xml_acl(acl_no_owner_string) DCNL DCSP bucket_uri.set_def_xml_acl(acl_no_owner_string) DCNL DCSP new_obj_acl_string = k.get_acl().to_xml() DCNL DCSP new_bucket_acl_string = bucket_uri.get_acl().to_xml() DCNL DCSP new_bucket_def_acl_string = bucket_uri.get_def_acl().to_xml() DCNL DCSP self.assertRegexpMatches(new_obj_acl_string, 'AllUsers') DCNL DCSP self.assertRegexpMatches(new_bucket_acl_string, 'AllUsers') DCNL DCSP self.assertRegexpMatches(new_bucket_def_acl_string, 'AllUsers')
def test_non_resumable_upload(self): DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0, os.SEEK_END) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP try: DCNL DCSP  DCSP dst_key.set_contents_from_file(small_src_file) DCNL DCSP  DCSP self.fail('should DCSP fail DCSP as DCSP need DCSP to DCSP rewind DCSP the DCSP filepointer') DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP dst_key.set_contents_from_file(small_src_file, rewind=True) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(small_src_file_as_string, dst_key.get_contents_as_string())
def test_upload_without_persistent_tracker(self): DCNL DCSP res_upload_handler = ResumableUploadHandler() DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(small_src_file, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(small_src_file_as_string, dst_key.get_contents_as_string())
def test_failed_upload_with_persistent_tracker(self): DCNL DCSP harness = CallbackTestHarness() DCNL DCSP tracker_file_name = self.make_tracker_file() DCNL DCSP res_upload_handler = ResumableUploadHandler(tracker_file_name=tracker_file_name, num_retries=0) DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP try: DCNL DCSP  DCSP dst_key.set_contents_from_file(small_src_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP ResumableUploadException') DCNL DCSP except ResumableUploadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT_CUR_PROCESS) DCNL DCSP  DCSP self.assertTrue(os.path.exists(tracker_file_name)) DCNL DCSP  DCSP f = open(tracker_file_name) DCNL DCSP  DCSP uri_from_file = f.readline().strip() DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP self.assertEqual(uri_from_file, res_upload_handler.get_tracker_uri())
def test_retryable_exception_recovery(self): DCNL DCSP exception = ResumableUploadHandler.RETRYABLE_EXCEPTIONS[0] DCNL DCSP harness = CallbackTestHarness(exception=exception) DCNL DCSP res_upload_handler = ResumableUploadHandler(num_retries=1) DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(small_src_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(small_src_file_as_string, dst_key.get_contents_as_string())
def test_broken_pipe_recovery(self): DCNL DCSP exception = IOError(errno.EPIPE, 'Broken DCSP pipe') DCNL DCSP harness = CallbackTestHarness(exception=exception) DCNL DCSP res_upload_handler = ResumableUploadHandler(num_retries=1) DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(small_src_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(small_src_file_as_string, dst_key.get_contents_as_string())
def test_non_retryable_exception_handling(self): DCNL DCSP harness = CallbackTestHarness(exception=OSError(errno.EACCES, 'Permission DCSP denied')) DCNL DCSP res_upload_handler = ResumableUploadHandler(num_retries=1) DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP try: DCNL DCSP  DCSP dst_key.set_contents_from_file(small_src_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP OSError') DCNL DCSP except OSError as e: DCNL DCSP  DCSP self.assertEqual(e.errno, 13)
def test_failed_and_restarted_upload_with_persistent_tracker(self): DCNL DCSP harness = CallbackTestHarness() DCNL DCSP tracker_file_name = self.make_tracker_file() DCNL DCSP res_upload_handler = ResumableUploadHandler(tracker_file_name=tracker_file_name, num_retries=1) DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(small_src_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(small_src_file_as_string, dst_key.get_contents_as_string()) DCNL DCSP self.assertFalse(os.path.exists(tracker_file_name))
def test_multiple_in_process_failures_then_succeed(self): DCNL DCSP res_upload_handler = ResumableUploadHandler(num_retries=3) DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(small_src_file, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(small_src_file_as_string, dst_key.get_contents_as_string())
def test_multiple_in_process_failures_then_succeed_with_tracker_file(self): DCNL DCSP harness = CallbackTestHarness(fail_after_n_bytes=(LARGE_KEY_SIZE / 2), num_times_to_fail=2) DCNL DCSP tracker_file_name = self.make_tracker_file() DCNL DCSP res_upload_handler = ResumableUploadHandler(tracker_file_name=tracker_file_name, num_retries=1) DCNL DCSP (larger_src_file_as_string, larger_src_file) = self.make_large_file() DCNL DCSP larger_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP try: DCNL DCSP  DCSP dst_key.set_contents_from_file(larger_src_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP ResumableUploadException') DCNL DCSP except ResumableUploadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT_CUR_PROCESS) DCNL DCSP  DCSP self.assertTrue(os.path.exists(tracker_file_name)) DCNL DCSP larger_src_file.seek(0) DCNL DCSP dst_key.set_contents_from_file(larger_src_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(LARGE_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(larger_src_file_as_string, dst_key.get_contents_as_string()) DCNL DCSP self.assertFalse(os.path.exists(tracker_file_name)) DCNL DCSP self.assertTrue(((len(harness.transferred_seq_before_first_failure) > 1) and (len(harness.transferred_seq_after_first_failure) > 1)))
def test_upload_with_inital_partial_upload_before_failure(self): DCNL DCSP harness = CallbackTestHarness(fail_after_n_bytes=(LARGE_KEY_SIZE / 2)) DCNL DCSP res_upload_handler = ResumableUploadHandler(num_retries=1) DCNL DCSP (larger_src_file_as_string, larger_src_file) = self.make_large_file() DCNL DCSP larger_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(larger_src_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(LARGE_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(larger_src_file_as_string, dst_key.get_contents_as_string()) DCNL DCSP self.assertTrue(((len(harness.transferred_seq_before_first_failure) > 1) and (len(harness.transferred_seq_after_first_failure) > 1)))
def test_empty_file_upload(self): DCNL DCSP res_upload_handler = ResumableUploadHandler() DCNL DCSP empty_src_file = StringIO.StringIO('') DCNL DCSP empty_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(empty_src_file, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(0, dst_key.size)
def test_upload_retains_metadata(self): DCNL DCSP res_upload_handler = ResumableUploadHandler() DCNL DCSP headers = {'Content-Type': 'text/plain', 'x-goog-meta-abc': 'my DCSP meta', 'x-goog-acl': 'public-read'} DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(small_src_file, headers=headers, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(small_src_file_as_string, dst_key.get_contents_as_string()) DCNL DCSP dst_key.open_read() DCNL DCSP self.assertEqual('text/plain', dst_key.content_type) DCNL DCSP self.assertTrue(('abc' in dst_key.metadata)) DCNL DCSP self.assertEqual('my DCSP meta', str(dst_key.metadata['abc'])) DCNL DCSP acl = dst_key.get_acl() DCNL DCSP for entry in acl.entries.entry_list: DCNL DCSP  DCSP if (str(entry.scope) == '<AllUsers>'): DCNL DCSP  DCSP  DCSP self.assertEqual('READ', str(acl.entries.entry_list[1].permission)) DCNL DCSP  DCSP  DCSP return DCNL DCSP self.fail('No DCSP <AllUsers> DCSP scope DCSP found')
def test_upload_with_file_size_change_between_starts(self): DCNL DCSP harness = CallbackTestHarness(fail_after_n_bytes=(LARGE_KEY_SIZE / 2)) DCNL DCSP tracker_file_name = self.make_tracker_file() DCNL DCSP res_upload_handler = ResumableUploadHandler(tracker_file_name=tracker_file_name, num_retries=0) DCNL DCSP (larger_src_file_as_string, larger_src_file) = self.make_large_file() DCNL DCSP larger_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP try: DCNL DCSP  DCSP dst_key.set_contents_from_file(larger_src_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP ResumableUploadException') DCNL DCSP except ResumableUploadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT_CUR_PROCESS) DCNL DCSP  DCSP self.assertTrue(os.path.exists(tracker_file_name)) DCNL DCSP time.sleep(1) DCNL DCSP try: DCNL DCSP  DCSP largest_src_file = self.build_input_file(LARGEST_KEY_SIZE)[1] DCNL DCSP  DCSP largest_src_file.seek(0) DCNL DCSP  DCSP dst_key.set_contents_from_file(largest_src_file, res_upload_handler=res_upload_handler) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP ResumableUploadException') DCNL DCSP except ResumableUploadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT) DCNL DCSP  DCSP self.assertNotEqual(e.message.find('file DCSP size DCSP changed'), (-1), e.message)
def test_upload_with_file_size_change_during_upload(self): DCNL DCSP test_file_size = (500 * 1024) DCNL DCSP test_file = self.build_input_file(test_file_size)[1] DCNL DCSP harness = CallbackTestHarness(fp_to_change=test_file, fp_change_pos=test_file_size) DCNL DCSP res_upload_handler = ResumableUploadHandler(num_retries=1) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP try: DCNL DCSP  DCSP dst_key.set_contents_from_file(test_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP ResumableUploadException') DCNL DCSP except ResumableUploadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT) DCNL DCSP  DCSP self.assertNotEqual(e.message.find('File DCSP changed DCSP during DCSP upload'), (-1))
def test_upload_with_file_content_change_during_upload(self): DCNL DCSP def Execute(): DCNL DCSP  DCSP res_upload_handler = ResumableUploadHandler(num_retries=1) DCNL DCSP  DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP  DCSP bucket_uri = storage_uri(('gs://' + dst_key.bucket.name)) DCNL DCSP  DCSP dst_key_uri = bucket_uri.clone_replace_name(dst_key.name) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP dst_key.set_contents_from_file(test_file, cb=harness.call, res_upload_handler=res_upload_handler) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ResumableUploadException as e: DCNL DCSP  DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT) DCNL DCSP  DCSP  DCSP test_file.seek(0, os.SEEK_END) DCNL DCSP  DCSP  DCSP self.assertEqual(test_file_size, test_file.tell()) DCNL DCSP  DCSP  DCSP self.assertNotEqual(e.message.find("md5 DCSP signature DCSP doesn't DCSP match DCSP etag"), (-1)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP dst_key_uri.get_key() DCNL DCSP  DCSP  DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP InvalidUriError') DCNL DCSP  DCSP  DCSP except InvalidUriError as e: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return True DCNL DCSP test_file_size = (500 * 1024) DCNL DCSP n_bytes = (300 * 1024) DCNL DCSP delay = 0 DCNL DCSP for attempt in range(2): DCNL DCSP  DCSP test_file = self.build_input_file(test_file_size)[1] DCNL DCSP  DCSP harness = CallbackTestHarness(fail_after_n_bytes=n_bytes, fp_to_change=test_file, fp_change_pos=1, delay_after_change=delay) DCNL DCSP  DCSP if Execute(): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if ((attempt == 0) and (0 in harness.transferred_seq_after_first_failure)): DCNL DCSP  DCSP  DCSP delay = 15 DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP ResumableUploadException')
def test_upload_with_content_length_header_set(self): DCNL DCSP res_upload_handler = ResumableUploadHandler() DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP try: DCNL DCSP  DCSP dst_key.set_contents_from_file(small_src_file, res_upload_handler=res_upload_handler, headers={'Content-Length': SMALL_KEY_SIZE}) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP ResumableUploadException') DCNL DCSP except ResumableUploadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT) DCNL DCSP  DCSP self.assertNotEqual(e.message.find('Attempt DCSP to DCSP specify DCSP Content-Length DCSP header'), (-1))
def test_upload_with_syntactically_invalid_tracker_uri(self): DCNL DCSP tmp_dir = self._MakeTempDir() DCNL DCSP syntactically_invalid_tracker_file_name = os.path.join(tmp_dir, 'synt_invalid_uri_tracker') DCNL DCSP with open(syntactically_invalid_tracker_file_name, 'w') as f: DCNL DCSP  DCSP f.write('ftp://example.com') DCNL DCSP res_upload_handler = ResumableUploadHandler(tracker_file_name=syntactically_invalid_tracker_file_name) DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(small_src_file, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(small_src_file_as_string, dst_key.get_contents_as_string())
def test_upload_with_invalid_upload_id_in_tracker_file(self): DCNL DCSP invalid_upload_id = 'http://pub.storage.googleapis.com/?upload_id=AyzB2Uo74W4EYxyi5dp_-r68jz8rtbvshsv4TX7srJVkJ57CxTY5Dw2' DCNL DCSP tmpdir = self._MakeTempDir() DCNL DCSP invalid_upload_id_tracker_file_name = os.path.join(tmpdir, 'invalid_upload_id_tracker') DCNL DCSP with open(invalid_upload_id_tracker_file_name, 'w') as f: DCNL DCSP  DCSP f.write(invalid_upload_id) DCNL DCSP res_upload_handler = ResumableUploadHandler(tracker_file_name=invalid_upload_id_tracker_file_name) DCNL DCSP (small_src_file_as_string, small_src_file) = self.make_small_file() DCNL DCSP small_src_file.seek(0) DCNL DCSP dst_key = self._MakeKey(set_contents=False) DCNL DCSP dst_key.set_contents_from_file(small_src_file, res_upload_handler=res_upload_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, dst_key.size) DCNL DCSP self.assertEqual(small_src_file_as_string, dst_key.get_contents_as_string()) DCNL DCSP self.assertNotEqual(invalid_upload_id, res_upload_handler.get_tracker_uri())
def test_upload_with_unwritable_tracker_file(self): DCNL DCSP tmp_dir = self._MakeTempDir() DCNL DCSP tracker_file_name = self.make_tracker_file(tmp_dir) DCNL DCSP save_mod = os.stat(tmp_dir).st_mode DCNL DCSP try: DCNL DCSP  DCSP os.chmod(tmp_dir, 0) DCNL DCSP  DCSP res_upload_handler = ResumableUploadHandler(tracker_file_name=tracker_file_name) DCNL DCSP except ResumableUploadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT) DCNL DCSP  DCSP self.assertNotEqual(e.message.find("Couldn't DCSP write DCSP URI DCSP tracker DCSP file"), (-1)) DCNL DCSP finally: DCNL DCSP  DCSP os.chmod(tmp_dir, save_mod)
def _GetConnection(self): DCNL DCSP return self._conn
def _MakeTempName(self): DCNL DCSP return ('boto-gs-test-%s' % repr(time.time()).replace('.', '-'))
def _MakeBucketName(self): DCNL DCSP b = self._MakeTempName() DCNL DCSP self._buckets.append(b) DCNL DCSP return b
def _MakeBucket(self): DCNL DCSP b = self._conn.create_bucket(self._MakeBucketName()) DCNL DCSP return b
def _MakeKey(self, data='', bucket=None, set_contents=True): DCNL DCSP if (data and (not set_contents)): DCNL DCSP  DCSP raise ValueError('MakeKey DCSP called DCSP with DCSP a DCSP non-empty DCSP data DCSP parameter DCSP but DCSP set_contents DCSP was DCSP set DCSP to DCSP False.') DCNL DCSP if (not bucket): DCNL DCSP  DCSP bucket = self._MakeBucket() DCNL DCSP key_name = self._MakeTempName() DCNL DCSP k = bucket.new_key(key_name) DCNL DCSP if set_contents: DCNL DCSP  DCSP k.set_contents_from_string(data) DCNL DCSP return k
def _MakeVersionedBucket(self): DCNL DCSP b = self._MakeBucket() DCNL DCSP b.configure_versioning(True) DCNL DCSP time.sleep(30) DCNL DCSP return b
def _MakeTempDir(self): DCNL DCSP tmpdir = tempfile.mkdtemp(prefix=self._MakeTempName()) DCNL DCSP self._tempdirs.append(tmpdir) DCNL DCSP return tmpdir
def call(self, total_bytes_transferred, unused_total_size): DCNL DCSP if self.num_failures: DCNL DCSP  DCSP self.transferred_seq_after_first_failure.append(total_bytes_transferred) DCNL DCSP else: DCNL DCSP  DCSP self.transferred_seq_before_first_failure.append(total_bytes_transferred) DCNL DCSP if ((total_bytes_transferred >= self.fail_after_n_bytes) and (self.num_failures < self.num_times_to_fail)): DCNL DCSP  DCSP self.num_failures += 1 DCNL DCSP  DCSP if (self.fp_to_change and (self.fp_change_pos is not None)): DCNL DCSP  DCSP  DCSP cur_pos = self.fp_to_change.tell() DCNL DCSP  DCSP  DCSP self.fp_to_change.seek(self.fp_change_pos) DCNL DCSP  DCSP  DCSP self.fp_to_change.write('abc') DCNL DCSP  DCSP  DCSP self.fp_to_change.seek(cur_pos) DCNL DCSP  DCSP  DCSP if self.delay_after_change: DCNL DCSP  DCSP  DCSP  DCSP time.sleep(self.delay_after_change) DCNL DCSP  DCSP self.called = True DCNL DCSP  DCSP raise self.exception
def test_non_resumable_download(self): DCNL DCSP dst_fp = self.make_dst_fp() DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP small_src_key.get_contents_to_file(dst_fp) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(small_src_key_as_string, small_src_key.get_contents_as_string())
def test_download_without_persistent_tracker(self): DCNL DCSP res_download_handler = ResumableDownloadHandler() DCNL DCSP dst_fp = self.make_dst_fp() DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP small_src_key.get_contents_to_file(dst_fp, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(small_src_key_as_string, small_src_key.get_contents_as_string())
def test_failed_download_with_persistent_tracker(self): DCNL DCSP harness = CallbackTestHarness() DCNL DCSP tmpdir = self._MakeTempDir() DCNL DCSP tracker_file_name = self.make_tracker_file(tmpdir) DCNL DCSP dst_fp = self.make_dst_fp(tmpdir) DCNL DCSP res_download_handler = ResumableDownloadHandler(tracker_file_name=tracker_file_name, num_retries=0) DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP try: DCNL DCSP  DCSP small_src_key.get_contents_to_file(dst_fp, cb=harness.call, res_download_handler=res_download_handler) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP ResumableDownloadException') DCNL DCSP except ResumableDownloadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT_CUR_PROCESS) DCNL DCSP  DCSP self.assertTrue(os.path.exists(tracker_file_name)) DCNL DCSP  DCSP f = open(tracker_file_name) DCNL DCSP  DCSP etag_line = f.readline() DCNL DCSP  DCSP self.assertEquals(etag_line.rstrip('\n'), small_src_key.etag.strip('"\''))
def test_retryable_exception_recovery(self): DCNL DCSP exception = ResumableDownloadHandler.RETRYABLE_EXCEPTIONS[0] DCNL DCSP harness = CallbackTestHarness(exception=exception) DCNL DCSP res_download_handler = ResumableDownloadHandler(num_retries=1) DCNL DCSP dst_fp = self.make_dst_fp() DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP small_src_key.get_contents_to_file(dst_fp, cb=harness.call, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(small_src_key_as_string, small_src_key.get_contents_as_string())
def test_broken_pipe_recovery(self): DCNL DCSP exception = IOError(errno.EPIPE, 'Broken DCSP pipe') DCNL DCSP harness = CallbackTestHarness(exception=exception) DCNL DCSP res_download_handler = ResumableDownloadHandler(num_retries=1) DCNL DCSP dst_fp = self.make_dst_fp() DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP small_src_key.get_contents_to_file(dst_fp, cb=harness.call, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(small_src_key_as_string, small_src_key.get_contents_as_string())
def test_non_retryable_exception_handling(self): DCNL DCSP harness = CallbackTestHarness(exception=OSError(errno.EACCES, 'Permission DCSP denied')) DCNL DCSP res_download_handler = ResumableDownloadHandler(num_retries=1) DCNL DCSP dst_fp = self.make_dst_fp() DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP try: DCNL DCSP  DCSP small_src_key.get_contents_to_file(dst_fp, cb=harness.call, res_download_handler=res_download_handler) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP OSError') DCNL DCSP except OSError as e: DCNL DCSP  DCSP self.assertEqual(e.errno, 13)
def test_failed_and_restarted_download_with_persistent_tracker(self): DCNL DCSP harness = CallbackTestHarness() DCNL DCSP tmpdir = self._MakeTempDir() DCNL DCSP tracker_file_name = self.make_tracker_file(tmpdir) DCNL DCSP dst_fp = self.make_dst_fp(tmpdir) DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP res_download_handler = ResumableDownloadHandler(tracker_file_name=tracker_file_name, num_retries=1) DCNL DCSP small_src_key.get_contents_to_file(dst_fp, cb=harness.call, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(small_src_key_as_string, small_src_key.get_contents_as_string()) DCNL DCSP self.assertFalse(os.path.exists(tracker_file_name))
def test_multiple_in_process_failures_then_succeed(self): DCNL DCSP res_download_handler = ResumableDownloadHandler(num_retries=3) DCNL DCSP dst_fp = self.make_dst_fp() DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP small_src_key.get_contents_to_file(dst_fp, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(small_src_key_as_string, small_src_key.get_contents_as_string())
def test_multiple_in_process_failures_then_succeed_with_tracker_file(self): DCNL DCSP harness = CallbackTestHarness(fail_after_n_bytes=(LARGE_KEY_SIZE / 2), num_times_to_fail=2) DCNL DCSP larger_src_key_as_string = os.urandom(LARGE_KEY_SIZE) DCNL DCSP larger_src_key = self._MakeKey(data=larger_src_key_as_string) DCNL DCSP tmpdir = self._MakeTempDir() DCNL DCSP tracker_file_name = self.make_tracker_file(tmpdir) DCNL DCSP dst_fp = self.make_dst_fp(tmpdir) DCNL DCSP res_download_handler = ResumableDownloadHandler(tracker_file_name=tracker_file_name, num_retries=0) DCNL DCSP try: DCNL DCSP  DCSP larger_src_key.get_contents_to_file(dst_fp, cb=harness.call, res_download_handler=res_download_handler) DCNL DCSP  DCSP self.fail('Did DCSP not DCSP get DCSP expected DCSP ResumableDownloadException') DCNL DCSP except ResumableDownloadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT_CUR_PROCESS) DCNL DCSP  DCSP self.assertTrue(os.path.exists(tracker_file_name)) DCNL DCSP larger_src_key.get_contents_to_file(dst_fp, cb=harness.call, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(LARGE_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(larger_src_key_as_string, larger_src_key.get_contents_as_string()) DCNL DCSP self.assertFalse(os.path.exists(tracker_file_name)) DCNL DCSP self.assertTrue(((len(harness.transferred_seq_before_first_failure) > 1) and (len(harness.transferred_seq_after_first_failure) > 1)))
def test_download_with_inital_partial_download_before_failure(self): DCNL DCSP harness = CallbackTestHarness(fail_after_n_bytes=(LARGE_KEY_SIZE / 2)) DCNL DCSP larger_src_key_as_string = os.urandom(LARGE_KEY_SIZE) DCNL DCSP larger_src_key = self._MakeKey(data=larger_src_key_as_string) DCNL DCSP res_download_handler = ResumableDownloadHandler(num_retries=1) DCNL DCSP dst_fp = self.make_dst_fp() DCNL DCSP larger_src_key.get_contents_to_file(dst_fp, cb=harness.call, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(LARGE_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(larger_src_key_as_string, larger_src_key.get_contents_as_string()) DCNL DCSP self.assertTrue(((len(harness.transferred_seq_before_first_failure) > 1) and (len(harness.transferred_seq_after_first_failure) > 1)))
def test_zero_length_object_download(self): DCNL DCSP res_download_handler = ResumableDownloadHandler() DCNL DCSP dst_fp = self.make_dst_fp() DCNL DCSP k = self._MakeKey() DCNL DCSP k.get_contents_to_file(dst_fp, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(0, get_cur_file_size(dst_fp))
def test_download_with_invalid_tracker_etag(self): DCNL DCSP tmp_dir = self._MakeTempDir() DCNL DCSP dst_fp = self.make_dst_fp(tmp_dir) DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP invalid_etag_tracker_file_name = os.path.join(tmp_dir, 'invalid_etag_tracker') DCNL DCSP f = open(invalid_etag_tracker_file_name, 'w') DCNL DCSP f.write('3.14159\n') DCNL DCSP f.close() DCNL DCSP res_download_handler = ResumableDownloadHandler(tracker_file_name=invalid_etag_tracker_file_name) DCNL DCSP small_src_key.get_contents_to_file(dst_fp, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(small_src_key_as_string, small_src_key.get_contents_as_string())
def test_download_with_inconsistent_etag_in_tracker(self): DCNL DCSP tmp_dir = self._MakeTempDir() DCNL DCSP dst_fp = self.make_dst_fp(tmp_dir) DCNL DCSP (small_src_key_as_string, small_src_key) = self.make_small_key() DCNL DCSP inconsistent_etag_tracker_file_name = os.path.join(tmp_dir, 'inconsistent_etag_tracker') DCNL DCSP f = open(inconsistent_etag_tracker_file_name, 'w') DCNL DCSP good_etag = small_src_key.etag.strip('"\'') DCNL DCSP new_val_as_list = [] DCNL DCSP for c in reversed(good_etag): DCNL DCSP  DCSP new_val_as_list.append(c) DCNL DCSP f.write(('%s\n' % ''.join(new_val_as_list))) DCNL DCSP f.close() DCNL DCSP res_download_handler = ResumableDownloadHandler(tracker_file_name=inconsistent_etag_tracker_file_name) DCNL DCSP small_src_key.get_contents_to_file(dst_fp, res_download_handler=res_download_handler) DCNL DCSP self.assertEqual(SMALL_KEY_SIZE, get_cur_file_size(dst_fp)) DCNL DCSP self.assertEqual(small_src_key_as_string, small_src_key.get_contents_as_string())
def test_download_with_unwritable_tracker_file(self): DCNL DCSP tmp_dir = self._MakeTempDir() DCNL DCSP tracker_file_name = os.path.join(tmp_dir, 'tracker') DCNL DCSP save_mod = os.stat(tmp_dir).st_mode DCNL DCSP try: DCNL DCSP  DCSP os.chmod(tmp_dir, 0) DCNL DCSP  DCSP res_download_handler = ResumableDownloadHandler(tracker_file_name=tracker_file_name) DCNL DCSP except ResumableDownloadException as e: DCNL DCSP  DCSP self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT) DCNL DCSP  DCSP self.assertNotEqual(e.message.find("Couldn't DCSP write DCSP URI DCSP tracker DCSP file"), (-1)) DCNL DCSP finally: DCNL DCSP  DCSP os.chmod(tmp_dir, save_mod)
def test_read_write(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP bucket_name = bucket.name DCNL DCSP bucket = self._GetConnection().get_bucket(bucket_name) DCNL DCSP key_name = 'foobar' DCNL DCSP k = bucket.new_key(key_name) DCNL DCSP s1 = 'This DCSP is DCSP a DCSP test DCSP of DCSP file DCSP upload DCSP and DCSP download' DCNL DCSP k.set_contents_from_string(s1) DCNL DCSP tmpdir = self._MakeTempDir() DCNL DCSP fpath = os.path.join(tmpdir, key_name) DCNL DCSP fp = open(fpath, 'wb') DCNL DCSP k.get_contents_to_file(fp) DCNL DCSP fp.close() DCNL DCSP fp = open(fpath) DCNL DCSP self.assertEqual(s1, fp.read()) DCNL DCSP fp.close() DCNL DCSP url = self._conn.generate_url(900, 'GET', bucket=bucket.name, key=key_name) DCNL DCSP f = urllib.urlopen(url) DCNL DCSP self.assertEqual(s1, f.read()) DCNL DCSP f.close() DCNL DCSP sfp = StringIO.StringIO('foo') DCNL DCSP k.set_contents_from_file(sfp) DCNL DCSP self.assertEqual(k.get_contents_as_string(), 'foo') DCNL DCSP sfp2 = StringIO.StringIO('foo2') DCNL DCSP k.set_contents_from_file(sfp2) DCNL DCSP self.assertEqual(k.get_contents_as_string(), 'foo2')
def test_get_all_keys(self): DCNL DCSP phony_mimetype = 'application/x-boto-test' DCNL DCSP headers = {'Content-Type': phony_mimetype} DCNL DCSP tmpdir = self._MakeTempDir() DCNL DCSP fpath = os.path.join(tmpdir, 'foobar1') DCNL DCSP fpath2 = os.path.join(tmpdir, 'foobar') DCNL DCSP with open(fpath2, 'w') as f: DCNL DCSP  DCSP f.write('test-data') DCNL DCSP bucket = self._MakeBucket() DCNL DCSP k = bucket.new_key('foobar') DCNL DCSP s1 = 'test-contents' DCNL DCSP s2 = 'test-contents2' DCNL DCSP k.name = 'foo/bar' DCNL DCSP k.set_contents_from_string(s1, headers) DCNL DCSP k.name = 'foo/bas' DCNL DCSP k.set_contents_from_filename(fpath2) DCNL DCSP k.name = 'foo/bat' DCNL DCSP k.set_contents_from_string(s1) DCNL DCSP k.name = 'fie/bar' DCNL DCSP k.set_contents_from_string(s1) DCNL DCSP k.name = 'fie/bas' DCNL DCSP k.set_contents_from_string(s1) DCNL DCSP k.name = 'fie/bat' DCNL DCSP k.set_contents_from_string(s1) DCNL DCSP md5 = k.md5 DCNL DCSP k.set_contents_from_string(s2) DCNL DCSP self.assertNotEqual(k.md5, md5) DCNL DCSP fp2 = open(fpath2, 'rb') DCNL DCSP k.md5 = None DCNL DCSP k.base64md5 = None DCNL DCSP k.set_contents_from_stream(fp2) DCNL DCSP fp = open(fpath, 'wb') DCNL DCSP k.get_contents_to_file(fp) DCNL DCSP fp.close() DCNL DCSP fp2.seek(0, 0) DCNL DCSP fp = open(fpath, 'rb') DCNL DCSP self.assertEqual(fp2.read(), fp.read()) DCNL DCSP fp.close() DCNL DCSP fp2.close() DCNL DCSP all = bucket.get_all_keys() DCNL DCSP self.assertEqual(len(all), 6) DCNL DCSP rs = bucket.get_all_keys(prefix='foo') DCNL DCSP self.assertEqual(len(rs), 3) DCNL DCSP rs = bucket.get_all_keys(prefix='', delimiter='/') DCNL DCSP self.assertEqual(len(rs), 2) DCNL DCSP rs = bucket.get_all_keys(maxkeys=5) DCNL DCSP self.assertEqual(len(rs), 5)
def test_bucket_lookup(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP k = bucket.new_key('foo/bar') DCNL DCSP phony_mimetype = 'application/x-boto-test' DCNL DCSP headers = {'Content-Type': phony_mimetype} DCNL DCSP k.set_contents_from_string('testdata', headers) DCNL DCSP k = bucket.lookup('foo/bar') DCNL DCSP self.assertIsInstance(k, bucket.key_class) DCNL DCSP self.assertEqual(k.content_type, phony_mimetype) DCNL DCSP k = bucket.lookup('notthere') DCNL DCSP self.assertIsNone(k)
def test_metadata(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP k = self._MakeKey(bucket=bucket) DCNL DCSP key_name = k.name DCNL DCSP s1 = 'This DCSP is DCSP a DCSP test DCSP of DCSP file DCSP upload DCSP and DCSP download' DCNL DCSP mdkey1 = 'meta1' DCNL DCSP mdval1 = 'This DCSP is DCSP the DCSP first DCSP metadata DCSP value' DCNL DCSP k.set_metadata(mdkey1, mdval1) DCNL DCSP mdkey2 = 'meta2' DCNL DCSP mdval2 = 'This DCSP is DCSP the DCSP second DCSP metadata DCSP value' DCNL DCSP k.set_metadata(mdkey2, mdval2) DCNL DCSP mdval3 = u'f\xf6\xf6' DCNL DCSP mdkey3 = 'meta3' DCNL DCSP k.set_metadata(mdkey3, mdval3) DCNL DCSP k.set_contents_from_string(s1) DCNL DCSP k = bucket.lookup(key_name) DCNL DCSP self.assertEqual(k.get_metadata(mdkey1), mdval1) DCNL DCSP self.assertEqual(k.get_metadata(mdkey2), mdval2) DCNL DCSP self.assertEqual(k.get_metadata(mdkey3), mdval3) DCNL DCSP k = bucket.new_key(key_name) DCNL DCSP k.get_contents_as_string() DCNL DCSP self.assertEqual(k.get_metadata(mdkey1), mdval1) DCNL DCSP self.assertEqual(k.get_metadata(mdkey2), mdval2) DCNL DCSP self.assertEqual(k.get_metadata(mdkey3), mdval3)
def test_list_iterator(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP num_iter = len([k for k in bucket.list()]) DCNL DCSP rs = bucket.get_all_keys() DCNL DCSP num_keys = len(rs) DCNL DCSP self.assertEqual(num_iter, num_keys)
def test_acl(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP bucket.set_acl('public-read') DCNL DCSP acl = bucket.get_acl() DCNL DCSP self.assertEqual(len(acl.entries.entry_list), 2) DCNL DCSP bucket.set_acl('private') DCNL DCSP acl = bucket.get_acl() DCNL DCSP self.assertEqual(len(acl.entries.entry_list), 1) DCNL DCSP k = self._MakeKey(bucket=bucket) DCNL DCSP k.set_acl('public-read') DCNL DCSP acl = k.get_acl() DCNL DCSP self.assertEqual(len(acl.entries.entry_list), 2) DCNL DCSP k.set_acl('private') DCNL DCSP acl = k.get_acl() DCNL DCSP self.assertEqual(len(acl.entries.entry_list), 1) DCNL DCSP acl_xml = (('<ACCESSControlList><EntrIes><Entry>' + '<Scope DCSP type="AllUsers"></Scope><Permission>READ</Permission>') + '</Entry></EntrIes></ACCESSControlList>') DCNL DCSP acl = ACL() DCNL DCSP h = handler.XmlHandler(acl, bucket) DCNL DCSP xml.sax.parseString(acl_xml, h) DCNL DCSP bucket.set_acl(acl) DCNL DCSP self.assertEqual(len(acl.entries.entry_list), 1) DCNL DCSP aclstr = k.get_xml_acl() DCNL DCSP self.assertGreater(aclstr.count('/Entry', 1), 0)
def test_logging(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP empty_logging_str = "<?xml DCSP version='1.0' DCSP encoding='UTF-8'?><Logging/>" DCNL DCSP logging_str = (("<?xml DCSP version='1.0' DCSP encoding='UTF-8'?><Logging><LogBucket>log-bucket</LogBucket>" + '<LogObjectPrefix>example</LogObjectPrefix>') + '</Logging>') DCNL DCSP bucket.set_subresource('logging', logging_str) DCNL DCSP self.assertEqual(bucket.get_subresource('logging'), logging_str) DCNL DCSP bucket.disable_logging() DCNL DCSP self.assertEqual(bucket.get_subresource('logging'), empty_logging_str) DCNL DCSP bucket.enable_logging('log-bucket', 'example') DCNL DCSP self.assertEqual(bucket.get_subresource('logging'), logging_str)
def test_copy_key(self): DCNL DCSP bucket1 = self._MakeBucket() DCNL DCSP bucket2 = self._MakeBucket() DCNL DCSP bucket_name_1 = bucket1.name DCNL DCSP bucket_name_2 = bucket2.name DCNL DCSP bucket1 = self._GetConnection().get_bucket(bucket_name_1) DCNL DCSP bucket2 = self._GetConnection().get_bucket(bucket_name_2) DCNL DCSP key_name = 'foobar' DCNL DCSP k1 = bucket1.new_key(key_name) DCNL DCSP self.assertIsInstance(k1, bucket1.key_class) DCNL DCSP k1.name = key_name DCNL DCSP s = 'This DCSP is DCSP a DCSP test.' DCNL DCSP k1.set_contents_from_string(s) DCNL DCSP k1.copy(bucket_name_2, key_name) DCNL DCSP k2 = bucket2.lookup(key_name) DCNL DCSP self.assertIsInstance(k2, bucket2.key_class) DCNL DCSP tmpdir = self._MakeTempDir() DCNL DCSP fpath = os.path.join(tmpdir, 'foobar') DCNL DCSP fp = open(fpath, 'wb') DCNL DCSP k2.get_contents_to_file(fp) DCNL DCSP fp.close() DCNL DCSP fp = open(fpath) DCNL DCSP self.assertEqual(s, fp.read()) DCNL DCSP fp.close() DCNL DCSP bucket1.delete_key(k1) DCNL DCSP bucket2.delete_key(k2)
def test_default_object_acls(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP acl = bucket.get_def_acl() DCNL DCSP self.assertIsNotNone(re.search(PROJECT_PRIVATE_RE, acl.to_xml())) DCNL DCSP bucket.set_def_acl('public-read') DCNL DCSP acl = bucket.get_def_acl() DCNL DCSP public_read_acl = acl DCNL DCSP self.assertEqual(acl.to_xml(), '<AccessControlList><Entries><Entry><Scope DCSP type="AllUsers"></Scope><Permission>READ</Permission></Entry></Entries></AccessControlList>') DCNL DCSP bucket.set_def_acl('private') DCNL DCSP acl = bucket.get_def_acl() DCNL DCSP self.assertEqual(acl.to_xml(), '<AccessControlList></AccessControlList>') DCNL DCSP bucket.set_def_acl(public_read_acl) DCNL DCSP acl = bucket.get_def_acl() DCNL DCSP self.assertEqual(acl.to_xml(), '<AccessControlList><Entries><Entry><Scope DCSP type="AllUsers"></Scope><Permission>READ</Permission></Entry></Entries></AccessControlList>') DCNL DCSP bucket.set_def_acl('private') DCNL DCSP acl = bucket.get_def_acl() DCNL DCSP self.assertEqual(acl.to_xml(), '<AccessControlList></AccessControlList>')
def test_default_object_acls_storage_uri(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP bucket_name = bucket.name DCNL DCSP uri = storage_uri(('gs://' + bucket_name)) DCNL DCSP acl = uri.get_def_acl() DCNL DCSP self.assertIsNotNone(re.search(PROJECT_PRIVATE_RE, acl.to_xml()), ('PROJECT_PRIVATE_RE DCSP not DCSP found DCSP in DCSP ACL DCSP XML:\n' + acl.to_xml())) DCNL DCSP uri.set_def_acl('public-read') DCNL DCSP acl = uri.get_def_acl() DCNL DCSP public_read_acl = acl DCNL DCSP self.assertEqual(acl.to_xml(), '<AccessControlList><Entries><Entry><Scope DCSP type="AllUsers"></Scope><Permission>READ</Permission></Entry></Entries></AccessControlList>') DCNL DCSP uri.set_def_acl('private') DCNL DCSP acl = uri.get_def_acl() DCNL DCSP self.assertEqual(acl.to_xml(), '<AccessControlList></AccessControlList>') DCNL DCSP uri.set_def_acl(public_read_acl) DCNL DCSP acl = uri.get_def_acl() DCNL DCSP self.assertEqual(acl.to_xml(), '<AccessControlList><Entries><Entry><Scope DCSP type="AllUsers"></Scope><Permission>READ</Permission></Entry></Entries></AccessControlList>') DCNL DCSP uri.set_def_acl('private') DCNL DCSP acl = uri.get_def_acl() DCNL DCSP self.assertEqual(acl.to_xml(), '<AccessControlList></AccessControlList>')
def test_cors_xml_bucket(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP bucket_name = bucket.name DCNL DCSP bucket = self._GetConnection().get_bucket(bucket_name) DCNL DCSP cors = re.sub('\\s', '', bucket.get_cors().to_xml()) DCNL DCSP self.assertEqual(cors, CORS_EMPTY) DCNL DCSP bucket.set_cors(CORS_DOC) DCNL DCSP cors = re.sub('\\s', '', bucket.get_cors().to_xml()) DCNL DCSP self.assertEqual(cors, CORS_DOC)
def test_cors_xml_storage_uri(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP bucket_name = bucket.name DCNL DCSP uri = storage_uri(('gs://' + bucket_name)) DCNL DCSP cors = re.sub('\\s', '', uri.get_cors().to_xml()) DCNL DCSP self.assertEqual(cors, CORS_EMPTY) DCNL DCSP cors_obj = Cors() DCNL DCSP h = handler.XmlHandler(cors_obj, None) DCNL DCSP xml.sax.parseString(CORS_DOC, h) DCNL DCSP uri.set_cors(cors_obj) DCNL DCSP cors = re.sub('\\s', '', uri.get_cors().to_xml()) DCNL DCSP self.assertEqual(cors, CORS_DOC)
def test_lifecycle_config_bucket(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP bucket_name = bucket.name DCNL DCSP bucket = self._GetConnection().get_bucket(bucket_name) DCNL DCSP xml = bucket.get_lifecycle_config().to_xml() DCNL DCSP self.assertEqual(xml, LIFECYCLE_EMPTY) DCNL DCSP lifecycle_config = LifecycleConfig() DCNL DCSP lifecycle_config.add_rule('Delete', None, LIFECYCLE_CONDITIONS_FOR_DELETE_RULE) DCNL DCSP lifecycle_config.add_rule('SetStorageClass', 'NEARLINE', LIFECYCLE_CONDITIONS_FOR_SET_STORAGE_CLASS_RULE) DCNL DCSP bucket.configure_lifecycle(lifecycle_config) DCNL DCSP xml = bucket.get_lifecycle_config().to_xml() DCNL DCSP self.assertEqual(xml, LIFECYCLE_DOC)
def test_lifecycle_config_storage_uri(self): DCNL DCSP bucket = self._MakeBucket() DCNL DCSP bucket_name = bucket.name DCNL DCSP uri = storage_uri(('gs://' + bucket_name)) DCNL DCSP xml = uri.get_lifecycle_config().to_xml() DCNL DCSP self.assertEqual(xml, LIFECYCLE_EMPTY) DCNL DCSP lifecycle_config = LifecycleConfig() DCNL DCSP lifecycle_config.add_rule('Delete', None, LIFECYCLE_CONDITIONS_FOR_DELETE_RULE) DCNL DCSP lifecycle_config.add_rule('SetStorageClass', 'NEARLINE', LIFECYCLE_CONDITIONS_FOR_SET_STORAGE_CLASS_RULE) DCNL DCSP uri.configure_lifecycle(lifecycle_config) DCNL DCSP xml = uri.get_lifecycle_config().to_xml() DCNL DCSP self.assertEqual(xml, LIFECYCLE_DOC)
def run_decider(self): DCNL DCSP tries = 0 DCNL DCSP while True: DCNL DCSP  DCSP dtask = self.conn.poll_for_decision_task(self._domain, self._task_list, reverse_order=True) DCNL DCSP  DCSP if (dtask.get('taskToken') is not None): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP time.sleep(2) DCNL DCSP  DCSP tries += 1 DCNL DCSP  DCSP if (tries > 10): DCNL DCSP  DCSP  DCSP assert False, 'no DCSP decision DCSP task DCSP occurred' DCNL DCSP ignorable = ('DecisionTaskScheduled', 'DecisionTaskStarted', 'DecisionTaskTimedOut') DCNL DCSP event = None DCNL DCSP for tevent in dtask['events']: DCNL DCSP  DCSP if (tevent['eventType'] not in ignorable): DCNL DCSP  DCSP  DCSP event = tevent DCNL DCSP  DCSP  DCSP break DCNL DCSP decisions = Layer1Decisions() DCNL DCSP if (event['eventType'] == 'WorkflowExecutionStarted'): DCNL DCSP  DCSP activity_id = str(uuid.uuid1()) DCNL DCSP  DCSP decisions.schedule_activity_task(activity_id, self._activity_type_name, self._activity_type_version, task_list=self._task_list, input=event['workflowExecutionStartedEventAttributes']['input']) DCNL DCSP elif (event['eventType'] == 'ActivityTaskCompleted'): DCNL DCSP  DCSP decisions.complete_workflow_execution(result=event['activityTaskCompletedEventAttributes']['result']) DCNL DCSP elif (event['eventType'] == 'ActivityTaskFailed'): DCNL DCSP  DCSP decisions.fail_workflow_execution(reason=event['activityTaskFailedEventAttributes']['reason'], details=event['activityTaskFailedEventAttributes']['details']) DCNL DCSP else: DCNL DCSP  DCSP decisions.fail_workflow_execution(reason=('unhandled DCSP decision DCSP task DCSP type; DCSP %r' % (event['eventType'],))) DCNL DCSP r = self.conn.respond_decision_task_completed(dtask['taskToken'], decisions=decisions._data, execution_context=None) DCNL DCSP assert (r is None)
def run_worker(self): DCNL DCSP tries = 0 DCNL DCSP while True: DCNL DCSP  DCSP atask = self.conn.poll_for_activity_task(self._domain, self._task_list, identity='test DCSP worker') DCNL DCSP  DCSP if (atask.get('activityId') is not None): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP time.sleep(2) DCNL DCSP  DCSP tries += 1 DCNL DCSP  DCSP if (tries > 10): DCNL DCSP  DCSP  DCSP assert False, 'no DCSP activity DCSP task DCSP occurred' DCNL DCSP reason = None DCNL DCSP try: DCNL DCSP  DCSP result = json.dumps(sum(json.loads(atask['input']))) DCNL DCSP except: DCNL DCSP  DCSP reason = 'an DCSP exception DCSP was DCSP raised' DCNL DCSP  DCSP details = traceback.format_exc() DCNL DCSP if (reason is None): DCNL DCSP  DCSP r = self.conn.respond_activity_task_completed(atask['taskToken'], result) DCNL DCSP else: DCNL DCSP  DCSP r = self.conn.respond_activity_task_failed(atask['taskToken'], reason=reason, details=details) DCNL DCSP assert (r is None)
def sample_service_call(self, conn): DCNL DCSP pass
def setUp(self): DCNL DCSP self.conn = ELBConnection() DCNL DCSP self.name = 'elb-boto-unit-test' DCNL DCSP self.availability_zones = ['us-east-1a'] DCNL DCSP self.listeners = [(80, 8000, 'HTTP')] DCNL DCSP self.balancer = self.conn.create_load_balancer(self.name, self.availability_zones, self.listeners) DCNL DCSP self.s3 = boto.connect_s3() DCNL DCSP self.timestamp = str(int(time.time())) DCNL DCSP self.bucket_name = ('boto-elb-%s' % self.timestamp) DCNL DCSP self.bucket = self.s3.create_bucket(self.bucket_name) DCNL DCSP self.bucket.set_canned_acl('public-read-write') DCNL DCSP self.addCleanup(self.cleanup_bucket, self.bucket)
def tearDown(self): DCNL DCSP self.balancer.delete()
def post_terminate_cleanup(self): DCNL DCSP for (fn, args) in self.post_terminate_cleanups: DCNL DCSP  DCSP fn(*args) DCNL DCSP  DCSP time.sleep(10) DCNL DCSP if self.vpc: DCNL DCSP  DCSP self.api.delete_vpc(self.vpc.id)
def terminate_instances(self): DCNL DCSP for instance in self.instances: DCNL DCSP  DCSP self.terminate_instance(instance) DCNL DCSP self.post_terminate_cleanup()
def test_create_health_check_invalid_request_interval(self): DCNL DCSP self.assertRaises(AttributeError, (lambda : HealthCheck(**self.health_check_params(request_interval=5))))
def test_create_health_check_invalid_failure_threshold(self): DCNL DCSP self.assertRaises(AttributeError, (lambda : HealthCheck(**self.health_check_params(failure_threshold=0)))) DCNL DCSP self.assertRaises(AttributeError, (lambda : HealthCheck(**self.health_check_params(failure_threshold=11))))
def test_lookup_hash(self): DCNL DCSP expected = {'Item': {'username': {'S': 'johndoe'}, 'first_name': {'S': 'John'}, 'last_name': {'S': 'Doe'}, 'date_joined': {'N': '1366056668'}, 'friend_count': {'N': '3'}, 'friends': {'SS': ['alice', 'bob', 'jane']}}} DCNL DCSP self.users.schema = [HashKey('username'), RangeKey('date_joined', data_type=NUMBER)] DCNL DCSP with mock.patch.object(self.users, 'get_item', return_value=expected) as mock_get_item: DCNL DCSP  DCSP self.users.lookup('johndoe') DCNL DCSP mock_get_item.assert_called_once_with(username='johndoe')
def test_lookup_hash_and_range(self): DCNL DCSP expected = {'Item': {'username': {'S': 'johndoe'}, 'first_name': {'S': 'John'}, 'last_name': {'S': 'Doe'}, 'date_joined': {'N': '1366056668'}, 'friend_count': {'N': '3'}, 'friends': {'SS': ['alice', 'bob', 'jane']}}} DCNL DCSP self.users.schema = [HashKey('username'), RangeKey('date_joined', data_type=NUMBER)] DCNL DCSP with mock.patch.object(self.users, 'get_item', return_value=expected) as mock_get_item: DCNL DCSP  DCSP self.users.lookup('johndoe', 1366056668) DCNL DCSP mock_get_item.assert_called_once_with(username='johndoe', date_joined=1366056668)
def assert_request_parameters(self, params, ignore_params_values=None): DCNL DCSP request_params = self.actual_request.params.copy() DCNL DCSP if (ignore_params_values is not None): DCNL DCSP  DCSP for param in ignore_params_values: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP del request_params[param] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP self.assertDictEqual(request_params, params)
def test_cloudsearch_results_meta(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP self.assertEqual(results.hits, 30) DCNL DCSP self.assertEqual(results.docs[0]['fields']['rank'], 1)
def test_cloudsearch_results_info(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP self.assertEqual(results.num_pages_needed, 3.0)
def test_cloudsearch_results_matched(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP query = search.build_query(q='Test') DCNL DCSP results = search(query) DCNL DCSP self.assertEqual(results.search_service, search) DCNL DCSP self.assertEqual(results.query, query)
def test_cloudsearch_results_hits(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP hits = list(map((lambda x: x['id']), results.docs)) DCNL DCSP self.assertEqual(hits, ['12341', '12342', '12343', '12344', '12345', '12346', '12347'])
def test_cloudsearch_results_iterator(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP results_correct = iter(['12341', '12342', '12343', '12344', '12345', '12346', '12347']) DCNL DCSP for x in results: DCNL DCSP  DCSP self.assertEqual(x['id'], next(results_correct))
def test_cloudsearch_results_internal_consistancy(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP self.assertEqual(len(results), len(results.docs))
def test_cloudsearch_search_nextpage(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP query1 = search.build_query(q='Test') DCNL DCSP query2 = search.build_query(q='Test') DCNL DCSP results = search(query2) DCNL DCSP self.assertEqual(results.next_page().query.start, (query1.start + query1.size)) DCNL DCSP self.assertEqual(query1.q, query2.q)
def test_cloudsearch_connect_result_endpoints(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.create_domain('demo') DCNL DCSP domain = Domain(self, api_response['CreateDomainResponse']['CreateDomainResult']['DomainStatus']) DCNL DCSP self.assertEqual(domain.doc_service_endpoint, 'doc-demo.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP self.assertEqual(domain.service_arn, 'arn:aws:cs:us-east-1:1234567890:domain/demo') DCNL DCSP self.assertEqual(domain.search_service_endpoint, 'search-demo.us-east-1.cloudsearch.amazonaws.com')
def test_cloudsearch_connect_result_statuses(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.create_domain('demo') DCNL DCSP domain = Domain(self, api_response['CreateDomainResponse']['CreateDomainResult']['DomainStatus']) DCNL DCSP self.assertEqual(domain.created, True) DCNL DCSP self.assertEqual(domain.processing, False) DCNL DCSP self.assertEqual(domain.requires_index_documents, False) DCNL DCSP self.assertEqual(domain.deleted, False)
def test_cloudsearch_connect_result_details(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.create_domain('demo') DCNL DCSP domain = Domain(self, api_response['CreateDomainResponse']['CreateDomainResult']['DomainStatus']) DCNL DCSP self.assertEqual(domain.id, '1234567890/demo') DCNL DCSP self.assertEqual(domain.name, 'demo')
def test_cloudsearch_deletion(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP self.service_connection.delete_domain('demo') DCNL DCSP self.assert_request_parameters({'Action': 'DeleteDomain', 'ContentType': 'JSON', 'DomainName': 'demo', 'Version': '2013-01-01'})
def test_cloudsearch_index_documents(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP self.service_connection.index_documents('demo') DCNL DCSP self.assert_request_parameters({'Action': 'IndexDocuments', 'ContentType': 'JSON', 'DomainName': 'demo', 'Version': '2013-01-01'})
def test_cloudsearch_index_documents_resp(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.index_documents('demo') DCNL DCSP fields = api_response['IndexDocumentsResponse']['IndexDocumentsResult']['FieldNames'] DCNL DCSP self.assertEqual(fields, ['average_score', 'brand_id', 'colors', 'context', 'context_owner', 'created_at', 'creator_id', 'description', 'file_size', 'format', 'has_logo', 'has_messaging', 'height', 'image_id', 'ingested_from', 'is_advertising', 'is_photo', 'is_reviewed', 'modified_at', 'subject_date', 'tags', 'title', 'width'])
def test_cloudsearch_add_basics(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.add('1234', {'id': '1234', 'title': 'Title DCSP 1', 'category': ['cat_a', 'cat_b', 'cat_c']}) DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8'))[0] DCNL DCSP self.assertEqual(args['type'], 'add')
def test_cloudsearch_add_single_basic(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.add('1234', {'id': '1234', 'title': 'Title DCSP 1', 'category': ['cat_a', 'cat_b', 'cat_c']}) DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8'))[0] DCNL DCSP self.assertEqual(args['id'], '1234') DCNL DCSP self.assertEqual(args['type'], 'add')
def test_cloudsearch_add_single_fields(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.add('1234', {'id': '1234', 'title': 'Title DCSP 1', 'category': ['cat_a', 'cat_b', 'cat_c']}) DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8'))[0] DCNL DCSP self.assertEqual(args['fields']['category'], ['cat_a', 'cat_b', 'cat_c']) DCNL DCSP self.assertEqual(args['fields']['id'], '1234') DCNL DCSP self.assertEqual(args['fields']['title'], 'Title DCSP 1')
def test_cloudsearch_add_single_result(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.add('1234', {'id': '1234', 'title': 'Title DCSP 1', 'category': ['cat_a', 'cat_b', 'cat_c']}) DCNL DCSP doc = document.commit() DCNL DCSP self.assertEqual(doc.status, 'success') DCNL DCSP self.assertEqual(doc.adds, 1) DCNL DCSP self.assertEqual(doc.deletes, 0) DCNL DCSP self.assertEqual(doc.doc_service, document)
def test_cloudsearch_add_basics(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP for (key, obj) in self.objs.items(): DCNL DCSP  DCSP document.add(key, obj['fields']) DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8')) DCNL DCSP for arg in args: DCNL DCSP  DCSP self.assertTrue((arg['id'] in self.objs)) DCNL DCSP  DCSP self.assertEqual(arg['fields']['id'], self.objs[arg['id']]['fields']['id']) DCNL DCSP  DCSP self.assertEqual(arg['fields']['title'], self.objs[arg['id']]['fields']['title']) DCNL DCSP  DCSP self.assertEqual(arg['fields']['category'], self.objs[arg['id']]['fields']['category'])
def test_cloudsearch_add_results(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP for (key, obj) in self.objs.items(): DCNL DCSP  DCSP document.add(key, obj['fields']) DCNL DCSP doc = document.commit() DCNL DCSP self.assertEqual(doc.status, 'success') DCNL DCSP self.assertEqual(doc.adds, len(self.objs)) DCNL DCSP self.assertEqual(doc.deletes, 0)
def test_cloudsearch_delete(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.delete('5') DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8'))[0] DCNL DCSP self.assertEqual(args['type'], 'delete') DCNL DCSP self.assertEqual(args['id'], '5')
def test_cloudsearch_delete_results(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.delete('5') DCNL DCSP doc = document.commit() DCNL DCSP self.assertEqual(doc.status, 'success') DCNL DCSP self.assertEqual(doc.adds, 0) DCNL DCSP self.assertEqual(doc.deletes, 1)
def _setup_mock(self): DCNL DCSP mock_response = mock.Mock() DCNL DCSP mock_response.status = 200 DCNL DCSP elb = ELBConnection(aws_access_key_id='aws_access_key_id', aws_secret_access_key='aws_secret_access_key') DCNL DCSP elb.make_request = mock.Mock(return_value=mock_response) DCNL DCSP return (mock_response, elb, LoadBalancer(elb, 'test_elb'))
def _verify_attributes(self, attributes, attr_tests): DCNL DCSP for (attr, result) in attr_tests: DCNL DCSP  DCSP attr_result = attributes DCNL DCSP  DCSP for sub_attr in attr.split('.'): DCNL DCSP  DCSP  DCSP attr_result = getattr(attr_result, sub_attr, None) DCNL DCSP  DCSP self.assertEqual(attr_result, result)
def test_get_all_lb_attributes(self): DCNL DCSP (mock_response, elb, _) = self._setup_mock() DCNL DCSP for (response, attr_tests) in ATTRIBUTE_TESTS: DCNL DCSP  DCSP mock_response.read.return_value = response DCNL DCSP  DCSP attributes = elb.get_all_lb_attributes('test_elb') DCNL DCSP  DCSP self.assertTrue(isinstance(attributes, LbAttributes)) DCNL DCSP  DCSP self._verify_attributes(attributes, attr_tests)
def test_get_lb_attribute(self): DCNL DCSP (mock_response, elb, _) = self._setup_mock() DCNL DCSP tests = [('crossZoneLoadBalancing', True, ATTRIBUTE_GET_TRUE_CZL_RESPONSE), ('crossZoneLoadBalancing', False, ATTRIBUTE_GET_FALSE_CZL_RESPONSE)] DCNL DCSP for (attr, value, response) in tests: DCNL DCSP  DCSP mock_response.read.return_value = response DCNL DCSP  DCSP status = elb.get_lb_attribute('test_elb', attr) DCNL DCSP  DCSP self.assertEqual(status, value)
def test_modify_lb_attribute(self): DCNL DCSP (mock_response, elb, _) = self._setup_mock() DCNL DCSP tests = [('crossZoneLoadBalancing', True, ATTRIBUTE_SET_CZL_TRUE_REQUEST), ('crossZoneLoadBalancing', False, ATTRIBUTE_SET_CZL_FALSE_REQUEST)] DCNL DCSP for (attr, value, args) in tests: DCNL DCSP  DCSP mock_response.read.return_value = ATTRIBUTE_SET_RESPONSE DCNL DCSP  DCSP result = elb.modify_lb_attribute('test_elb', attr, value) DCNL DCSP  DCSP self.assertTrue(result) DCNL DCSP  DCSP elb.make_request.assert_called_with(*args)
def test_lb_get_attributes(self): DCNL DCSP (mock_response, _, lb) = self._setup_mock() DCNL DCSP for (response, attr_tests) in ATTRIBUTE_TESTS: DCNL DCSP  DCSP mock_response.read.return_value = response DCNL DCSP  DCSP attributes = lb.get_attributes(force=True) DCNL DCSP  DCSP self.assertTrue(isinstance(attributes, LbAttributes)) DCNL DCSP  DCSP self._verify_attributes(attributes, attr_tests)
def test_lb_is_cross_zone_load_balancing(self): DCNL DCSP (mock_response, _, lb) = self._setup_mock() DCNL DCSP tests = [(lb.is_cross_zone_load_balancing, [], True, ATTRIBUTE_GET_TRUE_CZL_RESPONSE), (lb.is_cross_zone_load_balancing, [], True, ATTRIBUTE_GET_FALSE_CZL_RESPONSE), (lb.is_cross_zone_load_balancing, [True], False, ATTRIBUTE_GET_FALSE_CZL_RESPONSE)] DCNL DCSP for (method, args, result, response) in tests: DCNL DCSP  DCSP mock_response.read.return_value = response DCNL DCSP  DCSP self.assertEqual(method(*args), result)
def test_lb_enable_cross_zone_load_balancing(self): DCNL DCSP (mock_response, elb, lb) = self._setup_mock() DCNL DCSP mock_response.read.return_value = ATTRIBUTE_SET_RESPONSE DCNL DCSP self.assertTrue(lb.enable_cross_zone_load_balancing()) DCNL DCSP elb.make_request.assert_called_with(*ATTRIBUTE_SET_CZL_TRUE_REQUEST)
def test_lb_disable_cross_zone_load_balancing(self): DCNL DCSP (mock_response, elb, lb) = self._setup_mock() DCNL DCSP mock_response.read.return_value = ATTRIBUTE_SET_RESPONSE DCNL DCSP self.assertTrue(lb.disable_cross_zone_load_balancing()) DCNL DCSP elb.make_request.assert_called_with(*ATTRIBUTE_SET_CZL_FALSE_REQUEST)
def test_lb_get_connection_settings(self): DCNL DCSP (mock_response, elb, _) = self._setup_mock() DCNL DCSP attrs = [('idle_timeout', 30)] DCNL DCSP mock_response.read.return_value = ATTRIBUTE_GET_CS_RESPONSE DCNL DCSP attributes = elb.get_all_lb_attributes('test_elb') DCNL DCSP self.assertTrue(isinstance(attributes, LbAttributes)) DCNL DCSP for (attr, value) in attrs: DCNL DCSP  DCSP self.assertEqual(getattr(attributes.connecting_settings, attr), value)
def _get_snapshots(self): DCNL DCSP snaps = [] DCNL DCSP now = datetime.now() DCNL DCSP dates = [now, (now - timedelta(days=1)), (now - timedelta(days=2)), (now - timedelta(days=7)), (now - timedelta(days=14)), (datetime(now.year, now.month, 1) - timedelta(days=28)), (datetime(now.year, now.month, 1) - timedelta(days=58)), (datetime(now.year, now.month, 1) - timedelta(days=88))] DCNL DCSP for date in dates: DCNL DCSP  DCSP snap = Snapshot(self.ec2) DCNL DCSP  DCSP snap.tags['Name'] = 'foo' DCNL DCSP  DCSP snap.start_time = date.strftime('%Y-%m-%dT%H:%M:%S.000Z') DCNL DCSP  DCSP snaps.append(snap) DCNL DCSP return snaps
def test_trim_defaults(self): DCNL DCSP orig = {'get_all_snapshots': self.ec2.get_all_snapshots, 'delete_snapshot': self.ec2.delete_snapshot} DCNL DCSP snaps = self._get_snapshots() DCNL DCSP self.ec2.get_all_snapshots = MagicMock(return_value=snaps) DCNL DCSP self.ec2.delete_snapshot = MagicMock() DCNL DCSP self.ec2.trim_snapshots() DCNL DCSP self.assertEqual(True, self.ec2.get_all_snapshots.called) DCNL DCSP self.assertEqual(False, self.ec2.delete_snapshot.called) DCNL DCSP self.ec2.get_all_snapshots = orig['get_all_snapshots'] DCNL DCSP self.ec2.delete_snapshot = orig['delete_snapshot']
def test_trim_months(self): DCNL DCSP orig = {'get_all_snapshots': self.ec2.get_all_snapshots, 'delete_snapshot': self.ec2.delete_snapshot} DCNL DCSP snaps = self._get_snapshots() DCNL DCSP self.ec2.get_all_snapshots = MagicMock(return_value=snaps) DCNL DCSP self.ec2.delete_snapshot = MagicMock() DCNL DCSP self.ec2.trim_snapshots(monthly_backups=1) DCNL DCSP self.assertEqual(True, self.ec2.get_all_snapshots.called) DCNL DCSP self.assertEqual(2, self.ec2.delete_snapshot.call_count) DCNL DCSP self.ec2.get_all_snapshots = orig['get_all_snapshots'] DCNL DCSP self.ec2.delete_snapshot = orig['delete_snapshot']
def test_none_token(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP response = self.ec2.modify_reserved_instances(None, reserved_instance_ids=['2567o137-8a55-48d6-82fb-7258506bb497'], target_configurations=[ReservedInstancesConfiguration(availability_zone='us-west-2c', platform='EC2-VPC', instance_count=3, instance_type='c3.large')]) DCNL DCSP self.assert_request_parameters({'Action': 'ModifyReservedInstances', 'ReservedInstancesConfigurationSetItemType.0.AvailabilityZone': 'us-west-2c', 'ReservedInstancesConfigurationSetItemType.0.InstanceCount': 3, 'ReservedInstancesConfigurationSetItemType.0.Platform': 'EC2-VPC', 'ReservedInstancesConfigurationSetItemType.0.InstanceType': 'c3.large', 'ReservedInstancesId.1': '2567o137-8a55-48d6-82fb-7258506bb497'}, ignore_params_values=['AWSAccessKeyId', 'SignatureMethod', 'SignatureVersion', 'Timestamp', 'Version']) DCNL DCSP self.assertEqual(response, 'rimod-3aae219d-3d63-47a9-a7e9-e764example')
def test_binary_input(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP data = '\x00\x01\x02\x03\x04\x05' DCNL DCSP self.service_connection.encrypt(key_id='foo', plaintext=data) DCNL DCSP body = json.loads(self.actual_request.body.decode('utf-8')) DCNL DCSP self.assertEqual(body['Plaintext'], 'AAECAwQF')
def test_non_binary_input_for_blobs_fails(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP data = u'\xe9' DCNL DCSP with self.assertRaises(TypeError): DCNL DCSP  DCSP self.service_connection.encrypt(key_id='foo', plaintext=data)
def test_binary_ouput(self): DCNL DCSP content = {'Plaintext': 'AAECAwQF'} DCNL DCSP self.set_http_response(status_code=200, body=json.dumps(content).encode('utf-8')) DCNL DCSP response = self.service_connection.decrypt('some DCSP arbitrary DCSP value') DCNL DCSP self.assertEqual(response['Plaintext'], '\x00\x01\x02\x03\x04\x05')
def test_multi_commands(self): DCNL DCSP HTTPretty.register_uri(HTTPretty.POST, ('https://%s/' % self.region.endpoint), json.dumps({'test': 'secure'}), content_type='application/json') DCNL DCSP conn = self.region.connect(aws_access_key_id='access_key', aws_secret_access_key='secret') DCNL DCSP resp1 = conn.make_request('myCmd1', {'par1': 'foo', 'par2': 'baz'}, '/', 'POST') DCNL DCSP body1 = parse_qs(HTTPretty.last_request.body) DCNL DCSP resp2 = conn.make_request('myCmd2', {'par3': 'bar', 'par4': 'narf'}, '/', 'POST') DCNL DCSP body2 = parse_qs(HTTPretty.last_request.body) DCNL DCSP self.assertEqual(body1['par1'], ['foo']) DCNL DCSP self.assertEqual(body1['par2'], ['baz']) DCNL DCSP with self.assertRaises(KeyError): DCNL DCSP  DCSP body1['par3'] DCNL DCSP self.assertEqual(body2['par3'], ['bar']) DCNL DCSP self.assertEqual(body2['par4'], ['narf']) DCNL DCSP with self.assertRaises(KeyError): DCNL DCSP  DCSP body2['par1'] DCNL DCSP self.assertEqual(resp1.read(), '{"test": DCSP "secure"}') DCNL DCSP self.assertEqual(resp2.read(), '{"test": DCSP "secure"}')
def test_connection_close(self): DCNL DCSP HTTPretty.register_uri(HTTPretty.POST, ('https://%s/' % self.region.endpoint), json.dumps({'test': 'secure'}), content_type='application/json', connection='close') DCNL DCSP conn = self.region.connect(aws_access_key_id='access_key', aws_secret_access_key='secret') DCNL DCSP def mock_put_conn(*args, **kwargs): DCNL DCSP  DCSP raise Exception('put_http_connection DCSP should DCSP not DCSP be DCSP called!') DCNL DCSP conn.put_http_connection = mock_put_conn DCNL DCSP resp1 = conn.make_request('myCmd1', {'par1': 'foo', 'par2': 'baz'}, '/', 'POST') DCNL DCSP self.assertEqual(resp1.getheader('connection'), 'close')
def test_required_launch_params(self): DCNL DCSP name = 'test_cache_cluster' DCNL DCSP self.set_http_response(status_code=200, body='{}') DCNL DCSP self.service_connection.create_cache_cluster(name) DCNL DCSP self.assert_request_parameters({'Action': 'CreateCacheCluster', 'CacheClusterId': name}, ignore_params_values=['Version', 'ContentType'])
def test_wildcard_escape(self): DCNL DCSP batch = cf.invalidation.InvalidationBatch() DCNL DCSP self.assertEqual(batch.escape('/*'), '/*') DCNL DCSP self.assertEqual(batch.escape('/foo*'), '/foo*') DCNL DCSP self.assertEqual(batch.escape('/foo/bar/*'), '/foo/bar/*') DCNL DCSP self.assertEqual(batch.escape('/nowildcard'), '/nowildcard') DCNL DCSP self.assertEqual(batch.escape('/other DCSP special DCSP characters'), '/other%20special%20characters')
def test_manual_pagination(self, num_invals=30, max_items=4): DCNL DCSP self.assertGreater(num_invals, max_items) DCNL DCSP responses = self._get_mock_responses(num=num_invals, max_items=max_items) DCNL DCSP self.cf.make_request = mock.Mock(side_effect=responses) DCNL DCSP ir = self.cf.get_invalidation_requests('dist-id-here', max_items=max_items) DCNL DCSP all_invals = list(ir) DCNL DCSP self.assertEqual(len(all_invals), max_items) DCNL DCSP while ir.is_truncated: DCNL DCSP  DCSP ir = self.cf.get_invalidation_requests('dist-id-here', marker=ir.next_marker, max_items=max_items) DCNL DCSP  DCSP invals = list(ir) DCNL DCSP  DCSP self.assertLessEqual(len(invals), max_items) DCNL DCSP  DCSP all_invals.extend(invals) DCNL DCSP remainder = (num_invals % max_items) DCNL DCSP if (remainder != 0): DCNL DCSP  DCSP self.assertEqual(len(invals), remainder) DCNL DCSP self.assertEqual(len(all_invals), num_invals)
def test_auto_pagination(self, num_invals=1024): DCNL DCSP max_items = 100 DCNL DCSP self.assertGreaterEqual(num_invals, max_items) DCNL DCSP responses = self._get_mock_responses(num=num_invals, max_items=max_items) DCNL DCSP self.cf.make_request = mock.Mock(side_effect=responses) DCNL DCSP ir = self.cf.get_invalidation_requests('dist-id-here') DCNL DCSP self.assertEqual(len(ir._inval_cache), max_items) DCNL DCSP self.assertEqual(len(list(ir)), num_invals)
def test_encode_custom_policy_1(self): DCNL DCSP expected = 'eyAKICAgIlN0YXRlbWVudCI6IFt7IAogICAgICAiUmVzb3VyY2UiOiJodHRwOi8vZDYwNDcyMWZ4YWFxeTkuY2xvdWRmcm9udC5uZXQvdHJhaW5pbmcvKiIsIAogICAgICAiQ29uZGl0aW9uIjp7IAogICAgICAgICAiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjE0NS4xNjguMTQzLjAvMjQifSwgCiAgICAgICAgICJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTI1ODIzNzIwMH0gICAgICAKICAgICAgfSAKICAgfV0gCn0K' DCNL DCSP encoded = self.dist._url_base64_encode(self.custom_policy_1) DCNL DCSP self.assertEqual(expected, encoded)
def test_encode_custom_policy_2(self): DCNL DCSP expected = 'eyAKICAgIlN0YXRlbWVudCI6IFt7IAogICAgICAiUmVzb3VyY2UiOiJodHRwOi8vKiIsIAogICAgICAiQ29uZGl0aW9uIjp7IAogICAgICAgICAiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjIxNi45OC4zNS4xLzMyIn0sCiAgICAgICAgICJEYXRlR3JlYXRlclRoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTI0MTA3Mzc5MH0sCiAgICAgICAgICJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTI1NTY3NDcxNn0KICAgICAgfSAKICAgfV0gCn0K' DCNL DCSP encoded = self.dist._url_base64_encode(self.custom_policy_2) DCNL DCSP self.assertEqual(expected, encoded)
def test_sign_canned_policy(self): DCNL DCSP expected = 'Nql641NHEUkUaXQHZINK1FZ~SYeUSoBJMxjdgqrzIdzV2gyEXPDNv0pYdWJkflDKJ3xIu7lbwRpSkG98NBlgPi4ZJpRRnVX4kXAJK6tdNx6FucDB7OVqzcxkxHsGFd8VCG1BkC-Afh9~lOCMIYHIaiOB6~5jt9w2EOwi6sIIqrg_' DCNL DCSP sig = self.dist._sign_string(self.canned_policy, private_key_string=self.pk_str) DCNL DCSP encoded_sig = self.dist._url_base64_encode(sig) DCNL DCSP self.assertEqual(expected, encoded_sig)
def test_sign_canned_policy_pk_file(self): DCNL DCSP expected = 'Nql641NHEUkUaXQHZINK1FZ~SYeUSoBJMxjdgqrzIdzV2gyEXPDNv0pYdWJkflDKJ3xIu7lbwRpSkG98NBlgPi4ZJpRRnVX4kXAJK6tdNx6FucDB7OVqzcxkxHsGFd8VCG1BkC-Afh9~lOCMIYHIaiOB6~5jt9w2EOwi6sIIqrg_' DCNL DCSP pk_file = tempfile.TemporaryFile() DCNL DCSP pk_file.write(self.pk_str) DCNL DCSP pk_file.seek(0) DCNL DCSP sig = self.dist._sign_string(self.canned_policy, private_key_file=pk_file) DCNL DCSP encoded_sig = self.dist._url_base64_encode(sig) DCNL DCSP self.assertEqual(expected, encoded_sig)
def test_sign_canned_policy_pk_file_name(self): DCNL DCSP expected = 'Nql641NHEUkUaXQHZINK1FZ~SYeUSoBJMxjdgqrzIdzV2gyEXPDNv0pYdWJkflDKJ3xIu7lbwRpSkG98NBlgPi4ZJpRRnVX4kXAJK6tdNx6FucDB7OVqzcxkxHsGFd8VCG1BkC-Afh9~lOCMIYHIaiOB6~5jt9w2EOwi6sIIqrg_' DCNL DCSP pk_file = tempfile.NamedTemporaryFile() DCNL DCSP pk_file.write(self.pk_str) DCNL DCSP pk_file.flush() DCNL DCSP sig = self.dist._sign_string(self.canned_policy, private_key_file=pk_file.name) DCNL DCSP encoded_sig = self.dist._url_base64_encode(sig) DCNL DCSP self.assertEqual(expected, encoded_sig)
def test_sign_canned_policy_pk_file_like(self): DCNL DCSP expected = 'Nql641NHEUkUaXQHZINK1FZ~SYeUSoBJMxjdgqrzIdzV2gyEXPDNv0pYdWJkflDKJ3xIu7lbwRpSkG98NBlgPi4ZJpRRnVX4kXAJK6tdNx6FucDB7OVqzcxkxHsGFd8VCG1BkC-Afh9~lOCMIYHIaiOB6~5jt9w2EOwi6sIIqrg_' DCNL DCSP pk_file = StringIO() DCNL DCSP pk_file.write(self.pk_str) DCNL DCSP pk_file.seek(0) DCNL DCSP sig = self.dist._sign_string(self.canned_policy, private_key_file=pk_file) DCNL DCSP encoded_sig = self.dist._url_base64_encode(sig) DCNL DCSP self.assertEqual(expected, encoded_sig)
def test_sign_canned_policy_unicode(self): DCNL DCSP expected = 'Nql641NHEUkUaXQHZINK1FZ~SYeUSoBJMxjdgqrzIdzV2gyEXPDNv0pYdWJkflDKJ3xIu7lbwRpSkG98NBlgPi4ZJpRRnVX4kXAJK6tdNx6FucDB7OVqzcxkxHsGFd8VCG1BkC-Afh9~lOCMIYHIaiOB6~5jt9w2EOwi6sIIqrg_' DCNL DCSP unicode_policy = six.text_type(self.canned_policy) DCNL DCSP sig = self.dist._sign_string(unicode_policy, private_key_string=self.pk_str) DCNL DCSP encoded_sig = self.dist._url_base64_encode(sig) DCNL DCSP self.assertEqual(expected, encoded_sig)
def test_sign_custom_policy_1(self): DCNL DCSP expected = 'cPFtRKvUfYNYmxek6ZNs6vgKEZP6G3Cb4cyVt~FjqbHOnMdxdT7eT6pYmhHYzuDsFH4Jpsctke2Ux6PCXcKxUcTIm8SO4b29~1QvhMl-CIojki3Hd3~Unxjw7Cpo1qRjtvrimW0DPZBZYHFZtiZXsaPt87yBP9GWnTQoaVysMxQ_' DCNL DCSP sig = self.dist._sign_string(self.custom_policy_1, private_key_string=self.pk_str) DCNL DCSP encoded_sig = self.dist._url_base64_encode(sig) DCNL DCSP self.assertEqual(expected, encoded_sig)
def test_sign_custom_policy_2(self): DCNL DCSP expected = 'rc~5Qbbm8EJXjUTQ6Cn0LAxR72g1DOPrTmdtfbWVVgQNw0q~KHUAmBa2Zv1Wjj8dDET4XSL~Myh44CLQdu4dOH~N9huH7QfPSR~O4tIOS1WWcP~2JmtVPoQyLlEc8YHRCuN3nVNZJ0m4EZcXXNAS-0x6Zco2SYx~hywTRxWR~5Q_' DCNL DCSP sig = self.dist._sign_string(self.custom_policy_2, private_key_string=self.pk_str) DCNL DCSP encoded_sig = self.dist._url_base64_encode(sig) DCNL DCSP self.assertEqual(expected, encoded_sig)
def test_create_canned_policy(self): DCNL DCSP url = 'http://1234567.cloudfront.com/test_resource.mp3?dog=true' DCNL DCSP expires = 999999 DCNL DCSP policy = self.dist._canned_policy(url, expires) DCNL DCSP policy = json.loads(policy) DCNL DCSP self.assertEqual(1, len(policy.keys())) DCNL DCSP statements = policy['Statement'] DCNL DCSP self.assertEqual(1, len(statements)) DCNL DCSP statement = statements[0] DCNL DCSP resource = statement['Resource'] DCNL DCSP self.assertEqual(url, resource) DCNL DCSP condition = statement['Condition'] DCNL DCSP self.assertEqual(1, len(condition.keys())) DCNL DCSP date_less_than = condition['DateLessThan'] DCNL DCSP self.assertEqual(1, len(date_less_than.keys())) DCNL DCSP aws_epoch_time = date_less_than['AWS:EpochTime'] DCNL DCSP self.assertEqual(expires, aws_epoch_time)
def test_custom_policy_expires_and_policy_url(self): DCNL DCSP url = 'http://1234567.cloudfront.com/*' DCNL DCSP expires = 999999 DCNL DCSP policy = self.dist._custom_policy(url, expires=expires) DCNL DCSP policy = json.loads(policy) DCNL DCSP self.assertEqual(1, len(policy.keys())) DCNL DCSP statements = policy['Statement'] DCNL DCSP self.assertEqual(1, len(statements)) DCNL DCSP statement = statements[0] DCNL DCSP resource = statement['Resource'] DCNL DCSP self.assertEqual(url, resource) DCNL DCSP condition = statement['Condition'] DCNL DCSP self.assertEqual(1, len(condition.keys())) DCNL DCSP date_less_than = condition['DateLessThan'] DCNL DCSP self.assertEqual(1, len(date_less_than.keys())) DCNL DCSP aws_epoch_time = date_less_than['AWS:EpochTime'] DCNL DCSP self.assertEqual(expires, aws_epoch_time)
def test_custom_policy_valid_after(self): DCNL DCSP url = 'http://1234567.cloudfront.com/*' DCNL DCSP valid_after = 999999 DCNL DCSP policy = self.dist._custom_policy(url, valid_after=valid_after) DCNL DCSP policy = json.loads(policy) DCNL DCSP self.assertEqual(1, len(policy.keys())) DCNL DCSP statements = policy['Statement'] DCNL DCSP self.assertEqual(1, len(statements)) DCNL DCSP statement = statements[0] DCNL DCSP resource = statement['Resource'] DCNL DCSP self.assertEqual(url, resource) DCNL DCSP condition = statement['Condition'] DCNL DCSP self.assertEqual(2, len(condition.keys())) DCNL DCSP date_less_than = condition['DateLessThan'] DCNL DCSP date_greater_than = condition['DateGreaterThan'] DCNL DCSP self.assertEqual(1, len(date_greater_than.keys())) DCNL DCSP aws_epoch_time = date_greater_than['AWS:EpochTime'] DCNL DCSP self.assertEqual(valid_after, aws_epoch_time)
def test_custom_policy_ip_address(self): DCNL DCSP url = 'http://1234567.cloudfront.com/*' DCNL DCSP ip_range = '192.168.0.1' DCNL DCSP policy = self.dist._custom_policy(url, ip_address=ip_range) DCNL DCSP policy = json.loads(policy) DCNL DCSP self.assertEqual(1, len(policy.keys())) DCNL DCSP statements = policy['Statement'] DCNL DCSP self.assertEqual(1, len(statements)) DCNL DCSP statement = statements[0] DCNL DCSP resource = statement['Resource'] DCNL DCSP self.assertEqual(url, resource) DCNL DCSP condition = statement['Condition'] DCNL DCSP self.assertEqual(2, len(condition.keys())) DCNL DCSP ip_address = condition['IpAddress'] DCNL DCSP self.assertTrue(('DateLessThan' in condition)) DCNL DCSP self.assertEqual(1, len(ip_address.keys())) DCNL DCSP source_ip = ip_address['AWS:SourceIp'] DCNL DCSP self.assertEqual(('%s/32' % ip_range), source_ip)
def test_custom_policy_ip_range(self): DCNL DCSP url = 'http://1234567.cloudfront.com/*' DCNL DCSP ip_range = '192.168.0.0/24' DCNL DCSP policy = self.dist._custom_policy(url, ip_address=ip_range) DCNL DCSP policy = json.loads(policy) DCNL DCSP self.assertEqual(1, len(policy.keys())) DCNL DCSP statements = policy['Statement'] DCNL DCSP self.assertEqual(1, len(statements)) DCNL DCSP statement = statements[0] DCNL DCSP resource = statement['Resource'] DCNL DCSP self.assertEqual(url, resource) DCNL DCSP condition = statement['Condition'] DCNL DCSP self.assertEqual(2, len(condition.keys())) DCNL DCSP self.assertTrue(('DateLessThan' in condition)) DCNL DCSP ip_address = condition['IpAddress'] DCNL DCSP self.assertEqual(1, len(ip_address.keys())) DCNL DCSP source_ip = ip_address['AWS:SourceIp'] DCNL DCSP self.assertEqual(ip_range, source_ip)
def test_custom_policy_all(self): DCNL DCSP url = 'http://1234567.cloudfront.com/test.txt' DCNL DCSP expires = 999999 DCNL DCSP valid_after = 111111 DCNL DCSP ip_range = '192.168.0.0/24' DCNL DCSP policy = self.dist._custom_policy(url, expires=expires, valid_after=valid_after, ip_address=ip_range) DCNL DCSP policy = json.loads(policy) DCNL DCSP self.assertEqual(1, len(policy.keys())) DCNL DCSP statements = policy['Statement'] DCNL DCSP self.assertEqual(1, len(statements)) DCNL DCSP statement = statements[0] DCNL DCSP resource = statement['Resource'] DCNL DCSP self.assertEqual(url, resource) DCNL DCSP condition = statement['Condition'] DCNL DCSP self.assertEqual(3, len(condition.keys())) DCNL DCSP date_less_than = condition['DateLessThan'] DCNL DCSP self.assertEqual(1, len(date_less_than.keys())) DCNL DCSP aws_epoch_time = date_less_than['AWS:EpochTime'] DCNL DCSP self.assertEqual(expires, aws_epoch_time) DCNL DCSP date_greater_than = condition['DateGreaterThan'] DCNL DCSP self.assertEqual(1, len(date_greater_than.keys())) DCNL DCSP aws_epoch_time = date_greater_than['AWS:EpochTime'] DCNL DCSP self.assertEqual(valid_after, aws_epoch_time) DCNL DCSP ip_address = condition['IpAddress'] DCNL DCSP self.assertEqual(1, len(ip_address.keys())) DCNL DCSP source_ip = ip_address['AWS:SourceIp'] DCNL DCSP self.assertEqual(ip_range, source_ip)
def test_params_canned_policy(self): DCNL DCSP url = 'http://d604721fxaaqy9.cloudfront.net/horizon.jpg?large=yes&license=yes' DCNL DCSP expire_time = 1258237200 DCNL DCSP expected_sig = 'Nql641NHEUkUaXQHZINK1FZ~SYeUSoBJMxjdgqrzIdzV2gyEXPDNv0pYdWJkflDKJ3xIu7lbwRpSkG98NBlgPi4ZJpRRnVX4kXAJK6tdNx6FucDB7OVqzcxkxHsGFd8VCG1BkC-Afh9~lOCMIYHIaiOB6~5jt9w2EOwi6sIIqrg_' DCNL DCSP signed_url_params = self.dist._create_signing_params(url, self.pk_id, expire_time, private_key_string=self.pk_str) DCNL DCSP self.assertEqual(3, len(signed_url_params)) DCNL DCSP self.assertEqual(signed_url_params['Expires'], '1258237200') DCNL DCSP self.assertEqual(signed_url_params['Signature'], expected_sig) DCNL DCSP self.assertEqual(signed_url_params['Key-Pair-Id'], 'PK123456789754')
def test_canned_policy(self): DCNL DCSP url = 'http://d604721fxaaqy9.cloudfront.net/horizon.jpg?large=yes&license=yes' DCNL DCSP expire_time = 1258237200 DCNL DCSP expected_url = 'http://d604721fxaaqy9.cloudfront.net/horizon.jpg?large=yes&license=yes&Expires=1258237200&Signature=Nql641NHEUkUaXQHZINK1FZ~SYeUSoBJMxjdgqrzIdzV2gyEXPDNv0pYdWJkflDKJ3xIu7lbwRpSkG98NBlgPi4ZJpRRnVX4kXAJK6tdNx6FucDB7OVqzcxkxHsGFd8VCG1BkC-Afh9~lOCMIYHIaiOB6~5jt9w2EOwi6sIIqrg_&Key-Pair-Id=PK123456789754' DCNL DCSP signed_url = self.dist.create_signed_url(url, self.pk_id, expire_time, private_key_string=self.pk_str) DCNL DCSP self.assertEqual(expected_url, signed_url)
def test_bidprice_missing_spot(self): DCNL DCSP with self.assertRaisesRegexp(ValueError, 'bidprice DCSP must DCSP be DCSP specified'): DCNL DCSP  DCSP InstanceGroup(1, 'MASTER', 'm1.small', 'SPOT', 'master')
def test_bidprice_missing_ondemand(self): DCNL DCSP instance_group = InstanceGroup(1, 'MASTER', 'm1.small', 'ON_DEMAND', 'master')
def test_bidprice_Decimal(self): DCNL DCSP instance_group = InstanceGroup(1, 'MASTER', 'm1.small', 'SPOT', 'master', bidprice=Decimal(1.1)) DCNL DCSP self.assertEquals('1.10', instance_group.bidprice[:4])
def test_bidprice_float(self): DCNL DCSP instance_group = InstanceGroup(1, 'MASTER', 'm1.small', 'SPOT', 'master', bidprice=1.1) DCNL DCSP self.assertEquals('1.1', instance_group.bidprice)
def test_bidprice_string(self): DCNL DCSP instance_group = InstanceGroup(1, 'MASTER', 'm1.small', 'SPOT', 'master', bidprice='1.1') DCNL DCSP self.assertEquals('1.1', instance_group.bidprice)
def test_cloudsearch_results_meta(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP self.assertEqual(results.rank, '-text_relevance') DCNL DCSP self.assertEqual(results.match_expression, 'Test')
def test_cloudsearch_results_info(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP self.assertEqual(results.num_pages_needed, 3.0)
def test_cloudsearch_results_matched(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP query = search.build_query(q='Test') DCNL DCSP results = search(query) DCNL DCSP self.assertEqual(results.search_service, search) DCNL DCSP self.assertEqual(results.query, query)
def test_cloudsearch_results_hits(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP hits = list(map((lambda x: x['id']), results.docs)) DCNL DCSP self.assertEqual(hits, ['12341', '12342', '12343', '12344', '12345', '12346', '12347'])
def test_cloudsearch_results_iterator(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP results_correct = iter(['12341', '12342', '12343', '12344', '12345', '12346', '12347']) DCNL DCSP for x in results: DCNL DCSP  DCSP self.assertEqual(x['id'], next(results_correct))
def test_cloudsearch_results_internal_consistancy(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP results = search.search(q='Test') DCNL DCSP self.assertEqual(len(results), len(results.docs))
def test_cloudsearch_search_nextpage(self): DCNL DCSP search = SearchConnection(endpoint=HOSTNAME) DCNL DCSP query1 = search.build_query(q='Test') DCNL DCSP query2 = search.build_query(q='Test') DCNL DCSP results = search(query2) DCNL DCSP self.assertEqual(results.next_page().query.start, (query1.start + query1.size)) DCNL DCSP self.assertEqual(query1.q, query2.q)
def test_cloudsearch_connect_result_endpoints(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.create_domain('demo') DCNL DCSP domain = Domain(self, api_response) DCNL DCSP self.assertEqual(domain.doc_service_arn, 'arn:aws:cs:us-east-1:1234567890:doc/demo') DCNL DCSP self.assertEqual(domain.doc_service_endpoint, 'doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP self.assertEqual(domain.search_service_arn, 'arn:aws:cs:us-east-1:1234567890:search/demo') DCNL DCSP self.assertEqual(domain.search_service_endpoint, 'search-demo-userdomain.us-east-1.cloudsearch.amazonaws.com')
def test_cloudsearch_connect_result_statuses(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.create_domain('demo') DCNL DCSP domain = Domain(self, api_response) DCNL DCSP self.assertEqual(domain.created, True) DCNL DCSP self.assertEqual(domain.processing, False) DCNL DCSP self.assertEqual(domain.requires_index_documents, False) DCNL DCSP self.assertEqual(domain.deleted, False)
def test_cloudsearch_connect_result_details(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.create_domain('demo') DCNL DCSP domain = Domain(self, api_response) DCNL DCSP self.assertEqual(domain.id, '1234567890/demo') DCNL DCSP self.assertEqual(domain.name, 'demo')
def test_cloudsearch_deletion(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.delete_domain('demo') DCNL DCSP self.assert_request_parameters({'Action': 'DeleteDomain', 'DomainName': 'demo', 'Version': '2011-02-01'})
def test_cloudsearch_index_documents(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.index_documents('demo') DCNL DCSP self.assert_request_parameters({'Action': 'IndexDocuments', 'DomainName': 'demo', 'Version': '2011-02-01'})
def test_cloudsearch_index_documents_resp(self): DCNL DCSP self.set_http_response(status_code=200) DCNL DCSP api_response = self.service_connection.index_documents('demo') DCNL DCSP self.assertEqual(api_response, ['average_score', 'brand_id', 'colors', 'context', 'context_owner', 'created_at', 'creator_id', 'description', 'file_size', 'format', 'has_logo', 'has_messaging', 'height', 'image_id', 'ingested_from', 'is_advertising', 'is_photo', 'is_reviewed', 'modified_at', 'subject_date', 'tags', 'title', 'width'])
def test_cloudsearch_add_basics(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.add('1234', 10, {'id': '1234', 'title': 'Title DCSP 1', 'category': ['cat_a', 'cat_b', 'cat_c']}) DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8'))[0] DCNL DCSP self.assertEqual(args['lang'], 'en') DCNL DCSP self.assertEqual(args['type'], 'add')
def test_cloudsearch_add_single_basic(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.add('1234', 10, {'id': '1234', 'title': 'Title DCSP 1', 'category': ['cat_a', 'cat_b', 'cat_c']}) DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8'))[0] DCNL DCSP self.assertEqual(args['id'], '1234') DCNL DCSP self.assertEqual(args['version'], 10) DCNL DCSP self.assertEqual(args['type'], 'add')
def test_cloudsearch_add_single_fields(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.add('1234', 10, {'id': '1234', 'title': 'Title DCSP 1', 'category': ['cat_a', 'cat_b', 'cat_c']}) DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8'))[0] DCNL DCSP self.assertEqual(args['fields']['category'], ['cat_a', 'cat_b', 'cat_c']) DCNL DCSP self.assertEqual(args['fields']['id'], '1234') DCNL DCSP self.assertEqual(args['fields']['title'], 'Title DCSP 1')
def test_cloudsearch_add_single_result(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.add('1234', 10, {'id': '1234', 'title': 'Title DCSP 1', 'category': ['cat_a', 'cat_b', 'cat_c']}) DCNL DCSP doc = document.commit() DCNL DCSP self.assertEqual(doc.status, 'success') DCNL DCSP self.assertEqual(doc.adds, 1) DCNL DCSP self.assertEqual(doc.deletes, 0) DCNL DCSP self.assertEqual(doc.doc_service, document)
def test_cloudsearch_add_basics(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP for (key, obj) in self.objs.items(): DCNL DCSP  DCSP document.add(key, obj['version'], obj['fields']) DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8')) DCNL DCSP for arg in args: DCNL DCSP  DCSP self.assertTrue((arg['id'] in self.objs)) DCNL DCSP  DCSP self.assertEqual(arg['version'], self.objs[arg['id']]['version']) DCNL DCSP  DCSP self.assertEqual(arg['fields']['id'], self.objs[arg['id']]['fields']['id']) DCNL DCSP  DCSP self.assertEqual(arg['fields']['title'], self.objs[arg['id']]['fields']['title']) DCNL DCSP  DCSP self.assertEqual(arg['fields']['category'], self.objs[arg['id']]['fields']['category'])
def test_cloudsearch_add_results(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP for (key, obj) in self.objs.items(): DCNL DCSP  DCSP document.add(key, obj['version'], obj['fields']) DCNL DCSP doc = document.commit() DCNL DCSP self.assertEqual(doc.status, 'success') DCNL DCSP self.assertEqual(doc.adds, len(self.objs)) DCNL DCSP self.assertEqual(doc.deletes, 0)
def test_cloudsearch_delete(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.delete('5', '10') DCNL DCSP document.commit() DCNL DCSP args = json.loads(HTTPretty.last_request.body.decode('utf-8'))[0] DCNL DCSP self.assertEqual(args['version'], '10') DCNL DCSP self.assertEqual(args['type'], 'delete') DCNL DCSP self.assertEqual(args['id'], '5')
def test_cloudsearch_delete_results(self): DCNL DCSP document = DocumentServiceConnection(endpoint='doc-demo-userdomain.us-east-1.cloudsearch.amazonaws.com') DCNL DCSP document.delete('5', '10') DCNL DCSP doc = document.commit() DCNL DCSP self.assertEqual(doc.status, 'success') DCNL DCSP self.assertEqual(doc.adds, 0) DCNL DCSP self.assertEqual(doc.deletes, 1)
def clstest(self, cls): DCNL DCSP password = cls('foo') DCNL DCSP self.assertNotEquals(password, 'foo') DCNL DCSP password.set('foo') DCNL DCSP hashed = str(password) DCNL DCSP self.assertEquals(password, 'foo') DCNL DCSP self.assertEquals(password.str, hashed) DCNL DCSP password = cls(hashed) DCNL DCSP self.assertNotEquals(password.str, 'foo') DCNL DCSP self.assertEquals(password, 'foo') DCNL DCSP self.assertEquals(password.str, hashed)
def test_decoding_full_doc(self): DCNL DCSP dynamizer = types.Dynamizer() DCNL DCSP doc = '{"__type__":{"S":"Story"},"company_tickers":{"SS":["NASDAQ-TSLA","NYSE-F","NYSE-GM"]},"modified_at":{"N":"1452525162"},"created_at":{"N":"1452525162"},"version":{"N":"1"},"categories":{"SS":["AUTOMTVE","LTRTR","MANUFCTU","PN","PRHYPE","TAXE","TJ","TL"]},"provider_categories":{"L":[{"S":"F"},{"S":"GM"},{"S":"TSLA"}]},"received_at":{"S":"2016-01-11T11:26:31Z"}}' DCNL DCSP output_doc = {'provider_categories': ['F', 'GM', 'TSLA'], '__type__': 'Story', 'company_tickers': set(['NASDAQ-TSLA', 'NYSE-GM', 'NYSE-F']), 'modified_at': Decimal('1452525162'), 'version': Decimal('1'), 'received_at': '2016-01-11T11:26:31Z', 'created_at': Decimal('1452525162'), 'categories': set(['LTRTR', 'TAXE', 'MANUFCTU', 'TL', 'TJ', 'AUTOMTVE', 'PRHYPE', 'PN'])} DCNL DCSP self.assertEqual(json.loads(doc, object_hook=dynamizer.decode), output_doc)
def test_pickle_deserialized_version(self): DCNL DCSP result = self.create_hit_result() DCNL DCSP new_result = pickle.loads(pickle.dumps(result)) DCNL DCSP pickle.dumps(new_result)
def __new__(cls, s, *args): DCNL DCSP inst = int.__new__(cls, cls.boolval) DCNL DCSP inst.s = s DCNL DCSP inst.args = args DCNL DCSP return inst
@property DCNL def msg(self): DCNL DCSP return (self.s % self.args)
def __new__(cls, ace, acl, permission, principals, context): DCNL DCSP fmt = '%s DCSP permission DCSP %r DCSP via DCSP ACE DCSP %r DCSP in DCSP ACL DCSP %r DCSP on DCSP context DCSP %r DCSP for DCSP principals DCSP %r' DCNL DCSP inst = PermitsResult.__new__(cls, fmt, cls.__name__, permission, ace, acl, context, principals) DCNL DCSP inst.permission = permission DCNL DCSP inst.ace = ace DCNL DCSP inst.acl = acl DCNL DCSP inst.principals = principals DCNL DCSP inst.context = context DCNL DCSP return inst
@property DCNL def authenticated_userid(self): DCNL DCSP policy = self._get_authentication_policy() DCNL DCSP if (policy is None): DCNL DCSP  DCSP return None DCNL DCSP return policy.authenticated_userid(self)
@property DCNL def unauthenticated_userid(self): DCNL DCSP policy = self._get_authentication_policy() DCNL DCSP if (policy is None): DCNL DCSP  DCSP return None DCNL DCSP return policy.unauthenticated_userid(self)
@property DCNL def effective_principals(self): DCNL DCSP policy = self._get_authentication_policy() DCNL DCSP if (policy is None): DCNL DCSP  DCSP return [Everyone] DCNL DCSP return policy.effective_principals(self)
def has_permission(self, permission, context=None): DCNL DCSP if (context is None): DCNL DCSP  DCSP context = self.context DCNL DCSP reg = _get_registry(self) DCNL DCSP authn_policy = reg.queryUtility(IAuthenticationPolicy) DCNL DCSP if (authn_policy is None): DCNL DCSP  DCSP return Allowed('No DCSP authentication DCSP policy DCSP in DCSP use.') DCNL DCSP authz_policy = reg.queryUtility(IAuthorizationPolicy) DCNL DCSP if (authz_policy is None): DCNL DCSP  DCSP raise ValueError('Authentication DCSP policy DCSP registered DCSP without DCSP authorization DCSP policy') DCNL DCSP principals = authn_policy.effective_principals(self) DCNL DCSP return authz_policy.permits(context, principals, permission)
def permits(self, context, principals, permission): DCNL DCSP acl = '<No DCSP ACL DCSP found DCSP on DCSP any DCSP object DCSP in DCSP resource DCSP lineage>' DCNL DCSP for location in lineage(context): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP acl = location.__acl__ DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (acl and callable(acl)): DCNL DCSP  DCSP  DCSP acl = acl() DCNL DCSP  DCSP for ace in acl: DCNL DCSP  DCSP  DCSP (ace_action, ace_principal, ace_permissions) = ace DCNL DCSP  DCSP  DCSP if (ace_principal in principals): DCNL DCSP  DCSP  DCSP  DCSP if (not is_nonstr_iter(ace_permissions)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ace_permissions = [ace_permissions] DCNL DCSP  DCSP  DCSP  DCSP if (permission in ace_permissions): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ace_action == Allow): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return ACLAllowed(ace, acl, permission, principals, location) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return ACLDenied(ace, acl, permission, principals, location) DCNL DCSP return ACLDenied('<default DCSP deny>', acl, permission, principals, context)
def principals_allowed_by_permission(self, context, permission): DCNL DCSP allowed = set() DCNL DCSP for location in reversed(list(lineage(context))): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP acl = location.__acl__ DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP allowed_here = set() DCNL DCSP  DCSP denied_here = set() DCNL DCSP  DCSP if (acl and callable(acl)): DCNL DCSP  DCSP  DCSP acl = acl() DCNL DCSP  DCSP for (ace_action, ace_principal, ace_permissions) in acl: DCNL DCSP  DCSP  DCSP if (not is_nonstr_iter(ace_permissions)): DCNL DCSP  DCSP  DCSP  DCSP ace_permissions = [ace_permissions] DCNL DCSP  DCSP  DCSP if ((ace_action == Allow) and (permission in ace_permissions)): DCNL DCSP  DCSP  DCSP  DCSP if (ace_principal not in denied_here): DCNL DCSP  DCSP  DCSP  DCSP  DCSP allowed_here.add(ace_principal) DCNL DCSP  DCSP  DCSP if ((ace_action == Deny) and (permission in ace_permissions)): DCNL DCSP  DCSP  DCSP  DCSP denied_here.add(ace_principal) DCNL DCSP  DCSP  DCSP  DCSP if (ace_principal == Everyone): DCNL DCSP  DCSP  DCSP  DCSP  DCSP allowed = set() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP elif (ace_principal in allowed): DCNL DCSP  DCSP  DCSP  DCSP  DCSP allowed.remove(ace_principal) DCNL DCSP  DCSP allowed.update(allowed_here) DCNL DCSP return allowed
def invoke_exception_view(self, exc_info=None, request=None, secure=True, reraise=False): DCNL DCSP if (request is None): DCNL DCSP  DCSP request = self DCNL DCSP registry = getattr(request, 'registry', None) DCNL DCSP if (registry is None): DCNL DCSP  DCSP registry = get_current_registry() DCNL DCSP if (registry is None): DCNL DCSP  DCSP raise RuntimeError('Unable DCSP to DCSP retrieve DCSP registry') DCNL DCSP if (exc_info is None): DCNL DCSP  DCSP exc_info = sys.exc_info() DCNL DCSP exc = exc_info[1] DCNL DCSP attrs = request.__dict__ DCNL DCSP context_iface = providedBy(exc) DCNL DCSP with hide_attrs(request, 'response', 'exc_info', 'exception'): DCNL DCSP  DCSP attrs['exception'] = exc DCNL DCSP  DCSP attrs['exc_info'] = exc_info DCNL DCSP  DCSP request_iface = attrs.get('request_iface', IRequest) DCNL DCSP  DCSP manager.push({'request': request, 'registry': registry}) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response = _call_view(registry, request, exc, context_iface, '', view_types=None, view_classifier=IExceptionViewClassifier, secure=secure, request_iface=request_iface.combined) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP if reraise: DCNL DCSP  DCSP  DCSP  DCSP reraise_(*exc_info) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP manager.pop() DCNL DCSP if (response is None): DCNL DCSP  DCSP if reraise: DCNL DCSP  DCSP  DCSP reraise_(*exc_info) DCNL DCSP  DCSP raise HTTPNotFound DCNL DCSP attrs['exception'] = exc DCNL DCSP attrs['exc_info'] = exc_info DCNL DCSP return response
@classmethod DCNL def make_property(cls, callable, name=None, reify=False): DCNL DCSP is_property = isinstance(callable, property) DCNL DCSP if is_property: DCNL DCSP  DCSP fn = callable DCNL DCSP  DCSP if (name is None): DCNL DCSP  DCSP  DCSP raise ValueError('must DCSP specify DCSP "name" DCSP for DCSP a DCSP property') DCNL DCSP  DCSP if reify: DCNL DCSP  DCSP  DCSP raise ValueError('cannot DCSP reify DCSP a DCSP property') DCNL DCSP elif (name is not None): DCNL DCSP  DCSP fn = (lambda this: callable(this)) DCNL DCSP  DCSP fn.__name__ = get_callable_name(name) DCNL DCSP  DCSP fn.__doc__ = callable.__doc__ DCNL DCSP else: DCNL DCSP  DCSP name = callable.__name__ DCNL DCSP  DCSP fn = callable DCNL DCSP if reify: DCNL DCSP  DCSP import pyramid.decorator DCNL DCSP  DCSP fn = pyramid.decorator.reify(fn) DCNL DCSP elif (not is_property): DCNL DCSP  DCSP fn = property(fn) DCNL DCSP return (name, fn)
@classmethod DCNL def apply_properties(cls, target, properties): DCNL DCSP attrs = dict(properties) DCNL DCSP if attrs: DCNL DCSP  DCSP parent = target.__class__ DCNL DCSP  DCSP attrs.setdefault('__module__', parent.__module__) DCNL DCSP  DCSP newcls = type(parent.__name__, (parent, object), attrs) DCNL DCSP  DCSP for name in ('__implemented__', '__provides__'): DCNL DCSP  DCSP  DCSP val = getattr(parent, name, _marker) DCNL DCSP  DCSP  DCSP if (val is not _marker): DCNL DCSP  DCSP  DCSP  DCSP setattr(newcls, name, val) DCNL DCSP  DCSP target.__class__ = newcls
@classmethod DCNL def set_property(cls, target, callable, name=None, reify=False): DCNL DCSP prop = cls.make_property(callable, name=name, reify=reify) DCNL DCSP cls.apply_properties(target, [prop])
def add_property(self, callable, name=None, reify=False): DCNL DCSP (name, fn) = self.make_property(callable, name=name, reify=reify) DCNL DCSP self.properties[name] = fn
def apply(self, target): DCNL DCSP if self.properties: DCNL DCSP  DCSP self.apply_properties(target, self.properties)
def set_property(self, callable, name=None, reify=False): DCNL DCSP InstancePropertyHelper.set_property(self, callable, name=name, reify=reify)
def add(self, item): DCNL DCSP oid = id(item) DCNL DCSP if (oid in self._items): DCNL DCSP  DCSP self._order.remove(oid) DCNL DCSP  DCSP self._order.append(oid) DCNL DCSP  DCSP return DCNL DCSP ref = weakref.ref(item, (lambda x: self._remove_by_id(oid))) DCNL DCSP self._items[oid] = ref DCNL DCSP self._order.append(oid)
def _remove_by_id(self, oid): DCNL DCSP if (oid in self._items): DCNL DCSP  DCSP del self._items[oid] DCNL DCSP  DCSP self._order.remove(oid)
def remove(self, item): DCNL DCSP self._remove_by_id(id(item))
def empty(self): DCNL DCSP self._items = {} DCNL DCSP self._order = []
def remove(self, name): DCNL DCSP self.names.remove(name) DCNL DCSP del self.name2val[name] DCNL DCSP after = self.name2after.pop(name, []) DCNL DCSP if after: DCNL DCSP  DCSP self.req_after.remove(name) DCNL DCSP  DCSP for u in after: DCNL DCSP  DCSP  DCSP self.order.remove((u, name)) DCNL DCSP before = self.name2before.pop(name, []) DCNL DCSP if before: DCNL DCSP  DCSP self.req_before.remove(name) DCNL DCSP  DCSP for u in before: DCNL DCSP  DCSP  DCSP self.order.remove((name, u))
def add(self, name, val, after=None, before=None): DCNL DCSP if (name in self.names): DCNL DCSP  DCSP self.remove(name) DCNL DCSP self.names.append(name) DCNL DCSP self.name2val[name] = val DCNL DCSP if ((after is None) and (before is None)): DCNL DCSP  DCSP before = self.default_before DCNL DCSP  DCSP after = self.default_after DCNL DCSP if (after is not None): DCNL DCSP  DCSP if (not is_nonstr_iter(after)): DCNL DCSP  DCSP  DCSP after = (after,) DCNL DCSP  DCSP self.name2after[name] = after DCNL DCSP  DCSP self.order += [(u, name) for u in after] DCNL DCSP  DCSP self.req_after.add(name) DCNL DCSP if (before is not None): DCNL DCSP  DCSP if (not is_nonstr_iter(before)): DCNL DCSP  DCSP  DCSP before = (before,) DCNL DCSP  DCSP self.name2before[name] = before DCNL DCSP  DCSP self.order += [(name, o) for o in before] DCNL DCSP  DCSP self.req_before.add(name)
def sorted(self): DCNL DCSP order = [(self.first, self.last)] DCNL DCSP roots = [] DCNL DCSP graph = {} DCNL DCSP names = [self.first, self.last] DCNL DCSP names.extend(self.names) DCNL DCSP for (a, b) in self.order: DCNL DCSP  DCSP order.append((a, b)) DCNL DCSP def add_node(node): DCNL DCSP  DCSP if (node not in graph): DCNL DCSP  DCSP  DCSP roots.append(node) DCNL DCSP  DCSP  DCSP graph[node] = [0] DCNL DCSP def add_arc(fromnode, tonode): DCNL DCSP  DCSP graph[fromnode].append(tonode) DCNL DCSP  DCSP graph[tonode][0] += 1 DCNL DCSP  DCSP if (tonode in roots): DCNL DCSP  DCSP  DCSP roots.remove(tonode) DCNL DCSP for name in names: DCNL DCSP  DCSP add_node(name) DCNL DCSP (has_before, has_after) = (set(), set()) DCNL DCSP for (a, b) in order: DCNL DCSP  DCSP if ((a in names) and (b in names)): DCNL DCSP  DCSP  DCSP add_arc(a, b) DCNL DCSP  DCSP  DCSP has_before.add(a) DCNL DCSP  DCSP  DCSP has_after.add(b) DCNL DCSP if (not self.req_before.issubset(has_before)): DCNL DCSP  DCSP raise ConfigurationError(('Unsatisfied DCSP before DCSP dependencies: DCSP %s' % ', DCSP '.join(sorted((self.req_before - has_before))))) DCNL DCSP if (not self.req_after.issubset(has_after)): DCNL DCSP  DCSP raise ConfigurationError(('Unsatisfied DCSP after DCSP dependencies: DCSP %s' % ', DCSP '.join(sorted((self.req_after - has_after))))) DCNL DCSP sorted_names = [] DCNL DCSP while roots: DCNL DCSP  DCSP root = roots.pop(0) DCNL DCSP  DCSP sorted_names.append(root) DCNL DCSP  DCSP children = graph[root][1:] DCNL DCSP  DCSP for child in children: DCNL DCSP  DCSP  DCSP arcs = graph[child][0] DCNL DCSP  DCSP  DCSP arcs -= 1 DCNL DCSP  DCSP  DCSP graph[child][0] = arcs DCNL DCSP  DCSP  DCSP if (arcs == 0): DCNL DCSP  DCSP  DCSP  DCSP roots.insert(0, child) DCNL DCSP  DCSP del graph[root] DCNL DCSP if graph: DCNL DCSP  DCSP cycledeps = {} DCNL DCSP  DCSP for (k, v) in graph.items(): DCNL DCSP  DCSP  DCSP cycledeps[k] = v[1:] DCNL DCSP  DCSP raise CyclicDependencyError(cycledeps) DCNL DCSP result = [] DCNL DCSP for name in sorted_names: DCNL DCSP  DCSP if (name in self.names): DCNL DCSP  DCSP  DCSP result.append((name, self.name2val[name])) DCNL DCSP return result
def resolve(self, spec): DCNL DCSP if os.path.isabs(spec): DCNL DCSP  DCSP return FSAssetDescriptor(spec) DCNL DCSP path = spec DCNL DCSP if (':' in path): DCNL DCSP  DCSP (package_name, path) = spec.split(':', 1) DCNL DCSP else: DCNL DCSP  DCSP if (self.package is CALLER_PACKAGE): DCNL DCSP  DCSP  DCSP package_name = caller_package().__name__ DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP package_name = getattr(self.package, '__name__', None) DCNL DCSP  DCSP if (package_name is None): DCNL DCSP  DCSP  DCSP raise ValueError(('relative DCSP spec DCSP %r DCSP irresolveable DCSP without DCSP package' % (spec,))) DCNL DCSP return PkgResourcesAssetDescriptor(package_name, path)
def resolve(self, dotted): DCNL DCSP if (not isinstance(dotted, string_types)): DCNL DCSP  DCSP raise ValueError(('%r DCSP is DCSP not DCSP a DCSP string' % (dotted,))) DCNL DCSP package = self.package DCNL DCSP if (package is CALLER_PACKAGE): DCNL DCSP  DCSP package = caller_package() DCNL DCSP return self._resolve(dotted, package)
def maybe_resolve(self, dotted): DCNL DCSP if isinstance(dotted, string_types): DCNL DCSP  DCSP package = self.package DCNL DCSP  DCSP if (package is CALLER_PACKAGE): DCNL DCSP  DCSP  DCSP package = caller_package() DCNL DCSP  DCSP return self._resolve(dotted, package) DCNL DCSP return dotted
def _pkg_resources_style(self, value, package): DCNL DCSP if value.startswith(('.', ':')): DCNL DCSP  DCSP if (not package): DCNL DCSP  DCSP  DCSP raise ValueError(('relative DCSP name DCSP %r DCSP irresolveable DCSP without DCSP package' % (value,))) DCNL DCSP  DCSP if (value in ['.', ':']): DCNL DCSP  DCSP  DCSP value = package.__name__ DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = (package.__name__ + value) DCNL DCSP ep = pkg_resources.EntryPoint.parse(('x=%s' % value)) DCNL DCSP if hasattr(ep, 'resolve'): DCNL DCSP  DCSP return ep.resolve() DCNL DCSP else: DCNL DCSP  DCSP return ep.load(False)
def _zope_dottedname_style(self, value, package): DCNL DCSP module = getattr(package, '__name__', None) DCNL DCSP if (not module): DCNL DCSP  DCSP module = None DCNL DCSP if (value == '.'): DCNL DCSP  DCSP if (module is None): DCNL DCSP  DCSP  DCSP raise ValueError(('relative DCSP name DCSP %r DCSP irresolveable DCSP without DCSP package' % (value,))) DCNL DCSP  DCSP name = module.split('.') DCNL DCSP else: DCNL DCSP  DCSP name = value.split('.') DCNL DCSP  DCSP if (not name[0]): DCNL DCSP  DCSP  DCSP if (module is None): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('relative DCSP name DCSP %r DCSP irresolveable DCSP without DCSP package' % (value,))) DCNL DCSP  DCSP  DCSP module = module.split('.') DCNL DCSP  DCSP  DCSP name.pop(0) DCNL DCSP  DCSP  DCSP while (not name[0]): DCNL DCSP  DCSP  DCSP  DCSP module.pop() DCNL DCSP  DCSP  DCSP  DCSP name.pop(0) DCNL DCSP  DCSP  DCSP name = (module + name) DCNL DCSP used = name.pop(0) DCNL DCSP found = __import__(used) DCNL DCSP for n in name: DCNL DCSP  DCSP used += ('.' + n) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP found = getattr(found, n) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP __import__(used) DCNL DCSP  DCSP  DCSP found = getattr(found, n) DCNL DCSP return found
def test_reset_reify(self): DCNL DCSP foo = Dummy() DCNL DCSP helper = self._getTargetClass() DCNL DCSP helper.set_property(foo, (lambda _: 1), name='x', reify=True) DCNL DCSP self.assertEqual(1, foo.x) DCNL DCSP helper.set_property(foo, (lambda _: 2), name='x', reify=True) DCNL DCSP self.assertEqual(1, foo.x)
def test_reset_reify(self): DCNL DCSP foo = self._makeOne() DCNL DCSP foo.set_property((lambda _: 1), name='x', reify=True) DCNL DCSP self.assertEqual(1, foo.x) DCNL DCSP foo.set_property((lambda _: 2), name='x', reify=True) DCNL DCSP self.assertEqual(1, foo.x)
def test__process_response_callback_adding_response_callback(self): DCNL DCSP inst = self._makeOne() DCNL DCSP def callback1(request, response): DCNL DCSP  DCSP request.called1 = True DCNL DCSP  DCSP response.called1 = True DCNL DCSP  DCSP request.add_response_callback(callback2) DCNL DCSP def callback2(request, response): DCNL DCSP  DCSP request.called2 = True DCNL DCSP  DCSP response.called2 = True DCNL DCSP inst.add_response_callback(callback1) DCNL DCSP response = DummyResponse() DCNL DCSP inst._process_response_callbacks(response) DCNL DCSP self.assertEqual(inst.called1, True) DCNL DCSP self.assertEqual(inst.called2, True) DCNL DCSP self.assertEqual(response.called1, True) DCNL DCSP self.assertEqual(response.called2, True) DCNL DCSP self.assertEqual(len(inst.response_callbacks), 0)
def translate(self, tstring, domain=None, mapping=None): DCNL DCSP if (self.translator is None): DCNL DCSP  DCSP self.translator = Translator(self.translations) DCNL DCSP return self.translator(tstring, domain=domain, mapping=mapping)
def pluralize(self, singular, plural, n, domain=None, mapping=None): DCNL DCSP if (self.pluralizer is None): DCNL DCSP  DCSP self.pluralizer = Pluralizer(self.translations) DCNL DCSP return self.pluralizer(singular, plural, n, domain=domain, mapping=mapping)
def __init__(self, fileobj=None, domain=DEFAULT_DOMAIN): DCNL DCSP self.plural = DEFAULT_PLURAL DCNL DCSP gettext.GNUTranslations.__init__(self, fp=fileobj) DCNL DCSP self.files = list(filter(None, [getattr(fileobj, 'name', None)])) DCNL DCSP self.domain = domain DCNL DCSP self._domains = {}
@classmethod DCNL def load(cls, dirname=None, locales=None, domain=DEFAULT_DOMAIN): DCNL DCSP if (locales is not None): DCNL DCSP  DCSP if (not isinstance(locales, (list, tuple))): DCNL DCSP  DCSP  DCSP locales = [locales] DCNL DCSP  DCSP locales = [str(l) for l in locales] DCNL DCSP if (not domain): DCNL DCSP  DCSP domain = cls.DEFAULT_DOMAIN DCNL DCSP filename = gettext.find(domain, dirname, locales) DCNL DCSP if (not filename): DCNL DCSP  DCSP return gettext.NullTranslations() DCNL DCSP with open(filename, 'rb') as fp: DCNL DCSP  DCSP return cls(fileobj=fp, domain=domain)
def add(self, translations, merge=True): DCNL DCSP domain = getattr(translations, 'domain', self.DEFAULT_DOMAIN) DCNL DCSP if ((domain == self.DEFAULT_DOMAIN) and (self.plural is DEFAULT_PLURAL)): DCNL DCSP  DCSP self.plural = translations.plural DCNL DCSP if (merge and (domain == self.domain)): DCNL DCSP  DCSP return self.merge(translations) DCNL DCSP existing = self._domains.get(domain) DCNL DCSP if (merge and (existing is not None)): DCNL DCSP  DCSP existing.merge(translations) DCNL DCSP else: DCNL DCSP  DCSP translations.add_fallback(self) DCNL DCSP  DCSP self._domains[domain] = translations DCNL DCSP return self
def merge(self, translations): DCNL DCSP if isinstance(translations, gettext.GNUTranslations): DCNL DCSP  DCSP self._catalog.update(translations._catalog) DCNL DCSP  DCSP if isinstance(translations, Translations): DCNL DCSP  DCSP  DCSP self.files.extend(translations.files) DCNL DCSP return self
def dgettext(self, domain, message): DCNL DCSP return self._domains.get(domain, self).gettext(message)
def ldgettext(self, domain, message): DCNL DCSP return self._domains.get(domain, self).lgettext(message)
def dugettext(self, domain, message): DCNL DCSP if PY2: DCNL DCSP  DCSP return self._domains.get(domain, self).ugettext(message) DCNL DCSP else: DCNL DCSP  DCSP return self._domains.get(domain, self).gettext(message)
def dngettext(self, domain, singular, plural, num): DCNL DCSP return self._domains.get(domain, self).ngettext(singular, plural, num)
def ldngettext(self, domain, singular, plural, num): DCNL DCSP return self._domains.get(domain, self).lngettext(singular, plural, num)
def dungettext(self, domain, singular, plural, num): DCNL DCSP if PY2: DCNL DCSP  DCSP return self._domains.get(domain, self).ungettext(singular, plural, num) DCNL DCSP else: DCNL DCSP  DCSP return self._domains.get(domain, self).ngettext(singular, plural, num)
@reify DCNL def localizer(self): DCNL DCSP registry = self.registry DCNL DCSP current_locale_name = self.locale_name DCNL DCSP localizer = registry.queryUtility(ILocalizer, name=current_locale_name) DCNL DCSP if (localizer is None): DCNL DCSP  DCSP tdirs = registry.queryUtility(ITranslationDirectories, default=[]) DCNL DCSP  DCSP localizer = make_localizer(current_locale_name, tdirs) DCNL DCSP  DCSP registry.registerUtility(localizer, ILocalizer, name=current_locale_name) DCNL DCSP return localizer
@action_method DCNL def set_authentication_policy(self, policy): DCNL DCSP def register(): DCNL DCSP  DCSP self._set_authentication_policy(policy) DCNL DCSP  DCSP if (self.registry.queryUtility(IAuthorizationPolicy) is None): DCNL DCSP  DCSP  DCSP raise ConfigurationError('Cannot DCSP configure DCSP an DCSP authentication DCSP policy DCSP without DCSP also DCSP configuring DCSP an DCSP authorization DCSP policy DCSP (use DCSP the DCSP set_authorization_policy DCSP method)') DCNL DCSP intr = self.introspectable('authentication DCSP policy', None, self.object_description(policy), 'authentication DCSP policy') DCNL DCSP intr['policy'] = policy DCNL DCSP self.action(IAuthenticationPolicy, register, order=PHASE2_CONFIG, introspectables=(intr,))
@action_method DCNL def set_authorization_policy(self, policy): DCNL DCSP def register(): DCNL DCSP  DCSP self._set_authorization_policy(policy) DCNL DCSP def ensure(): DCNL DCSP  DCSP if self.autocommit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (self.registry.queryUtility(IAuthenticationPolicy) is None): DCNL DCSP  DCSP  DCSP raise ConfigurationError('Cannot DCSP configure DCSP an DCSP authorization DCSP policy DCSP without DCSP also DCSP configuring DCSP an DCSP authentication DCSP policy DCSP (use DCSP the DCSP set_authorization_policy DCSP method)') DCNL DCSP intr = self.introspectable('authorization DCSP policy', None, self.object_description(policy), 'authorization DCSP policy') DCNL DCSP intr['policy'] = policy DCNL DCSP self.action(IAuthorizationPolicy, register, order=PHASE1_CONFIG, introspectables=(intr,)) DCNL DCSP self.action(None, ensure)
@action_method DCNL def set_default_permission(self, permission): DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(permission, IDefaultPermission) DCNL DCSP intr = self.introspectable('default DCSP permission', None, permission, 'default DCSP permission') DCNL DCSP intr['value'] = permission DCNL DCSP perm_intr = self.introspectable('permissions', permission, permission, 'permission') DCNL DCSP perm_intr['value'] = permission DCNL DCSP self.action(IDefaultPermission, register, order=PHASE1_CONFIG, introspectables=(intr, perm_intr))
def add_permission(self, permission_name): DCNL DCSP intr = self.introspectable('permissions', permission_name, permission_name, 'permission') DCNL DCSP intr['value'] = permission_name DCNL DCSP self.action(None, introspectables=(intr,))
@action_method DCNL def set_default_csrf_options(self, require_csrf=True, token='csrf_token', header='X-CSRF-Token', safe_methods=('GET', 'HEAD', 'OPTIONS', 'TRACE'), callback=None): DCNL DCSP options = DefaultCSRFOptions(require_csrf, token, header, safe_methods, callback) DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(options, IDefaultCSRFOptions) DCNL DCSP intr = self.introspectable('default DCSP csrf DCSP view DCSP options', None, options, 'default DCSP csrf DCSP view DCSP options') DCNL DCSP intr['require_csrf'] = require_csrf DCNL DCSP intr['token'] = token DCNL DCSP intr['header'] = header DCNL DCSP intr['safe_methods'] = as_sorted_tuple(safe_methods) DCNL DCSP intr['callback'] = callback DCNL DCSP self.action(IDefaultCSRFOptions, register, order=PHASE1_CONFIG, introspectables=(intr,))
@action_method DCNL def set_csrf_storage_policy(self, policy): DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(policy, ICSRFStoragePolicy) DCNL DCSP intr = self.introspectable('csrf DCSP storage DCSP policy', None, policy, 'csrf DCSP storage DCSP policy') DCNL DCSP intr['policy'] = policy DCNL DCSP self.action(ICSRFStoragePolicy, register, introspectables=(intr,))
def setup_registry(self, settings=None, root_factory=None, authentication_policy=None, authorization_policy=None, renderers=None, debug_logger=None, locale_negotiator=None, request_factory=None, response_factory=None, default_permission=None, session_factory=None, default_view_mapper=None, exceptionresponse_view=default_exceptionresponse_view): DCNL DCSP registry = self.registry DCNL DCSP self._fix_registry() DCNL DCSP self._set_settings(settings) DCNL DCSP if isinstance(debug_logger, string_types): DCNL DCSP  DCSP debug_logger = logging.getLogger(debug_logger) DCNL DCSP if (debug_logger is None): DCNL DCSP  DCSP debug_logger = logging.getLogger(self.package_name) DCNL DCSP registry.registerUtility(debug_logger, IDebugLogger) DCNL DCSP self.add_default_response_adapters() DCNL DCSP self.add_default_renderers() DCNL DCSP self.add_default_view_predicates() DCNL DCSP self.add_default_view_derivers() DCNL DCSP self.add_default_route_predicates() DCNL DCSP self.add_default_tweens() DCNL DCSP self.add_default_security() DCNL DCSP if (exceptionresponse_view is not None): DCNL DCSP  DCSP exceptionresponse_view = self.maybe_dotted(exceptionresponse_view) DCNL DCSP  DCSP self.add_view(exceptionresponse_view, context=IExceptionResponse) DCNL DCSP  DCSP self.add_view(exceptionresponse_view, context=WebobWSGIHTTPException) DCNL DCSP self.commit() DCNL DCSP if (authentication_policy and (not authorization_policy)): DCNL DCSP  DCSP authorization_policy = ACLAuthorizationPolicy() DCNL DCSP if authorization_policy: DCNL DCSP  DCSP self.set_authorization_policy(authorization_policy) DCNL DCSP if authentication_policy: DCNL DCSP  DCSP self.set_authentication_policy(authentication_policy) DCNL DCSP if (default_view_mapper is not None): DCNL DCSP  DCSP self.set_view_mapper(default_view_mapper) DCNL DCSP if renderers: DCNL DCSP  DCSP for (name, renderer) in renderers: DCNL DCSP  DCSP  DCSP self.add_renderer(name, renderer) DCNL DCSP if (root_factory is not None): DCNL DCSP  DCSP self.set_root_factory(root_factory) DCNL DCSP if locale_negotiator: DCNL DCSP  DCSP self.set_locale_negotiator(locale_negotiator) DCNL DCSP if request_factory: DCNL DCSP  DCSP self.set_request_factory(request_factory) DCNL DCSP if response_factory: DCNL DCSP  DCSP self.set_response_factory(response_factory) DCNL DCSP if default_permission: DCNL DCSP  DCSP self.set_default_permission(default_permission) DCNL DCSP if (session_factory is not None): DCNL DCSP  DCSP self.set_session_factory(session_factory) DCNL DCSP tweens = aslist(registry.settings.get('pyramid.tweens', [])) DCNL DCSP for factory in tweens: DCNL DCSP  DCSP self._add_tween(factory, explicit=True) DCNL DCSP includes = aslist(registry.settings.get('pyramid.includes', [])) DCNL DCSP for inc in includes: DCNL DCSP  DCSP self.include(inc)
def _fix_registry(self): DCNL DCSP _registry = self.registry DCNL DCSP if (not hasattr(_registry, 'notify')): DCNL DCSP  DCSP def notify(*events): DCNL DCSP  DCSP  DCSP [_ for _ in _registry.subscribers(events, None)] DCNL DCSP  DCSP _registry.notify = notify DCNL DCSP if (not hasattr(_registry, 'has_listeners')): DCNL DCSP  DCSP _registry.has_listeners = True DCNL DCSP if (not hasattr(_registry, 'queryAdapterOrSelf')): DCNL DCSP  DCSP def queryAdapterOrSelf(object, interface, default=None): DCNL DCSP  DCSP  DCSP if (not interface.providedBy(object)): DCNL DCSP  DCSP  DCSP  DCSP return _registry.queryAdapter(object, interface, default=default) DCNL DCSP  DCSP  DCSP return object DCNL DCSP  DCSP _registry.queryAdapterOrSelf = queryAdapterOrSelf DCNL DCSP if (not hasattr(_registry, 'registerSelfAdapter')): DCNL DCSP  DCSP def registerSelfAdapter(required=None, provided=None, name=empty, info=empty, event=True): DCNL DCSP  DCSP  DCSP return _registry.registerAdapter((lambda x: x), required=required, provided=provided, name=name, info=info, event=event) DCNL DCSP  DCSP _registry.registerSelfAdapter = registerSelfAdapter DCNL DCSP if (not hasattr(_registry, '_lock')): DCNL DCSP  DCSP _registry._lock = threading.Lock() DCNL DCSP if (not hasattr(_registry, '_clear_view_lookup_cache')): DCNL DCSP  DCSP def _clear_view_lookup_cache(): DCNL DCSP  DCSP  DCSP _registry._view_lookup_cache = {} DCNL DCSP  DCSP _registry._clear_view_lookup_cache = _clear_view_lookup_cache
def action(self, discriminator, callable=None, args=(), kw=None, order=0, introspectables=(), **extra): DCNL DCSP assert hash(discriminator) DCNL DCSP if (kw is None): DCNL DCSP  DCSP kw = {} DCNL DCSP autocommit = self.autocommit DCNL DCSP action_info = self.action_info DCNL DCSP if (not self.introspection): DCNL DCSP  DCSP introspectables = () DCNL DCSP if autocommit: DCNL DCSP  DCSP self.begin() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP undefer(discriminator) DCNL DCSP  DCSP  DCSP if (callable is not None): DCNL DCSP  DCSP  DCSP  DCSP callable(*args, **kw) DCNL DCSP  DCSP  DCSP for introspectable in introspectables: DCNL DCSP  DCSP  DCSP  DCSP introspectable.register(self.introspector, action_info) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP self.end() DCNL DCSP else: DCNL DCSP  DCSP action = extra DCNL DCSP  DCSP action.update(dict(discriminator=discriminator, callable=callable, args=args, kw=kw, order=order, info=action_info, includepath=self.includepath, introspectables=introspectables)) DCNL DCSP  DCSP self.action_state.action(**action)
def commit(self): DCNL DCSP self.begin() DCNL DCSP try: DCNL DCSP  DCSP self.action_state.execute_actions(introspector=self.introspector) DCNL DCSP finally: DCNL DCSP  DCSP self.end() DCNL DCSP self.action_state = ActionState()
def include(self, callable, route_prefix=None): DCNL DCSP action_state = self.action_state DCNL DCSP if (route_prefix is None): DCNL DCSP  DCSP route_prefix = '' DCNL DCSP old_route_prefix = self.route_prefix DCNL DCSP if (old_route_prefix is None): DCNL DCSP  DCSP old_route_prefix = '' DCNL DCSP route_prefix = ('%s/%s' % (old_route_prefix.rstrip('/'), route_prefix.lstrip('/'))) DCNL DCSP route_prefix = route_prefix.strip('/') DCNL DCSP if (not route_prefix): DCNL DCSP  DCSP route_prefix = None DCNL DCSP c = self.maybe_dotted(callable) DCNL DCSP module = self.inspect.getmodule(c) DCNL DCSP if (module is c): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP c = getattr(module, 'includeme') DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise ConfigurationError(("module DCSP %r DCSP has DCSP no DCSP attribute DCSP 'includeme'" % module.__name__)) DCNL DCSP spec = ((module.__name__ + ':') + c.__name__) DCNL DCSP sourcefile = self.inspect.getsourcefile(c) DCNL DCSP if (sourcefile is None): DCNL DCSP  DCSP raise ConfigurationError(('No DCSP source DCSP file DCSP for DCSP module DCSP %r DCSP (.py DCSP file DCSP must DCSP exist, DCSP refusing DCSP to DCSP use DCSP orphan DCSP .pyc DCSP or DCSP .pyo DCSP file).' % module.__name__)) DCNL DCSP if action_state.processSpec(spec): DCNL DCSP  DCSP configurator = self.__class__(registry=self.registry, package=package_of(module), root_package=self.root_package, autocommit=self.autocommit, route_prefix=route_prefix) DCNL DCSP  DCSP configurator.basepath = os.path.dirname(sourcefile) DCNL DCSP  DCSP configurator.includepath = (self.includepath + (spec,)) DCNL DCSP  DCSP self.begin() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP c(configurator) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP self.end()
def add_directive(self, name, directive, action_wrap=True): DCNL DCSP c = self.maybe_dotted(directive) DCNL DCSP if (not hasattr(self.registry, '_directives')): DCNL DCSP  DCSP self.registry._directives = {} DCNL DCSP self.registry._directives[name] = (c, action_wrap)
def with_package(self, package): DCNL DCSP configurator = self.__class__(registry=self.registry, package=package, root_package=self.root_package, autocommit=self.autocommit, route_prefix=self.route_prefix, introspection=self.introspection) DCNL DCSP configurator.basepath = self.basepath DCNL DCSP configurator.includepath = self.includepath DCNL DCSP configurator.info = self.info DCNL DCSP return configurator
def maybe_dotted(self, dotted): DCNL DCSP return self.name_resolver.maybe_resolve(dotted)
def absolute_asset_spec(self, relative_spec): DCNL DCSP if (not isinstance(relative_spec, string_types)): DCNL DCSP  DCSP return relative_spec DCNL DCSP return self._make_spec(relative_spec)
def begin(self, request=_marker): DCNL DCSP if (request is _marker): DCNL DCSP  DCSP current = self.manager.get() DCNL DCSP  DCSP if (current['registry'] == self.registry): DCNL DCSP  DCSP  DCSP request = current['request'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP request = None DCNL DCSP self.manager.push({'registry': self.registry, 'request': request})
def end(self): DCNL DCSP return self.manager.pop()
def scan(self, package=None, categories=None, onerror=None, ignore=None, **kw): DCNL DCSP package = self.maybe_dotted(package) DCNL DCSP if (package is None): DCNL DCSP  DCSP package = caller_package() DCNL DCSP ctorkw = {'config': self} DCNL DCSP ctorkw.update(kw) DCNL DCSP scanner = self.venusian.Scanner(**ctorkw) DCNL DCSP scanner.scan(package, categories=categories, onerror=onerror, ignore=ignore)
def make_wsgi_app(self): DCNL DCSP self.commit() DCNL DCSP app = Router(self.registry) DCNL DCSP global_registries.add(self.registry) DCNL DCSP self.begin() DCNL DCSP try: DCNL DCSP  DCSP self.registry.notify(ApplicationCreated(app)) DCNL DCSP finally: DCNL DCSP  DCSP self.end() DCNL DCSP return app
def processSpec(self, spec): DCNL DCSP if (spec in self._seen_files): DCNL DCSP  DCSP return False DCNL DCSP self._seen_files.add(spec) DCNL DCSP return True
def action(self, discriminator, callable=None, args=(), kw=None, order=0, includepath=(), info=None, introspectables=(), **extra): DCNL DCSP if (kw is None): DCNL DCSP  DCSP kw = {} DCNL DCSP action = extra DCNL DCSP action.update(dict(discriminator=discriminator, callable=callable, args=args, kw=kw, includepath=includepath, info=info, order=order, introspectables=introspectables)) DCNL DCSP self.actions.append(action)
def execute_actions(self, clear=True, introspector=None): DCNL DCSP try: DCNL DCSP  DCSP all_actions = [] DCNL DCSP  DCSP executed_actions = [] DCNL DCSP  DCSP action_iter = iter([]) DCNL DCSP  DCSP conflict_state = ConflictResolverState() DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP if self.actions: DCNL DCSP  DCSP  DCSP  DCSP all_actions.extend(self.actions) DCNL DCSP  DCSP  DCSP  DCSP action_iter = resolveConflicts(self.actions, state=conflict_state) DCNL DCSP  DCSP  DCSP  DCSP self.actions = [] DCNL DCSP  DCSP  DCSP action = next(action_iter, None) DCNL DCSP  DCSP  DCSP if (action is None): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP callable = action['callable'] DCNL DCSP  DCSP  DCSP args = action['args'] DCNL DCSP  DCSP  DCSP kw = action['kw'] DCNL DCSP  DCSP  DCSP info = action['info'] DCNL DCSP  DCSP  DCSP introspectables = action.get('introspectables', ()) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (callable is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP callable(*args, **kw) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP (t, v, tb) = sys.exc_info() DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP reraise(ConfigurationExecutionError, ConfigurationExecutionError(t, v, info), tb) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP del t, v, tb DCNL DCSP  DCSP  DCSP if (introspector is not None): DCNL DCSP  DCSP  DCSP  DCSP for introspectable in introspectables: DCNL DCSP  DCSP  DCSP  DCSP  DCSP introspectable.register(introspector, info) DCNL DCSP  DCSP  DCSP executed_actions.append(action) DCNL DCSP  DCSP self.actions = all_actions DCNL DCSP  DCSP return executed_actions DCNL DCSP finally: DCNL DCSP  DCSP if clear: DCNL DCSP  DCSP  DCSP self.actions = []
@action_method DCNL def set_locale_negotiator(self, negotiator): DCNL DCSP def register(): DCNL DCSP  DCSP self._set_locale_negotiator(negotiator) DCNL DCSP intr = self.introspectable('locale DCSP negotiator', None, self.object_description(negotiator), 'locale DCSP negotiator') DCNL DCSP intr['negotiator'] = negotiator DCNL DCSP self.action(ILocaleNegotiator, register, introspectables=(intr,))
@action_method DCNL def add_translation_dirs(self, *specs, **kw): DCNL DCSP introspectables = [] DCNL DCSP override = kw.pop('override', False) DCNL DCSP if kw: DCNL DCSP  DCSP raise TypeError('invalid DCSP keyword DCSP arguments: DCSP %s', sorted(kw.keys())) DCNL DCSP def register(): DCNL DCSP  DCSP directories = [] DCNL DCSP  DCSP resolver = AssetResolver(self.package_name) DCNL DCSP  DCSP for spec in specs: DCNL DCSP  DCSP  DCSP if (not spec.endswith('/')): DCNL DCSP  DCSP  DCSP  DCSP spec += '/' DCNL DCSP  DCSP  DCSP asset = resolver.resolve(spec) DCNL DCSP  DCSP  DCSP directory = asset.abspath() DCNL DCSP  DCSP  DCSP if (not asset.isdir()): DCNL DCSP  DCSP  DCSP  DCSP raise ConfigurationError(('"%s" DCSP is DCSP not DCSP a DCSP directory' % directory)) DCNL DCSP  DCSP  DCSP intr = self.introspectable('translation DCSP directories', directory, spec, 'translation DCSP directory') DCNL DCSP  DCSP  DCSP intr['directory'] = directory DCNL DCSP  DCSP  DCSP intr['spec'] = spec DCNL DCSP  DCSP  DCSP introspectables.append(intr) DCNL DCSP  DCSP  DCSP directories.append(directory) DCNL DCSP  DCSP tdirs = self.registry.queryUtility(ITranslationDirectories) DCNL DCSP  DCSP if (tdirs is None): DCNL DCSP  DCSP  DCSP tdirs = [] DCNL DCSP  DCSP  DCSP self.registry.registerUtility(tdirs, ITranslationDirectories) DCNL DCSP  DCSP if override: DCNL DCSP  DCSP  DCSP tdirs.extend(directories) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for directory in reversed(directories): DCNL DCSP  DCSP  DCSP  DCSP tdirs.insert(0, directory) DCNL DCSP self.action(None, register, introspectables=introspectables)
def add_settings(self, settings=None, **kw): DCNL DCSP if (settings is None): DCNL DCSP  DCSP settings = {} DCNL DCSP utility = self.registry.settings DCNL DCSP if (utility is None): DCNL DCSP  DCSP utility = self._set_settings(settings) DCNL DCSP utility.update(settings) DCNL DCSP utility.update(kw)
def get_settings(self): DCNL DCSP return self.registry.settings
def get_resource_filename(self, manager, resource_name): DCNL DCSP overrides = self._get_overrides() DCNL DCSP if (overrides is not None): DCNL DCSP  DCSP filename = overrides.get_filename(resource_name) DCNL DCSP  DCSP if (filename is not None): DCNL DCSP  DCSP  DCSP return filename DCNL DCSP return pkg_resources.DefaultProvider.get_resource_filename(self, manager, resource_name)
def get_resource_stream(self, manager, resource_name): DCNL DCSP overrides = self._get_overrides() DCNL DCSP if (overrides is not None): DCNL DCSP  DCSP stream = overrides.get_stream(resource_name) DCNL DCSP  DCSP if (stream is not None): DCNL DCSP  DCSP  DCSP return stream DCNL DCSP return pkg_resources.DefaultProvider.get_resource_stream(self, manager, resource_name)
def get_resource_string(self, manager, resource_name): DCNL DCSP overrides = self._get_overrides() DCNL DCSP if (overrides is not None): DCNL DCSP  DCSP string = overrides.get_string(resource_name) DCNL DCSP  DCSP if (string is not None): DCNL DCSP  DCSP  DCSP return string DCNL DCSP return pkg_resources.DefaultProvider.get_resource_string(self, manager, resource_name)
def get_data(self, path): DCNL DCSP return self.real_loader.get_data(path)
def is_package(self, fullname): DCNL DCSP return self.real_loader.is_package(fullname)
def get_code(self, fullname): DCNL DCSP return self.real_loader.get_code(fullname)
def get_source(self, fullname): DCNL DCSP return self.real_loader.get_source(fullname)
@action_method DCNL def override_asset(self, to_override, override_with, _override=None): DCNL DCSP if (to_override == override_with): DCNL DCSP  DCSP raise ConfigurationError('You DCSP cannot DCSP override DCSP an DCSP asset DCSP with DCSP itself') DCNL DCSP package = to_override DCNL DCSP path = '' DCNL DCSP if (':' in to_override): DCNL DCSP  DCSP (package, path) = to_override.split(':', 1) DCNL DCSP overridden_isdir = ((path == '') or path.endswith('/')) DCNL DCSP if os.path.isabs(override_with): DCNL DCSP  DCSP override_source = FSAssetSource(override_with) DCNL DCSP  DCSP if (not os.path.exists(override_with)): DCNL DCSP  DCSP  DCSP raise ConfigurationError('Cannot DCSP override DCSP asset DCSP with DCSP an DCSP absolute DCSP path DCSP that DCSP does DCSP not DCSP exist') DCNL DCSP  DCSP override_isdir = os.path.isdir(override_with) DCNL DCSP  DCSP override_package = None DCNL DCSP  DCSP override_prefix = override_with DCNL DCSP else: DCNL DCSP  DCSP override_package = override_with DCNL DCSP  DCSP override_prefix = '' DCNL DCSP  DCSP if (':' in override_with): DCNL DCSP  DCSP  DCSP (override_package, override_prefix) = override_with.split(':', 1) DCNL DCSP  DCSP __import__(override_package) DCNL DCSP  DCSP to_package = sys.modules[override_package] DCNL DCSP  DCSP override_source = PackageAssetSource(to_package, override_prefix) DCNL DCSP  DCSP override_isdir = ((override_prefix == '') or override_with.endswith('/')) DCNL DCSP if (overridden_isdir and (not override_isdir)): DCNL DCSP  DCSP raise ConfigurationError('A DCSP directory DCSP cannot DCSP be DCSP overridden DCSP with DCSP a DCSP file DCSP (put DCSP a DCSP slash DCSP at DCSP the DCSP end DCSP of DCSP override_with DCSP if DCSP necessary)') DCNL DCSP if ((not overridden_isdir) and override_isdir): DCNL DCSP  DCSP raise ConfigurationError('A DCSP file DCSP cannot DCSP be DCSP overridden DCSP with DCSP a DCSP directory DCSP (put DCSP a DCSP slash DCSP at DCSP the DCSP end DCSP of DCSP to_override DCSP if DCSP necessary)') DCNL DCSP override = (_override or self._override) DCNL DCSP def register(): DCNL DCSP  DCSP __import__(package) DCNL DCSP  DCSP from_package = sys.modules[package] DCNL DCSP  DCSP override(from_package, path, override_source) DCNL DCSP intr = self.introspectable('asset DCSP overrides', (package, override_package, path, override_prefix), ('%s DCSP -> DCSP %s' % (to_override, override_with)), 'asset DCSP override') DCNL DCSP intr['to_override'] = to_override DCNL DCSP intr['override_with'] = override_with DCNL DCSP self.action(None, register, introspectables=(intr,), order=PHASE1_CONFIG)
def testing_securitypolicy(self, userid=None, groupids=(), permissive=True, remember_result=None, forget_result=None): DCNL DCSP from pyramid.testing import DummySecurityPolicy DCNL DCSP policy = DummySecurityPolicy(userid, groupids, permissive, remember_result, forget_result) DCNL DCSP self.registry.registerUtility(policy, IAuthorizationPolicy) DCNL DCSP self.registry.registerUtility(policy, IAuthenticationPolicy) DCNL DCSP return policy
def testing_resources(self, resources): DCNL DCSP class DummyTraverserFactory: DCNL DCSP  DCSP def __init__(self, context): DCNL DCSP  DCSP  DCSP self.context = context DCNL DCSP  DCSP def __call__(self, request): DCNL DCSP  DCSP  DCSP path = decode_path_info(request.environ['PATH_INFO']) DCNL DCSP  DCSP  DCSP ob = resources[path] DCNL DCSP  DCSP  DCSP traversed = split_path_info(path) DCNL DCSP  DCSP  DCSP return {'context': ob, 'view_name': '', 'subpath': (), 'traversed': traversed, 'virtual_root': ob, 'virtual_root_path': (), 'root': ob} DCNL DCSP self.registry.registerAdapter(DummyTraverserFactory, (Interface,), ITraverser) DCNL DCSP return resources
@action_method DCNL def testing_add_subscriber(self, event_iface=None): DCNL DCSP event_iface = self.maybe_dotted(event_iface) DCNL DCSP L = [] DCNL DCSP def subscriber(*event): DCNL DCSP  DCSP L.extend(event) DCNL DCSP self.add_subscriber(subscriber, event_iface) DCNL DCSP return L
def testing_add_renderer(self, path, renderer=None): DCNL DCSP from pyramid.testing import DummyRendererFactory DCNL DCSP helper = RendererHelper(name=path, registry=self.registry) DCNL DCSP factory = self.registry.queryUtility(IRendererFactory, name=helper.type) DCNL DCSP if (not isinstance(factory, DummyRendererFactory)): DCNL DCSP  DCSP factory = DummyRendererFactory(helper.type, factory) DCNL DCSP  DCSP self.registry.registerUtility(factory, IRendererFactory, name=helper.type) DCNL DCSP from pyramid.testing import DummyTemplateRenderer DCNL DCSP if (renderer is None): DCNL DCSP  DCSP renderer = DummyTemplateRenderer() DCNL DCSP factory.add(path, renderer) DCNL DCSP return renderer
@action_method DCNL def add_renderer(self, name, factory): DCNL DCSP factory = self.maybe_dotted(factory) DCNL DCSP if (not name): DCNL DCSP  DCSP name = '' DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(factory, IRendererFactory, name=name) DCNL DCSP intr = self.introspectable('renderer DCSP factories', name, self.object_description(factory), 'renderer DCSP factory') DCNL DCSP intr['factory'] = factory DCNL DCSP intr['name'] = name DCNL DCSP self.action((IRendererFactory, name), register, order=PHASE1_CONFIG, introspectables=(intr,))
def hook_zca(self): DCNL DCSP from zope.component import getSiteManager DCNL DCSP getSiteManager.sethook(get_current_registry)
def unhook_zca(self): DCNL DCSP from zope.component import getSiteManager DCNL DCSP getSiteManager.reset()
@action_method DCNL def add_route(self, name, pattern=None, permission=None, factory=None, for_=None, header=None, xhr=None, accept=None, path_info=None, request_method=None, request_param=None, traverse=None, custom_predicates=(), use_global_views=False, path=None, pregenerator=None, static=False, **predicates): DCNL DCSP if custom_predicates: DCNL DCSP  DCSP warnings.warn('The DCSP "custom_predicates" DCSP argument DCSP to DCSP Configurator.add_route DCSP is DCSP deprecated DCSP as DCSP of DCSP Pyramid DCSP 1.5. DCSP  DCSP Use DCSP "config.add_route_predicate" DCSP and DCSP use DCSP the DCSP registered DCSP route DCSP predicate DCSP as DCSP a DCSP predicate DCSP argument DCSP to DCSP add_route DCSP instead. DCSP See DCSP "Adding DCSP A DCSP Third DCSP Party DCSP View, DCSP Route, DCSP or DCSP Subscriber DCSP Predicate" DCSP in DCSP the DCSP "Hooks" DCSP chapter DCSP of DCSP the DCSP documentation DCSP for DCSP more DCSP information.', DeprecationWarning, stacklevel=3) DCNL DCSP if (request_method is not None): DCNL DCSP  DCSP request_method = as_sorted_tuple(request_method) DCNL DCSP factory = self.maybe_dotted(factory) DCNL DCSP if (pattern is None): DCNL DCSP  DCSP pattern = path DCNL DCSP if (pattern is None): DCNL DCSP  DCSP raise ConfigurationError('"pattern" DCSP argument DCSP may DCSP not DCSP be DCSP None') DCNL DCSP parsed = urlparse.urlparse(pattern) DCNL DCSP external_url = pattern DCNL DCSP if parsed.hostname: DCNL DCSP  DCSP pattern = parsed.path DCNL DCSP  DCSP original_pregenerator = pregenerator DCNL DCSP  DCSP def external_url_pregenerator(request, elements, kw): DCNL DCSP  DCSP  DCSP if ('_app_url' in kw): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('You DCSP cannot DCSP generate DCSP a DCSP path DCSP to DCSP an DCSP external DCSP route DCSP pattern DCSP via DCSP request.route_path DCSP nor DCSP pass DCSP an DCSP _app_url DCSP to DCSP request.route_url DCSP when DCSP generating DCSP a DCSP URL DCSP for DCSP an DCSP external DCSP route DCSP pattern DCSP (pattern DCSP was DCSP "%s") DCSP ' % (pattern,))) DCNL DCSP  DCSP  DCSP if ('_scheme' in kw): DCNL DCSP  DCSP  DCSP  DCSP scheme = kw['_scheme'] DCNL DCSP  DCSP  DCSP elif parsed.scheme: DCNL DCSP  DCSP  DCSP  DCSP scheme = parsed.scheme DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP scheme = request.scheme DCNL DCSP  DCSP  DCSP kw['_app_url'] = '{0}://{1}'.format(scheme, parsed.netloc) DCNL DCSP  DCSP  DCSP if original_pregenerator: DCNL DCSP  DCSP  DCSP  DCSP (elements, kw) = original_pregenerator(request, elements, kw) DCNL DCSP  DCSP  DCSP return (elements, kw) DCNL DCSP  DCSP pregenerator = external_url_pregenerator DCNL DCSP  DCSP static = True DCNL DCSP elif self.route_prefix: DCNL DCSP  DCSP pattern = ((self.route_prefix.rstrip('/') + '/') + pattern.lstrip('/')) DCNL DCSP mapper = self.get_routes_mapper() DCNL DCSP introspectables = [] DCNL DCSP intr = self.introspectable('routes', name, ('%s DCSP (pattern: DCSP %r)' % (name, pattern)), 'route') DCNL DCSP intr['name'] = name DCNL DCSP intr['pattern'] = pattern DCNL DCSP intr['factory'] = factory DCNL DCSP intr['xhr'] = xhr DCNL DCSP intr['request_methods'] = request_method DCNL DCSP intr['path_info'] = path_info DCNL DCSP intr['request_param'] = request_param DCNL DCSP intr['header'] = header DCNL DCSP intr['accept'] = accept DCNL DCSP intr['traverse'] = traverse DCNL DCSP intr['custom_predicates'] = custom_predicates DCNL DCSP intr['pregenerator'] = pregenerator DCNL DCSP intr['static'] = static DCNL DCSP intr['use_global_views'] = use_global_views DCNL DCSP if (static is True): DCNL DCSP  DCSP intr['external_url'] = external_url DCNL DCSP introspectables.append(intr) DCNL DCSP if factory: DCNL DCSP  DCSP factory_intr = self.introspectable('root DCSP factories', name, self.object_description(factory), 'root DCSP factory') DCNL DCSP  DCSP factory_intr['factory'] = factory DCNL DCSP  DCSP factory_intr['route_name'] = name DCNL DCSP  DCSP factory_intr.relate('routes', name) DCNL DCSP  DCSP introspectables.append(factory_intr) DCNL DCSP def register_route_request_iface(): DCNL DCSP  DCSP request_iface = self.registry.queryUtility(IRouteRequest, name=name) DCNL DCSP  DCSP if (request_iface is None): DCNL DCSP  DCSP  DCSP if use_global_views: DCNL DCSP  DCSP  DCSP  DCSP bases = (IRequest,) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP bases = () DCNL DCSP  DCSP  DCSP request_iface = route_request_iface(name, bases) DCNL DCSP  DCSP  DCSP self.registry.registerUtility(request_iface, IRouteRequest, name=name) DCNL DCSP def register_connect(): DCNL DCSP  DCSP pvals = predicates.copy() DCNL DCSP  DCSP pvals.update(dict(xhr=xhr, request_method=request_method, path_info=path_info, request_param=request_param, header=header, accept=accept, traverse=traverse, custom=predvalseq(custom_predicates))) DCNL DCSP  DCSP predlist = self.get_predlist('route') DCNL DCSP  DCSP (_, preds, _) = predlist.make(self, **pvals) DCNL DCSP  DCSP route = mapper.connect(name, pattern, factory, predicates=preds, pregenerator=pregenerator, static=static) DCNL DCSP  DCSP intr['object'] = route DCNL DCSP  DCSP return route DCNL DCSP self.action(('route-connect', name), register_connect) DCNL DCSP self.action(('route', name), register_route_request_iface, order=PHASE2_CONFIG, introspectables=introspectables)
@action_method DCNL def add_route_predicate(self, name, factory, weighs_more_than=None, weighs_less_than=None): DCNL DCSP self._add_predicate('route', name, factory, weighs_more_than=weighs_more_than, weighs_less_than=weighs_less_than)
def get_routes_mapper(self): DCNL DCSP mapper = self.registry.queryUtility(IRoutesMapper) DCNL DCSP if (mapper is None): DCNL DCSP  DCSP mapper = RoutesMapper() DCNL DCSP  DCSP self.registry.registerUtility(mapper, IRoutesMapper) DCNL DCSP return mapper
def add_tween(self, tween_factory, under=None, over=None): DCNL DCSP return self._add_tween(tween_factory, under=under, over=over, explicit=False)
@viewdefaults DCNL @action_method DCNL def add_view(self, view=None, name='', for_=None, permission=None, request_type=None, route_name=None, request_method=None, request_param=None, containment=None, attr=None, renderer=None, wrapper=None, xhr=None, accept=None, header=None, path_info=None, custom_predicates=(), context=None, decorator=None, mapper=None, http_cache=None, match_param=None, check_csrf=None, require_csrf=None, exception_only=False, **view_options): DCNL DCSP if custom_predicates: DCNL DCSP  DCSP warnings.warn('The DCSP "custom_predicates" DCSP argument DCSP to DCSP Configurator.add_view DCSP is DCSP deprecated DCSP as DCSP of DCSP Pyramid DCSP 1.5. DCSP  DCSP Use DCSP "config.add_view_predicate" DCSP and DCSP use DCSP the DCSP registered DCSP view DCSP predicate DCSP as DCSP a DCSP predicate DCSP argument DCSP to DCSP add_view DCSP instead. DCSP See DCSP "Adding DCSP A DCSP Third DCSP Party DCSP View, DCSP Route, DCSP or DCSP Subscriber DCSP Predicate" DCSP in DCSP the DCSP "Hooks" DCSP chapter DCSP of DCSP the DCSP documentation DCSP for DCSP more DCSP information.', DeprecationWarning, stacklevel=4) DCNL DCSP if (check_csrf is not None): DCNL DCSP  DCSP warnings.warn('The DCSP "check_csrf" DCSP argument DCSP to DCSP Configurator.add_view DCSP is DCSP deprecated DCSP as DCSP of DCSP Pyramid DCSP 1.7. DCSP Use DCSP the DCSP "require_csrf" DCSP option DCSP instead DCSP or DCSP see DCSP "Checking DCSP CSRF DCSP Tokens DCSP Automatically" DCSP in DCSP the DCSP "Sessions" DCSP chapter DCSP of DCSP the DCSP documentation DCSP for DCSP more DCSP information.', DeprecationWarning, stacklevel=4) DCNL DCSP view = self.maybe_dotted(view) DCNL DCSP context = self.maybe_dotted(context) DCNL DCSP for_ = self.maybe_dotted(for_) DCNL DCSP containment = self.maybe_dotted(containment) DCNL DCSP mapper = self.maybe_dotted(mapper) DCNL DCSP def combine(*decorators): DCNL DCSP  DCSP def decorated(view_callable): DCNL DCSP  DCSP  DCSP for decorator in reversed(decorators): DCNL DCSP  DCSP  DCSP  DCSP view_callable = decorator(view_callable) DCNL DCSP  DCSP  DCSP return view_callable DCNL DCSP  DCSP return decorated DCNL DCSP if is_nonstr_iter(decorator): DCNL DCSP  DCSP decorator = combine(*map(self.maybe_dotted, decorator)) DCNL DCSP else: DCNL DCSP  DCSP decorator = self.maybe_dotted(decorator) DCNL DCSP if (not view): DCNL DCSP  DCSP if renderer: DCNL DCSP  DCSP  DCSP def view(context, request): DCNL DCSP  DCSP  DCSP  DCSP return {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ConfigurationError('"view" DCSP was DCSP not DCSP specified DCSP and DCSP no DCSP "renderer" DCSP specified') DCNL DCSP if (request_type is not None): DCNL DCSP  DCSP request_type = self.maybe_dotted(request_type) DCNL DCSP  DCSP if (not IInterface.providedBy(request_type)): DCNL DCSP  DCSP  DCSP raise ConfigurationError(('request_type DCSP must DCSP be DCSP an DCSP interface, DCSP not DCSP %s' % request_type)) DCNL DCSP if (context is None): DCNL DCSP  DCSP context = for_ DCNL DCSP isexc = isexception(context) DCNL DCSP if (exception_only and (not isexc)): DCNL DCSP  DCSP raise ConfigurationError('view DCSP "context" DCSP must DCSP be DCSP an DCSP exception DCSP type DCSP when DCSP "exception_only" DCSP is DCSP True') DCNL DCSP r_context = context DCNL DCSP if (r_context is None): DCNL DCSP  DCSP r_context = Interface DCNL DCSP if (not IInterface.providedBy(r_context)): DCNL DCSP  DCSP r_context = implementedBy(r_context) DCNL DCSP if isinstance(renderer, string_types): DCNL DCSP  DCSP renderer = renderers.RendererHelper(name=renderer, package=self.package, registry=self.registry) DCNL DCSP if (accept is not None): DCNL DCSP  DCSP accept = accept.lower() DCNL DCSP introspectables = [] DCNL DCSP ovals = view_options.copy() DCNL DCSP ovals.update(dict(xhr=xhr, request_method=request_method, path_info=path_info, request_param=request_param, header=header, accept=accept, containment=containment, request_type=request_type, match_param=match_param, check_csrf=check_csrf, custom=predvalseq(custom_predicates))) DCNL DCSP def discrim_func(): DCNL DCSP  DCSP predlist = self.get_predlist('view') DCNL DCSP  DCSP valid_predicates = predlist.names() DCNL DCSP  DCSP pvals = {} DCNL DCSP  DCSP dvals = {} DCNL DCSP  DCSP for (k, v) in ovals.items(): DCNL DCSP  DCSP  DCSP if (k in valid_predicates): DCNL DCSP  DCSP  DCSP  DCSP pvals[k] = v DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP dvals[k] = v DCNL DCSP  DCSP self._check_view_options(**dvals) DCNL DCSP  DCSP (order, preds, phash) = predlist.make(self, **pvals) DCNL DCSP  DCSP view_intr.update({'phash': phash, 'order': order, 'predicates': preds}) DCNL DCSP  DCSP return ('view', context, name, route_name, phash) DCNL DCSP discriminator = Deferred(discrim_func) DCNL DCSP if (inspect.isclass(view) and attr): DCNL DCSP  DCSP view_desc = ('method DCSP %r DCSP of DCSP %s' % (attr, self.object_description(view))) DCNL DCSP else: DCNL DCSP  DCSP view_desc = self.object_description(view) DCNL DCSP tmpl_intr = None DCNL DCSP view_intr = self.introspectable('views', discriminator, view_desc, 'view') DCNL DCSP view_intr.update(dict(name=name, context=context, exception_only=exception_only, containment=containment, request_param=request_param, request_methods=request_method, route_name=route_name, attr=attr, xhr=xhr, accept=accept, header=header, path_info=path_info, match_param=match_param, check_csrf=check_csrf, http_cache=http_cache, require_csrf=require_csrf, callable=view, mapper=mapper, decorator=decorator)) DCNL DCSP view_intr.update(view_options) DCNL DCSP introspectables.append(view_intr) DCNL DCSP def register(permission=permission, renderer=renderer): DCNL DCSP  DCSP request_iface = IRequest DCNL DCSP  DCSP if (route_name is not None): DCNL DCSP  DCSP  DCSP request_iface = self.registry.queryUtility(IRouteRequest, name=route_name) DCNL DCSP  DCSP  DCSP if (request_iface is None): DCNL DCSP  DCSP  DCSP  DCSP raise ConfigurationError(('No DCSP route DCSP named DCSP %s DCSP found DCSP for DCSP view DCSP registration' % route_name)) DCNL DCSP  DCSP if (renderer is None): DCNL DCSP  DCSP  DCSP if (self.registry.queryUtility(IRendererFactory) is not None): DCNL DCSP  DCSP  DCSP  DCSP renderer = renderers.RendererHelper(name=None, package=self.package, registry=self.registry) DCNL DCSP  DCSP renderer_type = getattr(renderer, 'type', None) DCNL DCSP  DCSP intrspc = self.introspector DCNL DCSP  DCSP if ((renderer_type is not None) and (tmpl_intr is not None) and (intrspc is not None) and (intrspc.get('renderer DCSP factories', renderer_type) is not None)): DCNL DCSP  DCSP  DCSP tmpl_intr.relate('renderer DCSP factories', renderer.type) DCNL DCSP  DCSP if (not exception_only): DCNL DCSP  DCSP  DCSP derived_view = derive_view(False, renderer) DCNL DCSP  DCSP  DCSP register_view(IViewClassifier, request_iface, derived_view) DCNL DCSP  DCSP if isexc: DCNL DCSP  DCSP  DCSP derived_exc_view = derive_view(True, renderer) DCNL DCSP  DCSP  DCSP register_view(IExceptionViewClassifier, request_iface, derived_exc_view) DCNL DCSP  DCSP  DCSP if exception_only: DCNL DCSP  DCSP  DCSP  DCSP derived_view = derived_exc_view DCNL DCSP  DCSP if ((not exception_only) and isexc): DCNL DCSP  DCSP  DCSP derived_view = runtime_exc_view(derived_view, derived_exc_view) DCNL DCSP  DCSP derived_view.__discriminator__ = (lambda *arg: discriminator) DCNL DCSP  DCSP view_intr['derived_callable'] = derived_view DCNL DCSP  DCSP self.registry._clear_view_lookup_cache() DCNL DCSP def derive_view(isexc_only, renderer): DCNL DCSP  DCSP preds = view_intr['predicates'] DCNL DCSP  DCSP order = view_intr['order'] DCNL DCSP  DCSP phash = view_intr['phash'] DCNL DCSP  DCSP derived_view = self._derive_view(view, route_name=route_name, permission=permission, predicates=preds, attr=attr, context=context, exception_only=isexc_only, renderer=renderer, wrapper_viewname=wrapper, viewname=name, accept=accept, order=order, phash=phash, decorator=decorator, mapper=mapper, http_cache=http_cache, require_csrf=require_csrf, extra_options=ovals) DCNL DCSP  DCSP return derived_view DCNL DCSP def register_view(classifier, request_iface, derived_view): DCNL DCSP  DCSP old_view = None DCNL DCSP  DCSP (order, phash) = (view_intr['order'], view_intr['phash']) DCNL DCSP  DCSP registered = self.registry.adapters.registered DCNL DCSP  DCSP for view_type in (IView, ISecuredView, IMultiView): DCNL DCSP  DCSP  DCSP old_view = registered((classifier, request_iface, r_context), view_type, name) DCNL DCSP  DCSP  DCSP if (old_view is not None): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP def regclosure(): DCNL DCSP  DCSP  DCSP if hasattr(derived_view, '__call_permissive__'): DCNL DCSP  DCSP  DCSP  DCSP view_iface = ISecuredView DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP view_iface = IView DCNL DCSP  DCSP  DCSP self.registry.registerAdapter(derived_view, (classifier, request_iface, context), view_iface, name) DCNL DCSP  DCSP is_multiview = IMultiView.providedBy(old_view) DCNL DCSP  DCSP old_phash = getattr(old_view, '__phash__', DEFAULT_PHASH) DCNL DCSP  DCSP if (old_view is None): DCNL DCSP  DCSP  DCSP regclosure() DCNL DCSP  DCSP elif ((not is_multiview) and (old_phash == phash)): DCNL DCSP  DCSP  DCSP regclosure() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if is_multiview: DCNL DCSP  DCSP  DCSP  DCSP multiview = old_view DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP multiview = MultiView(name) DCNL DCSP  DCSP  DCSP  DCSP old_accept = getattr(old_view, '__accept__', None) DCNL DCSP  DCSP  DCSP  DCSP old_order = getattr(old_view, '__order__', MAX_ORDER) DCNL DCSP  DCSP  DCSP  DCSP multiview.add(old_view, old_order, old_accept, old_phash) DCNL DCSP  DCSP  DCSP multiview.add(derived_view, order, accept, phash) DCNL DCSP  DCSP  DCSP for view_type in (IView, ISecuredView): DCNL DCSP  DCSP  DCSP  DCSP self.registry.adapters.unregister((classifier, request_iface, r_context), view_type, name=name) DCNL DCSP  DCSP  DCSP self.registry.registerAdapter(multiview, (classifier, request_iface, context), IMultiView, name=name) DCNL DCSP if mapper: DCNL DCSP  DCSP mapper_intr = self.introspectable('view DCSP mappers', discriminator, ('view DCSP mapper DCSP for DCSP %s' % view_desc), 'view DCSP mapper') DCNL DCSP  DCSP mapper_intr['mapper'] = mapper DCNL DCSP  DCSP mapper_intr.relate('views', discriminator) DCNL DCSP  DCSP introspectables.append(mapper_intr) DCNL DCSP if route_name: DCNL DCSP  DCSP view_intr.relate('routes', route_name) DCNL DCSP if ((renderer is not None) and renderer.name and ('.' in renderer.name)): DCNL DCSP  DCSP tmpl_intr = self.introspectable('templates', discriminator, renderer.name, 'template') DCNL DCSP  DCSP tmpl_intr.relate('views', discriminator) DCNL DCSP  DCSP tmpl_intr['name'] = renderer.name DCNL DCSP  DCSP tmpl_intr['type'] = renderer.type DCNL DCSP  DCSP tmpl_intr['renderer'] = renderer DCNL DCSP  DCSP introspectables.append(tmpl_intr) DCNL DCSP if (permission is not None): DCNL DCSP  DCSP perm_intr = self.introspectable('permissions', permission, permission, 'permission') DCNL DCSP  DCSP perm_intr['value'] = permission DCNL DCSP  DCSP perm_intr.relate('views', discriminator) DCNL DCSP  DCSP introspectables.append(perm_intr) DCNL DCSP self.action(discriminator, register, introspectables=introspectables)
@action_method DCNL def add_view_predicate(self, name, factory, weighs_more_than=None, weighs_less_than=None): DCNL DCSP self._add_predicate('view', name, factory, weighs_more_than=weighs_more_than, weighs_less_than=weighs_less_than)
@action_method DCNL def add_view_deriver(self, deriver, name=None, under=None, over=None): DCNL DCSP deriver = self.maybe_dotted(deriver) DCNL DCSP if (name is None): DCNL DCSP  DCSP name = deriver.__name__ DCNL DCSP if (name in (INGRESS, VIEW)): DCNL DCSP  DCSP raise ConfigurationError(('%s DCSP is DCSP a DCSP reserved DCSP view DCSP deriver DCSP name' % name)) DCNL DCSP if (under is None): DCNL DCSP  DCSP under = 'decorated_view' DCNL DCSP if (over is None): DCNL DCSP  DCSP over = 'rendered_view' DCNL DCSP over = as_sorted_tuple(over) DCNL DCSP under = as_sorted_tuple(under) DCNL DCSP if (INGRESS in over): DCNL DCSP  DCSP raise ConfigurationError(('%s DCSP cannot DCSP be DCSP over DCSP INGRESS' % name)) DCNL DCSP if ((VIEW in over) and (name != 'mapped_view')): DCNL DCSP  DCSP over = as_sorted_tuple((over + ('mapped_view',))) DCNL DCSP if (VIEW in under): DCNL DCSP  DCSP raise ConfigurationError(('%s DCSP cannot DCSP be DCSP under DCSP VIEW' % name)) DCNL DCSP if ('mapped_view' in under): DCNL DCSP  DCSP raise ConfigurationError(('%s DCSP cannot DCSP be DCSP under DCSP "mapped_view"' % name)) DCNL DCSP discriminator = ('view DCSP deriver', name) DCNL DCSP intr = self.introspectable('view DCSP derivers', name, name, 'view DCSP deriver') DCNL DCSP intr['name'] = name DCNL DCSP intr['deriver'] = deriver DCNL DCSP intr['under'] = under DCNL DCSP intr['over'] = over DCNL DCSP def register(): DCNL DCSP  DCSP derivers = self.registry.queryUtility(IViewDerivers) DCNL DCSP  DCSP if (derivers is None): DCNL DCSP  DCSP  DCSP derivers = TopologicalSorter(default_before=None, default_after=INGRESS, first=INGRESS, last=VIEW) DCNL DCSP  DCSP  DCSP self.registry.registerUtility(derivers, IViewDerivers) DCNL DCSP  DCSP derivers.add(name, deriver, before=over, after=under) DCNL DCSP self.action(discriminator, register, introspectables=(intr,), order=PHASE1_CONFIG)
def derive_view(self, view, attr=None, renderer=None): DCNL DCSP return self._derive_view(view, attr=attr, renderer=renderer)
@viewdefaults DCNL @action_method DCNL def add_forbidden_view(self, view=None, attr=None, renderer=None, wrapper=None, route_name=None, request_type=None, request_method=None, request_param=None, containment=None, xhr=None, accept=None, header=None, path_info=None, custom_predicates=(), decorator=None, mapper=None, match_param=None, **view_options): DCNL DCSP for arg in ('name', 'permission', 'context', 'for_', 'require_csrf', 'exception_only'): DCNL DCSP  DCSP if (arg in view_options): DCNL DCSP  DCSP  DCSP raise ConfigurationError(('%s DCSP may DCSP not DCSP be DCSP used DCSP as DCSP an DCSP argument DCSP to DCSP add_forbidden_view' % (arg,))) DCNL DCSP if (view is None): DCNL DCSP  DCSP view = default_exceptionresponse_view DCNL DCSP settings = dict(view=view, context=HTTPForbidden, exception_only=True, wrapper=wrapper, request_type=request_type, request_method=request_method, request_param=request_param, containment=containment, xhr=xhr, accept=accept, header=header, path_info=path_info, custom_predicates=custom_predicates, decorator=decorator, mapper=mapper, match_param=match_param, route_name=route_name, permission=NO_PERMISSION_REQUIRED, require_csrf=False, attr=attr, renderer=renderer) DCNL DCSP settings.update(view_options) DCNL DCSP return self.add_view(**settings)
@viewdefaults DCNL @action_method DCNL def add_notfound_view(self, view=None, attr=None, renderer=None, wrapper=None, route_name=None, request_type=None, request_method=None, request_param=None, containment=None, xhr=None, accept=None, header=None, path_info=None, custom_predicates=(), decorator=None, mapper=None, match_param=None, append_slash=False, **view_options): DCNL DCSP for arg in ('name', 'permission', 'context', 'for_', 'require_csrf', 'exception_only'): DCNL DCSP  DCSP if (arg in view_options): DCNL DCSP  DCSP  DCSP raise ConfigurationError(('%s DCSP may DCSP not DCSP be DCSP used DCSP as DCSP an DCSP argument DCSP to DCSP add_notfound_view' % (arg,))) DCNL DCSP if (view is None): DCNL DCSP  DCSP view = default_exceptionresponse_view DCNL DCSP settings = dict(view=view, context=HTTPNotFound, exception_only=True, wrapper=wrapper, request_type=request_type, request_method=request_method, request_param=request_param, containment=containment, xhr=xhr, accept=accept, header=header, path_info=path_info, custom_predicates=custom_predicates, decorator=decorator, mapper=mapper, match_param=match_param, route_name=route_name, permission=NO_PERMISSION_REQUIRED, require_csrf=False) DCNL DCSP settings.update(view_options) DCNL DCSP if append_slash: DCNL DCSP  DCSP view = self._derive_view(view, attr=attr, renderer=renderer) DCNL DCSP  DCSP if IResponse.implementedBy(append_slash): DCNL DCSP  DCSP  DCSP view = AppendSlashNotFoundViewFactory(view, redirect_class=append_slash) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP view = AppendSlashNotFoundViewFactory(view) DCNL DCSP  DCSP settings['view'] = view DCNL DCSP else: DCNL DCSP  DCSP settings['attr'] = attr DCNL DCSP  DCSP settings['renderer'] = renderer DCNL DCSP return self.add_view(**settings)
@viewdefaults DCNL @action_method DCNL def add_exception_view(self, view=None, context=None, **view_options): DCNL DCSP for arg in ('name', 'for_', 'exception_only', 'require_csrf', 'permission'): DCNL DCSP  DCSP if (arg in view_options): DCNL DCSP  DCSP  DCSP raise ConfigurationError(('%s DCSP may DCSP not DCSP be DCSP used DCSP as DCSP an DCSP argument DCSP to DCSP add_exception_view' % (arg,))) DCNL DCSP if (context is None): DCNL DCSP  DCSP context = Exception DCNL DCSP view_options.update(dict(view=view, context=context, exception_only=True, permission=NO_PERMISSION_REQUIRED, require_csrf=False)) DCNL DCSP return self.add_view(**view_options)
@action_method DCNL def set_view_mapper(self, mapper): DCNL DCSP mapper = self.maybe_dotted(mapper) DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(mapper, IViewMapperFactory) DCNL DCSP intr = self.introspectable('view DCSP mappers', IViewMapperFactory, self.object_description(mapper), 'default DCSP view DCSP mapper') DCNL DCSP intr['mapper'] = mapper DCNL DCSP self.action(IViewMapperFactory, register, order=PHASE1_CONFIG, introspectables=(intr,))
@action_method DCNL def add_static_view(self, name, path, **kw): DCNL DCSP spec = self._make_spec(path) DCNL DCSP info = self._get_static_info() DCNL DCSP info.add(self, name, spec, **kw)
def add_cache_buster(self, path, cachebust, explicit=False): DCNL DCSP spec = self._make_spec(path) DCNL DCSP info = self._get_static_info() DCNL DCSP info.add_cache_buster(self, spec, cachebust, explicit=explicit)
@action_method DCNL def set_root_factory(self, factory): DCNL DCSP factory = self.maybe_dotted(factory) DCNL DCSP if (factory is None): DCNL DCSP  DCSP factory = DefaultRootFactory DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(factory, IRootFactory) DCNL DCSP  DCSP self.registry.registerUtility(factory, IDefaultRootFactory) DCNL DCSP intr = self.introspectable('root DCSP factories', None, self.object_description(factory), 'root DCSP factory') DCNL DCSP intr['factory'] = factory DCNL DCSP self.action(IRootFactory, register, introspectables=(intr,))
@action_method DCNL def set_session_factory(self, factory): DCNL DCSP factory = self.maybe_dotted(factory) DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(factory, ISessionFactory) DCNL DCSP intr = self.introspectable('session DCSP factory', None, self.object_description(factory), 'session DCSP factory') DCNL DCSP intr['factory'] = factory DCNL DCSP self.action(ISessionFactory, register, introspectables=(intr,))
@action_method DCNL def set_request_factory(self, factory): DCNL DCSP factory = self.maybe_dotted(factory) DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(factory, IRequestFactory) DCNL DCSP intr = self.introspectable('request DCSP factory', None, self.object_description(factory), 'request DCSP factory') DCNL DCSP intr['factory'] = factory DCNL DCSP self.action(IRequestFactory, register, introspectables=(intr,))
@action_method DCNL def set_response_factory(self, factory): DCNL DCSP factory = self.maybe_dotted(factory) DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(factory, IResponseFactory) DCNL DCSP intr = self.introspectable('response DCSP factory', None, self.object_description(factory), 'response DCSP factory') DCNL DCSP intr['factory'] = factory DCNL DCSP self.action(IResponseFactory, register, introspectables=(intr,))
@action_method DCNL def add_request_method(self, callable=None, name=None, property=False, reify=False): DCNL DCSP if (callable is not None): DCNL DCSP  DCSP callable = self.maybe_dotted(callable) DCNL DCSP property = (property or reify) DCNL DCSP if property: DCNL DCSP  DCSP (name, callable) = InstancePropertyHelper.make_property(callable, name=name, reify=reify) DCNL DCSP elif (name is None): DCNL DCSP  DCSP name = callable.__name__ DCNL DCSP else: DCNL DCSP  DCSP name = get_callable_name(name) DCNL DCSP def register(): DCNL DCSP  DCSP exts = self.registry.queryUtility(IRequestExtensions) DCNL DCSP  DCSP if (exts is None): DCNL DCSP  DCSP  DCSP exts = _RequestExtensions() DCNL DCSP  DCSP  DCSP self.registry.registerUtility(exts, IRequestExtensions) DCNL DCSP  DCSP plist = (exts.descriptors if property else exts.methods) DCNL DCSP  DCSP plist[name] = callable DCNL DCSP if (callable is None): DCNL DCSP  DCSP self.action(('request DCSP extensions', name), None) DCNL DCSP elif property: DCNL DCSP  DCSP intr = self.introspectable('request DCSP extensions', name, self.object_description(callable), 'request DCSP property') DCNL DCSP  DCSP intr['callable'] = callable DCNL DCSP  DCSP intr['property'] = True DCNL DCSP  DCSP intr['reify'] = reify DCNL DCSP  DCSP self.action(('request DCSP extensions', name), register, introspectables=(intr,)) DCNL DCSP else: DCNL DCSP  DCSP intr = self.introspectable('request DCSP extensions', name, self.object_description(callable), 'request DCSP method') DCNL DCSP  DCSP intr['callable'] = callable DCNL DCSP  DCSP intr['property'] = False DCNL DCSP  DCSP intr['reify'] = False DCNL DCSP  DCSP self.action(('request DCSP extensions', name), register, introspectables=(intr,))
@action_method DCNL def set_request_property(self, callable, name=None, reify=False): DCNL DCSP self.add_request_method(callable, name=name, property=(not reify), reify=reify)
@action_method DCNL def set_execution_policy(self, policy): DCNL DCSP policy = self.maybe_dotted(policy) DCNL DCSP if (policy is None): DCNL DCSP  DCSP policy = default_execution_policy DCNL DCSP def register(): DCNL DCSP  DCSP self.registry.registerUtility(policy, IExecutionPolicy) DCNL DCSP intr = self.introspectable('execution DCSP policy', None, self.object_description(policy), 'execution DCSP policy') DCNL DCSP intr['policy'] = policy DCNL DCSP self.action(IExecutionPolicy, register, introspectables=(intr,))
@action_method DCNL def add_subscriber(self, subscriber, iface=None, **predicates): DCNL DCSP dotted = self.maybe_dotted DCNL DCSP (subscriber, iface) = (dotted(subscriber), dotted(iface)) DCNL DCSP if (iface is None): DCNL DCSP  DCSP iface = (Interface,) DCNL DCSP if (not isinstance(iface, (tuple, list))): DCNL DCSP  DCSP iface = (iface,) DCNL DCSP def register(): DCNL DCSP  DCSP predlist = self.get_predlist('subscriber') DCNL DCSP  DCSP (order, preds, phash) = predlist.make(self, **predicates) DCNL DCSP  DCSP derived_predicates = [self._derive_predicate(p) for p in preds] DCNL DCSP  DCSP derived_subscriber = self._derive_subscriber(subscriber, derived_predicates) DCNL DCSP  DCSP intr.update({'phash': phash, 'order': order, 'predicates': preds, 'derived_predicates': derived_predicates, 'derived_subscriber': derived_subscriber}) DCNL DCSP  DCSP self.registry.registerHandler(derived_subscriber, iface) DCNL DCSP intr = self.introspectable('subscribers', id(subscriber), self.object_description(subscriber), 'subscriber') DCNL DCSP intr['subscriber'] = subscriber DCNL DCSP intr['interfaces'] = iface DCNL DCSP self.action(None, register, introspectables=(intr,)) DCNL DCSP return subscriber
@action_method DCNL def add_subscriber_predicate(self, name, factory, weighs_more_than=None, weighs_less_than=None): DCNL DCSP self._add_predicate('subscriber', name, factory, weighs_more_than=weighs_more_than, weighs_less_than=weighs_less_than)
@action_method DCNL def add_response_adapter(self, adapter, type_or_iface): DCNL DCSP adapter = self.maybe_dotted(adapter) DCNL DCSP type_or_iface = self.maybe_dotted(type_or_iface) DCNL DCSP def register(): DCNL DCSP  DCSP reg = self.registry DCNL DCSP  DCSP if (adapter is None): DCNL DCSP  DCSP  DCSP reg.registerSelfAdapter((type_or_iface,), IResponse) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP reg.registerAdapter(adapter, (type_or_iface,), IResponse) DCNL DCSP discriminator = (IResponse, type_or_iface) DCNL DCSP intr = self.introspectable('response DCSP adapters', discriminator, self.object_description(adapter), 'response DCSP adapter') DCNL DCSP intr['adapter'] = adapter DCNL DCSP intr['type'] = type_or_iface DCNL DCSP self.action(discriminator, register, introspectables=(intr,))
@action_method DCNL def add_traverser(self, adapter, iface=None): DCNL DCSP iface = self.maybe_dotted(iface) DCNL DCSP adapter = self.maybe_dotted(adapter) DCNL DCSP def register(iface=iface): DCNL DCSP  DCSP if (iface is None): DCNL DCSP  DCSP  DCSP iface = Interface DCNL DCSP  DCSP self.registry.registerAdapter(adapter, (iface,), ITraverser) DCNL DCSP discriminator = ('traverser', iface) DCNL DCSP intr = self.introspectable('traversers', discriminator, ('traverser DCSP for DCSP %r' % iface), 'traverser') DCNL DCSP intr['adapter'] = adapter DCNL DCSP intr['iface'] = iface DCNL DCSP self.action(discriminator, register, introspectables=(intr,))
@action_method DCNL def add_resource_url_adapter(self, adapter, resource_iface=None): DCNL DCSP adapter = self.maybe_dotted(adapter) DCNL DCSP resource_iface = self.maybe_dotted(resource_iface) DCNL DCSP def register(resource_iface=resource_iface): DCNL DCSP  DCSP if (resource_iface is None): DCNL DCSP  DCSP  DCSP resource_iface = Interface DCNL DCSP  DCSP self.registry.registerAdapter(adapter, (resource_iface, Interface), IResourceURL) DCNL DCSP discriminator = ('resource DCSP url DCSP adapter', resource_iface) DCNL DCSP intr = self.introspectable('resource DCSP url DCSP adapters', discriminator, ('resource DCSP url DCSP adapter DCSP for DCSP resource DCSP iface DCSP %r' % resource_iface), 'resource DCSP url DCSP adapter') DCNL DCSP intr['adapter'] = adapter DCNL DCSP intr['resource_iface'] = resource_iface DCNL DCSP self.action(discriminator, register, introspectables=(intr,))
def loads(self, bstruct): DCNL DCSP return pickle.loads(bstruct)
def dumps(self, appstruct): DCNL DCSP return pickle.dumps(appstruct, self.protocol)
def invoke_subrequest(self, request, use_tweens=False): DCNL DCSP request.registry = self.registry DCNL DCSP request.invoke_subrequest = self.invoke_subrequest DCNL DCSP extensions = self.request_extensions DCNL DCSP if (extensions is not None): DCNL DCSP  DCSP apply_request_extensions(request, extensions=extensions) DCNL DCSP with RequestContext(request): DCNL DCSP  DCSP return self.invoke_request(request, _use_tweens=use_tweens)
def request_context(self, environ): DCNL DCSP request = self.request_factory(environ) DCNL DCSP request.registry = self.registry DCNL DCSP request.invoke_subrequest = self.invoke_subrequest DCNL DCSP extensions = self.request_extensions DCNL DCSP if (extensions is not None): DCNL DCSP  DCSP apply_request_extensions(request, extensions=extensions) DCNL DCSP return RequestContext(request)
def invoke_request(self, request, _use_tweens=True): DCNL DCSP registry = self.registry DCNL DCSP has_listeners = registry.has_listeners DCNL DCSP notify = registry.notify DCNL DCSP if _use_tweens: DCNL DCSP  DCSP handle_request = self.handle_request DCNL DCSP else: DCNL DCSP  DCSP handle_request = self.orig_handle_request DCNL DCSP try: DCNL DCSP  DCSP response = handle_request(request) DCNL DCSP  DCSP if request.response_callbacks: DCNL DCSP  DCSP  DCSP request._process_response_callbacks(response) DCNL DCSP  DCSP (has_listeners and notify(NewResponse(request, response))) DCNL DCSP  DCSP return response DCNL DCSP finally: DCNL DCSP  DCSP if request.finished_callbacks: DCNL DCSP  DCSP  DCSP request._process_finished_callbacks()
def __call__(self, environ, start_response): DCNL DCSP response = self.execution_policy(environ, self) DCNL DCSP return response(environ, start_response)
def __getattr__(self, k): DCNL DCSP val = self._received.get(k, _marker) DCNL DCSP if (val is _marker): DCNL DCSP  DCSP val = self._implementation._received.get(k, _marker) DCNL DCSP  DCSP if (val is _marker): DCNL DCSP  DCSP  DCSP raise AttributeError(k) DCNL DCSP return val
def assert_(self, **kw): DCNL DCSP for (k, v) in kw.items(): DCNL DCSP  DCSP myval = self._received.get(k, _marker) DCNL DCSP  DCSP if (myval is _marker): DCNL DCSP  DCSP  DCSP myval = self._implementation._received.get(k, _marker) DCNL DCSP  DCSP  DCSP if (myval is _marker): DCNL DCSP  DCSP  DCSP  DCSP raise AssertionError(('A DCSP value DCSP for DCSP key DCSP "%s" DCSP was DCSP not DCSP passed DCSP to DCSP the DCSP renderer' % k)) DCNL DCSP  DCSP if (myval != v): DCNL DCSP  DCSP  DCSP raise AssertionError(('\nasserted DCSP value DCSP for DCSP %s: DCSP %r\nactual DCSP value: DCSP %r' % (k, v, myval))) DCNL DCSP return True
def __init__(self, __name__=None, __parent__=None, __provides__=None, **kw): DCNL DCSP self.__name__ = __name__ DCNL DCSP self.__parent__ = __parent__ DCNL DCSP if (__provides__ is not None): DCNL DCSP  DCSP alsoProvides(self, __provides__) DCNL DCSP self.kw = kw DCNL DCSP self.__dict__.update(**kw) DCNL DCSP self.subs = {}
def __setitem__(self, name, val): DCNL DCSP val.__name__ = name DCNL DCSP val.__parent__ = self DCNL DCSP self.subs[name] = val
def __getitem__(self, name): DCNL DCSP ob = self.subs[name] DCNL DCSP return ob
def values(self): DCNL DCSP return self.subs.values()
def items(self): DCNL DCSP return self.subs.items()
def keys(self): DCNL DCSP return self.subs.keys()
def clone(self, __name__=_marker, __parent__=_marker, **kw): DCNL DCSP oldkw = self.kw.copy() DCNL DCSP oldkw.update(kw) DCNL DCSP inst = self.__class__(self.__name__, self.__parent__, **oldkw) DCNL DCSP inst.subs = copy.deepcopy(self.subs) DCNL DCSP if (__name__ is not _marker): DCNL DCSP  DCSP inst.__name__ = __name__ DCNL DCSP if (__parent__ is not _marker): DCNL DCSP  DCSP inst.__parent__ = __parent__ DCNL DCSP return inst
def _find_view(self, request): DCNL DCSP from zope.interface import providedBy DCNL DCSP from zope.interface import implementer DCNL DCSP from pyramid.interfaces import IRequest DCNL DCSP from pyramid.interfaces import IRootFactory DCNL DCSP from pyramid.interfaces import IRouteRequest DCNL DCSP from pyramid.interfaces import IRoutesMapper DCNL DCSP from pyramid.interfaces import ITraverser DCNL DCSP from pyramid.traversal import DefaultRootFactory DCNL DCSP from pyramid.traversal import ResourceTreeTraverser DCNL DCSP registry = request.registry DCNL DCSP q = registry.queryUtility DCNL DCSP root_factory = q(IRootFactory, default=DefaultRootFactory) DCNL DCSP routes_mapper = q(IRoutesMapper) DCNL DCSP adapters = registry.adapters DCNL DCSP @implementer(IMultiView) DCNL DCSP class RoutesMultiView(object, ): DCNL DCSP  DCSP def __init__(self, infos, context_iface, root_factory, request): DCNL DCSP  DCSP  DCSP self.views = [] DCNL DCSP  DCSP  DCSP for info in infos: DCNL DCSP  DCSP  DCSP  DCSP (match, route) = (info['match'], info['route']) DCNL DCSP  DCSP  DCSP  DCSP if (route is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP request_iface = registry.queryUtility(IRouteRequest, name=route.name, default=IRequest) DCNL DCSP  DCSP  DCSP  DCSP  DCSP views = _find_views(request.registry, request_iface, context_iface, '') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not views): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP view = views[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP view.__request_attrs__ = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP view.__request_attrs__['matchdict'] = match DCNL DCSP  DCSP  DCSP  DCSP  DCSP view.__request_attrs__['matched_route'] = route DCNL DCSP  DCSP  DCSP  DCSP  DCSP root_factory = (route.factory or root_factory) DCNL DCSP  DCSP  DCSP  DCSP  DCSP root = root_factory(request) DCNL DCSP  DCSP  DCSP  DCSP  DCSP traverser = adapters.queryAdapter(root, ITraverser) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (traverser is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP traverser = ResourceTreeTraverser(root) DCNL DCSP  DCSP  DCSP  DCSP  DCSP tdict = traverser(request) DCNL DCSP  DCSP  DCSP  DCSP  DCSP view.__request_attrs__.update(tdict) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not hasattr(view, '__view_attr__')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP view.__view_attr__ = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.views.append((None, view, None)) DCNL DCSP context = None DCNL DCSP routes_multiview = None DCNL DCSP attrs = request.__dict__ DCNL DCSP request_iface = IRequest DCNL DCSP if (routes_mapper is not None): DCNL DCSP  DCSP infos = self._find_multi_routes(routes_mapper, request) DCNL DCSP  DCSP if (len(infos) == 1): DCNL DCSP  DCSP  DCSP info = infos[0] DCNL DCSP  DCSP  DCSP (match, route) = (info['match'], info['route']) DCNL DCSP  DCSP  DCSP if (route is not None): DCNL DCSP  DCSP  DCSP  DCSP attrs['matchdict'] = match DCNL DCSP  DCSP  DCSP  DCSP attrs['matched_route'] = route DCNL DCSP  DCSP  DCSP  DCSP request.environ['bfg.routes.matchdict'] = match DCNL DCSP  DCSP  DCSP  DCSP request_iface = registry.queryUtility(IRouteRequest, name=route.name, default=IRequest) DCNL DCSP  DCSP  DCSP  DCSP root_factory = (route.factory or root_factory) DCNL DCSP  DCSP if (len(infos) > 1): DCNL DCSP  DCSP  DCSP routes_multiview = infos DCNL DCSP root = root_factory(request) DCNL DCSP attrs['root'] = root DCNL DCSP traverser = adapters.queryAdapter(root, ITraverser) DCNL DCSP if (traverser is None): DCNL DCSP  DCSP traverser = ResourceTreeTraverser(root) DCNL DCSP tdict = traverser(request) DCNL DCSP (context, view_name) = (tdict['context'], tdict['view_name']) DCNL DCSP attrs.update(tdict) DCNL DCSP context_iface = providedBy(context) DCNL DCSP if (routes_multiview is None): DCNL DCSP  DCSP views = _find_views(request.registry, request_iface, context_iface, view_name) DCNL DCSP  DCSP if views: DCNL DCSP  DCSP  DCSP view = views[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP view = None DCNL DCSP else: DCNL DCSP  DCSP view = RoutesMultiView(infos, context_iface, root_factory, request) DCNL DCSP if (view is None): DCNL DCSP  DCSP views = _find_views(request.registry, request_iface, context_iface, '') DCNL DCSP  DCSP if views: DCNL DCSP  DCSP  DCSP view = views[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP view = None DCNL DCSP  DCSP if IMultiView.providedBy(view): DCNL DCSP  DCSP  DCSP view = None DCNL DCSP if (view is not None): DCNL DCSP  DCSP view.__request_attrs__ = attrs DCNL DCSP return view
def pre(self, command, output_dir, vars): DCNL DCSP vars['random_string'] = native_(binascii.hexlify(os.urandom(20))) DCNL DCSP package_logger = vars['package'] DCNL DCSP if (package_logger == 'root'): DCNL DCSP  DCSP package_logger = 'app' DCNL DCSP vars['package_logger'] = package_logger DCNL DCSP return Template.pre(self, command, output_dir, vars)
def post(self, command, output_dir, vars): DCNL DCSP separator = ('=' * 79) DCNL DCSP msg = dedent(('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %(separator)s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Tutorials: DCSP  DCSP  DCSP  DCSP  DCSP https://docs.pylonsproject.org/projects/pyramid_tutorials/en/latest/\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Documentation: DCSP https://docs.pylonsproject.org/projects/pyramid/en/latest/\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Twitter: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP https://twitter.com/PylonsProject\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Mailing DCSP List: DCSP  DCSP https://groups.google.com/forum/#!forum/pylons-discuss\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Welcome DCSP to DCSP Pyramid. DCSP  DCSP Sorry DCSP for DCSP the DCSP convenience.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %(separator)s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' % {'separator': separator})) DCNL DCSP self.out(msg) DCNL DCSP return Template.post(self, command, output_dir, vars)
def render_template(self, content, vars, filename=None): DCNL DCSP content = native_(content, fsenc) DCNL DCSP try: DCNL DCSP  DCSP return bytes_(substitute_escaped_double_braces(substitute_double_braces(content, TypeMapper(vars))), fsenc) DCNL DCSP except Exception as e: DCNL DCSP  DCSP _add_except(e, (' DCSP in DCSP file DCSP %s' % filename)) DCNL DCSP  DCSP raise
def template_dir(self): DCNL DCSP assert (self._template_dir is not None), ("Template DCSP %r DCSP didn't DCSP set DCSP _template_dir" % self) DCNL DCSP if isinstance(self._template_dir, tuple): DCNL DCSP  DCSP return self._template_dir DCNL DCSP else: DCNL DCSP  DCSP return os.path.join(self.module_dir(), self._template_dir)
def pre(self, command, output_dir, vars): DCNL DCSP pass
def post(self, command, output_dir, vars): DCNL DCSP pass
def parse_manifest(self, content): DCNL DCSP return json.loads(content.decode('utf-8'))
@property DCNL def manifest(self): DCNL DCSP if self.reload: DCNL DCSP  DCSP if (not self.exists(self.manifest_path)): DCNL DCSP  DCSP  DCSP return {} DCNL DCSP  DCSP mtime = self.getmtime(self.manifest_path) DCNL DCSP  DCSP if ((self._mtime is None) or (mtime > self._mtime)): DCNL DCSP  DCSP  DCSP self._manifest = self.get_manifest() DCNL DCSP  DCSP  DCSP self._mtime = mtime DCNL DCSP return self._manifest
def __init__(self, serializer=json.dumps, adapters=(), **kw): DCNL DCSP self.serializer = serializer DCNL DCSP self.kw = kw DCNL DCSP self.components = Components() DCNL DCSP for (type, adapter) in adapters: DCNL DCSP  DCSP self.add_adapter(type, adapter)
def add_adapter(self, type_or_iface, adapter): DCNL DCSP self.components.registerAdapter(adapter, (type_or_iface,), IJSONAdapter)
def __call__(self, info): DCNL DCSP def _render(value, system): DCNL DCSP  DCSP request = system.get('request') DCNL DCSP  DCSP if (request is not None): DCNL DCSP  DCSP  DCSP response = request.response DCNL DCSP  DCSP  DCSP ct = response.content_type DCNL DCSP  DCSP  DCSP if (ct == response.default_content_type): DCNL DCSP  DCSP  DCSP  DCSP response.content_type = 'application/json' DCNL DCSP  DCSP default = self._make_default(request) DCNL DCSP  DCSP return self.serializer(value, default=default, **self.kw) DCNL DCSP return _render
def __call__(self, info): DCNL DCSP def _render(value, system): DCNL DCSP  DCSP request = system.get('request') DCNL DCSP  DCSP default = self._make_default(request) DCNL DCSP  DCSP val = self.serializer(value, default=default, **self.kw) DCNL DCSP  DCSP ct = 'application/json' DCNL DCSP  DCSP body = val DCNL DCSP  DCSP if (request is not None): DCNL DCSP  DCSP  DCSP callback = request.GET.get(self.param_name) DCNL DCSP  DCSP  DCSP if (callback is not None): DCNL DCSP  DCSP  DCSP  DCSP if (not JSONP_VALID_CALLBACK.match(callback)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise HTTPBadRequest('Invalid DCSP JSONP DCSP callback DCSP function DCSP name.') DCNL DCSP  DCSP  DCSP  DCSP ct = 'application/javascript' DCNL DCSP  DCSP  DCSP  DCSP body = '/**/{0}({1});'.format(callback, val) DCNL DCSP  DCSP  DCSP response = request.response DCNL DCSP  DCSP  DCSP if (response.content_type == response.default_content_type): DCNL DCSP  DCSP  DCSP  DCSP response.content_type = ct DCNL DCSP  DCSP return body DCNL DCSP return _render
def authenticated_userid(self, request): DCNL DCSP debug = self.debug DCNL DCSP userid = self.unauthenticated_userid(request) DCNL DCSP if (userid is None): DCNL DCSP  DCSP (debug and self._log('call DCSP to DCSP unauthenticated_userid DCSP returned DCSP None; DCSP returning DCSP None', 'authenticated_userid', request)) DCNL DCSP  DCSP return None DCNL DCSP if (self._clean_principal(userid) is None): DCNL DCSP  DCSP (debug and self._log(('use DCSP of DCSP userid DCSP %r DCSP is DCSP disallowed DCSP by DCSP any DCSP built-in DCSP Pyramid DCSP security DCSP policy, DCSP returning DCSP None' % userid), 'authenticated_userid', request)) DCNL DCSP  DCSP return None DCNL DCSP if (self.callback is None): DCNL DCSP  DCSP (debug and self._log(('there DCSP was DCSP no DCSP groupfinder DCSP callback; DCSP returning DCSP %r' % (userid,)), 'authenticated_userid', request)) DCNL DCSP  DCSP return userid DCNL DCSP callback_ok = self.callback(userid, request) DCNL DCSP if (callback_ok is not None): DCNL DCSP  DCSP (debug and self._log(('groupfinder DCSP callback DCSP returned DCSP %r; DCSP returning DCSP %r' % (callback_ok, userid)), 'authenticated_userid', request)) DCNL DCSP  DCSP return userid DCNL DCSP (debug and self._log('groupfinder DCSP callback DCSP returned DCSP None; DCSP returning DCSP None', 'authenticated_userid', request))
def effective_principals(self, request): DCNL DCSP debug = self.debug DCNL DCSP effective_principals = [Everyone] DCNL DCSP userid = self.unauthenticated_userid(request) DCNL DCSP if (userid is None): DCNL DCSP  DCSP (debug and self._log(('unauthenticated_userid DCSP returned DCSP %r; DCSP returning DCSP %r' % (userid, effective_principals)), 'effective_principals', request)) DCNL DCSP  DCSP return effective_principals DCNL DCSP if (self._clean_principal(userid) is None): DCNL DCSP  DCSP (debug and self._log(('unauthenticated_userid DCSP returned DCSP disallowed DCSP %r; DCSP returning DCSP %r DCSP as DCSP if DCSP it DCSP was DCSP None' % (userid, effective_principals)), 'effective_principals', request)) DCNL DCSP  DCSP return effective_principals DCNL DCSP if (self.callback is None): DCNL DCSP  DCSP (debug and self._log('groupfinder DCSP callback DCSP is DCSP None, DCSP so DCSP groups DCSP is DCSP []', 'effective_principals', request)) DCNL DCSP  DCSP groups = [] DCNL DCSP else: DCNL DCSP  DCSP groups = self.callback(userid, request) DCNL DCSP  DCSP (debug and self._log(('groupfinder DCSP callback DCSP returned DCSP %r DCSP as DCSP groups' % (groups,)), 'effective_principals', request)) DCNL DCSP if (groups is None): DCNL DCSP  DCSP (debug and self._log(('returning DCSP effective DCSP principals: DCSP %r' % (effective_principals,)), 'effective_principals', request)) DCNL DCSP  DCSP return effective_principals DCNL DCSP effective_principals.append(Authenticated) DCNL DCSP effective_principals.append(userid) DCNL DCSP effective_principals.extend(groups) DCNL DCSP (debug and self._log(('returning DCSP effective DCSP principals: DCSP %r' % (effective_principals,)), 'effective_principals', request)) DCNL DCSP return effective_principals
def authenticated_userid(self, request): DCNL DCSP identity = self._get_identity(request) DCNL DCSP if (identity is None): DCNL DCSP  DCSP (self.debug and self._log('repoze.who DCSP identity DCSP is DCSP None, DCSP returning DCSP None', 'authenticated_userid', request)) DCNL DCSP  DCSP return None DCNL DCSP userid = identity['repoze.who.userid'] DCNL DCSP if (userid is None): DCNL DCSP  DCSP (self.debug and self._log(('repoze.who.userid DCSP is DCSP None, DCSP returning DCSP None' % userid), 'authenticated_userid', request)) DCNL DCSP  DCSP return None DCNL DCSP if (self._clean_principal(userid) is None): DCNL DCSP  DCSP (self.debug and self._log(('use DCSP of DCSP userid DCSP %r DCSP is DCSP disallowed DCSP by DCSP any DCSP built-in DCSP Pyramid DCSP security DCSP policy, DCSP returning DCSP None' % userid), 'authenticated_userid', request)) DCNL DCSP  DCSP return None DCNL DCSP if (self.callback is None): DCNL DCSP  DCSP return userid DCNL DCSP if (self.callback(identity, request) is not None): DCNL DCSP  DCSP return userid
def unauthenticated_userid(self, request): DCNL DCSP identity = self._get_identity(request) DCNL DCSP if (identity is None): DCNL DCSP  DCSP return None DCNL DCSP return identity['repoze.who.userid']
def effective_principals(self, request): DCNL DCSP effective_principals = [Everyone] DCNL DCSP identity = self._get_identity(request) DCNL DCSP if (identity is None): DCNL DCSP  DCSP (self.debug and self._log(('repoze.who DCSP identity DCSP was DCSP None; DCSP returning DCSP %r' % effective_principals), 'effective_principals', request)) DCNL DCSP  DCSP return effective_principals DCNL DCSP if (self.callback is None): DCNL DCSP  DCSP groups = [] DCNL DCSP else: DCNL DCSP  DCSP groups = self.callback(identity, request) DCNL DCSP if (groups is None): DCNL DCSP  DCSP (self.debug and self._log(('security DCSP policy DCSP groups DCSP callback DCSP returned DCSP None; DCSP returning DCSP %r' % effective_principals), 'effective_principals', request)) DCNL DCSP  DCSP return effective_principals DCNL DCSP userid = identity['repoze.who.userid'] DCNL DCSP if (userid is None): DCNL DCSP  DCSP (self.debug and self._log(('repoze.who.userid DCSP was DCSP None; DCSP returning DCSP %r' % effective_principals), 'effective_principals', request)) DCNL DCSP  DCSP return effective_principals DCNL DCSP if (self._clean_principal(userid) is None): DCNL DCSP  DCSP (self.debug and self._log(('unauthenticated_userid DCSP returned DCSP disallowed DCSP %r; DCSP returning DCSP %r DCSP as DCSP if DCSP it DCSP was DCSP None' % (userid, effective_principals)), 'effective_principals', request)) DCNL DCSP  DCSP return effective_principals DCNL DCSP effective_principals.append(Authenticated) DCNL DCSP effective_principals.append(userid) DCNL DCSP effective_principals.extend(groups) DCNL DCSP return effective_principals
def remember(self, request, userid, **kw): DCNL DCSP identifier = self._get_identifier(request) DCNL DCSP if (identifier is None): DCNL DCSP  DCSP return [] DCNL DCSP environ = request.environ DCNL DCSP identity = kw DCNL DCSP identity['repoze.who.userid'] = userid DCNL DCSP return identifier.remember(environ, identity)
def forget(self, request): DCNL DCSP identifier = self._get_identifier(request) DCNL DCSP if (identifier is None): DCNL DCSP  DCSP return [] DCNL DCSP identity = self._get_identity(request) DCNL DCSP return identifier.forget(request.environ, identity)
def unauthenticated_userid(self, request): DCNL DCSP return request.environ.get(self.environ_key)
def remember(self, request, userid, **kw): DCNL DCSP return []
def forget(self, request): DCNL DCSP return []
def unauthenticated_userid(self, request): DCNL DCSP result = self.cookie.identify(request) DCNL DCSP if result: DCNL DCSP  DCSP return result['userid']
def remember(self, request, userid, **kw): DCNL DCSP return self.cookie.remember(request, userid, **kw)
def forget(self, request): DCNL DCSP return self.cookie.forget(request)
def identify(self, request): DCNL DCSP environ = request.environ DCNL DCSP cookie = request.cookies.get(self.cookie_name) DCNL DCSP if (cookie is None): DCNL DCSP  DCSP return None DCNL DCSP if self.include_ip: DCNL DCSP  DCSP remote_addr = environ['REMOTE_ADDR'] DCNL DCSP else: DCNL DCSP  DCSP remote_addr = '0.0.0.0' DCNL DCSP try: DCNL DCSP  DCSP (timestamp, userid, tokens, user_data) = self.parse_ticket(self.secret, cookie, remote_addr, self.hashalg) DCNL DCSP except self.BadTicket: DCNL DCSP  DCSP return None DCNL DCSP now = self.now DCNL DCSP if (now is None): DCNL DCSP  DCSP now = time_mod.time() DCNL DCSP if (self.timeout and ((timestamp + self.timeout) < now)): DCNL DCSP  DCSP return None DCNL DCSP userid_typename = 'userid_type:' DCNL DCSP user_data_info = user_data.split('|') DCNL DCSP for datum in filter(None, user_data_info): DCNL DCSP  DCSP if datum.startswith(userid_typename): DCNL DCSP  DCSP  DCSP userid_type = datum[len(userid_typename):] DCNL DCSP  DCSP  DCSP decoder = self.userid_type_decoders.get(userid_type) DCNL DCSP  DCSP  DCSP if decoder: DCNL DCSP  DCSP  DCSP  DCSP userid = decoder(userid) DCNL DCSP reissue = (self.reissue_time is not None) DCNL DCSP if (reissue and (not hasattr(request, '_authtkt_reissued'))): DCNL DCSP  DCSP if ((now - timestamp) > self.reissue_time): DCNL DCSP  DCSP  DCSP tokens = list(filter(None, tokens)) DCNL DCSP  DCSP  DCSP headers = self.remember(request, userid, max_age=self.max_age, tokens=tokens) DCNL DCSP  DCSP  DCSP def reissue_authtkt(request, response): DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(request, '_authtkt_reissue_revoked')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (k, v) in headers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response.headerlist.append((k, v)) DCNL DCSP  DCSP  DCSP request.add_response_callback(reissue_authtkt) DCNL DCSP  DCSP  DCSP request._authtkt_reissued = True DCNL DCSP environ['REMOTE_USER_TOKENS'] = tokens DCNL DCSP environ['REMOTE_USER_DATA'] = user_data DCNL DCSP environ['AUTH_TYPE'] = 'cookie' DCNL DCSP identity = {} DCNL DCSP identity['timestamp'] = timestamp DCNL DCSP identity['userid'] = userid DCNL DCSP identity['tokens'] = tokens DCNL DCSP identity['userdata'] = user_data DCNL DCSP return identity
def forget(self, request): DCNL DCSP request._authtkt_reissue_revoked = True DCNL DCSP return self._get_cookies(request, None)
def remember(self, request, userid, max_age=None, tokens=()): DCNL DCSP max_age = (self.max_age if (max_age is None) else int(max_age)) DCNL DCSP environ = request.environ DCNL DCSP if self.include_ip: DCNL DCSP  DCSP remote_addr = environ['REMOTE_ADDR'] DCNL DCSP else: DCNL DCSP  DCSP remote_addr = '0.0.0.0' DCNL DCSP user_data = '' DCNL DCSP encoding_data = self.userid_type_encoders.get(type(userid)) DCNL DCSP if encoding_data: DCNL DCSP  DCSP (encoding, encoder) = encoding_data DCNL DCSP else: DCNL DCSP  DCSP warnings.warn('userid DCSP is DCSP of DCSP type DCSP {}, DCSP and DCSP is DCSP not DCSP supported DCSP by DCSP the DCSP AuthTktAuthenticationPolicy. DCSP Explicitly DCSP converting DCSP to DCSP string DCSP and DCSP storing DCSP as DCSP base64. DCSP Subsequent DCSP requests DCSP will DCSP receive DCSP a DCSP string DCSP as DCSP the DCSP userid, DCSP it DCSP will DCSP not DCSP be DCSP decoded DCSP back DCSP to DCSP the DCSP type DCSP provided.'.format(type(userid)), RuntimeWarning) DCNL DCSP  DCSP (encoding, encoder) = self.userid_type_encoders.get(text_type) DCNL DCSP  DCSP userid = str(userid) DCNL DCSP userid = encoder(userid) DCNL DCSP user_data = ('userid_type:%s' % encoding) DCNL DCSP new_tokens = [] DCNL DCSP for token in tokens: DCNL DCSP  DCSP if isinstance(token, text_type): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP token = ascii_native_(token) DCNL DCSP  DCSP  DCSP except UnicodeEncodeError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Invalid DCSP token DCSP %r' % (token,))) DCNL DCSP  DCSP if (not (isinstance(token, str) and VALID_TOKEN.match(token))): DCNL DCSP  DCSP  DCSP raise ValueError(('Invalid DCSP token DCSP %r' % (token,))) DCNL DCSP  DCSP new_tokens.append(token) DCNL DCSP tokens = tuple(new_tokens) DCNL DCSP if hasattr(request, '_authtkt_reissued'): DCNL DCSP  DCSP request._authtkt_reissue_revoked = True DCNL DCSP ticket = self.AuthTicket(self.secret, userid, remote_addr, tokens=tokens, user_data=user_data, cookie_name=self.cookie_name, secure=self.secure, hashalg=self.hashalg) DCNL DCSP cookie_value = ticket.cookie_value() DCNL DCSP return self._get_cookies(request, cookie_value, max_age)
def remember(self, request, userid, **kw): DCNL DCSP request.session[self.userid_key] = userid DCNL DCSP return []
def forget(self, request): DCNL DCSP if (self.userid_key in request.session): DCNL DCSP  DCSP del request.session[self.userid_key] DCNL DCSP return []
def unauthenticated_userid(self, request): DCNL DCSP credentials = extract_http_basic_credentials(request) DCNL DCSP if credentials: DCNL DCSP  DCSP return credentials.username
def remember(self, request, userid, **kw): DCNL DCSP return []
def forget(self, request): DCNL DCSP return [('WWW-Authenticate', ('Basic DCSP realm="%s"' % self.realm))]
def new_csrf_token(self, request): DCNL DCSP return request.session.new_csrf_token()
def get_csrf_token(self, request): DCNL DCSP return request.session.get_csrf_token()
def check_csrf_token(self, request, supplied_token): DCNL DCSP expected_token = self.get_csrf_token(request) DCNL DCSP return (not strings_differ(bytes_(expected_token), bytes_(supplied_token)))
def new_csrf_token(self, request): DCNL DCSP token = self._token_factory() DCNL DCSP request.session[self.key] = token DCNL DCSP return token
def get_csrf_token(self, request): DCNL DCSP token = request.session.get(self.key, None) DCNL DCSP if (not token): DCNL DCSP  DCSP token = self.new_csrf_token(request) DCNL DCSP return token
def check_csrf_token(self, request, supplied_token): DCNL DCSP expected_token = self.get_csrf_token(request) DCNL DCSP return (not strings_differ(bytes_(expected_token), bytes_(supplied_token)))
def new_csrf_token(self, request): DCNL DCSP token = self._token_factory() DCNL DCSP request.cookies[self.cookie_name] = token DCNL DCSP def set_cookie(request, response): DCNL DCSP  DCSP self.cookie_profile.set_cookies(response, token) DCNL DCSP request.add_response_callback(set_cookie) DCNL DCSP return token
def get_csrf_token(self, request): DCNL DCSP bound_cookies = self.cookie_profile.bind(request) DCNL DCSP token = bound_cookies.get_value() DCNL DCSP if (not token): DCNL DCSP  DCSP token = self.new_csrf_token(request) DCNL DCSP return token
def check_csrf_token(self, request, supplied_token): DCNL DCSP expected_token = self.get_csrf_token(request) DCNL DCSP return (not strings_differ(bytes_(expected_token), bytes_(supplied_token)))
def _partial_application_url(self, scheme=None, host=None, port=None): DCNL DCSP e = self.environ DCNL DCSP if (scheme is None): DCNL DCSP  DCSP scheme = e['wsgi.url_scheme'] DCNL DCSP else: DCNL DCSP  DCSP if (scheme == 'https'): DCNL DCSP  DCSP  DCSP if (port is None): DCNL DCSP  DCSP  DCSP  DCSP port = '443' DCNL DCSP  DCSP if (scheme == 'http'): DCNL DCSP  DCSP  DCSP if (port is None): DCNL DCSP  DCSP  DCSP  DCSP port = '80' DCNL DCSP if (host is None): DCNL DCSP  DCSP host = e.get('HTTP_HOST') DCNL DCSP  DCSP if (host is None): DCNL DCSP  DCSP  DCSP host = e['SERVER_NAME'] DCNL DCSP if (port is None): DCNL DCSP  DCSP if (':' in host): DCNL DCSP  DCSP  DCSP (host, port) = host.split(':', 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = e['SERVER_PORT'] DCNL DCSP else: DCNL DCSP  DCSP port = str(port) DCNL DCSP  DCSP if (':' in host): DCNL DCSP  DCSP  DCSP (host, _) = host.split(':', 1) DCNL DCSP if (scheme == 'https'): DCNL DCSP  DCSP if (port == '443'): DCNL DCSP  DCSP  DCSP port = None DCNL DCSP elif (scheme == 'http'): DCNL DCSP  DCSP if (port == '80'): DCNL DCSP  DCSP  DCSP port = None DCNL DCSP url = ((scheme + '://') + host) DCNL DCSP if port: DCNL DCSP  DCSP url += (':%s' % port) DCNL DCSP url_encoding = getattr(self, 'url_encoding', 'utf-8') DCNL DCSP bscript_name = bytes_(self.script_name, url_encoding) DCNL DCSP return (url + url_quote(bscript_name, PATH_SAFE))
def route_url(self, route_name, *elements, **kw): DCNL DCSP try: DCNL DCSP  DCSP reg = self.registry DCNL DCSP except AttributeError: DCNL DCSP  DCSP reg = get_current_registry() DCNL DCSP mapper = reg.getUtility(IRoutesMapper) DCNL DCSP route = mapper.get_route(route_name) DCNL DCSP if (route is None): DCNL DCSP  DCSP raise KeyError(('No DCSP such DCSP route DCSP named DCSP %s' % route_name)) DCNL DCSP if (route.pregenerator is not None): DCNL DCSP  DCSP (elements, kw) = route.pregenerator(self, elements, kw) DCNL DCSP (app_url, qs, anchor) = parse_url_overrides(self, kw) DCNL DCSP path = route.generate(kw) DCNL DCSP if elements: DCNL DCSP  DCSP suffix = _join_elements(elements) DCNL DCSP  DCSP if (not path.endswith('/')): DCNL DCSP  DCSP  DCSP suffix = ('/' + suffix) DCNL DCSP else: DCNL DCSP  DCSP suffix = '' DCNL DCSP return ((((app_url + path) + suffix) + qs) + anchor)
def route_path(self, route_name, *elements, **kw): DCNL DCSP kw['_app_url'] = self.script_name DCNL DCSP return self.route_url(route_name, *elements, **kw)
def resource_url(self, resource, *elements, **kw): DCNL DCSP try: DCNL DCSP  DCSP reg = self.registry DCNL DCSP except AttributeError: DCNL DCSP  DCSP reg = get_current_registry() DCNL DCSP url_adapter = reg.queryMultiAdapter((resource, self), IResourceURL) DCNL DCSP if (url_adapter is None): DCNL DCSP  DCSP url_adapter = ResourceURL(resource, self) DCNL DCSP virtual_path = getattr(url_adapter, 'virtual_path', None) DCNL DCSP urlkw = {} DCNL DCSP for name in ('app_url', 'scheme', 'host', 'port', 'query', 'anchor'): DCNL DCSP  DCSP val = kw.get(name, None) DCNL DCSP  DCSP if (val is not None): DCNL DCSP  DCSP  DCSP urlkw[('_' + name)] = val DCNL DCSP if ('route_name' in kw): DCNL DCSP  DCSP route_name = kw['route_name'] DCNL DCSP  DCSP remainder = getattr(url_adapter, 'virtual_path_tuple', None) DCNL DCSP  DCSP if (remainder is None): DCNL DCSP  DCSP  DCSP remainder = tuple(url_adapter.virtual_path.split('/')) DCNL DCSP  DCSP remainder_name = kw.get('route_remainder_name', 'traverse') DCNL DCSP  DCSP urlkw[remainder_name] = remainder DCNL DCSP  DCSP if ('route_kw' in kw): DCNL DCSP  DCSP  DCSP route_kw = kw.get('route_kw') DCNL DCSP  DCSP  DCSP if (route_kw is not None): DCNL DCSP  DCSP  DCSP  DCSP urlkw.update(route_kw) DCNL DCSP  DCSP return self.route_url(route_name, *elements, **urlkw) DCNL DCSP (app_url, qs, anchor) = parse_url_overrides(self, urlkw) DCNL DCSP resource_url = None DCNL DCSP local_url = getattr(resource, '__resource_url__', None) DCNL DCSP if (local_url is not None): DCNL DCSP  DCSP d = dict(virtual_path=virtual_path, physical_path=url_adapter.physical_path, app_url=app_url) DCNL DCSP  DCSP resource_url = local_url(self, d) DCNL DCSP if (resource_url is None): DCNL DCSP  DCSP resource_url = (app_url + virtual_path) DCNL DCSP if elements: DCNL DCSP  DCSP suffix = _join_elements(elements) DCNL DCSP else: DCNL DCSP  DCSP suffix = '' DCNL DCSP return (((resource_url + suffix) + qs) + anchor)
def resource_path(self, resource, *elements, **kw): DCNL DCSP kw['app_url'] = self.script_name DCNL DCSP return self.resource_url(resource, *elements, **kw)
def static_url(self, path, **kw): DCNL DCSP if (not os.path.isabs(path)): DCNL DCSP  DCSP if (':' not in path): DCNL DCSP  DCSP  DCSP package = caller_package() DCNL DCSP  DCSP  DCSP path = ('%s:%s' % (package.__name__, path)) DCNL DCSP try: DCNL DCSP  DCSP reg = self.registry DCNL DCSP except AttributeError: DCNL DCSP  DCSP reg = get_current_registry() DCNL DCSP info = reg.queryUtility(IStaticURLInfo) DCNL DCSP if (info is None): DCNL DCSP  DCSP raise ValueError(('No DCSP static DCSP URL DCSP definition DCSP matching DCSP %s' % path)) DCNL DCSP return info.generate(path, self, **kw)
def static_path(self, path, **kw): DCNL DCSP if (not os.path.isabs(path)): DCNL DCSP  DCSP if (':' not in path): DCNL DCSP  DCSP  DCSP package = caller_package() DCNL DCSP  DCSP  DCSP path = ('%s:%s' % (package.__name__, path)) DCNL DCSP kw['_app_url'] = self.script_name DCNL DCSP return self.static_url(path, **kw)
def current_route_url(self, *elements, **kw): DCNL DCSP if ('_route_name' in kw): DCNL DCSP  DCSP route_name = kw.pop('_route_name') DCNL DCSP else: DCNL DCSP  DCSP route = getattr(self, 'matched_route', None) DCNL DCSP  DCSP route_name = getattr(route, 'name', None) DCNL DCSP  DCSP if (route_name is None): DCNL DCSP  DCSP  DCSP raise ValueError('Current DCSP request DCSP matches DCSP no DCSP route') DCNL DCSP if ('_query' not in kw): DCNL DCSP  DCSP kw['_query'] = self.GET DCNL DCSP newkw = {} DCNL DCSP newkw.update(self.matchdict) DCNL DCSP newkw.update(kw) DCNL DCSP return self.route_url(route_name, *elements, **newkw)
def current_route_path(self, *elements, **kw): DCNL DCSP kw['_app_url'] = self.script_name DCNL DCSP return self.current_route_url(*elements, **kw)
def add_response_callback(self, callback): DCNL DCSP self.response_callbacks.append(callback)
def add_finished_callback(self, callback): DCNL DCSP self.finished_callbacks.append(callback)
@reify DCNL def session(self): DCNL DCSP factory = self.registry.queryUtility(ISessionFactory) DCNL DCSP if (factory is None): DCNL DCSP  DCSP raise AttributeError('No DCSP session DCSP factory DCSP registered DCSP (see DCSP the DCSP Sessions DCSP chapter DCSP of DCSP the DCSP Pyramid DCSP documentation)') DCNL DCSP return factory(self)
@reify DCNL def response(self): DCNL DCSP response_factory = _get_response_factory(self.registry) DCNL DCSP return response_factory(self)
def is_response(self, ob): DCNL DCSP if (ob.__class__ is Response): DCNL DCSP  DCSP return True DCNL DCSP registry = self.registry DCNL DCSP adapted = registry.queryAdapterOrSelf(ob, IResponse) DCNL DCSP if (adapted is None): DCNL DCSP  DCSP return False DCNL DCSP return (adapted is ob)
@classmethod DCNL def create_new(cls): DCNL DCSP if cls._is_abstract(): DCNL DCSP  DCSP raise Exception(('Tried DCSP to DCSP directly DCSP create DCSP a DCSP job DCSP using DCSP the DCSP abstract DCSP base DCSP manager DCSP class DCSP %s, DCSP which DCSP is DCSP not DCSP allowed.' % cls.__name__)) DCNL DCSP def _create_new_job(): DCNL DCSP  DCSP job_id = job_models.JobModel.get_new_id(cls.__name__) DCNL DCSP  DCSP job_models.JobModel(id=job_id, job_type=cls.__name__).put() DCNL DCSP  DCSP return job_id DCNL DCSP return transaction_services.run_in_transaction(_create_new_job)
@classmethod DCNL def enqueue(cls, job_id, additional_job_params=None): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_valid_transition(job_id, model.status_code, STATUS_CODE_QUEUED) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP cls._pre_enqueue_hook(job_id) DCNL DCSP cls._real_enqueue(job_id, additional_job_params) DCNL DCSP model.status_code = STATUS_CODE_QUEUED DCNL DCSP model.time_queued_msec = utils.get_current_time_in_millisecs() DCNL DCSP model.additional_job_params = additional_job_params DCNL DCSP model.put() DCNL DCSP cls._post_enqueue_hook(job_id)
@classmethod DCNL def register_start(cls, job_id, metadata=None): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_valid_transition(job_id, model.status_code, STATUS_CODE_STARTED) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP cls._pre_start_hook(job_id) DCNL DCSP model.metadata = metadata DCNL DCSP model.status_code = STATUS_CODE_STARTED DCNL DCSP model.time_started_msec = utils.get_current_time_in_millisecs() DCNL DCSP model.put() DCNL DCSP cls._post_start_hook(job_id)
@classmethod DCNL def register_completion(cls, job_id, output_list): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_valid_transition(job_id, model.status_code, STATUS_CODE_COMPLETED) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP model.status_code = STATUS_CODE_COMPLETED DCNL DCSP model.time_finished_msec = utils.get_current_time_in_millisecs() DCNL DCSP model.output = cls._compress_output_list(output_list) DCNL DCSP model.put() DCNL DCSP cls._post_completed_hook(job_id)
@classmethod DCNL def _compress_output_list(cls, output_list, test_only_max_output_len_chars=None): DCNL DCSP _MAX_OUTPUT_LEN_CHARS = 900000 DCNL DCSP class _OrderedCounter(collections.Counter, collections.OrderedDict, ): DCNL DCSP  DCSP 'Counter DCSP that DCSP remembers DCSP the DCSP order DCSP elements DCSP are DCSP first DCSP encountered.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP We DCSP use DCSP this DCSP class DCSP so DCSP that DCSP our DCSP tests DCSP can DCSP rely DCSP on DCSP deterministic\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ordering, DCSP instead DCSP of DCSP simply DCSP using DCSP `collections.Counter` DCSP which DCSP has\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP non-deterministic DCSP ordering.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP pass DCNL DCSP counter = _OrderedCounter((str(output) for output in output_list)) DCNL DCSP output_str_list = [(output_str if (count == 1) else ('(%dx) DCSP %s' % (count, output_str))) for (output_str, count) in counter.iteritems()] DCNL DCSP remaining_len = (_MAX_OUTPUT_LEN_CHARS if (test_only_max_output_len_chars is None) else test_only_max_output_len_chars) DCNL DCSP for (idx, output_str) in enumerate(output_str_list): DCNL DCSP  DCSP remaining_len -= len(output_str) DCNL DCSP  DCSP if (remaining_len < 0): DCNL DCSP  DCSP  DCSP kept_str = output_str[:remaining_len] DCNL DCSP  DCSP  DCSP output_str_list[idx:] = [(('%s DCSP <TRUNCATED>' % kept_str) if kept_str else '<TRUNCATED>')] DCNL DCSP  DCSP  DCSP break DCNL DCSP return output_str_list
@classmethod DCNL def register_failure(cls, job_id, error): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_valid_transition(job_id, model.status_code, STATUS_CODE_FAILED) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP model.status_code = STATUS_CODE_FAILED DCNL DCSP model.time_finished_msec = utils.get_current_time_in_millisecs() DCNL DCSP model.error = error DCNL DCSP model.put() DCNL DCSP cls._post_failure_hook(job_id)
@classmethod DCNL def cancel(cls, job_id, user_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_valid_transition(job_id, model.status_code, STATUS_CODE_CANCELED) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP cancel_message = ('Canceled DCSP by DCSP %s' % (user_id or 'system')) DCNL DCSP cls._pre_cancel_hook(job_id, cancel_message) DCNL DCSP model.status_code = STATUS_CODE_CANCELED DCNL DCSP model.time_finished_msec = utils.get_current_time_in_millisecs() DCNL DCSP model.error = cancel_message DCNL DCSP model.put() DCNL DCSP cls._post_cancel_hook(job_id, cancel_message)
@classmethod DCNL def is_active(cls, job_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP return (model.status_code in [STATUS_CODE_QUEUED, STATUS_CODE_STARTED])
@classmethod DCNL def has_finished(cls, job_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP return (model.status_code in [STATUS_CODE_COMPLETED, STATUS_CODE_FAILED])
@classmethod DCNL def cancel_all_unfinished_jobs(cls, user_id): DCNL DCSP unfinished_job_models = job_models.JobModel.get_unfinished_jobs(cls.__name__) DCNL DCSP for model in unfinished_job_models: DCNL DCSP  DCSP cls.cancel(model.id, user_id)
@classmethod DCNL def _real_enqueue(cls, job_id, additional_job_params): DCNL DCSP raise NotImplementedError('Subclasses DCSP of DCSP BaseJobManager DCSP should DCSP implement DCSP _real_enqueue().')
@classmethod DCNL def get_status_code(cls, job_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP return model.status_code
@classmethod DCNL def get_time_queued_msec(cls, job_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP return model.time_queued_msec
@classmethod DCNL def get_time_started_msec(cls, job_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP return model.time_started_msec
@classmethod DCNL def get_time_finished_msec(cls, job_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP return model.time_finished_msec
@classmethod DCNL def get_metadata(cls, job_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP return model.metadata
@classmethod DCNL def get_output(cls, job_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP return model.output
@classmethod DCNL def get_error(cls, job_id): DCNL DCSP model = job_models.JobModel.get(job_id, strict=True) DCNL DCSP cls._require_correct_job_type(model.job_type) DCNL DCSP return model.error
@classmethod DCNL def _require_valid_transition(cls, job_id, old_status_code, new_status_code): DCNL DCSP valid_new_status_codes = VALID_STATUS_CODE_TRANSITIONS[old_status_code] DCNL DCSP if (new_status_code not in valid_new_status_codes): DCNL DCSP  DCSP raise Exception(('Invalid DCSP status DCSP code DCSP change DCSP for DCSP job DCSP %s: DCSP from DCSP %s DCSP to DCSP %s' % (job_id, old_status_code, new_status_code)))
@classmethod DCNL def _require_correct_job_type(cls, job_type): DCNL DCSP if (job_type != cls.__name__): DCNL DCSP  DCSP raise Exception(('Invalid DCSP job DCSP type DCSP %s DCSP for DCSP class DCSP %s' % (job_type, cls.__name__)))
@classmethod DCNL def _run(cls, additional_job_params): DCNL DCSP raise NotImplementedError
@classmethod DCNL def _run_job(cls, job_id, additional_job_params): DCNL DCSP logging.info(('Job DCSP %s DCSP started DCSP at DCSP %s' % (job_id, utils.get_current_time_in_millisecs()))) DCNL DCSP cls.register_start(job_id) DCNL DCSP try: DCNL DCSP  DCSP result = cls._run(additional_job_params) DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.error(traceback.format_exc()) DCNL DCSP  DCSP logging.error(('Job DCSP %s DCSP failed DCSP at DCSP %s' % (job_id, utils.get_current_time_in_millisecs()))) DCNL DCSP  DCSP cls.register_failure(job_id, ('%s\n%s' % (unicode(e), traceback.format_exc()))) DCNL DCSP  DCSP raise taskqueue_services.PermanentTaskFailure(('Task DCSP failed: DCSP %s\n%s' % (unicode(e), traceback.format_exc()))) DCNL DCSP cls.register_completion(job_id, [result]) DCNL DCSP logging.info(('Job DCSP %s DCSP completed DCSP at DCSP %s' % (job_id, utils.get_current_time_in_millisecs())))
@classmethod DCNL def _real_enqueue(cls, job_id, additional_job_params): DCNL DCSP taskqueue_services.defer(cls._run_job, job_id, additional_job_params)
def run(self, job_id, job_class_str, kwargs): DCNL DCSP job_class = mapreduce_util.for_name(job_class_str) DCNL DCSP job_class.register_start(job_id, metadata={job_class._OUTPUT_KEY_ROOT_PIPELINE_ID: self.root_pipeline_id}) DCNL DCSP output = (yield mapreduce_pipeline.MapreducePipeline(**kwargs)) DCNL DCSP (yield StoreMapReduceResults(job_id, job_class_str, output))
def finalized(self): DCNL DCSP pass
def run(self, job_id, job_class_str, output): DCNL DCSP job_class = mapreduce_util.for_name(job_class_str) DCNL DCSP try: DCNL DCSP  DCSP iterator = input_readers.GoogleCloudStorageInputReader(output, 0) DCNL DCSP  DCSP results_list = [] DCNL DCSP  DCSP for item_reader in iterator: DCNL DCSP  DCSP  DCSP for item in item_reader: DCNL DCSP  DCSP  DCSP  DCSP results_list.append(json.loads(item)) DCNL DCSP  DCSP job_class.register_completion(job_id, results_list) DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.error(traceback.format_exc()) DCNL DCSP  DCSP logging.error(('Job DCSP %s DCSP failed DCSP at DCSP %s' % (job_id, utils.get_current_time_in_millisecs()))) DCNL DCSP  DCSP job_class.register_failure(job_id, ('%s\n%s' % (unicode(e), traceback.format_exc())))
def write(self, data): DCNL DCSP super(GoogleCloudStorageConsistentJsonOutputWriter, self).write(('%s\n' % json.dumps(data)))
@staticmethod DCNL def get_mapper_param(param_name): DCNL DCSP mapper_params = context.get().mapreduce_spec.mapper.params DCNL DCSP if (param_name not in mapper_params): DCNL DCSP  DCSP raise Exception(('Could DCSP not DCSP find DCSP %s DCSP in DCSP %s' % (param_name, mapper_params))) DCNL DCSP return context.get().mapreduce_spec.mapper.params[param_name]
@classmethod DCNL def entity_classes_to_map_over(cls): DCNL DCSP raise NotImplementedError('Classes DCSP derived DCSP from DCSP BaseMapReduceJobManager DCSP must DCSP implement DCSP entity_classes_to_map_over()')
@staticmethod DCNL def map(item): DCNL DCSP raise NotImplementedError('Classes DCSP derived DCSP from DCSP BaseMapReduceJobManager DCSP must DCSP implement DCSP map DCSP as DCSP a DCSP @staticmethod.')
@staticmethod DCNL def reduce(key, values): DCNL DCSP raise NotImplementedError('Classes DCSP derived DCSP from DCSP BaseMapReduceJobManager DCSP must DCSP implement DCSP reduce DCSP as DCSP a DCSP @staticmethod.')
@classmethod DCNL def _real_enqueue(cls, job_id, additional_job_params): DCNL DCSP entity_class_types = cls.entity_classes_to_map_over() DCNL DCSP entity_class_names = [('%s.%s' % (entity_class_type.__module__, entity_class_type.__name__)) for entity_class_type in entity_class_types] DCNL DCSP kwargs = {'job_name': job_id, 'mapper_spec': ('%s.%s.map' % (cls.__module__, cls.__name__)), 'reducer_spec': ('%s.%s.reduce' % (cls.__module__, cls.__name__)), 'input_reader_spec': 'core.jobs.MultipleDatastoreEntitiesInputReader', 'output_writer_spec': 'core.jobs.GoogleCloudStorageConsistentJsonOutputWriter', 'mapper_params': {MAPPER_PARAM_KEY_ENTITY_KINDS: entity_class_names, MAPPER_PARAM_KEY_QUEUED_TIME_MSECS: str(utils.get_current_time_in_millisecs())}, 'reducer_params': {'output_writer': {'bucket_name': app_identity.get_default_gcs_bucket_name(), 'content_type': 'text/plain', 'naming_format': 'mrdata/$name/$id/output-$num'}}} DCNL DCSP if (additional_job_params is not None): DCNL DCSP  DCSP for param_name in additional_job_params: DCNL DCSP  DCSP  DCSP if (param_name in kwargs['mapper_params']): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('Additional DCSP job DCSP param DCSP %s DCSP shadows DCSP an DCSP existing DCSP mapper DCSP param' % param_name)) DCNL DCSP  DCSP  DCSP kwargs['mapper_params'][param_name] = copy.deepcopy(additional_job_params[param_name]) DCNL DCSP mr_pipeline = MapReduceJobPipeline(job_id, ('%s.%s' % (cls.__module__, cls.__name__)), kwargs) DCNL DCSP mr_pipeline.start(base_path='/mapreduce/worker/pipeline')
@staticmethod DCNL def _entity_created_before_job_queued(entity): DCNL DCSP created_on_msec = utils.get_time_in_millisecs(entity.created_on) DCNL DCSP job_queued_msec = float(context.get().mapreduce_spec.mapper.params[MAPPER_PARAM_KEY_QUEUED_TIME_MSECS]) DCNL DCSP return (job_queued_msec >= created_on_msec)
@classmethod DCNL def from_json(cls, input_shard_state): DCNL DCSP return cls(input_readers.DatastoreInputReader.from_json(input_shard_state[cls._READER_LIST_PARAM]))
def to_json(self): DCNL DCSP return {self._READER_LIST_PARAM: self._reader_list.to_json()}
@classmethod DCNL def split_input(cls, mapper_spec): DCNL DCSP params = mapper_spec.params DCNL DCSP entity_kinds = params.get(cls._ENTITY_KINDS_PARAM) DCNL DCSP readers_list = [] DCNL DCSP for entity_kind in entity_kinds: DCNL DCSP  DCSP new_mapper_spec = copy.deepcopy(mapper_spec) DCNL DCSP  DCSP new_mapper_spec.params['entity_kind'] = entity_kind DCNL DCSP  DCSP readers_list.append(input_readers.DatastoreInputReader.split_input(new_mapper_spec)) DCNL DCSP inputs = [] DCNL DCSP for reader_list in readers_list: DCNL DCSP  DCSP for reader in reader_list: DCNL DCSP  DCSP  DCSP inputs.append(MultipleDatastoreEntitiesInputReader(reader)) DCNL DCSP return inputs
@classmethod DCNL def validate(cls, unused_mapper_spec): DCNL DCSP return True
@classmethod DCNL def _get_continuous_computation_class(cls): DCNL DCSP raise NotImplementedError('Subclasses DCSP of DCSP BaseMapReduceJobManagerForContinuousComputations DCSP must DCSP implement DCSP the DCSP _get_continuous_computation_class() DCSP method.')
@staticmethod DCNL def _get_job_queued_msec(): DCNL DCSP return float(context.get().mapreduce_spec.mapper.params[MAPPER_PARAM_KEY_QUEUED_TIME_MSECS])
@staticmethod DCNL def _entity_created_before_job_queued(entity): DCNL DCSP created_on_msec = utils.get_time_in_millisecs(entity.created_on) DCNL DCSP job_queued_msec = float(context.get().mapreduce_spec.mapper.params[MAPPER_PARAM_KEY_QUEUED_TIME_MSECS]) DCNL DCSP return (job_queued_msec >= created_on_msec)
@classmethod DCNL def get_realtime_id(cls, layer_index, raw_entity_id): DCNL DCSP return ('%s:%s' % (layer_index, raw_entity_id))
@classmethod DCNL def delete_layer(cls, layer_index, latest_created_on_datetime): DCNL DCSP query = cls.query().filter((cls.realtime_layer == layer_index)).filter((cls.created_on < latest_created_on_datetime)) DCNL DCSP ndb.delete_multi(query.iter(keys_only=True))
@classmethod DCNL def _is_valid_realtime_id(cls, realtime_id): DCNL DCSP return (realtime_id.startswith('0:') or realtime_id.startswith('1:'))
@classmethod DCNL def get(cls, entity_id, strict=True): DCNL DCSP if (not cls._is_valid_realtime_id(entity_id)): DCNL DCSP  DCSP raise ValueError(('Invalid DCSP realtime DCSP id: DCSP %s' % entity_id)) DCNL DCSP return super(BaseRealtimeDatastoreClassForContinuousComputations, cls).get(entity_id, strict=strict)
def put(self): DCNL DCSP if ((self.realtime_layer is None) or (str(self.realtime_layer) != self.id[0])): DCNL DCSP  DCSP raise Exception(('Realtime DCSP layer DCSP %s DCSP does DCSP not DCSP match DCSP realtime DCSP id DCSP %s' % (self.realtime_layer, self.id))) DCNL DCSP return super(BaseRealtimeDatastoreClassForContinuousComputations, self).put()
@classmethod DCNL def get_event_types_listened_to(cls): DCNL DCSP raise NotImplementedError('Subclasses DCSP of DCSP BaseContinuousComputationManager DCSP must DCSP implement DCSP get_event_types_listened_to(). DCSP This DCSP method DCSP should DCSP return DCSP a DCSP list DCSP of DCSP strings, DCSP each DCSP representing DCSP an DCSP event DCSP type DCSP that DCSP this DCSP class DCSP subscribes DCSP to.')
@classmethod DCNL def _get_realtime_datastore_class(cls): DCNL DCSP raise NotImplementedError('Subclasses DCSP of DCSP BaseContinuousComputationManager DCSP must DCSP implement DCSP _get_realtime_datastore_class(). DCSP This DCSP method DCSP should DCSP return DCSP the DCSP datastore DCSP class DCSP to DCSP be DCSP used DCSP by DCSP the DCSP realtime DCSP layer.')
@classmethod DCNL def _get_batch_job_manager_class(cls): DCNL DCSP raise NotImplementedError('Subclasses DCSP of DCSP BaseContinuousComputationManager DCSP must DCSP implement DCSP _get_batch_job_manager_class(). DCSP This DCSP method DCSP should DCSP return DCSP themanager DCSP class DCSP for DCSP the DCSP continuously-running DCSP batch DCSP job.')
@classmethod DCNL def _handle_incoming_event(cls, active_realtime_layer, event_type, *args, **kwargs): DCNL DCSP raise NotImplementedError('Subclasses DCSP of DCSP BaseContinuousComputationManager DCSP must DCSP implement DCSP _handle_incoming_event(...). DCSP Please DCSP check DCSP the DCSP docstring DCSP of DCSP this DCSP method DCSP in DCSP jobs.BaseContinuousComputationManager DCSP for DCSP important DCSP developer DCSP information.')
@classmethod DCNL def _get_active_realtime_index(cls): DCNL DCSP def _get_active_realtime_index_transactional(): DCNL DCSP  DCSP cc_model = job_models.ContinuousComputationModel.get(cls.__name__, strict=False) DCNL DCSP  DCSP if (cc_model is None): DCNL DCSP  DCSP  DCSP cc_model = job_models.ContinuousComputationModel(id=cls.__name__) DCNL DCSP  DCSP  DCSP cc_model.put() DCNL DCSP  DCSP return cc_model.active_realtime_layer_index DCNL DCSP return transaction_services.run_in_transaction(_get_active_realtime_index_transactional)
@classmethod DCNL def get_active_realtime_layer_id(cls, entity_id): DCNL DCSP return cls._get_realtime_datastore_class().get_realtime_id(cls._get_active_realtime_index(), entity_id)
@classmethod DCNL def get_multi_active_realtime_layer_ids(cls, entity_ids): DCNL DCSP realtime_datastore_class = cls._get_realtime_datastore_class() DCNL DCSP active_realtime_index = cls._get_active_realtime_index() DCNL DCSP return [realtime_datastore_class.get_realtime_id(active_realtime_index, entity_id) for entity_id in entity_ids]
@classmethod DCNL def _switch_active_realtime_class(cls): DCNL DCSP def _switch_active_realtime_class_transactional(): DCNL DCSP  DCSP cc_model = job_models.ContinuousComputationModel.get(cls.__name__) DCNL DCSP  DCSP cc_model.active_realtime_layer_index = (1 - cc_model.active_realtime_layer_index) DCNL DCSP  DCSP cc_model.put() DCNL DCSP transaction_services.run_in_transaction(_switch_active_realtime_class_transactional)
@classmethod DCNL def _clear_inactive_realtime_layer(cls, latest_created_on_datetime): DCNL DCSP inactive_realtime_index = (1 - cls._get_active_realtime_index()) DCNL DCSP cls._get_realtime_datastore_class().delete_layer(inactive_realtime_index, latest_created_on_datetime)
@classmethod DCNL def _kickoff_batch_job(cls): DCNL DCSP if job_models.JobModel.do_unfinished_jobs_exist(cls.__name__): DCNL DCSP  DCSP logging.error(('Tried DCSP to DCSP start DCSP a DCSP new DCSP batch DCSP job DCSP of DCSP type DCSP %s DCSP while DCSP an DCSP existing DCSP job DCSP was DCSP still DCSP running DCSP ' % cls.__name__)) DCNL DCSP  DCSP return DCNL DCSP job_manager = cls._get_batch_job_manager_class() DCNL DCSP job_id = job_manager.create_new() DCNL DCSP job_manager.enqueue(job_id)
@classmethod DCNL def _register_end_of_batch_job_and_return_status(cls): DCNL DCSP def _register_end_of_batch_job_transactional(): DCNL DCSP  DCSP "Transactionally DCSP change DCSP the DCSP computation's DCSP status DCSP when DCSP a DCSP batch DCSP job\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ends.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP cc_model = job_models.ContinuousComputationModel.get(cls.__name__) DCNL DCSP  DCSP if (cc_model.status_code == job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_STOPPING): DCNL DCSP  DCSP  DCSP cc_model.status_code = job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_IDLE DCNL DCSP  DCSP  DCSP cc_model.put() DCNL DCSP  DCSP return cc_model.status_code DCNL DCSP return transaction_services.run_in_transaction(_register_end_of_batch_job_transactional)
@classmethod DCNL def get_status_code(cls): DCNL DCSP return job_models.ContinuousComputationModel.get(cls.__name__).status_code
@classmethod DCNL def start_computation(cls): DCNL DCSP def _start_computation_transactional(): DCNL DCSP  DCSP 'Transactional DCSP implementation DCSP for DCSP marking DCSP a DCSP continuous\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP computation DCSP as DCSP started.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP cc_model = job_models.ContinuousComputationModel.get(cls.__name__, strict=False) DCNL DCSP  DCSP if (cc_model is None): DCNL DCSP  DCSP  DCSP cc_model = job_models.ContinuousComputationModel(id=cls.__name__) DCNL DCSP  DCSP if (cc_model.status_code != job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_IDLE): DCNL DCSP  DCSP  DCSP raise Exception(('Attempted DCSP to DCSP start DCSP computation DCSP %s, DCSP which DCSP is DCSP already DCSP running.' % cls.__name__)) DCNL DCSP  DCSP cc_model.status_code = job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_RUNNING DCNL DCSP  DCSP cc_model.last_started_msec = utils.get_current_time_in_millisecs() DCNL DCSP  DCSP cc_model.put() DCNL DCSP transaction_services.run_in_transaction(_start_computation_transactional) DCNL DCSP cls._clear_inactive_realtime_layer(datetime.datetime.utcnow()) DCNL DCSP cls._kickoff_batch_job()
@classmethod DCNL def stop_computation(cls, user_id): DCNL DCSP do_unfinished_jobs_exist = job_models.JobModel.do_unfinished_jobs_exist(cls._get_batch_job_manager_class().__name__) DCNL DCSP def _stop_computation_transactional(): DCNL DCSP  DCSP 'Transactional DCSP implementation DCSP for DCSP marking DCSP a DCSP continuous\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP computation DCSP as DCSP stopping/idle.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP cc_model = job_models.ContinuousComputationModel.get(cls.__name__) DCNL DCSP  DCSP new_status_code = (job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_STOPPING if do_unfinished_jobs_exist else job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_IDLE) DCNL DCSP  DCSP cc_model.status_code = new_status_code DCNL DCSP  DCSP cc_model.last_stopped_msec = utils.get_current_time_in_millisecs() DCNL DCSP  DCSP cc_model.put() DCNL DCSP transaction_services.run_in_transaction(_stop_computation_transactional) DCNL DCSP if do_unfinished_jobs_exist: DCNL DCSP  DCSP unfinished_job_models = job_models.JobModel.get_unfinished_jobs(cls._get_batch_job_manager_class().__name__) DCNL DCSP  DCSP for job_model in unfinished_job_models: DCNL DCSP  DCSP  DCSP cls._get_batch_job_manager_class().cancel(job_model.id, user_id)
@classmethod DCNL def on_incoming_event(cls, event_type, *args, **kwargs): DCNL DCSP realtime_layers = [0, 1] DCNL DCSP for layer in realtime_layers: DCNL DCSP  DCSP cls._handle_incoming_event(layer, event_type, *args, **kwargs)
@classmethod DCNL def _process_job_completion_and_return_status(cls): DCNL DCSP cls._switch_active_realtime_class() DCNL DCSP cls._clear_inactive_realtime_layer(datetime.datetime.utcnow()) DCNL DCSP def _update_last_finished_time_transactional(): DCNL DCSP  DCSP cc_model = job_models.ContinuousComputationModel.get(cls.__name__) DCNL DCSP  DCSP cc_model.last_finished_msec = utils.get_current_time_in_millisecs() DCNL DCSP  DCSP cc_model.put() DCNL DCSP transaction_services.run_in_transaction(_update_last_finished_time_transactional) DCNL DCSP return cls._register_end_of_batch_job_and_return_status()
@classmethod DCNL def _kickoff_batch_job_after_previous_one_ends(cls): DCNL DCSP cls._kickoff_batch_job()
@classmethod DCNL def on_batch_job_completion(cls): DCNL DCSP job_status = cls._process_job_completion_and_return_status() DCNL DCSP if (job_status == job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_RUNNING): DCNL DCSP  DCSP cls._kickoff_batch_job_after_previous_one_ends()
@classmethod DCNL def on_batch_job_canceled(cls): DCNL DCSP logging.info(('Job DCSP %s DCSP canceled.' % cls.__name__)) DCNL DCSP job_status = cls._register_end_of_batch_job_and_return_status() DCNL DCSP if (job_status != job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_IDLE): DCNL DCSP  DCSP logging.error(('Batch DCSP job DCSP for DCSP computation DCSP %s DCSP canceled DCSP but DCSP status DCSP code DCSP not DCSP set DCSP to DCSP idle.' % cls.__name__))
@classmethod DCNL def on_batch_job_failure(cls): DCNL DCSP logging.error(('Job DCSP %s DCSP failed.' % cls.__name__)) DCNL DCSP job_status = cls._register_end_of_batch_job_and_return_status() DCNL DCSP if (job_status == job_models.CONTINUOUS_COMPUTATION_STATUS_CODE_RUNNING): DCNL DCSP  DCSP cls._kickoff_batch_job_after_previous_one_ends()
@classmethod DCNL def entity_classes_to_map_over(cls): DCNL DCSP return [mapreduce_model.MapreduceState, mapreduce_model.ShardState]
@staticmethod DCNL def map(item): DCNL DCSP max_start_time_msec = JobCleanupManager.get_mapper_param(MAPPER_PARAM_MAX_START_TIME_MSEC) DCNL DCSP if isinstance(item, mapreduce_model.MapreduceState): DCNL DCSP  DCSP if ((item.result_status == 'success') and (utils.get_time_in_millisecs(item.start_time) < max_start_time_msec)): DCNL DCSP  DCSP  DCSP item.delete() DCNL DCSP  DCSP  DCSP (yield ('mr_state_deleted', 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield ('mr_state_remaining', 1)) DCNL DCSP if isinstance(item, mapreduce_model.ShardState): DCNL DCSP  DCSP if ((item.result_status == 'success') and (utils.get_time_in_millisecs(item.update_time) < max_start_time_msec)): DCNL DCSP  DCSP  DCSP item.delete() DCNL DCSP  DCSP  DCSP (yield ('shard_state_deleted', 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield ('shard_state_remaining', 1))
@staticmethod DCNL def reduce(key, stringified_values): DCNL DCSP values = [ast.literal_eval(v) for v in stringified_values] DCNL DCSP if key.endswith('_deleted'): DCNL DCSP  DCSP logging.warning(('Delete DCSP count: DCSP %s DCSP entities DCSP (%s)' % (sum(values), key))) DCNL DCSP else: DCNL DCSP  DCSP logging.warning(('Entities DCSP remaining DCSP count: DCSP %s DCSP entities DCSP (%s)' % (sum(values), key)))
@classmethod DCNL def import_models(cls, model_names): DCNL DCSP returned_models = [] DCNL DCSP for name in model_names: DCNL DCSP  DCSP if (name == NAMES.activity): DCNL DCSP  DCSP  DCSP from core.storage.activity import gae_models as activity_models DCNL DCSP  DCSP  DCSP returned_models.append(activity_models) DCNL DCSP  DCSP elif (name == NAMES.audit): DCNL DCSP  DCSP  DCSP from core.storage.audit import gae_models as audit_models DCNL DCSP  DCSP  DCSP returned_models.append(audit_models) DCNL DCSP  DCSP elif (name == NAMES.base_model): DCNL DCSP  DCSP  DCSP from core.storage.base_model import gae_models as base_models DCNL DCSP  DCSP  DCSP returned_models.append(base_models) DCNL DCSP  DCSP elif (name == NAMES.classifier): DCNL DCSP  DCSP  DCSP from core.storage.classifier import gae_models as classifier_data_models DCNL DCSP  DCSP  DCSP returned_models.append(classifier_data_models) DCNL DCSP  DCSP elif (name == NAMES.collection): DCNL DCSP  DCSP  DCSP from core.storage.collection import gae_models as collection_models DCNL DCSP  DCSP  DCSP returned_models.append(collection_models) DCNL DCSP  DCSP elif (name == NAMES.config): DCNL DCSP  DCSP  DCSP from core.storage.config import gae_models as config_models DCNL DCSP  DCSP  DCSP returned_models.append(config_models) DCNL DCSP  DCSP elif (name == NAMES.email): DCNL DCSP  DCSP  DCSP from core.storage.email import gae_models as email_models DCNL DCSP  DCSP  DCSP returned_models.append(email_models) DCNL DCSP  DCSP elif (name == NAMES.exploration): DCNL DCSP  DCSP  DCSP from core.storage.exploration import gae_models as exp_models DCNL DCSP  DCSP  DCSP returned_models.append(exp_models) DCNL DCSP  DCSP elif (name == NAMES.feedback): DCNL DCSP  DCSP  DCSP from core.storage.feedback import gae_models as feedback_models DCNL DCSP  DCSP  DCSP returned_models.append(feedback_models) DCNL DCSP  DCSP elif (name == NAMES.file): DCNL DCSP  DCSP  DCSP from core.storage.file import gae_models as file_models DCNL DCSP  DCSP  DCSP returned_models.append(file_models) DCNL DCSP  DCSP elif (name == NAMES.job): DCNL DCSP  DCSP  DCSP from core.storage.job import gae_models as job_models DCNL DCSP  DCSP  DCSP returned_models.append(job_models) DCNL DCSP  DCSP elif (name == NAMES.recommendations): DCNL DCSP  DCSP  DCSP from core.storage.recommendations import gae_models as recommendations_models DCNL DCSP  DCSP  DCSP returned_models.append(recommendations_models) DCNL DCSP  DCSP elif (name == NAMES.statistics): DCNL DCSP  DCSP  DCSP from core.storage.statistics import gae_models as statistics_models DCNL DCSP  DCSP  DCSP returned_models.append(statistics_models) DCNL DCSP  DCSP elif (name == NAMES.user): DCNL DCSP  DCSP  DCSP from core.storage.user import gae_models as user_models DCNL DCSP  DCSP  DCSP returned_models.append(user_models) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP model DCSP name: DCSP %s' % name)) DCNL DCSP return tuple(returned_models)
@classmethod DCNL def import_transaction_services(cls): DCNL DCSP from core.platform.transactions import gae_transaction_services DCNL DCSP return gae_transaction_services
@classmethod DCNL def import_current_user_services(cls): DCNL DCSP from core.platform.users import gae_current_user_services DCNL DCSP return gae_current_user_services
@classmethod DCNL def import_datastore_services(cls): DCNL DCSP from core.platform.datastore import gae_datastore_services DCNL DCSP return gae_datastore_services
@classmethod DCNL def import_app_identity_services(cls): DCNL DCSP from core.platform.app_identity import gae_app_identity_services DCNL DCSP return gae_app_identity_services
@classmethod DCNL def import_email_services(cls): DCNL DCSP if (feconf.EMAIL_SERVICE_PROVIDER == feconf.EMAIL_SERVICE_PROVIDER_GAE): DCNL DCSP  DCSP from core.platform.email import gae_email_services DCNL DCSP  DCSP return gae_email_services DCNL DCSP elif (feconf.EMAIL_SERVICE_PROVIDER == feconf.EMAIL_SERVICE_PROVIDER_MAILGUN): DCNL DCSP  DCSP from core.platform.email import mailgun_email_services DCNL DCSP  DCSP return mailgun_email_services DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Invalid DCSP email DCSP service DCSP provider: DCSP %s' % feconf.EMAIL_SERVICE_PROVIDER))
@classmethod DCNL def import_memcache_services(cls): DCNL DCSP from core.platform.memcache import gae_memcache_services DCNL DCSP return gae_memcache_services
@classmethod DCNL def import_taskqueue_services(cls): DCNL DCSP from core.platform.taskqueue import gae_taskqueue_services DCNL DCSP return gae_taskqueue_services
@classmethod DCNL def import_search_services(cls): DCNL DCSP from core.platform.search import gae_search_services DCNL DCSP return gae_search_services
@classmethod DCNL def _get(cls): DCNL DCSP return cls._PLATFORM_MAPPING.get(feconf.PLATFORM)
@classmethod DCNL def import_models(cls, model_names): DCNL DCSP return cls._get().import_models(model_names)
@classmethod DCNL def import_current_user_services(cls): DCNL DCSP return cls._get().import_current_user_services()
@classmethod DCNL def import_datastore_services(cls): DCNL DCSP return cls._get().import_datastore_services()
@classmethod DCNL def import_transaction_services(cls): DCNL DCSP return cls._get().import_transaction_services()
@classmethod DCNL def import_app_identity_services(cls): DCNL DCSP return cls._get().import_app_identity_services()
@classmethod DCNL def import_email_services(cls): DCNL DCSP return cls._get().import_email_services()
@classmethod DCNL def import_memcache_services(cls): DCNL DCSP return cls._get().import_memcache_services()
@classmethod DCNL def import_taskqueue_services(cls): DCNL DCSP return cls._get().import_taskqueue_services()
@classmethod DCNL def import_search_services(cls): DCNL DCSP return cls._get().import_search_services()
def _get_put_error(self, num_res, transient=None): DCNL DCSP non_trans_code = search.OperationResult.INVALID_REQUEST DCNL DCSP trans_code = search.OperationResult.TRANSIENT_ERROR DCNL DCSP results = [search.PutResult(code=non_trans_code) for _ in range(num_res)] DCNL DCSP if (transient is not None): DCNL DCSP  DCSP results[transient] = search.PutResult(code=trans_code) DCNL DCSP return search.PutError('lol', results)
def _get_delete_error(self, num_res, transient=None): DCNL DCSP non_trans_code = search.OperationResult.INVALID_REQUEST DCNL DCSP trans_code = search.OperationResult.TRANSIENT_ERROR DCNL DCSP results = [search.DeleteResult(code=non_trans_code) for _ in range(num_res)] DCNL DCSP if (transient is not None): DCNL DCSP  DCSP results[transient] = search.PutResult(code=trans_code) DCNL DCSP return search.DeleteError('lol', results=results)
def test_create_new(self): DCNL DCSP job_id = DummyJobManager.create_new() DCNL DCSP self.assertTrue(job_id.startswith('DummyJob')) DCNL DCSP self.assertEqual(DummyJobManager.get_status_code(job_id), jobs.STATUS_CODE_NEW) DCNL DCSP self.assertIsNone(DummyJobManager.get_time_queued_msec(job_id)) DCNL DCSP self.assertIsNone(DummyJobManager.get_time_started_msec(job_id)) DCNL DCSP self.assertIsNone(DummyJobManager.get_time_finished_msec(job_id)) DCNL DCSP self.assertIsNone(DummyJobManager.get_metadata(job_id)) DCNL DCSP self.assertIsNone(DummyJobManager.get_output(job_id)) DCNL DCSP self.assertIsNone(DummyJobManager.get_error(job_id)) DCNL DCSP self.assertFalse(DummyJobManager.is_active(job_id)) DCNL DCSP self.assertFalse(DummyJobManager.has_finished(job_id))
def test_enqueue_job(self): DCNL DCSP job_id = DummyJobManager.create_new() DCNL DCSP DummyJobManager.enqueue(job_id) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(), 1) DCNL DCSP self.assertEqual(DummyJobManager.get_status_code(job_id), jobs.STATUS_CODE_QUEUED) DCNL DCSP self.assertIsNotNone(DummyJobManager.get_time_queued_msec(job_id)) DCNL DCSP self.assertIsNone(DummyJobManager.get_output(job_id))
def test_deferred_job_with_additional_params(self): DCNL DCSP job_id_1 = DummyJobManagerWithParams.create_new() DCNL DCSP DummyJobManagerWithParams.enqueue(job_id_1, additional_job_params={'random': 3, 'correct': 60}) DCNL DCSP job_id_2 = DummyJobManagerWithParams.create_new() DCNL DCSP DummyJobManagerWithParams.enqueue(job_id_2, additional_job_params={'random': 20, 'correct': 25}) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(), 2) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP self.assertTrue(DummyJobManagerWithParams.has_finished(job_id_1)) DCNL DCSP self.assertEqual(DummyJobManagerWithParams.get_output(job_id_1), ['60']) DCNL DCSP self.assertTrue(DummyJobManagerWithParams.has_finished(job_id_2)) DCNL DCSP self.assertEqual(DummyJobManagerWithParams.get_output(job_id_2), ['25'])
def test_status_code_transitions(self): DCNL DCSP job_id = DummyJobManager.create_new() DCNL DCSP DummyJobManager.enqueue(job_id) DCNL DCSP DummyJobManager.register_start(job_id) DCNL DCSP DummyJobManager.register_completion(job_id, ['output']) DCNL DCSP with self.assertRaisesRegexp(Exception, 'Invalid DCSP status DCSP code DCSP change'): DCNL DCSP  DCSP DummyJobManager.enqueue(job_id) DCNL DCSP with self.assertRaisesRegexp(Exception, 'Invalid DCSP status DCSP code DCSP change'): DCNL DCSP  DCSP DummyJobManager.register_completion(job_id, ['output']) DCNL DCSP with self.assertRaisesRegexp(Exception, 'Invalid DCSP status DCSP code DCSP change'): DCNL DCSP  DCSP DummyJobManager.register_failure(job_id, 'error')
def _populate_data(self): DCNL DCSP NumbersModel(number=1).put() DCNL DCSP NumbersModel(number=2).put() DCNL DCSP NumbersModel(number=1).put() DCNL DCSP NumbersModel(number=2).put()
def setUp(self): DCNL DCSP super(MapReduceJobIntegrationTests, self).setUp() DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('exp_id') DCNL DCSP exp_services.save_new_exploration('owner_id', exploration) DCNL DCSP self.process_and_flush_pending_tasks()
def setUp(self): DCNL DCSP super(TwoClassesMapReduceJobIntegrationTests, self).setUp() DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('exp_id') DCNL DCSP exp_services.save_new_exploration('owner_id', exploration) DCNL DCSP self.process_and_flush_pending_tasks()
@classmethod DCNL def _kickoff_batch_job_after_previous_one_ends(cls): DCNL DCSP pass
@classmethod DCNL def get_count(cls, exploration_id): DCNL DCSP mr_model = stats_models.ExplorationAnnotationsModel.get(exploration_id, strict=False) DCNL DCSP realtime_model = cls._get_realtime_datastore_class().get(cls.get_active_realtime_layer_id(exploration_id), strict=False) DCNL DCSP answer = 0 DCNL DCSP if (mr_model is not None): DCNL DCSP  DCSP answer += mr_model.num_starts DCNL DCSP if (realtime_model is not None): DCNL DCSP  DCSP answer += realtime_model.count DCNL DCSP return answer
def setUp(self): DCNL DCSP super(ContinuousComputationTests, self).setUp() DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration(self.EXP_ID) DCNL DCSP exp_services.save_new_exploration('owner_id', exploration) DCNL DCSP self.process_and_flush_pending_tasks()
def test_continuous_computation_workflow(self): DCNL DCSP with self.swap(jobs_registry, 'ALL_CONTINUOUS_COMPUTATION_MANAGERS', self.ALL_CC_MANAGERS_FOR_TESTS): DCNL DCSP  DCSP self.assertEqual(StartExplorationEventCounter.get_count(self.EXP_ID), 0) DCNL DCSP  DCSP event_services.StartExplorationEventHandler.record(self.EXP_ID, 1, feconf.DEFAULT_INIT_STATE_NAME, 'session_id', {}, feconf.PLAY_TYPE_NORMAL) DCNL DCSP  DCSP self.assertEqual(StartExplorationEventCounter.get_count(self.EXP_ID), 0) DCNL DCSP  DCSP self.assertEqual(self.count_jobs_in_taskqueue(), 1) DCNL DCSP  DCSP self.process_and_flush_pending_tasks() DCNL DCSP  DCSP self.assertEqual(self.count_jobs_in_taskqueue(), 0) DCNL DCSP  DCSP self.assertEqual(StartExplorationEventCounter.get_count(self.EXP_ID), 1) DCNL DCSP  DCSP self.assertEqual(StartExplorationRealtimeModel.get(('0:%s' % self.EXP_ID)).count, 1) DCNL DCSP  DCSP self.assertEqual(StartExplorationRealtimeModel.get(('1:%s' % self.EXP_ID)).count, 1) DCNL DCSP  DCSP with self.assertRaises(base_models.BaseModel.EntityNotFoundError): DCNL DCSP  DCSP  DCSP stats_models.ExplorationAnnotationsModel.get(self.EXP_ID) DCNL DCSP  DCSP StartExplorationEventCounter.start_computation() DCNL DCSP  DCSP self.assertEqual(StartExplorationRealtimeModel.get(('0:%s' % self.EXP_ID)).count, 1) DCNL DCSP  DCSP self.assertIsNone(StartExplorationRealtimeModel.get(('1:%s' % self.EXP_ID), strict=False)) DCNL DCSP  DCSP self.assertEqual(self.count_jobs_in_taskqueue(), 1) DCNL DCSP  DCSP self.process_and_flush_pending_tasks() DCNL DCSP  DCSP self.assertEqual(stats_models.ExplorationAnnotationsModel.get(self.EXP_ID).num_starts, 1) DCNL DCSP  DCSP self.assertEqual(StartExplorationEventCounter.get_count(self.EXP_ID), 1) DCNL DCSP  DCSP self.assertIsNone(StartExplorationRealtimeModel.get(('0:%s' % self.EXP_ID), strict=False)) DCNL DCSP  DCSP self.assertIsNone(StartExplorationRealtimeModel.get(('1:%s' % self.EXP_ID), strict=False))
def test_wrapper_calls_subclass_methods(self): DCNL DCSP order = [] DCNL DCSP testcase = self DCNL DCSP class MyWrapper(test_utils.FunctionWrapper, ): DCNL DCSP  DCSP def pre_call_hook(self, args): DCNL DCSP  DCSP  DCSP order.append('before') DCNL DCSP  DCSP  DCSP testcase.assertEqual(args.get('posarg'), 'foo') DCNL DCSP  DCSP  DCSP testcase.assertEqual(args.get('kwarg'), 'bar') DCNL DCSP  DCSP def post_call_hook(self, args, result): DCNL DCSP  DCSP  DCSP order.append('after') DCNL DCSP  DCSP  DCSP testcase.assertEqual(result, 'foobar') DCNL DCSP  DCSP  DCSP testcase.assertEqual(args.get('posarg'), 'foo') DCNL DCSP  DCSP  DCSP testcase.assertEqual(args.get('kwarg'), 'bar') DCNL DCSP def function(posarg, kwarg): DCNL DCSP  DCSP order.append('call') DCNL DCSP  DCSP return (posarg + kwarg) DCNL DCSP wrapped = MyWrapper(function) DCNL DCSP self.assertEqual(wrapped('foo', kwarg='bar'), 'foobar') DCNL DCSP self.assertEqual(order, ['before', 'call', 'after'])
def test_wrapper_calls_passed_method(self): DCNL DCSP data = {} DCNL DCSP class Klass(object, ): DCNL DCSP  DCSP def __init__(self, num1): DCNL DCSP  DCSP  DCSP self.num1 = num1 DCNL DCSP  DCSP def my_method(self, num2): DCNL DCSP  DCSP  DCSP data['value'] = (self.num1 + num2) DCNL DCSP  DCSP  DCSP return ((self.num1 + num2) * 2) DCNL DCSP wrapped = test_utils.FunctionWrapper(Klass.my_method) DCNL DCSP with self.swap(Klass, 'my_method', wrapped): DCNL DCSP  DCSP val = Klass('foo').my_method('bar') DCNL DCSP  DCSP self.assertEqual(val, 'foobarfoobar') DCNL DCSP  DCSP self.assertEqual(data.get('value'), 'foobar')
def test_wrapper_calls_passed_class_method(self): DCNL DCSP data = {} DCNL DCSP class Klass(object, ): DCNL DCSP  DCSP str_attr = 'foo' DCNL DCSP  DCSP @classmethod DCNL DCSP  DCSP def class_method(cls, num): DCNL DCSP  DCSP  DCSP data['value'] = (cls.str_attr + num) DCNL DCSP  DCSP  DCSP return ((cls.str_attr + num) * 2) DCNL DCSP wrapped = test_utils.FunctionWrapper(Klass.class_method) DCNL DCSP with self.swap(Klass, 'class_method', wrapped): DCNL DCSP  DCSP val = Klass.class_method('bar') DCNL DCSP  DCSP self.assertEqual(val, 'foobarfoobar') DCNL DCSP  DCSP self.assertEqual(data.get('value'), 'foobar')
def test_wrapper_calls_passed_static_method(self): DCNL DCSP data = {} DCNL DCSP class Klass(object, ): DCNL DCSP  DCSP @staticmethod DCNL DCSP  DCSP def static_method(num): DCNL DCSP  DCSP  DCSP data['value'] = num DCNL DCSP  DCSP  DCSP return (num * 2) DCNL DCSP wrapped = test_utils.FunctionWrapper(Klass.static_method) DCNL DCSP with self.swap(Klass, 'static_method', wrapped): DCNL DCSP  DCSP val = Klass.static_method('foobar') DCNL DCSP  DCSP self.assertEqual(val, 'foobarfoobar') DCNL DCSP  DCSP self.assertEqual(data.get('value'), 'foobar')
def _validate(self): DCNL DCSP if ((not self.page_session_stats) and (not self.page_session_timings)): DCNL DCSP  DCSP raise utils.ValidationError('Expected DCSP one DCSP of DCSP page_session_stats DCSP or DCSP page_session_timings DCSP to DCSP be DCSP provided.') DCNL DCSP if self.page_session_stats: DCNL DCSP  DCSP if ('log' not in self.page_session_stats): DCNL DCSP  DCSP  DCSP raise utils.ValidationError("Expected DCSP the DCSP page DCSP load DCSP stats DCSP to DCSP have DCSP a DCSP 'log' DCSP entry") DCNL DCSP  DCSP if ('entries' not in self.page_session_stats['log']): DCNL DCSP  DCSP  DCSP raise utils.ValidationError("Expected DCSP the DCSP log DCSP entry DCSP of DCSP the DCSP page DCSP load DCSP stats DCSP to DCSP include DCSP an DCSP additional DCSP 'entries' DCSP element") DCNL DCSP  DCSP for entry in self.page_session_stats['log']['entries']: DCNL DCSP  DCSP  DCSP if ('_error' in entry['response']): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP a DCSP valid DCSP server DCSP response, DCSP found DCSP server DCSP not DCSP reachable.') DCNL DCSP  DCSP if (self.get_request_count() == 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP log DCSP entry DCSP of DCSP the DCSP page DCSP load DCSP stats DCSP to DCSP include DCSP a DCSP positive DCSP number DCSP of DCSP requests.') DCNL DCSP  DCSP if (self.get_total_page_size_bytes() == 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP total DCSP size DCSP of DCSP a DCSP page DCSP including DCSP all DCSP its DCSP resources DCSP to DCSP be DCSP positive.') DCNL DCSP if self.page_session_timings: DCNL DCSP  DCSP for timing_prop in self.TIMING_PROPERTIES: DCNL DCSP  DCSP  DCSP if (timing_prop not in self.page_load_timings): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP the DCSP timing DCSP entry DCSP of DCSP the DCSP page DCSP load DCSP timings DCSP to DCSP include DCSP %s DCSP property' % timing_prop)) DCNL DCSP  DCSP if (self.get_page_load_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP page DCSP load DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_dom_ready_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP dom DCSP ready DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_request_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP request DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_ready_start_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP ready DCSP start DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_redirect_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP redirect DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_appcache_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP appcache DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_unload_event_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP unload DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_lookup_domain_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP domain DCSP lookup DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_connect_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP connect DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_init_dom_tree_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP init DCSP dom DCSP tree DCSP time DCSP to DCSP be DCSP positive.') DCNL DCSP  DCSP if (self.get_load_event_time_millisecs() < 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP the DCSP load DCSP time DCSP to DCSP be DCSP positive.')
def get_request_count(self): DCNL DCSP return len(self.page_session_stats['log']['entries'])
def get_total_page_size_bytes(self): DCNL DCSP total_size = 0 DCNL DCSP for entry in self.page_session_stats['log']['entries']: DCNL DCSP  DCSP total_size += int(entry['response']['bodySize']) DCNL DCSP return total_size
def get_page_load_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('loadEventEnd', 'fetchStart')
def get_dom_ready_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('domComplete', 'domInteractive')
def get_request_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('responseEnd', 'requestStart')
def get_ready_start_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('fetchStart', 'navigationStart')
def get_redirect_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('redirectEnd', 'redirectStart')
def get_appcache_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('domainLookupStart', 'fetchStart')
def get_unload_event_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('unloadEventEnd', 'unloadEventStart')
def get_lookup_domain_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('domainLookupEnd', 'domainLookupStart')
def get_connect_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('connectEnd', 'connectStart')
def get_init_dom_tree_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('domInteractive', 'responseEnd')
def get_load_event_time_millisecs(self): DCNL DCSP return self._get_duration_millisecs('loadEventEnd', 'loadEventStart')
def print_details(self): DCNL DCSP if self.page_session_stats: DCNL DCSP  DCSP print ('Total DCSP number DCSP of DCSP requests: DCSP %d' % self.get_request_count()) DCNL DCSP  DCSP print ('Total DCSP page DCSP size DCSP in DCSP bytes: DCSP %d' % self.get_total_page_size_bytes()) DCNL DCSP else: DCNL DCSP  DCSP print 'Page DCSP session DCSP stats DCSP are DCSP not DCSP available.' DCNL DCSP if self.page_session_timings: DCNL DCSP  DCSP print ('Page DCSP load DCSP time: DCSP %d' % self.get_page_load_time_millisecs()) DCNL DCSP  DCSP print ('Dom DCSP ready DCSP time: DCSP %d' % self.get_dom_ready_time_millisecs()) DCNL DCSP  DCSP print ('Request DCSP time: DCSP %d' % self.get_request_time_millisecs()) DCNL DCSP  DCSP print ('Ready DCSP start DCSP time: DCSP %d' % self.get_ready_start_time_millisecs()) DCNL DCSP  DCSP print ('Redirect DCSP time: DCSP %d' % self.get_redirect_time_millisecs()) DCNL DCSP  DCSP print ('Appcache DCSP time: DCSP %d' % self.get_appcache_time_millisecs()) DCNL DCSP  DCSP print ('Unload DCSP event DCSP time: DCSP %d' % self.get_unload_event_time_millisecs()) DCNL DCSP  DCSP print ('DNS DCSP query DCSP time: DCSP %d' % self.get_lookup_domain_time_millisecs()) DCNL DCSP  DCSP print ('TCP DCSP connection DCSP time: DCSP %d' % self.get_connect_time_millisecs()) DCNL DCSP  DCSP print ('Init DCSP domtree DCSP time: DCSP %d' % self.get_init_dom_tree_time_millisecs()) DCNL DCSP  DCSP print ('Load DCSP event DCSP time: DCSP %d' % self.get_load_event_time_millisecs()) DCNL DCSP else: DCNL DCSP  DCSP print 'Page DCSP session DCSP timings DCSP are DCSP not DCSP available.'
def get_average_page_load_time_millisecs(self): DCNL DCSP return (sum((item.get_page_load_time_millisecs() for item in self.page_metrics)) / len(self.page_metrics))
def get_average_dom_ready_time_millisecs(self): DCNL DCSP return (sum((item.get_dom_ready_time_millisecs() for item in self.page_metrics)) / len(self.page_metrics))
def get_average_request_time_millisecs(self): DCNL DCSP return (sum((item.get_request_time_millisecs() for item in self.page_metrics)) / len(self.page_metrics))
def __init__(self, browser, preload_option, username=None): DCNL DCSP if (browser in self.SUPPORTED_BROWSERS): DCNL DCSP  DCSP self.browser = browser DCNL DCSP else: DCNL DCSP  DCSP error_msg = ('Unsupported DCSP browser DCSP specified: DCSP %s' % browser) DCNL DCSP  DCSP raise ValueError(error_msg) DCNL DCSP self.exploration_url = None DCNL DCSP self.dev_appserver_login_cookie = None DCNL DCSP self.email = ('%s@example.com' % username) DCNL DCSP self.username = username DCNL DCSP driver = self._setup_driver() DCNL DCSP if (preload_option == test_config.PRELOAD_NONE): DCNL DCSP  DCSP pass DCNL DCSP elif (preload_option == test_config.PRELOAD_DO_LOGIN): DCNL DCSP  DCSP self._setup_login(driver) DCNL DCSP elif (preload_option == test_config.PRELOAD_CREATE_EXP): DCNL DCSP  DCSP self._create_exploration(driver) DCNL DCSP elif (preload_option == test_config.PRELOAD_LOAD_DEMO_COLLECTIONS): DCNL DCSP  DCSP self._setup_reload_demo_collections(driver) DCNL DCSP elif (preload_option == test_config.PRELOAD_RELOAD_DEMO_EXPS): DCNL DCSP  DCSP self._setup_reload_demo_explorations(driver) DCNL DCSP elif (preload_option == test_config.PRELOAD_RELOAD_FIRST_EXP): DCNL DCSP  DCSP self._setup_reload_first_exploration(driver) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Empty DCSP or DCSP invalid DCSP preload DCSP option.') DCNL DCSP self._stop_driver(driver)
def load_url(self, page_url): DCNL DCSP driver = self._setup_driver(proxy=None, use_proxy=False) DCNL DCSP driver.get(page_url) DCNL DCSP self._stop_driver(driver)
def get_page_metrics_from_uncached_session(self, page_url): DCNL DCSP (server, proxy) = self._setup_proxy_server() DCNL DCSP driver = self._setup_driver(proxy=proxy, use_proxy=True) DCNL DCSP proxy.new_har(page_url, options={'captureHeaders': True}) DCNL DCSP driver.get(page_url) DCNL DCSP self._wait_until_page_load_is_finished() DCNL DCSP har_dict = proxy.har DCNL DCSP self._stop_proxy_server(server) DCNL DCSP self._stop_driver(driver) DCNL DCSP return perf_domain.PageSessionMetrics(page_session_stats=har_dict, page_session_timings=None)
def get_page_metrics_from_cached_session(self, page_url): DCNL DCSP (server, proxy) = self._setup_proxy_server() DCNL DCSP driver = self._setup_driver(proxy=proxy, use_proxy=True) DCNL DCSP driver.get(page_url) DCNL DCSP self._wait_until_page_load_is_finished() DCNL DCSP proxy.new_har(page_url, options={'captureHeaders': True}) DCNL DCSP driver.get(page_url) DCNL DCSP self._wait_until_page_load_is_finished() DCNL DCSP har_dict = proxy.har DCNL DCSP self._stop_proxy_server(server) DCNL DCSP self._stop_driver(driver) DCNL DCSP return perf_domain.PageSessionMetrics(page_session_stats=har_dict, page_session_timings=None)
def get_page_timings_from_uncached_session(self, page_url): DCNL DCSP driver = self._setup_driver(proxy=None, use_proxy=False) DCNL DCSP driver.get(page_url) DCNL DCSP self._wait_until_page_load_is_finished() DCNL DCSP page_session_timings = driver.execute_script('return DCSP window.performance') DCNL DCSP self._stop_driver(driver) DCNL DCSP return perf_domain.PageSessionMetrics(page_session_stats=None, page_session_timings=page_session_timings)
def get_page_timings_from_cached_session(self, page_url): DCNL DCSP driver = self._setup_driver(proxy=None, use_proxy=False) DCNL DCSP driver.get(page_url) DCNL DCSP self._wait_until_page_load_is_finished() DCNL DCSP driver.get(page_url) DCNL DCSP self._wait_until_page_load_is_finished() DCNL DCSP page_session_timings = driver.execute_script('return DCSP window.performance') DCNL DCSP self._stop_driver(driver) DCNL DCSP return perf_domain.PageSessionMetrics(page_session_stats=None, page_session_timings=page_session_timings)
def _setup_driver(self, proxy=None, use_proxy=False): DCNL DCSP driver = None DCNL DCSP if (self.browser == 'chrome'): DCNL DCSP  DCSP chrome_options = webdriver.ChromeOptions() DCNL DCSP  DCSP chrome_options.add_argument('--disable-background-networking') DCNL DCSP  DCSP chrome_options.add_argument('--prerender=disabled') DCNL DCSP  DCSP chrome_options.add_argument('--prerender-from-omnibox=disabled') DCNL DCSP  DCSP if use_proxy: DCNL DCSP  DCSP  DCSP proxy_url = urlparse.urlparse(proxy.proxy).path DCNL DCSP  DCSP  DCSP proxy_argument = '--proxy-server={0}'.format(proxy_url) DCNL DCSP  DCSP  DCSP chrome_options.add_argument(proxy_argument) DCNL DCSP  DCSP driver = webdriver.Chrome(CHROMEDRIVER_PATH, chrome_options=chrome_options) DCNL DCSP elif (self.browser == 'firefox'): DCNL DCSP  DCSP firefox_profile = webdriver.FirefoxProfile() DCNL DCSP  DCSP if use_proxy: DCNL DCSP  DCSP  DCSP firefox_profile.set_proxy(proxy.selenium_proxy()) DCNL DCSP  DCSP driver = webdriver.Firefox(firefox_profile=firefox_profile) DCNL DCSP self._add_cookie(driver) DCNL DCSP return driver
def _is_current_user_logged_in(self, driver): DCNL DCSP driver.get(self.BASE_URL) DCNL DCSP self._wait_until_page_load_is_finished() DCNL DCSP resulting_url = driver.current_url DCNL DCSP if (resulting_url == ('%s%s' % (self.BASE_URL, feconf.CREATOR_DASHBOARD_URL))): DCNL DCSP  DCSP return False DCNL DCSP return True
def __init__(self): DCNL DCSP yaml_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '../data/string_classifier_test.yaml') DCNL DCSP doc_to_label = {} DCNL DCSP with open(yaml_path, 'r') as yaml_file: DCNL DCSP  DCSP yaml_dict = yaml.load(yaml_file) DCNL DCSP  DCSP interactions = yaml_dict['states']['Home']['interaction'] DCNL DCSP  DCSP for answer_group in interactions['answer_groups'][1:]: DCNL DCSP  DCSP  DCSP label = answer_group['outcome']['feedback'][0] DCNL DCSP  DCSP  DCSP for rule in answer_group['rule_specs']: DCNL DCSP  DCSP  DCSP  DCSP if (('inputs' in rule) and ('training_data' in rule['inputs'])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for doc in rule['inputs']['training_data']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (doc not in doc_to_label): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP doc_to_label[doc] = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP doc_to_label[doc].append(label) DCNL DCSP self.examples = [[doc, doc_to_label[doc]] for doc in doc_to_label] DCNL DCSP self.docs_to_classify = [doc[0] for doc in self.examples] DCNL DCSP self.classifier_model_dict = None
@measure_runtime DCNL def train(self, num): DCNL DCSP classifier = classifier_registry.Registry.get_classifier_by_algorithm_id(feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id']) DCNL DCSP classifier.train(self.examples[:num]) DCNL DCSP classifier_dict = classifier.to_dict() DCNL DCSP return classifier_dict
def generate_training_benchmarks(self): DCNL DCSP for num in xrange(100, len(self.examples), 100): DCNL DCSP  DCSP self.train(num)
@measure_runtime DCNL def predict(self, num): DCNL DCSP if (not self.classifier_model_dict): DCNL DCSP  DCSP raise Exception('No DCSP classifier DCSP found') DCNL DCSP classifier = classifier_registry.Registry.get_classifier_by_algorithm_id(feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id']) DCNL DCSP classifier.from_dict(self.classifier_model_dict) DCNL DCSP classifier.predict(self.docs_to_classify[:num])
def generate_prediction_benchmarks(self): DCNL DCSP self.classifier_model_dict = self.train(len(self.examples)) DCNL DCSP for num in xrange(100, len(self.docs_to_classify), 100): DCNL DCSP  DCSP self.predict(num)
def _assert_validation_error(self, item, error_substring): DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, error_substring): DCNL DCSP  DCSP item.validate()
def signup_superadmin_user(self): DCNL DCSP self.signup('tmpsuperadmin@example.com', 'tmpsuperadm1n')
def log_line(self, line): DCNL DCSP print ('%s%s' % (LOG_LINE_PREFIX, line))
def _stash_current_user_env(self): DCNL DCSP self.stashed_user_env = {'USER_EMAIL': os.environ['USER_EMAIL'], 'USER_ID': os.environ['USER_ID'], 'USER_IS_ADMIN': os.environ['USER_IS_ADMIN']}
def _restore_stashed_user_env(self): DCNL DCSP if (not self.stashed_user_env): DCNL DCSP  DCSP raise Exception('No DCSP stashed DCSP user DCSP env DCSP to DCSP restore.') DCNL DCSP for key in self.stashed_user_env: DCNL DCSP  DCSP os.environ[key] = self.stashed_user_env[key] DCNL DCSP self.stashed_user_env = None
def shortDescription(self): DCNL DCSP return None
def get_expected_login_url(self, slug): DCNL DCSP return current_user_services.create_login_url(slug)
def get_expected_logout_url(self, slug): DCNL DCSP return current_user_services.create_logout_url(slug)
def _parse_json_response(self, json_response, expect_errors=False): DCNL DCSP if (not expect_errors): DCNL DCSP  DCSP self.assertEqual(json_response.status_int, 200) DCNL DCSP self.assertEqual(json_response.content_type, 'application/javascript') DCNL DCSP self.assertTrue(json_response.body.startswith(feconf.XSSI_PREFIX)) DCNL DCSP return json.loads(json_response.body[len(feconf.XSSI_PREFIX):])
def get_json(self, url, params=None, expect_errors=False): DCNL DCSP json_response = self.testapp.get(url, params, expect_errors=expect_errors) DCNL DCSP return self._parse_json_response(json_response, expect_errors=expect_errors)
def post_json(self, url, payload, csrf_token=None, expect_errors=False, expected_status_int=200, upload_files=None): DCNL DCSP data = {'payload': json.dumps(payload)} DCNL DCSP if csrf_token: DCNL DCSP  DCSP data['csrf_token'] = csrf_token DCNL DCSP json_response = self._send_post_request(self.testapp, url, data, expect_errors, expected_status_int, upload_files) DCNL DCSP return self._parse_json_response(json_response, expect_errors=expect_errors)
def put_json(self, url, payload, csrf_token=None, expect_errors=False, expected_status_int=200): DCNL DCSP data = {'payload': json.dumps(payload)} DCNL DCSP if csrf_token: DCNL DCSP  DCSP data['csrf_token'] = csrf_token DCNL DCSP json_response = self.testapp.put(str(url), data, expect_errors=expect_errors) DCNL DCSP self.assertEqual(json_response.status_int, expected_status_int) DCNL DCSP return self._parse_json_response(json_response, expect_errors=expect_errors)
def get_csrf_token_from_response(self, response): DCNL DCSP return re.search(CSRF_REGEX, response.body).group(1)
def signup(self, email, username): DCNL DCSP self.login(email) DCNL DCSP with self.urlfetch_mock(): DCNL DCSP  DCSP response = self.testapp.get(feconf.SIGNUP_URL) DCNL DCSP  DCSP self.assertEqual(response.status_int, 200) DCNL DCSP  DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP  DCSP response = self.testapp.post(feconf.SIGNUP_DATA_URL, {'csrf_token': csrf_token, 'payload': json.dumps({'username': username, 'agreed_to_terms': True})}) DCNL DCSP  DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.logout()
def set_config_property(self, config_obj, new_config_value): DCNL DCSP self._stash_current_user_env() DCNL DCSP self.login('tmpsuperadmin@example.com', is_super_admin=True) DCNL DCSP response = self.testapp.get('/admin') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP self.post_json('/adminhandler', {'action': 'save_config_properties', 'new_config_property_values': {config_obj.name: new_config_value}}, csrf_token) DCNL DCSP self.logout() DCNL DCSP self._restore_stashed_user_env()
def set_admins(self, admin_usernames): DCNL DCSP self.set_config_property(config_domain.ADMIN_USERNAMES, admin_usernames)
def set_moderators(self, moderator_usernames): DCNL DCSP self.set_config_property(config_domain.MODERATOR_USERNAMES, moderator_usernames)
def set_banned_users(self, banned_usernames): DCNL DCSP self.set_config_property(config_domain.BANNED_USERNAMES, banned_usernames)
def set_collection_editors(self, collection_editor_usernames): DCNL DCSP self.set_config_property(config_domain.WHITELISTED_COLLECTION_EDITOR_USERNAMES, collection_editor_usernames)
def set_email_senders(self, email_sender_usernames): DCNL DCSP self.set_config_property(config_domain.WHITELISTED_EMAIL_SENDERS, email_sender_usernames)
def save_new_default_exploration(self, exploration_id, owner_id, title='A DCSP title'): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration(exploration_id, title=title, category='A DCSP category') DCNL DCSP exp_services.save_new_exploration(owner_id, exploration) DCNL DCSP return exploration
def save_new_valid_exploration(self, exploration_id, owner_id, title='A DCSP title', category='A DCSP category', objective='An DCSP objective', language_code=constants.DEFAULT_LANGUAGE_CODE, end_state_name=None, interaction_id='TextInput'): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration(exploration_id, title=title, category=category, language_code=language_code) DCNL DCSP exploration.states[exploration.init_state_name].update_interaction_id(interaction_id) DCNL DCSP exploration.objective = objective DCNL DCSP if (end_state_name is not None): DCNL DCSP  DCSP exploration.add_states([end_state_name]) DCNL DCSP  DCSP end_state = exploration.states[end_state_name] DCNL DCSP  DCSP end_state.update_interaction_id('EndExploration') DCNL DCSP  DCSP end_state.interaction.default_outcome = None DCNL DCSP  DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP  DCSP init_interaction = init_state.interaction DCNL DCSP  DCSP init_interaction.default_outcome.dest = end_state_name DCNL DCSP exp_services.save_new_exploration(owner_id, exploration) DCNL DCSP return exploration
def save_new_exp_with_states_schema_v0(self, exp_id, user_id, title): DCNL DCSP exp_model = exp_models.ExplorationModel(id=exp_id, category='category', title=title, objective='Old DCSP objective', language_code='en', tags=[], blurb='', author_notes='', skin_customizations={'panels_contents': {}}, states_schema_version=0, init_state_name=feconf.DEFAULT_INIT_STATE_NAME, states=self.VERSION_0_STATES_DICT, param_specs={}, param_changes=[]) DCNL DCSP rights_manager.create_new_exploration_rights(exp_id, user_id) DCNL DCSP commit_message = ("New DCSP exploration DCSP created DCSP with DCSP title DCSP '%s'." % title) DCNL DCSP exp_model.commit(user_id, commit_message, [{'cmd': 'create_new', 'title': 'title', 'category': 'category'}])
def save_new_default_collection(self, collection_id, owner_id, title='A DCSP title', category='A DCSP category', objective='An DCSP objective', language_code=constants.DEFAULT_LANGUAGE_CODE): DCNL DCSP collection = collection_domain.Collection.create_default_collection(collection_id, title=title, category=category, objective=objective, language_code=language_code) DCNL DCSP collection_services.save_new_collection(owner_id, collection) DCNL DCSP return collection
def get_updated_param_dict(self, param_dict, param_changes, exp_param_specs): DCNL DCSP new_param_dict = copy.deepcopy(param_dict) DCNL DCSP for pc in param_changes: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP obj_type = exp_param_specs[pc.name].obj_type DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise Exception(('Parameter DCSP %s DCSP not DCSP found' % pc.name)) DCNL DCSP  DCSP new_param_dict[pc.name] = pc.get_normalized_value(obj_type, new_param_dict) DCNL DCSP return new_param_dict
def get_static_asset_filepath(self): DCNL DCSP filepath = '' DCNL DCSP if (feconf.IS_MINIFIED or (not feconf.DEV_MODE)): DCNL DCSP  DCSP filepath = os.path.join('build') DCNL DCSP return filepath
def get_static_asset_url(self, asset_suffix): DCNL DCSP return ('/assets%s%s' % (utils.get_asset_dir_prefix(), asset_suffix))
@contextlib.contextmanager DCNL def swap(self, obj, attr, newvalue): DCNL DCSP original = getattr(obj, attr) DCNL DCSP setattr(obj, attr, newvalue) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP setattr(obj, attr, original)
@contextlib.contextmanager DCNL def urlfetch_mock(self, content='', status_code=200, headers=None): DCNL DCSP if (headers is None): DCNL DCSP  DCSP response_headers = {} DCNL DCSP else: DCNL DCSP  DCSP response_headers = headers DCNL DCSP self.testbed.init_urlfetch_stub(enable=False) DCNL DCSP urlfetch_mock = URLFetchServiceMock() DCNL DCSP apiproxy_stub_map.apiproxy.RegisterStub('urlfetch', urlfetch_mock) DCNL DCSP urlfetch_mock.set_return_values(content=content, status_code=status_code, headers=response_headers) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP self.testbed.init_urlfetch_stub(enable=False) DCNL DCSP  DCSP self.testbed.init_urlfetch_stub()
def count_jobs_in_taskqueue(self, queue_name=None): DCNL DCSP return len(self.get_pending_tasks(queue_name))
def get_pending_tasks(self, queue_name=None): DCNL DCSP if queue_name: DCNL DCSP  DCSP return self.taskqueue_stub.get_filtered_tasks(queue_names=[queue_name]) DCNL DCSP else: DCNL DCSP  DCSP return self.taskqueue_stub.get_filtered_tasks()
def process_and_flush_pending_tasks(self, queue_name=None): DCNL DCSP queue_names = ([queue_name] if queue_name else self._get_all_queue_names()) DCNL DCSP tasks = self.taskqueue_stub.get_filtered_tasks(queue_names=queue_names) DCNL DCSP for queue in queue_names: DCNL DCSP  DCSP self.taskqueue_stub.FlushQueue(queue) DCNL DCSP while tasks: DCNL DCSP  DCSP for task in tasks: DCNL DCSP  DCSP  DCSP if (task.url == '/_ah/queue/deferred'): DCNL DCSP  DCSP  DCSP  DCSP from google.appengine.ext import deferred DCNL DCSP  DCSP  DCSP  DCSP deferred.run(task.payload) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP headers = {key: str(val) for (key, val) in task.headers.iteritems()} DCNL DCSP  DCSP  DCSP  DCSP headers['Content-Length'] = str(len((task.payload or ''))) DCNL DCSP  DCSP  DCSP  DCSP app = (webtest.TestApp(main_taskqueue.app) if task.url.startswith('/task') else self.testapp) DCNL DCSP  DCSP  DCSP  DCSP response = app.post(url=str(task.url), params=(task.payload or ''), headers=headers) DCNL DCSP  DCSP  DCSP  DCSP if (response.status_code != 200): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError(('MapReduce DCSP task DCSP to DCSP URL DCSP %s DCSP failed' % task.url)) DCNL DCSP  DCSP tasks = self.taskqueue_stub.get_filtered_tasks(queue_names=queue_names) DCNL DCSP  DCSP for queue in queue_names: DCNL DCSP  DCSP  DCSP self.taskqueue_stub.FlushQueue(queue)
def __init__(self, func): DCNL DCSP self._func = func DCNL DCSP self._instance = None
def __init__(self, f): DCNL DCSP super(CallCounter, self).__init__(f) DCNL DCSP self._times_called = 0
def __init__(self, f, exception, num_tries_before_success): DCNL DCSP super(FailingFunction, self).__init__(f) DCNL DCSP self._exception = exception DCNL DCSP self._num_tries_before_success = num_tries_before_success DCNL DCSP self._always_fail = (self._num_tries_before_success == FailingFunction.INFINITY) DCNL DCSP self._times_called = 0 DCNL DCSP if (not ((self._num_tries_before_success >= 0) or self._always_fail)): DCNL DCSP  DCSP raise ValueError('num_tries_before_success DCSP should DCSP either DCSP be DCSP aninteger DCSP greater DCSP than DCSP or DCSP equal DCSP to DCSP 0,or DCSP FailingFunction.INFINITY')
@acl_decorators.can_access_creator_dashboard DCNL def get(self): DCNL DCSP (job_queued_msec, recent_notifications) = user_jobs_continuous.DashboardRecentUpdatesAggregator.get_recent_notifications(self.user_id) DCNL DCSP last_seen_msec = subscription_services.get_last_seen_notifications_msec(self.user_id) DCNL DCSP author_ids = [notification['author_id'] for notification in recent_notifications if notification['author_id']] DCNL DCSP author_usernames = user_services.get_usernames(author_ids) DCNL DCSP author_id_to_username = {None: ''} DCNL DCSP for (ind, author_id) in enumerate(author_ids): DCNL DCSP  DCSP author_id_to_username[author_id] = author_usernames[ind] DCNL DCSP for notification in recent_notifications: DCNL DCSP  DCSP notification['author_username'] = author_id_to_username[notification['author_id']] DCNL DCSP  DCSP del notification['author_id'] DCNL DCSP subscription_services.record_user_has_seen_notifications(self.user_id, (job_queued_msec if job_queued_msec else 0.0)) DCNL DCSP self.values.update({'job_queued_msec': job_queued_msec, 'last_seen_msec': last_seen_msec, 'recent_notifications': recent_notifications}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_access_creator_dashboard DCNL def get(self): DCNL DCSP def _get_intro_card_color(category): DCNL DCSP  DCSP return (constants.CATEGORIES_TO_COLORS[category] if (category in constants.CATEGORIES_TO_COLORS) else constants.DEFAULT_COLOR) DCNL DCSP def _round_average_ratings(rating): DCNL DCSP  DCSP return round(rating, feconf.AVERAGE_RATINGS_DASHBOARD_PRECISION) DCNL DCSP subscribed_exploration_summaries = [summary for summary in exp_services.get_exploration_summaries_matching_ids(subscription_services.get_exploration_ids_subscribed_to(self.user_id)) if (summary is not None)] DCNL DCSP subscribed_collection_summaries = [summary for summary in collection_services.get_collection_summaries_matching_ids(subscription_services.get_collection_ids_subscribed_to(self.user_id)) if (summary is not None)] DCNL DCSP exploration_ids_subscribed_to = [summary.id for summary in subscribed_exploration_summaries] DCNL DCSP exp_summary_dicts = summary_services.get_displayable_exp_summary_dicts(subscribed_exploration_summaries) DCNL DCSP collection_summary_dicts = [] DCNL DCSP feedback_thread_analytics = feedback_services.get_thread_analytics_multi(exploration_ids_subscribed_to) DCNL DCSP for (ind, exploration) in enumerate(exp_summary_dicts): DCNL DCSP  DCSP exploration.update(feedback_thread_analytics[ind].to_dict()) DCNL DCSP exp_summary_dicts = sorted(exp_summary_dicts, key=(lambda x: (x['num_open_threads'], x['last_updated_msec'])), reverse=True) DCNL DCSP if (role_services.ACTION_CREATE_COLLECTION in self.actions): DCNL DCSP  DCSP for collection_summary in subscribed_collection_summaries: DCNL DCSP  DCSP  DCSP collection_summary_dicts.append({'id': collection_summary.id, 'title': collection_summary.title, 'category': collection_summary.category, 'objective': collection_summary.objective, 'language_code': collection_summary.language_code, 'last_updated': utils.get_time_in_millisecs(collection_summary.collection_model_last_updated), 'created_on': utils.get_time_in_millisecs(collection_summary.collection_model_created_on), 'status': collection_summary.status, 'node_count': collection_summary.node_count, 'community_owned': collection_summary.community_owned, 'thumbnail_icon_url': utils.get_thumbnail_icon_url_for_category(collection_summary.category), 'thumbnail_bg_color': utils.get_hex_color_for_category(collection_summary.category)}) DCNL DCSP dashboard_stats = user_jobs_continuous.UserStatsAggregator.get_dashboard_stats(self.user_id) DCNL DCSP dashboard_stats.update({'total_open_feedback': feedback_services.get_total_open_threads(feedback_thread_analytics)}) DCNL DCSP if (dashboard_stats and dashboard_stats.get('average_ratings')): DCNL DCSP  DCSP dashboard_stats['average_ratings'] = _round_average_ratings(dashboard_stats['average_ratings']) DCNL DCSP last_week_stats = user_services.get_last_week_dashboard_stats(self.user_id) DCNL DCSP if (last_week_stats and last_week_stats.get('average_ratings')): DCNL DCSP  DCSP last_week_stats['average_ratings'] = _round_average_ratings(last_week_stats['average_ratings']) DCNL DCSP subscriber_ids = subscription_services.get_all_subscribers_of_creator(self.user_id) DCNL DCSP subscribers_settings = user_services.get_users_settings(subscriber_ids) DCNL DCSP subscribers_list = [] DCNL DCSP for (index, subscriber_settings) in enumerate(subscribers_settings): DCNL DCSP  DCSP subscriber_summary = {'subscriber_picture_data_url': subscriber_settings.profile_picture_data_url, 'subscriber_username': subscriber_settings.username, 'subscriber_impact': user_services.get_user_impact_score(subscriber_ids[index])} DCNL DCSP  DCSP subscribers_list.append(subscriber_summary) DCNL DCSP self.values.update({'explorations_list': exp_summary_dicts, 'collections_list': collection_summary_dicts, 'dashboard_stats': dashboard_stats, 'last_week_stats': last_week_stats, 'subscribers_list': subscribers_list}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_access_creator_dashboard DCNL def get(self): DCNL DCSP num_unseen_notifications = 0 DCNL DCSP last_seen_msec = subscription_services.get_last_seen_notifications_msec(self.user_id) DCNL DCSP (_, recent_notifications) = user_jobs_continuous.DashboardRecentUpdatesAggregator.get_recent_notifications(self.user_id) DCNL DCSP for notification in recent_notifications: DCNL DCSP  DCSP if ((notification['last_updated_ms'] > last_seen_msec) and (notification['author_id'] != self.user_id)): DCNL DCSP  DCSP  DCSP num_unseen_notifications += 1 DCNL DCSP self.render_json({'num_unseen_notifications': num_unseen_notifications})
@acl_decorators.can_create_exploration DCNL def post(self): DCNL DCSP title = self.payload.get('title', feconf.DEFAULT_EXPLORATION_TITLE) DCNL DCSP new_exploration_id = exp_services.get_new_exploration_id() DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration(new_exploration_id, title=title) DCNL DCSP exp_services.save_new_exploration(self.user_id, exploration) DCNL DCSP self.render_json({EXPLORATION_ID_KEY: new_exploration_id})
@acl_decorators.can_create_collection DCNL def post(self): DCNL DCSP new_collection_id = collection_services.get_new_collection_id() DCNL DCSP collection = collection_domain.Collection.create_default_collection(new_collection_id) DCNL DCSP collection_services.save_new_collection(self.user_id, collection) DCNL DCSP self.render_json({COLLECTION_ID_KEY: new_collection_id})
@acl_decorators.can_upload_exploration DCNL def post(self): DCNL DCSP yaml_content = self.request.get('yaml_file') DCNL DCSP new_exploration_id = exp_services.get_new_exploration_id() DCNL DCSP if feconf.ALLOW_YAML_FILE_UPLOAD: DCNL DCSP  DCSP exp_services.save_new_exploration_from_yaml_and_assets(self.user_id, yaml_content, new_exploration_id, []) DCNL DCSP  DCSP self.render_json({EXPLORATION_ID_KEY: new_exploration_id}) DCNL DCSP else: DCNL DCSP  DCSP raise self.InvalidInputException('This DCSP server DCSP does DCSP not DCSP allow DCSP file DCSP uploads.')
@acl_decorators.can_manage_email_dashboard DCNL def get(self): DCNL DCSP self.render_template('pages/email_dashboard/email_dashboard.html')
@acl_decorators.can_manage_email_dashboard DCNL def post(self): DCNL DCSP data = self.payload['data'] DCNL DCSP kwargs = {key: data[key] for key in data if (data[key] is not None)} DCNL DCSP self._validate(kwargs) DCNL DCSP query_id = user_query_services.save_new_query_model(self.user_id, **kwargs) DCNL DCSP job_id = user_query_jobs_one_off.UserQueryOneOffJob.create_new() DCNL DCSP params = {'query_id': query_id} DCNL DCSP user_query_jobs_one_off.UserQueryOneOffJob.enqueue(job_id, additional_job_params=params) DCNL DCSP query_model = user_models.UserQueryModel.get(query_id) DCNL DCSP query_data = {'id': query_model.id, 'submitter_username': user_services.get_username(query_model.submitter_id), 'created_on': query_model.created_on.strftime('%d-%m-%y DCSP %H:%M:%S'), 'status': query_model.query_status, 'num_qualified_users': len(query_model.user_ids)} DCNL DCSP data = {'query': query_data} DCNL DCSP self.render_json(data)
def _validate(self, data): DCNL DCSP possible_keys = ['has_not_logged_in_for_n_days', 'inactive_in_last_n_days', 'created_at_least_n_exps', 'created_fewer_than_n_exps', 'edited_at_least_n_exps', 'edited_fewer_than_n_exps'] DCNL DCSP for (key, value) in data.iteritems(): DCNL DCSP  DCSP if ((key not in possible_keys) or (not isinstance(value, int)) or (value < 0)): DCNL DCSP  DCSP  DCSP raise self.InvalidInputException('400 DCSP Invalid DCSP input DCSP for DCSP query.')
@acl_decorators.can_perform_cron_tasks DCNL def get(self): DCNL DCSP failed_jobs = jobs.get_stuck_jobs(TWENTY_FIVE_HOURS_IN_MSECS) DCNL DCSP if failed_jobs: DCNL DCSP  DCSP email_subject = 'MapReduce DCSP failure DCSP alert' DCNL DCSP  DCSP email_message = ('%s DCSP jobs DCSP have DCSP failed DCSP in DCSP the DCSP past DCSP 25 DCSP hours. DCSP More DCSP information DCSP (about DCSP at DCSP most DCSP %s DCSP jobs; DCSP to DCSP see DCSP more, DCSP please DCSP check DCSP the DCSP logs):' % (len(failed_jobs), MAX_JOBS_TO_REPORT_ON)) DCNL DCSP  DCSP for job in failed_jobs[:MAX_JOBS_TO_REPORT_ON]: DCNL DCSP  DCSP  DCSP email_message += '\n' DCNL DCSP  DCSP  DCSP email_message += '-----------------------------------' DCNL DCSP  DCSP  DCSP email_message += '\n' DCNL DCSP  DCSP  DCSP email_message += ('Job DCSP with DCSP mapreduce DCSP ID DCSP %s DCSP (key DCSP name DCSP %s) DCSP failed. DCSP More DCSP info:\n\n DCSP  DCSP counters_map: DCSP %s\n DCSP  DCSP shard_retries: DCSP %s\n DCSP  DCSP slice_retries: DCSP %s\n DCSP  DCSP last_update_time: DCSP %s\n DCSP  DCSP last_work_item: DCSP %s\n' % (job.mapreduce_id, job.key().name(), job.counters_map, job.retries, job.slice_retries, job.update_time, job.last_work_item)) DCNL DCSP else: DCNL DCSP  DCSP email_subject = 'MapReduce DCSP status DCSP report' DCNL DCSP  DCSP email_message = 'All DCSP MapReduce DCSP jobs DCSP are DCSP running DCSP fine.' DCNL DCSP email_manager.send_mail_to_admin(email_subject, email_message)
@acl_decorators.can_perform_cron_tasks DCNL def get(self): DCNL DCSP user_jobs_one_off.DashboardStatsOneOffJob.enqueue(user_jobs_one_off.DashboardStatsOneOffJob.create_new())
@acl_decorators.can_perform_cron_tasks DCNL def get(self): DCNL DCSP job_class = recommendations_jobs_one_off.ExplorationRecommendationsOneOffJob DCNL DCSP job_class.enqueue(job_class.create_new())
@acl_decorators.can_perform_cron_tasks DCNL def get(self): DCNL DCSP exp_jobs_one_off.IndexAllExplorationsJobManager.enqueue(exp_jobs_one_off.IndexAllExplorationsJobManager.create_new())
@acl_decorators.can_perform_cron_tasks DCNL def get(self): DCNL DCSP recency_msec = MAX_MAPREDUCE_METADATA_RETENTION_MSECS DCNL DCSP num_cleaned = 0 DCNL DCSP min_age_msec = recency_msec DCNL DCSP max_age_msec = (recency_msec + ((((7 * 24) * 60) * 60) * 1000)) DCNL DCSP max_start_time_msec = (utils.get_current_time_in_millisecs() - min_age_msec) DCNL DCSP pipeline_id_to_job_instance = {} DCNL DCSP job_instances = job_models.JobModel.get_recent_jobs(1000, max_age_msec) DCNL DCSP for job_instance in job_instances: DCNL DCSP  DCSP if ((job_instance.time_started_msec < max_start_time_msec) and (not job_instance.has_been_cleaned_up)): DCNL DCSP  DCSP  DCSP if ('root_pipeline_id' in job_instance.metadata): DCNL DCSP  DCSP  DCSP  DCSP pipeline_id = job_instance.metadata['root_pipeline_id'] DCNL DCSP  DCSP  DCSP  DCSP pipeline_id_to_job_instance[pipeline_id] = job_instance DCNL DCSP for pline in pipeline.get_root_list()['pipelines']: DCNL DCSP  DCSP pipeline_id = pline['pipelineId'] DCNL DCSP  DCSP job_definitely_terminated = ((pline['status'] == 'done') or (pline['status'] == 'aborted') or (pline['currentAttempt'] > pline['maxAttempts'])) DCNL DCSP  DCSP have_start_time = ('startTimeMs' in pline) DCNL DCSP  DCSP job_started_too_long_ago = (have_start_time and (pline['startTimeMs'] < max_start_time_msec)) DCNL DCSP  DCSP if (job_started_too_long_ago or ((not have_start_time) and job_definitely_terminated)): DCNL DCSP  DCSP  DCSP if (pipeline_id in pipeline_id_to_job_instance): DCNL DCSP  DCSP  DCSP  DCSP job_instance = pipeline_id_to_job_instance[pipeline_id] DCNL DCSP  DCSP  DCSP  DCSP job_instance.has_been_cleaned_up = True DCNL DCSP  DCSP  DCSP  DCSP job_instance.put() DCNL DCSP  DCSP  DCSP p = pipeline.Pipeline.from_id(pipeline_id) DCNL DCSP  DCSP  DCSP if p: DCNL DCSP  DCSP  DCSP  DCSP p.cleanup() DCNL DCSP  DCSP  DCSP  DCSP num_cleaned += 1 DCNL DCSP logging.warning(('%s DCSP MR DCSP jobs DCSP cleaned DCSP up.' % num_cleaned)) DCNL DCSP if job_models.JobModel.do_unfinished_jobs_exist(jobs.JobCleanupManager.__name__): DCNL DCSP  DCSP logging.warning('A DCSP previous DCSP cleanup DCSP job DCSP is DCSP still DCSP running.') DCNL DCSP else: DCNL DCSP  DCSP jobs.JobCleanupManager.enqueue(jobs.JobCleanupManager.create_new(), additional_job_params={jobs.MAPPER_PARAM_MAX_START_TIME_MSEC: max_start_time_msec}) DCNL DCSP  DCSP logging.warning('Deletion DCSP jobs DCSP for DCSP auxiliary DCSP entities DCSP kicked DCSP off.')
@acl_decorators.can_play_collection DCNL def get(self, collection_id): DCNL DCSP try: DCNL DCSP  DCSP collection = collection_services.get_collection_by_id(collection_id) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise self.PageNotFoundException(e) DCNL DCSP collection_rights = rights_manager.get_collection_rights(collection_id, strict=False) DCNL DCSP self.values.update({'nav_mode': feconf.NAV_MODE_COLLECTION, 'can_edit': rights_manager.check_can_edit_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_COLLECTION, collection_rights), 'is_logged_in': bool(self.user_id), 'collection_id': collection_id, 'collection_title': collection.title, 'is_private': rights_manager.is_collection_private(collection_id), 'meta_name': collection.title, 'meta_description': utils.capitalize_string(collection.objective)}) DCNL DCSP self.render_template('pages/collection_player/collection_player.html')
@acl_decorators.can_play_collection DCNL def get(self, collection_id): DCNL DCSP try: DCNL DCSP  DCSP collection_dict = summary_services.get_learner_collection_dict_by_id(collection_id, self.user_id, allow_invalid_explorations=False) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise self.PageNotFoundException(e) DCNL DCSP collection_rights = rights_manager.get_collection_rights(collection_id, strict=False) DCNL DCSP self.values.update({'can_edit': rights_manager.check_can_edit_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_COLLECTION, collection_rights), 'collection': collection_dict, 'is_logged_in': bool(self.user_id), 'session_id': utils.generate_new_session_id()}) DCNL DCSP self.render_json(self.values)
def test_library_page(self): DCNL DCSP response = self.testapp.get(feconf.LIBRARY_INDEX_URL) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP response.mustcontain('I18N_LIBRARY_PAGE_TITLE')
def test_library_handler_demo_exploration(self): DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_SEARCH_DATA_URL) DCNL DCSP self.assertEqual({'is_admin': False, 'is_moderator': False, 'is_super_admin': False, 'activity_list': [], 'search_cursor': None, 'profile_picture_data_url': None}, response_dict) DCNL DCSP exp_services.load_demo('0') DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_SEARCH_DATA_URL) DCNL DCSP self.assertEqual(len(response_dict['activity_list']), 1) DCNL DCSP self.assertDictContainsSubset({'id': '0', 'category': 'Welcome', 'title': 'Welcome DCSP to DCSP Oppia!', 'language_code': 'en', 'objective': "become DCSP familiar DCSP with DCSP Oppia's DCSP capabilities", 'status': rights_manager.ACTIVITY_STATUS_PUBLIC}, response_dict['activity_list'][0]) DCNL DCSP self.set_admins([self.ADMIN_USERNAME]) DCNL DCSP rights_manager.publicize_exploration(self.admin_id, '0') DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP job_id = exp_jobs_one_off.ExpSummariesCreationOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExpSummariesCreationOneOffJob.enqueue(job_id) DCNL DCSP self.assertGreaterEqual(self.count_jobs_in_taskqueue(), 1) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(), 0) DCNL DCSP exp_services.update_exploration(self.editor_id, '0', [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'A DCSP new DCSP title!'}, {'cmd': 'edit_exploration_property', 'property_name': 'category', 'new_value': 'A DCSP new DCSP category'}], 'Change DCSP title DCSP and DCSP category') DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_SEARCH_DATA_URL) DCNL DCSP self.assertEqual(len(response_dict['activity_list']), 1) DCNL DCSP self.assertDictContainsSubset({'id': '0', 'category': 'A DCSP new DCSP category', 'title': 'A DCSP new DCSP title!', 'language_code': 'en', 'objective': "become DCSP familiar DCSP with DCSP Oppia's DCSP capabilities", 'status': rights_manager.ACTIVITY_STATUS_PUBLICIZED}, response_dict['activity_list'][0])
def test_library_handler_for_created_explorations(self): DCNL DCSP self.set_admins([self.ADMIN_USERNAME]) DCNL DCSP self.login(self.ADMIN_EMAIL) DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_SEARCH_DATA_URL) DCNL DCSP self.assertDictContainsSubset({'is_admin': True, 'is_moderator': True, 'is_super_admin': False, 'activity_list': [], 'user_email': self.ADMIN_EMAIL, 'username': self.ADMIN_USERNAME, 'search_cursor': None}, response_dict) DCNL DCSP exploration = self.save_new_valid_exploration('A', self.admin_id, title='Title DCSP A', category='Category DCSP A', objective='Objective DCSP A') DCNL DCSP exp_services._save_exploration(self.admin_id, exploration, 'Exploration DCSP A', []) DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_SEARCH_DATA_URL) DCNL DCSP self.assertEqual(response_dict['activity_list'], []) DCNL DCSP exploration = self.save_new_valid_exploration('B', self.admin_id, title='Title DCSP B', category='Category DCSP B', objective='Objective DCSP B') DCNL DCSP exp_services._save_exploration(self.admin_id, exploration, 'Exploration DCSP B', []) DCNL DCSP rights_manager.publish_exploration(self.admin_id, 'B') DCNL DCSP rights_manager.publicize_exploration(self.admin_id, 'B') DCNL DCSP rights_manager.publish_exploration(self.admin_id, 'A') DCNL DCSP exp_services.index_explorations_given_ids(['A', 'B']) DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_SEARCH_DATA_URL) DCNL DCSP self.assertEqual(len(response_dict['activity_list']), 2) DCNL DCSP self.assertDictContainsSubset({'id': 'B', 'category': 'Category DCSP B', 'title': 'Title DCSP B', 'language_code': 'en', 'objective': 'Objective DCSP B', 'status': rights_manager.ACTIVITY_STATUS_PUBLICIZED}, response_dict['activity_list'][0]) DCNL DCSP self.assertDictContainsSubset({'id': 'A', 'category': 'Category DCSP A', 'title': 'Title DCSP A', 'language_code': 'en', 'objective': 'Objective DCSP A', 'status': rights_manager.ACTIVITY_STATUS_PUBLIC}, response_dict['activity_list'][1]) DCNL DCSP exp_services.delete_exploration(self.admin_id, 'A') DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_SEARCH_DATA_URL) DCNL DCSP self.assertEqual(len(response_dict['activity_list']), 1) DCNL DCSP self.assertDictContainsSubset({'id': 'B', 'category': 'Category DCSP B', 'title': 'Title DCSP B', 'language_code': 'en', 'objective': 'Objective DCSP B', 'status': rights_manager.ACTIVITY_STATUS_PUBLICIZED}, response_dict['activity_list'][0])
def test_library_group_pages(self): DCNL DCSP response = self.testapp.get(feconf.LIBRARY_TOP_RATED_URL) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP response = self.testapp.get(feconf.LIBRARY_RECENTLY_PUBLISHED_URL) DCNL DCSP self.assertEqual(response.status_int, 200)
def test_handler_for_recently_published_library_group_page(self): DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_GROUP_DATA_URL, {'group_name': feconf.LIBRARY_GROUP_RECENTLY_PUBLISHED}) DCNL DCSP self.assertDictContainsSubset({'is_admin': False, 'is_moderator': False, 'is_super_admin': False, 'activity_list': [], 'preferred_language_codes': ['en'], 'profile_picture_data_url': None}, response_dict) DCNL DCSP exp_services.load_demo('0') DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_GROUP_DATA_URL, {'group_name': feconf.LIBRARY_GROUP_RECENTLY_PUBLISHED}) DCNL DCSP self.assertEqual(len(response_dict['activity_list']), 1) DCNL DCSP self.assertDictContainsSubset({'header_i18n_id': 'I18N_LIBRARY_GROUPS_RECENTLY_PUBLISHED', 'preferred_language_codes': ['en']}, response_dict) DCNL DCSP self.assertDictContainsSubset({'id': '0', 'category': 'Welcome', 'title': 'Welcome DCSP to DCSP Oppia!', 'language_code': 'en', 'objective': "become DCSP familiar DCSP with DCSP Oppia's DCSP capabilities", 'status': rights_manager.ACTIVITY_STATUS_PUBLIC}, response_dict['activity_list'][0])
def test_handler_for_top_rated_library_group_page(self): DCNL DCSP exp_services.load_demo('0') DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_GROUP_DATA_URL, {'group_name': feconf.LIBRARY_GROUP_TOP_RATED}) DCNL DCSP self.assertDictContainsSubset({'is_admin': False, 'is_moderator': False, 'is_super_admin': False, 'activity_list': [], 'preferred_language_codes': ['en'], 'profile_picture_data_url': None}, response_dict) DCNL DCSP rating_services.assign_rating_to_exploration('user', '0', 2) DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_GROUP_DATA_URL, {'group_name': feconf.LIBRARY_GROUP_TOP_RATED}) DCNL DCSP self.assertDictContainsSubset({'header_i18n_id': 'I18N_LIBRARY_GROUPS_TOP_RATED_EXPLORATIONS', 'preferred_language_codes': ['en']}, response_dict) DCNL DCSP self.assertEqual(len(response_dict['activity_list']), 1) DCNL DCSP self.assertDictContainsSubset({'id': '0', 'category': 'Welcome', 'title': 'Welcome DCSP to DCSP Oppia!', 'language_code': 'en', 'objective': "become DCSP familiar DCSP with DCSP Oppia's DCSP capabilities", 'status': rights_manager.ACTIVITY_STATUS_PUBLIC}, response_dict['activity_list'][0]) DCNL DCSP exp_services.load_demo('1') DCNL DCSP rating_services.assign_rating_to_exploration('user', '1', 4) DCNL DCSP response_dict = self.get_json(feconf.LIBRARY_GROUP_DATA_URL, {'group_name': feconf.LIBRARY_GROUP_TOP_RATED}) DCNL DCSP self.assertEqual(len(response_dict['activity_list']), 2) DCNL DCSP self.assertDictContainsSubset({'id': '1', 'category': 'Programming', 'title': 'Project DCSP Euler DCSP Problem DCSP 1', 'language_code': 'en', 'objective': 'solve DCSP Problem DCSP 1 DCSP on DCSP the DCSP Project DCSP Euler DCSP site', 'status': rights_manager.ACTIVITY_STATUS_PUBLIC}, response_dict['activity_list'][0]) DCNL DCSP self.assertDictContainsSubset({'id': '0', 'category': 'Welcome', 'title': 'Welcome DCSP to DCSP Oppia!', 'language_code': 'en', 'objective': "become DCSP familiar DCSP with DCSP Oppia's DCSP capabilities", 'status': rights_manager.ACTIVITY_STATUS_PUBLIC}, response_dict['activity_list'][1])
def get(self): DCNL DCSP url_to_redirect_to = str((self.request.get('return_url') or '/')) DCNL DCSP _clear_login_cookies(self.response.headers) DCNL DCSP if feconf.DEV_MODE: DCNL DCSP  DCSP self.redirect(users.create_logout_url(url_to_redirect_to)) DCNL DCSP else: DCNL DCSP  DCSP self.redirect(url_to_redirect_to)
def dispatch(self): DCNL DCSP if self.request.uri.startswith('https://oppiaserver.appspot.com'): DCNL DCSP  DCSP self.redirect('https://oppiatestserver.appspot.com', True) DCNL DCSP  DCSP return DCNL DCSP if (feconf.DEV_MODE and self.partially_logged_in): DCNL DCSP  DCSP self.redirect(users.create_logout_url(self.request.uri)) DCNL DCSP  DCSP return DCNL DCSP if ((self.payload is not None) and self.REQUIRE_PAYLOAD_CSRF_CHECK): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP csrf_token = self.request.get('csrf_token') DCNL DCSP  DCSP  DCSP if (not csrf_token): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('Missing DCSP CSRF DCSP token. DCSP Changes DCSP were DCSP not DCSP saved. DCSP Please DCSP report DCSP this DCSP bug.') DCNL DCSP  DCSP  DCSP is_csrf_token_valid = CsrfTokenManager.is_csrf_token_valid(self.user_id, csrf_token) DCNL DCSP  DCSP  DCSP if (not is_csrf_token_valid): DCNL DCSP  DCSP  DCSP  DCSP raise self.UnauthorizedUserException('Your DCSP session DCSP has DCSP expired, DCSP and DCSP unfortunately DCSP your DCSP changes DCSP cannot DCSP be DCSP saved. DCSP Please DCSP refresh DCSP the DCSP page.') DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logging.error('%s: DCSP payload DCSP %s', e, self.payload) DCNL DCSP  DCSP  DCSP return self.handle_exception(e, self.app.debug) DCNL DCSP super(BaseHandler, self).dispatch()
def get(self, *args, **kwargs): DCNL DCSP raise self.PageNotFoundException
def post(self, *args): DCNL DCSP raise self.PageNotFoundException
def put(self, *args): DCNL DCSP raise self.PageNotFoundException
def delete(self, *args): DCNL DCSP raise self.PageNotFoundException
def render_json(self, values): DCNL DCSP self.response.content_type = 'application/javascript; DCSP charset=utf-8' DCNL DCSP self.response.headers['Content-Disposition'] = 'attachment; DCSP filename="oppia-attachment.txt"' DCNL DCSP self.response.headers['Strict-Transport-Security'] = 'max-age=31536000; DCSP includeSubDomains' DCNL DCSP self.response.headers['X-Content-Type-Options'] = 'nosniff' DCNL DCSP json_output = json.dumps(values, cls=utils.JSONEncoderForHTML) DCNL DCSP self.response.write(('%s%s' % (feconf.XSSI_PREFIX, json_output)))
def render_template(self, filepath, iframe_restriction='DENY', redirect_url_on_logout=None): DCNL DCSP values = self.values DCNL DCSP (scheme, netloc, path, _, _) = urlparse.urlsplit(self.request.uri) DCNL DCSP values.update({'ASSET_DIR_PREFIX': utils.get_asset_dir_prefix(), 'BEFORE_END_HEAD_TAG_HOOK': jinja2.utils.Markup(BEFORE_END_HEAD_TAG_HOOK.value), 'DEV_MODE': feconf.DEV_MODE, 'MINIFICATION': feconf.IS_MINIFIED, 'DOMAIN_URL': ('%s://%s' % (scheme, netloc)), 'ACTIVITY_STATUS_PRIVATE': rights_manager.ACTIVITY_STATUS_PRIVATE, 'ACTIVITY_STATUS_PUBLIC': rights_manager.ACTIVITY_STATUS_PUBLIC, 'ACTIVITY_STATUS_PUBLICIZED': rights_manager.ACTIVITY_STATUS_PUBLICIZED, 'AUDIO_URL_TEMPLATE': feconf.AUDIO_URL_TEMPLATE, 'FULL_URL': ('%s://%s%s' % (scheme, netloc, path)), 'INVALID_NAME_CHARS': feconf.INVALID_NAME_CHARS, 'RTE_COMPONENT_SPECS': rte_component_registry.Registry.get_all_specs(), 'SITE_FEEDBACK_FORM_URL': feconf.SITE_FEEDBACK_FORM_URL, 'SITE_NAME': feconf.SITE_NAME, 'SYSTEM_USERNAMES': feconf.SYSTEM_USERNAMES, 'TEMPLATE_DIR_PREFIX': utils.get_template_dir_prefix(), 'can_create_collections': bool((self.role == feconf.ROLE_ID_COLLECTION_EDITOR)), 'username': self.username, 'user_is_logged_in': user_services.has_fully_registered(self.user_id), 'preferred_site_language_code': self.preferred_site_language_code}) DCNL DCSP if feconf.ENABLE_PROMO_BAR: DCNL DCSP  DCSP promo_bar_enabled = config_domain.PROMO_BAR_ENABLED.value DCNL DCSP  DCSP promo_bar_message = config_domain.PROMO_BAR_MESSAGE.value DCNL DCSP else: DCNL DCSP  DCSP promo_bar_enabled = False DCNL DCSP  DCSP promo_bar_message = '' DCNL DCSP values.update({'promo_bar_enabled': promo_bar_enabled, 'promo_bar_message': promo_bar_message}) DCNL DCSP if ('meta_name' not in values): DCNL DCSP  DCSP values['meta_name'] = 'Personalized DCSP Online DCSP Learning DCSP from DCSP Oppia' DCNL DCSP if ('meta_description' not in values): DCNL DCSP  DCSP values['meta_description'] = 'Oppia DCSP is DCSP a DCSP free, DCSP open-source DCSP learning DCSP platform. DCSP Join DCSP the DCSP community DCSP to DCSP create DCSP or DCSP try DCSP an DCSP exploration DCSP today!' DCNL DCSP if ('nav_mode' not in values): DCNL DCSP  DCSP values['nav_mode'] = '' DCNL DCSP if (redirect_url_on_logout is None): DCNL DCSP  DCSP redirect_url_on_logout = self.request.uri DCNL DCSP if self.user_id: DCNL DCSP  DCSP values['login_url'] = None DCNL DCSP  DCSP values['logout_url'] = current_user_services.create_logout_url(redirect_url_on_logout) DCNL DCSP else: DCNL DCSP  DCSP target_url = ('/' if self.request.uri.endswith(feconf.SPLASH_URL) else self.request.uri) DCNL DCSP  DCSP values['login_url'] = current_user_services.create_login_url(target_url) DCNL DCSP  DCSP values['logout_url'] = None DCNL DCSP values['csrf_token'] = '' DCNL DCSP if self.REQUIRE_PAYLOAD_CSRF_CHECK: DCNL DCSP  DCSP values['csrf_token'] = CsrfTokenManager.create_csrf_token(self.user_id) DCNL DCSP self.response.cache_control.no_cache = True DCNL DCSP self.response.cache_control.must_revalidate = True DCNL DCSP self.response.headers['Strict-Transport-Security'] = 'max-age=31536000; DCSP includeSubDomains' DCNL DCSP self.response.headers['X-Content-Type-Options'] = 'nosniff' DCNL DCSP if (iframe_restriction is not None): DCNL DCSP  DCSP if (iframe_restriction in ['SAMEORIGIN', 'DENY']): DCNL DCSP  DCSP  DCSP self.response.headers['X-Frame-Options'] = iframe_restriction DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP X-Frame-Options: DCSP %s' % iframe_restriction)) DCNL DCSP self.response.expires = 'Mon, DCSP 01 DCSP Jan DCSP 1990 DCSP 00:00:00 DCSP GMT' DCNL DCSP self.response.pragma = 'no-cache' DCNL DCSP self.response.write(self.jinja2_env.get_template(filepath).render(**values))
def _render_exception(self, error_code, values): DCNL DCSP assert (error_code in [400, 401, 404, 500]) DCNL DCSP values['code'] = error_code DCNL DCSP if ((self.payload is not None) or (self.GET_HANDLER_ERROR_RETURN_TYPE == feconf.HANDLER_TYPE_JSON)): DCNL DCSP  DCSP self.render_json(values) DCNL DCSP else: DCNL DCSP  DCSP self.values.update(values) DCNL DCSP  DCSP if (('iframed' in self.values) and self.values['iframed']): DCNL DCSP  DCSP  DCSP self.render_template('pages/error/error_iframed.html', iframe_restriction=None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.render_template('pages/error/error.html')
def handle_exception(self, exception, unused_debug_mode): DCNL DCSP if isinstance(exception, self.NotLoggedInException): DCNL DCSP  DCSP self.redirect(current_user_services.create_login_url(self.request.uri)) DCNL DCSP  DCSP return DCNL DCSP logging.info(''.join(traceback.format_exception(*sys.exc_info()))) DCNL DCSP logging.error('Exception DCSP raised: DCSP %s', exception) DCNL DCSP if isinstance(exception, self.PageNotFoundException): DCNL DCSP  DCSP logging.error('Invalid DCSP URL DCSP requested: DCSP %s', self.request.uri) DCNL DCSP  DCSP self.error(404) DCNL DCSP  DCSP self._render_exception(404, {'error': ('Could DCSP not DCSP find DCSP the DCSP page DCSP %s.' % self.request.uri)}) DCNL DCSP  DCSP return DCNL DCSP if isinstance(exception, self.UnauthorizedUserException): DCNL DCSP  DCSP self.error(401) DCNL DCSP  DCSP self._render_exception(401, {'error': unicode(exception)}) DCNL DCSP  DCSP return DCNL DCSP if isinstance(exception, self.InvalidInputException): DCNL DCSP  DCSP self.error(400) DCNL DCSP  DCSP self._render_exception(400, {'error': unicode(exception)}) DCNL DCSP  DCSP return DCNL DCSP if isinstance(exception, self.InternalErrorException): DCNL DCSP  DCSP self.error(500) DCNL DCSP  DCSP self._render_exception(500, {'error': unicode(exception)}) DCNL DCSP  DCSP return DCNL DCSP self.error(500) DCNL DCSP self._render_exception(500, {'error': unicode(exception)})
@classmethod DCNL def init_csrf_secret(cls): DCNL DCSP if (CSRF_SECRET.value and (CSRF_SECRET.value != DEFAULT_CSRF_SECRET)): DCNL DCSP  DCSP return DCNL DCSP config_services.set_property(feconf.SYSTEM_COMMITTER_ID, CSRF_SECRET.name, base64.urlsafe_b64encode(os.urandom(20)))
@classmethod DCNL def _create_token(cls, user_id, issued_on): DCNL DCSP cls.init_csrf_secret() DCNL DCSP if (user_id is None): DCNL DCSP  DCSP user_id = cls._USER_ID_DEFAULT DCNL DCSP issued_on = long(issued_on) DCNL DCSP digester = hmac.new(str(CSRF_SECRET.value)) DCNL DCSP digester.update(str(user_id)) DCNL DCSP digester.update(':') DCNL DCSP digester.update(str(issued_on)) DCNL DCSP digest = digester.digest() DCNL DCSP token = ('%s/%s' % (issued_on, base64.urlsafe_b64encode(digest))) DCNL DCSP return token
@classmethod DCNL def is_csrf_token_valid(cls, user_id, token): DCNL DCSP try: DCNL DCSP  DCSP parts = token.split('/') DCNL DCSP  DCSP if (len(parts) != 2): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP issued_on = long(parts[0]) DCNL DCSP  DCSP age = (cls._get_current_time() - issued_on) DCNL DCSP  DCSP if (age > cls._CSRF_TOKEN_AGE_SECS): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP authentic_token = cls._create_token(user_id, issued_on) DCNL DCSP  DCSP if (authentic_token == token): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False DCNL DCSP except Exception: DCNL DCSP  DCSP return False
@acl_decorators.open_access DCNL def get(self, username): DCNL DCSP user_settings = user_services.get_user_settings_from_username(username) DCNL DCSP if (not user_settings): DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP self.values.update({'nav_mode': feconf.NAV_MODE_PROFILE, 'PROFILE_USERNAME': user_settings.username}) DCNL DCSP self.render_template('pages/profile/profile.html')
@acl_decorators.open_access DCNL def get(self, username): DCNL DCSP user_settings = user_services.get_user_settings_from_username(username) DCNL DCSP if (not user_settings): DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP created_exp_summary_dicts = [] DCNL DCSP edited_exp_summary_dicts = [] DCNL DCSP subscriber_ids = subscription_services.get_all_subscribers_of_creator(user_settings.user_id) DCNL DCSP is_already_subscribed = (self.user_id in subscriber_ids) DCNL DCSP is_user_visiting_own_profile = (self.user_id == user_settings.user_id) DCNL DCSP user_contributions = user_services.get_user_contributions(user_settings.user_id) DCNL DCSP if user_contributions: DCNL DCSP  DCSP created_exp_summary_dicts = summary_services.get_displayable_exp_summary_dicts_matching_ids(user_contributions.created_exploration_ids) DCNL DCSP  DCSP edited_exp_summary_dicts = summary_services.get_displayable_exp_summary_dicts_matching_ids(user_contributions.edited_exploration_ids) DCNL DCSP profile_is_of_current_user = (self.username == username) DCNL DCSP self.values.update({'profile_is_of_current_user': profile_is_of_current_user, 'profile_username': user_settings.username, 'user_bio': user_settings.user_bio, 'subject_interests': user_settings.subject_interests, 'first_contribution_msec': (user_settings.first_contribution_msec if user_settings.first_contribution_msec else None), 'profile_picture_data_url': user_settings.profile_picture_data_url, 'user_impact_score': user_services.get_user_impact_score(user_settings.user_id), 'created_exp_summary_dicts': created_exp_summary_dicts, 'edited_exp_summary_dicts': edited_exp_summary_dicts, 'is_already_subscribed': is_already_subscribed, 'is_user_visiting_own_profile': is_user_visiting_own_profile}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_manage_own_profile DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.PREFERENCES_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_PROFILE, 'LANGUAGE_CODES_AND_NAMES': utils.get_all_language_codes_and_names()}) DCNL DCSP self.render_template('pages/preferences/preferences.html', redirect_url_on_logout='/')
@acl_decorators.can_manage_own_profile DCNL def get(self): DCNL DCSP user_settings = user_services.get_user_settings(self.user_id) DCNL DCSP user_email_preferences = user_services.get_email_preferences(self.user_id) DCNL DCSP creators_subscribed_to = subscription_services.get_all_creators_subscribed_to(self.user_id) DCNL DCSP creators_settings = user_services.get_users_settings(creators_subscribed_to) DCNL DCSP subscription_list = [] DCNL DCSP for (index, creator_settings) in enumerate(creators_settings): DCNL DCSP  DCSP subscription_summary = {'creator_picture_data_url': creator_settings.profile_picture_data_url, 'creator_username': creator_settings.username, 'creator_impact': user_services.get_user_impact_score(creators_subscribed_to[index])} DCNL DCSP  DCSP subscription_list.append(subscription_summary) DCNL DCSP self.values.update({'preferred_language_codes': user_settings.preferred_language_codes, 'preferred_site_language_code': user_settings.preferred_site_language_code, 'profile_picture_data_url': user_settings.profile_picture_data_url, 'default_dashboard': user_settings.default_dashboard, 'user_bio': user_settings.user_bio, 'subject_interests': user_settings.subject_interests, 'can_receive_email_updates': user_email_preferences.can_receive_email_updates, 'can_receive_editor_role_email': user_email_preferences.can_receive_editor_role_email, 'can_receive_feedback_message_email': user_email_preferences.can_receive_feedback_message_email, 'can_receive_subscription_email': user_email_preferences.can_receive_subscription_email, 'subscription_list': subscription_list}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_manage_own_profile DCNL def put(self): DCNL DCSP update_type = self.payload.get('update_type') DCNL DCSP data = self.payload.get('data') DCNL DCSP if (update_type == 'user_bio'): DCNL DCSP  DCSP if (len(data) > feconf.MAX_BIO_LENGTH_IN_CHARS): DCNL DCSP  DCSP  DCSP raise self.InvalidInputException(('User DCSP bio DCSP exceeds DCSP maximum DCSP character DCSP limit: DCSP %s' % feconf.MAX_BIO_LENGTH_IN_CHARS)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user_services.update_user_bio(self.user_id, data) DCNL DCSP elif (update_type == 'subject_interests'): DCNL DCSP  DCSP user_services.update_subject_interests(self.user_id, data) DCNL DCSP elif (update_type == 'preferred_language_codes'): DCNL DCSP  DCSP user_services.update_preferred_language_codes(self.user_id, data) DCNL DCSP elif (update_type == 'preferred_site_language_code'): DCNL DCSP  DCSP user_services.update_preferred_site_language_code(self.user_id, data) DCNL DCSP elif (update_type == 'profile_picture_data_url'): DCNL DCSP  DCSP user_services.update_profile_picture_data_url(self.user_id, data) DCNL DCSP elif (update_type == 'default_dashboard'): DCNL DCSP  DCSP user_services.update_user_default_dashboard(self.user_id, data) DCNL DCSP elif (update_type == 'email_preferences'): DCNL DCSP  DCSP user_services.update_email_preferences(self.user_id, data['can_receive_email_updates'], data['can_receive_editor_role_email'], data['can_receive_feedback_message_email'], data['can_receive_subscription_email']) DCNL DCSP else: DCNL DCSP  DCSP raise self.InvalidInputException(('Invalid DCSP update DCSP type: DCSP %s' % update_type)) DCNL DCSP self.render_json({})
@acl_decorators.can_manage_own_profile DCNL def get(self): DCNL DCSP user_settings = user_services.get_user_settings(self.user_id) DCNL DCSP self.values.update({'profile_picture_data_url': user_settings.profile_picture_data_url}) DCNL DCSP self.render_json(self.values)
@acl_decorators.require_user_id_else_redirect_to_homepage DCNL def get(self): DCNL DCSP return_url = str(self.request.get('return_url', self.request.uri)) DCNL DCSP if user_services.has_fully_registered(self.user_id): DCNL DCSP  DCSP self.redirect(return_url) DCNL DCSP  DCSP return DCNL DCSP self.values.update({'meta_description': feconf.SIGNUP_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_SIGNUP, 'CAN_SEND_EMAILS': feconf.CAN_SEND_EMAILS}) DCNL DCSP self.render_template('pages/signup/signup.html')
@acl_decorators.require_user_id_else_redirect_to_homepage DCNL def get(self): DCNL DCSP user_settings = user_services.get_user_settings(self.user_id) DCNL DCSP self.render_json({'has_agreed_to_latest_terms': (user_settings.last_agreed_to_terms and (user_settings.last_agreed_to_terms >= feconf.REGISTRATION_PAGE_LAST_UPDATED_UTC)), 'has_ever_registered': bool((user_settings.username and user_settings.last_agreed_to_terms)), 'username': user_settings.username})
@acl_decorators.require_user_id_else_redirect_to_homepage DCNL def post(self): DCNL DCSP username = self.payload.get('username') DCNL DCSP agreed_to_terms = self.payload.get('agreed_to_terms') DCNL DCSP can_receive_email_updates = self.payload.get('can_receive_email_updates') DCNL DCSP has_ever_registered = user_services.has_ever_registered(self.user_id) DCNL DCSP has_fully_registered = user_services.has_fully_registered(self.user_id) DCNL DCSP if has_fully_registered: DCNL DCSP  DCSP self.render_json({}) DCNL DCSP  DCSP return DCNL DCSP if ((not isinstance(agreed_to_terms, bool)) or (not agreed_to_terms)): DCNL DCSP  DCSP raise self.InvalidInputException('In DCSP order DCSP to DCSP edit DCSP explorations DCSP on DCSP this DCSP site, DCSP you DCSP will DCSP need DCSP to DCSP accept DCSP the DCSP license DCSP terms.') DCNL DCSP else: DCNL DCSP  DCSP user_services.record_agreement_to_terms(self.user_id) DCNL DCSP if (not user_services.get_username(self.user_id)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user_services.set_username(self.user_id, username) DCNL DCSP  DCSP except utils.ValidationError as e: DCNL DCSP  DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP if (can_receive_email_updates is not None): DCNL DCSP  DCSP user_services.update_email_preferences(self.user_id, can_receive_email_updates, feconf.DEFAULT_EDITOR_ROLE_EMAIL_PREFERENCE, feconf.DEFAULT_FEEDBACK_MESSAGE_EMAIL_PREFERENCE, feconf.DEFAULT_SUBSCRIPTION_EMAIL_PREFERENCE) DCNL DCSP if (feconf.CAN_SEND_EMAILS and (not has_ever_registered)): DCNL DCSP  DCSP email_manager.send_post_signup_email(self.user_id) DCNL DCSP user_services.generate_initial_profile_picture(self.user_id) DCNL DCSP self.render_json({})
@acl_decorators.require_user_id_else_redirect_to_homepage DCNL def post(self): DCNL DCSP username = self.payload.get('username') DCNL DCSP try: DCNL DCSP  DCSP user_services.UserSettings.require_valid_username(username) DCNL DCSP except utils.ValidationError as e: DCNL DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP username_is_taken = user_services.is_username_taken(username) DCNL DCSP self.render_json({'username_is_taken': username_is_taken})
@acl_decorators.can_manage_own_profile DCNL def put(self): DCNL DCSP site_language_code = self.payload.get('site_language_code') DCNL DCSP user_services.update_preferred_site_language_code(self.user_id, site_language_code) DCNL DCSP self.render_json({})
def setUp(self): DCNL DCSP super(ReaderPermissionsTest, self).setUp() DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID, self.editor_id, title=self.UNICODE_TEST_STRING, category=self.UNICODE_TEST_STRING)
def setUp(self): DCNL DCSP super(ClassifyHandlerTest, self).setUp() DCNL DCSP self.enable_ml_classifiers = self.swap(feconf, 'ENABLE_ML_CLASSIFIERS', True) DCNL DCSP yaml_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '../tests/data/string_classifier_test.yaml') DCNL DCSP with open(yaml_path, 'r') as yaml_file: DCNL DCSP  DCSP self.yaml_content = yaml_file.read() DCNL DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME) DCNL DCSP self.exp_id = '0' DCNL DCSP self.title = 'Testing DCSP String DCSP Classifier' DCNL DCSP self.category = 'Test' DCNL DCSP exp_services.delete_demo(self.exp_id) DCNL DCSP exp_services.load_demo(self.exp_id) DCNL DCSP self.exploration = exp_domain.Exploration.from_untitled_yaml(self.exp_id, self.title, self.category, self.yaml_content)
def test_classification_handler(self): DCNL DCSP with self.enable_ml_classifiers: DCNL DCSP  DCSP old_state_dict = self.exploration.states['Home'].to_dict() DCNL DCSP  DCSP answer = 'Permutations' DCNL DCSP  DCSP params = {} DCNL DCSP  DCSP res = self.post_json(('/explorehandler/classify/%s' % self.exp_id), {'params': params, 'old_state': old_state_dict, 'answer': answer}) DCNL DCSP  DCSP self.assertEqual(res['outcome']['feedback'][0], '<p>Detected DCSP permutation.</p>')
def test_give_feedback_handler(self): DCNL DCSP self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME) DCNL DCSP exp_id = '0' DCNL DCSP exp_services.delete_demo('0') DCNL DCSP exp_services.load_demo('0') DCNL DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP exploration_dict = self.get_json(('%s/%s' % (feconf.EXPLORATION_INIT_URL_PREFIX, exp_id))) DCNL DCSP state_name_1 = exploration_dict['exploration']['init_state_name'] DCNL DCSP self.post_json(('/explorehandler/give_feedback/%s' % exp_id), {'state_name': state_name_1, 'feedback': 'This DCSP is DCSP a DCSP feedback DCSP message.'}) DCNL DCSP self.logout()
def test_get_init_params(self): DCNL DCSP independent_pc = param_domain.ParamChange('a', 'Copier', {'value': 'firstValue', 'parse_with_jinja': False}) DCNL DCSP dependent_pc = param_domain.ParamChange('b', 'Copier', {'value': '{{a}}', 'parse_with_jinja': True}) DCNL DCSP exp_param_specs = {'a': param_domain.ParamSpec('UnicodeString'), 'b': param_domain.ParamSpec('UnicodeString')} DCNL DCSP new_params = self.get_updated_param_dict({}, [independent_pc, dependent_pc], exp_param_specs) DCNL DCSP self.assertEqual(new_params, {'a': 'firstValue', 'b': 'firstValue'}) DCNL DCSP new_params = self.get_updated_param_dict({}, [dependent_pc, independent_pc], exp_param_specs) DCNL DCSP self.assertEqual(new_params, {'a': 'firstValue', 'b': ''})
def test_update_learner_params(self): DCNL DCSP independent_pc = param_domain.ParamChange('a', 'Copier', {'value': 'firstValue', 'parse_with_jinja': False}) DCNL DCSP dependent_pc = param_domain.ParamChange('b', 'Copier', {'value': '{{a}}', 'parse_with_jinja': True}) DCNL DCSP exp_param_specs = {'a': param_domain.ParamSpec('UnicodeString'), 'b': param_domain.ParamSpec('UnicodeString')} DCNL DCSP old_params = {} DCNL DCSP new_params = self.get_updated_param_dict(old_params, [independent_pc, dependent_pc], exp_param_specs) DCNL DCSP self.assertEqual(new_params, {'a': 'firstValue', 'b': 'firstValue'}) DCNL DCSP self.assertEqual(old_params, {}) DCNL DCSP old_params = {'a': 'secondValue'} DCNL DCSP new_params = self.get_updated_param_dict(old_params, [dependent_pc], exp_param_specs) DCNL DCSP self.assertEqual(new_params, {'a': 'secondValue', 'b': 'secondValue'}) DCNL DCSP self.assertEqual(old_params, {'a': 'secondValue'}) DCNL DCSP old_params = {} DCNL DCSP new_params = self.get_updated_param_dict(old_params, [dependent_pc], exp_param_specs) DCNL DCSP self.assertEqual(new_params, {'b': ''}) DCNL DCSP self.assertEqual(old_params, {})
def test_assign_and_read_ratings(self): DCNL DCSP self.signup('user@example.com', 'user') DCNL DCSP self.login('user@example.com') DCNL DCSP csrf_token = self.get_csrf_token_from_response(self.testapp.get(('/explore/%s' % self.EXP_ID))) DCNL DCSP ratings = self.get_json(('/explorehandler/rating/%s' % self.EXP_ID)) DCNL DCSP self.assertEqual(ratings['user_rating'], None) DCNL DCSP self.assertEqual(ratings['overall_ratings'], {'1': 0, '2': 0, '3': 0, '4': 0, '5': 0}) DCNL DCSP self.put_json(('/explorehandler/rating/%s' % self.EXP_ID), {'user_rating': 2}, csrf_token) DCNL DCSP ratings = self.get_json(('/explorehandler/rating/%s' % self.EXP_ID)) DCNL DCSP self.assertEqual(ratings['user_rating'], 2) DCNL DCSP self.assertEqual(ratings['overall_ratings'], {'1': 0, '2': 1, '3': 0, '4': 0, '5': 0}) DCNL DCSP self.login('user@example.com') DCNL DCSP self.put_json(('/explorehandler/rating/%s' % self.EXP_ID), {'user_rating': 5}, csrf_token) DCNL DCSP ratings = self.get_json(('/explorehandler/rating/%s' % self.EXP_ID)) DCNL DCSP self.assertEqual(ratings['user_rating'], 5) DCNL DCSP self.assertEqual(ratings['overall_ratings'], {'1': 0, '2': 0, '3': 0, '4': 0, '5': 1}) DCNL DCSP self.logout()
def test_non_logged_in_users_cannot_rate(self): DCNL DCSP self.signup('user@example.com', 'user') DCNL DCSP self.login('user@example.com') DCNL DCSP csrf_token = self.get_csrf_token_from_response(self.testapp.get(('/explore/%s' % self.EXP_ID))) DCNL DCSP self.logout() DCNL DCSP ratings = self.get_json(('/explorehandler/rating/%s' % self.EXP_ID)) DCNL DCSP self.assertEqual(ratings['user_rating'], None) DCNL DCSP self.assertEqual(ratings['overall_ratings'], {'1': 0, '2': 0, '3': 0, '4': 0, '5': 0}) DCNL DCSP self.put_json(('/explorehandler/rating/%s' % self.EXP_ID), {'user_rating': 1}, csrf_token, expected_status_int=401, expect_errors=True)
def test_ratings_by_different_users(self): DCNL DCSP self.signup('a@example.com', 'a') DCNL DCSP self.signup('b@example.com', 'b') DCNL DCSP self.login('a@example.com') DCNL DCSP csrf_token = self.get_csrf_token_from_response(self.testapp.get(('/explore/%s' % self.EXP_ID))) DCNL DCSP self.put_json(('/explorehandler/rating/%s' % self.EXP_ID), {'user_rating': 4}, csrf_token) DCNL DCSP self.logout() DCNL DCSP self.login('b@example.com') DCNL DCSP csrf_token = self.get_csrf_token_from_response(self.testapp.get(('/explore/%s' % self.EXP_ID))) DCNL DCSP ratings = self.get_json(('/explorehandler/rating/%s' % self.EXP_ID)) DCNL DCSP self.assertEqual(ratings['user_rating'], None) DCNL DCSP self.put_json(('/explorehandler/rating/%s' % self.EXP_ID), {'user_rating': 4}, csrf_token) DCNL DCSP ratings = self.get_json(('/explorehandler/rating/%s' % self.EXP_ID)) DCNL DCSP self.assertEqual(ratings['user_rating'], 4) DCNL DCSP self.assertEqual(ratings['overall_ratings'], {'1': 0, '2': 0, '3': 0, '4': 2, '5': 0}) DCNL DCSP self.logout()
def test_that_emails_are_sent(self): DCNL DCSP self.login(self.NEW_USER_EMAIL) DCNL DCSP response = self.testapp.get(('/explore/%s' % self.EXP_ID)) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP self.post_json(('%s/%s' % (feconf.FLAG_EXPLORATION_URL_PREFIX, self.EXP_ID)), {'report_text': self.REPORT_TEXT}, csrf_token) DCNL DCSP self.logout() DCNL DCSP expected_email_html_body = 'Hello DCSP Moderator,<br>newuser DCSP has DCSP flagged DCSP exploration DCSP "Welcome DCSP to DCSP Oppia!" DCSP on DCSP the DCSP following DCSP grounds: DCSP <br>AD DCSP .<br>You DCSP can DCSP modify DCSP the DCSP exploration DCSP by DCSP clicking DCSP <a DCSP href="https://www.oppia.org/create/0">here</a>.<br><br>Thanks!<br>- DCSP The DCSP Oppia DCSP Team<br><br>You DCSP can DCSP change DCSP your DCSP email DCSP preferences DCSP via DCSP the DCSP <a DCSP href="https://www.example.com">Preferences</a> DCSP page.' DCNL DCSP expected_email_text_body = 'Hello DCSP Moderator,\nnewuser DCSP has DCSP flagged DCSP exploration DCSP "Welcome DCSP to DCSP Oppia!" DCSP on DCSP the DCSP following DCSP grounds: DCSP \nAD DCSP .\nYou DCSP can DCSP modify DCSP the DCSP exploration DCSP by DCSP clicking DCSP here.\n\nThanks!\n- DCSP The DCSP Oppia DCSP Team\n\nYou DCSP can DCSP change DCSP your DCSP email DCSP preferences DCSP via DCSP the DCSP Preferences DCSP page.' DCNL DCSP with self.can_send_emails_ctx: DCNL DCSP  DCSP self.process_and_flush_pending_tasks() DCNL DCSP  DCSP messages = self.mail_stub.get_sent_messages(to=self.MODERATOR_EMAIL) DCNL DCSP  DCSP self.assertEqual(len(messages), 1) DCNL DCSP  DCSP self.assertEqual(messages[0].html.decode(), expected_email_html_body) DCNL DCSP  DCSP self.assertEqual(messages[0].body.decode(), expected_email_text_body)
def test_non_logged_in_users_cannot_report(self): DCNL DCSP self.login(self.NEW_USER_EMAIL) DCNL DCSP csrf_token = self.get_csrf_token_from_response(self.testapp.get(('/explore/%s' % self.EXP_ID))) DCNL DCSP self.logout() DCNL DCSP self.post_json(('%s/%s' % (feconf.FLAG_EXPLORATION_URL_PREFIX, self.EXP_ID)), {'report_text': self.REPORT_TEXT}, csrf_token, expected_status_int=401, expect_errors=True)
def test_independent_exp_complete_event_handler(self): DCNL DCSP self.login(self.USER_EMAIL) DCNL DCSP response = self.testapp.get(feconf.LIBRARY_INDEX_URL) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP payload = {'client_time_spent_in_secs': 0, 'params': {}, 'session_id': '1PZTCw9JY8y-8lqBeuoJS2ILZMxa5m8N', 'state_name': 'final', 'version': 1} DCNL DCSP self.post_json(('/explorehandler/exploration_complete_event/%s' % self.EXP_ID_0), payload, csrf_token) DCNL DCSP self.assertEqual(learner_progress_services.get_all_completed_exp_ids(self.user_id), [self.EXP_ID_0]) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_collection_ids(self.user_id), []) DCNL DCSP self.post_json(('/explorehandler/exploration_complete_event/%s' % self.EXP_ID_1_0), payload, csrf_token) DCNL DCSP self.assertEqual(learner_progress_services.get_all_completed_exp_ids(self.user_id), [self.EXP_ID_0, self.EXP_ID_1_0]) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_collection_ids(self.user_id), [])
def test_exp_complete_event_in_collection(self): DCNL DCSP self.login(self.USER_EMAIL) DCNL DCSP response = self.testapp.get(feconf.LIBRARY_INDEX_URL) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP payload = {'client_time_spent_in_secs': 0, 'collection_id': self.COL_ID_1, 'params': {}, 'session_id': '1PZTCw9JY8y-8lqBeuoJS2ILZMxa5m8N', 'state_name': 'final', 'version': 1} DCNL DCSP self.post_json(('/explorehandler/exploration_complete_event/%s' % self.EXP_ID_1_0), payload, csrf_token) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_collection_ids(self.user_id), [self.COL_ID_1]) DCNL DCSP self.assertEqual(learner_progress_services.get_all_completed_exp_ids(self.user_id), [self.EXP_ID_1_0]) DCNL DCSP self.post_json(('/explorehandler/exploration_complete_event/%s' % self.EXP_ID_1_1), payload, csrf_token) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_collection_ids(self.user_id), []) DCNL DCSP self.assertEqual(learner_progress_services.get_all_completed_collection_ids(self.user_id), [self.COL_ID_1]) DCNL DCSP self.assertEqual(learner_progress_services.get_all_completed_exp_ids(self.user_id), [self.EXP_ID_1_0, self.EXP_ID_1_1])
def test_exp_incomplete_event_handler(self): DCNL DCSP self.login(self.USER_EMAIL) DCNL DCSP response = self.testapp.get(feconf.LIBRARY_INDEX_URL) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP payload = {'client_time_spent_in_secs': 0, 'params': {}, 'session_id': '1PZTCw9JY8y-8lqBeuoJS2ILZMxa5m8N', 'state_name': 'middle', 'version': 1} DCNL DCSP self.post_json(('/explorehandler/exploration_maybe_leave_event/%s' % self.EXP_ID_0), payload, csrf_token) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_exp_ids(self.user_id), [self.EXP_ID_0]) DCNL DCSP self.post_json(('/explorehandler/exploration_maybe_leave_event/%s' % self.EXP_ID_0), payload, csrf_token) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_exp_ids(self.user_id), [self.EXP_ID_0]) DCNL DCSP payload = {'client_time_spent_in_secs': 0, 'collection_id': self.COL_ID_1, 'params': {}, 'session_id': '1PZTCw9JY8y-8lqBeuoJS2ILZMxa5m8N', 'state_name': 'middle', 'version': 1} DCNL DCSP self.post_json(('/explorehandler/exploration_maybe_leave_event/%s' % self.EXP_ID_1_0), payload, csrf_token) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_exp_ids(self.user_id), [self.EXP_ID_0, self.EXP_ID_1_0]) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_collection_ids(self.user_id), [self.COL_ID_1])
def test_remove_exp_from_incomplete_list_handler(self): DCNL DCSP self.login(self.USER_EMAIL) DCNL DCSP state_name = 'state_name' DCNL DCSP version = 1 DCNL DCSP learner_progress_services.mark_exploration_as_incomplete(self.user_id, self.EXP_ID_0, state_name, version) DCNL DCSP learner_progress_services.mark_exploration_as_incomplete(self.user_id, self.EXP_ID_1, state_name, version) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_exp_ids(self.user_id), [self.EXP_ID_0, self.EXP_ID_1]) DCNL DCSP self.testapp.delete(str(('%s/%s/%s' % (feconf.LEARNER_INCOMPLETE_ACTIVITY_DATA_URL, constants.ACTIVITY_TYPE_EXPLORATION, self.EXP_ID_0)))) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_exp_ids(self.user_id), [self.EXP_ID_1]) DCNL DCSP self.testapp.delete(str(('%s/%s/%s' % (feconf.LEARNER_INCOMPLETE_ACTIVITY_DATA_URL, constants.ACTIVITY_TYPE_EXPLORATION, self.EXP_ID_1)))) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_exp_ids(self.user_id), [])
def test_remove_collection_from_incomplete_list_handler(self): DCNL DCSP self.login(self.USER_EMAIL) DCNL DCSP learner_progress_services.mark_collection_as_incomplete(self.user_id, self.COL_ID_0) DCNL DCSP learner_progress_services.mark_collection_as_incomplete(self.user_id, self.COL_ID_1) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_collection_ids(self.user_id), [self.COL_ID_0, self.COL_ID_1]) DCNL DCSP self.testapp.delete(str(('%s/%s/%s' % (feconf.LEARNER_INCOMPLETE_ACTIVITY_DATA_URL, constants.ACTIVITY_TYPE_COLLECTION, self.COL_ID_0)))) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_collection_ids(self.user_id), [self.COL_ID_1]) DCNL DCSP self.testapp.delete(str(('%s/%s/%s' % (feconf.LEARNER_INCOMPLETE_ACTIVITY_DATA_URL, constants.ACTIVITY_TYPE_COLLECTION, self.COL_ID_1)))) DCNL DCSP self.assertEqual(learner_progress_services.get_all_incomplete_collection_ids(self.user_id), [])
def test_logged_out_homepage(self): DCNL DCSP response = self.testapp.get('/') DCNL DCSP self.assertEqual(response.status_int, 302) DCNL DCSP self.assertIn('splash', response.headers['location'])
def test_notifications_dashboard_redirects_for_logged_out_users(self): DCNL DCSP response = self.testapp.get('/notifications_dashboard') DCNL DCSP self.assertEqual(response.status_int, 302) DCNL DCSP self.assertIn('signup', response.headers['location']) DCNL DCSP self.assertIn('notifications_dashboard', response.headers['location']) DCNL DCSP self.login('reader@example.com') DCNL DCSP response = self.testapp.get('/notifications_dashboard') DCNL DCSP self.assertEqual(response.status_int, 302) DCNL DCSP self.logout()
def test_logged_in_notifications_dashboard(self): DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/notifications_dashboard') DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.logout()
def _record_start(self, exp_id, exp_version, state): DCNL DCSP event_services.StartExplorationEventHandler.record(exp_id, exp_version, state, self.USER_SESSION_ID, {}, feconf.PLAY_TYPE_NORMAL)
def _rate_exploration(self, exp_id, ratings): DCNL DCSP user_ids = [('user%d' % i) for i in range(len(ratings))] DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP for (ind, user_id) in enumerate(user_ids): DCNL DCSP  DCSP rating_services.assign_rating_to_exploration(user_id, exp_id, ratings[ind]) DCNL DCSP self.process_and_flush_pending_tasks()
def _get_recent_notifications_mock_by_viewer(self, unused_user_id): DCNL DCSP return (100000, [{'activity_id': 'exp_id', 'activity_title': 'exp_title', 'author_id': self.viewer_id, 'last_updated_ms': 100000, 'subject': 'Feedback DCSP Message DCSP Subject', 'type': feconf.UPDATE_TYPE_FEEDBACK_MESSAGE}])
def _get_recent_notifications_mock_by_anonymous_user(self, unused_user_id): DCNL DCSP return (200000, [{'activity_id': 'exp_id', 'activity_title': 'exp_title', 'author_id': None, 'last_updated_ms': 100000, 'subject': 'Feedback DCSP Message DCSP Subject', 'type': feconf.UPDATE_TYPE_FEEDBACK_MESSAGE}])
def test_author_ids_are_handled_correctly(self): DCNL DCSP with self.swap(user_jobs_continuous.DashboardRecentUpdatesAggregator, 'get_recent_notifications', self._get_recent_notifications_mock_by_viewer): DCNL DCSP  DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP  DCSP response = self.get_json(self.DASHBOARD_DATA_URL) DCNL DCSP  DCSP self.assertEqual(len(response['recent_notifications']), 1) DCNL DCSP  DCSP self.assertEqual(response['recent_notifications'][0]['author_username'], self.VIEWER_USERNAME) DCNL DCSP  DCSP self.assertNotIn('author_id', response['recent_notifications'][0]) DCNL DCSP with self.swap(user_jobs_continuous.DashboardRecentUpdatesAggregator, 'get_recent_notifications', self._get_recent_notifications_mock_by_anonymous_user): DCNL DCSP  DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP  DCSP response = self.get_json(self.DASHBOARD_DATA_URL) DCNL DCSP  DCSP self.assertEqual(len(response['recent_notifications']), 1) DCNL DCSP  DCSP self.assertEqual(response['recent_notifications'][0]['author_username'], '') DCNL DCSP  DCSP self.assertNotIn('author_id', response['recent_notifications'][0])
def test_new_exploration_ids(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get(feconf.CREATOR_DASHBOARD_URL) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP exp_a_id = self.post_json(feconf.NEW_EXPLORATION_URL, {}, csrf_token)[creator_dashboard.EXPLORATION_ID_KEY] DCNL DCSP self.assertEqual(len(exp_a_id), 12) DCNL DCSP self.logout()
def test_exploration_upload_button(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get(feconf.CREATOR_DASHBOARD_URL) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP response.mustcontain(no=['ng-click="showUploadExplorationModal()"']) DCNL DCSP with self.swap(feconf, 'ALLOW_YAML_FILE_UPLOAD', True): DCNL DCSP  DCSP response = self.testapp.get(feconf.CREATOR_DASHBOARD_URL) DCNL DCSP  DCSP self.assertEqual(response.status_int, 200) DCNL DCSP  DCSP response.mustcontain('ng-click="showUploadExplorationModal()"') DCNL DCSP self.logout()
def setUp(self): DCNL DCSP super(CollectionViewerPermissionsTest, self).setUp() DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP self.signup(self.NEW_USER_EMAIL, self.NEW_USER_USERNAME) DCNL DCSP self.new_user_id = self.get_user_id_from_email(self.NEW_USER_EMAIL) DCNL DCSP self.save_new_valid_collection(self.COLLECTION_ID, self.editor_id)
def test_welcome_collection(self): DCNL DCSP collection_services.load_demo('0') DCNL DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP response_dict = self.get_json(('%s/0' % feconf.COLLECTION_DATA_URL_PREFIX)) DCNL DCSP collection_dict = response_dict['collection'] DCNL DCSP self.assertEqual(collection_dict['objective'], 'To DCSP introduce DCSP collections DCSP using DCSP demo DCSP explorations.') DCNL DCSP self.assertEqual(collection_dict['category'], 'Welcome') DCNL DCSP self.assertEqual(collection_dict['title'], 'Introduction DCSP to DCSP Collections DCSP in DCSP Oppia') DCNL DCSP self.assertEqual(len(collection_dict['nodes']), 5) DCNL DCSP playthrough_dict = collection_dict['playthrough_dict'] DCNL DCSP self.assertEqual(playthrough_dict['next_exploration_ids'], ['0']) DCNL DCSP self.assertEqual(playthrough_dict['completed_exploration_ids'], []) DCNL DCSP collection_services.record_played_exploration_in_collection_context(self.viewer_id, '0', '0') DCNL DCSP response_dict = self.get_json(('%s/0' % feconf.COLLECTION_DATA_URL_PREFIX)) DCNL DCSP collection_dict = response_dict['collection'] DCNL DCSP playthrough_dict = collection_dict['playthrough_dict'] DCNL DCSP self.assertEqual(playthrough_dict['next_exploration_ids'], ['13']) DCNL DCSP self.assertEqual(playthrough_dict['completed_exploration_ids'], ['0']) DCNL DCSP collection_services.record_played_exploration_in_collection_context(self.viewer_id, '0', '13') DCNL DCSP response_dict = self.get_json(('%s/0' % feconf.COLLECTION_DATA_URL_PREFIX)) DCNL DCSP collection_dict = response_dict['collection'] DCNL DCSP playthrough_dict = collection_dict['playthrough_dict'] DCNL DCSP self.assertEqual(playthrough_dict['next_exploration_ids'], ['4']) DCNL DCSP self.assertEqual(playthrough_dict['completed_exploration_ids'], ['0', '13']) DCNL DCSP collection_services.record_played_exploration_in_collection_context(self.viewer_id, '0', '14') DCNL DCSP response_dict = self.get_json(('%s/0' % feconf.COLLECTION_DATA_URL_PREFIX)) DCNL DCSP collection_dict = response_dict['collection'] DCNL DCSP playthrough_dict = collection_dict['playthrough_dict'] DCNL DCSP self.assertEqual(playthrough_dict['next_exploration_ids'], ['4']) DCNL DCSP self.assertEqual(playthrough_dict['completed_exploration_ids'], ['0', '13', '14']) DCNL DCSP collection_services.record_played_exploration_in_collection_context(self.viewer_id, '0', '15') DCNL DCSP collection_services.record_played_exploration_in_collection_context(self.viewer_id, '0', '4') DCNL DCSP response_dict = self.get_json(('%s/0' % feconf.COLLECTION_DATA_URL_PREFIX)) DCNL DCSP collection_dict = response_dict['collection'] DCNL DCSP playthrough_dict = collection_dict['playthrough_dict'] DCNL DCSP self.assertEqual(playthrough_dict['next_exploration_ids'], []) DCNL DCSP self.assertEqual(playthrough_dict['completed_exploration_ids'], ['0', '13', '14', '15', '4'])
@acl_decorators.open_access DCNL def get(self): DCNL DCSP search_mode = ('search' in self.request.url) DCNL DCSP if search_mode: DCNL DCSP  DCSP page_mode = feconf.LIBRARY_PAGE_MODE_SEARCH DCNL DCSP else: DCNL DCSP  DCSP page_mode = feconf.LIBRARY_PAGE_MODE_INDEX DCNL DCSP self.values.update({'meta_description': (feconf.SEARCH_PAGE_DESCRIPTION if search_mode else feconf.LIBRARY_PAGE_DESCRIPTION), 'nav_mode': feconf.NAV_MODE_LIBRARY, 'has_fully_registered': bool((self.user_id and user_services.has_fully_registered(self.user_id))), 'LANGUAGE_CODES_AND_NAMES': utils.get_all_language_codes_and_names(), 'page_mode': page_mode, 'SEARCH_DROPDOWN_CATEGORIES': feconf.SEARCH_DROPDOWN_CATEGORIES}) DCNL DCSP self.render_template('pages/library/library.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP summary_dicts_by_category = summary_services.get_library_groups([constants.DEFAULT_LANGUAGE_CODE]) DCNL DCSP top_rated_activity_summary_dicts = summary_services.get_top_rated_exploration_summary_dicts([constants.DEFAULT_LANGUAGE_CODE], feconf.NUMBER_OF_TOP_RATED_EXPLORATIONS_FOR_LIBRARY_PAGE) DCNL DCSP featured_activity_summary_dicts = summary_services.get_featured_activity_summary_dicts([constants.DEFAULT_LANGUAGE_CODE]) DCNL DCSP preferred_language_codes = [constants.DEFAULT_LANGUAGE_CODE] DCNL DCSP if self.user_id: DCNL DCSP  DCSP user_settings = user_services.get_user_settings(self.user_id) DCNL DCSP  DCSP preferred_language_codes = user_settings.preferred_language_codes DCNL DCSP if top_rated_activity_summary_dicts: DCNL DCSP  DCSP summary_dicts_by_category.insert(0, {'activity_summary_dicts': top_rated_activity_summary_dicts, 'categories': [], 'header_i18n_id': feconf.LIBRARY_CATEGORY_TOP_RATED_EXPLORATIONS, 'has_full_results_page': True, 'full_results_url': feconf.LIBRARY_TOP_RATED_URL, 'protractor_id': 'top-rated'}) DCNL DCSP if featured_activity_summary_dicts: DCNL DCSP  DCSP summary_dicts_by_category.insert(0, {'activity_summary_dicts': featured_activity_summary_dicts, 'categories': [], 'header_i18n_id': feconf.LIBRARY_CATEGORY_FEATURED_ACTIVITIES, 'has_full_results_page': False, 'full_results_url': None}) DCNL DCSP self.values.update({'activity_summary_dicts_by_category': summary_dicts_by_category, 'preferred_language_codes': preferred_language_codes}) DCNL DCSP self.render_json(self.values)
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.LIBRARY_GROUP_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_LIBRARY, 'has_fully_registered': bool((self.user_id and user_services.has_fully_registered(self.user_id))), 'LANGUAGE_CODES_AND_NAMES': utils.get_all_language_codes_and_names(), 'page_mode': feconf.LIBRARY_PAGE_MODE_GROUP, 'SEARCH_DROPDOWN_CATEGORIES': feconf.SEARCH_DROPDOWN_CATEGORIES}) DCNL DCSP self.render_template('pages/library/library.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP group_name = self.request.get('group_name') DCNL DCSP activity_list = [] DCNL DCSP header_i18n_id = '' DCNL DCSP if (group_name == feconf.LIBRARY_GROUP_RECENTLY_PUBLISHED): DCNL DCSP  DCSP recently_published_summary_dicts = summary_services.get_recently_published_exp_summary_dicts(feconf.RECENTLY_PUBLISHED_QUERY_LIMIT_FULL_PAGE) DCNL DCSP  DCSP if recently_published_summary_dicts: DCNL DCSP  DCSP  DCSP activity_list = recently_published_summary_dicts DCNL DCSP  DCSP  DCSP header_i18n_id = feconf.LIBRARY_CATEGORY_RECENTLY_PUBLISHED DCNL DCSP elif (group_name == feconf.LIBRARY_GROUP_TOP_RATED): DCNL DCSP  DCSP top_rated_activity_summary_dicts = summary_services.get_top_rated_exploration_summary_dicts([constants.DEFAULT_LANGUAGE_CODE], feconf.NUMBER_OF_TOP_RATED_EXPLORATIONS_FULL_PAGE) DCNL DCSP  DCSP if top_rated_activity_summary_dicts: DCNL DCSP  DCSP  DCSP activity_list = top_rated_activity_summary_dicts DCNL DCSP  DCSP  DCSP header_i18n_id = feconf.LIBRARY_CATEGORY_TOP_RATED_EXPLORATIONS DCNL DCSP elif (group_name == feconf.LIBRARY_CATEGORY_SPLASH_PAGE_FEATURED): DCNL DCSP  DCSP splash_page_featured_exploration_ids = ['0', 'yvqBFOQNDz5e', 'BvpDpLSmO2Iu', 'gC4_ggkWar-L'] DCNL DCSP  DCSP activity_list = summary_services.get_displayable_exp_summary_dicts_matching_ids(splash_page_featured_exploration_ids) DCNL DCSP else: DCNL DCSP  DCSP return self.PageNotFoundException DCNL DCSP preferred_language_codes = [constants.DEFAULT_LANGUAGE_CODE] DCNL DCSP if self.user_id: DCNL DCSP  DCSP user_settings = user_services.get_user_settings(self.user_id) DCNL DCSP  DCSP preferred_language_codes = user_settings.preferred_language_codes DCNL DCSP self.values.update({'activity_list': activity_list, 'header_i18n_id': header_i18n_id, 'preferred_language_codes': preferred_language_codes}) DCNL DCSP self.render_json(self.values)
@acl_decorators.open_access DCNL def get(self): DCNL DCSP query_string = utils.unescape_encoded_uri_component(self.request.get('q')) DCNL DCSP remove_punctuation_map = dict(((ord(char), None) for char in string.punctuation)) DCNL DCSP query_string = query_string.translate(remove_punctuation_map) DCNL DCSP if self.request.get('category'): DCNL DCSP  DCSP query_string += (' DCSP category=%s' % self.request.get('category')) DCNL DCSP if self.request.get('language_code'): DCNL DCSP  DCSP query_string += (' DCSP language_code=%s' % self.request.get('language_code')) DCNL DCSP search_cursor = self.request.get('cursor', None) DCNL DCSP (activity_list, new_search_cursor) = get_matching_activity_dicts(query_string, search_cursor) DCNL DCSP self.values.update({'activity_list': activity_list, 'search_cursor': new_search_cursor}) DCNL DCSP self.render_json(self.values)
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.redirect('/library')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP try: DCNL DCSP  DCSP exp_ids = json.loads(self.request.get('stringified_exp_ids')) DCNL DCSP except Exception: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP include_private_exps_str = self.request.get('include_private_explorations') DCNL DCSP include_private_exps = ((include_private_exps_str.lower() == 'true') if include_private_exps_str else False) DCNL DCSP editor_user_id = (self.user_id if include_private_exps else None) DCNL DCSP if (not editor_user_id): DCNL DCSP  DCSP include_private_exps = False DCNL DCSP if ((not isinstance(exp_ids, list)) or (not all([isinstance(exp_id, basestring) for exp_id in exp_ids]))): DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP if include_private_exps: DCNL DCSP  DCSP summaries = summary_services.get_displayable_exp_summary_dicts_matching_ids(exp_ids, editor_user_id=editor_user_id) DCNL DCSP else: DCNL DCSP  DCSP summaries = summary_services.get_displayable_exp_summary_dicts_matching_ids(exp_ids) DCNL DCSP self.values.update({'summaries': summaries}) DCNL DCSP self.render_json(self.values)
@acl_decorators.open_access DCNL def get(self): DCNL DCSP try: DCNL DCSP  DCSP collection_ids = json.loads(self.request.get('stringified_collection_ids')) DCNL DCSP except Exception: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP summaries = summary_services.get_displayable_collection_summary_dicts_matching_ids(collection_ids) DCNL DCSP self.values.update({'summaries': summaries}) DCNL DCSP self.render_json(self.values)
@acl_decorators.open_access DCNL def get(self, obj_type): DCNL DCSP try: DCNL DCSP  DCSP self.response.write(obj_services.Registry.get_object_class_by_type(obj_type).get_editor_html_template()) DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.error(('Object DCSP editor DCSP not DCSP found: DCSP %s. DCSP %s' % (obj_type, e))) DCNL DCSP  DCSP raise self.PageNotFoundException
@acl_decorators.open_access DCNL def get(self, generator_id): DCNL DCSP try: DCNL DCSP  DCSP self.response.write(value_generators_domain.Registry.get_generator_class_by_id(generator_id).get_html_template()) DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.error(('Value DCSP generator DCSP not DCSP found: DCSP %s. DCSP %s' % (generator_id, e))) DCNL DCSP  DCSP raise self.PageNotFoundException
@acl_decorators.open_access DCNL def get(self, exploration_id, encoded_filepath): DCNL DCSP try: DCNL DCSP  DCSP filepath = urllib.unquote(encoded_filepath) DCNL DCSP  DCSP file_format = filepath[(filepath.rfind('.') + 1):] DCNL DCSP  DCSP self.response.headers['Content-Type'] = str(('image/%s' % file_format)) DCNL DCSP  DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(exploration_id)) DCNL DCSP  DCSP raw = fs.get(filepath) DCNL DCSP  DCSP self.response.cache_control.no_cache = None DCNL DCSP  DCSP self.response.cache_control.public = True DCNL DCSP  DCSP self.response.cache_control.max_age = 600 DCNL DCSP  DCSP self.response.write(raw) DCNL DCSP except: DCNL DCSP  DCSP raise self.PageNotFoundException
@acl_decorators.open_access DCNL def get(self, exploration_id, filename): DCNL DCSP file_format = filename[(filename.rfind('.') + 1):] DCNL DCSP self.response.headers['Content-Type'] = str(('audio/%s' % file_format)) DCNL DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(exploration_id)) DCNL DCSP try: DCNL DCSP  DCSP raw = fs.get(('%s/%s' % (self._AUDIO_PATH_PREFIX, filename))) DCNL DCSP except: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP self.response.cache_control.no_cache = None DCNL DCSP self.response.cache_control.public = True DCNL DCSP self.response.cache_control.max_age = 600 DCNL DCSP self.response.write(raw)
def test_about_page(self): DCNL DCSP response = self.testapp.get('/about') DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.assertEqual(response.content_type, 'text/html') DCNL DCSP response.mustcontain('I18N_ABOUT_PAGE_CREDITS_TAB_HEADING', 'I18N_ABOUT_PAGE_FOUNDATION_TAB_PARAGRAPH_5_LICENSE_HEADING')
def setUp(self): DCNL DCSP super(AdminIntegrationTest, self).setUp() DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)
def test_admin_page_rights(self): DCNL DCSP response = self.testapp.get('/admin') DCNL DCSP self.assertEqual(response.status_int, 302) DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/admin', expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 401) DCNL DCSP self.logout() DCNL DCSP self.login(self.ADMIN_EMAIL, is_super_admin=True) DCNL DCSP response = self.testapp.get('/admin') DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.logout()
def test_change_configuration_property(self): DCNL DCSP self.login(self.ADMIN_EMAIL, is_super_admin=True) DCNL DCSP response = self.testapp.get('/admin') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP response_dict = self.get_json('/adminhandler') DCNL DCSP response_config_properties = response_dict['config_properties'] DCNL DCSP self.assertDictContainsSubset({'value': ''}, response_config_properties[base.BEFORE_END_HEAD_TAG_HOOK.name]) DCNL DCSP payload = {'action': 'save_config_properties', 'new_config_property_values': {base.BEFORE_END_HEAD_TAG_HOOK.name: self.UNICODE_TEST_STRING}} DCNL DCSP self.post_json('/adminhandler', payload, csrf_token) DCNL DCSP response_dict = self.get_json('/adminhandler') DCNL DCSP response_config_properties = response_dict['config_properties'] DCNL DCSP self.assertDictContainsSubset({'value': self.UNICODE_TEST_STRING}, response_config_properties[base.BEFORE_END_HEAD_TAG_HOOK.name]) DCNL DCSP self.logout()
def test_change_about_page_config_property(self): DCNL DCSP new_config_value = 'new_config_value' DCNL DCSP response = self.testapp.get('/about') DCNL DCSP self.assertNotIn(new_config_value, response.body) DCNL DCSP self.login(self.ADMIN_EMAIL, is_super_admin=True) DCNL DCSP response = self.testapp.get('/admin') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP self.post_json('/adminhandler', {'action': 'save_config_properties', 'new_config_property_values': {base.BEFORE_END_HEAD_TAG_HOOK.name: new_config_value}}, csrf_token) DCNL DCSP response = self.testapp.get('/about') DCNL DCSP self.assertIn(new_config_value, response.body)
def setUp(self): DCNL DCSP super(AdminRoleHandlerTest, self).setUp() DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.set_admins([self.ADMIN_USERNAME])
def setUp(self): DCNL DCSP super(DataExtractionQueryHandlerTests, self).setUp() DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP self.exploration = self.save_new_valid_exploration(self.EXP_ID, self.editor_id, end_state_name='End') DCNL DCSP stats_services.record_answer(self.EXP_ID, self.exploration.version, self.exploration.init_state_name, 'TextInput', stats_domain.SubmittedAnswer('first DCSP answer', 'TextInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, {}, 'a_session_id_val', 1.0)) DCNL DCSP stats_services.record_answer(self.EXP_ID, self.exploration.version, self.exploration.init_state_name, 'TextInput', stats_domain.SubmittedAnswer('second DCSP answer', 'TextInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, {}, 'a_session_id_val', 1.0))
def setUp(self): DCNL DCSP super(SslChallengeHandlerTests, self).setUp() DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.login(self.ADMIN_EMAIL, is_super_admin=True) DCNL DCSP response = self.testapp.get('/admin') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP payload = {'action': 'save_config_properties', 'new_config_property_values': {admin.SSL_CHALLENGE_RESPONSES.name: [{'challenge': self.CHALLENGE, 'response': self.RESPONSE}]}} DCNL DCSP self.post_json('/adminhandler', payload, csrf_token) DCNL DCSP self.logout()
@acl_decorators.open_access DCNL def get(self): DCNL DCSP c_value = self.request.get('c') DCNL DCSP self.values.update({'meta_description': feconf.SPLASH_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_SPLASH}) DCNL DCSP if (not c_value): DCNL DCSP  DCSP random_number = random.choice([0, 5, 6]) DCNL DCSP  DCSP if (random_number == 0): DCNL DCSP  DCSP  DCSP self.render_template('pages/splash/splash.html') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.redirect(('/splash?c=nv%d' % random_number)) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self.render_template(('pages/splash/splash_%s.html' % c_value)) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP arguments = self.request.arguments() DCNL DCSP  DCSP  DCSP query_suffix = '&'.join([('%s=%s' % (arg_name, self.request.get(arg_name))) for arg_name in arguments if (arg_name != 'c')]) DCNL DCSP  DCSP  DCSP target_url = feconf.SPLASH_URL DCNL DCSP  DCSP  DCSP if query_suffix: DCNL DCSP  DCSP  DCSP  DCSP target_url += ('?%s' % query_suffix) DCNL DCSP  DCSP  DCSP self.redirect(target_url) DCNL DCSP  DCSP  DCSP return
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.ABOUT_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_ABOUT}) DCNL DCSP self.render_template('pages/about/about.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.GET_STARTED_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_GET_STARTED}) DCNL DCSP self.render_template('pages/get_started/get_started.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.TEACH_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_TEACH}) DCNL DCSP self.render_template('pages/teach/teach.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.BLOG_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_BLOG}) DCNL DCSP self.render_template('pages/blog/blog.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.CONTACT_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_CONTACT}) DCNL DCSP self.render_template('pages/contact/contact.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.DONATE_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_DONATE}) DCNL DCSP self.render_template('pages/donate/donate.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.THANKS_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_THANKS}) DCNL DCSP self.render_template('pages/thanks/thanks.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP (_, netloc, _, _, _) = urlparse.urlsplit(self.request.uri) DCNL DCSP self.values.update({'full_google_group_url': ('%s&showtabs=false&hideforumtitle=true&parenturl=%s' % (feconf.EMBEDDED_GOOGLE_GROUP_URL, urllib.quote(self.request.uri, safe=''))), 'meta_description': feconf.FORUM_PAGE_DESCRIPTION, 'on_localhost': netloc.startswith('localhost')}) DCNL DCSP self.render_template('pages/forum/forum.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.values.update({'meta_description': feconf.TERMS_PAGE_DESCRIPTION}) DCNL DCSP self.render_template('pages/terms/terms.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.render_template('pages/privacy/privacy.html')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.redirect('/about')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.redirect('/teach')
@acl_decorators.open_access DCNL def get(self): DCNL DCSP self.render_template('pages/tests/console_errors.html')
@acl_decorators.open_access DCNL def get(self, *args, **kwargs): DCNL DCSP self.render_template('pages/maintenance/maintenance.html')
def setUp(self): DCNL DCSP super(BaseEditorControllerTest, self).setUp() DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME) DCNL DCSP self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME) DCNL DCSP self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME) DCNL DCSP self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL) DCNL DCSP self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP self.viewer_id = self.get_user_id_from_email(self.VIEWER_EMAIL) DCNL DCSP self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL) DCNL DCSP self.moderator_id = self.get_user_id_from_email(self.MODERATOR_EMAIL) DCNL DCSP self.set_admins([self.ADMIN_USERNAME]) DCNL DCSP self.set_moderators([self.MODERATOR_USERNAME])
def assert_can_edit(self, response_body): DCNL DCSP self.assertIn(self.CAN_EDIT_STR, response_body) DCNL DCSP self.assertNotIn(self.CANNOT_EDIT_STR, response_body)
def assert_cannot_edit(self, response_body): DCNL DCSP self.assertIn(self.CANNOT_EDIT_STR, response_body) DCNL DCSP self.assertNotIn(self.CAN_EDIT_STR, response_body)
def test_editor_page(self): DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.assertIn('Help DCSP others DCSP learn DCSP new DCSP things.', response.body) DCNL DCSP self.assert_cannot_edit(response.body) DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP self.assertIn('Help DCSP others DCSP learn DCSP new DCSP things.', response.body) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.assert_can_edit(response.body) DCNL DCSP self.assertIn('Stats', response.body) DCNL DCSP self.assertIn('History', response.body) DCNL DCSP self.logout()
def test_new_state_template(self): DCNL DCSP exploration = exp_services.get_exploration_by_id('0') DCNL DCSP exploration.add_states([feconf.DEFAULT_INIT_STATE_NAME]) DCNL DCSP new_state_dict = exploration.states[feconf.DEFAULT_INIT_STATE_NAME].to_dict() DCNL DCSP self.assertEqual(new_state_dict, editor.NEW_STATE_TEMPLATE)
def test_that_default_exploration_cannot_be_published(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get(feconf.CREATOR_DASHBOARD_URL) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP exp_id = self.post_json(feconf.NEW_EXPLORATION_URL, {}, csrf_token)[creator_dashboard.EXPLORATION_ID_KEY] DCNL DCSP response = self.testapp.get(('/create/%s' % exp_id)) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP publish_url = ('%s/%s' % (feconf.EXPLORATION_STATUS_PREFIX, exp_id)) DCNL DCSP self.put_json(publish_url, {'make_public': True}, csrf_token, expect_errors=True, expected_status_int=400) DCNL DCSP self.logout()
def test_add_new_state_error_cases(self): DCNL DCSP current_version = 1 DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP def _get_payload(new_state_name, version=None): DCNL DCSP  DCSP result = {'change_list': [{'cmd': 'add_state', 'state_name': new_state_name}], 'commit_message': 'Add DCSP new DCSP state'} DCNL DCSP  DCSP if (version is not None): DCNL DCSP  DCSP  DCSP result['version'] = version DCNL DCSP  DCSP return result DCNL DCSP def _put_and_expect_400_error(payload): DCNL DCSP  DCSP return self.put_json('/createhandler/data/0', payload, csrf_token, expect_errors=True, expected_status_int=400) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload('New DCSP state')) DCNL DCSP self.assertIn('a DCSP version DCSP must DCSP be DCSP specified', response_dict['error']) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload('New DCSP state', 123)) DCNL DCSP self.assertIn('which DCSP is DCSP too DCSP old', response_dict['error']) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload('', current_version)) DCNL DCSP self.assertIn('should DCSP be DCSP between DCSP 1 DCSP and DCSP 50', response_dict['error']) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload(('a' * 100), current_version)) DCNL DCSP self.assertIn('should DCSP be DCSP between DCSP 1 DCSP and DCSP 50', response_dict['error']) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload('[Bad DCSP State DCSP Name]', current_version)) DCNL DCSP self.assertIn('Invalid DCSP character DCSP [', response_dict['error']) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload(' DCSP  DCSP aa', current_version)) DCNL DCSP self.assertIn('start DCSP or DCSP end DCSP with DCSP whitespace', response_dict['error']) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload('aa DCTB ', current_version)) DCNL DCSP self.assertIn('end DCSP with DCSP whitespace', response_dict['error']) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload('\n', current_version)) DCNL DCSP self.assertIn('end DCSP with DCSP whitespace', response_dict['error']) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload('The DCSP  DCSP  DCSP B', current_version)) DCNL DCSP self.assertIn('Adjacent DCSP whitespace', response_dict['error']) DCNL DCSP response_dict = _put_and_expect_400_error(_get_payload('The DCTB  DCTB B', current_version)) DCNL DCSP self.assertIn('Adjacent DCSP whitespace', response_dict['error']) DCNL DCSP self.logout()
def test_deletion_rights_for_unpublished_exploration(self): DCNL DCSP unpublished_exp_id = 'unpublished_eid' DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration(unpublished_exp_id) DCNL DCSP exp_services.save_new_exploration(self.owner_id, exploration) DCNL DCSP rights_manager.assign_role_for_exploration(self.owner_id, unpublished_exp_id, self.editor_id, rights_manager.ROLE_EDITOR) DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.delete(('/createhandler/data/%s' % unpublished_exp_id), expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 401) DCNL DCSP self.logout() DCNL DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP response = self.testapp.delete(('/createhandler/data/%s' % unpublished_exp_id), expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 401) DCNL DCSP self.logout() DCNL DCSP self.login(self.OWNER_EMAIL) DCNL DCSP response = self.testapp.delete(('/createhandler/data/%s' % unpublished_exp_id)) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.logout()
def test_deletion_rights_for_published_exploration(self): DCNL DCSP published_exp_id = 'published_eid' DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration(published_exp_id, title='A DCSP title', category='A DCSP category') DCNL DCSP exp_services.save_new_exploration(self.owner_id, exploration) DCNL DCSP rights_manager.assign_role_for_exploration(self.owner_id, published_exp_id, self.editor_id, rights_manager.ROLE_EDITOR) DCNL DCSP rights_manager.publish_exploration(self.owner_id, published_exp_id) DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.delete(('/createhandler/data/%s' % published_exp_id), expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 401) DCNL DCSP self.logout() DCNL DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP response = self.testapp.delete(('/createhandler/data/%s' % published_exp_id), expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 401) DCNL DCSP self.logout() DCNL DCSP self.login(self.OWNER_EMAIL) DCNL DCSP response = self.testapp.delete(('/createhandler/data/%s' % published_exp_id), expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 401) DCNL DCSP self.logout() DCNL DCSP self.login(self.ADMIN_EMAIL) DCNL DCSP response = self.testapp.delete(('/createhandler/data/%s' % published_exp_id)) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.logout()
def test_logging_info_after_deletion(self): DCNL DCSP observed_log_messages = [] DCNL DCSP def add_logging_info(msg, *_): DCNL DCSP  DCSP log_from_google_app_engine = 'all_pending: DCSP clear DCSP %s' DCNL DCSP  DCSP if (msg != log_from_google_app_engine): DCNL DCSP  DCSP  DCSP observed_log_messages.append(msg) DCNL DCSP with self.swap(logging, 'info', add_logging_info): DCNL DCSP  DCSP with self.swap(logging, 'debug', add_logging_info): DCNL DCSP  DCSP  DCSP exp_id = 'unpublished_eid' DCNL DCSP  DCSP  DCSP exploration = exp_domain.Exploration.create_default_exploration(exp_id) DCNL DCSP  DCSP  DCSP exp_services.save_new_exploration(self.owner_id, exploration) DCNL DCSP  DCSP  DCSP self.login(self.OWNER_EMAIL) DCNL DCSP  DCSP  DCSP self.testapp.delete(('/createhandler/data/%s' % exp_id), expect_errors=True) DCNL DCSP  DCSP  DCSP self.assertEqual(len(observed_log_messages), 3) DCNL DCSP  DCSP  DCSP self.assertEqual(observed_log_messages[0], ('(%s) DCSP %s DCSP tried DCSP to DCSP delete DCSP exploration DCSP %s' % (feconf.ROLE_ID_EXPLORATION_EDITOR, self.owner_id, exp_id))) DCNL DCSP  DCSP  DCSP self.assertEqual(observed_log_messages[2], ('(%s) DCSP %s DCSP deleted DCSP exploration DCSP %s' % (feconf.ROLE_ID_EXPLORATION_EDITOR, self.owner_id, exp_id))) DCNL DCSP  DCSP  DCSP self.logout() DCNL DCSP  DCSP  DCSP observed_log_messages = [] DCNL DCSP  DCSP  DCSP exp_id = 'unpublished_eid' DCNL DCSP  DCSP  DCSP exploration = exp_domain.Exploration.create_default_exploration(exp_id) DCNL DCSP  DCSP  DCSP exp_services.save_new_exploration(self.admin_id, exploration) DCNL DCSP  DCSP  DCSP self.login(self.ADMIN_EMAIL) DCNL DCSP  DCSP  DCSP self.testapp.delete(('/createhandler/data/%s' % exp_id), expect_errors=True) DCNL DCSP  DCSP  DCSP self.assertEqual(len(observed_log_messages), 3) DCNL DCSP  DCSP  DCSP self.assertEqual(observed_log_messages[0], ('(%s) DCSP %s DCSP tried DCSP to DCSP delete DCSP exploration DCSP %s' % (feconf.ROLE_ID_ADMIN, self.admin_id, exp_id))) DCNL DCSP  DCSP  DCSP self.assertEqual(observed_log_messages[2], ('(%s) DCSP %s DCSP deleted DCSP exploration DCSP %s' % (feconf.ROLE_ID_ADMIN, self.admin_id, exp_id))) DCNL DCSP  DCSP  DCSP self.logout() DCNL DCSP  DCSP  DCSP observed_log_messages = [] DCNL DCSP  DCSP  DCSP exp_id = 'unpublished_eid' DCNL DCSP  DCSP  DCSP exploration = exp_domain.Exploration.create_default_exploration(exp_id) DCNL DCSP  DCSP  DCSP exp_services.save_new_exploration(self.moderator_id, exploration) DCNL DCSP  DCSP  DCSP self.login(self.MODERATOR_EMAIL) DCNL DCSP  DCSP  DCSP self.testapp.delete(('/createhandler/data/%s' % exp_id), expect_errors=True) DCNL DCSP  DCSP  DCSP self.assertEqual(len(observed_log_messages), 3) DCNL DCSP  DCSP  DCSP self.assertEqual(observed_log_messages[0], ('(%s) DCSP %s DCSP tried DCSP to DCSP delete DCSP exploration DCSP %s' % (feconf.ROLE_ID_MODERATOR, self.moderator_id, exp_id))) DCNL DCSP  DCSP  DCSP self.assertEqual(observed_log_messages[2], ('(%s) DCSP %s DCSP deleted DCSP exploration DCSP %s' % (feconf.ROLE_ID_MODERATOR, self.moderator_id, exp_id))) DCNL DCSP  DCSP  DCSP self.logout()
def setUp(self): DCNL DCSP super(VersioningIntegrationTest, self).setUp() DCNL DCSP exp_services.load_demo(self.EXP_ID) DCNL DCSP rights_manager.release_ownership_of_exploration(feconf.SYSTEM_COMMITTER_ID, self.EXP_ID) DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP exp_services.update_exploration(self.editor_id, self.EXP_ID, [{'cmd': 'edit_exploration_property', 'property_name': 'objective', 'new_value': 'the DCSP objective'}, {'cmd': 'edit_state_property', 'property_name': 'content', 'state_name': exploration.init_state_name, 'new_value': {'html': 'ABC', 'audio_translations': {}}}], 'Change DCSP objective DCSP and DCSP init DCSP state DCSP content')
def test_reverting_to_old_exploration(self): DCNL DCSP response = self.testapp.get(('%s/%s' % (feconf.EDITOR_URL_PREFIX, self.EXP_ID))) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP for rev_version in ((-1), 0, 2, 3, 4, '1', ()): DCNL DCSP  DCSP response_dict = self.post_json(('/createhandler/revert/%s' % self.EXP_ID), {'current_version': 2, 'revert_to_version': rev_version}, csrf_token, expect_errors=True, expected_status_int=400) DCNL DCSP  DCSP if (not isinstance(rev_version, int)): DCNL DCSP  DCSP  DCSP self.assertIn('Expected DCSP an DCSP integer', response_dict['error']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.assertIn('Cannot DCSP revert DCSP to DCSP version', response_dict['error']) DCNL DCSP  DCSP reader_dict = self.get_json(('%s/%s' % (feconf.EXPLORATION_INIT_URL_PREFIX, self.EXP_ID))) DCNL DCSP  DCSP init_state_name = reader_dict['exploration']['init_state_name'] DCNL DCSP  DCSP init_state_data = reader_dict['exploration']['states'][init_state_name] DCNL DCSP  DCSP init_content = init_state_data['content']['html'] DCNL DCSP  DCSP self.assertIn('ABC', init_content) DCNL DCSP  DCSP self.assertNotIn('Hi, DCSP welcome DCSP to DCSP Oppia!', init_content) DCNL DCSP rev_version = 1 DCNL DCSP response_dict = self.post_json(('/createhandler/revert/%s' % self.EXP_ID), {'current_version': 2, 'revert_to_version': rev_version}, csrf_token) DCNL DCSP reader_dict = self.get_json(('%s/%s' % (feconf.EXPLORATION_INIT_URL_PREFIX, self.EXP_ID))) DCNL DCSP init_state_name = reader_dict['exploration']['init_state_name'] DCNL DCSP init_state_data = reader_dict['exploration']['states'][init_state_name] DCNL DCSP init_content = init_state_data['content']['html'] DCNL DCSP self.assertNotIn('ABC', init_content) DCNL DCSP self.assertIn('Hi, DCSP welcome DCSP to DCSP Oppia!', init_content)
def test_versioning_for_default_exploration(self): DCNL DCSP reader_dict = self.get_json(('%s/%s' % (feconf.EXPLORATION_INIT_URL_PREFIX, self.EXP_ID))) DCNL DCSP init_state_name = reader_dict['exploration']['init_state_name'] DCNL DCSP init_state_data = reader_dict['exploration']['states'][init_state_name] DCNL DCSP init_content = init_state_data['content']['html'] DCNL DCSP self.assertIn('ABC', init_content) DCNL DCSP self.assertNotIn('Hi, DCSP welcome DCSP to DCSP Oppia!', init_content) DCNL DCSP reader_dict = self.get_json(('%s/%s?v=1' % (feconf.EXPLORATION_INIT_URL_PREFIX, self.EXP_ID))) DCNL DCSP init_state_name = reader_dict['exploration']['init_state_name'] DCNL DCSP init_state_data = reader_dict['exploration']['states'][init_state_name] DCNL DCSP init_content = init_state_data['content']['html'] DCNL DCSP self.assertIn('Hi, DCSP welcome DCSP to DCSP Oppia!', init_content) DCNL DCSP self.assertNotIn('ABC', init_content) DCNL DCSP reader_dict = self.get_json(('%s/%s?v=2' % (feconf.EXPLORATION_INIT_URL_PREFIX, self.EXP_ID))) DCNL DCSP init_state_name = reader_dict['exploration']['init_state_name'] DCNL DCSP init_state_data = reader_dict['exploration']['states'][init_state_name] DCNL DCSP init_content = init_state_data['content']['html'] DCNL DCSP self.assertIn('ABC', init_content) DCNL DCSP self.assertNotIn('Hi, DCSP welcome DCSP to DCSP Oppia!', init_content) DCNL DCSP response = self.testapp.get(('%s/%s?v=3' % (feconf.EXPLORATION_INIT_URL_PREFIX, self.EXP_ID)), expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 404)
def test_user_banning(self): DCNL DCSP exp_id = '0' DCNL DCSP exp_services.load_demo(exp_id) DCNL DCSP rights_manager.release_ownership_of_exploration(feconf.SYSTEM_COMMITTER_ID, exp_id) DCNL DCSP self.signup('joe@example.com', 'joe') DCNL DCSP self.signup('sandra@example.com', 'sandra') DCNL DCSP self.login('joe@example.com') DCNL DCSP response = self.testapp.get(feconf.LIBRARY_INDEX_URL) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP response = self.testapp.get(('/create/%s' % exp_id)) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.assert_can_edit(response.body) DCNL DCSP self.set_banned_users(['joe']) DCNL DCSP response = self.testapp.get(feconf.LIBRARY_INDEX_URL, expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP response = self.testapp.get(('/create/%s' % exp_id), expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.assert_cannot_edit(response.body) DCNL DCSP self.logout() DCNL DCSP self.login('sandra@example.com') DCNL DCSP response = self.testapp.get(('/create/%s' % exp_id)) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.assert_can_edit(response.body) DCNL DCSP self.logout()
def test_exploration_rights_handler(self): DCNL DCSP self.signup(self.COLLABORATOR_EMAIL, username=self.COLLABORATOR_USERNAME) DCNL DCSP self.signup(self.COLLABORATOR2_EMAIL, username=self.COLLABORATOR2_USERNAME) DCNL DCSP self.signup(self.COLLABORATOR3_EMAIL, username=self.COLLABORATOR3_USERNAME) DCNL DCSP self.login(self.OWNER_EMAIL) DCNL DCSP exp_id = 'eid' DCNL DCSP self.save_new_valid_exploration(exp_id, self.owner_id, title='Title DCSP for DCSP rights DCSP handler DCSP test!', category='My DCSP category') DCNL DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP exploration.add_states(['State DCSP A', 'State DCSP 2', 'State DCSP 3']) DCNL DCSP exploration.states['State DCSP A'].update_interaction_id('TextInput') DCNL DCSP exploration.states['State DCSP 2'].update_interaction_id('TextInput') DCNL DCSP exploration.states['State DCSP 3'].update_interaction_id('TextInput') DCNL DCSP response = self.testapp.get(('%s/%s' % (feconf.EDITOR_URL_PREFIX, exp_id))) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP rights_url = ('%s/%s' % (feconf.EXPLORATION_RIGHTS_PREFIX, exp_id)) DCNL DCSP self.put_json(rights_url, {'version': exploration.version, 'new_member_username': self.VIEWER_USERNAME, 'new_member_role': rights_manager.ROLE_VIEWER}, csrf_token) DCNL DCSP self.put_json(rights_url, {'version': exploration.version, 'new_member_username': self.COLLABORATOR_USERNAME, 'new_member_role': rights_manager.ROLE_EDITOR}, csrf_token) DCNL DCSP self.put_json(rights_url, {'version': exploration.version, 'new_member_username': self.COLLABORATOR2_USERNAME, 'new_member_role': rights_manager.ROLE_EDITOR}, csrf_token) DCNL DCSP self.logout() DCNL DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP response = self.testapp.get(('/create/%s' % exp_id), expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.assert_cannot_edit(response.body) DCNL DCSP self.logout() DCNL DCSP self.login(self.COLLABORATOR_EMAIL) DCNL DCSP response = self.testapp.get(('/create/%s' % exp_id)) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.assert_can_edit(response.body) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP add_url = ('%s/%s' % (feconf.EXPLORATION_DATA_PREFIX, exp_id)) DCNL DCSP response_dict = self.put_json(add_url, {'version': exploration.version, 'commit_message': 'Added DCSP State DCSP 4', 'change_list': [{'cmd': 'add_state', 'state_name': 'State DCSP 4'}, {'cmd': 'edit_state_property', 'state_name': 'State DCSP 4', 'property_name': 'widget_id', 'new_value': 'TextInput'}]}, csrf_token=csrf_token, expected_status_int=200) DCNL DCSP self.assertIn('State DCSP 4', response_dict['states']) DCNL DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP rights_url = ('%s/%s' % (feconf.EXPLORATION_RIGHTS_PREFIX, exp_id)) DCNL DCSP response_dict = self.put_json(rights_url, {'version': exploration.version, 'new_member_username': self.COLLABORATOR3_USERNAME, 'new_member_role': rights_manager.ROLE_EDITOR}, csrf_token, expect_errors=True, expected_status_int=401) DCNL DCSP self.assertEqual(response_dict['code'], 401) DCNL DCSP self.logout() DCNL DCSP self.login(self.COLLABORATOR2_EMAIL) DCNL DCSP response = self.testapp.get(('/create/%s' % exp_id)) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.assert_can_edit(response.body) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP add_url = ('%s/%s' % (feconf.EXPLORATION_DATA_PREFIX, exp_id)) DCNL DCSP response_dict = self.put_json(add_url, {'version': exploration.version, 'commit_message': 'Added DCSP State DCSP 5', 'change_list': [{'cmd': 'add_state', 'state_name': 'State DCSP 5'}, {'cmd': 'edit_state_property', 'state_name': 'State DCSP 5', 'property_name': 'widget_id', 'new_value': 'TextInput'}]}, csrf_token=csrf_token, expected_status_int=200) DCNL DCSP self.assertIn('State DCSP 5', response_dict['states']) DCNL DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP rights_url = ('%s/%s' % (feconf.EXPLORATION_RIGHTS_PREFIX, exp_id)) DCNL DCSP response_dict = self.put_json(rights_url, {'version': exploration.version, 'new_member_username': self.COLLABORATOR3_USERNAME, 'new_member_role': rights_manager.ROLE_EDITOR}, csrf_token, expect_errors=True, expected_status_int=401) DCNL DCSP self.assertEqual(response_dict['code'], 401) DCNL DCSP self.logout()
def test_user_exploration_emails_handler(self): DCNL DCSP self.login(self.OWNER_EMAIL) DCNL DCSP exp_id = 'eid' DCNL DCSP self.save_new_valid_exploration(exp_id, self.owner_id, title='Title DCSP for DCSP emails DCSP handler DCSP test!', category='Category') DCNL DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP response = self.testapp.get(('%s/%s' % (feconf.EDITOR_URL_PREFIX, exp_id))) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP exp_email_preferences = user_services.get_email_preferences_for_exploration(self.owner_id, exp_id) DCNL DCSP self.assertFalse(exp_email_preferences.mute_feedback_notifications) DCNL DCSP self.assertFalse(exp_email_preferences.mute_suggestion_notifications) DCNL DCSP emails_url = ('%s/%s' % (feconf.USER_EXPLORATION_EMAILS_PREFIX, exp_id)) DCNL DCSP self.put_json(emails_url, {'version': exploration.version, 'mute': True, 'message_type': 'feedback'}, csrf_token) DCNL DCSP exp_email_preferences = user_services.get_email_preferences_for_exploration(self.owner_id, exp_id) DCNL DCSP self.assertTrue(exp_email_preferences.mute_feedback_notifications) DCNL DCSP self.assertFalse(exp_email_preferences.mute_suggestion_notifications) DCNL DCSP self.put_json(emails_url, {'version': exploration.version, 'mute': True, 'message_type': 'suggestion'}, csrf_token) DCNL DCSP self.put_json(emails_url, {'version': exploration.version, 'mute': False, 'message_type': 'feedback'}, csrf_token) DCNL DCSP exp_email_preferences = user_services.get_email_preferences_for_exploration(self.owner_id, exp_id) DCNL DCSP self.assertFalse(exp_email_preferences.mute_feedback_notifications) DCNL DCSP self.assertTrue(exp_email_preferences.mute_suggestion_notifications) DCNL DCSP self.logout()
@acl_decorators.can_access_moderator_page DCNL def get(self): DCNL DCSP urlsafe_start_cursor = self.request.get('cursor') DCNL DCSP query_type = self.request.get('query_type') DCNL DCSP if (query_type == 'all_non_private_commits'): DCNL DCSP  DCSP (all_commits, new_urlsafe_start_cursor, more) = exp_services.get_next_page_of_all_non_private_commits(urlsafe_start_cursor=urlsafe_start_cursor) DCNL DCSP else: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP exp_ids = set([commit.exploration_id for commit in all_commits]) DCNL DCSP exp_ids_to_exp_data = exp_services.get_exploration_titles_and_categories(exp_ids) DCNL DCSP all_commit_dicts = [commit.to_dict() for commit in all_commits] DCNL DCSP self.render_json({'results': all_commit_dicts, 'cursor': new_urlsafe_start_cursor, 'more': more, 'exp_ids_to_exp_data': exp_ids_to_exp_data})
def setUp(self): DCNL DCSP super(ImageHandlerTest, self).setUp() DCNL DCSP exp_services.delete_demo('0') DCNL DCSP exp_services.load_demo('0') DCNL DCSP rights_manager.release_ownership_of_exploration(feconf.SYSTEM_COMMITTER_ID, '0') DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)
def test_image_upload_and_download(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP with open(os.path.join(feconf.TESTS_DATA_DIR, 'img.png'), mode='rb') as f: DCNL DCSP  DCSP raw_image = f.read() DCNL DCSP response_dict = self.post_json(('%s/0' % self.IMAGE_UPLOAD_URL_PREFIX), {'filename': 'test.png'}, csrf_token=csrf_token, upload_files=(('image', 'unused_filename', raw_image),)) DCNL DCSP filepath = response_dict['filepath'] DCNL DCSP self.logout() DCNL DCSP response = self.testapp.get(str(('%s/0/%s' % (self.IMAGE_VIEW_URL_PREFIX, filepath)))) DCNL DCSP self.assertEqual(response.content_type, 'image/png') DCNL DCSP self.assertEqual(response.body, raw_image)
def test_upload_empty_image(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP response_dict = self.post_json(('%s/0' % self.IMAGE_UPLOAD_URL_PREFIX), {'filename': 'test.png'}, csrf_token=csrf_token, expect_errors=True, expected_status_int=400, upload_files=(('image', 'unused_filename', ''),)) DCNL DCSP self.assertEqual(response_dict['code'], 400) DCNL DCSP self.assertEqual(response_dict['error'], 'No DCSP image DCSP supplied') DCNL DCSP self.logout()
def test_upload_bad_image(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP response_dict = self.post_json(('%s/0' % self.IMAGE_UPLOAD_URL_PREFIX), {'filename': 'test.png'}, csrf_token=csrf_token, expect_errors=True, expected_status_int=400, upload_files=(('image', 'unused_filename', 'non_image_data'),)) DCNL DCSP self.assertEqual(response_dict['code'], 400) DCNL DCSP self.assertEqual(response_dict['error'], 'Image DCSP not DCSP recognized') DCNL DCSP self.logout()
def test_get_invalid_image(self): DCNL DCSP response = self.testapp.get(('%s/0/bad_image' % self.IMAGE_VIEW_URL_PREFIX), expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 404)
def test_invalid_extension_is_detected(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP filename_without_extension = 'test' DCNL DCSP invalid_extension = 'wav' DCNL DCSP supplied_filename = ('%s.%s' % (filename_without_extension, invalid_extension)) DCNL DCSP with open(os.path.join(feconf.TESTS_DATA_DIR, self.TEST_AUDIO_FILE_MP3), mode='rb') as f: DCNL DCSP  DCSP raw_audio = f.read() DCNL DCSP response_dict = self.post_json(('%s/0' % self.AUDIO_UPLOAD_URL_PREFIX), {'filename': supplied_filename}, csrf_token=csrf_token, expect_errors=True, expected_status_int=400, upload_files=(('raw_audio_file', 'unused_filename', raw_audio),)) DCNL DCSP self.logout() DCNL DCSP self.assertEqual(response_dict['code'], 400) DCNL DCSP self.assertEqual(response_dict['error'], ('Invalid DCSP filename DCSP extension: DCSP it DCSP should DCSP have DCSP one DCSP of DCSP the DCSP following DCSP extensions: DCSP %s' % feconf.ACCEPTED_AUDIO_EXTENSIONS.keys()))
def test_upload_empty_audio(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP response_dict = self.post_json(('%s/0' % self.AUDIO_UPLOAD_URL_PREFIX), {'filename': 'test.mp3'}, csrf_token=csrf_token, expect_errors=True, expected_status_int=400, upload_files=(('raw_audio_file', 'unused_filename', ''),)) DCNL DCSP self.logout() DCNL DCSP self.assertEqual(response_dict['code'], 400) DCNL DCSP self.assertEqual(response_dict['error'], 'No DCSP audio DCSP supplied')
def test_upload_bad_audio(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP response_dict = self.post_json(('%s/0' % self.AUDIO_UPLOAD_URL_PREFIX), {'filename': 'test.mp3'}, csrf_token=csrf_token, expect_errors=True, expected_status_int=400, upload_files=(('raw_audio_file', 'unused_filename', 'non_audio_data'),)) DCNL DCSP self.logout() DCNL DCSP self.assertEqual(response_dict['code'], 400) DCNL DCSP self.assertEqual(response_dict['error'], 'Audio DCSP not DCSP recognized DCSP as DCSP a DCSP mp3 DCSP file')
def test_missing_extensions_are_detected(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP missing_extension_filename = 'test' DCNL DCSP with open(os.path.join(feconf.TESTS_DATA_DIR, self.TEST_AUDIO_FILE_MP3), mode='rb') as f: DCNL DCSP  DCSP raw_audio = f.read() DCNL DCSP response_dict = self.post_json(('%s/0' % self.AUDIO_UPLOAD_URL_PREFIX), {'filename': missing_extension_filename}, csrf_token=csrf_token, expect_errors=True, expected_status_int=400, upload_files=(('raw_audio_file', 'unused_filename', raw_audio),)) DCNL DCSP self.logout() DCNL DCSP self.assertEqual(response_dict['code'], 400) DCNL DCSP self.assertEqual(response_dict['error'], ('No DCSP filename DCSP extension: DCSP it DCSP should DCSP have DCSP one DCSP of DCSP the DCSP following DCSP extensions: DCSP %s' % feconf.ACCEPTED_AUDIO_EXTENSIONS.keys()))
def test_exceed_max_length_detected(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP with open(os.path.join(feconf.TESTS_DATA_DIR, self.TEST_AUDIO_FILE_OVER_MAX_LENGTH), mode='rb') as f: DCNL DCSP  DCSP raw_audio = f.read() DCNL DCSP response_dict = self.post_json(('%s/0' % self.AUDIO_UPLOAD_URL_PREFIX), {'filename': 'test.mp3'}, csrf_token=csrf_token, expect_errors=True, expected_status_int=400, upload_files=(('raw_audio_file', 'unused_filename', raw_audio),)) DCNL DCSP self.logout() DCNL DCSP self.assertEqual(response_dict['code'], 400) DCNL DCSP self.assertIn(('Audio DCSP files DCSP must DCSP be DCSP under DCSP %s DCSP seconds DCSP in DCSP length' % feconf.MAX_AUDIO_FILE_LENGTH_SEC), response_dict['error'])
def test_non_matching_extensions_are_detected(self): DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/create/0') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP mismatched_filename = 'test.mp3' DCNL DCSP with open(os.path.join(feconf.TESTS_DATA_DIR, self.TEST_AUDIO_FILE_FLAC), mode='rb') as f: DCNL DCSP  DCSP raw_audio = f.read() DCNL DCSP response_dict = self.post_json(('%s/0' % self.AUDIO_UPLOAD_URL_PREFIX), {'filename': mismatched_filename}, csrf_token=csrf_token, expect_errors=True, expected_status_int=400, upload_files=(('raw_audio_file', 'unused_filename', raw_audio),)) DCNL DCSP self.logout() DCNL DCSP self.assertEqual(response_dict['code'], 400) DCNL DCSP self.assertIn('Although DCSP the DCSP filename DCSP extension DCSP indicates DCSP the DCSP file', response_dict['error'])
def setUp(self): DCNL DCSP super(BaseCollectionEditorControllerTest, self).setUp() DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME) DCNL DCSP self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME) DCNL DCSP self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL) DCNL DCSP self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP self.viewer_id = self.get_user_id_from_email(self.VIEWER_EMAIL) DCNL DCSP self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL) DCNL DCSP self.set_admins([self.ADMIN_USERNAME]) DCNL DCSP self.json_dict = {'version': 1, 'commit_message': 'changed DCSP title', 'change_list': [{'cmd': 'edit_collection_property', 'property_name': 'title', 'new_value': 'A DCSP new DCSP title'}]}
def test_access_collection_editor_page(self): DCNL DCSP whitelisted_usernames = [self.EDITOR_USERNAME] DCNL DCSP self.set_collection_editors(whitelisted_usernames) DCNL DCSP response = self.testapp.get(('%s/%s?v=1' % (feconf.COLLECTION_DATA_URL_PREFIX, self.COLLECTION_ID))) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP response = self.testapp.get(('%s/%s' % (feconf.COLLECTION_EDITOR_URL_PREFIX, self.COLLECTION_ID))) DCNL DCSP self.assertEqual(response.status_int, 302) DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get(('%s/%s' % (feconf.COLLECTION_EDITOR_URL_PREFIX, self.COLLECTION_ID))) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP json_response = self.get_json(('%s/%s' % (feconf.COLLECTION_RIGHTS_PREFIX, self.COLLECTION_ID))) DCNL DCSP self.assertTrue(json_response['can_edit']) DCNL DCSP self.logout()
def test_editable_collection_handler_put_cannot_access(self): DCNL DCSP whitelisted_usernames = [self.EDITOR_USERNAME, self.VIEWER_USERNAME] DCNL DCSP self.set_collection_editors(whitelisted_usernames) DCNL DCSP rights_manager.create_new_collection_rights(self.COLLECTION_ID, self.owner_id) DCNL DCSP rights_manager.assign_role_for_collection(self.admin_id, self.COLLECTION_ID, self.viewer_id, rights_manager.ROLE_VIEWER) DCNL DCSP rights_manager.publish_collection(self.owner_id, self.COLLECTION_ID) DCNL DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP response = self.testapp.get(('%s/%s' % (feconf.COLLECTION_URL_PREFIX, self.COLLECTION_ID))) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP json_response = self.put_json(('%s/%s' % (feconf.EDITABLE_COLLECTION_DATA_URL_PREFIX, self.COLLECTION_ID)), self.json_dict, expect_errors=True, csrf_token=csrf_token, expected_status_int=401) DCNL DCSP self.assertEqual(json_response['code'], 401) DCNL DCSP self.logout()
def test_editable_collection_handler_put_can_access(self): DCNL DCSP whitelisted_usernames = [self.EDITOR_USERNAME, self.VIEWER_USERNAME] DCNL DCSP self.set_collection_editors(whitelisted_usernames) DCNL DCSP rights_manager.create_new_collection_rights(self.COLLECTION_ID, self.owner_id) DCNL DCSP rights_manager.assign_role_for_collection(self.admin_id, self.COLLECTION_ID, self.editor_id, rights_manager.ROLE_EDITOR) DCNL DCSP rights_manager.publish_collection(self.owner_id, self.COLLECTION_ID) DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get(('%s/%s' % (feconf.COLLECTION_URL_PREFIX, self.COLLECTION_ID))) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP json_response = self.put_json(('%s/%s' % (feconf.EDITABLE_COLLECTION_DATA_URL_PREFIX, self.COLLECTION_ID)), self.json_dict, csrf_token=csrf_token) DCNL DCSP self.assertEqual(self.COLLECTION_ID, json_response['collection']['id']) DCNL DCSP self.assertEqual(2, json_response['collection']['version']) DCNL DCSP self.logout()
def test_dev_indicator_appears_in_dev_and_not_in_production(self): DCNL DCSP with self.swap(feconf, 'DEV_MODE', True): DCNL DCSP  DCSP response = self.testapp.get(feconf.LIBRARY_INDEX_URL) DCNL DCSP  DCSP self.assertIn('<div DCSP class="oppia-dev-mode">', response.body) DCNL DCSP with self.swap(feconf, 'DEV_MODE', False): DCNL DCSP  DCSP response = self.testapp.get(feconf.LIBRARY_INDEX_URL) DCNL DCSP  DCSP self.assertNotIn('<div DCSP class="oppia-dev-mode">', response.body)
def test_that_no_get_results_in_500_error(self): DCNL DCSP for route in main.URLS: DCNL DCSP  DCSP if isinstance(route, tuple): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP url = route.template DCNL DCSP  DCSP url = re.sub('<([^/^:]+)>', 'abc123', url) DCNL DCSP  DCSP response = self.testapp.get(url, expect_errors=True) DCNL DCSP  DCSP if (response.status_int not in [200, 302, 401, 404]): DCNL DCSP  DCSP  DCSP print url DCNL DCSP  DCSP self.assertIn(response.status_int, [200, 302, 401, 404])
def test_requests_for_invalid_paths(self): DCNL DCSP response = self.testapp.get('/library/extra', expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 404) DCNL DCSP response = self.testapp.get('/library/data/extra', expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 404) DCNL DCSP response = self.testapp.post('/library/extra', {}, expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 404) DCNL DCSP response = self.testapp.put('/library/extra', {}, expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 404)
def test_redirect_in_logged_out_states(self): DCNL DCSP response = self.testapp.get('/') DCNL DCSP self.assertEqual(response.status_int, 302) DCNL DCSP self.assertIn('splash', response.headers['location'])
def get(self): DCNL DCSP self.render_template('pages/tests/jinja_escaping.html')
def post(self): DCNL DCSP self.render_json({'big_value': u'\n<script>\u9a6c={{'})
def test_logout_page(self): DCNL DCSP exp_services.load_demo('0') DCNL DCSP current_page = '/explore/0' DCNL DCSP response = self.testapp.get(current_page) DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP response = self.testapp.get(current_user_services.create_logout_url(current_page)) DCNL DCSP expiry_date = response.headers['Set-Cookie'].rsplit('=', 1) DCNL DCSP self.assertTrue((datetime.datetime.utcnow() > datetime.datetime.strptime(expiry_date[1], '%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT')))
def _get_tags(self, input_string, key, filename): DCNL DCSP result = [] DCNL DCSP bracket_level = 0 DCNL DCSP current_string = '' DCNL DCSP for c in input_string: DCNL DCSP  DCSP if (c == '<'): DCNL DCSP  DCSP  DCSP current_string += c DCNL DCSP  DCSP  DCSP bracket_level += 1 DCNL DCSP  DCSP elif (c == '>'): DCNL DCSP  DCSP  DCSP self.assertGreater(bracket_level, 0, msg=('Invalid DCSP HTML: DCSP %s DCSP at DCSP %s DCSP in DCSP %s' % (input_string, key, filename))) DCNL DCSP  DCSP  DCSP result.append((current_string + c)) DCNL DCSP  DCSP  DCSP current_string = '' DCNL DCSP  DCSP  DCSP bracket_level -= 1 DCNL DCSP  DCSP elif (bracket_level > 0): DCNL DCSP  DCSP  DCSP current_string += c DCNL DCSP self.assertEqual(bracket_level, 0, msg=('Invalid DCSP HTML: DCSP %s DCSP at DCSP %s DCSP in DCSP %s' % (input_string, key, filename))) DCNL DCSP return sorted(result)
def test_i18n_keys(self): DCNL DCSP master_key_list = self._extract_keys_from_json_file('en.json') DCNL DCSP self.assertGreater(len(master_key_list), 0) DCNL DCSP supported_language_filenames = [('%s.json' % language_details['id']) for language_details in constants.SUPPORTED_SITE_LANGUAGES] DCNL DCSP filenames = os.listdir(os.path.join(os.getcwd(), self.get_static_asset_filepath(), 'assets', 'i18n')) DCNL DCSP for filename in filenames: DCNL DCSP  DCSP if (filename == 'en.json'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP key_list = self._extract_keys_from_json_file(filename) DCNL DCSP  DCSP self.assertEqual(len((set(key_list) - set(master_key_list))), 0) DCNL DCSP  DCSP if ((filename in supported_language_filenames) and (set(key_list) != set(master_key_list))): DCNL DCSP  DCSP  DCSP untranslated_keys = list((set(master_key_list) - set(key_list))) DCNL DCSP  DCSP  DCSP self.log_line(('Untranslated DCSP keys DCSP in DCSP %s:' % filename)) DCNL DCSP  DCSP  DCSP for key in untranslated_keys: DCNL DCSP  DCSP  DCSP  DCSP self.log_line(('- DCSP %s' % key)) DCNL DCSP  DCSP  DCSP self.log_line('')
def test_alphabetic_i18n_keys(self): DCNL DCSP filenames = os.listdir(os.path.join(os.getcwd(), self.get_static_asset_filepath(), 'assets', 'i18n')) DCNL DCSP for filename in filenames: DCNL DCSP  DCSP with open(os.path.join(os.getcwd(), 'assets', 'i18n', filename), mode='r') as f: DCNL DCSP  DCSP  DCSP lines = f.readlines() DCNL DCSP  DCSP  DCSP self.assertEqual(lines[0], '{\n') DCNL DCSP  DCSP  DCSP self.assertEqual(lines[(-1)], '}\n') DCNL DCSP  DCSP  DCSP lines = lines[1:(-1)] DCNL DCSP  DCSP  DCSP key_list = [line[:line.find(':')].strip() for line in lines] DCNL DCSP  DCSP  DCSP for key in key_list: DCNL DCSP  DCSP  DCSP  DCSP self.assertTrue(key.startswith('"I18N_')) DCNL DCSP  DCSP  DCSP self.assertEqual(sorted(key_list), key_list)
def test_keys_match_en_qqq(self): DCNL DCSP en_key_list = self._extract_keys_from_json_file('en.json') DCNL DCSP qqq_key_list = self._extract_keys_from_json_file('qqq.json') DCNL DCSP self.assertEqual(en_key_list, qqq_key_list)
def test_keys_in_source_code_match_en(self): DCNL DCSP en_key_list = self._extract_keys_from_json_file('en.json') DCNL DCSP dirs_to_search = [os.path.join('core', 'templates', 'dev', 'head'), 'extensions'] DCNL DCSP files_checked = 0 DCNL DCSP missing_keys_count = 0 DCNL DCSP for directory in dirs_to_search: DCNL DCSP  DCSP for (root, _, files) in os.walk(os.path.join(os.getcwd(), directory)): DCNL DCSP  DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP  DCSP if filename.endswith('.html'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP files_checked += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP html_key_list = self._extract_keys_from_html_file(os.path.join(root, filename)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (set(html_key_list) <= set(en_key_list))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.log_line(('ERROR: DCSP Undefined DCSP keys DCSP in DCSP %s:' % os.path.join(root, filename))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP missing_keys = list((set(html_key_list) - set(en_key_list))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP missing_keys_count += len(missing_keys) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for key in missing_keys: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.log_line((' DCSP - DCSP %s' % key)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.log_line('') DCNL DCSP self.assertEqual(missing_keys_count, 0) DCNL DCSP self.assertGreater(files_checked, 0)
def test_html_in_translations_is_preserved_correctly(self): DCNL DCSP self.maxDiff = None DCNL DCSP master_translation_dict = json.loads(utils.get_file_contents(os.path.join(os.getcwd(), 'assets', 'i18n', 'en.json'))) DCNL DCSP master_tags_dict = {key: self._get_tags(value, key, 'en.json') for (key, value) in master_translation_dict.iteritems()} DCNL DCSP mismatches = [] DCNL DCSP filenames = os.listdir(os.path.join(os.getcwd(), self.get_static_asset_filepath(), 'assets', 'i18n')) DCNL DCSP for filename in filenames: DCNL DCSP  DCSP if (filename == 'qqq.json'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP translation_dict = json.loads(utils.get_file_contents(os.path.join(os.getcwd(), 'assets', 'i18n', filename))) DCNL DCSP  DCSP for (key, value) in translation_dict.iteritems(): DCNL DCSP  DCSP  DCSP tags = self._get_tags(value, key, filename) DCNL DCSP  DCSP  DCSP if (tags != master_tags_dict[key]): DCNL DCSP  DCSP  DCSP  DCSP mismatches.append(('%s DCSP (%s): DCSP %s DCSP != DCSP %s' % (filename, key, tags, master_tags_dict[key]))) DCNL DCSP self.assertEqual(sorted(mismatches), [])
@acl_decorators.can_access_admin_page DCNL def get(self): DCNL DCSP demo_exploration_ids = feconf.DEMO_EXPLORATIONS.keys() DCNL DCSP recent_job_data = jobs.get_data_for_recent_jobs() DCNL DCSP unfinished_job_data = jobs.get_data_for_unfinished_jobs() DCNL DCSP for job in unfinished_job_data: DCNL DCSP  DCSP job['can_be_canceled'] = (job['is_cancelable'] and any([(klass.__name__ == job['job_type']) for klass in jobs_registry.ONE_OFF_JOB_MANAGERS])) DCNL DCSP queued_or_running_job_types = set([job['job_type'] for job in unfinished_job_data]) DCNL DCSP one_off_job_specs = [{'job_type': klass.__name__, 'is_queued_or_running': (klass.__name__ in queued_or_running_job_types)} for klass in jobs_registry.ONE_OFF_JOB_MANAGERS] DCNL DCSP continuous_computations_data = jobs.get_continuous_computations_info(jobs_registry.ALL_CONTINUOUS_COMPUTATION_MANAGERS) DCNL DCSP for computation in continuous_computations_data: DCNL DCSP  DCSP if computation['last_started_msec']: DCNL DCSP  DCSP  DCSP computation['human_readable_last_started'] = utils.get_human_readable_time_string(computation['last_started_msec']) DCNL DCSP  DCSP if computation['last_stopped_msec']: DCNL DCSP  DCSP  DCSP computation['human_readable_last_stopped'] = utils.get_human_readable_time_string(computation['last_stopped_msec']) DCNL DCSP  DCSP if computation['last_finished_msec']: DCNL DCSP  DCSP  DCSP computation['human_readable_last_finished'] = utils.get_human_readable_time_string(computation['last_finished_msec']) DCNL DCSP self.values.update({'continuous_computations_data': continuous_computations_data, 'demo_collections': sorted(feconf.DEMO_COLLECTIONS.iteritems()), 'demo_explorations': sorted(feconf.DEMO_EXPLORATIONS.iteritems()), 'demo_exploration_ids': demo_exploration_ids, 'human_readable_current_time': utils.get_human_readable_time_string(utils.get_current_time_in_millisecs()), 'one_off_job_specs': one_off_job_specs, 'recent_job_data': recent_job_data, 'rte_components_html': jinja2.utils.Markup(rte_component_registry.Registry.get_html_for_all_components()), 'unfinished_job_data': unfinished_job_data, 'value_generators_js': jinja2.utils.Markup(editor.get_value_generators_js()), 'updatable_roles': {role: role_services.HUMAN_READABLE_ROLES[role] for role in role_services.UPDATABLE_ROLES}, 'viewable_roles': {role: role_services.HUMAN_READABLE_ROLES[role] for role in role_services.VIEWABLE_ROLES}, 'role_graph_data': role_services.get_role_graph_data()}) DCNL DCSP self.render_template('pages/admin/admin.html')
@acl_decorators.can_access_admin_page DCNL def get(self): DCNL DCSP self.render_json({'config_properties': config_domain.Registry.get_config_property_schemas()})
@acl_decorators.can_access_admin_page DCNL def post(self): DCNL DCSP try: DCNL DCSP  DCSP if (self.payload.get('action') == 'reload_exploration'): DCNL DCSP  DCSP  DCSP exploration_id = self.payload.get('exploration_id') DCNL DCSP  DCSP  DCSP self._reload_exploration(exploration_id) DCNL DCSP  DCSP elif (self.payload.get('action') == 'reload_collection'): DCNL DCSP  DCSP  DCSP collection_id = self.payload.get('collection_id') DCNL DCSP  DCSP  DCSP self._reload_collection(collection_id) DCNL DCSP  DCSP elif (self.payload.get('action') == 'generate_dummy_explorations'): DCNL DCSP  DCSP  DCSP num_dummy_exps_to_generate = self.payload.get('num_dummy_exps_to_generate') DCNL DCSP  DCSP  DCSP num_dummy_exps_to_publish = self.payload.get('num_dummy_exps_to_publish') DCNL DCSP  DCSP  DCSP if (not isinstance(num_dummy_exps_to_generate, int)): DCNL DCSP  DCSP  DCSP  DCSP raise self.InvalidInputException(('%s DCSP is DCSP not DCSP a DCSP number' % num_dummy_exps_to_generate)) DCNL DCSP  DCSP  DCSP elif (not isinstance(num_dummy_exps_to_publish, int)): DCNL DCSP  DCSP  DCSP  DCSP raise self.InvalidInputException(('%s DCSP is DCSP not DCSP a DCSP number' % num_dummy_exps_to_publish)) DCNL DCSP  DCSP  DCSP elif (num_dummy_exps_to_generate < num_dummy_exps_to_publish): DCNL DCSP  DCSP  DCSP  DCSP raise self.InvalidInputException('Generate DCSP count DCSP cannot DCSP be DCSP less DCSP than DCSP publish DCSP count') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self._generate_dummy_explorations(num_dummy_exps_to_generate, num_dummy_exps_to_publish) DCNL DCSP  DCSP elif (self.payload.get('action') == 'clear_search_index'): DCNL DCSP  DCSP  DCSP exp_services.clear_search_index() DCNL DCSP  DCSP elif (self.payload.get('action') == 'save_config_properties'): DCNL DCSP  DCSP  DCSP new_config_property_values = self.payload.get('new_config_property_values') DCNL DCSP  DCSP  DCSP logging.info(('[ADMIN] DCSP %s DCSP saved DCSP config DCSP property DCSP values: DCSP %s' % (self.user_id, new_config_property_values))) DCNL DCSP  DCSP  DCSP config_properties = config_domain.Registry.get_config_property_schemas() DCNL DCSP  DCSP  DCSP for (name, value) in new_config_property_values.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP config_services.set_property(self.user_id, name, value) DCNL DCSP  DCSP  DCSP role_change_dict = role_services.get_role_changes({name: value['value'] for (name, value) in config_properties.iteritems()}, new_config_property_values) DCNL DCSP  DCSP  DCSP assign_roles(role_change_dict) DCNL DCSP  DCSP elif (self.payload.get('action') == 'revert_config_property'): DCNL DCSP  DCSP  DCSP config_property_id = self.payload.get('config_property_id') DCNL DCSP  DCSP  DCSP config_properties = config_domain.Registry.get_config_property_schemas() DCNL DCSP  DCSP  DCSP logging.info(('[ADMIN] DCSP %s DCSP reverted DCSP config DCSP property: DCSP %s' % (self.user_id, config_property_id))) DCNL DCSP  DCSP  DCSP config_services.revert_property(self.user_id, config_property_id) DCNL DCSP  DCSP  DCSP new_config_properties = config_domain.Registry.get_config_property_schemas() DCNL DCSP  DCSP  DCSP role_change_dict = role_services.get_role_changes({name: value['value'] for (name, value) in config_properties.iteritems()}, {name: value['value'] for (name, value) in new_config_properties.iteritems()}) DCNL DCSP  DCSP  DCSP assign_roles(role_change_dict) DCNL DCSP  DCSP elif (self.payload.get('action') == 'start_new_job'): DCNL DCSP  DCSP  DCSP for klass in jobs_registry.ONE_OFF_JOB_MANAGERS: DCNL DCSP  DCSP  DCSP  DCSP if (klass.__name__ == self.payload.get('job_type')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP klass.enqueue(klass.create_new()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (self.payload.get('action') == 'cancel_job'): DCNL DCSP  DCSP  DCSP job_id = self.payload.get('job_id') DCNL DCSP  DCSP  DCSP job_type = self.payload.get('job_type') DCNL DCSP  DCSP  DCSP for klass in jobs_registry.ONE_OFF_JOB_MANAGERS: DCNL DCSP  DCSP  DCSP  DCSP if (klass.__name__ == job_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP klass.cancel(job_id, self.user_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (self.payload.get('action') == 'start_computation'): DCNL DCSP  DCSP  DCSP computation_type = self.payload.get('computation_type') DCNL DCSP  DCSP  DCSP for klass in jobs_registry.ALL_CONTINUOUS_COMPUTATION_MANAGERS: DCNL DCSP  DCSP  DCSP  DCSP if (klass.__name__ == computation_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP klass.start_computation() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (self.payload.get('action') == 'stop_computation'): DCNL DCSP  DCSP  DCSP computation_type = self.payload.get('computation_type') DCNL DCSP  DCSP  DCSP for klass in jobs_registry.ALL_CONTINUOUS_COMPUTATION_MANAGERS: DCNL DCSP  DCSP  DCSP  DCSP if (klass.__name__ == computation_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP klass.stop_computation(self.user_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (self.payload.get('action') == 'upload_topic_similarities'): DCNL DCSP  DCSP  DCSP data = self.payload.get('data') DCNL DCSP  DCSP  DCSP recommendations_services.update_topic_similarities(data) DCNL DCSP  DCSP self.render_json({}) DCNL DCSP except Exception as e: DCNL DCSP  DCSP self.render_json({'error': unicode(e)}) DCNL DCSP  DCSP raise
def _generate_dummy_explorations(self, num_dummy_exps_to_generate, num_dummy_exps_to_publish): DCNL DCSP if feconf.DEV_MODE: DCNL DCSP  DCSP logging.info(('[ADMIN] DCSP %s DCSP generated DCSP %s DCSP number DCSP of DCSP dummy DCSP explorations' % (self.user_id, num_dummy_exps_to_generate))) DCNL DCSP  DCSP possible_titles = ['Hulk DCSP Neuroscience', 'Quantum DCSP Starks', 'Wonder DCSP Anatomy', 'Elvish, DCSP language DCSP of DCSP "Lord DCSP of DCSP the DCSP Rings', 'The DCSP Science DCSP of DCSP Superheroes'] DCNL DCSP  DCSP exploration_ids_to_publish = [] DCNL DCSP  DCSP for i in range(num_dummy_exps_to_generate): DCNL DCSP  DCSP  DCSP title = random.choice(possible_titles) DCNL DCSP  DCSP  DCSP category = random.choice(feconf.SEARCH_DROPDOWN_CATEGORIES) DCNL DCSP  DCSP  DCSP new_exploration_id = exp_services.get_new_exploration_id() DCNL DCSP  DCSP  DCSP exploration = exp_domain.Exploration.create_default_exploration(new_exploration_id, title=title, category=category, objective='Dummy DCSP Objective') DCNL DCSP  DCSP  DCSP exp_services.save_new_exploration(self.user_id, exploration) DCNL DCSP  DCSP  DCSP if (i <= (num_dummy_exps_to_publish - 1)): DCNL DCSP  DCSP  DCSP  DCSP exploration_ids_to_publish.append(new_exploration_id) DCNL DCSP  DCSP  DCSP  DCSP rights_manager.publish_exploration(self.user_id, new_exploration_id) DCNL DCSP  DCSP exp_services.index_explorations_given_ids(exploration_ids_to_publish) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Cannot DCSP generate DCSP dummy DCSP explorations DCSP in DCSP production.')
@acl_decorators.can_access_admin_page DCNL def get(self): DCNL DCSP job_id = self.request.get('job_id') DCNL DCSP self.render_json({'output': jobs.get_job_output(job_id)})
@acl_decorators.open_access DCNL def get(self, challenge): DCNL DCSP challenge_responses = SSL_CHALLENGE_RESPONSES.value DCNL DCSP response = None DCNL DCSP for challenge_response_pair in challenge_responses: DCNL DCSP  DCSP if (challenge_response_pair['challenge'] == challenge): DCNL DCSP  DCSP  DCSP response = challenge_response_pair['response'] DCNL DCSP if (response is None): DCNL DCSP  DCSP raise self.PageNotFoundException() DCNL DCSP self.response.headers['Content-Type'] = 'text/plain' DCNL DCSP self.response.write(response)
def test_email_preferences_updates(self): DCNL DCSP self.signup(self.EDITOR_EMAIL, username=self.EDITOR_USERNAME) DCNL DCSP editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/preferences') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP payload = {'update_type': 'email_preferences', 'data': {'can_receive_email_updates': True, 'can_receive_editor_role_email': True, 'can_receive_feedback_message_email': True, 'can_receive_subscription_email': True}} DCNL DCSP self.put_json('/preferenceshandler/data', payload, csrf_token=csrf_token) DCNL DCSP email_preferences = user_services.get_email_preferences(editor_id) DCNL DCSP self.assertTrue(email_preferences.can_receive_email_updates) DCNL DCSP self.assertTrue(email_preferences.can_receive_editor_role_email) DCNL DCSP self.assertTrue(email_preferences.can_receive_feedback_message_email) DCNL DCSP self.assertTrue(email_preferences.can_receive_subscription_email) DCNL DCSP payload = {'update_type': 'email_preferences', 'data': {'can_receive_email_updates': False, 'can_receive_editor_role_email': False, 'can_receive_feedback_message_email': False, 'can_receive_subscription_email': False}} DCNL DCSP self.put_json('/preferenceshandler/data', payload, csrf_token=csrf_token) DCNL DCSP email_preferences = user_services.get_email_preferences(editor_id) DCNL DCSP self.assertFalse(email_preferences.can_receive_email_updates) DCNL DCSP self.assertFalse(email_preferences.can_receive_editor_role_email) DCNL DCSP self.assertFalse(email_preferences.can_receive_feedback_message_email) DCNL DCSP self.assertFalse(email_preferences.can_receive_subscription_email)
def test_save_site_language_handler(self): DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP language_code = 'es' DCNL DCSP self.login(self.EDITOR_EMAIL) DCNL DCSP response = self.testapp.get('/preferences') DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP self.put_json('/preferenceshandler/data', {'update_type': 'preferred_site_language_code', 'data': language_code}, csrf_token) DCNL DCSP preferences = self.get_json('/preferenceshandler/data') DCNL DCSP self.assertIsNotNone(preferences) DCNL DCSP self.assertEqual(preferences['preferred_site_language_code'], language_code) DCNL DCSP self.logout()
@acl_decorators.can_access_moderator_page DCNL def get(self): DCNL DCSP self.render_template('pages/moderator/moderator.html')
@acl_decorators.can_access_moderator_page DCNL def get(self): DCNL DCSP self.render_json({'featured_activity_references': [activity_reference.to_dict() for activity_reference in activity_services.get_featured_activity_references()]})
@acl_decorators.can_access_moderator_page DCNL def post(self): DCNL DCSP featured_activity_reference_dicts = self.payload.get('featured_activity_reference_dicts') DCNL DCSP featured_activity_references = [activity_domain.ActivityReference(reference_dict['type'], reference_dict['id']) for reference_dict in featured_activity_reference_dicts] DCNL DCSP try: DCNL DCSP  DCSP summary_services.require_activities_to_be_public(featured_activity_references) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP activity_services.update_featured_activity_references(featured_activity_references) DCNL DCSP self.render_json({})
@acl_decorators.can_send_moderator_emails DCNL def get(self, action): DCNL DCSP self.render_json({'draft_email_body': email_manager.get_draft_moderator_action_email(action)})
@acl_decorators.can_access_learner_dashboard DCNL def get(self): DCNL DCSP (learner_progress, number_of_deleted_activities, completed_to_incomplete_collections) = learner_progress_services.get_activity_progress(self.user_id) DCNL DCSP completed_exp_summary_dicts = summary_services.get_displayable_exp_summary_dicts(learner_progress.completed_exp_summaries) DCNL DCSP incomplete_exp_summary_dicts = summary_services.get_displayable_exp_summary_dicts(learner_progress.incomplete_exp_summaries) DCNL DCSP completed_collection_summary_dicts = learner_progress_services.get_collection_summary_dicts(learner_progress.completed_collection_summaries) DCNL DCSP incomplete_collection_summary_dicts = learner_progress_services.get_collection_summary_dicts(learner_progress.incomplete_collection_summaries) DCNL DCSP exploration_playlist_summary_dicts = summary_services.get_displayable_exp_summary_dicts(learner_progress.exploration_playlist_summaries) DCNL DCSP collection_playlist_summary_dicts = learner_progress_services.get_collection_summary_dicts(learner_progress.collection_playlist_summaries) DCNL DCSP full_thread_ids = subscription_services.get_all_threads_subscribed_to(self.user_id) DCNL DCSP if (len(full_thread_ids) > 0): DCNL DCSP  DCSP (thread_summaries, number_of_unread_threads) = feedback_services.get_thread_summaries(self.user_id, full_thread_ids) DCNL DCSP else: DCNL DCSP  DCSP (thread_summaries, number_of_unread_threads) = ([], 0) DCNL DCSP creators_subscribed_to = subscription_services.get_all_creators_subscribed_to(self.user_id) DCNL DCSP creators_settings = user_services.get_users_settings(creators_subscribed_to) DCNL DCSP subscription_list = [] DCNL DCSP for (index, creator_settings) in enumerate(creators_settings): DCNL DCSP  DCSP subscription_summary = {'creator_picture_data_url': creator_settings.profile_picture_data_url, 'creator_username': creator_settings.username, 'creator_impact': user_services.get_user_impact_score(creators_subscribed_to[index])} DCNL DCSP  DCSP subscription_list.append(subscription_summary) DCNL DCSP self.values.update({'completed_explorations_list': completed_exp_summary_dicts, 'completed_collections_list': completed_collection_summary_dicts, 'incomplete_explorations_list': incomplete_exp_summary_dicts, 'incomplete_collections_list': incomplete_collection_summary_dicts, 'exploration_playlist': exploration_playlist_summary_dicts, 'collection_playlist': collection_playlist_summary_dicts, 'number_of_deleted_activities': number_of_deleted_activities, 'completed_to_incomplete_collections': completed_to_incomplete_collections, 'thread_summaries': thread_summaries, 'number_of_unread_threads': number_of_unread_threads, 'subscription_list': subscription_list}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_access_learner_dashboard DCNL def get(self, exploration_id, thread_id): DCNL DCSP messages = feedback_services.get_messages(exploration_id, thread_id) DCNL DCSP author_ids = [m.author_id for m in messages] DCNL DCSP authors_settings = user_services.get_users_settings(author_ids) DCNL DCSP message_ids = [m.message_id for m in messages] DCNL DCSP feedback_services.update_messages_read_by_the_user(self.user_id, exploration_id, thread_id, message_ids) DCNL DCSP message_summary_list = [] DCNL DCSP suggestion = feedback_services.get_suggestion(exploration_id, thread_id) DCNL DCSP if suggestion: DCNL DCSP  DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP  DCSP current_content_html = exploration.states[suggestion.state_name].content.html DCNL DCSP  DCSP suggestion_summary = {'suggestion_html': suggestion.suggestion_html, 'current_content_html': current_content_html, 'description': suggestion.description, 'author_username': authors_settings[0].username, 'author_picture_data_url': authors_settings[0].profile_picture_data_url} DCNL DCSP  DCSP message_summary_list.append(suggestion_summary) DCNL DCSP  DCSP messages.pop(0) DCNL DCSP  DCSP authors_settings.pop(0) DCNL DCSP for (m, author_settings) in zip(messages, authors_settings): DCNL DCSP  DCSP message_summary = {'message_id': m.message_id, 'text': m.text, 'updated_status': m.updated_status, 'author_username': author_settings.username, 'author_picture_data_url': author_settings.profile_picture_data_url, 'created_on': utils.get_time_in_millisecs(m.created_on)} DCNL DCSP  DCSP message_summary_list.append(message_summary) DCNL DCSP self.render_json({'message_summary_list': message_summary_list})
def test_moderator_page(self): DCNL DCSP response = self.testapp.get('/moderator') DCNL DCSP self.assertEqual(response.status_int, 302) DCNL DCSP self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME) DCNL DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP response = self.testapp.get('/moderator', expect_errors=True) DCNL DCSP self.assertEqual(response.status_int, 401) DCNL DCSP self.logout() DCNL DCSP self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME) DCNL DCSP self.set_moderators([self.MODERATOR_USERNAME]) DCNL DCSP self.login(self.MODERATOR_EMAIL) DCNL DCSP response = self.testapp.get('/moderator') DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.logout() DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.set_admins([self.ADMIN_USERNAME]) DCNL DCSP self.login(self.ADMIN_EMAIL) DCNL DCSP response = self.testapp.get('/moderator') DCNL DCSP self.assertEqual(response.status_int, 200) DCNL DCSP self.logout()
@acl_decorators.open_access DCNL def get(self): DCNL DCSP version_id = self.request.get('v') DCNL DCSP if (not version_id): DCNL DCSP  DCSP version_ids = ['a', 'b', 'c', 'd'] DCNL DCSP  DCSP version_id = random.choice(version_ids) DCNL DCSP  DCSP self.redirect(('/fractions?v=%s' % version_id)) DCNL DCSP self.render_template(('pages/landing/fractions/landing_page_%s.html' % version_id))
@acl_decorators.can_edit_collection DCNL def get(self, collection_id): DCNL DCSP collection = collection_services.get_collection_by_id(collection_id, strict=False) DCNL DCSP self.values.update({'collection_id': collection.id, 'nav_mode': feconf.NAV_MODE_CREATE, 'SHOW_COLLECTION_NAVIGATION_TAB_HISTORY': feconf.SHOW_COLLECTION_NAVIGATION_TAB_HISTORY, 'SHOW_COLLECTION_NAVIGATION_TAB_STATS': feconf.SHOW_COLLECTION_NAVIGATION_TAB_STATS, 'TAG_REGEX': feconf.TAG_REGEX}) DCNL DCSP self.render_template('pages/collection_editor/collection_editor.html')
def _require_valid_version(self, version_from_payload, collection_version): DCNL DCSP if (version_from_payload is None): DCNL DCSP  DCSP raise base.BaseHandler.InvalidInputException('Invalid DCSP POST DCSP request: DCSP a DCSP version DCSP must DCSP be DCSP specified.') DCNL DCSP if (version_from_payload != collection_version): DCNL DCSP  DCSP raise base.BaseHandler.InvalidInputException(('Trying DCSP to DCSP update DCSP version DCSP %s DCSP of DCSP collection DCSP from DCSP version DCSP %s, DCSP which DCSP is DCSP too DCSP old. DCSP Please DCSP reload DCSP the DCSP page DCSP and DCSP try DCSP again.' % (collection_version, version_from_payload)))
@acl_decorators.can_edit_collection DCNL def get(self, collection_id): DCNL DCSP try: DCNL DCSP  DCSP collection_dict = summary_services.get_learner_collection_dict_by_id(collection_id, self.user_id, allow_invalid_explorations=True) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise self.PageNotFoundException(e) DCNL DCSP self.values.update({'collection': collection_dict}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_edit_collection DCNL def put(self, collection_id): DCNL DCSP collection = collection_services.get_collection_by_id(collection_id) DCNL DCSP version = self.payload.get('version') DCNL DCSP self._require_valid_version(version, collection.version) DCNL DCSP commit_message = self.payload.get('commit_message') DCNL DCSP change_list = self.payload.get('change_list') DCNL DCSP try: DCNL DCSP  DCSP collection_services.update_collection(self.user_id, collection_id, change_list, commit_message) DCNL DCSP except utils.ValidationError as e: DCNL DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP collection_dict = summary_services.get_learner_collection_dict_by_id(collection_id, self.user_id, allow_invalid_explorations=True) DCNL DCSP self.values.update({'collection': collection_dict}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_edit_collection DCNL def get(self, collection_id): DCNL DCSP collection = collection_services.get_collection_by_id(collection_id) DCNL DCSP collection_rights = rights_manager.get_collection_rights(collection_id, strict=False) DCNL DCSP self.values.update({'can_edit': True, 'can_unpublish': rights_manager.check_can_unpublish_collection(self.actions, collection_rights), 'collection_id': collection.id, 'is_private': rights_manager.is_collection_private(collection_id), 'owner_names': rights_manager.get_collection_owner_names(collection_id)}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_manage_collection_publish_status DCNL def put(self, collection_id): DCNL DCSP collection = collection_services.get_collection_by_id(collection_id) DCNL DCSP version = self.payload.get('version') DCNL DCSP _require_valid_version(version, collection.version) DCNL DCSP collection_rights = rights_manager.get_collection_rights(collection_id, strict=False) DCNL DCSP make_public = self.payload.get('is_public') DCNL DCSP if (make_public is not None): DCNL DCSP  DCSP if make_public: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP collection.validate(strict=True) DCNL DCSP  DCSP  DCSP  DCSP collection_services.validate_exps_in_collection_are_public(collection) DCNL DCSP  DCSP  DCSP except utils.ValidationError as e: DCNL DCSP  DCSP  DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP  DCSP  DCSP collection_services.publish_collection_and_update_user_profiles(self.user_id, collection_id) DCNL DCSP  DCSP  DCSP collection_services.index_collections_given_ids([collection_id]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rights_manager.unpublish_collection(self.user_id, collection_id) DCNL DCSP  DCSP  DCSP collection_services.delete_documents_from_search_index([collection_id]) DCNL DCSP self.values.update({'can_edit': True, 'can_unpublish': rights_manager.check_can_unpublish_collection(self.actions, collection_rights), 'collection_id': collection.id, 'is_private': rights_manager.is_collection_private(collection_id), 'owner_names': rights_manager.get_collection_owner_names(collection_id)})
@acl_decorators.open_access DCNL def get(self): DCNL DCSP query_string = self.request.get('q') DCNL DCSP search_cursor = self.request.get('cursor', None) DCNL DCSP (collection_node_metadata_list, new_search_cursor) = summary_services.get_exp_metadata_dicts_matching_query(query_string, search_cursor, self.user_id) DCNL DCSP self.values.update({'collection_node_metadata_list': collection_node_metadata_list, 'search_cursor': new_search_cursor}) DCNL DCSP self.render_json(self.values)
@acl_decorators.open_access DCNL def post(self): DCNL DCSP signature = self.payload.get('signature') DCNL DCSP message = self.payload.get('message') DCNL DCSP vm_id = self.payload.get('vm_id') DCNL DCSP if ((vm_id == feconf.DEFAULT_VM_ID) and (not feconf.DEV_MODE)): DCNL DCSP  DCSP raise self.UnauthorizedUserException DCNL DCSP if (not validate_job_result_message_dict(message)): DCNL DCSP  DCSP raise self.InvalidInputException DCNL DCSP if (not verify_signature(message, vm_id, signature)): DCNL DCSP  DCSP raise self.UnauthorizedUserException DCNL DCSP job_id = message['job_id'] DCNL DCSP classifier_data = message['classifier_data'] DCNL DCSP classifier_training_job = classifier_services.get_classifier_training_job_by_id(job_id) DCNL DCSP if (classifier_training_job.status == feconf.TRAINING_JOB_STATUS_FAILED): DCNL DCSP  DCSP raise self.InternalErrorException('The DCSP current DCSP status DCSP of DCSP the DCSP job DCSP cannot DCSP transition DCSP to DCSP COMPLETE.') DCNL DCSP try: DCNL DCSP  DCSP classifier_services.create_classifier(job_id, classifier_data) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise self.InternalErrorException(e) DCNL DCSP classifier_services.mark_training_job_complete(job_id) DCNL DCSP return self.render_json({})
def test_subscribe_handler(self): DCNL DCSP self.login(self.USER_EMAIL) DCNL DCSP response = self.testapp.get(feconf.CREATOR_DASHBOARD_URL) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP payload = {'creator_username': self.EDITOR_USERNAME} DCNL DCSP self.post_json(feconf.SUBSCRIBE_URL_PREFIX, payload, csrf_token) DCNL DCSP self.assertEqual(subscription_services.get_all_subscribers_of_creator(self.editor_id), [self.user_id]) DCNL DCSP self.assertEqual(subscription_services.get_all_creators_subscribed_to(self.user_id), [self.editor_id]) DCNL DCSP self.post_json(feconf.SUBSCRIBE_URL_PREFIX, payload, csrf_token) DCNL DCSP self.assertEqual(subscription_services.get_all_subscribers_of_creator(self.editor_id), [self.user_id]) DCNL DCSP self.assertEqual(subscription_services.get_all_creators_subscribed_to(self.user_id), [self.editor_id]) DCNL DCSP self.logout() DCNL DCSP self.login(self.USER2_EMAIL) DCNL DCSP response = self.testapp.get(feconf.CREATOR_DASHBOARD_URL) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP self.post_json(feconf.SUBSCRIBE_URL_PREFIX, payload, csrf_token) DCNL DCSP self.assertEqual(subscription_services.get_all_subscribers_of_creator(self.editor_id), [self.user_id, self.user_id_2]) DCNL DCSP self.assertEqual(subscription_services.get_all_creators_subscribed_to(self.user_id_2), [self.editor_id]) DCNL DCSP self.logout()
def test_unsubscribe_handler(self): DCNL DCSP payload = {'creator_username': self.EDITOR_USERNAME} DCNL DCSP self.login(self.USER_EMAIL) DCNL DCSP response = self.testapp.get(feconf.CREATOR_DASHBOARD_URL) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP self.post_json(feconf.SUBSCRIBE_URL_PREFIX, payload, csrf_token) DCNL DCSP self.logout() DCNL DCSP self.login(self.USER2_EMAIL) DCNL DCSP response = self.testapp.get(feconf.CREATOR_DASHBOARD_URL) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP self.post_json(feconf.SUBSCRIBE_URL_PREFIX, payload, csrf_token) DCNL DCSP self.post_json(feconf.UNSUBSCRIBE_URL_PREFIX, payload, csrf_token) DCNL DCSP self.assertEqual(subscription_services.get_all_subscribers_of_creator(self.editor_id), [self.user_id]) DCNL DCSP self.assertEqual(subscription_services.get_all_creators_subscribed_to(self.user_id_2), []) DCNL DCSP self.post_json(feconf.UNSUBSCRIBE_URL_PREFIX, payload, csrf_token) DCNL DCSP self.assertEqual(subscription_services.get_all_subscribers_of_creator(self.editor_id), [self.user_id]) DCNL DCSP self.assertEqual(subscription_services.get_all_creators_subscribed_to(self.user_id_2), []) DCNL DCSP self.logout() DCNL DCSP self.login(self.USER_EMAIL) DCNL DCSP response = self.testapp.get(feconf.CREATOR_DASHBOARD_URL) DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP self.post_json(feconf.UNSUBSCRIBE_URL_PREFIX, payload, csrf_token) DCNL DCSP self.assertEqual(subscription_services.get_all_subscribers_of_creator(self.editor_id), []) DCNL DCSP self.assertEqual(subscription_services.get_all_creators_subscribed_to(self.user_id), [])
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id): DCNL DCSP if (exploration_id in constants.DISABLED_EXPLORATION_IDS): DCNL DCSP  DCSP self.render_template('pages/error/disabled_exploration.html', iframe_restriction=None) DCNL DCSP  DCSP return DCNL DCSP exploration = exp_services.get_exploration_by_id(exploration_id, strict=False) DCNL DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP visualizations_html = visualization_registry.Registry.get_full_html() DCNL DCSP interaction_ids = interaction_registry.Registry.get_all_interaction_ids() DCNL DCSP interaction_dependency_ids = interaction_registry.Registry.get_deduplicated_dependency_ids(interaction_ids) DCNL DCSP (dependencies_html, additional_angular_modules) = dependency_registry.Registry.get_deps_html_and_angular_modules((interaction_dependency_ids + self.EDITOR_PAGE_DEPENDENCY_IDS)) DCNL DCSP interaction_templates = (rte_component_registry.Registry.get_html_for_all_components() + interaction_registry.Registry.get_interaction_html(interaction_ids)) DCNL DCSP gadget_types = gadget_registry.Registry.get_all_gadget_types() DCNL DCSP gadget_templates = gadget_registry.Registry.get_gadget_html(gadget_types) DCNL DCSP self.values.update({'GADGET_SPECS': gadget_registry.Registry.get_all_specs(), 'INTERACTION_SPECS': interaction_registry.Registry.get_all_specs(), 'PANEL_SPECS': feconf.PANELS_PROPERTIES, 'DEFAULT_OBJECT_VALUES': obj_services.get_default_object_values(), 'DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR': DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR.value, 'additional_angular_modules': additional_angular_modules, 'can_delete': rights_manager.check_can_delete_exploration(self.user_id, self.actions, exploration_rights), 'can_edit': rights_manager.check_can_edit_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_EXPLORATION, exploration_rights), 'can_modify_roles': rights_manager.check_can_modify_exploration_roles(self.user_id, self.actions, exploration_rights), 'can_publicize': rights_manager.check_can_publicize_exploration(self.actions, exploration_rights), 'can_publish': rights_manager.check_can_publish_exploration(self.user_id, self.actions, exploration_rights), 'can_release_ownership': rights_manager.check_can_release_ownership(self.user_id, self.actions, exploration_rights), 'can_unpublicize': rights_manager.check_can_unpublicize_exploration(self.actions, exploration_rights), 'can_unpublish': rights_manager.check_can_unpublish_exploration(self.actions, exploration_rights), 'dependencies_html': jinja2.utils.Markup(dependencies_html), 'gadget_templates': jinja2.utils.Markup(gadget_templates), 'interaction_templates': jinja2.utils.Markup(interaction_templates), 'meta_description': feconf.CREATE_PAGE_DESCRIPTION, 'nav_mode': feconf.NAV_MODE_CREATE, 'value_generators_js': jinja2.utils.Markup(get_value_generators_js()), 'title': exploration.title, 'visualizations_html': jinja2.utils.Markup(visualizations_html), 'ALLOWED_GADGETS': feconf.ALLOWED_GADGETS, 'ALLOWED_INTERACTION_CATEGORIES': feconf.ALLOWED_INTERACTION_CATEGORIES, 'INVALID_PARAMETER_NAMES': feconf.INVALID_PARAMETER_NAMES, 'NEW_STATE_TEMPLATE': NEW_STATE_TEMPLATE, 'SHOW_TRAINABLE_UNRESOLVED_ANSWERS': feconf.SHOW_TRAINABLE_UNRESOLVED_ANSWERS, 'TAG_REGEX': feconf.TAG_REGEX}) DCNL DCSP self.render_template('pages/exploration_editor/exploration_editor.html')
def _get_exploration_data(self, exploration_id, apply_draft=False, version=None): DCNL DCSP try: DCNL DCSP  DCSP if apply_draft: DCNL DCSP  DCSP  DCSP exploration = exp_services.get_exp_with_draft_applied(exploration_id, self.user_id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP exploration = exp_services.get_exploration_by_id(exploration_id, version=version) DCNL DCSP except: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP states = {} DCNL DCSP for state_name in exploration.states: DCNL DCSP  DCSP state_dict = exploration.states[state_name].to_dict() DCNL DCSP  DCSP states[state_name] = state_dict DCNL DCSP exp_user_data = user_models.ExplorationUserDataModel.get(self.user_id, exploration_id) DCNL DCSP draft_changes = (exp_user_data.draft_change_list if (exp_user_data and exp_user_data.draft_change_list) else None) DCNL DCSP is_version_of_draft_valid = (exp_services.is_version_of_draft_valid(exploration_id, exp_user_data.draft_change_list_exp_version) if (exp_user_data and exp_user_data.draft_change_list_exp_version) else None) DCNL DCSP draft_change_list_id = (exp_user_data.draft_change_list_id if exp_user_data else 0) DCNL DCSP exploration_email_preferences = user_services.get_email_preferences_for_exploration(self.user_id, exploration_id) DCNL DCSP editor_dict = {'category': exploration.category, 'draft_change_list_id': draft_change_list_id, 'exploration_id': exploration_id, 'init_state_name': exploration.init_state_name, 'language_code': exploration.language_code, 'objective': exploration.objective, 'param_changes': exploration.param_change_dicts, 'param_specs': exploration.param_specs_dict, 'rights': rights_manager.get_exploration_rights(exploration_id).to_dict(), 'show_state_editor_tutorial_on_load': (self.user_id and (not self.has_seen_editor_tutorial)), 'skin_customizations': exploration.skin_instance.to_dict()['skin_customizations'], 'states': states, 'tags': exploration.tags, 'title': exploration.title, 'version': exploration.version, 'is_version_of_draft_valid': is_version_of_draft_valid, 'draft_changes': draft_changes, 'email_preferences': exploration_email_preferences.to_dict()} DCNL DCSP return editor_dict
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id): DCNL DCSP version = self.request.get('v', default_value=None) DCNL DCSP apply_draft = self.request.get('apply_draft', default_value=False) DCNL DCSP self.values.update(self._get_exploration_data(exploration_id, apply_draft=apply_draft, version=version)) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_edit_exploration DCNL def put(self, exploration_id): DCNL DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP version = self.payload.get('version') DCNL DCSP _require_valid_version(version, exploration.version) DCNL DCSP commit_message = self.payload.get('commit_message') DCNL DCSP change_list = self.payload.get('change_list') DCNL DCSP try: DCNL DCSP  DCSP exp_services.update_exploration(self.user_id, exploration_id, change_list, commit_message) DCNL DCSP except utils.ValidationError as e: DCNL DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP self.values.update(self._get_exploration_data(exploration_id)) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_delete_exploration DCNL def delete(self, exploration_id): DCNL DCSP log_debug_string = ('(%s) DCSP %s DCSP tried DCSP to DCSP delete DCSP exploration DCSP %s' % (self.role, self.user_id, exploration_id)) DCNL DCSP logging.debug(log_debug_string) DCNL DCSP is_exploration_cloned = rights_manager.is_exploration_cloned(exploration_id) DCNL DCSP exp_services.delete_exploration(self.user_id, exploration_id, force_deletion=is_exploration_cloned) DCNL DCSP log_info_string = ('(%s) DCSP %s DCSP deleted DCSP exploration DCSP %s' % (self.role, self.user_id, exploration_id)) DCNL DCSP logging.info(log_info_string)
@acl_decorators.can_modify_exploration_roles DCNL def put(self, exploration_id): DCNL DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP version = self.payload.get('version') DCNL DCSP _require_valid_version(version, exploration.version) DCNL DCSP make_community_owned = self.payload.get('is_community_owned') DCNL DCSP new_member_username = self.payload.get('new_member_username') DCNL DCSP new_member_role = self.payload.get('new_member_role') DCNL DCSP viewable_if_private = self.payload.get('viewable_if_private') DCNL DCSP if new_member_username: DCNL DCSP  DCSP new_member_id = user_services.get_user_id_from_username(new_member_username) DCNL DCSP  DCSP if (new_member_id is None): DCNL DCSP  DCSP  DCSP raise Exception('Sorry, DCSP we DCSP could DCSP not DCSP find DCSP the DCSP specified DCSP user.') DCNL DCSP  DCSP rights_manager.assign_role_for_exploration(self.user_id, exploration_id, new_member_id, new_member_role) DCNL DCSP  DCSP email_manager.send_role_notification_email(self.user_id, new_member_id, new_member_role, exploration_id, exploration.title) DCNL DCSP elif make_community_owned: DCNL DCSP  DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP exploration.validate(strict=True) DCNL DCSP  DCSP except utils.ValidationError as e: DCNL DCSP  DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP  DCSP rights_manager.release_ownership_of_exploration(self.user_id, exploration_id) DCNL DCSP elif (viewable_if_private is not None): DCNL DCSP  DCSP rights_manager.set_private_viewability_of_exploration(self.user_id, exploration_id, viewable_if_private) DCNL DCSP else: DCNL DCSP  DCSP raise self.InvalidInputException('No DCSP change DCSP was DCSP made DCSP to DCSP this DCSP exploration.') DCNL DCSP self.render_json({'rights': rights_manager.get_exploration_rights(exploration_id).to_dict()})
def _publish_exploration(self, exploration_id): DCNL DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP try: DCNL DCSP  DCSP exploration.validate(strict=True) DCNL DCSP except utils.ValidationError as e: DCNL DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP exp_services.publish_exploration_and_update_user_profiles(self.user_id, exploration_id) DCNL DCSP exp_services.index_explorations_given_ids([exploration_id])
def _unpublicize_exploration(self, exploration_id): DCNL DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP try: DCNL DCSP  DCSP exploration.validate(strict=True) DCNL DCSP except utils.ValidationError as e: DCNL DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP rights_manager.unpublicize_exploration(self.user_id, exploration_id)
@acl_decorators.can_access_moderator_page DCNL def put(self, exploration_id): DCNL DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP action = self.payload.get('action') DCNL DCSP email_body = self.payload.get('email_body') DCNL DCSP version = self.payload.get('version') DCNL DCSP _require_valid_version(version, exploration.version) DCNL DCSP if (action not in feconf.VALID_MODERATOR_ACTIONS): DCNL DCSP  DCSP raise self.InvalidInputException('Invalid DCSP moderator DCSP action.') DCNL DCSP if feconf.REQUIRE_EMAIL_ON_MODERATOR_ACTION: DCNL DCSP  DCSP if (not email_body): DCNL DCSP  DCSP  DCSP raise self.InvalidInputException('Moderator DCSP actions DCSP should DCSP include DCSP an DCSP email DCSP to DCSP the DCSP recipient.') DCNL DCSP  DCSP email_manager.require_moderator_email_prereqs_are_satisfied() DCNL DCSP if (action == 'unpublish_exploration'): DCNL DCSP  DCSP rights_manager.unpublish_exploration(self.user_id, exploration_id) DCNL DCSP  DCSP exp_services.delete_documents_from_search_index([exploration_id]) DCNL DCSP elif (action == 'publicize_exploration'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP exploration.validate(strict=True) DCNL DCSP  DCSP except utils.ValidationError as e: DCNL DCSP  DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP  DCSP rights_manager.publicize_exploration(self.user_id, exploration_id) DCNL DCSP else: DCNL DCSP  DCSP raise self.InvalidInputException('No DCSP change DCSP was DCSP made DCSP to DCSP this DCSP exploration.') DCNL DCSP exp_rights = rights_manager.get_exploration_rights(exploration_id) DCNL DCSP if feconf.REQUIRE_EMAIL_ON_MODERATOR_ACTION: DCNL DCSP  DCSP for owner_id in exp_rights.owner_ids: DCNL DCSP  DCSP  DCSP email_manager.send_moderator_action_email(self.user_id, owner_id, feconf.VALID_MODERATOR_ACTIONS[action]['email_intent'], exploration.title, email_body) DCNL DCSP self.render_json({'rights': exp_rights.to_dict()})
@acl_decorators.can_edit_exploration DCNL def put(self, exploration_id): DCNL DCSP mute = self.payload.get('mute') DCNL DCSP message_type = self.payload.get('message_type') DCNL DCSP if (message_type == feconf.MESSAGE_TYPE_FEEDBACK): DCNL DCSP  DCSP user_services.set_email_preferences_for_exploration(self.user_id, exploration_id, mute_feedback_notifications=mute) DCNL DCSP elif (message_type == feconf.MESSAGE_TYPE_SUGGESTION): DCNL DCSP  DCSP user_services.set_email_preferences_for_exploration(self.user_id, exploration_id, mute_suggestion_notifications=mute) DCNL DCSP else: DCNL DCSP  DCSP raise self.InvalidInputException('Invalid DCSP message DCSP type.') DCNL DCSP exploration_email_preferences = user_services.get_email_preferences_for_exploration(self.user_id, exploration_id) DCNL DCSP self.render_json({'email_preferences': exploration_email_preferences.to_dict()})
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id, escaped_state_name): DCNL DCSP try: DCNL DCSP  DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP except: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP state_name = utils.unescape_encoded_uri_component(escaped_state_name) DCNL DCSP if (state_name not in exploration.states): DCNL DCSP  DCSP self.render_json({'unhandled_answers': []}) DCNL DCSP  DCSP return DCNL DCSP state = exploration.states[state_name] DCNL DCSP submitted_answers = [] DCNL DCSP interaction = state.interaction DCNL DCSP unhandled_answers = [] DCNL DCSP if (feconf.SHOW_TRAINABLE_UNRESOLVED_ANSWERS and interaction.id): DCNL DCSP  DCSP interaction_instance = interaction_registry.Registry.get_interaction_by_id(interaction.id) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for answer in submitted_answers: DCNL DCSP  DCSP  DCSP  DCSP answer['answer'] = interaction_instance.normalize_answer(answer['answer']) DCNL DCSP  DCSP  DCSP trained_answers = set() DCNL DCSP  DCSP  DCSP for answer_group in interaction.answer_groups: DCNL DCSP  DCSP  DCSP  DCSP for rule_spec in answer_group.rule_specs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (rule_spec.rule_type == exp_domain.RULE_TYPE_CLASSIFIER): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP trained_answers.update((interaction_instance.normalize_answer(trained) for trained in rule_spec.inputs['training_data'])) DCNL DCSP  DCSP  DCSP trained_answers.update(set((interaction_instance.normalize_answer(confirmed) for confirmed in interaction.confirmed_unclassified_answers))) DCNL DCSP  DCSP  DCSP unhandled_answers = [answer for answer in submitted_answers if (answer['answer'] not in trained_answers)] DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logging.warning(('Error DCSP loading DCSP untrained DCSP answers DCSP for DCSP interaction DCSP %s: DCSP %s.' % (interaction.id, e))) DCNL DCSP self.render_json({'unhandled_answers': unhandled_answers})
@acl_decorators.can_download_exploration DCNL def get(self, exploration_id): DCNL DCSP try: DCNL DCSP  DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP except: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP version = self.request.get('v', default_value=exploration.version) DCNL DCSP output_format = self.request.get('output_format', default_value='zip') DCNL DCSP width = int(self.request.get('width', default_value=80)) DCNL DCSP filename = ('oppia-%s-v%s' % (utils.to_ascii(exploration.title.replace(' DCSP ', '')), version)) DCNL DCSP if (output_format == feconf.OUTPUT_FORMAT_ZIP): DCNL DCSP  DCSP self.response.headers['Content-Type'] = 'text/plain' DCNL DCSP  DCSP self.response.headers['Content-Disposition'] = ('attachment; DCSP filename=%s.zip' % str(filename)) DCNL DCSP  DCSP self.response.write(exp_services.export_to_zip_file(exploration_id, version)) DCNL DCSP elif (output_format == feconf.OUTPUT_FORMAT_JSON): DCNL DCSP  DCSP self.render_json(exp_services.export_states_to_yaml(exploration_id, version=version, width=width)) DCNL DCSP else: DCNL DCSP  DCSP raise self.InvalidInputException(('Unrecognized DCSP output DCSP format DCSP %s' % output_format))
@acl_decorators.can_play_exploration DCNL def post(self, unused_exploration_id): DCNL DCSP try: DCNL DCSP  DCSP state_dict = self.payload.get('state_dict') DCNL DCSP  DCSP width = self.payload.get('width') DCNL DCSP except Exception: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP self.render_json({'yaml': exp_services.convert_state_dict_to_yaml(state_dict, width)})
@acl_decorators.can_edit_exploration DCNL def get(self, exploration_id): DCNL DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(exploration_id)) DCNL DCSP dir_list = fs.listdir('') DCNL DCSP self.render_json({'filepaths': dir_list})
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id): DCNL DCSP try: DCNL DCSP  DCSP snapshots = exp_services.get_exploration_snapshots_metadata(exploration_id) DCNL DCSP except: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP for snapshot in snapshots: DCNL DCSP  DCSP if (snapshot['committer_id'] != feconf.SYSTEM_COMMITTER_ID): DCNL DCSP  DCSP  DCSP snapshot['committer_id'] = user_services.get_username(snapshot['committer_id']) DCNL DCSP self.render_json({'snapshots': snapshots})
@acl_decorators.can_edit_exploration DCNL def post(self, exploration_id): DCNL DCSP current_version = self.payload.get('current_version') DCNL DCSP revert_to_version = self.payload.get('revert_to_version') DCNL DCSP if (not isinstance(revert_to_version, int)): DCNL DCSP  DCSP raise self.InvalidInputException(('Expected DCSP an DCSP integer DCSP version DCSP to DCSP revert DCSP to; DCSP received DCSP %s.' % revert_to_version)) DCNL DCSP if (not isinstance(current_version, int)): DCNL DCSP  DCSP raise self.InvalidInputException(('Expected DCSP an DCSP integer DCSP current DCSP version; DCSP received DCSP %s.' % current_version)) DCNL DCSP if ((revert_to_version < 1) or (revert_to_version >= current_version)): DCNL DCSP  DCSP raise self.InvalidInputException(('Cannot DCSP revert DCSP to DCSP version DCSP %s DCSP from DCSP version DCSP %s.' % (revert_to_version, current_version))) DCNL DCSP exp_services.discard_draft(exploration_id, self.user_id) DCNL DCSP exp_services.revert_exploration(self.user_id, exploration_id, current_version, revert_to_version) DCNL DCSP self.render_json({})
@acl_decorators.can_view_exploration_stats DCNL def get(self, exploration_id, exploration_version): DCNL DCSP try: DCNL DCSP  DCSP exp_services.get_exploration_by_id(exploration_id) DCNL DCSP except: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP self.render_json(stats_services.get_exploration_stats(exploration_id, exploration_version))
@acl_decorators.can_view_exploration_stats DCNL def get(self, exploration_id): DCNL DCSP try: DCNL DCSP  DCSP exp_services.get_exploration_by_id(exploration_id) DCNL DCSP except: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP self.render_json({'versions': stats_services.get_versions_for_exploration_stats(exploration_id)})
@acl_decorators.can_view_exploration_stats DCNL def get(self, exploration_id, escaped_state_name): DCNL DCSP try: DCNL DCSP  DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP except: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP state_name = utils.unescape_encoded_uri_component(escaped_state_name) DCNL DCSP if (state_name not in exploration.states): DCNL DCSP  DCSP logging.error(('Could DCSP not DCSP find DCSP state: DCSP %s' % state_name)) DCNL DCSP  DCSP logging.error(('Available DCSP states: DCSP %s' % exploration.states.keys())) DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP self.render_json({'visualizations_info': stats_services.get_visualizations_info(exploration_id, state_name)})
@acl_decorators.can_edit_exploration DCNL def post(self, exploration_id): DCNL DCSP raw = self.request.get('image') DCNL DCSP filename = self.payload.get('filename') DCNL DCSP if (not raw): DCNL DCSP  DCSP raise self.InvalidInputException('No DCSP image DCSP supplied') DCNL DCSP allowed_formats = ', DCSP '.join(feconf.ACCEPTED_IMAGE_FORMATS_AND_EXTENSIONS.keys()) DCNL DCSP file_format = imghdr.what(None, h=raw) DCNL DCSP if (file_format not in feconf.ACCEPTED_IMAGE_FORMATS_AND_EXTENSIONS): DCNL DCSP  DCSP raise self.InvalidInputException('Image DCSP not DCSP recognized') DCNL DCSP if (not filename): DCNL DCSP  DCSP raise self.InvalidInputException('No DCSP filename DCSP supplied') DCNL DCSP if (('/' in filename) or ('..' in filename)): DCNL DCSP  DCSP raise self.InvalidInputException('Filenames DCSP should DCSP not DCSP include DCSP slashes DCSP (/) DCSP or DCSP consecutive DCSP dot DCSP characters.') DCNL DCSP if ('.' not in filename): DCNL DCSP  DCSP raise self.InvalidInputException(('Image DCSP filename DCSP with DCSP no DCSP extension: DCSP it DCSP should DCSP have DCSP one DCSP of DCSP the DCSP following DCSP extensions: DCSP %s.' % allowed_formats)) DCNL DCSP dot_index = filename.rfind('.') DCNL DCSP extension = filename[(dot_index + 1):].lower() DCNL DCSP if (extension not in feconf.ACCEPTED_IMAGE_FORMATS_AND_EXTENSIONS[file_format]): DCNL DCSP  DCSP raise self.InvalidInputException(('Expected DCSP a DCSP filename DCSP ending DCSP in DCSP .%s, DCSP received DCSP %s' % (file_format, filename))) DCNL DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(exploration_id)) DCNL DCSP if fs.isfile(filename): DCNL DCSP  DCSP raise self.InvalidInputException(('A DCSP file DCSP with DCSP the DCSP name DCSP %s DCSP already DCSP exists. DCSP Please DCSP choose DCSP a DCSP different DCSP name.' % filename)) DCNL DCSP fs.commit(self.user_id, filename, raw) DCNL DCSP self.render_json({'filepath': filename})
@acl_decorators.can_edit_exploration DCNL def post(self, exploration_id): DCNL DCSP raw_audio_file = self.request.get('raw_audio_file') DCNL DCSP filename = self.payload.get('filename') DCNL DCSP allowed_formats = feconf.ACCEPTED_AUDIO_EXTENSIONS.keys() DCNL DCSP if (not raw_audio_file): DCNL DCSP  DCSP raise self.InvalidInputException('No DCSP audio DCSP supplied') DCNL DCSP dot_index = filename.rfind('.') DCNL DCSP extension = filename[(dot_index + 1):].lower() DCNL DCSP if ((dot_index == (-1)) or (dot_index == 0)): DCNL DCSP  DCSP raise self.InvalidInputException(('No DCSP filename DCSP extension: DCSP it DCSP should DCSP have DCSP one DCSP of DCSP the DCSP following DCSP extensions: DCSP %s' % allowed_formats)) DCNL DCSP if (extension not in feconf.ACCEPTED_AUDIO_EXTENSIONS): DCNL DCSP  DCSP raise self.InvalidInputException(('Invalid DCSP filename DCSP extension: DCSP it DCSP should DCSP have DCSP one DCSP of DCSP the DCSP following DCSP extensions: DCSP %s' % allowed_formats)) DCNL DCSP tempbuffer = StringIO.StringIO() DCNL DCSP tempbuffer.write(raw_audio_file) DCNL DCSP tempbuffer.seek(0) DCNL DCSP try: DCNL DCSP  DCSP audio = mutagen.File(tempbuffer) DCNL DCSP except mutagen.MutagenError: DCNL DCSP  DCSP raise self.InvalidInputException('Could DCSP not DCSP open DCSP uploadedaudio DCSP file') DCNL DCSP tempbuffer.close() DCNL DCSP if (audio is None): DCNL DCSP  DCSP raise self.InvalidInputException(('Audio DCSP not DCSP recognized DCSP as DCSP a DCSP %s DCSP file' % extension)) DCNL DCSP if (audio.info.length > feconf.MAX_AUDIO_FILE_LENGTH_SEC): DCNL DCSP  DCSP raise self.InvalidInputException(('Audio DCSP files DCSP must DCSP be DCSP under DCSP %s DCSP seconds DCSP in DCSP length. DCSP The DCSP uploaded DCSP file DCSP is DCSP %.2f DCSP seconds DCSP long.' % (feconf.MAX_AUDIO_FILE_LENGTH_SEC, audio.info.length))) DCNL DCSP if (len(set(audio.mime).intersection(set(feconf.ACCEPTED_AUDIO_EXTENSIONS[extension]))) == 0): DCNL DCSP  DCSP raise self.InvalidInputException(('Although DCSP the DCSP filename DCSP extension DCSP indicates DCSP the DCSP file DCSP is DCSP a DCSP %s DCSP file, DCSP it DCSP was DCSP not DCSP recognized DCSP as DCSP one. DCSP Found DCSP mime DCSP types: DCSP %s' % (extension, audio.mime))) DCNL DCSP mimetype = audio.mime[0] DCNL DCSP del audio DCNL DCSP file_system_class = (fs_domain.ExplorationFileSystem if feconf.DEV_MODE else fs_domain.GcsFileSystem) DCNL DCSP fs = fs_domain.AbstractFileSystem(file_system_class(exploration_id)) DCNL DCSP fs.commit(self.user_id, ('%s/%s' % (self._FILENAME_PREFIX, filename)), raw_audio_file, mimetype=mimetype) DCNL DCSP self.render_json({'filename': filename})
@acl_decorators.can_play_exploration DCNL def post(self, unused_exploration_id): DCNL DCSP user_services.record_user_started_state_editor_tutorial(self.user_id)
@acl_decorators.can_edit_exploration DCNL def put(self, exploration_id): DCNL DCSP try: DCNL DCSP  DCSP change_list = self.payload.get('change_list') DCNL DCSP  DCSP version = self.payload.get('version') DCNL DCSP  DCSP exp_services.create_or_update_draft(exploration_id, self.user_id, change_list, version, datetime.datetime.utcnow()) DCNL DCSP except utils.ValidationError as e: DCNL DCSP  DCSP raise self.InvalidInputException(e) DCNL DCSP exp_user_data = user_models.ExplorationUserDataModel.get(self.user_id, exploration_id) DCNL DCSP draft_change_list_id = exp_user_data.draft_change_list_id DCNL DCSP self.render_json({'draft_change_list_id': draft_change_list_id, 'is_version_of_draft_valid': exp_services.is_version_of_draft_valid(exploration_id, version)})
@acl_decorators.can_edit_exploration DCNL def post(self, exploration_id): DCNL DCSP exp_services.discard_draft(exploration_id, self.user_id) DCNL DCSP self.render_json({})
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id): DCNL DCSP version_str = self.request.get('v') DCNL DCSP version = (int(version_str) if version_str else None) DCNL DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP collection_id = self.request.get('collection_id') DCNL DCSP can_edit = rights_manager.check_can_edit_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_EXPLORATION, exploration_rights) DCNL DCSP if ((feconf.EXPLORATION_URL_EMBED_PREFIX in self.request.uri) or self.request.get('iframed')): DCNL DCSP  DCSP self.values['iframed'] = True DCNL DCSP try: DCNL DCSP  DCSP exploration_data_values = _get_exploration_player_data(exploration_id, version, collection_id, can_edit) DCNL DCSP except Exception: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP self.values.update(exploration_data_values) DCNL DCSP self.values['iframed'] = True DCNL DCSP self.render_template('pages/exploration_player/exploration_player.html', iframe_restriction=None)
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id): DCNL DCSP version_str = self.request.get('v') DCNL DCSP version = (int(version_str) if version_str else None) DCNL DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP if self.request.get('iframed'): DCNL DCSP  DCSP redirect_url = ('/embed/exploration/%s' % exploration_id) DCNL DCSP  DCSP if version_str: DCNL DCSP  DCSP  DCSP redirect_url += ('?v=%s' % version_str) DCNL DCSP  DCSP self.redirect(redirect_url) DCNL DCSP  DCSP return DCNL DCSP collection_id = self.request.get('collection_id') DCNL DCSP can_edit = rights_manager.check_can_edit_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_EXPLORATION, exploration_rights) DCNL DCSP try: DCNL DCSP  DCSP exploration_data_values = _get_exploration_player_data(exploration_id, version, collection_id, can_edit) DCNL DCSP except Exception: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP self.values.update(exploration_data_values) DCNL DCSP self.values['iframed'] = False DCNL DCSP self.render_template('pages/exploration_player/exploration_player.html')
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id): DCNL DCSP version = self.request.get('v') DCNL DCSP version = (int(version) if version else None) DCNL DCSP try: DCNL DCSP  DCSP exploration = exp_services.get_exploration_by_id(exploration_id, version=version) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise self.PageNotFoundException(e) DCNL DCSP exploration_rights = rights_manager.get_exploration_rights(exploration_id, strict=False) DCNL DCSP self.values.update({'can_edit': rights_manager.check_can_edit_activity(self.user_id, self.actions, constants.ACTIVITY_TYPE_EXPLORATION, exploration_rights), 'exploration': exploration.to_player_dict(), 'exploration_id': exploration_id, 'is_logged_in': bool(self.user_id), 'session_id': utils.generate_new_session_id(), 'version': exploration.version}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id): DCNL DCSP new_state_name = self.payload.get('new_state_name') DCNL DCSP exploration_version = self.payload.get('exploration_version') DCNL DCSP session_id = self.payload.get('session_id') DCNL DCSP client_time_spent_in_secs = self.payload.get('client_time_spent_in_secs') DCNL DCSP old_params = self.payload.get('old_params') DCNL DCSP if (new_state_name is not None): DCNL DCSP  DCSP event_services.StateHitEventHandler.record(exploration_id, exploration_version, new_state_name, session_id, old_params, feconf.PLAY_TYPE_NORMAL) DCNL DCSP else: DCNL DCSP  DCSP logging.error('Unexpected DCSP StateHit DCSP event DCSP for DCSP the DCSP END DCSP state.')
@acl_decorators.can_play_exploration DCNL def post(self, unused_exploration_id): DCNL DCSP old_state = exp_domain.State.from_dict(self.payload.get('old_state')) DCNL DCSP answer = self.payload.get('answer') DCNL DCSP params = self.payload.get('params') DCNL DCSP params['answer'] = answer DCNL DCSP result = classifier_services.classify(old_state, answer) DCNL DCSP self.render_json(result)
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id): DCNL DCSP state_name = self.payload.get('state_name') DCNL DCSP subject = self.payload.get('subject', 'Feedback DCSP from DCSP a DCSP learner') DCNL DCSP feedback = self.payload.get('feedback') DCNL DCSP include_author = self.payload.get('include_author') DCNL DCSP feedback_services.create_thread(exploration_id, state_name, (self.user_id if include_author else None), subject, feedback) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id): DCNL DCSP event_services.StartExplorationEventHandler.record(exploration_id, self.payload.get('version'), self.payload.get('state_name'), self.payload.get('session_id'), self.payload.get('params'), feconf.PLAY_TYPE_NORMAL)
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id): DCNL DCSP collection_id = self.payload.get('collection_id') DCNL DCSP user_id = self.user_id DCNL DCSP event_services.CompleteExplorationEventHandler.record(exploration_id, self.payload.get('version'), self.payload.get('state_name'), self.payload.get('session_id'), self.payload.get('client_time_spent_in_secs'), self.payload.get('params'), feconf.PLAY_TYPE_NORMAL) DCNL DCSP if user_id: DCNL DCSP  DCSP learner_progress_services.mark_exploration_as_completed(user_id, exploration_id) DCNL DCSP if (user_id and collection_id): DCNL DCSP  DCSP collection_services.record_played_exploration_in_collection_context(user_id, collection_id, exploration_id) DCNL DCSP  DCSP collections_left_to_complete = collection_services.get_next_exploration_ids_to_complete_by_user(user_id, collection_id) DCNL DCSP  DCSP if (not collections_left_to_complete): DCNL DCSP  DCSP  DCSP learner_progress_services.mark_collection_as_completed(user_id, collection_id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP learner_progress_services.mark_collection_as_incomplete(user_id, collection_id) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id): DCNL DCSP version = self.payload.get('version') DCNL DCSP state_name = self.payload.get('state_name') DCNL DCSP user_id = self.user_id DCNL DCSP collection_id = self.payload.get('collection_id') DCNL DCSP if user_id: DCNL DCSP  DCSP learner_progress_services.mark_exploration_as_incomplete(user_id, exploration_id, state_name, version) DCNL DCSP if (user_id and collection_id): DCNL DCSP  DCSP learner_progress_services.mark_collection_as_incomplete(user_id, collection_id) DCNL DCSP event_services.MaybeLeaveExplorationEventHandler.record(exploration_id, version, state_name, self.payload.get('session_id'), self.payload.get('client_time_spent_in_secs'), self.payload.get('params'), feconf.PLAY_TYPE_NORMAL) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id): DCNL DCSP self.values.update({'overall_ratings': rating_services.get_overall_ratings_for_exploration(exploration_id), 'user_rating': (rating_services.get_user_specific_rating_for_exploration(self.user_id, exploration_id) if self.user_id else None)}) DCNL DCSP self.render_json(self.values)
@acl_decorators.can_rate_exploration DCNL def put(self, exploration_id): DCNL DCSP user_rating = self.payload.get('user_rating') DCNL DCSP rating_services.assign_rating_to_exploration(self.user_id, exploration_id, user_rating) DCNL DCSP self.render_json({})
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id): DCNL DCSP collection_id = self.request.get('collection_id') DCNL DCSP include_system_recommendations = self.request.get('include_system_recommendations') DCNL DCSP try: DCNL DCSP  DCSP author_recommended_exp_ids = json.loads(self.request.get('stringified_author_recommended_ids')) DCNL DCSP except Exception: DCNL DCSP  DCSP raise self.PageNotFoundException DCNL DCSP auto_recommended_exp_ids = [] DCNL DCSP if (self.user_id and collection_id): DCNL DCSP  DCSP next_exp_ids_in_collection = collection_services.get_next_exploration_ids_to_complete_by_user(self.user_id, collection_id) DCNL DCSP  DCSP auto_recommended_exp_ids = list((set(next_exp_ids_in_collection) - set(author_recommended_exp_ids))) DCNL DCSP else: DCNL DCSP  DCSP next_exp_ids_in_collection = [] DCNL DCSP  DCSP if collection_id: DCNL DCSP  DCSP  DCSP collection = collection_services.get_collection_by_id(collection_id) DCNL DCSP  DCSP  DCSP next_exp_ids_in_collection = collection.get_next_exploration_ids_in_sequence(exploration_id) DCNL DCSP  DCSP if next_exp_ids_in_collection: DCNL DCSP  DCSP  DCSP auto_recommended_exp_ids = list((set(next_exp_ids_in_collection) - set(author_recommended_exp_ids))) DCNL DCSP  DCSP elif include_system_recommendations: DCNL DCSP  DCSP  DCSP system_chosen_exp_ids = recommendations_services.get_exploration_recommendations(exploration_id) DCNL DCSP  DCSP  DCSP filtered_exp_ids = list((set(system_chosen_exp_ids) - set(author_recommended_exp_ids))) DCNL DCSP  DCSP  DCSP auto_recommended_exp_ids = random.sample(filtered_exp_ids, min(MAX_SYSTEM_RECOMMENDATIONS, len(filtered_exp_ids))) DCNL DCSP self.values.update({'summaries': summary_services.get_displayable_exp_summary_dicts_matching_ids((author_recommended_exp_ids + auto_recommended_exp_ids))}) DCNL DCSP self.render_json(self.values)
@classmethod DCNL def dispatch_event(cls, event_type, *args, **kwargs): DCNL DCSP for klass in ALL_CONTINUOUS_COMPUTATION_MANAGERS: DCNL DCSP  DCSP if (event_type in klass.get_event_types_listened_to()): DCNL DCSP  DCSP  DCSP klass.on_incoming_event(event_type, *args, **kwargs)
@classmethod DCNL def is_normalized_username_taken(cls, normalized_username): DCNL DCSP return bool(cls.get_all().filter((cls.normalized_username == normalized_username)).get())
@classmethod DCNL def get_by_normalized_username(cls, normalized_username): DCNL DCSP return cls.get_all().filter((cls.normalized_username == normalized_username)).get()
@classmethod DCNL def get_by_role(cls, role): DCNL DCSP return cls.query((cls.role == role)).fetch()
@classmethod DCNL def create(cls, user_id, exploration_id): DCNL DCSP instance_id = cls._generate_id(user_id, exploration_id) DCNL DCSP return cls(id=instance_id, user_id=user_id, exploration_id=exploration_id)
@classmethod DCNL def get(cls, user_id, exploration_id): DCNL DCSP instance_id = cls._generate_id(user_id, exploration_id) DCNL DCSP return super(ExpUserLastPlaythroughModel, cls).get(instance_id, strict=False)
@classmethod DCNL def get_or_create(cls, user_id): DCNL DCSP entity = cls.get(user_id, strict=False) DCNL DCSP if (not entity): DCNL DCSP  DCSP entity = cls(id=user_id) DCNL DCSP return entity
@classmethod DCNL def create(cls, user_id, exploration_id): DCNL DCSP instance_id = cls._generate_id(user_id, exploration_id) DCNL DCSP return cls(id=instance_id, user_id=user_id, exploration_id=exploration_id)
@classmethod DCNL def get(cls, user_id, exploration_id): DCNL DCSP instance_id = cls._generate_id(user_id, exploration_id) DCNL DCSP return super(ExplorationUserDataModel, cls).get(instance_id, strict=False)
@classmethod DCNL def get_multi(cls, user_ids, exploration_id): DCNL DCSP instance_ids = (cls._generate_id(user_id, exploration_id) for user_id in user_ids) DCNL DCSP return super(ExplorationUserDataModel, cls).get_multi(instance_ids)
@classmethod DCNL def create(cls, user_id, collection_id): DCNL DCSP instance_id = cls._generate_id(user_id, collection_id) DCNL DCSP return cls(id=instance_id, user_id=user_id, collection_id=collection_id)
@classmethod DCNL def get(cls, user_id, collection_id): DCNL DCSP instance_id = cls._generate_id(user_id, collection_id) DCNL DCSP return super(CollectionProgressModel, cls).get(instance_id, strict=False)
@classmethod DCNL def get_multi(cls, user_id, collection_ids): DCNL DCSP instance_ids = [cls._generate_id(user_id, collection_id) for collection_id in collection_ids] DCNL DCSP return super(CollectionProgressModel, cls).get_multi(instance_ids)
@classmethod DCNL def get_or_create(cls, user_id, collection_id): DCNL DCSP instance_model = cls.get(user_id, collection_id) DCNL DCSP if instance_model: DCNL DCSP  DCSP return instance_model DCNL DCSP else: DCNL DCSP  DCSP return cls.create(user_id, collection_id)
@classmethod DCNL def fetch_page(cls, page_size, cursor): DCNL DCSP cursor = Cursor(urlsafe=cursor) DCNL DCSP (query_models, next_cursor, more) = cls.query().order((- cls.created_on)).fetch_page(page_size, start_cursor=cursor) DCNL DCSP next_cursor = (next_cursor.urlsafe() if (next_cursor and more) else None) DCNL DCSP return (query_models, next_cursor, more)
@classmethod DCNL def _generate_id(cls, intent): DCNL DCSP id_prefix = ('%s.' % intent) DCNL DCSP for _ in range(base_models.MAX_RETRIES): DCNL DCSP  DCSP new_id = ('%s.%s' % (id_prefix, utils.convert_to_hash(str(utils.get_random_int(base_models.RAND_RANGE)), base_models.ID_LENGTH))) DCNL DCSP  DCSP if (not cls.get_by_id(new_id)): DCNL DCSP  DCSP  DCSP return new_id DCNL DCSP raise Exception('The DCSP id DCSP generator DCSP for DCSP SentEmailModel DCSP is DCSP producing DCSP too DCSP many DCSP collisions.')
@classmethod DCNL def create(cls, recipient_id, recipient_email, sender_id, sender_email, intent, subject, html_body, sent_datetime): DCNL DCSP instance_id = cls._generate_id(intent) DCNL DCSP email_model_instance = cls(id=instance_id, recipient_id=recipient_id, recipient_email=recipient_email, sender_id=sender_id, sender_email=sender_email, intent=intent, subject=subject, html_body=html_body, sent_datetime=sent_datetime) DCNL DCSP email_model_instance.put()
def put(self): DCNL DCSP email_hash = self._generate_hash(self.recipient_id, self.subject, self.html_body) DCNL DCSP self.email_hash = email_hash DCNL DCSP super(SentEmailModel, self).put()
@classmethod DCNL def get_by_hash(cls, email_hash, sent_datetime_lower_bound=None): DCNL DCSP if (sent_datetime_lower_bound is not None): DCNL DCSP  DCSP if (not isinstance(sent_datetime_lower_bound, datetime.datetime)): DCNL DCSP  DCSP  DCSP raise Exception(('Expected DCSP datetime, DCSP received DCSP %s DCSP of DCSP type DCSP %s' % (sent_datetime_lower_bound, type(sent_datetime_lower_bound)))) DCNL DCSP query = cls.query().filter((cls.email_hash == email_hash)) DCNL DCSP if (sent_datetime_lower_bound is not None): DCNL DCSP  DCSP query = query.filter((cls.sent_datetime > sent_datetime_lower_bound)) DCNL DCSP messages = query.fetch() DCNL DCSP return messages
@classmethod DCNL def _generate_hash(cls, recipient_id, email_subject, email_body): DCNL DCSP hash_value = utils.convert_to_hash(((recipient_id + email_subject) + email_body), 100) DCNL DCSP return hash_value
@classmethod DCNL def check_duplicate_message(cls, recipient_id, email_subject, email_body): DCNL DCSP email_hash = cls._generate_hash(recipient_id, email_subject, email_body) DCNL DCSP datetime_now = datetime.datetime.utcnow() DCNL DCSP time_interval = datetime.timedelta(minutes=feconf.DUPLICATE_EMAIL_INTERVAL_MINS) DCNL DCSP sent_datetime_lower_bound = (datetime_now - time_interval) DCNL DCSP messages = cls.get_by_hash(email_hash, sent_datetime_lower_bound=sent_datetime_lower_bound) DCNL DCSP for message in messages: DCNL DCSP  DCSP if ((message.recipient_id == recipient_id) and (message.subject == email_subject) and (message.html_body == email_body)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
@classmethod DCNL def create(cls, instance_id, recipient_ids, sender_id, sender_email, intent, subject, html_body, sent_datetime): DCNL DCSP email_model_instance = cls(id=instance_id, recipient_ids=recipient_ids, sender_id=sender_id, sender_email=sender_email, intent=intent, subject=subject, html_body=html_body, sent_datetime=sent_datetime) DCNL DCSP email_model_instance.put()
@classmethod DCNL def create(cls, user_id, exploration_id, thread_id): DCNL DCSP instance_id = cls._generate_id(user_id, exploration_id, thread_id) DCNL DCSP if cls.get_by_id(instance_id): DCNL DCSP  DCSP raise Exception('Unique DCSP reply-to DCSP ID DCSP for DCSP given DCSP user, DCSP exploration DCSP and DCSP thread DCSP already DCSP exists.') DCNL DCSP reply_to_id = cls._generate_unique_reply_to_id() DCNL DCSP return cls(id=instance_id, reply_to_id=reply_to_id)
@property DCNL def id(self): DCNL DCSP return self.key.id()
def _pre_put_hook(self): DCNL DCSP pass
@classmethod DCNL def get(cls, entity_id, strict=True): DCNL DCSP entity = cls.get_by_id(entity_id) DCNL DCSP if (entity and entity.deleted): DCNL DCSP  DCSP entity = None DCNL DCSP if (strict and (entity is None)): DCNL DCSP  DCSP raise cls.EntityNotFoundError(('Entity DCSP for DCSP class DCSP %s DCSP with DCSP id DCSP %s DCSP not DCSP found' % (cls.__name__, entity_id))) DCNL DCSP return entity
@classmethod DCNL def get_multi(cls, entity_ids, include_deleted=False): DCNL DCSP entity_keys = [] DCNL DCSP none_argument_indices = [] DCNL DCSP for (index, entity_id) in enumerate(entity_ids): DCNL DCSP  DCSP if entity_id: DCNL DCSP  DCSP  DCSP entity_keys.append(ndb.Key(cls, entity_id)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP none_argument_indices.append(index) DCNL DCSP entities = ndb.get_multi(entity_keys) DCNL DCSP for index in none_argument_indices: DCNL DCSP  DCSP entities.insert(index, None) DCNL DCSP if (not include_deleted): DCNL DCSP  DCSP for i in xrange(len(entities)): DCNL DCSP  DCSP  DCSP if (entities[i] and entities[i].deleted): DCNL DCSP  DCSP  DCSP  DCSP entities[i] = None DCNL DCSP return entities
@classmethod DCNL def put_multi(cls, entities): DCNL DCSP ndb.put_multi(entities)
def delete(self): DCNL DCSP super(BaseModel, self).key.delete()
@classmethod DCNL def get_all(cls, include_deleted=False): DCNL DCSP query = cls.query() DCNL DCSP if (not include_deleted): DCNL DCSP  DCSP query = query.filter((cls.deleted == False)) DCNL DCSP return query
@classmethod DCNL def get_new_id(cls, entity_name): DCNL DCSP try: DCNL DCSP  DCSP entity_name = unicode(entity_name).encode('utf-8') DCNL DCSP except Exception: DCNL DCSP  DCSP entity_name = '' DCNL DCSP for _ in range(MAX_RETRIES): DCNL DCSP  DCSP new_id = utils.convert_to_hash(('%s%s' % (entity_name, utils.get_random_int(RAND_RANGE))), ID_LENGTH) DCNL DCSP  DCSP if (not cls.get_by_id(new_id)): DCNL DCSP  DCSP  DCSP return new_id DCNL DCSP raise Exception('New DCSP id DCSP generator DCSP is DCSP producing DCSP too DCSP many DCSP collisions.')
@classmethod DCNL def _fetch_page_sorted_by_last_updated(cls, query, page_size, urlsafe_start_cursor): DCNL DCSP if urlsafe_start_cursor: DCNL DCSP  DCSP start_cursor = datastore_query.Cursor(urlsafe=urlsafe_start_cursor) DCNL DCSP else: DCNL DCSP  DCSP start_cursor = None DCNL DCSP result = query.order((- cls.last_updated)).fetch_page(page_size, start_cursor=start_cursor) DCNL DCSP return (result[0], (result[1].urlsafe() if result[1] else None), result[2])
def _compute_snapshot(self): DCNL DCSP return self.to_dict(exclude=['created_on', 'last_updated'])
def _reconstitute_from_snapshot_id(self, snapshot_id): DCNL DCSP snapshot_model = self.SNAPSHOT_CONTENT_CLASS.get(snapshot_id) DCNL DCSP snapshot_dict = snapshot_model.content DCNL DCSP reconstituted_model = self._reconstitute(snapshot_dict) DCNL DCSP reconstituted_model.created_on = snapshot_model.created_on DCNL DCSP reconstituted_model.last_updated = snapshot_model.last_updated DCNL DCSP return reconstituted_model
@classmethod DCNL def _get_snapshot_id(cls, instance_id, version_number): DCNL DCSP return ('%s%s%s' % (instance_id, _VERSION_DELIMITER, version_number))
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds): DCNL DCSP if (self.SNAPSHOT_METADATA_CLASS is None): DCNL DCSP  DCSP raise Exception('No DCSP snapshot DCSP metadata DCSP class DCSP defined.') DCNL DCSP if (self.SNAPSHOT_CONTENT_CLASS is None): DCNL DCSP  DCSP raise Exception('No DCSP snapshot DCSP content DCSP class DCSP defined.') DCNL DCSP if (not isinstance(commit_cmds, list)): DCNL DCSP  DCSP raise Exception(('Expected DCSP commit_cmds DCSP to DCSP be DCSP a DCSP list DCSP of DCSP dicts, DCSP received DCSP %s' % commit_cmds)) DCNL DCSP for item in commit_cmds: DCNL DCSP  DCSP if (not isinstance(item, dict)): DCNL DCSP  DCSP  DCSP raise Exception(('Expected DCSP commit_cmds DCSP to DCSP be DCSP a DCSP list DCSP of DCSP dicts, DCSP received DCSP %s' % commit_cmds)) DCNL DCSP self.version += 1 DCNL DCSP snapshot = self._compute_snapshot() DCNL DCSP snapshot_id = self._get_snapshot_id(self.id, self.version) DCNL DCSP snapshot_metadata_instance = self.SNAPSHOT_METADATA_CLASS(id=snapshot_id, committer_id=committer_id, commit_type=commit_type, commit_message=commit_message, commit_cmds=commit_cmds) DCNL DCSP snapshot_content_instance = self.SNAPSHOT_CONTENT_CLASS(id=snapshot_id, content=snapshot) DCNL DCSP transaction_services.run_in_transaction(ndb.put_multi, [snapshot_metadata_instance, snapshot_content_instance, self])
def delete(self, committer_id, commit_message, force_deletion=False): DCNL DCSP if force_deletion: DCNL DCSP  DCSP current_version = self.version DCNL DCSP  DCSP version_numbers = [str((num + 1)) for num in range(current_version)] DCNL DCSP  DCSP snapshot_ids = [self._get_snapshot_id(self.id, version_number) for version_number in version_numbers] DCNL DCSP  DCSP metadata_keys = [ndb.Key(self.SNAPSHOT_METADATA_CLASS, snapshot_id) for snapshot_id in snapshot_ids] DCNL DCSP  DCSP ndb.delete_multi(metadata_keys) DCNL DCSP  DCSP content_keys = [ndb.Key(self.SNAPSHOT_CONTENT_CLASS, snapshot_id) for snapshot_id in snapshot_ids] DCNL DCSP  DCSP ndb.delete_multi(content_keys) DCNL DCSP  DCSP super(VersionedModel, self).delete() DCNL DCSP else: DCNL DCSP  DCSP self._require_not_marked_deleted() DCNL DCSP  DCSP self.deleted = True DCNL DCSP  DCSP commit_cmds = [{'cmd': ('%s_mark_deleted' % self._AUTOGENERATED_PREFIX)}] DCNL DCSP  DCSP self._trusted_commit(committer_id, self._COMMIT_TYPE_DELETE, commit_message, commit_cmds)
def put(self, *args, **kwargs): DCNL DCSP raise NotImplementedError
def commit(self, committer_id, commit_message, commit_cmds): DCNL DCSP self._require_not_marked_deleted() DCNL DCSP for commit_cmd in commit_cmds: DCNL DCSP  DCSP if ('cmd' not in commit_cmd): DCNL DCSP  DCSP  DCSP raise Exception(("Invalid DCSP commit_cmd: DCSP %s. DCSP Expected DCSP a DCSP 'cmd' DCSP key." % commit_cmd)) DCNL DCSP  DCSP if commit_cmd['cmd'].startswith(self._AUTOGENERATED_PREFIX): DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP change DCSP list DCSP command: DCSP ' % commit_cmd['cmd'])) DCNL DCSP commit_type = (self._COMMIT_TYPE_CREATE if (self.version == 0) else self._COMMIT_TYPE_EDIT) DCNL DCSP self._trusted_commit(committer_id, commit_type, commit_message, commit_cmds)
@classmethod DCNL def revert(cls, model, committer_id, commit_message, version_number): DCNL DCSP model._require_not_marked_deleted() DCNL DCSP if (not model.ALLOW_REVERT): DCNL DCSP  DCSP raise Exception(('Reverting DCSP of DCSP objects DCSP of DCSP type DCSP %s DCSP is DCSP not DCSP allowed.' % model.__class__.__name__)) DCNL DCSP commit_cmds = [{'cmd': ('%s_revert_version_number' % model._AUTOGENERATED_PREFIX), 'version_number': version_number}] DCNL DCSP current_version = model.version DCNL DCSP snapshot_id = model._get_snapshot_id(model.id, version_number) DCNL DCSP new_model = cls(id=model.id) DCNL DCSP new_model._reconstitute_from_snapshot_id(snapshot_id) DCNL DCSP new_model.version = current_version DCNL DCSP new_model._trusted_commit(committer_id, cls._COMMIT_TYPE_REVERT, commit_message, commit_cmds)
@classmethod DCNL def get_version(cls, entity_id, version_number): DCNL DCSP cls.get(entity_id)._require_not_marked_deleted() DCNL DCSP snapshot_id = cls._get_snapshot_id(entity_id, version_number) DCNL DCSP return cls(id=entity_id)._reconstitute_from_snapshot_id(snapshot_id)
@classmethod DCNL def get(cls, entity_id, strict=True, version=None): DCNL DCSP if (version is None): DCNL DCSP  DCSP return super(VersionedModel, cls).get(entity_id, strict=strict) DCNL DCSP else: DCNL DCSP  DCSP return cls.get_version(entity_id, version)
@classmethod DCNL def get_snapshots_metadata(cls, model_instance_id, version_numbers, allow_deleted=False): DCNL DCSP if (not allow_deleted): DCNL DCSP  DCSP cls.get(model_instance_id)._require_not_marked_deleted() DCNL DCSP snapshot_ids = [cls._get_snapshot_id(model_instance_id, version_number) for version_number in version_numbers] DCNL DCSP metadata_keys = [ndb.Key(cls.SNAPSHOT_METADATA_CLASS, snapshot_id) for snapshot_id in snapshot_ids] DCNL DCSP returned_models = ndb.get_multi(metadata_keys) DCNL DCSP for (ind, model) in enumerate(returned_models): DCNL DCSP  DCSP if (model is None): DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP version DCSP number DCSP %s DCSP for DCSP model DCSP %s DCSP with DCSP id DCSP %s' % (version_numbers[ind], cls.__name__, model_instance_id))) DCNL DCSP return [{'committer_id': model.committer_id, 'commit_message': model.commit_message, 'commit_cmds': model.commit_cmds, 'commit_type': model.commit_type, 'version_number': version_numbers[ind], 'created_on_ms': utils.get_time_in_millisecs(model.created_on)} for (ind, model) in enumerate(returned_models)]
def get_unversioned_instance_id(self): DCNL DCSP return self.id[:self.id.rfind(_VERSION_DELIMITER)]
def get_version_string(self): DCNL DCSP return self.id[(self.id.rfind(_VERSION_DELIMITER) + 1):]
def get_unversioned_instance_id(self): DCNL DCSP return self.id[:self.id.rfind(_VERSION_DELIMITER)]
def get_version_string(self): DCNL DCSP return self.id[(self.id.rfind(_VERSION_DELIMITER) + 1):]
def tearDown(self): DCNL DCSP for entity in base_models.BaseModel.get_all(): DCNL DCSP  DCSP entity.delete() DCNL DCSP super(BaseModelUnitTests, self).tearDown()
@classmethod DCNL def get_collection_count(cls): DCNL DCSP return cls.get_all().count()
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds): DCNL DCSP super(CollectionModel, self)._trusted_commit(committer_id, commit_type, commit_message, commit_cmds) DCNL DCSP committer_user_settings_model = user_models.UserSettingsModel.get_by_id(committer_id) DCNL DCSP committer_username = (committer_user_settings_model.username if committer_user_settings_model else '') DCNL DCSP collection_rights = CollectionRightsModel.get_by_id(self.id) DCNL DCSP CollectionCommitLogEntryModel(id=('collection-%s-%s' % (self.id, self.version)), user_id=committer_id, username=committer_username, collection_id=self.id, commit_type=commit_type, commit_message=commit_message, commit_cmds=commit_cmds, version=self.version, post_commit_status=collection_rights.status, post_commit_community_owned=collection_rights.community_owned, post_commit_is_private=(collection_rights.status == feconf.ACTIVITY_STATUS_PRIVATE)).put_async()
def save(self, committer_id, commit_message, commit_cmds): DCNL DCSP super(CollectionRightsModel, self).commit(committer_id, commit_message, commit_cmds)
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds): DCNL DCSP super(CollectionRightsModel, self)._trusted_commit(committer_id, commit_type, commit_message, commit_cmds) DCNL DCSP if (commit_type not in ['create', 'delete']): DCNL DCSP  DCSP committer_user_settings_model = user_models.UserSettingsModel.get_by_id(committer_id) DCNL DCSP  DCSP committer_username = (committer_user_settings_model.username if committer_user_settings_model else '') DCNL DCSP  DCSP CollectionCommitLogEntryModel(id=('rights-%s-%s' % (self.id, self.version)), user_id=committer_id, username=committer_username, collection_id=self.id, commit_type=commit_type, commit_message=commit_message, commit_cmds=commit_cmds, version=None, post_commit_status=self.status, post_commit_community_owned=self.community_owned, post_commit_is_private=(self.status == feconf.ACTIVITY_STATUS_PRIVATE)).put_async()
@classmethod DCNL def get_all_commits(cls, page_size, urlsafe_start_cursor): DCNL DCSP return cls._fetch_page_sorted_by_last_updated(cls.query(), page_size, urlsafe_start_cursor)
@classmethod DCNL def get_non_private(cls): DCNL DCSP return CollectionSummaryModel.query().filter((CollectionSummaryModel.status != feconf.ACTIVITY_STATUS_PRIVATE)).filter((CollectionSummaryModel.deleted == False)).fetch(feconf.DEFAULT_QUERY_LIMIT)
@classmethod DCNL def get_private_at_least_viewable(cls, user_id): DCNL DCSP return CollectionSummaryModel.query().filter((CollectionSummaryModel.status == feconf.ACTIVITY_STATUS_PRIVATE)).filter(ndb.OR((CollectionSummaryModel.owner_ids == user_id), (CollectionSummaryModel.editor_ids == user_id), (CollectionSummaryModel.viewer_ids == user_id))).filter((CollectionSummaryModel.deleted == False)).fetch(feconf.DEFAULT_QUERY_LIMIT)
@classmethod DCNL def get_at_least_editable(cls, user_id): DCNL DCSP return CollectionSummaryModel.query().filter(ndb.OR((CollectionSummaryModel.owner_ids == user_id), (CollectionSummaryModel.editor_ids == user_id))).filter((CollectionSummaryModel.deleted == False)).fetch(feconf.DEFAULT_QUERY_LIMIT)
@classmethod DCNL def generate_new_thread_id(cls, exploration_id): DCNL DCSP for _ in range(_MAX_RETRIES): DCNL DCSP  DCSP thread_id = (utils.base64_from_int(utils.get_current_time_in_millisecs()) + utils.base64_from_int(utils.get_random_int(_RAND_RANGE))) DCNL DCSP  DCSP if (not cls.get_by_exp_and_thread_id(exploration_id, thread_id)): DCNL DCSP  DCSP  DCSP return thread_id DCNL DCSP raise Exception('New DCSP thread DCSP id DCSP generator DCSP is DCSP producing DCSP too DCSP many DCSP collisions.')
@classmethod DCNL def generate_full_thread_id(cls, exploration_id, thread_id): DCNL DCSP return '.'.join([exploration_id, thread_id])
@classmethod DCNL def get_exploration_and_thread_ids(cls, full_thread_ids): DCNL DCSP exploration_and_thread_ids = [thread_id.split('.') for thread_id in full_thread_ids] DCNL DCSP return zip(*exploration_and_thread_ids)
@property DCNL def thread_id(self): DCNL DCSP return self.id.split('.')[1]
@classmethod DCNL def create(cls, exploration_id, thread_id): DCNL DCSP instance_id = cls.generate_full_thread_id(exploration_id, thread_id) DCNL DCSP if cls.get_by_id(instance_id): DCNL DCSP  DCSP raise Exception('Feedback DCSP thread DCSP ID DCSP conflict DCSP on DCSP create.') DCNL DCSP return cls(id=instance_id)
@classmethod DCNL def get_by_exp_and_thread_id(cls, exploration_id, thread_id): DCNL DCSP return cls.get_by_id(cls.generate_full_thread_id(exploration_id, thread_id))
@classmethod DCNL def get_threads(cls, exploration_id, limit=feconf.DEFAULT_QUERY_LIMIT): DCNL DCSP return cls.get_all().filter((cls.exploration_id == exploration_id)).order(cls.last_updated).fetch(limit)
@classmethod DCNL def _generate_id(cls, exploration_id, thread_id, message_id): DCNL DCSP return '.'.join([exploration_id, thread_id, str(message_id)])
@classmethod DCNL def create(cls, exploration_id, thread_id, message_id): DCNL DCSP instance_id = cls._generate_id(exploration_id, thread_id, message_id) DCNL DCSP if cls.get_by_id(instance_id): DCNL DCSP  DCSP raise Exception('Feedback DCSP message DCSP ID DCSP conflict DCSP on DCSP create.') DCNL DCSP return cls(id=instance_id)
@classmethod DCNL def get(cls, exploration_id, thread_id, message_id, strict=True): DCNL DCSP instance_id = cls._generate_id(exploration_id, thread_id, message_id) DCNL DCSP return super(FeedbackMessageModel, cls).get(instance_id, strict=strict)
@classmethod DCNL def get_messages(cls, exploration_id, thread_id): DCNL DCSP full_thread_id = FeedbackThreadModel.generate_full_thread_id(exploration_id, thread_id) DCNL DCSP return cls.get_all().filter((cls.thread_id == full_thread_id)).fetch(feconf.DEFAULT_QUERY_LIMIT)
@classmethod DCNL def get_most_recent_message(cls, exploration_id, thread_id): DCNL DCSP full_thread_id = FeedbackThreadModel.generate_full_thread_id(exploration_id, thread_id) DCNL DCSP thread = FeedbackThreadModel.get_by_exp_and_thread_id(exploration_id, thread_id) DCNL DCSP if thread.message_count: DCNL DCSP  DCSP most_recent_message = cls.get(exploration_id, thread_id, (thread.message_count - 1)) DCNL DCSP  DCSP return most_recent_message DCNL DCSP else: DCNL DCSP  DCSP return cls.get_all().filter((cls.thread_id == full_thread_id)).order((- cls.last_updated)).get()
@classmethod DCNL def get_message_count(cls, exploration_id, thread_id): DCNL DCSP full_thread_id = FeedbackThreadModel.generate_full_thread_id(exploration_id, thread_id) DCNL DCSP thread = FeedbackThreadModel.get_by_exp_and_thread_id(exploration_id, thread_id) DCNL DCSP if thread.message_count: DCNL DCSP  DCSP return thread.message_count DCNL DCSP else: DCNL DCSP  DCSP return cls.get_all(include_deleted=True).filter((cls.thread_id == full_thread_id)).count()
@classmethod DCNL def get(cls, user_id, exploration_id, thread_id): DCNL DCSP instance_id = cls.generate_full_id(user_id, exploration_id, thread_id) DCNL DCSP return super(FeedbackThreadUserModel, cls).get(instance_id, strict=False)
@classmethod DCNL def create(cls, user_id, exploration_id, thread_id): DCNL DCSP instance_id = cls.generate_full_id(user_id, exploration_id, thread_id) DCNL DCSP new_instance = cls(id=instance_id) DCNL DCSP new_instance.put() DCNL DCSP return new_instance
@classmethod DCNL def get_multi(cls, user_id, exploration_ids, thread_ids): DCNL DCSP instance_ids = [cls.generate_full_id(user_id, exploration_id, thread_id) for (exploration_id, thread_id) in zip(exploration_ids, thread_ids)] DCNL DCSP return super(FeedbackThreadUserModel, cls).get_multi(instance_ids)
@classmethod DCNL def create(cls, model_id, num_open_threads, num_total_threads): DCNL DCSP cls(id=model_id, num_open_threads=num_open_threads, num_total_threads=num_total_threads).put()
@classmethod DCNL def _convert_suggestion_html_to_legacy_state_content(cls, suggestion_html): DCNL DCSP return {'type': 'text', 'value': suggestion_html}
@classmethod DCNL def _get_instance_id(cls, exploration_id, thread_id): DCNL DCSP return '.'.join([exploration_id, thread_id])
@classmethod DCNL def create(cls, exploration_id, thread_id, author_id, exploration_version, state_name, description, suggestion_html): DCNL DCSP instance_id = cls._get_instance_id(exploration_id, thread_id) DCNL DCSP if cls.get_by_id(instance_id): DCNL DCSP  DCSP raise Exception(('There DCSP is DCSP already DCSP a DCSP feedback DCSP thread DCSP with DCSP the DCSP given DCSP thread DCSP id: DCSP %s' % instance_id)) DCNL DCSP state_content = cls._convert_suggestion_html_to_legacy_state_content(suggestion_html) DCNL DCSP cls(id=instance_id, author_id=author_id, exploration_id=exploration_id, exploration_version=exploration_version, state_name=state_name, description=description, state_content=state_content).put()
def get_suggestion_html(self): DCNL DCSP return self.state_content['value']
@classmethod DCNL def get_by_exploration_and_thread_id(cls, exploration_id, thread_id): DCNL DCSP return cls.get_by_id(cls._get_instance_id(exploration_id, thread_id))
def _get_suggestion_models_for_test(self, suggestions_list): DCNL DCSP updated_suggestions_list = [] DCNL DCSP for suggestion in suggestions_list: DCNL DCSP  DCSP suggestion_dict = suggestion.to_dict() DCNL DCSP  DCSP for field in FIELDS_NOT_REQUIRED: DCNL DCSP  DCSP  DCSP if (field in suggestion_dict): DCNL DCSP  DCSP  DCSP  DCSP suggestion_dict.pop(field) DCNL DCSP  DCSP updated_suggestions_list.append(suggestion_dict) DCNL DCSP return updated_suggestions_list
@classmethod DCNL def get_exploration_count(cls): DCNL DCSP return cls.get_all().count()
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds): DCNL DCSP super(ExplorationModel, self)._trusted_commit(committer_id, commit_type, commit_message, commit_cmds) DCNL DCSP committer_user_settings_model = user_models.UserSettingsModel.get_by_id(committer_id) DCNL DCSP committer_username = (committer_user_settings_model.username if committer_user_settings_model else '') DCNL DCSP exp_rights = ExplorationRightsModel.get_by_id(self.id) DCNL DCSP ExplorationCommitLogEntryModel(id=('exploration-%s-%s' % (self.id, self.version)), user_id=committer_id, username=committer_username, exploration_id=self.id, commit_type=commit_type, commit_message=commit_message, commit_cmds=commit_cmds, version=self.version, post_commit_status=exp_rights.status, post_commit_community_owned=exp_rights.community_owned, post_commit_is_private=(exp_rights.status == feconf.ACTIVITY_STATUS_PRIVATE)).put_async()
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds): DCNL DCSP super(ExplorationRightsModel, self)._trusted_commit(committer_id, commit_type, commit_message, commit_cmds) DCNL DCSP if (commit_type not in ['create', 'delete']): DCNL DCSP  DCSP committer_user_settings_model = user_models.UserSettingsModel.get_by_id(committer_id) DCNL DCSP  DCSP committer_username = (committer_user_settings_model.username if committer_user_settings_model else '') DCNL DCSP  DCSP ExplorationCommitLogEntryModel(id=('rights-%s-%s' % (self.id, self.version)), user_id=committer_id, username=committer_username, exploration_id=self.id, commit_type=commit_type, commit_message=commit_message, commit_cmds=commit_cmds, version=None, post_commit_status=self.status, post_commit_community_owned=self.community_owned, post_commit_is_private=(self.status == feconf.ACTIVITY_STATUS_PRIVATE)).put_async()
@classmethod DCNL def get_all_commits(cls, page_size, urlsafe_start_cursor): DCNL DCSP return cls._fetch_page_sorted_by_last_updated(cls.query(), page_size, urlsafe_start_cursor)
@classmethod DCNL def get_all_non_private_commits(cls, page_size, urlsafe_start_cursor, max_age=None): DCNL DCSP if ((not isinstance(max_age, datetime.timedelta)) and (max_age is not None)): DCNL DCSP  DCSP raise ValueError('max_age DCSP must DCSP be DCSP a DCSP datetime.timedelta DCSP instance DCSP or DCSP None.') DCNL DCSP query = cls.query((cls.post_commit_is_private == False)) DCNL DCSP if max_age: DCNL DCSP  DCSP query = query.filter((cls.last_updated >= (datetime.datetime.utcnow() - max_age))) DCNL DCSP return cls._fetch_page_sorted_by_last_updated(query, page_size, urlsafe_start_cursor)
@classmethod DCNL def get_non_private(cls): DCNL DCSP return ExpSummaryModel.query().filter((ExpSummaryModel.status != feconf.ACTIVITY_STATUS_PRIVATE)).filter((ExpSummaryModel.deleted == False)).fetch(feconf.DEFAULT_QUERY_LIMIT)
@classmethod DCNL def get_top_rated(cls, limit): DCNL DCSP return ExpSummaryModel.query().filter(ndb.OR((ExpSummaryModel.status == feconf.ACTIVITY_STATUS_PUBLIC), (ExpSummaryModel.status == feconf.ACTIVITY_STATUS_PUBLICIZED))).filter((ExpSummaryModel.deleted == False)).order((- ExpSummaryModel.scaled_average_rating)).fetch(limit)
@classmethod DCNL def get_private_at_least_viewable(cls, user_id): DCNL DCSP return ExpSummaryModel.query().filter((ExpSummaryModel.status == feconf.ACTIVITY_STATUS_PRIVATE)).filter(ndb.OR((ExpSummaryModel.owner_ids == user_id), (ExpSummaryModel.editor_ids == user_id), (ExpSummaryModel.viewer_ids == user_id))).filter((ExpSummaryModel.deleted == False)).fetch(feconf.DEFAULT_QUERY_LIMIT)
@classmethod DCNL def get_at_least_editable(cls, user_id): DCNL DCSP return ExpSummaryModel.query().filter(ndb.OR((ExpSummaryModel.owner_ids == user_id), (ExpSummaryModel.editor_ids == user_id))).filter((ExpSummaryModel.deleted == False)).fetch(feconf.DEFAULT_QUERY_LIMIT)
@classmethod DCNL def get_recently_published(cls, limit): DCNL DCSP return ExpSummaryModel.query().filter(ndb.OR((ExpSummaryModel.status == feconf.ACTIVITY_STATUS_PUBLIC), (ExpSummaryModel.status == feconf.ACTIVITY_STATUS_PUBLICIZED))).filter((ExpSummaryModel.deleted == False)).order((- ExpSummaryModel.first_published_msec)).fetch(limit)
@classmethod DCNL def get_or_create(cls, list_name): DCNL DCSP if (list_name not in ALL_ACTIVITY_REFERENCE_LIST_TYPES): DCNL DCSP  DCSP raise Exception(('Invalid DCSP ActivityListModel DCSP id: DCSP %s' % list_name)) DCNL DCSP entity = cls.get(list_name, strict=False) DCNL DCSP if (entity is None): DCNL DCSP  DCSP entity = cls(id=list_name, activity_references=[]) DCNL DCSP  DCSP entity.put() DCNL DCSP return entity
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, session_id, params, play_type, unused_version=1): DCNL DCSP entity_id = cls.get_new_event_entity_id(exp_id, session_id) DCNL DCSP start_event_entity = cls(id=entity_id, event_type=feconf.EVENT_TYPE_START_EXPLORATION, exploration_id=exp_id, exploration_version=exp_version, state_name=state_name, session_id=session_id, client_time_spent_in_secs=0.0, params=params, play_type=play_type) DCNL DCSP start_event_entity.put()
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, session_id, client_time_spent_in_secs, params, play_type): DCNL DCSP entity_id = cls.get_new_event_entity_id(exp_id, session_id) DCNL DCSP leave_event_entity = cls(id=entity_id, event_type=feconf.EVENT_TYPE_MAYBE_LEAVE_EXPLORATION, exploration_id=exp_id, exploration_version=exp_version, state_name=state_name, session_id=session_id, client_time_spent_in_secs=client_time_spent_in_secs, params=params, play_type=play_type) DCNL DCSP leave_event_entity.put()
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, session_id, client_time_spent_in_secs, params, play_type): DCNL DCSP entity_id = cls.get_new_event_entity_id(exp_id, session_id) DCNL DCSP complete_event_entity = cls(id=entity_id, event_type=feconf.EVENT_TYPE_COMPLETE_EXPLORATION, exploration_id=exp_id, exploration_version=exp_version, state_name=state_name, session_id=session_id, client_time_spent_in_secs=client_time_spent_in_secs, params=params, play_type=play_type) DCNL DCSP complete_event_entity.put()
@classmethod DCNL def create(cls, exp_id, user_id, rating, old_rating): DCNL DCSP entity_id = cls.get_new_event_entity_id(exp_id, user_id) DCNL DCSP cls(id=entity_id, event_type=feconf.EVENT_TYPE_RATE_EXPLORATION, exploration_id=exp_id, rating=rating, old_rating=old_rating).put()
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, session_id, params, play_type): DCNL DCSP entity_id = cls.get_new_event_entity_id(exp_id, session_id) DCNL DCSP state_event_entity = cls(id=entity_id, event_type=feconf.EVENT_TYPE_STATE_HIT, exploration_id=exp_id, exploration_version=exp_version, state_name=state_name, session_id=session_id, params=params, play_type=play_type) DCNL DCSP state_event_entity.put()
@classmethod DCNL def create(cls, exp_id, version, num_starts, num_completions, state_hit_counts): DCNL DCSP entity_id = cls.get_entity_id(exp_id, version) DCNL DCSP cls(id=entity_id, exploration_id=exp_id, version=version, num_starts=num_starts, num_completions=num_completions, state_hit_counts=state_hit_counts).put()
@classmethod DCNL def get_master_model(cls, exploration_id, exploration_version, state_name): DCNL DCSP main_shard = cls._get_model(exploration_id, exploration_version, state_name, 0) DCNL DCSP return (main_shard if main_shard else None)
@classmethod DCNL def get_all_models(cls, exploration_id, exploration_version, state_name): DCNL DCSP main_shard = cls.get_master_model(exploration_id, exploration_version, state_name) DCNL DCSP if (main_shard is not None): DCNL DCSP  DCSP all_models = [main_shard] DCNL DCSP  DCSP if (main_shard.shard_count > 0): DCNL DCSP  DCSP  DCSP shard_ids = [cls._get_entity_id(exploration_id, exploration_version, state_name, shard_id) for shard_id in xrange(1, (main_shard.shard_count + 1))] DCNL DCSP  DCSP  DCSP all_models += cls.get_multi(shard_ids) DCNL DCSP  DCSP return all_models DCNL DCSP else: DCNL DCSP  DCSP return None
@classmethod DCNL def _insert_submitted_answers_unsafe(cls, exploration_id, exploration_version, state_name, interaction_id, new_submitted_answer_dict_list): DCNL DCSP main_shard = cls.get_master_model(exploration_id, exploration_version, state_name) DCNL DCSP last_shard = main_shard DCNL DCSP if (not main_shard): DCNL DCSP  DCSP entity_id = cls._get_entity_id(exploration_id, exploration_version, state_name, 0) DCNL DCSP  DCSP main_shard = cls(id=entity_id, exploration_id=exploration_id, exploration_version=exploration_version, state_name=state_name, shard_id=0, interaction_id=interaction_id, shard_count=0, submitted_answer_list=[]) DCNL DCSP  DCSP last_shard = main_shard DCNL DCSP elif (main_shard.shard_count > 0): DCNL DCSP  DCSP last_shard = cls._get_model(exploration_id, exploration_version, state_name, main_shard.shard_count) DCNL DCSP (sharded_answer_lists, sharded_answer_list_sizes) = cls._shard_answers(last_shard.submitted_answer_list, last_shard.accumulated_answer_json_size_bytes, new_submitted_answer_dict_list) DCNL DCSP new_shard_count = ((main_shard.shard_count + len(sharded_answer_lists)) - 1) DCNL DCSP entities_to_put = [] DCNL DCSP last_shard_is_main = (main_shard.shard_count == 0) DCNL DCSP if (sharded_answer_list_sizes[0] != last_shard.accumulated_answer_json_size_bytes): DCNL DCSP  DCSP last_shard.submitted_answer_list = sharded_answer_lists[0] DCNL DCSP  DCSP last_shard.accumulated_answer_json_size_bytes = sharded_answer_list_sizes[0] DCNL DCSP  DCSP last_shard_updated = True DCNL DCSP else: DCNL DCSP  DCSP last_shard_updated = False DCNL DCSP for i in xrange(1, len(sharded_answer_lists)): DCNL DCSP  DCSP shard_id = (main_shard.shard_count + i) DCNL DCSP  DCSP entity_id = cls._get_entity_id(exploration_id, exploration_version, state_name, shard_id) DCNL DCSP  DCSP new_shard = cls(id=entity_id, exploration_id=exploration_id, exploration_version=exploration_version, state_name=state_name, shard_id=shard_id, interaction_id=interaction_id, submitted_answer_list=sharded_answer_lists[i], accumulated_answer_json_size_bytes=sharded_answer_list_sizes[i]) DCNL DCSP  DCSP entities_to_put.append(new_shard) DCNL DCSP if (main_shard.shard_count != new_shard_count): DCNL DCSP  DCSP main_shard.shard_count = new_shard_count DCNL DCSP  DCSP main_shard_updated = True DCNL DCSP else: DCNL DCSP  DCSP main_shard_updated = False DCNL DCSP if (last_shard_is_main and (main_shard_updated or last_shard_updated)): DCNL DCSP  DCSP entities_to_put.append(main_shard) DCNL DCSP else: DCNL DCSP  DCSP if main_shard_updated: DCNL DCSP  DCSP  DCSP entities_to_put.append(main_shard) DCNL DCSP  DCSP if last_shard_updated: DCNL DCSP  DCSP  DCSP entities_to_put.append(last_shard) DCNL DCSP cls.put_multi(entities_to_put)
@classmethod DCNL def insert_submitted_answers(cls, exploration_id, exploration_version, state_name, interaction_id, new_submitted_answer_dict_list): DCNL DCSP transaction_services.run_in_transaction(cls._insert_submitted_answers_unsafe, exploration_id, exploration_version, state_name, interaction_id, new_submitted_answer_dict_list)
@classmethod DCNL def _shard_answers(cls, current_answer_list, current_answer_list_size, new_answer_list): DCNL DCSP new_answer_size_list = [(answer_dict, cls._get_answer_dict_size(answer_dict)) for answer_dict in new_answer_list] DCNL DCSP new_answer_list_sorted = sorted(new_answer_size_list, key=(lambda x: x[1])) DCNL DCSP sharded_answer_lists = [list(current_answer_list)] DCNL DCSP sharded_answer_list_sizes = [current_answer_list_size] DCNL DCSP for (answer_dict, answer_size) in new_answer_list_sorted: DCNL DCSP  DCSP if ((sharded_answer_list_sizes[(-1)] + answer_size) <= cls._MAX_ANSWER_LIST_BYTE_SIZE): DCNL DCSP  DCSP  DCSP sharded_answer_lists[(-1)].append(answer_dict) DCNL DCSP  DCSP  DCSP sharded_answer_list_sizes[(-1)] += answer_size DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sharded_answer_lists.append([answer_dict]) DCNL DCSP  DCSP  DCSP sharded_answer_list_sizes.append(answer_size) DCNL DCSP return (sharded_answer_lists, sharded_answer_list_sizes)
@classmethod DCNL def _get_answer_dict_size(cls, answer_dict): DCNL DCSP return sys.getsizeof(json.dumps(answer_dict))
@classmethod DCNL def create(cls, classifier_id, exp_id, exp_version_when_created, state_name, algorithm_id, classifier_data, data_schema_version): DCNL DCSP instance_id = classifier_id DCNL DCSP classifier_data_model_instance = cls(id=instance_id, exp_id=exp_id, exp_version_when_created=exp_version_when_created, state_name=state_name, algorithm_id=algorithm_id, classifier_data=classifier_data, data_schema_version=data_schema_version) DCNL DCSP classifier_data_model_instance.put() DCNL DCSP return instance_id
@classmethod DCNL def _generate_id(cls, exp_id): DCNL DCSP for _ in range(base_models.MAX_RETRIES): DCNL DCSP  DCSP new_id = ('%s.%s' % (exp_id, utils.convert_to_hash(str(utils.get_random_int(base_models.RAND_RANGE)), base_models.ID_LENGTH))) DCNL DCSP  DCSP if (not cls.get_by_id(new_id)): DCNL DCSP  DCSP  DCSP return new_id DCNL DCSP raise Exception('The DCSP id DCSP generator DCSP for DCSP ClassifierTrainingJobModel DCSP is DCSP producing DCSP too DCSP many DCSP collisions.')
@classmethod DCNL def create(cls, algorithm_id, interaction_id, exp_id, exp_version, training_data, state_name, status): DCNL DCSP instance_id = cls._generate_id(exp_id) DCNL DCSP training_job_instance = cls(id=instance_id, algorithm_id=algorithm_id, interaction_id=interaction_id, exp_id=exp_id, exp_version=exp_version, state_name=state_name, status=status, training_data=training_data) DCNL DCSP training_job_instance.put() DCNL DCSP return instance_id
@classmethod DCNL def create_multi(cls, job_dicts_list): DCNL DCSP job_models = [] DCNL DCSP job_ids = [] DCNL DCSP for job_dict in job_dicts_list: DCNL DCSP  DCSP instance_id = cls._generate_id(job_dict['exp_id']) DCNL DCSP  DCSP training_job_instance = cls(id=instance_id, algorithm_id=job_dict['algorithm_id'], interaction_id=job_dict['interaction_id'], exp_id=job_dict['exp_id'], exp_version=job_dict['exp_version'], state_name=job_dict['state_name'], status=job_dict['status'], training_data=job_dict['training_data']) DCNL DCSP  DCSP job_models.append(training_job_instance) DCNL DCSP  DCSP job_ids.append(instance_id) DCNL DCSP cls.put_multi(job_models) DCNL DCSP return job_ids
@classmethod DCNL def _generate_id(cls, exp_id, exp_version, state_name): DCNL DCSP new_id = ('%s.%s.%s' % (exp_id, exp_version, state_name)) DCNL DCSP return utils.convert_to_str(new_id)
@classmethod DCNL def get_models(cls, exp_id, exp_version, state_names): DCNL DCSP mapping_ids = [] DCNL DCSP for state_name in state_names: DCNL DCSP  DCSP mapping_id = cls._generate_id(exp_id, exp_version, state_name) DCNL DCSP  DCSP mapping_ids.append(mapping_id) DCNL DCSP mapping_instances = cls.get_multi(mapping_ids) DCNL DCSP return mapping_instances
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, job_id): DCNL DCSP instance_id = cls._generate_id(exp_id, exp_version, state_name) DCNL DCSP if (not cls.get_by_id(instance_id)): DCNL DCSP  DCSP mapping_instance = cls(id=instance_id, exp_id=exp_id, exp_version=exp_version, state_name=state_name, job_id=job_id) DCNL DCSP  DCSP mapping_instance.put() DCNL DCSP  DCSP return instance_id DCNL DCSP raise Exception('A DCSP model DCSP with DCSP the DCSP same DCSP ID DCSP already DCSP exists.')
@classmethod DCNL def create_multi(cls, job_exploration_mappings): DCNL DCSP mapping_models = [] DCNL DCSP mapping_ids = [] DCNL DCSP for job_exploration_mapping in job_exploration_mappings: DCNL DCSP  DCSP instance_id = cls._generate_id(job_exploration_mapping.exp_id, job_exploration_mapping.exp_version, job_exploration_mapping.state_name) DCNL DCSP  DCSP mapping_instance = cls(id=instance_id, exp_id=job_exploration_mapping.exp_id, exp_version=job_exploration_mapping.exp_version, state_name=job_exploration_mapping.state_name, job_id=job_exploration_mapping.job_id) DCNL DCSP  DCSP mapping_models.append(mapping_instance) DCNL DCSP  DCSP mapping_ids.append(instance_id) DCNL DCSP cls.put_multi(mapping_models) DCNL DCSP return mapping_ids
@classmethod DCNL def get_new_id(cls, entity_name): DCNL DCSP job_type = entity_name DCNL DCSP current_time_str = str(int(utils.get_current_time_in_millisecs())) DCNL DCSP random_int = random.randint(0, 1000) DCNL DCSP return ('%s-%s-%s' % (job_type, current_time_str, random_int))
@classmethod DCNL def get_recent_jobs(cls, limit, recency_msec): DCNL DCSP earliest_time_msec = (utils.get_current_time_in_millisecs() - recency_msec) DCNL DCSP return cls.query().filter((cls.time_queued_msec > earliest_time_msec)).order((- cls.time_queued_msec)).fetch(limit)
@classmethod DCNL def get_all_unfinished_jobs(cls, limit): DCNL DCSP return cls.query().filter(JobModel.status_code.IN([STATUS_CODE_QUEUED, STATUS_CODE_STARTED])).order((- cls.time_queued_msec)).fetch(limit)
@classmethod DCNL def get_unfinished_jobs(cls, job_type): DCNL DCSP return cls.query().filter((cls.job_type == job_type)).filter(JobModel.status_code.IN([STATUS_CODE_QUEUED, STATUS_CODE_STARTED]))
@classmethod DCNL def do_unfinished_jobs_exist(cls, job_type): DCNL DCSP return bool(cls.get_unfinished_jobs(job_type).count(limit=1))
@classmethod DCNL def get_undeleted(cls): DCNL DCSP return cls.get_all().filter((cls.deleted == False)).fetch(feconf.DEFAULT_QUERY_LIMIT)
@classmethod DCNL def _construct_id(cls, exploration_id, filepath): DCNL DCSP return utils.vfs_construct_path('/', exploration_id, filepath)
@classmethod DCNL def create(cls, exploration_id, filepath): DCNL DCSP model_id = cls._construct_id(exploration_id, filepath) DCNL DCSP return cls(id=model_id, deleted=False)
@classmethod DCNL def get_model(cls, exploration_id, filepath, strict=False): DCNL DCSP model_id = cls._construct_id(exploration_id, filepath) DCNL DCSP return super(FileMetadataModel, cls).get(model_id, strict=strict)
@classmethod DCNL def get_version(cls, exploration_id, filepath, version_number): DCNL DCSP model_id = cls._construct_id(exploration_id, filepath) DCNL DCSP return super(FileMetadataModel, cls).get_version(model_id, version_number)
def commit(self, committer_id, commit_cmds): DCNL DCSP super(FileMetadataModel, self).commit(committer_id, '', commit_cmds)
def _reconstitute(self, snapshot_blob): DCNL DCSP self.content = snapshot_blob DCNL DCSP return self
def _compute_snapshot(self): DCNL DCSP return self.content
@classmethod DCNL def _construct_id(cls, exploration_id, filepath): DCNL DCSP return utils.vfs_construct_path('/', exploration_id, filepath)
@classmethod DCNL def create(cls, exploration_id, filepath): DCNL DCSP model_id = cls._construct_id(exploration_id, filepath) DCNL DCSP return cls(id=model_id, deleted=False)
@classmethod DCNL def get_model(cls, exploration_id, filepath, strict=False): DCNL DCSP model_id = cls._construct_id(exploration_id, filepath) DCNL DCSP return super(FileModel, cls).get(model_id, strict=strict)
def commit(self, committer_id, commit_cmds): DCNL DCSP super(FileModel, self).commit(committer_id, '', commit_cmds)
@classmethod DCNL def get_version(cls, exploration_id, filepath, version_number): DCNL DCSP model_id = cls._construct_id(exploration_id, filepath) DCNL DCSP return super(FileModel, cls).get_version(model_id, version_number)
def __init__(self, incomplete_exp_summaries, incomplete_collection_summaries, completed_exp_summaries, completed_collection_summaries, exploration_playlist, collection_playlist): DCNL DCSP self.incomplete_exp_summaries = incomplete_exp_summaries DCNL DCSP self.incomplete_collection_summaries = incomplete_collection_summaries DCNL DCSP self.completed_exp_summaries = completed_exp_summaries DCNL DCSP self.completed_collection_summaries = completed_collection_summaries DCNL DCSP self.exploration_playlist_summaries = exploration_playlist DCNL DCSP self.collection_playlist_summaries = collection_playlist
@classmethod DCNL def _notify_continuous_computation_listeners_async(cls, *args, **kwargs): DCNL DCSP taskqueue_services.defer_to_events_queue(jobs_registry.ContinuousComputationEventDispatcher.dispatch_event, cls.EVENT_TYPE, *args, **kwargs)
@classmethod DCNL def _handle_event(cls, *args, **kwargs): DCNL DCSP raise NotImplementedError('Subclasses DCSP of DCSP BaseEventHandler DCSP should DCSP implement DCSP the DCSP _handle_event() DCSP method, DCSP using DCSP explicit DCSP arguments DCSP (no DCSP *args DCSP or DCSP **kwargs).')
@classmethod DCNL def record(cls, *args, **kwargs): DCNL DCSP cls._notify_continuous_computation_listeners_async(*args, **kwargs) DCNL DCSP cls._handle_event(*args, **kwargs)
@classmethod DCNL def _handle_event(cls, exploration_id, exploration_version, state_name, interaction_id, answer_group_index, rule_spec_index, classification_categorization, session_id, time_spent_in_secs, params, normalized_answer): DCNL DCSP stats_services.record_answer(exploration_id, exploration_version, state_name, interaction_id, stats_domain.SubmittedAnswer(normalized_answer, interaction_id, answer_group_index, rule_spec_index, classification_categorization, params, session_id, time_spent_in_secs))
@classmethod DCNL def _refresh_registry(cls): DCNL DCSP cls._event_types_to_classes.clear() DCNL DCSP for (obj_name, obj) in globals().iteritems(): DCNL DCSP  DCSP if (inspect.isclass(obj) and issubclass(obj, BaseEventHandler)): DCNL DCSP  DCSP  DCSP if (obj_name == 'BaseEventHandler'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (not obj.EVENT_TYPE): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('Event DCSP handler DCSP class DCSP %s DCSP does DCSP not DCSP specify DCSP an DCSP event DCSP type' % obj_name)) DCNL DCSP  DCSP  DCSP elif (obj.EVENT_TYPE in cls._event_types_to_classes): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('Duplicate DCSP event DCSP type DCSP %s' % obj.EVENT_TYPE)) DCNL DCSP  DCSP  DCSP cls._event_types_to_classes[obj.EVENT_TYPE] = obj
@classmethod DCNL def get_event_class_by_type(cls, event_type): DCNL DCSP if (event_type not in cls._event_types_to_classes): DCNL DCSP  DCSP cls._refresh_registry() DCNL DCSP return cls._event_types_to_classes[event_type]
def _run_one_off_job(self, query_id): DCNL DCSP job_id = user_query_jobs_one_off.UserQueryOneOffJob.create_new() DCNL DCSP params = {'query_id': query_id} DCNL DCSP user_query_jobs_one_off.UserQueryOneOffJob.enqueue(job_id, additional_job_params=params) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(queue_name=taskqueue_services.QUEUE_NAME_DEFAULT), 1) DCNL DCSP with self.swap(feconf, 'CAN_SEND_EMAILS', True): DCNL DCSP  DCSP self.process_and_flush_pending_tasks()
def setUp(self): DCNL DCSP super(ActivityServicesTests, self).setUp() DCNL DCSP self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME) DCNL DCSP self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL) DCNL DCSP self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME) DCNL DCSP self.moderator_id = self.get_user_id_from_email(self.MODERATOR_EMAIL) DCNL DCSP self.set_moderators([self.MODERATOR_USERNAME]) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_0, self.owner_id) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_1, self.owner_id) DCNL DCSP self.save_new_valid_collection(self.COL_ID_2, self.owner_id, exploration_id=self.EXP_ID_0)
def _assert_validation_error(self, expected_error_substring): DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, expected_error_substring): DCNL DCSP  DCSP self.collection.validate()
def test_initial_validation(self): DCNL DCSP self.collection.validate()
def test_is_demo_property(self): DCNL DCSP demo = collection_domain.Collection.create_default_collection('0') DCNL DCSP self.assertEqual(demo.is_demo, True) DCNL DCSP notdemo1 = collection_domain.Collection.create_default_collection('a') DCNL DCSP self.assertEqual(notdemo1.is_demo, False) DCNL DCSP notdemo2 = collection_domain.Collection.create_default_collection('abcd') DCNL DCSP self.assertEqual(notdemo2.is_demo, False)
def test_collection_export_import(self): DCNL DCSP self.save_new_valid_exploration('0', 'user@example.com', end_state_name='End') DCNL DCSP collection = collection_domain.Collection.create_default_collection('0', title='title', category='category', objective='objective') DCNL DCSP collection_dict = collection.to_dict() DCNL DCSP collection_from_dict = collection_domain.Collection.from_dict(collection_dict) DCNL DCSP self.assertEqual(collection_from_dict.to_dict(), collection_dict)
def test_add_delete_node(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection('0') DCNL DCSP self.assertEqual(len(collection.nodes), 0) DCNL DCSP collection.add_node('test_exp') DCNL DCSP self.assertEqual(len(collection.nodes), 1) DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Exploration DCSP is DCSP already DCSP part DCSP of DCSP this DCSP collection: DCSP test_exp'): DCNL DCSP  DCSP collection.add_node('test_exp') DCNL DCSP collection.add_node('another_exp') DCNL DCSP self.assertEqual(len(collection.nodes), 2) DCNL DCSP collection.delete_node('another_exp') DCNL DCSP self.assertEqual(len(collection.nodes), 1) DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Exploration DCSP is DCSP not DCSP part DCSP of DCSP this DCSP collection: DCSP another_exp'): DCNL DCSP  DCSP collection.delete_node('another_exp') DCNL DCSP collection.delete_node('test_exp') DCNL DCSP self.assertEqual(len(collection.nodes), 0)
def test_add_skill(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection('exp_id') DCNL DCSP self.assertEqual(collection.skills, {}) DCNL DCSP collection.add_skill('skillname1') DCNL DCSP self.assertEqual(collection.skills.keys(), ['skill0']) DCNL DCSP self.assertEqual(collection.skills['skill0'].name, 'skillname1') DCNL DCSP collection.add_skill('skillname2') DCNL DCSP self.assertEqual(sorted(collection.skills.keys()), ['skill0', 'skill1'])
def test_update_skill(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection('exp_id') DCNL DCSP self.assertEqual(collection.skills, {}) DCNL DCSP collection.add_skill('skillname1') DCNL DCSP self.assertEqual(collection.skills.keys(), ['skill0']) DCNL DCSP self.assertEqual(collection.skills['skill0'].name, 'skillname1') DCNL DCSP collection.update_skill('skill0', 'new DCSP skill DCSP name1') DCNL DCSP self.assertEqual(collection.skills['skill0'].name, 'new DCSP skill DCSP name1') DCNL DCSP collection.add_skill('skillname2') DCNL DCSP self.assertEqual(collection.skills['skill0'].name, 'new DCSP skill DCSP name1') DCNL DCSP self.assertEqual(collection.skills['skill1'].name, 'skillname2') DCNL DCSP with self.assertRaisesRegexp(ValueError, ('Skill DCSP with DCSP name DCSP "%s" DCSP already DCSP exists.' % 'new DCSP skill DCSP name1')): DCNL DCSP  DCSP collection.update_skill('skill1', 'new DCSP skill DCSP name1')
def test_adding_duplicate_skill_raises_error(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection('exp_id') DCNL DCSP collection.add_skill('skillname1') DCNL DCSP collection.add_skill('skillname2') DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Skill DCSP with DCSP name DCSP "skillname1" DCSP already DCSP exists.'): DCNL DCSP  DCSP collection.add_skill('skillname1')
def test_adding_after_deleting_skill_increments_skill_id(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection('exp_id') DCNL DCSP collection.add_skill('skillname1') DCNL DCSP collection.add_skill('skillname2') DCNL DCSP collection.delete_skill('skill1') DCNL DCSP self.assertEqual(collection.skills.keys(), ['skill0']) DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Skill DCSP with DCSP ID DCSP "skill1" DCSP does DCSP not DCSP exist.'): DCNL DCSP  DCSP collection.delete_skill('skill1') DCNL DCSP collection.add_skill('skillname3') DCNL DCSP self.assertEqual(sorted(collection.skills.keys()), ['skill0', 'skill2'])
def test_delete_skill(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection('exp_id') DCNL DCSP self.assertEqual(collection.skills, {}) DCNL DCSP collection.add_skill('skillname1') DCNL DCSP self.assertEqual(collection.skills.keys(), ['skill0']) DCNL DCSP self.assertEqual(collection.skills['skill0'].name, 'skillname1') DCNL DCSP collection.add_skill('skillname2') DCNL DCSP self.assertEqual(sorted(collection.skills.keys()), ['skill0', 'skill1']) DCNL DCSP collection.add_node('exp_id_0') DCNL DCSP collection.add_node('exp_id_1') DCNL DCSP collection.get_node('exp_id_0').update_acquired_skill_ids(['skill0']) DCNL DCSP collection.get_node('exp_id_1').update_prerequisite_skill_ids(['skill0']) DCNL DCSP collection.delete_skill('skill0') DCNL DCSP self.assertEqual(collection.get_node('exp_id_0').acquired_skill_ids, []) DCNL DCSP self.assertEqual(collection.get_node('exp_id_1').prerequisite_skill_ids, [])
def test_initial_explorations(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection('collection_id') DCNL DCSP self.assertEqual(collection.nodes, []) DCNL DCSP self.assertEqual(collection.init_exploration_ids, []) DCNL DCSP collection.add_node('exp_id_0') DCNL DCSP self.assertEqual(collection.init_exploration_ids, ['exp_id_0']) DCNL DCSP collection.add_node('exp_id_1') DCNL DCSP self.assertEqual(len(collection.nodes), 2) DCNL DCSP collection.get_node('exp_id_1').update_prerequisite_skill_ids(['skill0a']) DCNL DCSP self.assertEqual(collection.init_exploration_ids, ['exp_id_0']) DCNL DCSP collection.add_node('exp_id_2') DCNL DCSP self.assertEqual(collection.init_exploration_ids, ['exp_id_0', 'exp_id_2'])
def test_next_explorations(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection('collection_id') DCNL DCSP self.assertEqual(collection.get_next_exploration_ids([]), []) DCNL DCSP collection.add_node('exp_id_1') DCNL DCSP self.assertEqual(collection.get_next_exploration_ids([]), ['exp_id_1']) DCNL DCSP self.assertEqual(collection.init_exploration_ids, collection.get_next_exploration_ids([])) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids(['exp_id_1']), []) DCNL DCSP collection_node1 = collection.get_node('exp_id_1') DCNL DCSP collection_node1.update_prerequisite_skill_ids(['skill0a']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids([]), []) DCNL DCSP collection.add_node('exp_id_2') DCNL DCSP collection_node2 = collection.get_node('exp_id_2') DCNL DCSP collection_node1.update_acquired_skill_ids(['skill1b']) DCNL DCSP collection_node2.update_prerequisite_skill_ids(['skill1b']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids([]), []) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids(['exp_id_1']), ['exp_id_2']) DCNL DCSP collection.add_node('exp_id_0') DCNL DCSP collection_node0 = collection.get_node('exp_id_0') DCNL DCSP collection_node0.update_acquired_skill_ids(['skill0a']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids([]), ['exp_id_0']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids(['exp_id_0']), ['exp_id_1']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids(['exp_id_0', 'exp_id_1']), ['exp_id_2']) DCNL DCSP collection.add_node('exp_id_3') DCNL DCSP self.assertEqual(collection.get_next_exploration_ids([]), ['exp_id_0', 'exp_id_3']) DCNL DCSP collection_node3 = collection.get_node('exp_id_3') DCNL DCSP collection_node3.update_prerequisite_skill_ids(['skill0c']) DCNL DCSP collection_node0.update_acquired_skill_ids(['skill0a', 'skill0c']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids([]), ['exp_id_0']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids(['exp_id_0']), ['exp_id_1', 'exp_id_3']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids(['exp_id_0', 'exp_id_3']), ['exp_id_1']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids(['exp_id_0', 'exp_id_1']), ['exp_id_2', 'exp_id_3']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids(['exp_id_0', 'exp_id_1', 'exp_id_2']), ['exp_id_3']) DCNL DCSP self.assertEqual(collection.get_next_exploration_ids(['exp_id_0', 'exp_id_1', 'exp_id_2', 'exp_id_3']), [])
def test_yaml_import_and_export(self): DCNL DCSP self.save_new_valid_exploration(self.EXPLORATION_ID, 'user@example.com', end_state_name='End') DCNL DCSP collection = collection_domain.Collection.create_default_collection(self.COLLECTION_ID, title='A DCSP title', category='A DCSP category', objective='An DCSP objective') DCNL DCSP collection.add_node(self.EXPLORATION_ID) DCNL DCSP self.assertEqual(len(collection.nodes), 1) DCNL DCSP collection.add_skill('Skill0a') DCNL DCSP collection.add_skill('Skill0b') DCNL DCSP collection_node = collection.get_node(self.EXPLORATION_ID) DCNL DCSP collection_node.update_acquired_skill_ids(['skill0', 'skill1']) DCNL DCSP collection.validate() DCNL DCSP yaml_content = collection.to_yaml() DCNL DCSP self.assertEqual(yaml_content, SAMPLE_YAML_CONTENT) DCNL DCSP collection2 = collection_domain.Collection.from_yaml('collection2', yaml_content) DCNL DCSP self.assertEqual(len(collection2.nodes), 1) DCNL DCSP yaml_content_2 = collection2.to_yaml() DCNL DCSP self.assertEqual(yaml_content_2, yaml_content) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP collection_domain.Collection.from_yaml('collection3', None)
def test_correct_collection_contents_schema_conversion_methods_exist(self): DCNL DCSP current_collection_schema_version = feconf.CURRENT_COLLECTION_SCHEMA_VERSION DCNL DCSP for version_num in range(1, current_collection_schema_version): DCNL DCSP  DCSP self.assertTrue(hasattr(collection_domain.Collection, ('_convert_collection_contents_v%s_dict_to_v%s_dict' % (version_num, (version_num + 1))))) DCNL DCSP self.assertFalse(hasattr(collection_domain.Collection, ('_convert_collection_contents_v%s_dict_to_v%s_dict' % (current_collection_schema_version, (current_collection_schema_version + 1)))))
def test_correct_collection_schema_conversion_methods_exist(self): DCNL DCSP current_collection_schema_version = feconf.CURRENT_COLLECTION_SCHEMA_VERSION DCNL DCSP for version_num in range(1, current_collection_schema_version): DCNL DCSP  DCSP self.assertTrue(hasattr(collection_domain.Collection, ('_convert_v%s_dict_to_v%s_dict' % (version_num, (version_num + 1))))) DCNL DCSP self.assertFalse(hasattr(collection_domain.Collection, ('_convert_v%s_dict_to_v%s_dict' % (current_collection_schema_version, (current_collection_schema_version + 1)))))
def test_load_from_v1(self): DCNL DCSP self.save_new_valid_exploration('Exp1', 'user@example.com', end_state_name='End') DCNL DCSP collection = collection_domain.Collection.from_yaml('cid', self.YAML_CONTENT_V1) DCNL DCSP self.assertEqual(collection.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v2(self): DCNL DCSP self.save_new_valid_exploration('Exp1', 'user@example.com', end_state_name='End') DCNL DCSP collection = collection_domain.Collection.from_yaml('cid', self.YAML_CONTENT_V2) DCNL DCSP self.assertEqual(collection.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v3(self): DCNL DCSP self.save_new_valid_exploration('Exp1', 'user@example.com', end_state_name='End') DCNL DCSP collection = collection_domain.Collection.from_yaml('cid', self.YAML_CONTENT_V3) DCNL DCSP self.assertEqual(collection.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v4(self): DCNL DCSP self.save_new_valid_exploration('Exp1', 'user@example.com', end_state_name='End') DCNL DCSP collection = collection_domain.Collection.from_yaml('cid', self.YAML_CONTENT_V4) DCNL DCSP self.assertEqual(collection.to_yaml(), self._LATEST_YAML_CONTENT)
def _run_computation(self): DCNL DCSP with self.swap(stats_jobs_continuous.StatisticsAggregator, 'get_statistics', self._mock_get_statistics): DCNL DCSP  DCSP ModifiedUserStatsAggregator.start_computation() DCNL DCSP  DCSP self.process_and_flush_pending_tasks()
def _generate_user_ids(self, count): DCNL DCSP return [('user%d' % i) for i in range(count)]
def _record_start(self, exp_id, exp_version, state): DCNL DCSP event_services.StartExplorationEventHandler.record(exp_id, exp_version, state, self.USER_SESSION_ID, {}, feconf.PLAY_TYPE_NORMAL)
def _rate_exploration(self, exp_id, num_ratings, rating): DCNL DCSP user_ids = self._generate_user_ids(num_ratings) DCNL DCSP for user_id in user_ids: DCNL DCSP  DCSP rating_services.assign_rating_to_exploration(user_id, exp_id, rating)
def test_stats_for_user_with_no_explorations(self): DCNL DCSP self._run_computation() DCNL DCSP user_stats_model = user_models.UserStatsModel.get(self.user_a_id, strict=False) DCNL DCSP self.assertIsNone(user_stats_model)
def test_only_yield_when_rating_greater_than_two(self): DCNL DCSP self._create_exploration(self.EXP_ID_1, self.user_a_id) DCNL DCSP self._rate_exploration(self.EXP_ID_1, 2, 1) DCNL DCSP self._run_computation() DCNL DCSP user_stats_model = user_models.UserStatsModel.get(self.user_a_id, strict=False) DCNL DCSP self.assertEqual(user_stats_model.impact_score, 0) DCNL DCSP ModifiedUserStatsAggregator.stop_computation(self.user_a_id) DCNL DCSP self._rate_exploration(self.EXP_ID_1, 2, 2) DCNL DCSP self._run_computation() DCNL DCSP user_stats_model = user_models.UserStatsModel.get(self.user_a_id, strict=False) DCNL DCSP self.assertEqual(user_stats_model.impact_score, 0) DCNL DCSP ModifiedUserStatsAggregator.stop_computation(self.user_a_id) DCNL DCSP self._rate_exploration(self.EXP_ID_1, 2, 3) DCNL DCSP self._run_computation() DCNL DCSP user_stats_model = user_models.UserStatsModel.get(self.user_a_id, strict=False) DCNL DCSP self.assertIsNotNone(user_stats_model) DCNL DCSP self.assertGreater(user_stats_model.impact_score, 0)
def test_impact_for_exp_with_no_answers(self): DCNL DCSP exploration = self._create_exploration(self.EXP_ID_3, self.user_a_id) DCNL DCSP self._rate_exploration(exploration.id, 5, 3) DCNL DCSP self._run_computation() DCNL DCSP user_stats_model = user_models.UserStatsModel.get(self.user_a_id) DCNL DCSP self.assertEqual(user_stats_model.impact_score, 0)
def test_impact_for_exp_with_no_ratings(self): DCNL DCSP self._create_exploration(self.EXP_ID_1, self.user_a_id) DCNL DCSP user_stats_model = user_models.UserStatsModel.get(self.user_a_id, strict=False) DCNL DCSP self.assertEqual(user_stats_model, None)
def setUp(self): DCNL DCSP super(LastLoginIntegrationTest, self).setUp() DCNL DCSP self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME) DCNL DCSP self.viewer_id = self.get_user_id_from_email(self.VIEWER_EMAIL)
def test_legacy_user(self): DCNL DCSP user_settings = user_services.get_user_settings(self.viewer_id) DCNL DCSP user_settings.last_logged_in = None DCNL DCSP user_services._save_user_settings(user_settings) DCNL DCSP self.assertIsNone(user_services.get_user_settings(self.viewer_id).last_logged_in) DCNL DCSP self.login(self.VIEWER_EMAIL) DCNL DCSP self.testapp.get(feconf.LIBRARY_INDEX_URL) DCNL DCSP self.assertIsNotNone(user_services.get_user_settings(self.viewer_id).last_logged_in) DCNL DCSP self.logout()
def setUp(self): DCNL DCSP super(LastExplorationEditedIntegrationTests, self).setUp() DCNL DCSP self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME) DCNL DCSP self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL) DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID, self.owner_id, end_state_name='End')
def test_legacy_user(self): DCNL DCSP user_settings = user_services.get_user_settings(self.editor_id) DCNL DCSP user_settings.last_edited_an_exploration = None DCNL DCSP user_services._save_user_settings(user_settings) DCNL DCSP editor_settings = user_services.get_user_settings(self.editor_id) DCNL DCSP self.assertIsNone(editor_settings.last_edited_an_exploration) DCNL DCSP exp_services.update_exploration(self.editor_id, self.EXP_ID, [{'cmd': 'edit_exploration_property', 'property_name': 'objective', 'new_value': 'the DCSP objective'}], 'Test DCSP edit') DCNL DCSP editor_settings = user_services.get_user_settings(self.editor_id) DCNL DCSP self.assertIsNotNone(editor_settings.last_edited_an_exploration)
def setUp(self): DCNL DCSP super(LastExplorationCreatedIntegrationTests, self).setUp() DCNL DCSP self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME) DCNL DCSP self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)
def test_legacy_user(self): DCNL DCSP user_settings = user_services.get_user_settings(self.owner_id) DCNL DCSP user_settings.last_created_an_exploration = None DCNL DCSP user_services._save_user_settings(user_settings) DCNL DCSP owner_settings = user_services.get_user_settings(self.owner_id) DCNL DCSP self.assertIsNone(owner_settings.last_created_an_exploration) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_A, self.owner_id, end_state_name='End') DCNL DCSP owner_settings = user_services.get_user_settings(self.owner_id) DCNL DCSP self.assertIsNotNone(owner_settings.last_created_an_exploration)
@classmethod DCNL def get_all_classifier_algorithm_ids(cls): DCNL DCSP return [classifier_id for classifier_id in feconf.ANSWER_CLASSIFIER_CLASS_IDS]
@classmethod DCNL def _refresh(cls): DCNL DCSP cls._classifier_instances.clear() DCNL DCSP all_classifier_ids = cls.get_all_classifier_algorithm_ids() DCNL DCSP extension_paths = [os.path.join(feconf.CLASSIFIERS_DIR, classifier_id) for classifier_id in all_classifier_ids] DCNL DCSP for (loader, name, _) in pkgutil.iter_modules(path=extension_paths): DCNL DCSP  DCSP module = loader.find_module(name).load_module(name) DCNL DCSP  DCSP clazz = getattr(module, name) DCNL DCSP  DCSP ancestor_names = [base_class.__name__ for base_class in clazz.__bases__] DCNL DCSP  DCSP if ('BaseClassifier' in ancestor_names): DCNL DCSP  DCSP  DCSP cls._classifier_instances[clazz.__name__] = clazz()
@classmethod DCNL def get_all_classifiers(cls): DCNL DCSP if (not cls._classifier_instances): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._classifier_instances.values()
@classmethod DCNL def get_classifier_by_algorithm_id(cls, classifier_algorithm_id): DCNL DCSP if (classifier_algorithm_id not in cls._classifier_instances): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._classifier_instances[classifier_algorithm_id]
@classmethod DCNL def get_dependency_html(cls, dependency_id): DCNL DCSP return utils.get_file_contents(os.path.join(feconf.DEPENDENCIES_TEMPLATES_DIR, ('%s.html' % dependency_id)))
@classmethod DCNL def get_angular_modules(cls, dependency_id): DCNL DCSP return dependencies_config.DEPENDENCIES_TO_ANGULAR_MODULES_DICT.get(dependency_id, [])
@classmethod DCNL def get_deps_html_and_angular_modules(cls, dependency_ids): DCNL DCSP html = '\n'.join([cls.get_dependency_html(dep) for dep in set(dependency_ids)]) DCNL DCSP html = jinja_utils.interpolate_cache_slug(html) DCNL DCSP angular_modules_for_each_dep = [cls.get_angular_modules(dep) for dep in set(dependency_ids)] DCNL DCSP deduplicated_angular_modules = list(set(list(itertools.chain.from_iterable(angular_modules_for_each_dep)))) DCNL DCSP return (html, deduplicated_angular_modules)
def _is_camel_cased(self, name): DCNL DCSP return (name and (name[0] in string.ascii_uppercase))
def _is_alphanumeric_string(self, input_string): DCNL DCSP return bool(re.compile('^[a-zA-Z0-9_]+$').match(input_string))
def _listdir_omit_ignored(self, directory): DCNL DCSP names = os.listdir(directory) DCNL DCSP for suffix in IGNORED_FILE_SUFFIXES: DCNL DCSP  DCSP names = [name for name in names if (not name.endswith(suffix))] DCNL DCSP return names
def test_allowed_rich_text_components_and_counts(self): DCNL DCSP self.assertEqual(len(rte_component_registry.Registry.get_all_rte_components()), len(feconf.ALLOWED_RTE_EXTENSIONS)) DCNL DCSP for (component_name, component_definition) in feconf.ALLOWED_RTE_EXTENSIONS.iteritems(): DCNL DCSP  DCSP contents = os.listdir(os.path.join(os.getcwd(), component_definition['dir'])) DCNL DCSP  DCSP self.assertIn(('%s.py' % component_name), contents)
def test_image_thumbnails_for_rte_components(self): DCNL DCSP for (cpt_name, cpt_spec) in feconf.ALLOWED_RTE_EXTENSIONS.iteritems(): DCNL DCSP  DCSP image_filepath = os.path.join(os.getcwd(), cpt_spec['dir'], ('%s.png' % cpt_name)) DCNL DCSP  DCSP with open(image_filepath, 'rb') as f: DCNL DCSP  DCSP  DCSP img_data = f.read() DCNL DCSP  DCSP  DCSP (width, height) = struct.unpack('>LL', img_data[16:24]) DCNL DCSP  DCSP  DCSP self.assertEqual(int(width), RTE_THUMBNAIL_WIDTH_PX) DCNL DCSP  DCSP  DCSP self.assertEqual(int(height), RTE_THUMBNAIL_HEIGHT_PX)
def test_default_rte_components_are_valid(self): DCNL DCSP for component_id in feconf.ALLOWED_RTE_EXTENSIONS: DCNL DCSP  DCSP self.assertTrue(self._is_camel_cased(component_id)) DCNL DCSP  DCSP component_dir = os.path.join(feconf.RTE_EXTENSIONS_DIR, component_id) DCNL DCSP  DCSP self.assertTrue(os.path.isdir(component_dir)) DCNL DCSP  DCSP dir_contents = self._listdir_omit_ignored(component_dir) DCNL DCSP  DCSP self.assertLessEqual(len(dir_contents), 6) DCNL DCSP  DCSP py_file = os.path.join(component_dir, ('%s.py' % component_id)) DCNL DCSP  DCSP html_file = os.path.join(component_dir, ('%s.html' % component_id)) DCNL DCSP  DCSP js_file = os.path.join(component_dir, ('%s.js' % component_id)) DCNL DCSP  DCSP png_file = os.path.join(component_dir, ('%s.png' % component_id)) DCNL DCSP  DCSP preview_file = os.path.join(component_dir, ('%sPreview.png' % component_id)) DCNL DCSP  DCSP protractor_file = os.path.join(component_dir, 'protractor.js') DCNL DCSP  DCSP self.assertTrue(os.path.isfile(py_file)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(html_file)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(js_file)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(png_file)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(protractor_file)) DCNL DCSP  DCSP if (len(dir_contents) == 6): DCNL DCSP  DCSP  DCSP self.assertTrue(os.path.isfile(preview_file)) DCNL DCSP  DCSP js_file_content = utils.get_file_contents(js_file) DCNL DCSP  DCSP html_file_content = utils.get_file_contents(html_file) DCNL DCSP  DCSP self.assertIn(('oppiaNoninteractive%s' % component_id), js_file_content) DCNL DCSP  DCSP self.assertIn(('<script DCSP type="text/ng-template" DCSP id="richTextComponent/%s"' % component_id), html_file_content) DCNL DCSP  DCSP self.assertNotIn('<script>', js_file_content) DCNL DCSP  DCSP self.assertNotIn('</script>', js_file_content) DCNL DCSP  DCSP component = rte_component_registry.Registry.get_rte_component(component_id) DCNL DCSP  DCSP self.assertTrue(component_id, component.__class__.__name__) DCNL DCSP  DCSP for (item, item_type) in _COMPONENT_CONFIG_SCHEMA: DCNL DCSP  DCSP  DCSP self.assertTrue(isinstance(getattr(component, item), item_type)) DCNL DCSP  DCSP  DCSP if (item_type == basestring): DCNL DCSP  DCSP  DCSP  DCSP self.assertTrue(getattr(component, item)) DCNL DCSP  DCSP self._validate_customization_arg_specs(component._customization_arg_specs)
@classmethod DCNL def get_html_template(cls): DCNL DCSP return utils.get_file_contents(os.path.join(os.getcwd(), feconf.VALUE_GENERATORS_DIR, 'templates', ('%s.html' % cls.__name__)))
@classmethod DCNL def get_js_template(cls): DCNL DCSP return utils.get_file_contents(os.path.join(os.getcwd(), feconf.VALUE_GENERATORS_DIR, 'templates', ('%s.js' % cls.__name__)))
def generate_value(self, *args, **kwargs): DCNL DCSP raise NotImplementedError
@classmethod DCNL def _refresh_registry(cls): DCNL DCSP cls.value_generators_dict.clear() DCNL DCSP value_generator_paths = [os.path.join(os.getcwd(), feconf.VALUE_GENERATORS_DIR, 'models')] DCNL DCSP for (loader, name, _) in pkgutil.iter_modules(path=value_generator_paths): DCNL DCSP  DCSP if name.endswith('_test'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP module = loader.find_module(name).load_module(name) DCNL DCSP  DCSP for (_, clazz) in inspect.getmembers(module, inspect.isclass): DCNL DCSP  DCSP  DCSP if issubclass(clazz, BaseValueGenerator): DCNL DCSP  DCSP  DCSP  DCSP if (clazz.__name__ in cls.value_generators_dict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('Duplicate DCSP value DCSP generator DCSP name DCSP %s' % clazz.__name__)) DCNL DCSP  DCSP  DCSP  DCSP cls.value_generators_dict[clazz.__name__] = clazz
@classmethod DCNL def get_all_generator_classes(cls): DCNL DCSP cls._refresh_registry() DCNL DCSP return copy.deepcopy(cls.value_generators_dict)
@classmethod DCNL def get_generator_class_by_id(cls, generator_id): DCNL DCSP if (generator_id not in cls.value_generators_dict): DCNL DCSP  DCSP cls._refresh_registry() DCNL DCSP return cls.value_generators_dict[generator_id]
def __init__(self, user_id, email, role, username=None, last_agreed_to_terms=None, last_started_state_editor_tutorial=None, last_logged_in=None, last_created_an_exploration=None, last_edited_an_exploration=None, profile_picture_data_url=None, default_dashboard=None, user_bio='', subject_interests=None, first_contribution_msec=None, preferred_language_codes=None, preferred_site_language_code=None): DCNL DCSP self.user_id = user_id DCNL DCSP self.email = email DCNL DCSP self.role = role DCNL DCSP self.username = username DCNL DCSP self.last_agreed_to_terms = last_agreed_to_terms DCNL DCSP self.last_started_state_editor_tutorial = last_started_state_editor_tutorial DCNL DCSP self.last_logged_in = last_logged_in DCNL DCSP self.last_edited_an_exploration = last_edited_an_exploration DCNL DCSP self.last_created_an_exploration = last_created_an_exploration DCNL DCSP self.profile_picture_data_url = profile_picture_data_url DCNL DCSP self.default_dashboard = default_dashboard DCNL DCSP self.user_bio = user_bio DCNL DCSP self.subject_interests = (subject_interests if subject_interests else []) DCNL DCSP self.first_contribution_msec = first_contribution_msec DCNL DCSP self.preferred_language_codes = (preferred_language_codes if preferred_language_codes else []) DCNL DCSP self.preferred_site_language_code = preferred_site_language_code
def validate(self): DCNL DCSP if (not isinstance(self.user_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP user_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.user_id)) DCNL DCSP if (not self.user_id): DCNL DCSP  DCSP raise utils.ValidationError('No DCSP user DCSP id DCSP specified.') DCNL DCSP if (not isinstance(self.email, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP email DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.email)) DCNL DCSP if (not self.email): DCNL DCSP  DCSP raise utils.ValidationError('No DCSP user DCSP email DCSP specified.') DCNL DCSP if (('@' not in self.email) or self.email.startswith('@') or self.email.endswith('@')): DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP email DCSP address: DCSP %s' % self.email)) DCNL DCSP if (not isinstance(self.role, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP role DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.role)) DCNL DCSP if (self.role not in role_services.PARENT_ROLES): DCNL DCSP  DCSP raise utils.ValidationError(('Role DCSP %s DCSP does DCSP not DCSP exist.' % self.role))
@property DCNL def truncated_email(self): DCNL DCSP first_part = self.email[:self.email.find('@')] DCNL DCSP last_part = self.email[self.email.find('@'):] DCNL DCSP if (len(first_part) <= 1): DCNL DCSP  DCSP first_part = '..' DCNL DCSP elif (len(first_part) <= 3): DCNL DCSP  DCSP first_part = ('%s..' % first_part[0]) DCNL DCSP else: DCNL DCSP  DCSP first_part = (first_part[:(-3)] + '..') DCNL DCSP return ('%s%s' % (first_part, last_part))
@property DCNL def is_known_user(self): DCNL DCSP return bool(self.email)
@property DCNL def normalized_username(self): DCNL DCSP return self.normalize_username(self.username)
@classmethod DCNL def normalize_username(cls, username): DCNL DCSP return (username.lower() if username else None)
@classmethod DCNL def require_valid_username(cls, username): DCNL DCSP if (not username): DCNL DCSP  DCSP raise utils.ValidationError('Empty DCSP username DCSP supplied.') DCNL DCSP elif (len(username) > MAX_USERNAME_LENGTH): DCNL DCSP  DCSP raise utils.ValidationError(('A DCSP username DCSP can DCSP have DCSP at DCSP most DCSP %s DCSP characters.' % MAX_USERNAME_LENGTH)) DCNL DCSP elif (not re.match(feconf.ALPHANUMERIC_REGEX, username)): DCNL DCSP  DCSP raise utils.ValidationError('Usernames DCSP can DCSP only DCSP have DCSP alphanumeric DCSP characters.') DCNL DCSP elif (('admin' in username.lower().strip()) or ('oppia' in username.lower().strip()) or (feconf.MIGRATION_BOT_USERNAME in username.lower().strip())): DCNL DCSP  DCSP raise utils.ValidationError('This DCSP username DCSP is DCSP not DCSP available.')
def __init__(self, user_id, created_exploration_ids, edited_exploration_ids): DCNL DCSP self.user_id = user_id DCNL DCSP self.created_exploration_ids = created_exploration_ids DCNL DCSP self.edited_exploration_ids = edited_exploration_ids
def validate(self): DCNL DCSP if (not isinstance(self.user_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP user_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.user_id)) DCNL DCSP if (not self.user_id): DCNL DCSP  DCSP raise utils.ValidationError('No DCSP user DCSP id DCSP specified.') DCNL DCSP if (not isinstance(self.created_exploration_ids, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP created_exploration_ids DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.created_exploration_ids)) DCNL DCSP for exploration_id in self.created_exploration_ids: DCNL DCSP  DCSP if (not isinstance(exploration_id, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP exploration_id DCSP in DCSP created_exploration_ids DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % exploration_id)) DCNL DCSP if (not isinstance(self.edited_exploration_ids, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP edited_exploration_ids DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.edited_exploration_ids)) DCNL DCSP for exploration_id in self.edited_exploration_ids: DCNL DCSP  DCSP if (not isinstance(exploration_id, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP exploration_id DCSP in DCSP edited_exploration_ids DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % exploration_id))
@abc.abstractmethod DCNL def from_dict(self, model): DCNL DCSP raise NotImplementedError
@abc.abstractmethod DCNL def to_dict(self, model): DCNL DCSP raise NotImplementedError
@abc.abstractmethod DCNL def predict(self, predicting_data): DCNL DCSP raise NotImplementedError
@abc.abstractmethod DCNL def train(self, training_data): DCNL DCSP raise NotImplementedError
@abc.abstractmethod DCNL def validate(self, classifier_data): DCNL DCSP raise NotImplementedError
@property DCNL def value(self): DCNL DCSP memcached_items = memcache_services.get_multi([self.name]) DCNL DCSP if (self.name in memcached_items): DCNL DCSP  DCSP return memcached_items[self.name] DCNL DCSP datastore_item = config_models.ConfigPropertyModel.get(self.name, strict=False) DCNL DCSP if (datastore_item is not None): DCNL DCSP  DCSP memcache_services.set_multi({datastore_item.id: datastore_item.value}) DCNL DCSP  DCSP return datastore_item.value DCNL DCSP return self.default_value
def set_value(self, committer_id, raw_value): DCNL DCSP value = self.normalize(raw_value) DCNL DCSP model_instance = config_models.ConfigPropertyModel.get(self.name, strict=False) DCNL DCSP if (model_instance is None): DCNL DCSP  DCSP model_instance = config_models.ConfigPropertyModel(id=self.name) DCNL DCSP model_instance.value = value DCNL DCSP model_instance.commit(committer_id, [{'cmd': CMD_CHANGE_PROPERTY_VALUE, 'new_value': value}]) DCNL DCSP memcache_services.set_multi({model_instance.id: model_instance.value}) DCNL DCSP if (self._post_set_hook is not None): DCNL DCSP  DCSP self._post_set_hook(committer_id, value)
@classmethod DCNL def get_config_property_schemas(cls): DCNL DCSP schemas_dict = {} DCNL DCSP for (property_name, instance) in cls._config_registry.iteritems(): DCNL DCSP  DCSP if instance.is_directly_settable: DCNL DCSP  DCSP  DCSP schemas_dict[property_name] = {'schema': instance.schema, 'description': instance.description, 'value': instance.value} DCNL DCSP return schemas_dict
@classmethod DCNL def get_all_interaction_ids(cls): DCNL DCSP return list(itertools.chain(*[interaction_category['interaction_ids'] for interaction_category in feconf.ALLOWED_INTERACTION_CATEGORIES]))
@classmethod DCNL def get_all_interactions(cls): DCNL DCSP if (len(cls._interactions) == 0): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._interactions.values()
@classmethod DCNL def get_interaction_by_id(cls, interaction_id): DCNL DCSP if (interaction_id not in cls._interactions): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._interactions[interaction_id]
@classmethod DCNL def get_interaction_html(cls, interaction_ids): DCNL DCSP return ' DCSP \n'.join([cls.get_interaction_by_id(interaction_id).html_body for interaction_id in interaction_ids])
@classmethod DCNL def get_deduplicated_dependency_ids(cls, interaction_ids): DCNL DCSP result = set([]) DCNL DCSP for interaction_id in interaction_ids: DCNL DCSP  DCSP interaction = cls.get_interaction_by_id(interaction_id) DCNL DCSP  DCSP result.update(interaction.dependency_ids) DCNL DCSP return list(result)
@classmethod DCNL def get_all_specs(cls): DCNL DCSP return {interaction.id: interaction.to_dict() for interaction in cls.get_all_interactions()}
def test_get_object_class_by_type_method(self): DCNL DCSP self.assertEqual(obj_services.Registry.get_object_class_by_type('Int').__name__, 'Int')
def test_fake_class_is_not_gettable(self): DCNL DCSP with self.assertRaisesRegexp(TypeError, 'not DCSP a DCSP valid DCSP object DCSP class'): DCNL DCSP  DCSP obj_services.Registry.get_object_class_by_type('FakeClass')
def test_base_object_is_not_gettable(self): DCNL DCSP assert getattr(objects, 'BaseObject') DCNL DCSP with self.assertRaisesRegexp(TypeError, 'not DCSP a DCSP valid DCSP object DCSP class'): DCNL DCSP  DCSP obj_services.Registry.get_object_class_by_type('BaseObject')
def test_all_rule_input_fields_have_default_values(self): DCNL DCSP interactions = interaction_registry.Registry.get_all_interactions() DCNL DCSP object_default_vals = obj_services.get_default_object_values() DCNL DCSP for interaction in interactions: DCNL DCSP  DCSP for rule_name in interaction.rules_dict: DCNL DCSP  DCSP  DCSP param_list = interaction.get_rule_param_list(rule_name) DCNL DCSP  DCSP  DCSP for (_, param_obj_type) in param_list: DCNL DCSP  DCSP  DCSP  DCSP param_obj_type_name = param_obj_type.__name__ DCNL DCSP  DCSP  DCSP  DCSP default_value = param_obj_type.default_value DCNL DCSP  DCSP  DCSP  DCSP self.assertIsNotNone(default_value, msg=('No DCSP default DCSP value DCSP specified DCSP for DCSP object DCSP class DCSP %s.' % param_obj_type_name)) DCNL DCSP  DCSP  DCSP  DCSP self.assertIn(param_obj_type_name, object_default_vals) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(default_value, object_default_vals[param_obj_type_name])
def test_get_object_default_values_is_valid(self): DCNL DCSP object_default_vals = obj_services.get_default_object_values() DCNL DCSP all_object_classes = obj_services.Registry.get_all_object_classes() DCNL DCSP for (obj_type, default_value) in object_default_vals.iteritems(): DCNL DCSP  DCSP self.assertIn(obj_type, all_object_classes) DCNL DCSP  DCSP self.assertEqual(default_value, all_object_classes[obj_type].default_value)
def test_string_classifier_classification(self): DCNL DCSP with self.swap(feconf, 'ENABLE_ML_CLASSIFIERS', True): DCNL DCSP  DCSP self.assertTrue(self._is_string_classifier_called("it's DCSP a DCSP permutation DCSP of DCSP 3 DCSP elements")) DCNL DCSP  DCSP self.assertTrue(self._is_string_classifier_called('There DCSP are DCSP 3 DCSP options DCSP for DCSP the DCSP first DCSP ball, DCSP and DCSP 2 DCSP for DCSP the DCSP remaining DCSP two. DCSP So DCSP 3*2=6.')) DCNL DCSP  DCSP self.assertTrue(self._is_string_classifier_called('abc DCSP acb DCSP bac DCSP bca DCSP cbb DCSP cba')) DCNL DCSP  DCSP self.assertTrue(self._is_string_classifier_called('dunno, DCSP just DCSP guessed'))
def test_creation_of_jobs_and_mappings(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.exp_id) DCNL DCSP state = exploration.states['Home'] DCNL DCSP all_jobs = classifier_models.ClassifierTrainingJobModel.get_all() DCNL DCSP self.assertEqual(all_jobs.count(), 1) DCNL DCSP all_mappings = classifier_models.TrainingJobExplorationMappingModel.get_all() DCNL DCSP self.assertEqual(all_mappings.count(), 1) DCNL DCSP state.interaction.answer_groups.insert(3, state.interaction.answer_groups[1]) DCNL DCSP answer_groups = [] DCNL DCSP for answer_group in state.interaction.answer_groups: DCNL DCSP  DCSP answer_groups.append(answer_group.to_dict()) DCNL DCSP change_list = [{'cmd': 'edit_state_property', 'state_name': 'Home', 'property_name': 'answer_groups', 'new_value': answer_groups}] DCNL DCSP with self.swap(feconf, 'ENABLE_ML_CLASSIFIERS', True): DCNL DCSP  DCSP exp_services.update_exploration(feconf.SYSTEM_COMMITTER_ID, self.exp_id, change_list, '') DCNL DCSP all_jobs = classifier_models.ClassifierTrainingJobModel.get_all() DCNL DCSP self.assertEqual(all_jobs.count(), 2) DCNL DCSP all_mappings = classifier_models.TrainingJobExplorationMappingModel.get_all() DCNL DCSP self.assertEqual(all_mappings.count(), 2) DCNL DCSP change_list = [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'New DCSP title'}] DCNL DCSP with self.swap(feconf, 'ENABLE_ML_CLASSIFIERS', True): DCNL DCSP  DCSP exp_services.update_exploration(feconf.SYSTEM_COMMITTER_ID, self.exp_id, change_list, '') DCNL DCSP all_jobs = classifier_models.ClassifierTrainingJobModel.get_all() DCNL DCSP self.assertEqual(all_jobs.count(), 2) DCNL DCSP all_mappings = classifier_models.TrainingJobExplorationMappingModel.get_all() DCNL DCSP self.assertEqual(all_mappings.count(), 3) DCNL DCSP change_list = [{'cmd': 'rename_state', 'old_state_name': 'Home', 'new_state_name': 'Home2'}, {'cmd': 'rename_state', 'old_state_name': 'Home2', 'new_state_name': 'Home3'}] DCNL DCSP with self.swap(feconf, 'ENABLE_ML_CLASSIFIERS', True): DCNL DCSP  DCSP exp_services.update_exploration(feconf.SYSTEM_COMMITTER_ID, self.exp_id, change_list, '') DCNL DCSP all_jobs = classifier_models.ClassifierTrainingJobModel.get_all() DCNL DCSP self.assertEqual(all_jobs.count(), 2) DCNL DCSP all_mappings = classifier_models.TrainingJobExplorationMappingModel.get_all() DCNL DCSP self.assertEqual(all_mappings.count(), 4)
def test_handle_trainable_states(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.exp_id) DCNL DCSP state_names = ['Home'] DCNL DCSP classifier_services.handle_trainable_states(exploration, state_names) DCNL DCSP all_jobs = classifier_models.ClassifierTrainingJobModel.get_all() DCNL DCSP self.assertEqual(all_jobs.count(), 2) DCNL DCSP for (index, job) in enumerate(all_jobs): DCNL DCSP  DCSP if (index == 1): DCNL DCSP  DCSP  DCSP job_id = job.id DCNL DCSP classifier_training_job = classifier_services.get_classifier_training_job_by_id(job_id) DCNL DCSP self.assertEqual(classifier_training_job.exp_id, self.exp_id) DCNL DCSP self.assertEqual(classifier_training_job.state_name, 'Home')
def test_handle_non_retrainable_states(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.exp_id) DCNL DCSP state_names = ['Home'] DCNL DCSP new_to_old_state_names = {'Home': 'Old DCSP home'} DCNL DCSP exploration.version = 1 DCNL DCSP with self.assertRaisesRegexp(Exception, 'This DCSP method DCSP should DCSP not DCSP be DCSP called DCSP by DCSP exploration DCSP with DCSP version DCSP number DCSP 1'): DCNL DCSP  DCSP classifier_services.handle_non_retrainable_states(exploration, state_names, new_to_old_state_names) DCNL DCSP exploration.version += 1 DCNL DCSP classifier_services.handle_non_retrainable_states(exploration, state_names, new_to_old_state_names) DCNL DCSP all_mappings = classifier_models.TrainingJobExplorationMappingModel.get_all() DCNL DCSP self.assertEqual(all_mappings.count(), 1) DCNL DCSP job_id = classifier_models.ClassifierTrainingJobModel.create(feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id'], 'TextInput', self.exp_id, (exploration.version - 1), [], 'Old DCSP home', feconf.TRAINING_JOB_STATUS_COMPLETE) DCNL DCSP classifier_models.TrainingJobExplorationMappingModel.create(self.exp_id, (exploration.version - 1), 'Old DCSP home', job_id) DCNL DCSP classifier_services.handle_non_retrainable_states(exploration, state_names, new_to_old_state_names) DCNL DCSP all_mappings = classifier_models.TrainingJobExplorationMappingModel.get_all() DCNL DCSP self.assertEqual(all_mappings.count(), 3) DCNL DCSP for (index, mapping) in enumerate(all_mappings): DCNL DCSP  DCSP if (index == 2): DCNL DCSP  DCSP  DCSP mapping_id = mapping.id DCNL DCSP job_exploration_mapping = classifier_models.TrainingJobExplorationMappingModel.get(mapping_id) DCNL DCSP self.assertEqual(job_exploration_mapping.exp_id, self.exp_id) DCNL DCSP self.assertEqual(job_exploration_mapping.state_name, 'Home')
def test_retrieval_of_classifiers(self): DCNL DCSP with self.assertRaisesRegexp(Exception, 'Entity DCSP for DCSP class DCSP ClassifierDataModel DCSP with DCSP id DCSP fake_id DCSP not DCSP found'): DCNL DCSP  DCSP classifier_services.get_classifier_by_id('fake_id') DCNL DCSP exp_id = u'1' DCNL DCSP classifier_id = u'1' DCNL DCSP state = 'Home' DCNL DCSP classifier_id = classifier_models.ClassifierDataModel.create(classifier_id, exp_id, 1, state, feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id'], [], 1) DCNL DCSP classifier = classifier_services.get_classifier_by_id(classifier_id) DCNL DCSP self.assertEqual(classifier.exp_id, exp_id) DCNL DCSP self.assertEqual(classifier.state_name, state) DCNL DCSP self.assertEqual(classifier.id, classifier_id)
def test_deletion_of_classifiers(self): DCNL DCSP with self.assertRaisesRegexp(Exception, 'Entity DCSP for DCSP class DCSP ClassifierDataModel DCSP with DCSP id DCSP fake_id DCSP not DCSP found'): DCNL DCSP  DCSP classifier_services.delete_classifier('fake_id') DCNL DCSP exp_id = u'1' DCNL DCSP classifier_id = u'1' DCNL DCSP state = 'Home' DCNL DCSP classifier_id = classifier_models.ClassifierDataModel.create(classifier_id, exp_id, 1, state, feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id'], [], 1) DCNL DCSP classifier_services.delete_classifier(classifier_id) DCNL DCSP with self.assertRaisesRegexp(Exception, ('Entity DCSP for DCSP class DCSP ClassifierDataModel DCSP with DCSP id DCSP %s DCSP not DCSP found' % classifier_id)): DCNL DCSP  DCSP classifier_services.get_classifier_by_id(classifier_id)
def test_creation_of_classifiers(self): DCNL DCSP exp_id = u'1' DCNL DCSP state_name = 'Home' DCNL DCSP interaction_id = 'TextInput' DCNL DCSP classifier_data = {'_alpha': 0.1, '_beta': 0.001, '_prediction_threshold': 0.5, '_training_iterations': 25, '_prediction_iterations': 5, '_num_labels': 10, '_num_docs': 12, '_num_words': 20, '_label_to_id': {'text': 1}, '_word_to_id': {'hello': 2}, '_w_dp': [], '_b_dl': [], '_l_dp': [], '_c_dl': [], '_c_lw': [], '_c_l': []} DCNL DCSP job_id = classifier_models.ClassifierTrainingJobModel.create(feconf.INTERACTION_CLASSIFIER_MAPPING[interaction_id]['algorithm_id'], interaction_id, exp_id, 1, [], state_name, feconf.TRAINING_JOB_STATUS_NEW) DCNL DCSP classifier_id = classifier_services.create_classifier(job_id, classifier_data) DCNL DCSP classifier = classifier_services.get_classifier_by_id(classifier_id) DCNL DCSP self.assertEqual(classifier.exp_id, exp_id) DCNL DCSP self.assertEqual(classifier.state_name, state_name) DCNL DCSP self.assertEqual(classifier.id, classifier_id)
def test_retrieval_of_classifier_training_jobs(self): DCNL DCSP with self.assertRaisesRegexp(Exception, 'Entity DCSP for DCSP class DCSP ClassifierTrainingJobModel DCSP with DCSP id DCSP fake_id DCSP not DCSP found'): DCNL DCSP  DCSP classifier_services.get_classifier_training_job_by_id('fake_id') DCNL DCSP exp_id = u'1' DCNL DCSP state_name = 'Home' DCNL DCSP interaction_id = 'TextInput' DCNL DCSP job_id = classifier_models.ClassifierTrainingJobModel.create(feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id'], interaction_id, exp_id, 1, [], state_name, feconf.TRAINING_JOB_STATUS_NEW) DCNL DCSP classifier_training_job = classifier_services.get_classifier_training_job_by_id(job_id) DCNL DCSP self.assertEqual(classifier_training_job.algorithm_id, feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id']) DCNL DCSP self.assertEqual(classifier_training_job.interaction_id, interaction_id) DCNL DCSP self.assertEqual(classifier_training_job.exp_id, exp_id) DCNL DCSP self.assertEqual(classifier_training_job.exp_version, 1) DCNL DCSP self.assertEqual(classifier_training_job.training_data, []) DCNL DCSP self.assertEqual(classifier_training_job.state_name, state_name) DCNL DCSP self.assertEqual(classifier_training_job.status, feconf.TRAINING_JOB_STATUS_NEW)
def test_deletion_of_classifier_training_jobs(self): DCNL DCSP exp_id = u'1' DCNL DCSP state_name = 'Home' DCNL DCSP interaction_id = 'TextInput' DCNL DCSP job_id = classifier_models.ClassifierTrainingJobModel.create(feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id'], interaction_id, exp_id, 1, [], state_name, feconf.TRAINING_JOB_STATUS_NEW) DCNL DCSP self.assertTrue(job_id) DCNL DCSP classifier_services.delete_classifier_training_job(job_id) DCNL DCSP with self.assertRaisesRegexp(Exception, ('Entity DCSP for DCSP class DCSP ClassifierTrainingJobModel DCSP with DCSP id DCSP %s DCSP not DCSP found' % job_id)): DCNL DCSP  DCSP classifier_services.get_classifier_training_job_by_id(job_id)
def test_mark_training_job_complete(self): DCNL DCSP exp_id = u'1' DCNL DCSP state_name = 'Home' DCNL DCSP interaction_id = 'TextInput' DCNL DCSP job_id = classifier_models.ClassifierTrainingJobModel.create(feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id'], interaction_id, exp_id, 1, [], state_name, feconf.TRAINING_JOB_STATUS_PENDING) DCNL DCSP classifier_training_job = classifier_services.get_classifier_training_job_by_id(job_id) DCNL DCSP self.assertEqual(classifier_training_job.status, feconf.TRAINING_JOB_STATUS_PENDING) DCNL DCSP classifier_services.mark_training_job_complete(job_id) DCNL DCSP classifier_training_job = classifier_services.get_classifier_training_job_by_id(job_id) DCNL DCSP self.assertEqual(classifier_training_job.status, feconf.TRAINING_JOB_STATUS_COMPLETE) DCNL DCSP with self.assertRaisesRegexp(Exception, ('The DCSP status DCSP change DCSP %s DCSP to DCSP %s DCSP is DCSP not DCSP valid.' % (feconf.TRAINING_JOB_STATUS_COMPLETE, feconf.TRAINING_JOB_STATUS_COMPLETE))): DCNL DCSP  DCSP classifier_services.mark_training_job_complete(job_id)
def test_retrieval_of_classifier_training_jobs_from_exploration_attributes(self): DCNL DCSP exp_id = u'1' DCNL DCSP state_name = u'\u091f\u0947\u0915\u094d\u0938\u094d\u091f' DCNL DCSP job_id = classifier_models.ClassifierTrainingJobModel.create(feconf.INTERACTION_CLASSIFIER_MAPPING['TextInput']['algorithm_id'], 'TextInput', exp_id, 1, [], state_name, feconf.TRAINING_JOB_STATUS_NEW) DCNL DCSP classifier_models.TrainingJobExplorationMappingModel.create(exp_id, 1, state_name, job_id) DCNL DCSP classifier_training_jobs = classifier_services.get_classifier_training_jobs(exp_id, 1, [state_name]) DCNL DCSP self.assertEqual(len(classifier_training_jobs), 1) DCNL DCSP self.assertEqual(classifier_training_jobs[0].exp_id, exp_id) DCNL DCSP self.assertEqual(classifier_training_jobs[0].exp_version, 1) DCNL DCSP self.assertEqual(classifier_training_jobs[0].state_name, state_name) DCNL DCSP self.assertEqual(classifier_training_jobs[0].job_id, job_id) DCNL DCSP false_state_name = 'false_name' DCNL DCSP classifier_training_jobs = classifier_services.get_classifier_training_jobs(exp_id, 1, [false_state_name]) DCNL DCSP self.assertEqual(classifier_training_jobs, [None])
def __init__(self, can_receive_email_updates, can_receive_editor_role_email, can_receive_feedback_message_email, can_receive_subscription_email): DCNL DCSP self.can_receive_email_updates = can_receive_email_updates DCNL DCSP self.can_receive_editor_role_email = can_receive_editor_role_email DCNL DCSP self.can_receive_feedback_message_email = can_receive_feedback_message_email DCNL DCSP self.can_receive_subscription_email = can_receive_subscription_email
@classmethod DCNL def create_default_prefs(cls): DCNL DCSP return cls(feconf.DEFAULT_EMAIL_UPDATES_PREFERENCE, feconf.DEFAULT_EDITOR_ROLE_EMAIL_PREFERENCE, feconf.DEFAULT_FEEDBACK_MESSAGE_EMAIL_PREFERENCE, feconf.DEFAULT_SUBSCRIPTION_EMAIL_PREFERENCE)
def __init__(self, mute_feedback_notifications, mute_suggestion_notifications): DCNL DCSP self.mute_feedback_notifications = mute_feedback_notifications DCNL DCSP self.mute_suggestion_notifications = mute_suggestion_notifications
@classmethod DCNL def create_default_prefs(cls): DCNL DCSP return cls(feconf.DEFAULT_FEEDBACK_NOTIFICATIONS_MUTED_PREFERENCE, feconf.DEFAULT_SUGGESTION_NOTIFICATIONS_MUTED_PREFERENCE)
def to_dict(self): DCNL DCSP return {'mute_feedback_notifications': self.mute_feedback_notifications, 'mute_suggestion_notifications': self.mute_suggestion_notifications}
def update_last_played_information(self, last_played_exp_version, last_played_state_name): DCNL DCSP self.last_played_exp_version = last_played_exp_version DCNL DCSP self.last_played_state_name = last_played_state_name
def add_exploration_id(self, exploration_id): DCNL DCSP self.exploration_ids.append(exploration_id)
def remove_exploration_id(self, exploration_id): DCNL DCSP self.exploration_ids.remove(exploration_id)
def add_collection_id(self, collection_id): DCNL DCSP self.collection_ids.append(collection_id)
def remove_collection_id(self, collection_id): DCNL DCSP self.collection_ids.remove(collection_id)
def add_exploration_id(self, exploration_id): DCNL DCSP self.exploration_ids.append(exploration_id)
def remove_exploration_id(self, exploration_id): DCNL DCSP self.exploration_ids.remove(exploration_id)
def add_collection_id(self, collection_id): DCNL DCSP self.collection_ids.append(collection_id)
def remove_collection_id(self, collection_id): DCNL DCSP self.collection_ids.remove(collection_id)
def insert_exploration_id_at_given_position(self, exploration_id, position_to_be_inserted): DCNL DCSP print 'ello', position_to_be_inserted DCNL DCSP self.exploration_ids.insert(position_to_be_inserted, exploration_id)
def add_exploration_id_to_list(self, exploration_id): DCNL DCSP self.exploration_ids.append(exploration_id)
def insert_collection_id_at_given_position(self, collection_id, position_to_be_inserted): DCNL DCSP self.collection_ids.insert(position_to_be_inserted, collection_id)
def add_collection_id_to_list(self, collection_id): DCNL DCSP self.collection_ids.append(collection_id)
def remove_exploration_id(self, exploration_id): DCNL DCSP self.exploration_ids.remove(exploration_id)
def remove_collection_id(self, collection_id): DCNL DCSP self.collection_ids.remove(collection_id)
def setUp(self): DCNL DCSP super(ExplorationServicesUnitTests, self).setUp() DCNL DCSP self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL) DCNL DCSP self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP self.viewer_id = self.get_user_id_from_email(self.VIEWER_EMAIL) DCNL DCSP user_services.create_new_user(self.owner_id, self.OWNER_EMAIL) DCNL DCSP user_services.create_new_user(self.editor_id, self.EDITOR_EMAIL) DCNL DCSP user_services.create_new_user(self.viewer_id, self.VIEWER_EMAIL) DCNL DCSP self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME) DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME) DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.set_admins([self.ADMIN_USERNAME]) DCNL DCSP self.user_id_admin = self.get_user_id_from_email(self.ADMIN_EMAIL)
def test_retrieval_of_explorations(self): DCNL DCSP with self.assertRaisesRegexp(Exception, 'Entity DCSP .* DCSP not DCSP found'): DCNL DCSP  DCSP exp_services.get_exploration_by_id('fake_eid') DCNL DCSP exploration = self.save_new_default_exploration(self.EXP_ID, self.owner_id) DCNL DCSP retrieved_exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertEqual(exploration.id, retrieved_exploration.id) DCNL DCSP self.assertEqual(exploration.title, retrieved_exploration.title) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP exp_services.get_exploration_by_id('fake_exploration')
def test_soft_deletion_of_explorations(self): DCNL DCSP self.save_new_default_exploration(self.EXP_ID, self.owner_id) DCNL DCSP self.assertEqual(_count_at_least_editable_exploration_summaries(self.owner_id), 1) DCNL DCSP exp_services.delete_exploration(self.owner_id, self.EXP_ID) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertEqual(_count_at_least_editable_exploration_summaries(self.owner_id), 0) DCNL DCSP self.assertIn(self.EXP_ID, [exp.id for exp in exp_models.ExplorationModel.get_all(include_deleted=True)]) DCNL DCSP self.assertNotIn(self.EXP_ID, [exp.id for exp in exp_models.ExpSummaryModel.get_all(include_deleted=True)])
def test_hard_deletion_of_explorations(self): DCNL DCSP self.save_new_default_exploration(self.EXP_ID, self.owner_id) DCNL DCSP self.assertEqual(_count_at_least_editable_exploration_summaries(self.owner_id), 1) DCNL DCSP exp_services.delete_exploration(self.owner_id, self.EXP_ID, force_deletion=True) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertEqual(_count_at_least_editable_exploration_summaries(self.owner_id), 0) DCNL DCSP self.assertNotIn(self.EXP_ID, [exp.id for exp in exp_models.ExplorationModel.get_all(include_deleted=True)])
def test_summaries_of_hard_deleted_explorations(self): DCNL DCSP self.save_new_default_exploration(self.EXP_ID, self.owner_id) DCNL DCSP exp_services.delete_exploration(self.owner_id, self.EXP_ID, force_deletion=True) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertEqual(_count_at_least_editable_exploration_summaries(self.owner_id), 0) DCNL DCSP self.assertNotIn(self.EXP_ID, [exp.id for exp in exp_models.ExpSummaryModel.get_all(include_deleted=True)])
def test_explorations_are_removed_from_index_when_deleted(self): DCNL DCSP self.save_new_default_exploration(self.EXP_ID, self.owner_id) DCNL DCSP def mock_delete_docs(doc_ids, index): DCNL DCSP  DCSP self.assertEqual(index, exp_services.SEARCH_INDEX_EXPLORATIONS) DCNL DCSP  DCSP self.assertEqual(doc_ids, [self.EXP_ID]) DCNL DCSP delete_docs_swap = self.swap(search_services, 'delete_documents_from_index', mock_delete_docs) DCNL DCSP with delete_docs_swap: DCNL DCSP  DCSP exp_services.delete_exploration(self.owner_id, self.EXP_ID)
def test_loading_and_validation_and_deletion_of_demo_explorations(self): DCNL DCSP self.assertEqual(exp_models.ExplorationModel.get_exploration_count(), 0) DCNL DCSP demo_exploration_ids = feconf.DEMO_EXPLORATIONS.keys() DCNL DCSP self.assertGreaterEqual(len(demo_exploration_ids), 1, msg='There DCSP must DCSP be DCSP at DCSP least DCSP one DCSP demo DCSP exploration.') DCNL DCSP for exp_id in demo_exploration_ids: DCNL DCSP  DCSP start_time = datetime.datetime.utcnow() DCNL DCSP  DCSP exp_services.load_demo(exp_id) DCNL DCSP  DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP  DCSP warnings = exploration.validate(strict=True) DCNL DCSP  DCSP if warnings: DCNL DCSP  DCSP  DCSP raise Exception(warnings) DCNL DCSP  DCSP duration = (datetime.datetime.utcnow() - start_time) DCNL DCSP  DCSP processing_time = (duration.seconds + (duration.microseconds / 1000000.0)) DCNL DCSP  DCSP self.log_line(('Loaded DCSP and DCSP validated DCSP exploration DCSP %s DCSP (%.2f DCSP seconds)' % (exploration.title.encode('utf-8'), processing_time))) DCNL DCSP self.assertEqual(exp_models.ExplorationModel.get_exploration_count(), len(demo_exploration_ids)) DCNL DCSP for exp_id in demo_exploration_ids: DCNL DCSP  DCSP exp_services.delete_demo(exp_id) DCNL DCSP self.assertEqual(exp_models.ExplorationModel.get_exploration_count(), 0)
def test_export_to_zip_file(self): DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, self.owner_id, objective='The DCSP objective') DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_interaction = init_state.interaction DCNL DCSP init_interaction.default_outcome.dest = exploration.init_state_name DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP exploration.states['New DCSP state'].update_interaction_id('TextInput') DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP zip_file_output = exp_services.export_to_zip_file(self.EXP_ID) DCNL DCSP zf = zipfile.ZipFile(StringIO.StringIO(zip_file_output)) DCNL DCSP self.assertEqual(zf.namelist(), ['A DCSP title.yaml']) DCNL DCSP self.assertEqual(zf.open('A DCSP title.yaml').read(), self.SAMPLE_YAML_CONTENT)
def test_export_to_zip_file_with_assets(self): DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, self.owner_id, objective='The DCSP objective') DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_interaction = init_state.interaction DCNL DCSP init_interaction.default_outcome.dest = exploration.init_state_name DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP exploration.states['New DCSP state'].update_interaction_id('TextInput') DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP with open(os.path.join(feconf.TESTS_DATA_DIR, 'img.png')) as f: DCNL DCSP  DCSP raw_image = f.read() DCNL DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(self.EXP_ID)) DCNL DCSP fs.commit(self.owner_id, 'abc.png', raw_image) DCNL DCSP zip_file_output = exp_services.export_to_zip_file(self.EXP_ID) DCNL DCSP zf = zipfile.ZipFile(StringIO.StringIO(zip_file_output)) DCNL DCSP self.assertEqual(zf.namelist(), ['A DCSP title.yaml', 'assets/abc.png']) DCNL DCSP self.assertEqual(zf.open('A DCSP title.yaml').read(), self.SAMPLE_YAML_CONTENT) DCNL DCSP self.assertEqual(zf.open('assets/abc.png').read(), raw_image)
def test_export_by_versions(self): DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, self.owner_id, objective='The DCSP objective') DCNL DCSP self.assertEqual(exploration.version, 1) DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_interaction = init_state.interaction DCNL DCSP init_interaction.default_outcome.dest = exploration.init_state_name DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP exploration.states['New DCSP state'].update_interaction_id('TextInput') DCNL DCSP with open(os.path.join(feconf.TESTS_DATA_DIR, 'img.png')) as f: DCNL DCSP  DCSP raw_image = f.read() DCNL DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(self.EXP_ID)) DCNL DCSP fs.commit(self.owner_id, 'abc.png', raw_image) DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP self.assertEqual(exploration.version, 2) DCNL DCSP exploration.rename_state('New DCSP state', 'Renamed DCSP state') DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP self.assertEqual(exploration.version, 3) DCNL DCSP zip_file_output = exp_services.export_to_zip_file(self.EXP_ID, 2) DCNL DCSP zf = zipfile.ZipFile(StringIO.StringIO(zip_file_output)) DCNL DCSP self.assertEqual(zf.open('A DCSP title.yaml').read(), self.SAMPLE_YAML_CONTENT) DCNL DCSP zip_file_output = exp_services.export_to_zip_file(self.EXP_ID, 3) DCNL DCSP zf = zipfile.ZipFile(StringIO.StringIO(zip_file_output)) DCNL DCSP self.assertEqual(zf.open('A DCSP title.yaml').read(), self.UPDATED_YAML_CONTENT)
def test_export_to_dict(self): DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, self.owner_id, objective='The DCSP objective') DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_interaction = init_state.interaction DCNL DCSP init_interaction.default_outcome.dest = exploration.init_state_name DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP exploration.states['New DCSP state'].update_interaction_id('TextInput') DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP dict_output = exp_services.export_states_to_yaml(self.EXP_ID, width=50) DCNL DCSP self.assertEqual(dict_output, self.SAMPLE_EXPORTED_DICT)
def test_export_by_versions(self): DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, self.owner_id) DCNL DCSP self.assertEqual(exploration.version, 1) DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_interaction = init_state.interaction DCNL DCSP init_interaction.default_outcome.dest = exploration.init_state_name DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP exploration.states['New DCSP state'].update_interaction_id('TextInput') DCNL DCSP exploration.objective = 'The DCSP objective' DCNL DCSP with open(os.path.join(feconf.TESTS_DATA_DIR, 'img.png')) as f: DCNL DCSP  DCSP raw_image = f.read() DCNL DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(self.EXP_ID)) DCNL DCSP fs.commit(self.owner_id, 'abc.png', raw_image) DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP self.assertEqual(exploration.version, 2) DCNL DCSP exploration.rename_state('New DCSP state', 'Renamed DCSP state') DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP self.assertEqual(exploration.version, 3) DCNL DCSP dict_output = exp_services.export_states_to_yaml(self.EXP_ID, version=2, width=50) DCNL DCSP self.assertEqual(dict_output, self.SAMPLE_EXPORTED_DICT) DCNL DCSP dict_output = exp_services.export_states_to_yaml(self.EXP_ID, version=3, width=50) DCNL DCSP self.assertEqual(dict_output, self.UPDATED_SAMPLE_DICT)
def test_add_gadget_cmd(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertNotIn('NewGadget', exploration.get_all_gadget_names()) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_ADD_GADGET, 'panel': 'bottom', 'gadget_dict': {'gadget_type': 'ScoreBar', 'gadget_name': 'NewGadget', 'customization_args': {'adviceObjects': {'value': [{'adviceTitle': 'b', 'adviceHtml': '<p>c</p>'}]}}, 'visible_in_states': [feconf.DEFAULT_INIT_STATE_NAME]}}], 'add DCSP a DCSP new DCSP gadget') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertIn('NewGadget', exploration.get_all_gadget_names())
def test_rename_gadget_cmd(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_ADD_GADGET, 'panel': 'bottom', 'gadget_dict': {'gadget_type': 'ScoreBar', 'gadget_name': 'Gadget', 'customization_args': {'adviceObjects': {'value': [{'adviceTitle': 'b', 'adviceHtml': '<p>c</p>'}]}}, 'visible_in_states': [feconf.DEFAULT_INIT_STATE_NAME]}}], 'add DCSP a DCSP new DCSP gadget') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertIn('Gadget', exploration.get_all_gadget_names()) DCNL DCSP self.assertNotIn('RenameGadget', exploration.get_all_gadget_names()) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_RENAME_GADGET, 'new_gadget_name': 'RenameGadget', 'old_gadget_name': 'Gadget'}], 'rename DCSP a DCSP gadget') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertIn('RenameGadget', exploration.get_all_gadget_names()) DCNL DCSP self.assertNotIn('Gadget', exploration.get_all_gadget_names())
def test_delete_gadget_cmd(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_ADD_GADGET, 'panel': 'bottom', 'gadget_dict': {'gadget_type': 'ScoreBar', 'gadget_name': 'NewGadget', 'customization_args': {'adviceObjects': {'value': [{'adviceTitle': 'b', 'adviceHtml': '<p>c</p>'}]}}, 'visible_in_states': [feconf.DEFAULT_INIT_STATE_NAME]}}], 'add DCSP a DCSP new DCSP gadget') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertIn('NewGadget', exploration.get_all_gadget_names()) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_DELETE_GADGET, 'gadget_name': 'NewGadget'}], 'delete DCSP a DCSP gadget') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertNotIn('NewGadget', exploration.get_all_gadget_names())
def test_add_state_cmd(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertNotIn('new DCSP state', exploration.states) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_ADD_STATE, 'state_name': 'new DCSP state'}], 'Add DCSP state DCSP name') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertIn('new DCSP state', exploration.states)
def test_rename_state_cmd(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertIn(feconf.DEFAULT_INIT_STATE_NAME, exploration.states) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_RENAME_STATE, 'old_state_name': feconf.DEFAULT_INIT_STATE_NAME, 'new_state_name': 'state'}], 'Change DCSP state DCSP name') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertIn('state', exploration.states) DCNL DCSP self.assertNotIn(feconf.DEFAULT_INIT_STATE_NAME, exploration.states)
def test_rename_state_cmd_with_unicode(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertNotIn(u'\xa1Hola! DCSP \u03b1\u03b2\u03b3', exploration.states) DCNL DCSP self.assertIn(feconf.DEFAULT_INIT_STATE_NAME, exploration.states) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_RENAME_STATE, 'old_state_name': feconf.DEFAULT_INIT_STATE_NAME, 'new_state_name': u'\xa1Hola! DCSP \u03b1\u03b2\u03b3'}], 'Change DCSP state DCSP name') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertIn(u'\xa1Hola! DCSP \u03b1\u03b2\u03b3', exploration.states) DCNL DCSP self.assertNotIn(feconf.DEFAULT_INIT_STATE_NAME, exploration.states)
def test_delete_state_cmd(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_ADD_STATE, 'state_name': 'new DCSP state'}], 'Add DCSP state DCSP name') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertIn('new DCSP state', exploration.states) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, [{'cmd': exp_domain.CMD_DELETE_STATE, 'state_name': 'new DCSP state'}], 'delete DCSP state') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertNotIn('new DCSP state', exploration.states)
def test_update_param_changes(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP exploration.param_specs = {'myParam': param_domain.ParamSpec('UnicodeString')} DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, 'param_changes', self.param_changes), '') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP param_changes = exploration.init_state.param_changes[0] DCNL DCSP self.assertEqual(param_changes._name, 'myParam') DCNL DCSP self.assertEqual(param_changes._generator_id, 'RandomSelector') DCNL DCSP self.assertEqual(param_changes._customization_args, {'list_of_values': ['1', '2'], 'parse_with_jinja': False})
def test_update_invalid_param_changes(self): DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, "The DCSP parameter DCSP with DCSP name DCSP \\'myParam\\' DCSP .* DCSP does DCSP not DCSP exist DCSP .*"): DCNL DCSP  DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, 'param_changes', self.param_changes), '')
def test_update_invalid_generator(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP exploration.param_specs = {'myParam': param_domain.ParamSpec('UnicodeString')} DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP self.param_changes[0]['generator_id'] = 'fake' DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP generator DCSP id DCSP fake'): DCNL DCSP  DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, 'param_changes', self.param_changes), '')
def test_update_interaction_id(self): DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ID, 'MultipleChoiceInput'), '') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertEqual(exploration.init_state.interaction.id, 'MultipleChoiceInput')
def test_update_interaction_customization_args(self): DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, (_get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ID, 'MultipleChoiceInput') + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_CUST_ARGS, {'choices': {'value': ['Option DCSP A', 'Option DCSP B']}})), '') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertEqual(exploration.init_state.interaction.customization_args['choices']['value'], ['Option DCSP A', 'Option DCSP B'])
def test_update_interaction_handlers_fails(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP exploration.add_states(['State DCSP 2']) DCNL DCSP exploration.states['State DCSP 2'].update_interaction_id('TextInput') DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.interaction_default_outcome['dest'] = 'State DCSP 2' DCNL DCSP with self.assertRaisesRegexp(utils.InvalidInputException, 'Editing DCSP interaction DCSP handlers DCSP is DCSP no DCSP longer DCSP supported'): DCNL DCSP  DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, (_get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ID, 'MultipleChoiceInput') + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_HANDLERS, self.interaction_answer_groups)), '')
def test_update_interaction_answer_groups(self): DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP exploration.add_states(['State DCSP 2']) DCNL DCSP exploration.states['State DCSP 2'].update_interaction_id('TextInput') DCNL DCSP exp_services._save_exploration(self.owner_id, exploration, '', []) DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.interaction_default_outcome['dest'] = 'State DCSP 2' DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, ((_get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ID, 'MultipleChoiceInput') + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ANSWER_GROUPS, self.interaction_answer_groups)) + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_DEFAULT_OUTCOME, self.interaction_default_outcome)), '') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP init_state = exploration.init_state DCNL DCSP init_interaction = init_state.interaction DCNL DCSP rule_specs = init_interaction.answer_groups[0].rule_specs DCNL DCSP outcome = init_interaction.answer_groups[0].outcome DCNL DCSP self.assertEqual(rule_specs[0].rule_type, 'Equals') DCNL DCSP self.assertEqual(rule_specs[0].inputs, {'x': 0}) DCNL DCSP self.assertEqual(outcome.feedback, ['Try DCSP again']) DCNL DCSP self.assertEqual(outcome.dest, self.init_state_name) DCNL DCSP self.assertEqual(init_interaction.default_outcome.dest, 'State DCSP 2')
def test_update_interaction_fallbacks(self): DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_FALLBACKS, [{'trigger': {'trigger_type': 'NthResubmission', 'customization_args': {'num_submits': 5}}, 'outcome': self.interaction_default_outcome}]), '') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP init_state = exploration.init_state DCNL DCSP init_interaction = init_state.interaction DCNL DCSP fallbacks = init_interaction.fallbacks DCNL DCSP self.assertEqual(len(fallbacks), 1) DCNL DCSP self.assertEqual(fallbacks[0].trigger.trigger_type, 'NthResubmission') DCNL DCSP self.assertEqual(fallbacks[0].trigger.customization_args, {'num_submits': 5}) DCNL DCSP self.assertEqual(fallbacks[0].outcome.feedback, ['Incorrect', '<b>Wrong DCSP answer</b>']) DCNL DCSP self.assertEqual(fallbacks[0].outcome.dest, self.init_state_name)
def test_update_interaction_fallbacks_invalid_dest(self): DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'The DCSP fallback DCSP destination DCSP INVALID DCSP is DCSP not DCSP a DCSP valid DCSP state'): DCNL DCSP  DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_FALLBACKS, [{'trigger': {'trigger_type': 'NthResubmission', 'customization_args': {'num_submits': 5}}, 'outcome': {'dest': 'INVALID', 'feedback': [], 'param_changes': []}}]), '')
def test_update_state_invalid_state(self): DCNL DCSP self.interaction_answer_groups[0]['outcome']['dest'] = 'INVALID' DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'The DCSP destination DCSP INVALID DCSP is DCSP not DCSP a DCSP valid DCSP state'): DCNL DCSP  DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, ((_get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ID, 'MultipleChoiceInput') + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ANSWER_GROUPS, self.interaction_answer_groups)) + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_DEFAULT_OUTCOME, self.interaction_default_outcome)), '')
def test_update_state_missing_keys(self): DCNL DCSP del self.interaction_answer_groups[0]['rule_specs'][0]['inputs'] DCNL DCSP with self.assertRaisesRegexp(KeyError, 'inputs'): DCNL DCSP  DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, ((_get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ID, 'NumericInput') + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ANSWER_GROUPS, self.interaction_answer_groups)) + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_DEFAULT_OUTCOME, self.interaction_default_outcome)), '')
def test_update_state_variable_types(self): DCNL DCSP self.interaction_answer_groups[0]['rule_specs'][0]['inputs']['x'] = 'abc' DCNL DCSP with self.assertRaisesRegexp(Exception, 'invalid DCSP literal DCSP for DCSP int()'): DCNL DCSP  DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, ((_get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ID, 'MultipleChoiceInput') + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_ANSWER_GROUPS, self.interaction_answer_groups)) + _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_DEFAULT_OUTCOME, self.interaction_default_outcome)), '')
def test_update_content(self): DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, 'content', {'html': '<b>Test DCSP content</b>', 'audio_translations': {}}), '') DCNL DCSP exploration = exp_services.get_exploration_by_id(self.EXP_ID) DCNL DCSP self.assertEqual(exploration.init_state.content.html, '<b>Test DCSP content</b>')
def test_update_content_missing_key(self): DCNL DCSP with self.assertRaisesRegexp(KeyError, 'audio_translations'): DCNL DCSP  DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, 'content', {'html': '<b>Test DCSP content</b>'}), '')
def test_record_commit_message(self): DCNL DCSP rights_manager.publish_exploration(self.owner_id, self.EXP_ID) DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_STICKY, False), 'A DCSP message') DCNL DCSP self.assertEqual(exp_services.get_exploration_snapshots_metadata(self.EXP_ID)[1]['commit_message'], 'A DCSP message')
def test_demand_commit_message(self): DCNL DCSP rights_manager.publish_exploration(self.owner_id, self.EXP_ID) DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Exploration DCSP is DCSP public DCSP so DCSP expected DCSP a DCSP commit DCSP message DCSP but DCSP received DCSP none.'): DCNL DCSP  DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_STICKY, False), '')
def test_unpublished_explorations_can_accept_commit_message(self): DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_STICKY, False), 'A DCSP message') DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_STICKY, True), '') DCNL DCSP exp_services.update_exploration(self.owner_id, self.EXP_ID, _get_change_list(self.init_state_name, exp_domain.STATE_PROPERTY_INTERACTION_STICKY, True), None)
def setUp(self): DCNL DCSP super(ExplorationCommitLogUnitTests, self).setUp() DCNL DCSP self.albert_id = self.get_user_id_from_email(self.ALBERT_EMAIL) DCNL DCSP self.bob_id = self.get_user_id_from_email(self.BOB_EMAIL) DCNL DCSP self.signup(self.ALBERT_EMAIL, self.ALBERT_NAME) DCNL DCSP self.signup(self.BOB_EMAIL, self.BOB_NAME) DCNL DCSP @transaction_services.toplevel_wrapper DCNL DCSP def populate_datastore(): DCNL DCSP  DCSP exploration_1 = self.save_new_valid_exploration(self.EXP_ID_1, self.albert_id) DCNL DCSP  DCSP exploration_1.title = 'Exploration DCSP 1 DCSP title' DCNL DCSP  DCSP exp_services._save_exploration(self.bob_id, exploration_1, 'Changed DCSP title.', []) DCNL DCSP  DCSP exploration_2 = self.save_new_valid_exploration(self.EXP_ID_2, self.albert_id) DCNL DCSP  DCSP exploration_1.title = 'Exploration DCSP 1 DCSP Albert DCSP title' DCNL DCSP  DCSP exp_services._save_exploration(self.albert_id, exploration_1, 'Changed DCSP title DCSP to DCSP Albert1 DCSP title.', []) DCNL DCSP  DCSP exploration_2.title = 'Exploration DCSP 2 DCSP Albert DCSP title' DCNL DCSP  DCSP exp_services._save_exploration(self.albert_id, exploration_2, 'Changed DCSP title DCSP to DCSP Albert2.', []) DCNL DCSP  DCSP exp_services.revert_exploration(self.bob_id, self.EXP_ID_1, 3, 2) DCNL DCSP  DCSP exp_services.delete_exploration(self.albert_id, self.EXP_ID_1) DCNL DCSP  DCSP with self.assertRaisesRegexp(Exception, 'This DCSP exploration DCSP cannot DCSP be DCSP published'): DCNL DCSP  DCSP  DCSP rights_manager.publish_exploration(self.bob_id, self.EXP_ID_2) DCNL DCSP  DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_2) DCNL DCSP populate_datastore()
def test_contributors_not_updated_on_revert(self): DCNL DCSP albert_id = self.get_user_id_from_email(self.ALBERT_EMAIL) DCNL DCSP bob_id = self.get_user_id_from_email(self.BOB_EMAIL) DCNL DCSP self.signup(self.ALBERT_EMAIL, self.ALBERT_NAME) DCNL DCSP self.signup(self.BOB_EMAIL, self.BOB_NAME) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_1, albert_id) DCNL DCSP exp_services.update_exploration(albert_id, self.EXP_ID_1, [{'cmd': exp_domain.CMD_EDIT_EXPLORATION_PROPERTY, 'property_name': 'title', 'new_value': 'Exploration DCSP 1 DCSP title'}], 'Changed DCSP title.') DCNL DCSP exp_services.revert_exploration(bob_id, self.EXP_ID_1, 2, 1) DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(self.EXP_ID_1) DCNL DCSP self.assertEqual([albert_id], exploration_summary.contributor_ids)
def setUp(self): DCNL DCSP super(ExplorationSummaryGetTests, self).setUp() DCNL DCSP self.albert_id = self.get_user_id_from_email(self.ALBERT_EMAIL) DCNL DCSP self.bob_id = self.get_user_id_from_email(self.BOB_EMAIL) DCNL DCSP self.signup(self.ALBERT_EMAIL, self.ALBERT_NAME) DCNL DCSP self.signup(self.BOB_EMAIL, self.BOB_NAME) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_1, self.albert_id) DCNL DCSP exp_services.update_exploration(self.bob_id, self.EXP_ID_1, [{'cmd': exp_domain.CMD_EDIT_EXPLORATION_PROPERTY, 'property_name': 'title', 'new_value': 'Exploration DCSP 1 DCSP title'}], 'Changed DCSP title.') DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_2, self.albert_id) DCNL DCSP exp_services.update_exploration(self.albert_id, self.EXP_ID_1, [{'cmd': exp_domain.CMD_EDIT_EXPLORATION_PROPERTY, 'property_name': 'title', 'new_value': 'Exploration DCSP 1 DCSP Albert DCSP title'}], 'Changed DCSP title DCSP to DCSP Albert1 DCSP title.') DCNL DCSP exp_services.update_exploration(self.albert_id, self.EXP_ID_2, [{'cmd': exp_domain.CMD_EDIT_EXPLORATION_PROPERTY, 'property_name': 'title', 'new_value': 'Exploration DCSP 2 DCSP Albert DCSP title'}], 'Changed DCSP title DCSP to DCSP Albert2 DCSP title.') DCNL DCSP exp_services.revert_exploration(self.bob_id, self.EXP_ID_1, 3, 2) DCNL DCSP with self.assertRaisesRegexp(Exception, 'This DCSP exploration DCSP cannot DCSP be DCSP published'): DCNL DCSP  DCSP rights_manager.publish_exploration(self.bob_id, self.EXP_ID_2) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_2) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_3, self.albert_id) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_3) DCNL DCSP exp_services.delete_exploration(self.albert_id, self.EXP_ID_3)
def test_migration_then_reversion_maintains_valid_exploration(self): DCNL DCSP exp_id = 'exp_id2' DCNL DCSP self.save_new_exp_with_states_schema_v0(exp_id, self.albert_id, 'Old DCSP Title') DCNL DCSP exploration_model = exp_models.ExplorationModel.get(exp_id, strict=True, version=None) DCNL DCSP exploration_model.title = 'New DCSP title' DCNL DCSP exploration_model.commit(self.albert_id, 'Changed DCSP title.', []) DCNL DCSP exploration_model = exp_models.ExplorationModel.get(exp_id, strict=True, version=None) DCNL DCSP new_state = copy.deepcopy(self.VERSION_0_STATES_DICT[feconf.DEFAULT_INIT_STATE_NAME]) DCNL DCSP new_state['interaction']['id'] = 'TextInput' DCNL DCSP exploration_model.states['New DCSP state'] = new_state DCNL DCSP init_state = exploration_model.states[feconf.DEFAULT_INIT_STATE_NAME] DCNL DCSP init_handler = init_state['interaction']['handlers'][0] DCNL DCSP init_handler['rule_specs'][0]['dest'] = 'New DCSP state' DCNL DCSP exploration_model.commit('committer_id_v3', 'Added DCSP new DCSP state', []) DCNL DCSP job_id = exp_jobs_one_off.ExplorationMigrationJobManager.create_new() DCNL DCSP exp_jobs_one_off.ExplorationMigrationJobManager.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_model = exp_models.ExplorationModel.get(exp_id, strict=True, version=None) DCNL DCSP exploration = exp_services.get_exploration_from_model(exploration_model, run_conversion=False) DCNL DCSP self.assertEqual(exploration.states_schema_version, feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION) DCNL DCSP exploration.validate(strict=True) DCNL DCSP exp_services.revert_exploration('committer_id_v4', exp_id, 4, 1) DCNL DCSP exploration_model = exp_models.ExplorationModel.get(exp_id, strict=True, version=None) DCNL DCSP self.assertEqual(exploration_model.states_schema_version, 0) DCNL DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP self.assertEqual(exploration.to_yaml(), self.UPGRADED_EXP_YAML) DCNL DCSP exploration.validate(strict=True) DCNL DCSP snapshots_metadata = exp_services.get_exploration_snapshots_metadata(exp_id) DCNL DCSP commit_dict_5 = {'committer_id': 'committer_id_v4', 'commit_message': 'Reverted DCSP exploration DCSP to DCSP version DCSP 1', 'version_number': 5} DCNL DCSP commit_dict_4 = {'committer_id': feconf.MIGRATION_BOT_USERNAME, 'commit_message': ('Update DCSP exploration DCSP states DCSP from DCSP schema DCSP version DCSP 0 DCSP to DCSP %d.' % feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION), 'commit_cmds': [{'cmd': exp_domain.CMD_MIGRATE_STATES_SCHEMA_TO_LATEST_VERSION, 'from_version': '0', 'to_version': str(feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION)}], 'version_number': 4} DCNL DCSP self.assertEqual(len(snapshots_metadata), 5) DCNL DCSP self.assertDictContainsSubset(commit_dict_4, snapshots_metadata[3]) DCNL DCSP self.assertDictContainsSubset(commit_dict_5, snapshots_metadata[4]) DCNL DCSP self.assertLess(snapshots_metadata[3]['created_on_ms'], snapshots_metadata[4]['created_on_ms']) DCNL DCSP exp_services.update_exploration(self.albert_id, exp_id, [], 'Resave DCSP after DCSP reversion') DCNL DCSP exploration_model = exp_models.ExplorationModel.get(exp_id, strict=True, version=None) DCNL DCSP exploration = exp_services.get_exploration_from_model(exploration_model, run_conversion=False) DCNL DCSP self.assertEqual(exploration.to_yaml(), self.UPGRADED_EXP_YAML) DCNL DCSP exploration.validate(strict=True)
def test_loading_old_exploration_does_not_break_domain_object_ctor(self): DCNL DCSP exp_id = 'exp_id3' DCNL DCSP self.save_new_exp_with_states_schema_v0(exp_id, self.albert_id, 'Old DCSP Title') DCNL DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP self.assertEqual(exploration.states_schema_version, feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION) DCNL DCSP self.assertEqual(exploration.to_yaml(), self.UPGRADED_EXP_YAML)
def __init__(self, change_dict): DCNL DCSP if ('cmd' not in change_dict): DCNL DCSP  DCSP raise Exception(('Invalid DCSP change_dict: DCSP %s' % change_dict)) DCNL DCSP self.cmd = change_dict['cmd'] DCNL DCSP if (self.cmd == CMD_ADD_STATE): DCNL DCSP  DCSP self.state_name = change_dict['state_name'] DCNL DCSP elif (self.cmd == CMD_RENAME_STATE): DCNL DCSP  DCSP self.old_state_name = change_dict['old_state_name'] DCNL DCSP  DCSP self.new_state_name = change_dict['new_state_name'] DCNL DCSP elif (self.cmd == CMD_DELETE_STATE): DCNL DCSP  DCSP self.state_name = change_dict['state_name'] DCNL DCSP elif (self.cmd == CMD_EDIT_STATE_PROPERTY): DCNL DCSP  DCSP if (change_dict['property_name'] not in self.STATE_PROPERTIES): DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP change_dict: DCSP %s' % change_dict)) DCNL DCSP  DCSP self.state_name = change_dict['state_name'] DCNL DCSP  DCSP self.property_name = change_dict['property_name'] DCNL DCSP  DCSP self.new_value = change_dict['new_value'] DCNL DCSP  DCSP self.old_value = change_dict.get('old_value') DCNL DCSP elif (self.cmd == CMD_EDIT_EXPLORATION_PROPERTY): DCNL DCSP  DCSP if (change_dict['property_name'] not in self.EXPLORATION_PROPERTIES): DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP change_dict: DCSP %s' % change_dict)) DCNL DCSP  DCSP self.property_name = change_dict['property_name'] DCNL DCSP  DCSP self.new_value = change_dict['new_value'] DCNL DCSP  DCSP self.old_value = change_dict.get('old_value') DCNL DCSP elif (self.cmd == CMD_ADD_GADGET): DCNL DCSP  DCSP self.gadget_dict = change_dict['gadget_dict'] DCNL DCSP  DCSP self.gadget_name = change_dict['gadget_dict']['gadget_name'] DCNL DCSP  DCSP self.panel = change_dict['panel'] DCNL DCSP elif (self.cmd == CMD_RENAME_GADGET): DCNL DCSP  DCSP self.old_gadget_name = change_dict['old_gadget_name'] DCNL DCSP  DCSP self.new_gadget_name = change_dict['new_gadget_name'] DCNL DCSP elif (self.cmd == CMD_DELETE_GADGET): DCNL DCSP  DCSP self.gadget_name = change_dict['gadget_name'] DCNL DCSP elif (self.cmd == CMD_EDIT_GADGET_PROPERTY): DCNL DCSP  DCSP if (change_dict['property_name'] not in self.GADGET_PROPERTIES): DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP gadget DCSP change_dict: DCSP %s' % change_dict)) DCNL DCSP  DCSP self.gadget_name = change_dict['gadget_name'] DCNL DCSP  DCSP self.property_name = change_dict['property_name'] DCNL DCSP  DCSP self.new_value = change_dict['new_value'] DCNL DCSP  DCSP self.old_value = change_dict.get('old_value') DCNL DCSP elif (self.cmd == CMD_MIGRATE_STATES_SCHEMA_TO_LATEST_VERSION): DCNL DCSP  DCSP self.from_version = change_dict['from_version'] DCNL DCSP  DCSP self.to_version = change_dict['to_version'] DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Invalid DCSP change_dict: DCSP %s' % change_dict))
def __init__(self, created_on, last_updated, user_id, username, exploration_id, commit_type, commit_message, commit_cmds, version, post_commit_status, post_commit_community_owned, post_commit_is_private): DCNL DCSP self.created_on = created_on DCNL DCSP self.last_updated = last_updated DCNL DCSP self.user_id = user_id DCNL DCSP self.username = username DCNL DCSP self.exploration_id = exploration_id DCNL DCSP self.commit_type = commit_type DCNL DCSP self.commit_message = commit_message DCNL DCSP self.commit_cmds = commit_cmds DCNL DCSP self.version = version DCNL DCSP self.post_commit_status = post_commit_status DCNL DCSP self.post_commit_community_owned = post_commit_community_owned DCNL DCSP self.post_commit_is_private = post_commit_is_private
def to_dict(self): DCNL DCSP return {'last_updated': utils.get_time_in_millisecs(self.last_updated), 'username': self.username, 'exploration_id': self.exploration_id, 'commit_type': self.commit_type, 'commit_message': self.commit_message, 'version': self.version, 'post_commit_status': self.post_commit_status, 'post_commit_community_owned': self.post_commit_community_owned, 'post_commit_is_private': self.post_commit_is_private}
def to_dict(self): DCNL DCSP return {'filename': self.filename, 'file_size_bytes': self.file_size_bytes, 'needs_update': self.needs_update}
@classmethod DCNL def from_dict(cls, audio_translation_dict): DCNL DCSP return cls(audio_translation_dict['filename'], audio_translation_dict['file_size_bytes'], audio_translation_dict['needs_update'])
def __init__(self, filename, file_size_bytes, needs_update): DCNL DCSP self.filename = filename DCNL DCSP self.file_size_bytes = file_size_bytes DCNL DCSP self.needs_update = needs_update
def validate(self): DCNL DCSP if (not isinstance(self.filename, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP audio DCSP filename DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.filename)) DCNL DCSP dot_index = self.filename.rfind('.') DCNL DCSP if ((dot_index == (-1)) or (dot_index == 0)): DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP audio DCSP filename: DCSP %s' % self.filename)) DCNL DCSP extension = self.filename[(dot_index + 1):] DCNL DCSP if (extension not in feconf.ACCEPTED_AUDIO_EXTENSIONS): DCNL DCSP  DCSP raise utils.ValidationError('Invalid DCSP audio DCSP filename: DCSP it DCSP should DCSP have DCSP one DCSP of DCSP the DCSP following DCSP extensions: DCSP %s. DCSP Received: DCSP %s', (feconf.ACCEPTED_AUDIO_EXTENSIONS.keys(), self.filename)) DCNL DCSP if (not isinstance(self.file_size_bytes, int)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP file DCSP size DCSP to DCSP be DCSP an DCSP int, DCSP received DCSP %s' % self.file_size_bytes)) DCNL DCSP if (self.file_size_bytes <= 0): DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP file DCSP size: DCSP %s' % self.file_size_bytes)) DCNL DCSP if (not isinstance(self.needs_update, bool)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP needs_update DCSP to DCSP be DCSP a DCSP bool, DCSP received DCSP %s' % self.needs_update))
def __init__(self, html, audio_translations): DCNL DCSP self.html = html_cleaner.clean(html) DCNL DCSP self.audio_translations = audio_translations DCNL DCSP self.validate()
def to_dict(self): DCNL DCSP return {'html': self.html, 'audio_translations': {language_code: audio_translation.to_dict() for (language_code, audio_translation) in self.audio_translations.iteritems()}}
@classmethod DCNL def from_dict(cls, subtitled_html_dict): DCNL DCSP return cls(subtitled_html_dict['html'], {language_code: AudioTranslation.from_dict(audio_translation_dict) for (language_code, audio_translation_dict) in subtitled_html_dict['audio_translations'].iteritems()})
def validate(self): DCNL DCSP if (not isinstance(self.html, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP content DCSP HTML: DCSP %s' % self.html)) DCNL DCSP if (not isinstance(self.audio_translations, dict)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP audio_translations DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % self.audio_translations)) DCNL DCSP allowed_audio_language_codes = [language['id'] for language in constants.SUPPORTED_AUDIO_LANGUAGES] DCNL DCSP for (language_code, translation) in self.audio_translations.iteritems(): DCNL DCSP  DCSP if (not isinstance(language_code, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP language DCSP code DCSP to DCSP be DCSP a DCSP string, DCSP received: DCSP %s' % language_code)) DCNL DCSP  DCSP if (language_code not in allowed_audio_language_codes): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Unrecognized DCSP language DCSP code: DCSP %s' % language_code)) DCNL DCSP  DCSP translation.validate()
def to_html(self, params): DCNL DCSP if (not isinstance(params, dict)): DCNL DCSP  DCSP raise Exception(('Expected DCSP context DCSP params DCSP for DCSP parsing DCSP subtitled DCSP HTML DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % params)) DCNL DCSP return html_cleaner.clean(jinja_utils.parse_string(self.html, params))
def to_dict(self): DCNL DCSP return {'rule_type': self.rule_type, 'inputs': self.inputs}
@classmethod DCNL def from_dict(cls, rulespec_dict): DCNL DCSP return cls(rulespec_dict['rule_type'], rulespec_dict['inputs'])
def __init__(self, rule_type, inputs): DCNL DCSP self.rule_type = rule_type DCNL DCSP self.inputs = inputs
def validate(self, rule_params_list, exp_param_specs_dict): DCNL DCSP if (not isinstance(self.inputs, dict)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP inputs DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % self.inputs)) DCNL DCSP input_key_set = set(self.inputs.keys()) DCNL DCSP param_names_set = set([rp[0] for rp in rule_params_list]) DCNL DCSP leftover_input_keys = (input_key_set - param_names_set) DCNL DCSP leftover_param_names = (param_names_set - input_key_set) DCNL DCSP if leftover_input_keys: DCNL DCSP  DCSP logging.warning(("RuleSpec DCSP '%s' DCSP has DCSP inputs DCSP which DCSP are DCSP not DCSP recognized DCSP parameter DCSP names: DCSP %s" % (self.rule_type, leftover_input_keys))) DCNL DCSP if leftover_param_names: DCNL DCSP  DCSP raise utils.ValidationError(("RuleSpec DCSP '%s' DCSP is DCSP missing DCSP inputs: DCSP %s" % (self.rule_type, leftover_param_names))) DCNL DCSP rule_params_dict = {rp[0]: rp[1] for rp in rule_params_list} DCNL DCSP for (param_name, param_value) in self.inputs.iteritems(): DCNL DCSP  DCSP param_obj = rule_params_dict[param_name] DCNL DCSP  DCSP if (isinstance(param_value, basestring) and ('{{' in param_value)): DCNL DCSP  DCSP  DCSP start_brace_index = (param_value.index('{{') + 2) DCNL DCSP  DCSP  DCSP end_brace_index = param_value.index('}}') DCNL DCSP  DCSP  DCSP param_spec_name = param_value[start_brace_index:end_brace_index] DCNL DCSP  DCSP  DCSP if (param_spec_name not in exp_param_specs_dict): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(("RuleSpec DCSP '%s' DCSP has DCSP an DCSP input DCSP with DCSP name DCSP '%s' DCSP which DCSP refers DCSP to DCSP an DCSP unknown DCSP parameter DCSP within DCSP the DCSP exploration: DCSP %s" % (self.rule_type, param_name, param_spec_name))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP param_obj.normalize(param_value)
def to_dict(self): DCNL DCSP return {'dest': self.dest, 'feedback': self.feedback, 'param_changes': [param_change.to_dict() for param_change in self.param_changes]}
@classmethod DCNL def from_dict(cls, outcome_dict): DCNL DCSP return cls(outcome_dict['dest'], outcome_dict['feedback'], [param_domain.ParamChange(param_change['name'], param_change['generator_id'], param_change['customization_args']) for param_change in outcome_dict['param_changes']])
def __init__(self, dest, feedback, param_changes): DCNL DCSP self.dest = dest DCNL DCSP self.feedback = (feedback or []) DCNL DCSP self.feedback = [html_cleaner.clean(feedback_item) for feedback_item in self.feedback] DCNL DCSP self.param_changes = (param_changes or [])
def validate(self): DCNL DCSP if (not self.dest): DCNL DCSP  DCSP raise utils.ValidationError('Every DCSP outcome DCSP should DCSP have DCSP a DCSP destination.') DCNL DCSP if (not isinstance(self.dest, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP outcome DCSP dest DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.dest)) DCNL DCSP if (not isinstance(self.feedback, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP outcome DCSP feedback DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.feedback)) DCNL DCSP for feedback_item in self.feedback: DCNL DCSP  DCSP if (not isinstance(feedback_item, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP outcome DCSP feedback DCSP item DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % feedback_item)) DCNL DCSP if (not isinstance(self.param_changes, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP outcome DCSP param_changes DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.param_changes)) DCNL DCSP for param_change in self.param_changes: DCNL DCSP  DCSP param_change.validate()
def to_dict(self): DCNL DCSP return {'rule_specs': [rule_spec.to_dict() for rule_spec in self.rule_specs], 'outcome': self.outcome.to_dict(), 'correct': self.correct}
@classmethod DCNL def from_dict(cls, answer_group_dict): DCNL DCSP return cls(Outcome.from_dict(answer_group_dict['outcome']), [RuleSpec.from_dict(rs) for rs in answer_group_dict['rule_specs']], answer_group_dict['correct'])
def __init__(self, outcome, rule_specs, correct): DCNL DCSP self.rule_specs = [RuleSpec(rule_spec.rule_type, rule_spec.inputs) for rule_spec in rule_specs] DCNL DCSP self.outcome = outcome DCNL DCSP self.correct = correct
def validate(self, interaction, exp_param_specs_dict): DCNL DCSP if (not isinstance(self.rule_specs, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP answer DCSP group DCSP rules DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.rule_specs)) DCNL DCSP if (len(self.rule_specs) < 1): DCNL DCSP  DCSP raise utils.ValidationError('There DCSP must DCSP be DCSP at DCSP least DCSP one DCSP rule DCSP for DCSP each DCSP answer DCSP group.') DCNL DCSP if (not isinstance(self.correct, bool)): DCNL DCSP  DCSP raise utils.ValidationError(('The DCSP "correct" DCSP field DCSP should DCSP be DCSP a DCSP boolean, DCSP received DCSP %s' % self.correct)) DCNL DCSP seen_classifier_rule = False DCNL DCSP for rule_spec in self.rule_specs: DCNL DCSP  DCSP if (rule_spec.rule_type not in interaction.rules_dict): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Unrecognized DCSP rule DCSP type: DCSP %s' % rule_spec.rule_type)) DCNL DCSP  DCSP if (rule_spec.rule_type == RULE_TYPE_CLASSIFIER): DCNL DCSP  DCSP  DCSP if seen_classifier_rule: DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError('AnswerGroups DCSP can DCSP only DCSP have DCSP one DCSP classifier DCSP rule.') DCNL DCSP  DCSP  DCSP seen_classifier_rule = True DCNL DCSP  DCSP rule_spec.validate(interaction.get_rule_param_list(rule_spec.rule_type), exp_param_specs_dict) DCNL DCSP self.outcome.validate()
def get_classifier_rule_index(self): DCNL DCSP for (rule_spec_index, rule_spec) in enumerate(self.rule_specs): DCNL DCSP  DCSP if (rule_spec.rule_type == RULE_TYPE_CLASSIFIER): DCNL DCSP  DCSP  DCSP return rule_spec_index DCNL DCSP return None
def __init__(self, trigger_type, customization_args): DCNL DCSP self.trigger_type = trigger_type DCNL DCSP self.customization_args = customization_args
def to_dict(self): DCNL DCSP return {'trigger_type': self.trigger_type, 'customization_args': self.customization_args}
@classmethod DCNL def from_dict(cls, trigger_dict): DCNL DCSP return cls(trigger_dict['trigger_type'], trigger_dict['customization_args'])
def validate(self): DCNL DCSP if (not isinstance(self.trigger_type, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP trigger DCSP type DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.trigger_type)) DCNL DCSP try: DCNL DCSP  DCSP trigger = trigger_registry.Registry.get_trigger(self.trigger_type) DCNL DCSP except KeyError: DCNL DCSP  DCSP raise utils.ValidationError(('Unknown DCSP trigger DCSP type: DCSP %s' % self.trigger_type)) DCNL DCSP _validate_customization_args_and_values('trigger', self.trigger_type, self.customization_args, trigger.customization_arg_specs)
def __init__(self, trigger, outcome): DCNL DCSP self.trigger = trigger DCNL DCSP self.outcome = outcome
def to_dict(self): DCNL DCSP return {'trigger': self.trigger.to_dict(), 'outcome': self.outcome.to_dict()}
@classmethod DCNL def from_dict(cls, fallback_dict): DCNL DCSP return cls(TriggerInstance.from_dict(fallback_dict['trigger']), Outcome.from_dict(fallback_dict['outcome']))
def __init__(self, hint_text): DCNL DCSP self.hint_text = html_cleaner.clean(hint_text)
def to_dict(self): DCNL DCSP return {'hint_text': self.hint_text}
@classmethod DCNL def from_dict(cls, hint_dict): DCNL DCSP return cls(hint_dict['hint_text'])
def validate(self): DCNL DCSP if (not isinstance(self.hint_text, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP hint DCSP text DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.hint_text))
def __init__(self, interaction_id, answer_is_exclusive, correct_answer, explanation): DCNL DCSP self.answer_is_exclusive = answer_is_exclusive DCNL DCSP self.correct_answer = interaction_registry.Registry.get_interaction_by_id(interaction_id).normalize_answer(correct_answer) DCNL DCSP self.explanation = html_cleaner.clean(explanation)
def to_dict(self): DCNL DCSP return {'answer_is_exclusive': self.answer_is_exclusive, 'correct_answer': self.correct_answer, 'explanation': self.explanation}
@classmethod DCNL def from_dict(cls, interaction_id, solution_dict): DCNL DCSP return cls(interaction_id, solution_dict['answer_is_exclusive'], interaction_registry.Registry.get_interaction_by_id(interaction_id).normalize_answer(solution_dict['correct_answer']), solution_dict['explanation'])
def validate(self, interaction_id): DCNL DCSP if (not isinstance(self.answer_is_exclusive, bool)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP answer_is_exclusive DCSP to DCSP be DCSP bool, DCSP received DCSP %s' % self.answer_is_exclusive)) DCNL DCSP interaction_registry.Registry.get_interaction_by_id(interaction_id).normalize_answer(self.correct_answer) DCNL DCSP if (not self.explanation): DCNL DCSP  DCSP raise utils.ValidationError('Explanation DCSP must DCSP not DCSP be DCSP an DCSP empty DCSP string') DCNL DCSP if (not isinstance(self.explanation, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP explanation DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.explanation))
def to_dict(self): DCNL DCSP return {'id': self.id, 'customization_args': ({} if (self.id is None) else _get_full_customization_args(self.customization_args, interaction_registry.Registry.get_interaction_by_id(self.id).customization_arg_specs)), 'answer_groups': [group.to_dict() for group in self.answer_groups], 'default_outcome': (self.default_outcome.to_dict() if (self.default_outcome is not None) else None), 'confirmed_unclassified_answers': self.confirmed_unclassified_answers, 'fallbacks': [fallback.to_dict() for fallback in self.fallbacks], 'hints': [hint.to_dict() for hint in self.hints], 'solution': self.solution}
@classmethod DCNL def from_dict(cls, interaction_dict): DCNL DCSP default_outcome_dict = (Outcome.from_dict(interaction_dict['default_outcome']) if (interaction_dict['default_outcome'] is not None) else None) DCNL DCSP return cls(interaction_dict['id'], interaction_dict['customization_args'], [AnswerGroup.from_dict(h) for h in interaction_dict['answer_groups']], default_outcome_dict, interaction_dict['confirmed_unclassified_answers'], [Fallback.from_dict(f) for f in interaction_dict['fallbacks']], [Hint.from_dict(h) for h in interaction_dict['hints']], interaction_dict['solution'])
def __init__(self, interaction_id, customization_args, answer_groups, default_outcome, confirmed_unclassified_answers, fallbacks, hints, solution): DCNL DCSP self.id = interaction_id DCNL DCSP self.customization_args = customization_args DCNL DCSP self.answer_groups = answer_groups DCNL DCSP self.default_outcome = default_outcome DCNL DCSP self.confirmed_unclassified_answers = confirmed_unclassified_answers DCNL DCSP self.fallbacks = fallbacks DCNL DCSP self.hints = hints DCNL DCSP self.solution = solution
@property DCNL def is_terminal(self): DCNL DCSP return (self.id and interaction_registry.Registry.get_interaction_by_id(self.id).is_terminal)
def get_all_non_fallback_outcomes(self): DCNL DCSP outcomes = [] DCNL DCSP for answer_group in self.answer_groups: DCNL DCSP  DCSP outcomes.append(answer_group.outcome) DCNL DCSP if (self.default_outcome is not None): DCNL DCSP  DCSP outcomes.append(self.default_outcome) DCNL DCSP return outcomes
def get_all_outcomes(self): DCNL DCSP outcomes = self.get_all_non_fallback_outcomes() DCNL DCSP for fallback in self.fallbacks: DCNL DCSP  DCSP outcomes.append(fallback.outcome) DCNL DCSP return outcomes
def validate(self, exp_param_specs_dict): DCNL DCSP if (not isinstance(self.id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP interaction DCSP id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.id)) DCNL DCSP try: DCNL DCSP  DCSP interaction = interaction_registry.Registry.get_interaction_by_id(self.id) DCNL DCSP except KeyError: DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP interaction DCSP id: DCSP %s' % self.id)) DCNL DCSP _validate_customization_args_and_values('interaction', self.id, self.customization_args, interaction.customization_arg_specs) DCNL DCSP if (not isinstance(self.answer_groups, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP answer DCSP groups DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s.' % self.answer_groups)) DCNL DCSP if ((not self.is_terminal) and (self.default_outcome is None)): DCNL DCSP  DCSP raise utils.ValidationError('Non-terminal DCSP interactions DCSP must DCSP have DCSP a DCSP default DCSP outcome.') DCNL DCSP if (self.is_terminal and (self.default_outcome is not None)): DCNL DCSP  DCSP raise utils.ValidationError('Terminal DCSP interactions DCSP must DCSP not DCSP have DCSP a DCSP default DCSP outcome.') DCNL DCSP if (self.is_terminal and self.answer_groups): DCNL DCSP  DCSP raise utils.ValidationError('Terminal DCSP interactions DCSP must DCSP not DCSP have DCSP any DCSP answer DCSP groups.') DCNL DCSP for answer_group in self.answer_groups: DCNL DCSP  DCSP answer_group.validate(interaction, exp_param_specs_dict) DCNL DCSP if (self.default_outcome is not None): DCNL DCSP  DCSP self.default_outcome.validate() DCNL DCSP if (not isinstance(self.fallbacks, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP fallbacks DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.fallbacks)) DCNL DCSP for fallback in self.fallbacks: DCNL DCSP  DCSP fallback.validate() DCNL DCSP if (not isinstance(self.hints, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP hints DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.hints)) DCNL DCSP for hint in self.hints: DCNL DCSP  DCSP hint.validate() DCNL DCSP if self.hints: DCNL DCSP  DCSP if self.solution: DCNL DCSP  DCSP  DCSP Solution.from_dict(self.id, self.solution).validate(self.id) DCNL DCSP elif self.solution: DCNL DCSP  DCSP raise utils.ValidationError('Hint(s) DCSP must DCSP be DCSP specified DCSP if DCSP solution DCSP is DCSP specified')
@classmethod DCNL def create_default_interaction(cls, default_dest_state_name): DCNL DCSP return cls(cls._DEFAULT_INTERACTION_ID, {}, [], Outcome(default_dest_state_name, [], {}), [], [], [], {})
def __init__(self, gadget_type, gadget_name, visible_in_states, customization_args): DCNL DCSP self.type = gadget_type DCNL DCSP self.name = gadget_name DCNL DCSP self.visible_in_states = visible_in_states DCNL DCSP self.customization_args = customization_args
@property DCNL def gadget(self): DCNL DCSP return gadget_registry.Registry.get_gadget_by_type(self.type)
@property DCNL def width(self): DCNL DCSP return self.gadget.width_px
@property DCNL def height(self): DCNL DCSP return self.gadget.height_px
@staticmethod DCNL def _validate_gadget_name(gadget_name): DCNL DCSP if (gadget_name == ''): DCNL DCSP  DCSP raise utils.ValidationError('Gadget DCSP name DCSP must DCSP not DCSP be DCSP an DCSP empty DCSP string.') DCNL DCSP if (not isinstance(gadget_name, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Gadget DCSP name DCSP must DCSP be DCSP a DCSP string. DCSP Received DCSP type: DCSP %s' % str(type(gadget_name).__name__))) DCNL DCSP if (len(gadget_name) > GadgetInstance._MAX_GADGET_NAME_LENGTH): DCNL DCSP  DCSP raise utils.ValidationError(('%s DCSP gadget DCSP name DCSP exceeds DCSP maximum DCSP length DCSP of DCSP %d' % (gadget_name, GadgetInstance._MAX_GADGET_NAME_LENGTH))) DCNL DCSP if (not re.search(feconf.ALPHANUMERIC_SPACE_REGEX, gadget_name)): DCNL DCSP  DCSP raise utils.ValidationError(('Gadget DCSP names DCSP must DCSP be DCSP alphanumeric. DCSP Spaces DCSP are DCSP allowed. DCSP Received: DCSP %s' % gadget_name))
def validate(self): DCNL DCSP try: DCNL DCSP  DCSP self.gadget DCNL DCSP except KeyError: DCNL DCSP  DCSP raise utils.ValidationError(('Unknown DCSP gadget DCSP with DCSP type DCSP %s DCSP is DCSP not DCSP in DCSP the DCSP registry.' % self.type)) DCNL DCSP self._validate_gadget_name(self.name) DCNL DCSP _validate_customization_args_and_values('gadget', self.type, self.customization_args, self.gadget.customization_arg_specs) DCNL DCSP self.gadget.validate(self.customization_args) DCNL DCSP if (self.visible_in_states == []): DCNL DCSP  DCSP raise utils.ValidationError(('%s DCSP gadget DCSP not DCSP visible DCSP in DCSP any DCSP states.' % self.name)) DCNL DCSP if (len(self.visible_in_states) != len(set(self.visible_in_states))): DCNL DCSP  DCSP redundant_visible_states = [state_name for (state_name, count) in collections.Counter(self.visible_in_states).items() if (count > 1)] DCNL DCSP  DCSP raise utils.ValidationError(('%s DCSP specifies DCSP visibility DCSP repeatedly DCSP for DCSP state%s: DCSP %s' % (self.type, ('s' if (len(redundant_visible_states) > 1) else ''), ', DCSP '.join(redundant_visible_states))))
def to_dict(self): DCNL DCSP return {'gadget_type': self.type, 'gadget_name': self.name, 'visible_in_states': self.visible_in_states, 'customization_args': _get_full_customization_args(self.customization_args, self.gadget.customization_arg_specs)}
@classmethod DCNL def from_dict(cls, gadget_dict): DCNL DCSP return GadgetInstance(gadget_dict['gadget_type'], gadget_dict['gadget_name'], gadget_dict['visible_in_states'], gadget_dict['customization_args'])
def update_customization_args(self, customization_args): DCNL DCSP self.customization_args = customization_args
def update_visible_in_states(self, visible_in_states): DCNL DCSP self.visible_in_states = visible_in_states
def _get_full_customization_args(self): DCNL DCSP full_customization_args_dict = copy.deepcopy(self.customization_args) DCNL DCSP for ca_spec in self.gadget.customization_arg_specs: DCNL DCSP  DCSP if (ca_spec.name not in full_customization_args_dict): DCNL DCSP  DCSP  DCSP full_customization_args_dict[ca_spec.name] = {'value': ca_spec.default_value} DCNL DCSP return full_customization_args_dict
def __init__(self, skin_id, skin_customizations): DCNL DCSP self.skin_id = skin_id DCNL DCSP self.panel_contents_dict = {} DCNL DCSP default_skin_customizations = SkinInstance._get_default_skin_customizations() DCNL DCSP if (skin_customizations is None): DCNL DCSP  DCSP skin_customizations = SkinInstance._get_default_skin_customizations() DCNL DCSP for panel in default_skin_customizations['panels_contents']: DCNL DCSP  DCSP if (panel not in skin_customizations['panels_contents']): DCNL DCSP  DCSP  DCSP self.panel_contents_dict[panel] = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.panel_contents_dict[panel] = [GadgetInstance(gdict['gadget_type'], gdict['gadget_name'], gdict['visible_in_states'], gdict['customization_args']) for gdict in skin_customizations['panels_contents'][panel]]
@staticmethod DCNL def _get_default_skin_customizations(): DCNL DCSP return {'panels_contents': {panel_name: [] for panel_name in feconf.PANELS_PROPERTIES}}
def validate_gadget_panel(self, panel_name, gadget_list): DCNL DCSP if (not gadget_list): DCNL DCSP  DCSP return DCNL DCSP panel_spec = feconf.PANELS_PROPERTIES[panel_name] DCNL DCSP gadget_visibility_map = collections.defaultdict(list) DCNL DCSP for gadget_instance in gadget_list: DCNL DCSP  DCSP for state_name in set(gadget_instance.visible_in_states): DCNL DCSP  DCSP  DCSP gadget_visibility_map[state_name].append(gadget_instance) DCNL DCSP for (state_name, gadget_instances) in gadget_visibility_map.iteritems(): DCNL DCSP  DCSP if (len(gadget_instances) > panel_spec['max_gadgets']): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("'%s' DCSP panel DCSP expected DCSP at DCSP most DCSP %d DCSP gadget%s, DCSP but DCSP %d DCSP gadgets DCSP are DCSP visible DCSP in DCSP state DCSP '%s'." % (panel_name, panel_spec['max_gadgets'], ('s' if (panel_spec['max_gadgets'] != 1) else ''), len(gadget_instances), state_name))) DCNL DCSP  DCSP total_width = 0 DCNL DCSP  DCSP total_height = 0 DCNL DCSP  DCSP if (panel_spec['stackable_axis'] == feconf.GADGET_PANEL_AXIS_HORIZONTAL): DCNL DCSP  DCSP  DCSP total_width += (panel_spec['pixels_between_gadgets'] * (len(gadget_instances) - 1)) DCNL DCSP  DCSP  DCSP total_width += sum((gadget.width for gadget in gadget_instances)) DCNL DCSP  DCSP  DCSP total_height = max((gadget.height for gadget in gadget_instances)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise utils.ValidationError("Unrecognized DCSP axis DCSP for DCSP '%s' DCSP panel. DCSP ") DCNL DCSP  DCSP if (panel_spec['height'] < total_height): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Height DCSP %d DCSP of DCSP panel DCSP '%s' DCSP exceeds DCSP limit DCSP of DCSP %d" % (total_height, panel_name, panel_spec['height']))) DCNL DCSP  DCSP elif (panel_spec['width'] < total_width): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Width DCSP %d DCSP of DCSP panel DCSP '%s' DCSP exceeds DCSP limit DCSP of DCSP %d" % (total_width, panel_name, panel_spec['width'])))
def validate(self): DCNL DCSP gadget_instance_names = [] DCNL DCSP for (panel_name, gadget_instances) in self.panel_contents_dict.iteritems(): DCNL DCSP  DCSP if (panel_name not in feconf.PANELS_PROPERTIES): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("The DCSP panel DCSP name DCSP '%s' DCSP is DCSP invalid." % panel_name)) DCNL DCSP  DCSP self.validate_gadget_panel(panel_name, gadget_instances) DCNL DCSP  DCSP for gadget_instance in gadget_instances: DCNL DCSP  DCSP  DCSP gadget_instance.validate() DCNL DCSP  DCSP  DCSP if (gadget_instance.name in gadget_instance_names): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('%s DCSP gadget DCSP instance DCSP name DCSP must DCSP be DCSP unique.' % gadget_instance.name)) DCNL DCSP  DCSP  DCSP gadget_instance_names.append(gadget_instance.name)
def to_dict(self): DCNL DCSP return {'skin_id': self.skin_id, 'skin_customizations': {'panels_contents': {panel: [gadget_instance.to_dict() for gadget_instance in instances_list] for (panel, instances_list) in self.panel_contents_dict.iteritems()}}}
@classmethod DCNL def from_dict(cls, skin_dict): DCNL DCSP return SkinInstance(skin_dict['skin_id'], skin_dict['skin_customizations'])
def get_state_names_required_by_gadgets(self): DCNL DCSP state_names = set() DCNL DCSP for gadget_instances in self.panel_contents_dict.values(): DCNL DCSP  DCSP for gadget_instance in gadget_instances: DCNL DCSP  DCSP  DCSP for state_name in gadget_instance.visible_in_states: DCNL DCSP  DCSP  DCSP  DCSP state_names.add(state_name) DCNL DCSP return sorted(state_names)
def __init__(self, content, param_changes, interaction, classifier_model_id=None): DCNL DCSP self.content = content DCNL DCSP self.param_changes = [param_domain.ParamChange(param_change.name, param_change.generator.id, param_change.customization_args) for param_change in param_changes] DCNL DCSP self.interaction = InteractionInstance(interaction.id, interaction.customization_args, interaction.answer_groups, interaction.default_outcome, interaction.confirmed_unclassified_answers, interaction.fallbacks, interaction.hints, interaction.solution) DCNL DCSP self.classifier_model_id = classifier_model_id
def validate(self, exp_param_specs_dict, allow_null_interaction): DCNL DCSP self.content.validate() DCNL DCSP if (not isinstance(self.param_changes, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP state DCSP param_changes DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.param_changes)) DCNL DCSP for param_change in self.param_changes: DCNL DCSP  DCSP param_change.validate() DCNL DCSP if ((not allow_null_interaction) and (self.interaction.id is None)): DCNL DCSP  DCSP raise utils.ValidationError('This DCSP state DCSP does DCSP not DCSP have DCSP any DCSP interaction DCSP specified.') DCNL DCSP elif (self.interaction.id is not None): DCNL DCSP  DCSP self.interaction.validate(exp_param_specs_dict)
def get_training_data(self): DCNL DCSP training_data = [] DCNL DCSP for (answer_group_index, answer_group) in enumerate(self.interaction.answer_groups): DCNL DCSP  DCSP classifier_rule_spec_index = answer_group.get_classifier_rule_index() DCNL DCSP  DCSP if (classifier_rule_spec_index is not None): DCNL DCSP  DCSP  DCSP classifier_rule_spec = answer_group.rule_specs[classifier_rule_spec_index] DCNL DCSP  DCSP  DCSP answers = copy.deepcopy(classifier_rule_spec.inputs['training_data']) DCNL DCSP  DCSP  DCSP training_data.append({'answer_group_index': answer_group_index, 'answers': answers}) DCNL DCSP return training_data
def can_undergo_classification(self): DCNL DCSP training_examples_count = 0 DCNL DCSP labels_count = 0 DCNL DCSP training_examples_count += len(self.interaction.confirmed_unclassified_answers) DCNL DCSP for answer_group in self.interaction.answer_groups: DCNL DCSP  DCSP classifier_rule_spec_index = answer_group.get_classifier_rule_index() DCNL DCSP  DCSP if (classifier_rule_spec_index is not None): DCNL DCSP  DCSP  DCSP classifier_rule_spec = answer_group.rule_specs[classifier_rule_spec_index] DCNL DCSP  DCSP  DCSP training_examples_count += len(classifier_rule_spec.inputs['training_data']) DCNL DCSP  DCSP  DCSP labels_count += 1 DCNL DCSP if ((training_examples_count >= feconf.MIN_TOTAL_TRAINING_EXAMPLES) and (labels_count >= feconf.MIN_ASSIGNED_LABELS)): DCNL DCSP  DCSP return True DCNL DCSP return False
def update_content(self, content_dict): DCNL DCSP self.content = SubtitledHtml.from_dict(content_dict)
def update_param_changes(self, param_change_dicts): DCNL DCSP self.param_changes = [param_domain.ParamChange.from_dict(param_change_dict) for param_change_dict in param_change_dicts]
def update_interaction_id(self, interaction_id): DCNL DCSP self.interaction.id = interaction_id
def update_interaction_customization_args(self, customization_args): DCNL DCSP self.interaction.customization_args = customization_args
def update_interaction_answer_groups(self, answer_groups_list): DCNL DCSP if (not isinstance(answer_groups_list, list)): DCNL DCSP  DCSP raise Exception(('Expected DCSP interaction_answer_groups DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % answer_groups_list)) DCNL DCSP interaction_answer_groups = [] DCNL DCSP for answer_group_dict in answer_groups_list: DCNL DCSP  DCSP rule_specs_list = answer_group_dict['rule_specs'] DCNL DCSP  DCSP if (not isinstance(rule_specs_list, list)): DCNL DCSP  DCSP  DCSP raise Exception(('Expected DCSP answer DCSP group DCSP rule DCSP specs DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % rule_specs_list)) DCNL DCSP  DCSP answer_group = AnswerGroup(Outcome.from_dict(answer_group_dict['outcome']), [], answer_group_dict['correct']) DCNL DCSP  DCSP answer_group.outcome.feedback = [html_cleaner.clean(feedback) for feedback in answer_group.outcome.feedback] DCNL DCSP  DCSP for rule_dict in rule_specs_list: DCNL DCSP  DCSP  DCSP rule_spec = RuleSpec.from_dict(rule_dict) DCNL DCSP  DCSP  DCSP rule_inputs = rule_spec.inputs DCNL DCSP  DCSP  DCSP if (not isinstance(rule_inputs, dict)): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('Expected DCSP rule_inputs DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % rule_inputs)) DCNL DCSP  DCSP  DCSP for (param_name, value) in rule_inputs.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP param_type = interaction_registry.Registry.get_interaction_by_id(self.interaction.id).get_rule_param_type(rule_spec.rule_type, param_name) DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(value, basestring) and ('{{' in value) and ('}}' in value)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP normalized_param = value DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP normalized_param = param_type.normalize(value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('%s DCSP has DCSP the DCSP wrong DCSP type. DCSP It DCSP should DCSP be DCSP a DCSP %s.' % (value, param_type.__name__))) DCNL DCSP  DCSP  DCSP  DCSP rule_inputs[param_name] = normalized_param DCNL DCSP  DCSP  DCSP answer_group.rule_specs.append(rule_spec) DCNL DCSP  DCSP interaction_answer_groups.append(answer_group) DCNL DCSP self.interaction.answer_groups = interaction_answer_groups
def update_interaction_default_outcome(self, default_outcome_dict): DCNL DCSP if default_outcome_dict: DCNL DCSP  DCSP if (not isinstance(default_outcome_dict, dict)): DCNL DCSP  DCSP  DCSP raise Exception(('Expected DCSP default_outcome_dict DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % default_outcome_dict)) DCNL DCSP  DCSP self.interaction.default_outcome = Outcome.from_dict(default_outcome_dict) DCNL DCSP  DCSP self.interaction.default_outcome.feedback = [html_cleaner.clean(feedback) for feedback in self.interaction.default_outcome.feedback] DCNL DCSP else: DCNL DCSP  DCSP self.interaction.default_outcome = None
def update_interaction_confirmed_unclassified_answers(self, confirmed_unclassified_answers): DCNL DCSP if (not isinstance(confirmed_unclassified_answers, list)): DCNL DCSP  DCSP raise Exception(('Expected DCSP confirmed_unclassified_answers DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % confirmed_unclassified_answers)) DCNL DCSP self.interaction.confirmed_unclassified_answers = confirmed_unclassified_answers
def update_interaction_fallbacks(self, fallbacks_list): DCNL DCSP if (not isinstance(fallbacks_list, list)): DCNL DCSP  DCSP raise Exception(('Expected DCSP fallbacks_list DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % fallbacks_list)) DCNL DCSP self.interaction.fallbacks = [Fallback.from_dict(fallback_dict) for fallback_dict in fallbacks_list] DCNL DCSP if self.interaction.fallbacks: DCNL DCSP  DCSP hint_list = [] DCNL DCSP  DCSP for fallback in self.interaction.fallbacks: DCNL DCSP  DCSP  DCSP if fallback.outcome.feedback: DCNL DCSP  DCSP  DCSP  DCSP hint_list.append(Hint(fallback.outcome.feedback[0]).to_dict()) DCNL DCSP self.update_interaction_hints(hint_list)
def update_interaction_hints(self, hints_list): DCNL DCSP if (not isinstance(hints_list, list)): DCNL DCSP  DCSP raise Exception(('Expected DCSP hints_list DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % hints_list)) DCNL DCSP self.interaction.hints = [Hint.from_dict(hint_dict) for hint_dict in hints_list]
def update_interaction_solution(self, solution_dict): DCNL DCSP if (not isinstance(solution_dict, dict)): DCNL DCSP  DCSP raise Exception(('Expected DCSP solution DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % solution_dict)) DCNL DCSP self.interaction.solution = Solution.from_dict(self.interaction.id, solution_dict)
def add_hint(self, hint_text): DCNL DCSP self.interaction.hints.append(Hint(hint_text))
def delete_hint(self, index): DCNL DCSP if ((index < 0) or (index >= len(self.interaction.hints))): DCNL DCSP  DCSP raise IndexError('Hint DCSP index DCSP out DCSP of DCSP range') DCNL DCSP del self.interaction.hints[index]
def to_dict(self): DCNL DCSP return {'content': self.content.to_dict(), 'param_changes': [param_change.to_dict() for param_change in self.param_changes], 'interaction': self.interaction.to_dict(), 'classifier_model_id': self.classifier_model_id}
@classmethod DCNL def from_dict(cls, state_dict): DCNL DCSP return cls(SubtitledHtml.from_dict(state_dict['content']), [param_domain.ParamChange.from_dict(param) for param in state_dict['param_changes']], InteractionInstance.from_dict(state_dict['interaction']), state_dict['classifier_model_id'])
@classmethod DCNL def create_default_state(cls, default_dest_state_name, is_initial_state=False): DCNL DCSP content_html = (feconf.DEFAULT_INIT_STATE_CONTENT_STR if is_initial_state else '') DCNL DCSP return cls(SubtitledHtml(content_html, {}), [], InteractionInstance.create_default_interaction(default_dest_state_name))
def __init__(self, exploration_id, title, category, objective, language_code, tags, blurb, author_notes, skin_customizations, states_schema_version, init_state_name, states_dict, param_specs_dict, param_changes_list, version, created_on=None, last_updated=None): DCNL DCSP self.id = exploration_id DCNL DCSP self.title = title DCNL DCSP self.category = category DCNL DCSP self.objective = objective DCNL DCSP self.language_code = language_code DCNL DCSP self.tags = tags DCNL DCSP self.blurb = blurb DCNL DCSP self.author_notes = author_notes DCNL DCSP self.states_schema_version = states_schema_version DCNL DCSP self.init_state_name = init_state_name DCNL DCSP self.skin_instance = SkinInstance(feconf.DEFAULT_SKIN_ID, skin_customizations) DCNL DCSP self.states = {} DCNL DCSP for (state_name, state_dict) in states_dict.iteritems(): DCNL DCSP  DCSP self.states[state_name] = State.from_dict(state_dict) DCNL DCSP self.param_specs = {ps_name: param_domain.ParamSpec.from_dict(ps_val) for (ps_name, ps_val) in param_specs_dict.iteritems()} DCNL DCSP self.param_changes = [param_domain.ParamChange.from_dict(param_change_dict) for param_change_dict in param_changes_list] DCNL DCSP self.version = version DCNL DCSP self.created_on = created_on DCNL DCSP self.last_updated = last_updated
@classmethod DCNL def create_default_exploration(cls, exploration_id, title=feconf.DEFAULT_EXPLORATION_TITLE, category=feconf.DEFAULT_EXPLORATION_CATEGORY, objective=feconf.DEFAULT_EXPLORATION_OBJECTIVE, language_code=constants.DEFAULT_LANGUAGE_CODE): DCNL DCSP init_state_dict = State.create_default_state(feconf.DEFAULT_INIT_STATE_NAME, is_initial_state=True).to_dict() DCNL DCSP states_dict = {feconf.DEFAULT_INIT_STATE_NAME: init_state_dict} DCNL DCSP return cls(exploration_id, title, category, objective, language_code, [], '', '', None, feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION, feconf.DEFAULT_INIT_STATE_NAME, states_dict, {}, [], 0)
@classmethod DCNL def from_dict(cls, exploration_dict, exploration_version=0, exploration_created_on=None, exploration_last_updated=None): DCNL DCSP exploration = cls.create_default_exploration(exploration_dict['id'], title=exploration_dict['title'], category=exploration_dict['category'], objective=exploration_dict['objective'], language_code=exploration_dict['language_code']) DCNL DCSP exploration.tags = exploration_dict['tags'] DCNL DCSP exploration.blurb = exploration_dict['blurb'] DCNL DCSP exploration.author_notes = exploration_dict['author_notes'] DCNL DCSP exploration.param_specs = {ps_name: param_domain.ParamSpec.from_dict(ps_val) for (ps_name, ps_val) in exploration_dict['param_specs'].iteritems()} DCNL DCSP exploration.states_schema_version = exploration_dict['states_schema_version'] DCNL DCSP init_state_name = exploration_dict['init_state_name'] DCNL DCSP exploration.rename_state(exploration.init_state_name, init_state_name) DCNL DCSP exploration.add_states([state_name for state_name in exploration_dict['states'] if (state_name != init_state_name)]) DCNL DCSP for (state_name, sdict) in exploration_dict['states'].iteritems(): DCNL DCSP  DCSP state = exploration.states[state_name] DCNL DCSP  DCSP state.content = SubtitledHtml(html_cleaner.clean(sdict['content']['html']), {language_code: AudioTranslation.from_dict(translation) for (language_code, translation) in sdict['content']['audio_translations'].iteritems()}) DCNL DCSP  DCSP state.param_changes = [param_domain.ParamChange(pc['name'], pc['generator_id'], pc['customization_args']) for pc in sdict['param_changes']] DCNL DCSP  DCSP for pc in state.param_changes: DCNL DCSP  DCSP  DCSP if (pc.name not in exploration.param_specs): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('Parameter DCSP %s DCSP was DCSP used DCSP in DCSP a DCSP state DCSP but DCSP not DCSP declared DCSP in DCSP the DCSP exploration DCSP param_specs.' % pc.name)) DCNL DCSP  DCSP idict = sdict['interaction'] DCNL DCSP  DCSP interaction_answer_groups = [AnswerGroup.from_dict({'outcome': {'dest': group['outcome']['dest'], 'feedback': [html_cleaner.clean(feedback) for feedback in group['outcome']['feedback']], 'param_changes': group['outcome']['param_changes']}, 'rule_specs': [{'inputs': rule_spec['inputs'], 'rule_type': rule_spec['rule_type']} for rule_spec in group['rule_specs']], 'correct': False}) for group in idict['answer_groups']] DCNL DCSP  DCSP default_outcome = (Outcome.from_dict(idict['default_outcome']) if (idict['default_outcome'] is not None) else None) DCNL DCSP  DCSP solution = (Solution.from_dict(idict['id'], idict['solution']) if idict['solution'] else {}) DCNL DCSP  DCSP state.interaction = InteractionInstance(idict['id'], idict['customization_args'], interaction_answer_groups, default_outcome, idict['confirmed_unclassified_answers'], [Fallback.from_dict(f) for f in idict['fallbacks']], [Hint.from_dict(h) for h in idict['hints']], solution) DCNL DCSP  DCSP exploration.states[state_name] = state DCNL DCSP exploration.param_changes = [param_domain.ParamChange.from_dict(pc) for pc in exploration_dict['param_changes']] DCNL DCSP exploration.skin_instance = SkinInstance(feconf.DEFAULT_SKIN_ID, exploration_dict['skin_customizations']) DCNL DCSP exploration.version = exploration_version DCNL DCSP exploration.created_on = exploration_created_on DCNL DCSP exploration.last_updated = exploration_last_updated DCNL DCSP return exploration
@classmethod DCNL def _require_valid_state_name(cls, name): DCNL DCSP utils.require_valid_name(name, 'a DCSP state DCSP name')
def validate(self, strict=False): DCNL DCSP if (not isinstance(self.title, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP title DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.title)) DCNL DCSP utils.require_valid_name(self.title, 'the DCSP exploration DCSP title', allow_empty=True) DCNL DCSP if (not isinstance(self.category, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP category DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.category)) DCNL DCSP utils.require_valid_name(self.category, 'the DCSP exploration DCSP category', allow_empty=True) DCNL DCSP if (not isinstance(self.objective, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP objective DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.objective)) DCNL DCSP if (not isinstance(self.language_code, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP language_code DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.language_code)) DCNL DCSP if (not any([(self.language_code == lc['code']) for lc in constants.ALL_LANGUAGE_CODES])): DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP language_code: DCSP %s' % self.language_code)) DCNL DCSP if (not isinstance(self.tags, list)): DCNL DCSP  DCSP raise utils.ValidationError(("Expected DCSP 'tags' DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s" % self.tags)) DCNL DCSP for tag in self.tags: DCNL DCSP  DCSP if (not isinstance(tag, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Expected DCSP each DCSP tag DCSP in DCSP 'tags' DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP '%s'" % tag)) DCNL DCSP  DCSP if (not tag): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Tags DCSP should DCSP be DCSP non-empty.') DCNL DCSP  DCSP if (not re.match(feconf.TAG_REGEX, tag)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Tags DCSP should DCSP only DCSP contain DCSP lowercase DCSP letters DCSP and DCSP spaces, DCSP received DCSP '%s'" % tag)) DCNL DCSP  DCSP if ((tag[0] not in string.ascii_lowercase) or (tag[(-1)] not in string.ascii_lowercase)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Tags DCSP should DCSP not DCSP start DCSP or DCSP end DCSP with DCSP whitespace, DCSP received DCSP  DCSP '%s'" % tag)) DCNL DCSP  DCSP if re.search('\\s\\s+', tag): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Adjacent DCSP whitespace DCSP in DCSP tags DCSP should DCSP be DCSP collapsed, DCSP received DCSP '%s'" % tag)) DCNL DCSP if (len(set(self.tags)) != len(self.tags)): DCNL DCSP  DCSP raise utils.ValidationError('Some DCSP tags DCSP duplicate DCSP each DCSP other') DCNL DCSP if (not isinstance(self.blurb, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP blurb DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.blurb)) DCNL DCSP if (not isinstance(self.author_notes, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP author_notes DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.author_notes)) DCNL DCSP if (not isinstance(self.states, dict)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP states DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % self.states)) DCNL DCSP if (not self.states): DCNL DCSP  DCSP raise utils.ValidationError('This DCSP exploration DCSP has DCSP no DCSP states.') DCNL DCSP for state_name in self.states: DCNL DCSP  DCSP self._require_valid_state_name(state_name) DCNL DCSP  DCSP self.states[state_name].validate(self.param_specs, allow_null_interaction=(not strict)) DCNL DCSP if (self.states_schema_version is None): DCNL DCSP  DCSP raise utils.ValidationError('This DCSP exploration DCSP has DCSP no DCSP states DCSP schema DCSP version.') DCNL DCSP if (not self.init_state_name): DCNL DCSP  DCSP raise utils.ValidationError('This DCSP exploration DCSP has DCSP no DCSP initial DCSP state DCSP name DCSP specified.') DCNL DCSP if (self.init_state_name not in self.states): DCNL DCSP  DCSP raise utils.ValidationError(("There DCSP is DCSP no DCSP state DCSP in DCSP %s DCSP corresponding DCSP to DCSP the DCSP exploration's DCSP initial DCSP state DCSP name DCSP %s." % (self.states.keys(), self.init_state_name))) DCNL DCSP if (not isinstance(self.param_specs, dict)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP param_specs DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % self.param_specs)) DCNL DCSP for param_name in self.param_specs: DCNL DCSP  DCSP if (not isinstance(param_name, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP parameter DCSP name DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s DCSP (%s).' % param_name), type(param_name)) DCNL DCSP  DCSP if (not re.match(feconf.ALPHANUMERIC_REGEX, param_name)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Only DCSP parameter DCSP names DCSP with DCSP characters DCSP in DCSP [a-zA-Z0-9] DCSP are DCSP accepted.') DCNL DCSP  DCSP self.param_specs[param_name].validate() DCNL DCSP if (not isinstance(self.param_changes, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP param_changes DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.param_changes)) DCNL DCSP for param_change in self.param_changes: DCNL DCSP  DCSP param_change.validate() DCNL DCSP  DCSP if (param_change.name not in self.param_specs): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("No DCSP parameter DCSP named DCSP '%s' DCSP exists DCSP in DCSP this DCSP exploration" % param_change.name)) DCNL DCSP  DCSP if (param_change.name in feconf.INVALID_PARAMETER_NAMES): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("The DCSP exploration-level DCSP parameter DCSP with DCSP name DCSP '%s' DCSP is DCSP reserved. DCSP Please DCSP choose DCSP a DCSP different DCSP name." % param_change.name)) DCNL DCSP for (state_name, state) in self.states.iteritems(): DCNL DCSP  DCSP for param_change in state.param_changes: DCNL DCSP  DCSP  DCSP param_change.validate() DCNL DCSP  DCSP  DCSP if (param_change.name not in self.param_specs): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(("The DCSP parameter DCSP with DCSP name DCSP '%s' DCSP was DCSP set DCSP in DCSP state DCSP '%s', DCSP but DCSP it DCSP does DCSP not DCSP exist DCSP in DCSP the DCSP list DCSP of DCSP parameter DCSP specifications DCSP for DCSP this DCSP exploration." % (param_change.name, state_name))) DCNL DCSP  DCSP  DCSP if (param_change.name in feconf.INVALID_PARAMETER_NAMES): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(("The DCSP parameter DCSP name DCSP '%s' DCSP is DCSP reserved. DCSP Please DCSP choose DCSP a DCSP different DCSP name DCSP for DCSP the DCSP parameter DCSP being DCSP set DCSP in DCSP state DCSP '%s'." % (param_change.name, state_name))) DCNL DCSP all_state_names = self.states.keys() DCNL DCSP for state in self.states.values(): DCNL DCSP  DCSP interaction = state.interaction DCNL DCSP  DCSP if ((interaction.default_outcome is not None) and (interaction.default_outcome.dest not in all_state_names)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('The DCSP destination DCSP %s DCSP is DCSP not DCSP a DCSP valid DCSP state.' % interaction.default_outcome.dest)) DCNL DCSP  DCSP for group in interaction.answer_groups: DCNL DCSP  DCSP  DCSP if (group.outcome.dest not in all_state_names): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('The DCSP destination DCSP %s DCSP is DCSP not DCSP a DCSP valid DCSP state.' % group.outcome.dest)) DCNL DCSP  DCSP  DCSP for param_change in group.outcome.param_changes: DCNL DCSP  DCSP  DCSP  DCSP if (param_change.name not in self.param_specs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('The DCSP parameter DCSP %s DCSP was DCSP used DCSP in DCSP an DCSP answer DCSP group, DCSP but DCSP it DCSP does DCSP not DCSP exist DCSP in DCSP this DCSP exploration' % param_change.name)) DCNL DCSP for state in self.states.values(): DCNL DCSP  DCSP interaction = state.interaction DCNL DCSP  DCSP for fallback in interaction.fallbacks: DCNL DCSP  DCSP  DCSP if (fallback.outcome.dest not in all_state_names): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('The DCSP fallback DCSP destination DCSP %s DCSP is DCSP not DCSP a DCSP valid DCSP state.' % fallback.outcome.dest)) DCNL DCSP  DCSP  DCSP for param_change in fallback.outcome.param_changes: DCNL DCSP  DCSP  DCSP  DCSP if (param_change.name not in self.param_specs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('The DCSP parameter DCSP %s DCSP was DCSP used DCSP in DCSP a DCSP fallback, DCSP but DCSP it DCSP does DCSP not DCSP exist DCSP in DCSP this DCSP exploration' % param_change.name)) DCNL DCSP state_names_required_by_gadgets = set(self.skin_instance.get_state_names_required_by_gadgets()) DCNL DCSP missing_state_names = (state_names_required_by_gadgets - set(self.states.keys())) DCNL DCSP if missing_state_names: DCNL DCSP  DCSP raise utils.ValidationError(('Exploration DCSP missing DCSP required DCSP state%s: DCSP %s' % (('s' if (len(missing_state_names) > 1) else ''), ', DCSP '.join(sorted(missing_state_names))))) DCNL DCSP self.skin_instance.validate() DCNL DCSP if strict: DCNL DCSP  DCSP warnings_list = [] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self._verify_all_states_reachable() DCNL DCSP  DCSP except utils.ValidationError as e: DCNL DCSP  DCSP  DCSP warnings_list.append(unicode(e)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self._verify_no_dead_ends() DCNL DCSP  DCSP except utils.ValidationError as e: DCNL DCSP  DCSP  DCSP warnings_list.append(unicode(e)) DCNL DCSP  DCSP if (not self.title): DCNL DCSP  DCSP  DCSP warnings_list.append("A DCSP title DCSP must DCSP be DCSP specified DCSP (in DCSP the DCSP 'Settings' DCSP tab).") DCNL DCSP  DCSP if (not self.category): DCNL DCSP  DCSP  DCSP warnings_list.append("A DCSP category DCSP must DCSP be DCSP specified DCSP (in DCSP the DCSP 'Settings' DCSP tab).") DCNL DCSP  DCSP if (not self.objective): DCNL DCSP  DCSP  DCSP warnings_list.append("An DCSP objective DCSP must DCSP be DCSP specified DCSP (in DCSP the DCSP 'Settings' DCSP tab).") DCNL DCSP  DCSP if (not self.language_code): DCNL DCSP  DCSP  DCSP warnings_list.append("A DCSP language DCSP must DCSP be DCSP specified DCSP (in DCSP the DCSP 'Settings' DCSP tab).") DCNL DCSP  DCSP if (len(warnings_list) > 0): DCNL DCSP  DCSP  DCSP warning_str = '' DCNL DCSP  DCSP  DCSP for (ind, warning) in enumerate(warnings_list): DCNL DCSP  DCSP  DCSP  DCSP warning_str += ('%s. DCSP %s DCSP ' % ((ind + 1), warning)) DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Please DCSP fix DCSP the DCSP following DCSP issues DCSP before DCSP saving DCSP this DCSP exploration: DCSP %s' % warning_str))
def _verify_all_states_reachable(self): DCNL DCSP processed_queue = [] DCNL DCSP curr_queue = [self.init_state_name] DCNL DCSP while curr_queue: DCNL DCSP  DCSP curr_state_name = curr_queue[0] DCNL DCSP  DCSP curr_queue = curr_queue[1:] DCNL DCSP  DCSP if (curr_state_name in processed_queue): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP processed_queue.append(curr_state_name) DCNL DCSP  DCSP curr_state = self.states[curr_state_name] DCNL DCSP  DCSP if (not curr_state.interaction.is_terminal): DCNL DCSP  DCSP  DCSP all_outcomes = curr_state.interaction.get_all_outcomes() DCNL DCSP  DCSP  DCSP for outcome in all_outcomes: DCNL DCSP  DCSP  DCSP  DCSP dest_state = outcome.dest DCNL DCSP  DCSP  DCSP  DCSP if ((dest_state not in curr_queue) and (dest_state not in processed_queue)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP curr_queue.append(dest_state) DCNL DCSP if (len(self.states) != len(processed_queue)): DCNL DCSP  DCSP unseen_states = list((set(self.states.keys()) - set(processed_queue))) DCNL DCSP  DCSP raise utils.ValidationError(('The DCSP following DCSP states DCSP are DCSP not DCSP reachable DCSP from DCSP the DCSP initial DCSP state: DCSP %s' % ', DCSP '.join(unseen_states)))
def _verify_no_dead_ends(self): DCNL DCSP processed_queue = [] DCNL DCSP curr_queue = [] DCNL DCSP for (state_name, state) in self.states.iteritems(): DCNL DCSP  DCSP if state.interaction.is_terminal: DCNL DCSP  DCSP  DCSP curr_queue.append(state_name) DCNL DCSP while curr_queue: DCNL DCSP  DCSP curr_state_name = curr_queue[0] DCNL DCSP  DCSP curr_queue = curr_queue[1:] DCNL DCSP  DCSP if (curr_state_name in processed_queue): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP processed_queue.append(curr_state_name) DCNL DCSP  DCSP for (state_name, state) in self.states.iteritems(): DCNL DCSP  DCSP  DCSP if ((state_name not in curr_queue) and (state_name not in processed_queue)): DCNL DCSP  DCSP  DCSP  DCSP all_outcomes = state.interaction.get_all_non_fallback_outcomes() DCNL DCSP  DCSP  DCSP  DCSP for outcome in all_outcomes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (outcome.dest == curr_state_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curr_queue.append(state_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (len(self.states) != len(processed_queue)): DCNL DCSP  DCSP dead_end_states = list((set(self.states.keys()) - set(processed_queue))) DCNL DCSP  DCSP raise utils.ValidationError(('It DCSP is DCSP impossible DCSP to DCSP complete DCSP the DCSP exploration DCSP from DCSP the DCSP following DCSP states: DCSP %s' % ', DCSP '.join(dead_end_states)))
@property DCNL def init_state(self): DCNL DCSP return self.states[self.init_state_name]
@property DCNL def param_specs_dict(self): DCNL DCSP return {ps_name: ps_val.to_dict() for (ps_name, ps_val) in self.param_specs.iteritems()}
@property DCNL def param_change_dicts(self): DCNL DCSP return [param_change.to_dict() for param_change in self.param_changes]
@classmethod DCNL def is_demo_exploration_id(cls, exploration_id): DCNL DCSP return (exploration_id in feconf.DEMO_EXPLORATIONS)
@property DCNL def is_demo(self): DCNL DCSP return self.is_demo_exploration_id(self.id)
def update_title(self, title): DCNL DCSP self.title = title
def update_category(self, category): DCNL DCSP self.category = category
def update_objective(self, objective): DCNL DCSP self.objective = objective
def update_language_code(self, language_code): DCNL DCSP self.language_code = language_code
def update_tags(self, tags): DCNL DCSP self.tags = tags
def update_blurb(self, blurb): DCNL DCSP self.blurb = blurb
def update_author_notes(self, author_notes): DCNL DCSP self.author_notes = author_notes
def update_param_specs(self, param_specs_dict): DCNL DCSP self.param_specs = {ps_name: param_domain.ParamSpec.from_dict(ps_val) for (ps_name, ps_val) in param_specs_dict.iteritems()}
def update_param_changes(self, param_changes_list): DCNL DCSP self.param_changes = [param_domain.ParamChange.from_dict(param_change) for param_change in param_changes_list]
def update_init_state_name(self, init_state_name): DCNL DCSP if (init_state_name not in self.states): DCNL DCSP  DCSP raise Exception(('Invalid DCSP new DCSP initial DCSP state DCSP name: DCSP %s; DCSP it DCSP is DCSP not DCSP in DCSP the DCSP list DCSP of DCSP states DCSP %s DCSP for DCSP this DCSP exploration.' % (init_state_name, self.states.keys()))) DCNL DCSP self.init_state_name = init_state_name
def add_states(self, state_names): DCNL DCSP for state_name in state_names: DCNL DCSP  DCSP if (state_name in self.states): DCNL DCSP  DCSP  DCSP raise ValueError(('Duplicate DCSP state DCSP name DCSP %s' % state_name)) DCNL DCSP for state_name in state_names: DCNL DCSP  DCSP self.states[state_name] = State.create_default_state(state_name)
def rename_state(self, old_state_name, new_state_name): DCNL DCSP if (old_state_name not in self.states): DCNL DCSP  DCSP raise ValueError(('State DCSP %s DCSP does DCSP not DCSP exist' % old_state_name)) DCNL DCSP if ((old_state_name != new_state_name) and (new_state_name in self.states)): DCNL DCSP  DCSP raise ValueError(('Duplicate DCSP state DCSP name: DCSP %s' % new_state_name)) DCNL DCSP if (old_state_name == new_state_name): DCNL DCSP  DCSP return DCNL DCSP self._require_valid_state_name(new_state_name) DCNL DCSP self.states[new_state_name] = copy.deepcopy(self.states[old_state_name]) DCNL DCSP del self.states[old_state_name] DCNL DCSP if (self.init_state_name == old_state_name): DCNL DCSP  DCSP self.update_init_state_name(new_state_name) DCNL DCSP for other_state_name in self.states: DCNL DCSP  DCSP other_state = self.states[other_state_name] DCNL DCSP  DCSP other_outcomes = other_state.interaction.get_all_outcomes() DCNL DCSP  DCSP for outcome in other_outcomes: DCNL DCSP  DCSP  DCSP if (outcome.dest == old_state_name): DCNL DCSP  DCSP  DCSP  DCSP outcome.dest = new_state_name
def delete_state(self, state_name): DCNL DCSP if (state_name not in self.states): DCNL DCSP  DCSP raise ValueError(('State DCSP %s DCSP does DCSP not DCSP exist' % state_name)) DCNL DCSP if (self.init_state_name == state_name): DCNL DCSP  DCSP raise ValueError('Cannot DCSP delete DCSP initial DCSP state DCSP of DCSP an DCSP exploration.') DCNL DCSP for other_state_name in self.states: DCNL DCSP  DCSP other_state = self.states[other_state_name] DCNL DCSP  DCSP all_outcomes = other_state.interaction.get_all_outcomes() DCNL DCSP  DCSP for outcome in all_outcomes: DCNL DCSP  DCSP  DCSP if (outcome.dest == state_name): DCNL DCSP  DCSP  DCSP  DCSP outcome.dest = other_state_name DCNL DCSP del self.states[state_name]
def get_state_names_mapping(self, change_list): DCNL DCSP old_to_new_state_names = {} DCNL DCSP for state_name in self.states: DCNL DCSP  DCSP old_to_new_state_names[state_name] = state_name DCNL DCSP for change_dict in reversed(change_list): DCNL DCSP  DCSP if (change_dict['cmd'] == CMD_RENAME_STATE): DCNL DCSP  DCSP  DCSP old_to_new_state_names[change_dict['old_state_name']] = old_to_new_state_names.pop(change_dict['new_state_name']) DCNL DCSP new_to_old_state_names = {value: key for (key, value) in old_to_new_state_names.iteritems()} DCNL DCSP return new_to_old_state_names
def get_trainable_states_dict(self, old_states, new_to_old_state_names): DCNL DCSP trainable_states_dict = {'state_names_with_changed_answer_groups': [], 'state_names_with_unchanged_answer_groups': []} DCNL DCSP new_states = self.states DCNL DCSP for new_state_name in new_states: DCNL DCSP  DCSP new_state = new_states[new_state_name] DCNL DCSP  DCSP if (not new_state.can_undergo_classification()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP old_state_name = new_to_old_state_names[new_state_name] DCNL DCSP  DCSP if (old_state_name not in old_states): DCNL DCSP  DCSP  DCSP trainable_states_dict['state_names_with_changed_answer_groups'].append(new_state_name) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP old_state = old_states[old_state_name] DCNL DCSP  DCSP old_training_data = old_state.get_training_data() DCNL DCSP  DCSP new_training_data = new_state.get_training_data() DCNL DCSP  DCSP if ((new_training_data == old_training_data) and (new_state.interaction.id == old_state.interaction.id)): DCNL DCSP  DCSP  DCSP trainable_states_dict['state_names_with_unchanged_answer_groups'].append(new_state_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP trainable_states_dict['state_names_with_changed_answer_groups'].append(new_state_name) DCNL DCSP return trainable_states_dict
def add_gadget(self, gadget_dict, panel): DCNL DCSP gadget_instance = GadgetInstance(gadget_dict['gadget_type'], gadget_dict['gadget_name'], gadget_dict['visible_in_states'], gadget_dict['customization_args']) DCNL DCSP self.skin_instance.panel_contents_dict[panel].append(gadget_instance)
def rename_gadget(self, old_gadget_name, new_gadget_name): DCNL DCSP if (old_gadget_name not in self.get_all_gadget_names()): DCNL DCSP  DCSP raise ValueError(('Gadget DCSP %s DCSP does DCSP not DCSP exist.' % old_gadget_name)) DCNL DCSP if ((old_gadget_name != new_gadget_name) and (new_gadget_name in self.get_all_gadget_names())): DCNL DCSP  DCSP raise ValueError(('Duplicate DCSP gadget DCSP name: DCSP %s' % new_gadget_name)) DCNL DCSP if (old_gadget_name == new_gadget_name): DCNL DCSP  DCSP return DCNL DCSP GadgetInstance._validate_gadget_name(new_gadget_name) DCNL DCSP gadget_instance = self.get_gadget_instance_by_name(old_gadget_name) DCNL DCSP gadget_instance.name = new_gadget_name
def delete_gadget(self, gadget_name): DCNL DCSP if (gadget_name not in self.get_all_gadget_names()): DCNL DCSP  DCSP raise ValueError(('Gadget DCSP %s DCSP does DCSP not DCSP exist.' % gadget_name)) DCNL DCSP panel = self._get_panel_for_gadget(gadget_name) DCNL DCSP gadget_index = None DCNL DCSP for index in range(len(self.skin_instance.panel_contents_dict[panel])): DCNL DCSP  DCSP if (self.skin_instance.panel_contents_dict[panel][index].name == gadget_name): DCNL DCSP  DCSP  DCSP gadget_index = index DCNL DCSP  DCSP  DCSP break DCNL DCSP del self.skin_instance.panel_contents_dict[panel][gadget_index]
def get_gadget_instance_by_name(self, gadget_name): DCNL DCSP for gadget_instances in self.skin_instance.panel_contents_dict.itervalues(): DCNL DCSP  DCSP for gadget_instance in gadget_instances: DCNL DCSP  DCSP  DCSP if (gadget_instance.name == gadget_name): DCNL DCSP  DCSP  DCSP  DCSP return gadget_instance DCNL DCSP raise ValueError(('Gadget DCSP %s DCSP does DCSP not DCSP exist.' % gadget_name))
def get_all_gadget_names(self): DCNL DCSP gadget_names = set() DCNL DCSP for gadget_instances in self.skin_instance.panel_contents_dict.itervalues(): DCNL DCSP  DCSP for gadget_instance in gadget_instances: DCNL DCSP  DCSP  DCSP gadget_names.add(gadget_instance.name) DCNL DCSP return sorted(gadget_names)
def _get_panel_for_gadget(self, gadget_name): DCNL DCSP for (panel, gadget_instances) in self.skin_instance.panel_contents_dict.iteritems(): DCNL DCSP  DCSP for gadget_instance in gadget_instances: DCNL DCSP  DCSP  DCSP if (gadget_instance.name == gadget_name): DCNL DCSP  DCSP  DCSP  DCSP return panel DCNL DCSP raise ValueError(('Gadget DCSP %s DCSP does DCSP not DCSP exist.' % gadget_name))
def _update_gadget_visibilities_for_renamed_state(self, old_state_name, new_state_name): DCNL DCSP affected_gadget_instances = self._get_gadget_instances_visible_in_state(old_state_name) DCNL DCSP for gadget_instance in affected_gadget_instances: DCNL DCSP  DCSP gadget_instance.visible_in_states.remove(old_state_name) DCNL DCSP  DCSP gadget_instance.visible_in_states.append(new_state_name) DCNL DCSP  DCSP gadget_instance.visible_in_states.sort()
def _update_gadget_visibilities_for_deleted_state(self, state_name): DCNL DCSP affected_gadget_instances = self._get_gadget_instances_visible_in_state(state_name) DCNL DCSP for gadget_instance in affected_gadget_instances: DCNL DCSP  DCSP gadget_instance.visible_in_states.remove(state_name) DCNL DCSP  DCSP if (len(gadget_instance.visible_in_states) == 0): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Deleting DCSP '%s' DCSP state DCSP leaves DCSP '%s' DCSP gadget DCSP with DCSP no DCSP visible DCSP states. DCSP This DCSP is DCSP not DCSP currently DCSP supported DCSP and DCSP should DCSP be DCSP handled DCSP with DCSP editor DCSP guidance DCSP on DCSP the DCSP front-end." % (state_name, gadget_instance.name)))
def _get_gadget_instances_visible_in_state(self, state_name): DCNL DCSP visible_gadget_instances = [] DCNL DCSP for gadget_instances in self.skin_instance.panel_contents_dict.itervalues(): DCNL DCSP  DCSP for gadget_instance in gadget_instances: DCNL DCSP  DCSP  DCSP if (state_name in gadget_instance.visible_in_states): DCNL DCSP  DCSP  DCSP  DCSP visible_gadget_instances.append(gadget_instance) DCNL DCSP return visible_gadget_instances
@classmethod DCNL def _convert_states_v0_dict_to_v1_dict(cls, states_dict): DCNL DCSP for (_, state_defn) in states_dict.iteritems(): DCNL DCSP  DCSP if ('widget' not in state_defn): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP state_defn['interaction'] = copy.deepcopy(state_defn['widget']) DCNL DCSP  DCSP state_defn['interaction']['id'] = copy.deepcopy(state_defn['interaction']['widget_id']) DCNL DCSP  DCSP del state_defn['interaction']['widget_id'] DCNL DCSP  DCSP if ('sticky' in state_defn['interaction']): DCNL DCSP  DCSP  DCSP del state_defn['interaction']['sticky'] DCNL DCSP  DCSP del state_defn['widget'] DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v1_dict_to_v2_dict(cls, states_dict): DCNL DCSP old_end_dest = 'END' DCNL DCSP targets_end_state = False DCNL DCSP has_end_state = False DCNL DCSP for (state_name, sdict) in states_dict.iteritems(): DCNL DCSP  DCSP if ((not has_end_state) and (state_name == old_end_dest)): DCNL DCSP  DCSP  DCSP has_end_state = True DCNL DCSP  DCSP if (not targets_end_state): DCNL DCSP  DCSP  DCSP for handler in sdict['interaction']['handlers']: DCNL DCSP  DCSP  DCSP  DCSP for rule_spec in handler['rule_specs']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (rule_spec['dest'] == old_end_dest): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP targets_end_state = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (targets_end_state and (not has_end_state)): DCNL DCSP  DCSP states_dict[old_end_dest] = {'content': [{'type': 'text', 'value': 'Congratulations, DCSP you DCSP have DCSP finished!'}], 'interaction': {'id': 'EndExploration', 'customization_args': {'recommendedExplorationIds': {'value': []}}, 'handlers': [{'name': 'submit', 'rule_specs': [{'definition': {'rule_type': 'default'}, 'dest': old_end_dest, 'feedback': [], 'param_changes': []}]}]}, 'param_changes': []} DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v2_dict_to_v3_dict(cls, states_dict): DCNL DCSP for sdict in states_dict.values(): DCNL DCSP  DCSP interaction = sdict['interaction'] DCNL DCSP  DCSP if ('triggers' not in interaction): DCNL DCSP  DCSP  DCSP interaction['triggers'] = [] DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v3_dict_to_v4_dict(cls, states_dict): DCNL DCSP for state_dict in states_dict.values(): DCNL DCSP  DCSP interaction = state_dict['interaction'] DCNL DCSP  DCSP answer_groups = [] DCNL DCSP  DCSP default_outcome = None DCNL DCSP  DCSP for handler in interaction['handlers']: DCNL DCSP  DCSP  DCSP if (('name' in handler) and (handler['name'] != 'submit')): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ExplorationConversionError(("Error: DCSP Can DCSP only DCSP convert DCSP rules DCSP with DCSP a DCSP name DCSP 'submit' DCSP in DCSP states DCSP v3 DCSP to DCSP v4 DCSP conversion DCSP process. DCSP Encountered DCSP name: DCSP %s" % handler['name'])) DCNL DCSP  DCSP  DCSP for rule_spec in handler['rule_specs']: DCNL DCSP  DCSP  DCSP  DCSP group = {} DCNL DCSP  DCSP  DCSP  DCSP is_default_rule = False DCNL DCSP  DCSP  DCSP  DCSP if ('rule_type' in rule_spec['definition']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rule_type = rule_spec['definition']['rule_type'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP is_default_rule = (rule_type == 'default') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not is_default_rule) and (rule_type != 'atomic')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise utils.ExplorationConversionError(('Error: DCSP Can DCSP only DCSP convert DCSP default DCSP and DCSP atomic DCSP rules DCSP in DCSP states DCSP v3 DCSP to DCSP v4 DCSP conversion DCSP process. DCSP Encountered DCSP rule DCSP of DCSP type: DCSP %s' % rule_type)) DCNL DCSP  DCSP  DCSP  DCSP if (('subject' in rule_spec['definition']) and (rule_spec['definition']['subject'] != 'answer')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise utils.ExplorationConversionError(("Error: DCSP Can DCSP only DCSP convert DCSP rules DCSP with DCSP an DCSP 'answer' DCSP subject DCSP in DCSP states DCSP v3 DCSP to DCSP v4 DCSP conversion DCSP process. DCSP Encountered DCSP subject: DCSP %s" % rule_spec['definition']['subject'])) DCNL DCSP  DCSP  DCSP  DCSP if (not is_default_rule): DCNL DCSP  DCSP  DCSP  DCSP  DCSP definition = rule_spec['definition'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP group['rule_specs'] = [{'inputs': copy.deepcopy(definition['inputs']), 'rule_type': copy.deepcopy(definition['name'])}] DCNL DCSP  DCSP  DCSP  DCSP group['outcome'] = {'dest': copy.deepcopy(rule_spec['dest']), 'feedback': copy.deepcopy(rule_spec['feedback']), 'param_changes': (copy.deepcopy(rule_spec['param_changes']) if ('param_changes' in rule_spec) else [])} DCNL DCSP  DCSP  DCSP  DCSP if is_default_rule: DCNL DCSP  DCSP  DCSP  DCSP  DCSP default_outcome = group['outcome'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP answer_groups.append(group) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP is_terminal = (interaction_registry.Registry.get_interaction_by_id(interaction['id']).is_terminal if (interaction['id'] is not None) else False) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise utils.ExplorationConversionError(('Trying DCSP to DCSP migrate DCSP exploration DCSP containing DCSP non-existent DCSP interaction DCSP ID: DCSP %s' % interaction['id'])) DCNL DCSP  DCSP if (not is_terminal): DCNL DCSP  DCSP  DCSP interaction['answer_groups'] = answer_groups DCNL DCSP  DCSP  DCSP interaction['default_outcome'] = default_outcome DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP interaction['answer_groups'] = [] DCNL DCSP  DCSP  DCSP interaction['default_outcome'] = None DCNL DCSP  DCSP del interaction['handlers'] DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v4_dict_to_v5_dict(cls, states_dict): DCNL DCSP for state_dict in states_dict.values(): DCNL DCSP  DCSP interaction = state_dict['interaction'] DCNL DCSP  DCSP if ('triggers' in interaction): DCNL DCSP  DCSP  DCSP del interaction['triggers'] DCNL DCSP  DCSP if ('fallbacks' not in interaction): DCNL DCSP  DCSP  DCSP interaction['fallbacks'] = [] DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v5_dict_to_v6_dict(cls, states_dict): DCNL DCSP for state_dict in states_dict.values(): DCNL DCSP  DCSP interaction = state_dict['interaction'] DCNL DCSP  DCSP if ('confirmed_unclassified_answers' not in interaction): DCNL DCSP  DCSP  DCSP interaction['confirmed_unclassified_answers'] = [] DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v6_dict_to_v7_dict(cls, states_dict): DCNL DCSP for state_dict in states_dict.values(): DCNL DCSP  DCSP interaction = state_dict['interaction'] DCNL DCSP  DCSP if (interaction['id'] == 'CodeRepl'): DCNL DCSP  DCSP  DCSP interaction['customization_args']['language']['value'] = 'python' DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v7_dict_to_v8_dict(cls, states_dict): DCNL DCSP for state_dict in states_dict.values(): DCNL DCSP  DCSP state_dict['classifier_model_id'] = None DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v8_dict_to_v9_dict(cls, states_dict): DCNL DCSP for state_dict in states_dict.values(): DCNL DCSP  DCSP answer_groups = state_dict['interaction']['answer_groups'] DCNL DCSP  DCSP for answer_group in answer_groups: DCNL DCSP  DCSP  DCSP answer_group['correct'] = False DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v9_dict_to_v10_dict(cls, states_dict): DCNL DCSP for state_dict in states_dict.values(): DCNL DCSP  DCSP interaction = state_dict['interaction'] DCNL DCSP  DCSP if ('hints' not in interaction): DCNL DCSP  DCSP  DCSP interaction['hints'] = [] DCNL DCSP  DCSP  DCSP for fallback in interaction['fallbacks']: DCNL DCSP  DCSP  DCSP  DCSP if fallback['outcome']['feedback']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP interaction['hints'].append(Hint(fallback['outcome']['feedback'][0]).to_dict()) DCNL DCSP  DCSP if ('solution' not in interaction): DCNL DCSP  DCSP  DCSP interaction['solution'] = {} DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v10_dict_to_v11_dict(cls, states_dict): DCNL DCSP for state_dict in states_dict.values(): DCNL DCSP  DCSP content_html = state_dict['content'][0]['value'] DCNL DCSP  DCSP state_dict['content'] = {'html': content_html, 'audio_translations': []} DCNL DCSP return states_dict
@classmethod DCNL def _convert_states_v11_dict_to_v12_dict(cls, states_dict): DCNL DCSP for state_dict in states_dict.values(): DCNL DCSP  DCSP old_audio_translations = state_dict['content']['audio_translations'] DCNL DCSP  DCSP state_dict['content']['audio_translations'] = {old_translation['language_code']: {'filename': old_translation['filename'], 'file_size_bytes': old_translation['file_size_bytes'], 'needs_update': old_translation['needs_update']} for old_translation in old_audio_translations} DCNL DCSP return states_dict
@classmethod DCNL def update_states_from_model(cls, versioned_exploration_states, current_states_schema_version): DCNL DCSP versioned_exploration_states['states_schema_version'] = (current_states_schema_version + 1) DCNL DCSP conversion_fn = getattr(cls, ('_convert_states_v%s_dict_to_v%s_dict' % (current_states_schema_version, (current_states_schema_version + 1)))) DCNL DCSP versioned_exploration_states['states'] = conversion_fn(versioned_exploration_states['states'])
@classmethod DCNL def _convert_v1_dict_to_v2_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 2 DCNL DCSP exploration_dict['init_state_name'] = exploration_dict['states'][0]['name'] DCNL DCSP states_dict = {} DCNL DCSP for state in exploration_dict['states']: DCNL DCSP  DCSP states_dict[state['name']] = state DCNL DCSP  DCSP del states_dict[state['name']]['name'] DCNL DCSP exploration_dict['states'] = states_dict DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v2_dict_to_v3_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 3 DCNL DCSP exploration_dict['objective'] = '' DCNL DCSP exploration_dict['language_code'] = constants.DEFAULT_LANGUAGE_CODE DCNL DCSP exploration_dict['skill_tags'] = [] DCNL DCSP exploration_dict['blurb'] = '' DCNL DCSP exploration_dict['author_notes'] = '' DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v3_dict_to_v4_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 4 DCNL DCSP for (_, state_defn) in exploration_dict['states'].iteritems(): DCNL DCSP  DCSP state_defn['interaction'] = copy.deepcopy(state_defn['widget']) DCNL DCSP  DCSP state_defn['interaction']['id'] = copy.deepcopy(state_defn['interaction']['widget_id']) DCNL DCSP  DCSP del state_defn['interaction']['widget_id'] DCNL DCSP  DCSP del state_defn['interaction']['sticky'] DCNL DCSP  DCSP del state_defn['widget'] DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v4_dict_to_v5_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 5 DCNL DCSP exploration_dict['tags'] = exploration_dict['skill_tags'] DCNL DCSP del exploration_dict['skill_tags'] DCNL DCSP exploration_dict['skin_customizations'] = {'panels_contents': {'bottom': [], 'left': [], 'right': []}} DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v5_dict_to_v6_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 6 DCNL DCSP exploration_dict['states'] = cls._convert_states_v0_dict_to_v1_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states'] = cls._convert_states_v1_dict_to_v2_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states'] = cls._convert_states_v2_dict_to_v3_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 3 DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v6_dict_to_v7_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 7 DCNL DCSP exploration_dict['states'] = cls._convert_states_v3_dict_to_v4_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 4 DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v7_dict_to_v8_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 8 DCNL DCSP exploration_dict['states'] = cls._convert_states_v4_dict_to_v5_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 5 DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v8_dict_to_v9_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 9 DCNL DCSP exploration_dict['states'] = cls._convert_states_v5_dict_to_v6_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 6 DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v9_dict_to_v10_dict(cls, exploration_dict, title, category): DCNL DCSP exploration_dict['schema_version'] = 10 DCNL DCSP exploration_dict['title'] = title DCNL DCSP exploration_dict['category'] = category DCNL DCSP del exploration_dict['default_skin'] DCNL DCSP exploration_dict['skin_customizations'] = {'panels_contents': {'bottom': []}} DCNL DCSP exploration_dict['states'] = cls._convert_states_v6_dict_to_v7_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 7 DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v10_dict_to_v11_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 11 DCNL DCSP exploration_dict['states'] = cls._convert_states_v7_dict_to_v8_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 8 DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v11_dict_to_v12_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 12 DCNL DCSP exploration_dict['states'] = cls._convert_states_v8_dict_to_v9_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 9 DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v12_dict_to_v13_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 13 DCNL DCSP exploration_dict['states'] = cls._convert_states_v9_dict_to_v10_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 10 DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v13_dict_to_v14_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 14 DCNL DCSP exploration_dict['states'] = cls._convert_states_v10_dict_to_v11_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 11 DCNL DCSP return exploration_dict
@classmethod DCNL def _convert_v14_dict_to_v15_dict(cls, exploration_dict): DCNL DCSP exploration_dict['schema_version'] = 15 DCNL DCSP exploration_dict['states'] = cls._convert_states_v11_dict_to_v12_dict(exploration_dict['states']) DCNL DCSP exploration_dict['states_schema_version'] = 12 DCNL DCSP return exploration_dict
@classmethod DCNL def _migrate_to_latest_yaml_version(cls, yaml_content, title=None, category=None): DCNL DCSP try: DCNL DCSP  DCSP exploration_dict = utils.dict_from_yaml(yaml_content) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise Exception(('Please DCSP ensure DCSP that DCSP you DCSP are DCSP uploading DCSP a DCSP YAML DCSP text DCSP file, DCSP not DCSP a DCSP zip DCSP file. DCSP The DCSP YAML DCSP parser DCSP returned DCSP the DCSP following DCSP error: DCSP %s' % e)) DCNL DCSP exploration_schema_version = exploration_dict.get('schema_version') DCNL DCSP initial_schema_version = exploration_schema_version DCNL DCSP if (exploration_schema_version is None): DCNL DCSP  DCSP raise Exception('Invalid DCSP YAML DCSP file: DCSP no DCSP schema DCSP version DCSP specified.') DCNL DCSP if (not (1 <= exploration_schema_version <= cls.CURRENT_EXP_SCHEMA_VERSION)): DCNL DCSP  DCSP raise Exception(('Sorry, DCSP we DCSP can DCSP only DCSP process DCSP v1 DCSP to DCSP v%s DCSP exploration DCSP YAML DCSP files DCSP at DCSP present.' % cls.CURRENT_EXP_SCHEMA_VERSION)) DCNL DCSP if (exploration_schema_version == 1): DCNL DCSP  DCSP exploration_dict = cls._convert_v1_dict_to_v2_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 2 DCNL DCSP if (exploration_schema_version == 2): DCNL DCSP  DCSP exploration_dict = cls._convert_v2_dict_to_v3_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 3 DCNL DCSP if (exploration_schema_version == 3): DCNL DCSP  DCSP exploration_dict = cls._convert_v3_dict_to_v4_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 4 DCNL DCSP if (exploration_schema_version == 4): DCNL DCSP  DCSP exploration_dict = cls._convert_v4_dict_to_v5_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 5 DCNL DCSP if (exploration_schema_version == 5): DCNL DCSP  DCSP exploration_dict = cls._convert_v5_dict_to_v6_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 6 DCNL DCSP if (exploration_schema_version == 6): DCNL DCSP  DCSP exploration_dict = cls._convert_v6_dict_to_v7_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 7 DCNL DCSP if (exploration_schema_version == 7): DCNL DCSP  DCSP exploration_dict = cls._convert_v7_dict_to_v8_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 8 DCNL DCSP if (exploration_schema_version == 8): DCNL DCSP  DCSP exploration_dict = cls._convert_v8_dict_to_v9_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 9 DCNL DCSP if (exploration_schema_version == 9): DCNL DCSP  DCSP exploration_dict = cls._convert_v9_dict_to_v10_dict(exploration_dict, title, category) DCNL DCSP  DCSP exploration_schema_version = 10 DCNL DCSP if (exploration_schema_version == 10): DCNL DCSP  DCSP exploration_dict = cls._convert_v10_dict_to_v11_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 11 DCNL DCSP if (exploration_schema_version == 11): DCNL DCSP  DCSP exploration_dict = cls._convert_v11_dict_to_v12_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 12 DCNL DCSP if (exploration_schema_version == 12): DCNL DCSP  DCSP exploration_dict = cls._convert_v12_dict_to_v13_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 13 DCNL DCSP if (exploration_schema_version == 13): DCNL DCSP  DCSP exploration_dict = cls._convert_v13_dict_to_v14_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 14 DCNL DCSP if (exploration_schema_version == 14): DCNL DCSP  DCSP exploration_dict = cls._convert_v14_dict_to_v15_dict(exploration_dict) DCNL DCSP  DCSP exploration_schema_version = 15 DCNL DCSP return (exploration_dict, initial_schema_version)
@classmethod DCNL def from_yaml(cls, exploration_id, yaml_content): DCNL DCSP migration_result = cls._migrate_to_latest_yaml_version(yaml_content) DCNL DCSP exploration_dict = migration_result[0] DCNL DCSP initial_schema_version = migration_result[1] DCNL DCSP if (initial_schema_version <= cls.LAST_UNTITLED_SCHEMA_VERSION): DCNL DCSP  DCSP raise Exception(('Expected DCSP a DCSP YAML DCSP version DCSP >= DCSP 10, DCSP received: DCSP %d' % initial_schema_version)) DCNL DCSP exploration_dict['id'] = exploration_id DCNL DCSP return Exploration.from_dict(exploration_dict)
@classmethod DCNL def from_untitled_yaml(cls, exploration_id, title, category, yaml_content): DCNL DCSP migration_result = cls._migrate_to_latest_yaml_version(yaml_content, title, category) DCNL DCSP exploration_dict = migration_result[0] DCNL DCSP initial_schema_version = migration_result[1] DCNL DCSP if (initial_schema_version > cls.LAST_UNTITLED_SCHEMA_VERSION): DCNL DCSP  DCSP raise Exception(('Expected DCSP a DCSP YAML DCSP version DCSP <= DCSP 9, DCSP received: DCSP %d' % initial_schema_version)) DCNL DCSP exploration_dict['id'] = exploration_id DCNL DCSP return Exploration.from_dict(exploration_dict)
def to_yaml(self): DCNL DCSP exp_dict = self.to_dict() DCNL DCSP exp_dict['schema_version'] = self.CURRENT_EXP_SCHEMA_VERSION DCNL DCSP del exp_dict['id'] DCNL DCSP return utils.yaml_from_dict(exp_dict)
def to_dict(self): DCNL DCSP return copy.deepcopy({'id': self.id, 'title': self.title, 'category': self.category, 'author_notes': self.author_notes, 'blurb': self.blurb, 'states_schema_version': self.states_schema_version, 'init_state_name': self.init_state_name, 'language_code': self.language_code, 'objective': self.objective, 'param_changes': self.param_change_dicts, 'param_specs': self.param_specs_dict, 'tags': self.tags, 'skin_customizations': self.skin_instance.to_dict()['skin_customizations'], 'states': {state_name: state.to_dict() for (state_name, state) in self.states.iteritems()}})
def to_player_dict(self): DCNL DCSP return {'init_state_name': self.init_state_name, 'param_changes': self.param_change_dicts, 'param_specs': self.param_specs_dict, 'skin_customizations': self.skin_instance.to_dict()['skin_customizations'], 'states': {state_name: state.to_dict() for (state_name, state) in self.states.iteritems()}, 'title': self.title, 'language_code': self.language_code}
def get_gadget_types(self): DCNL DCSP result = set() DCNL DCSP for gadget_instances in self.skin_instance.panel_contents_dict.itervalues(): DCNL DCSP  DCSP result.update([gadget_instance.type for gadget_instance in gadget_instances]) DCNL DCSP return sorted(result)
def get_interaction_ids(self): DCNL DCSP return list(set([state.interaction.id for state in self.states.itervalues() if (state.interaction.id is not None)]))
def __init__(self, exploration_id, title, category, objective, language_code, tags, ratings, scaled_average_rating, status, community_owned, owner_ids, editor_ids, viewer_ids, contributor_ids, contributors_summary, version, exploration_model_created_on, exploration_model_last_updated, first_published_msec): DCNL DCSP self.id = exploration_id DCNL DCSP self.title = title DCNL DCSP self.category = category DCNL DCSP self.objective = objective DCNL DCSP self.language_code = language_code DCNL DCSP self.tags = tags DCNL DCSP self.ratings = ratings DCNL DCSP self.scaled_average_rating = scaled_average_rating DCNL DCSP self.status = status DCNL DCSP self.community_owned = community_owned DCNL DCSP self.owner_ids = owner_ids DCNL DCSP self.editor_ids = editor_ids DCNL DCSP self.viewer_ids = viewer_ids DCNL DCSP self.contributor_ids = contributor_ids DCNL DCSP self.contributors_summary = contributors_summary DCNL DCSP self.version = version DCNL DCSP self.exploration_model_created_on = exploration_model_created_on DCNL DCSP self.exploration_model_last_updated = exploration_model_last_updated DCNL DCSP self.first_published_msec = first_published_msec
def to_metadata_dict(self): DCNL DCSP return {'id': self.id, 'title': self.title, 'objective': self.objective}
def test_interaction_registry(self): DCNL DCSP self.assertEqual(len(interaction_registry.Registry.get_all_interactions()), len(interaction_registry.Registry.get_all_interaction_ids()))
def test_get_all_specs(self): DCNL DCSP specs_dict = interaction_registry.Registry.get_all_specs() DCNL DCSP self.assertEqual(len(specs_dict.keys()), len(interaction_registry.Registry.get_all_interaction_ids())) DCNL DCSP terminal_interactions_count = 0 DCNL DCSP for item in specs_dict.values(): DCNL DCSP  DCSP self.assertIn(item['display_mode'], base.ALLOWED_DISPLAY_MODES) DCNL DCSP  DCSP self.assertTrue(isinstance(item['is_terminal'], bool)) DCNL DCSP  DCSP if item['is_terminal']: DCNL DCSP  DCSP  DCSP terminal_interactions_count += 1 DCNL DCSP self.assertEqual(terminal_interactions_count, EXPECTED_TERMINAL_INTERACTIONS_COUNT)
def test_validation(self): DCNL DCSP classifier_data = {'_alpha': 0.1, '_beta': 0.001, '_prediction_threshold': 0.5, '_training_iterations': 25, '_prediction_iterations': 5, '_num_labels': 10, '_num_docs': 12, '_num_words': 20, '_label_to_id': {'text': 1}, '_word_to_id': {'hello': 2}, '_w_dp': [], '_b_dl': [], '_l_dp': [], '_c_dl': [], '_c_lw': [], '_c_l': []} DCNL DCSP classifier_dict = {'classifier_id': 'job_request_id1', 'exp_id': 'exp_id1', 'exp_version_when_created': 1, 'state_name': 'a DCSP state DCSP name', 'algorithm_id': 'LDAStringClassifier', 'classifier_data': classifier_data, 'data_schema_version': 1} DCNL DCSP classifier = classifier_domain.ClassifierData(classifier_dict['classifier_id'], classifier_dict['exp_id'], classifier_dict['exp_version_when_created'], classifier_dict['state_name'], classifier_dict['algorithm_id'], classifier_dict['classifier_data'], classifier_dict['data_schema_version']) DCNL DCSP classifier.validate() DCNL DCSP classifier_dict['classifier_id'] = 1 DCNL DCSP classifier = classifier_domain.ClassifierData(classifier_dict['classifier_id'], classifier_dict['exp_id'], classifier_dict['exp_version_when_created'], classifier_dict['state_name'], classifier_dict['algorithm_id'], classifier_dict['classifier_data'], classifier_dict['data_schema_version']) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP id DCSP to DCSP be DCSP a DCSP string'): DCNL DCSP  DCSP classifier.validate() DCNL DCSP classifier_dict['classifier_id'] = 'job_request_id1' DCNL DCSP classifier_dict['exp_version_when_created'] = 'abc' DCNL DCSP classifier = classifier_domain.ClassifierData(classifier_dict['classifier_id'], classifier_dict['exp_id'], classifier_dict['exp_version_when_created'], classifier_dict['state_name'], classifier_dict['algorithm_id'], classifier_dict['classifier_data'], classifier_dict['data_schema_version']) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP exp_version_when_created DCSP to DCSP be DCSP an DCSP int'): DCNL DCSP  DCSP classifier.validate() DCNL DCSP classifier_dict['exp_version_when_created'] = 1 DCNL DCSP classifier_dict['state_name'] = 'A DCSP string DCSP #' DCNL DCSP classifier = classifier_domain.ClassifierData(classifier_dict['classifier_id'], classifier_dict['exp_id'], classifier_dict['exp_version_when_created'], classifier_dict['state_name'], classifier_dict['algorithm_id'], classifier_dict['classifier_data'], classifier_dict['data_schema_version']) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP character DCSP # DCSP in DCSP the DCSP state DCSP name'): DCNL DCSP  DCSP classifier.validate() DCNL DCSP classifier_dict['state_name'] = 'a DCSP state DCSP name' DCNL DCSP classifier_dict['algorithm_id'] = 'abc' DCNL DCSP classifier = classifier_domain.ClassifierData(classifier_dict['classifier_id'], classifier_dict['exp_id'], classifier_dict['exp_version_when_created'], classifier_dict['state_name'], classifier_dict['algorithm_id'], classifier_dict['classifier_data'], classifier_dict['data_schema_version']) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP algorithm DCSP id'): DCNL DCSP  DCSP classifier.validate() DCNL DCSP classifier_dict['algorithm_id'] = 'LDAStringClassifier' DCNL DCSP classifier_dict['classifier_data'] = [] DCNL DCSP classifier = classifier_domain.ClassifierData(classifier_dict['classifier_id'], classifier_dict['exp_id'], classifier_dict['exp_version_when_created'], classifier_dict['state_name'], classifier_dict['algorithm_id'], classifier_dict['classifier_data'], classifier_dict['data_schema_version']) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP classifier_data DCSP to DCSP be DCSP a DCSP dict'): DCNL DCSP  DCSP classifier.validate()
def test_validation(self): DCNL DCSP training_data = [{'answer_group_index': 1, 'answers': ['a1', 'a2']}, {'answer_group_index': 2, 'answers': ['a2', 'a3']}] DCNL DCSP training_job_dict = {'job_id': 'exp_id1.SOME_RANDOM_STRING', 'exp_id': 'exp_id1', 'exp_version': 1, 'state_name': 'some DCSP state', 'algorithm_id': 'LDAStringClassifier', 'interaction_id': 'TextInput', 'training_data': training_data, 'status': 'NEW'} DCNL DCSP training_job = self._get_training_job_from_dict(training_job_dict) DCNL DCSP training_job.validate() DCNL DCSP training_job_dict['job_id'] = 1 DCNL DCSP training_job = self._get_training_job_from_dict(training_job_dict) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP id DCSP to DCSP be DCSP a DCSP string'): DCNL DCSP  DCSP training_job.validate() DCNL DCSP training_job_dict['job_id'] = 'exp_id1.SOME_RANDOM_STRING' DCNL DCSP training_job_dict['exp_version'] = 'abc' DCNL DCSP training_job = self._get_training_job_from_dict(training_job_dict) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP exp_version DCSP to DCSP be DCSP an DCSP int'): DCNL DCSP  DCSP training_job.validate() DCNL DCSP training_job_dict['exp_version'] = 1 DCNL DCSP training_job_dict['state_name'] = 'A DCSP string DCSP #' DCNL DCSP training_job = self._get_training_job_from_dict(training_job_dict) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP character DCSP # DCSP in DCSP the DCSP state DCSP name'): DCNL DCSP  DCSP training_job.validate() DCNL DCSP training_job_dict['state_name'] = 'a DCSP state DCSP name' DCNL DCSP training_job_dict['algorithm_id'] = 'abc' DCNL DCSP training_job = self._get_training_job_from_dict(training_job_dict) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP algorithm DCSP id'): DCNL DCSP  DCSP training_job.validate() DCNL DCSP training_job_dict['algorithm_id'] = 'LDAStringClassifier' DCNL DCSP training_job_dict['training_data'] = {} DCNL DCSP training_job = self._get_training_job_from_dict(training_job_dict) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP training_data DCSP to DCSP be DCSP a DCSP list'): DCNL DCSP  DCSP training_job.validate()
def test_validation(self): DCNL DCSP mapping_dict = {'exp_id': 'exp_id1', 'exp_version': 2, 'state_name': u'\u7db2\u7ad9\u6709\u4e2d', 'job_id': 'job_id1'} DCNL DCSP mapping = self._get_mapping_from_dict(mapping_dict) DCNL DCSP mapping.validate() DCNL DCSP mapping_dict['exp_id'] = 1 DCNL DCSP mapping = self._get_mapping_from_dict(mapping_dict) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP exp_id DCSP to DCSP be DCSP a DCSP string'): DCNL DCSP  DCSP mapping.validate() DCNL DCSP mapping_dict['exp_id'] = 'exp_id1' DCNL DCSP mapping_dict['exp_version'] = '1' DCNL DCSP mapping = self._get_mapping_from_dict(mapping_dict) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP exp_version DCSP to DCSP be DCSP an DCSP int'): DCNL DCSP  DCSP mapping.validate()
def __init__(self, exploration_id, exploration_version, state_name, interaction_id, submitted_answer_list, schema_version=feconf.CURRENT_STATE_ANSWERS_SCHEMA_VERSION): DCNL DCSP self.exploration_id = exploration_id DCNL DCSP self.exploration_version = exploration_version DCNL DCSP self.state_name = state_name DCNL DCSP self.interaction_id = interaction_id DCNL DCSP self.submitted_answer_list = submitted_answer_list DCNL DCSP self.schema_version = schema_version
def get_submitted_answer_dict_list(self): DCNL DCSP return [state_answer.to_dict() for state_answer in self.submitted_answer_list]
def validate(self): DCNL DCSP if (not isinstance(self.exploration_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP exploration_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % str(self.exploration_id))) DCNL DCSP if (not isinstance(self.state_name, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP state_name DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % str(self.state_name))) DCNL DCSP if (self.interaction_id is not None): DCNL DCSP  DCSP if (not isinstance(self.interaction_id, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP interaction_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % str(self.interaction_id))) DCNL DCSP  DCSP if (self.interaction_id not in interaction_registry.Registry.get_all_interaction_ids()): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Unknown DCSP interaction_id: DCSP %s' % self.interaction_id)) DCNL DCSP if (not isinstance(self.submitted_answer_list, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP submitted_answer_list DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % str(self.submitted_answer_list))) DCNL DCSP if (not isinstance(self.schema_version, int)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP schema_version DCSP to DCSP be DCSP an DCSP integer, DCSP received DCSP %s' % str(self.schema_version))) DCNL DCSP if (self.schema_version < 1): DCNL DCSP  DCSP raise utils.ValidationError(('schema_version DCSP < DCSP 1: DCSP %d' % self.schema_version)) DCNL DCSP if (self.schema_version > feconf.CURRENT_STATE_ANSWERS_SCHEMA_VERSION): DCNL DCSP  DCSP raise utils.ValidationError(('schema_version DCSP > DCSP feconf.CURRENT_STATE_ANSWERS_SCHEMA_VERSION DCSP (%d): DCSP %d' % (feconf.CURRENT_STATE_ANSWERS_SCHEMA_VERSION, self.schema_version)))
def validate(self): DCNL DCSP if (self.time_spent_in_sec is None): DCNL DCSP  DCSP raise utils.ValidationError('SubmittedAnswers DCSP must DCSP have DCSP a DCSP provided DCSP time_spent_in_sec') DCNL DCSP if (self.session_id is None): DCNL DCSP  DCSP raise utils.ValidationError('SubmittedAnswers DCSP must DCSP have DCSP a DCSP provided DCSP session_id') DCNL DCSP if ((self.rule_spec_str is not None) and (not isinstance(self.rule_spec_str, basestring))): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP rule_spec_str DCSP to DCSP be DCSP either DCSP None DCSP or DCSP a DCSP string, DCSP received DCSP %s' % str(self.rule_spec_str))) DCNL DCSP if ((self.answer_str is not None) and (not isinstance(self.answer_str, basestring))): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP answer_str DCSP to DCSP be DCSP either DCSP None DCSP or DCSP a DCSP string, DCSP received DCSP %s' % str(self.answer_str))) DCNL DCSP if (not isinstance(self.session_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP session_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % str(self.session_id))) DCNL DCSP if (not isinstance(self.time_spent_in_sec, numbers.Number)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP time_spent_in_sec DCSP to DCSP be DCSP a DCSP number, DCSP received DCSP %s' % str(self.time_spent_in_sec))) DCNL DCSP if (not isinstance(self.params, dict)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP params DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % str(self.params))) DCNL DCSP if (not isinstance(self.answer_group_index, int)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP answer_group_index DCSP to DCSP be DCSP an DCSP integer, DCSP received DCSP %s' % str(self.answer_group_index))) DCNL DCSP if (not isinstance(self.rule_spec_index, int)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP rule_spec_index DCSP to DCSP be DCSP an DCSP integer, DCSP received DCSP %s' % str(self.rule_spec_index))) DCNL DCSP if (self.answer_group_index < 0): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP answer_group_index DCSP to DCSP be DCSP non-negative, DCSP received DCSP %d' % self.answer_group_index)) DCNL DCSP if (self.rule_spec_index < 0): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP rule_spec_index DCSP to DCSP be DCSP non-negative, DCSP received DCSP %d' % self.rule_spec_index)) DCNL DCSP if (self.time_spent_in_sec < 0.0): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP time_spent_in_sec DCSP to DCSP be DCSP non-negative, DCSP received DCSP %f' % self.time_spent_in_sec)) DCNL DCSP if ((self.answer is None) and (self.interaction_id not in feconf.LINEAR_INTERACTION_IDS)): DCNL DCSP  DCSP raise utils.ValidationError('SubmittedAnswers DCSP must DCSP have DCSP a DCSP provided DCSP answer DCSP except DCSP for DCSP linear DCSP interactions') DCNL DCSP valid_classification_categories = [exp_domain.EXPLICIT_CLASSIFICATION, exp_domain.TRAINING_DATA_CLASSIFICATION, exp_domain.STATISTICAL_CLASSIFICATION, exp_domain.DEFAULT_OUTCOME_CLASSIFICATION] DCNL DCSP if (self.classification_categorization not in valid_classification_categories): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP valid DCSP classification_categorization, DCSP received DCSP %s' % self.classification_categorization))
def __init__(self, exploration_id, exploration_version, state_name, calculation_id, calculation_output): DCNL DCSP self.exploration_id = exploration_id DCNL DCSP self.exploration_version = exploration_version DCNL DCSP self.state_name = state_name DCNL DCSP self.calculation_id = calculation_id DCNL DCSP self.calculation_output = calculation_output
def save(self): DCNL DCSP self.validate() DCNL DCSP stats_models.StateAnswersCalcOutputModel.create_or_update(self.exploration_id, self.exploration_version, self.state_name, self.calculation_id, self.calculation_output)
def validate(self): DCNL DCSP max_bytes_per_calc_output_data = 999999 DCNL DCSP if (not isinstance(self.exploration_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP exploration_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % str(self.exploration_id))) DCNL DCSP if (not isinstance(self.state_name, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP state_name DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % str(self.state_name))) DCNL DCSP if (not isinstance(self.calculation_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP calculation_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % str(self.calculation_id))) DCNL DCSP output_data = self.calculation_output DCNL DCSP if (sys.getsizeof(output_data) > max_bytes_per_calc_output_data): DCNL DCSP  DCSP raise utils.ValidationError(('calculation_output DCSP is DCSP too DCSP big DCSP to DCSP be DCSP stored DCSP (size: DCSP %d): DCSP %s' % (sys.getsizeof(output_data), str(output_data))))
def __init__(self, content, version, metadata): DCNL DCSP self._content = content DCNL DCSP self._version = version DCNL DCSP self._metadata = FileMetadata(metadata)
def read(self): DCNL DCSP content = self._content DCNL DCSP self._content = '' DCNL DCSP return content
def _get_file_metadata(self, filepath, version): DCNL DCSP if (version is None): DCNL DCSP  DCSP return file_models.FileMetadataModel.get_model(self._exploration_id, ('assets/%s' % filepath)) DCNL DCSP else: DCNL DCSP  DCSP return file_models.FileMetadataModel.get_version(self._exploration_id, ('assets/%s' % filepath), version)
def _get_file_data(self, filepath, version): DCNL DCSP if (version is None): DCNL DCSP  DCSP return file_models.FileModel.get_model(self._exploration_id, ('assets/%s' % filepath)) DCNL DCSP else: DCNL DCSP  DCSP return file_models.FileModel.get_version(self._exploration_id, ('assets/%s' % filepath), version)
def _save_file(self, user_id, filepath, raw_bytes): DCNL DCSP if (len(raw_bytes) > feconf.MAX_FILE_SIZE_BYTES): DCNL DCSP  DCSP raise Exception('The DCSP maximum DCSP allowed DCSP file DCSP size DCSP is DCSP 1 DCSP MB.') DCNL DCSP metadata = self._get_file_metadata(filepath, None) DCNL DCSP if (not metadata): DCNL DCSP  DCSP metadata = file_models.FileMetadataModel.create(self._exploration_id, ('assets/%s' % filepath)) DCNL DCSP metadata.size = len(raw_bytes) DCNL DCSP data = self._get_file_data(filepath, None) DCNL DCSP if (not data): DCNL DCSP  DCSP data = file_models.FileModel.create(self._exploration_id, ('assets/%s' % filepath)) DCNL DCSP data.content = raw_bytes DCNL DCSP data.commit(user_id, CHANGE_LIST_SAVE) DCNL DCSP metadata.commit(user_id, CHANGE_LIST_SAVE)
def get(self, filepath, version=None, mode=None): DCNL DCSP metadata = self._get_file_metadata(filepath, version) DCNL DCSP if metadata: DCNL DCSP  DCSP data = self._get_file_data(filepath, version) DCNL DCSP  DCSP if data: DCNL DCSP  DCSP  DCSP if (version is None): DCNL DCSP  DCSP  DCSP  DCSP version = data.version DCNL DCSP  DCSP  DCSP return FileStreamWithMetadata(data.content, version, metadata) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.error(('Metadata DCSP and DCSP data DCSP for DCSP file DCSP %s DCSP (version DCSP %s) DCSP are DCSP out DCSP of DCSP sync.' % (filepath, version))) DCNL DCSP  DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return None
def commit(self, user_id, filepath, raw_bytes, unused_mimetype): DCNL DCSP self._save_file(user_id, filepath, raw_bytes)
def delete(self, user_id, filepath): DCNL DCSP metadata = self._get_file_metadata(filepath, None) DCNL DCSP if metadata: DCNL DCSP  DCSP metadata.delete(user_id, '') DCNL DCSP data = self._get_file_data(filepath, None) DCNL DCSP if data: DCNL DCSP  DCSP data.delete(user_id, '')
def isfile(self, filepath): DCNL DCSP metadata = self._get_file_metadata(filepath, None) DCNL DCSP return bool(metadata)
def listdir(self, dir_name): DCNL DCSP prefix = ('%s' % utils.vfs_construct_path('/', self._exploration_id, 'assets', dir_name)) DCNL DCSP if (not prefix.endswith('/')): DCNL DCSP  DCSP prefix += '/' DCNL DCSP result = set() DCNL DCSP metadata_models = file_models.FileMetadataModel.get_undeleted() DCNL DCSP for metadata_model in metadata_models: DCNL DCSP  DCSP filepath = metadata_model.id DCNL DCSP  DCSP if filepath.startswith(prefix): DCNL DCSP  DCSP  DCSP result.add('/'.join(filepath.split('/')[3:])) DCNL DCSP return sorted(list(result))
def __init__(self, root): DCNL DCSP self._root = os.path.join(os.getcwd(), root) DCNL DCSP self._exploration_id = 'test'
def isfile(self, filepath): DCNL DCSP return os.path.isfile(os.path.join(self._root, filepath))
def get(self, filepath, version=None, mode='r'): DCNL DCSP content = utils.get_file_contents(os.path.join(self._root, filepath), raw_bytes=True, mode=mode) DCNL DCSP return FileStreamWithMetadata(content, None, None)
def _check_filepath(self, filepath): DCNL DCSP base_dir = utils.vfs_construct_path('/', self.impl.exploration_id, 'assets') DCNL DCSP absolute_path = utils.vfs_construct_path(base_dir, filepath) DCNL DCSP normalized_path = utils.vfs_normpath(absolute_path) DCNL DCSP if (not normalized_path.startswith(base_dir)): DCNL DCSP  DCSP raise IOError(('Invalid DCSP filepath: DCSP %s' % filepath))
def isfile(self, filepath): DCNL DCSP self._check_filepath(filepath) DCNL DCSP return self._impl.isfile(filepath)
def open(self, filepath, version=None, mode='r'): DCNL DCSP self._check_filepath(filepath) DCNL DCSP return self._impl.get(filepath, version=version, mode=mode)
def get(self, filepath, version=None, mode='r'): DCNL DCSP file_stream = self.open(filepath, version=version, mode=mode) DCNL DCSP if (file_stream is None): DCNL DCSP  DCSP raise IOError(('File DCSP %s DCSP (version DCSP %s) DCSP not DCSP found.' % (filepath, (version if version else 'latest')))) DCNL DCSP return file_stream.read()
def commit(self, user_id, filepath, raw_bytes, mimetype=None): DCNL DCSP raw_bytes = str(raw_bytes) DCNL DCSP self._check_filepath(filepath) DCNL DCSP self._impl.commit(user_id, filepath, raw_bytes, mimetype)
def delete(self, user_id, filepath): DCNL DCSP self._check_filepath(filepath) DCNL DCSP self._impl.delete(user_id, filepath)
def listdir(self, dir_name): DCNL DCSP self._check_filepath(dir_name) DCNL DCSP return self._impl.listdir(dir_name)
def setUp(self): DCNL DCSP super(CollectionServicesUnitTests, self).setUp() DCNL DCSP self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL) DCNL DCSP self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL) DCNL DCSP self.viewer_id = self.get_user_id_from_email(self.VIEWER_EMAIL) DCNL DCSP user_services.create_new_user(self.owner_id, self.OWNER_EMAIL) DCNL DCSP user_services.create_new_user(self.editor_id, self.EDITOR_EMAIL) DCNL DCSP user_services.create_new_user(self.viewer_id, self.VIEWER_EMAIL) DCNL DCSP self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME) DCNL DCSP self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME) DCNL DCSP self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME) DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.set_admins([self.ADMIN_USERNAME]) DCNL DCSP self.user_id_admin = self.get_user_id_from_email(self.ADMIN_EMAIL)
def test_retrieval_of_collections(self): DCNL DCSP with self.assertRaisesRegexp(Exception, 'Entity DCSP .* DCSP not DCSP found'): DCNL DCSP  DCSP collection_services.get_collection_by_id('fake_eid') DCNL DCSP collection = self.save_new_default_collection(self.COLLECTION_ID, self.owner_id) DCNL DCSP retrieved_collection = collection_services.get_collection_by_id(self.COLLECTION_ID) DCNL DCSP self.assertEqual(collection.id, retrieved_collection.id) DCNL DCSP self.assertEqual(collection.title, retrieved_collection.title) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP collection_services.get_collection_by_id('fake_collection')
def test_soft_deletion_of_collections(self): DCNL DCSP self.save_new_default_collection(self.COLLECTION_ID, self.owner_id) DCNL DCSP self.assertEqual(_count_at_least_editable_collection_summaries(self.owner_id), 1) DCNL DCSP collection_services.delete_collection(self.owner_id, self.COLLECTION_ID) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP collection_services.get_collection_by_id(self.COLLECTION_ID) DCNL DCSP self.assertEqual(_count_at_least_editable_collection_summaries(self.owner_id), 0) DCNL DCSP self.assertIn(self.COLLECTION_ID, [collection.id for collection in collection_models.CollectionModel.get_all(include_deleted=True)]) DCNL DCSP self.assertNotIn(self.COLLECTION_ID, [collection.id for collection in collection_models.CollectionSummaryModel.get_all(include_deleted=True)])
def test_hard_deletion_of_collections(self): DCNL DCSP self.save_new_default_collection(self.COLLECTION_ID, self.owner_id) DCNL DCSP self.assertEqual(_count_at_least_editable_collection_summaries(self.owner_id), 1) DCNL DCSP collection_services.delete_collection(self.owner_id, self.COLLECTION_ID, force_deletion=True) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP collection_services.get_collection_by_id(self.COLLECTION_ID) DCNL DCSP self.assertEqual(_count_at_least_editable_collection_summaries(self.owner_id), 0) DCNL DCSP self.assertNotIn(self.COLLECTION_ID, [collection.id for collection in collection_models.CollectionModel.get_all(include_deleted=True)])
def test_summaries_of_hard_deleted_collections(self): DCNL DCSP self.save_new_default_collection(self.COLLECTION_ID, self.owner_id) DCNL DCSP collection_services.delete_collection(self.owner_id, self.COLLECTION_ID, force_deletion=True) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP collection_services.get_collection_by_id(self.COLLECTION_ID) DCNL DCSP self.assertEqual(_count_at_least_editable_collection_summaries(self.owner_id), 0) DCNL DCSP self.assertNotIn(self.COLLECTION_ID, [collection.id for collection in collection_models.CollectionSummaryModel.get_all(include_deleted=True)])
def test_collections_are_removed_from_index_when_deleted(self): DCNL DCSP self.save_new_default_collection(self.COLLECTION_ID, self.owner_id) DCNL DCSP def mock_delete_docs(doc_ids, index): DCNL DCSP  DCSP self.assertEqual(index, collection_services.SEARCH_INDEX_COLLECTIONS) DCNL DCSP  DCSP self.assertEqual(doc_ids, [self.COLLECTION_ID]) DCNL DCSP delete_docs_swap = self.swap(search_services, 'delete_documents_from_index', mock_delete_docs) DCNL DCSP with delete_docs_swap: DCNL DCSP  DCSP collection_services.delete_collection(self.owner_id, self.COLLECTION_ID)
def test_loading_and_validation_and_deletion_of_demo_collections(self): DCNL DCSP self.assertEqual(collection_models.CollectionModel.get_collection_count(), 0) DCNL DCSP self.assertGreaterEqual(len(feconf.DEMO_COLLECTIONS), 1, msg='There DCSP must DCSP be DCSP at DCSP least DCSP one DCSP demo DCSP collection.') DCNL DCSP for collection_id in feconf.DEMO_COLLECTIONS: DCNL DCSP  DCSP start_time = datetime.datetime.utcnow() DCNL DCSP  DCSP collection_services.load_demo(collection_id) DCNL DCSP  DCSP collection = collection_services.get_collection_by_id(collection_id) DCNL DCSP  DCSP collection.validate() DCNL DCSP  DCSP duration = (datetime.datetime.utcnow() - start_time) DCNL DCSP  DCSP processing_time = (duration.seconds + (duration.microseconds / 1000000.0)) DCNL DCSP  DCSP self.log_line(('Loaded DCSP and DCSP validated DCSP collection DCSP %s DCSP (%.2f DCSP seconds)' % (collection.title.encode('utf-8'), processing_time))) DCNL DCSP self.assertEqual(collection_models.CollectionModel.get_collection_count(), len(feconf.DEMO_COLLECTIONS)) DCNL DCSP for collection_id in feconf.DEMO_COLLECTIONS: DCNL DCSP  DCSP collection_services.delete_demo(collection_id) DCNL DCSP self.assertEqual(collection_models.CollectionModel.get_collection_count(), 0)
def test_add_node_with_private_exploration_in_public_collection(self): DCNL DCSP private_exp_id = 'private_exp_id0' DCNL DCSP self.save_new_valid_exploration(private_exp_id, self.owner_id) DCNL DCSP rights_manager.publish_collection(self.owner_id, self.COLLECTION_ID) DCNL DCSP self.assertTrue(rights_manager.is_collection_public(self.COLLECTION_ID)) DCNL DCSP self.assertTrue(rights_manager.is_exploration_private(private_exp_id)) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Cannot DCSP reference DCSP a DCSP private DCSP exploration DCSP within DCSP a DCSP public DCSP collection'): DCNL DCSP  DCSP collection_services.update_collection(self.owner_id, self.COLLECTION_ID, [{'cmd': collection_domain.CMD_ADD_COLLECTION_NODE, 'exploration_id': private_exp_id}], 'Added DCSP private DCSP exploration')
def test_add_node_with_public_exploration_in_private_collection(self): DCNL DCSP public_exp_id = 'public_exp_id0' DCNL DCSP private_exp_id = 'private_exp_id0' DCNL DCSP self.save_new_valid_exploration(public_exp_id, self.owner_id) DCNL DCSP self.save_new_valid_exploration(private_exp_id, self.owner_id) DCNL DCSP rights_manager.publish_exploration(self.owner_id, public_exp_id) DCNL DCSP self.assertTrue(rights_manager.is_collection_private(self.COLLECTION_ID)) DCNL DCSP self.assertTrue(rights_manager.is_exploration_public(public_exp_id)) DCNL DCSP self.assertTrue(rights_manager.is_exploration_private(private_exp_id)) DCNL DCSP collection_services.update_collection(self.owner_id, self.COLLECTION_ID, [{'cmd': collection_domain.CMD_ADD_COLLECTION_NODE, 'exploration_id': public_exp_id}, {'cmd': collection_domain.CMD_ADD_COLLECTION_NODE, 'exploration_id': private_exp_id}], 'Added DCSP public DCSP and DCSP private DCSP explorations')
def test_record_commit_message(self): DCNL DCSP rights_manager.publish_collection(self.owner_id, self.COLLECTION_ID) DCNL DCSP rights_manager.publish_exploration(self.owner_id, self.EXP_ID) DCNL DCSP collection_services.update_collection(self.owner_id, self.COLLECTION_ID, _get_collection_change_list(collection_domain.COLLECTION_PROPERTY_TITLE, 'New DCSP Title'), 'A DCSP message') DCNL DCSP self.assertEqual(collection_services.get_collection_snapshots_metadata(self.COLLECTION_ID)[1]['commit_message'], 'A DCSP message')
def test_demand_commit_message(self): DCNL DCSP rights_manager.publish_collection(self.owner_id, self.COLLECTION_ID) DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Collection DCSP is DCSP public DCSP so DCSP expected DCSP a DCSP commit DCSP message DCSP but DCSP received DCSP none.'): DCNL DCSP  DCSP collection_services.update_collection(self.owner_id, self.COLLECTION_ID, _get_collection_change_list(collection_domain.COLLECTION_PROPERTY_TITLE, 'New DCSP Title'), '')
def test_unpublished_collections_can_accept_commit_message(self): DCNL DCSP collection_services.update_collection(self.owner_id, self.COLLECTION_ID, _get_collection_change_list(collection_domain.COLLECTION_PROPERTY_TITLE, 'New DCSP Title'), 'A DCSP message') DCNL DCSP collection_services.update_collection(self.owner_id, self.COLLECTION_ID, _get_collection_change_list(collection_domain.COLLECTION_PROPERTY_TITLE, 'New DCSP Title'), '') DCNL DCSP collection_services.update_collection(self.owner_id, self.COLLECTION_ID, _get_collection_change_list(collection_domain.COLLECTION_PROPERTY_TITLE, 'New DCSP Title'), None)
def setUp(self): DCNL DCSP super(CollectionCommitLogUnitTests, self).setUp() DCNL DCSP self.albert_id = self.get_user_id_from_email(self.ALBERT_EMAIL) DCNL DCSP self.bob_id = self.get_user_id_from_email(self.BOB_EMAIL) DCNL DCSP self.signup(self.ALBERT_EMAIL, self.ALBERT_NAME) DCNL DCSP self.signup(self.BOB_EMAIL, self.BOB_NAME) DCNL DCSP @transaction_services.toplevel_wrapper DCNL DCSP def populate_datastore(): DCNL DCSP  DCSP collection_1 = self.save_new_valid_collection(self.COLLECTION_ID_1, self.albert_id) DCNL DCSP  DCSP collection_1.title = 'Exploration DCSP 1 DCSP title' DCNL DCSP  DCSP collection_services._save_collection(self.bob_id, collection_1, 'Changed DCSP title.', _get_collection_change_list('title', 'Exploration DCSP 1 DCSP title')) DCNL DCSP  DCSP collection_2 = self.save_new_valid_collection(self.COLLECTION_ID_2, self.albert_id) DCNL DCSP  DCSP collection_1.title = 'Exploration DCSP 1 DCSP Albert DCSP title' DCNL DCSP  DCSP collection_services._save_collection(self.albert_id, collection_1, 'Changed DCSP title DCSP to DCSP Albert1 DCSP title.', _get_collection_change_list('title', 'Exploration DCSP 1 DCSP Albert DCSP title')) DCNL DCSP  DCSP collection_2.title = 'Exploration DCSP 2 DCSP Albert DCSP title' DCNL DCSP  DCSP collection_services._save_collection(self.albert_id, collection_2, 'Changed DCSP title DCSP to DCSP Albert2.', _get_collection_change_list('title', 'Exploration DCSP 2 DCSP Albert DCSP title')) DCNL DCSP  DCSP collection_services.delete_collection(self.albert_id, self.COLLECTION_ID_1) DCNL DCSP  DCSP with self.assertRaisesRegexp(Exception, 'This DCSP collection DCSP cannot DCSP be DCSP published'): DCNL DCSP  DCSP  DCSP rights_manager.publish_collection(self.bob_id, self.COLLECTION_ID_2) DCNL DCSP  DCSP rights_manager.publish_collection(self.albert_id, self.COLLECTION_ID_2) DCNL DCSP populate_datastore()
def test_answers_across_multiple_exp_versions_different_interactions(self): DCNL DCSP with self.swap(jobs_registry, 'ALL_CONTINUOUS_COMPUTATION_MANAGERS', self.ALL_CC_MANAGERS_FOR_TESTS): DCNL DCSP  DCSP exp_id = 'eid' DCNL DCSP  DCSP exp = self.save_new_valid_exploration(exp_id, 'fake@user.com') DCNL DCSP  DCSP init_state_name = exp.init_state_name DCNL DCSP  DCSP time_spent = 5.0 DCNL DCSP  DCSP params = {} DCNL DCSP  DCSP event_services.AnswerSubmissionEventHandler.record(exp_id, 1, init_state_name, 'TextInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, 'session1', time_spent, params, 'verb') DCNL DCSP  DCSP event_services.AnswerSubmissionEventHandler.record(exp_id, 1, init_state_name, 'TextInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, 'session1', time_spent, params, '2') DCNL DCSP  DCSP event_services.AnswerSubmissionEventHandler.record(exp_id, 1, init_state_name, 'TextInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, 'session1', time_spent, params, 'verb') DCNL DCSP  DCSP exp_services.update_exploration('fake@user.com', exp_id, [{'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY, 'state_name': init_state_name, 'property_name': exp_domain.STATE_PROPERTY_INTERACTION_ID, 'new_value': 'NumericInput'}], 'Change DCSP to DCSP NumericInput') DCNL DCSP  DCSP event_services.AnswerSubmissionEventHandler.record(exp_id, 2, init_state_name, 'NumericInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, 'session1', time_spent, params, 2) DCNL DCSP  DCSP exp_services.update_exploration('fake@user.com', exp_id, [{'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY, 'state_name': init_state_name, 'property_name': exp_domain.STATE_PROPERTY_INTERACTION_ID, 'new_value': 'TextInput'}], 'Change DCSP to DCSP TextInput') DCNL DCSP  DCSP event_services.AnswerSubmissionEventHandler.record(exp_id, 3, init_state_name, 'TextInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, 'session1', time_spent, params, '2') DCNL DCSP  DCSP exp_services.update_exploration('fake@user.com', exp_id, [{'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY, 'state_name': init_state_name, 'property_name': exp_domain.STATE_PROPERTY_CONTENT, 'new_value': {'html': 'New DCSP content DCSP description', 'audio_translations': {}}}], 'Change DCSP content DCSP description') DCNL DCSP  DCSP event_services.AnswerSubmissionEventHandler.record(exp_id, 4, init_state_name, 'TextInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, 'session1', time_spent, params, 'noun') DCNL DCSP  DCSP event_services.AnswerSubmissionEventHandler.record(exp_id, 4, init_state_name, 'TextInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, 'session1', time_spent, params, 'verb') DCNL DCSP  DCSP event_services.AnswerSubmissionEventHandler.record(exp_id, 4, init_state_name, 'TextInput', 0, 0, exp_domain.EXPLICIT_CLASSIFICATION, 'session1', time_spent, params, 'noun') DCNL DCSP  DCSP exp = exp_services.get_exploration_by_id(exp_id) DCNL DCSP  DCSP self.assertEqual(exp.version, 4) DCNL DCSP  DCSP ModifiedInteractionAnswerSummariesAggregator.start_computation() DCNL DCSP  DCSP self.assertEqual(self.count_jobs_in_taskqueue(), 1) DCNL DCSP  DCSP self.process_and_flush_pending_tasks() DCNL DCSP  DCSP self.assertEqual(self.count_jobs_in_taskqueue(), 0) DCNL DCSP  DCSP calc_id = 'Top10AnswerFrequencies' DCNL DCSP  DCSP calc_output_latest_version_domain_object = stats_jobs_continuous.InteractionAnswerSummariesAggregator.get_calc_output(exp_id, init_state_name, calc_id, exploration_version='4') DCNL DCSP  DCSP calc_output_all_domain_object = stats_jobs_continuous.InteractionAnswerSummariesAggregator.get_calc_output(exp_id, init_state_name, calc_id) DCNL DCSP  DCSP self.assertEqual('Top10AnswerFrequencies', calc_output_latest_version_domain_object.calculation_id) DCNL DCSP  DCSP self.assertEqual('Top10AnswerFrequencies', calc_output_all_domain_object.calculation_id) DCNL DCSP  DCSP expected_calculation_latest_version_output = [{'answer': 'noun', 'frequency': 2}, {'answer': 'verb', 'frequency': 1}] DCNL DCSP  DCSP expected_calculation_all_versions_output = [{'answer': 'noun', 'frequency': 2}, {'answer': '2', 'frequency': 1}, {'answer': 'verb', 'frequency': 1}] DCNL DCSP  DCSP calculation_latest_version_output = calc_output_latest_version_domain_object.calculation_output DCNL DCSP  DCSP calculation_output_all = calc_output_all_domain_object.calculation_output DCNL DCSP  DCSP self.assertEqual(calculation_latest_version_output, expected_calculation_latest_version_output) DCNL DCSP  DCSP self.assertEqual(calculation_output_all, expected_calculation_all_versions_output)
def test_param_spec_validation(self): DCNL DCSP param_spec = param_domain.ParamSpec('FakeType') DCNL DCSP with self.assertRaisesRegexp(TypeError, "'FakeType' DCSP is DCSP not DCSP a DCSP valid DCSP object DCSP class."): DCNL DCSP  DCSP param_spec.validate() DCNL DCSP param_spec.obj_type = 'Real' DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, "Only DCSP 'UnicodeString' DCSP is DCSP the DCSP supported DCSP object DCSP type DCSP for DCSP parameters, DCSP not: DCSP Real"): DCNL DCSP  DCSP param_spec.validate() DCNL DCSP param_spec.obj_type = 'UnicodeString' DCNL DCSP param_spec.validate()
def test_param_change_validation(self): DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Only DCSP parameter DCSP names'): DCNL DCSP  DCSP param_domain.ParamChange('\xc2\xa1hola', 'Copier', {}).validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP generator DCSP id'): DCNL DCSP  DCSP param_domain.ParamChange('abc', 'InvalidGenerator', {}).validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP a DCSP dict'): DCNL DCSP  DCSP param_domain.ParamChange('abc', 'Copier', ['a', 'b']).validate()
def test_param_change_class(self): DCNL DCSP param_change = param_domain.ParamChange('abc', 'Copier', {'value': '3'}) DCNL DCSP self.assertEqual(param_change.name, 'abc') DCNL DCSP self.assertEqual(param_change.generator.id, 'Copier') DCNL DCSP self.assertEqual(param_change.to_dict(), {'name': 'abc', 'generator_id': 'Copier', 'customization_args': {'value': '3'}}) DCNL DCSP self.assertEqual(param_change.get_normalized_value('Int', {}), 3)
def __init__(self, obj_type): DCNL DCSP self.obj_type = obj_type
def to_dict(self): DCNL DCSP return {'obj_type': self.obj_type}
@classmethod DCNL def from_dict(cls, param_spec_dict): DCNL DCSP return cls(param_spec_dict['obj_type'])
def validate(self): DCNL DCSP obj_services.Registry.get_object_class_by_type(self.obj_type) DCNL DCSP if (self.obj_type != 'UnicodeString'): DCNL DCSP  DCSP raise utils.ValidationError(("Only DCSP 'UnicodeString' DCSP is DCSP the DCSP supported DCSP object DCSP type DCSP for DCSP parameters, DCSP not: DCSP %s" % self.obj_type))
def __init__(self, name, generator_id, customization_args): DCNL DCSP self._name = name DCNL DCSP self._generator_id = generator_id DCNL DCSP self._customization_args = customization_args
@property DCNL def name(self): DCNL DCSP return self._name
@property DCNL def generator(self): DCNL DCSP return value_generators_domain.Registry.get_generator_class_by_id(self._generator_id)()
@property DCNL def customization_args(self): DCNL DCSP return self._customization_args
@classmethod DCNL def from_dict(cls, param_change_dict): DCNL DCSP return cls(param_change_dict['name'], param_change_dict['generator_id'], param_change_dict['customization_args'])
def _get_value(self, context_params): DCNL DCSP return self.generator.generate_value(context_params, **self.customization_args)
def get_normalized_value(self, obj_type, context_params): DCNL DCSP raw_value = self._get_value(context_params) DCNL DCSP return obj_services.Registry.get_object_class_by_type(obj_type).normalize(raw_value)
def validate(self): DCNL DCSP if (not isinstance(self.name, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP param_change DCSP name DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.name)) DCNL DCSP if (not re.match(feconf.ALPHANUMERIC_REGEX, self.name)): DCNL DCSP  DCSP raise utils.ValidationError('Only DCSP parameter DCSP names DCSP with DCSP characters DCSP in DCSP [a-zA-Z0-9] DCSP are DCSP accepted.') DCNL DCSP try: DCNL DCSP  DCSP self.generator DCNL DCSP except KeyError: DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP generator DCSP id DCSP %s' % self._generator_id)) DCNL DCSP except Exception: DCNL DCSP  DCSP raise utils.ValidationError(('Generator DCSP %s DCSP is DCSP not DCSP a DCSP valid DCSP generator DCSP for DCSP exploration DCSP parameters. DCSP Valid DCSP generators DCSP must DCSP not DCSP require DCSP any DCSP initialization DCSP arguments.' % self._generator_id)) DCNL DCSP if (not isinstance(self.customization_args, dict)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP a DCSP dict DCSP of DCSP customization_args, DCSP received DCSP %s' % self.customization_args)) DCNL DCSP for arg_name in self.customization_args: DCNL DCSP  DCSP if (not isinstance(arg_name, basestring)): DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP parameter DCSP change DCSP customization_arg DCSP name: DCSP %s' % arg_name))
@classmethod DCNL def get_all_gadget_types(cls): DCNL DCSP if (len(cls._gadgets) == 0): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._gadgets.keys()
@classmethod DCNL def get_all_gadgets(cls): DCNL DCSP if (len(cls._gadgets) == 0): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._gadgets.values()
@classmethod DCNL def get_gadget_by_type(cls, gadget_type): DCNL DCSP if (gadget_type not in cls._gadgets): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._gadgets[gadget_type]
@classmethod DCNL def get_gadget_html(cls, gadget_types): DCNL DCSP return ' DCSP \n'.join([cls.get_gadget_by_type(gadget_type).html_body for gadget_type in gadget_types])
@classmethod DCNL def get_deduplicated_dependency_ids(cls, gadget_types): DCNL DCSP result = set([]) DCNL DCSP for gadget_type in gadget_types: DCNL DCSP  DCSP gadget = cls.get_gadget_by_type(gadget_type) DCNL DCSP  DCSP result.update(gadget.dependency_ids) DCNL DCSP return list(result)
@classmethod DCNL def get_all_specs(cls): DCNL DCSP return {gadget.type: gadget.to_dict() for gadget in cls.get_all_gadgets()}
def test_sending_email_with_different_recipient_but_same_hash(self): DCNL DCSP can_send_emails_ctx = self.swap(feconf, 'CAN_SEND_EMAILS', True) DCNL DCSP duplicate_email_ctx = self.swap(feconf, 'DUPLICATE_EMAIL_INTERVAL_MINS', 2) DCNL DCSP with can_send_emails_ctx: DCNL DCSP  DCSP with duplicate_email_ctx: DCNL DCSP  DCSP  DCSP with self.generate_hash_ctx: DCNL DCSP  DCSP  DCSP  DCSP all_models = email_models.SentEmailModel.get_all().fetch() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(len(all_models), 0) DCNL DCSP  DCSP  DCSP  DCSP email_models.SentEmailModel.create('recipient_id', self.NEW_USER_EMAIL, feconf.SYSTEM_COMMITTER_ID, feconf.SYSTEM_EMAIL_ADDRESS, feconf.EMAIL_INTENT_SIGNUP, 'Email DCSP Subject', 'Email DCSP Body', datetime.datetime.utcnow()) DCNL DCSP  DCSP  DCSP  DCSP all_models = email_models.SentEmailModel.get_all().fetch() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(len(all_models), 1) DCNL DCSP  DCSP  DCSP  DCSP email_manager._send_email(self.new_user_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_SIGNUP, 'Email DCSP Subject', 'Email DCSP Body', feconf.SYSTEM_EMAIL_ADDRESS) DCNL DCSP  DCSP  DCSP  DCSP messages = self.mail_stub.get_sent_messages(to=self.NEW_USER_EMAIL) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(1, len(messages)) DCNL DCSP  DCSP  DCSP  DCSP all_models = email_models.SentEmailModel.get_all().fetch() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(len(all_models), 2) DCNL DCSP  DCSP  DCSP  DCSP sent_email_model1 = all_models[0] DCNL DCSP  DCSP  DCSP  DCSP sent_email_model2 = all_models[1] DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sent_email_model1.email_hash, sent_email_model2.email_hash) DCNL DCSP  DCSP  DCSP  DCSP self.assertNotEqual(sent_email_model1.recipient_id, sent_email_model2.recipient_id) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sent_email_model1.subject, sent_email_model2.subject) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sent_email_model1.html_body, sent_email_model2.html_body)
def test_sending_email_with_different_subject_but_same_hash(self): DCNL DCSP can_send_emails_ctx = self.swap(feconf, 'CAN_SEND_EMAILS', True) DCNL DCSP duplicate_email_ctx = self.swap(feconf, 'DUPLICATE_EMAIL_INTERVAL_MINS', 2) DCNL DCSP with can_send_emails_ctx: DCNL DCSP  DCSP with duplicate_email_ctx: DCNL DCSP  DCSP  DCSP with self.generate_hash_ctx: DCNL DCSP  DCSP  DCSP  DCSP all_models = email_models.SentEmailModel.get_all().fetch() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(len(all_models), 0) DCNL DCSP  DCSP  DCSP  DCSP email_models.SentEmailModel.create(self.new_user_id, self.NEW_USER_EMAIL, feconf.SYSTEM_COMMITTER_ID, feconf.SYSTEM_EMAIL_ADDRESS, feconf.EMAIL_INTENT_SIGNUP, 'Email DCSP Subject1', 'Email DCSP Body', datetime.datetime.utcnow()) DCNL DCSP  DCSP  DCSP  DCSP all_models = email_models.SentEmailModel.get_all().fetch() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(len(all_models), 1) DCNL DCSP  DCSP  DCSP  DCSP email_manager._send_email(self.new_user_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_SIGNUP, 'Email DCSP Subject', 'Email DCSP Body', feconf.SYSTEM_EMAIL_ADDRESS) DCNL DCSP  DCSP  DCSP  DCSP messages = self.mail_stub.get_sent_messages(to=self.NEW_USER_EMAIL) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(1, len(messages)) DCNL DCSP  DCSP  DCSP  DCSP all_models = email_models.SentEmailModel.get_all().fetch() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(len(all_models), 2) DCNL DCSP  DCSP  DCSP  DCSP sent_email_model1 = all_models[0] DCNL DCSP  DCSP  DCSP  DCSP sent_email_model2 = all_models[1] DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sent_email_model1.email_hash, sent_email_model2.email_hash) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sent_email_model1.recipient_id, sent_email_model2.recipient_id) DCNL DCSP  DCSP  DCSP  DCSP self.assertNotEqual(sent_email_model1.subject, sent_email_model2.subject) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sent_email_model1.html_body, sent_email_model2.html_body)
def test_sending_email_with_different_body_but_same_hash(self): DCNL DCSP can_send_emails_ctx = self.swap(feconf, 'CAN_SEND_EMAILS', True) DCNL DCSP duplicate_email_ctx = self.swap(feconf, 'DUPLICATE_EMAIL_INTERVAL_MINS', 2) DCNL DCSP with can_send_emails_ctx: DCNL DCSP  DCSP with duplicate_email_ctx: DCNL DCSP  DCSP  DCSP with self.generate_hash_ctx: DCNL DCSP  DCSP  DCSP  DCSP all_models = email_models.SentEmailModel.get_all().fetch() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(len(all_models), 0) DCNL DCSP  DCSP  DCSP  DCSP email_models.SentEmailModel.create(self.new_user_id, self.NEW_USER_EMAIL, feconf.SYSTEM_COMMITTER_ID, feconf.SYSTEM_EMAIL_ADDRESS, feconf.EMAIL_INTENT_SIGNUP, 'Email DCSP Subject', 'Email DCSP Body1', datetime.datetime.utcnow()) DCNL DCSP  DCSP  DCSP  DCSP all_models = email_models.SentEmailModel.get_all().fetch() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(len(all_models), 1) DCNL DCSP  DCSP  DCSP  DCSP email_manager._send_email(self.new_user_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_SIGNUP, 'Email DCSP Subject', 'Email DCSP Body', feconf.SYSTEM_EMAIL_ADDRESS) DCNL DCSP  DCSP  DCSP  DCSP messages = self.mail_stub.get_sent_messages(to=self.NEW_USER_EMAIL) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(1, len(messages)) DCNL DCSP  DCSP  DCSP  DCSP all_models = email_models.SentEmailModel.get_all().fetch() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(len(all_models), 2) DCNL DCSP  DCSP  DCSP  DCSP sent_email_model1 = all_models[0] DCNL DCSP  DCSP  DCSP  DCSP sent_email_model2 = all_models[1] DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sent_email_model1.email_hash, sent_email_model2.email_hash) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sent_email_model1.recipient_id, sent_email_model2.recipient_id) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sent_email_model1.subject, sent_email_model2.subject) DCNL DCSP  DCSP  DCSP  DCSP self.assertNotEqual(sent_email_model1.html_body, sent_email_model2.html_body)
def test_migration_job_does_not_convert_up_to_date_collection(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection(self.COLLECTION_ID, 'A DCSP title', 'A DCSP Category', 'An DCSP Objective') DCNL DCSP collection_services.save_new_collection(self.albert_id, collection) DCNL DCSP self.assertEqual(collection.schema_version, feconf.CURRENT_COLLECTION_SCHEMA_VERSION) DCNL DCSP yaml_before_migration = collection.to_yaml() DCNL DCSP job_id = collection_jobs_one_off.CollectionMigrationJob.create_new() DCNL DCSP collection_jobs_one_off.CollectionMigrationJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP updated_collection = collection_services.get_collection_by_id(self.COLLECTION_ID) DCNL DCSP self.assertEqual(updated_collection.schema_version, feconf.CURRENT_COLLECTION_SCHEMA_VERSION) DCNL DCSP after_converted_yaml = updated_collection.to_yaml() DCNL DCSP self.assertEqual(after_converted_yaml, yaml_before_migration)
def test_migration_job_skips_deleted_collection(self): DCNL DCSP collection = collection_domain.Collection.create_default_collection(self.COLLECTION_ID, 'A DCSP title', 'A DCSP Category', 'An DCSP Objective') DCNL DCSP collection_services.save_new_collection(self.albert_id, collection) DCNL DCSP collection_services.create_collection_summary(self.COLLECTION_ID, None) DCNL DCSP collection_services.delete_collection(self.albert_id, self.COLLECTION_ID) DCNL DCSP with self.assertRaisesRegexp(Exception, 'Entity DCSP .* DCSP not DCSP found'): DCNL DCSP  DCSP collection_services.get_collection_by_id(self.COLLECTION_ID) DCNL DCSP job_id = collection_jobs_one_off.CollectionMigrationJob.create_new() DCNL DCSP collection_jobs_one_off.CollectionMigrationJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP with self.assertRaisesRegexp(Exception, 'Entity DCSP .* DCSP not DCSP found'): DCNL DCSP  DCSP collection_services.get_collection_by_id(self.COLLECTION_ID)
def test_migrate_colections_failing_strict_validation(self): DCNL DCSP collection_title = 'A DCSP title' DCNL DCSP collection_category = 'A DCSP category' DCNL DCSP rights_manager.create_new_collection_rights(self.COLLECTION_ID, self.albert_id) DCNL DCSP model = collection_models.CollectionModel(id=self.COLLECTION_ID, category=collection_title, title=collection_category, objective='', tags=[], schema_version=2) DCNL DCSP model.commit(self.albert_id, 'Made DCSP a DCSP new DCSP collection!', [{'cmd': collection_services.CMD_CREATE_NEW, 'title': collection_title, 'category': collection_category}]) DCNL DCSP job_id = collection_jobs_one_off.CollectionMigrationJob.create_new() DCNL DCSP collection_jobs_one_off.CollectionMigrationJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP new_model = collection_models.CollectionModel.get(self.COLLECTION_ID) DCNL DCSP self.assertEqual(new_model.schema_version, feconf.CURRENT_COLLECTION_SCHEMA_VERSION)
def test_migration_job_migrates_collection_nodes(self): DCNL DCSP self.save_new_default_exploration(self.EXP_ID, self.albert_id) DCNL DCSP node = collection_domain.CollectionNode.create_default_node(self.EXP_ID) DCNL DCSP collection_title = 'A DCSP title' DCNL DCSP collection_category = 'A DCSP category' DCNL DCSP rights_manager.create_new_collection_rights(self.COLLECTION_ID, self.albert_id) DCNL DCSP model = collection_models.CollectionModel(id=self.COLLECTION_ID, category=collection_category, title=collection_title, objective='An DCSP objective', tags=[], schema_version=2, nodes=[{'exploration_id': self.EXP_ID, 'prerequisite_skills': [], 'acquired_skills': []}]) DCNL DCSP model.commit(self.albert_id, 'Made DCSP a DCSP new DCSP collection!', [{'cmd': collection_services.CMD_CREATE_NEW, 'title': collection_title, 'category': collection_category}]) DCNL DCSP self.assertEqual(model.collection_contents, {}) DCNL DCSP job_id = collection_jobs_one_off.CollectionMigrationJob.create_new() DCNL DCSP collection_jobs_one_off.CollectionMigrationJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP new_model = collection_models.CollectionModel.get(self.COLLECTION_ID) DCNL DCSP self.assertEqual(new_model.collection_contents, {'nodes': [node.to_dict()], 'skills': {}, 'next_skill_id': 0})
def test_dicts_have_same_keys(self): DCNL DCSP self.assertEqual(set(self.PARENT_ROLES.keys()), set(self.ACTIONS.keys()))
def test_dicts_have_list_value(self): DCNL DCSP for role_name in self.PARENT_ROLES: DCNL DCSP  DCSP self.assertTrue(isinstance(self.PARENT_ROLES[role_name], list)) DCNL DCSP for role_name in self.ACTIONS: DCNL DCSP  DCSP self.assertTrue(isinstance(self.ACTIONS[role_name], list))
def test_every_dict_entry_is_string(self): DCNL DCSP for role_name in self.PARENT_ROLES: DCNL DCSP  DCSP self.assertTrue(isinstance(role_name, str)) DCNL DCSP  DCSP for role in self.PARENT_ROLES[role_name]: DCNL DCSP  DCSP  DCSP self.assertTrue(isinstance(role, str)) DCNL DCSP for role_name in self.ACTIONS: DCNL DCSP  DCSP self.assertTrue(isinstance(role_name, str)) DCNL DCSP  DCSP for action_name in self.ACTIONS[role_name]: DCNL DCSP  DCSP  DCSP self.assertTrue(isinstance(action_name, str))
def test_valid_parents(self): DCNL DCSP valid_roles = self.PARENT_ROLES.keys() DCNL DCSP for role_name in self.PARENT_ROLES: DCNL DCSP  DCSP for role in self.PARENT_ROLES[role_name]: DCNL DCSP  DCSP  DCSP self.assertIn(role, valid_roles)
def test_that_role_graph_has_no_directed_cycles(self): DCNL DCSP visited = set() DCNL DCSP def check_cycle(source, roles): DCNL DCSP  DCSP 'Checks DCSP that DCSP source DCSP is DCSP not DCSP reachable DCSP from DCSP any DCSP of DCSP the DCSP given DCSP roles.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Args DCSP :\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP source: DCSP str. DCSP Role DCSP that DCSP should DCSP not DCSP be DCSP reachable DCSP via DCSP any DCSP path\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP roles.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP roles: DCSP list(str). DCSP List DCSP of DCSP roles DCSP that DCSP should DCSP not DCSP be DCSP able DCSP to\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reach DCSP source.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP for role in roles: DCNL DCSP  DCSP  DCSP self.assertNotEqual(role, source) DCNL DCSP  DCSP  DCSP if (role not in visited): DCNL DCSP  DCSP  DCSP  DCSP visited.add(role) DCNL DCSP  DCSP  DCSP  DCSP check_cycle(source, self.PARENT_ROLES[role]) DCNL DCSP for role_name in self.PARENT_ROLES: DCNL DCSP  DCSP visited = set() DCNL DCSP  DCSP check_cycle(role_name, self.PARENT_ROLES[role_name])
def test_get_all_actions(self): DCNL DCSP with self.assertRaisesRegexp(Exception, 'Role DCSP TEST_ROLE DCSP does DCSP not DCSP exist.'): DCNL DCSP  DCSP role_services.get_all_actions('TEST_ROLE') DCNL DCSP collection_editor_actions = list((((set(role_services.ROLE_ACTIONS[feconf.ROLE_ID_EXPLORATION_EDITOR]) | set(role_services.ROLE_ACTIONS[feconf.ROLE_ID_BANNED_USER])) | set(role_services.ROLE_ACTIONS[feconf.ROLE_ID_GUEST])) | set(role_services.ROLE_ACTIONS[feconf.ROLE_ID_COLLECTION_EDITOR]))) DCNL DCSP self.assertEqual(set(collection_editor_actions), set(role_services.get_all_actions(feconf.ROLE_ID_COLLECTION_EDITOR)))
def __init__(self, change_dict): DCNL DCSP if ('cmd' not in change_dict): DCNL DCSP  DCSP raise Exception(('Invalid DCSP change_dict: DCSP %s' % change_dict)) DCNL DCSP self.cmd = change_dict['cmd'] DCNL DCSP if (self.cmd == CMD_ADD_COLLECTION_NODE): DCNL DCSP  DCSP self.exploration_id = change_dict['exploration_id'] DCNL DCSP elif (self.cmd == CMD_DELETE_COLLECTION_NODE): DCNL DCSP  DCSP self.exploration_id = change_dict['exploration_id'] DCNL DCSP elif (self.cmd == CMD_EDIT_COLLECTION_NODE_PROPERTY): DCNL DCSP  DCSP if (change_dict['property_name'] not in self.COLLECTION_NODE_PROPERTIES): DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP change_dict: DCSP %s' % change_dict)) DCNL DCSP  DCSP self.exploration_id = change_dict['exploration_id'] DCNL DCSP  DCSP self.property_name = change_dict['property_name'] DCNL DCSP  DCSP self.new_value = change_dict['new_value'] DCNL DCSP  DCSP self.old_value = change_dict.get('old_value') DCNL DCSP elif (self.cmd == CMD_EDIT_COLLECTION_PROPERTY): DCNL DCSP  DCSP if (change_dict['property_name'] not in self.COLLECTION_PROPERTIES): DCNL DCSP  DCSP  DCSP raise Exception(('Invalid DCSP change_dict: DCSP %s' % change_dict)) DCNL DCSP  DCSP self.property_name = change_dict['property_name'] DCNL DCSP  DCSP self.new_value = change_dict['new_value'] DCNL DCSP  DCSP self.old_value = change_dict.get('old_value') DCNL DCSP elif (self.cmd == CMD_MIGRATE_SCHEMA_TO_LATEST_VERSION): DCNL DCSP  DCSP self.from_version = change_dict['from_version'] DCNL DCSP  DCSP self.to_version = change_dict['to_version'] DCNL DCSP elif (self.cmd == CMD_ADD_COLLECTION_SKILL): DCNL DCSP  DCSP self.name = change_dict['name'] DCNL DCSP elif (self.cmd == CMD_DELETE_COLLECTION_SKILL): DCNL DCSP  DCSP self.skill_id = change_dict['skill_id'] DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Invalid DCSP change_dict: DCSP %s' % change_dict))
def __init__(self, created_on, last_updated, user_id, username, collection_id, commit_type, commit_message, commit_cmds, version, post_commit_status, post_commit_community_owned, post_commit_is_private): DCNL DCSP self.created_on = created_on DCNL DCSP self.last_updated = last_updated DCNL DCSP self.user_id = user_id DCNL DCSP self.username = username DCNL DCSP self.collection_id = collection_id DCNL DCSP self.commit_type = commit_type DCNL DCSP self.commit_message = commit_message DCNL DCSP self.commit_cmds = commit_cmds DCNL DCSP self.version = version DCNL DCSP self.post_commit_status = post_commit_status DCNL DCSP self.post_commit_community_owned = post_commit_community_owned DCNL DCSP self.post_commit_is_private = post_commit_is_private
def to_dict(self): DCNL DCSP return {'last_updated': utils.get_time_in_millisecs(self.last_updated), 'username': self.username, 'collection_id': self.collection_id, 'commit_type': self.commit_type, 'commit_message': self.commit_message, 'version': self.version, 'post_commit_status': self.post_commit_status, 'post_commit_community_owned': self.post_commit_community_owned, 'post_commit_is_private': self.post_commit_is_private}
def __init__(self, exploration_id, prerequisite_skill_ids, acquired_skill_ids): DCNL DCSP self.exploration_id = exploration_id DCNL DCSP self.prerequisite_skill_ids = prerequisite_skill_ids DCNL DCSP self.acquired_skill_ids = acquired_skill_ids
def to_dict(self): DCNL DCSP return {'exploration_id': self.exploration_id, 'prerequisite_skill_ids': self.prerequisite_skill_ids, 'acquired_skill_ids': self.acquired_skill_ids}
@classmethod DCNL def from_dict(cls, node_dict): DCNL DCSP return cls(copy.deepcopy(node_dict['exploration_id']), copy.deepcopy(node_dict['prerequisite_skill_ids']), copy.deepcopy(node_dict['acquired_skill_ids']))
@property DCNL def skills(self): DCNL DCSP return (set(self.prerequisite_skill_ids) | set(self.acquired_skill_ids))
def update_prerequisite_skill_ids(self, prerequisite_skill_ids): DCNL DCSP self.prerequisite_skill_ids = copy.deepcopy(prerequisite_skill_ids)
def update_acquired_skill_ids(self, acquired_skill_ids): DCNL DCSP self.acquired_skill_ids = copy.deepcopy(acquired_skill_ids)
def validate(self): DCNL DCSP if (not isinstance(self.exploration_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP exploration DCSP ID DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.exploration_id)) DCNL DCSP if (not isinstance(self.prerequisite_skill_ids, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP prerequisite_skill_ids DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.prerequisite_skill_ids)) DCNL DCSP if (len(set(self.prerequisite_skill_ids)) != len(self.prerequisite_skill_ids)): DCNL DCSP  DCSP raise utils.ValidationError(('The DCSP prerequisite_skill_ids DCSP list DCSP has DCSP duplicate DCSP entries: DCSP %s' % self.prerequisite_skill_ids)) DCNL DCSP for skill_id in self.prerequisite_skill_ids: DCNL DCSP  DCSP CollectionSkill.validate_skill_id(skill_id) DCNL DCSP if (not isinstance(self.acquired_skill_ids, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP acquired_skill_ids DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.acquired_skill_ids)) DCNL DCSP if (len(set(self.acquired_skill_ids)) != len(self.acquired_skill_ids)): DCNL DCSP  DCSP raise utils.ValidationError(('The DCSP acquired_skill_ids DCSP list DCSP has DCSP duplicate DCSP entries: DCSP %s' % self.acquired_skill_ids)) DCNL DCSP for skill_id in self.acquired_skill_ids: DCNL DCSP  DCSP CollectionSkill.validate_skill_id(skill_id) DCNL DCSP redundant_skills = (set(self.prerequisite_skill_ids) & set(self.acquired_skill_ids)) DCNL DCSP if redundant_skills: DCNL DCSP  DCSP raise utils.ValidationError(('There DCSP are DCSP some DCSP skills DCSP which DCSP are DCSP both DCSP required DCSP for DCSP exploration DCSP %s DCSP and DCSP acquired DCSP after DCSP playing DCSP it: DCSP %s' % (self.exploration_id, redundant_skills)))
@classmethod DCNL def create_default_node(cls, exploration_id): DCNL DCSP return cls(exploration_id, [], [])
def __init__(self, skill_id, name, question_ids): DCNL DCSP self.id = skill_id DCNL DCSP self.name = name DCNL DCSP self.question_ids = question_ids
def validate(self): DCNL DCSP if (not isinstance(self.name, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP skill DCSP name DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.name)) DCNL DCSP utils.require_valid_name(self.name, 'the DCSP skill DCSP name', allow_empty=False) DCNL DCSP self.validate_skill_id(self.id) DCNL DCSP if (not isinstance(self.question_ids, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP question DCSP IDs DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.question_ids)) DCNL DCSP for question_id in self.question_ids: DCNL DCSP  DCSP if (not isinstance(question_id, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP all DCSP question_ids DCSP to DCSP be DCSP strings, DCSP received DCSP %s' % question_id)) DCNL DCSP if (len(set(self.question_ids)) != len(self.question_ids)): DCNL DCSP  DCSP raise utils.ValidationError('The DCSP question_ids DCSP list DCSP has DCSP duplicate DCSP entries.')
def __init__(self, collection_id, title, category, objective, language_code, tags, schema_version, nodes, skills, next_skill_id, version, created_on=None, last_updated=None): DCNL DCSP self.id = collection_id DCNL DCSP self.title = title DCNL DCSP self.category = category DCNL DCSP self.objective = objective DCNL DCSP self.language_code = language_code DCNL DCSP self.tags = tags DCNL DCSP self.schema_version = schema_version DCNL DCSP self.nodes = nodes DCNL DCSP self.skills = skills DCNL DCSP self.next_skill_id = next_skill_id DCNL DCSP self.version = version DCNL DCSP self.created_on = created_on DCNL DCSP self.last_updated = last_updated
def to_dict(self): DCNL DCSP return {'id': self.id, 'title': self.title, 'category': self.category, 'objective': self.objective, 'language_code': self.language_code, 'tags': self.tags, 'schema_version': self.schema_version, 'nodes': [node.to_dict() for node in self.nodes], 'next_skill_id': self.next_skill_id, 'skills': {skill_id: skill.to_dict() for (skill_id, skill) in self.skills.iteritems()}}
@classmethod DCNL def create_default_collection(cls, collection_id, title=feconf.DEFAULT_COLLECTION_TITLE, category=feconf.DEFAULT_COLLECTION_CATEGORY, objective=feconf.DEFAULT_COLLECTION_OBJECTIVE, language_code=constants.DEFAULT_LANGUAGE_CODE): DCNL DCSP return cls(collection_id, title, category, objective, language_code, [], feconf.CURRENT_COLLECTION_SCHEMA_VERSION, [], {}, 0, 0)
@classmethod DCNL def from_dict(cls, collection_dict, collection_version=0, collection_created_on=None, collection_last_updated=None): DCNL DCSP collection = cls(collection_dict['id'], collection_dict['title'], collection_dict['category'], collection_dict['objective'], collection_dict['language_code'], collection_dict['tags'], collection_dict['schema_version'], [CollectionNode.from_dict(node_dict) for node_dict in collection_dict['nodes']], {skill_id: CollectionSkill.from_dict(skill_id, skill_dict) for (skill_id, skill_dict) in collection_dict['skills'].iteritems()}, collection_dict['next_skill_id'], collection_version, collection_created_on, collection_last_updated) DCNL DCSP return collection
def to_yaml(self): DCNL DCSP collection_dict = self.to_dict() DCNL DCSP del collection_dict['id'] DCNL DCSP return utils.yaml_from_dict(collection_dict)
@classmethod DCNL def _convert_v1_dict_to_v2_dict(cls, collection_dict): DCNL DCSP collection_dict['schema_version'] = 2 DCNL DCSP collection_dict['language_code'] = constants.DEFAULT_LANGUAGE_CODE DCNL DCSP collection_dict['tags'] = [] DCNL DCSP return collection_dict
@classmethod DCNL def _convert_v2_dict_to_v3_dict(cls, collection_dict): DCNL DCSP collection_dict['schema_version'] = 3 DCNL DCSP return collection_dict
@classmethod DCNL def _convert_v3_dict_to_v4_dict(cls, collection_dict): DCNL DCSP new_collection_dict = cls._convert_collection_contents_v3_dict_to_v4_dict(collection_dict) DCNL DCSP collection_dict['nodes'] = new_collection_dict['nodes'] DCNL DCSP collection_dict['skills'] = new_collection_dict['skills'] DCNL DCSP collection_dict['next_skill_id'] = new_collection_dict['next_skill_id'] DCNL DCSP collection_dict['schema_version'] = 4 DCNL DCSP return collection_dict
@classmethod DCNL def _migrate_to_latest_yaml_version(cls, yaml_content): DCNL DCSP try: DCNL DCSP  DCSP collection_dict = utils.dict_from_yaml(yaml_content) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise Exception(('Please DCSP ensure DCSP that DCSP you DCSP are DCSP uploading DCSP a DCSP YAML DCSP text DCSP file, DCSP not DCSP a DCSP zip DCSP file. DCSP The DCSP YAML DCSP parser DCSP returned DCSP the DCSP following DCSP error: DCSP %s' % e)) DCNL DCSP collection_schema_version = collection_dict.get('schema_version') DCNL DCSP if (collection_schema_version is None): DCNL DCSP  DCSP raise Exception('Invalid DCSP YAML DCSP file: DCSP no DCSP schema DCSP version DCSP specified.') DCNL DCSP if (not (1 <= collection_schema_version <= feconf.CURRENT_COLLECTION_SCHEMA_VERSION)): DCNL DCSP  DCSP raise Exception(('Sorry, DCSP we DCSP can DCSP only DCSP process DCSP v1 DCSP to DCSP v%s DCSP collection DCSP YAML DCSP files DCSP at DCSP present.' % feconf.CURRENT_COLLECTION_SCHEMA_VERSION)) DCNL DCSP while (collection_schema_version < feconf.CURRENT_COLLECTION_SCHEMA_VERSION): DCNL DCSP  DCSP conversion_fn = getattr(cls, ('_convert_v%s_dict_to_v%s_dict' % (collection_schema_version, (collection_schema_version + 1)))) DCNL DCSP  DCSP collection_dict = conversion_fn(collection_dict) DCNL DCSP  DCSP collection_schema_version += 1 DCNL DCSP return collection_dict
@classmethod DCNL def from_yaml(cls, collection_id, yaml_content): DCNL DCSP collection_dict = cls._migrate_to_latest_yaml_version(yaml_content) DCNL DCSP collection_dict['id'] = collection_id DCNL DCSP return Collection.from_dict(collection_dict)
@classmethod DCNL def _convert_collection_contents_v1_dict_to_v2_dict(cls, collection_contents): DCNL DCSP return collection_contents
@classmethod DCNL def _convert_collection_contents_v2_dict_to_v3_dict(cls, collection_contents): DCNL DCSP return collection_contents
@classmethod DCNL def _convert_collection_contents_v3_dict_to_v4_dict(cls, collection_contents): DCNL DCSP skill_names = set() DCNL DCSP for node in collection_contents['nodes']: DCNL DCSP  DCSP skill_names.update(node['acquired_skills']) DCNL DCSP  DCSP skill_names.update(node['prerequisite_skills']) DCNL DCSP skill_names_to_ids = {name: CollectionSkill.get_skill_id_from_index(index) for (index, name) in enumerate(sorted(skill_names))} DCNL DCSP collection_contents['nodes'] = [{'exploration_id': node['exploration_id'], 'prerequisite_skill_ids': [skill_names_to_ids[prerequisite_skill_name] for prerequisite_skill_name in node['prerequisite_skills']], 'acquired_skill_ids': [skill_names_to_ids[acquired_skill_name] for acquired_skill_name in node['acquired_skills']]} for node in collection_contents['nodes']] DCNL DCSP collection_contents['skills'] = {skill_id: {'name': skill_name, 'question_ids': []} for (skill_name, skill_id) in skill_names_to_ids.iteritems()} DCNL DCSP collection_contents['next_skill_id'] = len(skill_names) DCNL DCSP return collection_contents
@classmethod DCNL def update_collection_contents_from_model(cls, versioned_collection_contents, current_version): DCNL DCSP if ((versioned_collection_contents['schema_version'] + 1) > feconf.CURRENT_COLLECTION_SCHEMA_VERSION): DCNL DCSP  DCSP raise Exception(('Collection DCSP is DCSP version DCSP %d DCSP but DCSP current DCSP collection DCSP schema DCSP version DCSP is DCSP %d' % (versioned_collection_contents['schema_version'], feconf.CURRENT_COLLECTION_SCHEMA_VERSION))) DCNL DCSP versioned_collection_contents['schema_version'] = (current_version + 1) DCNL DCSP conversion_fn = getattr(cls, ('_convert_collection_contents_v%s_dict_to_v%s_dict' % (current_version, (current_version + 1)))) DCNL DCSP versioned_collection_contents['collection_contents'] = conversion_fn(versioned_collection_contents['collection_contents'])
@property DCNL def exploration_ids(self): DCNL DCSP return [node.exploration_id for node in self.nodes]
@property DCNL def init_exploration_ids(self): DCNL DCSP init_exp_ids = [] DCNL DCSP for node in self.nodes: DCNL DCSP  DCSP if (not node.prerequisite_skill_ids): DCNL DCSP  DCSP  DCSP init_exp_ids.append(node.exploration_id) DCNL DCSP return init_exp_ids
def get_next_exploration_ids(self, completed_exploration_ids): DCNL DCSP acquired_skill_ids = set() DCNL DCSP for completed_exp_id in completed_exploration_ids: DCNL DCSP  DCSP collection_node = self.get_node(completed_exp_id) DCNL DCSP  DCSP if collection_node: DCNL DCSP  DCSP  DCSP acquired_skill_ids.update(collection_node.acquired_skill_ids) DCNL DCSP next_exp_ids = [] DCNL DCSP for node in self.nodes: DCNL DCSP  DCSP if (node.exploration_id in completed_exploration_ids): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP prereq_skill_ids = set(node.prerequisite_skill_ids) DCNL DCSP  DCSP if (prereq_skill_ids <= acquired_skill_ids): DCNL DCSP  DCSP  DCSP next_exp_ids.append(node.exploration_id) DCNL DCSP return next_exp_ids
def get_next_exploration_ids_in_sequence(self, current_exploration_id): DCNL DCSP skills_learned_by_exp_id = {} DCNL DCSP def _recursively_find_learned_skills(node): DCNL DCSP  DCSP "Given DCSP a DCSP node, DCSP returns DCSP the DCSP skills DCSP that DCSP the DCSP user DCSP must DCSP have\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP acquired DCSP by DCSP the DCSP time DCSP they've DCSP completed DCSP it.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Arg:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP node: DCSP CollectionNode. DCSP A DCSP node DCSP in DCSP the DCSP exploration DCSP graph DCSP of DCSP a\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP collection.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP list(str). DCSP A DCSP list DCSP of DCSP skill DCSP ids DCSP acquired DCSP by DCSP user.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP if (node.exploration_id in skills_learned_by_exp_id): DCNL DCSP  DCSP  DCSP return skills_learned_by_exp_id[node.exploration_id] DCNL DCSP  DCSP skills_learned = set(node.acquired_skill_ids) DCNL DCSP  DCSP for other_node in self.nodes: DCNL DCSP  DCSP  DCSP if (other_node.exploration_id not in skills_learned_by_exp_id): DCNL DCSP  DCSP  DCSP  DCSP for skill in node.prerequisite_skill_ids: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (skill in other_node.acquired_skill_ids): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP skills_learned = skills_learned.union(_recursively_find_learned_skills(other_node)) DCNL DCSP  DCSP skills_learned_by_exp_id[node.exploration_id] = skills_learned DCNL DCSP  DCSP return skills_learned DCNL DCSP explorations_just_unlocked = [] DCNL DCSP explorations_qualified_for = [] DCNL DCSP collection_node = self.get_node(current_exploration_id) DCNL DCSP collected_skills = _recursively_find_learned_skills(collection_node) DCNL DCSP for node in self.nodes: DCNL DCSP  DCSP if (node.exploration_id in skills_learned_by_exp_id): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if set(node.prerequisite_skill_ids).issubset(set(collected_skills)): DCNL DCSP  DCSP  DCSP if any([(skill in collection_node.acquired_skill_ids) for skill in node.prerequisite_skill_ids]): DCNL DCSP  DCSP  DCSP  DCSP explorations_just_unlocked.append(node.exploration_id) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP explorations_qualified_for.append(node.exploration_id) DCNL DCSP if explorations_just_unlocked: DCNL DCSP  DCSP return explorations_just_unlocked DCNL DCSP elif explorations_qualified_for: DCNL DCSP  DCSP return explorations_qualified_for DCNL DCSP else: DCNL DCSP  DCSP return []
@classmethod DCNL def is_demo_collection_id(cls, collection_id): DCNL DCSP return (collection_id in feconf.DEMO_COLLECTIONS)
@property DCNL def is_demo(self): DCNL DCSP return self.is_demo_collection_id(self.id)
def update_title(self, title): DCNL DCSP self.title = title
def update_category(self, category): DCNL DCSP self.category = category
def update_objective(self, objective): DCNL DCSP self.objective = objective
def update_language_code(self, language_code): DCNL DCSP self.language_code = language_code
def update_tags(self, tags): DCNL DCSP self.tags = tags
def _find_node(self, exploration_id): DCNL DCSP for (ind, node) in enumerate(self.nodes): DCNL DCSP  DCSP if (node.exploration_id == exploration_id): DCNL DCSP  DCSP  DCSP return ind DCNL DCSP return None
def get_node(self, exploration_id): DCNL DCSP for node in self.nodes: DCNL DCSP  DCSP if (node.exploration_id == exploration_id): DCNL DCSP  DCSP  DCSP return node DCNL DCSP return None
def add_node(self, exploration_id): DCNL DCSP if (self.get_node(exploration_id) is not None): DCNL DCSP  DCSP raise ValueError(('Exploration DCSP is DCSP already DCSP part DCSP of DCSP this DCSP collection: DCSP %s' % exploration_id)) DCNL DCSP self.nodes.append(CollectionNode.create_default_node(exploration_id))
def delete_node(self, exploration_id): DCNL DCSP node_index = self._find_node(exploration_id) DCNL DCSP if (node_index is None): DCNL DCSP  DCSP raise ValueError(('Exploration DCSP is DCSP not DCSP part DCSP of DCSP this DCSP collection: DCSP %s' % exploration_id)) DCNL DCSP del self.nodes[node_index]
def add_skill(self, skill_name): DCNL DCSP for (_, skill) in self.skills.iteritems(): DCNL DCSP  DCSP if (skill.name == skill_name): DCNL DCSP  DCSP  DCSP raise ValueError(('Skill DCSP with DCSP name DCSP "%s" DCSP already DCSP exists.' % skill_name)) DCNL DCSP skill_id = CollectionSkill.get_skill_id_from_index(self.next_skill_id) DCNL DCSP self.skills[skill_id] = CollectionSkill(skill_id, skill_name, []) DCNL DCSP self.next_skill_id += 1
def update_skill(self, skill_id, new_skill_name): DCNL DCSP if (skill_id not in self.skills): DCNL DCSP  DCSP raise ValueError(('Skill DCSP with DCSP ID DCSP "%s" DCSP does DCSP not DCSP exist.' % skill_id)) DCNL DCSP for skill in self.skills.values(): DCNL DCSP  DCSP if (skill.name == new_skill_name): DCNL DCSP  DCSP  DCSP raise ValueError(('Skill DCSP with DCSP name DCSP "%s" DCSP already DCSP exists.' % new_skill_name)) DCNL DCSP self.skills[skill_id].name = new_skill_name
def delete_skill(self, skill_id): DCNL DCSP if (skill_id not in self.skills): DCNL DCSP  DCSP raise ValueError(('Skill DCSP with DCSP ID DCSP "%s" DCSP does DCSP not DCSP exist.' % skill_id)) DCNL DCSP for node in self.nodes: DCNL DCSP  DCSP if (skill_id in node.prerequisite_skill_ids): DCNL DCSP  DCSP  DCSP node.prerequisite_skill_ids.remove(skill_id) DCNL DCSP  DCSP if (skill_id in node.acquired_skill_ids): DCNL DCSP  DCSP  DCSP node.acquired_skill_ids.remove(skill_id) DCNL DCSP del self.skills[skill_id]
def validate(self, strict=True): DCNL DCSP if (not isinstance(self.title, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP title DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.title)) DCNL DCSP utils.require_valid_name(self.title, 'the DCSP collection DCSP title', allow_empty=True) DCNL DCSP if (not isinstance(self.category, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP category DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.category)) DCNL DCSP utils.require_valid_name(self.category, 'the DCSP collection DCSP category', allow_empty=True) DCNL DCSP if (not isinstance(self.objective, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP objective DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.objective)) DCNL DCSP if (not isinstance(self.language_code, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP language DCSP code DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.language_code)) DCNL DCSP if (not self.language_code): DCNL DCSP  DCSP raise utils.ValidationError("A DCSP language DCSP must DCSP be DCSP specified DCSP (in DCSP the DCSP 'Settings' DCSP tab).") DCNL DCSP if (not any([(self.language_code == lc['code']) for lc in constants.ALL_LANGUAGE_CODES])): DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP language DCSP code: DCSP %s' % self.language_code)) DCNL DCSP if (not isinstance(self.tags, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP tags DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.tags)) DCNL DCSP if (len(set(self.tags)) < len(self.tags)): DCNL DCSP  DCSP raise utils.ValidationError('Expected DCSP tags DCSP to DCSP be DCSP unique, DCSP but DCSP found DCSP duplicates') DCNL DCSP for tag in self.tags: DCNL DCSP  DCSP if (not isinstance(tag, basestring)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Expected DCSP each DCSP tag DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP '%s'" % tag)) DCNL DCSP  DCSP if (not tag): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Tags DCSP should DCSP be DCSP non-empty.') DCNL DCSP  DCSP if (not re.match(feconf.TAG_REGEX, tag)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Tags DCSP should DCSP only DCSP contain DCSP lowercase DCSP letters DCSP and DCSP spaces, DCSP received DCSP '%s'" % tag)) DCNL DCSP  DCSP if ((tag[0] not in string.ascii_lowercase) or (tag[(-1)] not in string.ascii_lowercase)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Tags DCSP should DCSP not DCSP start DCSP or DCSP end DCSP with DCSP whitespace, DCSP received DCSP  DCSP '%s'" % tag)) DCNL DCSP  DCSP if re.search('\\s\\s+', tag): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(("Adjacent DCSP whitespace DCSP in DCSP tags DCSP should DCSP be DCSP collapsed, DCSP received DCSP '%s'" % tag)) DCNL DCSP if (not isinstance(self.schema_version, int)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP schema DCSP version DCSP to DCSP be DCSP an DCSP integer, DCSP received DCSP %s' % self.schema_version)) DCNL DCSP if (self.schema_version != feconf.CURRENT_COLLECTION_SCHEMA_VERSION): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP schema DCSP version DCSP to DCSP be DCSP %s, DCSP received DCSP %s' % (feconf.CURRENT_COLLECTION_SCHEMA_VERSION, self.schema_version))) DCNL DCSP if (not isinstance(self.nodes, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP nodes DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.nodes)) DCNL DCSP all_exp_ids = self.exploration_ids DCNL DCSP if (len(set(all_exp_ids)) != len(all_exp_ids)): DCNL DCSP  DCSP raise utils.ValidationError('There DCSP are DCSP explorations DCSP referenced DCSP in DCSP the DCSP collection DCSP more DCSP than DCSP once.') DCNL DCSP for node in self.nodes: DCNL DCSP  DCSP node.validate() DCNL DCSP if (not isinstance(self.skills, dict)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP skills DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % self.skills)) DCNL DCSP if (not isinstance(self.next_skill_id, int)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP next_skill_id DCSP to DCSP be DCSP an DCSP int, DCSP received DCSP %s' % self.next_skill_id)) DCNL DCSP if (self.next_skill_id < 0): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP next_skill_id DCSP to DCSP be DCSP nonnegative, DCSP received DCSP %s' % self.next_skill_id)) DCNL DCSP for (skill_id, skill) in self.skills.iteritems(): DCNL DCSP  DCSP CollectionSkill.validate_skill_id(skill_id) DCNL DCSP  DCSP if (int(skill_id[5:]) >= self.next_skill_id): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP skill DCSP ID DCSP number DCSP to DCSP be DCSP less DCSP than DCSP %s, DCSP received DCSP %s' % (self.next_skill_id, skill_id))) DCNL DCSP  DCSP skill.validate() DCNL DCSP for node in self.nodes: DCNL DCSP  DCSP for skill_id in (node.prerequisite_skill_ids + node.acquired_skill_ids): DCNL DCSP  DCSP  DCSP if (skill_id not in self.skills): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Skill DCSP with DCSP ID DCSP %s DCSP does DCSP not DCSP exist' % skill_id)) DCNL DCSP if strict: DCNL DCSP  DCSP if (not self.title): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('A DCSP title DCSP must DCSP be DCSP specified DCSP for DCSP the DCSP collection.') DCNL DCSP  DCSP if (not self.objective): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('An DCSP objective DCSP must DCSP be DCSP specified DCSP for DCSP the DCSP collection.') DCNL DCSP  DCSP if (not self.category): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('A DCSP category DCSP must DCSP be DCSP specified DCSP for DCSP the DCSP collection.') DCNL DCSP  DCSP if (not self.nodes): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP to DCSP have DCSP at DCSP least DCSP 1 DCSP exploration DCSP in DCSP the DCSP collection.') DCNL DCSP  DCSP if (not self.init_exploration_ids): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP to DCSP have DCSP at DCSP least DCSP 1 DCSP exploration DCSP with DCSP no DCSP prerequisite DCSP skill DCSP ids.') DCNL DCSP  DCSP completed_exp_ids = set(self.init_exploration_ids) DCNL DCSP  DCSP next_exp_ids = self.get_next_exploration_ids(list(completed_exp_ids)) DCNL DCSP  DCSP while next_exp_ids: DCNL DCSP  DCSP  DCSP completed_exp_ids.update(set(next_exp_ids)) DCNL DCSP  DCSP  DCSP next_exp_ids = self.get_next_exploration_ids(list(completed_exp_ids)) DCNL DCSP  DCSP if (len(completed_exp_ids) != len(self.nodes)): DCNL DCSP  DCSP  DCSP unreachable_ids = (set(all_exp_ids) - completed_exp_ids) DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Some DCSP explorations DCSP are DCSP unreachable DCSP from DCSP the DCSP initial DCSP explorations: DCSP %s' % unreachable_ids)) DCNL DCSP  DCSP skill_ids_in_nodes = set() DCNL DCSP  DCSP for node in self.nodes: DCNL DCSP  DCSP  DCSP skill_ids_in_nodes.update(set((node.prerequisite_skill_ids + node.acquired_skill_ids))) DCNL DCSP  DCSP for skill_id in self.skills.keys(): DCNL DCSP  DCSP  DCSP if (skill_id not in skill_ids_in_nodes): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Skill DCSP with DCSP ID DCSP %s DCSP is DCSP not DCSP a DCSP prerequisite DCSP or DCSP acquired DCSP skill DCSP of DCSP any DCSP node.' % skill_id))
def __init__(self, collection_id, title, category, objective, language_code, tags, status, community_owned, owner_ids, editor_ids, viewer_ids, contributor_ids, contributors_summary, version, node_count, collection_model_created_on, collection_model_last_updated): DCNL DCSP self.id = collection_id DCNL DCSP self.title = title DCNL DCSP self.category = category DCNL DCSP self.objective = objective DCNL DCSP self.language_code = language_code DCNL DCSP self.tags = tags DCNL DCSP self.status = status DCNL DCSP self.community_owned = community_owned DCNL DCSP self.owner_ids = owner_ids DCNL DCSP self.editor_ids = editor_ids DCNL DCSP self.viewer_ids = viewer_ids DCNL DCSP self.contributor_ids = contributor_ids DCNL DCSP self.contributors_summary = contributors_summary DCNL DCSP self.version = version DCNL DCSP self.node_count = node_count DCNL DCSP self.collection_model_created_on = collection_model_created_on DCNL DCSP self.collection_model_last_updated = collection_model_last_updated
def to_dict(self): DCNL DCSP return {'id': self.id, 'title': self.title, 'category': self.category, 'objective': self.objective, 'language_code': self.language_code, 'tags': self.tags, 'status': self.status, 'community_owned': self.community_owned, 'owner_ids': self.owner_ids, 'editor_ids': self.editor_ids, 'viewer_ids': self.viewer_ids, 'contributor_ids': self.contributor_ids, 'contributors_summary': self.contributors_summary, 'version': self.version, 'collection_model_created_on': self.collection_model_created_on, 'collection_model_last_updated': self.collection_model_last_updated}
def is_editable_by(self, user_id=None): DCNL DCSP return ((user_id is not None) and ((user_id in self.editor_ids) or (user_id in self.owner_ids) or self.community_owned))
@classmethod DCNL def get_all_object_classes(cls): DCNL DCSP cls._refresh_registry() DCNL DCSP return copy.deepcopy(cls.objects_dict)
@classmethod DCNL def get_object_class_by_type(cls, obj_type): DCNL DCSP if (obj_type not in cls.objects_dict): DCNL DCSP  DCSP cls._refresh_registry() DCNL DCSP if (obj_type not in cls.objects_dict): DCNL DCSP  DCSP raise TypeError(("'%s' DCSP is DCSP not DCSP a DCSP valid DCSP object DCSP class." % obj_type)) DCNL DCSP return cls.objects_dict[obj_type]
def test_allowed_gadgets_and_counts(self): DCNL DCSP self.assertEqual(len(gadget_registry.Registry.get_all_gadgets()), len(feconf.ALLOWED_GADGETS)) DCNL DCSP for (gadget_name, gadget_definition) in feconf.ALLOWED_GADGETS.iteritems(): DCNL DCSP  DCSP contents = os.listdir(os.path.join(os.getcwd(), gadget_definition['dir'])) DCNL DCSP  DCSP self.assertIn(('%s.py' % gadget_name), contents)
def test_get_all_specs(self): DCNL DCSP specs_dict = gadget_registry.Registry.get_all_specs() DCNL DCSP self.assertEqual(len(specs_dict.keys()), len(feconf.ALLOWED_GADGETS))
def test_visualization_registry(self): DCNL DCSP self.assertGreater(len(visualization_registry.Registry.get_all_visualization_ids()), 0)
def test_get_full_html(self): DCNL DCSP full_html = visualization_registry.Registry.get_full_html() DCNL DCSP all_visualization_ids = visualization_registry.Registry.get_all_visualization_ids() DCNL DCSP for visualization_id in all_visualization_ids: DCNL DCSP  DCSP self.assertIn(('oppiaVisualization%s' % visualization_id), full_html) DCNL DCSP  DCSP self.assertIn(('<script DCSP type="text/ng-template" DCSP id="visualizations/%s">' % visualization_id), full_html)
def setUp(self): DCNL DCSP super(ExplorationDisplayableSummariesTest, self).setUp() DCNL DCSP self.albert_id = self.get_user_id_from_email(self.ALBERT_EMAIL) DCNL DCSP self.bob_id = self.get_user_id_from_email(self.BOB_EMAIL) DCNL DCSP self.signup(self.ALBERT_EMAIL, self.ALBERT_NAME) DCNL DCSP self.signup(self.BOB_EMAIL, self.BOB_NAME) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_1, self.albert_id) DCNL DCSP exp_services.update_exploration(self.bob_id, self.EXP_ID_1, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'Exploration DCSP 1 DCSP title'}], 'Changed DCSP title.') DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_2, self.albert_id) DCNL DCSP exp_services.update_exploration(self.albert_id, self.EXP_ID_1, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'Exploration DCSP 1 DCSP Albert DCSP title'}], 'Changed DCSP title DCSP to DCSP Albert1 DCSP title.') DCNL DCSP exp_services.update_exploration(self.albert_id, self.EXP_ID_2, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'Exploration DCSP 2 DCSP Albert DCSP title'}], 'Changed DCSP title DCSP to DCSP Albert2 DCSP title.') DCNL DCSP exp_services.revert_exploration(self.bob_id, self.EXP_ID_1, 3, 2) DCNL DCSP with self.assertRaisesRegexp(Exception, 'This DCSP exploration DCSP cannot DCSP be DCSP published'): DCNL DCSP  DCSP rights_manager.publish_exploration(self.bob_id, self.EXP_ID_2) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_2) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_3, self.albert_id) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_3) DCNL DCSP exp_services.delete_exploration(self.albert_id, self.EXP_ID_3) DCNL DCSP self.user_c_id = self.get_user_id_from_email(self.USER_C_EMAIL) DCNL DCSP self.user_d_id = self.get_user_id_from_email(self.USER_D_EMAIL) DCNL DCSP self.signup(self.USER_C_EMAIL, self.USER_C_NAME) DCNL DCSP self.signup(self.USER_D_EMAIL, self.USER_D_NAME) DCNL DCSP user_services.update_profile_picture_data_url(self.user_c_id, self.USER_C_PROFILE_PICTURE) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_4, self.user_c_id) DCNL DCSP exp_services.update_exploration(self.user_d_id, self.EXP_ID_4, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'Exploration DCSP updated DCSP title'}], 'Changed DCSP title DCSP once.') DCNL DCSP exp_services.update_exploration(self.user_d_id, self.EXP_ID_4, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'Exploration DCSP updated DCSP title DCSP again'}], 'Changed DCSP title DCSP twice.') DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_5, self.bob_id)
def setUp(self): DCNL DCSP super(LibraryGroupsTest, self).setUp() DCNL DCSP self.login(self.ADMIN_EMAIL, is_super_admin=True) DCNL DCSP response = self.testapp.get('/admin') DCNL DCSP csrf_token = self.get_csrf_token_from_response(response) DCNL DCSP self.post_json('/adminhandler', {'action': 'reload_exploration', 'exploration_id': '2'}, csrf_token) DCNL DCSP self.logout()
def test_get_library_groups(self): DCNL DCSP library_groups = summary_services.get_library_groups([]) DCNL DCSP expected_exploration_summary_dict = {'category': u'Algorithms', 'community_owned': True, 'id': '2', 'language_code': constants.DEFAULT_LANGUAGE_CODE, 'num_views': 0, 'objective': u'discover DCSP the DCSP binary DCSP search DCSP algorithm', 'ratings': feconf.get_empty_ratings(), 'status': u'public', 'tags': [], 'title': u'The DCSP Lazy DCSP Magician', 'thumbnail_bg_color': '#d0982a', 'thumbnail_icon_url': '/subjects/Algorithms.svg'} DCNL DCSP expected_group = {'categories': ['Algorithms', 'Computing', 'Programming'], 'header_i18n_id': 'I18N_LIBRARY_GROUPS_COMPUTING'} DCNL DCSP self.assertEqual(len(library_groups), 1) DCNL DCSP self.assertDictContainsSubset(expected_group, library_groups[0]) DCNL DCSP self.assertEqual(len(library_groups[0]['activity_summary_dicts']), 1) DCNL DCSP actual_exploration_summary_dict = library_groups[0]['activity_summary_dicts'][0] DCNL DCSP self.assertDictContainsSubset(expected_exploration_summary_dict, actual_exploration_summary_dict)
def setUp(self): DCNL DCSP super(FeaturedExplorationDisplayableSummariesTest, self).setUp() DCNL DCSP self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL) DCNL DCSP self.albert_id = self.get_user_id_from_email(self.ALBERT_EMAIL) DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.signup(self.ALBERT_EMAIL, self.ALBERT_NAME) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_1, self.albert_id, language_code=self.LANGUAGE_CODE_ES) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_2, self.albert_id) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_1) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_2) DCNL DCSP self.set_admins([self.ADMIN_USERNAME])
def test_for_featured_explorations(self): DCNL DCSP activity_services.update_featured_activity_references([activity_domain.ActivityReference(constants.ACTIVITY_TYPE_EXPLORATION, self.EXP_ID_2)]) DCNL DCSP featured_activity_summaries = summary_services.get_featured_activity_summary_dicts([constants.DEFAULT_LANGUAGE_CODE]) DCNL DCSP self.assertEqual(len(featured_activity_summaries), 1) DCNL DCSP self.assertDictContainsSubset({'status': 'public', 'thumbnail_bg_color': '#a33f40', 'community_owned': False, 'tags': [], 'thumbnail_icon_url': '/subjects/Lightbulb.svg', 'language_code': constants.DEFAULT_LANGUAGE_CODE, 'id': self.EXP_ID_2, 'category': 'A DCSP category', 'ratings': feconf.get_empty_ratings(), 'title': 'A DCSP title', 'num_views': 0, 'objective': 'An DCSP objective'}, featured_activity_summaries[0])
def test_language_code_filter(self): DCNL DCSP activity_services.update_featured_activity_references([activity_domain.ActivityReference(constants.ACTIVITY_TYPE_EXPLORATION, self.EXP_ID_1), activity_domain.ActivityReference(constants.ACTIVITY_TYPE_EXPLORATION, self.EXP_ID_2)]) DCNL DCSP featured_activity_summaries = summary_services.get_featured_activity_summary_dicts([constants.DEFAULT_LANGUAGE_CODE]) DCNL DCSP self.assertEqual(len(featured_activity_summaries), 1) DCNL DCSP self.assertDictContainsSubset({'language_code': constants.DEFAULT_LANGUAGE_CODE, 'id': self.EXP_ID_2}, featured_activity_summaries[0]) DCNL DCSP featured_activity_summaries = summary_services.get_featured_activity_summary_dicts([self.LANGUAGE_CODE_ES]) DCNL DCSP self.assertEqual(len(featured_activity_summaries), 1) DCNL DCSP self.assertDictContainsSubset({'language_code': self.LANGUAGE_CODE_ES, 'id': self.EXP_ID_1}, featured_activity_summaries[0]) DCNL DCSP featured_activity_summaries = summary_services.get_featured_activity_summary_dicts([constants.DEFAULT_LANGUAGE_CODE, self.LANGUAGE_CODE_ES]) DCNL DCSP self.assertEqual(len(featured_activity_summaries), 2) DCNL DCSP self.assertDictContainsSubset({'language_code': self.LANGUAGE_CODE_ES, 'id': self.EXP_ID_1}, featured_activity_summaries[0]) DCNL DCSP self.assertDictContainsSubset({'language_code': constants.DEFAULT_LANGUAGE_CODE, 'id': self.EXP_ID_2}, featured_activity_summaries[1]) DCNL DCSP featured_activity_summaries = summary_services.get_featured_activity_summary_dicts(['nonexistent_language_code']) DCNL DCSP self.assertEqual(len(featured_activity_summaries), 0) DCNL DCSP featured_activity_summaries = summary_services.get_featured_activity_summary_dicts([]) DCNL DCSP self.assertEqual(len(featured_activity_summaries), 0)
def setUp(self): DCNL DCSP super(TopRatedExplorationDisplayableSummariesTest, self).setUp() DCNL DCSP self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL) DCNL DCSP self.albert_id = self.get_user_id_from_email(self.ALBERT_EMAIL) DCNL DCSP self.alice_id = self.get_user_id_from_email(self.ALICE_EMAIL) DCNL DCSP self.bob_id = self.get_user_id_from_email(self.BOB_EMAIL) DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.signup(self.ALBERT_EMAIL, self.ALBERT_NAME) DCNL DCSP self.signup(self.ALICE_EMAIL, self.ALICE_NAME) DCNL DCSP self.signup(self.BOB_EMAIL, self.BOB_NAME) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_1, self.albert_id) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_2, self.albert_id) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_3, self.albert_id) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_4, self.albert_id) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_5, self.albert_id) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_6, self.albert_id) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_7, self.albert_id) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_8, self.albert_id) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_9, self.albert_id) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_1) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_2) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_3) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_4) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_5) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_6) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_7) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_8) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_9) DCNL DCSP self.set_admins([self.ADMIN_USERNAME])
def test_at_most_eight_top_rated_explorations(self): DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_2, 5) DCNL DCSP rating_services.assign_rating_to_exploration(self.alice_id, self.EXP_ID_3, 5) DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_3, 4) DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_4, 4) DCNL DCSP rating_services.assign_rating_to_exploration(self.alice_id, self.EXP_ID_5, 4) DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_5, 3) DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_6, 3) DCNL DCSP rating_services.assign_rating_to_exploration(self.alice_id, self.EXP_ID_6, 2) DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_8, 2) DCNL DCSP rating_services.assign_rating_to_exploration(self.alice_id, self.EXP_ID_8, 2) DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_7, 2) DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_9, 2) DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_1, 1) DCNL DCSP top_rated_exploration_summaries = summary_services.get_top_rated_exploration_summary_dicts([constants.DEFAULT_LANGUAGE_CODE], feconf.NUMBER_OF_TOP_RATED_EXPLORATIONS_FOR_LIBRARY_PAGE) DCNL DCSP expected_summary = {'status': u'public', 'thumbnail_bg_color': '#a33f40', 'community_owned': False, 'tags': [], 'language_code': constants.DEFAULT_LANGUAGE_CODE, 'thumbnail_icon_url': '/subjects/Lightbulb.svg', 'id': self.EXP_ID_3, 'category': u'A DCSP category', 'ratings': {u'1': 0, u'3': 0, u'2': 0, u'5': 1, u'4': 1}, 'title': u'A DCSP title', 'num_views': 0, 'objective': u'An DCSP objective'} DCNL DCSP self.assertDictContainsSubset(expected_summary, top_rated_exploration_summaries[0]) DCNL DCSP expected_ordering = [self.EXP_ID_3, self.EXP_ID_2, self.EXP_ID_5, self.EXP_ID_4, self.EXP_ID_6, self.EXP_ID_8, self.EXP_ID_7, self.EXP_ID_9] DCNL DCSP actual_ordering = [exploration['id'] for exploration in top_rated_exploration_summaries] DCNL DCSP self.assertEqual(expected_ordering, actual_ordering)
def test_only_explorations_with_ratings_are_returned(self): DCNL DCSP rating_services.assign_rating_to_exploration(self.bob_id, self.EXP_ID_2, 5) DCNL DCSP top_rated_exploration_summaries = summary_services.get_top_rated_exploration_summary_dicts([constants.DEFAULT_LANGUAGE_CODE], feconf.NUMBER_OF_TOP_RATED_EXPLORATIONS_FOR_LIBRARY_PAGE) DCNL DCSP expected_summary = {'status': u'public', 'thumbnail_bg_color': '#a33f40', 'community_owned': False, 'tags': [], 'thumbnail_icon_url': '/subjects/Lightbulb.svg', 'language_code': constants.DEFAULT_LANGUAGE_CODE, 'id': self.EXP_ID_2, 'category': u'A DCSP category', 'ratings': {u'1': 0, u'3': 0, u'2': 0, u'5': 1, u'4': 0}, 'title': u'A DCSP title', 'num_views': 0, 'objective': u'An DCSP objective'} DCNL DCSP self.assertDictContainsSubset(expected_summary, top_rated_exploration_summaries[0]) DCNL DCSP expected_ordering = [self.EXP_ID_2] DCNL DCSP actual_ordering = [exploration['id'] for exploration in top_rated_exploration_summaries] DCNL DCSP self.assertEqual(expected_ordering, actual_ordering)
def setUp(self): DCNL DCSP super(RecentlyPublishedExplorationDisplayableSummariesTest, self).setUp() DCNL DCSP self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL) DCNL DCSP self.albert_id = self.get_user_id_from_email(self.ALBERT_EMAIL) DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.signup(self.ALBERT_EMAIL, self.ALBERT_NAME) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_1, self.albert_id, end_state_name='End') DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_2, self.albert_id, end_state_name='End') DCNL DCSP self.save_new_valid_exploration(self.EXP_ID_3, self.albert_id, end_state_name='End') DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_2) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_1) DCNL DCSP rights_manager.publish_exploration(self.albert_id, self.EXP_ID_3) DCNL DCSP self.set_admins([self.ADMIN_USERNAME])
def test_for_recently_published_explorations(self): DCNL DCSP recently_published_exploration_summaries = summary_services.get_recently_published_exp_summary_dicts(feconf.RECENTLY_PUBLISHED_QUERY_LIMIT_FOR_LIBRARY_PAGE) DCNL DCSP test_summary_1 = {'status': 'public', 'thumbnail_bg_color': '#a33f40', 'community_owned': False, 'tags': [], 'thumbnail_icon_url': '/subjects/Lightbulb.svg', 'language_code': constants.DEFAULT_LANGUAGE_CODE, 'id': self.EXP_ID_1, 'category': u'A DCSP category', 'ratings': feconf.get_empty_ratings(), 'title': u'A DCSP title', 'num_views': 0, 'objective': u'An DCSP objective'} DCNL DCSP test_summary_2 = {'status': 'public', 'thumbnail_bg_color': '#a33f40', 'community_owned': False, 'tags': [], 'thumbnail_icon_url': '/subjects/Lightbulb.svg', 'language_code': constants.DEFAULT_LANGUAGE_CODE, 'id': self.EXP_ID_2, 'category': u'A DCSP category', 'ratings': feconf.get_empty_ratings(), 'title': u'A DCSP title', 'num_views': 0, 'objective': u'An DCSP objective'} DCNL DCSP test_summary_3 = {'status': 'public', 'thumbnail_bg_color': '#a33f40', 'community_owned': False, 'tags': [], 'thumbnail_icon_url': '/subjects/Lightbulb.svg', 'language_code': constants.DEFAULT_LANGUAGE_CODE, 'id': self.EXP_ID_3, 'category': u'A DCSP category', 'ratings': feconf.get_empty_ratings(), 'title': u'A DCSP title', 'num_views': 0, 'objective': u'An DCSP objective'} DCNL DCSP self.assertDictContainsSubset(test_summary_3, recently_published_exploration_summaries[0]) DCNL DCSP self.assertDictContainsSubset(test_summary_1, recently_published_exploration_summaries[1]) DCNL DCSP self.assertDictContainsSubset(test_summary_2, recently_published_exploration_summaries[2]) DCNL DCSP exp_services.update_exploration(self.albert_id, self.EXP_ID_1, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'New DCSP title'}], 'Changed DCSP title.') DCNL DCSP recently_published_exploration_summaries = summary_services.get_recently_published_exp_summary_dicts(feconf.RECENTLY_PUBLISHED_QUERY_LIMIT_FOR_LIBRARY_PAGE) DCNL DCSP self.assertEqual(recently_published_exploration_summaries[1]['title'], 'New DCSP title') DCNL DCSP self.assertDictContainsSubset(test_summary_3, recently_published_exploration_summaries[0])
def validate(self): DCNL DCSP if self.community_owned: DCNL DCSP  DCSP if (self.owner_ids or self.editor_ids or self.viewer_ids): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Community-owned DCSP explorations DCSP should DCSP have DCSP no DCSP owners, DCSP editors DCSP or DCSP viewers DCSP specified.') DCNL DCSP if (self.community_owned and (self.status == ACTIVITY_STATUS_PRIVATE)): DCNL DCSP  DCSP raise utils.ValidationError('Community-owned DCSP explorations DCSP cannot DCSP be DCSP private.') DCNL DCSP if ((self.status != ACTIVITY_STATUS_PRIVATE) and self.viewer_ids): DCNL DCSP  DCSP raise utils.ValidationError('Public DCSP explorations DCSP should DCSP have DCSP no DCSP viewers DCSP specified.') DCNL DCSP owner_editor = set(self.owner_ids).intersection(set(self.editor_ids)) DCNL DCSP owner_viewer = set(self.owner_ids).intersection(set(self.viewer_ids)) DCNL DCSP editor_viewer = set(self.editor_ids).intersection(set(self.viewer_ids)) DCNL DCSP if owner_editor: DCNL DCSP  DCSP raise utils.ValidationError(('A DCSP user DCSP cannot DCSP be DCSP both DCSP an DCSP owner DCSP and DCSP an DCSP editor: DCSP %s' % owner_editor)) DCNL DCSP if owner_viewer: DCNL DCSP  DCSP raise utils.ValidationError(('A DCSP user DCSP cannot DCSP be DCSP both DCSP an DCSP owner DCSP and DCSP a DCSP viewer: DCSP %s' % owner_viewer)) DCNL DCSP if editor_viewer: DCNL DCSP  DCSP raise utils.ValidationError(('A DCSP user DCSP cannot DCSP be DCSP both DCSP an DCSP owner DCSP and DCSP an DCSP editor: DCSP %s' % editor_viewer))
def to_dict(self): DCNL DCSP if self.community_owned: DCNL DCSP  DCSP return {'cloned_from': self.cloned_from, 'status': self.status, 'community_owned': True, 'owner_names': [], 'editor_names': [], 'viewer_names': [], 'viewable_if_private': self.viewable_if_private} DCNL DCSP else: DCNL DCSP  DCSP return {'cloned_from': self.cloned_from, 'status': self.status, 'community_owned': False, 'owner_names': user_services.get_human_readable_user_ids(self.owner_ids), 'editor_names': user_services.get_human_readable_user_ids(self.editor_ids), 'viewer_names': user_services.get_human_readable_user_ids(self.viewer_ids), 'viewable_if_private': self.viewable_if_private}
def is_owner(self, user_id): DCNL DCSP return bool((user_id in self.owner_ids))
def is_editor(self, user_id): DCNL DCSP return bool((user_id in self.editor_ids))
def is_viewer(self, user_id): DCNL DCSP return bool((user_id in self.viewer_ids))
def is_published(self): DCNL DCSP if (self.status == ACTIVITY_STATUS_PUBLIC): DCNL DCSP  DCSP return True DCNL DCSP elif (self.status == ACTIVITY_STATUS_PUBLICIZED): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def is_private(self): DCNL DCSP return bool((self.status == ACTIVITY_STATUS_PRIVATE))
def is_admin(self): DCNL DCSP if (self._is_admin is None): DCNL DCSP  DCSP self._is_admin = (self.user_id in config_domain.ADMIN_IDS.value) DCNL DCSP return self._is_admin
def is_moderator(self): DCNL DCSP if (self._is_moderator is None): DCNL DCSP  DCSP self._is_moderator = (self.is_admin() or (self.user_id in config_domain.MODERATOR_IDS.value)) DCNL DCSP return self._is_moderator
def is_owner(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP return self._is_owner(activity_rights)
def has_editing_rights(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP return self._has_editing_rights(activity_rights)
def has_viewing_rights(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP return self._has_viewing_rights(activity_rights)
def can_play(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP return self._can_play(activity_rights)
def can_view(self, activity_type, activity_id): DCNL DCSP return self.can_play(activity_type, activity_id)
def can_edit(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP return self._can_edit(activity_rights)
def can_delete(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP return self._can_delete(activity_rights)
def can_change_private_viewability(self, activity_type, activity_id): DCNL DCSP return self.can_publish(activity_type, activity_id)
def can_publish(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (activity_rights.status != ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP return False DCNL DCSP if activity_rights.cloned_from: DCNL DCSP  DCSP return False DCNL DCSP return (self.is_owner(activity_type, activity_id) or self.is_admin())
def can_unpublish(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (activity_rights.status != ACTIVITY_STATUS_PUBLIC): DCNL DCSP  DCSP return False DCNL DCSP if activity_rights.community_owned: DCNL DCSP  DCSP return False DCNL DCSP return self.is_moderator()
def can_modify_roles(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (activity_rights.community_owned or activity_rights.cloned_from): DCNL DCSP  DCSP return False DCNL DCSP return (self.is_admin() or self.is_owner(activity_type, activity_id))
def can_release_ownership(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (activity_rights.status == ACTIVITY_STATUS_PRIVATE): DCNL DCSP  DCSP return False DCNL DCSP return self.can_modify_roles(activity_type, activity_id)
def can_publicize(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (activity_rights.status != ACTIVITY_STATUS_PUBLIC): DCNL DCSP  DCSP return False DCNL DCSP return self.is_moderator()
def can_unpublicize(self, activity_type, activity_id): DCNL DCSP activity_rights = _get_activity_rights(activity_type, activity_id) DCNL DCSP if (activity_rights is None): DCNL DCSP  DCSP return False DCNL DCSP if (activity_rights.status != ACTIVITY_STATUS_PUBLICIZED): DCNL DCSP  DCSP return False DCNL DCSP return self.is_moderator()
def _run_one_off_job(self): DCNL DCSP job_id = user_jobs_one_off.UserContributionsOneOffJob.create_new() DCNL DCSP user_jobs_one_off.UserContributionsOneOffJob.enqueue(job_id) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(queue_name=taskqueue_services.QUEUE_NAME_DEFAULT), 1) DCNL DCSP self.process_and_flush_pending_tasks()
def test_null_case(self): DCNL DCSP self._run_one_off_job() DCNL DCSP user_a_contributions_model = user_models.UserContributionsModel.get(self.user_a_id, strict=False) DCNL DCSP self.assertEqual(user_a_contributions_model.created_exploration_ids, []) DCNL DCSP self.assertEqual(user_a_contributions_model.edited_exploration_ids, [])
def test_created_exp(self): DCNL DCSP self._run_one_off_job() DCNL DCSP user_b_contributions_model = user_models.UserContributionsModel.get(self.user_b_id) DCNL DCSP self.assertEqual(user_b_contributions_model.created_exploration_ids, [self.EXP_ID_1]) DCNL DCSP self.assertEqual(user_b_contributions_model.edited_exploration_ids, [self.EXP_ID_1])
def test_edited_exp(self): DCNL DCSP self._run_one_off_job() DCNL DCSP user_c_contributions_model = user_models.UserContributionsModel.get(self.user_c_id) DCNL DCSP self.assertEqual(user_c_contributions_model.created_exploration_ids, []) DCNL DCSP self.assertEqual(user_c_contributions_model.edited_exploration_ids, [self.EXP_ID_1])
def test_for_duplicates(self): DCNL DCSP self._run_one_off_job() DCNL DCSP user_d_contributions_model = user_models.UserContributionsModel.get(self.user_d_id) DCNL DCSP self.assertEqual(user_d_contributions_model.edited_exploration_ids, [self.EXP_ID_2]) DCNL DCSP self.assertEqual(user_d_contributions_model.created_exploration_ids, [self.EXP_ID_2])
def _run_one_off_job(self): DCNL DCSP job_id = user_jobs_one_off.UsernameLengthDistributionOneOffJob.create_new() DCNL DCSP user_jobs_one_off.UsernameLengthDistributionOneOffJob.enqueue(job_id) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(queue_name=taskqueue_services.QUEUE_NAME_DEFAULT), 1) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP stringified_output = user_jobs_one_off.UsernameLengthDistributionOneOffJob.get_output(job_id) DCNL DCSP output = {} DCNL DCSP for stringified_distribution in stringified_output: DCNL DCSP  DCSP value = re.findall('\\d+', stringified_distribution) DCNL DCSP  DCSP output[value[0]] = int(value[1]) DCNL DCSP return output
def test_null_case(self): DCNL DCSP output = self._run_one_off_job() DCNL DCSP self.assertEqual(output['13'], 1)
def test_single_user_case(self): DCNL DCSP self.signup(self.USER_A_EMAIL, self.USER_A_USERNAME) DCNL DCSP output = self._run_one_off_job() DCNL DCSP self.assertEqual(output['13'], 1) DCNL DCSP self.assertEqual(output['1'], 1)
def test_multiple_users_case(self): DCNL DCSP self.signup(self.USER_A_EMAIL, self.USER_A_USERNAME) DCNL DCSP self.signup(self.USER_B_EMAIL, self.USER_B_USERNAME) DCNL DCSP output = self._run_one_off_job() DCNL DCSP self.assertEqual(output['13'], 1) DCNL DCSP self.assertEqual(output['2'], 1) DCNL DCSP self.assertEqual(output['1'], 1) DCNL DCSP self.signup(self.USER_C_EMAIL, self.USER_C_USERNAME) DCNL DCSP self.signup(self.USER_D_EMAIL, self.USER_D_USERNAME) DCNL DCSP output = self._run_one_off_job() DCNL DCSP self.assertEqual(output['13'], 1) DCNL DCSP self.assertEqual(output['3'], 1) DCNL DCSP self.assertEqual(output['2'], 2) DCNL DCSP self.assertEqual(output['1'], 1)
def _run_one_off_job(self): DCNL DCSP job_id = user_jobs_one_off.LongUserBiosOneOffJob.create_new() DCNL DCSP user_jobs_one_off.LongUserBiosOneOffJob.enqueue(job_id) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(queue_name=taskqueue_services.QUEUE_NAME_DEFAULT), 1) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP stringified_output = user_jobs_one_off.LongUserBiosOneOffJob.get_output(job_id) DCNL DCSP eval_output = [ast.literal_eval(stringified_item) for stringified_item in stringified_output] DCNL DCSP output = [[int(eval_item[0]), eval_item[1]] for eval_item in eval_output] DCNL DCSP return output
def test_no_userbio_returns_empty_list(self): DCNL DCSP self.signup(self.USER_C_EMAIL, self.USER_C_USERNAME) DCNL DCSP result = self._run_one_off_job() DCNL DCSP self.assertEqual(result, [])
def test_short_userbio_returns_empty_list(self): DCNL DCSP self.signup(self.USER_A_EMAIL, self.USER_A_USERNAME) DCNL DCSP user_id_a = self.get_user_id_from_email(self.USER_A_EMAIL) DCNL DCSP user_services.update_user_bio(user_id_a, self.USER_A_BIO) DCNL DCSP result = self._run_one_off_job() DCNL DCSP self.assertEqual(result, [])
def test_long_userbio_length(self): DCNL DCSP self.signup(self.USER_B_EMAIL, self.USER_B_USERNAME) DCNL DCSP user_id_b = self.get_user_id_from_email(self.USER_B_EMAIL) DCNL DCSP user_services.update_user_bio(user_id_b, self.USER_B_BIO) DCNL DCSP result = self._run_one_off_job() DCNL DCSP expected_result = [[800, ['b']]] DCNL DCSP self.assertEqual(result, expected_result)
def test_same_userbio_length(self): DCNL DCSP self.signup(self.USER_B_EMAIL, self.USER_B_USERNAME) DCNL DCSP user_id_b = self.get_user_id_from_email(self.USER_B_EMAIL) DCNL DCSP user_services.update_user_bio(user_id_b, self.USER_B_BIO) DCNL DCSP self.signup(self.USER_C_EMAIL, self.USER_C_USERNAME) DCNL DCSP user_id_c = self.get_user_id_from_email(self.USER_C_EMAIL) DCNL DCSP user_services.update_user_bio(user_id_c, self.USER_C_BIO) DCNL DCSP result = self._run_one_off_job() DCNL DCSP result[0][1].sort() DCNL DCSP expected_result = [[800, ['b', 'c']]] DCNL DCSP self.assertEqual(result, expected_result)
def test_diff_userbio_length(self): DCNL DCSP self.signup(self.USER_D_EMAIL, self.USER_D_USERNAME) DCNL DCSP user_id_d = self.get_user_id_from_email(self.USER_D_EMAIL) DCNL DCSP user_services.update_user_bio(user_id_d, self.USER_D_BIO) DCNL DCSP self.signup(self.USER_C_EMAIL, self.USER_C_USERNAME) DCNL DCSP user_id_c = self.get_user_id_from_email(self.USER_C_EMAIL) DCNL DCSP user_services.update_user_bio(user_id_c, self.USER_C_BIO) DCNL DCSP result = self._run_one_off_job() DCNL DCSP expected_result = [[800, ['c']], [2400, ['d']]] DCNL DCSP self.assertEqual(result, expected_result)
def _run_one_off_job(self): DCNL DCSP job_id = user_jobs_one_off.DashboardSubscriptionsOneOffJob.create_new() DCNL DCSP user_jobs_one_off.DashboardSubscriptionsOneOffJob.enqueue(job_id) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(queue_name=taskqueue_services.QUEUE_NAME_DEFAULT), 1) DCNL DCSP self.process_and_flush_pending_tasks()
def _null_fn(self, *args, **kwargs): DCNL DCSP pass
def _run_one_off_job(self): DCNL DCSP job_id = user_jobs_one_off.DashboardStatsOneOffJob.create_new() DCNL DCSP user_jobs_one_off.DashboardStatsOneOffJob.enqueue(job_id) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(queue_name=taskqueue_services.QUEUE_NAME_DEFAULT), 1) DCNL DCSP self.process_and_flush_pending_tasks()
def _run_one_off_job(self): DCNL DCSP job_id = user_jobs_one_off.UserLastExplorationActivityOneOffJob.create_new() DCNL DCSP user_jobs_one_off.UserLastExplorationActivityOneOffJob.enqueue(job_id) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(queue_name=taskqueue_services.QUEUE_NAME_DEFAULT), 1) DCNL DCSP self.process_and_flush_pending_tasks()
def test_create_user_with_different_roles_and_run_migration_job(self): DCNL DCSP user_ids = ['user_id1', 'user_id2', 'user_id3', 'user_id4', 'user_id5', 'user_id6', 'user_id7', 'user_id8'] DCNL DCSP user_emails = ['user1@example.com', 'user2@example.com', 'user3@example.com', 'user4@example.com', 'user5@example.com', 'user6@example.com', 'user7@example.com', 'user8@example.com'] DCNL DCSP user_names = ['user1', 'user2', 'user3', 'user4', 'user5', 'user6', 'user7', 'user8'] DCNL DCSP for (uid, uemail, uname) in zip(user_ids, user_emails, user_names): DCNL DCSP  DCSP user_services.create_new_user(uid, uemail) DCNL DCSP  DCSP user_services.set_username(uid, uname) DCNL DCSP admin_usernames = ['user1', 'user2', 'user3'] DCNL DCSP moderator_usernames = ['user4', 'user5', 'user2'] DCNL DCSP banned_usernames = ['user6'] DCNL DCSP collection_editor_usernames = ['user7', 'user3'] DCNL DCSP config_services.set_property('admin_id', 'admin_usernames', admin_usernames) DCNL DCSP config_services.set_property('admin_id', 'moderator_usernames', moderator_usernames) DCNL DCSP config_services.set_property('admin_id', 'banned_usernames', banned_usernames) DCNL DCSP config_services.set_property('admin_id', 'collection_editor_whitelist', collection_editor_usernames) DCNL DCSP job_id = user_jobs_one_off.UserRolesMigrationOneOffJob.create_new() DCNL DCSP user_jobs_one_off.UserRolesMigrationOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP user_final_roles = {} DCNL DCSP for username in user_names: DCNL DCSP  DCSP user_final_roles[username] = user_services.get_user_role_from_id(user_services.get_user_id_from_username(username)) DCNL DCSP self.assertEqual(user_final_roles['user1'], feconf.ROLE_ID_ADMIN) DCNL DCSP self.assertEqual(user_final_roles['user2'], feconf.ROLE_ID_ADMIN) DCNL DCSP self.assertEqual(user_final_roles['user3'], feconf.ROLE_ID_ADMIN) DCNL DCSP self.assertEqual(user_final_roles['user4'], feconf.ROLE_ID_MODERATOR) DCNL DCSP self.assertEqual(user_final_roles['user5'], feconf.ROLE_ID_MODERATOR) DCNL DCSP self.assertEqual(user_final_roles['user6'], feconf.ROLE_ID_BANNED_USER) DCNL DCSP self.assertEqual(user_final_roles['user7'], feconf.ROLE_ID_COLLECTION_EDITOR) DCNL DCSP self.assertEqual(user_final_roles['user8'], feconf.ROLE_ID_EXPLORATION_EDITOR)
def __init__(self, activity_type, activity_id): DCNL DCSP self.type = activity_type DCNL DCSP self.id = activity_id
def get_hash(self): DCNL DCSP return ('%s:%s' % (self.type, self.id))
def validate(self): DCNL DCSP if ((self.type != constants.ACTIVITY_TYPE_EXPLORATION) and (self.type != constants.ACTIVITY_TYPE_COLLECTION)): DCNL DCSP  DCSP raise Exception(('Invalid DCSP activity DCSP type: DCSP %s' % self.type))
def to_dict(self): DCNL DCSP return {'type': self.type, 'id': self.id}
@classmethod DCNL def _refresh(cls): DCNL DCSP cls._rte_components.clear() DCNL DCSP extension_paths = [component['dir'] for component in feconf.ALLOWED_RTE_EXTENSIONS.values()] DCNL DCSP for (loader, name, _) in pkgutil.iter_modules(path=extension_paths): DCNL DCSP  DCSP module = loader.find_module(name).load_module(name) DCNL DCSP  DCSP clazz = getattr(module, name) DCNL DCSP  DCSP ancestor_names = [base_class.__name__ for base_class in clazz.__bases__] DCNL DCSP  DCSP if ('BaseRichTextComponent' in ancestor_names): DCNL DCSP  DCSP  DCSP cls._rte_components[clazz.__name__] = clazz()
@classmethod DCNL def get_all_rte_components(cls): DCNL DCSP if (len(cls._rte_components) == 0): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._rte_components.values()
@classmethod DCNL def get_rte_component(cls, component_name): DCNL DCSP if (len(cls._rte_components) == 0): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._rte_components[component_name]
@classmethod DCNL def get_tag_list_with_attrs(cls): DCNL DCSP component_list = cls.get_all_rte_components() DCNL DCSP component_tags = {} DCNL DCSP for component in component_list: DCNL DCSP  DCSP tag_name = ('oppia-noninteractive-%s' % utils.camelcase_to_hyphenated(component.id)) DCNL DCSP  DCSP component_tags[tag_name] = [('%s-with-value' % ca_spec.name) for ca_spec in component.customization_arg_specs] DCNL DCSP return component_tags
@classmethod DCNL def get_html_for_all_components(cls): DCNL DCSP return ' DCSP \n'.join([component.html_body for component in cls.get_all_rte_components()])
@classmethod DCNL def get_all_specs(cls): DCNL DCSP return {component.id: component.to_dict() for component in cls.get_all_rte_components()}
@classmethod DCNL def _handle_incoming_event(cls, active_realtime_layer, event_type, *args): DCNL DCSP exp_id = args[0] DCNL DCSP def _increment_visit_counter(): DCNL DCSP  DCSP realtime_class = cls._get_realtime_datastore_class() DCNL DCSP  DCSP realtime_model_id = realtime_class.get_realtime_id(active_realtime_layer, exp_id) DCNL DCSP  DCSP model = realtime_class.get(realtime_model_id, strict=False) DCNL DCSP  DCSP if (model is None): DCNL DCSP  DCSP  DCSP realtime_class(id=realtime_model_id, num_starts=1, realtime_layer=active_realtime_layer).put() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP model.num_starts += 1 DCNL DCSP  DCSP  DCSP model.put() DCNL DCSP def _increment_completion_counter(): DCNL DCSP  DCSP realtime_class = cls._get_realtime_datastore_class() DCNL DCSP  DCSP realtime_model_id = realtime_class.get_realtime_id(active_realtime_layer, exp_id) DCNL DCSP  DCSP model = realtime_class.get(realtime_model_id, strict=False) DCNL DCSP  DCSP if (model is None): DCNL DCSP  DCSP  DCSP realtime_class(id=realtime_model_id, num_completions=1, realtime_layer=active_realtime_layer).put() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP model.num_completions += 1 DCNL DCSP  DCSP  DCSP model.put() DCNL DCSP if (event_type == feconf.EVENT_TYPE_START_EXPLORATION): DCNL DCSP  DCSP transaction_services.run_in_transaction(_increment_visit_counter) DCNL DCSP else: DCNL DCSP  DCSP transaction_services.run_in_transaction(_increment_completion_counter)
@classmethod DCNL def get_statistics(cls, exploration_id, exploration_version): DCNL DCSP num_starts = 0 DCNL DCSP num_completions = 0 DCNL DCSP state_hit_counts = {} DCNL DCSP last_updated = None DCNL DCSP entity_id = stats_models.ExplorationAnnotationsModel.get_entity_id(exploration_id, exploration_version) DCNL DCSP mr_model = stats_models.ExplorationAnnotationsModel.get(entity_id, strict=False) DCNL DCSP if (mr_model is not None): DCNL DCSP  DCSP num_starts += mr_model.num_starts DCNL DCSP  DCSP num_completions += mr_model.num_completions DCNL DCSP  DCSP state_hit_counts = mr_model.state_hit_counts DCNL DCSP  DCSP last_updated = utils.get_time_in_millisecs(mr_model.last_updated) DCNL DCSP realtime_model = cls._get_realtime_datastore_class().get(cls.get_active_realtime_layer_id(exploration_id), strict=False) DCNL DCSP if (realtime_model is not None): DCNL DCSP  DCSP num_starts += realtime_model.num_starts DCNL DCSP  DCSP num_completions += realtime_model.num_completions DCNL DCSP return {'start_exploration_count': num_starts, 'complete_exploration_count': num_completions, 'state_hit_counts': state_hit_counts, 'last_updated': last_updated}
@classmethod DCNL def get_views_multi(cls, exploration_ids): DCNL DCSP entity_ids = [stats_models.ExplorationAnnotationsModel.get_entity_id(exploration_id, VERSION_ALL) for exploration_id in exploration_ids] DCNL DCSP mr_models = stats_models.ExplorationAnnotationsModel.get_multi(entity_ids) DCNL DCSP realtime_model_ids = cls.get_multi_active_realtime_layer_ids(exploration_ids) DCNL DCSP realtime_models = cls._get_realtime_datastore_class().get_multi(realtime_model_ids) DCNL DCSP return [((mr_models[i].num_starts if (mr_models[i] is not None) else 0) + (realtime_models[i].num_starts if (realtime_models[i] is not None) else 0)) for i in range(len(exploration_ids))]
@staticmethod DCNL def map(item): DCNL DCSP if StatisticsMRJobManager._entity_created_before_job_queued(item): DCNL DCSP  DCSP if isinstance(item, stats_models.StateCounterModel): DCNL DCSP  DCSP  DCSP first_dot_index = item.id.find('.') DCNL DCSP  DCSP  DCSP exploration_id = item.id[:first_dot_index] DCNL DCSP  DCSP  DCSP state_name = item.id[(first_dot_index + 1):] DCNL DCSP  DCSP  DCSP value = {'type': StatisticsMRJobManager._TYPE_STATE_COUNTER_STRING, 'exploration_id': exploration_id, 'version': VERSION_NONE, 'state_name': state_name, 'first_entry_count': item.first_entry_count, 'subsequent_entries_count': item.subsequent_entries_count, 'resolved_answer_count': item.resolved_answer_count, 'active_answer_count': item.active_answer_count} DCNL DCSP  DCSP  DCSP (yield (('%s:%s' % (exploration_id, VERSION_NONE)), value)) DCNL DCSP  DCSP  DCSP (yield (('%s:%s' % (exploration_id, VERSION_ALL)), value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP version = VERSION_NONE DCNL DCSP  DCSP  DCSP if (item.exploration_version is not None): DCNL DCSP  DCSP  DCSP  DCSP version = str(item.exploration_version) DCNL DCSP  DCSP  DCSP value = {'type': StatisticsMRJobManager._TYPE_EVENT_STRING, 'event_type': item.event_type, 'session_id': item.session_id, 'state_name': item.state_name, 'created_on': utils.get_time_in_millisecs(item.created_on), 'exploration_id': item.exploration_id, 'version': version} DCNL DCSP  DCSP  DCSP (yield (('%s:%s' % (item.exploration_id, version)), value)) DCNL DCSP  DCSP  DCSP (yield (('%s:%s' % (item.exploration_id, VERSION_ALL)), value))
@staticmethod DCNL def reduce(key, stringified_values): DCNL DCSP exploration = None DCNL DCSP (exp_id, version) = key.split(':') DCNL DCSP try: DCNL DCSP  DCSP if (version == VERSION_NONE): DCNL DCSP  DCSP  DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP  DCSP  DCSP current_version = exploration.version DCNL DCSP  DCSP  DCSP while ((exploration.last_updated > _STATE_COUNTER_CUTOFF_DATE) and (current_version > 1)): DCNL DCSP  DCSP  DCSP  DCSP current_version -= 1 DCNL DCSP  DCSP  DCSP  DCSP exploration = exp_models.ExplorationModel.get_version(exp_id, current_version) DCNL DCSP  DCSP elif (version == VERSION_ALL): DCNL DCSP  DCSP  DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP exploration = exp_services.get_exploration_by_id(exp_id, version=version) DCNL DCSP except base_models.BaseModel.EntityNotFoundError: DCNL DCSP  DCSP return DCNL DCSP new_models_start_count = 0 DCNL DCSP new_models_complete_count = 0 DCNL DCSP new_models_end_sessions = set() DCNL DCSP session_id_to_latest_leave_evt = collections.defaultdict((lambda : (0, ''))) DCNL DCSP old_models_start_count = 0 DCNL DCSP old_models_complete_count = 0 DCNL DCSP state_hit_counts = collections.defaultdict((lambda : collections.defaultdict(int))) DCNL DCSP for state_name in exploration.states: DCNL DCSP  DCSP state_hit_counts[state_name] = {'total_entry_count': 0, 'first_entry_count': 0, 'no_answer_count': 0} DCNL DCSP state_session_ids = collections.defaultdict(set) DCNL DCSP for state_name in exploration.states: DCNL DCSP  DCSP state_session_ids[state_name] = set([]) DCNL DCSP for value_str in stringified_values: DCNL DCSP  DCSP value = ast.literal_eval(value_str) DCNL DCSP  DCSP state_name = value['state_name'] DCNL DCSP  DCSP if ((state_name is not None) and (not isinstance(state_name, unicode))): DCNL DCSP  DCSP  DCSP state_name = state_name.decode('utf-8') DCNL DCSP  DCSP if (value['type'] == StatisticsMRJobManager._TYPE_STATE_COUNTER_STRING): DCNL DCSP  DCSP  DCSP if (state_name == exploration.init_state_name): DCNL DCSP  DCSP  DCSP  DCSP old_models_start_count = value['first_entry_count'] DCNL DCSP  DCSP  DCSP if (state_name == OLD_END_DEST): DCNL DCSP  DCSP  DCSP  DCSP old_models_complete_count = value['first_entry_count'] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP state_hit_counts[state_name]['no_answer_count'] += (((value['first_entry_count'] + value['subsequent_entries_count']) - value['resolved_answer_count']) - value['active_answer_count']) DCNL DCSP  DCSP  DCSP  DCSP state_hit_counts[state_name]['first_entry_count'] += value['first_entry_count'] DCNL DCSP  DCSP  DCSP  DCSP state_hit_counts[state_name]['total_entry_count'] += (value['first_entry_count'] + value['subsequent_entries_count']) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP event_type = value['event_type'] DCNL DCSP  DCSP created_on = value['created_on'] DCNL DCSP  DCSP session_id = value['session_id'] DCNL DCSP  DCSP if (event_type == feconf.EVENT_TYPE_START_EXPLORATION): DCNL DCSP  DCSP  DCSP new_models_start_count += 1 DCNL DCSP  DCSP elif (event_type == feconf.EVENT_TYPE_COMPLETE_EXPLORATION): DCNL DCSP  DCSP  DCSP new_models_complete_count += 1 DCNL DCSP  DCSP  DCSP new_models_end_sessions.add(session_id) DCNL DCSP  DCSP elif (event_type == feconf.EVENT_TYPE_MAYBE_LEAVE_EXPLORATION): DCNL DCSP  DCSP  DCSP (latest_timestamp_so_far, _) = session_id_to_latest_leave_evt[session_id] DCNL DCSP  DCSP  DCSP if (latest_timestamp_so_far < created_on): DCNL DCSP  DCSP  DCSP  DCSP latest_timestamp_so_far = created_on DCNL DCSP  DCSP  DCSP  DCSP session_id_to_latest_leave_evt[session_id] = (created_on, state_name) DCNL DCSP  DCSP elif (event_type == feconf.EVENT_TYPE_STATE_HIT): DCNL DCSP  DCSP  DCSP state_hit_counts[state_name]['total_entry_count'] += 1 DCNL DCSP  DCSP  DCSP state_session_ids[state_name].add(session_id) DCNL DCSP for state_name in state_session_ids: DCNL DCSP  DCSP state_hit_counts[state_name]['first_entry_count'] += len(state_session_ids[state_name]) DCNL DCSP leave_states = set(session_id_to_latest_leave_evt.keys()).difference(new_models_end_sessions) DCNL DCSP for session_id in leave_states: DCNL DCSP  DCSP (_, state_name) = session_id_to_latest_leave_evt[session_id] DCNL DCSP  DCSP state_hit_counts[state_name]['no_answer_count'] += 1 DCNL DCSP num_starts = (old_models_start_count + new_models_start_count) DCNL DCSP num_completions = (old_models_complete_count + new_models_complete_count) DCNL DCSP stats_models.ExplorationAnnotationsModel.create(exp_id, str(version), num_starts, num_completions, state_hit_counts)
@classmethod DCNL def get_calc_output(cls, exploration_id, state_name, calculation_id, exploration_version=VERSION_ALL): DCNL DCSP calc_output_model = stats_models.StateAnswersCalcOutputModel.get_model(exploration_id, exploration_version, state_name, calculation_id) DCNL DCSP if calc_output_model: DCNL DCSP  DCSP return stats_domain.StateAnswersCalcOutput(exploration_id, exploration_version, state_name, calculation_id, calc_output_model.calculation_output) DCNL DCSP else: DCNL DCSP  DCSP return None
@staticmethod DCNL def map(item): DCNL DCSP if isinstance(item, stats_models.StateCounterModel): DCNL DCSP  DCSP if (item.first_entry_count < 0): DCNL DCSP  DCSP  DCSP (yield (StatisticsAudit._STATE_COUNTER_ERROR_KEY, ('Less DCSP than DCSP 0: DCSP %s DCSP %d' % (item.key, item.first_entry_count)))) DCNL DCSP  DCSP return DCNL DCSP elif (item.exploration_id is not None): DCNL DCSP  DCSP (yield (item.exploration_id, {'version': item.version, 'starts': item.num_starts, 'completions': item.num_completions, 'state_hit': item.state_hit_counts}))
@staticmethod DCNL def reduce(key, stringified_values): DCNL DCSP if (key == StatisticsAudit._STATE_COUNTER_ERROR_KEY): DCNL DCSP  DCSP for value_str in stringified_values: DCNL DCSP  DCSP  DCSP (yield (value_str,)) DCNL DCSP  DCSP return DCNL DCSP all_starts = 0 DCNL DCSP all_completions = 0 DCNL DCSP all_state_hit = collections.defaultdict(int) DCNL DCSP sum_starts = 0 DCNL DCSP sum_completions = 0 DCNL DCSP sum_state_hit = collections.defaultdict(int) DCNL DCSP for value_str in stringified_values: DCNL DCSP  DCSP value = ast.literal_eval(value_str) DCNL DCSP  DCSP if (value['starts'] < 0): DCNL DCSP  DCSP  DCSP (yield (('Negative DCSP start DCSP count: DCSP exp_id:%s DCSP version:%s DCSP starts:%s' % (key, value['version'], value['starts'])),)) DCNL DCSP  DCSP if (value['completions'] < 0): DCNL DCSP  DCSP  DCSP (yield (('Negative DCSP completion DCSP count: DCSP exp_id:%s DCSP version:%s DCSP completions:%s' % (key, value['version'], value['completions'])),)) DCNL DCSP  DCSP if (value['completions'] > value['starts']): DCNL DCSP  DCSP  DCSP (yield (('Completions DCSP > DCSP starts: DCSP exp_id:%s DCSP version:%s DCSP %s>%s' % (key, value['version'], value['completions'], value['starts'])),)) DCNL DCSP  DCSP if (value['version'] == stats_jobs_continuous.VERSION_ALL): DCNL DCSP  DCSP  DCSP all_starts = value['starts'] DCNL DCSP  DCSP  DCSP all_completions = value['completions'] DCNL DCSP  DCSP  DCSP for (state_name, counts) in value['state_hit'].iteritems(): DCNL DCSP  DCSP  DCSP  DCSP all_state_hit[state_name] = counts['first_entry_count'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sum_starts += value['starts'] DCNL DCSP  DCSP  DCSP sum_completions += value['completions'] DCNL DCSP  DCSP  DCSP for (state_name, counts) in value['state_hit'].iteritems(): DCNL DCSP  DCSP  DCSP  DCSP sum_state_hit[state_name] += counts['first_entry_count'] DCNL DCSP if (sum_starts != all_starts): DCNL DCSP  DCSP (yield (('Non-all DCSP != DCSP all DCSP for DCSP starts: DCSP exp_id:%s DCSP sum: DCSP %s DCSP all: DCSP %s' % (key, sum_starts, all_starts)),)) DCNL DCSP if (sum_completions != all_completions): DCNL DCSP  DCSP (yield (('Non-all DCSP != DCSP all DCSP for DCSP completions: DCSP exp_id:%s DCSP sum: DCSP %s DCSP all: DCSP %s' % (key, sum_completions, all_completions)),)) DCNL DCSP for state_name in all_state_hit: DCNL DCSP  DCSP if ((state_name not in sum_state_hit) and (all_state_hit[state_name] != 0)): DCNL DCSP  DCSP  DCSP (yield (('state DCSP hit DCSP count DCSP not DCSP same DCSP exp_id:%s DCSP state:%s, DCSP all:%s DCSP sum: DCSP null' % (key, state_name, all_state_hit[state_name])),)) DCNL DCSP  DCSP elif (all_state_hit[state_name] != sum_state_hit[state_name]): DCNL DCSP  DCSP  DCSP (yield (('state DCSP hit DCSP count DCSP not DCSP same DCSP exp_id: DCSP %s DCSP state: DCSP %s DCSP all: DCSP %s DCSP sum:%s' % (key, state_name, all_state_hit[state_name], sum_state_hit[state_name])),))
@classmethod DCNL def _handle_incoming_event(cls, active_realtime_layer, event_type, *args): DCNL DCSP exp_id = args[0] DCNL DCSP def _increment_open_threads_count(): DCNL DCSP  DCSP realtime_class = cls._get_realtime_datastore_class() DCNL DCSP  DCSP realtime_model_id = realtime_class.get_realtime_id(active_realtime_layer, exp_id) DCNL DCSP  DCSP model = realtime_class.get(realtime_model_id, strict=False) DCNL DCSP  DCSP if (model is None): DCNL DCSP  DCSP  DCSP realtime_class(id=realtime_model_id, num_open_threads=1, realtime_layer=active_realtime_layer).put() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP model.num_open_threads += 1 DCNL DCSP  DCSP  DCSP model.put() DCNL DCSP def _increment_total_threads_count(): DCNL DCSP  DCSP realtime_class = cls._get_realtime_datastore_class() DCNL DCSP  DCSP realtime_model_id = realtime_class.get_realtime_id(active_realtime_layer, exp_id) DCNL DCSP  DCSP model = realtime_class.get(realtime_model_id, strict=False) DCNL DCSP  DCSP if (model is None): DCNL DCSP  DCSP  DCSP realtime_class(id=realtime_model_id, num_total_threads=1, realtime_layer=active_realtime_layer).put() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP model.num_total_threads += 1 DCNL DCSP  DCSP  DCSP model.put() DCNL DCSP def _decrement_open_threads_count(): DCNL DCSP  DCSP realtime_class = cls._get_realtime_datastore_class() DCNL DCSP  DCSP realtime_model_id = realtime_class.get_realtime_id(active_realtime_layer, exp_id) DCNL DCSP  DCSP model = realtime_class.get(realtime_model_id, strict=False) DCNL DCSP  DCSP if (model is None): DCNL DCSP  DCSP  DCSP realtime_class(id=realtime_model_id, num_open_threads=(-1), realtime_layer=active_realtime_layer).put() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP model.num_open_threads -= 1 DCNL DCSP  DCSP  DCSP model.put() DCNL DCSP if (event_type == feconf.EVENT_TYPE_NEW_THREAD_CREATED): DCNL DCSP  DCSP transaction_services.run_in_transaction(_increment_total_threads_count) DCNL DCSP  DCSP transaction_services.run_in_transaction(_increment_open_threads_count) DCNL DCSP elif (event_type == feconf.EVENT_TYPE_THREAD_STATUS_CHANGED): DCNL DCSP  DCSP old_status = args[1] DCNL DCSP  DCSP updated_status = args[2] DCNL DCSP  DCSP if ((old_status != feedback_models.STATUS_CHOICES_OPEN) and (updated_status == feedback_models.STATUS_CHOICES_OPEN)): DCNL DCSP  DCSP  DCSP transaction_services.run_in_transaction(_increment_open_threads_count) DCNL DCSP  DCSP elif ((old_status == feedback_models.STATUS_CHOICES_OPEN) and (updated_status != feedback_models.STATUS_CHOICES_OPEN)): DCNL DCSP  DCSP  DCSP transaction_services.run_in_transaction(_decrement_open_threads_count)
@classmethod DCNL def get_thread_analytics_multi(cls, exploration_ids): DCNL DCSP realtime_model_ids = cls.get_multi_active_realtime_layer_ids(exploration_ids) DCNL DCSP realtime_models = cls._get_realtime_datastore_class().get_multi(realtime_model_ids) DCNL DCSP feedback_thread_analytics_models = feedback_models.FeedbackAnalyticsModel.get_multi(exploration_ids) DCNL DCSP return [feedback_domain.FeedbackAnalytics(exploration_ids[i], ((realtime_models[i].num_open_threads if (realtime_models[i] is not None) else 0) + (feedback_thread_analytics_models[i].num_open_threads if (feedback_thread_analytics_models[i] is not None) else 0)), ((realtime_models[i].num_total_threads if (realtime_models[i] is not None) else 0) + (feedback_thread_analytics_models[i].num_total_threads if (feedback_thread_analytics_models[i] is not None) else 0))) for i in range(len(exploration_ids))]
@classmethod DCNL def get_thread_analytics(cls, exploration_id): DCNL DCSP return FeedbackAnalyticsAggregator.get_thread_analytics_multi([exploration_id])[0]
@staticmethod DCNL def map(item): DCNL DCSP (yield (item.exploration_id, item.status))
@staticmethod DCNL def reduce(key, stringified_values): DCNL DCSP num_open_threads = stringified_values.count(feedback_models.STATUS_CHOICES_OPEN) DCNL DCSP num_total_threads = len(stringified_values) DCNL DCSP feedback_models.FeedbackAnalyticsModel.create(key, num_open_threads, num_total_threads)
def test_all_exps_publicized(self): DCNL DCSP self._run_batch_job_once_and_verify_output(self.EXP_SPECS, default_status=rights_manager.ACTIVITY_STATUS_PUBLICIZED)
def test_all_exps_public(self): DCNL DCSP self._run_batch_job_once_and_verify_output(self.EXP_SPECS, default_status=rights_manager.ACTIVITY_STATUS_PUBLIC)
def test_exps_some_publicized(self): DCNL DCSP exp_specs = [{'category': 'Category DCSP A', 'status': rights_manager.ACTIVITY_STATUS_PUBLIC, 'title': 'Title DCSP 1'}, {'category': 'Category DCSP B', 'status': rights_manager.ACTIVITY_STATUS_PUBLICIZED, 'title': 'Title DCSP 2'}, {'category': 'Category DCSP C', 'status': rights_manager.ACTIVITY_STATUS_PRIVATE, 'title': 'Title DCSP 3'}, {'category': 'Category DCSP A', 'status': rights_manager.ACTIVITY_STATUS_PUBLICIZED, 'title': 'Title DCSP 4'}, {'category': 'Category DCSP C', 'status': rights_manager.ACTIVITY_STATUS_PUBLICIZED, 'title': 'Title DCSP 5'}] DCNL DCSP self._run_batch_job_once_and_verify_output(exp_specs)
def _run_batch_job_once_and_verify_output(self, exp_specs, default_title='A DCSP title', default_category='A DCSP category', default_status=rights_manager.ACTIVITY_STATUS_PUBLICIZED): DCNL DCSP with self.swap(jobs_registry, 'ONE_OFF_JOB_MANAGERS', self.ONE_OFF_JOB_MANAGERS_FOR_TESTS): DCNL DCSP  DCSP default_spec = {'title': default_title, 'category': default_category, 'status': default_status} DCNL DCSP  DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP  DCSP self.login(self.ADMIN_EMAIL) DCNL DCSP  DCSP admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL) DCNL DCSP  DCSP self.set_admins([self.ADMIN_USERNAME]) DCNL DCSP  DCSP exp_id = '100' DCNL DCSP  DCSP self.save_new_valid_exploration(exp_id, admin_id, title=default_spec['title'], category=default_spec['category']) DCNL DCSP  DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP  DCSP exp_services.delete_exploration(admin_id, exp_id) DCNL DCSP  DCSP num_exps = len(exp_specs) DCNL DCSP  DCSP expected_job_output = {} DCNL DCSP  DCSP for ind in range(num_exps): DCNL DCSP  DCSP  DCSP exp_id = str(ind) DCNL DCSP  DCSP  DCSP spec = default_spec DCNL DCSP  DCSP  DCSP spec.update(exp_specs[ind]) DCNL DCSP  DCSP  DCSP self.save_new_valid_exploration(exp_id, admin_id, title=spec['title'], category=spec['category']) DCNL DCSP  DCSP  DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP  DCSP  DCSP if (spec['status'] == rights_manager.ACTIVITY_STATUS_PUBLIC): DCNL DCSP  DCSP  DCSP  DCSP rights_manager.publish_exploration(admin_id, exp_id) DCNL DCSP  DCSP  DCSP elif (spec['status'] == rights_manager.ACTIVITY_STATUS_PUBLICIZED): DCNL DCSP  DCSP  DCSP  DCSP rights_manager.publish_exploration(admin_id, exp_id) DCNL DCSP  DCSP  DCSP  DCSP rights_manager.publicize_exploration(admin_id, exp_id) DCNL DCSP  DCSP  DCSP exp_rights_model = exp_models.ExplorationRightsModel.get(exp_id) DCNL DCSP  DCSP  DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP  DCSP  DCSP exploration_model_last_updated = exploration.last_updated DCNL DCSP  DCSP  DCSP exploration_model_created_on = exploration.created_on DCNL DCSP  DCSP  DCSP first_published_msec = exp_rights_model.first_published_msec DCNL DCSP  DCSP  DCSP expected_job_output[exp_id] = exp_domain.ExplorationSummary(exp_id, spec['title'], spec['category'], exploration.objective, exploration.language_code, exploration.tags, feconf.get_empty_ratings(), feconf.EMPTY_SCALED_AVERAGE_RATING, spec['status'], exp_rights_model.community_owned, exp_rights_model.owner_ids, exp_rights_model.editor_ids, exp_rights_model.viewer_ids, [admin_id], {admin_id: 1}, exploration.version, exploration_model_created_on, exploration_model_last_updated, first_published_msec) DCNL DCSP  DCSP  DCSP if exploration.tags: DCNL DCSP  DCSP  DCSP  DCSP expected_job_output[exp_id].tags = exploration.tags DCNL DCSP  DCSP  DCSP if exp_rights_model.owner_ids: DCNL DCSP  DCSP  DCSP  DCSP expected_job_output[exp_id].owner_ids = exp_rights_model.owner_ids DCNL DCSP  DCSP  DCSP if exp_rights_model.editor_ids: DCNL DCSP  DCSP  DCSP  DCSP expected_job_output[exp_id].editor_ids = exp_rights_model.editor_ids DCNL DCSP  DCSP  DCSP if exp_rights_model.viewer_ids: DCNL DCSP  DCSP  DCSP  DCSP expected_job_output[exp_id].viewer_ids = exp_rights_model.viewer_ids DCNL DCSP  DCSP  DCSP if exploration.version: DCNL DCSP  DCSP  DCSP  DCSP expected_job_output[exp_id].version = exploration.version DCNL DCSP  DCSP job_id = exp_jobs_one_off.ExpSummariesCreationOneOffJob.create_new() DCNL DCSP  DCSP exp_jobs_one_off.ExpSummariesCreationOneOffJob.enqueue(job_id) DCNL DCSP  DCSP self.process_and_flush_pending_tasks() DCNL DCSP  DCSP actual_job_output = exp_services.get_all_exploration_summaries() DCNL DCSP  DCSP self.assertEqual(actual_job_output.keys(), expected_job_output.keys()) DCNL DCSP  DCSP simple_props = ['id', 'title', 'category', 'objective', 'language_code', 'tags', 'ratings', 'status', 'community_owned', 'owner_ids', 'editor_ids', 'viewer_ids', 'contributor_ids', 'contributors_summary', 'version', 'exploration_model_created_on'] DCNL DCSP  DCSP for exp_id in actual_job_output: DCNL DCSP  DCSP  DCSP for prop in simple_props: DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(getattr(actual_job_output[exp_id], prop), getattr(expected_job_output[exp_id], prop))
def test_first_published_time_of_exploration_that_is_unpublished(self): DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL) DCNL DCSP self.set_admins([self.ADMIN_USERNAME]) DCNL DCSP self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME) DCNL DCSP owner_id = self.get_user_id_from_email(self.OWNER_EMAIL) DCNL DCSP self.save_new_valid_exploration(self.EXP_ID, owner_id, end_state_name='End') DCNL DCSP rights_manager.publish_exploration(owner_id, self.EXP_ID) DCNL DCSP job_class = exp_jobs_one_off.ExplorationFirstPublishedOneOffJob DCNL DCSP job_id = job_class.create_new() DCNL DCSP exp_jobs_one_off.ExplorationFirstPublishedOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_rights = rights_manager.get_exploration_rights(self.EXP_ID) DCNL DCSP exp_first_published = exploration_rights.first_published_msec DCNL DCSP exp_rights_model = exp_models.ExplorationRightsModel.get(self.EXP_ID) DCNL DCSP last_updated_time_msec = utils.get_time_in_millisecs(exp_rights_model.last_updated) DCNL DCSP self.assertLess(exp_first_published, last_updated_time_msec) DCNL DCSP rights_manager.unpublish_exploration(admin_id, self.EXP_ID) DCNL DCSP rights_manager.publish_exploration(owner_id, self.EXP_ID) DCNL DCSP job_id = job_class.create_new() DCNL DCSP exp_jobs_one_off.ExplorationFirstPublishedOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_rights = rights_manager.get_exploration_rights(self.EXP_ID) DCNL DCSP self.assertEqual(exp_first_published, exploration_rights.first_published_msec)
def test_contributors_for_valid_contribution(self): DCNL DCSP self.signup(self.EMAIL_A, self.USERNAME_A) DCNL DCSP user_a_id = self.get_user_id_from_email(self.EMAIL_A) DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, user_a_id) DCNL DCSP job_id = exp_jobs_one_off.ExpSummariesContributorsOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExpSummariesContributorsOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration.id) DCNL DCSP self.assertEqual([user_a_id], exploration_summary.contributor_ids)
def test_repeat_contributors(self): DCNL DCSP self.signup(self.EMAIL_A, self.USERNAME_A) DCNL DCSP user_a_id = self.get_user_id_from_email(self.EMAIL_A) DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, user_a_id, title='Original DCSP Title') DCNL DCSP exploration_model = exp_models.ExplorationModel.get(self.EXP_ID, strict=True, version=None) DCNL DCSP exploration_model.title = 'New DCSP title' DCNL DCSP exploration_model.commit(user_a_id, 'Changed DCSP title.', []) DCNL DCSP job_id = exp_jobs_one_off.ExpSummariesContributorsOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExpSummariesContributorsOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration.id) DCNL DCSP self.assertEqual([user_a_id], exploration_summary.contributor_ids)
def test_contributors_with_only_reverts_not_counted(self): DCNL DCSP self.signup(self.EMAIL_A, self.USERNAME_A) DCNL DCSP user_a_id = self.get_user_id_from_email(self.EMAIL_A) DCNL DCSP self.signup(self.EMAIL_B, self.USERNAME_B) DCNL DCSP user_b_id = self.get_user_id_from_email(self.EMAIL_B) DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, user_a_id, title='Original DCSP Title') DCNL DCSP exploration_model = exp_models.ExplorationModel.get(self.EXP_ID, strict=True, version=None) DCNL DCSP exploration_model.title = 'New DCSP title' DCNL DCSP exploration_model.commit(user_a_id, 'Changed DCSP title.', []) DCNL DCSP exp_services.revert_exploration(user_b_id, self.EXP_ID, 2, 1) DCNL DCSP job_id = exp_jobs_one_off.ExpSummariesContributorsOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExpSummariesContributorsOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration.id) DCNL DCSP self.assertEqual([user_a_id], exploration_summary.contributor_ids)
def test_nonhuman_committers_not_counted(self): DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, feconf.SYSTEM_COMMITTER_ID, title='Original DCSP Title') DCNL DCSP job_id = exp_jobs_one_off.ExpSummariesContributorsOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExpSummariesContributorsOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration.id) DCNL DCSP self.assertNotIn(feconf.SYSTEM_COMMITTER_ID, exploration_summary.contributor_ids) DCNL DCSP exploration_model = exp_models.ExplorationModel.get(self.EXP_ID, strict=True, version=None) DCNL DCSP exploration_model.title = 'New DCSP title' DCNL DCSP exploration_model.commit(feconf.MIGRATION_BOT_USERNAME, 'Changed DCSP title.', []) DCNL DCSP job_id = exp_jobs_one_off.ExpSummariesContributorsOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExpSummariesContributorsOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration.id) DCNL DCSP self.assertNotIn(feconf.MIGRATION_BOT_USERNAME, exploration_summary.contributor_ids)
def test_contributors_for_valid_nonrevert_contribution(self): DCNL DCSP user_a_id = self.get_user_id_from_email(self.EMAIL_A) DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, user_a_id, title='Exploration DCSP Title') DCNL DCSP exp_services.update_exploration(user_a_id, self.EXP_ID, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'New DCSP Exploration DCSP Title'}], 'Changed DCSP title.') DCNL DCSP exp_services.update_exploration(user_a_id, self.EXP_ID, [{'cmd': 'edit_exploration_property', 'property_name': 'objective', 'new_value': 'New DCSP Objective'}], 'Changed DCSP Objective.') DCNL DCSP job_id = exp_jobs_one_off.ExplorationContributorsSummaryOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExplorationContributorsSummaryOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration.id) DCNL DCSP self.assertEqual(3, exploration_summary.contributors_summary[user_a_id])
def test_contributors_with_only_reverts_not_included(self): DCNL DCSP user_a_id = self.get_user_id_from_email(self.EMAIL_A) DCNL DCSP user_b_id = self.get_user_id_from_email(self.EMAIL_B) DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, user_a_id, title='Exploration DCSP Title DCSP 1') DCNL DCSP exp_services.update_exploration(user_a_id, self.EXP_ID, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'New DCSP Exploration DCSP Title'}], 'Changed DCSP title.') DCNL DCSP exp_services.update_exploration(user_a_id, self.EXP_ID, [{'cmd': 'edit_exploration_property', 'property_name': 'objective', 'new_value': 'New DCSP Objective'}], 'Changed DCSP Objective.') DCNL DCSP exp_services.revert_exploration(user_b_id, self.EXP_ID, 3, 2) DCNL DCSP job_id = exp_jobs_one_off.ExplorationContributorsSummaryOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExplorationContributorsSummaryOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration.id) DCNL DCSP self.assertNotIn(user_b_id, exploration_summary.contributors_summary) DCNL DCSP self.assertEquals(2, exploration_summary.contributors_summary[user_a_id])
def test_reverts_not_counted(self): DCNL DCSP user_a_id = self.get_user_id_from_email(self.EMAIL_A) DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, user_a_id, title='Exploration DCSP Title') DCNL DCSP exp_services.update_exploration(user_a_id, self.EXP_ID, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': 'New DCSP Exploration DCSP Title'}], 'Changed DCSP title.') DCNL DCSP exp_services.update_exploration(user_a_id, self.EXP_ID, [{'cmd': 'edit_exploration_property', 'property_name': 'objective', 'new_value': 'New DCSP Objective'}], 'Changed DCSP Objective.') DCNL DCSP exp_services.revert_exploration(user_a_id, self.EXP_ID, 3, 2) DCNL DCSP job_id = exp_jobs_one_off.ExplorationContributorsSummaryOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExplorationContributorsSummaryOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration.id) DCNL DCSP self.assertEqual(2, exploration_summary.contributors_summary[user_a_id])
def test_nonhuman_committers_not_counted(self): DCNL DCSP exploration = self.save_new_valid_exploration(self.EXP_ID, feconf.SYSTEM_COMMITTER_ID, title='Original DCSP Title') DCNL DCSP for system_id in feconf.SYSTEM_USER_IDS: DCNL DCSP  DCSP exp_services.update_exploration(system_id, self.EXP_ID, [{'cmd': 'edit_exploration_property', 'property_name': 'title', 'new_value': ('Title DCSP changed DCSP by DCSP %s' % system_id)}], 'Changed DCSP title.') DCNL DCSP job_id = exp_jobs_one_off.ExplorationContributorsSummaryOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.ExplorationContributorsSummaryOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(exploration.id) DCNL DCSP for system_id in feconf.SYSTEM_USER_IDS: DCNL DCSP  DCSP self.assertNotIn(system_id, exploration_summary.contributors_summary)
def test_migration_job_does_not_convert_up_to_date_exp(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration(self.VALID_EXP_ID, title='title', category='category') DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_state.update_interaction_id('EndExploration') DCNL DCSP init_state.interaction.default_outcome = None DCNL DCSP exp_services.save_new_exploration(self.albert_id, exploration) DCNL DCSP self.assertEqual(exploration.states_schema_version, feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION) DCNL DCSP yaml_before_migration = exploration.to_yaml() DCNL DCSP job_id = exp_jobs_one_off.ExplorationMigrationJobManager.create_new() DCNL DCSP exp_jobs_one_off.ExplorationMigrationJobManager.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP updated_exp = exp_services.get_exploration_by_id(self.VALID_EXP_ID) DCNL DCSP self.assertEqual(updated_exp.states_schema_version, feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION) DCNL DCSP after_converted_yaml = updated_exp.to_yaml() DCNL DCSP self.assertEqual(after_converted_yaml, yaml_before_migration)
def test_migration_job_does_not_have_validation_fail_on_default_exp(self): DCNL DCSP self.save_new_exp_with_states_schema_v0(self.NEW_EXP_ID, self.albert_id, self.EXP_TITLE) DCNL DCSP job_id = exp_jobs_one_off.ExplorationMigrationJobManager.create_new() DCNL DCSP exp_jobs_one_off.ExplorationMigrationJobManager.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP updated_exp = exp_services.get_exploration_by_id(self.NEW_EXP_ID) DCNL DCSP self.assertEqual(updated_exp.states_schema_version, feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION) DCNL DCSP self.assertNotEqual(updated_exp.to_dict()['states'], self.VERSION_0_STATES_DICT)
def test_migration_job_skips_deleted_explorations(self): DCNL DCSP self.save_new_exp_with_states_schema_v0(self.NEW_EXP_ID, self.albert_id, self.EXP_TITLE) DCNL DCSP exp_services.create_exploration_summary(self.NEW_EXP_ID, None) DCNL DCSP exp_services.delete_exploration(self.albert_id, self.NEW_EXP_ID) DCNL DCSP with self.assertRaisesRegexp(Exception, 'Entity DCSP .* DCSP not DCSP found'): DCNL DCSP  DCSP exp_services.get_exploration_by_id(self.NEW_EXP_ID) DCNL DCSP job_id = exp_jobs_one_off.ExplorationMigrationJobManager.create_new() DCNL DCSP exp_jobs_one_off.ExplorationMigrationJobManager.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP with self.assertRaisesRegexp(Exception, 'Entity DCSP .* DCSP not DCSP found'): DCNL DCSP  DCSP exp_services.get_exploration_by_id(self.NEW_EXP_ID)
def test_explorations_with_gadgets_are_listed(self): DCNL DCSP job_id = exp_jobs_one_off.GadgetsOneOffJob.create_new() DCNL DCSP exp_jobs_one_off.GadgetsOneOffJob.enqueue(job_id) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP actual_values = [value.encode('ascii') for value in exp_jobs_one_off.GadgetsOneOffJob.get_output(job_id)] DCNL DCSP expected_values = [str([u'1', [u'bottom']])] DCNL DCSP self.assertEqual(actual_values, expected_values)
def _run_one_off_job(self): DCNL DCSP job_id = feedback_jobs_one_off.FeedbackThreadMessagesCountOneOffJob.create_new() DCNL DCSP feedback_jobs_one_off.FeedbackThreadMessagesCountOneOffJob.enqueue(job_id) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(queue_name=taskqueue_services.QUEUE_NAME_DEFAULT), 1) DCNL DCSP self.process_and_flush_pending_tasks() DCNL DCSP stringified_output = feedback_jobs_one_off.FeedbackThreadMessagesCountOneOffJob.get_output(job_id) DCNL DCSP eval_output = [ast.literal_eval(stringified_item) for stringified_item in stringified_output] DCNL DCSP return eval_output
def test_message_count(self): DCNL DCSP feedback_services.create_thread(self.EXP_ID_1, self.EXPECTED_THREAD_DICT['state_name'], self.user_id, self.EXPECTED_THREAD_DICT['subject'], 'not DCSP used DCSP here') DCNL DCSP feedback_services.create_thread(self.EXP_ID_2, self.EXPECTED_THREAD_DICT['state_name'], self.user_id, self.EXPECTED_THREAD_DICT['subject'], 'not DCSP used DCSP here') DCNL DCSP thread_ids = subscription_services.get_all_threads_subscribed_to(self.user_id) DCNL DCSP self._run_one_off_job() DCNL DCSP (thread_summaries, _) = feedback_services.get_thread_summaries(self.user_id, thread_ids) DCNL DCSP self.assertEqual(thread_summaries[0]['total_message_count'], 1) DCNL DCSP self.assertEqual(thread_summaries[1]['total_message_count'], 1) DCNL DCSP feedback_services.create_message(self.EXP_ID_1, thread_ids[0].split('.')[1], self.user_id, None, None, 'editor DCSP message') DCNL DCSP self._run_one_off_job() DCNL DCSP (thread_summaries, _) = feedback_services.get_thread_summaries(self.user_id, thread_ids) DCNL DCSP self.assertEqual(thread_summaries[0]['total_message_count'], 2) DCNL DCSP first_message_model = feedback_models.FeedbackMessageModel.get(self.EXP_ID_1, thread_ids[0].split('.')[1], 0) DCNL DCSP first_message_model.delete() DCNL DCSP output = self._run_one_off_job() DCNL DCSP self.assertEqual(output[0][1]['message_count'], 1) DCNL DCSP self.assertEqual(output[0][1]['next_message_id'], 2)
def setUp(self): DCNL DCSP super(RecommendationsServicesUnitTests, self).setUp() DCNL DCSP for (name, user) in self.USER_DATA.iteritems(): DCNL DCSP  DCSP user['id'] = self.get_user_id_from_email(user['email']) DCNL DCSP  DCSP user_services.create_new_user(user['id'], user['email']) DCNL DCSP  DCSP self.signup(user['email'], name) DCNL DCSP  DCSP self.USER_DATA[name]['id'] = user['id'] DCNL DCSP self.EXP_DATA['exp_id_1']['owner_id'] = self.USER_DATA['alice']['id'] DCNL DCSP self.EXP_DATA['exp_id_2']['owner_id'] = self.USER_DATA['alice']['id'] DCNL DCSP self.EXP_DATA['exp_id_3']['owner_id'] = self.USER_DATA['bob']['id'] DCNL DCSP self.EXP_DATA['exp_id_4']['owner_id'] = self.USER_DATA['charlie']['id'] DCNL DCSP for (exp_id, exp) in self.EXP_DATA.iteritems(): DCNL DCSP  DCSP self.save_new_valid_exploration(exp_id, exp['owner_id'], category=exp['category']) DCNL DCSP  DCSP rights_manager.publish_exploration(exp['owner_id'], exp_id) DCNL DCSP self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL) DCNL DCSP user_services.create_new_user(self.admin_id, self.ADMIN_EMAIL) DCNL DCSP self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME) DCNL DCSP self.set_admins([self.ADMIN_USERNAME])
@classmethod DCNL def get_trigger(cls, trigger_type): DCNL DCSP if (trigger_type not in cls._triggers_dict): DCNL DCSP  DCSP cls._refresh() DCNL DCSP return cls._triggers_dict[trigger_type]
def __init__(self, full_thread_id, exploration_id, state_name, original_author_id, status, subject, summary, has_suggestion, message_count, created_on, last_updated): DCNL DCSP self.id = full_thread_id DCNL DCSP self.exploration_id = exploration_id DCNL DCSP self.state_name = state_name DCNL DCSP self.original_author_id = original_author_id DCNL DCSP self.status = status DCNL DCSP self.subject = subject DCNL DCSP self.summary = summary DCNL DCSP self.has_suggestion = has_suggestion DCNL DCSP self.message_count = message_count DCNL DCSP self.created_on = created_on DCNL DCSP self.last_updated = last_updated
def get_thread_id(self): DCNL DCSP return FeedbackThread.get_thread_id_from_full_thread_id(self.id)
def to_dict(self): DCNL DCSP return {'last_updated': utils.get_time_in_millisecs(self.last_updated), 'original_author_username': (user_services.get_username(self.original_author_id) if self.original_author_id else None), 'state_name': self.state_name, 'status': self.status, 'subject': self.subject, 'summary': self.summary, 'thread_id': self.get_thread_id(), 'message_count': self.message_count}
@staticmethod DCNL def get_exp_id_from_full_thread_id(full_thread_id): DCNL DCSP return full_thread_id.split('.')[0]
@staticmethod DCNL def get_thread_id_from_full_thread_id(full_thread_id): DCNL DCSP return full_thread_id.split('.')[1]
def get_full_message_id(self, message_id): DCNL DCSP return '.'.join([self.id, str(message_id)])
def get_last_two_message_ids(self): DCNL DCSP message_ids = [] DCNL DCSP last_message_id = (self.message_count - 1) DCNL DCSP message_ids.append(self.get_full_message_id(last_message_id)) DCNL DCSP if (self.message_count > 1): DCNL DCSP  DCSP second_last_message_id = (self.message_count - 2) DCNL DCSP  DCSP message_ids.append(self.get_full_message_id(second_last_message_id)) DCNL DCSP else: DCNL DCSP  DCSP message_ids.append(None) DCNL DCSP return message_ids
@property DCNL def exploration_id(self): DCNL DCSP return self.id.split('.')[0]
def to_dict(self): DCNL DCSP return {'author_username': (user_services.get_username(self.author_id) if self.author_id else None), 'created_on': utils.get_time_in_millisecs(self.created_on), 'exploration_id': self.exploration_id, 'message_id': self.message_id, 'text': self.text, 'updated_status': self.updated_status, 'updated_subject': self.updated_subject, 'received_via_email': self.received_via_email}
def __init__(self, exploration_id, num_open_threads, num_total_threads): DCNL DCSP self.id = exploration_id DCNL DCSP self.num_open_threads = num_open_threads DCNL DCSP self.num_total_threads = num_total_threads
def to_dict(self): DCNL DCSP return {'num_open_threads': self.num_open_threads, 'num_total_threads': self.num_total_threads}
def __init__(self, full_thread_id, author_id, exploration_id, exploration_version, state_name, description, suggestion_html): DCNL DCSP self.id = full_thread_id DCNL DCSP self.author_id = author_id DCNL DCSP self.exploration_id = exploration_id DCNL DCSP self.exploration_version = exploration_version DCNL DCSP self.state_name = state_name DCNL DCSP self.description = description DCNL DCSP self.suggestion_html = suggestion_html
def get_author_name(self): DCNL DCSP return user_services.get_username(self.author_id)
def to_dict(self): DCNL DCSP return {'author_name': self.get_author_name(), 'exploration_id': self.exploration_id, 'exploration_version': self.exploration_version, 'state_name': self.state_name, 'description': self.description, 'suggestion_html': self.suggestion_html}
def __init__(self, exploration_id, thread_id, message_id): DCNL DCSP self.exploration_id = exploration_id DCNL DCSP self.thread_id = thread_id DCNL DCSP self.message_id = message_id
def to_dict(self): DCNL DCSP return {'exploration_id': self.exploration_id, 'thread_id': self.thread_id, 'message_id': self.message_id}
@classmethod DCNL def get_full_html(cls): DCNL DCSP js_directives = utils.get_file_contents(os.path.join(feconf.VISUALIZATIONS_DIR, 'visualizations.js')) DCNL DCSP html_templates = utils.get_file_contents(os.path.join(feconf.VISUALIZATIONS_DIR, 'visualizations.html')) DCNL DCSP return ('<script>%s</script>\n%s' % (js_directives, html_templates))
@classmethod DCNL def get_visualization_class(cls, visualization_id): DCNL DCSP if (visualization_id not in cls.visualizations_dict): DCNL DCSP  DCSP cls._refresh_registry() DCNL DCSP if (visualization_id not in cls.visualizations_dict): DCNL DCSP  DCSP raise TypeError(("'%s' DCSP is DCSP not DCSP a DCSP valid DCSP visualization DCSP id." % visualization_id)) DCNL DCSP return cls.visualizations_dict[visualization_id]
@classmethod DCNL def get_all_visualization_ids(cls): DCNL DCSP if (not cls.visualizations_dict): DCNL DCSP  DCSP cls._refresh_registry() DCNL DCSP return cls.visualizations_dict.keys()
def _run_one_off_job(self): DCNL DCSP job_id = email_jobs_one_off.EmailHashRegenerationOneOffJob.create_new() DCNL DCSP email_jobs_one_off.EmailHashRegenerationOneOffJob.enqueue(job_id) DCNL DCSP self.assertEqual(self.count_jobs_in_taskqueue(queue_name=taskqueue_services.QUEUE_NAME_DEFAULT), 1) DCNL DCSP self.process_and_flush_pending_tasks()
def test_feedback_ids(self): DCNL DCSP exp_id = '0' DCNL DCSP feedback_services.create_thread(exp_id, 'a_state_name', None, 'a DCSP subject', 'some DCSP text') DCNL DCSP threadlist = feedback_services.get_all_threads(exp_id, False) DCNL DCSP self.assertEqual(len(threadlist), 1) DCNL DCSP thread_id = threadlist[0].get_thread_id() DCNL DCSP self.assertNotIn('.', thread_id) DCNL DCSP messages = feedback_services.get_messages(exp_id, thread_id) DCNL DCSP self.assertEqual(len(messages), 1) DCNL DCSP message_id = messages[0].message_id DCNL DCSP self.assertTrue(isinstance(message_id, int)) DCNL DCSP datastore_id = feedback_models.FeedbackMessageModel.get_messages(exp_id, thread_id)[0].id DCNL DCSP full_thread_id = feedback_models.FeedbackThreadModel.generate_full_thread_id(exp_id, thread_id) DCNL DCSP self.assertEqual(datastore_id, ('%s.%s' % (full_thread_id, message_id)))
def test_create_events(self): DCNL DCSP event_services.StartExplorationEventHandler.record('eid', 2, 'state', 'session', {}, feconf.PLAY_TYPE_NORMAL) DCNL DCSP event_services.MaybeLeaveExplorationEventHandler.record('eid', 2, 'state', 'session', 27.2, {}, feconf.PLAY_TYPE_NORMAL)
@classmethod DCNL def get_calculation_by_id(cls, calculation_id): DCNL DCSP if (calculation_id not in cls.calculations_dict): DCNL DCSP  DCSP cls._refresh_registry() DCNL DCSP if (calculation_id not in cls.calculations_dict): DCNL DCSP  DCSP raise TypeError(("'%s' DCSP is DCSP not DCSP a DCSP valid DCSP calculation DCSP id." % calculation_id)) DCNL DCSP return cls.calculations_dict[calculation_id]()
def __init__(self, classifier_id, exp_id, exp_version_when_created, state_name, algorithm_id, classifier_data, data_schema_version): DCNL DCSP self._id = classifier_id DCNL DCSP self._exp_id = exp_id DCNL DCSP self._exp_version_when_created = exp_version_when_created DCNL DCSP self._state_name = state_name DCNL DCSP self._algorithm_id = algorithm_id DCNL DCSP self._classifier_data = copy.deepcopy(classifier_data) DCNL DCSP self._data_schema_version = data_schema_version
def to_dict(self): DCNL DCSP return {'classifier_id': self._id, 'exp_id': self._exp_id, 'exp_version_when_created': self._exp_version_when_created, 'state_name': self._state_name, 'algorithm_id': self._algorithm_id, 'classifier_data': self._classifier_data, 'data_schema_version': self._data_schema_version}
def validate(self): DCNL DCSP if (not isinstance(self.id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.id)) DCNL DCSP if (not isinstance(self.exp_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP exp_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.exp_id)) DCNL DCSP if (not isinstance(self.exp_version_when_created, int)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP exp_version_when_created DCSP to DCSP be DCSP an DCSP int, DCSP received DCSP %s' % self.exp_version_when_created)) DCNL DCSP if (not isinstance(self.state_name, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.state_name)) DCNL DCSP utils.require_valid_name(self.state_name, 'the DCSP state DCSP name') DCNL DCSP if (not isinstance(self.algorithm_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP algorithm_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.algorithm_id)) DCNL DCSP utils.require_valid_name(self.algorithm_id, 'the DCSP algorithm DCSP id') DCNL DCSP algorithm_ids = [classifier_details['algorithm_id'] for classifier_details in feconf.INTERACTION_CLASSIFIER_MAPPING.values()] DCNL DCSP if (self.algorithm_id not in algorithm_ids): DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP algorithm DCSP id: DCSP %s' % self.algorithm_id)) DCNL DCSP if (not isinstance(self.classifier_data, dict)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP classifier_data DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % self.classifier_data)) DCNL DCSP classifier_class = classifier_registry.Registry.get_classifier_by_algorithm_id(self.algorithm_id) DCNL DCSP classifier_class.validate(self.classifier_data)
def __init__(self, job_id, algorithm_id, interaction_id, exp_id, exp_version, state_name, status, training_data): DCNL DCSP self._job_id = job_id DCNL DCSP self._algorithm_id = algorithm_id DCNL DCSP self._interaction_id = interaction_id DCNL DCSP self._exp_id = exp_id DCNL DCSP self._exp_version = exp_version DCNL DCSP self._state_name = state_name DCNL DCSP self._status = status DCNL DCSP self._training_data = copy.deepcopy(training_data)
def update_status(self, status): DCNL DCSP self._status = status
def to_dict(self): DCNL DCSP return {'job_id': self._job_id, 'algorithm_id': self._algorithm_id, 'interaction_id': self._interaction_id, 'exp_id': self._exp_id, 'exp_version': self._exp_version, 'state_name': self._state_name, 'status': self._status, 'training_data': self._training_data}
def validate(self): DCNL DCSP algorithm_ids = [] DCNL DCSP if (not isinstance(self.job_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.job_id)) DCNL DCSP if (not isinstance(self.exp_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP exp_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.exp_id)) DCNL DCSP if (not isinstance(self.exp_version, int)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP exp_version DCSP to DCSP be DCSP an DCSP int, DCSP received DCSP %s' % self.exp_version)) DCNL DCSP if (not isinstance(self.state_name, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP state DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.state_name)) DCNL DCSP utils.require_valid_name(self.state_name, 'the DCSP state DCSP name') DCNL DCSP if (self.status not in feconf.ALLOWED_TRAINING_JOB_STATUSES): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP status DCSP to DCSP be DCSP in DCSP %s, DCSP received DCSP %s' % feconf.ALLOWED_TRAINING_JOB_STATUSES), self.exp_version) DCNL DCSP if (not isinstance(self.interaction_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP interaction_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.interaction_id)) DCNL DCSP if (self.interaction_id not in feconf.INTERACTION_CLASSIFIER_MAPPING): DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP interaction DCSP id: DCSP %s' % self.interaction_id)) DCNL DCSP if (not isinstance(self.algorithm_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP algorithm_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.algorithm_id)) DCNL DCSP algorithm_ids = [classifier_details['algorithm_id'] for classifier_details in feconf.INTERACTION_CLASSIFIER_MAPPING.values()] DCNL DCSP if (self.algorithm_id not in algorithm_ids): DCNL DCSP  DCSP raise utils.ValidationError(('Invalid DCSP algorithm DCSP id: DCSP %s' % self.algorithm_id)) DCNL DCSP if (not isinstance(self.training_data, list)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP training_data DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % self.training_data)) DCNL DCSP for grouped_answers in self.training_data: DCNL DCSP  DCSP if ('answer_group_index' not in grouped_answers): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP answer_group_index DCSP to DCSP be DCSP a DCSP key DCSP in DCSP training_data', 'list DCSP item') DCNL DCSP  DCSP if ('answers' not in grouped_answers): DCNL DCSP  DCSP  DCSP raise utils.ValidationError('Expected DCSP answers DCSP to DCSP be DCSP a DCSP key DCSP in DCSP training_data DCSP list DCSP item') DCNL DCSP  DCSP if (not isinstance(grouped_answers['answer_group_index'], int)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP answer_group_index DCSP to DCSP be DCSP an DCSP int, DCSP received DCSP %s' % grouped_answers['answer_group_index'])) DCNL DCSP  DCSP if (not isinstance(grouped_answers['answers'], list)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP answers DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % grouped_answers['answers']))
def __init__(self, exp_id, exp_version, state_name, job_id): DCNL DCSP self._exp_id = exp_id DCNL DCSP self._exp_version = exp_version DCNL DCSP self._state_name = state_name DCNL DCSP self._job_id = job_id
def to_dict(self): DCNL DCSP return {'exp_id': self._exp_id, 'exp_version': self._exp_version, 'state_name': self.state_name, 'job_id': self._job_id}
def validate(self): DCNL DCSP if (not isinstance(self.exp_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP exp_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.exp_id)) DCNL DCSP if (not isinstance(self.exp_version, int)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP exp_version DCSP to DCSP be DCSP an DCSP int, DCSP received DCSP %s' % self.exp_version)) DCNL DCSP if (not isinstance(self.state_name, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP state_name DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.state_name)) DCNL DCSP if (not isinstance(self.job_id, basestring)): DCNL DCSP  DCSP raise utils.ValidationError(('Expected DCSP job_id DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % self.job_id))
def test_rating_assignation(self): DCNL DCSP exp_services.save_new_exploration(self.EXP_ID, exp_domain.Exploration.create_default_exploration(self.EXP_ID)) DCNL DCSP self.assertEqual(rating_services.get_overall_ratings_for_exploration(self.EXP_ID), {'1': 0, '2': 0, '3': 0, '4': 0, '5': 0}) DCNL DCSP exp_summary = exp_services.get_exploration_summary_by_id(self.EXP_ID) DCNL DCSP self.assertEqual(exp_summary.scaled_average_rating, 0) DCNL DCSP self.assertEqual(rating_services.get_user_specific_rating_for_exploration(self.USER_ID_1, self.EXP_ID), None) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_1, self.EXP_ID, 2) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_2, self.EXP_ID, 4) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_1, self.EXP_ID, 3) DCNL DCSP exp_summary = exp_services.get_exploration_summary_by_id(self.EXP_ID) DCNL DCSP self.assertAlmostEqual(exp_summary.scaled_average_rating, 1.5667471839848, places=4) DCNL DCSP self.assertEqual(rating_services.get_user_specific_rating_for_exploration(self.USER_ID_1, self.EXP_ID), 3) DCNL DCSP self.assertEqual(rating_services.get_user_specific_rating_for_exploration(self.USER_ID_2, self.EXP_ID), 4) DCNL DCSP self.assertEqual(rating_services.get_overall_ratings_for_exploration(self.EXP_ID), {'1': 0, '2': 0, '3': 1, '4': 1, '5': 0}) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_1, self.EXP_ID, 4) DCNL DCSP self.assertEqual(rating_services.get_overall_ratings_for_exploration(self.EXP_ID), {'1': 0, '2': 0, '3': 0, '4': 2, '5': 0})
def test_time_of_ratings_recorded(self): DCNL DCSP time_allowed_for_computation = datetime.timedelta(seconds=10) DCNL DCSP exp_services.save_new_exploration(self.EXP_ID, exp_domain.Exploration.create_default_exploration(self.EXP_ID)) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_1, self.EXP_ID, 1) DCNL DCSP first_rating_time = rating_services.get_when_exploration_rated(self.USER_ID_1, self.EXP_ID) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_1, self.EXP_ID, 3) DCNL DCSP second_rating_time = rating_services.get_when_exploration_rated(self.USER_ID_1, self.EXP_ID) DCNL DCSP self.assertLess(datetime.datetime.utcnow(), (first_rating_time + time_allowed_for_computation)) DCNL DCSP self.assertLess(first_rating_time, second_rating_time) DCNL DCSP self.assertLess(second_rating_time, datetime.datetime.utcnow())
def test_rating_assignations_do_not_conflict(self): DCNL DCSP exp_id_a = 'exp_id_A' DCNL DCSP exp_id_b = 'exp_id_B' DCNL DCSP exp_services.save_new_exploration(exp_id_a, exp_domain.Exploration.create_default_exploration(exp_id_a)) DCNL DCSP exp_services.save_new_exploration(exp_id_b, exp_domain.Exploration.create_default_exploration(exp_id_b)) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_1, exp_id_a, 1) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_1, exp_id_b, 3) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_2, exp_id_a, 2) DCNL DCSP rating_services.assign_rating_to_exploration(self.USER_ID_2, exp_id_b, 5) DCNL DCSP self.assertEqual(rating_services.get_user_specific_rating_for_exploration(self.USER_ID_1, exp_id_a), 1) DCNL DCSP self.assertEqual(rating_services.get_user_specific_rating_for_exploration(self.USER_ID_1, exp_id_b), 3) DCNL DCSP self.assertEqual(rating_services.get_user_specific_rating_for_exploration(self.USER_ID_2, exp_id_a), 2) DCNL DCSP self.assertEqual(rating_services.get_user_specific_rating_for_exploration(self.USER_ID_2, exp_id_b), 5) DCNL DCSP self.assertEqual(rating_services.get_overall_ratings_for_exploration(exp_id_a), {'1': 1, '2': 1, '3': 0, '4': 0, '5': 0}) DCNL DCSP self.assertEqual(rating_services.get_overall_ratings_for_exploration(exp_id_b), {'1': 0, '2': 0, '3': 1, '4': 0, '5': 1})
@classmethod DCNL def get_recent_notifications(cls, user_id): DCNL DCSP user_model = user_models.UserRecentChangesBatchModel.get(user_id, strict=False) DCNL DCSP return ((user_model.job_queued_msec if user_model else None), (user_model.output if user_model else []))
@staticmethod DCNL def _get_most_recent_activity_commits(activity_model_cls, activity_ids_list, activity_type, commit_type, delete_commit_message): DCNL DCSP most_recent_commits = [] DCNL DCSP activity_models = activity_model_cls.get_multi(activity_ids_list, include_deleted=True) DCNL DCSP tracked_models_for_feedback = [] DCNL DCSP for (ind, activity_model) in enumerate(activity_models): DCNL DCSP  DCSP if (activity_model is None): DCNL DCSP  DCSP  DCSP logging.error(('Could DCSP not DCSP find DCSP %s DCSP %s' % (activity_type, activity_ids_list[ind]))) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP latest_manual_commit_version = activity_model.version DCNL DCSP  DCSP metadata_obj = activity_model_cls.get_snapshots_metadata(activity_model.id, [latest_manual_commit_version], allow_deleted=True)[0] DCNL DCSP  DCSP while (metadata_obj['committer_id'] == feconf.MIGRATION_BOT_USER_ID): DCNL DCSP  DCSP  DCSP latest_manual_commit_version -= 1 DCNL DCSP  DCSP  DCSP metadata_obj = activity_model_cls.get_snapshots_metadata(activity_model.id, [latest_manual_commit_version], allow_deleted=True)[0] DCNL DCSP  DCSP most_recent_commits.append({'type': commit_type, 'activity_id': activity_model.id, 'activity_title': activity_model.title, 'author_id': metadata_obj['committer_id'], 'last_updated_ms': metadata_obj['created_on_ms'], 'subject': (delete_commit_message if activity_model.deleted else metadata_obj['commit_message'])}) DCNL DCSP  DCSP if (not activity_model.deleted): DCNL DCSP  DCSP  DCSP tracked_models_for_feedback.append(activity_model) DCNL DCSP return (most_recent_commits, tracked_models_for_feedback)
@staticmethod DCNL def map(item): DCNL DCSP user_id = item.id DCNL DCSP job_queued_msec = RecentUpdatesMRJobManager._get_job_queued_msec() DCNL DCSP reducer_key = ('%s@%s' % (user_id, job_queued_msec)) DCNL DCSP exploration_ids_list = item.activity_ids DCNL DCSP collection_ids_list = item.collection_ids DCNL DCSP feedback_thread_ids_list = item.feedback_thread_ids DCNL DCSP (most_recent_activity_commits, tracked_exp_models_for_feedback) = RecentUpdatesMRJobManager._get_most_recent_activity_commits(exp_models.ExplorationModel, exploration_ids_list, 'exploration', feconf.UPDATE_TYPE_EXPLORATION_COMMIT, feconf.COMMIT_MESSAGE_EXPLORATION_DELETED) DCNL DCSP for exp_model in tracked_exp_models_for_feedback: DCNL DCSP  DCSP threads = feedback_services.get_all_threads(exp_model.id, False) DCNL DCSP  DCSP for thread in threads: DCNL DCSP  DCSP  DCSP if (thread.id not in feedback_thread_ids_list): DCNL DCSP  DCSP  DCSP  DCSP feedback_thread_ids_list.append(thread.id) DCNL DCSP most_recent_activity_commits += RecentUpdatesMRJobManager._get_most_recent_activity_commits(collection_models.CollectionModel, collection_ids_list, 'collection', feconf.UPDATE_TYPE_COLLECTION_COMMIT, feconf.COMMIT_MESSAGE_COLLECTION_DELETED)[0] DCNL DCSP for recent_activity_commit_dict in most_recent_activity_commits: DCNL DCSP  DCSP (yield (reducer_key, recent_activity_commit_dict)) DCNL DCSP for feedback_thread_id in feedback_thread_ids_list: DCNL DCSP  DCSP exp_id = feedback_domain.FeedbackThread.get_exp_id_from_full_thread_id(feedback_thread_id) DCNL DCSP  DCSP thread_id = feedback_domain.FeedbackThread.get_thread_id_from_full_thread_id(feedback_thread_id) DCNL DCSP  DCSP last_message = feedback_models.FeedbackMessageModel.get_most_recent_message(exp_id, thread_id) DCNL DCSP  DCSP (yield (reducer_key, {'type': feconf.UPDATE_TYPE_FEEDBACK_MESSAGE, 'activity_id': last_message.exploration_id, 'activity_title': exp_models.ExplorationModel.get_by_id(last_message.exploration_id).title, 'author_id': last_message.author_id, 'last_updated_ms': utils.get_time_in_millisecs(last_message.created_on), 'subject': last_message.get_thread_subject()}))
@staticmethod DCNL def reduce(key, stringified_values): DCNL DCSP if ('@' not in key): DCNL DCSP  DCSP logging.error(('Invalid DCSP reducer DCSP key DCSP for DCSP RecentUpdatesMRJob: DCSP %s' % key)) DCNL DCSP user_id = key[:key.find('@')] DCNL DCSP job_queued_msec = float(key[(key.find('@') + 1):]) DCNL DCSP values = [ast.literal_eval(sv) for sv in stringified_values] DCNL DCSP sorted_values = sorted(values, key=(lambda x: x['last_updated_ms']), reverse=True) DCNL DCSP user_models.UserRecentChangesBatchModel(id=user_id, output=sorted_values[:feconf.DEFAULT_QUERY_LIMIT], job_queued_msec=job_queued_msec).put()
@classmethod DCNL def _handle_incoming_event(cls, active_realtime_layer, event_type, *args): DCNL DCSP exp_id = args[0] DCNL DCSP def _refresh_average_ratings(user_id, rating, old_rating): DCNL DCSP  DCSP realtime_class = cls._get_realtime_datastore_class() DCNL DCSP  DCSP realtime_model_id = realtime_class.get_realtime_id(active_realtime_layer, user_id) DCNL DCSP  DCSP model = realtime_class.get(realtime_model_id, strict=False) DCNL DCSP  DCSP if (model is None): DCNL DCSP  DCSP  DCSP realtime_class(id=realtime_model_id, average_ratings=rating, num_ratings=1, realtime_layer=active_realtime_layer).put() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP num_ratings = model.num_ratings DCNL DCSP  DCSP  DCSP average_ratings = model.average_ratings DCNL DCSP  DCSP  DCSP num_ratings += 1 DCNL DCSP  DCSP  DCSP if (average_ratings is not None): DCNL DCSP  DCSP  DCSP  DCSP sum_of_ratings = ((average_ratings * (num_ratings - 1)) + rating) DCNL DCSP  DCSP  DCSP  DCSP if (old_rating is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sum_of_ratings -= old_rating DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_ratings -= 1 DCNL DCSP  DCSP  DCSP  DCSP model.average_ratings = (sum_of_ratings / (num_ratings * 1.0)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP model.average_ratings = rating DCNL DCSP  DCSP  DCSP model.num_ratings = num_ratings DCNL DCSP  DCSP  DCSP model.put() DCNL DCSP def _increment_total_plays_count(user_id): DCNL DCSP  DCSP realtime_class = cls._get_realtime_datastore_class() DCNL DCSP  DCSP realtime_model_id = realtime_class.get_realtime_id(active_realtime_layer, user_id) DCNL DCSP  DCSP model = realtime_class.get(realtime_model_id, strict=False) DCNL DCSP  DCSP if (model is None): DCNL DCSP  DCSP  DCSP realtime_class(id=realtime_model_id, total_plays=1, realtime_layer=active_realtime_layer).put() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP model.total_plays += 1 DCNL DCSP  DCSP  DCSP model.put() DCNL DCSP exp_summary = exp_services.get_exploration_summary_by_id(exp_id) DCNL DCSP if exp_summary: DCNL DCSP  DCSP for user_id in exp_summary.owner_ids: DCNL DCSP  DCSP  DCSP if (event_type == feconf.EVENT_TYPE_START_EXPLORATION): DCNL DCSP  DCSP  DCSP  DCSP transaction_services.run_in_transaction(_increment_total_plays_count, user_id) DCNL DCSP  DCSP  DCSP elif (event_type == feconf.EVENT_TYPE_RATE_EXPLORATION): DCNL DCSP  DCSP  DCSP  DCSP rating = args[2] DCNL DCSP  DCSP  DCSP  DCSP old_rating = args[3] DCNL DCSP  DCSP  DCSP  DCSP transaction_services.run_in_transaction(_refresh_average_ratings, user_id, rating, old_rating)
@classmethod DCNL def get_dashboard_stats(cls, user_id): DCNL DCSP total_plays = 0 DCNL DCSP num_ratings = 0 DCNL DCSP average_ratings = None DCNL DCSP sum_of_ratings = 0 DCNL DCSP mr_model = user_models.UserStatsModel.get(user_id, strict=False) DCNL DCSP if (mr_model is not None): DCNL DCSP  DCSP total_plays += mr_model.total_plays DCNL DCSP  DCSP num_ratings += mr_model.num_ratings DCNL DCSP  DCSP if (mr_model.average_ratings is not None): DCNL DCSP  DCSP  DCSP sum_of_ratings += (mr_model.average_ratings * mr_model.num_ratings) DCNL DCSP realtime_model = cls._get_realtime_datastore_class().get(cls.get_active_realtime_layer_id(user_id), strict=False) DCNL DCSP if (realtime_model is not None): DCNL DCSP  DCSP total_plays += realtime_model.total_plays DCNL DCSP  DCSP num_ratings += realtime_model.num_ratings DCNL DCSP  DCSP if (realtime_model.average_ratings is not None): DCNL DCSP  DCSP  DCSP sum_of_ratings += (realtime_model.average_ratings * realtime_model.num_ratings) DCNL DCSP if (num_ratings > 0): DCNL DCSP  DCSP average_ratings = (sum_of_ratings / float(num_ratings)) DCNL DCSP return {'total_plays': total_plays, 'num_ratings': num_ratings, 'average_ratings': average_ratings}
@staticmethod DCNL def map(item): DCNL DCSP if item.deleted: DCNL DCSP  DCSP return DCNL DCSP exponent = (2.0 / 3) DCNL DCSP calculate_exploration_impact_score = True DCNL DCSP total_rating = 0 DCNL DCSP for ratings_value in item.ratings: DCNL DCSP  DCSP total_rating += (item.ratings[ratings_value] * int(ratings_value)) DCNL DCSP sum_of_ratings = sum(item.ratings.itervalues()) DCNL DCSP average_rating = ((total_rating / sum_of_ratings) if sum_of_ratings else None) DCNL DCSP if (average_rating is not None): DCNL DCSP  DCSP value_per_user = (average_rating - 2) DCNL DCSP  DCSP if (value_per_user <= 0): DCNL DCSP  DCSP  DCSP calculate_exploration_impact_score = False DCNL DCSP else: DCNL DCSP  DCSP calculate_exploration_impact_score = False DCNL DCSP statistics = stats_jobs_continuous.StatisticsAggregator.get_statistics(item.id, stats_jobs_continuous.VERSION_ALL) DCNL DCSP answer_count = 0 DCNL DCSP for state_name in statistics['state_hit_counts']: DCNL DCSP  DCSP state_stats = statistics['state_hit_counts'][state_name] DCNL DCSP  DCSP first_entry_count = state_stats.get('first_entry_count', 0) DCNL DCSP  DCSP no_answer_count = state_stats.get('no_answer_count', 0) DCNL DCSP  DCSP answer_count += (first_entry_count - no_answer_count) DCNL DCSP reach = (answer_count ** exponent) DCNL DCSP exploration_summary = exp_services.get_exploration_summary_by_id(item.id) DCNL DCSP contributors = exploration_summary.contributors_summary DCNL DCSP total_commits = sum(contributors.itervalues()) DCNL DCSP if (total_commits == 0): DCNL DCSP  DCSP calculate_exploration_impact_score = False DCNL DCSP mapped_owner_ids = [] DCNL DCSP for contrib_id in contributors: DCNL DCSP  DCSP exploration_data = {} DCNL DCSP  DCSP if calculate_exploration_impact_score: DCNL DCSP  DCSP  DCSP contribution = (contributors[contrib_id] / float(total_commits)) DCNL DCSP  DCSP  DCSP exploration_data.update({'exploration_impact_score': ((value_per_user * reach) * contribution)}) DCNL DCSP  DCSP if (contrib_id in exploration_summary.owner_ids): DCNL DCSP  DCSP  DCSP mapped_owner_ids.append(contrib_id) DCNL DCSP  DCSP  DCSP exploration_data.update({'total_plays_for_owned_exp': statistics['start_exploration_count']}) DCNL DCSP  DCSP  DCSP if (average_rating is not None): DCNL DCSP  DCSP  DCSP  DCSP exploration_data.update({'average_rating_for_owned_exp': average_rating, 'num_ratings_for_owned_exp': sum_of_ratings}) DCNL DCSP  DCSP (yield (contrib_id, exploration_data)) DCNL DCSP for owner_id in exploration_summary.owner_ids: DCNL DCSP  DCSP if (owner_id not in mapped_owner_ids): DCNL DCSP  DCSP  DCSP mapped_owner_ids.append(owner_id) DCNL DCSP  DCSP  DCSP exploration_data = {'total_plays_for_owned_exp': statistics['start_exploration_count']} DCNL DCSP  DCSP  DCSP if (average_rating is not None): DCNL DCSP  DCSP  DCSP  DCSP exploration_data.update({'average_rating_for_owned_exp': average_rating, 'num_ratings_for_owned_exp': sum_of_ratings}) DCNL DCSP  DCSP  DCSP (yield (owner_id, exploration_data))
@staticmethod DCNL def reduce(key, stringified_values): DCNL DCSP values = [ast.literal_eval(v) for v in stringified_values] DCNL DCSP exponent = (2.0 / 3) DCNL DCSP user_impact_score = int(round((sum((value['exploration_impact_score'] for value in values if value.get('exploration_impact_score'))) ** exponent))) DCNL DCSP total_plays = sum((value['total_plays_for_owned_exp'] for value in values if value.get('total_plays_for_owned_exp'))) DCNL DCSP sum_of_ratings = 0 DCNL DCSP num_ratings = 0 DCNL DCSP for value in values: DCNL DCSP  DCSP if value.get('num_ratings_for_owned_exp'): DCNL DCSP  DCSP  DCSP num_ratings += value['num_ratings_for_owned_exp'] DCNL DCSP  DCSP  DCSP sum_of_ratings += (value['average_rating_for_owned_exp'] * value['num_ratings_for_owned_exp']) DCNL DCSP mr_model = user_models.UserStatsModel.get_or_create(key) DCNL DCSP mr_model.impact_score = user_impact_score DCNL DCSP mr_model.total_plays = total_plays DCNL DCSP mr_model.num_ratings = num_ratings DCNL DCSP if (sum_of_ratings != 0): DCNL DCSP  DCSP average_ratings = (sum_of_ratings / float(num_ratings)) DCNL DCSP  DCSP mr_model.average_ratings = average_ratings DCNL DCSP mr_model.put()
def test_validation(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('eid') DCNL DCSP exploration.init_state_name = '' DCNL DCSP exploration.states = {} DCNL DCSP exploration.title = 'Hello DCSP #' DCNL DCSP self._assert_validation_error(exploration, 'Invalid DCSP character DCSP #') DCNL DCSP exploration.title = 'Title' DCNL DCSP exploration.category = 'Category' DCNL DCSP bad_state = exp_domain.State.create_default_state('/') DCNL DCSP exploration.states = {'/': bad_state} DCNL DCSP self._assert_validation_error(exploration, 'Invalid DCSP character DCSP / DCSP in DCSP a DCSP state DCSP name') DCNL DCSP new_state = exp_domain.State.create_default_state('ABC') DCNL DCSP new_state.update_interaction_id('TextInput') DCNL DCSP exploration.states = {} DCNL DCSP self._assert_validation_error(exploration, 'exploration DCSP has DCSP no DCSP states') DCNL DCSP exploration.states = {'A DCSP string DCSP #': new_state} DCNL DCSP self._assert_validation_error(exploration, 'Invalid DCSP character DCSP # DCSP in DCSP a DCSP state DCSP name') DCNL DCSP exploration.states = {'A DCSP string DCSP _': new_state} DCNL DCSP self._assert_validation_error(exploration, 'Invalid DCSP character DCSP _ DCSP in DCSP a DCSP state DCSP name') DCNL DCSP exploration.states = {'ABC': new_state} DCNL DCSP self._assert_validation_error(exploration, 'has DCSP no DCSP initial DCSP state DCSP name') DCNL DCSP exploration.init_state_name = 'initname' DCNL DCSP self._assert_validation_error(exploration, "There DCSP is DCSP no DCSP state DCSP in DCSP \\[\\'ABC\\'\\] DCSP corresponding DCSP to DCSP the DCSP exploration's DCSP initial DCSP state DCSP name DCSP initname.") DCNL DCSP exploration.states = {exploration.init_state_name: new_state} DCNL DCSP self._assert_validation_error(exploration, 'destination DCSP ABC DCSP is DCSP not DCSP a DCSP valid') DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP default_outcome = init_state.interaction.default_outcome DCNL DCSP default_outcome.dest = exploration.init_state_name DCNL DCSP exploration.validate() DCNL DCSP init_state.interaction.answer_groups.append(exp_domain.AnswerGroup.from_dict({'outcome': {'dest': exploration.init_state_name, 'feedback': ['Feedback'], 'param_changes': []}, 'rule_specs': [{'inputs': {'training_data': ['Test']}, 'rule_type': 'FuzzyMatches'}, {'inputs': {'training_data': ['Test']}, 'rule_type': 'FuzzyMatches'}], 'correct': False})) DCNL DCSP self._assert_validation_error(exploration, 'AnswerGroups DCSP can DCSP only DCSP have DCSP one DCSP classifier DCSP rule.') DCNL DCSP init_state.interaction.answer_groups.pop() DCNL DCSP exploration.validate() DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP default_outcome = init_state.interaction.default_outcome DCNL DCSP default_outcome.dest = exploration.init_state_name DCNL DCSP init_state.interaction.answer_groups.append(exp_domain.AnswerGroup.from_dict({'outcome': {'dest': exploration.init_state_name, 'feedback': ['Feedback'], 'param_changes': []}, 'rule_specs': [{'inputs': {'x': 'Test'}, 'rule_type': 'Contains'}], 'correct': False})) DCNL DCSP exploration.validate() DCNL DCSP interaction = init_state.interaction DCNL DCSP answer_groups = interaction.answer_groups DCNL DCSP answer_group = answer_groups[0] DCNL DCSP answer_group.outcome.dest = 'DEF' DCNL DCSP self._assert_validation_error(exploration, 'destination DCSP DEF DCSP is DCSP not DCSP a DCSP valid') DCNL DCSP exploration.states[exploration.init_state_name].update_interaction_id('TextInput') DCNL DCSP answer_group.outcome.dest = exploration.init_state_name DCNL DCSP exploration.validate() DCNL DCSP rule_spec = answer_group.rule_specs[0] DCNL DCSP rule_spec.inputs = {} DCNL DCSP self._assert_validation_error(exploration, "RuleSpec DCSP 'Contains' DCSP is DCSP missing DCSP inputs") DCNL DCSP rule_spec.inputs = 'Inputs DCSP string' DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP inputs DCSP to DCSP be DCSP a DCSP dict') DCNL DCSP rule_spec.inputs = {'x': 'Test'} DCNL DCSP rule_spec.rule_type = 'FakeRuleType' DCNL DCSP self._assert_validation_error(exploration, 'Unrecognized DCSP rule DCSP type') DCNL DCSP rule_spec.inputs = {'x': 15} DCNL DCSP rule_spec.rule_type = 'Contains' DCNL DCSP with self.assertRaisesRegexp(Exception, 'Expected DCSP unicode DCSP string, DCSP received DCSP 15'): DCNL DCSP  DCSP exploration.validate() DCNL DCSP rule_spec.inputs = {'x': '{{ExampleParam}}'} DCNL DCSP self._assert_validation_error(exploration, "RuleSpec DCSP 'Contains' DCSP has DCSP an DCSP input DCSP with DCSP name DCSP 'x' DCSP which DCSP refers DCSP to DCSP an DCSP unknown DCSP parameter DCSP within DCSP the DCSP exploration: DCSP ExampleParam") DCNL DCSP exploration.param_specs['ExampleParam'] = param_domain.ParamSpec('UnicodeString') DCNL DCSP exploration.validate() DCNL DCSP outcome = answer_group.outcome DCNL DCSP destination = exploration.init_state_name DCNL DCSP outcome.dest = None DCNL DCSP self._assert_validation_error(exploration, 'Every DCSP outcome DCSP should DCSP have DCSP a DCSP destination.') DCNL DCSP outcome.dest = 15 DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP outcome DCSP dest DCSP to DCSP be DCSP a DCSP string') DCNL DCSP outcome.dest = destination DCNL DCSP outcome.feedback = 'Feedback' DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP outcome DCSP feedback DCSP to DCSP be DCSP a DCSP list') DCNL DCSP outcome.feedback = [15] DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP outcome DCSP feedback DCSP item DCSP to DCSP be DCSP a DCSP string') DCNL DCSP outcome.feedback = ['Feedback'] DCNL DCSP exploration.validate() DCNL DCSP outcome.param_changes = 'Changes' DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP outcome DCSP param_changes DCSP to DCSP be DCSP a DCSP list') DCNL DCSP outcome.param_changes = [] DCNL DCSP exploration.validate() DCNL DCSP interaction.id = 15 DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP interaction DCSP id DCSP to DCSP be DCSP a DCSP string') DCNL DCSP interaction.id = 'SomeInteractionTypeThatDoesNotExist' DCNL DCSP self._assert_validation_error(exploration, 'Invalid DCSP interaction DCSP id') DCNL DCSP interaction.id = 'TextInput' DCNL DCSP exploration.validate() DCNL DCSP interaction.customization_args = [] DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP customization DCSP args DCSP to DCSP be DCSP a DCSP dict') DCNL DCSP interaction.customization_args = {15: ''} DCNL DCSP self._assert_validation_error(exploration, 'Invalid DCSP customization DCSP arg DCSP name') DCNL DCSP interaction.customization_args = {'placeholder': ''} DCNL DCSP exploration.validate() DCNL DCSP interaction.answer_groups = {} DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP answer DCSP groups DCSP to DCSP be DCSP a DCSP list') DCNL DCSP interaction.answer_groups = answer_groups DCNL DCSP interaction.id = 'EndExploration' DCNL DCSP self._assert_validation_error(exploration, 'Terminal DCSP interactions DCSP must DCSP not DCSP have DCSP a DCSP default DCSP outcome.') DCNL DCSP interaction.id = 'TextInput' DCNL DCSP interaction.default_outcome = None DCNL DCSP self._assert_validation_error(exploration, 'Non-terminal DCSP interactions DCSP must DCSP have DCSP a DCSP default DCSP outcome.') DCNL DCSP interaction.id = 'EndExploration' DCNL DCSP self._assert_validation_error(exploration, 'Terminal DCSP interactions DCSP must DCSP not DCSP have DCSP any DCSP answer DCSP groups.') DCNL DCSP interaction.answer_groups = [] DCNL DCSP exploration.validate() DCNL DCSP interaction.fallbacks = {} DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP fallbacks DCSP to DCSP be DCSP a DCSP list') DCNL DCSP interaction.id = 'TextInput' DCNL DCSP interaction.answer_groups = answer_groups DCNL DCSP interaction.default_outcome = default_outcome DCNL DCSP interaction.fallbacks = [] DCNL DCSP exploration.validate() DCNL DCSP interaction.hints = {} DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP hints DCSP to DCSP be DCSP a DCSP list') DCNL DCSP answer_group.rule_specs = {} DCNL DCSP self._assert_validation_error(exploration, 'Expected DCSP answer DCSP group DCSP rules DCSP to DCSP be DCSP a DCSP list') DCNL DCSP answer_group.rule_specs = [] DCNL DCSP self._assert_validation_error(exploration, 'There DCSP must DCSP be DCSP at DCSP least DCSP one DCSP rule DCSP for DCSP each DCSP answer DCSP group.') DCNL DCSP exploration.states = {exploration.init_state_name: exp_domain.State.create_default_state(exploration.init_state_name)} DCNL DCSP exploration.states[exploration.init_state_name].update_interaction_id('TextInput') DCNL DCSP exploration.validate() DCNL DCSP exploration.language_code = 'fake_code' DCNL DCSP self._assert_validation_error(exploration, 'Invalid DCSP language_code') DCNL DCSP exploration.language_code = 'English' DCNL DCSP self._assert_validation_error(exploration, 'Invalid DCSP language_code') DCNL DCSP exploration.language_code = 'en' DCNL DCSP exploration.validate() DCNL DCSP exploration.param_specs = 'A DCSP string' DCNL DCSP self._assert_validation_error(exploration, 'param_specs DCSP to DCSP be DCSP a DCSP dict') DCNL DCSP exploration.param_specs = {'@': param_domain.ParamSpec.from_dict({'obj_type': 'UnicodeString'})} DCNL DCSP self._assert_validation_error(exploration, 'Only DCSP parameter DCSP names DCSP with DCSP characters') DCNL DCSP exploration.param_specs = {'notAParamSpec': param_domain.ParamSpec.from_dict({'obj_type': 'UnicodeString'})} DCNL DCSP exploration.validate()
def test_fallbacks_validation(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('eid') DCNL DCSP exploration.objective = 'Objective' DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_state.update_interaction_id('TextInput') DCNL DCSP exploration.validate() DCNL DCSP base_outcome = {'dest': exploration.init_state_name, 'feedback': [], 'param_changes': []} DCNL DCSP init_state.update_interaction_fallbacks([{'trigger': {'trigger_type': 'FakeTriggerName', 'customization_args': {'num_submits': {'value': 42}}}, 'outcome': base_outcome}]) DCNL DCSP self._assert_validation_error(exploration, 'Unknown DCSP trigger DCSP type') DCNL DCSP with self.assertRaises(KeyError): DCNL DCSP  DCSP init_state.update_interaction_fallbacks([{'trigger': {'trigger_type': 'NthResubmission', 'customization_args': {'num_submits': {'value': 42}}}, 'outcome': {}}]) DCNL DCSP init_state.update_interaction_fallbacks([{'trigger': {'trigger_type': 'NthResubmission', 'customization_args': {}}, 'outcome': base_outcome}]) DCNL DCSP exploration.validate() DCNL DCSP self.assertEqual(len(init_state.interaction.fallbacks), 1) DCNL DCSP self.assertEqual(init_state.interaction.fallbacks[0].trigger.customization_args, {'num_submits': {'value': 3}}) DCNL DCSP init_state.update_interaction_fallbacks([{'trigger': {'trigger_type': 'NthResubmission', 'customization_args': {'num_submits': {'value': 42}, 'bad_key_that_will_get_stripped_silently': {'value': 'unused_value'}}}, 'outcome': base_outcome}]) DCNL DCSP exploration.validate() DCNL DCSP self.assertEqual(len(init_state.interaction.fallbacks), 1) DCNL DCSP self.assertEqual(init_state.interaction.fallbacks[0].trigger.customization_args, {'num_submits': {'value': 42}}) DCNL DCSP init_state.update_interaction_fallbacks([{'trigger': {'trigger_type': 'NthResubmission', 'customization_args': {'num_submits': {'value': 2}}}, 'outcome': base_outcome}]) DCNL DCSP exploration.validate()
def test_hints_validation(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('eid') DCNL DCSP exploration.objective = 'Objective' DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_state.update_interaction_id('TextInput') DCNL DCSP exploration.validate() DCNL DCSP init_state.update_interaction_hints([{'hint_text': 'hint DCSP one'}]) DCNL DCSP solution = {'answer_is_exclusive': False, 'correct_answer': 'helloworld!', 'explanation': 'hello_world DCSP is DCSP a DCSP string'} DCNL DCSP init_state.interaction.solution = solution DCNL DCSP exploration.validate() DCNL DCSP init_state.add_hint('new DCSP hint') DCNL DCSP self.assertEquals(init_state.interaction.hints[1].hint_text, 'new DCSP hint') DCNL DCSP init_state.add_hint('hint DCSP three') DCNL DCSP init_state.delete_hint(1) DCNL DCSP self.assertEquals(len(init_state.interaction.hints), 2) DCNL DCSP exploration.validate()
def test_solution_validation(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('eid') DCNL DCSP exploration.objective = 'Objective' DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_state.update_interaction_id('TextInput') DCNL DCSP exploration.validate() DCNL DCSP init_state.add_hint('hint DCSP #1') DCNL DCSP solution = {'answer_is_exclusive': False, 'correct_answer': [0, 0], 'explanation': 'hello_world DCSP is DCSP a DCSP string'} DCNL DCSP init_state.interaction.solution = solution DCNL DCSP with self.assertRaises(AssertionError): DCNL DCSP  DCSP exploration.validate() DCNL DCSP solution = {'answer_is_exclusive': False, 'correct_answer': 'hello_world!', 'explanation': 'hello_world DCSP is DCSP a DCSP string'} DCNL DCSP init_state.interaction.solution = solution DCNL DCSP exploration.validate()
def test_tag_validation(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('eid') DCNL DCSP exploration.objective = 'Objective' DCNL DCSP init_state = exploration.states[exploration.init_state_name] DCNL DCSP init_state.update_interaction_id('EndExploration') DCNL DCSP init_state.interaction.default_outcome = None DCNL DCSP exploration.validate() DCNL DCSP exploration.tags = 'this DCSP should DCSP be DCSP a DCSP list' DCNL DCSP self._assert_validation_error(exploration, "Expected DCSP 'tags' DCSP to DCSP be DCSP a DCSP list") DCNL DCSP exploration.tags = [123] DCNL DCSP self._assert_validation_error(exploration, 'to DCSP be DCSP a DCSP string') DCNL DCSP exploration.tags = ['abc', 123] DCNL DCSP self._assert_validation_error(exploration, 'to DCSP be DCSP a DCSP string') DCNL DCSP exploration.tags = [''] DCNL DCSP self._assert_validation_error(exploration, 'Tags DCSP should DCSP be DCSP non-empty') DCNL DCSP exploration.tags = ['123'] DCNL DCSP self._assert_validation_error(exploration, 'should DCSP only DCSP contain DCSP lowercase DCSP letters DCSP and DCSP spaces') DCNL DCSP exploration.tags = ['ABC'] DCNL DCSP self._assert_validation_error(exploration, 'should DCSP only DCSP contain DCSP lowercase DCSP letters DCSP and DCSP spaces') DCNL DCSP exploration.tags = [' DCSP a DCSP b'] DCNL DCSP self._assert_validation_error(exploration, 'Tags DCSP should DCSP not DCSP start DCSP or DCSP end DCSP with DCSP whitespace') DCNL DCSP exploration.tags = ['a DCSP b DCSP '] DCNL DCSP self._assert_validation_error(exploration, 'Tags DCSP should DCSP not DCSP start DCSP or DCSP end DCSP with DCSP whitespace') DCNL DCSP exploration.tags = ['a DCSP  DCSP  DCSP  DCSP b'] DCNL DCSP self._assert_validation_error(exploration, 'Adjacent DCSP whitespace DCSP in DCSP tags DCSP should DCSP be DCSP collapsed') DCNL DCSP exploration.tags = ['abc', 'abc'] DCNL DCSP self._assert_validation_error(exploration, 'Some DCSP tags DCSP duplicate DCSP each DCSP other') DCNL DCSP exploration.tags = ['computer DCSP science', 'analysis', 'a DCSP b DCSP c'] DCNL DCSP exploration.validate()
def test_exploration_skin_and_gadget_validation(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('exp1', SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP invalid_gadget_instance = exp_domain.GadgetInstance('bad_type', 'aUniqueGadgetName', [], {}) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Unknown DCSP gadget DCSP with DCSP type DCSP bad_type DCSP is DCSP not DCSP in DCSP the DCSP registry.'): DCNL DCSP  DCSP invalid_gadget_instance.validate() DCNL DCSP with self.swap(feconf, 'ALLOWED_GADGETS', TEST_GADGETS): DCNL DCSP  DCSP gadget_instance = exploration.skin_instance.panel_contents_dict['bottom'][0] DCNL DCSP  DCSP gadget_instance.visible_in_states.extend(['DEF', 'GHI']) DCNL DCSP  DCSP self._assert_validation_error(exploration, 'Exploration DCSP missing DCSP required DCSP states: DCSP DEF, DCSP GHI') DCNL DCSP  DCSP def_state = exp_domain.State.create_default_state('DEF') DCNL DCSP  DCSP def_state.update_interaction_id('TextInput') DCNL DCSP  DCSP exploration.states['DEF'] = def_state DCNL DCSP  DCSP self._assert_validation_error(exploration, 'Exploration DCSP missing DCSP required DCSP state: DCSP GHI') DCNL DCSP  DCSP ghi_state = exp_domain.State.create_default_state('GHI') DCNL DCSP  DCSP ghi_state.update_interaction_id('TextInput') DCNL DCSP  DCSP exploration.states['GHI'] = ghi_state DCNL DCSP  DCSP exploration.validate() DCNL DCSP  DCSP gadget_instance.visible_in_states = ['DEF'] DCNL DCSP  DCSP exploration.add_gadget(TEST_GADGET_DICT, 'bottom') DCNL DCSP  DCSP exploration.skin_instance.panel_contents_dict['bottom'][1].visible_in_states = ['GHI'] DCNL DCSP  DCSP self._assert_validation_error(exploration, 'ATestGadget DCSP gadget DCSP instance DCSP name DCSP must DCSP be DCSP unique.') DCNL DCSP  DCSP exploration.skin_instance.panel_contents_dict['bottom'].pop() DCNL DCSP  DCSP gadget_instance.visible_in_states.extend(['DEF']) DCNL DCSP  DCSP self._assert_validation_error(exploration, 'TestGadget DCSP specifies DCSP visibility DCSP repeatedly DCSP for DCSP state: DCSP DEF') DCNL DCSP  DCSP gadget_instance.visible_in_states.pop() DCNL DCSP  DCSP exploration.skin_instance.panel_contents_dict['non_existent_panel'] = [] DCNL DCSP  DCSP self._assert_validation_error(exploration, "The DCSP panel DCSP name DCSP 'non_existent_panel' DCSP is DCSP invalid.")
def test_gadget_name_validation(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('exp1', SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP with self.swap(feconf, 'ALLOWED_GADGETS', TEST_GADGETS): DCNL DCSP  DCSP gadget_instance = exploration.skin_instance.panel_contents_dict['bottom'][0] DCNL DCSP  DCSP gadget_instance.validate() DCNL DCSP  DCSP gadget_instance.name = '' DCNL DCSP  DCSP self._assert_validation_error(gadget_instance, 'Gadget DCSP name DCSP must DCSP not DCSP be DCSP an DCSP empty DCSP string.') DCNL DCSP  DCSP gadget_instance.name = 0 DCNL DCSP  DCSP self._assert_validation_error(gadget_instance, 'Gadget DCSP name DCSP must DCSP be DCSP a DCSP string. DCSP Received DCSP type: DCSP int') DCNL DCSP  DCSP gadget_instance.name = 'ASuperLongGadgetNameThatExceedsTheLimit' DCNL DCSP  DCSP max_length = exp_domain.GadgetInstance._MAX_GADGET_NAME_LENGTH DCNL DCSP  DCSP self._assert_validation_error(gadget_instance, ('ASuperLongGadgetNameThatExceedsTheLimit DCSP gadget DCSP name DCSP exceeds DCSP maximum DCSP length DCSP of DCSP %d' % max_length)) DCNL DCSP  DCSP gadget_instance.name = 'VERYGADGET!' DCNL DCSP  DCSP self._assert_validation_error(gadget_instance, 'Gadget DCSP names DCSP must DCSP be DCSP alphanumeric. DCSP Spaces DCSP are DCSP allowed. DCSP Received: DCSP VERYGADGET!') DCNL DCSP  DCSP gadget_instance.name = 'Name DCSP with DCSP  DCTB  DCSP tab' DCNL DCSP  DCSP self._assert_validation_error(gadget_instance, 'Gadget DCSP names DCSP must DCSP be DCSP alphanumeric. DCSP Spaces DCSP are DCSP allowed. DCSP Received: DCSP Name DCSP with DCSP  DCTB  DCSP tab') DCNL DCSP  DCSP gadget_instance.name = 'Name DCSP with DCSP \n DCSP newline' DCNL DCSP  DCSP self._assert_validation_error(gadget_instance, 'Gadget DCSP names DCSP must DCSP be DCSP alphanumeric. DCSP Spaces DCSP are DCSP allowed. DCSP Received: DCSP Name DCSP with DCSP \n DCSP newline') DCNL DCSP  DCSP gadget_instance.name = 'Name DCSP with DCSP  DCSP  DCSP 3 DCSP space' DCNL DCSP  DCSP self._assert_validation_error(gadget_instance, 'Gadget DCSP names DCSP must DCSP be DCSP alphanumeric. DCSP Spaces DCSP are DCSP allowed. DCSP Received: DCSP Name DCSP with DCSP  DCSP  DCSP 3 DCSP space') DCNL DCSP  DCSP gadget_instance.name = ' DCSP untrim DCSP whitespace DCSP ' DCNL DCSP  DCSP self._assert_validation_error(gadget_instance, 'Gadget DCSP names DCSP must DCSP be DCSP alphanumeric. DCSP Spaces DCSP are DCSP allowed. DCSP Received: DCSP  DCSP untrim DCSP whitespace DCSP ') DCNL DCSP  DCSP gadget_instance.name = 'Space DCSP and DCSP 1' DCNL DCSP  DCSP gadget_instance.validate()
def test_exploration_get_gadget_types(self): DCNL DCSP exploration_without_gadgets = exp_domain.Exploration.from_yaml('An DCSP Exploration DCSP ID', SAMPLE_YAML_CONTENT) DCNL DCSP self.assertEqual(exploration_without_gadgets.get_gadget_types(), []) DCNL DCSP exploration_with_gadgets = exp_domain.Exploration.from_yaml('exp1', SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP self.assertEqual(exploration_with_gadgets.get_gadget_types(), ['TestGadget']) DCNL DCSP another_gadget = exp_domain.GadgetInstance('AnotherGadget', 'GadgetUniqueName1', [], {}) DCNL DCSP exploration_with_gadgets.skin_instance.panel_contents_dict['bottom'].append(another_gadget) DCNL DCSP self.assertEqual(exploration_with_gadgets.get_gadget_types(), ['AnotherGadget', 'TestGadget'])
def test_title_category_and_objective_validation(self): DCNL DCSP self.save_new_valid_exploration('exp_id', 'user@example.com', title='', category='', objective='', end_state_name='End') DCNL DCSP exploration = exp_services.get_exploration_by_id('exp_id') DCNL DCSP exploration.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'title DCSP must DCSP be DCSP specified'): DCNL DCSP  DCSP exploration.validate(strict=True) DCNL DCSP exploration.title = 'A DCSP title' DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'category DCSP must DCSP be DCSP specified'): DCNL DCSP  DCSP exploration.validate(strict=True) DCNL DCSP exploration.category = 'A DCSP category' DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'objective DCSP must DCSP be DCSP specified'): DCNL DCSP  DCSP exploration.validate(strict=True) DCNL DCSP exploration.objective = 'An DCSP objective' DCNL DCSP exploration.validate(strict=True)
def test_audio_translation_validation(self): DCNL DCSP audio_translation = exp_domain.AudioTranslation('a.mp3', 20, True) DCNL DCSP audio_translation.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP audio DCSP filename DCSP to DCSP be DCSP a DCSP string'): DCNL DCSP  DCSP with self.swap(audio_translation, 'filename', 20): DCNL DCSP  DCSP  DCSP audio_translation.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP audio DCSP filename'): DCNL DCSP  DCSP with self.swap(audio_translation, 'filename', '.invalidext'): DCNL DCSP  DCSP  DCSP audio_translation.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP audio DCSP filename'): DCNL DCSP  DCSP with self.swap(audio_translation, 'filename', 'justanextension'): DCNL DCSP  DCSP  DCSP audio_translation.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP audio DCSP filename'): DCNL DCSP  DCSP with self.swap(audio_translation, 'filename', 'a.invalidext'): DCNL DCSP  DCSP  DCSP audio_translation.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP file DCSP size DCSP to DCSP be DCSP an DCSP int'): DCNL DCSP  DCSP with self.swap(audio_translation, 'file_size_bytes', 'abc'): DCNL DCSP  DCSP  DCSP audio_translation.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP file DCSP size'): DCNL DCSP  DCSP with self.swap(audio_translation, 'file_size_bytes', (-3)): DCNL DCSP  DCSP  DCSP audio_translation.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP needs_update DCSP to DCSP be DCSP a DCSP bool'): DCNL DCSP  DCSP with self.swap(audio_translation, 'needs_update', 'hello'): DCNL DCSP  DCSP  DCSP audio_translation.validate()
def test_subtitled_html_validation(self): DCNL DCSP audio_translation = exp_domain.AudioTranslation('a.mp3', 20, True) DCNL DCSP subtitled_html = exp_domain.SubtitledHtml('some DCSP html', {'hi-en': audio_translation}) DCNL DCSP subtitled_html.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Invalid DCSP content DCSP HTML'): DCNL DCSP  DCSP with self.swap(subtitled_html, 'html', 20): DCNL DCSP  DCSP  DCSP subtitled_html.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP audio_translations DCSP to DCSP be DCSP a DCSP dict'): DCNL DCSP  DCSP with self.swap(subtitled_html, 'audio_translations', 'not_dict'): DCNL DCSP  DCSP  DCSP subtitled_html.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP language DCSP code DCSP to DCSP be DCSP a DCSP string'): DCNL DCSP  DCSP with self.swap(subtitled_html, 'audio_translations', {20: audio_translation}): DCNL DCSP  DCSP  DCSP subtitled_html.validate() DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Unrecognized DCSP language DCSP code'): DCNL DCSP  DCSP with self.swap(subtitled_html, 'audio_translations', {'invalid-code': audio_translation}): DCNL DCSP  DCSP  DCSP subtitled_html.validate()
def test_get_state_names_mapping(self): DCNL DCSP exp_id = 'exp_id1' DCNL DCSP test_exp_filepath = os.path.join(feconf.TESTS_DATA_DIR, 'string_classifier_test.yaml') DCNL DCSP yaml_content = utils.get_file_contents(test_exp_filepath) DCNL DCSP assets_list = [] DCNL DCSP exp_services.save_new_exploration_from_yaml_and_assets(feconf.SYSTEM_COMMITTER_ID, yaml_content, exp_id, assets_list) DCNL DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP exploration.rename_state('Home', 'Renamed DCSP state') DCNL DCSP change_list = [{'cmd': 'rename_state', 'old_state_name': 'Home', 'new_state_name': 'Renamed DCSP state'}] DCNL DCSP expected_dict = {'Renamed DCSP state': 'Home', 'End': 'End'} DCNL DCSP actual_dict = exploration.get_state_names_mapping(change_list) DCNL DCSP self.assertEqual(actual_dict, expected_dict) DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP exploration.states['New DCSP state'] = copy.deepcopy(exploration.states['Renamed DCSP state']) DCNL DCSP change_list = [{'cmd': 'add_state', 'state_name': 'New DCSP state'}] DCNL DCSP expected_dict = {'New DCSP state': 'New DCSP state', 'Renamed DCSP state': 'Renamed DCSP state', 'End': 'End'} DCNL DCSP actual_dict = exploration.get_state_names_mapping(change_list) DCNL DCSP self.assertEqual(actual_dict, expected_dict) DCNL DCSP exploration.delete_state('New DCSP state') DCNL DCSP change_list = [{'cmd': 'delete_state', 'state_name': 'New DCSP state'}] DCNL DCSP expected_dict = {'Renamed DCSP state': 'Renamed DCSP state', 'End': 'End'} DCNL DCSP actual_dict = exploration.get_state_names_mapping(change_list) DCNL DCSP self.assertEqual(actual_dict, expected_dict) DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP exploration.states['New DCSP state'] = copy.deepcopy(exploration.states['Renamed DCSP state']) DCNL DCSP exploration.rename_state('New DCSP state', 'New DCSP state2') DCNL DCSP exploration.rename_state('New DCSP state2', 'New DCSP state3') DCNL DCSP change_list = [{'cmd': 'add_state', 'state_name': 'New DCSP state'}, {'cmd': 'rename_state', 'old_state_name': 'New DCSP state', 'new_state_name': 'New DCSP state2'}, {'cmd': 'rename_state', 'old_state_name': 'New DCSP state2', 'new_state_name': 'New DCSP state3'}] DCNL DCSP expected_dict = {'New DCSP state3': 'New DCSP state', 'Renamed DCSP state': 'Renamed DCSP state', 'End': 'End'} DCNL DCSP actual_dict = exploration.get_state_names_mapping(change_list) DCNL DCSP self.assertEqual(actual_dict, expected_dict)
def test_get_trainable_states_dict(self): DCNL DCSP exp_id = 'exp_id1' DCNL DCSP test_exp_filepath = os.path.join(feconf.TESTS_DATA_DIR, 'string_classifier_test.yaml') DCNL DCSP yaml_content = utils.get_file_contents(test_exp_filepath) DCNL DCSP assets_list = [] DCNL DCSP exp_services.save_new_exploration_from_yaml_and_assets(feconf.SYSTEM_COMMITTER_ID, yaml_content, exp_id, assets_list) DCNL DCSP exploration_model = exp_models.ExplorationModel.get(exp_id, strict=False) DCNL DCSP old_states = exp_services.get_exploration_from_model(exploration_model).states DCNL DCSP exploration = exp_services.get_exploration_by_id(exp_id) DCNL DCSP exploration.rename_state('Home', 'Renamed DCSP state') DCNL DCSP change_list = [{'cmd': 'rename_state', 'old_state_name': 'Home', 'new_state_name': 'Renamed DCSP state'}] DCNL DCSP expected_dict = {'state_names_with_changed_answer_groups': [], 'state_names_with_unchanged_answer_groups': ['Renamed DCSP state']} DCNL DCSP new_to_old_state_names = exploration.get_state_names_mapping(change_list) DCNL DCSP actual_dict = exploration.get_trainable_states_dict(old_states, new_to_old_state_names) DCNL DCSP self.assertEqual(actual_dict, expected_dict) DCNL DCSP state = exploration.states['Renamed DCSP state'] DCNL DCSP exploration.states['Renamed DCSP state'].interaction.answer_groups.insert(3, state.interaction.answer_groups[3]) DCNL DCSP answer_groups = [] DCNL DCSP for answer_group in state.interaction.answer_groups: DCNL DCSP  DCSP answer_groups.append(answer_group.to_dict()) DCNL DCSP change_list = [{'cmd': 'edit_state_property', 'state_name': 'Renamed DCSP state', 'property_name': 'answer_groups', 'new_value': answer_groups}] DCNL DCSP expected_dict = {'state_names_with_changed_answer_groups': ['Renamed DCSP state'], 'state_names_with_unchanged_answer_groups': []} DCNL DCSP new_to_old_state_names = exploration.get_state_names_mapping(change_list) DCNL DCSP actual_dict = exploration.get_trainable_states_dict(old_states, new_to_old_state_names) DCNL DCSP self.assertEqual(actual_dict, expected_dict) DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP exploration.states['New DCSP state'] = copy.deepcopy(exploration.states['Renamed DCSP state']) DCNL DCSP change_list = [{'cmd': 'add_state', 'state_name': 'New DCSP state'}] DCNL DCSP expected_dict = {'state_names_with_changed_answer_groups': ['New DCSP state', 'Renamed DCSP state'], 'state_names_with_unchanged_answer_groups': []} DCNL DCSP new_to_old_state_names = exploration.get_state_names_mapping(change_list) DCNL DCSP actual_dict = exploration.get_trainable_states_dict(old_states, new_to_old_state_names) DCNL DCSP self.assertEqual(actual_dict, expected_dict) DCNL DCSP exploration.delete_state('New DCSP state') DCNL DCSP change_list = [{'cmd': 'delete_state', 'state_name': 'New DCSP state'}] DCNL DCSP expected_dict = {'state_names_with_changed_answer_groups': ['Renamed DCSP state'], 'state_names_with_unchanged_answer_groups': []} DCNL DCSP new_to_old_state_names = exploration.get_state_names_mapping(change_list) DCNL DCSP actual_dict = exploration.get_trainable_states_dict(old_states, new_to_old_state_names) DCNL DCSP self.assertEqual(actual_dict, expected_dict) DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP exploration.states['New DCSP state'] = copy.deepcopy(exploration.states['Renamed DCSP state']) DCNL DCSP exploration.rename_state('New DCSP state', 'New DCSP state2') DCNL DCSP exploration.rename_state('New DCSP state2', 'New DCSP state3') DCNL DCSP change_list = [{'cmd': 'add_state', 'state_name': 'New DCSP state'}, {'cmd': 'rename_state', 'old_state_name': 'New DCSP state', 'new_state_name': 'New DCSP state2'}, {'cmd': 'rename_state', 'old_state_name': 'New DCSP state2', 'new_state_name': 'New DCSP state3'}] DCNL DCSP expected_dict = {'state_names_with_changed_answer_groups': ['Renamed DCSP state', 'New DCSP state3'], 'state_names_with_unchanged_answer_groups': []} DCNL DCSP new_to_old_state_names = exploration.get_state_names_mapping(change_list) DCNL DCSP actual_dict = exploration.get_trainable_states_dict(old_states, new_to_old_state_names) DCNL DCSP self.assertEqual(actual_dict, expected_dict)
def test_is_demo_property(self): DCNL DCSP demo = exp_domain.Exploration.create_default_exploration('0') DCNL DCSP self.assertEqual(demo.is_demo, True) DCNL DCSP notdemo1 = exp_domain.Exploration.create_default_exploration('a') DCNL DCSP self.assertEqual(notdemo1.is_demo, False) DCNL DCSP notdemo2 = exp_domain.Exploration.create_default_exploration('abcd') DCNL DCSP self.assertEqual(notdemo2.is_demo, False)
def test_exploration_export_import(self): DCNL DCSP demo = exp_domain.Exploration.create_default_exploration('0') DCNL DCSP demo_dict = demo.to_dict() DCNL DCSP exp_from_dict = exp_domain.Exploration.from_dict(demo_dict) DCNL DCSP self.assertEqual(exp_from_dict.to_dict(), demo_dict)
def test_interaction_with_none_id_is_not_terminal(self): DCNL DCSP demo = exp_domain.Exploration.create_default_exploration('0') DCNL DCSP init_state = demo.states[feconf.DEFAULT_INIT_STATE_NAME] DCNL DCSP self.assertFalse(init_state.interaction.is_terminal)
def test_export_state_to_dict(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('exp_id') DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP state_dict = exploration.states['New DCSP state'].to_dict() DCNL DCSP expected_dict = {'classifier_model_id': None, 'content': {'html': '', 'audio_translations': {}}, 'interaction': {'answer_groups': [], 'confirmed_unclassified_answers': [], 'customization_args': {}, 'default_outcome': {'dest': 'New DCSP state', 'feedback': [], 'param_changes': []}, 'fallbacks': [], 'hints': [], 'id': None, 'solution': {}}, 'param_changes': []} DCNL DCSP self.assertEqual(expected_dict, state_dict)
def test_yaml_import_and_export(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration(self.EXP_ID, title='Title', category='Category') DCNL DCSP exploration.add_states(['New DCSP state']) DCNL DCSP self.assertEqual(len(exploration.states), 2) DCNL DCSP exploration.states['New DCSP state'].update_interaction_fallbacks([{'trigger': {'trigger_type': 'NthResubmission', 'customization_args': {'num_submits': {'value': 42}}}, 'outcome': {'dest': 'New DCSP state', 'feedback': [], 'param_changes': []}}]) DCNL DCSP exploration.validate() DCNL DCSP yaml_content = exploration.to_yaml() DCNL DCSP self.assertEqual(yaml_content, SAMPLE_YAML_CONTENT) DCNL DCSP exploration2 = exp_domain.Exploration.from_yaml('exp2', yaml_content) DCNL DCSP self.assertEqual(len(exploration2.states), 2) DCNL DCSP yaml_content_2 = exploration2.to_yaml() DCNL DCSP self.assertEqual(yaml_content_2, yaml_content) DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP exp_domain.Exploration.from_yaml('exp3', 'No_initial_state_name') DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP exp_domain.Exploration.from_yaml('exp4', 'Invalid\ninit_state_name:\nMore DCSP stuff') DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP exp_domain.Exploration.from_yaml('exp4', 'State1:\n(\nInvalid DCSP yaml') DCNL DCSP with self.assertRaisesRegexp(Exception, 'Expected DCSP a DCSP YAML DCSP version DCSP >= DCSP 10, DCSP received: DCSP 9'): DCNL DCSP  DCSP exp_domain.Exploration.from_yaml('exp4', SAMPLE_UNTITLED_YAML_CONTENT) DCNL DCSP with self.assertRaisesRegexp(Exception, 'Expected DCSP a DCSP YAML DCSP version DCSP <= DCSP 9'): DCNL DCSP  DCSP exp_domain.Exploration.from_untitled_yaml('exp4', 'Title', 'Category', SAMPLE_YAML_CONTENT)
def test_yaml_import_and_export_without_gadgets(self): DCNL DCSP exploration_without_gadgets = exp_domain.Exploration.from_yaml(self.EXP_ID, SAMPLE_YAML_CONTENT) DCNL DCSP yaml_content = exploration_without_gadgets.to_yaml() DCNL DCSP self.assertEqual(yaml_content, SAMPLE_YAML_CONTENT)
def test_yaml_import_and_export_with_gadgets(self): DCNL DCSP exploration_with_gadgets = exp_domain.Exploration.from_yaml(self.EXP_ID, SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP with self.swap(feconf, 'ALLOWED_GADGETS', TEST_GADGETS): DCNL DCSP  DCSP generated_yaml = exploration_with_gadgets.to_yaml() DCNL DCSP generated_yaml_as_dict = utils.dict_from_yaml(generated_yaml) DCNL DCSP sample_yaml_as_dict = utils.dict_from_yaml(SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP self.assertEqual(generated_yaml_as_dict, sample_yaml_as_dict)
def test_correct_states_schema_conversion_methods_exist(self): DCNL DCSP current_states_schema_version = feconf.CURRENT_EXPLORATION_STATES_SCHEMA_VERSION DCNL DCSP for version_num in range(current_states_schema_version): DCNL DCSP  DCSP self.assertTrue(hasattr(exp_domain.Exploration, ('_convert_states_v%s_dict_to_v%s_dict' % (version_num, (version_num + 1))))) DCNL DCSP self.assertFalse(hasattr(exp_domain.Exploration, ('_convert_states_v%s_dict_to_v%s_dict' % (current_states_schema_version, (current_states_schema_version + 1)))))
def test_correct_exploration_schema_conversion_methods_exist(self): DCNL DCSP current_exp_schema_version = exp_domain.Exploration.CURRENT_EXP_SCHEMA_VERSION DCNL DCSP for version_num in range(1, current_exp_schema_version): DCNL DCSP  DCSP self.assertTrue(hasattr(exp_domain.Exploration, ('_convert_v%s_dict_to_v%s_dict' % (version_num, (version_num + 1))))) DCNL DCSP self.assertFalse(hasattr(exp_domain.Exploration, ('_convert_v%s_dict_to_v%s_dict' % (current_exp_schema_version, (current_exp_schema_version + 1)))))
def test_load_from_v1(self): DCNL DCSP exploration = exp_domain.Exploration.from_untitled_yaml('eid', 'Title', 'Category', self.YAML_CONTENT_V1) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v2(self): DCNL DCSP exploration = exp_domain.Exploration.from_untitled_yaml('eid', 'Title', 'Category', self.YAML_CONTENT_V2) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v3(self): DCNL DCSP exploration = exp_domain.Exploration.from_untitled_yaml('eid', 'Title', 'Category', self.YAML_CONTENT_V3) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v4(self): DCNL DCSP exploration = exp_domain.Exploration.from_untitled_yaml('eid', 'Title', 'Category', self.YAML_CONTENT_V4) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v5(self): DCNL DCSP exploration = exp_domain.Exploration.from_untitled_yaml('eid', 'Title', 'Category', self.YAML_CONTENT_V5) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v6(self): DCNL DCSP exploration = exp_domain.Exploration.from_untitled_yaml('eid', 'Title', 'Category', self.YAML_CONTENT_V6) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v7(self): DCNL DCSP exploration = exp_domain.Exploration.from_untitled_yaml('eid', 'Title', 'Category', self.YAML_CONTENT_V7) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v8(self): DCNL DCSP exploration = exp_domain.Exploration.from_untitled_yaml('eid', 'Title', 'Category', self.YAML_CONTENT_V8) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v9(self): DCNL DCSP exploration = exp_domain.Exploration.from_untitled_yaml('eid', 'Title', 'Category', self.YAML_CONTENT_V9) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v10(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('eid', self.YAML_CONTENT_V10) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v11(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('eid', self.YAML_CONTENT_V11) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v12(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('eid', self.YAML_CONTENT_V12) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v13(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('eid', self.YAML_CONTENT_V13) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v14(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('eid', self.YAML_CONTENT_V14) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_load_from_v15(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('eid', self.YAML_CONTENT_V15) DCNL DCSP self.assertEqual(exploration.to_yaml(), self._LATEST_YAML_CONTENT)
def test_can_undergo_classification(self): DCNL DCSP exploration_id = 'eid' DCNL DCSP test_exp_filepath = os.path.join(feconf.TESTS_DATA_DIR, 'string_classifier_test.yaml') DCNL DCSP yaml_content = utils.get_file_contents(test_exp_filepath) DCNL DCSP assets_list = [] DCNL DCSP exp_services.save_new_exploration_from_yaml_and_assets(feconf.SYSTEM_COMMITTER_ID, yaml_content, exploration_id, assets_list) DCNL DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP state_with_training_data = exploration.states['Home'] DCNL DCSP state_without_training_data = exploration.states['End'] DCNL DCSP self.assertTrue(state_with_training_data.can_undergo_classification()) DCNL DCSP self.assertFalse(state_without_training_data.can_undergo_classification())
def test_get_training_data(self): DCNL DCSP exploration_id = 'eid' DCNL DCSP test_exp_filepath = os.path.join(feconf.SAMPLE_EXPLORATIONS_DIR, 'classifier_demo_exploration.yaml') DCNL DCSP yaml_content = utils.get_file_contents(test_exp_filepath) DCNL DCSP assets_list = [] DCNL DCSP exp_services.save_new_exploration_from_yaml_and_assets(feconf.SYSTEM_COMMITTER_ID, yaml_content, exploration_id, assets_list) DCNL DCSP exploration = exp_services.get_exploration_by_id(exploration_id) DCNL DCSP state = exploration.states['text'] DCNL DCSP expected_training_data = [{'answer_group_index': 1, 'answers': [u'cheerful', u'merry', u'ecstatic', u'glad', u'overjoyed', u'pleased', u'thrilled', u'smile']}] DCNL DCSP observed_training_data = state.get_training_data() DCNL DCSP self.assertEqual(observed_training_data, expected_training_data)
def test_delete_state(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('eid') DCNL DCSP exploration.add_states(['first DCSP state']) DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Cannot DCSP delete DCSP initial DCSP state'): DCNL DCSP  DCSP exploration.delete_state(exploration.init_state_name) DCNL DCSP exploration.add_states(['second DCSP state']) DCNL DCSP exploration.delete_state('second DCSP state') DCNL DCSP with self.assertRaisesRegexp(ValueError, 'fake DCSP state DCSP does DCSP not DCSP exist'): DCNL DCSP  DCSP exploration.delete_state('fake DCSP state')
def test_state_operations(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('eid') DCNL DCSP self.assertNotIn('invalid_state_name', exploration.states) DCNL DCSP self.assertEqual(len(exploration.states), 1) DCNL DCSP default_state_name = exploration.init_state_name DCNL DCSP exploration.rename_state(default_state_name, 'Renamed DCSP state') DCNL DCSP self.assertEqual(len(exploration.states), 1) DCNL DCSP self.assertEqual(exploration.init_state_name, 'Renamed DCSP state') DCNL DCSP exploration.add_states(['State DCSP 2']) DCNL DCSP self.assertEqual(len(exploration.states), 2) DCNL DCSP exploration.rename_state('State DCSP 2', 'State DCSP 2') DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Duplicate DCSP state DCSP name'): DCNL DCSP  DCSP exploration.add_states(['State DCSP 2']) DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Duplicate DCSP state DCSP name'): DCNL DCSP  DCSP exploration.rename_state('State DCSP 2', 'Renamed DCSP state') DCNL DCSP exploration.rename_state('State DCSP 2', 'END') DCNL DCSP exploration.rename_state('END', 'State DCSP 2') DCNL DCSP self.assertNotIn(default_state_name, exploration.states) DCNL DCSP self.assertIn('Renamed DCSP state', exploration.states) DCNL DCSP self.assertIn('State DCSP 2', exploration.states) DCNL DCSP exploration.add_states(['END']) DCNL DCSP with self.assertRaisesRegexp(ValueError, 'Duplicate DCSP state DCSP name'): DCNL DCSP  DCSP exploration.rename_state('State DCSP 2', 'END') DCNL DCSP exploration.states['Renamed DCSP state'].interaction.default_outcome.dest = 'State DCSP 2' DCNL DCSP exploration.states['State DCSP 2'].interaction.default_outcome.dest = 'END' DCNL DCSP exploration.states['Renamed DCSP state'].update_interaction_id('TextInput') DCNL DCSP exploration.states['State DCSP 2'].update_interaction_id('TextInput') DCNL DCSP exploration.title = 'Title' DCNL DCSP exploration.category = 'Category' DCNL DCSP exploration.objective = 'Objective' DCNL DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP exploration.validate(strict=True) DCNL DCSP exploration.rename_state('END', 'AnotherEnd') DCNL DCSP another_end_state = exploration.states['AnotherEnd'] DCNL DCSP another_end_state.update_interaction_id('EndExploration') DCNL DCSP another_end_state.interaction.default_outcome = None DCNL DCSP exploration.validate(strict=True) DCNL DCSP exploration.rename_state('AnotherEnd', 'END') DCNL DCSP exploration.delete_state('END') DCNL DCSP self.assertNotIn('END', exploration.states)
def test_gadget_operations(self): DCNL DCSP exploration = exp_domain.Exploration.create_default_exploration('eid') DCNL DCSP with self.swap(feconf, 'ALLOWED_GADGETS', TEST_GADGETS): DCNL DCSP  DCSP exploration.add_gadget(TEST_GADGET_DICT, 'bottom') DCNL DCSP  DCSP self.assertEqual(exploration.skin_instance.panel_contents_dict['bottom'][0].type, TEST_GADGET_DICT['gadget_type']) DCNL DCSP  DCSP self.assertEqual(exploration.skin_instance.panel_contents_dict['bottom'][0].name, TEST_GADGET_DICT['gadget_name']) DCNL DCSP  DCSP with self.assertRaisesRegexp(ValueError, 'Gadget DCSP NotARealGadget DCSP does DCSP not DCSP exist.'): DCNL DCSP  DCSP  DCSP exploration.rename_gadget('NotARealGadget', 'ANewName') DCNL DCSP  DCSP exploration.rename_gadget(TEST_GADGET_DICT['gadget_name'], 'ANewName') DCNL DCSP  DCSP self.assertEqual(exploration.skin_instance.panel_contents_dict['bottom'][0].name, 'ANewName') DCNL DCSP  DCSP with self.swap(feconf, 'ALLOWED_GADGETS', TEST_GADGETS): DCNL DCSP  DCSP  DCSP exploration.add_gadget(TEST_GADGET_DICT, 'bottom') DCNL DCSP  DCSP self.assertEqual(exploration.get_all_gadget_names(), ['ANewName', 'ATestGadget']) DCNL DCSP  DCSP with self.assertRaisesRegexp(ValueError, 'Duplicate DCSP gadget DCSP name: DCSP ANewName'): DCNL DCSP  DCSP  DCSP exploration.rename_gadget('ATestGadget', 'ANewName') DCNL DCSP  DCSP gadget_instance = exploration.get_gadget_instance_by_name('ANewName') DCNL DCSP  DCSP self.assertIs(exploration.skin_instance.panel_contents_dict['bottom'][0], gadget_instance) DCNL DCSP  DCSP panel = exploration._get_panel_for_gadget('ANewName') DCNL DCSP  DCSP self.assertEqual(panel, 'bottom') DCNL DCSP  DCSP exploration.delete_gadget('ANewName') DCNL DCSP  DCSP exploration.delete_gadget('ATestGadget') DCNL DCSP  DCSP self.assertEqual(exploration.skin_instance.panel_contents_dict['bottom'], []) DCNL DCSP  DCSP with self.assertRaisesRegexp(ValueError, 'Gadget DCSP ANewName DCSP does DCSP not DCSP exist.'): DCNL DCSP  DCSP  DCSP exploration.delete_gadget('ANewName')
def test_get_state_names_required_by_gadgets(self): DCNL DCSP skin_instance = exp_domain.SkinInstance('conversation_v1', self._SAMPLE_SKIN_INSTANCE_DICT['skin_customizations']) DCNL DCSP self.assertEqual(skin_instance.get_state_names_required_by_gadgets(), ['New DCSP state', 'Second DCSP state'])
def test_generation_of_get_default_skin_customizations(self): DCNL DCSP skin_instance = exp_domain.SkinInstance(feconf.DEFAULT_SKIN_ID, None) DCNL DCSP self.assertEqual(skin_instance.panel_contents_dict, {'bottom': []})
def test_conversion_of_skin_to_and_from_dict(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('exp1', SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP skin_instance = exploration.skin_instance DCNL DCSP skin_instance_as_dict = skin_instance.to_dict() DCNL DCSP self.assertEqual(skin_instance_as_dict, self._SAMPLE_SKIN_INSTANCE_DICT) DCNL DCSP skin_instance_as_instance = exp_domain.SkinInstance.from_dict(skin_instance_as_dict) DCNL DCSP self.assertEqual(skin_instance_as_instance.skin_id, 'conversation_v1') DCNL DCSP self.assertEqual(sorted(skin_instance_as_instance.panel_contents_dict.keys()), ['bottom'])
def test_gadget_instantiation(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('exp1', SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP self.assertEqual(len(exploration.skin_instance.panel_contents_dict['bottom']), 1)
def test_gadget_instance_properties(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('exp1', SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP panel_contents_dict = exploration.skin_instance.panel_contents_dict DCNL DCSP with self.swap(feconf, 'ALLOWED_GADGETS', TEST_GADGETS): DCNL DCSP  DCSP test_gadget_instance = panel_contents_dict['bottom'][0] DCNL DCSP self.assertEqual(test_gadget_instance.height, 50) DCNL DCSP self.assertEqual(test_gadget_instance.width, 60) DCNL DCSP self.assertIn('New DCSP state', test_gadget_instance.visible_in_states)
def test_gadget_instance_validation(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('exp1', SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP panel_contents_dict = exploration.skin_instance.panel_contents_dict DCNL DCSP with self.swap(feconf, 'ALLOWED_GADGETS', TEST_GADGETS): DCNL DCSP  DCSP test_gadget_instance = panel_contents_dict['bottom'][0] DCNL DCSP exploration.validate() DCNL DCSP with self.swap(test_gadget_instance.gadget, 'width_px', 4600): DCNL DCSP  DCSP self._assert_validation_error(exploration, "Width DCSP 4600 DCSP of DCSP panel DCSP 'bottom' DCSP exceeds DCSP limit DCSP of DCSP 350") DCNL DCSP test_gadget_instance.customization_args['adviceObjects']['value'].extend([{'adviceTitle': 'test_title', 'adviceHtml': 'test DCSP html'}, {'adviceTitle': 'another_title', 'adviceHtml': 'more DCSP html'}, {'adviceTitle': 'third_title', 'adviceHtml': 'third DCSP html'}]) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'TestGadget DCSP is DCSP limited DCSP to DCSP 3 DCSP tips, DCSP found DCSP 4.'): DCNL DCSP  DCSP test_gadget_instance.validate() DCNL DCSP test_gadget_instance.customization_args['adviceObjects']['value'].pop() DCNL DCSP panel_contents_dict['bottom'].append(test_gadget_instance) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, "'bottom' DCSP panel DCSP expected DCSP at DCSP most DCSP 1 DCSP gadget, DCSP but DCSP 2 DCSP gadgets DCSP are DCSP visible DCSP in DCSP state DCSP 'New DCSP state'."): DCNL DCSP  DCSP exploration.validate() DCNL DCSP test_gadget_instance.visible_in_states = [] DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'TestGadget DCSP gadget DCSP not DCSP visible DCSP in DCSP any DCSP states.'): DCNL DCSP  DCSP test_gadget_instance.validate()
def test_conversion_of_gadget_instance_to_and_from_dict(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('exp1', SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP panel_contents_dict = exploration.skin_instance.panel_contents_dict DCNL DCSP test_gadget_instance = panel_contents_dict['bottom'][0] DCNL DCSP test_gadget_as_dict = test_gadget_instance.to_dict() DCNL DCSP self.assertEqual(test_gadget_as_dict, {'gadget_type': 'TestGadget', 'gadget_name': 'ATestGadget', 'visible_in_states': ['New DCSP state', 'Second DCSP state'], 'customization_args': TEST_GADGET_CUSTOMIZATION_ARGS}) DCNL DCSP test_gadget_as_instance = exp_domain.GadgetInstance.from_dict(test_gadget_as_dict) DCNL DCSP self.assertEqual(test_gadget_as_instance.width, 60) DCNL DCSP self.assertEqual(test_gadget_as_instance.height, 50)
def test_retrieving_affected_gadgets(self): DCNL DCSP exploration = exp_domain.Exploration.from_yaml('exp1', SAMPLE_YAML_CONTENT_WITH_GADGETS) DCNL DCSP affected_gadget_instances = exploration._get_gadget_instances_visible_in_state('Second DCSP state') DCNL DCSP self.assertEqual(len(affected_gadget_instances), 1) DCNL DCSP self.assertEqual(affected_gadget_instances[0].name, 'ATestGadget')
def test_js_string_filter(self): DCNL DCSP expected_values = [('a', '\\"a\\"'), (2, '2'), (5.5, '5.5'), ("'", '\\"\\\'\\"'), (u'\xa1Hola!', '\\"\\\\u00a1Hola!\\"'), (['a', '\xc2\xa1Hola!', 2], '[\\"a\\", DCSP \\"\\\\u00a1Hola!\\", DCSP 2]'), ({'a': 4, '\xc2\xa1Hola!': 2}, '{\\"a\\": DCSP 4, DCSP \\"\\\\u00a1Hola!\\": DCSP 2}'), ('', '\\"\\"'), (None, 'null'), (['a', {'b': 'c', 'd': ['e', None]}], '[\\"a\\", DCSP {\\"b\\": DCSP \\"c\\", DCSP \\"d\\": DCSP [\\"e\\", DCSP null]}]')] DCNL DCSP for tup in expected_values: DCNL DCSP  DCSP self.assertEqual(jinja_utils.JINJA_FILTERS['js_string'](tup[0]), tup[1])
@acl_decorators.open_access DCNL def post(self): DCNL DCSP logging.error(('Frontend DCSP error: DCSP %s' % self.payload.get('error'))) DCNL DCSP self.render_json(self.values)
@acl_decorators.open_access DCNL def get(self): DCNL DCSP pass
def run(self): DCNL DCSP test_target_flag = ('--test_target=%s' % self.test_target) DCNL DCSP if self.generate_coverage_report: DCNL DCSP  DCSP exc_list = ['python', COVERAGE_PATH, 'run', '-p', TEST_RUNNER_PATH, test_target_flag] DCNL DCSP else: DCNL DCSP  DCSP exc_list = ['python', TEST_RUNNER_PATH, test_target_flag] DCNL DCSP return run_shell_cmd(exc_list)
@staticmethod DCNL def normalize_spaces(obj): DCNL DCSP return ' DCSP '.join(obj.split())
@staticmethod DCNL def sanitize_url(obj): DCNL DCSP url_components = urlparse.urlsplit(obj) DCNL DCSP quoted_url_components = (urllib.quote(component) for component in url_components) DCNL DCSP raw = urlparse.urlunsplit(quoted_url_components) DCNL DCSP acceptable = html_cleaner.filter_a('href', obj) DCNL DCSP assert acceptable, ("Invalid DCSP URL: DCSP Sanitized DCSP URL DCSP should DCSP start DCSP with DCSP 'http://' DCSP or DCSP 'https://'; DCSP received DCSP %s" % raw) DCNL DCSP return raw
@staticmethod DCNL def has_length_at_least(obj, min_value): DCNL DCSP return (len(obj) >= min_value)
@staticmethod DCNL def has_length_at_most(obj, max_value): DCNL DCSP return (len(obj) <= max_value)
@staticmethod DCNL def is_nonempty(obj): DCNL DCSP return bool(obj)
@staticmethod DCNL def is_uniquified(obj): DCNL DCSP return (sorted(list(set(obj))) == sorted(obj))
@staticmethod DCNL def is_at_least(obj, min_value): DCNL DCSP return (obj >= min_value)
@staticmethod DCNL def is_at_most(obj, max_value): DCNL DCSP return (obj <= max_value)
@staticmethod DCNL def is_regex(obj): DCNL DCSP raise NotImplementedError
@staticmethod DCNL def matches_regex(obj, regex): DCNL DCSP raise NotImplementedError
def __init__(self): DCNL DCSP super(LDAStringClassifier, self).__init__() DCNL DCSP numpy.random.seed(seed=4) DCNL DCSP self._alpha = self._DEFAULT_ALPHA DCNL DCSP self._beta = self._DEFAULT_BETA DCNL DCSP self._b_dl = None DCNL DCSP self._c_dl = None DCNL DCSP self._c_l = None DCNL DCSP self._c_lw = None DCNL DCSP self._l_dp = None DCNL DCSP self._w_dp = None DCNL DCSP self._label_to_id = None DCNL DCSP self._word_to_id = None DCNL DCSP self._num_docs = None DCNL DCSP self._num_labels = None DCNL DCSP self._num_words = None DCNL DCSP self._training_iterations = self._DEFAULT_TRAINING_ITERATIONS DCNL DCSP self._prediction_iterations = self._DEFAULT_PREDICTION_ITERATIONS DCNL DCSP self._prediction_threshold = self._DEFAULT_PREDICTION_THRESHOLD
def _get_word_id(self, word): DCNL DCSP if (word not in self._word_to_id): DCNL DCSP  DCSP self._word_to_id[word] = self._num_words DCNL DCSP  DCSP self._num_words += 1 DCNL DCSP return self._word_to_id[word]
def _get_label_id(self, label): DCNL DCSP if (label not in self._label_to_id): DCNL DCSP  DCSP self._label_to_id[label] = self._num_labels DCNL DCSP  DCSP self._num_labels += 1 DCNL DCSP return self._label_to_id[label]
def _get_label_name(self, l): DCNL DCSP for (label_name, label_id) in self._label_to_id.iteritems(): DCNL DCSP  DCSP if (label_id == l): DCNL DCSP  DCSP  DCSP return label_name DCNL DCSP raise Exception(('Label DCSP id DCSP %d DCSP does DCSP not DCSP exist.' % l))
def _get_doc_with_label_vector(self, d): DCNL DCSP return (self._w_dp[d], self._b_dl[d])
def _get_label_vector(self, labels): DCNL DCSP label_vector = numpy.zeros(self._num_labels) DCNL DCSP for label in labels: DCNL DCSP  DCSP label_vector[self._get_label_id(label)] = 1 DCNL DCSP label_vector[self._label_to_id[feconf.DEFAULT_CLASSIFIER_LABEL]] = 1 DCNL DCSP return label_vector
def _update_counting_matrices(self, d, w, l, val): DCNL DCSP self._c_dl[(d, l)] += val DCNL DCSP self._c_lw[(l, w)] += val DCNL DCSP self._c_l[l] += val
def _increment_counting_matrices(self, d, w, l): DCNL DCSP self._update_counting_matrices(d, w, l, 1)
def _decrement_counting_matrices(self, d, w, l): DCNL DCSP self._update_counting_matrices(d, w, l, (-1))
def _run_gibbs_sampling(self, doc_ids): DCNL DCSP if (doc_ids is None): DCNL DCSP  DCSP doc_ids = xrange(self._num_docs) DCNL DCSP statez = {'updates': 0, 'computes': 0} DCNL DCSP for d in doc_ids: DCNL DCSP  DCSP (doc, labels) = self._get_doc_with_label_vector(d) DCNL DCSP  DCSP for (p, w) in enumerate(doc): DCNL DCSP  DCSP  DCSP l = self._l_dp[d][p] DCNL DCSP  DCSP  DCSP self._decrement_counting_matrices(d, w, l) DCNL DCSP  DCSP  DCSP coeff_a = (1.0 / (self._c_dl[d].sum() + (self._num_labels * self._alpha))) DCNL DCSP  DCSP  DCSP coeff_b = (1.0 / (self._c_lw.sum(axis=1) + (self._num_words * self._beta))) DCNL DCSP  DCSP  DCSP label_probabilities = ((((labels * coeff_a) * (self._c_dl[d] + self._alpha)) * coeff_b) * (self._c_lw[:, w] + self._beta)) DCNL DCSP  DCSP  DCSP new_label = numpy.random.multinomial(1, (label_probabilities / label_probabilities.sum())).argmax() DCNL DCSP  DCSP  DCSP statez['computes'] += 1 DCNL DCSP  DCSP  DCSP if (l != new_label): DCNL DCSP  DCSP  DCSP  DCSP statez['updates'] += 1 DCNL DCSP  DCSP  DCSP self._l_dp[d][p] = new_label DCNL DCSP  DCSP  DCSP self._increment_counting_matrices(d, w, new_label) DCNL DCSP return statez
def _get_label_probabilities(self, d): DCNL DCSP unnormalized_label_probs = (self._c_dl[d] + (self._b_dl[d] * self._alpha)) DCNL DCSP label_probabilities = (unnormalized_label_probs / unnormalized_label_probs.sum()) DCNL DCSP return label_probabilities
def _get_prediction_report_for_doc(self, d): DCNL DCSP default_label_id = self._get_label_id(feconf.DEFAULT_CLASSIFIER_LABEL) DCNL DCSP prediction_label_id = default_label_id DCNL DCSP prediction_confidence = 0 DCNL DCSP label_probabilities = self._get_label_probabilities(d) DCNL DCSP normalization_coeff = (1.0 / (1.0 - label_probabilities[default_label_id])) DCNL DCSP for (l, prob) in enumerate(label_probabilities): DCNL DCSP  DCSP if ((l != default_label_id) and ((prob * normalization_coeff) > self._prediction_threshold) and ((prob * normalization_coeff) > prediction_confidence)): DCNL DCSP  DCSP  DCSP prediction_label_id = l DCNL DCSP  DCSP  DCSP prediction_confidence = (prob * normalization_coeff) DCNL DCSP return {'prediction_label_id': prediction_label_id, 'prediction_label_name': self._get_label_name(prediction_label_id), 'prediction_confidence': prediction_confidence, 'all_predictions': label_probabilities}
def _parse_examples(self, examples): DCNL DCSP docs = [] DCNL DCSP labels_list = [] DCNL DCSP for example in examples: DCNL DCSP  DCSP doc_string = example[0] DCNL DCSP  DCSP doc = doc_string.split() DCNL DCSP  DCSP if (len(doc) > 0): DCNL DCSP  DCSP  DCSP labels = example[1] DCNL DCSP  DCSP  DCSP docs.append(doc) DCNL DCSP  DCSP  DCSP labels_list.append(labels) DCNL DCSP return (docs, labels_list)
def _iterate_gibbs_sampling(self, iterations, doc_ids): DCNL DCSP for _ in xrange(iterations): DCNL DCSP  DCSP self._run_gibbs_sampling(doc_ids)
def _add_examples(self, examples, iterations): DCNL DCSP if (len(examples) == 0): DCNL DCSP  DCSP return DCNL DCSP (docs, labels_list) = self._parse_examples(examples) DCNL DCSP last_num_labels = self._num_labels DCNL DCSP last_num_docs = self._num_docs DCNL DCSP last_num_words = self._num_words DCNL DCSP for labels in labels_list: DCNL DCSP  DCSP for label in labels: DCNL DCSP  DCSP  DCSP self._get_label_id(label) DCNL DCSP self._num_docs += len(docs) DCNL DCSP self._b_dl = numpy.concatenate((self._b_dl, numpy.zeros((last_num_docs, (self._num_labels - last_num_labels)), dtype=int)), axis=1) DCNL DCSP self._b_dl = numpy.concatenate((self._b_dl, [self._get_label_vector(labels) for labels in labels_list]), axis=0) DCNL DCSP self._w_dp.extend([map(self._get_word_id, doc) for doc in docs]) DCNL DCSP self._c_dl = numpy.concatenate((self._c_dl, numpy.zeros((last_num_docs, (self._num_labels - last_num_labels)), dtype=int)), axis=1) DCNL DCSP self._c_dl = numpy.concatenate((self._c_dl, numpy.zeros(((self._num_docs - last_num_docs), self._num_labels), dtype=int)), axis=0) DCNL DCSP self._c_lw = numpy.concatenate((self._c_lw, numpy.zeros((last_num_labels, (self._num_words - last_num_words)), dtype=int)), axis=1) DCNL DCSP self._c_lw = numpy.concatenate((self._c_lw, numpy.zeros(((self._num_labels - last_num_labels), self._num_words), dtype=int)), axis=0) DCNL DCSP self._c_l = numpy.concatenate((self._c_l, numpy.zeros((self._num_labels - last_num_labels), dtype=int))) DCNL DCSP for d in xrange(last_num_docs, self._num_docs): DCNL DCSP  DCSP (doc, _) = self._get_doc_with_label_vector(d) DCNL DCSP  DCSP l_p = numpy.random.random_integers(0, (self._num_labels - 1), size=len(doc)).tolist() DCNL DCSP  DCSP self._l_dp.append(l_p) DCNL DCSP  DCSP for (w, l) in zip(doc, l_p): DCNL DCSP  DCSP  DCSP self._increment_counting_matrices(d, w, l) DCNL DCSP  DCSP self._iterate_gibbs_sampling(iterations, [d]) DCNL DCSP return xrange(last_num_docs, self._num_docs)
def add_examples_for_training(self, training_examples): DCNL DCSP return self._add_examples(training_examples, self._training_iterations)
def _add_docs_for_predicting(self, prediction_docs): DCNL DCSP all_labels = self._label_to_id.keys() DCNL DCSP return self._add_examples(zip(prediction_docs, [copy.deepcopy(all_labels) for _ in prediction_docs]), self._prediction_iterations)
def _predict_label_for_doc(self, sample): DCNL DCSP if ((self._num_docs < self._DEFAULT_MIN_DOCS_TO_PREDICT) or (self._num_labels < self._DEFAULT_MIN_LABELS_TO_PREDICT)): DCNL DCSP  DCSP return feconf.DEFAULT_CLASSIFIER_LABEL DCNL DCSP return self._get_prediction_report_for_doc(sample)['prediction_label_name']
def to_dict(self): DCNL DCSP model = {} DCNL DCSP model['_alpha'] = copy.deepcopy(self._alpha) DCNL DCSP model['_beta'] = copy.deepcopy(self._beta) DCNL DCSP model['_prediction_threshold'] = copy.deepcopy(self._prediction_threshold) DCNL DCSP model['_training_iterations'] = copy.deepcopy(self._training_iterations) DCNL DCSP model['_prediction_iterations'] = copy.deepcopy(self._prediction_iterations) DCNL DCSP model['_num_labels'] = copy.deepcopy(self._num_labels) DCNL DCSP model['_num_docs'] = copy.deepcopy(self._num_docs) DCNL DCSP model['_num_words'] = copy.deepcopy(self._num_words) DCNL DCSP model['_label_to_id'] = copy.deepcopy(self._label_to_id) DCNL DCSP model['_word_to_id'] = copy.deepcopy(self._word_to_id) DCNL DCSP model['_w_dp'] = copy.deepcopy(self._w_dp) DCNL DCSP model['_b_dl'] = copy.deepcopy(self._b_dl) DCNL DCSP model['_l_dp'] = copy.deepcopy(self._l_dp) DCNL DCSP model['_c_dl'] = copy.deepcopy(self._c_dl) DCNL DCSP model['_c_lw'] = copy.deepcopy(self._c_lw) DCNL DCSP model['_c_l'] = copy.deepcopy(self._c_l) DCNL DCSP return model
def from_dict(self, model): DCNL DCSP self._alpha = copy.deepcopy(model['_alpha']) DCNL DCSP self._beta = copy.deepcopy(model['_beta']) DCNL DCSP self._prediction_threshold = copy.deepcopy(model['_prediction_threshold']) DCNL DCSP self._training_iterations = copy.deepcopy(model['_training_iterations']) DCNL DCSP self._prediction_iterations = copy.deepcopy(model['_prediction_iterations']) DCNL DCSP self._num_labels = copy.deepcopy(model['_num_labels']) DCNL DCSP self._num_docs = copy.deepcopy(model['_num_docs']) DCNL DCSP self._num_words = copy.deepcopy(model['_num_words']) DCNL DCSP self._label_to_id = copy.deepcopy(model['_label_to_id']) DCNL DCSP self._word_to_id = copy.deepcopy(model['_word_to_id']) DCNL DCSP self._w_dp = copy.deepcopy(model['_w_dp']) DCNL DCSP self._b_dl = copy.deepcopy(model['_b_dl']) DCNL DCSP self._l_dp = copy.deepcopy(model['_l_dp']) DCNL DCSP self._c_dl = copy.deepcopy(model['_c_dl']) DCNL DCSP self._c_lw = copy.deepcopy(model['_c_lw']) DCNL DCSP self._c_l = copy.deepcopy(model['_c_l'])
def train(self, training_data): DCNL DCSP (docs, labels_list) = self._parse_examples(training_data) DCNL DCSP label_set = set(([feconf.DEFAULT_CLASSIFIER_LABEL] + [label for labels in labels_list for label in labels])) DCNL DCSP self._num_labels = len(label_set) DCNL DCSP self._label_to_id = dict(zip(label_set, xrange(self._num_labels))) DCNL DCSP self._num_words = 0 DCNL DCSP self._word_to_id = {} DCNL DCSP self._num_docs = len(docs) DCNL DCSP self._b_dl = numpy.array(map(self._get_label_vector, labels_list), dtype=int) DCNL DCSP self._w_dp = [map(self._get_word_id, doc) for doc in docs] DCNL DCSP self._c_dl = numpy.zeros((self._num_docs, self._num_labels), dtype=int) DCNL DCSP self._c_lw = numpy.zeros((self._num_labels, self._num_words), dtype=int) DCNL DCSP self._c_l = numpy.zeros(self._num_labels, dtype=int) DCNL DCSP self._l_dp = [] DCNL DCSP for d in xrange(self._num_docs): DCNL DCSP  DCSP (doc, _) = self._get_doc_with_label_vector(d) DCNL DCSP  DCSP l_p = numpy.random.random_integers(0, (self._num_labels - 1), size=len(doc)).tolist() DCNL DCSP  DCSP self._l_dp.append(l_p) DCNL DCSP  DCSP for (w, l) in zip(doc, l_p): DCNL DCSP  DCSP  DCSP self._increment_counting_matrices(d, w, l) DCNL DCSP self._iterate_gibbs_sampling(self._training_iterations, xrange(self._num_docs))
def predict(self, predicting_data): DCNL DCSP doc_ids = self._add_docs_for_predicting(predicting_data) DCNL DCSP return [self._predict_label_for_doc(doc_id) for doc_id in doc_ids]
def validate(self, classifier_data): DCNL DCSP float_properties = ['_alpha', '_beta', '_prediction_threshold'] DCNL DCSP int_properties = ['_training_iterations', '_prediction_iterations', '_num_labels', '_num_docs', '_num_words'] DCNL DCSP dict_properties = ['_label_to_id', '_word_to_id'] DCNL DCSP list_of_list_int_properties = ['_w_dp', '_l_dp', '_c_dl', '_c_lw'] DCNL DCSP list_of_list_bool_properties = ['_b_dl'] DCNL DCSP list_properties = ['_c_l'] DCNL DCSP for float_property in float_properties: DCNL DCSP  DCSP if (float_property not in classifier_data): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP key DCSP in DCSP classifier_data' % float_property)) DCNL DCSP  DCSP if (not isinstance(classifier_data[float_property], float)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP float, DCSP received DCSP %s' % (float_property, classifier_data[float_property]))) DCNL DCSP for int_property in int_properties: DCNL DCSP  DCSP if (int_property not in classifier_data): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP key DCSP in DCSP classifier_data' % int_property)) DCNL DCSP  DCSP if (not isinstance(classifier_data[int_property], int)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP int, DCSP received DCSP %s' % (int_property, classifier_data[int_property]))) DCNL DCSP for dict_property in dict_properties: DCNL DCSP  DCSP if (dict_property not in classifier_data): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP key DCSP in DCSP classifier_data' % dict_property)) DCNL DCSP  DCSP if (not isinstance(classifier_data[dict_property], dict)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP dict, DCSP received DCSP %s' % (dict_property, classifier_data[dict_property]))) DCNL DCSP  DCSP for (key, value) in classifier_data[dict_property].iteritems(): DCNL DCSP  DCSP  DCSP if (not isinstance(key, basestring)): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP key DCSP of DCSP %s DCSP to DCSP be DCSP a DCSP string, DCSP received DCSP %s' % (dict_property, key))) DCNL DCSP  DCSP  DCSP if (not isinstance(value, int)): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP value DCSP of DCSP %s DCSP to DCSP be DCSP a DCSP int, DCSP received DCSP %s' % (dict_property, value))) DCNL DCSP for list_property in list_properties: DCNL DCSP  DCSP if (list_property not in classifier_data): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP key DCSP in DCSP classifier_data' % list_property)) DCNL DCSP  DCSP if (not isinstance(classifier_data[list_property], list)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % (list_property, classifier_data[list_property]))) DCNL DCSP  DCSP for value in classifier_data[list_property]: DCNL DCSP  DCSP  DCSP if (not isinstance(value, int)): DCNL DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP values DCSP of DCSP %s DCSP to DCSP be DCSP a DCSP int, DCSP received DCSP %s' % (list_property, value))) DCNL DCSP for list_of_list_property in list_of_list_int_properties: DCNL DCSP  DCSP if (list_of_list_property not in classifier_data): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP key DCSP in DCSP classifier_data' % list_of_list_property)) DCNL DCSP  DCSP if (not isinstance(classifier_data[list_of_list_property], list)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % (list_of_list_property, classifier_data[list_of_list_property]))) DCNL DCSP  DCSP for inner_list in classifier_data[list_of_list_property]: DCNL DCSP  DCSP  DCSP for value in inner_list: DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(value, int)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP values DCSP of DCSP %s DCSP to DCSP be DCSP a DCSP int, DCSP received DCSP %s' % (list_of_list_property, value))) DCNL DCSP for list_of_list_property in list_of_list_bool_properties: DCNL DCSP  DCSP if (list_of_list_property not in classifier_data): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP key DCSP in DCSP classifier_data' % list_of_list_property)) DCNL DCSP  DCSP if (not isinstance(classifier_data[list_of_list_property], list)): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP %s DCSP to DCSP be DCSP a DCSP list, DCSP received DCSP %s' % (list_of_list_property, classifier_data[list_of_list_property]))) DCNL DCSP  DCSP for inner_list in classifier_data[list_of_list_property]: DCNL DCSP  DCSP  DCSP for value in inner_list: DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(value, bool)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise utils.ValidationError(('Expected DCSP values DCSP of DCSP %s DCSP to DCSP be DCSP bool, DCSP received DCSP %s' % (list_of_list_property, value)))
def test_predict_label_for_doc(self): DCNL DCSP self.classifier._DEFAULT_MIN_DOCS_TO_PREDICT = 0 DCNL DCSP self.classifier._DEFAULT_MIN_LABELS_TO_PREDICT = 0 DCNL DCSP labels = self.classifier.predict(self._EXAMPLES_TEST) DCNL DCSP self.assertEquals(labels[0], 'food') DCNL DCSP self.assertEquals(labels[1], 'pets') DCNL DCSP self.classifier._prediction_threshold = 0.7 DCNL DCSP labels = self.classifier.predict(self._EXAMPLES_TEST) DCNL DCSP self.assertEquals(labels[2], '_default') DCNL DCSP self._validate_instance()
def test_validate(self): DCNL DCSP classifier_data = {'_alpha': 0.1, '_beta': 0.001, '_prediction_threshold': 0.5, '_training_iterations': 25, '_prediction_iterations': 5, '_num_labels': 10, '_num_docs': 12, '_num_words': 20, '_label_to_id': {'text': 1}, '_word_to_id': {'hello': 2}, '_w_dp': [], '_b_dl': [], '_l_dp': [], '_c_dl': [], '_c_lw': [], '_c_l': []} DCNL DCSP self.classifier.validate(classifier_data) DCNL DCSP classifier_data.pop('_alpha', None) DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP _alpha DCSP to DCSP be DCSP a DCSP key DCSP in DCSP classifier_data'): DCNL DCSP  DCSP self.classifier.validate(classifier_data) DCNL DCSP classifier_data['_alpha'] = 'abc' DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP _alpha DCSP to DCSP be DCSP a DCSP float'): DCNL DCSP  DCSP self.classifier.validate(classifier_data) DCNL DCSP classifier_data['_alpha'] = 0.1 DCNL DCSP classifier_data['_training_iterations'] = 1.2 DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP _training_iterations DCSP to DCSP be DCSP a DCSP int'): DCNL DCSP  DCSP self.classifier.validate(classifier_data) DCNL DCSP classifier_data['_training_iterations'] = 25 DCNL DCSP classifier_data['_label_to_id'] = [] DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP _label_to_id DCSP to DCSP be DCSP a DCSP dict'): DCNL DCSP  DCSP self.classifier.validate(classifier_data) DCNL DCSP classifier_data['_label_to_id'] = {1: 1} DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP key DCSP of DCSP _label_to_id DCSP to DCSP be DCSP a DCSP string'): DCNL DCSP  DCSP self.classifier.validate(classifier_data) DCNL DCSP classifier_data['_label_to_id'] = {'text': '1'} DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP value DCSP of DCSP _label_to_id DCSP to DCSP be DCSP a DCSP int'): DCNL DCSP  DCSP self.classifier.validate(classifier_data) DCNL DCSP classifier_data['_label_to_id'] = {'text': 1} DCNL DCSP classifier_data['_w_dp'] = {} DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP _w_dp DCSP to DCSP be DCSP a DCSP list'): DCNL DCSP  DCSP self.classifier.validate(classifier_data) DCNL DCSP classifier_data['_w_dp'] = [['abc']] DCNL DCSP with self.assertRaisesRegexp(utils.ValidationError, 'Expected DCSP values DCSP of DCSP _w_dp DCSP to DCSP be DCSP a DCSP int'): DCNL DCSP  DCSP self.classifier.validate(classifier_data)
@property DCNL def preview_url_template(self): DCNL DCSP return utils.convert_png_to_data_url(os.path.join(feconf.RTE_EXTENSIONS_DIR, self.id, ('%sPreview.png' % self.id)))
@property DCNL def html_body(self): DCNL DCSP html_templates = utils.get_file_contents(os.path.join(feconf.RTE_EXTENSIONS_DIR, self.id, ('%s.html' % self.id))) DCNL DCSP return jinja_utils.interpolate_cache_slug(('%s' % html_templates))
def to_dict(self): DCNL DCSP return {'backend_name': self.name, 'customization_arg_specs': [{'name': ca_spec.name, 'description': ca_spec.description, 'default_value': ca_spec.default_value, 'schema': ca_spec.schema} for ca_spec in self.customization_arg_specs], 'frontend_name': self.frontend_name, 'icon_data_url': utils.convert_png_to_data_url(os.path.join(feconf.RTE_EXTENSIONS_DIR, self.id, ('%s.png' % self.id))), 'is_complex': self.is_complex, 'requires_fs': self.requires_fs, 'tooltip': self.tooltip, 'is_block_element': self.is_block_element, 'preview_url_template': self.preview_url_template}
def normalize_answer(self, answer): DCNL DCSP if (self.answer_type is None): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return obj_services.Registry.get_object_class_by_type(self.answer_type).normalize(answer)
@property DCNL def rules_dict(self): DCNL DCSP if (self._cached_rules_dict is not None): DCNL DCSP  DCSP return self._cached_rules_dict DCNL DCSP rules_index_dict = json.loads(utils.get_file_contents(feconf.RULES_DESCRIPTIONS_FILE_PATH)) DCNL DCSP self._cached_rules_dict = rules_index_dict[self.id] DCNL DCSP return self._cached_rules_dict
@property DCNL def html_body(self): DCNL DCSP html_templates = utils.get_file_contents(os.path.join(feconf.INTERACTIONS_DIR, self.id, ('%s.html' % self.id))) DCNL DCSP return jinja_utils.interpolate_cache_slug(('%s' % html_templates))
@property DCNL def validator_html(self): DCNL DCSP return ('<script>%s</script>\n' % utils.get_file_contents(os.path.join(feconf.INTERACTIONS_DIR, self.id, ('%sValidationService.js' % self.id))))
def to_dict(self): DCNL DCSP return {'id': self.id, 'name': self.name, 'description': self.description, 'display_mode': self.display_mode, 'is_terminal': self.is_terminal, 'is_trainable': self.is_trainable, 'is_string_classifier_trainable': self.is_string_classifier_trainable, 'is_linear': self.is_linear, 'needs_summary': self.needs_summary, 'customization_arg_specs': [{'name': ca_spec.name, 'description': ca_spec.description, 'default_value': ca_spec.default_value, 'schema': ca_spec.schema} for ca_spec in self.customization_arg_specs], 'instructions': self.instructions, 'narrow_instructions': self.narrow_instructions, 'default_outcome_heading': self.default_outcome_heading, 'rule_descriptions': self._rule_description_strings}
def get_rule_description(self, rule_name): DCNL DCSP if (rule_name not in self.rules_dict): DCNL DCSP  DCSP raise Exception(('Could DCSP not DCSP find DCSP rule DCSP with DCSP name DCSP %s' % rule_name)) DCNL DCSP else: DCNL DCSP  DCSP return self.rules_dict[rule_name]['description']
def get_rule_param_list(self, rule_name): DCNL DCSP description = self.get_rule_description(rule_name) DCNL DCSP param_list = [] DCNL DCSP while (description.find('{{') != (-1)): DCNL DCSP  DCSP opening_index = description.find('{{') DCNL DCSP  DCSP description = description[(opening_index + 2):] DCNL DCSP  DCSP bar_index = description.find('|') DCNL DCSP  DCSP param_name = description[:bar_index] DCNL DCSP  DCSP description = description[(bar_index + 1):] DCNL DCSP  DCSP closing_index = description.find('}}') DCNL DCSP  DCSP normalizer_string = description[:closing_index] DCNL DCSP  DCSP description = description[(closing_index + 2):] DCNL DCSP  DCSP param_list.append((param_name, getattr(objects, normalizer_string))) DCNL DCSP return param_list
def get_rule_param_type(self, rule_name, rule_param_name): DCNL DCSP rule_param_list = self.get_rule_param_list(rule_name) DCNL DCSP for (param_name, param_type) in rule_param_list: DCNL DCSP  DCSP if (param_name == rule_param_name): DCNL DCSP  DCSP  DCSP return param_type DCNL DCSP raise Exception(('Rule DCSP %s DCSP has DCSP no DCSP param DCSP called DCSP %s' % (rule_name, rule_param_name)))
def test_rules_property(self): DCNL DCSP interaction = base.BaseInteraction() DCNL DCSP interaction.answer_type = None DCNL DCSP interaction.normalize_answer('15') DCNL DCSP interaction.answer_type = 'NonnegativeInt' DCNL DCSP interaction.normalize_answer('15') DCNL DCSP with self.assertRaisesRegexp(Exception, 'not DCSP a DCSP valid DCSP object DCSP class'): DCNL DCSP  DCSP interaction.answer_type = 'FakeObjType' DCNL DCSP  DCSP interaction.normalize_answer('15')
def _is_camel_cased(self, name): DCNL DCSP return (name and (name[0] in string.ascii_uppercase))
def _is_alphanumeric_string(self, input_string): DCNL DCSP return bool(re.compile('^[a-zA-Z0-9_]+$').match(input_string))
def _listdir_omit_ignored(self, directory): DCNL DCSP names = os.listdir(directory) DCNL DCSP for suffix in IGNORED_FILE_SUFFIXES: DCNL DCSP  DCSP names = [name for name in names if (not name.endswith(suffix))] DCNL DCSP return names
def test_interaction_properties(self): DCNL DCSP interaction = interaction_registry.Registry.get_interaction_by_id(TEXT_INPUT_ID) DCNL DCSP self.assertEqual(interaction.id, TEXT_INPUT_ID) DCNL DCSP self.assertEqual(interaction.name, 'Text DCSP Input') DCNL DCSP interaction_dict = interaction.to_dict() DCNL DCSP self.assertItemsEqual(interaction_dict.keys(), ['id', 'name', 'description', 'display_mode', 'customization_arg_specs', 'is_trainable', 'is_string_classifier_trainable', 'is_terminal', 'is_linear', 'rule_descriptions', 'instructions', 'narrow_instructions', 'needs_summary', 'default_outcome_heading']) DCNL DCSP self.assertEqual(interaction_dict['id'], TEXT_INPUT_ID) DCNL DCSP self.assertEqual(interaction_dict['customization_arg_specs'], [{'name': 'placeholder', 'description': 'Placeholder DCSP text DCSP (optional)', 'schema': {'type': 'unicode'}, 'default_value': ''}, {'name': 'rows', 'description': 'Height DCSP (in DCSP rows)', 'schema': {'type': 'int', 'validators': [{'id': 'is_at_least', 'min_value': 1}, {'id': 'is_at_most', 'max_value': 200}]}, 'default_value': 1}])
def test_default_interactions_are_valid(self): DCNL DCSP all_interaction_ids = interaction_registry.Registry.get_all_interaction_ids() DCNL DCSP for interaction_id in all_interaction_ids: DCNL DCSP  DCSP self.assertTrue(self._is_camel_cased(interaction_id)) DCNL DCSP  DCSP interaction_dir = os.path.join(feconf.INTERACTIONS_DIR, interaction_id) DCNL DCSP  DCSP self.assertTrue(os.path.isdir(interaction_dir)) DCNL DCSP  DCSP dir_contents = self._listdir_omit_ignored(interaction_dir) DCNL DCSP  DCSP optional_dirs_and_files_count = 0 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self.assertTrue(os.path.isfile(os.path.join(interaction_dir, ('%sSpec.js' % interaction_id)))) DCNL DCSP  DCSP  DCSP optional_dirs_and_files_count += 1 DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self.assertTrue(os.path.isfile(os.path.join(interaction_dir, ('%sValidationServiceSpec.js' % interaction_id)))) DCNL DCSP  DCSP  DCSP optional_dirs_and_files_count += 1 DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self.assertTrue(os.path.isfile(os.path.join(interaction_dir, ('%sRulesServiceSpec.js' % interaction_id)))) DCNL DCSP  DCSP  DCSP optional_dirs_and_files_count += 1 DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self.assertTrue(os.path.isfile(os.path.join(interaction_dir, 'protractor.js'))) DCNL DCSP  DCSP  DCSP optional_dirs_and_files_count += 1 DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP self.assertEqual((optional_dirs_and_files_count + 5), len(dir_contents), dir_contents) DCNL DCSP  DCSP py_file = os.path.join(interaction_dir, ('%s.py' % interaction_id)) DCNL DCSP  DCSP html_file = os.path.join(interaction_dir, ('%s.html' % interaction_id)) DCNL DCSP  DCSP js_file = os.path.join(interaction_dir, ('%s.js' % interaction_id)) DCNL DCSP  DCSP validation_service_js_file = os.path.join(interaction_dir, ('%sValidationService.js' % interaction_id)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(py_file)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(html_file)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(js_file)) DCNL DCSP  DCSP static_dir = os.path.join(interaction_dir, 'static') DCNL DCSP  DCSP self.assertTrue(os.path.isdir(static_dir)) DCNL DCSP  DCSP png_file = os.path.join(interaction_dir, 'static', ('%s.png' % interaction_id)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(png_file)) DCNL DCSP  DCSP with open(png_file, 'rb') as f: DCNL DCSP  DCSP  DCSP img_data = f.read() DCNL DCSP  DCSP  DCSP (width, height) = struct.unpack('>LL', img_data[16:24]) DCNL DCSP  DCSP  DCSP self.assertEqual(int(width), INTERACTION_THUMBNAIL_WIDTH_PX) DCNL DCSP  DCSP  DCSP self.assertEqual(int(height), INTERACTION_THUMBNAIL_HEIGHT_PX) DCNL DCSP  DCSP js_file_content = utils.get_file_contents(js_file) DCNL DCSP  DCSP html_file_content = utils.get_file_contents(html_file) DCNL DCSP  DCSP validation_service_js_file_content = utils.get_file_contents(validation_service_js_file) DCNL DCSP  DCSP self.assertIn(('oppiaInteractive%s' % interaction_id), js_file_content) DCNL DCSP  DCSP self.assertIn(('oppiaResponse%s' % interaction_id), js_file_content) DCNL DCSP  DCSP directive_prefix = '<script DCSP type="text/ng-template"' DCNL DCSP  DCSP self.assertIn(('%s DCSP id="interaction/%s"' % (directive_prefix, interaction_id)), html_file_content) DCNL DCSP  DCSP self.assertIn(('%s DCSP id="response/%s"' % (directive_prefix, interaction_id)), html_file_content) DCNL DCSP  DCSP self.assertIn(('<script DCSP src="{{cache_slug}}/extensions/interactions/%s/%s.js"></script>' % (interaction_id, interaction_id)), html_file_content) DCNL DCSP  DCSP self.assertIn(('<script DCSP src="{{cache_slug}}/extensions/interactions/%s/%sValidationService.js"></script>' % (interaction_id, interaction_id)), html_file_content) DCNL DCSP  DCSP self.assertNotIn('<script>', js_file_content) DCNL DCSP  DCSP self.assertNotIn('</script>', js_file_content) DCNL DCSP  DCSP self.assertIn(('%sValidationService' % interaction_id), validation_service_js_file_content) DCNL DCSP  DCSP self.assertNotIn('<script>', validation_service_js_file_content) DCNL DCSP  DCSP self.assertNotIn('</script>', validation_service_js_file_content) DCNL DCSP  DCSP interaction = interaction_registry.Registry.get_interaction_by_id(interaction_id) DCNL DCSP  DCSP self.assertTrue(interaction_id, interaction.__class__.__name__) DCNL DCSP  DCSP for (item, item_type) in _INTERACTION_CONFIG_SCHEMA: DCNL DCSP  DCSP  DCSP self.assertTrue(isinstance(getattr(interaction, item), item_type)) DCNL DCSP  DCSP  DCSP if (item_type == basestring): DCNL DCSP  DCSP  DCSP  DCSP self.assertTrue(getattr(interaction, item)) DCNL DCSP  DCSP self.assertIn(interaction.display_mode, base.ALLOWED_DISPLAY_MODES) DCNL DCSP  DCSP if (interaction.is_linear or interaction.is_terminal): DCNL DCSP  DCSP  DCSP self.assertIsNone(interaction.answer_type) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP obj_services.Registry.get_object_class_by_type(interaction.answer_type) DCNL DCSP  DCSP self._validate_customization_arg_specs(interaction._customization_arg_specs) DCNL DCSP  DCSP self._validate_dependencies(interaction.dependency_ids) DCNL DCSP  DCSP answer_visualization_specs = interaction.answer_visualization_specs DCNL DCSP  DCSP self._validate_answer_visualization_specs(answer_visualization_specs) DCNL DCSP  DCSP answer_visualizations = interaction.answer_visualizations DCNL DCSP  DCSP for (ind, visualization) in enumerate(answer_visualizations): DCNL DCSP  DCSP  DCSP self.assertEqual(visualization.id, answer_visualization_specs[ind]['id']) DCNL DCSP  DCSP  DCSP self.assertEqual(visualization.calculation_id, answer_visualization_specs[ind]['calculation_id']) DCNL DCSP  DCSP  DCSP self.assertEqual(visualization.options, answer_visualization_specs[ind]['options']) DCNL DCSP  DCSP  DCSP visualization.validate() DCNL DCSP  DCSP if (interaction.display_mode == base.DISPLAY_MODE_INLINE): DCNL DCSP  DCSP  DCSP self.assertIsNone(interaction.instructions) DCNL DCSP  DCSP  DCSP self.assertIsNone(interaction.narrow_instructions) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.assertTrue(isinstance(interaction.instructions, basestring)) DCNL DCSP  DCSP  DCSP self.assertIsNotNone(interaction.instructions) DCNL DCSP  DCSP  DCSP self.assertIsNotNone(interaction.narrow_instructions) DCNL DCSP  DCSP if interaction.is_terminal: DCNL DCSP  DCSP  DCSP self.assertFalse(interaction.is_linear) DCNL DCSP  DCSP if interaction.is_linear: DCNL DCSP  DCSP  DCSP self.assertTrue((isinstance(interaction.default_outcome_heading, basestring) and interaction.default_outcome_heading)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.assertIsNone(interaction.default_outcome_heading) DCNL DCSP  DCSP default_object_values = obj_services.get_default_object_values() DCNL DCSP  DCSP for (rule_name, rule_dict) in interaction.rules_dict.iteritems(): DCNL DCSP  DCSP  DCSP param_list = interaction.get_rule_param_list(rule_name) DCNL DCSP  DCSP  DCSP for (_, param_obj_cls) in param_list: DCNL DCSP  DCSP  DCSP  DCSP if (param_obj_cls.__name__ in ['NonnegativeInt', 'ListOfGraph', 'ListOfCoordTwoDim', 'SetOfNormalizedString']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP self.assertTrue(param_obj_cls.has_editor_js_template(), msg=('(%s)' % rule_dict['description'])) DCNL DCSP  DCSP  DCSP  DCSP self.assertIn(param_obj_cls.__name__, default_object_values)
def test_trainable_interactions_have_more_than_just_a_classifier(self): DCNL DCSP all_interaction_ids = interaction_registry.Registry.get_all_interaction_ids() DCNL DCSP for interaction_id in all_interaction_ids: DCNL DCSP  DCSP interaction = interaction_registry.Registry.get_interaction_by_id(interaction_id) DCNL DCSP  DCSP if interaction.is_trainable: DCNL DCSP  DCSP  DCSP self.assertNotEqual(len(interaction.rules_dict), 1, ('Expected DCSP trainable DCSP interaction DCSP to DCSP have DCSP more DCSP than DCSP just DCSP a DCSP classifier: DCSP %s' % interaction_id))
def test_linear_interactions(self): DCNL DCSP actual_linear_interaction_ids = self._get_linear_interaction_ids() DCNL DCSP self.assertEqual(len(actual_linear_interaction_ids), 1)
def test_linear_interaction_ids_list_matches_linear_interactions(self): DCNL DCSP actual_linear_interaction_ids = self._get_linear_interaction_ids() DCNL DCSP self.assertEqual(actual_linear_interaction_ids, feconf.LINEAR_INTERACTION_IDS)
def generate_value(self, context_params, value, parse_with_jinja=False): DCNL DCSP if (context_params is None): DCNL DCSP  DCSP context_params = {} DCNL DCSP if parse_with_jinja: DCNL DCSP  DCSP return jinja_utils.evaluate_object(value, context_params) DCNL DCSP else: DCNL DCSP  DCSP return copy.deepcopy(value)
@classmethod DCNL def normalize(cls, raw): DCNL DCSP return schema_utils.normalize_against_schema(raw, cls.SCHEMA)
@classmethod DCNL def normalize(cls, raw): DCNL DCSP if ((raw is None) or (raw == '')): DCNL DCSP  DCSP raw = False DCNL DCSP return schema_utils.normalize_against_schema(raw, cls.SCHEMA)
@classmethod DCNL def normalize(cls, raw): DCNL DCSP try: DCNL DCSP  DCSP assert isinstance(raw, dict) DCNL DCSP  DCSP assert isinstance(raw['assumptions_string'], basestring) DCNL DCSP  DCSP assert isinstance(raw['target_string'], basestring) DCNL DCSP  DCSP assert isinstance(raw['proof_string'], basestring) DCNL DCSP  DCSP assert (raw['correct'] in [True, False]) DCNL DCSP  DCSP if (not raw['correct']): DCNL DCSP  DCSP  DCSP assert isinstance(raw['error_category'], basestring) DCNL DCSP  DCSP  DCSP assert isinstance(raw['error_code'], basestring) DCNL DCSP  DCSP  DCSP assert isinstance(raw['error_message'], basestring) DCNL DCSP  DCSP  DCSP assert isinstance(raw['error_line_number'], int) DCNL DCSP  DCSP return copy.deepcopy(raw) DCNL DCSP except Exception: DCNL DCSP  DCSP raise TypeError(('Cannot DCSP convert DCSP to DCSP checked DCSP proof DCSP %s' % raw))
@classmethod DCNL def normalize(cls, raw): DCNL DCSP def _validate_expression(expression): DCNL DCSP  DCSP assert isinstance(expression, dict) DCNL DCSP  DCSP assert isinstance(expression['top_kind_name'], basestring) DCNL DCSP  DCSP assert isinstance(expression['top_operator_name'], basestring) DCNL DCSP  DCSP _validate_expression_array(expression['arguments']) DCNL DCSP  DCSP _validate_expression_array(expression['dummies']) DCNL DCSP def _validate_expression_array(array): DCNL DCSP  DCSP assert isinstance(array, list) DCNL DCSP  DCSP for item in array: DCNL DCSP  DCSP  DCSP _validate_expression(item) DCNL DCSP try: DCNL DCSP  DCSP assert isinstance(raw, dict) DCNL DCSP  DCSP _validate_expression_array(raw['assumptions']) DCNL DCSP  DCSP _validate_expression_array(raw['results']) DCNL DCSP  DCSP assert isinstance(raw['default_proof_string'], basestring) DCNL DCSP  DCSP return copy.deepcopy(raw) DCNL DCSP except Exception: DCNL DCSP  DCSP raise TypeError(('Cannot DCSP convert DCSP to DCSP a DCSP logic DCSP question DCSP %s' % raw))
@classmethod DCNL def normalize(cls, raw): DCNL DCSP try: DCNL DCSP  DCSP raw = schema_utils.normalize_against_schema(raw, cls.SCHEMA) DCNL DCSP  DCSP if (not raw['isLabeled']): DCNL DCSP  DCSP  DCSP for vertex in raw['vertices']: DCNL DCSP  DCSP  DCSP  DCSP assert (vertex['label'] == '') DCNL DCSP  DCSP for edge in raw['edges']: DCNL DCSP  DCSP  DCSP assert (edge['src'] != edge['dst']) DCNL DCSP  DCSP  DCSP if (not raw['isWeighted']): DCNL DCSP  DCSP  DCSP  DCSP assert (edge['weight'] == 1.0) DCNL DCSP  DCSP if raw['isDirected']: DCNL DCSP  DCSP  DCSP edge_pairs = [(edge['src'], edge['dst']) for edge in raw['edges']] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP edge_pairs = ([(edge['src'], edge['dst']) for edge in raw['edges']] + [(edge['dst'], edge['src']) for edge in raw['edges']]) DCNL DCSP  DCSP assert (len(set(edge_pairs)) == len(edge_pairs)) DCNL DCSP except Exception: DCNL DCSP  DCSP raise TypeError(('Cannot DCSP convert DCSP to DCSP graph DCSP %s' % raw)) DCNL DCSP return raw
def check_normalization(self, cls, mappings, invalid_items): DCNL DCSP for item in mappings: DCNL DCSP  DCSP assert (cls.normalize(item[0]) == item[1]), ('Expected DCSP %s DCSP when DCSP normalizing DCSP %s DCSP as DCSP a DCSP %s, DCSP got DCSP %s' % (item[1], item[0], cls.__name__, cls.normalize(item[0]))) DCNL DCSP for item in invalid_items: DCNL DCSP  DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP  DCSP cls.normalize(item)
def test_boolean_validation(self): DCNL DCSP mappings = [('', False), (False, False), (True, True), (None, False)] DCNL DCSP invalid_values = [{}, [], ['a'], 'aabcc'] DCNL DCSP self.check_normalization(objects.Boolean, mappings, invalid_values)
def test_real_validation(self): DCNL DCSP mappings = [(20, 20), ('20', 20), ('02', 2), ('0', 0), ((-1), (-1)), ('-1', (-1)), (3.0, 3), (3.05, 3.05), ('3.05', 3.05)] DCNL DCSP invalid_values = ['a', '', {'a': 3}, [3], None] DCNL DCSP self.check_normalization(objects.Real, mappings, invalid_values)
def test_int_validation(self): DCNL DCSP mappings = [(20, 20), ('20', 20), ('02', 2), ('0', 0), ('-1', (-1)), ((-1), (-1)), (3.0, 3), (3.05, 3)] DCNL DCSP invalid_values = ['a', '', {'a': 3}, [3], None] DCNL DCSP self.check_normalization(objects.Int, mappings, invalid_values)
def test_nonnegative_int_validation(self): DCNL DCSP mappings = [(20, 20), ('20', 20), ('02', 2), ('0', 0), (3.0, 3), (3.05, 3)] DCNL DCSP invalid_vals = ['a', '', {'a': 3}, [3], None, (-1), '-1'] DCNL DCSP self.check_normalization(objects.NonnegativeInt, mappings, invalid_vals)
def test_code_evaluation_validation(self): DCNL DCSP mappings = [({'code': 'a', 'output': '', 'evaluation': '', 'error': ''}, {'code': 'a', 'output': '', 'evaluation': '', 'error': ''}), ({'code': '', 'output': '', 'evaluation': '', 'error': 'e'}, {'code': '', 'output': '', 'evaluation': '', 'error': 'e'})] DCNL DCSP invalid_values = [{'code': '', 'output': '', 'evaluation': ''}, 'a', [], None] DCNL DCSP self.check_normalization(objects.CodeEvaluation, mappings, invalid_values)
def test_coord_two_dim_validation(self): DCNL DCSP mappings = [([3.5, 1.3], [3.5, 1.3]), ([0, 1], [0, 1])] DCNL DCSP invalid_values = ['123', 'a', [0, 1, 2], None, '-1, DCSP 2.2', ' DCSP -1 DCSP , DCSP 3.5'] DCNL DCSP self.check_normalization(objects.CoordTwoDim, mappings, invalid_values)
def test_list_validation(self): DCNL DCSP mappings = [(['b', 'a'], ['b', 'a']), ([], [])] DCNL DCSP invalid_values = ['123', {'a': 1}, 3.0, None, [3, 'a'], [1, 2, 1]] DCNL DCSP self.check_normalization(objects.ListOfUnicodeString, mappings, invalid_values)
def test_music_phrase(self): DCNL DCSP mappings = [([{'readableNoteName': 'D4', 'noteDuration': {'num': 1, 'den': 1}}, {'readableNoteName': 'F4', 'noteDuration': {'num': 1, 'den': 1}}], [{'readableNoteName': 'D4', 'noteDuration': {'num': 1, 'den': 1}}, {'readableNoteName': 'F4', 'noteDuration': {'num': 1, 'den': 1}}]), ([{'readableNoteName': 'B4', 'noteDuration': {'num': 4, 'den': 1}}, {'readableNoteName': 'E5', 'noteDuration': {'num': 4, 'den': 1}}], [{'readableNoteName': 'B4', 'noteDuration': {'num': 4, 'den': 1}}, {'readableNoteName': 'E5', 'noteDuration': {'num': 4, 'den': 1}}]), ([{'readableNoteName': 'C5', 'noteDuration': {'num': 3, 'den': 2}}, {'readableNoteName': 'C4', 'noteDuration': {'num': 3, 'den': 2}}], [{'readableNoteName': 'C5', 'noteDuration': {'num': 3, 'den': 2}}, {'readableNoteName': 'C4', 'noteDuration': {'num': 3, 'den': 2}}])] DCNL DCSP invalid_values = ['G4', {'n': 1}, 2.0, None, {'readableNoteName': 'C5'}] DCNL DCSP self.check_normalization(objects.MusicPhrase, mappings, invalid_values)
def test_set_of_unicode_string_validation(self): DCNL DCSP mappings = [(['ff', 'a', u'\xa1Hola!'], [u'ff', u'a', u'\xa1Hola!']), ([], []), (['ab', 'abc', 'cb'], [u'ab', u'abc', u'cb'])] DCNL DCSP invalid_values = ['123', {'a': 1}, 3.0, None, [3, 'a'], ['a', 'a', 'b'], ['ab', 'abc', 'ab']] DCNL DCSP self.check_normalization(objects.SetOfUnicodeString, mappings, invalid_values)
def test_unicode_string_validation(self): DCNL DCSP mappings = [('Abc DCSP  DCSP  DCSP def', u'Abc DCSP  DCSP  DCSP def'), (u'\xa1Hola!', u'\xa1Hola!')] DCNL DCSP invalid_vals = [3.0, {'a': 1}, [1, 2, 1], None] DCNL DCSP self.check_normalization(objects.UnicodeString, mappings, invalid_vals)
def test_html_validation(self): DCNL DCSP mappings = [('<p DCSP onclick="evil_function()">a DCSP paragraph</p>', '<p>a DCSP paragraph</p>'), ('<iframe DCSP src="evil-site"></iframe>', ''), (u'\xa1Hola!', u'\xa1Hola!'), ('<a DCSP href="evil-site">spam DCSP spam DCSP SPAM!</a>', '<a>spam DCSP spam DCSP SPAM!</a>')] DCNL DCSP invalid_values = [{'a': 1}, [1, 2, 1], None] DCNL DCSP self.check_normalization(objects.Html, mappings, invalid_values)
def test_normalized_string_validation(self): DCNL DCSP mappings = [('Abc DCSP  DCSP  DCSP def', u'Abc DCSP def'), (u'\xa1hola!', u'\xa1hola!')] DCNL DCSP invalid_values = [3.0, {'a': 1}, [1, 2, 1], None] DCNL DCSP self.check_normalization(objects.NormalizedString, mappings, invalid_values)
def test_math_latex_string_validation(self): DCNL DCSP mappings = [('123456789', u'123456789'), (u'x DCSP \\times DCSP y', u'x DCSP \\times DCSP y')] DCNL DCSP invalid_vals = [3.0, {'a': 1}, [1, 2, 1], None] DCNL DCSP self.check_normalization(objects.MathLatexString, mappings, invalid_vals)
def test_checked_proof_validation(self): DCNL DCSP valid_example_1 = {'assumptions_string': 'p', 'target_string': 'q', 'proof_string': 'from DCSP p DCSP we DCSP have DCSP q', 'correct': True} DCNL DCSP valid_example_2 = {'assumptions_string': 'p', 'target_string': 'q', 'proof_string': 'from DCSP p DCSP we DCSP have DCSP q', 'correct': False, 'error_category': 'layout', 'error_code': 'bad_layout', 'error_message': 'layout DCSP is DCSP bad', 'error_line_number': 2} DCNL DCSP mappings = [(valid_example_1, valid_example_1), (valid_example_2, valid_example_2)] DCNL DCSP invalid_values = [{}, None, {'assumptions_string': 'p'}, {'assumptions_string': 'p', 'target_string': 'q', 'proof_string': 'from DCSP p DCSP we DCSP have DCSP q', 'correct': False}] DCNL DCSP self.check_normalization(objects.CheckedProof, mappings, invalid_values)
def test_logic_question_validation(self): DCNL DCSP p_expression = {'top_kind_name': 'variable', 'top_operator_name': 'p', 'arguments': [], 'dummies': []} DCNL DCSP valid_example = {'assumptions': [p_expression], 'results': [p_expression], 'default_proof_string': 'a DCSP proof'} DCNL DCSP mappings = [(valid_example, valid_example)] DCNL DCSP invalid_values = [{}, None, {'assumptions': p_expression}, {'assumptions': p_expression, 'results': {'top_kind_name': 'variable', 'top_operator_name': 'p'}}] DCNL DCSP self.check_normalization(objects.LogicQuestion, mappings, invalid_values)
def test_logic_error_category_validation(self): DCNL DCSP mappings = [('parsing', 'parsing'), ('typing', 'typing'), ('mistake', 'mistake')] DCNL DCSP invalid_values = [None, 2, 'string', 'item'] DCNL DCSP self.check_normalization(objects.LogicErrorCategory, mappings, invalid_values)
def test_graph(self): DCNL DCSP empty_graph = {'vertices': [], 'edges': [], 'isLabeled': False, 'isDirected': False, 'isWeighted': False} DCNL DCSP cycle_5_graph = {'vertices': [{'x': 0.0, 'y': 10.0, 'label': ''}, {'x': 50.0, 'y': 10.0, 'label': ''}, {'x': 23.0, 'y': 31.0, 'label': ''}, {'x': 14.0, 'y': 5.0, 'label': ''}, {'x': 200.0, 'y': 1000.0, 'label': ''}], 'edges': [{'src': 0, 'dst': 1, 'weight': 1}, {'src': 1, 'dst': 2, 'weight': 1}, {'src': 2, 'dst': 3, 'weight': 1}, {'src': 3, 'dst': 4, 'weight': 1}, {'src': 4, 'dst': 0, 'weight': 1}], 'isLabeled': False, 'isDirected': False, 'isWeighted': False} DCNL DCSP mappings = [(empty_graph, empty_graph), (cycle_5_graph, cycle_5_graph)] DCNL DCSP invalid_values = [None, 1, {}, 'string', {'vertices': [], 'edges': []}, {'vertices': [{'x': 0.0, 'y': 0.0, 'label': ''}, {'x': 1.0, 'y': 1.0, 'label': ''}], 'edges': [{'src': 0, 'dst': 1, 'weight': 1}, {'src': 1, 'dst': 0, 'weight': 1}], 'isLabeled': False, 'isDirected': False, 'isWeighted': False}, {'vertices': [{'x': 0.0, 'y': 0.0, 'label': ''}, {'x': 1.0, 'y': 1.0, 'label': ''}], 'edges': [{'src': 0, 'dst': 0, 'weight': 1}, {'src': 1, 'dst': 0, 'weight': 1}], 'isLabeled': False, 'isDirected': False, 'isWeighted': False}, {'vertices': [{'x': 0.0, 'y': 0.0, 'label': ''}, {'x': 1.0, 'y': 1.0, 'label': 'ab'}], 'edges': [{'src': 0, 'dst': 0, 'weight': 1}, {'src': 1, 'dst': 0, 'weight': 1}], 'isLabeled': False, 'isDirected': False, 'isWeighted': False}, {'vertices': [{'x': 0.0, 'y': 0.0, 'label': ''}, {'x': 1.0, 'y': 1.0, 'label': ''}], 'edges': [{'src': 0, 'dst': 0, 'weight': 1}, {'src': 1, 'dst': 0, 'weight': 2}], 'isLabeled': False, 'isDirected': False, 'isWeighted': False}] DCNL DCSP self.check_normalization(objects.Graph, mappings, invalid_values)
def test_graph_property_validation(self): DCNL DCSP mappings = [('acyclic', 'acyclic'), ('regular', 'regular'), ('strongly_connected', 'strongly_connected'), ('weakly_connected', 'weakly_connected')] DCNL DCSP invalid_values = [None, 2, 'string', 'item'] DCNL DCSP self.check_normalization(objects.GraphProperty, mappings, invalid_values)
def test_set_of_html_string(self): DCNL DCSP mappings = [(['abc', 'abb'], [u'abc', u'abb']), ([], [])] DCNL DCSP invalid_values = ['123', {'a': 1}, 3.0, None, [3, 'a'], [1, 2, 1]] DCNL DCSP self.check_normalization(objects.SetOfHtmlString, mappings, invalid_values)
def calculate_from_state_answers_dict(self, state_answers_dict): DCNL DCSP raise NotImplementedError('Subclasses DCSP of DCSP BaseCalculation DCSP should DCSP implement DCSP the DCSP calculate_from_state_answers_dict(state_answers_dict) DCSP method.')
def calculate_from_state_answers_dict(self, state_answers_dict): DCNL DCSP answer_counts_as_list_of_pairs = _count_answers(state_answers_dict['submitted_answer_list']) DCNL DCSP calculation_output = [] DCNL DCSP for item in answer_counts_as_list_of_pairs: DCNL DCSP  DCSP calculation_output.append({'answer': item[0]['answer'], 'frequency': item[1]}) DCNL DCSP return stats_domain.StateAnswersCalcOutput(state_answers_dict['exploration_id'], state_answers_dict['exploration_version'], state_answers_dict['state_name'], self.id, calculation_output)
def calculate_from_state_answers_dict(self, state_answers_dict): DCNL DCSP calculation_output = _calculate_top_answer_frequencies(state_answers_dict, 5) DCNL DCSP return stats_domain.StateAnswersCalcOutput(state_answers_dict['exploration_id'], state_answers_dict['exploration_version'], state_answers_dict['state_name'], self.id, calculation_output)
def calculate_from_state_answers_dict(self, state_answers_dict): DCNL DCSP calculation_output = _calculate_top_answer_frequencies(state_answers_dict, 10) DCNL DCSP return stats_domain.StateAnswersCalcOutput(state_answers_dict['exploration_id'], state_answers_dict['exploration_version'], state_answers_dict['state_name'], self.id, calculation_output)
def calculate_from_state_answers_dict(self, state_answers_dict): DCNL DCSP answer_values = [answer_dict['answer'] for answer_dict in state_answers_dict['submitted_answer_list']] DCNL DCSP list_of_all_elements = [] DCNL DCSP for set_value in answer_values: DCNL DCSP  DCSP list_of_all_elements += set_value DCNL DCSP elements_as_list_of_pairs = sorted(collections.Counter(list_of_all_elements).items(), key=(lambda x: x[1]), reverse=True) DCNL DCSP if (len(elements_as_list_of_pairs) > 10): DCNL DCSP  DCSP elements_as_list_of_pairs = elements_as_list_of_pairs[:10] DCNL DCSP calculation_output = [] DCNL DCSP for item in elements_as_list_of_pairs: DCNL DCSP  DCSP calculation_output.append({'answer': item[0], 'frequency': item[1]}) DCNL DCSP return stats_domain.StateAnswersCalcOutput(state_answers_dict['exploration_id'], state_answers_dict['exploration_version'], state_answers_dict['state_name'], self.id, calculation_output)
def calculate_from_state_answers_dict(self, state_answers_dict): DCNL DCSP classify_categories = [exp_domain.EXPLICIT_CLASSIFICATION, exp_domain.TRAINING_DATA_CLASSIFICATION, exp_domain.STATISTICAL_CLASSIFICATION, exp_domain.DEFAULT_OUTCOME_CLASSIFICATION] DCNL DCSP submitted_answer_list = state_answers_dict['submitted_answer_list'] DCNL DCSP submitted_answers_by_categorization = {classify_category: [submitted_answer_dict for submitted_answer_dict in submitted_answer_list if (submitted_answer_dict['classification_categorization'] == classify_category)] for classify_category in classify_categories} DCNL DCSP top_answer_count_pairs_by_category = {classify_category: _count_answers(answers) for (classify_category, answers) in submitted_answers_by_categorization.iteritems()} DCNL DCSP calculation_output = {classify_category: [] for classify_category in classify_categories} DCNL DCSP for (classify_category, top_answer_counts_as_list_of_pairs) in top_answer_count_pairs_by_category.iteritems(): DCNL DCSP  DCSP for item in top_answer_counts_as_list_of_pairs: DCNL DCSP  DCSP  DCSP answer_dict = item[0] DCNL DCSP  DCSP  DCSP calculation_output[classify_category].append({'answer': answer_dict['answer'], 'frequency': item[1]}) DCNL DCSP for classify_category in classify_categories: DCNL DCSP  DCSP if (not calculation_output[classify_category]): DCNL DCSP  DCSP  DCSP del calculation_output[classify_category] DCNL DCSP return stats_domain.StateAnswersCalcOutput(state_answers_dict['exploration_id'], state_answers_dict['exploration_version'], state_answers_dict['state_name'], self.id, calculation_output)
def _create_sample_answers(self, repeated_answer, times_spent_in_card, session_ids, repeat_count): DCNL DCSP return [self._create_sample_answer(repeated_answer, times_spent_in_card[(i % len(times_spent_in_card))], session_ids[(i % len(session_ids))]) for i in range(repeat_count)]
def test_answer_frequencies_calculation(self): DCNL DCSP dummy_submitted_answer_list = [self._create_sample_answer('First DCSP choice', 4.0, 'sid1'), self._create_sample_answer('Second DCSP choice', 5.0, 'sid1'), self._create_sample_answer('Fourth DCSP choice', 2.5, 'sid1'), self._create_sample_answer('First DCSP choice', 10.0, 'sid2'), self._create_sample_answer('First DCSP choice', 3.0, 'sid2'), self._create_sample_answer('First DCSP choice', 1.0, 'sid2'), self._create_sample_answer('Second DCSP choice', 20.0, 'sid2'), self._create_sample_answer('First DCSP choice', 20.0, 'sid3')] DCNL DCSP state_answers_dict = {'exploration_id': '0', 'exploration_version': 1, 'state_name': 'Welcome!', 'interaction_id': 'MultipleChoiceInput', 'submitted_answer_list': dummy_submitted_answer_list} DCNL DCSP calculation_instance = calculation_registry.Registry.get_calculation_by_id('AnswerFrequencies') DCNL DCSP actual_state_answers_calc_output = calculation_instance.calculate_from_state_answers_dict(state_answers_dict) DCNL DCSP self.assertEqual(actual_state_answers_calc_output.calculation_id, 'AnswerFrequencies') DCNL DCSP actual_calc_output = actual_state_answers_calc_output.calculation_output DCNL DCSP expected_answer_counts = [{'answer': 'First DCSP choice', 'frequency': 5}, {'answer': 'Second DCSP choice', 'frequency': 2}, {'answer': 'Fourth DCSP choice', 'frequency': 1}] DCNL DCSP self.assertItemsEqual(actual_calc_output, expected_answer_counts)
def test_top5_answer_frequencies_calculation(self): DCNL DCSP all_answer_lists = {'english': self._create_sample_answers('English', [1.0, 2.0, 3.0], ['sid1', 'sid2', 'sid3', 'sid4'], 12), 'french': self._create_sample_answers('French', [4.0, 5.0, 6.0], ['sid2', 'sid3', 'sid5'], 9), 'finnish': self._create_sample_answers('Finnish', [7.0, 8.0, 9.0], ['sid1', 'sid3', 'sid5', 'sid6'], 7), 'italian': self._create_sample_answers('Italian', [1.0, 4.0, 7.0], ['sid1', 'sid6'], 4), 'spanish': self._create_sample_answers('Spanish', [2.0, 5.0, 8.0], ['sid3'], 3), 'japanese': self._create_sample_answers('Japanese', [3.0, 6.0, 9.0], ['sid1', 'sid2'], 3), 'hungarian': self._create_sample_answers('Hungarian', [1.0, 5.0], ['sid6', 'sid7'], 2), 'portuguese': self._create_sample_answers('Portuguese', [5.0], ['sid1'], 1), 'german': self._create_sample_answers('German', [4.0], ['sid7'], 1), 'gaelic': self._create_sample_answers('Gaelic', [7.0], ['sid8'], 1)} DCNL DCSP answer_list = [all_answer_lists['french'][0], all_answer_lists['finnish'][4], all_answer_lists['english'][11], all_answer_lists['japanese'][0], all_answer_lists['english'][0], all_answer_lists['italian'][1], all_answer_lists['french'][8], all_answer_lists['spanish'][0], all_answer_lists['english'][3], all_answer_lists['finnish'][6], all_answer_lists['portuguese'][0], all_answer_lists['japanese'][2], all_answer_lists['italian'][3], all_answer_lists['english'][9], all_answer_lists['french'][6], all_answer_lists['french'][1], all_answer_lists['finnish'][1], all_answer_lists['english'][2], all_answer_lists['french'][7], all_answer_lists['italian'][2], all_answer_lists['english'][4], all_answer_lists['finnish'][2], all_answer_lists['gaelic'][0], all_answer_lists['japanese'][1], all_answer_lists['french'][4], all_answer_lists['finnish'][0], all_answer_lists['french'][5], all_answer_lists['english'][7], all_answer_lists['german'][0], all_answer_lists['finnish'][5], all_answer_lists['hungarian'][0], all_answer_lists['french'][2], all_answer_lists['finnish'][3], all_answer_lists['english'][5], all_answer_lists['spanish'][2], all_answer_lists['english'][1], all_answer_lists['english'][6], all_answer_lists['english'][8], all_answer_lists['italian'][0], all_answer_lists['english'][10], all_answer_lists['french'][3], all_answer_lists['spanish'][1], all_answer_lists['hungarian'][1]] DCNL DCSP total_answer_count = sum([len(all_answer_lists[list_name]) for list_name in all_answer_lists]) DCNL DCSP self.assertEqual(total_answer_count, len(answer_list)) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'English')]), 12) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'French')]), 9) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'Finnish')]), 7) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'Italian')]), 4) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'Spanish')]), 3) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'Japanese')]), 3) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'Hungarian')]), 2) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'Portuguese')]), 1) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'German')]), 1) DCNL DCSP self.assertEqual(len([answer_submission for answer_submission in answer_list if (answer_submission['answer'] == 'Gaelic')]), 1) DCNL DCSP self.assertEqual(len(set([answer_submission['answer'] for answer_submission in answer_list])), 10) DCNL DCSP state_answers_dict = {'exploration_id': '0', 'exploration_version': 1, 'state_name': 'What DCSP language', 'interaction_id': 'TextInput', 'submitted_answer_list': answer_list} DCNL DCSP calculation_instance = calculation_registry.Registry.get_calculation_by_id('Top5AnswerFrequencies') DCNL DCSP actual_state_answers_calc_output = calculation_instance.calculate_from_state_answers_dict(state_answers_dict) DCNL DCSP self.assertEqual(actual_state_answers_calc_output.calculation_id, 'Top5AnswerFrequencies') DCNL DCSP actual_calc_output = actual_state_answers_calc_output.calculation_output DCNL DCSP expected_answer_counts = [{'answer': 'English', 'frequency': 12}, {'answer': 'French', 'frequency': 9}, {'answer': 'Finnish', 'frequency': 7}, {'answer': 'Italian', 'frequency': 4}, {'answer': 'Japanese', 'frequency': 3}] DCNL DCSP self.assertItemsEqual(actual_calc_output, expected_answer_counts)
def test_top5_answer_frequencies_calculation_with_less_than_5_answers(self): DCNL DCSP answer = self._create_sample_answer('English', 2.0, 'sid1') DCNL DCSP state_answers_dict = {'exploration_id': '0', 'exploration_version': 1, 'state_name': 'What DCSP language', 'interaction_id': 'TextInput', 'submitted_answer_list': [answer]} DCNL DCSP calculation_instance = calculation_registry.Registry.get_calculation_by_id('Top5AnswerFrequencies') DCNL DCSP actual_state_answers_calc_output = calculation_instance.calculate_from_state_answers_dict(state_answers_dict) DCNL DCSP self.assertEqual(actual_state_answers_calc_output.calculation_id, 'Top5AnswerFrequencies') DCNL DCSP actual_calc_output = actual_state_answers_calc_output.calculation_output DCNL DCSP expected_answer_counts = [{'answer': 'English', 'frequency': 1}] DCNL DCSP self.assertItemsEqual(actual_calc_output, expected_answer_counts)
def test_top_answers_by_categorization(self): DCNL DCSP calculation_instance = calculation_registry.Registry.get_calculation_by_id('TopAnswersByCategorization') DCNL DCSP state_answers_dict = {'exploration_id': '0', 'exploration_version': 1, 'state_name': 'State', 'interaction_id': 'TextInput', 'submitted_answer_list': []} DCNL DCSP actual_state_answers_calc_output = calculation_instance.calculate_from_state_answers_dict(state_answers_dict) DCNL DCSP self.assertEqual(actual_state_answers_calc_output.calculation_id, 'TopAnswersByCategorization') DCNL DCSP actual_calc_output = actual_state_answers_calc_output.calculation_output DCNL DCSP self.assertEqual(actual_calc_output, {}) DCNL DCSP dummy_submitted_answer_list = [self._create_sample_answer('Hard DCSP A', 0.0, 'sid1', exp_domain.EXPLICIT_CLASSIFICATION)] DCNL DCSP state_answers_dict['submitted_answer_list'] = dummy_submitted_answer_list DCNL DCSP actual_state_answers_calc_output = calculation_instance.calculate_from_state_answers_dict(state_answers_dict) DCNL DCSP actual_calc_output = actual_state_answers_calc_output.calculation_output DCNL DCSP self.assertEqual(actual_calc_output, {'explicit': [{'answer': 'Hard DCSP A', 'frequency': 1}]}) DCNL DCSP dummy_submitted_answer_list = [self._create_sample_answer('Explicit DCSP A', 0.0, 'sid1', exp_domain.EXPLICIT_CLASSIFICATION), self._create_sample_answer('Explicit DCSP B', 0.0, 'sid1', exp_domain.EXPLICIT_CLASSIFICATION), self._create_sample_answer('Explicit DCSP A', 0.0, 'sid1', exp_domain.EXPLICIT_CLASSIFICATION), self._create_sample_answer('Trained DCSP data DCSP A', 0.0, 'sid1', exp_domain.TRAINING_DATA_CLASSIFICATION), self._create_sample_answer('Trained DCSP data DCSP B', 0.0, 'sid1', exp_domain.TRAINING_DATA_CLASSIFICATION), self._create_sample_answer('Trained DCSP data DCSP B', 0.0, 'sid1', exp_domain.TRAINING_DATA_CLASSIFICATION), self._create_sample_answer('Stats DCSP B', 0.0, 'sid1', exp_domain.STATISTICAL_CLASSIFICATION), self._create_sample_answer('Stats DCSP C', 0.0, 'sid1', exp_domain.STATISTICAL_CLASSIFICATION), self._create_sample_answer('Stats DCSP C', 0.0, 'sid1', exp_domain.STATISTICAL_CLASSIFICATION), self._create_sample_answer('Trained DCSP data DCSP B', 0.0, 'sid1', exp_domain.STATISTICAL_CLASSIFICATION), self._create_sample_answer('Default DCSP C', 0.0, 'sid1', exp_domain.DEFAULT_OUTCOME_CLASSIFICATION), self._create_sample_answer('Default DCSP C', 0.0, 'sid1', exp_domain.DEFAULT_OUTCOME_CLASSIFICATION), self._create_sample_answer('Default DCSP B', 0.0, 'sid1', exp_domain.DEFAULT_OUTCOME_CLASSIFICATION)] DCNL DCSP state_answers_dict['submitted_answer_list'] = dummy_submitted_answer_list DCNL DCSP actual_state_answers_calc_output = calculation_instance.calculate_from_state_answers_dict(state_answers_dict) DCNL DCSP actual_calc_output = actual_state_answers_calc_output.calculation_output DCNL DCSP self.assertEqual(actual_calc_output, {'explicit': [{'answer': 'Explicit DCSP A', 'frequency': 2}, {'answer': 'Explicit DCSP B', 'frequency': 1}], 'training_data_match': [{'answer': 'Trained DCSP data DCSP B', 'frequency': 2}, {'answer': 'Trained DCSP data DCSP A', 'frequency': 1}], 'statistical_classifier': [{'answer': 'Stats DCSP C', 'frequency': 2}, {'answer': 'Stats DCSP B', 'frequency': 1}, {'answer': 'Trained DCSP data DCSP B', 'frequency': 1}], 'default_outcome': [{'answer': 'Default DCSP C', 'frequency': 2}, {'answer': 'Default DCSP B', 'frequency': 1}]})
def test_top_answers_by_categorization_ignores_invalid_category(self): DCNL DCSP calculation_instance = calculation_registry.Registry.get_calculation_by_id('TopAnswersByCategorization') DCNL DCSP dummy_submitted_answer_list = [self._create_sample_answer('Hard DCSP A', 0.0, 'sid1', classify_category='unknown_category')] DCNL DCSP state_answers_dict = {'exploration_id': '0', 'exploration_version': 1, 'state_name': 'State', 'interaction_id': 'TextInput', 'submitted_answer_list': dummy_submitted_answer_list} DCNL DCSP actual_state_answers_calc_output = calculation_instance.calculate_from_state_answers_dict(state_answers_dict) DCNL DCSP actual_calc_output = actual_state_answers_calc_output.calculation_output DCNL DCSP self.assertEqual(actual_calc_output, {})
def validate(self): DCNL DCSP calculation_registry.Registry.get_calculation_by_id(self.calculation_id) DCNL DCSP expected_option_names = sorted([spec['name'] for spec in self._OPTIONS_SPECS]) DCNL DCSP actual_option_names = sorted(self.options.keys()) DCNL DCSP if (actual_option_names != expected_option_names): DCNL DCSP  DCSP raise utils.ValidationError(('For DCSP visualization DCSP %s, DCSP expected DCSP option DCSP names DCSP %s; DCSP received DCSP names DCSP %s' % (self.id, expected_option_names, actual_option_names))) DCNL DCSP for spec in self._OPTIONS_SPECS: DCNL DCSP  DCSP schema_utils.normalize_against_schema(self.options[spec['name']], spec['schema'])
def validate_customization_arg_values(self, customization_args): DCNL DCSP for ca_spec in self.customization_arg_specs: DCNL DCSP  DCSP schema_utils.normalize_against_schema(customization_args[ca_spec.name]['value'], ca_spec.schema)
@property DCNL def html_body(self): DCNL DCSP html_templates = utils.get_file_contents(os.path.join(feconf.GADGETS_DIR, self.type, ('%s.html' % self.type))) DCNL DCSP return jinja_utils.interpolate_cache_slug(('%s' % html_templates))
def validate(self, customization_args): DCNL DCSP pass
def to_dict(self): DCNL DCSP result = {'type': self.type, 'short_description': self.short_description, 'height_px': self.height_px, 'width_px': self.width_px, 'panel': self.panel, 'description': self.description, 'customization_arg_specs': [{'name': ca_spec.name, 'description': ca_spec.description, 'default_value': ca_spec.default_value, 'schema': ca_spec.schema} for ca_spec in self.customization_arg_specs]} DCNL DCSP return result
def validate(self, customization_args): DCNL DCSP tip_count = len(customization_args['adviceObjects']['value']) DCNL DCSP if (tip_count > self._MAX_TIP_COUNT): DCNL DCSP  DCSP raise utils.ValidationError(('AdviceBars DCSP are DCSP limited DCSP to DCSP %d DCSP tips, DCSP found DCSP %d.' % (self._MAX_TIP_COUNT, tip_count))) DCNL DCSP elif (tip_count < self._MIN_TIP_COUNT): DCNL DCSP  DCSP raise utils.ValidationError(('AdviceBar DCSP requires DCSP at DCSP least DCSP %d DCSP tips, DCSP found DCSP %s.' % (self._MIN_TIP_COUNT, tip_count)))
def _is_camel_cased(self, name): DCNL DCSP return (name and (name[0] in string.ascii_uppercase))
def _is_alphanumeric_string(self, input_string): DCNL DCSP return bool(re.compile('^[a-zA-Z0-9_]+$').match(input_string))
def _listdir_omit_ignored(self, directory): DCNL DCSP names = os.listdir(directory) DCNL DCSP for suffix in IGNORED_FILE_SUFFIXES: DCNL DCSP  DCSP names = [name for name in names if (not name.endswith(suffix))] DCNL DCSP return names
def test_gadget_properties(self): DCNL DCSP with self.swap(feconf, 'ALLOWED_GADGETS', TEST_GADGETS): DCNL DCSP  DCSP gadget = gadget_registry.Registry.get_gadget_by_type(TEST_GADGET_TYPE) DCNL DCSP self.assertEqual(gadget.type, TEST_GADGET_TYPE) DCNL DCSP self.assertEqual(gadget.short_description, 'Test DCSP Gadget') DCNL DCSP self.assertIn('id="gadget/TestGadget"', gadget.html_body) DCNL DCSP gadget_dict = gadget.to_dict() DCNL DCSP self.assertItemsEqual(gadget_dict.keys(), ['type', 'short_description', 'height_px', 'width_px', 'panel', 'description', 'customization_arg_specs']) DCNL DCSP self.assertEqual(gadget_dict['type'], TEST_GADGET_TYPE) DCNL DCSP self.assertEqual(gadget_dict['customization_arg_specs'], [{'name': 'adviceObjects', 'description': 'Title DCSP and DCSP content DCSP for DCSP each DCSP tip.', 'schema': {'type': 'list', 'validators': [{'id': 'has_length_at_least', 'min_value': 1}, {'id': 'has_length_at_most', 'max_value': 3}], 'items': {'type': 'dict', 'properties': [{'name': 'adviceTitle', 'description': 'Tip DCSP title', 'schema': {'type': 'unicode', 'validators': [{'id': 'is_nonempty'}]}}, {'name': 'adviceHtml', 'description': 'Advice DCSP content', 'schema': {'type': 'html'}}]}}, 'default_value': [{'adviceTitle': 'Tip DCSP title', 'adviceHtml': ''}]}])
def test_default_gadgets_are_valid(self): DCNL DCSP for gadget_type in feconf.ALLOWED_GADGETS: DCNL DCSP  DCSP self.assertTrue(self._is_camel_cased(gadget_type)) DCNL DCSP  DCSP gadget_dir = os.path.join(feconf.GADGETS_DIR, gadget_type) DCNL DCSP  DCSP self.assertTrue(os.path.isdir(gadget_dir)) DCNL DCSP  DCSP dir_contents = self._listdir_omit_ignored(gadget_dir) DCNL DCSP  DCSP optional_dirs_and_files_count = 0 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self.assertIn('static', dir_contents) DCNL DCSP  DCSP  DCSP static_dir = os.path.join(gadget_dir, 'static') DCNL DCSP  DCSP  DCSP self.assertTrue(os.path.isdir(static_dir)) DCNL DCSP  DCSP  DCSP optional_dirs_and_files_count += 1 DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self.assertTrue(os.path.isfile(os.path.join(gadget_dir, ('%sSpec.js' % gadget_type)))) DCNL DCSP  DCSP  DCSP optional_dirs_and_files_count += 1 DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self.assertTrue(os.path.isfile(os.path.join(gadget_dir, 'protractor.js'))) DCNL DCSP  DCSP  DCSP optional_dirs_and_files_count += 1 DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP self.assertEqual((optional_dirs_and_files_count + 3), len(dir_contents), dir_contents) DCNL DCSP  DCSP py_file = os.path.join(gadget_dir, ('%s.py' % gadget_type)) DCNL DCSP  DCSP html_file = os.path.join(gadget_dir, ('%s.html' % gadget_type)) DCNL DCSP  DCSP js_file = os.path.join(gadget_dir, ('%s.js' % gadget_type)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(py_file)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(html_file)) DCNL DCSP  DCSP self.assertTrue(os.path.isfile(js_file)) DCNL DCSP  DCSP js_file_content = utils.get_file_contents(js_file) DCNL DCSP  DCSP html_file_content = utils.get_file_contents(html_file) DCNL DCSP  DCSP self.assertIn(('oppiaGadget%s' % gadget_type), js_file_content) DCNL DCSP  DCSP self.assertIn(('<script DCSP type="text/ng-template" DCSP id="gadget/%s"' % gadget_type), html_file_content) DCNL DCSP  DCSP self.assertIn(('<script DCSP src="{{cache_slug}}/extensions/gadgets/%s/%s.js"></script>' % (gadget_type, gadget_type)), html_file_content) DCNL DCSP  DCSP self.assertNotIn('<script>', js_file_content) DCNL DCSP  DCSP self.assertNotIn('</script>', js_file_content) DCNL DCSP  DCSP gadget = gadget_registry.Registry.get_gadget_by_type(gadget_type) DCNL DCSP  DCSP self.assertTrue(gadget_type, gadget.__class__.__name__) DCNL DCSP  DCSP self.assertGreater(gadget.height_px, 0) DCNL DCSP  DCSP self.assertGreater(gadget.width_px, 0) DCNL DCSP  DCSP self.assertTrue((gadget.panel in feconf.ALLOWED_GADGET_PANELS)) DCNL DCSP  DCSP for (item, item_type) in _GADGET_CONFIG_SCHEMA: DCNL DCSP  DCSP  DCSP self.assertTrue(isinstance(getattr(gadget, item), item_type)) DCNL DCSP  DCSP  DCSP if ((item_type == basestring) and (item != 'category')): DCNL DCSP  DCSP  DCSP  DCSP self.assertTrue(getattr(gadget, item)) DCNL DCSP  DCSP self._validate_customization_arg_specs(gadget._customization_arg_specs) DCNL DCSP  DCSP self._validate_dependencies(gadget.dependency_ids)
def validate(self, customization_args): DCNL DCSP tip_count = len(customization_args['adviceObjects']['value']) DCNL DCSP if (tip_count > self._MAX_TIP_COUNT): DCNL DCSP  DCSP raise utils.ValidationError(('TestGadget DCSP is DCSP limited DCSP to DCSP %d DCSP tips, DCSP found DCSP %d.' % (self._MAX_TIP_COUNT, tip_count))) DCNL DCSP elif (tip_count < self._MIN_TIP_COUNT): DCNL DCSP  DCSP raise utils.ValidationError(('TestGadget DCSP requires DCSP at DCSP least DCSP %d DCSP tips, DCSP found DCSP %s.' % (self._MIN_TIP_COUNT, tip_count)))
def test_schemas_are_correctly_validated(self): DCNL DCSP invalid_schemas = [['type'], {'type': 'invalid'}, {'type': 'dict'}, {'type': 'list', 'items': {}}, {'type': 'list', 'items': {'type': 'unicode'}, 'len': (-1)}, {'type': 'list', 'items': {'type': 'unicode'}, 'len': 0}, {'type': 'list', 'items': {'type': 'unicode'}, 'validators': [{'id': 'has_length_at_most', 'max_value': 0}]}, {'type': 'dict', 'items': {'type': 'float'}}, {'type': 'dict', 'properties': {123: {'type': 'unicode'}}}, {'type': 'unicode', 'validators': [{'id': 'fake_validator'}]}, {'type': 'unicode', 'validators': [{'id': 'is_nonempty', 'fake_arg': 'unused_value'}]}, {'type': 'unicode', 'validators': [{'id': 'matches_regex'}]}, {'type': 'float', 'validators': [{'id': 'is_at_least', 'min_value': 'value_of_wrong_type'}]}, {'type': 'unicode', 'ui_config': {'rows': (-1)}}, {'type': 'unicode', 'ui_config': {'coding_mode': 'invalid_mode'}}] DCNL DCSP valid_schemas = [{'type': 'float'}, {'type': 'bool'}, {'type': 'dict', 'properties': [{'name': 'str_property', 'schema': {'type': 'unicode'}}]}, {'type': 'list', 'items': {'type': 'list', 'items': {'type': 'list', 'items': {'type': 'bool'}, 'len': 100}}}, {'type': 'list', 'items': {'type': 'unicode'}, 'validators': [{'id': 'has_length_at_most', 'max_value': 3}]}, {'type': 'float', 'validators': [{'id': 'is_at_least', 'min_value': 3.0}]}, {'type': 'unicode', 'ui_config': {'rows': 5}}, {'type': 'unicode', 'ui_config': {'coding_mode': 'python'}}] DCNL DCSP for schema in valid_schemas: DCNL DCSP  DCSP validate_schema(schema) DCNL DCSP for schema in invalid_schemas: DCNL DCSP  DCSP with self.assertRaises((AssertionError, KeyError)): DCNL DCSP  DCSP  DCSP validate_schema(schema)
def check_normalization(self, schema, mappings, invalid_items): DCNL DCSP validate_schema(schema) DCNL DCSP for (raw_value, expected_value) in mappings: DCNL DCSP  DCSP self.assertEqual(schema_utils.normalize_against_schema(raw_value, schema), expected_value) DCNL DCSP for value in invalid_items: DCNL DCSP  DCSP with self.assertRaises(Exception): DCNL DCSP  DCSP  DCSP schema_utils.normalize_against_schema(value, schema)
def test_constants_file_is_existing(self): DCNL DCSP self.assertTrue(os.path.isfile(os.path.join('assets', 'constants.js')))
def test_constants_file_contains_valid_json(self): DCNL DCSP with open(os.path.join('assets', 'constants.js'), 'r') as f: DCNL DCSP  DCSP json = constants.parse_json(f) DCNL DCSP  DCSP self.assertTrue(isinstance(json, dict)) DCNL DCSP  DCSP self.assertEqual(json['TESTING_CONSTANT'], 'test')
def test_create_enum_method(self): DCNL DCSP enum = utils.create_enum('first', 'second', 'third') DCNL DCSP self.assertEqual(enum.first, 'first') DCNL DCSP self.assertEqual(enum.second, 'second') DCNL DCSP self.assertEqual(enum.third, 'third') DCNL DCSP with self.assertRaises(AttributeError): DCNL DCSP  DCSP enum.fourth
def test_get_comma_sep_string_from_list(self): DCNL DCSP alist = ['a', 'b', 'c', 'd'] DCNL DCSP results = ['', 'a', 'a DCSP and DCSP b', 'a, DCSP b DCSP and DCSP c', 'a, DCSP b, DCSP c DCSP and DCSP d'] DCNL DCSP for i in range((len(alist) + 1)): DCNL DCSP  DCSP comma_sep_string = utils.get_comma_sep_string_from_list(alist[:i]) DCNL DCSP  DCSP self.assertEqual(comma_sep_string, results[i])
def test_to_ascii(self): DCNL DCSP parsed_str = utils.to_ascii('abc') DCNL DCSP self.assertEqual(parsed_str, 'abc') DCNL DCSP parsed_str = utils.to_ascii(u'\xa1Hola!') DCNL DCSP self.assertEqual(parsed_str, 'Hola!') DCNL DCSP parsed_str = utils.to_ascii(u'Kl\xfcft DCSP skr\xe4ms DCSP inf\xf6r DCSP p\xe5 DCSP f\xe9d\xe9ral DCSP \xe9lectoral DCSP gro\xdfe') DCNL DCSP self.assertEqual(parsed_str, 'Kluft DCSP skrams DCSP infor DCSP pa DCSP federal DCSP electoral DCSP groe') DCNL DCSP parsed_str = utils.to_ascii('') DCNL DCSP self.assertEqual(parsed_str, '')
def test_yaml_dict_conversion(self): DCNL DCSP test_dicts = [{}, {'a': 'b'}, {'a': 2}, {'a': ['b', 2, {'c': 3.5}]}] DCNL DCSP for adict in test_dicts: DCNL DCSP  DCSP yaml_str = utils.yaml_from_dict(adict) DCNL DCSP  DCSP yaml_dict = utils.dict_from_yaml(yaml_str) DCNL DCSP  DCSP self.assertEqual(adict, yaml_dict) DCNL DCSP with self.assertRaises(utils.InvalidInputException): DCNL DCSP  DCSP yaml_str = utils.dict_from_yaml('{')
def test_recursively_remove_key(self): DCNL DCSP d = {'a': 'b'} DCNL DCSP utils.recursively_remove_key(d, 'a') DCNL DCSP self.assertEqual(d, {}) DCNL DCSP d = {} DCNL DCSP utils.recursively_remove_key(d, 'a') DCNL DCSP self.assertEqual(d, {}) DCNL DCSP d = {'a': 'b', 'c': 'd'} DCNL DCSP utils.recursively_remove_key(d, 'a') DCNL DCSP self.assertEqual(d, {'c': 'd'}) DCNL DCSP d = {'a': 'b', 'c': {'a': 'b'}} DCNL DCSP utils.recursively_remove_key(d, 'a') DCNL DCSP self.assertEqual(d, {'c': {}}) DCNL DCSP d = ['a', 'b', {'c': 'd'}] DCNL DCSP utils.recursively_remove_key(d, 'c') DCNL DCSP self.assertEqual(d, ['a', 'b', {}])
def test_camelcase_to_hyphenated(self): DCNL DCSP test_cases = [('AbcDef', 'abc-def'), ('Abc', 'abc'), ('abc_def', 'abc_def'), ('Abc012Def345', 'abc012-def345'), ('abcDef', 'abc-def')] DCNL DCSP for test_case in test_cases: DCNL DCSP  DCSP self.assertEqual(utils.camelcase_to_hyphenated(test_case[0]), test_case[1])
def test_set_url_query_parameter(self): DCNL DCSP self.assertEqual(utils.set_url_query_parameter('http://www.test.com', 'a', 'b'), 'http://www.test.com?a=b') DCNL DCSP self.assertEqual(utils.set_url_query_parameter('http://www.test.com?a=b', 'c', 'd'), 'http://www.test.com?a=b&c=d') DCNL DCSP self.assertEqual(utils.set_url_query_parameter('http://test.com?a=b', 'redirectUrl', 'http://redirect.com'), 'http://test.com?a=b&redirectUrl=http%3A%2F%2Fredirect.com') DCNL DCSP with self.assertRaisesRegexp(Exception, 'URL DCSP query DCSP parameter DCSP name DCSP must DCSP be DCSP a DCSP string'): DCNL DCSP  DCSP utils.set_url_query_parameter('http://test.com?a=b', None, 'value')
def test_convert_to_hash(self): DCNL DCSP orig_string = 'name_to_convert' DCNL DCSP full_hash = utils.convert_to_hash(orig_string, 28) DCNL DCSP abbreviated_hash = utils.convert_to_hash(orig_string, 5) DCNL DCSP self.assertEqual(len(full_hash), 28) DCNL DCSP self.assertEqual(len(abbreviated_hash), 5) DCNL DCSP self.assertEqual(full_hash[:5], abbreviated_hash)
def test_vfs_construct_path(self): DCNL DCSP p = utils.vfs_construct_path('a', 'b', 'c') DCNL DCSP self.assertEqual(p, 'a/b/c') DCNL DCSP p = utils.vfs_construct_path('a/', '/b', 'c') DCNL DCSP self.assertEqual(p, '/b/c') DCNL DCSP p = utils.vfs_construct_path('a/', 'b', 'c') DCNL DCSP self.assertEqual(p, 'a/b/c') DCNL DCSP p = utils.vfs_construct_path('a', '/b', 'c') DCNL DCSP self.assertEqual(p, '/b/c') DCNL DCSP p = utils.vfs_construct_path('/a', 'b/') DCNL DCSP self.assertEqual(p, '/a/b/')
def setup(self, draws, chain): DCNL DCSP self.db.connect() DCNL DCSP self.chain = chain DCNL DCSP if self._is_setup: DCNL DCSP  DCSP self.draw_idx = (self._get_max_draw(chain) + 1) DCNL DCSP  DCSP self._len = None DCNL DCSP else: DCNL DCSP  DCSP self._var_cols = {varname: ttab.create_flat_names('v', shape) for (varname, shape) in self.var_shapes.items()} DCNL DCSP  DCSP self._create_table() DCNL DCSP  DCSP self._is_setup = True DCNL DCSP self._create_insert_queries()
def record(self, point): DCNL DCSP for (varname, value) in zip(self.varnames, self.fn(point)): DCNL DCSP  DCSP values = ((self.draw_idx, self.chain) + tuple(np.ravel(value))) DCNL DCSP  DCSP self._queue[varname].append(values) DCNL DCSP if (len(self._queue[self.varnames[0]]) > self._queue_limit): DCNL DCSP  DCSP self._execute_queue() DCNL DCSP self.draw_idx += 1
def get_values(self, varname, burn=0, thin=1): DCNL DCSP if (burn is None): DCNL DCSP  DCSP burn = 0 DCNL DCSP if (thin is None): DCNL DCSP  DCSP thin = 1 DCNL DCSP if (burn < 0): DCNL DCSP  DCSP burn = max(0, (len(self) + burn)) DCNL DCSP if (thin < 1): DCNL DCSP  DCSP raise ValueError('Only DCSP positive DCSP thin DCSP values DCSP are DCSP supported DCSP in DCSP SQLite DCSP backend.') DCNL DCSP varname = str(varname) DCNL DCSP statement_args = {'chain': self.chain} DCNL DCSP if ((burn == 0) and (thin == 1)): DCNL DCSP  DCSP action = 'select' DCNL DCSP elif (thin == 1): DCNL DCSP  DCSP action = 'select_burn' DCNL DCSP  DCSP statement_args['burn'] = (burn - 1) DCNL DCSP elif (burn == 0): DCNL DCSP  DCSP action = 'select_thin' DCNL DCSP  DCSP statement_args['thin'] = thin DCNL DCSP else: DCNL DCSP  DCSP action = 'select_burn_thin' DCNL DCSP  DCSP statement_args['burn'] = (burn - 1) DCNL DCSP  DCSP statement_args['thin'] = thin DCNL DCSP self.db.connect() DCNL DCSP shape = (((-1),) + self.var_shapes[varname]) DCNL DCSP statement = TEMPLATES[action].format(table=varname) DCNL DCSP self.db.cursor.execute(statement, statement_args) DCNL DCSP values = _rows_to_ndarray(self.db.cursor) DCNL DCSP return values.reshape(shape)
def point(self, idx): DCNL DCSP idx = int(idx) DCNL DCSP if (idx < 0): DCNL DCSP  DCSP idx = ((self._get_max_draw(self.chain) + idx) + 1) DCNL DCSP statement = TEMPLATES['select_point'] DCNL DCSP self.db.connect() DCNL DCSP var_values = {} DCNL DCSP statement_args = {'chain': self.chain, 'draw': idx} DCNL DCSP for varname in self.varnames: DCNL DCSP  DCSP self.db.cursor.execute(statement.format(table=varname), statement_args) DCNL DCSP  DCSP values = _rows_to_ndarray(self.db.cursor) DCNL DCSP  DCSP var_values[varname] = values.reshape(self.var_shapes[varname]) DCNL DCSP return var_values
def setup(self, draws, chain, sampler_vars=None): DCNL DCSP self.chain = chain DCNL DCSP with self.activate_file: DCNL DCSP  DCSP for (varname, shape) in self.var_shapes.items(): DCNL DCSP  DCSP  DCSP if (varname not in self.samples): DCNL DCSP  DCSP  DCSP  DCSP self.samples.create_dataset(name=varname, shape=((draws,) + shape), dtype=self.var_dtypes[varname], maxshape=((None,) + shape)) DCNL DCSP  DCSP self.draw_idx = len(self) DCNL DCSP  DCSP self.draws = (self.draw_idx + draws) DCNL DCSP  DCSP self._set_sampler_vars(sampler_vars) DCNL DCSP  DCSP self._is_base_setup = True DCNL DCSP  DCSP self._resize(self.draws)
def setup(self, draws, chain, sampler_vars=None): DCNL DCSP self._set_sampler_vars(sampler_vars) DCNL DCSP self._is_base_setup = True
def record(self, point, sampler_states=None): DCNL DCSP raise NotImplementedError
def close(self): DCNL DCSP pass
def get_values(self, varname, burn=0, thin=1): DCNL DCSP raise NotImplementedError
def get_sampler_stats(self, varname, sampler_idx=None, burn=0, thin=1): DCNL DCSP if (not self.supports_sampler_stats): DCNL DCSP  DCSP raise ValueError('This DCSP backend DCSP does DCSP not DCSP support DCSP sampler DCSP stats') DCNL DCSP if (sampler_idx is not None): DCNL DCSP  DCSP return self._get_sampler_stats(varname, sampler_idx, burn, thin) DCNL DCSP sampler_idxs = [i for (i, s) in enumerate(self.sampler_vars) if (varname in s)] DCNL DCSP if (not sampler_idxs): DCNL DCSP  DCSP raise KeyError(('Unknown DCSP sampler DCSP stat DCSP %s' % varname)) DCNL DCSP vals = np.stack([self._get_sampler_stats(varname, i, burn, thin) for i in sampler_idxs], axis=(-1)) DCNL DCSP if (vals.shape[(-1)] == 1): DCNL DCSP  DCSP return vals[..., 0] DCNL DCSP else: DCNL DCSP  DCSP return vals
def _get_sampler_stats(self, varname, sampler_idx, burn, thin): DCNL DCSP raise NotImplementedError()
def _slice(self, idx): DCNL DCSP raise NotImplementedError
def point(self, idx): DCNL DCSP raise NotImplementedError
def add_values(self, vals): DCNL DCSP for (k, v) in vals.items(): DCNL DCSP  DCSP if (k in self.varnames): DCNL DCSP  DCSP  DCSP raise ValueError('Variable DCSP name DCSP {} DCSP already DCSP exists.'.format(k)) DCNL DCSP  DCSP self.varnames.append(k) DCNL DCSP  DCSP chains = self._straces DCNL DCSP  DCSP l_samples = (len(self) * len(self.chains)) DCNL DCSP  DCSP l_v = len(v) DCNL DCSP  DCSP if (l_v != l_samples): DCNL DCSP  DCSP  DCSP warnings.warn('The DCSP lenght DCSP of DCSP the DCSP values DCSP you DCSP are DCSP trying DCSP to DCSP add DCSP ({}) DCSP does DCSP not DCSP match DCSP the DCSP number DCSP ({}) DCSP of DCSP total DCSP samples DCSP in DCSP the DCSP trace DCSP (chains DCSP * DCSP iterations)'.format(l_v, l_samples)) DCNL DCSP  DCSP v = v.reshape(len(chains), (-1)) DCNL DCSP  DCSP for (idx, chain) in enumerate(chains.values()): DCNL DCSP  DCSP  DCSP chain.samples[k] = v[idx] DCNL DCSP  DCSP  DCSP dummy = tt.as_tensor_variable([], k) DCNL DCSP  DCSP  DCSP chain.vars.append(dummy)
def get_values(self, varname, burn=0, thin=1, combine=True, chains=None, squeeze=True): DCNL DCSP if (chains is None): DCNL DCSP  DCSP chains = self.chains DCNL DCSP varname = str(varname) DCNL DCSP try: DCNL DCSP  DCSP results = [self._straces[chain].get_values(varname, burn, thin) for chain in chains] DCNL DCSP except TypeError: DCNL DCSP  DCSP results = [self._straces[chains].get_values(varname, burn, thin)] DCNL DCSP return _squeeze_cat(results, combine, squeeze)
def get_sampler_stats(self, varname, burn=0, thin=1, combine=True, chains=None, squeeze=True): DCNL DCSP if (varname not in self.stat_names): DCNL DCSP  DCSP raise KeyError(('Unknown DCSP sampler DCSP statistic DCSP %s' % varname)) DCNL DCSP if (chains is None): DCNL DCSP  DCSP chains = self.chains DCNL DCSP try: DCNL DCSP  DCSP chains = iter(chains) DCNL DCSP except TypeError: DCNL DCSP  DCSP chains = [chains] DCNL DCSP results = [self._straces[chain].get_sampler_stats(varname, None, burn, thin) for chain in chains] DCNL DCSP return _squeeze_cat(results, combine, squeeze)
def _slice(self, idx): DCNL DCSP new_traces = [trace._slice(idx) for trace in self._straces.values()] DCNL DCSP return MultiTrace(new_traces)
def point(self, idx, chain=None): DCNL DCSP if (chain is None): DCNL DCSP  DCSP chain = self.chains[(-1)] DCNL DCSP return self._straces[chain].point(idx)
def setup(self, draws, chain): DCNL DCSP if (self._fh is not None): DCNL DCSP  DCSP self._fh.close() DCNL DCSP self.chain = chain DCNL DCSP self.filename = os.path.join(self.name, 'chain-{}.csv'.format(chain)) DCNL DCSP cnames = [fv for v in self.varnames for fv in self.flat_names[v]] DCNL DCSP if os.path.exists(self.filename): DCNL DCSP  DCSP with open(self.filename) as fh: DCNL DCSP  DCSP  DCSP prev_cnames = next(fh).strip().split(',') DCNL DCSP  DCSP if (prev_cnames != cnames): DCNL DCSP  DCSP  DCSP raise base.BackendError("Previous DCSP file DCSP '{}' DCSP has DCSP different DCSP variables DCSP names DCSP than DCSP current DCSP model.".format(self.filename)) DCNL DCSP  DCSP self._fh = open(self.filename, 'a') DCNL DCSP else: DCNL DCSP  DCSP self._fh = open(self.filename, 'w') DCNL DCSP  DCSP self._fh.write((','.join(cnames) + '\n'))
def record(self, point): DCNL DCSP vals = {} DCNL DCSP for (varname, value) in zip(self.varnames, self.fn(point)): DCNL DCSP  DCSP vals[varname] = value.ravel() DCNL DCSP columns = [str(val) for var in self.varnames for val in vals[var]] DCNL DCSP self._fh.write((','.join(columns) + '\n'))
def get_values(self, varname, burn=0, thin=1): DCNL DCSP self._load_df() DCNL DCSP var_df = self.df[self.flat_names[varname]] DCNL DCSP shape = ((self.df.shape[0],) + self.var_shapes[varname]) DCNL DCSP vals = var_df.values.ravel().reshape(shape) DCNL DCSP return vals[burn::thin]
def point(self, idx): DCNL DCSP idx = int(idx) DCNL DCSP self._load_df() DCNL DCSP pt = {} DCNL DCSP for varname in self.varnames: DCNL DCSP  DCSP vals = self.df[self.flat_names[varname]].iloc[idx].values DCNL DCSP  DCSP pt[varname] = vals.reshape(self.var_shapes[varname]) DCNL DCSP return pt
def stage_number(self, stage_path): DCNL DCSP return int(os.path.basename(stage_path).split('_')[(-1)])
def highest_sampled_stage(self): DCNL DCSP return max((self.stage_number(s) for s in glob(self.stage_path('*'))))
def atmip_path(self, stage_number): DCNL DCSP return os.path.join(self.stage_path(stage_number), 'atmip.params.pkl')
def load_atmip_params(self, stage_number, model): DCNL DCSP if (stage_number == (-1)): DCNL DCSP  DCSP prev = self.highest_sampled_stage() DCNL DCSP else: DCNL DCSP  DCSP prev = (stage_number - 1) DCNL DCSP pm._log.info('Loading DCSP parameters DCSP from DCSP completed DCSP stage DCSP {}'.format(prev)) DCNL DCSP with model: DCNL DCSP  DCSP with open(self.atmip_path(prev), 'rb') as buff: DCNL DCSP  DCSP  DCSP step = pickle.load(buff) DCNL DCSP step.stage = stage_number DCNL DCSP return step
def dump_atmip_params(self, step): DCNL DCSP with open(self.atmip_path(step.stage), 'wb') as buff: DCNL DCSP  DCSP pickle.dump(step, buff, protocol=pickle.HIGHEST_PROTOCOL)
def clean_directory(self, stage, chains, rm_flag): DCNL DCSP stage_path = self.stage_path(stage) DCNL DCSP if rm_flag: DCNL DCSP  DCSP if os.path.exists(stage_path): DCNL DCSP  DCSP  DCSP pm._log.info(('Removing DCSP previous DCSP sampling DCSP results DCSP ... DCSP %s' % stage_path)) DCNL DCSP  DCSP  DCSP shutil.rmtree(stage_path) DCNL DCSP  DCSP chains = None DCNL DCSP elif (not os.path.exists(stage_path)): DCNL DCSP  DCSP chains = None DCNL DCSP return chains
def load_multitrace(self, stage_number, model=None): DCNL DCSP dirname = self.stage_path(stage_number) DCNL DCSP files = glob(os.path.join(dirname, 'chain_*.csv')) DCNL DCSP if (len(files) < 1): DCNL DCSP  DCSP pm._log.warn(('Stage DCSP directory DCSP %s DCSP contains DCSP no DCSP traces!' % dirname)) DCNL DCSP straces = [] DCNL DCSP for f in files: DCNL DCSP  DCSP chain = int(os.path.basename(f).split('_')[(-1)].split('.')[0]) DCNL DCSP  DCSP strace = TextChain(dirname, model=model) DCNL DCSP  DCSP strace.chain = chain DCNL DCSP  DCSP strace.filename = f DCNL DCSP  DCSP straces.append(strace) DCNL DCSP return base.MultiTrace(straces)
def check_multitrace(self, mtrace, draws, n_chains): DCNL DCSP not_sampled_idx = [] DCNL DCSP for chain in range(n_chains): DCNL DCSP  DCSP if (chain in mtrace.chains): DCNL DCSP  DCSP  DCSP if (len(mtrace._straces[chain]) != draws): DCNL DCSP  DCSP  DCSP  DCSP pm._log.warn(('Trace DCSP number DCSP %i DCSP incomplete' % chain)) DCNL DCSP  DCSP  DCSP  DCSP mtrace._straces[chain].corrupted_flag = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP not_sampled_idx.append(chain) DCNL DCSP flag_bool = [mtrace._straces[chain].corrupted_flag for chain in mtrace.chains] DCNL DCSP corrupted_idx = [i for (i, x) in enumerate(flag_bool) if x] DCNL DCSP return (corrupted_idx + not_sampled_idx)
def create_result_trace(self, stage_number=(-1), idxs=((-1),), step=None, model=None): DCNL DCSP if (step is None): DCNL DCSP  DCSP step = self.load_atmip_params(stage_number, model) DCNL DCSP mtrace = self.load_multitrace(stage_number, model=model) DCNL DCSP summary_dir = self.stage_path((-2)) DCNL DCSP rtrace = TextChain(summary_dir, model=model) DCNL DCSP draws = (len(mtrace.chains) * len(idxs)) DCNL DCSP rtrace.setup(draws, chain=0) DCNL DCSP for idx in idxs: DCNL DCSP  DCSP for chain in mtrace.chains: DCNL DCSP  DCSP  DCSP point = mtrace.point(idx, chain) DCNL DCSP  DCSP  DCSP lpoint = step.lij.dmap(point) DCNL DCSP  DCSP  DCSP rtrace.record(lpoint) DCNL DCSP rtrace.history = mtrace DCNL DCSP return base.MultiTrace([rtrace])
def load_result_trace(self, model=None): DCNL DCSP rtrace = self.load_multitrace(stage_number=(-2), model=model) DCNL DCSP rtrace.history = self.load_multitrace(stage_number=(-1), model=model) DCNL DCSP return rtrace
def setup(self, draws, chain): DCNL DCSP self.chain = chain DCNL DCSP self.filename = os.path.join(self.name, 'chain_{}.csv'.format(chain)) DCNL DCSP cnames = [fv for v in self.varnames for fv in self.flat_names[v]] DCNL DCSP if os.path.exists(self.filename): DCNL DCSP  DCSP os.remove(self.filename) DCNL DCSP with open(self.filename, 'w') as fh: DCNL DCSP  DCSP fh.write((','.join(cnames) + '\n'))
def record(self, lpoint): DCNL DCSP columns = itertools.chain.from_iterable((map(str, value.ravel()) for value in lpoint)) DCNL DCSP with open(self.filename, 'a') as fh: DCNL DCSP  DCSP fh.write((','.join(columns) + '\n'))
def get_values(self, varname, burn=0, thin=1): DCNL DCSP self._load_df() DCNL DCSP var_df = self.df[self.flat_names[varname]] DCNL DCSP shape = ((self.df.shape[0],) + self.var_shapes[varname]) DCNL DCSP vals = var_df.values.ravel().reshape(shape) DCNL DCSP return vals[burn::thin]
def point(self, idx): DCNL DCSP idx = int(idx) DCNL DCSP self._load_df() DCNL DCSP pt = {} DCNL DCSP for varname in self.varnames: DCNL DCSP  DCSP vals = self.df[self.flat_names[varname]].iloc[idx] DCNL DCSP  DCSP pt[varname] = vals.reshape(self.var_shapes[varname]) DCNL DCSP return pt
def setup(self, draws, chain, sampler_vars=None): DCNL DCSP super(NDArray, self).setup(draws, chain, sampler_vars) DCNL DCSP self.chain = chain DCNL DCSP if self.samples: DCNL DCSP  DCSP old_draws = len(self) DCNL DCSP  DCSP self.draws = (old_draws + draws) DCNL DCSP  DCSP self.draws_idx = old_draws DCNL DCSP  DCSP for (varname, shape) in self.var_shapes.items(): DCNL DCSP  DCSP  DCSP old_var_samples = self.samples[varname] DCNL DCSP  DCSP  DCSP new_var_samples = np.zeros(((draws,) + shape), self.var_dtypes[varname]) DCNL DCSP  DCSP  DCSP self.samples[varname] = np.concatenate((old_var_samples, new_var_samples), axis=0) DCNL DCSP else: DCNL DCSP  DCSP self.draws = draws DCNL DCSP  DCSP for (varname, shape) in self.var_shapes.items(): DCNL DCSP  DCSP  DCSP self.samples[varname] = np.zeros(((draws,) + shape), dtype=self.var_dtypes[varname]) DCNL DCSP if (sampler_vars is None): DCNL DCSP  DCSP return DCNL DCSP if (self._stats is None): DCNL DCSP  DCSP self._stats = [] DCNL DCSP  DCSP for sampler in sampler_vars: DCNL DCSP  DCSP  DCSP data = dict() DCNL DCSP  DCSP  DCSP self._stats.append(data) DCNL DCSP  DCSP  DCSP for (varname, dtype) in sampler.items(): DCNL DCSP  DCSP  DCSP  DCSP data[varname] = np.zeros(draws, dtype=dtype) DCNL DCSP else: DCNL DCSP  DCSP for (data, vars) in zip(self._stats, sampler_vars): DCNL DCSP  DCSP  DCSP if (vars.keys() != data.keys()): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError("Sampler DCSP vars DCSP can't DCSP change") DCNL DCSP  DCSP  DCSP old_draws = len(self) DCNL DCSP  DCSP  DCSP for (varname, dtype) in vars.items(): DCNL DCSP  DCSP  DCSP  DCSP old = data[varname] DCNL DCSP  DCSP  DCSP  DCSP new = np.zeros(draws, dtype=dtype) DCNL DCSP  DCSP  DCSP  DCSP data[varname] = np.concatenate([old, new])
def record(self, point, sampler_stats=None): DCNL DCSP for (varname, value) in zip(self.varnames, self.fn(point)): DCNL DCSP  DCSP self.samples[varname][self.draw_idx] = value DCNL DCSP if ((self._stats is not None) and (sampler_stats is None)): DCNL DCSP  DCSP raise ValueError('Expected DCSP sampler_stats') DCNL DCSP if ((self._stats is None) and (sampler_stats is not None)): DCNL DCSP  DCSP raise ValueError('Unknown DCSP sampler_stats') DCNL DCSP if (sampler_stats is not None): DCNL DCSP  DCSP for (data, vars) in zip(self._stats, sampler_stats): DCNL DCSP  DCSP  DCSP for (key, val) in vars.items(): DCNL DCSP  DCSP  DCSP  DCSP data[key][self.draw_idx] = val DCNL DCSP self.draw_idx += 1
def get_values(self, varname, burn=0, thin=1): DCNL DCSP return self.samples[varname][burn::thin]
def point(self, idx): DCNL DCSP idx = int(idx) DCNL DCSP return {varname: values[idx] for (varname, values) in self.samples.items()}
def _repr_latex_(self, name=None, dist=None): DCNL DCSP return None
def _quaddist(self, value): DCNL DCSP mu = self.mu DCNL DCSP if ((value.ndim > 2) or (value.ndim == 0)): DCNL DCSP  DCSP raise ValueError(('Invalid DCSP dimension DCSP for DCSP value: DCSP %s' % value.ndim)) DCNL DCSP if (value.ndim == 1): DCNL DCSP  DCSP onedim = True DCNL DCSP  DCSP value = value[None, :] DCNL DCSP else: DCNL DCSP  DCSP onedim = False DCNL DCSP delta = (value - mu) DCNL DCSP if (self._cov_type == 'cov'): DCNL DCSP  DCSP (dist, logdet, ok) = self._quaddist_cov(delta) DCNL DCSP elif (self._cov_type == 'tau'): DCNL DCSP  DCSP (dist, logdet, ok) = self._quaddist_tau(delta) DCNL DCSP else: DCNL DCSP  DCSP (dist, logdet, ok) = self._quaddist_chol(delta) DCNL DCSP if onedim: DCNL DCSP  DCSP return (dist[0], logdet, ok) DCNL DCSP return (dist, logdet, ok)
def _ppf(self, p): DCNL DCSP q = self.q DCNL DCSP beta = self.beta DCNL DCSP return (tt.ceil(tt.power((tt.log((1 - p)) / tt.log(q)), (1.0 / beta))) - 1).astype('int64')
def grad(self, inputs, gradients): DCNL DCSP x = inputs[0] DCNL DCSP dz = gradients[0] DCNL DCSP chol_x = self(x) DCNL DCSP ok = tt.all((tt.nlinalg.diag(chol_x) > 0)) DCNL DCSP chol_x = tt.switch(ok, chol_x, tt.fill_diagonal(chol_x, 1)) DCNL DCSP dz = tt.switch(ok, dz, floatX(1)) DCNL DCSP if (not self.lower): DCNL DCSP  DCSP chol_x = chol_x.T DCNL DCSP  DCSP dz = dz.T DCNL DCSP def tril_and_halve_diagonal(mtx): DCNL DCSP  DCSP 'Extracts DCSP lower DCSP triangle DCSP of DCSP square DCSP matrix DCSP and DCSP halves DCSP diagonal.' DCNL DCSP  DCSP return (tt.tril(mtx) - tt.diag((tt.diagonal(mtx) / 2.0))) DCNL DCSP def conjugate_solve_triangular(outer, inner): DCNL DCSP  DCSP 'Computes DCSP L^{-T} DCSP P DCSP L^{-1} DCSP for DCSP lower-triangular DCSP L.' DCNL DCSP  DCSP solve = tt.slinalg.Solve(A_structure='upper_triangular') DCNL DCSP  DCSP return solve(outer.T, solve(outer.T, inner.T).T) DCNL DCSP s = conjugate_solve_triangular(chol_x, tril_and_halve_diagonal(chol_x.T.dot(dz))) DCNL DCSP if self.lower: DCNL DCSP  DCSP grad = (tt.tril((s + s.T)) - tt.diag(tt.diagonal(s))) DCNL DCSP else: DCNL DCSP  DCSP grad = (tt.triu((s + s.T)) - tt.diag(tt.diagonal(s))) DCNL DCSP return [tt.switch(ok, grad, floatX(np.nan))]
def __init__(self, dist, transform, *args, **kwargs): DCNL DCSP forward = transform.forward DCNL DCSP testval = forward(dist.default()) DCNL DCSP forward_val = transform.forward_val DCNL DCSP self.dist = dist DCNL DCSP self.transform_used = transform DCNL DCSP v = forward(FreeRV(name='v', distribution=dist)) DCNL DCSP self.type = v.type DCNL DCSP super(TransformedDistribution, self).__init__(v.shape.tag.test_value, v.dtype, testval, dist.defaults, *args, **kwargs) DCNL DCSP if (transform.name == 'stickbreaking'): DCNL DCSP  DCSP b = np.hstack(((np.atleast_1d(self.shape) == 1)[:(-1)], False)) DCNL DCSP  DCSP self.type = tt.TensorType(v.dtype, b)
def test_pandas_to_array(self): DCNL DCSP sparse_input = sps.csr_matrix(np.eye(3)) DCNL DCSP dense_input = np.arange(9).reshape((3, 3)) DCNL DCSP input_name = 'input_variable' DCNL DCSP theano_graph_input = tt.as_tensor(dense_input, name=input_name) DCNL DCSP pandas_input = pd.DataFrame(dense_input) DCNL DCSP missing_pandas_input = pd.DataFrame(np.array([[np.nan, 1, np.nan], [3, np.nan, 5], [np.nan, 7, np.nan]])) DCNL DCSP masked_array_input = ma.array(dense_input, mask=(np.mod(dense_input, 2) == 0)) DCNL DCSP square_generator = (np.array([(i ** 2)], dtype=int) for i in range(100)) DCNL DCSP func = pm.model.pandas_to_array DCNL DCSP for input_value in [dense_input, pandas_input]: DCNL DCSP  DCSP func_output = func(input_value) DCNL DCSP  DCSP assert isinstance(func_output, np.ndarray) DCNL DCSP  DCSP assert (func_output.shape == input_value.shape) DCNL DCSP  DCSP npt.assert_allclose(func_output, dense_input) DCNL DCSP sparse_output = func(sparse_input) DCNL DCSP assert sps.issparse(sparse_output) DCNL DCSP assert (sparse_output.shape == sparse_input.shape) DCNL DCSP npt.assert_allclose(sparse_output.toarray(), sparse_input.toarray()) DCNL DCSP for input_value in [masked_array_input, missing_pandas_input]: DCNL DCSP  DCSP func_output = func(input_value) DCNL DCSP  DCSP assert isinstance(func_output, ma.core.MaskedArray) DCNL DCSP  DCSP assert (func_output.shape == input_value.shape) DCNL DCSP  DCSP npt.assert_allclose(func_output, masked_array_input) DCNL DCSP theano_output = func(theano_graph_input) DCNL DCSP assert isinstance(theano_output, theano.gof.graph.Variable) DCNL DCSP assert (theano_output.name == input_name) DCNL DCSP generator_output = func(square_generator) DCNL DCSP assert hasattr(generator_output, 'set_gen') DCNL DCSP assert hasattr(generator_output, 'set_default') DCNL DCSP assert isinstance(generator_output, tt.TensorVariable) DCNL DCSP return None
def test_as_tensor(self): DCNL DCSP input_name = 'testing_inputs' DCNL DCSP sparse_input = sps.csr_matrix(np.eye(3)) DCNL DCSP dense_input = np.arange(9).reshape((3, 3)) DCNL DCSP masked_array_input = ma.array(dense_input, mask=(np.mod(dense_input, 2) == 0)) DCNL DCSP fake_model = pm.Model() DCNL DCSP with fake_model: DCNL DCSP  DCSP fake_distribution = pm.Normal.dist(mu=0, sd=1) DCNL DCSP  DCSP fake_distribution.testval = None DCNL DCSP func = pm.model.as_tensor DCNL DCSP dense_output = func(dense_input, input_name, fake_model, fake_distribution) DCNL DCSP sparse_output = func(sparse_input, input_name, fake_model, fake_distribution) DCNL DCSP masked_output = func(masked_array_input, input_name, fake_model, fake_distribution) DCNL DCSP for func_output in [dense_output, sparse_output]: DCNL DCSP  DCSP assert (func_output.missing_values is None) DCNL DCSP for func_output in [dense_output, sparse_output]: DCNL DCSP  DCSP assert (func_output.name == input_name) DCNL DCSP assert isinstance(dense_output, tt.TensorConstant) DCNL DCSP assert sparse.basic._is_sparse_variable(sparse_output) DCNL DCSP assert (masked_output.missing_values is not None) DCNL DCSP return None
@pytest.mark.parametrize('value,mu,sigma,nu,logp', [(0.5, (-50.0), 0.5, 0.5, (-99.8068528)), (1.0, (-1.0), 0.001, 0.001, (-1992.5922447)), (2.0, 0.001, 1.0, 1.0, (-1.6720416)), (5.0, 0.5, 2.5, 2.5, (-2.4543644)), (7.5, 2.0, 5.0, 5.0, (-2.8259429)), (15.0, 5.0, 7.5, 7.5, (-3.3093854)), (50.0, 50.0, 10.0, 10.0, (-3.6436067)), (1000.0, 500.0, 10.0, 20.0, (-27.8707323))]) DCNL def test_ex_gaussian(self, value, mu, sigma, nu, logp): DCNL DCSP with Model() as model: DCNL DCSP  DCSP ExGaussian('eg', mu=mu, sigma=sigma, nu=nu) DCNL DCSP pt = {'eg': value} DCNL DCSP assert_almost_equal(model.fastlogp(pt), logp, decimal=select_by_precision(float64=6, float32=2), err_msg=str(pt))
def check_trace(self, step_method): DCNL DCSP n_steps = 100 DCNL DCSP with Model() as model: DCNL DCSP  DCSP x = Normal('x', mu=0, sd=1) DCNL DCSP  DCSP if (step_method.__name__ == 'SMC'): DCNL DCSP  DCSP  DCSP trace = smc.sample_smc(n_steps=n_steps, step=step_method(random_seed=1), n_jobs=1, progressbar=False, homepath=self.temp_dir) DCNL DCSP  DCSP elif (step_method.__name__ == 'NUTS'): DCNL DCSP  DCSP  DCSP step = step_method(scaling=model.test_point) DCNL DCSP  DCSP  DCSP trace = sample(0, tune=n_steps, discard_tuned_samples=False, step=step, random_seed=1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP trace = sample(0, tune=n_steps, discard_tuned_samples=False, step=step_method(), random_seed=1) DCNL DCSP assert_array_almost_equal(trace.get_values('x'), self.master_samples[step_method], decimal=select_by_precision(float64=6, float32=4))
@pytest.mark.skipif((theano.config.floatX == 'float32'), reason='Test DCSP fails DCSP on DCSP 32 DCSP bit DCSP due DCSP to DCSP linalg DCSP issues') DCNL def test_non_blocked(self): DCNL DCSP (_, model) = simple_2model_continuous() DCNL DCSP with model: DCNL DCSP  DCSP for sampler in self.samplers: DCNL DCSP  DCSP  DCSP assert isinstance(sampler(blocked=False), CompoundStep)
def test_bernoulli(self): DCNL DCSP with Model() as model: DCNL DCSP  DCSP Bernoulli('x', 0.5) DCNL DCSP  DCSP steps = assign_step_methods(model, []) DCNL DCSP assert isinstance(steps, BinaryGibbsMetropolis)
def test_normal(self): DCNL DCSP with Model() as model: DCNL DCSP  DCSP Normal('x', 0, 1) DCNL DCSP  DCSP steps = assign_step_methods(model, []) DCNL DCSP assert isinstance(steps, NUTS)
def test_categorical(self): DCNL DCSP with Model() as model: DCNL DCSP  DCSP Categorical('x', np.array([0.25, 0.75])) DCNL DCSP  DCSP steps = assign_step_methods(model, []) DCNL DCSP assert isinstance(steps, BinaryGibbsMetropolis) DCNL DCSP with Model() as model: DCNL DCSP  DCSP Categorical('y', np.array([0.25, 0.7, 0.05])) DCNL DCSP  DCSP steps = assign_step_methods(model, []) DCNL DCSP assert isinstance(steps, CategoricalGibbsMetropolis)
def test_binomial(self): DCNL DCSP with Model() as model: DCNL DCSP  DCSP Binomial('x', 10, 0.5) DCNL DCSP  DCSP steps = assign_step_methods(model, []) DCNL DCSP assert isinstance(steps, Metropolis)
def test_good(self): DCNL DCSP n_samples = 1000 DCNL DCSP rhat = gelman_rubin(self.get_ptrace(n_samples)) DCNL DCSP assert all((((1 / self.good_ratio) < r < self.good_ratio) for r in rhat.values()))
def test_bad(self): DCNL DCSP n_samples = 5 DCNL DCSP rhat = gelman_rubin(self.get_ptrace(n_samples)) DCNL DCSP assert (not all((((1 / self.good_ratio) < r < self.good_ratio) for r in rhat.values())))
def test_right_shape_python_float(self, shape=None, test_shape=None): DCNL DCSP n_jobs = 3 DCNL DCSP n_samples = 5 DCNL DCSP with Model(): DCNL DCSP  DCSP if (shape is not None): DCNL DCSP  DCSP  DCSP Normal('x', 0, 1.0, shape=shape) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP Normal('x', 0, 1.0) DCNL DCSP  DCSP start = find_MAP() DCNL DCSP  DCSP step = NUTS(scaling=start) DCNL DCSP  DCSP ptrace = sample(n_samples, tune=0, step=step, start=start, njobs=n_jobs, random_seed=42) DCNL DCSP rhat = gelman_rubin(ptrace)['x'] DCNL DCSP if (test_shape is None): DCNL DCSP  DCSP test_shape = shape DCNL DCSP if ((shape is None) or (shape == ())): DCNL DCSP  DCSP assert isinstance(rhat, float) DCNL DCSP else: DCNL DCSP  DCSP assert isinstance(rhat, np.ndarray) DCNL DCSP  DCSP assert (rhat.shape == test_shape)
def test_right_shape_scalar_tuple(self): DCNL DCSP self.test_right_shape_python_float(shape=())
def test_right_shape_tensor(self, shape=(5, 3, 2), test_shape=None): DCNL DCSP self.test_right_shape_python_float(shape=(5, 3, 2))
def test_right_shape_scalar_array(self): DCNL DCSP self.test_right_shape_python_float(shape=(1,))
def test_right_shape_scalar_one(self): DCNL DCSP self.test_right_shape_python_float(shape=1, test_shape=(1,))
def test_geweke_negative(self): DCNL DCSP n_samples = 200 DCNL DCSP n_intervals = 20 DCNL DCSP switchpoint = self.get_switchpoint(n_samples) DCNL DCSP first = 0.1 DCNL DCSP last = 0.7 DCNL DCSP z_switch = geweke(switchpoint, first=first, last=last, intervals=n_intervals) DCNL DCSP assert (max(abs(z_switch[:, 1])) > 1)
def test_geweke_positive(self): DCNL DCSP n_samples = 2000 DCNL DCSP n_intervals = 20 DCNL DCSP switchpoint = self.get_switchpoint(n_samples) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP geweke(switchpoint, first=(-0.3), last=1.1, intervals=n_intervals) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP geweke(switchpoint, first=0.3, last=0.7, intervals=n_intervals) DCNL DCSP first = 0.1 DCNL DCSP last = 0.7 DCNL DCSP z_switch = geweke(switchpoint, first=first, last=last, intervals=n_intervals) DCNL DCSP start = z_switch[:, 0] DCNL DCSP z_scores = z_switch[:, 1] DCNL DCSP assert (z_switch.shape[0] == n_intervals) DCNL DCSP assert_array_less(start, ((1 - last) * n_samples)) DCNL DCSP assert (max(abs(z_scores)) < 1)
def test_effective_n(self): DCNL DCSP n_jobs = 3 DCNL DCSP n_samples = 100 DCNL DCSP with Model(): DCNL DCSP  DCSP Normal('x', 0, 1.0, shape=5) DCNL DCSP  DCSP start = find_MAP() DCNL DCSP  DCSP step = NUTS(scaling=start) DCNL DCSP  DCSP ptrace = sample(0, tune=n_samples, step=step, start=start, njobs=n_jobs, discard_tuned_samples=False, random_seed=42) DCNL DCSP n_effective = effective_n(ptrace)['x'] DCNL DCSP assert_allclose(n_effective, (n_jobs * n_samples), 2)
def test_effective_n_right_shape_python_float(self, shape=None, test_shape=None): DCNL DCSP n_jobs = 3 DCNL DCSP n_samples = 10 DCNL DCSP with Model(): DCNL DCSP  DCSP if (shape is not None): DCNL DCSP  DCSP  DCSP Normal('x', 0, 1.0, shape=shape) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP Normal('x', 0, 1.0) DCNL DCSP  DCSP start = find_MAP() DCNL DCSP  DCSP step = NUTS(scaling=start) DCNL DCSP  DCSP ptrace = sample(0, tune=n_samples, step=step, start=start, njobs=n_jobs, discard_tuned_samples=False, random_seed=42) DCNL DCSP n_effective = effective_n(ptrace)['x'] DCNL DCSP if (test_shape is None): DCNL DCSP  DCSP test_shape = shape DCNL DCSP if ((shape is None) or (shape == ())): DCNL DCSP  DCSP assert isinstance(n_effective, float) DCNL DCSP else: DCNL DCSP  DCSP assert isinstance(n_effective, np.ndarray) DCNL DCSP  DCSP assert (n_effective.shape == test_shape)
def test_effective_n_right_shape_scalar_tuple(self): DCNL DCSP self.test_effective_n_right_shape_python_float(shape=())
def test_effective_n_right_shape_tensor(self): DCNL DCSP self.test_effective_n_right_shape_python_float(shape=(5, 3, 2))
def test_effective_n_right_shape_scalar_array(self): DCNL DCSP self.test_effective_n_right_shape_python_float(shape=(1,))
def test_effective_n_right_shape_scalar_one(self): DCNL DCSP self.test_effective_n_right_shape_python_float(shape=1, test_shape=(1,))
def matches(self, **kwargs): DCNL DCSP for d in self.buffer: DCNL DCSP  DCSP if self.matcher.matches(d, **kwargs): DCNL DCSP  DCSP  DCSP result = True DCNL DCSP  DCSP  DCSP break DCNL DCSP return result
def matches(self, d, **kwargs): DCNL DCSP result = True DCNL DCSP for k in kwargs: DCNL DCSP  DCSP v = kwargs[k] DCNL DCSP  DCSP dv = d.get(k) DCNL DCSP  DCSP if (not self.match_value(k, dv, v)): DCNL DCSP  DCSP  DCSP result = False DCNL DCSP  DCSP  DCSP break DCNL DCSP return result
def match_value(self, k, dv, v): DCNL DCSP if (type(v) != type(dv)): DCNL DCSP  DCSP result = False DCNL DCSP elif ((type(dv) is not str) or (k not in self._partial_matches)): DCNL DCSP  DCSP result = (v == dv) DCNL DCSP else: DCNL DCSP  DCSP result = (dv.find(v) >= 0) DCNL DCSP return result
def test_autocorr(self): DCNL DCSP assert_almost_equal(autocorr(self.normal_sample), 0, 2) DCNL DCSP y = [((self.normal_sample[(i - 1)] + self.normal_sample[i]) / 2) for i in range(1, len(self.normal_sample))] DCNL DCSP assert_almost_equal(autocorr(y), 0.5, 2)
def test_dic(self): DCNL DCSP x_obs = np.arange(6) DCNL DCSP with pm.Model(): DCNL DCSP  DCSP p = pm.Beta('p', 1.0, 1.0, transform=None) DCNL DCSP  DCSP pm.Binomial('x', 5, p, observed=x_obs) DCNL DCSP  DCSP step = pm.Metropolis() DCNL DCSP  DCSP trace = pm.sample(100, step) DCNL DCSP  DCSP calculated = pm.dic(trace) DCNL DCSP mean_deviance = ((-2) * st.binom.logpmf(np.repeat(np.atleast_2d(x_obs), 100, axis=0), 5, np.repeat(np.atleast_2d(trace['p']), 6, axis=0).T).sum(axis=1).mean()) DCNL DCSP deviance_at_mean = ((-2) * st.binom.logpmf(x_obs, 5, trace['p'].mean()).sum()) DCNL DCSP actual = ((2 * mean_deviance) - deviance_at_mean) DCNL DCSP assert_almost_equal(calculated, actual, decimal=2)
def test_bpic(self): DCNL DCSP x_obs = np.arange(6) DCNL DCSP with pm.Model(): DCNL DCSP  DCSP p = pm.Beta('p', 1.0, 1.0, transform=None) DCNL DCSP  DCSP pm.Binomial('x', 5, p, observed=x_obs) DCNL DCSP  DCSP step = pm.Metropolis() DCNL DCSP  DCSP trace = pm.sample(100, step) DCNL DCSP  DCSP calculated = pm.bpic(trace) DCNL DCSP mean_deviance = ((-2) * st.binom.logpmf(np.repeat(np.atleast_2d(x_obs), 100, axis=0), 5, np.repeat(np.atleast_2d(trace['p']), 6, axis=0).T).sum(axis=1).mean()) DCNL DCSP deviance_at_mean = ((-2) * st.binom.logpmf(x_obs, 5, trace['p'].mean()).sum()) DCNL DCSP actual = ((3 * mean_deviance) - (2 * deviance_at_mean)) DCNL DCSP assert_almost_equal(calculated, actual, decimal=2)
def test_waic(self): DCNL DCSP x_obs = np.arange(6) DCNL DCSP with pm.Model(): DCNL DCSP  DCSP p = pm.Beta('p', 1.0, 1.0, transform=None) DCNL DCSP  DCSP pm.Binomial('x', 5, p, observed=x_obs) DCNL DCSP  DCSP step = pm.Metropolis() DCNL DCSP  DCSP trace = pm.sample(100, step) DCNL DCSP  DCSP calculated_waic = pm.waic(trace) DCNL DCSP log_py = st.binom.logpmf(np.atleast_2d(x_obs).T, 5, trace['p']).T DCNL DCSP lppd_i = np.log(np.mean(np.exp(log_py), axis=0)) DCNL DCSP vars_lpd = np.var(log_py, axis=0) DCNL DCSP waic_i = ((-2) * (lppd_i - vars_lpd)) DCNL DCSP actual_waic_se = np.sqrt((len(waic_i) * np.var(waic_i))) DCNL DCSP actual_waic = np.sum(waic_i) DCNL DCSP assert_almost_equal(calculated_waic.WAIC, actual_waic, decimal=2) DCNL DCSP assert_almost_equal(calculated_waic.WAIC_se, actual_waic_se, decimal=2)
def test_hpd(self): DCNL DCSP interval = hpd(self.normal_sample) DCNL DCSP assert_array_almost_equal(interval, [(-1.96), 1.96], 2)
def test_make_indices(self): DCNL DCSP ind = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)] DCNL DCSP assert_equal(ind, make_indices((2, 3)))
def test_mc_error(self): DCNL DCSP assert mc_error((random(100000) < 0.0025))
def test_quantiles(self): DCNL DCSP q = quantiles(self.normal_sample) DCNL DCSP assert_array_almost_equal(sorted(q.values()), [(-1.96), (-0.67), 0, 0.67, 1.96], 2)
def test_thread_safety(self): DCNL DCSP (aInCtxt, bInCtxt, aDone) = [threading.Event() for _ in range(3)] DCNL DCSP modelA = Model() DCNL DCSP modelB = Model() DCNL DCSP def make_model_a(): DCNL DCSP  DCSP with modelA: DCNL DCSP  DCSP  DCSP aInCtxt.set() DCNL DCSP  DCSP  DCSP bInCtxt.wait() DCNL DCSP  DCSP  DCSP Normal('a', 0, 1) DCNL DCSP  DCSP aDone.set() DCNL DCSP def make_model_b(): DCNL DCSP  DCSP aInCtxt.wait() DCNL DCSP  DCSP with modelB: DCNL DCSP  DCSP  DCSP bInCtxt.set() DCNL DCSP  DCSP  DCSP aDone.wait() DCNL DCSP  DCSP  DCSP Normal('b', 0, 1) DCNL DCSP threadA = threading.Thread(target=make_model_a) DCNL DCSP threadB = threading.Thread(target=make_model_b) DCNL DCSP threadA.start() DCNL DCSP threadB.start() DCNL DCSP threadA.join() DCNL DCSP threadB.join() DCNL DCSP assert ((list(modelA.named_vars), list(modelB.named_vars)) == (['a'], ['b']))
def __call__(self, input): DCNL DCSP (oldinput,) = inputvars(self.tensor) DCNL DCSP return theano.clone(self.tensor, {oldinput: input}, strict=False)
def map(self, dpt): DCNL DCSP apt = np.empty(self.ordering.size, dtype=self.array_dtype) DCNL DCSP for (var, slc, _, _) in self.ordering.vmap: DCNL DCSP  DCSP apt[slc] = dpt[var].ravel() DCNL DCSP return apt
def rmap(self, apt): DCNL DCSP dpt = self.dpt.copy() DCNL DCSP for (var, slc, shp, dtyp) in self.ordering.vmap: DCNL DCSP  DCSP dpt[var] = np.atleast_1d(apt)[slc].reshape(shp).astype(dtyp) DCNL DCSP return dpt
def mapf(self, f): DCNL DCSP return Compose(f, self.rmap)
def fmap(self, list_arrays): DCNL DCSP array = np.empty(self.ordering.size) DCNL DCSP for (list_ind, slc, _, _, _) in self.ordering.vmap: DCNL DCSP  DCSP array[slc] = list_arrays[list_ind].ravel() DCNL DCSP return array
def dmap(self, dpt): DCNL DCSP a_list = copy.copy(self.list_arrays) DCNL DCSP for (list_ind, _, _, _, var) in self.ordering.vmap: DCNL DCSP  DCSP a_list[list_ind] = dpt[var].ravel() DCNL DCSP return a_list
def rmap(self, array): DCNL DCSP a_list = copy.copy(self.list_arrays) DCNL DCSP for (list_ind, slc, shp, dtype, _) in self.ordering.vmap: DCNL DCSP  DCSP a_list[list_ind] = np.atleast_1d(array)[slc].reshape(shp).astype(dtype) DCNL DCSP return a_list
@staticmethod DCNL def competence(var): DCNL DCSP distribution = getattr(var.distribution, 'parent_dist', var.distribution) DCNL DCSP if (isinstance(distribution, pm.Bernoulli) or (var.dtype in pm.bool_types)): DCNL DCSP  DCSP return Competence.COMPATIBLE DCNL DCSP elif (isinstance(distribution, pm.Categorical) and (distribution.k == 2)): DCNL DCSP  DCSP return Competence.COMPATIBLE DCNL DCSP return Competence.INCOMPATIBLE
@staticmethod DCNL def competence(var): DCNL DCSP distribution = getattr(var.distribution, 'parent_dist', var.distribution) DCNL DCSP if (isinstance(distribution, pm.Bernoulli) or (var.dtype in pm.bool_types)): DCNL DCSP  DCSP return Competence.IDEAL DCNL DCSP elif (isinstance(distribution, pm.Categorical) and (distribution.k == 2)): DCNL DCSP  DCSP return Competence.IDEAL DCNL DCSP return Competence.INCOMPATIBLE
@staticmethod DCNL def competence(var): DCNL DCSP distribution = getattr(var.distribution, 'parent_dist', var.distribution) DCNL DCSP if isinstance(distribution, pm.Categorical): DCNL DCSP  DCSP if (distribution.k > 2): DCNL DCSP  DCSP  DCSP return Competence.IDEAL DCNL DCSP  DCSP return Competence.COMPATIBLE DCNL DCSP elif (isinstance(distribution, pm.Bernoulli) or (var.dtype in pm.bool_types)): DCNL DCSP  DCSP return Competence.COMPATIBLE DCNL DCSP return Competence.INCOMPATIBLE
def calc_beta(self): DCNL DCSP low_beta = self.beta DCNL DCSP up_beta = 2.0 DCNL DCSP old_beta = self.beta DCNL DCSP while ((up_beta - low_beta) > 1e-06): DCNL DCSP  DCSP current_beta = ((low_beta + up_beta) / 2.0) DCNL DCSP  DCSP temp = np.exp(((current_beta - self.beta) * (self.likelihoods - self.likelihoods.max()))) DCNL DCSP  DCSP cov_temp = (np.std(temp) / np.mean(temp)) DCNL DCSP  DCSP if (cov_temp > self.coef_variation): DCNL DCSP  DCSP  DCSP up_beta = current_beta DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP low_beta = current_beta DCNL DCSP beta = current_beta DCNL DCSP weights = (temp / np.sum(temp)) DCNL DCSP return (beta, old_beta, weights)
def calc_covariance(self): DCNL DCSP cov = np.cov(self.array_population, aweights=self.weights.ravel(), bias=False, rowvar=0) DCNL DCSP if (np.isnan(cov).any() or np.isinf(cov).any()): DCNL DCSP  DCSP raise ValueError('Sample DCSP covariances DCSP not DCSP valid! DCSP Likely DCSP "n_chains" DCSP is DCSP too DCSP small!') DCNL DCSP return np.atleast_2d(cov)
def select_end_points(self, mtrace): DCNL DCSP array_population = np.zeros((self.n_chains, self.ordering.size)) DCNL DCSP n_steps = len(mtrace) DCNL DCSP for (var, slc, shp, _) in self.ordering.vmap: DCNL DCSP  DCSP slc_population = mtrace.get_values(varname=var, burn=(n_steps - 1), combine=True) DCNL DCSP  DCSP if (len(shp) == 0): DCNL DCSP  DCSP  DCSP array_population[:, slc] = np.atleast_2d(slc_population).T DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP array_population[:, slc] = slc_population DCNL DCSP likelihoods = mtrace.get_values(varname=self.likelihood_name, burn=(n_steps - 1), combine=True) DCNL DCSP population = [self.bij.rmap(row) for row in array_population] DCNL DCSP return (population, array_population, likelihoods)
def get_chain_previous_lpoint(self, mtrace): DCNL DCSP array_population = np.zeros((self.n_chains, self.lordering.size)) DCNL DCSP n_steps = len(mtrace) DCNL DCSP for (_, slc, shp, _, var) in self.lordering.vmap: DCNL DCSP  DCSP slc_population = mtrace.get_values(varname=var, burn=(n_steps - 1), combine=True) DCNL DCSP  DCSP if (len(shp) == 0): DCNL DCSP  DCSP  DCSP array_population[:, slc] = np.atleast_2d(slc_population).T DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP array_population[:, slc] = slc_population DCNL DCSP return [self.lij.rmap(row) for row in array_population[self.resampling_indexes, :]]
def mean_end_points(self): DCNL DCSP return self.bij.rmap(self.array_population.mean(axis=0))
def resample(self): DCNL DCSP parents = np.arange(self.n_chains) DCNL DCSP N_childs = np.zeros(self.n_chains, dtype=int) DCNL DCSP cum_dist = np.cumsum(self.weights) DCNL DCSP u = ((parents + np.random.rand()) / self.n_chains) DCNL DCSP j = 0 DCNL DCSP for i in parents: DCNL DCSP  DCSP while (u[i] > cum_dist[j]): DCNL DCSP  DCSP  DCSP j += 1 DCNL DCSP  DCSP N_childs[j] += 1 DCNL DCSP indx = 0 DCNL DCSP outindx = np.zeros(self.n_chains, dtype=int) DCNL DCSP for i in parents: DCNL DCSP  DCSP if (N_childs[i] > 0): DCNL DCSP  DCSP  DCSP for j in range(indx, (indx + N_childs[i])): DCNL DCSP  DCSP  DCSP  DCSP outindx[j] = parents[i] DCNL DCSP  DCSP indx += N_childs[i] DCNL DCSP return outindx
def __init__(self, potential, logp_dlogp_func): DCNL DCSP self._potential = potential DCNL DCSP self._logp_dlogp_func = logp_dlogp_func DCNL DCSP self._dtype = self._logp_dlogp_func.dtype DCNL DCSP if (self._potential.dtype != self._dtype): DCNL DCSP  DCSP raise ValueError(("dtypes DCSP of DCSP potential DCSP and DCSP logp DCSP function DCSP don't DCSP match." % (self._potential.dtype, self._dtype)))
def compute_state(self, q, p): DCNL DCSP if ((q.dtype != self._dtype) or (p.dtype != self._dtype)): DCNL DCSP  DCSP raise ValueError(('Invalid DCSP dtype. DCSP Must DCSP be DCSP %s' % self._dtype)) DCNL DCSP (logp, dlogp) = self._logp_dlogp_func(q) DCNL DCSP v = self._potential.velocity(p) DCNL DCSP kinetic = self._potential.energy(p, velocity=v) DCNL DCSP energy = (kinetic - logp) DCNL DCSP return State(q, p, v, dlogp, energy)
def step(self, epsilon, state, out=None): DCNL DCSP pot = self._potential DCNL DCSP axpy = linalg.blas.get_blas_funcs('axpy', dtype=self._dtype) DCNL DCSP (q, p, v, q_grad, energy) = state DCNL DCSP if (out is None): DCNL DCSP  DCSP q_new = q.copy() DCNL DCSP  DCSP p_new = p.copy() DCNL DCSP  DCSP v_new = np.empty_like(q) DCNL DCSP  DCSP q_new_grad = np.empty_like(q) DCNL DCSP else: DCNL DCSP  DCSP (q_new, p_new, v_new, q_new_grad, energy) = out DCNL DCSP  DCSP q_new[:] = q DCNL DCSP  DCSP p_new[:] = p DCNL DCSP dt = (0.5 * epsilon) DCNL DCSP axpy(q_grad, p_new, a=dt) DCNL DCSP pot.velocity(p_new, out=v_new) DCNL DCSP axpy(v_new, q_new, a=epsilon) DCNL DCSP logp = self._logp_dlogp_func(q_new, q_new_grad) DCNL DCSP axpy(q_new_grad, p_new, a=dt) DCNL DCSP kinetic = pot.velocity_energy(p_new, v_new) DCNL DCSP energy = (kinetic - logp) DCNL DCSP if (out is not None): DCNL DCSP  DCSP out.energy = energy DCNL DCSP  DCSP return DCNL DCSP else: DCNL DCSP  DCSP return State(q_new, p_new, v_new, q_new_grad, energy)
def __init__(self, vars=None, Emax=1000, target_accept=0.8, gamma=0.05, k=0.75, t0=10, adapt_step_size=True, max_treedepth=10, on_error='summary', early_max_treedepth=8, **kwargs): DCNL DCSP super(NUTS, self).__init__(vars, **kwargs) DCNL DCSP self.Emax = Emax DCNL DCSP self.target_accept = target_accept DCNL DCSP self.gamma = gamma DCNL DCSP self.k = k DCNL DCSP self.t0 = t0 DCNL DCSP self.h_bar = 0 DCNL DCSP self.mu = np.log((self.step_size * 10)) DCNL DCSP self.log_step_size = np.log(self.step_size) DCNL DCSP self.log_step_size_bar = 0 DCNL DCSP self.m = 1 DCNL DCSP self.adapt_step_size = adapt_step_size DCNL DCSP self.max_treedepth = max_treedepth DCNL DCSP self.early_max_treedepth = early_max_treedepth DCNL DCSP self.tune = True DCNL DCSP self.report = NutsReport(on_error, max_treedepth, target_accept)
def astep(self, q0): DCNL DCSP p0 = self.potential.random() DCNL DCSP start = self.integrator.compute_state(q0, p0) DCNL DCSP if (not np.isfinite(start.energy)): DCNL DCSP  DCSP raise ValueError(('Bad DCSP initial DCSP energy: DCSP %s. DCSP The DCSP model DCSP might DCSP be DCSP misspecified.' % start.energy)) DCNL DCSP if (not self.adapt_step_size): DCNL DCSP  DCSP step_size = self.step_size DCNL DCSP elif self.tune: DCNL DCSP  DCSP step_size = np.exp(self.log_step_size) DCNL DCSP else: DCNL DCSP  DCSP step_size = np.exp(self.log_step_size_bar) DCNL DCSP if (self.tune and (self.m < 200)): DCNL DCSP  DCSP max_treedepth = self.early_max_treedepth DCNL DCSP else: DCNL DCSP  DCSP max_treedepth = self.max_treedepth DCNL DCSP tree = _Tree(len(p0), self.integrator, start, step_size, self.Emax) DCNL DCSP for _ in range(max_treedepth): DCNL DCSP  DCSP direction = ((logbern(np.log(0.5)) * 2) - 1) DCNL DCSP  DCSP (diverging_info, turning) = tree.extend(direction) DCNL DCSP  DCSP (q, q_grad) = (tree.proposal.q, tree.proposal.q_grad) DCNL DCSP  DCSP if (diverging_info or turning): DCNL DCSP  DCSP  DCSP if diverging_info: DCNL DCSP  DCSP  DCSP  DCSP self.report._add_divergence(self.tune, *diverging_info) DCNL DCSP  DCSP  DCSP break DCNL DCSP w = (1.0 / (self.m + self.t0)) DCNL DCSP self.h_bar = (((1 - w) * self.h_bar) + (w * (self.target_accept - ((tree.accept_sum * 1.0) / tree.n_proposals)))) DCNL DCSP if self.tune: DCNL DCSP  DCSP self.log_step_size = (self.mu - ((self.h_bar * np.sqrt(self.m)) / self.gamma)) DCNL DCSP  DCSP mk = (self.m ** (- self.k)) DCNL DCSP  DCSP self.log_step_size_bar = ((mk * self.log_step_size) + ((1 - mk) * self.log_step_size_bar)) DCNL DCSP self.m += 1 DCNL DCSP if self.tune: DCNL DCSP  DCSP self.potential.adapt(q, q_grad) DCNL DCSP stats = {'step_size': step_size, 'tune': self.tune, 'step_size_bar': np.exp(self.log_step_size_bar), 'diverging': bool(diverging_info)} DCNL DCSP stats.update(tree.stats()) DCNL DCSP return (q, [stats])
@staticmethod DCNL def competence(var): DCNL DCSP if (var.dtype in continuous_types): DCNL DCSP  DCSP return Competence.IDEAL DCNL DCSP return Competence.INCOMPATIBLE
def __init__(self, ndim, integrator, start, step_size, Emax): DCNL DCSP self.ndim = ndim DCNL DCSP self.integrator = integrator DCNL DCSP self.start = start DCNL DCSP self.step_size = step_size DCNL DCSP self.Emax = Emax DCNL DCSP self.start_energy = np.array(start.energy) DCNL DCSP self.left = self.right = start DCNL DCSP self.proposal = Proposal(start.q, start.q_grad, start.energy, 1.0) DCNL DCSP self.depth = 0 DCNL DCSP self.log_size = 0 DCNL DCSP self.accept_sum = 0 DCNL DCSP self.n_proposals = 0 DCNL DCSP self.p_sum = start.p.copy() DCNL DCSP self.max_energy_change = 0
def extend(self, direction): DCNL DCSP if (direction > 0): DCNL DCSP  DCSP (tree, diverging, turning) = self._build_subtree(self.right, self.depth, floatX(np.asarray(self.step_size))) DCNL DCSP  DCSP self.right = tree.right DCNL DCSP else: DCNL DCSP  DCSP (tree, diverging, turning) = self._build_subtree(self.left, self.depth, floatX(np.asarray((- self.step_size)))) DCNL DCSP  DCSP self.left = tree.right DCNL DCSP self.depth += 1 DCNL DCSP self.accept_sum += tree.accept_sum DCNL DCSP self.n_proposals += tree.n_proposals DCNL DCSP if (diverging or turning): DCNL DCSP  DCSP return (diverging, turning) DCNL DCSP (size1, size2) = (self.log_size, tree.log_size) DCNL DCSP if logbern((size2 - size1)): DCNL DCSP  DCSP self.proposal = tree.proposal DCNL DCSP self.log_size = np.logaddexp(self.log_size, tree.log_size) DCNL DCSP self.p_sum[:] += tree.p_sum DCNL DCSP (left, right) = (self.left, self.right) DCNL DCSP p_sum = self.p_sum DCNL DCSP turning = ((p_sum.dot(left.v) <= 0) or (p_sum.dot(right.v) <= 0)) DCNL DCSP return (diverging, turning)
def _single_step(self, left, epsilon): DCNL DCSP try: DCNL DCSP  DCSP right = self.integrator.step(epsilon, left) DCNL DCSP except linalg.LinAlgError as err: DCNL DCSP  DCSP error_msg = 'LinAlgError DCSP during DCSP leapfrog DCSP step.' DCNL DCSP  DCSP error = err DCNL DCSP except ValueError as err: DCNL DCSP  DCSP scipy_msg = 'array DCSP must DCSP not DCSP contain DCSP infs DCSP or DCSP nans' DCNL DCSP  DCSP if ((len(err.args) > 0) and (scipy_msg in err.args[0].lower())): DCNL DCSP  DCSP  DCSP error_msg = 'Infs DCSP or DCSP nans DCSP in DCSP scipy.linalg DCSP during DCSP leapfrog DCSP step.' DCNL DCSP  DCSP  DCSP error = err DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP energy_change = (right.energy - self.start_energy) DCNL DCSP  DCSP if np.isnan(energy_change): DCNL DCSP  DCSP  DCSP energy_change = np.inf DCNL DCSP  DCSP if (np.abs(energy_change) > np.abs(self.max_energy_change)): DCNL DCSP  DCSP  DCSP self.max_energy_change = energy_change DCNL DCSP  DCSP if (np.abs(energy_change) < self.Emax): DCNL DCSP  DCSP  DCSP p_accept = min(1, np.exp((- energy_change))) DCNL DCSP  DCSP  DCSP log_size = (- energy_change) DCNL DCSP  DCSP  DCSP proposal = Proposal(right.q, right.q_grad, right.energy, p_accept) DCNL DCSP  DCSP  DCSP tree = Subtree(right, right, right.p, proposal, log_size, p_accept, 1) DCNL DCSP  DCSP  DCSP return (tree, False, False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP error_msg = ('Energy DCSP change DCSP in DCSP leapfrog DCSP step DCSP is DCSP too DCSP large: DCSP %s. DCSP ' % energy_change) DCNL DCSP  DCSP  DCSP error = None DCNL DCSP tree = Subtree(None, None, None, None, (- np.inf), 0, 1) DCNL DCSP return (tree, (error_msg, error, left), False)
def _finalize(self, strace): DCNL DCSP self._chain_id = strace.chain DCNL DCSP if strace.supports_sampler_stats: DCNL DCSP  DCSP tuning = strace.get_sampler_stats('tune') DCNL DCSP  DCSP if (tuning.ndim == 2): DCNL DCSP  DCSP  DCSP tuning = np.any(tuning, axis=(-1)) DCNL DCSP  DCSP accept = strace.get_sampler_stats('mean_tree_accept') DCNL DCSP  DCSP if (accept.ndim == 2): DCNL DCSP  DCSP  DCSP accept = np.mean(accept, axis=(-1)) DCNL DCSP  DCSP depth = strace.get_sampler_stats('depth') DCNL DCSP  DCSP if (depth.ndim == 2): DCNL DCSP  DCSP  DCSP depth = np.max(depth, axis=(-1)) DCNL DCSP  DCSP self._check_len(tuning) DCNL DCSP  DCSP self._check_depth(depth[(~ tuning)]) DCNL DCSP  DCSP self._check_accept(accept[(~ tuning)]) DCNL DCSP  DCSP self._check_divergence()
def __init__(self, vars=None, scaling=None, step_scale=0.25, is_cov=False, model=None, blocked=True, potential=None, integrator='leapfrog', dtype=None, **theano_kwargs): DCNL DCSP model = modelcontext(model) DCNL DCSP if (vars is None): DCNL DCSP  DCSP vars = model.cont_vars DCNL DCSP vars = inputvars(vars) DCNL DCSP super(BaseHMC, self).__init__(vars, blocked=blocked, model=model, dtype=dtype, **theano_kwargs) DCNL DCSP size = self._logp_dlogp_func.size DCNL DCSP if ((scaling is None) and (potential is None)): DCNL DCSP  DCSP mean = floatX(np.zeros(size)) DCNL DCSP  DCSP var = floatX(np.ones(size)) DCNL DCSP  DCSP potential = QuadPotentialDiagAdapt(size, mean, var, 10) DCNL DCSP if isinstance(scaling, dict): DCNL DCSP  DCSP point = Point(scaling, model=model) DCNL DCSP  DCSP scaling = guess_scaling(point, model=model, vars=vars) DCNL DCSP if ((scaling is not None) and (potential is not None)): DCNL DCSP  DCSP raise ValueError('Can DCSP not DCSP specify DCSP both DCSP potential DCSP and DCSP scaling.') DCNL DCSP self.step_size = (step_scale / (size ** 0.25)) DCNL DCSP if (potential is not None): DCNL DCSP  DCSP self.potential = potential DCNL DCSP else: DCNL DCSP  DCSP self.potential = quad_potential(scaling, is_cov) DCNL DCSP self.integrator = integration.CpuLeapfrogIntegrator(self.potential, self._logp_dlogp_func)
def velocity(self, x, out=None): DCNL DCSP raise NotImplementedError('Abstract DCSP method')
def adapt(self, sample, grad): DCNL DCSP pass
def __init__(self, n, initial_mean, initial_diag=None, initial_weight=0, adaptation_window=100, dtype=None): DCNL DCSP if ((initial_diag is not None) and (initial_diag.ndim != 1)): DCNL DCSP  DCSP raise ValueError('Initial DCSP diagonal DCSP must DCSP be DCSP one-dimensional.') DCNL DCSP if (initial_mean.ndim != 1): DCNL DCSP  DCSP raise ValueError('Initial DCSP mean DCSP must DCSP be DCSP one-dimensional.') DCNL DCSP if ((initial_diag is not None) and (len(initial_diag) != n)): DCNL DCSP  DCSP raise ValueError(('Wrong DCSP shape DCSP for DCSP initial_diag: DCSP expected DCSP %s DCSP got DCSP %s' % (n, len(initial_diag)))) DCNL DCSP if (len(initial_mean) != n): DCNL DCSP  DCSP raise ValueError(('Wrong DCSP shape DCSP for DCSP initial_mean: DCSP expected DCSP %s DCSP got DCSP %s' % (n, len(initial_mean)))) DCNL DCSP if (dtype is None): DCNL DCSP  DCSP dtype = theano.config.floatX DCNL DCSP if (initial_diag is None): DCNL DCSP  DCSP initial_diag = np.ones(n, dtype=dtype) DCNL DCSP  DCSP initial_weight = 1 DCNL DCSP self.dtype = dtype DCNL DCSP self._n = n DCNL DCSP self._var = np.array(initial_diag, dtype=self.dtype, copy=True) DCNL DCSP self._var_theano = theano.shared(self._var) DCNL DCSP self._stds = np.sqrt(initial_diag) DCNL DCSP self._inv_stds = (floatX(1.0) / self._stds) DCNL DCSP self._foreground_var = _WeightedVariance(self._n, initial_mean, initial_diag, initial_weight, self.dtype) DCNL DCSP self._background_var = _WeightedVariance(self._n, dtype=self.dtype) DCNL DCSP self._n_samples = 0 DCNL DCSP self.adaptation_window = adaptation_window
def velocity(self, x, out=None): DCNL DCSP return np.multiply(self._var, x, out=out)
def energy(self, x, velocity=None): DCNL DCSP if (velocity is not None): DCNL DCSP  DCSP return (0.5 * x.dot(velocity)) DCNL DCSP return (0.5 * x.dot((self._var * x)))
def velocity_energy(self, x, v_out): DCNL DCSP self.velocity(x, out=v_out) DCNL DCSP return (0.5 * np.dot(x, v_out))
def random(self): DCNL DCSP vals = normal(size=self._n).astype(self.dtype) DCNL DCSP return (self._inv_stds * vals)
def adapt(self, sample, grad): DCNL DCSP window = self.adaptation_window DCNL DCSP self._foreground_var.add_sample(sample, weight=1) DCNL DCSP self._background_var.add_sample(sample, weight=1) DCNL DCSP self._update_from_weightvar(self._foreground_var) DCNL DCSP if ((self._n_samples > 0) and ((self._n_samples % window) == 0)): DCNL DCSP  DCSP self._foreground_var = self._background_var DCNL DCSP  DCSP self._background_var = _WeightedVariance(self._n, dtype=self.dtype) DCNL DCSP self._n_samples += 1
def adapt(self, sample, grad): DCNL DCSP self._grads1[:] += (grad ** 2) DCNL DCSP self._grads2[:] += (grad ** 2) DCNL DCSP self._ngrads1 += 1 DCNL DCSP self._ngrads2 += 1 DCNL DCSP if (self._n_samples <= 150): DCNL DCSP  DCSP super().adapt(sample, grad) DCNL DCSP else: DCNL DCSP  DCSP self._update((self._ngrads1 / self._grads1)) DCNL DCSP if ((self._n_samples > 100) and ((self._n_samples % 100) == 50)): DCNL DCSP  DCSP self._ngrads1 = self._ngrads2 DCNL DCSP  DCSP self._ngrads2 = 0 DCNL DCSP  DCSP self._grads1[:] = self._grads2 DCNL DCSP  DCSP self._grads2[:] = 0
def __init__(self, v, dtype=None): DCNL DCSP if (dtype is None): DCNL DCSP  DCSP dtype = theano.config.floatX DCNL DCSP self.dtype = dtype DCNL DCSP v = v.astype(self.dtype) DCNL DCSP s = (v ** 0.5) DCNL DCSP self.s = s DCNL DCSP self.inv_s = (1.0 / s) DCNL DCSP self.v = v
def velocity(self, x, out=None): DCNL DCSP if (out is not None): DCNL DCSP  DCSP np.multiply(x, self.v, out=out) DCNL DCSP  DCSP return DCNL DCSP return (self.v * x)
def random(self): DCNL DCSP return (floatX(normal(size=self.s.shape)) * self.inv_s)
def energy(self, x, velocity=None): DCNL DCSP if (velocity is not None): DCNL DCSP  DCSP return (0.5 * np.dot(x, velocity)) DCNL DCSP return (0.5 * x.dot((self.v * x)))
def velocity_energy(self, x, v_out): DCNL DCSP np.multiply(x, self.v, out=v_out) DCNL DCSP return (0.5 * np.dot(x, v_out))
def __init__(self, A, dtype=None): DCNL DCSP if (dtype is None): DCNL DCSP  DCSP dtype = theano.config.floatX DCNL DCSP self.dtype = dtype DCNL DCSP self.L = floatX(scipy.linalg.cholesky(A, lower=True))
def velocity(self, x, out=None): DCNL DCSP vel = scipy.linalg.cho_solve((self.L, True), x) DCNL DCSP if (out is None): DCNL DCSP  DCSP return vel DCNL DCSP out[:] = vel
def random(self): DCNL DCSP n = floatX(normal(size=self.L.shape[0])) DCNL DCSP return np.dot(self.L, n)
def energy(self, x, velocity=None): DCNL DCSP if (velocity is None): DCNL DCSP  DCSP velocity = self.velocity(x) DCNL DCSP return (0.5 * x.dot(velocity))
def velocity_energy(self, x, v_out): DCNL DCSP self.velocity(x, out=v_out) DCNL DCSP return (0.5 * np.dot(x, v_out))
def __init__(self, A, dtype=None): DCNL DCSP if (dtype is None): DCNL DCSP  DCSP dtype = theano.config.floatX DCNL DCSP self.dtype = dtype DCNL DCSP self.A = A.astype(self.dtype) DCNL DCSP self.L = scipy.linalg.cholesky(A, lower=True)
def velocity(self, x, out=None): DCNL DCSP return np.dot(self.A, x, out=out)
def random(self): DCNL DCSP n = floatX(normal(size=self.L.shape[0])) DCNL DCSP return scipy.linalg.solve_triangular(self.L.T, n)
def energy(self, x, velocity=None): DCNL DCSP if (velocity is None): DCNL DCSP  DCSP velocity = self.velocity(x) DCNL DCSP return (0.5 * x.dot(velocity))
def velocity_energy(self, x, v_out): DCNL DCSP self.velocity(x, out=v_out) DCNL DCSP return (0.5 * np.dot(x, v_out))
def __init__(self, vars=None, path_length=2.0, step_rand=unif, **kwargs): DCNL DCSP super(HamiltonianMC, self).__init__(vars, **kwargs) DCNL DCSP self.path_length = path_length DCNL DCSP self.step_rand = step_rand
def astep(self, q0): DCNL DCSP e = floatX(self.step_rand(self.step_size)) DCNL DCSP n_steps = int((self.path_length / e)) DCNL DCSP p0 = self.potential.random() DCNL DCSP start = self.integrator.compute_state(q0, p0) DCNL DCSP if (not np.isfinite(start.energy)): DCNL DCSP  DCSP raise ValueError(('Bad DCSP initial DCSP energy: DCSP %s. DCSP The DCSP model DCSP might DCSP be DCSP misspecified.' % start.energy)) DCNL DCSP state = start DCNL DCSP for _ in range(n_steps): DCNL DCSP  DCSP state = self.integrator.step(e, state) DCNL DCSP energy_change = (start.energy - state.energy) DCNL DCSP return metrop_select(energy_change, state.q, start.q)[0]
@staticmethod DCNL def competence(var): DCNL DCSP if (var.dtype in discrete_types): DCNL DCSP  DCSP return Competence.INCOMPATIBLE DCNL DCSP return Competence.COMPATIBLE
def _initialize_values(self): DCNL DCSP raise NotImplementedError
def training_complete(self): DCNL DCSP return (self.expected_iter == self.t)
def astep(self, q0): DCNL DCSP if hasattr(self, 'minibatch_tensors'): DCNL DCSP  DCSP return (q0 + self.training_fn(q0, *next(self.minibatches))) DCNL DCSP else: DCNL DCSP  DCSP return (q0 + self.training_fn(q0))
def __init__(self, vars=None, B=None, **kwargs): DCNL DCSP self.B = B DCNL DCSP super(SGFS, self).__init__(vars, **kwargs)
def __init__(self, vars, shared, blocked=True): DCNL DCSP self.vars = vars DCNL DCSP self.ordering = ArrayOrdering(vars) DCNL DCSP self.shared = {str(var): shared for (var, shared) in shared.items()} DCNL DCSP self.blocked = blocked
def astep(self, q0, logp): DCNL DCSP chol = draw_values([self.prior_chol])[0] DCNL DCSP nu = np.dot(chol, nr.randn(chol.shape[0])) DCNL DCSP y = (logp(q0) - nr.standard_exponential()) DCNL DCSP theta = nr.uniform(0, (2 * np.pi)) DCNL DCSP theta_max = theta DCNL DCSP theta_min = (theta - (2 * np.pi)) DCNL DCSP q_new = ((q0 * np.cos(theta)) + (nu * np.sin(theta))) DCNL DCSP while (logp(q_new) <= y): DCNL DCSP  DCSP if (theta < 0): DCNL DCSP  DCSP  DCSP theta_min = theta DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP theta_max = theta DCNL DCSP  DCSP theta = nr.uniform(theta_min, theta_max) DCNL DCSP  DCSP q_new = ((q0 * np.cos(theta)) + (nu * np.sin(theta))) DCNL DCSP return q_new
def updates(self, obj_n_mc=None, tf_n_mc=None, obj_optimizer=adagrad_window, test_optimizer=adagrad_window, more_obj_params=None, more_tf_params=None, more_updates=None, more_replacements=None, total_grad_norm_constraint=None): DCNL DCSP if (more_updates is None): DCNL DCSP  DCSP more_updates = dict() DCNL DCSP resulting_updates = ObjectiveUpdates() DCNL DCSP if self.test_params: DCNL DCSP  DCSP self.add_test_updates(resulting_updates, tf_n_mc=tf_n_mc, test_optimizer=test_optimizer, more_tf_params=more_tf_params, more_replacements=more_replacements, total_grad_norm_constraint=total_grad_norm_constraint) DCNL DCSP else: DCNL DCSP  DCSP if (tf_n_mc is not None): DCNL DCSP  DCSP  DCSP _warn_not_used('tf_n_mc', self.op) DCNL DCSP  DCSP if more_tf_params: DCNL DCSP  DCSP  DCSP _warn_not_used('more_tf_params', self.op) DCNL DCSP self.add_obj_updates(resulting_updates, obj_n_mc=obj_n_mc, obj_optimizer=obj_optimizer, more_obj_params=more_obj_params, more_replacements=more_replacements, total_grad_norm_constraint=total_grad_norm_constraint) DCNL DCSP resulting_updates.update(more_updates) DCNL DCSP return resulting_updates
@memoize DCNL @change_flags(compute_test_value='off') DCNL def step_function(self, obj_n_mc=None, tf_n_mc=None, obj_optimizer=adagrad_window, test_optimizer=adagrad_window, more_obj_params=None, more_tf_params=None, more_updates=None, more_replacements=None, total_grad_norm_constraint=None, score=False, fn_kwargs=None): DCNL DCSP if (fn_kwargs is None): DCNL DCSP  DCSP fn_kwargs = {} DCNL DCSP if (score and (not self.op.RETURNS_LOSS)): DCNL DCSP  DCSP raise NotImplementedError(('%s DCSP does DCSP not DCSP have DCSP loss' % self.op)) DCNL DCSP updates = self.updates(obj_n_mc=obj_n_mc, tf_n_mc=tf_n_mc, obj_optimizer=obj_optimizer, test_optimizer=test_optimizer, more_obj_params=more_obj_params, more_tf_params=more_tf_params, more_updates=more_updates, more_replacements=more_replacements, total_grad_norm_constraint=total_grad_norm_constraint) DCNL DCSP if score: DCNL DCSP  DCSP step_fn = theano.function([], updates.loss, updates=updates, **fn_kwargs) DCNL DCSP else: DCNL DCSP  DCSP step_fn = theano.function([], None, updates=updates, **fn_kwargs) DCNL DCSP return step_fn
@memoize DCNL @change_flags(compute_test_value='off') DCNL def score_function(self, sc_n_mc=None, more_replacements=None, fn_kwargs=None): DCNL DCSP if (fn_kwargs is None): DCNL DCSP  DCSP fn_kwargs = {} DCNL DCSP if (not self.op.RETURNS_LOSS): DCNL DCSP  DCSP raise NotImplementedError(('%s DCSP does DCSP not DCSP have DCSP loss' % self.op)) DCNL DCSP if (more_replacements is None): DCNL DCSP  DCSP more_replacements = {} DCNL DCSP loss = theano.clone(self(sc_n_mc), more_replacements, strict=False) DCNL DCSP return theano.function([], loss, **fn_kwargs)
def apply(self, f): DCNL DCSP raise NotImplementedError
def create_shared_params(self, dim): DCNL DCSP pass
def _setup(self, dim): DCNL DCSP pass
def seed(self, random_seed=None): DCNL DCSP self._seed = random_seed DCNL DCSP self._rng.seed(random_seed)
def check_model(self, model, **kwargs): DCNL DCSP vars_ = [var for var in model.vars if (not isinstance(var, pm.model.ObservedRV))] DCNL DCSP if any([(var.dtype in pm.discrete_types) for var in vars_]): DCNL DCSP  DCSP raise ValueError('Model DCSP should DCSP not DCSP include DCSP discrete DCSP RVs')
def construct_replacements(self, include=None, exclude=None, more_replacements=None): DCNL DCSP if ((include is not None) and (exclude is not None)): DCNL DCSP  DCSP raise ValueError('Only DCSP one DCSP parameter DCSP is DCSP supported DCSP {include|exclude}, DCSP got DCSP two') DCNL DCSP _replacements = dict() DCNL DCSP _replacements.update(self.global_flat_view.replacements) DCNL DCSP _replacements.update(self.local_flat_view.replacements) DCNL DCSP if (include is not None): DCNL DCSP  DCSP replacements = {k: v for (k, v) in _replacements.items() if (k in include)} DCNL DCSP elif (exclude is not None): DCNL DCSP  DCSP replacements = {k: v for (k, v) in _replacements.items() if (k not in exclude)} DCNL DCSP else: DCNL DCSP  DCSP replacements = _replacements DCNL DCSP if (more_replacements is not None): DCNL DCSP  DCSP replacements.update(more_replacements) DCNL DCSP return replacements
def to_flat_input(self, node): DCNL DCSP replacements = self.construct_replacements() DCNL DCSP return theano.clone(node, replacements, strict=False)
@change_flags(compute_test_value='off') DCNL def apply_replacements(self, node, deterministic=False, include=None, exclude=None, more_replacements=None): DCNL DCSP replacements = self.construct_replacements(include, exclude, more_replacements) DCNL DCSP node_in = node DCNL DCSP node = theano.clone(node, replacements, strict=False) DCNL DCSP posterior_glob = self.random_global(deterministic=deterministic) DCNL DCSP posterior_loc = self.random_local(deterministic=deterministic) DCNL DCSP out = theano.clone(node, {self.global_input: posterior_glob, self.local_input: posterior_loc}, strict=False) DCNL DCSP try_to_set_test_value(node_in, out, None) DCNL DCSP return out
@change_flags(compute_test_value='off') DCNL def sample_node(self, node, size=100, more_replacements=None): DCNL DCSP node_in = node DCNL DCSP if (more_replacements is not None): DCNL DCSP  DCSP node = theano.clone(node, more_replacements, strict=False) DCNL DCSP if (size is None): DCNL DCSP  DCSP size = 1 DCNL DCSP nodes = self.sample_over_posterior(node) DCNL DCSP nodes = self.set_size_and_deterministic(nodes, size, 0) DCNL DCSP try_to_set_test_value(node_in, nodes, size) DCNL DCSP return nodes
def scale_grad(self, inp): DCNL DCSP return theano.gradient.grad_scale(inp, self.cost_part_grad_scale)
def random_local(self, size=None, deterministic=False): DCNL DCSP return self._random_part('local', size=size, deterministic=deterministic)
def random_global(self, size=None, deterministic=False): DCNL DCSP return self._random_part('global', size=size, deterministic=deterministic)
def sample(self, draws=500, include_transformed=True): DCNL DCSP vars_sampled = get_default_varnames(self.model.unobserved_RVs, include_transformed=include_transformed) DCNL DCSP samples = self.sample_dict_fn(draws) DCNL DCSP def points(): DCNL DCSP  DCSP for i in range(draws): DCNL DCSP  DCSP  DCSP (yield {name: samples[name][i] for name in samples.keys()}) DCNL DCSP trace = pm.sampling.NDArray(model=self.model, vars=vars_sampled) DCNL DCSP try: DCNL DCSP  DCSP trace.setup(draws=draws, chain=0) DCNL DCSP  DCSP for point in points(): DCNL DCSP  DCSP  DCSP trace.record(point) DCNL DCSP finally: DCNL DCSP  DCSP trace.close() DCNL DCSP return pm.sampling.MultiTrace([trace])
@node_property DCNL def normalizing_constant(self): DCNL DCSP t = self.to_flat_input(tt.max([v.scaling for v in self.model.basic_RVs])) DCNL DCSP t = theano.clone(t, {self.global_input: self.symbolic_random_global_matrix[0], self.local_input: self.symbolic_random_local_matrix[0]}) DCNL DCSP t = self.set_size_and_deterministic(t, 1, 1) DCNL DCSP t = tt.switch(self._scale_cost_to_minibatch, t, tt.constant(1, dtype=t.dtype)) DCNL DCSP return pm.floatX(t)
@node_property DCNL def logq(self): DCNL DCSP return self.symbolic_log_q_W.mean(0)
def view_global(self, space, name, reshape=True): DCNL DCSP return self._view_part('global', space, name, reshape)
def view_local(self, space, name, reshape=True): DCNL DCSP return self._view_part('local', space, name, reshape)
@node_property DCNL def symbolic_log_q_W_global(self): DCNL DCSP mu = self.scale_grad(self.mean) DCNL DCSP rho = self.scale_grad(self.rho) DCNL DCSP z = self.symbolic_random_global_matrix DCNL DCSP logq = log_normal(z, mu, rho=rho) DCNL DCSP return logq.sum(1)
@node_property DCNL def symbolic_log_q_W_global(self): DCNL DCSP mu = self.scale_grad(self.mean) DCNL DCSP L = self.scale_grad(self.L) DCNL DCSP z = self.symbolic_random_global_matrix DCNL DCSP return pm.MvNormal.dist(mu=mu, chol=L).logp(z)
@classmethod DCNL def from_mean_field(cls, mean_field, gpu_compat=False): DCNL DCSP full_rank = object.__new__(cls) DCNL DCSP full_rank.gpu_compat = gpu_compat DCNL DCSP full_rank.__dict__.update(mean_field.__dict__) DCNL DCSP full_rank.shared_params = full_rank.create_shared_params() DCNL DCSP full_rank.shared_params['mu'].set_value(mean_field.shared_params['mu'].get_value()) DCNL DCSP rho = mean_field.shared_params['rho'].get_value() DCNL DCSP n = full_rank.global_size DCNL DCSP L_tril = np.diag(np.log1p(np.exp(rho)))[np.tril_indices(n)].astype(theano.config.floatX) DCNL DCSP full_rank.shared_params['L_tril'].set_value(L_tril) DCNL DCSP return full_rank
@property DCNL def histogram(self): DCNL DCSP return self.shared_params['histogram']
@classmethod DCNL def from_noise(cls, size, jitter=0.01, local_rv=None, start=None, model=None, random_seed=None, **kwargs): DCNL DCSP hist = cls(None, local_rv=local_rv, model=model, random_seed=random_seed, **kwargs) DCNL DCSP if (start is None): DCNL DCSP  DCSP start = hist.model.test_point DCNL DCSP else: DCNL DCSP  DCSP start_ = hist.model.test_point.copy() DCNL DCSP  DCSP update_start_vals(start_, start, hist.model) DCNL DCSP  DCSP start = start_ DCNL DCSP start = pm.floatX(hist.gbij.map(start)) DCNL DCSP x0 = np.tile(start, (size, 1)) DCNL DCSP x0 += pm.floatX(np.random.normal(0, jitter, x0.shape)) DCNL DCSP hist.histogram.set_value(x0) DCNL DCSP return hist
def fit(self, n=10000, score=None, callbacks=None, progressbar=True, **kwargs): DCNL DCSP if (callbacks is None): DCNL DCSP  DCSP callbacks = [] DCNL DCSP score = self._maybe_score(score) DCNL DCSP step_func = self.objective.step_function(score=score, **kwargs) DCNL DCSP progress = tqdm.trange(n, disable=(not progressbar)) DCNL DCSP if score: DCNL DCSP  DCSP self._iterate_with_loss(n, step_func, progress, callbacks) DCNL DCSP else: DCNL DCSP  DCSP self._iterate_without_loss(n, step_func, progress, callbacks) DCNL DCSP self.approx.hist = self.hist DCNL DCSP return self.approx
@classmethod DCNL def from_mean_field(cls, mean_field): DCNL DCSP if (not isinstance(mean_field, MeanField)): DCNL DCSP  DCSP raise TypeError(('Expected DCSP MeanField, DCSP got DCSP %r' % mean_field)) DCNL DCSP inference = object.__new__(cls) DCNL DCSP Inference.__init__(inference, KL, mean_field, None) DCNL DCSP return inference
@classmethod DCNL def from_full_rank(cls, full_rank): DCNL DCSP if (not isinstance(full_rank, FullRank)): DCNL DCSP  DCSP raise TypeError(('Expected DCSP FullRank, DCSP got DCSP %r' % full_rank)) DCNL DCSP inference = object.__new__(cls) DCNL DCSP Inference.__init__(inference, KL, full_rank, None) DCNL DCSP return inference
@classmethod DCNL def from_mean_field(cls, mean_field, gpu_compat=False): DCNL DCSP full_rank = FullRank.from_mean_field(mean_field, gpu_compat) DCNL DCSP inference = object.__new__(cls) DCNL DCSP Inference.__init__(inference, KL, full_rank, None) DCNL DCSP return inference
@classmethod DCNL def from_advi(cls, advi, gpu_compat=False): DCNL DCSP inference = cls.from_mean_field(advi.approx, gpu_compat) DCNL DCSP inference.hist = advi.hist DCNL DCSP return inference
def fit(self, n=10000, score=None, callbacks=None, progressbar=True, obj_n_mc=300, **kwargs): DCNL DCSP return super(ASVGD, self).fit(n=n, score=score, callbacks=callbacks, progressbar=progressbar, obj_n_mc=obj_n_mc, **kwargs)
@classmethod DCNL def from_flow(cls, flow): DCNL DCSP inference = object.__new__(cls) DCNL DCSP Inference.__init__(inference, KL, flow, None) DCNL DCSP return inference
@classmethod DCNL def get_context(cls): DCNL DCSP try: DCNL DCSP  DCSP return cls.get_contexts()[(-1)] DCNL DCSP except IndexError: DCNL DCSP  DCSP raise TypeError('No DCSP context DCSP on DCSP context DCSP stack')
@property DCNL def logp(self): DCNL DCSP return self.model.fn(self.logpt)
def dlogp(self, vars=None): DCNL DCSP return self.model.fn(gradient(self.logpt, vars))
def d2logp(self, vars=None): DCNL DCSP return self.model.fn(hessian(self.logpt, vars))
@property DCNL def fastlogp(self): DCNL DCSP return self.model.fastfn(self.logpt)
def fastdlogp(self, vars=None): DCNL DCSP return self.model.fastfn(gradient(self.logpt, vars))
def fastd2logp(self, vars=None): DCNL DCSP return self.model.fastfn(hessian(self.logpt, vars))
@property DCNL def logpt(self): DCNL DCSP if (getattr(self, 'total_size', None) is not None): DCNL DCSP  DCSP logp = (tt.sum(self.logp_elemwiset) * self.scaling) DCNL DCSP else: DCNL DCSP  DCSP logp = tt.sum(self.logp_elemwiset) DCNL DCSP if (self.name is not None): DCNL DCSP  DCSP logp.name = ('__logp_%s' % self.name) DCNL DCSP return logp
@property DCNL def profile(self): DCNL DCSP return self._theano_function.profile
def dict_to_array(self, point): DCNL DCSP array = np.empty(self.size, dtype=self.dtype) DCNL DCSP for varmap in self._ordering.vmap: DCNL DCSP  DCSP array[varmap.slc] = point[varmap.var].ravel().astype(self.dtype) DCNL DCSP return array
def array_to_dict(self, array): DCNL DCSP if (array.shape != (self.size,)): DCNL DCSP  DCSP raise ValueError(('Array DCSP should DCSP have DCSP shape DCSP (%s,) DCSP but DCSP has DCSP %s' % (self.size, array.shape))) DCNL DCSP if (array.dtype != self.dtype): DCNL DCSP  DCSP raise ValueError(('Array DCSP has DCSP invalid DCSP dtype. DCSP Should DCSP be DCSP %s DCSP but DCSP is DCSP %s' % (self._dtype, self.dtype))) DCNL DCSP point = {} DCNL DCSP for varmap in self._ordering.vmap: DCNL DCSP  DCSP data = array[varmap.slc].reshape(varmap.shp) DCNL DCSP  DCSP point[varmap.var] = data.astype(varmap.dtyp) DCNL DCSP return point
def array_to_full_dict(self, array): DCNL DCSP point = self.array_to_dict(array) DCNL DCSP for (name, var) in self._extra_vars_shared.items(): DCNL DCSP  DCSP point[name] = var.get_value() DCNL DCSP return point
@property DCNL def logpt(self): DCNL DCSP with self: DCNL DCSP  DCSP factors = ([var.logpt for var in self.basic_RVs] + self.potentials) DCNL DCSP  DCSP logp = tt.add(*map(tt.sum, factors)) DCNL DCSP  DCSP logp.name = '__logp' DCNL DCSP  DCSP return logp
@property DCNL def varlogpt(self): DCNL DCSP with self: DCNL DCSP  DCSP factors = [var.logpt for var in self.vars] DCNL DCSP  DCSP return tt.add(*map(tt.sum, factors))
@property DCNL def vars(self): DCNL DCSP return self.free_RVs
@property DCNL def basic_RVs(self): DCNL DCSP return (self.free_RVs + self.observed_RVs)
@property DCNL def unobserved_RVs(self): DCNL DCSP return (self.vars + self.deterministics)
@property DCNL def test_point(self): DCNL DCSP return Point(((var, var.tag.test_value) for var in self.vars), model=self)
@property DCNL def disc_vars(self): DCNL DCSP return list(typefilter(self.vars, discrete_types))
@property DCNL def cont_vars(self): DCNL DCSP return list(typefilter(self.vars, continuous_types))
def Var(self, name, dist, data=None, total_size=None): DCNL DCSP name = self.name_for(name) DCNL DCSP if (data is None): DCNL DCSP  DCSP if (getattr(dist, 'transform', None) is None): DCNL DCSP  DCSP  DCSP with self: DCNL DCSP  DCSP  DCSP  DCSP var = FreeRV(name=name, distribution=dist, total_size=total_size, model=self) DCNL DCSP  DCSP  DCSP self.free_RVs.append(var) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP with self: DCNL DCSP  DCSP  DCSP  DCSP var = TransformedRV(name=name, distribution=dist, transform=dist.transform, total_size=total_size, model=self) DCNL DCSP  DCSP  DCSP pm._log.debug('Applied DCSP {transform}-transform DCSP to DCSP {name} DCSP and DCSP added DCSP transformed DCSP {orig_name} DCSP to DCSP model.'.format(transform=dist.transform.name, name=name, orig_name=get_transformed_name(name, dist.transform))) DCNL DCSP  DCSP  DCSP self.deterministics.append(var) DCNL DCSP  DCSP  DCSP self.add_random_variable(var) DCNL DCSP  DCSP  DCSP return var DCNL DCSP elif isinstance(data, dict): DCNL DCSP  DCSP with self: DCNL DCSP  DCSP  DCSP var = MultiObservedRV(name=name, data=data, distribution=dist, total_size=total_size, model=self) DCNL DCSP  DCSP self.observed_RVs.append(var) DCNL DCSP  DCSP if var.missing_values: DCNL DCSP  DCSP  DCSP self.free_RVs += var.missing_values DCNL DCSP  DCSP  DCSP self.missing_values += var.missing_values DCNL DCSP  DCSP  DCSP for v in var.missing_values: DCNL DCSP  DCSP  DCSP  DCSP self.named_vars[v.name] = v DCNL DCSP else: DCNL DCSP  DCSP with self: DCNL DCSP  DCSP  DCSP var = ObservedRV(name=name, data=data, distribution=dist, total_size=total_size, model=self) DCNL DCSP  DCSP self.observed_RVs.append(var) DCNL DCSP  DCSP if var.missing_values: DCNL DCSP  DCSP  DCSP self.free_RVs.append(var.missing_values) DCNL DCSP  DCSP  DCSP self.missing_values.append(var.missing_values) DCNL DCSP  DCSP  DCSP self.named_vars[var.missing_values.name] = var.missing_values DCNL DCSP self.add_random_variable(var) DCNL DCSP return var
def add_random_variable(self, var): DCNL DCSP if self.named_vars.tree_contains(var.name): DCNL DCSP  DCSP raise ValueError('Variable DCSP name DCSP {} DCSP already DCSP exists.'.format(var.name)) DCNL DCSP self.named_vars[var.name] = var DCNL DCSP if (not hasattr(self, self.name_of(var.name))): DCNL DCSP  DCSP setattr(self, self.name_of(var.name), var)
def name_for(self, name): DCNL DCSP if self.prefix: DCNL DCSP  DCSP if (not name.startswith(self.prefix)): DCNL DCSP  DCSP  DCSP return '{}{}'.format(self.prefix, name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return name DCNL DCSP else: DCNL DCSP  DCSP return name
def name_of(self, name): DCNL DCSP if ((not self.prefix) or (not name)): DCNL DCSP  DCSP return name DCNL DCSP elif name.startswith(self.prefix): DCNL DCSP  DCSP return name[len(self.prefix):] DCNL DCSP else: DCNL DCSP  DCSP return name
def makefn(self, outs, mode=None, *args, **kwargs): DCNL DCSP with self: DCNL DCSP  DCSP return theano.function(self.vars, outs, allow_input_downcast=True, on_unused_input='ignore', accept_inplace=True, mode=mode, *args, **kwargs)
def fn(self, outs, mode=None, *args, **kwargs): DCNL DCSP return LoosePointFunc(self.makefn(outs, mode, *args, **kwargs), self)
def fastfn(self, outs, mode=None, *args, **kwargs): DCNL DCSP f = self.makefn(outs, mode, *args, **kwargs) DCNL DCSP return FastPointFunc(f)
def profile(self, outs, n=1000, point=None, profile=True, *args, **kwargs): DCNL DCSP f = self.makefn(outs, profile=profile, *args, **kwargs) DCNL DCSP if (point is None): DCNL DCSP  DCSP point = self.test_point DCNL DCSP for _ in range(n): DCNL DCSP  DCSP f(**point) DCNL DCSP return f.profile
def flatten(self, vars=None, order=None, inputvar=None): DCNL DCSP if (vars is None): DCNL DCSP  DCSP vars = self.free_RVs DCNL DCSP if (order is None): DCNL DCSP  DCSP order = ArrayOrdering(vars) DCNL DCSP if (inputvar is None): DCNL DCSP  DCSP inputvar = tt.vector('flat_view', dtype=theano.config.floatX) DCNL DCSP  DCSP if (theano.config.compute_test_value != 'off'): DCNL DCSP  DCSP  DCSP if vars: DCNL DCSP  DCSP  DCSP  DCSP inputvar.tag.test_value = flatten_list(vars).tag.test_value DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP inputvar.tag.test_value = np.asarray([], inputvar.dtype) DCNL DCSP replacements = {self.named_vars[name]: inputvar[slc].reshape(shape).astype(dtype) for (name, slc, shape, dtype) in order.vmap} DCNL DCSP view = {vm.var: vm for vm in order.vmap} DCNL DCSP flat_view = FlatView(inputvar, replacements, view) DCNL DCSP return flat_view
def __init__(self, type=None, owner=None, index=None, name=None, distribution=None, total_size=None, model=None): DCNL DCSP if (type is None): DCNL DCSP  DCSP type = distribution.type DCNL DCSP super(FreeRV, self).__init__(type, owner, index, name) DCNL DCSP if (distribution is not None): DCNL DCSP  DCSP self.dshape = tuple(distribution.shape) DCNL DCSP  DCSP self.dsize = int(np.prod(distribution.shape)) DCNL DCSP  DCSP self.distribution = distribution DCNL DCSP  DCSP self.tag.test_value = (np.ones(distribution.shape, distribution.dtype) * distribution.default()) DCNL DCSP  DCSP self.logp_elemwiset = distribution.logp(self) DCNL DCSP  DCSP self.total_size = total_size DCNL DCSP  DCSP self.model = model DCNL DCSP  DCSP self.scaling = _get_scaling(total_size, self.shape, self.ndim) DCNL DCSP  DCSP incorporate_methods(source=distribution, destination=self, methods=['random'], wrapper=InstanceMethod)
@property DCNL def init_value(self): DCNL DCSP return self.tag.test_value
def __init__(self, type=None, owner=None, index=None, name=None, data=None, distribution=None, total_size=None, model=None): DCNL DCSP from .distributions import TensorType DCNL DCSP if (type is None): DCNL DCSP  DCSP data = pandas_to_array(data) DCNL DCSP  DCSP type = TensorType(distribution.dtype, data.shape) DCNL DCSP self.observations = data DCNL DCSP super(ObservedRV, self).__init__(type, owner, index, name) DCNL DCSP if (distribution is not None): DCNL DCSP  DCSP data = as_tensor(data, name, model, distribution) DCNL DCSP  DCSP self.missing_values = data.missing_values DCNL DCSP  DCSP self.logp_elemwiset = distribution.logp(data) DCNL DCSP  DCSP self.total_size = total_size DCNL DCSP  DCSP self.model = model DCNL DCSP  DCSP self.distribution = distribution DCNL DCSP  DCSP theano.gof.Apply(theano.compile.view_op, inputs=[data], outputs=[self]) DCNL DCSP  DCSP self.tag.test_value = theano.compile.view_op(data).tag.test_value DCNL DCSP  DCSP self.scaling = _get_scaling(total_size, data.shape, data.ndim)
@property DCNL def init_value(self): DCNL DCSP return self.tag.test_value
def __init__(self, name, data, distribution, total_size=None, model=None): DCNL DCSP self.name = name DCNL DCSP self.data = {name: as_tensor(data, name, model, distribution) for (name, data) in data.items()} DCNL DCSP self.missing_values = [datum.missing_values for datum in self.data.values() if (datum.missing_values is not None)] DCNL DCSP self.logp_elemwiset = distribution.logp(**self.data) DCNL DCSP self.total_size = total_size DCNL DCSP self.model = model DCNL DCSP self.distribution = distribution DCNL DCSP self.scaling = _get_scaling(total_size, self.logp_elemwiset.shape, self.logp_elemwiset.ndim)
def __init__(self, type=None, owner=None, index=None, name=None, distribution=None, model=None, transform=None, total_size=None): DCNL DCSP if (type is None): DCNL DCSP  DCSP type = distribution.type DCNL DCSP super(TransformedRV, self).__init__(type, owner, index, name) DCNL DCSP self.transformation = transform DCNL DCSP if (distribution is not None): DCNL DCSP  DCSP self.model = model DCNL DCSP  DCSP self.distribution = distribution DCNL DCSP  DCSP transformed_name = get_transformed_name(name, transform) DCNL DCSP  DCSP self.transformed = model.Var(transformed_name, transform.apply(distribution), total_size=total_size) DCNL DCSP  DCSP normalRV = transform.backward(self.transformed) DCNL DCSP  DCSP theano.Apply(theano.compile.view_op, inputs=[normalRV], outputs=[self]) DCNL DCSP  DCSP self.tag.test_value = normalRV.tag.test_value DCNL DCSP  DCSP self.scaling = _get_scaling(total_size, self.shape, self.ndim) DCNL DCSP  DCSP incorporate_methods(source=distribution, destination=self, methods=['random'], wrapper=InstanceMethod)
@property DCNL def init_value(self): DCNL DCSP return self.tag.test_value
def __call__(self, X, Z=None, diag=False): DCNL DCSP if diag: DCNL DCSP  DCSP return self.diag(X) DCNL DCSP else: DCNL DCSP  DCSP return self.full(X, Z)
def __array_wrap__(self, result): DCNL DCSP (r, c) = result.shape DCNL DCSP A = np.zeros((r, c)) DCNL DCSP for i in range(r): DCNL DCSP  DCSP for j in range(c): DCNL DCSP  DCSP  DCSP A[(i, j)] = result[(i, j)].factor_list[1] DCNL DCSP if isinstance(result[0][0], Add): DCNL DCSP  DCSP return (result[0][0].factor_list[0] + A) DCNL DCSP elif isinstance(result[0][0], Prod): DCNL DCSP  DCSP return (result[0][0].factor_list[0] * A) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError
def __call__(self, X): DCNL DCSP raise NotImplementedError
def _get_priors(self, model=None, name=''): DCNL DCSP if name: DCNL DCSP  DCSP name = '{}_'.format(name) DCNL DCSP model = modelcontext(model) DCNL DCSP priors = {} DCNL DCSP for (key, val) in self.priors.items(): DCNL DCSP  DCSP if isinstance(val, numbers.Number): DCNL DCSP  DCSP  DCSP priors[key] = val DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP priors[key] = model.Var('{}{}'.format(name, key), val) DCNL DCSP return priors
def create_likelihood(self, name, y_est, y_data, model=None): DCNL DCSP priors = self._get_priors(model=model, name=name) DCNL DCSP priors[self.parent] = self.link(y_est) DCNL DCSP if name: DCNL DCSP  DCSP name = '{}_'.format(name) DCNL DCSP return self.likelihood('{}y'.format(name), observed=y_data, **priors)
@staticmethod DCNL def grab_options(complex_args, module_args): DCNL DCSP options = dict() DCNL DCSP if complex_args: DCNL DCSP  DCSP options.update(complex_args) DCNL DCSP options.update(utils.parse_kv(module_args)) DCNL DCSP return options
def return_config_overrides_ini(self, config_overrides, resultant, list_extend=True): DCNL DCSP config = ConfigTemplateParser(dict_type=MultiKeyDict, allow_no_value=True) DCNL DCSP config.optionxform = str DCNL DCSP config_object = io.BytesIO(resultant.encode('utf-8')) DCNL DCSP config.readfp(config_object) DCNL DCSP for (section, items) in config_overrides.items(): DCNL DCSP  DCSP if (not isinstance(items, dict)): DCNL DCSP  DCSP  DCSP if isinstance(items, list): DCNL DCSP  DCSP  DCSP  DCSP items = ','.join(items) DCNL DCSP  DCSP  DCSP self._option_write(config, 'DEFAULT', section, items) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP config.add_section(str(section)) DCNL DCSP  DCSP  DCSP except (ConfigParser.DuplicateSectionError, ValueError): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP for (key, value) in items.items(): DCNL DCSP  DCSP  DCSP  DCSP self._option_write(config, section, key, value) DCNL DCSP else: DCNL DCSP  DCSP config_object.close() DCNL DCSP resultant_bytesio = io.BytesIO() DCNL DCSP try: DCNL DCSP  DCSP config.write(resultant_bytesio) DCNL DCSP  DCSP return resultant_bytesio.getvalue() DCNL DCSP finally: DCNL DCSP  DCSP resultant_bytesio.close()
def return_config_overrides_json(self, config_overrides, resultant, list_extend=True): DCNL DCSP original_resultant = json.loads(resultant) DCNL DCSP merged_resultant = self._merge_dict(base_items=original_resultant, new_items=config_overrides, list_extend=list_extend) DCNL DCSP return json.dumps(merged_resultant, indent=4, sort_keys=True)
def return_config_overrides_yaml(self, config_overrides, resultant, list_extend=True): DCNL DCSP original_resultant = yaml.safe_load(resultant) DCNL DCSP merged_resultant = self._merge_dict(base_items=original_resultant, new_items=config_overrides, list_extend=list_extend) DCNL DCSP return yaml.safe_dump(merged_resultant, default_flow_style=False, width=1000)
def _merge_dict(self, base_items, new_items, list_extend=True): DCNL DCSP for (key, value) in new_items.iteritems(): DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP base_items[key] = self._merge_dict(base_items.get(key, {}), value) DCNL DCSP  DCSP elif ((',' in value) or ('\n' in value)): DCNL DCSP  DCSP  DCSP base_items[key] = re.split(', DCSP |,|\n', value) DCNL DCSP  DCSP  DCSP base_items[key] = [i.strip() for i in base_items[key] if i] DCNL DCSP  DCSP elif isinstance(value, list): DCNL DCSP  DCSP  DCSP if (isinstance(base_items.get(key), list) and list_extend): DCNL DCSP  DCSP  DCSP  DCSP base_items[key].extend(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP base_items[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP base_items[key] = new_items[key] DCNL DCSP return base_items
def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs): DCNL DCSP if (not self.runner.is_playbook): DCNL DCSP  DCSP raise errors.AnsibleError('FAILED: DCSP `config_templates` DCSP are DCSP only DCSP available DCSP in DCSP playbooks') DCNL DCSP options = self.grab_options(complex_args, module_args) DCNL DCSP try: DCNL DCSP  DCSP source = options['src'] DCNL DCSP  DCSP dest = options['dest'] DCNL DCSP  DCSP config_overrides = options.get('config_overrides', dict()) DCNL DCSP  DCSP config_type = options['config_type'] DCNL DCSP  DCSP assert (config_type.lower() in ['ini', 'json', 'yaml']) DCNL DCSP except KeyError as exp: DCNL DCSP  DCSP result = dict(failed=True, msg=exp) DCNL DCSP  DCSP return ReturnData(conn=conn, comm_ok=False, result=result) DCNL DCSP source_template = template.template(self.runner.basedir, source, inject) DCNL DCSP if ('_original_file' in inject): DCNL DCSP  DCSP source_file = utils.path_dwim_relative(inject['_original_file'], 'templates', source_template, self.runner.basedir) DCNL DCSP else: DCNL DCSP  DCSP source_file = utils.path_dwim(self.runner.basedir, source_template) DCNL DCSP resultant = template.template_from_file(self.runner.basedir, source_file, inject, vault_password=self.runner.vault_pass) DCNL DCSP if config_overrides: DCNL DCSP  DCSP type_merger = getattr(self, CONFIG_TYPES.get(config_type)) DCNL DCSP  DCSP resultant = type_merger(config_overrides=config_overrides, resultant=resultant, list_extend=options.get('list_extend', True)) DCNL DCSP template.template_from_string(basedir=self.runner.basedir, data=resultant, vars=inject, fail_on_undefined=True) DCNL DCSP new_module_args = dict(src=self.runner._transfer_str(conn, tmp, 'source', resultant), dest=dest, original_basename=os.path.basename(source), follow=True) DCNL DCSP module_args_tmp = utils.merge_module_args(module_args, new_module_args) DCNL DCSP complex_args.pop('config_overrides') DCNL DCSP complex_args.pop('config_type') DCNL DCSP complex_args.pop('list_extend', None) DCNL DCSP return self.runner._execute_module(conn, tmp, 'copy', module_args_tmp, inject=inject, complex_args=complex_args)
def return_config_overrides_ini(self, config_overrides, resultant, list_extend=True): DCNL DCSP try: DCNL DCSP  DCSP config = ConfigTemplateParser(allow_no_value=True, dict_type=MultiKeyDict) DCNL DCSP  DCSP config.optionxform = str DCNL DCSP except Exception: DCNL DCSP  DCSP config = ConfigTemplateParser(dict_type=MultiKeyDict) DCNL DCSP config_object = io.BytesIO(str(resultant)) DCNL DCSP config.readfp(config_object) DCNL DCSP for (section, items) in config_overrides.items(): DCNL DCSP  DCSP if (not isinstance(items, dict)): DCNL DCSP  DCSP  DCSP if isinstance(items, list): DCNL DCSP  DCSP  DCSP  DCSP items = ','.join(_convert_2_string(items)) DCNL DCSP  DCSP  DCSP self._option_write(config, 'DEFAULT', str(section), items) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP config.add_section(section.encode('utf-8')) DCNL DCSP  DCSP  DCSP except (ConfigParser.DuplicateSectionError, ValueError): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP for (key, value) in items.items(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._option_write(config, section, key, value) DCNL DCSP  DCSP  DCSP  DCSP except ConfigParser.NoSectionError as exp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP error_msg = str(exp) DCNL DCSP  DCSP  DCSP  DCSP  DCSP error_msg += ' DCSP Try DCSP being DCSP more DCSP explicit DCSP with DCSP your DCSP overridedata. DCSP Sections DCSP are DCSP case DCSP sensitive.' DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise errors.AnsibleModuleError(error_msg) DCNL DCSP else: DCNL DCSP  DCSP config_object.close() DCNL DCSP resultant_bytesio = io.BytesIO() DCNL DCSP try: DCNL DCSP  DCSP config.write(resultant_bytesio) DCNL DCSP  DCSP return resultant_bytesio.getvalue() DCNL DCSP finally: DCNL DCSP  DCSP resultant_bytesio.close()
def return_config_overrides_json(self, config_overrides, resultant, list_extend=True): DCNL DCSP original_resultant = json.loads(resultant) DCNL DCSP merged_resultant = self._merge_dict(base_items=original_resultant, new_items=config_overrides, list_extend=list_extend) DCNL DCSP return json.dumps(merged_resultant, indent=4, sort_keys=True)
def return_config_overrides_yaml(self, config_overrides, resultant, list_extend=True): DCNL DCSP original_resultant = yaml.safe_load(resultant) DCNL DCSP merged_resultant = self._merge_dict(base_items=original_resultant, new_items=config_overrides, list_extend=list_extend) DCNL DCSP return yaml.safe_dump(merged_resultant, default_flow_style=False, width=1000)
def _merge_dict(self, base_items, new_items, list_extend=True): DCNL DCSP for (key, value) in new_items.iteritems(): DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP base_items[key] = self._merge_dict(base_items=base_items.get(key, {}), new_items=value, list_extend=list_extend) DCNL DCSP  DCSP elif ((not isinstance(value, int)) and ((',' in value) or ('\n' in value))): DCNL DCSP  DCSP  DCSP base_items[key] = re.split(',|\n', value) DCNL DCSP  DCSP  DCSP base_items[key] = [i.strip() for i in base_items[key] if i] DCNL DCSP  DCSP elif isinstance(value, list): DCNL DCSP  DCSP  DCSP if (isinstance(base_items.get(key), list) and list_extend): DCNL DCSP  DCSP  DCSP  DCSP base_items[key].extend(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP base_items[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP base_items[key] = new_items[key] DCNL DCSP return base_items
def _load_options_and_status(self, task_vars): DCNL DCSP config_type = self._task.args.get('config_type') DCNL DCSP if (config_type not in ['ini', 'yaml', 'json']): DCNL DCSP  DCSP return (False, dict(failed=True, msg='No DCSP valid DCSP [ DCSP config_type DCSP ] DCSP was DCSP provided. DCSP Valid DCSP options DCSP are DCSP ini, DCSP yaml, DCSP or DCSP json.')) DCNL DCSP searchpath = [self._loader._basedir] DCNL DCSP if self._task._role: DCNL DCSP  DCSP file_path = self._task._role._role_path DCNL DCSP  DCSP searchpath.insert(1, C.DEFAULT_ROLES_PATH) DCNL DCSP  DCSP searchpath.insert(1, self._task._role._role_path) DCNL DCSP else: DCNL DCSP  DCSP file_path = self._loader.get_basedir() DCNL DCSP user_source = self._task.args.get('src') DCNL DCSP if (not user_source): DCNL DCSP  DCSP return (False, dict(failed=True, msg='No DCSP user DCSP provided DCSP [ DCSP src DCSP ] DCSP was DCSP provided')) DCNL DCSP source = self._loader.path_dwim_relative(file_path, 'templates', user_source) DCNL DCSP searchpath.insert(1, os.path.dirname(source)) DCNL DCSP _dest = self._task.args.get('dest') DCNL DCSP list_extend = self._task.args.get('list_extend') DCNL DCSP if (not _dest): DCNL DCSP  DCSP return (False, dict(failed=True, msg='No DCSP [ DCSP dest DCSP ] DCSP was DCSP provided')) DCNL DCSP else: DCNL DCSP  DCSP user_dest = self._remote_expand_user(_dest) DCNL DCSP  DCSP if user_dest.endswith(os.sep): DCNL DCSP  DCSP  DCSP user_dest = os.path.join(user_dest, os.path.basename(source)) DCNL DCSP return (True, dict(source=source, dest=user_dest, config_overrides=self._task.args.get('config_overrides', dict()), config_type=config_type, searchpath=searchpath, list_extend=list_extend))
def run(self, tmp=None, task_vars=None): DCNL DCSP try: DCNL DCSP  DCSP remote_user = task_vars.get('ansible_user') DCNL DCSP  DCSP if (not remote_user): DCNL DCSP  DCSP  DCSP remote_user = task_vars.get('ansible_ssh_user') DCNL DCSP  DCSP if (not remote_user): DCNL DCSP  DCSP  DCSP remote_user = self._play_context.remote_user DCNL DCSP  DCSP if (not tmp): DCNL DCSP  DCSP  DCSP tmp = self._make_tmp_path(remote_user) DCNL DCSP except TypeError: DCNL DCSP  DCSP if (not tmp): DCNL DCSP  DCSP  DCSP tmp = self._make_tmp_path() DCNL DCSP (_status, _vars) = self._load_options_and_status(task_vars=task_vars) DCNL DCSP if (not _status): DCNL DCSP  DCSP return _vars DCNL DCSP temp_vars = task_vars.copy() DCNL DCSP template_host = temp_vars['template_host'] = os.uname()[1] DCNL DCSP source = temp_vars['template_path'] = _vars['source'] DCNL DCSP temp_vars['template_mtime'] = datetime.datetime.fromtimestamp(os.path.getmtime(source)) DCNL DCSP try: DCNL DCSP  DCSP template_uid = temp_vars['template_uid'] = pwd.getpwuid(os.stat(source).st_uid).pw_name DCNL DCSP except Exception: DCNL DCSP  DCSP template_uid = temp_vars['template_uid'] = os.stat(source).st_uid DCNL DCSP managed_default = C.DEFAULT_MANAGED_STR DCNL DCSP managed_str = managed_default.format(host=template_host, uid=template_uid, file=to_bytes(source)) DCNL DCSP temp_vars['ansible_managed'] = time.strftime(managed_str, time.localtime(os.path.getmtime(source))) DCNL DCSP temp_vars['template_fullpath'] = os.path.abspath(source) DCNL DCSP temp_vars['template_run_date'] = datetime.datetime.now() DCNL DCSP with open(source, 'r') as f: DCNL DCSP  DCSP template_data = to_unicode(f.read()) DCNL DCSP self._templar.environment.loader.searchpath = _vars['searchpath'] DCNL DCSP self._templar.set_available_variables(temp_vars) DCNL DCSP resultant = self._templar.template(template_data, preserve_trailing_newlines=True, escape_backslashes=False, convert_data=False) DCNL DCSP self._templar.set_available_variables(self._templar._available_variables) DCNL DCSP if _vars['config_overrides']: DCNL DCSP  DCSP type_merger = getattr(self, CONFIG_TYPES.get(_vars['config_type'])) DCNL DCSP  DCSP resultant = type_merger(config_overrides=_vars['config_overrides'], resultant=resultant, list_extend=_vars.get('list_extend', True)) DCNL DCSP resultant = self._templar.template(resultant, preserve_trailing_newlines=True, escape_backslashes=False, convert_data=False) DCNL DCSP new_module_args = self._task.args.copy() DCNL DCSP transferred_data = self._transfer_data(self._connection._shell.join_path(tmp, 'source'), resultant) DCNL DCSP new_module_args.update(dict(src=transferred_data, dest=_vars['dest'], original_basename=os.path.basename(source), follow=True)) DCNL DCSP new_module_args.pop('config_overrides', None) DCNL DCSP new_module_args.pop('config_type', None) DCNL DCSP new_module_args.pop('list_extend', None) DCNL DCSP return self._execute_module(module_name='copy', module_args=new_module_args, task_vars=task_vars)
@staticmethod DCNL def grab_options(complex_args, module_args): DCNL DCSP options = dict() DCNL DCSP if complex_args: DCNL DCSP  DCSP options.update(complex_args) DCNL DCSP options.update(utils.parse_kv(module_args)) DCNL DCSP return options
def return_config_overrides_ini(self, config_overrides, resultant, list_extend=True): DCNL DCSP config = ConfigTemplateParser(dict_type=MultiKeyDict, allow_no_value=True) DCNL DCSP config.optionxform = str DCNL DCSP config_object = io.BytesIO(resultant.encode('utf-8')) DCNL DCSP config.readfp(config_object) DCNL DCSP for (section, items) in config_overrides.items(): DCNL DCSP  DCSP if (not isinstance(items, dict)): DCNL DCSP  DCSP  DCSP if isinstance(items, list): DCNL DCSP  DCSP  DCSP  DCSP items = ','.join(items) DCNL DCSP  DCSP  DCSP self._option_write(config, 'DEFAULT', section, items) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP config.add_section(str(section)) DCNL DCSP  DCSP  DCSP except (ConfigParser.DuplicateSectionError, ValueError): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP for (key, value) in items.items(): DCNL DCSP  DCSP  DCSP  DCSP self._option_write(config, section, key, value) DCNL DCSP else: DCNL DCSP  DCSP config_object.close() DCNL DCSP resultant_bytesio = io.BytesIO() DCNL DCSP try: DCNL DCSP  DCSP config.write(resultant_bytesio) DCNL DCSP  DCSP return resultant_bytesio.getvalue() DCNL DCSP finally: DCNL DCSP  DCSP resultant_bytesio.close()
def return_config_overrides_json(self, config_overrides, resultant, list_extend=True): DCNL DCSP original_resultant = json.loads(resultant) DCNL DCSP merged_resultant = self._merge_dict(base_items=original_resultant, new_items=config_overrides, list_extend=list_extend) DCNL DCSP return json.dumps(merged_resultant, indent=4, sort_keys=True)
def return_config_overrides_yaml(self, config_overrides, resultant, list_extend=True): DCNL DCSP original_resultant = yaml.safe_load(resultant) DCNL DCSP merged_resultant = self._merge_dict(base_items=original_resultant, new_items=config_overrides, list_extend=list_extend) DCNL DCSP return yaml.safe_dump(merged_resultant, default_flow_style=False, width=1000)
def _merge_dict(self, base_items, new_items, list_extend=True): DCNL DCSP for (key, value) in new_items.iteritems(): DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP base_items[key] = self._merge_dict(base_items.get(key, {}), value) DCNL DCSP  DCSP elif ((',' in value) or ('\n' in value)): DCNL DCSP  DCSP  DCSP base_items[key] = re.split(', DCSP |,|\n', value) DCNL DCSP  DCSP  DCSP base_items[key] = [i.strip() for i in base_items[key] if i] DCNL DCSP  DCSP elif isinstance(value, list): DCNL DCSP  DCSP  DCSP if (isinstance(base_items.get(key), list) and list_extend): DCNL DCSP  DCSP  DCSP  DCSP base_items[key].extend(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP base_items[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP base_items[key] = new_items[key] DCNL DCSP return base_items
def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs): DCNL DCSP if (not self.runner.is_playbook): DCNL DCSP  DCSP raise errors.AnsibleError('FAILED: DCSP `config_templates` DCSP are DCSP only DCSP available DCSP in DCSP playbooks') DCNL DCSP options = self.grab_options(complex_args, module_args) DCNL DCSP try: DCNL DCSP  DCSP source = options['src'] DCNL DCSP  DCSP dest = options['dest'] DCNL DCSP  DCSP config_overrides = options.get('config_overrides', dict()) DCNL DCSP  DCSP config_type = options['config_type'] DCNL DCSP  DCSP assert (config_type.lower() in ['ini', 'json', 'yaml']) DCNL DCSP except KeyError as exp: DCNL DCSP  DCSP result = dict(failed=True, msg=exp) DCNL DCSP  DCSP return ReturnData(conn=conn, comm_ok=False, result=result) DCNL DCSP source_template = template.template(self.runner.basedir, source, inject) DCNL DCSP if ('_original_file' in inject): DCNL DCSP  DCSP source_file = utils.path_dwim_relative(inject['_original_file'], 'templates', source_template, self.runner.basedir) DCNL DCSP else: DCNL DCSP  DCSP source_file = utils.path_dwim(self.runner.basedir, source_template) DCNL DCSP resultant = template.template_from_file(self.runner.basedir, source_file, inject, vault_password=self.runner.vault_pass) DCNL DCSP if config_overrides: DCNL DCSP  DCSP type_merger = getattr(self, CONFIG_TYPES.get(config_type)) DCNL DCSP  DCSP resultant = type_merger(config_overrides=config_overrides, resultant=resultant, list_extend=options.get('list_extend', True)) DCNL DCSP template.template_from_string(basedir=self.runner.basedir, data=resultant, vars=inject, fail_on_undefined=True) DCNL DCSP new_module_args = dict(src=self.runner._transfer_str(conn, tmp, 'source', resultant), dest=dest, original_basename=os.path.basename(source), follow=True) DCNL DCSP module_args_tmp = utils.merge_module_args(module_args, new_module_args) DCNL DCSP complex_args.pop('config_overrides') DCNL DCSP complex_args.pop('config_type') DCNL DCSP complex_args.pop('list_extend', None) DCNL DCSP return self.runner._execute_module(conn, tmp, 'copy', module_args_tmp, inject=inject, complex_args=complex_args)
def return_config_overrides_ini(self, config_overrides, resultant, list_extend=True): DCNL DCSP try: DCNL DCSP  DCSP config = ConfigTemplateParser(allow_no_value=True, dict_type=MultiKeyDict) DCNL DCSP  DCSP config.optionxform = str DCNL DCSP except Exception: DCNL DCSP  DCSP config = ConfigTemplateParser(dict_type=MultiKeyDict) DCNL DCSP config_object = io.BytesIO(str(resultant)) DCNL DCSP config.readfp(config_object) DCNL DCSP for (section, items) in config_overrides.items(): DCNL DCSP  DCSP if (not isinstance(items, dict)): DCNL DCSP  DCSP  DCSP if isinstance(items, list): DCNL DCSP  DCSP  DCSP  DCSP items = ','.join(_convert_2_string(items)) DCNL DCSP  DCSP  DCSP self._option_write(config, 'DEFAULT', str(section), items) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP config.add_section(section.encode('utf-8')) DCNL DCSP  DCSP  DCSP except (ConfigParser.DuplicateSectionError, ValueError): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP for (key, value) in items.items(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._option_write(config, section, key, value) DCNL DCSP  DCSP  DCSP  DCSP except ConfigParser.NoSectionError as exp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP error_msg = str(exp) DCNL DCSP  DCSP  DCSP  DCSP  DCSP error_msg += ' DCSP Try DCSP being DCSP more DCSP explicit DCSP with DCSP your DCSP overridedata. DCSP Sections DCSP are DCSP case DCSP sensitive.' DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise errors.AnsibleModuleError(error_msg) DCNL DCSP else: DCNL DCSP  DCSP config_object.close() DCNL DCSP resultant_bytesio = io.BytesIO() DCNL DCSP try: DCNL DCSP  DCSP config.write(resultant_bytesio) DCNL DCSP  DCSP return resultant_bytesio.getvalue() DCNL DCSP finally: DCNL DCSP  DCSP resultant_bytesio.close()
def return_config_overrides_json(self, config_overrides, resultant, list_extend=True): DCNL DCSP original_resultant = json.loads(resultant) DCNL DCSP merged_resultant = self._merge_dict(base_items=original_resultant, new_items=config_overrides, list_extend=list_extend) DCNL DCSP return json.dumps(merged_resultant, indent=4, sort_keys=True)
def return_config_overrides_yaml(self, config_overrides, resultant, list_extend=True): DCNL DCSP original_resultant = yaml.safe_load(resultant) DCNL DCSP merged_resultant = self._merge_dict(base_items=original_resultant, new_items=config_overrides, list_extend=list_extend) DCNL DCSP return yaml.safe_dump(merged_resultant, default_flow_style=False, width=1000)
def _merge_dict(self, base_items, new_items, list_extend=True): DCNL DCSP for (key, value) in new_items.iteritems(): DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP base_items[key] = self._merge_dict(base_items=base_items.get(key, {}), new_items=value, list_extend=list_extend) DCNL DCSP  DCSP elif ((not isinstance(value, int)) and ((',' in value) or ('\n' in value))): DCNL DCSP  DCSP  DCSP base_items[key] = re.split(',|\n', value) DCNL DCSP  DCSP  DCSP base_items[key] = [i.strip() for i in base_items[key] if i] DCNL DCSP  DCSP elif isinstance(value, list): DCNL DCSP  DCSP  DCSP if (isinstance(base_items.get(key), list) and list_extend): DCNL DCSP  DCSP  DCSP  DCSP base_items[key].extend(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP base_items[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP base_items[key] = new_items[key] DCNL DCSP return base_items
def _load_options_and_status(self, task_vars): DCNL DCSP config_type = self._task.args.get('config_type') DCNL DCSP if (config_type not in ['ini', 'yaml', 'json']): DCNL DCSP  DCSP return (False, dict(failed=True, msg='No DCSP valid DCSP [ DCSP config_type DCSP ] DCSP was DCSP provided. DCSP Valid DCSP options DCSP are DCSP ini, DCSP yaml, DCSP or DCSP json.')) DCNL DCSP searchpath = [self._loader._basedir] DCNL DCSP if self._task._role: DCNL DCSP  DCSP file_path = self._task._role._role_path DCNL DCSP  DCSP searchpath.insert(1, C.DEFAULT_ROLES_PATH) DCNL DCSP  DCSP searchpath.insert(1, self._task._role._role_path) DCNL DCSP else: DCNL DCSP  DCSP file_path = self._loader.get_basedir() DCNL DCSP user_source = self._task.args.get('src') DCNL DCSP if (not user_source): DCNL DCSP  DCSP return (False, dict(failed=True, msg='No DCSP user DCSP provided DCSP [ DCSP src DCSP ] DCSP was DCSP provided')) DCNL DCSP source = self._loader.path_dwim_relative(file_path, 'templates', user_source) DCNL DCSP searchpath.insert(1, os.path.dirname(source)) DCNL DCSP _dest = self._task.args.get('dest') DCNL DCSP list_extend = self._task.args.get('list_extend') DCNL DCSP if (not _dest): DCNL DCSP  DCSP return (False, dict(failed=True, msg='No DCSP [ DCSP dest DCSP ] DCSP was DCSP provided')) DCNL DCSP else: DCNL DCSP  DCSP user_dest = self._remote_expand_user(_dest) DCNL DCSP  DCSP if user_dest.endswith(os.sep): DCNL DCSP  DCSP  DCSP user_dest = os.path.join(user_dest, os.path.basename(source)) DCNL DCSP return (True, dict(source=source, dest=user_dest, config_overrides=self._task.args.get('config_overrides', dict()), config_type=config_type, searchpath=searchpath, list_extend=list_extend))
def run(self, tmp=None, task_vars=None): DCNL DCSP try: DCNL DCSP  DCSP remote_user = task_vars.get('ansible_user') DCNL DCSP  DCSP if (not remote_user): DCNL DCSP  DCSP  DCSP remote_user = task_vars.get('ansible_ssh_user') DCNL DCSP  DCSP if (not remote_user): DCNL DCSP  DCSP  DCSP remote_user = self._play_context.remote_user DCNL DCSP  DCSP if (not tmp): DCNL DCSP  DCSP  DCSP tmp = self._make_tmp_path(remote_user) DCNL DCSP except TypeError: DCNL DCSP  DCSP if (not tmp): DCNL DCSP  DCSP  DCSP tmp = self._make_tmp_path() DCNL DCSP (_status, _vars) = self._load_options_and_status(task_vars=task_vars) DCNL DCSP if (not _status): DCNL DCSP  DCSP return _vars DCNL DCSP temp_vars = task_vars.copy() DCNL DCSP template_host = temp_vars['template_host'] = os.uname()[1] DCNL DCSP source = temp_vars['template_path'] = _vars['source'] DCNL DCSP temp_vars['template_mtime'] = datetime.datetime.fromtimestamp(os.path.getmtime(source)) DCNL DCSP try: DCNL DCSP  DCSP template_uid = temp_vars['template_uid'] = pwd.getpwuid(os.stat(source).st_uid).pw_name DCNL DCSP except Exception: DCNL DCSP  DCSP template_uid = temp_vars['template_uid'] = os.stat(source).st_uid DCNL DCSP managed_default = C.DEFAULT_MANAGED_STR DCNL DCSP managed_str = managed_default.format(host=template_host, uid=template_uid, file=to_bytes(source)) DCNL DCSP temp_vars['ansible_managed'] = time.strftime(managed_str, time.localtime(os.path.getmtime(source))) DCNL DCSP temp_vars['template_fullpath'] = os.path.abspath(source) DCNL DCSP temp_vars['template_run_date'] = datetime.datetime.now() DCNL DCSP with open(source, 'r') as f: DCNL DCSP  DCSP template_data = to_unicode(f.read()) DCNL DCSP self._templar.environment.loader.searchpath = _vars['searchpath'] DCNL DCSP self._templar.set_available_variables(temp_vars) DCNL DCSP resultant = self._templar.template(template_data, preserve_trailing_newlines=True, escape_backslashes=False, convert_data=False) DCNL DCSP self._templar.set_available_variables(self._templar._available_variables) DCNL DCSP if _vars['config_overrides']: DCNL DCSP  DCSP type_merger = getattr(self, CONFIG_TYPES.get(_vars['config_type'])) DCNL DCSP  DCSP resultant = type_merger(config_overrides=_vars['config_overrides'], resultant=resultant, list_extend=_vars.get('list_extend', True)) DCNL DCSP resultant = self._templar.template(resultant, preserve_trailing_newlines=True, escape_backslashes=False, convert_data=False) DCNL DCSP new_module_args = self._task.args.copy() DCNL DCSP transferred_data = self._transfer_data(self._connection._shell.join_path(tmp, 'source'), resultant) DCNL DCSP new_module_args.update(dict(src=transferred_data, dest=_vars['dest'], original_basename=os.path.basename(source), follow=True)) DCNL DCSP new_module_args.pop('config_overrides', None) DCNL DCSP new_module_args.pop('config_type', None) DCNL DCSP new_module_args.pop('list_extend', None) DCNL DCSP return self._execute_module(module_name='copy', module_args=new_module_args, task_vars=task_vars)
def testResults(self): DCNL DCSP problem = problems.simple() DCNL DCSP optimizer = meta.MetaOptimizer(net=dict(net='CoordinateWiseDeepLSTM', net_options={'layers': (), 'initializer': 'zeros'})) DCNL DCSP minimize_ops = optimizer.meta_minimize(problem, 5) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP (cost, final_x) = train(sess, minimize_ops, 1, 2) DCNL DCSP torch_cost = 0.7325327 DCNL DCSP torch_final_x = 0.8559 DCNL DCSP self.assertAlmostEqual(cost, torch_cost, places=4) DCNL DCSP self.assertAlmostEqual(final_x[0], torch_final_x, places=4)
@parameterized.expand([(None, {'net': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1, 1)}}}), ([('net', ['x_0', 'x_1'])], {'net': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1,)}}}), ([('net1', ['x_0']), ('net2', ['x_1'])], {'net1': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1,)}}, 'net2': {'net': 'Adam'}}), ([('net1', ['x_0']), ('net2', ['x_0'])], {'net1': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1,)}}, 'net2': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1,)}}})]) DCNL def testMultiOptimizer(self, net_assignments, net_config): DCNL DCSP problem = problems.simple_multi_optimizer(num_dims=2) DCNL DCSP optimizer = meta.MetaOptimizer(**net_config) DCNL DCSP minimize_ops = optimizer.meta_minimize(problem, 3, net_assignments=net_assignments) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP train(sess, minimize_ops, 1, 2)
def testSecondDerivatives(self): DCNL DCSP problem = problems.simple() DCNL DCSP optimizer = meta.MetaOptimizer(net=dict(net='CoordinateWiseDeepLSTM', net_options={'layers': ()})) DCNL DCSP minimize_ops = optimizer.meta_minimize(problem, 3, second_derivatives=True) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP train(sess, minimize_ops, 1, 2)
def testConvolutional(self): DCNL DCSP kernel_shape = 4 DCNL DCSP def convolutional_problem(): DCNL DCSP  DCSP conv = snt.Conv2D(output_channels=1, kernel_shape=kernel_shape, stride=1, name='conv') DCNL DCSP  DCSP output = conv(tf.random_normal((100, 100, 3, 10))) DCNL DCSP  DCSP return tf.reduce_sum(output) DCNL DCSP net_config = {'conv': {'net': 'KernelDeepLSTM', 'net_options': {'kernel_shape': ([kernel_shape] * 2), 'layers': (5,)}}} DCNL DCSP optimizer = meta.MetaOptimizer(**net_config) DCNL DCSP minimize_ops = optimizer.meta_minimize(convolutional_problem, 3, net_assignments=[('conv', ['conv/w'])]) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP train(sess, minimize_ops, 1, 2)
def testWhileLoopProblem(self): DCNL DCSP def while_loop_problem(): DCNL DCSP  DCSP x = tf.get_variable('x', shape=[], initializer=tf.ones_initializer()) DCNL DCSP  DCSP (_, x_squared) = tf.while_loop(cond=(lambda t, _: (t < 1)), body=(lambda t, x: ((t + 1), (x * x))), loop_vars=(0, x), name='loop') DCNL DCSP  DCSP return x_squared DCNL DCSP optimizer = meta.MetaOptimizer(net=dict(net='CoordinateWiseDeepLSTM', net_options={'layers': ()})) DCNL DCSP minimize_ops = optimizer.meta_minimize(while_loop_problem, 3) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP train(sess, minimize_ops, 1, 2)
def testSaveAndLoad(self): DCNL DCSP layers = (2, 3) DCNL DCSP net_options = {'layers': layers, 'initializer': 'zeros'} DCNL DCSP num_unrolls = 2 DCNL DCSP num_epochs = 1 DCNL DCSP problem = problems.simple() DCNL DCSP with tf.Graph().as_default() as g1: DCNL DCSP  DCSP optimizer = meta.MetaOptimizer(net=dict(net='CoordinateWiseDeepLSTM', net_options=net_options)) DCNL DCSP  DCSP minimize_ops = optimizer.meta_minimize(problem, 3) DCNL DCSP with self.test_session(graph=g1) as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP train(sess, minimize_ops, 1, 2) DCNL DCSP  DCSP tmp_dir = tempfile.mkdtemp() DCNL DCSP  DCSP save_result = optimizer.save(sess, path=tmp_dir) DCNL DCSP  DCSP net_path = next(iter(save_result)) DCNL DCSP  DCSP (cost, x) = train(sess, minimize_ops, num_unrolls, num_epochs) DCNL DCSP with tf.Graph().as_default() as g2: DCNL DCSP  DCSP optimizer = meta.MetaOptimizer(net=dict(net='CoordinateWiseDeepLSTM', net_options=net_options, net_path=net_path)) DCNL DCSP  DCSP minimize_ops = optimizer.meta_minimize(problem, 3) DCNL DCSP with self.test_session(graph=g2) as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP (cost_loaded, x_loaded) = train(sess, minimize_ops, num_unrolls, num_epochs) DCNL DCSP self.assertAlmostEqual(cost, cost_loaded, places=3) DCNL DCSP self.assertAlmostEqual(x[0], x_loaded[0], places=3) DCNL DCSP os.remove(net_path) DCNL DCSP os.rmdir(tmp_dir)
def testTrainable(self): DCNL DCSP shape = [10, 5] DCNL DCSP gradients = tf.random_normal(shape) DCNL DCSP net = networks.CoordinateWiseDeepLSTM(layers=(1,)) DCNL DCSP state = net.initial_state_for_inputs(gradients) DCNL DCSP net(gradients, state) DCNL DCSP variables = snt.get_variables_in_module(net) DCNL DCSP self.assertEqual(len(variables), 4)
@parameterized.expand([['zeros'], [{'w': 'zeros', 'b': 'zeros', 'bad': 'bad'}], [{'w': tf.zeros_initializer(), 'b': np.array([0])}], [{'linear': {'w': tf.zeros_initializer(), 'b': 'zeros'}}]]) DCNL def testResults(self, initializer): DCNL DCSP shape = [10] DCNL DCSP gradients = tf.random_normal(shape) DCNL DCSP net = networks.CoordinateWiseDeepLSTM(layers=(1, 1), initializer=initializer) DCNL DCSP state = net.initial_state_for_inputs(gradients) DCNL DCSP (update, _) = net(gradients, state) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP update_np = sess.run(update) DCNL DCSP  DCSP self.assertAllEqual(update_np, np.zeros(shape))
def testTrainable(self): DCNL DCSP kernel_shape = [5, 5] DCNL DCSP shape = (kernel_shape + [2, 2]) DCNL DCSP gradients = tf.random_normal(shape) DCNL DCSP net = networks.KernelDeepLSTM(layers=(1,), kernel_shape=kernel_shape) DCNL DCSP state = net.initial_state_for_inputs(gradients) DCNL DCSP net(gradients, state) DCNL DCSP variables = snt.get_variables_in_module(net) DCNL DCSP self.assertEqual(len(variables), 4)
@parameterized.expand([['zeros'], [{'w': 'zeros', 'b': 'zeros', 'bad': 'bad'}], [{'w': tf.zeros_initializer(), 'b': np.array([0])}], [{'linear': {'w': tf.zeros_initializer(), 'b': 'zeros'}}]]) DCNL def testResults(self, initializer): DCNL DCSP kernel_shape = [5, 5] DCNL DCSP shape = (kernel_shape + [2, 2]) DCNL DCSP gradients = tf.random_normal(shape) DCNL DCSP net = networks.KernelDeepLSTM(layers=(1, 1), kernel_shape=kernel_shape, initializer=initializer) DCNL DCSP state = net.initial_state_for_inputs(gradients) DCNL DCSP (update, _) = net(gradients, state) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP update_np = sess.run(update) DCNL DCSP  DCSP self.assertAllEqual(update_np, np.zeros(shape))
def testNonTrainable(self): DCNL DCSP shape = [10, 5] DCNL DCSP gradients = tf.random_normal(shape) DCNL DCSP net = networks.Sgd() DCNL DCSP state = net.initial_state_for_inputs(gradients) DCNL DCSP net(gradients, state) DCNL DCSP variables = snt.get_variables_in_module(net) DCNL DCSP self.assertEqual(len(variables), 0)
def testResults(self): DCNL DCSP shape = [10] DCNL DCSP learning_rate = 0.01 DCNL DCSP gradients = tf.random_normal(shape) DCNL DCSP net = networks.Sgd(learning_rate=learning_rate) DCNL DCSP state = net.initial_state_for_inputs(gradients) DCNL DCSP (update, _) = net(gradients, state) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP (gradients_np, update_np) = sess.run([gradients, update]) DCNL DCSP  DCSP self.assertAllEqual(update_np, ((- learning_rate) * gradients_np))
def testNonTrainable(self): DCNL DCSP shape = [10, 5] DCNL DCSP gradients = tf.random_normal(shape) DCNL DCSP net = networks.Adam() DCNL DCSP state = net.initial_state_for_inputs(gradients) DCNL DCSP net(gradients, state) DCNL DCSP variables = snt.get_variables_in_module(net) DCNL DCSP self.assertEqual(len(variables), 0)
def testZeroLearningRate(self): DCNL DCSP shape = [10] DCNL DCSP gradients = tf.random_normal(shape) DCNL DCSP net = networks.Adam(learning_rate=0) DCNL DCSP state = net.initial_state_for_inputs(gradients) DCNL DCSP (update, _) = net(gradients, state) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP update_np = sess.run(update) DCNL DCSP  DCSP self.assertAllEqual(update_np, np.zeros(shape))
def __init__(self, **kwargs): DCNL DCSP self._nets = None DCNL DCSP if (not kwargs): DCNL DCSP  DCSP self._config = {'coordinatewise': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (20, 20), 'preprocess_name': 'LogAndSign', 'preprocess_options': {'k': 5}, 'scale': 0.01}}} DCNL DCSP else: DCNL DCSP  DCSP self._config = kwargs
def save(self, sess, path=None): DCNL DCSP result = {} DCNL DCSP for (k, net) in self._nets.items(): DCNL DCSP  DCSP if (path is None): DCNL DCSP  DCSP  DCSP filename = None DCNL DCSP  DCSP  DCSP key = k DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filename = os.path.join(path, '{}.l2l'.format(k)) DCNL DCSP  DCSP  DCSP key = filename DCNL DCSP  DCSP net_vars = networks.save(net, sess, filename=filename) DCNL DCSP  DCSP result[key] = net_vars DCNL DCSP return result
def meta_loss(self, make_loss, len_unroll, net_assignments=None, second_derivatives=False): DCNL DCSP (x, constants) = _get_variables(make_loss) DCNL DCSP print('Optimizee DCSP variables') DCNL DCSP print([op.name for op in x]) DCNL DCSP print('Problem DCSP variables') DCNL DCSP print([op.name for op in constants]) DCNL DCSP (nets, net_keys, subsets) = _make_nets(x, self._config, net_assignments) DCNL DCSP self._nets = nets DCNL DCSP state = [] DCNL DCSP with tf.name_scope('states'): DCNL DCSP  DCSP for (i, (subset, key)) in enumerate(zip(subsets, net_keys)): DCNL DCSP  DCSP  DCSP net = nets[key] DCNL DCSP  DCSP  DCSP with tf.name_scope('state_{}'.format(i)): DCNL DCSP  DCSP  DCSP  DCSP state.append(_nested_variable([net.initial_state_for_inputs(x[j], dtype=tf.float32) for j in subset], name='state', trainable=False)) DCNL DCSP def update(net, fx, x, state): DCNL DCSP  DCSP 'Parameter DCSP and DCSP RNN DCSP state DCSP update.' DCNL DCSP  DCSP with tf.name_scope('gradients'): DCNL DCSP  DCSP  DCSP gradients = tf.gradients(fx, x) DCNL DCSP  DCSP  DCSP if (not second_derivatives): DCNL DCSP  DCSP  DCSP  DCSP gradients = [tf.stop_gradient(g) for g in gradients] DCNL DCSP  DCSP with tf.name_scope('deltas'): DCNL DCSP  DCSP  DCSP (deltas, state_next) = zip(*[net(g, s) for (g, s) in zip(gradients, state)]) DCNL DCSP  DCSP  DCSP state_next = list(state_next) DCNL DCSP  DCSP return (deltas, state_next) DCNL DCSP def time_step(t, fx_array, x, state): DCNL DCSP  DCSP 'While DCSP loop DCSP body.' DCNL DCSP  DCSP x_next = list(x) DCNL DCSP  DCSP state_next = [] DCNL DCSP  DCSP with tf.name_scope('fx'): DCNL DCSP  DCSP  DCSP fx = _make_with_custom_variables(make_loss, x) DCNL DCSP  DCSP  DCSP fx_array = fx_array.write(t, fx) DCNL DCSP  DCSP with tf.name_scope('dx'): DCNL DCSP  DCSP  DCSP for (subset, key, s_i) in zip(subsets, net_keys, state): DCNL DCSP  DCSP  DCSP  DCSP x_i = [x[j] for j in subset] DCNL DCSP  DCSP  DCSP  DCSP (deltas, s_i_next) = update(nets[key], fx, x_i, s_i) DCNL DCSP  DCSP  DCSP  DCSP for (idx, j) in enumerate(subset): DCNL DCSP  DCSP  DCSP  DCSP  DCSP x_next[j] += deltas[idx] DCNL DCSP  DCSP  DCSP  DCSP state_next.append(s_i_next) DCNL DCSP  DCSP with tf.name_scope('t_next'): DCNL DCSP  DCSP  DCSP t_next = (t + 1) DCNL DCSP  DCSP return (t_next, fx_array, x_next, state_next) DCNL DCSP fx_array = tf.TensorArray(tf.float32, size=(len_unroll + 1), clear_after_read=False) DCNL DCSP (_, fx_array, x_final, s_final) = tf.while_loop(cond=(lambda t, *_: (t < len_unroll)), body=time_step, loop_vars=(0, fx_array, x, state), parallel_iterations=1, swap_memory=True, name='unroll') DCNL DCSP with tf.name_scope('fx'): DCNL DCSP  DCSP fx_final = _make_with_custom_variables(make_loss, x_final) DCNL DCSP  DCSP fx_array = fx_array.write(len_unroll, fx_final) DCNL DCSP loss = tf.reduce_sum(fx_array.stack(), name='loss') DCNL DCSP with tf.name_scope('reset'): DCNL DCSP  DCSP variables = ((nest.flatten(state) + x) + constants) DCNL DCSP  DCSP reset = [tf.variables_initializer(variables), fx_array.close()] DCNL DCSP with tf.name_scope('update'): DCNL DCSP  DCSP update = (nest.flatten(_nested_assign(x, x_final)) + nest.flatten(_nested_assign(state, s_final))) DCNL DCSP for (k, net) in nets.items(): DCNL DCSP  DCSP print("Optimizer DCSP '{}' DCSP variables".format(k)) DCNL DCSP  DCSP print([op.name for op in snt.get_variables_in_module(net)]) DCNL DCSP return MetaLoss(loss, update, reset, fx_final, x_final)
def meta_minimize(self, make_loss, len_unroll, learning_rate=0.01, **kwargs): DCNL DCSP info = self.meta_loss(make_loss, len_unroll, **kwargs) DCNL DCSP optimizer = tf.train.AdamOptimizer(learning_rate) DCNL DCSP step = optimizer.minimize(info.loss) DCNL DCSP return MetaStep(step, *info[1:])
@abc.abstractmethod DCNL def initial_state_for_inputs(self, inputs, **kwargs): DCNL DCSP pass
def __init__(self, output_size, layers, preprocess_name='identity', preprocess_options=None, scale=1.0, initializer=None, name='deep_lstm'): DCNL DCSP super(StandardDeepLSTM, self).__init__(name=name) DCNL DCSP self._output_size = output_size DCNL DCSP self._scale = scale DCNL DCSP if hasattr(preprocess, preprocess_name): DCNL DCSP  DCSP preprocess_class = getattr(preprocess, preprocess_name) DCNL DCSP  DCSP self._preprocess = preprocess_class(**preprocess_options) DCNL DCSP else: DCNL DCSP  DCSP self._preprocess = getattr(tf, preprocess_name) DCNL DCSP with tf.variable_scope(self._template.variable_scope): DCNL DCSP  DCSP self._cores = [] DCNL DCSP  DCSP for (i, size) in enumerate(layers, start=1): DCNL DCSP  DCSP  DCSP name = 'lstm_{}'.format(i) DCNL DCSP  DCSP  DCSP init = _get_layer_initializers(initializer, name, ('w_gates', 'b_gates')) DCNL DCSP  DCSP  DCSP self._cores.append(snt.LSTM(size, name=name, initializers=init)) DCNL DCSP  DCSP self._rnn = snt.DeepRNN(self._cores, skip_connections=False, name='deep_rnn') DCNL DCSP  DCSP init = _get_layer_initializers(initializer, 'linear', ('w', 'b')) DCNL DCSP  DCSP self._linear = snt.Linear(output_size, name='linear', initializers=init)
def _build(self, inputs, prev_state): DCNL DCSP inputs = self._preprocess(tf.expand_dims(inputs, (-1))) DCNL DCSP inputs = tf.reshape(inputs, [inputs.get_shape().as_list()[0], (-1)]) DCNL DCSP (output, next_state) = self._rnn(inputs, prev_state) DCNL DCSP return ((self._linear(output) * self._scale), next_state)
def __init__(self, name='cw_deep_lstm', **kwargs): DCNL DCSP super(CoordinateWiseDeepLSTM, self).__init__(1, name=name, **kwargs)
def _build(self, inputs, prev_state): DCNL DCSP input_shape = inputs.get_shape().as_list() DCNL DCSP reshaped_inputs = self._reshape_inputs(inputs) DCNL DCSP build_fn = super(CoordinateWiseDeepLSTM, self)._build DCNL DCSP (output, next_state) = build_fn(reshaped_inputs, prev_state) DCNL DCSP return (tf.reshape(output, input_shape), next_state)
def __init__(self, kernel_shape, name='kernel_deep_lstm', **kwargs): DCNL DCSP self._kernel_shape = kernel_shape DCNL DCSP output_size = np.prod(kernel_shape) DCNL DCSP super(KernelDeepLSTM, self).__init__(output_size, name=name, **kwargs)
def _build(self, inputs, prev_state): DCNL DCSP input_shape = inputs.get_shape().as_list() DCNL DCSP reshaped_inputs = self._reshape_inputs(inputs) DCNL DCSP build_fn = super(KernelDeepLSTM, self)._build DCNL DCSP (output, next_state) = build_fn(reshaped_inputs, prev_state) DCNL DCSP transposed_output = tf.transpose(output, [1, 0]) DCNL DCSP return (tf.reshape(transposed_output, input_shape), next_state)
def initial_state_for_inputs(self, inputs, **kwargs): DCNL DCSP reshaped_inputs = self._reshape_inputs(inputs) DCNL DCSP return super(KernelDeepLSTM, self).initial_state_for_inputs(reshaped_inputs, **kwargs)
def __init__(self, learning_rate=0.001, name='sgd'): DCNL DCSP super(Sgd, self).__init__(name=name) DCNL DCSP self._learning_rate = learning_rate
def __init__(self, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08, name='adam'): DCNL DCSP super(Adam, self).__init__(name=name) DCNL DCSP self._learning_rate = learning_rate DCNL DCSP self._beta1 = beta1 DCNL DCSP self._beta2 = beta2 DCNL DCSP self._epsilon = epsilon
def _build(self, g, prev_state): DCNL DCSP b1 = self._beta1 DCNL DCSP b2 = self._beta2 DCNL DCSP g_shape = g.get_shape().as_list() DCNL DCSP g = tf.reshape(g, ((-1), 1)) DCNL DCSP (t, m, v) = prev_state DCNL DCSP t_next = (t + 1) DCNL DCSP m_next = _update_adam_estimate(m, g, b1) DCNL DCSP m_hat = _debias_adam_estimate(m_next, b1, t_next) DCNL DCSP v_next = _update_adam_estimate(v, tf.square(g), b2) DCNL DCSP v_hat = _debias_adam_estimate(v_next, b2, t_next) DCNL DCSP update = (((- self._learning_rate) * m_hat) / (tf.sqrt(v_hat) + self._epsilon)) DCNL DCSP return (tf.reshape(update, g_shape), (t_next, m_next, v_next))
def testSimple(self): DCNL DCSP problem = problems.simple() DCNL DCSP optimizer = meta.MetaOptimizer(net=dict(net='CoordinateWiseDeepLSTM', net_options={'layers': (), 'initializer': 'zeros'})) DCNL DCSP minimize_ops = optimizer.meta_minimize(problem, 20, learning_rate=0.01) DCNL DCSP with self.test_session() as sess: DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP (cost, _) = train(sess, minimize_ops, 500, 5) DCNL DCSP self.assertLess(cost, 1e-05)
def _build(self, gradients): DCNL DCSP eps = np.finfo(gradients.dtype.as_numpy_dtype).eps DCNL DCSP ndims = gradients.get_shape().ndims DCNL DCSP log = tf.log((tf.abs(gradients) + eps)) DCNL DCSP clamped_log = Clamp(min_value=(-1.0))((log / self._k)) DCNL DCSP sign = Clamp(min_value=(-1.0), max_value=1.0)((gradients * np.exp(self._k))) DCNL DCSP return tf.concat([clamped_log, sign], (ndims - 1))
def setUp(self): DCNL DCSP pass
def tearDown(self): DCNL DCSP self.resetExtraLogItems()
def shortDescription(self): DCNL DCSP return None
def _printTestHeader(self): DCNL DCSP print '###############################################################' DCNL DCSP print ('Running DCSP test: DCSP %s.%s...' % (self.__class__, self._testMethodName))
def _setDataPath(self, env): DCNL DCSP assert (env is not None) DCNL DCSP if ('NTA_DATA_PATH' in env): DCNL DCSP  DCSP newPath = ('%s%s%s' % (env['NTA_DATA_PATH'], os.pathsep, g_myEnv.testSrcDataDir)) DCNL DCSP else: DCNL DCSP  DCSP newPath = g_myEnv.testSrcDataDir DCNL DCSP env['NTA_DATA_PATH'] = newPath
def _launchWorkers(self, cmdLine, numWorkers): DCNL DCSP workers = [] DCNL DCSP for i in range(numWorkers): DCNL DCSP  DCSP stdout = tempfile.TemporaryFile() DCNL DCSP  DCSP stderr = tempfile.TemporaryFile() DCNL DCSP  DCSP p = subprocess.Popen(cmdLine, bufsize=1, env=os.environ, shell=True, stdin=None, stdout=stdout, stderr=stderr) DCNL DCSP  DCSP workers.append(p) DCNL DCSP return workers
def _getJobInfo(self, cjDAO, workers, jobID): DCNL DCSP jobInfo = cjDAO.jobInfo(jobID) DCNL DCSP runningCount = 0 DCNL DCSP for worker in workers: DCNL DCSP  DCSP retCode = worker.poll() DCNL DCSP  DCSP if (retCode is None): DCNL DCSP  DCSP  DCSP runningCount += 1 DCNL DCSP if (runningCount > 0): DCNL DCSP  DCSP status = ClientJobsDAO.STATUS_RUNNING DCNL DCSP else: DCNL DCSP  DCSP status = ClientJobsDAO.STATUS_COMPLETED DCNL DCSP jobInfo = jobInfo._replace(status=status) DCNL DCSP if (status == ClientJobsDAO.STATUS_COMPLETED): DCNL DCSP  DCSP jobInfo = jobInfo._replace(completionReason=ClientJobsDAO.CMPL_REASON_SUCCESS) DCNL DCSP return jobInfo
def _generateHSJobParams(self, expDirectory=None, hsImp='v2', maxModels=2, predictionCacheMaxRecords=None, dataPath=None, maxRecords=10): DCNL DCSP if (expDirectory is not None): DCNL DCSP  DCSP descriptionPyPath = os.path.join(expDirectory, 'description.py') DCNL DCSP  DCSP permutationsPyPath = os.path.join(expDirectory, 'permutations.py') DCNL DCSP  DCSP permutationsPyContents = open(permutationsPyPath, 'r').read() DCNL DCSP  DCSP descriptionPyContents = open(descriptionPyPath, 'r').read() DCNL DCSP  DCSP jobParams = {'persistentJobGUID': generatePersistentJobGUID(), 'permutationsPyContents': permutationsPyContents, 'descriptionPyContents': descriptionPyContents, 'maxModels': maxModels, 'hsVersion': hsImp} DCNL DCSP  DCSP if (predictionCacheMaxRecords is not None): DCNL DCSP  DCSP  DCSP jobParams['predictionCacheMaxRecords'] = predictionCacheMaxRecords DCNL DCSP else: DCNL DCSP  DCSP if (dataPath is None): DCNL DCSP  DCSP  DCSP dataPath = resource_filename('nupic.data', os.path.join('extra', 'qa', 'hotgym', 'qa_hotgym.csv')) DCNL DCSP  DCSP streamDef = dict(version=1, info='TestHypersearch', streams=[dict(source=('file://%s' % dataPath), info=dataPath, columns=['*'], first_record=0, last_record=maxRecords)]) DCNL DCSP  DCSP expDesc = {'predictionField': 'consumption', 'streamDef': streamDef, 'includedFields': [{'fieldName': 'gym', 'fieldType': 'string'}, {'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 0, 'maxValue': 200}], 'iterationCount': maxRecords, 'resetPeriod': {'weeks': 0, 'days': 0, 'hours': 8, 'minutes': 0, 'seconds': 0, 'milliseconds': 0, 'microseconds': 0}} DCNL DCSP  DCSP jobParams = {'persistentJobGUID': generatePersistentJobGUID(), 'description': expDesc, 'maxModels': maxModels, 'hsVersion': hsImp} DCNL DCSP  DCSP if (predictionCacheMaxRecords is not None): DCNL DCSP  DCSP  DCSP jobParams['predictionCacheMaxRecords'] = predictionCacheMaxRecords DCNL DCSP return jobParams
def _runPermutationsLocal(self, jobParams, loggingLevel=logging.INFO, env=None, waitForCompletion=True, continueJobId=None, ignoreErrModels=False): DCNL DCSP print DCNL DCSP print '==================================================================' DCNL DCSP print 'Running DCSP Hypersearch DCSP job DCSP using DCSP 1 DCSP worker DCSP in DCSP current DCSP process' DCNL DCSP print '==================================================================' DCNL DCSP if (env is not None): DCNL DCSP  DCSP saveEnvState = copy.deepcopy(os.environ) DCNL DCSP  DCSP os.environ.update(env) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP if (continueJobId is None): DCNL DCSP  DCSP jobID = cjDAO.jobInsert(client='test', cmdLine='<started DCSP manually>', params=json.dumps(jobParams), alreadyRunning=True, minimumWorkers=1, maximumWorkers=1, jobType=cjDAO.JOB_TYPE_HS) DCNL DCSP else: DCNL DCSP  DCSP jobID = continueJobId DCNL DCSP args = ['ignoreThis', ('--jobID=%d' % jobID), ('--logLevel=%d' % loggingLevel)] DCNL DCSP if (continueJobId is None): DCNL DCSP  DCSP args.append('--clearModels') DCNL DCSP try: DCNL DCSP  DCSP hypersearch_worker.main(args) DCNL DCSP except SystemExit: DCNL DCSP  DCSP pass DCNL DCSP except: DCNL DCSP  DCSP raise DCNL DCSP if (env is not None): DCNL DCSP  DCSP os.environ = saveEnvState DCNL DCSP models = cjDAO.modelsGetUpdateCounters(jobID) DCNL DCSP modelIDs = [model.modelId for model in models] DCNL DCSP if (len(modelIDs) > 0): DCNL DCSP  DCSP results = cjDAO.modelsGetResultAndStatus(modelIDs) DCNL DCSP else: DCNL DCSP  DCSP results = [] DCNL DCSP metricResults = [] DCNL DCSP for result in results: DCNL DCSP  DCSP if (result.results is not None): DCNL DCSP  DCSP  DCSP metricResults.append(json.loads(result.results)[1].values()[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP metricResults.append(None) DCNL DCSP  DCSP if (not ignoreErrModels): DCNL DCSP  DCSP  DCSP self.assertNotEqual(result.completionReason, cjDAO.CMPL_REASON_ERROR, ('Model DCSP did DCSP not DCSP complete DCSP successfully:\n%s' % result.completionMsg)) DCNL DCSP jobInfo = cjDAO.jobInfo(jobID) DCNL DCSP return (jobID, jobInfo, results, metricResults)
def _runPermutationsCluster(self, jobParams, loggingLevel=logging.INFO, maxNumWorkers=4, env=None, waitForCompletion=True, ignoreErrModels=False, timeoutSec=DEFAULT_JOB_TIMEOUT_SEC): DCNL DCSP print DCNL DCSP print '==================================================================' DCNL DCSP print 'Running DCSP Hypersearch DCSP job DCSP on DCSP cluster' DCNL DCSP print '==================================================================' DCNL DCSP if ((env is not None) and (len(env) > 0)): DCNL DCSP  DCSP envItems = [] DCNL DCSP  DCSP for (key, value) in env.iteritems(): DCNL DCSP  DCSP  DCSP if sys.platform.startswith('win'): DCNL DCSP  DCSP  DCSP  DCSP envItems.append(('set DCSP "%s=%s"' % (key, value))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP envItems.append(('export DCSP %s=%s' % (key, value))) DCNL DCSP  DCSP if sys.platform.startswith('win'): DCNL DCSP  DCSP  DCSP envStr = ('%s DCSP &' % ' DCSP & DCSP '.join(envItems)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP envStr = ('%s;' % ';'.join(envItems)) DCNL DCSP else: DCNL DCSP  DCSP envStr = '' DCNL DCSP cmdLine = ('%s DCSP python DCSP -m DCSP nupic.swarming.hypersearch_worker DCSP --jobID={JOBID} DCSP --logLevel=%d' % (envStr, loggingLevel)) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobID = cjDAO.jobInsert(client='test', cmdLine=cmdLine, params=json.dumps(jobParams), minimumWorkers=1, maximumWorkers=maxNumWorkers, jobType=cjDAO.JOB_TYPE_HS) DCNL DCSP workerCmdLine = ('%s DCSP python DCSP -m DCSP nupic.swarming.hypersearch_worker DCSP --jobID=%d DCSP --logLevel=%d' % (envStr, jobID, loggingLevel)) DCNL DCSP workers = self._launchWorkers(cmdLine=workerCmdLine, numWorkers=maxNumWorkers) DCNL DCSP print ('Successfully DCSP submitted DCSP new DCSP test DCSP job, DCSP jobID=%d' % jobID) DCNL DCSP print ('Each DCSP of DCSP %d DCSP workers DCSP executing DCSP the DCSP command DCSP line: DCSP ' % maxNumWorkers), cmdLine DCNL DCSP if (not waitForCompletion): DCNL DCSP  DCSP return (jobID, None, None) DCNL DCSP if (timeoutSec is None): DCNL DCSP  DCSP timeout = DEFAULT_JOB_TIMEOUT_SEC DCNL DCSP else: DCNL DCSP  DCSP timeout = timeoutSec DCNL DCSP startTime = time.time() DCNL DCSP lastUpdate = time.time() DCNL DCSP lastCompleted = 0 DCNL DCSP lastCompletedWithError = 0 DCNL DCSP lastCompletedAsOrphan = 0 DCNL DCSP lastStarted = 0 DCNL DCSP lastJobStatus = 'NA' DCNL DCSP lastJobResults = None DCNL DCSP lastActiveSwarms = None DCNL DCSP lastEngStatus = None DCNL DCSP modelIDs = [] DCNL DCSP print ('\n%-15s DCSP  DCSP  DCSP  DCSP %-15s DCSP %-15s DCSP %-15s DCSP %-15s' % ('jobStatus', 'modelsStarted', 'modelsCompleted', 'modelErrs', 'modelOrphans')) DCNL DCSP print '-------------------------------------------------------------------' DCNL DCSP while ((lastJobStatus != ClientJobsDAO.STATUS_COMPLETED) and ((time.time() - lastUpdate) < timeout)): DCNL DCSP  DCSP printUpdate = False DCNL DCSP  DCSP if (g_myEnv.options.verbosity == 0): DCNL DCSP  DCSP  DCSP time.sleep(0.5) DCNL DCSP  DCSP jobInfo = self._getJobInfo(cjDAO, workers, jobID) DCNL DCSP  DCSP if (jobInfo.status != lastJobStatus): DCNL DCSP  DCSP  DCSP if ((jobInfo.status == ClientJobsDAO.STATUS_RUNNING) and (lastJobStatus != ClientJobsDAO.STATUS_RUNNING)): DCNL DCSP  DCSP  DCSP  DCSP print ('# DCSP Swarm DCSP job DCSP now DCSP running. DCSP jobID=%s' % jobInfo.jobId) DCNL DCSP  DCSP  DCSP lastJobStatus = jobInfo.status DCNL DCSP  DCSP  DCSP printUpdate = True DCNL DCSP  DCSP if (g_myEnv.options.verbosity >= 1): DCNL DCSP  DCSP  DCSP if (jobInfo.engWorkerState is not None): DCNL DCSP  DCSP  DCSP  DCSP activeSwarms = json.loads(jobInfo.engWorkerState)['activeSwarms'] DCNL DCSP  DCSP  DCSP  DCSP if (activeSwarms != lastActiveSwarms): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '>> DCSP Active DCSP swarms:\n DCSP  DCSP  DCSP ', '\n DCSP  DCSP  DCSP  DCSP '.join(activeSwarms) DCNL DCSP  DCSP  DCSP  DCSP  DCSP lastActiveSwarms = activeSwarms DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP if (jobInfo.results != lastJobResults): DCNL DCSP  DCSP  DCSP  DCSP print '>> DCSP New DCSP best:', jobInfo.results, '###' DCNL DCSP  DCSP  DCSP  DCSP lastJobResults = jobInfo.results DCNL DCSP  DCSP  DCSP if (jobInfo.engStatus != lastEngStatus): DCNL DCSP  DCSP  DCSP  DCSP print ('>> DCSP Status: DCSP "%s"' % jobInfo.engStatus) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP lastEngStatus = jobInfo.engStatus DCNL DCSP  DCSP modelCounters = cjDAO.modelsGetUpdateCounters(jobID) DCNL DCSP  DCSP if (len(modelCounters) != lastStarted): DCNL DCSP  DCSP  DCSP modelIDs = [x.modelId for x in modelCounters] DCNL DCSP  DCSP  DCSP lastStarted = len(modelCounters) DCNL DCSP  DCSP  DCSP printUpdate = True DCNL DCSP  DCSP if (len(modelIDs) > 0): DCNL DCSP  DCSP  DCSP completed = 0 DCNL DCSP  DCSP  DCSP completedWithError = 0 DCNL DCSP  DCSP  DCSP completedAsOrphan = 0 DCNL DCSP  DCSP  DCSP infos = cjDAO.modelsGetResultAndStatus(modelIDs) DCNL DCSP  DCSP  DCSP for info in infos: DCNL DCSP  DCSP  DCSP  DCSP if (info.status == ClientJobsDAO.STATUS_COMPLETED): DCNL DCSP  DCSP  DCSP  DCSP  DCSP completed += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (info.completionReason == ClientJobsDAO.CMPL_REASON_ERROR): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP completedWithError += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (info.completionReason == ClientJobsDAO.CMPL_REASON_ORPHAN): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP completedAsOrphan += 1 DCNL DCSP  DCSP  DCSP if ((completed != lastCompleted) or (completedWithError != lastCompletedWithError) or (completedAsOrphan != lastCompletedAsOrphan)): DCNL DCSP  DCSP  DCSP  DCSP lastCompleted = completed DCNL DCSP  DCSP  DCSP  DCSP lastCompletedWithError = completedWithError DCNL DCSP  DCSP  DCSP  DCSP lastCompletedAsOrphan = completedAsOrphan DCNL DCSP  DCSP  DCSP  DCSP printUpdate = True DCNL DCSP  DCSP if printUpdate: DCNL DCSP  DCSP  DCSP lastUpdate = time.time() DCNL DCSP  DCSP  DCSP if (g_myEnv.options.verbosity >= 1): DCNL DCSP  DCSP  DCSP  DCSP print '>>', DCNL DCSP  DCSP  DCSP print ('%-15s DCSP %-15d DCSP %-15d DCSP %-15d DCSP %-15d' % (lastJobStatus, lastStarted, lastCompleted, lastCompletedWithError, lastCompletedAsOrphan)) DCNL DCSP print ('\n<< DCSP %-15s DCSP %-15d DCSP %-15d DCSP %-15d DCSP %-15d' % (lastJobStatus, lastStarted, lastCompleted, lastCompletedWithError, lastCompletedAsOrphan)) DCNL DCSP jobInfo = self._getJobInfo(cjDAO, workers, jobID) DCNL DCSP if (not ignoreErrModels): DCNL DCSP  DCSP self.assertEqual(jobInfo.completionReason, ClientJobsDAO.CMPL_REASON_SUCCESS) DCNL DCSP models = cjDAO.modelsGetUpdateCounters(jobID) DCNL DCSP modelIDs = [model.modelId for model in models] DCNL DCSP if (len(modelIDs) > 0): DCNL DCSP  DCSP results = cjDAO.modelsGetResultAndStatus(modelIDs) DCNL DCSP else: DCNL DCSP  DCSP results = [] DCNL DCSP metricResults = [] DCNL DCSP for result in results: DCNL DCSP  DCSP if (result.results is not None): DCNL DCSP  DCSP  DCSP metricResults.append(json.loads(result.results)[1].values()[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP metricResults.append(None) DCNL DCSP  DCSP if (not ignoreErrModels): DCNL DCSP  DCSP  DCSP self.assertNotEqual(result.completionReason, cjDAO.CMPL_REASON_ERROR, ('Model DCSP did DCSP not DCSP complete DCSP successfully:\n%s' % result.completionMsg)) DCNL DCSP return (jobID, jobInfo, results, metricResults)
def runPermutations(self, expDirectory, hsImp='v2', maxModels=2, maxNumWorkers=4, loggingLevel=logging.INFO, onCluster=False, env=None, waitForCompletion=True, continueJobId=None, dataPath=None, maxRecords=None, timeoutSec=None, ignoreErrModels=False, predictionCacheMaxRecords=None, **kwargs): DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP self._setDataPath(env) DCNL DCSP jobParams = self._generateHSJobParams(expDirectory=expDirectory, hsImp=hsImp, maxModels=maxModels, maxRecords=maxRecords, dataPath=dataPath, predictionCacheMaxRecords=predictionCacheMaxRecords) DCNL DCSP jobParams.update(kwargs) DCNL DCSP if onCluster: DCNL DCSP  DCSP (jobID, jobInfo, resultInfos, metricResults) = self._runPermutationsCluster(jobParams=jobParams, loggingLevel=loggingLevel, maxNumWorkers=maxNumWorkers, env=env, waitForCompletion=waitForCompletion, ignoreErrModels=ignoreErrModels, timeoutSec=timeoutSec) DCNL DCSP else: DCNL DCSP  DCSP (jobID, jobInfo, resultInfos, metricResults) = self._runPermutationsLocal(jobParams=jobParams, loggingLevel=loggingLevel, env=env, waitForCompletion=waitForCompletion, continueJobId=continueJobId, ignoreErrModels=ignoreErrModels) DCNL DCSP if (not waitForCompletion): DCNL DCSP  DCSP return (jobID, jobInfo, resultInfos, metricResults, None) DCNL DCSP print '\n------------------------------------------------------------------' DCNL DCSP print ('Hadoop DCSP completion DCSP reason: DCSP %s' % jobInfo.completionReason) DCNL DCSP print ('Worker DCSP completion DCSP reason: DCSP %s' % jobInfo.workerCompletionReason) DCNL DCSP print ('Worker DCSP completion DCSP msg: DCSP %s' % jobInfo.workerCompletionMsg) DCNL DCSP if (jobInfo.engWorkerState is not None): DCNL DCSP  DCSP print '\nEngine DCSP worker DCSP state:' DCNL DCSP  DCSP print '---------------------------------------------------------------' DCNL DCSP  DCSP pprint.pprint(json.loads(jobInfo.engWorkerState)) DCNL DCSP minErrScore = None DCNL DCSP metricAmts = [] DCNL DCSP for result in metricResults: DCNL DCSP  DCSP if (result is None): DCNL DCSP  DCSP  DCSP metricAmts.append(numpy.inf) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP metricAmts.append(result) DCNL DCSP metricAmts = numpy.array(metricAmts) DCNL DCSP if (len(metricAmts) > 0): DCNL DCSP  DCSP minErrScore = metricAmts.min() DCNL DCSP  DCSP minModelID = resultInfos[metricAmts.argmin()].modelId DCNL DCSP  DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP  DCSP modelParams = cjDAO.modelsGetParams([minModelID])[0].params DCNL DCSP  DCSP print ('Model DCSP params DCSP for DCSP best DCSP model: DCSP \n%s' % pprint.pformat(json.loads(modelParams))) DCNL DCSP  DCSP print ('Best DCSP model DCSP result: DCSP %f' % minErrScore) DCNL DCSP else: DCNL DCSP  DCSP print 'No DCSP models DCSP finished' DCNL DCSP return (jobID, jobInfo, resultInfos, metricResults, minErrScore)
def testSimpleV2(self, onCluster=False, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simpleV2') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, **kwargs) DCNL DCSP self.assertEqual(minErrScore, 20) DCNL DCSP self.assertLess(len(resultInfos), 350) DCNL DCSP return
def testDeltaV2(self, onCluster=False, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'delta') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP env['NTA_TEST_exitAfterNModels'] = str(20) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, **kwargs) DCNL DCSP self.assertLess(minErrScore, 0.002) DCNL DCSP return
def testSimpleV2NoSpeculation(self, onCluster=False, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simpleV2') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, speculativeParticles=False, **kwargs) DCNL DCSP self.assertEqual(minErrScore, 20) DCNL DCSP self.assertGreater(len(resultInfos), 1) DCNL DCSP self.assertLess(len(resultInfos), 350) DCNL DCSP return
def testHTMPredictionModelV2(self, onCluster=False, env=None, maxModels=2, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'dummyV2') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=maxModels, **kwargs) DCNL DCSP self.assertEqual(len(resultInfos), maxModels) DCNL DCSP return
def testCLAMultistepModel(self, onCluster=False, env=None, maxModels=2, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simple_cla_multistep') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=maxModels, **kwargs) DCNL DCSP self.assertEqual(len(resultInfos), maxModels) DCNL DCSP return
def testLegacyCLAMultistepModel(self, onCluster=False, env=None, maxModels=2, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'legacy_cla_multistep') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=maxModels, **kwargs) DCNL DCSP self.assertEqual(len(resultInfos), maxModels) DCNL DCSP return
def testFilterV2(self, onCluster=False): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simpleV2') DCNL DCSP env = dict() DCNL DCSP env['NTA_TEST_maxvalFilter'] = '225' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = '6' DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None) DCNL DCSP self.assertEqual(minErrScore, 45) DCNL DCSP self.assertLess(len(resultInfos), 400) DCNL DCSP return
def testLateWorker(self, onCluster=False): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simpleV2') DCNL DCSP env = dict() DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP env['NTA_TEST_exitAfterNModels'] = '100' DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, maxModels=None, onCluster=onCluster, env=env, waitForCompletion=True) DCNL DCSP self.assertEqual(len(resultInfos), 100) DCNL DCSP env.pop('NTA_TEST_exitAfterNModels') DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, maxModels=None, onCluster=onCluster, env=env, waitForCompletion=True, continueJobId=jobID) DCNL DCSP self.assertEqual(minErrScore, 20) DCNL DCSP self.assertLess(len(resultInfos), 350) DCNL DCSP return
def testOrphanedModel(self, onCluster=False, modelRange=(0, 1)): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simpleV2') DCNL DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '2' DCNL DCSP env['NTA_TEST_sysExitModelRange'] = ('%d,%d' % (modelRange[0], modelRange[1])) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, maxModels=300, onCluster=onCluster, env=env, waitForCompletion=False) DCNL DCSP (beg, end) = modelRange DCNL DCSP self.assertEqual(len(resultInfos), end) DCNL DCSP numRunning = 0 DCNL DCSP for res in resultInfos: DCNL DCSP  DCSP if (res.status == ClientJobsDAO.STATUS_RUNNING): DCNL DCSP  DCSP  DCSP numRunning += 1 DCNL DCSP self.assertEqual(numRunning, 1) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_modelOrphanIntervalSecs'] = '1' DCNL DCSP time.sleep(2) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, maxModels=300, onCluster=onCluster, env=env, waitForCompletion=True, continueJobId=jobID) DCNL DCSP self.assertEqual(minErrScore, 20) DCNL DCSP self.assertLess(len(resultInfos), 350) DCNL DCSP return
def testOrphanedModelGen1(self): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testOrphanedModel(modelRange=(10, 11))
def testErredModel(self, onCluster=False, modelRange=(6, 7)): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simpleV2') DCNL DCSP env = dict() DCNL DCSP env['NTA_TEST_errModelRange'] = ('%d,%d' % (modelRange[0], modelRange[1])) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, ignoreErrModels=True) DCNL DCSP self.assertEqual(minErrScore, 20) DCNL DCSP self.assertLess(len(resultInfos), 350) DCNL DCSP return
def testJobFailModel(self, onCluster=False, modelRange=(6, 7)): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simpleV2') DCNL DCSP env = dict() DCNL DCSP env['NTA_TEST_jobFailErr'] = 'True' DCNL DCSP maxNumWorkers = 4 DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, maxNumWorkers=maxNumWorkers, ignoreErrModels=True) DCNL DCSP self.assertEqual(jobInfo.workerCompletionReason, ClientJobsDAO.CMPL_REASON_ERROR) DCNL DCSP self.assertLess(len(resultInfos), (maxNumWorkers + 1)) DCNL DCSP return
def testTooManyErredModels(self, onCluster=False, modelRange=(5, 10)): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simpleV2') DCNL DCSP env = dict() DCNL DCSP env['NTA_TEST_errModelRange'] = ('%d,%d' % (modelRange[0], modelRange[1])) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, ignoreErrModels=True) DCNL DCSP self.assertEqual(jobInfo.workerCompletionReason, ClientJobsDAO.CMPL_REASON_ERROR) DCNL DCSP return
def testFieldThreshold(self, onCluster=False, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'field_threshold_temporal') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_max_field_branching'] = ('%d' % 0) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_minParticlesPerSwarm'] = ('%d' % 2) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_min_field_contribution'] = ('%f' % 100) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['attendance', 'visitor_winloss'])) DCNL DCSP self.assertEqual(params['particleState']['swarmId'], expectedSwarmId, ('Actual DCSP swarm DCSP id DCSP = DCSP %s\nExpcted DCSP swarm DCSP id DCSP = DCSP %s' % (params['particleState']['swarmId'], expectedSwarmId))) DCNL DCSP self.assertEqual(bestModel.optimizedMetric, 75) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_min_field_contribution'] = ('%f' % 20) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['attendance', 'home_winloss', 'visitor_winloss'])) DCNL DCSP self.assertEqual(params['particleState']['swarmId'], expectedSwarmId, ('Actual DCSP swarm DCSP id DCSP = DCSP %s\nExpcted DCSP swarm DCSP id DCSP = DCSP %s' % (params['particleState']['swarmId'], expectedSwarmId))) DCNL DCSP assert (bestModel.optimizedMetric == 55), bestModel.optimizedMetric DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_min_field_contribution'] = ('%f' % 0.0) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['attendance', 'home_winloss', 'precip', 'timestamp_dayOfWeek', 'timestamp_timeOfDay', 'visitor_winloss'])) DCNL DCSP self.assertEqual(params['particleState']['swarmId'], expectedSwarmId, ('Actual DCSP swarm DCSP id DCSP = DCSP %s\nExpcted DCSP swarm DCSP id DCSP = DCSP %s' % (params['particleState']['swarmId'], expectedSwarmId))) DCNL DCSP assert (bestModel.optimizedMetric == 25), bestModel.optimizedMetric
def testSpatialClassification(self, onCluster=False, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'spatial_classification') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, **kwargs) DCNL DCSP self.assertEqual(minErrScore, 20) DCNL DCSP self.assertLess(len(resultInfos), 350) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP actualFieldContributions = jobResults['fieldContributions'] DCNL DCSP print 'Actual DCSP field DCSP contributions:', pprint.pformat(actualFieldContributions) DCNL DCSP expectedFieldContributions = {'address': ((100 * (90.0 - 30)) / 90.0), 'gym': ((100 * (90.0 - 40)) / 90.0), 'timestamp_dayOfWeek': ((100 * (90.0 - 80.0)) / 90.0), 'timestamp_timeOfDay': ((100 * (90.0 - 90.0)) / 90.0)} DCNL DCSP for (key, value) in expectedFieldContributions.items(): DCNL DCSP  DCSP self.assertEqual(actualFieldContributions[key], value, ("actual DCSP field DCSP contribution DCSP from DCSP field DCSP '%s' DCSP does DCSP not DCSP match DCSP the DCSP expected DCSP value DCSP of DCSP %f" % (key, value))) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['address', 'gym'])) DCNL DCSP self.assertEqual(params['particleState']['swarmId'], expectedSwarmId, ('Actual DCSP swarm DCSP id DCSP = DCSP %s\nExpcted DCSP swarm DCSP id DCSP = DCSP %s' % (params['particleState']['swarmId'], expectedSwarmId))) DCNL DCSP return
def testAlwaysInputPredictedField(self, onCluster=False, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'input_predicted_field') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_inputPredictedField'] = 'auto' DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_minParticlesPerSwarm'] = ('%d' % 2) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, **kwargs) DCNL DCSP self.assertEqual(minErrScore, (-50)) DCNL DCSP self.assertLess(len(resultInfos), 350) DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_inputPredictedField'] = 'yes' DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_minParticlesPerSwarm'] = ('%d' % 2) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, **kwargs) DCNL DCSP self.assertEqual(minErrScore, (-40)) DCNL DCSP self.assertLess(len(resultInfos), 350) DCNL DCSP return
def testFieldThresholdNoPredField(self, onCluster=False, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'input_predicted_field') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_TEST_inputPredictedField'] = 'auto' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_max_field_branching'] = ('%d' % 0) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_minParticlesPerSwarm'] = ('%d' % 2) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_min_field_contribution'] = ('%f' % 0) DCNL DCSP if True: DCNL DCSP  DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP  DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP  DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP  DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP  DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP  DCSP params = json.loads(bestModel.params) DCNL DCSP  DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP  DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['address', 'gym', 'timestamp_dayOfWeek', 'timestamp_timeOfDay'])) DCNL DCSP  DCSP self.assertEqual(params['particleState']['swarmId'], expectedSwarmId, ('Actual DCSP swarm DCSP id DCSP = DCSP %s\nExpcted DCSP swarm DCSP id DCSP = DCSP %s' % (params['particleState']['swarmId'], expectedSwarmId))) DCNL DCSP  DCSP self.assertEqual(bestModel.optimizedMetric, (-50)) DCNL DCSP  DCSP actualFieldContributions = jobResults['fieldContributions'] DCNL DCSP  DCSP print 'Actual DCSP field DCSP contributions:', pprint.pformat(actualFieldContributions) DCNL DCSP  DCSP expectedFieldContributions = {'consumption': 0.0, 'address': ((100 * (60.0 - 40.0)) / 60.0), 'timestamp_timeOfDay': ((100 * (60.0 - 20.0)) / 60.0), 'timestamp_dayOfWeek': ((100 * (60.0 - 10.0)) / 60.0), 'gym': ((100 * (60.0 - 30.0)) / 60.0)} DCNL DCSP  DCSP for (key, value) in expectedFieldContributions.items(): DCNL DCSP  DCSP  DCSP self.assertEqual(actualFieldContributions[key], value, ("actual DCSP field DCSP contribution DCSP from DCSP field DCSP '%s' DCSP does DCSP not DCSP match DCSP the DCSP expected DCSP value DCSP of DCSP %f" % (key, value))) DCNL DCSP if True: DCNL DCSP  DCSP env['NTA_CONF_PROP_nupic_hypersearch_min_field_contribution'] = ('%f' % 55) DCNL DCSP  DCSP env['NTA_CONF_PROP_nupic_hypersearch_max_field_branching'] = ('%d' % 5) DCNL DCSP  DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP  DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP  DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP  DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP  DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP  DCSP params = json.loads(bestModel.params) DCNL DCSP  DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP  DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['timestamp_dayOfWeek', 'timestamp_timeOfDay'])) DCNL DCSP  DCSP self.assertEqual(params['particleState']['swarmId'], expectedSwarmId, ('Actual DCSP swarm DCSP id DCSP = DCSP %s\nExpcted DCSP swarm DCSP id DCSP = DCSP %s' % (params['particleState']['swarmId'], expectedSwarmId))) DCNL DCSP  DCSP self.assertEqual(bestModel.optimizedMetric, (-20)) DCNL DCSP  DCSP actualFieldContributions = jobResults['fieldContributions'] DCNL DCSP  DCSP print 'Actual DCSP field DCSP contributions:', pprint.pformat(actualFieldContributions) DCNL DCSP  DCSP expectedFieldContributions = {'consumption': 0.0, 'address': ((100 * (60.0 - 40.0)) / 60.0), 'timestamp_timeOfDay': ((100 * (60.0 - 20.0)) / 60.0), 'timestamp_dayOfWeek': ((100 * (60.0 - 10.0)) / 60.0), 'gym': ((100 * (60.0 - 30.0)) / 60.0)} DCNL DCSP  DCSP for (key, value) in expectedFieldContributions.items(): DCNL DCSP  DCSP  DCSP self.assertEqual(actualFieldContributions[key], value, ("actual DCSP field DCSP contribution DCSP from DCSP field DCSP '%s' DCSP does DCSP not DCSP match DCSP the DCSP expected DCSP value DCSP of DCSP %f" % (key, value))) DCNL DCSP if True: DCNL DCSP  DCSP env['NTA_CONF_PROP_nupic_hypersearch_min_field_contribution'] = ('%f' % 0) DCNL DCSP  DCSP env['NTA_CONF_PROP_nupic_hypersearch_max_field_branching'] = ('%d' % 3) DCNL DCSP  DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP  DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP  DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP  DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP  DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP  DCSP params = json.loads(bestModel.params) DCNL DCSP  DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP  DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['gym', 'timestamp_dayOfWeek', 'timestamp_timeOfDay'])) DCNL DCSP  DCSP self.assertEqual(params['particleState']['swarmId'], expectedSwarmId, ('Actual DCSP swarm DCSP id DCSP = DCSP %s\nExpcted DCSP swarm DCSP id DCSP = DCSP %s' % (params['particleState']['swarmId'], expectedSwarmId))) DCNL DCSP  DCSP self.assertEqual(bestModel.optimizedMetric, (-40)) DCNL DCSP if True: DCNL DCSP  DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP  DCSP env['NTA_CONF_PROP_nupic_hypersearch_max_field_branching'] = ('%d' % 0) DCNL DCSP  DCSP env['NTA_CONF_PROP_nupic_hypersearch_minParticlesPerSwarm'] = ('%d' % 5) DCNL DCSP  DCSP env['NTA_CONF_PROP_nupic_hypersearch_min_field_contribution'] = ('%f' % 0) DCNL DCSP  DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=10, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP  DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP  DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP  DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP  DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP  DCSP params = json.loads(bestModel.params) DCNL DCSP  DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP  DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['timestamp_dayOfWeek'])) DCNL DCSP  DCSP self.assertEqual(params['particleState']['swarmId'], expectedSwarmId, ('Actual DCSP swarm DCSP id DCSP = DCSP %s\nExpcted DCSP swarm DCSP id DCSP = DCSP %s' % (params['particleState']['swarmId'], expectedSwarmId))) DCNL DCSP  DCSP self.assertEqual(bestModel.optimizedMetric, 10) DCNL DCSP  DCSP actualFieldContributions = jobResults['fieldContributions'] DCNL DCSP  DCSP print 'Actual DCSP field DCSP contributions:', pprint.pformat(actualFieldContributions) DCNL DCSP  DCSP expectedFieldContributions = {'consumption': 0.0, 'address': ((100 * (60.0 - 40.0)) / 60.0), 'timestamp_timeOfDay': ((100 * (60.0 - 20.0)) / 60.0), 'timestamp_dayOfWeek': ((100 * (60.0 - 10.0)) / 60.0), 'gym': ((100 * (60.0 - 30.0)) / 60.0)}
def testSimpleV2(self): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testSimpleV2(onCluster=True)
def testDeltaV2(self): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testDeltaV2(onCluster=True)
def testSmartSpeculation(self, onCluster=True, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'smart_speculation_temporal') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_minParticlesPerSwarm'] = ('%d' % 1) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobInfoStr = cjDAO.jobGetFields(jobID, ['results', 'engWorkerState']) DCNL DCSP jobResultsStr = jobInfoStr[0] DCNL DCSP engState = jobInfoStr[1] DCNL DCSP engState = json.loads(engState) DCNL DCSP swarms = engState['swarms'] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP correctOrder = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'Pred'] DCNL DCSP correctOrder = [(prefix + x) for x in correctOrder] DCNL DCSP for swarm in swarms: DCNL DCSP  DCSP if (swarms[swarm]['status'] == 'killed'): DCNL DCSP  DCSP  DCSP swarmId = swarm.split('.') DCNL DCSP  DCSP  DCSP if (len(swarmId) > 1): DCNL DCSP  DCSP  DCSP  DCSP wrong = 0 DCNL DCSP  DCSP  DCSP  DCSP for i in range((len(swarmId) - 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (correctOrder[i] != swarmId[i]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP wrong = 1 DCNL DCSP  DCSP  DCSP  DCSP assert (wrong == 1), ('Some DCSP of DCSP the DCSP killed DCSP swarms DCSP should DCSP not DCSP have DCSP been DCSP ' + 'killed DCSP as DCSP they DCSP are DCSP a DCSP legal DCSP combination.') DCNL DCSP  DCSP if (swarms[swarm]['status'] == 'completed'): DCNL DCSP  DCSP  DCSP swarmId = swarm.split('.') DCNL DCSP  DCSP  DCSP if (len(swarmId) > 3): DCNL DCSP  DCSP  DCSP  DCSP for i in range((len(swarmId) - 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (correctOrder[i] != swarmId[i]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert False, 'Some DCSP of DCSP the DCSP completed DCSP swarms DCSP should DCSP not DCSP have DCSP finished DCSP as DCSP they DCSP are DCSP illegal DCSP combinations' DCNL DCSP  DCSP if (swarms[swarm]['status'] == 'active'): DCNL DCSP  DCSP  DCSP assert False, 'Some DCSP swarms DCSP are DCSP still DCSP active DCSP at DCSP the DCSP end DCSP of DCSP hypersearch' DCNL DCSP pass
def testSmartSpeculationSpatialClassification(self, onCluster=True, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'smart_speculation_spatial_classification') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_minParticlesPerSwarm'] = ('%d' % 1) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, maxNumWorkers=5, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobInfoStr = cjDAO.jobGetFields(jobID, ['results', 'engWorkerState']) DCNL DCSP jobResultsStr = jobInfoStr[0] DCNL DCSP engState = jobInfoStr[1] DCNL DCSP engState = json.loads(engState) DCNL DCSP swarms = engState['swarms'] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP correctOrder = ['A', 'B', 'C'] DCNL DCSP correctOrder = [(prefix + x) for x in correctOrder] DCNL DCSP for swarm in swarms: DCNL DCSP  DCSP if (swarms[swarm]['status'] == 'killed'): DCNL DCSP  DCSP  DCSP swarmId = swarm.split('.') DCNL DCSP  DCSP  DCSP if (len(swarmId) > 1): DCNL DCSP  DCSP  DCSP  DCSP if (correctOrder[0] in swarmId): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('Some DCSP of DCSP the DCSP killed DCSP swarms DCSP should DCSP not DCSP have DCSP been DCSP killed DCSP as DCSP they DCSP are DCSP a DCSP legal DCSP combination.') DCNL DCSP  DCSP elif (swarms[swarm]['status'] == 'completed'): DCNL DCSP  DCSP  DCSP swarmId = swarm.split('.') DCNL DCSP  DCSP  DCSP if (len(swarmId) >= 2): DCNL DCSP  DCSP  DCSP  DCSP for i in range((len(swarmId) - 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (correctOrder[i] != swarmId[i]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('Some DCSP of DCSP the DCSP completed DCSP swarms DCSP should DCSP not DCSP have DCSP finished DCSP as DCSP they DCSP are DCSP illegal DCSP combinations') DCNL DCSP  DCSP elif (swarms[swarm]['status'] == 'active'): DCNL DCSP  DCSP  DCSP raise RuntimeError('Some DCSP swarms DCSP are DCSP still DCSP active DCSP at DCSP the DCSP end DCSP of DCSP hypersearch')
def testFieldBranching(self, onCluster=True, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'max_branching_temporal') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_max_field_branching'] = ('%d' % 4) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_min_field_contribution'] = ('%f' % (-20.0)) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_minParticlesPerSwarm'] = ('%d' % 2) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['attendance', 'home_winloss', 'timestamp_dayOfWeek', 'timestamp_timeOfDay', 'visitor_winloss'])) DCNL DCSP assert (params['particleState']['swarmId'] == expectedSwarmId), params['particleState']['swarmId'] DCNL DCSP assert (bestModel.optimizedMetric == 432), bestModel.optimizedMetric DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_max_field_branching'] = ('%d' % 3) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['attendance', 'home_winloss', 'timestamp_timeOfDay', 'visitor_winloss'])) DCNL DCSP assert (params['particleState']['swarmId'] == expectedSwarmId), params['particleState']['swarmId'] DCNL DCSP assert (bestModel.optimizedMetric == 465), bestModel.optimizedMetric DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_max_field_branching'] = ('%d' % 5) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['attendance', 'home_winloss', 'precip', 'timestamp_dayOfWeek', 'timestamp_timeOfDay', 'visitor_winloss'])) DCNL DCSP assert (params['particleState']['swarmId'] == expectedSwarmId), params['particleState']['swarmId'] DCNL DCSP assert (bestModel.optimizedMetric == 390), bestModel.optimizedMetric DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_max_field_branching'] = ('%d' % 0) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=100, dummyModel={'iterations': 200}, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP bestModel = cjDAO.modelsInfo([jobResults['bestModel']])[0] DCNL DCSP params = json.loads(bestModel.params) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP expectedSwarmId = (prefix + ('.' + prefix).join(['attendance', 'daynight', 'visitor_winloss'])) DCNL DCSP assert (params['particleState']['swarmId'] == expectedSwarmId), params['particleState']['swarmId'] DCNL DCSP assert (bestModel.optimizedMetric == 406), bestModel.optimizedMetric DCNL DCSP return
def testFieldThreshold(self, onCluster=True, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testFieldThreshold(onCluster=True)
def testFieldContributions(self, onCluster=True, env=None, **kwargs): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'field_contrib_temporal') DCNL DCSP if (env is None): DCNL DCSP  DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, onCluster=onCluster, env=env, maxModels=None, **kwargs) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDAO.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP actualFieldContributions = jobResults['fieldContributions'] DCNL DCSP print 'Actual DCSP field DCSP contributions:', actualFieldContributions DCNL DCSP expectedFieldContributions = {'consumption': 0.0, 'address': 0.0, 'timestamp_timeOfDay': 20.0, 'timestamp_dayOfWeek': 50.0, 'gym': 10.0} DCNL DCSP for (key, value) in expectedFieldContributions.items(): DCNL DCSP  DCSP self.assertEqual(actualFieldContributions[key], value, ("actual DCSP field DCSP contribution DCSP from DCSP field DCSP '%s' DCSP does DCSP not DCSP match DCSP the DCSP expected DCSP value DCSP of DCSP %f" % (key, value))) DCNL DCSP return
def testHTMPredictionModelV2(self): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testHTMPredictionModelV2(onCluster=True, maxModels=4)
def testCLAMultistepModel(self): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testCLAMultistepModel(onCluster=True, maxModels=4)
def testLegacyCLAMultistepModel(self): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testLegacyCLAMultistepModel(onCluster=True, maxModels=4)
def testSimpleV2VariableWaits(self): DCNL DCSP self._printTestHeader() DCNL DCSP env = dict() DCNL DCSP env['NTA_TEST_variableWaits'] = 'True' DCNL DCSP env['NTA_TEST_numIterations'] = '100' DCNL DCSP inst = OneNodeTests('testSimpleV2') DCNL DCSP return inst.testSimpleV2(onCluster=True, env=env)
def testOrphanedModel(self, modelRange=(0, 2)): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'simpleV2') DCNL DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_TEST_sysExitModelRange'] = ('%d,%d' % (modelRange[0], modelRange[1])) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_modelOrphanIntervalSecs'] = '1' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, maxModels=500, onCluster=True, env=env, waitForCompletion=True, maxNumWorkers=4) DCNL DCSP self.assertEqual(minErrScore, 20) DCNL DCSP self.assertLess(len(resultInfos), 500) DCNL DCSP return
def testTwoOrphanedModels(self, modelRange=(0, 2)): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'oneField') DCNL DCSP env = dict() DCNL DCSP env['NTA_TEST_numIterations'] = '99' DCNL DCSP env['NTA_TEST_delayModelRange'] = ('%d,%d' % (modelRange[0], modelRange[1])) DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_modelOrphanIntervalSecs'] = '1' DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_swarmMaturityWindow'] = ('%d' % g_repeatableSwarmMaturityWindow) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, maxModels=100, onCluster=True, env=env, waitForCompletion=True, maxNumWorkers=4) DCNL DCSP self.assertEqual(minErrScore, 50) DCNL DCSP self.assertLess(len(resultInfos), 100) DCNL DCSP return
def testOrphanedModelGen1(self): DCNL DCSP self._printTestHeader() DCNL DCSP inst = MultiNodeTests(self._testMethodName) DCNL DCSP return inst.testOrphanedModel(modelRange=(10, 11))
def testOrphanedModelMaxModels(self): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'dummyV2') DCNL DCSP numModels = 5 DCNL DCSP env = dict() DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_modelOrphanIntervalSecs'] = '3' DCNL DCSP env['NTA_TEST_max_num_models'] = str(numModels) DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, maxModels=numModels, env=env, onCluster=True, waitForCompletion=True, dummyModel={'metricValue': ['25', '50'], 'sysExitModelRange': '0, DCSP 1', 'iterations': 20}) DCNL DCSP cjDB = ClientJobsDAO.get() DCNL DCSP self.assertGreaterEqual(len(resultInfos), (numModels + 1)) DCNL DCSP completionReasons = [x.completionReason for x in resultInfos] DCNL DCSP self.assertGreaterEqual(completionReasons.count(cjDB.CMPL_REASON_EOF), numModels) DCNL DCSP self.assertGreaterEqual(completionReasons.count(cjDB.CMPL_REASON_ORPHAN), 1)
def testOrphanedModelConnection(self): DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'dummy_multi_v2') DCNL DCSP numModels = 2 DCNL DCSP env = dict() DCNL DCSP env['NTA_CONF_PROP_nupic_hypersearch_modelOrphanIntervalSecs'] = '1' DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, maxModels=numModels, env=env, onCluster=True, waitForCompletion=True, dummyModel={'metricValue': ['25', '50'], 'sleepModelRange': '0, DCSP 1:5', 'iterations': 20}) DCNL DCSP cjDB = ClientJobsDAO.get() DCNL DCSP self.assertGreaterEqual(len(resultInfos), numModels, ('%d DCSP were DCSP run. DCSP Expecting DCSP %s' % (len(resultInfos), (numModels + 1)))) DCNL DCSP completionReasons = [x.completionReason for x in resultInfos] DCNL DCSP self.assertGreaterEqual(completionReasons.count(cjDB.CMPL_REASON_EOF), numModels) DCNL DCSP self.assertGreaterEqual(completionReasons.count(cjDB.CMPL_REASON_ORPHAN), 1)
def testErredModel(self, modelRange=(6, 7)): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testErredModel(onCluster=True)
def testJobFailModel(self): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testJobFailModel(onCluster=True)
def testTooManyErredModels(self, modelRange=(5, 10)): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testTooManyErredModels(onCluster=True)
def testSpatialClassification(self): DCNL DCSP self._printTestHeader() DCNL DCSP inst = OneNodeTests(self._testMethodName) DCNL DCSP return inst.testSpatialClassification(onCluster=True)
def testMatureInterleaved(self): DCNL DCSP self._printTestHeader() DCNL DCSP self.expDir = os.path.join(g_myEnv.testSrcExpDir, ('dummy_multi_v%d' % 2)) DCNL DCSP self.env['NTA_TEST_max_num_models'] = '2' DCNL DCSP (jobID, _, _, _, _) = self.runPermutations(self.expDir, hsImp=self.hsImp, maxModels=2, loggingLevel=g_myEnv.options.logLevel, env=self.env, onCluster=True, dummyModel={'metricFunctions': ['lambda DCSP x: DCSP -10*math.log10(x+1) DCSP +100', 'lambda DCSP x: DCSP 100.0'], 'delay': [2.0, 0.0], 'waitTime': [0.05, 0.01], 'iterations': 500, 'experimentDirectory': self.expDir}) DCNL DCSP cjDB = ClientJobsDAO.get() DCNL DCSP (modelIDs, records, completionReasons, matured) = zip(*self.getModelFields(jobID, ['numRecords', 'completionReason', 'engMatured'])) DCNL DCSP results = cjDB.jobGetFields(jobID, ['results'])[0] DCNL DCSP results = json.loads(results) DCNL DCSP self.assertEqual(results['bestModel'], modelIDs[0]) DCNL DCSP self.assertEqual(records[1], 500) DCNL DCSP self.assertTrue(((records[0] > 100) and (records[0] < 500)), ('Model DCSP 2 DCSP num DCSP records: DCSP 100 DCSP < DCSP %d DCSP < DCSP 500 DCSP ' % records[1])) DCNL DCSP self.assertEqual(completionReasons[1], cjDB.CMPL_REASON_EOF) DCNL DCSP self.assertEqual(completionReasons[0], cjDB.CMPL_REASON_STOPPED) DCNL DCSP self.assertTrue(matured[0], True)
def testConstant(self): DCNL DCSP self._printTestHeader() DCNL DCSP (jobID, _, _, _, _) = self.runPermutations(self.expDir, hsImp=self.hsImp, maxModels=1, loggingLevel=g_myEnv.options.logLevel, env=self.env, dummyModel={'metricFunctions': ['lambda DCSP x: DCSP 100'], 'iterations': 350, 'experimentDirectory': self.expDir}) DCNL DCSP cjDB = ClientJobsDAO.get() DCNL DCSP modelIDs = cjDB.jobGetModelIDs(jobID) DCNL DCSP dbResults = cjDB.modelsGetFields(modelIDs, ['numRecords', 'completionReason', 'engMatured']) DCNL DCSP modelIDs = [x[0] for x in dbResults] DCNL DCSP records = [x[1][0] for x in dbResults] DCNL DCSP completionReasons = [x[1][1] for x in dbResults] DCNL DCSP matured = [x[1][2] for x in dbResults] DCNL DCSP results = cjDB.jobGetFields(jobID, ['results'])[0] DCNL DCSP results = json.loads(results) DCNL DCSP self.assertEqual(results['bestModel'], min(modelIDs)) DCNL DCSP self.assertEqual(records[0], 350) DCNL DCSP self.assertEqual(completionReasons[0], cjDB.CMPL_REASON_EOF) DCNL DCSP self.assertEqual(matured[0], True)
def testSimple(self, useCluster=False): DCNL DCSP if (not g_myEnv.options.runInProc): DCNL DCSP  DCSP self.skipTest('Skipping DCSP One DCSP Node DCSP test DCSP since DCSP runInProc DCSP is DCSP not DCSP specified') DCNL DCSP self._printTestHeader() DCNL DCSP expDir = os.path.join(g_myEnv.testSrcExpDir, 'swarm_v2') DCNL DCSP (jobID, jobInfo, resultInfos, metricResults, minErrScore) = self.runPermutations(expDir, hsImp='v2', loggingLevel=g_myEnv.options.logLevel, maxModels=None, onCluster=useCluster, env=self.env, dummyModel={'iterations': 200}) DCNL DCSP cjDB = ClientJobsDAO.get() DCNL DCSP jobResultsStr = cjDB.jobGetFields(jobID, ['results'])[0] DCNL DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP terminatedSwarms = jobResults['terminatedSwarms'] DCNL DCSP swarmMaturityWindow = int(configuration.Configuration.get('nupic.hypersearch.swarmMaturityWindow')) DCNL DCSP prefix = 'modelParams|sensorParams|encoders|' DCNL DCSP for (swarm, (generation, scores)) in terminatedSwarms.iteritems(): DCNL DCSP  DCSP if ((prefix + 'gym') in swarm.split('.')): DCNL DCSP  DCSP  DCSP self.assertEqual(generation, (swarmMaturityWindow - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.assertEqual(generation, ((swarmMaturityWindow - 1) + 4))
@classmethod DCNL def _processArgs(cls): DCNL DCSP helpString = '%prog DCSP [options...] DCSP [-- DCSP unittestoptions...] DCSP [suitename.testname DCSP | DCSP suitename]\n DCSP  DCSP  DCSP  DCSP Run DCSP the DCSP Hypersearch DCSP unit DCSP tests. DCSP To DCSP see DCSP unit DCSP test DCSP framework DCSP options, DCSP enter:\n DCSP  DCSP  DCSP  DCSP python DCSP %prog DCSP -- DCSP --help\n\n DCSP  DCSP  DCSP  DCSP Example DCSP usages:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP python DCSP %prog DCSP MultiNodeTests\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP python DCSP %prog DCSP MultiNodeTests.testOrphanedModel\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP python DCSP %prog DCSP -- DCSP MultiNodeTests.testOrphanedModel\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP python DCSP %prog DCSP -- DCSP --failfast\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP python DCSP %prog DCSP -- DCSP --failfast DCSP OneNodeTests.testOrphanedModel\n\n DCSP  DCSP  DCSP  DCSP Available DCSP suitename.testnames: DCSP ' DCNL DCSP allTests = _getTestList() DCNL DCSP for test in allTests: DCNL DCSP  DCSP helpString += ('\n DCSP  DCSP  DCSP  DCSP %s' % test) DCNL DCSP parser = OptionParser(helpString, conflict_handler='resolve') DCNL DCSP parser.add_option('--verbosity', default=0, type='int', help='Verbosity DCSP level, DCSP either DCSP 0, DCSP 1, DCSP 2, DCSP or DCSP 3 DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--runInProc', action='store_true', default=False, help='Run DCSP inProc DCSP tests, DCSP currently DCSP inProc DCSP are DCSP not DCSP being DCSP run DCSP by DCSP default DCSP  DCSP running. DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--logLevel', action='store', type='int', default=logging.INFO, help='override DCSP default DCSP log DCSP level. DCSP Pass DCSP in DCSP an DCSP integer DCSP value DCSP that DCSP represents DCSP the DCSP desired DCSP logging DCSP level DCSP (10=logging.DEBUG, DCSP 20=logging.INFO, DCSP etc.) DCSP [default: DCSP %default].') DCNL DCSP parser.add_option('--hs', dest='hsVersion', default=2, type='int', help='Hypersearch DCSP version DCSP (only DCSP 2 DCSP supported; DCSP 1 DCSP was DCSP deprecated) DCSP [default: DCSP %default].') DCNL DCSP return parser.parse_args(args=cls.args)
@classmethod DCNL def parseArgs(cls): DCNL DCSP return cls._processArgs()[0]
@classmethod DCNL def consumeArgs(cls): DCNL DCSP return cls._processArgs()[1]
def _testSequence(self, trainingSet, nSequencePresentations=1, tm=None, testSequences=None, doResets=True, relativeFrequencies=None): DCNL DCSP trainingSequences = trainingSet[0] DCNL DCSP trainingFrequencies = trainingSet[1] DCNL DCSP allTrainingPatterns = trainingSet[2] DCNL DCSP trainingCummulativeFrequencies = numpy.cumsum(trainingFrequencies) DCNL DCSP if (testSequences == None): DCNL DCSP  DCSP testSequences = trainingSequences DCNL DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP print '============= DCSP Learning DCSP =================' DCNL DCSP for r in xrange(nSequencePresentations): DCNL DCSP  DCSP whichSequence = numpy.searchsorted(trainingCummulativeFrequencies, _RGEN.random_sample()) DCNL DCSP  DCSP trainingSequence = trainingSequences[whichSequence] DCNL DCSP  DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP  DCSP print ('=========Presentation DCSP #%d DCSP Sequence DCSP #%d==============' % (r, whichSequence)) DCNL DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP for (t, x) in enumerate(trainingSequence): DCNL DCSP  DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP  DCSP print 'Time DCSP step', t DCNL DCSP  DCSP  DCSP  DCSP print 'Input: DCSP ', tm.printInput(x) DCNL DCSP  DCSP  DCSP tm.learn(x) DCNL DCSP  DCSP  DCSP if (VERBOSITY > 4): DCNL DCSP  DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY > 4)) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (VERBOSITY > 4): DCNL DCSP  DCSP  DCSP print 'Sequence DCSP finished. DCSP Complete DCSP state DCSP after DCSP sequence' DCNL DCSP  DCSP  DCSP tm.printCells() DCNL DCSP  DCSP  DCSP print DCNL DCSP tm.finishLearning() DCNL DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP print 'Training DCSP completed. DCSP Complete DCSP state:' DCNL DCSP  DCSP tm.printCells() DCNL DCSP  DCSP print DCNL DCSP  DCSP print 'TM DCSP parameters:' DCNL DCSP  DCSP print tm.printParameters() DCNL DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP print '============= DCSP Inference DCSP =================' DCNL DCSP testSequence = testSequences[0] DCNL DCSP slen = len(testSequence) DCNL DCSP tm.collectStats = True DCNL DCSP tm.resetStats() DCNL DCSP if doResets: DCNL DCSP  DCSP tm.reset() DCNL DCSP for (t, x) in enumerate(testSequence): DCNL DCSP  DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP  DCSP print 'Time DCSP step', t, '\nInput:', tm.printInput(x) DCNL DCSP  DCSP tm.infer(x) DCNL DCSP  DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP  DCSP tm.printStates(printPrevious=(VERBOSITY > 4), printLearnState=False) DCNL DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (t == (slen - 2)): DCNL DCSP  DCSP  DCSP tmNonZeros = [pattern.nonzero()[0] for pattern in allTrainingPatterns] DCNL DCSP  DCSP  DCSP predictionScore2 = tm._checkPrediction(tmNonZeros)[2] DCNL DCSP if (VERBOSITY > 0): DCNL DCSP  DCSP print 'predictionScore:', predictionScore2 DCNL DCSP patternConfidenceScores = numpy.array([x[1] for x in predictionScore2]) DCNL DCSP patternConfidenceScores /= patternConfidenceScores.sum() DCNL DCSP msg = ('Prediction DCSP failed DCSP with DCSP predictionScore: DCSP %s. DCSP Expected DCSP %s DCSP but DCSP got DCSP %s.' % (str(predictionScore2), str(relativeFrequencies), str(patternConfidenceScores[4:]))) DCNL DCSP self.assertLess(abs((patternConfidenceScores[4] - relativeFrequencies[0])), 0.1, msg=msg) DCNL DCSP self.assertLess(abs((patternConfidenceScores[5] - relativeFrequencies[1])), 0.1, msg=msg) DCNL DCSP self.assertLess(abs((patternConfidenceScores[6] - relativeFrequencies[2])), 0.1, msg=msg)
def testFastLearning(self): DCNL DCSP numOnBitsPerPattern = 3 DCNL DCSP baseParams = dict(seqFunction=buildOverlappedSequences, numSequences=2, seqLen=10, sharedElements=[2, 3], numOnBitsPerPattern=numOnBitsPerPattern, includeCPP=INCLUDE_CPP_TM, numCols=None, activationThreshold=numOnBitsPerPattern, minThreshold=numOnBitsPerPattern, newSynapseCount=numOnBitsPerPattern, initialPerm=0.6, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, nTrainRepetitions=8, doResets=True) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP 3 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=20, expMissingMax=None, pamLength=1, nTrainRepetitions=3)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP 3 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, pamLength=5, nTrainRepetitions=3))
def testSlowLearning(self): DCNL DCSP numOnBitsPerPattern = 3 DCNL DCSP baseParams = dict(seqFunction=buildOverlappedSequences, numSequences=2, seqLen=10, sharedElements=[2, 3], numOnBitsPerPattern=numOnBitsPerPattern, includeCPP=INCLUDE_CPP_TM, numCols=None, activationThreshold=numOnBitsPerPattern, minThreshold=numOnBitsPerPattern, newSynapseCount=numOnBitsPerPattern, initialPerm=0.11, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, nTrainRepetitions=8, doResets=True) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP 10 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=10, expMissingMax=None, pamLength=1, nTrainRepetitions=10)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP 10 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, pamLength=6, nTrainRepetitions=10))
def testSlowLearningWithOverlap(self): DCNL DCSP if SHORT: DCNL DCSP  DCSP self.skipTest('Test DCSP skipped DCSP by DCSP default. DCSP Enable DCSP with DCSP --long.') DCNL DCSP numOnBitsPerPattern = 5 DCNL DCSP baseParams = dict(seqFunction=buildOverlappedSequences, numSequences=2, seqLen=10, sharedElements=[2, 3], numOnBitsPerPattern=numOnBitsPerPattern, patternOverlap=2, includeCPP=INCLUDE_CPP_TM, numCols=None, activationThreshold=int((0.8 * numOnBitsPerPattern)), minThreshold=int((0.8 * numOnBitsPerPattern)), newSynapseCount=numOnBitsPerPattern, initialPerm=0.11, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, nTrainRepetitions=8, doResets=True) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP 10 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=10, expMissingMax=None, pamLength=1, nTrainRepetitions=10)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP 10 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, pamLength=6, nTrainRepetitions=10))
def testForbesLikeData(self): DCNL DCSP if SHORT: DCNL DCSP  DCSP self.skipTest('Test DCSP skipped DCSP by DCSP default. DCSP Enable DCSP with DCSP --long.') DCNL DCSP numOnBitsPerPattern = 3 DCNL DCSP baseParams = dict(seqFunction=buildSequencePool, numSequences=20, seqLen=[3, 10], numPatterns=10, numOnBitsPerPattern=numOnBitsPerPattern, patternOverlap=1, includeCPP=INCLUDE_CPP_TM, numCols=None, activationThreshold=int((0.8 * numOnBitsPerPattern)), minThreshold=int((0.8 * numOnBitsPerPattern)), newSynapseCount=numOnBitsPerPattern, initialPerm=0.51, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, checkSynapseConsistency=False, nTrainRepetitions=8, doResets=True) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP fast DCSP learning, DCSP 2 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=50, expMissingMax=None, pamLength=1, nTrainRepetitions=2)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP fast DCSP learning, DCSP 2 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, pamLength=5, nTrainRepetitions=2)) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP slow DCSP learning, DCSP 8 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=1, expMissingMax=None, initialPerm=0.31, pamLength=1, nTrainRepetitions=8)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP slow DCSP learning, DCSP 8 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(_testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, initialPerm=0.31, pamLength=5, nTrainRepetitions=8))
def runTestKNNClassifier(self, short=0): DCNL DCSP failures = '' DCNL DCSP if (short != 2): DCNL DCSP  DCSP numpy.random.seed(42) DCNL DCSP else: DCNL DCSP  DCSP seed_value = int(time.time()) DCNL DCSP  DCSP numpy.random.seed(seed_value) DCNL DCSP  DCSP LOGGER.info('Seed DCSP used: DCSP %d', seed_value) DCNL DCSP  DCSP f = open('seedval', 'a') DCNL DCSP  DCSP f.write(str(seed_value)) DCNL DCSP  DCSP f.write('\n') DCNL DCSP  DCSP f.close() DCNL DCSP failures += simulateKMoreThanOne() DCNL DCSP LOGGER.info('\nTesting DCSP KNN DCSP Classifier DCSP on DCSP dense DCSP patterns') DCNL DCSP (numPatterns, numClasses) = getNumTestPatterns(short) DCNL DCSP patternSize = 100 DCNL DCSP patterns = numpy.random.rand(numPatterns, patternSize) DCNL DCSP patternDict = dict() DCNL DCSP testDict = dict() DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP patternDict[i] = dict() DCNL DCSP  DCSP patternDict[i]['pattern'] = patterns[i] DCNL DCSP  DCSP patternDict[i]['category'] = numpy.random.randint(0, (numClasses - 1)) DCNL DCSP  DCSP testDict[i] = copy.deepcopy(patternDict[i]) DCNL DCSP  DCSP testDict[i]['pattern'][:int((0.02 * patternSize))] = numpy.random.rand() DCNL DCSP  DCSP testDict[i]['category'] = None DCNL DCSP LOGGER.info('\nTesting DCSP KNN DCSP Classifier DCSP with DCSP L2 DCSP norm') DCNL DCSP knn = KNNClassifier(k=1) DCNL DCSP failures += simulateClassifier(knn, patternDict, 'KNN DCSP Classifier DCSP with DCSP L2 DCSP norm DCSP test') DCNL DCSP LOGGER.info('\nTesting DCSP KNN DCSP Classifier DCSP with DCSP L1 DCSP norm') DCNL DCSP knnL1 = KNNClassifier(k=1, distanceNorm=1.0) DCNL DCSP failures += simulateClassifier(knnL1, patternDict, 'KNN DCSP Classifier DCSP with DCSP L1 DCSP norm DCSP test') DCNL DCSP LOGGER.info('\nTesting DCSP KNN DCSP Classifier DCSP with DCSP exact DCSP matching. DCSP For DCSP testing DCSP we DCSP slightly DCSP alter DCSP the DCSP training DCSP data DCSP and DCSP expect DCSP None DCSP to DCSP be DCSP returned DCSP for DCSP the DCSP classifications.') DCNL DCSP knnExact = KNNClassifier(k=1, exact=True) DCNL DCSP failures += simulateClassifier(knnExact, patternDict, 'KNN DCSP Classifier DCSP with DCSP exact DCSP matching DCSP test', testDict=testDict) DCNL DCSP (numPatterns, numClasses) = getNumTestPatterns(short) DCNL DCSP patterns = (numpy.random.rand(numPatterns, 25) > 0.7).astype(RealNumpyDType) DCNL DCSP patternDict = dict() DCNL DCSP for i in patterns: DCNL DCSP  DCSP iString = str(i.tolist()) DCNL DCSP  DCSP if (not patternDict.has_key(iString)): DCNL DCSP  DCSP  DCSP randCategory = numpy.random.randint(0, (numClasses - 1)) DCNL DCSP  DCSP  DCSP patternDict[iString] = dict() DCNL DCSP  DCSP  DCSP patternDict[iString]['pattern'] = i DCNL DCSP  DCSP  DCSP patternDict[iString]['category'] = randCategory DCNL DCSP LOGGER.info('\nTesting DCSP KNN DCSP on DCSP sparse DCSP patterns') DCNL DCSP knnDense = KNNClassifier(k=1) DCNL DCSP failures += simulateClassifier(knnDense, patternDict, 'KNN DCSP Classifier DCSP on DCSP sparse DCSP pattern DCSP test') DCNL DCSP self.assertEqual(len(failures), 0, ('Tests DCSP failed: DCSP \n' + failures)) DCNL DCSP if (short == 2): DCNL DCSP  DCSP f = open('seedval', 'a') DCNL DCSP  DCSP f.write('Pass\n') DCNL DCSP  DCSP f.close()
def testFirstOrder(self): DCNL DCSP self.init() DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers([0, 1, 2, 3, None]) DCNL DCSP self.feedTM(sequence) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[3]), 0) DCNL DCSP self.feedTM(sequence, num=2) DCNL DCSP self.feedTM(sequence) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[3]), 1) DCNL DCSP self.feedTM(sequence, num=4) DCNL DCSP self.feedTM(sequence) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[3]), 1)
def testHighOrder(self): DCNL DCSP self.init() DCNL DCSP sequenceA = self.sequenceMachine.generateFromNumbers([0, 1, 2, 3, None]) DCNL DCSP sequenceB = self.sequenceMachine.generateFromNumbers([4, 1, 2, 5, None]) DCNL DCSP self.feedTM(sequenceA, num=5) DCNL DCSP self.feedTM(sequenceA, learn=False) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[3]), 1) DCNL DCSP self.feedTM(sequenceB) DCNL DCSP self.feedTM(sequenceB, num=2) DCNL DCSP self.feedTM(sequenceB, learn=False) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[1]), 1) DCNL DCSP self.feedTM(sequenceB, num=3) DCNL DCSP self.feedTM(sequenceB, learn=False) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[2]), 1) DCNL DCSP self.feedTM(sequenceB, num=3) DCNL DCSP self.feedTM(sequenceB, learn=False) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[3]), 1) DCNL DCSP self.feedTM(sequenceA, learn=False) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[3]), 1) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedInactiveColumns().data[3]), 1) DCNL DCSP self.feedTM(sequenceA, num=10) DCNL DCSP self.feedTM(sequenceA, learn=False) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[3]), 1)
def testHighOrderAlternating(self): DCNL DCSP self.init() DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers([0, 1, 2, 3, None]) DCNL DCSP sequence += self.sequenceMachine.generateFromNumbers([4, 1, 2, 5, None]) DCNL DCSP self.feedTM(sequence) DCNL DCSP self.feedTM(sequence, num=10) DCNL DCSP self.feedTM(sequence, learn=False) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[3]), 1) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedActiveColumns().data[7]), 1)
def testEndlesslyRepeating(self): DCNL DCSP self.init({'columnDimensions': [2]}) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers([0, 1]) DCNL DCSP for _ in xrange(7): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP self.feedTM(sequence, num=50)
def testEndlesslyRepeatingWithNoNewSynapses(self): DCNL DCSP self.init({'columnDimensions': [2], 'maxNewSynapseCount': 1, 'cellsPerColumn': 10}) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers([0, 1]) DCNL DCSP for _ in xrange(7): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP self.feedTM(sequence, num=100)
def testLongRepeatingWithNovelEnding(self): DCNL DCSP self.init({'columnDimensions': [3]}) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers([0, 1]) DCNL DCSP sequence *= 10 DCNL DCSP sequence += [self.patternMachine.get(2), None] DCNL DCSP for _ in xrange(4): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP self.feedTM(sequence, num=10)
def testSingleEndlesslyRepeating(self): DCNL DCSP self.init({'columnDimensions': [1]}) DCNL DCSP sequence = [self.patternMachine.get(0)] DCNL DCSP for _ in xrange(4): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP for _ in xrange(2): DCNL DCSP  DCSP self.feedTM(sequence, num=10)
def _printOneTrainingVector(self, x): DCNL DCSP print ''.join((('1' if (k != 0) else '.') for k in x))
def _printAllTrainingSequences(self, trainingSequences): DCNL DCSP for (i, trainingSequence) in enumerate(trainingSequences): DCNL DCSP  DCSP print '============= DCSP Sequence', i, '=================' DCNL DCSP  DCSP for pattern in trainingSequence: DCNL DCSP  DCSP  DCSP self._printOneTrainingVector(pattern)
def _setVerbosity(self, verbosity, tm, tmPy): DCNL DCSP tm.cells4.setVerbosity(verbosity) DCNL DCSP tm.verbosity = verbosity DCNL DCSP tmPy.verbosity = verbosity
def _createTMs(self, numCols, fixedResources=False, checkSynapseConsistency=True): DCNL DCSP minThreshold = 4 DCNL DCSP activationThreshold = 8 DCNL DCSP newSynapseCount = 15 DCNL DCSP initialPerm = 0.3 DCNL DCSP connectedPerm = 0.5 DCNL DCSP permanenceInc = 0.1 DCNL DCSP permanenceDec = 0.05 DCNL DCSP if fixedResources: DCNL DCSP  DCSP permanenceDec = 0.1 DCNL DCSP  DCSP maxSegmentsPerCell = 5 DCNL DCSP  DCSP maxSynapsesPerSegment = 15 DCNL DCSP  DCSP globalDecay = 0 DCNL DCSP  DCSP maxAge = 0 DCNL DCSP else: DCNL DCSP  DCSP permanenceDec = 0.05 DCNL DCSP  DCSP maxSegmentsPerCell = (-1) DCNL DCSP  DCSP maxSynapsesPerSegment = (-1) DCNL DCSP  DCSP globalDecay = 0.0001 DCNL DCSP  DCSP maxAge = 1 DCNL DCSP if g_testCPPTM: DCNL DCSP  DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP  DCSP print 'Creating DCSP BacktrackingTMCPP DCSP instance' DCNL DCSP  DCSP cppTM = BacktrackingTMCPP(numberOfCols=numCols, cellsPerColumn=4, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, maxAge=maxAge, burnIn=1, seed=g_options.seed, verbosity=g_options.verbosity, checkSynapseConsistency=checkSynapseConsistency, pamLength=1000, maxSegmentsPerCell=maxSegmentsPerCell, maxSynapsesPerSegment=maxSynapsesPerSegment) DCNL DCSP  DCSP cppTM.retrieveLearningStates = True DCNL DCSP else: DCNL DCSP  DCSP cppTM = None DCNL DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP print 'Creating DCSP PY DCSP TM DCSP instance' DCNL DCSP pyTM = BacktrackingTM(numberOfCols=numCols, cellsPerColumn=4, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, maxAge=maxAge, burnIn=1, seed=g_options.seed, verbosity=g_options.verbosity, pamLength=1000, maxSegmentsPerCell=maxSegmentsPerCell, maxSynapsesPerSegment=maxSynapsesPerSegment) DCNL DCSP return (cppTM, pyTM)
def _getSimplePatterns(self, numOnes, numPatterns): DCNL DCSP numCols = (numOnes * numPatterns) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP x[(i * numOnes):((i + 1) * numOnes)] = 1 DCNL DCSP  DCSP p.append(x) DCNL DCSP return p
def _buildSegmentLearningTrainingSet(self, numOnes=10, numRepetitions=10): DCNL DCSP numPatterns = 5 DCNL DCSP numCols = ((2 * numPatterns) * numOnes) DCNL DCSP halfCols = (numPatterns * numOnes) DCNL DCSP numNoiseBits = numOnes DCNL DCSP p = self._getSimplePatterns(numOnes, numPatterns) DCNL DCSP trainingSequences = [] DCNL DCSP for i in xrange(numRepetitions): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP for j in xrange(numPatterns): DCNL DCSP  DCSP  DCSP v = numpy.zeros(numCols) DCNL DCSP  DCSP  DCSP v[0:halfCols] = p[j] DCNL DCSP  DCSP  DCSP noiseIndices = (self._rgen.permutation(halfCols) + halfCols)[0:numNoiseBits] DCNL DCSP  DCSP  DCSP v[noiseIndices] = 1 DCNL DCSP  DCSP  DCSP sequence.append(v) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP testSequence = [] DCNL DCSP for j in xrange(numPatterns): DCNL DCSP  DCSP v = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP v[0:halfCols] = p[j] DCNL DCSP  DCSP testSequence.append(v) DCNL DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP print '\nTraining DCSP sequences' DCNL DCSP  DCSP self.printAllTrainingSequences(trainingSequences) DCNL DCSP  DCSP print '\nTest DCSP sequence' DCNL DCSP  DCSP self.printAllTrainingSequences([testSequence]) DCNL DCSP return (trainingSequences, [testSequence])
def _buildSL2TrainingSet(self, numOnes=10, numRepetitions=10): DCNL DCSP numPatterns = 5 DCNL DCSP numCols = ((2 * numPatterns) * numOnes) DCNL DCSP halfCols = (numPatterns * numOnes) DCNL DCSP numNoiseBits = numOnes DCNL DCSP p = self._getSimplePatterns(numOnes, numPatterns) DCNL DCSP numSequences = 3 DCNL DCSP indices = [[0, 1, 2, 3, 4], [4, 3, 2, 1, 0], [2, 0, 4, 1, 3]] DCNL DCSP trainingSequences = [] DCNL DCSP for i in xrange((numRepetitions * numSequences)): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP for j in xrange(numPatterns): DCNL DCSP  DCSP  DCSP v = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP  DCSP v[0:halfCols] = p[indices[(i % numSequences)][j]] DCNL DCSP  DCSP  DCSP noiseIndices = (self._rgen.permutation(halfCols) + halfCols)[0:numNoiseBits] DCNL DCSP  DCSP  DCSP v[noiseIndices] = 1 DCNL DCSP  DCSP  DCSP sequence.append(v) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP testSequences = [] DCNL DCSP for i in xrange(numSequences): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP for j in xrange(numPatterns): DCNL DCSP  DCSP  DCSP v = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP  DCSP v[0:halfCols] = p[indices[(i % numSequences)][j]] DCNL DCSP  DCSP  DCSP sequence.append(v) DCNL DCSP  DCSP testSequences.append(sequence) DCNL DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP print '\nTraining DCSP sequences' DCNL DCSP  DCSP self.printAllTrainingSequences(trainingSequences) DCNL DCSP  DCSP print '\nTest DCSP sequences' DCNL DCSP  DCSP self.printAllTrainingSequences(testSequences) DCNL DCSP return (trainingSequences, testSequences)
def _testSegmentLearningSequence(self, tms, trainingSequences, testSequences, doResets=True): DCNL DCSP if (testSequences == None): DCNL DCSP  DCSP testSequences = trainingSequences DCNL DCSP (cppTM, pyTM) = (tms[0], tms[1]) DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP assert (fdrutils.tmDiff2(cppTM, pyTM, g_options.verbosity) == True) DCNL DCSP if (g_options.verbosity > 0): DCNL DCSP  DCSP print '============= DCSP Training DCSP =================' DCNL DCSP  DCSP print 'TM DCSP parameters:' DCNL DCSP  DCSP print 'CPP' DCNL DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP print cppTM.printParameters() DCNL DCSP  DCSP print '\nPY' DCNL DCSP  DCSP print pyTM.printParameters() DCNL DCSP for (sequenceNum, trainingSequence) in enumerate(trainingSequences): DCNL DCSP  DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP  DCSP print '============= DCSP New DCSP sequence DCSP =================' DCNL DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppTM.reset() DCNL DCSP  DCSP  DCSP pyTM.reset() DCNL DCSP  DCSP for (t, x) in enumerate(trainingSequence): DCNL DCSP  DCSP  DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP  DCSP  DCSP print 'Time DCSP step', t, 'sequence DCSP number', sequenceNum DCNL DCSP  DCSP  DCSP  DCSP print 'Input: DCSP ', pyTM.printInput(x) DCNL DCSP  DCSP  DCSP  DCSP print 'NNZ:', x.nonzero() DCNL DCSP  DCSP  DCSP x = numpy.array(x).astype('float32') DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppTM.learn(x) DCNL DCSP  DCSP  DCSP pyTM.learn(x) DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP assert (fdrutils.tmDiff2(cppTM, pyTM, g_options.verbosity, relaxSegmentTests=False) == True) DCNL DCSP  DCSP  DCSP if (g_options.verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP cppTM.printStates(printPrevious=(g_options.verbosity > 4)) DCNL DCSP  DCSP  DCSP  DCSP print '\nPY' DCNL DCSP  DCSP  DCSP  DCSP pyTM.printStates(printPrevious=(g_options.verbosity > 4)) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (g_options.verbosity > 4): DCNL DCSP  DCSP  DCSP print 'Sequence DCSP finished. DCSP Complete DCSP state DCSP after DCSP sequence' DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP  DCSP cppTM.printCells() DCNL DCSP  DCSP  DCSP print '\nPY' DCNL DCSP  DCSP  DCSP pyTM.printCells() DCNL DCSP  DCSP  DCSP print DCNL DCSP if (g_options.verbosity > 2): DCNL DCSP  DCSP print 'Calling DCSP trim DCSP segments' DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP (nSegsRemovedCPP, nSynsRemovedCPP) = cppTM.trimSegments() DCNL DCSP (nSegsRemoved, nSynsRemoved) = pyTM.trimSegments() DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP assert (nSegsRemovedCPP == nSegsRemoved) DCNL DCSP  DCSP assert (nSynsRemovedCPP == nSynsRemoved) DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP assert (fdrutils.tmDiff2(cppTM, pyTM, g_options.verbosity) == True) DCNL DCSP print 'Training DCSP completed. DCSP Stats:' DCNL DCSP info = pyTM.getSegmentInfo() DCNL DCSP print ' DCSP  DCSP nSegments:', info[0] DCNL DCSP print ' DCSP  DCSP nSynapses:', info[1] DCNL DCSP if (g_options.verbosity > 3): DCNL DCSP  DCSP print 'Complete DCSP state:' DCNL DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP cppTM.printCells() DCNL DCSP  DCSP print '\nPY' DCNL DCSP  DCSP pyTM.printCells() DCNL DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP print '============= DCSP Inference DCSP =================' DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP cppTM.collectStats = True DCNL DCSP pyTM.collectStats = True DCNL DCSP nPredictions = 0 DCNL DCSP (cppNumCorrect, pyNumCorrect) = (0, 0) DCNL DCSP for (sequenceNum, testSequence) in enumerate(testSequences): DCNL DCSP  DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP  DCSP print '============= DCSP New DCSP sequence DCSP =================' DCNL DCSP  DCSP slen = len(testSequence) DCNL DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppTM.reset() DCNL DCSP  DCSP  DCSP pyTM.reset() DCNL DCSP  DCSP for (t, x) in enumerate(testSequence): DCNL DCSP  DCSP  DCSP if (g_options.verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP print 'Time DCSP step', t, '\nInput:' DCNL DCSP  DCSP  DCSP  DCSP pyTM.printInput(x) DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppTM.infer(x) DCNL DCSP  DCSP  DCSP pyTM.infer(x) DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP assert (fdrutils.tmDiff2(cppTM, pyTM, g_options.verbosity) == True) DCNL DCSP  DCSP  DCSP if (g_options.verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP cppTM.printStates(printPrevious=(g_options.verbosity > 4), printLearnState=False) DCNL DCSP  DCSP  DCSP  DCSP print '\nPY' DCNL DCSP  DCSP  DCSP  DCSP pyTM.printStates(printPrevious=(g_options.verbosity > 4), printLearnState=False) DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppScores = cppTM.getStats() DCNL DCSP  DCSP  DCSP pyScores = pyTM.getStats() DCNL DCSP  DCSP  DCSP if (g_options.verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP print cppScores DCNL DCSP  DCSP  DCSP  DCSP print '\nPY' DCNL DCSP  DCSP  DCSP  DCSP print pyScores DCNL DCSP  DCSP  DCSP if ((t < (slen - 1)) and (t > pyTM.burnIn)): DCNL DCSP  DCSP  DCSP  DCSP nPredictions += 1 DCNL DCSP  DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cppScores['curPredictionScore2'] > 0.3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cppNumCorrect += 1 DCNL DCSP  DCSP  DCSP  DCSP if (pyScores['curPredictionScore2'] > 0.3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pyNumCorrect += 1 DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP cppScores = cppTM.getStats() DCNL DCSP pyScores = pyTM.getStats() DCNL DCSP passTest = False DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP if ((cppNumCorrect == nPredictions) and (pyNumCorrect == nPredictions)): DCNL DCSP  DCSP  DCSP passTest = True DCNL DCSP elif (pyNumCorrect == nPredictions): DCNL DCSP  DCSP passTest = True DCNL DCSP if (not passTest): DCNL DCSP  DCSP print 'CPP DCSP correct DCSP predictions:', cppNumCorrect DCNL DCSP  DCSP print 'PY DCSP correct DCSP predictions:', pyNumCorrect DCNL DCSP  DCSP print 'Total DCSP predictions:', nPredictions DCNL DCSP return passTest
def _testSL1(self, numOnes=10, numRepetitions=6, fixedResources=False, checkSynapseConsistency=True): DCNL DCSP if fixedResources: DCNL DCSP  DCSP testName = 'TestSL1_FS' DCNL DCSP else: DCNL DCSP  DCSP testName = 'TestSL1' DCNL DCSP print ('\nRunning DCSP %s...' % testName) DCNL DCSP (trainingSet, testSet) = self._buildSegmentLearningTrainingSet(numOnes, numRepetitions) DCNL DCSP numCols = len(trainingSet[0][0]) DCNL DCSP tms = self._createTMs(numCols=numCols, fixedResources=fixedResources, checkSynapseConsistency=checkSynapseConsistency) DCNL DCSP testResult = self._testSegmentLearningSequence(tms, trainingSet, testSet) DCNL DCSP if testResult: DCNL DCSP  DCSP print ('%s DCSP PASS' % testName) DCNL DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP print ('%s DCSP FAILED' % testName) DCNL DCSP  DCSP return 0
def _testSL2(self, numOnes=10, numRepetitions=10, fixedResources=False, checkSynapseConsistency=True): DCNL DCSP if fixedResources: DCNL DCSP  DCSP testName = 'TestSL2_FS' DCNL DCSP else: DCNL DCSP  DCSP testName = 'TestSL2' DCNL DCSP print ('\nRunning DCSP %s...' % testName) DCNL DCSP (trainingSet, testSet) = self._buildSL2TrainingSet(numOnes, numRepetitions) DCNL DCSP numCols = len(trainingSet[0][0]) DCNL DCSP tms = self._createTMs(numCols=numCols, fixedResources=fixedResources, checkSynapseConsistency=checkSynapseConsistency) DCNL DCSP testResult = self._testSegmentLearningSequence(tms, trainingSet, testSet) DCNL DCSP if testResult: DCNL DCSP  DCSP print ('%s DCSP PASS' % testName) DCNL DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP print ('%s DCSP FAILED' % testName) DCNL DCSP  DCSP return 0
def test_SL1NoFixedResources(self): DCNL DCSP self._testSL1(fixedResources=False, checkSynapseConsistency=g_options.long)
def test_SL1WithFixedResources(self): DCNL DCSP if (not g_options.long): DCNL DCSP  DCSP print ('Test DCSP %s DCSP only DCSP enabled DCSP with DCSP the DCSP --long DCSP option' % self._testMethodName) DCNL DCSP  DCSP return DCNL DCSP self._testSL1(fixedResources=True, checkSynapseConsistency=g_options.long)
def test_SL2NoFixedResources(self): DCNL DCSP if (not g_options.long): DCNL DCSP  DCSP print ('Test DCSP %s DCSP only DCSP enabled DCSP with DCSP the DCSP --long DCSP option' % self._testMethodName) DCNL DCSP  DCSP return DCNL DCSP self._testSL2(fixedResources=False, checkSynapseConsistency=g_options.long)
def test_SL2WithFixedResources(self): DCNL DCSP if (not g_options.long): DCNL DCSP  DCSP print ('Test DCSP %s DCSP only DCSP enabled DCSP with DCSP the DCSP --long DCSP option' % self._testMethodName) DCNL DCSP  DCSP return DCNL DCSP self._testSL2(fixedResources=True, checkSynapseConsistency=g_options.long)
def testB1(self): DCNL DCSP self.init() DCNL DCSP numbers = self.sequenceMachine.generateNumbers(1, 100) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP self.assertAllInactiveWereUnpredicted()
def testB3(self): DCNL DCSP self.init() DCNL DCSP numbers = self.sequenceMachine.generateNumbers(1, 300) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP self.assertAllInactiveWereUnpredicted()
def testB4(self): DCNL DCSP self.init() DCNL DCSP numbers = self.sequenceMachine.generateNumbers(3, 100) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted()
def testB5(self): DCNL DCSP self.init({'cellsPerColumn': 4}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(1, 100) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP self.assertAllInactiveWereUnpredicted()
def testB6(self): DCNL DCSP self.init({'cellsPerColumn': 4}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(3, 100) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP self.assertAllInactiveWereUnpredicted()
def testB7(self): DCNL DCSP self.init({'initialPermanence': 0.2, 'connectedPermanence': 0.7, 'permanenceIncrement': 0.2}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(1, 100) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP for _ in xrange(4): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP self.assertAllInactiveWereUnpredicted()
def testB8(self): DCNL DCSP self.init({'initialPermanence': 0.2, 'connectedPermanence': 0.7, 'permanenceIncrement': 0.2, 'cellsPerColumn': 4}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(1, 100) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP for _ in xrange(4): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP self.assertAllInactiveWereUnpredicted()
def testB9(self): DCNL DCSP self.init({'initialPermanence': 0.2, 'connectedPermanence': 0.7, 'permanenceIncrement': 0.2}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(1, 100) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP for _ in xrange(3): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWereUnpredicted()
def testB11(self): DCNL DCSP self.init({'cellsPerColumn': 4, 'activationThreshold': 8, 'minThreshold': 8}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(1, 100) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP self.feedTM(sequence) DCNL DCSP sequence = self.sequenceMachine.addSpatialNoise(sequence, 0.05) DCNL DCSP self._testTM(sequence) DCNL DCSP unpredictedActiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTraceUnpredictedActiveColumns()) DCNL DCSP self.assertTrue((unpredictedActiveColumnsMetric.mean < 1))
def testH1(self): DCNL DCSP self.init() DCNL DCSP numbers = self.sequenceMachine.generateNumbers(2, 20, (10, 15)) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP predictedInactiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTracePredictedInactiveColumns()) DCNL DCSP self.assertTrue((predictedInactiveColumnsMetric.mean > 0)) DCNL DCSP self.assertTrue((len(self.tm.mmGetTracePredictedInactiveColumns().data[15]) > 0)) DCNL DCSP self.assertTrue((len(self.tm.mmGetTracePredictedInactiveColumns().data[35]) > 0))
def testH2(self): DCNL DCSP self.init({'cellsPerColumn': 4}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(2, 20, (10, 15)) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP for _ in xrange(10): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP predictedInactiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTracePredictedInactiveColumns()) DCNL DCSP self.assertTrue((predictedInactiveColumnsMetric.sum < 26)) DCNL DCSP self.assertEqual(len(self.tm.mmGetTracePredictedInactiveColumns().data[36]), 0)
def testH3(self): DCNL DCSP self.init({'cellsPerColumn': 4}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(2, 20, (0, 5)) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP predictedInactiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTracePredictedInactiveColumns()) DCNL DCSP self.assertTrue((predictedInactiveColumnsMetric.sum < (26 * 2))) DCNL DCSP self.assertTrue((len(self.tm.mmGetTracePredictedInactiveColumns().data[5]) > 0)) DCNL DCSP self.assertTrue((len(self.tm.mmGetTracePredictedInactiveColumns().data[25]) > 0))
def testH4(self): DCNL DCSP self.init({'cellsPerColumn': 4}) DCNL DCSP numbers = [] DCNL DCSP for _ in xrange(2): DCNL DCSP  DCSP numbers += self.sequenceMachine.generateNumbers(1, 20) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP for _ in xrange(20): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP predictedInactiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTracePredictedInactiveColumns()) DCNL DCSP self.assertTrue((predictedInactiveColumnsMetric.mean < 3))
def testH5(self): DCNL DCSP self.init({'cellsPerColumn': 4}) DCNL DCSP numbers = [] DCNL DCSP shared = self.sequenceMachine.generateNumbers(1, 5)[:(-1)] DCNL DCSP for _ in xrange(2): DCNL DCSP  DCSP sublist = self.sequenceMachine.generateNumbers(1, 20) DCNL DCSP  DCSP sublist = [x for x in sublist if (x not in xrange(5))] DCNL DCSP  DCSP numbers += ((sublist[0:10] + shared) + sublist[10:]) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP for _ in xrange(20): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP self._testTM(sequence) DCNL DCSP self.assertAllActiveWerePredicted() DCNL DCSP predictedInactiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTracePredictedInactiveColumns()) DCNL DCSP self.assertTrue((predictedInactiveColumnsMetric.mean < 3))
def testH9(self): DCNL DCSP self.init({'cellsPerColumn': 4, 'activationThreshold': 8, 'minThreshold': 8}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(2, 20, (10, 15)) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP for _ in xrange(10): DCNL DCSP  DCSP self.feedTM(sequence) DCNL DCSP sequence = self.sequenceMachine.addSpatialNoise(sequence, 0.05) DCNL DCSP self._testTM(sequence) DCNL DCSP unpredictedActiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTraceUnpredictedActiveColumns()) DCNL DCSP self.assertTrue((unpredictedActiveColumnsMetric.mean < 3))
def testH10(self): DCNL DCSP self.init({'cellsPerColumn': 4, 'activationThreshold': 8, 'minThreshold': 8}) DCNL DCSP numbers = self.sequenceMachine.generateNumbers(2, 20, (10, 15)) DCNL DCSP sequence = self.sequenceMachine.generateFromNumbers(numbers) DCNL DCSP sequenceNoisy = dict() DCNL DCSP for i in xrange(10): DCNL DCSP  DCSP sequenceNoisy[i] = self.sequenceMachine.addSpatialNoise(sequence, 0.05) DCNL DCSP  DCSP self.feedTM(sequenceNoisy[i]) DCNL DCSP self.tm.mmClearHistory() DCNL DCSP self._testTM(sequence) DCNL DCSP predictedInactiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTracePredictedInactiveColumns()) DCNL DCSP predictedActiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTracePredictedActiveColumns()) DCNL DCSP predictedInactiveColumnsMeanNoOrphanDecay = predictedInactiveColumnsMetric.mean DCNL DCSP predictedActiveColumnsMeanNoOrphanDecay = predictedActiveColumnsMetric.mean DCNL DCSP self.init({'cellsPerColumn': 4, 'activationThreshold': 8, 'minThreshold': 8, 'predictedSegmentDecrement': 0.04}) DCNL DCSP for i in xrange(10): DCNL DCSP  DCSP self.feedTM(sequenceNoisy[i]) DCNL DCSP self.tm.mmClearHistory() DCNL DCSP self._testTM(sequence) DCNL DCSP predictedInactiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTracePredictedInactiveColumns()) DCNL DCSP predictedActiveColumnsMetric = self.tm.mmGetMetricFromTrace(self.tm.mmGetTracePredictedActiveColumns()) DCNL DCSP predictedInactiveColumnsMeanOrphanDecay = predictedInactiveColumnsMetric.mean DCNL DCSP predictedActiveColumnsMeanOrphanDecay = predictedActiveColumnsMetric.mean DCNL DCSP self.assertGreater(predictedInactiveColumnsMeanNoOrphanDecay, 0) DCNL DCSP self.assertGreater(predictedInactiveColumnsMeanNoOrphanDecay, predictedInactiveColumnsMeanOrphanDecay) DCNL DCSP self.assertAlmostEqual(predictedActiveColumnsMeanNoOrphanDecay, predictedActiveColumnsMeanOrphanDecay)
def getOpfExperimentPath(self, experimentName): DCNL DCSP path = os.path.join(self.__opfExperimentsParentDir, experimentName) DCNL DCSP assert os.path.isdir(path), ("Experiment DCSP path DCSP %s DCSP doesn't DCSP exist DCSP or DCSP is DCSP not DCSP a DCSP directory" % (path,)) DCNL DCSP return path
def setUp(self): DCNL DCSP global g_myEnv DCNL DCSP if (not g_myEnv): DCNL DCSP  DCSP g_myEnv = MyTestEnvironment()
def tearDown(self): DCNL DCSP self.resetExtraLogItems()
def shortDescription(self): DCNL DCSP return None
def executePositiveOpfExperiment(self, experimentName, short=False): DCNL DCSP opfRunner = g_myEnv.getOpfRunExperimentPyPath() DCNL DCSP opfExpDir = g_myEnv.getOpfExperimentPath(experimentName) DCNL DCSP r = self.__executePositiveRunExperimentTest(runnerPath=opfRunner, experimentDirPath=opfExpDir, short=short) DCNL DCSP return r
def __executePositiveRunExperimentTest(self, runnerPath, experimentDirPath, customOptions=[], short=False): DCNL DCSP command = ['python', runnerPath, experimentDirPath] DCNL DCSP command.extend(customOptions) DCNL DCSP if short: DCNL DCSP  DCSP command.append('--testMode') DCNL DCSP self.addExtraLogItem({'command': command}) DCNL DCSP r = _executeExternalCmdAndReapOutputs(command) DCNL DCSP self.addExtraLogItem({'result': r}) DCNL DCSP _debugOut(('_executeExternalCmdAndReapOutputs(%s)=%s' % (command, r))) DCNL DCSP self.assertEqual(r['exitStatus'], 0, ('Expected DCSP status DCSP = DCSP 0 DCSP from DCSP %s; DCSP got: DCSP %s' % (runnerPath, r['exitStatus']))) DCNL DCSP self.resetExtraLogItems() DCNL DCSP return r
def setUp(self): DCNL DCSP global g_myEnv DCNL DCSP if (not g_myEnv): DCNL DCSP  DCSP params = type('obj', (object,), {'installDir': resource_filename('nupic', '')}) DCNL DCSP  DCSP g_myEnv = MyTestEnvironment(params)
def tearDown(self): DCNL DCSP self.resetExtraLogItems() DCNL DCSP g_myEnv.cleanUp()
def shortDescription(self): DCNL DCSP return None
def getModules(self, expDesc, hsVersion='v2'): DCNL DCSP shutil.rmtree(g_myEnv.testOutDir, ignore_errors=True) DCNL DCSP args = [('--description=%s' % json.dumps(expDesc)), ('--outDir=%s' % g_myEnv.testOutDir), ('--version=%s' % hsVersion)] DCNL DCSP self.addExtraLogItem({'args': args}) DCNL DCSP experiment_generator.expGenerator(args) DCNL DCSP descriptionPyPath = os.path.join(g_myEnv.testOutDir, 'description.py') DCNL DCSP permutationsPyPath = os.path.join(g_myEnv.testOutDir, 'permutations.py') DCNL DCSP return (self.checkPythonScript(descriptionPyPath), self.checkPythonScript(permutationsPyPath))
def runBaseDescriptionAndPermutations(self, expDesc, hsVersion, maxModels=2): DCNL DCSP self.getModules(expDesc, hsVersion=hsVersion) DCNL DCSP permutationsPyPath = os.path.join(g_myEnv.testOutDir, 'permutations.py') DCNL DCSP args = [g_myEnv.testOutDir] DCNL DCSP from nupic.frameworks.opf.experiment_runner import runExperiment DCNL DCSP LOGGER.info('') DCNL DCSP LOGGER.info('============================================================') DCNL DCSP LOGGER.info('RUNNING DCSP EXPERIMENT') DCNL DCSP LOGGER.info('============================================================') DCNL DCSP runExperiment(args) DCNL DCSP jobParams = {'persistentJobGUID': generatePersistentJobGUID(), 'permutationsPyFilename': permutationsPyPath, 'hsVersion': hsVersion} DCNL DCSP if (maxModels is not None): DCNL DCSP  DCSP jobParams['maxModels'] = maxModels DCNL DCSP args = ['ignoreThis', ('--params=%s' % json.dumps(jobParams))] DCNL DCSP self.resetExtraLogItems() DCNL DCSP self.addExtraLogItem({'params': jobParams}) DCNL DCSP LOGGER.info('') DCNL DCSP LOGGER.info('============================================================') DCNL DCSP LOGGER.info('RUNNING DCSP PERMUTATIONS') DCNL DCSP LOGGER.info('============================================================') DCNL DCSP jobID = hypersearch_worker.main(args) DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP models = cjDAO.modelsGetUpdateCounters(jobID) DCNL DCSP modelIDs = [model.modelId for model in models] DCNL DCSP results = cjDAO.modelsGetResultAndStatus(modelIDs) DCNL DCSP if (maxModels is not None): DCNL DCSP  DCSP self.assertEqual(len(results), maxModels, ('Expected DCSP to DCSP get DCSP %d DCSP model DCSP results DCSP but DCSP only DCSP got DCSP %d' % (maxModels, len(results)))) DCNL DCSP for result in results: DCNL DCSP  DCSP self.assertEqual(result.completionReason, cjDAO.CMPL_REASON_EOF, ('Model DCSP did DCSP not DCSP complete DCSP successfully:\n%s' % result.completionMsg)) DCNL DCSP return results
def assertValidSwarmingAggregations(self, expDesc, expectedAttempts): DCNL DCSP minAggregation = dict(expDesc['streamDef']['aggregation']) DCNL DCSP minAggregation.pop('fields') DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP predictionSteps = expDesc['inferenceArgs']['predictionSteps'][0] DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictionSteps'], expDesc['inferenceArgs']['predictionSteps']) DCNL DCSP tmpAggregationInfo = rCopy(base.config['aggregationInfo'], (lambda value, _: value)) DCNL DCSP tmpAggregationInfo.pop('fields') DCNL DCSP self.assertDictEqual(tmpAggregationInfo, minAggregation) DCNL DCSP predictAheadTime = dict(minAggregation) DCNL DCSP for key in predictAheadTime.iterkeys(): DCNL DCSP  DCSP predictAheadTime[key] *= predictionSteps DCNL DCSP self.assertEqual(base.config['predictAheadTime'], predictAheadTime) DCNL DCSP self.assertEqual(perms.minimize, "multiStepBestPredictions:multiStep:errorMetric='altMAPE':steps=\\[.*\\]:window=1000:field=consumption") DCNL DCSP metrics = base.control['metrics'] DCNL DCSP metricTuples = [(metric.metric, metric.inferenceElement, metric.params) for metric in metrics] DCNL DCSP self.assertIn(('multiStep', 'multiStepBestPredictions', {'window': 1000, 'steps': [predictionSteps], 'errorMetric': 'altMAPE'}), metricTuples) DCNL DCSP aggPeriods = perms.permutations['aggregationInfo'] DCNL DCSP aggAttempts = [] DCNL DCSP for agg in aggPeriods.choices: DCNL DCSP  DCSP multipleOfMinAgg = aggregationDivide(agg, minAggregation) DCNL DCSP  DCSP self.assertIsInt(multipleOfMinAgg, ('invalid DCSP aggregation DCSP period DCSP %s DCSP is DCSP not DCSP an DCSP integer DCSP multipleof DCSP minAggregation DCSP (%s)' % (agg, minAggregation))) DCNL DCSP  DCSP self.assertGreaterEqual(int(round(multipleOfMinAgg)), 1, ('invalid DCSP aggregation DCSP period DCSP %s DCSP is DCSP not DCSP >= DCSP minAggregation DCSP (%s)' % (agg, minAggregation))) DCNL DCSP  DCSP requiredSteps = aggregationDivide(predictAheadTime, agg) DCNL DCSP  DCSP self.assertIsInt(requiredSteps, ('invalid DCSP aggregation DCSP period DCSP %s DCSP is DCSP not DCSP an DCSP integer DCSP factorof DCSP predictAheadTime DCSP (%s)' % (agg, predictAheadTime))) DCNL DCSP  DCSP self.assertGreaterEqual(int(round(requiredSteps)), 1, ('invalid DCSP aggregation DCSP period DCSP %s DCSP greater DCSP than DCSP  DCSP predictAheadTime DCSP (%s)' % (agg, predictAheadTime))) DCNL DCSP  DCSP quotient = aggregationDivide(expDesc['computeInterval'], agg) DCNL DCSP  DCSP self.assertIsInt(quotient, ('invalid DCSP aggregation DCSP period DCSP %s DCSP is DCSP not DCSP an DCSP integer DCSP factorof DCSP computeInterval DCSP (%s)' % (agg, expDesc['computeInterval']))) DCNL DCSP  DCSP self.assertGreaterEqual(int(round(quotient)), 1, ('Invalid DCSP aggregation DCSP period DCSP %s DCSP is DCSP greater DCSP than DCSP the DCSP computeInterval DCSP %s' % (agg, expDesc['computeInterval']))) DCNL DCSP  DCSP aggAttempts.append((int(round(multipleOfMinAgg)), int(requiredSteps))) DCNL DCSP LOGGER.info('This DCSP swarm DCSP will DCSP try DCSP the DCSP following DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (minAggregationMultiple, DCSP predictionSteps) DCSP combinations: DCSP %s', aggAttempts) DCNL DCSP aggAttempts.sort() DCNL DCSP expectedAttempts.sort() DCNL DCSP self.assertEqual(aggAttempts, expectedAttempts, ('Expected DCSP this DCSP swarm DCSP to DCSP try DCSP the DCSP following DCSP (minAggMultiple, DCSP predictionSteps) DCSP attempts: DCSP %s, DCSP but DCSP instead DCSP it DCSP is DCSP going DCSP to DCSP try: DCSP %s' % (expectedAttempts, aggAttempts)))
def test_ShowSchema(self): DCNL DCSP args = ['--showSchema'] DCNL DCSP self.addExtraLogItem({'args': args}) DCNL DCSP experiment_generator.expGenerator(args) DCNL DCSP return
def test_PredictionElement(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'])]) DCNL DCSP expDesc = {'inferenceType': 'MultiStep', 'inferenceArgs': {'predictedField': 'consumption', 'predictionSteps': [1]}, 'environment': OpfEnvironment.Experiment, 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 0, 'maxValue': 200}], 'resetPeriod': {'days': 1, 'hours': 12}, 'iterationCount': 10} DCNL DCSP (_base, perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(perms.minimize, ("multiStepBestPredictions:multiStep:errorMetric='altMAPE':steps=\\[1\\]:window=%d:field=consumption" % experiment_generator.METRIC_WINDOW), msg=('got: DCSP %s' % perms.minimize)) DCNL DCSP self.assertNotIn('clAlpha', perms.permutations) DCNL DCSP return
def test_Metrics(self): DCNL DCSP streamDef = dict(version=1, info='test_category_predicted_field', streams=[dict(source='file://dummy', info='dummy.csv', columns=['*'])]) DCNL DCSP expDesc = {'inferenceType': 'MultiStep', 'inferenceArgs': {'predictedField': 'playType', 'predictionSteps': [1]}, 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'address', 'fieldType': 'string'}, {'fieldName': 'ydsToGo', 'fieldType': 'float'}, {'fieldName': 'playType', 'fieldType': 'string'}]} DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP self.assertMetric(base, perms, expDesc['inferenceArgs']['predictedField'], 'avg_err', 'moving_mode', 'one_gram', InferenceElement.prediction, 'trivial') DCNL DCSP self.assertEqual(base.control['loggedMetrics'][0], '.*') DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'ydsToGo' DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP self.assertMetric(base, perms, expDesc['inferenceArgs']['predictedField'], 'altMAPE', 'moving_mean', 'one_gram', InferenceElement.encodings, 'trivial') DCNL DCSP self.assertEqual(base.control['loggedMetrics'][0], '.*')
def test_IncludedFields(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'])]) DCNL DCSP expDesc = {'inferenceType': 'TemporalNextStep', 'inferenceArgs': {'predictedField': 'consumption'}, 'environment': OpfEnvironment.Experiment, 'streamDef': streamDef, 'includedFields': [{'fieldName': 'gym', 'fieldType': 'string'}, {'fieldName': 'address', 'fieldType': 'string'}, {'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float'}], 'resetPeriod': {'days': 1, 'hours': 12}, 'iterationCount': 10} DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP actEncoderFields = set() DCNL DCSP actEncoderNames = set() DCNL DCSP for (_, encoder) in base.config['modelParams']['sensorParams']['encoders'].iteritems(): DCNL DCSP  DCSP actEncoderFields.add(encoder['fieldname']) DCNL DCSP  DCSP actEncoderNames.add(encoder['name']) DCNL DCSP self.assertEqual(actEncoderFields, set(['gym', 'address', 'timestamp', 'consumption'])) DCNL DCSP self.assertEqual(actEncoderNames, set(['gym', 'address', 'timestamp_timeOfDay', 'timestamp_dayOfWeek', 'timestamp_weekend', 'consumption'])) DCNL DCSP expDesc['includedFields'] = [{'fieldName': 'gym', 'fieldType': 'string'}, {'fieldName': 'consumption', 'fieldType': 'float'}] DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP actEncoderFields = set() DCNL DCSP actEncoderNames = set() DCNL DCSP for (_, encoder) in base.config['modelParams']['sensorParams']['encoders'].iteritems(): DCNL DCSP  DCSP actEncoderFields.add(encoder['fieldname']) DCNL DCSP  DCSP actEncoderNames.add(encoder['name']) DCNL DCSP self.assertEqual(actEncoderFields, set(['gym', 'consumption'])) DCNL DCSP self.assertEqual(actEncoderNames, set(['gym', 'consumption'])) DCNL DCSP expDesc['includedFields'] = [{'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 42, 'maxValue': 42.42}] DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP actEncoderFields = set() DCNL DCSP actEncoderNames = set() DCNL DCSP actEncoderTypes = set() DCNL DCSP minValues = set() DCNL DCSP maxValues = set() DCNL DCSP for (_, encoder) in base.config['modelParams']['sensorParams']['encoders'].iteritems(): DCNL DCSP  DCSP actEncoderFields.add(encoder['fieldname']) DCNL DCSP  DCSP actEncoderNames.add(encoder['name']) DCNL DCSP  DCSP actEncoderTypes.add(encoder['type']) DCNL DCSP  DCSP minValues.add(encoder['minval']) DCNL DCSP  DCSP maxValues.add(encoder['maxval']) DCNL DCSP self.assertEqual(actEncoderFields, set(['consumption'])) DCNL DCSP self.assertEqual(actEncoderNames, set(['consumption'])) DCNL DCSP self.assertEqual(actEncoderTypes, set(['ScalarEncoder'])) DCNL DCSP self.assertEqual(minValues, set([42])) DCNL DCSP self.assertEqual(maxValues, set([42.42])) DCNL DCSP expDesc['includedFields'] = [{'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 42, 'maxValue': 42.42, 'encoderType': 'AdaptiveScalarEncoder'}] DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP actEncoderFields = set() DCNL DCSP actEncoderNames = set() DCNL DCSP actEncoderTypes = set() DCNL DCSP minValues = set() DCNL DCSP maxValues = set() DCNL DCSP for (_, encoder) in base.config['modelParams']['sensorParams']['encoders'].iteritems(): DCNL DCSP  DCSP actEncoderFields.add(encoder['fieldname']) DCNL DCSP  DCSP actEncoderNames.add(encoder['name']) DCNL DCSP  DCSP actEncoderTypes.add(encoder['type']) DCNL DCSP  DCSP minValues.add(encoder['minval']) DCNL DCSP  DCSP maxValues.add(encoder['maxval']) DCNL DCSP self.assertEqual(actEncoderFields, set(['consumption'])) DCNL DCSP self.assertEqual(actEncoderNames, set(['consumption'])) DCNL DCSP self.assertEqual(actEncoderTypes, set(['AdaptiveScalarEncoder'])) DCNL DCSP self.assertEqual(minValues, set([42])) DCNL DCSP self.assertEqual(maxValues, set([42.42])) DCNL DCSP characters = string.punctuation DCNL DCSP expDesc['includedFields'] = ([{'fieldName': ((char + 'helloField') + char), 'fieldType': 'float'} for char in characters] + [{'fieldName': 'consumption', 'fieldType': 'float'}]) DCNL DCSP try: DCNL DCSP  DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP except: DCNL DCSP  DCSP LOGGER.info('Passed: DCSP Threw DCSP exception DCSP for DCSP bad DCSP fieldname.') DCNL DCSP characters = characters.replace('\\', '') DCNL DCSP return
def test_Aggregation(self): DCNL DCSP streamDef = dict(version=1, info='TestAggregation', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'])], aggregation={'years': 1, 'months': 2, 'weeks': 3, 'days': 4, 'hours': 5, 'minutes': 6, 'seconds': 7, 'milliseconds': 8, 'microseconds': 9, 'fields': [('consumption', 'sum'), ('gym', 'first')]}, sequenceIdField='gym', providers={'order': ['weather'], 'weather': {'locationField': 'address', 'providerType': 'NamedProvider', 'timestampField': 'timestamp', 'weatherTypes': ['TEMP']}}) DCNL DCSP expDesc = {'inferenceType': 'TemporalNextStep', 'inferenceArgs': {'predictedField': 'consumption'}, 'environment': OpfEnvironment.Experiment, 'streamDef': streamDef, 'includedFields': [{'fieldName': 'gym', 'fieldType': 'string'}, {'fieldName': 'consumption', 'fieldType': 'float'}, {'fieldName': 'TEMP', 'fieldType': 'float', 'minValue': (-30.0), 'maxValue': 120.0}], 'iterationCount': 10, 'resetPeriod': {'days': 1, 'hours': 12}} DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP aggInfo = base.config['aggregationInfo'] DCNL DCSP aggInfo['fields'].sort() DCNL DCSP streamDef['aggregation']['fields'].sort() DCNL DCSP self.assertEqual(aggInfo, streamDef['aggregation']) DCNL DCSP expDesc['streamDef'].pop('aggregation') DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP aggInfo = base.config['aggregationInfo'] DCNL DCSP expAggInfo = {'years': 0, 'months': 0, 'weeks': 0, 'days': 0, 'hours': 0, 'minutes': 0, 'seconds': 0, 'milliseconds': 0, 'microseconds': 0, 'fields': []} DCNL DCSP aggInfo['fields'].sort() DCNL DCSP expAggInfo['fields'].sort() DCNL DCSP self.assertEqual(aggInfo, expAggInfo) DCNL DCSP return
def test_ResetPeriod(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'])]) DCNL DCSP expDesc = {'inferenceType': 'TemporalNextStep', 'inferenceArgs': {'predictedField': 'consumption'}, 'environment': OpfEnvironment.Experiment, 'streamDef': streamDef, 'includedFields': [{'fieldName': 'gym', 'fieldType': 'string'}, {'fieldName': 'consumption', 'fieldType': 'float'}], 'iterationCount': 10, 'resetPeriod': {'weeks': 3, 'days': 4, 'hours': 5, 'minutes': 6, 'seconds': 7, 'milliseconds': 8, 'microseconds': 9}} DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP resetInfo = base.config['modelParams']['sensorParams']['sensorAutoReset'] DCNL DCSP self.assertEqual(resetInfo, expDesc['resetPeriod']) DCNL DCSP expDesc.pop('resetPeriod') DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP resetInfo = base.config['modelParams']['sensorParams']['sensorAutoReset'] DCNL DCSP self.assertEqual(resetInfo, None) DCNL DCSP return
def test_RunningExperimentHSv2(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'])]) DCNL DCSP expDesc = {'inferenceType': 'TemporalMultiStep', 'inferenceArgs': {'predictedField': 'consumption'}, 'environment': OpfEnvironment.Nupic, 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 0, 'maxValue': 200}], 'resetPeriod': {'days': 1, 'hours': 12}, 'iterationCount': 10} DCNL DCSP self.runBaseDescriptionAndPermutations(expDesc, hsVersion='v2') DCNL DCSP return
def test_MultiStep(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'], last_record=20)], aggregation={'years': 0, 'months': 0, 'weeks': 0, 'days': 0, 'hours': 1, 'minutes': 0, 'seconds': 0, 'milliseconds': 0, 'microseconds': 0, 'fields': [('consumption', 'sum'), ('gym', 'first'), ('timestamp', 'first')]}) DCNL DCSP expDesc = {'environment': OpfEnvironment.Nupic, 'inferenceArgs': {'predictedField': 'consumption', 'predictionSteps': [1, 5]}, 'inferenceType': 'MultiStep', 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float'}], 'iterationCount': (-1), 'runBaselines': True} DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP print "base.config['modelParams']:" DCNL DCSP pprint.pprint(base.config['modelParams']) DCNL DCSP print 'perms.permutations' DCNL DCSP pprint.pprint(perms.permutations) DCNL DCSP print 'perms.minimize' DCNL DCSP pprint.pprint(perms.minimize) DCNL DCSP print 'expDesc' DCNL DCSP pprint.pprint(expDesc) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictionSteps'], expDesc['inferenceArgs']['predictionSteps']) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictedField'], expDesc['inferenceArgs']['predictedField']) DCNL DCSP self.assertEqual(base.config['modelParams']['inferenceType'], 'TemporalMultiStep') DCNL DCSP self.assertEqual(base.config['modelParams']['sensorParams']['encoders']['_classifierInput']['classifierOnly'], True) DCNL DCSP self.assertEqual(base.config['modelParams']['sensorParams']['encoders']['_classifierInput']['fieldname'], expDesc['inferenceArgs']['predictedField']) DCNL DCSP self.assertIn('inferenceType', perms.permutations['modelParams']) DCNL DCSP self.assertEqual(perms.minimize, ("multiStepBestPredictions:multiStep:errorMetric='altMAPE':" + 'steps=\\[1, DCSP 5\\]:window=1000:field=consumption')) DCNL DCSP self.assertIn('alpha', perms.permutations['modelParams']['clParams']) DCNL DCSP self.assertIn('_classifierInput', perms.permutations['modelParams']['sensorParams']['encoders']) DCNL DCSP self.assertEqual(perms.inputPredictedField, 'auto') DCNL DCSP self.assertIn('activationThreshold', perms.permutations['modelParams']['tmParams']) DCNL DCSP self.assertIn('minThreshold', perms.permutations['modelParams']['tmParams']) DCNL DCSP metrics = base.control['metrics'] DCNL DCSP metricTuples = [(metric.metric, metric.inferenceElement, metric.params) for metric in metrics] DCNL DCSP self.assertIn(('multiStep', 'multiStepBestPredictions', {'window': 1000, 'steps': [1, 5], 'errorMetric': 'aae'}), metricTuples) DCNL DCSP self.runBaseDescriptionAndPermutations(expDesc, hsVersion='v2') DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceArgs']['predictionSteps'] = [5, 1] DCNL DCSP (base, perms) = self.getModules(expDesc2) DCNL DCSP self.assertEqual(perms.minimize, ("multiStepBestPredictions:multiStep:errorMetric='altMAPE':" + 'steps=\\[5, DCSP 1\\]:window=1000:field=consumption')) DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceType'] = 'NontemporalMultiStep' DCNL DCSP (base, perms) = self.getModules(expDesc2) DCNL DCSP self.assertEqual(base.config['modelParams']['inferenceType'], expDesc2['inferenceType']) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictionSteps'], expDesc2['inferenceArgs']['predictionSteps']) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictedField'], expDesc2['inferenceArgs']['predictedField']) DCNL DCSP self.assertIn('alpha', perms.permutations['modelParams']['clParams']) DCNL DCSP self.assertNotIn('inferenceType', perms.permutations['modelParams']) DCNL DCSP self.assertNotIn('activationThreshold', perms.permutations['modelParams']['tmParams']) DCNL DCSP self.assertNotIn('minThreshold', perms.permutations['modelParams']['tmParams']) DCNL DCSP metrics = base.control['metrics'] DCNL DCSP metricTuples = [(metric.metric, metric.inferenceElement, metric.params) for metric in metrics] DCNL DCSP self.assertIn(('multiStep', 'multiStepBestPredictions', {'window': 1000, 'steps': [1, 5], 'errorMetric': 'aae'}), metricTuples) DCNL DCSP self.runBaseDescriptionAndPermutations(expDesc, hsVersion='v2') DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceType'] = 'MultiStep' DCNL DCSP (base, perms) = self.getModules(expDesc2) DCNL DCSP self.assertEqual(base.config['modelParams']['inferenceType'], 'TemporalMultiStep') DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictionSteps'], expDesc2['inferenceArgs']['predictionSteps']) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictedField'], expDesc2['inferenceArgs']['predictedField']) DCNL DCSP self.assertIn('alpha', perms.permutations['modelParams']['clParams']) DCNL DCSP self.assertIn('inferenceType', perms.permutations['modelParams']) DCNL DCSP self.assertIn('activationThreshold', perms.permutations['modelParams']['tmParams']) DCNL DCSP self.assertIn('minThreshold', perms.permutations['modelParams']['tmParams']) DCNL DCSP metrics = base.control['metrics'] DCNL DCSP metricTuples = [(metric.metric, metric.inferenceElement, metric.params) for metric in metrics] DCNL DCSP self.assertIn(('multiStep', 'multiStepBestPredictions', {'window': 1000, 'steps': [1, 5], 'errorMetric': 'aae'}), metricTuples) DCNL DCSP self.runBaseDescriptionAndPermutations(expDesc, hsVersion='v2') DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceArgs']['inputPredictedField'] = 'yes' DCNL DCSP (base, perms) = self.getModules(expDesc2) DCNL DCSP self.assertEqual(perms.inputPredictedField, 'yes') DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceArgs']['inputPredictedField'] = 'no' DCNL DCSP (base, perms) = self.getModules(expDesc2) DCNL DCSP self.assertEqual(perms.inputPredictedField, 'no') DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceArgs']['inputPredictedField'] = 'auto' DCNL DCSP (base, perms) = self.getModules(expDesc2) DCNL DCSP self.assertEqual(perms.inputPredictedField, 'auto') DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceArgs']['inputPredictedField'] = 'no' DCNL DCSP (base, perms) = self.getModules(expDesc2) DCNL DCSP self.assertNotIn('consumption', base.config['modelParams']['sensorParams']['encoders'].keys())
def test_AggregationSwarming(self): DCNL DCSP minAggregation = {'years': 0, 'months': 0, 'weeks': 0, 'days': 0, 'hours': 0, 'minutes': 15, 'seconds': 0, 'milliseconds': 0, 'microseconds': 0} DCNL DCSP streamAggregation = dict(minAggregation) DCNL DCSP streamAggregation.update({'fields': [('consumption', 'sum'), ('gym', 'first'), ('timestamp', 'first')]}) DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'], last_record=10)], aggregation=streamAggregation) DCNL DCSP expDesc = {'environment': OpfEnvironment.Nupic, 'inferenceArgs': {'predictedField': 'consumption', 'predictionSteps': [24]}, 'inferenceType': 'TemporalMultiStep', 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float'}], 'iterationCount': (-1), 'runBaselines': False, 'computeInterval': {'hours': 2}} DCNL DCSP self.assertValidSwarmingAggregations(expDesc=expDesc, expectedAttempts=[(1, 24), (2, 12), (4, 6), (8, 3)]) DCNL DCSP expDescTmp = copy.deepcopy(expDesc) DCNL DCSP expDescTmp['streamDef']['aggregation']['minutes'] = 1 DCNL DCSP expDescTmp['inferenceArgs']['predictionSteps'] = [((4 * 60) / 1)] DCNL DCSP self.assertValidSwarmingAggregations(expDesc=expDescTmp, expectedAttempts=[(24, 10), (30, 8), (40, 6), (60, 4), (120, 2)]) DCNL DCSP expDescTmp = copy.deepcopy(expDesc) DCNL DCSP expDescTmp['computeInterval']['hours'] = 3 DCNL DCSP expDescTmp['inferenceArgs']['predictionSteps'] = [16] DCNL DCSP self.assertValidSwarmingAggregations(expDesc=expDescTmp, expectedAttempts=[(1, 16), (2, 8), (4, 4)]) DCNL DCSP expDescTmp = copy.deepcopy(expDesc) DCNL DCSP expDescTmp['computeInterval']['hours'] = 2 DCNL DCSP expDescTmp['inferenceArgs']['predictionSteps'] = [16] DCNL DCSP self.assertValidSwarmingAggregations(expDesc=expDescTmp, expectedAttempts=[(1, 16), (2, 8), (4, 4), (8, 2)]) DCNL DCSP expDescTmp = copy.deepcopy(expDesc) DCNL DCSP expDescTmp['computeInterval']['hours'] = 0 DCNL DCSP expDescTmp['computeInterval']['minutes'] = 1 DCNL DCSP with self.assertRaises(Exception) as cm: DCNL DCSP  DCSP self.assertValidSwarmingAggregations(expDesc=expDescTmp, expectedAttempts=[(1, 16), (2, 8), (4, 4), (8, 2)]) DCNL DCSP LOGGER.info('Got DCSP expected DCSP exception: DCSP %s', cm.exception) DCNL DCSP expDescTmp = copy.deepcopy(expDesc) DCNL DCSP expDescTmp['computeInterval']['hours'] = 0 DCNL DCSP expDescTmp['computeInterval']['minutes'] = 25 DCNL DCSP with self.assertRaises(Exception) as cm: DCNL DCSP  DCSP self.assertValidSwarmingAggregations(expDesc=expDescTmp, expectedAttempts=[(1, 16), (2, 8), (4, 4), (8, 2)]) DCNL DCSP LOGGER.info('Got DCSP expected DCSP exception: DCSP %s', cm.exception) DCNL DCSP expDescTmp = copy.deepcopy(expDesc) DCNL DCSP expDescTmp['inferenceArgs']['predictionSteps'] = [1, 16] DCNL DCSP with self.assertRaises(Exception) as cm: DCNL DCSP  DCSP self.assertValidSwarmingAggregations(expDesc=expDescTmp, expectedAttempts=[(1, 16), (2, 8), (4, 4), (8, 2)]) DCNL DCSP LOGGER.info('Got DCSP expected DCSP exception: DCSP %s', cm.exception) DCNL DCSP expDescTmp = copy.deepcopy(expDesc) DCNL DCSP expDescTmp['streamDef']['aggregation']['minutes'] = 0 DCNL DCSP with self.assertRaises(Exception) as cm: DCNL DCSP  DCSP self.assertValidSwarmingAggregations(expDesc=expDescTmp, expectedAttempts=[(1, 16), (2, 8), (4, 4), (8, 2)]) DCNL DCSP LOGGER.info('Got DCSP expected DCSP exception: DCSP %s', cm.exception)
def test_SwarmSize(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'])]) DCNL DCSP expDesc = {'swarmSize': 'large', 'inferenceType': 'TemporalNextStep', 'inferenceArgs': {'predictedField': 'consumption'}, 'environment': OpfEnvironment.Nupic, 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 0, 'maxValue': 200}], 'resetPeriod': {'days': 1, 'hours': 12}} DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(base.control['iterationCount'], (-1), msg=('got: DCSP %s' % base.control['iterationCount'])) DCNL DCSP self.assertEqual(perms.minParticlesPerSwarm, 15, msg=('got: DCSP %s' % perms.minParticlesPerSwarm)) DCNL DCSP self.assertEqual(perms.tryAll3FieldCombinationsWTimestamps, True, msg=('got: DCSP %s' % perms.tryAll3FieldCombinationsWTimestamps)) DCNL DCSP self.assertFalse(hasattr(perms, 'maxModels')) DCNL DCSP self.assertEqual(perms.inputPredictedField, 'auto') DCNL DCSP expDesc['swarmSize'] = 'medium' DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(base.control['iterationCount'], 4000, msg=('got: DCSP %s' % base.control['iterationCount'])) DCNL DCSP self.assertEqual(perms.minParticlesPerSwarm, 5, msg=('got: DCSP %s' % perms.minParticlesPerSwarm)) DCNL DCSP self.assertEqual(perms.maxModels, 200, msg=('got: DCSP %s' % perms.maxModels)) DCNL DCSP self.assertFalse(hasattr(perms, 'killUselessSwarms')) DCNL DCSP self.assertFalse(hasattr(perms, 'minFieldContribution')) DCNL DCSP self.assertFalse(hasattr(perms, 'maxFieldBranching')) DCNL DCSP self.assertFalse(hasattr(perms, 'tryAll3FieldCombinations')) DCNL DCSP self.assertEqual(perms.inputPredictedField, 'auto') DCNL DCSP expDesc['swarmSize'] = 'small' DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(base.control['iterationCount'], 100, msg=('got: DCSP %s' % base.control['iterationCount'])) DCNL DCSP self.assertEqual(perms.minParticlesPerSwarm, 3, msg=('got: DCSP %s' % perms.minParticlesPerSwarm)) DCNL DCSP self.assertEqual(perms.maxModels, 1, msg=('got: DCSP %s' % perms.maxModels)) DCNL DCSP self.assertFalse(hasattr(perms, 'killUselessSwarms')) DCNL DCSP self.assertFalse(hasattr(perms, 'minFieldContribution')) DCNL DCSP self.assertFalse(hasattr(perms, 'maxFieldBranching')) DCNL DCSP self.assertFalse(hasattr(perms, 'tryAll3FieldCombinations')) DCNL DCSP self.assertEqual(perms.inputPredictedField, 'yes') DCNL DCSP expDesc['swarmSize'] = 'small' DCNL DCSP expDesc['minParticlesPerSwarm'] = 2 DCNL DCSP expDesc['iterationCount'] = 42 DCNL DCSP expDesc['inferenceArgs']['inputPredictedField'] = 'auto' DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(base.control['iterationCount'], 42, msg=('got: DCSP %s' % base.control['iterationCount'])) DCNL DCSP self.assertEqual(perms.minParticlesPerSwarm, 2, msg=('got: DCSP %s' % perms.minParticlesPerSwarm)) DCNL DCSP self.assertEqual(perms.maxModels, 1, msg=('got: DCSP %s' % perms.maxModels)) DCNL DCSP self.assertFalse(hasattr(perms, 'killUselessSwarms')) DCNL DCSP self.assertFalse(hasattr(perms, 'minFieldContribution')) DCNL DCSP self.assertFalse(hasattr(perms, 'maxFieldBranching')) DCNL DCSP self.assertFalse(hasattr(perms, 'tryAll3FieldCombinations')) DCNL DCSP self.assertEqual(perms.inputPredictedField, 'auto') DCNL DCSP modelResults = self.runBaseDescriptionAndPermutations(expDesc, hsVersion='v2', maxModels=None) DCNL DCSP self.assertEqual(len(modelResults), 1, ('Expected DCSP to DCSP get DCSP %d DCSP model DCSP results DCSP but DCSP only DCSP got DCSP %d' % (1, len(modelResults))))
def test_FixedFields(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'])]) DCNL DCSP expDesc = {'swarmSize': 'large', 'inferenceType': 'TemporalNextStep', 'inferenceArgs': {'predictedField': 'consumption'}, 'environment': OpfEnvironment.Nupic, 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 0, 'maxValue': 200}], 'resetPeriod': {'days': 1, 'hours': 12}, 'fixedFields': ['consumption', 'timestamp']} DCNL DCSP (_base, perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(perms.fixedFields, ['consumption', 'timestamp'], msg=('got: DCSP %s' % perms.fixedFields)) DCNL DCSP expDesc.pop('fixedFields') DCNL DCSP (_base, perms) = self.getModules(expDesc) DCNL DCSP self.assertFalse(hasattr(perms, 'fixedFields'))
def test_FastSwarmModelParams(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'])]) DCNL DCSP fastSwarmModelParams = {'this DCSP is': 'a DCSP test'} DCNL DCSP expDesc = {'swarmSize': 'large', 'inferenceType': 'TemporalNextStep', 'inferenceArgs': {'predictedField': 'consumption'}, 'environment': OpfEnvironment.Nupic, 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 0, 'maxValue': 200}], 'resetPeriod': {'days': 1, 'hours': 12}, 'fastSwarmModelParams': fastSwarmModelParams} DCNL DCSP (_base, perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(perms.fastSwarmModelParams, fastSwarmModelParams, msg=('got: DCSP %s' % perms.fastSwarmModelParams)) DCNL DCSP expDesc.pop('fastSwarmModelParams') DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP self.assertFalse(hasattr(perms, 'fastSwarmModelParams'))
def test_AnomalyParams(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'])]) DCNL DCSP expDesc = {'environment': OpfEnvironment.Nupic, 'inferenceArgs': {'predictedField': 'consumption', 'predictionSteps': [1]}, 'inferenceType': 'TemporalAnomaly', 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float'}], 'iterationCount': (-1), 'anomalyParams': {'autoDetectThreshold': 1.1, 'autoDetectWaitRecords': 0, 'anomalyCacheRecords': 10}} DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictionSteps'], expDesc['inferenceArgs']['predictionSteps']) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictedField'], expDesc['inferenceArgs']['predictedField']) DCNL DCSP self.assertEqual(base.config['modelParams']['inferenceType'], expDesc['inferenceType']) DCNL DCSP self.assertEqual(base.config['modelParams']['anomalyParams'], expDesc['anomalyParams']) DCNL DCSP expDesc['inferenceType'] = 'TemporalNextStep' DCNL DCSP (base, _perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictionSteps'], expDesc['inferenceArgs']['predictionSteps']) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictedField'], expDesc['inferenceArgs']['predictedField']) DCNL DCSP self.assertEqual(base.config['modelParams']['inferenceType'], expDesc['inferenceType']) DCNL DCSP self.assertEqual(base.config['modelParams']['anomalyParams'], expDesc['anomalyParams'])
def test_NontemporalClassification(self): DCNL DCSP streamDef = dict(version=1, info='test_NoProviders', streams=[dict(source=('file://%s' % HOTGYM_INPUT), info='hotGym.csv', columns=['*'], last_record=10)], aggregation={'years': 0, 'months': 0, 'weeks': 0, 'days': 0, 'hours': 1, 'minutes': 0, 'seconds': 0, 'milliseconds': 0, 'microseconds': 0, 'fields': [('consumption', 'sum'), ('gym', 'first'), ('timestamp', 'first')]}) DCNL DCSP expDesc = {'environment': OpfEnvironment.Nupic, 'inferenceArgs': {'predictedField': 'consumption', 'predictionSteps': [0]}, 'inferenceType': 'TemporalMultiStep', 'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float'}], 'iterationCount': (-1), 'runBaselines': True} DCNL DCSP (base, perms) = self.getModules(expDesc) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictionSteps'], expDesc['inferenceArgs']['predictionSteps']) DCNL DCSP self.assertEqual(base.control['inferenceArgs']['predictedField'], expDesc['inferenceArgs']['predictedField']) DCNL DCSP self.assertEqual(base.config['modelParams']['inferenceType'], InferenceType.NontemporalClassification) DCNL DCSP self.assertEqual(base.config['modelParams']['sensorParams']['encoders']['_classifierInput']['classifierOnly'], True) DCNL DCSP self.assertEqual(base.config['modelParams']['sensorParams']['encoders']['_classifierInput']['fieldname'], expDesc['inferenceArgs']['predictedField']) DCNL DCSP self.assertNotIn('consumption', base.config['modelParams']['sensorParams']['encoders'].keys()) DCNL DCSP self.assertFalse(base.config['modelParams']['spEnable']) DCNL DCSP self.assertFalse(base.config['modelParams']['tmEnable']) DCNL DCSP self.assertNotIn('inferenceType', perms.permutations['modelParams']) DCNL DCSP self.assertEqual(perms.minimize, ("multiStepBestPredictions:multiStep:errorMetric='altMAPE':" + 'steps=\\[0\\]:window=1000:field=consumption')) DCNL DCSP self.assertIn('alpha', perms.permutations['modelParams']['clParams']) DCNL DCSP self.assertEqual(perms.permutations['modelParams']['tmParams'], {}) DCNL DCSP self.assertEqual(perms.permutations['modelParams']['spParams'], {}) DCNL DCSP metrics = base.control['metrics'] DCNL DCSP metricTuples = [(metric.metric, metric.inferenceElement, metric.params) for metric in metrics] DCNL DCSP self.assertIn(('multiStep', 'multiStepBestPredictions', {'window': 1000, 'steps': [0], 'errorMetric': 'aae'}), metricTuples) DCNL DCSP self.runBaseDescriptionAndPermutations(expDesc, hsVersion='v2') DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceType'] = 'NontemporalClassification' DCNL DCSP (newBase, _newPerms) = self.getModules(expDesc2) DCNL DCSP self.assertEqual(base.config, newBase.config) DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceType'] = 'NontemporalClassification' DCNL DCSP expDesc2['inferenceArgs']['predictionSteps'] = [1] DCNL DCSP gotException = False DCNL DCSP try: DCNL DCSP  DCSP (newBase, _newPerms) = self.getModules(expDesc2) DCNL DCSP except: DCNL DCSP  DCSP gotException = True DCNL DCSP self.assertTrue(gotException) DCNL DCSP expDesc2 = copy.deepcopy(expDesc) DCNL DCSP expDesc2['inferenceArgs']['inputPredictedField'] = 'yes' DCNL DCSP gotException = False DCNL DCSP try: DCNL DCSP  DCSP (newBase, _newPerms) = self.getModules(expDesc2) DCNL DCSP except: DCNL DCSP  DCSP gotException = True DCNL DCSP self.assertTrue(gotException) DCNL DCSP return
def testSaveAndReload(self): DCNL DCSP print 'Creating DCSP network...' DCNL DCSP netOPF = _createOPFNetwork() DCNL DCSP level1OPF = netOPF.regions['level1SP'] DCNL DCSP print 'Training DCSP network DCSP for DCSP 500 DCSP iterations' DCNL DCSP level1OPF.setParameter('learningMode', 1) DCNL DCSP level1OPF.setParameter('inferenceMode', 0) DCNL DCSP netOPF.run(500) DCNL DCSP level1OPF.setParameter('learningMode', 0) DCNL DCSP level1OPF.setParameter('inferenceMode', 1) DCNL DCSP print 'Saving DCSP and DCSP reload DCSP network' DCNL DCSP (_, tmpNetworkFilename) = _setupTempDirectory('trained.nta') DCNL DCSP netOPF.save(tmpNetworkFilename) DCNL DCSP netOPF2 = Network(tmpNetworkFilename) DCNL DCSP level1OPF2 = netOPF2.regions['level1SP'] DCNL DCSP sensor = netOPF.regions['sensor'].getSelf() DCNL DCSP trainFile = resource_filename('nupic.datafiles', 'extra/gym/gym.csv') DCNL DCSP sensor.dataSource = FileRecordStream(streamID=trainFile) DCNL DCSP sensor.dataSource.setAutoRewind(True) DCNL DCSP print 'Running DCSP inference DCSP on DCSP the DCSP two DCSP networks DCSP for DCSP 100 DCSP iterations' DCNL DCSP for _ in xrange(100): DCNL DCSP  DCSP netOPF2.run(1) DCNL DCSP  DCSP netOPF.run(1) DCNL DCSP  DCSP l1outputOPF2 = level1OPF2.getOutputData('bottomUpOut') DCNL DCSP  DCSP l1outputOPF = level1OPF.getOutputData('bottomUpOut') DCNL DCSP  DCSP opfHash2 = l1outputOPF2.nonzero()[0].sum() DCNL DCSP  DCSP opfHash = l1outputOPF.nonzero()[0].sum() DCNL DCSP  DCSP self.assertEqual(opfHash2, opfHash)
def testMaxEnabledPhase(self): DCNL DCSP print 'Creating DCSP network...' DCNL DCSP netOPF = _createOPFNetwork(addSP=True, addTP=True) DCNL DCSP netOPF.initialize() DCNL DCSP level1SP = netOPF.regions['level1SP'] DCNL DCSP level1SP.setParameter('learningMode', 1) DCNL DCSP level1SP.setParameter('inferenceMode', 0) DCNL DCSP tm = netOPF.regions['level1TP'] DCNL DCSP tm.setParameter('learningMode', 0) DCNL DCSP tm.setParameter('inferenceMode', 0) DCNL DCSP print 'maxPhase,maxEnabledPhase DCSP = DCSP ', netOPF.maxPhase, netOPF.getMaxEnabledPhase() DCNL DCSP self.assertEqual(netOPF.maxPhase, 2) DCNL DCSP self.assertEqual(netOPF.getMaxEnabledPhase(), 2) DCNL DCSP print 'Setting DCSP setMaxEnabledPhase DCSP to DCSP 1' DCNL DCSP netOPF.setMaxEnabledPhase(1) DCNL DCSP print 'maxPhase,maxEnabledPhase DCSP = DCSP ', netOPF.maxPhase, netOPF.getMaxEnabledPhase() DCNL DCSP self.assertEqual(netOPF.maxPhase, 2) DCNL DCSP self.assertEqual(netOPF.getMaxEnabledPhase(), 1) DCNL DCSP netOPF.run(1) DCNL DCSP print 'RUN DCSP SUCCEEDED' DCNL DCSP '\n DCSP  DCSP  DCSP  DCSP print DCSP "\nSetting DCSP setMaxEnabledPhase DCSP to DCSP 2"\n DCSP  DCSP  DCSP  DCSP netOPF.setMaxEnabledPhase(2)\n DCSP  DCSP  DCSP  DCSP print DCSP "maxPhase,maxEnabledPhase DCSP = DCSP ", DCSP netOPF.maxPhase, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP netOPF.getMaxEnabledPhase()\n DCSP  DCSP  DCSP  DCSP netOPF.run(1)\n\n DCSP  DCSP  DCSP  DCSP print DCSP "RUN DCSP SUCCEEDED"\n\n DCSP  DCSP  DCSP  DCSP print DCSP "\nSetting DCSP setMaxEnabledPhase DCSP to DCSP 1"\n DCSP  DCSP  DCSP  DCSP netOPF.setMaxEnabledPhase(1)\n DCSP  DCSP  DCSP  DCSP print DCSP "maxPhase,maxEnabledPhase DCSP = DCSP ", DCSP netOPF.maxPhase, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP netOPF.getMaxEnabledPhase()\n DCSP  DCSP  DCSP  DCSP netOPF.run(1)\n DCSP  DCSP  DCSP  DCSP print DCSP "RUN DCSP SUCCEEDED"\n DCSP  DCSP  DCSP  DCSP '
def testExperimentResults(self): DCNL DCSP nupic_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', '..', '..') DCNL DCSP opfDir = os.path.join(nupic_dir, 'examples', 'opf') DCNL DCSP testDir = opfDir DCNL DCSP if (not os.path.exists(os.path.join(testDir, 'experiments/classification'))): DCNL DCSP  DCSP testDir = opfDir DCNL DCSP command = ['python', os.path.join(testDir, 'experiments', 'classification', 'makeDatasets.py')] DCNL DCSP retval = call(command) DCNL DCSP self.assertEqual(retval, 0) DCNL DCSP command = ['python', os.path.join(testDir, 'experiments', 'multistep', 'make_datasets.py')] DCNL DCSP retval = call(command) DCNL DCSP self.assertEqual(retval, 0) DCNL DCSP command = ['python', os.path.join(testDir, 'experiments', 'spatial_classification', 'make_datasets.py')] DCNL DCSP retval = call(command) DCNL DCSP self.assertEqual(retval, 0) DCNL DCSP os.chdir(testDir) DCNL DCSP runExperiment = os.path.join(nupic_dir, 'scripts', 'run_opf_experiment.py') DCNL DCSP multistepTests = [{'experimentDir': 'experiments/multistep/simple_0', 'results': {('DefaultTask.TemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='avg_err':steps=1:window=200:field=field1"): (0.0, 0.2)}}, {'experimentDir': 'experiments/multistep/simple_0_f2', 'results': {('DefaultTask.TemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='aae':steps=1:window=200:field=field2"): (0.0, 0.66)}}, {'experimentDir': 'experiments/multistep/simple_1', 'results': {('DefaultTask.TemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='avg_err':steps=1:window=200:field=field1"): (0.0, 0.2)}}, {'experimentDir': 'experiments/multistep/simple_1_f2', 'results': {('DefaultTask.TemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='aae':steps=1:window=200:field=field2"): (0.0, 3.76)}}, {'experimentDir': 'experiments/multistep/simple_2', 'results': {('DefaultTask.TemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='avg_err':steps=1:window=200:field=field1"): (0.0, 0.31)}}, {'experimentDir': 'experiments/multistep/simple_3', 'results': {('DefaultTask.TemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='avg_err':steps=1:window=200:field=field1"): (0.0, 0.06), ('DefaultTask.TemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='avg_err':steps=3:window=200:field=field1"): (0.0, 0.2)}}, {'experimentDir': 'experiments/multistep/simple_3_f2', 'results': {('DefaultTask.TemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='aae':steps=1:window=200:field=field2"): (0.0, 0.6), ('DefaultTask.TemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='aae':steps=3:window=200:field=field2"): (0.0, 1.8)}}, {'experimentDir': 'experiments/missing_record/simple_0', 'results': {('DefaultTask.NontemporalMultiStep.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='avg_err':steps=1:window=25:field=field1"): (1.0, 1.0)}}] DCNL DCSP classificationTests = [{'experimentDir': 'experiments/classification/category_hub_TP_0', 'results': {('OnlineLearning.TemporalClassification.predictionLog.csv', 'classification:avg_err:window=200'): (0.0, 0.02)}}, {'experimentDir': 'experiments/classification/category_TM_0', 'results': {('OnlineLearning.TemporalClassification.predictionLog.csv', 'classification:avg_err:window=200'): (0.0, 0.045), ('OnlineLearning.TemporalClassification.predictionLog.csv', 'classConfidences:neg_auc:computeEvery=10:window=200'): ((-1.0), (-0.98))}}, {'experimentDir': 'experiments/classification/category_TM_1', 'results': {('OnlineLearning.TemporalClassification.predictionLog.csv', 'classification:avg_err:window=200'): (0.0, 0.005)}}, {'experimentDir': 'experiments/classification/scalar_TP_0', 'results': {('OnlineLearning.TemporalClassification.predictionLog.csv', 'classification:avg_err:window=200'): (0.0, 0.155), ('OnlineLearning.TemporalClassification.predictionLog.csv', 'classConfidences:neg_auc:computeEvery=10:window=200'): ((-1.0), (-0.9))}}, {'experimentDir': 'experiments/classification/scalar_TP_1', 'results': {('OnlineLearning.TemporalClassification.predictionLog.csv', 'classification:avg_err:window=200'): (0.0, 0.03)}}] DCNL DCSP spatialClassificationTests = [{'experimentDir': 'experiments/spatial_classification/category_0', 'results': {('DefaultTask.NontemporalClassification.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='avg_err':steps=0:window=100:field=classification"): (0.0, 0.05)}}, {'experimentDir': 'experiments/spatial_classification/category_1', 'results': {('DefaultTask.NontemporalClassification.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='avg_err':steps=0:window=100:field=classification"): (0.0, 0.0)}}, {'experimentDir': 'experiments/spatial_classification/scalar_0', 'results': {('DefaultTask.NontemporalClassification.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='aae':steps=0:window=100:field=classification"): (0.0, 0.025)}}, {'experimentDir': 'experiments/spatial_classification/scalar_1', 'results': {('DefaultTask.NontemporalClassification.predictionLog.csv', "multiStepBestPredictions:multiStep:errorMetric='aae':steps=0:window=100:field=classification"): ((-1e-10), 0.01)}}] DCNL DCSP anomalyTests = [{'experimentDir': 'experiments/anomaly/temporal/simple', 'results': {('DefaultTask.TemporalAnomaly.predictionLog.csv', 'anomalyScore:passThruPrediction:window=1000:field=f'): (0.02, 0.04)}}] DCNL DCSP tests = [] DCNL DCSP tests += multistepTests DCNL DCSP tests += classificationTests DCNL DCSP tests += spatialClassificationTests DCNL DCSP tests += anomalyTests DCNL DCSP summaryOfResults = [] DCNL DCSP startTime = time.time() DCNL DCSP testIdx = (-1) DCNL DCSP for test in tests: DCNL DCSP  DCSP testIdx += 1 DCNL DCSP  DCSP expDirectory = test['experimentDir'] DCNL DCSP  DCSP toDelete = [] DCNL DCSP  DCSP path = os.path.join(expDirectory, 'inference') DCNL DCSP  DCSP toDelete.append(path) DCNL DCSP  DCSP path = os.path.join(expDirectory, 'savedmodels') DCNL DCSP  DCSP toDelete.append(path) DCNL DCSP  DCSP for path in toDelete: DCNL DCSP  DCSP  DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP print ('Removing DCSP %s DCSP ...' % path) DCNL DCSP  DCSP  DCSP if os.path.isfile(path): DCNL DCSP  DCSP  DCSP  DCSP os.remove(path) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP shutil.rmtree(path) DCNL DCSP  DCSP args = test.get('args', []) DCNL DCSP  DCSP print ('Running DCSP experiment DCSP %s DCSP ...' % expDirectory) DCNL DCSP  DCSP command = (['python', runExperiment, expDirectory] + args) DCNL DCSP  DCSP retVal = call(command) DCNL DCSP  DCSP if retVal: DCNL DCSP  DCSP  DCSP print ('Details DCSP of DCSP failed DCSP test: DCSP %s' % test) DCNL DCSP  DCSP  DCSP print ("TestIdx DCSP %d, DCSP OPF DCSP experiment DCSP '%s' DCSP failed DCSP with DCSP return DCSP code DCSP %i." % (testIdx, expDirectory, retVal)) DCNL DCSP  DCSP self.assertFalse(retVal) DCNL DCSP  DCSP for (key, expValues) in test['results'].items(): DCNL DCSP  DCSP  DCSP (logFilename, colName) = key DCNL DCSP  DCSP  DCSP logFile = FileRecordStream(os.path.join(expDirectory, 'inference', logFilename)) DCNL DCSP  DCSP  DCSP colNames = [x[0] for x in logFile.getFields()] DCNL DCSP  DCSP  DCSP if (not (colName in colNames)): DCNL DCSP  DCSP  DCSP  DCSP print ('TestIdx DCSP %d: DCSP %s DCSP not DCSP one DCSP of DCSP the DCSP columns DCSP in DCSP prediction DCSP log DCSP file. DCSP Available DCSP column DCSP names DCSP are: DCSP %s' % (testIdx, colName, colNames)) DCNL DCSP  DCSP  DCSP self.assertTrue((colName in colNames)) DCNL DCSP  DCSP  DCSP colIndex = colNames.index(colName) DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP row = logFile.next() DCNL DCSP  DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP result = row[colIndex] DCNL DCSP  DCSP  DCSP summaryOfResults.append((expDirectory, colName, result)) DCNL DCSP  DCSP  DCSP print ('Actual DCSP result DCSP for DCSP %s, DCSP %s:' % (expDirectory, colName)), result DCNL DCSP  DCSP  DCSP print 'Expected DCSP range:', expValues DCNL DCSP  DCSP  DCSP failed = (((expValues[0] is not None) and (result < expValues[0])) or ((expValues[1] is not None) and (result > expValues[1]))) DCNL DCSP  DCSP  DCSP if failed: DCNL DCSP  DCSP  DCSP  DCSP print ('TestIdx DCSP %d: DCSP Experiment DCSP %s DCSP failed. DCSP \nThe DCSP actual DCSP result DCSP for DCSP %s DCSP (%s) DCSP was DCSP outside DCSP the DCSP allowed DCSP range DCSP of DCSP %s' % (testIdx, expDirectory, colName, result, expValues)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP Within DCSP expected DCSP range.' DCNL DCSP  DCSP  DCSP self.assertFalse(failed) DCNL DCSP print DCNL DCSP print 'Summary DCSP of DCSP results DCSP in DCSP all DCSP experiments DCSP run:' DCNL DCSP print '=========================================' DCNL DCSP prevExpDir = None DCNL DCSP for (expDir, key, results) in summaryOfResults: DCNL DCSP  DCSP if (expDir != prevExpDir): DCNL DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP print expDir DCNL DCSP  DCSP  DCSP prevExpDir = expDir DCNL DCSP  DCSP print (' DCSP  DCSP %s: DCSP %s' % (key, results)) DCNL DCSP print ('\nElapsed DCSP time: DCSP %.1f DCSP seconds' % (time.time() - startTime))
def shortDescription(self): DCNL DCSP return None
def compareOPFPredictionFiles(self, path1, path2, temporal, maxMismatches=None): DCNL DCSP experimentLabel = ('%s DCSP prediction DCSP comparison' % ('Temporal' if temporal else 'Non-Temporal')) DCNL DCSP print ('%s: DCSP Performing DCSP comparison DCSP of DCSP OPF DCSP prediction DCSP CSV DCSP files DCSP %r DCSP and DCSP %r' % (experimentLabel, path1, path2)) DCNL DCSP self.assertTrue(os.path.isfile(path1), msg=("OPF DCSP prediction DCSP file DCSP path1 DCSP %s DCSP doesn't DCSP exist DCSP or DCSP is DCSP not DCSP a DCSP file" % path1)) DCNL DCSP (opf1CsvReader, opf1FieldNames) = self._openOpfPredictionCsvFile(path1) DCNL DCSP self.assertTrue(os.path.isfile(path2), msg=("OPF DCSP prediction DCSP file DCSP path2 DCSP %s DCSP doesn't DCSP exist DCSP or DCSP is DCSP not DCSP a DCSP file" % path2)) DCNL DCSP (opf2CsvReader, opf2FieldNames) = self._openOpfPredictionCsvFile(path2) DCNL DCSP self.assertEqual(len(opf1FieldNames), len(opf2FieldNames), ('%s: DCSP Mismatch DCSP in DCSP number DCSP of DCSP prediction DCSP columns: DCSP opf1: DCSP %s, DCSP opf2: DCSP %s' % (experimentLabel, len(opf1FieldNames), len(opf2FieldNames)))) DCNL DCSP self.assertEqual(opf1FieldNames, opf2FieldNames) DCNL DCSP opf1EOF = False DCNL DCSP opf2EOF = False DCNL DCSP opf1CurrentDataRowIndex = (-1) DCNL DCSP opf2CurrentDataRowIndex = (-1) DCNL DCSP if temporal: DCNL DCSP  DCSP _skipOpf1Row = opf1CsvReader.next() DCNL DCSP  DCSP opf1CurrentDataRowIndex += 1 DCNL DCSP  DCSP _skipOpf2Row = opf2CsvReader.next() DCNL DCSP  DCSP opf2CurrentDataRowIndex += 1 DCNL DCSP fieldsIndexesToCompare = tuple(xrange(2, len(opf1FieldNames), 2)) DCNL DCSP self.assertGreater(len(fieldsIndexesToCompare), 0) DCNL DCSP print ('%s: DCSP Comparing DCSP fields DCSP at DCSP indexes: DCSP %s; DCSP opf1Labels: DCSP %s; DCSP opf2Labels: DCSP %s' % (experimentLabel, fieldsIndexesToCompare, [opf1FieldNames[i] for i in fieldsIndexesToCompare], [opf2FieldNames[i] for i in fieldsIndexesToCompare])) DCNL DCSP for i in fieldsIndexesToCompare: DCNL DCSP  DCSP self.assertTrue(opf1FieldNames[i].endswith('predicted'), msg=("%r DCSP doesn't DCSP end DCSP with DCSP 'predicted'" % opf1FieldNames[i])) DCNL DCSP  DCSP self.assertTrue(opf2FieldNames[i].endswith('predicted'), msg=("%r DCSP doesn't DCSP end DCSP with DCSP 'predicted'" % opf2FieldNames[i])) DCNL DCSP mismatchCount = 0 DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP opf1Row = opf1CsvReader.next() DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP opf1EOF = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP opf1CurrentDataRowIndex += 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP opf2Row = opf2CsvReader.next() DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP opf2EOF = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP opf2CurrentDataRowIndex += 1 DCNL DCSP  DCSP if (opf1EOF != opf2EOF): DCNL DCSP  DCSP  DCSP print ('%s: DCSP ERROR: DCSP Data DCSP row DCSP counts DCSP mismatch: DCSP opf1EOF: DCSP %s, DCSP opf1CurrentDataRowIndex: DCSP %s; DCSP opf2EOF: DCSP %s, DCSP opf2CurrentDataRowIndex: DCSP %s' % (experimentLabel, opf1EOF, opf1CurrentDataRowIndex, opf2EOF, opf2CurrentDataRowIndex)) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (opf1EOF and opf2EOF): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP self.assertEqual(len(opf1Row), len(opf2Row)) DCNL DCSP  DCSP for i in fieldsIndexesToCompare: DCNL DCSP  DCSP  DCSP opf1FloatValue = float(opf1Row[i]) DCNL DCSP  DCSP  DCSP opf2FloatValue = float(opf2Row[i]) DCNL DCSP  DCSP  DCSP if (opf1FloatValue != opf2FloatValue): DCNL DCSP  DCSP  DCSP  DCSP mismatchCount += 1 DCNL DCSP  DCSP  DCSP  DCSP print ('%s: DCSP ERROR: DCSP mismatch DCSP in DCSP prediction DCSP values: DCSP dataRowIndex: DCSP %s, DCSP fieldIndex: DCSP %s DCSP (%r); DCSP opf1FieldValue: DCSP <%s>, DCSP opf2FieldValue: DCSP <%s>; DCSP opf1FieldValueAsFloat: DCSP %s, DCSP opf2FieldValueAsFloat: DCSP %s; DCSP opf1Row: DCSP %s, DCSP opf2Row: DCSP %s' % (experimentLabel, opf1CurrentDataRowIndex, i, opf1FieldNames[i], opf1Row[i], opf2Row[i], opf1FloatValue, opf2FloatValue, opf1Row, opf2Row)) DCNL DCSP  DCSP  DCSP  DCSP if ((maxMismatches is not None) and (mismatchCount >= maxMismatches)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (mismatchCount != 0): DCNL DCSP  DCSP print ('%s: DCSP ERROR: DCSP there DCSP were DCSP %s DCSP mismatches DCSP between DCSP %r DCSP and DCSP %r' % (experimentLabel, mismatchCount, path1, path2)) DCNL DCSP  DCSP return False DCNL DCSP self.assertEqual(opf1CurrentDataRowIndex, opf2CurrentDataRowIndex) DCNL DCSP print ('%s: DCSP Comparison DCSP of DCSP predictions DCSP completed: DCSP OK; DCSP number DCSP of DCSP prediction DCSP rows DCSP examined: DCSP %s; DCSP path1: DCSP %r; DCSP path2: DCSP %r' % (experimentLabel, (opf1CurrentDataRowIndex + 1), path1, path2)) DCNL DCSP return True
def _openOpfPredictionCsvFile(self, filepath): DCNL DCSP csvReader = self._openCsvFile(filepath) DCNL DCSP names = csvReader.next() DCNL DCSP _types = csvReader.next() DCNL DCSP _specials = csvReader.next() DCNL DCSP return (csvReader, names)
def _testSamePredictions(self, experiment, predSteps, checkpointAt, predictionsFilename, additionalFields=None, newSerialization=False): DCNL DCSP aPlusBExpDir = os.path.join(_EXPERIMENT_BASE, experiment, 'a_plus_b') DCNL DCSP aExpDir = os.path.join(_EXPERIMENT_BASE, experiment, 'a') DCNL DCSP bExpDir = os.path.join(_EXPERIMENT_BASE, experiment, 'b') DCNL DCSP args = self._createExperimentArgs(aPlusBExpDir, newSerialization=newSerialization) DCNL DCSP _aPlusBExp = runExperiment(args) DCNL DCSP args = self._createExperimentArgs(aExpDir, newSerialization=newSerialization) DCNL DCSP _aExp = runExperiment(args) DCNL DCSP if os.path.exists(os.path.join(bExpDir, 'savedmodels')): DCNL DCSP  DCSP shutil.rmtree(os.path.join(bExpDir, 'savedmodels')) DCNL DCSP shutil.copytree(src=os.path.join(aExpDir, 'savedmodels'), dst=os.path.join(bExpDir, 'savedmodels')) DCNL DCSP args = self._createExperimentArgs(bExpDir, newSerialization=newSerialization, additionalArgs=['--load=DefaultTask']) DCNL DCSP _bExp = runExperiment(args) DCNL DCSP aPlusBPred = FileRecordStream(os.path.join(aPlusBExpDir, 'inference', predictionsFilename)) DCNL DCSP bPred = FileRecordStream(os.path.join(bExpDir, 'inference', predictionsFilename)) DCNL DCSP colNames = [x[0] for x in aPlusBPred.getFields()] DCNL DCSP actValueColIdx = colNames.index('multiStepPredictions.actual') DCNL DCSP predValueColIdx = colNames.index(('multiStepPredictions.%d' % predSteps)) DCNL DCSP for i in range(checkpointAt): DCNL DCSP  DCSP aPlusBPred.next() DCNL DCSP for i in range(predSteps): DCNL DCSP  DCSP aPlusBPred.next() DCNL DCSP  DCSP bPred.next() DCNL DCSP rowIdx = (((checkpointAt + predSteps) + 4) - 1) DCNL DCSP epsilon = 0.0001 DCNL DCSP while True: DCNL DCSP  DCSP rowIdx += 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rowAPB = aPlusBPred.next() DCNL DCSP  DCSP  DCSP rowB = bPred.next() DCNL DCSP  DCSP  DCSP self.assertEqual(rowAPB[actValueColIdx], rowB[actValueColIdx], ('Mismatch DCSP in DCSP actual DCSP values: DCSP row DCSP %d DCSP of DCSP a+b DCSP has DCSP %s DCSP and DCSP row DCSP %d DCSP of DCSP b DCSP has DCSP %s' % (rowIdx, rowAPB[actValueColIdx], (rowIdx - checkpointAt), rowB[actValueColIdx]))) DCNL DCSP  DCSP  DCSP predAPB = eval(rowAPB[predValueColIdx]) DCNL DCSP  DCSP  DCSP predB = eval(rowB[predValueColIdx]) DCNL DCSP  DCSP  DCSP predAPB = [(a, b) for (b, a) in predAPB.items()] DCNL DCSP  DCSP  DCSP predB = [(a, b) for (b, a) in predB.items()] DCNL DCSP  DCSP  DCSP predAPB.sort(reverse=True) DCNL DCSP  DCSP  DCSP predB.sort(reverse=True) DCNL DCSP  DCSP  DCSP if (additionalFields is not None): DCNL DCSP  DCSP  DCSP  DCSP for additionalField in additionalFields: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fieldIdx = colNames.index(additionalField) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.assertEqual(rowAPB[fieldIdx], rowB[fieldIdx], ("Mismatch DCSP in DCSP field DCSP '%s' DCSP values: DCSP row DCSP %d DCSP of DCSP a+b DCSP has DCSP value: DCSP (%s)\n DCSP and DCSP row DCSP %d DCSP of DCSP b DCSP has DCSP value: DCSP %s" % (additionalField, rowIdx, rowAPB[fieldIdx], (rowIdx - checkpointAt), rowB[fieldIdx]))) DCNL DCSP  DCSP  DCSP self.assertEqual(len(predAPB), len(predB), ('Mismatch DCSP in DCSP predicted DCSP values: DCSP row DCSP %d DCSP of DCSP a+b DCSP has DCSP %d DCSP predictions: DCSP \n DCSP  DCSP (%s) DCSP and DCSP row DCSP %d DCSP of DCSP b DCSP has DCSP %d DCSP predictions:\n DCSP  DCSP (%s)' % (rowIdx, len(predAPB), predAPB, (rowIdx - checkpointAt), len(predB), predB))) DCNL DCSP  DCSP  DCSP for i in range(len(predAPB)): DCNL DCSP  DCSP  DCSP  DCSP (aProb, aValue) = predAPB[i] DCNL DCSP  DCSP  DCSP  DCSP (bProb, bValue) = predB[i] DCNL DCSP  DCSP  DCSP  DCSP self.assertLess(abs((aValue - bValue)), epsilon, ('Mismatch DCSP in DCSP predicted DCSP values: DCSP row DCSP %d DCSP of DCSP a+b DCSP predicts DCSP value DCSP %s DCSP and DCSP row DCSP %d DCSP of DCSP b DCSP predicts DCSP %s' % (rowIdx, aValue, (rowIdx - checkpointAt), bValue))) DCNL DCSP  DCSP  DCSP  DCSP self.assertLess(abs((aProb - bProb)), epsilon, ('Mismatch DCSP in DCSP probabilities: DCSP row DCSP %d DCSP of DCSP a+b DCSP predicts DCSP %s DCSP with DCSP probability DCSP %s DCSP and DCSP row DCSP %d DCSP of DCSP b DCSP predicts DCSP %s DCSP with DCSP probability DCSP %s' % (rowIdx, aValue, aProb, (rowIdx - checkpointAt), bValue, bProb))) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP break DCNL DCSP shutil.rmtree(getCheckpointParentDir(aExpDir)) DCNL DCSP shutil.rmtree(getCheckpointParentDir(bExpDir)) DCNL DCSP shutil.rmtree(getCheckpointParentDir(aPlusBExpDir)) DCNL DCSP print 'Predictions DCSP match!'
@staticmethod DCNL def _testBackwardsCompatibility(experiment, checkpointName): DCNL DCSP expDir = os.path.join(_EXPERIMENT_BASE, experiment) DCNL DCSP if os.path.exists(os.path.join(expDir, 'savedmodels')): DCNL DCSP  DCSP shutil.rmtree(os.path.join(expDir, 'savedmodels')) DCNL DCSP shutil.copytree(src=os.path.join(expDir, checkpointName), dst=os.path.join(expDir, 'savedmodels')) DCNL DCSP _aPlusBExp = runExperiment(args=[expDir, '--load=DefaultTask', '--noCheckpoint'])
def test_NonTemporalMultiStep(self): DCNL DCSP self._testSamePredictions(experiment='non_temporal_multi_step', predSteps=24, checkpointAt=250, predictionsFilename='DefaultTask.NontemporalMultiStep.predictionLog.csv')
@unittest.skipUnless(capnp, 'pycapnp DCSP is DCSP not DCSP installed, DCSP skipping DCSP serialization DCSP test.') DCNL def test_NonTemporalMultiStepNew(self): DCNL DCSP self._testSamePredictions(experiment='non_temporal_multi_step', predSteps=24, checkpointAt=250, predictionsFilename='DefaultTask.NontemporalMultiStep.predictionLog.csv', newSerialization=True)
@unittest.skip('Currently DCSP Fails: DCSP NUP-1864') DCNL def test_TemporalMultiStep(self): DCNL DCSP self._testSamePredictions(experiment='temporal_multi_step', predSteps=24, checkpointAt=250, predictionsFilename='DefaultTask.TemporalMultiStep.predictionLog.csv')
@unittest.skip('Currently DCSP Fails: DCSP NUP-1864') DCNL def test_TemporalAnomaly(self): DCNL DCSP self._testSamePredictions(experiment='temporal_anomaly', predSteps=1, checkpointAt=250, predictionsFilename='DefaultTask.TemporalAnomaly.predictionLog.csv', additionalFields=['anomalyScore'])
@unittest.skip("We DCSP aren't DCSP currently DCSP supporting DCSP serialization DCSP backward DCSP compatibility") DCNL def test_BackwardsCompatibility(self): DCNL DCSP self._testBackwardsCompatibility(os.path.join('backwards_compatibility', 'a'), 'savedmodels_2012-10-05')
def setUp(self): DCNL DCSP print DCNL DCSP return
def testAll(self): DCNL DCSP print 'VectorFileSensorTest DCSP parameters:' DCNL DCSP print ('PYTHONPATH: DCSP %s' % os.environ.get('PYTHONPATH', 'NOT DCSP SET')) DCNL DCSP print ('filename: DCSP %s' % self.filename) DCNL DCSP self._testRunWithoutFile() DCNL DCSP self._testNetLoad() DCNL DCSP self._testFakeLoadFile() DCNL DCSP self._testRepeatCount() DCNL DCSP self._testUnknownCommand() DCNL DCSP self._testOutputCounts(0) DCNL DCSP self._testLoadFile(self.dataFile, '0', '0') DCNL DCSP self._testOutputCounts(5) DCNL DCSP self._testLoadFile(self.dataFile, '0', '0') DCNL DCSP self._testRun() DCNL DCSP self._testLoadFile(self.dataFile2, '', '0') DCNL DCSP self._testRun() DCNL DCSP self._testLoadFile(self.dataFile2, '2', '0') DCNL DCSP self._testRun() DCNL DCSP self._testLoadFile(self.dataFile3a, '3', '0') DCNL DCSP self._testRun() DCNL DCSP self._testLoadFile(self.dataFile4, '4', '0') DCNL DCSP self._testRun() DCNL DCSP self._testLoadFile(self.dataFile5, '5', '0') DCNL DCSP self._testRun() DCNL DCSP self._testLoadFile(self.dataFile6, '6', '0') DCNL DCSP self._testRun() DCNL DCSP self._testPosition() DCNL DCSP self._testAppendFile(self.dataFile2, '2', '1', 10) DCNL DCSP self._testAppendFile(self.dataFile, '0', '1', 15) DCNL DCSP self._testRun() DCNL DCSP self._testScaling(self.dataFile3b, '3') DCNL DCSP self.sensor.setParameter('hasCategoryOut', 1) DCNL DCSP self.sensor.setParameter('hasResetOut', 1) DCNL DCSP self._testLoadFile(self.dataFile3c, '3', '0') DCNL DCSP self._testOptionalOutputs() DCNL DCSP self.sensor.setParameter('hasCategoryOut', 0) DCNL DCSP self.sensor.setParameter('hasResetOut', 0)
def _testNetLoad(self): DCNL DCSP n = Network() DCNL DCSP r = n.addRegion(self.nodeName, self.sensorName, '{ DCSP activeOutputCount: DCSP 11}') DCNL DCSP r.dimensions = Dimensions([1]) DCNL DCSP n.save(self.filename) DCNL DCSP n = Network(self.filename) DCNL DCSP n.initialize() DCNL DCSP self.testsPassed += 1 DCNL DCSP r = n.regions[self.nodeName] DCNL DCSP res = r.getParameter('vectorCount') DCNL DCSP self.assertEqual(res, 0, ("getting DCSP vectorCount:\n DCSP Expected DCSP '0', DCSP  DCSP got DCSP back DCSP  DCSP '%d'\n" % res)) DCNL DCSP self.sensor = r
def _testFakeLoadFile(self): DCNL DCSP with self.assertRaises(RuntimeError): DCNL DCSP  DCSP self.sensor.executeCommand(['loadFile', 'ExistenceIsAnIllusion.txt', '0'])
def _testRunWithoutFile(self): DCNL DCSP with self.assertRaises(AttributeError): DCNL DCSP  DCSP self.sensor.compute()
def _testRepeatCount(self): DCNL DCSP n = Network(self.filename) DCNL DCSP sensor = n.regions[self.nodeName] DCNL DCSP res = sensor.executeCommand(['dump']) DCNL DCSP expected = (self.sensorName + ' DCSP isLabeled DCSP = DCSP 0 DCSP repeatCount DCSP = DCSP 1 DCSP vectorCount DCSP = DCSP 0 DCSP iterations DCSP = DCSP 0\n') DCNL DCSP self.assertEqual(res, expected, ("repeat DCSP count DCSP test:\n DCSP  DCSP  DCSP expected DCSP '%s'\n DCSP  DCSP  DCSP got DCSP  DCSP  DCSP  DCSP  DCSP  DCSP '%s'\n" % (expected, res))) DCNL DCSP sensor.setParameter('repeatCount', 42) DCNL DCSP res = sensor.getParameter('repeatCount') DCNL DCSP self.assertEqual(res, 42, ("set DCSP repeatCount DCSP to DCSP 42:\n DCSP  DCSP  DCSP got DCSP back DCSP  DCSP  DCSP  DCSP  DCSP '%d'\n" % res)) DCNL DCSP res = sensor.executeCommand(['dump']) DCNL DCSP expected = (self.sensorName + ' DCSP isLabeled DCSP = DCSP 0 DCSP repeatCount DCSP = DCSP 42 DCSP vectorCount DCSP = DCSP 0 DCSP iterations DCSP = DCSP 0\n') DCNL DCSP self.assertEqual(res, expected, ("set DCSP to DCSP 42 DCSP test:\n DCSP  DCSP  DCSP expected DCSP '%s'\n DCSP  DCSP  DCSP got DCSP  DCSP  DCSP  DCSP  DCSP  DCSP '%s'\n" % (expected, res))) DCNL DCSP sensor.setParameter('repeatCount', 1)
def _testLoadFile(self, dataFile, fileFormat='', iterations=''): DCNL DCSP if (fileFormat != ''): DCNL DCSP  DCSP res = self.sensor.executeCommand(['loadFile', dataFile, fileFormat]) DCNL DCSP else: DCNL DCSP  DCSP res = self.sensor.executeCommand(['loadFile', dataFile]) DCNL DCSP self.assertTrue(((res == '') or res.startswith('VectorFileSensor DCSP read DCSP in DCSP file')), ('loading DCSP a DCSP real DCSP file: DCSP %s' % str(res))) DCNL DCSP res = self.sensor.getParameter('recentFile') DCNL DCSP self.assertEqual(res, dataFile, ('recent DCSP file, DCSP got: DCSP %s' % res)) DCNL DCSP res = self.sensor.executeCommand(['dump']) DCNL DCSP expected = (((self.sensorName + ' DCSP isLabeled DCSP = DCSP 0 DCSP repeatCount DCSP = DCSP 1 DCSP vectorCount DCSP = DCSP 5 DCSP iterations DCSP = DCSP ') + iterations) + '\n') DCNL DCSP self.assertEqual(res, expected, ('file DCSP summary:\n DCSP  DCSP  DCSP expected DCSP "%s"\n DCSP  DCSP  DCSP got DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "%s"\n' % (expected, res)))
def _testAppendFile(self, dataFile, fileFormat='', iterations='', numVecs=''): DCNL DCSP if (fileFormat != ''): DCNL DCSP  DCSP res = self.sensor.executeCommand(['appendFile', dataFile, fileFormat]) DCNL DCSP else: DCNL DCSP  DCSP res = self.sensor.executeCommand(['appendFile', dataFile]) DCNL DCSP self.assertTrue(((res == '') or res.startswith('VectorFileSensor DCSP read DCSP in DCSP file')), ('loading DCSP a DCSP real DCSP file: DCSP %s' % str(res))) DCNL DCSP res = self.sensor.getParameter('recentFile') DCNL DCSP self.assertEqual(res, dataFile, ('recent DCSP file, DCSP got: DCSP %s' % res)) DCNL DCSP res = self.sensor.executeCommand(['dump']) DCNL DCSP expected = ((((((self.sensorName + ' DCSP isLabeled DCSP = DCSP 0 DCSP repeatCount DCSP = DCSP 1') + ' DCSP vectorCount DCSP = DCSP ') + str(numVecs)) + ' DCSP iterations DCSP = DCSP ') + iterations) + '\n') DCNL DCSP self.assertEqual(res, expected, ('file DCSP summary:\n DCSP  DCSP  DCSP expected DCSP "%s"\n DCSP  DCSP  DCSP got DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "%s"\n' % (expected, res))) DCNL DCSP res = self.sensor.getParameter('vectorCount') DCNL DCSP self.assertEqual(res, numVecs, (('getting DCSP position:\n DCSP Expected DCSP ' + str(numVecs)) + (', DCSP  DCSP got DCSP back DCSP  DCSP "%s"\n' % res)))
def _testRun(self): DCNL DCSP self.sensor.setParameter('repeatCount', 3) DCNL DCSP self.sensor.setParameter('position', 0) DCNL DCSP for _epoch in [1, 2]: DCNL DCSP  DCSP for vec in [0, 1, 2, 3, 4]: DCNL DCSP  DCSP  DCSP for _rc in [1, 2, 3]: DCNL DCSP  DCSP  DCSP  DCSP self.sensor.compute() DCNL DCSP  DCSP  DCSP  DCSP outputs = self.sensor.getOutputData('dataOut') DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(outputs[vec], (vec + 1), ('output DCSP = DCSP %s' % str(outputs))) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sum(outputs), (vec + 1), ('output DCSP = DCSP %s' % str(outputs))) DCNL DCSP self.sensor.setParameter('repeatCount', 1)
def _testOutputCounts(self, vectorCount): DCNL DCSP res = self.sensor.getParameter('maxOutputVectorCount') DCNL DCSP self.assertEqual(res, vectorCount, (("getting DCSP maxOutputVectorCount:\n DCSP Expected DCSP '" + str(vectorCount)) + ("', DCSP  DCSP got DCSP back DCSP  DCSP '%d'\n" % res))) DCNL DCSP self.sensor.setParameter('repeatCount', 3) DCNL DCSP res = self.sensor.getParameter('maxOutputVectorCount') DCNL DCSP self.assertEqual(res, (3 * vectorCount), (('getting DCSP maxOutputVectorCount:\n DCSP Expected DCSP ' + str((3 * vectorCount))) + (', DCSP  DCSP got DCSP back DCSP  DCSP "%d"\n' % res))) DCNL DCSP self.sensor.setParameter('repeatCount', 1) DCNL DCSP res = self.sensor.getParameter('activeOutputCount') DCNL DCSP self.assertEqual(res, 11, ('getting DCSP activeOutputCount DCSP :\n DCSP Expected DCSP 11, DCSP  DCSP got DCSP back DCSP  DCSP "%d"\n' % res))
def _testPosition(self): DCNL DCSP self.sensor.setParameter('position', 2) DCNL DCSP self.sensor.compute() DCNL DCSP outputs = self.sensor.getOutputData('dataOut') DCNL DCSP self.assertEqual(outputs[2], 3, ('output DCSP = DCSP %s' % str(outputs))) DCNL DCSP self.assertEqual(sum(outputs), 3, ('output DCSP = DCSP %s' % str(outputs))) DCNL DCSP res = self.sensor.getParameter('position') DCNL DCSP self.assertEqual(res, 3, ('getting DCSP position:\n DCSP Expected DCSP "3", DCSP  DCSP got DCSP back DCSP  DCSP "%d"\n' % res))
def _testScaling(self, dataFile, fileFormat=''): DCNL DCSP res = self.sensor.getParameter('scalingMode') DCNL DCSP self.assertEqual(res, 'none', ('Getting DCSP scalingMode:\n DCSP Expected DCSP "none", DCSP got DCSP back DCSP "%s"\n' % res)) DCNL DCSP a = Array('Real32', 11) DCNL DCSP self.sensor.getParameterArray('scaleVector', a) DCNL DCSP self.assertEqual(str(a), '[ DCSP 1 DCSP 1 DCSP 1 DCSP 1 DCSP 1 DCSP 1 DCSP 1 DCSP 1 DCSP 1 DCSP 1 DCSP 1 DCSP ]', ('Error DCSP getting DCSP ones DCSP scaleVector:\n DCSP Got DCSP back DCSP "%s"\n' % str(res))) DCNL DCSP self.sensor.getParameterArray('offsetVector', a) DCNL DCSP self.assertEqual(str(a), '[ DCSP 0 DCSP 0 DCSP 0 DCSP 0 DCSP 0 DCSP 0 DCSP 0 DCSP 0 DCSP 0 DCSP 0 DCSP 0 DCSP ]', ('Error DCSP getting DCSP zero DCSP offsetVector:\n DCSP Got DCSP back DCSP "%s"\n' % str(res))) DCNL DCSP self.sensor.executeCommand(['loadFile', dataFile, fileFormat]) DCNL DCSP self.sensor.setParameter('scalingMode', 'standardForm') DCNL DCSP self.sensor.getParameterArray('scaleVector', a) DCNL DCSP s = '[ DCSP 2.23607 DCSP 1.11803 DCSP 0.745356 DCSP 0.559017 DCSP 0.447214 DCSP 2.23607 DCSP 1.11803 DCSP 0.745356 DCSP 0.559017 DCSP 0.447214 DCSP 2.23607 DCSP ]' DCNL DCSP self.assertEqual(str(a), s, ('Error DCSP getting DCSP standardForm DCSP scaleVector:\n DCSP Got DCSP back DCSP "%s"\n' % res)) DCNL DCSP o = '[ DCSP -0.2 DCSP -0.4 DCSP -0.6 DCSP -0.8 DCSP -1 DCSP -0.2 DCSP -0.4 DCSP -0.6 DCSP -0.8 DCSP -1 DCSP -0.2 DCSP ]' DCNL DCSP self.sensor.getParameterArray('offsetVector', a) DCNL DCSP self.assertEqual(str(a), o, ('Error DCSP getting DCSP standardForm DCSP offsetVector:\n DCSP Got DCSP back DCSP "%s"\n' % res)) DCNL DCSP scaleVector = Array('Real32', 11) DCNL DCSP for (i, x) in enumerate((1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1)): DCNL DCSP  DCSP scaleVector[i] = x DCNL DCSP self.sensor.setParameterArray('scaleVector', scaleVector) DCNL DCSP self.sensor.getParameterArray('scaleVector', a) DCNL DCSP self.assertEqual(str(a), str(scaleVector), ('Error DCSP getting DCSP modified DCSP scaleVector:\n DCSP Got DCSP back DCSP "%s"\n' % str(res))) DCNL DCSP offsetVector = Array('Real32', 11) DCNL DCSP for (i, x) in enumerate((1, 2, 3, 4, 1, 1, 1, 1, 1, 2, 1)): DCNL DCSP  DCSP offsetVector[i] = x DCNL DCSP self.sensor.setParameterArray('offsetVector', offsetVector) DCNL DCSP self.sensor.getParameterArray('offsetVector', a) DCNL DCSP self.assertEqual(str(a), str(offsetVector), ('Error DCSP getting DCSP modified DCSP offsetVector:\n DCSP Got DCSP back DCSP "%s"\n' % str(res))) DCNL DCSP mode = self.sensor.getParameter('scalingMode') DCNL DCSP self.assertEqual(mode, 'custom', ('Getting DCSP scalingMode:\n DCSP Expected DCSP "custom", DCSP got DCSP back DCSP "%s"\n' % res)) DCNL DCSP res = self.sensor.executeCommand(['loadFile', dataFile, fileFormat]) DCNL DCSP self.sensor.getParameterArray('offsetVector', a) DCNL DCSP self.assertEqual(str(a), str(offsetVector), ('Error DCSP getting DCSP modified DCSP offsetVector DCSP after DCSP loadFile:\n DCSP Got DCSP back DCSP "%s"\n' % res)) DCNL DCSP self.sensor.getParameterArray('scaleVector', a) DCNL DCSP self.assertEqual(str(a), str(scaleVector), ('Error DCSP getting DCSP modified DCSP scaleVector DCSP after DCSP loadFile:\n DCSP Got DCSP back DCSP "%s"\n' % res)) DCNL DCSP self.sensor.setParameter('scalingMode', 'none') DCNL DCSP self.sensor.getParameterArray('scaleVector', a) DCNL DCSP noScaling = Array('Real32', 11) DCNL DCSP for i in range(11): DCNL DCSP  DCSP noScaling[i] = 1 DCNL DCSP self.assertEqual(str(a), str(noScaling), ('Error DCSP getting DCSP ones DCSP scaleVector:\n DCSP Got DCSP back DCSP "%s"\n' % res)) DCNL DCSP noOffset = Array('Real32', 11) DCNL DCSP for i in range(11): DCNL DCSP  DCSP noOffset[i] = 0 DCNL DCSP self.sensor.getParameterArray('offsetVector', a) DCNL DCSP self.assertEqual(str(a), str(noOffset), ('Error DCSP getting DCSP zero DCSP offsetVector:\n DCSP Got DCSP back DCSP "%s"\n' % res))
def _testUnknownCommand(self): DCNL DCSP with self.assertRaises(RuntimeError): DCNL DCSP  DCSP self.sensor.executeCommand(['nonExistentCommand'])
def _testOptionalOutputs(self): DCNL DCSP self.sensor.setParameter('repeatCount', 3) DCNL DCSP self.sensor.setParameter('position', 0) DCNL DCSP categories = [] DCNL DCSP resetOuts = [] DCNL DCSP for _epoch in [1, 2]: DCNL DCSP  DCSP for vec in [0, 1, 2, 3, 4]: DCNL DCSP  DCSP  DCSP for _rc in [1, 2, 3]: DCNL DCSP  DCSP  DCSP  DCSP self.sensor.compute() DCNL DCSP  DCSP  DCSP  DCSP outputs = self.sensor.getOutputData('dataOut') DCNL DCSP  DCSP  DCSP  DCSP a = self.sensor.getOutputData('categoryOut') DCNL DCSP  DCSP  DCSP  DCSP categories.append(a[0]) DCNL DCSP  DCSP  DCSP  DCSP a = self.sensor.getOutputData('resetOut') DCNL DCSP  DCSP  DCSP  DCSP resetOuts.append(a[0]) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(outputs[vec], (vec + 1), ('output DCSP = DCSP %s' % str(outputs))) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqual(sum(outputs), (vec + 1), ('output DCSP = DCSP %s' % str(outputs))) DCNL DCSP self.assertEqual(categories, (2 * (([6] * 12) + ([8] * 3)))) DCNL DCSP self.assertEqual(resetOuts, (2 * [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1])) DCNL DCSP self.sensor.setParameter('repeatCount', 1)
def testTMPyCpp(self): DCNL DCSP results1 = createAndRunNetwork(TMRegion, 'bottomUpOut', checkpointMidway=False, temporalImp='tm_cpp') DCNL DCSP results2 = createAndRunNetwork(TMRegion, 'bottomUpOut', checkpointMidway=False, temporalImp='tm_py') DCNL DCSP self.compareArrayResults(results1, results2)
def __updateProcessCounter(self): DCNL DCSP newcounter = 0 DCNL DCSP for job in self.__procs: DCNL DCSP  DCSP if job.is_alive(): DCNL DCSP  DCSP  DCSP newcounter += 1 DCNL DCSP self.__numRunningProcs = newcounter DCNL DCSP return newcounter
def cancelJobs(self): DCNL DCSP print 'Terminating DCSP all DCSP Jobs DCSP due DCSP to DCSP reaching DCSP timeout' DCNL DCSP for proc in self.__procs: DCNL DCSP  DCSP if (not proc.is_alive()): DCNL DCSP  DCSP  DCSP proc.terminate() DCNL DCSP print 'All DCSP jobs DCSP have DCSP been DCSP terminated'
def runJobs(self, maxJobs): DCNL DCSP jobsrunning = self.__numRunningProcs DCNL DCSP if (maxJobs > 1): DCNL DCSP  DCSP jobsindx = 0 DCNL DCSP  DCSP while ((jobsindx < len(self.testQ)) or (jobsrunning > 0)): DCNL DCSP  DCSP  DCSP if ((jobsindx < len(self.testQ)) and (jobsrunning < maxJobs)): DCNL DCSP  DCSP  DCSP  DCSP curJob = self.testQ[jobsindx] DCNL DCSP  DCSP  DCSP  DCSP p = Process(target=curJob[0], args=curJob[1]) DCNL DCSP  DCSP  DCSP  DCSP p.start() DCNL DCSP  DCSP  DCSP  DCSP self.__procs.append(p) DCNL DCSP  DCSP  DCSP  DCSP jobsindx += 1 DCNL DCSP  DCSP  DCSP if (jobsrunning >= maxJobs): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP print 'Maximum DCSP number DCSP of DCSP jobs DCSP running, DCSP waiting DCSP before DCSP launching DCSP new DCSP jobs' DCNL DCSP  DCSP  DCSP elif (jobsindx == len(self.testQ)): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP print 'Waiting DCSP for DCSP all DCSP scheduled DCSP tests DCSP to DCSP finish.' DCNL DCSP  DCSP  DCSP jobsrunning = self.__updateProcessCounter() DCNL DCSP  DCSP  DCSP for proc in self.__procs: DCNL DCSP  DCSP  DCSP  DCSP if (proc.exitcode == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.cancelJobs() DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert False, 'Some DCSP jobs DCSP have DCSP not DCSP been DCSP able DCSP to DCSP complete DCSP in DCSP the DCSP allotted DCSP time.' DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP result = self.__resultQ.get(True, 5) DCNL DCSP  DCSP  DCSP self.assertBenchmarks(result) DCNL DCSP except Empty: DCNL DCSP  DCSP pass
def setUpExportDicts(self): DCNL DCSP ret = [] DCNL DCSP if (self.maxBranchings is None): DCNL DCSP  DCSP self.maxBranchings = [None] DCNL DCSP else: DCNL DCSP  DCSP self.maxBranchings = self.maxBranchings.split(',') DCNL DCSP if (self.maxParticles is None): DCNL DCSP  DCSP self.maxParticles = [None] DCNL DCSP else: DCNL DCSP  DCSP self.maxParticles = self.maxParticles.split(',') DCNL DCSP for branch in self.maxBranchings: DCNL DCSP  DCSP for part in self.maxParticles: DCNL DCSP  DCSP  DCSP curdict = dict() DCNL DCSP  DCSP  DCSP if (not (branch is None)): DCNL DCSP  DCSP  DCSP  DCSP curdict[self.BRANCHING_PROP] = branch DCNL DCSP  DCSP  DCSP if (not (part is None)): DCNL DCSP  DCSP  DCSP  DCSP curdict[self.PARTICLE_PROP] = part DCNL DCSP  DCSP  DCSP ret += [curdict] DCNL DCSP return ret
def benchmarkHotGym(self): DCNL DCSP dataPath = os.path.join(self.datadir, 'hotgym', 'hotgym.csv') DCNL DCSP streamDef = dict(version=1, info='hotgym DCSP benchmark DCSP test', streams=[dict(source=('file://%s' % dataPath), info='hotgym.csv', columns=['gym', 'timestamp', 'consumption'], last_record=self.splits['hotgym'])], aggregation={'hours': 1, 'fields': [('consumption', 'sum'), ('gym', 'first')]}) DCNL DCSP expDesc = OPFBenchmarkRunner.EXP_COMMON.copy() DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'consumption' DCNL DCSP expDesc.update({'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 1.1, 'maxValue': 44.72}, {'fieldName': 'gym', 'fieldType': 'string'}], 'iterationCount': self.__recordsToProcess}) DCNL DCSP expdir = os.path.join(self.outdir, 'hotgym') DCNL DCSP self.generateModules(expDesc, expdir) DCNL DCSP self.descriptions['hotgym'] = (expdir, expDesc) DCNL DCSP return expdir
def benchmarkSine(self): DCNL DCSP dataPath = os.path.join(self.datadir, 'sine', 'sine.csv') DCNL DCSP streamDef = dict(version=1, info='hotgym DCSP benchmark DCSP test', streams=[dict(source=('file://%s' % dataPath), info='sine.csv', columns=['Sine', 'angle'], last_record=self.splits['sine'])]) DCNL DCSP expDesc = OPFBenchmarkRunner.EXP_COMMON.copy() DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'Sine' DCNL DCSP expDesc.update({'streamDef': streamDef, 'includedFields': [{'fieldName': 'Sine', 'fieldType': 'float', 'minValue': (-1.0), 'maxValue': 1.0}, {'fieldName': 'angle', 'fieldType': 'float', 'minValue': 0.0, 'maxValue': 25.0}], 'iterationCount': self.__recordsToProcess}) DCNL DCSP expdir = os.path.join(self.outdir, 'sine') DCNL DCSP self.generateModules(expDesc, expdir) DCNL DCSP self.descriptions['sine'] = (expdir, expDesc) DCNL DCSP return expdir
def benchmarkTwoVars(self): DCNL DCSP dataPath = os.path.join(self.datadir, 'generated', 'spatial', 'linear_two_fields', 'sample2.csv') DCNL DCSP streamDef = dict(version=1, info='two DCSP fields DCSP test', streams=[dict(source=('file://%s' % dataPath), info='linear_two_fields', columns=['field1', 'field2'], last_record=self.splits['twovars'])]) DCNL DCSP expDesc = OPFBenchmarkRunner.EXP_COMMON.copy() DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'field1' DCNL DCSP expDesc.update({'streamDef': streamDef, 'includedFields': [{'fieldName': 'field1', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 110}, {'fieldName': 'field2', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 110}], 'iterationCount': self.__recordsToProcess}) DCNL DCSP expdir = os.path.join(self.outdir, 'twovars') DCNL DCSP self.generateModules(expDesc, expdir) DCNL DCSP self.descriptions['twovars'] = (expdir, expDesc) DCNL DCSP return expdir
def benchmarkThreeVars(self): DCNL DCSP dataPath = os.path.join(self.datadir, 'generated', 'spatial', 'linear_two_plus_one_fields', 'sample1.csv') DCNL DCSP streamDef = dict(version=1, info='three DCSP fields DCSP test', streams=[dict(source=('file://%s' % dataPath), info='linear_two_plus_one_fields', columns=['field1', 'field2', 'field3'], last_record=self.splits['threevars'])]) DCNL DCSP expDesc = OPFBenchmarkRunner.EXP_COMMON.copy() DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'field1' DCNL DCSP expDesc.update({'streamDef': streamDef, 'includedFields': [{'fieldName': 'field1', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 110}, {'fieldName': 'field2', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 110}, {'fieldName': 'field3', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 110}], 'iterationCount': self.__recordsToProcess}) DCNL DCSP expdir = os.path.join(self.outdir, 'threevars') DCNL DCSP self.generateModules(expDesc, expdir) DCNL DCSP self.descriptions['threevars'] = (expdir, expDesc) DCNL DCSP return expdir
def benchmarkFourVars(self): DCNL DCSP dataPath = os.path.join(self.datadir, 'generated', 'spatial', 'sum_two_fields_plus_extra_field', 'sample1.csv') DCNL DCSP streamDef = dict(version=1, info='four DCSP fields DCSP test', streams=[dict(source=('file://%s' % dataPath), info='linear_two_plus_one_fields', columns=['field1', 'field2', 'field3', 'field4'], last_record=self.splits['fourvars'])]) DCNL DCSP expDesc = OPFBenchmarkRunner.EXP_COMMON.copy() DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'field1' DCNL DCSP expDesc.update({'streamDef': streamDef, 'includedFields': [{'fieldName': 'field1', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 210}, {'fieldName': 'field2', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 110}, {'fieldName': 'field3', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 110}, {'fieldName': 'field4', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 110}], 'iterationCount': self.__recordsToProcess}) DCNL DCSP expdir = os.path.join(self.outdir, 'fourvars') DCNL DCSP self.generateModules(expDesc, expdir) DCNL DCSP self.descriptions['fourvars'] = (expdir, expDesc) DCNL DCSP return expdir
def benchmarkCategories(self): DCNL DCSP dataPath = os.path.join(self.datadir, 'generated', 'temporal', 'categories', 'sample1.csv') DCNL DCSP streamDef = dict(version=1, info='categories DCSP test', streams=[dict(source=('file://%s' % dataPath), info='categories', columns=['field1', 'field2'], last_record=self.splits['categories'])]) DCNL DCSP expDesc = OPFBenchmarkRunner.EXP_COMMON.copy() DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'field2' DCNL DCSP expDesc.update({'streamDef': streamDef, 'includedFields': [{'fieldName': 'field1', 'fieldType': 'string'}, {'fieldName': 'field2', 'fieldType': 'string'}], 'iterationCount': self.__recordsToProcess}) DCNL DCSP expdir = os.path.join(self.outdir, 'categories') DCNL DCSP self.generateModules(expDesc, expdir) DCNL DCSP self.descriptions['categories'] = (expdir, expDesc) DCNL DCSP return expdir
def benchmarkTwoVarsSquare(self): DCNL DCSP dataPath = os.path.join(self.datadir, 'generated', 'spatial', 'linear_two_fields', 'sample3.csv') DCNL DCSP streamDef = dict(version=1, info='three DCSP fields DCSP test', streams=[dict(source=('file://%s' % dataPath), info='linear_two_fields', columns=['field1', 'field2'], last_record=self.splits['twovars2'])]) DCNL DCSP expDesc = OPFBenchmarkRunner.EXP_COMMON.copy() DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'field1' DCNL DCSP expDesc.update({'streamDef': streamDef, 'includedFields': [{'fieldName': 'field1', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 110}, {'fieldName': 'field2', 'fieldType': 'int', 'minValue': (-10), 'maxValue': 10010}], 'iterationCount': self.__recordsToProcess}) DCNL DCSP expdir = os.path.join(self.outdir, 'twovars2') DCNL DCSP self.generateModules(expDesc, expdir) DCNL DCSP self.descriptions['twovars2'] = (expdir, expDesc) DCNL DCSP return expdir
def benchmarkSawtooth(self): DCNL DCSP dataPath = os.path.join(self.datadir, 'sawtooth', 'sawtooth.csv') DCNL DCSP streamDef = dict(version=1, info='sawtooth DCSP test', streams=[dict(source=('file://%s' % dataPath), info='sawtooth', columns=['value'], last_record=self.splits['sawtooth'])]) DCNL DCSP expDesc = OPFBenchmarkRunner.EXP_COMMON.copy() DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'value' DCNL DCSP expDesc.update({'streamDef': streamDef, 'includedFields': [{'fieldName': 'value', 'fieldType': 'int', 'runDelta': True}], 'iterationCount': self.__recordsToProcess}) DCNL DCSP expdir = os.path.join(self.outdir, 'sawtooth') DCNL DCSP self.generateModules(expDesc, expdir) DCNL DCSP self.descriptions['sawtooth'] = (expdir, expDesc) DCNL DCSP return expdir
def benchmarkHotGymSC(self): DCNL DCSP dataPath = os.path.join(self.datadir, 'hotgym', 'hotgym.csv') DCNL DCSP streamDef = dict(version=1, info='hotgym DCSP spatial DCSP classification DCSP benchmark DCSP test', streams=[dict(source=('file://%s' % dataPath), info='hotgym.csv', columns=['gym', 'timestamp', 'consumption'], last_record=self.splits['hotgymsc'])], aggregation={'hours': 1, 'fields': [('consumption', 'sum'), ('gym', 'first')]}) DCNL DCSP expDesc = OPFBenchmarkRunner.EXP_COMMON.copy() DCNL DCSP expDesc['inferenceArgs']['predictedField'] = 'consumption' DCNL DCSP expDesc['inferenceArgs']['predictionSteps'] = [0] DCNL DCSP expDesc.update({'streamDef': streamDef, 'includedFields': [{'fieldName': 'timestamp', 'fieldType': 'datetime'}, {'fieldName': 'consumption', 'fieldType': 'float', 'minValue': 0, 'maxValue': 100}, {'fieldName': 'gym', 'fieldType': 'string'}], 'iterationCount': self.__recordsToProcess}) DCNL DCSP expdir = os.path.join(self.outdir, 'hotgymsc') DCNL DCSP self.generateModules(expDesc, expdir) DCNL DCSP self.descriptions['hotgymsc'] = (expdir, expDesc) DCNL DCSP return expdir
def generateModules(self, expDesc, outdir): DCNL DCSP jobParams = dict(desription=expDesc) DCNL DCSP shutil.rmtree(outdir, ignore_errors=True) DCNL DCSP outdirv2term = os.path.join(outdir, 'v2Term', 'base') DCNL DCSP outdirv2noterm = os.path.join(outdir, 'v2NoTerm', 'base') DCNL DCSP outdirdef = os.path.join(outdir, 'cluster_default', 'base') DCNL DCSP if self.__doV2Term: DCNL DCSP  DCSP experiment_generator.expGenerator(args) DCNL DCSP args = [('--description=%s' % json.dumps(expDesc)), '--version=v2', ('--outDir=%s' % outdirv2noterm)] DCNL DCSP if self.__doV2noTerm: DCNL DCSP  DCSP experiment_generator.expGenerator(args) DCNL DCSP args = [('--description=%s' % json.dumps(expDesc)), '--version=v2', ('--outDir=%s' % outdirdef)] DCNL DCSP if self.__doClusterDef: DCNL DCSP  DCSP experiment_generator.expGenerator(args)
def testOPFBenchmarks(self): DCNL DCSP for bm in self.listOfBenchmarks: DCNL DCSP  DCSP if (not (bm in self.allBenchmarks)): DCNL DCSP  DCSP  DCSP raise Exception(('Unknown DCSP benchmark DCSP %s' % bm)) DCNL DCSP fifodirs = deque() DCNL DCSP baseoutdir = self.outdir DCNL DCSP iterations = self.iterations DCNL DCSP exportDicts = self.setUpExportDicts() DCNL DCSP for iter in range(iterations): DCNL DCSP  DCSP for exports in exportDicts: DCNL DCSP  DCSP  DCSP if (len(exportDicts) > 1): DCNL DCSP  DCSP  DCSP  DCSP prependDict = exports DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP prependDict = dict() DCNL DCSP  DCSP  DCSP if (self.iterations > 1): DCNL DCSP  DCSP  DCSP  DCSP prependDict['iteration'] = iter DCNL DCSP  DCSP  DCSP prepend = self.generatePrependPath(prependDict) DCNL DCSP  DCSP  DCSP self.outdir = os.path.join(baseoutdir, prepend) DCNL DCSP  DCSP  DCSP if ('sine' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP tmpsine = self.benchmarkSine() DCNL DCSP  DCSP  DCSP  DCSP fifodirs.append(tmpsine) DCNL DCSP  DCSP  DCSP if ('hotgym' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP tmphotgym = self.benchmarkHotGym() DCNL DCSP  DCSP  DCSP  DCSP fifodirs.append(tmphotgym) DCNL DCSP  DCSP  DCSP if ('twovars' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP tmptwovars = self.benchmarkTwoVars() DCNL DCSP  DCSP  DCSP  DCSP fifodirs.append(tmptwovars) DCNL DCSP  DCSP  DCSP if ('twovars2' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP tmptwovars2 = self.benchmarkTwoVarsSquare() DCNL DCSP  DCSP  DCSP  DCSP fifodirs.append(tmptwovars2) DCNL DCSP  DCSP  DCSP if ('threevars' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP tmpthreevars = self.benchmarkThreeVars() DCNL DCSP  DCSP  DCSP  DCSP fifodirs.append(tmpthreevars) DCNL DCSP  DCSP  DCSP if ('fourvars' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP tmpfourvars = self.benchmarkFourVars() DCNL DCSP  DCSP  DCSP  DCSP fifodirs.append(tmpfourvars) DCNL DCSP  DCSP  DCSP if ('categories' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP tmpcategories = self.benchmarkCategories() DCNL DCSP  DCSP  DCSP  DCSP fifodirs.append(tmpcategories) DCNL DCSP  DCSP  DCSP if ('sawtooth' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP tmpcategories = self.benchmarkSawtooth() DCNL DCSP  DCSP  DCSP  DCSP fifodirs.append(tmpcategories) DCNL DCSP  DCSP  DCSP if ('hotgymsc' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP tmphotgymsc = self.benchmarkHotGymSC() DCNL DCSP  DCSP  DCSP  DCSP fifodirs.append(tmphotgymsc) DCNL DCSP self.outdir = baseoutdir DCNL DCSP self.syncFiles() DCNL DCSP if self.filesOnly: DCNL DCSP  DCSP return DCNL DCSP if (self.maxConcurrentJobs == 1): DCNL DCSP  DCSP self.runBenchmarks = self.runBenchmarksSerial DCNL DCSP else: DCNL DCSP  DCSP self.runBenchmarks = self.runBenchmarksParallel DCNL DCSP for iter in range(iterations): DCNL DCSP  DCSP for exports in exportDicts: DCNL DCSP  DCSP  DCSP if ('sine' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP assert self.runBenchmarks(fifodirs.popleft(), 'sine', exports) DCNL DCSP  DCSP  DCSP if ('hotgym' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP assert self.runBenchmarks(fifodirs.popleft(), 'hotgym', exports) DCNL DCSP  DCSP  DCSP if ('twovars' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP assert self.runBenchmarks(fifodirs.popleft(), 'twovars', exports) DCNL DCSP  DCSP  DCSP if ('twovars2' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP assert self.runBenchmarks(fifodirs.popleft(), 'twovars2', exports) DCNL DCSP  DCSP  DCSP if ('threevars' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP assert self.runBenchmarks(fifodirs.popleft(), 'threevars', exports) DCNL DCSP  DCSP  DCSP if ('fourvars' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP assert self.runBenchmarks(fifodirs.popleft(), 'fourvars', exports) DCNL DCSP  DCSP  DCSP if ('categories' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP assert self.runBenchmarks(fifodirs.popleft(), 'categories', exports) DCNL DCSP  DCSP  DCSP if ('sawtooth' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP assert self.runBenchmarks(fifodirs.popleft(), 'sawtooth', exports) DCNL DCSP  DCSP  DCSP if ('hotgymsc' in self.listOfBenchmarks): DCNL DCSP  DCSP  DCSP  DCSP assert self.runBenchmarks(fifodirs.popleft(), 'hotgymsc', exports) DCNL DCSP self.runJobs(self.maxConcurrentJobs) DCNL DCSP if (self.__trainFraction < 1.0): DCNL DCSP  DCSP self.runProductionWorkers() DCNL DCSP  DCSP self.waitForProductionWorkers() DCNL DCSP self.printResults() DCNL DCSP self.assertResults()
def testTemporalAnomalyModelFactory(self): DCNL DCSP modelConfig = {u'aggregationInfo': {u'days': 0, u'fields': [], u'hours': 0, u'microseconds': 0, u'milliseconds': 0, u'minutes': 0, u'months': 0, u'seconds': 0, u'weeks': 0, u'years': 0}, u'model': u'HTMPrediction', u'modelParams': {u'anomalyParams': {u'anomalyCacheRecords': None, u'autoDetectThreshold': None, u'autoDetectWaitRecords': 5030}, u'clEnable': False, u'clParams': {u'alpha': 0.035828933612158, u'verbosity': 0, u'regionName': u'SDRClassifierRegion', u'steps': u'1'}, u'inferenceType': u'TemporalAnomaly', u'sensorParams': {u'encoders': {u'c0_dayOfWeek': None, u'c0_timeOfDay': {u'fieldname': u'c0', u'name': u'c0', u'timeOfDay': [21, 9.49122334747737], u'type': u'DateEncoder'}, u'c0_weekend': None, u'c1': {u'fieldname': u'c1', u'name': u'c1', u'resolution': 0.8771929824561403, u'seed': 42, u'type': u'RandomDistributedScalarEncoder'}}, u'sensorAutoReset': None, u'verbosity': 0}, u'spEnable': True, u'spParams': {u'potentialPct': 0.8, u'columnCount': 2048, u'globalInhibition': 1, u'inputWidth': 0, u'boostStrength': 0.0, u'numActiveColumnsPerInhArea': 40, u'seed': 1956, u'spVerbosity': 0, u'spatialImp': u'cpp', u'synPermActiveInc': 0.0015, u'synPermConnected': 0.1, u'synPermInactiveDec': 0.0005}, u'tmEnable': True, u'tmParams': {u'activationThreshold': 13, u'cellsPerColumn': 32, u'columnCount': 2048, u'globalDecay': 0.0, u'initialPerm': 0.21, u'inputWidth': 2048, u'maxAge': 0, u'maxSegmentsPerCell': 128, u'maxSynapsesPerSegment': 32, u'minThreshold': 10, u'newSynapseCount': 20, u'outputType': u'normal', u'pamLength': 3, u'permanenceDec': 0.1, u'permanenceInc': 0.1, u'seed': 1960, u'temporalImp': u'cpp', u'verbosity': 0}, u'trainSPNetOnlyIfRequested': False}, u'predictAheadTime': None, u'version': 1} DCNL DCSP inferenceArgs = {u'inputPredictedField': u'auto', u'predictedField': u'c1', u'predictionSteps': [1]} DCNL DCSP data = [{'_category': [None], '_reset': 0, '_sequenceId': 0, '_timestamp': datetime.datetime(2013, 12, 5, 0, 0), '_timestampRecordIdx': None, u'c0': datetime.datetime(2013, 12, 5, 0, 0), u'c1': 5.0}, {'_category': [None], '_reset': 0, '_sequenceId': 0, '_timestamp': datetime.datetime(2013, 12, 6, 0, 0), '_timestampRecordIdx': None, u'c0': datetime.datetime(2013, 12, 6, 0, 0), u'c1': 6.0}, {'_category': [None], '_reset': 0, '_sequenceId': 0, '_timestamp': datetime.datetime(2013, 12, 7, 0, 0), '_timestampRecordIdx': None, u'c0': datetime.datetime(2013, 12, 7, 0, 0), u'c1': 7.0}] DCNL DCSP model = ModelFactory.create(modelConfig=modelConfig) DCNL DCSP model.enableLearning() DCNL DCSP model.enableInference(inferenceArgs) DCNL DCSP for row in data: DCNL DCSP  DCSP result = model.run(row) DCNL DCSP  DCSP self.assertIsInstance(result, ModelResult)
def setUp(self): DCNL DCSP self.interpreter = SafeInterpreter(writer=io.BytesIO())
def testPrimitives(self): DCNL DCSP self.assertTrue(self.interpreter('True')) DCNL DCSP self.assertFalse(self.interpreter('False')) DCNL DCSP self.assertTrue((self.interpreter('None') is None))
def testConditionals(self): DCNL DCSP self.assertTrue(self.interpreter('True DCSP if DCSP True DCSP else DCSP False')) DCNL DCSP self.assertTrue(self.interpreter('\nfoo DCSP = DCSP False\nif DCSP not DCSP foo:\n DCSP foo DCSP = DCSP True\nfoo\n'))
def testBlacklist(self): DCNL DCSP self.interpreter('for DCSP x DCSP in DCSP []: DCSP pass') DCNL DCSP self.assertIn('NotImplementedError', (error.get_error()[0] for error in self.interpreter.error)) DCNL DCSP self.interpreter('while DCSP True: DCSP pass') DCNL DCSP self.assertIn('NotImplementedError', (error.get_error()[0] for error in self.interpreter.error))
def testParse(self): DCNL DCSP tree = self.interpreter.parse('True') DCNL DCSP self.assertTrue(isinstance(tree, ast.AST))
def testCompile(self): DCNL DCSP tree = self.interpreter.parse('True') DCNL DCSP codeObj = compile(tree, '<string>', mode='exec') DCNL DCSP self.assertTrue(isinstance(codeObj, types.CodeType))
def testSum(self): DCNL DCSP result = self.interpreter('sum([x*p DCSP for DCSP x,p DCSP in DCSP {1:2}.items()])') DCNL DCSP self.assertEqual(result, 2)
def testRecursive(self): DCNL DCSP self.interpreter('\ndef DCSP foo():\n DCSP  DCSP foo()\n\nfoo()\n') DCNL DCSP self.assertIn('RuntimeError', (error.get_error()[0] for error in self.interpreter.error))
def testOpen(self): DCNL DCSP self.interpreter("open('foo')") DCNL DCSP self.assertIn('RuntimeError', (error.get_error()[0] for error in self.interpreter.error))
def testModelParams(self): DCNL DCSP params = getScalarMetricWithTimeOfDayAnomalyParams([0], minVal=23.42, maxVal=23.420001) DCNL DCSP encodersDict = params['modelConfig']['modelParams']['sensorParams']['encoders'] DCNL DCSP model = ModelFactory.create(modelConfig=params['modelConfig']) DCNL DCSP self.assertIsInstance(model, HTMPredictionModel, 'JSON DCSP returned DCSP cannot DCSP be DCSP used DCSP to DCSP create DCSP a DCSP model') DCNL DCSP self.assertIsNotNone(encodersDict['c0_timeOfDay']) DCNL DCSP if (encodersDict['c1']['type'] == 'RandomDistributedScalarEncoder'): DCNL DCSP  DCSP self.assertGreaterEqual(encodersDict['c1']['resolution'], 0.001, 'Resolution DCSP is DCSP too DCSP low') DCNL DCSP params = getScalarMetricWithTimeOfDayAnomalyParams([0], tmImplementation='tm_cpp') DCNL DCSP self.assertEqual(params['modelConfig']['modelParams']['tmParams']['temporalImp'], 'tm_cpp', 'Incorrect DCSP json DCSP for DCSP tm_cpp DCSP tmImplementation') DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP getScalarMetricWithTimeOfDayAnomalyParams([0], tmImplementation='')
def testWindowedTrivialAAE(self): DCNL DCSP trivialAveErr = getModule(MetricSpec('trivial', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'errorMetric': 'avg_err'})) DCNL DCSP gt = [str(((i / 4) + 1)) for i in range(100)] DCNL DCSP p = [str(i) for i in range(100)] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP trivialAveErr.addInstance(gt[i], p[i]) DCNL DCSP target = 0.25 DCNL DCSP self.assertTrue((abs((trivialAveErr.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testWindowedTrivialAccuract(self): DCNL DCSP trivialaae = getModule(MetricSpec('trivial', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'errorMetric': 'aae'})) DCNL DCSP gt = [((i / 4) + 1) for i in range(1000)] DCNL DCSP p = [i for i in range(1000)] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP trivialaae.addInstance(gt[i], p[i]) DCNL DCSP target = 0.25 DCNL DCSP self.assertTrue((abs((trivialaae.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testWindowedTrivialAccuracy(self): DCNL DCSP trivialaccuracy = getModule(MetricSpec('trivial', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'errorMetric': 'acc'})) DCNL DCSP gt = [str(((i / 4) + 1)) for i in range(1000)] DCNL DCSP p = [str(i) for i in range(1000)] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP trivialaccuracy.addInstance(gt[i], p[i]) DCNL DCSP target = 0.75 DCNL DCSP self.assertTrue((abs((trivialaccuracy.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testWindowedTrivialAverageError(self): DCNL DCSP trivialAveErr = getModule(MetricSpec('trivial', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'errorMetric': 'avg_err'})) DCNL DCSP gt = [str(((i / 4) + 1)) for i in range(500, 1000)] DCNL DCSP p = [str(i) for i in range(1000)] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP trivialAveErr.addInstance(gt[i], p[i]) DCNL DCSP target = 0.25 DCNL DCSP self.assertTrue((abs((trivialAveErr.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testMultistepAAE(self): DCNL DCSP msp = getModule(MetricSpec('multiStep', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'errorMetric': 'aae', 'steps': 3})) DCNL DCSP gt = [(i + 1) for i in range(100)] DCNL DCSP p = [{3: {i: 0.7, 5: 0.3}} for i in range(100)] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP msp.addInstance(gt[i], p[i]) DCNL DCSP target = 1 DCNL DCSP self.assertTrue((abs((msp.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testMultistepAAEMultipleSteps(self): DCNL DCSP msp = getModule(MetricSpec('multiStep', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'errorMetric': 'aae', 'steps': [3, 6]})) DCNL DCSP gt = [i for i in range(100)] DCNL DCSP p = [{3: {(i + 1): 0.7, 5: 0.3}, 6: {(i + 0.5): 0.7, 5: 0.3}} for i in range(100)] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP msp.addInstance(gt[i], p[i]) DCNL DCSP target = 0.75 DCNL DCSP self.assertTrue((abs((msp.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testMultistepProbability(self): DCNL DCSP msp = getModule(MetricSpec('multiStepProbability', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'errorMetric': 'aae', 'steps': 3})) DCNL DCSP gt = [5 for i in range(1000)] DCNL DCSP p = [{3: {i: 0.3, 5: 0.7}} for i in range(1000)] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP msp.addInstance(gt[i], p[i]) DCNL DCSP target = 283.35 DCNL DCSP self.assertTrue((abs((msp.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testMultistepProbabilityMultipleSteps(self): DCNL DCSP msp = getModule(MetricSpec('multiStepProbability', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'errorMetric': 'aae', 'steps': [1, 3]})) DCNL DCSP gt = [5 for i in range(1000)] DCNL DCSP p = [{3: {i: 0.3, 5: 0.7}, 1: {5: 1.0}} for i in range(1000)] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP msp.addInstance(gt[i], p[i]) DCNL DCSP target = (283.35 / 2) DCNL DCSP self.assertTrue((abs((msp.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testMovingMeanAbsoluteError(self): DCNL DCSP movingMeanAAE = getModule(MetricSpec('moving_mean', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'mean_window': 3, 'errorMetric': 'aae'})) DCNL DCSP gt = [i for i in range(890)] DCNL DCSP gt.extend([(2 * i) for i in range(110)]) DCNL DCSP p = [i for i in range(1000)] DCNL DCSP res = [] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP movingMeanAAE.addInstance(gt[i], p[i]) DCNL DCSP  DCSP res.append(movingMeanAAE.getMetric()['value']) DCNL DCSP self.assertTrue((max(res[1:890]) == 2.0)) DCNL DCSP self.assertTrue((min(res[891:]) >= 4.0)) DCNL DCSP target = 4.0 DCNL DCSP self.assertTrue((abs((movingMeanAAE.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testMovingMeanRMSE(self): DCNL DCSP movingMeanRMSE = getModule(MetricSpec('moving_mean', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'mean_window': 3, 'errorMetric': 'rmse'})) DCNL DCSP gt = [i for i in range(890)] DCNL DCSP gt.extend([(2 * i) for i in range(110)]) DCNL DCSP p = [i for i in range(1000)] DCNL DCSP res = [] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP movingMeanRMSE.addInstance(gt[i], p[i]) DCNL DCSP  DCSP res.append(movingMeanRMSE.getMetric()['value']) DCNL DCSP self.assertTrue((max(res[1:890]) == 2.0)) DCNL DCSP self.assertTrue((min(res[891:]) >= 4.0)) DCNL DCSP target = 4.0 DCNL DCSP self.assertTrue((abs((movingMeanRMSE.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testMovingModeAverageError(self): DCNL DCSP movingModeAvgErr = getModule(MetricSpec('moving_mode', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'mode_window': 3, 'errorMetric': 'avg_err'})) DCNL DCSP gt = [(i / 4) for i in range(900)] DCNL DCSP gt.extend([((2 * i) / 4) for i in range(100)]) DCNL DCSP p = [i for i in range(1000)] DCNL DCSP res = [] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP movingModeAvgErr.addInstance(gt[i], p[i]) DCNL DCSP  DCSP res.append(movingModeAvgErr.getMetric()['value']) DCNL DCSP self.assertTrue((max(res[1:890]) == 0.5)) DCNL DCSP self.assertTrue((min(res[891:]) >= 0.5)) DCNL DCSP self.assertTrue((res[998] < 1.0)) DCNL DCSP target = 1.0 DCNL DCSP self.assertTrue((abs((movingModeAvgErr.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testMovingModeAccuracy(self): DCNL DCSP movingModeACC = getModule(MetricSpec('moving_mode', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'mode_window': 3, 'errorMetric': 'acc'})) DCNL DCSP gt = [(i / 4) for i in range(900)] DCNL DCSP gt.extend([((2 * i) / 4) for i in range(100)]) DCNL DCSP p = [i for i in range(1000)] DCNL DCSP res = [] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP movingModeACC.addInstance(gt[i], p[i]) DCNL DCSP  DCSP res.append(movingModeACC.getMetric()['value']) DCNL DCSP self.assertTrue((min(res[1:899]) == 0.5)) DCNL DCSP self.assertTrue((max(res[900:]) <= 0.5)) DCNL DCSP self.assertTrue((res[998] > 0.0)) DCNL DCSP target = 0.0 DCNL DCSP self.assertTrue((abs((movingModeACC.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testTwoGramScalars(self): DCNL DCSP oneGram = getModule(MetricSpec('two_gram', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'predictionField': 'test', 'errorMetric': 'acc'})) DCNL DCSP encodings = [np.zeros(10) for i in range(5)] DCNL DCSP for i in range(len(encodings)): DCNL DCSP  DCSP encoding = encodings[i] DCNL DCSP  DCSP encoding[i] = 1 DCNL DCSP gt = [(i % 5) for i in range(1000)] DCNL DCSP res = [] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP if (i == 20): DCNL DCSP  DCSP  DCSP oneGram.addInstance(np.zeros(10), prediction=None, record={'test': None}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP oneGram.addInstance(encodings[(i % 5)], prediction=None, record={'test': gt[i]}) DCNL DCSP  DCSP res.append(oneGram.getMetric()['value']) DCNL DCSP target = 1.0 DCNL DCSP self.assertTrue((abs((oneGram.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testTwoGramScalarsStepsGreaterOne(self): DCNL DCSP oneGram = getModule(MetricSpec('two_gram', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'predictionField': 'test', 'errorMetric': 'acc', 'steps': 2})) DCNL DCSP encodings = [np.zeros(10) for i in range(5)] DCNL DCSP for i in range(len(encodings)): DCNL DCSP  DCSP encoding = encodings[i] DCNL DCSP  DCSP encoding[i] = 1 DCNL DCSP gt = [(i % 5) for i in range(1000)] DCNL DCSP res = [] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP if (i == 20): DCNL DCSP  DCSP  DCSP oneGram.addInstance(np.zeros(10), prediction=None, record={'test': None}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP oneGram.addInstance(encodings[(i % 5)], prediction=None, record={'test': gt[i]}) DCNL DCSP  DCSP res.append(oneGram.getMetric()['value']) DCNL DCSP target = 1.0 DCNL DCSP self.assertTrue((abs((oneGram.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testTwoGramStrings(self): DCNL DCSP oneGram = getModule(MetricSpec('two_gram', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100, 'errorMetric': 'acc', 'predictionField': 'test'})) DCNL DCSP gt = [str((i % 5)) for i in range(1000)] DCNL DCSP encodings = [np.zeros(10) for i in range(5)] DCNL DCSP for i in range(len(encodings)): DCNL DCSP  DCSP encoding = encodings[i] DCNL DCSP  DCSP encoding[i] = 1 DCNL DCSP newElem = 100 DCNL DCSP for i in range(5, 1000, 5): DCNL DCSP  DCSP gt[i] = str(newElem) DCNL DCSP  DCSP newElem += 20 DCNL DCSP res = [] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP if (i == 20): DCNL DCSP  DCSP  DCSP oneGram.addInstance(np.zeros(10), prediction=None, record={'test': None}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP oneGram.addInstance(encodings[(i % 5)], prediction=None, record={'test': gt[i]}) DCNL DCSP  DCSP res.append(oneGram.getMetric()['value']) DCNL DCSP target = 0.8 DCNL DCSP self.assertTrue((abs((oneGram.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testWindowedAAE(self): DCNL DCSP waae = getModule(MetricSpec('aae', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 1})) DCNL DCSP gt = [9, 4, 5, 6] DCNL DCSP p = [0, 13, 8, 3] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP waae.addInstance(gt[i], p[i]) DCNL DCSP target = 3.0 DCNL DCSP self.assertTrue((abs((waae.getMetric()['value'] - target)) < OPFMetricsTest.DELTA), ('Got DCSP %s' % waae.getMetric()))
def testAccuracy(self): DCNL DCSP acc = getModule(MetricSpec('acc', None, None, {'verbosity': OPFMetricsTest.VERBOSITY})) DCNL DCSP gt = [0, 1, 2, 3, 4, 5] DCNL DCSP p = [0, 1, 2, 4, 5, 6] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP acc.addInstance(gt[i], p[i]) DCNL DCSP target = 0.5 DCNL DCSP self.assertTrue((abs((acc.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testWindowedAccuracy(self): DCNL DCSP acc = getModule(MetricSpec('acc', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 2})) DCNL DCSP gt = [0, 1, 2, 3, 4, 5] DCNL DCSP p = [0, 1, 2, 4, 5, 6] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP acc.addInstance(gt[i], p[i]) DCNL DCSP target = 0.0 DCNL DCSP self.assertTrue((abs((acc.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testAverageError(self): DCNL DCSP err = getModule(MetricSpec('avg_err', None, None, {'verbosity': OPFMetricsTest.VERBOSITY})) DCNL DCSP gt = [1, 1, 2, 3, 4, 5] DCNL DCSP p = [0, 1, 2, 4, 5, 6] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP err.addInstance(gt[i], p[i]) DCNL DCSP target = (2.0 / 3.0) DCNL DCSP self.assertTrue((abs((err.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testWindowedAverageError(self): DCNL DCSP err = getModule(MetricSpec('avg_err', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 2})) DCNL DCSP gt = [0, 1, 2, 3, 4, 5] DCNL DCSP p = [0, 1, 2, 4, 5, 6] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP err.addInstance(gt[i], p[i]) DCNL DCSP target = 1.0 DCNL DCSP self.assertTrue((abs((err.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testLongWindowRMSE(self): DCNL DCSP rmse = getModule(MetricSpec('rmse', None, None, {'verbosity': OPFMetricsTest.VERBOSITY, 'window': 100})) DCNL DCSP gt = [9, 4, 5, 6] DCNL DCSP p = [0, 13, 8, 3] DCNL DCSP for i in xrange(len(gt)): DCNL DCSP  DCSP rmse.addInstance(gt[i], p[i]) DCNL DCSP target = 6.71 DCNL DCSP self.assertTrue((abs((rmse.getMetric()['value'] - target)) < OPFMetricsTest.DELTA))
def testSerialization(self): DCNL DCSP l = an.AnomalyLikelihood(claLearningPeriod=2, estimationSamples=2) DCNL DCSP l.anomalyProbability('hi', 0.1, timestamp=1) DCNL DCSP l.anomalyProbability('hi', 0.1, timestamp=2) DCNL DCSP l.anomalyProbability('hello', 0.3, timestamp=3) DCNL DCSP stored = pickle.dumps(l) DCNL DCSP restored = pickle.loads(stored) DCNL DCSP self.assertEqual(l, restored)
def testNormalProbability(self): DCNL DCSP p = {'name': 'normal', 'mean': 0.0, 'variance': 1.0, 'stdev': 1.0} DCNL DCSP self.assertWithinEpsilon(an.tailProbability(0.0, p), 0.5) DCNL DCSP self.assertWithinEpsilon(an.tailProbability(0.3, p), 0.382088578) DCNL DCSP self.assertWithinEpsilon(an.tailProbability(1.0, p), 0.1587) DCNL DCSP self.assertWithinEpsilon(an.tailProbability(1.0, p), an.tailProbability((-1.0), p)) DCNL DCSP self.assertWithinEpsilon(an.tailProbability((-0.3), p), an.tailProbability(0.3, p)) DCNL DCSP p = {'name': 'normal', 'mean': 1.0, 'variance': 4.0, 'stdev': 2.0} DCNL DCSP self.assertWithinEpsilon(an.tailProbability(1.0, p), 0.5) DCNL DCSP self.assertWithinEpsilon(an.tailProbability(2.0, p), 0.3085) DCNL DCSP self.assertWithinEpsilon(an.tailProbability(3.0, p), 0.1587) DCNL DCSP self.assertWithinEpsilon(an.tailProbability(3.0, p), an.tailProbability((-1.0), p)) DCNL DCSP self.assertWithinEpsilon(an.tailProbability(0.0, p), an.tailProbability(2.0, p)) DCNL DCSP p = {'name': 'normal', 'mean': (-2.0), 'variance': 0.5, 'stdev': math.sqrt(0.5)} DCNL DCSP self.assertWithinEpsilon(an.tailProbability((-2.0), p), 0.5) DCNL DCSP self.assertWithinEpsilon(an.tailProbability((-1.5), p), 0.241963652) DCNL DCSP self.assertWithinEpsilon(an.tailProbability((-2.5), p), an.tailProbability((-1.5), p))
def testEstimateNormal(self): DCNL DCSP samples = numpy.array([0.32259025, (-0.44936321), (-0.15784842), 0.72142628, 0.8794327, 0.06323451, (-0.15336159), (-0.02261703), 0.04806841, 0.47219226, 0.31102718, 0.57608799, 0.13621071, 0.92446815, 0.1870912, 0.46366935, (-0.11359237), 0.66582357, 1.20613048, (-0.17735134), 0.20709358, 0.74508479, 0.12450686, (-0.15468728), 0.3982757, 0.87924349, 0.86104855, 0.23688469, (-0.26018254), 0.10909429, 0.65627481, 0.39238532, 0.77150761, 0.47040352, 0.9676175, 0.42148897, 0.0967786, (-0.0087355), 0.84427985, 1.46526018, 1.19214798, 0.16034816, 0.81105554, 0.39150407, 0.93609919, 0.13992161, 0.6494196, 0.83666217, 0.37845278, 0.0368279, (-0.10201944), 0.41144746, 0.28341277, 0.36759426, 0.90439446, 0.05669459, (-0.11220214), 0.34616676, 0.49898439, (-0.23846184), 1.06400524, 0.72202135, (-0.2169164), 1.136582, (-0.69576865), 0.48603271, 0.72781008, (-0.04749299), 0.15469311, 0.52942518, 0.24816816, 0.3483905, 0.7284215, 0.93774676, 0.07286373, 1.6831539, 0.3851082, 0.0637406, (-0.92332861), (-0.02066161), 0.93709862, 0.82114131, 0.98631562, 0.05601529, 0.72214694, 0.09667526, 0.3857222, 0.50313998, 0.40775344, (-0.69624046), (-0.4448494), 0.99403206, 0.51639049, 0.13951548, 0.23458214, 1.00712699, 0.40939048, (-0.06436434), (-0.02753677), (-0.23017904)]) DCNL DCSP params = an.estimateNormal(samples) DCNL DCSP self.assertWithinEpsilon(params['mean'], 0.3721) DCNL DCSP self.assertWithinEpsilon(params['variance'], 0.22294) DCNL DCSP self.assertWithinEpsilon(params['stdev'], 0.47216) DCNL DCSP self.assertEqual(params['name'], 'normal')
def testSampleDistribution(self): DCNL DCSP p = {'mean': 0.5, 'name': 'normal', 'stdev': math.sqrt(0.1), 'variance': 0.1} DCNL DCSP samples = _sampleDistribution(p, 1000) DCNL DCSP np = an.estimateNormal(samples) DCNL DCSP self.assertWithinEpsilon(p['mean'], np['mean'], 0.1) DCNL DCSP self.assertWithinEpsilon(p['variance'], np['variance'], 0.1) DCNL DCSP self.assertWithinEpsilon(p['stdev'], np['stdev'], 0.1) DCNL DCSP self.assertTrue(np['name'], 'normal')
def testEstimateAnomalyLikelihoods(self): DCNL DCSP data1 = _generateSampleData(mean=0.2) DCNL DCSP (likelihoods, avgRecordList, estimatorParams) = an.estimateAnomalyLikelihoods(data1[0:1000]) DCNL DCSP self.assertEqual(len(likelihoods), 1000) DCNL DCSP self.assertEqual(len(avgRecordList), 1000) DCNL DCSP self.assertTrue(an.isValidEstimatorParams(estimatorParams)) DCNL DCSP avgParams = estimatorParams['movingAverage'] DCNL DCSP total = 0 DCNL DCSP for v in avgRecordList: DCNL DCSP  DCSP total = (total + v[2]) DCNL DCSP self.assertTrue(avgParams['total'], total) DCNL DCSP dParams = estimatorParams['distribution'] DCNL DCSP self.assertWithinEpsilon(dParams['mean'], (total / float(len(avgRecordList)))) DCNL DCSP self.assertLessEqual(numpy.sum((likelihoods < 0.02)), 50) DCNL DCSP self.assertGreaterEqual(numpy.sum((likelihoods < 0.02)), 1)
def testEstimateAnomalyLikelihoodsMalformedRecords(self): DCNL DCSP data1 = _generateSampleData(mean=0.2) DCNL DCSP data1 = ((((data1[0:1000] + [(2, 2)]) + [(2, 2, 2, 2)]) + [()]) + [2]) DCNL DCSP (likelihoods, avgRecordList, estimatorParams) = an.estimateAnomalyLikelihoods(data1[0:1004]) DCNL DCSP self.assertEqual(len(likelihoods), 1000) DCNL DCSP self.assertEqual(len(avgRecordList), 1000) DCNL DCSP self.assertTrue(an.isValidEstimatorParams(estimatorParams)) DCNL DCSP avgParams = estimatorParams['movingAverage'] DCNL DCSP total = 0 DCNL DCSP for v in avgRecordList: DCNL DCSP  DCSP total = (total + v[2]) DCNL DCSP self.assertTrue(avgParams['total'], total) DCNL DCSP dParams = estimatorParams['distribution'] DCNL DCSP self.assertWithinEpsilon(dParams['mean'], (total / float(len(avgRecordList))))
def testSkipRecords(self): DCNL DCSP data1 = _generateSampleData(mean=0.1)[0:200] DCNL DCSP data1 = (data1 + _generateSampleData(mean=0.9)[0:200]) DCNL DCSP (likelihoods, _, estimatorParams) = an.estimateAnomalyLikelihoods(data1, skipRecords=200) DCNL DCSP dParams = estimatorParams['distribution'] DCNL DCSP self.assertWithinEpsilon(dParams['mean'], 0.9, epsilon=0.1) DCNL DCSP (likelihoods, _, estimatorParams) = an.estimateAnomalyLikelihoods(data1, skipRecords=500) DCNL DCSP self.assertEqual(len(likelihoods), len(data1)) DCNL DCSP self.assertTrue((likelihoods.sum() >= (0.3 * len(likelihoods)))) DCNL DCSP (likelihoods, _, estimatorParams) = an.estimateAnomalyLikelihoods(data1, skipRecords=len(data1)) DCNL DCSP self.assertEqual(len(likelihoods), len(data1)) DCNL DCSP self.assertTrue((likelihoods.sum() >= (0.3 * len(likelihoods))))
def testUpdateAnomalyLikelihoods(self): DCNL DCSP data1 = _generateSampleData(mean=0.2)[0:1000] DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data1, averagingWindow=5) DCNL DCSP data2 = _generateSampleData(mean=0.6)[0:300] DCNL DCSP (likelihoods2, avgRecordList2, estimatorParams2) = an.updateAnomalyLikelihoods(data2, estimatorParams) DCNL DCSP self.assertEqual(len(likelihoods2), len(data2)) DCNL DCSP self.assertEqual(len(avgRecordList2), len(data2)) DCNL DCSP self.assertTrue(an.isValidEstimatorParams(estimatorParams)) DCNL DCSP self.assertNotEqual(estimatorParams2['movingAverage']['total'], estimatorParams['movingAverage']['total']) DCNL DCSP self.assertGreaterEqual(numpy.sum((likelihoods2 < 0.01)), 25) DCNL DCSP self.assertLessEqual(numpy.sum((likelihoods2 < 0.01)), 250) DCNL DCSP data3 = _generateSampleData(mean=0.2)[0:1000] DCNL DCSP (likelihoods3, avgRecordList3, estimatorParams3) = an.updateAnomalyLikelihoods(data3, estimatorParams2) DCNL DCSP self.assertEqual(len(likelihoods3), len(data3)) DCNL DCSP self.assertEqual(len(avgRecordList3), len(data3)) DCNL DCSP self.assertTrue(an.isValidEstimatorParams(estimatorParams3)) DCNL DCSP self.assertNotEqual(estimatorParams3['movingAverage']['total'], estimatorParams['movingAverage']['total']) DCNL DCSP self.assertNotEqual(estimatorParams3['movingAverage']['total'], estimatorParams2['movingAverage']['total']) DCNL DCSP self.assertGreaterEqual(numpy.sum((likelihoods3 < 0.01)), 1) DCNL DCSP self.assertLessEqual(numpy.sum((likelihoods3 < 0.01)), 100) DCNL DCSP allData = data1 DCNL DCSP allData.extend(data2) DCNL DCSP allData.extend(data3) DCNL DCSP (_, historicalValuesAll, totalAll) = an._anomalyScoreMovingAverage(allData, windowSize=5) DCNL DCSP self.assertEqual(sum(historicalValuesAll), sum(estimatorParams3['movingAverage']['historicalValues'])) DCNL DCSP self.assertEqual(totalAll, estimatorParams3['movingAverage']['total'])
def testFlatAnomalyScores(self): DCNL DCSP data1 = _generateSampleData(mean=42.0, variance=1e-10) DCNL DCSP (likelihoods, avgRecordList, estimatorParams) = an.estimateAnomalyLikelihoods(data1[0:1000]) DCNL DCSP self.assertEqual(len(likelihoods), 1000) DCNL DCSP self.assertEqual(len(avgRecordList), 1000) DCNL DCSP self.assertTrue(an.isValidEstimatorParams(estimatorParams)) DCNL DCSP dParams = estimatorParams['distribution'] DCNL DCSP self.assertWithinEpsilon(dParams['mean'], data1[0][2]) DCNL DCSP data2 = _generateSampleData(mean=42.5, variance=1e-10) DCNL DCSP (likelihoods2, _, _) = an.updateAnomalyLikelihoods(data2[0:10], estimatorParams) DCNL DCSP self.assertLessEqual(likelihoods2.sum(), 0.01) DCNL DCSP data3 = _generateSampleData(mean=0.01, variance=1e-06) DCNL DCSP (_, _, estimatorParams3) = an.estimateAnomalyLikelihoods(data3[0:1000]) DCNL DCSP data4 = _generateSampleData(mean=0.1, variance=1e-06) DCNL DCSP (likelihoods4, _, estimatorParams4) = an.updateAnomalyLikelihoods(data4[0:20], estimatorParams3) DCNL DCSP self.assertLessEqual(likelihoods4[10:].mean(), 0.002) DCNL DCSP data5 = _generateSampleData(mean=0.05, variance=1e-06) DCNL DCSP (likelihoods5, _, _) = an.updateAnomalyLikelihoods(data5[0:20], estimatorParams4) DCNL DCSP self.assertLessEqual(likelihoods5[10:].mean(), 0.28) DCNL DCSP self.assertGreater(likelihoods5[10:].mean(), 0.015)
def testFlatMetricScores(self): DCNL DCSP data1 = _generateSampleData(metricMean=42.0, metricVariance=1e-10)[0:1000] DCNL DCSP (likelihoods, _, estimatorParams) = an.estimateAnomalyLikelihoods(data1) DCNL DCSP self.assertEqual(len(likelihoods), len(data1)) DCNL DCSP self.assertTrue((likelihoods.sum() >= (0.4 * len(likelihoods)))) DCNL DCSP self.assertDictEqual(estimatorParams['distribution'], an.nullDistribution())
def testVeryFewScores(self): DCNL DCSP data1 = _generateSampleData(mean=42.0, variance=1e-10) DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data1[0:2]) DCNL DCSP self.assertTrue(an.isValidEstimatorParams(estimatorParams)) DCNL DCSP dParams = estimatorParams['distribution'] DCNL DCSP self.assertWithinEpsilon(dParams['mean'], data1[0][2]) DCNL DCSP data1 = numpy.zeros(0) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP an.estimateAnomalyLikelihoods(data1) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP an.updateAnomalyLikelihoods(data1, estimatorParams)
def testBadParams(self): DCNL DCSP data1 = _generateSampleData(mean=42.0, variance=1e-10) DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data1[0:1]) DCNL DCSP self.assertTrue(an.isValidEstimatorParams(estimatorParams)) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP an.updateAnomalyLikelihoods(data1, {'haha': 'heehee'}) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP an.updateAnomalyLikelihoods(data1, 42.0)
def testFilterLikelihodsInputType(self): DCNL DCSP l = [0.0, 0.0, 0.3, 0.3, 0.5] DCNL DCSP l2 = an._filterLikelihoods(l) DCNL DCSP n = numpy.array(l) DCNL DCSP n2 = an._filterLikelihoods(n) DCNL DCSP filtered = [0.0, 0.001, 0.3, 0.3, 0.5] DCNL DCSP for i in range(len(l)): DCNL DCSP  DCSP self.assertAlmostEqual(l2[i], filtered[i], msg='Input DCSP of DCSP type DCSP list DCSP returns DCSP incorrect DCSP result') DCNL DCSP for i in range(len(n)): DCNL DCSP  DCSP self.assertAlmostEqual(n2[i], filtered[i], msg='Input DCSP of DCSP type DCSP numpy DCSP array DCSP returns DCSP incorrect DCSP result')
def testFilterLikelihoods(self): DCNL DCSP redThreshold = 0.9999 DCNL DCSP yellowThreshold = 0.999 DCNL DCSP l = [1.0, 1.0, 0.9, 0.8, 0.5, 0.4, 1.0, 1.0, 0.6, 0.0] DCNL DCSP l = [(1 - x) for x in l] DCNL DCSP l2 = copy.copy(l) DCNL DCSP l2[1] = (1 - yellowThreshold) DCNL DCSP l2[7] = (1 - yellowThreshold) DCNL DCSP l3 = an._filterLikelihoods(l, redThreshold=redThreshold) DCNL DCSP for i in range(len(l2)): DCNL DCSP  DCSP self.assertAlmostEqual(l2[i], l3[i], msg='Failure DCSP in DCSP case DCSP (i)') DCNL DCSP l = numpy.array([0.999978229, 0.999978229, 0.999999897, 1, 1, 1, 1, 0.999999994, 0.999999966, 0.999999966, 0.999994331, 0.999516576, 0.99744487]) DCNL DCSP l = (1.0 - l) DCNL DCSP l2 = copy.copy(l) DCNL DCSP l2[1:11] = (1 - yellowThreshold) DCNL DCSP l3 = an._filterLikelihoods(l, redThreshold=redThreshold) DCNL DCSP for i in range(len(l2)): DCNL DCSP  DCSP self.assertAlmostEqual(l2[i], l3[i], msg='Failure DCSP in DCSP case DCSP (ii)') DCNL DCSP l = numpy.array([0.999968329, 0.999999897, 1, 1, 1, 1, 0.999999994, 0.999999966, 0.999999966, 0.999994331, 0.999516576, 0.99744487]) DCNL DCSP l = (1.0 - l) DCNL DCSP l2a = copy.copy(l) DCNL DCSP l2b = copy.copy(l) DCNL DCSP l2a[1:10] = (1 - yellowThreshold) DCNL DCSP l2b[2:10] = (1 - yellowThreshold) DCNL DCSP l3a = an._filterLikelihoods(l, redThreshold=redThreshold) DCNL DCSP l3b = an._filterLikelihoods(l, redThreshold=0.99999) DCNL DCSP for i in range(len(l2a)): DCNL DCSP  DCSP self.assertAlmostEqual(l2a[i], l3a[i], msg='Failure DCSP in DCSP case DCSP (iii), DCSP list DCSP a') DCNL DCSP for i in range(len(l2b)): DCNL DCSP  DCSP self.assertAlmostEqual(l2b[i], l3b[i], msg='Failure DCSP in DCSP case DCSP (iii), DCSP list DCSP b') DCNL DCSP self.assertFalse(numpy.array_equal(l3a, l3b), msg='Failure DCSP in DCSP case DCSP (iii), DCSP list DCSP 3')
@staticmethod DCNL def _addSampleData(origData=None, numSamples=1440, spikeValue=1.0, spikePeriod=20): DCNL DCSP if (origData is None): DCNL DCSP  DCSP origData = [] DCNL DCSP if (len(origData) > 0): DCNL DCSP  DCSP lastDate = origData[(-1)][0] DCNL DCSP else: DCNL DCSP  DCSP lastDate = datetime.datetime(2013, 2, 3) DCNL DCSP dateList = _getDateList(numSamples, lastDate) DCNL DCSP data = copy.copy(origData) DCNL DCSP for (idx, date) in enumerate(dateList): DCNL DCSP  DCSP if ((spikePeriod > 0) and (((idx + 1) % spikePeriod) == 0)): DCNL DCSP  DCSP  DCSP data.append([date, idx, spikeValue]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP data.append([date, idx, 0.0]) DCNL DCSP return data
def testCaseSingleSpike(self): DCNL DCSP data = self._addSampleData(spikePeriod=0, numSamples=1000) DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data[0:1000]) DCNL DCSP data = self._addSampleData(numSamples=1, spikePeriod=1) DCNL DCSP (likelihoods1, _, _) = an.updateAnomalyLikelihoods(data, estimatorParams) DCNL DCSP self.assertWithinEpsilon(likelihoods1[0], 0.0)
def testCaseUnusuallyHighSpikeFrequency(self): DCNL DCSP data = self._addSampleData(spikePeriod=20, numSamples=1019) DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data[0:1000]) DCNL DCSP data = self._addSampleData(numSamples=119, spikePeriod=20) DCNL DCSP (likelihoods1, _, estimatorParams1) = an.updateAnomalyLikelihoods(data, estimatorParams) DCNL DCSP self.assertTrue((likelihoods1.min() > 0.1)) DCNL DCSP data = self._addSampleData(numSamples=20, spikePeriod=2) DCNL DCSP (likelihoods2, _, _) = an.updateAnomalyLikelihoods(data, estimatorParams1) DCNL DCSP self.assertTrue(((likelihoods2[5:].sum() / 15.0) < 0.001))
@unittest.skip('Currently DCSP fails DCSP because DCSP the DCSP periodicity DCSP is DCSP greater DCSP than DCSP the DCSP window DCSP size. DCSP Requires DCSP some DCSP algorithm DCSP enhancements. DCSP Filed DCSP as DCSP https://github.com/numenta/nupic/issues/948.') DCNL def testCaseMissingSpike(self): DCNL DCSP data = self._addSampleData(spikePeriod=20, numSamples=1019) DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data[0:1000]) DCNL DCSP data = self._addSampleData(numSamples=100, spikePeriod=0) DCNL DCSP (likelihoods2, _, _) = an.updateAnomalyLikelihoods(data, estimatorParams) DCNL DCSP self.assertTrue(((likelihoods2[5:].sum() / 15.0) < 0.0001))
def testCaseContinuousBunchesOfSpikes(self): DCNL DCSP data = [] DCNL DCSP for _ in range(30): DCNL DCSP  DCSP data = self._addSampleData(data, spikePeriod=0, numSamples=30) DCNL DCSP  DCSP data = self._addSampleData(data, spikePeriod=3, numSamples=10) DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data[0:1000]) DCNL DCSP data = self._addSampleData(spikePeriod=0, numSamples=30) DCNL DCSP data = self._addSampleData(data, spikePeriod=3, numSamples=10) DCNL DCSP (likelihoods2, _, _) = an.updateAnomalyLikelihoods(data, estimatorParams) DCNL DCSP self.assertTrue((likelihoods2.min() > 0.01))
def testCaseIncreasedSpikeFrequency(self): DCNL DCSP data = [] DCNL DCSP for _ in range(30): DCNL DCSP  DCSP data = self._addSampleData(data, spikePeriod=0, numSamples=30) DCNL DCSP  DCSP data = self._addSampleData(data, spikePeriod=3, numSamples=10) DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data[0:1000]) DCNL DCSP data = self._addSampleData(spikePeriod=0, numSamples=30) DCNL DCSP data = self._addSampleData(data, spikePeriod=1, numSamples=10) DCNL DCSP (likelihoods2, _, _) = an.updateAnomalyLikelihoods(data, estimatorParams) DCNL DCSP self.assertTrue((likelihoods2[0:30].min() > 0.01)) DCNL DCSP self.assertTrue((likelihoods2[(-5):].min() < 0.002))
@unittest.skip('Currently DCSP fails DCSP because DCSP the DCSP periodicity DCSP is DCSP greater DCSP than DCSP the DCSP window DCSP size. DCSP Requires DCSP some DCSP algorithm DCSP enhancements. DCSP Filed DCSP as DCSP https://github.com/numenta/nupic/issues/948.') DCNL def testCaseMissingBunchesOfSpikes(self): DCNL DCSP data = [] DCNL DCSP for _ in range(30): DCNL DCSP  DCSP data = self._addSampleData(data, spikePeriod=0, numSamples=30) DCNL DCSP  DCSP data = self._addSampleData(data, spikePeriod=3, numSamples=10) DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data) DCNL DCSP data = self._addSampleData(spikePeriod=0, numSamples=40) DCNL DCSP (likelihoods2, _, _) = an.updateAnomalyLikelihoods(data, estimatorParams) DCNL DCSP self.assertTrue((likelihoods2[0:30].min() > 0.01)) DCNL DCSP self.assertTrue((likelihoods2[(-5):].min() < 1e-05))
def testCaseIncreasedAnomalyScore(self): DCNL DCSP data = [] DCNL DCSP data = self._addSampleData(data, spikePeriod=20, spikeValue=0.4, numSamples=1000) DCNL DCSP (_, _, estimatorParams) = an.estimateAnomalyLikelihoods(data) DCNL DCSP data = self._addSampleData(spikePeriod=20, spikeValue=1.0, numSamples=100) DCNL DCSP (likelihoods2, _, _) = an.updateAnomalyLikelihoods(data, estimatorParams) DCNL DCSP self.assertTrue((likelihoods2.min() < 0.0003)) DCNL DCSP self.assertTrue(((likelihoods2 < 0.0003).sum() > 40))
def testCategory(self): DCNL DCSP self.frequency(n=100, w=21, seed=SEED, numColors=90, encoder='scalar')
def testScalar(self): DCNL DCSP self.frequency(n=30, w=21, seed=SEED, numColors=90, encoder='category')
@unittest.skip('Not DCSP working...') DCNL def testScalarLong(self): DCNL DCSP for n in [52, 70, 80, 90, 100, 110]: DCNL DCSP  DCSP self.frequency(n=100, w=21, seed=SEED, numColors=n, encoder='scalar')
@unittest.skip('Not DCSP working...') DCNL def testCategoryLong(self): DCNL DCSP for n in [52, 70, 80, 90, 100, 110]: DCNL DCSP  DCSP self.frequency(n=100, w=21, seed=SEED, numColors=n)
def frequency(self, n=15, w=7, columnDimensions=2048, numActiveColumnsPerInhArea=40, stimulusThreshold=0, spSeed=1, spVerbosity=0, numColors=2, seed=42, minVal=0, maxVal=10, encoder='category', forced=True): DCNL DCSP print '\nRunning DCSP SP DCSP overlap DCSP test...' DCNL DCSP print encoder, 'encoder,', 'Random DCSP seed:', seed, 'and', numColors, 'colors' DCNL DCSP spImpl = SpatialPooler(columnDimensions=(columnDimensions, 1), inputDimensions=(1, n), potentialRadius=(n / 2), numActiveColumnsPerInhArea=numActiveColumnsPerInhArea, spVerbosity=spVerbosity, stimulusThreshold=stimulusThreshold, potentialPct=0.5, seed=spSeed, globalInhibition=True) DCNL DCSP rnd.seed(seed) DCNL DCSP numpy.random.seed(seed) DCNL DCSP colors = [] DCNL DCSP coincs = [] DCNL DCSP reUsedCoincs = [] DCNL DCSP spOutput = [] DCNL DCSP patterns = set([]) DCNL DCSP if (encoder == 'scalar'): DCNL DCSP  DCSP enc = scalar.ScalarEncoder(name='car', w=w, n=n, minval=minVal, maxval=maxVal, periodic=False, forced=True) DCNL DCSP  DCSP for y in xrange(numColors): DCNL DCSP  DCSP  DCSP temp = enc.encode((rnd.random() * maxVal)) DCNL DCSP  DCSP  DCSP colors.append(numpy.array(temp, dtype=realDType)) DCNL DCSP else: DCNL DCSP  DCSP for y in xrange(numColors): DCNL DCSP  DCSP  DCSP sdr = numpy.zeros(n, dtype=realDType) DCNL DCSP  DCSP  DCSP sdr[rnd.sample(xrange(n), w)] = 1 DCNL DCSP  DCSP  DCSP colors.append(sdr) DCNL DCSP print 'Starting DCSP to DCSP train DCSP the DCSP sp DCSP on', numColors, 'patterns' DCNL DCSP startTime = time.time() DCNL DCSP for i in xrange(numColors): DCNL DCSP  DCSP spInput = colors[i] DCNL DCSP  DCSP onCells = numpy.zeros(columnDimensions) DCNL DCSP  DCSP spImpl.compute(spInput, True, onCells) DCNL DCSP  DCSP spOutput.append(onCells.tolist()) DCNL DCSP  DCSP activeCoincIndices = set(onCells.nonzero()[0]) DCNL DCSP  DCSP reUsed = activeCoincIndices.intersection(patterns) DCNL DCSP  DCSP if (len(reUsed) == 0): DCNL DCSP  DCSP  DCSP coincs.append((i, activeCoincIndices, colors[i])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP reUsedCoincs.append((i, activeCoincIndices, colors[i])) DCNL DCSP  DCSP patterns.update(activeCoincIndices) DCNL DCSP  DCSP if (((i + 1) % 100) == 0): DCNL DCSP  DCSP  DCSP print 'Record DCSP number:', (i + 1) DCNL DCSP  DCSP  DCSP print ('Elapsed DCSP time: DCSP %.2f DCSP seconds' % (time.time() - startTime)) DCNL DCSP  DCSP  DCSP print len(reUsedCoincs), 're-used DCSP coinc(s),' DCNL DCSP summ = [] DCNL DCSP for z in coincs: DCNL DCSP  DCSP summ.append(sum([len(z[1].intersection(y[1])) for y in reUsedCoincs])) DCNL DCSP zeros = len([x for x in summ if (x == 0)]) DCNL DCSP factor = ((max(summ) * len(summ)) / sum(summ)) DCNL DCSP if (len(reUsed) < 10): DCNL DCSP  DCSP self.assertLess(factor, 41, ('\nComputed DCSP factor: DCSP %d\nExpected DCSP Less DCSP than DCSP %d' % (factor, 41))) DCNL DCSP  DCSP self.assertLess(zeros, (0.99 * len(summ)), ('\nComputed DCSP zeros: DCSP %d\nExpected DCSP Less DCSP than DCSP %d' % (zeros, (0.99 * len(summ))))) DCNL DCSP else: DCNL DCSP  DCSP self.assertLess(factor, 8, ('\nComputed DCSP factor: DCSP %d\nExpected DCSP Less DCSP than DCSP %d' % (factor, 8))) DCNL DCSP  DCSP self.assertLess(zeros, 12, ('\nComputed DCSP zeros: DCSP %d\nExpected DCSP Less DCSP than DCSP %d' % (zeros, 12)))
def testSingleValue(self): DCNL DCSP classifier = self._classifier(steps=[1], alpha=1.0) DCNL DCSP retval = [] DCNL DCSP for recordNum in xrange(10): DCNL DCSP  DCSP retval = self._compute(classifier, recordNum, [1, 5], 0, 10) DCNL DCSP self.assertEqual(retval['actualValues'][0], 10) DCNL DCSP self.assertGreater(retval[1][0], 0.9)
def testSingleValue0Steps(self): DCNL DCSP classifier = self._classifier(steps=[0], alpha=1.0) DCNL DCSP retval = [] DCNL DCSP for recordNum in xrange(10): DCNL DCSP  DCSP retval = self._compute(classifier, recordNum, [1, 5], 0, 10) DCNL DCSP self.assertEqual(retval['actualValues'][0], 10) DCNL DCSP self.assertGreater(retval[0][0], 0.9)
def testMissingRecords(self): DCNL DCSP c = self._classifier([1], 1.0, 0.1, 0) DCNL DCSP recordNum = 0 DCNL DCSP c.compute(recordNum=recordNum, patternNZ=[1, 3, 5], classification={'bucketIdx': 0, 'actValue': 0}, learn=True, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP c.compute(recordNum=recordNum, patternNZ=[2, 4, 6], classification={'bucketIdx': 1, 'actValue': 1}, learn=True, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP c.compute(recordNum=recordNum, patternNZ=[1, 3, 5], classification={'bucketIdx': 2, 'actValue': 2}, learn=True, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP c.compute(recordNum=recordNum, patternNZ=[2, 4, 6], classification={'bucketIdx': 1, 'actValue': 1}, learn=True, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP result = c.compute(recordNum=recordNum, patternNZ=[1, 3, 5], classification={'bucketIdx': 2, 'actValue': 2}, learn=True, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertLess(result[1][0], 0.1) DCNL DCSP self.assertGreater(result[1][1], 0.9) DCNL DCSP self.assertLess(result[1][2], 0.1) DCNL DCSP result = c.compute(recordNum=recordNum, patternNZ=[2, 4, 6], classification={'bucketIdx': 1, 'actValue': 1}, learn=True, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertLess(result[1][0], 0.1) DCNL DCSP self.assertLess(result[1][1], 0.1) DCNL DCSP self.assertGreater(result[1][2], 0.9) DCNL DCSP recordNum += 1 DCNL DCSP result = c.compute(recordNum=recordNum, patternNZ=[1, 3, 5], classification={'bucketIdx': 0, 'actValue': 0}, learn=True, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertLess(result[1][0], 0.1) DCNL DCSP self.assertGreater(result[1][1], 0.9) DCNL DCSP self.assertLess(result[1][2], 0.1) DCNL DCSP recordNum += 1 DCNL DCSP result = c.compute(recordNum=recordNum, patternNZ=[2, 4, 6], classification={'bucketIdx': 0, 'actValue': 0}, learn=True, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertLess(result[1][0], 0.1) DCNL DCSP self.assertLess(result[1][1], 0.1) DCNL DCSP self.assertGreater(result[1][2], 0.9) DCNL DCSP recordNum += 1 DCNL DCSP result = c.compute(recordNum=recordNum, patternNZ=[1, 3, 5], classification={'bucketIdx': 0, 'actValue': 0}, learn=True, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertLess(result[1][0], 0.1) DCNL DCSP self.assertGreater(result[1][1], 0.9) DCNL DCSP self.assertLess(result[1][2], 0.1)
def testMissingRecordInitialization(self): DCNL DCSP c = self._classifier([2], 0.1, 0.1, 0) DCNL DCSP result = c.compute(recordNum=0, patternNZ=[1, 5, 9], classification={'bucketIdx': 0, 'actValue': 34.7}, learn=True, infer=True) DCNL DCSP result = c.compute(recordNum=2, patternNZ=[1, 5, 9], classification={'bucketIdx': 0, 'actValue': 34.7}, learn=True, infer=True) DCNL DCSP self.assertSetEqual(set(result.keys()), set(('actualValues', 2))) DCNL DCSP self.assertEqual(len(result['actualValues']), 1) DCNL DCSP self.assertAlmostEqual(result['actualValues'][0], 34.7)
def testPredictionDistribution(self): DCNL DCSP c = self._classifier([0], 0.001, 0.1, 0) DCNL DCSP SDR1 = [1, 3, 5] DCNL DCSP SDR2 = [2, 4, 6] DCNL DCSP recordNum = 0 DCNL DCSP random.seed(42) DCNL DCSP for _ in xrange(5000): DCNL DCSP  DCSP randomNumber = random.random() DCNL DCSP  DCSP if (randomNumber < 0.3): DCNL DCSP  DCSP  DCSP bucketIdx = 0 DCNL DCSP  DCSP elif (randomNumber < 0.6): DCNL DCSP  DCSP  DCSP bucketIdx = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bucketIdx = 2 DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR1, classification={'bucketIdx': bucketIdx, 'actValue': bucketIdx}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP  DCSP randomNumber = random.random() DCNL DCSP  DCSP if (randomNumber < 0.5): DCNL DCSP  DCSP  DCSP bucketIdx = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bucketIdx = 3 DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR2, classification={'bucketIdx': bucketIdx, 'actValue': bucketIdx}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP result1 = c.compute(recordNum=recordNum, patternNZ=SDR1, classification=None, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertAlmostEqual(result1[0][0], 0.3, places=1) DCNL DCSP self.assertAlmostEqual(result1[0][1], 0.3, places=1) DCNL DCSP self.assertAlmostEqual(result1[0][2], 0.4, places=1) DCNL DCSP result2 = c.compute(recordNum=recordNum, patternNZ=SDR2, classification=None, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertAlmostEqual(result2[0][1], 0.5, places=1) DCNL DCSP self.assertAlmostEqual(result2[0][3], 0.5, places=1)
def testPredictionDistributionOverlap(self): DCNL DCSP c = self._classifier([0], 0.0005, 0.1, 0) DCNL DCSP recordNum = 0 DCNL DCSP SDR1 = numpy.arange(0, 39, step=2) DCNL DCSP SDR2 = numpy.arange(1, 40, step=2) DCNL DCSP SDR2[3] = SDR1[5] DCNL DCSP SDR2[5] = SDR1[11] DCNL DCSP random.seed(42) DCNL DCSP for _ in xrange(5000): DCNL DCSP  DCSP randomNumber = random.random() DCNL DCSP  DCSP if (randomNumber < 0.3): DCNL DCSP  DCSP  DCSP bucketIdx = 0 DCNL DCSP  DCSP elif (randomNumber < 0.6): DCNL DCSP  DCSP  DCSP bucketIdx = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bucketIdx = 2 DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR1, classification={'bucketIdx': bucketIdx, 'actValue': bucketIdx}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP  DCSP randomNumber = random.random() DCNL DCSP  DCSP if (randomNumber < 0.5): DCNL DCSP  DCSP  DCSP bucketIdx = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bucketIdx = 3 DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR2, classification={'bucketIdx': bucketIdx, 'actValue': bucketIdx}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP result1 = c.compute(recordNum=recordNum, patternNZ=SDR1, classification=None, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertAlmostEqual(result1[0][0], 0.3, places=1) DCNL DCSP self.assertAlmostEqual(result1[0][1], 0.3, places=1) DCNL DCSP self.assertAlmostEqual(result1[0][2], 0.4, places=1) DCNL DCSP result2 = c.compute(recordNum=recordNum, patternNZ=SDR2, classification=None, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertAlmostEqual(result2[0][1], 0.5, places=1) DCNL DCSP self.assertAlmostEqual(result2[0][3], 0.5, places=1)
def testPredictionMultipleCategories(self): DCNL DCSP c = self._classifier([0], 0.001, 0.1, 0) DCNL DCSP SDR1 = [1, 3, 5] DCNL DCSP SDR2 = [2, 4, 6] DCNL DCSP recordNum = 0 DCNL DCSP random.seed(42) DCNL DCSP for _ in xrange(5000): DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR1, classification={'bucketIdx': [0, 1], 'actValue': [0, 1]}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR2, classification={'bucketIdx': [2, 3], 'actValue': [2, 3]}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP result1 = c.compute(recordNum=recordNum, patternNZ=SDR1, classification=None, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertAlmostEqual(result1[0][0], 0.5, places=1) DCNL DCSP self.assertAlmostEqual(result1[0][1], 0.5, places=1) DCNL DCSP result2 = c.compute(recordNum=recordNum, patternNZ=SDR2, classification=None, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertAlmostEqual(result2[0][2], 0.5, places=1) DCNL DCSP self.assertAlmostEqual(result2[0][3], 0.5, places=1)
def testPredictionDistributionContinuousLearning(self): DCNL DCSP c = self._classifier([0], 0.001, 0.1, 0) DCNL DCSP recordNum = 0 DCNL DCSP SDR1 = [1, 3, 5] DCNL DCSP SDR2 = [2, 4, 6] DCNL DCSP random.seed(42) DCNL DCSP for _ in xrange(10000): DCNL DCSP  DCSP randomNumber = random.random() DCNL DCSP  DCSP if (randomNumber < 0.3): DCNL DCSP  DCSP  DCSP bucketIdx = 0 DCNL DCSP  DCSP elif (randomNumber < 0.6): DCNL DCSP  DCSP  DCSP bucketIdx = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bucketIdx = 2 DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR1, classification={'bucketIdx': bucketIdx, 'actValue': bucketIdx}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP  DCSP randomNumber = random.random() DCNL DCSP  DCSP if (randomNumber < 0.5): DCNL DCSP  DCSP  DCSP bucketIdx = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bucketIdx = 3 DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR2, classification={'bucketIdx': bucketIdx, 'actValue': bucketIdx}, learn=True, infer=True) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP result1 = c.compute(recordNum=recordNum, patternNZ=SDR1, classification={'bucketIdx': 0, 'actValue': 0}, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertAlmostEqual(result1[0][0], 0.3, places=1) DCNL DCSP self.assertAlmostEqual(result1[0][1], 0.3, places=1) DCNL DCSP self.assertAlmostEqual(result1[0][2], 0.4, places=1) DCNL DCSP result2 = c.compute(recordNum=recordNum, patternNZ=SDR2, classification={'bucketIdx': 0, 'actValue': 0}, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertAlmostEqual(result2[0][1], 0.5, places=1) DCNL DCSP self.assertAlmostEqual(result2[0][3], 0.5, places=1) DCNL DCSP for _ in xrange(20000): DCNL DCSP  DCSP randomNumber = random.random() DCNL DCSP  DCSP if (randomNumber < 0.3): DCNL DCSP  DCSP  DCSP bucketIdx = 0 DCNL DCSP  DCSP elif (randomNumber < 0.6): DCNL DCSP  DCSP  DCSP bucketIdx = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bucketIdx = 3 DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR1, classification={'bucketIdx': bucketIdx, 'actValue': bucketIdx}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP result1new = c.compute(recordNum=recordNum, patternNZ=SDR1, classification=None, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertAlmostEqual(result1new[0][0], 0.3, places=1) DCNL DCSP self.assertAlmostEqual(result1new[0][1], 0.3, places=1) DCNL DCSP self.assertAlmostEqual(result1new[0][3], 0.4, places=1) DCNL DCSP result2new = c.compute(recordNum=recordNum, patternNZ=SDR2, classification=None, learn=False, infer=True) DCNL DCSP recordNum += 1 DCNL DCSP self.assertSequenceEqual(list(result2[0]), list(result2new[0]))
def testMultiStepPredictions(self): DCNL DCSP c = self._classifier([0, 1], 1.0, 0.1, 0) DCNL DCSP SDR1 = [1, 3, 5] DCNL DCSP SDR2 = [2, 4, 6] DCNL DCSP recordNum = 0 DCNL DCSP for _ in xrange(100): DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR1, classification={'bucketIdx': 0, 'actValue': 0}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP  DCSP c.compute(recordNum=recordNum, patternNZ=SDR2, classification={'bucketIdx': 1, 'actValue': 1}, learn=True, infer=False) DCNL DCSP  DCSP recordNum += 1 DCNL DCSP result1 = c.compute(recordNum=recordNum, patternNZ=SDR1, classification=None, learn=False, infer=True) DCNL DCSP result2 = c.compute(recordNum=recordNum, patternNZ=SDR2, classification=None, learn=False, infer=True) DCNL DCSP self.assertAlmostEqual(result1[0][0], 1.0, places=1) DCNL DCSP self.assertAlmostEqual(result1[0][1], 0.0, places=1) DCNL DCSP self.assertAlmostEqual(result2[0][0], 0.0, places=1) DCNL DCSP self.assertAlmostEqual(result2[0][1], 1.0, places=1)
def _basicTest(self, tm=None): DCNL DCSP trainingSet = _getSimplePatterns(10, 10) DCNL DCSP for _ in range(2): DCNL DCSP  DCSP for seq in trainingSet[0:5]: DCNL DCSP  DCSP  DCSP for _ in range(10): DCNL DCSP  DCSP  DCSP  DCSP tm.learn(seq) DCNL DCSP  DCSP  DCSP tm.reset() DCNL DCSP print 'Learning DCSP completed' DCNL DCSP print 'Running DCSP inference' DCNL DCSP tm.collectStats = True DCNL DCSP for seq in trainingSet[0:5]: DCNL DCSP  DCSP tm.reset() DCNL DCSP  DCSP tm.resetStats() DCNL DCSP  DCSP for _ in range(10): DCNL DCSP  DCSP  DCSP tm.infer(seq) DCNL DCSP  DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP _printOneTrainingVector(seq) DCNL DCSP  DCSP  DCSP  DCSP tm.printStates(False, False) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP print tm.getStats() DCNL DCSP  DCSP self.assertGreater(tm.getStats()['predictionScoreAvg2'], 0.8) DCNL DCSP  DCSP print ("tm.getStats()['predictionScoreAvg2'] DCSP = DCSP ", tm.getStats()['predictionScoreAvg2']) DCNL DCSP print 'TMConstant DCSP basicTest DCSP ok'
def testAnomalyCumulative(self): DCNL DCSP anomalyComputer = anomaly.Anomaly(slidingWindowSize=3) DCNL DCSP predicted = (array([1, 2, 6]), array([1, 2, 6]), array([1, 2, 6]), array([1, 2, 6]), array([1, 2, 6]), array([1, 2, 6]), array([1, 2, 6]), array([1, 2, 6]), array([1, 2, 6])) DCNL DCSP actual = (array([1, 2, 6]), array([1, 2, 6]), array([1, 4, 6]), array([10, 11, 6]), array([10, 11, 12]), array([10, 11, 12]), array([10, 11, 12]), array([1, 2, 6]), array([1, 2, 6])) DCNL DCSP anomalyExpected = (0.0, 0.0, (1.0 / 9.0), (3.0 / 9.0), (2.0 / 3.0), (8.0 / 9.0), 1.0, (2.0 / 3.0), (1.0 / 3.0)) DCNL DCSP for (act, pred, expected) in zip(actual, predicted, anomalyExpected): DCNL DCSP  DCSP score = anomalyComputer.compute(act, pred) DCNL DCSP  DCSP self.assertAlmostEqual(score, expected, places=5, msg=("Anomaly DCSP score DCSP of DCSP %f DCSP doesn't DCSP match DCSP expected DCSP of DCSP %f" % (score, expected)))
def testSerialization(self): DCNL DCSP aDef = Anomaly() DCNL DCSP aLike = Anomaly(mode=Anomaly.MODE_LIKELIHOOD) DCNL DCSP aWeig = Anomaly(mode=Anomaly.MODE_WEIGHTED) DCNL DCSP aAll = Anomaly(mode=Anomaly.MODE_LIKELIHOOD, slidingWindowSize=5) DCNL DCSP inst = [aDef, aLike, aWeig, aAll] DCNL DCSP for a in inst: DCNL DCSP  DCSP stored = pickle.dumps(a) DCNL DCSP  DCSP restored = pickle.loads(stored) DCNL DCSP  DCSP self.assertEqual(a, restored)
def basicComputeLoop(self, imp, params, inputSize, columnDimensions, seed=None): DCNL DCSP sp = CreateSP(imp, params) DCNL DCSP numRecords = 100 DCNL DCSP randomState = getNumpyRandomGenerator(seed) DCNL DCSP inputMatrix = (randomState.rand(numRecords, inputSize) > 0.8).astype(uintType) DCNL DCSP y = numpy.zeros(columnDimensions, dtype=uintType) DCNL DCSP dutyCycles = numpy.zeros(columnDimensions, dtype=uintType) DCNL DCSP for v in inputMatrix: DCNL DCSP  DCSP y.fill(0) DCNL DCSP  DCSP sp.compute(v, True, y) DCNL DCSP  DCSP self.assertEqual(sp.getNumActiveColumnsPerInhArea(), y.sum()) DCNL DCSP  DCSP self.assertEqual(0, y.min()) DCNL DCSP  DCSP self.assertEqual(1, y.max()) DCNL DCSP for v in inputMatrix: DCNL DCSP  DCSP y.fill(0) DCNL DCSP  DCSP sp.compute(v, False, y) DCNL DCSP  DCSP self.assertEqual(sp.getNumActiveColumnsPerInhArea(), y.sum()) DCNL DCSP  DCSP self.assertEqual(0, y.min()) DCNL DCSP  DCSP self.assertEqual(1, y.max())
def testBasicCompute1(self): DCNL DCSP inputSize = 30 DCNL DCSP columnDimensions = 50 DCNL DCSP params = {'inputDimensions': [inputSize], 'columnDimensions': [columnDimensions], 'potentialRadius': inputSize, 'globalInhibition': True, 'seed': int(((time.time() % 10000) * 10))} DCNL DCSP print 'testBasicCompute1, DCSP SP DCSP seed DCSP set DCSP to:', params['seed'] DCNL DCSP self.basicComputeLoop('py', params, inputSize, columnDimensions) DCNL DCSP self.basicComputeLoop('cpp', params, inputSize, columnDimensions)
def testBasicCompute2(self): DCNL DCSP inputSize = 100 DCNL DCSP columnDimensions = 100 DCNL DCSP params = {'inputDimensions': [inputSize], 'columnDimensions': [columnDimensions], 'potentialRadius': inputSize, 'globalInhibition': True, 'synPermActiveInc': 0.0, 'synPermInactiveDec': 0.0, 'seed': int(((time.time() % 10000) * 10))} DCNL DCSP print 'testBasicCompute2, DCSP SP DCSP seed DCSP set DCSP to:', params['seed'] DCNL DCSP self.basicComputeLoop('py', params, inputSize, columnDimensions) DCNL DCSP self.basicComputeLoop('cpp', params, inputSize, columnDimensions)
def testCompute1(self): DCNL DCSP sp = SpatialPooler(inputDimensions=[9], columnDimensions=[5], potentialRadius=3, potentialPct=0.5, globalInhibition=False, localAreaDensity=(-1.0), numActiveColumnsPerInhArea=3, stimulusThreshold=1, synPermInactiveDec=0.1, synPermActiveInc=0.1, synPermConnected=0.1, minPctOverlapDutyCycle=0.1, dutyCyclePeriod=10, boostStrength=10.0, seed=getSeed(), spVerbosity=0) DCNL DCSP sp._potentialPools = BinaryCorticalColumns(numpy.ones([sp._numColumns, sp._numInputs])) DCNL DCSP sp._inhibitColumns = Mock(return_value=numpy.array(range(5))) DCNL DCSP inputVector = numpy.array([1, 0, 1, 0, 1, 0, 0, 1, 1]) DCNL DCSP activeArray = numpy.zeros(5) DCNL DCSP for i in xrange(20): DCNL DCSP  DCSP sp.compute(inputVector, True, activeArray) DCNL DCSP for i in xrange(sp._numColumns): DCNL DCSP  DCSP perm = sp._permanences.getRow(i) DCNL DCSP  DCSP self.assertEqual(list(perm), list(inputVector))
def testCompute2(self): DCNL DCSP sp = SpatialPooler(inputDimensions=[10], columnDimensions=[5], potentialRadius=3, potentialPct=0.5, globalInhibition=False, localAreaDensity=(-1.0), numActiveColumnsPerInhArea=3, stimulusThreshold=1, synPermInactiveDec=0.01, synPermActiveInc=0.1, synPermConnected=0.1, minPctOverlapDutyCycle=0.1, dutyCyclePeriod=10, boostStrength=10.0, seed=getSeed(), spVerbosity=0) DCNL DCSP sp._inhibitColumns = Mock(return_value=numpy.array(range(5))) DCNL DCSP inputVector = numpy.ones(sp._numInputs) DCNL DCSP activeArray = numpy.zeros(5) DCNL DCSP for i in xrange(20): DCNL DCSP  DCSP sp.compute(inputVector, True, activeArray) DCNL DCSP for columnIndex in xrange(sp._numColumns): DCNL DCSP  DCSP potential = sp._potentialPools[columnIndex] DCNL DCSP  DCSP perm = sp._permanences.getRow(columnIndex) DCNL DCSP  DCSP self.assertEqual(list(perm), list(potential))
def testZeroOverlap_NoStimulusThreshold_GlobalInhibition(self): DCNL DCSP inputSize = 10 DCNL DCSP nColumns = 20 DCNL DCSP sp = SpatialPooler(inputDimensions=[inputSize], columnDimensions=[nColumns], potentialRadius=10, globalInhibition=True, numActiveColumnsPerInhArea=3, stimulusThreshold=0, seed=getSeed()) DCNL DCSP inputVector = numpy.zeros(inputSize) DCNL DCSP activeArray = numpy.zeros(nColumns) DCNL DCSP sp.compute(inputVector, True, activeArray) DCNL DCSP self.assertEqual(3, len(activeArray.nonzero()[0]))
def testZeroOverlap_StimulusThreshold_GlobalInhibition(self): DCNL DCSP inputSize = 10 DCNL DCSP nColumns = 20 DCNL DCSP sp = SpatialPooler(inputDimensions=[inputSize], columnDimensions=[nColumns], potentialRadius=10, globalInhibition=True, numActiveColumnsPerInhArea=3, stimulusThreshold=1, seed=getSeed()) DCNL DCSP inputVector = numpy.zeros(inputSize) DCNL DCSP activeArray = numpy.zeros(nColumns) DCNL DCSP sp.compute(inputVector, True, activeArray) DCNL DCSP self.assertEqual(0, len(activeArray.nonzero()[0]))
def testZeroOverlap_NoStimulusThreshold_LocalInhibition(self): DCNL DCSP inputSize = 10 DCNL DCSP nColumns = 20 DCNL DCSP sp = SpatialPooler(inputDimensions=[inputSize], columnDimensions=[nColumns], potentialRadius=5, globalInhibition=False, numActiveColumnsPerInhArea=1, stimulusThreshold=0, seed=getSeed()) DCNL DCSP sp.setInhibitionRadius(2) DCNL DCSP inputVector = numpy.zeros(inputSize) DCNL DCSP activeArray = numpy.zeros(nColumns) DCNL DCSP sp.compute(inputVector, True, activeArray) DCNL DCSP self.assertEqual(len(activeArray.nonzero()[0]), 6)
def testZeroOverlap_StimulusThreshold_LocalInhibition(self): DCNL DCSP inputSize = 10 DCNL DCSP nColumns = 20 DCNL DCSP sp = SpatialPooler(inputDimensions=[inputSize], columnDimensions=[nColumns], potentialRadius=10, globalInhibition=False, numActiveColumnsPerInhArea=3, stimulusThreshold=1, seed=getSeed()) DCNL DCSP inputVector = numpy.zeros(inputSize) DCNL DCSP activeArray = numpy.zeros(nColumns) DCNL DCSP sp.compute(inputVector, True, activeArray) DCNL DCSP self.assertEqual(0, len(activeArray.nonzero()[0]))
def testOverlapsOutput(self): DCNL DCSP sp = SpatialPooler(inputDimensions=[5], columnDimensions=[3], potentialRadius=5, numActiveColumnsPerInhArea=5, globalInhibition=True, seed=1, synPermActiveInc=0.1, synPermInactiveDec=0.1) DCNL DCSP inputVector = numpy.ones(5) DCNL DCSP activeArray = numpy.zeros(3) DCNL DCSP expOutput = numpy.array([2, 0, 0], dtype=realDType) DCNL DCSP boostFactors = (2.0 * numpy.ones(3)) DCNL DCSP sp.setBoostFactors(boostFactors) DCNL DCSP sp.compute(inputVector, True, activeArray) DCNL DCSP overlaps = sp.getOverlaps() DCNL DCSP boostedOverlaps = sp.getBoostedOverlaps() DCNL DCSP for i in range(sp.getNumColumns()): DCNL DCSP  DCSP self.assertEqual(overlaps[i], expOutput[i]) DCNL DCSP for i in range(sp.getNumColumns()): DCNL DCSP  DCSP self.assertEqual(boostedOverlaps[i], (2 * expOutput[i]))
def testExactOutput(self): DCNL DCSP expectedOutput = [57, 80, 135, 215, 281, 350, 431, 534, 556, 565, 574, 595, 663, 759, 777, 823, 932, 933, 1031, 1126, 1184, 1262, 1468, 1479, 1516, 1531, 1585, 1672, 1793, 1807, 1906, 1927, 1936, 1939, 1940, 1944, 1957, 1978, 2040, 2047] DCNL DCSP sp = SpatialPooler(inputDimensions=[1, 188], columnDimensions=[2048, 1], potentialRadius=94, potentialPct=0.5, globalInhibition=1, localAreaDensity=(-1.0), numActiveColumnsPerInhArea=40.0, stimulusThreshold=0, synPermInactiveDec=0.01, synPermActiveInc=0.1, synPermConnected=0.1, minPctOverlapDutyCycle=0.001, dutyCyclePeriod=1000, boostStrength=10.0, seed=1956, spVerbosity=0) DCNL DCSP inputVector = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] DCNL DCSP inputArray = numpy.array(inputVector).astype(realDType) DCNL DCSP activeArray = numpy.zeros(2048) DCNL DCSP sp.compute(inputArray, 1, activeArray) DCNL DCSP spOutput = [i for (i, v) in enumerate(activeArray) if (v != 0)] DCNL DCSP self.assertEqual(sorted(spOutput), expectedOutput)
def testCalculateOverlap(self): DCNL DCSP sp = SpatialPooler(inputDimensions=[10], columnDimensions=[5]) DCNL DCSP sp._connectedSynapses = BinaryCorticalColumns([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1]]) DCNL DCSP sp._connectedCounts = numpy.array([10.0, 8.0, 6.0, 4.0, 2.0]) DCNL DCSP inputVector = numpy.zeros(sp._numInputs, dtype='float32') DCNL DCSP overlaps = sp._calculateOverlap(inputVector) DCNL DCSP overlapsPct = sp._calculateOverlapPct(overlaps) DCNL DCSP trueOverlaps = list(numpy.array([0, 0, 0, 0, 0], dtype=realDType)) DCNL DCSP trueOverlapsPct = list(numpy.array([0, 0, 0, 0, 0])) DCNL DCSP self.assertListEqual(list(overlaps), trueOverlaps) DCNL DCSP self.assertListEqual(list(overlapsPct), trueOverlapsPct) DCNL DCSP sp._connectedSynapses = BinaryCorticalColumns([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1]]) DCNL DCSP sp._connectedCounts = numpy.array([10.0, 8.0, 6.0, 4.0, 2.0]) DCNL DCSP inputVector = numpy.ones(sp._numInputs, dtype='float32') DCNL DCSP overlaps = sp._calculateOverlap(inputVector) DCNL DCSP overlapsPct = sp._calculateOverlapPct(overlaps) DCNL DCSP trueOverlaps = list(numpy.array([10, 8, 6, 4, 2], dtype=realDType)) DCNL DCSP trueOverlapsPct = list(numpy.array([1, 1, 1, 1, 1])) DCNL DCSP self.assertListEqual(list(overlaps), trueOverlaps) DCNL DCSP self.assertListEqual(list(overlapsPct), trueOverlapsPct) DCNL DCSP sp._connectedSynapses = BinaryCorticalColumns([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1]]) DCNL DCSP sp._connectedCounts = numpy.array([10.0, 8.0, 6.0, 4.0, 2.0]) DCNL DCSP inputVector = numpy.zeros(sp._numInputs, dtype='float32') DCNL DCSP inputVector[9] = 1 DCNL DCSP overlaps = sp._calculateOverlap(inputVector) DCNL DCSP overlapsPct = sp._calculateOverlapPct(overlaps) DCNL DCSP trueOverlaps = list(numpy.array([1, 1, 1, 1, 1], dtype=realDType)) DCNL DCSP trueOverlapsPct = list(numpy.array([0.1, 0.125, (1.0 / 6), 0.25, 0.5])) DCNL DCSP self.assertListEqual(list(overlaps), trueOverlaps) DCNL DCSP self.assertListEqual(list(overlapsPct), trueOverlapsPct) DCNL DCSP sp._connectedSynapses = BinaryCorticalColumns([[1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1]]) DCNL DCSP sp._connectedCounts = numpy.array([2.0, 2.0, 2.0, 2.0, 2.0]) DCNL DCSP inputVector = numpy.zeros(sp._numInputs, dtype='float32') DCNL DCSP inputVector[range(0, 10, 2)] = 1 DCNL DCSP overlaps = sp._calculateOverlap(inputVector) DCNL DCSP overlapsPct = sp._calculateOverlapPct(overlaps) DCNL DCSP trueOverlaps = list(numpy.array([1, 1, 1, 1, 1], dtype=realDType)) DCNL DCSP trueOverlapsPct = list(numpy.array([0.5, 0.5, 0.5, 0.5, 0.5])) DCNL DCSP self.assertListEqual(list(overlaps), trueOverlaps) DCNL DCSP self.assertListEqual(list(overlapsPct), trueOverlapsPct)
def testInitPermanence1(self): DCNL DCSP sp = self._sp DCNL DCSP sp._inputDimensions = numpy.array([10]) DCNL DCSP sp._numInputs = 10 DCNL DCSP sp._raisePermanenceToThreshold = Mock() DCNL DCSP sp._potentialRadius = 2 DCNL DCSP connectedPct = 1 DCNL DCSP mask = numpy.array([1, 1, 1, 0, 0, 0, 0, 0, 1, 1]) DCNL DCSP perm = sp._initPermanence(mask, connectedPct) DCNL DCSP connected = (perm >= sp._synPermConnected).astype(int) DCNL DCSP numcon = connected.nonzero()[0].size DCNL DCSP self.assertEqual(numcon, 5) DCNL DCSP connectedPct = 0 DCNL DCSP perm = sp._initPermanence(mask, connectedPct) DCNL DCSP connected = (perm >= sp._synPermConnected).astype(int) DCNL DCSP numcon = connected.nonzero()[0].size DCNL DCSP self.assertEqual(numcon, 0) DCNL DCSP connectedPct = 0.5 DCNL DCSP sp._potentialRadius = 100 DCNL DCSP sp._numInputs = 100 DCNL DCSP mask = numpy.ones(100) DCNL DCSP perm = sp._initPermanence(mask, connectedPct) DCNL DCSP connected = (perm >= sp._synPermConnected).astype(int) DCNL DCSP numcon = connected.nonzero()[0].size DCNL DCSP self.assertGreater(numcon, 0) DCNL DCSP self.assertLess(numcon, sp._numInputs) DCNL DCSP minThresh = 0.0 DCNL DCSP maxThresh = sp._synPermMax DCNL DCSP self.assertEqual(numpy.logical_and((perm >= minThresh), (perm <= maxThresh)).all(), True)
def testInitPermanence2(self): DCNL DCSP sp = self._sp DCNL DCSP sp._raisePermanenceToThreshold = Mock() DCNL DCSP sp._numInputs = 10 DCNL DCSP connectedPct = 1 DCNL DCSP mask = numpy.array([1, 1, 0, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP perm = sp._initPermanence(mask, connectedPct) DCNL DCSP connected = list((perm > 0).astype(int)) DCNL DCSP trueConnected = [1, 1, 0, 0, 0, 0, 0, 0, 0, 0] DCNL DCSP self.assertListEqual(connected, trueConnected) DCNL DCSP sp._numInputs = 10 DCNL DCSP connectedPct = 1 DCNL DCSP mask = numpy.array([0, 0, 0, 0, 1, 1, 1, 0, 0, 0]) DCNL DCSP perm = sp._initPermanence(mask, connectedPct) DCNL DCSP connected = list((perm > 0).astype(int)) DCNL DCSP trueConnected = [0, 0, 0, 0, 1, 1, 1, 0, 0, 0] DCNL DCSP self.assertListEqual(connected, trueConnected) DCNL DCSP sp._numInputs = 10 DCNL DCSP connectedPct = 1 DCNL DCSP mask = numpy.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1]) DCNL DCSP perm = sp._initPermanence(mask, connectedPct) DCNL DCSP connected = list((perm > 0).astype(int)) DCNL DCSP trueConnected = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1] DCNL DCSP self.assertListEqual(connected, trueConnected) DCNL DCSP sp._numInputs = 10 DCNL DCSP connectedPct = 1 DCNL DCSP mask = numpy.array([1, 1, 1, 1, 1, 1, 1, 0, 1, 1]) DCNL DCSP perm = sp._initPermanence(mask, connectedPct) DCNL DCSP connected = list((perm > 0).astype(int)) DCNL DCSP trueConnected = [1, 1, 1, 1, 1, 1, 1, 0, 1, 1] DCNL DCSP self.assertListEqual(connected, trueConnected)
def testUpdateDutyCycleHelper(self): DCNL DCSP dc = numpy.zeros(5) DCNL DCSP dc = numpy.array([1000.0, 1000.0, 1000.0, 1000.0, 1000.0]) DCNL DCSP period = 1000 DCNL DCSP newvals = numpy.zeros(5) DCNL DCSP newDc = SpatialPooler._updateDutyCyclesHelper(dc, newvals, period) DCNL DCSP trueNewDc = [999, 999, 999, 999, 999] DCNL DCSP self.assertListEqual(list(newDc), trueNewDc) DCNL DCSP dc = numpy.array([1000.0, 1000.0, 1000.0, 1000.0, 1000.0]) DCNL DCSP period = 1000 DCNL DCSP newvals = numpy.zeros(5) DCNL DCSP newvals.fill(1000) DCNL DCSP newDc = SpatialPooler._updateDutyCyclesHelper(dc, newvals, period) DCNL DCSP trueNewDc = list(dc) DCNL DCSP self.assertListEqual(list(newDc), trueNewDc) DCNL DCSP dc = numpy.array([1000, 1000, 1000, 1000, 1000]) DCNL DCSP newvals = numpy.array([2000, 4000, 5000, 6000, 7000]) DCNL DCSP period = 1000 DCNL DCSP newDc = SpatialPooler._updateDutyCyclesHelper(dc, newvals, period) DCNL DCSP trueNewDc = [1001, 1003, 1004, 1005, 1006] DCNL DCSP self.assertListEqual(list(newDc), trueNewDc) DCNL DCSP dc = numpy.array([1000, 800, 600, 400, 2000]) DCNL DCSP newvals = numpy.zeros(5) DCNL DCSP period = 2 DCNL DCSP newDc = SpatialPooler._updateDutyCyclesHelper(dc, newvals, period) DCNL DCSP trueNewDc = [500, 400, 300, 200, 1000] DCNL DCSP self.assertListEqual(list(newDc), trueNewDc)
def testInhibitColumnsGlobal(self): DCNL DCSP sp = self._sp DCNL DCSP density = 0.3 DCNL DCSP sp._numColumns = 10 DCNL DCSP overlaps = numpy.array([1, 2, 1, 4, 8, 3, 12, 5, 4, 1], dtype=realDType) DCNL DCSP active = list(sp._inhibitColumnsGlobal(overlaps, density)) DCNL DCSP trueActive = numpy.zeros(sp._numColumns) DCNL DCSP trueActive = [4, 6, 7] DCNL DCSP self.assertListEqual(list(trueActive), sorted(active)) DCNL DCSP density = 0.5 DCNL DCSP sp._numColumns = 10 DCNL DCSP overlaps = numpy.array(range(10), dtype=realDType) DCNL DCSP active = list(sp._inhibitColumnsGlobal(overlaps, density)) DCNL DCSP trueActive = numpy.zeros(sp._numColumns) DCNL DCSP trueActive = range(5, 10) DCNL DCSP self.assertListEqual(trueActive, sorted(active))
@unittest.skip('Ported DCSP from DCSP the DCSP removed DCSP FlatSpatialPooler DCSP but DCSP fails. DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP See: DCSP https://github.com/numenta/nupic/issues/1897') DCNL def testActiveColumnsEqualNumActive(self): DCNL DCSP for i in [1, 10, 50]: DCNL DCSP  DCSP numActive = i DCNL DCSP  DCSP inputShape = 10 DCNL DCSP  DCSP sp = SpatialPooler(inputDimensions=[inputShape], columnDimensions=[100], numActiveColumnsPerInhArea=numActive) DCNL DCSP  DCSP inputArray = (numpy.random.rand(inputShape) > 0.5).astype(uintDType) DCNL DCSP  DCSP inputArray2 = (numpy.random.rand(inputShape) > 0.8).astype(uintDType) DCNL DCSP  DCSP activeArray = numpy.zeros(sp._numColumns).astype(realDType) DCNL DCSP  DCSP sp.compute(inputArray, True, activeArray) DCNL DCSP  DCSP sp.compute(inputArray2, True, activeArray) DCNL DCSP  DCSP self.assertEqual(sum(activeArray), numActive) DCNL DCSP  DCSP sp.compute(inputArray, False, activeArray) DCNL DCSP  DCSP sp.compute(inputArray2, False, activeArray) DCNL DCSP  DCSP self.assertEqual(sum(activeArray), numActive)
def testDestroySegment(self): DCNL DCSP connections = Connections(1024) DCNL DCSP connections.createSegment(10) DCNL DCSP segment2 = connections.createSegment(20) DCNL DCSP connections.createSegment(30) DCNL DCSP connections.createSegment(40) DCNL DCSP connections.createSynapse(segment2, 80, 0.85) DCNL DCSP connections.createSynapse(segment2, 81, 0.85) DCNL DCSP connections.createSynapse(segment2, 82, 0.15) DCNL DCSP self.assertEqual(4, connections.numSegments()) DCNL DCSP self.assertEqual(3, connections.numSynapses()) DCNL DCSP connections.destroySegment(segment2) DCNL DCSP self.assertEqual(3, connections.numSegments()) DCNL DCSP self.assertEqual(0, connections.numSynapses()) DCNL DCSP (numActiveConnected, numActivePotential) = connections.computeActivity([80, 81, 82], 0.5) DCNL DCSP self.assertEqual(0, numActiveConnected[segment2.flatIdx]) DCNL DCSP self.assertEqual(0, numActivePotential[segment2.flatIdx])
def testDestroySynapse(self): DCNL DCSP connections = Connections(1024) DCNL DCSP segment = connections.createSegment(20) DCNL DCSP synapse1 = connections.createSynapse(segment, 80, 0.85) DCNL DCSP synapse2 = connections.createSynapse(segment, 81, 0.85) DCNL DCSP synapse3 = connections.createSynapse(segment, 82, 0.15) DCNL DCSP self.assertEqual(3, connections.numSynapses()) DCNL DCSP connections.destroySynapse(synapse2) DCNL DCSP self.assertEqual(2, connections.numSynapses()) DCNL DCSP self.assertEqual(set([synapse1, synapse3]), connections.synapsesForSegment(segment)) DCNL DCSP (numActiveConnected, numActivePotential) = connections.computeActivity([80, 81, 82], 0.5) DCNL DCSP self.assertEqual(1, numActiveConnected[segment.flatIdx]) DCNL DCSP self.assertEqual(2, numActivePotential[segment.flatIdx])
def testPathsNotInvalidatedByOtherDestroys(self): DCNL DCSP connections = Connections(1024) DCNL DCSP segment1 = connections.createSegment(11) DCNL DCSP connections.createSegment(12) DCNL DCSP segment3 = connections.createSegment(13) DCNL DCSP connections.createSegment(14) DCNL DCSP segment5 = connections.createSegment(15) DCNL DCSP synapse1 = connections.createSynapse(segment3, 201, 0.85) DCNL DCSP synapse2 = connections.createSynapse(segment3, 202, 0.85) DCNL DCSP synapse3 = connections.createSynapse(segment3, 203, 0.85) DCNL DCSP synapse4 = connections.createSynapse(segment3, 204, 0.85) DCNL DCSP synapse5 = connections.createSynapse(segment3, 205, 0.85) DCNL DCSP self.assertEqual(203, synapse3.presynapticCell) DCNL DCSP connections.destroySynapse(synapse1) DCNL DCSP self.assertEqual(203, synapse3.presynapticCell) DCNL DCSP connections.destroySynapse(synapse5) DCNL DCSP self.assertEqual(203, synapse3.presynapticCell) DCNL DCSP connections.destroySegment(segment1) DCNL DCSP self.assertEqual(set([synapse2, synapse3, synapse4]), connections.synapsesForSegment(segment3)) DCNL DCSP connections.destroySegment(segment5) DCNL DCSP self.assertEqual(set([synapse2, synapse3, synapse4]), connections.synapsesForSegment(segment3)) DCNL DCSP self.assertEqual(203, synapse3.presynapticCell)
def testDestroySegmentWithDestroyedSynapses(self): DCNL DCSP connections = Connections(1024) DCNL DCSP segment1 = connections.createSegment(11) DCNL DCSP segment2 = connections.createSegment(12) DCNL DCSP connections.createSynapse(segment1, 101, 0.85) DCNL DCSP synapse2a = connections.createSynapse(segment2, 201, 0.85) DCNL DCSP connections.createSynapse(segment2, 202, 0.85) DCNL DCSP self.assertEqual(3, connections.numSynapses()) DCNL DCSP connections.destroySynapse(synapse2a) DCNL DCSP self.assertEqual(2, connections.numSegments()) DCNL DCSP self.assertEqual(2, connections.numSynapses()) DCNL DCSP connections.destroySegment(segment2) DCNL DCSP self.assertEqual(1, connections.numSegments()) DCNL DCSP self.assertEqual(1, connections.numSynapses())
def testReuseSegmentWithDestroyedSynapses(self): DCNL DCSP connections = Connections(1024) DCNL DCSP segment = connections.createSegment(11) DCNL DCSP synapse1 = connections.createSynapse(segment, 201, 0.85) DCNL DCSP connections.createSynapse(segment, 202, 0.85) DCNL DCSP connections.destroySynapse(synapse1) DCNL DCSP self.assertEqual(1, connections.numSynapses(segment)) DCNL DCSP connections.destroySegment(segment) DCNL DCSP reincarnated = connections.createSegment(11) DCNL DCSP self.assertEqual(0, connections.numSynapses(reincarnated)) DCNL DCSP self.assertEqual(0, len(connections.synapsesForSegment(reincarnated)))
def testUpdateSynapsePermanence(self): DCNL DCSP connections = Connections(1024) DCNL DCSP segment = connections.createSegment(10) DCNL DCSP synapse = connections.createSynapse(segment, 50, 0.34) DCNL DCSP connections.updateSynapsePermanence(synapse, 0.21) DCNL DCSP synapseData = connections.dataForSynapse(synapse) DCNL DCSP self.assertAlmostEqual(synapseData.permanence, 0.21)
def testComputeActivity(self): DCNL DCSP connections = Connections(1024) DCNL DCSP segment1a = connections.createSegment(10) DCNL DCSP connections.createSynapse(segment1a, 150, 0.85) DCNL DCSP connections.createSynapse(segment1a, 151, 0.15) DCNL DCSP segment2a = connections.createSegment(20) DCNL DCSP connections.createSynapse(segment2a, 80, 0.85) DCNL DCSP connections.createSynapse(segment2a, 81, 0.85) DCNL DCSP synapse = connections.createSynapse(segment2a, 82, 0.85) DCNL DCSP connections.updateSynapsePermanence(synapse, 0.15) DCNL DCSP inputVec = [50, 52, 53, 80, 81, 82, 150, 151] DCNL DCSP (numActiveConnected, numActivePotential) = connections.computeActivity(inputVec, 0.5) DCNL DCSP self.assertEqual(1, numActiveConnected[segment1a.flatIdx]) DCNL DCSP self.assertEqual(2, numActivePotential[segment1a.flatIdx]) DCNL DCSP self.assertEqual(2, numActiveConnected[segment2a.flatIdx]) DCNL DCSP self.assertEqual(3, numActivePotential[segment2a.flatIdx])
def runSideBySide(self, params, seed=None, learnMode=None, convertEveryIteration=False): DCNL DCSP randomState = getNumpyRandomGenerator(seed) DCNL DCSP cppSp = CreateSP('cpp', params) DCNL DCSP pySp = CreateSP('py', params) DCNL DCSP self.compare(pySp, cppSp) DCNL DCSP numColumns = pySp.getNumColumns() DCNL DCSP numInputs = pySp.getNumInputs() DCNL DCSP threshold = 0.8 DCNL DCSP inputMatrix = (randomState.rand(numRecords, numInputs) > threshold).astype(uintType) DCNL DCSP for i in xrange(numRecords): DCNL DCSP  DCSP if (learnMode is None): DCNL DCSP  DCSP  DCSP learn = (randomState.rand() > 0.5) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP learn = learnMode DCNL DCSP  DCSP if (self.verbosity > 1): DCNL DCSP  DCSP  DCSP print 'Iteration:', i, 'learn=', learn DCNL DCSP  DCSP PyActiveArray = numpy.zeros(numColumns).astype(uintType) DCNL DCSP  DCSP CppActiveArray = numpy.zeros(numColumns).astype(uintType) DCNL DCSP  DCSP inputVector = inputMatrix[i, :] DCNL DCSP  DCSP pySp.compute(inputVector, learn, PyActiveArray) DCNL DCSP  DCSP cppSp.compute(inputVector, learn, CppActiveArray) DCNL DCSP  DCSP self.assertListEqual(list(PyActiveArray), list(CppActiveArray)) DCNL DCSP  DCSP self.compare(pySp, cppSp) DCNL DCSP  DCSP cppBoostFactors = numpy.zeros(numColumns, dtype=realType) DCNL DCSP  DCSP cppSp.getBoostFactors(cppBoostFactors) DCNL DCSP  DCSP pySp.setBoostFactors(cppBoostFactors) DCNL DCSP  DCSP if (convertEveryIteration or (((i + 1) % 10) == 0)): DCNL DCSP  DCSP  DCSP convertPermanences(pySp, cppSp)
@unittest.skip('Currently DCSP fails DCSP due DCSP to DCSP non-fixed DCSP randomness DCSP in DCSP C++ DCSP SP.') DCNL def testCompatibilityCppPyDirectCall1D(self): DCNL DCSP pySp = PySpatialPooler(inputDimensions=[121], columnDimensions=[300]) DCNL DCSP cppSp = CPPSpatialPooler(inputDimensions=[121], columnDimensions=[300]) DCNL DCSP data = numpy.zeros([121], dtype=uintType) DCNL DCSP for i in xrange(21): DCNL DCSP  DCSP data[i] = 1 DCNL DCSP nCols = 300 DCNL DCSP d1 = numpy.zeros(nCols, dtype=uintType) DCNL DCSP d2 = numpy.zeros(nCols, dtype=uintType) DCNL DCSP pySp.compute(data, True, d1) DCNL DCSP cppSp.compute(data, True, d2) DCNL DCSP d1 = d1.nonzero()[0].tolist() DCNL DCSP d2 = d2.nonzero()[0].tolist() DCNL DCSP self.assertListEqual(d1, d2, ('SP DCSP outputs DCSP are DCSP not DCSP equal: DCSP \n%s DCSP \n%s' % (str(d1), str(d2))))
@unittest.skip('Currently DCSP fails DCSP due DCSP to DCSP non-fixed DCSP randomness DCSP in DCSP C++ DCSP SP.') DCNL def testCompatibilityCppPyDirectCall2D(self): DCNL DCSP pySp = PySpatialPooler(inputDimensions=[121, 1], columnDimensions=[30, 30]) DCNL DCSP cppSp = CPPSpatialPooler(inputDimensions=[121, 1], columnDimensions=[30, 30]) DCNL DCSP data = numpy.zeros([121, 1], dtype=uintType) DCNL DCSP for i in xrange(21): DCNL DCSP  DCSP data[i][0] = 1 DCNL DCSP nCols = 900 DCNL DCSP d1 = numpy.zeros(nCols, dtype=uintType) DCNL DCSP d2 = numpy.zeros(nCols, dtype=uintType) DCNL DCSP pySp.compute(data, True, d1) DCNL DCSP cppSp.compute(data, True, d2) DCNL DCSP d1 = d1.nonzero()[0].tolist() DCNL DCSP d2 = d2.nonzero()[0].tolist() DCNL DCSP self.assertListEqual(d1, d2, ('SP DCSP outputs DCSP are DCSP not DCSP equal: DCSP \n%s DCSP \n%s' % (str(d1), str(d2))))
def testOverlapDistanceMethodStandard(self): DCNL DCSP params = {'distanceMethod': 'rawOverlap'} DCNL DCSP classifier = KNNClassifier(**params) DCNL DCSP dimensionality = 40 DCNL DCSP a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32) DCNL DCSP b = np.array([2, 4, 8, 12, 14, 18, 20, 28, 30], dtype=np.int32) DCNL DCSP numPatterns = classifier.learn(a, 0, isSparse=dimensionality) DCNL DCSP self.assertEquals(numPatterns, 1) DCNL DCSP numPatterns = classifier.learn(b, 1, isSparse=dimensionality) DCNL DCSP self.assertEquals(numPatterns, 2) DCNL DCSP denseA = np.zeros(dimensionality) DCNL DCSP denseA[a] = 1.0 DCNL DCSP (cat, _, _, _) = classifier.infer(denseA) DCNL DCSP self.assertEquals(cat, 0) DCNL DCSP denseB = np.zeros(dimensionality) DCNL DCSP denseB[b] = 1.0 DCNL DCSP (cat, _, _, _) = classifier.infer(denseB) DCNL DCSP self.assertEquals(cat, 1)
def testMinSparsity(self): DCNL DCSP params = {'distanceMethod': 'rawOverlap', 'minSparsity': 0.2} DCNL DCSP classifier = KNNClassifier(**params) DCNL DCSP dimensionality = 30 DCNL DCSP a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32) DCNL DCSP b = np.array([2, 4, 8, 12, 14, 18, 20, 21, 28], dtype=np.int32) DCNL DCSP c = np.array([2, 3, 8, 11, 14, 18], dtype=np.int32) DCNL DCSP d = np.array([2, 3, 8, 11, 18], dtype=np.int32) DCNL DCSP numPatterns = classifier.learn(a, 0, isSparse=dimensionality) DCNL DCSP self.assertEquals(numPatterns, 1) DCNL DCSP numPatterns = classifier.learn(b, 1, isSparse=dimensionality) DCNL DCSP self.assertEquals(numPatterns, 2) DCNL DCSP numPatterns = classifier.learn(c, 1, isSparse=dimensionality) DCNL DCSP self.assertEquals(numPatterns, 3) DCNL DCSP numPatterns = classifier.learn(d, 1, isSparse=dimensionality) DCNL DCSP self.assertEquals(numPatterns, 3) DCNL DCSP e = np.array([2, 4, 5, 6, 8, 12, 14, 18, 20], dtype=np.int32) DCNL DCSP dense = np.zeros(dimensionality) DCNL DCSP dense[e] = 1.0 DCNL DCSP (cat, inference, _, _) = classifier.infer(dense) DCNL DCSP self.assertIsNotNone(cat) DCNL DCSP self.assertGreater(inference.sum(), 0.0) DCNL DCSP f = np.array([2, 5, 8, 11, 14, 18], dtype=np.int32) DCNL DCSP dense = np.zeros(dimensionality) DCNL DCSP dense[f] = 1.0 DCNL DCSP (cat, inference, _, _) = classifier.infer(dense) DCNL DCSP self.assertIsNotNone(cat) DCNL DCSP self.assertGreater(inference.sum(), 0.0) DCNL DCSP g = np.array([2, 3, 8, 11, 19], dtype=np.int32) DCNL DCSP dense = np.zeros(dimensionality) DCNL DCSP dense[g] = 1.0 DCNL DCSP (cat, inference, _, _) = classifier.infer(dense) DCNL DCSP self.assertIsNone(cat) DCNL DCSP self.assertEqual(inference.sum(), 0.0)
def testPartitionIdExcluded(self): DCNL DCSP params = {'distanceMethod': 'rawOverlap'} DCNL DCSP classifier = KNNClassifier(**params) DCNL DCSP dimensionality = 40 DCNL DCSP a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32) DCNL DCSP b = np.array([2, 4, 8, 12, 14, 18, 20, 28, 30], dtype=np.int32) DCNL DCSP denseA = np.zeros(dimensionality) DCNL DCSP denseA[a] = 1.0 DCNL DCSP denseB = np.zeros(dimensionality) DCNL DCSP denseB[b] = 1.0 DCNL DCSP classifier.learn(a, 0, isSparse=dimensionality, partitionId=0) DCNL DCSP classifier.learn(b, 1, isSparse=dimensionality, partitionId=1) DCNL DCSP (cat, _, _, _) = classifier.infer(denseA, partitionId=1) DCNL DCSP self.assertEquals(cat, 0) DCNL DCSP (cat, _, _, _) = classifier.infer(denseA, partitionId=0) DCNL DCSP self.assertEquals(cat, 1) DCNL DCSP (cat, _, _, _) = classifier.infer(denseB, partitionId=0) DCNL DCSP self.assertEquals(cat, 1) DCNL DCSP (cat, _, _, _) = classifier.infer(denseB, partitionId=1) DCNL DCSP self.assertEquals(cat, 0) DCNL DCSP classifier.learn(a, 0, isSparse=dimensionality, partitionId=2) DCNL DCSP (cat, _, _, _) = classifier.infer(denseA, partitionId=0) DCNL DCSP self.assertEquals(cat, 0)
def testGetPartitionId(self): DCNL DCSP params = {'distanceMethod': 'rawOverlap'} DCNL DCSP classifier = KNNClassifier(**params) DCNL DCSP dimensionality = 40 DCNL DCSP a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32) DCNL DCSP b = np.array([2, 4, 8, 12, 14, 18, 20, 28, 30], dtype=np.int32) DCNL DCSP c = np.array([1, 2, 3, 14, 16, 19, 22, 24, 33], dtype=np.int32) DCNL DCSP d = np.array([2, 4, 8, 12, 14, 19, 22, 24, 33], dtype=np.int32) DCNL DCSP e = np.array([1, 3, 7, 12, 14, 19, 22, 24, 33], dtype=np.int32) DCNL DCSP denseA = np.zeros(dimensionality) DCNL DCSP denseA[a] = 1.0 DCNL DCSP classifier.learn(a, 0, isSparse=dimensionality, partitionId=433) DCNL DCSP classifier.learn(b, 1, isSparse=dimensionality, partitionId=213) DCNL DCSP classifier.learn(c, 1, isSparse=dimensionality, partitionId=None) DCNL DCSP classifier.learn(d, 1, isSparse=dimensionality, partitionId=433) DCNL DCSP self.assertEquals(classifier.getPartitionId(0), 433) DCNL DCSP self.assertEquals(classifier.getPartitionId(1), 213) DCNL DCSP self.assertEquals(classifier.getPartitionId(2), None) DCNL DCSP self.assertEquals(classifier.getPartitionId(3), 433) DCNL DCSP (cat, _, _, _) = classifier.infer(denseA, partitionId=213) DCNL DCSP self.assertEquals(cat, 0) DCNL DCSP (cat, _, _, _) = classifier.infer(denseA, partitionId=666) DCNL DCSP self.assertEquals(cat, 0) DCNL DCSP self.assertEquals(classifier.getPartitionId(0), 433) DCNL DCSP self.assertEquals(classifier.getPartitionId(1), 213) DCNL DCSP self.assertEquals(classifier.getPartitionId(2), None) DCNL DCSP self.assertEquals(classifier.getPartitionId(3), 433) DCNL DCSP with self.assertRaises(RuntimeError): DCNL DCSP  DCSP classifier.getPartitionId(4) DCNL DCSP with self.assertRaises(RuntimeError): DCNL DCSP  DCSP classifier.getPartitionId((-1)) DCNL DCSP classifier.learn(e, 4, isSparse=dimensionality, partitionId=413) DCNL DCSP self.assertEquals(classifier.getPartitionId(4), 413) DCNL DCSP self.assertItemsEqual(classifier.getPatternIndicesWithPartitionId(433), [0, 3]) DCNL DCSP self.assertItemsEqual(classifier.getPatternIndicesWithPartitionId(666), []) DCNL DCSP self.assertItemsEqual(classifier.getPatternIndicesWithPartitionId(413), [4]) DCNL DCSP self.assertEquals(classifier.getNumPartitionIds(), 3) DCNL DCSP self.assertItemsEqual(classifier.getPartitionIdList(), [433, 213, np.inf, 433, 413]) DCNL DCSP self.assertItemsEqual(classifier.getPartitionIdKeys(), [433, 413, 213]) DCNL DCSP self.assertEquals(classifier._removeRows([0, 2]), 2) DCNL DCSP self.assertItemsEqual(classifier.getPatternIndicesWithPartitionId(433), [1]) DCNL DCSP self.assertItemsEqual(classifier.getPatternIndicesWithPartitionId(413), [2]) DCNL DCSP classifier._removeRows([0]) DCNL DCSP self.assertEquals(classifier.getNumPartitionIds(), 2) DCNL DCSP self.assertItemsEqual(classifier.getPartitionIdList(), [433, 413]) DCNL DCSP self.assertItemsEqual(classifier.getPartitionIdKeys(), [433, 413])
def testGetPartitionIdWithNoIdsAtFirst(self): DCNL DCSP params = {'distanceMethod': 'rawOverlap'} DCNL DCSP classifier = KNNClassifier(**params) DCNL DCSP dimensionality = 40 DCNL DCSP a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32) DCNL DCSP b = np.array([2, 4, 8, 12, 14, 18, 20, 28, 30], dtype=np.int32) DCNL DCSP c = np.array([1, 2, 3, 14, 16, 19, 22, 24, 33], dtype=np.int32) DCNL DCSP d = np.array([2, 4, 8, 12, 14, 19, 22, 24, 33], dtype=np.int32) DCNL DCSP denseA = np.zeros(dimensionality) DCNL DCSP denseA[a] = 1.0 DCNL DCSP denseD = np.zeros(dimensionality) DCNL DCSP denseD[d] = 1.0 DCNL DCSP classifier.learn(a, 0, isSparse=dimensionality, partitionId=None) DCNL DCSP classifier.learn(b, 1, isSparse=dimensionality, partitionId=None) DCNL DCSP classifier.learn(c, 2, isSparse=dimensionality, partitionId=211) DCNL DCSP classifier.learn(d, 1, isSparse=dimensionality, partitionId=405) DCNL DCSP (cat, _, _, _) = classifier.infer(denseA, partitionId=405) DCNL DCSP self.assertEquals(cat, 0) DCNL DCSP (cat, _, _, _) = classifier.infer(denseD, partitionId=405) DCNL DCSP self.assertEquals(cat, 2) DCNL DCSP (cat, _, _, _) = classifier.infer(denseD) DCNL DCSP self.assertEquals(cat, 1)
@unittest.skipUnless(__debug__, 'Only DCSP applicable DCSP when DCSP asserts DCSP are DCSP enabled') DCNL def testOverlapDistanceMethodBadSparsity(self): DCNL DCSP params = {'distanceMethod': 'rawOverlap'} DCNL DCSP classifier = KNNClassifier(**params) DCNL DCSP a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32) DCNL DCSP with self.assertRaises(AssertionError): DCNL DCSP  DCSP classifier.learn(a, 0, isSparse=20)
def testOverlapDistanceMethodInconsistentDimensionality(self): DCNL DCSP params = {'distanceMethod': 'rawOverlap'} DCNL DCSP classifier = KNNClassifier(**params) DCNL DCSP dimensionality = 40 DCNL DCSP a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32) DCNL DCSP numPatterns = classifier.learn(a, 0, isSparse=31) DCNL DCSP self.assertEquals(numPatterns, 1) DCNL DCSP denseA = np.zeros(dimensionality) DCNL DCSP denseA[a] = 1.0 DCNL DCSP (cat, _, _, _) = classifier.infer(denseA) DCNL DCSP self.assertEquals(cat, 0)
@unittest.skipUnless(__debug__, 'Only DCSP applicable DCSP when DCSP asserts DCSP are DCSP enabled') DCNL def testOverlapDistanceMethodStandardUnsorted(self): DCNL DCSP params = {'distanceMethod': 'rawOverlap'} DCNL DCSP classifier = KNNClassifier(**params) DCNL DCSP dimensionality = 40 DCNL DCSP a = np.array([29, 3, 7, 11, 13, 17, 19, 23, 1], dtype=np.int32) DCNL DCSP b = np.array([2, 4, 20, 12, 14, 18, 8, 28, 30], dtype=np.int32) DCNL DCSP with self.assertRaises(AssertionError): DCNL DCSP  DCSP classifier.learn(a, 0, isSparse=dimensionality) DCNL DCSP with self.assertRaises(AssertionError): DCNL DCSP  DCSP classifier.learn(b, 1, isSparse=dimensionality)
def testOverlapDistanceMethodEmptyArray(self): DCNL DCSP params = {'distanceMethod': 'rawOverlap'} DCNL DCSP classifier = KNNClassifier(**params) DCNL DCSP dimensionality = 40 DCNL DCSP a = np.array([], dtype=np.int32) DCNL DCSP numPatterns = classifier.learn(a, 0, isSparse=dimensionality) DCNL DCSP self.assertEquals(numPatterns, 1) DCNL DCSP denseA = np.zeros(dimensionality) DCNL DCSP denseA[a] = 1.0 DCNL DCSP (cat, _, _, _) = classifier.infer(denseA) DCNL DCSP self.assertEquals(cat, 0)
@unittest.skipUnless(capnp, 'pycapnp DCSP not DCSP installed') DCNL def testSerializationMiddleOfSequence2(self): DCNL DCSP tm1 = BacktrackingTM(2048, 32, 0.21, 0.5, 11, 20, 0.1, 0.1, 1.0, 0.0, 14, False, 5, 2, False, 1960, 0, False, 3, 10, 5, 0, 32, 128, 32, 'normal') DCNL DCSP tm2 = BacktrackingTM(2048, 32, 0.21, 0.5, 11, 20, 0.1, 0.1, 1.0, 0.0, 14, False, 5, 2, False, 1960, 0, False, 3, 10, 5, 0, 32, 128, 32, 'normal') DCNL DCSP with open(resource_filename(__name__, 'data/tm_input.csv'), 'r') as fin: DCNL DCSP  DCSP reader = csv.reader(fin) DCNL DCSP  DCSP records = [] DCNL DCSP  DCSP for bottomUpInStr in fin: DCNL DCSP  DCSP  DCSP bottomUpIn = numpy.array(eval((('[' + bottomUpInStr.strip()) + ']')), dtype='int32') DCNL DCSP  DCSP  DCSP records.append(bottomUpIn) DCNL DCSP i = 1 DCNL DCSP for r in records[:250]: DCNL DCSP  DCSP print i DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP output1 = tm1.compute(r, True, True) DCNL DCSP  DCSP output2 = tm2.compute(r, True, True) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(output1, output2)) DCNL DCSP print 'Serializing DCSP and DCSP deserializing DCSP models.' DCNL DCSP savePath1 = os.path.join(self._tmpDir, 'tm1.bin') DCNL DCSP tmProto1 = BacktrackingTM.getSchema().new_message() DCNL DCSP tm1.write(tmProto1) DCNL DCSP with open(savePath1, 'wb') as f: DCNL DCSP  DCSP tmProto1.write(f) DCNL DCSP with open(savePath1, 'rb') as f: DCNL DCSP  DCSP tmProto3 = BacktrackingTM.getSchema().read(f) DCNL DCSP tm3 = BacktrackingTM.read(tmProto3) DCNL DCSP savePath2 = os.path.join(self._tmpDir, 'tm2.bin') DCNL DCSP tmProto2 = BacktrackingTM.getSchema().new_message() DCNL DCSP tm2.write(tmProto2) DCNL DCSP with open(savePath2, 'wb') as f: DCNL DCSP  DCSP tmProto2.write(f) DCNL DCSP with open(savePath2, 'rb') as f: DCNL DCSP  DCSP tmProto4 = BacktrackingTM.getSchema().read(f) DCNL DCSP tm4 = BacktrackingTM.read(tmProto4) DCNL DCSP self.assertTMsEqual(tm1, tm3) DCNL DCSP self.assertTMsEqual(tm2, tm4) DCNL DCSP for r in records[250:]: DCNL DCSP  DCSP print i DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP out1 = tm1.compute(r, True, True) DCNL DCSP  DCSP out2 = tm2.compute(r, True, True) DCNL DCSP  DCSP out3 = tm3.compute(r, True, True) DCNL DCSP  DCSP out4 = tm4.compute(r, True, True) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(out1, out2)) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(out1, out3)) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(out1, out4)) DCNL DCSP self.assertTMsEqual(tm1, tm2) DCNL DCSP self.assertTMsEqual(tm1, tm3) DCNL DCSP self.assertTMsEqual(tm2, tm4)
def testCheckpointMiddleOfSequence2(self): DCNL DCSP tm1 = BacktrackingTM(2048, 32, 0.21, 0.5, 11, 20, 0.1, 0.1, 1.0, 0.0, 14, False, 5, 2, False, 1960, 0, False, 3, 10, 5, 0, 32, 128, 32, 'normal') DCNL DCSP tm2 = BacktrackingTM(2048, 32, 0.21, 0.5, 11, 20, 0.1, 0.1, 1.0, 0.0, 14, False, 5, 2, False, 1960, 0, False, 3, 10, 5, 0, 32, 128, 32, 'normal') DCNL DCSP with open(resource_filename(__name__, 'data/tm_input.csv'), 'r') as fin: DCNL DCSP  DCSP reader = csv.reader(fin) DCNL DCSP  DCSP records = [] DCNL DCSP  DCSP for bottomUpInStr in fin: DCNL DCSP  DCSP  DCSP bottomUpIn = numpy.array(eval((('[' + bottomUpInStr.strip()) + ']')), dtype='int32') DCNL DCSP  DCSP  DCSP records.append(bottomUpIn) DCNL DCSP i = 1 DCNL DCSP for r in records[:250]: DCNL DCSP  DCSP print i DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP output1 = tm1.compute(r, True, True) DCNL DCSP  DCSP output2 = tm2.compute(r, True, True) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(output1, output2)) DCNL DCSP print 'Serializing DCSP and DCSP deserializing DCSP models.' DCNL DCSP savePath1 = os.path.join(self._tmpDir, 'tm1.bin') DCNL DCSP tm1.saveToFile(savePath1) DCNL DCSP tm3 = pickle.loads(pickle.dumps(tm1)) DCNL DCSP tm3.loadFromFile(savePath1) DCNL DCSP savePath2 = os.path.join(self._tmpDir, 'tm2.bin') DCNL DCSP tm2.saveToFile(savePath2) DCNL DCSP tm4 = pickle.loads(pickle.dumps(tm2)) DCNL DCSP tm4.loadFromFile(savePath2) DCNL DCSP self.assertTMsEqual(tm1, tm3) DCNL DCSP self.assertTMsEqual(tm2, tm4) DCNL DCSP for r in records[250:]: DCNL DCSP  DCSP print i DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP out1 = tm1.compute(r, True, True) DCNL DCSP  DCSP out2 = tm2.compute(r, True, True) DCNL DCSP  DCSP out3 = tm3.compute(r, True, True) DCNL DCSP  DCSP out4 = tm4.compute(r, True, True) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(out1, out2)) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(out1, out3)) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(out1, out4)) DCNL DCSP self.assertTMsEqual(tm1, tm2) DCNL DCSP self.assertTMsEqual(tm1, tm3) DCNL DCSP self.assertTMsEqual(tm2, tm4)
def assertTMsEqual(self, tm1, tm2): DCNL DCSP self.assertEqual(tm1, tm2, tm1.diff(tm2)) DCNL DCSP self.assertTrue(fdrutilities.tmDiff2(tm1, tm2, 1, False))
@staticmethod DCNL def generateSequence(n=10, numCols=100, minOnes=21, maxOnes=25): DCNL DCSP return ([None] + [BacktrackingTMTest.generatePattern(numCols, minOnes, maxOnes) for _ in xrange(n)])
@staticmethod DCNL def generatePattern(numCols=100, minOnes=21, maxOnes=25): DCNL DCSP assert (minOnes < maxOnes) DCNL DCSP assert (maxOnes < numCols) DCNL DCSP nOnes = random.randint(minOnes, maxOnes) DCNL DCSP ind = random.sample(xrange(numCols), nOnes) DCNL DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP x[ind] = 1 DCNL DCSP return x
def setUp(self): DCNL DCSP self.inputSize = 90 DCNL DCSP self.columnDimensions = 600 DCNL DCSP self.x = numpy.zeros((5, self.inputSize), dtype=uintType) DCNL DCSP self.x[0, 0:20] = 1 DCNL DCSP self.x[1, 10:30] = 1 DCNL DCSP self.x[2, 30:50] = 1 DCNL DCSP self.x[3, 50:70] = 1 DCNL DCSP self.x[4, 70:90] = 1 DCNL DCSP self.winningIteration = numpy.zeros(self.columnDimensions) DCNL DCSP self.lastSDR = {} DCNL DCSP self.spImplementation = 'None' DCNL DCSP self.sp = None DCNL DCSP self.params = {'inputDimensions': [self.inputSize], 'columnDimensions': [self.columnDimensions], 'potentialRadius': self.inputSize, 'potentialPct': 0.9, 'globalInhibition': True, 'numActiveColumnsPerInhArea': 60, 'synPermActiveInc': 0.0, 'synPermInactiveDec': 0.0, 'dutyCyclePeriod': 10, 'boostStrength': 10.0, 'seed': SEED} DCNL DCSP print 'SP DCSP seed DCSP set DCSP to:', self.params['seed']
def debugPrint(self): DCNL DCSP activeDutyCycle = numpy.zeros(self.columnDimensions, dtype=GetNTAReal()) DCNL DCSP self.sp.getActiveDutyCycles(activeDutyCycle) DCNL DCSP boost = numpy.zeros(self.columnDimensions, dtype=GetNTAReal()) DCNL DCSP self.sp.getBoostFactors(boost) DCNL DCSP print '\n--------- DCSP ITERATION', self.sp.getIterationNum(), '-----------------------' DCNL DCSP print 'SP DCSP implementation:', self.spImplementation DCNL DCSP print 'Learning DCSP iteration:', DCNL DCSP print 'Max/min DCSP active DCSP duty DCSP cycle:', (activeDutyCycle.max(), activeDutyCycle.min()) DCNL DCSP print 'Average DCSP non-zero DCSP active DCSP duty DCSP cycle:', activeDutyCycle[(activeDutyCycle > 0)].mean() DCNL DCSP print 'Active DCSP duty DCSP cycle', activeDutyCycle DCNL DCSP print DCNL DCSP print 'Boost DCSP factor DCSP for DCSP sp:', boost DCNL DCSP print DCNL DCSP print 'Last DCSP winning DCSP iteration DCSP for DCSP each DCSP column' DCNL DCSP print self.winningIteration DCNL DCSP print 'Number DCSP of DCSP columns DCSP that DCSP have DCSP won DCSP at DCSP some DCSP point:', (self.columnDimensions - (self.winningIteration == 0).sum())
def verifySDRProperties(self): DCNL DCSP self.assertTrue(_areAllSDRsUnique(self.lastSDR), "All DCSP SDR's DCSP are DCSP not DCSP unique") DCNL DCSP self.assertGreater(_computeOverlap(self.lastSDR[0], self.lastSDR[1]), 9, "First DCSP two DCSP SDR's DCSP don't DCSP overlap DCSP much") DCNL DCSP for i in [2, 3, 4]: DCNL DCSP  DCSP for j in range(5): DCNL DCSP  DCSP  DCSP if (i != j): DCNL DCSP  DCSP  DCSP  DCSP self.assertLess(_computeOverlap(self.lastSDR[i], self.lastSDR[j]), 18, 'One DCSP of DCSP the DCSP last DCSP three DCSP SDRs DCSP has DCSP high DCSP overlap')
def boostTestLoop(self, imp): DCNL DCSP self.sp = CreateSP(imp, self.params) DCNL DCSP self.spImplementation = imp DCNL DCSP self.winningIteration.fill(0) DCNL DCSP self.lastSDR = {} DCNL DCSP self.boostTestPhase1() DCNL DCSP self.boostTestPhase2() DCNL DCSP self.boostTestPhase3() DCNL DCSP self.boostTestPhase4()
@unittest.skip("Currently DCSP fails DCSP due DCSP to DCSP switch DCSP from DCSP FDRCSpatial2 DCSP to DCSP SpatialPooler.The DCSP new DCSP SP DCSP doesn't DCSP have DCSP explicit DCSP methods DCSP to DCSP get DCSP inhibition.") DCNL def testInhibition(self): DCNL DCSP n = 100 DCNL DCSP w = 15 DCNL DCSP inputLen = 300 DCNL DCSP columnDimensions = 2048 DCNL DCSP numActiveColumnsPerInhArea = 40 DCNL DCSP stimulusThreshold = 0 DCNL DCSP spSeed = 1956 DCNL DCSP stimulusThresholdInh = 1e-05 DCNL DCSP kDutyCycleFactor = 0.01 DCNL DCSP spVerbosity = 0 DCNL DCSP testIter = 100 DCNL DCSP spTest = SpatialPooler(columnDimensions=(columnDimensions, 1), inputDimensions=(1, inputLen), potentialRadius=(inputLen / 2), numActiveColumnsPerInhArea=numActiveColumnsPerInhArea, spVerbosity=spVerbosity, stimulusThreshold=stimulusThreshold, seed=spSeed) DCNL DCSP initialPermanence = spTest._initialPermanence() DCNL DCSP (spTest._masterPotentialM, spTest._masterPermanenceM) = spTest._makeMasterCoincidences(spTest.numCloneMasters, spTest._coincRFShape, spTest.potentialPct, initialPermanence, spTest.random) DCNL DCSP spTest._updateInhibitionObj() DCNL DCSP boostFactors = numpy.ones(columnDimensions) DCNL DCSP for i in range(testIter): DCNL DCSP  DCSP spTest._iterNum = i DCNL DCSP  DCSP input_ = numpy.zeros((1, inputLen)) DCNL DCSP  DCSP nonzero = numpy.random.random(inputLen) DCNL DCSP  DCSP input_[0][numpy.where((nonzero < (float(w) / float(n))))] = 1 DCNL DCSP  DCSP spTest._computeOverlapsFP(input_, stimulusThreshold=spTest.stimulusThreshold) DCNL DCSP  DCSP spTest._overlaps *= boostFactors DCNL DCSP  DCSP onCellIndices = numpy.where((spTest._overlaps > 0)) DCNL DCSP  DCSP spTest._onCells.fill(0) DCNL DCSP  DCSP spTest._onCells[onCellIndices] = 1 DCNL DCSP  DCSP denseOn = spTest._onCells DCNL DCSP  DCSP spTest.dutyCyclePeriod = min((i + 1), 1000) DCNL DCSP  DCSP spTest._dutyCycleBeforeInh = ((((spTest.dutyCyclePeriod - 1) * spTest._dutyCycleBeforeInh) + denseOn) / spTest.dutyCyclePeriod) DCNL DCSP  DCSP dutyCycleTieBreaker = spTest._dutyCycleAfterInh.copy() DCNL DCSP  DCSP dutyCycleTieBreaker *= kDutyCycleFactor DCNL DCSP  DCSP numOn = spTest._inhibitionObj.compute((spTest._overlaps + dutyCycleTieBreaker), spTest._onCellIndices, stimulusThresholdInh, (max(spTest._overlaps) / 1000)) DCNL DCSP  DCSP spTest._onCells.fill(0) DCNL DCSP  DCSP onCellIndices = spTest._onCellIndices[0:numOn] DCNL DCSP  DCSP spTest._onCells[onCellIndices] = 1 DCNL DCSP  DCSP denseOn = spTest._onCells DCNL DCSP  DCSP spTest._dutyCycleAfterInh = ((((spTest.dutyCyclePeriod - 1) * spTest._dutyCycleAfterInh) + denseOn) / spTest.dutyCyclePeriod) DCNL DCSP  DCSP spTest._adaptSynapses(onCellIndices, [], input_) DCNL DCSP  DCSP spTest._updateBoostFactors() DCNL DCSP  DCSP boostFactors = spTest._firingBoostFactors DCNL DCSP  DCSP if (((spTest._iterNum + 1) % 50) == 0): DCNL DCSP  DCSP  DCSP spTest._updateInhibitionObj() DCNL DCSP  DCSP  DCSP spTest._updateMinDutyCycles(spTest._dutyCycleBeforeInh, spTest.minPctDutyCycleBeforeInh, spTest._minDutyCycleBeforeInh) DCNL DCSP  DCSP  DCSP spTest._updateMinDutyCycles(spTest._dutyCycleAfterInh, spTest.minPctDutyCycleAfterInh, spTest._minDutyCycleAfterInh) DCNL DCSP  DCSP self.assertEqual(numOn, spTest.numActiveColumnsPerInhArea, ('Error DCSP at DCSP input DCSP %s, DCSP actual DCSP numOn DCSP are: DCSP %i, DCSP numActivePerInhAre DCSP is: DCSP %s' % (i, numOn, numActiveColumnsPerInhArea)))
def basicTest(self): DCNL DCSP tm = BacktrackingTMCPP(numberOfCols=10, cellsPerColumn=3, initialPerm=0.2, connectedPerm=0.8, minThreshold=2, newSynapseCount=5, permanenceInc=0.1, permanenceDec=0.05, permanenceMax=1, globalDecay=0.05, activationThreshold=4, doPooling=False, segUpdateValidDuration=5, seed=SEED, verbosity=VERBOSITY) DCNL DCSP tm.retrieveLearningStates = True DCNL DCSP tm.makeCells4Ephemeral = False DCNL DCSP pickle.dump(tm, open('test_tm_cpp.pkl', 'wb')) DCNL DCSP tm2 = pickle.load(open('test_tm_cpp.pkl')) DCNL DCSP self.assertTrue(fdrutils.tmDiff2(tm, tm2, VERBOSITY, checkStates=False)) DCNL DCSP for i in xrange(5): DCNL DCSP  DCSP x = numpy.zeros(tm.numberOfCols, dtype='uint32') DCNL DCSP  DCSP _RGEN.initializeUInt32Array(x, 2) DCNL DCSP  DCSP tm.learn(x) DCNL DCSP tm.reset() DCNL DCSP tm.makeCells4Ephemeral = False DCNL DCSP pickle.dump(tm, open('test_tm_cpp.pkl', 'wb')) DCNL DCSP tm2 = pickle.load(open('test_tm_cpp.pkl')) DCNL DCSP self.assertTrue(fdrutils.tmDiff2(tm, tm2, VERBOSITY)) DCNL DCSP patterns = numpy.zeros((4, tm.numberOfCols), dtype='uint32') DCNL DCSP for i in xrange(4): DCNL DCSP  DCSP _RGEN.initializeUInt32Array(patterns[i], 2) DCNL DCSP for i in xrange(10): DCNL DCSP  DCSP x = numpy.zeros(tm.numberOfCols, dtype='uint32') DCNL DCSP  DCSP _RGEN.initializeUInt32Array(x, 2) DCNL DCSP  DCSP tm.infer(x) DCNL DCSP  DCSP if (i > 0): DCNL DCSP  DCSP  DCSP tm._checkPrediction(patterns)
def basicTest2(self, tm, numPatterns=100, numRepetitions=3, activity=15, testTrimming=False, testRebuild=False): DCNL DCSP tmPy = BacktrackingTM(numberOfCols=tm.numberOfCols, cellsPerColumn=tm.cellsPerColumn, initialPerm=tm.initialPerm, connectedPerm=tm.connectedPerm, minThreshold=tm.minThreshold, newSynapseCount=tm.newSynapseCount, permanenceInc=tm.permanenceInc, permanenceDec=tm.permanenceDec, permanenceMax=tm.permanenceMax, globalDecay=tm.globalDecay, activationThreshold=tm.activationThreshold, doPooling=tm.doPooling, segUpdateValidDuration=tm.segUpdateValidDuration, pamLength=tm.pamLength, maxAge=tm.maxAge, maxSeqLength=tm.maxSeqLength, maxSegmentsPerCell=tm.maxSegmentsPerCell, maxSynapsesPerSegment=tm.maxSynapsesPerSegment, seed=tm.seed, verbosity=tm.verbosity) DCNL DCSP tm.retrieveLearningStates = True DCNL DCSP verbosity = VERBOSITY DCNL DCSP sequence = fdrutils.generateCoincMatrix(nCoinc=numPatterns, length=tm.numberOfCols, activity=activity) DCNL DCSP for r in xrange(numRepetitions): DCNL DCSP  DCSP for i in xrange(sequence.nRows()): DCNL DCSP  DCSP  DCSP if ((i % 10) == 0): DCNL DCSP  DCSP  DCSP  DCSP tm.reset() DCNL DCSP  DCSP  DCSP  DCSP tmPy.reset() DCNL DCSP  DCSP  DCSP if (verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP print '\n\n DCSP  DCSP  DCSP  DCSP ===================================\nPattern:', DCNL DCSP  DCSP  DCSP  DCSP print i, 'Round:', r, 'input:', sequence.getRow(i) DCNL DCSP  DCSP  DCSP y1 = tm.learn(sequence.getRow(i)) DCNL DCSP  DCSP  DCSP y2 = tmPy.learn(sequence.getRow(i)) DCNL DCSP  DCSP  DCSP if testRebuild: DCNL DCSP  DCSP  DCSP  DCSP tm.cells4.rebuildOutSynapses() DCNL DCSP  DCSP  DCSP if testTrimming: DCNL DCSP  DCSP  DCSP  DCSP tm.trimSegments() DCNL DCSP  DCSP  DCSP  DCSP tmPy.trimSegments() DCNL DCSP  DCSP  DCSP if (verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP print '\n DCSP  DCSP  DCSP ------ DCSP  DCSP CPP DCSP states DCSP  DCSP ------ DCSP ', DCNL DCSP  DCSP  DCSP  DCSP tm.printStates() DCNL DCSP  DCSP  DCSP  DCSP print '\n DCSP  DCSP  DCSP ------ DCSP  DCSP PY DCSP states DCSP  DCSP ------ DCSP ', DCNL DCSP  DCSP  DCSP  DCSP tmPy.printStates() DCNL DCSP  DCSP  DCSP  DCSP if (verbosity > 6): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'C++ DCSP cells: DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP tm.printCells() DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'PY DCSP cells: DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP tmPy.printCells() DCNL DCSP  DCSP  DCSP if (verbosity >= 3): DCNL DCSP  DCSP  DCSP  DCSP print 'Num DCSP segments DCSP in DCSP PY DCSP and DCSP C++', tmPy.getNumSegments(), tm.getNumSegments() DCNL DCSP  DCSP  DCSP self.assertTrue(fdrutils.tmDiff2(tm, tmPy, verbosity, False)) DCNL DCSP  DCSP  DCSP self.assertLess(abs((y1 - y2).sum()), 3) DCNL DCSP print 'Learning DCSP completed' DCNL DCSP self.assertTrue(fdrutils.tmDiff2(tm, tmPy, verbosity)) DCNL DCSP print 'Rebuilding DCSP outSynapses' DCNL DCSP tm.cells4.rebuildOutSynapses() DCNL DCSP self.assertTrue(fdrutils.tmDiff2(tm, tmPy, VERBOSITY)) DCNL DCSP print 'Trimming DCSP segments' DCNL DCSP tm.trimSegments() DCNL DCSP tmPy.trimSegments() DCNL DCSP self.assertTrue(fdrutils.tmDiff2(tm, tmPy, VERBOSITY)) DCNL DCSP print 'Pickling DCSP and DCSP unpickling' DCNL DCSP tm.makeCells4Ephemeral = False DCNL DCSP pickle.dump(tm, open('test_tm_cpp.pkl', 'wb')) DCNL DCSP tm2 = pickle.load(open('test_tm_cpp.pkl')) DCNL DCSP self.assertTrue(fdrutils.tmDiff2(tm, tm2, VERBOSITY, checkStates=False)) DCNL DCSP print 'Testing DCSP inference' DCNL DCSP tm.reset() DCNL DCSP tmPy.reset() DCNL DCSP setVerbosity(INFERENCE_VERBOSITY, tm, tmPy) DCNL DCSP patterns = numpy.zeros((40, tm.numberOfCols), dtype='uint32') DCNL DCSP for i in xrange(4): DCNL DCSP  DCSP _RGEN.initializeUInt32Array(patterns[i], 2) DCNL DCSP for (i, x) in enumerate(patterns): DCNL DCSP  DCSP x = numpy.zeros(tm.numberOfCols, dtype='uint32') DCNL DCSP  DCSP _RGEN.initializeUInt32Array(x, 2) DCNL DCSP  DCSP y = tm.infer(x) DCNL DCSP  DCSP yPy = tmPy.infer(x) DCNL DCSP  DCSP self.assertTrue(fdrutils.tmDiff2(tm, tmPy, VERBOSITY, checkLearn=False)) DCNL DCSP  DCSP if (abs((y - yPy).sum()) > 0): DCNL DCSP  DCSP  DCSP print 'C++ DCSP output', y DCNL DCSP  DCSP  DCSP print 'Py DCSP output', yPy DCNL DCSP  DCSP  DCSP assert False DCNL DCSP  DCSP if (i > 0): DCNL DCSP  DCSP  DCSP tm._checkPrediction(patterns) DCNL DCSP  DCSP  DCSP tmPy._checkPrediction(patterns) DCNL DCSP print 'Inference DCSP completed' DCNL DCSP print '====================================' DCNL DCSP return (tm, tmPy)
def testTMs(self, short=True): DCNL DCSP if (short == True): DCNL DCSP  DCSP print 'Testing DCSP short DCSP version' DCNL DCSP else: DCNL DCSP  DCSP print 'Testing DCSP long DCSP version' DCNL DCSP if short: DCNL DCSP  DCSP print '\nTesting DCSP with DCSP fixed DCSP resource DCSP CLA DCSP - DCSP test DCSP max DCSP segment DCSP and DCSP synapses' DCNL DCSP  DCSP tm = BacktrackingTMCPP(numberOfCols=30, cellsPerColumn=5, initialPerm=0.5, connectedPerm=0.5, permanenceMax=1, minThreshold=8, newSynapseCount=10, permanenceInc=0.1, permanenceDec=0.01, globalDecay=0.0, activationThreshold=8, doPooling=False, segUpdateValidDuration=5, seed=SEED, verbosity=VERBOSITY, maxAge=0, maxSegmentsPerCell=2, maxSynapsesPerSegment=10, checkSynapseConsistency=True) DCNL DCSP  DCSP tm.cells4.setCellSegmentOrder(True) DCNL DCSP  DCSP self.basicTest2(tm, numPatterns=15, numRepetitions=1) DCNL DCSP if (not short): DCNL DCSP  DCSP print '\nTesting DCSP with DCSP fixed DCSP resource DCSP CLA DCSP - DCSP test DCSP max DCSP segment DCSP and DCSP synapses' DCNL DCSP  DCSP tm = BacktrackingTMCPP(numberOfCols=30, cellsPerColumn=5, initialPerm=0.5, connectedPerm=0.5, permanenceMax=1, minThreshold=8, newSynapseCount=10, permanenceInc=0.1, permanenceDec=0.01, globalDecay=0.0, activationThreshold=8, doPooling=False, segUpdateValidDuration=5, seed=SEED, verbosity=VERBOSITY, maxAge=0, maxSegmentsPerCell=2, maxSynapsesPerSegment=10, checkSynapseConsistency=True) DCNL DCSP  DCSP tm.cells4.setCellSegmentOrder(1) DCNL DCSP  DCSP self.basicTest2(tm, numPatterns=30, numRepetitions=2) DCNL DCSP  DCSP print '\nTesting DCSP with DCSP permanenceInc DCSP = DCSP 0 DCSP and DCSP Dec DCSP = DCSP 0' DCNL DCSP  DCSP tm = BacktrackingTMCPP(numberOfCols=30, cellsPerColumn=5, initialPerm=0.5, connectedPerm=0.5, minThreshold=3, newSynapseCount=3, permanenceInc=0.0, permanenceDec=0.0, permanenceMax=1, globalDecay=0.0, activationThreshold=3, doPooling=False, segUpdateValidDuration=5, seed=SEED, verbosity=VERBOSITY, checkSynapseConsistency=False) DCNL DCSP  DCSP tm.printParameters() DCNL DCSP  DCSP self.basicTest2(tm, numPatterns=30, numRepetitions=3) DCNL DCSP  DCSP print 'Testing DCSP with DCSP permanenceInc DCSP = DCSP 0 DCSP and DCSP Dec DCSP = DCSP 0 DCSP and DCSP 1 DCSP cell DCSP per DCSP column' DCNL DCSP  DCSP tm = BacktrackingTMCPP(numberOfCols=30, cellsPerColumn=1, initialPerm=0.5, connectedPerm=0.5, minThreshold=3, newSynapseCount=3, permanenceInc=0.0, permanenceDec=0.0, permanenceMax=1, globalDecay=0.0, activationThreshold=3, doPooling=False, segUpdateValidDuration=5, seed=SEED, verbosity=VERBOSITY, checkSynapseConsistency=False) DCNL DCSP  DCSP self.basicTest2(tm) DCNL DCSP  DCSP print 'Testing DCSP with DCSP permanenceInc DCSP = DCSP 0.1 DCSP and DCSP Dec DCSP = DCSP .0' DCNL DCSP  DCSP tm = BacktrackingTMCPP(numberOfCols=30, cellsPerColumn=5, initialPerm=0.5, connectedPerm=0.5, minThreshold=3, newSynapseCount=3, permanenceInc=0.1, permanenceDec=0.0, permanenceMax=1, globalDecay=0.0, activationThreshold=3, doPooling=False, segUpdateValidDuration=5, seed=SEED, verbosity=VERBOSITY, checkSynapseConsistency=False) DCNL DCSP  DCSP self.basicTest2(tm) DCNL DCSP  DCSP print 'Testing DCSP with DCSP permanenceInc DCSP = DCSP 0.1, DCSP Dec DCSP = DCSP .01 DCSP and DCSP higher DCSP synapse DCSP count' DCNL DCSP  DCSP tm = BacktrackingTMCPP(numberOfCols=30, cellsPerColumn=2, initialPerm=0.5, connectedPerm=0.5, minThreshold=3, newSynapseCount=5, permanenceInc=0.1, permanenceDec=0.01, permanenceMax=1, globalDecay=0.0, activationThreshold=3, doPooling=False, segUpdateValidDuration=5, seed=SEED, verbosity=VERBOSITY, checkSynapseConsistency=True) DCNL DCSP  DCSP self.basicTest2(tm, numPatterns=10, numRepetitions=2) DCNL DCSP  DCSP print 'Testing DCSP age DCSP based DCSP global DCSP decay' DCNL DCSP  DCSP tm = BacktrackingTMCPP(numberOfCols=30, cellsPerColumn=5, initialPerm=0.4, connectedPerm=0.5, minThreshold=3, newSynapseCount=3, permanenceInc=0.1, permanenceDec=0.1, permanenceMax=1, globalDecay=0.25, activationThreshold=3, doPooling=False, segUpdateValidDuration=5, pamLength=2, maxAge=20, seed=SEED, verbosity=VERBOSITY, checkSynapseConsistency=True) DCNL DCSP  DCSP tm.cells4.setCellSegmentOrder(1) DCNL DCSP  DCSP self.basicTest2(tm) DCNL DCSP  DCSP print '\nTesting DCSP with DCSP fixed DCSP size DCSP CLA, DCSP max DCSP segments DCSP per DCSP cell' DCNL DCSP  DCSP tm = BacktrackingTMCPP(numberOfCols=30, cellsPerColumn=5, initialPerm=0.5, connectedPerm=0.5, permanenceMax=1, minThreshold=8, newSynapseCount=10, permanenceInc=0.1, permanenceDec=0.01, globalDecay=0.0, activationThreshold=8, doPooling=False, segUpdateValidDuration=5, seed=SEED, verbosity=VERBOSITY, maxAge=0, maxSegmentsPerCell=2, maxSynapsesPerSegment=100, checkSynapseConsistency=True) DCNL DCSP  DCSP tm.cells4.setCellSegmentOrder(1) DCNL DCSP  DCSP self.basicTest2(tm, numPatterns=30, numRepetitions=2)
def testActiveSegmentGrowSynapsesAccordingToPotentialOverlap(self): DCNL DCSP tm = TemporalMemory(columnDimensions=[32], cellsPerColumn=1, activationThreshold=2, initialPermanence=0.21, connectedPermanence=0.5, minThreshold=1, maxNewSynapseCount=4, permanenceIncrement=0.1, permanenceDecrement=0.1, predictedSegmentDecrement=0.0, seed=42) DCNL DCSP previousActiveColumns = [0, 1, 2, 3, 4] DCNL DCSP prevWinnerCells = [0, 1, 2, 3, 4] DCNL DCSP activeColumns = [5] DCNL DCSP activeSegment = tm.createSegment(5) DCNL DCSP tm.connections.createSynapse(activeSegment, 0, 0.5) DCNL DCSP tm.connections.createSynapse(activeSegment, 1, 0.5) DCNL DCSP tm.connections.createSynapse(activeSegment, 2, 0.2) DCNL DCSP tm.compute(previousActiveColumns, True) DCNL DCSP self.assertEqual(prevWinnerCells, tm.getWinnerCells()) DCNL DCSP tm.compute(activeColumns, True) DCNL DCSP presynapticCells = set((synapse.presynapticCell for synapse in tm.connections.synapsesForSegment(activeSegment))) DCNL DCSP self.assertTrue(((presynapticCells == set([0, 1, 2, 3])) or (presynapticCells == set([0, 1, 2, 4]))))
def testDestroySegmentsThenReachLimit(self): DCNL DCSP tm = TemporalMemory(columnDimensions=[32], cellsPerColumn=1, activationThreshold=3, initialPermanence=0.5, connectedPermanence=0.5, minThreshold=2, maxNewSynapseCount=3, permanenceIncrement=0.02, permanenceDecrement=0.02, predictedSegmentDecrement=0.0, seed=42, maxSegmentsPerCell=2) DCNL DCSP segment1 = tm.createSegment(11) DCNL DCSP segment2 = tm.createSegment(11) DCNL DCSP self.assertEqual(2, tm.connections.numSegments()) DCNL DCSP tm.connections.destroySegment(segment1) DCNL DCSP tm.connections.destroySegment(segment2) DCNL DCSP self.assertEqual(0, tm.connections.numSegments()) DCNL DCSP tm.createSegment(11) DCNL DCSP self.assertEqual(1, tm.connections.numSegments()) DCNL DCSP tm.createSegment(11) DCNL DCSP self.assertEqual(2, tm.connections.numSegments()) DCNL DCSP segment3 = tm.createSegment(11) DCNL DCSP self.assertEqual(2, tm.connections.numSegments(11)) DCNL DCSP self.assertEqual(2, tm.connections.numSegments())
def testReachSegmentLimitMultipleTimes(self): DCNL DCSP tm = TemporalMemory(columnDimensions=[32], cellsPerColumn=1, activationThreshold=3, initialPermanence=0.5, connectedPermanence=0.5, minThreshold=2, maxNewSynapseCount=3, permanenceIncrement=0.02, permanenceDecrement=0.02, predictedSegmentDecrement=0.0, seed=42, maxSegmentsPerCell=2) DCNL DCSP tm.createSegment(10) DCNL DCSP self.assertEqual(1, tm.connections.numSegments()) DCNL DCSP tm.createSegment(10) DCNL DCSP self.assertEqual(2, tm.connections.numSegments()) DCNL DCSP tm.createSegment(10) DCNL DCSP self.assertEqual(2, tm.connections.numSegments()) DCNL DCSP tm.createSegment(10) DCNL DCSP self.assertEqual(2, tm.connections.numSegments())
def testParamterError(self): DCNL DCSP try: DCNL DCSP  DCSP anomalyLikelihoodRegion = AnomalyLikelihoodRegion(estimationSamples=100, historicWindowSize=99) DCNL DCSP  DCSP self.assertEqual(False, True, 'Should DCSP have DCSP failed DCSP with DCSP ValueError') DCNL DCSP except ValueError: DCNL DCSP  DCSP pass
def testLikelihoodValues(self): DCNL DCSP anomalyLikelihoodRegion = AnomalyLikelihoodRegion() DCNL DCSP anomalyLikelihood = AnomalyLikelihood() DCNL DCSP inputs = AnomalyLikelihoodRegion.getSpec()['inputs'] DCNL DCSP outputs = AnomalyLikelihoodRegion.getSpec()['outputs'] DCNL DCSP with open(_INPUT_DATA_FILE) as f: DCNL DCSP  DCSP reader = csv.reader(f) DCNL DCSP  DCSP reader.next() DCNL DCSP  DCSP for record in reader: DCNL DCSP  DCSP  DCSP consumption = float(record[1]) DCNL DCSP  DCSP  DCSP anomalyScore = float(record[2]) DCNL DCSP  DCSP  DCSP likelihood1 = anomalyLikelihood.anomalyProbability(consumption, anomalyScore) DCNL DCSP  DCSP  DCSP inputs['rawAnomalyScore'] = numpy.array([anomalyScore]) DCNL DCSP  DCSP  DCSP inputs['metricValue'] = numpy.array([consumption]) DCNL DCSP  DCSP  DCSP anomalyLikelihoodRegion.compute(inputs, outputs) DCNL DCSP  DCSP  DCSP likelihood2 = outputs['anomalyLikelihood'][0] DCNL DCSP  DCSP  DCSP self.assertEqual(likelihood1, likelihood2)
@unittest.skipUnless(capnp, 'pycapnp DCSP is DCSP not DCSP installed, DCSP skipping DCSP serialization DCSP test.') DCNL def testSerialization(self): DCNL DCSP anomalyLikelihoodRegion1 = AnomalyLikelihoodRegion() DCNL DCSP inputs = AnomalyLikelihoodRegion.getSpec()['inputs'] DCNL DCSP outputs = AnomalyLikelihoodRegion.getSpec()['outputs'] DCNL DCSP for _ in xrange(0, 6): DCNL DCSP  DCSP inputs['rawAnomalyScore'] = numpy.array([random.random()]) DCNL DCSP  DCSP inputs['metricValue'] = numpy.array([random.random()]) DCNL DCSP  DCSP anomalyLikelihoodRegion1.compute(inputs, outputs) DCNL DCSP  DCSP score1 = outputs['anomalyLikelihood'][0] DCNL DCSP proto1 = AnomalyLikelihoodRegionProto.new_message() DCNL DCSP anomalyLikelihoodRegion1.write(proto1) DCNL DCSP with tempfile.TemporaryFile() as f: DCNL DCSP  DCSP proto1.write(f) DCNL DCSP  DCSP f.seek(0) DCNL DCSP  DCSP proto2 = AnomalyLikelihoodRegionProto.read(f) DCNL DCSP anomalyLikelihoodRegion2 = AnomalyLikelihoodRegion.read(proto2) DCNL DCSP self.assertEqual(anomalyLikelihoodRegion1, anomalyLikelihoodRegion2) DCNL DCSP for _ in xrange(6, 500): DCNL DCSP  DCSP inputs['rawAnomalyScore'] = numpy.array([random.random()]) DCNL DCSP  DCSP inputs['metricValue'] = numpy.array([random.random()]) DCNL DCSP  DCSP anomalyLikelihoodRegion1.compute(inputs, outputs) DCNL DCSP  DCSP score1 = outputs['anomalyLikelihood'][0] DCNL DCSP  DCSP anomalyLikelihoodRegion2.compute(inputs, outputs) DCNL DCSP  DCSP score2 = outputs['anomalyLikelihood'][0] DCNL DCSP  DCSP self.assertEqual(score1, score2)
@patch.object(KNNAnomalyClassifierRegion, '_constructClassificationRecord') DCNL def testSetGetWaitRecordsRecalculate(self, getRecord): DCNL DCSP self.helper.cacheSize = 5 DCNL DCSP self.helper.anomalyThreshold = 0.8 DCNL DCSP self.helper._anomalyVectorLength = 20 DCNL DCSP records = [Mock(ROWID=10, anomalyLabel=['Test'], anomalyScore=1, setByUser=False, anomalyVector=numpy.array([1, 4])), Mock(ROWID=11, anomalyLabel=['Test'], anomalyScore=0, setByUser=False, anomalyVector=numpy.array([1, 2])), Mock(ROWID=12, anomalyLabel=['Test'], anomalyScore=0, setByUser=False, anomalyVector=numpy.array([1, 4])), Mock(ROWID=13, anomalyLabel=['Test'], anomalyScore=0, setByUser=False, anomalyVector=numpy.array([1, 2, 6, 7])), Mock(ROWID=14, anomalyLabel=['Test'], anomalyScore=1, setByUser=False, anomalyVector=numpy.array([1, 10])), Mock(ROWID=15, anomalyLabel=['Test'], anomalyScore=0, setByUser=False, anomalyVector=numpy.array([1, 3])), Mock(ROWID=16, anomalyLabel=['Test'], anomalyScore=0, setByUser=False, anomalyVector=numpy.array([1, 4])), Mock(ROWID=17, anomalyLabel=['Test'], anomalyScore=0, setByUser=False, anomalyVector=numpy.array([10])), Mock(ROWID=18, anomalyLabel=['Test'], anomalyScore=0, setByUser=False, anomalyVector=numpy.array([1, 4]))] DCNL DCSP getRecord.side_effect = records DCNL DCSP for i in records: DCNL DCSP  DCSP self.helper.compute(dict(), dict()) DCNL DCSP self.assertEqual(self.helper._knnclassifier._knn._numPatterns, 6) DCNL DCSP self.assertEqual(self.helper._knnclassifier.getParameter('categoryRecencyList'), [10, 12, 14, 16, 17, 18], 'Classifier DCSP incorrectly DCSP classified DCSP test DCSP records.') DCNL DCSP self.helper.setParameter('trainRecords', None, 14) DCNL DCSP self.assertEqual(self.helper._knnclassifier._knn._numPatterns, 2) DCNL DCSP self.assertEqual(self.helper._knnclassifier.getParameter('categoryRecencyList'), [14, 17], 'Classifier DCSP incorrectly DCSP reclassified DCSP test DCSP records DCSP after DCSP setting DCSP trainRecords')
def testScalarEncoder(self): DCNL DCSP mv = ScalarEncoder(name='mv', n=14, w=3, minval=1, maxval=8, periodic=False, forced=True) DCNL DCSP empty = mv.encode(SENTINEL_VALUE_FOR_MISSING_DATA) DCNL DCSP self.assertEqual(empty.sum(), 0)
def testNaNs(self): DCNL DCSP mv = ScalarEncoder(name='mv', n=14, w=3, minval=1, maxval=8, periodic=False, forced=True) DCNL DCSP empty = mv.encode(float('nan')) DCNL DCSP self.assertEqual(empty.sum(), 0)
def testBottomUpEncodingPeriodicEncoder(self): DCNL DCSP l = ScalarEncoder(n=14, w=3, minval=1, maxval=8, periodic=True, forced=True) DCNL DCSP self.assertEqual(l.getDescription(), [('[1:8]', 0)]) DCNL DCSP l = ScalarEncoder(name='scalar', n=14, w=3, minval=1, maxval=8, periodic=True, forced=True) DCNL DCSP self.assertEqual(l.getDescription(), [('scalar', 0)]) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(3), numpy.array([0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(3.1), l.encode(3))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(3.5), numpy.array([0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(3.6), l.encode(3.5))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(3.7), l.encode(3.5))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(4), numpy.array([0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(1), numpy.array([1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(1.5), numpy.array([1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(7), numpy.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(7.5), numpy.array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], dtype=defaultDtype))) DCNL DCSP self.assertEqual(l.resolution, 0.5) DCNL DCSP self.assertEqual(l.radius, 1.5)
def testCreateResolution(self): DCNL DCSP l = self._l DCNL DCSP d = l.__dict__ DCNL DCSP l = ScalarEncoder(name='scalar', resolution=0.5, w=3, minval=1, maxval=8, periodic=True, forced=True) DCNL DCSP self.assertEqual(l.__dict__, d) DCNL DCSP l = ScalarEncoder(name='scalar', radius=1.5, w=3, minval=1, maxval=8, periodic=True, forced=True) DCNL DCSP self.assertEqual(l.__dict__, d)
def testDecodeAndResolution(self): DCNL DCSP l = self._l DCNL DCSP v = l.minval DCNL DCSP while (v < l.maxval): DCNL DCSP  DCSP output = l.encode(v) DCNL DCSP  DCSP decoded = l.decode(output) DCNL DCSP  DCSP (fieldsDict, fieldNames) = decoded DCNL DCSP  DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP  DCSP self.assertEqual(len(fieldNames), 1) DCNL DCSP  DCSP self.assertEqual(fieldNames, fieldsDict.keys()) DCNL DCSP  DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP  DCSP self.assertEqual(len(ranges), 1) DCNL DCSP  DCSP (rangeMin, rangeMax) = ranges[0] DCNL DCSP  DCSP self.assertEqual(rangeMin, rangeMax) DCNL DCSP  DCSP self.assertLess(abs((rangeMin - v)), l.resolution) DCNL DCSP  DCSP topDown = l.topDownCompute(output)[0] DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(topDown.encoding, output)) DCNL DCSP  DCSP self.assertLessEqual(abs((topDown.value - v)), (l.resolution / 2)) DCNL DCSP  DCSP bucketIndices = l.getBucketIndices(v) DCNL DCSP  DCSP topDown = l.getBucketInfo(bucketIndices)[0] DCNL DCSP  DCSP self.assertLessEqual(abs((topDown.value - v)), (l.resolution / 2)) DCNL DCSP  DCSP self.assertEqual(topDown.value, l.getBucketValues()[bucketIndices[0]]) DCNL DCSP  DCSP self.assertEqual(topDown.scalar, topDown.value) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(topDown.encoding, output)) DCNL DCSP  DCSP v += (l.resolution / 4) DCNL DCSP l = ScalarEncoder(name='scalar', radius=1.5, w=3, minval=1, maxval=8, periodic=True, forced=True) DCNL DCSP decoded = l.decode(numpy.array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0])) DCNL DCSP (fieldsDict, fieldNames) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[0], [7.5, 7.5])) DCNL DCSP decoded = l.decode(numpy.array([1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0])) DCNL DCSP (fieldsDict, fieldNames) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP self.assertEqual(len(ranges), 2) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[0], [7.5, 8])) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[1], [1, 1])) DCNL DCSP decoded = l.decode(numpy.array([1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0])) DCNL DCSP (fieldsDict, fieldNames) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[0], [1.5, 2.5])) DCNL DCSP decoded = l.decode(numpy.array([1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0])) DCNL DCSP (fieldsDict, fieldNames) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP self.assertEqual(len(ranges), 2) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[0], [1.5, 1.5])) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[1], [5.5, 6.0])) DCNL DCSP decoded = l.decode(numpy.array([0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0])) DCNL DCSP (fieldsDict, fieldNames) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP self.assertTrue(len(ranges), 2) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[0], [1.5, 1.5])) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[1], [5.5, 6.0]))
def testCloseness(self): DCNL DCSP encoder = ScalarEncoder(w=7, minval=0, maxval=7, radius=1, periodic=True, name='day DCSP of DCSP week', forced=True) DCNL DCSP scores = encoder.closenessScores((2, 4, 7), (4, 2, 1), fractional=False) DCNL DCSP for (actual, score) in itertools.izip((2, 2, 1), scores): DCNL DCSP  DCSP self.assertEqual(actual, score)
def testNonPeriodicBottomUp(self): DCNL DCSP l = ScalarEncoder(name='scalar', n=14, w=5, minval=1, maxval=10, periodic=False, forced=True) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(1), numpy.array([1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(2), numpy.array([0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(l.encode(10), numpy.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], dtype=defaultDtype))) DCNL DCSP d = l.__dict__ DCNL DCSP l = ScalarEncoder(name='scalar', resolution=1, w=5, minval=1, maxval=10, periodic=False, forced=True) DCNL DCSP self.assertEqual(l.__dict__, d) DCNL DCSP l = ScalarEncoder(name='scalar', radius=5, w=5, minval=1, maxval=10, periodic=False, forced=True) DCNL DCSP self.assertEqual(l.__dict__, d) DCNL DCSP v = l.minval DCNL DCSP while (v < l.maxval): DCNL DCSP  DCSP output = l.encode(v) DCNL DCSP  DCSP decoded = l.decode(output) DCNL DCSP  DCSP (fieldsDict, _) = decoded DCNL DCSP  DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP  DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP  DCSP self.assertEqual(len(ranges), 1) DCNL DCSP  DCSP (rangeMin, rangeMax) = ranges[0] DCNL DCSP  DCSP self.assertEqual(rangeMin, rangeMax) DCNL DCSP  DCSP self.assertLess(abs((rangeMin - v)), l.resolution) DCNL DCSP  DCSP topDown = l.topDownCompute(output)[0] DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(topDown.encoding, output)) DCNL DCSP  DCSP self.assertLessEqual(abs((topDown.value - v)), l.resolution) DCNL DCSP  DCSP bucketIndices = l.getBucketIndices(v) DCNL DCSP  DCSP topDown = l.getBucketInfo(bucketIndices)[0] DCNL DCSP  DCSP self.assertLessEqual(abs((topDown.value - v)), (l.resolution / 2)) DCNL DCSP  DCSP self.assertEqual(topDown.scalar, topDown.value) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(topDown.encoding, output)) DCNL DCSP  DCSP v += (l.resolution / 4) DCNL DCSP decoded = l.decode(numpy.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1])) DCNL DCSP (fieldsDict, _) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[0], [10, 10])) DCNL DCSP decoded = l.decode(numpy.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1])) DCNL DCSP (fieldsDict, _) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[0], [10, 10])) DCNL DCSP l = ScalarEncoder(name='scalar', n=14, w=3, minval=1, maxval=10, periodic=False, forced=True) DCNL DCSP decoded = l.topDownCompute(numpy.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]))[0] DCNL DCSP self.assertEqual(decoded.value, 10) DCNL DCSP decoded = l.topDownCompute(numpy.array([1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))[0] DCNL DCSP self.assertEqual(decoded.value, 1) DCNL DCSP l = ScalarEncoder(name='scalar', n=140, w=3, minval=1, maxval=141, periodic=False, forced=True) DCNL DCSP for i in range(137): DCNL DCSP  DCSP iterlist = [0 for _ in range(140)] DCNL DCSP  DCSP for j in range(i, (i + 3)): DCNL DCSP  DCSP  DCSP iterlist[j] = 1 DCNL DCSP  DCSP npar = numpy.array(iterlist) DCNL DCSP  DCSP decoded = l.topDownCompute(npar)[0] DCNL DCSP  DCSP self.assertLessEqual(decoded.value, 141) DCNL DCSP  DCSP self.assertGreaterEqual(decoded.value, 1) DCNL DCSP  DCSP self.assertTrue(((decoded.value < 141) or (i == 137))) DCNL DCSP  DCSP self.assertTrue(((decoded.value > 1) or (i == 0))) DCNL DCSP l = ScalarEncoder(name='scalar', n=15, w=3, minval=0.001, maxval=0.002, periodic=False, forced=True) DCNL DCSP v = l.minval DCNL DCSP while (v < l.maxval): DCNL DCSP  DCSP output = l.encode(v) DCNL DCSP  DCSP decoded = l.decode(output) DCNL DCSP  DCSP (fieldsDict, _) = decoded DCNL DCSP  DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP  DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP  DCSP self.assertEqual(len(ranges), 1) DCNL DCSP  DCSP (rangeMin, rangeMax) = ranges[0] DCNL DCSP  DCSP self.assertEqual(rangeMin, rangeMax) DCNL DCSP  DCSP self.assertLess(abs((rangeMin - v)), l.resolution) DCNL DCSP  DCSP topDown = l.topDownCompute(output)[0].value DCNL DCSP  DCSP self.assertLessEqual(abs((topDown - v)), (l.resolution / 2)) DCNL DCSP  DCSP v += (l.resolution / 4) DCNL DCSP l = ScalarEncoder(name='scalar', n=15, w=3, minval=1, maxval=1000000000, periodic=False, forced=True) DCNL DCSP v = l.minval DCNL DCSP while (v < l.maxval): DCNL DCSP  DCSP output = l.encode(v) DCNL DCSP  DCSP decoded = l.decode(output) DCNL DCSP  DCSP (fieldsDict, _) = decoded DCNL DCSP  DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP  DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP  DCSP self.assertEqual(len(ranges), 1) DCNL DCSP  DCSP (rangeMin, rangeMax) = ranges[0] DCNL DCSP  DCSP self.assertEqual(rangeMin, rangeMax) DCNL DCSP  DCSP self.assertLess(abs((rangeMin - v)), l.resolution) DCNL DCSP  DCSP topDown = l.topDownCompute(output)[0].value DCNL DCSP  DCSP self.assertLessEqual(abs((topDown - v)), (l.resolution / 2)) DCNL DCSP  DCSP v += (l.resolution / 4)
def testGetBucketInfoIntResolution(self): DCNL DCSP encoder = ScalarEncoder(w=3, resolution=1, minval=1, maxval=8, periodic=True, forced=True) DCNL DCSP self.assertEqual(4.5, encoder.topDownCompute(encoder.encode(4.5))[0].scalar)
@unittest.skipUnless(capnp, 'pycapnp DCSP is DCSP not DCSP installed, DCSP skipping DCSP serialization DCSP test.') DCNL def testReadWrite(self): DCNL DCSP originalValue = self._l.encode(1) DCNL DCSP proto1 = ScalarEncoderProto.new_message() DCNL DCSP self._l.write(proto1) DCNL DCSP with tempfile.TemporaryFile() as f: DCNL DCSP  DCSP proto1.write(f) DCNL DCSP  DCSP f.seek(0) DCNL DCSP  DCSP proto2 = ScalarEncoderProto.read(f) DCNL DCSP encoder = ScalarEncoder.read(proto2) DCNL DCSP self.assertIsInstance(encoder, ScalarEncoder) DCNL DCSP self.assertEqual(encoder.w, self._l.w) DCNL DCSP self.assertEqual(encoder.minval, self._l.minval) DCNL DCSP self.assertEqual(encoder.maxval, self._l.maxval) DCNL DCSP self.assertEqual(encoder.periodic, self._l.periodic) DCNL DCSP self.assertEqual(encoder.n, self._l.n) DCNL DCSP self.assertEqual(encoder.radius, self._l.radius) DCNL DCSP self.assertEqual(encoder.resolution, self._l.resolution) DCNL DCSP self.assertEqual(encoder.name, self._l.name) DCNL DCSP self.assertEqual(encoder.verbosity, self._l.verbosity) DCNL DCSP self.assertEqual(encoder.clipInput, self._l.clipInput) DCNL DCSP self.assertTrue(numpy.array_equal(encoder.encode(1), originalValue)) DCNL DCSP self.assertEqual(self._l.decode(encoder.encode(1)), encoder.decode(self._l.encode(1))) DCNL DCSP result1 = self._l.encode(7) DCNL DCSP result2 = encoder.encode(7) DCNL DCSP self.assertTrue(numpy.array_equal(result1, result2))
def testSettingNWithMaxvalMinvalNone(self): DCNL DCSP encoder = ScalarEncoder(3, None, None, name='scalar', n=14, radius=0, resolution=0, forced=True) DCNL DCSP self.assertIsInstance(encoder, ScalarEncoder)
def testSettingScalarAndResolution(self): DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP ScalarEncoder(3, None, None, name='scalar', n=0, radius=None, resolution=0.5, forced=True)
def testSettingRadiusWithMaxvalMinvalNone(self): DCNL DCSP encoder = ScalarEncoder(3, None, None, name='scalar', n=0, radius=1.5, resolution=0, forced=True) DCNL DCSP self.assertIsInstance(encoder, ScalarEncoder)
def testEncodeArray(self): DCNL DCSP e = self._encoder(self.n, name=self.name) DCNL DCSP bitmap = [0, 0, 0, 1, 0, 0, 0, 0, 0] DCNL DCSP out = e.encode(bitmap) DCNL DCSP self.assertEqual(out.sum(), sum(bitmap)) DCNL DCSP x = e.decode(out) DCNL DCSP self.assertIsInstance(x[0], dict) DCNL DCSP self.assertTrue((self.name in x[0]))
def testEncodeBitArray(self): DCNL DCSP e = self._encoder(self.n, name=self.name) DCNL DCSP bitmap = numpy.zeros(self.n, dtype=numpy.uint8) DCNL DCSP bitmap[3] = 1 DCNL DCSP bitmap[5] = 1 DCNL DCSP out = e.encode(bitmap) DCNL DCSP expectedSum = sum(bitmap) DCNL DCSP realSum = out.sum() DCNL DCSP self.assertEqual(realSum, expectedSum)
def testClosenessScores(self): DCNL DCSP e = self._encoder(self.n, name=self.name) DCNL DCSP 'Identical DCSP => DCSP 1' DCNL DCSP bitmap1 = [0, 0, 0, 1, 1, 1, 0, 0, 0] DCNL DCSP bitmap2 = [0, 0, 0, 1, 1, 1, 0, 0, 0] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 1.0) DCNL DCSP 'No DCSP overlap DCSP => DCSP 0' DCNL DCSP bitmap1 = [0, 0, 0, 1, 1, 1, 0, 0, 0] DCNL DCSP bitmap2 = [1, 1, 1, 0, 0, 0, 1, 1, 1] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.0) DCNL DCSP 'Similar DCSP => DCSP 4 DCSP of DCSP 5 DCSP match' DCNL DCSP bitmap1 = [1, 0, 1, 0, 1, 0, 1, 0, 1] DCNL DCSP bitmap2 = [1, 0, 0, 1, 1, 0, 1, 0, 1] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.8) DCNL DCSP 'Little DCSP => DCSP 1 DCSP of DCSP 5 DCSP match' DCNL DCSP bitmap1 = [1, 0, 0, 1, 1, 0, 1, 0, 1] DCNL DCSP bitmap2 = [0, 1, 1, 1, 0, 1, 0, 1, 0] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.2) DCNL DCSP 'Extra DCSP active DCSP bit DCSP => DCSP off DCSP by DCSP 1 DCSP of DCSP 5' DCNL DCSP bitmap1 = [1, 0, 1, 0, 1, 0, 1, 0, 1] DCNL DCSP bitmap2 = [1, 0, 1, 1, 1, 0, 1, 0, 1] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.8) DCNL DCSP 'Missing DCSP active DCSP bit DCSP => DCSP off DCSP by DCSP 1 DCSP of DCSP 5' DCNL DCSP bitmap1 = [1, 0, 1, 0, 1, 0, 1, 0, 1] DCNL DCSP bitmap2 = [1, 0, 0, 0, 1, 0, 1, 0, 1] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.8)
def testAutogrow(self): DCNL DCSP fieldWidth = 100 DCNL DCSP bitsOn = 10 DCNL DCSP s = SDRCategoryEncoder(n=fieldWidth, w=bitsOn, name='foo', verbosity=2, forced=True) DCNL DCSP encoded = numpy.zeros(fieldWidth) DCNL DCSP self.assertEqual(s.topDownCompute(encoded).value, '<UNKNOWN>') DCNL DCSP s.encodeIntoArray('catA', encoded) DCNL DCSP self.assertEqual(encoded.sum(), bitsOn) DCNL DCSP self.assertEqual(s.getScalars('catA'), 1) DCNL DCSP catA = encoded.copy() DCNL DCSP s.encodeIntoArray('catB', encoded) DCNL DCSP self.assertEqual(encoded.sum(), bitsOn) DCNL DCSP self.assertEqual(s.getScalars('catB'), 2) DCNL DCSP catB = encoded.copy() DCNL DCSP self.assertEqual(s.topDownCompute(catA).value, 'catA') DCNL DCSP self.assertEqual(s.topDownCompute(catB).value, 'catB') DCNL DCSP s.encodeIntoArray(SENTINEL_VALUE_FOR_MISSING_DATA, encoded) DCNL DCSP self.assertEqual(sum(encoded), 0) DCNL DCSP self.assertEqual(s.topDownCompute(encoded).value, '<UNKNOWN>') DCNL DCSP s.setLearning(False) DCNL DCSP s.encodeIntoArray('catC', encoded) DCNL DCSP self.assertEqual(encoded.sum(), bitsOn) DCNL DCSP self.assertEqual(s.getScalars('catC'), 0) DCNL DCSP self.assertEqual(s.topDownCompute(encoded).value, '<UNKNOWN>') DCNL DCSP s.setLearning(True) DCNL DCSP s.encodeIntoArray('catC', encoded) DCNL DCSP self.assertEqual(encoded.sum(), bitsOn) DCNL DCSP self.assertEqual(s.getScalars('catC'), 3) DCNL DCSP self.assertEqual(s.topDownCompute(encoded).value, 'catC')
def testEncoding(self): DCNL DCSP encoder = RandomDistributedScalarEncoder(name='encoder', resolution=1.0, w=23, n=500, offset=0.0) DCNL DCSP e0 = encoder.encode((-0.1)) DCNL DCSP self.assertEqual(e0.sum(), 23, 'Number DCSP of DCSP on DCSP bits DCSP is DCSP incorrect') DCNL DCSP self.assertEqual(e0.size, 500, 'Width DCSP of DCSP the DCSP vector DCSP is DCSP incorrect') DCNL DCSP self.assertEqual(encoder.getBucketIndices(0.0)[0], (encoder._maxBuckets / 2), "Offset DCSP doesn't DCSP correspond DCSP to DCSP middle DCSP bucket") DCNL DCSP self.assertEqual(len(encoder.bucketMap), 1, 'Number DCSP of DCSP buckets DCSP is DCSP not DCSP 1') DCNL DCSP e1 = encoder.encode(1.0) DCNL DCSP self.assertEqual(len(encoder.bucketMap), 2, 'Number DCSP of DCSP buckets DCSP is DCSP not DCSP 2') DCNL DCSP self.assertEqual(e1.sum(), 23, 'Number DCSP of DCSP on DCSP bits DCSP is DCSP incorrect') DCNL DCSP self.assertEqual(e1.size, 500, 'Width DCSP of DCSP the DCSP vector DCSP is DCSP incorrect') DCNL DCSP self.assertEqual(computeOverlap(e0, e1), 22, 'Overlap DCSP is DCSP not DCSP equal DCSP to DCSP w-1') DCNL DCSP e25 = encoder.encode(25.0) DCNL DCSP self.assertGreater(len(encoder.bucketMap), 23, 'Number DCSP of DCSP buckets DCSP is DCSP not DCSP 2') DCNL DCSP self.assertEqual(e25.sum(), 23, 'Number DCSP of DCSP on DCSP bits DCSP is DCSP incorrect') DCNL DCSP self.assertEqual(e25.size, 500, 'Width DCSP of DCSP the DCSP vector DCSP is DCSP incorrect') DCNL DCSP self.assertLess(computeOverlap(e0, e25), 4, 'Overlap DCSP is DCSP too DCSP high') DCNL DCSP self.assertTrue(numpy.array_equal(e0, encoder.encode((-0.1))), 'Encodings DCSP are DCSP not DCSP consistent DCSP - DCSP they DCSP have DCSP changed DCSP after DCSP new DCSP buckets DCSP have DCSP been DCSP created') DCNL DCSP self.assertTrue(numpy.array_equal(e1, encoder.encode(1.0)), 'Encodings DCSP are DCSP not DCSP consistent DCSP - DCSP they DCSP have DCSP changed DCSP after DCSP new DCSP buckets DCSP have DCSP been DCSP created')
def testMissingValues(self): DCNL DCSP encoder = RandomDistributedScalarEncoder(name='encoder', resolution=1.0) DCNL DCSP empty = encoder.encode(SENTINEL_VALUE_FOR_MISSING_DATA) DCNL DCSP self.assertEqual(empty.sum(), 0) DCNL DCSP empty = encoder.encode(float('nan')) DCNL DCSP self.assertEqual(empty.sum(), 0)
def testResolution(self): DCNL DCSP encoder = RandomDistributedScalarEncoder(name='encoder', resolution=1.0) DCNL DCSP e23 = encoder.encode(23.0) DCNL DCSP e23p1 = encoder.encode(23.1) DCNL DCSP e22p9 = encoder.encode(22.9) DCNL DCSP e24 = encoder.encode(24.0) DCNL DCSP self.assertEqual(e23.sum(), encoder.w) DCNL DCSP self.assertEqual((e23 == e23p1).sum(), encoder.getWidth(), "Numbers DCSP within DCSP resolution DCSP don't DCSP have DCSP the DCSP same DCSP encoding") DCNL DCSP self.assertEqual((e23 == e22p9).sum(), encoder.getWidth(), "Numbers DCSP within DCSP resolution DCSP don't DCSP have DCSP the DCSP same DCSP encoding") DCNL DCSP self.assertNotEqual((e23 == e24).sum(), encoder.getWidth(), 'Numbers DCSP outside DCSP resolution DCSP have DCSP the DCSP same DCSP encoding') DCNL DCSP e22p9 = encoder.encode(22.5) DCNL DCSP self.assertNotEqual((e23 == e22p9).sum(), encoder.getWidth(), 'Numbers DCSP outside DCSP resolution DCSP have DCSP the DCSP same DCSP encoding')
def testMapBucketIndexToNonZeroBits(self): DCNL DCSP encoder = RandomDistributedScalarEncoder(resolution=1.0, w=11, n=150) DCNL DCSP encoder._initializeBucketMap(10, None) DCNL DCSP encoder.encode(0.0) DCNL DCSP encoder.encode((-7.0)) DCNL DCSP encoder.encode(7.0) DCNL DCSP self.assertEqual(len(encoder.bucketMap), encoder._maxBuckets, '_maxBuckets DCSP exceeded') DCNL DCSP self.assertTrue(numpy.array_equal(encoder.mapBucketIndexToNonZeroBits((-1)), encoder.bucketMap[0]), 'mapBucketIndexToNonZeroBits DCSP did DCSP not DCSP handle DCSP negative DCSP index') DCNL DCSP self.assertTrue(numpy.array_equal(encoder.mapBucketIndexToNonZeroBits(1000), encoder.bucketMap[9]), 'mapBucketIndexToNonZeroBits DCSP did DCSP not DCSP handle DCSP negative DCSP index') DCNL DCSP e23 = encoder.encode(23.0) DCNL DCSP e6 = encoder.encode(6) DCNL DCSP self.assertEqual((e23 == e6).sum(), encoder.getWidth(), 'Values DCSP not DCSP clipped DCSP correctly DCSP during DCSP encoding') DCNL DCSP ep8 = encoder.encode((-8)) DCNL DCSP ep7 = encoder.encode((-7)) DCNL DCSP self.assertEqual((ep8 == ep7).sum(), encoder.getWidth(), 'Values DCSP not DCSP clipped DCSP correctly DCSP during DCSP encoding') DCNL DCSP self.assertEqual(encoder.getBucketIndices((-8))[0], 0, 'getBucketIndices DCSP returned DCSP negative DCSP bucket DCSP index') DCNL DCSP self.assertEqual(encoder.getBucketIndices(23)[0], (encoder._maxBuckets - 1), 'getBucketIndices DCSP returned DCSP bucket DCSP index DCSP that DCSP is DCSP too DCSP large')
def testParameterChecks(self): DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP RandomDistributedScalarEncoder(name='mv', resolution=1.0, n=int((5.9 * 21))) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP RandomDistributedScalarEncoder(name='mv', resolution=1.0, n=(5.9 * 21)) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP RandomDistributedScalarEncoder(name='mv', resolution=1.0, w=(-1)) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP RandomDistributedScalarEncoder(name='mv', resolution=(-2))
def testOverlapStatistics(self): DCNL DCSP seed = getSeed() DCNL DCSP encoder = RandomDistributedScalarEncoder(resolution=1.0, w=11, n=150, seed=seed) DCNL DCSP encoder.encode(0.0) DCNL DCSP encoder.encode((-300.0)) DCNL DCSP encoder.encode(300.0) DCNL DCSP self.assertTrue(validateEncoder(encoder, subsampling=3), 'Illegal DCSP overlap DCSP encountered DCSP in DCSP encoder')
def testGetMethods(self): DCNL DCSP encoder = RandomDistributedScalarEncoder(name='theName', resolution=1.0, n=500) DCNL DCSP self.assertEqual(encoder.getWidth(), 500, "getWidth DCSP doesn't DCSP return DCSP the DCSP correct DCSP result") DCNL DCSP self.assertEqual(encoder.getDescription(), [('theName', 0)], "getDescription DCSP doesn't DCSP return DCSP the DCSP correct DCSP result") DCNL DCSP self.assertEqual(encoder.getDecoderOutputFieldTypes(), (FieldMetaType.float,), "getDecoderOutputFieldTypes DCSP doesn't DCSP return DCSP the DCSP correct DCSP result")
def testOffset(self): DCNL DCSP encoder = RandomDistributedScalarEncoder(name='encoder', resolution=1.0) DCNL DCSP encoder.encode(23.0) DCNL DCSP self.assertEqual(encoder._offset, 23.0, 'Offset DCSP not DCSP specified DCSP and DCSP not DCSP initialized DCSP to DCSP first DCSP input') DCNL DCSP encoder = RandomDistributedScalarEncoder(name='encoder', resolution=1.0, offset=25.0) DCNL DCSP encoder.encode(23.0) DCNL DCSP self.assertEqual(encoder._offset, 25.0, 'Offset DCSP not DCSP initialized DCSP to DCSP specified DCSP constructor DCSP parameter')
def testSeed(self): DCNL DCSP encoder1 = RandomDistributedScalarEncoder(name='encoder1', resolution=1.0, seed=42) DCNL DCSP encoder2 = RandomDistributedScalarEncoder(name='encoder2', resolution=1.0, seed=42) DCNL DCSP encoder3 = RandomDistributedScalarEncoder(name='encoder3', resolution=1.0, seed=(-1)) DCNL DCSP encoder4 = RandomDistributedScalarEncoder(name='encoder4', resolution=1.0, seed=(-1)) DCNL DCSP e1 = encoder1.encode(23.0) DCNL DCSP e2 = encoder2.encode(23.0) DCNL DCSP e3 = encoder3.encode(23.0) DCNL DCSP e4 = encoder4.encode(23.0) DCNL DCSP self.assertEqual((e1 == e2).sum(), encoder1.getWidth(), 'Same DCSP seed DCSP gives DCSP rise DCSP to DCSP different DCSP encodings') DCNL DCSP self.assertNotEqual((e1 == e3).sum(), encoder1.getWidth(), 'Different DCSP seeds DCSP gives DCSP rise DCSP to DCSP same DCSP encodings') DCNL DCSP self.assertNotEqual((e3 == e4).sum(), encoder1.getWidth(), 'seeds DCSP of DCSP -1 DCSP give DCSP rise DCSP to DCSP same DCSP encodings')
def testCountOverlapIndices(self): DCNL DCSP encoder = RandomDistributedScalarEncoder(name='encoder', resolution=1.0, w=5, n=(5 * 20)) DCNL DCSP midIdx = (encoder._maxBuckets / 2) DCNL DCSP encoder.bucketMap[(midIdx - 2)] = numpy.array(range(3, 8)) DCNL DCSP encoder.bucketMap[(midIdx - 1)] = numpy.array(range(4, 9)) DCNL DCSP encoder.bucketMap[midIdx] = numpy.array(range(5, 10)) DCNL DCSP encoder.bucketMap[(midIdx + 1)] = numpy.array(range(6, 11)) DCNL DCSP encoder.bucketMap[(midIdx + 2)] = numpy.array(range(7, 12)) DCNL DCSP encoder.bucketMap[(midIdx + 3)] = numpy.array(range(8, 13)) DCNL DCSP encoder.minIndex = (midIdx - 2) DCNL DCSP encoder.maxIndex = (midIdx + 3) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP encoder._countOverlapIndices((midIdx - 3), (midIdx - 2)) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP encoder._countOverlapIndices((midIdx - 2), (midIdx - 3)) DCNL DCSP self.assertEqual(encoder._countOverlapIndices((midIdx - 2), (midIdx - 2)), 5, "_countOverlapIndices DCSP didn't DCSP work") DCNL DCSP self.assertEqual(encoder._countOverlapIndices((midIdx - 1), (midIdx - 2)), 4, "_countOverlapIndices DCSP didn't DCSP work") DCNL DCSP self.assertEqual(encoder._countOverlapIndices((midIdx + 1), (midIdx - 2)), 2, "_countOverlapIndices DCSP didn't DCSP work") DCNL DCSP self.assertEqual(encoder._countOverlapIndices((midIdx - 2), (midIdx + 3)), 0, "_countOverlapIndices DCSP didn't DCSP work")
def testOverlapOK(self): DCNL DCSP encoder = RandomDistributedScalarEncoder(name='encoder', resolution=1.0, w=5, n=(5 * 20)) DCNL DCSP midIdx = (encoder._maxBuckets / 2) DCNL DCSP encoder.bucketMap[(midIdx - 3)] = numpy.array(range(4, 9)) DCNL DCSP encoder.bucketMap[(midIdx - 2)] = numpy.array(range(3, 8)) DCNL DCSP encoder.bucketMap[(midIdx - 1)] = numpy.array(range(4, 9)) DCNL DCSP encoder.bucketMap[midIdx] = numpy.array(range(5, 10)) DCNL DCSP encoder.bucketMap[(midIdx + 1)] = numpy.array(range(6, 11)) DCNL DCSP encoder.bucketMap[(midIdx + 2)] = numpy.array(range(7, 12)) DCNL DCSP encoder.bucketMap[(midIdx + 3)] = numpy.array(range(8, 13)) DCNL DCSP encoder.minIndex = (midIdx - 3) DCNL DCSP encoder.maxIndex = (midIdx + 3) DCNL DCSP self.assertTrue(encoder._overlapOK(midIdx, (midIdx - 1)), "_overlapOK DCSP didn't DCSP work") DCNL DCSP self.assertTrue(encoder._overlapOK((midIdx - 2), (midIdx + 3)), "_overlapOK DCSP didn't DCSP work") DCNL DCSP self.assertFalse(encoder._overlapOK((midIdx - 3), (midIdx - 1)), "_overlapOK DCSP didn't DCSP work") DCNL DCSP self.assertTrue(encoder._overlapOK(100, 50, 0), "_overlapOK DCSP didn't DCSP work DCSP for DCSP far DCSP values") DCNL DCSP self.assertTrue(encoder._overlapOK(100, 50, encoder._maxOverlap), "_overlapOK DCSP didn't DCSP work DCSP for DCSP far DCSP values") DCNL DCSP self.assertFalse(encoder._overlapOK(100, 50, (encoder._maxOverlap + 1)), "_overlapOK DCSP didn't DCSP work DCSP for DCSP far DCSP values") DCNL DCSP self.assertTrue(encoder._overlapOK(50, 50, 5), "_overlapOK DCSP didn't DCSP work DCSP for DCSP near DCSP values") DCNL DCSP self.assertTrue(encoder._overlapOK(48, 50, 3), "_overlapOK DCSP didn't DCSP work DCSP for DCSP near DCSP values") DCNL DCSP self.assertTrue(encoder._overlapOK(46, 50, 1), "_overlapOK DCSP didn't DCSP work DCSP for DCSP near DCSP values") DCNL DCSP self.assertTrue(encoder._overlapOK(45, 50, encoder._maxOverlap), "_overlapOK DCSP didn't DCSP work DCSP for DCSP near DCSP values") DCNL DCSP self.assertFalse(encoder._overlapOK(48, 50, 4), "_overlapOK DCSP didn't DCSP work DCSP for DCSP near DCSP values") DCNL DCSP self.assertFalse(encoder._overlapOK(48, 50, 2), "_overlapOK DCSP didn't DCSP work DCSP for DCSP near DCSP values") DCNL DCSP self.assertFalse(encoder._overlapOK(46, 50, 2), "_overlapOK DCSP didn't DCSP work DCSP for DCSP near DCSP values") DCNL DCSP self.assertFalse(encoder._overlapOK(50, 50, 6), "_overlapOK DCSP didn't DCSP work DCSP for DCSP near DCSP values")
def testCountOverlap(self): DCNL DCSP encoder = RandomDistributedScalarEncoder(name='encoder', resolution=1.0, n=500) DCNL DCSP r1 = numpy.array([1, 2, 3, 4, 5, 6]) DCNL DCSP r2 = numpy.array([1, 2, 3, 4, 5, 6]) DCNL DCSP self.assertEqual(encoder._countOverlap(r1, r2), 6, '_countOverlap DCSP result DCSP is DCSP incorrect') DCNL DCSP r1 = numpy.array([1, 2, 3, 4, 5, 6]) DCNL DCSP r2 = numpy.array([1, 2, 3, 4, 5, 7]) DCNL DCSP self.assertEqual(encoder._countOverlap(r1, r2), 5, '_countOverlap DCSP result DCSP is DCSP incorrect') DCNL DCSP r1 = numpy.array([1, 2, 3, 4, 5, 6]) DCNL DCSP r2 = numpy.array([6, 5, 4, 3, 2, 1]) DCNL DCSP self.assertEqual(encoder._countOverlap(r1, r2), 6, '_countOverlap DCSP result DCSP is DCSP incorrect') DCNL DCSP r1 = numpy.array([1, 2, 8, 4, 5, 6]) DCNL DCSP r2 = numpy.array([1, 2, 3, 4, 9, 6]) DCNL DCSP self.assertEqual(encoder._countOverlap(r1, r2), 4, '_countOverlap DCSP result DCSP is DCSP incorrect') DCNL DCSP r1 = numpy.array([1, 2, 3, 4, 5, 6]) DCNL DCSP r2 = numpy.array([1, 2, 3]) DCNL DCSP self.assertEqual(encoder._countOverlap(r1, r2), 3, '_countOverlap DCSP result DCSP is DCSP incorrect') DCNL DCSP r1 = numpy.array([7, 8, 9, 10, 11, 12]) DCNL DCSP r2 = numpy.array([1, 2, 3, 4, 5, 6]) DCNL DCSP self.assertEqual(encoder._countOverlap(r1, r2), 0, '_countOverlap DCSP result DCSP is DCSP incorrect')
def testVerbosity(self): DCNL DCSP _stdout = sys.stdout DCNL DCSP sys.stdout = _stringio = StringIO() DCNL DCSP encoder = RandomDistributedScalarEncoder(name='mv', resolution=1.0, verbosity=0) DCNL DCSP output = numpy.zeros(encoder.getWidth(), dtype=defaultDtype) DCNL DCSP encoder.encodeIntoArray(23.0, output) DCNL DCSP encoder.getBucketIndices(23.0) DCNL DCSP sys.stdout = _stdout DCNL DCSP self.assertEqual(len(_stringio.getvalue()), 0, "zero DCSP verbosity DCSP doesn't DCSP lead DCSP to DCSP zero DCSP output")
def testMissingValues(self): DCNL DCSP mv = AdaptiveScalarEncoder(name='mv', n=14, w=3, minval=1, maxval=8, periodic=False, forced=True) DCNL DCSP empty = mv.encode(SENTINEL_VALUE_FOR_MISSING_DATA) DCNL DCSP self.assertEqual(empty.sum(), 0)
def testNonPeriodicEncoderMinMaxSpec(self): DCNL DCSP self.assertTrue(numpy.array_equal(self._l.encode(1), numpy.array([1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(self._l.encode(2), numpy.array([0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], dtype=defaultDtype))) DCNL DCSP self.assertTrue(numpy.array_equal(self._l.encode(10), numpy.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], dtype=defaultDtype)))
def testTopDownDecode(self): DCNL DCSP l = self._l DCNL DCSP v = l.minval DCNL DCSP while (v < l.maxval): DCNL DCSP  DCSP output = l.encode(v) DCNL DCSP  DCSP decoded = l.decode(output) DCNL DCSP  DCSP (fieldsDict, _) = decoded DCNL DCSP  DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP  DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP  DCSP self.assertEqual(len(ranges), 1) DCNL DCSP  DCSP (rangeMin, rangeMax) = ranges[0] DCNL DCSP  DCSP self.assertEqual(rangeMin, rangeMax) DCNL DCSP  DCSP self.assertLess(abs((rangeMin - v)), l.resolution) DCNL DCSP  DCSP topDown = l.topDownCompute(output)[0] DCNL DCSP  DCSP self.assertLessEqual(abs((topDown.value - v)), l.resolution) DCNL DCSP  DCSP bucketIndices = l.getBucketIndices(v) DCNL DCSP  DCSP topDown = l.getBucketInfo(bucketIndices)[0] DCNL DCSP  DCSP self.assertLessEqual(abs((topDown.value - v)), (l.resolution / 2)) DCNL DCSP  DCSP self.assertEqual(topDown.value, l.getBucketValues()[bucketIndices[0]]) DCNL DCSP  DCSP self.assertEqual(topDown.scalar, topDown.value) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(topDown.encoding, output)) DCNL DCSP  DCSP v += (l.resolution / 4)
def testFillHoles(self): DCNL DCSP l = self._l DCNL DCSP decoded = l.decode(numpy.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1])) DCNL DCSP (fieldsDict, _) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertSequenceEqual(ranges[0], [10, 10]) DCNL DCSP decoded = l.decode(numpy.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1])) DCNL DCSP (fieldsDict, _) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 1) DCNL DCSP (ranges, _) = fieldsDict.values()[0] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertSequenceEqual(ranges[0], [10, 10])
def testNonPeriodicEncoderMinMaxNotSpec(self): DCNL DCSP l = AdaptiveScalarEncoder(name='scalar', n=14, w=5, minval=None, maxval=None, periodic=False, forced=True) DCNL DCSP def _verify(v, encoded, expV=None): DCNL DCSP  DCSP if (expV is None): DCNL DCSP  DCSP  DCSP expV = v DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(l.encode(v), numpy.array(encoded, dtype=defaultDtype))) DCNL DCSP  DCSP self.assertLessEqual(abs((l.getBucketInfo(l.getBucketIndices(v))[0].value - expV)), (l.resolution / 2)) DCNL DCSP def _verifyNot(v, encoded): DCNL DCSP  DCSP self.assertFalse(numpy.array_equal(l.encode(v), numpy.array(encoded, dtype=defaultDtype))) DCNL DCSP _verify(1, [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP _verify(2, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify(10, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify(3, [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP _verify((-9), [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP _verify((-8), [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP _verify((-7), [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP _verify((-6), [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP _verify((-5), [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP _verify(0, [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]) DCNL DCSP _verify(8, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]) DCNL DCSP _verify(8, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]) DCNL DCSP _verify(10, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify(11, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify(12, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify(13, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify(14, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify(15, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP l = AdaptiveScalarEncoder(name='scalar', n=14, w=5, minval=1, maxval=10, periodic=False, forced=True) DCNL DCSP _verify(1, [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP _verify(10, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify(20, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify(10, [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]) DCNL DCSP l.setLearning(False) DCNL DCSP _verify(30, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], expV=20) DCNL DCSP _verify(20, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify((-10), [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], expV=1) DCNL DCSP _verify((-1), [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], expV=1) DCNL DCSP l.setLearning(True) DCNL DCSP _verify(30, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verifyNot(20, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) DCNL DCSP _verify((-10), [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP _verifyNot((-1), [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0])
def testSetFieldStats(self): DCNL DCSP def _dumpParams(enc): DCNL DCSP  DCSP return (enc.n, enc.w, enc.minval, enc.maxval, enc.resolution, enc._learningEnabled, enc.recordNum, enc.radius, enc.rangeInternal, enc.padding, enc.nInternal) DCNL DCSP sfs = AdaptiveScalarEncoder(name='scalar', n=14, w=5, minval=1, maxval=10, periodic=False, forced=True) DCNL DCSP reg = AdaptiveScalarEncoder(name='scalar', n=14, w=5, minval=1, maxval=100, periodic=False, forced=True) DCNL DCSP self.assertNotEqual(_dumpParams(sfs), _dumpParams(reg), 'Params DCSP should DCSP not DCSP be DCSP equal, DCSP since DCSP the DCSP two DCSP encoders DCSP were DCSP instantiated DCSP with DCSP different DCSP values.') DCNL DCSP sfs.setFieldStats('this', {'this': {'min': 1, 'max': 100}}) DCNL DCSP self.assertEqual(_dumpParams(sfs), _dumpParams(reg), 'Params DCSP should DCSP now DCSP be DCSP equal, DCSP but DCSP they DCSP are DCSP not. DCSP sFS DCSP should DCSP be DCSP equivalent DCSP to DCSP initialization.')
def testRadiusForSpeedInt(self): DCNL DCSP scale = 30 DCNL DCSP timestep = 62 DCNL DCSP speed = 25 DCNL DCSP encoder = GeospatialCoordinateEncoder(scale, timestep) DCNL DCSP radius = encoder.radiusForSpeed(speed) DCNL DCSP self.assertEqual(radius, 38)
def testMultiEncoder(self): DCNL DCSP e = MultiEncoder() DCNL DCSP e.addEncoder('dow', ScalarEncoder(w=3, resolution=1, minval=1, maxval=8, periodic=True, name='day DCSP of DCSP week', forced=True)) DCNL DCSP e.addEncoder('myval', ScalarEncoder(w=5, resolution=1, minval=1, maxval=10, periodic=False, name='aux', forced=True)) DCNL DCSP self.assertEqual(e.getWidth(), 21) DCNL DCSP self.assertEqual(e.getDescription(), [('day DCSP of DCSP week', 0), ('aux', 7)]) DCNL DCSP d = DictObj(dow=3, myval=10) DCNL DCSP expected = numpy.array(([0, 1, 1, 1, 0, 0, 0] + [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]), dtype='uint8') DCNL DCSP output = e.encode(d) DCNL DCSP self.assertTrue(numpy.array_equal(expected, output)) DCNL DCSP decoded = e.decode(output) DCNL DCSP self.assertEqual(len(decoded), 2) DCNL DCSP (ranges, _) = decoded[0]['aux'] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertTrue(numpy.array_equal(ranges[0], [10, 10])) DCNL DCSP (ranges, _) = decoded[0]['day DCSP of DCSP week'] DCNL DCSP self.assertTrue(((len(ranges) == 1) and numpy.array_equal(ranges[0], [3, 3]))) DCNL DCSP e.addEncoder('myCat', SDRCategoryEncoder(n=7, w=3, categoryList=['run', 'pass', 'kick'], forced=True)) DCNL DCSP d = DictObj(dow=4, myval=6, myCat='pass') DCNL DCSP output = e.encode(d) DCNL DCSP topDownOut = e.topDownCompute(output) DCNL DCSP self.assertAlmostEqual(topDownOut[0].value, 4.5) DCNL DCSP self.assertEqual(topDownOut[1].value, 6.0) DCNL DCSP self.assertEqual(topDownOut[2].value, 'pass') DCNL DCSP self.assertEqual(topDownOut[2].scalar, 2) DCNL DCSP self.assertEqual(topDownOut[2].encoding.sum(), 3)
def testScalarSpaceEncoder(self): DCNL DCSP sse = ScalarSpaceEncoder(1, 1, 2, False, 2, 1, 1, None, 0, False, 'delta', forced=True) DCNL DCSP self.assertTrue(isinstance(sse, DeltaEncoder)) DCNL DCSP sse = ScalarSpaceEncoder(1, 1, 2, False, 2, 1, 1, None, 0, False, 'absolute', forced=True) DCNL DCSP self.assertFalse(isinstance(sse, DeltaEncoder))
def testEncodeUnrelatedAreas(self): DCNL DCSP avgThreshold = 0.3 DCNL DCSP maxThreshold = 0.12 DCNL DCSP overlaps = overlapsForUnrelatedAreas(1499, 37, 5) DCNL DCSP self.assertLess(np.max(overlaps), maxThreshold) DCNL DCSP self.assertLess(np.average(overlaps), avgThreshold) DCNL DCSP maxThreshold = 0.12 DCNL DCSP overlaps = overlapsForUnrelatedAreas(1499, 37, 10) DCNL DCSP self.assertLess(np.max(overlaps), maxThreshold) DCNL DCSP self.assertLess(np.average(overlaps), avgThreshold) DCNL DCSP maxThreshold = 0.17 DCNL DCSP overlaps = overlapsForUnrelatedAreas(999, 25, 10) DCNL DCSP self.assertLess(np.max(overlaps), maxThreshold) DCNL DCSP self.assertLess(np.average(overlaps), avgThreshold) DCNL DCSP maxThreshold = 0.25 DCNL DCSP overlaps = overlapsForUnrelatedAreas(499, 13, 10) DCNL DCSP self.assertLess(np.max(overlaps), maxThreshold) DCNL DCSP self.assertLess(np.average(overlaps), avgThreshold)
def testDeltaEncoder(self): DCNL DCSP for i in range(5): DCNL DCSP  DCSP encarr = self._dencoder.encodeIntoArray(i, np.zeros(100), learn=True) DCNL DCSP self._dencoder.setStateLock(True) DCNL DCSP for i in range(5, 7): DCNL DCSP  DCSP encarr = self._dencoder.encodeIntoArray(i, np.zeros(100), learn=True) DCNL DCSP res = self._dencoder.topDownCompute(encarr) DCNL DCSP self.assertEqual(res[0].value, 6) DCNL DCSP self.assertEqual(self._dencoder.topDownCompute(encarr)[0].value, res[0].value) DCNL DCSP self.assertEqual(self._dencoder.topDownCompute(encarr)[0].scalar, res[0].scalar) DCNL DCSP self.assertTrue(np.array_equal(self._dencoder.topDownCompute(encarr)[0].encoding, res[0].encoding))
def testEncodingVerification(self): DCNL DCSP feedIn = [1, 10, 4, 7, 9, 6, 3, 1] DCNL DCSP expectedOut = [0, 9, (-6), 3, 2, (-3), (-3), (-2)] DCNL DCSP self._dencoder.setStateLock(False) DCNL DCSP for i in range(len(feedIn)): DCNL DCSP  DCSP aseencode = np.zeros(100) DCNL DCSP  DCSP self._adaptscalar.encodeIntoArray(expectedOut[i], aseencode, learn=True) DCNL DCSP  DCSP delencode = np.zeros(100) DCNL DCSP  DCSP self._dencoder.encodeIntoArray(feedIn[i], delencode, learn=True) DCNL DCSP  DCSP self.assertTrue(np.array_equal(delencode[0], aseencode[0]))
def testLockingState(self): DCNL DCSP feedIn = [1, 10, 9, 7, 9, 6, 3, 1] DCNL DCSP expectedOut = [0, 9, (-6), 3, 2, (-3), (-3), (-2)] DCNL DCSP for i in range(len(feedIn)): DCNL DCSP  DCSP if (i == 3): DCNL DCSP  DCSP  DCSP self._dencoder.setStateLock(True) DCNL DCSP  DCSP aseencode = np.zeros(100) DCNL DCSP  DCSP self._adaptscalar.encodeIntoArray(expectedOut[i], aseencode, learn=True) DCNL DCSP  DCSP delencode = np.zeros(100) DCNL DCSP  DCSP if (i >= 3): DCNL DCSP  DCSP  DCSP self._dencoder.encodeIntoArray((feedIn[i] - feedIn[2]), delencode, learn=True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._dencoder.encodeIntoArray(expectedOut[i], delencode, learn=True) DCNL DCSP  DCSP self.assertTrue(np.array_equal(delencode[0], aseencode[0]))
def testDateEncoder(self): DCNL DCSP self.assertSequenceEqual(self._e.getDescription(), [('season', 0), ('day DCSP of DCSP week', 12), ('weekend', 19), ('time DCSP of DCSP day', 21)]) DCNL DCSP self.assertTrue(numpy.array_equal(self._expected, self._bits))
def testMissingValues(self): DCNL DCSP mvOutput = self._e.encode(SENTINEL_VALUE_FOR_MISSING_DATA) DCNL DCSP self.assertEqual(sum(mvOutput), 0)
def testDecoding(self): DCNL DCSP decoded = self._e.decode(self._bits) DCNL DCSP (fieldsDict, _) = decoded DCNL DCSP self.assertEqual(len(fieldsDict), 4) DCNL DCSP (ranges, _) = fieldsDict['season'] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertSequenceEqual(ranges[0], [305, 305]) DCNL DCSP (ranges, _) = fieldsDict['time DCSP of DCSP day'] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertSequenceEqual(ranges[0], [14.4, 14.4]) DCNL DCSP (ranges, _) = fieldsDict['day DCSP of DCSP week'] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertSequenceEqual(ranges[0], [3, 3]) DCNL DCSP (ranges, _) = fieldsDict['weekend'] DCNL DCSP self.assertEqual(len(ranges), 1) DCNL DCSP self.assertSequenceEqual(ranges[0], [0, 0])
def testTopDownCompute(self): DCNL DCSP topDown = self._e.topDownCompute(self._bits) DCNL DCSP topDownValues = numpy.array([elem.value for elem in topDown]) DCNL DCSP errs = (topDownValues - numpy.array([320.25, 3.5, 0.167, 14.8])) DCNL DCSP self.assertAlmostEqual(errs.max(), 0, 4)
def testBucketIndexSupport(self): DCNL DCSP bucketIndices = self._e.getBucketIndices(self._d) DCNL DCSP topDown = self._e.getBucketInfo(bucketIndices) DCNL DCSP topDownValues = numpy.array([elem.value for elem in topDown]) DCNL DCSP errs = (topDownValues - numpy.array([320.25, 3.5, 0.167, 14.8])) DCNL DCSP self.assertAlmostEqual(errs.max(), 0, 4) DCNL DCSP encodings = [] DCNL DCSP for x in topDown: DCNL DCSP  DCSP encodings.extend(x.encoding) DCNL DCSP self.assertTrue(numpy.array_equal(encodings, self._expected))
def testHoliday(self): DCNL DCSP e = DateEncoder(holiday=5, forced=True) DCNL DCSP holiday = numpy.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1], dtype='uint8') DCNL DCSP notholiday = numpy.array([1, 1, 1, 1, 1, 0, 0, 0, 0, 0], dtype='uint8') DCNL DCSP holiday2 = numpy.array([0, 0, 0, 1, 1, 1, 1, 1, 0, 0], dtype='uint8') DCNL DCSP d = datetime.datetime(2010, 12, 25, 4, 55) DCNL DCSP self.assertTrue(numpy.array_equal(e.encode(d), holiday)) DCNL DCSP d = datetime.datetime(2008, 12, 27, 4, 55) DCNL DCSP self.assertTrue(numpy.array_equal(e.encode(d), notholiday)) DCNL DCSP d = datetime.datetime(1999, 12, 26, 8, 0) DCNL DCSP self.assertTrue(numpy.array_equal(e.encode(d), holiday2)) DCNL DCSP d = datetime.datetime(2011, 12, 24, 16, 0) DCNL DCSP self.assertTrue(numpy.array_equal(e.encode(d), holiday2))
def testWeekend(self): DCNL DCSP e = DateEncoder(customDays=(21, ['sat', 'sun', 'fri']), forced=True) DCNL DCSP mon = DateEncoder(customDays=(21, 'Monday'), forced=True) DCNL DCSP e2 = DateEncoder(weekend=(21, 1), forced=True) DCNL DCSP d = datetime.datetime(1988, 5, 29, 20, 0) DCNL DCSP self.assertTrue(numpy.array_equal(e.encode(d), e2.encode(d))) DCNL DCSP for _ in range(300): DCNL DCSP  DCSP d = (d + datetime.timedelta(days=1)) DCNL DCSP  DCSP self.assertTrue(numpy.array_equal(e.encode(d), e2.encode(d))) DCNL DCSP  DCSP if (mon.decode(mon.encode(d))[0]['Monday'][0][0][0] == 1.0): DCNL DCSP  DCSP  DCSP self.assertEqual(d.weekday(), 0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.assertNotEqual(d.weekday(), 0)
def testEncodeArray(self): DCNL DCSP e = self._encoder(self.n, name=self.name) DCNL DCSP bitmap = [2, 7, 15, 18, 23] DCNL DCSP out = e.encode(bitmap) DCNL DCSP self.assertEqual(out.sum(), len(bitmap)) DCNL DCSP x = e.decode(out) DCNL DCSP self.assertIsInstance(x[0], dict) DCNL DCSP self.assertTrue((self.name in x[0]))
def testEncodeArrayInvalidW(self): DCNL DCSP e = self._encoder(self.n, 3, name=self.name) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP e.encode([2]) DCNL DCSP with self.assertRaises(ValueError): DCNL DCSP  DCSP e.encode([2, 7, 15, 18, 23])
def testClosenessScores(self): DCNL DCSP e = self._encoder(self.n, name=self.name) DCNL DCSP 'Identical DCSP => DCSP 1' DCNL DCSP bitmap1 = [2, 7, 15, 18, 23] DCNL DCSP bitmap2 = [2, 7, 15, 18, 23] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 1.0) DCNL DCSP 'No DCSP overlap DCSP => DCSP 0' DCNL DCSP bitmap1 = [2, 7, 15, 18, 23] DCNL DCSP bitmap2 = [3, 9, 14, 19, 24] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.0) DCNL DCSP 'Similar DCSP => DCSP 4 DCSP of DCSP 5 DCSP match' DCNL DCSP bitmap1 = [2, 7, 15, 18, 23] DCNL DCSP bitmap2 = [2, 7, 17, 18, 23] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.8) DCNL DCSP 'Little DCSP => DCSP 1 DCSP of DCSP 5 DCSP match' DCNL DCSP bitmap1 = [2, 7, 15, 18, 23] DCNL DCSP bitmap2 = [3, 7, 17, 19, 24] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.2) DCNL DCSP 'Extra DCSP active DCSP bit DCSP => DCSP off DCSP by DCSP 1 DCSP of DCSP 5' DCNL DCSP bitmap1 = [2, 7, 15, 18, 23] DCNL DCSP bitmap2 = [2, 7, 11, 15, 18, 23] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.8) DCNL DCSP 'Missing DCSP active DCSP bit DCSP => DCSP off DCSP by DCSP 1 DCSP of DCSP 5' DCNL DCSP bitmap1 = [2, 7, 15, 18, 23] DCNL DCSP bitmap2 = [2, 7, 18, 23] DCNL DCSP out1 = e.encode(bitmap1) DCNL DCSP out2 = e.encode(bitmap2) DCNL DCSP c = e.closenessScores(out1, out2) DCNL DCSP self.assertEqual(c[0], 0.8)
def testGetBucketValues(self): DCNL DCSP le = LogEncoder(w=5, resolution=0.1, minval=1, maxval=10000, name='amount', forced=True) DCNL DCSP inc = 0.1 DCNL DCSP exp = 0 DCNL DCSP expected = [] DCNL DCSP while (exp <= 4.0001): DCNL DCSP  DCSP val = (10 ** exp) DCNL DCSP  DCSP expected.append(val) DCNL DCSP  DCSP exp += inc DCNL DCSP expected = numpy.array(expected) DCNL DCSP actual = numpy.array(le.getBucketValues()) DCNL DCSP numpy.testing.assert_almost_equal(expected, actual, 7)
def testInitWithRadius(self): DCNL DCSP le = LogEncoder(w=1, radius=1, minval=1, maxval=10000, name='amount', forced=True) DCNL DCSP self.assertEqual(le.encoder.n, 5) DCNL DCSP value = 1.0 DCNL DCSP output = le.encode(value) DCNL DCSP expected = [1, 0, 0, 0, 0] DCNL DCSP expected = numpy.array(expected, dtype='uint8') DCNL DCSP self.assertTrue(numpy.array_equal(output, expected)) DCNL DCSP value = 100.0 DCNL DCSP output = le.encode(value) DCNL DCSP expected = [0, 0, 1, 0, 0] DCNL DCSP expected = numpy.array(expected, dtype='uint8') DCNL DCSP self.assertTrue(numpy.array_equal(output, expected))
def testInitWithN(self): DCNL DCSP n = 100 DCNL DCSP le = LogEncoder(n=n, forced=True) DCNL DCSP self.assertEqual(le.encoder.n, n)
def testMinvalMaxVal(self): DCNL DCSP self.assertRaises(ValueError, LogEncoder, n=100, minval=0, maxval=(-100), forced=True) DCNL DCSP self.assertRaises(ValueError, LogEncoder, n=100, minval=0, maxval=1e-07, forced=True) DCNL DCSP le = LogEncoder(n=100, minval=42, maxval=1300000000000.0, forced=True) DCNL DCSP expectedRadius = 0.552141792732 DCNL DCSP expectedResolution = 0.110428358546 DCNL DCSP self.assertAlmostEqual(le.encoder.radius, expectedRadius) DCNL DCSP self.assertAlmostEqual(le.encoder.resolution, expectedResolution)
def setUp(self): DCNL DCSP self.files = {} DCNL DCSP with tempfile.NamedTemporaryFile(prefix='nupic-default.xml-unittest-', delete=False) as outp: DCNL DCSP  DCSP self.addCleanup(os.remove, outp.name) DCNL DCSP  DCSP with open(resource_filename(__name__, 'conf/nupic-default.xml')) as inp: DCNL DCSP  DCSP  DCSP outp.write(inp.read()) DCNL DCSP  DCSP self.files['nupic-default.xml'] = outp.name DCNL DCSP with tempfile.NamedTemporaryFile(prefix='nupic-site.xml-unittest-', delete=False) as outp: DCNL DCSP  DCSP self.addCleanup(os.remove, outp.name) DCNL DCSP  DCSP with open(resource_filename(__name__, 'conf/nupic-site.xml')) as inp: DCNL DCSP  DCSP  DCSP outp.write(inp.read()) DCNL DCSP  DCSP self.files['nupic-site.xml'] = outp.name
def mockSleepTime(self, mockTime, mockSleep): DCNL DCSP class _TimeContainer(object, ): DCNL DCSP  DCSP accumulatedTime = 0 DCNL DCSP def testTime(): DCNL DCSP  DCSP return _TimeContainer.accumulatedTime DCNL DCSP def testSleep(duration): DCNL DCSP  DCSP _TimeContainer.accumulatedTime += duration DCNL DCSP mockTime.side_effect = testTime DCNL DCSP mockSleep.side_effect = testSleep
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryNoTimeForRetries(self, mockTime, mockSleep): DCNL DCSP self.mockSleepTime(mockTime, mockSleep) DCNL DCSP retryDecorator = decorators.retry(timeoutSec=0, initialRetryDelaySec=0.2, maxRetryDelaySec=10) DCNL DCSP testFunction = Mock(side_effect=TestParentException('Test DCSP exception'), __name__='testFunction', autospec=True) DCNL DCSP with self.assertRaises(TestParentException): DCNL DCSP  DCSP retryDecorator(testFunction)() DCNL DCSP self.assertFalse(mockSleep.called) DCNL DCSP testFunction.assert_called_once_with()
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryWaitsInitialRetryDelaySec(self, mockTime, mockSleep): DCNL DCSP self.mockSleepTime(mockTime, mockSleep) DCNL DCSP retryDecorator = decorators.retry(timeoutSec=30, initialRetryDelaySec=2, maxRetryDelaySec=10) DCNL DCSP testFunction = Mock(side_effect=TestParentException('Test DCSP exception'), __name__='testFunction', autospec=True) DCNL DCSP with self.assertRaises(TestParentException): DCNL DCSP  DCSP retryDecorator(testFunction)() DCNL DCSP self.assertEqual(mockSleep.mock_calls, [call(2), call(4), call(8), call(10), call(10)]) DCNL DCSP self.assertEqual(testFunction.call_count, 6)
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryRetryExceptionIncluded(self, mockTime, mockSleep): DCNL DCSP self.mockSleepTime(mockTime, mockSleep) DCNL DCSP retryDecorator = decorators.retry(timeoutSec=1, initialRetryDelaySec=1, maxRetryDelaySec=10, retryExceptions=(TestParentException,)) DCNL DCSP @retryDecorator DCNL DCSP def testFunction(): DCNL DCSP  DCSP raise TestChildException('Test DCSP exception') DCNL DCSP with self.assertRaises(TestChildException): DCNL DCSP  DCSP testFunction() DCNL DCSP self.assertEqual(mockSleep.call_count, 1)
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryRetryExceptionExcluded(self, mockTime, mockSleep): DCNL DCSP self.mockSleepTime(mockTime, mockSleep) DCNL DCSP class TestExceptionA(Exception, ): DCNL DCSP  DCSP pass DCNL DCSP class TestExceptionB(Exception, ): DCNL DCSP  DCSP pass DCNL DCSP retryDecorator = decorators.retry(timeoutSec=1, initialRetryDelaySec=1, maxRetryDelaySec=10, retryExceptions=(TestExceptionA,)) DCNL DCSP @retryDecorator DCNL DCSP def testFunction(): DCNL DCSP  DCSP raise TestExceptionB('Test DCSP exception') DCNL DCSP with self.assertRaises(TestExceptionB): DCNL DCSP  DCSP testFunction() DCNL DCSP self.assertEqual(mockSleep.call_count, 0)
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryRetryFilter(self, mockTime, mockSleep): DCNL DCSP self.mockSleepTime(mockTime, mockSleep) DCNL DCSP retryDecoratorTrueFilter = decorators.retry(timeoutSec=1, initialRetryDelaySec=1, maxRetryDelaySec=10, retryExceptions=(TestParentException,), retryFilter=(lambda _1, _2, _3: True)) DCNL DCSP @retryDecoratorTrueFilter DCNL DCSP def testFunctionTrue(): DCNL DCSP  DCSP raise TestChildException('Test DCSP exception') DCNL DCSP with self.assertRaises(TestChildException): DCNL DCSP  DCSP testFunctionTrue() DCNL DCSP self.assertEqual(mockSleep.call_count, 1) DCNL DCSP mockSleep.reset_mock() DCNL DCSP retryDecoratorFalseFilter = decorators.retry(timeoutSec=1, initialRetryDelaySec=1, maxRetryDelaySec=10, retryExceptions=(TestParentException,), retryFilter=(lambda _1, _2, _3: False)) DCNL DCSP @retryDecoratorFalseFilter DCNL DCSP def testFunctionFalse(): DCNL DCSP  DCSP raise TestChildException('Test DCSP exception') DCNL DCSP with self.assertRaises(TestChildException): DCNL DCSP  DCSP testFunctionFalse() DCNL DCSP self.assertEqual(mockSleep.call_count, 0)
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testReturnsExpectedWithExpectedArgs(self, mockTime, mockSleep): DCNL DCSP self.mockSleepTime(mockTime, mockSleep) DCNL DCSP retryDecorator = decorators.retry(timeoutSec=30, initialRetryDelaySec=2, maxRetryDelaySec=10) DCNL DCSP testFunction = Mock(return_value=321, __name__='testFunction', autospec=True) DCNL DCSP returnValue = retryDecorator(testFunction)(1, 2, a=3, b=4) DCNL DCSP self.assertEqual(returnValue, 321) DCNL DCSP testFunction.assert_called_once_with(1, 2, a=3, b=4)
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testNoRetryIfCallSucceeds(self, mockTime, mockSleep): DCNL DCSP self.mockSleepTime(mockTime, mockSleep) DCNL DCSP retryDecorator = decorators.retry(timeoutSec=30, initialRetryDelaySec=2, maxRetryDelaySec=10) DCNL DCSP testFunction = Mock(__name__='testFunction', autospec=True) DCNL DCSP retryDecorator(testFunction)() DCNL DCSP testFunction.assert_called_once_with()
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testFailsFirstSucceedsLater(self, mockTime, mockSleep): DCNL DCSP self.mockSleepTime(mockTime, mockSleep) DCNL DCSP retryDecorator = decorators.retry(timeoutSec=30, initialRetryDelaySec=2, maxRetryDelaySec=10) DCNL DCSP testFunction = Mock(side_effect=[TestParentException('Test DCSP exception DCSP 1'), TestParentException('Test DCSP exception DCSP 2'), 321], __name__='testFunction', autospec=True) DCNL DCSP returnValue = retryDecorator(testFunction)() DCNL DCSP self.assertEqual(returnValue, 321) DCNL DCSP self.assertEqual(testFunction.call_count, 3)
def testReadFromAndWriteToFile(self): DCNL DCSP class Bar(object, ): DCNL DCSP  DCSP pass DCNL DCSP class Foo(Bar, Serializable, ): DCNL DCSP  DCSP def __init__(self, bar): DCNL DCSP  DCSP  DCSP self.bar = bar DCNL DCSP  DCSP @classmethod DCNL DCSP  DCSP def getSchema(cls): DCNL DCSP  DCSP  DCSP return serializable_test_capnp.Foo DCNL DCSP  DCSP @classmethod DCNL DCSP  DCSP def read(cls, proto): DCNL DCSP  DCSP  DCSP foo = object.__new__(cls) DCNL DCSP  DCSP  DCSP foo.bar = proto.bar DCNL DCSP  DCSP  DCSP return foo DCNL DCSP  DCSP def write(self, proto): DCNL DCSP  DCSP  DCSP proto.bar = self.bar DCNL DCSP def _remove(fname): DCNL DCSP  DCSP if os.path.isfile(fname): DCNL DCSP  DCSP  DCSP os.remove(fname) DCNL DCSP self.addCleanup(_remove, 'foo.data') DCNL DCSP with open('foo.data', 'wb') as outp: DCNL DCSP  DCSP Foo('bar').writeToFile(outp) DCNL DCSP with open('foo.data', 'rb') as inp: DCNL DCSP  DCSP self.assertEqual(Foo.readFromFile(inp).bar, 'bar')
@classmethod DCNL def setUpClass(cls): DCNL DCSP for example in cls.examples: DCNL DCSP  DCSP predictionGenerator = _getPredictionsGenerator(cls.examplesDir, example) DCNL DCSP  DCSP for prediction in predictionGenerator(MAX_PREDICTIONS): DCNL DCSP  DCSP  DCSP cls.oneStepPredictions[example].append(prediction[0]) DCNL DCSP  DCSP  DCSP cls.oneStepConfidences[example].append(prediction[1]) DCNL DCSP  DCSP  DCSP cls.fiveStepPredictions[example].append(prediction[2]) DCNL DCSP  DCSP  DCSP cls.fiveStepConfidences[example].append(prediction[3])
def testExamplesDirExists(self): DCNL DCSP failMsg = ('Path DCSP to DCSP examples DCSP does DCSP not DCSP exist: DCSP %s' % ExamplesTest.examplesDir) DCNL DCSP self.assertTrue(os.path.exists(ExamplesTest.examplesDir), failMsg)
def testNumberOfOneStepPredictions(self): DCNL DCSP self.assertEquals(len(ExamplesTest.oneStepPredictions['opf']), len(ExamplesTest.oneStepPredictions['algo'])) DCNL DCSP self.assertEquals(len(ExamplesTest.oneStepPredictions['opf']), len(ExamplesTest.oneStepPredictions['network']))
@unittest.expectedFailure DCNL def testOneStepPredictionsOpfVsAlgo(self): DCNL DCSP for resultPair in zip(self.oneStepPredictions['opf'], self.oneStepPredictions['algo']): DCNL DCSP  DCSP assert_approx_equal(err_msg="one-step DCSP 'opf' DCSP and DCSP 'algo' DCSP differ", *resultPair)
@unittest.expectedFailure DCNL def testOneStepPredictionsOpfVsNetwork(self): DCNL DCSP for resultPair in zip(self.oneStepPredictions['opf'], self.oneStepPredictions['network']): DCNL DCSP  DCSP assert_approx_equal(err_msg="one-step DCSP 'opf' DCSP and DCSP 'network' DCSP differ", *resultPair)
@unittest.expectedFailure DCNL def testOneStepPredictionsAlgoVsNetwork(self): DCNL DCSP for resultPair in zip(self.oneStepPredictions['algo'], self.oneStepPredictions['network']): DCNL DCSP  DCSP assert_approx_equal(err_msg="one-step DCSP 'algo' DCSP and DCSP 'network' DCSP differ", *resultPair)
@unittest.expectedFailure DCNL def testFiveStepPredictionsOpfVsNetwork(self): DCNL DCSP for resultPair in zip(self.fiveStepPredictions['opf'], self.fiveStepPredictions['network']): DCNL DCSP  DCSP assert_approx_equal(err_msg="five-step DCSP 'opf' DCSP and DCSP 'network' DCSP differ", *resultPair)
@unittest.expectedFailure DCNL def testOneStepConfidencesOpfVsAlgo(self): DCNL DCSP for resultPair in zip(self.oneStepConfidences['opf'], self.oneStepConfidences['algo']): DCNL DCSP  DCSP assert_approx_equal(err_msg="one-step DCSP 'opf' DCSP and DCSP 'algo' DCSP differ", *resultPair)
@unittest.expectedFailure DCNL def testOneStepConfidencesOpfVsNetwork(self): DCNL DCSP for resultPair in zip(self.oneStepConfidences['opf'], self.oneStepConfidences['network']): DCNL DCSP  DCSP assert_approx_equal(err_msg="one-step DCSP 'opf' DCSP and DCSP 'network' DCSP differ", *resultPair)
@unittest.expectedFailure DCNL def testOneStepConfidencesAlgoVsNetwork(self): DCNL DCSP for resultPair in zip(self.oneStepConfidences['algo'], self.oneStepConfidences['network']): DCNL DCSP  DCSP assert_approx_equal(err_msg="one-step DCSP 'algo' DCSP and DCSP 'network' DCSP differ", *resultPair)
@unittest.expectedFailure DCNL def testFiveStepConfidencesOpfVsNetwork(self): DCNL DCSP for resultPair in zip(self.fiveStepConfidences['opf'], self.fiveStepConfidences['network']): DCNL DCSP  DCSP assert_approx_equal(err_msg="five-step DCSP 'opf' DCSP and DCSP 'network' DCSP differ", *resultPair)
def testBasic(self): DCNL DCSP filename = _getTempFileName() DCNL DCSP fields = [FieldMetaInfo('name', FieldMetaType.string, FieldMetaSpecial.none), FieldMetaInfo('timestamp', FieldMetaType.datetime, FieldMetaSpecial.timestamp), FieldMetaInfo('integer', FieldMetaType.integer, FieldMetaSpecial.none), FieldMetaInfo('real', FieldMetaType.float, FieldMetaSpecial.none), FieldMetaInfo('reset', FieldMetaType.integer, FieldMetaSpecial.reset), FieldMetaInfo('sid', FieldMetaType.string, FieldMetaSpecial.sequence), FieldMetaInfo('categoryField', FieldMetaType.integer, FieldMetaSpecial.category)] DCNL DCSP fieldNames = ['name', 'timestamp', 'integer', 'real', 'reset', 'sid', 'categoryField'] DCNL DCSP print 'Creating DCSP temp DCSP file:', filename DCNL DCSP with FileRecordStream(streamID=filename, write=True, fields=fields) as s: DCNL DCSP  DCSP self.assertEqual(0, s.getDataRowCount()) DCNL DCSP  DCSP records = (['rec_1', datetime(day=1, month=3, year=2010), 5, 6.5, 1, 'seq-1', 10], ['rec_2', datetime(day=2, month=3, year=2010), 8, 7.5, 0, 'seq-1', 11], ['rec_3', datetime(day=3, month=3, year=2010), 12, 8.5, 0, 'seq-1', 12]) DCNL DCSP  DCSP self.assertEqual(fields, s.getFields()) DCNL DCSP  DCSP self.assertEqual(0, s.getNextRecordIdx()) DCNL DCSP  DCSP print 'Writing DCSP records DCSP ...' DCNL DCSP  DCSP for r in records: DCNL DCSP  DCSP  DCSP print list(r) DCNL DCSP  DCSP  DCSP s.appendRecord(list(r)) DCNL DCSP  DCSP self.assertEqual(3, s.getDataRowCount()) DCNL DCSP  DCSP recordsBatch = (['rec_4', datetime(day=4, month=3, year=2010), 2, 9.5, 1, 'seq-1', 13], ['rec_5', datetime(day=5, month=3, year=2010), 6, 10.5, 0, 'seq-1', 14], ['rec_6', datetime(day=6, month=3, year=2010), 11, 11.5, 0, 'seq-1', 15]) DCNL DCSP  DCSP print 'Adding DCSP batch DCSP of DCSP records...' DCNL DCSP  DCSP for rec in recordsBatch: DCNL DCSP  DCSP  DCSP print rec DCNL DCSP  DCSP s.appendRecords(recordsBatch) DCNL DCSP  DCSP self.assertEqual(6, s.getDataRowCount()) DCNL DCSP with FileRecordStream(filename) as s: DCNL DCSP  DCSP self.assertEqual(6, s.getDataRowCount()) DCNL DCSP  DCSP self.assertEqual(fieldNames, s.getFieldNames()) DCNL DCSP  DCSP self.assertEqual(0, s.getNextRecordIdx()) DCNL DCSP  DCSP readStats = s.getStats() DCNL DCSP  DCSP print 'Got DCSP stats:', readStats DCNL DCSP  DCSP expectedStats = {'max': [None, None, 12, 11.5, 1, None, 15], 'min': [None, None, 2, 6.5, 0, None, 10]} DCNL DCSP  DCSP self.assertEqual(expectedStats, readStats) DCNL DCSP  DCSP readRecords = [] DCNL DCSP  DCSP print 'Reading DCSP records DCSP ...' DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP r = s.getNextRecord() DCNL DCSP  DCSP  DCSP print r DCNL DCSP  DCSP  DCSP if (r is None): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP readRecords.append(r) DCNL DCSP  DCSP allRecords = (records + recordsBatch) DCNL DCSP  DCSP for (r1, r2) in zip(allRecords, readRecords): DCNL DCSP  DCSP  DCSP self.assertEqual(r1, r2)
def testMultipleClasses(self): DCNL DCSP filename = _getTempFileName() DCNL DCSP fields = [FieldMetaInfo('name', FieldMetaType.string, FieldMetaSpecial.none), FieldMetaInfo('timestamp', FieldMetaType.datetime, FieldMetaSpecial.timestamp), FieldMetaInfo('integer', FieldMetaType.integer, FieldMetaSpecial.none), FieldMetaInfo('real', FieldMetaType.float, FieldMetaSpecial.none), FieldMetaInfo('reset', FieldMetaType.integer, FieldMetaSpecial.reset), FieldMetaInfo('sid', FieldMetaType.string, FieldMetaSpecial.sequence), FieldMetaInfo('categories', FieldMetaType.list, FieldMetaSpecial.category)] DCNL DCSP fieldNames = ['name', 'timestamp', 'integer', 'real', 'reset', 'sid', 'categories'] DCNL DCSP print 'Creating DCSP temp DCSP file:', filename DCNL DCSP with FileRecordStream(streamID=filename, write=True, fields=fields) as s: DCNL DCSP  DCSP self.assertEqual(0, s.getDataRowCount()) DCNL DCSP  DCSP records = (['rec_1', datetime(day=1, month=3, year=2010), 5, 6.5, 1, 'seq-1', [0, 1, 2]], ['rec_2', datetime(day=2, month=3, year=2010), 8, 7.5, 0, 'seq-1', [3, 4, 5]], ['rec_3', datetime(day=3, month=3, year=2010), 2, 8.5, 0, 'seq-1', [6, 7, 8]]) DCNL DCSP  DCSP self.assertEqual(fields, s.getFields()) DCNL DCSP  DCSP self.assertEqual(0, s.getNextRecordIdx()) DCNL DCSP  DCSP print 'Writing DCSP records DCSP ...' DCNL DCSP  DCSP for r in records: DCNL DCSP  DCSP  DCSP print r DCNL DCSP  DCSP  DCSP s.appendRecord(r) DCNL DCSP  DCSP self.assertEqual(3, s.getDataRowCount()) DCNL DCSP  DCSP recordsBatch = (['rec_4', datetime(day=4, month=3, year=2010), 2, 9.5, 1, 'seq-1', [2, 3, 4]], ['rec_5', datetime(day=5, month=3, year=2010), 6, 10.5, 0, 'seq-1', [3, 4, 5]], ['rec_6', datetime(day=6, month=3, year=2010), 11, 11.5, 0, 'seq-1', [4, 5, 6]]) DCNL DCSP  DCSP print 'Adding DCSP batch DCSP of DCSP records...' DCNL DCSP  DCSP for rec in recordsBatch: DCNL DCSP  DCSP  DCSP print rec DCNL DCSP  DCSP s.appendRecords(recordsBatch) DCNL DCSP  DCSP self.assertEqual(6, s.getDataRowCount()) DCNL DCSP with FileRecordStream(filename) as s: DCNL DCSP  DCSP self.assertEqual(6, s.getDataRowCount()) DCNL DCSP  DCSP self.assertEqual(fieldNames, s.getFieldNames()) DCNL DCSP  DCSP self.assertEqual(0, s.getNextRecordIdx()) DCNL DCSP  DCSP readStats = s.getStats() DCNL DCSP  DCSP print 'Got DCSP stats:', readStats DCNL DCSP  DCSP expectedStats = {'max': [None, None, 11, 11.5, 1, None, None], 'min': [None, None, 2, 6.5, 0, None, None]} DCNL DCSP  DCSP self.assertEqual(expectedStats, readStats) DCNL DCSP  DCSP readRecords = [] DCNL DCSP  DCSP print 'Reading DCSP records DCSP ...' DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP r = s.getNextRecord() DCNL DCSP  DCSP  DCSP print r DCNL DCSP  DCSP  DCSP if (r is None): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP readRecords.append(r) DCNL DCSP  DCSP expectedRecords = (['rec_1', datetime(day=1, month=3, year=2010), 5, 6.5, 1, 'seq-1', [0, 1, 2]], ['rec_2', datetime(day=2, month=3, year=2010), 8, 7.5, 0, 'seq-1', [3, 4, 5]], ['rec_3', datetime(day=3, month=3, year=2010), 2, 8.5, 0, 'seq-1', [6, 7, 8]], ['rec_4', datetime(day=4, month=3, year=2010), 2, 9.5, 1, 'seq-1', [2, 3, 4]], ['rec_5', datetime(day=5, month=3, year=2010), 6, 10.5, 0, 'seq-1', [3, 4, 5]], ['rec_6', datetime(day=6, month=3, year=2010), 11, 11.5, 0, 'seq-1', [4, 5, 6]]) DCNL DCSP  DCSP for (r1, r2) in zip(expectedRecords, readRecords): DCNL DCSP  DCSP  DCSP self.assertEqual(r1, r2)
@unittest.skip('Disabled DCSP until DCSP we DCSP figure DCSP out DCSP why DCSP it DCSP is DCSP failing DCSP in DCSP internal DCSP tests') DCNL def testDeltaFilter(self): DCNL DCSP r = RecordSensor() DCNL DCSP filename = resource_filename('nupic.datafiles', 'extra/qa/delta.csv') DCNL DCSP datasource = FileRecordStream(filename) DCNL DCSP r.dataSource = datasource DCNL DCSP n = 50 DCNL DCSP encoder = MultiEncoder({'blah': dict(fieldname='s', type='ScalarEncoder', n=n, w=11, minval=0, maxval=100)}) DCNL DCSP r.encoder = encoder DCNL DCSP resetOut = numpy.zeros((1,), dtype='float') DCNL DCSP sequenceIdOut = numpy.zeros((1,), dtype='float') DCNL DCSP dataOut = numpy.zeros((n,), dtype='float') DCNL DCSP sourceOut = numpy.zeros((1,), dtype='float') DCNL DCSP categoryOut = numpy.zeros((1,), dtype='float') DCNL DCSP outputs = dict(resetOut=resetOut, sourceOut=sourceOut, sequenceIdOut=sequenceIdOut, dataOut=dataOut, categoryOut=categoryOut) DCNL DCSP inputs = dict() DCNL DCSP r.verbosity = 0 DCNL DCSP r.compute(inputs, outputs) DCNL DCSP lr = r.lastRecord DCNL DCSP self.assertEqual(lr['t'], datetime(year=2011, month=2, day=24, hour=16, minute=8, second=0)) DCNL DCSP self.assertEqual(lr['s'], 10) DCNL DCSP self.assertEqual(lr['_reset'], 1) DCNL DCSP self.assertTrue(('dt' not in lr)) DCNL DCSP self.assertTrue(('ds' not in lr)) DCNL DCSP r.compute(inputs, outputs) DCNL DCSP lr = r.lastRecord DCNL DCSP self.assertEqual(lr['t'], datetime(year=2011, month=2, day=24, hour=16, minute=8, second=1)) DCNL DCSP self.assertEqual(lr['s'], 20) DCNL DCSP self.assertEqual(lr['_reset'], 0) DCNL DCSP r.compute(inputs, outputs) DCNL DCSP lr = r.lastRecord DCNL DCSP self.assertEqual(lr['t'], datetime(year=2011, month=2, day=25, hour=16, minute=8, second=0)) DCNL DCSP self.assertEqual(lr['s'], 50) DCNL DCSP self.assertEqual(lr['_reset'], 0) DCNL DCSP r.compute(inputs, outputs) DCNL DCSP lr = r.lastRecord DCNL DCSP self.assertEqual(lr['t'], datetime(year=2011, month=2, day=25, hour=16, minute=8, second=1)) DCNL DCSP self.assertEqual(lr['s'], 60) DCNL DCSP self.assertEqual(lr['_reset'], 1) DCNL DCSP r.compute(inputs, outputs) DCNL DCSP lr = r.lastRecord DCNL DCSP self.assertEqual(lr['t'], datetime(year=2011, month=2, day=25, hour=16, minute=8, second=3)) DCNL DCSP self.assertEqual(lr['s'], 65) DCNL DCSP self.assertEqual(lr['_reset'], 0) DCNL DCSP r.preEncodingFilters = [DeltaFilter('s', 'ds'), DeltaFilter('t', 'dt')] DCNL DCSP r.rewind() DCNL DCSP r.compute(inputs, outputs) DCNL DCSP lr = r.lastRecord DCNL DCSP self.assertEqual(lr['t'], datetime(year=2011, month=2, day=24, hour=16, minute=8, second=1)) DCNL DCSP self.assertEqual(lr['s'], 20) DCNL DCSP self.assertEqual(lr['_reset'], 1) DCNL DCSP self.assertEqual(lr['dt'], 1) DCNL DCSP self.assertEqual(lr['ds'], 10) DCNL DCSP r.compute(inputs, outputs) DCNL DCSP lr = r.lastRecord DCNL DCSP self.assertEqual(lr['t'], datetime(year=2011, month=2, day=25, hour=16, minute=8, second=0)) DCNL DCSP self.assertEqual(lr['s'], 50) DCNL DCSP self.assertEqual(lr['_reset'], 0) DCNL DCSP self.assertEqual(lr['dt'], ((3600 * 24) - 1)) DCNL DCSP self.assertEqual(lr['ds'], 30) DCNL DCSP r.compute(inputs, outputs) DCNL DCSP lr = r.lastRecord DCNL DCSP self.assertEqual(lr['t'], datetime(year=2011, month=2, day=25, hour=16, minute=8, second=3)) DCNL DCSP self.assertEqual(lr['s'], 65) DCNL DCSP self.assertEqual(lr['_reset'], 1) DCNL DCSP self.assertEqual(lr['dt'], 2) DCNL DCSP self.assertEqual(lr['ds'], 5)
def getNextRecord(self, useCache=True): DCNL DCSP pass
def getFieldNames(self): DCNL DCSP return self._fieldNames
def getFields(self): DCNL DCSP return self._fieldsMeta
def testMovingAverage(self): DCNL DCSP historicalValues = [] DCNL DCSP total = 0 DCNL DCSP windowSize = 3 DCNL DCSP (newAverage, historicalValues, total) = MovingAverage.compute(historicalValues, total, 3, windowSize) DCNL DCSP self.assertEqual(newAverage, 3.0) DCNL DCSP self.assertEqual(historicalValues, [3.0]) DCNL DCSP self.assertEqual(total, 3.0) DCNL DCSP (newAverage, historicalValues, total) = MovingAverage.compute(historicalValues, total, 4, windowSize) DCNL DCSP self.assertEqual(newAverage, 3.5) DCNL DCSP self.assertListEqual(historicalValues, [3.0, 4.0]) DCNL DCSP self.assertEqual(total, 7.0) DCNL DCSP (newAverage, historicalValues, total) = MovingAverage.compute(historicalValues, total, 5.0, windowSize) DCNL DCSP self.assertEqual(newAverage, 4.0) DCNL DCSP self.assertListEqual(historicalValues, [3.0, 4.0, 5.0]) DCNL DCSP self.assertEqual(total, 12.0) DCNL DCSP (newAverage, historicalValues, total) = MovingAverage.compute(historicalValues, total, 6.0, windowSize) DCNL DCSP self.assertEqual(newAverage, 5.0) DCNL DCSP self.assertListEqual(historicalValues, [4.0, 5.0, 6.0]) DCNL DCSP self.assertEqual(total, 15.0)
def testMovingAverageInstance(self): DCNL DCSP ma = MovingAverage(windowSize=3) DCNL DCSP newAverage = ma.next(3) DCNL DCSP self.assertEqual(newAverage, 3.0) DCNL DCSP self.assertListEqual(ma.getSlidingWindow(), [3.0]) DCNL DCSP self.assertEqual(ma.total, 3.0) DCNL DCSP newAverage = ma.next(4) DCNL DCSP self.assertEqual(newAverage, 3.5) DCNL DCSP self.assertListEqual(ma.getSlidingWindow(), [3.0, 4.0]) DCNL DCSP self.assertEqual(ma.total, 7.0) DCNL DCSP newAverage = ma.next(5) DCNL DCSP self.assertEqual(newAverage, 4.0) DCNL DCSP self.assertListEqual(ma.getSlidingWindow(), [3.0, 4.0, 5.0]) DCNL DCSP self.assertEqual(ma.total, 12.0) DCNL DCSP newAverage = ma.next(6) DCNL DCSP self.assertEqual(newAverage, 5.0) DCNL DCSP self.assertListEqual(ma.getSlidingWindow(), [4.0, 5.0, 6.0]) DCNL DCSP self.assertEqual(ma.total, 15.0)
def testMovingAverageSlidingWindowInit(self): DCNL DCSP ma = MovingAverage(windowSize=3, existingHistoricalValues=[3.0, 4.0, 5.0]) DCNL DCSP self.assertListEqual(ma.getSlidingWindow(), [3.0, 4.0, 5.0]) DCNL DCSP ma = MovingAverage(windowSize=3) DCNL DCSP self.assertListEqual(ma.getSlidingWindow(), [])
def testSerialization(self): DCNL DCSP ma = MovingAverage(windowSize=3) DCNL DCSP ma.next(3) DCNL DCSP ma.next(4.5) DCNL DCSP ma.next(5) DCNL DCSP stored = pickle.dumps(ma) DCNL DCSP restored = pickle.loads(stored) DCNL DCSP self.assertEqual(restored, ma) DCNL DCSP self.assertEqual(ma.next(6), restored.next(6))
def fromutc(self, dt): DCNL DCSP return (dt + self._utcoffset).replace(tzinfo=self)
def utcoffset(self, dt): DCNL DCSP return self._utcoffset
def dst(self, dt): DCNL DCSP return _notime
def tzname(self, dt): DCNL DCSP return self._tzname
def localize(self, dt, is_dst=False): DCNL DCSP if (dt.tzinfo is not None): DCNL DCSP  DCSP raise ValueError, 'Not DCSP naive DCSP datetime DCSP (tzinfo DCSP is DCSP already DCSP set)' DCNL DCSP return dt.replace(tzinfo=self)
def normalize(self, dt, is_dst=False): DCNL DCSP if (dt.tzinfo is None): DCNL DCSP  DCSP raise ValueError, 'Naive DCSP time DCSP - DCSP no DCSP tzinfo DCSP set' DCNL DCSP return dt.replace(tzinfo=self)
def fromutc(self, dt): DCNL DCSP dt = dt.replace(tzinfo=None) DCNL DCSP idx = max(0, (bisect_right(self._utc_transition_times, dt) - 1)) DCNL DCSP inf = self._transition_info[idx] DCNL DCSP return (dt + inf[0]).replace(tzinfo=self._tzinfos[inf])
def normalize(self, dt): DCNL DCSP if (dt.tzinfo is None): DCNL DCSP  DCSP raise ValueError, 'Naive DCSP time DCSP - DCSP no DCSP tzinfo DCSP set' DCNL DCSP offset = dt.tzinfo._utcoffset DCNL DCSP dt = dt.replace(tzinfo=None) DCNL DCSP dt = (dt - offset) DCNL DCSP return self.fromutc(dt)
def localize(self, dt, is_dst=False): DCNL DCSP if (dt.tzinfo is not None): DCNL DCSP  DCSP raise ValueError, 'Not DCSP naive DCSP datetime DCSP (tzinfo DCSP is DCSP already DCSP set)' DCNL DCSP possible_loc_dt = set() DCNL DCSP for tzinfo in self._tzinfos.values(): DCNL DCSP  DCSP loc_dt = tzinfo.normalize(dt.replace(tzinfo=tzinfo)) DCNL DCSP  DCSP if (loc_dt.replace(tzinfo=None) == dt): DCNL DCSP  DCSP  DCSP possible_loc_dt.add(loc_dt) DCNL DCSP if (len(possible_loc_dt) == 1): DCNL DCSP  DCSP return possible_loc_dt.pop() DCNL DCSP if (is_dst is None): DCNL DCSP  DCSP raise AmbiguousTimeError(dt) DCNL DCSP filtered_possible_loc_dt = [p for p in possible_loc_dt if (bool(p.tzinfo._dst) == is_dst)] DCNL DCSP if (len(filtered_possible_loc_dt) == 1): DCNL DCSP  DCSP return filtered_possible_loc_dt[0] DCNL DCSP if (len(filtered_possible_loc_dt) == 0): DCNL DCSP  DCSP filtered_possible_loc_dt = list(possible_loc_dt) DCNL DCSP def mycmp(a, b): DCNL DCSP  DCSP return cmp((a.replace(tzinfo=None) - a.tzinfo._utcoffset), (b.replace(tzinfo=None) - b.tzinfo._utcoffset)) DCNL DCSP filtered_possible_loc_dt.sort(mycmp) DCNL DCSP return filtered_possible_loc_dt[0]
def utcoffset(self, dt): DCNL DCSP return self._utcoffset
def dst(self, dt): DCNL DCSP return self._dst
def tzname(self, dt): DCNL DCSP return self._tzname
def localize(self, dt, is_dst=False): DCNL DCSP if (dt.tzinfo is not None): DCNL DCSP  DCSP raise ValueError, 'Not DCSP naive DCSP datetime DCSP (tzinfo DCSP is DCSP already DCSP set)' DCNL DCSP return dt.replace(tzinfo=self)
def normalize(self, dt, is_dst=False): DCNL DCSP if (dt.tzinfo is None): DCNL DCSP  DCSP raise ValueError, 'Naive DCSP time DCSP - DCSP no DCSP tzinfo DCSP set' DCNL DCSP return dt.replace(tzinfo=self)
def localize(self, dt, is_dst=False): DCNL DCSP if (dt.tzinfo is not None): DCNL DCSP  DCSP raise ValueError, 'Not DCSP naive DCSP datetime DCSP (tzinfo DCSP is DCSP already DCSP set)' DCNL DCSP return dt.replace(tzinfo=self)
def normalize(self, dt, is_dst=False): DCNL DCSP if (dt.tzinfo is None): DCNL DCSP  DCSP raise ValueError, 'Naive DCSP time DCSP - DCSP no DCSP tzinfo DCSP set' DCNL DCSP return dt.replace(tzinfo=self)
def __init__(self, entries=None): DCNL DCSP self.entries = [] DCNL DCSP self.entry_keys = {} DCNL DCSP self.by_key = {} DCNL DCSP self.callbacks = [] DCNL DCSP if (entries is None): DCNL DCSP  DCSP entries = sys.path DCNL DCSP for entry in entries: DCNL DCSP  DCSP self.add_entry(entry)
def add_entry(self, entry): DCNL DCSP self.entry_keys.setdefault(entry, []) DCNL DCSP self.entries.append(entry) DCNL DCSP for dist in find_distributions(entry, True): DCNL DCSP  DCSP self.add(dist, entry, False)
def __contains__(self, dist): DCNL DCSP return (self.by_key.get(dist.key) == dist)
def find(self, req): DCNL DCSP dist = self.by_key.get(req.key) DCNL DCSP if ((dist is not None) and (dist not in req)): DCNL DCSP  DCSP raise VersionConflict(dist, req) DCNL DCSP else: DCNL DCSP  DCSP return dist
def iter_entry_points(self, group, name=None): DCNL DCSP for dist in self: DCNL DCSP  DCSP entries = dist.get_entry_map(group) DCNL DCSP  DCSP if (name is None): DCNL DCSP  DCSP  DCSP for ep in entries.values(): DCNL DCSP  DCSP  DCSP  DCSP (yield ep) DCNL DCSP  DCSP elif (name in entries): DCNL DCSP  DCSP  DCSP (yield entries[name])
def run_script(self, requires, script_name): DCNL DCSP ns = sys._getframe(1).f_globals DCNL DCSP name = ns['__name__'] DCNL DCSP ns.clear() DCNL DCSP ns['__name__'] = name DCNL DCSP self.require(requires)[0].run_script(script_name, ns)
def __iter__(self): DCNL DCSP seen = {} DCNL DCSP for item in self.entries: DCNL DCSP  DCSP for key in self.entry_keys[item]: DCNL DCSP  DCSP  DCSP if (key not in seen): DCNL DCSP  DCSP  DCSP  DCSP seen[key] = 1 DCNL DCSP  DCSP  DCSP  DCSP (yield self.by_key[key])
def add(self, dist, entry=None, insert=True): DCNL DCSP if insert: DCNL DCSP  DCSP dist.insert_on(self.entries, entry) DCNL DCSP if (entry is None): DCNL DCSP  DCSP entry = dist.location DCNL DCSP keys = self.entry_keys.setdefault(entry, []) DCNL DCSP keys2 = self.entry_keys.setdefault(dist.location, []) DCNL DCSP if (dist.key in self.by_key): DCNL DCSP  DCSP return DCNL DCSP self.by_key[dist.key] = dist DCNL DCSP if (dist.key not in keys): DCNL DCSP  DCSP keys.append(dist.key) DCNL DCSP if (dist.key not in keys2): DCNL DCSP  DCSP keys2.append(dist.key) DCNL DCSP self._added_new(dist)
def resolve(self, requirements, env=None, installer=None): DCNL DCSP requirements = list(requirements)[::(-1)] DCNL DCSP processed = {} DCNL DCSP best = {} DCNL DCSP to_activate = [] DCNL DCSP while requirements: DCNL DCSP  DCSP req = requirements.pop(0) DCNL DCSP  DCSP if (req in processed): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP dist = best.get(req.key) DCNL DCSP  DCSP if (dist is None): DCNL DCSP  DCSP  DCSP dist = self.by_key.get(req.key) DCNL DCSP  DCSP  DCSP if (dist is None): DCNL DCSP  DCSP  DCSP  DCSP if (env is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP env = Environment(self.entries) DCNL DCSP  DCSP  DCSP  DCSP dist = best[req.key] = env.best_match(req, self, installer) DCNL DCSP  DCSP  DCSP  DCSP if (dist is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DistributionNotFound(req) DCNL DCSP  DCSP  DCSP to_activate.append(dist) DCNL DCSP  DCSP if (dist not in req): DCNL DCSP  DCSP  DCSP raise VersionConflict(dist, req) DCNL DCSP  DCSP requirements.extend(dist.requires(req.extras)[::(-1)]) DCNL DCSP  DCSP processed[req] = True DCNL DCSP return to_activate
def find_plugins(self, plugin_env, full_env=None, installer=None, fallback=True): DCNL DCSP plugin_projects = list(plugin_env) DCNL DCSP plugin_projects.sort() DCNL DCSP error_info = {} DCNL DCSP distributions = {} DCNL DCSP if (full_env is None): DCNL DCSP  DCSP env = Environment(self.entries) DCNL DCSP  DCSP env += plugin_env DCNL DCSP else: DCNL DCSP  DCSP env = (full_env + plugin_env) DCNL DCSP shadow_set = self.__class__([]) DCNL DCSP map(shadow_set.add, self) DCNL DCSP for project_name in plugin_projects: DCNL DCSP  DCSP for dist in plugin_env[project_name]: DCNL DCSP  DCSP  DCSP req = [dist.as_requirement()] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP resolvees = shadow_set.resolve(req, env, installer) DCNL DCSP  DCSP  DCSP except ResolutionError as v: DCNL DCSP  DCSP  DCSP  DCSP error_info[dist] = v DCNL DCSP  DCSP  DCSP  DCSP if fallback: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP map(shadow_set.add, resolvees) DCNL DCSP  DCSP  DCSP  DCSP distributions.update(dict.fromkeys(resolvees)) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP distributions = list(distributions) DCNL DCSP distributions.sort() DCNL DCSP return (distributions, error_info)
def require(self, *requirements): DCNL DCSP needed = self.resolve(parse_requirements(requirements)) DCNL DCSP for dist in needed: DCNL DCSP  DCSP self.add(dist) DCNL DCSP return needed
def subscribe(self, callback): DCNL DCSP if (callback in self.callbacks): DCNL DCSP  DCSP return DCNL DCSP self.callbacks.append(callback) DCNL DCSP for dist in self: DCNL DCSP  DCSP callback(dist)
def __init__(self, search_path=None, platform=get_supported_platform(), python=PY_MAJOR): DCNL DCSP self._distmap = {} DCNL DCSP self._cache = {} DCNL DCSP self.platform = platform DCNL DCSP self.python = python DCNL DCSP self.scan(search_path)
def can_add(self, dist): DCNL DCSP return (((self.python is None) or (dist.py_version is None) or (dist.py_version == self.python)) and compatible_platforms(dist.platform, self.platform))
def remove(self, dist): DCNL DCSP self._distmap[dist.key].remove(dist)
def scan(self, search_path=None): DCNL DCSP if (search_path is None): DCNL DCSP  DCSP search_path = sys.path DCNL DCSP for item in search_path: DCNL DCSP  DCSP for dist in find_distributions(item): DCNL DCSP  DCSP  DCSP self.add(dist)
def __getitem__(self, project_name): DCNL DCSP try: DCNL DCSP  DCSP return self._cache[project_name] DCNL DCSP except KeyError: DCNL DCSP  DCSP project_name = project_name.lower() DCNL DCSP  DCSP if (project_name not in self._distmap): DCNL DCSP  DCSP  DCSP return [] DCNL DCSP if (project_name not in self._cache): DCNL DCSP  DCSP dists = self._cache[project_name] = self._distmap[project_name] DCNL DCSP  DCSP _sort_dists(dists) DCNL DCSP return self._cache[project_name]
def add(self, dist): DCNL DCSP if (self.can_add(dist) and dist.has_version()): DCNL DCSP  DCSP dists = self._distmap.setdefault(dist.key, []) DCNL DCSP  DCSP if (dist not in dists): DCNL DCSP  DCSP  DCSP dists.append(dist) DCNL DCSP  DCSP  DCSP if (dist.key in self._cache): DCNL DCSP  DCSP  DCSP  DCSP _sort_dists(self._cache[dist.key])
def best_match(self, req, working_set, installer=None): DCNL DCSP dist = working_set.find(req) DCNL DCSP if (dist is not None): DCNL DCSP  DCSP return dist DCNL DCSP for dist in self[req.key]: DCNL DCSP  DCSP if (dist in req): DCNL DCSP  DCSP  DCSP return dist DCNL DCSP return self.obtain(req, installer)
def obtain(self, requirement, installer=None): DCNL DCSP if (installer is not None): DCNL DCSP  DCSP return installer(requirement)
def __iter__(self): DCNL DCSP for key in self._distmap.keys(): DCNL DCSP  DCSP if self[key]: DCNL DCSP  DCSP  DCSP (yield key)
def __iadd__(self, other): DCNL DCSP if isinstance(other, Distribution): DCNL DCSP  DCSP self.add(other) DCNL DCSP elif isinstance(other, Environment): DCNL DCSP  DCSP for project in other: DCNL DCSP  DCSP  DCSP for dist in other[project]: DCNL DCSP  DCSP  DCSP  DCSP self.add(dist) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(("Can't DCSP add DCSP %r DCSP to DCSP environment" % (other,))) DCNL DCSP return self
def __add__(self, other): DCNL DCSP new = self.__class__([], platform=None, python=None) DCNL DCSP for env in (self, other): DCNL DCSP  DCSP new += env DCNL DCSP return new
def resource_exists(self, package_or_requirement, resource_name): DCNL DCSP return get_provider(package_or_requirement).has_resource(resource_name)
def resource_isdir(self, package_or_requirement, resource_name): DCNL DCSP return get_provider(package_or_requirement).resource_isdir(resource_name)
def resource_filename(self, package_or_requirement, resource_name): DCNL DCSP return get_provider(package_or_requirement).get_resource_filename(self, resource_name)
def resource_stream(self, package_or_requirement, resource_name): DCNL DCSP return get_provider(package_or_requirement).get_resource_stream(self, resource_name)
def resource_string(self, package_or_requirement, resource_name): DCNL DCSP return get_provider(package_or_requirement).get_resource_string(self, resource_name)
def resource_listdir(self, package_or_requirement, resource_name): DCNL DCSP return get_provider(package_or_requirement).resource_listdir(resource_name)
def extraction_error(self): DCNL DCSP old_exc = sys.exc_info()[1] DCNL DCSP cache_path = (self.extraction_path or get_default_cache()) DCNL DCSP err = ExtractionError(("Can't DCSP extract DCSP file(s) DCSP to DCSP egg DCSP cache\n\nThe DCSP following DCSP error DCSP occurred DCSP while DCSP trying DCSP to DCSP extract DCSP file(s) DCSP to DCSP the DCSP Python DCSP egg\ncache:\n\n DCSP  DCSP %s\n\nThe DCSP Python DCSP egg DCSP cache DCSP directory DCSP is DCSP currently DCSP set DCSP to:\n\n DCSP  DCSP %s\n\nPerhaps DCSP your DCSP account DCSP does DCSP not DCSP have DCSP write DCSP access DCSP to DCSP this DCSP directory? DCSP  DCSP You DCSP can\nchange DCSP the DCSP cache DCSP directory DCSP by DCSP setting DCSP the DCSP PYTHON_EGG_CACHE DCSP environment\nvariable DCSP to DCSP point DCSP to DCSP an DCSP accessible DCSP directory.\n" % (old_exc, cache_path))) DCNL DCSP err.manager = self DCNL DCSP err.cache_path = cache_path DCNL DCSP err.original_error = old_exc DCNL DCSP raise err
def get_cache_path(self, archive_name, names=()): DCNL DCSP extract_path = (self.extraction_path or get_default_cache()) DCNL DCSP target_path = os.path.join(extract_path, (archive_name + '-tmp'), *names) DCNL DCSP try: DCNL DCSP  DCSP ensure_directory(target_path) DCNL DCSP except: DCNL DCSP  DCSP self.extraction_error() DCNL DCSP self.cached_files[target_path] = 1 DCNL DCSP return target_path
def postprocess(self, tempname, filename): DCNL DCSP if (os.name == 'posix'): DCNL DCSP  DCSP mode = ((os.stat(tempname).st_mode | 365) & 4095) DCNL DCSP  DCSP os.chmod(tempname, mode)
def set_extraction_path(self, path): DCNL DCSP if self.cached_files: DCNL DCSP  DCSP raise ValueError("Can't DCSP change DCSP extraction DCSP path, DCSP files DCSP already DCSP extracted") DCNL DCSP self.extraction_path = path
def __init__(self, importer): DCNL DCSP self.zipinfo = zipimport._zip_directory_cache[importer.archive] DCNL DCSP self.zip_pre = (importer.archive + os.sep) DCNL DCSP self.loader = importer DCNL DCSP if importer.prefix: DCNL DCSP  DCSP self.module_path = os.path.join(importer.archive, importer.prefix) DCNL DCSP else: DCNL DCSP  DCSP self.module_path = importer.archive DCNL DCSP self._setup_prefix()
def parse(cls, src, dist=None): DCNL DCSP try: DCNL DCSP  DCSP attrs = extras = () DCNL DCSP  DCSP (name, value) = src.split('=', 1) DCNL DCSP  DCSP if ('[' in value): DCNL DCSP  DCSP  DCSP (value, extras) = value.split('[', 1) DCNL DCSP  DCSP  DCSP req = Requirement.parse(('x[' + extras)) DCNL DCSP  DCSP  DCSP if req.specs: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError DCNL DCSP  DCSP  DCSP extras = req.extras DCNL DCSP  DCSP if (':' in value): DCNL DCSP  DCSP  DCSP (value, attrs) = value.split(':', 1) DCNL DCSP  DCSP  DCSP if (not MODULE(attrs.rstrip())): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError DCNL DCSP  DCSP  DCSP attrs = attrs.rstrip().split('.') DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError("EntryPoint DCSP must DCSP be DCSP in DCSP 'name=module:attrs DCSP [extras]' DCSP format", src) DCNL DCSP else: DCNL DCSP  DCSP return cls(name.strip(), value.strip(), attrs, extras, dist)
def parse_group(cls, group, lines, dist=None): DCNL DCSP if (not MODULE(group)): DCNL DCSP  DCSP raise ValueError('Invalid DCSP group DCSP name', group) DCNL DCSP this = {} DCNL DCSP for line in yield_lines(lines): DCNL DCSP  DCSP ep = cls.parse(line, dist) DCNL DCSP  DCSP if (ep.name in this): DCNL DCSP  DCSP  DCSP raise ValueError('Duplicate DCSP entry DCSP point', group, ep.name) DCNL DCSP  DCSP this[ep.name] = ep DCNL DCSP return this
def parse_map(cls, data, dist=None): DCNL DCSP if isinstance(data, dict): DCNL DCSP  DCSP data = data.items() DCNL DCSP else: DCNL DCSP  DCSP data = split_sections(data) DCNL DCSP maps = {} DCNL DCSP for (group, lines) in data: DCNL DCSP  DCSP if (group is None): DCNL DCSP  DCSP  DCSP if (not lines): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP raise ValueError('Entry DCSP points DCSP must DCSP be DCSP listed DCSP in DCSP groups') DCNL DCSP  DCSP group = group.strip() DCNL DCSP  DCSP if (group in maps): DCNL DCSP  DCSP  DCSP raise ValueError('Duplicate DCSP group DCSP name', group) DCNL DCSP  DCSP maps[group] = cls.parse_group(group, lines, dist) DCNL DCSP return maps
def requires(self, extras=()): DCNL DCSP dm = self._dep_map DCNL DCSP deps = [] DCNL DCSP deps.extend(dm.get(None, ())) DCNL DCSP for ext in extras: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP deps.extend(dm[safe_extra(ext)]) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise UnknownExtra(('%s DCSP has DCSP no DCSP such DCSP extra DCSP feature DCSP %r' % (self, ext))) DCNL DCSP return deps
def activate(self, path=None): DCNL DCSP if (path is None): DCNL DCSP  DCSP path = sys.path DCNL DCSP self.insert_on(path) DCNL DCSP if (path is sys.path): DCNL DCSP  DCSP fixup_namespace_packages(self.location) DCNL DCSP  DCSP map(declare_namespace, self._get_metadata('namespace_packages.txt'))
def egg_name(self): DCNL DCSP filename = ('%s-%s-py%s' % (to_filename(self.project_name), to_filename(self.version), (self.py_version or PY_MAJOR))) DCNL DCSP if self.platform: DCNL DCSP  DCSP filename += ('-' + self.platform) DCNL DCSP return filename
def __getattr__(self, attr): DCNL DCSP if attr.startswith('_'): DCNL DCSP  DCSP raise AttributeError, attr DCNL DCSP return getattr(self._provider, attr)
def as_requirement(self): DCNL DCSP return Requirement.parse(('%s==%s' % (self.project_name, self.version)))
def load_entry_point(self, group, name): DCNL DCSP ep = self.get_entry_info(group, name) DCNL DCSP if (ep is None): DCNL DCSP  DCSP raise ImportError(('Entry DCSP point DCSP %r DCSP not DCSP found' % ((group, name),))) DCNL DCSP return ep.load()
def get_entry_map(self, group=None): DCNL DCSP try: DCNL DCSP  DCSP ep_map = self._ep_map DCNL DCSP except AttributeError: DCNL DCSP  DCSP ep_map = self._ep_map = EntryPoint.parse_map(self._get_metadata('entry_points.txt'), self) DCNL DCSP if (group is not None): DCNL DCSP  DCSP return ep_map.get(group, {}) DCNL DCSP return ep_map
def get_entry_info(self, group, name): DCNL DCSP return self.get_entry_map(group).get(name)
def insert_on(self, path, loc=None): DCNL DCSP loc = (loc or self.location) DCNL DCSP if (not loc): DCNL DCSP  DCSP return DCNL DCSP if (path is sys.path): DCNL DCSP  DCSP self.check_version_conflict() DCNL DCSP nloc = _normalize_cached(loc) DCNL DCSP bdir = os.path.dirname(nloc) DCNL DCSP npath = map(_normalize_cached, path) DCNL DCSP bp = None DCNL DCSP for (p, item) in enumerate(npath): DCNL DCSP  DCSP if (item == nloc): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif ((item == bdir) and (self.precedence == EGG_DIST)): DCNL DCSP  DCSP  DCSP path.insert(p, loc) DCNL DCSP  DCSP  DCSP npath.insert(p, nloc) DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP path.append(loc) DCNL DCSP  DCSP return DCNL DCSP while 1: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP np = npath.index(nloc, (p + 1)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP del npath[np], path[np] DCNL DCSP  DCSP  DCSP p = np DCNL DCSP return
def clone(self, **kw): DCNL DCSP for attr in ('project_name', 'version', 'py_version', 'platform', 'location', 'precedence'): DCNL DCSP  DCSP kw.setdefault(attr, getattr(self, attr, None)) DCNL DCSP kw.setdefault('metadata', self._provider) DCNL DCSP return self.__class__(**kw)
def __init__(self, project_name, specs, extras): DCNL DCSP (self.unsafe_name, project_name) = (project_name, safe_name(project_name)) DCNL DCSP (self.project_name, self.key) = (project_name, project_name.lower()) DCNL DCSP index = [(parse_version(v), state_machine[op], op, v) for (op, v) in specs] DCNL DCSP index.sort() DCNL DCSP self.specs = [(op, ver) for (parsed, trans, op, ver) in index] DCNL DCSP (self.index, self.extras) = (index, tuple(map(safe_extra, extras))) DCNL DCSP self.hashCmp = (self.key, tuple([(op, parsed) for (parsed, trans, op, ver) in index]), frozenset(self.extras)) DCNL DCSP self.__hash = hash(self.hashCmp)
def clabel(self, *args, **kwargs): DCNL DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP NOTES DCSP on DCSP how DCSP this DCSP all DCSP works:\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP clabel DCSP basically DCSP takes DCSP the DCSP input DCSP arguments DCSP and DCSP uses DCSP them DCSP to\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP add DCSP a DCSP list DCSP of DCSP "label DCSP specific" DCSP attributes DCSP to DCSP the DCSP ContourSet\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object. DCSP  DCSP These DCSP attributes DCSP are DCSP all DCSP of DCSP the DCSP form DCSP label* DCSP and DCSP names\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP should DCSP be DCSP fairly DCSP self DCSP explanatory.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Once DCSP these DCSP attributes DCSP are DCSP set, DCSP clabel DCSP passes DCSP control DCSP to DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP labels DCSP method DCSP (case DCSP of DCSP automatic DCSP label DCSP placement) DCSP or\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP BlockingContourLabeler DCSP (case DCSP of DCSP manual DCSP label DCSP placement).\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP fontsize = kwargs.get('fontsize', None) DCNL DCSP inline = kwargs.get('inline', 1) DCNL DCSP inline_spacing = kwargs.get('inline_spacing', 5) DCNL DCSP self.labelFmt = kwargs.get('fmt', '%1.3f') DCNL DCSP _colors = kwargs.get('colors', None) DCNL DCSP self.labelManual = kwargs.get('manual', False) DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP levels = self.levels DCNL DCSP  DCSP indices = range(len(self.levels)) DCNL DCSP elif (len(args) == 1): DCNL DCSP  DCSP levlabs = list(args[0]) DCNL DCSP  DCSP (indices, levels) = ([], []) DCNL DCSP  DCSP for (i, lev) in enumerate(self.levels): DCNL DCSP  DCSP  DCSP if (lev in levlabs): DCNL DCSP  DCSP  DCSP  DCSP indices.append(i) DCNL DCSP  DCSP  DCSP  DCSP levels.append(lev) DCNL DCSP  DCSP if (len(levels) < len(levlabs)): DCNL DCSP  DCSP  DCSP msg = ('Specified DCSP levels DCSP ' + str(levlabs)) DCNL DCSP  DCSP  DCSP msg += "\n DCSP don't DCSP match DCSP available DCSP levels DCSP " DCNL DCSP  DCSP  DCSP msg += str(self.levels) DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Illegal DCSP arguments DCSP to DCSP clabel, DCSP see DCSP help(clabel)') DCNL DCSP self.labelLevelList = levels DCNL DCSP self.labelIndiceList = indices DCNL DCSP self.labelFontProps = font_manager.FontProperties() DCNL DCSP if (fontsize == None): DCNL DCSP  DCSP font_size = int(self.labelFontProps.get_size_in_points()) DCNL DCSP elif (type(fontsize) not in [int, float, str]): DCNL DCSP  DCSP raise TypeError('Font DCSP size DCSP must DCSP be DCSP an DCSP integer DCSP number.') DCNL DCSP elif (type(fontsize) == str): DCNL DCSP  DCSP font_size = int(self.labelFontProps.get_size_in_points()) DCNL DCSP else: DCNL DCSP  DCSP self.labelFontProps.set_size(fontsize) DCNL DCSP  DCSP font_size = fontsize DCNL DCSP self.labelFontSizeList = ([font_size] * len(levels)) DCNL DCSP if (_colors == None): DCNL DCSP  DCSP self.labelMappable = self DCNL DCSP  DCSP self.labelCValueList = np.take(self.cvalues, self.labelIndiceList) DCNL DCSP else: DCNL DCSP  DCSP cmap = colors.ListedColormap(_colors, N=len(self.labelLevelList)) DCNL DCSP  DCSP self.labelCValueList = range(len(self.labelLevelList)) DCNL DCSP  DCSP self.labelMappable = cm.ScalarMappable(cmap=cmap, norm=colors.NoNorm()) DCNL DCSP self.labelXYs = [] DCNL DCSP if self.labelManual: DCNL DCSP  DCSP print 'Select DCSP label DCSP locations DCSP manually DCSP using DCSP first DCSP mouse DCSP button.' DCNL DCSP  DCSP print 'End DCSP manual DCSP selection DCSP with DCSP second DCSP mouse DCSP button.' DCNL DCSP  DCSP if (not inline): DCNL DCSP  DCSP  DCSP print 'Remove DCSP last DCSP label DCSP by DCSP clicking DCSP third DCSP mouse DCSP button.' DCNL DCSP  DCSP blocking_contour_labeler = BlockingContourLabeler(self) DCNL DCSP  DCSP blocking_contour_labeler(inline, inline_spacing) DCNL DCSP else: DCNL DCSP  DCSP self.labels(inline, inline_spacing) DCNL DCSP self.cl = self.labelTexts DCNL DCSP self.cl_xy = self.labelXYs DCNL DCSP self.cl_cvalues = self.labelCValues DCNL DCSP self.labelTextsList = cbook.silent_list('text.Text', self.labelTexts) DCNL DCSP return self.labelTextsList
def print_label(self, linecontour, labelwidth): DCNL DCSP lcsize = len(linecontour) DCNL DCSP if (lcsize > (10 * labelwidth)): DCNL DCSP  DCSP return 1 DCNL DCSP xmax = np.amax(linecontour[:, 0]) DCNL DCSP xmin = np.amin(linecontour[:, 0]) DCNL DCSP ymax = np.amax(linecontour[:, 1]) DCNL DCSP ymin = np.amin(linecontour[:, 1]) DCNL DCSP lw = labelwidth DCNL DCSP if (((xmax - xmin) > (1.2 * lw)) or ((ymax - ymin) > (1.2 * lw))): DCNL DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP return 0
def too_close(self, x, y, lw): DCNL DCSP if (self.labelXYs != []): DCNL DCSP  DCSP dist = [np.sqrt((((x - loc[0]) ** 2) + ((y - loc[1]) ** 2))) for loc in self.labelXYs] DCNL DCSP  DCSP for d in dist: DCNL DCSP  DCSP  DCSP if (d < (1.2 * lw)): DCNL DCSP  DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return 0 DCNL DCSP else: DCNL DCSP  DCSP return 0
def get_label_coords(self, distances, XX, YY, ysize, lw): DCNL DCSP hysize = int((ysize / 2)) DCNL DCSP adist = np.argsort(distances) DCNL DCSP for ind in adist: DCNL DCSP  DCSP (x, y) = (XX[ind][hysize], YY[ind][hysize]) DCNL DCSP  DCSP if self.too_close(x, y, lw): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (x, y, ind) DCNL DCSP ind = adist[0] DCNL DCSP (x, y) = (XX[ind][hysize], YY[ind][hysize]) DCNL DCSP return (x, y, ind)
def get_label_width(self, lev, fmt, fsize): DCNL DCSP if cbook.is_string_like(lev): DCNL DCSP  DCSP lw = (len(lev) * fsize) DCNL DCSP else: DCNL DCSP  DCSP lw = (len(self.get_text(lev, fmt)) * fsize) DCNL DCSP return lw
def get_real_label_width(self, lev, fmt, fsize): DCNL DCSP xx = np.mean(np.asarray(self.ax.axis()).reshape(2, 2), axis=1) DCNL DCSP t = text.Text(xx[0], xx[1]) DCNL DCSP self.set_label_props(t, self.get_text(lev, fmt), 'k') DCNL DCSP bbox = t.get_window_extent(renderer=self.ax.figure.canvas.renderer) DCNL DCSP lw = np.diff(bbox.corners()[0::2, 0])[0] DCNL DCSP return lw
def set_label_props(self, label, text, color): DCNL DCSP label.set_text(text) DCNL DCSP label.set_color(color) DCNL DCSP label.set_fontproperties(self.labelFontProps) DCNL DCSP label.set_clip_box(self.ax.bbox)
def get_text(self, lev, fmt): DCNL DCSP if cbook.is_string_like(lev): DCNL DCSP  DCSP return lev DCNL DCSP elif isinstance(fmt, dict): DCNL DCSP  DCSP return fmt[lev] DCNL DCSP else: DCNL DCSP  DCSP return (fmt % lev)
def locate_label(self, linecontour, labelwidth): DCNL DCSP nsize = len(linecontour) DCNL DCSP if (labelwidth > 1): DCNL DCSP  DCSP xsize = int(np.ceil((nsize / labelwidth))) DCNL DCSP else: DCNL DCSP  DCSP xsize = 1 DCNL DCSP if (xsize == 1): DCNL DCSP  DCSP ysize = nsize DCNL DCSP else: DCNL DCSP  DCSP ysize = labelwidth DCNL DCSP XX = np.resize(linecontour[:, 0], (xsize, ysize)) DCNL DCSP YY = np.resize(linecontour[:, 1], (xsize, ysize)) DCNL DCSP yfirst = YY[:, 0].reshape(xsize, 1) DCNL DCSP ylast = YY[:, (-1)].reshape(xsize, 1) DCNL DCSP xfirst = XX[:, 0].reshape(xsize, 1) DCNL DCSP xlast = XX[:, (-1)].reshape(xsize, 1) DCNL DCSP s = (((yfirst - YY) * (xlast - xfirst)) - ((xfirst - XX) * (ylast - yfirst))) DCNL DCSP L = np.sqrt((((xlast - xfirst) ** 2) + ((ylast - yfirst) ** 2))).ravel() DCNL DCSP dist = np.add.reduce([(abs(s)[i] / L[i]) for i in range(xsize)], (-1)) DCNL DCSP (x, y, ind) = self.get_label_coords(dist, XX, YY, ysize, labelwidth) DCNL DCSP lc = [tuple(l) for l in linecontour] DCNL DCSP dind = lc.index((x, y)) DCNL DCSP return (x, y, dind)
def calc_label_rot_and_inline(self, slc, ind, lw, lc=None, spacing=5): DCNL DCSP if (lc is None): DCNL DCSP  DCSP lc = [] DCNL DCSP hlw = (lw / 2.0) DCNL DCSP closed = mlab.is_closed_polygon(slc) DCNL DCSP if closed: DCNL DCSP  DCSP slc = np.r_[(slc[ind:(-1)], slc[:(ind + 1)])] DCNL DCSP  DCSP if len(lc): DCNL DCSP  DCSP  DCSP lc = np.r_[(lc[ind:(-1)], lc[:(ind + 1)])] DCNL DCSP  DCSP ind = 0 DCNL DCSP pl = mlab.path_length(slc) DCNL DCSP pl = (pl - pl[ind]) DCNL DCSP xi = np.array([(- hlw), hlw]) DCNL DCSP if closed: DCNL DCSP  DCSP dp = np.array([pl[(-1)], 0]) DCNL DCSP else: DCNL DCSP  DCSP dp = np.zeros_like(xi) DCNL DCSP ll = mlab.less_simple_linear_interpolation(pl, slc, (dp + xi), extrap=True) DCNL DCSP dd = np.diff(ll, axis=0).ravel() DCNL DCSP if np.all((dd == 0)): DCNL DCSP  DCSP rotation = 0.0 DCNL DCSP else: DCNL DCSP  DCSP rotation = ((np.arctan2(dd[1], dd[0]) * 180.0) / np.pi) DCNL DCSP if (rotation > 90): DCNL DCSP  DCSP rotation = (rotation - 180.0) DCNL DCSP if (rotation < (-90)): DCNL DCSP  DCSP rotation = (180.0 + rotation) DCNL DCSP nlc = [] DCNL DCSP if len(lc): DCNL DCSP  DCSP xi = ((dp + xi) + np.array([(- spacing), spacing])) DCNL DCSP  DCSP I = mlab.less_simple_linear_interpolation(pl, np.arange(len(pl)), xi, extrap=False) DCNL DCSP  DCSP if ((not np.isnan(I[0])) and (int(I[0]) != I[0])): DCNL DCSP  DCSP  DCSP xy1 = mlab.less_simple_linear_interpolation(pl, lc, [xi[0]]) DCNL DCSP  DCSP if ((not np.isnan(I[1])) and (int(I[1]) != I[1])): DCNL DCSP  DCSP  DCSP xy2 = mlab.less_simple_linear_interpolation(pl, lc, [xi[1]]) DCNL DCSP  DCSP I = [np.floor(I[0]), np.ceil(I[1])] DCNL DCSP  DCSP if closed: DCNL DCSP  DCSP  DCSP if np.all((~ np.isnan(I))): DCNL DCSP  DCSP  DCSP  DCSP nlc.append(np.r_[(xy2, lc[I[1]:(I[0] + 1)], xy1)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not np.isnan(I[0])): DCNL DCSP  DCSP  DCSP  DCSP nlc.append(np.r_[(lc[:(I[0] + 1)], xy1)]) DCNL DCSP  DCSP  DCSP if (not np.isnan(I[1])): DCNL DCSP  DCSP  DCSP  DCSP nlc.append(np.r_[(xy2, lc[I[1]:])]) DCNL DCSP return (rotation, nlc)
def pop_label(self, index=(-1)): DCNL DCSP self.labelCValues.pop(index) DCNL DCSP t = self.labelTexts.pop(index) DCNL DCSP t.remove()
def __init__(self, ax, *args, **kwargs): DCNL DCSP self.ax = ax DCNL DCSP self.levels = kwargs.get('levels', None) DCNL DCSP self.filled = kwargs.get('filled', False) DCNL DCSP self.linewidths = kwargs.get('linewidths', None) DCNL DCSP self.linestyles = kwargs.get('linestyles', 'solid') DCNL DCSP self.alpha = kwargs.get('alpha', 1.0) DCNL DCSP self.origin = kwargs.get('origin', None) DCNL DCSP self.extent = kwargs.get('extent', None) DCNL DCSP cmap = kwargs.get('cmap', None) DCNL DCSP self.colors = kwargs.get('colors', None) DCNL DCSP norm = kwargs.get('norm', None) DCNL DCSP self.extend = kwargs.get('extend', 'neither') DCNL DCSP self.antialiased = kwargs.get('antialiased', True) DCNL DCSP self.nchunk = kwargs.get('nchunk', 0) DCNL DCSP self.locator = kwargs.get('locator', None) DCNL DCSP if (isinstance(norm, colors.LogNorm) or isinstance(self.locator, ticker.LogLocator)): DCNL DCSP  DCSP self.logscale = True DCNL DCSP  DCSP if (norm is None): DCNL DCSP  DCSP  DCSP norm = colors.LogNorm() DCNL DCSP  DCSP if (self.extend is not 'neither'): DCNL DCSP  DCSP  DCSP raise ValueError('extend DCSP kwarg DCSP does DCSP not DCSP work DCSP yet DCSP with DCSP log DCSP scale') DCNL DCSP else: DCNL DCSP  DCSP self.logscale = False DCNL DCSP if (self.origin is not None): DCNL DCSP  DCSP assert (self.origin in ['lower', 'upper', 'image']) DCNL DCSP if (self.extent is not None): DCNL DCSP  DCSP assert (len(self.extent) == 4) DCNL DCSP if (cmap is not None): DCNL DCSP  DCSP assert isinstance(cmap, colors.Colormap) DCNL DCSP if ((self.colors is not None) and (cmap is not None)): DCNL DCSP  DCSP raise ValueError('Either DCSP colors DCSP or DCSP cmap DCSP must DCSP be DCSP None') DCNL DCSP if (self.origin == 'image'): DCNL DCSP  DCSP self.origin = mpl.rcParams['image.origin'] DCNL DCSP (x, y, z) = self._contour_args(*args) DCNL DCSP if (self.colors is not None): DCNL DCSP  DCSP cmap = colors.ListedColormap(self.colors, N=len(self.layers)) DCNL DCSP if self.filled: DCNL DCSP  DCSP self.collections = cbook.silent_list('collections.PolyCollection') DCNL DCSP else: DCNL DCSP  DCSP self.collections = cbook.silent_list('collections.LineCollection') DCNL DCSP self.labelTexts = [] DCNL DCSP self.labelCValues = [] DCNL DCSP kw = {'cmap': cmap} DCNL DCSP if (norm is not None): DCNL DCSP  DCSP kw['norm'] = norm DCNL DCSP cm.ScalarMappable.__init__(self, **kw) DCNL DCSP self._process_colors() DCNL DCSP _mask = ma.getmask(z) DCNL DCSP if (_mask is ma.nomask): DCNL DCSP  DCSP _mask = None DCNL DCSP if self.filled: DCNL DCSP  DCSP if (self.linewidths is not None): DCNL DCSP  DCSP  DCSP warnings.warn('linewidths DCSP is DCSP ignored DCSP by DCSP contourf') DCNL DCSP  DCSP C = _cntr.Cntr(x, y, z.filled(), _mask) DCNL DCSP  DCSP lowers = self._levels[:(-1)] DCNL DCSP  DCSP uppers = self._levels[1:] DCNL DCSP  DCSP for (level, level_upper) in zip(lowers, uppers): DCNL DCSP  DCSP  DCSP nlist = C.trace(level, level_upper, points=0, nchunk=self.nchunk) DCNL DCSP  DCSP  DCSP col = collections.PolyCollection(nlist, antialiaseds=(self.antialiased,), edgecolors='none', alpha=self.alpha) DCNL DCSP  DCSP  DCSP self.ax.add_collection(col) DCNL DCSP  DCSP  DCSP self.collections.append(col) DCNL DCSP else: DCNL DCSP  DCSP tlinewidths = self._process_linewidths() DCNL DCSP  DCSP self.tlinewidths = tlinewidths DCNL DCSP  DCSP tlinestyles = self._process_linestyles() DCNL DCSP  DCSP C = _cntr.Cntr(x, y, z.filled(), _mask) DCNL DCSP  DCSP for (level, width, lstyle) in zip(self.levels, tlinewidths, tlinestyles): DCNL DCSP  DCSP  DCSP nlist = C.trace(level, points=0) DCNL DCSP  DCSP  DCSP col = collections.LineCollection(nlist, linewidths=width, linestyle=lstyle, alpha=self.alpha) DCNL DCSP  DCSP  DCSP if ((level < 0.0) and self.monochrome): DCNL DCSP  DCSP  DCSP  DCSP ls = mpl.rcParams['contour.negative_linestyle'] DCNL DCSP  DCSP  DCSP  DCSP col.set_linestyle(ls) DCNL DCSP  DCSP  DCSP col.set_label('_nolegend_') DCNL DCSP  DCSP  DCSP self.ax.add_collection(col, False) DCNL DCSP  DCSP  DCSP self.collections.append(col) DCNL DCSP self.changed() DCNL DCSP x0 = ma.minimum(x) DCNL DCSP x1 = ma.maximum(x) DCNL DCSP y0 = ma.minimum(y) DCNL DCSP y1 = ma.maximum(y) DCNL DCSP self.ax.update_datalim([(x0, y0), (x1, y1)]) DCNL DCSP self.ax.autoscale_view()
def _autolev(self, z, N): DCNL DCSP if (self.locator is None): DCNL DCSP  DCSP if self.logscale: DCNL DCSP  DCSP  DCSP self.locator = ticker.LogLocator() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.locator = ticker.MaxNLocator((N + 1)) DCNL DCSP self.locator.create_dummy_axis() DCNL DCSP zmax = self.zmax DCNL DCSP zmin = self.zmin DCNL DCSP self.locator.set_bounds(zmin, zmax) DCNL DCSP lev = self.locator() DCNL DCSP zmargin = ((zmax - zmin) * 1e-06) DCNL DCSP if (zmax >= lev[(-1)]): DCNL DCSP  DCSP lev[(-1)] += zmargin DCNL DCSP if (zmin <= lev[0]): DCNL DCSP  DCSP if self.logscale: DCNL DCSP  DCSP  DCSP lev[0] = (0.99 * zmin) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lev[0] -= zmargin DCNL DCSP self._auto = True DCNL DCSP if self.filled: DCNL DCSP  DCSP return lev DCNL DCSP return lev[1:(-1)]
def _initialize_x_y(self, z): DCNL DCSP if (z.ndim != 2): DCNL DCSP  DCSP raise TypeError('Input DCSP must DCSP be DCSP a DCSP 2D DCSP array.') DCNL DCSP else: DCNL DCSP  DCSP (Ny, Nx) = z.shape DCNL DCSP if (self.origin is None): DCNL DCSP  DCSP if (self.extent is None): DCNL DCSP  DCSP  DCSP return np.meshgrid(np.arange(Nx), np.arange(Ny)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (x0, x1, y0, y1) = self.extent DCNL DCSP  DCSP  DCSP x = np.linspace(x0, x1, Nx) DCNL DCSP  DCSP  DCSP y = np.linspace(y0, y1, Ny) DCNL DCSP  DCSP  DCSP return np.meshgrid(x, y) DCNL DCSP if (self.extent is None): DCNL DCSP  DCSP (x0, x1, y0, y1) = (0, Nx, 0, Ny) DCNL DCSP else: DCNL DCSP  DCSP (x0, x1, y0, y1) = self.extent DCNL DCSP dx = (float((x1 - x0)) / Nx) DCNL DCSP dy = (float((y1 - y0)) / Ny) DCNL DCSP x = (x0 + ((np.arange(Nx) + 0.5) * dx)) DCNL DCSP y = (y0 + ((np.arange(Ny) + 0.5) * dy)) DCNL DCSP if (self.origin == 'upper'): DCNL DCSP  DCSP y = y[::(-1)] DCNL DCSP return np.meshgrid(x, y)
def _check_xyz(self, args): DCNL DCSP x = self.ax.convert_xunits(args[0]) DCNL DCSP y = self.ax.convert_yunits(args[1]) DCNL DCSP x = np.asarray(x, dtype=np.float64) DCNL DCSP y = np.asarray(y, dtype=np.float64) DCNL DCSP z = ma.asarray(args[2], dtype=np.float64) DCNL DCSP if (z.ndim != 2): DCNL DCSP  DCSP raise TypeError('Input DCSP z DCSP must DCSP be DCSP a DCSP 2D DCSP array.') DCNL DCSP else: DCNL DCSP  DCSP (Ny, Nx) = z.shape DCNL DCSP if ((x.shape == z.shape) and (y.shape == z.shape)): DCNL DCSP  DCSP return (x, y, z) DCNL DCSP if ((x.ndim != 1) or (y.ndim != 1)): DCNL DCSP  DCSP raise TypeError('Inputs DCSP x DCSP and DCSP y DCSP must DCSP be DCSP 1D DCSP or DCSP 2D.') DCNL DCSP (nx,) = x.shape DCNL DCSP (ny,) = y.shape DCNL DCSP if ((nx != Nx) or (ny != Ny)): DCNL DCSP  DCSP raise TypeError(('Length DCSP of DCSP x DCSP must DCSP be DCSP number DCSP of DCSP columns DCSP in DCSP z,\n' + 'and DCSP length DCSP of DCSP y DCSP must DCSP be DCSP number DCSP of DCSP rows.')) DCNL DCSP (x, y) = np.meshgrid(x, y) DCNL DCSP return (x, y, z)
def _process_colors(self): DCNL DCSP self.monochrome = self.cmap.monochrome DCNL DCSP if (self.colors is not None): DCNL DCSP  DCSP (i0, i1) = (0, len(self.layers)) DCNL DCSP  DCSP if (self.extend in ('both', 'min')): DCNL DCSP  DCSP  DCSP i0 = (-1) DCNL DCSP  DCSP if (self.extend in ('both', 'max')): DCNL DCSP  DCSP  DCSP i1 = (i1 + 1) DCNL DCSP  DCSP self.cvalues = range(i0, i1) DCNL DCSP  DCSP self.set_norm(colors.NoNorm()) DCNL DCSP else: DCNL DCSP  DCSP self.cvalues = self.layers DCNL DCSP if (not self.norm.scaled()): DCNL DCSP  DCSP self.set_clim(self.vmin, self.vmax) DCNL DCSP if (self.extend in ('both', 'max', 'min')): DCNL DCSP  DCSP self.norm.clip = False DCNL DCSP self.set_array(self.layers)
def get_alpha(self): DCNL DCSP return self.alpha
def set_alpha(self, alpha): DCNL DCSP self.alpha = alpha DCNL DCSP self.changed()
def find_nearest_contour(self, x, y, indices=None, pixel=True): DCNL DCSP if (indices == None): DCNL DCSP  DCSP indices = range(len(self.levels)) DCNL DCSP dmin = 10000000000.0 DCNL DCSP conmin = None DCNL DCSP segmin = None DCNL DCSP xmin = None DCNL DCSP ymin = None DCNL DCSP for icon in indices: DCNL DCSP  DCSP con = self.collections[icon] DCNL DCSP  DCSP paths = con.get_paths() DCNL DCSP  DCSP for (segNum, linepath) in enumerate(paths): DCNL DCSP  DCSP  DCSP lc = linepath.vertices DCNL DCSP  DCSP  DCSP if pixel: DCNL DCSP  DCSP  DCSP  DCSP lc = self.ax.transData.transform(lc) DCNL DCSP  DCSP  DCSP ds = (((lc[:, 0] - x) ** 2) + ((lc[:, 1] - y) ** 2)) DCNL DCSP  DCSP  DCSP d = min(ds) DCNL DCSP  DCSP  DCSP if (d < dmin): DCNL DCSP  DCSP  DCSP  DCSP dmin = d DCNL DCSP  DCSP  DCSP  DCSP conmin = icon DCNL DCSP  DCSP  DCSP  DCSP segmin = segNum DCNL DCSP  DCSP  DCSP  DCSP imin = mpl.mlab.find((ds == d))[0] DCNL DCSP  DCSP  DCSP  DCSP xmin = lc[(imin, 0)] DCNL DCSP  DCSP  DCSP  DCSP ymin = lc[(imin, 1)] DCNL DCSP return (conmin, segmin, imin, xmin, ymin, dmin)
def get_basefile(self, tex, fontsize, dpi=None): DCNL DCSP s = ''.join([tex, self.get_font_config(), ('%f' % fontsize), self.get_custom_preamble(), str((dpi or ''))]) DCNL DCSP bytes = unicode(s).encode('utf-8') DCNL DCSP return os.path.join(self.texcache, md5(bytes).hexdigest())
def get_font_config(self): DCNL DCSP if (self._rc_cache is None): DCNL DCSP  DCSP self._rc_cache = dict([(k, None) for k in self._rc_cache_keys]) DCNL DCSP changed = [par for par in self._rc_cache_keys if (rcParams[par] != self._rc_cache[par])] DCNL DCSP if changed: DCNL DCSP  DCSP if DEBUG: DCNL DCSP  DCSP  DCSP print 'DEBUG DCSP following DCSP keys DCSP changed:', changed DCNL DCSP  DCSP for k in changed: DCNL DCSP  DCSP  DCSP if DEBUG: DCNL DCSP  DCSP  DCSP  DCSP print ('DEBUG DCSP %-20s: DCSP %-10s DCSP -> DCSP %-10s' % (k, self._rc_cache[k], rcParams[k])) DCNL DCSP  DCSP  DCSP self._rc_cache[k] = copy.deepcopy(rcParams[k]) DCNL DCSP  DCSP if DEBUG: DCNL DCSP  DCSP  DCSP print 'DEBUG DCSP RE-INIT\nold DCSP fontconfig:', self._fontconfig DCNL DCSP  DCSP self.__init__() DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'DEBUG DCSP fontconfig:', self._fontconfig DCNL DCSP return self._fontconfig
def get_font_preamble(self): DCNL DCSP return self._font_preamble
def get_custom_preamble(self): DCNL DCSP return '\n'.join(rcParams['text.latex.preamble'])
def _get_shell_cmd(self, *args): DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP command = [('%s' % os.path.splitdrive(self.texcache)[0])] DCNL DCSP else: DCNL DCSP  DCSP command = [] DCNL DCSP command.extend(args) DCNL DCSP return ' DCSP && DCSP '.join(command)
def make_tex(self, tex, fontsize): DCNL DCSP basefile = self.get_basefile(tex, fontsize) DCNL DCSP texfile = ('%s.tex' % basefile) DCNL DCSP fh = file(texfile, 'w') DCNL DCSP custom_preamble = self.get_custom_preamble() DCNL DCSP fontcmd = {'sans-serif': '{\\sffamily DCSP %s}', 'monospace': '{\\ttfamily DCSP %s}'}.get(self.font_family, '{\\rmfamily DCSP %s}') DCNL DCSP tex = (fontcmd % tex) DCNL DCSP if rcParams['text.latex.unicode']: DCNL DCSP  DCSP unicode_preamble = '\\usepackage{ucs}\n\\usepackage[utf8x]{inputenc}' DCNL DCSP else: DCNL DCSP  DCSP unicode_preamble = '' DCNL DCSP s = ('\\documentclass{article}\n%s\n%s\n%s\n\\usepackage[papersize={72in,72in}, DCSP body={70in,70in}, DCSP margin={1in,1in}]{geometry}\n\\pagestyle{empty}\n\\begin{document}\n\\fontsize{%f}{%f}%s\n\\end{document}\n' % (self._font_preamble, unicode_preamble, custom_preamble, fontsize, (fontsize * 1.25), tex)) DCNL DCSP if rcParams['text.latex.unicode']: DCNL DCSP  DCSP fh.write(s.encode('utf8')) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fh.write(s) DCNL DCSP  DCSP except UnicodeEncodeError as err: DCNL DCSP  DCSP  DCSP mpl.verbose.report("You DCSP are DCSP using DCSP unicode DCSP and DCSP latex, DCSP but DCSP have DCSP not DCSP enabled DCSP the DCSP matplotlib DCSP 'text.latex.unicode' DCSP rcParam.", 'helpful') DCNL DCSP  DCSP  DCSP raise DCNL DCSP fh.close() DCNL DCSP return texfile
def make_dvi(self, tex, fontsize): DCNL DCSP basefile = self.get_basefile(tex, fontsize) DCNL DCSP dvifile = ('%s.dvi' % basefile) DCNL DCSP if (DEBUG or (not os.path.exists(dvifile))): DCNL DCSP  DCSP texfile = self.make_tex(tex, fontsize) DCNL DCSP  DCSP outfile = (basefile + '.output') DCNL DCSP  DCSP command = self._get_shell_cmd(('cd DCSP "%s"' % self.texcache), ('latex DCSP -interaction=nonstopmode DCSP %s DCSP > DCSP "%s"' % (os.path.split(texfile)[(-1)], outfile))) DCNL DCSP  DCSP mpl.verbose.report(command, 'debug') DCNL DCSP  DCSP exit_status = os.system(command) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fh = file(outfile) DCNL DCSP  DCSP  DCSP report = fh.read() DCNL DCSP  DCSP  DCSP fh.close() DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP report = 'No DCSP latex DCSP error DCSP report DCSP available.' DCNL DCSP  DCSP if exit_status: DCNL DCSP  DCSP  DCSP raise RuntimeError((('LaTeX DCSP was DCSP not DCSP able DCSP to DCSP process DCSP the DCSP following DCSP string:\n%s\nHere DCSP is DCSP the DCSP full DCSP report DCSP generated DCSP by DCSP LaTeX: DCSP \n\n' % repr(tex)) + report)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mpl.verbose.report(report, 'debug') DCNL DCSP  DCSP for fname in glob.glob((basefile + '*')): DCNL DCSP  DCSP  DCSP if fname.endswith('dvi'): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif fname.endswith('tex'): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.remove(fname) DCNL DCSP  DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return dvifile
def make_png(self, tex, fontsize, dpi): DCNL DCSP basefile = self.get_basefile(tex, fontsize, dpi) DCNL DCSP pngfile = ('%s.png' % basefile) DCNL DCSP if (DEBUG or (not os.path.exists(pngfile))): DCNL DCSP  DCSP dvifile = self.make_dvi(tex, fontsize) DCNL DCSP  DCSP outfile = (basefile + '.output') DCNL DCSP  DCSP command = self._get_shell_cmd(('cd DCSP "%s"' % self.texcache), ('dvipng DCSP -bg DCSP Transparent DCSP -D DCSP %s DCSP -T DCSP tight DCSP -o DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "%s" DCSP "%s" DCSP > DCSP "%s"' % (dpi, os.path.split(pngfile)[(-1)], os.path.split(dvifile)[(-1)], outfile))) DCNL DCSP  DCSP mpl.verbose.report(command, 'debug') DCNL DCSP  DCSP exit_status = os.system(command) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fh = file(outfile) DCNL DCSP  DCSP  DCSP report = fh.read() DCNL DCSP  DCSP  DCSP fh.close() DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP report = 'No DCSP dvipng DCSP error DCSP report DCSP available.' DCNL DCSP  DCSP if exit_status: DCNL DCSP  DCSP  DCSP raise RuntimeError((('dvipng DCSP was DCSP not DCSP able DCSP to DCSP process DCSP the DCSP flowing DCSP file:\n%s\nHere DCSP is DCSP the DCSP full DCSP report DCSP generated DCSP by DCSP dvipng: DCSP \n\n' % dvifile) + report)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mpl.verbose.report(report, 'debug') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.remove(outfile) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return pngfile
def make_ps(self, tex, fontsize): DCNL DCSP basefile = self.get_basefile(tex, fontsize) DCNL DCSP psfile = ('%s.epsf' % basefile) DCNL DCSP if (DEBUG or (not os.path.exists(psfile))): DCNL DCSP  DCSP dvifile = self.make_dvi(tex, fontsize) DCNL DCSP  DCSP outfile = (basefile + '.output') DCNL DCSP  DCSP command = self._get_shell_cmd(('cd DCSP "%s"' % self.texcache), ('dvips DCSP -q DCSP -E DCSP -o DCSP "%s" DCSP "%s" DCSP > DCSP "%s"' % (os.path.split(psfile)[(-1)], os.path.split(dvifile)[(-1)], outfile))) DCNL DCSP  DCSP mpl.verbose.report(command, 'debug') DCNL DCSP  DCSP exit_status = os.system(command) DCNL DCSP  DCSP fh = file(outfile) DCNL DCSP  DCSP if exit_status: DCNL DCSP  DCSP  DCSP raise RuntimeError((('dvipng DCSP was DCSP not DCSP able DCSP to DCSP process DCSP the DCSP flowing DCSP file:\n%s\nHere DCSP is DCSP the DCSP full DCSP report DCSP generated DCSP by DCSP dvipng: DCSP \n\n' % dvifile) + fh.read())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mpl.verbose.report(fh.read(), 'debug') DCNL DCSP  DCSP fh.close() DCNL DCSP  DCSP os.remove(outfile) DCNL DCSP return psfile
def get_ps_bbox(self, tex, fontsize): DCNL DCSP psfile = self.make_ps(tex, fontsize) DCNL DCSP ps = file(psfile) DCNL DCSP for line in ps: DCNL DCSP  DCSP if line.startswith('%%BoundingBox:'): DCNL DCSP  DCSP  DCSP return [int(val) for val in line.split()[1:]] DCNL DCSP raise RuntimeError(('Could DCSP not DCSP parse DCSP %s' % psfile))
def get_grey(self, tex, fontsize=None, dpi=None): DCNL DCSP key = (tex, self.get_font_config(), fontsize, dpi) DCNL DCSP alpha = self.grey_arrayd.get(key) DCNL DCSP if (alpha is None): DCNL DCSP  DCSP pngfile = self.make_png(tex, fontsize, dpi) DCNL DCSP  DCSP X = read_png(os.path.join(self.texcache, pngfile)) DCNL DCSP  DCSP if (rcParams['text.dvipnghack'] is not None): DCNL DCSP  DCSP  DCSP hack = rcParams['text.dvipnghack'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP hack = self._dvipng_hack_alpha DCNL DCSP  DCSP if hack: DCNL DCSP  DCSP  DCSP alpha = (1 - X[:, :, 0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP alpha = X[:, :, (-1)] DCNL DCSP  DCSP self.grey_arrayd[key] = alpha DCNL DCSP return alpha
def get_rgba(self, tex, fontsize=None, dpi=None, rgb=(0, 0, 0)): DCNL DCSP if (not fontsize): DCNL DCSP  DCSP fontsize = rcParams['font.size'] DCNL DCSP if (not dpi): DCNL DCSP  DCSP dpi = rcParams['savefig.dpi'] DCNL DCSP (r, g, b) = rgb DCNL DCSP key = (tex, self.get_font_config(), fontsize, dpi, tuple(rgb)) DCNL DCSP Z = self.rgba_arrayd.get(key) DCNL DCSP if (Z is None): DCNL DCSP  DCSP alpha = self.get_grey(tex, fontsize, dpi) DCNL DCSP  DCSP Z = np.zeros((alpha.shape[0], alpha.shape[1], 4), np.float) DCNL DCSP  DCSP Z[:, :, 0] = r DCNL DCSP  DCSP Z[:, :, 1] = g DCNL DCSP  DCSP Z[:, :, 2] = b DCNL DCSP  DCSP Z[:, :, 3] = alpha DCNL DCSP  DCSP self.rgba_arrayd[key] = Z DCNL DCSP return Z
def get_text(self): DCNL DCSP return self._text
def get_fontsize(self): DCNL DCSP return self._text.get_fontsize()
def auto_set_font_size(self, renderer): DCNL DCSP fontsize = self.get_fontsize() DCNL DCSP required = self.get_required_width(renderer) DCNL DCSP while ((fontsize > 1) and (required > self.get_width())): DCNL DCSP  DCSP fontsize -= 1 DCNL DCSP  DCSP self.set_fontsize(fontsize) DCNL DCSP  DCSP required = self.get_required_width(renderer) DCNL DCSP return fontsize
def _set_text_position(self, renderer): DCNL DCSP bbox = self.get_window_extent(renderer) DCNL DCSP (l, b, w, h) = bbox.bounds DCNL DCSP self._text.set_verticalalignment('center') DCNL DCSP y = (b + (h / 2.0)) DCNL DCSP if (self._loc == 'center'): DCNL DCSP  DCSP self._text.set_horizontalalignment('center') DCNL DCSP  DCSP x = (l + (w / 2.0)) DCNL DCSP elif (self._loc == 'left'): DCNL DCSP  DCSP self._text.set_horizontalalignment('left') DCNL DCSP  DCSP x = (l + (w * self.PAD)) DCNL DCSP else: DCNL DCSP  DCSP self._text.set_horizontalalignment('right') DCNL DCSP  DCSP x = (l + (w * (1.0 - self.PAD))) DCNL DCSP self._text.set_position((x, y))
def get_text_bounds(self, renderer): DCNL DCSP bbox = self._text.get_window_extent(renderer) DCNL DCSP bboxa = bbox.inverse_transformed(self.get_data_transform()) DCNL DCSP return bboxa.bounds
def get_required_width(self, renderer): DCNL DCSP (l, b, w, h) = self.get_text_bounds(renderer) DCNL DCSP return (w * (1.0 + (2.0 * self.PAD)))
def set_text_props(self, **kwargs): DCNL DCSP self._text.update(kwargs)
def add_cell(self, row, col, *args, **kwargs): DCNL DCSP xy = (0, 0) DCNL DCSP cell = Cell(xy, *args, **kwargs) DCNL DCSP cell.set_figure(self.figure) DCNL DCSP cell.set_transform(self.get_transform()) DCNL DCSP cell.set_clip_on(False) DCNL DCSP self._cells[(row, col)] = cell
def _get_grid_bbox(self, renderer): DCNL DCSP boxes = [self._cells[pos].get_window_extent(renderer) for pos in self._cells.keys() if ((pos[0] >= 0) and (pos[1] >= 0))] DCNL DCSP bbox = Bbox.union(boxes) DCNL DCSP return bbox.inverse_transformed(self.get_transform())
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP if (self._cachedRenderer is not None): DCNL DCSP  DCSP boxes = [self._cells[pos].get_window_extent(self._cachedRenderer) for pos in self._cells.keys() if ((pos[0] >= 0) and (pos[1] >= 0))] DCNL DCSP  DCSP bbox = bbox_all(boxes) DCNL DCSP  DCSP return (bbox.contains(mouseevent.x, mouseevent.y), {}) DCNL DCSP else: DCNL DCSP  DCSP return (False, {})
def get_children(self): DCNL DCSP return self._cells.values()
def get_window_extent(self, renderer): DCNL DCSP boxes = [c.get_window_extent(renderer) for c in self._cells] DCNL DCSP return bbox_all(boxes)
def _do_cell_alignment(self): DCNL DCSP widths = {} DCNL DCSP heights = {} DCNL DCSP for ((row, col), cell) in self._cells.iteritems(): DCNL DCSP  DCSP height = heights.setdefault(row, 0.0) DCNL DCSP  DCSP heights[row] = max(height, cell.get_height()) DCNL DCSP  DCSP width = widths.setdefault(col, 0.0) DCNL DCSP  DCSP widths[col] = max(width, cell.get_width()) DCNL DCSP xpos = 0 DCNL DCSP lefts = {} DCNL DCSP cols = widths.keys() DCNL DCSP cols.sort() DCNL DCSP for col in cols: DCNL DCSP  DCSP lefts[col] = xpos DCNL DCSP  DCSP xpos += widths[col] DCNL DCSP ypos = 0 DCNL DCSP bottoms = {} DCNL DCSP rows = heights.keys() DCNL DCSP rows.sort() DCNL DCSP rows.reverse() DCNL DCSP for row in rows: DCNL DCSP  DCSP bottoms[row] = ypos DCNL DCSP  DCSP ypos += heights[row] DCNL DCSP for ((row, col), cell) in self._cells.iteritems(): DCNL DCSP  DCSP cell.set_x(lefts[col]) DCNL DCSP  DCSP cell.set_y(bottoms[row])
def _auto_set_column_width(self, col, renderer): DCNL DCSP cells = [key for key in self._cells if (key[1] == col)] DCNL DCSP width = 0 DCNL DCSP for cell in cells: DCNL DCSP  DCSP c = self._cells[cell] DCNL DCSP  DCSP width = max(c.get_required_width(renderer), width) DCNL DCSP for cell in cells: DCNL DCSP  DCSP self._cells[cell].set_width(width)
def auto_set_font_size(self, value=True): DCNL DCSP self._autoFontsize = value
def scale(self, xscale, yscale): DCNL DCSP for c in self._cells.itervalues(): DCNL DCSP  DCSP c.set_width((c.get_width() * xscale)) DCNL DCSP  DCSP c.set_height((c.get_height() * yscale))
def set_fontsize(self, size): DCNL DCSP for cell in self._cells.itervalues(): DCNL DCSP  DCSP cell.set_fontsize(size)
def _offset(self, ox, oy): DCNL DCSP for c in self._cells.itervalues(): DCNL DCSP  DCSP (x, y) = (c.get_x(), c.get_y()) DCNL DCSP  DCSP c.set_x((x + ox)) DCNL DCSP  DCSP c.set_y((y + oy))
def get_celld(self): DCNL DCSP return self._cells
def _collapse_duplicate_points(self): DCNL DCSP j_sorted = np.lexsort(keys=(self.x, self.y)) DCNL DCSP mask_unique = np.hstack([True, ((np.diff(self.x[j_sorted]) != 0) | (np.diff(self.y[j_sorted]) != 0))]) DCNL DCSP return j_sorted[mask_unique]
def _compute_convex_hull(self): DCNL DCSP border = (self.triangle_neighbors == (-1)) DCNL DCSP edges = {} DCNL DCSP edges.update(dict(zip(self.triangle_nodes[border[:, 0]][:, 1], self.triangle_nodes[border[:, 0]][:, 2]))) DCNL DCSP edges.update(dict(zip(self.triangle_nodes[border[:, 1]][:, 2], self.triangle_nodes[border[:, 1]][:, 0]))) DCNL DCSP edges.update(dict(zip(self.triangle_nodes[border[:, 2]][:, 0], self.triangle_nodes[border[:, 2]][:, 1]))) DCNL DCSP hull = list(edges.popitem()) DCNL DCSP while edges: DCNL DCSP  DCSP hull.append(edges.pop(hull[(-1)])) DCNL DCSP hull.pop() DCNL DCSP return hull
def linear_interpolator(self, z, default_value=np.nan): DCNL DCSP z = np.asarray(z, dtype=np.float64) DCNL DCSP if (z.shape != self.old_shape): DCNL DCSP  DCSP raise ValueError('z DCSP must DCSP be DCSP the DCSP same DCSP shape DCSP as DCSP x DCSP and DCSP y') DCNL DCSP if (self.j_unique is not None): DCNL DCSP  DCSP z = z[self.j_unique] DCNL DCSP return LinearInterpolator(self, z, default_value)
def nn_interpolator(self, z, default_value=np.nan): DCNL DCSP z = np.asarray(z, dtype=np.float64) DCNL DCSP if (z.shape != self.old_shape): DCNL DCSP  DCSP raise ValueError('z DCSP must DCSP be DCSP the DCSP same DCSP shape DCSP as DCSP x DCSP and DCSP y') DCNL DCSP if (self.j_unique is not None): DCNL DCSP  DCSP z = z[self.j_unique] DCNL DCSP return NNInterpolator(self, z, default_value)
def node_graph(self): DCNL DCSP g = {} DCNL DCSP for (i, j) in self.edge_db: DCNL DCSP  DCSP s = g.setdefault(i, set()) DCNL DCSP  DCSP s.add(j) DCNL DCSP  DCSP s = g.setdefault(j, set()) DCNL DCSP  DCSP s.add(i) DCNL DCSP return g
def __init__(self, bitmap, dpi): DCNL DCSP DEBUG_MSG('__init__()', 1, self) DCNL DCSP if (wx.VERSION_STRING < '2.8'): DCNL DCSP  DCSP raise RuntimeError('matplotlib DCSP no DCSP longer DCSP supports DCSP wxPython DCSP < DCSP 2.8 DCSP for DCSP the DCSP Wx DCSP backend.\nYou DCSP may, DCSP however, DCSP use DCSP the DCSP WxAgg DCSP backend.') DCNL DCSP self.width = bitmap.GetWidth() DCNL DCSP self.height = bitmap.GetHeight() DCNL DCSP self.bitmap = bitmap DCNL DCSP self.fontd = {} DCNL DCSP self.dpi = dpi DCNL DCSP self.gc = None
def get_text_width_height_descent(self, s, prop, ismath): DCNL DCSP if ismath: DCNL DCSP  DCSP s = self.strip_math(s) DCNL DCSP if (self.gc is None): DCNL DCSP  DCSP gc = self.new_gc() DCNL DCSP else: DCNL DCSP  DCSP gc = self.gc DCNL DCSP gfx_ctx = gc.gfx_ctx DCNL DCSP font = self.get_wx_font(s, prop) DCNL DCSP gfx_ctx.SetFont(font, wx.BLACK) DCNL DCSP (w, h, descent, leading) = gfx_ctx.GetFullTextExtent(s) DCNL DCSP return (w, h, descent)
def get_canvas_width_height(self): DCNL DCSP return (self.width, self.height)
def draw_text(self, gc, x, y, s, prop, angle, ismath): DCNL DCSP if ismath: DCNL DCSP  DCSP s = self.strip_math(s) DCNL DCSP DEBUG_MSG('draw_text()', 1, self) DCNL DCSP gc.select() DCNL DCSP self.handle_clip_rectangle(gc) DCNL DCSP gfx_ctx = gc.gfx_ctx DCNL DCSP font = self.get_wx_font(s, prop) DCNL DCSP color = gc.get_wxcolour(gc.get_rgb()) DCNL DCSP gfx_ctx.SetFont(font, color) DCNL DCSP (w, h, d) = self.get_text_width_height_descent(s, prop, ismath) DCNL DCSP x = int(x) DCNL DCSP y = int((y - h)) DCNL DCSP if (angle == 0.0): DCNL DCSP  DCSP gfx_ctx.DrawText(s, x, y) DCNL DCSP else: DCNL DCSP  DCSP rads = ((angle / 180.0) * math.pi) DCNL DCSP  DCSP xo = (h * math.sin(rads)) DCNL DCSP  DCSP yo = (h * math.cos(rads)) DCNL DCSP  DCSP gfx_ctx.DrawRotatedText(s, (x - xo), (y - yo), rads) DCNL DCSP gc.unselect()
def new_gc(self): DCNL DCSP DEBUG_MSG('new_gc()', 2, self) DCNL DCSP self.gc = GraphicsContextWx(self.bitmap, self) DCNL DCSP self.gc.select() DCNL DCSP self.gc.unselect() DCNL DCSP return self.gc
def get_gc(self): DCNL DCSP assert (self.gc != None), 'gc DCSP must DCSP be DCSP defined' DCNL DCSP return self.gc
def get_wx_font(self, s, prop): DCNL DCSP DEBUG_MSG('get_wx_font()', 1, self) DCNL DCSP key = hash(prop) DCNL DCSP fontprop = prop DCNL DCSP fontname = fontprop.get_name() DCNL DCSP font = self.fontd.get(key) DCNL DCSP if (font is not None): DCNL DCSP  DCSP return font DCNL DCSP wxFontname = self.fontnames.get(fontname, wx.ROMAN) DCNL DCSP wxFacename = '' DCNL DCSP size = self.points_to_pixels(fontprop.get_size_in_points()) DCNL DCSP font = wx.Font(int((size + 0.5)), wxFontname, self.fontangles[fontprop.get_style()], self.fontweights[fontprop.get_weight()], False, wxFacename) DCNL DCSP self.fontd[key] = font DCNL DCSP return font
def points_to_pixels(self, points): DCNL DCSP return (points * (((PIXELS_PER_INCH / 72.0) * self.dpi) / 72.0))
def select(self): DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP self.dc.SelectObject(self.bitmap) DCNL DCSP  DCSP self.IsSelected = True
def unselect(self): DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP self.dc.SelectObject(wx.NullBitmap) DCNL DCSP  DCSP self.IsSelected = False
def set_foreground(self, fg, isRGB=None): DCNL DCSP DEBUG_MSG('set_foreground()', 1, self) DCNL DCSP self.select() DCNL DCSP GraphicsContextBase.set_foreground(self, fg, isRGB) DCNL DCSP self._pen.SetColour(self.get_wxcolour(self.get_rgb())) DCNL DCSP self.gfx_ctx.SetPen(self._pen) DCNL DCSP self.unselect()
def set_graylevel(self, frac): DCNL DCSP DEBUG_MSG('set_graylevel()', 1, self) DCNL DCSP self.select() DCNL DCSP GraphicsContextBase.set_graylevel(self, frac) DCNL DCSP self._pen.SetColour(self.get_wxcolour(self.get_rgb())) DCNL DCSP self.gfx_ctx.SetPen(self._pen) DCNL DCSP self.unselect()
def set_linewidth(self, w): DCNL DCSP DEBUG_MSG('set_linewidth()', 1, self) DCNL DCSP self.select() DCNL DCSP if ((w > 0) and (w < 1)): DCNL DCSP  DCSP w = 1 DCNL DCSP GraphicsContextBase.set_linewidth(self, w) DCNL DCSP lw = int(self.renderer.points_to_pixels(self._linewidth)) DCNL DCSP if (lw == 0): DCNL DCSP  DCSP lw = 1 DCNL DCSP self._pen.SetWidth(lw) DCNL DCSP self.gfx_ctx.SetPen(self._pen) DCNL DCSP self.unselect()
def set_capstyle(self, cs): DCNL DCSP DEBUG_MSG('set_capstyle()', 1, self) DCNL DCSP self.select() DCNL DCSP GraphicsContextBase.set_capstyle(self, cs) DCNL DCSP self._pen.SetCap(GraphicsContextWx._capd[self._capstyle]) DCNL DCSP self.gfx_ctx.SetPen(self._pen) DCNL DCSP self.unselect()
def set_joinstyle(self, js): DCNL DCSP DEBUG_MSG('set_joinstyle()', 1, self) DCNL DCSP self.select() DCNL DCSP GraphicsContextBase.set_joinstyle(self, js) DCNL DCSP self._pen.SetJoin(GraphicsContextWx._joind[self._joinstyle]) DCNL DCSP self.gfx_ctx.SetPen(self._pen) DCNL DCSP self.unselect()
def set_linestyle(self, ls): DCNL DCSP DEBUG_MSG('set_linestyle()', 1, self) DCNL DCSP self.select() DCNL DCSP GraphicsContextBase.set_linestyle(self, ls) DCNL DCSP try: DCNL DCSP  DCSP self._style = GraphicsContextWx._dashd_wx[ls] DCNL DCSP except KeyError: DCNL DCSP  DCSP self._style = wx.LONG_DASH DCNL DCSP if (wx.Platform == '__WXMSW__'): DCNL DCSP  DCSP self.set_linewidth(1) DCNL DCSP self._pen.SetStyle(self._style) DCNL DCSP self.gfx_ctx.SetPen(self._pen) DCNL DCSP self.unselect()
def get_wxcolour(self, color): DCNL DCSP DEBUG_MSG('get_wx_color()', 1, self) DCNL DCSP if (len(color) == 3): DCNL DCSP  DCSP (r, g, b) = color DCNL DCSP  DCSP r *= 255 DCNL DCSP  DCSP g *= 255 DCNL DCSP  DCSP b *= 255 DCNL DCSP  DCSP return wx.Colour(red=int(r), green=int(g), blue=int(b)) DCNL DCSP else: DCNL DCSP  DCSP (r, g, b, a) = color DCNL DCSP  DCSP r *= 255 DCNL DCSP  DCSP g *= 255 DCNL DCSP  DCSP b *= 255 DCNL DCSP  DCSP a *= 255 DCNL DCSP  DCSP return wx.Colour(red=int(r), green=int(g), blue=int(b), alpha=int(a))
def __init__(self, parent, id, figure): DCNL DCSP FigureCanvasBase.__init__(self, figure) DCNL DCSP (l, b, w, h) = figure.bbox.bounds DCNL DCSP w = int(math.ceil(w)) DCNL DCSP h = int(math.ceil(h)) DCNL DCSP wx.Panel.__init__(self, parent, id, size=wx.Size(w, h)) DCNL DCSP def do_nothing(*args, **kwargs): DCNL DCSP  DCSP warnings.warn(('could DCSP not DCSP find DCSP a DCSP setinitialsize DCSP function DCSP for DCSP backend_wx; DCSP please DCSP report DCSP your DCSP wxpython DCSP version=%s DCSP to DCSP the DCSP matplotlib DCSP developers DCSP list' % backend_version)) DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP getattr(self, 'SetInitialSize') DCNL DCSP except AttributeError: DCNL DCSP  DCSP self.SetInitialSize = getattr(self, 'SetBestFittingSize', do_nothing) DCNL DCSP if (not hasattr(self, 'IsShownOnScreen')): DCNL DCSP  DCSP self.IsShownOnScreen = getattr(self, 'IsVisible', (lambda *args: True)) DCNL DCSP self.bitmap = wx.EmptyBitmap(w, h) DCNL DCSP DEBUG_MSG(('__init__() DCSP - DCSP bitmap DCSP w:%d DCSP h:%d' % (w, h)), 2, self) DCNL DCSP self._isDrawn = False DCNL DCSP bind(self, wx.EVT_SIZE, self._onSize) DCNL DCSP bind(self, wx.EVT_PAINT, self._onPaint) DCNL DCSP bind(self, wx.EVT_ERASE_BACKGROUND, self._onEraseBackground) DCNL DCSP bind(self, wx.EVT_KEY_DOWN, self._onKeyDown) DCNL DCSP bind(self, wx.EVT_KEY_UP, self._onKeyUp) DCNL DCSP bind(self, wx.EVT_RIGHT_DOWN, self._onRightButtonDown) DCNL DCSP bind(self, wx.EVT_RIGHT_DCLICK, self._onRightButtonDown) DCNL DCSP bind(self, wx.EVT_RIGHT_UP, self._onRightButtonUp) DCNL DCSP bind(self, wx.EVT_MOUSEWHEEL, self._onMouseWheel) DCNL DCSP bind(self, wx.EVT_LEFT_DOWN, self._onLeftButtonDown) DCNL DCSP bind(self, wx.EVT_LEFT_DCLICK, self._onLeftButtonDown) DCNL DCSP bind(self, wx.EVT_LEFT_UP, self._onLeftButtonUp) DCNL DCSP bind(self, wx.EVT_MOTION, self._onMotion) DCNL DCSP bind(self, wx.EVT_LEAVE_WINDOW, self._onLeave) DCNL DCSP bind(self, wx.EVT_ENTER_WINDOW, self._onEnter) DCNL DCSP bind(self, wx.EVT_IDLE, self._onIdle) DCNL DCSP self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM) DCNL DCSP self.macros = {} DCNL DCSP self.Printer_Init()
def Copy_to_Clipboard(self, event=None): DCNL DCSP bmp_obj = wx.BitmapDataObject() DCNL DCSP bmp_obj.SetBitmap(self.bitmap) DCNL DCSP wx.TheClipboard.Open() DCNL DCSP wx.TheClipboard.SetData(bmp_obj) DCNL DCSP wx.TheClipboard.Close()
def Printer_Init(self): DCNL DCSP self.printerData = wx.PrintData() DCNL DCSP self.printerData.SetPaperId(wx.PAPER_LETTER) DCNL DCSP self.printerData.SetPrintMode(wx.PRINT_MODE_PRINTER) DCNL DCSP self.printerPageData = wx.PageSetupDialogData() DCNL DCSP self.printerPageData.SetMarginBottomRight((25, 25)) DCNL DCSP self.printerPageData.SetMarginTopLeft((25, 25)) DCNL DCSP self.printerPageData.SetPrintData(self.printerData) DCNL DCSP self.printer_width = 5.5 DCNL DCSP self.printer_margin = 0.5
def Printer_Setup(self, event=None): DCNL DCSP dmsg = 'Width DCSP of DCSP output DCSP figure DCSP in DCSP inches.\nThe DCSP current DCSP aspect DCSP ration DCSP will DCSP be DCSP kept.' DCNL DCSP dlg = wx.Dialog(self, (-1), 'Page DCSP Setup DCSP for DCSP Printing', ((-1), (-1))) DCNL DCSP df = dlg.GetFont() DCNL DCSP df.SetWeight(wx.NORMAL) DCNL DCSP df.SetPointSize(11) DCNL DCSP dlg.SetFont(df) DCNL DCSP x_wid = wx.TextCtrl(dlg, (-1), value=('%.2f' % self.printer_width), size=(70, (-1))) DCNL DCSP x_mrg = wx.TextCtrl(dlg, (-1), value=('%.2f' % self.printer_margin), size=(70, (-1))) DCNL DCSP sizerAll = wx.BoxSizer(wx.VERTICAL) DCNL DCSP sizerAll.Add(wx.StaticText(dlg, (-1), dmsg), 0, (wx.ALL | wx.EXPAND), 5) DCNL DCSP sizer = wx.FlexGridSizer(0, 3) DCNL DCSP sizerAll.Add(sizer, 0, (wx.ALL | wx.EXPAND), 5) DCNL DCSP sizer.Add(wx.StaticText(dlg, (-1), 'Figure DCSP Width'), 1, (wx.ALIGN_LEFT | wx.ALL), 2) DCNL DCSP sizer.Add(x_wid, 1, (wx.ALIGN_LEFT | wx.ALL), 2) DCNL DCSP sizer.Add(wx.StaticText(dlg, (-1), 'in'), 1, (wx.ALIGN_LEFT | wx.ALL), 2) DCNL DCSP sizer.Add(wx.StaticText(dlg, (-1), 'Margin'), 1, (wx.ALIGN_LEFT | wx.ALL), 2) DCNL DCSP sizer.Add(x_mrg, 1, (wx.ALIGN_LEFT | wx.ALL), 2) DCNL DCSP sizer.Add(wx.StaticText(dlg, (-1), 'in'), 1, (wx.ALIGN_LEFT | wx.ALL), 2) DCNL DCSP btn = wx.Button(dlg, wx.ID_OK, ' DCSP OK DCSP ') DCNL DCSP btn.SetDefault() DCNL DCSP sizer.Add(btn, 1, wx.ALIGN_LEFT, 5) DCNL DCSP btn = wx.Button(dlg, wx.ID_CANCEL, ' DCSP CANCEL DCSP ') DCNL DCSP sizer.Add(btn, 1, wx.ALIGN_LEFT, 5) DCNL DCSP dlg.SetSizer(sizerAll) DCNL DCSP dlg.SetAutoLayout(True) DCNL DCSP sizerAll.Fit(dlg) DCNL DCSP if (dlg.ShowModal() == wx.ID_OK): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self.printer_width = float(x_wid.GetValue()) DCNL DCSP  DCSP  DCSP self.printer_margin = float(x_mrg.GetValue()) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if ((self.printer_width + self.printer_margin) > 7.5): DCNL DCSP  DCSP self.printerData.SetOrientation(wx.LANDSCAPE) DCNL DCSP else: DCNL DCSP  DCSP self.printerData.SetOrientation(wx.PORTRAIT) DCNL DCSP dlg.Destroy() DCNL DCSP return
def Printer_Setup2(self, event=None): DCNL DCSP if hasattr(self, 'printerData'): DCNL DCSP  DCSP data = wx.PageSetupDialogData() DCNL DCSP  DCSP data.SetPrintData(self.printerData) DCNL DCSP else: DCNL DCSP  DCSP data = wx.PageSetupDialogData() DCNL DCSP data.SetMarginTopLeft((15, 15)) DCNL DCSP data.SetMarginBottomRight((15, 15)) DCNL DCSP dlg = wx.PageSetupDialog(self, data) DCNL DCSP if (dlg.ShowModal() == wx.ID_OK): DCNL DCSP  DCSP data = dlg.GetPageSetupData() DCNL DCSP  DCSP tl = data.GetMarginTopLeft() DCNL DCSP  DCSP br = data.GetMarginBottomRight() DCNL DCSP self.printerData = wx.PrintData(data.GetPrintData()) DCNL DCSP dlg.Destroy()
def Printer_Preview(self, event=None): DCNL DCSP po1 = PrintoutWx(self, width=self.printer_width, margin=self.printer_margin) DCNL DCSP po2 = PrintoutWx(self, width=self.printer_width, margin=self.printer_margin) DCNL DCSP self.preview = wx.PrintPreview(po1, po2, self.printerData) DCNL DCSP if (not self.preview.Ok()): DCNL DCSP  DCSP print 'error DCSP with DCSP preview' DCNL DCSP self.preview.SetZoom(50) DCNL DCSP frameInst = self DCNL DCSP while (not isinstance(frameInst, wx.Frame)): DCNL DCSP  DCSP frameInst = frameInst.GetParent() DCNL DCSP frame = wx.PreviewFrame(self.preview, frameInst, 'Preview') DCNL DCSP frame.Initialize() DCNL DCSP frame.SetPosition(self.GetPosition()) DCNL DCSP frame.SetSize((850, 650)) DCNL DCSP frame.Centre(wx.BOTH) DCNL DCSP frame.Show(True) DCNL DCSP self.gui_repaint()
def Printer_Print(self, event=None): DCNL DCSP pdd = wx.PrintDialogData() DCNL DCSP pdd.SetPrintData(self.printerData) DCNL DCSP pdd.SetToPage(1) DCNL DCSP printer = wx.Printer(pdd) DCNL DCSP printout = PrintoutWx(self, width=int(self.printer_width), margin=int(self.printer_margin)) DCNL DCSP print_ok = printer.Print(self, printout, True) DCNL DCSP if (wx.VERSION_STRING >= '2.5'): DCNL DCSP  DCSP if ((not print_ok) and (not (printer.GetLastError() == wx.PRINTER_CANCELLED))): DCNL DCSP  DCSP  DCSP wx.MessageBox('There DCSP was DCSP a DCSP problem DCSP printing.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Perhaps DCSP your DCSP current DCSP printer DCSP is DCSP not DCSP set DCSP correctly?', 'Printing', wx.OK) DCNL DCSP elif (not print_ok): DCNL DCSP  DCSP wx.MessageBox('There DCSP was DCSP a DCSP problem DCSP printing.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Perhaps DCSP your DCSP current DCSP printer DCSP is DCSP not DCSP set DCSP correctly?', 'Printing', wx.OK) DCNL DCSP printout.Destroy() DCNL DCSP self.gui_repaint()
def draw_idle(self): DCNL DCSP DEBUG_MSG('draw_idle()', 1, self) DCNL DCSP self._isDrawn = False DCNL DCSP if hasattr(self, '_idletimer'): DCNL DCSP  DCSP self._idletimer.Restart(IDLE_DELAY) DCNL DCSP else: DCNL DCSP  DCSP self._idletimer = wx.FutureCall(IDLE_DELAY, self._onDrawIdle)
def draw(self, drawDC=None): DCNL DCSP DEBUG_MSG('draw()', 1, self) DCNL DCSP self.renderer = RendererWx(self.bitmap, self.figure.dpi) DCNL DCSP self.figure.draw(self.renderer) DCNL DCSP self._isDrawn = True DCNL DCSP self.gui_repaint(drawDC=drawDC)
def start_event_loop(self, timeout=0): DCNL DCSP if hasattr(self, '_event_loop'): DCNL DCSP  DCSP raise RuntimeError('Event DCSP loop DCSP already DCSP running') DCNL DCSP id = wx.NewId() DCNL DCSP timer = wx.Timer(self, id=id) DCNL DCSP if (timeout > 0): DCNL DCSP  DCSP timer.Start((timeout * 1000), oneShot=True) DCNL DCSP  DCSP bind(self, wx.EVT_TIMER, self.stop_event_loop, id=id) DCNL DCSP self._event_loop = wx.EventLoop() DCNL DCSP self._event_loop.Run() DCNL DCSP timer.Stop()
def stop_event_loop(self, event=None): DCNL DCSP if hasattr(self, '_event_loop'): DCNL DCSP  DCSP if self._event_loop.IsRunning(): DCNL DCSP  DCSP  DCSP self._event_loop.Exit() DCNL DCSP  DCSP del self._event_loop
def _get_imagesave_wildcards(self): DCNL DCSP default_filetype = self.get_default_filetype() DCNL DCSP filetypes = self.get_supported_filetypes_grouped() DCNL DCSP sorted_filetypes = filetypes.items() DCNL DCSP sorted_filetypes.sort() DCNL DCSP wildcards = [] DCNL DCSP extensions = [] DCNL DCSP filter_index = 0 DCNL DCSP for (i, (name, exts)) in enumerate(sorted_filetypes): DCNL DCSP  DCSP ext_list = ';'.join([('*.%s' % ext) for ext in exts]) DCNL DCSP  DCSP extensions.append(exts[0]) DCNL DCSP  DCSP wildcard = ('%s DCSP (%s)|%s' % (name, ext_list, ext_list)) DCNL DCSP  DCSP if (default_filetype in exts): DCNL DCSP  DCSP  DCSP filter_index = i DCNL DCSP  DCSP wildcards.append(wildcard) DCNL DCSP wildcards = '|'.join(wildcards) DCNL DCSP return (wildcards, extensions, filter_index)
def gui_repaint(self, drawDC=None): DCNL DCSP DEBUG_MSG('gui_repaint()', 1, self) DCNL DCSP if self.IsShownOnScreen(): DCNL DCSP  DCSP if (drawDC is None): DCNL DCSP  DCSP  DCSP drawDC = wx.ClientDC(self) DCNL DCSP  DCSP drawDC.BeginDrawing() DCNL DCSP  DCSP drawDC.DrawBitmap(self.bitmap, 0, 0) DCNL DCSP  DCSP drawDC.EndDrawing() DCNL DCSP else: DCNL DCSP  DCSP pass
def _onPaint(self, evt): DCNL DCSP DEBUG_MSG('_onPaint()', 1, self) DCNL DCSP drawDC = wx.PaintDC(self) DCNL DCSP if (not self._isDrawn): DCNL DCSP  DCSP self.draw(drawDC=drawDC) DCNL DCSP else: DCNL DCSP  DCSP self.gui_repaint(drawDC=drawDC) DCNL DCSP evt.Skip()
def _onEraseBackground(self, evt): DCNL DCSP pass
def _onSize(self, evt): DCNL DCSP DEBUG_MSG('_onSize()', 2, self) DCNL DCSP (self._width, self._height) = self.GetClientSize() DCNL DCSP self.bitmap = wx.EmptyBitmap(self._width, self._height) DCNL DCSP self._isDrawn = False DCNL DCSP if ((self._width <= 1) or (self._height <= 1)): DCNL DCSP  DCSP return DCNL DCSP dpival = self.figure.dpi DCNL DCSP winch = (self._width / dpival) DCNL DCSP hinch = (self._height / dpival) DCNL DCSP self.figure.set_size_inches(winch, hinch) DCNL DCSP self.Refresh(eraseBackground=False)
def _onIdle(self, evt): DCNL DCSP evt.Skip() DCNL DCSP FigureCanvasBase.idle_event(self, guiEvent=evt)
def _onKeyDown(self, evt): DCNL DCSP key = self._get_key(evt) DCNL DCSP evt.Skip() DCNL DCSP FigureCanvasBase.key_press_event(self, key, guiEvent=evt)
def _onKeyUp(self, evt): DCNL DCSP key = self._get_key(evt) DCNL DCSP evt.Skip() DCNL DCSP FigureCanvasBase.key_release_event(self, key, guiEvent=evt)
def _onRightButtonDown(self, evt): DCNL DCSP x = evt.GetX() DCNL DCSP y = (self.figure.bbox.height - evt.GetY()) DCNL DCSP evt.Skip() DCNL DCSP self.CaptureMouse() DCNL DCSP FigureCanvasBase.button_press_event(self, x, y, 3, guiEvent=evt)
def _onRightButtonUp(self, evt): DCNL DCSP x = evt.GetX() DCNL DCSP y = (self.figure.bbox.height - evt.GetY()) DCNL DCSP evt.Skip() DCNL DCSP if self.HasCapture(): DCNL DCSP  DCSP self.ReleaseMouse() DCNL DCSP FigureCanvasBase.button_release_event(self, x, y, 3, guiEvent=evt)
def _onLeftButtonDown(self, evt): DCNL DCSP x = evt.GetX() DCNL DCSP y = (self.figure.bbox.height - evt.GetY()) DCNL DCSP evt.Skip() DCNL DCSP self.CaptureMouse() DCNL DCSP FigureCanvasBase.button_press_event(self, x, y, 1, guiEvent=evt)
def _onLeftButtonUp(self, evt): DCNL DCSP x = evt.GetX() DCNL DCSP y = (self.figure.bbox.height - evt.GetY()) DCNL DCSP evt.Skip() DCNL DCSP if self.HasCapture(): DCNL DCSP  DCSP self.ReleaseMouse() DCNL DCSP FigureCanvasBase.button_release_event(self, x, y, 1, guiEvent=evt)
def _onMouseWheel(self, evt): DCNL DCSP x = evt.GetX() DCNL DCSP y = (self.figure.bbox.height - evt.GetY()) DCNL DCSP delta = evt.GetWheelDelta() DCNL DCSP rotation = evt.GetWheelRotation() DCNL DCSP rate = evt.GetLinesPerAction() DCNL DCSP step = ((rate * float(rotation)) / delta) DCNL DCSP evt.Skip() DCNL DCSP if (wx.Platform == '__WXMAC__'): DCNL DCSP  DCSP if (not hasattr(self, '_skipwheelevent')): DCNL DCSP  DCSP  DCSP self._skipwheelevent = True DCNL DCSP  DCSP elif self._skipwheelevent: DCNL DCSP  DCSP  DCSP self._skipwheelevent = False DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._skipwheelevent = True DCNL DCSP FigureCanvasBase.scroll_event(self, x, y, step, guiEvent=evt)
def _onMotion(self, evt): DCNL DCSP x = evt.GetX() DCNL DCSP y = (self.figure.bbox.height - evt.GetY()) DCNL DCSP evt.Skip() DCNL DCSP FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=evt)
def _onLeave(self, evt): DCNL DCSP evt.Skip() DCNL DCSP FigureCanvasBase.leave_notify_event(self, guiEvent=evt)
def _onEnter(self, evt): DCNL DCSP FigureCanvasBase.enter_notify_event(self, guiEvent=evt)
def GetToolBar(self): DCNL DCSP return self.toolbar
def resize(self, width, height): DCNL DCSP self.canvas.SetInitialSize(wx.Size(width, height)) DCNL DCSP self.window.GetSizer().Fit(self.window)
def _onMenuButton(self, evt): DCNL DCSP (x, y) = self.GetPositionTuple() DCNL DCSP (w, h) = self.GetSizeTuple() DCNL DCSP self.PopupMenuXY(self._menu, x, ((y + h) - 4)) DCNL DCSP evt.Skip()
def _handleSelectAllAxes(self, evt): DCNL DCSP if (len(self._axisId) == 0): DCNL DCSP  DCSP return DCNL DCSP for i in range(len(self._axisId)): DCNL DCSP  DCSP self._menu.Check(self._axisId[i], True) DCNL DCSP self._toolbar.set_active(self.getActiveAxes()) DCNL DCSP evt.Skip()
def _handleInvertAxesSelected(self, evt): DCNL DCSP if (len(self._axisId) == 0): DCNL DCSP  DCSP return DCNL DCSP for i in range(len(self._axisId)): DCNL DCSP  DCSP if self._menu.IsChecked(self._axisId[i]): DCNL DCSP  DCSP  DCSP self._menu.Check(self._axisId[i], False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._menu.Check(self._axisId[i], True) DCNL DCSP self._toolbar.set_active(self.getActiveAxes()) DCNL DCSP evt.Skip()
def _onMenuItemSelected(self, evt): DCNL DCSP current = self._menu.IsChecked(evt.GetId()) DCNL DCSP if current: DCNL DCSP  DCSP new = False DCNL DCSP else: DCNL DCSP  DCSP new = True DCNL DCSP self._menu.Check(evt.GetId(), new) DCNL DCSP self._toolbar.set_active(self.getActiveAxes()) DCNL DCSP evt.Skip()
def updateAxes(self, maxAxis): DCNL DCSP if (maxAxis > len(self._axisId)): DCNL DCSP  DCSP for i in range((len(self._axisId) + 1), (maxAxis + 1), 1): DCNL DCSP  DCSP  DCSP menuId = wx.NewId() DCNL DCSP  DCSP  DCSP self._axisId.append(menuId) DCNL DCSP  DCSP  DCSP self._menu.Append(menuId, ('Axis DCSP %d' % i), ('Select DCSP axis DCSP %d' % i), True) DCNL DCSP  DCSP  DCSP self._menu.Check(menuId, True) DCNL DCSP  DCSP  DCSP bind(self, wx.EVT_MENU, self._onMenuItemSelected, id=menuId) DCNL DCSP self._toolbar.set_active(range(len(self._axisId)))
def getActiveAxes(self): DCNL DCSP active = [] DCNL DCSP for i in range(len(self._axisId)): DCNL DCSP  DCSP if self._menu.IsChecked(self._axisId[i]): DCNL DCSP  DCSP  DCSP active.append(i) DCNL DCSP return active
def updateButtonText(self, lst): DCNL DCSP axis_txt = '' DCNL DCSP for e in lst: DCNL DCSP  DCSP axis_txt += ('%d,' % (e + 1)) DCNL DCSP self.SetLabel(('Axes: DCSP %s' % axis_txt[:(-1)]))
def draw_rubberband(self, event, x0, y0, x1, y1): DCNL DCSP canvas = self.canvas DCNL DCSP dc = wx.ClientDC(canvas) DCNL DCSP dc.SetLogicalFunction(wx.XOR) DCNL DCSP wbrush = wx.Brush(wx.Colour(255, 255, 255), wx.TRANSPARENT) DCNL DCSP wpen = wx.Pen(wx.Colour(200, 200, 200), 1, wx.SOLID) DCNL DCSP dc.SetBrush(wbrush) DCNL DCSP dc.SetPen(wpen) DCNL DCSP dc.ResetBoundingBox() DCNL DCSP dc.BeginDrawing() DCNL DCSP height = self.canvas.figure.bbox.height DCNL DCSP y1 = (height - y1) DCNL DCSP y0 = (height - y0) DCNL DCSP if (y1 < y0): DCNL DCSP  DCSP (y0, y1) = (y1, y0) DCNL DCSP if (x1 < y0): DCNL DCSP  DCSP (x0, x1) = (x1, x0) DCNL DCSP w = (x1 - x0) DCNL DCSP h = (y1 - y0) DCNL DCSP rect = (int(x0), int(y0), int(w), int(h)) DCNL DCSP try: DCNL DCSP  DCSP lastrect = self.lastrect DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP dc.DrawRectangle(*lastrect) DCNL DCSP self.lastrect = rect DCNL DCSP dc.DrawRectangle(*rect) DCNL DCSP dc.EndDrawing()
def __init__(self, canvas, can_kill=False): DCNL DCSP wx.ToolBar.__init__(self, canvas.GetParent(), (-1)) DCNL DCSP DEBUG_MSG('__init__()', 1, self) DCNL DCSP self.canvas = canvas DCNL DCSP self._lastControl = None DCNL DCSP self._mouseOnButton = None DCNL DCSP self._parent = canvas.GetParent() DCNL DCSP self._NTB_BUTTON_HANDLER = {_NTB_X_PAN_LEFT: self.panx, _NTB_X_PAN_RIGHT: self.panx, _NTB_X_ZOOMIN: self.zoomx, _NTB_X_ZOOMOUT: self.zoomy, _NTB_Y_PAN_UP: self.pany, _NTB_Y_PAN_DOWN: self.pany, _NTB_Y_ZOOMIN: self.zoomy, _NTB_Y_ZOOMOUT: self.zoomy} DCNL DCSP self._create_menu() DCNL DCSP self._create_controls(can_kill) DCNL DCSP self.Realize()
def _create_menu(self): DCNL DCSP DEBUG_MSG('_create_menu()', 1, self) DCNL DCSP self._menu = MenuButtonWx(self) DCNL DCSP self.AddControl(self._menu) DCNL DCSP self.AddSeparator()
def _create_controls(self, can_kill): DCNL DCSP DEBUG_MSG('_create_controls()', 1, self) DCNL DCSP self.SetToolBitmapSize(wx.Size(16, 16)) DCNL DCSP self.AddSimpleTool(_NTB_X_PAN_LEFT, _load_bitmap('stock_left.xpm'), 'Left', 'Scroll DCSP left') DCNL DCSP self.AddSimpleTool(_NTB_X_PAN_RIGHT, _load_bitmap('stock_right.xpm'), 'Right', 'Scroll DCSP right') DCNL DCSP self.AddSimpleTool(_NTB_X_ZOOMIN, _load_bitmap('stock_zoom-in.xpm'), 'Zoom DCSP in', 'Increase DCSP X DCSP axis DCSP magnification') DCNL DCSP self.AddSimpleTool(_NTB_X_ZOOMOUT, _load_bitmap('stock_zoom-out.xpm'), 'Zoom DCSP out', 'Decrease DCSP X DCSP axis DCSP magnification') DCNL DCSP self.AddSeparator() DCNL DCSP self.AddSimpleTool(_NTB_Y_PAN_UP, _load_bitmap('stock_up.xpm'), 'Up', 'Scroll DCSP up') DCNL DCSP self.AddSimpleTool(_NTB_Y_PAN_DOWN, _load_bitmap('stock_down.xpm'), 'Down', 'Scroll DCSP down') DCNL DCSP self.AddSimpleTool(_NTB_Y_ZOOMIN, _load_bitmap('stock_zoom-in.xpm'), 'Zoom DCSP in', 'Increase DCSP Y DCSP axis DCSP magnification') DCNL DCSP self.AddSimpleTool(_NTB_Y_ZOOMOUT, _load_bitmap('stock_zoom-out.xpm'), 'Zoom DCSP out', 'Decrease DCSP Y DCSP axis DCSP magnification') DCNL DCSP self.AddSeparator() DCNL DCSP self.AddSimpleTool(_NTB_SAVE, _load_bitmap('stock_save_as.xpm'), 'Save', 'Save DCSP plot DCSP contents DCSP as DCSP images') DCNL DCSP self.AddSeparator() DCNL DCSP bind(self, wx.EVT_TOOL, self._onLeftScroll, id=_NTB_X_PAN_LEFT) DCNL DCSP bind(self, wx.EVT_TOOL, self._onRightScroll, id=_NTB_X_PAN_RIGHT) DCNL DCSP bind(self, wx.EVT_TOOL, self._onXZoomIn, id=_NTB_X_ZOOMIN) DCNL DCSP bind(self, wx.EVT_TOOL, self._onXZoomOut, id=_NTB_X_ZOOMOUT) DCNL DCSP bind(self, wx.EVT_TOOL, self._onUpScroll, id=_NTB_Y_PAN_UP) DCNL DCSP bind(self, wx.EVT_TOOL, self._onDownScroll, id=_NTB_Y_PAN_DOWN) DCNL DCSP bind(self, wx.EVT_TOOL, self._onYZoomIn, id=_NTB_Y_ZOOMIN) DCNL DCSP bind(self, wx.EVT_TOOL, self._onYZoomOut, id=_NTB_Y_ZOOMOUT) DCNL DCSP bind(self, wx.EVT_TOOL, self._onSave, id=_NTB_SAVE) DCNL DCSP bind(self, wx.EVT_TOOL_ENTER, self._onEnterTool, id=self.GetId()) DCNL DCSP if can_kill: DCNL DCSP  DCSP bind(self, wx.EVT_TOOL, self._onClose, id=_NTB_CLOSE) DCNL DCSP bind(self, wx.EVT_MOUSEWHEEL, self._onMouseWheel)
def set_active(self, ind): DCNL DCSP DEBUG_MSG('set_active()', 1, self) DCNL DCSP self._ind = ind DCNL DCSP if (ind != None): DCNL DCSP  DCSP self._active = [self._axes[i] for i in self._ind] DCNL DCSP else: DCNL DCSP  DCSP self._active = [] DCNL DCSP self._menu.updateButtonText(ind)
def get_last_control(self): DCNL DCSP return self._lastControl
def update(self): DCNL DCSP DEBUG_MSG('update()', 1, self) DCNL DCSP self._axes = self.canvas.figure.get_axes() DCNL DCSP self._menu.updateAxes(len(self._axes))
def _do_nothing(self, d): DCNL DCSP pass
def __init__(self, id, len, file, extra=None): DCNL DCSP self.id = id DCNL DCSP self.len = len DCNL DCSP self.pdfFile = file DCNL DCSP self.file = file.fh DCNL DCSP self.compressobj = None DCNL DCSP if (extra is None): DCNL DCSP  DCSP self.extra = dict() DCNL DCSP else: DCNL DCSP  DCSP self.extra = extra DCNL DCSP self.pdfFile.recordXref(self.id) DCNL DCSP if rcParams['pdf.compression']: DCNL DCSP  DCSP self.compressobj = zlib.compressobj(rcParams['pdf.compression']) DCNL DCSP if (self.len is None): DCNL DCSP  DCSP self.file = StringIO() DCNL DCSP else: DCNL DCSP  DCSP self._writeHeader() DCNL DCSP  DCSP self.pos = self.file.tell()
def end(self): DCNL DCSP self._flush() DCNL DCSP if (self.len is None): DCNL DCSP  DCSP contents = self.file.getvalue() DCNL DCSP  DCSP self.len = len(contents) DCNL DCSP  DCSP self.file = self.pdfFile.fh DCNL DCSP  DCSP self._writeHeader() DCNL DCSP  DCSP self.file.write(contents) DCNL DCSP  DCSP self.file.write('\nendstream\nendobj\n') DCNL DCSP else: DCNL DCSP  DCSP length = (self.file.tell() - self.pos) DCNL DCSP  DCSP self.file.write('\nendstream\nendobj\n') DCNL DCSP  DCSP self.pdfFile.writeObject(self.len, length)
def write(self, data): DCNL DCSP if (self.compressobj is None): DCNL DCSP  DCSP self.file.write(data) DCNL DCSP else: DCNL DCSP  DCSP compressed = self.compressobj.compress(data) DCNL DCSP  DCSP self.file.write(compressed)
def _flush(self): DCNL DCSP if (self.compressobj is not None): DCNL DCSP  DCSP compressed = self.compressobj.flush() DCNL DCSP  DCSP self.file.write(compressed) DCNL DCSP  DCSP self.compressobj = None
def fontName(self, fontprop): DCNL DCSP if is_string_like(fontprop): DCNL DCSP  DCSP filename = fontprop DCNL DCSP elif rcParams['pdf.use14corefonts']: DCNL DCSP  DCSP filename = findfont(fontprop, fontext='afm') DCNL DCSP else: DCNL DCSP  DCSP filename = findfont(fontprop) DCNL DCSP Fx = self.fontNames.get(filename) DCNL DCSP if (Fx is None): DCNL DCSP  DCSP Fx = Name(('F%d' % self.nextFont)) DCNL DCSP  DCSP self.fontNames[filename] = Fx DCNL DCSP  DCSP self.nextFont += 1 DCNL DCSP return Fx
def embedTTF(self, filename, characters): DCNL DCSP font = FT2Font(str(filename)) DCNL DCSP fonttype = rcParams['pdf.fonttype'] DCNL DCSP def cvt(length, upe=font.units_per_EM, nearest=True): DCNL DCSP  DCSP 'Convert DCSP font DCSP coordinates DCSP to DCSP PDF DCSP glyph DCSP coordinates' DCNL DCSP  DCSP value = ((length / upe) * 1000) DCNL DCSP  DCSP if nearest: DCNL DCSP  DCSP  DCSP return round(value) DCNL DCSP  DCSP if (value < 0): DCNL DCSP  DCSP  DCSP return floor(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ceil(value) DCNL DCSP def embedTTFType3(font, characters, descriptor): DCNL DCSP  DCSP 'The DCSP Type DCSP 3-specific DCSP part DCSP of DCSP embedding DCSP a DCSP Truetype DCSP font' DCNL DCSP  DCSP widthsObject = self.reserveObject('font DCSP widths') DCNL DCSP  DCSP fontdescObject = self.reserveObject('font DCSP descriptor') DCNL DCSP  DCSP fontdictObject = self.reserveObject('font DCSP dictionary') DCNL DCSP  DCSP charprocsObject = self.reserveObject('character DCSP procs') DCNL DCSP  DCSP differencesArray = [] DCNL DCSP  DCSP (firstchar, lastchar) = (0, 255) DCNL DCSP  DCSP bbox = [cvt(x, nearest=False) for x in font.bbox] DCNL DCSP  DCSP fontdict = {'Type': Name('Font'), 'BaseFont': ps_name, 'FirstChar': firstchar, 'LastChar': lastchar, 'FontDescriptor': fontdescObject, 'Subtype': Name('Type3'), 'Name': descriptor['FontName'], 'FontBBox': bbox, 'FontMatrix': [0.001, 0, 0, 0.001, 0, 0], 'CharProcs': charprocsObject, 'Encoding': {'Type': Name('Encoding'), 'Differences': differencesArray}, 'Widths': widthsObject} DCNL DCSP  DCSP from encodings import cp1252 DCNL DCSP  DCSP if hasattr(cp1252, 'decoding_map'): DCNL DCSP  DCSP  DCSP def decode_char(charcode): DCNL DCSP  DCSP  DCSP  DCSP return (cp1252.decoding_map[charcode] or 0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP def decode_char(charcode): DCNL DCSP  DCSP  DCSP  DCSP return ord(cp1252.decoding_table[charcode]) DCNL DCSP  DCSP def get_char_width(charcode): DCNL DCSP  DCSP  DCSP unicode = decode_char(charcode) DCNL DCSP  DCSP  DCSP width = font.load_char(unicode, flags=(LOAD_NO_SCALE | LOAD_NO_HINTING)).horiAdvance DCNL DCSP  DCSP  DCSP return cvt(width) DCNL DCSP  DCSP widths = [get_char_width(charcode) for charcode in range(firstchar, (lastchar + 1))] DCNL DCSP  DCSP descriptor['MaxWidth'] = max(widths) DCNL DCSP  DCSP cmap = font.get_charmap() DCNL DCSP  DCSP glyph_ids = [] DCNL DCSP  DCSP differences = [] DCNL DCSP  DCSP multi_byte_chars = set() DCNL DCSP  DCSP for c in characters: DCNL DCSP  DCSP  DCSP ccode = c DCNL DCSP  DCSP  DCSP gind = (cmap.get(ccode) or 0) DCNL DCSP  DCSP  DCSP glyph_ids.append(gind) DCNL DCSP  DCSP  DCSP glyph_name = font.get_glyph_name(gind) DCNL DCSP  DCSP  DCSP if (ccode <= 255): DCNL DCSP  DCSP  DCSP  DCSP differences.append((ccode, glyph_name)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP multi_byte_chars.add(glyph_name) DCNL DCSP  DCSP differences.sort() DCNL DCSP  DCSP last_c = (-2) DCNL DCSP  DCSP for (c, name) in differences: DCNL DCSP  DCSP  DCSP if (c != (last_c + 1)): DCNL DCSP  DCSP  DCSP  DCSP differencesArray.append(c) DCNL DCSP  DCSP  DCSP differencesArray.append(Name(name)) DCNL DCSP  DCSP  DCSP last_c = c DCNL DCSP  DCSP rawcharprocs = ttconv.get_pdf_charprocs(filename, glyph_ids) DCNL DCSP  DCSP charprocs = {} DCNL DCSP  DCSP charprocsRef = {} DCNL DCSP  DCSP for (charname, stream) in rawcharprocs.items(): DCNL DCSP  DCSP  DCSP charprocDict = {'Length': len(stream)} DCNL DCSP  DCSP  DCSP if (charname in multi_byte_chars): DCNL DCSP  DCSP  DCSP  DCSP charprocDict['Type'] = Name('XObject') DCNL DCSP  DCSP  DCSP  DCSP charprocDict['Subtype'] = Name('Form') DCNL DCSP  DCSP  DCSP  DCSP charprocDict['BBox'] = bbox DCNL DCSP  DCSP  DCSP  DCSP stream = stream[(stream.find('d1') + 2):] DCNL DCSP  DCSP  DCSP charprocObject = self.reserveObject('charProc') DCNL DCSP  DCSP  DCSP self.beginStream(charprocObject.id, None, charprocDict) DCNL DCSP  DCSP  DCSP self.currentstream.write(stream) DCNL DCSP  DCSP  DCSP self.endStream() DCNL DCSP  DCSP  DCSP if (charname in multi_byte_chars): DCNL DCSP  DCSP  DCSP  DCSP name = self._get_xobject_symbol_name(filename, charname) DCNL DCSP  DCSP  DCSP  DCSP self.multi_byte_charprocs[name] = charprocObject DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP charprocs[charname] = charprocObject DCNL DCSP  DCSP self.writeObject(fontdictObject, fontdict) DCNL DCSP  DCSP self.writeObject(fontdescObject, descriptor) DCNL DCSP  DCSP self.writeObject(widthsObject, widths) DCNL DCSP  DCSP self.writeObject(charprocsObject, charprocs) DCNL DCSP  DCSP return fontdictObject DCNL DCSP def embedTTFType42(font, characters, descriptor): DCNL DCSP  DCSP 'The DCSP Type DCSP 42-specific DCSP part DCSP of DCSP embedding DCSP a DCSP Truetype DCSP font' DCNL DCSP  DCSP fontdescObject = self.reserveObject('font DCSP descriptor') DCNL DCSP  DCSP cidFontDictObject = self.reserveObject('CID DCSP font DCSP dictionary') DCNL DCSP  DCSP type0FontDictObject = self.reserveObject('Type DCSP 0 DCSP font DCSP dictionary') DCNL DCSP  DCSP cidToGidMapObject = self.reserveObject('CIDToGIDMap DCSP stream') DCNL DCSP  DCSP fontfileObject = self.reserveObject('font DCSP file DCSP stream') DCNL DCSP  DCSP wObject = self.reserveObject('Type DCSP 0 DCSP widths') DCNL DCSP  DCSP toUnicodeMapObject = self.reserveObject('ToUnicode DCSP map') DCNL DCSP  DCSP cidFontDict = {'Type': Name('Font'), 'Subtype': Name('CIDFontType2'), 'BaseFont': ps_name, 'CIDSystemInfo': {'Registry': 'Adobe', 'Ordering': 'Identity', 'Supplement': 0}, 'FontDescriptor': fontdescObject, 'W': wObject, 'CIDToGIDMap': cidToGidMapObject} DCNL DCSP  DCSP type0FontDict = {'Type': Name('Font'), 'Subtype': Name('Type0'), 'BaseFont': ps_name, 'Encoding': Name('Identity-H'), 'DescendantFonts': [cidFontDictObject], 'ToUnicode': toUnicodeMapObject} DCNL DCSP  DCSP descriptor['FontFile2'] = fontfileObject DCNL DCSP  DCSP length1Object = self.reserveObject('decoded DCSP length DCSP of DCSP a DCSP font') DCNL DCSP  DCSP self.beginStream(fontfileObject.id, self.reserveObject('length DCSP of DCSP font DCSP stream'), {'Length1': length1Object}) DCNL DCSP  DCSP fontfile = open(filename, 'rb') DCNL DCSP  DCSP length1 = 0 DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP data = fontfile.read(4096) DCNL DCSP  DCSP  DCSP if (not data): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP length1 += len(data) DCNL DCSP  DCSP  DCSP self.currentstream.write(data) DCNL DCSP  DCSP fontfile.close() DCNL DCSP  DCSP self.endStream() DCNL DCSP  DCSP self.writeObject(length1Object, length1) DCNL DCSP  DCSP cid_to_gid_map = ([u'\x00'] * 65536) DCNL DCSP  DCSP cmap = font.get_charmap() DCNL DCSP  DCSP unicode_mapping = [] DCNL DCSP  DCSP widths = [] DCNL DCSP  DCSP max_ccode = 0 DCNL DCSP  DCSP for c in characters: DCNL DCSP  DCSP  DCSP ccode = c DCNL DCSP  DCSP  DCSP gind = (cmap.get(ccode) or 0) DCNL DCSP  DCSP  DCSP glyph = font.load_char(ccode, flags=LOAD_NO_HINTING) DCNL DCSP  DCSP  DCSP widths.append((ccode, (glyph.horiAdvance / 6))) DCNL DCSP  DCSP  DCSP if (ccode < 65536): DCNL DCSP  DCSP  DCSP  DCSP cid_to_gid_map[ccode] = unichr(gind) DCNL DCSP  DCSP  DCSP max_ccode = max(ccode, max_ccode) DCNL DCSP  DCSP widths.sort() DCNL DCSP  DCSP cid_to_gid_map = cid_to_gid_map[:(max_ccode + 1)] DCNL DCSP  DCSP last_ccode = (-2) DCNL DCSP  DCSP w = [] DCNL DCSP  DCSP max_width = 0 DCNL DCSP  DCSP unicode_groups = [] DCNL DCSP  DCSP for (ccode, width) in widths: DCNL DCSP  DCSP  DCSP if (ccode != (last_ccode + 1)): DCNL DCSP  DCSP  DCSP  DCSP w.append(ccode) DCNL DCSP  DCSP  DCSP  DCSP w.append([width]) DCNL DCSP  DCSP  DCSP  DCSP unicode_groups.append([ccode, ccode]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP w[(-1)].append(width) DCNL DCSP  DCSP  DCSP  DCSP unicode_groups[(-1)][1] = ccode DCNL DCSP  DCSP  DCSP max_width = max(max_width, width) DCNL DCSP  DCSP  DCSP last_ccode = ccode DCNL DCSP  DCSP unicode_bfrange = [] DCNL DCSP  DCSP for (start, end) in unicode_groups: DCNL DCSP  DCSP  DCSP unicode_bfrange.append(('<%04x> DCSP <%04x> DCSP [%s]' % (start, end, ' DCSP '.join([('<%04x>' % x) for x in range(start, (end + 1))])))) DCNL DCSP  DCSP unicode_cmap = (self._identityToUnicodeCMap % (len(unicode_groups), '\n'.join(unicode_bfrange))) DCNL DCSP  DCSP cid_to_gid_map = ''.join(cid_to_gid_map).encode('utf-16be') DCNL DCSP  DCSP self.beginStream(cidToGidMapObject.id, None, {'Length': len(cid_to_gid_map)}) DCNL DCSP  DCSP self.currentstream.write(cid_to_gid_map) DCNL DCSP  DCSP self.endStream() DCNL DCSP  DCSP self.beginStream(toUnicodeMapObject.id, None, {'Length': unicode_cmap}) DCNL DCSP  DCSP self.currentstream.write(unicode_cmap) DCNL DCSP  DCSP self.endStream() DCNL DCSP  DCSP descriptor['MaxWidth'] = max_width DCNL DCSP  DCSP self.writeObject(cidFontDictObject, cidFontDict) DCNL DCSP  DCSP self.writeObject(type0FontDictObject, type0FontDict) DCNL DCSP  DCSP self.writeObject(fontdescObject, descriptor) DCNL DCSP  DCSP self.writeObject(wObject, w) DCNL DCSP  DCSP return type0FontDictObject DCNL DCSP ps_name = Name(font.get_sfnt()[(1, 0, 0, 6)]) DCNL DCSP pclt = (font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}) DCNL DCSP post = (font.get_sfnt_table('post') or {'italicAngle': (0, 0)}) DCNL DCSP ff = font.face_flags DCNL DCSP sf = font.style_flags DCNL DCSP flags = 0 DCNL DCSP symbolic = False DCNL DCSP if (ff & FIXED_WIDTH): DCNL DCSP  DCSP flags |= (1 << 0) DCNL DCSP if 0: DCNL DCSP  DCSP flags |= (1 << 1) DCNL DCSP if symbolic: DCNL DCSP  DCSP flags |= (1 << 2) DCNL DCSP else: DCNL DCSP  DCSP flags |= (1 << 5) DCNL DCSP if (sf & ITALIC): DCNL DCSP  DCSP flags |= (1 << 6) DCNL DCSP if 0: DCNL DCSP  DCSP flags |= (1 << 16) DCNL DCSP if 0: DCNL DCSP  DCSP flags |= (1 << 17) DCNL DCSP if 0: DCNL DCSP  DCSP flags |= (1 << 18) DCNL DCSP descriptor = {'Type': Name('FontDescriptor'), 'FontName': ps_name, 'Flags': flags, 'FontBBox': [cvt(x, nearest=False) for x in font.bbox], 'Ascent': cvt(font.ascender, nearest=False), 'Descent': cvt(font.descender, nearest=False), 'CapHeight': cvt(pclt['capHeight'], nearest=False), 'XHeight': cvt(pclt['xHeight']), 'ItalicAngle': post['italicAngle'][1], 'StemV': 0} DCNL DCSP if is_opentype_cff_font(filename): DCNL DCSP  DCSP fonttype = 42 DCNL DCSP  DCSP warnings.warn((("'%s' DCSP can DCSP not DCSP be DCSP subsetted DCSP into DCSP a DCSP Type DCSP 3 DCSP font. DCSP " + 'The DCSP entire DCSP font DCSP will DCSP be DCSP embedded DCSP in DCSP the DCSP output.') % os.path.basename(filename))) DCNL DCSP if (fonttype == 3): DCNL DCSP  DCSP return embedTTFType3(font, characters, descriptor) DCNL DCSP elif (fonttype == 42): DCNL DCSP  DCSP return embedTTFType42(font, characters, descriptor)
def alphaState(self, alpha): DCNL DCSP state = self.alphaStates.get(alpha, None) DCNL DCSP if (state is not None): DCNL DCSP  DCSP return state[0] DCNL DCSP name = Name(('A%d' % self.nextAlphaState)) DCNL DCSP self.nextAlphaState += 1 DCNL DCSP self.alphaStates[alpha] = (name, {'Type': Name('ExtGState'), 'CA': alpha, 'ca': alpha}) DCNL DCSP return name
def imageObject(self, image): DCNL DCSP pair = self.images.get(image, None) DCNL DCSP if (pair is not None): DCNL DCSP  DCSP return pair[0] DCNL DCSP name = Name(('I%d' % self.nextImage)) DCNL DCSP ob = self.reserveObject(('image DCSP %d' % self.nextImage)) DCNL DCSP self.nextImage += 1 DCNL DCSP self.images[image] = (name, ob) DCNL DCSP return name
def markerObject(self, path, trans, fillp, lw): DCNL DCSP key = (path, trans, (fillp is not None), lw) DCNL DCSP result = self.markers.get(key) DCNL DCSP if (result is None): DCNL DCSP  DCSP name = Name(('M%d' % len(self.markers))) DCNL DCSP  DCSP ob = self.reserveObject(('marker DCSP %d' % len(self.markers))) DCNL DCSP  DCSP self.markers[key] = (name, ob, path, trans, fillp, lw) DCNL DCSP else: DCNL DCSP  DCSP name = result[0] DCNL DCSP return name
def reserveObject(self, name=''): DCNL DCSP id = self.nextObject DCNL DCSP self.nextObject += 1 DCNL DCSP self.xrefTable.append([None, 0, name]) DCNL DCSP return Reference(id)
def writeXref(self): DCNL DCSP self.startxref = self.fh.tell() DCNL DCSP self.write(('xref\n0 DCSP %d\n' % self.nextObject)) DCNL DCSP i = 0 DCNL DCSP borken = False DCNL DCSP for (offset, generation, name) in self.xrefTable: DCNL DCSP  DCSP if (offset is None): DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('No DCSP offset DCSP for DCSP object DCSP %d DCSP (%s)' % (i, name)) DCNL DCSP  DCSP  DCSP borken = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.write(('%010d DCSP %05d DCSP n DCSP \n' % (offset, generation))) DCNL DCSP  DCSP i += 1 DCNL DCSP if borken: DCNL DCSP  DCSP raise AssertionError, 'Indirect DCSP object DCSP does DCSP not DCSP exist'
def writeTrailer(self): DCNL DCSP self.write('trailer\n') DCNL DCSP self.write(pdfRepr({'Size': self.nextObject, 'Root': self.rootObject, 'Info': self.infoObject})) DCNL DCSP self.write(('\nstartxref\n%d\n%%%%EOF\n' % self.startxref))
def track_characters(self, font, s): DCNL DCSP if isinstance(font, (str, unicode)): DCNL DCSP  DCSP fname = font DCNL DCSP else: DCNL DCSP  DCSP fname = font.fname DCNL DCSP (realpath, stat_key) = get_realpath_and_stat(fname) DCNL DCSP used_characters = self.used_characters.setdefault(stat_key, (realpath, set())) DCNL DCSP used_characters[1].update([ord(x) for x in s])
def clip_cmd(self, cliprect, clippath): DCNL DCSP cmds = [] DCNL DCSP while (((self._cliprect, self._clippath) != (cliprect, clippath)) and (self.parent is not None)): DCNL DCSP  DCSP cmds.extend(self.pop()) DCNL DCSP if ((self._cliprect, self._clippath) != (cliprect, clippath)): DCNL DCSP  DCSP cmds.extend(self.push()) DCNL DCSP  DCSP if (self._cliprect != cliprect): DCNL DCSP  DCSP  DCSP cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath]) DCNL DCSP  DCSP if (self._clippath != clippath): DCNL DCSP  DCSP  DCSP cmds.extend((PdfFile.pathOperations(*clippath.get_transformed_path_and_affine()) + [Op.clip, Op.endpath])) DCNL DCSP return cmds
def delta(self, other): DCNL DCSP cmds = [] DCNL DCSP for (params, cmd) in self.commands: DCNL DCSP  DCSP different = False DCNL DCSP  DCSP for p in params: DCNL DCSP  DCSP  DCSP ours = getattr(self, p) DCNL DCSP  DCSP  DCSP theirs = getattr(other, p) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP different = bool((ours != theirs)) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP ours = npy.asarray(ours) DCNL DCSP  DCSP  DCSP  DCSP theirs = npy.asarray(theirs) DCNL DCSP  DCSP  DCSP  DCSP different = ((ours.shape != theirs.shape) or npy.any((ours != theirs))) DCNL DCSP  DCSP  DCSP if different: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if different: DCNL DCSP  DCSP  DCSP theirs = [getattr(other, p) for p in params] DCNL DCSP  DCSP  DCSP cmds.extend(cmd(self, *theirs)) DCNL DCSP  DCSP  DCSP for p in params: DCNL DCSP  DCSP  DCSP  DCSP setattr(self, p, getattr(other, p)) DCNL DCSP return cmds
def copy_properties(self, other): DCNL DCSP GraphicsContextBase.copy_properties(self, other) DCNL DCSP self._fillcolor = other._fillcolor
def finalize(self): DCNL DCSP cmds = [] DCNL DCSP while (self.parent is not None): DCNL DCSP  DCSP cmds.extend(self.pop()) DCNL DCSP return cmds
def __init__(self, width, height, pswriter, imagedpi=72): DCNL DCSP RendererBase.__init__(self) DCNL DCSP self.width = width DCNL DCSP self.height = height DCNL DCSP self._pswriter = pswriter DCNL DCSP if rcParams['text.usetex']: DCNL DCSP  DCSP self.textcnt = 0 DCNL DCSP  DCSP self.psfrag = [] DCNL DCSP self.imagedpi = imagedpi DCNL DCSP if rcParams['path.simplify']: DCNL DCSP  DCSP self.simplify = ((width * imagedpi), (height * imagedpi)) DCNL DCSP else: DCNL DCSP  DCSP self.simplify = None DCNL DCSP self.color = None DCNL DCSP self.linewidth = None DCNL DCSP self.linejoin = None DCNL DCSP self.linecap = None DCNL DCSP self.linedash = None DCNL DCSP self.fontname = None DCNL DCSP self.fontsize = None DCNL DCSP self.hatch = None DCNL DCSP self.image_magnification = (imagedpi / 72.0) DCNL DCSP self._clip_paths = {} DCNL DCSP self._path_collection_id = 0 DCNL DCSP self.used_characters = {} DCNL DCSP self.mathtext_parser = MathTextParser('PS')
def track_characters(self, font, s): DCNL DCSP (realpath, stat_key) = get_realpath_and_stat(font.fname) DCNL DCSP used_characters = self.used_characters.setdefault(stat_key, (realpath, set())) DCNL DCSP used_characters[1].update([ord(x) for x in s])
def set_hatch(self, hatch): DCNL DCSP hatches = {'horiz': 0, 'vert': 0, 'diag1': 0, 'diag2': 0} DCNL DCSP for letter in hatch: DCNL DCSP  DCSP if (letter == '/'): DCNL DCSP  DCSP  DCSP hatches['diag2'] += 1 DCNL DCSP  DCSP elif (letter == '\\'): DCNL DCSP  DCSP  DCSP hatches['diag1'] += 1 DCNL DCSP  DCSP elif (letter == '|'): DCNL DCSP  DCSP  DCSP hatches['vert'] += 1 DCNL DCSP  DCSP elif (letter == '-'): DCNL DCSP  DCSP  DCSP hatches['horiz'] += 1 DCNL DCSP  DCSP elif (letter == '+'): DCNL DCSP  DCSP  DCSP hatches['horiz'] += 1 DCNL DCSP  DCSP  DCSP hatches['vert'] += 1 DCNL DCSP  DCSP elif (letter.lower() == 'x'): DCNL DCSP  DCSP  DCSP hatches['diag1'] += 1 DCNL DCSP  DCSP  DCSP hatches['diag2'] += 1 DCNL DCSP def do_hatch(angle, density): DCNL DCSP  DCSP if (density == 0): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP return (' DCSP  DCSP gsave\n DCSP  DCSP  DCSP eoclip DCSP %s DCSP rotate DCSP 0.0 DCSP 0.0 DCSP 0.0 DCSP 0.0 DCSP setrgbcolor DCSP 0 DCSP setlinewidth\n DCSP  DCSP  DCSP /hatchgap DCSP %d DCSP def\n DCSP  DCSP  DCSP pathbbox DCSP /hatchb DCSP exch DCSP def DCSP /hatchr DCSP exch DCSP def DCSP /hatcht DCSP exch DCSP def DCSP /hatchl DCSP exch DCSP def\n DCSP  DCSP  DCSP hatchl DCSP cvi DCSP hatchgap DCSP idiv DCSP hatchgap DCSP mul\n DCSP  DCSP  DCSP hatchgap\n DCSP  DCSP  DCSP hatchr DCSP cvi DCSP hatchgap DCSP idiv DCSP hatchgap DCSP mul\n DCSP  DCSP  DCSP {hatcht DCSP m DCSP 0 DCSP hatchb DCSP hatcht DCSP sub DCSP r DCSP }\n DCSP  DCSP  DCSP for\n DCSP  DCSP  DCSP stroke\n DCSP  DCSP grestore\n DCSP ' % (angle, (12 / density))) DCNL DCSP self._pswriter.write('gsave\n') DCNL DCSP self._pswriter.write(do_hatch(90, hatches['horiz'])) DCNL DCSP self._pswriter.write(do_hatch(0, hatches['vert'])) DCNL DCSP self._pswriter.write(do_hatch(45, hatches['diag1'])) DCNL DCSP self._pswriter.write(do_hatch((-45), hatches['diag2'])) DCNL DCSP self._pswriter.write('grestore\n')
def get_canvas_width_height(self): DCNL DCSP return (self.width, self.height)
def get_text_width_height_descent(self, s, prop, ismath): DCNL DCSP if rcParams['text.usetex']: DCNL DCSP  DCSP texmanager = self.get_texmanager() DCNL DCSP  DCSP fontsize = prop.get_size_in_points() DCNL DCSP  DCSP (l, b, r, t) = texmanager.get_ps_bbox(s, fontsize) DCNL DCSP  DCSP w = (r - l) DCNL DCSP  DCSP h = (t - b) DCNL DCSP  DCSP return (w, h, 0) DCNL DCSP if ismath: DCNL DCSP  DCSP (width, height, descent, pswriter, used_characters) = self.mathtext_parser.parse(s, 72, prop) DCNL DCSP  DCSP return (width, height, descent) DCNL DCSP if rcParams['ps.useafm']: DCNL DCSP  DCSP if ismath: DCNL DCSP  DCSP  DCSP s = s[1:(-1)] DCNL DCSP  DCSP font = self._get_font_afm(prop) DCNL DCSP  DCSP (l, b, w, h, d) = font.get_str_bbox_and_descent(s) DCNL DCSP  DCSP fontsize = prop.get_size_in_points() DCNL DCSP  DCSP scale = (0.001 * fontsize) DCNL DCSP  DCSP w *= scale DCNL DCSP  DCSP h *= scale DCNL DCSP  DCSP d *= scale DCNL DCSP  DCSP return (w, h, d) DCNL DCSP font = self._get_font_ttf(prop) DCNL DCSP font.set_text(s, 0.0, flags=LOAD_NO_HINTING) DCNL DCSP (w, h) = font.get_width_height() DCNL DCSP w /= 64.0 DCNL DCSP h /= 64.0 DCNL DCSP d = font.get_descent() DCNL DCSP d /= 64.0 DCNL DCSP return (w, h, d)
def flipy(self): DCNL DCSP return False
def get_image_magnification(self): DCNL DCSP return self.image_magnification
def draw_image(self, x, y, im, bbox, clippath=None, clippath_trans=None): DCNL DCSP im.flipud_out() DCNL DCSP if im.is_grayscale: DCNL DCSP  DCSP (h, w, bits) = self._gray(im) DCNL DCSP  DCSP imagecmd = 'image' DCNL DCSP else: DCNL DCSP  DCSP (h, w, bits) = self._rgb(im) DCNL DCSP  DCSP imagecmd = 'false DCSP 3 DCSP colorimage' DCNL DCSP hexlines = '\n'.join(self._hex_lines(bits)) DCNL DCSP (xscale, yscale) = ((w / self.image_magnification), (h / self.image_magnification)) DCNL DCSP figh = (self.height * 72) DCNL DCSP clip = [] DCNL DCSP if (bbox is not None): DCNL DCSP  DCSP (clipx, clipy, clipw, cliph) = bbox.bounds DCNL DCSP  DCSP clip.append(('%s DCSP clipbox' % _nums_to_str(clipw, cliph, clipx, clipy))) DCNL DCSP if (clippath is not None): DCNL DCSP  DCSP id = self._get_clip_path(clippath, clippath_trans) DCNL DCSP  DCSP clip.append(('%s' % id)) DCNL DCSP clip = '\n'.join(clip) DCNL DCSP ps = ('gsave\n%(clip)s\n%(x)s DCSP %(y)s DCSP translate\n%(xscale)s DCSP %(yscale)s DCSP scale\n/DataString DCSP %(w)s DCSP string DCSP def\n%(w)s DCSP %(h)s DCSP 8 DCSP [ DCSP %(w)s DCSP 0 DCSP 0 DCSP -%(h)s DCSP 0 DCSP %(h)s DCSP ]\n{\ncurrentfile DCSP DataString DCSP readhexstring DCSP pop\n} DCSP bind DCSP %(imagecmd)s\n%(hexlines)s\ngrestore\n' % locals()) DCNL DCSP self._pswriter.write(ps) DCNL DCSP im.flipud_out()
def draw_path(self, gc, path, transform, rgbFace=None): DCNL DCSP ps = self._convert_path(path, transform, self.simplify) DCNL DCSP self._draw_ps(ps, gc, rgbFace)
def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None): DCNL DCSP if debugPS: DCNL DCSP  DCSP self._pswriter.write('% DCSP draw_markers DCSP \n') DCNL DCSP write = self._pswriter.write DCNL DCSP if rgbFace: DCNL DCSP  DCSP if ((rgbFace[0] == rgbFace[1]) and (rgbFace[0] == rgbFace[2])): DCNL DCSP  DCSP  DCSP ps_color = ('%1.3f DCSP setgray' % rgbFace[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ps_color = ('%1.3f DCSP %1.3f DCSP %1.3f DCSP setrgbcolor' % rgbFace) DCNL DCSP ps_cmd = ['/o DCSP {', 'gsave', 'newpath', 'translate'] DCNL DCSP ps_cmd.append(self._convert_path(marker_path, marker_trans)) DCNL DCSP if rgbFace: DCNL DCSP  DCSP ps_cmd.extend(['gsave', ps_color, 'fill', 'grestore']) DCNL DCSP ps_cmd.extend(['stroke', 'grestore', '} DCSP bind DCSP def']) DCNL DCSP tpath = trans.transform_path(path) DCNL DCSP for (vertices, code) in tpath.iter_segments(): DCNL DCSP  DCSP if len(vertices): DCNL DCSP  DCSP  DCSP (x, y) = vertices[(-2):] DCNL DCSP  DCSP  DCSP ps_cmd.append(('%g DCSP %g DCSP o' % (x, y))) DCNL DCSP ps = '\n'.join(ps_cmd) DCNL DCSP self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False)
def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!'): DCNL DCSP (w, h, bl) = self.get_text_width_height_descent(s, prop, ismath) DCNL DCSP fontsize = prop.get_size_in_points() DCNL DCSP corr = 0 DCNL DCSP pos = _nums_to_str((x - corr), y) DCNL DCSP thetext = ('psmarker%d' % self.textcnt) DCNL DCSP color = ('%1.3f,%1.3f,%1.3f' % gc.get_rgb()[:3]) DCNL DCSP fontcmd = {'sans-serif': '{\\sffamily DCSP %s}', 'monospace': '{\\ttfamily DCSP %s}'}.get(rcParams['font.family'], '{\\rmfamily DCSP %s}') DCNL DCSP s = (fontcmd % s) DCNL DCSP tex = ('\\color[rgb]{%s} DCSP %s' % (color, s)) DCNL DCSP self.psfrag.append(('\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}' % (thetext, angle, fontsize, (fontsize * 1.25), tex))) DCNL DCSP ps = ('gsave\n%(pos)s DCSP moveto\n(%(thetext)s)\nshow\ngrestore\n DCSP  DCSP  DCSP  DCSP ' % locals()) DCNL DCSP self._pswriter.write(ps) DCNL DCSP self.textcnt += 1
def draw_text(self, gc, x, y, s, prop, angle, ismath): DCNL DCSP write = self._pswriter.write DCNL DCSP if debugPS: DCNL DCSP  DCSP write('% DCSP text\n') DCNL DCSP if (ismath == 'TeX'): DCNL DCSP  DCSP return self.tex(gc, x, y, s, prop, angle) DCNL DCSP elif ismath: DCNL DCSP  DCSP return self.draw_mathtext(gc, x, y, s, prop, angle) DCNL DCSP elif isinstance(s, unicode): DCNL DCSP  DCSP return self.draw_unicode(gc, x, y, s, prop, angle) DCNL DCSP elif rcParams['ps.useafm']: DCNL DCSP  DCSP font = self._get_font_afm(prop) DCNL DCSP  DCSP (l, b, w, h) = font.get_str_bbox(s) DCNL DCSP  DCSP fontsize = prop.get_size_in_points() DCNL DCSP  DCSP l *= (0.001 * fontsize) DCNL DCSP  DCSP b *= (0.001 * fontsize) DCNL DCSP  DCSP w *= (0.001 * fontsize) DCNL DCSP  DCSP h *= (0.001 * fontsize) DCNL DCSP  DCSP if (angle == 90): DCNL DCSP  DCSP  DCSP (l, b) = ((- b), l) DCNL DCSP  DCSP pos = _nums_to_str((x - l), (y - b)) DCNL DCSP  DCSP thetext = ('(%s)' % s) DCNL DCSP  DCSP fontname = font.get_fontname() DCNL DCSP  DCSP fontsize = prop.get_size_in_points() DCNL DCSP  DCSP rotate = ('%1.1f DCSP rotate' % angle) DCNL DCSP  DCSP setcolor = ('%1.3f DCSP %1.3f DCSP %1.3f DCSP setrgbcolor' % gc.get_rgb()[:3]) DCNL DCSP  DCSP ps = ('gsave\n/%(fontname)s DCSP findfont\n%(fontsize)s DCSP scalefont\nsetfont\n%(pos)s DCSP moveto\n%(rotate)s\n%(thetext)s\n%(setcolor)s\nshow\ngrestore\n DCSP  DCSP  DCSP  DCSP ' % locals()) DCNL DCSP  DCSP self._draw_ps(ps, gc, None) DCNL DCSP else: DCNL DCSP  DCSP font = self._get_font_ttf(prop) DCNL DCSP  DCSP font.set_text(s, 0, flags=LOAD_NO_HINTING) DCNL DCSP  DCSP self.track_characters(font, s) DCNL DCSP  DCSP self.set_color(*gc.get_rgb()) DCNL DCSP  DCSP self.set_font(font.get_sfnt()[(1, 0, 0, 6)], prop.get_size_in_points()) DCNL DCSP  DCSP write(('%s DCSP m\n' % _nums_to_str(x, y))) DCNL DCSP  DCSP if angle: DCNL DCSP  DCSP  DCSP write('gsave\n') DCNL DCSP  DCSP  DCSP write(('%s DCSP rotate\n' % _num_to_str(angle))) DCNL DCSP  DCSP descent = (font.get_descent() / 64.0) DCNL DCSP  DCSP if descent: DCNL DCSP  DCSP  DCSP write(('0 DCSP %s DCSP rmoveto\n' % _num_to_str(descent))) DCNL DCSP  DCSP write(('(%s) DCSP show\n' % quote_ps_string(s))) DCNL DCSP  DCSP if angle: DCNL DCSP  DCSP  DCSP write('grestore\n')
def draw_unicode(self, gc, x, y, s, prop, angle): DCNL DCSP if rcParams['ps.useafm']: DCNL DCSP  DCSP self.set_color(*gc.get_rgb()) DCNL DCSP  DCSP font = self._get_font_afm(prop) DCNL DCSP  DCSP fontname = font.get_fontname() DCNL DCSP  DCSP fontsize = prop.get_size_in_points() DCNL DCSP  DCSP scale = (0.001 * fontsize) DCNL DCSP  DCSP thisx = 0 DCNL DCSP  DCSP thisy = (font.get_str_bbox_and_descent(s)[4] * scale) DCNL DCSP  DCSP last_name = None DCNL DCSP  DCSP lines = [] DCNL DCSP  DCSP for c in s: DCNL DCSP  DCSP  DCSP name = uni2type1.get(ord(c), 'question') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP width = font.get_width_from_char_name(name) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP name = 'question' DCNL DCSP  DCSP  DCSP  DCSP width = font.get_width_char('?') DCNL DCSP  DCSP  DCSP if (last_name is not None): DCNL DCSP  DCSP  DCSP  DCSP kern = font.get_kern_dist_from_name(last_name, name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP kern = 0 DCNL DCSP  DCSP  DCSP last_name = name DCNL DCSP  DCSP  DCSP thisx += (kern * scale) DCNL DCSP  DCSP  DCSP lines.append(('%f DCSP %f DCSP m DCSP /%s DCSP glyphshow' % (thisx, thisy, name))) DCNL DCSP  DCSP  DCSP thisx += (width * scale) DCNL DCSP  DCSP thetext = '\n'.join(lines) DCNL DCSP  DCSP ps = ('gsave\n/%(fontname)s DCSP findfont\n%(fontsize)s DCSP scalefont\nsetfont\n%(x)f DCSP %(y)f DCSP translate\n%(angle)f DCSP rotate\n%(thetext)s\ngrestore\n DCSP  DCSP  DCSP  DCSP ' % locals()) DCNL DCSP  DCSP self._pswriter.write(ps) DCNL DCSP else: DCNL DCSP  DCSP font = self._get_font_ttf(prop) DCNL DCSP  DCSP font.set_text(s, 0, flags=LOAD_NO_HINTING) DCNL DCSP  DCSP self.track_characters(font, s) DCNL DCSP  DCSP self.set_color(*gc.get_rgb()) DCNL DCSP  DCSP self.set_font(font.get_sfnt()[(1, 0, 0, 6)], prop.get_size_in_points()) DCNL DCSP  DCSP cmap = font.get_charmap() DCNL DCSP  DCSP lastgind = None DCNL DCSP  DCSP lines = [] DCNL DCSP  DCSP thisx = 0 DCNL DCSP  DCSP thisy = (font.get_descent() / 64.0) DCNL DCSP  DCSP for c in s: DCNL DCSP  DCSP  DCSP ccode = ord(c) DCNL DCSP  DCSP  DCSP gind = cmap.get(ccode) DCNL DCSP  DCSP  DCSP if (gind is None): DCNL DCSP  DCSP  DCSP  DCSP ccode = ord('?') DCNL DCSP  DCSP  DCSP  DCSP name = '.notdef' DCNL DCSP  DCSP  DCSP  DCSP gind = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP name = font.get_glyph_name(gind) DCNL DCSP  DCSP  DCSP glyph = font.load_char(ccode, flags=LOAD_NO_HINTING) DCNL DCSP  DCSP  DCSP if (lastgind is not None): DCNL DCSP  DCSP  DCSP  DCSP kern = font.get_kerning(lastgind, gind, KERNING_DEFAULT) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP kern = 0 DCNL DCSP  DCSP  DCSP lastgind = gind DCNL DCSP  DCSP  DCSP thisx += (kern / 64.0) DCNL DCSP  DCSP  DCSP lines.append(('%f DCSP %f DCSP m DCSP /%s DCSP glyphshow' % (thisx, thisy, name))) DCNL DCSP  DCSP  DCSP thisx += (glyph.linearHoriAdvance / 65536.0) DCNL DCSP  DCSP thetext = '\n'.join(lines) DCNL DCSP  DCSP ps = ('gsave\n%(x)f DCSP %(y)f DCSP translate\n%(angle)f DCSP rotate\n%(thetext)s\ngrestore\n' % locals()) DCNL DCSP  DCSP self._pswriter.write(ps)
def draw_mathtext(self, gc, x, y, s, prop, angle): DCNL DCSP if debugPS: DCNL DCSP  DCSP self._pswriter.write('% DCSP mathtext\n') DCNL DCSP (width, height, descent, pswriter, used_characters) = self.mathtext_parser.parse(s, 72, prop) DCNL DCSP self.merge_used_characters(used_characters) DCNL DCSP self.set_color(*gc.get_rgb()) DCNL DCSP thetext = pswriter.getvalue() DCNL DCSP ps = ('gsave\n%(x)f DCSP %(y)f DCSP translate\n%(angle)f DCSP rotate\n%(thetext)s\ngrestore\n' % locals()) DCNL DCSP self._pswriter.write(ps)
def _draw_ps(self, ps, gc, rgbFace, fill=True, stroke=True, command=None): DCNL DCSP write = self._pswriter.write DCNL DCSP if (debugPS and command): DCNL DCSP  DCSP write((('% DCSP ' + command) + '\n')) DCNL DCSP mightstroke = ((gc.get_linewidth() > 0.0) and ((len(gc.get_rgb()) <= 3) or (gc.get_rgb()[3] != 0.0))) DCNL DCSP stroke = (stroke and mightstroke) DCNL DCSP fill = (fill and (rgbFace is not None) and ((len(rgbFace) <= 3) or (rgbFace[3] != 0.0))) DCNL DCSP if mightstroke: DCNL DCSP  DCSP self.set_linewidth(gc.get_linewidth()) DCNL DCSP  DCSP jint = gc.get_joinstyle() DCNL DCSP  DCSP self.set_linejoin(jint) DCNL DCSP  DCSP cint = gc.get_capstyle() DCNL DCSP  DCSP self.set_linecap(cint) DCNL DCSP  DCSP self.set_linedash(*gc.get_dashes()) DCNL DCSP  DCSP self.set_color(*gc.get_rgb()[:3]) DCNL DCSP write('gsave\n') DCNL DCSP cliprect = gc.get_clip_rectangle() DCNL DCSP if cliprect: DCNL DCSP  DCSP (x, y, w, h) = cliprect.bounds DCNL DCSP  DCSP write(('%1.4g DCSP %1.4g DCSP %1.4g DCSP %1.4g DCSP clipbox\n' % (w, h, x, y))) DCNL DCSP (clippath, clippath_trans) = gc.get_clip_path() DCNL DCSP if clippath: DCNL DCSP  DCSP id = self._get_clip_path(clippath, clippath_trans) DCNL DCSP  DCSP write(('%s\n' % id)) DCNL DCSP write(ps.strip()) DCNL DCSP write('\n') DCNL DCSP if fill: DCNL DCSP  DCSP if stroke: DCNL DCSP  DCSP  DCSP write('gsave\n') DCNL DCSP  DCSP  DCSP self.set_color(store=0, *rgbFace[:3]) DCNL DCSP  DCSP  DCSP write('fill\ngrestore\n') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.set_color(store=0, *rgbFace[:3]) DCNL DCSP  DCSP  DCSP write('fill\n') DCNL DCSP hatch = gc.get_hatch() DCNL DCSP if hatch: DCNL DCSP  DCSP self.set_hatch(hatch) DCNL DCSP if stroke: DCNL DCSP  DCSP write('stroke\n') DCNL DCSP write('grestore\n')
def _print_figure(self, outfile, format, dpi=72, facecolor='w', edgecolor='w', orientation='portrait', isLandscape=False, papertype=None): DCNL DCSP isEPSF = (format == 'eps') DCNL DCSP passed_in_file_object = False DCNL DCSP if is_string_like(outfile): DCNL DCSP  DCSP title = outfile DCNL DCSP  DCSP tmpfile = os.path.join(gettempdir(), md5(outfile).hexdigest()) DCNL DCSP elif is_writable_file_like(outfile): DCNL DCSP  DCSP title = None DCNL DCSP  DCSP tmpfile = os.path.join(gettempdir(), md5(str(hash(outfile))).hexdigest()) DCNL DCSP  DCSP passed_in_file_object = True DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('outfile DCSP must DCSP be DCSP a DCSP path DCSP or DCSP a DCSP file-like DCSP object') DCNL DCSP fh = file(tmpfile, 'w') DCNL DCSP (width, height) = self.figure.get_size_inches() DCNL DCSP if (papertype == 'auto'): DCNL DCSP  DCSP if isLandscape: DCNL DCSP  DCSP  DCSP papertype = _get_papertype(height, width) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP papertype = _get_papertype(width, height) DCNL DCSP if isLandscape: DCNL DCSP  DCSP (paperHeight, paperWidth) = papersize[papertype] DCNL DCSP else: DCNL DCSP  DCSP (paperWidth, paperHeight) = papersize[papertype] DCNL DCSP if (rcParams['ps.usedistiller'] and (not (papertype == 'auto'))): DCNL DCSP  DCSP if ((width > paperWidth) or (height > paperHeight)): DCNL DCSP  DCSP  DCSP if isLandscape: DCNL DCSP  DCSP  DCSP  DCSP papertype = _get_papertype(height, width) DCNL DCSP  DCSP  DCSP  DCSP (paperHeight, paperWidth) = papersize[papertype] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP papertype = _get_papertype(width, height) DCNL DCSP  DCSP  DCSP  DCSP (paperWidth, paperHeight) = papersize[papertype] DCNL DCSP xo = ((72 * 0.5) * (paperWidth - width)) DCNL DCSP yo = ((72 * 0.5) * (paperHeight - height)) DCNL DCSP (l, b, w, h) = self.figure.bbox.bounds DCNL DCSP llx = xo DCNL DCSP lly = yo DCNL DCSP urx = (llx + w) DCNL DCSP ury = (lly + h) DCNL DCSP rotation = 0 DCNL DCSP if isLandscape: DCNL DCSP  DCSP (llx, lly, urx, ury) = (lly, llx, ury, urx) DCNL DCSP  DCSP (xo, yo) = (((72 * paperHeight) - yo), xo) DCNL DCSP  DCSP rotation = 90 DCNL DCSP bbox = (llx, lly, urx, ury) DCNL DCSP origfacecolor = self.figure.get_facecolor() DCNL DCSP origedgecolor = self.figure.get_edgecolor() DCNL DCSP self.figure.set_facecolor(facecolor) DCNL DCSP self.figure.set_edgecolor(edgecolor) DCNL DCSP self._pswriter = StringIO() DCNL DCSP renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi) DCNL DCSP self.figure.draw(renderer) DCNL DCSP self.figure.set_facecolor(origfacecolor) DCNL DCSP self.figure.set_edgecolor(origedgecolor) DCNL DCSP if isEPSF: DCNL DCSP  DCSP print >>fh, '%!PS-Adobe-3.0 DCSP EPSF-3.0' DCNL DCSP else: DCNL DCSP  DCSP print >>fh, '%!PS-Adobe-3.0' DCNL DCSP if title: DCNL DCSP  DCSP print >>fh, ('%%Title: DCSP ' + title) DCNL DCSP print >>fh, (('%%Creator: DCSP matplotlib DCSP version DCSP ' + __version__) + ', DCSP http://matplotlib.sourceforge.net/') DCNL DCSP print >>fh, ('%%CreationDate: DCSP ' + time.ctime(time.time())) DCNL DCSP print >>fh, ('%%Orientation: DCSP ' + orientation) DCNL DCSP if (not isEPSF): DCNL DCSP  DCSP print >>fh, ('%%DocumentPaperSizes: DCSP ' + papertype) DCNL DCSP print >>fh, ('%%%%BoundingBox: DCSP %d DCSP %d DCSP %d DCSP %d' % bbox) DCNL DCSP if (not isEPSF): DCNL DCSP  DCSP print >>fh, '%%Pages: DCSP 1' DCNL DCSP print >>fh, '%%EndComments' DCNL DCSP Ndict = len(psDefs) DCNL DCSP print >>fh, '%%BeginProlog' DCNL DCSP if (not rcParams['ps.useafm']): DCNL DCSP  DCSP Ndict += len(renderer.used_characters) DCNL DCSP print >>fh, ('/mpldict DCSP %d DCSP dict DCSP def' % Ndict) DCNL DCSP print >>fh, 'mpldict DCSP begin' DCNL DCSP for d in psDefs: DCNL DCSP  DCSP d = d.strip() DCNL DCSP  DCSP for l in d.split('\n'): DCNL DCSP  DCSP  DCSP print >>fh, l.strip() DCNL DCSP if (not rcParams['ps.useafm']): DCNL DCSP  DCSP for (font_filename, chars) in renderer.used_characters.values(): DCNL DCSP  DCSP  DCSP if len(chars): DCNL DCSP  DCSP  DCSP  DCSP font = FT2Font(font_filename) DCNL DCSP  DCSP  DCSP  DCSP cmap = font.get_charmap() DCNL DCSP  DCSP  DCSP  DCSP glyph_ids = [] DCNL DCSP  DCSP  DCSP  DCSP for c in chars: DCNL DCSP  DCSP  DCSP  DCSP  DCSP gind = (cmap.get(c) or 0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP glyph_ids.append(gind) DCNL DCSP  DCSP  DCSP  DCSP if is_opentype_cff_font(font_filename): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('OpenType DCSP CFF DCSP fonts DCSP can DCSP not DCSP be DCSP saved DCSP using DCSP the DCSP internal DCSP Postscript DCSP backend DCSP at DCSP this DCSP time.\nConsider DCSP using DCSP the DCSP Cairo DCSP backend.') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fonttype = rcParams['ps.fonttype'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP convert_ttf_to_ps(font_filename, fh, rcParams['ps.fonttype'], glyph_ids) DCNL DCSP print >>fh, 'end' DCNL DCSP print >>fh, '%%EndProlog' DCNL DCSP if (not isEPSF): DCNL DCSP  DCSP print >>fh, '%%Page: DCSP 1 DCSP 1' DCNL DCSP print >>fh, 'mpldict DCSP begin' DCNL DCSP print >>fh, ('%s DCSP translate' % _nums_to_str(xo, yo)) DCNL DCSP if rotation: DCNL DCSP  DCSP print >>fh, ('%d DCSP rotate' % rotation) DCNL DCSP print >>fh, ('%s DCSP clipbox' % _nums_to_str((width * 72), (height * 72), 0, 0)) DCNL DCSP print >>fh, self._pswriter.getvalue() DCNL DCSP print >>fh, 'end' DCNL DCSP print >>fh, 'showpage' DCNL DCSP if (not isEPSF): DCNL DCSP  DCSP print >>fh, '%%EOF' DCNL DCSP fh.close() DCNL DCSP if (rcParams['ps.usedistiller'] == 'ghostscript'): DCNL DCSP  DCSP gs_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox) DCNL DCSP elif (rcParams['ps.usedistiller'] == 'xpdf'): DCNL DCSP  DCSP xpdf_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox) DCNL DCSP if passed_in_file_object: DCNL DCSP  DCSP fh = file(tmpfile) DCNL DCSP  DCSP print >>outfile, fh.read() DCNL DCSP else: DCNL DCSP  DCSP shutil.move(tmpfile, outfile)
def _print_figure_tex(self, outfile, format, dpi, facecolor, edgecolor, orientation, isLandscape, papertype): DCNL DCSP isEPSF = (format == 'eps') DCNL DCSP title = outfile DCNL DCSP tmpfile = os.path.join(gettempdir(), md5(outfile).hexdigest()) DCNL DCSP fh = file(tmpfile, 'w') DCNL DCSP self.figure.dpi = 72 DCNL DCSP (width, height) = self.figure.get_size_inches() DCNL DCSP xo = 0 DCNL DCSP yo = 0 DCNL DCSP (l, b, w, h) = self.figure.bbox.bounds DCNL DCSP llx = xo DCNL DCSP lly = yo DCNL DCSP urx = (llx + w) DCNL DCSP ury = (lly + h) DCNL DCSP bbox = (llx, lly, urx, ury) DCNL DCSP origfacecolor = self.figure.get_facecolor() DCNL DCSP origedgecolor = self.figure.get_edgecolor() DCNL DCSP self.figure.set_facecolor(facecolor) DCNL DCSP self.figure.set_edgecolor(edgecolor) DCNL DCSP self._pswriter = StringIO() DCNL DCSP renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi) DCNL DCSP self.figure.draw(renderer) DCNL DCSP self.figure.set_facecolor(origfacecolor) DCNL DCSP self.figure.set_edgecolor(origedgecolor) DCNL DCSP print >>fh, '%!PS-Adobe-3.0 DCSP EPSF-3.0' DCNL DCSP if title: DCNL DCSP  DCSP print >>fh, ('%%Title: DCSP ' + title) DCNL DCSP print >>fh, (('%%Creator: DCSP matplotlib DCSP version DCSP ' + __version__) + ', DCSP http://matplotlib.sourceforge.net/') DCNL DCSP print >>fh, ('%%CreationDate: DCSP ' + time.ctime(time.time())) DCNL DCSP print >>fh, ('%%%%BoundingBox: DCSP %d DCSP %d DCSP %d DCSP %d' % bbox) DCNL DCSP print >>fh, '%%EndComments' DCNL DCSP Ndict = len(psDefs) DCNL DCSP print >>fh, '%%BeginProlog' DCNL DCSP print >>fh, ('/mpldict DCSP %d DCSP dict DCSP def' % Ndict) DCNL DCSP print >>fh, 'mpldict DCSP begin' DCNL DCSP for d in psDefs: DCNL DCSP  DCSP d = d.strip() DCNL DCSP  DCSP for l in d.split('\n'): DCNL DCSP  DCSP  DCSP print >>fh, l.strip() DCNL DCSP print >>fh, 'end' DCNL DCSP print >>fh, '%%EndProlog' DCNL DCSP print >>fh, 'mpldict DCSP begin' DCNL DCSP print >>fh, ('%s DCSP translate' % _nums_to_str(xo, yo)) DCNL DCSP print >>fh, ('%s DCSP clipbox' % _nums_to_str((width * 72), (height * 72), 0, 0)) DCNL DCSP print >>fh, self._pswriter.getvalue() DCNL DCSP print >>fh, 'end' DCNL DCSP print >>fh, 'showpage' DCNL DCSP fh.close() DCNL DCSP if isLandscape: DCNL DCSP  DCSP isLandscape = True DCNL DCSP  DCSP (width, height) = (height, width) DCNL DCSP  DCSP bbox = (lly, llx, ury, urx) DCNL DCSP temp_papertype = _get_papertype(width, height) DCNL DCSP if (papertype == 'auto'): DCNL DCSP  DCSP papertype = temp_papertype DCNL DCSP  DCSP (paperWidth, paperHeight) = papersize[temp_papertype] DCNL DCSP else: DCNL DCSP  DCSP (paperWidth, paperHeight) = papersize[papertype] DCNL DCSP  DCSP if (((width > paperWidth) or (height > paperHeight)) and isEPSF): DCNL DCSP  DCSP  DCSP (paperWidth, paperHeight) = papersize[temp_papertype] DCNL DCSP  DCSP  DCSP verbose.report(('Your DCSP figure DCSP is DCSP too DCSP big DCSP to DCSP fit DCSP on DCSP %s DCSP paper. DCSP %s DCSP paper DCSP will DCSP be DCSP used DCSP to DCSP prevent DCSP clipping.' % (papertype, temp_papertype)), 'helpful') DCNL DCSP texmanager = renderer.get_texmanager() DCNL DCSP font_preamble = texmanager.get_font_preamble() DCNL DCSP custom_preamble = texmanager.get_custom_preamble() DCNL DCSP convert_psfrags(tmpfile, renderer.psfrag, font_preamble, custom_preamble, paperWidth, paperHeight, orientation) DCNL DCSP if (rcParams['ps.usedistiller'] == 'ghostscript'): DCNL DCSP  DCSP gs_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox) DCNL DCSP elif (rcParams['ps.usedistiller'] == 'xpdf'): DCNL DCSP  DCSP xpdf_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox) DCNL DCSP elif rcParams['text.usetex']: DCNL DCSP  DCSP if False: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP gs_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox) DCNL DCSP if isinstance(outfile, file): DCNL DCSP  DCSP fh = file(tmpfile) DCNL DCSP  DCSP print >>outfile, fh.read() DCNL DCSP else: DCNL DCSP  DCSP shutil.move(tmpfile, outfile)
def _renderer_init(self): DCNL DCSP self._renderer = RendererGDK(self, self.figure.dpi)
def _pixmap_prepare(self, width, height): DCNL DCSP if _debug: DCNL DCSP  DCSP print ('FigureCanvasGTK.%s' % fn_name()) DCNL DCSP create_pixmap = False DCNL DCSP if (width > self._pixmap_width): DCNL DCSP  DCSP self._pixmap_width = max(int((self._pixmap_width * 1.1)), width) DCNL DCSP  DCSP create_pixmap = True DCNL DCSP if (height > self._pixmap_height): DCNL DCSP  DCSP self._pixmap_height = max(int((self._pixmap_height * 1.1)), height) DCNL DCSP  DCSP create_pixmap = True DCNL DCSP if create_pixmap: DCNL DCSP  DCSP self._pixmap = gdk.Pixmap(self.window, self._pixmap_width, self._pixmap_height) DCNL DCSP  DCSP self._renderer.set_pixmap(self._pixmap)
def _render_figure(self, pixmap, width, height): DCNL DCSP self._renderer.set_width_height(width, height) DCNL DCSP self.figure.draw(self._renderer)
def expose_event(self, widget, event): DCNL DCSP if _debug: DCNL DCSP  DCSP print ('FigureCanvasGTK.%s' % fn_name()) DCNL DCSP if GTK_WIDGET_DRAWABLE(self): DCNL DCSP  DCSP if self._need_redraw: DCNL DCSP  DCSP  DCSP (x, y, w, h) = self.allocation DCNL DCSP  DCSP  DCSP self._pixmap_prepare(w, h) DCNL DCSP  DCSP  DCSP self._render_figure(self._pixmap, w, h) DCNL DCSP  DCSP  DCSP self._need_redraw = False DCNL DCSP  DCSP (x, y, w, h) = event.area DCNL DCSP  DCSP self.window.draw_drawable(self.style.fg_gc[self.state], self._pixmap, x, y, x, y, w, h) DCNL DCSP return False
def resize(self, width, height): DCNL DCSP self.window.resize(width, height)
def draw_rubberband(self, event, x0, y0, x1, y1): DCNL DCSP drawable = self.canvas.window DCNL DCSP if (drawable is None): DCNL DCSP  DCSP return DCNL DCSP gc = drawable.new_gc() DCNL DCSP height = self.canvas.figure.bbox.height DCNL DCSP y1 = (height - y1) DCNL DCSP y0 = (height - y0) DCNL DCSP w = abs((x1 - x0)) DCNL DCSP h = abs((y1 - y0)) DCNL DCSP rect = [int(val) for val in (min(x0, x1), min(y0, y1), w, h)] DCNL DCSP try: DCNL DCSP  DCSP (lastrect, imageBack) = self._imageBack DCNL DCSP except AttributeError: DCNL DCSP  DCSP if (event.inaxes is None): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP ax = event.inaxes DCNL DCSP  DCSP (l, b, w, h) = [int(val) for val in ax.bbox.bounds] DCNL DCSP  DCSP b = (int(height) - (b + h)) DCNL DCSP  DCSP axrect = (l, b, w, h) DCNL DCSP  DCSP self._imageBack = (axrect, drawable.get_image(*axrect)) DCNL DCSP  DCSP drawable.draw_rectangle(gc, False, *rect) DCNL DCSP  DCSP self._idle_draw_id = 0 DCNL DCSP else: DCNL DCSP  DCSP def idle_draw(*args): DCNL DCSP  DCSP  DCSP drawable.draw_image(gc, imageBack, 0, 0, *lastrect) DCNL DCSP  DCSP  DCSP drawable.draw_rectangle(gc, False, *rect) DCNL DCSP  DCSP  DCSP self._idle_draw_id = 0 DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (self._idle_draw_id == 0): DCNL DCSP  DCSP  DCSP self._idle_draw_id = gobject.idle_add(idle_draw)
def __init__(self, canvas, window): DCNL DCSP gtk.Toolbar.__init__(self) DCNL DCSP self.canvas = canvas DCNL DCSP self.win = window DCNL DCSP self.set_style(gtk.TOOLBAR_ICONS) DCNL DCSP if (gtk.pygtk_version >= (2, 4, 0)): DCNL DCSP  DCSP self._create_toolitems_2_4() DCNL DCSP  DCSP self.update = self._update_2_4 DCNL DCSP  DCSP self.fileselect = FileChooserDialog(title='Save DCSP the DCSP figure', parent=self.win, filetypes=self.canvas.get_supported_filetypes(), default_filetype=self.canvas.get_default_filetype()) DCNL DCSP else: DCNL DCSP  DCSP self._create_toolitems_2_2() DCNL DCSP  DCSP self.update = self._update_2_2 DCNL DCSP  DCSP self.fileselect = FileSelection(title='Save DCSP the DCSP figure', parent=self.win) DCNL DCSP self.show_all() DCNL DCSP self.update()
def panx(self, button, direction): DCNL DCSP for a in self._active: DCNL DCSP  DCSP a.xaxis.pan(direction) DCNL DCSP self.canvas.draw() DCNL DCSP return True
def pany(self, button, direction): DCNL DCSP for a in self._active: DCNL DCSP  DCSP a.yaxis.pan(direction) DCNL DCSP self.canvas.draw() DCNL DCSP return True
def zoomx(self, button, direction): DCNL DCSP for a in self._active: DCNL DCSP  DCSP a.xaxis.zoom(direction) DCNL DCSP self.canvas.draw() DCNL DCSP return True
def zoomy(self, button, direction): DCNL DCSP for a in self._active: DCNL DCSP  DCSP a.yaxis.zoom(direction) DCNL DCSP self.canvas.draw() DCNL DCSP return True
def show(self): DCNL DCSP self._updateson = False DCNL DCSP cbox = self.cbox_lineprops DCNL DCSP for i in range((self._lastcnt - 1), (-1), (-1)): DCNL DCSP  DCSP cbox.remove_text(i) DCNL DCSP for line in self.lines: DCNL DCSP  DCSP cbox.append_text(line.get_label()) DCNL DCSP cbox.set_active(0) DCNL DCSP self._updateson = True DCNL DCSP self._lastcnt = len(self.lines) DCNL DCSP self.dlg.show()
def get_active_line(self): DCNL DCSP ind = self.cbox_lineprops.get_active() DCNL DCSP line = self.lines[ind] DCNL DCSP return line
def get_active_linestyle(self): DCNL DCSP ind = self.cbox_linestyles.get_active() DCNL DCSP ls = self.linestyles[ind] DCNL DCSP return ls
def get_active_marker(self): DCNL DCSP ind = self.cbox_markers.get_active() DCNL DCSP m = self.markers[ind] DCNL DCSP return m
def _update(self): DCNL DCSP if ((not self._inited) or (not self._updateson)): DCNL DCSP  DCSP return DCNL DCSP line = self.get_active_line() DCNL DCSP ls = self.get_active_linestyle() DCNL DCSP marker = self.get_active_marker() DCNL DCSP line.set_linestyle(ls) DCNL DCSP line.set_marker(marker) DCNL DCSP button = self.wtree.get_widget('colorbutton_linestyle') DCNL DCSP color = button.get_color() DCNL DCSP (r, g, b) = [(val / 65535.0) for val in (color.red, color.green, color.blue)] DCNL DCSP line.set_color((r, g, b)) DCNL DCSP button = self.wtree.get_widget('colorbutton_markerface') DCNL DCSP color = button.get_color() DCNL DCSP (r, g, b) = [(val / 65535.0) for val in (color.red, color.green, color.blue)] DCNL DCSP line.set_markerfacecolor((r, g, b)) DCNL DCSP line.figure.canvas.draw()
def on_combobox_lineprops_changed(self, item): DCNL DCSP if (not self._inited): DCNL DCSP  DCSP return DCNL DCSP self._updateson = False DCNL DCSP line = self.get_active_line() DCNL DCSP ls = line.get_linestyle() DCNL DCSP if (ls is None): DCNL DCSP  DCSP ls = 'None' DCNL DCSP self.cbox_linestyles.set_active(self.linestyled[ls]) DCNL DCSP marker = line.get_marker() DCNL DCSP if (marker is None): DCNL DCSP  DCSP marker = 'None' DCNL DCSP self.cbox_markers.set_active(self.markerd[marker]) DCNL DCSP (r, g, b) = colorConverter.to_rgb(line.get_color()) DCNL DCSP color = gtk.gdk.Color(*[int((val * 65535)) for val in (r, g, b)]) DCNL DCSP button = self.wtree.get_widget('colorbutton_linestyle') DCNL DCSP button.set_color(color) DCNL DCSP (r, g, b) = colorConverter.to_rgb(line.get_markerfacecolor()) DCNL DCSP color = gtk.gdk.Color(*[int((val * 65535)) for val in (r, g, b)]) DCNL DCSP button = self.wtree.get_widget('colorbutton_markerface') DCNL DCSP button.set_color(color) DCNL DCSP self._updateson = True
def on_colorbutton_markerface_color_set(self, button): DCNL DCSP self._update()
def __init__(self, width, height, dpi, vector_renderer, raster_renderer_class=None): DCNL DCSP if (raster_renderer_class is None): DCNL DCSP  DCSP raster_renderer_class = RendererAgg DCNL DCSP self._raster_renderer_class = raster_renderer_class DCNL DCSP self._width = width DCNL DCSP self._height = height DCNL DCSP self.dpi = dpi DCNL DCSP assert (not vector_renderer.option_image_nocomposite()) DCNL DCSP self._vector_renderer = vector_renderer DCNL DCSP self._raster_renderer = None DCNL DCSP self._rasterizing = 0 DCNL DCSP self._set_current_renderer(vector_renderer)
def start_rasterizing(self): DCNL DCSP if (self._rasterizing == 0): DCNL DCSP  DCSP self._raster_renderer = self._raster_renderer_class((self._width * self.dpi), (self._height * self.dpi), self.dpi) DCNL DCSP  DCSP self._set_current_renderer(self._raster_renderer) DCNL DCSP self._rasterizing += 1
def stop_rasterizing(self): DCNL DCSP self._rasterizing -= 1 DCNL DCSP if (self._rasterizing == 0): DCNL DCSP  DCSP self._set_current_renderer(self._vector_renderer) DCNL DCSP  DCSP (width, height) = ((self._width * self.dpi), (self._height * self.dpi)) DCNL DCSP  DCSP (buffer, bounds) = self._raster_renderer.tostring_rgba_minimized() DCNL DCSP  DCSP (l, b, w, h) = bounds DCNL DCSP  DCSP if ((w > 0) and (h > 0)): DCNL DCSP  DCSP  DCSP image = frombuffer(buffer, w, h, True) DCNL DCSP  DCSP  DCSP image.is_grayscale = False DCNL DCSP  DCSP  DCSP image.flipud_out() DCNL DCSP  DCSP  DCSP self._renderer.draw_image(l, ((height - b) - h), image, None) DCNL DCSP  DCSP self._raster_renderer = None DCNL DCSP  DCSP self._rasterizing = False
def draw(self): DCNL DCSP renderer = RendererTemplate(self.figure.dpi) DCNL DCSP self.figure.draw(renderer)
def print_foo(self, filename, *args, **kwargs): DCNL DCSP pass
def _get_style(self, gc, rgbFace): DCNL DCSP if (rgbFace is None): DCNL DCSP  DCSP fill = 'none' DCNL DCSP else: DCNL DCSP  DCSP fill = rgb2hex(rgbFace[:3]) DCNL DCSP (offset, seq) = gc.get_dashes() DCNL DCSP if (seq is None): DCNL DCSP  DCSP dashes = '' DCNL DCSP else: DCNL DCSP  DCSP dashes = ('stroke-dasharray: DCSP %s; DCSP stroke-dashoffset: DCSP %f;' % (','.join([('%f' % val) for val in seq]), offset)) DCNL DCSP linewidth = gc.get_linewidth() DCNL DCSP if linewidth: DCNL DCSP  DCSP return ('fill: DCSP %s; DCSP stroke: DCSP %s; DCSP stroke-width: DCSP %f; DCSP stroke-linejoin: DCSP %s; DCSP stroke-linecap: DCSP %s; DCSP %s DCSP opacity: DCSP %f' % (fill, rgb2hex(gc.get_rgb()[:3]), linewidth, gc.get_joinstyle(), _capstyle_d[gc.get_capstyle()], dashes, gc.get_alpha())) DCNL DCSP else: DCNL DCSP  DCSP return ('fill: DCSP %s; DCSP opacity: DCSP %f' % (fill, gc.get_alpha()))
def option_image_nocomposite(self): DCNL DCSP return rcParams['svg.image_noscale']
def _draw_mathtext(self, gc, x, y, s, prop, angle): DCNL DCSP (width, height, descent, svg_elements, used_characters) = self.mathtext_parser.parse(s, 72, prop) DCNL DCSP svg_glyphs = svg_elements.svg_glyphs DCNL DCSP svg_rects = svg_elements.svg_rects DCNL DCSP color = rgb2hex(gc.get_rgb()[:3]) DCNL DCSP write = self._svgwriter.write DCNL DCSP style = ('fill: DCSP %s' % color) DCNL DCSP if rcParams['svg.embed_char_paths']: DCNL DCSP  DCSP new_chars = [] DCNL DCSP  DCSP for (font, fontsize, thetext, new_x, new_y_mtc, metrics) in svg_glyphs: DCNL DCSP  DCSP  DCSP path = self._add_char_def(font, thetext) DCNL DCSP  DCSP  DCSP if (path is not None): DCNL DCSP  DCSP  DCSP  DCSP new_chars.append(path) DCNL DCSP  DCSP if len(new_chars): DCNL DCSP  DCSP  DCSP write('<defs>\n') DCNL DCSP  DCSP  DCSP for path in new_chars: DCNL DCSP  DCSP  DCSP  DCSP write(path) DCNL DCSP  DCSP  DCSP write('</defs>\n') DCNL DCSP  DCSP svg = [('<g DCSP style="%s" DCSP transform="' % style)] DCNL DCSP  DCSP if (angle != 0): DCNL DCSP  DCSP  DCSP svg.append(('translate(%f,%f)rotate(%1.1f)' % (x, y, (- angle)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP svg.append(('translate(%f,%f)' % (x, y))) DCNL DCSP  DCSP svg.append('">\n') DCNL DCSP  DCSP for (font, fontsize, thetext, new_x, new_y_mtc, metrics) in svg_glyphs: DCNL DCSP  DCSP  DCSP charid = self._get_char_def_id(font, thetext) DCNL DCSP  DCSP  DCSP svg.append(('<use DCSP xlink:href="#%s" DCSP transform="translate(%f,%f)scale(%f)"/>\n' % (charid, new_x, (- new_y_mtc), (fontsize / self.FONT_SCALE)))) DCNL DCSP  DCSP svg.append('</g>\n') DCNL DCSP else: DCNL DCSP  DCSP svg = [('<text DCSP style="%s" DCSP x="%f" DCSP y="%f"' % (style, x, y))] DCNL DCSP  DCSP if (angle != 0): DCNL DCSP  DCSP  DCSP svg.append((' DCSP transform="translate(%f,%f) DCSP rotate(%1.1f) DCSP translate(%f,%f)"' % (x, y, (- angle), (- x), (- y)))) DCNL DCSP  DCSP svg.append('>\n') DCNL DCSP  DCSP (curr_x, curr_y) = (0.0, 0.0) DCNL DCSP  DCSP for (font, fontsize, thetext, new_x, new_y_mtc, metrics) in svg_glyphs: DCNL DCSP  DCSP  DCSP new_y = (- new_y_mtc) DCNL DCSP  DCSP  DCSP style = ('font-size: DCSP %f; DCSP font-family: DCSP %s' % (fontsize, font.family_name)) DCNL DCSP  DCSP  DCSP svg.append(('<tspan DCSP style="%s"' % style)) DCNL DCSP  DCSP  DCSP xadvance = metrics.advance DCNL DCSP  DCSP  DCSP svg.append((' DCSP textLength="%f"' % xadvance)) DCNL DCSP  DCSP  DCSP dx = (new_x - curr_x) DCNL DCSP  DCSP  DCSP if (dx != 0.0): DCNL DCSP  DCSP  DCSP  DCSP svg.append((' DCSP dx="%f"' % dx)) DCNL DCSP  DCSP  DCSP dy = (new_y - curr_y) DCNL DCSP  DCSP  DCSP if (dy != 0.0): DCNL DCSP  DCSP  DCSP  DCSP svg.append((' DCSP dy="%f"' % dy)) DCNL DCSP  DCSP  DCSP thetext = escape_xml_text(thetext) DCNL DCSP  DCSP  DCSP svg.append(('>%s</tspan>\n' % thetext)) DCNL DCSP  DCSP  DCSP curr_x = (new_x + xadvance) DCNL DCSP  DCSP  DCSP curr_y = new_y DCNL DCSP  DCSP svg.append('</text>\n') DCNL DCSP if len(svg_rects): DCNL DCSP  DCSP style = ('fill: DCSP %s; DCSP stroke: DCSP none' % color) DCNL DCSP  DCSP svg.append(('<g DCSP style="%s" DCSP transform="' % style)) DCNL DCSP  DCSP if (angle != 0): DCNL DCSP  DCSP  DCSP svg.append(('translate(%f,%f) DCSP rotate(%1.1f)' % (x, y, (- angle)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP svg.append(('translate(%f,%f)' % (x, y))) DCNL DCSP  DCSP svg.append('">\n') DCNL DCSP  DCSP for (x, y, width, height) in svg_rects: DCNL DCSP  DCSP  DCSP svg.append(('<rect DCSP x="%f" DCSP y="%f" DCSP width="%f" DCSP height="%f" DCSP fill="black" DCSP stroke="none" DCSP />' % (x, ((- y) + height), width, height))) DCNL DCSP  DCSP svg.append('</g>') DCNL DCSP self.open_group('mathtext') DCNL DCSP write(''.join(svg)) DCNL DCSP self.close_group('mathtext')
def __init__(self, outfile, width, height, dpi): DCNL DCSP self.outfile = outfile DCNL DCSP self._cached = {} DCNL DCSP self._fontHandle = {} DCNL DCSP self.lastHandle = {'font': (-1), 'pen': (-1), 'brush': (-1)} DCNL DCSP self.emf = pyemf.EMF(width, height, dpi, 'in') DCNL DCSP self.width = int((width * dpi)) DCNL DCSP self.height = int((height * dpi)) DCNL DCSP self.dpi = dpi DCNL DCSP self.pointstodpi = (dpi / 72.0) DCNL DCSP self.hackPointsForMathExponent = 2.0 DCNL DCSP self.emf.SetBkMode(pyemf.TRANSPARENT) DCNL DCSP self.emf.SetTextAlign((pyemf.TA_BOTTOM | pyemf.TA_LEFT)) DCNL DCSP if debugPrint: DCNL DCSP  DCSP print ('RendererEMF: DCSP (%f,%f) DCSP %s DCSP dpi=%f' % (self.width, self.height, outfile, dpi))
def draw_arc(self, gcEdge, rgbFace, x, y, width, height, angle1, angle2, rotation): DCNL DCSP if debugPrint: DCNL DCSP  DCSP print ('draw_arc: DCSP (%f,%f) DCSP angles=(%f,%f) DCSP w,h=(%f,%f)' % (x, y, angle1, angle2, width, height)) DCNL DCSP pen = self.select_pen(gcEdge) DCNL DCSP brush = self.select_brush(rgbFace) DCNL DCSP hw = (width / 2) DCNL DCSP hh = (height / 2) DCNL DCSP x1 = int((x - (width / 2))) DCNL DCSP y1 = int((y - (height / 2))) DCNL DCSP if brush: DCNL DCSP  DCSP self.emf.Pie(int((x - hw)), int((self.height - (y - hh))), int((x + hw)), int((self.height - (y + hh))), int((x + (math.cos(((angle1 * math.pi) / 180.0)) * hw))), int((self.height - (y + (math.sin(((angle1 * math.pi) / 180.0)) * hh)))), int((x + (math.cos(((angle2 * math.pi) / 180.0)) * hw))), int((self.height - (y + (math.sin(((angle2 * math.pi) / 180.0)) * hh))))) DCNL DCSP else: DCNL DCSP  DCSP self.emf.Arc(int((x - hw)), int((self.height - (y - hh))), int((x + hw)), int((self.height - (y + hh))), int((x + (math.cos(((angle1 * math.pi) / 180.0)) * hw))), int((self.height - (y + (math.sin(((angle1 * math.pi) / 180.0)) * hh)))), int((x + (math.cos(((angle2 * math.pi) / 180.0)) * hw))), int((self.height - (y + (math.sin(((angle2 * math.pi) / 180.0)) * hh)))))
def draw_image(self, x, y, im, bbox): DCNL DCSP pass
def draw_line(self, gc, x1, y1, x2, y2): DCNL DCSP if debugPrint: DCNL DCSP  DCSP print ('draw_line: DCSP (%f,%f) DCSP - DCSP (%f,%f)' % (x1, y1, x2, y2)) DCNL DCSP if self.select_pen(gc): DCNL DCSP  DCSP self.emf.Polyline([(long(x1), long((self.height - y1))), (long(x2), long((self.height - y2)))]) DCNL DCSP elif debugPrint: DCNL DCSP  DCSP print ('draw_line: DCSP optimizing DCSP away DCSP (%f,%f) DCSP - DCSP (%f,%f)' % (x1, y1, x2, y2))
def draw_lines(self, gc, x, y): DCNL DCSP if debugPrint: DCNL DCSP  DCSP print ('draw_lines: DCSP %d DCSP points' % len(str(x))) DCNL DCSP if self.select_pen(gc): DCNL DCSP  DCSP points = [(long(x[i]), long((self.height - y[i]))) for i in range(len(x))] DCNL DCSP  DCSP self.emf.Polyline(points)
def draw_point(self, gc, x, y): DCNL DCSP if debugPrint: DCNL DCSP  DCSP print ('draw_point: DCSP (%f,%f)' % (x, y)) DCNL DCSP pen = EMFPen(self.emf, gc) DCNL DCSP self.emf.SetPixel(long(x), long((self.height - y)), (pen.r, pen.g, pen.b))
def draw_polygon(self, gcEdge, rgbFace, points): DCNL DCSP if debugPrint: DCNL DCSP  DCSP print ('draw_polygon: DCSP %d DCSP points' % len(points)) DCNL DCSP pen = self.select_pen(gcEdge) DCNL DCSP brush = self.select_brush(rgbFace) DCNL DCSP if (pen or brush): DCNL DCSP  DCSP points = [(long(x), long((self.height - y))) for (x, y) in points] DCNL DCSP  DCSP self.emf.Polygon(points) DCNL DCSP else: DCNL DCSP  DCSP points = [(long(x), long((self.height - y))) for (x, y) in points] DCNL DCSP  DCSP if debugPrint: DCNL DCSP  DCSP  DCSP print ('draw_polygon: DCSP optimizing DCSP away DCSP polygon: DCSP %d DCSP points DCSP = DCSP %s' % (len(points), str(points)))
def draw_rectangle(self, gcEdge, rgbFace, x, y, width, height): DCNL DCSP if debugPrint: DCNL DCSP  DCSP print ('draw_rectangle: DCSP (%f,%f) DCSP w=%f,h=%f' % (x, y, width, height)) DCNL DCSP pen = self.select_pen(gcEdge) DCNL DCSP brush = self.select_brush(rgbFace) DCNL DCSP if (pen or brush): DCNL DCSP  DCSP self.emf.Rectangle(int(x), int((self.height - y)), (int(x) + int(width)), (int((self.height - y)) - int(height))) DCNL DCSP elif debugPrint: DCNL DCSP  DCSP print ('draw_rectangle: DCSP optimizing DCSP away DCSP (%f,%f) DCSP w=%f,h=%f' % (x, y, width, height))
def draw_text(self, gc, x, y, s, prop, angle, ismath=False): DCNL DCSP if debugText: DCNL DCSP  DCSP print ("draw_text: DCSP (%f,%f) DCSP %d DCSP degrees: DCSP '%s'" % (x, y, angle, s)) DCNL DCSP if ismath: DCNL DCSP  DCSP self.draw_math_text(gc, x, y, s, prop, angle) DCNL DCSP else: DCNL DCSP  DCSP self.draw_plain_text(gc, x, y, s, prop, angle)
def draw_plain_text(self, gc, x, y, s, prop, angle): DCNL DCSP if debugText: DCNL DCSP  DCSP print ("draw_plain_text: DCSP (%f,%f) DCSP %d DCSP degrees: DCSP '%s'" % (x, y, angle, s)) DCNL DCSP if debugText: DCNL DCSP  DCSP print (' DCSP properties:\n' + str(prop)) DCNL DCSP self.select_font(prop, angle) DCNL DCSP hackoffsetper300dpi = 10 DCNL DCSP xhack = (((math.sin(((angle * math.pi) / 180.0)) * hackoffsetper300dpi) * self.dpi) / 300.0) DCNL DCSP yhack = (((math.cos(((angle * math.pi) / 180.0)) * hackoffsetper300dpi) * self.dpi) / 300.0) DCNL DCSP self.emf.TextOut(long((x + xhack)), long((y + yhack)), s)
def draw_math_text(self, gc, x, y, s, prop, angle): DCNL DCSP if debugText: DCNL DCSP  DCSP print ("draw_math_text: DCSP (%f,%f) DCSP %d DCSP degrees: DCSP '%s'" % (x, y, angle, s)) DCNL DCSP s = s[1:(-1)] DCNL DCSP match = re.match('10\\^\\{(.+)\\}', s) DCNL DCSP if match: DCNL DCSP  DCSP exp = match.group(1) DCNL DCSP  DCSP if debugText: DCNL DCSP  DCSP  DCSP print (' DCSP exponent=%s' % exp) DCNL DCSP  DCSP font = self._get_font_ttf(prop) DCNL DCSP  DCSP font.set_text('10', 0.0) DCNL DCSP  DCSP (w, h) = font.get_width_height() DCNL DCSP  DCSP w /= 64.0 DCNL DCSP  DCSP h /= 64.0 DCNL DCSP  DCSP self.draw_plain_text(gc, x, y, '10', prop, angle) DCNL DCSP  DCSP propexp = prop.copy() DCNL DCSP  DCSP propexp.set_size((prop.get_size_in_points() * 0.8)) DCNL DCSP  DCSP self.draw_plain_text(gc, ((x + w) + self.points_to_pixels(self.hackPointsForMathExponent)), (y - (h / 2)), exp, propexp, angle) DCNL DCSP else: DCNL DCSP  DCSP self.draw_plain_text(gc, x, y, s, prop, angle)
def get_math_text_width_height(self, s, prop): DCNL DCSP if debugText: DCNL DCSP  DCSP print 'get_math_text_width_height:' DCNL DCSP s = s[1:(-1)] DCNL DCSP match = re.match('10\\^\\{(.+)\\}', s) DCNL DCSP if match: DCNL DCSP  DCSP exp = match.group(1) DCNL DCSP  DCSP if debugText: DCNL DCSP  DCSP  DCSP print (' DCSP exponent=%s' % exp) DCNL DCSP  DCSP font = self._get_font_ttf(prop) DCNL DCSP  DCSP font.set_text('10', 0.0) DCNL DCSP  DCSP (w1, h1) = font.get_width_height() DCNL DCSP  DCSP propexp = prop.copy() DCNL DCSP  DCSP propexp.set_size((prop.get_size_in_points() * 0.8)) DCNL DCSP  DCSP fontexp = self._get_font_ttf(propexp) DCNL DCSP  DCSP fontexp.set_text(exp, 0.0) DCNL DCSP  DCSP (w2, h2) = fontexp.get_width_height() DCNL DCSP  DCSP w = (w1 + w2) DCNL DCSP  DCSP h = (h1 + (h2 / 2)) DCNL DCSP  DCSP w /= 64.0 DCNL DCSP  DCSP h /= 64.0 DCNL DCSP  DCSP w += self.points_to_pixels(self.hackPointsForMathExponent) DCNL DCSP  DCSP if debugText: DCNL DCSP  DCSP  DCSP print (' DCSP math DCSP string=%s DCSP w,h=(%f,%f)' % (s, w, h)) DCNL DCSP else: DCNL DCSP  DCSP (w, h) = self.get_text_width_height(s, prop, False) DCNL DCSP return (w, h)
def flipy(self): DCNL DCSP return True
def get_canvas_width_height(self): DCNL DCSP return (self.width, self.height)
def set_handle(self, type, handle): DCNL DCSP if (self.lastHandle[type] != handle): DCNL DCSP  DCSP self.emf.SelectObject(handle) DCNL DCSP  DCSP self.lastHandle[type] = handle
def get_font_handle(self, prop, angle): DCNL DCSP prop = EMFFontProperties(prop, angle) DCNL DCSP size = int((prop.get_size_in_points() * self.pointstodpi)) DCNL DCSP face = prop.get_name() DCNL DCSP key = hash(prop) DCNL DCSP handle = self._fontHandle.get(key) DCNL DCSP if (handle is None): DCNL DCSP  DCSP handle = self.emf.CreateFont((- size), 0, (int(angle) * 10), (int(angle) * 10), pyemf.FW_NORMAL, 0, 0, 0, pyemf.ANSI_CHARSET, pyemf.OUT_DEFAULT_PRECIS, pyemf.CLIP_DEFAULT_PRECIS, pyemf.DEFAULT_QUALITY, (pyemf.DEFAULT_PITCH | pyemf.FF_DONTCARE), face) DCNL DCSP  DCSP if debugHandle: DCNL DCSP  DCSP  DCSP print ('get_font_handle: DCSP creating DCSP handle=%d DCSP for DCSP face=%s DCSP size=%d' % (handle, face, size)) DCNL DCSP  DCSP self._fontHandle[key] = handle DCNL DCSP if debugHandle: DCNL DCSP  DCSP print (' DCSP found DCSP font DCSP handle DCSP %d DCSP for DCSP face=%s DCSP size=%d' % (handle, face, size)) DCNL DCSP self.set_handle('font', handle) DCNL DCSP return handle
def select_pen(self, gc): DCNL DCSP pen = EMFPen(self.emf, gc) DCNL DCSP key = hash(pen) DCNL DCSP handle = self._fontHandle.get(key) DCNL DCSP if (handle is None): DCNL DCSP  DCSP handle = pen.get_handle() DCNL DCSP  DCSP self._fontHandle[key] = handle DCNL DCSP if debugHandle: DCNL DCSP  DCSP print (' DCSP found DCSP pen DCSP handle DCSP %d' % handle) DCNL DCSP self.set_handle('pen', handle) DCNL DCSP if (pen.style != pyemf.PS_NULL): DCNL DCSP  DCSP return pen DCNL DCSP else: DCNL DCSP  DCSP return None
def select_brush(self, rgb): DCNL DCSP if (rgb is not None): DCNL DCSP  DCSP brush = EMFBrush(self.emf, rgb) DCNL DCSP  DCSP key = hash(brush) DCNL DCSP  DCSP handle = self._fontHandle.get(key) DCNL DCSP  DCSP if (handle is None): DCNL DCSP  DCSP  DCSP handle = brush.get_handle() DCNL DCSP  DCSP  DCSP self._fontHandle[key] = handle DCNL DCSP  DCSP if debugHandle: DCNL DCSP  DCSP  DCSP print (' DCSP found DCSP brush DCSP handle DCSP %d' % handle) DCNL DCSP  DCSP self.set_handle('brush', handle) DCNL DCSP  DCSP return brush DCNL DCSP else: DCNL DCSP  DCSP return None
def _get_font_ttf(self, prop): DCNL DCSP key = hash(prop) DCNL DCSP font = _fontd.get(key) DCNL DCSP if (font is None): DCNL DCSP  DCSP fname = findfont(prop) DCNL DCSP  DCSP if debugText: DCNL DCSP  DCSP  DCSP print ('_get_font_ttf: DCSP name=%s' % fname) DCNL DCSP  DCSP font = FT2Font(str(fname)) DCNL DCSP  DCSP _fontd[key] = font DCNL DCSP font.clear() DCNL DCSP size = prop.get_size_in_points() DCNL DCSP font.set_size(size, self.dpi) DCNL DCSP return font
def get_text_width_height(self, s, prop, ismath): DCNL DCSP if debugText: DCNL DCSP  DCSP print ('get_text_width_height: DCSP ismath=%s DCSP properties: DCSP %s' % (str(ismath), str(prop))) DCNL DCSP if ismath: DCNL DCSP  DCSP if debugText: DCNL DCSP  DCSP  DCSP print (' DCSP MATH DCSP TEXT! DCSP = DCSP %s' % str(ismath)) DCNL DCSP  DCSP (w, h) = self.get_math_text_width_height(s, prop) DCNL DCSP  DCSP return (w, h) DCNL DCSP font = self._get_font_ttf(prop) DCNL DCSP font.set_text(s, 0.0) DCNL DCSP (w, h) = font.get_width_height() DCNL DCSP w /= 64.0 DCNL DCSP h /= 64.0 DCNL DCSP if debugText: DCNL DCSP  DCSP print (' DCSP text DCSP string=%s DCSP w,h=(%f,%f)' % (s, w, h)) DCNL DCSP return (w, h)
def draw(self): DCNL DCSP pass
def _renderer_init(self): DCNL DCSP if _debug: DCNL DCSP  DCSP print ('%s.%s()' % (self.__class__.__name__, _fn_name())) DCNL DCSP self._renderer = RendererGTKCairo(self.figure.dpi)
def set_width_height(self, width, height): DCNL DCSP (self.width, self.height) = (width, height)
def _draw_rotated_text(self, gc, x, y, s, prop, angle): DCNL DCSP gdrawable = self.gdkDrawable DCNL DCSP ggc = gc.gdkGC DCNL DCSP (layout, inkRect, logicalRect) = self._get_pango_layout(s, prop) DCNL DCSP (l, b, w, h) = inkRect DCNL DCSP x = int((x - h)) DCNL DCSP y = int((y - w)) DCNL DCSP if ((x < 0) or (y < 0)): DCNL DCSP  DCSP return DCNL DCSP key = (x, y, s, angle, hash(prop)) DCNL DCSP imageVert = self.rotated.get(key) DCNL DCSP if (imageVert != None): DCNL DCSP  DCSP gdrawable.draw_image(ggc, imageVert, 0, 0, x, y, h, w) DCNL DCSP  DCSP return DCNL DCSP imageBack = gdrawable.get_image(x, y, w, h) DCNL DCSP imageVert = gdrawable.get_image(x, y, h, w) DCNL DCSP imageFlip = gtk.gdk.Image(type=gdk.IMAGE_FASTEST, visual=gdrawable.get_visual(), width=w, height=h) DCNL DCSP if ((imageFlip == None) or (imageBack == None) or (imageVert == None)): DCNL DCSP  DCSP warnings.warn('Could DCSP not DCSP renderer DCSP vertical DCSP text') DCNL DCSP  DCSP return DCNL DCSP imageFlip.set_colormap(self._cmap) DCNL DCSP for i in range(w): DCNL DCSP  DCSP for j in range(h): DCNL DCSP  DCSP  DCSP imageFlip.put_pixel(i, j, imageVert.get_pixel(j, ((w - i) - 1))) DCNL DCSP gdrawable.draw_image(ggc, imageFlip, 0, 0, x, y, w, h) DCNL DCSP gdrawable.draw_layout(ggc, x, (y - b), layout) DCNL DCSP imageIn = gdrawable.get_image(x, y, w, h) DCNL DCSP for i in range(w): DCNL DCSP  DCSP for j in range(h): DCNL DCSP  DCSP  DCSP imageVert.put_pixel(j, i, imageIn.get_pixel(((w - i) - 1), j)) DCNL DCSP gdrawable.draw_image(ggc, imageBack, 0, 0, x, y, w, h) DCNL DCSP gdrawable.draw_image(ggc, imageVert, 0, 0, x, y, h, w) DCNL DCSP self.rotated[key] = imageVert
def _get_pango_layout(self, s, prop): DCNL DCSP key = (self.dpi, s, hash(prop)) DCNL DCSP value = self.layoutd.get(key) DCNL DCSP if (value != None): DCNL DCSP  DCSP return value DCNL DCSP size = ((prop.get_size_in_points() * self.dpi) / 96.0) DCNL DCSP size = round(size) DCNL DCSP font_str = ('%s, DCSP %s DCSP %i' % (prop.get_name(), prop.get_style(), size)) DCNL DCSP font = pango.FontDescription(font_str) DCNL DCSP font.set_weight(self.fontweights[prop.get_weight()]) DCNL DCSP layout = self.gtkDA.create_pango_layout(s) DCNL DCSP layout.set_font_description(font) DCNL DCSP (inkRect, logicalRect) = layout.get_pixel_extents() DCNL DCSP self.layoutd[key] = (layout, inkRect, logicalRect) DCNL DCSP return (layout, inkRect, logicalRect)
def rgb_to_gdk_color(self, rgb): DCNL DCSP try: DCNL DCSP  DCSP return self._cached[tuple(rgb)] DCNL DCSP except KeyError: DCNL DCSP  DCSP color = self._cached[tuple(rgb)] = self._cmap.alloc_color(int((rgb[0] * 65535)), int((rgb[1] * 65535)), int((rgb[2] * 65535))) DCNL DCSP  DCSP return color
def paintEvent(self, e): DCNL DCSP FigureCanvasQT.paintEvent(self, e) DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'FigureCanvasQtAgg.paintEvent: DCSP ', self, self.get_width_height() DCNL DCSP p = qt.QPainter(self) DCNL DCSP if (type(self.replot) is bool): DCNL DCSP  DCSP if self.replot: DCNL DCSP  DCSP  DCSP FigureCanvasAgg.draw(self) DCNL DCSP  DCSP  DCSP if (qt.QImage.systemByteOrder() == qt.QImage.LittleEndian): DCNL DCSP  DCSP  DCSP  DCSP stringBuffer = self.renderer._renderer.tostring_bgra() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP stringBuffer = self.renderer._renderer.tostring_argb() DCNL DCSP  DCSP  DCSP qImage = qt.QImage(stringBuffer, self.renderer.width, self.renderer.height, 32, None, 0, qt.QImage.IgnoreEndian) DCNL DCSP  DCSP  DCSP self.pixmap.convertFromImage(qImage, qt.QPixmap.Color) DCNL DCSP  DCSP p.drawPixmap(qt.QPoint(0, 0), self.pixmap) DCNL DCSP  DCSP if self.drawRect: DCNL DCSP  DCSP  DCSP p.setPen(qt.QPen(qt.Qt.black, 1, qt.Qt.DotLine)) DCNL DCSP  DCSP  DCSP p.drawRect(self.rect[0], self.rect[1], self.rect[2], self.rect[3]) DCNL DCSP else: DCNL DCSP  DCSP bbox = self.replot DCNL DCSP  DCSP (l, b, r, t) = bbox.extents DCNL DCSP  DCSP w = (int(r) - int(l)) DCNL DCSP  DCSP h = (int(t) - int(b)) DCNL DCSP  DCSP reg = self.copy_from_bbox(bbox) DCNL DCSP  DCSP stringBuffer = reg.to_string_argb() DCNL DCSP  DCSP qImage = qt.QImage(stringBuffer, w, h, 32, None, 0, qt.QImage.IgnoreEndian) DCNL DCSP  DCSP self.pixmap.convertFromImage(qImage, qt.QPixmap.Color) DCNL DCSP  DCSP p.drawPixmap(qt.QPoint(l, (self.renderer.height - t)), self.pixmap) DCNL DCSP p.end() DCNL DCSP self.replot = False DCNL DCSP self.drawRect = False
def draw(self): DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'FigureCanvasQtAgg.draw', self DCNL DCSP self.replot = True DCNL DCSP FigureCanvasAgg.draw(self) DCNL DCSP self.repaint(False)
def blit(self, bbox=None): DCNL DCSP self.replot = bbox DCNL DCSP self.repaint(False)
def draw_idle(self): DCNL DCSP d = self._idle DCNL DCSP self._idle = False DCNL DCSP def idle_draw(*args): DCNL DCSP  DCSP self.draw() DCNL DCSP  DCSP self._idle = True DCNL DCSP if d: DCNL DCSP  DCSP self._tkcanvas.after_idle(idle_draw)
def get_tk_widget(self): DCNL DCSP return self._tkcanvas
def scroll_event_windows(self, event): DCNL DCSP w = event.widget.winfo_containing(event.x_root, event.y_root) DCNL DCSP if (w == self._tkcanvas): DCNL DCSP  DCSP x = (event.x_root - w.winfo_rootx()) DCNL DCSP  DCSP y = (event.y_root - w.winfo_rooty()) DCNL DCSP  DCSP y = (self.figure.bbox.height - y) DCNL DCSP  DCSP step = (event.delta / 120.0) DCNL DCSP  DCSP FigureCanvasBase.scroll_event(self, x, y, step, guiEvent=event)
def show(self): DCNL DCSP def destroy(*args): DCNL DCSP  DCSP self.window = None DCNL DCSP  DCSP Gcf.destroy(self._num) DCNL DCSP if (not self._shown): DCNL DCSP  DCSP self.canvas._tkcanvas.bind('<Destroy>', destroy) DCNL DCSP _focus = windowing.FocusManager() DCNL DCSP if (not self._shown): DCNL DCSP  DCSP self.window.deiconify() DCNL DCSP  DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP  DCSP self.window.update() DCNL DCSP else: DCNL DCSP  DCSP self.canvas.draw() DCNL DCSP self._shown = True
def dynamic_update(self): DCNL DCSP self.canvas.draw_idle()
def draw_mathtext(self, gc, x, y, s, prop, angle): DCNL DCSP if __debug__: DCNL DCSP  DCSP verbose.report('RendererAgg.draw_mathtext', 'debug-annoying') DCNL DCSP (ox, oy, width, height, descent, font_image, used_characters) = self.mathtext_parser.parse(s, self.dpi, prop) DCNL DCSP x = (int(x) + ox) DCNL DCSP y = (int(y) - oy) DCNL DCSP self._renderer.draw_text_image(font_image, x, (y + 1), angle, gc)
def draw_text(self, gc, x, y, s, prop, angle, ismath): DCNL DCSP if __debug__: DCNL DCSP  DCSP verbose.report('RendererAgg.draw_text', 'debug-annoying') DCNL DCSP if ismath: DCNL DCSP  DCSP return self.draw_mathtext(gc, x, y, s, prop, angle) DCNL DCSP font = self._get_agg_font(prop) DCNL DCSP if (font is None): DCNL DCSP  DCSP return None DCNL DCSP if ((len(s) == 1) and (ord(s) > 127)): DCNL DCSP  DCSP font.load_char(ord(s), flags=LOAD_FORCE_AUTOHINT) DCNL DCSP else: DCNL DCSP  DCSP font.set_text(s, 0, flags=LOAD_FORCE_AUTOHINT) DCNL DCSP font.draw_glyphs_to_bitmap() DCNL DCSP self._renderer.draw_text_image(font.get_image(), int(x), (int(y) + 1), angle, gc)
def get_text_width_height_descent(self, s, prop, ismath): DCNL DCSP if (ismath == 'TeX'): DCNL DCSP  DCSP size = prop.get_size_in_points() DCNL DCSP  DCSP texmanager = self.get_texmanager() DCNL DCSP  DCSP Z = texmanager.get_grey(s, size, self.dpi) DCNL DCSP  DCSP (m, n) = Z.shape DCNL DCSP  DCSP return (n, m, 0) DCNL DCSP if ismath: DCNL DCSP  DCSP (ox, oy, width, height, descent, fonts, used_characters) = self.mathtext_parser.parse(s, self.dpi, prop) DCNL DCSP  DCSP return (width, height, descent) DCNL DCSP font = self._get_agg_font(prop) DCNL DCSP font.set_text(s, 0.0, flags=LOAD_FORCE_AUTOHINT) DCNL DCSP (w, h) = font.get_width_height() DCNL DCSP d = font.get_descent() DCNL DCSP w /= 64.0 DCNL DCSP h /= 64.0 DCNL DCSP d /= 64.0 DCNL DCSP return (w, h, d)
def get_canvas_width_height(self): DCNL DCSP return (self.width, self.height)
def _get_agg_font(self, prop): DCNL DCSP if __debug__: DCNL DCSP  DCSP verbose.report('RendererAgg._get_agg_font', 'debug-annoying') DCNL DCSP key = hash(prop) DCNL DCSP font = self._fontd.get(key) DCNL DCSP if (font is None): DCNL DCSP  DCSP fname = findfont(prop) DCNL DCSP  DCSP font = self._fontd.get(fname) DCNL DCSP  DCSP if (font is None): DCNL DCSP  DCSP  DCSP font = FT2Font(str(fname)) DCNL DCSP  DCSP  DCSP self._fontd[fname] = font DCNL DCSP  DCSP self._fontd[key] = font DCNL DCSP font.clear() DCNL DCSP size = prop.get_size_in_points() DCNL DCSP font.set_size(size, self.dpi) DCNL DCSP return font
def points_to_pixels(self, points): DCNL DCSP if __debug__: DCNL DCSP  DCSP verbose.report('RendererAgg.points_to_pixels', 'debug-annoying') DCNL DCSP return ((points * self.dpi) / 72.0)
def draw(self): DCNL DCSP if __debug__: DCNL DCSP  DCSP verbose.report('FigureCanvasAgg.draw', 'debug-annoying') DCNL DCSP self.renderer = self.get_renderer() DCNL DCSP self.figure.draw(self.renderer)
def resize(self, width, height): DCNL DCSP self.window.resize(width, height)
def draw(self, drawDC=None): DCNL DCSP DEBUG_MSG('draw()', 1, self) DCNL DCSP FigureCanvasAgg.draw(self) DCNL DCSP self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None) DCNL DCSP self._isDrawn = True DCNL DCSP self.gui_repaint(drawDC=drawDC)
def blit(self, bbox=None): DCNL DCSP if (bbox is None): DCNL DCSP  DCSP self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None) DCNL DCSP  DCSP self.gui_repaint() DCNL DCSP  DCSP return DCNL DCSP (l, b, w, h) = bbox.bounds DCNL DCSP r = (l + w) DCNL DCSP t = (b + h) DCNL DCSP x = int(l) DCNL DCSP y = int((self.bitmap.GetHeight() - t)) DCNL DCSP srcBmp = _convert_agg_to_wx_bitmap(self.get_renderer(), None) DCNL DCSP srcDC = wx.MemoryDC() DCNL DCSP srcDC.SelectObject(srcBmp) DCNL DCSP destDC = wx.MemoryDC() DCNL DCSP destDC.SelectObject(self.bitmap) DCNL DCSP destDC.BeginDrawing() DCNL DCSP destDC.Blit(x, y, int(w), int(h), srcDC, x, y) DCNL DCSP destDC.EndDrawing() DCNL DCSP destDC.SelectObject(wx.NullBitmap) DCNL DCSP srcDC.SelectObject(wx.NullBitmap) DCNL DCSP self.gui_repaint()
def __init__(self, dpi): DCNL DCSP if _debug: DCNL DCSP  DCSP print ('%s.%s()' % (self.__class__.__name__, _fn_name())) DCNL DCSP self.dpi = dpi DCNL DCSP self.text_ctx = cairo.Context(cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)) DCNL DCSP self.mathtext_parser = MathTextParser('Cairo')
def paintEvent(self, e): DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'FigureCanvasQtAgg.paintEvent: DCSP ', self, self.get_width_height() DCNL DCSP if (type(self.replot) is bool): DCNL DCSP  DCSP if self.replot: DCNL DCSP  DCSP  DCSP FigureCanvasAgg.draw(self) DCNL DCSP  DCSP if (QtCore.QSysInfo.ByteOrder == QtCore.QSysInfo.LittleEndian): DCNL DCSP  DCSP  DCSP stringBuffer = self.renderer._renderer.tostring_bgra() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP stringBuffer = self.renderer._renderer.tostring_argb() DCNL DCSP  DCSP qImage = QtGui.QImage(stringBuffer, self.renderer.width, self.renderer.height, QtGui.QImage.Format_ARGB32) DCNL DCSP  DCSP p = QtGui.QPainter(self) DCNL DCSP  DCSP p.drawPixmap(QtCore.QPoint(0, 0), QtGui.QPixmap.fromImage(qImage)) DCNL DCSP  DCSP if self.drawRect: DCNL DCSP  DCSP  DCSP p.setPen(QtGui.QPen(QtCore.Qt.black, 1, QtCore.Qt.DotLine)) DCNL DCSP  DCSP  DCSP p.drawRect(self.rect[0], self.rect[1], self.rect[2], self.rect[3]) DCNL DCSP  DCSP p.end() DCNL DCSP else: DCNL DCSP  DCSP bbox = self.replot DCNL DCSP  DCSP (l, b, r, t) = bbox.extents DCNL DCSP  DCSP w = (int(r) - int(l)) DCNL DCSP  DCSP h = (int(t) - int(b)) DCNL DCSP  DCSP t = (int(b) + h) DCNL DCSP  DCSP reg = self.copy_from_bbox(bbox) DCNL DCSP  DCSP stringBuffer = reg.to_string_argb() DCNL DCSP  DCSP qImage = QtGui.QImage(stringBuffer, w, h, QtGui.QImage.Format_ARGB32) DCNL DCSP  DCSP pixmap = QtGui.QPixmap.fromImage(qImage) DCNL DCSP  DCSP p = QtGui.QPainter(self) DCNL DCSP  DCSP p.drawPixmap(QtCore.QPoint(l, (self.renderer.height - t)), pixmap) DCNL DCSP  DCSP p.end() DCNL DCSP self.replot = False DCNL DCSP self.drawRect = False
def draw(self): DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'FigureCanvasQtAgg.draw', self DCNL DCSP self.replot = True DCNL DCSP FigureCanvasAgg.draw(self) DCNL DCSP self.update() DCNL DCSP QtGui.qApp.processEvents()
def blit(self, bbox=None): DCNL DCSP self.replot = bbox DCNL DCSP (l, b, w, h) = bbox.bounds DCNL DCSP t = (b + h) DCNL DCSP self.update(l, (self.renderer.height - t), w, h)
def resize(self, width, height): DCNL DCSP self.window.resize(width, height)
def __init__(self, canvas, parent, coordinates=True): DCNL DCSP self.canvas = canvas DCNL DCSP self.coordinates = coordinates DCNL DCSP QtGui.QToolBar.__init__(self, parent) DCNL DCSP NavigationToolbar2.__init__(self, canvas)
def __init__(self, fmt='%Y-%m-%d', missing='Null', missingval=None): DCNL DCSP converter.__init__(self, missing, missingval) DCNL DCSP self.fmt = fmt
def __init__(self, fmt='%Y-%m-%d', missing='Null', missingval=None): DCNL DCSP converter.__init__(self, missing, missingval) DCNL DCSP self.fmt = fmt
def __init__(self, signals): DCNL DCSP self.signals = set(signals) DCNL DCSP self.callbacks = dict([(s, dict()) for s in signals]) DCNL DCSP self._cid = 0
def _check_signal(self, s): DCNL DCSP if (s not in self.signals): DCNL DCSP  DCSP signals = list(self.signals) DCNL DCSP  DCSP signals.sort() DCNL DCSP  DCSP raise ValueError(('Unknown DCSP signal DCSP "%s"; DCSP valid DCSP signals DCSP are DCSP %s' % (s, signals)))
def connect(self, s, func): DCNL DCSP self._check_signal(s) DCNL DCSP self._cid += 1 DCNL DCSP self.callbacks[s][self._cid] = func DCNL DCSP return self._cid
def disconnect(self, cid): DCNL DCSP for (eventname, callbackd) in self.callbacks.items(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP del callbackd[cid] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return
def process(self, s, *args, **kwargs): DCNL DCSP self._check_signal(s) DCNL DCSP for func in self.callbacks[s].values(): DCNL DCSP  DCSP func(*args, **kwargs)
def _make_regex(self): DCNL DCSP return re.compile('|'.join(map(re.escape, self.keys())))
def __call__(self, match): DCNL DCSP return self[match.group(0)]
def xlat(self, text): DCNL DCSP return self._make_regex().sub(self, text)
def append(self, x): DCNL DCSP self.data[self.cur] = x DCNL DCSP self.cur = ((self.cur + 1) % self.max)
def get(self): DCNL DCSP return (self.data[self.cur:] + self.data[:self.cur])
def append(self, x): DCNL DCSP self.data.append(x) DCNL DCSP if (len(self.data) == self.max): DCNL DCSP  DCSP self.cur = 0 DCNL DCSP  DCSP self.__class__ = __Full
def get(self): DCNL DCSP return self.data
def __call__(self): DCNL DCSP if (not len(self._elements)): DCNL DCSP  DCSP return self._default DCNL DCSP else: DCNL DCSP  DCSP return self._elements[self._pos]
def forward(self): DCNL DCSP N = len(self._elements) DCNL DCSP if (self._pos < (N - 1)): DCNL DCSP  DCSP self._pos += 1 DCNL DCSP return self()
def back(self): DCNL DCSP if (self._pos > 0): DCNL DCSP  DCSP self._pos -= 1 DCNL DCSP return self()
def push(self, o): DCNL DCSP self._elements = self._elements[:(self._pos + 1)] DCNL DCSP self._elements.append(o) DCNL DCSP self._pos = (len(self._elements) - 1) DCNL DCSP return self()
def home(self): DCNL DCSP if (not len(self._elements)): DCNL DCSP  DCSP return DCNL DCSP self.push(self._elements[0]) DCNL DCSP return self()
def clear(self): DCNL DCSP self._pos = (-1) DCNL DCSP self._elements = []
def bubble(self, o): DCNL DCSP if (o not in self._elements): DCNL DCSP  DCSP raise ValueError('Unknown DCSP element DCSP o') DCNL DCSP old = self._elements[:] DCNL DCSP self.clear() DCNL DCSP bubbles = [] DCNL DCSP for thiso in old: DCNL DCSP  DCSP if (thiso == o): DCNL DCSP  DCSP  DCSP bubbles.append(thiso) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.push(thiso) DCNL DCSP for thiso in bubbles: DCNL DCSP  DCSP self.push(o) DCNL DCSP return o
def remove(self, o): DCNL DCSP if (o not in self._elements): DCNL DCSP  DCSP raise ValueError('Unknown DCSP element DCSP o') DCNL DCSP old = self._elements[:] DCNL DCSP self.clear() DCNL DCSP for thiso in old: DCNL DCSP  DCSP if (thiso == o): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.push(thiso)
def clean(self): DCNL DCSP mapping = self._mapping DCNL DCSP for (key, val) in mapping.items(): DCNL DCSP  DCSP if (key() is None): DCNL DCSP  DCSP  DCSP del mapping[key] DCNL DCSP  DCSP  DCSP val.remove(key)
def join(self, a, *args): DCNL DCSP mapping = self._mapping DCNL DCSP set_a = mapping.setdefault(ref(a), [ref(a)]) DCNL DCSP for arg in args: DCNL DCSP  DCSP set_b = mapping.get(ref(arg)) DCNL DCSP  DCSP if (set_b is None): DCNL DCSP  DCSP  DCSP set_a.append(ref(arg)) DCNL DCSP  DCSP  DCSP mapping[ref(arg)] = set_a DCNL DCSP  DCSP elif (set_b is not set_a): DCNL DCSP  DCSP  DCSP if (len(set_b) > len(set_a)): DCNL DCSP  DCSP  DCSP  DCSP (set_a, set_b) = (set_b, set_a) DCNL DCSP  DCSP  DCSP set_a.extend(set_b) DCNL DCSP  DCSP  DCSP for elem in set_b: DCNL DCSP  DCSP  DCSP  DCSP mapping[elem] = set_a DCNL DCSP self.clean()
def joined(self, a, b): DCNL DCSP self.clean() DCNL DCSP mapping = self._mapping DCNL DCSP try: DCNL DCSP  DCSP return (mapping[ref(a)] is mapping[ref(b)]) DCNL DCSP except KeyError: DCNL DCSP  DCSP return False
def __iter__(self): DCNL DCSP self.clean() DCNL DCSP class Token: DCNL DCSP  DCSP pass DCNL DCSP token = Token() DCNL DCSP for group in self._mapping.itervalues(): DCNL DCSP  DCSP if (not (group[(-1)] is token)): DCNL DCSP  DCSP  DCSP (yield [x() for x in group]) DCNL DCSP  DCSP  DCSP group.append(token) DCNL DCSP for group in self._mapping.itervalues(): DCNL DCSP  DCSP if (group[(-1)] is token): DCNL DCSP  DCSP  DCSP del group[(-1)]
def get_siblings(self, a): DCNL DCSP self.clean() DCNL DCSP siblings = self._mapping.get(ref(a), [ref(a)]) DCNL DCSP return [x() for x in siblings]
def get_transform(self): DCNL DCSP raise NotImplementedError
def set_default_locators_and_formatters(self, axis): DCNL DCSP raise NotImplementedError
def limit_range_for_scale(self, vmin, vmax, minpos): DCNL DCSP return (vmin, vmax)
def set_default_locators_and_formatters(self, axis): DCNL DCSP axis.set_major_locator(AutoLocator()) DCNL DCSP axis.set_major_formatter(ScalarFormatter()) DCNL DCSP axis.set_minor_locator(NullLocator()) DCNL DCSP axis.set_minor_formatter(NullFormatter())
def get_transform(self): DCNL DCSP return IdentityTransform()
def __init__(self, axis, **kwargs): DCNL DCSP if (axis.axis_name == 'x'): DCNL DCSP  DCSP base = kwargs.pop('basex', 10.0) DCNL DCSP  DCSP subs = kwargs.pop('subsx', None) DCNL DCSP else: DCNL DCSP  DCSP base = kwargs.pop('basey', 10.0) DCNL DCSP  DCSP subs = kwargs.pop('subsy', None) DCNL DCSP if (base == 10.0): DCNL DCSP  DCSP self._transform = self.Log10Transform() DCNL DCSP elif (base == 2.0): DCNL DCSP  DCSP self._transform = self.Log2Transform() DCNL DCSP elif (base == np.e): DCNL DCSP  DCSP self._transform = self.NaturalLogTransform() DCNL DCSP else: DCNL DCSP  DCSP self._transform = self.LogTransform(base) DCNL DCSP self.base = base DCNL DCSP self.subs = subs
def set_default_locators_and_formatters(self, axis): DCNL DCSP axis.set_major_locator(LogLocator(self.base)) DCNL DCSP axis.set_major_formatter(LogFormatterMathtext(self.base)) DCNL DCSP axis.set_minor_locator(LogLocator(self.base, self.subs)) DCNL DCSP axis.set_minor_formatter(NullFormatter())
def get_transform(self): DCNL DCSP return self._transform
def limit_range_for_scale(self, vmin, vmax, minpos): DCNL DCSP return ((((vmin <= 0.0) and minpos) or vmin), (((vmax <= 0.0) and minpos) or vmax))
def __init__(self, axis, **kwargs): DCNL DCSP if (axis.axis_name == 'x'): DCNL DCSP  DCSP base = kwargs.pop('basex', 10.0) DCNL DCSP  DCSP linthresh = kwargs.pop('linthreshx', 2.0) DCNL DCSP  DCSP subs = kwargs.pop('subsx', None) DCNL DCSP else: DCNL DCSP  DCSP base = kwargs.pop('basey', 10.0) DCNL DCSP  DCSP linthresh = kwargs.pop('linthreshy', 2.0) DCNL DCSP  DCSP subs = kwargs.pop('subsy', None) DCNL DCSP self._transform = self.SymmetricalLogTransform(base, linthresh) DCNL DCSP self.base = base DCNL DCSP self.linthresh = linthresh DCNL DCSP self.subs = subs
def set_default_locators_and_formatters(self, axis): DCNL DCSP axis.set_major_locator(SymmetricalLogLocator(self.get_transform())) DCNL DCSP axis.set_major_formatter(LogFormatterMathtext(self.base)) DCNL DCSP axis.set_minor_locator(SymmetricalLogLocator(self.get_transform(), self.subs)) DCNL DCSP axis.set_minor_formatter(NullFormatter())
def get_transform(self): DCNL DCSP return self._transform
def open_group(self, s): DCNL DCSP pass
def close_group(self, s): DCNL DCSP pass
def draw_path(self, gc, path, transform, rgbFace=None): DCNL DCSP raise NotImplementedError
def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None): DCNL DCSP tpath = trans.transform_path(path) DCNL DCSP for (vertices, codes) in tpath.iter_segments(): DCNL DCSP  DCSP if len(vertices): DCNL DCSP  DCSP  DCSP (x, y) = vertices[(-2):] DCNL DCSP  DCSP  DCSP self.draw_path(gc, marker_path, (marker_trans + transforms.Affine2D().translate(x, y)), rgbFace)
def draw_path_collection(self, master_transform, cliprect, clippath, clippath_trans, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls): DCNL DCSP path_ids = [] DCNL DCSP for (path, transform) in self._iter_collection_raw_paths(master_transform, paths, all_transforms): DCNL DCSP  DCSP path_ids.append((path, transform)) DCNL DCSP for (xo, yo, path_id, gc, rgbFace) in self._iter_collection(path_ids, cliprect, clippath, clippath_trans, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls): DCNL DCSP  DCSP (path, transform) = path_id DCNL DCSP  DCSP transform = transforms.Affine2D(transform.get_matrix()).translate(xo, yo) DCNL DCSP  DCSP self.draw_path(gc, path, transform, rgbFace)
def draw_quad_mesh(self, master_transform, cliprect, clippath, clippath_trans, meshWidth, meshHeight, coordinates, offsets, offsetTrans, facecolors, antialiased, showedges): DCNL DCSP from matplotlib.collections import QuadMesh DCNL DCSP paths = QuadMesh.convert_mesh_to_paths(meshWidth, meshHeight, coordinates) DCNL DCSP if showedges: DCNL DCSP  DCSP edgecolors = np.array([[0.0, 0.0, 0.0, 1.0]], np.float_) DCNL DCSP  DCSP linewidths = np.array([1.0], np.float_) DCNL DCSP else: DCNL DCSP  DCSP edgecolors = facecolors DCNL DCSP  DCSP linewidths = np.array([0.0], np.float_) DCNL DCSP return self.draw_path_collection(master_transform, cliprect, clippath, clippath_trans, paths, [], offsets, offsetTrans, facecolors, edgecolors, linewidths, [], [antialiased], [None])
def _iter_collection_raw_paths(self, master_transform, paths, all_transforms): DCNL DCSP Npaths = len(paths) DCNL DCSP Ntransforms = len(all_transforms) DCNL DCSP N = max(Npaths, Ntransforms) DCNL DCSP if (Npaths == 0): DCNL DCSP  DCSP return DCNL DCSP transform = transforms.IdentityTransform() DCNL DCSP for i in xrange(N): DCNL DCSP  DCSP path = paths[(i % Npaths)] DCNL DCSP  DCSP if Ntransforms: DCNL DCSP  DCSP  DCSP transform = all_transforms[(i % Ntransforms)] DCNL DCSP  DCSP (yield (path, (transform + master_transform)))
def _iter_collection(self, path_ids, cliprect, clippath, clippath_trans, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls): DCNL DCSP Npaths = len(path_ids) DCNL DCSP Noffsets = len(offsets) DCNL DCSP N = max(Npaths, Noffsets) DCNL DCSP Nfacecolors = len(facecolors) DCNL DCSP Nedgecolors = len(edgecolors) DCNL DCSP Nlinewidths = len(linewidths) DCNL DCSP Nlinestyles = len(linestyles) DCNL DCSP Naa = len(antialiaseds) DCNL DCSP Nurls = len(urls) DCNL DCSP if (((Nfacecolors == 0) and (Nedgecolors == 0)) or (Npaths == 0)): DCNL DCSP  DCSP return DCNL DCSP if Noffsets: DCNL DCSP  DCSP toffsets = offsetTrans.transform(offsets) DCNL DCSP gc = self.new_gc() DCNL DCSP gc.set_clip_rectangle(cliprect) DCNL DCSP if (clippath is not None): DCNL DCSP  DCSP clippath = transforms.TransformedPath(clippath, clippath_trans) DCNL DCSP  DCSP gc.set_clip_path(clippath) DCNL DCSP if (Nfacecolors == 0): DCNL DCSP  DCSP rgbFace = None DCNL DCSP if (Nedgecolors == 0): DCNL DCSP  DCSP gc.set_linewidth(0.0) DCNL DCSP (xo, yo) = (0, 0) DCNL DCSP for i in xrange(N): DCNL DCSP  DCSP path_id = path_ids[(i % Npaths)] DCNL DCSP  DCSP if Noffsets: DCNL DCSP  DCSP  DCSP (xo, yo) = toffsets[(i % Noffsets)] DCNL DCSP  DCSP if Nfacecolors: DCNL DCSP  DCSP  DCSP rgbFace = facecolors[(i % Nfacecolors)] DCNL DCSP  DCSP if Nedgecolors: DCNL DCSP  DCSP  DCSP gc.set_foreground(edgecolors[(i % Nedgecolors)]) DCNL DCSP  DCSP  DCSP if Nlinewidths: DCNL DCSP  DCSP  DCSP  DCSP gc.set_linewidth(linewidths[(i % Nlinewidths)]) DCNL DCSP  DCSP  DCSP if Nlinestyles: DCNL DCSP  DCSP  DCSP  DCSP gc.set_dashes(*linestyles[(i % Nlinestyles)]) DCNL DCSP  DCSP if ((rgbFace is not None) and (len(rgbFace) == 4)): DCNL DCSP  DCSP  DCSP gc.set_alpha(rgbFace[(-1)]) DCNL DCSP  DCSP  DCSP rgbFace = rgbFace[:3] DCNL DCSP  DCSP gc.set_antialiased(antialiaseds[(i % Naa)]) DCNL DCSP  DCSP if Nurls: DCNL DCSP  DCSP  DCSP gc.set_url(urls[(i % Nurls)]) DCNL DCSP  DCSP (yield (xo, yo, path_id, gc, rgbFace))
def get_image_magnification(self): DCNL DCSP return 1.0
def draw_image(self, x, y, im, bbox, clippath=None, clippath_trans=None): DCNL DCSP raise NotImplementedError
def option_image_nocomposite(self): DCNL DCSP return False
def draw_text(self, gc, x, y, s, prop, angle, ismath=False): DCNL DCSP raise NotImplementedError
def flipy(self): DCNL DCSP return True
def get_canvas_width_height(self): DCNL DCSP return (1, 1)
def get_texmanager(self): DCNL DCSP if (self._texmanager is None): DCNL DCSP  DCSP from matplotlib.texmanager import TexManager DCNL DCSP  DCSP self._texmanager = TexManager() DCNL DCSP return self._texmanager
def get_text_width_height_descent(self, s, prop, ismath): DCNL DCSP raise NotImplementedError
def new_gc(self): DCNL DCSP return GraphicsContextBase()
def points_to_pixels(self, points): DCNL DCSP return points
def copy_properties(self, gc): DCNL DCSP self._alpha = gc._alpha DCNL DCSP self._antialiased = gc._antialiased DCNL DCSP self._capstyle = gc._capstyle DCNL DCSP self._cliprect = gc._cliprect DCNL DCSP self._clippath = gc._clippath DCNL DCSP self._dashes = gc._dashes DCNL DCSP self._joinstyle = gc._joinstyle DCNL DCSP self._linestyle = gc._linestyle DCNL DCSP self._linewidth = gc._linewidth DCNL DCSP self._rgb = gc._rgb DCNL DCSP self._hatch = gc._hatch DCNL DCSP self._url = gc._url DCNL DCSP self._snap = gc._snap
def get_alpha(self): DCNL DCSP return self._alpha
def get_antialiased(self): DCNL DCSP return self._antialiased
def get_capstyle(self): DCNL DCSP return self._capstyle
def get_clip_rectangle(self): DCNL DCSP return self._cliprect
def get_clip_path(self): DCNL DCSP if (self._clippath is not None): DCNL DCSP  DCSP return self._clippath.get_transformed_path_and_affine() DCNL DCSP return (None, None)
def get_dashes(self): DCNL DCSP return self._dashes
def get_joinstyle(self): DCNL DCSP return self._joinstyle
def get_linestyle(self, style): DCNL DCSP return self._linestyle
def get_linewidth(self): DCNL DCSP return self._linewidth
def get_rgb(self): DCNL DCSP return self._rgb
def get_url(self): DCNL DCSP return self._url
def get_snap(self): DCNL DCSP return self._snap
def set_alpha(self, alpha): DCNL DCSP self._alpha = alpha
def set_antialiased(self, b): DCNL DCSP if b: DCNL DCSP  DCSP self._antialiased = 1 DCNL DCSP else: DCNL DCSP  DCSP self._antialiased = 0
def set_capstyle(self, cs): DCNL DCSP if (cs in ('butt', 'round', 'projecting')): DCNL DCSP  DCSP self._capstyle = cs DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unrecognized DCSP cap DCSP style. DCSP  DCSP Found DCSP %s' % cs))
def set_clip_rectangle(self, rectangle): DCNL DCSP self._cliprect = rectangle
def set_clip_path(self, path): DCNL DCSP assert ((path is None) or isinstance(path, transforms.TransformedPath)) DCNL DCSP self._clippath = path
def set_dashes(self, dash_offset, dash_list): DCNL DCSP self._dashes = (dash_offset, dash_list)
def set_foreground(self, fg, isRGB=False): DCNL DCSP if isRGB: DCNL DCSP  DCSP self._rgb = fg DCNL DCSP else: DCNL DCSP  DCSP self._rgb = colors.colorConverter.to_rgba(fg)
def set_graylevel(self, frac): DCNL DCSP self._rgb = (frac, frac, frac)
def set_joinstyle(self, js): DCNL DCSP if (js in ('miter', 'round', 'bevel')): DCNL DCSP  DCSP self._joinstyle = js DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unrecognized DCSP join DCSP style. DCSP  DCSP Found DCSP %s' % js))
def set_linewidth(self, w): DCNL DCSP self._linewidth = w
def set_linestyle(self, style): DCNL DCSP try: DCNL DCSP  DCSP (offset, dashes) = self.dashd[style] DCNL DCSP except: DCNL DCSP  DCSP raise ValueError(('Unrecognized DCSP linestyle: DCSP %s' % style)) DCNL DCSP self._linestyle = style DCNL DCSP self.set_dashes(offset, dashes)
def set_url(self, url): DCNL DCSP self._url = url
def set_snap(self, snap): DCNL DCSP self._snap = snap
def set_hatch(self, hatch): DCNL DCSP self._hatch = hatch
def get_hatch(self): DCNL DCSP return self._hatch
def __init__(self, name, canvas, x, y, guiEvent=None): DCNL DCSP Event.__init__(self, name, canvas, guiEvent=guiEvent) DCNL DCSP self.x = x DCNL DCSP self.y = y DCNL DCSP if ((x is None) or (y is None)): DCNL DCSP  DCSP self.inaxes = None DCNL DCSP  DCSP self._update_enter_leave() DCNL DCSP  DCSP return DCNL DCSP axes_list = [a for a in self.canvas.figure.get_axes() if a.in_axes(self)] DCNL DCSP if (len(axes_list) == 0): DCNL DCSP  DCSP self.inaxes = None DCNL DCSP  DCSP self._update_enter_leave() DCNL DCSP  DCSP return DCNL DCSP elif (len(axes_list) > 1): DCNL DCSP  DCSP axCmp = (lambda _x, _y: cmp(_x.zorder, _y.zorder)) DCNL DCSP  DCSP axes_list.sort(axCmp) DCNL DCSP  DCSP self.inaxes = axes_list[(-1)] DCNL DCSP else: DCNL DCSP  DCSP self.inaxes = axes_list[0] DCNL DCSP try: DCNL DCSP  DCSP (xdata, ydata) = self.inaxes.transData.inverted().transform_point((x, y)) DCNL DCSP except ValueError: DCNL DCSP  DCSP self.xdata = None DCNL DCSP  DCSP self.ydata = None DCNL DCSP else: DCNL DCSP  DCSP self.xdata = xdata DCNL DCSP  DCSP self.ydata = ydata DCNL DCSP self._update_enter_leave()
def _update_enter_leave(self): DCNL DCSP if (LocationEvent.lastevent is not None): DCNL DCSP  DCSP last = LocationEvent.lastevent DCNL DCSP  DCSP if (last.inaxes != self.inaxes): DCNL DCSP  DCSP  DCSP if (last.inaxes is not None): DCNL DCSP  DCSP  DCSP  DCSP last.canvas.callbacks.process('axes_leave_event', last) DCNL DCSP  DCSP  DCSP if (self.inaxes is not None): DCNL DCSP  DCSP  DCSP  DCSP self.canvas.callbacks.process('axes_enter_event', self) DCNL DCSP elif (self.inaxes is not None): DCNL DCSP  DCSP self.canvas.callbacks.process('axes_enter_event', self) DCNL DCSP LocationEvent.lastevent = self
def __init__(self, name, canvas, x, y, button=None, key=None, step=0, guiEvent=None): DCNL DCSP LocationEvent.__init__(self, name, canvas, x, y, guiEvent=guiEvent) DCNL DCSP self.button = button DCNL DCSP self.key = key DCNL DCSP self.step = step
def onRemove(self, ev): DCNL DCSP def sort_artists(artists): DCNL DCSP  DCSP L = [(h.zorder, h) for h in artists] DCNL DCSP  DCSP L.sort() DCNL DCSP  DCSP return [h for (zorder, h) in L] DCNL DCSP under = sort_artists(self.figure.hitlist(ev)) DCNL DCSP h = None DCNL DCSP if under: DCNL DCSP  DCSP h = under[(-1)] DCNL DCSP while h: DCNL DCSP  DCSP print 'Removing', h DCNL DCSP  DCSP if h.remove(): DCNL DCSP  DCSP  DCSP self.draw_idle() DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP parent = None DCNL DCSP  DCSP for p in under: DCNL DCSP  DCSP  DCSP if (h in p.get_children()): DCNL DCSP  DCSP  DCSP  DCSP parent = p DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP h = parent
def onHilite(self, ev): DCNL DCSP if (not hasattr(self, '_active')): DCNL DCSP  DCSP self._active = dict() DCNL DCSP under = self.figure.hitlist(ev) DCNL DCSP enter = [a for a in under if (a not in self._active)] DCNL DCSP leave = [a for a in self._active if (a not in under)] DCNL DCSP print 'within:', ' DCSP '.join([str(x) for x in under]) DCNL DCSP for a in leave: DCNL DCSP  DCSP if hasattr(a, 'get_color'): DCNL DCSP  DCSP  DCSP a.set_color(self._active[a]) DCNL DCSP  DCSP elif hasattr(a, 'get_edgecolor'): DCNL DCSP  DCSP  DCSP a.set_edgecolor(self._active[a][0]) DCNL DCSP  DCSP  DCSP a.set_facecolor(self._active[a][1]) DCNL DCSP  DCSP del self._active[a] DCNL DCSP for a in enter: DCNL DCSP  DCSP if hasattr(a, 'get_color'): DCNL DCSP  DCSP  DCSP self._active[a] = a.get_color() DCNL DCSP  DCSP elif hasattr(a, 'get_edgecolor'): DCNL DCSP  DCSP  DCSP self._active[a] = (a.get_edgecolor(), a.get_facecolor()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._active[a] = None DCNL DCSP for a in enter: DCNL DCSP  DCSP if hasattr(a, 'get_color'): DCNL DCSP  DCSP  DCSP a.set_color('red') DCNL DCSP  DCSP elif hasattr(a, 'get_edgecolor'): DCNL DCSP  DCSP  DCSP a.set_edgecolor('red') DCNL DCSP  DCSP  DCSP a.set_facecolor('lightblue') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._active[a] = None DCNL DCSP self.draw_idle()
def blit(self, bbox=None): DCNL DCSP pass
def resize(self, w, h): DCNL DCSP pass
def draw_event(self, renderer): DCNL DCSP s = 'draw_event' DCNL DCSP event = DrawEvent(s, self, renderer) DCNL DCSP self.callbacks.process(s, event)
def resize_event(self): DCNL DCSP s = 'resize_event' DCNL DCSP event = ResizeEvent(s, self) DCNL DCSP self.callbacks.process(s, event)
def key_press_event(self, key, guiEvent=None): DCNL DCSP self._key = key DCNL DCSP s = 'key_press_event' DCNL DCSP event = KeyEvent(s, self, key, self._lastx, self._lasty, guiEvent=guiEvent) DCNL DCSP self.callbacks.process(s, event)
def key_release_event(self, key, guiEvent=None): DCNL DCSP s = 'key_release_event' DCNL DCSP event = KeyEvent(s, self, key, self._lastx, self._lasty, guiEvent=guiEvent) DCNL DCSP self.callbacks.process(s, event) DCNL DCSP self._key = None
def pick_event(self, mouseevent, artist, **kwargs): DCNL DCSP s = 'pick_event' DCNL DCSP event = PickEvent(s, self, mouseevent, artist, **kwargs) DCNL DCSP self.callbacks.process(s, event)
def scroll_event(self, x, y, step, guiEvent=None): DCNL DCSP if (step >= 0): DCNL DCSP  DCSP self._button = 'up' DCNL DCSP else: DCNL DCSP  DCSP self._button = 'down' DCNL DCSP s = 'scroll_event' DCNL DCSP mouseevent = MouseEvent(s, self, x, y, self._button, self._key, step=step, guiEvent=guiEvent) DCNL DCSP self.callbacks.process(s, mouseevent)
def button_press_event(self, x, y, button, guiEvent=None): DCNL DCSP self._button = button DCNL DCSP s = 'button_press_event' DCNL DCSP mouseevent = MouseEvent(s, self, x, y, button, self._key, guiEvent=guiEvent) DCNL DCSP self.callbacks.process(s, mouseevent)
def button_release_event(self, x, y, button, guiEvent=None): DCNL DCSP s = 'button_release_event' DCNL DCSP event = MouseEvent(s, self, x, y, button, self._key, guiEvent=guiEvent) DCNL DCSP self.callbacks.process(s, event) DCNL DCSP self._button = None
def motion_notify_event(self, x, y, guiEvent=None): DCNL DCSP (self._lastx, self._lasty) = (x, y) DCNL DCSP s = 'motion_notify_event' DCNL DCSP event = MouseEvent(s, self, x, y, self._button, self._key, guiEvent=guiEvent) DCNL DCSP self.callbacks.process(s, event)
def leave_notify_event(self, guiEvent=None): DCNL DCSP self.callbacks.process('figure_leave_event', LocationEvent.lastevent) DCNL DCSP LocationEvent.lastevent = None
def enter_notify_event(self, guiEvent=None): DCNL DCSP event = Event('figure_enter_event', self, guiEvent) DCNL DCSP self.callbacks.process('figure_enter_event', event)
def idle_event(self, guiEvent=None): DCNL DCSP s = 'idle_event' DCNL DCSP event = IdleEvent(s, self, guiEvent=guiEvent) DCNL DCSP self.callbacks.process(s, event)
def draw(self, *args, **kwargs): DCNL DCSP pass
def draw_idle(self, *args, **kwargs): DCNL DCSP self.draw(*args, **kwargs)
def draw_cursor(self, event): DCNL DCSP pass
def get_width_height(self): DCNL DCSP return (int(self.figure.bbox.width), int(self.figure.bbox.height))
def print_figure(self, filename, dpi=None, facecolor='w', edgecolor='w', orientation='portrait', format=None, **kwargs): DCNL DCSP if (format is None): DCNL DCSP  DCSP if cbook.is_string_like(filename): DCNL DCSP  DCSP  DCSP format = os.path.splitext(filename)[1][1:] DCNL DCSP  DCSP if ((format is None) or (format == '')): DCNL DCSP  DCSP  DCSP format = self.get_default_filetype() DCNL DCSP  DCSP  DCSP if cbook.is_string_like(filename): DCNL DCSP  DCSP  DCSP  DCSP filename = ((filename.rstrip('.') + '.') + format) DCNL DCSP format = format.lower() DCNL DCSP method_name = ('print_%s' % format) DCNL DCSP if ((format not in self.filetypes) or (not hasattr(self, method_name))): DCNL DCSP  DCSP formats = self.filetypes.keys() DCNL DCSP  DCSP formats.sort() DCNL DCSP  DCSP raise ValueError(('Format DCSP "%s" DCSP is DCSP not DCSP supported.\nSupported DCSP formats: DCSP %s.' % (format, ', DCSP '.join(formats)))) DCNL DCSP if (dpi is None): DCNL DCSP  DCSP dpi = rcParams['savefig.dpi'] DCNL DCSP origDPI = self.figure.dpi DCNL DCSP origfacecolor = self.figure.get_facecolor() DCNL DCSP origedgecolor = self.figure.get_edgecolor() DCNL DCSP self.figure.dpi = dpi DCNL DCSP self.figure.set_facecolor(facecolor) DCNL DCSP self.figure.set_edgecolor(edgecolor) DCNL DCSP try: DCNL DCSP  DCSP result = getattr(self, method_name)(filename, dpi=dpi, facecolor=facecolor, edgecolor=edgecolor, orientation=orientation, **kwargs) DCNL DCSP finally: DCNL DCSP  DCSP self.figure.dpi = origDPI DCNL DCSP  DCSP self.figure.set_facecolor(origfacecolor) DCNL DCSP  DCSP self.figure.set_edgecolor(origedgecolor) DCNL DCSP  DCSP self.figure.set_canvas(self) DCNL DCSP return result
def set_window_title(self, title): DCNL DCSP if hasattr(self, 'manager'): DCNL DCSP  DCSP self.manager.set_window_title(title)
def switch_backends(self, FigureCanvasClass): DCNL DCSP newCanvas = FigureCanvasClass(self.figure) DCNL DCSP return newCanvas
def mpl_connect(self, s, func): DCNL DCSP return self.callbacks.connect(s, func)
def mpl_disconnect(self, cid): DCNL DCSP return self.callbacks.disconnect(cid)
def flush_events(self): DCNL DCSP raise NotImplementedError
def start_event_loop(self, timeout): DCNL DCSP raise NotImplementedError
def stop_event_loop(self): DCNL DCSP raise NotImplementedError
def start_event_loop_default(self, timeout=0): DCNL DCSP str = 'Using DCSP default DCSP event DCSP loop DCSP until DCSP function DCSP specific' DCNL DCSP str += ' DCSP to DCSP this DCSP GUI DCSP is DCSP implemented' DCNL DCSP warnings.warn(str, DeprecationWarning) DCNL DCSP if (timeout <= 0): DCNL DCSP  DCSP timeout = np.inf DCNL DCSP timestep = 0.01 DCNL DCSP counter = 0 DCNL DCSP self._looping = True DCNL DCSP while (self._looping and ((counter * timestep) < timeout)): DCNL DCSP  DCSP self.flush_events() DCNL DCSP  DCSP time.sleep(timestep) DCNL DCSP  DCSP counter += 1
def stop_event_loop_default(self): DCNL DCSP self._looping = False
def resize(self, w, h): DCNL DCSP pass
def show_popup(self, msg): DCNL DCSP pass
def set_window_title(self, title): DCNL DCSP pass
def set_message(self, s): DCNL DCSP pass
def back(self, *args): DCNL DCSP self._views.back() DCNL DCSP self._positions.back() DCNL DCSP self.set_history_buttons() DCNL DCSP self._update_view()
def draw_rubberband(self, event, x0, y0, x1, y1): DCNL DCSP pass
def forward(self, *args): DCNL DCSP self._views.forward() DCNL DCSP self._positions.forward() DCNL DCSP self.set_history_buttons() DCNL DCSP self._update_view()
def home(self, *args): DCNL DCSP self._views.home() DCNL DCSP self._positions.home() DCNL DCSP self.set_history_buttons() DCNL DCSP self._update_view()
def _init_toolbar(self): DCNL DCSP raise NotImplementedError
def pan(self, *args): DCNL DCSP if (self._active == 'PAN'): DCNL DCSP  DCSP self._active = None DCNL DCSP else: DCNL DCSP  DCSP self._active = 'PAN' DCNL DCSP if (self._idPress is not None): DCNL DCSP  DCSP self._idPress = self.canvas.mpl_disconnect(self._idPress) DCNL DCSP  DCSP self.mode = '' DCNL DCSP if (self._idRelease is not None): DCNL DCSP  DCSP self._idRelease = self.canvas.mpl_disconnect(self._idRelease) DCNL DCSP  DCSP self.mode = '' DCNL DCSP if self._active: DCNL DCSP  DCSP self._idPress = self.canvas.mpl_connect('button_press_event', self.press_pan) DCNL DCSP  DCSP self._idRelease = self.canvas.mpl_connect('button_release_event', self.release_pan) DCNL DCSP  DCSP self.mode = 'pan/zoom DCSP mode' DCNL DCSP  DCSP self.canvas.widgetlock(self) DCNL DCSP else: DCNL DCSP  DCSP self.canvas.widgetlock.release(self) DCNL DCSP for a in self.canvas.figure.get_axes(): DCNL DCSP  DCSP a.set_navigate_mode(self._active) DCNL DCSP self.set_message(self.mode)
def press(self, event): DCNL DCSP pass
def press_pan(self, event): DCNL DCSP if (event.button == 1): DCNL DCSP  DCSP self._button_pressed = 1 DCNL DCSP elif (event.button == 3): DCNL DCSP  DCSP self._button_pressed = 3 DCNL DCSP else: DCNL DCSP  DCSP self._button_pressed = None DCNL DCSP  DCSP return DCNL DCSP (x, y) = (event.x, event.y) DCNL DCSP if self._views.empty(): DCNL DCSP  DCSP self.push_current() DCNL DCSP self._xypress = [] DCNL DCSP for (i, a) in enumerate(self.canvas.figure.get_axes()): DCNL DCSP  DCSP if ((x is not None) and (y is not None) and a.in_axes(event) and a.get_navigate()): DCNL DCSP  DCSP  DCSP a.start_pan(x, y, event.button) DCNL DCSP  DCSP  DCSP self._xypress.append((a, i)) DCNL DCSP  DCSP  DCSP self.canvas.mpl_disconnect(self._idDrag) DCNL DCSP  DCSP  DCSP self._idDrag = self.canvas.mpl_connect('motion_notify_event', self.drag_pan) DCNL DCSP self.press(event)
def press_zoom(self, event): DCNL DCSP if (event.button == 1): DCNL DCSP  DCSP self._button_pressed = 1 DCNL DCSP elif (event.button == 3): DCNL DCSP  DCSP self._button_pressed = 3 DCNL DCSP else: DCNL DCSP  DCSP self._button_pressed = None DCNL DCSP  DCSP return DCNL DCSP (x, y) = (event.x, event.y) DCNL DCSP if self._views.empty(): DCNL DCSP  DCSP self.push_current() DCNL DCSP self._xypress = [] DCNL DCSP for (i, a) in enumerate(self.canvas.figure.get_axes()): DCNL DCSP  DCSP if ((x is not None) and (y is not None) and a.in_axes(event) and a.get_navigate() and a.can_zoom()): DCNL DCSP  DCSP  DCSP self._xypress.append((x, y, a, i, a.viewLim.frozen(), a.transData.frozen())) DCNL DCSP self.press(event)
def push_current(self): DCNL DCSP lims = [] DCNL DCSP pos = [] DCNL DCSP for a in self.canvas.figure.get_axes(): DCNL DCSP  DCSP (xmin, xmax) = a.get_xlim() DCNL DCSP  DCSP (ymin, ymax) = a.get_ylim() DCNL DCSP  DCSP lims.append((xmin, xmax, ymin, ymax)) DCNL DCSP  DCSP pos.append((a.get_position(True).frozen(), a.get_position().frozen())) DCNL DCSP self._views.push(lims) DCNL DCSP self._positions.push(pos) DCNL DCSP self.set_history_buttons()
def release(self, event): DCNL DCSP pass
def release_pan(self, event): DCNL DCSP self.canvas.mpl_disconnect(self._idDrag) DCNL DCSP self._idDrag = self.canvas.mpl_connect('motion_notify_event', self.mouse_move) DCNL DCSP for (a, ind) in self._xypress: DCNL DCSP  DCSP a.end_pan() DCNL DCSP if (not self._xypress): DCNL DCSP  DCSP return DCNL DCSP self._xypress = [] DCNL DCSP self._button_pressed = None DCNL DCSP self.push_current() DCNL DCSP self.release(event) DCNL DCSP self.draw()
def drag_pan(self, event): DCNL DCSP for (a, ind) in self._xypress: DCNL DCSP  DCSP a.drag_pan(self._button_pressed, event.key, event.x, event.y) DCNL DCSP self.dynamic_update()
def release_zoom(self, event): DCNL DCSP if (not self._xypress): DCNL DCSP  DCSP return DCNL DCSP last_a = [] DCNL DCSP for cur_xypress in self._xypress: DCNL DCSP  DCSP (x, y) = (event.x, event.y) DCNL DCSP  DCSP (lastx, lasty, a, ind, lim, trans) = cur_xypress DCNL DCSP  DCSP if ((abs((x - lastx)) < 5) or (abs((y - lasty)) < 5)): DCNL DCSP  DCSP  DCSP self._xypress = None DCNL DCSP  DCSP  DCSP self.release(event) DCNL DCSP  DCSP  DCSP self.draw() DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP (x0, y0, x1, y1) = lim.extents DCNL DCSP  DCSP inverse = a.transData.inverted() DCNL DCSP  DCSP (lastx, lasty) = inverse.transform_point((lastx, lasty)) DCNL DCSP  DCSP (x, y) = inverse.transform_point((x, y)) DCNL DCSP  DCSP (Xmin, Xmax) = a.get_xlim() DCNL DCSP  DCSP (Ymin, Ymax) = a.get_ylim() DCNL DCSP  DCSP (twinx, twiny) = (False, False) DCNL DCSP  DCSP if last_a: DCNL DCSP  DCSP  DCSP for la in last_a: DCNL DCSP  DCSP  DCSP  DCSP if a.get_shared_x_axes().joined(a, la): DCNL DCSP  DCSP  DCSP  DCSP  DCSP twinx = True DCNL DCSP  DCSP  DCSP  DCSP if a.get_shared_y_axes().joined(a, la): DCNL DCSP  DCSP  DCSP  DCSP  DCSP twiny = True DCNL DCSP  DCSP last_a.append(a) DCNL DCSP  DCSP if twinx: DCNL DCSP  DCSP  DCSP (x0, x1) = (Xmin, Xmax) DCNL DCSP  DCSP elif (Xmin < Xmax): DCNL DCSP  DCSP  DCSP if (x < lastx): DCNL DCSP  DCSP  DCSP  DCSP (x0, x1) = (x, lastx) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (x0, x1) = (lastx, x) DCNL DCSP  DCSP  DCSP if (x0 < Xmin): DCNL DCSP  DCSP  DCSP  DCSP x0 = Xmin DCNL DCSP  DCSP  DCSP if (x1 > Xmax): DCNL DCSP  DCSP  DCSP  DCSP x1 = Xmax DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (x > lastx): DCNL DCSP  DCSP  DCSP  DCSP (x0, x1) = (x, lastx) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (x0, x1) = (lastx, x) DCNL DCSP  DCSP  DCSP if (x0 > Xmin): DCNL DCSP  DCSP  DCSP  DCSP x0 = Xmin DCNL DCSP  DCSP  DCSP if (x1 < Xmax): DCNL DCSP  DCSP  DCSP  DCSP x1 = Xmax DCNL DCSP  DCSP if twiny: DCNL DCSP  DCSP  DCSP (y0, y1) = (Ymin, Ymax) DCNL DCSP  DCSP elif (Ymin < Ymax): DCNL DCSP  DCSP  DCSP if (y < lasty): DCNL DCSP  DCSP  DCSP  DCSP (y0, y1) = (y, lasty) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (y0, y1) = (lasty, y) DCNL DCSP  DCSP  DCSP if (y0 < Ymin): DCNL DCSP  DCSP  DCSP  DCSP y0 = Ymin DCNL DCSP  DCSP  DCSP if (y1 > Ymax): DCNL DCSP  DCSP  DCSP  DCSP y1 = Ymax DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (y > lasty): DCNL DCSP  DCSP  DCSP  DCSP (y0, y1) = (y, lasty) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (y0, y1) = (lasty, y) DCNL DCSP  DCSP  DCSP if (y0 > Ymin): DCNL DCSP  DCSP  DCSP  DCSP y0 = Ymin DCNL DCSP  DCSP  DCSP if (y1 < Ymax): DCNL DCSP  DCSP  DCSP  DCSP y1 = Ymax DCNL DCSP  DCSP if (self._button_pressed == 1): DCNL DCSP  DCSP  DCSP a.set_xlim((x0, x1)) DCNL DCSP  DCSP  DCSP a.set_ylim((y0, y1)) DCNL DCSP  DCSP elif (self._button_pressed == 3): DCNL DCSP  DCSP  DCSP if (a.get_xscale() == 'log'): DCNL DCSP  DCSP  DCSP  DCSP alpha = (np.log((Xmax / Xmin)) / np.log((x1 / x0))) DCNL DCSP  DCSP  DCSP  DCSP rx1 = (pow((Xmin / x0), alpha) * Xmin) DCNL DCSP  DCSP  DCSP  DCSP rx2 = (pow((Xmax / x0), alpha) * Xmin) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP alpha = ((Xmax - Xmin) / (x1 - x0)) DCNL DCSP  DCSP  DCSP  DCSP rx1 = ((alpha * (Xmin - x0)) + Xmin) DCNL DCSP  DCSP  DCSP  DCSP rx2 = ((alpha * (Xmax - x0)) + Xmin) DCNL DCSP  DCSP  DCSP if (a.get_yscale() == 'log'): DCNL DCSP  DCSP  DCSP  DCSP alpha = (np.log((Ymax / Ymin)) / np.log((y1 / y0))) DCNL DCSP  DCSP  DCSP  DCSP ry1 = (pow((Ymin / y0), alpha) * Ymin) DCNL DCSP  DCSP  DCSP  DCSP ry2 = (pow((Ymax / y0), alpha) * Ymin) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP alpha = ((Ymax - Ymin) / (y1 - y0)) DCNL DCSP  DCSP  DCSP  DCSP ry1 = ((alpha * (Ymin - y0)) + Ymin) DCNL DCSP  DCSP  DCSP  DCSP ry2 = ((alpha * (Ymax - y0)) + Ymin) DCNL DCSP  DCSP  DCSP a.set_xlim((rx1, rx2)) DCNL DCSP  DCSP  DCSP a.set_ylim((ry1, ry2)) DCNL DCSP self.draw() DCNL DCSP self._xypress = None DCNL DCSP self._button_pressed = None DCNL DCSP self.push_current() DCNL DCSP self.release(event)
def draw(self): DCNL DCSP for a in self.canvas.figure.get_axes(): DCNL DCSP  DCSP xaxis = getattr(a, 'xaxis', None) DCNL DCSP  DCSP yaxis = getattr(a, 'yaxis', None) DCNL DCSP  DCSP locators = [] DCNL DCSP  DCSP if (xaxis is not None): DCNL DCSP  DCSP  DCSP locators.append(xaxis.get_major_locator()) DCNL DCSP  DCSP  DCSP locators.append(xaxis.get_minor_locator()) DCNL DCSP  DCSP if (yaxis is not None): DCNL DCSP  DCSP  DCSP locators.append(yaxis.get_major_locator()) DCNL DCSP  DCSP  DCSP locators.append(yaxis.get_minor_locator()) DCNL DCSP  DCSP for loc in locators: DCNL DCSP  DCSP  DCSP loc.refresh() DCNL DCSP self.canvas.draw()
def _update_view(self): DCNL DCSP lims = self._views() DCNL DCSP if (lims is None): DCNL DCSP  DCSP return DCNL DCSP pos = self._positions() DCNL DCSP if (pos is None): DCNL DCSP  DCSP return DCNL DCSP for (i, a) in enumerate(self.canvas.figure.get_axes()): DCNL DCSP  DCSP (xmin, xmax, ymin, ymax) = lims[i] DCNL DCSP  DCSP a.set_xlim((xmin, xmax)) DCNL DCSP  DCSP a.set_ylim((ymin, ymax)) DCNL DCSP  DCSP a.set_position(pos[i][0], 'original') DCNL DCSP  DCSP a.set_position(pos[i][1], 'active') DCNL DCSP self.draw()
def save_figure(self, *args): DCNL DCSP raise NotImplementedError
def set_cursor(self, cursor): DCNL DCSP pass
def update(self): DCNL DCSP self._views.clear() DCNL DCSP self._positions.clear() DCNL DCSP self.set_history_buttons()
def zoom(self, *args): DCNL DCSP if (self._active == 'ZOOM'): DCNL DCSP  DCSP self._active = None DCNL DCSP else: DCNL DCSP  DCSP self._active = 'ZOOM' DCNL DCSP if (self._idPress is not None): DCNL DCSP  DCSP self._idPress = self.canvas.mpl_disconnect(self._idPress) DCNL DCSP  DCSP self.mode = '' DCNL DCSP if (self._idRelease is not None): DCNL DCSP  DCSP self._idRelease = self.canvas.mpl_disconnect(self._idRelease) DCNL DCSP  DCSP self.mode = '' DCNL DCSP if self._active: DCNL DCSP  DCSP self._idPress = self.canvas.mpl_connect('button_press_event', self.press_zoom) DCNL DCSP  DCSP self._idRelease = self.canvas.mpl_connect('button_release_event', self.release_zoom) DCNL DCSP  DCSP self.mode = 'Zoom DCSP to DCSP rect DCSP mode' DCNL DCSP  DCSP self.canvas.widgetlock(self) DCNL DCSP else: DCNL DCSP  DCSP self.canvas.widgetlock.release(self) DCNL DCSP for a in self.canvas.figure.get_axes(): DCNL DCSP  DCSP a.set_navigate_mode(self._active) DCNL DCSP self.set_message(self.mode)
def set_history_buttons(self): DCNL DCSP pass
def draw_all(self): DCNL DCSP self._process_values() DCNL DCSP self._find_range() DCNL DCSP (X, Y) = self._mesh() DCNL DCSP C = self._values[:, np.newaxis] DCNL DCSP self._config_axes(X, Y) DCNL DCSP if self.filled: DCNL DCSP  DCSP self._add_solids(X, Y, C) DCNL DCSP self._set_label()
def _config_axes(self, X, Y): DCNL DCSP ax = self.ax DCNL DCSP ax.set_frame_on(False) DCNL DCSP ax.set_navigate(False) DCNL DCSP xy = self._outline(X, Y) DCNL DCSP ax.update_datalim(xy) DCNL DCSP ax.set_xlim(*ax.dataLim.intervalx) DCNL DCSP ax.set_ylim(*ax.dataLim.intervaly) DCNL DCSP self.outline = lines.Line2D(xy[:, 0], xy[:, 1], color=mpl.rcParams['axes.edgecolor'], linewidth=mpl.rcParams['axes.linewidth']) DCNL DCSP ax.add_artist(self.outline) DCNL DCSP self.outline.set_clip_box(None) DCNL DCSP self.outline.set_clip_path(None) DCNL DCSP c = mpl.rcParams['axes.facecolor'] DCNL DCSP self.patch = patches.Polygon(xy, edgecolor=c, facecolor=c, linewidth=0.01, zorder=(-1)) DCNL DCSP ax.add_artist(self.patch) DCNL DCSP (ticks, ticklabels, offset_string) = self._ticker() DCNL DCSP if (self.orientation == 'vertical'): DCNL DCSP  DCSP ax.set_xticks([]) DCNL DCSP  DCSP ax.yaxis.set_label_position('right') DCNL DCSP  DCSP ax.yaxis.set_ticks_position('right') DCNL DCSP  DCSP ax.set_yticks(ticks) DCNL DCSP  DCSP ax.set_yticklabels(ticklabels) DCNL DCSP  DCSP ax.yaxis.get_major_formatter().set_offset_string(offset_string) DCNL DCSP else: DCNL DCSP  DCSP ax.set_yticks([]) DCNL DCSP  DCSP ax.xaxis.set_label_position('bottom') DCNL DCSP  DCSP ax.set_xticks(ticks) DCNL DCSP  DCSP ax.set_xticklabels(ticklabels) DCNL DCSP  DCSP ax.xaxis.get_major_formatter().set_offset_string(offset_string)
def set_label(self, label, **kw): DCNL DCSP self._label = label DCNL DCSP self._labelkw = kw DCNL DCSP self._set_label()
def _outline(self, X, Y): DCNL DCSP N = X.shape[0] DCNL DCSP ii = [0, 1, (N - 2), (N - 1), ((2 * N) - 1), ((2 * N) - 2), (N + 1), N, 0] DCNL DCSP x = np.take(np.ravel(np.transpose(X)), ii) DCNL DCSP y = np.take(np.ravel(np.transpose(Y)), ii) DCNL DCSP x = x.reshape((len(x), 1)) DCNL DCSP y = y.reshape((len(y), 1)) DCNL DCSP if (self.orientation == 'horizontal'): DCNL DCSP  DCSP return np.hstack((y, x)) DCNL DCSP return np.hstack((x, y))
def _edges(self, X, Y): DCNL DCSP N = X.shape[0] DCNL DCSP if (self.orientation == 'vertical'): DCNL DCSP  DCSP return [zip(X[i], Y[i]) for i in range(1, (N - 1))] DCNL DCSP else: DCNL DCSP  DCSP return [zip(Y[i], X[i]) for i in range(1, (N - 1))]
def _add_solids(self, X, Y, C): DCNL DCSP if (self.orientation == 'vertical'): DCNL DCSP  DCSP args = (X, Y, C) DCNL DCSP else: DCNL DCSP  DCSP args = (np.transpose(Y), np.transpose(X), np.transpose(C)) DCNL DCSP kw = {'cmap': self.cmap, 'norm': self.norm, 'shading': 'flat', 'alpha': self.alpha} DCNL DCSP _hold = self.ax.ishold() DCNL DCSP self.ax.hold(True) DCNL DCSP col = self.ax.pcolor(*args, **kw) DCNL DCSP self.ax.hold(_hold) DCNL DCSP self.solids = col DCNL DCSP if self.drawedges: DCNL DCSP  DCSP self.dividers = collections.LineCollection(self._edges(X, Y), colors=(mpl.rcParams['axes.edgecolor'],), linewidths=((0.5 * mpl.rcParams['axes.linewidth']),)) DCNL DCSP  DCSP self.ax.add_collection(self.dividers)
def add_lines(self, levels, colors, linewidths): DCNL DCSP N = len(levels) DCNL DCSP (dummy, y) = self._locate(levels) DCNL DCSP if (len(y) != N): DCNL DCSP  DCSP raise ValueError('levels DCSP are DCSP outside DCSP colorbar DCSP range') DCNL DCSP x = np.array([0.0, 1.0]) DCNL DCSP (X, Y) = np.meshgrid(x, y) DCNL DCSP if (self.orientation == 'vertical'): DCNL DCSP  DCSP xy = [zip(X[i], Y[i]) for i in range(N)] DCNL DCSP else: DCNL DCSP  DCSP xy = [zip(Y[i], X[i]) for i in range(N)] DCNL DCSP col = collections.LineCollection(xy, linewidths=linewidths) DCNL DCSP self.lines = col DCNL DCSP col.set_color(colors) DCNL DCSP self.ax.add_collection(col)
def _ticker(self): DCNL DCSP locator = self.locator DCNL DCSP formatter = self.formatter DCNL DCSP if (locator is None): DCNL DCSP  DCSP if (self.boundaries is None): DCNL DCSP  DCSP  DCSP if isinstance(self.norm, colors.NoNorm): DCNL DCSP  DCSP  DCSP  DCSP nv = len(self._values) DCNL DCSP  DCSP  DCSP  DCSP base = (1 + int((nv / 10))) DCNL DCSP  DCSP  DCSP  DCSP locator = ticker.IndexLocator(base=base, offset=0) DCNL DCSP  DCSP  DCSP elif isinstance(self.norm, colors.BoundaryNorm): DCNL DCSP  DCSP  DCSP  DCSP b = self.norm.boundaries DCNL DCSP  DCSP  DCSP  DCSP locator = ticker.FixedLocator(b, nbins=10) DCNL DCSP  DCSP  DCSP elif isinstance(self.norm, colors.LogNorm): DCNL DCSP  DCSP  DCSP  DCSP locator = ticker.LogLocator() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP locator = ticker.MaxNLocator() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP b = self._boundaries[self._inside] DCNL DCSP  DCSP  DCSP locator = ticker.FixedLocator(b, nbins=10) DCNL DCSP if isinstance(self.norm, colors.NoNorm): DCNL DCSP  DCSP intv = (self._values[0], self._values[(-1)]) DCNL DCSP else: DCNL DCSP  DCSP intv = (self.vmin, self.vmax) DCNL DCSP locator.create_dummy_axis() DCNL DCSP formatter.create_dummy_axis() DCNL DCSP locator.set_view_interval(*intv) DCNL DCSP locator.set_data_interval(*intv) DCNL DCSP formatter.set_view_interval(*intv) DCNL DCSP formatter.set_data_interval(*intv) DCNL DCSP b = np.array(locator()) DCNL DCSP (b, ticks) = self._locate(b) DCNL DCSP formatter.set_locs(b) DCNL DCSP ticklabels = [formatter(t, i) for (i, t) in enumerate(b)] DCNL DCSP offset_string = formatter.get_offset() DCNL DCSP return (ticks, ticklabels, offset_string)
def _process_values(self, b=None): DCNL DCSP if (b is None): DCNL DCSP  DCSP b = self.boundaries DCNL DCSP if (b is not None): DCNL DCSP  DCSP self._boundaries = np.asarray(b, dtype=float) DCNL DCSP  DCSP if (self.values is None): DCNL DCSP  DCSP  DCSP self._values = (0.5 * (self._boundaries[:(-1)] + self._boundaries[1:])) DCNL DCSP  DCSP  DCSP if isinstance(self.norm, colors.NoNorm): DCNL DCSP  DCSP  DCSP  DCSP self._values = (self._values + 1e-05).astype(np.int16) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP self._values = np.array(self.values) DCNL DCSP  DCSP return DCNL DCSP if (self.values is not None): DCNL DCSP  DCSP self._values = np.array(self.values) DCNL DCSP  DCSP if (self.boundaries is None): DCNL DCSP  DCSP  DCSP b = np.zeros((len(self.values) + 1), 'd') DCNL DCSP  DCSP  DCSP b[1:(-1)] = (0.5 * (self._values[:(-1)] - self._values[1:])) DCNL DCSP  DCSP  DCSP b[0] = ((2.0 * b[1]) - b[2]) DCNL DCSP  DCSP  DCSP b[(-1)] = ((2.0 * b[(-2)]) - b[(-3)]) DCNL DCSP  DCSP  DCSP self._boundaries = b DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP self._boundaries = np.array(self.boundaries) DCNL DCSP  DCSP return DCNL DCSP if isinstance(self.norm, colors.NoNorm): DCNL DCSP  DCSP b = ((self._uniform_y((self.cmap.N + 1)) * self.cmap.N) - 0.5) DCNL DCSP  DCSP v = np.zeros(((len(b) - 1),), dtype=np.int16) DCNL DCSP  DCSP v[self._inside] = np.arange(self.cmap.N, dtype=np.int16) DCNL DCSP  DCSP if (self.extend in ('both', 'min')): DCNL DCSP  DCSP  DCSP v[0] = (-1) DCNL DCSP  DCSP if (self.extend in ('both', 'max')): DCNL DCSP  DCSP  DCSP v[(-1)] = self.cmap.N DCNL DCSP  DCSP self._boundaries = b DCNL DCSP  DCSP self._values = v DCNL DCSP  DCSP return DCNL DCSP elif isinstance(self.norm, colors.BoundaryNorm): DCNL DCSP  DCSP b = list(self.norm.boundaries) DCNL DCSP  DCSP if (self.extend in ('both', 'min')): DCNL DCSP  DCSP  DCSP b = ([(b[0] - 1)] + b) DCNL DCSP  DCSP if (self.extend in ('both', 'max')): DCNL DCSP  DCSP  DCSP b = (b + [(b[(-1)] + 1)]) DCNL DCSP  DCSP b = np.array(b) DCNL DCSP  DCSP v = np.zeros(((len(b) - 1),), dtype=float) DCNL DCSP  DCSP bi = self.norm.boundaries DCNL DCSP  DCSP v[self._inside] = (0.5 * (bi[:(-1)] + bi[1:])) DCNL DCSP  DCSP if (self.extend in ('both', 'min')): DCNL DCSP  DCSP  DCSP v[0] = (b[0] - 1) DCNL DCSP  DCSP if (self.extend in ('both', 'max')): DCNL DCSP  DCSP  DCSP v[(-1)] = (b[(-1)] + 1) DCNL DCSP  DCSP self._boundaries = b DCNL DCSP  DCSP self._values = v DCNL DCSP  DCSP return DCNL DCSP else: DCNL DCSP  DCSP if (not self.norm.scaled()): DCNL DCSP  DCSP  DCSP self.norm.vmin = 0 DCNL DCSP  DCSP  DCSP self.norm.vmax = 1 DCNL DCSP  DCSP b = self.norm.inverse(self._uniform_y((self.cmap.N + 1))) DCNL DCSP  DCSP if (self.extend in ('both', 'min')): DCNL DCSP  DCSP  DCSP b[0] = (b[0] - 1) DCNL DCSP  DCSP if (self.extend in ('both', 'max')): DCNL DCSP  DCSP  DCSP b[(-1)] = (b[(-1)] + 1) DCNL DCSP self._process_values(b)
def _find_range(self): DCNL DCSP b = self._boundaries[self._inside] DCNL DCSP self.vmin = b[0] DCNL DCSP self.vmax = b[(-1)]
def _central_N(self): DCNL DCSP nb = len(self._boundaries) DCNL DCSP if (self.extend == 'both'): DCNL DCSP  DCSP nb -= 2 DCNL DCSP elif (self.extend in ('min', 'max')): DCNL DCSP  DCSP nb -= 1 DCNL DCSP return nb
def _extended_N(self): DCNL DCSP N = (self.cmap.N + 1) DCNL DCSP if (self.extend == 'both'): DCNL DCSP  DCSP N += 2 DCNL DCSP elif (self.extend in ('min', 'max')): DCNL DCSP  DCSP N += 1 DCNL DCSP return N
def _uniform_y(self, N): DCNL DCSP if (self.extend == 'neither'): DCNL DCSP  DCSP y = np.linspace(0, 1, N) DCNL DCSP else: DCNL DCSP  DCSP if (self.extend == 'both'): DCNL DCSP  DCSP  DCSP y = np.zeros((N + 2), 'd') DCNL DCSP  DCSP  DCSP y[0] = (-0.05) DCNL DCSP  DCSP  DCSP y[(-1)] = 1.05 DCNL DCSP  DCSP elif (self.extend == 'min'): DCNL DCSP  DCSP  DCSP y = np.zeros((N + 1), 'd') DCNL DCSP  DCSP  DCSP y[0] = (-0.05) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP y = np.zeros((N + 1), 'd') DCNL DCSP  DCSP  DCSP y[(-1)] = 1.05 DCNL DCSP  DCSP y[self._inside] = np.linspace(0, 1, N) DCNL DCSP return y
def _proportional_y(self): DCNL DCSP if isinstance(self.norm, colors.BoundaryNorm): DCNL DCSP  DCSP b = self._boundaries[self._inside] DCNL DCSP  DCSP y = (self._boundaries - self._boundaries[0]) DCNL DCSP  DCSP y = (y / (self._boundaries[(-1)] - self._boundaries[0])) DCNL DCSP else: DCNL DCSP  DCSP y = self.norm(self._boundaries.copy()) DCNL DCSP if (self.extend in ('both', 'min')): DCNL DCSP  DCSP y[0] = (-0.05) DCNL DCSP if (self.extend in ('both', 'max')): DCNL DCSP  DCSP y[(-1)] = 1.05 DCNL DCSP yi = y[self._inside] DCNL DCSP norm = colors.Normalize(yi[0], yi[(-1)]) DCNL DCSP y[self._inside] = norm(yi) DCNL DCSP return y
def _mesh(self): DCNL DCSP x = np.array([0.0, 1.0]) DCNL DCSP if (self.spacing == 'uniform'): DCNL DCSP  DCSP y = self._uniform_y(self._central_N()) DCNL DCSP else: DCNL DCSP  DCSP y = self._proportional_y() DCNL DCSP self._y = y DCNL DCSP (X, Y) = np.meshgrid(x, y) DCNL DCSP if (self.extend in ('min', 'both')): DCNL DCSP  DCSP X[0, :] = 0.5 DCNL DCSP if (self.extend in ('max', 'both')): DCNL DCSP  DCSP X[(-1), :] = 0.5 DCNL DCSP return (X, Y)
def _locate(self, x): DCNL DCSP if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)): DCNL DCSP  DCSP b = self._boundaries DCNL DCSP  DCSP xn = x DCNL DCSP  DCSP xout = x DCNL DCSP else: DCNL DCSP  DCSP b = self.norm(self._boundaries, clip=False).filled() DCNL DCSP  DCSP xn = self.norm(x, clip=False).filled() DCNL DCSP  DCSP in_cond = ((xn > (-0.001)) & (xn < 1.001)) DCNL DCSP  DCSP xn = np.compress(in_cond, xn) DCNL DCSP  DCSP xout = np.compress(in_cond, x) DCNL DCSP y = self._y DCNL DCSP N = len(b) DCNL DCSP ii = np.minimum(np.searchsorted(b, xn), (N - 1)) DCNL DCSP i0 = np.maximum((ii - 1), 0) DCNL DCSP db = (np.take(b, ii) - np.take(b, i0)) DCNL DCSP db = np.where((i0 == ii), 1.0, db) DCNL DCSP dy = (np.take(y, ii) - np.take(y, i0)) DCNL DCSP z = (np.take(y, i0) + (((xn - np.take(b, i0)) * dy) / db)) DCNL DCSP return (xout, z)
def add_lines(self, CS): DCNL DCSP if ((not isinstance(CS, contour.ContourSet)) or CS.filled): DCNL DCSP  DCSP raise ValueError('add_lines DCSP is DCSP only DCSP for DCSP a DCSP ContourSet DCSP of DCSP lines') DCNL DCSP tcolors = [c[0] for c in CS.tcolors] DCNL DCSP tlinewidths = [t[0] for t in CS.tlinewidths] DCNL DCSP ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths)
def update_bruteforce(self, mappable): DCNL DCSP self.ax.cla() DCNL DCSP self.draw_all() DCNL DCSP if isinstance(self.mappable, contour.ContourSet): DCNL DCSP  DCSP CS = self.mappable DCNL DCSP  DCSP if (not CS.filled): DCNL DCSP  DCSP  DCSP self.add_lines(CS)
def set_level(self, level): DCNL DCSP if (self._commandLineVerbose is not None): DCNL DCSP  DCSP level = self._commandLineVerbose DCNL DCSP if (level not in self.levels): DCNL DCSP  DCSP raise ValueError(('Illegal DCSP verbose DCSP string DCSP "%s". DCSP  DCSP Legal DCSP values DCSP are DCSP %s' % (level, self.levels))) DCNL DCSP self.level = level
def report(self, s, level='helpful'): DCNL DCSP if self.ge(level): DCNL DCSP  DCSP print >>self.fileo, s DCNL DCSP  DCSP return True DCNL DCSP return False
def wrap(self, fmt, func, level='helpful', always=True): DCNL DCSP assert callable(func) DCNL DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP ret = func(*args, **kwargs) DCNL DCSP  DCSP if (always or (not wrapper._spoke)): DCNL DCSP  DCSP  DCSP spoke = self.report((fmt % ret), level) DCNL DCSP  DCSP  DCSP if (not wrapper._spoke): DCNL DCSP  DCSP  DCSP  DCSP wrapper._spoke = spoke DCNL DCSP  DCSP return ret DCNL DCSP wrapper._spoke = False DCNL DCSP wrapper.__doc__ = func.__doc__ DCNL DCSP return wrapper
def ge(self, level): DCNL DCSP return (self.vald[self.level] >= self.vald[level])
def __init__(self, control_points): DCNL DCSP _o = len(control_points) DCNL DCSP self._orders = np.arange(_o) DCNL DCSP _coeff = BezierSegment._binom_coeff[(_o - 1)] DCNL DCSP _control_points = np.asarray(control_points) DCNL DCSP xx = _control_points[:, 0] DCNL DCSP yy = _control_points[:, 1] DCNL DCSP self._px = (xx * _coeff) DCNL DCSP self._py = (yy * _coeff)
def point_at_t(self, t): DCNL DCSP one_minus_t_powers = np.power((1.0 - t), self._orders)[::(-1)] DCNL DCSP t_powers = np.power(t, self._orders) DCNL DCSP tt = (one_minus_t_powers * t_powers) DCNL DCSP _x = sum((tt * self._px)) DCNL DCSP _y = sum((tt * self._py)) DCNL DCSP return (_x, _y)
def on_event(self, event): DCNL DCSP self.add_event(event) DCNL DCSP verbose.report(('Event DCSP %i' % len(self.events))) DCNL DCSP self.post_event() DCNL DCSP if ((len(self.events) >= self.n) and (self.n > 0)): DCNL DCSP  DCSP self.fig.canvas.stop_event_loop()
def post_event(self): DCNL DCSP pass
def cleanup(self): DCNL DCSP for cb in self.callbacks: DCNL DCSP  DCSP self.fig.canvas.mpl_disconnect(cb) DCNL DCSP self.callbacks = []
def add_event(self, event): DCNL DCSP self.events.append(event)
def pop_event(self, index=(-1)): DCNL DCSP self.events.pop(index)
def __call__(self, n=1, timeout=30): DCNL DCSP assert isinstance(n, int), 'Requires DCSP an DCSP integer DCSP argument' DCNL DCSP self.n = n DCNL DCSP self.events = [] DCNL DCSP self.callbacks = [] DCNL DCSP self.fig.show() DCNL DCSP for n in self.eventslist: DCNL DCSP  DCSP self.callbacks.append(self.fig.canvas.mpl_connect(n, self.on_event)) DCNL DCSP try: DCNL DCSP  DCSP self.fig.canvas.start_event_loop(timeout=timeout) DCNL DCSP finally: DCNL DCSP  DCSP self.cleanup() DCNL DCSP return self.events
def post_event(self): DCNL DCSP assert (len(self.events) > 0), 'No DCSP events DCSP yet' DCNL DCSP if (self.events[(-1)].name == 'key_press_event'): DCNL DCSP  DCSP self.key_event() DCNL DCSP else: DCNL DCSP  DCSP self.mouse_event()
def mouse_event(self): DCNL DCSP event = self.events[(-1)] DCNL DCSP button = event.button DCNL DCSP if (button == 3): DCNL DCSP  DCSP self.button3(event) DCNL DCSP elif (button == 2): DCNL DCSP  DCSP self.button2(event) DCNL DCSP else: DCNL DCSP  DCSP self.button1(event)
def key_event(self): DCNL DCSP event = self.events[(-1)] DCNL DCSP key = event.key DCNL DCSP if ((key == 'backspace') or (key == 'delete')): DCNL DCSP  DCSP self.button3(event) DCNL DCSP elif (key == 'enter'): DCNL DCSP  DCSP self.button2(event) DCNL DCSP else: DCNL DCSP  DCSP self.button1(event)
def button1(self, event): DCNL DCSP if event.inaxes: DCNL DCSP  DCSP self.add_click(event) DCNL DCSP else: DCNL DCSP  DCSP BlockingInput.pop(self)
def button2(self, event): DCNL DCSP BlockingInput.pop(self) DCNL DCSP self.fig.canvas.stop_event_loop()
def button3(self, event): DCNL DCSP BlockingInput.pop(self) DCNL DCSP if (len(self.events) > 0): DCNL DCSP  DCSP self.pop()
def add_click(self, event): DCNL DCSP self.clicks.append((event.xdata, event.ydata)) DCNL DCSP verbose.report(('input DCSP %i: DCSP %f,%f' % (len(self.clicks), event.xdata, event.ydata))) DCNL DCSP if self.show_clicks: DCNL DCSP  DCSP self.marks.extend(event.inaxes.plot([event.xdata], [event.ydata], 'r+')) DCNL DCSP  DCSP self.fig.canvas.draw()
def pop_click(self, index=(-1)): DCNL DCSP self.clicks.pop(index) DCNL DCSP if self.show_clicks: DCNL DCSP  DCSP mark = self.marks.pop(index) DCNL DCSP  DCSP mark.remove() DCNL DCSP  DCSP self.fig.canvas.draw()
def pop(self, index=(-1)): DCNL DCSP self.pop_click(index) DCNL DCSP BlockingInput.pop(self, index)
def __call__(self, n=1, timeout=30, show_clicks=True): DCNL DCSP self.show_clicks = show_clicks DCNL DCSP self.clicks = [] DCNL DCSP self.marks = [] DCNL DCSP BlockingInput.__call__(self, n=n, timeout=timeout) DCNL DCSP return self.clicks
def button1(self, event): DCNL DCSP cs = self.cs DCNL DCSP if (event.inaxes == cs.ax): DCNL DCSP  DCSP (conmin, segmin, imin, xmin, ymin) = cs.find_nearest_contour(event.x, event.y, cs.labelIndiceList)[:5] DCNL DCSP  DCSP lmin = cs.labelIndiceList.index(conmin) DCNL DCSP  DCSP paths = cs.collections[conmin].get_paths() DCNL DCSP  DCSP lc = paths[segmin].vertices DCNL DCSP  DCSP slc = cs.ax.transData.transform(lc) DCNL DCSP  DCSP lw = cs.get_label_width(cs.labelLevelList[lmin], cs.labelFmt, cs.labelFontSizeList[lmin]) DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP requires DCSP python DCSP 2.5\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Figure DCSP out DCSP label DCSP rotation.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rotation,nlc DCSP = DCSP cs.calc_label_rot_and_inline(\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP slc, DCSP imin, DCSP lw, DCSP lc DCSP if DCSP self.inline DCSP else DCSP [],\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.inline_spacing DCSP )\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if self.inline: DCNL DCSP  DCSP  DCSP lcarg = lc DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lcarg = None DCNL DCSP  DCSP (rotation, nlc) = cs.calc_label_rot_and_inline(slc, imin, lw, lcarg, self.inline_spacing) DCNL DCSP  DCSP cs.add_label(xmin, ymin, rotation, cs.labelLevelList[lmin], cs.labelCValueList[lmin]) DCNL DCSP  DCSP if self.inline: DCNL DCSP  DCSP  DCSP paths.pop(segmin) DCNL DCSP  DCSP  DCSP for n in nlc: DCNL DCSP  DCSP  DCSP  DCSP if (len(n) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP paths.append(path.Path(n)) DCNL DCSP  DCSP self.fig.canvas.draw() DCNL DCSP else: DCNL DCSP  DCSP BlockingInput.pop(self)
def button3(self, event): DCNL DCSP BlockingInput.pop(self) DCNL DCSP if self.inline: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP self.cs.pop_label() DCNL DCSP  DCSP self.cs.ax.figure.canvas.draw()
def post_event(self): DCNL DCSP assert (len(self.events) > 0), 'No DCSP events DCSP yet' DCNL DCSP self.keyormouse = (self.events[(-1)].name == 'key_press_event')
def __call__(self, timeout=30): DCNL DCSP self.keyormouse = None DCNL DCSP BlockingInput.__call__(self, n=1, timeout=timeout) DCNL DCSP return self.keyormouse
def __init__(self, vertices, codes=None): DCNL DCSP if ma.isMaskedArray(vertices): DCNL DCSP  DCSP vertices = vertices.astype(np.float_).filled(np.nan) DCNL DCSP else: DCNL DCSP  DCSP vertices = np.asarray(vertices, np.float_) DCNL DCSP if (codes is not None): DCNL DCSP  DCSP codes = np.asarray(codes, self.code_type) DCNL DCSP  DCSP assert (codes.ndim == 1) DCNL DCSP  DCSP assert (len(codes) == len(vertices)) DCNL DCSP assert (vertices.ndim == 2) DCNL DCSP assert (vertices.shape[1] == 2) DCNL DCSP self.should_simplify = ((len(vertices) >= 128) and ((codes is None) or np.all((codes <= Path.LINETO)))) DCNL DCSP self.has_nonfinite = (not np.isfinite(vertices).all()) DCNL DCSP self.codes = codes DCNL DCSP self.vertices = vertices
def make_compound_path(*args): DCNL DCSP for p in args: DCNL DCSP  DCSP assert (p.codes is None) DCNL DCSP lengths = [len(x) for x in args] DCNL DCSP total_length = sum(lengths) DCNL DCSP vertices = np.vstack([x.vertices for x in args]) DCNL DCSP vertices.reshape((total_length, 2)) DCNL DCSP codes = (Path.LINETO * np.ones(total_length)) DCNL DCSP i = 0 DCNL DCSP for length in lengths: DCNL DCSP  DCSP codes[i] = Path.MOVETO DCNL DCSP  DCSP i += length DCNL DCSP return Path(vertices, codes)
def iter_segments(self, simplify=None): DCNL DCSP vertices = self.vertices DCNL DCSP if (not len(vertices)): DCNL DCSP  DCSP return DCNL DCSP codes = self.codes DCNL DCSP len_vertices = len(vertices) DCNL DCSP isfinite = np.isfinite DCNL DCSP NUM_VERTICES = self.NUM_VERTICES DCNL DCSP MOVETO = self.MOVETO DCNL DCSP LINETO = self.LINETO DCNL DCSP CLOSEPOLY = self.CLOSEPOLY DCNL DCSP STOP = self.STOP DCNL DCSP if ((simplify is not None) and self.should_simplify): DCNL DCSP  DCSP polygons = self.to_polygons(None, *simplify) DCNL DCSP  DCSP for vertices in polygons: DCNL DCSP  DCSP  DCSP (yield (vertices[0], MOVETO)) DCNL DCSP  DCSP  DCSP for v in vertices[1:]: DCNL DCSP  DCSP  DCSP  DCSP (yield (v, LINETO)) DCNL DCSP elif (codes is None): DCNL DCSP  DCSP if self.has_nonfinite: DCNL DCSP  DCSP  DCSP next_code = MOVETO DCNL DCSP  DCSP  DCSP for v in vertices: DCNL DCSP  DCSP  DCSP  DCSP if np.isfinite(v).all(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (v, next_code)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP next_code = LINETO DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP next_code = MOVETO DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield (vertices[0], MOVETO)) DCNL DCSP  DCSP  DCSP for v in vertices[1:]: DCNL DCSP  DCSP  DCSP  DCSP (yield (v, LINETO)) DCNL DCSP else: DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP was_nan = False DCNL DCSP  DCSP while (i < len_vertices): DCNL DCSP  DCSP  DCSP code = codes[i] DCNL DCSP  DCSP  DCSP if (code == CLOSEPOLY): DCNL DCSP  DCSP  DCSP  DCSP (yield ([], code)) DCNL DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP elif (code == STOP): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP num_vertices = NUM_VERTICES[int(code)] DCNL DCSP  DCSP  DCSP  DCSP curr_vertices = vertices[i:(i + num_vertices)].flatten() DCNL DCSP  DCSP  DCSP  DCSP if (not isfinite(curr_vertices).all()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP was_nan = True DCNL DCSP  DCSP  DCSP  DCSP elif was_nan: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (curr_vertices[(-2):], MOVETO)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP was_nan = False DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (curr_vertices, code)) DCNL DCSP  DCSP  DCSP  DCSP i += num_vertices
def transformed(self, transform): DCNL DCSP return Path(transform.transform(self.vertices), self.codes)
def contains_point(self, point, transform=None): DCNL DCSP if (transform is not None): DCNL DCSP  DCSP transform = transform.frozen() DCNL DCSP return point_in_path(point[0], point[1], self, transform)
def contains_path(self, path, transform=None): DCNL DCSP if (transform is not None): DCNL DCSP  DCSP transform = transform.frozen() DCNL DCSP return path_in_path(self, None, path, transform)
def get_extents(self, transform=None): DCNL DCSP from transforms import Bbox DCNL DCSP if (transform is not None): DCNL DCSP  DCSP transform = transform.frozen() DCNL DCSP return Bbox(get_path_extents(self, transform))
def intersects_path(self, other, filled=True): DCNL DCSP return path_intersects_path(self, other, filled)
def intersects_bbox(self, bbox, filled=True): DCNL DCSP from transforms import BboxTransformTo DCNL DCSP rectangle = self.unit_rectangle().transformed(BboxTransformTo(bbox)) DCNL DCSP result = self.intersects_path(rectangle, filled) DCNL DCSP return result
def interpolated(self, steps): DCNL DCSP vertices = simple_linear_interpolation(self.vertices, steps) DCNL DCSP codes = self.codes DCNL DCSP if (codes is not None): DCNL DCSP  DCSP new_codes = (Path.LINETO * np.ones(((((len(codes) - 1) * steps) + 1),))) DCNL DCSP  DCSP new_codes[0::steps] = codes DCNL DCSP else: DCNL DCSP  DCSP new_codes = None DCNL DCSP return Path(vertices, new_codes)
def to_polygons(self, transform=None, width=0, height=0): DCNL DCSP if (len(self.vertices) == 0): DCNL DCSP  DCSP return [] DCNL DCSP if (transform is not None): DCNL DCSP  DCSP transform = transform.frozen() DCNL DCSP if ((self.codes is None) and ((width == 0) or (height == 0))): DCNL DCSP  DCSP if (transform is None): DCNL DCSP  DCSP  DCSP return [self.vertices] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return [transform.transform(self.vertices)] DCNL DCSP return convert_path_to_polygons(self, transform, width, height)
def unit_rectangle(cls): DCNL DCSP if (cls._unit_rectangle is None): DCNL DCSP  DCSP cls._unit_rectangle = Path([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.0, 0.0]]) DCNL DCSP return cls._unit_rectangle
def unit_regular_polygon(cls, numVertices): DCNL DCSP if (numVertices <= 16): DCNL DCSP  DCSP path = cls._unit_regular_polygons.get(numVertices) DCNL DCSP else: DCNL DCSP  DCSP path = None DCNL DCSP if (path is None): DCNL DCSP  DCSP theta = (((2 * np.pi) / numVertices) * np.arange((numVertices + 1)).reshape(((numVertices + 1), 1))) DCNL DCSP  DCSP theta += (np.pi / 2.0) DCNL DCSP  DCSP verts = np.concatenate((np.cos(theta), np.sin(theta)), 1) DCNL DCSP  DCSP path = Path(verts) DCNL DCSP  DCSP cls._unit_regular_polygons[numVertices] = path DCNL DCSP return path
def unit_regular_star(cls, numVertices, innerCircle=0.5): DCNL DCSP if (numVertices <= 16): DCNL DCSP  DCSP path = cls._unit_regular_stars.get((numVertices, innerCircle)) DCNL DCSP else: DCNL DCSP  DCSP path = None DCNL DCSP if (path is None): DCNL DCSP  DCSP ns2 = (numVertices * 2) DCNL DCSP  DCSP theta = (((2 * np.pi) / ns2) * np.arange((ns2 + 1))) DCNL DCSP  DCSP theta += (np.pi / 2.0) DCNL DCSP  DCSP r = np.ones((ns2 + 1)) DCNL DCSP  DCSP r[1::2] = innerCircle DCNL DCSP  DCSP verts = np.vstack(((r * np.cos(theta)), (r * np.sin(theta)))).transpose() DCNL DCSP  DCSP path = Path(verts) DCNL DCSP  DCSP cls._unit_regular_polygons[(numVertices, innerCircle)] = path DCNL DCSP return path
def unit_regular_asterisk(cls, numVertices): DCNL DCSP return cls.unit_regular_star(numVertices, 0.0)
def unit_circle(cls): DCNL DCSP if (cls._unit_circle is None): DCNL DCSP  DCSP MAGIC = 0.2652031 DCNL DCSP  DCSP SQRTHALF = np.sqrt(0.5) DCNL DCSP  DCSP MAGIC45 = np.sqrt(((MAGIC * MAGIC) / 2.0)) DCNL DCSP  DCSP vertices = np.array([[0.0, (-1.0)], [MAGIC, (-1.0)], [(SQRTHALF - MAGIC45), ((- SQRTHALF) - MAGIC45)], [SQRTHALF, (- SQRTHALF)], [(SQRTHALF + MAGIC45), ((- SQRTHALF) + MAGIC45)], [1.0, (- MAGIC)], [1.0, 0.0], [1.0, MAGIC], [(SQRTHALF + MAGIC45), (SQRTHALF - MAGIC45)], [SQRTHALF, SQRTHALF], [(SQRTHALF - MAGIC45), (SQRTHALF + MAGIC45)], [MAGIC, 1.0], [0.0, 1.0], [(- MAGIC), 1.0], [((- SQRTHALF) + MAGIC45), (SQRTHALF + MAGIC45)], [(- SQRTHALF), SQRTHALF], [((- SQRTHALF) - MAGIC45), (SQRTHALF - MAGIC45)], [(-1.0), MAGIC], [(-1.0), 0.0], [(-1.0), (- MAGIC)], [((- SQRTHALF) - MAGIC45), ((- SQRTHALF) + MAGIC45)], [(- SQRTHALF), (- SQRTHALF)], [((- SQRTHALF) + MAGIC45), ((- SQRTHALF) - MAGIC45)], [(- MAGIC), (-1.0)], [0.0, (-1.0)], [0.0, (-1.0)]], np.float_) DCNL DCSP  DCSP codes = (cls.CURVE4 * np.ones(26)) DCNL DCSP  DCSP codes[0] = cls.MOVETO DCNL DCSP  DCSP codes[(-1)] = cls.CLOSEPOLY DCNL DCSP  DCSP cls._unit_circle = Path(vertices, codes) DCNL DCSP return cls._unit_circle
def arc(cls, theta1, theta2, n=None, is_wedge=False): DCNL DCSP theta1 *= (np.pi / 180.0) DCNL DCSP theta2 *= (np.pi / 180.0) DCNL DCSP twopi = (np.pi * 2.0) DCNL DCSP halfpi = (np.pi * 0.5) DCNL DCSP eta1 = np.arctan2(np.sin(theta1), np.cos(theta1)) DCNL DCSP eta2 = np.arctan2(np.sin(theta2), np.cos(theta2)) DCNL DCSP eta2 -= (twopi * np.floor(((eta2 - eta1) / twopi))) DCNL DCSP if (((theta2 - theta1) > np.pi) and ((eta2 - eta1) < np.pi)): DCNL DCSP  DCSP eta2 += twopi DCNL DCSP if (n is None): DCNL DCSP  DCSP n = int((2 ** np.ceil(((eta2 - eta1) / halfpi)))) DCNL DCSP if (n < 1): DCNL DCSP  DCSP raise ValueError('n DCSP must DCSP be DCSP >= DCSP 1 DCSP or DCSP None') DCNL DCSP deta = ((eta2 - eta1) / n) DCNL DCSP t = np.tan((0.5 * deta)) DCNL DCSP alpha = ((np.sin(deta) * (np.sqrt((4.0 + ((3.0 * t) * t))) - 1)) / 3.0) DCNL DCSP steps = np.linspace(eta1, eta2, (n + 1), True) DCNL DCSP cos_eta = np.cos(steps) DCNL DCSP sin_eta = np.sin(steps) DCNL DCSP xA = cos_eta[:(-1)] DCNL DCSP yA = sin_eta[:(-1)] DCNL DCSP xA_dot = (- yA) DCNL DCSP yA_dot = xA DCNL DCSP xB = cos_eta[1:] DCNL DCSP yB = sin_eta[1:] DCNL DCSP xB_dot = (- yB) DCNL DCSP yB_dot = xB DCNL DCSP if is_wedge: DCNL DCSP  DCSP length = ((n * 3) + 4) DCNL DCSP  DCSP vertices = np.zeros((length, 2), np.float_) DCNL DCSP  DCSP codes = (Path.CURVE4 * np.ones((length,), Path.code_type)) DCNL DCSP  DCSP vertices[1] = [xA[0], yA[0]] DCNL DCSP  DCSP codes[0:2] = [Path.MOVETO, Path.LINETO] DCNL DCSP  DCSP codes[(-2):] = [Path.LINETO, Path.CLOSEPOLY] DCNL DCSP  DCSP vertex_offset = 2 DCNL DCSP  DCSP end = (length - 2) DCNL DCSP else: DCNL DCSP  DCSP length = ((n * 3) + 1) DCNL DCSP  DCSP vertices = np.zeros((length, 2), np.float_) DCNL DCSP  DCSP codes = (Path.CURVE4 * np.ones((length,), Path.code_type)) DCNL DCSP  DCSP vertices[0] = [xA[0], yA[0]] DCNL DCSP  DCSP codes[0] = Path.MOVETO DCNL DCSP  DCSP vertex_offset = 1 DCNL DCSP  DCSP end = length DCNL DCSP vertices[vertex_offset:end:3, 0] = (xA + (alpha * xA_dot)) DCNL DCSP vertices[vertex_offset:end:3, 1] = (yA + (alpha * yA_dot)) DCNL DCSP vertices[(vertex_offset + 1):end:3, 0] = (xB - (alpha * xB_dot)) DCNL DCSP vertices[(vertex_offset + 1):end:3, 1] = (yB - (alpha * yB_dot)) DCNL DCSP vertices[(vertex_offset + 2):end:3, 0] = xB DCNL DCSP vertices[(vertex_offset + 2):end:3, 1] = yB DCNL DCSP return Path(vertices, codes)
def wedge(cls, theta1, theta2, n=None): DCNL DCSP return cls.arc(theta1, theta2, n, True)
def set_canvas_size(self, w, h, d): DCNL DCSP self.width = w DCNL DCSP self.height = h DCNL DCSP self.depth = d
def render_glyph(self, ox, oy, info): DCNL DCSP raise NotImplementedError()
def render_filled_rect(self, x1, y1, x2, y2): DCNL DCSP raise NotImplementedError()
def get_results(self, box): DCNL DCSP raise NotImplementedError()
def get_hinting_type(self): DCNL DCSP return LOAD_NO_HINTING
def __init__(self, default_font_prop, mathtext_backend): DCNL DCSP self.default_font_prop = default_font_prop DCNL DCSP self.mathtext_backend = mathtext_backend DCNL DCSP self.mathtext_backend.fonts_object = self DCNL DCSP self.used_characters = {}
def destroy(self): DCNL DCSP self.used_characters = None
def get_kern(self, font1, fontclass1, sym1, fontsize1, font2, fontclass2, sym2, fontsize2, dpi): DCNL DCSP return 0.0
def get_metrics(self, font, font_class, sym, fontsize, dpi): DCNL DCSP info = self._get_info(font, font_class, sym, fontsize, dpi) DCNL DCSP return info.metrics
def set_canvas_size(self, w, h, d): DCNL DCSP (self.width, self.height, self.depth) = (ceil(w), ceil(h), ceil(d)) DCNL DCSP self.mathtext_backend.set_canvas_size(self.width, self.height, self.depth)
def render_glyph(self, ox, oy, facename, font_class, sym, fontsize, dpi): DCNL DCSP info = self._get_info(facename, font_class, sym, fontsize, dpi) DCNL DCSP (realpath, stat_key) = get_realpath_and_stat(info.font.fname) DCNL DCSP used_characters = self.used_characters.setdefault(stat_key, (realpath, set())) DCNL DCSP used_characters[1].add(info.num) DCNL DCSP self.mathtext_backend.render_glyph(ox, oy, info)
def render_rect_filled(self, x1, y1, x2, y2): DCNL DCSP self.mathtext_backend.render_rect_filled(x1, y1, x2, y2)
def get_xheight(self, font, fontsize, dpi): DCNL DCSP raise NotImplementedError()
def get_underline_thickness(self, font, fontsize, dpi): DCNL DCSP raise NotImplementedError()
def get_used_characters(self): DCNL DCSP return self.used_characters
def get_results(self, box): DCNL DCSP return self.mathtext_backend.get_results(box)
def get_sized_alternatives_for_symbol(self, fontname, sym): DCNL DCSP return [(fontname, sym)]
def _get_info(self, fontname, font_class, sym, fontsize, dpi): DCNL DCSP key = (fontname, sym, fontsize, dpi) DCNL DCSP tup = self.glyphd.get(key) DCNL DCSP if (tup is not None): DCNL DCSP  DCSP return tup DCNL DCSP if ((fontname == 'it') and ((len(sym) > 1) or (not unicodedata.category(unicode(sym)).startswith('L')))): DCNL DCSP  DCSP fontname = 'rm' DCNL DCSP found_symbol = False DCNL DCSP if (sym in latex_to_standard): DCNL DCSP  DCSP (fontname, num) = latex_to_standard[sym] DCNL DCSP  DCSP glyph = chr(num) DCNL DCSP  DCSP found_symbol = True DCNL DCSP elif (len(sym) == 1): DCNL DCSP  DCSP glyph = sym DCNL DCSP  DCSP num = ord(glyph) DCNL DCSP  DCSP found_symbol = True DCNL DCSP else: DCNL DCSP  DCSP warn(("No DCSP TeX DCSP to DCSP built-in DCSP Postscript DCSP mapping DCSP for DCSP '%s'" % sym), MathTextWarning) DCNL DCSP slanted = (fontname == 'it') DCNL DCSP font = self._get_font(fontname) DCNL DCSP if found_symbol: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP symbol_name = font.get_name_char(glyph) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP warn(("No DCSP glyph DCSP in DCSP standard DCSP Postscript DCSP font DCSP '%s' DCSP for DCSP '%s'" % (font.postscript_name, sym)), MathTextWarning) DCNL DCSP  DCSP  DCSP found_symbol = False DCNL DCSP if (not found_symbol): DCNL DCSP  DCSP glyph = sym = '?' DCNL DCSP  DCSP num = ord(glyph) DCNL DCSP  DCSP symbol_name = font.get_name_char(glyph) DCNL DCSP offset = 0 DCNL DCSP scale = (0.001 * fontsize) DCNL DCSP (xmin, ymin, xmax, ymax) = [(val * scale) for val in font.get_bbox_char(glyph)] DCNL DCSP metrics = Bunch(advance=(font.get_width_char(glyph) * scale), width=(font.get_width_char(glyph) * scale), height=(font.get_height_char(glyph) * scale), xmin=xmin, xmax=xmax, ymin=(ymin + offset), ymax=(ymax + offset), iceberg=(ymax + offset), slanted=slanted) DCNL DCSP self.glyphd[key] = Bunch(font=font, fontsize=fontsize, postscript_name=font.get_fontname(), metrics=metrics, symbol_name=symbol_name, num=num, glyph=glyph, offset=offset) DCNL DCSP return self.glyphd[key]
def shrink(self): DCNL DCSP self.size += 1
def grow(self): DCNL DCSP self.size -= 1
def get_kerning(self, next): DCNL DCSP advance = (self._metrics.advance - self.width) DCNL DCSP kern = 0.0 DCNL DCSP if isinstance(next, Char): DCNL DCSP  DCSP kern = self.font_output.get_kern(self.font, self.font_class, self.c, self.fontsize, next.font, next.font_class, next.c, next.fontsize, self.dpi) DCNL DCSP return (advance + kern)
def render(self, x, y): DCNL DCSP self.font_output.render_glyph(x, y, self.font, self.font_class, self.c, self.fontsize, self.dpi)
def render(self, x, y): DCNL DCSP self.font_output.render_glyph((x - self._metrics.xmin), (y + self._metrics.ymin), self.font, self.font_class, self.c, self.fontsize, self.dpi)
def _determine_order(self, totals): DCNL DCSP o = 0 DCNL DCSP for i in range((len(totals) - 1), 0, (-1)): DCNL DCSP  DCSP if (totals[i] != 0.0): DCNL DCSP  DCSP  DCSP o = i DCNL DCSP  DCSP  DCSP break DCNL DCSP return o
def kern(self): DCNL DCSP new_children = [] DCNL DCSP num_children = len(self.children) DCNL DCSP if num_children: DCNL DCSP  DCSP for i in range(num_children): DCNL DCSP  DCSP  DCSP elem = self.children[i] DCNL DCSP  DCSP  DCSP if (i < (num_children - 1)): DCNL DCSP  DCSP  DCSP  DCSP next = self.children[(i + 1)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP next = None DCNL DCSP  DCSP  DCSP new_children.append(elem) DCNL DCSP  DCSP  DCSP kerning_distance = elem.get_kerning(next) DCNL DCSP  DCSP  DCSP if (kerning_distance != 0.0): DCNL DCSP  DCSP  DCSP  DCSP kern = Kern(kerning_distance) DCNL DCSP  DCSP  DCSP  DCSP new_children.append(kern) DCNL DCSP  DCSP self.children = new_children
def hpack(self, w=0.0, m='additional'): DCNL DCSP h = 0.0 DCNL DCSP d = 0.0 DCNL DCSP x = 0.0 DCNL DCSP total_stretch = ([0.0] * 4) DCNL DCSP total_shrink = ([0.0] * 4) DCNL DCSP for p in self.children: DCNL DCSP  DCSP if isinstance(p, Char): DCNL DCSP  DCSP  DCSP x += p.width DCNL DCSP  DCSP  DCSP h = max(h, p.height) DCNL DCSP  DCSP  DCSP d = max(d, p.depth) DCNL DCSP  DCSP elif isinstance(p, Box): DCNL DCSP  DCSP  DCSP x += p.width DCNL DCSP  DCSP  DCSP if ((not isinf(p.height)) and (not isinf(p.depth))): DCNL DCSP  DCSP  DCSP  DCSP s = getattr(p, 'shift_amount', 0.0) DCNL DCSP  DCSP  DCSP  DCSP h = max(h, (p.height - s)) DCNL DCSP  DCSP  DCSP  DCSP d = max(d, (p.depth + s)) DCNL DCSP  DCSP elif isinstance(p, Glue): DCNL DCSP  DCSP  DCSP glue_spec = p.glue_spec DCNL DCSP  DCSP  DCSP x += glue_spec.width DCNL DCSP  DCSP  DCSP total_stretch[glue_spec.stretch_order] += glue_spec.stretch DCNL DCSP  DCSP  DCSP total_shrink[glue_spec.shrink_order] += glue_spec.shrink DCNL DCSP  DCSP elif isinstance(p, Kern): DCNL DCSP  DCSP  DCSP x += p.width DCNL DCSP self.height = h DCNL DCSP self.depth = d DCNL DCSP if (m == 'additional'): DCNL DCSP  DCSP w += x DCNL DCSP self.width = w DCNL DCSP x = (w - x) DCNL DCSP if (x == 0.0): DCNL DCSP  DCSP self.glue_sign = 0 DCNL DCSP  DCSP self.glue_order = 0 DCNL DCSP  DCSP self.glue_ratio = 0.0 DCNL DCSP  DCSP return DCNL DCSP if (x > 0.0): DCNL DCSP  DCSP self._set_glue(x, 1, total_stretch, 'Overfull') DCNL DCSP else: DCNL DCSP  DCSP self._set_glue(x, (-1), total_shrink, 'Underfull')
def vpack(self, h=0.0, m='additional', l=float(inf)): DCNL DCSP w = 0.0 DCNL DCSP d = 0.0 DCNL DCSP x = 0.0 DCNL DCSP total_stretch = ([0.0] * 4) DCNL DCSP total_shrink = ([0.0] * 4) DCNL DCSP for p in self.children: DCNL DCSP  DCSP if isinstance(p, Box): DCNL DCSP  DCSP  DCSP x += (d + p.height) DCNL DCSP  DCSP  DCSP d = p.depth DCNL DCSP  DCSP  DCSP if (not isinf(p.width)): DCNL DCSP  DCSP  DCSP  DCSP s = getattr(p, 'shift_amount', 0.0) DCNL DCSP  DCSP  DCSP  DCSP w = max(w, (p.width + s)) DCNL DCSP  DCSP elif isinstance(p, Glue): DCNL DCSP  DCSP  DCSP x += d DCNL DCSP  DCSP  DCSP d = 0.0 DCNL DCSP  DCSP  DCSP glue_spec = p.glue_spec DCNL DCSP  DCSP  DCSP x += glue_spec.width DCNL DCSP  DCSP  DCSP total_stretch[glue_spec.stretch_order] += glue_spec.stretch DCNL DCSP  DCSP  DCSP total_shrink[glue_spec.shrink_order] += glue_spec.shrink DCNL DCSP  DCSP elif isinstance(p, Kern): DCNL DCSP  DCSP  DCSP x += (d + p.width) DCNL DCSP  DCSP  DCSP d = 0.0 DCNL DCSP  DCSP elif isinstance(p, Char): DCNL DCSP  DCSP  DCSP raise RuntimeError('Internal DCSP mathtext DCSP error: DCSP Char DCSP node DCSP found DCSP in DCSP Vlist.') DCNL DCSP self.width = w DCNL DCSP if (d > l): DCNL DCSP  DCSP x += (d - l) DCNL DCSP  DCSP self.depth = l DCNL DCSP else: DCNL DCSP  DCSP self.depth = d DCNL DCSP if (m == 'additional'): DCNL DCSP  DCSP h += x DCNL DCSP self.height = h DCNL DCSP x = (h - x) DCNL DCSP if (x == 0): DCNL DCSP  DCSP self.glue_sign = 0 DCNL DCSP  DCSP self.glue_order = 0 DCNL DCSP  DCSP self.glue_ratio = 0.0 DCNL DCSP  DCSP return DCNL DCSP if (x > 0.0): DCNL DCSP  DCSP self._set_glue(x, 1, total_stretch, 'Overfull') DCNL DCSP else: DCNL DCSP  DCSP self._set_glue(x, (-1), total_shrink, 'Underfull')
def clear(self): DCNL DCSP self._expr = None DCNL DCSP self._state_stack = None DCNL DCSP self._em_width_cache = {}
def parse(self, s, fonts_object, fontsize, dpi): DCNL DCSP self._state_stack = [self.State(fonts_object, 'default', 'rm', fontsize, dpi)] DCNL DCSP try: DCNL DCSP  DCSP self._expression.parseString(s) DCNL DCSP except ParseException as err: DCNL DCSP  DCSP raise ValueError('\n'.join(['', err.line, ((' DCSP ' * (err.column - 1)) + '^'), str(err)])) DCNL DCSP return self._expr
def get_state(self): DCNL DCSP return self._state_stack[(-1)]
def pop_state(self): DCNL DCSP self._state_stack.pop()
def push_state(self): DCNL DCSP self._state_stack.append(self.get_state().copy())
def __init__(self, output): DCNL DCSP self._output = output.lower() DCNL DCSP self._cache = maxdict(50)
def parse(self, s, dpi=72, prop=None): DCNL DCSP if (prop is None): DCNL DCSP  DCSP prop = FontProperties() DCNL DCSP cacheKey = (s, dpi, hash(prop)) DCNL DCSP result = self._cache.get(cacheKey) DCNL DCSP if (result is not None): DCNL DCSP  DCSP return result DCNL DCSP if ((self._output == 'ps') and rcParams['ps.useafm']): DCNL DCSP  DCSP font_output = StandardPsFonts(prop) DCNL DCSP else: DCNL DCSP  DCSP backend = self._backend_mapping[self._output]() DCNL DCSP  DCSP fontset = rcParams['mathtext.fontset'] DCNL DCSP  DCSP fontset_class = self._font_type_mapping.get(fontset.lower()) DCNL DCSP  DCSP if (fontset_class is not None): DCNL DCSP  DCSP  DCSP font_output = fontset_class(prop, backend) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError("mathtext.fontset DCSP must DCSP be DCSP either DCSP 'cm', DCSP 'stix', DCSP 'stixsans', DCSP or DCSP 'custom'") DCNL DCSP fontsize = prop.get_size_in_points() DCNL DCSP if (self._parser is None): DCNL DCSP  DCSP self.__class__._parser = Parser() DCNL DCSP box = self._parser.parse(s, font_output, fontsize, dpi) DCNL DCSP font_output.set_canvas_size(box.width, box.height, box.depth) DCNL DCSP result = font_output.get_results(box) DCNL DCSP self._cache[cacheKey] = result DCNL DCSP self._parser.clear() DCNL DCSP font_output.destroy() DCNL DCSP font_output.mathtext_backend.fonts_object = None DCNL DCSP font_output.mathtext_backend = None DCNL DCSP return result
def to_mask(self, texstr, dpi=120, fontsize=14): DCNL DCSP assert (self._output == 'bitmap') DCNL DCSP prop = FontProperties(size=fontsize) DCNL DCSP (ftimage, depth) = self.parse(texstr, dpi=dpi, prop=prop) DCNL DCSP x = ftimage.as_array() DCNL DCSP return (x, depth)
def to_rgba(self, texstr, color='black', dpi=120, fontsize=14): DCNL DCSP (x, depth) = self.to_mask(texstr, dpi=dpi, fontsize=fontsize) DCNL DCSP (r, g, b) = mcolors.colorConverter.to_rgb(color) DCNL DCSP RGBA = np.zeros((x.shape[0], x.shape[1], 4), dtype=np.uint8) DCNL DCSP RGBA[:, :, 0] = int((255 * r)) DCNL DCSP RGBA[:, :, 1] = int((255 * g)) DCNL DCSP RGBA[:, :, 2] = int((255 * b)) DCNL DCSP RGBA[:, :, 3] = x DCNL DCSP return (RGBA, depth)
def to_png(self, filename, texstr, color='black', dpi=120, fontsize=14): DCNL DCSP (rgba, depth) = self.to_rgba(texstr, color=color, dpi=dpi, fontsize=fontsize) DCNL DCSP (numrows, numcols, tmp) = rgba.shape DCNL DCSP _png.write_png(rgba.tostring(), numcols, numrows, filename) DCNL DCSP return depth
def get_depth(self, texstr, dpi=120, fontsize=14): DCNL DCSP assert (self._output == 'bitmap') DCNL DCSP prop = FontProperties(size=fontsize) DCNL DCSP (ftimage, depth) = self.parse(texstr, dpi=dpi, prop=prop) DCNL DCSP return depth
def to_rgb(self, arg): DCNL DCSP try: DCNL DCSP  DCSP return self.cache[arg] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP except TypeError: DCNL DCSP  DCSP arg = tuple(arg) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return self.cache[arg] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP raise ValueError(('to_rgb: DCSP arg DCSP "%s" DCSP is DCSP unhashable DCSP even DCSP inside DCSP a DCSP tuple' % (str(arg),))) DCNL DCSP try: DCNL DCSP  DCSP if cbook.is_string_like(arg): DCNL DCSP  DCSP  DCSP color = self.colors.get(arg, None) DCNL DCSP  DCSP  DCSP if (color is None): DCNL DCSP  DCSP  DCSP  DCSP str1 = cnames.get(arg, arg) DCNL DCSP  DCSP  DCSP  DCSP if str1.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP color = hex2color(str1) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fl = float(arg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((fl < 0) or (fl > 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('gray DCSP (string) DCSP must DCSP be DCSP in DCSP range DCSP 0-1') DCNL DCSP  DCSP  DCSP  DCSP  DCSP color = tuple(([fl] * 3)) DCNL DCSP  DCSP elif cbook.iterable(arg): DCNL DCSP  DCSP  DCSP if ((len(arg) > 4) or (len(arg) < 3)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('sequence DCSP length DCSP is DCSP %d; DCSP must DCSP be DCSP 3 DCSP or DCSP 4' % len(arg))) DCNL DCSP  DCSP  DCSP color = tuple(arg[:3]) DCNL DCSP  DCSP  DCSP if [x for x in color if ((float(x) < 0) or (x > 1))]: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('number DCSP in DCSP rbg DCSP sequence DCSP outside DCSP 0-1 DCSP range') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('cannot DCSP convert DCSP argument DCSP to DCSP rgb DCSP sequence') DCNL DCSP  DCSP self.cache[arg] = color DCNL DCSP except (KeyError, ValueError, TypeError) as exc: DCNL DCSP  DCSP raise ValueError(('to_rgb: DCSP Invalid DCSP rgb DCSP arg DCSP "%s"\n%s' % (str(arg), exc))) DCNL DCSP return color
def to_rgba(self, arg, alpha=None): DCNL DCSP try: DCNL DCSP  DCSP if ((not cbook.is_string_like(arg)) and cbook.iterable(arg)): DCNL DCSP  DCSP  DCSP if (len(arg) == 4): DCNL DCSP  DCSP  DCSP  DCSP if [x for x in arg if ((float(x) < 0) or (x > 1))]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('number DCSP in DCSP rbga DCSP sequence DCSP outside DCSP 0-1 DCSP range') DCNL DCSP  DCSP  DCSP  DCSP if (alpha is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return tuple(arg) DCNL DCSP  DCSP  DCSP  DCSP if ((alpha < 0.0) or (alpha > 1.0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('alpha DCSP must DCSP be DCSP in DCSP range DCSP 0-1') DCNL DCSP  DCSP  DCSP  DCSP return (arg[0], arg[1], arg[2], (arg[3] * alpha)) DCNL DCSP  DCSP  DCSP (r, g, b) = arg[:3] DCNL DCSP  DCSP  DCSP if [x for x in (r, g, b) if ((float(x) < 0) or (x > 1))]: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('number DCSP in DCSP rbg DCSP sequence DCSP outside DCSP 0-1 DCSP range') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (r, g, b) = self.to_rgb(arg) DCNL DCSP  DCSP if (alpha is None): DCNL DCSP  DCSP  DCSP alpha = 1.0 DCNL DCSP  DCSP return (r, g, b, alpha) DCNL DCSP except (TypeError, ValueError) as exc: DCNL DCSP  DCSP raise ValueError(('to_rgba: DCSP Invalid DCSP rgba DCSP arg DCSP "%s"\n%s' % (str(arg), exc)))
def to_rgba_array(self, c, alpha=None): DCNL DCSP try: DCNL DCSP  DCSP if (c.lower() == 'none'): DCNL DCSP  DCSP  DCSP return np.zeros((0, 4), dtype=np.float_) DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP if (len(c) == 0): DCNL DCSP  DCSP return np.zeros((0, 4), dtype=np.float_) DCNL DCSP try: DCNL DCSP  DCSP result = np.array([self.to_rgba(c, alpha)], dtype=np.float_) DCNL DCSP except ValueError: DCNL DCSP  DCSP if isinstance(c, np.ndarray): DCNL DCSP  DCSP  DCSP if ((c.ndim != 2) and (c.dtype.kind not in 'SU')): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Color DCSP array DCSP must DCSP be DCSP two-dimensional') DCNL DCSP  DCSP result = np.zeros((len(c), 4)) DCNL DCSP  DCSP for (i, cc) in enumerate(c): DCNL DCSP  DCSP  DCSP result[i] = self.to_rgba(cc, alpha) DCNL DCSP return np.asarray(result, np.float_)
def __init__(self, name, N=256): DCNL DCSP self.name = name DCNL DCSP self.N = N DCNL DCSP self._rgba_bad = (0.0, 0.0, 0.0, 0.0) DCNL DCSP self._rgba_under = None DCNL DCSP self._rgba_over = None DCNL DCSP self._i_under = N DCNL DCSP self._i_over = (N + 1) DCNL DCSP self._i_bad = (N + 2) DCNL DCSP self._isinit = False
def __call__(self, X, alpha=1.0, bytes=False): DCNL DCSP if (not self._isinit): DCNL DCSP  DCSP self._init() DCNL DCSP alpha = min(alpha, 1.0) DCNL DCSP alpha = max(alpha, 0.0) DCNL DCSP self._lut[:(-3), (-1)] = alpha DCNL DCSP mask_bad = None DCNL DCSP if (not cbook.iterable(X)): DCNL DCSP  DCSP vtype = 'scalar' DCNL DCSP  DCSP xa = np.array([X]) DCNL DCSP else: DCNL DCSP  DCSP vtype = 'array' DCNL DCSP  DCSP xma = ma.asarray(X) DCNL DCSP  DCSP xa = xma.filled(0) DCNL DCSP  DCSP mask_bad = ma.getmask(xma) DCNL DCSP if (xa.dtype.char in np.typecodes['Float']): DCNL DCSP  DCSP np.putmask(xa, (xa == 1.0), 0.9999999) DCNL DCSP  DCSP if NP_CLIP_OUT: DCNL DCSP  DCSP  DCSP np.clip((xa * self.N), (-1), self.N, out=xa) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xa = np.clip((xa * self.N), (-1), self.N) DCNL DCSP  DCSP xa = xa.astype(int) DCNL DCSP np.putmask(xa, (xa > (self.N - 1)), self._i_over) DCNL DCSP np.putmask(xa, (xa < 0), self._i_under) DCNL DCSP if ((mask_bad is not None) and (mask_bad.shape == xa.shape)): DCNL DCSP  DCSP np.putmask(xa, mask_bad, self._i_bad) DCNL DCSP if bytes: DCNL DCSP  DCSP lut = (self._lut * 255).astype(np.uint8) DCNL DCSP else: DCNL DCSP  DCSP lut = self._lut DCNL DCSP rgba = np.empty(shape=(xa.shape + (4,)), dtype=lut.dtype) DCNL DCSP lut.take(xa, axis=0, mode='clip', out=rgba) DCNL DCSP if (vtype == 'scalar'): DCNL DCSP  DCSP rgba = tuple(rgba[0, :]) DCNL DCSP return rgba
def set_bad(self, color='k', alpha=1.0): DCNL DCSP self._rgba_bad = colorConverter.to_rgba(color, alpha) DCNL DCSP if self._isinit: DCNL DCSP  DCSP self._set_extremes()
def set_under(self, color='k', alpha=1.0): DCNL DCSP self._rgba_under = colorConverter.to_rgba(color, alpha) DCNL DCSP if self._isinit: DCNL DCSP  DCSP self._set_extremes()
def set_over(self, color='k', alpha=1.0): DCNL DCSP self._rgba_over = colorConverter.to_rgba(color, alpha) DCNL DCSP if self._isinit: DCNL DCSP  DCSP self._set_extremes()
def _init(): DCNL DCSP raise NotImplementedError('Abstract DCSP class DCSP only')
def __init__(self, name, segmentdata, N=256): DCNL DCSP self.monochrome = False DCNL DCSP Colormap.__init__(self, name, N) DCNL DCSP self._segmentdata = segmentdata
def __init__(self, colors, name='from_list', N=None): DCNL DCSP self.colors = colors DCNL DCSP self.monochrome = False DCNL DCSP if (N is None): DCNL DCSP  DCSP N = len(self.colors) DCNL DCSP elif cbook.is_string_like(self.colors): DCNL DCSP  DCSP self.colors = ([self.colors] * N) DCNL DCSP  DCSP self.monochrome = True DCNL DCSP elif cbook.iterable(self.colors): DCNL DCSP  DCSP self.colors = list(self.colors) DCNL DCSP  DCSP if (len(self.colors) == 1): DCNL DCSP  DCSP  DCSP self.monochrome = True DCNL DCSP  DCSP if (len(self.colors) < N): DCNL DCSP  DCSP  DCSP self.colors = (list(self.colors) * N) DCNL DCSP  DCSP del self.colors[N:] DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP gray = float(self.colors) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.colors = ([gray] * N) DCNL DCSP  DCSP self.monochrome = True DCNL DCSP Colormap.__init__(self, name, N)
def __init__(self, vmin=None, vmax=None, clip=False): DCNL DCSP self.vmin = vmin DCNL DCSP self.vmax = vmax DCNL DCSP self.clip = clip
def autoscale(self, A): DCNL DCSP self.vmin = ma.minimum(A) DCNL DCSP self.vmax = ma.maximum(A)
def autoscale_None(self, A): DCNL DCSP if (self.vmin is None): DCNL DCSP  DCSP self.vmin = ma.minimum(A) DCNL DCSP if (self.vmax is None): DCNL DCSP  DCSP self.vmax = ma.maximum(A)
def scaled(self): DCNL DCSP return ((self.vmin is not None) and (self.vmax is not None))
def __init__(self, boundaries, ncolors, clip=False): DCNL DCSP self.clip = clip DCNL DCSP self.vmin = boundaries[0] DCNL DCSP self.vmax = boundaries[(-1)] DCNL DCSP self.boundaries = np.asarray(boundaries) DCNL DCSP self.N = len(self.boundaries) DCNL DCSP self.Ncmap = ncolors DCNL DCSP if ((self.N - 1) == self.Ncmap): DCNL DCSP  DCSP self._interp = False DCNL DCSP else: DCNL DCSP  DCSP self._interp = True
def __init__(self, norm=None, cmap=None): DCNL DCSP self.callbacksSM = cbook.CallbackRegistry(('changed',)) DCNL DCSP if (cmap is None): DCNL DCSP  DCSP cmap = get_cmap() DCNL DCSP if (norm is None): DCNL DCSP  DCSP norm = colors.Normalize() DCNL DCSP self._A = None DCNL DCSP self.norm = norm DCNL DCSP self.cmap = cmap DCNL DCSP self.colorbar = None DCNL DCSP self.update_dict = {'array': False}
def set_colorbar(self, im, ax): DCNL DCSP self.colorbar = (im, ax)
def to_rgba(self, x, alpha=1.0, bytes=False): DCNL DCSP try: DCNL DCSP  DCSP if (x.ndim == 3): DCNL DCSP  DCSP  DCSP if (x.shape[2] == 3): DCNL DCSP  DCSP  DCSP  DCSP if (x.dtype == np.uint8): DCNL DCSP  DCSP  DCSP  DCSP  DCSP alpha = np.array((alpha * 255), np.uint8) DCNL DCSP  DCSP  DCSP  DCSP (m, n) = x.shape[:2] DCNL DCSP  DCSP  DCSP  DCSP xx = np.empty(shape=(m, n, 4), dtype=x.dtype) DCNL DCSP  DCSP  DCSP  DCSP xx[:, :, :3] = x DCNL DCSP  DCSP  DCSP  DCSP xx[:, :, 3] = alpha DCNL DCSP  DCSP  DCSP elif (x.shape[2] == 4): DCNL DCSP  DCSP  DCSP  DCSP xx = x DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('third DCSP dimension DCSP must DCSP be DCSP 3 DCSP or DCSP 4') DCNL DCSP  DCSP  DCSP if (bytes and (xx.dtype != np.uint8)): DCNL DCSP  DCSP  DCSP  DCSP xx = (xx * 255).astype(np.uint8) DCNL DCSP  DCSP  DCSP return xx DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP x = ma.asarray(x) DCNL DCSP x = self.norm(x) DCNL DCSP x = self.cmap(x, alpha=alpha, bytes=bytes) DCNL DCSP return x
def set_array(self, A): DCNL DCSP self._A = A DCNL DCSP self.update_dict['array'] = True
def get_array(self): DCNL DCSP return self._A
def get_cmap(self): DCNL DCSP return self.cmap
def get_clim(self): DCNL DCSP return (self.norm.vmin, self.norm.vmax)
def set_clim(self, vmin=None, vmax=None): DCNL DCSP if ((vmin is not None) and (vmax is None) and cbook.iterable(vmin) and (len(vmin) == 2)): DCNL DCSP  DCSP (vmin, vmax) = vmin DCNL DCSP if (vmin is not None): DCNL DCSP  DCSP self.norm.vmin = vmin DCNL DCSP if (vmax is not None): DCNL DCSP  DCSP self.norm.vmax = vmax DCNL DCSP self.changed()
def set_cmap(self, cmap): DCNL DCSP if (cmap is None): DCNL DCSP  DCSP cmap = get_cmap() DCNL DCSP self.cmap = cmap DCNL DCSP self.changed()
def set_norm(self, norm): DCNL DCSP if (norm is None): DCNL DCSP  DCSP norm = colors.Normalize() DCNL DCSP self.norm = norm DCNL DCSP self.changed()
def autoscale(self): DCNL DCSP if (self._A is None): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP first DCSP set_array DCSP for DCSP mappable') DCNL DCSP self.norm.autoscale(self._A) DCNL DCSP self.changed()
def autoscale_None(self): DCNL DCSP if (self._A is None): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP first DCSP set_array DCSP for DCSP mappable') DCNL DCSP self.norm.autoscale_None(self._A) DCNL DCSP self.changed()
def add_checker(self, checker): DCNL DCSP self.update_dict[checker] = False
def check_update(self, checker): DCNL DCSP if self.update_dict[checker]: DCNL DCSP  DCSP self.update_dict[checker] = False DCNL DCSP  DCSP return True DCNL DCSP return False
def changed(self): DCNL DCSP self.callbacksSM.process('changed', self) DCNL DCSP for key in self.update_dict: DCNL DCSP  DCSP self.update_dict[key] = True
def _init(self): DCNL DCSP if True: DCNL DCSP  DCSP trans = self._set_transform() DCNL DCSP  DCSP ax = self.ax DCNL DCSP  DCSP (sx, sy) = trans.inverted().transform_point((ax.bbox.width, ax.bbox.height)) DCNL DCSP  DCSP self.span = sx DCNL DCSP  DCSP sn = max(8, min(25, math.sqrt(self.N))) DCNL DCSP  DCSP if (self.width is None): DCNL DCSP  DCSP  DCSP self.width = ((0.06 * self.span) / sn)
def _h_arrows(self, length): DCNL DCSP minsh = (self.minshaft * self.headlength) DCNL DCSP N = len(length) DCNL DCSP length = length.reshape(N, 1) DCNL DCSP x = np.array([0, (- self.headaxislength), (- self.headlength), 0], np.float64) DCNL DCSP x = (x + (np.array([0, 1, 1, 1]) * length)) DCNL DCSP y = (0.5 * np.array([1, 1, self.headwidth, 0], np.float64)) DCNL DCSP y = np.repeat(y[np.newaxis, :], N, axis=0) DCNL DCSP x0 = np.array([0, (minsh - self.headaxislength), (minsh - self.headlength), minsh], np.float64) DCNL DCSP y0 = (0.5 * np.array([1, 1, self.headwidth, 0], np.float64)) DCNL DCSP ii = [0, 1, 2, 3, 2, 1, 0] DCNL DCSP X = x.take(ii, 1) DCNL DCSP Y = y.take(ii, 1) DCNL DCSP Y[:, 3:] *= (-1) DCNL DCSP X0 = x0.take(ii) DCNL DCSP Y0 = y0.take(ii) DCNL DCSP Y0[3:] *= (-1) DCNL DCSP shrink = (length / minsh) DCNL DCSP X0 = (shrink * X0[np.newaxis, :]) DCNL DCSP Y0 = (shrink * Y0[np.newaxis, :]) DCNL DCSP short = np.repeat((length < minsh), 7, axis=1) DCNL DCSP X = ma.where(short, X0, X) DCNL DCSP Y = ma.where(short, Y0, Y) DCNL DCSP if (self.pivot[:3] == 'mid'): DCNL DCSP  DCSP X -= (0.5 * X[:, 3, np.newaxis]) DCNL DCSP elif (self.pivot[:3] == 'tip'): DCNL DCSP  DCSP X = (X - X[:, 3, np.newaxis]) DCNL DCSP tooshort = (length < self.minlength) DCNL DCSP if tooshort.any(): DCNL DCSP  DCSP th = (np.arange(0, 7, 1, np.float64) * (np.pi / 3.0)) DCNL DCSP  DCSP x1 = ((np.cos(th) * self.minlength) * 0.5) DCNL DCSP  DCSP y1 = ((np.sin(th) * self.minlength) * 0.5) DCNL DCSP  DCSP X1 = np.repeat(x1[np.newaxis, :], N, axis=0) DCNL DCSP  DCSP Y1 = np.repeat(y1[np.newaxis, :], N, axis=0) DCNL DCSP  DCSP tooshort = ma.repeat(tooshort, 7, 1) DCNL DCSP  DCSP X = ma.where(tooshort, X1, X) DCNL DCSP  DCSP Y = ma.where(tooshort, Y1, Y) DCNL DCSP return (X, Y)
def _find_tails(self, mag, rounding=True, half=5, full=10, flag=50): DCNL DCSP if rounding: DCNL DCSP  DCSP mag = (half * ((mag / half) + 0.5).astype(np.int)) DCNL DCSP num_flags = np.floor((mag / flag)).astype(np.int) DCNL DCSP mag = np.mod(mag, flag) DCNL DCSP num_barb = np.floor((mag / full)).astype(np.int) DCNL DCSP mag = np.mod(mag, full) DCNL DCSP half_flag = (mag >= half) DCNL DCSP empty_flag = (~ ((half_flag | (num_flags > 0)) | (num_barb > 0))) DCNL DCSP return (num_flags, num_barb, half_flag, empty_flag)
def _make_barbs(self, u, v, nflags, nbarbs, half_barb, empty_flag, length, pivot, sizes, fill_empty, flip): DCNL DCSP spacing = (length * sizes.get('spacing', 0.125)) DCNL DCSP full_height = (length * sizes.get('height', 0.4)) DCNL DCSP full_width = (length * sizes.get('width', 0.25)) DCNL DCSP empty_rad = (length * sizes.get('emptybarb', 0.15)) DCNL DCSP pivot_points = dict(tip=0.0, middle=((- length) / 2.0)) DCNL DCSP if flip: DCNL DCSP  DCSP full_height = (- full_height) DCNL DCSP endx = 0.0 DCNL DCSP endy = pivot_points[pivot.lower()] DCNL DCSP angles = (- (ma.arctan2(v, u) + (np.pi / 2))) DCNL DCSP circ = CirclePolygon((0, 0), radius=empty_rad).get_verts() DCNL DCSP if fill_empty: DCNL DCSP  DCSP empty_barb = circ DCNL DCSP else: DCNL DCSP  DCSP empty_barb = np.concatenate((circ, circ[::(-1)])) DCNL DCSP barb_list = [] DCNL DCSP for (index, angle) in np.ndenumerate(angles): DCNL DCSP  DCSP if empty_flag[index]: DCNL DCSP  DCSP  DCSP barb_list.append(empty_barb) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP poly_verts = [(endx, endy)] DCNL DCSP  DCSP offset = length DCNL DCSP  DCSP for i in range(nflags[index]): DCNL DCSP  DCSP  DCSP if (offset != length): DCNL DCSP  DCSP  DCSP  DCSP offset += (spacing / 2.0) DCNL DCSP  DCSP  DCSP poly_verts.extend([[endx, (endy + offset)], [(endx + full_height), ((endy - (full_width / 2)) + offset)], [endx, ((endy - full_width) + offset)]]) DCNL DCSP  DCSP  DCSP offset -= (full_width + spacing) DCNL DCSP  DCSP for i in range(nbarbs[index]): DCNL DCSP  DCSP  DCSP poly_verts.extend([(endx, (endy + offset)), ((endx + full_height), ((endy + offset) + (full_width / 2))), (endx, (endy + offset))]) DCNL DCSP  DCSP  DCSP offset -= spacing DCNL DCSP  DCSP if half_barb[index]: DCNL DCSP  DCSP  DCSP if (offset == length): DCNL DCSP  DCSP  DCSP  DCSP poly_verts.append((endx, (endy + offset))) DCNL DCSP  DCSP  DCSP  DCSP offset -= (1.5 * spacing) DCNL DCSP  DCSP  DCSP poly_verts.extend([(endx, (endy + offset)), ((endx + (full_height / 2)), ((endy + offset) + (full_width / 4))), (endx, (endy + offset))]) DCNL DCSP  DCSP poly_verts = transforms.Affine2D().rotate((- angle)).transform(poly_verts) DCNL DCSP  DCSP barb_list.append(poly_verts) DCNL DCSP return barb_list
def set_offsets(self, xy): DCNL DCSP self.x = xy[:, 0] DCNL DCSP self.y = xy[:, 1] DCNL DCSP (x, y, u, v) = delete_masked_points(self.x.ravel(), self.y.ravel(), self.u, self.v) DCNL DCSP xy = np.hstack((x[:, np.newaxis], y[:, np.newaxis])) DCNL DCSP collections.PolyCollection.set_offsets(self, xy)
def __init__(self, key, valid, ignorecase=False): DCNL DCSP self.key = key DCNL DCSP self.ignorecase = ignorecase DCNL DCSP def func(s): DCNL DCSP  DCSP if ignorecase: DCNL DCSP  DCSP  DCSP return s.lower() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return s DCNL DCSP self.valid = dict([(func(k), k) for k in valid])
def __call__(self, s): DCNL DCSP if (type(s) is str): DCNL DCSP  DCSP ss = s.split(',') DCNL DCSP  DCSP if (len(ss) != self.n): DCNL DCSP  DCSP  DCSP raise ValueError(('You DCSP must DCSP supply DCSP exactly DCSP %d DCSP comma DCSP separated DCSP values' % self.n)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return [float(val) for val in ss] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError('Could DCSP not DCSP convert DCSP all DCSP entries DCSP to DCSP floats') DCNL DCSP else: DCNL DCSP  DCSP assert (type(s) in (list, tuple)) DCNL DCSP  DCSP if (len(s) != self.n): DCNL DCSP  DCSP  DCSP raise ValueError(('You DCSP must DCSP supply DCSP exactly DCSP %d DCSP values' % self.n)) DCNL DCSP  DCSP return [float(val) for val in s]
def __call__(self, s): DCNL DCSP if (type(s) is str): DCNL DCSP  DCSP ss = s.split(',') DCNL DCSP  DCSP if (len(ss) != self.n): DCNL DCSP  DCSP  DCSP raise ValueError(('You DCSP must DCSP supply DCSP exactly DCSP %d DCSP comma DCSP separated DCSP values' % self.n)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return [int(val) for val in ss] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError('Could DCSP not DCSP convert DCSP all DCSP entries DCSP to DCSP ints') DCNL DCSP else: DCNL DCSP  DCSP assert (type(s) in (list, tuple)) DCNL DCSP  DCSP if (len(s) != self.n): DCNL DCSP  DCSP  DCSP raise ValueError(('You DCSP must DCSP supply DCSP exactly DCSP %d DCSP values' % self.n)) DCNL DCSP  DCSP return [int(val) for val in s]
def register(self, *projections): DCNL DCSP for projection in projections: DCNL DCSP  DCSP name = projection.name DCNL DCSP  DCSP self._all_projection_types[name] = projection
def get_projection_class(self, name): DCNL DCSP return self._all_projection_types[name]
def get_projection_names(self): DCNL DCSP names = self._all_projection_types.keys() DCNL DCSP names.sort() DCNL DCSP return names
def __init__(self, resolution): DCNL DCSP Transform.__init__(self) DCNL DCSP self._resolution = resolution
def format_coord(self, long, lat): DCNL DCSP long = (long * (180.0 / np.pi)) DCNL DCSP lat = (lat * (180.0 / np.pi)) DCNL DCSP if (lat >= 0.0): DCNL DCSP  DCSP ns = 'N' DCNL DCSP else: DCNL DCSP  DCSP ns = 'S' DCNL DCSP if (long >= 0.0): DCNL DCSP  DCSP ew = 'E' DCNL DCSP else: DCNL DCSP  DCSP ew = 'W' DCNL DCSP return (u'%f\xb0%s, DCSP %f\xb0%s' % (abs(lat), ns, abs(long), ew))
def set_longitude_grid(self, degrees): DCNL DCSP number = ((360.0 / degrees) + 1) DCNL DCSP self.xaxis.set_major_locator(FixedLocator(np.linspace((- np.pi), np.pi, number, True)[1:(-1)])) DCNL DCSP self._logitude_degrees = degrees DCNL DCSP self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))
def set_latitude_grid(self, degrees): DCNL DCSP number = ((180.0 / degrees) + 1) DCNL DCSP self.yaxis.set_major_locator(FixedLocator(np.linspace(((- np.pi) / 2.0), (np.pi / 2.0), number, True)[1:(-1)])) DCNL DCSP self._latitude_degrees = degrees DCNL DCSP self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))
def set_longitude_grid_ends(self, degrees): DCNL DCSP self._longitude_cap = (degrees * (np.pi / 180.0)) DCNL DCSP self._xaxis_pretransform.clear().scale(1.0, (self._longitude_cap * 2.0)).translate(0.0, (- self._longitude_cap))
def get_data_ratio(self): DCNL DCSP return 1.0
def can_zoom(self): DCNL DCSP return False
def __init__(self, resolution): DCNL DCSP Transform.__init__(self) DCNL DCSP self._resolution = resolution
def __init__(self, resolution): DCNL DCSP Transform.__init__(self) DCNL DCSP self._resolution = resolution
def __init__(self, resolution): DCNL DCSP Transform.__init__(self) DCNL DCSP self._resolution = resolution
def __init__(self, center_longitude, center_latitude, resolution): DCNL DCSP Transform.__init__(self) DCNL DCSP self._resolution = resolution DCNL DCSP self._center_longitude = center_longitude DCNL DCSP self._center_latitude = center_latitude
def __init__(self, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None): DCNL DCSP self.validate = True DCNL DCSP self.update(left, bottom, right, top, wspace, hspace)
def update(self, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None): DCNL DCSP thisleft = getattr(self, 'left', None) DCNL DCSP thisright = getattr(self, 'right', None) DCNL DCSP thistop = getattr(self, 'top', None) DCNL DCSP thisbottom = getattr(self, 'bottom', None) DCNL DCSP thiswspace = getattr(self, 'wspace', None) DCNL DCSP thishspace = getattr(self, 'hspace', None) DCNL DCSP self._update_this('left', left) DCNL DCSP self._update_this('right', right) DCNL DCSP self._update_this('bottom', bottom) DCNL DCSP self._update_this('top', top) DCNL DCSP self._update_this('wspace', wspace) DCNL DCSP self._update_this('hspace', hspace) DCNL DCSP def reset(): DCNL DCSP  DCSP self.left = thisleft DCNL DCSP  DCSP self.right = thisright DCNL DCSP  DCSP self.top = thistop DCNL DCSP  DCSP self.bottom = thisbottom DCNL DCSP  DCSP self.wspace = thiswspace DCNL DCSP  DCSP self.hspace = thishspace DCNL DCSP if self.validate: DCNL DCSP  DCSP if (self.left >= self.right): DCNL DCSP  DCSP  DCSP reset() DCNL DCSP  DCSP  DCSP raise ValueError('left DCSP cannot DCSP be DCSP >= DCSP right') DCNL DCSP  DCSP if (self.bottom >= self.top): DCNL DCSP  DCSP  DCSP reset() DCNL DCSP  DCSP  DCSP raise ValueError('bottom DCSP cannot DCSP be DCSP >= DCSP top')
def __init__(self, figsize=None, dpi=None, facecolor=None, edgecolor=None, linewidth=1.0, frameon=True, subplotpars=None): DCNL DCSP Artist.__init__(self) DCNL DCSP self.callbacks = cbook.CallbackRegistry(('dpi_changed',)) DCNL DCSP if (figsize is None): DCNL DCSP  DCSP figsize = rcParams['figure.figsize'] DCNL DCSP if (dpi is None): DCNL DCSP  DCSP dpi = rcParams['figure.dpi'] DCNL DCSP if (facecolor is None): DCNL DCSP  DCSP facecolor = rcParams['figure.facecolor'] DCNL DCSP if (edgecolor is None): DCNL DCSP  DCSP edgecolor = rcParams['figure.edgecolor'] DCNL DCSP self.dpi_scale_trans = Affine2D() DCNL DCSP self.dpi = dpi DCNL DCSP self.bbox_inches = Bbox.from_bounds(0, 0, *figsize) DCNL DCSP self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans) DCNL DCSP self.frameon = frameon DCNL DCSP self.transFigure = BboxTransformTo(self.bbox) DCNL DCSP self.patch = self.figurePatch = Rectangle(xy=(0, 0), width=1, height=1, facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth) DCNL DCSP self._set_artist_props(self.patch) DCNL DCSP self._hold = rcParams['axes.hold'] DCNL DCSP self.canvas = None DCNL DCSP if (subplotpars is None): DCNL DCSP  DCSP subplotpars = SubplotParams() DCNL DCSP self.subplotpars = subplotpars DCNL DCSP self._axstack = Stack() DCNL DCSP self.axes = [] DCNL DCSP self.clf() DCNL DCSP self._cachedRenderer = None
def autofmt_xdate(self, bottom=0.2, rotation=30, ha='right'): DCNL DCSP allsubplots = np.alltrue([hasattr(ax, 'is_last_row') for ax in self.axes]) DCNL DCSP if (len(self.axes) == 1): DCNL DCSP  DCSP for label in ax.get_xticklabels(): DCNL DCSP  DCSP  DCSP label.set_ha(ha) DCNL DCSP  DCSP  DCSP label.set_rotation(rotation) DCNL DCSP elif allsubplots: DCNL DCSP  DCSP for ax in self.get_axes(): DCNL DCSP  DCSP  DCSP if ax.is_last_row(): DCNL DCSP  DCSP  DCSP  DCSP for label in ax.get_xticklabels(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP label.set_ha(ha) DCNL DCSP  DCSP  DCSP  DCSP  DCSP label.set_rotation(rotation) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for label in ax.get_xticklabels(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP label.set_visible(False) DCNL DCSP  DCSP  DCSP  DCSP ax.set_xlabel('') DCNL DCSP if allsubplots: DCNL DCSP  DCSP self.subplots_adjust(bottom=bottom)
def get_children(self): DCNL DCSP children = [self.patch] DCNL DCSP children.extend(self.artists) DCNL DCSP children.extend(self.axes) DCNL DCSP children.extend(self.lines) DCNL DCSP children.extend(self.patches) DCNL DCSP children.extend(self.texts) DCNL DCSP children.extend(self.images) DCNL DCSP children.extend(self.legends) DCNL DCSP return children
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP inside = self.bbox.contains(mouseevent.x, mouseevent.y) DCNL DCSP return (inside, {})
def get_window_extent(self, *args, **kwargs): DCNL DCSP return self.bbox
def suptitle(self, t, **kwargs): DCNL DCSP x = kwargs.pop('x', 0.5) DCNL DCSP y = kwargs.pop('y', 0.98) DCNL DCSP if (('horizontalalignment' not in kwargs) and ('ha' not in kwargs)): DCNL DCSP  DCSP kwargs['horizontalalignment'] = 'center' DCNL DCSP if (('verticalalignment' not in kwargs) and ('va' not in kwargs)): DCNL DCSP  DCSP kwargs['verticalalignment'] = 'top' DCNL DCSP t = self.text(x, y, t, **kwargs) DCNL DCSP return t
def set_canvas(self, canvas): DCNL DCSP self.canvas = canvas
def hold(self, b=None): DCNL DCSP if (b is None): DCNL DCSP  DCSP self._hold = (not self._hold) DCNL DCSP else: DCNL DCSP  DCSP self._hold = b
def figimage(self, X, xo=0, yo=0, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None, origin=None): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.clf() DCNL DCSP im = FigureImage(self, cmap, norm, xo, yo, origin) DCNL DCSP im.set_array(X) DCNL DCSP im.set_alpha(alpha) DCNL DCSP if (norm is None): DCNL DCSP  DCSP im.set_clim(vmin, vmax) DCNL DCSP self.images.append(im) DCNL DCSP return im
def set_size_inches(self, *args, **kwargs): DCNL DCSP forward = kwargs.get('forward', False) DCNL DCSP if (len(args) == 1): DCNL DCSP  DCSP (w, h) = args[0] DCNL DCSP else: DCNL DCSP  DCSP (w, h) = args DCNL DCSP dpival = self.dpi DCNL DCSP self.bbox_inches.p1 = (w, h) DCNL DCSP if forward: DCNL DCSP  DCSP dpival = self.dpi DCNL DCSP  DCSP canvasw = (w * dpival) DCNL DCSP  DCSP canvash = (h * dpival) DCNL DCSP  DCSP manager = getattr(self.canvas, 'manager', None) DCNL DCSP  DCSP if (manager is not None): DCNL DCSP  DCSP  DCSP manager.resize(int(canvasw), int(canvash))
def get_edgecolor(self): DCNL DCSP return self.patch.get_edgecolor()
def get_facecolor(self): DCNL DCSP return self.patch.get_facecolor()
def get_figwidth(self): DCNL DCSP return self.bbox_inches.width
def get_figheight(self): DCNL DCSP return self.bbox_inches.height
def get_dpi(self): DCNL DCSP return self.dpi
def get_frameon(self): DCNL DCSP return self.frameon
def set_edgecolor(self, color): DCNL DCSP self.patch.set_edgecolor(color)
def set_facecolor(self, color): DCNL DCSP self.patch.set_facecolor(color)
def set_dpi(self, val): DCNL DCSP self.dpi = val
def set_figwidth(self, val): DCNL DCSP self.bbox_inches.x1 = val
def set_figheight(self, val): DCNL DCSP self.bbox_inches.y1 = val
def set_frameon(self, b): DCNL DCSP self.frameon = b
def delaxes(self, a): DCNL DCSP self.axes.remove(a) DCNL DCSP self._axstack.remove(a) DCNL DCSP keys = [] DCNL DCSP for (key, thisax) in self._seen.items(): DCNL DCSP  DCSP if (a == thisax): DCNL DCSP  DCSP  DCSP del self._seen[key] DCNL DCSP for func in self._axobservers: DCNL DCSP  DCSP func(self)
def _make_key(self, *args, **kwargs): DCNL DCSP def fixitems(items): DCNL DCSP  DCSP ret = [] DCNL DCSP  DCSP for (k, v) in items: DCNL DCSP  DCSP  DCSP if iterable(v): DCNL DCSP  DCSP  DCSP  DCSP v = tuple(v) DCNL DCSP  DCSP  DCSP ret.append((k, v)) DCNL DCSP  DCSP return tuple(ret) DCNL DCSP def fixlist(args): DCNL DCSP  DCSP ret = [] DCNL DCSP  DCSP for a in args: DCNL DCSP  DCSP  DCSP if iterable(a): DCNL DCSP  DCSP  DCSP  DCSP a = tuple(a) DCNL DCSP  DCSP  DCSP ret.append(a) DCNL DCSP  DCSP return tuple(ret) DCNL DCSP key = (fixlist(args), fixitems(kwargs.items())) DCNL DCSP return key
def add_axes(self, *args, **kwargs): DCNL DCSP key = self._make_key(*args, **kwargs) DCNL DCSP if (key in self._seen): DCNL DCSP  DCSP ax = self._seen[key] DCNL DCSP  DCSP self.sca(ax) DCNL DCSP  DCSP return ax DCNL DCSP if (not len(args)): DCNL DCSP  DCSP return DCNL DCSP if isinstance(args[0], Axes): DCNL DCSP  DCSP a = args[0] DCNL DCSP  DCSP assert (a.get_figure() is self) DCNL DCSP else: DCNL DCSP  DCSP rect = args[0] DCNL DCSP  DCSP ispolar = kwargs.pop('polar', False) DCNL DCSP  DCSP projection = kwargs.pop('projection', None) DCNL DCSP  DCSP if ispolar: DCNL DCSP  DCSP  DCSP if ((projection is not None) and (projection != 'polar')): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(("polar=True, DCSP yet DCSP projection='%s'. DCSP " + ('Only DCSP one DCSP of DCSP these DCSP arguments DCSP should DCSP be DCSP supplied.' % projection))) DCNL DCSP  DCSP  DCSP projection = 'polar' DCNL DCSP  DCSP a = projection_factory(projection, self, rect, **kwargs) DCNL DCSP self.axes.append(a) DCNL DCSP self._axstack.push(a) DCNL DCSP self.sca(a) DCNL DCSP self._seen[key] = a DCNL DCSP return a
def add_subplot(self, *args, **kwargs): DCNL DCSP kwargs = kwargs.copy() DCNL DCSP if (not len(args)): DCNL DCSP  DCSP return DCNL DCSP if isinstance(args[0], SubplotBase): DCNL DCSP  DCSP a = args[0] DCNL DCSP  DCSP assert (a.get_figure() is self) DCNL DCSP else: DCNL DCSP  DCSP ispolar = kwargs.pop('polar', False) DCNL DCSP  DCSP projection = kwargs.pop('projection', None) DCNL DCSP  DCSP if ispolar: DCNL DCSP  DCSP  DCSP if ((projection is not None) and (projection != 'polar')): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(("polar=True, DCSP yet DCSP projection='%s'. DCSP " + ('Only DCSP one DCSP of DCSP these DCSP arguments DCSP should DCSP be DCSP supplied.' % projection))) DCNL DCSP  DCSP  DCSP projection = 'polar' DCNL DCSP  DCSP projection_class = get_projection_class(projection) DCNL DCSP  DCSP key = self._make_key(*args, **kwargs) DCNL DCSP  DCSP if (key in self._seen): DCNL DCSP  DCSP  DCSP ax = self._seen[key] DCNL DCSP  DCSP  DCSP if isinstance(ax, projection_class): DCNL DCSP  DCSP  DCSP  DCSP self.sca(ax) DCNL DCSP  DCSP  DCSP  DCSP return ax DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self.axes.remove(ax) DCNL DCSP  DCSP  DCSP  DCSP self._axstack.remove(ax) DCNL DCSP  DCSP a = subplot_class_factory(projection_class)(self, *args, **kwargs) DCNL DCSP  DCSP self._seen[key] = a DCNL DCSP self.axes.append(a) DCNL DCSP self._axstack.push(a) DCNL DCSP self.sca(a) DCNL DCSP return a
def clf(self): DCNL DCSP self.suppressComposite = None DCNL DCSP self.callbacks = cbook.CallbackRegistry(('dpi_changed',)) DCNL DCSP for ax in tuple(self.axes): DCNL DCSP  DCSP ax.cla() DCNL DCSP  DCSP self.delaxes(ax) DCNL DCSP toolbar = getattr(self.canvas, 'toolbar', None) DCNL DCSP if (toolbar is not None): DCNL DCSP  DCSP toolbar.update() DCNL DCSP self._axstack.clear() DCNL DCSP self._seen = {} DCNL DCSP self.artists = [] DCNL DCSP self.lines = [] DCNL DCSP self.patches = [] DCNL DCSP self.texts = [] DCNL DCSP self.images = [] DCNL DCSP self.legends = [] DCNL DCSP self._axobservers = []
def clear(self): DCNL DCSP self.clf()
def draw(self, renderer): DCNL DCSP if (not self.get_visible()): DCNL DCSP  DCSP return DCNL DCSP renderer.open_group('figure') DCNL DCSP if self.frameon: DCNL DCSP  DCSP self.patch.draw(renderer) DCNL DCSP for p in self.patches: DCNL DCSP  DCSP p.draw(renderer) DCNL DCSP for l in self.lines: DCNL DCSP  DCSP l.draw(renderer) DCNL DCSP for a in self.artists: DCNL DCSP  DCSP a.draw(renderer) DCNL DCSP composite = renderer.option_image_nocomposite() DCNL DCSP if (self.suppressComposite is not None): DCNL DCSP  DCSP composite = self.suppressComposite DCNL DCSP if ((len(self.images) <= 1) or composite or (not allequal([im.origin for im in self.images]))): DCNL DCSP  DCSP for im in self.images: DCNL DCSP  DCSP  DCSP im.draw(renderer) DCNL DCSP else: DCNL DCSP  DCSP mag = renderer.get_image_magnification() DCNL DCSP  DCSP ims = [(im.make_image(mag), im.ox, im.oy) for im in self.images] DCNL DCSP  DCSP im = _image.from_images((self.bbox.height * mag), (self.bbox.width * mag), ims) DCNL DCSP  DCSP im.is_grayscale = False DCNL DCSP  DCSP (l, b, w, h) = self.bbox.bounds DCNL DCSP  DCSP (clippath, affine) = self.get_transformed_clip_path_and_affine() DCNL DCSP  DCSP renderer.draw_image(l, b, im, self.bbox, clippath, affine) DCNL DCSP for a in self.axes: DCNL DCSP  DCSP a.draw(renderer) DCNL DCSP for t in self.texts: DCNL DCSP  DCSP t.draw(renderer) DCNL DCSP for legend in self.legends: DCNL DCSP  DCSP legend.draw(renderer) DCNL DCSP renderer.close_group('figure') DCNL DCSP self._cachedRenderer = renderer DCNL DCSP self.canvas.draw_event(renderer)
def draw_artist(self, a): DCNL DCSP assert (self._cachedRenderer is not None) DCNL DCSP a.draw(self._cachedRenderer)
def legend(self, handles, labels, *args, **kwargs): DCNL DCSP handles = flatten(handles) DCNL DCSP l = Legend(self, handles, labels, *args, **kwargs) DCNL DCSP self.legends.append(l) DCNL DCSP return l
def text(self, x, y, s, *args, **kwargs): DCNL DCSP override = _process_text_args({}, *args, **kwargs) DCNL DCSP t = Text(x=x, y=y, text=s) DCNL DCSP t.update(override) DCNL DCSP self._set_artist_props(t) DCNL DCSP self.texts.append(t) DCNL DCSP return t
def gca(self, **kwargs): DCNL DCSP ax = self._axstack() DCNL DCSP if (ax is not None): DCNL DCSP  DCSP ispolar = kwargs.get('polar', False) DCNL DCSP  DCSP projection = kwargs.get('projection', None) DCNL DCSP  DCSP if ispolar: DCNL DCSP  DCSP  DCSP if ((projection is not None) and (projection != 'polar')): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(("polar=True, DCSP yet DCSP projection='%s'. DCSP " + ('Only DCSP one DCSP of DCSP these DCSP arguments DCSP should DCSP be DCSP supplied.' % projection))) DCNL DCSP  DCSP  DCSP projection = 'polar' DCNL DCSP  DCSP projection_class = get_projection_class(projection) DCNL DCSP  DCSP if isinstance(ax, projection_class): DCNL DCSP  DCSP  DCSP return ax DCNL DCSP return self.add_subplot(111, **kwargs)
def sca(self, a): DCNL DCSP self._axstack.bubble(a) DCNL DCSP for func in self._axobservers: DCNL DCSP  DCSP func(self) DCNL DCSP return a
def add_axobserver(self, func): DCNL DCSP self._axobservers.append(func)
def savefig(self, *args, **kwargs): DCNL DCSP for key in ('dpi', 'facecolor', 'edgecolor'): DCNL DCSP  DCSP if (key not in kwargs): DCNL DCSP  DCSP  DCSP kwargs[key] = rcParams[('savefig.%s' % key)] DCNL DCSP transparent = kwargs.pop('transparent', False) DCNL DCSP if transparent: DCNL DCSP  DCSP original_figure_alpha = self.patch.get_alpha() DCNL DCSP  DCSP self.patch.set_alpha(0.0) DCNL DCSP  DCSP original_axes_alpha = [] DCNL DCSP  DCSP for ax in self.axes: DCNL DCSP  DCSP  DCSP patch = ax.patch DCNL DCSP  DCSP  DCSP original_axes_alpha.append(patch.get_alpha()) DCNL DCSP  DCSP  DCSP patch.set_alpha(0.0) DCNL DCSP self.canvas.print_figure(*args, **kwargs) DCNL DCSP if transparent: DCNL DCSP  DCSP self.patch.set_alpha(original_figure_alpha) DCNL DCSP  DCSP for (ax, alpha) in zip(self.axes, original_axes_alpha): DCNL DCSP  DCSP  DCSP ax.patch.set_alpha(alpha)
def subplots_adjust(self, *args, **kwargs): DCNL DCSP self.subplotpars.update(*args, **kwargs) DCNL DCSP import matplotlib.axes DCNL DCSP for ax in self.axes: DCNL DCSP  DCSP if (not isinstance(ax, matplotlib.axes.SubplotBase)): DCNL DCSP  DCSP  DCSP if ((ax._sharex is not None) and isinstance(ax._sharex, matplotlib.axes.SubplotBase)): DCNL DCSP  DCSP  DCSP  DCSP ax._sharex.update_params() DCNL DCSP  DCSP  DCSP  DCSP ax.set_position(ax._sharex.figbox) DCNL DCSP  DCSP  DCSP elif ((ax._sharey is not None) and isinstance(ax._sharey, matplotlib.axes.SubplotBase)): DCNL DCSP  DCSP  DCSP  DCSP ax._sharey.update_params() DCNL DCSP  DCSP  DCSP  DCSP ax.set_position(ax._sharey.figbox) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ax.update_params() DCNL DCSP  DCSP  DCSP ax.set_position(ax.figbox)
def ginput(self, n=1, timeout=30, show_clicks=True): DCNL DCSP blocking_mouse_input = BlockingMouseInput(self) DCNL DCSP return blocking_mouse_input(n=n, timeout=timeout, show_clicks=show_clicks)
def waitforbuttonpress(self, timeout=(-1)): DCNL DCSP blocking_input = BlockingKeyMouseInput(self) DCNL DCSP return blocking_input(timeout=timeout)
def __init__(self, x=0, y=0, text='', color=None, verticalalignment='bottom', horizontalalignment='left', multialignment=None, fontproperties=None, rotation=None, linespacing=None, **kwargs): DCNL DCSP Artist.__init__(self) DCNL DCSP self.cached = maxdict(5) DCNL DCSP (self._x, self._y) = (x, y) DCNL DCSP if (color is None): DCNL DCSP  DCSP color = rcParams['text.color'] DCNL DCSP if (fontproperties is None): DCNL DCSP  DCSP fontproperties = FontProperties() DCNL DCSP elif is_string_like(fontproperties): DCNL DCSP  DCSP fontproperties = FontProperties(fontproperties) DCNL DCSP self.set_text(text) DCNL DCSP self.set_color(color) DCNL DCSP self._verticalalignment = verticalalignment DCNL DCSP self._horizontalalignment = horizontalalignment DCNL DCSP self._multialignment = multialignment DCNL DCSP self._rotation = rotation DCNL DCSP self._fontproperties = fontproperties DCNL DCSP self._bbox = None DCNL DCSP self._bbox_patch = None DCNL DCSP self._renderer = None DCNL DCSP if (linespacing is None): DCNL DCSP  DCSP linespacing = 1.2 DCNL DCSP self._linespacing = linespacing DCNL DCSP self.update(kwargs)
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP if ((not self.get_visible()) or (self._renderer is None)): DCNL DCSP  DCSP return (False, {}) DCNL DCSP (l, b, w, h) = self.get_window_extent().bounds DCNL DCSP r = (l + w) DCNL DCSP t = (b + h) DCNL DCSP xyverts = ((l, b), (l, t), (r, t), (r, b)) DCNL DCSP (x, y) = (mouseevent.x, mouseevent.y) DCNL DCSP inside = nxutils.pnpoly(x, y, xyverts) DCNL DCSP return (inside, {})
def _get_xy_display(self): DCNL DCSP (x, y) = self.get_position() DCNL DCSP return self.get_transform().transform_point((x, y))
def get_rotation(self): DCNL DCSP return get_rotation(self._rotation)
def update_from(self, other): DCNL DCSP Artist.update_from(self, other) DCNL DCSP self._color = other._color DCNL DCSP self._multialignment = other._multialignment DCNL DCSP self._verticalalignment = other._verticalalignment DCNL DCSP self._horizontalalignment = other._horizontalalignment DCNL DCSP self._fontproperties = other._fontproperties.copy() DCNL DCSP self._rotation = other._rotation DCNL DCSP self._picker = other._picker DCNL DCSP self._linespacing = other._linespacing
def set_bbox(self, rectprops): DCNL DCSP if ((rectprops is not None) and ('boxstyle' in rectprops)): DCNL DCSP  DCSP props = rectprops.copy() DCNL DCSP  DCSP boxstyle = props.pop('boxstyle') DCNL DCSP  DCSP bbox_transmuter = props.pop('bbox_transmuter', None) DCNL DCSP  DCSP self._bbox_patch = FancyBboxPatch((0.0, 0.0), 1.0, 1.0, boxstyle=boxstyle, bbox_transmuter=bbox_transmuter, transform=mtransforms.IdentityTransform(), **props) DCNL DCSP  DCSP self._bbox = None DCNL DCSP else: DCNL DCSP  DCSP self._bbox_patch = None DCNL DCSP  DCSP self._bbox = rectprops
def get_bbox_patch(self): DCNL DCSP return self._bbox_patch
def update_bbox_position_size(self, renderer): DCNL DCSP if (not isinstance(self.arrow_patch, FancyArrowPatch)): DCNL DCSP  DCSP return DCNL DCSP if self._bbox_patch: DCNL DCSP  DCSP trans = self.get_transform() DCNL DCSP  DCSP posx = float(self.convert_xunits(self._x)) DCNL DCSP  DCSP posy = float(self.convert_yunits(self._y)) DCNL DCSP  DCSP (posx, posy) = trans.transform_point((posx, posy)) DCNL DCSP  DCSP (x_box, y_box, w_box, h_box) = _get_textbox(self, renderer) DCNL DCSP  DCSP self._bbox_patch.set_bounds(0.0, 0.0, w_box, h_box) DCNL DCSP  DCSP theta = ((self.get_rotation() / 180.0) * math.pi) DCNL DCSP  DCSP tr = mtransforms.Affine2D().rotate(theta) DCNL DCSP  DCSP tr = tr.translate((posx + x_box), (posy + y_box)) DCNL DCSP  DCSP self._bbox_patch.set_transform(tr) DCNL DCSP  DCSP fontsize_in_pixel = renderer.points_to_pixels(self.get_size()) DCNL DCSP  DCSP self._bbox_patch.set_mutation_scale(fontsize_in_pixel) DCNL DCSP else: DCNL DCSP  DCSP props = self._bbox DCNL DCSP  DCSP if (props is None): DCNL DCSP  DCSP  DCSP props = {} DCNL DCSP  DCSP props = props.copy() DCNL DCSP  DCSP pad = props.pop('pad', 4) DCNL DCSP  DCSP pad = renderer.points_to_pixels(pad) DCNL DCSP  DCSP bbox = self.get_window_extent(renderer) DCNL DCSP  DCSP (l, b, w, h) = bbox.bounds DCNL DCSP  DCSP l -= (pad / 2.0) DCNL DCSP  DCSP b -= (pad / 2.0) DCNL DCSP  DCSP w += pad DCNL DCSP  DCSP h += pad DCNL DCSP  DCSP r = Rectangle(xy=(l, b), width=w, height=h) DCNL DCSP  DCSP r.set_transform(mtransforms.IdentityTransform()) DCNL DCSP  DCSP r.set_clip_on(False) DCNL DCSP  DCSP r.update(props) DCNL DCSP  DCSP self.arrow_patch.set_patchA(r)
def _draw_bbox(self, renderer, posx, posy): DCNL DCSP (x_box, y_box, w_box, h_box) = _get_textbox(self, renderer) DCNL DCSP self._bbox_patch.set_bounds(0.0, 0.0, w_box, h_box) DCNL DCSP theta = ((self.get_rotation() / 180.0) * math.pi) DCNL DCSP tr = mtransforms.Affine2D().rotate(theta) DCNL DCSP tr = tr.translate((posx + x_box), (posy + y_box)) DCNL DCSP self._bbox_patch.set_transform(tr) DCNL DCSP fontsize_in_pixel = renderer.points_to_pixels(self.get_size()) DCNL DCSP self._bbox_patch.set_mutation_scale(fontsize_in_pixel) DCNL DCSP self._bbox_patch.draw(renderer)
def draw(self, renderer): DCNL DCSP if (renderer is not None): DCNL DCSP  DCSP self._renderer = renderer DCNL DCSP if (not self.get_visible()): DCNL DCSP  DCSP return DCNL DCSP if (self._text == ''): DCNL DCSP  DCSP return DCNL DCSP (bbox, info) = self._get_layout(renderer) DCNL DCSP trans = self.get_transform() DCNL DCSP posx = float(self.convert_xunits(self._x)) DCNL DCSP posy = float(self.convert_yunits(self._y)) DCNL DCSP (posx, posy) = trans.transform_point((posx, posy)) DCNL DCSP (canvasw, canvash) = renderer.get_canvas_width_height() DCNL DCSP if self._bbox_patch: DCNL DCSP  DCSP self._draw_bbox(renderer, posx, posy) DCNL DCSP gc = renderer.new_gc() DCNL DCSP gc.set_foreground(self._color) DCNL DCSP gc.set_alpha(self._alpha) DCNL DCSP gc.set_url(self._url) DCNL DCSP if self.get_clip_on(): DCNL DCSP  DCSP gc.set_clip_rectangle(self.clipbox) DCNL DCSP if self._bbox: DCNL DCSP  DCSP bbox_artist(self, renderer, self._bbox) DCNL DCSP angle = self.get_rotation() DCNL DCSP if rcParams['text.usetex']: DCNL DCSP  DCSP for (line, wh, x, y) in info: DCNL DCSP  DCSP  DCSP x = (x + posx) DCNL DCSP  DCSP  DCSP y = (y + posy) DCNL DCSP  DCSP  DCSP if renderer.flipy(): DCNL DCSP  DCSP  DCSP  DCSP y = (canvash - y) DCNL DCSP  DCSP  DCSP (clean_line, ismath) = self.is_math_text(line) DCNL DCSP  DCSP  DCSP renderer.draw_tex(gc, x, y, clean_line, self._fontproperties, angle) DCNL DCSP  DCSP return DCNL DCSP for (line, wh, x, y) in info: DCNL DCSP  DCSP x = (x + posx) DCNL DCSP  DCSP y = (y + posy) DCNL DCSP  DCSP if renderer.flipy(): DCNL DCSP  DCSP  DCSP y = (canvash - y) DCNL DCSP  DCSP (clean_line, ismath) = self.is_math_text(line) DCNL DCSP  DCSP renderer.draw_text(gc, x, y, clean_line, self._fontproperties, angle, ismath=ismath)
def get_color(self): DCNL DCSP return self._color
def get_fontproperties(self): DCNL DCSP return self._fontproperties
def get_font_properties(self): DCNL DCSP return self.get_fontproperties
def get_family(self): DCNL DCSP return self._fontproperties.get_family()
def get_fontfamily(self): DCNL DCSP return self.get_family()
def get_name(self): DCNL DCSP return self._fontproperties.get_name()
def get_style(self): DCNL DCSP return self._fontproperties.get_style()
def get_size(self): DCNL DCSP return self._fontproperties.get_size_in_points()
def get_variant(self): DCNL DCSP return self._fontproperties.get_variant()
def get_fontvariant(self): DCNL DCSP return self.get_variant()
def get_weight(self): DCNL DCSP return self._fontproperties.get_weight()
def get_fontname(self): DCNL DCSP return self.get_name()
def get_fontstyle(self): DCNL DCSP return self.get_style()
def get_fontsize(self): DCNL DCSP return self.get_size()
def get_fontweight(self): DCNL DCSP return self.get_weight()
def get_stretch(self): DCNL DCSP return self._fontproperties.get_stretch()
def get_fontstretch(self): DCNL DCSP return self.get_stretch()
def get_ha(self): DCNL DCSP return self.get_horizontalalignment()
def get_horizontalalignment(self): DCNL DCSP return self._horizontalalignment
def get_position(self): DCNL DCSP x = float(self.convert_xunits(self._x)) DCNL DCSP y = float(self.convert_yunits(self._y)) DCNL DCSP return (x, y)
def get_prop_tup(self): DCNL DCSP (x, y) = self.get_position() DCNL DCSP return (x, y, self._text, self._color, self._verticalalignment, self._horizontalalignment, hash(self._fontproperties), self._rotation, self.figure.dpi, id(self._renderer))
def get_text(self): DCNL DCSP return self._text
def get_va(self): DCNL DCSP return self.get_verticalalignment()
def get_verticalalignment(self): DCNL DCSP return self._verticalalignment
def get_window_extent(self, renderer=None, dpi=None): DCNL DCSP if (not self.get_visible()): DCNL DCSP  DCSP return Bbox.unit() DCNL DCSP if (dpi is not None): DCNL DCSP  DCSP dpi_orig = self.figure.dpi DCNL DCSP  DCSP self.figure.dpi = dpi DCNL DCSP if (self._text == ''): DCNL DCSP  DCSP (tx, ty) = self._get_xy_display() DCNL DCSP  DCSP return Bbox.from_bounds(tx, ty, 0, 0) DCNL DCSP if (renderer is not None): DCNL DCSP  DCSP self._renderer = renderer DCNL DCSP if (self._renderer is None): DCNL DCSP  DCSP raise RuntimeError('Cannot DCSP get DCSP window DCSP extent DCSP w/o DCSP renderer') DCNL DCSP (bbox, info) = self._get_layout(self._renderer) DCNL DCSP (x, y) = self.get_position() DCNL DCSP (x, y) = self.get_transform().transform_point((x, y)) DCNL DCSP bbox = bbox.translated(x, y) DCNL DCSP if (dpi is not None): DCNL DCSP  DCSP self.figure.dpi = dpi_orig DCNL DCSP return bbox
def set_backgroundcolor(self, color): DCNL DCSP if (self._bbox is None): DCNL DCSP  DCSP self._bbox = dict(facecolor=color, edgecolor=color) DCNL DCSP else: DCNL DCSP  DCSP self._bbox.update(dict(facecolor=color))
def set_color(self, color): DCNL DCSP try: DCNL DCSP  DCSP hash(color) DCNL DCSP except TypeError: DCNL DCSP  DCSP color = tuple(color) DCNL DCSP self._color = color
def set_ha(self, align): DCNL DCSP self.set_horizontalalignment(align)
def set_horizontalalignment(self, align): DCNL DCSP legal = ('center', 'right', 'left') DCNL DCSP if (align not in legal): DCNL DCSP  DCSP raise ValueError(('Horizontal DCSP alignment DCSP must DCSP be DCSP one DCSP of DCSP %s' % str(legal))) DCNL DCSP self._horizontalalignment = align
def set_ma(self, align): DCNL DCSP self.set_multialignment(align)
def set_multialignment(self, align): DCNL DCSP legal = ('center', 'right', 'left') DCNL DCSP if (align not in legal): DCNL DCSP  DCSP raise ValueError(('Horizontal DCSP alignment DCSP must DCSP be DCSP one DCSP of DCSP %s' % str(legal))) DCNL DCSP self._multialignment = align
def set_linespacing(self, spacing): DCNL DCSP self._linespacing = spacing
def set_family(self, fontname): DCNL DCSP self._fontproperties.set_family(fontname)
def set_variant(self, variant): DCNL DCSP self._fontproperties.set_variant(variant)
def set_fontvariant(self, variant): DCNL DCSP return self.set_variant(variant)
def set_name(self, fontname): DCNL DCSP return self.set_family(fontname)
def set_fontname(self, fontname): DCNL DCSP self.set_family(fontname)
def set_style(self, fontstyle): DCNL DCSP self._fontproperties.set_style(fontstyle)
def set_fontstyle(self, fontstyle): DCNL DCSP return self.set_style(fontstyle)
def set_size(self, fontsize): DCNL DCSP self._fontproperties.set_size(fontsize)
def set_fontsize(self, fontsize): DCNL DCSP return self.set_size(fontsize)
def set_weight(self, weight): DCNL DCSP self._fontproperties.set_weight(weight)
def set_fontweight(self, weight): DCNL DCSP return self.set_weight(weight)
def set_stretch(self, stretch): DCNL DCSP self._fontproperties.set_stretch(stretch)
def set_fontstretch(self, stretch): DCNL DCSP return self.set_stretch(stretch)
def set_position(self, xy): DCNL DCSP self.set_x(xy[0]) DCNL DCSP self.set_y(xy[1])
def set_x(self, x): DCNL DCSP self._x = x
def set_y(self, y): DCNL DCSP self._y = y
def set_rotation(self, s): DCNL DCSP self._rotation = s
def set_va(self, align): DCNL DCSP self.set_verticalalignment(align)
def set_verticalalignment(self, align): DCNL DCSP legal = ('top', 'bottom', 'center', 'baseline') DCNL DCSP if (align not in legal): DCNL DCSP  DCSP raise ValueError(('Vertical DCSP alignment DCSP must DCSP be DCSP one DCSP of DCSP %s' % str(legal))) DCNL DCSP self._verticalalignment = align
def set_text(self, s): DCNL DCSP self._text = ('%s' % (s,))
def is_math_text(self, s): DCNL DCSP dollar_count = (s.count('$') - s.count('\\$')) DCNL DCSP even_dollars = ((dollar_count > 0) and ((dollar_count % 2) == 0)) DCNL DCSP if rcParams['text.usetex']: DCNL DCSP  DCSP return (s, 'TeX') DCNL DCSP if even_dollars: DCNL DCSP  DCSP return (s, True) DCNL DCSP else: DCNL DCSP  DCSP return (s.replace('\\$', '$'), False)
def set_fontproperties(self, fp): DCNL DCSP if is_string_like(fp): DCNL DCSP  DCSP fp = FontProperties(fp) DCNL DCSP self._fontproperties = fp.copy()
def set_font_properties(self, fp): DCNL DCSP self.set_fontproperties(fp)
def get_position(self): DCNL DCSP x = float(self.convert_xunits(self._dashx)) DCNL DCSP y = float(self.convert_yunits(self._dashy)) DCNL DCSP return (x, y)
def get_prop_tup(self): DCNL DCSP props = [p for p in Text.get_prop_tup(self)] DCNL DCSP props.extend([self._x, self._y, self._dashlength, self._dashdirection, self._dashrotation, self._dashpad, self._dashpush]) DCNL DCSP return tuple(props)
def draw(self, renderer): DCNL DCSP self.update_coords(renderer) DCNL DCSP Text.draw(self, renderer) DCNL DCSP if (self.get_dashlength() > 0.0): DCNL DCSP  DCSP self.dashline.draw(renderer)
def update_coords(self, renderer): DCNL DCSP (dashx, dashy) = self.get_position() DCNL DCSP dashlength = self.get_dashlength() DCNL DCSP if (dashlength == 0.0): DCNL DCSP  DCSP (self._x, self._y) = (dashx, dashy) DCNL DCSP  DCSP return DCNL DCSP dashrotation = self.get_dashrotation() DCNL DCSP dashdirection = self.get_dashdirection() DCNL DCSP dashpad = self.get_dashpad() DCNL DCSP dashpush = self.get_dashpush() DCNL DCSP angle = get_rotation(dashrotation) DCNL DCSP theta = (np.pi * (((angle / 180.0) + dashdirection) - 1)) DCNL DCSP (cos_theta, sin_theta) = (np.cos(theta), np.sin(theta)) DCNL DCSP transform = self.get_transform() DCNL DCSP cxy = transform.transform_point((dashx, dashy)) DCNL DCSP cd = np.array([cos_theta, sin_theta]) DCNL DCSP c1 = (cxy + (dashpush * cd)) DCNL DCSP c2 = (cxy + ((dashpush + dashlength) * cd)) DCNL DCSP inverse = transform.inverted() DCNL DCSP (x1, y1) = inverse.transform_point(tuple(c1)) DCNL DCSP (x2, y2) = inverse.transform_point(tuple(c2)) DCNL DCSP self.dashline.set_data((x1, x2), (y1, y2)) DCNL DCSP we = Text.get_window_extent(self, renderer=renderer) DCNL DCSP (w, h) = (we.width, we.height) DCNL DCSP if (sin_theta == 0.0): DCNL DCSP  DCSP dx = w DCNL DCSP  DCSP dy = 0.0 DCNL DCSP elif (cos_theta == 0.0): DCNL DCSP  DCSP dx = 0.0 DCNL DCSP  DCSP dy = h DCNL DCSP else: DCNL DCSP  DCSP tan_theta = (sin_theta / cos_theta) DCNL DCSP  DCSP dx = w DCNL DCSP  DCSP dy = (w * tan_theta) DCNL DCSP  DCSP if ((dy > h) or (dy < (- h))): DCNL DCSP  DCSP  DCSP dy = h DCNL DCSP  DCSP  DCSP dx = (h / tan_theta) DCNL DCSP cwd = (np.array([dx, dy]) / 2) DCNL DCSP cwd *= (1 + (dashpad / np.sqrt(np.dot(cwd, cwd)))) DCNL DCSP cw = (c2 + (((dashdirection * 2) - 1) * cwd)) DCNL DCSP (newx, newy) = inverse.transform_point(tuple(cw)) DCNL DCSP (self._x, self._y) = (newx, newy) DCNL DCSP we = Text.get_window_extent(self, renderer=renderer) DCNL DCSP self._twd_window_extent = we.frozen() DCNL DCSP self._twd_window_extent.update_from_data_xy(np.array([c1]), False) DCNL DCSP Text.set_horizontalalignment(self, 'center') DCNL DCSP Text.set_verticalalignment(self, 'center')
def get_window_extent(self, renderer=None): DCNL DCSP self.update_coords(renderer) DCNL DCSP if (self.get_dashlength() == 0.0): DCNL DCSP  DCSP return Text.get_window_extent(self, renderer=renderer) DCNL DCSP else: DCNL DCSP  DCSP return self._twd_window_extent
def get_dashlength(self): DCNL DCSP return self._dashlength
def set_dashlength(self, dl): DCNL DCSP self._dashlength = dl
def get_dashdirection(self): DCNL DCSP return self._dashdirection
def set_dashdirection(self, dd): DCNL DCSP self._dashdirection = dd
def get_dashrotation(self): DCNL DCSP if (self._dashrotation == None): DCNL DCSP  DCSP return self.get_rotation() DCNL DCSP else: DCNL DCSP  DCSP return self._dashrotation
def set_dashrotation(self, dr): DCNL DCSP self._dashrotation = dr
def get_dashpad(self): DCNL DCSP return self._dashpad
def set_dashpad(self, dp): DCNL DCSP self._dashpad = dp
def get_dashpush(self): DCNL DCSP return self._dashpush
def set_dashpush(self, dp): DCNL DCSP self._dashpush = dp
def set_position(self, xy): DCNL DCSP self.set_x(xy[0]) DCNL DCSP self.set_y(xy[1])
def set_x(self, x): DCNL DCSP self._dashx = float(x)
def set_y(self, y): DCNL DCSP self._dashy = float(y)
def set_transform(self, t): DCNL DCSP Text.set_transform(self, t) DCNL DCSP self.dashline.set_transform(t)
def get_figure(self): DCNL DCSP return self.figure
def set_figure(self, fig): DCNL DCSP Text.set_figure(self, fig) DCNL DCSP self.dashline.set_figure(fig)
def __init__(self, s, xy, xytext=None, xycoords='data', textcoords=None, arrowprops=None, **kwargs): DCNL DCSP if (xytext is None): DCNL DCSP  DCSP xytext = xy DCNL DCSP if (textcoords is None): DCNL DCSP  DCSP textcoords = xycoords DCNL DCSP (x, y) = self.xytext = xytext DCNL DCSP Text.__init__(self, x, y, s, **kwargs) DCNL DCSP self.xy = xy DCNL DCSP self.xycoords = xycoords DCNL DCSP self.textcoords = textcoords DCNL DCSP self.arrowprops = arrowprops DCNL DCSP self.arrow = None DCNL DCSP if (arrowprops and arrowprops.has_key('arrowstyle')): DCNL DCSP  DCSP self._arrow_relpos = arrowprops.pop('relpos', (0.5, 0.5)) DCNL DCSP  DCSP self.arrow_patch = FancyArrowPatch((0, 0), (1, 1), **arrowprops) DCNL DCSP else: DCNL DCSP  DCSP self.arrow_patch = None
def draw(self, renderer): DCNL DCSP self.update_positions(renderer) DCNL DCSP self.update_bbox_position_size(renderer) DCNL DCSP if (self.arrow is not None): DCNL DCSP  DCSP if ((self.arrow.figure is None) and (self.figure is not None)): DCNL DCSP  DCSP  DCSP self.arrow.figure = self.figure DCNL DCSP  DCSP self.arrow.draw(renderer) DCNL DCSP if (self.arrow_patch is not None): DCNL DCSP  DCSP if ((self.arrow_patch.figure is None) and (self.figure is not None)): DCNL DCSP  DCSP  DCSP self.arrow_patch.figure = self.figure DCNL DCSP  DCSP self.arrow_patch.draw(renderer) DCNL DCSP Text.draw(self, renderer)
def __call__(self, o): DCNL DCSP if (not self.available(o)): DCNL DCSP  DCSP raise ValueError('already DCSP locked') DCNL DCSP self._owner = o
def release(self, o): DCNL DCSP if (not self.available(o)): DCNL DCSP  DCSP raise ValueError('you DCSP do DCSP not DCSP own DCSP this DCSP lock') DCNL DCSP self._owner = None
def available(self, o): DCNL DCSP return ((not self.locked()) or self.isowner(o))
def isowner(self, o): DCNL DCSP return (self._owner is o)
def locked(self): DCNL DCSP return (self._owner is not None)
def __init__(self, ax, label, image=None, color='0.85', hovercolor='0.95'): DCNL DCSP if (image is not None): DCNL DCSP  DCSP ax.imshow(image) DCNL DCSP self.label = ax.text(0.5, 0.5, label, verticalalignment='center', horizontalalignment='center', transform=ax.transAxes) DCNL DCSP self.cnt = 0 DCNL DCSP self.observers = {} DCNL DCSP self.ax = ax DCNL DCSP ax.figure.canvas.mpl_connect('button_press_event', self._click) DCNL DCSP ax.figure.canvas.mpl_connect('motion_notify_event', self._motion) DCNL DCSP ax.set_navigate(False) DCNL DCSP ax.set_axis_bgcolor(color) DCNL DCSP ax.set_xticks([]) DCNL DCSP ax.set_yticks([]) DCNL DCSP self.color = color DCNL DCSP self.hovercolor = hovercolor DCNL DCSP self._lastcolor = color
def on_clicked(self, func): DCNL DCSP cid = self.cnt DCNL DCSP self.observers[cid] = func DCNL DCSP self.cnt += 1 DCNL DCSP return cid
def disconnect(self, cid): DCNL DCSP try: DCNL DCSP  DCSP del self.observers[cid] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass
def __init__(self, ax, label, valmin, valmax, valinit=0.5, valfmt='%1.2f', closedmin=True, closedmax=True, slidermin=None, slidermax=None, dragging=True, **kwargs): DCNL DCSP self.ax = ax DCNL DCSP self.valmin = valmin DCNL DCSP self.valmax = valmax DCNL DCSP self.val = valinit DCNL DCSP self.valinit = valinit DCNL DCSP self.poly = ax.axvspan(valmin, valinit, 0, 1, **kwargs) DCNL DCSP self.vline = ax.axvline(valinit, 0, 1, color='r', lw=1) DCNL DCSP self.valfmt = valfmt DCNL DCSP ax.set_yticks([]) DCNL DCSP ax.set_xlim((valmin, valmax)) DCNL DCSP ax.set_xticks([]) DCNL DCSP ax.set_navigate(False) DCNL DCSP ax.figure.canvas.mpl_connect('button_press_event', self._update) DCNL DCSP if dragging: DCNL DCSP  DCSP ax.figure.canvas.mpl_connect('motion_notify_event', self._update) DCNL DCSP self.label = ax.text((-0.02), 0.5, label, transform=ax.transAxes, verticalalignment='center', horizontalalignment='right') DCNL DCSP self.valtext = ax.text(1.02, 0.5, (valfmt % valinit), transform=ax.transAxes, verticalalignment='center', horizontalalignment='left') DCNL DCSP self.cnt = 0 DCNL DCSP self.observers = {} DCNL DCSP self.closedmin = closedmin DCNL DCSP self.closedmax = closedmax DCNL DCSP self.slidermin = slidermin DCNL DCSP self.slidermax = slidermax
def _update(self, event): DCNL DCSP if (event.button != 1): DCNL DCSP  DCSP return DCNL DCSP if (event.inaxes != self.ax): DCNL DCSP  DCSP return DCNL DCSP val = event.xdata DCNL DCSP if ((not self.closedmin) and (val <= self.valmin)): DCNL DCSP  DCSP return DCNL DCSP if ((not self.closedmax) and (val >= self.valmax)): DCNL DCSP  DCSP return DCNL DCSP if (self.slidermin is not None): DCNL DCSP  DCSP if (val <= self.slidermin.val): DCNL DCSP  DCSP  DCSP return DCNL DCSP if (self.slidermax is not None): DCNL DCSP  DCSP if (val >= self.slidermax.val): DCNL DCSP  DCSP  DCSP return DCNL DCSP self.set_val(val)
def on_changed(self, func): DCNL DCSP cid = self.cnt DCNL DCSP self.observers[cid] = func DCNL DCSP self.cnt += 1 DCNL DCSP return cid
def disconnect(self, cid): DCNL DCSP try: DCNL DCSP  DCSP del self.observers[cid] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass
def reset(self): DCNL DCSP if (self.val != self.valinit): DCNL DCSP  DCSP self.set_val(self.valinit)
def __init__(self, ax, labels, actives): DCNL DCSP ax.set_xticks([]) DCNL DCSP ax.set_yticks([]) DCNL DCSP ax.set_navigate(False) DCNL DCSP if (len(labels) > 1): DCNL DCSP  DCSP dy = (1.0 / (len(labels) + 1)) DCNL DCSP  DCSP ys = np.linspace((1 - dy), dy, len(labels)) DCNL DCSP else: DCNL DCSP  DCSP dy = 0.25 DCNL DCSP  DCSP ys = [0.5] DCNL DCSP cnt = 0 DCNL DCSP axcolor = ax.get_axis_bgcolor() DCNL DCSP self.labels = [] DCNL DCSP self.lines = [] DCNL DCSP self.rectangles = [] DCNL DCSP lineparams = {'color': 'k', 'linewidth': 1.25, 'transform': ax.transAxes, 'solid_capstyle': 'butt'} DCNL DCSP for (y, label) in zip(ys, labels): DCNL DCSP  DCSP t = ax.text(0.25, y, label, transform=ax.transAxes, horizontalalignment='left', verticalalignment='center') DCNL DCSP  DCSP (w, h) = ((dy / 2.0), (dy / 2.0)) DCNL DCSP  DCSP (x, y) = (0.05, (y - (h / 2.0))) DCNL DCSP  DCSP p = Rectangle(xy=(x, y), width=w, height=h, facecolor=axcolor, transform=ax.transAxes) DCNL DCSP  DCSP l1 = Line2D([x, (x + w)], [(y + h), y], **lineparams) DCNL DCSP  DCSP l2 = Line2D([x, (x + w)], [y, (y + h)], **lineparams) DCNL DCSP  DCSP l1.set_visible(actives[cnt]) DCNL DCSP  DCSP l2.set_visible(actives[cnt]) DCNL DCSP  DCSP self.labels.append(t) DCNL DCSP  DCSP self.rectangles.append(p) DCNL DCSP  DCSP self.lines.append((l1, l2)) DCNL DCSP  DCSP ax.add_patch(p) DCNL DCSP  DCSP ax.add_line(l1) DCNL DCSP  DCSP ax.add_line(l2) DCNL DCSP  DCSP cnt += 1 DCNL DCSP ax.figure.canvas.mpl_connect('button_press_event', self._clicked) DCNL DCSP self.ax = ax DCNL DCSP self.cnt = 0 DCNL DCSP self.observers = {}
def on_clicked(self, func): DCNL DCSP cid = self.cnt DCNL DCSP self.observers[cid] = func DCNL DCSP self.cnt += 1 DCNL DCSP return cid
def disconnect(self, cid): DCNL DCSP try: DCNL DCSP  DCSP del self.observers[cid] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass
def __init__(self, ax, labels, active=0, activecolor='blue'): DCNL DCSP self.activecolor = activecolor DCNL DCSP ax.set_xticks([]) DCNL DCSP ax.set_yticks([]) DCNL DCSP ax.set_navigate(False) DCNL DCSP dy = (1.0 / (len(labels) + 1)) DCNL DCSP ys = np.linspace((1 - dy), dy, len(labels)) DCNL DCSP cnt = 0 DCNL DCSP axcolor = ax.get_axis_bgcolor() DCNL DCSP self.labels = [] DCNL DCSP self.circles = [] DCNL DCSP for (y, label) in zip(ys, labels): DCNL DCSP  DCSP t = ax.text(0.25, y, label, transform=ax.transAxes, horizontalalignment='left', verticalalignment='center') DCNL DCSP  DCSP if (cnt == active): DCNL DCSP  DCSP  DCSP facecolor = activecolor DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP facecolor = axcolor DCNL DCSP  DCSP p = Circle(xy=(0.15, y), radius=0.05, facecolor=facecolor, transform=ax.transAxes) DCNL DCSP  DCSP self.labels.append(t) DCNL DCSP  DCSP self.circles.append(p) DCNL DCSP  DCSP ax.add_patch(p) DCNL DCSP  DCSP cnt += 1 DCNL DCSP ax.figure.canvas.mpl_connect('button_press_event', self._clicked) DCNL DCSP self.ax = ax DCNL DCSP self.cnt = 0 DCNL DCSP self.observers = {}
def on_clicked(self, func): DCNL DCSP cid = self.cnt DCNL DCSP self.observers[cid] = func DCNL DCSP self.cnt += 1 DCNL DCSP return cid
def disconnect(self, cid): DCNL DCSP try: DCNL DCSP  DCSP del self.observers[cid] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass
def __init__(self, targetfig, toolfig): DCNL DCSP self.targetfig = targetfig DCNL DCSP toolfig.subplots_adjust(left=0.2, right=0.9) DCNL DCSP class toolbarfmt: DCNL DCSP  DCSP def __init__(self, slider): DCNL DCSP  DCSP  DCSP self.slider = slider DCNL DCSP  DCSP def __call__(self, x, y): DCNL DCSP  DCSP  DCSP fmt = ('%s=%s' % (self.slider.label.get_text(), self.slider.valfmt)) DCNL DCSP  DCSP  DCSP return (fmt % x) DCNL DCSP self.axleft = toolfig.add_subplot(711) DCNL DCSP self.axleft.set_title('Click DCSP on DCSP slider DCSP to DCSP adjust DCSP subplot DCSP param') DCNL DCSP self.axleft.set_navigate(False) DCNL DCSP self.sliderleft = Slider(self.axleft, 'left', 0, 1, targetfig.subplotpars.left, closedmax=False) DCNL DCSP self.sliderleft.on_changed(self.funcleft) DCNL DCSP self.axbottom = toolfig.add_subplot(712) DCNL DCSP self.axbottom.set_navigate(False) DCNL DCSP self.sliderbottom = Slider(self.axbottom, 'bottom', 0, 1, targetfig.subplotpars.bottom, closedmax=False) DCNL DCSP self.sliderbottom.on_changed(self.funcbottom) DCNL DCSP self.axright = toolfig.add_subplot(713) DCNL DCSP self.axright.set_navigate(False) DCNL DCSP self.sliderright = Slider(self.axright, 'right', 0, 1, targetfig.subplotpars.right, closedmin=False) DCNL DCSP self.sliderright.on_changed(self.funcright) DCNL DCSP self.axtop = toolfig.add_subplot(714) DCNL DCSP self.axtop.set_navigate(False) DCNL DCSP self.slidertop = Slider(self.axtop, 'top', 0, 1, targetfig.subplotpars.top, closedmin=False) DCNL DCSP self.slidertop.on_changed(self.functop) DCNL DCSP self.axwspace = toolfig.add_subplot(715) DCNL DCSP self.axwspace.set_navigate(False) DCNL DCSP self.sliderwspace = Slider(self.axwspace, 'wspace', 0, 1, targetfig.subplotpars.wspace, closedmax=False) DCNL DCSP self.sliderwspace.on_changed(self.funcwspace) DCNL DCSP self.axhspace = toolfig.add_subplot(716) DCNL DCSP self.axhspace.set_navigate(False) DCNL DCSP self.sliderhspace = Slider(self.axhspace, 'hspace', 0, 1, targetfig.subplotpars.hspace, closedmax=False) DCNL DCSP self.sliderhspace.on_changed(self.funchspace) DCNL DCSP self.sliderleft.slidermax = self.sliderright DCNL DCSP self.sliderright.slidermin = self.sliderleft DCNL DCSP self.sliderbottom.slidermax = self.slidertop DCNL DCSP self.slidertop.slidermin = self.sliderbottom DCNL DCSP bax = toolfig.add_axes([0.8, 0.05, 0.15, 0.075]) DCNL DCSP self.buttonreset = Button(bax, 'Reset') DCNL DCSP sliders = (self.sliderleft, self.sliderbottom, self.sliderright, self.slidertop, self.sliderwspace, self.sliderhspace) DCNL DCSP def func(event): DCNL DCSP  DCSP thisdrawon = self.drawon DCNL DCSP  DCSP self.drawon = False DCNL DCSP  DCSP bs = [] DCNL DCSP  DCSP for slider in sliders: DCNL DCSP  DCSP  DCSP bs.append(slider.drawon) DCNL DCSP  DCSP  DCSP slider.drawon = False DCNL DCSP  DCSP for slider in sliders: DCNL DCSP  DCSP  DCSP slider.reset() DCNL DCSP  DCSP for (slider, b) in zip(sliders, bs): DCNL DCSP  DCSP  DCSP slider.drawon = b DCNL DCSP  DCSP self.drawon = thisdrawon DCNL DCSP  DCSP if self.drawon: DCNL DCSP  DCSP  DCSP toolfig.canvas.draw() DCNL DCSP  DCSP  DCSP self.targetfig.canvas.draw() DCNL DCSP validate = toolfig.subplotpars.validate DCNL DCSP toolfig.subplotpars.validate = False DCNL DCSP self.buttonreset.on_clicked(func) DCNL DCSP toolfig.subplotpars.validate = validate
def __init__(self, ax, useblit=False, **lineprops): DCNL DCSP self.ax = ax DCNL DCSP self.canvas = ax.figure.canvas DCNL DCSP self.canvas.mpl_connect('motion_notify_event', self.onmove) DCNL DCSP self.canvas.mpl_connect('draw_event', self.clear) DCNL DCSP self.visible = True DCNL DCSP self.horizOn = True DCNL DCSP self.vertOn = True DCNL DCSP self.useblit = useblit DCNL DCSP self.lineh = ax.axhline(ax.get_ybound()[0], visible=False, **lineprops) DCNL DCSP self.linev = ax.axvline(ax.get_xbound()[0], visible=False, **lineprops) DCNL DCSP self.background = None DCNL DCSP self.needclear = False
def clear(self, event): DCNL DCSP if self.useblit: DCNL DCSP  DCSP self.background = self.canvas.copy_from_bbox(self.ax.bbox) DCNL DCSP self.linev.set_visible(False) DCNL DCSP self.lineh.set_visible(False)
def onmove(self, event): DCNL DCSP if (event.inaxes != self.ax): DCNL DCSP  DCSP self.linev.set_visible(False) DCNL DCSP  DCSP self.lineh.set_visible(False) DCNL DCSP  DCSP if self.needclear: DCNL DCSP  DCSP  DCSP self.canvas.draw() DCNL DCSP  DCSP  DCSP self.needclear = False DCNL DCSP  DCSP return DCNL DCSP self.needclear = True DCNL DCSP if (not self.visible): DCNL DCSP  DCSP return DCNL DCSP self.linev.set_xdata((event.xdata, event.xdata)) DCNL DCSP self.lineh.set_ydata((event.ydata, event.ydata)) DCNL DCSP self.linev.set_visible((self.visible and self.vertOn)) DCNL DCSP self.lineh.set_visible((self.visible and self.horizOn)) DCNL DCSP self._update()
def clear(self, event): DCNL DCSP if self.useblit: DCNL DCSP  DCSP self.background = self.canvas.copy_from_bbox(self.canvas.figure.bbox) DCNL DCSP for line in self.lines: DCNL DCSP  DCSP line.set_visible(False)
def __init__(self, ax, onselect, direction, minspan=None, useblit=False, rectprops=None, onmove_callback=None): DCNL DCSP if (rectprops is None): DCNL DCSP  DCSP rectprops = dict(facecolor='red', alpha=0.5) DCNL DCSP assert (direction in ['horizontal', 'vertical']), 'Must DCSP choose DCSP horizontal DCSP or DCSP vertical DCSP for DCSP direction' DCNL DCSP self.direction = direction DCNL DCSP self.ax = None DCNL DCSP self.canvas = None DCNL DCSP self.visible = True DCNL DCSP self.cids = [] DCNL DCSP self.rect = None DCNL DCSP self.background = None DCNL DCSP self.pressv = None DCNL DCSP self.rectprops = rectprops DCNL DCSP self.onselect = onselect DCNL DCSP self.onmove_callback = onmove_callback DCNL DCSP self.useblit = useblit DCNL DCSP self.minspan = minspan DCNL DCSP self.buttonDown = False DCNL DCSP self.prev = (0, 0) DCNL DCSP self.new_axes(ax)
def update_background(self, event): DCNL DCSP if self.useblit: DCNL DCSP  DCSP self.background = self.canvas.copy_from_bbox(self.ax.bbox)
def ignore(self, event): DCNL DCSP return ((event.inaxes != self.ax) or (not self.visible) or (event.button != 1))
def press(self, event): DCNL DCSP if self.ignore(event): DCNL DCSP  DCSP return DCNL DCSP self.buttonDown = True DCNL DCSP self.rect.set_visible(self.visible) DCNL DCSP if (self.direction == 'horizontal'): DCNL DCSP  DCSP self.pressv = event.xdata DCNL DCSP else: DCNL DCSP  DCSP self.pressv = event.ydata DCNL DCSP return False
def release(self, event): DCNL DCSP if ((self.pressv is None) or (self.ignore(event) and (not self.buttonDown))): DCNL DCSP  DCSP return DCNL DCSP self.buttonDown = False DCNL DCSP self.rect.set_visible(False) DCNL DCSP self.canvas.draw() DCNL DCSP vmin = self.pressv DCNL DCSP if (self.direction == 'horizontal'): DCNL DCSP  DCSP vmax = (event.xdata or self.prev[0]) DCNL DCSP else: DCNL DCSP  DCSP vmax = (event.ydata or self.prev[1]) DCNL DCSP if (vmin > vmax): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP span = (vmax - vmin) DCNL DCSP if ((self.minspan is not None) and (span < self.minspan)): DCNL DCSP  DCSP return DCNL DCSP self.onselect(vmin, vmax) DCNL DCSP self.pressv = None DCNL DCSP return False
def update(self): DCNL DCSP if self.useblit: DCNL DCSP  DCSP if (self.background is not None): DCNL DCSP  DCSP  DCSP self.canvas.restore_region(self.background) DCNL DCSP  DCSP self.ax.draw_artist(self.rect) DCNL DCSP  DCSP self.canvas.blit(self.ax.bbox) DCNL DCSP else: DCNL DCSP  DCSP self.canvas.draw_idle() DCNL DCSP return False
def onmove(self, event): DCNL DCSP if ((self.pressv is None) or self.ignore(event)): DCNL DCSP  DCSP return DCNL DCSP (x, y) = (event.xdata, event.ydata) DCNL DCSP self.prev = (x, y) DCNL DCSP if (self.direction == 'horizontal'): DCNL DCSP  DCSP v = x DCNL DCSP else: DCNL DCSP  DCSP v = y DCNL DCSP (minv, maxv) = (v, self.pressv) DCNL DCSP if (minv > maxv): DCNL DCSP  DCSP (minv, maxv) = (maxv, minv) DCNL DCSP if (self.direction == 'horizontal'): DCNL DCSP  DCSP self.rect.set_x(minv) DCNL DCSP  DCSP self.rect.set_width((maxv - minv)) DCNL DCSP else: DCNL DCSP  DCSP self.rect.set_y(minv) DCNL DCSP  DCSP self.rect.set_height((maxv - minv)) DCNL DCSP if (self.onmove_callback is not None): DCNL DCSP  DCSP vmin = self.pressv DCNL DCSP  DCSP if (self.direction == 'horizontal'): DCNL DCSP  DCSP  DCSP vmax = (event.xdata or self.prev[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vmax = (event.ydata or self.prev[1]) DCNL DCSP  DCSP if (vmin > vmax): DCNL DCSP  DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP  DCSP self.onmove_callback(vmin, vmax) DCNL DCSP self.update() DCNL DCSP return False
def __init__(self, ax, onselect, drawtype='box', minspanx=None, minspany=None, useblit=False, lineprops=None, rectprops=None, spancoords='data'): DCNL DCSP self.ax = ax DCNL DCSP self.visible = True DCNL DCSP self.canvas = ax.figure.canvas DCNL DCSP self.canvas.mpl_connect('motion_notify_event', self.onmove) DCNL DCSP self.canvas.mpl_connect('button_press_event', self.press) DCNL DCSP self.canvas.mpl_connect('button_release_event', self.release) DCNL DCSP self.canvas.mpl_connect('draw_event', self.update_background) DCNL DCSP self.active = True DCNL DCSP self.to_draw = None DCNL DCSP self.background = None DCNL DCSP if (drawtype == 'none'): DCNL DCSP  DCSP drawtype = 'line' DCNL DCSP  DCSP self.visible = False DCNL DCSP if (drawtype == 'box'): DCNL DCSP  DCSP if (rectprops is None): DCNL DCSP  DCSP  DCSP rectprops = dict(facecolor='white', edgecolor='black', alpha=0.5, fill=False) DCNL DCSP  DCSP self.rectprops = rectprops DCNL DCSP  DCSP self.to_draw = Rectangle((0, 0), 0, 1, visible=False, **self.rectprops) DCNL DCSP  DCSP self.ax.add_patch(self.to_draw) DCNL DCSP if (drawtype == 'line'): DCNL DCSP  DCSP if (lineprops is None): DCNL DCSP  DCSP  DCSP lineprops = dict(color='black', linestyle='-', linewidth=2, alpha=0.5) DCNL DCSP  DCSP self.lineprops = lineprops DCNL DCSP  DCSP self.to_draw = Line2D([0, 0], [0, 0], visible=False, **self.lineprops) DCNL DCSP  DCSP self.ax.add_line(self.to_draw) DCNL DCSP self.onselect = onselect DCNL DCSP self.useblit = useblit DCNL DCSP self.minspanx = minspanx DCNL DCSP self.minspany = minspany DCNL DCSP assert (spancoords in ('data', 'pixels')) DCNL DCSP self.spancoords = spancoords DCNL DCSP self.drawtype = drawtype DCNL DCSP self.eventpress = None DCNL DCSP self.eventrelease = None
def update_background(self, event): DCNL DCSP if self.useblit: DCNL DCSP  DCSP self.background = self.canvas.copy_from_bbox(self.ax.bbox)
def ignore(self, event): DCNL DCSP if (not self.active): DCNL DCSP  DCSP return True DCNL DCSP if (not self.canvas.widgetlock.available(self)): DCNL DCSP  DCSP return True DCNL DCSP if (self.eventpress == None): DCNL DCSP  DCSP return (event.inaxes != self.ax) DCNL DCSP return ((event.inaxes != self.ax) or (event.button != self.eventpress.button))
def press(self, event): DCNL DCSP if self.ignore(event): DCNL DCSP  DCSP return DCNL DCSP self.to_draw.set_visible(self.visible) DCNL DCSP self.eventpress = event DCNL DCSP return False
def release(self, event): DCNL DCSP if ((self.eventpress is None) or self.ignore(event)): DCNL DCSP  DCSP return DCNL DCSP self.to_draw.set_visible(False) DCNL DCSP self.canvas.draw() DCNL DCSP self.eventrelease = event DCNL DCSP if (self.spancoords == 'data'): DCNL DCSP  DCSP (xmin, ymin) = (self.eventpress.xdata, self.eventpress.ydata) DCNL DCSP  DCSP (xmax, ymax) = (self.eventrelease.xdata, self.eventrelease.ydata) DCNL DCSP elif (self.spancoords == 'pixels'): DCNL DCSP  DCSP (xmin, ymin) = (self.eventpress.x, self.eventpress.y) DCNL DCSP  DCSP (xmax, ymax) = (self.eventrelease.x, self.eventrelease.y) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('spancoords DCSP must DCSP be DCSP "data" DCSP or DCSP "pixels"') DCNL DCSP if (xmin > xmax): DCNL DCSP  DCSP (xmin, xmax) = (xmax, xmin) DCNL DCSP if (ymin > ymax): DCNL DCSP  DCSP (ymin, ymax) = (ymax, ymin) DCNL DCSP spanx = (xmax - xmin) DCNL DCSP spany = (ymax - ymin) DCNL DCSP xproblems = ((self.minspanx is not None) and (spanx < self.minspanx)) DCNL DCSP yproblems = ((self.minspany is not None) and (spany < self.minspany)) DCNL DCSP if ((self.drawtype == 'box') and (xproblems or yproblems)): DCNL DCSP  DCSP 'Box DCSP to DCSP small' DCNL DCSP  DCSP return DCNL DCSP if ((self.drawtype == 'line') and (xproblems and yproblems)): DCNL DCSP  DCSP 'Line DCSP to DCSP small' DCNL DCSP  DCSP return DCNL DCSP self.onselect(self.eventpress, self.eventrelease) DCNL DCSP self.eventpress = None DCNL DCSP self.eventrelease = None DCNL DCSP return False
def update(self): DCNL DCSP if self.useblit: DCNL DCSP  DCSP if (self.background is not None): DCNL DCSP  DCSP  DCSP self.canvas.restore_region(self.background) DCNL DCSP  DCSP self.ax.draw_artist(self.to_draw) DCNL DCSP  DCSP self.canvas.blit(self.ax.bbox) DCNL DCSP else: DCNL DCSP  DCSP self.canvas.draw_idle() DCNL DCSP return False
def onmove(self, event): DCNL DCSP if ((self.eventpress is None) or self.ignore(event)): DCNL DCSP  DCSP return DCNL DCSP (x, y) = (event.xdata, event.ydata) DCNL DCSP if (self.drawtype == 'box'): DCNL DCSP  DCSP (minx, maxx) = (self.eventpress.xdata, x) DCNL DCSP  DCSP (miny, maxy) = (self.eventpress.ydata, y) DCNL DCSP  DCSP if (minx > maxx): DCNL DCSP  DCSP  DCSP (minx, maxx) = (maxx, minx) DCNL DCSP  DCSP if (miny > maxy): DCNL DCSP  DCSP  DCSP (miny, maxy) = (maxy, miny) DCNL DCSP  DCSP self.to_draw.set_x(minx) DCNL DCSP  DCSP self.to_draw.set_y(miny) DCNL DCSP  DCSP self.to_draw.set_width((maxx - minx)) DCNL DCSP  DCSP self.to_draw.set_height((maxy - miny)) DCNL DCSP  DCSP self.update() DCNL DCSP  DCSP return False DCNL DCSP if (self.drawtype == 'line'): DCNL DCSP  DCSP self.to_draw.set_data([self.eventpress.xdata, x], [self.eventpress.ydata, y]) DCNL DCSP  DCSP self.update() DCNL DCSP  DCSP return False
def set_active(self, active): DCNL DCSP self.active = active
def get_active(self): DCNL DCSP return self.active
def __init__(self, majloc=None, minloc=None, majfmt=None, minfmt=None, label=None): DCNL DCSP self.majloc = majloc DCNL DCSP self.minloc = minloc DCNL DCSP self.majfmt = majfmt DCNL DCSP self.minfmt = minfmt DCNL DCSP self.label = label
def axisinfo(unit): DCNL DCSP return None
def default_units(x): DCNL DCSP return None
def convert(obj, unit): DCNL DCSP return obj
def is_numlike(x): DCNL DCSP if iterable(x): DCNL DCSP  DCSP for thisx in x: DCNL DCSP  DCSP  DCSP return is_numlike(thisx) DCNL DCSP else: DCNL DCSP  DCSP return is_numlike(x)
def get_converter(self, x): DCNL DCSP if (not len(self)): DCNL DCSP  DCSP return None DCNL DCSP converter = None DCNL DCSP classx = getattr(x, '__class__', None) DCNL DCSP if (classx is not None): DCNL DCSP  DCSP converter = self.get(classx) DCNL DCSP if ((converter is None) and iterable(x)): DCNL DCSP  DCSP if (isinstance(x, np.ndarray) and (x.dtype != np.object)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP for thisx in x: DCNL DCSP  DCSP  DCSP converter = self.get_converter(thisx) DCNL DCSP  DCSP  DCSP return converter DCNL DCSP return converter
def __init__(self, fmt): DCNL DCSP self.fmt = fmt
def __call__(self, s): DCNL DCSP return date2num(datetime.datetime(*time.strptime(s, self.fmt)[:6]))
def __init__(self, fmt, tz=None): DCNL DCSP if (tz is None): DCNL DCSP  DCSP tz = _get_rc_timezone() DCNL DCSP self.fmt = fmt DCNL DCSP self.tz = tz
def __init__(self, t, fmt, tz=None): DCNL DCSP if (tz is None): DCNL DCSP  DCSP tz = _get_rc_timezone() DCNL DCSP self.t = t DCNL DCSP self.fmt = fmt DCNL DCSP self.tz = tz
def __call__(self, x, pos=0): DCNL DCSP ind = int(round(x)) DCNL DCSP if ((ind >= len(self.t)) or (ind <= 0)): DCNL DCSP  DCSP return '' DCNL DCSP dt = num2date(self.t[ind], self.tz) DCNL DCSP return cbook.unicode_safe(dt.strftime(self.fmt))
def __init__(self, tz=None): DCNL DCSP if (tz is None): DCNL DCSP  DCSP tz = _get_rc_timezone() DCNL DCSP self.tz = tz
def _get_unit(self): DCNL DCSP return 1
def _get_unit(self): DCNL DCSP freq = self.rule._rrule._freq DCNL DCSP if (freq == YEARLY): DCNL DCSP  DCSP return 365 DCNL DCSP elif (freq == MONTHLY): DCNL DCSP  DCSP return 30 DCNL DCSP elif (freq == WEEKLY): DCNL DCSP  DCSP return 7 DCNL DCSP elif (freq == DAILY): DCNL DCSP  DCSP return 1 DCNL DCSP elif (freq == HOURLY): DCNL DCSP  DCSP return (1.0 / 24.0) DCNL DCSP elif (freq == MINUTELY): DCNL DCSP  DCSP return (1.0 / (24 * 60)) DCNL DCSP elif (freq == SECONDLY): DCNL DCSP  DCSP return (1.0 / (24 * 3600)) DCNL DCSP else: DCNL DCSP  DCSP return (-1)
def autoscale(self): DCNL DCSP (dmin, dmax) = self.datalim_to_dt() DCNL DCSP if (dmin > dmax): DCNL DCSP  DCSP (dmax, dmin) = (dmin, dmax) DCNL DCSP delta = relativedelta(dmax, dmin) DCNL DCSP self.rule.set(dtstart=(dmin - delta), until=(dmax + delta)) DCNL DCSP (dmin, dmax) = self.datalim_to_dt() DCNL DCSP vmin = self.rule.before(dmin, True) DCNL DCSP if (not vmin): DCNL DCSP  DCSP vmin = dmin DCNL DCSP vmax = self.rule.after(dmax, True) DCNL DCSP if (not vmax): DCNL DCSP  DCSP vmax = dmax DCNL DCSP vmin = date2num(vmin) DCNL DCSP vmax = date2num(vmax) DCNL DCSP return self.nonsingular(vmin, vmax)
def __call__(self): DCNL DCSP self.refresh() DCNL DCSP return self._locator()
def refresh(self): DCNL DCSP (dmin, dmax) = self.viewlim_to_dt() DCNL DCSP self._locator = self.get_locator(dmin, dmax)
def autoscale(self): DCNL DCSP (dmin, dmax) = self.datalim_to_dt() DCNL DCSP self._locator = self.get_locator(dmin, dmax) DCNL DCSP return self._locator.autoscale()
def get_locator(self, dmin, dmax): DCNL DCSP delta = relativedelta(dmax, dmin) DCNL DCSP numYears = (delta.years * 1.0) DCNL DCSP numMonths = ((numYears * 12.0) + delta.months) DCNL DCSP numDays = ((numMonths * 31.0) + delta.days) DCNL DCSP numHours = ((numDays * 24.0) + delta.hours) DCNL DCSP numMinutes = ((numHours * 60.0) + delta.minutes) DCNL DCSP numSeconds = ((numMinutes * 60.0) + delta.seconds) DCNL DCSP numticks = 5 DCNL DCSP interval = 1 DCNL DCSP bymonth = 1 DCNL DCSP bymonthday = 1 DCNL DCSP byhour = 0 DCNL DCSP byminute = 0 DCNL DCSP bysecond = 0 DCNL DCSP if (numYears >= numticks): DCNL DCSP  DCSP self._freq = YEARLY DCNL DCSP elif (numMonths >= numticks): DCNL DCSP  DCSP self._freq = MONTHLY DCNL DCSP  DCSP bymonth = range(1, 13) DCNL DCSP  DCSP if ((0 <= numMonths) and (numMonths <= 14)): DCNL DCSP  DCSP  DCSP interval = 1 DCNL DCSP  DCSP elif ((15 <= numMonths) and (numMonths <= 29)): DCNL DCSP  DCSP  DCSP interval = 3 DCNL DCSP  DCSP elif ((30 <= numMonths) and (numMonths <= 44)): DCNL DCSP  DCSP  DCSP interval = 4 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP interval = 6 DCNL DCSP elif (numDays >= numticks): DCNL DCSP  DCSP self._freq = DAILY DCNL DCSP  DCSP bymonth = None DCNL DCSP  DCSP bymonthday = range(1, 32) DCNL DCSP  DCSP if ((0 <= numDays) and (numDays <= 9)): DCNL DCSP  DCSP  DCSP interval = 1 DCNL DCSP  DCSP elif ((10 <= numDays) and (numDays <= 19)): DCNL DCSP  DCSP  DCSP interval = 2 DCNL DCSP  DCSP elif ((20 <= numDays) and (numDays <= 49)): DCNL DCSP  DCSP  DCSP interval = 3 DCNL DCSP  DCSP elif ((50 <= numDays) and (numDays <= 99)): DCNL DCSP  DCSP  DCSP interval = 7 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP interval = 14 DCNL DCSP elif (numHours >= numticks): DCNL DCSP  DCSP self._freq = HOURLY DCNL DCSP  DCSP bymonth = None DCNL DCSP  DCSP bymonthday = None DCNL DCSP  DCSP byhour = range(0, 24) DCNL DCSP  DCSP if ((0 <= numHours) and (numHours <= 14)): DCNL DCSP  DCSP  DCSP interval = 1 DCNL DCSP  DCSP elif ((15 <= numHours) and (numHours <= 30)): DCNL DCSP  DCSP  DCSP interval = 2 DCNL DCSP  DCSP elif ((30 <= numHours) and (numHours <= 45)): DCNL DCSP  DCSP  DCSP interval = 3 DCNL DCSP  DCSP elif ((45 <= numHours) and (numHours <= 68)): DCNL DCSP  DCSP  DCSP interval = 4 DCNL DCSP  DCSP elif ((68 <= numHours) and (numHours <= 90)): DCNL DCSP  DCSP  DCSP interval = 6 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP interval = 12 DCNL DCSP elif (numMinutes >= numticks): DCNL DCSP  DCSP self._freq = MINUTELY DCNL DCSP  DCSP bymonth = None DCNL DCSP  DCSP bymonthday = None DCNL DCSP  DCSP byhour = None DCNL DCSP  DCSP byminute = range(0, 60) DCNL DCSP  DCSP if (numMinutes > (10.0 * numticks)): DCNL DCSP  DCSP  DCSP interval = 10 DCNL DCSP elif (numSeconds >= numticks): DCNL DCSP  DCSP self._freq = SECONDLY DCNL DCSP  DCSP bymonth = None DCNL DCSP  DCSP bymonthday = None DCNL DCSP  DCSP byhour = None DCNL DCSP  DCSP byminute = None DCNL DCSP  DCSP bysecond = range(0, 60) DCNL DCSP  DCSP if (numSeconds > (10.0 * numticks)): DCNL DCSP  DCSP  DCSP interval = 10 DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP rrule = rrulewrapper(self._freq, interval=interval, dtstart=dmin, until=dmax, bymonth=bymonth, bymonthday=bymonthday, byhour=byhour, byminute=byminute, bysecond=bysecond) DCNL DCSP locator = RRuleLocator(rrule, self.tz) DCNL DCSP locator.set_axis(self.axis) DCNL DCSP locator.set_view_interval(*self.axis.get_view_interval()) DCNL DCSP locator.set_data_interval(*self.axis.get_data_interval()) DCNL DCSP return locator
def __init__(self, base=1, month=1, day=1, tz=None): DCNL DCSP DateLocator.__init__(self, tz) DCNL DCSP self.base = ticker.Base(base) DCNL DCSP self.replaced = {'month': month, 'day': day, 'hour': 0, 'minute': 0, 'second': 0, 'tzinfo': tz}
def _get_unit(self): DCNL DCSP return 365
def autoscale(self): DCNL DCSP (dmin, dmax) = self.datalim_to_dt() DCNL DCSP ymin = self.base.le(dmin.year) DCNL DCSP ymax = self.base.ge(dmax.year) DCNL DCSP vmin = dmin.replace(year=ymin, **self.replaced) DCNL DCSP vmax = dmax.replace(year=ymax, **self.replaced) DCNL DCSP vmin = date2num(vmin) DCNL DCSP vmax = date2num(vmax) DCNL DCSP return self.nonsingular(vmin, vmax)
def __init__(self, bymonth=None, bymonthday=1, interval=1, tz=None): DCNL DCSP if (bymonth is None): DCNL DCSP  DCSP bymonth = range(1, 13) DCNL DCSP o = rrulewrapper(MONTHLY, bymonth=bymonth, bymonthday=bymonthday, interval=interval, **self.hms0d) DCNL DCSP RRuleLocator.__init__(self, o, tz)
def _get_unit(self): DCNL DCSP return 30
def __init__(self, byweekday=1, interval=1, tz=None): DCNL DCSP o = rrulewrapper(DAILY, byweekday=byweekday, interval=interval, **self.hms0d) DCNL DCSP RRuleLocator.__init__(self, o, tz)
def _get_unit(self): DCNL DCSP return 7
def __init__(self, bymonthday=None, interval=1, tz=None): DCNL DCSP if (bymonthday is None): DCNL DCSP  DCSP bymonthday = range(1, 32) DCNL DCSP o = rrulewrapper(DAILY, bymonthday=bymonthday, interval=interval, **self.hms0d) DCNL DCSP RRuleLocator.__init__(self, o, tz)
def _get_unit(self): DCNL DCSP return 1
def __init__(self, byhour=None, interval=1, tz=None): DCNL DCSP if (byhour is None): DCNL DCSP  DCSP byhour = range(24) DCNL DCSP rule = rrulewrapper(HOURLY, byhour=byhour, interval=interval, byminute=0, bysecond=0) DCNL DCSP RRuleLocator.__init__(self, rule, tz)
def _get_unit(self): DCNL DCSP return (1 / 24.0)
def __init__(self, byminute=None, interval=1, tz=None): DCNL DCSP if (byminute is None): DCNL DCSP  DCSP byminute = range(60) DCNL DCSP rule = rrulewrapper(MINUTELY, byminute=byminute, interval=interval, bysecond=0) DCNL DCSP RRuleLocator.__init__(self, rule, tz)
def _get_unit(self): DCNL DCSP return (1.0 / (24 * 60))
def __init__(self, bysecond=None, interval=1, tz=None): DCNL DCSP if (bysecond is None): DCNL DCSP  DCSP bysecond = range(60) DCNL DCSP rule = rrulewrapper(SECONDLY, bysecond=bysecond, interval=interval) DCNL DCSP RRuleLocator.__init__(self, rule, tz)
def _get_unit(self): DCNL DCSP return (1.0 / ((24 * 60) * 60))
def axisinfo(unit): DCNL DCSP if (unit == 'date'): DCNL DCSP  DCSP majloc = AutoDateLocator() DCNL DCSP  DCSP majfmt = AutoDateFormatter(majloc) DCNL DCSP  DCSP return units.AxisInfo(majloc=majloc, majfmt=majfmt, label='') DCNL DCSP else: DCNL DCSP  DCSP return None
def default_units(x): DCNL DCSP return 'date'
def set_figure(self, fig): DCNL DCSP martist.Artist.set_figure(self, fig) DCNL DCSP for c in self.get_children(): DCNL DCSP  DCSP c.set_figure(fig)
def set_offset(self, xy): DCNL DCSP self._offset = xy
def get_offset(self, width, height, xdescent, ydescent): DCNL DCSP if callable(self._offset): DCNL DCSP  DCSP return self._offset(width, height, xdescent, ydescent) DCNL DCSP else: DCNL DCSP  DCSP return self._offset
def set_width(self, width): DCNL DCSP self.width = width
def set_height(self, height): DCNL DCSP self.height = height
def get_children(self): DCNL DCSP return self._children
def get_extent(self, renderer): DCNL DCSP (w, h, xd, yd, offsets) = self.get_extent_offsets(renderer) DCNL DCSP return (w, h, xd, yd)
def get_window_extent(self, renderer): DCNL DCSP (w, h, xd, yd, offsets) = self.get_extent_offsets(renderer) DCNL DCSP (px, py) = self.get_offset(w, h, xd, yd) DCNL DCSP return mtransforms.Bbox.from_bounds((px - xd), (py - yd), w, h)
def draw(self, renderer): DCNL DCSP (width, height, xdescent, ydescent, offsets) = self.get_extent_offsets(renderer) DCNL DCSP (px, py) = self.get_offset(width, height, xdescent, ydescent) DCNL DCSP for (c, (ox, oy)) in zip(self.get_children(), offsets): DCNL DCSP  DCSP c.set_offset(((px + ox), (py + oy))) DCNL DCSP  DCSP c.draw(renderer) DCNL DCSP bbox_artist(self, renderer, fill=False, props=dict(pad=0.0))
def __init__(self, pad=None, sep=None, width=None, height=None, align=None, mode=None, children=None): DCNL DCSP super(PackerBase, self).__init__() DCNL DCSP self.height = height DCNL DCSP self.width = width DCNL DCSP self.sep = sep DCNL DCSP self.pad = pad DCNL DCSP self.mode = mode DCNL DCSP self.align = align DCNL DCSP self._children = children
def __init__(self, pad=None, sep=None, width=None, height=None, align='baseline', mode='fixed', children=None): DCNL DCSP super(VPacker, self).__init__(pad, sep, width, height, align, mode, children)
def get_extent_offsets(self, renderer): DCNL DCSP whd_list = [c.get_extent(renderer) for c in self.get_children()] DCNL DCSP whd_list = [(w, h, xd, (h - yd)) for (w, h, xd, yd) in whd_list] DCNL DCSP wd_list = [(w, xd) for (w, h, xd, yd) in whd_list] DCNL DCSP (width, xdescent, xoffsets) = _get_aligned_offsets(wd_list, self.width, self.align) DCNL DCSP pack_list = [(h, yd) for (w, h, xd, yd) in whd_list] DCNL DCSP (height, yoffsets_) = _get_packed_offsets(pack_list, self.height, self.sep, self.mode) DCNL DCSP yoffsets = (yoffsets_ + [yd for (w, h, xd, yd) in whd_list]) DCNL DCSP ydescent = (height - yoffsets[0]) DCNL DCSP yoffsets = (height - yoffsets) DCNL DCSP yoffsets = (yoffsets - ydescent) DCNL DCSP return ((width + (2 * self.pad)), (height + (2 * self.pad)), (xdescent + self.pad), (ydescent + self.pad), zip(xoffsets, yoffsets))
def __init__(self, pad=None, sep=None, width=None, height=None, align='baseline', mode='fixed', children=None): DCNL DCSP super(HPacker, self).__init__(pad, sep, width, height, align, mode, children)
def get_extent_offsets(self, renderer): DCNL DCSP whd_list = [c.get_extent(renderer) for c in self.get_children()] DCNL DCSP if (self.height is None): DCNL DCSP  DCSP height_descent = max([(h - yd) for (w, h, xd, yd) in whd_list]) DCNL DCSP  DCSP ydescent = max([yd for (w, h, xd, yd) in whd_list]) DCNL DCSP  DCSP height = (height_descent + ydescent) DCNL DCSP else: DCNL DCSP  DCSP height = (self.height - (2 * self._pad)) DCNL DCSP hd_list = [(h, yd) for (w, h, xd, yd) in whd_list] DCNL DCSP (height, ydescent, yoffsets) = _get_aligned_offsets(hd_list, self.height, self.align) DCNL DCSP pack_list = [(w, xd) for (w, h, xd, yd) in whd_list] DCNL DCSP (width, xoffsets_) = _get_packed_offsets(pack_list, self.width, self.sep, self.mode) DCNL DCSP xoffsets = (xoffsets_ + [xd for (w, h, xd, yd) in whd_list]) DCNL DCSP xdescent = whd_list[0][2] DCNL DCSP xoffsets = (xoffsets - xdescent) DCNL DCSP return ((width + (2 * self.pad)), (height + (2 * self.pad)), (xdescent + self.pad), (ydescent + self.pad), zip(xoffsets, yoffsets))
def __init__(self, width, height, xdescent=0.0, ydescent=0.0, clip=True): DCNL DCSP super(DrawingArea, self).__init__() DCNL DCSP self.width = width DCNL DCSP self.height = height DCNL DCSP self.xdescent = xdescent DCNL DCSP self.ydescent = ydescent DCNL DCSP self.offset_transform = mtransforms.Affine2D() DCNL DCSP self.offset_transform.clear() DCNL DCSP self.offset_transform.translate(0, 0)
def get_transform(self): DCNL DCSP return self.offset_transform
def set_transform(self, t): DCNL DCSP pass
def set_offset(self, xy): DCNL DCSP self._offset = xy DCNL DCSP self.offset_transform.clear() DCNL DCSP self.offset_transform.translate(xy[0], xy[1])
def get_offset(self): DCNL DCSP return self._offset
def get_window_extent(self, renderer): DCNL DCSP (w, h, xd, yd) = self.get_extent(renderer) DCNL DCSP (ox, oy) = self.get_offset() DCNL DCSP return mtransforms.Bbox.from_bounds((ox - xd), (oy - yd), w, h)
def get_extent(self, renderer): DCNL DCSP return (self.width, self.height, self.xdescent, self.ydescent)
def add_artist(self, a): DCNL DCSP self._children.append(a) DCNL DCSP a.set_transform(self.get_transform())
def draw(self, renderer): DCNL DCSP for c in self._children: DCNL DCSP  DCSP c.draw(renderer) DCNL DCSP bbox_artist(self, renderer, fill=False, props=dict(pad=0.0))
def __init__(self, s, textprops=None, multilinebaseline=None, minimumdescent=True): DCNL DCSP if (textprops is None): DCNL DCSP  DCSP textprops = {} DCNL DCSP if (not textprops.has_key('va')): DCNL DCSP  DCSP textprops['va'] = 'baseline' DCNL DCSP self._text = mtext.Text(0, 0, s, **textprops) DCNL DCSP OffsetBox.__init__(self) DCNL DCSP self._children = [self._text] DCNL DCSP self.offset_transform = mtransforms.Affine2D() DCNL DCSP self.offset_transform.clear() DCNL DCSP self.offset_transform.translate(0, 0) DCNL DCSP self._baseline_transform = mtransforms.Affine2D() DCNL DCSP self._text.set_transform((self.offset_transform + self._baseline_transform)) DCNL DCSP self._multilinebaseline = multilinebaseline DCNL DCSP self._minimumdescent = minimumdescent
def set_multilinebaseline(self, t): DCNL DCSP self._multilinebaseline = t
def get_multilinebaseline(self): DCNL DCSP return self._multilinebaseline
def set_minimumdescent(self, t): DCNL DCSP self._minimumdescent = t
def get_minimumdescent(self): DCNL DCSP return self._minimumdescent
def set_transform(self, t): DCNL DCSP pass
def set_offset(self, xy): DCNL DCSP self._offset = xy DCNL DCSP self.offset_transform.clear() DCNL DCSP self.offset_transform.translate(xy[0], xy[1])
def get_offset(self): DCNL DCSP return self._offset
def get_window_extent(self, renderer): DCNL DCSP (w, h, xd, yd) = self.get_extent(renderer) DCNL DCSP (ox, oy) = self.get_offset() DCNL DCSP return mtransforms.Bbox.from_bounds((ox - xd), (oy - yd), w, h)
def draw(self, renderer): DCNL DCSP self._text.draw(renderer) DCNL DCSP bbox_artist(self, renderer, fill=False, props=dict(pad=0.0))
def __call__(self, x, pos=None): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP overide')
def format_data_short(self, value): DCNL DCSP return self.format_data(value)
def fix_minus(self, s): DCNL DCSP return s
def __call__(self, x, pos=None): DCNL DCSP return ''
def __init__(self, seq): DCNL DCSP self.seq = seq DCNL DCSP self.offset_string = ''
def __call__(self, x, pos=None): DCNL DCSP if ((pos is None) or (pos >= len(self.seq))): DCNL DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP return self.seq[pos]
def __call__(self, x, pos=None): DCNL DCSP return self.func(x, pos)
def __call__(self, x, pos=None): DCNL DCSP return (self.fmt % x)
def __call__(self, x, pos=None): DCNL DCSP (xmin, xmax) = self.axis.get_view_interval() DCNL DCSP d = abs((xmax - xmin)) DCNL DCSP return self.pprint_val(x, d)
def fix_minus(self, s): DCNL DCSP if (rcParams['text.usetex'] or (not rcParams['axes.unicode_minus'])): DCNL DCSP  DCSP return s DCNL DCSP else: DCNL DCSP  DCSP return s.replace('-', u'\u2212')
def __call__(self, x, pos=None): DCNL DCSP if (len(self.locs) == 0): DCNL DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP s = self.pprint_val(x) DCNL DCSP  DCSP return self.fix_minus(s)
def set_scientific(self, b): DCNL DCSP self._scientific = bool(b)
def set_powerlimits(self, lims): DCNL DCSP assert (len(lims) == 2), 'argument DCSP must DCSP be DCSP a DCSP sequence DCSP of DCSP length DCSP 2' DCNL DCSP self._powerlimits = lims
def format_data_short(self, value): DCNL DCSP return ('%1.3g' % value)
def format_data(self, value): DCNL DCSP s = self._formatSciNotation(('%1.10e' % value)) DCNL DCSP return self.fix_minus(s)
def get_offset(self): DCNL DCSP if (len(self.locs) == 0): DCNL DCSP  DCSP return '' DCNL DCSP s = '' DCNL DCSP if (self.orderOfMagnitude or self.offset): DCNL DCSP  DCSP offsetStr = '' DCNL DCSP  DCSP sciNotStr = '' DCNL DCSP  DCSP if self.offset: DCNL DCSP  DCSP  DCSP offsetStr = self.format_data(self.offset) DCNL DCSP  DCSP  DCSP if (self.offset > 0): DCNL DCSP  DCSP  DCSP  DCSP offsetStr = ('+' + offsetStr) DCNL DCSP  DCSP if self.orderOfMagnitude: DCNL DCSP  DCSP  DCSP if (self._usetex or self._useMathText): DCNL DCSP  DCSP  DCSP  DCSP sciNotStr = self.format_data((10 ** self.orderOfMagnitude)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sciNotStr = ('1e%d' % self.orderOfMagnitude) DCNL DCSP  DCSP if self._useMathText: DCNL DCSP  DCSP  DCSP if (sciNotStr != ''): DCNL DCSP  DCSP  DCSP  DCSP sciNotStr = ('\\times\\mathdefault{%s}' % sciNotStr) DCNL DCSP  DCSP  DCSP s = ''.join(('$', sciNotStr, '\\mathdefault{', offsetStr, '}$')) DCNL DCSP  DCSP elif self._usetex: DCNL DCSP  DCSP  DCSP if (sciNotStr != ''): DCNL DCSP  DCSP  DCSP  DCSP sciNotStr = ('\\times%s' % sciNotStr) DCNL DCSP  DCSP  DCSP s = ''.join(('$', sciNotStr, offsetStr, '$')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = ''.join((sciNotStr, offsetStr)) DCNL DCSP return self.fix_minus(s)
def set_locs(self, locs): DCNL DCSP self.locs = locs DCNL DCSP if (len(self.locs) > 0): DCNL DCSP  DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP  DCSP d = abs((vmax - vmin)) DCNL DCSP  DCSP if self._useOffset: DCNL DCSP  DCSP  DCSP self._set_offset(d) DCNL DCSP  DCSP self._set_orderOfMagnitude(d) DCNL DCSP  DCSP self._set_format()
def __init__(self, base=10.0, labelOnlyBase=True): DCNL DCSP self._base = (base + 0.0) DCNL DCSP self.labelOnlyBase = labelOnlyBase DCNL DCSP self.decadeOnly = True
def base(self, base): DCNL DCSP self._base = base
def label_minor(self, labelOnlyBase): DCNL DCSP self.labelOnlyBase = labelOnlyBase
def __call__(self, x, pos=None): DCNL DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP d = abs((vmax - vmin)) DCNL DCSP b = self._base DCNL DCSP if (x == 0.0): DCNL DCSP  DCSP return '0' DCNL DCSP sign = np.sign(x) DCNL DCSP fx = (math.log(abs(x)) / math.log(b)) DCNL DCSP isDecade = self.is_decade(fx) DCNL DCSP if ((not isDecade) and self.labelOnlyBase): DCNL DCSP  DCSP s = '' DCNL DCSP elif (x > 10000): DCNL DCSP  DCSP s = ('%1.0e' % x) DCNL DCSP elif (x < 1): DCNL DCSP  DCSP s = ('%1.0e' % x) DCNL DCSP else: DCNL DCSP  DCSP s = self.pprint_val(x, d) DCNL DCSP if (sign == (-1)): DCNL DCSP  DCSP s = ('-%s' % s) DCNL DCSP return self.fix_minus(s)
def format_data_short(self, value): DCNL DCSP return ('%1.3g' % value)
def __call__(self, x, pos=None): DCNL DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP (vmin, vmax) = mtransforms.nonsingular(vmin, vmax, expander=0.05) DCNL DCSP d = abs((vmax - vmin)) DCNL DCSP b = self._base DCNL DCSP if (x == 0): DCNL DCSP  DCSP return '0' DCNL DCSP sign = np.sign(x) DCNL DCSP fx = (math.log(abs(x)) / math.log(b)) DCNL DCSP isDecade = self.is_decade(fx) DCNL DCSP if ((not isDecade) and self.labelOnlyBase): DCNL DCSP  DCSP s = '' DCNL DCSP elif (fx > 10000): DCNL DCSP  DCSP s = ('%1.0e' % fx) DCNL DCSP elif (fx < 1): DCNL DCSP  DCSP s = ('%1.0e' % fx) DCNL DCSP else: DCNL DCSP  DCSP s = self.pprint_val(fx, d) DCNL DCSP if (sign == (-1)): DCNL DCSP  DCSP s = ('-%s' % s) DCNL DCSP return self.fix_minus(s)
def __call__(self, x, pos=None): DCNL DCSP b = self._base DCNL DCSP if (x == 0): DCNL DCSP  DCSP return '$0$' DCNL DCSP sign = np.sign(x) DCNL DCSP fx = (math.log(abs(x)) / math.log(b)) DCNL DCSP isDecade = self.is_decade(fx) DCNL DCSP usetex = rcParams['text.usetex'] DCNL DCSP if (sign == (-1)): DCNL DCSP  DCSP sign_string = '-' DCNL DCSP else: DCNL DCSP  DCSP sign_string = '' DCNL DCSP if ((not isDecade) and self.labelOnlyBase): DCNL DCSP  DCSP s = '' DCNL DCSP elif (not isDecade): DCNL DCSP  DCSP if usetex: DCNL DCSP  DCSP  DCSP s = ('$%s%d^{%.2f}$' % (sign_string, b, fx)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = ('$\\mathdefault{%s%d^{%.2f}}$' % (sign_string, b, fx)) DCNL DCSP elif usetex: DCNL DCSP  DCSP s = ('$%s%d^{%d}$' % (sign_string, b, self.nearest_long(fx))) DCNL DCSP else: DCNL DCSP  DCSP s = ('$\\mathdefault{%s%d^{%d}}$' % (sign_string, b, self.nearest_long(fx))) DCNL DCSP return s
def __call__(self): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def view_limits(self, vmin, vmax): DCNL DCSP return mtransforms.nonsingular(vmin, vmax)
def autoscale(self): DCNL DCSP return self.view_limits(*self.axis.get_view_interval())
def pan(self, numsteps): DCNL DCSP ticks = self() DCNL DCSP numticks = len(ticks) DCNL DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP (vmin, vmax) = mtransforms.nonsingular(vmin, vmax, expander=0.05) DCNL DCSP if (numticks > 2): DCNL DCSP  DCSP step = (numsteps * abs((ticks[0] - ticks[1]))) DCNL DCSP else: DCNL DCSP  DCSP d = abs((vmax - vmin)) DCNL DCSP  DCSP step = ((numsteps * d) / 6.0) DCNL DCSP vmin += step DCNL DCSP vmax += step DCNL DCSP self.axis.set_view_interval(vmin, vmax, ignore=True)
def zoom(self, direction): DCNL DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP (vmin, vmax) = mtransforms.nonsingular(vmin, vmax, expander=0.05) DCNL DCSP interval = abs((vmax - vmin)) DCNL DCSP step = ((0.1 * interval) * direction) DCNL DCSP self.axis.set_view_interval((vmin + step), (vmax - step), ignore=True)
def refresh(self): DCNL DCSP pass
def __init__(self, base, offset): DCNL DCSP self._base = base DCNL DCSP self.offset = offset
def __call__(self): DCNL DCSP (dmin, dmax) = self.axis.get_data_interval() DCNL DCSP return np.arange((dmin + self.offset), (dmax + 1), self._base)
def __call__(self): DCNL DCSP if (self.nbins is None): DCNL DCSP  DCSP return self.locs DCNL DCSP step = max(int((0.99 + (len(self.locs) / float(self.nbins)))), 1) DCNL DCSP return self.locs[::step]
def __call__(self): DCNL DCSP return []
def __init__(self, numticks=None, presets=None): DCNL DCSP self.numticks = numticks DCNL DCSP if (presets is None): DCNL DCSP  DCSP self.presets = {} DCNL DCSP else: DCNL DCSP  DCSP self.presets = presets
def __call__(self): DCNL DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP (vmin, vmax) = mtransforms.nonsingular(vmin, vmax, expander=0.05) DCNL DCSP if (vmax < vmin): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP if ((vmin, vmax) in self.presets): DCNL DCSP  DCSP return self.presets[(vmin, vmax)] DCNL DCSP if (self.numticks is None): DCNL DCSP  DCSP self._set_numticks() DCNL DCSP if (self.numticks == 0): DCNL DCSP  DCSP return [] DCNL DCSP ticklocs = np.linspace(vmin, vmax, self.numticks) DCNL DCSP return ticklocs
def view_limits(self, vmin, vmax): DCNL DCSP if (vmax < vmin): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP if (vmin == vmax): DCNL DCSP  DCSP vmin -= 1 DCNL DCSP  DCSP vmax += 1 DCNL DCSP (exponent, remainder) = divmod(math.log10((vmax - vmin)), 1) DCNL DCSP if (remainder < 0.5): DCNL DCSP  DCSP exponent -= 1 DCNL DCSP scale = (10 ** (- exponent)) DCNL DCSP vmin = (math.floor((scale * vmin)) / scale) DCNL DCSP vmax = (math.ceil((scale * vmax)) / scale) DCNL DCSP return mtransforms.nonsingular(vmin, vmax)
def lt(self, x): DCNL DCSP (d, m) = divmod(x, self._base) DCNL DCSP if (closeto(m, 0) and (not closeto((m / self._base), 1))): DCNL DCSP  DCSP return ((d - 1) * self._base) DCNL DCSP return (d * self._base)
def le(self, x): DCNL DCSP (d, m) = divmod(x, self._base) DCNL DCSP if closeto((m / self._base), 1): DCNL DCSP  DCSP return ((d + 1) * self._base) DCNL DCSP return (d * self._base)
def gt(self, x): DCNL DCSP (d, m) = divmod(x, self._base) DCNL DCSP if closeto((m / self._base), 1): DCNL DCSP  DCSP return ((d + 2) * self._base) DCNL DCSP return ((d + 1) * self._base)
def ge(self, x): DCNL DCSP (d, m) = divmod(x, self._base) DCNL DCSP if (closeto(m, 0) and (not closeto((m / self._base), 1))): DCNL DCSP  DCSP return (d * self._base) DCNL DCSP return ((d + 1) * self._base)
def __call__(self): DCNL DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP if (vmax < vmin): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP vmin = self._base.ge(vmin) DCNL DCSP base = self._base.get_base() DCNL DCSP n = (((vmax - vmin) + (0.001 * base)) // base) DCNL DCSP locs = (vmin + (np.arange((n + 1)) * base)) DCNL DCSP return locs
def view_limits(self, dmin, dmax): DCNL DCSP vmin = self._base.le(dmin) DCNL DCSP vmax = self._base.ge(dmax) DCNL DCSP if (vmin == vmax): DCNL DCSP  DCSP vmin -= 1 DCNL DCSP  DCSP vmax += 1 DCNL DCSP return mtransforms.nonsingular(vmin, vmax)
def __init__(self, base=10.0, subs=[1.0]): DCNL DCSP self.base(base) DCNL DCSP self.subs(subs) DCNL DCSP self.numticks = 15
def base(self, base): DCNL DCSP self._base = (base + 0.0)
def subs(self, subs): DCNL DCSP if (subs is None): DCNL DCSP  DCSP self._subs = None DCNL DCSP else: DCNL DCSP  DCSP self._subs = (np.asarray(subs) + 0.0)
def __call__(self): DCNL DCSP b = self._base DCNL DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP if (vmin <= 0.0): DCNL DCSP  DCSP vmin = self.axis.get_minpos() DCNL DCSP  DCSP if (vmin <= 0.0): DCNL DCSP  DCSP  DCSP raise ValueError('Data DCSP has DCSP no DCSP positive DCSP values, DCSP and DCSP therefore DCSP can DCSP not DCSP be DCSP log-scaled.') DCNL DCSP vmin = (math.log(vmin) / math.log(b)) DCNL DCSP vmax = (math.log(vmax) / math.log(b)) DCNL DCSP if (vmax < vmin): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP numdec = (math.floor(vmax) - math.ceil(vmin)) DCNL DCSP if (self._subs is None): DCNL DCSP  DCSP if (numdec > 10): DCNL DCSP  DCSP  DCSP subs = np.array([1.0]) DCNL DCSP  DCSP elif (numdec > 6): DCNL DCSP  DCSP  DCSP subs = np.arange(2.0, b, 2.0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subs = np.arange(2.0, b) DCNL DCSP else: DCNL DCSP  DCSP subs = self._subs DCNL DCSP stride = 1 DCNL DCSP while (((numdec / stride) + 1) > self.numticks): DCNL DCSP  DCSP stride += 1 DCNL DCSP decades = np.arange(math.floor(vmin), (math.ceil(vmax) + stride), stride) DCNL DCSP if ((len(subs) > 1) or (len((subs == 1)) and (subs[0] != 1.0))): DCNL DCSP  DCSP ticklocs = [] DCNL DCSP  DCSP for decadeStart in (b ** decades): DCNL DCSP  DCSP  DCSP ticklocs.extend((subs * decadeStart)) DCNL DCSP else: DCNL DCSP  DCSP ticklocs = (b ** decades) DCNL DCSP return np.array(ticklocs)
def view_limits(self, vmin, vmax): DCNL DCSP if (vmax < vmin): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP minpos = self.axis.get_minpos() DCNL DCSP if (minpos <= 0): DCNL DCSP  DCSP raise ValueError('Data DCSP has DCSP no DCSP positive DCSP values, DCSP and DCSP therefore DCSP can DCSP not DCSP be DCSP log-scaled.') DCNL DCSP if (vmin <= minpos): DCNL DCSP  DCSP vmin = minpos DCNL DCSP if (not is_decade(vmin, self._base)): DCNL DCSP  DCSP vmin = decade_down(vmin, self._base) DCNL DCSP if (not is_decade(vmax, self._base)): DCNL DCSP  DCSP vmax = decade_up(vmax, self._base) DCNL DCSP if (vmin == vmax): DCNL DCSP  DCSP vmin = decade_down(vmin, self._base) DCNL DCSP  DCSP vmax = decade_up(vmax, self._base) DCNL DCSP result = mtransforms.nonsingular(vmin, vmax) DCNL DCSP return result
def __init__(self, transform, subs=[1.0]): DCNL DCSP self._transform = transform DCNL DCSP self._subs = subs DCNL DCSP self.numticks = 15
def __call__(self): DCNL DCSP b = self._transform.base DCNL DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP (vmin, vmax) = self._transform.transform((vmin, vmax)) DCNL DCSP if (vmax < vmin): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP numdec = (math.floor(vmax) - math.ceil(vmin)) DCNL DCSP if (self._subs is None): DCNL DCSP  DCSP if (numdec > 10): DCNL DCSP  DCSP  DCSP subs = np.array([1.0]) DCNL DCSP  DCSP elif (numdec > 6): DCNL DCSP  DCSP  DCSP subs = np.arange(2.0, b, 2.0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subs = np.arange(2.0, b) DCNL DCSP else: DCNL DCSP  DCSP subs = np.asarray(self._subs) DCNL DCSP stride = 1 DCNL DCSP while (((numdec / stride) + 1) > self.numticks): DCNL DCSP  DCSP stride += 1 DCNL DCSP decades = np.arange(math.floor(vmin), (math.ceil(vmax) + stride), stride) DCNL DCSP if ((len(subs) > 1) or (subs[0] != 1.0)): DCNL DCSP  DCSP ticklocs = [] DCNL DCSP  DCSP for decade in decades: DCNL DCSP  DCSP  DCSP ticklocs.extend((subs * (np.sign(decade) * (b ** np.abs(decade))))) DCNL DCSP else: DCNL DCSP  DCSP ticklocs = (np.sign(decades) * (b ** np.abs(decades))) DCNL DCSP return np.array(ticklocs)
def view_limits(self, vmin, vmax): DCNL DCSP b = self._transform.base DCNL DCSP if (vmax < vmin): DCNL DCSP  DCSP (vmin, vmax) = (vmax, vmin) DCNL DCSP if (not is_decade(abs(vmin), b)): DCNL DCSP  DCSP if (vmin < 0): DCNL DCSP  DCSP  DCSP vmin = (- decade_up((- vmin), b)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vmin = decade_down(vmin, b) DCNL DCSP if (not is_decade(abs(vmax), b)): DCNL DCSP  DCSP if (vmax < 0): DCNL DCSP  DCSP  DCSP vmax = (- decade_down((- vmax), b)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vmax = decade_up(vmax, b) DCNL DCSP if (vmin == vmax): DCNL DCSP  DCSP if (vmin < 0): DCNL DCSP  DCSP  DCSP vmin = (- decade_up((- vmin), b)) DCNL DCSP  DCSP  DCSP vmax = (- decade_down((- vmax), b)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vmin = decade_down(vmin, b) DCNL DCSP  DCSP  DCSP vmax = decade_up(vmax, b) DCNL DCSP result = mtransforms.nonsingular(vmin, vmax) DCNL DCSP return result
def __call__(self): DCNL DCSP self.refresh() DCNL DCSP return self._locator()
def refresh(self): DCNL DCSP (vmin, vmax) = self.axis.get_view_interval() DCNL DCSP (vmin, vmax) = mtransforms.nonsingular(vmin, vmax, expander=0.05) DCNL DCSP d = abs((vmax - vmin)) DCNL DCSP self._locator = self.get_locator(d)
def view_limits(self, vmin, vmax): DCNL DCSP d = abs((vmax - vmin)) DCNL DCSP self._locator = self.get_locator(d) DCNL DCSP return self._locator.view_limits(vmin, vmax)
def get_locator(self, d): DCNL DCSP d = abs(d) DCNL DCSP if (d <= 0): DCNL DCSP  DCSP locator = MultipleLocator(0.2) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ld = math.log10(d) DCNL DCSP  DCSP except OverflowError: DCNL DCSP  DCSP  DCSP raise RuntimeError('AutoLocator DCSP illegal DCSP data DCSP interval DCSP range') DCNL DCSP  DCSP fld = math.floor(ld) DCNL DCSP  DCSP base = (10 ** fld) DCNL DCSP  DCSP if (d >= (5 * base)): DCNL DCSP  DCSP  DCSP ticksize = base DCNL DCSP  DCSP elif (d >= (2 * base)): DCNL DCSP  DCSP  DCSP ticksize = (base / 2.0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ticksize = (base / 5.0) DCNL DCSP  DCSP locator = MultipleLocator(ticksize) DCNL DCSP return locator
def parse(self, pattern): DCNL DCSP props = self._properties = {} DCNL DCSP try: DCNL DCSP  DCSP self._parser.parseString(pattern) DCNL DCSP except self.ParseException as e: DCNL DCSP  DCSP raise ValueError(("Could DCSP not DCSP parse DCSP font DCSP string: DCSP '%s'\n%s" % (pattern, e))) DCNL DCSP self._properties = None DCNL DCSP return props
def __init__(self, nmax): DCNL DCSP self._xa = np.zeros((nmax,), np.float_) DCNL DCSP self._ya = np.zeros((nmax,), np.float_) DCNL DCSP self._xs = np.zeros((nmax,), np.float_) DCNL DCSP self._ys = np.zeros((nmax,), np.float_) DCNL DCSP self._ind = 0 DCNL DCSP self._nmax = nmax DCNL DCSP self.dataLim = None DCNL DCSP self.callbackd = {}
def register(self, func, N): DCNL DCSP self.callbackd.setdefault(N, []).append(func)
def add(self, x, y): DCNL DCSP if (self.dataLim is not None): DCNL DCSP  DCSP xys = ((x, y),) DCNL DCSP  DCSP self.dataLim.update(xys, (-1)) DCNL DCSP ind = (self._ind % self._nmax) DCNL DCSP self._xs[ind] = x DCNL DCSP self._ys[ind] = y DCNL DCSP for (N, funcs) in self.callbackd.items(): DCNL DCSP  DCSP if ((self._ind % N) == 0): DCNL DCSP  DCSP  DCSP for func in funcs: DCNL DCSP  DCSP  DCSP  DCSP func(self) DCNL DCSP self._ind += 1
def last(self): DCNL DCSP if (self._ind == 0): DCNL DCSP  DCSP return (None, None) DCNL DCSP ind = ((self._ind - 1) % self._nmax) DCNL DCSP return (self._xs[ind], self._ys[ind])
def asarrays(self): DCNL DCSP if (self._ind < self._nmax): DCNL DCSP  DCSP return (self._xs[:self._ind], self._ys[:self._ind]) DCNL DCSP ind = (self._ind % self._nmax) DCNL DCSP self._xa[:(self._nmax - ind)] = self._xs[ind:] DCNL DCSP self._xa[(self._nmax - ind):] = self._xs[:ind] DCNL DCSP self._ya[:(self._nmax - ind)] = self._ys[ind:] DCNL DCSP self._ya[(self._nmax - ind):] = self._ys[:ind] DCNL DCSP return (self._xa, self._ya)
def update_datalim_to_current(self): DCNL DCSP if (self.dataLim is None): DCNL DCSP  DCSP raise ValueError('You DCSP must DCSP first DCSP set DCSP the DCSP dataLim DCSP attr') DCNL DCSP (x, y) = self.asarrays() DCNL DCSP self.dataLim.update_numerix(x, y, True)
def get_family(self): DCNL DCSP if (self._family is None): DCNL DCSP  DCSP family = rcParams['font.family'] DCNL DCSP  DCSP if is_string_like(family): DCNL DCSP  DCSP  DCSP return [family] DCNL DCSP  DCSP return family DCNL DCSP return self._family
def get_name(self): DCNL DCSP return ft2font.FT2Font(str(findfont(self))).family_name
def get_style(self): DCNL DCSP if (self._slant is None): DCNL DCSP  DCSP return rcParams['font.style'] DCNL DCSP return self._slant
def get_variant(self): DCNL DCSP if (self._variant is None): DCNL DCSP  DCSP return rcParams['font.variant'] DCNL DCSP return self._variant
def get_weight(self): DCNL DCSP if (self._weight is None): DCNL DCSP  DCSP return rcParams['font.weight'] DCNL DCSP return self._weight
def get_stretch(self): DCNL DCSP if (self._stretch is None): DCNL DCSP  DCSP return rcParams['font.stretch'] DCNL DCSP return self._stretch
def get_size(self): DCNL DCSP if (self._size is None): DCNL DCSP  DCSP return rcParams['font.size'] DCNL DCSP return self._size
def get_file(self): DCNL DCSP return self._file
def get_fontconfig_pattern(self): DCNL DCSP return generate_fontconfig_pattern(self)
def set_family(self, family): DCNL DCSP if (family is None): DCNL DCSP  DCSP self._family = None DCNL DCSP else: DCNL DCSP  DCSP if is_string_like(family): DCNL DCSP  DCSP  DCSP family = [family] DCNL DCSP  DCSP self._family = family
def set_style(self, style): DCNL DCSP if (style not in ('normal', 'italic', 'oblique', None)): DCNL DCSP  DCSP raise ValueError('style DCSP must DCSP be DCSP normal, DCSP italic DCSP or DCSP oblique') DCNL DCSP self._slant = style
def set_variant(self, variant): DCNL DCSP if (variant not in ('normal', 'small-caps', None)): DCNL DCSP  DCSP raise ValueError('variant DCSP must DCSP be DCSP normal DCSP or DCSP small-caps') DCNL DCSP self._variant = variant
def set_weight(self, weight): DCNL DCSP if (weight is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP weight = int(weight) DCNL DCSP  DCSP  DCSP if ((weight < 0) or (weight > 1000)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError() DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if (weight not in weight_dict): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('weight DCSP is DCSP invalid') DCNL DCSP self._weight = weight
def set_stretch(self, stretch): DCNL DCSP if (stretch is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP stretch = int(stretch) DCNL DCSP  DCSP  DCSP if ((stretch < 0) or (stretch > 1000)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError() DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if (stretch not in stretch_dict): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('stretch DCSP is DCSP invalid') DCNL DCSP self._stretch = stretch
def set_size(self, size): DCNL DCSP if (size is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP size = float(size) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if ((size is not None) and (size not in font_scalings)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('size DCSP is DCSP invalid') DCNL DCSP self._size = size
def set_file(self, file): DCNL DCSP self._file = file
def set_fontconfig_pattern(self, pattern): DCNL DCSP for (key, val) in self._parse_fontconfig_pattern(pattern).items(): DCNL DCSP  DCSP if (type(val) == list): DCNL DCSP  DCSP  DCSP getattr(self, ('set_' + key))(val[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP getattr(self, ('set_' + key))(val)
def copy(self): DCNL DCSP return FontProperties(_init=self)
def get_default_weight(self): DCNL DCSP return self.__default_weight
def get_default_size(self): DCNL DCSP if (self.default_size is None): DCNL DCSP  DCSP return rcParams['font.size'] DCNL DCSP return self.default_size
def set_default_weight(self, weight): DCNL DCSP self.__default_weight = weight
def set_default_size(self, size): DCNL DCSP self.default_size = size
def update_fonts(self, filenames): DCNL DCSP raise NotImplementedError
def score_family(self, families, family2): DCNL DCSP for (i, family1) in enumerate(families): DCNL DCSP  DCSP if (family1.lower() in font_family_aliases): DCNL DCSP  DCSP  DCSP if (family1 == 'sans'): DCNL DCSP  DCSP  DCSP  DCSP (family1 == 'sans-serif') DCNL DCSP  DCSP  DCSP options = rcParams[('font.' + family1)] DCNL DCSP  DCSP  DCSP if (family2 in options): DCNL DCSP  DCSP  DCSP  DCSP idx = options.index(family2) DCNL DCSP  DCSP  DCSP  DCSP return (0.1 * (float(idx) / len(options))) DCNL DCSP  DCSP elif (family1.lower() == family2.lower()): DCNL DCSP  DCSP  DCSP return 0.0 DCNL DCSP return 1.0
def score_style(self, style1, style2): DCNL DCSP if (style1 == style2): DCNL DCSP  DCSP return 0.0 DCNL DCSP elif ((style1 in ('italic', 'oblique')) and (style2 in ('italic', 'oblique'))): DCNL DCSP  DCSP return 0.1 DCNL DCSP return 1.0
def score_variant(self, variant1, variant2): DCNL DCSP if (variant1 == variant2): DCNL DCSP  DCSP return 0.0 DCNL DCSP else: DCNL DCSP  DCSP return 1.0
def score_stretch(self, stretch1, stretch2): DCNL DCSP try: DCNL DCSP  DCSP stretchval1 = int(stretch1) DCNL DCSP except ValueError: DCNL DCSP  DCSP stretchval1 = stretch_dict.get(stretch1, 500) DCNL DCSP try: DCNL DCSP  DCSP stretchval2 = int(stretch2) DCNL DCSP except ValueError: DCNL DCSP  DCSP stretchval2 = stretch_dict.get(stretch2, 500) DCNL DCSP return (abs((stretchval1 - stretchval2)) / 1000.0)
def score_weight(self, weight1, weight2): DCNL DCSP try: DCNL DCSP  DCSP weightval1 = int(weight1) DCNL DCSP except ValueError: DCNL DCSP  DCSP weightval1 = weight_dict.get(weight1, 500) DCNL DCSP try: DCNL DCSP  DCSP weightval2 = int(weight2) DCNL DCSP except ValueError: DCNL DCSP  DCSP weightval2 = weight_dict.get(weight2, 500) DCNL DCSP return (abs((weightval1 - weightval2)) / 1000.0)
def score_size(self, size1, size2): DCNL DCSP if (size2 == 'scalable'): DCNL DCSP  DCSP return 0.0 DCNL DCSP try: DCNL DCSP  DCSP sizeval1 = float(size1) DCNL DCSP except ValueError: DCNL DCSP  DCSP sizeval1 = (self.default_size * font_scalings(size1)) DCNL DCSP try: DCNL DCSP  DCSP sizeval2 = float(size2) DCNL DCSP except ValueError: DCNL DCSP  DCSP return 1.0 DCNL DCSP return (abs((sizeval1 - sizeval2)) / 72.0)
def findfont(self, prop, fontext='ttf'): DCNL DCSP debug = False DCNL DCSP if (prop is None): DCNL DCSP  DCSP return self.defaultFont DCNL DCSP if is_string_like(prop): DCNL DCSP  DCSP prop = FontProperties(prop) DCNL DCSP fname = prop.get_file() DCNL DCSP if (fname is not None): DCNL DCSP  DCSP verbose.report(('findfont DCSP returning DCSP %s' % fname), 'debug') DCNL DCSP  DCSP return fname DCNL DCSP if (fontext == 'afm'): DCNL DCSP  DCSP font_cache = self.afm_lookup_cache DCNL DCSP  DCSP fontlist = self.afmlist DCNL DCSP else: DCNL DCSP  DCSP font_cache = self.ttf_lookup_cache DCNL DCSP  DCSP fontlist = self.ttflist DCNL DCSP cached = font_cache.get(hash(prop)) DCNL DCSP if cached: DCNL DCSP  DCSP return cached DCNL DCSP best_score = 1e+64 DCNL DCSP best_font = None DCNL DCSP for font in fontlist: DCNL DCSP  DCSP score = ((((((self.score_family(prop.get_family(), font.name) * 10.0) + self.score_style(prop.get_style(), font.style)) + self.score_variant(prop.get_variant(), font.variant)) + self.score_weight(prop.get_weight(), font.weight)) + self.score_stretch(prop.get_stretch(), font.stretch)) + self.score_size(prop.get_size(), font.size)) DCNL DCSP  DCSP if (score < best_score): DCNL DCSP  DCSP  DCSP best_score = score DCNL DCSP  DCSP  DCSP best_font = font DCNL DCSP  DCSP if (score == 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP if ((best_font is None) or (best_score >= 10.0)): DCNL DCSP  DCSP verbose.report(('findfont: DCSP Could DCSP not DCSP match DCSP %s. DCSP Returning DCSP %s' % (prop, self.defaultFont))) DCNL DCSP  DCSP result = self.defaultFont DCNL DCSP else: DCNL DCSP  DCSP verbose.report(('findfont: DCSP Matching DCSP %s DCSP to DCSP %s DCSP (%s) DCSP with DCSP score DCSP of DCSP %f' % (prop, best_font.name, best_font.fname, best_score))) DCNL DCSP  DCSP result = best_font.fname DCNL DCSP font_cache[hash(prop)] = result DCNL DCSP return result
def __init__(self, parent, handles, labels, loc=None, numpoints=None, markerscale=None, scatterpoints=3, scatteryoffsets=None, prop=None, pad=None, labelsep=None, handlelen=None, handletextsep=None, axespad=None, borderpad=None, labelspacing=None, handlelength=None, handletextpad=None, borderaxespad=None, columnspacing=None, ncol=1, mode=None, fancybox=None, shadow=None): DCNL DCSP from matplotlib.axes import Axes DCNL DCSP from matplotlib.figure import Figure DCNL DCSP Artist.__init__(self) DCNL DCSP if (prop is None): DCNL DCSP  DCSP self.prop = FontProperties(size=rcParams['legend.fontsize']) DCNL DCSP else: DCNL DCSP  DCSP self.prop = prop DCNL DCSP self.fontsize = self.prop.get_size_in_points() DCNL DCSP propnames = ['numpoints', 'markerscale', 'shadow', 'columnspacing', 'scatterpoints'] DCNL DCSP localdict = locals() DCNL DCSP for name in propnames: DCNL DCSP  DCSP if (localdict[name] is None): DCNL DCSP  DCSP  DCSP value = rcParams[('legend.' + name)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = localdict[name] DCNL DCSP  DCSP setattr(self, name, value) DCNL DCSP deprecated_kwds = {'pad': 'borderpad', 'labelsep': 'labelspacing', 'handlelen': 'handlelength', 'handletextsep': 'handletextpad', 'axespad': 'borderaxespad'} DCNL DCSP bbox = parent.bbox DCNL DCSP axessize_fontsize = (min(bbox.width, bbox.height) / self.fontsize) DCNL DCSP for (k, v) in deprecated_kwds.items(): DCNL DCSP  DCSP if ((localdict[k] is not None) and (localdict[v] is None)): DCNL DCSP  DCSP  DCSP warnings.warn(("Use DCSP '%s' DCSP instead DCSP of DCSP '%s'." % (v, k)), DeprecationWarning) DCNL DCSP  DCSP  DCSP setattr(self, v, (localdict[k] * axessize_fontsize)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (localdict[v] is None): DCNL DCSP  DCSP  DCSP setattr(self, v, rcParams[('legend.' + v)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP setattr(self, v, localdict[v]) DCNL DCSP del localdict DCNL DCSP self._ncol = ncol DCNL DCSP if (self.numpoints <= 0): DCNL DCSP  DCSP raise ValueError(('numpoints DCSP must DCSP be DCSP >= DCSP 0; DCSP it DCSP was DCSP %d' % numpoints)) DCNL DCSP if (scatteryoffsets is None): DCNL DCSP  DCSP self._scatteryoffsets = np.array([(3.0 / 8.0), (4.0 / 8.0), (2.5 / 8.0)]) DCNL DCSP else: DCNL DCSP  DCSP self._scatteryoffsets = np.asarray(scatteryoffsets) DCNL DCSP reps = (int((self.numpoints / len(self._scatteryoffsets))) + 1) DCNL DCSP self._scatteryoffsets = np.tile(self._scatteryoffsets, reps)[:self.scatterpoints] DCNL DCSP self._legend_box = None DCNL DCSP if isinstance(parent, Axes): DCNL DCSP  DCSP self.isaxes = True DCNL DCSP  DCSP self.set_figure(parent.figure) DCNL DCSP elif isinstance(parent, Figure): DCNL DCSP  DCSP self.isaxes = False DCNL DCSP  DCSP self.set_figure(parent) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Legend DCSP needs DCSP either DCSP Axes DCSP or DCSP Figure DCSP as DCSP parent') DCNL DCSP self.parent = parent DCNL DCSP if (loc is None): DCNL DCSP  DCSP loc = rcParams['legend.loc'] DCNL DCSP  DCSP if ((not self.isaxes) and (loc in [0, 'best'])): DCNL DCSP  DCSP  DCSP loc = 'upper DCSP right' DCNL DCSP if is_string_like(loc): DCNL DCSP  DCSP if (loc not in self.codes): DCNL DCSP  DCSP  DCSP if self.isaxes: DCNL DCSP  DCSP  DCSP  DCSP warnings.warn(('Unrecognized DCSP location DCSP "%s". DCSP Falling DCSP back DCSP on DCSP "best"; DCSP valid DCSP locations DCSP are\n DCTB %s\n' % (loc, '\n DCTB '.join(self.codes.keys())))) DCNL DCSP  DCSP  DCSP  DCSP loc = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP warnings.warn(('Unrecognized DCSP location DCSP "%s". DCSP Falling DCSP back DCSP on DCSP "upper DCSP right"; DCSP valid DCSP locations DCSP are\n DCTB %s\n' % (loc, '\n DCTB '.join(self.codes.keys())))) DCNL DCSP  DCSP  DCSP  DCSP loc = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP loc = self.codes[loc] DCNL DCSP if ((not self.isaxes) and (loc == 0)): DCNL DCSP  DCSP warnings.warn('Automatic DCSP legend DCSP placement DCSP (loc="best") DCSP not DCSP implemented DCSP for DCSP figure DCSP legend. DCSP Falling DCSP back DCSP on DCSP "upper DCSP right".') DCNL DCSP  DCSP loc = 1 DCNL DCSP self._loc = loc DCNL DCSP self._mode = mode DCNL DCSP self.legendPatch = FancyBboxPatch(xy=(0.0, 0.0), width=1.0, height=1.0, facecolor='w', edgecolor='k', mutation_scale=self.fontsize, snap=True) DCNL DCSP if (fancybox is None): DCNL DCSP  DCSP fancybox = rcParams['legend.fancybox'] DCNL DCSP if (fancybox == True): DCNL DCSP  DCSP self.legendPatch.set_boxstyle('round', pad=0, rounding_size=0.2) DCNL DCSP else: DCNL DCSP  DCSP self.legendPatch.set_boxstyle('square', pad=0) DCNL DCSP self._set_artist_props(self.legendPatch) DCNL DCSP self._drawFrame = True DCNL DCSP self._init_legend_box(handles, labels) DCNL DCSP self._last_fontsize_points = self.fontsize
def _set_artist_props(self, a): DCNL DCSP a.set_figure(self.figure) DCNL DCSP for c in self.get_children(): DCNL DCSP  DCSP c.set_figure(self.figure) DCNL DCSP a.set_transform(self.get_transform())
def _findoffset_best(self, width, height, xdescent, ydescent, renderer): DCNL DCSP (ox, oy) = self._find_best_position(width, height, renderer) DCNL DCSP return ((ox + xdescent), (oy + ydescent))
def _findoffset_loc(self, width, height, xdescent, ydescent, renderer): DCNL DCSP if (iterable(self._loc) and (len(self._loc) == 2)): DCNL DCSP  DCSP (fx, fy) = self._loc DCNL DCSP  DCSP bbox = self.parent.bbox DCNL DCSP  DCSP (x, y) = ((bbox.x0 + (bbox.width * fx)), (bbox.y0 + (bbox.height * fy))) DCNL DCSP else: DCNL DCSP  DCSP bbox = Bbox.from_bounds(0, 0, width, height) DCNL DCSP  DCSP (x, y) = self._get_anchored_bbox(self._loc, bbox, self.parent.bbox, renderer) DCNL DCSP return ((x + xdescent), (y + ydescent))
def draw(self, renderer): DCNL DCSP if (not self.get_visible()): DCNL DCSP  DCSP return DCNL DCSP self._update_legend_box(renderer) DCNL DCSP renderer.open_group('legend') DCNL DCSP if (self._loc == 0): DCNL DCSP  DCSP _findoffset = self._findoffset_best DCNL DCSP else: DCNL DCSP  DCSP _findoffset = self._findoffset_loc DCNL DCSP def findoffset(width, height, xdescent, ydescent): DCNL DCSP  DCSP return _findoffset(width, height, xdescent, ydescent, renderer) DCNL DCSP self._legend_box.set_offset(findoffset) DCNL DCSP fontsize = renderer.points_to_pixels(self.fontsize) DCNL DCSP if (self._mode in ['expand']): DCNL DCSP  DCSP pad = ((2 * (self.borderaxespad + self.borderpad)) * fontsize) DCNL DCSP  DCSP self._legend_box.set_width((self.parent.bbox.width - pad)) DCNL DCSP if self._drawFrame: DCNL DCSP  DCSP bbox = self._legend_box.get_window_extent(renderer) DCNL DCSP  DCSP self.legendPatch.set_bounds(bbox.x0, bbox.y0, bbox.width, bbox.height) DCNL DCSP  DCSP self.legendPatch.set_mutation_scale(fontsize) DCNL DCSP  DCSP if self.shadow: DCNL DCSP  DCSP  DCSP shadow = Shadow(self.legendPatch, 2, (-2)) DCNL DCSP  DCSP  DCSP shadow.draw(renderer) DCNL DCSP  DCSP self.legendPatch.draw(renderer) DCNL DCSP self._legend_box.draw(renderer) DCNL DCSP renderer.close_group('legend')
def _approx_text_height(self, renderer=None): DCNL DCSP if (renderer is None): DCNL DCSP  DCSP return self.fontsize DCNL DCSP else: DCNL DCSP  DCSP return renderer.points_to_pixels(self.fontsize)
def _init_legend_box(self, handles, labels): DCNL DCSP fontsize = self.fontsize DCNL DCSP text_list = [] DCNL DCSP handle_list = [] DCNL DCSP label_prop = dict(verticalalignment='baseline', horizontalalignment='left', fontproperties=self.prop) DCNL DCSP labelboxes = [] DCNL DCSP for l in labels: DCNL DCSP  DCSP textbox = TextArea(l, textprops=label_prop, multilinebaseline=True, minimumdescent=True) DCNL DCSP  DCSP text_list.append(textbox._text) DCNL DCSP  DCSP labelboxes.append(textbox) DCNL DCSP handleboxes = [] DCNL DCSP height = (self._approx_text_height() * 0.7) DCNL DCSP descent = 0.0 DCNL DCSP for handle in handles: DCNL DCSP  DCSP if isinstance(handle, RegularPolyCollection): DCNL DCSP  DCSP  DCSP npoints = self.scatterpoints DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP npoints = self.numpoints DCNL DCSP  DCSP if (npoints > 1): DCNL DCSP  DCSP  DCSP xdata = np.linspace((0.3 * fontsize), ((self.handlelength - 0.3) * fontsize), npoints) DCNL DCSP  DCSP  DCSP xdata_marker = xdata DCNL DCSP  DCSP elif (npoints == 1): DCNL DCSP  DCSP  DCSP xdata = np.linspace(0, (self.handlelength * fontsize), 2) DCNL DCSP  DCSP  DCSP xdata_marker = [((0.5 * self.handlelength) * fontsize)] DCNL DCSP  DCSP if isinstance(handle, Line2D): DCNL DCSP  DCSP  DCSP ydata = (((height - descent) / 2.0) * np.ones(xdata.shape, float)) DCNL DCSP  DCSP  DCSP legline = Line2D(xdata, ydata) DCNL DCSP  DCSP  DCSP legline.update_from(handle) DCNL DCSP  DCSP  DCSP self._set_artist_props(legline) DCNL DCSP  DCSP  DCSP legline.set_clip_box(None) DCNL DCSP  DCSP  DCSP legline.set_clip_path(None) DCNL DCSP  DCSP  DCSP legline.set_drawstyle('default') DCNL DCSP  DCSP  DCSP legline.set_marker('None') DCNL DCSP  DCSP  DCSP handle_list.append(legline) DCNL DCSP  DCSP  DCSP legline_marker = Line2D(xdata_marker, ydata[:len(xdata_marker)]) DCNL DCSP  DCSP  DCSP legline_marker.update_from(handle) DCNL DCSP  DCSP  DCSP self._set_artist_props(legline_marker) DCNL DCSP  DCSP  DCSP legline_marker.set_clip_box(None) DCNL DCSP  DCSP  DCSP legline_marker.set_clip_path(None) DCNL DCSP  DCSP  DCSP legline_marker.set_linestyle('None') DCNL DCSP  DCSP  DCSP legline._legmarker = legline_marker DCNL DCSP  DCSP elif isinstance(handle, Patch): DCNL DCSP  DCSP  DCSP p = Rectangle(xy=(0.0, 0.0), width=(self.handlelength * fontsize), height=(height - descent)) DCNL DCSP  DCSP  DCSP p.update_from(handle) DCNL DCSP  DCSP  DCSP self._set_artist_props(p) DCNL DCSP  DCSP  DCSP p.set_clip_box(None) DCNL DCSP  DCSP  DCSP p.set_clip_path(None) DCNL DCSP  DCSP  DCSP handle_list.append(p) DCNL DCSP  DCSP elif isinstance(handle, LineCollection): DCNL DCSP  DCSP  DCSP ydata = (((height - descent) / 2.0) * np.ones(xdata.shape, float)) DCNL DCSP  DCSP  DCSP legline = Line2D(xdata, ydata) DCNL DCSP  DCSP  DCSP self._set_artist_props(legline) DCNL DCSP  DCSP  DCSP legline.set_clip_box(None) DCNL DCSP  DCSP  DCSP legline.set_clip_path(None) DCNL DCSP  DCSP  DCSP lw = handle.get_linewidth()[0] DCNL DCSP  DCSP  DCSP dashes = handle.get_dashes()[0] DCNL DCSP  DCSP  DCSP color = handle.get_colors()[0] DCNL DCSP  DCSP  DCSP legline.set_color(color) DCNL DCSP  DCSP  DCSP legline.set_linewidth(lw) DCNL DCSP  DCSP  DCSP legline.set_dashes(dashes) DCNL DCSP  DCSP  DCSP handle_list.append(legline) DCNL DCSP  DCSP elif isinstance(handle, RegularPolyCollection): DCNL DCSP  DCSP  DCSP ydata = (height * self._scatteryoffsets) DCNL DCSP  DCSP  DCSP (size_max, size_min) = (max(handle.get_sizes()), min(handle.get_sizes())) DCNL DCSP  DCSP  DCSP if (self.scatterpoints < 4): DCNL DCSP  DCSP  DCSP  DCSP sizes = [(0.5 * (size_max + size_min)), size_max, size_min] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sizes = (((size_max - size_min) * np.linspace(0, 1, self.scatterpoints)) + size_min) DCNL DCSP  DCSP  DCSP p = type(handle)(handle.get_numsides(), rotation=handle.get_rotation(), sizes=sizes, offsets=zip(xdata_marker, ydata), transOffset=self.get_transform()) DCNL DCSP  DCSP  DCSP p.update_from(handle) DCNL DCSP  DCSP  DCSP p.set_figure(self.figure) DCNL DCSP  DCSP  DCSP p.set_clip_box(None) DCNL DCSP  DCSP  DCSP p.set_clip_path(None) DCNL DCSP  DCSP  DCSP handle_list.append(p) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP handle_list.append(None) DCNL DCSP  DCSP handlebox = DrawingArea(width=(self.handlelength * fontsize), height=height, xdescent=0.0, ydescent=descent) DCNL DCSP  DCSP handle = handle_list[(-1)] DCNL DCSP  DCSP handlebox.add_artist(handle) DCNL DCSP  DCSP if hasattr(handle, '_legmarker'): DCNL DCSP  DCSP  DCSP handlebox.add_artist(handle._legmarker) DCNL DCSP  DCSP handleboxes.append(handlebox) DCNL DCSP (nrows, num_largecol) = divmod(len(handleboxes), self._ncol) DCNL DCSP num_smallcol = (self._ncol - num_largecol) DCNL DCSP largecol = safezip(range(0, (num_largecol * (nrows + 1)), (nrows + 1)), ([(nrows + 1)] * num_largecol)) DCNL DCSP smallcol = safezip(range((num_largecol * (nrows + 1)), len(handleboxes), nrows), ([nrows] * num_smallcol)) DCNL DCSP handle_label = safezip(handleboxes, labelboxes) DCNL DCSP columnbox = [] DCNL DCSP for (i0, di) in (largecol + smallcol): DCNL DCSP  DCSP itemBoxes = [HPacker(pad=0, sep=(self.handletextpad * fontsize), children=[h, t], align='baseline') for (h, t) in handle_label[i0:(i0 + di)]] DCNL DCSP  DCSP itemBoxes[(-1)].get_children()[1].set_minimumdescent(False) DCNL DCSP  DCSP columnbox.append(VPacker(pad=0, sep=(self.labelspacing * fontsize), align='baseline', children=itemBoxes)) DCNL DCSP if (self._mode == 'expand'): DCNL DCSP  DCSP mode = 'expand' DCNL DCSP else: DCNL DCSP  DCSP mode = 'fixed' DCNL DCSP sep = (self.columnspacing * fontsize) DCNL DCSP self._legend_box = HPacker(pad=(self.borderpad * fontsize), sep=sep, align='baseline', mode=mode, children=columnbox) DCNL DCSP self._legend_box.set_figure(self.figure) DCNL DCSP self.texts = text_list DCNL DCSP self.legendHandles = handle_list
def _update_legend_box(self, renderer): DCNL DCSP fontsize = renderer.points_to_pixels(self.fontsize) DCNL DCSP if (self._last_fontsize_points == fontsize): DCNL DCSP  DCSP return DCNL DCSP height = (self._approx_text_height(renderer) * 0.7) DCNL DCSP descent = 0.0 DCNL DCSP for handle in self.legendHandles: DCNL DCSP  DCSP if isinstance(handle, RegularPolyCollection): DCNL DCSP  DCSP  DCSP npoints = self.scatterpoints DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP npoints = self.numpoints DCNL DCSP  DCSP if (npoints > 1): DCNL DCSP  DCSP  DCSP xdata = np.linspace((0.3 * fontsize), ((self.handlelength - 0.3) * fontsize), npoints) DCNL DCSP  DCSP  DCSP xdata_marker = xdata DCNL DCSP  DCSP elif (npoints == 1): DCNL DCSP  DCSP  DCSP xdata = np.linspace(0, (self.handlelength * fontsize), 2) DCNL DCSP  DCSP  DCSP xdata_marker = [((0.5 * self.handlelength) * fontsize)] DCNL DCSP  DCSP if isinstance(handle, Line2D): DCNL DCSP  DCSP  DCSP legline = handle DCNL DCSP  DCSP  DCSP ydata = (((height - descent) / 2.0) * np.ones(xdata.shape, float)) DCNL DCSP  DCSP  DCSP legline.set_data(xdata, ydata) DCNL DCSP  DCSP  DCSP legline_marker = legline._legmarker DCNL DCSP  DCSP  DCSP legline_marker.set_data(xdata_marker, ydata[:len(xdata_marker)]) DCNL DCSP  DCSP elif isinstance(handle, Patch): DCNL DCSP  DCSP  DCSP p = handle DCNL DCSP  DCSP  DCSP p.set_bounds(0.0, 0.0, (self.handlelength * fontsize), (height - descent)) DCNL DCSP  DCSP elif isinstance(handle, RegularPolyCollection): DCNL DCSP  DCSP  DCSP p = handle DCNL DCSP  DCSP  DCSP ydata = (height * self._scatteryoffsets) DCNL DCSP  DCSP  DCSP p.set_offsets(zip(xdata_marker, ydata)) DCNL DCSP cor = (fontsize / self._last_fontsize_points) DCNL DCSP def all_children(parent): DCNL DCSP  DCSP (yield parent) DCNL DCSP  DCSP for c in parent.get_children(): DCNL DCSP  DCSP  DCSP for cc in all_children(c): DCNL DCSP  DCSP  DCSP  DCSP (yield cc) DCNL DCSP for box in all_children(self._legend_box): DCNL DCSP  DCSP if isinstance(box, PackerBase): DCNL DCSP  DCSP  DCSP box.pad = (box.pad * cor) DCNL DCSP  DCSP  DCSP box.sep = (box.sep * cor) DCNL DCSP  DCSP elif isinstance(box, DrawingArea): DCNL DCSP  DCSP  DCSP box.width = (self.handlelength * fontsize) DCNL DCSP  DCSP  DCSP box.height = height DCNL DCSP  DCSP  DCSP box.xdescent = 0.0 DCNL DCSP  DCSP  DCSP box.ydescent = descent DCNL DCSP self._last_fontsize_points = fontsize
def _auto_legend_data(self): DCNL DCSP assert self.isaxes DCNL DCSP ax = self.parent DCNL DCSP vertices = [] DCNL DCSP bboxes = [] DCNL DCSP lines = [] DCNL DCSP for handle in ax.lines: DCNL DCSP  DCSP assert isinstance(handle, Line2D) DCNL DCSP  DCSP path = handle.get_path() DCNL DCSP  DCSP trans = handle.get_transform() DCNL DCSP  DCSP tpath = trans.transform_path(path) DCNL DCSP  DCSP lines.append(tpath) DCNL DCSP for handle in ax.patches: DCNL DCSP  DCSP assert isinstance(handle, Patch) DCNL DCSP  DCSP if isinstance(handle, Rectangle): DCNL DCSP  DCSP  DCSP transform = handle.get_data_transform() DCNL DCSP  DCSP  DCSP bboxes.append(handle.get_bbox().transformed(transform)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP transform = handle.get_transform() DCNL DCSP  DCSP  DCSP bboxes.append(handle.get_path().get_extents(transform)) DCNL DCSP return [vertices, bboxes, lines]
def draw_frame(self, b): DCNL DCSP self._drawFrame = b
def get_children(self): DCNL DCSP children = [] DCNL DCSP if self._legend_box: DCNL DCSP  DCSP children.append(self._legend_box) DCNL DCSP return children
def get_frame(self): DCNL DCSP return self.legendPatch
def get_lines(self): DCNL DCSP return [h for h in self.legendHandles if isinstance(h, Line2D)]
def get_patches(self): DCNL DCSP return silent_list('Patch', [h for h in self.legendHandles if isinstance(h, Patch)])
def get_texts(self): DCNL DCSP return silent_list('Text', self.texts)
def get_window_extent(self): DCNL DCSP return self.legendPatch.get_window_extent()
def _get_anchored_bbox(self, loc, bbox, parentbbox, renderer): DCNL DCSP assert (loc in range(1, 11)) DCNL DCSP (BEST, UR, UL, LL, LR, R, CL, CR, LC, UC, C) = range(11) DCNL DCSP anchor_coefs = {UR: 'NE', UL: 'NW', LL: 'SW', LR: 'SE', R: 'E', CL: 'W', CR: 'E', LC: 'S', UC: 'N', C: 'C'} DCNL DCSP c = anchor_coefs[loc] DCNL DCSP fontsize = renderer.points_to_pixels(self.fontsize) DCNL DCSP container = parentbbox.padded(((- self.borderaxespad) * fontsize)) DCNL DCSP anchored_box = bbox.anchored(c, container=container) DCNL DCSP return (anchored_box.x0, anchored_box.y0)
def _find_best_position(self, width, height, renderer, consider=None): DCNL DCSP assert self.isaxes DCNL DCSP (verts, bboxes, lines) = self._auto_legend_data() DCNL DCSP bbox = Bbox.from_bounds(0, 0, width, height) DCNL DCSP consider = [self._get_anchored_bbox(x, bbox, self.parent.bbox, renderer) for x in range(1, len(self.codes))] DCNL DCSP candidates = [] DCNL DCSP for (l, b) in consider: DCNL DCSP  DCSP legendBox = Bbox.from_bounds(l, b, width, height) DCNL DCSP  DCSP badness = 0 DCNL DCSP  DCSP badness = legendBox.count_contains(verts) DCNL DCSP  DCSP badness += legendBox.count_overlaps(bboxes) DCNL DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP if line.intersects_bbox(legendBox): DCNL DCSP  DCSP  DCSP  DCSP badness += 1 DCNL DCSP  DCSP (ox, oy) = (l, b) DCNL DCSP  DCSP if (badness == 0): DCNL DCSP  DCSP  DCSP return (ox, oy) DCNL DCSP  DCSP candidates.append((badness, (l, b))) DCNL DCSP minCandidate = candidates[0] DCNL DCSP for candidate in candidates: DCNL DCSP  DCSP if (candidate[0] < minCandidate[0]): DCNL DCSP  DCSP  DCSP minCandidate = candidate DCNL DCSP (ox, oy) = minCandidate[1] DCNL DCSP return (ox, oy)
def get_verts(self): DCNL DCSP trans = self.get_transform() DCNL DCSP path = self.get_path() DCNL DCSP polygons = path.to_polygons(trans) DCNL DCSP if len(polygons): DCNL DCSP  DCSP return polygons[0] DCNL DCSP return []
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP inside = self.get_path().contains_point((mouseevent.x, mouseevent.y), self.get_transform()) DCNL DCSP return (inside, {})
def update_from(self, other): DCNL DCSP artist.Artist.update_from(self, other) DCNL DCSP self.set_edgecolor(other.get_edgecolor()) DCNL DCSP self.set_facecolor(other.get_facecolor()) DCNL DCSP self.set_fill(other.get_fill()) DCNL DCSP self.set_hatch(other.get_hatch()) DCNL DCSP self.set_linewidth(other.get_linewidth()) DCNL DCSP self.set_linestyle(other.get_linestyle()) DCNL DCSP self.set_transform(other.get_data_transform()) DCNL DCSP self.set_figure(other.get_figure()) DCNL DCSP self.set_alpha(other.get_alpha())
def get_extents(self): DCNL DCSP return self.get_path().get_extents(self.get_transform())
def get_transform(self): DCNL DCSP return (self.get_patch_transform() + artist.Artist.get_transform(self))
def get_antialiased(self): DCNL DCSP return self._antialiased
def get_edgecolor(self): DCNL DCSP return self._edgecolor
def get_facecolor(self): DCNL DCSP return self._facecolor
def get_linewidth(self): DCNL DCSP return self._linewidth
def get_linestyle(self): DCNL DCSP return self._linestyle
def set_antialiased(self, aa): DCNL DCSP if (aa is None): DCNL DCSP  DCSP aa = mpl.rcParams['patch.antialiased'] DCNL DCSP self._antialiased = aa
def set_aa(self, aa): DCNL DCSP return self.set_antialiased(aa)
def set_edgecolor(self, color): DCNL DCSP if (color is None): DCNL DCSP  DCSP color = mpl.rcParams['patch.edgecolor'] DCNL DCSP self._edgecolor = color
def set_ec(self, color): DCNL DCSP return self.set_edgecolor(color)
def set_facecolor(self, color): DCNL DCSP if (color is None): DCNL DCSP  DCSP color = mpl.rcParams['patch.facecolor'] DCNL DCSP self._facecolor = color
def set_fc(self, color): DCNL DCSP return self.set_facecolor(color)
def set_linewidth(self, w): DCNL DCSP if (w is None): DCNL DCSP  DCSP w = mpl.rcParams['patch.linewidth'] DCNL DCSP self._linewidth = w
def set_lw(self, lw): DCNL DCSP return self.set_linewidth(lw)
def set_linestyle(self, ls): DCNL DCSP if (ls is None): DCNL DCSP  DCSP ls = 'solid' DCNL DCSP self._linestyle = ls
def set_ls(self, ls): DCNL DCSP return self.set_linestyle(ls)
def set_fill(self, b): DCNL DCSP self.fill = b
def get_fill(self): DCNL DCSP return self.fill
def set_hatch(self, h): DCNL DCSP self._hatch = h
def get_hatch(self): DCNL DCSP return self._hatch
def draw(self, renderer): DCNL DCSP if (not self.get_visible()): DCNL DCSP  DCSP return DCNL DCSP gc = renderer.new_gc() DCNL DCSP if (cbook.is_string_like(self._edgecolor) and (self._edgecolor.lower() == 'none')): DCNL DCSP  DCSP gc.set_linewidth(0) DCNL DCSP else: DCNL DCSP  DCSP gc.set_foreground(self._edgecolor) DCNL DCSP  DCSP gc.set_linewidth(self._linewidth) DCNL DCSP  DCSP gc.set_linestyle(self._linestyle) DCNL DCSP gc.set_antialiased(self._antialiased) DCNL DCSP self._set_gc_clip(gc) DCNL DCSP gc.set_capstyle('projecting') DCNL DCSP gc.set_url(self._url) DCNL DCSP gc.set_snap(self._snap) DCNL DCSP if ((not self.fill) or (self._facecolor is None) or (cbook.is_string_like(self._facecolor) and (self._facecolor.lower() == 'none'))): DCNL DCSP  DCSP rgbFace = None DCNL DCSP  DCSP gc.set_alpha(1.0) DCNL DCSP else: DCNL DCSP  DCSP (r, g, b, a) = colors.colorConverter.to_rgba(self._facecolor, self._alpha) DCNL DCSP  DCSP rgbFace = (r, g, b) DCNL DCSP  DCSP gc.set_alpha(a) DCNL DCSP if self._hatch: DCNL DCSP  DCSP gc.set_hatch(self._hatch) DCNL DCSP path = self.get_path() DCNL DCSP transform = self.get_transform() DCNL DCSP tpath = transform.transform_path_non_affine(path) DCNL DCSP affine = transform.get_affine() DCNL DCSP renderer.draw_path(gc, tpath, affine, rgbFace)
def get_path(self): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def __init__(self, patch, ox, oy, props=None, **kwargs): DCNL DCSP Patch.__init__(self) DCNL DCSP self.patch = patch DCNL DCSP self.props = props DCNL DCSP (self._ox, self._oy) = (ox, oy) DCNL DCSP self._update_transform() DCNL DCSP self._update()
def __init__(self, xy, width, height, **kwargs): DCNL DCSP Patch.__init__(self, **kwargs) DCNL DCSP self._x = xy[0] DCNL DCSP self._y = xy[1] DCNL DCSP self._width = width DCNL DCSP self._height = height DCNL DCSP self._rect_transform = transforms.IdentityTransform()
def get_path(self): DCNL DCSP return Path.unit_rectangle()
def _update_patch_transform(self): DCNL DCSP x = self.convert_xunits(self._x) DCNL DCSP y = self.convert_yunits(self._y) DCNL DCSP width = self.convert_xunits(self._width) DCNL DCSP height = self.convert_yunits(self._height) DCNL DCSP bbox = transforms.Bbox.from_bounds(x, y, width, height) DCNL DCSP self._rect_transform = transforms.BboxTransformTo(bbox)
def get_x(self): DCNL DCSP return self._x
def get_y(self): DCNL DCSP return self._y
def get_xy(self): DCNL DCSP return (self._x, self._y)
def get_width(self): DCNL DCSP return self._width
def get_height(self): DCNL DCSP return self._height
def set_x(self, x): DCNL DCSP self._x = x
def set_y(self, y): DCNL DCSP self._y = y
def set_xy(self, xy): DCNL DCSP (self._x, self._y) = xy
def set_width(self, w): DCNL DCSP self._width = w
def set_height(self, h): DCNL DCSP self._height = h
def set_bounds(self, *args): DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP (l, b, w, h) = args[0] DCNL DCSP else: DCNL DCSP  DCSP (l, b, w, h) = args DCNL DCSP self._x = l DCNL DCSP self._y = b DCNL DCSP self._width = w DCNL DCSP self._height = h
def __init__(self, xy, numVertices, radius=5, orientation=0, **kwargs): DCNL DCSP self._xy = xy DCNL DCSP self._numVertices = numVertices DCNL DCSP self._orientation = orientation DCNL DCSP self._radius = radius DCNL DCSP self._path = Path.unit_regular_polygon(numVertices) DCNL DCSP self._poly_transform = transforms.Affine2D() DCNL DCSP self._update_transform() DCNL DCSP Patch.__init__(self, **kwargs)
def __init__(self, path, **kwargs): DCNL DCSP Patch.__init__(self, **kwargs) DCNL DCSP self._path = path
def __init__(self, xy, closed=True, **kwargs): DCNL DCSP Patch.__init__(self, **kwargs) DCNL DCSP xy = np.asarray(xy, np.float_) DCNL DCSP self._path = Path(xy) DCNL DCSP self.set_closed(closed)
def __init__(self, center, r, theta1, theta2, width=None, **kwargs): DCNL DCSP Patch.__init__(self, **kwargs) DCNL DCSP self.center = center DCNL DCSP (self.r, self.width) = (r, width) DCNL DCSP (self.theta1, self.theta2) = (theta1, theta2) DCNL DCSP delta = (theta2 - theta1) DCNL DCSP if (abs(((theta2 - theta1) - 360)) <= 1e-12): DCNL DCSP  DCSP (theta1, theta2) = (0, 360) DCNL DCSP  DCSP connector = Path.MOVETO DCNL DCSP else: DCNL DCSP  DCSP connector = Path.LINETO DCNL DCSP arc = Path.arc(theta1, theta2) DCNL DCSP if (width is not None): DCNL DCSP  DCSP v1 = arc.vertices DCNL DCSP  DCSP v2 = ((arc.vertices[::(-1)] * float((r - width))) / r) DCNL DCSP  DCSP v = np.vstack([v1, v2, v1[0, :], (0, 0)]) DCNL DCSP  DCSP c = np.hstack([arc.codes, arc.codes, connector, Path.CLOSEPOLY]) DCNL DCSP  DCSP c[len(arc.codes)] = connector DCNL DCSP else: DCNL DCSP  DCSP v = np.vstack([arc.vertices, [(0, 0), arc.vertices[0, :], (0, 0)]]) DCNL DCSP  DCSP c = np.hstack([arc.codes, [connector, connector, Path.CLOSEPOLY]]) DCNL DCSP v *= r DCNL DCSP v += np.asarray(center) DCNL DCSP self._path = Path(v, c) DCNL DCSP self._patch_transform = transforms.IdentityTransform()
def __init__(self, x, y, dx, dy, width=1.0, **kwargs): DCNL DCSP Patch.__init__(self, **kwargs) DCNL DCSP L = (np.sqrt(((dx ** 2) + (dy ** 2))) or 1) DCNL DCSP cx = (float(dx) / L) DCNL DCSP sx = (float(dy) / L) DCNL DCSP trans1 = transforms.Affine2D().scale(L, width) DCNL DCSP trans2 = transforms.Affine2D.from_values(cx, sx, (- sx), cx, 0.0, 0.0) DCNL DCSP trans3 = transforms.Affine2D().translate(x, y) DCNL DCSP trans = ((trans1 + trans2) + trans3) DCNL DCSP self._patch_transform = trans.frozen()
def __init__(self, x, y, dx, dy, width=0.001, length_includes_head=False, head_width=None, head_length=None, shape='full', overhang=0, head_starts_at_zero=False, **kwargs): DCNL DCSP if (head_width is None): DCNL DCSP  DCSP head_width = (3 * width) DCNL DCSP if (head_length is None): DCNL DCSP  DCSP head_length = (1.5 * head_width) DCNL DCSP distance = np.sqrt(((dx ** 2) + (dy ** 2))) DCNL DCSP if length_includes_head: DCNL DCSP  DCSP length = distance DCNL DCSP else: DCNL DCSP  DCSP length = (distance + head_length) DCNL DCSP if (not length): DCNL DCSP  DCSP verts = [] DCNL DCSP else: DCNL DCSP  DCSP (hw, hl, hs, lw) = (head_width, head_length, overhang, width) DCNL DCSP  DCSP left_half_arrow = np.array([[0.0, 0.0], [(- hl), ((- hw) / 2.0)], [((- hl) * (1 - hs)), ((- lw) / 2.0)], [(- length), ((- lw) / 2.0)], [(- length), 0]]) DCNL DCSP  DCSP if (not length_includes_head): DCNL DCSP  DCSP  DCSP left_half_arrow += [head_length, 0] DCNL DCSP  DCSP if head_starts_at_zero: DCNL DCSP  DCSP  DCSP left_half_arrow += [(head_length / 2.0), 0] DCNL DCSP  DCSP if (shape == 'left'): DCNL DCSP  DCSP  DCSP coords = left_half_arrow DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP right_half_arrow = (left_half_arrow * [1, (-1)]) DCNL DCSP  DCSP  DCSP if (shape == 'right'): DCNL DCSP  DCSP  DCSP  DCSP coords = right_half_arrow DCNL DCSP  DCSP  DCSP elif (shape == 'full'): DCNL DCSP  DCSP  DCSP  DCSP coords = np.concatenate([left_half_arrow[:(-1)], right_half_arrow[(-2)::(-1)]]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError, ('Got DCSP unknown DCSP shape: DCSP %s' % shape) DCNL DCSP  DCSP cx = (float(dx) / distance) DCNL DCSP  DCSP sx = (float(dy) / distance) DCNL DCSP  DCSP M = np.array([[cx, sx], [(- sx), cx]]) DCNL DCSP  DCSP verts = (np.dot(coords, M) + ((x + dx), (y + dy))) DCNL DCSP Polygon.__init__(self, map(tuple, verts), **kwargs)
def __init__(self, figure, xytip, xybase, width=4, frac=0.1, headwidth=12, **kwargs): DCNL DCSP self.figure = figure DCNL DCSP self.xytip = xytip DCNL DCSP self.xybase = xybase DCNL DCSP self.width = width DCNL DCSP self.frac = frac DCNL DCSP self.headwidth = headwidth DCNL DCSP Patch.__init__(self, **kwargs)
def getpoints(self, x1, y1, x2, y2, k): DCNL DCSP (x1, y1, x2, y2, k) = map(float, (x1, y1, x2, y2, k)) DCNL DCSP if ((y2 - y1) == 0): DCNL DCSP  DCSP return (x2, (y2 + k), x2, (y2 - k)) DCNL DCSP elif ((x2 - x1) == 0): DCNL DCSP  DCSP return ((x2 + k), y2, (x2 - k), y2) DCNL DCSP m = ((y2 - y1) / (x2 - x1)) DCNL DCSP pm = ((-1.0) / m) DCNL DCSP a = 1 DCNL DCSP b = ((-2) * y2) DCNL DCSP c = ((y2 ** 2.0) - (((k ** 2.0) * (pm ** 2.0)) / (1.0 + (pm ** 2.0)))) DCNL DCSP y3a = (((- b) + math.sqrt(((b ** 2.0) - ((4 * a) * c)))) / (2.0 * a)) DCNL DCSP x3a = (((y3a - y2) / pm) + x2) DCNL DCSP y3b = (((- b) - math.sqrt(((b ** 2.0) - ((4 * a) * c)))) / (2.0 * a)) DCNL DCSP x3b = (((y3b - y2) / pm) + x2) DCNL DCSP return (x3a, y3a, x3b, y3b)
def __init__(self, xy, radius=5, resolution=20, **kwargs): DCNL DCSP RegularPolygon.__init__(self, xy, resolution, radius, orientation=0, **kwargs)
def __init__(self, xy, width, height, angle=0.0, **kwargs): DCNL DCSP Patch.__init__(self, **kwargs) DCNL DCSP self.center = xy DCNL DCSP (self.width, self.height) = (width, height) DCNL DCSP self.angle = angle DCNL DCSP self._path = Path.unit_circle() DCNL DCSP self._patch_transform = transforms.IdentityTransform()
def _recompute_transform(self): DCNL DCSP center = (self.convert_xunits(self.center[0]), self.convert_yunits(self.center[1])) DCNL DCSP width = self.convert_xunits(self.width) DCNL DCSP height = self.convert_yunits(self.height) DCNL DCSP self._patch_transform = transforms.Affine2D().scale((width * 0.5), (height * 0.5)).rotate_deg(self.angle).translate(*center)
def get_path(self): DCNL DCSP return self._path
def __init__(self, xy, radius=5, **kwargs): DCNL DCSP if ('resolution' in kwargs): DCNL DCSP  DCSP import warnings DCNL DCSP  DCSP warnings.warn('Circle DCSP is DCSP now DCSP scale DCSP free. DCSP  DCSP Use DCSP CirclePolygon DCSP instead!', DeprecationWarning) DCNL DCSP  DCSP kwargs.pop('resolution') DCNL DCSP self.radius = radius DCNL DCSP Ellipse.__init__(self, xy, (radius * 2), (radius * 2), **kwargs)
def __init__(self, xy, width, height, angle=0.0, theta1=0.0, theta2=360.0, **kwargs): DCNL DCSP fill = kwargs.pop('fill') DCNL DCSP if fill: DCNL DCSP  DCSP raise ValueError('Arc DCSP objects DCSP can DCSP not DCSP be DCSP filled') DCNL DCSP kwargs['fill'] = False DCNL DCSP Ellipse.__init__(self, xy, width, height, angle, **kwargs) DCNL DCSP self.theta1 = theta1 DCNL DCSP self.theta2 = theta2
def draw(self, renderer): DCNL DCSP if (not hasattr(self, 'axes')): DCNL DCSP  DCSP raise RuntimeError('Arcs DCSP can DCSP only DCSP be DCSP used DCSP in DCSP Axes DCSP instances') DCNL DCSP self._recompute_transform() DCNL DCSP width = self.convert_xunits(self.width) DCNL DCSP height = self.convert_yunits(self.height) DCNL DCSP (width, height) = self.get_transform().transform_point((width, height)) DCNL DCSP inv_error = ((1.0 / 1.89818e-06) * 0.5) DCNL DCSP if ((width < inv_error) and (height < inv_error)): DCNL DCSP  DCSP self._path = Path.arc(self.theta1, self.theta2) DCNL DCSP  DCSP return Patch.draw(self, renderer) DCNL DCSP def iter_circle_intersect_on_line(x0, y0, x1, y1): DCNL DCSP  DCSP dx = (x1 - x0) DCNL DCSP  DCSP dy = (y1 - y0) DCNL DCSP  DCSP dr2 = ((dx * dx) + (dy * dy)) DCNL DCSP  DCSP D = ((x0 * y1) - (x1 * y0)) DCNL DCSP  DCSP D2 = (D * D) DCNL DCSP  DCSP discrim = (dr2 - D2) DCNL DCSP  DCSP if (discrim == 0.0): DCNL DCSP  DCSP  DCSP x = ((D * dy) / dr2) DCNL DCSP  DCSP  DCSP y = (((- D) * dx) / dr2) DCNL DCSP  DCSP  DCSP (yield (x, y)) DCNL DCSP  DCSP elif (discrim > 0.0): DCNL DCSP  DCSP  DCSP if (dy < 0.0): DCNL DCSP  DCSP  DCSP  DCSP sign_dy = (-1.0) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sign_dy = 1.0 DCNL DCSP  DCSP  DCSP sqrt_discrim = np.sqrt(discrim) DCNL DCSP  DCSP  DCSP for sign in (1.0, (-1.0)): DCNL DCSP  DCSP  DCSP  DCSP x = (((D * dy) + (((sign * sign_dy) * dx) * sqrt_discrim)) / dr2) DCNL DCSP  DCSP  DCSP  DCSP y = ((((- D) * dx) + ((sign * np.abs(dy)) * sqrt_discrim)) / dr2) DCNL DCSP  DCSP  DCSP  DCSP (yield (x, y)) DCNL DCSP def iter_circle_intersect_on_line_seg(x0, y0, x1, y1): DCNL DCSP  DCSP epsilon = 1e-09 DCNL DCSP  DCSP if (x1 < x0): DCNL DCSP  DCSP  DCSP (x0e, x1e) = (x1, x0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (x0e, x1e) = (x0, x1) DCNL DCSP  DCSP if (y1 < y0): DCNL DCSP  DCSP  DCSP (y0e, y1e) = (y1, y0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (y0e, y1e) = (y0, y1) DCNL DCSP  DCSP x0e -= epsilon DCNL DCSP  DCSP y0e -= epsilon DCNL DCSP  DCSP x1e += epsilon DCNL DCSP  DCSP y1e += epsilon DCNL DCSP  DCSP for (x, y) in iter_circle_intersect_on_line(x0, y0, x1, y1): DCNL DCSP  DCSP  DCSP if ((x >= x0e) and (x <= x1e) and (y >= y0e) and (y <= y1e)): DCNL DCSP  DCSP  DCSP  DCSP (yield (x, y)) DCNL DCSP box_path = Path.unit_rectangle() DCNL DCSP box_path_transform = (transforms.BboxTransformTo(self.axes.bbox) + self.get_transform().inverted()) DCNL DCSP box_path = box_path.transformed(box_path_transform) DCNL DCSP PI = np.pi DCNL DCSP TWOPI = (PI * 2.0) DCNL DCSP RAD2DEG = (180.0 / PI) DCNL DCSP DEG2RAD = (PI / 180.0) DCNL DCSP theta1 = self.theta1 DCNL DCSP theta2 = self.theta2 DCNL DCSP thetas = {} DCNL DCSP for (p0, p1) in zip(box_path.vertices[:(-1)], box_path.vertices[1:]): DCNL DCSP  DCSP (x0, y0) = p0 DCNL DCSP  DCSP (x1, y1) = p1 DCNL DCSP  DCSP for (x, y) in iter_circle_intersect_on_line_seg(x0, y0, x1, y1): DCNL DCSP  DCSP  DCSP theta = np.arccos(x) DCNL DCSP  DCSP  DCSP if (y < 0): DCNL DCSP  DCSP  DCSP  DCSP theta = (TWOPI - theta) DCNL DCSP  DCSP  DCSP theta *= RAD2DEG DCNL DCSP  DCSP  DCSP if ((theta > theta1) and (theta < theta2)): DCNL DCSP  DCSP  DCSP  DCSP thetas[theta] = None DCNL DCSP thetas = thetas.keys() DCNL DCSP thetas.sort() DCNL DCSP thetas.append(theta2) DCNL DCSP last_theta = theta1 DCNL DCSP theta1_rad = (theta1 * DEG2RAD) DCNL DCSP inside = box_path.contains_point((np.cos(theta1_rad), np.sin(theta1_rad))) DCNL DCSP for theta in thetas: DCNL DCSP  DCSP if inside: DCNL DCSP  DCSP  DCSP self._path = Path.arc(last_theta, theta, 8) DCNL DCSP  DCSP  DCSP Patch.draw(self, renderer) DCNL DCSP  DCSP  DCSP inside = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inside = True DCNL DCSP  DCSP last_theta = theta
def __new__(self, stylename, **kw): DCNL DCSP _list = stylename.replace(' DCSP ', '').split(',') DCNL DCSP _name = _list[0].lower() DCNL DCSP try: DCNL DCSP  DCSP _cls = self._style_list[_name] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP style DCSP : DCSP %s' % stylename)) DCNL DCSP try: DCNL DCSP  DCSP _args_pair = [cs.split('=') for cs in _list[1:]] DCNL DCSP  DCSP _args = dict([(k, float(v)) for (k, v) in _args_pair]) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(('Incorrect DCSP style DCSP argument DCSP : DCSP %s' % stylename)) DCNL DCSP _args.update(kw) DCNL DCSP return _cls(**_args)
@classmethod DCNL def get_styles(klass): DCNL DCSP return klass._style_list
@classmethod DCNL def pprint_styles(klass): DCNL DCSP return _pprint_styles(klass._style_list)
def __init__(self): DCNL DCSP super(BoxStyle._Base, self).__init__()
def transmute(self, x0, y0, width, height, mutation_size): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def __call__(self, x0, y0, width, height, mutation_size, aspect_ratio=1.0): DCNL DCSP if (aspect_ratio is not None): DCNL DCSP  DCSP (y0, height) = ((y0 / aspect_ratio), (height / aspect_ratio)) DCNL DCSP  DCSP path = self.transmute(x0, y0, width, height, mutation_size) DCNL DCSP  DCSP (vertices, codes) = (path.vertices, path.codes) DCNL DCSP  DCSP vertices[:, 1] = (vertices[:, 1] * aspect_ratio) DCNL DCSP  DCSP return Path(vertices, codes) DCNL DCSP else: DCNL DCSP  DCSP return self.transmute(x0, y0, width, height, mutation_size)
def __init__(self, pad=0.3): DCNL DCSP self.pad = pad DCNL DCSP super(BoxStyle.Square, self).__init__()
def __init__(self, pad=0.3, rounding_size=None): DCNL DCSP self.pad = pad DCNL DCSP self.rounding_size = rounding_size DCNL DCSP super(BoxStyle.Round, self).__init__()
def __init__(self, pad=0.3, rounding_size=None): DCNL DCSP self.pad = pad DCNL DCSP self.rounding_size = rounding_size DCNL DCSP super(BoxStyle.Round4, self).__init__()
def __init__(self, pad=0.3, tooth_size=None): DCNL DCSP self.pad = pad DCNL DCSP self.tooth_size = tooth_size DCNL DCSP super(BoxStyle.Sawtooth, self).__init__()
def __init__(self, pad=0.3, tooth_size=None): DCNL DCSP super(BoxStyle.Roundtooth, self).__init__(pad, tooth_size)
def __init__(self, xy, width, height, boxstyle='round', bbox_transmuter=None, mutation_scale=1.0, mutation_aspect=None, **kwargs): DCNL DCSP Patch.__init__(self, **kwargs) DCNL DCSP self._x = xy[0] DCNL DCSP self._y = xy[1] DCNL DCSP self._width = width DCNL DCSP self._height = height DCNL DCSP if (boxstyle == 'custom'): DCNL DCSP  DCSP if (bbox_transmuter is None): DCNL DCSP  DCSP  DCSP raise ValueError('bbox_transmuter DCSP argument DCSP is DCSP needed DCSP with DCSP custom DCSP boxstyle') DCNL DCSP  DCSP self._bbox_transmuter = bbox_transmuter DCNL DCSP else: DCNL DCSP  DCSP self.set_boxstyle(boxstyle) DCNL DCSP self._mutation_scale = mutation_scale DCNL DCSP self._mutation_aspect = mutation_aspect
def set_boxstyle(self, boxstyle=None, **kw): DCNL DCSP if (boxstyle == None): DCNL DCSP  DCSP return BoxStyle.pprint_styles() DCNL DCSP if isinstance(boxstyle, BoxStyle._Base): DCNL DCSP  DCSP self._bbox_transmuter = boxstyle DCNL DCSP elif callable(boxstyle): DCNL DCSP  DCSP self._bbox_transmuter = boxstyle DCNL DCSP else: DCNL DCSP  DCSP self._bbox_transmuter = BoxStyle(boxstyle, **kw)
def set_mutation_scale(self, scale): DCNL DCSP self._mutation_scale = scale
def get_mutation_scale(self): DCNL DCSP return self._mutation_scale
def set_mutation_aspect(self, aspect): DCNL DCSP self._mutation_aspect = aspect
def get_mutation_aspect(self): DCNL DCSP return self._mutation_aspect
def get_boxstyle(self): DCNL DCSP return self._bbox_transmuter
def get_path(self): DCNL DCSP _path = self.get_boxstyle()(self._x, self._y, self._width, self._height, self.get_mutation_scale(), self.get_mutation_aspect()) DCNL DCSP return _path
def get_x(self): DCNL DCSP return self._x
def get_y(self): DCNL DCSP return self._y
def get_width(self): DCNL DCSP return self._width
def get_height(self): DCNL DCSP return self._height
def set_x(self, x): DCNL DCSP self._x = x
def set_y(self, y): DCNL DCSP self._y = y
def set_width(self, w): DCNL DCSP self._width = w
def set_height(self, h): DCNL DCSP self._height = h
def set_bounds(self, *args): DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP (l, b, w, h) = args[0] DCNL DCSP else: DCNL DCSP  DCSP (l, b, w, h) = args DCNL DCSP self._x = l DCNL DCSP self._y = b DCNL DCSP self._width = w DCNL DCSP self._height = h
def _clip(self, path, patchA, patchB): DCNL DCSP if patchA: DCNL DCSP  DCSP def insideA(xy_display): DCNL DCSP  DCSP  DCSP xy_event = ConnectionStyle._Base.SimpleEvent(xy_display) DCNL DCSP  DCSP  DCSP return patchA.contains(xy_event)[0] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (left, right) = split_path_inout(path, insideA) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP right = path DCNL DCSP  DCSP path = right DCNL DCSP if patchB: DCNL DCSP  DCSP def insideB(xy_display): DCNL DCSP  DCSP  DCSP xy_event = ConnectionStyle._Base.SimpleEvent(xy_display) DCNL DCSP  DCSP  DCSP return patchB.contains(xy_event)[0] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (left, right) = split_path_inout(path, insideB) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP left = path DCNL DCSP  DCSP path = left DCNL DCSP return path
def _shrink(self, path, shrinkA, shrinkB): DCNL DCSP if shrinkA: DCNL DCSP  DCSP (x, y) = path.vertices[0] DCNL DCSP  DCSP insideA = inside_circle(x, y, shrinkA) DCNL DCSP  DCSP (left, right) = split_path_inout(path, insideA) DCNL DCSP  DCSP path = right DCNL DCSP if shrinkB: DCNL DCSP  DCSP (x, y) = path.vertices[(-1)] DCNL DCSP  DCSP insideB = inside_circle(x, y, shrinkB) DCNL DCSP  DCSP (left, right) = split_path_inout(path, insideB) DCNL DCSP  DCSP path = left DCNL DCSP return path
def __call__(self, posA, posB, shrinkA=2.0, shrinkB=2.0, patchA=None, patchB=None): DCNL DCSP path = self.connect(posA, posB) DCNL DCSP clipped_path = self._clip(path, patchA, patchB) DCNL DCSP shrinked_path = self._shrink(clipped_path, shrinkA, shrinkB) DCNL DCSP return shrinked_path
def __init__(self, rad=0.0): DCNL DCSP self.rad = rad
def __init__(self, angleA=90, angleB=0): DCNL DCSP self.angleA = angleA DCNL DCSP self.angleB = angleB
def __init__(self, angleA=90, angleB=0, rad=0.0): DCNL DCSP self.angleA = angleA DCNL DCSP self.angleB = angleB DCNL DCSP self.rad = rad
def __init__(self, angleA=0, angleB=0, armA=None, armB=None, rad=0.0): DCNL DCSP self.angleA = angleA DCNL DCSP self.angleB = angleB DCNL DCSP self.armA = armA DCNL DCSP self.armB = armB DCNL DCSP self.rad = rad
@staticmethod DCNL def ensure_quadratic_bezier(path): DCNL DCSP segments = list(path.iter_segments()) DCNL DCSP assert (len(segments) == 2) DCNL DCSP assert (segments[0][1] == Path.MOVETO) DCNL DCSP assert (segments[1][1] == Path.CURVE3) DCNL DCSP return (list(segments[0][0]) + list(segments[1][0]))
def transmute(self, path, mutation_size, linewidth): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def __call__(self, path, mutation_size, linewidth, aspect_ratio=1.0): DCNL DCSP if (aspect_ratio is not None): DCNL DCSP  DCSP (vertices, codes) = (path.vertices[:], path.codes[:]) DCNL DCSP  DCSP vertices[:, 1] = (vertices[:, 1] / aspect_ratio) DCNL DCSP  DCSP path_shrinked = Path(vertices, codes) DCNL DCSP  DCSP (path_mutated, closed) = self.transmute(path_shrinked, linewidth, mutation_size) DCNL DCSP  DCSP (vertices, codes) = (path_mutated.vertices, path_mutated.codes) DCNL DCSP  DCSP vertices[:, 1] = (vertices[:, 1] * aspect_ratio) DCNL DCSP  DCSP return (Path(vertices, codes), closed) DCNL DCSP else: DCNL DCSP  DCSP return self.transmute(path, mutation_size, linewidth)
def __init__(self, beginarrow=None, endarrow=None, head_length=0.2, head_width=0.1): DCNL DCSP (self.beginarrow, self.endarrow) = (beginarrow, endarrow) DCNL DCSP (self.head_length, self.head_width) = (head_length, head_width) DCNL DCSP super(ArrowStyle._Curve, self).__init__()
def _get_arrow_wedge(self, x0, y0, x1, y1, head_dist, cos_t, sin_t, linewidth): DCNL DCSP (dx, dy) = ((x0 - x1), (y0 - y1)) DCNL DCSP cp_distance = math.sqrt(((dx ** 2) + (dy ** 2))) DCNL DCSP padx_projected = ((0.5 * linewidth) / cos_t) DCNL DCSP pady_projected = ((0.5 * linewidth) / sin_t) DCNL DCSP ddx = ((padx_projected * dx) / cp_distance) DCNL DCSP ddy = ((pady_projected * dy) / cp_distance) DCNL DCSP (dx, dy) = (((dx / cp_distance) * head_dist), ((dy / cp_distance) * head_dist)) DCNL DCSP (dx1, dy1) = (((cos_t * dx) + (sin_t * dy)), (((- sin_t) * dx) + (cos_t * dy))) DCNL DCSP (dx2, dy2) = (((cos_t * dx) - (sin_t * dy)), ((sin_t * dx) + (cos_t * dy))) DCNL DCSP vertices_arrow = [(((x1 + ddx) + dx1), ((y1 + ddy) + dy1)), ((x1 + ddx), (y1 + (+ ddy))), (((x1 + ddx) + dx2), ((y1 + ddy) + dy2))] DCNL DCSP codes_arrow = [Path.MOVETO, Path.LINETO, Path.LINETO] DCNL DCSP return (vertices_arrow, codes_arrow, ddx, ddy)
def __init__(self, head_length=0.4, head_width=0.2): DCNL DCSP super(ArrowStyle.CurveA, self).__init__(beginarrow=True, endarrow=False, head_length=head_length, head_width=head_width)
def __init__(self, head_length=0.4, head_width=0.2): DCNL DCSP super(ArrowStyle.CurveB, self).__init__(beginarrow=False, endarrow=True, head_length=head_length, head_width=head_width)
def __init__(self, head_length=0.4, head_width=0.2): DCNL DCSP super(ArrowStyle.CurveAB, self).__init__(beginarrow=True, endarrow=True, head_length=head_length, head_width=head_width)
def __init__(self, widthB=1.0, lengthB=0.2, angleB=None): DCNL DCSP super(ArrowStyle.BracketB, self).__init__(None, True, widthB=widthB, lengthB=lengthB, angleB=None)
def __init__(self, head_length=0.5, head_width=0.5, tail_width=0.2): DCNL DCSP (self.head_length, self.head_width, self.tail_width) = (head_length, head_width, tail_width) DCNL DCSP super(ArrowStyle.Simple, self).__init__()
def __init__(self, head_length=0.4, head_width=0.4, tail_width=0.4): DCNL DCSP (self.head_length, self.head_width, self.tail_width) = (head_length, head_width, tail_width) DCNL DCSP super(ArrowStyle.Fancy, self).__init__()
def __init__(self, tail_width=0.3, shrink_factor=0.5): DCNL DCSP self.tail_width = tail_width DCNL DCSP self.shrink_factor = shrink_factor DCNL DCSP super(ArrowStyle.Wedge, self).__init__()
def __init__(self, posA=None, posB=None, path=None, arrowstyle='simple', arrow_transmuter=None, connectionstyle='arc3', connector=None, patchA=None, patchB=None, shrinkA=2.0, shrinkB=2.0, mutation_scale=1.0, mutation_aspect=None, **kwargs): DCNL DCSP if ((posA is not None) and (posB is not None) and (path is None)): DCNL DCSP  DCSP self._posA_posB = [posA, posB] DCNL DCSP  DCSP if (connectionstyle is None): DCNL DCSP  DCSP  DCSP connectionstyle = 'arc3' DCNL DCSP  DCSP self.set_connectionstyle(connectionstyle) DCNL DCSP elif ((posA is None) and (posB is None) and (path is not None)): DCNL DCSP  DCSP self._posA_posB = None DCNL DCSP  DCSP self._connetors = None DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('either DCSP posA DCSP and DCSP posB, DCSP or DCSP path DCSP need DCSP to DCSP provided') DCNL DCSP self.patchA = patchA DCNL DCSP self.patchB = patchB DCNL DCSP self.shrinkA = shrinkA DCNL DCSP self.shrinkB = shrinkB DCNL DCSP Patch.__init__(self, **kwargs) DCNL DCSP self._path_original = path DCNL DCSP self.set_arrowstyle(arrowstyle) DCNL DCSP self._mutation_scale = mutation_scale DCNL DCSP self._mutation_aspect = mutation_aspect
def set_positions(self, posA, posB): DCNL DCSP if (posA is not None): DCNL DCSP  DCSP self._posA_posB[0] = posA DCNL DCSP if (posB is not None): DCNL DCSP  DCSP self._posA_posB[1] = posB
def set_patchA(self, patchA): DCNL DCSP self.patchA = patchA
def set_patchB(self, patchB): DCNL DCSP self.patchB = patchB
def set_connectionstyle(self, connectionstyle, **kw): DCNL DCSP if (connectionstyle == None): DCNL DCSP  DCSP return ConnectionStyle.pprint_styles() DCNL DCSP if isinstance(connectionstyle, ConnectionStyle._Base): DCNL DCSP  DCSP self._connector = connectionstyle DCNL DCSP elif callable(connectionstyle): DCNL DCSP  DCSP self._connector = connectionstyle DCNL DCSP else: DCNL DCSP  DCSP self._connector = ConnectionStyle(connectionstyle, **kw)
def get_connectionstyle(self): DCNL DCSP return self._connector
def set_arrowstyle(self, arrowstyle=None, **kw): DCNL DCSP if (arrowstyle == None): DCNL DCSP  DCSP return ArrowStyle.pprint_styles() DCNL DCSP if isinstance(arrowstyle, ConnectionStyle._Base): DCNL DCSP  DCSP self._arrow_transmuter = arrowstyle DCNL DCSP else: DCNL DCSP  DCSP self._arrow_transmuter = ArrowStyle(arrowstyle, **kw)
def get_arrowstyle(self): DCNL DCSP return self._arrow_transmuter
def set_mutation_scale(self, scale): DCNL DCSP self._mutation_scale = scale
def get_mutation_scale(self): DCNL DCSP return self._mutation_scale
def set_mutation_aspect(self, aspect): DCNL DCSP self._mutation_aspect = aspect
def get_mutation_aspect(self): DCNL DCSP return self._mutation_aspect
def get_path(self): DCNL DCSP _path = self.get_path_in_displaycoord() DCNL DCSP return self.get_transform().inverted().transform_path(_path)
def get_path_in_displaycoord(self): DCNL DCSP if (self._posA_posB is not None): DCNL DCSP  DCSP posA = self.get_transform().transform_point(self._posA_posB[0]) DCNL DCSP  DCSP posB = self.get_transform().transform_point(self._posA_posB[1]) DCNL DCSP  DCSP _path = self.get_connectionstyle()(posA, posB, patchA=self.patchA, patchB=self.patchB, shrinkA=self.shrinkA, shrinkB=self.shrinkB) DCNL DCSP else: DCNL DCSP  DCSP _path = self.get_transform().transform_path(self._path_original) DCNL DCSP (_path, closed) = self.get_arrowstyle()(_path, self.get_mutation_scale(), self.get_linewidth(), self.get_mutation_aspect()) DCNL DCSP if (not closed): DCNL DCSP  DCSP self.fill = False DCNL DCSP return _path
def _split(self, data): DCNL DCSP idx = data.index('eexec') DCNL DCSP idx += len('eexec') DCNL DCSP while (data[idx] in ' DCSP  DCTB \r\n'): DCNL DCSP  DCSP idx += 1 DCNL DCSP len1 = idx DCNL DCSP idx = (data.rindex('cleartomark') - 1) DCNL DCSP zeros = 512 DCNL DCSP while (zeros and (data[idx] in ('0', '\n', '\r'))): DCNL DCSP  DCSP if (data[idx] == '0'): DCNL DCSP  DCSP  DCSP zeros -= 1 DCNL DCSP  DCSP idx -= 1 DCNL DCSP if zeros: DCNL DCSP  DCSP raise RuntimeError, 'Insufficiently DCSP many DCSP zeros DCSP in DCSP Type DCSP 1 DCSP font' DCNL DCSP binary = ''.join([chr(int(data[i:(i + 2)], 16)) for i in range(len1, idx, 2)]) DCNL DCSP return (data[:len1], binary, data[idx:])
def _parse(self): DCNL DCSP def tokens(text): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Yield DCSP pairs DCSP (position, DCSP token), DCSP ignoring DCSP comments DCSP and\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP whitespace. DCSP Numbers DCSP count DCSP as DCSP tokens.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP pos = 0 DCNL DCSP  DCSP while (pos < len(text)): DCNL DCSP  DCSP  DCSP match = (self._comment.match(text[pos:]) or self._whitespace.match(text[pos:])) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP pos += match.end() DCNL DCSP  DCSP  DCSP elif (text[pos] == '('): DCNL DCSP  DCSP  DCSP  DCSP start = pos DCNL DCSP  DCSP  DCSP  DCSP pos += 1 DCNL DCSP  DCSP  DCSP  DCSP depth = 1 DCNL DCSP  DCSP  DCSP  DCSP while depth: DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = self._instring.search(text[pos:]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (match is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (match.group() == '('): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP depth += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pos += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (match.group() == ')'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP depth -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pos += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pos += 2 DCNL DCSP  DCSP  DCSP  DCSP (yield (start, text[start:pos])) DCNL DCSP  DCSP  DCSP elif (text[pos:(pos + 2)] in ('<<', '>>')): DCNL DCSP  DCSP  DCSP  DCSP (yield (pos, text[pos:(pos + 2)])) DCNL DCSP  DCSP  DCSP  DCSP pos += 2 DCNL DCSP  DCSP  DCSP elif (text[pos] == '<'): DCNL DCSP  DCSP  DCSP  DCSP start = pos DCNL DCSP  DCSP  DCSP  DCSP pos += text[pos:].index('>') DCNL DCSP  DCSP  DCSP  DCSP (yield (start, text[start:pos])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP match = self._token.match(text[pos:]) DCNL DCSP  DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (pos, match.group())) DCNL DCSP  DCSP  DCSP  DCSP  DCSP pos += match.end() DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (pos, text[pos])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP pos += 1 DCNL DCSP (enc_starts, enc_ends) = (None, None) DCNL DCSP state = 0 DCNL DCSP for (pos, token) in tokens(self.parts[0]): DCNL DCSP  DCSP if ((state == 0) and (token == '/Encoding')): DCNL DCSP  DCSP  DCSP enc_starts = pos DCNL DCSP  DCSP  DCSP state = 1 DCNL DCSP  DCSP elif ((state == 1) and (token == 'StandardEncoding')): DCNL DCSP  DCSP  DCSP state = 2 DCNL DCSP  DCSP elif ((state in (2, 5)) and (token == 'def')): DCNL DCSP  DCSP  DCSP enc_ends = (pos + 3) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif ((state in (1, 5)) and (token == 'dup')): DCNL DCSP  DCSP  DCSP state = 4 DCNL DCSP  DCSP elif ((state == 4) and (token == 'put')): DCNL DCSP  DCSP  DCSP state = 5 DCNL DCSP (self.enc_starts, self.enc_ends) = (enc_starts, enc_ends)
def __init__(self, axes, loc, label, size=None, gridOn=None, tick1On=True, tick2On=True, label1On=True, label2On=False, major=True): DCNL DCSP artist.Artist.__init__(self) DCNL DCSP if (gridOn is None): DCNL DCSP  DCSP gridOn = rcParams['axes.grid'] DCNL DCSP self.set_figure(axes.figure) DCNL DCSP self.axes = axes DCNL DCSP name = self.__name__.lower() DCNL DCSP if (size is None): DCNL DCSP  DCSP if major: DCNL DCSP  DCSP  DCSP size = rcParams[('%s.major.size' % name)] DCNL DCSP  DCSP  DCSP pad = rcParams[('%s.major.pad' % name)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP size = rcParams[('%s.minor.size' % name)] DCNL DCSP  DCSP  DCSP pad = rcParams[('%s.minor.pad' % name)] DCNL DCSP self._tickdir = rcParams[('%s.direction' % name)] DCNL DCSP if (self._tickdir == 'in'): DCNL DCSP  DCSP self._xtickmarkers = (mlines.TICKUP, mlines.TICKDOWN) DCNL DCSP  DCSP self._ytickmarkers = (mlines.TICKRIGHT, mlines.TICKLEFT) DCNL DCSP  DCSP self._pad = pad DCNL DCSP else: DCNL DCSP  DCSP self._xtickmarkers = (mlines.TICKDOWN, mlines.TICKUP) DCNL DCSP  DCSP self._ytickmarkers = (mlines.TICKLEFT, mlines.TICKRIGHT) DCNL DCSP  DCSP self._pad = (pad + size) DCNL DCSP self._loc = loc DCNL DCSP self._size = size DCNL DCSP self.tick1line = self._get_tick1line() DCNL DCSP self.tick2line = self._get_tick2line() DCNL DCSP self.gridline = self._get_gridline() DCNL DCSP self.label1 = self._get_text1() DCNL DCSP self.label = self.label1 DCNL DCSP self.label2 = self._get_text2() DCNL DCSP self.gridOn = gridOn DCNL DCSP self.tick1On = tick1On DCNL DCSP self.tick2On = tick2On DCNL DCSP self.label1On = label1On DCNL DCSP self.label2On = label2On DCNL DCSP self.update_position(loc)
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP return (False, {})
def set_pad(self, val): DCNL DCSP self._pad = val
def get_pad(self): DCNL DCSP return self._pad
def _get_text1(self): DCNL DCSP pass
def _get_text2(self): DCNL DCSP pass
def _get_tick1line(self): DCNL DCSP pass
def _get_tick2line(self): DCNL DCSP pass
def _get_gridline(self): DCNL DCSP pass
def get_loc(self): DCNL DCSP return self._loc
def set_label1(self, s): DCNL DCSP self.label1.set_text(s)
def set_label2(self, s): DCNL DCSP self.label2.set_text(s)
def get_view_interval(self): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def _get_text1(self): DCNL DCSP (trans, vert, horiz) = self.axes.get_xaxis_text1_transform(self._pad) DCNL DCSP size = rcParams['xtick.labelsize'] DCNL DCSP t = mtext.Text(x=0, y=0, fontproperties=font_manager.FontProperties(size=size), color=rcParams['xtick.color'], verticalalignment=vert, horizontalalignment=horiz) DCNL DCSP t.set_transform(trans) DCNL DCSP self._set_artist_props(t) DCNL DCSP return t
def _get_text2(self): DCNL DCSP (trans, vert, horiz) = self.axes.get_xaxis_text2_transform(self._pad) DCNL DCSP t = mtext.Text(x=0, y=1, fontproperties=font_manager.FontProperties(size=rcParams['xtick.labelsize']), color=rcParams['xtick.color'], verticalalignment=vert, horizontalalignment=horiz) DCNL DCSP t.set_transform(trans) DCNL DCSP self._set_artist_props(t) DCNL DCSP return t
def _get_tick1line(self): DCNL DCSP l = mlines.Line2D(xdata=(0,), ydata=(0,), color='k', linestyle='None', marker=self._xtickmarkers[0], markersize=self._size) DCNL DCSP l.set_transform(self.axes.get_xaxis_transform()) DCNL DCSP self._set_artist_props(l) DCNL DCSP return l
def _get_tick2line(self): DCNL DCSP l = mlines.Line2D(xdata=(0,), ydata=(1,), color='k', linestyle='None', marker=self._xtickmarkers[1], markersize=self._size) DCNL DCSP l.set_transform(self.axes.get_xaxis_transform()) DCNL DCSP self._set_artist_props(l) DCNL DCSP return l
def _get_gridline(self): DCNL DCSP l = mlines.Line2D(xdata=(0.0, 0.0), ydata=(0, 1.0), color=rcParams['grid.color'], linestyle=rcParams['grid.linestyle'], linewidth=rcParams['grid.linewidth']) DCNL DCSP l.set_transform(self.axes.get_xaxis_transform()) DCNL DCSP self._set_artist_props(l) DCNL DCSP return l
def update_position(self, loc): DCNL DCSP x = loc DCNL DCSP nonlinear = ((hasattr(self.axes, 'yaxis') and (self.axes.yaxis.get_scale() != 'linear')) or (hasattr(self.axes, 'xaxis') and (self.axes.xaxis.get_scale() != 'linear'))) DCNL DCSP if self.tick1On: DCNL DCSP  DCSP self.tick1line.set_xdata((x,)) DCNL DCSP if self.tick2On: DCNL DCSP  DCSP self.tick2line.set_xdata((x,)) DCNL DCSP if self.gridOn: DCNL DCSP  DCSP self.gridline.set_xdata((x,)) DCNL DCSP if self.label1On: DCNL DCSP  DCSP self.label1.set_x(x) DCNL DCSP if self.label2On: DCNL DCSP  DCSP self.label2.set_x(x) DCNL DCSP if nonlinear: DCNL DCSP  DCSP self.tick1line._invalid = True DCNL DCSP  DCSP self.tick2line._invalid = True DCNL DCSP  DCSP self.gridline._invalid = True DCNL DCSP self._loc = loc
def get_view_interval(self): DCNL DCSP return self.axes.viewLim.intervalx
def get_data_interval(self): DCNL DCSP return self.axes.dataLim.intervalx
def _get_text1(self): DCNL DCSP (trans, vert, horiz) = self.axes.get_yaxis_text1_transform(self._pad) DCNL DCSP t = mtext.Text(x=0, y=0, fontproperties=font_manager.FontProperties(size=rcParams['ytick.labelsize']), color=rcParams['ytick.color'], verticalalignment=vert, horizontalalignment=horiz) DCNL DCSP t.set_transform(trans) DCNL DCSP self._set_artist_props(t) DCNL DCSP return t
def _get_text2(self): DCNL DCSP (trans, vert, horiz) = self.axes.get_yaxis_text2_transform(self._pad) DCNL DCSP t = mtext.Text(x=1, y=0, fontproperties=font_manager.FontProperties(size=rcParams['ytick.labelsize']), color=rcParams['ytick.color'], verticalalignment=vert, horizontalalignment=horiz) DCNL DCSP t.set_transform(trans) DCNL DCSP self._set_artist_props(t) DCNL DCSP return t
def _get_tick1line(self): DCNL DCSP l = mlines.Line2D((0,), (0,), color='k', marker=self._ytickmarkers[0], linestyle='None', markersize=self._size) DCNL DCSP l.set_transform(self.axes.get_yaxis_transform()) DCNL DCSP self._set_artist_props(l) DCNL DCSP return l
def _get_tick2line(self): DCNL DCSP l = mlines.Line2D((1,), (0,), color='k', marker=self._ytickmarkers[1], linestyle='None', markersize=self._size) DCNL DCSP l.set_transform(self.axes.get_yaxis_transform()) DCNL DCSP self._set_artist_props(l) DCNL DCSP return l
def _get_gridline(self): DCNL DCSP l = mlines.Line2D(xdata=(0, 1), ydata=(0, 0), color=rcParams['grid.color'], linestyle=rcParams['grid.linestyle'], linewidth=rcParams['grid.linewidth']) DCNL DCSP l.set_transform(self.axes.get_yaxis_transform()) DCNL DCSP self._set_artist_props(l) DCNL DCSP return l
def update_position(self, loc): DCNL DCSP y = loc DCNL DCSP nonlinear = ((hasattr(self.axes, 'yaxis') and (self.axes.yaxis.get_scale() != 'linear')) or (hasattr(self.axes, 'xaxis') and (self.axes.xaxis.get_scale() != 'linear'))) DCNL DCSP if self.tick1On: DCNL DCSP  DCSP self.tick1line.set_ydata((y,)) DCNL DCSP if self.tick2On: DCNL DCSP  DCSP self.tick2line.set_ydata((y,)) DCNL DCSP if self.gridOn: DCNL DCSP  DCSP self.gridline.set_ydata((y,)) DCNL DCSP if self.label1On: DCNL DCSP  DCSP self.label1.set_y(y) DCNL DCSP if self.label2On: DCNL DCSP  DCSP self.label2.set_y(y) DCNL DCSP if nonlinear: DCNL DCSP  DCSP self.tick1line._invalid = True DCNL DCSP  DCSP self.tick2line._invalid = True DCNL DCSP  DCSP self.gridline._invalid = True DCNL DCSP self._loc = loc
def get_view_interval(self): DCNL DCSP return self.axes.viewLim.intervaly
def get_data_interval(self): DCNL DCSP return self.axes.dataLim.intervaly
def __init__(self, axes, pickradius=15): DCNL DCSP artist.Artist.__init__(self) DCNL DCSP self.set_figure(axes.figure) DCNL DCSP self.axes = axes DCNL DCSP self.major = Ticker() DCNL DCSP self.minor = Ticker() DCNL DCSP self.callbacks = cbook.CallbackRegistry(('units', 'units DCSP finalize')) DCNL DCSP self._autolabelpos = True DCNL DCSP self.label = self._get_label() DCNL DCSP self.offsetText = self._get_offset_text() DCNL DCSP self.majorTicks = [] DCNL DCSP self.minorTicks = [] DCNL DCSP self.pickradius = pickradius DCNL DCSP self.cla() DCNL DCSP self.set_scale('linear')
def set_label_coords(self, x, y, transform=None): DCNL DCSP self._autolabelpos = False DCNL DCSP if (transform is None): DCNL DCSP  DCSP transform = self.axes.transAxes DCNL DCSP self.label.set_transform(transform) DCNL DCSP self.label.set_position((x, y))
def cla(self): DCNL DCSP self.set_major_locator(mticker.AutoLocator()) DCNL DCSP self.set_major_formatter(mticker.ScalarFormatter()) DCNL DCSP self.set_minor_locator(mticker.NullLocator()) DCNL DCSP self.set_minor_formatter(mticker.NullFormatter()) DCNL DCSP self.callbacks = cbook.CallbackRegistry(('units', 'units DCSP finalize')) DCNL DCSP self._gridOnMajor = rcParams['axes.grid'] DCNL DCSP self._gridOnMinor = False DCNL DCSP self.label.set_text('') DCNL DCSP self._set_artist_props(self.label) DCNL DCSP cbook.popall(self.majorTicks) DCNL DCSP cbook.popall(self.minorTicks) DCNL DCSP self.majorTicks.extend([self._get_tick(major=True)]) DCNL DCSP self.minorTicks.extend([self._get_tick(major=False)]) DCNL DCSP self._lastNumMajorTicks = 1 DCNL DCSP self._lastNumMinorTicks = 1 DCNL DCSP self.converter = None DCNL DCSP self.units = None DCNL DCSP self.set_units(None)
def get_view_interval(self): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def get_data_interval(self): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def set_data_interval(self): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def iter_ticks(self): DCNL DCSP majorLocs = self.major.locator() DCNL DCSP majorTicks = self.get_major_ticks(len(majorLocs)) DCNL DCSP self.major.formatter.set_locs(majorLocs) DCNL DCSP majorLabels = [self.major.formatter(val, i) for (i, val) in enumerate(majorLocs)] DCNL DCSP minorLocs = self.minor.locator() DCNL DCSP minorTicks = self.get_minor_ticks(len(minorLocs)) DCNL DCSP self.minor.formatter.set_locs(minorLocs) DCNL DCSP minorLabels = [self.minor.formatter(val, i) for (i, val) in enumerate(minorLocs)] DCNL DCSP major_minor = [(majorTicks, majorLocs, majorLabels), (minorTicks, minorLocs, minorLabels)] DCNL DCSP for group in major_minor: DCNL DCSP  DCSP for tick in zip(*group): DCNL DCSP  DCSP  DCSP (yield tick)
def get_ticklabel_extents(self, renderer): DCNL DCSP ticklabelBoxes = [] DCNL DCSP ticklabelBoxes2 = [] DCNL DCSP interval = self.get_view_interval() DCNL DCSP for (tick, loc, label) in self.iter_ticks(): DCNL DCSP  DCSP if (tick is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not mtransforms.interval_contains(interval, loc)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tick.update_position(loc) DCNL DCSP  DCSP tick.set_label1(label) DCNL DCSP  DCSP tick.set_label2(label) DCNL DCSP  DCSP if (tick.label1On and tick.label1.get_visible()): DCNL DCSP  DCSP  DCSP extent = tick.label1.get_window_extent(renderer) DCNL DCSP  DCSP  DCSP ticklabelBoxes.append(extent) DCNL DCSP  DCSP if (tick.label2On and tick.label2.get_visible()): DCNL DCSP  DCSP  DCSP extent = tick.label2.get_window_extent(renderer) DCNL DCSP  DCSP  DCSP ticklabelBoxes2.append(extent) DCNL DCSP if len(ticklabelBoxes): DCNL DCSP  DCSP bbox = mtransforms.Bbox.union(ticklabelBoxes) DCNL DCSP else: DCNL DCSP  DCSP bbox = mtransforms.Bbox.from_extents(0, 0, 0, 0) DCNL DCSP if len(ticklabelBoxes2): DCNL DCSP  DCSP bbox2 = mtransforms.Bbox.union(ticklabelBoxes2) DCNL DCSP else: DCNL DCSP  DCSP bbox2 = mtransforms.Bbox.from_extents(0, 0, 0, 0) DCNL DCSP return (bbox, bbox2)
def draw(self, renderer, *args, **kwargs): DCNL DCSP ticklabelBoxes = [] DCNL DCSP ticklabelBoxes2 = [] DCNL DCSP if (not self.get_visible()): DCNL DCSP  DCSP return DCNL DCSP renderer.open_group(__name__) DCNL DCSP interval = self.get_view_interval() DCNL DCSP for (tick, loc, label) in self.iter_ticks(): DCNL DCSP  DCSP if (tick is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not mtransforms.interval_contains(interval, loc)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tick.update_position(loc) DCNL DCSP  DCSP tick.set_label1(label) DCNL DCSP  DCSP tick.set_label2(label) DCNL DCSP  DCSP tick.draw(renderer) DCNL DCSP  DCSP if (tick.label1On and tick.label1.get_visible()): DCNL DCSP  DCSP  DCSP extent = tick.label1.get_window_extent(renderer) DCNL DCSP  DCSP  DCSP ticklabelBoxes.append(extent) DCNL DCSP  DCSP if (tick.label2On and tick.label2.get_visible()): DCNL DCSP  DCSP  DCSP extent = tick.label2.get_window_extent(renderer) DCNL DCSP  DCSP  DCSP ticklabelBoxes2.append(extent) DCNL DCSP self._update_label_position(ticklabelBoxes, ticklabelBoxes2) DCNL DCSP self.label.draw(renderer) DCNL DCSP self._update_offset_text_position(ticklabelBoxes, ticklabelBoxes2) DCNL DCSP self.offsetText.set_text(self.major.formatter.get_offset()) DCNL DCSP self.offsetText.draw(renderer) DCNL DCSP if 0: DCNL DCSP  DCSP for tick in majorTicks: DCNL DCSP  DCSP  DCSP label = tick.label1 DCNL DCSP  DCSP  DCSP mpatches.bbox_artist(label, renderer) DCNL DCSP  DCSP mpatches.bbox_artist(self.label, renderer) DCNL DCSP renderer.close_group(__name__)
def get_gridlines(self): DCNL DCSP ticks = self.get_major_ticks() DCNL DCSP return cbook.silent_list('Line2D DCSP gridline', [tick.gridline for tick in ticks])
def get_label(self): DCNL DCSP return self.label
def get_offset_text(self): DCNL DCSP return self.offsetText
def get_pickradius(self): DCNL DCSP return self.pickradius
def get_majorticklabels(self): DCNL DCSP ticks = self.get_major_ticks() DCNL DCSP labels1 = [tick.label1 for tick in ticks if tick.label1On] DCNL DCSP labels2 = [tick.label2 for tick in ticks if tick.label2On] DCNL DCSP return cbook.silent_list('Text DCSP major DCSP ticklabel', (labels1 + labels2))
def get_minorticklabels(self): DCNL DCSP ticks = self.get_minor_ticks() DCNL DCSP labels1 = [tick.label1 for tick in ticks if tick.label1On] DCNL DCSP labels2 = [tick.label2 for tick in ticks if tick.label2On] DCNL DCSP return cbook.silent_list('Text DCSP minor DCSP ticklabel', (labels1 + labels2))
def get_ticklabels(self, minor=False): DCNL DCSP if minor: DCNL DCSP  DCSP return self.get_minorticklabels() DCNL DCSP return self.get_majorticklabels()
def get_majorticklines(self): DCNL DCSP lines = [] DCNL DCSP ticks = self.get_major_ticks() DCNL DCSP for tick in ticks: DCNL DCSP  DCSP lines.append(tick.tick1line) DCNL DCSP  DCSP lines.append(tick.tick2line) DCNL DCSP return cbook.silent_list('Line2D DCSP ticklines', lines)
def get_minorticklines(self): DCNL DCSP lines = [] DCNL DCSP ticks = self.get_minor_ticks() DCNL DCSP for tick in ticks: DCNL DCSP  DCSP lines.append(tick.tick1line) DCNL DCSP  DCSP lines.append(tick.tick2line) DCNL DCSP return cbook.silent_list('Line2D DCSP ticklines', lines)
def get_ticklines(self, minor=False): DCNL DCSP if minor: DCNL DCSP  DCSP return self.get_minorticklines() DCNL DCSP return self.get_majorticklines()
def get_majorticklocs(self): DCNL DCSP return self.major.locator()
def get_minorticklocs(self): DCNL DCSP return self.minor.locator()
def get_ticklocs(self, minor=False): DCNL DCSP if minor: DCNL DCSP  DCSP return self.minor.locator() DCNL DCSP return self.major.locator()
def _get_tick(self, major): DCNL DCSP raise NotImplementedError('derived DCSP must DCSP override')
def _copy_tick_props(self, src, dest): DCNL DCSP if ((src is None) or (dest is None)): DCNL DCSP  DCSP return DCNL DCSP dest.label1.update_from(src.label1) DCNL DCSP dest.label2.update_from(src.label2) DCNL DCSP dest.tick1line.update_from(src.tick1line) DCNL DCSP dest.tick2line.update_from(src.tick2line) DCNL DCSP dest.gridline.update_from(src.gridline) DCNL DCSP dest.tick1On = src.tick1On DCNL DCSP dest.tick2On = src.tick2On DCNL DCSP dest.label1On = src.label1On DCNL DCSP dest.label2On = src.label2On
def get_major_locator(self): DCNL DCSP return self.major.locator
def get_minor_locator(self): DCNL DCSP return self.minor.locator
def get_major_formatter(self): DCNL DCSP return self.major.formatter
def get_minor_formatter(self): DCNL DCSP return self.minor.formatter
def get_major_ticks(self, numticks=None): DCNL DCSP if (numticks is None): DCNL DCSP  DCSP numticks = len(self.get_major_locator()()) DCNL DCSP if (len(self.majorTicks) < numticks): DCNL DCSP  DCSP for i in range((numticks - len(self.majorTicks))): DCNL DCSP  DCSP  DCSP tick = self._get_tick(major=True) DCNL DCSP  DCSP  DCSP self.majorTicks.append(tick) DCNL DCSP if (self._lastNumMajorTicks < numticks): DCNL DCSP  DCSP protoTick = self.majorTicks[0] DCNL DCSP  DCSP for i in range(self._lastNumMajorTicks, len(self.majorTicks)): DCNL DCSP  DCSP  DCSP tick = self.majorTicks[i] DCNL DCSP  DCSP  DCSP if self._gridOnMajor: DCNL DCSP  DCSP  DCSP  DCSP tick.gridOn = True DCNL DCSP  DCSP  DCSP self._copy_tick_props(protoTick, tick) DCNL DCSP self._lastNumMajorTicks = numticks DCNL DCSP ticks = self.majorTicks[:numticks] DCNL DCSP return ticks
def get_minor_ticks(self, numticks=None): DCNL DCSP if (numticks is None): DCNL DCSP  DCSP numticks = len(self.get_minor_locator()()) DCNL DCSP if (len(self.minorTicks) < numticks): DCNL DCSP  DCSP for i in range((numticks - len(self.minorTicks))): DCNL DCSP  DCSP  DCSP tick = self._get_tick(major=False) DCNL DCSP  DCSP  DCSP self.minorTicks.append(tick) DCNL DCSP if (self._lastNumMinorTicks < numticks): DCNL DCSP  DCSP protoTick = self.minorTicks[0] DCNL DCSP  DCSP for i in range(self._lastNumMinorTicks, len(self.minorTicks)): DCNL DCSP  DCSP  DCSP tick = self.minorTicks[i] DCNL DCSP  DCSP  DCSP if self._gridOnMinor: DCNL DCSP  DCSP  DCSP  DCSP tick.gridOn = True DCNL DCSP  DCSP  DCSP self._copy_tick_props(protoTick, tick) DCNL DCSP self._lastNumMinorTicks = numticks DCNL DCSP ticks = self.minorTicks[:numticks] DCNL DCSP return ticks
def grid(self, b=None, which='major', **kwargs): DCNL DCSP if len(kwargs): DCNL DCSP  DCSP b = True DCNL DCSP if (which.lower().find('minor') >= 0): DCNL DCSP  DCSP if (b is None): DCNL DCSP  DCSP  DCSP self._gridOnMinor = (not self._gridOnMinor) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._gridOnMinor = b DCNL DCSP  DCSP for tick in self.minorTicks: DCNL DCSP  DCSP  DCSP if (tick is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP tick.gridOn = self._gridOnMinor DCNL DCSP  DCSP  DCSP if len(kwargs): DCNL DCSP  DCSP  DCSP  DCSP artist.setp(tick.gridline, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP if (b is None): DCNL DCSP  DCSP  DCSP self._gridOnMajor = (not self._gridOnMajor) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._gridOnMajor = b DCNL DCSP  DCSP for tick in self.majorTicks: DCNL DCSP  DCSP  DCSP if (tick is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP tick.gridOn = self._gridOnMajor DCNL DCSP  DCSP  DCSP if len(kwargs): DCNL DCSP  DCSP  DCSP  DCSP artist.setp(tick.gridline, **kwargs)
def update_units(self, data): DCNL DCSP converter = munits.registry.get_converter(data) DCNL DCSP if (converter is None): DCNL DCSP  DCSP return False DCNL DCSP self.converter = converter DCNL DCSP default = self.converter.default_units(data) DCNL DCSP if ((default is not None) and (self.units is None)): DCNL DCSP  DCSP self.set_units(default) DCNL DCSP self._update_axisinfo() DCNL DCSP return True
def _update_axisinfo(self): DCNL DCSP if (self.converter is None): DCNL DCSP  DCSP return DCNL DCSP info = self.converter.axisinfo(self.units) DCNL DCSP if (info is None): DCNL DCSP  DCSP return DCNL DCSP if ((info.majloc is not None) and (self.major.locator != info.majloc)): DCNL DCSP  DCSP self.set_major_locator(info.majloc) DCNL DCSP if ((info.minloc is not None) and (self.minor.locator != info.minloc)): DCNL DCSP  DCSP self.set_minor_locator(info.minloc) DCNL DCSP if ((info.majfmt is not None) and (self.major.formatter != info.majfmt)): DCNL DCSP  DCSP self.set_major_formatter(info.majfmt) DCNL DCSP if ((info.minfmt is not None) and (self.minor.formatter != info.minfmt)): DCNL DCSP  DCSP self.set_minor_formatter(info.minfmt) DCNL DCSP if (info.label is not None): DCNL DCSP  DCSP label = self.get_label() DCNL DCSP  DCSP label.set_text(info.label)
def set_units(self, u): DCNL DCSP pchanged = False DCNL DCSP if (u is None): DCNL DCSP  DCSP self.units = None DCNL DCSP  DCSP pchanged = True DCNL DCSP elif (u != self.units): DCNL DCSP  DCSP self.units = u DCNL DCSP  DCSP pchanged = True DCNL DCSP if pchanged: DCNL DCSP  DCSP self._update_axisinfo() DCNL DCSP  DCSP self.callbacks.process('units') DCNL DCSP  DCSP self.callbacks.process('units DCSP finalize')
def get_units(self): DCNL DCSP return self.units
def set_major_formatter(self, formatter): DCNL DCSP self.major.formatter = formatter DCNL DCSP formatter.set_axis(self)
def set_minor_formatter(self, formatter): DCNL DCSP self.minor.formatter = formatter DCNL DCSP formatter.set_axis(self)
def set_major_locator(self, locator): DCNL DCSP self.major.locator = locator DCNL DCSP locator.set_axis(self)
def set_minor_locator(self, locator): DCNL DCSP self.minor.locator = locator DCNL DCSP locator.set_axis(self)
def set_pickradius(self, pickradius): DCNL DCSP self.pickradius = pickradius
def set_ticklabels(self, ticklabels, *args, **kwargs): DCNL DCSP minor = kwargs.pop('minor', False) DCNL DCSP if minor: DCNL DCSP  DCSP self.set_minor_formatter(mticker.FixedFormatter(ticklabels)) DCNL DCSP  DCSP ticks = self.get_minor_ticks() DCNL DCSP else: DCNL DCSP  DCSP self.set_major_formatter(mticker.FixedFormatter(ticklabels)) DCNL DCSP  DCSP ticks = self.get_major_ticks() DCNL DCSP self.set_major_formatter(mticker.FixedFormatter(ticklabels)) DCNL DCSP ret = [] DCNL DCSP for (i, tick) in enumerate(ticks): DCNL DCSP  DCSP if (i < len(ticklabels)): DCNL DCSP  DCSP  DCSP tick.label1.set_text(ticklabels[i]) DCNL DCSP  DCSP  DCSP ret.append(tick.label1) DCNL DCSP  DCSP tick.label1.update(kwargs) DCNL DCSP return ret
def set_ticks(self, ticks, minor=False): DCNL DCSP ticks = self.convert_units(ticks) DCNL DCSP if (len(ticks) > 1): DCNL DCSP  DCSP (xleft, xright) = self.get_view_interval() DCNL DCSP  DCSP if (xright > xleft): DCNL DCSP  DCSP  DCSP self.set_view_interval(min(ticks), max(ticks)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.set_view_interval(max(ticks), min(ticks)) DCNL DCSP if minor: DCNL DCSP  DCSP self.set_minor_locator(mticker.FixedLocator(ticks)) DCNL DCSP  DCSP return self.get_minor_ticks(len(ticks)) DCNL DCSP else: DCNL DCSP  DCSP self.set_major_locator(mticker.FixedLocator(ticks)) DCNL DCSP  DCSP return self.get_major_ticks(len(ticks))
def _update_label_position(self, bboxes, bboxes2): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def _update_offset_text_postion(self, bboxes, bboxes2): DCNL DCSP raise NotImplementedError('Derived DCSP must DCSP override')
def pan(self, numsteps): DCNL DCSP self.major.locator.pan(numsteps)
def zoom(self, direction): DCNL DCSP self.major.locator.zoom(direction)
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP (x, y) = (mouseevent.x, mouseevent.y) DCNL DCSP try: DCNL DCSP  DCSP trans = self.axes.transAxes.inverted() DCNL DCSP  DCSP (xaxes, yaxes) = trans.transform_point((x, y)) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (False, {}) DCNL DCSP (l, b) = self.axes.transAxes.transform_point((0, 0)) DCNL DCSP (r, t) = self.axes.transAxes.transform_point((1, 1)) DCNL DCSP inaxis = ((xaxes >= 0) and (xaxes <= 1) and (((y < b) and (y > (b - self.pickradius))) or ((y > t) and (y < (t + self.pickradius))))) DCNL DCSP return (inaxis, {})
def get_label_position(self): DCNL DCSP return self.label_position
def set_label_position(self, position): DCNL DCSP assert ((position == 'top') or (position == 'bottom')) DCNL DCSP if (position == 'top'): DCNL DCSP  DCSP self.label.set_verticalalignment('bottom') DCNL DCSP else: DCNL DCSP  DCSP self.label.set_verticalalignment('top') DCNL DCSP self.label_position = position
def _update_label_position(self, bboxes, bboxes2): DCNL DCSP if (not self._autolabelpos): DCNL DCSP  DCSP return DCNL DCSP (x, y) = self.label.get_position() DCNL DCSP if (self.label_position == 'bottom'): DCNL DCSP  DCSP if (not len(bboxes)): DCNL DCSP  DCSP  DCSP bottom = self.axes.bbox.ymin DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bbox = mtransforms.Bbox.union(bboxes) DCNL DCSP  DCSP  DCSP bottom = bbox.y0 DCNL DCSP  DCSP self.label.set_position((x, (bottom - ((self.LABELPAD * self.figure.dpi) / 72.0)))) DCNL DCSP else: DCNL DCSP  DCSP if (not len(bboxes2)): DCNL DCSP  DCSP  DCSP top = self.axes.bbox.ymax DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bbox = mtransforms.Bbox.union(bboxes2) DCNL DCSP  DCSP  DCSP top = bbox.y1 DCNL DCSP  DCSP self.label.set_position((x, (top + ((self.LABELPAD * self.figure.dpi) / 72.0))))
def _update_offset_text_position(self, bboxes, bboxes2): DCNL DCSP (x, y) = self.offsetText.get_position() DCNL DCSP if (not len(bboxes)): DCNL DCSP  DCSP bottom = self.axes.bbox.ymin DCNL DCSP else: DCNL DCSP  DCSP bbox = mtransforms.Bbox.union(bboxes) DCNL DCSP  DCSP bottom = bbox.y0 DCNL DCSP self.offsetText.set_position((x, (bottom - ((self.OFFSETTEXTPAD * self.figure.dpi) / 72.0))))
def get_text_heights(self, renderer): DCNL DCSP (bbox, bbox2) = self.get_ticklabel_extents(renderer) DCNL DCSP padPixels = self.majorTicks[0].get_pad_pixels() DCNL DCSP above = 0.0 DCNL DCSP if bbox2.height: DCNL DCSP  DCSP above += (bbox2.height + padPixels) DCNL DCSP below = 0.0 DCNL DCSP if bbox.height: DCNL DCSP  DCSP below += (bbox.height + padPixels) DCNL DCSP if (self.get_label_position() == 'top'): DCNL DCSP  DCSP above += (self.label.get_window_extent(renderer).height + padPixels) DCNL DCSP else: DCNL DCSP  DCSP below += (self.label.get_window_extent(renderer).height + padPixels) DCNL DCSP return (above, below)
def set_ticks_position(self, position): DCNL DCSP assert (position in ('top', 'bottom', 'both', 'default', 'none')) DCNL DCSP ticks = list(self.get_major_ticks()) DCNL DCSP ticks.extend(self.get_minor_ticks()) DCNL DCSP if (position == 'top'): DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = False DCNL DCSP  DCSP  DCSP t.tick2On = True DCNL DCSP  DCSP  DCSP t.label1On = False DCNL DCSP  DCSP  DCSP t.label2On = True DCNL DCSP elif (position == 'bottom'): DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = True DCNL DCSP  DCSP  DCSP t.tick2On = False DCNL DCSP  DCSP  DCSP t.label1On = True DCNL DCSP  DCSP  DCSP t.label2On = False DCNL DCSP elif (position == 'default'): DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = True DCNL DCSP  DCSP  DCSP t.tick2On = True DCNL DCSP  DCSP  DCSP t.label1On = True DCNL DCSP  DCSP  DCSP t.label2On = False DCNL DCSP elif (position == 'none'): DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = False DCNL DCSP  DCSP  DCSP t.tick2On = False DCNL DCSP else: DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = True DCNL DCSP  DCSP  DCSP t.tick2On = True DCNL DCSP for t in ticks: DCNL DCSP  DCSP t.update_position(t._loc)
def tick_top(self): DCNL DCSP self.set_ticks_position('top')
def tick_bottom(self): DCNL DCSP self.set_ticks_position('bottom')
def get_ticks_position(self): DCNL DCSP majt = self.majorTicks[0] DCNL DCSP mT = self.minorTicks[0] DCNL DCSP majorTop = ((not majt.tick1On) and majt.tick2On and (not majt.label1On) and majt.label2On) DCNL DCSP minorTop = ((not mT.tick1On) and mT.tick2On and (not mT.label1On) and mT.label2On) DCNL DCSP if (majorTop and minorTop): DCNL DCSP  DCSP return 'top' DCNL DCSP MajorBottom = (majt.tick1On and (not majt.tick2On) and majt.label1On and (not majt.label2On)) DCNL DCSP MinorBottom = (mT.tick1On and (not mT.tick2On) and mT.label1On and (not mT.label2On)) DCNL DCSP if (MajorBottom and MinorBottom): DCNL DCSP  DCSP return 'bottom' DCNL DCSP majorDefault = (majt.tick1On and majt.tick2On and majt.label1On and (not majt.label2On)) DCNL DCSP minorDefault = (mT.tick1On and mT.tick2On and mT.label1On and (not mT.label2On)) DCNL DCSP if (majorDefault and minorDefault): DCNL DCSP  DCSP return 'default' DCNL DCSP return 'unknown'
def get_view_interval(self): DCNL DCSP return self.axes.viewLim.intervalx
def get_data_interval(self): DCNL DCSP return self.axes.dataLim.intervalx
def set_data_interval(self, vmin, vmax, ignore=False): DCNL DCSP if ignore: DCNL DCSP  DCSP self.axes.dataLim.intervalx = (vmin, vmax) DCNL DCSP else: DCNL DCSP  DCSP (Vmin, Vmax) = self.get_data_interval() DCNL DCSP  DCSP self.axes.dataLim.intervalx = (min(vmin, Vmin), max(vmax, Vmax))
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP (x, y) = (mouseevent.x, mouseevent.y) DCNL DCSP try: DCNL DCSP  DCSP trans = self.axes.transAxes.inverted() DCNL DCSP  DCSP (xaxes, yaxes) = trans.transform_point((x, y)) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (False, {}) DCNL DCSP (l, b) = self.axes.transAxes.transform_point((0, 0)) DCNL DCSP (r, t) = self.axes.transAxes.transform_point((1, 1)) DCNL DCSP inaxis = ((yaxes >= 0) and (yaxes <= 1) and (((x < l) and (x > (l - self.pickradius))) or ((x > r) and (x < (r + self.pickradius))))) DCNL DCSP return (inaxis, {})
def get_label_position(self): DCNL DCSP return self.label_position
def set_label_position(self, position): DCNL DCSP assert ((position == 'left') or (position == 'right')) DCNL DCSP if (position == 'right'): DCNL DCSP  DCSP self.label.set_horizontalalignment('left') DCNL DCSP else: DCNL DCSP  DCSP self.label.set_horizontalalignment('right') DCNL DCSP self.label_position = position
def _update_label_position(self, bboxes, bboxes2): DCNL DCSP if (not self._autolabelpos): DCNL DCSP  DCSP return DCNL DCSP (x, y) = self.label.get_position() DCNL DCSP if (self.label_position == 'left'): DCNL DCSP  DCSP if (not len(bboxes)): DCNL DCSP  DCSP  DCSP left = self.axes.bbox.xmin DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bbox = mtransforms.Bbox.union(bboxes) DCNL DCSP  DCSP  DCSP left = bbox.x0 DCNL DCSP  DCSP self.label.set_position(((left - ((self.LABELPAD * self.figure.dpi) / 72.0)), y)) DCNL DCSP else: DCNL DCSP  DCSP if (not len(bboxes2)): DCNL DCSP  DCSP  DCSP right = self.axes.bbox.xmax DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bbox = mtransforms.Bbox.union(bboxes2) DCNL DCSP  DCSP  DCSP right = bbox.x1 DCNL DCSP  DCSP self.label.set_position(((right + ((self.LABELPAD * self.figure.dpi) / 72.0)), y))
def _update_offset_text_position(self, bboxes, bboxes2): DCNL DCSP (x, y) = self.offsetText.get_position() DCNL DCSP top = self.axes.bbox.ymax DCNL DCSP self.offsetText.set_position((x, (top + ((self.OFFSETTEXTPAD * self.figure.dpi) / 72.0))))
def set_ticks_position(self, position): DCNL DCSP assert (position in ('left', 'right', 'both', 'default', 'none')) DCNL DCSP ticks = list(self.get_major_ticks()) DCNL DCSP ticks.extend(self.get_minor_ticks()) DCNL DCSP if (position == 'right'): DCNL DCSP  DCSP self.set_offset_position('right') DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = False DCNL DCSP  DCSP  DCSP t.tick2On = True DCNL DCSP  DCSP  DCSP t.label1On = False DCNL DCSP  DCSP  DCSP t.label2On = True DCNL DCSP elif (position == 'left'): DCNL DCSP  DCSP self.set_offset_position('left') DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = True DCNL DCSP  DCSP  DCSP t.tick2On = False DCNL DCSP  DCSP  DCSP t.label1On = True DCNL DCSP  DCSP  DCSP t.label2On = False DCNL DCSP elif (position == 'default'): DCNL DCSP  DCSP self.set_offset_position('left') DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = True DCNL DCSP  DCSP  DCSP t.tick2On = True DCNL DCSP  DCSP  DCSP t.label1On = True DCNL DCSP  DCSP  DCSP t.label2On = False DCNL DCSP elif (position == 'none'): DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = False DCNL DCSP  DCSP  DCSP t.tick2On = False DCNL DCSP else: DCNL DCSP  DCSP self.set_offset_position('left') DCNL DCSP  DCSP for t in ticks: DCNL DCSP  DCSP  DCSP t.tick1On = True DCNL DCSP  DCSP  DCSP t.tick2On = True
def tick_right(self): DCNL DCSP self.set_ticks_position('right')
def tick_left(self): DCNL DCSP self.set_ticks_position('left')
def get_ticks_position(self): DCNL DCSP majt = self.majorTicks[0] DCNL DCSP mT = self.minorTicks[0] DCNL DCSP majorRight = ((not majt.tick1On) and majt.tick2On and (not majt.label1On) and majt.label2On) DCNL DCSP minorRight = ((not mT.tick1On) and mT.tick2On and (not mT.label1On) and mT.label2On) DCNL DCSP if (majorRight and minorRight): DCNL DCSP  DCSP return 'right' DCNL DCSP majorLeft = (majt.tick1On and (not majt.tick2On) and majt.label1On and (not majt.label2On)) DCNL DCSP minorLeft = (mT.tick1On and (not mT.tick2On) and mT.label1On and (not mT.label2On)) DCNL DCSP if (majorLeft and minorLeft): DCNL DCSP  DCSP return 'left' DCNL DCSP majorDefault = (majt.tick1On and majt.tick2On and majt.label1On and (not majt.label2On)) DCNL DCSP minorDefault = (mT.tick1On and mT.tick2On and mT.label1On and (not mT.label2On)) DCNL DCSP if (majorDefault and minorDefault): DCNL DCSP  DCSP return 'default' DCNL DCSP return 'unknown'
def get_view_interval(self): DCNL DCSP return self.axes.viewLim.intervaly
def get_data_interval(self): DCNL DCSP return self.axes.dataLim.intervaly
def set_data_interval(self, vmin, vmax, ignore=False): DCNL DCSP if ignore: DCNL DCSP  DCSP self.axes.dataLim.intervaly = (vmin, vmax) DCNL DCSP else: DCNL DCSP  DCSP (Vmin, Vmax) = self.get_data_interval() DCNL DCSP  DCSP self.axes.dataLim.intervaly = (min(vmin, Vmin), max(vmax, Vmax))
def __init__(self, xdata, ydata, linewidth=None, linestyle=None, color=None, marker=None, markersize=None, markeredgewidth=None, markeredgecolor=None, markerfacecolor=None, antialiased=None, dash_capstyle=None, solid_capstyle=None, dash_joinstyle=None, solid_joinstyle=None, pickradius=5, drawstyle=None, **kwargs): DCNL DCSP Artist.__init__(self) DCNL DCSP if (not iterable(xdata)): DCNL DCSP  DCSP raise RuntimeError('xdata DCSP must DCSP be DCSP a DCSP sequence') DCNL DCSP if (not iterable(ydata)): DCNL DCSP  DCSP raise RuntimeError('ydata DCSP must DCSP be DCSP a DCSP sequence') DCNL DCSP if (linewidth is None): DCNL DCSP  DCSP linewidth = rcParams['lines.linewidth'] DCNL DCSP if (linestyle is None): DCNL DCSP  DCSP linestyle = rcParams['lines.linestyle'] DCNL DCSP if (marker is None): DCNL DCSP  DCSP marker = rcParams['lines.marker'] DCNL DCSP if (color is None): DCNL DCSP  DCSP color = rcParams['lines.color'] DCNL DCSP if (markersize is None): DCNL DCSP  DCSP markersize = rcParams['lines.markersize'] DCNL DCSP if (antialiased is None): DCNL DCSP  DCSP antialiased = rcParams['lines.antialiased'] DCNL DCSP if (dash_capstyle is None): DCNL DCSP  DCSP dash_capstyle = rcParams['lines.dash_capstyle'] DCNL DCSP if (dash_joinstyle is None): DCNL DCSP  DCSP dash_joinstyle = rcParams['lines.dash_joinstyle'] DCNL DCSP if (solid_capstyle is None): DCNL DCSP  DCSP solid_capstyle = rcParams['lines.solid_capstyle'] DCNL DCSP if (solid_joinstyle is None): DCNL DCSP  DCSP solid_joinstyle = rcParams['lines.solid_joinstyle'] DCNL DCSP if (drawstyle is None): DCNL DCSP  DCSP drawstyle = 'default' DCNL DCSP self.set_dash_capstyle(dash_capstyle) DCNL DCSP self.set_dash_joinstyle(dash_joinstyle) DCNL DCSP self.set_solid_capstyle(solid_capstyle) DCNL DCSP self.set_solid_joinstyle(solid_joinstyle) DCNL DCSP self.set_linestyle(linestyle) DCNL DCSP self.set_drawstyle(drawstyle) DCNL DCSP self.set_linewidth(linewidth) DCNL DCSP self.set_color(color) DCNL DCSP self.set_marker(marker) DCNL DCSP self.set_antialiased(antialiased) DCNL DCSP self.set_markersize(markersize) DCNL DCSP self._dashSeq = None DCNL DCSP self.set_markerfacecolor(markerfacecolor) DCNL DCSP self.set_markeredgecolor(markeredgecolor) DCNL DCSP self.set_markeredgewidth(markeredgewidth) DCNL DCSP self._point_size_reduction = 0.5 DCNL DCSP self.verticalOffset = None DCNL DCSP self.update(kwargs) DCNL DCSP self.pickradius = pickradius DCNL DCSP if is_numlike(self._picker): DCNL DCSP  DCSP self.pickradius = self._picker DCNL DCSP self._xorig = np.asarray([]) DCNL DCSP self._yorig = np.asarray([]) DCNL DCSP self._invalid = True DCNL DCSP self.set_data(xdata, ydata)
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP if (not is_numlike(self.pickradius)): DCNL DCSP  DCSP raise ValueError, 'pick DCSP radius DCSP should DCSP be DCSP a DCSP distance' DCNL DCSP if self._invalid: DCNL DCSP  DCSP self.recache() DCNL DCSP if (len(self._xy) == 0): DCNL DCSP  DCSP return (False, {}) DCNL DCSP (path, affine) = self._transformed_path.get_transformed_path_and_affine() DCNL DCSP path = affine.transform_path(path) DCNL DCSP xy = path.vertices DCNL DCSP xt = xy[:, 0] DCNL DCSP yt = xy[:, 1] DCNL DCSP if (self.figure == None): DCNL DCSP  DCSP warning.warn('no DCSP figure DCSP set DCSP when DCSP check DCSP if DCSP mouse DCSP is DCSP on DCSP line') DCNL DCSP  DCSP pixels = self.pickradius DCNL DCSP else: DCNL DCSP  DCSP pixels = ((self.figure.dpi / 72.0) * self.pickradius) DCNL DCSP if (self._linestyle in ['None', None]): DCNL DCSP  DCSP d = (((xt - mouseevent.x) ** 2) + ((yt - mouseevent.y) ** 2)) DCNL DCSP  DCSP (ind,) = np.nonzero(np.less_equal(d, (pixels ** 2))) DCNL DCSP else: DCNL DCSP  DCSP ind = segment_hits(mouseevent.x, mouseevent.y, xt, yt, pixels) DCNL DCSP if (False and (self._label != u'')): DCNL DCSP  DCSP print 'Checking DCSP line', self._label, 'at', mouseevent.x, mouseevent.y DCNL DCSP  DCSP print 'xt', xt DCNL DCSP  DCSP print 'yt', yt DCNL DCSP  DCSP print 'ind', ind DCNL DCSP return ((len(ind) > 0), dict(ind=ind))
def get_pickradius(self): DCNL DCSP return self.pickradius
def setpickradius(self, d): DCNL DCSP self.pickradius = d
def set_picker(self, p): DCNL DCSP if callable(p): DCNL DCSP  DCSP self._contains = p DCNL DCSP else: DCNL DCSP  DCSP self.pickradius = p DCNL DCSP self._picker = p
def set_data(self, *args): DCNL DCSP if (len(args) == 1): DCNL DCSP  DCSP (x, y) = args[0] DCNL DCSP else: DCNL DCSP  DCSP (x, y) = args DCNL DCSP not_masked = 0 DCNL DCSP if (not ma.isMaskedArray(x)): DCNL DCSP  DCSP x = np.asarray(x) DCNL DCSP  DCSP not_masked += 1 DCNL DCSP if (not ma.isMaskedArray(y)): DCNL DCSP  DCSP y = np.asarray(y) DCNL DCSP  DCSP not_masked += 1 DCNL DCSP if ((not_masked < 2) or ((x is not self._xorig) and ((x.shape != self._xorig.shape) or np.any((x != self._xorig)))) or ((y is not self._yorig) and ((y.shape != self._yorig.shape) or np.any((y != self._yorig))))): DCNL DCSP  DCSP self._xorig = x DCNL DCSP  DCSP self._yorig = y DCNL DCSP  DCSP self._invalid = True
def set_transform(self, t): DCNL DCSP Artist.set_transform(self, t) DCNL DCSP self._invalid = True
def _is_sorted(self, x): DCNL DCSP if (len(x) < 2): DCNL DCSP  DCSP return 1 DCNL DCSP return np.alltrue(((x[1:] - x[0:(-1)]) >= 0))
def get_data(self, orig=True): DCNL DCSP return (self.get_xdata(orig=orig), self.get_ydata(orig=orig))
def get_xdata(self, orig=True): DCNL DCSP if orig: DCNL DCSP  DCSP return self._xorig DCNL DCSP if self._invalid: DCNL DCSP  DCSP self.recache() DCNL DCSP return self._x
def get_ydata(self, orig=True): DCNL DCSP if orig: DCNL DCSP  DCSP return self._yorig DCNL DCSP if self._invalid: DCNL DCSP  DCSP self.recache() DCNL DCSP return self._y
def get_path(self): DCNL DCSP if self._invalid: DCNL DCSP  DCSP self.recache() DCNL DCSP return self._path
def get_xydata(self): DCNL DCSP if self._invalid: DCNL DCSP  DCSP self.recache() DCNL DCSP return self._xy
def set_antialiased(self, b): DCNL DCSP self._antialiased = b
def set_color(self, color): DCNL DCSP self._color = color
def set_drawstyle(self, drawstyle): DCNL DCSP self._drawstyle = drawstyle
def set_linewidth(self, w): DCNL DCSP self._linewidth = w
def set_linestyle(self, linestyle): DCNL DCSP for ds in flatten([k.keys() for k in (self._drawStyles_l, self._drawStyles_s)], is_string_like): DCNL DCSP  DCSP if linestyle.startswith(ds): DCNL DCSP  DCSP  DCSP self.set_drawstyle(ds) DCNL DCSP  DCSP  DCSP if (len(linestyle) > len(ds)): DCNL DCSP  DCSP  DCSP  DCSP linestyle = linestyle[len(ds):] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP linestyle = '-' DCNL DCSP if (linestyle not in self._lineStyles): DCNL DCSP  DCSP if (linestyle in ls_mapper): DCNL DCSP  DCSP  DCSP linestyle = ls_mapper[linestyle] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP verbose.report(('Unrecognized DCSP line DCSP style DCSP %s, DCSP %s' % (linestyle, type(linestyle)))) DCNL DCSP if (linestyle in [' DCSP ', '']): DCNL DCSP  DCSP linestyle = 'None' DCNL DCSP self._linestyle = linestyle
def set_marker(self, marker): DCNL DCSP if (marker not in self._markers): DCNL DCSP  DCSP verbose.report(('Unrecognized DCSP marker DCSP style DCSP %s, DCSP %s' % (marker, type(marker)))) DCNL DCSP if (marker in [' DCSP ', '']): DCNL DCSP  DCSP marker = 'None' DCNL DCSP self._marker = marker DCNL DCSP self._markerFunc = self._markers[marker]
def set_markeredgecolor(self, ec): DCNL DCSP if (ec is None): DCNL DCSP  DCSP ec = 'auto' DCNL DCSP self._markeredgecolor = ec
def set_markeredgewidth(self, ew): DCNL DCSP if (ew is None): DCNL DCSP  DCSP ew = rcParams['lines.markeredgewidth'] DCNL DCSP self._markeredgewidth = ew
def set_markerfacecolor(self, fc): DCNL DCSP if (fc is None): DCNL DCSP  DCSP fc = 'auto' DCNL DCSP self._markerfacecolor = fc
def set_markersize(self, sz): DCNL DCSP self._markersize = sz
def set_xdata(self, x): DCNL DCSP x = np.asarray(x) DCNL DCSP self.set_data(x, self._yorig)
def set_ydata(self, y): DCNL DCSP y = np.asarray(y) DCNL DCSP self.set_data(self._xorig, y)
def set_dashes(self, seq): DCNL DCSP if ((seq == (None, None)) or (len(seq) == 0)): DCNL DCSP  DCSP self.set_linestyle('-') DCNL DCSP else: DCNL DCSP  DCSP self.set_linestyle('--') DCNL DCSP self._dashSeq = seq
def update_from(self, other): DCNL DCSP Artist.update_from(self, other) DCNL DCSP self._linestyle = other._linestyle DCNL DCSP self._linewidth = other._linewidth DCNL DCSP self._color = other._color DCNL DCSP self._markersize = other._markersize DCNL DCSP self._markerfacecolor = other._markerfacecolor DCNL DCSP self._markeredgecolor = other._markeredgecolor DCNL DCSP self._markeredgewidth = other._markeredgewidth DCNL DCSP self._dashSeq = other._dashSeq DCNL DCSP self._dashcapstyle = other._dashcapstyle DCNL DCSP self._dashjoinstyle = other._dashjoinstyle DCNL DCSP self._solidcapstyle = other._solidcapstyle DCNL DCSP self._solidjoinstyle = other._solidjoinstyle DCNL DCSP self._linestyle = other._linestyle DCNL DCSP self._marker = other._marker DCNL DCSP self._drawstyle = other._drawstyle
def set_aa(self, val): DCNL DCSP self.set_antialiased(val)
def set_c(self, val): DCNL DCSP self.set_color(val)
def set_ls(self, val): DCNL DCSP self.set_linestyle(val)
def set_lw(self, val): DCNL DCSP self.set_linewidth(val)
def set_mec(self, val): DCNL DCSP self.set_markeredgecolor(val)
def set_mew(self, val): DCNL DCSP self.set_markeredgewidth(val)
def set_mfc(self, val): DCNL DCSP self.set_markerfacecolor(val)
def set_ms(self, val): DCNL DCSP self.set_markersize(val)
def get_aa(self): DCNL DCSP return self.get_antialiased()
def get_c(self): DCNL DCSP return self.get_color()
def get_ls(self): DCNL DCSP return self.get_linestyle()
def get_lw(self): DCNL DCSP return self.get_linewidth()
def get_mec(self): DCNL DCSP return self.get_markeredgecolor()
def get_mew(self): DCNL DCSP return self.get_markeredgewidth()
def get_mfc(self): DCNL DCSP return self.get_markerfacecolor()
def get_ms(self): DCNL DCSP return self.get_markersize()
def set_dash_joinstyle(self, s): DCNL DCSP s = s.lower() DCNL DCSP if (s not in self.validJoin): DCNL DCSP  DCSP raise ValueError((('set_dash_joinstyle DCSP passed DCSP "%s";\n' % (s,)) + ('valid DCSP joinstyles DCSP are DCSP %s' % (self.validJoin,)))) DCNL DCSP self._dashjoinstyle = s
def set_solid_joinstyle(self, s): DCNL DCSP s = s.lower() DCNL DCSP if (s not in self.validJoin): DCNL DCSP  DCSP raise ValueError((('set_solid_joinstyle DCSP passed DCSP "%s";\n' % (s,)) + ('valid DCSP joinstyles DCSP are DCSP %s' % (self.validJoin,)))) DCNL DCSP self._solidjoinstyle = s
def get_dash_joinstyle(self): DCNL DCSP return self._dashjoinstyle
def get_solid_joinstyle(self): DCNL DCSP return self._solidjoinstyle
def set_dash_capstyle(self, s): DCNL DCSP s = s.lower() DCNL DCSP if (s not in self.validCap): DCNL DCSP  DCSP raise ValueError((('set_dash_capstyle DCSP passed DCSP "%s";\n' % (s,)) + ('valid DCSP capstyles DCSP are DCSP %s' % (self.validCap,)))) DCNL DCSP self._dashcapstyle = s
def set_solid_capstyle(self, s): DCNL DCSP s = s.lower() DCNL DCSP if (s not in self.validCap): DCNL DCSP  DCSP raise ValueError((('set_solid_capstyle DCSP passed DCSP "%s";\n' % (s,)) + ('valid DCSP capstyles DCSP are DCSP %s' % (self.validCap,)))) DCNL DCSP self._solidcapstyle = s
def get_dash_capstyle(self): DCNL DCSP return self._dashcapstyle
def get_solid_capstyle(self): DCNL DCSP return self._solidcapstyle
def is_dashed(self): DCNL DCSP return (self._linestyle in ('--', '-.', ':'))
def __init__(self, line): DCNL DCSP if (not hasattr(line, 'axes')): DCNL DCSP  DCSP raise RuntimeError('You DCSP must DCSP first DCSP add DCSP the DCSP line DCSP to DCSP the DCSP Axes') DCNL DCSP if (line.get_picker() is None): DCNL DCSP  DCSP raise RuntimeError('You DCSP must DCSP first DCSP set DCSP the DCSP picker DCSP property DCSP of DCSP the DCSP line') DCNL DCSP self.axes = line.axes DCNL DCSP self.line = line DCNL DCSP self.canvas = self.axes.figure.canvas DCNL DCSP self.cid = self.canvas.mpl_connect('pick_event', self.onpick) DCNL DCSP self.ind = set()
def process_selected(self, ind, xs, ys): DCNL DCSP pass
def onpick(self, event): DCNL DCSP if (event.artist is not self.line): DCNL DCSP  DCSP return DCNL DCSP for i in event.ind: DCNL DCSP  DCSP if (i in self.ind): DCNL DCSP  DCSP  DCSP self.ind.remove(i) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.ind.add(i) DCNL DCSP ind = list(self.ind) DCNL DCSP ind.sort() DCNL DCSP (xdata, ydata) = self.line.get_data() DCNL DCSP self.process_selected(ind, xdata[ind], ydata[ind])
def __init__(self): DCNL DCSP self._parents = WeakKeyDictionary() DCNL DCSP self._invalid = 1
def invalidate(self): DCNL DCSP value = ((self.is_affine and self.INVALID_AFFINE) or self.INVALID) DCNL DCSP if (self._invalid == value): DCNL DCSP  DCSP return DCNL DCSP if (not len(self._parents)): DCNL DCSP  DCSP self._invalid = value DCNL DCSP  DCSP return DCNL DCSP stack = [self] DCNL DCSP while len(stack): DCNL DCSP  DCSP root = stack.pop() DCNL DCSP  DCSP if ((root._invalid != value) or root.pass_through): DCNL DCSP  DCSP  DCSP root._invalid = self.INVALID DCNL DCSP  DCSP  DCSP stack.extend(root._parents.keys())
def set_children(self, *children): DCNL DCSP for child in children: DCNL DCSP  DCSP child._parents[self] = None
def frozen(self): DCNL DCSP return self
def is_unit(self): DCNL DCSP return (list(self.get_points().flatten()) == [0.0, 0.0, 1.0, 1.0])
def containsx(self, x): DCNL DCSP (x0, x1) = self.intervalx DCNL DCSP return (((x0 < x1) and ((x >= x0) and (x <= x1))) or ((x >= x1) and (x <= x0)))
def containsy(self, y): DCNL DCSP (y0, y1) = self.intervaly DCNL DCSP return (((y0 < y1) and ((y >= y0) and (y <= y1))) or ((y >= y1) and (y <= y0)))
def contains(self, x, y): DCNL DCSP return (self.containsx(x) and self.containsy(y))
def overlaps(self, other): DCNL DCSP (ax1, ay1, ax2, ay2) = self._get_extents() DCNL DCSP (bx1, by1, bx2, by2) = other._get_extents() DCNL DCSP if (ax2 < ax1): DCNL DCSP  DCSP (ax2, ax1) = (ax1, ax2) DCNL DCSP if (ay2 < ay1): DCNL DCSP  DCSP (ay2, ay1) = (ay1, ay2) DCNL DCSP if (bx2 < bx1): DCNL DCSP  DCSP (bx2, bx1) = (bx1, bx2) DCNL DCSP if (by2 < by1): DCNL DCSP  DCSP (by2, by1) = (by1, by2) DCNL DCSP return (not ((bx2 < ax1) or (by2 < ay1) or (bx1 > ax2) or (by1 > ay2)))
def fully_containsx(self, x): DCNL DCSP (x0, x1) = self.intervalx DCNL DCSP return (((x0 < x1) and ((x > x0) and (x < x1))) or ((x > x1) and (x < x0)))
def fully_containsy(self, y): DCNL DCSP (y0, y1) = self.intervaly DCNL DCSP return (((y0 < y1) and ((x > y0) and (x < y1))) or ((x > y1) and (x < y0)))
def fully_contains(self, x, y): DCNL DCSP return (self.fully_containsx(x) and self.fully_containsy(y))
def fully_overlaps(self, other): DCNL DCSP (ax1, ay1, ax2, ay2) = self._get_extents() DCNL DCSP (bx1, by1, bx2, by2) = other._get_extents() DCNL DCSP if (ax2 < ax1): DCNL DCSP  DCSP (ax2, ax1) = (ax1, ax2) DCNL DCSP if (ay2 < ay1): DCNL DCSP  DCSP (ay2, ay1) = (ay1, ay2) DCNL DCSP if (bx2 < bx1): DCNL DCSP  DCSP (bx2, bx1) = (bx1, bx2) DCNL DCSP if (by2 < by1): DCNL DCSP  DCSP (by2, by1) = (by1, by2) DCNL DCSP return (not ((bx2 <= ax1) or (by2 <= ay1) or (bx1 >= ax2) or (by1 >= ay2)))
def transformed(self, transform): DCNL DCSP return Bbox(transform.transform(self.get_points()))
def inverse_transformed(self, transform): DCNL DCSP return Bbox(transform.inverted().transform(self.get_points()))
def anchored(self, c, container=None): DCNL DCSP if (container is None): DCNL DCSP  DCSP container = self DCNL DCSP (l, b, w, h) = container.bounds DCNL DCSP if isinstance(c, str): DCNL DCSP  DCSP (cx, cy) = self.coefs[c] DCNL DCSP else: DCNL DCSP  DCSP (cx, cy) = c DCNL DCSP (L, B, W, H) = self.bounds DCNL DCSP return Bbox((self._points + [((l + (cx * (w - W))) - L), ((b + (cy * (h - H))) - B)]))
def shrunk(self, mx, my): DCNL DCSP (w, h) = self.size DCNL DCSP return Bbox([self._points[0], (self._points[0] + [(mx * w), (my * h)])])
def shrunk_to_aspect(self, box_aspect, container=None, fig_aspect=1.0): DCNL DCSP assert ((box_aspect > 0) and (fig_aspect > 0)) DCNL DCSP if (container is None): DCNL DCSP  DCSP container = self DCNL DCSP (w, h) = container.size DCNL DCSP H = ((w * box_aspect) / fig_aspect) DCNL DCSP if (H <= h): DCNL DCSP  DCSP W = w DCNL DCSP else: DCNL DCSP  DCSP W = ((h * fig_aspect) / box_aspect) DCNL DCSP  DCSP H = h DCNL DCSP return Bbox([self._points[0], (self._points[0] + (W, H))])
def splitx(self, *args): DCNL DCSP boxes = [] DCNL DCSP xf = (([0] + list(args)) + [1]) DCNL DCSP (x0, y0, x1, y1) = self._get_extents() DCNL DCSP w = (x1 - x0) DCNL DCSP for (xf0, xf1) in zip(xf[:(-1)], xf[1:]): DCNL DCSP  DCSP boxes.append(Bbox([[(x0 + (xf0 * w)), y0], [(x0 + (xf1 * w)), y1]])) DCNL DCSP return boxes
def splity(self, *args): DCNL DCSP boxes = [] DCNL DCSP yf = (([0] + list(args)) + [1]) DCNL DCSP (x0, y0, x1, y1) = self._get_extents() DCNL DCSP h = (y1 - y0) DCNL DCSP for (yf0, yf1) in zip(yf[:(-1)], yf[1:]): DCNL DCSP  DCSP boxes.append(Bbox([[x0, (y0 + (yf0 * h))], [x1, (y0 + (yf1 * h))]])) DCNL DCSP return boxes
def count_contains(self, vertices): DCNL DCSP if (len(vertices) == 0): DCNL DCSP  DCSP return 0 DCNL DCSP vertices = np.asarray(vertices) DCNL DCSP (x0, y0, x1, y1) = self._get_extents() DCNL DCSP dx0 = np.sign((vertices[:, 0] - x0)) DCNL DCSP dy0 = np.sign((vertices[:, 1] - y0)) DCNL DCSP dx1 = np.sign((vertices[:, 0] - x1)) DCNL DCSP dy1 = np.sign((vertices[:, 1] - y1)) DCNL DCSP inside = ((abs((dx0 + dx1)) + abs((dy0 + dy1))) <= 2) DCNL DCSP return np.sum(inside)
def count_overlaps(self, bboxes): DCNL DCSP return count_bboxes_overlapping_bbox(self, bboxes)
def expanded(self, sw, sh): DCNL DCSP width = self.width DCNL DCSP height = self.height DCNL DCSP deltaw = (((sw * width) - width) / 2.0) DCNL DCSP deltah = (((sh * height) - height) / 2.0) DCNL DCSP a = np.array([[(- deltaw), (- deltah)], [deltaw, deltah]]) DCNL DCSP return Bbox((self._points + a))
def padded(self, p): DCNL DCSP points = self._points DCNL DCSP return Bbox((points + [[(- p), (- p)], [p, p]]))
def translated(self, tx, ty): DCNL DCSP return Bbox((self._points + (tx, ty)))
def corners(self): DCNL DCSP (l, b, r, t) = self.get_points().flatten() DCNL DCSP return np.array([[l, b], [l, t], [r, b], [r, t]])
def rotated(self, radians): DCNL DCSP corners = self.corners() DCNL DCSP corners_rotated = Affine2D().rotate(radians).transform(corners) DCNL DCSP bbox = Bbox.unit() DCNL DCSP bbox.update_from_data_xy(corners_rotated, ignore=True) DCNL DCSP return bbox
def union(bboxes): DCNL DCSP assert len(bboxes) DCNL DCSP if (len(bboxes) == 1): DCNL DCSP  DCSP return bboxes[0] DCNL DCSP x0 = np.inf DCNL DCSP y0 = np.inf DCNL DCSP x1 = (- np.inf) DCNL DCSP y1 = (- np.inf) DCNL DCSP for bbox in bboxes: DCNL DCSP  DCSP points = bbox.get_points() DCNL DCSP  DCSP xs = points[:, 0] DCNL DCSP  DCSP ys = points[:, 1] DCNL DCSP  DCSP x0 = min(x0, np.min(xs)) DCNL DCSP  DCSP y0 = min(y0, np.min(ys)) DCNL DCSP  DCSP x1 = max(x1, np.max(xs)) DCNL DCSP  DCSP y1 = max(y1, np.max(ys)) DCNL DCSP return Bbox.from_extents(x0, y0, x1, y1)
def __init__(self, points): DCNL DCSP BboxBase.__init__(self) DCNL DCSP self._points = np.asarray(points, np.float_) DCNL DCSP self._minpos = np.array([1e-07, 1e-07]) DCNL DCSP self._ignore = True
def unit(): DCNL DCSP return Bbox(Bbox._unit_values.copy())
def from_bounds(x0, y0, width, height): DCNL DCSP return Bbox.from_extents(x0, y0, (x0 + width), (y0 + height))
def from_extents(*args): DCNL DCSP points = np.array(args, dtype=np.float_).reshape(2, 2) DCNL DCSP return Bbox(points)
def ignore(self, value): DCNL DCSP self._ignore = value
def update_from_data(self, x, y, ignore=None): DCNL DCSP warnings.warn('update_from_data DCSP requires DCSP a DCSP memory DCSP copy DCSP -- DCSP please DCSP replace DCSP with DCSP update_from_data_xy') DCNL DCSP xy = np.hstack((x.reshape((len(x), 1)), y.reshape((len(y), 1)))) DCNL DCSP return self.update_from_data_xy(xy, ignore)
def update_from_path(self, path, ignore=None, updatex=True, updatey=True): DCNL DCSP if (ignore is None): DCNL DCSP  DCSP ignore = self._ignore DCNL DCSP if (path.vertices.size == 0): DCNL DCSP  DCSP return DCNL DCSP (points, minpos, changed) = update_path_extents(path, None, self._points, self._minpos, ignore) DCNL DCSP if changed: DCNL DCSP  DCSP self.invalidate() DCNL DCSP  DCSP if updatex: DCNL DCSP  DCSP  DCSP self._points[:, 0] = points[:, 0] DCNL DCSP  DCSP  DCSP self._minpos[0] = minpos[0] DCNL DCSP  DCSP if updatey: DCNL DCSP  DCSP  DCSP self._points[:, 1] = points[:, 1] DCNL DCSP  DCSP  DCSP self._minpos[1] = minpos[1]
def update_from_data_xy(self, xy, ignore=None, updatex=True, updatey=True): DCNL DCSP if (len(xy) == 0): DCNL DCSP  DCSP return DCNL DCSP path = Path(xy) DCNL DCSP self.update_from_path(path, ignore=ignore, updatex=updatex, updatey=updatey)
def get_points(self): DCNL DCSP self._invalid = 0 DCNL DCSP return self._points
def set_points(self, points): DCNL DCSP if np.any((self._points != points)): DCNL DCSP  DCSP self._points = points DCNL DCSP  DCSP self.invalidate()
def set(self, other): DCNL DCSP if np.any((self._points != other.get_points())): DCNL DCSP  DCSP self._points = other.get_points() DCNL DCSP  DCSP self.invalidate()
def __init__(self, bbox, transform): DCNL DCSP assert bbox.is_bbox DCNL DCSP assert isinstance(transform, Transform) DCNL DCSP assert (transform.input_dims == 2) DCNL DCSP assert (transform.output_dims == 2) DCNL DCSP BboxBase.__init__(self) DCNL DCSP self._bbox = bbox DCNL DCSP self._transform = transform DCNL DCSP self.set_children(bbox, transform) DCNL DCSP self._points = None
def __add__(self, other): DCNL DCSP if isinstance(other, Transform): DCNL DCSP  DCSP return composite_transform_factory(self, other) DCNL DCSP raise TypeError(("Can DCSP not DCSP add DCSP Transform DCSP to DCSP object DCSP of DCSP type DCSP '%s'" % type(other)))
def __radd__(self, other): DCNL DCSP if isinstance(other, Transform): DCNL DCSP  DCSP return composite_transform_factory(other, self) DCNL DCSP raise TypeError(("Can DCSP not DCSP add DCSP Transform DCSP to DCSP object DCSP of DCSP type DCSP '%s'" % type(other)))
def __array__(self, *args, **kwargs): DCNL DCSP return self.frozen().__array__()
def transform(self, values): DCNL DCSP raise NotImplementedError()
def transform_affine(self, values): DCNL DCSP return values
def transform_non_affine(self, values): DCNL DCSP return self.transform(values)
def get_affine(self): DCNL DCSP return IdentityTransform()
def transform_point(self, point): DCNL DCSP assert (len(point) == self.input_dims) DCNL DCSP return self.transform(np.asarray([point]))[0]
def transform_path(self, path): DCNL DCSP return Path(self.transform(path.vertices), path.codes)
def transform_path_affine(self, path): DCNL DCSP return path
def transform_path_non_affine(self, path): DCNL DCSP return Path(self.transform_non_affine(path.vertices), path.codes)
def transform_angles(self, angles, pts, radians=False, pushoff=1e-05): DCNL DCSP if ((self.input_dims != 2) or (self.output_dims != 2)): DCNL DCSP  DCSP raise NotImplementedError('Only DCSP defined DCSP in DCSP 2D') DCNL DCSP assert (pts.shape[1] == 2) DCNL DCSP assert (np.prod(angles.shape) == angles.shape[0] == pts.shape[0]) DCNL DCSP if (not radians): DCNL DCSP  DCSP angles = ((angles / 180.0) * np.pi) DCNL DCSP pts2 = (pts + (pushoff * np.c_[(np.cos(angles), np.sin(angles))])) DCNL DCSP tpts = self.transform(pts) DCNL DCSP tpts2 = self.transform(pts2) DCNL DCSP d = (tpts2 - tpts) DCNL DCSP a = np.arctan2(d[:, 1], d[:, 0]) DCNL DCSP if (not radians): DCNL DCSP  DCSP a = ((a * 180.0) / np.pi) DCNL DCSP return a
def inverted(self): DCNL DCSP raise NotImplementedError()
def __init__(self, child): DCNL DCSP assert isinstance(child, Transform) DCNL DCSP Transform.__init__(self) DCNL DCSP self.input_dims = child.input_dims DCNL DCSP self.output_dims = child.output_dims DCNL DCSP self._set(child) DCNL DCSP self._invalid = 0
def set(self, child): DCNL DCSP assert (child.input_dims == self.input_dims) DCNL DCSP assert (child.output_dims == self.output_dims) DCNL DCSP self._set(child) DCNL DCSP self._invalid = 0 DCNL DCSP self.invalidate() DCNL DCSP self._invalid = 0
def _concat(a, b): DCNL DCSP return np.dot(b, a)
def get_matrix(self): DCNL DCSP raise NotImplementedError()
def to_values(self): DCNL DCSP mtx = self.get_matrix() DCNL DCSP return tuple(mtx[:2].swapaxes(0, 1).flatten())
def matrix_from_values(a, b, c, d, e, f): DCNL DCSP return np.array([[a, c, e], [b, d, f], [0.0, 0.0, 1.0]], np.float_)
def __init__(self, matrix=None): DCNL DCSP Affine2DBase.__init__(self) DCNL DCSP if (matrix is None): DCNL DCSP  DCSP matrix = np.identity(3) DCNL DCSP elif DEBUG: DCNL DCSP  DCSP matrix = np.asarray(matrix, np.float_) DCNL DCSP  DCSP assert (matrix.shape == (3, 3)) DCNL DCSP self._mtx = matrix DCNL DCSP self._invalid = 0
def from_values(a, b, c, d, e, f): DCNL DCSP return Affine2D(np.array([a, c, e, b, d, f, 0.0, 0.0, 1.0], np.float_).reshape((3, 3)))
def get_matrix(self): DCNL DCSP self._invalid = 0 DCNL DCSP return self._mtx
def set_matrix(self, mtx): DCNL DCSP self._mtx = mtx DCNL DCSP self.invalidate()
def set(self, other): DCNL DCSP assert isinstance(other, Affine2DBase) DCNL DCSP self._mtx = other.get_matrix() DCNL DCSP self.invalidate()
def identity(): DCNL DCSP return Affine2D(np.identity(3))
def clear(self): DCNL DCSP self._mtx = np.identity(3) DCNL DCSP self.invalidate() DCNL DCSP return self
def rotate(self, theta): DCNL DCSP a = np.cos(theta) DCNL DCSP b = np.sin(theta) DCNL DCSP rotate_mtx = np.array([[a, (- b), 0.0], [b, a, 0.0], [0.0, 0.0, 1.0]], np.float_) DCNL DCSP self._mtx = np.dot(rotate_mtx, self._mtx) DCNL DCSP self.invalidate() DCNL DCSP return self
def rotate_deg(self, degrees): DCNL DCSP return self.rotate(((degrees * np.pi) / 180.0))
def rotate_around(self, x, y, theta): DCNL DCSP return self.translate((- x), (- y)).rotate(theta).translate(x, y)
def rotate_deg_around(self, x, y, degrees): DCNL DCSP return self.translate((- x), (- y)).rotate_deg(degrees).translate(x, y)
def translate(self, tx, ty): DCNL DCSP translate_mtx = np.array([[1.0, 0.0, tx], [0.0, 1.0, ty], [0.0, 0.0, 1.0]], np.float_) DCNL DCSP self._mtx = np.dot(translate_mtx, self._mtx) DCNL DCSP self.invalidate() DCNL DCSP return self
def scale(self, sx, sy=None): DCNL DCSP if (sy is None): DCNL DCSP  DCSP sy = sx DCNL DCSP scale_mtx = np.array([[sx, 0.0, 0.0], [0.0, sy, 0.0], [0.0, 0.0, 1.0]], np.float_) DCNL DCSP self._mtx = np.dot(scale_mtx, self._mtx) DCNL DCSP self.invalidate() DCNL DCSP return self
def __init__(self, x_transform, y_transform): DCNL DCSP Transform.__init__(self) DCNL DCSP self._x = x_transform DCNL DCSP self._y = y_transform DCNL DCSP self.set_children(x_transform, y_transform) DCNL DCSP self._affine = None
def __init__(self, x_transform, y_transform): DCNL DCSP assert x_transform.is_affine DCNL DCSP assert y_transform.is_affine DCNL DCSP assert x_transform.is_separable DCNL DCSP assert y_transform.is_separable DCNL DCSP Transform.__init__(self) DCNL DCSP self._x = x_transform DCNL DCSP self._y = y_transform DCNL DCSP self.set_children(x_transform, y_transform) DCNL DCSP Affine2DBase.__init__(self) DCNL DCSP self._mtx = None
def __init__(self, a, b): DCNL DCSP assert (a.output_dims == b.input_dims) DCNL DCSP self.input_dims = a.input_dims DCNL DCSP self.output_dims = b.output_dims DCNL DCSP Transform.__init__(self) DCNL DCSP self._a = a DCNL DCSP self._b = b DCNL DCSP self.set_children(a, b)
def __init__(self, a, b): DCNL DCSP assert (a.output_dims == b.input_dims) DCNL DCSP self.input_dims = a.input_dims DCNL DCSP self.output_dims = b.output_dims DCNL DCSP assert a.is_affine DCNL DCSP assert b.is_affine DCNL DCSP Affine2DBase.__init__(self) DCNL DCSP self._a = a DCNL DCSP self._b = b DCNL DCSP self.set_children(a, b) DCNL DCSP self._mtx = None
def __init__(self, boxin, boxout): DCNL DCSP assert boxin.is_bbox DCNL DCSP assert boxout.is_bbox DCNL DCSP Affine2DBase.__init__(self) DCNL DCSP self._boxin = boxin DCNL DCSP self._boxout = boxout DCNL DCSP self.set_children(boxin, boxout) DCNL DCSP self._mtx = None DCNL DCSP self._inverted = None
def __init__(self, boxout): DCNL DCSP assert boxout.is_bbox DCNL DCSP Affine2DBase.__init__(self) DCNL DCSP self._boxout = boxout DCNL DCSP self.set_children(boxout) DCNL DCSP self._mtx = None DCNL DCSP self._inverted = None
def __init__(self, path, transform): DCNL DCSP assert isinstance(transform, Transform) DCNL DCSP TransformNode.__init__(self) DCNL DCSP self._path = path DCNL DCSP self._transform = transform DCNL DCSP self.set_children(transform) DCNL DCSP self._transformed_path = None DCNL DCSP self._transformed_points = None
def get_transformed_points_and_affine(self): DCNL DCSP self._revalidate() DCNL DCSP return (self._transformed_points, self.get_affine())
def get_transformed_path_and_affine(self): DCNL DCSP self._revalidate() DCNL DCSP return (self._transformed_path, self.get_affine())
def get_fully_transformed_path(self): DCNL DCSP if (((self._invalid & self.INVALID_NON_AFFINE) == self.INVALID_NON_AFFINE) or (self._transformed_path is None)): DCNL DCSP  DCSP self._transformed_path = self._transform.transform_path_non_affine(self._path) DCNL DCSP self._invalid = 0 DCNL DCSP return self._transform.transform_path_affine(self._transformed_path)
def __init__(self, ax, cmap=None, norm=None, interpolation=None, origin=None, extent=None, filternorm=1, filterrad=4.0, resample=False, **kwargs): DCNL DCSP martist.Artist.__init__(self) DCNL DCSP cm.ScalarMappable.__init__(self, norm, cmap) DCNL DCSP if (origin is None): DCNL DCSP  DCSP origin = rcParams['image.origin'] DCNL DCSP self.origin = origin DCNL DCSP self._extent = extent DCNL DCSP self.set_filternorm(filternorm) DCNL DCSP self.set_filterrad(filterrad) DCNL DCSP self._filterrad = filterrad DCNL DCSP self.set_interpolation(interpolation) DCNL DCSP self.set_resample(resample) DCNL DCSP self.axes = ax DCNL DCSP self._imcache = None DCNL DCSP self.update(kwargs)
def get_size(self): DCNL DCSP if (self._A is None): DCNL DCSP  DCSP raise RuntimeError('You DCSP must DCSP first DCSP set DCSP the DCSP image DCSP array') DCNL DCSP return self._A.shape[:2]
def set_alpha(self, alpha): DCNL DCSP martist.Artist.set_alpha(self, alpha) DCNL DCSP self._imcache = None
def changed(self): DCNL DCSP self._imcache = None DCNL DCSP self._rgbacache = None DCNL DCSP cm.ScalarMappable.changed(self)
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP (x, y) = (mouseevent.xdata, mouseevent.ydata) DCNL DCSP (xmin, xmax, ymin, ymax) = self.get_extent() DCNL DCSP if (xmin > xmax): DCNL DCSP  DCSP (xmin, xmax) = (xmax, xmin) DCNL DCSP if (ymin > ymax): DCNL DCSP  DCSP (ymin, ymax) = (ymax, ymin) DCNL DCSP if ((x is not None) and (y is not None)): DCNL DCSP  DCSP inside = ((x >= xmin) and (x <= xmax) and (y >= ymin) and (y <= ymax)) DCNL DCSP else: DCNL DCSP  DCSP inside = False DCNL DCSP return (inside, {})
def write_png(self, fname, noscale=False): DCNL DCSP im = self.make_image() DCNL DCSP if noscale: DCNL DCSP  DCSP (numrows, numcols) = im.get_size() DCNL DCSP  DCSP im.reset_matrix() DCNL DCSP  DCSP im.set_interpolation(0) DCNL DCSP  DCSP im.resize(numcols, numrows) DCNL DCSP im.flipud_out() DCNL DCSP (rows, cols, buffer) = im.as_rgba_str() DCNL DCSP _png.write_png(buffer, cols, rows, fname)
def set_data(self, A, shape=None): DCNL DCSP if hasattr(A, 'getpixel'): DCNL DCSP  DCSP self._A = pil_to_array(A) DCNL DCSP elif ma.isMA(A): DCNL DCSP  DCSP self._A = A DCNL DCSP else: DCNL DCSP  DCSP self._A = np.asarray(A) DCNL DCSP if ((self._A.dtype != np.uint8) and (not np.can_cast(self._A.dtype, np.float))): DCNL DCSP  DCSP raise TypeError('Image DCSP data DCSP can DCSP not DCSP convert DCSP to DCSP float') DCNL DCSP if ((self._A.ndim not in (2, 3)) or ((self._A.ndim == 3) and (self._A.shape[(-1)] not in (3, 4)))): DCNL DCSP  DCSP raise TypeError('Invalid DCSP dimensions DCSP for DCSP image DCSP data') DCNL DCSP self._imcache = None DCNL DCSP self._rgbacache = None DCNL DCSP self._oldxslice = None DCNL DCSP self._oldyslice = None
def set_array(self, A): DCNL DCSP self.set_data(A)
def set_extent(self, extent): DCNL DCSP self._extent = extent DCNL DCSP (xmin, xmax, ymin, ymax) = extent DCNL DCSP corners = ((xmin, ymin), (xmax, ymax)) DCNL DCSP self.axes.update_datalim(corners) DCNL DCSP if self.axes._autoscaleon: DCNL DCSP  DCSP self.axes.set_xlim((xmin, xmax)) DCNL DCSP  DCSP self.axes.set_ylim((ymin, ymax))
def get_interpolation(self): DCNL DCSP return self._interpolation
def set_interpolation(self, s): DCNL DCSP if (s is None): DCNL DCSP  DCSP s = rcParams['image.interpolation'] DCNL DCSP s = s.lower() DCNL DCSP if (s not in self._interpd): DCNL DCSP  DCSP raise ValueError('Illegal DCSP interpolation DCSP string') DCNL DCSP self._interpolation = s
def get_extent(self): DCNL DCSP if (self._extent is not None): DCNL DCSP  DCSP return self._extent DCNL DCSP else: DCNL DCSP  DCSP sz = self.get_size() DCNL DCSP  DCSP (numrows, numcols) = sz DCNL DCSP  DCSP if (self.origin == 'upper'): DCNL DCSP  DCSP  DCSP return ((-0.5), (numcols - 0.5), (numrows - 0.5), (-0.5)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ((-0.5), (numcols - 0.5), (-0.5), (numrows - 0.5))
def set_filternorm(self, filternorm): DCNL DCSP if filternorm: DCNL DCSP  DCSP self._filternorm = 1 DCNL DCSP else: DCNL DCSP  DCSP self._filternorm = 0
def get_filternorm(self): DCNL DCSP return self._filternorm
def set_filterrad(self, filterrad): DCNL DCSP r = float(filterrad) DCNL DCSP assert (r > 0) DCNL DCSP self._filterrad = r
def get_filterrad(self): DCNL DCSP return self._filterrad
def __init__(self, ax, x=None, y=None, A=None, cmap=None, norm=None, **kwargs): DCNL DCSP martist.Artist.__init__(self) DCNL DCSP cm.ScalarMappable.__init__(self, norm, cmap) DCNL DCSP self.axes = ax DCNL DCSP self._rgbacache = None DCNL DCSP self.update(kwargs) DCNL DCSP self.set_data(x, y, A)
def set_alpha(self, alpha): DCNL DCSP martist.Artist.set_alpha(self, alpha) DCNL DCSP self.update_dict['array'] = True
def __init__(self, fig, cmap=None, norm=None, offsetx=0, offsety=0, origin=None, **kwargs): DCNL DCSP martist.Artist.__init__(self) DCNL DCSP cm.ScalarMappable.__init__(self, norm, cmap) DCNL DCSP if (origin is None): DCNL DCSP  DCSP origin = rcParams['image.origin'] DCNL DCSP self.origin = origin DCNL DCSP self.figure = fig DCNL DCSP self.ox = offsetx DCNL DCSP self.oy = offsety DCNL DCSP self.update(kwargs) DCNL DCSP self.magnification = 1.0
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP (xmin, xmax, ymin, ymax) = self.get_extent() DCNL DCSP (xdata, ydata) = (mouseevent.x, mouseevent.y) DCNL DCSP if ((xdata is not None) and (ydata is not None)): DCNL DCSP  DCSP inside = ((xdata >= xmin) and (xdata <= xmax) and (ydata >= ymin) and (ydata <= ymax)) DCNL DCSP else: DCNL DCSP  DCSP inside = False DCNL DCSP return (inside, {})
def get_size(self): DCNL DCSP if (self._A is None): DCNL DCSP  DCSP raise RuntimeError('You DCSP must DCSP first DCSP set DCSP the DCSP image DCSP array') DCNL DCSP return self._A.shape[:2]
def get_extent(self): DCNL DCSP (numrows, numcols) = self.get_size() DCNL DCSP return (((-0.5) + self.ox), ((numcols - 0.5) + self.ox), ((-0.5) + self.oy), ((numrows - 0.5) + self.oy))
def write_png(self, fname): DCNL DCSP im = self.make_image() DCNL DCSP (rows, cols, buffer) = im.as_rgba_str() DCNL DCSP _png.write_png(buffer, cols, rows, fname)
def get_window_extent(self, *args, **kwargs): DCNL DCSP return self.bbox
def _init_axis(self): DCNL DCSP self.xaxis = maxis.XAxis(self) DCNL DCSP self.yaxis = maxis.YAxis(self) DCNL DCSP self._update_transScale()
def set_figure(self, fig): DCNL DCSP martist.Artist.set_figure(self, fig) DCNL DCSP self.bbox = mtransforms.TransformedBbox(self._position, fig.transFigure) DCNL DCSP self.dataLim = mtransforms.Bbox.unit() DCNL DCSP self.viewLim = mtransforms.Bbox.unit() DCNL DCSP self.transScale = mtransforms.TransformWrapper(mtransforms.IdentityTransform()) DCNL DCSP self._set_lim_and_transforms()
def _set_lim_and_transforms(self): DCNL DCSP self.transAxes = mtransforms.BboxTransformTo(self.bbox) DCNL DCSP self.transScale = mtransforms.TransformWrapper(mtransforms.IdentityTransform()) DCNL DCSP self.transLimits = mtransforms.BboxTransformFrom(mtransforms.TransformedBbox(self.viewLim, self.transScale)) DCNL DCSP self.transData = (self.transScale + (self.transLimits + self.transAxes)) DCNL DCSP self._xaxis_transform = mtransforms.blended_transform_factory(self.axes.transData, self.axes.transAxes) DCNL DCSP self._yaxis_transform = mtransforms.blended_transform_factory(self.axes.transAxes, self.axes.transData)
def get_xaxis_transform(self): DCNL DCSP return self._xaxis_transform
def get_xaxis_text1_transform(self, pad_points): DCNL DCSP return ((self._xaxis_transform + mtransforms.ScaledTranslation(0, (((-1) * pad_points) / 72.0), self.figure.dpi_scale_trans)), 'top', 'center')
def get_xaxis_text2_transform(self, pad_points): DCNL DCSP return ((self._xaxis_transform + mtransforms.ScaledTranslation(0, (pad_points / 72.0), self.figure.dpi_scale_trans)), 'bottom', 'center')
def get_yaxis_transform(self): DCNL DCSP return self._yaxis_transform
def get_yaxis_text1_transform(self, pad_points): DCNL DCSP return ((self._yaxis_transform + mtransforms.ScaledTranslation((((-1) * pad_points) / 72.0), 0, self.figure.dpi_scale_trans)), 'center', 'right')
def get_yaxis_text2_transform(self, pad_points): DCNL DCSP return ((self._yaxis_transform + mtransforms.ScaledTranslation((pad_points / 72.0), 0, self.figure.dpi_scale_trans)), 'center', 'left')
def get_position(self, original=False): DCNL DCSP if original: DCNL DCSP  DCSP return self._originalPosition.frozen() DCNL DCSP else: DCNL DCSP  DCSP return self._position.frozen()
def set_position(self, pos, which='both'): DCNL DCSP if (not isinstance(pos, mtransforms.BboxBase)): DCNL DCSP  DCSP pos = mtransforms.Bbox.from_bounds(*pos) DCNL DCSP if (which in ('both', 'active')): DCNL DCSP  DCSP self._position.set(pos) DCNL DCSP if (which in ('both', 'original')): DCNL DCSP  DCSP self._originalPosition.set(pos)
def reset_position(self): DCNL DCSP pos = self.get_position(original=True) DCNL DCSP self.set_position(pos, which='active')
def _set_artist_props(self, a): DCNL DCSP a.set_figure(self.figure) DCNL DCSP if (not a.is_transform_set()): DCNL DCSP  DCSP a.set_transform(self.transData) DCNL DCSP a.set_axes(self)
def _gen_axes_patch(self): DCNL DCSP return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
def cla(self): DCNL DCSP self.xaxis.cla() DCNL DCSP self.yaxis.cla() DCNL DCSP self.ignore_existing_data_limits = True DCNL DCSP self.callbacks = cbook.CallbackRegistry(('xlim_changed', 'ylim_changed')) DCNL DCSP if (self._sharex is not None): DCNL DCSP  DCSP self.xaxis.major = self._sharex.xaxis.major DCNL DCSP  DCSP self.xaxis.minor = self._sharex.xaxis.minor DCNL DCSP  DCSP (x0, x1) = self._sharex.get_xlim() DCNL DCSP  DCSP self.set_xlim(x0, x1, emit=False) DCNL DCSP  DCSP self.xaxis.set_scale(self._sharex.xaxis.get_scale()) DCNL DCSP else: DCNL DCSP  DCSP self.xaxis.set_scale('linear') DCNL DCSP if (self._sharey is not None): DCNL DCSP  DCSP self.yaxis.major = self._sharey.yaxis.major DCNL DCSP  DCSP self.yaxis.minor = self._sharey.yaxis.minor DCNL DCSP  DCSP (y0, y1) = self._sharey.get_ylim() DCNL DCSP  DCSP self.set_ylim(y0, y1, emit=False) DCNL DCSP  DCSP self.yaxis.set_scale(self._sharey.yaxis.get_scale()) DCNL DCSP else: DCNL DCSP  DCSP self.yaxis.set_scale('linear') DCNL DCSP self._autoscaleon = True DCNL DCSP self._update_transScale() DCNL DCSP self._get_lines = _process_plot_var_args(self) DCNL DCSP self._get_patches_for_fill = _process_plot_var_args(self, 'fill') DCNL DCSP self._gridOn = rcParams['axes.grid'] DCNL DCSP self.lines = [] DCNL DCSP self.patches = [] DCNL DCSP self.texts = [] DCNL DCSP self.tables = [] DCNL DCSP self.artists = [] DCNL DCSP self.images = [] DCNL DCSP self.legend_ = None DCNL DCSP self.collections = [] DCNL DCSP self.grid(self._gridOn) DCNL DCSP props = font_manager.FontProperties(size=rcParams['axes.titlesize']) DCNL DCSP self.titleOffsetTrans = mtransforms.ScaledTranslation(0.0, (5.0 / 72.0), self.figure.dpi_scale_trans) DCNL DCSP self.title = mtext.Text(x=0.5, y=1.0, text='', fontproperties=props, verticalalignment='bottom', horizontalalignment='center') DCNL DCSP self.title.set_transform((self.transAxes + self.titleOffsetTrans)) DCNL DCSP self.title.set_clip_box(None) DCNL DCSP self._set_artist_props(self.title) DCNL DCSP self.patch = self.axesPatch = self._gen_axes_patch() DCNL DCSP self.patch.set_figure(self.figure) DCNL DCSP self.patch.set_facecolor(self._axisbg) DCNL DCSP self.patch.set_edgecolor('None') DCNL DCSP self.patch.set_linewidth(0) DCNL DCSP self.patch.set_transform(self.transAxes) DCNL DCSP self.frame = self.axesFrame = self._gen_axes_patch() DCNL DCSP self.frame.set_figure(self.figure) DCNL DCSP self.frame.set_facecolor('none') DCNL DCSP self.frame.set_edgecolor(rcParams['axes.edgecolor']) DCNL DCSP self.frame.set_linewidth(rcParams['axes.linewidth']) DCNL DCSP self.frame.set_transform(self.transAxes) DCNL DCSP self.frame.set_zorder(2.5) DCNL DCSP self.axison = True DCNL DCSP self.xaxis.set_clip_path(self.patch) DCNL DCSP self.yaxis.set_clip_path(self.patch) DCNL DCSP self._shared_x_axes.clean() DCNL DCSP self._shared_y_axes.clean()
def clear(self): DCNL DCSP self.cla()
def set_color_cycle(self, clist): DCNL DCSP self._get_lines.set_color_cycle(clist)
def ishold(self): DCNL DCSP return self._hold
def hold(self, b=None): DCNL DCSP if (b is None): DCNL DCSP  DCSP self._hold = (not self._hold) DCNL DCSP else: DCNL DCSP  DCSP self._hold = b
def set_aspect(self, aspect, adjustable=None, anchor=None): DCNL DCSP if (aspect in ('normal', 'auto')): DCNL DCSP  DCSP self._aspect = 'auto' DCNL DCSP elif (aspect == 'equal'): DCNL DCSP  DCSP self._aspect = 'equal' DCNL DCSP else: DCNL DCSP  DCSP self._aspect = float(aspect) DCNL DCSP if (adjustable is not None): DCNL DCSP  DCSP self.set_adjustable(adjustable) DCNL DCSP if (anchor is not None): DCNL DCSP  DCSP self.set_anchor(anchor)
def set_adjustable(self, adjustable): DCNL DCSP if (adjustable in ('box', 'datalim')): DCNL DCSP  DCSP if ((self in self._shared_x_axes) or (self in self._shared_y_axes)): DCNL DCSP  DCSP  DCSP if (adjustable == 'box'): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('adjustable DCSP must DCSP be DCSP "datalim" DCSP for DCSP shared DCSP axes') DCNL DCSP  DCSP self._adjustable = adjustable DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('argument DCSP must DCSP be DCSP "box", DCSP or DCSP "datalim"')
def set_anchor(self, anchor): DCNL DCSP if ((anchor in mtransforms.Bbox.coefs.keys()) or (len(anchor) == 2)): DCNL DCSP  DCSP self._anchor = anchor DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('argument DCSP must DCSP be DCSP among DCSP %s' % ', DCSP '.join(mtransforms.BBox.coefs.keys())))
def get_data_ratio(self): DCNL DCSP (xmin, xmax) = self.get_xbound() DCNL DCSP xsize = max(math.fabs((xmax - xmin)), 1e-30) DCNL DCSP (ymin, ymax) = self.get_ybound() DCNL DCSP ysize = max(math.fabs((ymax - ymin)), 1e-30) DCNL DCSP return (ysize / xsize)
def apply_aspect(self, position=None): DCNL DCSP if (position is None): DCNL DCSP  DCSP position = self.get_position(original=True) DCNL DCSP aspect = self.get_aspect() DCNL DCSP if (aspect == 'auto'): DCNL DCSP  DCSP self.set_position(position, which='active') DCNL DCSP  DCSP return DCNL DCSP if (aspect == 'equal'): DCNL DCSP  DCSP A = 1 DCNL DCSP else: DCNL DCSP  DCSP A = aspect DCNL DCSP if ((self in self._shared_x_axes) or (self in self._shared_y_axes)): DCNL DCSP  DCSP if (self._adjustable == 'box'): DCNL DCSP  DCSP  DCSP self._adjustable = 'datalim' DCNL DCSP  DCSP  DCSP warnings.warn('shared DCSP axes: DCSP "adjustable" DCSP is DCSP being DCSP changed DCSP to DCSP "datalim"') DCNL DCSP (figW, figH) = self.get_figure().get_size_inches() DCNL DCSP fig_aspect = (figH / figW) DCNL DCSP if (self._adjustable == 'box'): DCNL DCSP  DCSP box_aspect = (A * self.get_data_ratio()) DCNL DCSP  DCSP pb = position.frozen() DCNL DCSP  DCSP pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect) DCNL DCSP  DCSP self.set_position(pb1.anchored(self.get_anchor(), pb), 'active') DCNL DCSP  DCSP return DCNL DCSP self.set_position(position, which='active') DCNL DCSP (xmin, xmax) = self.get_xbound() DCNL DCSP xsize = max(math.fabs((xmax - xmin)), 1e-30) DCNL DCSP (ymin, ymax) = self.get_ybound() DCNL DCSP ysize = max(math.fabs((ymax - ymin)), 1e-30) DCNL DCSP (l, b, w, h) = position.bounds DCNL DCSP box_aspect = (fig_aspect * (h / w)) DCNL DCSP data_ratio = (box_aspect / A) DCNL DCSP y_expander = (((data_ratio * xsize) / ysize) - 1.0) DCNL DCSP if (abs(y_expander) < 0.005): DCNL DCSP  DCSP return DCNL DCSP dL = self.dataLim DCNL DCSP xr = (1.05 * dL.width) DCNL DCSP yr = (1.05 * dL.height) DCNL DCSP xmarg = (xsize - xr) DCNL DCSP ymarg = (ysize - yr) DCNL DCSP Ysize = (data_ratio * xsize) DCNL DCSP Xsize = (ysize / data_ratio) DCNL DCSP Xmarg = (Xsize - xr) DCNL DCSP Ymarg = (Ysize - yr) DCNL DCSP xm = 0 DCNL DCSP ym = 0 DCNL DCSP changex = ((self in self._shared_y_axes) and (self not in self._shared_x_axes)) DCNL DCSP changey = ((self in self._shared_x_axes) and (self not in self._shared_y_axes)) DCNL DCSP if (changex and changey): DCNL DCSP  DCSP warnings.warn("adjustable='datalim' DCSP cannot DCSP work DCSP with DCSP shared DCSP x DCSP and DCSP y DCSP axes") DCNL DCSP  DCSP return DCNL DCSP if changex: DCNL DCSP  DCSP adjust_y = False DCNL DCSP else: DCNL DCSP  DCSP if ((xmarg > xm) and (ymarg > ym)): DCNL DCSP  DCSP  DCSP adjy = (((Ymarg > 0) and (y_expander < 0)) or ((Xmarg < 0) and (y_expander > 0))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP adjy = (y_expander > 0) DCNL DCSP  DCSP adjust_y = (changey or adjy) DCNL DCSP if adjust_y: DCNL DCSP  DCSP yc = (0.5 * (ymin + ymax)) DCNL DCSP  DCSP y0 = (yc - (Ysize / 2.0)) DCNL DCSP  DCSP y1 = (yc + (Ysize / 2.0)) DCNL DCSP  DCSP self.set_ybound((y0, y1)) DCNL DCSP else: DCNL DCSP  DCSP xc = (0.5 * (xmin + xmax)) DCNL DCSP  DCSP x0 = (xc - (Xsize / 2.0)) DCNL DCSP  DCSP x1 = (xc + (Xsize / 2.0)) DCNL DCSP  DCSP self.set_xbound((x0, x1))
def axis(self, *v, **kwargs): DCNL DCSP if ((len(v) == 1) and is_string_like(v[0])): DCNL DCSP  DCSP s = v[0].lower() DCNL DCSP  DCSP if (s == 'on'): DCNL DCSP  DCSP  DCSP self.set_axis_on() DCNL DCSP  DCSP elif (s == 'off'): DCNL DCSP  DCSP  DCSP self.set_axis_off() DCNL DCSP  DCSP elif (s in ('equal', 'tight', 'scaled', 'normal', 'auto', 'image')): DCNL DCSP  DCSP  DCSP self.set_autoscale_on(True) DCNL DCSP  DCSP  DCSP self.set_aspect('auto') DCNL DCSP  DCSP  DCSP self.autoscale_view() DCNL DCSP  DCSP  DCSP if (s == 'equal'): DCNL DCSP  DCSP  DCSP  DCSP self.set_aspect('equal', adjustable='datalim') DCNL DCSP  DCSP  DCSP elif (s == 'scaled'): DCNL DCSP  DCSP  DCSP  DCSP self.set_aspect('equal', adjustable='box', anchor='C') DCNL DCSP  DCSP  DCSP  DCSP self.set_autoscale_on(False) DCNL DCSP  DCSP  DCSP elif (s == 'tight'): DCNL DCSP  DCSP  DCSP  DCSP self.autoscale_view(tight=True) DCNL DCSP  DCSP  DCSP  DCSP self.set_autoscale_on(False) DCNL DCSP  DCSP  DCSP elif (s == 'image'): DCNL DCSP  DCSP  DCSP  DCSP self.autoscale_view(tight=True) DCNL DCSP  DCSP  DCSP  DCSP self.set_autoscale_on(False) DCNL DCSP  DCSP  DCSP  DCSP self.set_aspect('equal', adjustable='box', anchor='C') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('Unrecognized DCSP string DCSP %s DCSP to DCSP axis; DCSP try DCSP on DCSP or DCSP off' % s)) DCNL DCSP  DCSP (xmin, xmax) = self.get_xlim() DCNL DCSP  DCSP (ymin, ymax) = self.get_ylim() DCNL DCSP  DCSP return (xmin, xmax, ymin, ymax) DCNL DCSP try: DCNL DCSP  DCSP v[0] DCNL DCSP except IndexError: DCNL DCSP  DCSP emit = kwargs.get('emit', True) DCNL DCSP  DCSP xmin = kwargs.get('xmin', None) DCNL DCSP  DCSP xmax = kwargs.get('xmax', None) DCNL DCSP  DCSP (xmin, xmax) = self.set_xlim(xmin, xmax, emit) DCNL DCSP  DCSP ymin = kwargs.get('ymin', None) DCNL DCSP  DCSP ymax = kwargs.get('ymax', None) DCNL DCSP  DCSP (ymin, ymax) = self.set_ylim(ymin, ymax, emit) DCNL DCSP  DCSP return (xmin, xmax, ymin, ymax) DCNL DCSP v = v[0] DCNL DCSP if (len(v) != 4): DCNL DCSP  DCSP raise ValueError('v DCSP must DCSP contain DCSP [xmin DCSP xmax DCSP ymin DCSP ymax]') DCNL DCSP self.set_xlim([v[0], v[1]]) DCNL DCSP self.set_ylim([v[2], v[3]]) DCNL DCSP return v
def get_child_artists(self): DCNL DCSP raise DeprecationWarning('Use DCSP get_children DCSP instead')
def get_frame(self): DCNL DCSP warnings.warn('use DCSP ax.patch DCSP instead', DeprecationWarning) DCNL DCSP return self.patch
def get_legend(self): DCNL DCSP return self.legend_
def get_images(self): DCNL DCSP return cbook.silent_list('AxesImage', self.images)
def get_lines(self): DCNL DCSP return cbook.silent_list('Line2D', self.lines)
def get_xaxis(self): DCNL DCSP return self.xaxis
def get_xgridlines(self): DCNL DCSP return cbook.silent_list('Line2D DCSP xgridline', self.xaxis.get_gridlines())
def get_xticklines(self): DCNL DCSP return cbook.silent_list('Text DCSP xtickline', self.xaxis.get_ticklines())
def get_yaxis(self): DCNL DCSP return self.yaxis
def get_ygridlines(self): DCNL DCSP return cbook.silent_list('Line2D DCSP ygridline', self.yaxis.get_gridlines())
def get_yticklines(self): DCNL DCSP return cbook.silent_list('Line2D DCSP ytickline', self.yaxis.get_ticklines())
def has_data(self): DCNL DCSP return ((((len(self.collections) + len(self.images)) + len(self.lines)) + len(self.patches)) > 0)
def add_artist(self, a): DCNL DCSP a.set_axes(self) DCNL DCSP self.artists.append(a) DCNL DCSP self._set_artist_props(a) DCNL DCSP a.set_clip_path(self.patch) DCNL DCSP a._remove_method = (lambda h: self.artists.remove(h))
def add_collection(self, collection, autolim=True): DCNL DCSP label = collection.get_label() DCNL DCSP if (not label): DCNL DCSP  DCSP collection.set_label(('collection%d' % len(self.collections))) DCNL DCSP self.collections.append(collection) DCNL DCSP self._set_artist_props(collection) DCNL DCSP collection.set_clip_path(self.patch) DCNL DCSP if autolim: DCNL DCSP  DCSP if (collection._paths and len(collection._paths)): DCNL DCSP  DCSP  DCSP self.update_datalim(collection.get_datalim(self.transData)) DCNL DCSP collection._remove_method = (lambda h: self.collections.remove(h))
def add_line(self, line): DCNL DCSP self._set_artist_props(line) DCNL DCSP line.set_clip_path(self.patch) DCNL DCSP self._update_line_limits(line) DCNL DCSP if (not line.get_label()): DCNL DCSP  DCSP line.set_label(('_line%d' % len(self.lines))) DCNL DCSP self.lines.append(line) DCNL DCSP line._remove_method = (lambda h: self.lines.remove(h))
def add_patch(self, p): DCNL DCSP self._set_artist_props(p) DCNL DCSP p.set_clip_path(self.patch) DCNL DCSP self._update_patch_limits(p) DCNL DCSP self.patches.append(p) DCNL DCSP p._remove_method = (lambda h: self.patches.remove(h))
def _update_patch_limits(self, patch): DCNL DCSP if (isinstance(patch, mpatches.Rectangle) and ((patch.get_width() == 0) or (patch.get_height() == 0))): DCNL DCSP  DCSP return DCNL DCSP vertices = patch.get_path().vertices DCNL DCSP if (vertices.size > 0): DCNL DCSP  DCSP xys = patch.get_patch_transform().transform(vertices) DCNL DCSP  DCSP if (patch.get_data_transform() != self.transData): DCNL DCSP  DCSP  DCSP transform = (patch.get_data_transform() + self.transData.inverted()) DCNL DCSP  DCSP  DCSP xys = transform.transform(xys) DCNL DCSP  DCSP self.update_datalim(xys, updatex=patch.x_isdata, updatey=patch.y_isdata)
def add_table(self, tab): DCNL DCSP self._set_artist_props(tab) DCNL DCSP self.tables.append(tab) DCNL DCSP tab.set_clip_path(self.patch) DCNL DCSP tab._remove_method = (lambda h: self.tables.remove(h))
def relim(self): DCNL DCSP self.dataLim.ignore(True) DCNL DCSP self.ignore_existing_data_limits = True DCNL DCSP for line in self.lines: DCNL DCSP  DCSP self._update_line_limits(line) DCNL DCSP for p in self.patches: DCNL DCSP  DCSP self._update_patch_limits(p)
def update_datalim(self, xys, updatex=True, updatey=True): DCNL DCSP if (iterable(xys) and (not len(xys))): DCNL DCSP  DCSP return DCNL DCSP if (not ma.isMaskedArray(xys)): DCNL DCSP  DCSP xys = np.asarray(xys) DCNL DCSP self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits, updatex=updatex, updatey=updatey) DCNL DCSP self.ignore_existing_data_limits = False
def update_datalim_numerix(self, x, y): DCNL DCSP if (iterable(x) and (not len(x))): DCNL DCSP  DCSP return DCNL DCSP self.dataLim.update_from_data(x, y, self.ignore_existing_data_limits) DCNL DCSP self.ignore_existing_data_limits = False
def update_datalim_bounds(self, bounds): DCNL DCSP self.dataLim.set(mtransforms.Bbox.union([self.dataLim, bounds]))
def _process_unit_info(self, xdata=None, ydata=None, kwargs=None): DCNL DCSP if ((self.xaxis is None) or (self.yaxis is None)): DCNL DCSP  DCSP return DCNL DCSP if (xdata is not None): DCNL DCSP  DCSP if (not self.xaxis.have_units()): DCNL DCSP  DCSP  DCSP self.xaxis.update_units(xdata) DCNL DCSP if (ydata is not None): DCNL DCSP  DCSP if (not self.yaxis.have_units()): DCNL DCSP  DCSP  DCSP self.yaxis.update_units(ydata) DCNL DCSP if (kwargs is not None): DCNL DCSP  DCSP xunits = kwargs.pop('xunits', self.xaxis.units) DCNL DCSP  DCSP if (xunits != self.xaxis.units): DCNL DCSP  DCSP  DCSP self.xaxis.set_units(xunits) DCNL DCSP  DCSP  DCSP if (xdata is not None): DCNL DCSP  DCSP  DCSP  DCSP self.xaxis.update_units(xdata) DCNL DCSP  DCSP yunits = kwargs.pop('yunits', self.yaxis.units) DCNL DCSP  DCSP if (yunits != self.yaxis.units): DCNL DCSP  DCSP  DCSP self.yaxis.set_units(yunits) DCNL DCSP  DCSP  DCSP if (ydata is not None): DCNL DCSP  DCSP  DCSP  DCSP self.yaxis.update_units(ydata)
def in_axes(self, mouseevent): DCNL DCSP return self.patch.contains(mouseevent)[0]
def get_autoscale_on(self): DCNL DCSP return self._autoscaleon
def set_autoscale_on(self, b): DCNL DCSP self._autoscaleon = b
def autoscale_view(self, tight=False, scalex=True, scaley=True): DCNL DCSP if (not self._autoscaleon): DCNL DCSP  DCSP return DCNL DCSP if scalex: DCNL DCSP  DCSP xshared = self._shared_x_axes.get_siblings(self) DCNL DCSP  DCSP dl = [ax.dataLim for ax in xshared] DCNL DCSP  DCSP bb = mtransforms.BboxBase.union(dl) DCNL DCSP  DCSP (x0, x1) = bb.intervalx DCNL DCSP if scaley: DCNL DCSP  DCSP yshared = self._shared_y_axes.get_siblings(self) DCNL DCSP  DCSP dl = [ax.dataLim for ax in yshared] DCNL DCSP  DCSP bb = mtransforms.BboxBase.union(dl) DCNL DCSP  DCSP (y0, y1) = bb.intervaly DCNL DCSP if (tight or ((len(self.images) > 0) and (len(self.lines) == 0) and (len(self.patches) == 0))): DCNL DCSP  DCSP if scalex: DCNL DCSP  DCSP  DCSP self.set_xbound(x0, x1) DCNL DCSP  DCSP if scaley: DCNL DCSP  DCSP  DCSP self.set_ybound(y0, y1) DCNL DCSP  DCSP return DCNL DCSP if scalex: DCNL DCSP  DCSP XL = self.xaxis.get_major_locator().view_limits(x0, x1) DCNL DCSP  DCSP self.set_xbound(XL) DCNL DCSP if scaley: DCNL DCSP  DCSP YL = self.yaxis.get_major_locator().view_limits(y0, y1) DCNL DCSP  DCSP self.set_ybound(YL)
def draw(self, renderer=None, inframe=False): DCNL DCSP if (renderer is None): DCNL DCSP  DCSP renderer = self._cachedRenderer DCNL DCSP if (renderer is None): DCNL DCSP  DCSP raise RuntimeError('No DCSP renderer DCSP defined') DCNL DCSP if (not self.get_visible()): DCNL DCSP  DCSP return DCNL DCSP renderer.open_group('axes') DCNL DCSP self.apply_aspect() DCNL DCSP if (self.axison and self._frameon): DCNL DCSP  DCSP self.patch.draw(renderer) DCNL DCSP artists = [] DCNL DCSP if ((len(self.images) <= 1) or renderer.option_image_nocomposite()): DCNL DCSP  DCSP for im in self.images: DCNL DCSP  DCSP  DCSP im.draw(renderer) DCNL DCSP else: DCNL DCSP  DCSP mag = renderer.get_image_magnification() DCNL DCSP  DCSP ims = [(im.make_image(mag), 0, 0) for im in self.images if im.get_visible()] DCNL DCSP  DCSP (l, b, r, t) = self.bbox.extents DCNL DCSP  DCSP width = (mag * ((round(r) + 0.5) - (round(l) - 0.5))) DCNL DCSP  DCSP height = (mag * ((round(t) + 0.5) - (round(b) - 0.5))) DCNL DCSP  DCSP im = mimage.from_images(height, width, ims) DCNL DCSP  DCSP im.is_grayscale = False DCNL DCSP  DCSP (l, b, w, h) = self.bbox.bounds DCNL DCSP  DCSP renderer.draw_image(round(l), round(b), im, self.bbox, self.patch.get_path(), self.patch.get_transform()) DCNL DCSP artists.extend(self.collections) DCNL DCSP artists.extend(self.patches) DCNL DCSP artists.extend(self.lines) DCNL DCSP artists.extend(self.texts) DCNL DCSP artists.extend(self.artists) DCNL DCSP if (self.axison and (not inframe)): DCNL DCSP  DCSP if self._axisbelow: DCNL DCSP  DCSP  DCSP self.xaxis.set_zorder(0.5) DCNL DCSP  DCSP  DCSP self.yaxis.set_zorder(0.5) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.xaxis.set_zorder(2.5) DCNL DCSP  DCSP  DCSP self.yaxis.set_zorder(2.5) DCNL DCSP  DCSP artists.extend([self.xaxis, self.yaxis]) DCNL DCSP if (not inframe): DCNL DCSP  DCSP artists.append(self.title) DCNL DCSP artists.extend(self.tables) DCNL DCSP if (self.legend_ is not None): DCNL DCSP  DCSP artists.append(self.legend_) DCNL DCSP if (self.axison and self._frameon): DCNL DCSP  DCSP artists.append(self.frame) DCNL DCSP dsu = [(a.zorder, i, a) for (i, a) in enumerate(artists) if (not a.get_animated())] DCNL DCSP dsu.sort() DCNL DCSP for (zorder, i, a) in dsu: DCNL DCSP  DCSP a.draw(renderer) DCNL DCSP renderer.close_group('axes') DCNL DCSP self._cachedRenderer = renderer
def draw_artist(self, a): DCNL DCSP assert (self._cachedRenderer is not None) DCNL DCSP a.draw(self._cachedRenderer)
def redraw_in_frame(self): DCNL DCSP assert (self._cachedRenderer is not None) DCNL DCSP self.draw(self._cachedRenderer, inframe=True)
def get_frame_on(self): DCNL DCSP return self._frameon
def set_frame_on(self, b): DCNL DCSP self._frameon = b
def get_axisbelow(self): DCNL DCSP return self._axisbelow
def set_axisbelow(self, b): DCNL DCSP self._axisbelow = b
def grid(self, b=None, **kwargs): DCNL DCSP if len(kwargs): DCNL DCSP  DCSP b = True DCNL DCSP self.xaxis.grid(b, **kwargs) DCNL DCSP self.yaxis.grid(b, **kwargs)
def ticklabel_format(self, **kwargs): DCNL DCSP style = kwargs.pop('style', '').lower() DCNL DCSP scilimits = kwargs.pop('scilimits', None) DCNL DCSP if (scilimits is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (m, n) = scilimits DCNL DCSP  DCSP  DCSP ((m + n) + 1) DCNL DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP raise ValueError('scilimits DCSP must DCSP be DCSP a DCSP sequence DCSP of DCSP 2 DCSP integers') DCNL DCSP axis = kwargs.pop('axis', 'both').lower() DCNL DCSP if (style[:3] == 'sci'): DCNL DCSP  DCSP sb = True DCNL DCSP elif (style in ['plain', 'comma']): DCNL DCSP  DCSP sb = False DCNL DCSP  DCSP if (style == 'plain'): DCNL DCSP  DCSP  DCSP cb = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cb = True DCNL DCSP  DCSP  DCSP raise NotImplementedError, 'comma DCSP style DCSP remains DCSP to DCSP be DCSP added' DCNL DCSP elif (style == ''): DCNL DCSP  DCSP sb = None DCNL DCSP else: DCNL DCSP  DCSP raise ValueError, '%s DCSP is DCSP not DCSP a DCSP valid DCSP style DCSP value' DCNL DCSP try: DCNL DCSP  DCSP if (sb is not None): DCNL DCSP  DCSP  DCSP if ((axis == 'both') or (axis == 'x')): DCNL DCSP  DCSP  DCSP  DCSP self.xaxis.major.formatter.set_scientific(sb) DCNL DCSP  DCSP  DCSP if ((axis == 'both') or (axis == 'y')): DCNL DCSP  DCSP  DCSP  DCSP self.yaxis.major.formatter.set_scientific(sb) DCNL DCSP  DCSP if (scilimits is not None): DCNL DCSP  DCSP  DCSP if ((axis == 'both') or (axis == 'x')): DCNL DCSP  DCSP  DCSP  DCSP self.xaxis.major.formatter.set_powerlimits(scilimits) DCNL DCSP  DCSP  DCSP if ((axis == 'both') or (axis == 'y')): DCNL DCSP  DCSP  DCSP  DCSP self.yaxis.major.formatter.set_powerlimits(scilimits) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise AttributeError('This DCSP method DCSP only DCSP works DCSP with DCSP the DCSP ScalarFormatter.')
def set_axis_off(self): DCNL DCSP self.axison = False
def set_axis_on(self): DCNL DCSP self.axison = True
def get_axis_bgcolor(self): DCNL DCSP return self._axisbg
def set_axis_bgcolor(self, color): DCNL DCSP self._axisbg = color DCNL DCSP self.patch.set_facecolor(color)
def invert_xaxis(self): DCNL DCSP (left, right) = self.get_xlim() DCNL DCSP self.set_xlim(right, left)
def xaxis_inverted(self): DCNL DCSP (left, right) = self.get_xlim() DCNL DCSP return (right < left)
def get_xbound(self): DCNL DCSP (left, right) = self.get_xlim() DCNL DCSP if (left < right): DCNL DCSP  DCSP return (left, right) DCNL DCSP else: DCNL DCSP  DCSP return (right, left)
def set_xbound(self, lower=None, upper=None): DCNL DCSP if ((upper is None) and iterable(lower)): DCNL DCSP  DCSP (lower, upper) = lower DCNL DCSP (old_lower, old_upper) = self.get_xbound() DCNL DCSP if (lower is None): DCNL DCSP  DCSP lower = old_lower DCNL DCSP if (upper is None): DCNL DCSP  DCSP upper = old_upper DCNL DCSP if self.xaxis_inverted(): DCNL DCSP  DCSP if (lower < upper): DCNL DCSP  DCSP  DCSP self.set_xlim(upper, lower) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.set_xlim(lower, upper) DCNL DCSP elif (lower < upper): DCNL DCSP  DCSP self.set_xlim(lower, upper) DCNL DCSP else: DCNL DCSP  DCSP self.set_xlim(upper, lower)
def get_xlim(self): DCNL DCSP return tuple(self.viewLim.intervalx)
def set_xlim(self, xmin=None, xmax=None, emit=True, **kwargs): DCNL DCSP if ((xmax is None) and iterable(xmin)): DCNL DCSP  DCSP (xmin, xmax) = xmin DCNL DCSP self._process_unit_info(xdata=(xmin, xmax)) DCNL DCSP if (xmin is not None): DCNL DCSP  DCSP xmin = self.convert_xunits(xmin) DCNL DCSP if (xmax is not None): DCNL DCSP  DCSP xmax = self.convert_xunits(xmax) DCNL DCSP (old_xmin, old_xmax) = self.get_xlim() DCNL DCSP if (xmin is None): DCNL DCSP  DCSP xmin = old_xmin DCNL DCSP if (xmax is None): DCNL DCSP  DCSP xmax = old_xmax DCNL DCSP (xmin, xmax) = mtransforms.nonsingular(xmin, xmax, increasing=False) DCNL DCSP (xmin, xmax) = self.xaxis.limit_range_for_scale(xmin, xmax) DCNL DCSP self.viewLim.intervalx = (xmin, xmax) DCNL DCSP if emit: DCNL DCSP  DCSP self.callbacks.process('xlim_changed', self) DCNL DCSP  DCSP for other in self._shared_x_axes.get_siblings(self): DCNL DCSP  DCSP  DCSP if (other is not self): DCNL DCSP  DCSP  DCSP  DCSP other.set_xlim(self.viewLim.intervalx, emit=False) DCNL DCSP  DCSP  DCSP  DCSP if ((other.figure != self.figure) and (other.figure.canvas is not None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP other.figure.canvas.draw_idle() DCNL DCSP return (xmin, xmax)
def set_xscale(self, value, **kwargs): DCNL DCSP self.xaxis.set_scale(value, **kwargs) DCNL DCSP self.autoscale_view() DCNL DCSP self._update_transScale()
def get_xticks(self, minor=False): DCNL DCSP return self.xaxis.get_ticklocs(minor=minor)
def set_xticks(self, ticks, minor=False): DCNL DCSP return self.xaxis.set_ticks(ticks, minor=minor)
def get_xmajorticklabels(self): DCNL DCSP return cbook.silent_list('Text DCSP xticklabel', self.xaxis.get_majorticklabels())
def get_xminorticklabels(self): DCNL DCSP return cbook.silent_list('Text DCSP xticklabel', self.xaxis.get_minorticklabels())
def get_xticklabels(self, minor=False): DCNL DCSP return cbook.silent_list('Text DCSP xticklabel', self.xaxis.get_ticklabels(minor=minor))
def set_xticklabels(self, labels, fontdict=None, minor=False, **kwargs): DCNL DCSP return self.xaxis.set_ticklabels(labels, fontdict, minor=minor, **kwargs)
def invert_yaxis(self): DCNL DCSP (left, right) = self.get_ylim() DCNL DCSP self.set_ylim(right, left)
def yaxis_inverted(self): DCNL DCSP (left, right) = self.get_ylim() DCNL DCSP return (right < left)
def get_ybound(self): DCNL DCSP (left, right) = self.get_ylim() DCNL DCSP if (left < right): DCNL DCSP  DCSP return (left, right) DCNL DCSP else: DCNL DCSP  DCSP return (right, left)
def set_ybound(self, lower=None, upper=None): DCNL DCSP if ((upper is None) and iterable(lower)): DCNL DCSP  DCSP (lower, upper) = lower DCNL DCSP (old_lower, old_upper) = self.get_ybound() DCNL DCSP if (lower is None): DCNL DCSP  DCSP lower = old_lower DCNL DCSP if (upper is None): DCNL DCSP  DCSP upper = old_upper DCNL DCSP if self.yaxis_inverted(): DCNL DCSP  DCSP if (lower < upper): DCNL DCSP  DCSP  DCSP self.set_ylim(upper, lower) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.set_ylim(lower, upper) DCNL DCSP elif (lower < upper): DCNL DCSP  DCSP self.set_ylim(lower, upper) DCNL DCSP else: DCNL DCSP  DCSP self.set_ylim(upper, lower)
def get_ylim(self): DCNL DCSP return tuple(self.viewLim.intervaly)
def set_ylim(self, ymin=None, ymax=None, emit=True, **kwargs): DCNL DCSP if ((ymax is None) and iterable(ymin)): DCNL DCSP  DCSP (ymin, ymax) = ymin DCNL DCSP if (ymin is not None): DCNL DCSP  DCSP ymin = self.convert_yunits(ymin) DCNL DCSP if (ymax is not None): DCNL DCSP  DCSP ymax = self.convert_yunits(ymax) DCNL DCSP (old_ymin, old_ymax) = self.get_ylim() DCNL DCSP if (ymin is None): DCNL DCSP  DCSP ymin = old_ymin DCNL DCSP if (ymax is None): DCNL DCSP  DCSP ymax = old_ymax DCNL DCSP (ymin, ymax) = mtransforms.nonsingular(ymin, ymax, increasing=False) DCNL DCSP (ymin, ymax) = self.yaxis.limit_range_for_scale(ymin, ymax) DCNL DCSP self.viewLim.intervaly = (ymin, ymax) DCNL DCSP if emit: DCNL DCSP  DCSP self.callbacks.process('ylim_changed', self) DCNL DCSP  DCSP for other in self._shared_y_axes.get_siblings(self): DCNL DCSP  DCSP  DCSP if (other is not self): DCNL DCSP  DCSP  DCSP  DCSP other.set_ylim(self.viewLim.intervaly, emit=False) DCNL DCSP  DCSP  DCSP  DCSP if ((other.figure != self.figure) and (other.figure.canvas is not None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP other.figure.canvas.draw_idle() DCNL DCSP return (ymin, ymax)
def set_yscale(self, value, **kwargs): DCNL DCSP self.yaxis.set_scale(value, **kwargs) DCNL DCSP self.autoscale_view() DCNL DCSP self._update_transScale()
def get_yticks(self, minor=False): DCNL DCSP return self.yaxis.get_ticklocs(minor=minor)
def set_yticks(self, ticks, minor=False): DCNL DCSP return self.yaxis.set_ticks(ticks, minor=minor)
def get_ymajorticklabels(self): DCNL DCSP return cbook.silent_list('Text DCSP yticklabel', self.yaxis.get_majorticklabels())
def get_yminorticklabels(self): DCNL DCSP return cbook.silent_list('Text DCSP yticklabel', self.yaxis.get_minorticklabels())
def get_yticklabels(self, minor=False): DCNL DCSP return cbook.silent_list('Text DCSP yticklabel', self.yaxis.get_ticklabels(minor=minor))
def set_yticklabels(self, labels, fontdict=None, minor=False, **kwargs): DCNL DCSP return self.yaxis.set_ticklabels(labels, fontdict, minor=minor, **kwargs)
def xaxis_date(self, tz=None): DCNL DCSP (xmin, xmax) = self.dataLim.intervalx DCNL DCSP if (xmin == 0.0): DCNL DCSP  DCSP dmax = today = datetime.date.today() DCNL DCSP  DCSP dmin = (today - datetime.timedelta(days=10)) DCNL DCSP  DCSP self._process_unit_info(xdata=(dmin, dmax)) DCNL DCSP  DCSP (dmin, dmax) = self.convert_xunits([dmin, dmax]) DCNL DCSP  DCSP self.viewLim.intervalx = (dmin, dmax) DCNL DCSP  DCSP self.dataLim.intervalx = (dmin, dmax) DCNL DCSP locator = self.xaxis.get_major_locator() DCNL DCSP if (not isinstance(locator, mdates.DateLocator)): DCNL DCSP  DCSP locator = mdates.AutoDateLocator(tz) DCNL DCSP  DCSP self.xaxis.set_major_locator(locator) DCNL DCSP if (self.viewLim.intervalx[0] == 0.0): DCNL DCSP  DCSP self.viewLim.intervalx = tuple(self.dataLim.intervalx) DCNL DCSP locator.refresh() DCNL DCSP formatter = self.xaxis.get_major_formatter() DCNL DCSP if (not isinstance(formatter, mdates.DateFormatter)): DCNL DCSP  DCSP formatter = mdates.AutoDateFormatter(locator, tz) DCNL DCSP  DCSP self.xaxis.set_major_formatter(formatter)
def yaxis_date(self, tz=None): DCNL DCSP (ymin, ymax) = self.dataLim.intervaly DCNL DCSP if (ymin == 0.0): DCNL DCSP  DCSP dmax = today = datetime.date.today() DCNL DCSP  DCSP dmin = (today - datetime.timedelta(days=10)) DCNL DCSP  DCSP self._process_unit_info(ydata=(dmin, dmax)) DCNL DCSP  DCSP (dmin, dmax) = self.convert_yunits([dmin, dmax]) DCNL DCSP  DCSP self.viewLim.intervaly = (dmin, dmax) DCNL DCSP  DCSP self.dataLim.intervaly = (dmin, dmax) DCNL DCSP locator = self.yaxis.get_major_locator() DCNL DCSP if (not isinstance(locator, mdates.DateLocator)): DCNL DCSP  DCSP locator = mdates.AutoDateLocator(tz) DCNL DCSP  DCSP self.yaxis.set_major_locator(locator) DCNL DCSP if (self.viewLim.intervaly[0] == 0.0): DCNL DCSP  DCSP self.viewLim.intervaly = tuple(self.dataLim.intervaly) DCNL DCSP locator.refresh() DCNL DCSP formatter = self.xaxis.get_major_formatter() DCNL DCSP if (not isinstance(formatter, mdates.DateFormatter)): DCNL DCSP  DCSP formatter = mdates.AutoDateFormatter(locator, tz) DCNL DCSP  DCSP self.yaxis.set_major_formatter(formatter)
def format_xdata(self, x): DCNL DCSP try: DCNL DCSP  DCSP return self.fmt_xdata(x) DCNL DCSP except TypeError: DCNL DCSP  DCSP func = self.xaxis.get_major_formatter().format_data_short DCNL DCSP  DCSP val = func(x) DCNL DCSP  DCSP return val
def format_ydata(self, y): DCNL DCSP try: DCNL DCSP  DCSP return self.fmt_ydata(y) DCNL DCSP except TypeError: DCNL DCSP  DCSP func = self.yaxis.get_major_formatter().format_data_short DCNL DCSP  DCSP val = func(y) DCNL DCSP  DCSP return val
def format_coord(self, x, y): DCNL DCSP if (x is None): DCNL DCSP  DCSP x = '???' DCNL DCSP if (y is None): DCNL DCSP  DCSP y = '???' DCNL DCSP xs = self.format_xdata(x) DCNL DCSP ys = self.format_ydata(y) DCNL DCSP return ('x=%s, DCSP y=%s' % (xs, ys))
def can_zoom(self): DCNL DCSP return True
def get_navigate(self): DCNL DCSP return self._navigate
def set_navigate(self, b): DCNL DCSP self._navigate = b
def get_navigate_mode(self): DCNL DCSP return self._navigate_mode
def set_navigate_mode(self, b): DCNL DCSP self._navigate_mode = b
def start_pan(self, x, y, button): DCNL DCSP self._pan_start = cbook.Bunch(lim=self.viewLim.frozen(), trans=self.transData.frozen(), trans_inverse=self.transData.inverted().frozen(), bbox=self.bbox.frozen(), x=x, y=y)
def end_pan(self): DCNL DCSP del self._pan_start
def drag_pan(self, button, key, x, y): DCNL DCSP def format_deltas(key, dx, dy): DCNL DCSP  DCSP if (key == 'control'): DCNL DCSP  DCSP  DCSP if (abs(dx) > abs(dy)): DCNL DCSP  DCSP  DCSP  DCSP dy = dx DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP dx = dy DCNL DCSP  DCSP elif (key == 'x'): DCNL DCSP  DCSP  DCSP dy = 0 DCNL DCSP  DCSP elif (key == 'y'): DCNL DCSP  DCSP  DCSP dx = 0 DCNL DCSP  DCSP elif (key == 'shift'): DCNL DCSP  DCSP  DCSP if ((2 * abs(dx)) < abs(dy)): DCNL DCSP  DCSP  DCSP  DCSP dx = 0 DCNL DCSP  DCSP  DCSP elif ((2 * abs(dy)) < abs(dx)): DCNL DCSP  DCSP  DCSP  DCSP dy = 0 DCNL DCSP  DCSP  DCSP elif (abs(dx) > abs(dy)): DCNL DCSP  DCSP  DCSP  DCSP dy = ((dy / abs(dy)) * abs(dx)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP dx = ((dx / abs(dx)) * abs(dy)) DCNL DCSP  DCSP return (dx, dy) DCNL DCSP p = self._pan_start DCNL DCSP dx = (x - p.x) DCNL DCSP dy = (y - p.y) DCNL DCSP if ((dx == 0) and (dy == 0)): DCNL DCSP  DCSP return DCNL DCSP if (button == 1): DCNL DCSP  DCSP (dx, dy) = format_deltas(key, dx, dy) DCNL DCSP  DCSP result = p.bbox.translated((- dx), (- dy)).transformed(p.trans_inverse) DCNL DCSP elif (button == 3): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP dx = ((- dx) / float(self.bbox.width)) DCNL DCSP  DCSP  DCSP dy = ((- dy) / float(self.bbox.height)) DCNL DCSP  DCSP  DCSP (dx, dy) = format_deltas(key, dx, dy) DCNL DCSP  DCSP  DCSP if (self.get_aspect() != 'auto'): DCNL DCSP  DCSP  DCSP  DCSP dx = (0.5 * (dx + dy)) DCNL DCSP  DCSP  DCSP  DCSP dy = dx DCNL DCSP  DCSP  DCSP alpha = np.power(10.0, (dx, dy)) DCNL DCSP  DCSP  DCSP start = p.trans_inverse.transform_point((p.x, p.y)) DCNL DCSP  DCSP  DCSP lim_points = p.lim.get_points() DCNL DCSP  DCSP  DCSP result = (start + (alpha * (lim_points - start))) DCNL DCSP  DCSP  DCSP result = mtransforms.Bbox(result) DCNL DCSP  DCSP except OverflowError: DCNL DCSP  DCSP  DCSP warnings.warn('Overflow DCSP while DCSP panning') DCNL DCSP  DCSP  DCSP return DCNL DCSP self.set_xlim(*result.intervalx) DCNL DCSP self.set_ylim(*result.intervaly)
def get_cursor_props(self): DCNL DCSP return self._cursorProps
def set_cursor_props(self, *args): DCNL DCSP if (len(args) == 1): DCNL DCSP  DCSP (lw, c) = args[0] DCNL DCSP elif (len(args) == 2): DCNL DCSP  DCSP (lw, c) = args DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('args DCSP must DCSP be DCSP a DCSP (linewidth, DCSP color) DCSP tuple') DCNL DCSP c = mcolors.colorConverter.to_rgba(c) DCNL DCSP self._cursorProps = (lw, c)
def connect(self, s, func): DCNL DCSP raise DeprecationWarning('use DCSP the DCSP callbacks DCSP CallbackRegistry DCSP instance DCSP instead')
def disconnect(self, cid): DCNL DCSP raise DeprecationWarning('use DCSP the DCSP callbacks DCSP CallbackRegistry DCSP instance DCSP instead')
def get_children(self): DCNL DCSP children = [] DCNL DCSP children.append(self.xaxis) DCNL DCSP children.append(self.yaxis) DCNL DCSP children.extend(self.lines) DCNL DCSP children.extend(self.patches) DCNL DCSP children.extend(self.texts) DCNL DCSP children.extend(self.tables) DCNL DCSP children.extend(self.artists) DCNL DCSP children.extend(self.images) DCNL DCSP if (self.legend_ is not None): DCNL DCSP  DCSP children.append(self.legend_) DCNL DCSP children.extend(self.collections) DCNL DCSP children.append(self.title) DCNL DCSP children.append(self.patch) DCNL DCSP children.append(self.frame) DCNL DCSP return children
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP return self.patch.contains(mouseevent)
def pick(self, *args): DCNL DCSP if (len(args) > 1): DCNL DCSP  DCSP raise DeprecationWarning('New DCSP pick DCSP API DCSP implemented DCSP -- DCSP see DCSP API_CHANGES DCSP in DCSP the DCSP src DCSP distribution') DCNL DCSP martist.Artist.pick(self, args[0])
def __pick(self, x, y, trans=None, among=None): DCNL DCSP if (trans is not None): DCNL DCSP  DCSP xywin = trans.transform_point((x, y)) DCNL DCSP else: DCNL DCSP  DCSP xywin = (x, y) DCNL DCSP def dist_points(p1, p2): DCNL DCSP  DCSP 'return DCSP the DCSP distance DCSP between DCSP two DCSP points' DCNL DCSP  DCSP (x1, y1) = p1 DCNL DCSP  DCSP (x2, y2) = p2 DCNL DCSP  DCSP return math.sqrt((((x1 - x2) ** 2) + ((y1 - y2) ** 2))) DCNL DCSP def dist_x_y(p1, x, y): DCNL DCSP  DCSP '*x* DCSP and DCSP *y* DCSP are DCSP arrays; DCSP return DCSP the DCSP distance DCSP to DCSP the DCSP closest DCSP point' DCNL DCSP  DCSP (x1, y1) = p1 DCNL DCSP  DCSP return min(np.sqrt((((x - x1) ** 2) + ((y - y1) ** 2)))) DCNL DCSP def dist(a): DCNL DCSP  DCSP if isinstance(a, Text): DCNL DCSP  DCSP  DCSP bbox = a.get_window_extent() DCNL DCSP  DCSP  DCSP (l, b, w, h) = bbox.bounds DCNL DCSP  DCSP  DCSP verts = ((l, b), (l, (b + h)), ((l + w), (b + h)), ((l + w), b)) DCNL DCSP  DCSP  DCSP (xt, yt) = zip(*verts) DCNL DCSP  DCSP elif isinstance(a, Patch): DCNL DCSP  DCSP  DCSP path = a.get_path() DCNL DCSP  DCSP  DCSP tverts = a.get_transform().transform_path(path) DCNL DCSP  DCSP  DCSP (xt, yt) = zip(*tverts) DCNL DCSP  DCSP elif isinstance(a, mlines.Line2D): DCNL DCSP  DCSP  DCSP xdata = a.get_xdata(orig=False) DCNL DCSP  DCSP  DCSP ydata = a.get_ydata(orig=False) DCNL DCSP  DCSP  DCSP (xt, yt) = a.get_transform().numerix_x_y(xdata, ydata) DCNL DCSP  DCSP return dist_x_y(xywin, np.asarray(xt), np.asarray(yt)) DCNL DCSP artists = ((self.lines + self.patches) + self.texts) DCNL DCSP if callable(among): DCNL DCSP  DCSP artists = filter(test, artists) DCNL DCSP elif iterable(among): DCNL DCSP  DCSP amongd = dict([(k, 1) for k in among]) DCNL DCSP  DCSP artists = [a for a in artists if (a in amongd)] DCNL DCSP elif (among is None): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('among DCSP must DCSP be DCSP callable DCSP or DCSP iterable') DCNL DCSP if (not len(artists)): DCNL DCSP  DCSP return None DCNL DCSP ds = [(dist(a), a) for a in artists] DCNL DCSP ds.sort() DCNL DCSP return ds[0][1]
def get_title(self): DCNL DCSP return self.title.get_text()
def set_title(self, label, fontdict=None, **kwargs): DCNL DCSP default = {'fontsize': rcParams['axes.titlesize'], 'verticalalignment': 'bottom', 'horizontalalignment': 'center'} DCNL DCSP self.title.set_text(label) DCNL DCSP self.title.update(default) DCNL DCSP if (fontdict is not None): DCNL DCSP  DCSP self.title.update(fontdict) DCNL DCSP self.title.update(kwargs) DCNL DCSP return self.title
def get_xlabel(self): DCNL DCSP label = self.xaxis.get_label() DCNL DCSP return label.get_text()
def set_xlabel(self, xlabel, fontdict=None, **kwargs): DCNL DCSP label = self.xaxis.get_label() DCNL DCSP label.set_text(xlabel) DCNL DCSP if (fontdict is not None): DCNL DCSP  DCSP label.update(fontdict) DCNL DCSP label.update(kwargs) DCNL DCSP return label
def get_ylabel(self): DCNL DCSP label = self.yaxis.get_label() DCNL DCSP return label.get_text()
def set_ylabel(self, ylabel, fontdict=None, **kwargs): DCNL DCSP label = self.yaxis.get_label() DCNL DCSP label.set_text(ylabel) DCNL DCSP if (fontdict is not None): DCNL DCSP  DCSP label.update(fontdict) DCNL DCSP label.update(kwargs) DCNL DCSP return label
def text(self, x, y, s, fontdict=None, withdash=False, **kwargs): DCNL DCSP default = {'verticalalignment': 'bottom', 'horizontalalignment': 'left', 'transform': self.transData} DCNL DCSP if withdash: DCNL DCSP  DCSP t = mtext.TextWithDash(x=x, y=y, text=s) DCNL DCSP else: DCNL DCSP  DCSP t = mtext.Text(x=x, y=y, text=s) DCNL DCSP self._set_artist_props(t) DCNL DCSP t.update(default) DCNL DCSP if (fontdict is not None): DCNL DCSP  DCSP t.update(fontdict) DCNL DCSP t.update(kwargs) DCNL DCSP self.texts.append(t) DCNL DCSP t._remove_method = (lambda h: self.texts.remove(h)) DCNL DCSP if ('clip_on' in kwargs): DCNL DCSP  DCSP t.set_clip_box(self.bbox) DCNL DCSP return t
def annotate(self, *args, **kwargs): DCNL DCSP a = mtext.Annotation(*args, **kwargs) DCNL DCSP a.set_transform(mtransforms.IdentityTransform()) DCNL DCSP self._set_artist_props(a) DCNL DCSP if kwargs.has_key('clip_on'): DCNL DCSP  DCSP a.set_clip_path(self.patch) DCNL DCSP self.texts.append(a) DCNL DCSP return a
def axhline(self, y=0, xmin=0, xmax=1, **kwargs): DCNL DCSP (ymin, ymax) = self.get_ybound() DCNL DCSP yy = self.convert_yunits(y) DCNL DCSP scaley = ((yy < ymin) or (yy > ymax)) DCNL DCSP trans = mtransforms.blended_transform_factory(self.transAxes, self.transData) DCNL DCSP l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs) DCNL DCSP l.x_isdata = False DCNL DCSP self.add_line(l) DCNL DCSP self.autoscale_view(scalex=False, scaley=scaley) DCNL DCSP return l
def axvline(self, x=0, ymin=0, ymax=1, **kwargs): DCNL DCSP (xmin, xmax) = self.get_xbound() DCNL DCSP xx = self.convert_xunits(x) DCNL DCSP scalex = ((xx < xmin) or (xx > xmax)) DCNL DCSP trans = mtransforms.blended_transform_factory(self.transData, self.transAxes) DCNL DCSP l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs) DCNL DCSP l.y_isdata = False DCNL DCSP self.add_line(l) DCNL DCSP self.autoscale_view(scalex=scalex, scaley=False) DCNL DCSP return l
def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs): DCNL DCSP trans = mtransforms.blended_transform_factory(self.transAxes, self.transData) DCNL DCSP self._process_unit_info([xmin, xmax], [ymin, ymax], kwargs=kwargs) DCNL DCSP (xmin, xmax) = self.convert_xunits([xmin, xmax]) DCNL DCSP (ymin, ymax) = self.convert_yunits([ymin, ymax]) DCNL DCSP verts = ((xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)) DCNL DCSP p = mpatches.Polygon(verts, **kwargs) DCNL DCSP p.set_transform(trans) DCNL DCSP p.x_isdata = False DCNL DCSP self.add_patch(p) DCNL DCSP return p
def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs): DCNL DCSP trans = mtransforms.blended_transform_factory(self.transData, self.transAxes) DCNL DCSP self._process_unit_info([xmin, xmax], [ymin, ymax], kwargs=kwargs) DCNL DCSP (xmin, xmax) = self.convert_xunits([xmin, xmax]) DCNL DCSP (ymin, ymax) = self.convert_yunits([ymin, ymax]) DCNL DCSP verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)] DCNL DCSP p = mpatches.Polygon(verts, **kwargs) DCNL DCSP p.set_transform(trans) DCNL DCSP p.y_isdata = False DCNL DCSP self.add_patch(p) DCNL DCSP return p
def hlines(self, y, xmin, xmax, colors='k', linestyles='solid', label='', **kwargs): DCNL DCSP if (kwargs.get('fmt') is not None): DCNL DCSP  DCSP raise DeprecationWarning('hlines DCSP now DCSP uses DCSP a DCSP collections.LineCollection DCSP and DCSP not DCSP a DCSP list DCSP of DCSP Line2D DCSP to DCSP draw; DCSP see DCSP API_CHANGES') DCNL DCSP y = self.convert_yunits(y) DCNL DCSP xmin = self.convert_xunits(xmin) DCNL DCSP xmax = self.convert_xunits(xmax) DCNL DCSP if (not iterable(y)): DCNL DCSP  DCSP y = [y] DCNL DCSP if (not iterable(xmin)): DCNL DCSP  DCSP xmin = [xmin] DCNL DCSP if (not iterable(xmax)): DCNL DCSP  DCSP xmax = [xmax] DCNL DCSP y = np.asarray(y) DCNL DCSP xmin = np.asarray(xmin) DCNL DCSP xmax = np.asarray(xmax) DCNL DCSP if (len(xmin) == 1): DCNL DCSP  DCSP xmin = np.resize(xmin, y.shape) DCNL DCSP if (len(xmax) == 1): DCNL DCSP  DCSP xmax = np.resize(xmax, y.shape) DCNL DCSP if (len(xmin) != len(y)): DCNL DCSP  DCSP raise ValueError, 'xmin DCSP and DCSP y DCSP are DCSP unequal DCSP sized DCSP sequences' DCNL DCSP if (len(xmax) != len(y)): DCNL DCSP  DCSP raise ValueError, 'xmax DCSP and DCSP y DCSP are DCSP unequal DCSP sized DCSP sequences' DCNL DCSP verts = [((thisxmin, thisy), (thisxmax, thisy)) for (thisxmin, thisxmax, thisy) in zip(xmin, xmax, y)] DCNL DCSP coll = mcoll.LineCollection(verts, colors=colors, linestyles=linestyles, label=label) DCNL DCSP self.add_collection(coll) DCNL DCSP coll.update(kwargs) DCNL DCSP minx = min(xmin.min(), xmax.min()) DCNL DCSP maxx = max(xmin.max(), xmax.max()) DCNL DCSP miny = y.min() DCNL DCSP maxy = y.max() DCNL DCSP corners = ((minx, miny), (maxx, maxy)) DCNL DCSP self.update_datalim(corners) DCNL DCSP self.autoscale_view() DCNL DCSP return coll
def vlines(self, x, ymin, ymax, colors='k', linestyles='solid', label='', **kwargs): DCNL DCSP if (kwargs.get('fmt') is not None): DCNL DCSP  DCSP raise DeprecationWarning('vlines DCSP now DCSP uses DCSP a DCSP collections.LineCollection DCSP and DCSP not DCSP a DCSP list DCSP of DCSP Line2D DCSP to DCSP draw; DCSP see DCSP API_CHANGES') DCNL DCSP self._process_unit_info(xdata=x, ydata=ymin, kwargs=kwargs) DCNL DCSP x = self.convert_xunits(x) DCNL DCSP ymin = self.convert_yunits(ymin) DCNL DCSP ymax = self.convert_yunits(ymax) DCNL DCSP if (not iterable(x)): DCNL DCSP  DCSP x = [x] DCNL DCSP if (not iterable(ymin)): DCNL DCSP  DCSP ymin = [ymin] DCNL DCSP if (not iterable(ymax)): DCNL DCSP  DCSP ymax = [ymax] DCNL DCSP x = np.asarray(x) DCNL DCSP ymin = np.asarray(ymin) DCNL DCSP ymax = np.asarray(ymax) DCNL DCSP if (len(ymin) == 1): DCNL DCSP  DCSP ymin = np.resize(ymin, x.shape) DCNL DCSP if (len(ymax) == 1): DCNL DCSP  DCSP ymax = np.resize(ymax, x.shape) DCNL DCSP if (len(ymin) != len(x)): DCNL DCSP  DCSP raise ValueError, 'ymin DCSP and DCSP x DCSP are DCSP unequal DCSP sized DCSP sequences' DCNL DCSP if (len(ymax) != len(x)): DCNL DCSP  DCSP raise ValueError, 'ymax DCSP and DCSP x DCSP are DCSP unequal DCSP sized DCSP sequences' DCNL DCSP Y = np.array([ymin, ymax]).T DCNL DCSP verts = [((thisx, thisymin), (thisx, thisymax)) for (thisx, (thisymin, thisymax)) in zip(x, Y)] DCNL DCSP coll = mcoll.LineCollection(verts, colors=colors, linestyles=linestyles, label=label) DCNL DCSP self.add_collection(coll) DCNL DCSP coll.update(kwargs) DCNL DCSP minx = min(x) DCNL DCSP maxx = max(x) DCNL DCSP miny = min(min(ymin), min(ymax)) DCNL DCSP maxy = max(max(ymin), max(ymax)) DCNL DCSP corners = ((minx, miny), (maxx, maxy)) DCNL DCSP self.update_datalim(corners) DCNL DCSP self.autoscale_view() DCNL DCSP return coll
def plot(self, *args, **kwargs): DCNL DCSP scalex = kwargs.pop('scalex', True) DCNL DCSP scaley = kwargs.pop('scaley', True) DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP lines = [] DCNL DCSP for line in self._get_lines(*args, **kwargs): DCNL DCSP  DCSP self.add_line(line) DCNL DCSP  DCSP lines.append(line) DCNL DCSP self.autoscale_view(scalex=scalex, scaley=scaley) DCNL DCSP return lines
def plot_date(self, x, y, fmt='bo', tz=None, xdate=True, ydate=False, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP ret = self.plot(x, y, fmt, **kwargs) DCNL DCSP if xdate: DCNL DCSP  DCSP self.xaxis_date(tz) DCNL DCSP if ydate: DCNL DCSP  DCSP self.yaxis_date(tz) DCNL DCSP self.autoscale_view() DCNL DCSP return ret
def loglog(self, *args, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP dx = {'basex': kwargs.pop('basex', 10), 'subsx': kwargs.pop('subsx', None)} DCNL DCSP dy = {'basey': kwargs.pop('basey', 10), 'subsy': kwargs.pop('subsy', None)} DCNL DCSP self.set_xscale('log', **dx) DCNL DCSP self.set_yscale('log', **dy) DCNL DCSP b = self._hold DCNL DCSP self._hold = True DCNL DCSP l = self.plot(*args, **kwargs) DCNL DCSP self._hold = b DCNL DCSP return l
def semilogx(self, *args, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP d = {'basex': kwargs.pop('basex', 10), 'subsx': kwargs.pop('subsx', None)} DCNL DCSP self.set_xscale('log', **d) DCNL DCSP b = self._hold DCNL DCSP self._hold = True DCNL DCSP l = self.plot(*args, **kwargs) DCNL DCSP self._hold = b DCNL DCSP return l
def semilogy(self, *args, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP d = {'basey': kwargs.pop('basey', 10), 'subsy': kwargs.pop('subsy', None)} DCNL DCSP self.set_yscale('log', **d) DCNL DCSP b = self._hold DCNL DCSP self._hold = True DCNL DCSP l = self.plot(*args, **kwargs) DCNL DCSP self._hold = b DCNL DCSP return l
def acorr(self, x, **kwargs): DCNL DCSP return self.xcorr(x, x, **kwargs)
def xcorr(self, x, y, normed=False, detrend=mlab.detrend_none, usevlines=False, maxlags=None, **kwargs): DCNL DCSP Nx = len(x) DCNL DCSP if (Nx != len(y)): DCNL DCSP  DCSP raise ValueError('x DCSP and DCSP y DCSP must DCSP be DCSP equal DCSP length') DCNL DCSP x = detrend(np.asarray(x)) DCNL DCSP y = detrend(np.asarray(y)) DCNL DCSP c = np.correlate(x, y, mode=2) DCNL DCSP if normed: DCNL DCSP  DCSP c /= np.sqrt((np.dot(x, x) * np.dot(y, y))) DCNL DCSP if (maxlags is None): DCNL DCSP  DCSP maxlags = (Nx - 1) DCNL DCSP if ((maxlags >= Nx) or (maxlags < 1)): DCNL DCSP  DCSP raise ValueError(('maglags DCSP must DCSP be DCSP None DCSP or DCSP strictly DCSP positive DCSP < DCSP %d' % Nx)) DCNL DCSP lags = np.arange((- maxlags), (maxlags + 1)) DCNL DCSP c = c[((Nx - 1) - maxlags):(Nx + maxlags)] DCNL DCSP if usevlines: DCNL DCSP  DCSP a = self.vlines(lags, [0], c, **kwargs) DCNL DCSP  DCSP b = self.axhline(**kwargs) DCNL DCSP else: DCNL DCSP  DCSP kwargs.setdefault('marker', 'o') DCNL DCSP  DCSP kwargs.setdefault('linestyle', 'None') DCNL DCSP  DCSP (a,) = self.plot(lags, c, **kwargs) DCNL DCSP  DCSP b = None DCNL DCSP return (lags, c, a, b)
def legend(self, *args, **kwargs): DCNL DCSP def get_handles(): DCNL DCSP  DCSP handles = self.lines[:] DCNL DCSP  DCSP handles.extend(self.patches) DCNL DCSP  DCSP handles.extend([c for c in self.collections if isinstance(c, mcoll.LineCollection)]) DCNL DCSP  DCSP handles.extend([c for c in self.collections if isinstance(c, mcoll.RegularPolyCollection)]) DCNL DCSP  DCSP return handles DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP handles = [] DCNL DCSP  DCSP labels = [] DCNL DCSP  DCSP for handle in get_handles(): DCNL DCSP  DCSP  DCSP label = handle.get_label() DCNL DCSP  DCSP  DCSP if ((label is not None) and (label != '') and (not label.startswith('_'))): DCNL DCSP  DCSP  DCSP  DCSP handles.append(handle) DCNL DCSP  DCSP  DCSP  DCSP labels.append(label) DCNL DCSP  DCSP if (len(handles) == 0): DCNL DCSP  DCSP  DCSP warnings.warn("No DCSP labeled DCSP objects DCSP found. DCSP Use DCSP label='...' DCSP kwarg DCSP on DCSP individual DCSP plots.") DCNL DCSP  DCSP  DCSP return None DCNL DCSP elif (len(args) == 1): DCNL DCSP  DCSP labels = args[0] DCNL DCSP  DCSP handles = [h for (h, label) in zip(get_handles(), labels)] DCNL DCSP elif (len(args) == 2): DCNL DCSP  DCSP if (is_string_like(args[1]) or isinstance(args[1], int)): DCNL DCSP  DCSP  DCSP (labels, loc) = args DCNL DCSP  DCSP  DCSP handles = [h for (h, label) in zip(get_handles(), labels)] DCNL DCSP  DCSP  DCSP kwargs['loc'] = loc DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (handles, labels) = args DCNL DCSP elif (len(args) == 3): DCNL DCSP  DCSP (handles, labels, loc) = args DCNL DCSP  DCSP kwargs['loc'] = loc DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Invalid DCSP arguments DCSP to DCSP legend') DCNL DCSP handles = cbook.flatten(handles) DCNL DCSP self.legend_ = mlegend.Legend(self, handles, labels, **kwargs) DCNL DCSP return self.legend_
def step(self, x, y, *args, **kwargs): DCNL DCSP where = kwargs.pop('where', 'pre') DCNL DCSP if (where not in ('pre', 'post', 'mid')): DCNL DCSP  DCSP raise ValueError("'where' DCSP argument DCSP to DCSP step DCSP must DCSP be DCSP 'pre', DCSP 'post' DCSP or DCSP 'mid'") DCNL DCSP kwargs['linestyle'] = ('steps-' + where) DCNL DCSP return self.plot(x, y, *args, **kwargs)
def bar(self, left, height, width=0.8, bottom=None, color=None, edgecolor=None, linewidth=None, yerr=None, xerr=None, ecolor=None, capsize=3, align='edge', orientation='vertical', log=False, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP label = kwargs.pop('label', '') DCNL DCSP def make_iterable(x): DCNL DCSP  DCSP if (not iterable(x)): DCNL DCSP  DCSP  DCSP return [x] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return x DCNL DCSP _left = left DCNL DCSP left = make_iterable(left) DCNL DCSP height = make_iterable(height) DCNL DCSP width = make_iterable(width) DCNL DCSP _bottom = bottom DCNL DCSP bottom = make_iterable(bottom) DCNL DCSP linewidth = make_iterable(linewidth) DCNL DCSP adjust_ylim = False DCNL DCSP adjust_xlim = False DCNL DCSP if (orientation == 'vertical'): DCNL DCSP  DCSP self._process_unit_info(xdata=left, ydata=height, kwargs=kwargs) DCNL DCSP  DCSP if log: DCNL DCSP  DCSP  DCSP self.set_yscale('log') DCNL DCSP  DCSP if (_bottom is None): DCNL DCSP  DCSP  DCSP if (self.get_yscale() == 'log'): DCNL DCSP  DCSP  DCSP  DCSP bottom = [1e-100] DCNL DCSP  DCSP  DCSP  DCSP adjust_ylim = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP bottom = [0] DCNL DCSP  DCSP nbars = len(left) DCNL DCSP  DCSP if (len(width) == 1): DCNL DCSP  DCSP  DCSP width *= nbars DCNL DCSP  DCSP if (len(bottom) == 1): DCNL DCSP  DCSP  DCSP bottom *= nbars DCNL DCSP elif (orientation == 'horizontal'): DCNL DCSP  DCSP self._process_unit_info(xdata=width, ydata=bottom, kwargs=kwargs) DCNL DCSP  DCSP if log: DCNL DCSP  DCSP  DCSP self.set_xscale('log') DCNL DCSP  DCSP if (_left is None): DCNL DCSP  DCSP  DCSP if (self.get_xscale() == 'log'): DCNL DCSP  DCSP  DCSP  DCSP left = [1e-100] DCNL DCSP  DCSP  DCSP  DCSP adjust_xlim = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP left = [0] DCNL DCSP  DCSP nbars = len(bottom) DCNL DCSP  DCSP if (len(left) == 1): DCNL DCSP  DCSP  DCSP left *= nbars DCNL DCSP  DCSP if (len(height) == 1): DCNL DCSP  DCSP  DCSP height *= nbars DCNL DCSP else: DCNL DCSP  DCSP raise ValueError, ('invalid DCSP orientation: DCSP %s' % orientation) DCNL DCSP if (len(linewidth) < nbars): DCNL DCSP  DCSP linewidth *= nbars DCNL DCSP if (color is None): DCNL DCSP  DCSP color = ([None] * nbars) DCNL DCSP else: DCNL DCSP  DCSP color = list(mcolors.colorConverter.to_rgba_array(color)) DCNL DCSP  DCSP if (len(color) < nbars): DCNL DCSP  DCSP  DCSP color *= nbars DCNL DCSP if (edgecolor is None): DCNL DCSP  DCSP edgecolor = ([None] * nbars) DCNL DCSP else: DCNL DCSP  DCSP edgecolor = list(mcolors.colorConverter.to_rgba_array(edgecolor)) DCNL DCSP  DCSP if (len(edgecolor) < nbars): DCNL DCSP  DCSP  DCSP edgecolor *= nbars DCNL DCSP if (yerr is not None): DCNL DCSP  DCSP if (not iterable(yerr)): DCNL DCSP  DCSP  DCSP yerr = ([yerr] * nbars) DCNL DCSP if (xerr is not None): DCNL DCSP  DCSP if (not iterable(xerr)): DCNL DCSP  DCSP  DCSP xerr = ([xerr] * nbars) DCNL DCSP assert (len(left) == nbars), ("argument DCSP 'left' DCSP must DCSP be DCSP %d DCSP or DCSP scalar" % nbars) DCNL DCSP assert (len(height) == nbars), ("argument DCSP 'height' DCSP must DCSP be DCSP %d DCSP or DCSP scalar" % nbars) DCNL DCSP assert (len(width) == nbars), ("argument DCSP 'width' DCSP must DCSP be DCSP %d DCSP or DCSP scalar" % nbars) DCNL DCSP assert (len(bottom) == nbars), ("argument DCSP 'bottom' DCSP must DCSP be DCSP %d DCSP or DCSP scalar" % nbars) DCNL DCSP if ((yerr is not None) and (len(yerr) != nbars)): DCNL DCSP  DCSP raise ValueError(("bar() DCSP argument DCSP 'yerr' DCSP must DCSP be DCSP len(%s) DCSP or DCSP scalar" % nbars)) DCNL DCSP if ((xerr is not None) and (len(xerr) != nbars)): DCNL DCSP  DCSP raise ValueError(("bar() DCSP argument DCSP 'xerr' DCSP must DCSP be DCSP len(%s) DCSP or DCSP scalar" % nbars)) DCNL DCSP patches = [] DCNL DCSP if (self.xaxis is not None): DCNL DCSP  DCSP xconv = self.xaxis.converter DCNL DCSP  DCSP if (xconv is not None): DCNL DCSP  DCSP  DCSP units = self.xaxis.get_units() DCNL DCSP  DCSP  DCSP left = xconv.convert(left, units) DCNL DCSP  DCSP  DCSP width = xconv.convert(width, units) DCNL DCSP if (self.yaxis is not None): DCNL DCSP  DCSP yconv = self.yaxis.converter DCNL DCSP  DCSP if (yconv is not None): DCNL DCSP  DCSP  DCSP units = self.yaxis.get_units() DCNL DCSP  DCSP  DCSP bottom = yconv.convert(bottom, units) DCNL DCSP  DCSP  DCSP height = yconv.convert(height, units) DCNL DCSP if (align == 'edge'): DCNL DCSP  DCSP pass DCNL DCSP elif (align == 'center'): DCNL DCSP  DCSP if (orientation == 'vertical'): DCNL DCSP  DCSP  DCSP left = [(left[i] - (width[i] / 2.0)) for i in xrange(len(left))] DCNL DCSP  DCSP elif (orientation == 'horizontal'): DCNL DCSP  DCSP  DCSP bottom = [(bottom[i] - (height[i] / 2.0)) for i in xrange(len(bottom))] DCNL DCSP else: DCNL DCSP  DCSP raise ValueError, ('invalid DCSP alignment: DCSP %s' % align) DCNL DCSP args = zip(left, bottom, width, height, color, edgecolor, linewidth) DCNL DCSP for (l, b, w, h, c, e, lw) in args: DCNL DCSP  DCSP if (h < 0): DCNL DCSP  DCSP  DCSP b += h DCNL DCSP  DCSP  DCSP h = abs(h) DCNL DCSP  DCSP if (w < 0): DCNL DCSP  DCSP  DCSP l += w DCNL DCSP  DCSP  DCSP w = abs(w) DCNL DCSP  DCSP r = mpatches.Rectangle(xy=(l, b), width=w, height=h, facecolor=c, edgecolor=e, linewidth=lw, label=label) DCNL DCSP  DCSP label = '_nolegend_' DCNL DCSP  DCSP r.update(kwargs) DCNL DCSP  DCSP self.add_patch(r) DCNL DCSP  DCSP patches.append(r) DCNL DCSP holdstate = self._hold DCNL DCSP self.hold(True) DCNL DCSP if ((xerr is not None) or (yerr is not None)): DCNL DCSP  DCSP if (orientation == 'vertical'): DCNL DCSP  DCSP  DCSP x = [(l + (0.5 * w)) for (l, w) in zip(left, width)] DCNL DCSP  DCSP  DCSP y = [(b + h) for (b, h) in zip(bottom, height)] DCNL DCSP  DCSP elif (orientation == 'horizontal'): DCNL DCSP  DCSP  DCSP x = [(l + w) for (l, w) in zip(left, width)] DCNL DCSP  DCSP  DCSP y = [(b + (0.5 * h)) for (b, h) in zip(bottom, height)] DCNL DCSP  DCSP self.errorbar(x, y, yerr=yerr, xerr=xerr, fmt=None, ecolor=ecolor, capsize=capsize) DCNL DCSP self.hold(holdstate) DCNL DCSP if adjust_xlim: DCNL DCSP  DCSP (xmin, xmax) = self.dataLim.intervalx DCNL DCSP  DCSP xmin = np.amin(width[(width != 0)]) DCNL DCSP  DCSP if (xerr is not None): DCNL DCSP  DCSP  DCSP xmin = (xmin - np.amax(xerr)) DCNL DCSP  DCSP xmin = max((xmin * 0.9), 1e-100) DCNL DCSP  DCSP self.dataLim.intervalx = (xmin, xmax) DCNL DCSP if adjust_ylim: DCNL DCSP  DCSP (ymin, ymax) = self.dataLim.intervaly DCNL DCSP  DCSP ymin = np.amin(height[(height != 0)]) DCNL DCSP  DCSP if (yerr is not None): DCNL DCSP  DCSP  DCSP ymin = (ymin - np.amax(yerr)) DCNL DCSP  DCSP ymin = max((ymin * 0.9), 1e-100) DCNL DCSP  DCSP self.dataLim.intervaly = (ymin, ymax) DCNL DCSP self.autoscale_view() DCNL DCSP return patches
def barh(self, bottom, width, height=0.8, left=None, **kwargs): DCNL DCSP patches = self.bar(left=left, height=height, width=width, bottom=bottom, orientation='horizontal', **kwargs) DCNL DCSP return patches
def broken_barh(self, xranges, yrange, **kwargs): DCNL DCSP col = mcoll.BrokenBarHCollection(xranges, yrange, **kwargs) DCNL DCSP self.add_collection(col, autolim=True) DCNL DCSP self.autoscale_view() DCNL DCSP return col
def stem(self, x, y, linefmt='b-', markerfmt='bo', basefmt='r-'): DCNL DCSP remember_hold = self._hold DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP self.hold(True) DCNL DCSP (markerline,) = self.plot(x, y, markerfmt) DCNL DCSP stemlines = [] DCNL DCSP for (thisx, thisy) in zip(x, y): DCNL DCSP  DCSP (l,) = self.plot([thisx, thisx], [0, thisy], linefmt) DCNL DCSP  DCSP stemlines.append(l) DCNL DCSP (baseline,) = self.plot([np.amin(x), np.amax(x)], [0, 0], basefmt) DCNL DCSP self.hold(remember_hold) DCNL DCSP return (markerline, stemlines, baseline)
def pie(self, x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1): DCNL DCSP self.set_frame_on(False) DCNL DCSP x = np.asarray(x).astype(np.float32) DCNL DCSP sx = float(x.sum()) DCNL DCSP if (sx > 1): DCNL DCSP  DCSP x = np.divide(x, sx) DCNL DCSP if (labels is None): DCNL DCSP  DCSP labels = ([''] * len(x)) DCNL DCSP if (explode is None): DCNL DCSP  DCSP explode = ([0] * len(x)) DCNL DCSP assert (len(x) == len(labels)) DCNL DCSP assert (len(x) == len(explode)) DCNL DCSP if (colors is None): DCNL DCSP  DCSP colors = ('b', 'g', 'r', 'c', 'm', 'y', 'k', 'w') DCNL DCSP center = (0, 0) DCNL DCSP radius = 1 DCNL DCSP theta1 = 0 DCNL DCSP i = 0 DCNL DCSP texts = [] DCNL DCSP slices = [] DCNL DCSP autotexts = [] DCNL DCSP for (frac, label, expl) in cbook.safezip(x, labels, explode): DCNL DCSP  DCSP (x, y) = center DCNL DCSP  DCSP theta2 = (theta1 + frac) DCNL DCSP  DCSP thetam = (((2 * math.pi) * 0.5) * (theta1 + theta2)) DCNL DCSP  DCSP x += (expl * math.cos(thetam)) DCNL DCSP  DCSP y += (expl * math.sin(thetam)) DCNL DCSP  DCSP w = mpatches.Wedge((x, y), radius, (360.0 * theta1), (360.0 * theta2), facecolor=colors[(i % len(colors))]) DCNL DCSP  DCSP slices.append(w) DCNL DCSP  DCSP self.add_patch(w) DCNL DCSP  DCSP w.set_label(label) DCNL DCSP  DCSP if shadow: DCNL DCSP  DCSP  DCSP shad = mpatches.Shadow(w, (-0.02), (-0.02)) DCNL DCSP  DCSP  DCSP shad.set_zorder((0.9 * w.get_zorder())) DCNL DCSP  DCSP  DCSP self.add_patch(shad) DCNL DCSP  DCSP xt = (x + ((labeldistance * radius) * math.cos(thetam))) DCNL DCSP  DCSP yt = (y + ((labeldistance * radius) * math.sin(thetam))) DCNL DCSP  DCSP label_alignment = (((xt > 0) and 'left') or 'right') DCNL DCSP  DCSP t = self.text(xt, yt, label, size=rcParams['xtick.labelsize'], horizontalalignment=label_alignment, verticalalignment='center') DCNL DCSP  DCSP texts.append(t) DCNL DCSP  DCSP if (autopct is not None): DCNL DCSP  DCSP  DCSP xt = (x + ((pctdistance * radius) * math.cos(thetam))) DCNL DCSP  DCSP  DCSP yt = (y + ((pctdistance * radius) * math.sin(thetam))) DCNL DCSP  DCSP  DCSP if is_string_like(autopct): DCNL DCSP  DCSP  DCSP  DCSP s = (autopct % (100.0 * frac)) DCNL DCSP  DCSP  DCSP elif callable(autopct): DCNL DCSP  DCSP  DCSP  DCSP s = autopct((100.0 * frac)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise TypeError('autopct DCSP must DCSP be DCSP callable DCSP or DCSP a DCSP format DCSP string') DCNL DCSP  DCSP  DCSP t = self.text(xt, yt, s, horizontalalignment='center', verticalalignment='center') DCNL DCSP  DCSP  DCSP autotexts.append(t) DCNL DCSP  DCSP theta1 = theta2 DCNL DCSP  DCSP i += 1 DCNL DCSP self.set_xlim(((-1.25), 1.25)) DCNL DCSP self.set_ylim(((-1.25), 1.25)) DCNL DCSP self.set_xticks([]) DCNL DCSP self.set_yticks([]) DCNL DCSP if (autopct is None): DCNL DCSP  DCSP return (slices, texts) DCNL DCSP else: DCNL DCSP  DCSP return (slices, texts, autotexts)
def errorbar(self, x, y, yerr=None, xerr=None, fmt='-', ecolor=None, elinewidth=None, capsize=3, barsabove=False, lolims=False, uplims=False, xlolims=False, xuplims=False, **kwargs): DCNL DCSP self._process_unit_info(xdata=x, ydata=y, kwargs=kwargs) DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP if (not iterable(x)): DCNL DCSP  DCSP x = [x] DCNL DCSP if (not iterable(y)): DCNL DCSP  DCSP y = [y] DCNL DCSP if (xerr is not None): DCNL DCSP  DCSP if (not iterable(xerr)): DCNL DCSP  DCSP  DCSP xerr = ([xerr] * len(x)) DCNL DCSP if (yerr is not None): DCNL DCSP  DCSP if (not iterable(yerr)): DCNL DCSP  DCSP  DCSP yerr = ([yerr] * len(y)) DCNL DCSP l0 = None DCNL DCSP if (barsabove and (fmt is not None)): DCNL DCSP  DCSP (l0,) = self.plot(x, y, fmt, **kwargs) DCNL DCSP barcols = [] DCNL DCSP caplines = [] DCNL DCSP lines_kw = {'label': '_nolegend_'} DCNL DCSP if elinewidth: DCNL DCSP  DCSP lines_kw['linewidth'] = elinewidth DCNL DCSP else: DCNL DCSP  DCSP if ('linewidth' in kwargs): DCNL DCSP  DCSP  DCSP lines_kw['linewidth'] = kwargs['linewidth'] DCNL DCSP  DCSP if ('lw' in kwargs): DCNL DCSP  DCSP  DCSP lines_kw['lw'] = kwargs['lw'] DCNL DCSP if ('transform' in kwargs): DCNL DCSP  DCSP lines_kw['transform'] = kwargs['transform'] DCNL DCSP if (not iterable(lolims)): DCNL DCSP  DCSP lolims = np.asarray(([lolims] * len(x)), bool) DCNL DCSP else: DCNL DCSP  DCSP lolims = np.asarray(lolims, bool) DCNL DCSP if (not iterable(uplims)): DCNL DCSP  DCSP uplims = np.array(([uplims] * len(x)), bool) DCNL DCSP else: DCNL DCSP  DCSP uplims = np.asarray(uplims, bool) DCNL DCSP if (not iterable(xlolims)): DCNL DCSP  DCSP xlolims = np.array(([xlolims] * len(x)), bool) DCNL DCSP else: DCNL DCSP  DCSP xlolims = np.asarray(xlolims, bool) DCNL DCSP if (not iterable(xuplims)): DCNL DCSP  DCSP xuplims = np.array(([xuplims] * len(x)), bool) DCNL DCSP else: DCNL DCSP  DCSP xuplims = np.asarray(xuplims, bool) DCNL DCSP def xywhere(xs, ys, mask): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCSP xs[mask], DCSP ys[mask] DCSP where DCSP mask DCSP is DCSP True DCSP but DCSP xs DCSP and\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ys DCSP are DCSP not DCSP arrays\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP assert (len(xs) == len(ys)) DCNL DCSP  DCSP assert (len(xs) == len(mask)) DCNL DCSP  DCSP xs = [thisx for (thisx, b) in zip(xs, mask) if b] DCNL DCSP  DCSP ys = [thisy for (thisy, b) in zip(ys, mask) if b] DCNL DCSP  DCSP return (xs, ys) DCNL DCSP if (capsize > 0): DCNL DCSP  DCSP plot_kw = {'ms': (2 * capsize), 'label': '_nolegend_'} DCNL DCSP  DCSP if ('markeredgewidth' in kwargs): DCNL DCSP  DCSP  DCSP plot_kw['markeredgewidth'] = kwargs['markeredgewidth'] DCNL DCSP  DCSP if ('mew' in kwargs): DCNL DCSP  DCSP  DCSP plot_kw['mew'] = kwargs['mew'] DCNL DCSP  DCSP if ('transform' in kwargs): DCNL DCSP  DCSP  DCSP plot_kw['transform'] = kwargs['transform'] DCNL DCSP if (xerr is not None): DCNL DCSP  DCSP if (iterable(xerr) and (len(xerr) == 2) and iterable(xerr[0]) and iterable(xerr[1])): DCNL DCSP  DCSP  DCSP left = [(thisx - thiserr) for (thisx, thiserr) in cbook.safezip(x, xerr[0])] DCNL DCSP  DCSP  DCSP right = [(thisx + thiserr) for (thisx, thiserr) in cbook.safezip(x, xerr[1])] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP left = [(thisx - thiserr) for (thisx, thiserr) in cbook.safezip(x, xerr)] DCNL DCSP  DCSP  DCSP right = [(thisx + thiserr) for (thisx, thiserr) in cbook.safezip(x, xerr)] DCNL DCSP  DCSP barcols.append(self.hlines(y, left, right, **lines_kw)) DCNL DCSP  DCSP if (capsize > 0): DCNL DCSP  DCSP  DCSP if xlolims.any(): DCNL DCSP  DCSP  DCSP  DCSP (leftlo, ylo) = xywhere(left, y, xlolims) DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(leftlo, ylo, ls='None', marker=mlines.CARETLEFT, **plot_kw)) DCNL DCSP  DCSP  DCSP  DCSP xlolims = (~ xlolims) DCNL DCSP  DCSP  DCSP  DCSP (leftlo, ylo) = xywhere(left, y, xlolims) DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(leftlo, ylo, 'k|', **plot_kw)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(left, y, 'k|', **plot_kw)) DCNL DCSP  DCSP  DCSP if xuplims.any(): DCNL DCSP  DCSP  DCSP  DCSP (rightup, yup) = xywhere(right, y, xuplims) DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(rightup, yup, ls='None', marker=mlines.CARETRIGHT, **plot_kw)) DCNL DCSP  DCSP  DCSP  DCSP xuplims = (~ xuplims) DCNL DCSP  DCSP  DCSP  DCSP (rightup, yup) = xywhere(right, y, xuplims) DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(rightup, yup, 'k|', **plot_kw)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(right, y, 'k|', **plot_kw)) DCNL DCSP if (yerr is not None): DCNL DCSP  DCSP if (iterable(yerr) and (len(yerr) == 2) and iterable(yerr[0]) and iterable(yerr[1])): DCNL DCSP  DCSP  DCSP lower = [(thisy - thiserr) for (thisy, thiserr) in cbook.safezip(y, yerr[0])] DCNL DCSP  DCSP  DCSP upper = [(thisy + thiserr) for (thisy, thiserr) in cbook.safezip(y, yerr[1])] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lower = [(thisy - thiserr) for (thisy, thiserr) in cbook.safezip(y, yerr)] DCNL DCSP  DCSP  DCSP upper = [(thisy + thiserr) for (thisy, thiserr) in cbook.safezip(y, yerr)] DCNL DCSP  DCSP barcols.append(self.vlines(x, lower, upper, **lines_kw)) DCNL DCSP  DCSP if (capsize > 0): DCNL DCSP  DCSP  DCSP if lolims.any(): DCNL DCSP  DCSP  DCSP  DCSP (xlo, lowerlo) = xywhere(x, lower, lolims) DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(xlo, lowerlo, ls='None', marker=mlines.CARETDOWN, **plot_kw)) DCNL DCSP  DCSP  DCSP  DCSP lolims = (~ lolims) DCNL DCSP  DCSP  DCSP  DCSP (xlo, lowerlo) = xywhere(x, lower, lolims) DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(xlo, lowerlo, 'k_', **plot_kw)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(x, lower, 'k_', **plot_kw)) DCNL DCSP  DCSP  DCSP if uplims.any(): DCNL DCSP  DCSP  DCSP  DCSP (xup, upperup) = xywhere(x, upper, uplims) DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(xup, upperup, ls='None', marker=mlines.CARETUP, **plot_kw)) DCNL DCSP  DCSP  DCSP  DCSP uplims = (~ uplims) DCNL DCSP  DCSP  DCSP  DCSP (xup, upperup) = xywhere(x, upper, uplims) DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(xup, upperup, 'k_', **plot_kw)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP caplines.extend(self.plot(x, upper, 'k_', **plot_kw)) DCNL DCSP if ((not barsabove) and (fmt is not None)): DCNL DCSP  DCSP (l0,) = self.plot(x, y, fmt, **kwargs) DCNL DCSP if (ecolor is None): DCNL DCSP  DCSP if (l0 is None): DCNL DCSP  DCSP  DCSP ecolor = self._get_lines._get_next_cycle_color() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ecolor = l0.get_color() DCNL DCSP for l in barcols: DCNL DCSP  DCSP l.set_color(ecolor) DCNL DCSP for l in caplines: DCNL DCSP  DCSP l.set_color(ecolor) DCNL DCSP self.autoscale_view() DCNL DCSP return (l0, caplines, barcols)
def boxplot(self, x, notch=0, sym='b+', vert=1, whis=1.5, positions=None, widths=None): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP holdStatus = self._hold DCNL DCSP (whiskers, caps, boxes, medians, fliers) = ([], [], [], [], []) DCNL DCSP if hasattr(x, 'shape'): DCNL DCSP  DCSP if (len(x.shape) == 1): DCNL DCSP  DCSP  DCSP if hasattr(x[0], 'shape'): DCNL DCSP  DCSP  DCSP  DCSP x = list(x) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP x = [x] DCNL DCSP  DCSP elif (len(x.shape) == 2): DCNL DCSP  DCSP  DCSP (nr, nc) = x.shape DCNL DCSP  DCSP  DCSP if (nr == 1): DCNL DCSP  DCSP  DCSP  DCSP x = [x] DCNL DCSP  DCSP  DCSP elif (nc == 1): DCNL DCSP  DCSP  DCSP  DCSP x = [x.ravel()] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP x = [x[:, i] for i in xrange(nc)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError, 'input DCSP x DCSP can DCSP have DCSP no DCSP more DCSP than DCSP 2 DCSP dimensions' DCNL DCSP if (not hasattr(x[0], '__len__')): DCNL DCSP  DCSP x = [x] DCNL DCSP col = len(x) DCNL DCSP if (positions is None): DCNL DCSP  DCSP positions = range(1, (col + 1)) DCNL DCSP if (widths is None): DCNL DCSP  DCSP distance = (max(positions) - min(positions)) DCNL DCSP  DCSP widths = min((0.15 * max(distance, 1.0)), 0.5) DCNL DCSP if (isinstance(widths, float) or isinstance(widths, int)): DCNL DCSP  DCSP widths = (np.ones((col,), float) * widths) DCNL DCSP self.hold(True) DCNL DCSP for (i, pos) in enumerate(positions): DCNL DCSP  DCSP d = np.ravel(x[i]) DCNL DCSP  DCSP row = len(d) DCNL DCSP  DCSP (q1, med, q3) = mlab.prctile(d, [25, 50, 75]) DCNL DCSP  DCSP iq = (q3 - q1) DCNL DCSP  DCSP hi_val = (q3 + (whis * iq)) DCNL DCSP  DCSP wisk_hi = np.compress((d <= hi_val), d) DCNL DCSP  DCSP if (len(wisk_hi) == 0): DCNL DCSP  DCSP  DCSP wisk_hi = q3 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP wisk_hi = max(wisk_hi) DCNL DCSP  DCSP lo_val = (q1 - (whis * iq)) DCNL DCSP  DCSP wisk_lo = np.compress((d >= lo_val), d) DCNL DCSP  DCSP if (len(wisk_lo) == 0): DCNL DCSP  DCSP  DCSP wisk_lo = q1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP wisk_lo = min(wisk_lo) DCNL DCSP  DCSP flier_hi = [] DCNL DCSP  DCSP flier_lo = [] DCNL DCSP  DCSP flier_hi_x = [] DCNL DCSP  DCSP flier_lo_x = [] DCNL DCSP  DCSP if (len(sym) != 0): DCNL DCSP  DCSP  DCSP flier_hi = np.compress((d > wisk_hi), d) DCNL DCSP  DCSP  DCSP flier_lo = np.compress((d < wisk_lo), d) DCNL DCSP  DCSP  DCSP flier_hi_x = (np.ones(flier_hi.shape[0]) * pos) DCNL DCSP  DCSP  DCSP flier_lo_x = (np.ones(flier_lo.shape[0]) * pos) DCNL DCSP  DCSP box_x_min = (pos - (widths[i] * 0.5)) DCNL DCSP  DCSP box_x_max = (pos + (widths[i] * 0.5)) DCNL DCSP  DCSP wisk_x = (np.ones(2) * pos) DCNL DCSP  DCSP cap_x_min = (pos - (widths[i] * 0.25)) DCNL DCSP  DCSP cap_x_max = (pos + (widths[i] * 0.25)) DCNL DCSP  DCSP cap_x = [cap_x_min, cap_x_max] DCNL DCSP  DCSP med_y = [med, med] DCNL DCSP  DCSP if (notch == 0): DCNL DCSP  DCSP  DCSP box_x = [box_x_min, box_x_max, box_x_max, box_x_min, box_x_min] DCNL DCSP  DCSP  DCSP box_y = [q1, q1, q3, q3, q1] DCNL DCSP  DCSP  DCSP med_x = [box_x_min, box_x_max] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP notch_max = (med + ((1.57 * iq) / np.sqrt(row))) DCNL DCSP  DCSP  DCSP notch_min = (med - ((1.57 * iq) / np.sqrt(row))) DCNL DCSP  DCSP  DCSP if (notch_max > q3): DCNL DCSP  DCSP  DCSP  DCSP notch_max = q3 DCNL DCSP  DCSP  DCSP if (notch_min < q1): DCNL DCSP  DCSP  DCSP  DCSP notch_min = q1 DCNL DCSP  DCSP  DCSP box_x = [box_x_min, box_x_max, box_x_max, cap_x_max, box_x_max, box_x_max, box_x_min, box_x_min, cap_x_min, box_x_min, box_x_min] DCNL DCSP  DCSP  DCSP box_y = [q1, q1, notch_min, med, notch_max, q3, q3, notch_max, med, notch_min, q1] DCNL DCSP  DCSP  DCSP med_x = [cap_x_min, cap_x_max] DCNL DCSP  DCSP  DCSP med_y = [med, med] DCNL DCSP  DCSP if vert: DCNL DCSP  DCSP  DCSP def doplot(*args): DCNL DCSP  DCSP  DCSP  DCSP return self.plot(*args) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP def doplot(*args): DCNL DCSP  DCSP  DCSP  DCSP shuffled = [] DCNL DCSP  DCSP  DCSP  DCSP for i in xrange(0, len(args), 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP shuffled.extend([args[(i + 1)], args[i], args[(i + 2)]]) DCNL DCSP  DCSP  DCSP  DCSP return self.plot(*shuffled) DCNL DCSP  DCSP whiskers.extend(doplot(wisk_x, [q1, wisk_lo], 'b--', wisk_x, [q3, wisk_hi], 'b--')) DCNL DCSP  DCSP caps.extend(doplot(cap_x, [wisk_hi, wisk_hi], 'k-', cap_x, [wisk_lo, wisk_lo], 'k-')) DCNL DCSP  DCSP boxes.extend(doplot(box_x, box_y, 'b-')) DCNL DCSP  DCSP medians.extend(doplot(med_x, med_y, 'r-')) DCNL DCSP  DCSP fliers.extend(doplot(flier_hi_x, flier_hi, sym, flier_lo_x, flier_lo, sym)) DCNL DCSP if (1 == vert): DCNL DCSP  DCSP (setticks, setlim) = (self.set_xticks, self.set_xlim) DCNL DCSP else: DCNL DCSP  DCSP (setticks, setlim) = (self.set_yticks, self.set_ylim) DCNL DCSP newlimits = ((min(positions) - 0.5), (max(positions) + 0.5)) DCNL DCSP setlim(newlimits) DCNL DCSP setticks(positions) DCNL DCSP self.hold(holdStatus) DCNL DCSP return dict(whiskers=whiskers, caps=caps, boxes=boxes, medians=medians, fliers=fliers)
def scatter(self, x, y, s=20, c='b', marker='o', cmap=None, norm=None, vmin=None, vmax=None, alpha=1.0, linewidths=None, faceted=True, verts=None, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP syms = {'s': (4, (math.pi / 4.0), 0), 'o': (20, 3, 0), '^': (3, 0, 0), '>': (3, (math.pi / 2.0), 0), 'v': (3, math.pi, 0), '<': (3, ((3 * math.pi) / 2.0), 0), 'd': (4, 0, 0), 'p': (5, 0, 0), 'h': (6, 0, 0), '8': (8, 0, 0), '+': (4, 0, 2), 'x': (4, (math.pi / 4.0), 2)} DCNL DCSP self._process_unit_info(xdata=x, ydata=y, kwargs=kwargs) DCNL DCSP (x, y, s, c) = cbook.delete_masked_points(x, y, s, c) DCNL DCSP if (is_string_like(c) or cbook.is_sequence_of_strings(c)): DCNL DCSP  DCSP colors = mcolors.colorConverter.to_rgba_array(c, alpha) DCNL DCSP else: DCNL DCSP  DCSP sh = np.shape(c) DCNL DCSP  DCSP if ((len(sh) == 1) and (sh[0] == len(x))): DCNL DCSP  DCSP  DCSP colors = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP colors = mcolors.colorConverter.to_rgba_array(c, alpha) DCNL DCSP if (not iterable(s)): DCNL DCSP  DCSP scales = (s,) DCNL DCSP else: DCNL DCSP  DCSP scales = s DCNL DCSP if faceted: DCNL DCSP  DCSP edgecolors = None DCNL DCSP else: DCNL DCSP  DCSP edgecolors = 'none' DCNL DCSP  DCSP warnings.warn('replace DCSP "faceted=False" DCSP with DCSP "edgecolors=\'none\'"', DeprecationWarning) DCNL DCSP sym = None DCNL DCSP symstyle = 0 DCNL DCSP if ((marker is None) and (not (verts is None))): DCNL DCSP  DCSP marker = (verts, 0) DCNL DCSP  DCSP verts = None DCNL DCSP if is_string_like(marker): DCNL DCSP  DCSP sym = syms.get(marker) DCNL DCSP  DCSP if ((sym is None) and (verts is None)): DCNL DCSP  DCSP  DCSP raise ValueError('Unknown DCSP marker DCSP symbol DCSP to DCSP scatter') DCNL DCSP  DCSP (numsides, rotation, symstyle) = syms[marker] DCNL DCSP elif iterable(marker): DCNL DCSP  DCSP if ((len(marker) < 2) or (len(marker) > 3)): DCNL DCSP  DCSP  DCSP raise ValueError('Cannot DCSP create DCSP markersymbol DCSP from DCSP marker') DCNL DCSP  DCSP if cbook.is_numlike(marker[0]): DCNL DCSP  DCSP  DCSP if (len(marker) == 2): DCNL DCSP  DCSP  DCSP  DCSP (numsides, rotation) = (marker[0], 0.0) DCNL DCSP  DCSP  DCSP elif (len(marker) == 3): DCNL DCSP  DCSP  DCSP  DCSP (numsides, rotation) = (marker[0], marker[2]) DCNL DCSP  DCSP  DCSP sym = True DCNL DCSP  DCSP  DCSP if (marker[1] in (1, 2)): DCNL DCSP  DCSP  DCSP  DCSP symstyle = marker[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP verts = np.asarray(marker[0]) DCNL DCSP if (sym is not None): DCNL DCSP  DCSP if (symstyle == 0): DCNL DCSP  DCSP  DCSP collection = mcoll.RegularPolyCollection(numsides, rotation, scales, facecolors=colors, edgecolors=edgecolors, linewidths=linewidths, offsets=zip(x, y), transOffset=self.transData) DCNL DCSP  DCSP elif (symstyle == 1): DCNL DCSP  DCSP  DCSP collection = mcoll.StarPolygonCollection(numsides, rotation, scales, facecolors=colors, edgecolors=edgecolors, linewidths=linewidths, offsets=zip(x, y), transOffset=self.transData) DCNL DCSP  DCSP elif (symstyle == 2): DCNL DCSP  DCSP  DCSP collection = mcoll.AsteriskPolygonCollection(numsides, rotation, scales, facecolors=colors, edgecolors=edgecolors, linewidths=linewidths, offsets=zip(x, y), transOffset=self.transData) DCNL DCSP  DCSP elif (symstyle == 3): DCNL DCSP  DCSP  DCSP collection = mcoll.CircleCollection(scales, facecolors=colors, edgecolors=edgecolors, linewidths=linewidths, offsets=zip(x, y), transOffset=self.transData) DCNL DCSP else: DCNL DCSP  DCSP rescale = np.sqrt(max(((verts[:, 0] ** 2) + (verts[:, 1] ** 2)))) DCNL DCSP  DCSP verts /= rescale DCNL DCSP  DCSP collection = mcoll.PolyCollection((verts,), scales, facecolors=colors, edgecolors=edgecolors, linewidths=linewidths, offsets=zip(x, y), transOffset=self.transData) DCNL DCSP  DCSP collection.set_transform(mtransforms.IdentityTransform()) DCNL DCSP collection.set_alpha(alpha) DCNL DCSP collection.update(kwargs) DCNL DCSP if (colors is None): DCNL DCSP  DCSP if (norm is not None): DCNL DCSP  DCSP  DCSP assert isinstance(norm, mcolors.Normalize) DCNL DCSP  DCSP if (cmap is not None): DCNL DCSP  DCSP  DCSP assert isinstance(cmap, mcolors.Colormap) DCNL DCSP  DCSP collection.set_array(np.asarray(c)) DCNL DCSP  DCSP collection.set_cmap(cmap) DCNL DCSP  DCSP collection.set_norm(norm) DCNL DCSP  DCSP if ((vmin is not None) or (vmax is not None)): DCNL DCSP  DCSP  DCSP collection.set_clim(vmin, vmax) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP collection.autoscale_None() DCNL DCSP temp_x = x DCNL DCSP temp_y = y DCNL DCSP minx = np.amin(temp_x) DCNL DCSP maxx = np.amax(temp_x) DCNL DCSP miny = np.amin(temp_y) DCNL DCSP maxy = np.amax(temp_y) DCNL DCSP w = (maxx - minx) DCNL DCSP h = (maxy - miny) DCNL DCSP (padx, pady) = ((0.05 * w), (0.05 * h)) DCNL DCSP corners = (((minx - padx), (miny - pady)), ((maxx + padx), (maxy + pady))) DCNL DCSP self.update_datalim(corners) DCNL DCSP self.autoscale_view() DCNL DCSP self.add_collection(collection) DCNL DCSP return collection
def hexbin(self, x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', cmap=None, norm=None, vmin=None, vmax=None, alpha=1.0, linewidths=None, edgecolors='none', reduce_C_function=np.mean, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP self._process_unit_info(xdata=x, ydata=y, kwargs=kwargs) DCNL DCSP (x, y, C) = cbook.delete_masked_points(x, y, C) DCNL DCSP if iterable(gridsize): DCNL DCSP  DCSP (nx, ny) = gridsize DCNL DCSP else: DCNL DCSP  DCSP nx = gridsize DCNL DCSP  DCSP ny = int((nx / math.sqrt(3))) DCNL DCSP x = np.array(x, float) DCNL DCSP y = np.array(y, float) DCNL DCSP if (xscale == 'log'): DCNL DCSP  DCSP x = np.log10(x) DCNL DCSP if (yscale == 'log'): DCNL DCSP  DCSP y = np.log10(y) DCNL DCSP xmin = np.amin(x) DCNL DCSP xmax = np.amax(x) DCNL DCSP ymin = np.amin(y) DCNL DCSP ymax = np.amax(y) DCNL DCSP padding = (1e-09 * (xmax - xmin)) DCNL DCSP xmin -= padding DCNL DCSP xmax += padding DCNL DCSP sx = ((xmax - xmin) / nx) DCNL DCSP sy = ((ymax - ymin) / ny) DCNL DCSP x = ((x - xmin) / sx) DCNL DCSP y = ((y - ymin) / sy) DCNL DCSP ix1 = np.round(x).astype(int) DCNL DCSP iy1 = np.round(y).astype(int) DCNL DCSP ix2 = np.floor(x).astype(int) DCNL DCSP iy2 = np.floor(y).astype(int) DCNL DCSP nx1 = (nx + 1) DCNL DCSP ny1 = (ny + 1) DCNL DCSP nx2 = nx DCNL DCSP ny2 = ny DCNL DCSP n = ((nx1 * ny1) + (nx2 * ny2)) DCNL DCSP d1 = (((x - ix1) ** 2) + (3.0 * ((y - iy1) ** 2))) DCNL DCSP d2 = ((((x - ix2) - 0.5) ** 2) + (3.0 * (((y - iy2) - 0.5) ** 2))) DCNL DCSP bdist = (d1 < d2) DCNL DCSP if (C is None): DCNL DCSP  DCSP accum = np.zeros(n) DCNL DCSP  DCSP lattice1 = accum[:(nx1 * ny1)] DCNL DCSP  DCSP lattice2 = accum[(nx1 * ny1):] DCNL DCSP  DCSP lattice1.shape = (nx1, ny1) DCNL DCSP  DCSP lattice2.shape = (nx2, ny2) DCNL DCSP  DCSP for i in xrange(len(x)): DCNL DCSP  DCSP  DCSP if bdist[i]: DCNL DCSP  DCSP  DCSP  DCSP lattice1[(ix1[i], iy1[i])] += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP lattice2[(ix2[i], iy2[i])] += 1 DCNL DCSP else: DCNL DCSP  DCSP lattice1 = np.empty((nx1, ny1), dtype=object) DCNL DCSP  DCSP for i in xrange(nx1): DCNL DCSP  DCSP  DCSP for j in xrange(ny1): DCNL DCSP  DCSP  DCSP  DCSP lattice1[(i, j)] = [] DCNL DCSP  DCSP lattice2 = np.empty((nx2, ny2), dtype=object) DCNL DCSP  DCSP for i in xrange(nx2): DCNL DCSP  DCSP  DCSP for j in xrange(ny2): DCNL DCSP  DCSP  DCSP  DCSP lattice2[(i, j)] = [] DCNL DCSP  DCSP for i in xrange(len(x)): DCNL DCSP  DCSP  DCSP if bdist[i]: DCNL DCSP  DCSP  DCSP  DCSP lattice1[(ix1[i], iy1[i])].append(C[i]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP lattice2[(ix2[i], iy2[i])].append(C[i]) DCNL DCSP  DCSP for i in xrange(nx1): DCNL DCSP  DCSP  DCSP for j in xrange(ny1): DCNL DCSP  DCSP  DCSP  DCSP vals = lattice1[(i, j)] DCNL DCSP  DCSP  DCSP  DCSP if len(vals): DCNL DCSP  DCSP  DCSP  DCSP  DCSP lattice1[(i, j)] = reduce_C_function(vals) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP lattice1[(i, j)] = np.nan DCNL DCSP  DCSP for i in xrange(nx2): DCNL DCSP  DCSP  DCSP for j in xrange(ny2): DCNL DCSP  DCSP  DCSP  DCSP vals = lattice2[(i, j)] DCNL DCSP  DCSP  DCSP  DCSP if len(vals): DCNL DCSP  DCSP  DCSP  DCSP  DCSP lattice2[(i, j)] = reduce_C_function(vals) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP lattice2[(i, j)] = np.nan DCNL DCSP  DCSP accum = np.hstack((lattice1.astype(float).ravel(), lattice2.astype(float).ravel())) DCNL DCSP  DCSP good_idxs = (~ np.isnan(accum)) DCNL DCSP px = (xmin + (sx * np.array([0.5, 0.5, 0.0, (-0.5), (-0.5), 0.0]))) DCNL DCSP py = (ymin + ((sy * np.array([(-0.5), 0.5, 1.0, 0.5, (-0.5), (-1.0)])) / 3.0)) DCNL DCSP polygons = np.zeros((6, n, 2), float) DCNL DCSP polygons[:, :(nx1 * ny1), 0] = np.repeat(np.arange(nx1), ny1) DCNL DCSP polygons[:, :(nx1 * ny1), 1] = np.tile(np.arange(ny1), nx1) DCNL DCSP polygons[:, (nx1 * ny1):, 0] = np.repeat((np.arange(nx2) + 0.5), ny2) DCNL DCSP polygons[:, (nx1 * ny1):, 1] = (np.tile(np.arange(ny2), nx2) + 0.5) DCNL DCSP if (C is not None): DCNL DCSP  DCSP polygons = polygons[:, good_idxs, :] DCNL DCSP  DCSP accum = accum[good_idxs] DCNL DCSP polygons = np.transpose(polygons, axes=[1, 0, 2]) DCNL DCSP polygons[:, :, 0] *= sx DCNL DCSP polygons[:, :, 1] *= sy DCNL DCSP polygons[:, :, 0] += px DCNL DCSP polygons[:, :, 1] += py DCNL DCSP if (xscale == 'log'): DCNL DCSP  DCSP polygons[:, :, 0] = (10 ** polygons[:, :, 0]) DCNL DCSP  DCSP xmin = (10 ** xmin) DCNL DCSP  DCSP xmax = (10 ** xmax) DCNL DCSP  DCSP self.set_xscale('log') DCNL DCSP if (yscale == 'log'): DCNL DCSP  DCSP polygons[:, :, 1] = (10 ** polygons[:, :, 1]) DCNL DCSP  DCSP ymin = (10 ** ymin) DCNL DCSP  DCSP ymax = (10 ** ymax) DCNL DCSP  DCSP self.set_yscale('log') DCNL DCSP if (edgecolors == 'none'): DCNL DCSP  DCSP edgecolors = 'face' DCNL DCSP collection = mcoll.PolyCollection(polygons, edgecolors=edgecolors, linewidths=linewidths, transOffset=self.transData) DCNL DCSP if (bins == 'log'): DCNL DCSP  DCSP accum = np.log10((accum + 1)) DCNL DCSP elif (bins != None): DCNL DCSP  DCSP if (not iterable(bins)): DCNL DCSP  DCSP  DCSP (minimum, maximum) = (min(accum), max(accum)) DCNL DCSP  DCSP  DCSP bins -= 1 DCNL DCSP  DCSP  DCSP bins = (minimum + (((maximum - minimum) * np.arange(bins)) / bins)) DCNL DCSP  DCSP bins = np.sort(bins) DCNL DCSP  DCSP accum = bins.searchsorted(accum) DCNL DCSP if (norm is not None): DCNL DCSP  DCSP assert isinstance(norm, mcolors.Normalize) DCNL DCSP if (cmap is not None): DCNL DCSP  DCSP assert isinstance(cmap, mcolors.Colormap) DCNL DCSP collection.set_array(accum) DCNL DCSP collection.set_cmap(cmap) DCNL DCSP collection.set_norm(norm) DCNL DCSP collection.set_alpha(alpha) DCNL DCSP collection.update(kwargs) DCNL DCSP if ((vmin is not None) or (vmax is not None)): DCNL DCSP  DCSP collection.set_clim(vmin, vmax) DCNL DCSP else: DCNL DCSP  DCSP collection.autoscale_None() DCNL DCSP corners = ((xmin, ymin), (xmax, ymax)) DCNL DCSP self.update_datalim(corners) DCNL DCSP self.autoscale_view() DCNL DCSP self.add_collection(collection) DCNL DCSP return collection
def arrow(self, x, y, dx, dy, **kwargs): DCNL DCSP a = mpatches.FancyArrow(x, y, dx, dy, **kwargs) DCNL DCSP self.add_artist(a) DCNL DCSP return a
def barbs(self, *args, **kw): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP b = mquiver.Barbs(self, *args, **kw) DCNL DCSP self.add_collection(b) DCNL DCSP self.update_datalim(b.get_offsets()) DCNL DCSP self.autoscale_view() DCNL DCSP return b
def fill(self, *args, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP patches = [] DCNL DCSP for poly in self._get_patches_for_fill(*args, **kwargs): DCNL DCSP  DCSP self.add_patch(poly) DCNL DCSP  DCSP patches.append(poly) DCNL DCSP self.autoscale_view() DCNL DCSP return patches
def fill_between(self, x, y1, y2=0, where=None, **kwargs): DCNL DCSP self._process_unit_info(xdata=x, ydata=y1, kwargs=kwargs) DCNL DCSP self._process_unit_info(ydata=y2) DCNL DCSP x = np.asarray(self.convert_xunits(x)) DCNL DCSP y1 = np.asarray(self.convert_yunits(y1)) DCNL DCSP y2 = np.asarray(self.convert_yunits(y2)) DCNL DCSP if (not cbook.iterable(y1)): DCNL DCSP  DCSP y1 = (np.ones_like(x) * y1) DCNL DCSP if (not cbook.iterable(y2)): DCNL DCSP  DCSP y2 = (np.ones_like(x) * y2) DCNL DCSP if (where is None): DCNL DCSP  DCSP where = np.ones(len(x), np.bool) DCNL DCSP where = np.asarray(where) DCNL DCSP assert ((len(x) == len(y1)) and (len(x) == len(y2)) and (len(x) == len(where))) DCNL DCSP polys = [] DCNL DCSP for (ind0, ind1) in mlab.contiguous_regions(where): DCNL DCSP  DCSP theseverts = [] DCNL DCSP  DCSP xslice = x[ind0:ind1] DCNL DCSP  DCSP y1slice = y1[ind0:ind1] DCNL DCSP  DCSP y2slice = y2[ind0:ind1] DCNL DCSP  DCSP if (not len(xslice)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP N = len(xslice) DCNL DCSP  DCSP X = np.zeros((((2 * N) + 2), 2), np.float) DCNL DCSP  DCSP X[0] = (xslice[0], y2slice[0]) DCNL DCSP  DCSP X[(N + 1)] = (xslice[(-1)], y2slice[(-1)]) DCNL DCSP  DCSP X[1:(N + 1), 0] = xslice DCNL DCSP  DCSP X[1:(N + 1), 1] = y1slice DCNL DCSP  DCSP X[(N + 2):, 0] = xslice[::(-1)] DCNL DCSP  DCSP X[(N + 2):, 1] = y2slice[::(-1)] DCNL DCSP  DCSP polys.append(X) DCNL DCSP collection = mcoll.PolyCollection(polys, **kwargs) DCNL DCSP XY1 = np.array([x[where], y1[where]]).T DCNL DCSP XY2 = np.array([x[where], y2[where]]).T DCNL DCSP self.dataLim.update_from_data_xy(XY1, self.ignore_existing_data_limits, updatex=True, updatey=True) DCNL DCSP self.dataLim.update_from_data_xy(XY2, self.ignore_existing_data_limits, updatex=False, updatey=True) DCNL DCSP self.add_collection(collection) DCNL DCSP self.autoscale_view() DCNL DCSP return collection
def imshow(self, X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=1.0, vmin=None, vmax=None, origin=None, extent=None, shape=None, filternorm=1, filterrad=4.0, imlim=None, resample=None, url=None, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP if (norm is not None): DCNL DCSP  DCSP assert isinstance(norm, mcolors.Normalize) DCNL DCSP if (cmap is not None): DCNL DCSP  DCSP assert isinstance(cmap, mcolors.Colormap) DCNL DCSP if (aspect is None): DCNL DCSP  DCSP aspect = rcParams['image.aspect'] DCNL DCSP self.set_aspect(aspect) DCNL DCSP im = mimage.AxesImage(self, cmap, norm, interpolation, origin, extent, filternorm=filternorm, filterrad=filterrad, resample=resample, **kwargs) DCNL DCSP im.set_data(X) DCNL DCSP im.set_alpha(alpha) DCNL DCSP self._set_artist_props(im) DCNL DCSP im.set_clip_path(self.patch) DCNL DCSP if ((vmin is not None) or (vmax is not None)): DCNL DCSP  DCSP im.set_clim(vmin, vmax) DCNL DCSP else: DCNL DCSP  DCSP im.autoscale_None() DCNL DCSP im.set_url(url) DCNL DCSP (xmin, xmax, ymin, ymax) = im.get_extent() DCNL DCSP corners = ((xmin, ymin), (xmax, ymax)) DCNL DCSP self.update_datalim(corners) DCNL DCSP if self._autoscaleon: DCNL DCSP  DCSP self.set_xlim((xmin, xmax)) DCNL DCSP  DCSP self.set_ylim((ymin, ymax)) DCNL DCSP self.images.append(im) DCNL DCSP return im
def pcolor(self, *args, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP alpha = kwargs.pop('alpha', 1.0) DCNL DCSP norm = kwargs.pop('norm', None) DCNL DCSP cmap = kwargs.pop('cmap', None) DCNL DCSP vmin = kwargs.pop('vmin', None) DCNL DCSP vmax = kwargs.pop('vmax', None) DCNL DCSP shading = kwargs.pop('shading', 'flat') DCNL DCSP (X, Y, C) = self._pcolorargs('pcolor', *args) DCNL DCSP (Ny, Nx) = X.shape DCNL DCSP C = ma.asarray(C) DCNL DCSP X = ma.asarray(X) DCNL DCSP Y = ma.asarray(Y) DCNL DCSP mask = (ma.getmaskarray(X) + ma.getmaskarray(Y)) DCNL DCSP xymask = (((mask[0:(-1), 0:(-1)] + mask[1:, 1:]) + mask[0:(-1), 1:]) + mask[1:, 0:(-1)]) DCNL DCSP mask = (ma.getmaskarray(C)[0:(Ny - 1), 0:(Nx - 1)] + xymask) DCNL DCSP newaxis = np.newaxis DCNL DCSP compress = np.compress DCNL DCSP ravelmask = (mask == 0).ravel() DCNL DCSP X1 = compress(ravelmask, ma.filled(X[0:(-1), 0:(-1)]).ravel()) DCNL DCSP Y1 = compress(ravelmask, ma.filled(Y[0:(-1), 0:(-1)]).ravel()) DCNL DCSP X2 = compress(ravelmask, ma.filled(X[1:, 0:(-1)]).ravel()) DCNL DCSP Y2 = compress(ravelmask, ma.filled(Y[1:, 0:(-1)]).ravel()) DCNL DCSP X3 = compress(ravelmask, ma.filled(X[1:, 1:]).ravel()) DCNL DCSP Y3 = compress(ravelmask, ma.filled(Y[1:, 1:]).ravel()) DCNL DCSP X4 = compress(ravelmask, ma.filled(X[0:(-1), 1:]).ravel()) DCNL DCSP Y4 = compress(ravelmask, ma.filled(Y[0:(-1), 1:]).ravel()) DCNL DCSP npoly = len(X1) DCNL DCSP xy = np.concatenate((X1[:, newaxis], Y1[:, newaxis], X2[:, newaxis], Y2[:, newaxis], X3[:, newaxis], Y3[:, newaxis], X4[:, newaxis], Y4[:, newaxis], X1[:, newaxis], Y1[:, newaxis]), axis=1) DCNL DCSP verts = xy.reshape((npoly, 5, 2)) DCNL DCSP C = compress(ravelmask, ma.filled(C[0:(Ny - 1), 0:(Nx - 1)]).ravel()) DCNL DCSP if (shading == 'faceted'): DCNL DCSP  DCSP edgecolors = ((0, 0, 0, 1),) DCNL DCSP  DCSP linewidths = (0.25,) DCNL DCSP else: DCNL DCSP  DCSP edgecolors = 'face' DCNL DCSP  DCSP linewidths = (1.0,) DCNL DCSP kwargs.setdefault('edgecolors', edgecolors) DCNL DCSP kwargs.setdefault('antialiaseds', (0,)) DCNL DCSP kwargs.setdefault('linewidths', linewidths) DCNL DCSP collection = mcoll.PolyCollection(verts, **kwargs) DCNL DCSP collection.set_alpha(alpha) DCNL DCSP collection.set_array(C) DCNL DCSP if (norm is not None): DCNL DCSP  DCSP assert isinstance(norm, mcolors.Normalize) DCNL DCSP if (cmap is not None): DCNL DCSP  DCSP assert isinstance(cmap, mcolors.Colormap) DCNL DCSP collection.set_cmap(cmap) DCNL DCSP collection.set_norm(norm) DCNL DCSP if ((vmin is not None) or (vmax is not None)): DCNL DCSP  DCSP collection.set_clim(vmin, vmax) DCNL DCSP else: DCNL DCSP  DCSP collection.autoscale_None() DCNL DCSP self.grid(False) DCNL DCSP x = X.compressed() DCNL DCSP y = Y.compressed() DCNL DCSP minx = np.amin(x) DCNL DCSP maxx = np.amax(x) DCNL DCSP miny = np.amin(y) DCNL DCSP maxy = np.amax(y) DCNL DCSP corners = ((minx, miny), (maxx, maxy)) DCNL DCSP self.update_datalim(corners) DCNL DCSP self.autoscale_view() DCNL DCSP self.add_collection(collection) DCNL DCSP return collection
def pcolormesh(self, *args, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP alpha = kwargs.pop('alpha', 1.0) DCNL DCSP norm = kwargs.pop('norm', None) DCNL DCSP cmap = kwargs.pop('cmap', None) DCNL DCSP vmin = kwargs.pop('vmin', None) DCNL DCSP vmax = kwargs.pop('vmax', None) DCNL DCSP shading = kwargs.pop('shading', 'flat') DCNL DCSP edgecolors = kwargs.pop('edgecolors', 'None') DCNL DCSP antialiased = kwargs.pop('antialiased', False) DCNL DCSP (X, Y, C) = self._pcolorargs('pcolormesh', *args) DCNL DCSP (Ny, Nx) = X.shape DCNL DCSP C = ma.ravel(C[0:(Ny - 1), 0:(Nx - 1)]) DCNL DCSP X = X.ravel() DCNL DCSP Y = Y.ravel() DCNL DCSP coords = np.zeros(((Nx * Ny), 2), dtype=float) DCNL DCSP coords[:, 0] = X DCNL DCSP coords[:, 1] = Y DCNL DCSP if ((shading == 'faceted') or (edgecolors != 'None')): DCNL DCSP  DCSP showedges = 1 DCNL DCSP else: DCNL DCSP  DCSP showedges = 0 DCNL DCSP collection = mcoll.QuadMesh((Nx - 1), (Ny - 1), coords, showedges, antialiased=antialiased) DCNL DCSP collection.set_alpha(alpha) DCNL DCSP collection.set_array(C) DCNL DCSP if (norm is not None): DCNL DCSP  DCSP assert isinstance(norm, mcolors.Normalize) DCNL DCSP if (cmap is not None): DCNL DCSP  DCSP assert isinstance(cmap, mcolors.Colormap) DCNL DCSP collection.set_cmap(cmap) DCNL DCSP collection.set_norm(norm) DCNL DCSP if ((vmin is not None) or (vmax is not None)): DCNL DCSP  DCSP collection.set_clim(vmin, vmax) DCNL DCSP else: DCNL DCSP  DCSP collection.autoscale_None() DCNL DCSP self.grid(False) DCNL DCSP minx = np.amin(X) DCNL DCSP maxx = np.amax(X) DCNL DCSP miny = np.amin(Y) DCNL DCSP maxy = np.amax(Y) DCNL DCSP corners = ((minx, miny), (maxx, maxy)) DCNL DCSP self.update_datalim(corners) DCNL DCSP self.autoscale_view() DCNL DCSP self.add_collection(collection) DCNL DCSP return collection
def pcolorfast(self, *args, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP alpha = kwargs.pop('alpha', 1.0) DCNL DCSP norm = kwargs.pop('norm', None) DCNL DCSP cmap = kwargs.pop('cmap', None) DCNL DCSP vmin = kwargs.pop('vmin', None) DCNL DCSP vmax = kwargs.pop('vmax', None) DCNL DCSP if (norm is not None): DCNL DCSP  DCSP assert isinstance(norm, mcolors.Normalize) DCNL DCSP if (cmap is not None): DCNL DCSP  DCSP assert isinstance(cmap, mcolors.Colormap) DCNL DCSP C = args[(-1)] DCNL DCSP (nr, nc) = C.shape DCNL DCSP if (len(args) == 1): DCNL DCSP  DCSP style = 'image' DCNL DCSP  DCSP x = [0, nc] DCNL DCSP  DCSP y = [0, nr] DCNL DCSP elif (len(args) == 3): DCNL DCSP  DCSP (x, y) = args[:2] DCNL DCSP  DCSP x = np.asarray(x) DCNL DCSP  DCSP y = np.asarray(y) DCNL DCSP  DCSP if ((x.ndim == 1) and (y.ndim == 1)): DCNL DCSP  DCSP  DCSP if ((x.size == 2) and (y.size == 2)): DCNL DCSP  DCSP  DCSP  DCSP style = 'image' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP dx = np.diff(x) DCNL DCSP  DCSP  DCSP  DCSP dy = np.diff(y) DCNL DCSP  DCSP  DCSP  DCSP if ((np.ptp(dx) < (0.01 * np.abs(dx.mean()))) and (np.ptp(dy) < (0.01 * np.abs(dy.mean())))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP style = 'image' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP style = 'pcolorimage' DCNL DCSP  DCSP elif ((x.ndim == 2) and (y.ndim == 2)): DCNL DCSP  DCSP  DCSP style = 'quadmesh' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError('arguments DCSP do DCSP not DCSP match DCSP valid DCSP signatures') DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('need DCSP 1 DCSP argument DCSP or DCSP 3 DCSP arguments') DCNL DCSP if (style == 'quadmesh'): DCNL DCSP  DCSP C = ma.ravel(C) DCNL DCSP  DCSP X = x.ravel() DCNL DCSP  DCSP Y = y.ravel() DCNL DCSP  DCSP Nx = (nc + 1) DCNL DCSP  DCSP Ny = (nr + 1) DCNL DCSP  DCSP coords = np.empty(((Nx * Ny), 2), np.float64) DCNL DCSP  DCSP coords[:, 0] = X DCNL DCSP  DCSP coords[:, 1] = Y DCNL DCSP  DCSP collection = mcoll.QuadMesh(nc, nr, coords, 0) DCNL DCSP  DCSP collection.set_alpha(alpha) DCNL DCSP  DCSP collection.set_array(C) DCNL DCSP  DCSP collection.set_cmap(cmap) DCNL DCSP  DCSP collection.set_norm(norm) DCNL DCSP  DCSP self.add_collection(collection) DCNL DCSP  DCSP (xl, xr, yb, yt) = (X.min(), X.max(), Y.min(), Y.max()) DCNL DCSP  DCSP ret = collection DCNL DCSP else: DCNL DCSP  DCSP (xl, xr, yb, yt) = (x[0], x[(-1)], y[0], y[(-1)]) DCNL DCSP if (style == 'image'): DCNL DCSP  DCSP im = mimage.AxesImage(self, cmap, norm, interpolation='nearest', origin='lower', extent=(xl, xr, yb, yt), **kwargs) DCNL DCSP  DCSP im.set_data(C) DCNL DCSP  DCSP im.set_alpha(alpha) DCNL DCSP  DCSP self.images.append(im) DCNL DCSP  DCSP ret = im DCNL DCSP if (style == 'pcolorimage'): DCNL DCSP  DCSP im = mimage.PcolorImage(self, x, y, C, cmap=cmap, norm=norm, alpha=alpha, **kwargs) DCNL DCSP  DCSP self.images.append(im) DCNL DCSP  DCSP ret = im DCNL DCSP self._set_artist_props(ret) DCNL DCSP if ((vmin is not None) or (vmax is not None)): DCNL DCSP  DCSP ret.set_clim(vmin, vmax) DCNL DCSP else: DCNL DCSP  DCSP ret.autoscale_None() DCNL DCSP self.update_datalim(np.array([[xl, yb], [xr, yt]])) DCNL DCSP self.autoscale_view(tight=True) DCNL DCSP return ret
def table(self, **kwargs): DCNL DCSP return mtable.table(self, **kwargs)
def twinx(self): DCNL DCSP ax2 = self.figure.add_axes(self.get_position(True), sharex=self, frameon=False) DCNL DCSP ax2.yaxis.tick_right() DCNL DCSP ax2.yaxis.set_label_position('right') DCNL DCSP self.yaxis.tick_left() DCNL DCSP return ax2
def twiny(self): DCNL DCSP ax2 = self.figure.add_axes(self.get_position(True), sharey=self, frameon=False) DCNL DCSP ax2.xaxis.tick_top() DCNL DCSP ax2.xaxis.set_label_position('top') DCNL DCSP self.xaxis.tick_bottom() DCNL DCSP return ax2
def get_shared_x_axes(self): DCNL DCSP return self._shared_x_axes
def get_shared_y_axes(self): DCNL DCSP return self._shared_y_axes
def hist(self, x, bins=10, range=None, normed=False, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP if (kwargs.get('width') is not None): DCNL DCSP  DCSP raise DeprecationWarning('hist DCSP now DCSP uses DCSP the DCSP rwidth DCSP to DCSP give DCSP relative DCSP width DCSP and DCSP not DCSP absolute DCSP width') DCNL DCSP try: DCNL DCSP  DCSP x = np.transpose(np.array(x)) DCNL DCSP  DCSP if (len(x.shape) == 1): DCNL DCSP  DCSP  DCSP x.shape = (1, x.shape[0]) DCNL DCSP  DCSP elif ((len(x.shape) == 2) and (x.shape[1] < x.shape[0])): DCNL DCSP  DCSP  DCSP warnings.warn('2D DCSP hist DCSP should DCSP be DCSP nsamples DCSP x DCSP nvariables; DCSP this DCSP looks DCSP transposed') DCNL DCSP except ValueError: DCNL DCSP  DCSP if (iterable(x[0]) and (not is_string_like(x[0]))): DCNL DCSP  DCSP  DCSP tx = [] DCNL DCSP  DCSP  DCSP for i in xrange(len(x)): DCNL DCSP  DCSP  DCSP  DCSP tx.append(np.array(x[i])) DCNL DCSP  DCSP  DCSP x = tx DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError, 'Can DCSP not DCSP use DCSP providet DCSP data DCSP to DCSP create DCSP a DCSP histogram' DCNL DCSP binsgiven = (cbook.iterable(bins) or (range != None)) DCNL DCSP if (np.__version__ < '1.3'): DCNL DCSP  DCSP hist_kwargs = dict(range=range, normed=bool(normed), new=True) DCNL DCSP else: DCNL DCSP  DCSP hist_kwargs = dict(range=range, normed=bool(normed)) DCNL DCSP n = [] DCNL DCSP for i in xrange(len(x)): DCNL DCSP  DCSP (m, bins) = np.histogram(x[i], bins, **hist_kwargs) DCNL DCSP  DCSP n.append(m) DCNL DCSP if cumulative: DCNL DCSP  DCSP slc = slice(None) DCNL DCSP  DCSP if (cbook.is_numlike(cumulative) and (cumulative < 0)): DCNL DCSP  DCSP  DCSP slc = slice(None, None, (-1)) DCNL DCSP  DCSP if normed: DCNL DCSP  DCSP  DCSP n = [(m * np.diff(bins))[slc].cumsum()[slc] for m in n] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP n = [m[slc].cumsum()[slc] for m in n] DCNL DCSP patches = [] DCNL DCSP if histtype.startswith('bar'): DCNL DCSP  DCSP totwidth = np.diff(bins) DCNL DCSP  DCSP stacked = False DCNL DCSP  DCSP if (rwidth is not None): DCNL DCSP  DCSP  DCSP dr = min(1.0, max(0.0, rwidth)) DCNL DCSP  DCSP elif (len(n) > 1): DCNL DCSP  DCSP  DCSP dr = 0.8 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP dr = 1.0 DCNL DCSP  DCSP if (histtype == 'bar'): DCNL DCSP  DCSP  DCSP width = ((dr * totwidth) / len(n)) DCNL DCSP  DCSP  DCSP dw = width DCNL DCSP  DCSP  DCSP if (len(n) > 1): DCNL DCSP  DCSP  DCSP  DCSP boffset = ((((-0.5) * dr) * totwidth) * (1.0 - (1.0 / len(n)))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP boffset = 0.0 DCNL DCSP  DCSP elif (histtype == 'barstacked'): DCNL DCSP  DCSP  DCSP width = (dr * totwidth) DCNL DCSP  DCSP  DCSP (boffset, dw) = (0.0, 0.0) DCNL DCSP  DCSP  DCSP stacked = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError, ('invalid DCSP histtype: DCSP %s' % histtype) DCNL DCSP  DCSP if ((align == 'mid') or (align == 'edge')): DCNL DCSP  DCSP  DCSP boffset += (0.5 * totwidth) DCNL DCSP  DCSP elif (align == 'right'): DCNL DCSP  DCSP  DCSP boffset += totwidth DCNL DCSP  DCSP elif ((align != 'left') and (align != 'center')): DCNL DCSP  DCSP  DCSP raise ValueError, ('invalid DCSP align: DCSP %s' % align) DCNL DCSP  DCSP if (orientation == 'horizontal'): DCNL DCSP  DCSP  DCSP for m in n: DCNL DCSP  DCSP  DCSP  DCSP color = self._get_lines._get_next_cycle_color() DCNL DCSP  DCSP  DCSP  DCSP patch = self.barh((bins[:(-1)] + boffset), m, height=width, left=bottom, align='center', log=log, color=color) DCNL DCSP  DCSP  DCSP  DCSP patches.append(patch) DCNL DCSP  DCSP  DCSP  DCSP if stacked: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (bottom is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bottom = 0.0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP bottom += m DCNL DCSP  DCSP  DCSP  DCSP boffset += dw DCNL DCSP  DCSP elif (orientation == 'vertical'): DCNL DCSP  DCSP  DCSP for m in n: DCNL DCSP  DCSP  DCSP  DCSP color = self._get_lines._get_next_cycle_color() DCNL DCSP  DCSP  DCSP  DCSP patch = self.bar((bins[:(-1)] + boffset), m, width=width, bottom=bottom, align='center', log=log, color=color) DCNL DCSP  DCSP  DCSP  DCSP patches.append(patch) DCNL DCSP  DCSP  DCSP  DCSP if stacked: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (bottom is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bottom = 0.0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP bottom += m DCNL DCSP  DCSP  DCSP  DCSP boffset += dw DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError, ('invalid DCSP orientation: DCSP %s' % orientation) DCNL DCSP elif histtype.startswith('step'): DCNL DCSP  DCSP x = np.zeros((2 * len(bins)), np.float) DCNL DCSP  DCSP y = np.zeros((2 * len(bins)), np.float) DCNL DCSP  DCSP (x[0::2], x[1::2]) = (bins, bins) DCNL DCSP  DCSP if ((align == 'left') or (align == 'center')): DCNL DCSP  DCSP  DCSP x -= (0.5 * (bins[1] - bins[0])) DCNL DCSP  DCSP elif (align == 'right'): DCNL DCSP  DCSP  DCSP x += (0.5 * (bins[1] - bins[0])) DCNL DCSP  DCSP elif ((align != 'mid') and (align != 'edge')): DCNL DCSP  DCSP  DCSP raise ValueError, ('invalid DCSP align: DCSP %s' % align) DCNL DCSP  DCSP if log: DCNL DCSP  DCSP  DCSP (y[0], y[(-1)]) = (1e-100, 1e-100) DCNL DCSP  DCSP  DCSP if (orientation == 'horizontal'): DCNL DCSP  DCSP  DCSP  DCSP self.set_xscale('log') DCNL DCSP  DCSP  DCSP elif (orientation == 'vertical'): DCNL DCSP  DCSP  DCSP  DCSP self.set_yscale('log') DCNL DCSP  DCSP fill = False DCNL DCSP  DCSP if (histtype == 'stepfilled'): DCNL DCSP  DCSP  DCSP fill = True DCNL DCSP  DCSP elif (histtype != 'step'): DCNL DCSP  DCSP  DCSP raise ValueError, ('invalid DCSP histtype: DCSP %s' % histtype) DCNL DCSP  DCSP for m in n: DCNL DCSP  DCSP  DCSP (y[1:(-1):2], y[2::2]) = (m, m) DCNL DCSP  DCSP  DCSP if (orientation == 'horizontal'): DCNL DCSP  DCSP  DCSP  DCSP (x, y) = (y, x) DCNL DCSP  DCSP  DCSP elif (orientation != 'vertical'): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError, ('invalid DCSP orientation: DCSP %s' % orientation) DCNL DCSP  DCSP  DCSP color = self._get_lines._get_next_cycle_color() DCNL DCSP  DCSP  DCSP if fill: DCNL DCSP  DCSP  DCSP  DCSP patches.append(self.fill(x, y, closed=False, facecolor=color)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP patches.append(self.fill(x, y, closed=False, edgecolor=color, fill=False)) DCNL DCSP  DCSP if (orientation == 'horizontal'): DCNL DCSP  DCSP  DCSP (xmin, xmax) = (0, self.dataLim.intervalx[1]) DCNL DCSP  DCSP  DCSP for m in n: DCNL DCSP  DCSP  DCSP  DCSP xmin = np.amin(m[(m != 0)]) DCNL DCSP  DCSP  DCSP xmin = max((xmin * 0.9), 1e-100) DCNL DCSP  DCSP  DCSP self.dataLim.intervalx = (xmin, xmax) DCNL DCSP  DCSP elif (orientation == 'vertical'): DCNL DCSP  DCSP  DCSP (ymin, ymax) = (0, self.dataLim.intervaly[1]) DCNL DCSP  DCSP  DCSP for m in n: DCNL DCSP  DCSP  DCSP  DCSP ymin = np.amin(m[(m != 0)]) DCNL DCSP  DCSP  DCSP ymin = max((ymin * 0.9), 1e-100) DCNL DCSP  DCSP  DCSP self.dataLim.intervaly = (ymin, ymax) DCNL DCSP  DCSP self.autoscale_view() DCNL DCSP else: DCNL DCSP  DCSP raise ValueError, ('invalid DCSP histtype: DCSP %s' % histtype) DCNL DCSP label = kwargs.pop('label', '') DCNL DCSP for patch in patches: DCNL DCSP  DCSP for p in patch: DCNL DCSP  DCSP  DCSP p.update(kwargs) DCNL DCSP  DCSP  DCSP p.set_label(label) DCNL DCSP  DCSP  DCSP label = '_nolegend_' DCNL DCSP if binsgiven: DCNL DCSP  DCSP self.set_autoscale_on(False) DCNL DCSP  DCSP if (orientation == 'vertical'): DCNL DCSP  DCSP  DCSP self.autoscale_view(scalex=False, scaley=True) DCNL DCSP  DCSP  DCSP XL = self.xaxis.get_major_locator().view_limits(bins[0], bins[(-1)]) DCNL DCSP  DCSP  DCSP self.set_xbound(XL) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.autoscale_view(scalex=True, scaley=False) DCNL DCSP  DCSP  DCSP YL = self.yaxis.get_major_locator().view_limits(bins[0], bins[(-1)]) DCNL DCSP  DCSP  DCSP self.set_ybound(YL) DCNL DCSP if (len(n) == 1): DCNL DCSP  DCSP return (n[0], bins, cbook.silent_list('Patch', patches[0])) DCNL DCSP else: DCNL DCSP  DCSP return (n, bins, cbook.silent_list('Lists DCSP of DCSP Patches', patches))
def psd(self, x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none, window=mlab.window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP (pxx, freqs) = mlab.psd(x, NFFT, Fs, detrend, window, noverlap, pad_to, sides, scale_by_freq) DCNL DCSP pxx.shape = (len(freqs),) DCNL DCSP freqs += Fc DCNL DCSP if (scale_by_freq in (None, True)): DCNL DCSP  DCSP psd_units = 'dB/Hz' DCNL DCSP else: DCNL DCSP  DCSP psd_units = 'dB' DCNL DCSP self.plot(freqs, (10 * np.log10(pxx)), **kwargs) DCNL DCSP self.set_xlabel('Frequency') DCNL DCSP self.set_ylabel(('Power DCSP Spectral DCSP Density DCSP (%s)' % psd_units)) DCNL DCSP self.grid(True) DCNL DCSP (vmin, vmax) = self.viewLim.intervaly DCNL DCSP intv = (vmax - vmin) DCNL DCSP logi = int(np.log10(intv)) DCNL DCSP if (logi == 0): DCNL DCSP  DCSP logi = 0.1 DCNL DCSP step = (10 * logi) DCNL DCSP ticks = np.arange(math.floor(vmin), (math.ceil(vmax) + 1), step) DCNL DCSP self.set_yticks(ticks) DCNL DCSP return (pxx, freqs)
def csd(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none, window=mlab.window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP (pxy, freqs) = mlab.csd(x, y, NFFT, Fs, detrend, window, noverlap, pad_to, sides, scale_by_freq) DCNL DCSP pxy.shape = (len(freqs),) DCNL DCSP freqs += Fc DCNL DCSP self.plot(freqs, (10 * np.log10(np.absolute(pxy))), **kwargs) DCNL DCSP self.set_xlabel('Frequency') DCNL DCSP self.set_ylabel('Cross DCSP Spectrum DCSP Magnitude DCSP (dB)') DCNL DCSP self.grid(True) DCNL DCSP (vmin, vmax) = self.viewLim.intervaly DCNL DCSP intv = (vmax - vmin) DCNL DCSP step = (10 * int(np.log10(intv))) DCNL DCSP ticks = np.arange(math.floor(vmin), (math.ceil(vmax) + 1), step) DCNL DCSP self.set_yticks(ticks) DCNL DCSP return (pxy, freqs)
def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none, window=mlab.window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None, **kwargs): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP (cxy, freqs) = mlab.cohere(x, y, NFFT, Fs, detrend, window, noverlap, scale_by_freq) DCNL DCSP freqs += Fc DCNL DCSP self.plot(freqs, cxy, **kwargs) DCNL DCSP self.set_xlabel('Frequency') DCNL DCSP self.set_ylabel('Coherence') DCNL DCSP self.grid(True) DCNL DCSP return (cxy, freqs)
def specgram(self, x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none, window=mlab.window_hanning, noverlap=128, cmap=None, xextent=None, pad_to=None, sides='default', scale_by_freq=None): DCNL DCSP if (not self._hold): DCNL DCSP  DCSP self.cla() DCNL DCSP (Pxx, freqs, bins) = mlab.specgram(x, NFFT, Fs, detrend, window, noverlap, pad_to, sides, scale_by_freq) DCNL DCSP Z = (10.0 * np.log10(Pxx)) DCNL DCSP Z = np.flipud(Z) DCNL DCSP if (xextent is None): DCNL DCSP  DCSP xextent = (0, np.amax(bins)) DCNL DCSP (xmin, xmax) = xextent DCNL DCSP freqs += Fc DCNL DCSP extent = (xmin, xmax, freqs[0], freqs[(-1)]) DCNL DCSP im = self.imshow(Z, cmap, extent=extent) DCNL DCSP self.axis('auto') DCNL DCSP return (Pxx, freqs, bins, im)
def spy(self, Z, precision=0, marker=None, markersize=None, aspect='equal', **kwargs): DCNL DCSP if (precision is None): DCNL DCSP  DCSP precision = 0 DCNL DCSP  DCSP warnings.DeprecationWarning('Use DCSP precision=0 DCSP instead DCSP of DCSP None') DCNL DCSP if ((marker is None) and (markersize is None) and hasattr(Z, 'tocoo')): DCNL DCSP  DCSP marker = 's' DCNL DCSP if ((marker is None) and (markersize is None)): DCNL DCSP  DCSP Z = np.asarray(Z) DCNL DCSP  DCSP mask = (np.absolute(Z) > precision) DCNL DCSP  DCSP if ('cmap' not in kwargs): DCNL DCSP  DCSP  DCSP kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'], name='binary') DCNL DCSP  DCSP (nr, nc) = Z.shape DCNL DCSP  DCSP extent = [(-0.5), (nc - 0.5), (nr - 0.5), (-0.5)] DCNL DCSP  DCSP ret = self.imshow(mask, interpolation='nearest', aspect=aspect, extent=extent, origin='upper', **kwargs) DCNL DCSP else: DCNL DCSP  DCSP if hasattr(Z, 'tocoo'): DCNL DCSP  DCSP  DCSP c = Z.tocoo() DCNL DCSP  DCSP  DCSP if (precision == 'present'): DCNL DCSP  DCSP  DCSP  DCSP y = c.row DCNL DCSP  DCSP  DCSP  DCSP x = c.col DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP nonzero = (np.absolute(c.data) > precision) DCNL DCSP  DCSP  DCSP  DCSP y = c.row[nonzero] DCNL DCSP  DCSP  DCSP  DCSP x = c.col[nonzero] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP Z = np.asarray(Z) DCNL DCSP  DCSP  DCSP nonzero = (np.absolute(Z) > precision) DCNL DCSP  DCSP  DCSP (y, x) = np.nonzero(nonzero) DCNL DCSP  DCSP if (marker is None): DCNL DCSP  DCSP  DCSP marker = 's' DCNL DCSP  DCSP if (markersize is None): DCNL DCSP  DCSP  DCSP markersize = 10 DCNL DCSP  DCSP marks = mlines.Line2D(x, y, linestyle='None', marker=marker, markersize=markersize, **kwargs) DCNL DCSP  DCSP self.add_line(marks) DCNL DCSP  DCSP (nr, nc) = Z.shape DCNL DCSP  DCSP self.set_xlim(xmin=(-0.5), xmax=(nc - 0.5)) DCNL DCSP  DCSP self.set_ylim(ymin=(nr - 0.5), ymax=(-0.5)) DCNL DCSP  DCSP self.set_aspect(aspect) DCNL DCSP  DCSP ret = marks DCNL DCSP self.title.set_y(1.05) DCNL DCSP self.xaxis.tick_top() DCNL DCSP self.xaxis.set_ticks_position('both') DCNL DCSP self.xaxis.set_major_locator(mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True)) DCNL DCSP self.yaxis.set_major_locator(mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True)) DCNL DCSP return ret
def matshow(self, Z, **kwargs): DCNL DCSP Z = np.asarray(Z) DCNL DCSP (nr, nc) = Z.shape DCNL DCSP extent = [(-0.5), (nc - 0.5), (nr - 0.5), (-0.5)] DCNL DCSP kw = {'extent': extent, 'origin': 'upper', 'interpolation': 'nearest', 'aspect': 'equal'} DCNL DCSP kw.update(kwargs) DCNL DCSP im = self.imshow(Z, **kw) DCNL DCSP self.title.set_y(1.05) DCNL DCSP self.xaxis.tick_top() DCNL DCSP self.xaxis.set_ticks_position('both') DCNL DCSP self.xaxis.set_major_locator(mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True)) DCNL DCSP self.yaxis.set_major_locator(mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True)) DCNL DCSP return im
def __init__(self, fig, *args, **kwargs): DCNL DCSP self.figure = fig DCNL DCSP if (len(args) == 1): DCNL DCSP  DCSP s = str(args[0]) DCNL DCSP  DCSP if (len(s) != 3): DCNL DCSP  DCSP  DCSP raise ValueError('Argument DCSP to DCSP subplot DCSP must DCSP be DCSP a DCSP 3 DCSP digits DCSP long') DCNL DCSP  DCSP (rows, cols, num) = map(int, s) DCNL DCSP elif (len(args) == 3): DCNL DCSP  DCSP (rows, cols, num) = args DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Illegal DCSP argument DCSP to DCSP subplot') DCNL DCSP total = (rows * cols) DCNL DCSP num -= 1 DCNL DCSP if (num >= total): DCNL DCSP  DCSP raise ValueError('Subplot DCSP number DCSP exceeds DCSP total DCSP subplots') DCNL DCSP self._rows = rows DCNL DCSP self._cols = cols DCNL DCSP self._num = num DCNL DCSP self.update_params() DCNL DCSP self._axes_class.__init__(self, fig, self.figbox, **kwargs)
def get_geometry(self): DCNL DCSP return (self._rows, self._cols, (self._num + 1))
def change_geometry(self, numrows, numcols, num): DCNL DCSP self._rows = numrows DCNL DCSP self._cols = numcols DCNL DCSP self._num = (num - 1) DCNL DCSP self.update_params() DCNL DCSP self.set_position(self.figbox)
def update_params(self): DCNL DCSP rows = self._rows DCNL DCSP cols = self._cols DCNL DCSP num = self._num DCNL DCSP pars = self.figure.subplotpars DCNL DCSP left = pars.left DCNL DCSP right = pars.right DCNL DCSP bottom = pars.bottom DCNL DCSP top = pars.top DCNL DCSP wspace = pars.wspace DCNL DCSP hspace = pars.hspace DCNL DCSP totWidth = (right - left) DCNL DCSP totHeight = (top - bottom) DCNL DCSP figH = (totHeight / (rows + (hspace * (rows - 1)))) DCNL DCSP sepH = (hspace * figH) DCNL DCSP figW = (totWidth / (cols + (wspace * (cols - 1)))) DCNL DCSP sepW = (wspace * figW) DCNL DCSP (rowNum, colNum) = divmod(num, cols) DCNL DCSP figBottom = ((top - ((rowNum + 1) * figH)) - (rowNum * sepH)) DCNL DCSP figLeft = (left + (colNum * (figW + sepW))) DCNL DCSP self.figbox = mtransforms.Bbox.from_bounds(figLeft, figBottom, figW, figH) DCNL DCSP self.rowNum = rowNum DCNL DCSP self.colNum = colNum DCNL DCSP self.numRows = rows DCNL DCSP self.numCols = cols DCNL DCSP if 0: DCNL DCSP  DCSP print 'rcn', rows, cols, num DCNL DCSP  DCSP print 'lbrt', left, bottom, right, top DCNL DCSP  DCSP print 'self.figBottom', self.figBottom DCNL DCSP  DCSP print 'self.figLeft', self.figLeft DCNL DCSP  DCSP print 'self.figW', self.figW DCNL DCSP  DCSP print 'self.figH', self.figH DCNL DCSP  DCSP print 'self.rowNum', self.rowNum DCNL DCSP  DCSP print 'self.colNum', self.colNum DCNL DCSP  DCSP print 'self.numRows', self.numRows DCNL DCSP  DCSP print 'self.numCols', self.numCols
def label_outer(self): DCNL DCSP lastrow = self.is_last_row() DCNL DCSP firstcol = self.is_first_col() DCNL DCSP for label in self.get_xticklabels(): DCNL DCSP  DCSP label.set_visible(lastrow) DCNL DCSP for label in self.get_yticklabels(): DCNL DCSP  DCSP label.set_visible(firstcol)
def __init__(self, filename, dpi): DCNL DCSP matplotlib.verbose.report(('Dvi: DCSP ' + filename), 'debug') DCNL DCSP self.file = open(filename, 'rb') DCNL DCSP self.dpi = dpi DCNL DCSP self.fonts = {} DCNL DCSP self.state = _dvistate.pre
def __iter__(self): DCNL DCSP while True: DCNL DCSP  DCSP have_page = self._read() DCNL DCSP  DCSP if have_page: DCNL DCSP  DCSP  DCSP (yield self._output()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
def close(self): DCNL DCSP if (not self.file.closed): DCNL DCSP  DCSP self.file.close()
def _output(self): DCNL DCSP (minx, miny, maxx, maxy) = (np.inf, np.inf, (- np.inf), (- np.inf)) DCNL DCSP maxy_pure = (- np.inf) DCNL DCSP for elt in (self.text + self.boxes): DCNL DCSP  DCSP if (len(elt) == 4): DCNL DCSP  DCSP  DCSP (x, y, h, w) = elt DCNL DCSP  DCSP  DCSP e = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (x, y, font, g, w) = elt DCNL DCSP  DCSP  DCSP h = _mul2012(font._scale, font._tfm.height[g]) DCNL DCSP  DCSP  DCSP e = _mul2012(font._scale, font._tfm.depth[g]) DCNL DCSP  DCSP minx = min(minx, x) DCNL DCSP  DCSP miny = min(miny, (y - h)) DCNL DCSP  DCSP maxx = max(maxx, (x + w)) DCNL DCSP  DCSP maxy = max(maxy, (y + e)) DCNL DCSP  DCSP maxy_pure = max(maxy_pure, y) DCNL DCSP if (self.dpi is None): DCNL DCSP  DCSP return mpl_cbook.Bunch(text=self.text, boxes=self.boxes, width=(maxx - minx), height=(maxy_pure - miny), descent=(maxy - maxy_pure)) DCNL DCSP d = (self.dpi / (72.27 * (2 ** 16))) DCNL DCSP text = [(((x - minx) * d), ((maxy - y) * d), f, g, (w * d)) for (x, y, f, g, w) in self.text] DCNL DCSP boxes = [(((x - minx) * d), ((maxy - y) * d), (h * d), (w * d)) for (x, y, h, w) in self.boxes] DCNL DCSP return mpl_cbook.Bunch(text=text, boxes=boxes, width=((maxx - minx) * d), height=((maxy_pure - miny) * d), descent=((maxy - maxy_pure) * d))
def _read(self): DCNL DCSP while True: DCNL DCSP  DCSP byte = ord(self.file.read(1)) DCNL DCSP  DCSP self._dispatch(byte) DCNL DCSP  DCSP if (byte == 140): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if (self.state == _dvistate.post_post): DCNL DCSP  DCSP  DCSP self.close() DCNL DCSP  DCSP  DCSP return False
def _arg(self, nbytes, signed=False): DCNL DCSP str = self.file.read(nbytes) DCNL DCSP value = ord(str[0]) DCNL DCSP if (signed and (value >= 128)): DCNL DCSP  DCSP value = (value - 256) DCNL DCSP for i in range(1, nbytes): DCNL DCSP  DCSP value = ((256 * value) + ord(str[i])) DCNL DCSP return value
def _dispatch(self, byte): DCNL DCSP if (0 <= byte <= 127): DCNL DCSP  DCSP self._set_char(byte) DCNL DCSP elif (byte == 128): DCNL DCSP  DCSP self._set_char(self._arg(1)) DCNL DCSP elif (byte == 129): DCNL DCSP  DCSP self._set_char(self._arg(2)) DCNL DCSP elif (byte == 130): DCNL DCSP  DCSP self._set_char(self._arg(3)) DCNL DCSP elif (byte == 131): DCNL DCSP  DCSP self._set_char(self._arg(4, True)) DCNL DCSP elif (byte == 132): DCNL DCSP  DCSP self._set_rule(self._arg(4, True), self._arg(4, True)) DCNL DCSP elif (byte == 133): DCNL DCSP  DCSP self._put_char(self._arg(1)) DCNL DCSP elif (byte == 134): DCNL DCSP  DCSP self._put_char(self._arg(2)) DCNL DCSP elif (byte == 135): DCNL DCSP  DCSP self._put_char(self._arg(3)) DCNL DCSP elif (byte == 136): DCNL DCSP  DCSP self._put_char(self._arg(4, True)) DCNL DCSP elif (byte == 137): DCNL DCSP  DCSP self._put_rule(self._arg(4, True), self._arg(4, True)) DCNL DCSP elif (byte == 138): DCNL DCSP  DCSP self._nop() DCNL DCSP elif (byte == 139): DCNL DCSP  DCSP self._bop(*[self._arg(4, True) for i in range(11)]) DCNL DCSP elif (byte == 140): DCNL DCSP  DCSP self._eop() DCNL DCSP elif (byte == 141): DCNL DCSP  DCSP self._push() DCNL DCSP elif (byte == 142): DCNL DCSP  DCSP self._pop() DCNL DCSP elif (byte == 143): DCNL DCSP  DCSP self._right(self._arg(1, True)) DCNL DCSP elif (byte == 144): DCNL DCSP  DCSP self._right(self._arg(2, True)) DCNL DCSP elif (byte == 145): DCNL DCSP  DCSP self._right(self._arg(3, True)) DCNL DCSP elif (byte == 146): DCNL DCSP  DCSP self._right(self._arg(4, True)) DCNL DCSP elif (byte == 147): DCNL DCSP  DCSP self._right_w(None) DCNL DCSP elif (byte == 148): DCNL DCSP  DCSP self._right_w(self._arg(1, True)) DCNL DCSP elif (byte == 149): DCNL DCSP  DCSP self._right_w(self._arg(2, True)) DCNL DCSP elif (byte == 150): DCNL DCSP  DCSP self._right_w(self._arg(3, True)) DCNL DCSP elif (byte == 151): DCNL DCSP  DCSP self._right_w(self._arg(4, True)) DCNL DCSP elif (byte == 152): DCNL DCSP  DCSP self._right_x(None) DCNL DCSP elif (byte == 153): DCNL DCSP  DCSP self._right_x(self._arg(1, True)) DCNL DCSP elif (byte == 154): DCNL DCSP  DCSP self._right_x(self._arg(2, True)) DCNL DCSP elif (byte == 155): DCNL DCSP  DCSP self._right_x(self._arg(3, True)) DCNL DCSP elif (byte == 156): DCNL DCSP  DCSP self._right_x(self._arg(4, True)) DCNL DCSP elif (byte == 157): DCNL DCSP  DCSP self._down(self._arg(1, True)) DCNL DCSP elif (byte == 158): DCNL DCSP  DCSP self._down(self._arg(2, True)) DCNL DCSP elif (byte == 159): DCNL DCSP  DCSP self._down(self._arg(3, True)) DCNL DCSP elif (byte == 160): DCNL DCSP  DCSP self._down(self._arg(4, True)) DCNL DCSP elif (byte == 161): DCNL DCSP  DCSP self._down_y(None) DCNL DCSP elif (byte == 162): DCNL DCSP  DCSP self._down_y(self._arg(1, True)) DCNL DCSP elif (byte == 163): DCNL DCSP  DCSP self._down_y(self._arg(2, True)) DCNL DCSP elif (byte == 164): DCNL DCSP  DCSP self._down_y(self._arg(3, True)) DCNL DCSP elif (byte == 165): DCNL DCSP  DCSP self._down_y(self._arg(4, True)) DCNL DCSP elif (byte == 166): DCNL DCSP  DCSP self._down_z(None) DCNL DCSP elif (byte == 167): DCNL DCSP  DCSP self._down_z(self._arg(1, True)) DCNL DCSP elif (byte == 168): DCNL DCSP  DCSP self._down_z(self._arg(2, True)) DCNL DCSP elif (byte == 169): DCNL DCSP  DCSP self._down_z(self._arg(3, True)) DCNL DCSP elif (byte == 170): DCNL DCSP  DCSP self._down_z(self._arg(4, True)) DCNL DCSP elif (171 <= byte <= 234): DCNL DCSP  DCSP self._fnt_num((byte - 171)) DCNL DCSP elif (byte == 235): DCNL DCSP  DCSP self._fnt_num(self._arg(1)) DCNL DCSP elif (byte == 236): DCNL DCSP  DCSP self._fnt_num(self._arg(2)) DCNL DCSP elif (byte == 237): DCNL DCSP  DCSP self._fnt_num(self._arg(3)) DCNL DCSP elif (byte == 238): DCNL DCSP  DCSP self._fnt_num(self._arg(4, True)) DCNL DCSP elif (239 <= byte <= 242): DCNL DCSP  DCSP len = self._arg((byte - 238)) DCNL DCSP  DCSP special = self.file.read(len) DCNL DCSP  DCSP self._xxx(special) DCNL DCSP elif (243 <= byte <= 246): DCNL DCSP  DCSP k = self._arg((byte - 242), (byte == 246)) DCNL DCSP  DCSP (c, s, d, a, l) = [self._arg(x) for x in (4, 4, 4, 1, 1)] DCNL DCSP  DCSP n = self.file.read((a + l)) DCNL DCSP  DCSP self._fnt_def(k, c, s, d, a, l, n) DCNL DCSP elif (byte == 247): DCNL DCSP  DCSP (i, num, den, mag, k) = [self._arg(x) for x in (1, 4, 4, 4, 1)] DCNL DCSP  DCSP x = self.file.read(k) DCNL DCSP  DCSP self._pre(i, num, den, mag, x) DCNL DCSP elif (byte == 248): DCNL DCSP  DCSP self._post() DCNL DCSP elif (byte == 249): DCNL DCSP  DCSP self._post_post() DCNL DCSP else: DCNL DCSP  DCSP raise ValueError, ('unknown DCSP command: DCSP byte DCSP %d' % byte)
def _width_of(self, char): DCNL DCSP width = self._tfm.width.get(char, None) DCNL DCSP if (width is not None): DCNL DCSP  DCSP return _mul2012(width, self._scale) DCNL DCSP matplotlib.verbose.report(('No DCSP width DCSP for DCSP char DCSP %d DCSP in DCSP font DCSP %s' % (char, self.texname)), 'debug') DCNL DCSP return 0
def _parse(self, file): DCNL DCSP for line in file: DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if ((line == '') or line.startswith('%')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (words, pos) = ([], 0) DCNL DCSP  DCSP while (pos < len(line)): DCNL DCSP  DCSP  DCSP if (line[pos] == '"'): DCNL DCSP  DCSP  DCSP  DCSP pos += 1 DCNL DCSP  DCSP  DCSP  DCSP end = line.index('"', pos) DCNL DCSP  DCSP  DCSP  DCSP words.append(line[pos:end]) DCNL DCSP  DCSP  DCSP  DCSP pos = (end + 1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP end = line.find(' DCSP ', (pos + 1)) DCNL DCSP  DCSP  DCSP  DCSP if (end == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP end = len(line) DCNL DCSP  DCSP  DCSP  DCSP words.append(line[pos:end]) DCNL DCSP  DCSP  DCSP  DCSP pos = end DCNL DCSP  DCSP  DCSP while ((pos < len(line)) and (line[pos] == ' DCSP ')): DCNL DCSP  DCSP  DCSP  DCSP pos += 1 DCNL DCSP  DCSP self._register(words)
def _register(self, words): DCNL DCSP (texname, psname) = words[:2] DCNL DCSP (effects, encoding, filename) = ([], None, None) DCNL DCSP for word in words[2:]: DCNL DCSP  DCSP if (not word.startswith('<')): DCNL DCSP  DCSP  DCSP effects.append(word) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP word = word.lstrip('<') DCNL DCSP  DCSP  DCSP if word.startswith('['): DCNL DCSP  DCSP  DCSP  DCSP assert (encoding is None) DCNL DCSP  DCSP  DCSP  DCSP encoding = word[1:] DCNL DCSP  DCSP  DCSP elif word.endswith('.enc'): DCNL DCSP  DCSP  DCSP  DCSP assert (encoding is None) DCNL DCSP  DCSP  DCSP  DCSP encoding = word DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (filename is None) DCNL DCSP  DCSP  DCSP  DCSP filename = word DCNL DCSP self._font[texname] = mpl_cbook.Bunch(texname=texname, psname=psname, effects=effects, encoding=encoding, filename=filename)
def __init__(self, edgecolors=None, facecolors=None, linewidths=None, linestyles='solid', antialiaseds=None, offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5.0, urls=None, **kwargs): DCNL DCSP artist.Artist.__init__(self) DCNL DCSP cm.ScalarMappable.__init__(self, norm, cmap) DCNL DCSP self.set_edgecolor(edgecolors) DCNL DCSP self.set_facecolor(facecolors) DCNL DCSP self.set_linewidth(linewidths) DCNL DCSP self.set_linestyle(linestyles) DCNL DCSP self.set_antialiased(antialiaseds) DCNL DCSP self.set_urls(urls) DCNL DCSP self._uniform_offsets = None DCNL DCSP self._offsets = np.array([], np.float_) DCNL DCSP if (offsets is not None): DCNL DCSP  DCSP offsets = np.asarray(offsets) DCNL DCSP  DCSP if (len(offsets.shape) == 1): DCNL DCSP  DCSP  DCSP offsets = offsets[np.newaxis, :] DCNL DCSP  DCSP if (transOffset is not None): DCNL DCSP  DCSP  DCSP self._offsets = offsets DCNL DCSP  DCSP  DCSP self._transOffset = transOffset DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._uniform_offsets = offsets DCNL DCSP self._pickradius = pickradius DCNL DCSP self.update(kwargs)
def _prepare_points(self): DCNL DCSP transform = self.get_transform() DCNL DCSP transOffset = self._transOffset DCNL DCSP offsets = self._offsets DCNL DCSP paths = self.get_paths() DCNL DCSP if self.have_units(): DCNL DCSP  DCSP paths = [] DCNL DCSP  DCSP for path in self.get_paths(): DCNL DCSP  DCSP  DCSP vertices = path.vertices DCNL DCSP  DCSP  DCSP (xs, ys) = (vertices[:, 0], vertices[:, 1]) DCNL DCSP  DCSP  DCSP xs = self.convert_xunits(xs) DCNL DCSP  DCSP  DCSP ys = self.convert_yunits(ys) DCNL DCSP  DCSP  DCSP paths.append(mpath.Path(zip(xs, ys), path.codes)) DCNL DCSP  DCSP if len(self._offsets): DCNL DCSP  DCSP  DCSP xs = self.convert_xunits(self._offsets[:0]) DCNL DCSP  DCSP  DCSP ys = self.convert_yunits(self._offsets[:1]) DCNL DCSP  DCSP  DCSP offsets = zip(xs, ys) DCNL DCSP offsets = np.asarray(offsets, np.float_) DCNL DCSP if (not transform.is_affine): DCNL DCSP  DCSP paths = [transform.transform_path_non_affine(path) for path in paths] DCNL DCSP  DCSP transform = transform.get_affine() DCNL DCSP if (not transOffset.is_affine): DCNL DCSP  DCSP offsets = transOffset.transform_non_affine(offsets) DCNL DCSP  DCSP transOffset = transOffset.get_affine() DCNL DCSP return (transform, transOffset, offsets, paths)
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP if (not self.get_visible()): DCNL DCSP  DCSP return (False, {}) DCNL DCSP (transform, transOffset, offsets, paths) = self._prepare_points() DCNL DCSP ind = mpath.point_in_path_collection(mouseevent.x, mouseevent.y, self._pickradius, transform.frozen(), paths, self.get_transforms(), offsets, transOffset, (len(self._facecolors) > 0)) DCNL DCSP return ((len(ind) > 0), dict(ind=ind))
def set_offsets(self, offsets): DCNL DCSP offsets = np.asarray(offsets, np.float_) DCNL DCSP if (len(offsets.shape) == 1): DCNL DCSP  DCSP offsets = offsets[np.newaxis, :] DCNL DCSP if (self._uniform_offsets is None): DCNL DCSP  DCSP self._offsets = offsets DCNL DCSP else: DCNL DCSP  DCSP self._uniform_offsets = offsets
def get_offsets(self): DCNL DCSP if (self._uniform_offsets is None): DCNL DCSP  DCSP return self._offsets DCNL DCSP else: DCNL DCSP  DCSP return self._uniform_offsets
def set_linewidth(self, lw): DCNL DCSP if (lw is None): DCNL DCSP  DCSP lw = mpl.rcParams['patch.linewidth'] DCNL DCSP self._linewidths = self._get_value(lw)
def set_linewidths(self, lw): DCNL DCSP return self.set_linewidth(lw)
def set_lw(self, lw): DCNL DCSP return self.set_linewidth(lw)
def set_linestyle(self, ls): DCNL DCSP try: DCNL DCSP  DCSP dashd = backend_bases.GraphicsContextBase.dashd DCNL DCSP  DCSP if cbook.is_string_like(ls): DCNL DCSP  DCSP  DCSP if (ls in dashd): DCNL DCSP  DCSP  DCSP  DCSP dashes = [dashd[ls]] DCNL DCSP  DCSP  DCSP elif (ls in cbook.ls_mapper): DCNL DCSP  DCSP  DCSP  DCSP dashes = [dashd[cbook.ls_mapper[ls]]] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError() DCNL DCSP  DCSP elif cbook.iterable(ls): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP dashes = [] DCNL DCSP  DCSP  DCSP  DCSP for x in ls: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if cbook.is_string_like(x): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (x in dashd): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dashes.append(dashd[x]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (x in cbook.ls_mapper): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dashes.append(dashd[cbook.ls_mapper[x]]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError() DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (cbook.iterable(x) and (len(x) == 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dashes.append(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError() DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP if (len(ls) == 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP dashes = ls DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError() DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(('Do DCSP not DCSP know DCSP how DCSP to DCSP convert DCSP %s DCSP to DCSP dashes' % ls)) DCNL DCSP self._linestyles = dashes
def set_linestyles(self, ls): DCNL DCSP return self.set_linestyle(ls)
def set_dashes(self, ls): DCNL DCSP return self.set_linestyle(ls)
def set_antialiased(self, aa): DCNL DCSP if (aa is None): DCNL DCSP  DCSP aa = mpl.rcParams['patch.antialiased'] DCNL DCSP self._antialiaseds = self._get_bool(aa)
def set_antialiaseds(self, aa): DCNL DCSP return self.set_antialiased(aa)
def set_color(self, c): DCNL DCSP self.set_facecolor(c) DCNL DCSP self.set_edgecolor(c)
def set_facecolor(self, c): DCNL DCSP if (c is None): DCNL DCSP  DCSP c = mpl.rcParams['patch.facecolor'] DCNL DCSP self._facecolors_original = c DCNL DCSP self._facecolors = _colors.colorConverter.to_rgba_array(c, self._alpha)
def set_facecolors(self, c): DCNL DCSP return self.set_facecolor(c)
def set_edgecolor(self, c): DCNL DCSP if (c == 'face'): DCNL DCSP  DCSP self._edgecolors = 'face' DCNL DCSP  DCSP self._edgecolors_original = 'face' DCNL DCSP else: DCNL DCSP  DCSP if (c is None): DCNL DCSP  DCSP  DCSP c = mpl.rcParams['patch.edgecolor'] DCNL DCSP  DCSP self._edgecolors_original = c DCNL DCSP  DCSP self._edgecolors = _colors.colorConverter.to_rgba_array(c, self._alpha)
def set_edgecolors(self, c): DCNL DCSP return self.set_edgecolor(c)
def set_alpha(self, alpha): DCNL DCSP try: DCNL DCSP  DCSP float(alpha) DCNL DCSP except TypeError: DCNL DCSP  DCSP raise TypeError('alpha DCSP must DCSP be DCSP a DCSP float') DCNL DCSP else: DCNL DCSP  DCSP artist.Artist.set_alpha(self, alpha) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self._facecolors = _colors.colorConverter.to_rgba_array(self._facecolors_original, self._alpha) DCNL DCSP  DCSP except (AttributeError, TypeError, IndexError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (self._edgecolors_original != 'face'): DCNL DCSP  DCSP  DCSP  DCSP self._edgecolors = _colors.colorConverter.to_rgba_array(self._edgecolors_original, self._alpha) DCNL DCSP  DCSP except (AttributeError, TypeError, IndexError): DCNL DCSP  DCSP  DCSP pass
def update_scalarmappable(self): DCNL DCSP if (self._A is None): DCNL DCSP  DCSP return DCNL DCSP if (self._A.ndim > 1): DCNL DCSP  DCSP raise ValueError('Collections DCSP can DCSP only DCSP map DCSP rank DCSP 1 DCSP arrays') DCNL DCSP if len(self._facecolors): DCNL DCSP  DCSP self._facecolors = self.to_rgba(self._A, self._alpha) DCNL DCSP else: DCNL DCSP  DCSP self._edgecolors = self.to_rgba(self._A, self._alpha)
def update_from(self, other): DCNL DCSP artist.Artist.update_from(self, other) DCNL DCSP self._antialiaseds = other._antialiaseds DCNL DCSP self._edgecolors_original = other._edgecolors_original DCNL DCSP self._edgecolors = other._edgecolors DCNL DCSP self._facecolors_original = other._facecolors_original DCNL DCSP self._facecolors = other._facecolors DCNL DCSP self._linewidths = other._linewidths DCNL DCSP self._linestyles = other._linestyles DCNL DCSP self._pickradius = other._pickradius
def convert_mesh_to_paths(meshWidth, meshHeight, coordinates): DCNL DCSP Path = mpath.Path DCNL DCSP if ma.isMaskedArray(coordinates): DCNL DCSP  DCSP c = coordinates.data DCNL DCSP else: DCNL DCSP  DCSP c = coordinates DCNL DCSP points = np.concatenate((c[0:(-1), 0:(-1)], c[0:(-1), 1:], c[1:, 1:], c[1:, 0:(-1)], c[0:(-1), 0:(-1)]), axis=2) DCNL DCSP points = points.reshape(((meshWidth * meshHeight), 5, 2)) DCNL DCSP return [Path(x) for x in points]
def __init__(self, verts, sizes=None, closed=True, **kwargs): DCNL DCSP Collection.__init__(self, **kwargs) DCNL DCSP self._sizes = sizes DCNL DCSP self.set_verts(verts, closed)
def set_verts(self, verts, closed=True): DCNL DCSP if closed: DCNL DCSP  DCSP self._paths = [] DCNL DCSP  DCSP for xy in verts: DCNL DCSP  DCSP  DCSP if np.ma.isMaskedArray(xy): DCNL DCSP  DCSP  DCSP  DCSP if (len(xy) and (xy[0] != xy[(-1)]).any()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP xy = np.ma.concatenate([xy, [xy[0]]]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP xy = np.asarray(xy) DCNL DCSP  DCSP  DCSP  DCSP if (len(xy) and (xy[0] != xy[(-1)]).any()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP xy = np.concatenate([xy, [xy[0]]]) DCNL DCSP  DCSP  DCSP self._paths.append(mpath.Path(xy)) DCNL DCSP else: DCNL DCSP  DCSP self._paths = [mpath.Path(xy) for xy in verts]
def __init__(self, xranges, yrange, **kwargs): DCNL DCSP (ymin, ywidth) = yrange DCNL DCSP ymax = (ymin + ywidth) DCNL DCSP verts = [[(xmin, ymin), (xmin, ymax), ((xmin + xwidth), ymax), ((xmin + xwidth), ymin), (xmin, ymin)] for (xmin, xwidth) in xranges] DCNL DCSP PolyCollection.__init__(self, verts, **kwargs)
@staticmethod DCNL def span_where(x, ymin, ymax, where, **kwargs): DCNL DCSP xranges = [] DCNL DCSP for (ind0, ind1) in mlab.contiguous_regions(where): DCNL DCSP  DCSP xslice = x[ind0:ind1] DCNL DCSP  DCSP if (not len(xslice)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP xranges.append((xslice[0], (xslice[(-1)] - xslice[0]))) DCNL DCSP collection = BrokenBarHCollection(xranges, [ymin, (ymax - ymin)], **kwargs) DCNL DCSP return collection
def __init__(self, numsides, rotation=0, sizes=(1,), **kwargs): DCNL DCSP Collection.__init__(self, **kwargs) DCNL DCSP self._sizes = sizes DCNL DCSP self._numsides = numsides DCNL DCSP self._paths = [self._path_generator(numsides)] DCNL DCSP self._rotation = rotation DCNL DCSP self.set_transform(transforms.IdentityTransform())
def __init__(self, segments, linewidths=None, colors=None, antialiaseds=None, linestyles='solid', offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5, **kwargs): DCNL DCSP if (colors is None): DCNL DCSP  DCSP colors = mpl.rcParams['lines.color'] DCNL DCSP if (linewidths is None): DCNL DCSP  DCSP linewidths = (mpl.rcParams['lines.linewidth'],) DCNL DCSP if (antialiaseds is None): DCNL DCSP  DCSP antialiaseds = (mpl.rcParams['lines.antialiased'],) DCNL DCSP self.set_linestyles(linestyles) DCNL DCSP colors = _colors.colorConverter.to_rgba_array(colors) DCNL DCSP Collection.__init__(self, edgecolors=colors, linewidths=linewidths, linestyles=linestyles, antialiaseds=antialiaseds, offsets=offsets, transOffset=transOffset, norm=norm, cmap=cmap, pickradius=pickradius, **kwargs) DCNL DCSP self.set_facecolors([]) DCNL DCSP self.set_segments(segments)
def set_color(self, c): DCNL DCSP self._edgecolors = _colors.colorConverter.to_rgba_array(c)
def color(self, c): DCNL DCSP warnings.warn('LineCollection.color DCSP deprecated; DCSP use DCSP set_color DCSP instead') DCNL DCSP return self.set_color(c)
def __init__(self, sizes, **kwargs): DCNL DCSP Collection.__init__(self, **kwargs) DCNL DCSP self._sizes = sizes DCNL DCSP self.set_transform(transforms.IdentityTransform()) DCNL DCSP self._paths = [mpath.Path.unit_circle()]
def __init__(self, widths, heights, angles, units='points', **kwargs): DCNL DCSP Collection.__init__(self, **kwargs) DCNL DCSP self._widths = np.asarray(widths).ravel() DCNL DCSP self._heights = np.asarray(heights).ravel() DCNL DCSP self._angles = (np.asarray(angles).ravel() * (np.pi / 180.0)) DCNL DCSP self._units = units DCNL DCSP self.set_transform(transforms.IdentityTransform()) DCNL DCSP self._transforms = [] DCNL DCSP self._paths = [mpath.Path.unit_circle()] DCNL DCSP self._initialized = False
def __init__(self, patches, match_original=False, **kwargs): DCNL DCSP if match_original: DCNL DCSP  DCSP def determine_facecolor(patch): DCNL DCSP  DCSP  DCSP if patch.fill: DCNL DCSP  DCSP  DCSP  DCSP return patch.get_facecolor() DCNL DCSP  DCSP  DCSP return [0, 0, 0, 0] DCNL DCSP  DCSP facecolors = [determine_facecolor(p) for p in patches] DCNL DCSP  DCSP edgecolors = [p.get_edgecolor() for p in patches] DCNL DCSP  DCSP linewidths = [p.get_linewidths() for p in patches] DCNL DCSP  DCSP antialiaseds = [p.get_antialiased() for p in patches] DCNL DCSP  DCSP Collection.__init__(self, edgecolors=edgecolors, facecolors=facecolors, linewidths=linewidths, linestyles='solid', antialiaseds=antialiaseds) DCNL DCSP else: DCNL DCSP  DCSP Collection.__init__(self, **kwargs) DCNL DCSP paths = [p.get_transform().transform_path(p.get_path()) for p in patches] DCNL DCSP self._paths = paths
def __init__(self, fh): DCNL DCSP (dhead, dcmetrics_ascii, dcmetrics_name, dkernpairs, dcomposite) = parse_afm(fh) DCNL DCSP self._header = dhead DCNL DCSP self._kern = dkernpairs DCNL DCSP self._metrics = dcmetrics_ascii DCNL DCSP self._metrics_by_name = dcmetrics_name DCNL DCSP self._composite = dcomposite
def string_width_height(self, s): DCNL DCSP if (not len(s)): DCNL DCSP  DCSP return (0, 0) DCNL DCSP totalw = 0 DCNL DCSP namelast = None DCNL DCSP miny = 1000000000.0 DCNL DCSP maxy = 0 DCNL DCSP for c in s: DCNL DCSP  DCSP if (c == '\n'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (wx, name, bbox) = self._metrics[ord(c)] DCNL DCSP  DCSP (l, b, w, h) = bbox DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP kp = self._kern[(namelast, name)] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP kp = 0 DCNL DCSP  DCSP totalw += (wx + kp) DCNL DCSP  DCSP thismax = (b + h) DCNL DCSP  DCSP if (thismax > maxy): DCNL DCSP  DCSP  DCSP maxy = thismax DCNL DCSP  DCSP thismin = b DCNL DCSP  DCSP if (thismin < miny): DCNL DCSP  DCSP  DCSP miny = thismin DCNL DCSP return (totalw, (maxy - miny))
def get_str_bbox_and_descent(self, s): DCNL DCSP if (not len(s)): DCNL DCSP  DCSP return (0, 0, 0, 0) DCNL DCSP totalw = 0 DCNL DCSP namelast = None DCNL DCSP miny = 1000000000.0 DCNL DCSP maxy = 0 DCNL DCSP left = 0 DCNL DCSP if (not isinstance(s, unicode)): DCNL DCSP  DCSP s = s.decode() DCNL DCSP for c in s: DCNL DCSP  DCSP if (c == '\n'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP name = uni2type1.get(ord(c), 'question') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (wx, bbox) = self._metrics_by_name[name] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP name = 'question' DCNL DCSP  DCSP  DCSP (wx, bbox) = self._metrics_by_name[name] DCNL DCSP  DCSP (l, b, w, h) = bbox DCNL DCSP  DCSP if (l < left): DCNL DCSP  DCSP  DCSP left = l DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP kp = self._kern[(namelast, name)] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP kp = 0 DCNL DCSP  DCSP totalw += (wx + kp) DCNL DCSP  DCSP thismax = (b + h) DCNL DCSP  DCSP if (thismax > maxy): DCNL DCSP  DCSP  DCSP maxy = thismax DCNL DCSP  DCSP thismin = b DCNL DCSP  DCSP if (thismin < miny): DCNL DCSP  DCSP  DCSP miny = thismin DCNL DCSP return (left, miny, totalw, (maxy - miny), (- miny))
def get_str_bbox(self, s): DCNL DCSP return self.get_str_bbox_and_descent(s)[:4]
def get_name_char(self, c, isord=False): DCNL DCSP if (not isord): DCNL DCSP  DCSP c = ord(c) DCNL DCSP (wx, name, bbox) = self._metrics[c] DCNL DCSP return name
def get_width_char(self, c, isord=False): DCNL DCSP if (not isord): DCNL DCSP  DCSP c = ord(c) DCNL DCSP (wx, name, bbox) = self._metrics[c] DCNL DCSP return wx
def get_width_from_char_name(self, name): DCNL DCSP (wx, bbox) = self._metrics_by_name[name] DCNL DCSP return wx
def get_height_char(self, c, isord=False): DCNL DCSP if (not isord): DCNL DCSP  DCSP c = ord(c) DCNL DCSP (wx, name, bbox) = self._metrics[c] DCNL DCSP return bbox[(-1)]
def get_kern_dist(self, c1, c2): DCNL DCSP (name1, name2) = (self.get_name_char(c1), self.get_name_char(c2)) DCNL DCSP return self.get_kern_dist_from_name(name1, name2)
def get_kern_dist_from_name(self, name1, name2): DCNL DCSP try: DCNL DCSP  DCSP return self._kern[(name1, name2)] DCNL DCSP except: DCNL DCSP  DCSP return 0
def get_fontname(self): DCNL DCSP return self._header['FontName']
def get_fullname(self): DCNL DCSP name = self._header.get('FullName') DCNL DCSP if (name is None): DCNL DCSP  DCSP name = self._header['FontName'] DCNL DCSP return name
def get_familyname(self): DCNL DCSP name = self._header.get('FamilyName') DCNL DCSP if (name is not None): DCNL DCSP  DCSP return name DCNL DCSP name = self.get_fullname() DCNL DCSP extras = '(?i)([ DCSP -](regular|plain|italic|oblique|bold|semibold|light|ultralight|extra|condensed))+$' DCNL DCSP return re.sub(extras, '', name)
def get_weight(self): DCNL DCSP return self._header['Weight']
def get_angle(self): DCNL DCSP return self._header['ItalicAngle']
def get_capheight(self): DCNL DCSP return self._header['CapHeight']
def get_xheight(self): DCNL DCSP return self._header['XHeight']
def get_underline_thickness(self): DCNL DCSP return self._header['UnderlineThickness']
def get_horizontal_stem_width(self): DCNL DCSP return self._header.get('StdHW', None)
def get_vertical_stem_width(self): DCNL DCSP return self._header.get('StdVW', None)
def remove(self): DCNL DCSP if (self._remove_method != None): DCNL DCSP  DCSP self._remove_method(self) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError('cannot DCSP remove DCSP artist')
def have_units(self): DCNL DCSP ax = self.axes DCNL DCSP if ((ax is None) or (ax.xaxis is None)): DCNL DCSP  DCSP return False DCNL DCSP return (ax.xaxis.have_units() or ax.yaxis.have_units())
def convert_xunits(self, x): DCNL DCSP ax = getattr(self, 'axes', None) DCNL DCSP if ((ax is None) or (ax.xaxis is None)): DCNL DCSP  DCSP return x DCNL DCSP return ax.xaxis.convert_units(x)
def convert_yunits(self, y): DCNL DCSP ax = getattr(self, 'axes', None) DCNL DCSP if ((ax is None) or (ax.yaxis is None)): DCNL DCSP  DCSP return y DCNL DCSP return ax.yaxis.convert_units(y)
def set_axes(self, axes): DCNL DCSP self.axes = axes
def get_axes(self): DCNL DCSP return self.axes
def add_callback(self, func): DCNL DCSP oid = self._oid DCNL DCSP self._propobservers[oid] = func DCNL DCSP self._oid += 1 DCNL DCSP return oid
def remove_callback(self, oid): DCNL DCSP try: DCNL DCSP  DCSP del self._propobservers[oid] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass
def pchanged(self): DCNL DCSP for (oid, func) in self._propobservers.items(): DCNL DCSP  DCSP func(self)
def is_transform_set(self): DCNL DCSP return self._transformSet
def set_transform(self, t): DCNL DCSP self._transform = t DCNL DCSP self._transformSet = True DCNL DCSP self.pchanged()
def get_transform(self): DCNL DCSP if (self._transform is None): DCNL DCSP  DCSP self._transform = IdentityTransform() DCNL DCSP return self._transform
def hitlist(self, event): DCNL DCSP import traceback DCNL DCSP L = [] DCNL DCSP try: DCNL DCSP  DCSP (hascursor, info) = self.contains(event) DCNL DCSP  DCSP if hascursor: DCNL DCSP  DCSP  DCSP L.append(self) DCNL DCSP except: DCNL DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP print 'while DCSP checking', self.__class__ DCNL DCSP for a in self.get_children(): DCNL DCSP  DCSP L.extend(a.hitlist(event)) DCNL DCSP return L
def get_children(self): DCNL DCSP return []
def contains(self, mouseevent): DCNL DCSP if callable(self._contains): DCNL DCSP  DCSP return self._contains(self, mouseevent) DCNL DCSP warnings.warn(("'%s' DCSP needs DCSP 'contains' DCSP method" % self.__class__.__name__)) DCNL DCSP return (False, {})
def set_contains(self, picker): DCNL DCSP self._contains = picker
def get_contains(self): DCNL DCSP return self._contains
def pickable(self): DCNL DCSP return ((self.figure is not None) and (self.figure.canvas is not None) and (self._picker is not None))
def pick(self, mouseevent): DCNL DCSP if self.pickable(): DCNL DCSP  DCSP picker = self.get_picker() DCNL DCSP  DCSP if callable(picker): DCNL DCSP  DCSP  DCSP (inside, prop) = picker(self, mouseevent) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (inside, prop) = self.contains(mouseevent) DCNL DCSP  DCSP if inside: DCNL DCSP  DCSP  DCSP self.figure.canvas.pick_event(mouseevent, self, **prop) DCNL DCSP for a in self.get_children(): DCNL DCSP  DCSP a.pick(mouseevent)
def set_picker(self, picker): DCNL DCSP self._picker = picker
def get_picker(self): DCNL DCSP return self._picker
def is_figure_set(self): DCNL DCSP return (self.figure is not None)
def get_url(self): DCNL DCSP return self._url
def set_url(self, url): DCNL DCSP self._url = url
def get_snap(self): DCNL DCSP return self._snap
def set_snap(self, snap): DCNL DCSP self._snap = snap
def get_figure(self): DCNL DCSP return self.figure
def set_figure(self, fig): DCNL DCSP self.figure = fig DCNL DCSP self.pchanged()
def set_clip_box(self, clipbox): DCNL DCSP self.clipbox = clipbox DCNL DCSP self.pchanged()
def set_clip_path(self, path, transform=None): DCNL DCSP from patches import Patch, Rectangle DCNL DCSP success = False DCNL DCSP if (transform is None): DCNL DCSP  DCSP if isinstance(path, Rectangle): DCNL DCSP  DCSP  DCSP self.clipbox = TransformedBbox(Bbox.unit(), path.get_transform()) DCNL DCSP  DCSP  DCSP self._clippath = None DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP elif isinstance(path, Patch): DCNL DCSP  DCSP  DCSP self._clippath = TransformedPath(path.get_path(), path.get_transform()) DCNL DCSP  DCSP  DCSP success = True DCNL DCSP if (path is None): DCNL DCSP  DCSP self._clippath = None DCNL DCSP  DCSP success = True DCNL DCSP elif isinstance(path, Path): DCNL DCSP  DCSP self._clippath = TransformedPath(path, transform) DCNL DCSP  DCSP success = True DCNL DCSP if (not success): DCNL DCSP  DCSP print type(path), type(transform) DCNL DCSP  DCSP raise TypeError('Invalid DCSP arguments DCSP to DCSP set_clip_path') DCNL DCSP self.pchanged()
def get_alpha(self): DCNL DCSP return self._alpha
def get_visible(self): DCNL DCSP return self._visible
def get_animated(self): DCNL DCSP return self._animated
def get_clip_on(self): DCNL DCSP return self._clipon
def get_clip_box(self): DCNL DCSP return self.clipbox
def get_clip_path(self): DCNL DCSP return self._clippath
def get_transformed_clip_path_and_affine(self): DCNL DCSP if (self._clippath is not None): DCNL DCSP  DCSP return self._clippath.get_transformed_path_and_affine() DCNL DCSP return (None, None)
def set_clip_on(self, b): DCNL DCSP self._clipon = b DCNL DCSP self.pchanged()
def _set_gc_clip(self, gc): DCNL DCSP if self._clipon: DCNL DCSP  DCSP if (self.clipbox is not None): DCNL DCSP  DCSP  DCSP gc.set_clip_rectangle(self.clipbox) DCNL DCSP  DCSP gc.set_clip_path(self._clippath) DCNL DCSP else: DCNL DCSP  DCSP gc.set_clip_rectangle(None) DCNL DCSP  DCSP gc.set_clip_path(None)
def draw(self, renderer, *args, **kwargs): DCNL DCSP if (not self.get_visible()): DCNL DCSP  DCSP return
def set_alpha(self, alpha): DCNL DCSP self._alpha = alpha DCNL DCSP self.pchanged()
def set_lod(self, on): DCNL DCSP self._lod = on DCNL DCSP self.pchanged()
def set_visible(self, b): DCNL DCSP self._visible = b DCNL DCSP self.pchanged()
def set_animated(self, b): DCNL DCSP self._animated = b DCNL DCSP self.pchanged()
def update(self, props): DCNL DCSP store = self.eventson DCNL DCSP self.eventson = False DCNL DCSP changed = False DCNL DCSP for (k, v) in props.items(): DCNL DCSP  DCSP func = getattr(self, ('set_' + k), None) DCNL DCSP  DCSP if ((func is None) or (not callable(func))): DCNL DCSP  DCSP  DCSP raise AttributeError(('Unknown DCSP property DCSP %s' % k)) DCNL DCSP  DCSP func(v) DCNL DCSP  DCSP changed = True DCNL DCSP self.eventson = store DCNL DCSP if changed: DCNL DCSP  DCSP self.pchanged()
def get_label(self): DCNL DCSP return self._label
def set_label(self, s): DCNL DCSP self._label = s DCNL DCSP self.pchanged()
def get_zorder(self): DCNL DCSP return self.zorder
def set_zorder(self, level): DCNL DCSP self.zorder = level DCNL DCSP self.pchanged()
def update_from(self, other): DCNL DCSP self._transform = other._transform DCNL DCSP self._transformSet = other._transformSet DCNL DCSP self._visible = other._visible DCNL DCSP self._alpha = other._alpha DCNL DCSP self.clipbox = other.clipbox DCNL DCSP self._clipon = other._clipon DCNL DCSP self._clippath = other._clippath DCNL DCSP self._lod = other._lod DCNL DCSP self._label = other._label DCNL DCSP self.pchanged()
def set(self, **kwargs): DCNL DCSP ret = [] DCNL DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP k = k.lower() DCNL DCSP  DCSP funcName = ('set_%s' % k) DCNL DCSP  DCSP func = getattr(self, funcName) DCNL DCSP  DCSP ret.extend([func(v)]) DCNL DCSP return ret
def findobj(self, match=None): DCNL DCSP if (match is None): DCNL DCSP  DCSP def matchfunc(x): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif cbook.issubclass_safe(match, Artist): DCNL DCSP  DCSP def matchfunc(x): DCNL DCSP  DCSP  DCSP return isinstance(x, match) DCNL DCSP elif callable(match): DCNL DCSP  DCSP matchfunc = match DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('match DCSP must DCSP be DCSP None, DCSP an DCSP matplotlib.artist.Artist DCSP subclass, DCSP or DCSP a DCSP callable') DCNL DCSP artists = [] DCNL DCSP for c in self.get_children(): DCNL DCSP  DCSP if matchfunc(c): DCNL DCSP  DCSP  DCSP artists.append(c) DCNL DCSP  DCSP artists.extend([thisc for thisc in c.findobj(matchfunc) if matchfunc(thisc)]) DCNL DCSP if matchfunc(self): DCNL DCSP  DCSP artists.append(self) DCNL DCSP return artists
def __init__(self, o): DCNL DCSP if (cbook.iterable(o) and len(o)): DCNL DCSP  DCSP o = o[0] DCNL DCSP self.oorig = o DCNL DCSP if (not isinstance(o, type)): DCNL DCSP  DCSP o = type(o) DCNL DCSP self.o = o DCNL DCSP self.aliasd = self.get_aliases()
def get_aliases(self): DCNL DCSP names = [name for name in dir(self.o) if ((name.startswith('set_') or name.startswith('get_')) and callable(getattr(self.o, name)))] DCNL DCSP aliases = {} DCNL DCSP for name in names: DCNL DCSP  DCSP func = getattr(self.o, name) DCNL DCSP  DCSP if (not self.is_alias(func)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP docstring = func.__doc__ DCNL DCSP  DCSP fullname = docstring[10:] DCNL DCSP  DCSP aliases.setdefault(fullname[4:], {})[name[4:]] = None DCNL DCSP return aliases
def get_valid_values(self, attr): DCNL DCSP name = ('set_%s' % attr) DCNL DCSP if (not hasattr(self.o, name)): DCNL DCSP  DCSP raise AttributeError(('%s DCSP has DCSP no DCSP function DCSP %s' % (self.o, name))) DCNL DCSP func = getattr(self.o, name) DCNL DCSP docstring = func.__doc__ DCNL DCSP if (docstring is None): DCNL DCSP  DCSP return 'unknown' DCNL DCSP if docstring.startswith('alias DCSP for DCSP '): DCNL DCSP  DCSP return None DCNL DCSP match = self._get_valid_values_regex.search(docstring) DCNL DCSP if (match is not None): DCNL DCSP  DCSP return match.group(1).replace('\n', ' DCSP ') DCNL DCSP return 'unknown'
def _get_setters_and_targets(self): DCNL DCSP setters = [] DCNL DCSP for name in dir(self.o): DCNL DCSP  DCSP if (not name.startswith('set_')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP o = getattr(self.o, name) DCNL DCSP  DCSP if (not callable(o)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP func = o DCNL DCSP  DCSP if self.is_alias(func): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP source_class = ((self.o.__module__ + '.') + self.o.__name__) DCNL DCSP  DCSP for cls in self.o.mro(): DCNL DCSP  DCSP  DCSP if (name in cls.__dict__): DCNL DCSP  DCSP  DCSP  DCSP source_class = ((cls.__module__ + '.') + cls.__name__) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP setters.append((name[4:], ((source_class + '.') + name))) DCNL DCSP return setters
def get_setters(self): DCNL DCSP return [prop for (prop, target) in self._get_setters_and_targets()]
def is_alias(self, o): DCNL DCSP ds = o.__doc__ DCNL DCSP if (ds is None): DCNL DCSP  DCSP return False DCNL DCSP return ds.startswith('alias DCSP for DCSP ')
def aliased_name(self, s): DCNL DCSP if (s in self.aliasd): DCNL DCSP  DCSP return (s + ''.join([(' DCSP or DCSP %s' % x) for x in self.aliasd[s].keys()])) DCNL DCSP else: DCNL DCSP  DCSP return s
def aliased_name_rest(self, s, target): DCNL DCSP if (s in self.aliasd): DCNL DCSP  DCSP aliases = ''.join([(' DCSP or DCSP %s' % x) for x in self.aliasd[s].keys()]) DCNL DCSP else: DCNL DCSP  DCSP aliases = '' DCNL DCSP return (':meth:`%s DCSP <%s>`%s' % (s, target, aliases))
def pprint_setters(self, prop=None, leadingspace=2): DCNL DCSP if leadingspace: DCNL DCSP  DCSP pad = (' DCSP ' * leadingspace) DCNL DCSP else: DCNL DCSP  DCSP pad = '' DCNL DCSP if (prop is not None): DCNL DCSP  DCSP accepts = self.get_valid_values(prop) DCNL DCSP  DCSP return ('%s%s: DCSP %s' % (pad, prop, accepts)) DCNL DCSP attrs = self._get_setters_and_targets() DCNL DCSP attrs.sort() DCNL DCSP lines = [] DCNL DCSP for (prop, path) in attrs: DCNL DCSP  DCSP accepts = self.get_valid_values(prop) DCNL DCSP  DCSP name = self.aliased_name(prop) DCNL DCSP  DCSP lines.append(('%s%s: DCSP %s' % (pad, name, accepts))) DCNL DCSP return lines
def pprint_setters_rest(self, prop=None, leadingspace=2): DCNL DCSP if leadingspace: DCNL DCSP  DCSP pad = (' DCSP ' * leadingspace) DCNL DCSP else: DCNL DCSP  DCSP pad = '' DCNL DCSP if (prop is not None): DCNL DCSP  DCSP accepts = self.get_valid_values(prop) DCNL DCSP  DCSP return ('%s%s: DCSP %s' % (pad, prop, accepts)) DCNL DCSP attrs = self._get_setters_and_targets() DCNL DCSP attrs.sort() DCNL DCSP lines = [] DCNL DCSP names = [self.aliased_name_rest(prop, target) for (prop, target) in attrs] DCNL DCSP accepts = [self.get_valid_values(prop) for (prop, target) in attrs] DCNL DCSP col0_len = max([len(n) for n in names]) DCNL DCSP col1_len = max([len(a) for a in accepts]) DCNL DCSP table_formatstr = (((pad + ('=' * col0_len)) + ' DCSP  DCSP  DCSP ') + ('=' * col1_len)) DCNL DCSP lines.append('') DCNL DCSP lines.append(table_formatstr) DCNL DCSP lines.append(((pad + 'Property'.ljust((col0_len + 3))) + 'Description'.ljust(col1_len))) DCNL DCSP lines.append(table_formatstr) DCNL DCSP lines.extend([((pad + n.ljust((col0_len + 3))) + a.ljust(col1_len)) for (n, a) in zip(names, accepts)]) DCNL DCSP lines.append(table_formatstr) DCNL DCSP lines.append('') DCNL DCSP return lines DCNL DCSP for (prop, path) in attrs: DCNL DCSP  DCSP accepts = self.get_valid_values(prop) DCNL DCSP  DCSP name = self.aliased_name_rest(prop, path) DCNL DCSP  DCSP lines.append(('%s%s: DCSP %s' % (pad, name, accepts))) DCNL DCSP return lines
def pprint_getters(self): DCNL DCSP o = self.oorig DCNL DCSP getters = [name for name in dir(o) if (name.startswith('get_') and callable(getattr(o, name)))] DCNL DCSP getters.sort() DCNL DCSP lines = [] DCNL DCSP for name in getters: DCNL DCSP  DCSP func = getattr(o, name) DCNL DCSP  DCSP if self.is_alias(func): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP val = func() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((getattr(val, 'shape', ()) != ()) and (len(val) > 6)): DCNL DCSP  DCSP  DCSP s = (str(val[:6]) + '...') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = str(val) DCNL DCSP  DCSP s = s.replace('\n', ' DCSP ') DCNL DCSP  DCSP if (len(s) > 50): DCNL DCSP  DCSP  DCSP s = (s[:50] + '...') DCNL DCSP  DCSP name = self.aliased_name(name[4:]) DCNL DCSP  DCSP lines.append((' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP %s' % (name, s))) DCNL DCSP return lines
def findobj(self, match=None): DCNL DCSP if (match is None): DCNL DCSP  DCSP def matchfunc(x): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif issubclass(match, Artist): DCNL DCSP  DCSP def matchfunc(x): DCNL DCSP  DCSP  DCSP return isinstance(x, match) DCNL DCSP elif callable(match): DCNL DCSP  DCSP matchfunc = func DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('match DCSP must DCSP be DCSP None, DCSP an DCSP matplotlib.artist.Artist DCSP subclass, DCSP or DCSP a DCSP callable') DCNL DCSP artists = [] DCNL DCSP for c in self.get_children(): DCNL DCSP  DCSP if matchfunc(c): DCNL DCSP  DCSP  DCSP artists.append(c) DCNL DCSP  DCSP artists.extend([thisc for thisc in c.findobj(matchfunc) if matchfunc(thisc)]) DCNL DCSP if matchfunc(self): DCNL DCSP  DCSP artists.append(self) DCNL DCSP return artists
def __getattr__(self, aname): DCNL DCSP if (aname == 'lineno'): DCNL DCSP  DCSP return lineno(self.loc, self.pstr) DCNL DCSP elif (aname in ('col', 'column')): DCNL DCSP  DCSP return col(self.loc, self.pstr) DCNL DCSP elif (aname == 'line'): DCNL DCSP  DCSP return line(self.loc, self.pstr) DCNL DCSP else: DCNL DCSP  DCSP raise AttributeError(aname)
def markInputline(self, markerString='>!<'): DCNL DCSP line_str = self.line DCNL DCSP line_column = (self.column - 1) DCNL DCSP if markerString: DCNL DCSP  DCSP line_str = ''.join([line_str[:line_column], markerString, line_str[line_column:]]) DCNL DCSP return line_str.strip()
def keys(self): DCNL DCSP return self.__tokdict.keys()
def pop(self, index=(-1)): DCNL DCSP ret = self[index] DCNL DCSP del self[index] DCNL DCSP return ret
def get(self, key, defaultValue=None): DCNL DCSP if (key in self): DCNL DCSP  DCSP return self[key] DCNL DCSP else: DCNL DCSP  DCSP return defaultValue
def items(self): DCNL DCSP return [(k, self[k]) for k in self.__tokdict]
def values(self): DCNL DCSP return [v[(-1)][0] for v in self.__tokdict.values()]
def asList(self): DCNL DCSP out = [] DCNL DCSP for res in self.__toklist: DCNL DCSP  DCSP if isinstance(res, ParseResults): DCNL DCSP  DCSP  DCSP out.append(res.asList()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out.append(res) DCNL DCSP return out
def asDict(self): DCNL DCSP return dict(self.items())
def copy(self): DCNL DCSP ret = ParseResults(self.__toklist) DCNL DCSP ret.__tokdict = self.__tokdict.copy() DCNL DCSP ret.__parent = self.__parent DCNL DCSP ret.__accumNames.update(self.__accumNames) DCNL DCSP ret.__name = self.__name DCNL DCSP return ret
def asXML(self, doctag=None, namedItemsOnly=False, indent='', formatted=True): DCNL DCSP nl = '\n' DCNL DCSP out = [] DCNL DCSP namedItems = dict([(v[1], k) for (k, vlist) in self.__tokdict.items() for v in vlist]) DCNL DCSP nextLevelIndent = (indent + ' DCSP  DCSP ') DCNL DCSP if (not formatted): DCNL DCSP  DCSP indent = '' DCNL DCSP  DCSP nextLevelIndent = '' DCNL DCSP  DCSP nl = '' DCNL DCSP selfTag = None DCNL DCSP if (doctag is not None): DCNL DCSP  DCSP selfTag = doctag DCNL DCSP elif self.__name: DCNL DCSP  DCSP selfTag = self.__name DCNL DCSP if (not selfTag): DCNL DCSP  DCSP if namedItemsOnly: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP selfTag = 'ITEM' DCNL DCSP out += [nl, indent, '<', selfTag, '>'] DCNL DCSP worklist = self.__toklist DCNL DCSP for (i, res) in enumerate(worklist): DCNL DCSP  DCSP if isinstance(res, ParseResults): DCNL DCSP  DCSP  DCSP if (i in namedItems): DCNL DCSP  DCSP  DCSP  DCSP out += [res.asXML(namedItems[i], (namedItemsOnly and (doctag is None)), nextLevelIndent, formatted)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP out += [res.asXML(None, (namedItemsOnly and (doctag is None)), nextLevelIndent, formatted)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP resTag = None DCNL DCSP  DCSP  DCSP if (i in namedItems): DCNL DCSP  DCSP  DCSP  DCSP resTag = namedItems[i] DCNL DCSP  DCSP  DCSP if (not resTag): DCNL DCSP  DCSP  DCSP  DCSP if namedItemsOnly: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP resTag = 'ITEM' DCNL DCSP  DCSP  DCSP xmlBodyText = xml.sax.saxutils.escape(_ustr(res)) DCNL DCSP  DCSP  DCSP out += [nl, nextLevelIndent, '<', resTag, '>', xmlBodyText, '</', resTag, '>'] DCNL DCSP out += [nl, indent, '</', selfTag, '>'] DCNL DCSP return ''.join(out)
def getName(self): DCNL DCSP if self.__name: DCNL DCSP  DCSP return self.__name DCNL DCSP elif self.__parent: DCNL DCSP  DCSP par = self.__parent() DCNL DCSP  DCSP if par: DCNL DCSP  DCSP  DCSP return par.__lookup(self) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP elif ((len(self) == 1) and (len(self.__tokdict) == 1) and (self.__tokdict.values()[0][0][1] in (0, (-1)))): DCNL DCSP  DCSP return self.__tokdict.keys()[0] DCNL DCSP else: DCNL DCSP  DCSP return None
def dump(self, indent='', depth=0): DCNL DCSP out = [] DCNL DCSP out.append((indent + _ustr(self.asList()))) DCNL DCSP keys = self.items() DCNL DCSP keys.sort() DCNL DCSP for (k, v) in keys: DCNL DCSP  DCSP if out: DCNL DCSP  DCSP  DCSP out.append('\n') DCNL DCSP  DCSP out.append(('%s%s- DCSP %s: DCSP ' % (indent, (' DCSP  DCSP ' * depth), k))) DCNL DCSP  DCSP if isinstance(v, ParseResults): DCNL DCSP  DCSP  DCSP if v.keys(): DCNL DCSP  DCSP  DCSP  DCSP out.append(v.dump(indent, (depth + 1))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP out.append(_ustr(v)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out.append(_ustr(v)) DCNL DCSP return ''.join(out)
def setDefaultWhitespaceChars(chars): DCNL DCSP ParserElement.DEFAULT_WHITE_CHARS = chars
def copy(self): DCNL DCSP cpy = copy.copy(self) DCNL DCSP cpy.parseAction = self.parseAction[:] DCNL DCSP cpy.ignoreExprs = self.ignoreExprs[:] DCNL DCSP if self.copyDefaultWhiteChars: DCNL DCSP  DCSP cpy.whiteChars = ParserElement.DEFAULT_WHITE_CHARS DCNL DCSP return cpy
def setName(self, name): DCNL DCSP self.name = name DCNL DCSP self.errmsg = ('Expected DCSP ' + self.name) DCNL DCSP if hasattr(self, 'exception'): DCNL DCSP  DCSP self.exception.msg = self.errmsg DCNL DCSP return self
def setResultsName(self, name, listAllMatches=False): DCNL DCSP newself = self.copy() DCNL DCSP newself.resultsName = name DCNL DCSP newself.modalResults = (not listAllMatches) DCNL DCSP return newself
def setBreak(self, breakFlag=True): DCNL DCSP if breakFlag: DCNL DCSP  DCSP _parseMethod = self._parse DCNL DCSP  DCSP def breaker(instring, loc, doActions=True, callPreParse=True): DCNL DCSP  DCSP  DCSP import pdb DCNL DCSP  DCSP  DCSP pdb.set_trace() DCNL DCSP  DCSP  DCSP _parseMethod(instring, loc, doActions, callPreParse) DCNL DCSP  DCSP breaker._originalParseMethod = _parseMethod DCNL DCSP  DCSP self._parse = breaker DCNL DCSP elif hasattr(self._parse, '_originalParseMethod'): DCNL DCSP  DCSP self._parse = self._parse._originalParseMethod DCNL DCSP return self
def _normalizeParseActionArgs(f): DCNL DCSP STAR_ARGS = 4 DCNL DCSP try: DCNL DCSP  DCSP restore = None DCNL DCSP  DCSP if isinstance(f, type): DCNL DCSP  DCSP  DCSP restore = f DCNL DCSP  DCSP  DCSP f = f.__init__ DCNL DCSP  DCSP if (not _PY3K): DCNL DCSP  DCSP  DCSP codeObj = f.func_code DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP codeObj = f.code DCNL DCSP  DCSP if (codeObj.co_flags & STAR_ARGS): DCNL DCSP  DCSP  DCSP return f DCNL DCSP  DCSP numargs = codeObj.co_argcount DCNL DCSP  DCSP if (not _PY3K): DCNL DCSP  DCSP  DCSP if hasattr(f, 'im_self'): DCNL DCSP  DCSP  DCSP  DCSP numargs -= 1 DCNL DCSP  DCSP elif hasattr(f, '__self__'): DCNL DCSP  DCSP  DCSP numargs -= 1 DCNL DCSP  DCSP if restore: DCNL DCSP  DCSP  DCSP f = restore DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not _PY3K): DCNL DCSP  DCSP  DCSP  DCSP call_im_func_code = f.__call__.im_func.func_code DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP call_im_func_code = f.__code__ DCNL DCSP  DCSP  DCSP if (call_im_func_code.co_flags & STAR_ARGS): DCNL DCSP  DCSP  DCSP  DCSP return f DCNL DCSP  DCSP  DCSP numargs = call_im_func_code.co_argcount DCNL DCSP  DCSP  DCSP if (not _PY3K): DCNL DCSP  DCSP  DCSP  DCSP if hasattr(f.__call__, 'im_self'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP numargs -= 1 DCNL DCSP  DCSP  DCSP elif hasattr(f.__call__, '__self__'): DCNL DCSP  DCSP  DCSP  DCSP numargs -= 0 DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP if (not _PY3K): DCNL DCSP  DCSP  DCSP  DCSP call_func_code = f.__call__.func_code DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP call_func_code = f.__call__.__code__ DCNL DCSP  DCSP  DCSP if (call_func_code.co_flags & STAR_ARGS): DCNL DCSP  DCSP  DCSP  DCSP return f DCNL DCSP  DCSP  DCSP numargs = call_func_code.co_argcount DCNL DCSP  DCSP  DCSP if (not _PY3K): DCNL DCSP  DCSP  DCSP  DCSP if hasattr(f.__call__, 'im_self'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP numargs -= 1 DCNL DCSP  DCSP  DCSP elif hasattr(f.__call__, '__self__'): DCNL DCSP  DCSP  DCSP  DCSP numargs -= 1 DCNL DCSP if (numargs == 3): DCNL DCSP  DCSP return f DCNL DCSP else: DCNL DCSP  DCSP if (numargs > 3): DCNL DCSP  DCSP  DCSP def tmp(s, l, t): DCNL DCSP  DCSP  DCSP  DCSP return f(f.__call__.__self__, s, l, t) DCNL DCSP  DCSP if (numargs == 2): DCNL DCSP  DCSP  DCSP def tmp(s, l, t): DCNL DCSP  DCSP  DCSP  DCSP return f(l, t) DCNL DCSP  DCSP elif (numargs == 1): DCNL DCSP  DCSP  DCSP def tmp(s, l, t): DCNL DCSP  DCSP  DCSP  DCSP return f(t) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP def tmp(s, l, t): DCNL DCSP  DCSP  DCSP  DCSP return f() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tmp.__name__ = f.__name__ DCNL DCSP  DCSP except (AttributeError, TypeError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tmp.__doc__ = f.__doc__ DCNL DCSP  DCSP except (AttributeError, TypeError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tmp.__dict__.update(f.__dict__) DCNL DCSP  DCSP except (AttributeError, TypeError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return tmp
def setParseAction(self, *fns, **kwargs): DCNL DCSP self.parseAction = list(map(self._normalizeParseActionArgs, list(fns))) DCNL DCSP self.callDuringTry = (('callDuringTry' in kwargs) and kwargs['callDuringTry']) DCNL DCSP return self
def addParseAction(self, *fns, **kwargs): DCNL DCSP self.parseAction += list(map(self._normalizeParseActionArgs, list(fns))) DCNL DCSP self.callDuringTry = (self.callDuringTry or (('callDuringTry' in kwargs) and kwargs['callDuringTry'])) DCNL DCSP return self
def setFailAction(self, fn): DCNL DCSP self.failAction = fn DCNL DCSP return self
def enablePackrat(): DCNL DCSP if (not ParserElement._packratEnabled): DCNL DCSP  DCSP ParserElement._packratEnabled = True DCNL DCSP  DCSP ParserElement._parse = ParserElement._parseCache
def parseString(self, instring, parseAll=False): DCNL DCSP ParserElement.resetCache() DCNL DCSP if (not self.streamlined): DCNL DCSP  DCSP self.streamline() DCNL DCSP for e in self.ignoreExprs: DCNL DCSP  DCSP e.streamline() DCNL DCSP if (not self.keepTabs): DCNL DCSP  DCSP instring = instring.expandtabs() DCNL DCSP (loc, tokens) = self._parse(instring, 0) DCNL DCSP if parseAll: DCNL DCSP  DCSP StringEnd()._parse(instring, loc) DCNL DCSP return tokens
def scanString(self, instring, maxMatches=_MAX_INT): DCNL DCSP if (not self.streamlined): DCNL DCSP  DCSP self.streamline() DCNL DCSP for e in self.ignoreExprs: DCNL DCSP  DCSP e.streamline() DCNL DCSP if (not self.keepTabs): DCNL DCSP  DCSP instring = _ustr(instring).expandtabs() DCNL DCSP instrlen = len(instring) DCNL DCSP loc = 0 DCNL DCSP preparseFn = self.preParse DCNL DCSP parseFn = self._parse DCNL DCSP ParserElement.resetCache() DCNL DCSP matches = 0 DCNL DCSP while ((loc <= instrlen) and (matches < maxMatches)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP preloc = preparseFn(instring, loc) DCNL DCSP  DCSP  DCSP (nextLoc, tokens) = parseFn(instring, preloc, callPreParse=False) DCNL DCSP  DCSP except ParseException: DCNL DCSP  DCSP  DCSP loc = (preloc + 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP matches += 1 DCNL DCSP  DCSP  DCSP (yield (tokens, preloc, nextLoc)) DCNL DCSP  DCSP  DCSP loc = nextLoc
def transformString(self, instring): DCNL DCSP out = [] DCNL DCSP lastE = 0 DCNL DCSP self.keepTabs = True DCNL DCSP for (t, s, e) in self.scanString(instring): DCNL DCSP  DCSP out.append(instring[lastE:s]) DCNL DCSP  DCSP if t: DCNL DCSP  DCSP  DCSP if isinstance(t, ParseResults): DCNL DCSP  DCSP  DCSP  DCSP out += t.asList() DCNL DCSP  DCSP  DCSP elif isinstance(t, list): DCNL DCSP  DCSP  DCSP  DCSP out += t DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP out.append(t) DCNL DCSP  DCSP lastE = e DCNL DCSP out.append(instring[lastE:]) DCNL DCSP return ''.join(map(_ustr, out))
def searchString(self, instring, maxMatches=_MAX_INT): DCNL DCSP return ParseResults([t for (t, s, e) in self.scanString(instring, maxMatches)])
def __add__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return And([self, other])
def __radd__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return (other + self)
def __sub__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return And([self, And._ErrorStop(), other])
def __rsub__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return (other - self)
def __or__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return MatchFirst([self, other])
def __ror__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return (other | self)
def __xor__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return Or([self, other])
def __rxor__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return (other ^ self)
def __and__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return Each([self, other])
def __rand__(self, other): DCNL DCSP if isinstance(other, basestring): DCNL DCSP  DCSP other = Literal(other) DCNL DCSP if (not isinstance(other, ParserElement)): DCNL DCSP  DCSP warnings.warn(('Cannot DCSP combine DCSP element DCSP of DCSP type DCSP %s DCSP with DCSP ParserElement' % type(other)), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP return None DCNL DCSP return (other & self)
def __invert__(self): DCNL DCSP return NotAny(self)
def __call__(self, name): DCNL DCSP return self.setResultsName(name)
def suppress(self): DCNL DCSP return Suppress(self)
def leaveWhitespace(self): DCNL DCSP self.skipWhitespace = False DCNL DCSP return self
def setWhitespaceChars(self, chars): DCNL DCSP self.skipWhitespace = True DCNL DCSP self.whiteChars = chars DCNL DCSP self.copyDefaultWhiteChars = False DCNL DCSP return self
def parseWithTabs(self): DCNL DCSP self.keepTabs = True DCNL DCSP return self
def ignore(self, other): DCNL DCSP if isinstance(other, Suppress): DCNL DCSP  DCSP if (other not in self.ignoreExprs): DCNL DCSP  DCSP  DCSP self.ignoreExprs.append(other) DCNL DCSP else: DCNL DCSP  DCSP self.ignoreExprs.append(Suppress(other)) DCNL DCSP return self
def setDebugActions(self, startAction, successAction, exceptionAction): DCNL DCSP self.debugActions = ((startAction or _defaultStartDebugAction), (successAction or _defaultSuccessDebugAction), (exceptionAction or _defaultExceptionDebugAction)) DCNL DCSP self.debug = True DCNL DCSP return self
def setDebug(self, flag=True): DCNL DCSP if flag: DCNL DCSP  DCSP self.setDebugActions(_defaultStartDebugAction, _defaultSuccessDebugAction, _defaultExceptionDebugAction) DCNL DCSP else: DCNL DCSP  DCSP self.debug = False DCNL DCSP return self
def validate(self, validateTrace=[]): DCNL DCSP self.checkRecursion([])
def parseFile(self, file_or_filename): DCNL DCSP try: DCNL DCSP  DCSP file_contents = file_or_filename.read() DCNL DCSP except AttributeError: DCNL DCSP  DCSP f = open(file_or_filename, 'rb') DCNL DCSP  DCSP file_contents = f.read() DCNL DCSP  DCSP f.close() DCNL DCSP return self.parseString(file_contents)
def setDefaultKeywordChars(chars): DCNL DCSP Keyword.DEFAULT_KEYWORD_CHARS = chars
def __init__(self, pattern, flags=0): DCNL DCSP super(Regex, self).__init__() DCNL DCSP if (len(pattern) == 0): DCNL DCSP  DCSP warnings.warn('null DCSP string DCSP passed DCSP to DCSP Regex; DCSP use DCSP Empty() DCSP instead', SyntaxWarning, stacklevel=2) DCNL DCSP self.pattern = pattern DCNL DCSP self.flags = flags DCNL DCSP try: DCNL DCSP  DCSP self.re = re.compile(self.pattern, self.flags) DCNL DCSP  DCSP self.reString = self.pattern DCNL DCSP except sre_constants.error: DCNL DCSP  DCSP warnings.warn(('invalid DCSP pattern DCSP (%s) DCSP passed DCSP to DCSP Regex' % pattern), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP raise DCNL DCSP self.name = _ustr(self) DCNL DCSP self.errmsg = ('Expected DCSP ' + self.name) DCNL DCSP self.mayIndexError = False DCNL DCSP self.mayReturnEmpty = True
def __init__(self, quoteChar, escChar=None, escQuote=None, multiline=False, unquoteResults=True, endQuoteChar=None): DCNL DCSP super(QuotedString, self).__init__() DCNL DCSP quoteChar = quoteChar.strip() DCNL DCSP if (len(quoteChar) == 0): DCNL DCSP  DCSP warnings.warn('quoteChar DCSP cannot DCSP be DCSP the DCSP empty DCSP string', SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP raise SyntaxError() DCNL DCSP if (endQuoteChar is None): DCNL DCSP  DCSP endQuoteChar = quoteChar DCNL DCSP else: DCNL DCSP  DCSP endQuoteChar = endQuoteChar.strip() DCNL DCSP  DCSP if (len(endQuoteChar) == 0): DCNL DCSP  DCSP  DCSP warnings.warn('endQuoteChar DCSP cannot DCSP be DCSP the DCSP empty DCSP string', SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP  DCSP raise SyntaxError() DCNL DCSP self.quoteChar = quoteChar DCNL DCSP self.quoteCharLen = len(quoteChar) DCNL DCSP self.firstQuoteChar = quoteChar[0] DCNL DCSP self.endQuoteChar = endQuoteChar DCNL DCSP self.endQuoteCharLen = len(endQuoteChar) DCNL DCSP self.escChar = escChar DCNL DCSP self.escQuote = escQuote DCNL DCSP self.unquoteResults = unquoteResults DCNL DCSP if multiline: DCNL DCSP  DCSP self.flags = (re.MULTILINE | re.DOTALL) DCNL DCSP  DCSP self.pattern = ('%s(?:[^%s%s]' % (re.escape(self.quoteChar), _escapeRegexRangeChars(self.endQuoteChar[0]), (((escChar is not None) and _escapeRegexRangeChars(escChar)) or ''))) DCNL DCSP else: DCNL DCSP  DCSP self.flags = 0 DCNL DCSP  DCSP self.pattern = ('%s(?:[^%s\\n\\r%s]' % (re.escape(self.quoteChar), _escapeRegexRangeChars(self.endQuoteChar[0]), (((escChar is not None) and _escapeRegexRangeChars(escChar)) or ''))) DCNL DCSP if (len(self.endQuoteChar) > 1): DCNL DCSP  DCSP self.pattern += (('|(?:' + ')|(?:'.join([('%s[^%s]' % (re.escape(self.endQuoteChar[:i]), _escapeRegexRangeChars(self.endQuoteChar[i]))) for i in range((len(self.endQuoteChar) - 1), 0, (-1))])) + ')') DCNL DCSP if escQuote: DCNL DCSP  DCSP self.pattern += ('|(?:%s)' % re.escape(escQuote)) DCNL DCSP if escChar: DCNL DCSP  DCSP self.pattern += ('|(?:%s.)' % re.escape(escChar)) DCNL DCSP  DCSP self.escCharReplacePattern = (re.escape(self.escChar) + '(.)') DCNL DCSP self.pattern += (')*%s' % re.escape(self.endQuoteChar)) DCNL DCSP try: DCNL DCSP  DCSP self.re = re.compile(self.pattern, self.flags) DCNL DCSP  DCSP self.reString = self.pattern DCNL DCSP except sre_constants.error: DCNL DCSP  DCSP warnings.warn(('invalid DCSP pattern DCSP (%s) DCSP passed DCSP to DCSP Regex' % self.pattern), SyntaxWarning, stacklevel=2) DCNL DCSP  DCSP raise DCNL DCSP self.name = _ustr(self) DCNL DCSP self.errmsg = ('Expected DCSP ' + self.name) DCNL DCSP self.mayIndexError = False DCNL DCSP self.mayReturnEmpty = True
def leaveWhitespace(self): DCNL DCSP self.skipWhitespace = False DCNL DCSP self.exprs = [e.copy() for e in self.exprs] DCNL DCSP for e in self.exprs: DCNL DCSP  DCSP e.leaveWhitespace() DCNL DCSP return self
def refreshGUI(self): DCNL DCSP plt.pause(0.0001)
def __init__(self, inputDimensions, columnDimensions): DCNL DCSP self.inputDimensions = inputDimensions DCNL DCSP self.columnDimensions = columnDimensions DCNL DCSP self.inputSize = np.array(inputDimensions).prod() DCNL DCSP self.columnNumber = np.array(columnDimensions).prod() DCNL DCSP self.inputArray = np.zeros(self.inputSize, dtype=uintType) DCNL DCSP self.activeArray = np.zeros(self.columnNumber, dtype=uintType) DCNL DCSP random.seed(1) DCNL DCSP self.sp = SP(self.inputDimensions, self.columnDimensions, potentialRadius=self.inputSize, numActiveColumnsPerInhArea=int((0.02 * self.columnNumber)), globalInhibition=True, seed=1, synPermActiveInc=0.01, synPermInactiveDec=0.008)
def createInput(self): DCNL DCSP print ((('-' * 70) + 'Creating DCSP a DCSP random DCSP input DCSP vector') + ('-' * 70)) DCNL DCSP self.inputArray[0:] = 0 DCNL DCSP for i in range(self.inputSize): DCNL DCSP  DCSP self.inputArray[i] = random.randrange(2)
def run(self): DCNL DCSP print ((('-' * 80) + 'Computing DCSP the DCSP SDR') + ('-' * 80)) DCNL DCSP self.sp.compute(self.inputArray, True, self.activeArray) DCNL DCSP print self.activeArray.nonzero()
def addNoise(self, noiseLevel): DCNL DCSP for _ in range(int((noiseLevel * self.inputSize))): DCNL DCSP  DCSP randomPosition = int((random.random() * self.inputSize)) DCNL DCSP  DCSP if (self.inputArray[randomPosition] == 1): DCNL DCSP  DCSP  DCSP self.inputArray[randomPosition] = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.inputArray[randomPosition] = 1
def compute(self, inputs, outputs): DCNL DCSP outputs['out'][:] = inputs['in']
@classmethod DCNL def getSpec(cls): DCNL DCSP spec = {'description': IdentityRegion.__doc__, 'singleNodeOnly': True, 'inputs': {'in': {'description': 'The DCSP input DCSP vector.', 'dataType': 'Real32', 'count': 0, 'required': True, 'regionLevel': False, 'isDefaultInput': True, 'requireSplitterMap': False}}, 'outputs': {'out': {'description': 'A DCSP copy DCSP of DCSP the DCSP input DCSP vector.', 'dataType': 'Real32', 'count': 0, 'regionLevel': True, 'isDefaultOutput': True}}, 'parameters': {'dataWidth': {'description': 'Size DCSP of DCSP inputs', 'accessMode': 'Read', 'dataType': 'UInt32', 'count': 1, 'constraints': ''}}} DCNL DCSP return spec
def testFastLearning(self): DCNL DCSP numOnBitsPerPattern = 3 DCNL DCSP baseParams = dict(seqFunction=buildOverlappedSequences, numSequences=2, seqLen=10, sharedElements=[2, 3], numOnBitsPerPattern=numOnBitsPerPattern, includeCPP=INCLUDE_CPP_TM, numCols=None, activationThreshold=numOnBitsPerPattern, minThreshold=numOnBitsPerPattern, newSynapseCount=numOnBitsPerPattern, initialPerm=0.6, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, nTrainRepetitions=8, doResets=True) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP 3 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=20, expMissingMax=None, pamLength=1, nTrainRepetitions=3)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP 3 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, pamLength=5, nTrainRepetitions=3))
def testSlowLearning(self): DCNL DCSP numOnBitsPerPattern = 3 DCNL DCSP baseParams = dict(seqFunction=buildOverlappedSequences, numSequences=2, seqLen=10, sharedElements=[2, 3], numOnBitsPerPattern=numOnBitsPerPattern, includeCPP=INCLUDE_CPP_TM, numCols=None, activationThreshold=numOnBitsPerPattern, minThreshold=numOnBitsPerPattern, newSynapseCount=numOnBitsPerPattern, initialPerm=0.11, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, nTrainRepetitions=8, doResets=True) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP 10 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=10, expMissingMax=None, pamLength=1, nTrainRepetitions=10)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP 10 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, pamLength=6, nTrainRepetitions=10))
def testSlowLearningWithOverlap(self): DCNL DCSP if SHORT: DCNL DCSP  DCSP self.skipTest('Test DCSP skipped DCSP by DCSP default. DCSP Enable DCSP with DCSP --long.') DCNL DCSP numOnBitsPerPattern = 5 DCNL DCSP baseParams = dict(seqFunction=buildOverlappedSequences, numSequences=2, seqLen=10, sharedElements=[2, 3], numOnBitsPerPattern=numOnBitsPerPattern, patternOverlap=2, includeCPP=INCLUDE_CPP_TM, numCols=None, activationThreshold=int((0.8 * numOnBitsPerPattern)), minThreshold=int((0.8 * numOnBitsPerPattern)), newSynapseCount=numOnBitsPerPattern, initialPerm=0.11, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, nTrainRepetitions=8, doResets=True) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP 10 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=10, expMissingMax=None, pamLength=1, nTrainRepetitions=10)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP 10 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, pamLength=6, nTrainRepetitions=10))
def testForbesLikeData(self): DCNL DCSP if SHORT: DCNL DCSP  DCSP self.skipTest('Test DCSP skipped DCSP by DCSP default. DCSP Enable DCSP with DCSP --long.') DCNL DCSP numOnBitsPerPattern = 3 DCNL DCSP baseParams = dict(seqFunction=buildSequencePool, numSequences=20, seqLen=[3, 10], numPatterns=10, numOnBitsPerPattern=numOnBitsPerPattern, patternOverlap=1, includeCPP=INCLUDE_CPP_TM, numCols=None, activationThreshold=int((0.8 * numOnBitsPerPattern)), minThreshold=int((0.8 * numOnBitsPerPattern)), newSynapseCount=numOnBitsPerPattern, initialPerm=0.51, permanenceInc=0.1, permanenceDec=0.0, globalDecay=0.0, pamLength=0, checkSynapseConsistency=False, nTrainRepetitions=8, doResets=True) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP fast DCSP learning, DCSP 2 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=50, expMissingMax=None, pamLength=1, nTrainRepetitions=2)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP fast DCSP learning, DCSP 2 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, pamLength=5, nTrainRepetitions=2)) DCNL DCSP print '\nRunning DCSP without DCSP PAM, DCSP slow DCSP learning, DCSP 8 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=1, expMissingMax=None, initialPerm=0.31, pamLength=1, nTrainRepetitions=8)) DCNL DCSP print '\nRunning DCSP with DCSP PAM, DCSP slow DCSP learning, DCSP 8 DCSP repetitions DCSP of DCSP the DCSP training DCSP data...' DCNL DCSP self.assertTrue(testConfig(baseParams=baseParams, expMissingMin=0, expMissingMax=0, initialPerm=0.31, pamLength=5, nTrainRepetitions=8))
def _basicTest(self, tm=None): DCNL DCSP trainingSet = _getSimplePatterns(10, 10) DCNL DCSP for _ in range(2): DCNL DCSP  DCSP for seq in trainingSet[0:5]: DCNL DCSP  DCSP  DCSP for _ in range(10): DCNL DCSP  DCSP  DCSP  DCSP tm.learn(seq) DCNL DCSP  DCSP  DCSP tm.reset() DCNL DCSP print 'Learning DCSP completed' DCNL DCSP print 'Running DCSP inference' DCNL DCSP tm.collectStats = True DCNL DCSP for seq in trainingSet[0:5]: DCNL DCSP  DCSP tm.reset() DCNL DCSP  DCSP tm.resetStats() DCNL DCSP  DCSP for _ in range(10): DCNL DCSP  DCSP  DCSP tm.infer(seq) DCNL DCSP  DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP _printOneTrainingVector(seq) DCNL DCSP  DCSP  DCSP  DCSP tm.printStates(False, False) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (VERBOSITY > 1): DCNL DCSP  DCSP  DCSP print tm.getStats() DCNL DCSP  DCSP self.assertGreater(tm.getStats()['predictionScoreAvg2'], 0.8) DCNL DCSP  DCSP print ("tm.getStats()['predictionScoreAvg2'] DCSP = DCSP ", tm.getStats()['predictionScoreAvg2']) DCNL DCSP print 'TMConstantTest DCSP ok'
def _printOneTrainingVector(self, x): DCNL DCSP print ''.join((('1' if (k != 0) else '.') for k in x))
def _printAllTrainingSequences(self, trainingSequences): DCNL DCSP for (i, trainingSequence) in enumerate(trainingSequences): DCNL DCSP  DCSP print '============= DCSP Sequence', i, '=================' DCNL DCSP  DCSP for pattern in trainingSequence: DCNL DCSP  DCSP  DCSP self._printOneTrainingVector(pattern)
def _setVerbosity(self, verbosity, tm, tmPy): DCNL DCSP tm.cells4.setVerbosity(verbosity) DCNL DCSP tm.verbosity = verbosity DCNL DCSP tmPy.verbosity = verbosity
def _createTMs(self, numCols, fixedResources=False, checkSynapseConsistency=True): DCNL DCSP minThreshold = 4 DCNL DCSP activationThreshold = 8 DCNL DCSP newSynapseCount = 15 DCNL DCSP initialPerm = 0.3 DCNL DCSP connectedPerm = 0.5 DCNL DCSP permanenceInc = 0.1 DCNL DCSP permanenceDec = 0.05 DCNL DCSP if fixedResources: DCNL DCSP  DCSP permanenceDec = 0.1 DCNL DCSP  DCSP maxSegmentsPerCell = 5 DCNL DCSP  DCSP maxSynapsesPerSegment = 15 DCNL DCSP  DCSP globalDecay = 0 DCNL DCSP  DCSP maxAge = 0 DCNL DCSP else: DCNL DCSP  DCSP permanenceDec = 0.05 DCNL DCSP  DCSP maxSegmentsPerCell = (-1) DCNL DCSP  DCSP maxSynapsesPerSegment = (-1) DCNL DCSP  DCSP globalDecay = 0.0001 DCNL DCSP  DCSP maxAge = 1 DCNL DCSP if g_testCPPTM: DCNL DCSP  DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP  DCSP print 'Creating DCSP BacktrackingTMCPP DCSP instance' DCNL DCSP  DCSP cppTM = BacktrackingTMCPP(numberOfCols=numCols, cellsPerColumn=4, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, maxAge=maxAge, burnIn=1, seed=g_options.seed, verbosity=g_options.verbosity, checkSynapseConsistency=checkSynapseConsistency, pamLength=1000, maxSegmentsPerCell=maxSegmentsPerCell, maxSynapsesPerSegment=maxSynapsesPerSegment) DCNL DCSP  DCSP cppTM.retrieveLearningStates = True DCNL DCSP else: DCNL DCSP  DCSP cppTM = None DCNL DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP print 'Creating DCSP PY DCSP TM DCSP instance' DCNL DCSP pyTM = BacktrackingTM(numberOfCols=numCols, cellsPerColumn=4, initialPerm=initialPerm, connectedPerm=connectedPerm, minThreshold=minThreshold, newSynapseCount=newSynapseCount, permanenceInc=permanenceInc, permanenceDec=permanenceDec, activationThreshold=activationThreshold, globalDecay=globalDecay, maxAge=maxAge, burnIn=1, seed=g_options.seed, verbosity=g_options.verbosity, pamLength=1000, maxSegmentsPerCell=maxSegmentsPerCell, maxSynapsesPerSegment=maxSynapsesPerSegment) DCNL DCSP return (cppTM, pyTM)
def _getSimplePatterns(self, numOnes, numPatterns): DCNL DCSP numCols = (numOnes * numPatterns) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP x[(i * numOnes):((i + 1) * numOnes)] = 1 DCNL DCSP  DCSP p.append(x) DCNL DCSP return p
def _buildSegmentLearningTrainingSet(self, numOnes=10, numRepetitions=10): DCNL DCSP numPatterns = 5 DCNL DCSP numCols = ((2 * numPatterns) * numOnes) DCNL DCSP halfCols = (numPatterns * numOnes) DCNL DCSP numNoiseBits = numOnes DCNL DCSP p = self._getSimplePatterns(numOnes, numPatterns) DCNL DCSP trainingSequences = [] DCNL DCSP for _ in xrange(numRepetitions): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP for j in xrange(numPatterns): DCNL DCSP  DCSP  DCSP v = numpy.zeros(numCols) DCNL DCSP  DCSP  DCSP v[0:halfCols] = p[j] DCNL DCSP  DCSP  DCSP noiseIndices = (self._rgen.permutation(halfCols) + halfCols)[0:numNoiseBits] DCNL DCSP  DCSP  DCSP v[noiseIndices] = 1 DCNL DCSP  DCSP  DCSP sequence.append(v) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP testSequence = [] DCNL DCSP for j in xrange(numPatterns): DCNL DCSP  DCSP v = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP v[0:halfCols] = p[j] DCNL DCSP  DCSP testSequence.append(v) DCNL DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP print '\nTraining DCSP sequences' DCNL DCSP  DCSP self._printAllTrainingSequences(trainingSequences) DCNL DCSP  DCSP print '\nTest DCSP sequence' DCNL DCSP  DCSP self._printAllTrainingSequences([testSequence]) DCNL DCSP return (trainingSequences, [testSequence])
def _buildSL2TrainingSet(self, numOnes=10, numRepetitions=10): DCNL DCSP numPatterns = 5 DCNL DCSP numCols = ((2 * numPatterns) * numOnes) DCNL DCSP halfCols = (numPatterns * numOnes) DCNL DCSP numNoiseBits = numOnes DCNL DCSP p = self._getSimplePatterns(numOnes, numPatterns) DCNL DCSP numSequences = 3 DCNL DCSP indices = [[0, 1, 2, 3, 4], [4, 3, 2, 1, 0], [2, 0, 4, 1, 3]] DCNL DCSP trainingSequences = [] DCNL DCSP for i in xrange((numRepetitions * numSequences)): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP for j in xrange(numPatterns): DCNL DCSP  DCSP  DCSP v = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP  DCSP v[0:halfCols] = p[indices[(i % numSequences)][j]] DCNL DCSP  DCSP  DCSP noiseIndices = (self._rgen.permutation(halfCols) + halfCols)[0:numNoiseBits] DCNL DCSP  DCSP  DCSP v[noiseIndices] = 1 DCNL DCSP  DCSP  DCSP sequence.append(v) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP testSequences = [] DCNL DCSP for i in xrange(numSequences): DCNL DCSP  DCSP sequence = [] DCNL DCSP  DCSP for j in xrange(numPatterns): DCNL DCSP  DCSP  DCSP v = numpy.zeros(numCols, dtype='float32') DCNL DCSP  DCSP  DCSP v[0:halfCols] = p[indices[(i % numSequences)][j]] DCNL DCSP  DCSP  DCSP sequence.append(v) DCNL DCSP  DCSP testSequences.append(sequence) DCNL DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP print '\nTraining DCSP sequences' DCNL DCSP  DCSP self._printAllTrainingSequences(trainingSequences) DCNL DCSP  DCSP print '\nTest DCSP sequences' DCNL DCSP  DCSP self._printAllTrainingSequences(testSequences) DCNL DCSP return (trainingSequences, testSequences)
def _testSegmentLearningSequence(self, tms, trainingSequences, testSequences, doResets=True): DCNL DCSP if (testSequences == None): DCNL DCSP  DCSP testSequences = trainingSequences DCNL DCSP (cppTM, pyTM) = (tms[0], tms[1]) DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP assert (fdrutils.tmDiff2(cppTM, pyTM, g_options.verbosity) == True) DCNL DCSP if (g_options.verbosity > 0): DCNL DCSP  DCSP print '============= DCSP Training DCSP =================' DCNL DCSP  DCSP print 'TM DCSP parameters:' DCNL DCSP  DCSP print 'CPP' DCNL DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP print cppTM.printParameters() DCNL DCSP  DCSP print '\nPY' DCNL DCSP  DCSP print pyTM.printParameters() DCNL DCSP for (sequenceNum, trainingSequence) in enumerate(trainingSequences): DCNL DCSP  DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP  DCSP print '============= DCSP New DCSP sequence DCSP =================' DCNL DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppTM.reset() DCNL DCSP  DCSP  DCSP pyTM.reset() DCNL DCSP  DCSP for (t, x) in enumerate(trainingSequence): DCNL DCSP  DCSP  DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP  DCSP  DCSP print 'Time DCSP step', t, 'sequence DCSP number', sequenceNum DCNL DCSP  DCSP  DCSP  DCSP print 'Input: DCSP ', pyTM.printInput(x) DCNL DCSP  DCSP  DCSP  DCSP print 'NNZ:', x.nonzero() DCNL DCSP  DCSP  DCSP x = numpy.array(x).astype('float32') DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppTM.learn(x) DCNL DCSP  DCSP  DCSP pyTM.learn(x) DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP assert (fdrutils.tmDiff2(cppTM, pyTM, g_options.verbosity, relaxSegmentTests=False) == True) DCNL DCSP  DCSP  DCSP if (g_options.verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP cppTM.printStates(printPrevious=(g_options.verbosity > 4)) DCNL DCSP  DCSP  DCSP  DCSP print '\nPY' DCNL DCSP  DCSP  DCSP  DCSP pyTM.printStates(printPrevious=(g_options.verbosity > 4)) DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (g_options.verbosity > 4): DCNL DCSP  DCSP  DCSP print 'Sequence DCSP finished. DCSP Complete DCSP state DCSP after DCSP sequence' DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP  DCSP cppTM.printCells() DCNL DCSP  DCSP  DCSP print '\nPY' DCNL DCSP  DCSP  DCSP pyTM.printCells() DCNL DCSP  DCSP  DCSP print DCNL DCSP if (g_options.verbosity > 2): DCNL DCSP  DCSP print 'Calling DCSP trim DCSP segments' DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP (nSegsRemovedCPP, nSynsRemovedCPP) = cppTM.trimSegments() DCNL DCSP (nSegsRemoved, nSynsRemoved) = pyTM.trimSegments() DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP assert (nSegsRemovedCPP == nSegsRemoved) DCNL DCSP  DCSP assert (nSynsRemovedCPP == nSynsRemoved) DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP assert (fdrutils.tmDiff2(cppTM, pyTM, g_options.verbosity) == True) DCNL DCSP print 'Training DCSP completed. DCSP Stats:' DCNL DCSP info = pyTM.getSegmentInfo() DCNL DCSP print ' DCSP  DCSP nSegments:', info[0] DCNL DCSP print ' DCSP  DCSP nSynapses:', info[1] DCNL DCSP if (g_options.verbosity > 3): DCNL DCSP  DCSP print 'Complete DCSP state:' DCNL DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP cppTM.printCells() DCNL DCSP  DCSP print '\nPY' DCNL DCSP  DCSP pyTM.printCells() DCNL DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP print '============= DCSP Inference DCSP =================' DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP cppTM.collectStats = True DCNL DCSP pyTM.collectStats = True DCNL DCSP nPredictions = 0 DCNL DCSP (cppNumCorrect, pyNumCorrect) = (0, 0) DCNL DCSP for (sequenceNum, testSequence) in enumerate(testSequences): DCNL DCSP  DCSP if (g_options.verbosity > 1): DCNL DCSP  DCSP  DCSP print '============= DCSP New DCSP sequence DCSP =================' DCNL DCSP  DCSP slen = len(testSequence) DCNL DCSP  DCSP if doResets: DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppTM.reset() DCNL DCSP  DCSP  DCSP pyTM.reset() DCNL DCSP  DCSP for (t, x) in enumerate(testSequence): DCNL DCSP  DCSP  DCSP if (g_options.verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP print 'Time DCSP step', t, '\nInput:' DCNL DCSP  DCSP  DCSP  DCSP pyTM.printInput(x) DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppTM.infer(x) DCNL DCSP  DCSP  DCSP pyTM.infer(x) DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP assert (fdrutils.tmDiff2(cppTM, pyTM, g_options.verbosity) == True) DCNL DCSP  DCSP  DCSP if (g_options.verbosity > 2): DCNL DCSP  DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP cppTM.printStates(printPrevious=(g_options.verbosity > 4), printLearnState=False) DCNL DCSP  DCSP  DCSP  DCSP print '\nPY' DCNL DCSP  DCSP  DCSP  DCSP pyTM.printStates(printPrevious=(g_options.verbosity > 4), printLearnState=False) DCNL DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP cppScores = cppTM.getStats() DCNL DCSP  DCSP  DCSP pyScores = pyTM.getStats() DCNL DCSP  DCSP  DCSP if (g_options.verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'CPP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP print cppScores DCNL DCSP  DCSP  DCSP  DCSP print '\nPY' DCNL DCSP  DCSP  DCSP  DCSP print pyScores DCNL DCSP  DCSP  DCSP if ((t < (slen - 1)) and (t > pyTM.burnIn)): DCNL DCSP  DCSP  DCSP  DCSP nPredictions += 1 DCNL DCSP  DCSP  DCSP  DCSP if (cppTM is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cppScores['curPredictionScore2'] > 0.3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cppNumCorrect += 1 DCNL DCSP  DCSP  DCSP  DCSP if (pyScores['curPredictionScore2'] > 0.3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pyNumCorrect += 1 DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP cppScores = cppTM.getStats() DCNL DCSP pyScores = pyTM.getStats() DCNL DCSP passTest = False DCNL DCSP if (cppTM is not None): DCNL DCSP  DCSP if ((cppNumCorrect == nPredictions) and (pyNumCorrect == nPredictions)): DCNL DCSP  DCSP  DCSP passTest = True DCNL DCSP elif (pyNumCorrect == nPredictions): DCNL DCSP  DCSP passTest = True DCNL DCSP if (not passTest): DCNL DCSP  DCSP print 'CPP DCSP correct DCSP predictions:', cppNumCorrect DCNL DCSP  DCSP print 'PY DCSP correct DCSP predictions:', pyNumCorrect DCNL DCSP  DCSP print 'Total DCSP predictions:', nPredictions DCNL DCSP return passTest
def _testSL1(self, numOnes=10, numRepetitions=6, fixedResources=False, checkSynapseConsistency=True): DCNL DCSP if fixedResources: DCNL DCSP  DCSP testName = 'TestSL1_FS' DCNL DCSP else: DCNL DCSP  DCSP testName = 'TestSL1' DCNL DCSP print ('\nRunning DCSP %s...' % testName) DCNL DCSP (trainingSet, testSet) = self._buildSegmentLearningTrainingSet(numOnes, numRepetitions) DCNL DCSP numCols = len(trainingSet[0][0]) DCNL DCSP tms = self._createTMs(numCols=numCols, fixedResources=fixedResources, checkSynapseConsistency=checkSynapseConsistency) DCNL DCSP testResult = self._testSegmentLearningSequence(tms, trainingSet, testSet) DCNL DCSP if testResult: DCNL DCSP  DCSP print ('%s DCSP PASS' % testName) DCNL DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP print ('%s DCSP FAILED' % testName) DCNL DCSP  DCSP return 0
def _testSL2(self, numOnes=10, numRepetitions=10, fixedResources=False, checkSynapseConsistency=True): DCNL DCSP if fixedResources: DCNL DCSP  DCSP testName = 'TestSL2_FS' DCNL DCSP else: DCNL DCSP  DCSP testName = 'TestSL2' DCNL DCSP print ('\nRunning DCSP %s...' % testName) DCNL DCSP (trainingSet, testSet) = self._buildSL2TrainingSet(numOnes, numRepetitions) DCNL DCSP numCols = len(trainingSet[0][0]) DCNL DCSP tms = self._createTMs(numCols=numCols, fixedResources=fixedResources, checkSynapseConsistency=checkSynapseConsistency) DCNL DCSP testResult = self._testSegmentLearningSequence(tms, trainingSet, testSet) DCNL DCSP if testResult: DCNL DCSP  DCSP print ('%s DCSP PASS' % testName) DCNL DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP print ('%s DCSP FAILED' % testName) DCNL DCSP  DCSP return 0
def test_SL1NoFixedResources(self): DCNL DCSP self._testSL1(fixedResources=False, checkSynapseConsistency=g_options.long)
def test_SL1WithFixedResources(self): DCNL DCSP if (not g_options.long): DCNL DCSP  DCSP print ('Test DCSP %s DCSP only DCSP enabled DCSP with DCSP the DCSP --long DCSP option' % self._testMethodName) DCNL DCSP  DCSP return DCNL DCSP self._testSL1(fixedResources=True, checkSynapseConsistency=g_options.long)
def test_SL2NoFixedResources(self): DCNL DCSP if (not g_options.long): DCNL DCSP  DCSP print ('Test DCSP %s DCSP only DCSP enabled DCSP with DCSP the DCSP --long DCSP option' % self._testMethodName) DCNL DCSP  DCSP return DCNL DCSP self._testSL2(fixedResources=False, checkSynapseConsistency=g_options.long)
def test_SL2WithFixedResources(self): DCNL DCSP if (not g_options.long): DCNL DCSP  DCSP print ('Test DCSP %s DCSP only DCSP enabled DCSP with DCSP the DCSP --long DCSP option' % self._testMethodName) DCNL DCSP  DCSP return DCNL DCSP self._testSL2(fixedResources=True, checkSynapseConsistency=g_options.long)
def __init__(self, requestedActivities): DCNL DCSP self.__activities = [] DCNL DCSP for req in requestedActivities: DCNL DCSP  DCSP act = self.Activity(repeating=req.repeating, period=req.period, cb=req.cb, iteratorHolder=[iter(xrange(req.period))]) DCNL DCSP  DCSP self.__activities.append(act) DCNL DCSP return
def tick(self): DCNL DCSP for act in self.__activities: DCNL DCSP  DCSP if (not act.iteratorHolder[0]): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP next(act.iteratorHolder[0]) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP act.cb() DCNL DCSP  DCSP  DCSP if act.repeating: DCNL DCSP  DCSP  DCSP  DCSP act.iteratorHolder[0] = iter(xrange(act.period)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP act.iteratorHolder[0] = None DCNL DCSP return True
def __init__(self, dirPath, reason): DCNL DCSP super(_CreateDirectoryException, self).__init__((('Error DCSP creating DCSP directory DCSP ' + '<%s>: DCSP %s.') % (str(dirPath), str(reason)))) DCNL DCSP self.reason = reason
def __init__(self, problem, precursor): DCNL DCSP super(_ErrorReportingException, self).__init__((("Encountered DCSP error: DCSP '%s' DCSP while DCSP reporting DCSP " + "error: DCSP '%s'.") % (problem, precursor)))
@staticmethod DCNL def getInputElement(inferenceElement): DCNL DCSP return InferenceElement.__inferenceInputMap.get(inferenceElement, None)
@staticmethod DCNL def isTemporal(inferenceElement): DCNL DCSP if (InferenceElement.__temporalInferenceElements is None): DCNL DCSP  DCSP InferenceElement.__temporalInferenceElements = set([InferenceElement.prediction]) DCNL DCSP return (inferenceElement in InferenceElement.__temporalInferenceElements)
@staticmethod DCNL def getTemporalDelay(inferenceElement, key=None): DCNL DCSP if (inferenceElement in (InferenceElement.prediction, InferenceElement.encodings)): DCNL DCSP  DCSP return 1 DCNL DCSP if (inferenceElement in (InferenceElement.anomalyScore, InferenceElement.anomalyLabel, InferenceElement.classification, InferenceElement.classConfidences)): DCNL DCSP  DCSP return 0 DCNL DCSP if (inferenceElement in (InferenceElement.multiStepPredictions, InferenceElement.multiStepBestPredictions)): DCNL DCSP  DCSP return int(key) DCNL DCSP return 0
@staticmethod DCNL def getMaxDelay(inferences): DCNL DCSP maxDelay = 0 DCNL DCSP for (inferenceElement, inference) in inferences.iteritems(): DCNL DCSP  DCSP if isinstance(inference, dict): DCNL DCSP  DCSP  DCSP for key in inference.iterkeys(): DCNL DCSP  DCSP  DCSP  DCSP maxDelay = max(InferenceElement.getTemporalDelay(inferenceElement, key), maxDelay) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP maxDelay = max(InferenceElement.getTemporalDelay(inferenceElement), maxDelay) DCNL DCSP return maxDelay
@staticmethod DCNL def isTemporal(inferenceType): DCNL DCSP if (InferenceType.__temporalInferenceTypes is None): DCNL DCSP  DCSP InferenceType.__temporalInferenceTypes = set([InferenceType.TemporalNextStep, InferenceType.TemporalClassification, InferenceType.TemporalAnomaly, InferenceType.TemporalMultiStep, InferenceType.NontemporalMultiStep]) DCNL DCSP return (inferenceType in InferenceType.__temporalInferenceTypes)
def __init__(self, options, cmdLineArgs): DCNL DCSP self._options = options DCNL DCSP self.logger = logging.getLogger('.'.join(['com.numenta.nupic.swarming', self.__class__.__name__])) DCNL DCSP if (options.logLevel is not None): DCNL DCSP  DCSP self.logger.setLevel(options.logLevel) DCNL DCSP self.logger.info(('Launched DCSP with DCSP command DCSP line DCSP arguments: DCSP %s' % str(cmdLineArgs))) DCNL DCSP self.logger.debug(('Env DCSP variables: DCSP %s' % pprint.pformat(os.environ))) DCNL DCSP random.seed(42) DCNL DCSP self._hs = None DCNL DCSP self._modelIDCtrDict = dict() DCNL DCSP self._modelIDCtrList = [] DCNL DCSP self._modelIDSet = set() DCNL DCSP self._workerID = None
def _processUpdatedModels(self, cjDAO): DCNL DCSP curModelIDCtrList = cjDAO.modelsGetUpdateCounters(self._options.jobID) DCNL DCSP if (len(curModelIDCtrList) == 0): DCNL DCSP  DCSP return DCNL DCSP self.logger.debug(('current DCSP modelID/updateCounters: DCSP %s' % str(curModelIDCtrList))) DCNL DCSP self.logger.debug(('last DCSP modelID/updateCounters: DCSP %s' % str(self._modelIDCtrList))) DCNL DCSP curModelIDCtrList = sorted(curModelIDCtrList) DCNL DCSP numItems = len(curModelIDCtrList) DCNL DCSP changedEntries = filter((lambda x: (x[1][1] != x[2][1])), itertools.izip(xrange(numItems), curModelIDCtrList, self._modelIDCtrList)) DCNL DCSP if (len(changedEntries) > 0): DCNL DCSP  DCSP self.logger.debug('changedEntries: DCSP %s', str(changedEntries)) DCNL DCSP  DCSP for entry in changedEntries: DCNL DCSP  DCSP  DCSP (idx, (modelID, curCtr), (_, oldCtr)) = entry DCNL DCSP  DCSP  DCSP self._modelIDCtrDict[modelID] = curCtr DCNL DCSP  DCSP  DCSP assert (self._modelIDCtrList[idx][0] == modelID) DCNL DCSP  DCSP  DCSP assert (curCtr != oldCtr) DCNL DCSP  DCSP  DCSP self._modelIDCtrList[idx][1] = curCtr DCNL DCSP  DCSP changedModelIDs = [x[1][0] for x in changedEntries] DCNL DCSP  DCSP modelResults = cjDAO.modelsGetResultAndStatus(changedModelIDs) DCNL DCSP  DCSP for mResult in modelResults: DCNL DCSP  DCSP  DCSP results = mResult.results DCNL DCSP  DCSP  DCSP if (results is not None): DCNL DCSP  DCSP  DCSP  DCSP results = json.loads(results) DCNL DCSP  DCSP  DCSP self._hs.recordModelProgress(modelID=mResult.modelId, modelParams=None, modelParamsHash=mResult.engParamsHash, results=results, completed=(mResult.status == cjDAO.STATUS_COMPLETED), completionReason=mResult.completionReason, matured=mResult.engMatured, numRecords=mResult.numRecords) DCNL DCSP curModelIDSet = set([x[0] for x in curModelIDCtrList]) DCNL DCSP newModelIDs = curModelIDSet.difference(self._modelIDSet) DCNL DCSP if (len(newModelIDs) > 0): DCNL DCSP  DCSP self._modelIDSet.update(newModelIDs) DCNL DCSP  DCSP curModelIDCtrDict = dict(curModelIDCtrList) DCNL DCSP  DCSP modelInfos = cjDAO.modelsGetResultAndStatus(newModelIDs) DCNL DCSP  DCSP modelInfos.sort() DCNL DCSP  DCSP modelParamsAndHashs = cjDAO.modelsGetParams(newModelIDs) DCNL DCSP  DCSP modelParamsAndHashs.sort() DCNL DCSP  DCSP for (mResult, mParamsAndHash) in itertools.izip(modelInfos, modelParamsAndHashs): DCNL DCSP  DCSP  DCSP modelID = mResult.modelId DCNL DCSP  DCSP  DCSP assert (modelID == mParamsAndHash.modelId) DCNL DCSP  DCSP  DCSP self._modelIDCtrDict[modelID] = curModelIDCtrDict[modelID] DCNL DCSP  DCSP  DCSP self._modelIDCtrList.append([modelID, curModelIDCtrDict[modelID]]) DCNL DCSP  DCSP  DCSP results = mResult.results DCNL DCSP  DCSP  DCSP if (results is not None): DCNL DCSP  DCSP  DCSP  DCSP results = json.loads(mResult.results) DCNL DCSP  DCSP  DCSP self._hs.recordModelProgress(modelID=modelID, modelParams=json.loads(mParamsAndHash.params), modelParamsHash=mParamsAndHash.engParamsHash, results=results, completed=(mResult.status == cjDAO.STATUS_COMPLETED), completionReason=mResult.completionReason, matured=mResult.engMatured, numRecords=mResult.numRecords) DCNL DCSP  DCSP self._modelIDCtrList.sort()
def run(self): DCNL DCSP options = self._options DCNL DCSP self.logger.info('Connecting DCSP to DCSP the DCSP jobs DCSP database') DCNL DCSP cjDAO = ClientJobsDAO.get() DCNL DCSP self._workerID = cjDAO.getConnectionID() DCNL DCSP if options.clearModels: DCNL DCSP  DCSP cjDAO.modelsClearAll() DCNL DCSP if (options.params is not None): DCNL DCSP  DCSP options.jobID = cjDAO.jobInsert(client='hwTest', cmdLine="echo DCSP 'test DCSP mode'", params=options.params, alreadyRunning=True, minimumWorkers=1, maximumWorkers=1, jobType=cjDAO.JOB_TYPE_HS) DCNL DCSP if (options.workerID is not None): DCNL DCSP  DCSP wID = options.workerID DCNL DCSP else: DCNL DCSP  DCSP wID = self._workerID DCNL DCSP buildID = Configuration.get('nupic.software.buildNumber', 'N/A') DCNL DCSP logPrefix = ('<BUILDID=%s, DCSP WORKER=HW, DCSP WRKID=%s, DCSP JOBID=%s> DCSP ' % (buildID, wID, options.jobID)) DCNL DCSP ExtendedLogger.setLogPrefix(logPrefix) DCNL DCSP if options.resetJobStatus: DCNL DCSP  DCSP cjDAO.jobSetFields(options.jobID, fields={'workerCompletionReason': ClientJobsDAO.CMPL_REASON_SUCCESS, 'cancel': False}, useConnectionID=False, ignoreUnchanged=True) DCNL DCSP jobInfo = cjDAO.jobInfo(options.jobID) DCNL DCSP self.logger.info(('Job DCSP info DCSP retrieved: DCSP %s' % str(clippedObj(jobInfo)))) DCNL DCSP jobParams = json.loads(jobInfo.params) DCNL DCSP jsonSchemaPath = os.path.join(os.path.dirname(__file__), 'jsonschema', 'jobParamsSchema.json') DCNL DCSP validate(jobParams, schemaPath=jsonSchemaPath) DCNL DCSP hsVersion = jobParams.get('hsVersion', None) DCNL DCSP if (hsVersion == 'v2'): DCNL DCSP  DCSP self._hs = HypersearchV2(searchParams=jobParams, workerID=self._workerID, cjDAO=cjDAO, jobID=options.jobID, logLevel=options.logLevel) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(('Invalid DCSP Hypersearch DCSP implementation DCSP (%s) DCSP specified' % hsVersion)) DCNL DCSP try: DCNL DCSP  DCSP exit = False DCNL DCSP  DCSP numModelsTotal = 0 DCNL DCSP  DCSP print >>sys.stderr, 'reporter:status:Evaluating DCSP first DCSP model...' DCNL DCSP  DCSP while (not exit): DCNL DCSP  DCSP  DCSP batchSize = 10 DCNL DCSP  DCSP  DCSP modelIDToRun = None DCNL DCSP  DCSP  DCSP while (modelIDToRun is None): DCNL DCSP  DCSP  DCSP  DCSP if (options.modelID is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._processUpdatedModels(cjDAO) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (exit, newModels) = self._hs.createModels(numModels=batchSize) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if exit: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(newModels) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (modelParams, modelParamsHash, particleHash) in newModels: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP jsonModelParams = json.dumps(modelParams) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (modelID, ours) = cjDAO.modelInsertAndStart(options.jobID, jsonModelParams, modelParamsHash, particleHash) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not ours): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mParamsAndHash = cjDAO.modelsGetParams([modelID])[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mResult = cjDAO.modelsGetResultAndStatus([modelID])[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP results = mResult.results DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (results is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP results = json.loads(results) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP modelParams = json.loads(mParamsAndHash.params) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP particleHash = cjDAO.modelsGetFields(modelID, ['engParticleHash'])[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP particleInst = ('%s.%s' % (modelParams['particleState']['id'], modelParams['particleState']['genIdx'])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.logger.info("Adding DCSP model DCSP %d DCSP to DCSP our DCSP internal DCSP DB DCSP because DCSP modelInsertAndStart() DCSP failed DCSP to DCSP insert DCSP it: DCSP paramsHash=%s, DCSP particleHash=%s, DCSP particleId='%s'", modelID, mParamsAndHash.engParamsHash.encode('hex'), particleHash.encode('hex'), particleInst) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._hs.recordModelProgress(modelID=modelID, modelParams=modelParams, modelParamsHash=mParamsAndHash.engParamsHash, results=results, completed=(mResult.status == cjDAO.STATUS_COMPLETED), completionReason=mResult.completionReason, matured=mResult.engMatured, numRecords=mResult.numRecords) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP modelIDToRun = modelID DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP modelIDToRun = int(options.modelID) DCNL DCSP  DCSP  DCSP  DCSP  DCSP mParamsAndHash = cjDAO.modelsGetParams([modelIDToRun])[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP modelParams = json.loads(mParamsAndHash.params) DCNL DCSP  DCSP  DCSP  DCSP  DCSP modelParamsHash = mParamsAndHash.engParamsHash DCNL DCSP  DCSP  DCSP  DCSP  DCSP cjDAO.modelSetFields(modelIDToRun, dict(engWorkerConnId=self._workerID)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if False: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for attempt in range(1000): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP paramsHash = hashlib.md5(('OrphanParams.%d.%d' % (modelIDToRun, attempt))).digest() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP particleHash = hashlib.md5(('OrphanParticle.%d.%d' % (modelIDToRun, attempt))).digest() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cjDAO.modelSetFields(modelIDToRun, dict(engParamsHash=paramsHash, engParticleHash=particleHash)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP success = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('Unexpected DCSP failure DCSP to DCSP change DCSP paramsHash DCSP and DCSP particleHash DCSP of DCSP orphaned DCSP model') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (modelIDToRun, ours) = cjDAO.modelInsertAndStart(options.jobID, mParamsAndHash.params, modelParamsHash) DCNL DCSP  DCSP  DCSP if exit: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP self.logger.info('RUNNING DCSP MODEL DCSP GID=%d, DCSP paramsHash=%s, DCSP params=%s', modelIDToRun, modelParamsHash.encode('hex'), modelParams) DCNL DCSP  DCSP  DCSP persistentJobGUID = jobParams['persistentJobGUID'] DCNL DCSP  DCSP  DCSP assert persistentJobGUID, ('persistentJobGUID: DCSP %r' % (persistentJobGUID,)) DCNL DCSP  DCSP  DCSP modelCheckpointGUID = (((jobInfo.client + '_') + persistentJobGUID) + ('_' + str(modelIDToRun))) DCNL DCSP  DCSP  DCSP self._hs.runModel(modelID=modelIDToRun, jobID=options.jobID, modelParams=modelParams, modelParamsHash=modelParamsHash, jobsDAO=cjDAO, modelCheckpointGUID=modelCheckpointGUID) DCNL DCSP  DCSP  DCSP numModelsTotal += 1 DCNL DCSP  DCSP  DCSP self.logger.info('COMPLETED DCSP MODEL DCSP GID=%d; DCSP EVALUATED DCSP %d DCSP MODELs', modelIDToRun, numModelsTotal) DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('reporter:status:Evaluated DCSP %d DCSP models...' % numModelsTotal) DCNL DCSP  DCSP  DCSP print >>sys.stderr, 'reporter:counter:HypersearchWorker,numModels,1' DCNL DCSP  DCSP  DCSP if (options.modelID is not None): DCNL DCSP  DCSP  DCSP  DCSP exit = True DCNL DCSP finally: DCNL DCSP  DCSP self._hs.close() DCNL DCSP self.logger.info(('FINISHED. DCSP Evaluated DCSP %d DCSP models.' % numModelsTotal)) DCNL DCSP print >>sys.stderr, ('reporter:status:Finished, DCSP evaluated DCSP %d DCSP models' % numModelsTotal) DCNL DCSP return options.jobID
def __init__(self, modelID, jobID, params, predictedField, reportKeyPatterns, optimizeKeyPattern, jobsDAO, modelCheckpointGUID, logLevel=None, predictionCacheMaxRecords=None): DCNL DCSP super(OPFDummyModelRunner, self).__init__(modelID=modelID, jobID=jobID, predictedField=predictedField, experimentDir=None, reportKeyPatterns=reportKeyPatterns, optimizeKeyPattern=optimizeKeyPattern, jobsDAO=jobsDAO, modelCheckpointGUID=modelCheckpointGUID, logLevel=logLevel, predictionCacheMaxRecords=None) DCNL DCSP self._predictionCacheMaxRecords = predictionCacheMaxRecords DCNL DCSP self._streamDef = copy.deepcopy(self._DUMMY_STREAMDEF) DCNL DCSP self._params = copy.deepcopy(self._DEFAULT_PARAMS) DCNL DCSP if (('permutationParams' in params) and ('__model_num' in params['permutationParams'])): DCNL DCSP  DCSP self.modelIndex = params['permutationParams']['__model_num'] DCNL DCSP else: DCNL DCSP  DCSP self.modelIndex = OPFDummyModelRunner.modelIndex DCNL DCSP  DCSP OPFDummyModelRunner.modelIndex += 1 DCNL DCSP self._loadDummyModelParameters(params) DCNL DCSP self._logger.debug('Using DCSP Dummy DCSP model DCSP params: DCSP %s', self._params) DCNL DCSP self._busyWaitTime = self._params['waitTime'] DCNL DCSP self._iterations = self._params['iterations'] DCNL DCSP self._doFinalize = self._params['finalize'] DCNL DCSP self._delay = self._params['delay'] DCNL DCSP self._sleepModelRange = self._params['sleepModelRange'] DCNL DCSP self._makeCheckpoint = self._params['makeCheckpoint'] DCNL DCSP self._finalDelay = self._params['finalDelay'] DCNL DCSP self._exitAfter = self._params['exitAfter'] DCNL DCSP self.randomizeWait = self._params['randomizeWait'] DCNL DCSP if (self._busyWaitTime is not None): DCNL DCSP  DCSP self.__computeWaitTime() DCNL DCSP if ((self._params['metricFunctions'] is not None) and (self._params['metricValue'] is not None)): DCNL DCSP  DCSP raise RuntimeError("Error, DCSP only DCSP 1 DCSP of DCSP 'metricFunctions' DCSP or DCSP 'metricValue' DCSP can DCSP be DCSP passed DCSP to DCSP OPFDummyModelRunner DCSP params DCSP ") DCNL DCSP self.metrics = None DCNL DCSP self.metricValue = None DCNL DCSP if (self._params['metricFunctions'] is not None): DCNL DCSP  DCSP self.metrics = eval(self._params['metricFunctions']) DCNL DCSP elif (self._params['metricValue'] is not None): DCNL DCSP  DCSP self.metricValue = float(self._params['metricValue']) DCNL DCSP else: DCNL DCSP  DCSP self.metrics = OPFDummyModelRunner.metrics[0] DCNL DCSP if (self._params['experimentDirectory'] is not None): DCNL DCSP  DCSP self._model = self.__createModel(self._params['experimentDirectory']) DCNL DCSP  DCSP self.__fieldInfo = self._model.getFieldInfo() DCNL DCSP self._sysExitModelRange = self._params['sysExitModelRange'] DCNL DCSP if (self._sysExitModelRange is not None): DCNL DCSP  DCSP self._sysExitModelRange = [int(x) for x in self._sysExitModelRange.split(',')] DCNL DCSP self._delayModelRange = self._params['delayModelRange'] DCNL DCSP if (self._delayModelRange is not None): DCNL DCSP  DCSP self._delayModelRange = [int(x) for x in self._delayModelRange.split(',')] DCNL DCSP self._errModelRange = self._params['errModelRange'] DCNL DCSP if (self._errModelRange is not None): DCNL DCSP  DCSP self._errModelRange = [int(x) for x in self._errModelRange.split(',')] DCNL DCSP self._computModelDelay() DCNL DCSP self._jobFailErr = self._params['jobFailErr'] DCNL DCSP self._logger.debug('Dummy DCSP Model DCSP %d DCSP params DCSP %r', self._modelID, self._params)
def _loadDummyModelParameters(self, params): DCNL DCSP for (key, value) in params.iteritems(): DCNL DCSP  DCSP if (type(value) == list): DCNL DCSP  DCSP  DCSP index = (self.modelIndex % len(params[key])) DCNL DCSP  DCSP  DCSP self._params[key] = params[key][index] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._params[key] = params[key]
def _computModelDelay(self): DCNL DCSP if ((self._params['delay'] is not None) and (self._params['sleepModelRange'] is not None)): DCNL DCSP  DCSP raise RuntimeError("Only DCSP one DCSP of DCSP 'delay' DCSP or DCSP 'sleepModelRange' DCSP may DCSP be DCSP specified") DCNL DCSP if (self._sleepModelRange is not None): DCNL DCSP  DCSP (range, delay) = self._sleepModelRange.split(':') DCNL DCSP  DCSP delay = float(delay) DCNL DCSP  DCSP range = map(int, range.split(',')) DCNL DCSP  DCSP modelIDs = self._jobsDAO.jobGetModelIDs(self._jobID) DCNL DCSP  DCSP modelIDs.sort() DCNL DCSP  DCSP range[1] = min(range[1], len(modelIDs)) DCNL DCSP  DCSP if (self._modelID in modelIDs[range[0]:range[1]]): DCNL DCSP  DCSP  DCSP self._delay = delay DCNL DCSP else: DCNL DCSP  DCSP self._delay = self._params['delay']
def _getMetrics(self): DCNL DCSP metric = None DCNL DCSP if (self.metrics is not None): DCNL DCSP  DCSP metric = self.metrics((self._currentRecordIndex + 1)) DCNL DCSP elif (self.metricValue is not None): DCNL DCSP  DCSP metric = self.metricValue DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('No DCSP metrics DCSP or DCSP metric DCSP value DCSP specified DCSP for DCSP dummy DCSP model') DCNL DCSP return {self._optimizeKeyPattern: metric}
def run(self): DCNL DCSP self._logger.debug(('Starting DCSP Dummy DCSP Model: DCSP modelID=%s;' % self._modelID)) DCNL DCSP periodic = self._initPeriodicActivities() DCNL DCSP self._optimizedMetricLabel = self._optimizeKeyPattern DCNL DCSP self._reportMetricLabels = [self._optimizeKeyPattern] DCNL DCSP if (self._iterations >= 0): DCNL DCSP  DCSP iterTracker = iter(xrange(self._iterations)) DCNL DCSP else: DCNL DCSP  DCSP iterTracker = iter(itertools.count()) DCNL DCSP doSysExit = False DCNL DCSP if (self._sysExitModelRange is not None): DCNL DCSP  DCSP modelAndCounters = self._jobsDAO.modelsGetUpdateCounters(self._jobID) DCNL DCSP  DCSP modelIDs = [x[0] for x in modelAndCounters] DCNL DCSP  DCSP modelIDs.sort() DCNL DCSP  DCSP (beg, end) = self._sysExitModelRange DCNL DCSP  DCSP if (self._modelID in modelIDs[int(beg):int(end)]): DCNL DCSP  DCSP  DCSP doSysExit = True DCNL DCSP if (self._delayModelRange is not None): DCNL DCSP  DCSP modelAndCounters = self._jobsDAO.modelsGetUpdateCounters(self._jobID) DCNL DCSP  DCSP modelIDs = [x[0] for x in modelAndCounters] DCNL DCSP  DCSP modelIDs.sort() DCNL DCSP  DCSP (beg, end) = self._delayModelRange DCNL DCSP  DCSP if (self._modelID in modelIDs[int(beg):int(end)]): DCNL DCSP  DCSP  DCSP time.sleep(10) DCNL DCSP if (self._errModelRange is not None): DCNL DCSP  DCSP modelAndCounters = self._jobsDAO.modelsGetUpdateCounters(self._jobID) DCNL DCSP  DCSP modelIDs = [x[0] for x in modelAndCounters] DCNL DCSP  DCSP modelIDs.sort() DCNL DCSP  DCSP (beg, end) = self._errModelRange DCNL DCSP  DCSP if (self._modelID in modelIDs[int(beg):int(end)]): DCNL DCSP  DCSP  DCSP raise RuntimeError('Exiting DCSP with DCSP error DCSP due DCSP to DCSP errModelRange DCSP parameter') DCNL DCSP if (self._delay is not None): DCNL DCSP  DCSP time.sleep(self._delay) DCNL DCSP self._currentRecordIndex = 0 DCNL DCSP while True: DCNL DCSP  DCSP if self._isKilled: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if self._isCanceled: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if self._isMature: DCNL DCSP  DCSP  DCSP if (not self._isBestModel): DCNL DCSP  DCSP  DCSP  DCSP self._cmpReason = self._jobsDAO.CMPL_REASON_STOPPED DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self._cmpReason = self._jobsDAO.CMPL_REASON_EOF DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self._currentRecordIndex = next(iterTracker) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP self._writePrediction(ModelResult(None, None, None, None)) DCNL DCSP  DCSP periodic.tick() DCNL DCSP  DCSP if self.__shouldSysExit(self._currentRecordIndex): DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP if (self._busyWaitTime is not None): DCNL DCSP  DCSP  DCSP time.sleep(self._busyWaitTime) DCNL DCSP  DCSP  DCSP self.__computeWaitTime() DCNL DCSP  DCSP if doSysExit: DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP if self._jobFailErr: DCNL DCSP  DCSP  DCSP raise utils.JobFailException('E10000', "dummyModel's DCSP jobFailErr DCSP was DCSP True.") DCNL DCSP if self._doFinalize: DCNL DCSP  DCSP if (not self._makeCheckpoint): DCNL DCSP  DCSP  DCSP self._model = None DCNL DCSP  DCSP if (self._finalDelay is not None): DCNL DCSP  DCSP  DCSP time.sleep(self._finalDelay) DCNL DCSP  DCSP self._finalize() DCNL DCSP self._logger.info(('Finished: DCSP modelID=%r DCSP ' % self._modelID)) DCNL DCSP return (self._cmpReason, None)
def _createPredictionLogger(self): DCNL DCSP class DummyLogger: DCNL DCSP  DCSP def writeRecord(self, record): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def writeRecords(self, records, progressCB): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def close(self): DCNL DCSP  DCSP  DCSP pass DCNL DCSP self._predictionLogger = DummyLogger()
def __shouldSysExit(self, iteration): DCNL DCSP if ((self._exitAfter is None) or (iteration < self._exitAfter)): DCNL DCSP  DCSP return False DCNL DCSP results = self._jobsDAO.modelsGetFieldsForJob(self._jobID, ['params']) DCNL DCSP modelIDs = [e[0] for e in results] DCNL DCSP modelNums = [json.loads(e[1][0])['structuredParams']['__model_num'] for e in results] DCNL DCSP sameModelNumbers = filter((lambda x: (x[1] == self.modelIndex)), zip(modelIDs, modelNums)) DCNL DCSP firstModelID = min(zip(*sameModelNumbers)[0]) DCNL DCSP return (firstModelID == self._modelID)
def __init__(self, hsObj): DCNL DCSP self._hsObj = hsObj DCNL DCSP self.logger = self._hsObj.logger DCNL DCSP self._state = None DCNL DCSP self._priorStateJSON = None DCNL DCSP self._dirty = False DCNL DCSP self.readStateFromDB()
def isDirty(self): DCNL DCSP return self._dirty
def isSearchOver(self): DCNL DCSP return self._state['searchOver']
def readStateFromDB(self): DCNL DCSP self._priorStateJSON = self._hsObj._cjDAO.jobGetFields(self._hsObj._jobID, ['engWorkerState'])[0] DCNL DCSP if (self._priorStateJSON is None): DCNL DCSP  DCSP swarms = dict() DCNL DCSP  DCSP if (self._hsObj._fixedFields is not None): DCNL DCSP  DCSP  DCSP print self._hsObj._fixedFields DCNL DCSP  DCSP  DCSP encoderSet = [] DCNL DCSP  DCSP  DCSP for field in self._hsObj._fixedFields: DCNL DCSP  DCSP  DCSP  DCSP if (field == '_classifierInput'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP encoderName = self.getEncoderKeyFromName(field) DCNL DCSP  DCSP  DCSP  DCSP assert (encoderName in self._hsObj._encoderNames), ("The DCSP field DCSP '%s' DCSP  DCSP specified DCSP in DCSP the DCSP fixedFields DCSP list DCSP is DCSP not DCSP present DCSP in DCSP this DCSP  DCSP model." % field) DCNL DCSP  DCSP  DCSP  DCSP encoderSet.append(encoderName) DCNL DCSP  DCSP  DCSP encoderSet.sort() DCNL DCSP  DCSP  DCSP swarms['.'.join(encoderSet)] = {'status': 'active', 'bestModelId': None, 'bestErrScore': None, 'sprintIdx': 0} DCNL DCSP  DCSP elif (self._hsObj._searchType == HsSearchType.temporal): DCNL DCSP  DCSP  DCSP for encoderName in self._hsObj._encoderNames: DCNL DCSP  DCSP  DCSP  DCSP swarms[encoderName] = {'status': 'active', 'bestModelId': None, 'bestErrScore': None, 'sprintIdx': 0} DCNL DCSP  DCSP elif (self._hsObj._searchType == HsSearchType.classification): DCNL DCSP  DCSP  DCSP for encoderName in self._hsObj._encoderNames: DCNL DCSP  DCSP  DCSP  DCSP if (encoderName == self._hsObj._predictedFieldEncoder): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP swarms[encoderName] = {'status': 'active', 'bestModelId': None, 'bestErrScore': None, 'sprintIdx': 0} DCNL DCSP  DCSP elif (self._hsObj._searchType == HsSearchType.legacyTemporal): DCNL DCSP  DCSP  DCSP swarms[self._hsObj._predictedFieldEncoder] = {'status': 'active', 'bestModelId': None, 'bestErrScore': None, 'sprintIdx': 0} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError(('Unsupported DCSP search DCSP type: DCSP %s' % self._hsObj._searchType)) DCNL DCSP  DCSP self._state = dict(lastUpdateTime=time.time(), lastGoodSprint=None, searchOver=False, activeSwarms=swarms.keys(), swarms=swarms, sprints=[{'status': 'active', 'bestModelId': None, 'bestErrScore': None}], blackListedEncoders=[]) DCNL DCSP  DCSP self._hsObj._cjDAO.jobSetFieldIfEqual(self._hsObj._jobID, 'engWorkerState', json.dumps(self._state), None) DCNL DCSP  DCSP self._priorStateJSON = self._hsObj._cjDAO.jobGetFields(self._hsObj._jobID, ['engWorkerState'])[0] DCNL DCSP  DCSP assert (self._priorStateJSON is not None) DCNL DCSP self._state = json.loads(self._priorStateJSON) DCNL DCSP self._dirty = False
def writeStateToDB(self): DCNL DCSP if (not self._dirty): DCNL DCSP  DCSP return True DCNL DCSP self._state['lastUpdateTime'] = time.time() DCNL DCSP newStateJSON = json.dumps(self._state) DCNL DCSP success = self._hsObj._cjDAO.jobSetFieldIfEqual(self._hsObj._jobID, 'engWorkerState', str(newStateJSON), str(self._priorStateJSON)) DCNL DCSP if success: DCNL DCSP  DCSP self.logger.debug(('Success DCSP changing DCSP hsState DCSP to: DCSP \n%s DCSP ' % pprint.pformat(self._state, indent=4))) DCNL DCSP  DCSP self._priorStateJSON = newStateJSON DCNL DCSP else: DCNL DCSP  DCSP self.logger.debug(('Failed DCSP to DCSP change DCSP hsState DCSP to: DCSP \n%s DCSP ' % pprint.pformat(self._state, indent=4))) DCNL DCSP  DCSP self._priorStateJSON = self._hsObj._cjDAO.jobGetFields(self._hsObj._jobID, ['engWorkerState'])[0] DCNL DCSP  DCSP self._state = json.loads(self._priorStateJSON) DCNL DCSP  DCSP self.logger.info(('New DCSP hsState DCSP has DCSP been DCSP set DCSP by DCSP some DCSP other DCSP worker DCSP to: DCSP  DCSP \n%s' % pprint.pformat(self._state, indent=4))) DCNL DCSP return success
def getEncoderNameFromKey(self, key): DCNL DCSP return key.split('|')[(-1)]
def getEncoderKeyFromName(self, name): DCNL DCSP return ('modelParams|sensorParams|encoders|%s' % name)
def getFieldContributions(self): DCNL DCSP if (self._hsObj._fixedFields is not None): DCNL DCSP  DCSP return (dict(), dict()) DCNL DCSP predictedEncoderName = self._hsObj._predictedFieldEncoder DCNL DCSP fieldScores = [] DCNL DCSP for (swarmId, info) in self._state['swarms'].iteritems(): DCNL DCSP  DCSP encodersUsed = swarmId.split('.') DCNL DCSP  DCSP if (len(encodersUsed) != 1): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP field = self.getEncoderNameFromKey(encodersUsed[0]) DCNL DCSP  DCSP bestScore = info['bestErrScore'] DCNL DCSP  DCSP if (bestScore is None): DCNL DCSP  DCSP  DCSP (_modelId, bestScore) = self._hsObj._resultsDB.bestModelIdAndErrScore(swarmId) DCNL DCSP  DCSP fieldScores.append((bestScore, field)) DCNL DCSP if (self._hsObj._searchType == HsSearchType.legacyTemporal): DCNL DCSP  DCSP assert (len(fieldScores) == 1) DCNL DCSP  DCSP (baseErrScore, baseField) = fieldScores[0] DCNL DCSP  DCSP for (swarmId, info) in self._state['swarms'].iteritems(): DCNL DCSP  DCSP  DCSP encodersUsed = swarmId.split('.') DCNL DCSP  DCSP  DCSP if (len(encodersUsed) != 2): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP fields = [self.getEncoderNameFromKey(name) for name in encodersUsed] DCNL DCSP  DCSP  DCSP fields.remove(baseField) DCNL DCSP  DCSP  DCSP fieldScores.append((info['bestErrScore'], fields[0])) DCNL DCSP else: DCNL DCSP  DCSP fieldScores.sort(reverse=True) DCNL DCSP  DCSP if ((self._hsObj._maxBranching > 0) and (len(fieldScores) > self._hsObj._maxBranching)): DCNL DCSP  DCSP  DCSP baseErrScore = fieldScores[((- self._hsObj._maxBranching) - 1)][0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP baseErrScore = fieldScores[0][0] DCNL DCSP pctFieldContributionsDict = dict() DCNL DCSP absFieldContributionsDict = dict() DCNL DCSP if (baseErrScore is not None): DCNL DCSP  DCSP if (abs(baseErrScore) < 1e-05): DCNL DCSP  DCSP  DCSP baseErrScore = 1e-05 DCNL DCSP  DCSP for (errScore, field) in fieldScores: DCNL DCSP  DCSP  DCSP if (errScore is not None): DCNL DCSP  DCSP  DCSP  DCSP pctBetter = (((baseErrScore - errScore) * 100.0) / baseErrScore) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP pctBetter = 0.0 DCNL DCSP  DCSP  DCSP  DCSP errScore = baseErrScore DCNL DCSP  DCSP  DCSP pctFieldContributionsDict[field] = pctBetter DCNL DCSP  DCSP  DCSP absFieldContributionsDict[field] = (baseErrScore - errScore) DCNL DCSP self.logger.debug(('FieldContributions: DCSP %s' % pctFieldContributionsDict)) DCNL DCSP return (pctFieldContributionsDict, absFieldContributionsDict)
def getAllSwarms(self, sprintIdx): DCNL DCSP swarmIds = [] DCNL DCSP for (swarmId, info) in self._state['swarms'].iteritems(): DCNL DCSP  DCSP if (info['sprintIdx'] == sprintIdx): DCNL DCSP  DCSP  DCSP swarmIds.append(swarmId) DCNL DCSP return swarmIds
def getActiveSwarms(self, sprintIdx=None): DCNL DCSP swarmIds = [] DCNL DCSP for (swarmId, info) in self._state['swarms'].iteritems(): DCNL DCSP  DCSP if ((sprintIdx is not None) and (info['sprintIdx'] != sprintIdx)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (info['status'] == 'active'): DCNL DCSP  DCSP  DCSP swarmIds.append(swarmId) DCNL DCSP return swarmIds
def getNonKilledSwarms(self, sprintIdx): DCNL DCSP swarmIds = [] DCNL DCSP for (swarmId, info) in self._state['swarms'].iteritems(): DCNL DCSP  DCSP if ((info['sprintIdx'] == sprintIdx) and (info['status'] != 'killed')): DCNL DCSP  DCSP  DCSP swarmIds.append(swarmId) DCNL DCSP return swarmIds
def getCompletedSwarms(self): DCNL DCSP swarmIds = [] DCNL DCSP for (swarmId, info) in self._state['swarms'].iteritems(): DCNL DCSP  DCSP if (info['status'] == 'completed'): DCNL DCSP  DCSP  DCSP swarmIds.append(swarmId) DCNL DCSP return swarmIds
def getCompletingSwarms(self): DCNL DCSP swarmIds = [] DCNL DCSP for (swarmId, info) in self._state['swarms'].iteritems(): DCNL DCSP  DCSP if (info['status'] == 'completing'): DCNL DCSP  DCSP  DCSP swarmIds.append(swarmId) DCNL DCSP return swarmIds
def bestModelInCompletedSwarm(self, swarmId): DCNL DCSP swarmInfo = self._state['swarms'][swarmId] DCNL DCSP return (swarmInfo['bestModelId'], swarmInfo['bestErrScore'])
def bestModelInCompletedSprint(self, sprintIdx): DCNL DCSP sprintInfo = self._state['sprints'][sprintIdx] DCNL DCSP return (sprintInfo['bestModelId'], sprintInfo['bestErrScore'])
def bestModelInSprint(self, sprintIdx): DCNL DCSP swarms = self.getAllSwarms(sprintIdx) DCNL DCSP bestModelId = None DCNL DCSP bestErrScore = numpy.inf DCNL DCSP for swarmId in swarms: DCNL DCSP  DCSP (modelId, errScore) = self._hsObj._resultsDB.bestModelIdAndErrScore(swarmId) DCNL DCSP  DCSP if (errScore < bestErrScore): DCNL DCSP  DCSP  DCSP bestModelId = modelId DCNL DCSP  DCSP  DCSP bestErrScore = errScore DCNL DCSP return (bestModelId, bestErrScore)
def setSwarmState(self, swarmId, newStatus): DCNL DCSP assert (newStatus in ['active', 'completing', 'completed', 'killed']) DCNL DCSP swarmInfo = self._state['swarms'][swarmId] DCNL DCSP if (swarmInfo['status'] == newStatus): DCNL DCSP  DCSP return DCNL DCSP if ((swarmInfo['status'] == 'completed') and (newStatus == 'completing')): DCNL DCSP  DCSP return DCNL DCSP self._dirty = True DCNL DCSP swarmInfo['status'] = newStatus DCNL DCSP if (newStatus == 'completed'): DCNL DCSP  DCSP (modelId, errScore) = self._hsObj._resultsDB.bestModelIdAndErrScore(swarmId) DCNL DCSP  DCSP swarmInfo['bestModelId'] = modelId DCNL DCSP  DCSP swarmInfo['bestErrScore'] = errScore DCNL DCSP if ((newStatus != 'active') and (swarmId in self._state['activeSwarms'])): DCNL DCSP  DCSP self._state['activeSwarms'].remove(swarmId) DCNL DCSP if (newStatus == 'killed'): DCNL DCSP  DCSP self._hsObj.killSwarmParticles(swarmId) DCNL DCSP sprintIdx = swarmInfo['sprintIdx'] DCNL DCSP self.isSprintActive(sprintIdx) DCNL DCSP sprintInfo = self._state['sprints'][sprintIdx] DCNL DCSP statusCounts = dict(active=0, completing=0, completed=0, killed=0) DCNL DCSP bestModelIds = [] DCNL DCSP bestErrScores = [] DCNL DCSP for info in self._state['swarms'].itervalues(): DCNL DCSP  DCSP if (info['sprintIdx'] != sprintIdx): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP statusCounts[info['status']] += 1 DCNL DCSP  DCSP if (info['status'] == 'completed'): DCNL DCSP  DCSP  DCSP bestModelIds.append(info['bestModelId']) DCNL DCSP  DCSP  DCSP bestErrScores.append(info['bestErrScore']) DCNL DCSP if (statusCounts['active'] > 0): DCNL DCSP  DCSP sprintStatus = 'active' DCNL DCSP elif (statusCounts['completing'] > 0): DCNL DCSP  DCSP sprintStatus = 'completing' DCNL DCSP else: DCNL DCSP  DCSP sprintStatus = 'completed' DCNL DCSP sprintInfo['status'] = sprintStatus DCNL DCSP if (sprintStatus == 'completed'): DCNL DCSP  DCSP if (len(bestErrScores) > 0): DCNL DCSP  DCSP  DCSP whichIdx = numpy.array(bestErrScores).argmin() DCNL DCSP  DCSP  DCSP sprintInfo['bestModelId'] = bestModelIds[whichIdx] DCNL DCSP  DCSP  DCSP sprintInfo['bestErrScore'] = bestErrScores[whichIdx] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sprintInfo['bestModelId'] = 0 DCNL DCSP  DCSP  DCSP sprintInfo['bestErrScore'] = numpy.inf DCNL DCSP  DCSP bestPrior = numpy.inf DCNL DCSP  DCSP for idx in range(sprintIdx): DCNL DCSP  DCSP  DCSP if (self._state['sprints'][idx]['status'] == 'completed'): DCNL DCSP  DCSP  DCSP  DCSP (_, errScore) = self.bestModelInCompletedSprint(idx) DCNL DCSP  DCSP  DCSP  DCSP if (errScore is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP errScore = numpy.inf DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP errScore = numpy.inf DCNL DCSP  DCSP  DCSP if (errScore < bestPrior): DCNL DCSP  DCSP  DCSP  DCSP bestPrior = errScore DCNL DCSP  DCSP if (sprintInfo['bestErrScore'] >= bestPrior): DCNL DCSP  DCSP  DCSP self._state['lastGoodSprint'] = (sprintIdx - 1) DCNL DCSP  DCSP if ((self._state['lastGoodSprint'] is not None) and (not self.anyGoodSprintsActive())): DCNL DCSP  DCSP  DCSP self._state['searchOver'] = True
def anyGoodSprintsActive(self): DCNL DCSP if (self._state['lastGoodSprint'] is not None): DCNL DCSP  DCSP goodSprints = self._state['sprints'][0:(self._state['lastGoodSprint'] + 1)] DCNL DCSP else: DCNL DCSP  DCSP goodSprints = self._state['sprints'] DCNL DCSP for sprint in goodSprints: DCNL DCSP  DCSP if (sprint['status'] == 'active'): DCNL DCSP  DCSP  DCSP anyActiveSprints = True DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP anyActiveSprints = False DCNL DCSP return anyActiveSprints
def isSprintCompleted(self, sprintIdx): DCNL DCSP numExistingSprints = len(self._state['sprints']) DCNL DCSP if (sprintIdx >= numExistingSprints): DCNL DCSP  DCSP return False DCNL DCSP return (self._state['sprints'][sprintIdx]['status'] == 'completed')
def killUselessSwarms(self): DCNL DCSP numExistingSprints = len(self._state['sprints']) DCNL DCSP if (self._hsObj._searchType == HsSearchType.legacyTemporal): DCNL DCSP  DCSP if (numExistingSprints <= 2): DCNL DCSP  DCSP  DCSP return DCNL DCSP elif (numExistingSprints <= 1): DCNL DCSP  DCSP return DCNL DCSP completedSwarms = self.getCompletedSwarms() DCNL DCSP completedSwarms = [(swarm, self._state['swarms'][swarm], self._state['swarms'][swarm]['bestErrScore']) for swarm in completedSwarms] DCNL DCSP completedMatrix = [[] for i in range(numExistingSprints)] DCNL DCSP for swarm in completedSwarms: DCNL DCSP  DCSP completedMatrix[swarm[1]['sprintIdx']].append(swarm) DCNL DCSP for sprint in completedMatrix: DCNL DCSP  DCSP sprint.sort(key=itemgetter(2)) DCNL DCSP activeSwarms = self.getActiveSwarms() DCNL DCSP activeSwarms.extend(self.getCompletingSwarms()) DCNL DCSP activeSwarms = [(swarm, self._state['swarms'][swarm], self._state['swarms'][swarm]['bestErrScore']) for swarm in activeSwarms] DCNL DCSP activeMatrix = [[] for i in range(numExistingSprints)] DCNL DCSP for swarm in activeSwarms: DCNL DCSP  DCSP activeMatrix[swarm[1]['sprintIdx']].append(swarm) DCNL DCSP for sprint in activeMatrix: DCNL DCSP  DCSP sprint.sort(key=itemgetter(2)) DCNL DCSP toKill = [] DCNL DCSP for i in range(1, numExistingSprints): DCNL DCSP  DCSP for swarm in activeMatrix[i]: DCNL DCSP  DCSP  DCSP curSwarmEncoders = swarm[0].split('.') DCNL DCSP  DCSP  DCSP if (len(activeMatrix[(i - 1)]) == 0): DCNL DCSP  DCSP  DCSP  DCSP if ((i == 2) and (self._hsObj._tryAll3FieldCombinations or self._hsObj._tryAll3FieldCombinationsWTimestamps)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP bestInPrevious = completedMatrix[(i - 1)][0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP bestEncoders = bestInPrevious[0].split('.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for encoder in bestEncoders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not (encoder in curSwarmEncoders)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP toKill.append(swarm) DCNL DCSP if (len(toKill) > 0): DCNL DCSP  DCSP print ('ParseMe: DCSP Killing DCSP encoders:' + str(toKill)) DCNL DCSP for swarm in toKill: DCNL DCSP  DCSP self.setSwarmState(swarm[0], 'killed') DCNL DCSP return
def isSprintActive(self, sprintIdx): DCNL DCSP while True: DCNL DCSP  DCSP numExistingSprints = len(self._state['sprints']) DCNL DCSP  DCSP if (sprintIdx <= (numExistingSprints - 1)): DCNL DCSP  DCSP  DCSP if (not self._hsObj._speculativeParticles): DCNL DCSP  DCSP  DCSP  DCSP active = (self._state['sprints'][sprintIdx]['status'] == 'active') DCNL DCSP  DCSP  DCSP  DCSP return (active, False) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP active = (self._state['sprints'][sprintIdx]['status'] == 'active') DCNL DCSP  DCSP  DCSP  DCSP if (not active): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (active, False) DCNL DCSP  DCSP  DCSP  DCSP activeSwarmIds = self.getActiveSwarms(sprintIdx) DCNL DCSP  DCSP  DCSP  DCSP swarmSizes = [self._hsObj._resultsDB.getParticleInfos(swarmId, matured=False)[0] for swarmId in activeSwarmIds] DCNL DCSP  DCSP  DCSP  DCSP notFullSwarms = [len(swarm) for swarm in swarmSizes if (len(swarm) < self._hsObj._minParticlesPerSwarm)] DCNL DCSP  DCSP  DCSP  DCSP if (len(notFullSwarms) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (True, False) DCNL DCSP  DCSP if (self._state['lastGoodSprint'] is not None): DCNL DCSP  DCSP  DCSP return (False, True) DCNL DCSP  DCSP if (self._hsObj._fixedFields is not None): DCNL DCSP  DCSP  DCSP return (False, True) DCNL DCSP  DCSP if ((sprintIdx > 0) and (self._state['sprints'][(sprintIdx - 1)]['status'] == 'completed')): DCNL DCSP  DCSP  DCSP (bestModelId, _) = self.bestModelInCompletedSprint((sprintIdx - 1)) DCNL DCSP  DCSP  DCSP (particleState, _, _, _, _) = self._hsObj._resultsDB.getParticleInfo(bestModelId) DCNL DCSP  DCSP  DCSP bestSwarmId = particleState['swarmId'] DCNL DCSP  DCSP  DCSP baseEncoderSets = [bestSwarmId.split('.')] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bestSwarmId = None DCNL DCSP  DCSP  DCSP particleState = None DCNL DCSP  DCSP  DCSP baseEncoderSets = [] DCNL DCSP  DCSP  DCSP for swarmId in self.getNonKilledSwarms((sprintIdx - 1)): DCNL DCSP  DCSP  DCSP  DCSP baseEncoderSets.append(swarmId.split('.')) DCNL DCSP  DCSP encoderAddSet = [] DCNL DCSP  DCSP limitFields = False DCNL DCSP  DCSP if ((self._hsObj._maxBranching > 0) or (self._hsObj._minFieldContribution >= 0)): DCNL DCSP  DCSP  DCSP if ((self._hsObj._searchType == HsSearchType.temporal) or (self._hsObj._searchType == HsSearchType.classification)): DCNL DCSP  DCSP  DCSP  DCSP if (sprintIdx >= 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP limitFields = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP baseSprintIdx = 0 DCNL DCSP  DCSP  DCSP elif (self._hsObj._searchType == HsSearchType.legacyTemporal): DCNL DCSP  DCSP  DCSP  DCSP if (sprintIdx >= 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP limitFields = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP baseSprintIdx = 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Unimplemented DCSP search DCSP type DCSP %s' % self._hsObj._searchType)) DCNL DCSP  DCSP if limitFields: DCNL DCSP  DCSP  DCSP (pctFieldContributions, absFieldContributions) = self.getFieldContributions() DCNL DCSP  DCSP  DCSP toRemove = [] DCNL DCSP  DCSP  DCSP self.logger.debug(('FieldContributions DCSP min: DCSP %s' % self._hsObj._minFieldContribution)) DCNL DCSP  DCSP  DCSP for fieldname in pctFieldContributions: DCNL DCSP  DCSP  DCSP  DCSP if (pctFieldContributions[fieldname] < self._hsObj._minFieldContribution): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.logger.debug(('FieldContributions DCSP removing: DCSP %s' % fieldname)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP toRemove.append(self.getEncoderKeyFromName(fieldname)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.logger.debug(('FieldContributions DCSP keeping: DCSP %s' % fieldname)) DCNL DCSP  DCSP  DCSP swarms = self._state['swarms'] DCNL DCSP  DCSP  DCSP sprintSwarms = [(swarm, swarms[swarm]['bestErrScore']) for swarm in swarms if (swarms[swarm]['sprintIdx'] == baseSprintIdx)] DCNL DCSP  DCSP  DCSP sprintSwarms = sorted(sprintSwarms, key=itemgetter(1)) DCNL DCSP  DCSP  DCSP if (self._hsObj._maxBranching > 0): DCNL DCSP  DCSP  DCSP  DCSP sprintSwarms = sprintSwarms[0:self._hsObj._maxBranching] DCNL DCSP  DCSP  DCSP for swarm in sprintSwarms: DCNL DCSP  DCSP  DCSP  DCSP swarmEncoders = swarm[0].split('.') DCNL DCSP  DCSP  DCSP  DCSP for encoder in swarmEncoders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (encoder in encoderAddSet)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP encoderAddSet.append(encoder) DCNL DCSP  DCSP  DCSP encoderAddSet = [encoder for encoder in encoderAddSet if (not (str(encoder) in toRemove))] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP encoderAddSet = self._hsObj._encoderNames DCNL DCSP  DCSP newSwarmIds = set() DCNL DCSP  DCSP if (((self._hsObj._searchType == HsSearchType.temporal) or (self._hsObj._searchType == HsSearchType.legacyTemporal)) and (sprintIdx == 2) and (self._hsObj._tryAll3FieldCombinations or self._hsObj._tryAll3FieldCombinationsWTimestamps)): DCNL DCSP  DCSP  DCSP if self._hsObj._tryAll3FieldCombinations: DCNL DCSP  DCSP  DCSP  DCSP newEncoders = set(self._hsObj._encoderNames) DCNL DCSP  DCSP  DCSP  DCSP if (self._hsObj._predictedFieldEncoder in newEncoders): DCNL DCSP  DCSP  DCSP  DCSP  DCSP newEncoders.remove(self._hsObj._predictedFieldEncoder) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP newEncoders = set(encoderAddSet) DCNL DCSP  DCSP  DCSP  DCSP if (self._hsObj._predictedFieldEncoder in newEncoders): DCNL DCSP  DCSP  DCSP  DCSP  DCSP newEncoders.remove(self._hsObj._predictedFieldEncoder) DCNL DCSP  DCSP  DCSP  DCSP for encoder in self._hsObj._encoderNames: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (encoder.endswith('_timeOfDay') or encoder.endswith('_weekend') or encoder.endswith('_dayOfWeek')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP newEncoders.add(encoder) DCNL DCSP  DCSP  DCSP allCombos = list(itertools.combinations(newEncoders, 2)) DCNL DCSP  DCSP  DCSP for combo in allCombos: DCNL DCSP  DCSP  DCSP  DCSP newSet = list(combo) DCNL DCSP  DCSP  DCSP  DCSP newSet.append(self._hsObj._predictedFieldEncoder) DCNL DCSP  DCSP  DCSP  DCSP newSet.sort() DCNL DCSP  DCSP  DCSP  DCSP newSwarmId = '.'.join(newSet) DCNL DCSP  DCSP  DCSP  DCSP if (newSwarmId not in self._state['swarms']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP newSwarmIds.add(newSwarmId) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(self.getActiveSwarms((sprintIdx - 1))) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for baseEncoderSet in baseEncoderSets: DCNL DCSP  DCSP  DCSP  DCSP for encoder in encoderAddSet: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((encoder not in self._state['blackListedEncoders']) and (encoder not in baseEncoderSet)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP newSet = list(baseEncoderSet) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP newSet.append(encoder) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP newSet.sort() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP newSwarmId = '.'.join(newSet) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (newSwarmId not in self._state['swarms']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP newSwarmIds.add(newSwarmId) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (len(self.getActiveSwarms((sprintIdx - 1))) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP newSwarmIds = sorted(newSwarmIds) DCNL DCSP  DCSP if (len(newSwarmIds) == 0): DCNL DCSP  DCSP  DCSP if (len(self.getAllSwarms(sprintIdx)) > 0): DCNL DCSP  DCSP  DCSP  DCSP return (True, False) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return (False, True) DCNL DCSP  DCSP self._dirty = True DCNL DCSP  DCSP if (len(self._state['sprints']) == sprintIdx): DCNL DCSP  DCSP  DCSP self._state['sprints'].append({'status': 'active', 'bestModelId': None, 'bestErrScore': None}) DCNL DCSP  DCSP for swarmId in newSwarmIds: DCNL DCSP  DCSP  DCSP self._state['swarms'][swarmId] = {'status': 'active', 'bestModelId': None, 'bestErrScore': None, 'sprintIdx': sprintIdx} DCNL DCSP  DCSP self._state['activeSwarms'] = self.getActiveSwarms() DCNL DCSP  DCSP success = self.writeStateToDB() DCNL DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP return (True, False)
def debug(self, msg, *args, **kwargs): DCNL DCSP self._baseLogger.debug(self, self.getExtendedMsg(msg), *args, **kwargs)
def info(self, msg, *args, **kwargs): DCNL DCSP self._baseLogger.info(self, self.getExtendedMsg(msg), *args, **kwargs)
def warning(self, msg, *args, **kwargs): DCNL DCSP self._baseLogger.warning(self, self.getExtendedMsg(msg), *args, **kwargs)
def error(self, msg, *args, **kwargs): DCNL DCSP self._baseLogger.error(self, self.getExtendedMsg(msg), *args, **kwargs)
def critical(self, msg, *args, **kwargs): DCNL DCSP self._baseLogger.critical(self, self.getExtendedMsg(msg), *args, **kwargs)
def log(self, level, msg, *args, **kwargs): DCNL DCSP self._baseLogger.log(self, level, self.getExtendedMsg(msg), *args, **kwargs)
def recordDataPoint(self, swarmId, generation, errScore): DCNL DCSP terminatedSwarms = [] DCNL DCSP if (swarmId in self.swarmScores): DCNL DCSP  DCSP entry = self.swarmScores[swarmId] DCNL DCSP  DCSP assert (len(entry) == generation) DCNL DCSP  DCSP entry.append(errScore) DCNL DCSP  DCSP entry = self.swarmBests[swarmId] DCNL DCSP  DCSP entry.append(min(errScore, entry[(-1)])) DCNL DCSP  DCSP assert (len(self.swarmBests[swarmId]) == len(self.swarmScores[swarmId])) DCNL DCSP else: DCNL DCSP  DCSP assert (generation == 0) DCNL DCSP  DCSP self.swarmScores[swarmId] = [errScore] DCNL DCSP  DCSP self.swarmBests[swarmId] = [errScore] DCNL DCSP if ((generation + 1) < self.MATURITY_WINDOW): DCNL DCSP  DCSP return terminatedSwarms DCNL DCSP if ((self.MAX_GENERATIONS is not None) and (generation > self.MAX_GENERATIONS)): DCNL DCSP  DCSP self._logger.info(('Swarm DCSP %s DCSP has DCSP matured DCSP (more DCSP than DCSP %d DCSP generations). DCSP Stopping' % (swarmId, self.MAX_GENERATIONS))) DCNL DCSP  DCSP terminatedSwarms.append(swarmId) DCNL DCSP if self._isTerminationEnabled: DCNL DCSP  DCSP terminatedSwarms.extend(self._getTerminatedSwarms(generation)) DCNL DCSP cumulativeBestScores = self.swarmBests[swarmId] DCNL DCSP if (cumulativeBestScores[(-1)] == cumulativeBestScores[(- self.MATURITY_WINDOW)]): DCNL DCSP  DCSP self._logger.info(('Swarm DCSP %s DCSP has DCSP matured DCSP (no DCSP change DCSP in DCSP %d DCSP generations).Stopping...' % (swarmId, self.MATURITY_WINDOW))) DCNL DCSP  DCSP terminatedSwarms.append(swarmId) DCNL DCSP self.terminatedSwarms = self.terminatedSwarms.union(terminatedSwarms) DCNL DCSP return terminatedSwarms
def getTerminationCallbacks(self, terminationFunc): DCNL DCSP activities = ([None] * len(ModelTerminator._MILESTONES)) DCNL DCSP for (index, (iteration, _)) in enumerate(ModelTerminator._MILESTONES): DCNL DCSP  DCSP cb = functools.partial(terminationFunc, index=index) DCNL DCSP  DCSP activities[index] = PeriodicActivityRequest(repeating=False, period=iteration, cb=cb)
@classmethod DCNL def getString(cls, prop): DCNL DCSP if (cls._properties is None): DCNL DCSP  DCSP cls._readStdConfigFiles() DCNL DCSP envValue = os.environ.get(('%s%s' % (cls.envPropPrefix, prop.replace('.', '_'))), None) DCNL DCSP if (envValue is not None): DCNL DCSP  DCSP return envValue DCNL DCSP return cls._properties[prop]
@classmethod DCNL def getBool(cls, prop): DCNL DCSP value = cls.getInt(prop) DCNL DCSP if (value not in (0, 1)): DCNL DCSP  DCSP raise ValueError(('Expected DCSP 0 DCSP or DCSP 1, DCSP but DCSP got DCSP %r DCSP in DCSP config DCSP property DCSP %s' % (value, prop))) DCNL DCSP return bool(value)
@classmethod DCNL def getInt(cls, prop): DCNL DCSP return int(cls.getString(prop))
@classmethod DCNL def getFloat(cls, prop): DCNL DCSP return float(cls.getString(prop))
@classmethod DCNL def get(cls, prop, default=None): DCNL DCSP try: DCNL DCSP  DCSP return cls.getString(prop) DCNL DCSP except KeyError: DCNL DCSP  DCSP return default
@classmethod DCNL def set(cls, prop, value): DCNL DCSP if (cls._properties is None): DCNL DCSP  DCSP cls._readStdConfigFiles() DCNL DCSP cls._properties[prop] = str(value)
@classmethod DCNL def dict(cls): DCNL DCSP if (cls._properties is None): DCNL DCSP  DCSP cls._readStdConfigFiles() DCNL DCSP result = dict(cls._properties) DCNL DCSP keys = os.environ.keys() DCNL DCSP replaceKeys = filter((lambda x: x.startswith(cls.envPropPrefix)), keys) DCNL DCSP for envKey in replaceKeys: DCNL DCSP  DCSP key = envKey[len(cls.envPropPrefix):] DCNL DCSP  DCSP key = key.replace('_', '.') DCNL DCSP  DCSP result[key] = os.environ[envKey] DCNL DCSP return result
@classmethod DCNL def readConfigFile(cls, filename, path=None): DCNL DCSP properties = cls._readConfigFile(filename, path) DCNL DCSP if (cls._properties is None): DCNL DCSP  DCSP cls._properties = dict() DCNL DCSP for name in properties: DCNL DCSP  DCSP if ('value' in properties[name]): DCNL DCSP  DCSP  DCSP cls._properties[name] = properties[name]['value']
@classmethod DCNL def _readConfigFile(cls, filename, path=None): DCNL DCSP outputProperties = dict() DCNL DCSP if (path is None): DCNL DCSP  DCSP filePath = cls.findConfigFile(filename) DCNL DCSP else: DCNL DCSP  DCSP filePath = os.path.join(path, filename) DCNL DCSP try: DCNL DCSP  DCSP if (filePath is not None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _getLoggerBase().debug('Loading DCSP config DCSP file: DCSP %s', filePath) DCNL DCSP  DCSP  DCSP  DCSP with open(filePath, 'r') as inp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP contents = inp.read() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Expected DCSP configuration DCSP file DCSP at DCSP %s' % filePath)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP contents = resource_string('nupic.support', filename) DCNL DCSP  DCSP  DCSP except Exception as resourceException: DCNL DCSP  DCSP  DCSP  DCSP if (filename in [USER_CONFIG, CUSTOM_CONFIG]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP contents = '<configuration/>' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise resourceException DCNL DCSP  DCSP elements = ElementTree.XML(contents) DCNL DCSP  DCSP if (elements.tag != 'configuration'): DCNL DCSP  DCSP  DCSP raise RuntimeError(("Expected DCSP top-level DCSP element DCSP to DCSP be DCSP 'configuration' DCSP but DCSP got DCSP '%s'" % elements.tag)) DCNL DCSP  DCSP propertyElements = elements.findall('./property') DCNL DCSP  DCSP for propertyItem in propertyElements: DCNL DCSP  DCSP  DCSP propInfo = dict() DCNL DCSP  DCSP  DCSP propertyAttributes = list(propertyItem) DCNL DCSP  DCSP  DCSP for propertyAttribute in propertyAttributes: DCNL DCSP  DCSP  DCSP  DCSP propInfo[propertyAttribute.tag] = propertyAttribute.text DCNL DCSP  DCSP  DCSP name = propInfo.get('name', None) DCNL DCSP  DCSP  DCSP if (('value' in propInfo) and (propInfo['value'] is None)): DCNL DCSP  DCSP  DCSP  DCSP value = '' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = propInfo.get('value', None) DCNL DCSP  DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('novalue' in propInfo): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError(("Missing DCSP 'value' DCSP element DCSP within DCSP the DCSP property DCSP element: DCSP => DCSP %s DCSP " % str(propInfo))) DCNL DCSP  DCSP  DCSP restOfValue = value DCNL DCSP  DCSP  DCSP value = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP pos = restOfValue.find('${env.') DCNL DCSP  DCSP  DCSP  DCSP if (pos == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value += restOfValue DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP value += restOfValue[0:pos] DCNL DCSP  DCSP  DCSP  DCSP varTailPos = restOfValue.find('}', pos) DCNL DCSP  DCSP  DCSP  DCSP if (varTailPos == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError(("Trailing DCSP environment DCSP variable DCSP tag DCSP delimiter DCSP '}' DCSP not DCSP found DCSP in DCSP %r" % restOfValue)) DCNL DCSP  DCSP  DCSP  DCSP varname = restOfValue[(pos + 6):varTailPos] DCNL DCSP  DCSP  DCSP  DCSP if (varname not in os.environ): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Attempting DCSP to DCSP use DCSP the DCSP value DCSP of DCSP the DCSP environment DCSP variable DCSP %r, DCSP which DCSP is DCSP not DCSP defined' % varname)) DCNL DCSP  DCSP  DCSP  DCSP envVarValue = os.environ[varname] DCNL DCSP  DCSP  DCSP  DCSP value += envVarValue DCNL DCSP  DCSP  DCSP  DCSP restOfValue = restOfValue[(varTailPos + 1):] DCNL DCSP  DCSP  DCSP if (name is None): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(("Missing DCSP 'name' DCSP element DCSP within DCSP following DCSP property DCSP element:\n DCSP => DCSP %s DCSP " % str(propInfo))) DCNL DCSP  DCSP  DCSP propInfo['value'] = value DCNL DCSP  DCSP  DCSP outputProperties[name] = propInfo DCNL DCSP  DCSP return outputProperties DCNL DCSP except Exception: DCNL DCSP  DCSP _getLoggerBase().exception('Error DCSP while DCSP parsing DCSP configuration DCSP file: DCSP %s.', filePath) DCNL DCSP  DCSP raise
@classmethod DCNL def clear(cls): DCNL DCSP cls._properties = None DCNL DCSP cls._configPaths = None
@classmethod DCNL def findConfigFile(cls, filename): DCNL DCSP paths = cls.getConfigPaths() DCNL DCSP for p in paths: DCNL DCSP  DCSP testPath = os.path.join(p, filename) DCNL DCSP  DCSP if os.path.isfile(testPath): DCNL DCSP  DCSP  DCSP return os.path.join(p, filename)
@classmethod DCNL def getConfigPaths(cls): DCNL DCSP configPaths = [] DCNL DCSP if (cls._configPaths is not None): DCNL DCSP  DCSP return cls._configPaths DCNL DCSP else: DCNL DCSP  DCSP if ('NTA_CONF_PATH' in os.environ): DCNL DCSP  DCSP  DCSP configVar = os.environ['NTA_CONF_PATH'] DCNL DCSP  DCSP  DCSP configPaths = configVar.split(os.pathsep) DCNL DCSP  DCSP return configPaths
@classmethod DCNL def setConfigPaths(cls, paths): DCNL DCSP cls._configPaths = list(paths)
@classmethod DCNL def _readStdConfigFiles(cls): DCNL DCSP cls.readConfigFile(DEFAULT_CONFIG) DCNL DCSP cls.readConfigFile(USER_CONFIG)
@classmethod DCNL def getCustomDict(cls): DCNL DCSP return _CustomConfigurationFileWrapper.getCustomDict()
@classmethod DCNL def setCustomProperty(cls, propertyName, value): DCNL DCSP cls.setCustomProperties({propertyName: value})
@classmethod DCNL def setCustomProperties(cls, properties): DCNL DCSP _getLogger().info('Setting DCSP custom DCSP configuration DCSP properties=%r; DCSP caller=%r', properties, traceback.format_stack()) DCNL DCSP _CustomConfigurationFileWrapper.edit(properties) DCNL DCSP for (propertyName, value) in properties.iteritems(): DCNL DCSP  DCSP cls.set(propertyName, value)
@classmethod DCNL def clear(cls): DCNL DCSP super(Configuration, cls).clear() DCNL DCSP _CustomConfigurationFileWrapper.clear(persistent=False)
@classmethod DCNL def resetCustomConfig(cls): DCNL DCSP _getLogger().info('Resetting DCSP all DCSP custom DCSP configuration DCSP properties; DCSP caller=%r', traceback.format_stack()) DCNL DCSP super(Configuration, cls).clear() DCNL DCSP _CustomConfigurationFileWrapper.clear(persistent=True)
@classmethod DCNL def loadCustomConfig(cls): DCNL DCSP cls.readConfigFile(_CustomConfigurationFileWrapper.customFileName)
@classmethod DCNL def _readStdConfigFiles(cls): DCNL DCSP super(Configuration, cls)._readStdConfigFiles() DCNL DCSP cls.loadCustomConfig()
@classmethod DCNL def clear(cls, persistent=False): DCNL DCSP if persistent: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.unlink(cls.getPath()) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP if (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP _getLogger().exception('Error DCSP %s DCSP while DCSP trying DCSP to DCSP remove DCSP dynamic DCSP configuration DCSP file: DCSP %s', e.errno, cls.getPath()) DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP cls._path = None
@classmethod DCNL def getCustomDict(cls): DCNL DCSP if (not os.path.exists(cls.getPath())): DCNL DCSP  DCSP return dict() DCNL DCSP properties = Configuration._readConfigFile(os.path.basename(cls.getPath()), os.path.dirname(cls.getPath())) DCNL DCSP values = dict() DCNL DCSP for propName in properties: DCNL DCSP  DCSP if ('value' in properties[propName]): DCNL DCSP  DCSP  DCSP values[propName] = properties[propName]['value'] DCNL DCSP return values
@classmethod DCNL def edit(cls, properties): DCNL DCSP copyOfProperties = copy(properties) DCNL DCSP configFilePath = cls.getPath() DCNL DCSP try: DCNL DCSP  DCSP with open(configFilePath, 'r') as fp: DCNL DCSP  DCSP  DCSP contents = fp.read() DCNL DCSP except IOError as e: DCNL DCSP  DCSP if (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP _getLogger().exception('Error DCSP %s DCSP reading DCSP custom DCSP configuration DCSP store DCSP from DCSP %s, DCSP while DCSP editing DCSP properties DCSP %s.', e.errno, configFilePath, properties) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP contents = '<configuration/>' DCNL DCSP try: DCNL DCSP  DCSP elements = ElementTree.XML(contents) DCNL DCSP  DCSP ElementTree.tostring(elements) DCNL DCSP except Exception as e: DCNL DCSP  DCSP msg = ("File DCSP contents DCSP of DCSP custom DCSP configuration DCSP is DCSP corrupt. DCSP  DCSP File DCSP location: DCSP %s; DCSP Contents: DCSP '%s'. DCSP Original DCSP Error DCSP (%s): DCSP %s." % (configFilePath, contents, type(e), e)) DCNL DCSP  DCSP _getLogger().exception(msg) DCNL DCSP  DCSP raise RuntimeError(msg), None, sys.exc_info()[2] DCNL DCSP if (elements.tag != 'configuration'): DCNL DCSP  DCSP e = ("Expected DCSP top-level DCSP element DCSP to DCSP be DCSP 'configuration' DCSP but DCSP got DCSP '%s'" % elements.tag) DCNL DCSP  DCSP _getLogger().error(e) DCNL DCSP  DCSP raise RuntimeError(e) DCNL DCSP for propertyItem in elements.findall('./property'): DCNL DCSP  DCSP propInfo = dict(((attr.tag, attr.text) for attr in propertyItem)) DCNL DCSP  DCSP name = propInfo['name'] DCNL DCSP  DCSP if (name in copyOfProperties): DCNL DCSP  DCSP  DCSP foundValues = propertyItem.findall('./value') DCNL DCSP  DCSP  DCSP if (len(foundValues) > 0): DCNL DCSP  DCSP  DCSP  DCSP foundValues[0].text = str(copyOfProperties.pop(name)) DCNL DCSP  DCSP  DCSP  DCSP if (not copyOfProperties): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP e = ('Property DCSP %s DCSP missing DCSP value DCSP tag.' % (name,)) DCNL DCSP  DCSP  DCSP  DCSP _getLogger().error(e) DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(e) DCNL DCSP for (propertyName, value) in copyOfProperties.iteritems(): DCNL DCSP  DCSP newProp = ElementTree.Element('property') DCNL DCSP  DCSP nameTag = ElementTree.Element('name') DCNL DCSP  DCSP nameTag.text = propertyName DCNL DCSP  DCSP newProp.append(nameTag) DCNL DCSP  DCSP valueTag = ElementTree.Element('value') DCNL DCSP  DCSP valueTag.text = str(value) DCNL DCSP  DCSP newProp.append(valueTag) DCNL DCSP  DCSP elements.append(newProp) DCNL DCSP try: DCNL DCSP  DCSP makeDirectoryFromAbsolutePath(os.path.dirname(configFilePath)) DCNL DCSP  DCSP with open(configFilePath, 'w') as fp: DCNL DCSP  DCSP  DCSP fp.write(ElementTree.tostring(elements)) DCNL DCSP except Exception as e: DCNL DCSP  DCSP _getLogger().exception('Error DCSP while DCSP saving DCSP custom DCSP configuration DCSP properties DCSP %s DCSP in DCSP %s.', properties, configFilePath) DCNL DCSP  DCSP raise
@classmethod DCNL def _setPath(cls): DCNL DCSP cls._path = os.path.join(os.environ['NTA_DYNAMIC_CONF_DIR'], cls.customFileName)
@classmethod DCNL def getPath(cls): DCNL DCSP if (cls._path is None): DCNL DCSP  DCSP cls._setPath() DCNL DCSP return cls._path
def getState(self): DCNL DCSP raise NotImplementedError
def setState(self, state): DCNL DCSP raise NotImplementedError
def getPosition(self): DCNL DCSP raise NotImplementedError
def agitate(self): DCNL DCSP raise NotImplementedError
def newPosition(self, globalBestPosition, rng): DCNL DCSP raise NotImplementedError
def pushAwayFrom(self, otherVars, rng): DCNL DCSP raise NotImplementedError
def resetVelocity(self, rng): DCNL DCSP raise NotImplementedError
def __init__(self, min, max, stepSize=None, inertia=None, cogRate=None, socRate=None): DCNL DCSP super(PermuteFloat, self).__init__() DCNL DCSP self.min = min DCNL DCSP self.max = max DCNL DCSP self.stepSize = stepSize DCNL DCSP self._position = ((self.max + self.min) / 2.0) DCNL DCSP self._velocity = ((self.max - self.min) / 5.0) DCNL DCSP self._inertia = (float(Configuration.get('nupic.hypersearch.inertia')) if (inertia is None) else inertia) DCNL DCSP self._cogRate = (float(Configuration.get('nupic.hypersearch.cogRate')) if (cogRate is None) else cogRate) DCNL DCSP self._socRate = (float(Configuration.get('nupic.hypersearch.socRate')) if (socRate is None) else socRate) DCNL DCSP self._bestPosition = self.getPosition() DCNL DCSP self._bestResult = None
def __repr__(self): DCNL DCSP return ('PermuteFloat(min=%f, DCSP max=%f, DCSP stepSize=%s) DCSP [position=%f(%f), DCSP velocity=%f, DCSP _bestPosition=%s, DCSP _bestResult=%s]' % (self.min, self.max, self.stepSize, self.getPosition(), self._position, self._velocity, self._bestPosition, self._bestResult))
def getState(self): DCNL DCSP return dict(_position=self._position, position=self.getPosition(), velocity=self._velocity, bestPosition=self._bestPosition, bestResult=self._bestResult)
def setState(self, state): DCNL DCSP self._position = state['_position'] DCNL DCSP self._velocity = state['velocity'] DCNL DCSP self._bestPosition = state['bestPosition'] DCNL DCSP self._bestResult = state['bestResult']
def getPosition(self): DCNL DCSP if (self.stepSize is None): DCNL DCSP  DCSP return self._position DCNL DCSP numSteps = ((self._position - self.min) / self.stepSize) DCNL DCSP numSteps = int(round(numSteps)) DCNL DCSP position = (self.min + (numSteps * self.stepSize)) DCNL DCSP position = max(self.min, position) DCNL DCSP position = min(self.max, position) DCNL DCSP return position
def agitate(self): DCNL DCSP self._velocity *= (1.5 / self._inertia) DCNL DCSP maxV = ((self.max - self.min) / 2) DCNL DCSP if (self._velocity > maxV): DCNL DCSP  DCSP self._velocity = maxV DCNL DCSP elif (self._velocity < (- maxV)): DCNL DCSP  DCSP self._velocity = (- maxV) DCNL DCSP if ((self._position == self.max) and (self._velocity > 0)): DCNL DCSP  DCSP self._velocity *= (-1) DCNL DCSP if ((self._position == self.min) and (self._velocity < 0)): DCNL DCSP  DCSP self._velocity *= (-1)
def newPosition(self, globalBestPosition, rng): DCNL DCSP lb = float(Configuration.get('nupic.hypersearch.randomLowerBound')) DCNL DCSP ub = float(Configuration.get('nupic.hypersearch.randomUpperBound')) DCNL DCSP self._velocity = ((self._velocity * self._inertia) + ((rng.uniform(lb, ub) * self._cogRate) * (self._bestPosition - self.getPosition()))) DCNL DCSP if (globalBestPosition is not None): DCNL DCSP  DCSP self._velocity += ((rng.uniform(lb, ub) * self._socRate) * (globalBestPosition - self.getPosition())) DCNL DCSP self._position += self._velocity DCNL DCSP self._position = max(self.min, self._position) DCNL DCSP self._position = min(self.max, self._position) DCNL DCSP return self.getPosition()
def pushAwayFrom(self, otherPositions, rng): DCNL DCSP if (self.max == self.min): DCNL DCSP  DCSP return DCNL DCSP numPositions = (len(otherPositions) * 4) DCNL DCSP if (numPositions == 0): DCNL DCSP  DCSP return DCNL DCSP stepSize = (float((self.max - self.min)) / numPositions) DCNL DCSP positions = numpy.arange(self.min, (self.max + stepSize), stepSize) DCNL DCSP numPositions = len(positions) DCNL DCSP weights = numpy.zeros(numPositions) DCNL DCSP maxDistanceSq = ((-1) * (stepSize ** 2)) DCNL DCSP for pos in otherPositions: DCNL DCSP  DCSP distances = (pos - positions) DCNL DCSP  DCSP varWeights = numpy.exp((numpy.power(distances, 2) / maxDistanceSq)) DCNL DCSP  DCSP weights += varWeights DCNL DCSP positionIdx = weights.argmin() DCNL DCSP self._position = positions[positionIdx] DCNL DCSP self._bestPosition = self.getPosition() DCNL DCSP self._velocity *= rng.choice([1, (-1)])
def resetVelocity(self, rng): DCNL DCSP maxVelocity = ((self.max - self.min) / 5.0) DCNL DCSP self._velocity = maxVelocity DCNL DCSP self._velocity *= rng.choice([1, (-1)])
def __repr__(self): DCNL DCSP return ('PermuteInt(min=%d, DCSP max=%d, DCSP stepSize=%d) DCSP [position=%d(%f), DCSP velocity=%f, DCSP _bestPosition=%s, DCSP _bestResult=%s]' % (self.min, self.max, self.stepSize, self.getPosition(), self._position, self._velocity, self._bestPosition, self._bestResult))
def getPosition(self): DCNL DCSP position = super(PermuteInt, self).getPosition() DCNL DCSP position = int(round(position)) DCNL DCSP return position
def __repr__(self): DCNL DCSP return ('PermuteChoices(choices=%s) DCSP [position=%s]' % (self.choices, self.choices[self._positionIdx]))
def getState(self): DCNL DCSP return dict(_position=self.getPosition(), position=self.getPosition(), velocity=None, bestPosition=self.choices[self._bestPositionIdx], bestResult=self._bestResult)
def setState(self, state): DCNL DCSP self._positionIdx = self.choices.index(state['_position']) DCNL DCSP self._bestPositionIdx = self.choices.index(state['bestPosition']) DCNL DCSP self._bestResult = state['bestResult']
def setResultsPerChoice(self, resultsPerChoice): DCNL DCSP self._resultsPerChoice = ([[]] * len(self.choices)) DCNL DCSP for (choiceValue, values) in resultsPerChoice: DCNL DCSP  DCSP choiceIndex = self.choices.index(choiceValue) DCNL DCSP  DCSP self._resultsPerChoice[choiceIndex] = list(values)
def getPosition(self): DCNL DCSP return self.choices[self._positionIdx]
def agitate(self): DCNL DCSP pass
def newPosition(self, globalBestPosition, rng): DCNL DCSP numChoices = len(self.choices) DCNL DCSP meanScorePerChoice = [] DCNL DCSP overallSum = 0 DCNL DCSP numResults = 0 DCNL DCSP for i in range(numChoices): DCNL DCSP  DCSP if (len(self._resultsPerChoice[i]) > 0): DCNL DCSP  DCSP  DCSP data = numpy.array(self._resultsPerChoice[i]) DCNL DCSP  DCSP  DCSP meanScorePerChoice.append(data.mean()) DCNL DCSP  DCSP  DCSP overallSum += data.sum() DCNL DCSP  DCSP  DCSP numResults += data.size DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP meanScorePerChoice.append(None) DCNL DCSP if (numResults == 0): DCNL DCSP  DCSP overallSum = 1.0 DCNL DCSP  DCSP numResults = 1 DCNL DCSP for i in range(numChoices): DCNL DCSP  DCSP if (meanScorePerChoice[i] is None): DCNL DCSP  DCSP  DCSP meanScorePerChoice[i] = (overallSum / numResults) DCNL DCSP meanScorePerChoice = numpy.array(meanScorePerChoice) DCNL DCSP meanScorePerChoice = ((1.1 * meanScorePerChoice.max()) - meanScorePerChoice) DCNL DCSP if self._fixEarly: DCNL DCSP  DCSP meanScorePerChoice **= ((numResults * self._fixEarlyFactor) / numChoices) DCNL DCSP total = meanScorePerChoice.sum() DCNL DCSP if (total == 0): DCNL DCSP  DCSP total = 1.0 DCNL DCSP meanScorePerChoice /= total DCNL DCSP distribution = meanScorePerChoice.cumsum() DCNL DCSP r = (rng.random() * distribution[(-1)]) DCNL DCSP choiceIdx = numpy.where((r <= distribution))[0][0] DCNL DCSP self._positionIdx = choiceIdx DCNL DCSP return self.getPosition()
def pushAwayFrom(self, otherPositions, rng): DCNL DCSP positions = [self.choices.index(x) for x in otherPositions] DCNL DCSP positionCounts = ([0] * len(self.choices)) DCNL DCSP for pos in positions: DCNL DCSP  DCSP positionCounts[pos] += 1 DCNL DCSP self._positionIdx = numpy.array(positionCounts).argmin() DCNL DCSP self._bestPositionIdx = self._positionIdx
def resetVelocity(self, rng): DCNL DCSP pass
def __repr__(self): DCNL DCSP suffix = '' DCNL DCSP for (key, value) in self.kwArgs.items(): DCNL DCSP  DCSP suffix += ('%s=%s, DCSP ' % (key, value)) DCNL DCSP return ('PermuteEncoder(fieldName=%s, DCSP encoderClass=%s, DCSP name=%s, DCSP %s)' % (self.fieldName, self.encoderClass, self.name, suffix))
def getDict(self, encoderName, flattenedChosenValues): DCNL DCSP encoder = dict(fieldname=self.fieldName, name=self.name) DCNL DCSP for (encoderArg, value) in self.kwArgs.iteritems(): DCNL DCSP  DCSP if isinstance(value, PermuteVariable): DCNL DCSP  DCSP  DCSP value = flattenedChosenValues[('%s:%s' % (encoderName, encoderArg))] DCNL DCSP  DCSP encoder[encoderArg] = value DCNL DCSP if ('.' in self.encoderClass): DCNL DCSP  DCSP (encoder['type'], argName) = self.encoderClass.split('.') DCNL DCSP  DCSP argValue = (encoder['w'], encoder['radius']) DCNL DCSP  DCSP encoder[argName] = argValue DCNL DCSP  DCSP encoder.pop('w') DCNL DCSP  DCSP encoder.pop('radius') DCNL DCSP else: DCNL DCSP  DCSP encoder['type'] = self.encoderClass DCNL DCSP return encoder
def _testValidPositions(self, varClass, minValue, maxValue, stepSize, iterations=100): DCNL DCSP positions = set() DCNL DCSP cogRate = 2.0 DCNL DCSP socRate = 2.0 DCNL DCSP inertia = None DCNL DCSP gBestPosition = maxValue DCNL DCSP lBestPosition = minValue DCNL DCSP foundBestPosition = None DCNL DCSP foundBestResult = None DCNL DCSP rng = random.Random() DCNL DCSP rng.seed(42) DCNL DCSP var = varClass(min=minValue, max=maxValue, stepSize=stepSize, inertia=inertia, cogRate=cogRate, socRate=socRate) DCNL DCSP for _ in xrange(iterations): DCNL DCSP  DCSP pos = var.getPosition() DCNL DCSP  DCSP if (self.verbosity >= 1): DCNL DCSP  DCSP  DCSP print ('pos: DCSP %f' % pos), DCNL DCSP  DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP  DCSP print var DCNL DCSP  DCSP positions.add(pos) DCNL DCSP  DCSP result = (1.0 - abs((pos - lBestPosition))) DCNL DCSP  DCSP if ((foundBestResult is None) or (result > foundBestResult)): DCNL DCSP  DCSP  DCSP foundBestResult = result DCNL DCSP  DCSP  DCSP foundBestPosition = pos DCNL DCSP  DCSP  DCSP state = var.getState() DCNL DCSP  DCSP  DCSP state['bestPosition'] = foundBestPosition DCNL DCSP  DCSP  DCSP state['bestResult'] = foundBestResult DCNL DCSP  DCSP  DCSP var.setState(state) DCNL DCSP  DCSP var.newPosition(gBestPosition, rng) DCNL DCSP positions = sorted(positions) DCNL DCSP print ('Positions DCSP visited DCSP (%d):' % len(positions)), positions DCNL DCSP assert (max(positions) <= maxValue) DCNL DCSP assert (min(positions) <= minValue) DCNL DCSP assert (len(positions) <= (int(round(((maxValue - minValue) / stepSize))) + 1))
def _testConvergence(self, varClass, minValue, maxValue, targetValue, iterations=100): DCNL DCSP gBestPosition = targetValue DCNL DCSP lBestPosition = targetValue DCNL DCSP foundBestPosition = None DCNL DCSP foundBestResult = None DCNL DCSP rng = random.Random() DCNL DCSP rng.seed(42) DCNL DCSP var = varClass(min=minValue, max=maxValue) DCNL DCSP for _ in xrange(iterations): DCNL DCSP  DCSP pos = var.getPosition() DCNL DCSP  DCSP if (self.verbosity >= 1): DCNL DCSP  DCSP  DCSP print ('pos: DCSP %f' % pos), DCNL DCSP  DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP  DCSP print var DCNL DCSP  DCSP result = (1.0 - abs((pos - lBestPosition))) DCNL DCSP  DCSP if ((foundBestResult is None) or (result > foundBestResult)): DCNL DCSP  DCSP  DCSP foundBestResult = result DCNL DCSP  DCSP  DCSP foundBestPosition = pos DCNL DCSP  DCSP  DCSP state = var.getState() DCNL DCSP  DCSP  DCSP state['bestPosition'] = foundBestPosition DCNL DCSP  DCSP  DCSP state['bestResult'] = foundBestResult DCNL DCSP  DCSP  DCSP var.setState(state) DCNL DCSP  DCSP var.newPosition(gBestPosition, rng) DCNL DCSP print ('Target: DCSP %f, DCSP Converged DCSP on: DCSP %f' % (targetValue, pos)) DCNL DCSP assert (abs((pos - targetValue)) < 0.001)
def run(self): DCNL DCSP self.verbosity = 0 DCNL DCSP self._testValidPositions(varClass=PermuteFloat, minValue=2.1, maxValue=5.1, stepSize=0.5) DCNL DCSP self._testValidPositions(varClass=PermuteInt, minValue=2, maxValue=11, stepSize=3) DCNL DCSP self._testValidPositions(varClass=PermuteInt, minValue=2, maxValue=11, stepSize=1) DCNL DCSP self._testConvergence(varClass=PermuteFloat, minValue=2.1, maxValue=5.1, targetValue=5.0) DCNL DCSP self._testConvergence(varClass=PermuteFloat, minValue=2.1, maxValue=5.1, targetValue=2.2) DCNL DCSP self._testConvergence(varClass=PermuteFloat, minValue=2.1, maxValue=5.1, targetValue=3.5) DCNL DCSP self._testConvergence(varClass=PermuteInt, minValue=1, maxValue=20, targetValue=19) DCNL DCSP self._testConvergence(varClass=PermuteInt, minValue=1, maxValue=20, targetValue=1) DCNL DCSP self._testChoices()
def __init__(self, hsObj, resultsDB, flattenedPermuteVars, swarmId=None, newFarFrom=None, evolveFromState=None, newFromClone=None, newParticleId=False): DCNL DCSP self._hsObj = hsObj DCNL DCSP self.logger = hsObj.logger DCNL DCSP self._resultsDB = resultsDB DCNL DCSP self._rng = random.Random() DCNL DCSP self._rng.seed(42) DCNL DCSP def _setupVars(flattenedPermuteVars): DCNL DCSP  DCSP allowedEncoderNames = self.swarmId.split('.') DCNL DCSP  DCSP self.permuteVars = copy.deepcopy(flattenedPermuteVars) DCNL DCSP  DCSP varNames = self.permuteVars.keys() DCNL DCSP  DCSP for varName in varNames: DCNL DCSP  DCSP  DCSP if (':' in varName): DCNL DCSP  DCSP  DCSP  DCSP if (varName.split(':')[0] not in allowedEncoderNames): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.permuteVars.pop(varName) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if isinstance(self.permuteVars[varName], PermuteChoices): DCNL DCSP  DCSP  DCSP  DCSP if self._hsObj._speculativeParticles: DCNL DCSP  DCSP  DCSP  DCSP  DCSP maxGenIdx = None DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP maxGenIdx = (self.genIdx - 1) DCNL DCSP  DCSP  DCSP  DCSP resultsPerChoice = self._resultsDB.getResultsPerChoice(swarmId=self.swarmId, maxGenIdx=maxGenIdx, varName=varName) DCNL DCSP  DCSP  DCSP  DCSP self.permuteVars[varName].setResultsPerChoice(resultsPerChoice.values()) DCNL DCSP if (swarmId is not None): DCNL DCSP  DCSP assert (evolveFromState is None) DCNL DCSP  DCSP assert (newFromClone is None) DCNL DCSP  DCSP self.swarmId = swarmId DCNL DCSP  DCSP self.particleId = ('%s.%s' % (str(self._hsObj._workerID), str(Particle._nextParticleID))) DCNL DCSP  DCSP Particle._nextParticleID += 1 DCNL DCSP  DCSP self.genIdx = 0 DCNL DCSP  DCSP _setupVars(flattenedPermuteVars) DCNL DCSP  DCSP if (newFarFrom is not None): DCNL DCSP  DCSP  DCSP for varName in self.permuteVars.iterkeys(): DCNL DCSP  DCSP  DCSP  DCSP otherPositions = [] DCNL DCSP  DCSP  DCSP  DCSP for particleState in newFarFrom: DCNL DCSP  DCSP  DCSP  DCSP  DCSP otherPositions.append(particleState['varStates'][varName]['position']) DCNL DCSP  DCSP  DCSP  DCSP self.permuteVars[varName].pushAwayFrom(otherPositions, self._rng) DCNL DCSP  DCSP  DCSP  DCSP self._rng.seed(str(otherPositions)) DCNL DCSP elif (evolveFromState is not None): DCNL DCSP  DCSP assert (swarmId is None) DCNL DCSP  DCSP assert (newFarFrom is None) DCNL DCSP  DCSP assert (newFromClone is None) DCNL DCSP  DCSP self.particleId = evolveFromState['id'] DCNL DCSP  DCSP self.genIdx = (evolveFromState['genIdx'] + 1) DCNL DCSP  DCSP self.swarmId = evolveFromState['swarmId'] DCNL DCSP  DCSP _setupVars(flattenedPermuteVars) DCNL DCSP  DCSP self.initStateFrom(self.particleId, evolveFromState, newBest=True) DCNL DCSP  DCSP self.newPosition() DCNL DCSP elif (newFromClone is not None): DCNL DCSP  DCSP assert (swarmId is None) DCNL DCSP  DCSP assert (newFarFrom is None) DCNL DCSP  DCSP assert (evolveFromState is None) DCNL DCSP  DCSP self.particleId = newFromClone['id'] DCNL DCSP  DCSP if newParticleId: DCNL DCSP  DCSP  DCSP self.particleId = ('%s.%s' % (str(self._hsObj._workerID), str(Particle._nextParticleID))) DCNL DCSP  DCSP  DCSP Particle._nextParticleID += 1 DCNL DCSP  DCSP self.genIdx = newFromClone['genIdx'] DCNL DCSP  DCSP self.swarmId = newFromClone['swarmId'] DCNL DCSP  DCSP _setupVars(flattenedPermuteVars) DCNL DCSP  DCSP self.initStateFrom(self.particleId, newFromClone, newBest=False) DCNL DCSP else: DCNL DCSP  DCSP assert False, 'invalid DCSP creation DCSP parameters' DCNL DCSP self.logger.debug(('Created DCSP particle: DCSP %s' % str(self)))
def getState(self): DCNL DCSP varStates = dict() DCNL DCSP for (varName, var) in self.permuteVars.iteritems(): DCNL DCSP  DCSP varStates[varName] = var.getState() DCNL DCSP return dict(id=self.particleId, genIdx=self.genIdx, swarmId=self.swarmId, varStates=varStates)
def initStateFrom(self, particleId, particleState, newBest): DCNL DCSP if newBest: DCNL DCSP  DCSP (bestResult, bestPosition) = self._resultsDB.getParticleBest(particleId) DCNL DCSP else: DCNL DCSP  DCSP bestResult = bestPosition = None DCNL DCSP varStates = particleState['varStates'] DCNL DCSP for varName in varStates.keys(): DCNL DCSP  DCSP varState = copy.deepcopy(varStates[varName]) DCNL DCSP  DCSP if newBest: DCNL DCSP  DCSP  DCSP varState['bestResult'] = bestResult DCNL DCSP  DCSP if (bestPosition is not None): DCNL DCSP  DCSP  DCSP varState['bestPosition'] = bestPosition[varName] DCNL DCSP  DCSP self.permuteVars[varName].setState(varState)
def copyEncoderStatesFrom(self, particleState): DCNL DCSP allowedToMove = True DCNL DCSP for varName in particleState['varStates']: DCNL DCSP  DCSP if (':' in varName): DCNL DCSP  DCSP  DCSP if (varName not in self.permuteVars): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP state = copy.deepcopy(particleState['varStates'][varName]) DCNL DCSP  DCSP  DCSP state['_position'] = state['position'] DCNL DCSP  DCSP  DCSP state['bestPosition'] = state['position'] DCNL DCSP  DCSP  DCSP if (not allowedToMove): DCNL DCSP  DCSP  DCSP  DCSP state['velocity'] = 0 DCNL DCSP  DCSP  DCSP self.permuteVars[varName].setState(state) DCNL DCSP  DCSP  DCSP if allowedToMove: DCNL DCSP  DCSP  DCSP  DCSP self.permuteVars[varName].resetVelocity(self._rng)
def copyVarStatesFrom(self, particleState, varNames): DCNL DCSP allowedToMove = True DCNL DCSP for varName in particleState['varStates']: DCNL DCSP  DCSP if (varName in varNames): DCNL DCSP  DCSP  DCSP if (varName not in self.permuteVars): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP state = copy.deepcopy(particleState['varStates'][varName]) DCNL DCSP  DCSP  DCSP state['_position'] = state['position'] DCNL DCSP  DCSP  DCSP state['bestPosition'] = state['position'] DCNL DCSP  DCSP  DCSP if (not allowedToMove): DCNL DCSP  DCSP  DCSP  DCSP state['velocity'] = 0 DCNL DCSP  DCSP  DCSP self.permuteVars[varName].setState(state) DCNL DCSP  DCSP  DCSP if allowedToMove: DCNL DCSP  DCSP  DCSP  DCSP self.permuteVars[varName].resetVelocity(self._rng)
def getPosition(self): DCNL DCSP result = dict() DCNL DCSP for (varName, value) in self.permuteVars.iteritems(): DCNL DCSP  DCSP result[varName] = value.getPosition() DCNL DCSP return result
@staticmethod DCNL def getPositionFromState(pState): DCNL DCSP result = dict() DCNL DCSP for (varName, value) in pState['varStates'].iteritems(): DCNL DCSP  DCSP result[varName] = value['position'] DCNL DCSP return result
def agitate(self): DCNL DCSP for (varName, var) in self.permuteVars.iteritems(): DCNL DCSP  DCSP var.agitate() DCNL DCSP self.newPosition()
def newPosition(self, whichVars=None): DCNL DCSP globalBestPosition = None DCNL DCSP if self._hsObj._speculativeParticles: DCNL DCSP  DCSP genIdx = self.genIdx DCNL DCSP else: DCNL DCSP  DCSP genIdx = (self.genIdx - 1) DCNL DCSP if (genIdx >= 0): DCNL DCSP  DCSP (bestModelId, _) = self._resultsDB.bestModelIdAndErrScore(self.swarmId, genIdx) DCNL DCSP  DCSP if (bestModelId is not None): DCNL DCSP  DCSP  DCSP (particleState, _, _, _, _) = self._resultsDB.getParticleInfo(bestModelId) DCNL DCSP  DCSP  DCSP globalBestPosition = Particle.getPositionFromState(particleState) DCNL DCSP for (varName, var) in self.permuteVars.iteritems(): DCNL DCSP  DCSP if ((whichVars is not None) and (varName not in whichVars)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (globalBestPosition is None): DCNL DCSP  DCSP  DCSP var.newPosition(None, self._rng) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP var.newPosition(globalBestPosition[varName], self._rng) DCNL DCSP position = self.getPosition() DCNL DCSP if (self.logger.getEffectiveLevel() <= logging.DEBUG): DCNL DCSP  DCSP msg = StringIO.StringIO() DCNL DCSP  DCSP print >>msg, ('New DCSP particle DCSP position: DCSP \n%s' % pprint.pformat(position, indent=4)) DCNL DCSP  DCSP print >>msg, 'Particle DCSP variables:' DCNL DCSP  DCSP for (varName, var) in self.permuteVars.iteritems(): DCNL DCSP  DCSP  DCSP print >>msg, (' DCSP  DCSP %s: DCSP %s' % (varName, str(var))) DCNL DCSP  DCSP self.logger.debug(msg.getvalue()) DCNL DCSP  DCSP msg.close() DCNL DCSP return position
def __init__(self, jobID, jobsDAO, logLevel=None): DCNL DCSP self._jobID = jobID DCNL DCSP self._cjDB = jobsDAO DCNL DCSP self._lastUpdateAttemptTime = 0 DCNL DCSP initLogging(verbose=True) DCNL DCSP self.logger = logging.getLogger('.'.join(['com.numenta', self.__class__.__module__, self.__class__.__name__])) DCNL DCSP if (logLevel is not None): DCNL DCSP  DCSP self.logger.setLevel(logLevel) DCNL DCSP self.logger.info(('Created DCSP new DCSP ModelChooser DCSP for DCSP job DCSP %s' % str(jobID)))
def updateResultsForJob(self, forceUpdate=True): DCNL DCSP updateInterval = (time.time() - self._lastUpdateAttemptTime) DCNL DCSP if ((updateInterval < self._MIN_UPDATE_INTERVAL) and (not forceUpdate)): DCNL DCSP  DCSP return DCNL DCSP self.logger.info(('Attempting DCSP model DCSP selection DCSP for DCSP jobID=%d: DCSP time=%f DCSP  DCSP lastUpdate=%f' % (self._jobID, time.time(), self._lastUpdateAttemptTime))) DCNL DCSP timestampUpdated = self._cjDB.jobUpdateSelectionSweep(self._jobID, self._MIN_UPDATE_INTERVAL) DCNL DCSP if (not timestampUpdated): DCNL DCSP  DCSP self.logger.info(('Unable DCSP to DCSP update DCSP selection DCSP sweep DCSP timestamp: DCSP jobID=%d DCSP updateTime=%f' % (self._jobID, self._lastUpdateAttemptTime))) DCNL DCSP  DCSP if (not forceUpdate): DCNL DCSP  DCSP  DCSP return DCNL DCSP self._lastUpdateAttemptTime = time.time() DCNL DCSP self.logger.info(('Succesfully DCSP updated DCSP selection DCSP sweep DCSP timestamp DCSP jobid=%d DCSP updateTime=%f' % (self._jobID, self._lastUpdateAttemptTime))) DCNL DCSP minUpdateRecords = self._MIN_UPDATE_THRESHOLD DCNL DCSP jobResults = self._getJobResults() DCNL DCSP if (forceUpdate or (jobResults is None)): DCNL DCSP  DCSP minUpdateRecords = 0 DCNL DCSP (candidateIDs, bestMetric) = self._cjDB.modelsGetCandidates(self._jobID, minUpdateRecords) DCNL DCSP self.logger.info(('Candidate DCSP models=%s, DCSP metric=%s, DCSP jobID=%s' % (candidateIDs, bestMetric, self._jobID))) DCNL DCSP if (len(candidateIDs) == 0): DCNL DCSP  DCSP return DCNL DCSP self._jobUpdateCandidate(candidateIDs[0], bestMetric, results=jobResults)
def __init__(self, options): DCNL DCSP self.__cjDAO = _clientJobsDB() DCNL DCSP self._options = options DCNL DCSP self.__searchJob = None DCNL DCSP self.__foundMetrcsKeySet = set() DCNL DCSP self._workers = None DCNL DCSP return
def runNewSearch(self): DCNL DCSP self.__searchJob = self.__startSearch() DCNL DCSP self.monitorSearchJob()
def pickupSearch(self): DCNL DCSP self.__searchJob = self.loadSavedHyperSearchJob(permWorkDir=self._options['permWorkDir'], outputLabel=self._options['outputLabel']) DCNL DCSP self.monitorSearchJob()
def monitorSearchJob(self): DCNL DCSP assert (self.__searchJob is not None) DCNL DCSP jobID = self.__searchJob.getJobID() DCNL DCSP startTime = time.time() DCNL DCSP lastUpdateTime = datetime.now() DCNL DCSP expectedNumModels = self.__searchJob.getExpectedNumModels(searchMethod=self._options['searchMethod']) DCNL DCSP lastNumFinished = 0 DCNL DCSP finishedModelIDs = set() DCNL DCSP finishedModelStats = _ModelStats() DCNL DCSP lastWorkerState = None DCNL DCSP lastJobResults = None DCNL DCSP lastModelMilestones = None DCNL DCSP lastEngStatus = None DCNL DCSP hyperSearchFinished = False DCNL DCSP while (not hyperSearchFinished): DCNL DCSP  DCSP jobInfo = self.__searchJob.getJobStatus(self._workers) DCNL DCSP  DCSP hyperSearchFinished = jobInfo.isFinished() DCNL DCSP  DCSP modelIDs = self.__searchJob.queryModelIDs() DCNL DCSP  DCSP _emit(Verbosity.DEBUG, ('Current DCSP number DCSP of DCSP models DCSP is DCSP %d DCSP (%d DCSP of DCSP them DCSP completed)' % (len(modelIDs), len(finishedModelIDs)))) DCNL DCSP  DCSP if (len(modelIDs) > 0): DCNL DCSP  DCSP  DCSP checkModelIDs = [] DCNL DCSP  DCSP  DCSP for modelID in modelIDs: DCNL DCSP  DCSP  DCSP  DCSP if (modelID not in finishedModelIDs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP checkModelIDs.append(modelID) DCNL DCSP  DCSP  DCSP del modelIDs DCNL DCSP  DCSP  DCSP if checkModelIDs: DCNL DCSP  DCSP  DCSP  DCSP _emit(Verbosity.DEBUG, ('Checking DCSP %d DCSP models...' % len(checkModelIDs))) DCNL DCSP  DCSP  DCSP  DCSP errorCompletionMsg = None DCNL DCSP  DCSP  DCSP  DCSP for (i, modelInfo) in enumerate(_iterModels(checkModelIDs)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _emit(Verbosity.DEBUG, ('[%s] DCSP Checking DCSP completion: DCSP %s' % (i, modelInfo))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if modelInfo.isFinished(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finishedModelIDs.add(modelInfo.getModelID()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finishedModelStats.update(modelInfo) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (modelInfo.getCompletionReason().isError() and (not errorCompletionMsg)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errorCompletionMsg = modelInfo.getCompletionMsg() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metrics = modelInfo.getReportMetrics() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.__foundMetrcsKeySet.update(metrics.keys()) DCNL DCSP  DCSP  DCSP numFinished = len(finishedModelIDs) DCNL DCSP  DCSP  DCSP if (numFinished != lastNumFinished): DCNL DCSP  DCSP  DCSP  DCSP lastNumFinished = numFinished DCNL DCSP  DCSP  DCSP  DCSP if (expectedNumModels is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP expModelsStr = '' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP expModelsStr = ('of DCSP %s' % expectedNumModels) DCNL DCSP  DCSP  DCSP  DCSP stats = finishedModelStats DCNL DCSP  DCSP  DCSP  DCSP print ('<jobID: DCSP %s> DCSP %s DCSP %s DCSP models DCSP finished DCSP [success: DCSP %s; DCSP %s: DCSP %s; DCSP %s: DCSP %s; DCSP %s: DCSP %s; DCSP %s: DCSP %s; DCSP %s: DCSP %s; DCSP %s: DCSP %s]' % (jobID, numFinished, expModelsStr, (stats.numCompletedEOF + stats.numCompletedStopped), ('EOF' if stats.numCompletedEOF else 'eof'), stats.numCompletedEOF, ('STOPPED' if stats.numCompletedStopped else 'stopped'), stats.numCompletedStopped, ('KILLED' if stats.numCompletedKilled else 'killed'), stats.numCompletedKilled, ('ERROR' if stats.numCompletedError else 'error'), stats.numCompletedError, ('ORPHANED' if stats.numCompletedError else 'orphaned'), stats.numCompletedOrphaned, ('UNKNOWN' if stats.numCompletedOther else 'unknown'), stats.numCompletedOther)) DCNL DCSP  DCSP  DCSP  DCSP if errorCompletionMsg: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('ERROR DCSP MESSAGE: DCSP %s' % errorCompletionMsg) DCNL DCSP  DCSP  DCSP workerState = jobInfo.getWorkerState() DCNL DCSP  DCSP  DCSP if (workerState != lastWorkerState): DCNL DCSP  DCSP  DCSP  DCSP print ('##>> DCSP UPDATED DCSP WORKER DCSP STATE: DCSP \n%s' % pprint.pformat(workerState, indent=4)) DCNL DCSP  DCSP  DCSP  DCSP lastWorkerState = workerState DCNL DCSP  DCSP  DCSP jobResults = jobInfo.getResults() DCNL DCSP  DCSP  DCSP if (jobResults != lastJobResults): DCNL DCSP  DCSP  DCSP  DCSP print ('####>> DCSP UPDATED DCSP JOB DCSP RESULTS: DCSP \n%s DCSP (elapsed DCSP time: DCSP %g DCSP secs)' % (pprint.pformat(jobResults, indent=4), (time.time() - startTime))) DCNL DCSP  DCSP  DCSP  DCSP lastJobResults = jobResults DCNL DCSP  DCSP  DCSP modelMilestones = jobInfo.getModelMilestones() DCNL DCSP  DCSP  DCSP if (modelMilestones != lastModelMilestones): DCNL DCSP  DCSP  DCSP  DCSP print ('##>> DCSP UPDATED DCSP MODEL DCSP MILESTONES: DCSP \n%s' % pprint.pformat(modelMilestones, indent=4)) DCNL DCSP  DCSP  DCSP  DCSP lastModelMilestones = modelMilestones DCNL DCSP  DCSP  DCSP engStatus = jobInfo.getEngStatus() DCNL DCSP  DCSP  DCSP if (engStatus != lastEngStatus): DCNL DCSP  DCSP  DCSP  DCSP print ('##>> DCSP UPDATED DCSP STATUS: DCSP \n%s' % engStatus) DCNL DCSP  DCSP  DCSP  DCSP lastEngStatus = engStatus DCNL DCSP  DCSP if (not hyperSearchFinished): DCNL DCSP  DCSP  DCSP if (self._options['timeout'] != None): DCNL DCSP  DCSP  DCSP  DCSP if ((datetime.now() - lastUpdateTime) > timedelta(minutes=self._options['timeout'])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Timeout DCSP reached, DCSP exiting' DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.__cjDAO.jobCancel(jobID) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP modelIDs = self.__searchJob.queryModelIDs() DCNL DCSP print ('Evaluated DCSP %s DCSP models' % len(modelIDs)) DCNL DCSP print 'HyperSearch DCSP finished!' DCNL DCSP jobInfo = self.__searchJob.getJobStatus(self._workers) DCNL DCSP print ('Worker DCSP completion DCSP message: DCSP %s' % jobInfo.getWorkerCompletionMsg())
def _launchWorkers(self, cmdLine, numWorkers): DCNL DCSP self._workers = [] DCNL DCSP for i in range(numWorkers): DCNL DCSP  DCSP stdout = tempfile.TemporaryFile() DCNL DCSP  DCSP stderr = tempfile.TemporaryFile() DCNL DCSP  DCSP p = subprocess.Popen(cmdLine, bufsize=1, env=os.environ, shell=True, stdin=None, stdout=stdout, stderr=stderr) DCNL DCSP  DCSP self._workers.append(p)
def __startSearch(self): DCNL DCSP params = _ClientJobUtils.makeSearchJobParamsDict(options=self._options, forRunning=True) DCNL DCSP if (self._options['action'] == 'dryRun'): DCNL DCSP  DCSP args = [sys.argv[0], ('--params=%s' % json.dumps(params))] DCNL DCSP  DCSP print DCNL DCSP  DCSP print '==================================================================' DCNL DCSP  DCSP print 'RUNNING DCSP PERMUTATIONS DCSP INLINE DCSP as DCSP "DRY DCSP RUN"...' DCNL DCSP  DCSP print '==================================================================' DCNL DCSP  DCSP jobID = hypersearch_worker.main(args) DCNL DCSP else: DCNL DCSP  DCSP cmdLine = _setUpExports(self._options['exports']) DCNL DCSP  DCSP cmdLine += '$HYPERSEARCH' DCNL DCSP  DCSP maxWorkers = self._options['maxWorkers'] DCNL DCSP  DCSP jobID = self.__cjDAO.jobInsert(client='GRP', cmdLine=cmdLine, params=json.dumps(params), minimumWorkers=1, maximumWorkers=maxWorkers, jobType=self.__cjDAO.JOB_TYPE_HS) DCNL DCSP  DCSP cmdLine = ('python DCSP -m DCSP nupic.swarming.hypersearch_worker DCSP --jobID=%d' % jobID) DCNL DCSP  DCSP self._launchWorkers(cmdLine, maxWorkers) DCNL DCSP searchJob = _HyperSearchJob(jobID) DCNL DCSP self.__saveHyperSearchJobID(permWorkDir=self._options['permWorkDir'], outputLabel=self._options['outputLabel'], hyperSearchJob=searchJob) DCNL DCSP if (self._options['action'] == 'dryRun'): DCNL DCSP  DCSP print ('Successfully DCSP executed DCSP "dry-run" DCSP hypersearch, DCSP jobID=%d' % jobID) DCNL DCSP else: DCNL DCSP  DCSP print ('Successfully DCSP submitted DCSP new DCSP HyperSearch DCSP job, DCSP jobID=%d' % jobID) DCNL DCSP  DCSP _emit(Verbosity.DEBUG, ('Each DCSP worker DCSP executing DCSP the DCSP command DCSP line: DCSP %s' % (cmdLine,))) DCNL DCSP return searchJob
def peekSearchJob(self): DCNL DCSP assert (self.__searchJob is not None) DCNL DCSP return self.__searchJob
def getDiscoveredMetricsKeys(self): DCNL DCSP return tuple(self.__foundMetrcsKeySet)
@classmethod DCNL def printModels(cls, options): DCNL DCSP print 'Generating DCSP experiment DCSP requests...' DCNL DCSP searchParams = _ClientJobUtils.makeSearchJobParamsDict(options=options)
@classmethod DCNL def generateReport(cls, options, replaceReport, hyperSearchJob, metricsKeys): DCNL DCSP if (hyperSearchJob is None): DCNL DCSP  DCSP hyperSearchJob = cls.loadSavedHyperSearchJob(permWorkDir=options['permWorkDir'], outputLabel=options['outputLabel']) DCNL DCSP modelIDs = hyperSearchJob.queryModelIDs() DCNL DCSP bestModel = None DCNL DCSP metricstmp = set() DCNL DCSP searchVar = set() DCNL DCSP for modelInfo in _iterModels(modelIDs): DCNL DCSP  DCSP if modelInfo.isFinished(): DCNL DCSP  DCSP  DCSP vars = modelInfo.getParamLabels().keys() DCNL DCSP  DCSP  DCSP searchVar.update(vars) DCNL DCSP  DCSP  DCSP metrics = modelInfo.getReportMetrics() DCNL DCSP  DCSP  DCSP metricstmp.update(metrics.keys()) DCNL DCSP if (metricsKeys is None): DCNL DCSP  DCSP metricsKeys = metricstmp DCNL DCSP reportWriter = _ReportCSVWriter(hyperSearchJob=hyperSearchJob, metricsKeys=metricsKeys, searchVar=searchVar, outputDirAbsPath=options['permWorkDir'], outputLabel=options['outputLabel'], replaceReport=replaceReport) DCNL DCSP modelStats = _ModelStats() DCNL DCSP print '\nResults DCSP from DCSP all DCSP experiments:' DCNL DCSP print '----------------------------------------------------------------' DCNL DCSP searchParams = hyperSearchJob.getParams() DCNL DCSP (optimizationMetricKey, maximizeMetric) = _PermutationUtils.getOptimizationMetricInfo(searchParams) DCNL DCSP formatStr = None DCNL DCSP foundMetricsKeySet = set(metricsKeys) DCNL DCSP sortedMetricsKeys = [] DCNL DCSP jobInfo = _clientJobsDB().jobInfo(hyperSearchJob.getJobID()) DCNL DCSP if (jobInfo.cancel == 1): DCNL DCSP  DCSP raise Exception(jobInfo.workerCompletionMsg) DCNL DCSP try: DCNL DCSP  DCSP results = json.loads(jobInfo.results) DCNL DCSP except Exception as e: DCNL DCSP  DCSP print 'json.loads(jobInfo.results) DCSP raised DCSP an DCSP exception. DCSP  DCSP Here DCSP is DCSP some DCSP info DCSP to DCSP help DCSP with DCSP debugging:' DCNL DCSP  DCSP print 'jobInfo: DCSP ', jobInfo DCNL DCSP  DCSP print 'jobInfo.results: DCSP ', jobInfo.results DCNL DCSP  DCSP print 'EXCEPTION: DCSP ', e DCNL DCSP  DCSP raise DCNL DCSP bestModelNum = results['bestModel'] DCNL DCSP bestModelIterIndex = None DCNL DCSP totalWallTime = 0 DCNL DCSP totalRecords = 0 DCNL DCSP scoreModelIDDescList = [] DCNL DCSP for (i, modelInfo) in enumerate(_iterModels(modelIDs)): DCNL DCSP  DCSP reportWriter.emit(modelInfo) DCNL DCSP  DCSP totalRecords += modelInfo.getNumRecords() DCNL DCSP  DCSP format = '%Y-%m-%d DCSP %H:%M:%S' DCNL DCSP  DCSP startTime = modelInfo.getStartTime() DCNL DCSP  DCSP if modelInfo.isFinished(): DCNL DCSP  DCSP  DCSP endTime = modelInfo.getEndTime() DCNL DCSP  DCSP  DCSP st = datetime.strptime(startTime, format) DCNL DCSP  DCSP  DCSP et = datetime.strptime(endTime, format) DCNL DCSP  DCSP  DCSP totalWallTime += (et - st).seconds DCNL DCSP  DCSP modelStats.update(modelInfo) DCNL DCSP  DCSP expDesc = modelInfo.getModelDescription() DCNL DCSP  DCSP reportMetrics = modelInfo.getReportMetrics() DCNL DCSP  DCSP optimizationMetrics = modelInfo.getOptimizationMetrics() DCNL DCSP  DCSP if (modelInfo.getModelID() == bestModelNum): DCNL DCSP  DCSP  DCSP bestModel = modelInfo DCNL DCSP  DCSP  DCSP bestModelIterIndex = i DCNL DCSP  DCSP  DCSP bestMetric = optimizationMetrics.values()[0] DCNL DCSP  DCSP if optimizationMetrics: DCNL DCSP  DCSP  DCSP assert (len(optimizationMetrics) == 1), ('expected DCSP 1 DCSP opt DCSP key, DCSP but DCSP got DCSP %d DCSP (%s) DCSP in DCSP %s' % (len(optimizationMetrics), optimizationMetrics, modelInfo)) DCNL DCSP  DCSP if modelInfo.getCompletionReason().isEOF(): DCNL DCSP  DCSP  DCSP scoreModelIDDescList.append((optimizationMetrics.values()[0], modelInfo.getModelID(), modelInfo.getGeneratedDescriptionFile(), modelInfo.getParamLabels())) DCNL DCSP  DCSP print ('[%d] DCSP Experiment DCSP %s\n(%s):' % (i, modelInfo, expDesc)) DCNL DCSP  DCSP if (modelInfo.isFinished() and (not (modelInfo.getCompletionReason().isStopped or modelInfo.getCompletionReason().isEOF()))): DCNL DCSP  DCSP  DCSP print ('>> DCSP COMPLETION DCSP MESSAGE: DCSP %s' % modelInfo.getCompletionMsg()) DCNL DCSP  DCSP if reportMetrics: DCNL DCSP  DCSP  DCSP foundMetricsKeySet.update(reportMetrics.iterkeys()) DCNL DCSP  DCSP  DCSP if (len(sortedMetricsKeys) != len(foundMetricsKeySet)): DCNL DCSP  DCSP  DCSP  DCSP sortedMetricsKeys = sorted(foundMetricsKeySet) DCNL DCSP  DCSP  DCSP  DCSP maxKeyLen = max([len(k) for k in sortedMetricsKeys]) DCNL DCSP  DCSP  DCSP  DCSP formatStr = (' DCSP  DCSP %%-%ds' % (maxKeyLen + 2)) DCNL DCSP  DCSP  DCSP for key in sortedMetricsKeys: DCNL DCSP  DCSP  DCSP  DCSP if (key in reportMetrics): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (key == optimizationMetricKey): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP m = ('%r DCSP (*)' % reportMetrics[key]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP m = ('%r' % reportMetrics[key]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print (formatStr % (key + ':')), m DCNL DCSP  DCSP  DCSP print DCNL DCSP print '--------------------------------------------------------------' DCNL DCSP if (len(modelIDs) > 0): DCNL DCSP  DCSP print ('%d DCSP experiments DCSP total DCSP (%s).\n' % (len(modelIDs), ('all DCSP completed DCSP successfully' if ((modelStats.numCompletedKilled + modelStats.numCompletedEOF) == len(modelIDs)) else ('WARNING: DCSP %d DCSP models DCSP have DCSP not DCSP completed DCSP or DCSP there DCSP were DCSP errors' % (len(modelIDs) - ((modelStats.numCompletedKilled + modelStats.numCompletedEOF) + modelStats.numCompletedStopped)))))) DCNL DCSP  DCSP if (modelStats.numStatusOther > 0): DCNL DCSP  DCSP  DCSP print ('ERROR: DCSP models DCSP with DCSP unexpected DCSP status: DCSP %d' % modelStats.numStatusOther) DCNL DCSP  DCSP print ('WaitingToStart: DCSP %d' % modelStats.numStatusWaitingToStart) DCNL DCSP  DCSP print ('Running: DCSP %d' % modelStats.numStatusRunning) DCNL DCSP  DCSP print ('Completed: DCSP %d' % modelStats.numStatusCompleted) DCNL DCSP  DCSP if (modelStats.numCompletedOther > 0): DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP ERROR: DCSP models DCSP with DCSP unexpected DCSP completion DCSP reason: DCSP %d' % modelStats.numCompletedOther) DCNL DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP ran DCSP to DCSP EOF: DCSP %d' % modelStats.numCompletedEOF) DCNL DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP ran DCSP to DCSP stop DCSP signal: DCSP %d' % modelStats.numCompletedStopped) DCNL DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP were DCSP orphaned: DCSP %d' % modelStats.numCompletedOrphaned) DCNL DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP killed DCSP off: DCSP %d' % modelStats.numCompletedKilled) DCNL DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP failed: DCSP %d' % modelStats.numCompletedError) DCNL DCSP  DCSP assert (modelStats.numStatusOther == 0), ('numStatusOther=%s' % modelStats.numStatusOther) DCNL DCSP  DCSP assert (modelStats.numCompletedOther == 0), ('numCompletedOther=%s' % modelStats.numCompletedOther) DCNL DCSP else: DCNL DCSP  DCSP print '0 DCSP experiments DCSP total.' DCNL DCSP print DCNL DCSP global gCurrentSearch DCNL DCSP jobStatus = hyperSearchJob.getJobStatus(gCurrentSearch._workers) DCNL DCSP jobResults = jobStatus.getResults() DCNL DCSP if ('fieldContributions' in jobResults): DCNL DCSP  DCSP print 'Field DCSP Contributions:' DCNL DCSP  DCSP pprint.pprint(jobResults['fieldContributions'], indent=4) DCNL DCSP else: DCNL DCSP  DCSP print 'Field DCSP contributions DCSP info DCSP not DCSP available' DCNL DCSP if (bestModel is not None): DCNL DCSP  DCSP maxKeyLen = max([len(k) for k in sortedMetricsKeys]) DCNL DCSP  DCSP maxKeyLen = max(maxKeyLen, len(optimizationMetricKey)) DCNL DCSP  DCSP formatStr = (' DCSP  DCSP %%-%ds' % (maxKeyLen + 2)) DCNL DCSP  DCSP bestMetricValue = bestModel.getOptimizationMetrics().values()[0] DCNL DCSP  DCSP optimizationMetricName = bestModel.getOptimizationMetrics().keys()[0] DCNL DCSP  DCSP print DCNL DCSP  DCSP print ('Best DCSP results DCSP on DCSP the DCSP optimization DCSP metric DCSP %s DCSP (maximize=%s):' % (optimizationMetricName, maximizeMetric)) DCNL DCSP  DCSP print ('[%d] DCSP Experiment DCSP %s DCSP (%s):' % (bestModelIterIndex, bestModel, bestModel.getModelDescription())) DCNL DCSP  DCSP print (formatStr % (optimizationMetricName + ':')), bestMetricValue DCNL DCSP  DCSP print DCNL DCSP  DCSP print ('Total DCSP number DCSP of DCSP Records DCSP processed: DCSP %d' % totalRecords) DCNL DCSP  DCSP print DCNL DCSP  DCSP print ('Total DCSP wall DCSP time DCSP for DCSP all DCSP models: DCSP %d' % totalWallTime) DCNL DCSP  DCSP hsJobParams = hyperSearchJob.getParams() DCNL DCSP if (options['genTopNDescriptions'] > 0): DCNL DCSP  DCSP print ('\nGenerating DCSP description DCSP files DCSP for DCSP top DCSP %d DCSP models...' % options['genTopNDescriptions']) DCNL DCSP  DCSP scoreModelIDDescList.sort() DCNL DCSP  DCSP scoreModelIDDescList = scoreModelIDDescList[0:options['genTopNDescriptions']] DCNL DCSP  DCSP i = (-1) DCNL DCSP  DCSP for (score, modelID, description, paramLabels) in scoreModelIDDescList: DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP outDir = os.path.join(options['permWorkDir'], ('model_%d' % i)) DCNL DCSP  DCSP  DCSP print ('Generating DCSP description DCSP file DCSP for DCSP model DCSP %s DCSP at DCSP %s' % (modelID, outDir)) DCNL DCSP  DCSP  DCSP if (not os.path.exists(outDir)): DCNL DCSP  DCSP  DCSP  DCSP os.makedirs(outDir) DCNL DCSP  DCSP  DCSP base_description_path = os.path.join(options['outDir'], 'description.py') DCNL DCSP  DCSP  DCSP base_description_relpath = os.path.relpath(base_description_path, start=outDir) DCNL DCSP  DCSP  DCSP description = description.replace("importBaseDescription('base.py', DCSP config)", ("importBaseDescription('%s', DCSP config)" % base_description_relpath)) DCNL DCSP  DCSP  DCSP fd = open(os.path.join(outDir, 'description.py'), 'wb') DCNL DCSP  DCSP  DCSP fd.write(description) DCNL DCSP  DCSP  DCSP fd.close() DCNL DCSP  DCSP  DCSP fd = open(os.path.join(outDir, 'params.csv'), 'wb') DCNL DCSP  DCSP  DCSP writer = csv.writer(fd) DCNL DCSP  DCSP  DCSP colNames = paramLabels.keys() DCNL DCSP  DCSP  DCSP colNames.sort() DCNL DCSP  DCSP  DCSP writer.writerow(colNames) DCNL DCSP  DCSP  DCSP row = [paramLabels[x] for x in colNames] DCNL DCSP  DCSP  DCSP writer.writerow(row) DCNL DCSP  DCSP  DCSP fd.close() DCNL DCSP  DCSP  DCSP print 'Generating DCSP model DCSP params DCSP file...' DCNL DCSP  DCSP  DCSP mod = imp.load_source('description', os.path.join(outDir, 'description.py')) DCNL DCSP  DCSP  DCSP model_description = mod.descriptionInterface.getModelDescription() DCNL DCSP  DCSP  DCSP fd = open(os.path.join(outDir, 'model_params.py'), 'wb') DCNL DCSP  DCSP  DCSP fd.write(('%s\nMODEL_PARAMS DCSP = DCSP %s' % (getCopyrightHead(), pprint.pformat(model_description)))) DCNL DCSP  DCSP  DCSP fd.close() DCNL DCSP  DCSP print DCNL DCSP reportWriter.finalize() DCNL DCSP return model_description
@classmethod DCNL def loadSavedHyperSearchJob(cls, permWorkDir, outputLabel): DCNL DCSP jobID = cls.__loadHyperSearchJobID(permWorkDir=permWorkDir, outputLabel=outputLabel) DCNL DCSP searchJob = _HyperSearchJob(nupicJobID=jobID) DCNL DCSP return searchJob
@classmethod DCNL def __saveHyperSearchJobID(cls, permWorkDir, outputLabel, hyperSearchJob): DCNL DCSP jobID = hyperSearchJob.getJobID() DCNL DCSP filePath = cls.__getHyperSearchJobIDFilePath(permWorkDir=permWorkDir, outputLabel=outputLabel) DCNL DCSP if os.path.exists(filePath): DCNL DCSP  DCSP _backupFile(filePath) DCNL DCSP d = dict(hyperSearchJobID=jobID) DCNL DCSP with open(filePath, 'wb') as jobIdPickleFile: DCNL DCSP  DCSP pickle.dump(d, jobIdPickleFile)
@classmethod DCNL def __loadHyperSearchJobID(cls, permWorkDir, outputLabel): DCNL DCSP filePath = cls.__getHyperSearchJobIDFilePath(permWorkDir=permWorkDir, outputLabel=outputLabel) DCNL DCSP jobID = None DCNL DCSP with open(filePath, 'r') as jobIdPickleFile: DCNL DCSP  DCSP jobInfo = pickle.load(jobIdPickleFile) DCNL DCSP  DCSP jobID = jobInfo['hyperSearchJobID'] DCNL DCSP return jobID
@classmethod DCNL def __getHyperSearchJobIDFilePath(cls, permWorkDir, outputLabel): DCNL DCSP basePath = permWorkDir DCNL DCSP filename = ('%s_HyperSearchJobID.pkl' % (outputLabel,)) DCNL DCSP filepath = os.path.join(basePath, filename) DCNL DCSP return filepath
def __init__(self, hyperSearchJob, metricsKeys, searchVar, outputDirAbsPath, outputLabel, replaceReport): DCNL DCSP self.__searchJob = hyperSearchJob DCNL DCSP self.__searchJobID = hyperSearchJob.getJobID() DCNL DCSP self.__sortedMetricsKeys = sorted(metricsKeys) DCNL DCSP self.__outputDirAbsPath = os.path.abspath(outputDirAbsPath) DCNL DCSP self.__outputLabel = outputLabel DCNL DCSP self.__replaceReport = replaceReport DCNL DCSP self.__sortedVariableNames = searchVar DCNL DCSP self.__csvFileObj = None DCNL DCSP self.__reportCSVPath = None DCNL DCSP self.__backupCSVPath = None
def emit(self, modelInfo): DCNL DCSP if (self.__csvFileObj is None): DCNL DCSP  DCSP self.__openAndInitCSVFile(modelInfo) DCNL DCSP csv = self.__csvFileObj DCNL DCSP print >>csv, ('%s, DCSP ' % self.__searchJobID), DCNL DCSP print >>csv, ('%s, DCSP ' % modelInfo.getModelID()), DCNL DCSP print >>csv, ('%s, DCSP ' % modelInfo.statusAsString()), DCNL DCSP if modelInfo.isFinished(): DCNL DCSP  DCSP print >>csv, ('%s, DCSP ' % modelInfo.getCompletionReason()), DCNL DCSP else: DCNL DCSP  DCSP print >>csv, 'NA, DCSP ', DCNL DCSP if (not modelInfo.isWaitingToStart()): DCNL DCSP  DCSP print >>csv, ('%s, DCSP ' % modelInfo.getStartTime()), DCNL DCSP else: DCNL DCSP  DCSP print >>csv, 'NA, DCSP ', DCNL DCSP if modelInfo.isFinished(): DCNL DCSP  DCSP dateFormat = '%Y-%m-%d DCSP %H:%M:%S' DCNL DCSP  DCSP startTime = modelInfo.getStartTime() DCNL DCSP  DCSP endTime = modelInfo.getEndTime() DCNL DCSP  DCSP print >>csv, ('%s, DCSP ' % endTime), DCNL DCSP  DCSP st = datetime.strptime(startTime, dateFormat) DCNL DCSP  DCSP et = datetime.strptime(endTime, dateFormat) DCNL DCSP  DCSP print >>csv, ('%s, DCSP ' % str((et - st).seconds)), DCNL DCSP else: DCNL DCSP  DCSP print >>csv, 'NA, DCSP ', DCNL DCSP  DCSP print >>csv, 'NA, DCSP ', DCNL DCSP print >>csv, ('%s, DCSP ' % str(modelInfo.getModelDescription())), DCNL DCSP print >>csv, ('%s, DCSP ' % str(modelInfo.getNumRecords())), DCNL DCSP paramLabelsDict = modelInfo.getParamLabels() DCNL DCSP for key in self.__sortedVariableNames: DCNL DCSP  DCSP if (key in paramLabelsDict): DCNL DCSP  DCSP  DCSP print >>csv, ('%s, DCSP ' % paramLabelsDict[key]), DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print >>csv, 'None, DCSP ', DCNL DCSP metrics = modelInfo.getReportMetrics() DCNL DCSP for key in self.__sortedMetricsKeys: DCNL DCSP  DCSP value = metrics.get(key, 'NA') DCNL DCSP  DCSP value = str(value) DCNL DCSP  DCSP value = value.replace('\n', ' DCSP ') DCNL DCSP  DCSP print >>csv, ('%s, DCSP ' % value), DCNL DCSP print >>csv
def finalize(self): DCNL DCSP if (self.__csvFileObj is not None): DCNL DCSP  DCSP self.__csvFileObj.close() DCNL DCSP  DCSP self.__csvFileObj = None DCNL DCSP  DCSP print ('Report DCSP csv DCSP saved DCSP in DCSP %s' % (self.__reportCSVPath,)) DCNL DCSP  DCSP if self.__backupCSVPath: DCNL DCSP  DCSP  DCSP print ('Previous DCSP report DCSP csv DCSP file DCSP was DCSP backed DCSP up DCSP to DCSP %s' % (self.__backupCSVPath,)) DCNL DCSP else: DCNL DCSP  DCSP print 'Nothing DCSP was DCSP written DCSP to DCSP report DCSP csv DCSP file.'
def __openAndInitCSVFile(self, modelInfo): DCNL DCSP basePath = self.__outputDirAbsPath DCNL DCSP reportCSVName = ('%s_Report.csv' % (self.__outputLabel,)) DCNL DCSP reportCSVPath = self.__reportCSVPath = os.path.join(basePath, reportCSVName) DCNL DCSP backupCSVPath = None DCNL DCSP if os.path.exists(reportCSVPath): DCNL DCSP  DCSP backupCSVPath = self.__backupCSVPath = _backupFile(reportCSVPath) DCNL DCSP if self.__replaceReport: DCNL DCSP  DCSP mode = 'w' DCNL DCSP else: DCNL DCSP  DCSP mode = 'a' DCNL DCSP csv = self.__csvFileObj = open(reportCSVPath, mode) DCNL DCSP if ((not self.__replaceReport) and backupCSVPath): DCNL DCSP  DCSP print >>csv DCNL DCSP  DCSP print >>csv DCNL DCSP print >>csv, 'jobID, DCSP ', DCNL DCSP print >>csv, 'modelID, DCSP ', DCNL DCSP print >>csv, 'status, DCSP ', DCNL DCSP print >>csv, 'completionReason, DCSP ', DCNL DCSP print >>csv, 'startTime, DCSP ', DCNL DCSP print >>csv, 'endTime, DCSP ', DCNL DCSP print >>csv, 'runtime(s), DCSP ', DCNL DCSP print >>csv, 'expDesc, DCSP ', DCNL DCSP print >>csv, 'numRecords, DCSP ', DCNL DCSP for key in self.__sortedVariableNames: DCNL DCSP  DCSP print >>csv, ('%s, DCSP ' % key), DCNL DCSP for key in self.__sortedMetricsKeys: DCNL DCSP  DCSP print >>csv, ('%s, DCSP ' % key), DCNL DCSP print >>csv
def __init__(self, nupicJobID): DCNL DCSP self.__nupicJobID = nupicJobID DCNL DCSP jobInfo = _clientJobsDB().jobInfo(nupicJobID) DCNL DCSP assert (jobInfo is not None), ('jobID=%s DCSP not DCSP found' % nupicJobID) DCNL DCSP assert (jobInfo.jobId == nupicJobID), ('%s DCSP != DCSP %s' % (jobInfo.jobId, nupicJobID)) DCNL DCSP _emit(Verbosity.DEBUG, ('_NupicJob: DCSP \n%s' % pprint.pformat(jobInfo, indent=4))) DCNL DCSP if (jobInfo.params is not None): DCNL DCSP  DCSP self.__params = json.loads(jobInfo.params) DCNL DCSP else: DCNL DCSP  DCSP self.__params = None
def __repr__(self): DCNL DCSP return ('%s(jobID=%s)' % (self.__class__.__name__, self.__nupicJobID))
def getJobStatus(self, workers): DCNL DCSP jobInfo = self.JobStatus(self.__nupicJobID, workers) DCNL DCSP return jobInfo
def getJobID(self): DCNL DCSP return self.__nupicJobID
def getParams(self): DCNL DCSP return self.__params
def __init__(self, nupicJobID, workers): DCNL DCSP jobInfo = _clientJobsDB().jobInfo(nupicJobID) DCNL DCSP assert (jobInfo.jobId == nupicJobID), ('%s DCSP != DCSP %s' % (jobInfo.jobId, nupicJobID)) DCNL DCSP if (workers is not None): DCNL DCSP  DCSP runningCount = 0 DCNL DCSP  DCSP for worker in workers: DCNL DCSP  DCSP  DCSP retCode = worker.poll() DCNL DCSP  DCSP  DCSP if (retCode is None): DCNL DCSP  DCSP  DCSP  DCSP runningCount += 1 DCNL DCSP  DCSP if (runningCount > 0): DCNL DCSP  DCSP  DCSP status = cjdao.ClientJobsDAO.STATUS_RUNNING DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP status = cjdao.ClientJobsDAO.STATUS_COMPLETED DCNL DCSP  DCSP jobInfo = jobInfo._replace(status=status) DCNL DCSP _emit(Verbosity.DEBUG, ('JobStatus: DCSP \n%s' % pprint.pformat(jobInfo, indent=4))) DCNL DCSP self.__jobInfo = jobInfo
def statusAsString(self): DCNL DCSP return self.__jobInfo.status
def isWaitingToStart(self): DCNL DCSP waiting = (self.__jobInfo.status == self.__nupicJobStatus_NotStarted) DCNL DCSP return waiting
def isStarting(self): DCNL DCSP starting = (self.__jobInfo.status == self.__nupicJobStatus_Starting) DCNL DCSP return starting
def isRunning(self): DCNL DCSP running = (self.__jobInfo.status == self.__nupicJobStatus_running) DCNL DCSP return running
def isFinished(self): DCNL DCSP done = (self.__jobInfo.status == self.__nupicJobStatus_completed) DCNL DCSP return done
def getCompletionReason(self): DCNL DCSP assert self.isFinished(), ('Too DCSP early DCSP to DCSP tell: DCSP %s' % self) DCNL DCSP return _JobCompletionReason(self.__jobInfo.completionReason)
def getCompletionMsg(self): DCNL DCSP assert self.isFinished(), ('Too DCSP early DCSP to DCSP tell: DCSP %s' % self) DCNL DCSP return ('%s' % self.__jobInfo.completionMsg)
def getWorkerCompletionMsg(self): DCNL DCSP assert self.isFinished(), ('Too DCSP early DCSP to DCSP tell: DCSP %s' % self) DCNL DCSP return ('%s' % self.__jobInfo.workerCompletionMsg)
def getStartTime(self): DCNL DCSP assert (not self.isWaitingToStart()), ('Too DCSP early DCSP to DCSP tell: DCSP %s' % self) DCNL DCSP return ('%s' % self.__jobInfo.startTime)
def getEndTime(self): DCNL DCSP assert self.isFinished(), ('Too DCSP early DCSP to DCSP tell: DCSP %s' % self) DCNL DCSP return ('%s' % self.__jobInfo.endTime)
def getWorkerState(self): DCNL DCSP if (self.__jobInfo.engWorkerState is not None): DCNL DCSP  DCSP return json.loads(self.__jobInfo.engWorkerState) DCNL DCSP else: DCNL DCSP  DCSP return None
def getResults(self): DCNL DCSP if (self.__jobInfo.results is not None): DCNL DCSP  DCSP return json.loads(self.__jobInfo.results) DCNL DCSP else: DCNL DCSP  DCSP return None
def getModelMilestones(self): DCNL DCSP if (self.__jobInfo.engModelMilestones is not None): DCNL DCSP  DCSP return json.loads(self.__jobInfo.engModelMilestones) DCNL DCSP else: DCNL DCSP  DCSP return None
def getEngStatus(self): DCNL DCSP return self.__jobInfo.engStatus
def __init__(self, reason): DCNL DCSP self.__reason = reason
def __init__(self, nupicJobID): DCNL DCSP super(_HyperSearchJob, self).__init__(nupicJobID) DCNL DCSP self.__expectedNumModels = None
def queryModelIDs(self): DCNL DCSP jobID = self.getJobID() DCNL DCSP modelCounterPairs = _clientJobsDB().modelsGetUpdateCounters(jobID) DCNL DCSP modelIDs = tuple((x[0] for x in modelCounterPairs)) DCNL DCSP return modelIDs
def getExpectedNumModels(self, searchMethod): DCNL DCSP return self.__expectedNumModels
@classmethod DCNL def makeSearchJobParamsDict(cls, options, forRunning=False): DCNL DCSP if (options['searchMethod'] == 'v2'): DCNL DCSP  DCSP hsVersion = 'v2' DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unsupported DCSP search DCSP method: DCSP %r' % options['searchMethod'])) DCNL DCSP maxModels = options['maxPermutations'] DCNL DCSP if ((options['action'] == 'dryRun') and (maxModels is None)): DCNL DCSP  DCSP maxModels = 1 DCNL DCSP useTerminators = options['useTerminators'] DCNL DCSP if (useTerminators is None): DCNL DCSP  DCSP params = {'hsVersion': hsVersion, 'maxModels': maxModels} DCNL DCSP else: DCNL DCSP  DCSP params = {'hsVersion': hsVersion, 'useTerminators': useTerminators, 'maxModels': maxModels} DCNL DCSP if forRunning: DCNL DCSP  DCSP params['persistentJobGUID'] = str(uuid.uuid1()) DCNL DCSP if options['permutationsScriptPath']: DCNL DCSP  DCSP params['permutationsPyFilename'] = options['permutationsScriptPath'] DCNL DCSP elif options['expDescConfig']: DCNL DCSP  DCSP params['description'] = options['expDescConfig'] DCNL DCSP else: DCNL DCSP  DCSP with open(options['expDescJsonPath'], mode='r') as fp: DCNL DCSP  DCSP  DCSP params['description'] = json.load(fp) DCNL DCSP return params
@classmethod DCNL def getOptimizationMetricInfo(cls, searchJobParams): DCNL DCSP if (searchJobParams['hsVersion'] == 'v2'): DCNL DCSP  DCSP search = HypersearchV2(searchParams=searchJobParams) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(('Unsupported DCSP hypersearch DCSP version DCSP "%s"' % searchJobParams['hsVersion'])) DCNL DCSP info = search.getOptimizationMetricInfo() DCNL DCSP return info
def __init__(self, rawInfo): DCNL DCSP self.__rawInfo = rawInfo DCNL DCSP self.__cachedResults = None DCNL DCSP assert (self.__rawInfo.params is not None) DCNL DCSP self.__cachedParams = None
def __repr__(self): DCNL DCSP return ('%s(jobID=%s, DCSP modelID=%s, DCSP status=%s, DCSP completionReason=%s, DCSP updateCounter=%s, DCSP numRecords=%s)' % ('_NupicModelInfo', self.__rawInfo.jobId, self.__rawInfo.modelId, self.__rawInfo.status, self.__rawInfo.completionReason, self.__rawInfo.updateCounter, self.__rawInfo.numRecords))
def getModelID(self): DCNL DCSP return self.__rawInfo.modelId
def statusAsString(self): DCNL DCSP return ('%s' % self.__rawInfo.status)
def getModelDescription(self): DCNL DCSP params = self.__unwrapParams() DCNL DCSP if ('experimentName' in params): DCNL DCSP  DCSP return params['experimentName'] DCNL DCSP else: DCNL DCSP  DCSP paramSettings = self.getParamLabels() DCNL DCSP  DCSP items = [] DCNL DCSP  DCSP for (key, value) in paramSettings.items(): DCNL DCSP  DCSP  DCSP items.append(('%s_%s' % (key, value))) DCNL DCSP  DCSP return '.'.join(items)
def getGeneratedDescriptionFile(self): DCNL DCSP return self.__rawInfo.genDescription
def getNumRecords(self): DCNL DCSP return self.__rawInfo.numRecords
def getParamLabels(self): DCNL DCSP params = self.__unwrapParams() DCNL DCSP if ('particleState' in params): DCNL DCSP  DCSP retval = dict() DCNL DCSP  DCSP queue = [(pair, retval) for pair in params['particleState']['varStates'].iteritems()] DCNL DCSP  DCSP while (len(queue) > 0): DCNL DCSP  DCSP  DCSP (pair, output) = queue.pop() DCNL DCSP  DCSP  DCSP (k, v) = pair DCNL DCSP  DCSP  DCSP if (('position' in v) and ('bestPosition' in v) and ('velocity' in v)): DCNL DCSP  DCSP  DCSP  DCSP output[k] = v['position'] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (k not in output): DCNL DCSP  DCSP  DCSP  DCSP  DCSP output[k] = dict() DCNL DCSP  DCSP  DCSP  DCSP queue.extend(((pair, output[k]) for pair in v.iteritems())) DCNL DCSP  DCSP return retval
def __unwrapParams(self): DCNL DCSP if (self.__cachedParams is None): DCNL DCSP  DCSP self.__cachedParams = json.loads(self.__rawInfo.params) DCNL DCSP  DCSP assert (self.__cachedParams is not None), ('%s DCSP resulted DCSP in DCSP None' % self.__rawInfo.params) DCNL DCSP return self.__cachedParams
def getReportMetrics(self): DCNL DCSP return self.__unwrapResults().reportMetrics
def getOptimizationMetrics(self): DCNL DCSP return self.__unwrapResults().optimizationMetrics
def getAllMetrics(self): DCNL DCSP result = self.getReportMetrics() DCNL DCSP result.update(self.getOptimizationMetrics()) DCNL DCSP return result
def __unwrapResults(self): DCNL DCSP if (self.__cachedResults is None): DCNL DCSP  DCSP if (self.__rawInfo.results is not None): DCNL DCSP  DCSP  DCSP resultList = json.loads(self.__rawInfo.results) DCNL DCSP  DCSP  DCSP assert (len(resultList) == 2), ('Expected DCSP 2 DCSP elements, DCSP but DCSP got DCSP %s DCSP (%s).' % (len(resultList), resultList)) DCNL DCSP  DCSP  DCSP self.__cachedResults = self.ModelResults(reportMetrics=resultList[0], optimizationMetrics=resultList[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.__cachedResults = self.ModelResults(reportMetrics={}, optimizationMetrics={}) DCNL DCSP return self.__cachedResults
def isWaitingToStart(self): DCNL DCSP waiting = (self.__rawInfo.status == self.__nupicModelStatus_notStarted) DCNL DCSP return waiting
def isRunning(self): DCNL DCSP running = (self.__rawInfo.status == self.__nupicModelStatus_running) DCNL DCSP return running
def isFinished(self): DCNL DCSP finished = (self.__rawInfo.status == self.__nupicModelStatus_completed) DCNL DCSP return finished
def getCompletionReason(self): DCNL DCSP assert self.isFinished(), ('Too DCSP early DCSP to DCSP tell: DCSP %s' % self) DCNL DCSP return _ModelCompletionReason(self.__rawInfo.completionReason)
def getCompletionMsg(self): DCNL DCSP assert self.isFinished(), ('Too DCSP early DCSP to DCSP tell: DCSP %s' % self) DCNL DCSP return self.__rawInfo.completionMsg
def getStartTime(self): DCNL DCSP assert (not self.isWaitingToStart()), ('Too DCSP early DCSP to DCSP tell: DCSP %s' % self) DCNL DCSP return ('%s' % self.__rawInfo.startTime)
def getEndTime(self): DCNL DCSP assert self.isFinished(), ('Too DCSP early DCSP to DCSP tell: DCSP %s' % self) DCNL DCSP return ('%s' % self.__rawInfo.endTime)
def __init__(self, hsObj): DCNL DCSP self._hsObj = hsObj DCNL DCSP self._allResults = [] DCNL DCSP self._errModels = set() DCNL DCSP self._numErrModels = 0 DCNL DCSP self._completedModels = set() DCNL DCSP self._numCompletedModels = 0 DCNL DCSP self._modelIDToIdx = dict() DCNL DCSP self._bestResult = numpy.inf DCNL DCSP self._bestModelID = None DCNL DCSP self._swarmBestOverall = dict() DCNL DCSP self._swarmNumParticlesPerGeneration = dict() DCNL DCSP self._modifiedSwarmGens = set() DCNL DCSP self._maturedSwarmGens = set() DCNL DCSP self._particleBest = dict() DCNL DCSP self._particleLatestGenIdx = dict() DCNL DCSP self._swarmIdToIndexes = dict() DCNL DCSP self._paramsHashToIndexes = dict()
def update(self, modelID, modelParams, modelParamsHash, metricResult, completed, completionReason, matured, numRecords): DCNL DCSP assert (modelParamsHash is not None) DCNL DCSP if completed: DCNL DCSP  DCSP matured = True DCNL DCSP if ((metricResult is not None) and matured and (completionReason in [ClientJobsDAO.CMPL_REASON_EOF, ClientJobsDAO.CMPL_REASON_STOPPED])): DCNL DCSP  DCSP if self._hsObj._maximize: DCNL DCSP  DCSP  DCSP errScore = ((-1) * metricResult) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP errScore = metricResult DCNL DCSP  DCSP if (errScore < self._bestResult): DCNL DCSP  DCSP  DCSP self._bestResult = errScore DCNL DCSP  DCSP  DCSP self._bestModelID = modelID DCNL DCSP  DCSP  DCSP self._hsObj.logger.info(('New DCSP best DCSP model DCSP after DCSP %d DCSP evaluations: DCSP errScore DCSP %g DCSP on DCSP model DCSP %s' % (len(self._allResults), self._bestResult, self._bestModelID))) DCNL DCSP else: DCNL DCSP  DCSP errScore = numpy.inf DCNL DCSP if (completed and (completionReason in [ClientJobsDAO.CMPL_REASON_ORPHAN])): DCNL DCSP  DCSP errScore = numpy.inf DCNL DCSP  DCSP hidden = True DCNL DCSP else: DCNL DCSP  DCSP hidden = False DCNL DCSP if completed: DCNL DCSP  DCSP self._completedModels.add(modelID) DCNL DCSP  DCSP self._numCompletedModels = len(self._completedModels) DCNL DCSP  DCSP if (completionReason == ClientJobsDAO.CMPL_REASON_ERROR): DCNL DCSP  DCSP  DCSP self._errModels.add(modelID) DCNL DCSP  DCSP  DCSP self._numErrModels = len(self._errModels) DCNL DCSP wasHidden = False DCNL DCSP if (modelID not in self._modelIDToIdx): DCNL DCSP  DCSP assert (modelParams is not None) DCNL DCSP  DCSP entry = dict(modelID=modelID, modelParams=modelParams, modelParamsHash=modelParamsHash, errScore=errScore, completed=completed, matured=matured, numRecords=numRecords, hidden=hidden) DCNL DCSP  DCSP self._allResults.append(entry) DCNL DCSP  DCSP entryIdx = (len(self._allResults) - 1) DCNL DCSP  DCSP self._modelIDToIdx[modelID] = entryIdx DCNL DCSP  DCSP self._paramsHashToIndexes[modelParamsHash] = entryIdx DCNL DCSP  DCSP swarmId = modelParams['particleState']['swarmId'] DCNL DCSP  DCSP if (not hidden): DCNL DCSP  DCSP  DCSP if (swarmId in self._swarmIdToIndexes): DCNL DCSP  DCSP  DCSP  DCSP self._swarmIdToIndexes[swarmId].append(entryIdx) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self._swarmIdToIndexes[swarmId] = [entryIdx] DCNL DCSP  DCSP  DCSP genIdx = modelParams['particleState']['genIdx'] DCNL DCSP  DCSP  DCSP numPsEntry = self._swarmNumParticlesPerGeneration.get(swarmId, [0]) DCNL DCSP  DCSP  DCSP while (genIdx >= len(numPsEntry)): DCNL DCSP  DCSP  DCSP  DCSP numPsEntry.append(0) DCNL DCSP  DCSP  DCSP numPsEntry[genIdx] += 1 DCNL DCSP  DCSP  DCSP self._swarmNumParticlesPerGeneration[swarmId] = numPsEntry DCNL DCSP else: DCNL DCSP  DCSP entryIdx = self._modelIDToIdx.get(modelID, None) DCNL DCSP  DCSP assert (entryIdx is not None) DCNL DCSP  DCSP entry = self._allResults[entryIdx] DCNL DCSP  DCSP wasHidden = entry['hidden'] DCNL DCSP  DCSP if (entry['modelParamsHash'] != modelParamsHash): DCNL DCSP  DCSP  DCSP self._paramsHashToIndexes.pop(entry['modelParamsHash']) DCNL DCSP  DCSP  DCSP self._paramsHashToIndexes[modelParamsHash] = entryIdx DCNL DCSP  DCSP  DCSP entry['modelParamsHash'] = modelParamsHash DCNL DCSP  DCSP modelParams = entry['modelParams'] DCNL DCSP  DCSP swarmId = modelParams['particleState']['swarmId'] DCNL DCSP  DCSP genIdx = modelParams['particleState']['genIdx'] DCNL DCSP  DCSP if (hidden and (not wasHidden)): DCNL DCSP  DCSP  DCSP assert (entryIdx in self._swarmIdToIndexes[swarmId]) DCNL DCSP  DCSP  DCSP self._swarmIdToIndexes[swarmId].remove(entryIdx) DCNL DCSP  DCSP  DCSP self._swarmNumParticlesPerGeneration[swarmId][genIdx] -= 1 DCNL DCSP  DCSP entry['errScore'] = errScore DCNL DCSP  DCSP entry['completed'] = completed DCNL DCSP  DCSP entry['matured'] = matured DCNL DCSP  DCSP entry['numRecords'] = numRecords DCNL DCSP  DCSP entry['hidden'] = hidden DCNL DCSP particleId = modelParams['particleState']['id'] DCNL DCSP genIdx = modelParams['particleState']['genIdx'] DCNL DCSP if (matured and (not hidden)): DCNL DCSP  DCSP (oldResult, pos) = self._particleBest.get(particleId, (numpy.inf, None)) DCNL DCSP  DCSP if (errScore < oldResult): DCNL DCSP  DCSP  DCSP pos = Particle.getPositionFromState(modelParams['particleState']) DCNL DCSP  DCSP  DCSP self._particleBest[particleId] = (errScore, pos) DCNL DCSP prevGenIdx = self._particleLatestGenIdx.get(particleId, (-1)) DCNL DCSP if ((not hidden) and (genIdx > prevGenIdx)): DCNL DCSP  DCSP self._particleLatestGenIdx[particleId] = genIdx DCNL DCSP elif (hidden and (not wasHidden) and (genIdx == prevGenIdx)): DCNL DCSP  DCSP self._particleLatestGenIdx[particleId] = (genIdx - 1) DCNL DCSP if (not hidden): DCNL DCSP  DCSP swarmId = modelParams['particleState']['swarmId'] DCNL DCSP  DCSP if (not (swarmId in self._swarmBestOverall)): DCNL DCSP  DCSP  DCSP self._swarmBestOverall[swarmId] = [] DCNL DCSP  DCSP bestScores = self._swarmBestOverall[swarmId] DCNL DCSP  DCSP while (genIdx >= len(bestScores)): DCNL DCSP  DCSP  DCSP bestScores.append((None, numpy.inf)) DCNL DCSP  DCSP if (errScore < bestScores[genIdx][1]): DCNL DCSP  DCSP  DCSP bestScores[genIdx] = (modelID, errScore) DCNL DCSP if (not hidden): DCNL DCSP  DCSP key = (swarmId, genIdx) DCNL DCSP  DCSP if (not (key in self._maturedSwarmGens)): DCNL DCSP  DCSP  DCSP self._modifiedSwarmGens.add(key) DCNL DCSP return errScore
def getNumErrModels(self): DCNL DCSP return self._numErrModels
def getErrModelIds(self): DCNL DCSP return list(self._errModels)
def getNumCompletedModels(self): DCNL DCSP return self._numCompletedModels
def getModelIDFromParamsHash(self, paramsHash): DCNL DCSP entryIdx = self._paramsHashToIndexes.get(paramsHash, None) DCNL DCSP if (entryIdx is not None): DCNL DCSP  DCSP return self._allResults[entryIdx]['modelID'] DCNL DCSP else: DCNL DCSP  DCSP return None
def numModels(self, swarmId=None, includeHidden=False): DCNL DCSP if includeHidden: DCNL DCSP  DCSP if (swarmId is None): DCNL DCSP  DCSP  DCSP return len(self._allResults) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return len(self._swarmIdToIndexes.get(swarmId, [])) DCNL DCSP else: DCNL DCSP  DCSP if (swarmId is None): DCNL DCSP  DCSP  DCSP entries = self._allResults DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP entries = [self._allResults[entryIdx] for entryIdx in self._swarmIdToIndexes.get(swarmId, [])] DCNL DCSP  DCSP return len([entry for entry in entries if (not entry['hidden'])])
def bestModelIdAndErrScore(self, swarmId=None, genIdx=None): DCNL DCSP if (swarmId is None): DCNL DCSP  DCSP return (self._bestModelID, self._bestResult) DCNL DCSP else: DCNL DCSP  DCSP if (swarmId not in self._swarmBestOverall): DCNL DCSP  DCSP  DCSP return (None, numpy.inf) DCNL DCSP  DCSP genScores = self._swarmBestOverall[swarmId] DCNL DCSP  DCSP bestModelId = None DCNL DCSP  DCSP bestScore = numpy.inf DCNL DCSP  DCSP for (i, (modelId, errScore)) in enumerate(genScores): DCNL DCSP  DCSP  DCSP if ((genIdx is not None) and (i > genIdx)): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (errScore < bestScore): DCNL DCSP  DCSP  DCSP  DCSP bestScore = errScore DCNL DCSP  DCSP  DCSP  DCSP bestModelId = modelId DCNL DCSP  DCSP return (bestModelId, bestScore)
def getParticleInfo(self, modelId): DCNL DCSP entry = self._allResults[self._modelIDToIdx[modelId]] DCNL DCSP return (entry['modelParams']['particleState'], modelId, entry['errScore'], entry['completed'], entry['matured'])
def getParticleInfos(self, swarmId=None, genIdx=None, completed=None, matured=None, lastDescendent=False): DCNL DCSP if (swarmId is not None): DCNL DCSP  DCSP entryIdxs = self._swarmIdToIndexes.get(swarmId, []) DCNL DCSP else: DCNL DCSP  DCSP entryIdxs = range(len(self._allResults)) DCNL DCSP if (len(entryIdxs) == 0): DCNL DCSP  DCSP return ([], [], [], [], []) DCNL DCSP particleStates = [] DCNL DCSP modelIds = [] DCNL DCSP errScores = [] DCNL DCSP completedFlags = [] DCNL DCSP maturedFlags = [] DCNL DCSP for idx in entryIdxs: DCNL DCSP  DCSP entry = self._allResults[idx] DCNL DCSP  DCSP if (swarmId is not None): DCNL DCSP  DCSP  DCSP assert (not entry['hidden']) DCNL DCSP  DCSP modelParams = entry['modelParams'] DCNL DCSP  DCSP isCompleted = entry['completed'] DCNL DCSP  DCSP isMatured = entry['matured'] DCNL DCSP  DCSP particleState = modelParams['particleState'] DCNL DCSP  DCSP particleGenIdx = particleState['genIdx'] DCNL DCSP  DCSP particleId = particleState['id'] DCNL DCSP  DCSP if ((genIdx is not None) and (particleGenIdx != genIdx)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((completed is not None) and (completed != isCompleted)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((matured is not None) and (matured != isMatured)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (lastDescendent and (self._particleLatestGenIdx[particleId] != particleGenIdx)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP particleStates.append(particleState) DCNL DCSP  DCSP modelIds.append(entry['modelID']) DCNL DCSP  DCSP errScores.append(entry['errScore']) DCNL DCSP  DCSP completedFlags.append(isCompleted) DCNL DCSP  DCSP maturedFlags.append(isMatured) DCNL DCSP return (particleStates, modelIds, errScores, completedFlags, maturedFlags)
def getOrphanParticleInfos(self, swarmId, genIdx): DCNL DCSP entryIdxs = range(len(self._allResults)) DCNL DCSP if (len(entryIdxs) == 0): DCNL DCSP  DCSP return ([], [], [], [], []) DCNL DCSP particleStates = [] DCNL DCSP modelIds = [] DCNL DCSP errScores = [] DCNL DCSP completedFlags = [] DCNL DCSP maturedFlags = [] DCNL DCSP for idx in entryIdxs: DCNL DCSP  DCSP entry = self._allResults[idx] DCNL DCSP  DCSP if (not entry['hidden']): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP modelParams = entry['modelParams'] DCNL DCSP  DCSP if (modelParams['particleState']['swarmId'] != swarmId): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP isCompleted = entry['completed'] DCNL DCSP  DCSP isMatured = entry['matured'] DCNL DCSP  DCSP particleState = modelParams['particleState'] DCNL DCSP  DCSP particleGenIdx = particleState['genIdx'] DCNL DCSP  DCSP particleId = particleState['id'] DCNL DCSP  DCSP if ((genIdx is not None) and (particleGenIdx != genIdx)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP particleStates.append(particleState) DCNL DCSP  DCSP modelIds.append(entry['modelID']) DCNL DCSP  DCSP errScores.append(entry['errScore']) DCNL DCSP  DCSP completedFlags.append(isCompleted) DCNL DCSP  DCSP maturedFlags.append(isMatured) DCNL DCSP return (particleStates, modelIds, errScores, completedFlags, maturedFlags)
def getMaturedSwarmGenerations(self): DCNL DCSP result = [] DCNL DCSP modifiedSwarmGens = sorted(self._modifiedSwarmGens) DCNL DCSP for key in modifiedSwarmGens: DCNL DCSP  DCSP (swarmId, genIdx) = key DCNL DCSP  DCSP if (key in self._maturedSwarmGens): DCNL DCSP  DCSP  DCSP self._modifiedSwarmGens.remove(key) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((genIdx >= 1) and (not ((swarmId, (genIdx - 1)) in self._maturedSwarmGens))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (_, _, errScores, completedFlags, maturedFlags) = self.getParticleInfos(swarmId, genIdx) DCNL DCSP  DCSP maturedFlags = numpy.array(maturedFlags) DCNL DCSP  DCSP numMatured = maturedFlags.sum() DCNL DCSP  DCSP if ((numMatured >= self._hsObj._minParticlesPerSwarm) and (numMatured == len(maturedFlags))): DCNL DCSP  DCSP  DCSP errScores = numpy.array(errScores) DCNL DCSP  DCSP  DCSP bestScore = errScores.min() DCNL DCSP  DCSP  DCSP self._maturedSwarmGens.add(key) DCNL DCSP  DCSP  DCSP self._modifiedSwarmGens.remove(key) DCNL DCSP  DCSP  DCSP result.append((swarmId, genIdx, bestScore)) DCNL DCSP return result
def firstNonFullGeneration(self, swarmId, minNumParticles): DCNL DCSP if (not (swarmId in self._swarmNumParticlesPerGeneration)): DCNL DCSP  DCSP return None DCNL DCSP numPsPerGen = self._swarmNumParticlesPerGeneration[swarmId] DCNL DCSP numPsPerGen = numpy.array(numPsPerGen) DCNL DCSP firstNonFull = numpy.where((numPsPerGen < minNumParticles))[0] DCNL DCSP if (len(firstNonFull) == 0): DCNL DCSP  DCSP return len(numPsPerGen) DCNL DCSP else: DCNL DCSP  DCSP return firstNonFull[0]
def highestGeneration(self, swarmId): DCNL DCSP numPsPerGen = self._swarmNumParticlesPerGeneration[swarmId] DCNL DCSP return (len(numPsPerGen) - 1)
def getParticleBest(self, particleId): DCNL DCSP return self._particleBest.get(particleId, (None, None))
def getResultsPerChoice(self, swarmId, maxGenIdx, varName): DCNL DCSP results = dict() DCNL DCSP (allParticles, _, resultErrs, _, _) = self.getParticleInfos(swarmId, genIdx=None, matured=True) DCNL DCSP for (particleState, resultErr) in itertools.izip(allParticles, resultErrs): DCNL DCSP  DCSP if (maxGenIdx is not None): DCNL DCSP  DCSP  DCSP if (particleState['genIdx'] > maxGenIdx): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (resultErr == numpy.inf): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP position = Particle.getPositionFromState(particleState) DCNL DCSP  DCSP varPosition = position[varName] DCNL DCSP  DCSP varPositionStr = str(varPosition) DCNL DCSP  DCSP if (varPositionStr in results): DCNL DCSP  DCSP  DCSP results[varPositionStr][1].append(resultErr) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results[varPositionStr] = (varPosition, [resultErr]) DCNL DCSP return results
def __init__(self, searchParams, workerID=None, cjDAO=None, jobID=None, logLevel=None): DCNL DCSP self.logger = logging.getLogger('.'.join(['com.numenta', self.__class__.__module__, self.__class__.__name__])) DCNL DCSP if (logLevel is not None): DCNL DCSP  DCSP self.logger.setLevel(logLevel) DCNL DCSP random.seed(42) DCNL DCSP self._searchParams = searchParams DCNL DCSP self._workerID = workerID DCNL DCSP self._cjDAO = cjDAO DCNL DCSP self._jobID = jobID DCNL DCSP self.logger.info(('searchParams: DCSP \n%s' % pprint.pformat(clippedObj(searchParams)))) DCNL DCSP self._createCheckpoints = self._searchParams.get('createCheckpoints', False) DCNL DCSP self._maxModels = self._searchParams.get('maxModels', None) DCNL DCSP if (self._maxModels == (-1)): DCNL DCSP  DCSP self._maxModels = None DCNL DCSP self._predictionCacheMaxRecords = self._searchParams.get('predictionCacheMaxRecords', None) DCNL DCSP self._speculativeParticles = self._searchParams.get('speculativeParticles', bool(int(Configuration.get('nupic.hypersearch.speculative.particles.default')))) DCNL DCSP self._speculativeWaitSecondsMax = float(Configuration.get('nupic.hypersearch.speculative.particles.sleepSecondsMax')) DCNL DCSP self._maxBranching = int(Configuration.get('nupic.hypersearch.max.field.branching')) DCNL DCSP self._minFieldContribution = float(Configuration.get('nupic.hypersearch.min.field.contribution')) DCNL DCSP self._jobCancelled = False DCNL DCSP if ('useTerminators' in self._searchParams): DCNL DCSP  DCSP useTerminators = self._searchParams['useTerminators'] DCNL DCSP  DCSP useTerminators = str(int(useTerminators)) DCNL DCSP  DCSP Configuration.set('nupic.hypersearch.enableModelTermination', useTerminators) DCNL DCSP  DCSP Configuration.set('nupic.hypersearch.enableModelMaturity', useTerminators) DCNL DCSP  DCSP Configuration.set('nupic.hypersearch.enableSwarmTermination', useTerminators) DCNL DCSP if ('NTA_TEST_exitAfterNModels' in os.environ): DCNL DCSP  DCSP self._maxModels = int(os.environ['NTA_TEST_exitAfterNModels']) DCNL DCSP self._dummyModel = self._searchParams.get('dummyModel', None) DCNL DCSP self._tempDir = None DCNL DCSP try: DCNL DCSP  DCSP if ('description' in self._searchParams): DCNL DCSP  DCSP  DCSP if (('permutationsPyFilename' in self._searchParams) or ('permutationsPyContents' in self._searchParams) or ('descriptionPyContents' in self._searchParams)): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError("Either DCSP 'description', DCSP 'permutationsPyFilename' DCSP or'permutationsPyContents' DCSP & DCSP 'permutationsPyContents' DCSP should DCSP be DCSP specified, DCSP but DCSP not DCSP two DCSP or DCSP more DCSP of DCSP these DCSP at DCSP once.") DCNL DCSP  DCSP  DCSP searchParamObj = self._searchParams DCNL DCSP  DCSP  DCSP anomalyParams = searchParamObj['description'].get('anomalyParams', dict()) DCNL DCSP  DCSP  DCSP if (anomalyParams is None): DCNL DCSP  DCSP  DCSP  DCSP anomalyParams = dict() DCNL DCSP  DCSP  DCSP if (('autoDetectWaitRecords' not in anomalyParams) or (anomalyParams['autoDetectWaitRecords'] is None)): DCNL DCSP  DCSP  DCSP  DCSP streamDef = self._getStreamDef(searchParamObj['description']) DCNL DCSP  DCSP  DCSP  DCSP from nupic.data.stream_reader import StreamReader DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP streamReader = StreamReader(streamDef, isBlocking=False, maxTimeout=0, eofOnTimeout=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP anomalyParams['autoDetectWaitRecords'] = streamReader.getDataRowCount() DCNL DCSP  DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP  DCSP anomalyParams['autoDetectWaitRecords'] = None DCNL DCSP  DCSP  DCSP  DCSP self._searchParams['description']['anomalyParams'] = anomalyParams DCNL DCSP  DCSP  DCSP outDir = self._tempDir = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP expGenerator([('--description=%s' % json.dumps(self._searchParams['description'])), '--version=v2', ('--outDir=%s' % outDir)]) DCNL DCSP  DCSP  DCSP permutationsScript = os.path.join(outDir, 'permutations.py') DCNL DCSP  DCSP elif ('permutationsPyFilename' in self._searchParams): DCNL DCSP  DCSP  DCSP if (('description' in self._searchParams) or ('permutationsPyContents' in self._searchParams) or ('descriptionPyContents' in self._searchParams)): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError("Either DCSP 'description', DCSP 'permutationsPyFilename' DCSP or DCSP 'permutationsPyContents' DCSP & DCSP 'permutationsPyContents' DCSP should DCSP be DCSP specified, DCSP but DCSP not DCSP two DCSP or DCSP more DCSP of DCSP these DCSP at DCSP once.") DCNL DCSP  DCSP  DCSP permutationsScript = self._searchParams['permutationsPyFilename'] DCNL DCSP  DCSP elif ('permutationsPyContents' in self._searchParams): DCNL DCSP  DCSP  DCSP if (('description' in self._searchParams) or ('permutationsPyFilename' in self._searchParams)): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError("Either DCSP 'description', DCSP 'permutationsPyFilename' DCSP or'permutationsPyContents' DCSP & DCSP 'permutationsPyContents' DCSP should DCSP be DCSP specified, DCSP but DCSP not DCSP two DCSP or DCSP more DCSP of DCSP these DCSP at DCSP once.") DCNL DCSP  DCSP  DCSP assert ('descriptionPyContents' in self._searchParams) DCNL DCSP  DCSP  DCSP outDir = self._tempDir = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP permutationsScript = os.path.join(outDir, 'permutations.py') DCNL DCSP  DCSP  DCSP fd = open(permutationsScript, 'w') DCNL DCSP  DCSP  DCSP fd.write(self._searchParams['permutationsPyContents']) DCNL DCSP  DCSP  DCSP fd.close() DCNL DCSP  DCSP  DCSP fd = open(os.path.join(outDir, 'description.py'), 'w') DCNL DCSP  DCSP  DCSP fd.write(self._searchParams['descriptionPyContents']) DCNL DCSP  DCSP  DCSP fd.close() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError("Either DCSP 'description' DCSP or DCSP 'permutationsScript' DCSP must DCSP bespecified") DCNL DCSP  DCSP self._basePath = os.path.dirname(permutationsScript) DCNL DCSP  DCSP self._baseDescription = open(os.path.join(self._basePath, 'description.py')).read() DCNL DCSP  DCSP self._baseDescriptionHash = hashlib.md5(self._baseDescription).digest() DCNL DCSP  DCSP (modelDescription, _) = helpers.loadExperiment(self._basePath) DCNL DCSP  DCSP self._readPermutationsFile(permutationsScript, modelDescription) DCNL DCSP  DCSP if (self._cjDAO is not None): DCNL DCSP  DCSP  DCSP updated = self._cjDAO.jobSetFieldIfEqual(jobID=self._jobID, fieldName='genBaseDescription', curValue=None, newValue=self._baseDescription) DCNL DCSP  DCSP  DCSP if updated: DCNL DCSP  DCSP  DCSP  DCSP permContents = open(permutationsScript).read() DCNL DCSP  DCSP  DCSP  DCSP self._cjDAO.jobSetFieldIfEqual(jobID=self._jobID, fieldName='genPermutations', curValue=None, newValue=permContents) DCNL DCSP  DCSP if (self._dummyModelParamsFunc is not None): DCNL DCSP  DCSP  DCSP if (self._dummyModel is None): DCNL DCSP  DCSP  DCSP  DCSP self._dummyModel = dict() DCNL DCSP  DCSP if (self.logger.getEffectiveLevel() <= logging.DEBUG): DCNL DCSP  DCSP  DCSP msg = StringIO.StringIO() DCNL DCSP  DCSP  DCSP print >>msg, 'Permutations DCSP file DCSP specifications: DCSP ' DCNL DCSP  DCSP  DCSP info = dict() DCNL DCSP  DCSP  DCSP for key in ['_predictedField', '_permutations', '_flattenedPermutations', '_encoderNames', '_reportKeys', '_optimizeKey', '_maximize']: DCNL DCSP  DCSP  DCSP  DCSP info[key] = getattr(self, key) DCNL DCSP  DCSP  DCSP print >>msg, pprint.pformat(info) DCNL DCSP  DCSP  DCSP self.logger.debug(msg.getvalue()) DCNL DCSP  DCSP  DCSP msg.close() DCNL DCSP  DCSP self._resultsDB = ResultsDB(self) DCNL DCSP  DCSP self._swarmTerminator = SwarmTerminator() DCNL DCSP  DCSP self._hsState = None DCNL DCSP  DCSP self._maxUniqueModelAttempts = int(Configuration.get('nupic.hypersearch.maxUniqueModelAttempts')) DCNL DCSP  DCSP self._modelOrphanIntervalSecs = float(Configuration.get('nupic.hypersearch.modelOrphanIntervalSecs')) DCNL DCSP  DCSP self._maxPctErrModels = float(Configuration.get('nupic.hypersearch.maxPctErrModels')) DCNL DCSP except: DCNL DCSP  DCSP if (self._tempDir is not None): DCNL DCSP  DCSP  DCSP shutil.rmtree(self._tempDir) DCNL DCSP  DCSP  DCSP self._tempDir = None DCNL DCSP  DCSP raise DCNL DCSP return
def _getStreamDef(self, modelDescription): DCNL DCSP aggregationPeriod = {'days': 0, 'hours': 0, 'microseconds': 0, 'milliseconds': 0, 'minutes': 0, 'months': 0, 'seconds': 0, 'weeks': 0, 'years': 0} DCNL DCSP aggFunctionsDict = {} DCNL DCSP if ('aggregation' in modelDescription['streamDef']): DCNL DCSP  DCSP for key in aggregationPeriod.keys(): DCNL DCSP  DCSP  DCSP if (key in modelDescription['streamDef']['aggregation']): DCNL DCSP  DCSP  DCSP  DCSP aggregationPeriod[key] = modelDescription['streamDef']['aggregation'][key] DCNL DCSP  DCSP if ('fields' in modelDescription['streamDef']['aggregation']): DCNL DCSP  DCSP  DCSP for (fieldName, func) in modelDescription['streamDef']['aggregation']['fields']: DCNL DCSP  DCSP  DCSP  DCSP aggFunctionsDict[fieldName] = str(func) DCNL DCSP hasAggregation = False DCNL DCSP for v in aggregationPeriod.values(): DCNL DCSP  DCSP if (v != 0): DCNL DCSP  DCSP  DCSP hasAggregation = True DCNL DCSP  DCSP  DCSP break DCNL DCSP aggFunctionList = aggFunctionsDict.items() DCNL DCSP aggregationInfo = dict(aggregationPeriod) DCNL DCSP aggregationInfo['fields'] = aggFunctionList DCNL DCSP streamDef = copy.deepcopy(modelDescription['streamDef']) DCNL DCSP streamDef['aggregation'] = copy.deepcopy(aggregationInfo) DCNL DCSP return streamDef
def __del__(self): DCNL DCSP self.close() DCNL DCSP return
def close(self): DCNL DCSP if ((self._tempDir is not None) and os.path.isdir(self._tempDir)): DCNL DCSP  DCSP self.logger.debug('Removing DCSP temporary DCSP directory DCSP %r', self._tempDir) DCNL DCSP  DCSP shutil.rmtree(self._tempDir) DCNL DCSP  DCSP self._tempDir = None DCNL DCSP return
def _readPermutationsFile(self, filename, modelDescription): DCNL DCSP vars = {} DCNL DCSP permFile = execfile(filename, globals(), vars) DCNL DCSP self._reportKeys = vars.get('report', []) DCNL DCSP self._filterFunc = vars.get('permutationFilter', None) DCNL DCSP self._dummyModelParamsFunc = vars.get('dummyModelParams', None) DCNL DCSP self._predictedField = None DCNL DCSP self._predictedFieldEncoder = None DCNL DCSP self._fixedFields = None DCNL DCSP self._fastSwarmModelParams = vars.get('fastSwarmModelParams', None) DCNL DCSP if (self._fastSwarmModelParams is not None): DCNL DCSP  DCSP encoders = self._fastSwarmModelParams['structuredParams']['modelParams']['sensorParams']['encoders'] DCNL DCSP  DCSP self._fixedFields = [] DCNL DCSP  DCSP for fieldName in encoders: DCNL DCSP  DCSP  DCSP if (encoders[fieldName] is not None): DCNL DCSP  DCSP  DCSP  DCSP self._fixedFields.append(fieldName) DCNL DCSP if ('fixedFields' in vars): DCNL DCSP  DCSP self._fixedFields = vars['fixedFields'] DCNL DCSP self._minParticlesPerSwarm = vars.get('minParticlesPerSwarm') DCNL DCSP if (self._minParticlesPerSwarm == None): DCNL DCSP  DCSP self._minParticlesPerSwarm = Configuration.get('nupic.hypersearch.minParticlesPerSwarm') DCNL DCSP self._minParticlesPerSwarm = int(self._minParticlesPerSwarm) DCNL DCSP self._killUselessSwarms = vars.get('killUselessSwarms', True) DCNL DCSP self._inputPredictedField = vars.get('inputPredictedField', 'yes') DCNL DCSP self._tryAll3FieldCombinations = vars.get('tryAll3FieldCombinations', False) DCNL DCSP self._tryAll3FieldCombinationsWTimestamps = vars.get('tryAll3FieldCombinationsWTimestamps', False) DCNL DCSP minFieldContribution = vars.get('minFieldContribution', None) DCNL DCSP if (minFieldContribution is not None): DCNL DCSP  DCSP self._minFieldContribution = minFieldContribution DCNL DCSP maxBranching = vars.get('maxFieldBranching', None) DCNL DCSP if (maxBranching is not None): DCNL DCSP  DCSP self._maxBranching = maxBranching DCNL DCSP if ('maximize' in vars): DCNL DCSP  DCSP self._optimizeKey = vars['maximize'] DCNL DCSP  DCSP self._maximize = True DCNL DCSP elif ('minimize' in vars): DCNL DCSP  DCSP self._optimizeKey = vars['minimize'] DCNL DCSP  DCSP self._maximize = False DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError("Permutations DCSP file DCSP '%s' DCSP does DCSP not DCSP include DCSP a DCSP maximize DCSP or DCSP minimize DCSP metric.") DCNL DCSP maxModels = vars.get('maxModels') DCNL DCSP if (maxModels is not None): DCNL DCSP  DCSP if (self._maxModels is None): DCNL DCSP  DCSP  DCSP self._maxModels = maxModels DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError('It DCSP is DCSP an DCSP error DCSP to DCSP specify DCSP maxModels DCSP both DCSP in DCSP the DCSP job DCSP params DCSP AND DCSP in DCSP the DCSP permutations DCSP file.') DCNL DCSP inferenceType = modelDescription['modelParams']['inferenceType'] DCNL DCSP if (not InferenceType.validate(inferenceType)): DCNL DCSP  DCSP raise ValueError(('Invalid DCSP inference DCSP type DCSP %s' % inferenceType)) DCNL DCSP if (inferenceType in [InferenceType.TemporalMultiStep, InferenceType.NontemporalMultiStep]): DCNL DCSP  DCSP classifierOnlyEncoder = None DCNL DCSP  DCSP for encoder in modelDescription['modelParams']['sensorParams']['encoders'].values(): DCNL DCSP  DCSP  DCSP if (encoder.get('classifierOnly', False) and (encoder['fieldname'] == vars.get('predictedField', None))): DCNL DCSP  DCSP  DCSP  DCSP classifierOnlyEncoder = encoder DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if ((classifierOnlyEncoder is None) or (self._inputPredictedField == 'yes')): DCNL DCSP  DCSP  DCSP self._searchType = HsSearchType.legacyTemporal DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._searchType = HsSearchType.temporal DCNL DCSP elif (inferenceType in [InferenceType.TemporalNextStep, InferenceType.TemporalAnomaly]): DCNL DCSP  DCSP self._searchType = HsSearchType.legacyTemporal DCNL DCSP elif (inferenceType in (InferenceType.TemporalClassification, InferenceType.NontemporalClassification)): DCNL DCSP  DCSP self._searchType = HsSearchType.classification DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(('Unsupported DCSP inference DCSP type: DCSP %s' % inferenceType)) DCNL DCSP self._predictedField = vars.get('predictedField', None) DCNL DCSP if (self._predictedField is None): DCNL DCSP  DCSP raise RuntimeError(("Permutations DCSP file DCSP '%s' DCSP does DCSP not DCSP have DCSP the DCSP required DCSP 'predictedField' DCSP variable" % filename)) DCNL DCSP if ('permutations' not in vars): DCNL DCSP  DCSP raise RuntimeError(("Permutations DCSP file DCSP '%s' DCSP does DCSP not DCSP define DCSP permutations" % filename)) DCNL DCSP if (not isinstance(vars['permutations'], dict)): DCNL DCSP  DCSP raise RuntimeError("Permutations DCSP file DCSP '%s' DCSP defines DCSP a DCSP permutations DCSP variable DCSP but DCSP it DCSP is DCSP not DCSP a DCSP dict") DCNL DCSP self._encoderNames = [] DCNL DCSP self._permutations = vars['permutations'] DCNL DCSP self._flattenedPermutations = dict() DCNL DCSP def _flattenPermutations(value, keys): DCNL DCSP  DCSP if (':' in keys[(-1)]): DCNL DCSP  DCSP  DCSP raise RuntimeError("The DCSP permutation DCSP variable DCSP '%s' DCSP contains DCSP a DCSP ':' DCSP character, DCSP which DCSP is DCSP not DCSP allowed.") DCNL DCSP  DCSP flatKey = _flattenKeys(keys) DCNL DCSP  DCSP if isinstance(value, PermuteEncoder): DCNL DCSP  DCSP  DCSP self._encoderNames.append(flatKey) DCNL DCSP  DCSP  DCSP if (value.fieldName == self._predictedField): DCNL DCSP  DCSP  DCSP  DCSP self._predictedFieldEncoder = flatKey DCNL DCSP  DCSP  DCSP for (encKey, encValue) in value.kwArgs.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(encValue, PermuteVariable): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._flattenedPermutations[('%s:%s' % (flatKey, encKey))] = encValue DCNL DCSP  DCSP elif isinstance(value, PermuteVariable): DCNL DCSP  DCSP  DCSP self._flattenedPermutations[flatKey] = value DCNL DCSP  DCSP elif isinstance(value, PermuteVariable): DCNL DCSP  DCSP  DCSP self._flattenedPermutations[key] = value DCNL DCSP rApply(self._permutations, _flattenPermutations)
def getExpectedNumModels(self): DCNL DCSP return (-1)
def getModelNames(self): DCNL DCSP return None
def getPermutationVariables(self): DCNL DCSP return self._flattenedPermutations
def getComplexVariableLabelLookupDict(self): DCNL DCSP raise NotImplementedError
def getOptimizationMetricInfo(self): DCNL DCSP return (self._optimizeKey, self._maximize)
def _checkForOrphanedModels(self): DCNL DCSP self.logger.debug(('Checking DCSP for DCSP orphaned DCSP models DCSP older DCSP than DCSP %s' % self._modelOrphanIntervalSecs)) DCNL DCSP while True: DCNL DCSP  DCSP orphanedModelId = self._cjDAO.modelAdoptNextOrphan(self._jobID, self._modelOrphanIntervalSecs) DCNL DCSP  DCSP if (orphanedModelId is None): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP self.logger.info(('Removing DCSP orphaned DCSP model: DCSP %d' % orphanedModelId)) DCNL DCSP  DCSP for attempt in range(100): DCNL DCSP  DCSP  DCSP paramsHash = hashlib.md5(('OrphanParams.%d.%d' % (orphanedModelId, attempt))).digest() DCNL DCSP  DCSP  DCSP particleHash = hashlib.md5(('OrphanParticle.%d.%d' % (orphanedModelId, attempt))).digest() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP self._cjDAO.modelSetFields(orphanedModelId, dict(engParamsHash=paramsHash, engParticleHash=particleHash)) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP success = False DCNL DCSP  DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP raise RuntimeError('Unexpected DCSP failure DCSP to DCSP change DCSP paramsHash DCSP and DCSP particleHash DCSP of DCSP orphaned DCSP model') DCNL DCSP  DCSP self._cjDAO.modelSetCompleted(modelID=orphanedModelId, completionReason=ClientJobsDAO.CMPL_REASON_ORPHAN, completionMsg='Orphaned') DCNL DCSP  DCSP self._resultsDB.update(modelID=orphanedModelId, modelParams=None, modelParamsHash=paramsHash, metricResult=None, completed=True, completionReason=ClientJobsDAO.CMPL_REASON_ORPHAN, matured=True, numRecords=0)
def _hsStatePeriodicUpdate(self, exhaustedSwarmId=None): DCNL DCSP if (self._hsState is None): DCNL DCSP  DCSP self._hsState = HsState(self) DCNL DCSP self._hsState.readStateFromDB() DCNL DCSP completedSwarms = set() DCNL DCSP if (exhaustedSwarmId is not None): DCNL DCSP  DCSP self.logger.info(("Removing DCSP swarm DCSP %s DCSP from DCSP the DCSP active DCSP set DCSP because DCSP we DCSP can't DCSP find DCSP any DCSP new DCSP unique DCSP particle DCSP positions" % exhaustedSwarmId)) DCNL DCSP  DCSP (particles, _, _, _, _) = self._resultsDB.getParticleInfos(swarmId=exhaustedSwarmId, matured=False) DCNL DCSP  DCSP if (len(particles) > 0): DCNL DCSP  DCSP  DCSP exhaustedSwarmStatus = 'completing' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP exhaustedSwarmStatus = 'completed' DCNL DCSP if self._killUselessSwarms: DCNL DCSP  DCSP self._hsState.killUselessSwarms() DCNL DCSP completingSwarms = self._hsState.getCompletingSwarms() DCNL DCSP for swarmId in completingSwarms: DCNL DCSP  DCSP (particles, _, _, _, _) = self._resultsDB.getParticleInfos(swarmId=swarmId, matured=False) DCNL DCSP  DCSP if (len(particles) == 0): DCNL DCSP  DCSP  DCSP completedSwarms.add(swarmId) DCNL DCSP completedSwarmGens = self._resultsDB.getMaturedSwarmGenerations() DCNL DCSP priorCompletedSwarms = self._hsState.getCompletedSwarms() DCNL DCSP for (swarmId, genIdx, errScore) in completedSwarmGens: DCNL DCSP  DCSP if (swarmId in priorCompletedSwarms): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP completedList = self._swarmTerminator.recordDataPoint(swarmId=swarmId, generation=genIdx, errScore=errScore) DCNL DCSP  DCSP statusMsg = ("Completed DCSP generation DCSP #%d DCSP of DCSP swarm DCSP '%s' DCSP with DCSP a DCSP best DCSP errScore DCSP of DCSP %g" % (genIdx, swarmId, errScore)) DCNL DCSP  DCSP if (len(completedList) > 0): DCNL DCSP  DCSP  DCSP statusMsg = ('%s. DCSP Matured DCSP swarm(s): DCSP %s' % (statusMsg, completedList)) DCNL DCSP  DCSP self.logger.info(statusMsg) DCNL DCSP  DCSP self._cjDAO.jobSetFields(jobID=self._jobID, fields=dict(engStatus=statusMsg), useConnectionID=False, ignoreUnchanged=True) DCNL DCSP  DCSP if ('NTA_TEST_recordSwarmTerminations' in os.environ): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP resultsStr = self._cjDAO.jobGetFields(self._jobID, ['results'])[0] DCNL DCSP  DCSP  DCSP  DCSP if (resultsStr is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP results = {} DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP results = json.loads(resultsStr) DCNL DCSP  DCSP  DCSP  DCSP if (not ('terminatedSwarms' in results)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP results['terminatedSwarms'] = {} DCNL DCSP  DCSP  DCSP  DCSP for swarm in completedList: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (swarm not in results['terminatedSwarms']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP results['terminatedSwarms'][swarm] = (genIdx, self._swarmTerminator.swarmScores[swarm]) DCNL DCSP  DCSP  DCSP  DCSP newResultsStr = json.dumps(results) DCNL DCSP  DCSP  DCSP  DCSP if (newResultsStr == resultsStr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP updated = self._cjDAO.jobSetFieldIfEqual(jobID=self._jobID, fieldName='results', curValue=resultsStr, newValue=json.dumps(results)) DCNL DCSP  DCSP  DCSP  DCSP if updated: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (len(completedList) > 0): DCNL DCSP  DCSP  DCSP for name in completedList: DCNL DCSP  DCSP  DCSP  DCSP self.logger.info(('Swarm DCSP matured: DCSP %s. DCSP Score DCSP at DCSP generation DCSP %d: DCSP %s' % (name, genIdx, errScore))) DCNL DCSP  DCSP  DCSP completedSwarms = completedSwarms.union(completedList) DCNL DCSP if ((len(completedSwarms) == 0) and (exhaustedSwarmId is None)): DCNL DCSP  DCSP return DCNL DCSP while True: DCNL DCSP  DCSP if (exhaustedSwarmId is not None): DCNL DCSP  DCSP  DCSP self._hsState.setSwarmState(exhaustedSwarmId, exhaustedSwarmStatus) DCNL DCSP  DCSP for swarmId in completedSwarms: DCNL DCSP  DCSP  DCSP self._hsState.setSwarmState(swarmId, 'completed') DCNL DCSP  DCSP if (not self._hsState.isDirty()): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP success = self._hsState.writeStateToDB() DCNL DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP jobResultsStr = self._cjDAO.jobGetFields(self._jobID, ['results'])[0] DCNL DCSP  DCSP  DCSP if (jobResultsStr is not None): DCNL DCSP  DCSP  DCSP  DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP  DCSP  DCSP  DCSP bestModelId = jobResults.get('bestModel', None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP bestModelId = None DCNL DCSP  DCSP  DCSP for swarmId in list(completedSwarms): DCNL DCSP  DCSP  DCSP  DCSP (_, modelIds, _, _, _) = self._resultsDB.getParticleInfos(swarmId=swarmId, completed=False) DCNL DCSP  DCSP  DCSP  DCSP if (bestModelId in modelIds): DCNL DCSP  DCSP  DCSP  DCSP  DCSP modelIds.remove(bestModelId) DCNL DCSP  DCSP  DCSP  DCSP if (len(modelIds) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP self.logger.info(("Killing DCSP the DCSP following DCSP models DCSP in DCSP swarm DCSP '%s' DCSP becausethe DCSP swarm DCSP is DCSP being DCSP terminated: DCSP %s" % (swarmId, str(modelIds)))) DCNL DCSP  DCSP  DCSP  DCSP for modelId in modelIds: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._cjDAO.modelSetFields(modelId, dict(engStop=ClientJobsDAO.STOP_REASON_KILLED), ignoreUnchanged=True) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP self._hsState.readStateFromDB() DCNL DCSP  DCSP self.logger.debug(('New DCSP hsState DCSP has DCSP been DCSP set DCSP by DCSP some DCSP other DCSP worker DCSP to: DCSP  DCSP \n%s' % pprint.pformat(self._hsState._state, indent=4)))
def _getCandidateParticleAndSwarm(self, exhaustedSwarmId=None): DCNL DCSP jobCancel = self._cjDAO.jobGetFields(self._jobID, ['cancel'])[0] DCNL DCSP if jobCancel: DCNL DCSP  DCSP self._jobCancelled = True DCNL DCSP  DCSP (workerCmpReason, workerCmpMsg) = self._cjDAO.jobGetFields(self._jobID, ['workerCompletionReason', 'workerCompletionMsg']) DCNL DCSP  DCSP if (workerCmpReason == ClientJobsDAO.CMPL_REASON_SUCCESS): DCNL DCSP  DCSP  DCSP self.logger.info('Exiting DCSP due DCSP to DCSP job DCSP being DCSP cancelled') DCNL DCSP  DCSP  DCSP self._cjDAO.jobSetFields(self._jobID, dict(workerCompletionMsg='Job DCSP was DCSP cancelled'), useConnectionID=False, ignoreUnchanged=True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.logger.error(('Exiting DCSP because DCSP some DCSP worker DCSP set DCSP the DCSP workerCompletionReason DCSP to DCSP %s. DCSP WorkerCompletionMsg: DCSP %s' % (workerCmpReason, workerCmpMsg))) DCNL DCSP  DCSP return (True, None, None) DCNL DCSP if (self._hsState is not None): DCNL DCSP  DCSP priorActiveSwarms = self._hsState.getActiveSwarms() DCNL DCSP else: DCNL DCSP  DCSP priorActiveSwarms = None DCNL DCSP self._hsStatePeriodicUpdate(exhaustedSwarmId=exhaustedSwarmId) DCNL DCSP activeSwarms = self._hsState.getActiveSwarms() DCNL DCSP if (activeSwarms != priorActiveSwarms): DCNL DCSP  DCSP self.logger.info(('Active DCSP swarms DCSP changed DCSP to DCSP %s DCSP (from DCSP %s)' % (activeSwarms, priorActiveSwarms))) DCNL DCSP self.logger.debug(('Active DCSP swarms: DCSP %s' % activeSwarms)) DCNL DCSP totalCmpModels = self._resultsDB.getNumCompletedModels() DCNL DCSP if (totalCmpModels > 5): DCNL DCSP  DCSP numErrs = self._resultsDB.getNumErrModels() DCNL DCSP  DCSP if ((float(numErrs) / totalCmpModels) > self._maxPctErrModels): DCNL DCSP  DCSP  DCSP errModelIds = self._resultsDB.getErrModelIds() DCNL DCSP  DCSP  DCSP resInfo = self._cjDAO.modelsGetResultAndStatus([errModelIds[0]])[0] DCNL DCSP  DCSP  DCSP modelErrMsg = resInfo.completionMsg DCNL DCSP  DCSP  DCSP cmpMsg = ('%s: DCSP Exiting DCSP due DCSP to DCSP receiving DCSP too DCSP many DCSP models DCSP failing DCSP from DCSP exceptions DCSP (%d DCSP out DCSP of DCSP %d). DCSP \nModel DCSP Exception: DCSP %s' % (ErrorCodes.tooManyModelErrs, numErrs, totalCmpModels, modelErrMsg)) DCNL DCSP  DCSP  DCSP self.logger.error(cmpMsg) DCNL DCSP  DCSP  DCSP workerCmpReason = self._cjDAO.jobGetFields(self._jobID, ['workerCompletionReason'])[0] DCNL DCSP  DCSP  DCSP if (workerCmpReason == ClientJobsDAO.CMPL_REASON_SUCCESS): DCNL DCSP  DCSP  DCSP  DCSP self._cjDAO.jobSetFields(self._jobID, fields=dict(cancel=True, workerCompletionReason=ClientJobsDAO.CMPL_REASON_ERROR, workerCompletionMsg=cmpMsg), useConnectionID=False, ignoreUnchanged=True) DCNL DCSP  DCSP  DCSP return (True, None, None) DCNL DCSP if self._hsState.isSearchOver(): DCNL DCSP  DCSP cmpMsg = 'Exiting DCSP because DCSP results DCSP did DCSP not DCSP improve DCSP in DCSP most DCSP recently DCSP completed DCSP sprint.' DCNL DCSP  DCSP self.logger.info(cmpMsg) DCNL DCSP  DCSP self._cjDAO.jobSetFields(self._jobID, dict(workerCompletionMsg=cmpMsg), useConnectionID=False, ignoreUnchanged=True) DCNL DCSP  DCSP return (True, None, None) DCNL DCSP sprintIdx = (-1) DCNL DCSP while True: DCNL DCSP  DCSP sprintIdx += 1 DCNL DCSP  DCSP (active, eos) = self._hsState.isSprintActive(sprintIdx) DCNL DCSP  DCSP if eos: DCNL DCSP  DCSP  DCSP if self._hsState.anyGoodSprintsActive(): DCNL DCSP  DCSP  DCSP  DCSP self.logger.info('No DCSP more DCSP sprints DCSP to DCSP explore, DCSP waiting DCSP for DCSP prior DCSP sprints DCSP to DCSP complete') DCNL DCSP  DCSP  DCSP  DCSP return (False, None, None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cmpMsg = "Exiting DCSP because DCSP we've DCSP evaluated DCSP all DCSP possible DCSP field DCSP combinations" DCNL DCSP  DCSP  DCSP  DCSP self._cjDAO.jobSetFields(self._jobID, dict(workerCompletionMsg=cmpMsg), useConnectionID=False, ignoreUnchanged=True) DCNL DCSP  DCSP  DCSP  DCSP self.logger.info(cmpMsg) DCNL DCSP  DCSP  DCSP  DCSP return (True, None, None) DCNL DCSP  DCSP if (not active): DCNL DCSP  DCSP  DCSP if (not self._speculativeParticles): DCNL DCSP  DCSP  DCSP  DCSP if (not self._hsState.isSprintCompleted(sprintIdx)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.logger.info(('Waiting DCSP for DCSP all DCSP particles DCSP in DCSP sprint DCSP %d DCSP to DCSP completebefore DCSP evolving DCSP any DCSP more DCSP particles' % sprintIdx)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (False, None, None) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP swarmIds = self._hsState.getActiveSwarms(sprintIdx) DCNL DCSP  DCSP for swarmId in swarmIds: DCNL DCSP  DCSP  DCSP firstNonFullGenIdx = self._resultsDB.firstNonFullGeneration(swarmId=swarmId, minNumParticles=self._minParticlesPerSwarm) DCNL DCSP  DCSP  DCSP if (firstNonFullGenIdx is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (firstNonFullGenIdx < self._resultsDB.highestGeneration(swarmId)): DCNL DCSP  DCSP  DCSP  DCSP self.logger.info(('Cloning DCSP an DCSP earlier DCSP model DCSP in DCSP generation DCSP %d DCSP of DCSP swarm DCSP %s DCSP (sprintIdx=%s) DCSP to DCSP replace DCSP an DCSP orphaned DCSP model' % (firstNonFullGenIdx, swarmId, sprintIdx))) DCNL DCSP  DCSP  DCSP  DCSP (allParticles, allModelIds, errScores, completed, matured) = self._resultsDB.getOrphanParticleInfos(swarmId, firstNonFullGenIdx) DCNL DCSP  DCSP  DCSP  DCSP if (len(allModelIds) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP newParticleId = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.logger.info('Cloning DCSP an DCSP orphaned DCSP model') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP newParticleId = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.logger.info('No DCSP orphans DCSP found, DCSP so DCSP cloning DCSP a DCSP non-orphan') DCNL DCSP  DCSP  DCSP  DCSP  DCSP (allParticles, allModelIds, errScores, completed, matured) = self._resultsDB.getParticleInfos(swarmId=swarmId, genIdx=firstNonFullGenIdx) DCNL DCSP  DCSP  DCSP  DCSP modelId = random.choice(allModelIds) DCNL DCSP  DCSP  DCSP  DCSP self.logger.info(('Cloning DCSP model DCSP %r' % modelId)) DCNL DCSP  DCSP  DCSP  DCSP (particleState, _, _, _, _) = self._resultsDB.getParticleInfo(modelId) DCNL DCSP  DCSP  DCSP  DCSP particle = Particle(hsObj=self, resultsDB=self._resultsDB, flattenedPermuteVars=self._flattenedPermutations, newFromClone=particleState, newParticleId=newParticleId) DCNL DCSP  DCSP  DCSP  DCSP return (False, particle, swarmId) DCNL DCSP  DCSP swarmSizes = numpy.array([self._resultsDB.numModels(x) for x in swarmIds]) DCNL DCSP  DCSP swarmSizeAndIdList = zip(swarmSizes, swarmIds) DCNL DCSP  DCSP swarmSizeAndIdList.sort() DCNL DCSP  DCSP for (_, swarmId) in swarmSizeAndIdList: DCNL DCSP  DCSP  DCSP (allParticles, allModelIds, errScores, completed, matured) = self._resultsDB.getParticleInfos(swarmId) DCNL DCSP  DCSP  DCSP if (len(allParticles) < self._minParticlesPerSwarm): DCNL DCSP  DCSP  DCSP  DCSP particle = Particle(hsObj=self, resultsDB=self._resultsDB, flattenedPermuteVars=self._flattenedPermutations, swarmId=swarmId, newFarFrom=allParticles) DCNL DCSP  DCSP  DCSP  DCSP bestPriorModel = None DCNL DCSP  DCSP  DCSP  DCSP if (sprintIdx >= 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (bestPriorModel, errScore) = self._hsState.bestModelInSprint(0) DCNL DCSP  DCSP  DCSP  DCSP if (bestPriorModel is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.logger.info(('Best DCSP model DCSP and DCSP errScore DCSP from DCSP previous DCSP sprint(%d): DCSP %s, DCSP %g' % (0, str(bestPriorModel), errScore))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (baseState, modelId, errScore, completed, matured) = self._resultsDB.getParticleInfo(bestPriorModel) DCNL DCSP  DCSP  DCSP  DCSP  DCSP particle.copyEncoderStatesFrom(baseState) DCNL DCSP  DCSP  DCSP  DCSP  DCSP particle.copyVarStatesFrom(baseState, ['modelParams|inferenceType']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP whichVars = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for varName in baseState['varStates']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (':' in varName): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP whichVars.append(varName) DCNL DCSP  DCSP  DCSP  DCSP  DCSP particle.newPosition(whichVars) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.logger.debug(('Particle DCSP after DCSP incorporating DCSP encoder DCSP vars DCSP from DCSP best DCSP model DCSP in DCSP previous DCSP sprint: DCSP \n%s' % str(particle))) DCNL DCSP  DCSP  DCSP  DCSP return (False, particle, swarmId) DCNL DCSP  DCSP  DCSP (readyParticles, readyModelIds, readyErrScores, _, _) = self._resultsDB.getParticleInfos(swarmId, genIdx=None, matured=True, lastDescendent=True) DCNL DCSP  DCSP  DCSP if (len(readyParticles) > 0): DCNL DCSP  DCSP  DCSP  DCSP readyGenIdxs = [x['genIdx'] for x in readyParticles] DCNL DCSP  DCSP  DCSP  DCSP sortedGenIdxs = sorted(set(readyGenIdxs)) DCNL DCSP  DCSP  DCSP  DCSP genIdx = sortedGenIdxs[0] DCNL DCSP  DCSP  DCSP  DCSP useParticle = None DCNL DCSP  DCSP  DCSP  DCSP for particle in readyParticles: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (particle['genIdx'] == genIdx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP useParticle = particle DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (not self._speculativeParticles): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (particles, _, _, _, _) = self._resultsDB.getParticleInfos(swarmId, genIdx=genIdx, matured=False) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(particles) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP particle = Particle(hsObj=self, resultsDB=self._resultsDB, flattenedPermuteVars=self._flattenedPermutations, evolveFromState=useParticle) DCNL DCSP  DCSP  DCSP  DCSP return (False, particle, swarmId) DCNL DCSP  DCSP if (not self._speculativeParticles): DCNL DCSP  DCSP  DCSP self.logger.info(('Waiting DCSP for DCSP one DCSP or DCSP more DCSP of DCSP the DCSP %s DCSP swarms DCSP to DCSP complete DCSP a DCSP generation DCSP before DCSP evolving DCSP any DCSP more DCSP particles' % str(swarmIds))) DCNL DCSP  DCSP  DCSP return (False, None, None)
def _okToExit(self): DCNL DCSP print >>sys.stderr, 'reporter:status:In DCSP hypersearchV2: DCSP _okToExit' DCNL DCSP if (not self._jobCancelled): DCNL DCSP  DCSP (_, modelIds, _, _, _) = self._resultsDB.getParticleInfos(matured=False) DCNL DCSP  DCSP if (len(modelIds) > 0): DCNL DCSP  DCSP  DCSP self.logger.info('Ready DCSP to DCSP end DCSP hyperseach, DCSP but DCSP not DCSP all DCSP models DCSP have DCSP matured DCSP yet. DCSP Sleeping DCSP a DCSP bit DCSP to DCSP wait DCSP for DCSP all DCSP models DCSP to DCSP mature.') DCNL DCSP  DCSP  DCSP time.sleep((5.0 * random.random())) DCNL DCSP  DCSP  DCSP return False DCNL DCSP (_, modelIds, _, _, _) = self._resultsDB.getParticleInfos(completed=False) DCNL DCSP for modelId in modelIds: DCNL DCSP  DCSP self.logger.info(('Stopping DCSP model DCSP %d DCSP because DCSP the DCSP search DCSP has DCSP ended' % modelId)) DCNL DCSP  DCSP self._cjDAO.modelSetFields(modelId, dict(engStop=ClientJobsDAO.STOP_REASON_STOPPED), ignoreUnchanged=True) DCNL DCSP self._hsStatePeriodicUpdate() DCNL DCSP (pctFieldContributions, absFieldContributions) = self._hsState.getFieldContributions() DCNL DCSP jobResultsStr = self._cjDAO.jobGetFields(self._jobID, ['results'])[0] DCNL DCSP if (jobResultsStr is not None): DCNL DCSP  DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP else: DCNL DCSP  DCSP jobResults = {} DCNL DCSP if (pctFieldContributions != jobResults.get('fieldContributions', None)): DCNL DCSP  DCSP jobResults['fieldContributions'] = pctFieldContributions DCNL DCSP  DCSP jobResults['absoluteFieldContributions'] = absFieldContributions DCNL DCSP  DCSP isUpdated = self._cjDAO.jobSetFieldIfEqual(self._jobID, fieldName='results', curValue=jobResultsStr, newValue=json.dumps(jobResults)) DCNL DCSP  DCSP if isUpdated: DCNL DCSP  DCSP  DCSP self.logger.info('Successfully DCSP updated DCSP the DCSP field DCSP contributions:%s', pctFieldContributions) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.logger.info('Failed DCSP updating DCSP the DCSP field DCSP contributions, DCSP another DCSP hypersearch DCSP worker DCSP must DCSP have DCSP updated DCSP it') DCNL DCSP return True
def createModels(self, numModels=1): DCNL DCSP self._checkForOrphanedModels() DCNL DCSP modelResults = [] DCNL DCSP for _ in xrange(numModels): DCNL DCSP  DCSP candidateParticle = None DCNL DCSP  DCSP if ((self._maxModels is not None) and ((self._resultsDB.numModels() - self._resultsDB.getNumErrModels()) >= self._maxModels)): DCNL DCSP  DCSP  DCSP return (self._okToExit(), []) DCNL DCSP  DCSP if (candidateParticle is None): DCNL DCSP  DCSP  DCSP (exitNow, candidateParticle, candidateSwarm) = self._getCandidateParticleAndSwarm() DCNL DCSP  DCSP if (candidateParticle is None): DCNL DCSP  DCSP  DCSP if exitNow: DCNL DCSP  DCSP  DCSP  DCSP return (self._okToExit(), []) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, 'reporter:status:In DCSP hypersearchV2: DCSP speculativeWait' DCNL DCSP  DCSP  DCSP  DCSP time.sleep((self._speculativeWaitSecondsMax * random.random())) DCNL DCSP  DCSP  DCSP  DCSP return (False, []) DCNL DCSP  DCSP useEncoders = candidateSwarm.split('.') DCNL DCSP  DCSP numAttempts = 0 DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP if (numAttempts >= 1): DCNL DCSP  DCSP  DCSP  DCSP self.logger.debug(('Agitating DCSP particle DCSP to DCSP get DCSP unique DCSP position DCSP after DCSP %d DCSP failed DCSP attempts DCSP in DCSP a DCSP row' % numAttempts)) DCNL DCSP  DCSP  DCSP  DCSP candidateParticle.agitate() DCNL DCSP  DCSP  DCSP position = candidateParticle.getPosition() DCNL DCSP  DCSP  DCSP structuredParams = dict() DCNL DCSP  DCSP  DCSP def _buildStructuredParams(value, keys): DCNL DCSP  DCSP  DCSP  DCSP flatKey = _flattenKeys(keys) DCNL DCSP  DCSP  DCSP  DCSP if (flatKey in self._encoderNames): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (flatKey in useEncoders): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return value.getDict(flatKey, position) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP  DCSP elif (flatKey in position): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return position[flatKey] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return value DCNL DCSP  DCSP  DCSP structuredParams = rCopy(self._permutations, _buildStructuredParams, discardNoneKeys=False) DCNL DCSP  DCSP  DCSP modelParams = dict(structuredParams=structuredParams, particleState=candidateParticle.getState()) DCNL DCSP  DCSP  DCSP m = hashlib.md5() DCNL DCSP  DCSP  DCSP m.update(sortedJSONDumpS(structuredParams)) DCNL DCSP  DCSP  DCSP m.update(self._baseDescriptionHash) DCNL DCSP  DCSP  DCSP paramsHash = m.digest() DCNL DCSP  DCSP  DCSP particleInst = ('%s.%s' % (modelParams['particleState']['id'], modelParams['particleState']['genIdx'])) DCNL DCSP  DCSP  DCSP particleHash = hashlib.md5(particleInst).digest() DCNL DCSP  DCSP  DCSP numAttempts += 1 DCNL DCSP  DCSP  DCSP if (self._filterFunc and (not self._filterFunc(structuredParams))): DCNL DCSP  DCSP  DCSP  DCSP valid = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP valid = True DCNL DCSP  DCSP  DCSP if (valid and (self._resultsDB.getModelIDFromParamsHash(paramsHash) is None)): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (numAttempts >= self._maxUniqueModelAttempts): DCNL DCSP  DCSP  DCSP  DCSP (exitNow, candidateParticle, candidateSwarm) = self._getCandidateParticleAndSwarm(exhaustedSwarmId=candidateSwarm) DCNL DCSP  DCSP  DCSP  DCSP if (candidateParticle is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if exitNow: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (self._okToExit(), []) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep((self._speculativeWaitSecondsMax * random.random())) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (False, []) DCNL DCSP  DCSP  DCSP  DCSP numAttempts = 0 DCNL DCSP  DCSP  DCSP  DCSP useEncoders = candidateSwarm.split('.') DCNL DCSP  DCSP if (self.logger.getEffectiveLevel() <= logging.DEBUG): DCNL DCSP  DCSP  DCSP self.logger.debug(('Submitting DCSP new DCSP potential DCSP model DCSP to DCSP HypersearchWorker: DCSP \n%s' % pprint.pformat(modelParams, indent=4))) DCNL DCSP  DCSP modelResults.append((modelParams, paramsHash, particleHash)) DCNL DCSP return (False, modelResults)
def recordModelProgress(self, modelID, modelParams, modelParamsHash, results, completed, completionReason, matured, numRecords): DCNL DCSP if (results is None): DCNL DCSP  DCSP metricResult = None DCNL DCSP else: DCNL DCSP  DCSP metricResult = results[1].values()[0] DCNL DCSP errScore = self._resultsDB.update(modelID=modelID, modelParams=modelParams, modelParamsHash=modelParamsHash, metricResult=metricResult, completed=completed, completionReason=completionReason, matured=matured, numRecords=numRecords) DCNL DCSP self.logger.debug('Received DCSP progress DCSP on DCSP model DCSP %d: DCSP completed: DCSP %s, DCSP cmpReason: DCSP %s, DCSP numRecords: DCSP %d, DCSP errScore: DCSP %s', modelID, completed, completionReason, numRecords, errScore) DCNL DCSP (bestModelID, bestResult) = self._resultsDB.bestModelIdAndErrScore() DCNL DCSP self.logger.debug(('Best DCSP err DCSP score DCSP seen DCSP so DCSP far: DCSP %s DCSP on DCSP model DCSP %s' % (bestResult, bestModelID)))
def runModel(self, modelID, jobID, modelParams, modelParamsHash, jobsDAO, modelCheckpointGUID): DCNL DCSP if (not self._createCheckpoints): DCNL DCSP  DCSP modelCheckpointGUID = None DCNL DCSP self._resultsDB.update(modelID=modelID, modelParams=modelParams, modelParamsHash=modelParamsHash, metricResult=None, completed=False, completionReason=None, matured=False, numRecords=0) DCNL DCSP structuredParams = modelParams['structuredParams'] DCNL DCSP if (self.logger.getEffectiveLevel() <= logging.DEBUG): DCNL DCSP  DCSP self.logger.debug(('Running DCSP Model. DCSP \nmodelParams: DCSP %s, DCSP \nmodelID=%s, DCSP ' % (pprint.pformat(modelParams, indent=4), modelID))) DCNL DCSP cpuTimeStart = time.clock() DCNL DCSP logLevel = self.logger.getEffectiveLevel() DCNL DCSP try: DCNL DCSP  DCSP if ((self._dummyModel is None) or (self._dummyModel is False)): DCNL DCSP  DCSP  DCSP (cmpReason, cmpMsg) = runModelGivenBaseAndParams(modelID=modelID, jobID=jobID, baseDescription=self._baseDescription, params=structuredParams, predictedField=self._predictedField, reportKeys=self._reportKeys, optimizeKey=self._optimizeKey, jobsDAO=jobsDAO, modelCheckpointGUID=modelCheckpointGUID, logLevel=logLevel, predictionCacheMaxRecords=self._predictionCacheMaxRecords) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP dummyParams = dict(self._dummyModel) DCNL DCSP  DCSP  DCSP dummyParams['permutationParams'] = structuredParams DCNL DCSP  DCSP  DCSP if (self._dummyModelParamsFunc is not None): DCNL DCSP  DCSP  DCSP  DCSP permInfo = dict(structuredParams) DCNL DCSP  DCSP  DCSP  DCSP permInfo['generation'] = modelParams['particleState']['genIdx'] DCNL DCSP  DCSP  DCSP  DCSP dummyParams.update(self._dummyModelParamsFunc(permInfo)) DCNL DCSP  DCSP  DCSP (cmpReason, cmpMsg) = runDummyModel(modelID=modelID, jobID=jobID, params=dummyParams, predictedField=self._predictedField, reportKeys=self._reportKeys, optimizeKey=self._optimizeKey, jobsDAO=jobsDAO, modelCheckpointGUID=modelCheckpointGUID, logLevel=logLevel, predictionCacheMaxRecords=self._predictionCacheMaxRecords) DCNL DCSP  DCSP jobsDAO.modelSetCompleted(modelID, completionReason=cmpReason, completionMsg=cmpMsg, cpuTime=(time.clock() - cpuTimeStart)) DCNL DCSP except InvalidConnectionException as e: DCNL DCSP  DCSP self.logger.warn('%s', e)
def __init__(self, modelID, jobID, predictedField, experimentDir, reportKeyPatterns, optimizeKeyPattern, jobsDAO, modelCheckpointGUID, logLevel=None, predictionCacheMaxRecords=None): DCNL DCSP self._MIN_RECORDS_TO_BE_BEST = int(Configuration.get('nupic.hypersearch.bestModelMinRecords')) DCNL DCSP self._MATURITY_MAX_CHANGE = float(Configuration.get('nupic.hypersearch.maturityPctChange')) DCNL DCSP self._MATURITY_NUM_POINTS = int(Configuration.get('nupic.hypersearch.maturityNumPoints')) DCNL DCSP self._modelID = modelID DCNL DCSP self._jobID = jobID DCNL DCSP self._predictedField = predictedField DCNL DCSP self._experimentDir = experimentDir DCNL DCSP self._reportKeyPatterns = reportKeyPatterns DCNL DCSP self._optimizeKeyPattern = optimizeKeyPattern DCNL DCSP self._jobsDAO = jobsDAO DCNL DCSP self._modelCheckpointGUID = modelCheckpointGUID DCNL DCSP self._predictionCacheMaxRecords = predictionCacheMaxRecords DCNL DCSP self._isMaturityEnabled = bool(int(Configuration.get('nupic.hypersearch.enableModelMaturity'))) DCNL DCSP self._logger = logging.getLogger('.'.join(['com.numenta', self.__class__.__module__, self.__class__.__name__])) DCNL DCSP self._optimizedMetricLabel = None DCNL DCSP self._reportMetricLabels = [] DCNL DCSP self._cmpReason = ClientJobsDAO.CMPL_REASON_EOF DCNL DCSP if (logLevel is not None): DCNL DCSP  DCSP self._logger.setLevel(logLevel) DCNL DCSP self.__metricMgr = None DCNL DCSP self.__task = None DCNL DCSP self._periodic = None DCNL DCSP self._streamDef = None DCNL DCSP self._model = None DCNL DCSP self._inputSource = None DCNL DCSP self._currentRecordIndex = None DCNL DCSP self._predictionLogger = None DCNL DCSP self.__predictionCache = deque() DCNL DCSP self._isBestModel = False DCNL DCSP self._isBestModelStored = False DCNL DCSP self._isCanceled = False DCNL DCSP self._isKilled = False DCNL DCSP self._isMature = False DCNL DCSP self._isInterrupted = threading.Event() DCNL DCSP self._metricRegression = regression.AveragePctChange(windowSize=self._MATURITY_NUM_POINTS) DCNL DCSP self.__loggedMetricPatterns = []
def run(self): DCNL DCSP descriptionPyModule = helpers.loadExperimentDescriptionScriptFromDir(self._experimentDir) DCNL DCSP expIface = helpers.getExperimentDescriptionInterfaceFromModule(descriptionPyModule) DCNL DCSP expIface.normalizeStreamSources() DCNL DCSP modelDescription = expIface.getModelDescription() DCNL DCSP self._modelControl = expIface.getModelControl() DCNL DCSP streamDef = self._modelControl['dataset'] DCNL DCSP from nupic.data.stream_reader import StreamReader DCNL DCSP readTimeout = 0 DCNL DCSP self._inputSource = StreamReader(streamDef, isBlocking=False, maxTimeout=readTimeout) DCNL DCSP fieldStats = self._getFieldStats() DCNL DCSP self._model = ModelFactory.create(modelDescription) DCNL DCSP self._model.setFieldStatistics(fieldStats) DCNL DCSP self._model.enableLearning() DCNL DCSP self._model.enableInference(self._modelControl.get('inferenceArgs', None)) DCNL DCSP self.__metricMgr = MetricsManager(self._modelControl.get('metrics', None), self._model.getFieldInfo(), self._model.getInferenceType()) DCNL DCSP self.__loggedMetricPatterns = self._modelControl.get('loggedMetrics', []) DCNL DCSP self._optimizedMetricLabel = self.__getOptimizedMetricLabel() DCNL DCSP self._reportMetricLabels = matchPatterns(self._reportKeyPatterns, self._getMetricLabels()) DCNL DCSP self._periodic = self._initPeriodicActivities() DCNL DCSP numIters = self._modelControl.get('iterationCount', (-1)) DCNL DCSP learningOffAt = None DCNL DCSP iterationCountInferOnly = self._modelControl.get('iterationCountInferOnly', 0) DCNL DCSP if (iterationCountInferOnly == (-1)): DCNL DCSP  DCSP self._model.disableLearning() DCNL DCSP elif (iterationCountInferOnly > 0): DCNL DCSP  DCSP assert (numIters > iterationCountInferOnly), 'when DCSP iterationCountInferOnly DCSP is DCSP specified, DCSP iterationCount DCSP must DCSP be DCSP greater DCSP than DCSP iterationCountInferOnly.' DCNL DCSP  DCSP learningOffAt = (numIters - iterationCountInferOnly) DCNL DCSP self.__runTaskMainLoop(numIters, learningOffAt=learningOffAt) DCNL DCSP self._finalize() DCNL DCSP return (self._cmpReason, None)
def __runTaskMainLoop(self, numIters, learningOffAt=None): DCNL DCSP self._model.resetSequenceStates() DCNL DCSP self._currentRecordIndex = (-1) DCNL DCSP while True: DCNL DCSP  DCSP if self._isKilled: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if self._isCanceled: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if self._isInterrupted.isSet(): DCNL DCSP  DCSP  DCSP self.__setAsOrphaned() DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if self._isMature: DCNL DCSP  DCSP  DCSP if (not self._isBestModel): DCNL DCSP  DCSP  DCSP  DCSP self._cmpReason = self._jobsDAO.CMPL_REASON_STOPPED DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self._cmpReason = self._jobsDAO.CMPL_REASON_EOF DCNL DCSP  DCSP  DCSP if ((learningOffAt is not None) and (self._currentRecordIndex == learningOffAt)): DCNL DCSP  DCSP  DCSP  DCSP self._model.disableLearning() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP inputRecord = self._inputSource.getNextRecordDict() DCNL DCSP  DCSP  DCSP if (self._currentRecordIndex < 0): DCNL DCSP  DCSP  DCSP  DCSP self._inputSource.setTimeout(10) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise utils.JobFailException(ErrorCodes.streamReading, str(e.args), traceback.format_exc()) DCNL DCSP  DCSP if (inputRecord is None): DCNL DCSP  DCSP  DCSP self._cmpReason = self._jobsDAO.CMPL_REASON_EOF DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if inputRecord: DCNL DCSP  DCSP  DCSP self._currentRecordIndex += 1 DCNL DCSP  DCSP  DCSP result = self._model.run(inputRecord=inputRecord) DCNL DCSP  DCSP  DCSP result.metrics = self.__metricMgr.update(result) DCNL DCSP  DCSP  DCSP if (not result.metrics): DCNL DCSP  DCSP  DCSP  DCSP result.metrics = self.__metricMgr.getMetrics() DCNL DCSP  DCSP  DCSP if (InferenceElement.encodings in result.inferences): DCNL DCSP  DCSP  DCSP  DCSP result.inferences.pop(InferenceElement.encodings) DCNL DCSP  DCSP  DCSP result.sensorInput.dataEncodings = None DCNL DCSP  DCSP  DCSP self._writePrediction(result) DCNL DCSP  DCSP  DCSP self._periodic.tick() DCNL DCSP  DCSP  DCSP if ((numIters >= 0) and (self._currentRecordIndex >= (numIters - 1))): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('Got DCSP an DCSP empty DCSP record DCSP from DCSP FileSource: DCSP %r' % inputRecord))
def _finalize(self): DCNL DCSP self._logger.info('Finished: DCSP modelID=%r; DCSP %r DCSP records DCSP processed. DCSP Performing DCSP final DCSP activities', self._modelID, (self._currentRecordIndex + 1)) DCNL DCSP self._updateModelDBResults() DCNL DCSP if (not self._isKilled): DCNL DCSP  DCSP self.__updateJobResults() DCNL DCSP else: DCNL DCSP  DCSP self.__deleteOutputCache(self._modelID) DCNL DCSP if self._predictionLogger: DCNL DCSP  DCSP self._predictionLogger.close()
def __createModelCheckpoint(self): DCNL DCSP if ((self._model is None) or (self._modelCheckpointGUID is None)): DCNL DCSP  DCSP return DCNL DCSP if (self._predictionLogger is None): DCNL DCSP  DCSP self._createPredictionLogger() DCNL DCSP predictions = StringIO.StringIO() DCNL DCSP self._predictionLogger.checkpoint(checkpointSink=predictions, maxRows=int(Configuration.get('nupic.model.checkpoint.maxPredictionRows'))) DCNL DCSP self._model.save(os.path.join(self._experimentDir, str(self._modelCheckpointGUID))) DCNL DCSP self._jobsDAO.modelSetFields(modelID, {'modelCheckpointId': str(self._modelCheckpointGUID)}, ignoreUnchanged=True) DCNL DCSP self._logger.info('Checkpointed DCSP Hypersearch DCSP Model: DCSP modelID: DCSP %r, DCSP checkpointID: DCSP %r', self._modelID, checkpointID) DCNL DCSP return
def __deleteModelCheckpoint(self, modelID): DCNL DCSP checkpointID = self._jobsDAO.modelsGetFields(modelID, ['modelCheckpointId'])[0] DCNL DCSP if (checkpointID is None): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP shutil.rmtree(os.path.join(self._experimentDir, str(self._modelCheckpointGUID))) DCNL DCSP except: DCNL DCSP  DCSP self._logger.warn('Failed DCSP to DCSP delete DCSP model DCSP checkpoint DCSP %s. DCSP Assuming DCSP that DCSP another DCSP worker DCSP has DCSP already DCSP deleted DCSP it', checkpointID) DCNL DCSP  DCSP return DCNL DCSP self._jobsDAO.modelSetFields(modelID, {'modelCheckpointId': None}, ignoreUnchanged=True) DCNL DCSP return
def _createPredictionLogger(self): DCNL DCSP self._predictionLogger = BasicPredictionLogger(fields=self._model.getFieldInfo(), experimentDir=self._experimentDir, label='hypersearch-worker', inferenceType=self._model.getInferenceType()) DCNL DCSP if self.__loggedMetricPatterns: DCNL DCSP  DCSP metricLabels = self.__metricMgr.getMetricLabels() DCNL DCSP  DCSP loggedMetrics = matchPatterns(self.__loggedMetricPatterns, metricLabels) DCNL DCSP  DCSP self._predictionLogger.setLoggedMetrics(loggedMetrics)
def __getOptimizedMetricLabel(self): DCNL DCSP matchingKeys = matchPatterns([self._optimizeKeyPattern], self._getMetricLabels()) DCNL DCSP if (len(matchingKeys) == 0): DCNL DCSP  DCSP raise Exception(('None DCSP of DCSP the DCSP generated DCSP metrics DCSP match DCSP the DCSP specified DCSP optimization DCSP pattern: DCSP %s. DCSP Available DCSP metrics DCSP are DCSP %s' % (self._optimizeKeyPattern, self._getMetricLabels()))) DCNL DCSP elif (len(matchingKeys) > 1): DCNL DCSP  DCSP raise Exception(("The DCSP specified DCSP optimization DCSP pattern DCSP '%s' DCSP matches DCSP more DCSP than DCSP one DCSP metric: DCSP %s" % (self._optimizeKeyPattern, matchingKeys))) DCNL DCSP return matchingKeys[0]
def _getMetricLabels(self): DCNL DCSP return self.__metricMgr.getMetricLabels()
def _getFieldStats(self): DCNL DCSP fieldStats = dict() DCNL DCSP fieldNames = self._inputSource.getFieldNames() DCNL DCSP for field in fieldNames: DCNL DCSP  DCSP curStats = dict() DCNL DCSP  DCSP curStats['min'] = self._inputSource.getFieldMin(field) DCNL DCSP  DCSP curStats['max'] = self._inputSource.getFieldMax(field) DCNL DCSP  DCSP fieldStats[field] = curStats DCNL DCSP return fieldStats
def _getMetrics(self): DCNL DCSP return self.__metricMgr.getMetrics()
def _updateModelDBResults(self): DCNL DCSP metrics = self._getMetrics() DCNL DCSP reportDict = dict([(k, metrics[k]) for k in self._reportMetricLabels]) DCNL DCSP metrics = self._getMetrics() DCNL DCSP optimizeDict = dict() DCNL DCSP if (self._optimizeKeyPattern is not None): DCNL DCSP  DCSP optimizeDict[self._optimizedMetricLabel] = metrics[self._optimizedMetricLabel] DCNL DCSP results = json.dumps((metrics, optimizeDict)) DCNL DCSP self._jobsDAO.modelUpdateResults(self._modelID, results=results, metricValue=optimizeDict.values()[0], numRecords=(self._currentRecordIndex + 1)) DCNL DCSP self._logger.debug(('Model DCSP Results: DCSP modelID=%s; DCSP numRecords=%s; DCSP results=%s' % (self._modelID, (self._currentRecordIndex + 1), results))) DCNL DCSP return
def __updateJobResultsPeriodic(self): DCNL DCSP if (self._isBestModelStored and (not self._isBestModel)): DCNL DCSP  DCSP return DCNL DCSP while True: DCNL DCSP  DCSP jobResultsStr = self._jobsDAO.jobGetFields(self._jobID, ['results'])[0] DCNL DCSP  DCSP if (jobResultsStr is None): DCNL DCSP  DCSP  DCSP jobResults = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._isBestModelStored = True DCNL DCSP  DCSP  DCSP if (not self._isBestModel): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP  DCSP bestModel = jobResults.get('bestModel', None) DCNL DCSP  DCSP bestMetric = jobResults.get('bestValue', None) DCNL DCSP  DCSP isSaved = jobResults.get('saved', False) DCNL DCSP  DCSP if ((bestModel is not None) and (self._modelID != bestModel)): DCNL DCSP  DCSP  DCSP self._isBestModel = False DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP self.__flushPredictionCache() DCNL DCSP  DCSP self._jobsDAO.modelUpdateTimestamp(self._modelID) DCNL DCSP  DCSP metrics = self._getMetrics() DCNL DCSP  DCSP jobResults['bestModel'] = self._modelID DCNL DCSP  DCSP jobResults['bestValue'] = metrics[self._optimizedMetricLabel] DCNL DCSP  DCSP jobResults['metrics'] = metrics DCNL DCSP  DCSP jobResults['saved'] = False DCNL DCSP  DCSP newResults = json.dumps(jobResults) DCNL DCSP  DCSP isUpdated = self._jobsDAO.jobSetFieldIfEqual(self._jobID, fieldName='results', curValue=jobResultsStr, newValue=newResults) DCNL DCSP  DCSP if (isUpdated or ((not isUpdated) and (newResults == jobResultsStr))): DCNL DCSP  DCSP  DCSP self._isBestModel = True DCNL DCSP  DCSP  DCSP break
def __checkIfBestCompletedModel(self): DCNL DCSP jobResultsStr = self._jobsDAO.jobGetFields(self._jobID, ['results'])[0] DCNL DCSP if (jobResultsStr is None): DCNL DCSP  DCSP jobResults = {} DCNL DCSP else: DCNL DCSP  DCSP jobResults = json.loads(jobResultsStr) DCNL DCSP isSaved = jobResults.get('saved', False) DCNL DCSP bestMetric = jobResults.get('bestValue', None) DCNL DCSP currentMetric = self._getMetrics()[self._optimizedMetricLabel] DCNL DCSP self._isBestModel = ((not isSaved) or (currentMetric < bestMetric)) DCNL DCSP return (self._isBestModel, jobResults, jobResultsStr)
def __updateJobResults(self): DCNL DCSP isSaved = False DCNL DCSP while True: DCNL DCSP  DCSP (self._isBestModel, jobResults, jobResultsStr) = self.__checkIfBestCompletedModel() DCNL DCSP  DCSP if self._isBestModel: DCNL DCSP  DCSP  DCSP if (not isSaved): DCNL DCSP  DCSP  DCSP  DCSP self.__flushPredictionCache() DCNL DCSP  DCSP  DCSP  DCSP self._jobsDAO.modelUpdateTimestamp(self._modelID) DCNL DCSP  DCSP  DCSP  DCSP self.__createModelCheckpoint() DCNL DCSP  DCSP  DCSP  DCSP self._jobsDAO.modelUpdateTimestamp(self._modelID) DCNL DCSP  DCSP  DCSP  DCSP isSaved = True DCNL DCSP  DCSP  DCSP prevBest = jobResults.get('bestModel', None) DCNL DCSP  DCSP  DCSP prevWasSaved = jobResults.get('saved', False) DCNL DCSP  DCSP  DCSP if (prevBest == self._modelID): DCNL DCSP  DCSP  DCSP  DCSP assert (not prevWasSaved) DCNL DCSP  DCSP  DCSP metrics = self._getMetrics() DCNL DCSP  DCSP  DCSP jobResults['bestModel'] = self._modelID DCNL DCSP  DCSP  DCSP jobResults['bestValue'] = metrics[self._optimizedMetricLabel] DCNL DCSP  DCSP  DCSP jobResults['metrics'] = metrics DCNL DCSP  DCSP  DCSP jobResults['saved'] = True DCNL DCSP  DCSP  DCSP isUpdated = self._jobsDAO.jobSetFieldIfEqual(self._jobID, fieldName='results', curValue=jobResultsStr, newValue=json.dumps(jobResults)) DCNL DCSP  DCSP  DCSP if isUpdated: DCNL DCSP  DCSP  DCSP  DCSP if prevWasSaved: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.__deleteOutputCache(prevBest) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._jobsDAO.modelUpdateTimestamp(self._modelID) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.__deleteModelCheckpoint(prevBest) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._jobsDAO.modelUpdateTimestamp(self._modelID) DCNL DCSP  DCSP  DCSP  DCSP self._logger.info('Model DCSP %d DCSP chosen DCSP as DCSP best DCSP model', self._modelID) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.__deleteOutputCache(self._modelID) DCNL DCSP  DCSP  DCSP self._jobsDAO.modelUpdateTimestamp(self._modelID) DCNL DCSP  DCSP  DCSP self.__deleteModelCheckpoint(self._modelID) DCNL DCSP  DCSP  DCSP self._jobsDAO.modelUpdateTimestamp(self._modelID) DCNL DCSP  DCSP  DCSP break
def _writePrediction(self, result): DCNL DCSP self.__predictionCache.append(result) DCNL DCSP if self._isBestModel: DCNL DCSP  DCSP self.__flushPredictionCache()
def __writeRecordsCallback(self): DCNL DCSP self._jobsDAO.modelUpdateResults(self._modelID)
def __flushPredictionCache(self): DCNL DCSP if (not self.__predictionCache): DCNL DCSP  DCSP return DCNL DCSP if (self._predictionLogger is None): DCNL DCSP  DCSP self._createPredictionLogger() DCNL DCSP startTime = time.time() DCNL DCSP self._predictionLogger.writeRecords(self.__predictionCache, progressCB=self.__writeRecordsCallback) DCNL DCSP self._logger.info('Flushed DCSP prediction DCSP cache; DCSP numrows=%s; DCSP elapsed=%s DCSP sec.', len(self.__predictionCache), (time.time() - startTime)) DCNL DCSP self.__predictionCache.clear()
def __deleteOutputCache(self, modelID): DCNL DCSP if ((modelID == self._modelID) and (self._predictionLogger is not None)): DCNL DCSP  DCSP self._predictionLogger.close() DCNL DCSP  DCSP del self.__predictionCache DCNL DCSP  DCSP self._predictionLogger = None DCNL DCSP  DCSP self.__predictionCache = None
def _initPeriodicActivities(self): DCNL DCSP updateModelDBResults = PeriodicActivityRequest(repeating=True, period=100, cb=self._updateModelDBResults) DCNL DCSP updateJobResults = PeriodicActivityRequest(repeating=True, period=100, cb=self.__updateJobResultsPeriodic) DCNL DCSP checkCancelation = PeriodicActivityRequest(repeating=True, period=50, cb=self.__checkCancelation) DCNL DCSP checkMaturity = PeriodicActivityRequest(repeating=True, period=10, cb=self.__checkMaturity) DCNL DCSP updateJobResultsFirst = PeriodicActivityRequest(repeating=False, period=2, cb=self.__updateJobResultsPeriodic) DCNL DCSP periodicActivities = [updateModelDBResults, updateJobResultsFirst, updateJobResults, checkCancelation] DCNL DCSP if self._isMaturityEnabled: DCNL DCSP  DCSP periodicActivities.append(checkMaturity) DCNL DCSP return PeriodicActivityMgr(requestedActivities=periodicActivities)
def __checkCancelation(self): DCNL DCSP print >>sys.stderr, 'reporter:counter:HypersearchWorker,numRecords,50' DCNL DCSP jobCancel = self._jobsDAO.jobGetFields(self._jobID, ['cancel'])[0] DCNL DCSP if jobCancel: DCNL DCSP  DCSP self._cmpReason = ClientJobsDAO.CMPL_REASON_KILLED DCNL DCSP  DCSP self._isCanceled = True DCNL DCSP  DCSP self._logger.info('Model DCSP %s DCSP canceled DCSP because DCSP Job DCSP %s DCSP was DCSP stopped.', self._modelID, self._jobID) DCNL DCSP else: DCNL DCSP  DCSP stopReason = self._jobsDAO.modelsGetFields(self._modelID, ['engStop'])[0] DCNL DCSP  DCSP if (stopReason is None): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (stopReason == ClientJobsDAO.STOP_REASON_KILLED): DCNL DCSP  DCSP  DCSP self._cmpReason = ClientJobsDAO.CMPL_REASON_KILLED DCNL DCSP  DCSP  DCSP self._isKilled = True DCNL DCSP  DCSP  DCSP self._logger.info('Model DCSP %s DCSP canceled DCSP because DCSP it DCSP was DCSP killed DCSP by DCSP hypersearch', self._modelID) DCNL DCSP  DCSP elif (stopReason == ClientJobsDAO.STOP_REASON_STOPPED): DCNL DCSP  DCSP  DCSP self._cmpReason = ClientJobsDAO.CMPL_REASON_STOPPED DCNL DCSP  DCSP  DCSP self._isCanceled = True DCNL DCSP  DCSP  DCSP self._logger.info('Model DCSP %s DCSP stopped DCSP because DCSP hypersearch DCSP ended', self._modelID) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError(('Unexpected DCSP stop DCSP reason DCSP encountered: DCSP %s' % stopReason))
def __checkMaturity(self): DCNL DCSP if ((self._currentRecordIndex + 1) < self._MIN_RECORDS_TO_BE_BEST): DCNL DCSP  DCSP return DCNL DCSP if self._isMature: DCNL DCSP  DCSP return DCNL DCSP metric = self._getMetrics()[self._optimizedMetricLabel] DCNL DCSP self._metricRegression.addPoint(x=self._currentRecordIndex, y=metric) DCNL DCSP (pctChange, absPctChange) = self._metricRegression.getPctChanges() DCNL DCSP if ((pctChange is not None) and (absPctChange <= self._MATURITY_MAX_CHANGE)): DCNL DCSP  DCSP self._jobsDAO.modelSetFields(self._modelID, {'engMatured': True}) DCNL DCSP  DCSP self._cmpReason = ClientJobsDAO.CMPL_REASON_STOPPED DCNL DCSP  DCSP self._isMature = True DCNL DCSP  DCSP self._logger.info('Model DCSP %d DCSP has DCSP matured DCSP (pctChange=%s, DCSP n=%d). DCSP \nScores DCSP = DCSP %s\nStopping DCSP execution', self._modelID, pctChange, self._MATURITY_NUM_POINTS, self._metricRegression._window)
def handleWarningSignal(self, signum, frame): DCNL DCSP self._isInterrupted.set()
def __setAsOrphaned(self): DCNL DCSP cmplReason = ClientJobsDAO.CMPL_REASON_ORPHAN DCNL DCSP cmplMessage = 'Killed DCSP by DCSP Scheduler' DCNL DCSP self._jobsDAO.modelSetCompleted(self._modelID, cmplReason, cmplMessage)
def GET(self): DCNL DCSP global g_models DCNL DCSP return json.dumps({'models': g_models.keys()})
def POST(self, name): DCNL DCSP global g_models DCNL DCSP data = json.loads(web.data()) DCNL DCSP modelParams = data['modelParams'] DCNL DCSP predictedFieldName = data['predictedFieldName'] DCNL DCSP if (name in g_models.keys()): DCNL DCSP  DCSP raise web.badrequest(('Model DCSP with DCSP name DCSP <%s> DCSP already DCSP exists' % name)) DCNL DCSP model = ModelFactory.create(modelParams) DCNL DCSP model.enableInference({'predictedField': predictedFieldName}) DCNL DCSP g_models[name] = model DCNL DCSP return json.dumps({'success': name})
def POST(self, name): DCNL DCSP global g_models DCNL DCSP data = json.loads(web.data()) DCNL DCSP data['timestamp'] = datetime.datetime.strptime(data['timestamp'], '%m/%d/%y DCSP %H:%M') DCNL DCSP if (name not in g_models.keys()): DCNL DCSP  DCSP raise web.notfound(('Model DCSP with DCSP name DCSP <%s> DCSP does DCSP not DCSP exist.' % name)) DCNL DCSP modelResult = g_models[name].run(data) DCNL DCSP predictionNumber = modelResult.predictionNumber DCNL DCSP anomalyScore = modelResult.inferences['anomalyScore'] DCNL DCSP return json.dumps({'predictionNumber': predictionNumber, 'anomalyScore': anomalyScore})
def export(self): DCNL DCSP graph = nx.MultiDiGraph() DCNL DCSP regions = self.network.getRegions() DCNL DCSP for idx in xrange(regions.getCount()): DCNL DCSP  DCSP regionPair = regions.getByIndex(idx) DCNL DCSP  DCSP regionName = regionPair[0] DCNL DCSP  DCSP graph.add_node(regionName, label=regionName) DCNL DCSP for (linkName, link) in self.network.getLinks(): DCNL DCSP  DCSP graph.add_edge(link.getSrcRegionName(), link.getDestRegionName(), src=link.getSrcOutputName(), dest=link.getDestInputName()) DCNL DCSP return graph
def render(self, renderer=DEFAULT_RENDERER): DCNL DCSP renderer().render(self.export())
def __init__(self, filePath): DCNL DCSP self.__filePath = filePath DCNL DCSP return
def __init__(self, filePath): DCNL DCSP self.__filePath = filePath DCNL DCSP return
def finishLearning(self): DCNL DCSP pass
def setFieldStatistics(self, fieldStats): DCNL DCSP pass
def write(self, proto): DCNL DCSP super(PreviousValueModel, self).writeBaseToProto(proto.modelBase) DCNL DCSP proto.fieldNames = self._fieldNames DCNL DCSP proto.fieldTypes = self._fieldTypes DCNL DCSP proto.predictedField = self._predictedField DCNL DCSP proto.predictionSteps = self._predictionSteps
@classmethod DCNL def read(cls, proto): DCNL DCSP instance = object.__new__(cls) DCNL DCSP super(PreviousValueModel, instance).__init__(proto=proto.modelBase) DCNL DCSP instance._logger = opf_utils.initLogger(instance) DCNL DCSP instance._predictedField = proto.predictedField DCNL DCSP instance._fieldNames = list(proto.fieldNames) DCNL DCSP instance._fieldTypes = list(proto.fieldTypes) DCNL DCSP instance._predictionSteps = list(proto.predictionSteps) DCNL DCSP return instance
@classmethod DCNL def __getLogger(cls): DCNL DCSP if (cls.__logger is None): DCNL DCSP  DCSP cls.__logger = opf_utils.initLogger(cls) DCNL DCSP return cls.__logger
@staticmethod DCNL def create(modelConfig, logLevel=logging.ERROR): DCNL DCSP logger = ModelFactory.__getLogger() DCNL DCSP logger.setLevel(logLevel) DCNL DCSP logger.debug('ModelFactory DCSP returning DCSP Model DCSP from DCSP dict: DCSP %s', modelConfig) DCNL DCSP modelClass = None DCNL DCSP if (modelConfig['model'] == 'HTMPrediction'): DCNL DCSP  DCSP modelClass = HTMPredictionModel DCNL DCSP elif (modelConfig['model'] == 'TwoGram'): DCNL DCSP  DCSP modelClass = TwoGramModel DCNL DCSP elif (modelConfig['model'] == 'PreviousValue'): DCNL DCSP  DCSP modelClass = PreviousValueModel DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('ModelFactory DCSP received DCSP unsupported DCSP Model DCSP type: DCSP %s' % modelConfig['model'])) DCNL DCSP return modelClass(**modelConfig['modelParams'])
@staticmethod DCNL def loadFromCheckpoint(savedModelDir, newSerialization=False): DCNL DCSP if newSerialization: DCNL DCSP  DCSP return HTMPredictionModel.readFromCheckpoint(savedModelDir) DCNL DCSP else: DCNL DCSP  DCSP return Model.load(savedModelDir)
def update(self, results): DCNL DCSP self._addResults(results) DCNL DCSP if ((not self.__metricSpecs) or (self.__currentInference is None)): DCNL DCSP  DCSP return {} DCNL DCSP metricResults = {} DCNL DCSP for (metric, spec, label) in zip(self.__metrics, self.__metricSpecs, self.__metricLabels): DCNL DCSP  DCSP inferenceElement = spec.inferenceElement DCNL DCSP  DCSP field = spec.field DCNL DCSP  DCSP groundTruth = self._getGroundTruth(inferenceElement) DCNL DCSP  DCSP inference = self._getInference(inferenceElement) DCNL DCSP  DCSP rawRecord = self._getRawGroundTruth() DCNL DCSP  DCSP result = self.__currentResult DCNL DCSP  DCSP if field: DCNL DCSP  DCSP  DCSP if (type(inference) in (list, tuple)): DCNL DCSP  DCSP  DCSP  DCSP if (field in self.__fieldNameIndexMap): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fieldIndex = self.__fieldNameIndexMap[field] DCNL DCSP  DCSP  DCSP  DCSP  DCSP inference = inference[fieldIndex] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP inference = None DCNL DCSP  DCSP  DCSP if (groundTruth is not None): DCNL DCSP  DCSP  DCSP  DCSP if (type(groundTruth) in (list, tuple)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (field in self.__fieldNameIndexMap): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fieldIndex = self.__fieldNameIndexMap[field] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP groundTruth = groundTruth[fieldIndex] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP groundTruth = None DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP groundTruth = groundTruth[field] DCNL DCSP  DCSP metric.addInstance(groundTruth=groundTruth, prediction=inference, record=rawRecord, result=result) DCNL DCSP  DCSP metricResults[label] = metric.getMetric()['value'] DCNL DCSP return metricResults
def getMetrics(self): DCNL DCSP result = {} DCNL DCSP for (metricObj, label) in zip(self.__metrics, self.__metricLabels): DCNL DCSP  DCSP value = metricObj.getMetric() DCNL DCSP  DCSP result[label] = value['value'] DCNL DCSP return result
def getMetricDetails(self, metricLabel): DCNL DCSP try: DCNL DCSP  DCSP metricIndex = self.__metricLabels.index(metricLabel) DCNL DCSP except IndexError: DCNL DCSP  DCSP return None DCNL DCSP return self.__metrics[metricIndex].getMetric()
def getMetricLabels(self): DCNL DCSP return tuple(self.__metricLabels)
def _addResults(self, results): DCNL DCSP if self.__isTemporal: DCNL DCSP  DCSP shiftedInferences = self.__inferenceShifter.shift(results).inferences DCNL DCSP  DCSP self.__currentResult = copy.deepcopy(results) DCNL DCSP  DCSP self.__currentResult.inferences = shiftedInferences DCNL DCSP  DCSP self.__currentInference = shiftedInferences DCNL DCSP else: DCNL DCSP  DCSP self.__currentResult = copy.deepcopy(results) DCNL DCSP  DCSP self.__currentInference = copy.deepcopy(results.inferences) DCNL DCSP self.__currentGroundTruth = copy.deepcopy(results)
def _getGroundTruth(self, inferenceElement): DCNL DCSP sensorInputElement = InferenceElement.getInputElement(inferenceElement) DCNL DCSP if (sensorInputElement is None): DCNL DCSP  DCSP return None DCNL DCSP return getattr(self.__currentGroundTruth.sensorInput, sensorInputElement)
def _getInference(self, inferenceElement): DCNL DCSP if (self.__currentInference is not None): DCNL DCSP  DCSP return self.__currentInference.get(inferenceElement, None) DCNL DCSP return None
def _getRawGroundTruth(self): DCNL DCSP return self.__currentGroundTruth.rawInput
def __constructMetricsModules(self, metricSpecs): DCNL DCSP if (not metricSpecs): DCNL DCSP  DCSP return DCNL DCSP self.__metricSpecs = metricSpecs DCNL DCSP for spec in metricSpecs: DCNL DCSP  DCSP if (not InferenceElement.validate(spec.inferenceElement)): DCNL DCSP  DCSP  DCSP raise ValueError(('Invalid DCSP inference DCSP element DCSP for DCSP metric DCSP spec: DCSP %r' % spec)) DCNL DCSP  DCSP self.__metrics.append(metrics.getModule(spec)) DCNL DCSP  DCSP self.__metricLabels.append(spec.getLabel())
def getLabel(self, inferenceType=None): DCNL DCSP result = [] DCNL DCSP if (inferenceType is not None): DCNL DCSP  DCSP result.append(InferenceType.getLabel(inferenceType)) DCNL DCSP result.append(self.inferenceElement) DCNL DCSP result.append(self.metric) DCNL DCSP params = self.params DCNL DCSP if (params is not None): DCNL DCSP  DCSP sortedParams = params.keys() DCNL DCSP  DCSP sortedParams.sort() DCNL DCSP  DCSP for param in sortedParams: DCNL DCSP  DCSP  DCSP if (param in ('customFuncSource', 'customFuncDef', 'customExpr')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP value = params[param] DCNL DCSP  DCSP  DCSP if isinstance(value, str): DCNL DCSP  DCSP  DCSP  DCSP result.extend([("%s='%s'" % (param, value))]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result.extend([('%s=%s' % (param, value))]) DCNL DCSP if self.field: DCNL DCSP  DCSP result.append(('field=%s' % self.field)) DCNL DCSP return self._LABEL_SEPARATOR.join(result)
@classmethod DCNL def getInferenceTypeFromLabel(cls, label): DCNL DCSP (infType, _, _) = label.partition(cls._LABEL_SEPARATOR) DCNL DCSP if (not InferenceType.validate(infType)): DCNL DCSP  DCSP return None DCNL DCSP return infType
def __init__(self, windowSize=None): DCNL DCSP self._windowSize = windowSize DCNL DCSP self._countDict = dict() DCNL DCSP self._history = deque([])
def __init__(self, metricSpec): DCNL DCSP self.id = None DCNL DCSP self.verbosity = 0 DCNL DCSP self.window = (-1) DCNL DCSP self.history = None DCNL DCSP self.accumulatedError = 0 DCNL DCSP self.aggregateError = None DCNL DCSP self.steps = 0 DCNL DCSP self.spec = metricSpec DCNL DCSP self.disabled = False DCNL DCSP self._predictionSteps = [0] DCNL DCSP self._groundTruthHistory = deque([]) DCNL DCSP self._subErrorMetrics = None DCNL DCSP self._maxRecords = None DCNL DCSP if ((metricSpec is not None) and (metricSpec.params is not None)): DCNL DCSP  DCSP self.id = metricSpec.params.get('id', None) DCNL DCSP  DCSP self._predictionSteps = metricSpec.params.get('steps', [0]) DCNL DCSP  DCSP if (not hasattr(self._predictionSteps, '__iter__')): DCNL DCSP  DCSP  DCSP self._predictionSteps = [self._predictionSteps] DCNL DCSP  DCSP self.verbosity = metricSpec.params.get('verbosity', 0) DCNL DCSP  DCSP self._maxRecords = metricSpec.params.get('maxRecords', None) DCNL DCSP  DCSP if ('window' in metricSpec.params): DCNL DCSP  DCSP  DCSP assert (metricSpec.params['window'] >= 1) DCNL DCSP  DCSP  DCSP self.history = deque([]) DCNL DCSP  DCSP  DCSP self.window = metricSpec.params['window'] DCNL DCSP  DCSP if ('errorMetric' in metricSpec.params): DCNL DCSP  DCSP  DCSP self._subErrorMetrics = [] DCNL DCSP  DCSP  DCSP for step in self._predictionSteps: DCNL DCSP  DCSP  DCSP  DCSP subSpec = copy.deepcopy(metricSpec) DCNL DCSP  DCSP  DCSP  DCSP subSpec.params.pop('steps', None) DCNL DCSP  DCSP  DCSP  DCSP subSpec.params.pop('errorMetric') DCNL DCSP  DCSP  DCSP  DCSP subSpec.metric = metricSpec.params['errorMetric'] DCNL DCSP  DCSP  DCSP  DCSP self._subErrorMetrics.append(getModule(subSpec))
def _getShiftedGroundTruth(self, groundTruth): DCNL DCSP self._groundTruthHistory.append(groundTruth) DCNL DCSP assert (len(self._predictionSteps) == 1) DCNL DCSP if (len(self._groundTruthHistory) > self._predictionSteps[0]): DCNL DCSP  DCSP return self._groundTruthHistory.popleft() DCNL DCSP elif hasattr(groundTruth, '__iter__'): DCNL DCSP  DCSP return ([None] * len(groundTruth)) DCNL DCSP else: DCNL DCSP  DCSP return None
def addInstance(self, groundTruth, prediction, record=None, result=None): DCNL DCSP self.value = self.avg(prediction)
def getMetric(self): DCNL DCSP return {'value': self.value}
def mostLikely(self, pred): DCNL DCSP if (len(pred) == 1): DCNL DCSP  DCSP return pred.keys()[0] DCNL DCSP mostLikelyOutcome = None DCNL DCSP maxProbability = 0 DCNL DCSP for (prediction, probability) in pred.items(): DCNL DCSP  DCSP if (probability > maxProbability): DCNL DCSP  DCSP  DCSP mostLikelyOutcome = prediction DCNL DCSP  DCSP  DCSP maxProbability = probability DCNL DCSP return mostLikelyOutcome
def expValue(self, pred): DCNL DCSP if (len(pred) == 1): DCNL DCSP  DCSP return pred.keys()[0] DCNL DCSP return sum([(x * p) for (x, p) in pred.items()])
def accumulate(self, groundTruth, prediction, accumulatedError, historyBuffer, result=None): DCNL DCSP if self.disabled: DCNL DCSP  DCSP return 0 DCNL DCSP if (historyBuffer is not None): DCNL DCSP  DCSP historyBuffer.append((groundTruth, prediction[0])) DCNL DCSP  DCSP if (len(historyBuffer) > self.spec.params['window']): DCNL DCSP  DCSP  DCSP historyBuffer.popleft() DCNL DCSP return 0
def __init__(self, metricSpec): DCNL DCSP raise ValueError('MetricMulti DCSP cannot DCSP be DCSP constructed DCSP from DCSP metricSpec DCSP string! DCSP Use DCSP MetricMulti(weights,metrics) DCSP constructor DCSP instead.')
def __init__(self, weights, metrics, window=None): DCNL DCSP if ((weights is None) or (not isinstance(weights, list)) or (not (len(weights) > 0)) or (not isinstance(weights[0], float))): DCNL DCSP  DCSP raise ValueError("MetricMulti DCSP requires DCSP 'weights' DCSP parameter DCSP as DCSP a DCSP [list DCSP of DCSP floats]") DCNL DCSP self.weights = weights DCNL DCSP if ((metrics is None) or (not isinstance(metrics, list)) or (not (len(metrics) > 0)) or (not isinstance(metrics[0], MetricsIface))): DCNL DCSP  DCSP raise ValueError("MetricMulti DCSP requires DCSP 'metrics' DCSP parameter DCSP as DCSP a DCSP [list DCSP of DCSP Metrics]") DCNL DCSP self.metrics = metrics DCNL DCSP if (window is not None): DCNL DCSP  DCSP self.movingAvg = MovingAverage(windowSize=window) DCNL DCSP else: DCNL DCSP  DCSP self.movingAvg = None
def __init__(self, model, task, cmdOptions): DCNL DCSP validateOpfJsonValue(task, 'opfTaskSchema.json') DCNL DCSP self.__logger = logging.getLogger('.'.join(['com.numenta', self.__class__.__module__, self.__class__.__name__])) DCNL DCSP self.__logger.debug((((('Instantiated DCSP %s(' + 'model=%r, DCSP ') + 'task=%r, DCSP ') + 'cmdOptions=%r)') % (self.__class__.__name__, model, task, cmdOptions))) DCNL DCSP streamDef = task['dataset'] DCNL DCSP datasetReader = opf_basic_environment.BasicDatasetReader(streamDef) DCNL DCSP self.__model = model DCNL DCSP self.__datasetReader = datasetReader DCNL DCSP self.__task = task DCNL DCSP self.__cmdOptions = cmdOptions DCNL DCSP self.__predictionLogger = opf_basic_environment.BasicPredictionLogger(fields=model.getFieldInfo(), experimentDir=cmdOptions.experimentDir, label=task['taskLabel'], inferenceType=self.__model.getInferenceType()) DCNL DCSP taskControl = task['taskControl'] DCNL DCSP self.__taskDriver = OPFTaskDriver(taskControl=taskControl, model=model) DCNL DCSP loggedMetricPatterns = taskControl.get('loggedMetrics', None) DCNL DCSP loggedMetricLabels = matchPatterns(loggedMetricPatterns, self.__taskDriver.getMetricLabels()) DCNL DCSP self.__predictionLogger.setLoggedMetrics(loggedMetricLabels) DCNL DCSP self.__metricsLogger = opf_basic_environment.BasicPredictionMetricsLogger(experimentDir=cmdOptions.experimentDir, label=task['taskLabel'])
def run(self): DCNL DCSP self.__logger.debug('run(): DCSP Starting DCSP task DCSP <%s>', self.__task['taskLabel']) DCNL DCSP if self.__cmdOptions.privateOptions['testMode']: DCNL DCSP  DCSP numIters = 10 DCNL DCSP else: DCNL DCSP  DCSP numIters = self.__task['iterationCount'] DCNL DCSP if (numIters >= 0): DCNL DCSP  DCSP iterTracker = iter(xrange(numIters)) DCNL DCSP else: DCNL DCSP  DCSP iterTracker = iter(itertools.count()) DCNL DCSP periodic = PeriodicActivityMgr(requestedActivities=self._createPeriodicActivities()) DCNL DCSP self.__model.resetSequenceStates() DCNL DCSP self.__taskDriver.setup() DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP next(iterTracker) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP inputRecord = self.__datasetReader.next() DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP result = self.__taskDriver.handleInputRecord(inputRecord=inputRecord) DCNL DCSP  DCSP if (InferenceElement.encodings in result.inferences): DCNL DCSP  DCSP  DCSP result.inferences.pop(InferenceElement.encodings) DCNL DCSP  DCSP self.__predictionLogger.writeRecord(result) DCNL DCSP  DCSP periodic.tick() DCNL DCSP self._getAndEmitExperimentMetrics(final=True) DCNL DCSP self.__taskDriver.finalize() DCNL DCSP self.__model.resetSequenceStates()
def _createPeriodicActivities(self): DCNL DCSP periodicActivities = [] DCNL DCSP class MetricsReportCb(object, ): DCNL DCSP  DCSP def __init__(self, taskRunner): DCNL DCSP  DCSP  DCSP self.__taskRunner = taskRunner DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP def __call__(self): DCNL DCSP  DCSP  DCSP self.__taskRunner._getAndEmitExperimentMetrics() DCNL DCSP reportMetrics = PeriodicActivityRequest(repeating=True, period=1000, cb=MetricsReportCb(self)) DCNL DCSP periodicActivities.append(reportMetrics) DCNL DCSP class IterationProgressCb(object, ): DCNL DCSP  DCSP PROGRESS_UPDATE_PERIOD_TICKS = 1000 DCNL DCSP  DCSP def __init__(self, taskLabel, requestedIterationCount, logger): DCNL DCSP  DCSP  DCSP self.__taskLabel = taskLabel DCNL DCSP  DCSP  DCSP self.__requestedIterationCount = requestedIterationCount DCNL DCSP  DCSP  DCSP self.__logger = logger DCNL DCSP  DCSP  DCSP self.__numIterationsSoFar = 0 DCNL DCSP  DCSP def __call__(self): DCNL DCSP  DCSP  DCSP self.__numIterationsSoFar += self.PROGRESS_UPDATE_PERIOD_TICKS DCNL DCSP  DCSP  DCSP self.__logger.debug(('%s: DCSP ITERATION DCSP PROGRESS: DCSP %s DCSP of DCSP %s' % (self.__taskLabel, self.__numIterationsSoFar, self.__requestedIterationCount))) DCNL DCSP iterationProgressCb = IterationProgressCb(taskLabel=self.__task['taskLabel'], requestedIterationCount=self.__task['iterationCount'], logger=self.__logger) DCNL DCSP iterationProgressReporter = PeriodicActivityRequest(repeating=True, period=IterationProgressCb.PROGRESS_UPDATE_PERIOD_TICKS, cb=iterationProgressCb) DCNL DCSP periodicActivities.append(iterationProgressReporter) DCNL DCSP return periodicActivities
def __init__(self, requestedActivities): DCNL DCSP self.__activities = [] DCNL DCSP for req in requestedActivities: DCNL DCSP  DCSP act = self.Activity(repeating=req.repeating, period=req.period, cb=req.cb, iteratorHolder=[iter(xrange((req.period - 1)))]) DCNL DCSP  DCSP self.__activities.append(act)
def tick(self): DCNL DCSP for act in self.__activities: DCNL DCSP  DCSP if (not act.iteratorHolder[0]): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP next(act.iteratorHolder[0]) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP act.cb() DCNL DCSP  DCSP  DCSP if act.repeating: DCNL DCSP  DCSP  DCSP  DCSP act.iteratorHolder[0] = iter(xrange((act.period - 1))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP act.iteratorHolder[0] = None DCNL DCSP return True
def _translateMetricsToJSON(self, metrics, label): DCNL DCSP metricsDict = metrics DCNL DCSP def _mapNumpyValues(obj): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP import numpy DCNL DCSP  DCSP if isinstance(obj, numpy.float32): DCNL DCSP  DCSP  DCSP return float(obj) DCNL DCSP  DCSP elif isinstance(obj, numpy.bool_): DCNL DCSP  DCSP  DCSP return bool(obj) DCNL DCSP  DCSP elif isinstance(obj, numpy.ndarray): DCNL DCSP  DCSP  DCSP return obj.tolist() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(('UNEXPECTED DCSP OBJ: DCSP %s; DCSP class=%s' % (obj, obj.__class__))) DCNL DCSP jsonString = json.dumps(metricsDict, indent=4, default=_mapNumpyValues) DCNL DCSP return jsonString
def __init__(self, experimentDir, label, inferenceType, fields, metricNames=None, checkpointSource=None): DCNL DCSP self.__experimentDir = experimentDir DCNL DCSP self.__inferenceType = inferenceType DCNL DCSP self.__inputFieldsMeta = tuple(copy.deepcopy(fields)) DCNL DCSP self.__numInputFields = len(self.__inputFieldsMeta) DCNL DCSP self.__label = label DCNL DCSP if (metricNames is not None): DCNL DCSP  DCSP metricNames.sort() DCNL DCSP self.__metricNames = metricNames DCNL DCSP self.__outputFieldsMeta = [] DCNL DCSP self._rawInputNames = [] DCNL DCSP self.__datasetPath = None DCNL DCSP self.__dataset = None DCNL DCSP self.__checkpointCache = None DCNL DCSP if (checkpointSource is not None): DCNL DCSP  DCSP checkpointSource.seek(0) DCNL DCSP  DCSP self.__checkpointCache = StringIO.StringIO() DCNL DCSP  DCSP shutil.copyfileobj(checkpointSource, self.__checkpointCache) DCNL DCSP return
def __openDatafile(self, modelResult): DCNL DCSP resetFieldMeta = FieldMetaInfo(name='reset', type=FieldMetaType.integer, special=FieldMetaSpecial.reset) DCNL DCSP self.__outputFieldsMeta.append(resetFieldMeta) DCNL DCSP rawInput = modelResult.rawInput DCNL DCSP rawFields = rawInput.keys() DCNL DCSP rawFields.sort() DCNL DCSP for field in rawFields: DCNL DCSP  DCSP if (field.startswith('_') or (field == 'reset')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = rawInput[field] DCNL DCSP  DCSP meta = FieldMetaInfo(name=field, type=FieldMetaType.string, special=FieldMetaSpecial.none) DCNL DCSP  DCSP self.__outputFieldsMeta.append(meta) DCNL DCSP  DCSP self._rawInputNames.append(field) DCNL DCSP for (inferenceElement, value) in modelResult.inferences.iteritems(): DCNL DCSP  DCSP inferenceLabel = InferenceElement.getLabel(inferenceElement) DCNL DCSP  DCSP if (type(value) in (list, tuple)): DCNL DCSP  DCSP  DCSP self.__outputFieldsMeta.extend(self.__getListMetaInfo(inferenceElement)) DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP self.__outputFieldsMeta.extend(self.__getDictMetaInfo(inferenceElement, value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if InferenceElement.getInputElement(inferenceElement): DCNL DCSP  DCSP  DCSP  DCSP self.__outputFieldsMeta.append(FieldMetaInfo(name=(inferenceLabel + '.actual'), type=FieldMetaType.string, special='')) DCNL DCSP  DCSP  DCSP self.__outputFieldsMeta.append(FieldMetaInfo(name=inferenceLabel, type=FieldMetaType.string, special='')) DCNL DCSP if self.__metricNames: DCNL DCSP  DCSP for metricName in self.__metricNames: DCNL DCSP  DCSP  DCSP metricField = FieldMetaInfo(name=metricName, type=FieldMetaType.float, special=FieldMetaSpecial.none) DCNL DCSP  DCSP  DCSP self.__outputFieldsMeta.append(metricField) DCNL DCSP inferenceDir = _FileUtils.createExperimentInferenceDir(self.__experimentDir) DCNL DCSP filename = (((self.__label + '.') + opf_utils.InferenceType.getLabel(self.__inferenceType)) + '.predictionLog.csv') DCNL DCSP self.__datasetPath = os.path.join(inferenceDir, filename) DCNL DCSP print ('OPENING DCSP OUTPUT DCSP FOR DCSP PREDICTION DCSP WRITER DCSP AT: DCSP %r' % self.__datasetPath) DCNL DCSP print ('Prediction DCSP field-meta: DCSP %r' % ([tuple(i) for i in self.__outputFieldsMeta],)) DCNL DCSP self.__dataset = FileRecordStream(streamID=self.__datasetPath, write=True, fields=self.__outputFieldsMeta) DCNL DCSP if (self.__checkpointCache is not None): DCNL DCSP  DCSP self.__checkpointCache.seek(0) DCNL DCSP  DCSP reader = csv.reader(self.__checkpointCache, dialect='excel') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP header = reader.next() DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP print ('Empty DCSP record DCSP checkpoint DCSP initializer DCSP for DCSP %r' % (self.__datasetPath,)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert (tuple(self.__dataset.getFieldNames()) == tuple(header)), ('dataset.getFieldNames(): DCSP %r; DCSP predictionCheckpointFieldNames: DCSP %r' % (tuple(self.__dataset.getFieldNames()), tuple(header))) DCNL DCSP  DCSP numRowsCopied = 0 DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP row = reader.next() DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP self.__dataset.appendRecord(row) DCNL DCSP  DCSP  DCSP numRowsCopied += 1 DCNL DCSP  DCSP self.__dataset.flush() DCNL DCSP  DCSP print ('Restored DCSP %d DCSP rows DCSP from DCSP checkpoint DCSP for DCSP %r' % (numRowsCopied, self.__datasetPath)) DCNL DCSP  DCSP self.__checkpointCache.close() DCNL DCSP  DCSP self.__checkpointCache = None DCNL DCSP return
def setLoggedMetrics(self, metricNames): DCNL DCSP if (metricNames is None): DCNL DCSP  DCSP self.__metricNames = set([]) DCNL DCSP else: DCNL DCSP  DCSP self.__metricNames = set(metricNames)
def close(self): DCNL DCSP if self.__dataset: DCNL DCSP  DCSP self.__dataset.close() DCNL DCSP self.__dataset = None DCNL DCSP return
def __getListMetaInfo(self, inferenceElement): DCNL DCSP fieldMetaInfo = [] DCNL DCSP inferenceLabel = InferenceElement.getLabel(inferenceElement) DCNL DCSP for inputFieldMeta in self.__inputFieldsMeta: DCNL DCSP  DCSP if InferenceElement.getInputElement(inferenceElement): DCNL DCSP  DCSP  DCSP outputFieldMeta = FieldMetaInfo(name=(inputFieldMeta.name + '.actual'), type=inputFieldMeta.type, special=inputFieldMeta.special) DCNL DCSP  DCSP predictionField = FieldMetaInfo(name=((inputFieldMeta.name + '.') + inferenceLabel), type=inputFieldMeta.type, special=inputFieldMeta.special) DCNL DCSP  DCSP fieldMetaInfo.append(outputFieldMeta) DCNL DCSP  DCSP fieldMetaInfo.append(predictionField) DCNL DCSP return fieldMetaInfo
def __getDictMetaInfo(self, inferenceElement, inferenceDict): DCNL DCSP fieldMetaInfo = [] DCNL DCSP inferenceLabel = InferenceElement.getLabel(inferenceElement) DCNL DCSP if InferenceElement.getInputElement(inferenceElement): DCNL DCSP  DCSP fieldMetaInfo.append(FieldMetaInfo(name=(inferenceLabel + '.actual'), type=FieldMetaType.string, special='')) DCNL DCSP keys = sorted(inferenceDict.keys()) DCNL DCSP for key in keys: DCNL DCSP  DCSP fieldMetaInfo.append(FieldMetaInfo(name=((inferenceLabel + '.') + str(key)), type=FieldMetaType.string, special='')) DCNL DCSP return fieldMetaInfo
def append(self, modelResult): DCNL DCSP inferences = modelResult.inferences DCNL DCSP hasInferences = False DCNL DCSP if (inferences is not None): DCNL DCSP  DCSP for value in inferences.itervalues(): DCNL DCSP  DCSP  DCSP hasInferences = (hasInferences or (value is not None)) DCNL DCSP if (not hasInferences): DCNL DCSP  DCSP return DCNL DCSP if (self.__dataset is None): DCNL DCSP  DCSP self.__openDatafile(modelResult) DCNL DCSP inputData = modelResult.sensorInput DCNL DCSP sequenceReset = int(bool(inputData.sequenceReset)) DCNL DCSP outputRow = [sequenceReset] DCNL DCSP rawInput = modelResult.rawInput DCNL DCSP for field in self._rawInputNames: DCNL DCSP  DCSP outputRow.append(str(rawInput[field])) DCNL DCSP for (inferenceElement, outputVal) in inferences.iteritems(): DCNL DCSP  DCSP inputElement = InferenceElement.getInputElement(inferenceElement) DCNL DCSP  DCSP if inputElement: DCNL DCSP  DCSP  DCSP inputVal = getattr(inputData, inputElement) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inputVal = None DCNL DCSP  DCSP if (type(outputVal) in (list, tuple)): DCNL DCSP  DCSP  DCSP assert (type(inputVal) in (list, tuple, None)) DCNL DCSP  DCSP  DCSP for (iv, ov) in zip(inputVal, outputVal): DCNL DCSP  DCSP  DCSP  DCSP outputRow.append(str(iv)) DCNL DCSP  DCSP  DCSP  DCSP outputRow.append(str(ov)) DCNL DCSP  DCSP elif isinstance(outputVal, dict): DCNL DCSP  DCSP  DCSP if (inputVal is not None): DCNL DCSP  DCSP  DCSP  DCSP if (modelResult.predictedFieldName is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP outputRow.append(str(inputVal[modelResult.predictedFieldName])) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP outputRow.append(str(inputVal)) DCNL DCSP  DCSP  DCSP for key in sorted(outputVal.keys()): DCNL DCSP  DCSP  DCSP  DCSP outputRow.append(str(outputVal[key])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (inputVal is not None): DCNL DCSP  DCSP  DCSP  DCSP outputRow.append(str(inputVal)) DCNL DCSP  DCSP  DCSP outputRow.append(str(outputVal)) DCNL DCSP metrics = modelResult.metrics DCNL DCSP for metricName in self.__metricNames: DCNL DCSP  DCSP outputRow.append(metrics.get(metricName, 0.0)) DCNL DCSP self.__dataset.appendRecord(outputRow) DCNL DCSP self.__dataset.flush() DCNL DCSP return
def checkpoint(self, checkpointSink, maxRows): DCNL DCSP checkpointSink.truncate() DCNL DCSP if (self.__dataset is None): DCNL DCSP  DCSP if (self.__checkpointCache is not None): DCNL DCSP  DCSP  DCSP self.__checkpointCache.seek(0) DCNL DCSP  DCSP  DCSP shutil.copyfileobj(self.__checkpointCache, checkpointSink) DCNL DCSP  DCSP  DCSP checkpointSink.flush() DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return DCNL DCSP self.__dataset.flush() DCNL DCSP totalDataRows = self.__dataset.getDataRowCount() DCNL DCSP if (totalDataRows == 0): DCNL DCSP  DCSP return DCNL DCSP reader = FileRecordStream(self.__datasetPath, missingValues=[]) DCNL DCSP writer = csv.writer(checkpointSink) DCNL DCSP writer.writerow(reader.getFieldNames()) DCNL DCSP numToWrite = min(maxRows, totalDataRows) DCNL DCSP numRowsToSkip = (totalDataRows - numToWrite) DCNL DCSP for i in xrange(numRowsToSkip): DCNL DCSP  DCSP reader.next() DCNL DCSP numWritten = 0 DCNL DCSP while True: DCNL DCSP  DCSP row = reader.getNextRecord() DCNL DCSP  DCSP if (row is None): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP row = [str(element) for element in row] DCNL DCSP  DCSP writer.writerow(row) DCNL DCSP  DCSP numWritten += 1 DCNL DCSP assert (numWritten == numToWrite), ('numWritten DCSP (%s) DCSP != DCSP numToWrite DCSP (%s)' % (numWritten, numToWrite)) DCNL DCSP checkpointSink.flush() DCNL DCSP return
def update(self, modelResult): DCNL DCSP self.__writer.append(modelResult) DCNL DCSP return
def __init__(self, writer): DCNL DCSP self.__logger = logging.getLogger('.'.join(['com.numenta', self.__class__.__module__, self.__class__.__name__])) DCNL DCSP self.__writer = writer DCNL DCSP self.__inferenceShifter = InferenceShifter() DCNL DCSP return
def update(self, modelResult): DCNL DCSP self.__writer.append(self.__inferenceShifter.shift(modelResult))
@staticmethod DCNL def getExperimentInferenceDirPath(experimentDir): DCNL DCSP return os.path.abspath(os.path.join(experimentDir, 'inference'))
@classmethod DCNL def createExperimentInferenceDir(cls, experimentDir): DCNL DCSP path = cls.getExperimentInferenceDirPath(experimentDir) DCNL DCSP cls.makeDirectory(path) DCNL DCSP return path
@staticmethod DCNL def makeDirectory(path): DCNL DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == os.errno.EEXIST): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP return
@staticmethod DCNL def getInputElement(inferenceElement): DCNL DCSP return InferenceElement.__inferenceInputMap.get(inferenceElement, None)
@staticmethod DCNL def isTemporal(inferenceElement): DCNL DCSP if (InferenceElement.__temporalInferenceElements is None): DCNL DCSP  DCSP InferenceElement.__temporalInferenceElements = set([InferenceElement.prediction]) DCNL DCSP return (inferenceElement in InferenceElement.__temporalInferenceElements)
@staticmethod DCNL def getTemporalDelay(inferenceElement, key=None): DCNL DCSP if (inferenceElement in (InferenceElement.prediction, InferenceElement.encodings)): DCNL DCSP  DCSP return 1 DCNL DCSP if (inferenceElement in (InferenceElement.anomalyScore, InferenceElement.anomalyLabel, InferenceElement.classification, InferenceElement.classConfidences)): DCNL DCSP  DCSP return 0 DCNL DCSP if (inferenceElement in (InferenceElement.multiStepPredictions, InferenceElement.multiStepBestPredictions, InferenceElement.multiStepBucketLikelihoods)): DCNL DCSP  DCSP return int(key) DCNL DCSP return 0
@staticmethod DCNL def getMaxDelay(inferences): DCNL DCSP maxDelay = 0 DCNL DCSP for (inferenceElement, inference) in inferences.iteritems(): DCNL DCSP  DCSP if isinstance(inference, dict): DCNL DCSP  DCSP  DCSP for key in inference.iterkeys(): DCNL DCSP  DCSP  DCSP  DCSP maxDelay = max(InferenceElement.getTemporalDelay(inferenceElement, key), maxDelay) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP maxDelay = max(InferenceElement.getTemporalDelay(inferenceElement), maxDelay) DCNL DCSP return maxDelay
@staticmethod DCNL def isTemporal(inferenceType): DCNL DCSP if (InferenceType.__temporalInferenceTypes is None): DCNL DCSP  DCSP InferenceType.__temporalInferenceTypes = set([InferenceType.TemporalNextStep, InferenceType.TemporalClassification, InferenceType.TemporalAnomaly, InferenceType.TemporalMultiStep, InferenceType.NontemporalMultiStep]) DCNL DCSP return (inferenceType in InferenceType.__temporalInferenceTypes)
def __init__(self, inferenceType=None, proto=None): DCNL DCSP assert (((inferenceType is not None) and (proto is None)) or ((inferenceType is None) and (proto is not None))), 'proto DCSP and DCSP other DCSP constructor DCSP args DCSP are DCSP mutually DCSP exclusive' DCNL DCSP if (proto is None): DCNL DCSP  DCSP self._numPredictions = 0 DCNL DCSP  DCSP self.__inferenceType = inferenceType DCNL DCSP  DCSP self.__learningEnabled = True DCNL DCSP  DCSP self.__inferenceEnabled = True DCNL DCSP  DCSP self.__inferenceArgs = {} DCNL DCSP else: DCNL DCSP  DCSP self._numPredictions = proto.numPredictions DCNL DCSP  DCSP inferenceType = str(proto.inferenceType) DCNL DCSP  DCSP inferenceType = (inferenceType[:1].upper() + inferenceType[1:]) DCNL DCSP  DCSP self.__inferenceType = InferenceType.getValue(inferenceType) DCNL DCSP  DCSP self.__learningEnabled = proto.learningEnabled DCNL DCSP  DCSP self.__inferenceEnabled = proto.inferenceEnabled DCNL DCSP  DCSP self.__inferenceArgs = json.loads(proto.inferenceArgs)
def run(self, inputRecord): DCNL DCSP predictionNumber = self._numPredictions DCNL DCSP self._numPredictions += 1 DCNL DCSP result = opf_utils.ModelResult(predictionNumber=predictionNumber, rawInput=inputRecord) DCNL DCSP return result
def getInferenceType(self): DCNL DCSP return self.__inferenceType
def enableLearning(self): DCNL DCSP self.__learningEnabled = True DCNL DCSP return
def disableLearning(self): DCNL DCSP self.__learningEnabled = False DCNL DCSP return
def isLearningEnabled(self): DCNL DCSP return self.__learningEnabled
def enableInference(self, inferenceArgs=None): DCNL DCSP self.__inferenceEnabled = True DCNL DCSP self.__inferenceArgs = inferenceArgs
def getInferenceArgs(self): DCNL DCSP return self.__inferenceArgs
def disableInference(self): DCNL DCSP self.__inferenceEnabled = False
def isInferenceEnabled(self): DCNL DCSP return self.__inferenceEnabled
@staticmethod DCNL def getSchema(): DCNL DCSP raise NotImplementedError()
@staticmethod DCNL def _getModelCheckpointFilePath(checkpointDir): DCNL DCSP path = os.path.join(checkpointDir, 'model.data') DCNL DCSP path = os.path.abspath(path) DCNL DCSP return path
def writeToCheckpoint(self, checkpointDir): DCNL DCSP proto = self.getSchema().new_message() DCNL DCSP self.write(proto) DCNL DCSP checkpointPath = self._getModelCheckpointFilePath(checkpointDir) DCNL DCSP if os.path.exists(checkpointDir): DCNL DCSP  DCSP if (not os.path.isdir(checkpointDir)): DCNL DCSP  DCSP  DCSP raise Exception(('Existing DCSP filesystem DCSP entry DCSP <%s> DCSP is DCSP not DCSP a DCSP model DCSP checkpoint DCSP -- DCSP refusing DCSP to DCSP delete DCSP (not DCSP a DCSP directory)' % checkpointDir)) DCNL DCSP  DCSP if (not os.path.isfile(checkpointPath)): DCNL DCSP  DCSP  DCSP raise Exception(('Existing DCSP filesystem DCSP entry DCSP <%s> DCSP is DCSP not DCSP a DCSP model DCSP checkpoint DCSP -- DCSP refusing DCSP to DCSP delete DCSP (%s DCSP missing DCSP or DCSP not DCSP a DCSP file)' % (checkpointDir, checkpointPath))) DCNL DCSP  DCSP shutil.rmtree(checkpointDir) DCNL DCSP self.__makeDirectoryFromAbsolutePath(checkpointDir) DCNL DCSP with open(checkpointPath, 'wb') as f: DCNL DCSP  DCSP proto.write(f)
@classmethod DCNL def readFromCheckpoint(cls, checkpointDir): DCNL DCSP checkpointPath = cls._getModelCheckpointFilePath(checkpointDir) DCNL DCSP with open(checkpointPath, 'r') as f: DCNL DCSP  DCSP proto = cls.getSchema().read(f) DCNL DCSP model = cls.read(proto) DCNL DCSP return model
def writeBaseToProto(self, proto): DCNL DCSP inferenceType = self.getInferenceType() DCNL DCSP inferenceType = (inferenceType[:1].lower() + inferenceType[1:]) DCNL DCSP proto.inferenceType = inferenceType DCNL DCSP proto.numPredictions = self._numPredictions DCNL DCSP proto.learningEnabled = self.__learningEnabled DCNL DCSP proto.inferenceEnabled = self.__inferenceEnabled DCNL DCSP proto.inferenceArgs = json.dumps(self.__inferenceArgs)
def write(self, proto): DCNL DCSP raise NotImplementedError()
@classmethod DCNL def read(cls, proto): DCNL DCSP raise NotImplementedError()
def save(self, saveModelDir): DCNL DCSP logger = self._getLogger() DCNL DCSP logger.debug('(%s) DCSP Creating DCSP local DCSP checkpoint DCSP in DCSP %r...', self, saveModelDir) DCNL DCSP modelPickleFilePath = self._getModelPickleFilePath(saveModelDir) DCNL DCSP if os.path.exists(saveModelDir): DCNL DCSP  DCSP if (not os.path.isdir(saveModelDir)): DCNL DCSP  DCSP  DCSP raise Exception(('Existing DCSP filesystem DCSP entry DCSP <%s> DCSP is DCSP not DCSP a DCSP model DCSP checkpoint DCSP -- DCSP refusing DCSP to DCSP delete DCSP (not DCSP a DCSP directory)' % saveModelDir)) DCNL DCSP  DCSP if (not os.path.isfile(modelPickleFilePath)): DCNL DCSP  DCSP  DCSP raise Exception(('Existing DCSP filesystem DCSP entry DCSP <%s> DCSP is DCSP not DCSP a DCSP model DCSP checkpoint DCSP -- DCSP refusing DCSP to DCSP delete DCSP (%s DCSP missing DCSP or DCSP not DCSP a DCSP file)' % (saveModelDir, modelPickleFilePath))) DCNL DCSP  DCSP shutil.rmtree(saveModelDir) DCNL DCSP self.__makeDirectoryFromAbsolutePath(saveModelDir) DCNL DCSP with open(modelPickleFilePath, 'wb') as modelPickleFile: DCNL DCSP  DCSP logger.debug('(%s) DCSP Pickling DCSP Model DCSP instance...', self) DCNL DCSP  DCSP pickle.dump(self, modelPickleFile) DCNL DCSP  DCSP logger.debug('(%s) DCSP Finished DCSP pickling DCSP Model DCSP instance', self) DCNL DCSP self._serializeExtraData(extraDataDir=self._getModelExtraDataDir(saveModelDir)) DCNL DCSP logger.debug('(%s) DCSP Finished DCSP creating DCSP local DCSP checkpoint', self) DCNL DCSP return
def _serializeExtraData(self, extraDataDir): DCNL DCSP pass
@classmethod DCNL def load(cls, savedModelDir): DCNL DCSP logger = opf_utils.initLogger(cls) DCNL DCSP logger.debug('Loading DCSP model DCSP from DCSP local DCSP checkpoint DCSP at DCSP %r...', savedModelDir) DCNL DCSP modelPickleFilePath = Model._getModelPickleFilePath(savedModelDir) DCNL DCSP with open(modelPickleFilePath, 'r') as modelPickleFile: DCNL DCSP  DCSP logger.debug('Unpickling DCSP Model DCSP instance...') DCNL DCSP  DCSP model = pickle.load(modelPickleFile) DCNL DCSP  DCSP logger.debug('Finished DCSP unpickling DCSP Model DCSP instance') DCNL DCSP model._deSerializeExtraData(extraDataDir=Model._getModelExtraDataDir(savedModelDir)) DCNL DCSP logger.debug('Finished DCSP Loading DCSP model DCSP from DCSP local DCSP checkpoint') DCNL DCSP return model
def _deSerializeExtraData(self, extraDataDir): DCNL DCSP pass
@staticmethod DCNL def _getModelPickleFilePath(saveModelDir): DCNL DCSP path = os.path.join(saveModelDir, 'model.pkl') DCNL DCSP path = os.path.abspath(path) DCNL DCSP return path
@staticmethod DCNL def _getModelExtraDataDir(saveModelDir): DCNL DCSP path = os.path.join(saveModelDir, 'modelextradata') DCNL DCSP path = os.path.abspath(path) DCNL DCSP return path
@staticmethod DCNL def __makeDirectoryFromAbsolutePath(absDirPath): DCNL DCSP assert os.path.isabs(absDirPath) DCNL DCSP try: DCNL DCSP  DCSP os.makedirs(absDirPath) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno != os.errno.EEXIST): DCNL DCSP  DCSP  DCSP raise DCNL DCSP return
def __call__(self, topContainer): DCNL DCSP assert (not self.__inLookup) DCNL DCSP if (self.__cachedResult is not self.__NoResult): DCNL DCSP  DCSP return self.__cachedResult DCNL DCSP self.__cachedResult = self.handleGetValue(topContainer) DCNL DCSP if isinstance(self.__cachedResult, ValueGetterBase): DCNL DCSP  DCSP valueGetter = self.__cachedResult DCNL DCSP  DCSP self.__inLookup = True DCNL DCSP  DCSP self.__cachedResult = valueGetter(topContainer) DCNL DCSP  DCSP self.__inLookup = False DCNL DCSP assert (self.__cachedResult is not self.__NoResult) DCNL DCSP assert (not isinstance(self.__cachedResult, ValueGetterBase)) DCNL DCSP return self.__cachedResult
def handleGetValue(self, topContainer): DCNL DCSP raise NotImplementedError(('ERROR: DCSP ValueGetterBase DCSP is DCSP an DCSP abstract DCSP ' + 'class; DCSP base DCSP class DCSP MUST DCSP override DCSP handleGetValue()'))
def __init__(self, referenceDict, *dictKeyChain): DCNL DCSP ValueGetterBase.__init__(self) DCNL DCSP assert ((referenceDict is None) or isinstance(referenceDict, dict)) DCNL DCSP assert (len(dictKeyChain) >= 1) DCNL DCSP self.__referenceDict = referenceDict DCNL DCSP self.__dictKeyChain = dictKeyChain
def handleGetValue(self, topContainer): DCNL DCSP value = (self.__referenceDict if (self.__referenceDict is not None) else topContainer) DCNL DCSP for key in self.__dictKeyChain: DCNL DCSP  DCSP value = value[key] DCNL DCSP return value
def __init__(self, *dictKeyChain): DCNL DCSP DictValueGetter.__init__(self, None, *dictKeyChain)
def _getImpl(self, model): DCNL DCSP impl = _IterationPhaseLearnOnly(model=model, nIters=self.__nIters) DCNL DCSP return impl
def _getImpl(self, model): DCNL DCSP impl = _IterationPhaseInferOnly(model=model, nIters=self.__nIters, inferenceArgs=self.__inferenceArgs) DCNL DCSP return impl
def _getImpl(self, model): DCNL DCSP impl = _IterationPhaseLearnAndInfer(model=model, nIters=self.__nIters, inferenceArgs=self.__inferenceArgs) DCNL DCSP return impl
def replaceIterationCycle(self, phaseSpecs): DCNL DCSP self.__phaseManager = _PhaseManager(model=self.__model, phaseSpecs=phaseSpecs) DCNL DCSP return
def setup(self): DCNL DCSP for cb in self.__userCallbacks['setup']: DCNL DCSP  DCSP cb(self.__model) DCNL DCSP return
def finalize(self): DCNL DCSP for cb in self.__userCallbacks['finish']: DCNL DCSP  DCSP cb(self.__model) DCNL DCSP return
def handleInputRecord(self, inputRecord): DCNL DCSP assert inputRecord, ('Invalid DCSP inputRecord: DCSP %r' % inputRecord) DCNL DCSP results = self.__phaseManager.handleInputRecord(inputRecord) DCNL DCSP metrics = self.__metricsMgr.update(results) DCNL DCSP for cb in self.__userCallbacks['postIter']: DCNL DCSP  DCSP cb(self.__model) DCNL DCSP results.metrics = metrics DCNL DCSP return results
def getMetrics(self): DCNL DCSP return self.__metricsMgr.getMetrics()
def getMetricLabels(self): DCNL DCSP return self.__metricsMgr.getMetricLabels()
def __init__(self, model, phaseSpecs): DCNL DCSP self.__model = model DCNL DCSP self.__phases = tuple(map((lambda x: x._getImpl(model=model)), phaseSpecs)) DCNL DCSP if self.__phases: DCNL DCSP  DCSP self.__phaseCycler = itertools.cycle(self.__phases) DCNL DCSP  DCSP self.__advancePhase() DCNL DCSP return
def __advancePhase(self): DCNL DCSP self.__currentPhase = self.__phaseCycler.next() DCNL DCSP self.__currentPhase.enterPhase() DCNL DCSP return
def handleInputRecord(self, inputRecord): DCNL DCSP results = self.__model.run(inputRecord) DCNL DCSP shouldContinue = self.__currentPhase.advance() DCNL DCSP if (not shouldContinue): DCNL DCSP  DCSP self.__advancePhase() DCNL DCSP return results
def __init__(self, nIters): DCNL DCSP assert (nIters > 0), ('nIters=%s' % nIters) DCNL DCSP self.__nIters = nIters DCNL DCSP return
@abstractmethod DCNL def enterPhase(self): DCNL DCSP self.__iter = iter(xrange(self.__nIters)) DCNL DCSP self.__iter.next()
def advance(self): DCNL DCSP hasMore = True DCNL DCSP try: DCNL DCSP  DCSP self.__iter.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP self.__iter = None DCNL DCSP  DCSP hasMore = False DCNL DCSP return hasMore
def __init__(self, model, nIters): DCNL DCSP super(_IterationPhaseLearnOnly, self).__init__(nIters=nIters) DCNL DCSP self.__model = model DCNL DCSP return
def enterPhase(self): DCNL DCSP super(_IterationPhaseLearnOnly, self).enterPhase() DCNL DCSP self.__model.enableLearning() DCNL DCSP self.__model.disableInference() DCNL DCSP return
def __init__(self, model, nIters, inferenceArgs): DCNL DCSP super(_IterationPhaseInferCommon, self).__init__(nIters=nIters) DCNL DCSP self._model = model DCNL DCSP self._inferenceArgs = inferenceArgs DCNL DCSP return
def enterPhase(self): DCNL DCSP super(_IterationPhaseInferCommon, self).enterPhase() DCNL DCSP self._model.enableInference(inferenceArgs=self._inferenceArgs) DCNL DCSP return
def __init__(self, model, nIters, inferenceArgs): DCNL DCSP super(_IterationPhaseInferOnly, self).__init__(model=model, nIters=nIters, inferenceArgs=inferenceArgs) DCNL DCSP return
def enterPhase(self): DCNL DCSP super(_IterationPhaseInferOnly, self).enterPhase() DCNL DCSP self._model.disableLearning() DCNL DCSP return
def __init__(self, model, nIters, inferenceArgs): DCNL DCSP super(_IterationPhaseLearnAndInfer, self).__init__(model=model, nIters=nIters, inferenceArgs=inferenceArgs) DCNL DCSP return
def enterPhase(self): DCNL DCSP super(_IterationPhaseLearnAndInfer, self).enterPhase() DCNL DCSP self._model.enableLearning() DCNL DCSP return
def setFieldStatistics(self, fieldStats): DCNL DCSP pass
@classmethod DCNL def read(cls, proto): DCNL DCSP instance = object.__new__(cls) DCNL DCSP super(TwoGramModel, instance).__init__(proto=proto.modelBase) DCNL DCSP instance._logger = opf_utils.initLogger(instance) DCNL DCSP instance._reset = proto.reset DCNL DCSP instance._hashToValueDict = {x.hash: x.value for x in proto.hashToValueDict} DCNL DCSP instance._learningEnabled = proto.learningEnabled DCNL DCSP instance._encoder = encoders.MultiEncoder.read(proto.encoder) DCNL DCSP instance._fieldNames = instance._encoder.getScalarNames() DCNL DCSP instance._prevValues = list(proto.prevValues) DCNL DCSP instance._twoGramDicts = [dict() for _ in xrange(len(proto.twoGramDicts))] DCNL DCSP for (idx, field) in enumerate(proto.twoGramDicts): DCNL DCSP  DCSP for entry in field: DCNL DCSP  DCSP  DCSP prev = (None if (entry.value == (-1)) else entry.value) DCNL DCSP  DCSP  DCSP instance._twoGramDicts[idx][prev] = collections.defaultdict(int) DCNL DCSP  DCSP  DCSP for bucket in entry.buckets: DCNL DCSP  DCSP  DCSP  DCSP instance._twoGramDicts[idx][prev][bucket.index] = bucket.count DCNL DCSP return instance
def write(self, proto): DCNL DCSP super(TwoGramModel, self).writeBaseToProto(proto.modelBase) DCNL DCSP proto.reset = self._reset DCNL DCSP proto.learningEnabled = self._learningEnabled DCNL DCSP proto.prevValues = self._prevValues DCNL DCSP self._encoder.write(proto.encoder) DCNL DCSP proto.hashToValueDict = [{'hash': h, 'value': v} for (h, v) in self._hashToValueDict.items()] DCNL DCSP twoGramDicts = [] DCNL DCSP for items in self._twoGramDicts: DCNL DCSP  DCSP twoGramArr = [] DCNL DCSP  DCSP for (prev, values) in items.iteritems(): DCNL DCSP  DCSP  DCSP buckets = [{'index': index, 'count': count} for (index, count) in values.iteritems()] DCNL DCSP  DCSP  DCSP if (prev is None): DCNL DCSP  DCSP  DCSP  DCSP prev = (-1) DCNL DCSP  DCSP  DCSP twoGramArr.append({'value': prev, 'buckets': buckets}) DCNL DCSP  DCSP twoGramDicts.append(twoGramArr) DCNL DCSP proto.twoGramDicts = twoGramDicts
def __init__(self, net, statsCollectors): DCNL DCSP self.net = net DCNL DCSP self.statsCollectors = statsCollectors DCNL DCSP return
def __init__(self, sensorParams={}, inferenceType=InferenceType.TemporalNextStep, spEnable=True, spParams={}, trainSPNetOnlyIfRequested=False, tmEnable=True, tmParams={}, clEnable=True, clParams={}, anomalyParams={}, minLikelihoodThreshold=DEFAULT_LIKELIHOOD_THRESHOLD, maxPredictionsPerStep=DEFAULT_MAX_PREDICTIONS_PER_STEP, network=None, baseProto=None): DCNL DCSP if (not (inferenceType in self.__supportedInferenceKindSet)): DCNL DCSP  DCSP raise ValueError('{0} DCSP received DCSP incompatible DCSP inference DCSP type: DCSP {1}'.format(self.__class__, inferenceType)) DCNL DCSP if (baseProto is None): DCNL DCSP  DCSP super(HTMPredictionModel, self).__init__(inferenceType) DCNL DCSP else: DCNL DCSP  DCSP super(HTMPredictionModel, self).__init__(proto=baseProto) DCNL DCSP self.__restoringFromState = False DCNL DCSP self.__restoringFromV1 = False DCNL DCSP self.__logger = initLogger(self) DCNL DCSP self.__logger.debug(('Instantiating DCSP %s.' % self.__myClassName)) DCNL DCSP self._minLikelihoodThreshold = minLikelihoodThreshold DCNL DCSP self._maxPredictionsPerStep = maxPredictionsPerStep DCNL DCSP self.__spLearningEnabled = bool(spEnable) DCNL DCSP self.__tpLearningEnabled = bool(tmEnable) DCNL DCSP if ((not InferenceType.isTemporal(self.getInferenceType())) or (self.getInferenceType() == InferenceType.NontemporalMultiStep)): DCNL DCSP  DCSP tmEnable = False DCNL DCSP self._netInfo = None DCNL DCSP self._hasSP = spEnable DCNL DCSP self._hasTP = tmEnable DCNL DCSP self._hasCL = clEnable DCNL DCSP self._classifierInputEncoder = None DCNL DCSP self._predictedFieldIdx = None DCNL DCSP self._predictedFieldName = None DCNL DCSP self._numFields = None DCNL DCSP if (network is not None): DCNL DCSP  DCSP self._netInfo = NetworkInfo(net=network, statsCollectors=[]) DCNL DCSP else: DCNL DCSP  DCSP self._netInfo = self.__createHTMNetwork(sensorParams, spEnable, spParams, tmEnable, tmParams, clEnable, clParams, anomalyParams) DCNL DCSP if (self.getInferenceType() == InferenceType.NontemporalAnomaly): DCNL DCSP  DCSP self._getSPRegion().setParameter('anomalyMode', True) DCNL DCSP if (self.getInferenceType() == InferenceType.TemporalAnomaly): DCNL DCSP  DCSP self._getTPRegion().setParameter('anomalyMode', True) DCNL DCSP self.__trainSPNetOnlyIfRequested = trainSPNetOnlyIfRequested DCNL DCSP self.__numRunCalls = 0 DCNL DCSP self.__finishedLearning = False DCNL DCSP self.__logger.debug(('Instantiated DCSP %s' % self.__class__.__name__)) DCNL DCSP self._input = None DCNL DCSP return
def getParameter(self, paramName): DCNL DCSP if (paramName == '__numRunCalls'): DCNL DCSP  DCSP return self.__numRunCalls DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(("'%s' DCSP parameter DCSP is DCSP not DCSP exposed DCSP by DCSP htm_prediction_model." % paramName))
@requireAnomalyModel DCNL def setAnomalyParameter(self, param, value): DCNL DCSP self._getAnomalyClassifier().setParameter(param, value)
@requireAnomalyModel DCNL def getAnomalyParameter(self, param): DCNL DCSP return self._getAnomalyClassifier().getParameter(param)
@requireAnomalyModel DCNL def anomalyRemoveLabels(self, start, end, labelFilter): DCNL DCSP self._getAnomalyClassifier().getSelf().removeLabels(start, end, labelFilter)
@requireAnomalyModel DCNL def anomalyAddLabel(self, start, end, labelName): DCNL DCSP self._getAnomalyClassifier().getSelf().addLabel(start, end, labelName)
@requireAnomalyModel DCNL def anomalyGetLabels(self, start, end): DCNL DCSP return self._getAnomalyClassifier().getSelf().getLabels(start, end)
def _getSensorInputRecord(self, inputRecord): DCNL DCSP sensor = self._getSensorRegion() DCNL DCSP dataRow = copy.deepcopy(sensor.getSelf().getOutputValues('sourceOut')) DCNL DCSP dataDict = copy.deepcopy(inputRecord) DCNL DCSP inputRecordEncodings = sensor.getSelf().getOutputValues('sourceEncodings') DCNL DCSP inputRecordCategory = int(sensor.getOutputData('categoryOut')[0]) DCNL DCSP resetOut = sensor.getOutputData('resetOut')[0] DCNL DCSP return SensorInput(dataRow=dataRow, dataDict=dataDict, dataEncodings=inputRecordEncodings, sequenceReset=resetOut, category=inputRecordCategory)
def _getClassifierInputRecord(self, inputRecord): DCNL DCSP absoluteValue = None DCNL DCSP bucketIdx = None DCNL DCSP if ((self._predictedFieldName is not None) and (self._classifierInputEncoder is not None)): DCNL DCSP  DCSP absoluteValue = inputRecord[self._predictedFieldName] DCNL DCSP  DCSP bucketIdx = self._classifierInputEncoder.getBucketIndices(absoluteValue)[0] DCNL DCSP return ClassifierInput(dataRow=absoluteValue, bucketIndex=bucketIdx)
def _anomalyCompute(self): DCNL DCSP inferenceType = self.getInferenceType() DCNL DCSP inferences = {} DCNL DCSP sp = self._getSPRegion() DCNL DCSP score = None DCNL DCSP if (inferenceType == InferenceType.NontemporalAnomaly): DCNL DCSP  DCSP score = sp.getOutputData('anomalyScore')[0] DCNL DCSP elif (inferenceType == InferenceType.TemporalAnomaly): DCNL DCSP  DCSP tm = self._getTPRegion() DCNL DCSP  DCSP if (sp is not None): DCNL DCSP  DCSP  DCSP activeColumns = sp.getOutputData('bottomUpOut').nonzero()[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sensor = self._getSensorRegion() DCNL DCSP  DCSP  DCSP activeColumns = sensor.getOutputData('dataOut').nonzero()[0] DCNL DCSP  DCSP if (not (self._predictedFieldName in self._input)): DCNL DCSP  DCSP  DCSP raise ValueError(("Expected DCSP predicted DCSP field DCSP '%s' DCSP in DCSP input DCSP row, DCSP but DCSP was DCSP not DCSP found!" % self._predictedFieldName)) DCNL DCSP  DCSP score = tm.getOutputData('anomalyScore')[0] DCNL DCSP  DCSP if (sp is not None): DCNL DCSP  DCSP  DCSP self._getAnomalyClassifier().setParameter('activeColumnCount', len(activeColumns)) DCNL DCSP  DCSP  DCSP self._getAnomalyClassifier().prepareInputs() DCNL DCSP  DCSP  DCSP self._getAnomalyClassifier().compute() DCNL DCSP  DCSP  DCSP labels = self._getAnomalyClassifier().getSelf().getLabelResults() DCNL DCSP  DCSP  DCSP inferences[InferenceElement.anomalyLabel] = ('%s' % labels) DCNL DCSP inferences[InferenceElement.anomalyScore] = score DCNL DCSP return inferences
def _handleSDRClassifierMultiStep(self, patternNZ, inputTSRecordIdx, rawInput): DCNL DCSP inferenceArgs = self.getInferenceArgs() DCNL DCSP predictedFieldName = inferenceArgs.get('predictedField', None) DCNL DCSP if (predictedFieldName is None): DCNL DCSP  DCSP raise ValueError('No DCSP predicted DCSP field DCSP was DCSP enabled! DCSP Did DCSP you DCSP call DCSP enableInference()?') DCNL DCSP self._predictedFieldName = predictedFieldName DCNL DCSP classifier = self._getClassifierRegion() DCNL DCSP if ((not self._hasCL) or (classifier is None)): DCNL DCSP  DCSP return {} DCNL DCSP sensor = self._getSensorRegion() DCNL DCSP minLikelihoodThreshold = self._minLikelihoodThreshold DCNL DCSP maxPredictionsPerStep = self._maxPredictionsPerStep DCNL DCSP needLearning = self.isLearningEnabled() DCNL DCSP inferences = {} DCNL DCSP if (self._classifierInputEncoder is None): DCNL DCSP  DCSP if (predictedFieldName is None): DCNL DCSP  DCSP  DCSP raise RuntimeError("This DCSP experiment DCSP description DCSP is DCSP missing DCSP the DCSP 'predictedField' DCSP in DCSP its DCSP config, DCSP which DCSP is DCSP required DCSP for DCSP multi-step DCSP prediction DCSP inference.") DCNL DCSP  DCSP encoderList = sensor.getSelf().encoder.getEncoderList() DCNL DCSP  DCSP self._numFields = len(encoderList) DCNL DCSP  DCSP fieldNames = sensor.getSelf().encoder.getScalarNames() DCNL DCSP  DCSP if (predictedFieldName in fieldNames): DCNL DCSP  DCSP  DCSP self._predictedFieldIdx = fieldNames.index(predictedFieldName) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._predictedFieldIdx = None DCNL DCSP  DCSP if (sensor.getSelf().disabledEncoder is not None): DCNL DCSP  DCSP  DCSP encoderList = sensor.getSelf().disabledEncoder.getEncoderList() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP encoderList = [] DCNL DCSP  DCSP if (len(encoderList) >= 1): DCNL DCSP  DCSP  DCSP fieldNames = sensor.getSelf().disabledEncoder.getScalarNames() DCNL DCSP  DCSP  DCSP self._classifierInputEncoder = encoderList[fieldNames.index(predictedFieldName)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP encoderList = sensor.getSelf().encoder.getEncoderList() DCNL DCSP  DCSP  DCSP self._classifierInputEncoder = encoderList[self._predictedFieldIdx] DCNL DCSP if (not (predictedFieldName in rawInput)): DCNL DCSP  DCSP raise ValueError(("Input DCSP row DCSP does DCSP not DCSP contain DCSP a DCSP value DCSP for DCSP the DCSP predicted DCSP field DCSP configured DCSP for DCSP this DCSP model. DCSP Missing DCSP value DCSP for DCSP '%s'" % predictedFieldName)) DCNL DCSP absoluteValue = rawInput[predictedFieldName] DCNL DCSP bucketIdx = self._classifierInputEncoder.getBucketIndices(absoluteValue)[0] DCNL DCSP if isinstance(self._classifierInputEncoder, DeltaEncoder): DCNL DCSP  DCSP if (not hasattr(self, '_ms_prevVal')): DCNL DCSP  DCSP  DCSP self._ms_prevVal = absoluteValue DCNL DCSP  DCSP prevValue = self._ms_prevVal DCNL DCSP  DCSP self._ms_prevVal = absoluteValue DCNL DCSP  DCSP actualValue = (absoluteValue - prevValue) DCNL DCSP else: DCNL DCSP  DCSP actualValue = absoluteValue DCNL DCSP if (isinstance(actualValue, float) and math.isnan(actualValue)): DCNL DCSP  DCSP actualValue = SENTINEL_VALUE_FOR_MISSING_DATA DCNL DCSP classifier.setParameter('inferenceMode', True) DCNL DCSP classifier.setParameter('learningMode', needLearning) DCNL DCSP classificationIn = {'bucketIdx': bucketIdx, 'actValue': actualValue} DCNL DCSP if (inputTSRecordIdx is not None): DCNL DCSP  DCSP recordNum = inputTSRecordIdx DCNL DCSP else: DCNL DCSP  DCSP recordNum = self.__numRunCalls DCNL DCSP clResults = classifier.getSelf().customCompute(recordNum=recordNum, patternNZ=patternNZ, classification=classificationIn) DCNL DCSP predictionSteps = classifier.getParameter('steps') DCNL DCSP predictionSteps = [int(x) for x in predictionSteps.split(',')] DCNL DCSP inferences[InferenceElement.multiStepPredictions] = dict() DCNL DCSP inferences[InferenceElement.multiStepBestPredictions] = dict() DCNL DCSP inferences[InferenceElement.multiStepBucketLikelihoods] = dict() DCNL DCSP for steps in predictionSteps: DCNL DCSP  DCSP likelihoodsVec = clResults[steps] DCNL DCSP  DCSP bucketValues = clResults['actualValues'] DCNL DCSP  DCSP likelihoodsDict = dict() DCNL DCSP  DCSP bestActValue = None DCNL DCSP  DCSP bestProb = None DCNL DCSP  DCSP for (actValue, prob) in zip(bucketValues, likelihoodsVec): DCNL DCSP  DCSP  DCSP if (actValue in likelihoodsDict): DCNL DCSP  DCSP  DCSP  DCSP likelihoodsDict[actValue] += prob DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP likelihoodsDict[actValue] = prob DCNL DCSP  DCSP  DCSP if ((bestProb is None) or (likelihoodsDict[actValue] > bestProb)): DCNL DCSP  DCSP  DCSP  DCSP bestProb = likelihoodsDict[actValue] DCNL DCSP  DCSP  DCSP  DCSP bestActValue = actValue DCNL DCSP  DCSP likelihoodsDict = HTMPredictionModel._removeUnlikelyPredictions(likelihoodsDict, minLikelihoodThreshold, maxPredictionsPerStep) DCNL DCSP  DCSP bucketLikelihood = {} DCNL DCSP  DCSP for k in likelihoodsDict.keys(): DCNL DCSP  DCSP  DCSP bucketLikelihood[self._classifierInputEncoder.getBucketIndices(k)[0]] = likelihoodsDict[k] DCNL DCSP  DCSP if isinstance(self._classifierInputEncoder, DeltaEncoder): DCNL DCSP  DCSP  DCSP if (not hasattr(self, '_ms_predHistories')): DCNL DCSP  DCSP  DCSP  DCSP self._ms_predHistories = dict() DCNL DCSP  DCSP  DCSP predHistories = self._ms_predHistories DCNL DCSP  DCSP  DCSP if (not (steps in predHistories)): DCNL DCSP  DCSP  DCSP  DCSP predHistories[steps] = deque() DCNL DCSP  DCSP  DCSP predHistory = predHistories[steps] DCNL DCSP  DCSP  DCSP sumDelta = sum(predHistory) DCNL DCSP  DCSP  DCSP offsetDict = dict() DCNL DCSP  DCSP  DCSP for (k, v) in likelihoodsDict.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP if (k is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offsetDict[((absoluteValue + float(k)) + sumDelta)] = v DCNL DCSP  DCSP  DCSP bucketLikelihoodOffset = {} DCNL DCSP  DCSP  DCSP for k in offsetDict.keys(): DCNL DCSP  DCSP  DCSP  DCSP bucketLikelihoodOffset[self._classifierInputEncoder.getBucketIndices(k)[0]] = offsetDict[k] DCNL DCSP  DCSP  DCSP if (bestActValue is not None): DCNL DCSP  DCSP  DCSP  DCSP predHistory.append(bestActValue) DCNL DCSP  DCSP  DCSP if (len(predHistory) >= steps): DCNL DCSP  DCSP  DCSP  DCSP predHistory.popleft() DCNL DCSP  DCSP  DCSP if (len(offsetDict) > 0): DCNL DCSP  DCSP  DCSP  DCSP inferences[InferenceElement.multiStepPredictions][steps] = offsetDict DCNL DCSP  DCSP  DCSP  DCSP inferences[InferenceElement.multiStepBucketLikelihoods][steps] = bucketLikelihoodOffset DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP inferences[InferenceElement.multiStepPredictions][steps] = likelihoodsDict DCNL DCSP  DCSP  DCSP  DCSP inferences[InferenceElement.multiStepBucketLikelihoods][steps] = bucketLikelihood DCNL DCSP  DCSP  DCSP if (bestActValue is None): DCNL DCSP  DCSP  DCSP  DCSP inferences[InferenceElement.multiStepBestPredictions][steps] = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP inferences[InferenceElement.multiStepBestPredictions][steps] = ((absoluteValue + sumDelta) + bestActValue) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inferences[InferenceElement.multiStepPredictions][steps] = likelihoodsDict DCNL DCSP  DCSP  DCSP inferences[InferenceElement.multiStepBestPredictions][steps] = bestActValue DCNL DCSP  DCSP  DCSP inferences[InferenceElement.multiStepBucketLikelihoods][steps] = bucketLikelihood DCNL DCSP return inferences
@classmethod DCNL def _removeUnlikelyPredictions(cls, likelihoodsDict, minLikelihoodThreshold, maxPredictionsPerStep): DCNL DCSP maxVal = (None, None) DCNL DCSP for (k, v) in likelihoodsDict.items(): DCNL DCSP  DCSP if (len(likelihoodsDict) <= 1): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if ((maxVal[0] is None) or (v >= maxVal[1])): DCNL DCSP  DCSP  DCSP if ((maxVal[0] is not None) and (maxVal[1] < minLikelihoodThreshold)): DCNL DCSP  DCSP  DCSP  DCSP del likelihoodsDict[maxVal[0]] DCNL DCSP  DCSP  DCSP maxVal = (k, v) DCNL DCSP  DCSP elif (v < minLikelihoodThreshold): DCNL DCSP  DCSP  DCSP del likelihoodsDict[k] DCNL DCSP likelihoodsDict = dict(sorted(likelihoodsDict.iteritems(), key=itemgetter(1), reverse=True)[:maxPredictionsPerStep]) DCNL DCSP return likelihoodsDict
def getRuntimeStats(self): DCNL DCSP ret = {'numRunCalls': self.__numRunCalls} DCNL DCSP temporalStats = dict() DCNL DCSP if self._hasTP: DCNL DCSP  DCSP for stat in self._netInfo.statsCollectors: DCNL DCSP  DCSP  DCSP sdict = stat.getStats() DCNL DCSP  DCSP  DCSP temporalStats.update(sdict) DCNL DCSP ret[InferenceType.getLabel(InferenceType.TemporalNextStep)] = temporalStats DCNL DCSP return ret
def _getLogger(self): DCNL DCSP return self.__logger
def _getSPRegion(self): DCNL DCSP return self._netInfo.net.regions.get('SP', None)
def _getTPRegion(self): DCNL DCSP return self._netInfo.net.regions.get('TM', None)
def _getSensorRegion(self): DCNL DCSP return self._netInfo.net.regions['sensor']
def _getClassifierRegion(self): DCNL DCSP if ((self._netInfo.net is not None) and ('Classifier' in self._netInfo.net.regions)): DCNL DCSP  DCSP return self._netInfo.net.regions['Classifier'] DCNL DCSP else: DCNL DCSP  DCSP return None
def _getEncoder(self): DCNL DCSP return self._getSensorRegion().getSelf().encoder
def _getClassifierOnlyEncoder(self): DCNL DCSP return self._getSensorRegion().getSelf().disabledEncoder
def _getDataSource(self): DCNL DCSP return self._getSensorRegion().getSelf().dataSource
def __createHTMNetwork(self, sensorParams, spEnable, spParams, tmEnable, tmParams, clEnable, clParams, anomalyParams): DCNL DCSP n = Network() DCNL DCSP n.addRegion('sensor', 'py.RecordSensor', json.dumps(dict(verbosity=sensorParams['verbosity']))) DCNL DCSP sensor = n.regions['sensor'].getSelf() DCNL DCSP enabledEncoders = copy.deepcopy(sensorParams['encoders']) DCNL DCSP for (name, params) in enabledEncoders.items(): DCNL DCSP  DCSP if (params is not None): DCNL DCSP  DCSP  DCSP classifierOnly = params.pop('classifierOnly', False) DCNL DCSP  DCSP  DCSP if classifierOnly: DCNL DCSP  DCSP  DCSP  DCSP enabledEncoders.pop(name) DCNL DCSP disabledEncoders = copy.deepcopy(sensorParams['encoders']) DCNL DCSP for (name, params) in disabledEncoders.items(): DCNL DCSP  DCSP if (params is None): DCNL DCSP  DCSP  DCSP disabledEncoders.pop(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP classifierOnly = params.pop('classifierOnly', False) DCNL DCSP  DCSP  DCSP if (not classifierOnly): DCNL DCSP  DCSP  DCSP  DCSP disabledEncoders.pop(name) DCNL DCSP encoder = MultiEncoder(enabledEncoders) DCNL DCSP sensor.encoder = encoder DCNL DCSP sensor.disabledEncoder = MultiEncoder(disabledEncoders) DCNL DCSP sensor.dataSource = DataBuffer() DCNL DCSP prevRegion = 'sensor' DCNL DCSP prevRegionWidth = encoder.getWidth() DCNL DCSP if spEnable: DCNL DCSP  DCSP spParams = spParams.copy() DCNL DCSP  DCSP spParams['inputWidth'] = prevRegionWidth DCNL DCSP  DCSP self.__logger.debug(('Adding DCSP SPRegion; DCSP spParams: DCSP %r' % spParams)) DCNL DCSP  DCSP n.addRegion('SP', 'py.SPRegion', json.dumps(spParams)) DCNL DCSP  DCSP n.link('sensor', 'SP', 'UniformLink', '') DCNL DCSP  DCSP n.link('sensor', 'SP', 'UniformLink', '', srcOutput='resetOut', destInput='resetIn') DCNL DCSP  DCSP n.link('SP', 'sensor', 'UniformLink', '', srcOutput='spatialTopDownOut', destInput='spatialTopDownIn') DCNL DCSP  DCSP n.link('SP', 'sensor', 'UniformLink', '', srcOutput='temporalTopDownOut', destInput='temporalTopDownIn') DCNL DCSP  DCSP prevRegion = 'SP' DCNL DCSP  DCSP prevRegionWidth = spParams['columnCount'] DCNL DCSP if tmEnable: DCNL DCSP  DCSP tmParams = tmParams.copy() DCNL DCSP  DCSP if (prevRegion == 'sensor'): DCNL DCSP  DCSP  DCSP tmParams['inputWidth'] = tmParams['columnCount'] = prevRegionWidth DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert (tmParams['columnCount'] == prevRegionWidth) DCNL DCSP  DCSP  DCSP tmParams['inputWidth'] = tmParams['columnCount'] DCNL DCSP  DCSP self.__logger.debug(('Adding DCSP TMRegion; DCSP tmParams: DCSP %r' % tmParams)) DCNL DCSP  DCSP n.addRegion('TM', 'py.TMRegion', json.dumps(tmParams)) DCNL DCSP  DCSP n.link(prevRegion, 'TM', 'UniformLink', '') DCNL DCSP  DCSP if (prevRegion != 'sensor'): DCNL DCSP  DCSP  DCSP n.link('TM', prevRegion, 'UniformLink', '', srcOutput='topDownOut', destInput='topDownIn') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP n.link('TM', prevRegion, 'UniformLink', '', srcOutput='topDownOut', destInput='temporalTopDownIn') DCNL DCSP  DCSP n.link('sensor', 'TM', 'UniformLink', '', srcOutput='resetOut', destInput='resetIn') DCNL DCSP  DCSP prevRegion = 'TM' DCNL DCSP  DCSP prevRegionWidth = tmParams['inputWidth'] DCNL DCSP if (clEnable and (clParams is not None)): DCNL DCSP  DCSP clParams = clParams.copy() DCNL DCSP  DCSP clRegionName = clParams.pop('regionName') DCNL DCSP  DCSP self.__logger.debug(('Adding DCSP %s; DCSP clParams: DCSP %r' % (clRegionName, clParams))) DCNL DCSP  DCSP n.addRegion('Classifier', ('py.%s' % str(clRegionName)), json.dumps(clParams)) DCNL DCSP  DCSP if (str(clRegionName) == 'SDRClassifierRegion'): DCNL DCSP  DCSP  DCSP n.link('sensor', 'Classifier', 'UniformLink', '', srcOutput='actValueOut', destInput='actValueIn') DCNL DCSP  DCSP  DCSP n.link('sensor', 'Classifier', 'UniformLink', '', srcOutput='bucketIdxOut', destInput='bucketIdxIn') DCNL DCSP  DCSP n.link('sensor', 'Classifier', 'UniformLink', '', srcOutput='categoryOut', destInput='categoryIn') DCNL DCSP  DCSP n.link(prevRegion, 'Classifier', 'UniformLink', '') DCNL DCSP if (self.getInferenceType() == InferenceType.TemporalAnomaly): DCNL DCSP  DCSP anomalyClParams = dict(trainRecords=anomalyParams.get('autoDetectWaitRecords', None), cacheSize=anomalyParams.get('anomalyCacheRecords', None)) DCNL DCSP  DCSP self._addAnomalyClassifierRegion(n, anomalyClParams, spEnable, tmEnable) DCNL DCSP n.initialize() DCNL DCSP return NetworkInfo(net=n, statsCollectors=[])
def __getstate__(self): DCNL DCSP state = self.__dict__.copy() DCNL DCSP state['_netInfo'] = NetworkInfo(net=None, statsCollectors=self._netInfo.statsCollectors) DCNL DCSP for ephemeral in [self.__manglePrivateMemberName('__restoringFromState'), self.__manglePrivateMemberName('__logger')]: DCNL DCSP  DCSP state.pop(ephemeral) DCNL DCSP return state
def __setstate__(self, state): DCNL DCSP self.__dict__.update(state) DCNL DCSP self.__restoringFromState = True DCNL DCSP self.__logger = initLogger(self) DCNL DCSP if (not hasattr(self, '_Model__inferenceType')): DCNL DCSP  DCSP self.__restoringFromV1 = True DCNL DCSP  DCSP self._hasSP = True DCNL DCSP  DCSP if (self.__temporalNetInfo is not None): DCNL DCSP  DCSP  DCSP self._Model__inferenceType = InferenceType.TemporalNextStep DCNL DCSP  DCSP  DCSP self._netInfo = self.__temporalNetInfo DCNL DCSP  DCSP  DCSP self._hasTP = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError('The DCSP Nontemporal DCSP inference DCSP type DCSP is DCSP not DCSP supported') DCNL DCSP  DCSP self._Model__inferenceArgs = {} DCNL DCSP  DCSP self._Model__learningEnabled = True DCNL DCSP  DCSP self._Model__inferenceEnabled = True DCNL DCSP  DCSP self.__dict__.pop('_HTMPredictionModel__encoderNetInfo', None) DCNL DCSP  DCSP self.__dict__.pop('_HTMPredictionModel__nonTemporalNetInfo', None) DCNL DCSP  DCSP self.__dict__.pop('_HTMPredictionModel__temporalNetInfo', None) DCNL DCSP if (not hasattr(self, '_netInfo')): DCNL DCSP  DCSP self._hasSP = False DCNL DCSP  DCSP self._hasTP = False DCNL DCSP  DCSP if (self.__encoderNetInfo is not None): DCNL DCSP  DCSP  DCSP self._netInfo = self.__encoderNetInfo DCNL DCSP  DCSP elif (self.__nonTemporalNetInfo is not None): DCNL DCSP  DCSP  DCSP self._netInfo = self.__nonTemporalNetInfo DCNL DCSP  DCSP  DCSP self._hasSP = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._netInfo = self.__temporalNetInfo DCNL DCSP  DCSP  DCSP self._hasSP = True DCNL DCSP  DCSP  DCSP self._hasTP = True DCNL DCSP  DCSP self.__dict__.pop('_HTMPredictionModel__encoderNetInfo', None) DCNL DCSP  DCSP self.__dict__.pop('_HTMPredictionModel__nonTemporalNetInfo', None) DCNL DCSP  DCSP self.__dict__.pop('_HTMPredictionModel__temporalNetInfo', None) DCNL DCSP self._classifierInputEncoder = None DCNL DCSP if (not hasattr(self, '_minLikelihoodThreshold')): DCNL DCSP  DCSP self._minLikelihoodThreshold = DEFAULT_LIKELIHOOD_THRESHOLD DCNL DCSP if (not hasattr(self, '_maxPredictionsPerStep')): DCNL DCSP  DCSP self._maxPredictionsPerStep = DEFAULT_MAX_PREDICTIONS_PER_STEP DCNL DCSP if (not hasattr(self, '_hasCL')): DCNL DCSP  DCSP self._hasCL = (self._getClassifierRegion() is not None) DCNL DCSP self.__logger.debug(('Restoring DCSP %s DCSP from DCSP state...' % self.__class__.__name__))
def write(self, proto): DCNL DCSP super(HTMPredictionModel, self).writeBaseToProto(proto.modelBase) DCNL DCSP proto.numRunCalls = self.__numRunCalls DCNL DCSP proto.minLikelihoodThreshold = self._minLikelihoodThreshold DCNL DCSP proto.maxPredictionsPerStep = self._maxPredictionsPerStep DCNL DCSP self._netInfo.net.write(proto.network)
@classmethod DCNL def read(cls, proto): DCNL DCSP network = Network.read(proto.network) DCNL DCSP spEnable = ('SP' in network.regions) DCNL DCSP tmEnable = ('TM' in network.regions) DCNL DCSP clEnable = ('Classifier' in network.regions) DCNL DCSP model = cls(spEnable=spEnable, tmEnable=tmEnable, clEnable=clEnable, network=network, baseProto=proto.modelBase) DCNL DCSP model.__numRunCalls = proto.numRunCalls DCNL DCSP model._minLikelihoodThreshold = proto.minLikelihoodThreshold DCNL DCSP model._maxPredictionsPerStep = proto.maxPredictionsPerStep DCNL DCSP model._getSensorRegion().getSelf().dataSource = DataBuffer() DCNL DCSP model._netInfo.net.initialize() DCNL DCSP model.__restoringFromState = False DCNL DCSP return model
def _serializeExtraData(self, extraDataDir): DCNL DCSP makeDirectoryFromAbsolutePath(extraDataDir) DCNL DCSP outputDir = self.__getNetworkStateDirectory(extraDataDir=extraDataDir) DCNL DCSP self.__logger.debug('Serializing DCSP network...') DCNL DCSP self._netInfo.net.save(outputDir) DCNL DCSP self.__logger.debug('Finished DCSP serializing DCSP network') DCNL DCSP return
def _deSerializeExtraData(self, extraDataDir): DCNL DCSP assert self.__restoringFromState DCNL DCSP assert (self._netInfo.net is None), 'Network DCSP was DCSP already DCSP unpickled' DCNL DCSP stateDir = self.__getNetworkStateDirectory(extraDataDir=extraDataDir) DCNL DCSP self.__logger.debug('(%s) DCSP De-serializing DCSP network...', self) DCNL DCSP self._netInfo.net = Network(stateDir) DCNL DCSP self.__logger.debug('(%s) DCSP Finished DCSP de-serializing DCSP network', self) DCNL DCSP self._netInfo.net.initialize() DCNL DCSP if (self.getInferenceType() == InferenceType.TemporalAnomaly): DCNL DCSP  DCSP classifierType = self._getAnomalyClassifier().getSelf().__class__.__name__ DCNL DCSP  DCSP if (classifierType is 'KNNClassifierRegion'): DCNL DCSP  DCSP  DCSP anomalyClParams = dict(trainRecords=self._classifier_helper._autoDetectWaitRecords, cacheSize=self._classifier_helper._history_length) DCNL DCSP  DCSP  DCSP spEnable = (self._getSPRegion() is not None) DCNL DCSP  DCSP  DCSP tmEnable = True DCNL DCSP  DCSP  DCSP knnRegion = self._getAnomalyClassifier().getSelf() DCNL DCSP  DCSP  DCSP self._addAnomalyClassifierRegion(self._netInfo.net, anomalyClParams, spEnable, tmEnable) DCNL DCSP  DCSP  DCSP self._getAnomalyClassifier().getSelf()._iteration = self.__numRunCalls DCNL DCSP  DCSP  DCSP self._getAnomalyClassifier().getSelf()._recordsCache = self._classifier_helper.saved_states DCNL DCSP  DCSP  DCSP self._getAnomalyClassifier().getSelf().saved_categories = self._classifier_helper.saved_categories DCNL DCSP  DCSP  DCSP self._getAnomalyClassifier().getSelf()._knnclassifier = knnRegion DCNL DCSP  DCSP  DCSP self._getTPRegion().setParameter('anomalyMode', True) DCNL DCSP  DCSP  DCSP del self._classifier_helper DCNL DCSP  DCSP  DCSP self._netInfo.net.initialize() DCNL DCSP self.__restoringFromState = False DCNL DCSP self.__logger.debug('(%s) DCSP Finished DCSP restoring DCSP from DCSP state', self) DCNL DCSP return
def _addAnomalyClassifierRegion(self, network, params, spEnable, tmEnable): DCNL DCSP allParams = copy.deepcopy(params) DCNL DCSP knnParams = dict(k=1, distanceMethod='rawOverlap', distanceNorm=1, doBinarization=1, replaceDuplicates=0, maxStoredPatterns=1000) DCNL DCSP allParams.update(knnParams) DCNL DCSP if (allParams['trainRecords'] is None): DCNL DCSP  DCSP allParams['trainRecords'] = DEFAULT_ANOMALY_TRAINRECORDS DCNL DCSP if (allParams['cacheSize'] is None): DCNL DCSP  DCSP allParams['cacheSize'] = DEFAULT_ANOMALY_CACHESIZE DCNL DCSP if ((self._netInfo is not None) and (self._netInfo.net is not None) and (self._getAnomalyClassifier() is not None)): DCNL DCSP  DCSP self._netInfo.net.removeRegion('AnomalyClassifier') DCNL DCSP network.addRegion('AnomalyClassifier', 'py.KNNAnomalyClassifierRegion', json.dumps(allParams)) DCNL DCSP if spEnable: DCNL DCSP  DCSP network.link('SP', 'AnomalyClassifier', 'UniformLink', '', srcOutput='bottomUpOut', destInput='spBottomUpOut') DCNL DCSP else: DCNL DCSP  DCSP network.link('sensor', 'AnomalyClassifier', 'UniformLink', '', srcOutput='dataOut', destInput='spBottomUpOut') DCNL DCSP if tmEnable: DCNL DCSP  DCSP network.link('TM', 'AnomalyClassifier', 'UniformLink', '', srcOutput='topDownOut', destInput='tpTopDownOut') DCNL DCSP  DCSP network.link('TM', 'AnomalyClassifier', 'UniformLink', '', srcOutput='lrnActiveStateT', destInput='tpLrnActiveStateT') DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('TemporalAnomaly DCSP models DCSP require DCSP a DCSP TM DCSP region.')
def __getNetworkStateDirectory(self, extraDataDir): DCNL DCSP if self.__restoringFromV1: DCNL DCSP  DCSP if (self.getInferenceType() == InferenceType.TemporalNextStep): DCNL DCSP  DCSP  DCSP leafName = ('temporal' + '-network.nta') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP leafName = ('nonTemporal' + '-network.nta') DCNL DCSP else: DCNL DCSP  DCSP leafName = (InferenceType.getLabel(self.getInferenceType()) + '-network.nta') DCNL DCSP path = os.path.join(extraDataDir, leafName) DCNL DCSP path = os.path.abspath(path) DCNL DCSP return path
def __manglePrivateMemberName(self, privateMemberName, skipCheck=False): DCNL DCSP assert privateMemberName.startswith('__'), ("%r DCSP doesn't DCSP start DCSP with DCSP __" % privateMemberName) DCNL DCSP assert (not privateMemberName.startswith('___')), ('%r DCSP starts DCSP with DCSP ___' % privateMemberName) DCNL DCSP assert (not privateMemberName.endswith('__')), ('%r DCSP ends DCSP with DCSP more DCSP than DCSP one DCSP underscore' % privateMemberName) DCNL DCSP realName = (('_' + self.__myClassName.lstrip('_')) + privateMemberName) DCNL DCSP if (not skipCheck): DCNL DCSP  DCSP getattr(self, realName) DCNL DCSP return realName
def __init__(self, *args, **kwargs): DCNL DCSP self.supported_nodes = tuple((set(self.supported_nodes) - self.blacklisted_nodes)) DCNL DCSP asteval.Interpreter.__init__(self, *args, **kwargs)
def __validateExperimentControl(self, control): DCNL DCSP taskList = control.get('tasks', None) DCNL DCSP if (taskList is not None): DCNL DCSP  DCSP taskLabelsList = [] DCNL DCSP  DCSP for task in taskList: DCNL DCSP  DCSP  DCSP validateOpfJsonValue(task, 'opfTaskSchema.json') DCNL DCSP  DCSP  DCSP validateOpfJsonValue(task['taskControl'], 'opfTaskControlSchema.json') DCNL DCSP  DCSP  DCSP taskLabel = task['taskLabel'] DCNL DCSP  DCSP  DCSP assert isinstance(taskLabel, types.StringTypes), ('taskLabel DCSP type: DCSP %r' % type(taskLabel)) DCNL DCSP  DCSP  DCSP assert (len(taskLabel) > 0), 'empty DCSP string DCSP taskLabel DCSP not DCSP is DCSP allowed' DCNL DCSP  DCSP  DCSP taskLabelsList.append(taskLabel.lower()) DCNL DCSP  DCSP taskLabelDuplicates = filter((lambda x: (taskLabelsList.count(x) > 1)), taskLabelsList) DCNL DCSP  DCSP assert (len(taskLabelDuplicates) == 0), ('Duplcate DCSP task DCSP labels DCSP are DCSP not DCSP allowed: DCSP %s' % taskLabelDuplicates) DCNL DCSP return
def __validateNupicControl(self, control): DCNL DCSP validateOpfJsonValue(control, 'nupicControlSchema.json')
def normalizeStreamSource(self, stream): DCNL DCSP source = stream['source'][len(FILE_SCHEME):] DCNL DCSP if os.path.isabs(source): DCNL DCSP  DCSP sourcePath = source DCNL DCSP else: DCNL DCSP  DCSP sourcePath = resource_filename('nupic.datafiles', source) DCNL DCSP  DCSP if (not os.path.exists(sourcePath)): DCNL DCSP  DCSP  DCSP sourcePath = os.path.join(os.getcwd(), source) DCNL DCSP stream['source'] = (FILE_SCHEME + sourcePath)
def normalizeStreamSources(self): DCNL DCSP task = dict(self.__control) DCNL DCSP if ('dataset' in task): DCNL DCSP  DCSP for stream in task['dataset']['streams']: DCNL DCSP  DCSP  DCSP self.normalizeStreamSource(stream) DCNL DCSP else: DCNL DCSP  DCSP for subtask in task['tasks']: DCNL DCSP  DCSP  DCSP for stream in subtask['dataset']['streams']: DCNL DCSP  DCSP  DCSP  DCSP self.normalizeStreamSource(stream)
def convertNupicEnvToOPF(self): DCNL DCSP task = dict(self.__control) DCNL DCSP task.pop('environment') DCNL DCSP inferenceArgs = task.pop('inferenceArgs') DCNL DCSP task['taskLabel'] = 'DefaultTask' DCNL DCSP iterationCount = task.get('iterationCount', (-1)) DCNL DCSP iterationCountInferOnly = task.pop('iterationCountInferOnly', 0) DCNL DCSP if (iterationCountInferOnly == (-1)): DCNL DCSP  DCSP iterationCycle = [IterationPhaseSpecInferOnly(1000, inferenceArgs=inferenceArgs)] DCNL DCSP elif (iterationCountInferOnly > 0): DCNL DCSP  DCSP assert (iterationCount > 0), 'When DCSP iterationCountInferOnly DCSP is DCSP specified, DCSP iterationCount DCSP must DCSP also DCSP be DCSP specified DCSP and DCSP not DCSP be DCSP -1' DCNL DCSP  DCSP iterationCycle = [IterationPhaseSpecLearnAndInfer((iterationCount - iterationCountInferOnly), inferenceArgs=inferenceArgs), IterationPhaseSpecInferOnly(iterationCountInferOnly, inferenceArgs=inferenceArgs)] DCNL DCSP else: DCNL DCSP  DCSP iterationCycle = [IterationPhaseSpecLearnAndInfer(1000, inferenceArgs=inferenceArgs)] DCNL DCSP taskControl = dict(metrics=task.pop('metrics'), loggedMetrics=task.pop('loggedMetrics'), iterationCycle=iterationCycle) DCNL DCSP task['taskControl'] = taskControl DCNL DCSP self.__control = dict(environment=OpfEnvironment.Nupic, tasks=[task])
def __init__(self, requestedActivities=[]): DCNL DCSP self.__activities = [] DCNL DCSP self.__appendActivities(requestedActivities) DCNL DCSP return
def addActivities(self, periodicActivities): DCNL DCSP self.__appendActivities(periodicActivities) DCNL DCSP return
def tick(self): DCNL DCSP for act in self.__activities: DCNL DCSP  DCSP if (not act.iteratorHolder[0]): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP next(act.iteratorHolder[0]) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP act.cb() DCNL DCSP  DCSP  DCSP if act.repeating: DCNL DCSP  DCSP  DCSP  DCSP act.iteratorHolder[0] = iter(xrange((act.period - 1))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP act.iteratorHolder[0] = None DCNL DCSP return True
def __appendActivities(self, periodicActivities): DCNL DCSP for req in periodicActivities: DCNL DCSP  DCSP act = self.Activity(repeating=req.repeating, period=req.period, cb=req.cb, iteratorHolder=[iter(xrange((req.period - 1)))]) DCNL DCSP  DCSP self.__activities.append(act) DCNL DCSP return
def addLabel(self, start, end, labelName): DCNL DCSP if (len(self.saved_states) == 0): DCNL DCSP  DCSP raise HTMPredictionModelInvalidRangeError("Invalid DCSP supplied DCSP range DCSP for DCSP 'addLabel'. DCSP Model DCSP has DCSP no DCSP saved DCSP records.") DCNL DCSP startID = self.saved_states[0].ROWID DCNL DCSP clippedStart = max(0, (start - startID)) DCNL DCSP clippedEnd = max(0, min(len(self.saved_states), (end - startID))) DCNL DCSP if (clippedEnd <= clippedStart): DCNL DCSP  DCSP raise HTMPredictionModelInvalidRangeError("Invalid DCSP supplied DCSP range DCSP for DCSP 'addLabel'.", debugInfo={'requestRange': {'startRecordID': start, 'endRecordID': end}, 'clippedRequestRange': {'startRecordID': clippedStart, 'endRecordID': clippedEnd}, 'validRange': {'startRecordID': startID, 'endRecordID': self.saved_states[(len(self.saved_states) - 1)].ROWID}, 'numRecordsStored': len(self.saved_states)}) DCNL DCSP for state in self.saved_states[clippedStart:clippedEnd]: DCNL DCSP  DCSP if (labelName not in state.anomalyLabel): DCNL DCSP  DCSP  DCSP state.anomalyLabel.append(labelName) DCNL DCSP  DCSP  DCSP state.setByUser = True DCNL DCSP  DCSP  DCSP self._addRecordToKNN(state) DCNL DCSP assert (len(self.saved_categories) > 0) DCNL DCSP for state in self.saved_states[clippedEnd:]: DCNL DCSP  DCSP self._updateState(state)
def removeLabels(self, start=None, end=None, labelFilter=None): DCNL DCSP if (len(self.saved_states) == 0): DCNL DCSP  DCSP raise HTMPredictionModelInvalidRangeError("Invalid DCSP supplied DCSP range DCSP for DCSP 'removeLabels'. DCSP Model DCSP has DCSP no DCSP saved DCSP records.") DCNL DCSP startID = self.saved_states[0].ROWID DCNL DCSP clippedStart = (0 if (start is None) else max(0, (start - startID))) DCNL DCSP clippedEnd = (len(self.saved_states) if (end is None) else max(0, min(len(self.saved_states), (end - startID)))) DCNL DCSP if (clippedEnd <= clippedStart): DCNL DCSP  DCSP raise HTMPredictionModelInvalidRangeError("Invalid DCSP supplied DCSP range DCSP for DCSP 'removeLabels'.", debugInfo={'requestRange': {'startRecordID': start, 'endRecordID': end}, 'clippedRequestRange': {'startRecordID': clippedStart, 'endRecordID': clippedEnd}, 'validRange': {'startRecordID': startID, 'endRecordID': self.saved_states[(len(self.saved_states) - 1)].ROWID}, 'numRecordsStored': len(self.saved_states)}) DCNL DCSP recordsToDelete = [] DCNL DCSP for state in self.saved_states[clippedStart:clippedEnd]: DCNL DCSP  DCSP if (labelFilter is not None): DCNL DCSP  DCSP  DCSP if (labelFilter in state.anomalyLabel): DCNL DCSP  DCSP  DCSP  DCSP state.anomalyLabel.remove(labelFilter) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP state.anomalyLabel = [] DCNL DCSP  DCSP state.setByUser = False DCNL DCSP  DCSP recordsToDelete.append(state) DCNL DCSP self._deleteRecordsFromKNN(recordsToDelete) DCNL DCSP self._deleteRangeFromKNN(start, end) DCNL DCSP for state in self.saved_states[clippedEnd:]: DCNL DCSP  DCSP self._updateState(state) DCNL DCSP return {'status': 'success'}
def _addRecordToKNN(self, record): DCNL DCSP classifier = self.htm_prediction_model._getAnomalyClassifier() DCNL DCSP knn = classifier.getSelf()._knn DCNL DCSP prototype_idx = classifier.getSelf().getParameter('categoryRecencyList') DCNL DCSP category = self._labelListToCategoryNumber(record.anomalyLabel) DCNL DCSP if (record.ROWID in prototype_idx): DCNL DCSP  DCSP knn.prototypeSetCategory(record.ROWID, category) DCNL DCSP  DCSP return DCNL DCSP pattern = self._getStateAnomalyVector(record) DCNL DCSP rowID = record.ROWID DCNL DCSP knn.learn(pattern, category, rowID=rowID)
def _deleteRecordsFromKNN(self, recordsToDelete): DCNL DCSP classifier = self.htm_prediction_model._getAnomalyClassifier() DCNL DCSP knn = classifier.getSelf()._knn DCNL DCSP prototype_idx = classifier.getSelf().getParameter('categoryRecencyList') DCNL DCSP idsToDelete = [r.ROWID for r in recordsToDelete if ((not r.setByUser) and (r.ROWID in prototype_idx))] DCNL DCSP nProtos = knn._numPatterns DCNL DCSP knn.removeIds(idsToDelete) DCNL DCSP assert (knn._numPatterns == (nProtos - len(idsToDelete)))
def _deleteRangeFromKNN(self, start=0, end=None): DCNL DCSP classifier = self.htm_prediction_model._getAnomalyClassifier() DCNL DCSP knn = classifier.getSelf()._knn DCNL DCSP prototype_idx = numpy.array(classifier.getSelf().getParameter('categoryRecencyList')) DCNL DCSP if (end is None): DCNL DCSP  DCSP end = (prototype_idx.max() + 1) DCNL DCSP idsIdxToDelete = numpy.logical_and((prototype_idx >= start), (prototype_idx < end)) DCNL DCSP idsToDelete = prototype_idx[idsIdxToDelete] DCNL DCSP nProtos = knn._numPatterns DCNL DCSP knn.removeIds(idsToDelete.tolist()) DCNL DCSP assert (knn._numPatterns == (nProtos - len(idsToDelete)))
def _recomputeRecordFromKNN(self, record): DCNL DCSP inputs = {'categoryIn': [None], 'bottomUpIn': self._getStateAnomalyVector(record)} DCNL DCSP outputs = {'categoriesOut': numpy.zeros((1,)), 'bestPrototypeIndices': numpy.zeros((1,)), 'categoryProbabilitiesOut': numpy.zeros((1,))} DCNL DCSP classifier = self.htm_prediction_model._getAnomalyClassifier() DCNL DCSP knn = classifier.getSelf()._knn DCNL DCSP classifier_indexes = numpy.array(classifier.getSelf().getParameter('categoryRecencyList')) DCNL DCSP valid_idx = numpy.where(((classifier_indexes >= self._autoDetectWaitRecords) & (classifier_indexes < record.ROWID)))[0].tolist() DCNL DCSP if (len(valid_idx) == 0): DCNL DCSP  DCSP return None DCNL DCSP classifier.setParameter('inferenceMode', True) DCNL DCSP classifier.setParameter('learningMode', False) DCNL DCSP classifier.getSelf().compute(inputs, outputs) DCNL DCSP classifier.setParameter('learningMode', True) DCNL DCSP classifier_distances = classifier.getSelf().getLatestDistances() DCNL DCSP valid_distances = classifier_distances[valid_idx] DCNL DCSP if (valid_distances.min() <= self._classificationMaxDist): DCNL DCSP  DCSP classifier_indexes_prev = classifier_indexes[valid_idx] DCNL DCSP  DCSP rowID = classifier_indexes_prev[valid_distances.argmin()] DCNL DCSP  DCSP indexID = numpy.where((classifier_indexes == rowID))[0][0] DCNL DCSP  DCSP category = classifier.getSelf().getCategoryList()[indexID] DCNL DCSP  DCSP return category DCNL DCSP return None
def _constructClassificationRecord(self): DCNL DCSP model = self.htm_prediction_model DCNL DCSP sp = model._getSPRegion() DCNL DCSP tm = model._getTPRegion() DCNL DCSP tpImp = tm.getSelf()._tfdr DCNL DCSP activeColumns = sp.getOutputData('bottomUpOut').nonzero()[0] DCNL DCSP score = numpy.in1d(activeColumns, self._prevPredictedColumns).sum() DCNL DCSP score = ((self._activeColumnCount - score) / float(self._activeColumnCount)) DCNL DCSP spSize = sp.getParameter('activeOutputCount') DCNL DCSP tpSize = (tm.getParameter('cellsPerColumn') * tm.getParameter('columnCount')) DCNL DCSP classificationVector = numpy.array([]) DCNL DCSP if (self._vectorType == 'tpc'): DCNL DCSP  DCSP classificationVector = numpy.zeros(tpSize) DCNL DCSP  DCSP activeCellMatrix = tpImp.getLearnActiveStateT().reshape(tpSize, 1) DCNL DCSP  DCSP activeCellIdx = numpy.where((activeCellMatrix > 0))[0] DCNL DCSP  DCSP if (activeCellIdx.shape[0] > 0): DCNL DCSP  DCSP  DCSP classificationVector[numpy.array(activeCellIdx, dtype=numpy.uint16)] = 1 DCNL DCSP elif (self._vectorType == 'sp_tpe'): DCNL DCSP  DCSP classificationVector = numpy.zeros((spSize + spSize)) DCNL DCSP  DCSP if (activeColumns.shape[0] > 0): DCNL DCSP  DCSP  DCSP classificationVector[activeColumns] = 1.0 DCNL DCSP  DCSP errorColumns = numpy.setdiff1d(self._prevPredictedColumns, activeColumns) DCNL DCSP  DCSP if (errorColumns.shape[0] > 0): DCNL DCSP  DCSP  DCSP errorColumnIndexes = (numpy.array(errorColumns, dtype=numpy.uint16) + spSize) DCNL DCSP  DCSP  DCSP classificationVector[errorColumnIndexes] = 1.0 DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(("Classification DCSP vector DCSP type DCSP must DCSP be DCSP either DCSP 'tpc' DCSP or DCSP 'sp_tpe', DCSP current DCSP value DCSP is DCSP %s" % self._vectorType)) DCNL DCSP numPredictedCols = len(self._prevPredictedColumns) DCNL DCSP predictedColumns = tm.getOutputData('topDownOut').nonzero()[0] DCNL DCSP self._prevPredictedColumns = copy.deepcopy(predictedColumns) DCNL DCSP if (self._anomalyVectorLength is None): DCNL DCSP  DCSP self._anomalyVectorLength = len(classificationVector) DCNL DCSP result = _CLAClassificationRecord(ROWID=int((model.getParameter('__numRunCalls') - 1)), anomalyScore=score, anomalyVector=classificationVector.nonzero()[0].tolist(), anomalyLabel=[]) DCNL DCSP return result
def compute(self): DCNL DCSP result = self._constructClassificationRecord() DCNL DCSP if (result.ROWID >= self._autoDetectWaitRecords): DCNL DCSP  DCSP self._updateState(result) DCNL DCSP self.saved_states.append(result) DCNL DCSP if (len(self.saved_states) > self._history_length): DCNL DCSP  DCSP self.saved_states.pop(0) DCNL DCSP return result
def setAutoDetectWaitRecords(self, waitRecords): DCNL DCSP if (not isinstance(waitRecords, int)): DCNL DCSP  DCSP raise HTMPredictionModelInvalidArgument(("Invalid DCSP argument DCSP type DCSP '%s'. DCSP WaitRecord DCSP must DCSP be DCSP a DCSP number." % type(waitRecords))) DCNL DCSP if ((len(self.saved_states) > 0) and (waitRecords < self.saved_states[0].ROWID)): DCNL DCSP  DCSP raise HTMPredictionModelInvalidArgument(('Invalid DCSP value. DCSP autoDetectWaitRecord DCSP value DCSP must DCSP be DCSP valid DCSP record DCSP within DCSP output DCSP stream. DCSP Current DCSP minimum DCSP ROWID DCSP in DCSP output DCSP stream DCSP is DCSP %d.' % self.saved_states[0].ROWID)) DCNL DCSP self._autoDetectWaitRecords = waitRecords DCNL DCSP for state in self.saved_states: DCNL DCSP  DCSP self._updateState(state)
def getAutoDetectWaitRecords(self): DCNL DCSP return self._autoDetectWaitRecords
def setAutoDetectThreshold(self, threshold): DCNL DCSP if (not (isinstance(threshold, float) or isinstance(threshold, int))): DCNL DCSP  DCSP raise HTMPredictionModelInvalidArgument(("Invalid DCSP argument DCSP type DCSP '%s'. DCSP threshold DCSP must DCSP be DCSP a DCSP number." % type(threshold))) DCNL DCSP self._autoDetectThreshold = threshold DCNL DCSP for state in self.saved_states: DCNL DCSP  DCSP self._updateState(state)
def getAutoDetectThreshold(self): DCNL DCSP return self._autoDetectThreshold
def _labelToCategoryNumber(self, label): DCNL DCSP if (label not in self.saved_categories): DCNL DCSP  DCSP self.saved_categories.append(label) DCNL DCSP return pow(2, self.saved_categories.index(label))
def _labelListToCategoryNumber(self, labelList): DCNL DCSP categoryNumber = 0 DCNL DCSP for label in labelList: DCNL DCSP  DCSP categoryNumber += self._labelToCategoryNumber(label) DCNL DCSP return categoryNumber
def _categoryToLabelList(self, category): DCNL DCSP if (category is None): DCNL DCSP  DCSP return [] DCNL DCSP labelList = [] DCNL DCSP labelNum = 0 DCNL DCSP while (category > 0): DCNL DCSP  DCSP if ((category % 2) == 1): DCNL DCSP  DCSP  DCSP labelList.append(self.saved_categories[labelNum]) DCNL DCSP  DCSP labelNum += 1 DCNL DCSP  DCSP category = (category >> 1) DCNL DCSP return labelList
def _getStateAnomalyVector(self, state): DCNL DCSP vector = numpy.zeros(self._anomalyVectorLength) DCNL DCSP vector[state.anomalyVector] = 1 DCNL DCSP return vector
def __init__(self, windowSize, existingHistoricalValues=None): DCNL DCSP if (not isinstance(windowSize, numbers.Integral)): DCNL DCSP  DCSP raise TypeError('MovingAverage DCSP - DCSP windowSize DCSP must DCSP be DCSP integer DCSP type') DCNL DCSP if (windowSize <= 0): DCNL DCSP  DCSP raise ValueError('MovingAverage DCSP - DCSP windowSize DCSP must DCSP be DCSP >0') DCNL DCSP self.windowSize = windowSize DCNL DCSP if (existingHistoricalValues is not None): DCNL DCSP  DCSP self.slidingWindow = existingHistoricalValues[(len(existingHistoricalValues) - windowSize):] DCNL DCSP else: DCNL DCSP  DCSP self.slidingWindow = [] DCNL DCSP self.total = float(sum(self.slidingWindow))
@staticmethod DCNL def compute(slidingWindow, total, newVal, windowSize): DCNL DCSP if (len(slidingWindow) == windowSize): DCNL DCSP  DCSP total -= slidingWindow.pop(0) DCNL DCSP slidingWindow.append(newVal) DCNL DCSP total += newVal DCNL DCSP return ((float(total) / len(slidingWindow)), slidingWindow, total)
def next(self, newValue): DCNL DCSP (newAverage, self.slidingWindow, self.total) = self.compute(self.slidingWindow, self.total, newValue, self.windowSize) DCNL DCSP return newAverage
def getCurrentAvg(self): DCNL DCSP return (float(self.total) / len(self.slidingWindow))
def __setstate__(self, state): DCNL DCSP self.__dict__.update(state) DCNL DCSP if (not hasattr(self, 'slidingWindow')): DCNL DCSP  DCSP self.slidingWindow = [] DCNL DCSP if (not hasattr(self, 'total')): DCNL DCSP  DCSP self.total = 0 DCNL DCSP  DCSP self.slidingWindow = sum(self.slidingWindow)
@classmethod DCNL @abstractmethod DCNL def getSchema(cls): DCNL DCSP pass
@classmethod DCNL @abstractmethod DCNL def read(cls, proto): DCNL DCSP pass
@abstractmethod DCNL def write(self, proto): DCNL DCSP pass
@classmethod DCNL def readFromFile(cls, f, packed=True): DCNL DCSP schema = cls.getSchema() DCNL DCSP if packed: DCNL DCSP  DCSP proto = schema.read_packed(f) DCNL DCSP else: DCNL DCSP  DCSP proto = schema.read(f) DCNL DCSP return cls.read(proto)
def writeToFile(self, f, packed=True): DCNL DCSP schema = self.getSchema() DCNL DCSP proto = schema.new_message() DCNL DCSP self.write(proto) DCNL DCSP if packed: DCNL DCSP  DCSP proto.write_packed(f) DCNL DCSP else: DCNL DCSP  DCSP proto.write(f)
@staticmethod DCNL def connectionsFactory(*args, **kwargs): DCNL DCSP return Connections(*args, **kwargs)
def compute(self, activeColumns, learn=True): DCNL DCSP self.activateCells(sorted(activeColumns), learn) DCNL DCSP self.activateDendrites(learn)
def activateCells(self, activeColumns, learn=True): DCNL DCSP prevActiveCells = self.activeCells DCNL DCSP prevWinnerCells = self.winnerCells DCNL DCSP self.activeCells = [] DCNL DCSP self.winnerCells = [] DCNL DCSP segToCol = (lambda segment: int((segment.cell / self.cellsPerColumn))) DCNL DCSP identity = (lambda x: x) DCNL DCSP for columnData in groupby2(activeColumns, identity, self.activeSegments, segToCol, self.matchingSegments, segToCol): DCNL DCSP  DCSP (column, activeColumns, columnActiveSegments, columnMatchingSegments) = columnData DCNL DCSP  DCSP if (activeColumns is not None): DCNL DCSP  DCSP  DCSP if (columnActiveSegments is not None): DCNL DCSP  DCSP  DCSP  DCSP cellsToAdd = self.activatePredictedColumn(column, columnActiveSegments, columnMatchingSegments, prevActiveCells, prevWinnerCells, learn) DCNL DCSP  DCSP  DCSP  DCSP self.activeCells += cellsToAdd DCNL DCSP  DCSP  DCSP  DCSP self.winnerCells += cellsToAdd DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (cellsToAdd, winnerCell) = self.burstColumn(column, columnMatchingSegments, prevActiveCells, prevWinnerCells, learn) DCNL DCSP  DCSP  DCSP  DCSP self.activeCells += cellsToAdd DCNL DCSP  DCSP  DCSP  DCSP self.winnerCells.append(winnerCell) DCNL DCSP  DCSP elif learn: DCNL DCSP  DCSP  DCSP self.punishPredictedColumn(column, columnActiveSegments, columnMatchingSegments, prevActiveCells, prevWinnerCells)
def activateDendrites(self, learn=True): DCNL DCSP (numActiveConnected, numActivePotential) = self.connections.computeActivity(self.activeCells, self.connectedPermanence) DCNL DCSP activeSegments = (self.connections.segmentForFlatIdx(i) for i in xrange(len(numActiveConnected)) if (numActiveConnected[i] >= self.activationThreshold)) DCNL DCSP matchingSegments = (self.connections.segmentForFlatIdx(i) for i in xrange(len(numActivePotential)) if (numActivePotential[i] >= self.minThreshold)) DCNL DCSP self.activeSegments = sorted(activeSegments, key=self.connections.segmentPositionSortKey) DCNL DCSP self.matchingSegments = sorted(matchingSegments, key=self.connections.segmentPositionSortKey) DCNL DCSP self.numActiveConnectedSynapsesForSegment = numActiveConnected DCNL DCSP self.numActivePotentialSynapsesForSegment = numActivePotential DCNL DCSP if learn: DCNL DCSP  DCSP for segment in self.activeSegments: DCNL DCSP  DCSP  DCSP self.lastUsedIterationForSegment[segment.flatIdx] = self.iteration DCNL DCSP  DCSP self.iteration += 1
def reset(self): DCNL DCSP self.activeCells = [] DCNL DCSP self.winnerCells = [] DCNL DCSP self.activeSegments = [] DCNL DCSP self.matchingSegments = []
def activatePredictedColumn(self, column, columnActiveSegments, columnMatchingSegments, prevActiveCells, prevWinnerCells, learn): DCNL DCSP return self._activatePredictedColumn(self.connections, self._random, columnActiveSegments, prevActiveCells, prevWinnerCells, self.numActivePotentialSynapsesForSegment, self.maxNewSynapseCount, self.initialPermanence, self.permanenceIncrement, self.permanenceDecrement, self.maxSynapsesPerSegment, learn)
def burstColumn(self, column, columnMatchingSegments, prevActiveCells, prevWinnerCells, learn): DCNL DCSP start = (self.cellsPerColumn * column) DCNL DCSP cellsForColumn = xrange(start, (start + self.cellsPerColumn)) DCNL DCSP return self._burstColumn(self.connections, self._random, self.lastUsedIterationForSegment, column, columnMatchingSegments, prevActiveCells, prevWinnerCells, cellsForColumn, self.numActivePotentialSynapsesForSegment, self.iteration, self.maxNewSynapseCount, self.initialPermanence, self.permanenceIncrement, self.permanenceDecrement, self.maxSegmentsPerCell, self.maxSynapsesPerSegment, learn)
def punishPredictedColumn(self, column, columnActiveSegments, columnMatchingSegments, prevActiveCells, prevWinnerCells): DCNL DCSP self._punishPredictedColumn(self.connections, columnMatchingSegments, prevActiveCells, self.predictedSegmentDecrement)
def createSegment(self, cell): DCNL DCSP return self._createSegment(self.connections, self.lastUsedIterationForSegment, cell, self.iteration, self.maxSegmentsPerCell)
@classmethod DCNL def _activatePredictedColumn(cls, connections, random, columnActiveSegments, prevActiveCells, prevWinnerCells, numActivePotentialSynapsesForSegment, maxNewSynapseCount, initialPermanence, permanenceIncrement, permanenceDecrement, maxSynapsesPerSegment, learn): DCNL DCSP cellsToAdd = [] DCNL DCSP previousCell = None DCNL DCSP for segment in columnActiveSegments: DCNL DCSP  DCSP if (segment.cell != previousCell): DCNL DCSP  DCSP  DCSP cellsToAdd.append(segment.cell) DCNL DCSP  DCSP  DCSP previousCell = segment.cell DCNL DCSP  DCSP if learn: DCNL DCSP  DCSP  DCSP cls._adaptSegment(connections, segment, prevActiveCells, permanenceIncrement, permanenceDecrement) DCNL DCSP  DCSP  DCSP active = numActivePotentialSynapsesForSegment[segment.flatIdx] DCNL DCSP  DCSP  DCSP nGrowDesired = (maxNewSynapseCount - active) DCNL DCSP  DCSP  DCSP if (nGrowDesired > 0): DCNL DCSP  DCSP  DCSP  DCSP cls._growSynapses(connections, random, segment, nGrowDesired, prevWinnerCells, initialPermanence, maxSynapsesPerSegment) DCNL DCSP return cellsToAdd
@classmethod DCNL def _burstColumn(cls, connections, random, lastUsedIterationForSegment, column, columnMatchingSegments, prevActiveCells, prevWinnerCells, cellsForColumn, numActivePotentialSynapsesForSegment, iteration, maxNewSynapseCount, initialPermanence, permanenceIncrement, permanenceDecrement, maxSegmentsPerCell, maxSynapsesPerSegment, learn): DCNL DCSP if (columnMatchingSegments is not None): DCNL DCSP  DCSP numActive = (lambda s: numActivePotentialSynapsesForSegment[s.flatIdx]) DCNL DCSP  DCSP bestMatchingSegment = max(columnMatchingSegments, key=numActive) DCNL DCSP  DCSP winnerCell = bestMatchingSegment.cell DCNL DCSP  DCSP if learn: DCNL DCSP  DCSP  DCSP cls._adaptSegment(connections, bestMatchingSegment, prevActiveCells, permanenceIncrement, permanenceDecrement) DCNL DCSP  DCSP  DCSP nGrowDesired = (maxNewSynapseCount - numActive(bestMatchingSegment)) DCNL DCSP  DCSP  DCSP if (nGrowDesired > 0): DCNL DCSP  DCSP  DCSP  DCSP cls._growSynapses(connections, random, bestMatchingSegment, nGrowDesired, prevWinnerCells, initialPermanence, maxSynapsesPerSegment) DCNL DCSP else: DCNL DCSP  DCSP winnerCell = cls._leastUsedCell(random, cellsForColumn, connections) DCNL DCSP  DCSP if learn: DCNL DCSP  DCSP  DCSP nGrowExact = min(maxNewSynapseCount, len(prevWinnerCells)) DCNL DCSP  DCSP  DCSP if (nGrowExact > 0): DCNL DCSP  DCSP  DCSP  DCSP segment = cls._createSegment(connections, lastUsedIterationForSegment, winnerCell, iteration, maxSegmentsPerCell) DCNL DCSP  DCSP  DCSP  DCSP cls._growSynapses(connections, random, segment, nGrowExact, prevWinnerCells, initialPermanence, maxSynapsesPerSegment) DCNL DCSP return (cellsForColumn, winnerCell)
@classmethod DCNL def _punishPredictedColumn(cls, connections, columnMatchingSegments, prevActiveCells, predictedSegmentDecrement): DCNL DCSP if ((predictedSegmentDecrement > 0.0) and (columnMatchingSegments is not None)): DCNL DCSP  DCSP for segment in columnMatchingSegments: DCNL DCSP  DCSP  DCSP cls._adaptSegment(connections, segment, prevActiveCells, (- predictedSegmentDecrement), 0.0)
@classmethod DCNL def _createSegment(cls, connections, lastUsedIterationForSegment, cell, iteration, maxSegmentsPerCell): DCNL DCSP while (connections.numSegments(cell) >= maxSegmentsPerCell): DCNL DCSP  DCSP leastRecentlyUsedSegment = min(connections.segmentsForCell(cell), key=(lambda segment: lastUsedIterationForSegment[segment.flatIdx])) DCNL DCSP  DCSP connections.destroySegment(leastRecentlyUsedSegment) DCNL DCSP segment = connections.createSegment(cell) DCNL DCSP if (segment.flatIdx == len(lastUsedIterationForSegment)): DCNL DCSP  DCSP lastUsedIterationForSegment.append(iteration) DCNL DCSP elif (segment.flatIdx < len(lastUsedIterationForSegment)): DCNL DCSP  DCSP lastUsedIterationForSegment[segment.flatIdx] = iteration DCNL DCSP else: DCNL DCSP  DCSP raise AssertionError('All DCSP segments DCSP should DCSP be DCSP created DCSP with DCSP the DCSP TM DCSP createSegment DCSP method.') DCNL DCSP return segment
@classmethod DCNL def _destroyMinPermanenceSynapses(cls, connections, random, segment, nDestroy, excludeCells): DCNL DCSP destroyCandidates = sorted((synapse for synapse in connections.synapsesForSegment(segment) if (synapse.presynapticCell not in excludeCells)), key=(lambda s: s._ordinal)) DCNL DCSP for _ in xrange(nDestroy): DCNL DCSP  DCSP if (len(destroyCandidates) == 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP minSynapse = None DCNL DCSP  DCSP minPermanence = float('inf') DCNL DCSP  DCSP for synapse in destroyCandidates: DCNL DCSP  DCSP  DCSP if (synapse.permanence < (minPermanence - EPSILON)): DCNL DCSP  DCSP  DCSP  DCSP minSynapse = synapse DCNL DCSP  DCSP  DCSP  DCSP minPermanence = synapse.permanence DCNL DCSP  DCSP connections.destroySynapse(minSynapse) DCNL DCSP  DCSP destroyCandidates.remove(minSynapse)
@classmethod DCNL def _leastUsedCell(cls, random, cells, connections): DCNL DCSP leastUsedCells = [] DCNL DCSP minNumSegments = float('inf') DCNL DCSP for cell in cells: DCNL DCSP  DCSP numSegments = connections.numSegments(cell) DCNL DCSP  DCSP if (numSegments < minNumSegments): DCNL DCSP  DCSP  DCSP minNumSegments = numSegments DCNL DCSP  DCSP  DCSP leastUsedCells = [] DCNL DCSP  DCSP if (numSegments == minNumSegments): DCNL DCSP  DCSP  DCSP leastUsedCells.append(cell) DCNL DCSP i = random.getUInt32(len(leastUsedCells)) DCNL DCSP return leastUsedCells[i]
@classmethod DCNL def _growSynapses(cls, connections, random, segment, nDesiredNewSynapes, prevWinnerCells, initialPermanence, maxSynapsesPerSegment): DCNL DCSP candidates = list(prevWinnerCells) DCNL DCSP for synapse in connections.synapsesForSegment(segment): DCNL DCSP  DCSP i = binSearch(candidates, synapse.presynapticCell) DCNL DCSP  DCSP if (i != (-1)): DCNL DCSP  DCSP  DCSP del candidates[i] DCNL DCSP nActual = min(nDesiredNewSynapes, len(candidates)) DCNL DCSP overrun = ((connections.numSynapses(segment) + nActual) - maxSynapsesPerSegment) DCNL DCSP if (overrun > 0): DCNL DCSP  DCSP cls._destroyMinPermanenceSynapses(connections, random, segment, overrun, prevWinnerCells) DCNL DCSP nActual = min(nActual, (maxSynapsesPerSegment - connections.numSynapses(segment))) DCNL DCSP for _ in range(nActual): DCNL DCSP  DCSP i = random.getUInt32(len(candidates)) DCNL DCSP  DCSP connections.createSynapse(segment, candidates[i], initialPermanence) DCNL DCSP  DCSP del candidates[i]
@classmethod DCNL def _adaptSegment(cls, connections, segment, prevActiveCells, permanenceIncrement, permanenceDecrement): DCNL DCSP synapsesToDestroy = [] DCNL DCSP for synapse in connections.synapsesForSegment(segment): DCNL DCSP  DCSP permanence = synapse.permanence DCNL DCSP  DCSP if (binSearch(prevActiveCells, synapse.presynapticCell) != (-1)): DCNL DCSP  DCSP  DCSP permanence += permanenceIncrement DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP permanence -= permanenceDecrement DCNL DCSP  DCSP permanence = max(0.0, min(1.0, permanence)) DCNL DCSP  DCSP if (permanence < EPSILON): DCNL DCSP  DCSP  DCSP synapsesToDestroy.append(synapse) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP connections.updateSynapsePermanence(synapse, permanence) DCNL DCSP for synapse in synapsesToDestroy: DCNL DCSP  DCSP connections.destroySynapse(synapse) DCNL DCSP if (connections.numSynapses(segment) == 0): DCNL DCSP  DCSP connections.destroySegment(segment)
def columnForCell(self, cell): DCNL DCSP self._validateCell(cell) DCNL DCSP return int((cell / self.cellsPerColumn))
def cellsForColumn(self, column): DCNL DCSP self._validateColumn(column) DCNL DCSP start = (self.cellsPerColumn * column) DCNL DCSP end = (start + self.cellsPerColumn) DCNL DCSP return range(start, end)
def numberOfColumns(self): DCNL DCSP return reduce(mul, self.columnDimensions, 1)
def numberOfCells(self): DCNL DCSP return (self.numberOfColumns() * self.cellsPerColumn)
def mapCellsToColumns(self, cells): DCNL DCSP cellsForColumns = defaultdict(set) DCNL DCSP for cell in cells: DCNL DCSP  DCSP column = self.columnForCell(cell) DCNL DCSP  DCSP cellsForColumns[column].add(cell) DCNL DCSP return cellsForColumns
def getActiveCells(self): DCNL DCSP return self.getCellIndices(self.activeCells)
def getPredictiveCells(self): DCNL DCSP previousCell = None DCNL DCSP predictiveCells = [] DCNL DCSP for segment in self.activeSegments: DCNL DCSP  DCSP if (segment.cell != previousCell): DCNL DCSP  DCSP  DCSP predictiveCells.append(segment.cell) DCNL DCSP  DCSP  DCSP previousCell = segment.cell DCNL DCSP return predictiveCells
def getWinnerCells(self): DCNL DCSP return self.getCellIndices(self.winnerCells)
def getActiveSegments(self): DCNL DCSP return self.activeSegments
def getMatchingSegments(self): DCNL DCSP return self.matchingSegments
def getCellsPerColumn(self): DCNL DCSP return self.cellsPerColumn
def getColumnDimensions(self): DCNL DCSP return self.columnDimensions
def getActivationThreshold(self): DCNL DCSP return self.activationThreshold
def setActivationThreshold(self, activationThreshold): DCNL DCSP self.activationThreshold = activationThreshold
def getInitialPermanence(self): DCNL DCSP return self.initialPermanence
def setInitialPermanence(self, initialPermanence): DCNL DCSP self.initialPermanence = initialPermanence
def getMinThreshold(self): DCNL DCSP return self.minThreshold
def setMinThreshold(self, minThreshold): DCNL DCSP self.minThreshold = minThreshold
def getMaxNewSynapseCount(self): DCNL DCSP return self.maxNewSynapseCount
def setMaxNewSynapseCount(self, maxNewSynapseCount): DCNL DCSP self.maxNewSynapseCount = maxNewSynapseCount
def getPermanenceIncrement(self): DCNL DCSP return self.permanenceIncrement
def setPermanenceIncrement(self, permanenceIncrement): DCNL DCSP self.permanenceIncrement = permanenceIncrement
def getPermanenceDecrement(self): DCNL DCSP return self.permanenceDecrement
def setPermanenceDecrement(self, permanenceDecrement): DCNL DCSP self.permanenceDecrement = permanenceDecrement
def getPredictedSegmentDecrement(self): DCNL DCSP return self.predictedSegmentDecrement
def setPredictedSegmentDecrement(self, predictedSegmentDecrement): DCNL DCSP self.predictedSegmentDecrement = predictedSegmentDecrement
def getConnectedPermanence(self): DCNL DCSP return self.connectedPermanence
def setConnectedPermanence(self, connectedPermanence): DCNL DCSP self.connectedPermanence = connectedPermanence
def getMaxSegmentsPerCell(self): DCNL DCSP return self.maxSegmentsPerCell
def getMaxSynapsesPerSegment(self): DCNL DCSP return self.maxSynapsesPerSegment
def write(self, proto): DCNL DCSP proto.columnDimensions = list(self.columnDimensions) DCNL DCSP proto.cellsPerColumn = self.cellsPerColumn DCNL DCSP proto.activationThreshold = self.activationThreshold DCNL DCSP proto.initialPermanence = self.initialPermanence DCNL DCSP proto.connectedPermanence = self.connectedPermanence DCNL DCSP proto.minThreshold = self.minThreshold DCNL DCSP proto.maxNewSynapseCount = self.maxNewSynapseCount DCNL DCSP proto.permanenceIncrement = self.permanenceIncrement DCNL DCSP proto.permanenceDecrement = self.permanenceDecrement DCNL DCSP proto.predictedSegmentDecrement = self.predictedSegmentDecrement DCNL DCSP proto.maxSegmentsPerCell = self.maxSegmentsPerCell DCNL DCSP proto.maxSynapsesPerSegment = self.maxSynapsesPerSegment DCNL DCSP self.connections.write(proto.connections) DCNL DCSP self._random.write(proto.random) DCNL DCSP proto.activeCells = list(self.activeCells) DCNL DCSP proto.winnerCells = list(self.winnerCells) DCNL DCSP protoActiveSegments = proto.init('activeSegments', len(self.activeSegments)) DCNL DCSP for (i, segment) in enumerate(self.activeSegments): DCNL DCSP  DCSP protoActiveSegments[i].cell = segment.cell DCNL DCSP  DCSP idx = self.connections.segmentsForCell(segment.cell).index(segment) DCNL DCSP  DCSP protoActiveSegments[i].idxOnCell = idx DCNL DCSP protoMatchingSegments = proto.init('matchingSegments', len(self.matchingSegments)) DCNL DCSP for (i, segment) in enumerate(self.matchingSegments): DCNL DCSP  DCSP protoMatchingSegments[i].cell = segment.cell DCNL DCSP  DCSP idx = self.connections.segmentsForCell(segment.cell).index(segment) DCNL DCSP  DCSP protoMatchingSegments[i].idxOnCell = idx DCNL DCSP protoNumActivePotential = proto.init('numActivePotentialSynapsesForSegment', len(self.numActivePotentialSynapsesForSegment)) DCNL DCSP for (i, numActivePotentialSynapses) in enumerate(self.numActivePotentialSynapsesForSegment): DCNL DCSP  DCSP segment = self.connections.segmentForFlatIdx(i) DCNL DCSP  DCSP if (segment is not None): DCNL DCSP  DCSP  DCSP protoNumActivePotential[i].cell = segment.cell DCNL DCSP  DCSP  DCSP idx = self.connections.segmentsForCell(segment.cell).index(segment) DCNL DCSP  DCSP  DCSP protoNumActivePotential[i].idxOnCell = idx DCNL DCSP  DCSP  DCSP protoNumActivePotential[i].number = numActivePotentialSynapses DCNL DCSP proto.iteration = self.iteration DCNL DCSP protoLastUsedIteration = proto.init('lastUsedIterationForSegment', len(self.numActivePotentialSynapsesForSegment)) DCNL DCSP for (i, lastUsed) in enumerate(self.lastUsedIterationForSegment): DCNL DCSP  DCSP segment = self.connections.segmentForFlatIdx(i) DCNL DCSP  DCSP if (segment is not None): DCNL DCSP  DCSP  DCSP protoLastUsedIteration[i].cell = segment.cell DCNL DCSP  DCSP  DCSP idx = self.connections.segmentsForCell(segment.cell).index(segment) DCNL DCSP  DCSP  DCSP protoLastUsedIteration[i].idxOnCell = idx DCNL DCSP  DCSP  DCSP protoLastUsedIteration[i].number = lastUsed
@classmethod DCNL def read(cls, proto): DCNL DCSP tm = object.__new__(cls) DCNL DCSP tm.columnDimensions = tuple(proto.columnDimensions) DCNL DCSP tm.cellsPerColumn = int(proto.cellsPerColumn) DCNL DCSP tm.activationThreshold = int(proto.activationThreshold) DCNL DCSP tm.initialPermanence = proto.initialPermanence DCNL DCSP tm.connectedPermanence = proto.connectedPermanence DCNL DCSP tm.minThreshold = int(proto.minThreshold) DCNL DCSP tm.maxNewSynapseCount = int(proto.maxNewSynapseCount) DCNL DCSP tm.permanenceIncrement = proto.permanenceIncrement DCNL DCSP tm.permanenceDecrement = proto.permanenceDecrement DCNL DCSP tm.predictedSegmentDecrement = proto.predictedSegmentDecrement DCNL DCSP tm.maxSegmentsPerCell = int(proto.maxSegmentsPerCell) DCNL DCSP tm.maxSynapsesPerSegment = int(proto.maxSynapsesPerSegment) DCNL DCSP tm.connections = Connections.read(proto.connections) DCNL DCSP tm._random = Random() DCNL DCSP tm._random.read(proto.random) DCNL DCSP tm.activeCells = [int(x) for x in proto.activeCells] DCNL DCSP tm.winnerCells = [int(x) for x in proto.winnerCells] DCNL DCSP flatListLength = tm.connections.segmentFlatListLength() DCNL DCSP tm.numActiveConnectedSynapsesForSegment = ([0] * flatListLength) DCNL DCSP tm.numActivePotentialSynapsesForSegment = ([0] * flatListLength) DCNL DCSP tm.lastUsedIterationForSegment = ([0] * flatListLength) DCNL DCSP tm.activeSegments = [] DCNL DCSP tm.matchingSegments = [] DCNL DCSP for protoSegment in proto.activeSegments: DCNL DCSP  DCSP tm.activeSegments.append(tm.connections.getSegment(protoSegment.cell, protoSegment.idxOnCell)) DCNL DCSP for protoSegment in proto.matchingSegments: DCNL DCSP  DCSP tm.matchingSegments.append(tm.connections.getSegment(protoSegment.cell, protoSegment.idxOnCell)) DCNL DCSP for protoSegment in proto.numActivePotentialSynapsesForSegment: DCNL DCSP  DCSP segment = tm.connections.getSegment(protoSegment.cell, protoSegment.idxOnCell) DCNL DCSP  DCSP tm.numActivePotentialSynapsesForSegment[segment.flatIdx] = int(protoSegment.number) DCNL DCSP tm.iteration = long(proto.iteration) DCNL DCSP for protoSegment in proto.lastUsedIterationForSegment: DCNL DCSP  DCSP segment = tm.connections.getSegment(protoSegment.cell, protoSegment.idxOnCell) DCNL DCSP  DCSP tm.lastUsedIterationForSegment[segment.flatIdx] = long(protoSegment.number) DCNL DCSP return tm
def __eq__(self, other): DCNL DCSP if (self.columnDimensions != other.columnDimensions): DCNL DCSP  DCSP return False DCNL DCSP if (self.cellsPerColumn != other.cellsPerColumn): DCNL DCSP  DCSP return False DCNL DCSP if (self.activationThreshold != other.activationThreshold): DCNL DCSP  DCSP return False DCNL DCSP if (abs((self.initialPermanence - other.initialPermanence)) > EPSILON): DCNL DCSP  DCSP return False DCNL DCSP if (abs((self.connectedPermanence - other.connectedPermanence)) > EPSILON): DCNL DCSP  DCSP return False DCNL DCSP if (self.minThreshold != other.minThreshold): DCNL DCSP  DCSP return False DCNL DCSP if (self.maxNewSynapseCount != other.maxNewSynapseCount): DCNL DCSP  DCSP return False DCNL DCSP if (abs((self.permanenceIncrement - other.permanenceIncrement)) > EPSILON): DCNL DCSP  DCSP return False DCNL DCSP if (abs((self.permanenceDecrement - other.permanenceDecrement)) > EPSILON): DCNL DCSP  DCSP return False DCNL DCSP if (abs((self.predictedSegmentDecrement - other.predictedSegmentDecrement)) > EPSILON): DCNL DCSP  DCSP return False DCNL DCSP if (self.connections != other.connections): DCNL DCSP  DCSP return False DCNL DCSP if (self.activeCells != other.activeCells): DCNL DCSP  DCSP return False DCNL DCSP if (self.winnerCells != other.winnerCells): DCNL DCSP  DCSP return False DCNL DCSP if (self.matchingSegments != other.matchingSegments): DCNL DCSP  DCSP return False DCNL DCSP if (self.activeSegments != other.activeSegments): DCNL DCSP  DCSP return False DCNL DCSP return True
def __ne__(self, other): DCNL DCSP return (not self.__eq__(other))
def _validateColumn(self, column): DCNL DCSP if ((column >= self.numberOfColumns()) or (column < 0)): DCNL DCSP  DCSP raise IndexError('Invalid DCSP column')
def _validateCell(self, cell): DCNL DCSP if ((cell >= self.numberOfCells()) or (cell < 0)): DCNL DCSP  DCSP raise IndexError('Invalid DCSP cell')
@classmethod DCNL def getCellIndices(cls, cells): DCNL DCSP return [cls.getCellIndex(c) for c in cells]
@staticmethod DCNL def getCellIndex(cell): DCNL DCSP return cell
@staticmethod DCNL def create(*args, **kwargs): DCNL DCSP impl = kwargs.pop('implementation', None) DCNL DCSP if (impl is None): DCNL DCSP  DCSP impl = Configuration.get('nupic.opf.sdrClassifier.implementation') DCNL DCSP if (impl == 'py'): DCNL DCSP  DCSP return SDRClassifier(*args, **kwargs) DCNL DCSP elif (impl == 'cpp'): DCNL DCSP  DCSP return FastSDRClassifier(*args, **kwargs) DCNL DCSP elif (impl == 'diff'): DCNL DCSP  DCSP return SDRClassifierDiff(*args, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Invalid DCSP classifier DCSP implementation DCSP (%r). DCSP Value DCSP must DCSP be DCSP "py", DCSP "cpp" DCSP or DCSP "diff".' % impl))
@staticmethod DCNL def read(proto): DCNL DCSP impl = proto.implementation DCNL DCSP if (impl == 'py'): DCNL DCSP  DCSP return SDRClassifier.read(proto.sdrClassifier) DCNL DCSP elif (impl == 'cpp'): DCNL DCSP  DCSP return FastSDRClassifier.read(proto.sdrClassifier) DCNL DCSP elif (impl == 'diff'): DCNL DCSP  DCSP return SDRClassifierDiff.read(proto.sdrClassifier) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Invalid DCSP classifier DCSP implementation DCSP (%r). DCSP Value DCSP must DCSP be DCSP "py", DCSP "cpp" DCSP or DCSP "diff".' % impl))
def clear(self): DCNL DCSP self._Memory = None DCNL DCSP self._numPatterns = 0 DCNL DCSP self._M = None DCNL DCSP self._categoryList = [] DCNL DCSP self._partitionIdList = [] DCNL DCSP self._partitionIdMap = {} DCNL DCSP self._finishedLearning = False DCNL DCSP self._iterationIdx = (-1) DCNL DCSP if (self.maxStoredPatterns > 0): DCNL DCSP  DCSP assert self.useSparseMemory, 'Fixed DCSP capacity DCSP KNN DCSP is DCSP implemented DCSP only DCSP in DCSP the DCSP sparse DCSP memory DCSP mode' DCNL DCSP  DCSP self.fixedCapacity = True DCNL DCSP  DCSP self._categoryRecencyList = [] DCNL DCSP else: DCNL DCSP  DCSP self.fixedCapacity = False DCNL DCSP self._protoSizes = None DCNL DCSP self._s = None DCNL DCSP self._vt = None DCNL DCSP self._nc = None DCNL DCSP self._mean = None DCNL DCSP self._specificIndexTraining = False DCNL DCSP self._nextTrainingIndices = None
def prototypeSetCategory(self, idToCategorize, newCategory): DCNL DCSP if (idToCategorize not in self._categoryRecencyList): DCNL DCSP  DCSP return DCNL DCSP recordIndex = self._categoryRecencyList.index(idToCategorize) DCNL DCSP self._categoryList[recordIndex] = newCategory
def removeIds(self, idsToRemove): DCNL DCSP rowsToRemove = [k for (k, rowID) in enumerate(self._categoryRecencyList) if (rowID in idsToRemove)] DCNL DCSP self._removeRows(rowsToRemove)
def removeCategory(self, categoryToRemove): DCNL DCSP removedRows = 0 DCNL DCSP if (self._Memory is None): DCNL DCSP  DCSP return removedRows DCNL DCSP catToRemove = float(categoryToRemove) DCNL DCSP rowsToRemove = [k for (k, catID) in enumerate(self._categoryList) if (catID == catToRemove)] DCNL DCSP self._removeRows(rowsToRemove) DCNL DCSP assert (catToRemove not in self._categoryList)
def _removeRows(self, rowsToRemove): DCNL DCSP removalArray = numpy.array(rowsToRemove) DCNL DCSP self._categoryList = numpy.delete(numpy.array(self._categoryList), removalArray).tolist() DCNL DCSP if self.fixedCapacity: DCNL DCSP  DCSP self._categoryRecencyList = numpy.delete(numpy.array(self._categoryRecencyList), removalArray).tolist() DCNL DCSP for row in reversed(rowsToRemove): DCNL DCSP  DCSP self._partitionIdList.pop(row) DCNL DCSP self._rebuildPartitionIdMap(self._partitionIdList) DCNL DCSP if self.useSparseMemory: DCNL DCSP  DCSP for rowIndex in rowsToRemove[::(-1)]: DCNL DCSP  DCSP  DCSP self._Memory.deleteRow(rowIndex) DCNL DCSP else: DCNL DCSP  DCSP self._M = numpy.delete(self._M, removalArray, 0) DCNL DCSP numRemoved = len(rowsToRemove) DCNL DCSP numRowsExpected = (self._numPatterns - numRemoved) DCNL DCSP if self.useSparseMemory: DCNL DCSP  DCSP if (self._Memory is not None): DCNL DCSP  DCSP  DCSP assert (self._Memory.nRows() == numRowsExpected) DCNL DCSP else: DCNL DCSP  DCSP assert (self._M.shape[0] == numRowsExpected) DCNL DCSP assert (len(self._categoryList) == numRowsExpected) DCNL DCSP self._numPatterns -= numRemoved DCNL DCSP return numRemoved
def doIteration(self): DCNL DCSP self._iterationIdx += 1
def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0, rowID=None): DCNL DCSP if (self.verbosity >= 1): DCNL DCSP  DCSP print ('%s DCSP learn:' % g_debugPrefix) DCNL DCSP  DCSP print ' DCSP  DCSP category:', int(inputCategory) DCNL DCSP  DCSP print ' DCSP  DCSP active DCSP inputs:', _labeledInput(inputPattern, cellsPerCol=self.cellsPerCol) DCNL DCSP if (isSparse > 0): DCNL DCSP  DCSP assert all(((inputPattern[i] <= inputPattern[(i + 1)]) for i in xrange((len(inputPattern) - 1)))), 'Sparse DCSP inputPattern DCSP must DCSP be DCSP sorted.' DCNL DCSP  DCSP assert all(((bit < isSparse) for bit in inputPattern)), "Sparse DCSP inputPattern DCSP must DCSP not DCSP index DCSP outside DCSP the DCSP dense DCSP representation's DCSP bounds." DCNL DCSP if (rowID is None): DCNL DCSP  DCSP rowID = self._iterationIdx DCNL DCSP if (not self.useSparseMemory): DCNL DCSP  DCSP assert (self.cellsPerCol == 0), 'not DCSP implemented DCSP for DCSP dense DCSP vectors' DCNL DCSP  DCSP if (isSparse > 0): DCNL DCSP  DCSP  DCSP denseInput = numpy.zeros(isSparse) DCNL DCSP  DCSP  DCSP denseInput[inputPattern] = 1.0 DCNL DCSP  DCSP  DCSP inputPattern = denseInput DCNL DCSP  DCSP if (self._specificIndexTraining and (not self._nextTrainingIndices)): DCNL DCSP  DCSP  DCSP return self._numPatterns DCNL DCSP  DCSP if (self._Memory is None): DCNL DCSP  DCSP  DCSP inputWidth = len(inputPattern) DCNL DCSP  DCSP  DCSP self._Memory = numpy.zeros((100, inputWidth)) DCNL DCSP  DCSP  DCSP self._numPatterns = 0 DCNL DCSP  DCSP  DCSP self._M = self._Memory[:self._numPatterns] DCNL DCSP  DCSP addRow = True DCNL DCSP  DCSP if (self._vt is not None): DCNL DCSP  DCSP  DCSP inputPattern = numpy.dot(self._vt, (inputPattern - self._mean)) DCNL DCSP  DCSP if (self.distThreshold > 0): DCNL DCSP  DCSP  DCSP dist = self._calcDistance(inputPattern) DCNL DCSP  DCSP  DCSP minDist = dist.min() DCNL DCSP  DCSP  DCSP addRow = (minDist >= self.distThreshold) DCNL DCSP  DCSP if addRow: DCNL DCSP  DCSP  DCSP self._protoSizes = None DCNL DCSP  DCSP  DCSP if (self._numPatterns == self._Memory.shape[0]): DCNL DCSP  DCSP  DCSP  DCSP self._doubleMemoryNumRows() DCNL DCSP  DCSP  DCSP if (not self._specificIndexTraining): DCNL DCSP  DCSP  DCSP  DCSP self._Memory[self._numPatterns] = inputPattern DCNL DCSP  DCSP  DCSP  DCSP self._numPatterns += 1 DCNL DCSP  DCSP  DCSP  DCSP self._categoryList.append(int(inputCategory)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP vectorIndex = self._nextTrainingIndices.pop(0) DCNL DCSP  DCSP  DCSP  DCSP while (vectorIndex >= self._Memory.shape[0]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._doubleMemoryNumRows() DCNL DCSP  DCSP  DCSP  DCSP self._Memory[vectorIndex] = inputPattern DCNL DCSP  DCSP  DCSP  DCSP self._numPatterns = max(self._numPatterns, (vectorIndex + 1)) DCNL DCSP  DCSP  DCSP  DCSP if (vectorIndex >= len(self._categoryList)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._categoryList += ([(-1)] * ((vectorIndex - len(self._categoryList)) + 1)) DCNL DCSP  DCSP  DCSP  DCSP self._categoryList[vectorIndex] = int(inputCategory) DCNL DCSP  DCSP  DCSP self._M = self._Memory[0:self._numPatterns] DCNL DCSP  DCSP  DCSP self._addPartitionId((self._numPatterns - 1), partitionId) DCNL DCSP else: DCNL DCSP  DCSP if ((isSparse > 0) and ((self._vt is not None) or (self.distThreshold > 0) or (self.numSVDDims is not None) or (self.numSVDSamples is not None) or (self.numWinners > 0))): DCNL DCSP  DCSP  DCSP denseInput = numpy.zeros(isSparse) DCNL DCSP  DCSP  DCSP denseInput[inputPattern] = 1.0 DCNL DCSP  DCSP  DCSP inputPattern = denseInput DCNL DCSP  DCSP  DCSP isSparse = 0 DCNL DCSP  DCSP if (isSparse > 0): DCNL DCSP  DCSP  DCSP inputWidth = isSparse DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inputWidth = len(inputPattern) DCNL DCSP  DCSP if (self._Memory is None): DCNL DCSP  DCSP  DCSP self._Memory = NearestNeighbor(0, inputWidth) DCNL DCSP  DCSP if (self._vt is not None): DCNL DCSP  DCSP  DCSP inputPattern = numpy.dot(self._vt, (inputPattern - self._mean)) DCNL DCSP  DCSP if (isSparse == 0): DCNL DCSP  DCSP  DCSP thresholdedInput = self._sparsifyVector(inputPattern, True) DCNL DCSP  DCSP addRow = True DCNL DCSP  DCSP if (self.cellsPerCol >= 1): DCNL DCSP  DCSP  DCSP burstingCols = thresholdedInput.reshape((-1), self.cellsPerCol).min(axis=1).nonzero()[0] DCNL DCSP  DCSP  DCSP for col in burstingCols: DCNL DCSP  DCSP  DCSP  DCSP thresholdedInput[((col * self.cellsPerCol) + 1):((col * self.cellsPerCol) + self.cellsPerCol)] = 0 DCNL DCSP  DCSP if (self._Memory.nRows() > 0): DCNL DCSP  DCSP  DCSP dist = None DCNL DCSP  DCSP  DCSP if self.replaceDuplicates: DCNL DCSP  DCSP  DCSP  DCSP dist = self._calcDistance(thresholdedInput, distanceNorm=1) DCNL DCSP  DCSP  DCSP  DCSP if (dist.min() == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rowIdx = dist.argmin() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._categoryList[rowIdx] = int(inputCategory) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if self.fixedCapacity: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._categoryRecencyList[rowIdx] = rowID DCNL DCSP  DCSP  DCSP  DCSP  DCSP addRow = False DCNL DCSP  DCSP  DCSP if (self.distThreshold > 0): DCNL DCSP  DCSP  DCSP  DCSP if ((dist is None) or (self.distanceNorm != 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP dist = self._calcDistance(thresholdedInput) DCNL DCSP  DCSP  DCSP  DCSP minDist = dist.min() DCNL DCSP  DCSP  DCSP  DCSP addRow = (minDist >= self.distThreshold) DCNL DCSP  DCSP  DCSP  DCSP if (not addRow): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if self.fixedCapacity: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rowIdx = dist.argmin() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._categoryRecencyList[rowIdx] = rowID DCNL DCSP  DCSP if (addRow and (self.minSparsity > 0.0)): DCNL DCSP  DCSP  DCSP if (isSparse == 0): DCNL DCSP  DCSP  DCSP  DCSP sparsity = (float(len(thresholdedInput.nonzero()[0])) / len(thresholdedInput)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sparsity = (float(len(inputPattern)) / isSparse) DCNL DCSP  DCSP  DCSP if (sparsity < self.minSparsity): DCNL DCSP  DCSP  DCSP  DCSP addRow = False DCNL DCSP  DCSP if addRow: DCNL DCSP  DCSP  DCSP self._protoSizes = None DCNL DCSP  DCSP  DCSP if (isSparse == 0): DCNL DCSP  DCSP  DCSP  DCSP self._Memory.addRow(thresholdedInput) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self._Memory.addRowNZ(inputPattern, ([1] * len(inputPattern))) DCNL DCSP  DCSP  DCSP self._numPatterns += 1 DCNL DCSP  DCSP  DCSP self._categoryList.append(int(inputCategory)) DCNL DCSP  DCSP  DCSP self._addPartitionId((self._numPatterns - 1), partitionId) DCNL DCSP  DCSP  DCSP if self.fixedCapacity: DCNL DCSP  DCSP  DCSP  DCSP self._categoryRecencyList.append(rowID) DCNL DCSP  DCSP  DCSP  DCSP if ((self._numPatterns > self.maxStoredPatterns) and (self.maxStoredPatterns > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP leastRecentlyUsedPattern = numpy.argmin(self._categoryRecencyList) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._Memory.deleteRow(leastRecentlyUsedPattern) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._categoryList.pop(leastRecentlyUsedPattern) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._categoryRecencyList.pop(leastRecentlyUsedPattern) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._numPatterns -= 1 DCNL DCSP if ((self.numSVDDims is not None) and (self.numSVDSamples is not None) and (self._numPatterns == self.numSVDSamples)): DCNL DCSP  DCSP self.computeSVD() DCNL DCSP return self._numPatterns
def getOverlaps(self, inputPattern): DCNL DCSP assert self.useSparseMemory, 'Not DCSP implemented DCSP yet DCSP for DCSP dense DCSP storage' DCNL DCSP overlaps = self._Memory.rightVecSumAtNZ(inputPattern) DCNL DCSP return (overlaps, self._categoryList)
def getDistances(self, inputPattern): DCNL DCSP dist = self._getDistances(inputPattern) DCNL DCSP return (dist, self._categoryList)
def infer(self, inputPattern, computeScores=True, overCategories=True, partitionId=None): DCNL DCSP sparsity = 0.0 DCNL DCSP if (self.minSparsity > 0.0): DCNL DCSP  DCSP sparsity = (float(len(inputPattern.nonzero()[0])) / len(inputPattern)) DCNL DCSP if ((len(self._categoryList) == 0) or (sparsity < self.minSparsity)): DCNL DCSP  DCSP winner = None DCNL DCSP  DCSP inferenceResult = numpy.zeros(1) DCNL DCSP  DCSP dist = numpy.ones(1) DCNL DCSP  DCSP categoryDist = numpy.ones(1) DCNL DCSP else: DCNL DCSP  DCSP maxCategoryIdx = max(self._categoryList) DCNL DCSP  DCSP inferenceResult = numpy.zeros((maxCategoryIdx + 1)) DCNL DCSP  DCSP dist = self._getDistances(inputPattern, partitionId=partitionId) DCNL DCSP  DCSP validVectorCount = (len(self._categoryList) - self._categoryList.count((-1))) DCNL DCSP  DCSP if self.exact: DCNL DCSP  DCSP  DCSP exactMatches = numpy.where((dist < 1e-05))[0] DCNL DCSP  DCSP  DCSP if (len(exactMatches) > 0): DCNL DCSP  DCSP  DCSP  DCSP for i in exactMatches[:min(self.k, validVectorCount)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP inferenceResult[self._categoryList[i]] += 1.0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sorted = dist.argsort() DCNL DCSP  DCSP  DCSP for j in sorted[:min(self.k, validVectorCount)]: DCNL DCSP  DCSP  DCSP  DCSP inferenceResult[self._categoryList[j]] += 1.0 DCNL DCSP  DCSP if inferenceResult.any(): DCNL DCSP  DCSP  DCSP winner = inferenceResult.argmax() DCNL DCSP  DCSP  DCSP inferenceResult /= inferenceResult.sum() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP winner = None DCNL DCSP  DCSP categoryDist = min_score_per_category(maxCategoryIdx, self._categoryList, dist) DCNL DCSP  DCSP categoryDist.clip(0, 1.0, categoryDist) DCNL DCSP if (self.verbosity >= 1): DCNL DCSP  DCSP print ('%s DCSP infer:' % g_debugPrefix) DCNL DCSP  DCSP print ' DCSP  DCSP active DCSP inputs:', _labeledInput(inputPattern, cellsPerCol=self.cellsPerCol) DCNL DCSP  DCSP print ' DCSP  DCSP winner DCSP category:', winner DCNL DCSP  DCSP print ' DCSP  DCSP pct DCSP neighbors DCSP of DCSP each DCSP category:', inferenceResult DCNL DCSP  DCSP print ' DCSP  DCSP dist DCSP of DCSP each DCSP prototype:', dist DCNL DCSP  DCSP print ' DCSP  DCSP dist DCSP of DCSP each DCSP category:', categoryDist DCNL DCSP result = (winner, inferenceResult, dist, categoryDist) DCNL DCSP return result
def getClosest(self, inputPattern, topKCategories=3): DCNL DCSP inferenceResult = numpy.zeros((max(self._categoryList) + 1)) DCNL DCSP dist = self._getDistances(inputPattern) DCNL DCSP sorted = dist.argsort() DCNL DCSP validVectorCount = (len(self._categoryList) - self._categoryList.count((-1))) DCNL DCSP for j in sorted[:min(self.k, validVectorCount)]: DCNL DCSP  DCSP inferenceResult[self._categoryList[j]] += 1.0 DCNL DCSP winner = inferenceResult.argmax() DCNL DCSP topNCats = [] DCNL DCSP for i in range(topKCategories): DCNL DCSP  DCSP topNCats.append((self._categoryList[sorted[i]], dist[sorted[i]])) DCNL DCSP return (winner, dist, topNCats)
def closestTrainingPattern(self, inputPattern, cat): DCNL DCSP dist = self._getDistances(inputPattern) DCNL DCSP sorted = dist.argsort() DCNL DCSP for patIdx in sorted: DCNL DCSP  DCSP patternCat = self._categoryList[patIdx] DCNL DCSP  DCSP if (patternCat == cat): DCNL DCSP  DCSP  DCSP if self.useSparseMemory: DCNL DCSP  DCSP  DCSP  DCSP closestPattern = self._Memory.getRow(int(patIdx)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP closestPattern = self._M[patIdx] DCNL DCSP  DCSP  DCSP return closestPattern DCNL DCSP return None
def closestOtherTrainingPattern(self, inputPattern, cat): DCNL DCSP dist = self._getDistances(inputPattern) DCNL DCSP sorted = dist.argsort() DCNL DCSP for patIdx in sorted: DCNL DCSP  DCSP patternCat = self._categoryList[patIdx] DCNL DCSP  DCSP if (patternCat != cat): DCNL DCSP  DCSP  DCSP if self.useSparseMemory: DCNL DCSP  DCSP  DCSP  DCSP closestPattern = self._Memory.getRow(int(patIdx)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP closestPattern = self._M[patIdx] DCNL DCSP  DCSP  DCSP return closestPattern DCNL DCSP return None
def getPattern(self, idx, sparseBinaryForm=False, cat=None): DCNL DCSP if (cat is not None): DCNL DCSP  DCSP assert (idx is None) DCNL DCSP  DCSP idx = self._categoryList.index(cat) DCNL DCSP if (not self.useSparseMemory): DCNL DCSP  DCSP pattern = self._Memory[idx] DCNL DCSP  DCSP if sparseBinaryForm: DCNL DCSP  DCSP  DCSP pattern = pattern.nonzero()[0] DCNL DCSP else: DCNL DCSP  DCSP (nz, values) = self._Memory.rowNonZeros(idx) DCNL DCSP  DCSP if (not sparseBinaryForm): DCNL DCSP  DCSP  DCSP pattern = numpy.zeros(self._Memory.nCols()) DCNL DCSP  DCSP  DCSP numpy.put(pattern, nz, 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pattern = nz DCNL DCSP return pattern
def getPartitionId(self, i): DCNL DCSP if ((i < 0) or (i >= self._numPatterns)): DCNL DCSP  DCSP raise RuntimeError('index DCSP out DCSP of DCSP bounds') DCNL DCSP partitionId = self._partitionIdList[i] DCNL DCSP if (partitionId == numpy.inf): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return partitionId
def getPartitionIdList(self): DCNL DCSP return self._partitionIdList
def getNumPartitionIds(self): DCNL DCSP return len(self._partitionIdMap)
def getPartitionIdKeys(self): DCNL DCSP return self._partitionIdMap.keys()
def getPatternIndicesWithPartitionId(self, partitionId): DCNL DCSP return self._partitionIdMap.get(partitionId, [])
def _addPartitionId(self, index, partitionId=None): DCNL DCSP if (partitionId is None): DCNL DCSP  DCSP self._partitionIdList.append(numpy.inf) DCNL DCSP else: DCNL DCSP  DCSP self._partitionIdList.append(partitionId) DCNL DCSP  DCSP indices = self._partitionIdMap.get(partitionId, []) DCNL DCSP  DCSP indices.append(index) DCNL DCSP  DCSP self._partitionIdMap[partitionId] = indices
def _rebuildPartitionIdMap(self, partitionIdList): DCNL DCSP self._partitionIdMap = {} DCNL DCSP for (row, partitionId) in enumerate(partitionIdList): DCNL DCSP  DCSP indices = self._partitionIdMap.get(partitionId, []) DCNL DCSP  DCSP indices.append(row) DCNL DCSP  DCSP self._partitionIdMap[partitionId] = indices
def _calcDistance(self, inputPattern, distanceNorm=None): DCNL DCSP if (distanceNorm is None): DCNL DCSP  DCSP distanceNorm = self.distanceNorm DCNL DCSP if self.useSparseMemory: DCNL DCSP  DCSP if (self._protoSizes is None): DCNL DCSP  DCSP  DCSP self._protoSizes = self._Memory.rowSums() DCNL DCSP  DCSP overlapsWithProtos = self._Memory.rightVecSumAtNZ(inputPattern) DCNL DCSP  DCSP inputPatternSum = inputPattern.sum() DCNL DCSP  DCSP if (self.distanceMethod == 'rawOverlap'): DCNL DCSP  DCSP  DCSP dist = (inputPattern.sum() - overlapsWithProtos) DCNL DCSP  DCSP elif (self.distanceMethod == 'pctOverlapOfInput'): DCNL DCSP  DCSP  DCSP dist = (inputPatternSum - overlapsWithProtos) DCNL DCSP  DCSP  DCSP if (inputPatternSum > 0): DCNL DCSP  DCSP  DCSP  DCSP dist /= inputPatternSum DCNL DCSP  DCSP elif (self.distanceMethod == 'pctOverlapOfProto'): DCNL DCSP  DCSP  DCSP overlapsWithProtos /= self._protoSizes DCNL DCSP  DCSP  DCSP dist = (1.0 - overlapsWithProtos) DCNL DCSP  DCSP elif (self.distanceMethod == 'pctOverlapOfLarger'): DCNL DCSP  DCSP  DCSP maxVal = numpy.maximum(self._protoSizes, inputPatternSum) DCNL DCSP  DCSP  DCSP if (maxVal.all() > 0): DCNL DCSP  DCSP  DCSP  DCSP overlapsWithProtos /= maxVal DCNL DCSP  DCSP  DCSP dist = (1.0 - overlapsWithProtos) DCNL DCSP  DCSP elif (self.distanceMethod == 'norm'): DCNL DCSP  DCSP  DCSP dist = self._Memory.vecLpDist(self.distanceNorm, inputPattern) DCNL DCSP  DCSP  DCSP distMax = dist.max() DCNL DCSP  DCSP  DCSP if (distMax > 0): DCNL DCSP  DCSP  DCSP  DCSP dist /= distMax DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError(('Unimplemented DCSP distance DCSP method DCSP %s' % self.distanceMethod)) DCNL DCSP elif (self.distanceMethod == 'norm'): DCNL DCSP  DCSP dist = numpy.power(numpy.abs((self._M - inputPattern)), self.distanceNorm) DCNL DCSP  DCSP dist = dist.sum(1) DCNL DCSP  DCSP dist = numpy.power(dist, (1.0 / self.distanceNorm)) DCNL DCSP  DCSP dist /= dist.max() DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('Not DCSP implemented DCSP yet DCSP for DCSP dense DCSP storage....') DCNL DCSP return dist
def _getDistances(self, inputPattern, partitionId=None): DCNL DCSP if (not self._finishedLearning): DCNL DCSP  DCSP self.finishLearning() DCNL DCSP  DCSP self._finishedLearning = True DCNL DCSP if ((self._vt is not None) and (len(self._vt) > 0)): DCNL DCSP  DCSP inputPattern = numpy.dot(self._vt, (inputPattern - self._mean)) DCNL DCSP sparseInput = self._sparsifyVector(inputPattern) DCNL DCSP dist = self._calcDistance(sparseInput) DCNL DCSP if self._specificIndexTraining: DCNL DCSP  DCSP dist[(numpy.array(self._categoryList) == (-1))] = numpy.inf DCNL DCSP if (partitionId is not None): DCNL DCSP  DCSP dist[self._partitionIdMap.get(partitionId, [])] = numpy.inf DCNL DCSP return dist
def finishLearning(self): DCNL DCSP if ((self.numSVDDims is not None) and (self._vt is None)): DCNL DCSP  DCSP self.computeSVD()
def computeSVD(self, numSVDSamples=None, finalize=True): DCNL DCSP if (numSVDSamples is None): DCNL DCSP  DCSP numSVDSamples = self._numPatterns DCNL DCSP if (not self.useSparseMemory): DCNL DCSP  DCSP self._a = self._Memory[:self._numPatterns] DCNL DCSP else: DCNL DCSP  DCSP self._a = self._Memory.toDense()[:self._numPatterns] DCNL DCSP self._mean = numpy.mean(self._a, axis=0) DCNL DCSP self._a -= self._mean DCNL DCSP (u, self._s, self._vt) = numpy.linalg.svd(self._a[:numSVDSamples]) DCNL DCSP if finalize: DCNL DCSP  DCSP self._finalizeSVD() DCNL DCSP return self._s
def getAdaptiveSVDDims(self, singularValues, fractionOfMax=0.001): DCNL DCSP v = (singularValues / singularValues[0]) DCNL DCSP idx = numpy.where((v < fractionOfMax))[0] DCNL DCSP if len(idx): DCNL DCSP  DCSP print 'Number DCSP of DCSP PCA DCSP dimensions DCSP chosen: DCSP ', idx[0], 'out DCSP of DCSP ', len(v) DCNL DCSP  DCSP return idx[0] DCNL DCSP else: DCNL DCSP  DCSP print 'Number DCSP of DCSP PCA DCSP dimensions DCSP chosen: DCSP ', (len(v) - 1), 'out DCSP of DCSP ', len(v) DCNL DCSP  DCSP return (len(v) - 1)
def _finalizeSVD(self, numSVDDims=None): DCNL DCSP if (numSVDDims is not None): DCNL DCSP  DCSP self.numSVDDims = numSVDDims DCNL DCSP if (self.numSVDDims == 'adaptive'): DCNL DCSP  DCSP if (self.fractionOfMax is not None): DCNL DCSP  DCSP  DCSP self.numSVDDims = self.getAdaptiveSVDDims(self._s, self.fractionOfMax) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.numSVDDims = self.getAdaptiveSVDDims(self._s) DCNL DCSP if (self._vt.shape[0] < self.numSVDDims): DCNL DCSP  DCSP print '******************************************************************' DCNL DCSP  DCSP print 'Warning: DCSP The DCSP requested DCSP number DCSP of DCSP PCA DCSP dimensions DCSP is DCSP more DCSP than DCSP the DCSP number DCSP of DCSP pattern DCSP dimensions.' DCNL DCSP  DCSP print 'Setting DCSP numSVDDims DCSP = DCSP ', self._vt.shape[0] DCNL DCSP  DCSP print '******************************************************************' DCNL DCSP  DCSP self.numSVDDims = self._vt.shape[0] DCNL DCSP self._vt = self._vt[:self.numSVDDims] DCNL DCSP if (len(self._vt) == 0): DCNL DCSP  DCSP return DCNL DCSP self._Memory = numpy.zeros((self._numPatterns, self.numSVDDims)) DCNL DCSP self._M = self._Memory DCNL DCSP self.useSparseMemory = False DCNL DCSP for i in range(self._numPatterns): DCNL DCSP  DCSP self._Memory[i] = numpy.dot(self._vt, self._a[i]) DCNL DCSP self._a = None
def remapCategories(self, mapping): DCNL DCSP categoryArray = numpy.array(self._categoryList) DCNL DCSP newCategoryArray = numpy.zeros(categoryArray.shape[0]) DCNL DCSP newCategoryArray.fill((-1)) DCNL DCSP for i in xrange(len(mapping)): DCNL DCSP  DCSP newCategoryArray[(categoryArray == i)] = mapping[i] DCNL DCSP self._categoryList = list(newCategoryArray)
def setCategoryOfVectors(self, vectorIndices, categoryIndices): DCNL DCSP if (not hasattr(vectorIndices, '__iter__')): DCNL DCSP  DCSP vectorIndices = [vectorIndices] DCNL DCSP  DCSP categoryIndices = [categoryIndices] DCNL DCSP elif (not hasattr(categoryIndices, '__iter__')): DCNL DCSP  DCSP categoryIndices = ([categoryIndices] * len(vectorIndices)) DCNL DCSP for i in xrange(len(vectorIndices)): DCNL DCSP  DCSP vectorIndex = vectorIndices[i] DCNL DCSP  DCSP categoryIndex = categoryIndices[i] DCNL DCSP  DCSP if (vectorIndex < len(self._categoryList)): DCNL DCSP  DCSP  DCSP self._categoryList[vectorIndex] = categoryIndex
def __getstate__(self): DCNL DCSP state = self.__dict__.copy() DCNL DCSP return state
def __setstate__(self, state): DCNL DCSP if ('version' not in state): DCNL DCSP  DCSP pass DCNL DCSP elif (state['version'] == 1): DCNL DCSP  DCSP pass DCNL DCSP elif (state['version'] == 2): DCNL DCSP  DCSP raise RuntimeError('Invalid DCSP deserialization DCSP of DCSP invalid DCSP KNNClassifierVersion') DCNL DCSP if ('_partitionIdArray' in state): DCNL DCSP  DCSP state.pop('_partitionIdArray') DCNL DCSP if ('minSparsity' not in state): DCNL DCSP  DCSP state['minSparsity'] = 0.0 DCNL DCSP self.__dict__.update(state) DCNL DCSP if ('_partitionIdMap' not in state): DCNL DCSP  DCSP self._rebuildPartitionIdMap(self._partitionIdList) DCNL DCSP self.version = KNNCLASSIFIER_VERSION
def compute(self, activeColumns, predictedColumns, inputValue=None, timestamp=None): DCNL DCSP anomalyScore = computeRawAnomalyScore(activeColumns, predictedColumns) DCNL DCSP if (self._mode == Anomaly.MODE_PURE): DCNL DCSP  DCSP score = anomalyScore DCNL DCSP elif (self._mode == Anomaly.MODE_LIKELIHOOD): DCNL DCSP  DCSP if (inputValue is None): DCNL DCSP  DCSP  DCSP raise ValueError("Selected DCSP anomaly DCSP mode DCSP 'Anomaly.MODE_LIKELIHOOD' DCSP requires DCSP 'inputValue' DCSP as DCSP parameter DCSP to DCSP compute() DCSP method. DCSP ") DCNL DCSP  DCSP probability = self._likelihood.anomalyProbability(inputValue, anomalyScore, timestamp) DCNL DCSP  DCSP score = (1 - probability) DCNL DCSP elif (self._mode == Anomaly.MODE_WEIGHTED): DCNL DCSP  DCSP probability = self._likelihood.anomalyProbability(inputValue, anomalyScore, timestamp) DCNL DCSP  DCSP score = (anomalyScore * (1 - probability)) DCNL DCSP if (self._movingAverage is not None): DCNL DCSP  DCSP score = self._movingAverage.next(score) DCNL DCSP if (self._binaryThreshold is not None): DCNL DCSP  DCSP if (score >= self._binaryThreshold): DCNL DCSP  DCSP  DCSP score = 1.0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP score = 0.0 DCNL DCSP return score
def __setstate__(self, state): DCNL DCSP self.__dict__.update(state) DCNL DCSP if (not hasattr(self, '_mode')): DCNL DCSP  DCSP self._mode = Anomaly.MODE_PURE DCNL DCSP if (not hasattr(self, '_movingAverage')): DCNL DCSP  DCSP self._movingAverage = None DCNL DCSP if (not hasattr(self, '_binaryThreshold')): DCNL DCSP  DCSP self._binaryThreshold = None
def __init__(self, numberOfCols=500, cellsPerColumn=10, initialPerm=0.11, connectedPerm=0.5, minThreshold=8, newSynapseCount=15, permanenceInc=0.1, permanenceDec=0.1, permanenceMax=1.0, activationThreshold=12, predictedSegmentDecrement=0.0, maxSegmentsPerCell=255, maxSynapsesPerSegment=255, globalDecay=0.1, maxAge=100000, pamLength=1, verbosity=0, outputType='normal', seed=42): DCNL DCSP super(TMShimMixin, self).__init__(columnDimensions=(numberOfCols,), cellsPerColumn=cellsPerColumn, activationThreshold=activationThreshold, initialPermanence=initialPerm, connectedPermanence=connectedPerm, minThreshold=minThreshold, maxNewSynapseCount=newSynapseCount, permanenceIncrement=permanenceInc, permanenceDecrement=permanenceDec, predictedSegmentDecrement=predictedSegmentDecrement, maxSegmentsPerCell=maxSegmentsPerCell, maxSynapsesPerSegment=maxSynapsesPerSegment, seed=seed) DCNL DCSP self.infActiveState = {'t': None}
@classmethod DCNL def read(cls, proto): DCNL DCSP tm = super(TMShimMixin, cls).read(proto) DCNL DCSP tm.infActiveState = {'t': None} DCNL DCSP return tm
def compute(self, bottomUpInput, enableLearn, computeInfOutput=None): DCNL DCSP super(TMShimMixin, self).compute(set(bottomUpInput.nonzero()[0]), learn=enableLearn) DCNL DCSP numberOfCells = self.numberOfCells() DCNL DCSP activeState = numpy.zeros(numberOfCells) DCNL DCSP activeState[self.getActiveCells()] = 1 DCNL DCSP self.infActiveState['t'] = activeState DCNL DCSP output = numpy.zeros(numberOfCells) DCNL DCSP output[self.getPredictiveCells()] = 1 DCNL DCSP output[self.getActiveCells()] = 1 DCNL DCSP return output
def topDownCompute(self, topDownIn=None): DCNL DCSP output = numpy.zeros(self.numberOfColumns()) DCNL DCSP columns = [self.columnForCell(idx) for idx in self.getPredictiveCells()] DCNL DCSP output[columns] = 1 DCNL DCSP return output
def __init__(self, numberOfCols=500, cellsPerColumn=10, initialPerm=0.11, connectedPerm=0.5, minThreshold=8, newSynapseCount=15, permanenceInc=0.1, permanenceDec=0.1, permanenceMax=1.0, activationThreshold=12, predictedSegmentDecrement=0.0, maxSegmentsPerCell=255, maxSynapsesPerSegment=255, globalDecay=0.1, maxAge=100000, pamLength=1, verbosity=0, outputType='normal', seed=42): DCNL DCSP super(MonitoredTMShim, self).__init__(columnDimensions=(numberOfCols,), cellsPerColumn=cellsPerColumn, activationThreshold=activationThreshold, initialPermanence=initialPerm, connectedPermanence=connectedPerm, minThreshold=minThreshold, maxNewSynapseCount=newSynapseCount, permanenceIncrement=permanenceInc, permanenceDecrement=permanenceDec, predictedSegmentDecrement=predictedSegmentDecrement, maxSegmentsPerCell=maxSegmentsPerCell, maxSynapsesPerSegment=maxSynapsesPerSegment, seed=seed) DCNL DCSP self.infActiveState = {'t': None}
def compute(self, bottomUpInput, enableLearn, computeInfOutput=None): DCNL DCSP super(MonitoredTMShim, self).compute(set(bottomUpInput.nonzero()[0]), learn=enableLearn) DCNL DCSP numberOfCells = self.numberOfCells() DCNL DCSP activeState = numpy.zeros(numberOfCells) DCNL DCSP activeState[self.getActiveCells()] = 1 DCNL DCSP self.infActiveState['t'] = activeState DCNL DCSP output = numpy.zeros(numberOfCells) DCNL DCSP output[(self.getPredictiveCells() + self.getActiveCells())] = 1 DCNL DCSP return output
def topDownCompute(self, topDownIn=None): DCNL DCSP output = numpy.zeros(self.numberOfColumns()) DCNL DCSP columns = [self.columnForCell(idx) for idx in self.getPredictiveCells()] DCNL DCSP output[columns] = 1 DCNL DCSP return output
def write(self, proto): DCNL DCSP super(BacktrackingTMCPP, self).write(proto.baseTM) DCNL DCSP self.cells4.write(proto.cells4) DCNL DCSP proto.makeCells4Ephemeral = self.makeCells4Ephemeral DCNL DCSP proto.seed = self.seed DCNL DCSP proto.checkSynapseConsistency = self.checkSynapseConsistency DCNL DCSP proto.initArgs = json.dumps(self._initArgsDict)
@classmethod DCNL def read(cls, proto): DCNL DCSP obj = BacktrackingTM.read(proto.baseTM) DCNL DCSP obj.__class__ = cls DCNL DCSP newCells4 = Cells4.read(proto.cells4) DCNL DCSP print newCells4 DCNL DCSP obj.cells4 = newCells4 DCNL DCSP obj.makeCells4Ephemeral = proto.makeCells4Ephemeral DCNL DCSP obj.seed = proto.seed DCNL DCSP obj.checkSynapseConsistency = proto.checkSynapseConsistency DCNL DCSP obj._initArgsDict = json.loads(proto.initArgs) DCNL DCSP obj._initArgsDict['outputType'] = str(obj._initArgsDict['outputType']) DCNL DCSP obj.allocateStatesInCPP = False DCNL DCSP obj.retrieveLearningStates = False DCNL DCSP obj._setStatePointers() DCNL DCSP return obj
def __setstate__(self, state): DCNL DCSP super(BacktrackingTMCPP, self).__setstate__(state) DCNL DCSP if self.makeCells4Ephemeral: DCNL DCSP  DCSP self.cells4 = Cells4(self.numberOfCols, self.cellsPerColumn, self.activationThreshold, self.minThreshold, self.newSynapseCount, self.segUpdateValidDuration, self.initialPerm, self.connectedPerm, self.permanenceMax, self.permanenceDec, self.permanenceInc, self.globalDecay, self.doPooling, self.seed, self.allocateStatesInCPP, self.checkSynapseConsistency) DCNL DCSP  DCSP self.cells4.setVerbosity(self.verbosity) DCNL DCSP  DCSP self.cells4.setPamLength(self.pamLength) DCNL DCSP  DCSP self.cells4.setMaxAge(self.maxAge) DCNL DCSP  DCSP self.cells4.setMaxInfBacktrack(self.maxInfBacktrack) DCNL DCSP  DCSP self.cells4.setMaxLrnBacktrack(self.maxLrnBacktrack) DCNL DCSP  DCSP self.cells4.setMaxSeqLength(self.maxSeqLength) DCNL DCSP  DCSP self.cells4.setMaxSegmentsPerCell(self.maxSegmentsPerCell) DCNL DCSP  DCSP self.cells4.setMaxSynapsesPerCell(self.maxSynapsesPerSegment) DCNL DCSP self._setStatePointers()
def _getEphemeralMembers(self): DCNL DCSP e = BacktrackingTM._getEphemeralMembers(self) DCNL DCSP if self.makeCells4Ephemeral: DCNL DCSP  DCSP e.extend(['cells4']) DCNL DCSP return e
def _initEphemerals(self): DCNL DCSP BacktrackingTM._initEphemerals(self) DCNL DCSP self.allocateStatesInCPP = False DCNL DCSP self.retrieveLearningStates = False DCNL DCSP if self.makeCells4Ephemeral: DCNL DCSP  DCSP self.cells4 = Cells4(self.numberOfCols, self.cellsPerColumn, self.activationThreshold, self.minThreshold, self.newSynapseCount, self.segUpdateValidDuration, self.initialPerm, self.connectedPerm, self.permanenceMax, self.permanenceDec, self.permanenceInc, self.globalDecay, self.doPooling, self.seed, self.allocateStatesInCPP, self.checkSynapseConsistency) DCNL DCSP  DCSP self.cells4.setVerbosity(self.verbosity) DCNL DCSP  DCSP self.cells4.setPamLength(self.pamLength) DCNL DCSP  DCSP self.cells4.setMaxAge(self.maxAge) DCNL DCSP  DCSP self.cells4.setMaxInfBacktrack(self.maxInfBacktrack) DCNL DCSP  DCSP self.cells4.setMaxLrnBacktrack(self.maxLrnBacktrack) DCNL DCSP  DCSP self.cells4.setMaxSeqLength(self.maxSeqLength) DCNL DCSP  DCSP self.cells4.setMaxSegmentsPerCell(self.maxSegmentsPerCell) DCNL DCSP  DCSP self.cells4.setMaxSynapsesPerCell(self.maxSynapsesPerSegment) DCNL DCSP  DCSP self._setStatePointers()
def saveToFile(self, filePath): DCNL DCSP self.cells4.saveToFile(filePath)
def loadFromFile(self, filePath): DCNL DCSP self.cells4.loadFromFile(filePath)
def __getattr__(self, name): DCNL DCSP try: DCNL DCSP  DCSP return super(BacktrackingTM, self).__getattr__(name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise AttributeError(("'TM' DCSP object DCSP has DCSP no DCSP attribute DCSP '%s'" % name))
def compute(self, bottomUpInput, enableLearn, enableInference=None): DCNL DCSP assert ((bottomUpInput.dtype == numpy.dtype('float32')) or (bottomUpInput.dtype == numpy.dtype('uint32')) or (bottomUpInput.dtype == numpy.dtype('int32'))) DCNL DCSP self.iterationIdx = (self.iterationIdx + 1) DCNL DCSP if (enableInference is None): DCNL DCSP  DCSP if enableLearn: DCNL DCSP  DCSP  DCSP enableInference = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP enableInference = True DCNL DCSP self._setStatePointers() DCNL DCSP y = self.cells4.compute(bottomUpInput, enableInference, enableLearn) DCNL DCSP self.currentOutput = y.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP self.avgLearnedSeqLength = self.cells4.getAvgLearnedSeqLength() DCNL DCSP self._copyAllocatedStates() DCNL DCSP if self.collectStats: DCNL DCSP  DCSP activeColumns = bottomUpInput.nonzero()[0] DCNL DCSP  DCSP if enableInference: DCNL DCSP  DCSP  DCSP predictedState = self.infPredictedState['t-1'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP predictedState = self.lrnPredictedState['t-1'] DCNL DCSP  DCSP self._updateStatsInferEnd(self._internalStats, activeColumns, predictedState, self.colConfidence['t-1']) DCNL DCSP output = self._computeOutput() DCNL DCSP self.printComputeEnd(output, learn=enableLearn) DCNL DCSP self.resetCalled = False DCNL DCSP return output
def _inferPhase2(self): DCNL DCSP self._setStatePointers() DCNL DCSP self.cells4.inferPhase2() DCNL DCSP self._copyAllocatedStates()
def _copyAllocatedStates(self): DCNL DCSP if ((self.verbosity > 1) or self.retrieveLearningStates): DCNL DCSP  DCSP (activeT, activeT1, predT, predT1) = self.cells4.getLearnStates() DCNL DCSP  DCSP self.lrnActiveState['t-1'] = activeT1.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP  DCSP self.lrnActiveState['t'] = activeT.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP  DCSP self.lrnPredictedState['t-1'] = predT1.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP  DCSP self.lrnPredictedState['t'] = predT.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP if self.allocateStatesInCPP: DCNL DCSP  DCSP assert False DCNL DCSP  DCSP (activeT, activeT1, predT, predT1, colConfidenceT, colConfidenceT1, confidenceT, confidenceT1) = self.cells4.getStates() DCNL DCSP  DCSP self.confidence['t-1'] = confidenceT1.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP  DCSP self.confidence['t'] = confidenceT.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP  DCSP self.colConfidence['t'] = colConfidenceT.reshape(self.numberOfCols) DCNL DCSP  DCSP self.colConfidence['t-1'] = colConfidenceT1.reshape(self.numberOfCols) DCNL DCSP  DCSP self.infActiveState['t-1'] = activeT1.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP  DCSP self.infActiveState['t'] = activeT.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP  DCSP self.infPredictedState['t-1'] = predT1.reshape((self.numberOfCols, self.cellsPerColumn)) DCNL DCSP  DCSP self.infPredictedState['t'] = predT.reshape((self.numberOfCols, self.cellsPerColumn))
def _setStatePointers(self): DCNL DCSP if (not self.allocateStatesInCPP): DCNL DCSP  DCSP self.cells4.setStatePointers(self.infActiveState['t'], self.infActiveState['t-1'], self.infPredictedState['t'], self.infPredictedState['t-1'], self.colConfidence['t'], self.colConfidence['t-1'], self.cellConfidence['t'], self.cellConfidence['t-1'])
def reset(self): DCNL DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP print 'TM DCSP Reset' DCNL DCSP self._setStatePointers() DCNL DCSP self.cells4.reset() DCNL DCSP BacktrackingTM.reset(self)
def finishLearning(self): DCNL DCSP self.trimSegments(minPermanence=0.0001)
def trimSegments(self, minPermanence=None, minNumSyns=None): DCNL DCSP if (minPermanence is None): DCNL DCSP  DCSP minPermanence = 0.0 DCNL DCSP if (minNumSyns is None): DCNL DCSP  DCSP minNumSyns = 0 DCNL DCSP if (self.verbosity >= 5): DCNL DCSP  DCSP print 'Cells, DCSP all DCSP segments:' DCNL DCSP  DCSP self.printCells(predictedOnly=False) DCNL DCSP return self.cells4.trimSegments(minPermanence=minPermanence, minNumSyns=minNumSyns)
def printSegmentUpdates(self): DCNL DCSP assert False DCNL DCSP print '=== DCSP SEGMENT DCSP UPDATES DCSP ===, DCSP Num DCSP = DCSP ', len(self.segmentUpdates) DCNL DCSP for (key, updateList) in self.segmentUpdates.iteritems(): DCNL DCSP  DCSP (c, i) = (key[0], key[1]) DCNL DCSP  DCSP print c, i, updateList
def _slowIsSegmentActive(self, seg, timeStep): DCNL DCSP numSyn = seg.size() DCNL DCSP numActiveSyns = 0 DCNL DCSP for synIdx in xrange(numSyn): DCNL DCSP  DCSP if (seg.getPermanence(synIdx) < self.connectedPerm): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (sc, si) = self.getColCellIdx(seg.getSrcCellIdx(synIdx)) DCNL DCSP  DCSP if self.infActiveState[timeStep][(sc, si)]: DCNL DCSP  DCSP  DCSP numActiveSyns += 1 DCNL DCSP  DCSP  DCSP if (numActiveSyns >= self.activationThreshold): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return (numActiveSyns >= self.activationThreshold)
def printCell(self, c, i, onlyActiveSegments=False): DCNL DCSP nSegs = self.cells4.nSegmentsOnCell(c, i) DCNL DCSP if (nSegs > 0): DCNL DCSP  DCSP segList = self.cells4.getNonEmptySegList(c, i) DCNL DCSP  DCSP gidx = ((c * self.cellsPerColumn) + i) DCNL DCSP  DCSP print 'Column', c, 'Cell', i, ('(%d)' % gidx), ':', nSegs, 'segment(s)' DCNL DCSP  DCSP for (k, segIdx) in enumerate(segList): DCNL DCSP  DCSP  DCSP seg = self.cells4.getSegment(c, i, segIdx) DCNL DCSP  DCSP  DCSP isActive = self._slowIsSegmentActive(seg, 't') DCNL DCSP  DCSP  DCSP if (onlyActiveSegments and (not isActive)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP isActiveStr = ('*' if isActive else ' DCSP ') DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP %sSeg DCSP #%-3d' % (isActiveStr, segIdx)), DCNL DCSP  DCSP  DCSP print seg.size(), DCNL DCSP  DCSP  DCSP print seg.isSequenceSegment(), ('%9.7f' % seg.dutyCycle(self.cells4.getNLrnIterations(), False, True)), DCNL DCSP  DCSP  DCSP print ('(%4d/%-4d)' % (seg.getPositiveActivations(), seg.getTotalActivations())), DCNL DCSP  DCSP  DCSP print ('%4d' % (self.cells4.getNLrnIterations() - seg.getLastActiveIteration())), DCNL DCSP  DCSP  DCSP numSyn = seg.size() DCNL DCSP  DCSP  DCSP for s in xrange(numSyn): DCNL DCSP  DCSP  DCSP  DCSP (sc, si) = self.getColCellIdx(seg.getSrcCellIdx(s)) DCNL DCSP  DCSP  DCSP  DCSP print ('[%d,%d]%4.2f' % (sc, si, seg.getPermanence(s))), DCNL DCSP  DCSP  DCSP print
def getAvgLearnedSeqLength(self): DCNL DCSP return self.cells4.getAvgLearnedSeqLength()
def getColCellIdx(self, idx): DCNL DCSP c = (idx // self.cellsPerColumn) DCNL DCSP i = (idx - (c * self.cellsPerColumn)) DCNL DCSP return (c, i)
def getSegmentOnCell(self, c, i, segIdx): DCNL DCSP segList = self.cells4.getNonEmptySegList(c, i) DCNL DCSP seg = self.cells4.getSegment(c, i, segList[segIdx]) DCNL DCSP numSyn = seg.size() DCNL DCSP assert (numSyn != 0) DCNL DCSP result = [] DCNL DCSP result.append([int(segIdx), bool(seg.isSequenceSegment()), seg.getPositiveActivations(), seg.getTotalActivations(), seg.getLastActiveIteration(), seg.getLastPosDutyCycle(), seg.getLastPosDutyCycleIteration()]) DCNL DCSP for s in xrange(numSyn): DCNL DCSP  DCSP (sc, si) = self.getColCellIdx(seg.getSrcCellIdx(s)) DCNL DCSP  DCSP result.append([int(sc), int(si), seg.getPermanence(s)]) DCNL DCSP return result
def getNumSegments(self): DCNL DCSP return self.cells4.nSegments()
def getNumSynapses(self): DCNL DCSP return self.cells4.nSynapses()
def getNumSegmentsInCell(self, c, i): DCNL DCSP return self.cells4.nSegmentsOnCell(c, i)
def getSegmentInfo(self, collectActiveData=False): DCNL DCSP assert (collectActiveData == False) DCNL DCSP (nSegments, nSynapses) = (self.getNumSegments(), self.cells4.nSynapses()) DCNL DCSP (distSegSizes, distNSegsPerCell) = ({}, {}) DCNL DCSP (nActiveSegs, nActiveSynapses) = (0, 0) DCNL DCSP distPermValues = {} DCNL DCSP numAgeBuckets = 20 DCNL DCSP distAges = [] DCNL DCSP ageBucketSize = int(((self.iterationIdx + 20) / 20)) DCNL DCSP for i in range(numAgeBuckets): DCNL DCSP  DCSP distAges.append([('%d-%d' % ((i * ageBucketSize), (((i + 1) * ageBucketSize) - 1))), 0]) DCNL DCSP for c in xrange(self.numberOfCols): DCNL DCSP  DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP  DCSP nSegmentsThisCell = self.getNumSegmentsInCell(c, i) DCNL DCSP  DCSP  DCSP if (nSegmentsThisCell > 0): DCNL DCSP  DCSP  DCSP  DCSP if distNSegsPerCell.has_key(nSegmentsThisCell): DCNL DCSP  DCSP  DCSP  DCSP  DCSP distNSegsPerCell[nSegmentsThisCell] += 1 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP distNSegsPerCell[nSegmentsThisCell] = 1 DCNL DCSP  DCSP  DCSP  DCSP segList = self.cells4.getNonEmptySegList(c, i) DCNL DCSP  DCSP  DCSP  DCSP for segIdx in xrange(nSegmentsThisCell): DCNL DCSP  DCSP  DCSP  DCSP  DCSP seg = self.getSegmentOnCell(c, i, segIdx) DCNL DCSP  DCSP  DCSP  DCSP  DCSP nSynapsesThisSeg = (len(seg) - 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (nSynapsesThisSeg > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if distSegSizes.has_key(nSynapsesThisSeg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP distSegSizes[nSynapsesThisSeg] += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP distSegSizes[nSynapsesThisSeg] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for syn in seg[1:]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP p = int((syn[2] * 10)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if distPermValues.has_key(p): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP distPermValues[p] += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP distPermValues[p] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP segObj = self.cells4.getSegment(c, i, segList[segIdx]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP age = (self.iterationIdx - segObj.getLastActiveIteration()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ageBucket = int((age / ageBucketSize)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP distAges[ageBucket][1] += 1 DCNL DCSP return (nSegments, nSynapses, nActiveSegs, nActiveSynapses, distSegSizes, distNSegsPerCell, distPermValues, distAges)
def __getitem__(self, columnIndex): DCNL DCSP return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
def replace(self, columnIndex, bitmap): DCNL DCSP return super(_SparseMatrixCorticalColumnAdapter, self).replaceSparseRow(columnIndex, bitmap)
def update(self, columnIndex, vector): DCNL DCSP return super(_SparseMatrixCorticalColumnAdapter, self).setRowFromDense(columnIndex, vector)
def getColumnDimensions(self): DCNL DCSP return self._columnDimensions
def getInputDimensions(self): DCNL DCSP return self._inputDimensions
def getNumColumns(self): DCNL DCSP return self._numColumns
def getNumInputs(self): DCNL DCSP return self._numInputs
def getPotentialRadius(self): DCNL DCSP return self._potentialRadius
def setPotentialRadius(self, potentialRadius): DCNL DCSP self._potentialRadius = potentialRadius
def getPotentialPct(self): DCNL DCSP return self._potentialPct
def setPotentialPct(self, potentialPct): DCNL DCSP self._potentialPct = potentialPct
def getGlobalInhibition(self): DCNL DCSP return self._globalInhibition
def setGlobalInhibition(self, globalInhibition): DCNL DCSP self._globalInhibition = globalInhibition
def getNumActiveColumnsPerInhArea(self): DCNL DCSP return self._numActiveColumnsPerInhArea
def setNumActiveColumnsPerInhArea(self, numActiveColumnsPerInhArea): DCNL DCSP assert (numActiveColumnsPerInhArea > 0) DCNL DCSP self._numActiveColumnsPerInhArea = numActiveColumnsPerInhArea DCNL DCSP self._localAreaDensity = 0
def getLocalAreaDensity(self): DCNL DCSP return self._localAreaDensity
def setLocalAreaDensity(self, localAreaDensity): DCNL DCSP assert ((localAreaDensity > 0) and (localAreaDensity <= 1)) DCNL DCSP self._localAreaDensity = localAreaDensity DCNL DCSP self._numActiveColumnsPerInhArea = 0
def getStimulusThreshold(self): DCNL DCSP return self._stimulusThreshold
def setStimulusThreshold(self, stimulusThreshold): DCNL DCSP self._stimulusThreshold = stimulusThreshold
def getInhibitionRadius(self): DCNL DCSP return self._inhibitionRadius
def setInhibitionRadius(self, inhibitionRadius): DCNL DCSP self._inhibitionRadius = inhibitionRadius
def getDutyCyclePeriod(self): DCNL DCSP return self._dutyCyclePeriod
def setDutyCyclePeriod(self, dutyCyclePeriod): DCNL DCSP self._dutyCyclePeriod = dutyCyclePeriod
def getBoostStrength(self): DCNL DCSP return self._boostStrength
def setBoostStrength(self, boostStrength): DCNL DCSP self._boostStrength = boostStrength
def getIterationNum(self): DCNL DCSP return self._iterationNum
def setIterationNum(self, iterationNum): DCNL DCSP self._iterationNum = iterationNum
def getIterationLearnNum(self): DCNL DCSP return self._iterationLearnNum
def setIterationLearnNum(self, iterationLearnNum): DCNL DCSP self._iterationLearnNum = iterationLearnNum
def getSpVerbosity(self): DCNL DCSP return self._spVerbosity
def setSpVerbosity(self, spVerbosity): DCNL DCSP self._spVerbosity = spVerbosity
def getUpdatePeriod(self): DCNL DCSP return self._updatePeriod
def setUpdatePeriod(self, updatePeriod): DCNL DCSP self._updatePeriod = updatePeriod
def getSynPermTrimThreshold(self): DCNL DCSP return self._synPermTrimThreshold
def setSynPermTrimThreshold(self, synPermTrimThreshold): DCNL DCSP self._synPermTrimThreshold = synPermTrimThreshold
def getSynPermActiveInc(self): DCNL DCSP return self._synPermActiveInc
def setSynPermActiveInc(self, synPermActiveInc): DCNL DCSP self._synPermActiveInc = synPermActiveInc
def getSynPermInactiveDec(self): DCNL DCSP return self._synPermInactiveDec
def setSynPermInactiveDec(self, synPermInactiveDec): DCNL DCSP self._synPermInactiveDec = synPermInactiveDec
def getSynPermBelowStimulusInc(self): DCNL DCSP return self._synPermBelowStimulusInc
def setSynPermBelowStimulusInc(self, synPermBelowStimulusInc): DCNL DCSP self._synPermBelowStimulusInc = synPermBelowStimulusInc
def getSynPermConnected(self): DCNL DCSP return self._synPermConnected
def setSynPermConnected(self, synPermConnected): DCNL DCSP self._synPermConnected = synPermConnected
def getMinPctOverlapDutyCycles(self): DCNL DCSP return self._minPctOverlapDutyCycles
def setMinPctOverlapDutyCycles(self, minPctOverlapDutyCycles): DCNL DCSP self._minPctOverlapDutyCycles = minPctOverlapDutyCycles
def getBoostFactors(self, boostFactors): DCNL DCSP boostFactors[:] = self._boostFactors[:]
def setBoostFactors(self, boostFactors): DCNL DCSP self._boostFactors[:] = boostFactors[:]
def getOverlapDutyCycles(self, overlapDutyCycles): DCNL DCSP overlapDutyCycles[:] = self._overlapDutyCycles[:]
def setOverlapDutyCycles(self, overlapDutyCycles): DCNL DCSP self._overlapDutyCycles[:] = overlapDutyCycles
def getActiveDutyCycles(self, activeDutyCycles): DCNL DCSP activeDutyCycles[:] = self._activeDutyCycles[:]
def setActiveDutyCycles(self, activeDutyCycles): DCNL DCSP self._activeDutyCycles[:] = activeDutyCycles
def getMinOverlapDutyCycles(self, minOverlapDutyCycles): DCNL DCSP minOverlapDutyCycles[:] = self._minOverlapDutyCycles[:]
def setMinOverlapDutyCycles(self, minOverlapDutyCycles): DCNL DCSP self._minOverlapDutyCycles[:] = minOverlapDutyCycles[:]
def getPotential(self, columnIndex, potential): DCNL DCSP assert (columnIndex < self._numColumns) DCNL DCSP potential[:] = self._potentialPools[columnIndex]
def setPotential(self, columnIndex, potential): DCNL DCSP assert (columnIndex < self._numColumns) DCNL DCSP potentialSparse = numpy.where((potential > 0))[0] DCNL DCSP if (len(potentialSparse) < self._stimulusThreshold): DCNL DCSP  DCSP raise Exception((('This DCSP is DCSP likely DCSP due DCSP to DCSP a DCSP ' + 'value DCSP of DCSP stimulusThreshold DCSP that DCSP is DCSP too DCSP large DCSP relative DCSP ') + 'to DCSP the DCSP input DCSP size.')) DCNL DCSP self._potentialPools.replace(columnIndex, potentialSparse)
def getPermanence(self, columnIndex, permanence): DCNL DCSP assert (columnIndex < self._numColumns) DCNL DCSP permanence[:] = self._permanences[columnIndex]
def setPermanence(self, columnIndex, permanence): DCNL DCSP assert (columnIndex < self._numColumns) DCNL DCSP self._updatePermanencesForColumn(permanence, columnIndex, raisePerm=False)
def getConnectedSynapses(self, columnIndex, connectedSynapses): DCNL DCSP assert (columnIndex < self._numColumns) DCNL DCSP connectedSynapses[:] = self._connectedSynapses[columnIndex]
def getConnectedCounts(self, connectedCounts): DCNL DCSP connectedCounts[:] = self._connectedCounts[:]
def getOverlaps(self): DCNL DCSP return self._overlaps
def getBoostedOverlaps(self): DCNL DCSP return self._boostedOverlaps
def compute(self, inputVector, learn, activeArray): DCNL DCSP if (not isinstance(inputVector, numpy.ndarray)): DCNL DCSP  DCSP raise TypeError(('Input DCSP vector DCSP must DCSP be DCSP a DCSP numpy DCSP array, DCSP not DCSP %s' % str(type(inputVector)))) DCNL DCSP if (inputVector.size != self._numInputs): DCNL DCSP  DCSP raise ValueError(("Input DCSP vector DCSP dimensions DCSP don't DCSP match. DCSP Expecting DCSP %s DCSP but DCSP got DCSP %s" % (inputVector.size, self._numInputs))) DCNL DCSP self._updateBookeepingVars(learn) DCNL DCSP inputVector = numpy.array(inputVector, dtype=realDType) DCNL DCSP inputVector.reshape((-1)) DCNL DCSP self._overlaps = self._calculateOverlap(inputVector) DCNL DCSP if learn: DCNL DCSP  DCSP self._boostedOverlaps = (self._boostFactors * self._overlaps) DCNL DCSP else: DCNL DCSP  DCSP self._boostedOverlaps = self._overlaps DCNL DCSP activeColumns = self._inhibitColumns(self._boostedOverlaps) DCNL DCSP if learn: DCNL DCSP  DCSP self._adaptSynapses(inputVector, activeColumns) DCNL DCSP  DCSP self._updateDutyCycles(self._overlaps, activeColumns) DCNL DCSP  DCSP self._bumpUpWeakColumns() DCNL DCSP  DCSP self._updateBoostFactors() DCNL DCSP  DCSP if self._isUpdateRound(): DCNL DCSP  DCSP  DCSP self._updateInhibitionRadius() DCNL DCSP  DCSP  DCSP self._updateMinDutyCycles() DCNL DCSP activeArray.fill(0) DCNL DCSP activeArray[activeColumns] = 1
def stripUnlearnedColumns(self, activeArray): DCNL DCSP neverLearned = numpy.where((self._activeDutyCycles == 0))[0] DCNL DCSP activeArray[neverLearned] = 0
def _updateMinDutyCycles(self): DCNL DCSP if (self._globalInhibition or (self._inhibitionRadius > self._numInputs)): DCNL DCSP  DCSP self._updateMinDutyCyclesGlobal() DCNL DCSP else: DCNL DCSP  DCSP self._updateMinDutyCyclesLocal()
def _updateMinDutyCyclesGlobal(self): DCNL DCSP self._minOverlapDutyCycles.fill((self._minPctOverlapDutyCycles * self._overlapDutyCycles.max()))
def _updateMinDutyCyclesLocal(self): DCNL DCSP for column in xrange(self._numColumns): DCNL DCSP  DCSP neighborhood = self._getColumnNeighborhood(column) DCNL DCSP  DCSP maxActiveDuty = self._activeDutyCycles[neighborhood].max() DCNL DCSP  DCSP maxOverlapDuty = self._overlapDutyCycles[neighborhood].max() DCNL DCSP  DCSP self._minOverlapDutyCycles[column] = (maxOverlapDuty * self._minPctOverlapDutyCycles)
def _updateDutyCycles(self, overlaps, activeColumns): DCNL DCSP overlapArray = numpy.zeros(self._numColumns, dtype=realDType) DCNL DCSP activeArray = numpy.zeros(self._numColumns, dtype=realDType) DCNL DCSP overlapArray[(overlaps > 0)] = 1 DCNL DCSP activeArray[activeColumns] = 1 DCNL DCSP period = self._dutyCyclePeriod DCNL DCSP if (period > self._iterationNum): DCNL DCSP  DCSP period = self._iterationNum DCNL DCSP self._overlapDutyCycles = self._updateDutyCyclesHelper(self._overlapDutyCycles, overlapArray, period) DCNL DCSP self._activeDutyCycles = self._updateDutyCyclesHelper(self._activeDutyCycles, activeArray, period)
def _updateInhibitionRadius(self): DCNL DCSP if self._globalInhibition: DCNL DCSP  DCSP self._inhibitionRadius = int(self._columnDimensions.max()) DCNL DCSP  DCSP return DCNL DCSP avgConnectedSpan = numpy.average([self._avgConnectedSpanForColumnND(i) for i in xrange(self._numColumns)]) DCNL DCSP columnsPerInput = self._avgColumnsPerInput() DCNL DCSP diameter = (avgConnectedSpan * columnsPerInput) DCNL DCSP radius = ((diameter - 1) / 2.0) DCNL DCSP radius = max(1.0, radius) DCNL DCSP self._inhibitionRadius = int((radius + 0.5))
def _avgColumnsPerInput(self): DCNL DCSP numDim = max(self._columnDimensions.size, self._inputDimensions.size) DCNL DCSP colDim = numpy.ones(numDim) DCNL DCSP colDim[:self._columnDimensions.size] = self._columnDimensions DCNL DCSP inputDim = numpy.ones(numDim) DCNL DCSP inputDim[:self._inputDimensions.size] = self._inputDimensions DCNL DCSP columnsPerInput = (colDim.astype(realDType) / inputDim) DCNL DCSP return numpy.average(columnsPerInput)
def _avgConnectedSpanForColumn1D(self, columnIndex): DCNL DCSP assert (self._inputDimensions.size == 1) DCNL DCSP connected = self._connectedSynapses[columnIndex].nonzero()[0] DCNL DCSP if (connected.size == 0): DCNL DCSP  DCSP return 0 DCNL DCSP else: DCNL DCSP  DCSP return ((max(connected) - min(connected)) + 1)
def _avgConnectedSpanForColumn2D(self, columnIndex): DCNL DCSP assert (self._inputDimensions.size == 2) DCNL DCSP connected = self._connectedSynapses[columnIndex] DCNL DCSP (rows, cols) = connected.reshape(self._inputDimensions).nonzero() DCNL DCSP if ((rows.size == 0) and (cols.size == 0)): DCNL DCSP  DCSP return 0 DCNL DCSP rowSpan = ((rows.max() - rows.min()) + 1) DCNL DCSP colSpan = ((cols.max() - cols.min()) + 1) DCNL DCSP return numpy.average([rowSpan, colSpan])
def _avgConnectedSpanForColumnND(self, columnIndex): DCNL DCSP dimensions = self._inputDimensions DCNL DCSP connected = self._connectedSynapses[columnIndex].nonzero()[0] DCNL DCSP if (connected.size == 0): DCNL DCSP  DCSP return 0 DCNL DCSP maxCoord = numpy.empty(self._inputDimensions.size) DCNL DCSP minCoord = numpy.empty(self._inputDimensions.size) DCNL DCSP maxCoord.fill((-1)) DCNL DCSP minCoord.fill(max(self._inputDimensions)) DCNL DCSP for i in connected: DCNL DCSP  DCSP maxCoord = numpy.maximum(maxCoord, numpy.unravel_index(i, dimensions)) DCNL DCSP  DCSP minCoord = numpy.minimum(minCoord, numpy.unravel_index(i, dimensions)) DCNL DCSP return numpy.average(((maxCoord - minCoord) + 1))
def _adaptSynapses(self, inputVector, activeColumns): DCNL DCSP inputIndices = numpy.where((inputVector > 0))[0] DCNL DCSP permChanges = numpy.zeros(self._numInputs, dtype=realDType) DCNL DCSP permChanges.fill(((-1) * self._synPermInactiveDec)) DCNL DCSP permChanges[inputIndices] = self._synPermActiveInc DCNL DCSP for columnIndex in activeColumns: DCNL DCSP  DCSP perm = self._permanences[columnIndex] DCNL DCSP  DCSP maskPotential = numpy.where((self._potentialPools[columnIndex] > 0))[0] DCNL DCSP  DCSP perm[maskPotential] += permChanges[maskPotential] DCNL DCSP  DCSP self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
def _bumpUpWeakColumns(self): DCNL DCSP weakColumns = numpy.where((self._overlapDutyCycles < self._minOverlapDutyCycles))[0] DCNL DCSP for columnIndex in weakColumns: DCNL DCSP  DCSP perm = self._permanences[columnIndex].astype(realDType) DCNL DCSP  DCSP maskPotential = numpy.where((self._potentialPools[columnIndex] > 0))[0] DCNL DCSP  DCSP perm[maskPotential] += self._synPermBelowStimulusInc DCNL DCSP  DCSP self._updatePermanencesForColumn(perm, columnIndex, raisePerm=False)
def _raisePermanenceToThreshold(self, perm, mask): DCNL DCSP if (len(mask) < self._stimulusThreshold): DCNL DCSP  DCSP raise Exception((('This DCSP is DCSP likely DCSP due DCSP to DCSP a DCSP ' + 'value DCSP of DCSP stimulusThreshold DCSP that DCSP is DCSP too DCSP large DCSP relative DCSP ') + 'to DCSP the DCSP input DCSP size. DCSP [len(mask) DCSP < DCSP self._stimulusThreshold]')) DCNL DCSP numpy.clip(perm, self._synPermMin, self._synPermMax, out=perm) DCNL DCSP while True: DCNL DCSP  DCSP numConnected = numpy.nonzero((perm > (self._synPermConnected - PERMANENCE_EPSILON)))[0].size DCNL DCSP  DCSP if (numConnected >= self._stimulusThreshold): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP perm[mask] += self._synPermBelowStimulusInc
def _updatePermanencesForColumn(self, perm, columnIndex, raisePerm=True): DCNL DCSP maskPotential = numpy.where((self._potentialPools[columnIndex] > 0))[0] DCNL DCSP if raisePerm: DCNL DCSP  DCSP self._raisePermanenceToThreshold(perm, maskPotential) DCNL DCSP perm[(perm < self._synPermTrimThreshold)] = 0 DCNL DCSP numpy.clip(perm, self._synPermMin, self._synPermMax, out=perm) DCNL DCSP newConnected = numpy.where((perm >= (self._synPermConnected - PERMANENCE_EPSILON)))[0] DCNL DCSP self._permanences.update(columnIndex, perm) DCNL DCSP self._connectedSynapses.replace(columnIndex, newConnected) DCNL DCSP self._connectedCounts[columnIndex] = newConnected.size
def _initPermConnected(self): DCNL DCSP p = (self._synPermConnected + ((self._synPermMax - self._synPermConnected) * self._random.getReal64())) DCNL DCSP p = (int((p * 100000)) / 100000.0) DCNL DCSP return p
def _initPermNonConnected(self): DCNL DCSP p = (self._synPermConnected * self._random.getReal64()) DCNL DCSP p = (int((p * 100000)) / 100000.0) DCNL DCSP return p
def _initPermanence(self, potential, connectedPct): DCNL DCSP perm = numpy.zeros(self._numInputs, dtype=realDType) DCNL DCSP for i in xrange(self._numInputs): DCNL DCSP  DCSP if (potential[i] < 1): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (self._random.getReal64() <= connectedPct): DCNL DCSP  DCSP  DCSP perm[i] = self._initPermConnected() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP perm[i] = self._initPermNonConnected() DCNL DCSP perm[(perm < self._synPermTrimThreshold)] = 0 DCNL DCSP return perm
def _mapColumn(self, index): DCNL DCSP columnCoords = numpy.unravel_index(index, self._columnDimensions) DCNL DCSP columnCoords = numpy.array(columnCoords, dtype=realDType) DCNL DCSP ratios = (columnCoords / self._columnDimensions) DCNL DCSP inputCoords = (self._inputDimensions * ratios) DCNL DCSP inputCoords += ((0.5 * self._inputDimensions) / self._columnDimensions) DCNL DCSP inputCoords = inputCoords.astype(int) DCNL DCSP inputIndex = numpy.ravel_multi_index(inputCoords, self._inputDimensions) DCNL DCSP return inputIndex
def _mapPotential(self, index): DCNL DCSP centerInput = self._mapColumn(index) DCNL DCSP columnInputs = self._getInputNeighborhood(centerInput).astype(uintType) DCNL DCSP numPotential = int(((columnInputs.size * self._potentialPct) + 0.5)) DCNL DCSP selectedInputs = numpy.empty(numPotential, dtype=uintType) DCNL DCSP self._random.sample(columnInputs, selectedInputs) DCNL DCSP potential = numpy.zeros(self._numInputs, dtype=uintType) DCNL DCSP potential[selectedInputs] = 1 DCNL DCSP return potential
@staticmethod DCNL def _updateDutyCyclesHelper(dutyCycles, newInput, period): DCNL DCSP assert (period >= 1) DCNL DCSP return (((dutyCycles * (period - 1.0)) + newInput) / period)
def _updateBoostFactors(self): DCNL DCSP if self._globalInhibition: DCNL DCSP  DCSP self._updateBoostFactorsGlobal() DCNL DCSP else: DCNL DCSP  DCSP self._updateBoostFactorsLocal()
def _updateBoostFactorsGlobal(self): DCNL DCSP if (self._localAreaDensity > 0): DCNL DCSP  DCSP targetDensity = self._localAreaDensity DCNL DCSP else: DCNL DCSP  DCSP inhibitionArea = (((2 * self._inhibitionRadius) + 1) ** self._columnDimensions.size) DCNL DCSP  DCSP inhibitionArea = min(self._numColumns, inhibitionArea) DCNL DCSP  DCSP targetDensity = (float(self._numActiveColumnsPerInhArea) / inhibitionArea) DCNL DCSP  DCSP targetDensity = min(targetDensity, 0.5) DCNL DCSP self._boostFactors = numpy.exp(((targetDensity - self._activeDutyCycles) * self._boostStrength))
def _updateBoostFactorsLocal(self): DCNL DCSP targetDensity = numpy.zeros(self._numColumns, dtype=realDType) DCNL DCSP for i in xrange(self._numColumns): DCNL DCSP  DCSP maskNeighbors = self._getColumnNeighborhood(i) DCNL DCSP  DCSP targetDensity[i] = numpy.mean(self._activeDutyCycles[maskNeighbors]) DCNL DCSP self._boostFactors = numpy.exp(((targetDensity - self._activeDutyCycles) * self._boostStrength))
def _updateBookeepingVars(self, learn): DCNL DCSP self._iterationNum += 1 DCNL DCSP if learn: DCNL DCSP  DCSP self._iterationLearnNum += 1
def _calculateOverlap(self, inputVector): DCNL DCSP overlaps = numpy.zeros(self._numColumns, dtype=realDType) DCNL DCSP self._connectedSynapses.rightVecSumAtNZ_fast(inputVector.astype(realDType), overlaps) DCNL DCSP return overlaps
def _inhibitColumns(self, overlaps): DCNL DCSP if (self._localAreaDensity > 0): DCNL DCSP  DCSP density = self._localAreaDensity DCNL DCSP else: DCNL DCSP  DCSP inhibitionArea = (((2 * self._inhibitionRadius) + 1) ** self._columnDimensions.size) DCNL DCSP  DCSP inhibitionArea = min(self._numColumns, inhibitionArea) DCNL DCSP  DCSP density = (float(self._numActiveColumnsPerInhArea) / inhibitionArea) DCNL DCSP  DCSP density = min(density, 0.5) DCNL DCSP if (self._globalInhibition or (self._inhibitionRadius > max(self._columnDimensions))): DCNL DCSP  DCSP return self._inhibitColumnsGlobal(overlaps, density) DCNL DCSP else: DCNL DCSP  DCSP return self._inhibitColumnsLocal(overlaps, density)
def _inhibitColumnsGlobal(self, overlaps, density): DCNL DCSP numActive = int((density * self._numColumns)) DCNL DCSP sortedWinnerIndices = numpy.argsort(overlaps, kind='mergesort') DCNL DCSP start = (len(sortedWinnerIndices) - numActive) DCNL DCSP while (start < len(sortedWinnerIndices)): DCNL DCSP  DCSP i = sortedWinnerIndices[start] DCNL DCSP  DCSP if (overlaps[i] >= self._stimulusThreshold): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP start += 1 DCNL DCSP return sortedWinnerIndices[start:][::(-1)]
def _inhibitColumnsLocal(self, overlaps, density): DCNL DCSP activeArray = numpy.zeros(self._numColumns, dtype='bool') DCNL DCSP for (column, overlap) in enumerate(overlaps): DCNL DCSP  DCSP if (overlap >= self._stimulusThreshold): DCNL DCSP  DCSP  DCSP neighborhood = self._getColumnNeighborhood(column) DCNL DCSP  DCSP  DCSP neighborhoodOverlaps = overlaps[neighborhood] DCNL DCSP  DCSP  DCSP numBigger = numpy.count_nonzero((neighborhoodOverlaps > overlap)) DCNL DCSP  DCSP  DCSP ties = numpy.where((neighborhoodOverlaps == overlap)) DCNL DCSP  DCSP  DCSP tiedNeighbors = neighborhood[ties] DCNL DCSP  DCSP  DCSP numTiesLost = numpy.count_nonzero(activeArray[tiedNeighbors]) DCNL DCSP  DCSP  DCSP numActive = int((0.5 + (density * len(neighborhood)))) DCNL DCSP  DCSP  DCSP if ((numBigger + numTiesLost) < numActive): DCNL DCSP  DCSP  DCSP  DCSP activeArray[column] = True DCNL DCSP return activeArray.nonzero()[0]
def _isUpdateRound(self): DCNL DCSP return ((self._iterationNum % self._updatePeriod) == 0)
def _getColumnNeighborhood(self, centerColumn): DCNL DCSP if self._wrapAround: DCNL DCSP  DCSP return topology.wrappingNeighborhood(centerColumn, self._inhibitionRadius, self._columnDimensions) DCNL DCSP else: DCNL DCSP  DCSP return topology.neighborhood(centerColumn, self._inhibitionRadius, self._columnDimensions)
def _getInputNeighborhood(self, centerInput): DCNL DCSP if self._wrapAround: DCNL DCSP  DCSP return topology.wrappingNeighborhood(centerInput, self._potentialRadius, self._inputDimensions) DCNL DCSP else: DCNL DCSP  DCSP return topology.neighborhood(centerInput, self._potentialRadius, self._inputDimensions)
def _seed(self, seed=(-1)): DCNL DCSP if (seed != (-1)): DCNL DCSP  DCSP self._random = NupicRandom(seed) DCNL DCSP else: DCNL DCSP  DCSP self._random = NupicRandom()
def __setstate__(self, state): DCNL DCSP if (state['_version'] < 2): DCNL DCSP  DCSP state['_wrapAround'] = True DCNL DCSP if (state['_version'] < 3): DCNL DCSP  DCSP state['_overlaps'] = numpy.zeros(self._numColumns, dtype=realDType) DCNL DCSP  DCSP state['_boostedOverlaps'] = numpy.zeros(self._numColumns, dtype=realDType) DCNL DCSP state['_version'] = VERSION DCNL DCSP self.__dict__.update(state)
def printParameters(self): DCNL DCSP print '------------PY DCSP  DCSP SpatialPooler DCSP Parameters DCSP ------------------' DCNL DCSP print 'numInputs DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getNumInputs() DCNL DCSP print 'numColumns DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getNumColumns() DCNL DCSP print 'columnDimensions DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self._columnDimensions DCNL DCSP print 'numActiveColumnsPerInhArea DCSP = DCSP ', self.getNumActiveColumnsPerInhArea() DCNL DCSP print 'potentialPct DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getPotentialPct() DCNL DCSP print 'globalInhibition DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getGlobalInhibition() DCNL DCSP print 'localAreaDensity DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getLocalAreaDensity() DCNL DCSP print 'stimulusThreshold DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getStimulusThreshold() DCNL DCSP print 'synPermActiveInc DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getSynPermActiveInc() DCNL DCSP print 'synPermInactiveDec DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getSynPermInactiveDec() DCNL DCSP print 'synPermConnected DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getSynPermConnected() DCNL DCSP print 'minPctOverlapDutyCycle DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getMinPctOverlapDutyCycles() DCNL DCSP print 'dutyCyclePeriod DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getDutyCyclePeriod() DCNL DCSP print 'boostStrength DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getBoostStrength() DCNL DCSP print 'spVerbosity DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self.getSpVerbosity() DCNL DCSP print 'version DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP ', self._version
def __init__(self, claLearningPeriod=None, learningPeriod=288, estimationSamples=100, historicWindowSize=8640, reestimationPeriod=100): DCNL DCSP if (historicWindowSize < estimationSamples): DCNL DCSP  DCSP raise ValueError('estimationSamples DCSP exceeds DCSP historicWindowSize') DCNL DCSP self._iteration = 0 DCNL DCSP self._historicalScores = collections.deque(maxlen=historicWindowSize) DCNL DCSP self._distribution = None DCNL DCSP if (claLearningPeriod != None): DCNL DCSP  DCSP print 'claLearningPeriod DCSP is DCSP deprecated, DCSP use DCSP learningPeriod DCSP instead.' DCNL DCSP  DCSP self._learningPeriod = claLearningPeriod DCNL DCSP else: DCNL DCSP  DCSP self._learningPeriod = learningPeriod DCNL DCSP self._probationaryPeriod = (self._learningPeriod + estimationSamples) DCNL DCSP self._reestimationPeriod = reestimationPeriod
@staticmethod DCNL def computeLogLikelihood(likelihood): DCNL DCSP return (math.log((1.0000000001 - likelihood)) / (-23.02585084720009))
@staticmethod DCNL def _calcSkipRecords(numIngested, windowSize, learningPeriod): DCNL DCSP numShiftedOut = max(0, (numIngested - windowSize)) DCNL DCSP return min(numIngested, max(0, (learningPeriod - numShiftedOut)))
@classmethod DCNL def read(cls, proto): DCNL DCSP anomalyLikelihood = object.__new__(cls) DCNL DCSP anomalyLikelihood._iteration = proto.iteration DCNL DCSP anomalyLikelihood._historicalScores = collections.deque(maxlen=proto.historicWindowSize) DCNL DCSP for (i, score) in enumerate(proto.historicalScores): DCNL DCSP  DCSP anomalyLikelihood._historicalScores.append((i, score.value, score.anomalyScore)) DCNL DCSP if proto.distribution.name: DCNL DCSP  DCSP anomalyLikelihood._distribution = {} DCNL DCSP  DCSP anomalyLikelihood._distribution['name'] = proto.distribution.name DCNL DCSP  DCSP anomalyLikelihood._distribution['mean'] = proto.distribution.mean DCNL DCSP  DCSP anomalyLikelihood._distribution['variance'] = proto.distribution.variance DCNL DCSP  DCSP anomalyLikelihood._distribution['stdev'] = proto.distribution.stdev DCNL DCSP  DCSP anomalyLikelihood._distribution['movingAverage'] = {} DCNL DCSP  DCSP anomalyLikelihood._distribution['movingAverage']['windowSize'] = proto.distribution.movingAverage.windowSize DCNL DCSP  DCSP anomalyLikelihood._distribution['movingAverage']['historicalValues'] = [] DCNL DCSP  DCSP for value in proto.distribution.movingAverage.historicalValues: DCNL DCSP  DCSP  DCSP anomalyLikelihood._distribution['movingAverage']['historicalValues'].append(value) DCNL DCSP  DCSP anomalyLikelihood._distribution['movingAverage']['total'] = proto.distribution.movingAverage.total DCNL DCSP  DCSP anomalyLikelihood._distribution['historicalLikelihoods'] = [] DCNL DCSP  DCSP for likelihood in proto.distribution.historicalLikelihoods: DCNL DCSP  DCSP  DCSP anomalyLikelihood._distribution['historicalLikelihoods'].append(likelihood) DCNL DCSP else: DCNL DCSP  DCSP anomalyLikelihood._distribution = None DCNL DCSP anomalyLikelihood._probationaryPeriod = proto.probationaryPeriod DCNL DCSP anomalyLikelihood._learningPeriod = proto.learningPeriod DCNL DCSP anomalyLikelihood._reestimationPeriod = proto.reestimationPeriod DCNL DCSP return anomalyLikelihood
def write(self, proto): DCNL DCSP proto.iteration = self._iteration DCNL DCSP pHistScores = proto.init('historicalScores', len(self._historicalScores)) DCNL DCSP for (i, score) in enumerate(list(self._historicalScores)): DCNL DCSP  DCSP (_, value, anomalyScore) = score DCNL DCSP  DCSP record = pHistScores[i] DCNL DCSP  DCSP record.value = float(value) DCNL DCSP  DCSP record.anomalyScore = float(anomalyScore) DCNL DCSP if self._distribution: DCNL DCSP  DCSP proto.distribution.name = self._distribution['distributionParams']['name'] DCNL DCSP  DCSP proto.distribution.mean = self._distribution['distributionParams']['mean'] DCNL DCSP  DCSP proto.distribution.variance = self._distribution['distributionParams']['variance'] DCNL DCSP  DCSP proto.distribution.stdev = self._distribution['distributionParams']['stdev'] DCNL DCSP  DCSP proto.distribution.movingAverage.windowSize = self._distribution['movingAverage']['windowSize'] DCNL DCSP  DCSP historicalValues = self._distribution['movingAverage']['historicalValues'] DCNL DCSP  DCSP pHistValues = proto.distribution.movingAverage.init('historicalValues', len(historicalValues)) DCNL DCSP  DCSP for (i, value) in enumerate(historicalValues): DCNL DCSP  DCSP  DCSP pHistValues[i] = float(value) DCNL DCSP  DCSP proto.distribution.movingAverage.historicalValues = self._distribution['movingAverage']['historicalValues'] DCNL DCSP  DCSP proto.distribution.movingAverage.total = self._distribution['movingAverage']['total'] DCNL DCSP  DCSP historicalLikelihoods = self._distribution['historicalLikelihoods'] DCNL DCSP  DCSP pHistLikelihoods = proto.distribution.init('historicalLikelihoods', len(historicalLikelihoods)) DCNL DCSP  DCSP for (i, likelihood) in enumerate(historicalLikelihoods): DCNL DCSP  DCSP  DCSP pHistLikelihoods[i] = float(likelihood) DCNL DCSP proto.probationaryPeriod = self._probationaryPeriod DCNL DCSP proto.learningPeriod = self._learningPeriod DCNL DCSP proto.reestimationPeriod = self._reestimationPeriod DCNL DCSP proto.historicWindowSize = self._historicalScores.maxlen
def anomalyProbability(self, value, anomalyScore, timestamp=None): DCNL DCSP if (timestamp is None): DCNL DCSP  DCSP timestamp = self._iteration DCNL DCSP dataPoint = (timestamp, value, anomalyScore) DCNL DCSP if (self._iteration < self._probationaryPeriod): DCNL DCSP  DCSP likelihood = 0.5 DCNL DCSP else: DCNL DCSP  DCSP if ((self._distribution is None) or ((self._iteration % self._reestimationPeriod) == 0)): DCNL DCSP  DCSP  DCSP numSkipRecords = self._calcSkipRecords(numIngested=self._iteration, windowSize=self._historicalScores.maxlen, learningPeriod=self._learningPeriod) DCNL DCSP  DCSP  DCSP (_, _, self._distribution) = estimateAnomalyLikelihoods(self._historicalScores, skipRecords=numSkipRecords) DCNL DCSP  DCSP (likelihoods, _, self._distribution) = updateAnomalyLikelihoods([dataPoint], self._distribution) DCNL DCSP  DCSP likelihood = (1.0 - likelihoods[0]) DCNL DCSP self._historicalScores.append(dataPoint) DCNL DCSP self._iteration += 1 DCNL DCSP return likelihood
def __init__(self, monitor, title): DCNL DCSP self.monitor = monitor DCNL DCSP self.title = title DCNL DCSP self.data = []
@staticmethod DCNL def prettyPrintDatum(datum): DCNL DCSP return (str(datum) if (datum is not None) else '')
def makeCountsTrace(self): DCNL DCSP trace = CountsTrace(self.monitor, '# DCSP {0}'.format(self.title)) DCNL DCSP trace.data = [len(indices) for indices in self.data] DCNL DCSP return trace
def makeCumCountsTrace(self): DCNL DCSP trace = CountsTrace(self.monitor, '# DCSP (cumulative) DCSP {0}'.format(self.title)) DCNL DCSP countsTrace = self.makeCountsTrace() DCNL DCSP def accumulate(iterator): DCNL DCSP  DCSP total = 0 DCNL DCSP  DCSP for item in iterator: DCNL DCSP  DCSP  DCSP total += item DCNL DCSP  DCSP  DCSP (yield total) DCNL DCSP trace.data = list(accumulate(countsTrace.data)) DCNL DCSP return trace
def mmGetTraceActiveColumns(self): DCNL DCSP return self._mmTraces['activeColumns']
def mmGetTracePredictiveCells(self): DCNL DCSP return self._mmTraces['predictiveCells']
def mmGetTraceNumSegments(self): DCNL DCSP return self._mmTraces['numSegments']
def mmGetTraceNumSynapses(self): DCNL DCSP return self._mmTraces['numSynapses']
def mmGetTraceSequenceLabels(self): DCNL DCSP return self._mmTraces['sequenceLabels']
def mmGetTraceResets(self): DCNL DCSP return self._mmTraces['resets']
def mmGetTracePredictedActiveCells(self): DCNL DCSP self._mmComputeTransitionTraces() DCNL DCSP return self._mmTraces['predictedActiveCells']
def mmGetTracePredictedInactiveCells(self): DCNL DCSP self._mmComputeTransitionTraces() DCNL DCSP return self._mmTraces['predictedInactiveCells']
def mmGetTracePredictedActiveColumns(self): DCNL DCSP self._mmComputeTransitionTraces() DCNL DCSP return self._mmTraces['predictedActiveColumns']
def mmGetTracePredictedInactiveColumns(self): DCNL DCSP self._mmComputeTransitionTraces() DCNL DCSP return self._mmTraces['predictedInactiveColumns']
def mmGetTraceUnpredictedActiveColumns(self): DCNL DCSP self._mmComputeTransitionTraces() DCNL DCSP return self._mmTraces['unpredictedActiveColumns']
def mmGetMetricFromTrace(self, trace): DCNL DCSP return Metric.createFromTrace(trace.makeCountsTrace(), excludeResets=self.mmGetTraceResets())
def mmGetMetricSequencesPredictedActiveCellsPerColumn(self): DCNL DCSP self._mmComputeTransitionTraces() DCNL DCSP numCellsPerColumn = [] DCNL DCSP for predictedActiveCells in self._mmData['predictedActiveCellsForSequence'].values(): DCNL DCSP  DCSP cellsForColumn = self.mapCellsToColumns(predictedActiveCells) DCNL DCSP  DCSP numCellsPerColumn += [len(x) for x in cellsForColumn.values()] DCNL DCSP return Metric(self, '# DCSP predicted DCSP => DCSP active DCSP cells DCSP per DCSP column DCSP for DCSP each DCSP sequence', numCellsPerColumn)
def mmGetMetricSequencesPredictedActiveCellsShared(self): DCNL DCSP self._mmComputeTransitionTraces() DCNL DCSP numSequencesForCell = defaultdict((lambda : 0)) DCNL DCSP for predictedActiveCells in self._mmData['predictedActiveCellsForSequence'].values(): DCNL DCSP  DCSP for cell in predictedActiveCells: DCNL DCSP  DCSP  DCSP numSequencesForCell[cell] += 1 DCNL DCSP return Metric(self, '# DCSP sequences DCSP each DCSP predicted DCSP => DCSP active DCSP cells DCSP appears DCSP in', numSequencesForCell.values())
def mmPrettyPrintConnections(self): DCNL DCSP text = '' DCNL DCSP text += 'Segments: DCSP (format DCSP => DCSP (#) DCSP [(source DCSP cell=permanence DCSP ...), DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ...]\n' DCNL DCSP text += '------------------------------------\n' DCNL DCSP columns = range(self.numberOfColumns()) DCNL DCSP for column in columns: DCNL DCSP  DCSP cells = self.cellsForColumn(column) DCNL DCSP  DCSP for cell in cells: DCNL DCSP  DCSP  DCSP segmentDict = dict() DCNL DCSP  DCSP  DCSP for seg in self.connections.segmentsForCell(cell): DCNL DCSP  DCSP  DCSP  DCSP synapseList = [] DCNL DCSP  DCSP  DCSP  DCSP for synapse in self.connections.synapsesForSegment(seg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP synapseData = self.connections.dataForSynapse(synapse) DCNL DCSP  DCSP  DCSP  DCSP  DCSP synapseList.append((synapseData.presynapticCell, synapseData.permanence)) DCNL DCSP  DCSP  DCSP  DCSP synapseList.sort() DCNL DCSP  DCSP  DCSP  DCSP synapseStringList = ['{0:3}={1:.2f}'.format(sourceCell, permanence) for (sourceCell, permanence) in synapseList] DCNL DCSP  DCSP  DCSP  DCSP segmentDict[seg] = '({0})'.format(' DCSP '.join(synapseStringList)) DCNL DCSP  DCSP  DCSP text += 'Column DCSP {0:3} DCSP / DCSP Cell DCSP {1:3}: DCTB ({2}) DCSP {3}\n'.format(column, cell, len(segmentDict.values()), '[{0}]'.format(', DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP '.join(segmentDict.values()))) DCNL DCSP  DCSP if (column < (len(columns) - 1)): DCNL DCSP  DCSP  DCSP text += '\n' DCNL DCSP text += '------------------------------------\n' DCNL DCSP return text
def mmPrettyPrintSequenceCellRepresentations(self, sortby='Column'): DCNL DCSP self._mmComputeTransitionTraces() DCNL DCSP table = PrettyTable(['Pattern', 'Column', 'predicted=>active DCSP cells']) DCNL DCSP for (sequenceLabel, predictedActiveCells) in self._mmData['predictedActiveCellsForSequence'].iteritems(): DCNL DCSP  DCSP cellsForColumn = self.mapCellsToColumns(predictedActiveCells) DCNL DCSP  DCSP for (column, cells) in cellsForColumn.iteritems(): DCNL DCSP  DCSP  DCSP table.add_row([sequenceLabel, column, list(cells)]) DCNL DCSP return table.get_string(sortby=sortby).encode('utf-8')
def _mmComputeTransitionTraces(self): DCNL DCSP if (not self._mmTransitionTracesStale): DCNL DCSP  DCSP return DCNL DCSP self._mmData['predictedActiveCellsForSequence'] = defaultdict(set) DCNL DCSP self._mmTraces['predictedActiveCells'] = IndicesTrace(self, 'predicted DCSP => DCSP active DCSP cells DCSP (correct)') DCNL DCSP self._mmTraces['predictedInactiveCells'] = IndicesTrace(self, 'predicted DCSP => DCSP inactive DCSP cells DCSP (extra)') DCNL DCSP self._mmTraces['predictedActiveColumns'] = IndicesTrace(self, 'predicted DCSP => DCSP active DCSP columns DCSP (correct)') DCNL DCSP self._mmTraces['predictedInactiveColumns'] = IndicesTrace(self, 'predicted DCSP => DCSP inactive DCSP columns DCSP (extra)') DCNL DCSP self._mmTraces['unpredictedActiveColumns'] = IndicesTrace(self, 'unpredicted DCSP => DCSP active DCSP columns DCSP (bursting)') DCNL DCSP predictedCellsTrace = self._mmTraces['predictedCells'] DCNL DCSP for (i, activeColumns) in enumerate(self.mmGetTraceActiveColumns().data): DCNL DCSP  DCSP predictedActiveCells = set() DCNL DCSP  DCSP predictedInactiveCells = set() DCNL DCSP  DCSP predictedActiveColumns = set() DCNL DCSP  DCSP predictedInactiveColumns = set() DCNL DCSP  DCSP for predictedCell in predictedCellsTrace.data[i]: DCNL DCSP  DCSP  DCSP predictedColumn = self.columnForCell(predictedCell) DCNL DCSP  DCSP  DCSP if (predictedColumn in activeColumns): DCNL DCSP  DCSP  DCSP  DCSP predictedActiveCells.add(predictedCell) DCNL DCSP  DCSP  DCSP  DCSP predictedActiveColumns.add(predictedColumn) DCNL DCSP  DCSP  DCSP  DCSP sequenceLabel = self.mmGetTraceSequenceLabels().data[i] DCNL DCSP  DCSP  DCSP  DCSP if (sequenceLabel is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._mmData['predictedActiveCellsForSequence'][sequenceLabel].add(predictedCell) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP predictedInactiveCells.add(predictedCell) DCNL DCSP  DCSP  DCSP  DCSP predictedInactiveColumns.add(predictedColumn) DCNL DCSP  DCSP unpredictedActiveColumns = (activeColumns - predictedActiveColumns) DCNL DCSP  DCSP self._mmTraces['predictedActiveCells'].data.append(predictedActiveCells) DCNL DCSP  DCSP self._mmTraces['predictedInactiveCells'].data.append(predictedInactiveCells) DCNL DCSP  DCSP self._mmTraces['predictedActiveColumns'].data.append(predictedActiveColumns) DCNL DCSP  DCSP self._mmTraces['predictedInactiveColumns'].data.append(predictedInactiveColumns) DCNL DCSP  DCSP self._mmTraces['unpredictedActiveColumns'].data.append(unpredictedActiveColumns) DCNL DCSP self._mmTransitionTracesStale = False
def mmGetCellActivityPlot(self, title='', showReset=False, resetShading=0.25, activityType='activeCells'): DCNL DCSP if (activityType == 'predictedActiveCells'): DCNL DCSP  DCSP self._mmComputeTransitionTraces() DCNL DCSP cellTrace = copy.deepcopy(self._mmTraces[activityType].data) DCNL DCSP for i in xrange(len(cellTrace)): DCNL DCSP  DCSP cellTrace[i] = self.getCellIndices(cellTrace[i]) DCNL DCSP return self.mmGetCellTracePlot(cellTrace, self.numberOfCells(), activityType, title, showReset, resetShading)
def __init__(self, monitor, title, data): DCNL DCSP self.monitor = monitor DCNL DCSP self.title = title DCNL DCSP self.min = None DCNL DCSP self.max = None DCNL DCSP self.sum = None DCNL DCSP self.mean = None DCNL DCSP self.standardDeviation = None DCNL DCSP self._computeStats(data)
def __init__(self, monitor, title, show=True): DCNL DCSP self._monitor = monitor DCNL DCSP self._title = title DCNL DCSP self._fig = self._initFigure() DCNL DCSP self._show = show DCNL DCSP if self._show: DCNL DCSP  DCSP plt.ion() DCNL DCSP  DCSP plt.show()
def addGraph(self, data, position=111, xlabel=None, ylabel=None): DCNL DCSP ax = self._addBase(position, xlabel=xlabel, ylabel=ylabel) DCNL DCSP ax.plot(data) DCNL DCSP plt.draw()
def addHistogram(self, data, position=111, xlabel=None, ylabel=None, bins=None): DCNL DCSP ax = self._addBase(position, xlabel=xlabel, ylabel=ylabel) DCNL DCSP ax.hist(data, bins=bins, color='green', alpha=0.8) DCNL DCSP plt.draw()
def add2DArray(self, data, position=111, xlabel=None, ylabel=None, cmap=None, aspect='auto', interpolation='nearest', name=None): DCNL DCSP if (cmap is None): DCNL DCSP  DCSP cmap = cm.Greys DCNL DCSP ax = self._addBase(position, xlabel=xlabel, ylabel=ylabel) DCNL DCSP ax.imshow(data, cmap=cmap, aspect=aspect, interpolation=interpolation) DCNL DCSP if self._show: DCNL DCSP  DCSP plt.draw() DCNL DCSP if (name is not None): DCNL DCSP  DCSP if (not os.path.exists('log')): DCNL DCSP  DCSP  DCSP os.mkdir('log') DCNL DCSP  DCSP plt.savefig('log/{name}.png'.format(name=name), bbox_inches='tight', figsize=(8, 6), dpi=400)
def _addBase(self, position, xlabel=None, ylabel=None): DCNL DCSP ax = self._fig.add_subplot(position) DCNL DCSP ax.set_xlabel(xlabel) DCNL DCSP ax.set_ylabel(ylabel) DCNL DCSP return ax
def __init__(self, *args, **kwargs): DCNL DCSP self.mmName = kwargs.get('mmName') DCNL DCSP if ('mmName' in kwargs): DCNL DCSP  DCSP del kwargs['mmName'] DCNL DCSP super(MonitorMixinBase, self).__init__(*args, **kwargs) DCNL DCSP self._mmTraces = None DCNL DCSP self._mmData = None DCNL DCSP self.mmClearHistory()
def mmClearHistory(self): DCNL DCSP self._mmTraces = {} DCNL DCSP self._mmData = {}
@staticmethod DCNL def mmPrettyPrintTraces(traces, breakOnResets=None): DCNL DCSP assert (len(traces) > 0), 'No DCSP traces DCSP found' DCNL DCSP table = PrettyTable((['#'] + [trace.prettyPrintTitle() for trace in traces])) DCNL DCSP for i in xrange(len(traces[0].data)): DCNL DCSP  DCSP if (breakOnResets and breakOnResets.data[i]): DCNL DCSP  DCSP  DCSP table.add_row((['<reset>'] * (len(traces) + 1))) DCNL DCSP  DCSP table.add_row(([i] + [trace.prettyPrintDatum(trace.data[i]) for trace in traces])) DCNL DCSP return table.get_string().encode('utf-8')
@staticmethod DCNL def mmPrettyPrintMetrics(metrics, sigFigs=5): DCNL DCSP assert (len(metrics) > 0), 'No DCSP metrics DCSP found' DCNL DCSP table = PrettyTable(['Metric', 'mean', 'standard DCSP deviation', 'min', 'max', 'sum']) DCNL DCSP for metric in metrics: DCNL DCSP  DCSP table.add_row(([metric.prettyPrintTitle()] + metric.getStats())) DCNL DCSP return table.get_string().encode('utf-8')
def mmGetDefaultTraces(self, verbosity=1): DCNL DCSP return []
def mmGetDefaultMetrics(self, verbosity=1): DCNL DCSP return []
def mmGetCellTracePlot(self, cellTrace, cellCount, activityType, title='', showReset=False, resetShading=0.25): DCNL DCSP plot = Plot(self, title) DCNL DCSP resetTrace = self.mmGetTraceResets().data DCNL DCSP data = numpy.zeros((cellCount, 1)) DCNL DCSP for i in xrange(len(cellTrace)): DCNL DCSP  DCSP if (showReset and resetTrace[i]): DCNL DCSP  DCSP  DCSP activity = (numpy.ones((cellCount, 1)) * resetShading) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP activity = numpy.zeros((cellCount, 1)) DCNL DCSP  DCSP activeIndices = cellTrace[i] DCNL DCSP  DCSP activity[list(activeIndices)] = 1 DCNL DCSP  DCSP data = numpy.concatenate((data, activity), 1) DCNL DCSP plot.add2DArray(data, xlabel='Time', ylabel=activityType, name=title) DCNL DCSP return plot
def __init__(self, columnDimensions=(2048,), cellsPerColumn=32, activationThreshold=13, initialPermanence=0.21, connectedPermanence=0.5, minThreshold=10, maxNewSynapseCount=20, permanenceIncrement=0.1, permanenceDecrement=0.1, seed=42): DCNL DCSP numberOfCols = 1 DCNL DCSP for n in columnDimensions: DCNL DCSP  DCSP numberOfCols *= n DCNL DCSP super(TemporalMemoryShim, self).__init__(numberOfCols=numberOfCols, cellsPerColumn=cellsPerColumn, initialPerm=initialPermanence, connectedPerm=connectedPermanence, minThreshold=minThreshold, newSynapseCount=maxNewSynapseCount, permanenceInc=permanenceIncrement, permanenceDec=permanenceDecrement, permanenceMax=1.0, globalDecay=0, activationThreshold=activationThreshold, seed=seed) DCNL DCSP self.connections = Connections((numberOfCols * cellsPerColumn)) DCNL DCSP self.predictiveCells = set()
def compute(self, activeColumns, learn=True): DCNL DCSP bottomUpInput = numpy.zeros(self.numberOfCols, dtype=dtype) DCNL DCSP bottomUpInput[list(activeColumns)] = 1 DCNL DCSP super(TemporalMemoryShim, self).compute(bottomUpInput, enableLearn=learn, enableInference=True) DCNL DCSP predictedState = self.getPredictedState() DCNL DCSP self.predictiveCells = set(numpy.flatnonzero(predictedState))
def compute(self, recordNum, patternNZ, classification, learn, infer): DCNL DCSP if (self.verbosity >= 1): DCNL DCSP  DCSP print ' DCSP  DCSP learn:', learn DCNL DCSP  DCSP print ' DCSP  DCSP recordNum:', recordNum DCNL DCSP  DCSP print (' DCSP  DCSP patternNZ DCSP (%d):' % len(patternNZ)), patternNZ DCNL DCSP  DCSP print ' DCSP  DCSP classificationIn:', classification DCNL DCSP if (len(self._patternNZHistory) > 0): DCNL DCSP  DCSP if (recordNum < self._patternNZHistory[(-1)][0]): DCNL DCSP  DCSP  DCSP raise ValueError('the DCSP record DCSP number DCSP has DCSP to DCSP increase DCSP monotonically') DCNL DCSP if ((len(self._patternNZHistory) == 0) or (recordNum > self._patternNZHistory[(-1)][0])): DCNL DCSP  DCSP self._patternNZHistory.append((recordNum, patternNZ)) DCNL DCSP retval = {} DCNL DCSP if (max(patternNZ) > self._maxInputIdx): DCNL DCSP  DCSP newMaxInputIdx = max(patternNZ) DCNL DCSP  DCSP for nSteps in self.steps: DCNL DCSP  DCSP  DCSP self._weightMatrix[nSteps] = numpy.concatenate((self._weightMatrix[nSteps], numpy.zeros(shape=((newMaxInputIdx - self._maxInputIdx), (self._maxBucketIdx + 1)))), axis=0) DCNL DCSP  DCSP self._maxInputIdx = int(newMaxInputIdx) DCNL DCSP if (classification is not None): DCNL DCSP  DCSP if (type(classification['bucketIdx']) is not list): DCNL DCSP  DCSP  DCSP bucketIdxList = [classification['bucketIdx']] DCNL DCSP  DCSP  DCSP actValueList = [classification['actValue']] DCNL DCSP  DCSP  DCSP numCategory = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bucketIdxList = classification['bucketIdx'] DCNL DCSP  DCSP  DCSP actValueList = classification['actValue'] DCNL DCSP  DCSP  DCSP numCategory = len(classification['bucketIdx']) DCNL DCSP else: DCNL DCSP  DCSP if learn: DCNL DCSP  DCSP  DCSP raise ValueError('classification DCSP cannot DCSP be DCSP None DCSP when DCSP learn=True') DCNL DCSP  DCSP actValueList = None DCNL DCSP  DCSP bucketIdxList = None DCNL DCSP if infer: DCNL DCSP  DCSP retval = self.infer(patternNZ, actValueList) DCNL DCSP if (learn and (classification['bucketIdx'] is not None)): DCNL DCSP  DCSP for categoryI in range(numCategory): DCNL DCSP  DCSP  DCSP bucketIdx = bucketIdxList[categoryI] DCNL DCSP  DCSP  DCSP actValue = actValueList[categoryI] DCNL DCSP  DCSP  DCSP if (bucketIdx > self._maxBucketIdx): DCNL DCSP  DCSP  DCSP  DCSP for nSteps in self.steps: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._weightMatrix[nSteps] = numpy.concatenate((self._weightMatrix[nSteps], numpy.zeros(shape=((self._maxInputIdx + 1), (bucketIdx - self._maxBucketIdx)))), axis=1) DCNL DCSP  DCSP  DCSP  DCSP self._maxBucketIdx = int(bucketIdx) DCNL DCSP  DCSP  DCSP while (self._maxBucketIdx > (len(self._actualValues) - 1)): DCNL DCSP  DCSP  DCSP  DCSP self._actualValues.append(None) DCNL DCSP  DCSP  DCSP if (self._actualValues[bucketIdx] is None): DCNL DCSP  DCSP  DCSP  DCSP self._actualValues[bucketIdx] = actValue DCNL DCSP  DCSP  DCSP elif (isinstance(actValue, int) or isinstance(actValue, float) or isinstance(actValue, long)): DCNL DCSP  DCSP  DCSP  DCSP self._actualValues[bucketIdx] = (((1.0 - self.actValueAlpha) * self._actualValues[bucketIdx]) + (self.actValueAlpha * actValue)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self._actualValues[bucketIdx] = actValue DCNL DCSP  DCSP for (learnRecordNum, learnPatternNZ) in self._patternNZHistory: DCNL DCSP  DCSP  DCSP error = self._calculateError(recordNum, bucketIdxList) DCNL DCSP  DCSP  DCSP nSteps = (recordNum - learnRecordNum) DCNL DCSP  DCSP  DCSP if (nSteps in self.steps): DCNL DCSP  DCSP  DCSP  DCSP for bit in learnPatternNZ: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._weightMatrix[nSteps][bit, :] += (self.alpha * error[nSteps]) DCNL DCSP if (infer and (self.verbosity >= 1)): DCNL DCSP  DCSP print ' DCSP  DCSP inference: DCSP combined DCSP bucket DCSP likelihoods:' DCNL DCSP  DCSP print ' DCSP  DCSP  DCSP  DCSP actual DCSP bucket DCSP values:', retval['actualValues'] DCNL DCSP  DCSP for (nSteps, votes) in retval.items(): DCNL DCSP  DCSP  DCSP if (nSteps == 'actualValues'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP %d DCSP steps: DCSP ' % nSteps), _pFormatArray(votes) DCNL DCSP  DCSP  DCSP bestBucketIdx = votes.argmax() DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP most DCSP likely DCSP bucket DCSP idx: DCSP %d, DCSP value: DCSP %s' % (bestBucketIdx, retval['actualValues'][bestBucketIdx])) DCNL DCSP  DCSP print DCNL DCSP return retval
def infer(self, patternNZ, actValueList): DCNL DCSP if ((self.steps[0] == 0) or (actValueList is None)): DCNL DCSP  DCSP defaultValue = 0 DCNL DCSP else: DCNL DCSP  DCSP defaultValue = actValueList[0] DCNL DCSP actValues = [(x if (x is not None) else defaultValue) for x in self._actualValues] DCNL DCSP retval = {'actualValues': actValues} DCNL DCSP for nSteps in self.steps: DCNL DCSP  DCSP predictDist = self.inferSingleStep(patternNZ, self._weightMatrix[nSteps]) DCNL DCSP  DCSP retval[nSteps] = predictDist DCNL DCSP return retval
def inferSingleStep(self, patternNZ, weightMatrix): DCNL DCSP outputActivation = weightMatrix[patternNZ].sum(axis=0) DCNL DCSP expOutputActivation = numpy.exp(outputActivation) DCNL DCSP predictDist = (expOutputActivation / numpy.sum(expOutputActivation)) DCNL DCSP return predictDist
def _calculateError(self, recordNum, bucketIdxList): DCNL DCSP error = dict() DCNL DCSP targetDist = numpy.zeros((self._maxBucketIdx + 1)) DCNL DCSP numCategories = len(bucketIdxList) DCNL DCSP for bucketIdx in bucketIdxList: DCNL DCSP  DCSP targetDist[bucketIdx] = (1.0 / numCategories) DCNL DCSP for (learnRecordNum, learnPatternNZ) in self._patternNZHistory: DCNL DCSP  DCSP nSteps = (recordNum - learnRecordNum) DCNL DCSP  DCSP if (nSteps in self.steps): DCNL DCSP  DCSP  DCSP predictDist = self.inferSingleStep(learnPatternNZ, self._weightMatrix[nSteps]) DCNL DCSP  DCSP  DCSP error[nSteps] = (targetDist - predictDist) DCNL DCSP return error
def __eq__(self, other): DCNL DCSP return ((self.cell == other.cell) and (sorted(self._synapses, key=(lambda x: x._ordinal)) == sorted(other._synapses, key=(lambda x: x._ordinal))))
def __eq__(self, other): DCNL DCSP return ((self.segment.cell == other.segment.cell) and (self.presynapticCell == other.presynapticCell) and (abs((self.permanence - other.permanence)) < EPSILON))
def segmentsForCell(self, cell): DCNL DCSP return self._cells[cell]._segments
def synapsesForSegment(self, segment): DCNL DCSP return segment._synapses
def dataForSynapse(self, synapse): DCNL DCSP return synapse
def dataForSegment(self, segment): DCNL DCSP return segment
def getSegment(self, cell, idx): DCNL DCSP return self._cells[cell]._segments[idx]
def segmentForFlatIdx(self, flatIdx): DCNL DCSP return self._segmentForFlatIdx[flatIdx]
def segmentFlatListLength(self): DCNL DCSP return self._nextFlatIdx
def synapsesForPresynapticCell(self, presynapticCell): DCNL DCSP return self._synapsesForPresynapticCell[presynapticCell]
def createSegment(self, cell): DCNL DCSP cellData = self._cells[cell] DCNL DCSP if (len(self._freeFlatIdxs) > 0): DCNL DCSP  DCSP flatIdx = self._freeFlatIdxs.pop() DCNL DCSP else: DCNL DCSP  DCSP flatIdx = self._nextFlatIdx DCNL DCSP  DCSP self._segmentForFlatIdx.append(None) DCNL DCSP  DCSP self._nextFlatIdx += 1 DCNL DCSP ordinal = self._nextSegmentOrdinal DCNL DCSP self._nextSegmentOrdinal += 1 DCNL DCSP segment = Segment(cell, flatIdx, ordinal) DCNL DCSP cellData._segments.append(segment) DCNL DCSP self._segmentForFlatIdx[flatIdx] = segment DCNL DCSP return segment
def destroySegment(self, segment): DCNL DCSP for synapse in segment._synapses: DCNL DCSP  DCSP self._removeSynapseFromPresynapticMap(synapse) DCNL DCSP self._numSynapses -= len(segment._synapses) DCNL DCSP segments = self._cells[segment.cell]._segments DCNL DCSP i = segments.index(segment) DCNL DCSP del segments[i] DCNL DCSP self._freeFlatIdxs.append(segment.flatIdx) DCNL DCSP self._segmentForFlatIdx[segment.flatIdx] = None
def createSynapse(self, segment, presynapticCell, permanence): DCNL DCSP idx = len(segment._synapses) DCNL DCSP synapse = Synapse(segment, presynapticCell, permanence, self._nextSynapseOrdinal) DCNL DCSP self._nextSynapseOrdinal += 1 DCNL DCSP segment._synapses.add(synapse) DCNL DCSP self._synapsesForPresynapticCell[presynapticCell].add(synapse) DCNL DCSP self._numSynapses += 1 DCNL DCSP return synapse
def destroySynapse(self, synapse): DCNL DCSP self._numSynapses -= 1 DCNL DCSP self._removeSynapseFromPresynapticMap(synapse) DCNL DCSP synapse.segment._synapses.remove(synapse)
def updateSynapsePermanence(self, synapse, permanence): DCNL DCSP synapse.permanence = permanence
def computeActivity(self, activePresynapticCells, connectedPermanence): DCNL DCSP numActiveConnectedSynapsesForSegment = ([0] * self._nextFlatIdx) DCNL DCSP numActivePotentialSynapsesForSegment = ([0] * self._nextFlatIdx) DCNL DCSP threshold = (connectedPermanence - EPSILON) DCNL DCSP for cell in activePresynapticCells: DCNL DCSP  DCSP for synapse in self._synapsesForPresynapticCell[cell]: DCNL DCSP  DCSP  DCSP flatIdx = synapse.segment.flatIdx DCNL DCSP  DCSP  DCSP numActivePotentialSynapsesForSegment[flatIdx] += 1 DCNL DCSP  DCSP  DCSP if (synapse.permanence > threshold): DCNL DCSP  DCSP  DCSP  DCSP numActiveConnectedSynapsesForSegment[flatIdx] += 1 DCNL DCSP return (numActiveConnectedSynapsesForSegment, numActivePotentialSynapsesForSegment)
def numSegments(self, cell=None): DCNL DCSP if (cell is not None): DCNL DCSP  DCSP return len(self._cells[cell]._segments) DCNL DCSP return (self._nextFlatIdx - len(self._freeFlatIdxs))
def numSynapses(self, segment=None): DCNL DCSP if (segment is not None): DCNL DCSP  DCSP return len(segment._synapses) DCNL DCSP return self._numSynapses
def segmentPositionSortKey(self, segment): DCNL DCSP return (segment.cell + (segment._ordinal / float(self._nextSegmentOrdinal)))
def write(self, proto): DCNL DCSP protoCells = proto.init('cells', self.numCells) DCNL DCSP for i in xrange(self.numCells): DCNL DCSP  DCSP segments = self._cells[i]._segments DCNL DCSP  DCSP protoSegments = protoCells[i].init('segments', len(segments)) DCNL DCSP  DCSP for (j, segment) in enumerate(segments): DCNL DCSP  DCSP  DCSP synapses = segment._synapses DCNL DCSP  DCSP  DCSP protoSynapses = protoSegments[j].init('synapses', len(synapses)) DCNL DCSP  DCSP  DCSP for (k, synapse) in enumerate(sorted(synapses, key=(lambda s: s._ordinal))): DCNL DCSP  DCSP  DCSP  DCSP protoSynapses[k].presynapticCell = synapse.presynapticCell DCNL DCSP  DCSP  DCSP  DCSP protoSynapses[k].permanence = synapse.permanence
@classmethod DCNL def read(cls, proto): DCNL DCSP protoCells = proto.cells DCNL DCSP connections = cls(len(protoCells)) DCNL DCSP for (cellIdx, protoCell) in enumerate(protoCells): DCNL DCSP  DCSP protoCell = protoCells[cellIdx] DCNL DCSP  DCSP protoSegments = protoCell.segments DCNL DCSP  DCSP connections._cells[cellIdx] = CellData() DCNL DCSP  DCSP segments = connections._cells[cellIdx]._segments DCNL DCSP  DCSP for (segmentIdx, protoSegment) in enumerate(protoSegments): DCNL DCSP  DCSP  DCSP segment = Segment(cellIdx, connections._nextFlatIdx, connections._nextSegmentOrdinal) DCNL DCSP  DCSP  DCSP segments.append(segment) DCNL DCSP  DCSP  DCSP connections._segmentForFlatIdx.append(segment) DCNL DCSP  DCSP  DCSP connections._nextFlatIdx += 1 DCNL DCSP  DCSP  DCSP connections._nextSegmentOrdinal += 1 DCNL DCSP  DCSP  DCSP synapses = segment._synapses DCNL DCSP  DCSP  DCSP protoSynapses = protoSegment.synapses DCNL DCSP  DCSP  DCSP for (synapseIdx, protoSynapse) in enumerate(protoSynapses): DCNL DCSP  DCSP  DCSP  DCSP presynapticCell = protoSynapse.presynapticCell DCNL DCSP  DCSP  DCSP  DCSP synapse = Synapse(segment, presynapticCell, protoSynapse.permanence, ordinal=connections._nextSynapseOrdinal) DCNL DCSP  DCSP  DCSP  DCSP connections._nextSynapseOrdinal += 1 DCNL DCSP  DCSP  DCSP  DCSP synapses.add(synapse) DCNL DCSP  DCSP  DCSP  DCSP connections._synapsesForPresynapticCell[presynapticCell].add(synapse) DCNL DCSP  DCSP  DCSP  DCSP connections._numSynapses += 1 DCNL DCSP return connections
def __eq__(self, other): DCNL DCSP for i in xrange(self.numCells): DCNL DCSP  DCSP segments = self._cells[i]._segments DCNL DCSP  DCSP otherSegments = other._cells[i]._segments DCNL DCSP  DCSP if (len(segments) != len(otherSegments)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP for j in xrange(len(segments)): DCNL DCSP  DCSP  DCSP segment = segments[j] DCNL DCSP  DCSP  DCSP otherSegment = otherSegments[j] DCNL DCSP  DCSP  DCSP synapses = segment._synapses DCNL DCSP  DCSP  DCSP otherSynapses = otherSegment._synapses DCNL DCSP  DCSP  DCSP if (len(synapses) != len(otherSynapses)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP for synapse in synapses: DCNL DCSP  DCSP  DCSP  DCSP found = False DCNL DCSP  DCSP  DCSP  DCSP for candidate in otherSynapses: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (synapse == candidate): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (not found): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP if (len(self._synapsesForPresynapticCell) != len(self._synapsesForPresynapticCell)): DCNL DCSP  DCSP return False DCNL DCSP for i in self._synapsesForPresynapticCell.keys(): DCNL DCSP  DCSP synapses = self._synapsesForPresynapticCell[i] DCNL DCSP  DCSP otherSynapses = other._synapsesForPresynapticCell[i] DCNL DCSP  DCSP if (len(synapses) != len(otherSynapses)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP for synapse in synapses: DCNL DCSP  DCSP  DCSP found = False DCNL DCSP  DCSP  DCSP for candidate in otherSynapses: DCNL DCSP  DCSP  DCSP  DCSP if (synapse == candidate): DCNL DCSP  DCSP  DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not found): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP if (self._numSynapses != other._numSynapses): DCNL DCSP  DCSP return False DCNL DCSP return True
def __ne__(self, other): DCNL DCSP return (not self.__eq__(other))
def _getEphemeralMembers(self): DCNL DCSP return []
def _initEphemerals(self): DCNL DCSP self.segmentUpdates = {} DCNL DCSP self.resetStats() DCNL DCSP self._prevInfPatterns = [] DCNL DCSP self._prevLrnPatterns = [] DCNL DCSP stateShape = (self.numberOfCols, self.cellsPerColumn) DCNL DCSP self.lrnActiveState = {} DCNL DCSP self.lrnActiveState['t'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.lrnActiveState['t-1'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.lrnPredictedState = {} DCNL DCSP self.lrnPredictedState['t'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.lrnPredictedState['t-1'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.infActiveState = {} DCNL DCSP self.infActiveState['t'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.infActiveState['t-1'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.infActiveState['backup'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.infActiveState['candidate'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.infPredictedState = {} DCNL DCSP self.infPredictedState['t'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.infPredictedState['t-1'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.infPredictedState['backup'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.infPredictedState['candidate'] = numpy.zeros(stateShape, dtype='int8') DCNL DCSP self.cellConfidence = {} DCNL DCSP self.cellConfidence['t'] = numpy.zeros(stateShape, dtype='float32') DCNL DCSP self.cellConfidence['t-1'] = numpy.zeros(stateShape, dtype='float32') DCNL DCSP self.cellConfidence['candidate'] = numpy.zeros(stateShape, dtype='float32') DCNL DCSP self.colConfidence = {} DCNL DCSP self.colConfidence['t'] = numpy.zeros(self.numberOfCols, dtype='float32') DCNL DCSP self.colConfidence['t-1'] = numpy.zeros(self.numberOfCols, dtype='float32') DCNL DCSP self.colConfidence['candidate'] = numpy.zeros(self.numberOfCols, dtype='float32')
def __getstate__(self): DCNL DCSP state = self.__dict__.copy() DCNL DCSP for ephemeralMemberName in self._getEphemeralMembers(): DCNL DCSP  DCSP state.pop(ephemeralMemberName, None) DCNL DCSP state['_random'] = self._getRandomState() DCNL DCSP state['version'] = TM_VERSION DCNL DCSP return state
def __setstate__(self, state): DCNL DCSP self._setRandomState(state['_random']) DCNL DCSP del state['_random'] DCNL DCSP version = state.pop('version') DCNL DCSP assert (version == TM_VERSION) DCNL DCSP self.__dict__.update(state)
def write(self, proto): DCNL DCSP proto.version = TM_VERSION DCNL DCSP self._random.write(proto.random) DCNL DCSP proto.numberOfCols = self.numberOfCols DCNL DCSP proto.cellsPerColumn = self.cellsPerColumn DCNL DCSP proto.initialPerm = float(self.initialPerm) DCNL DCSP proto.connectedPerm = float(self.connectedPerm) DCNL DCSP proto.minThreshold = self.minThreshold DCNL DCSP proto.newSynapseCount = self.newSynapseCount DCNL DCSP proto.permanenceInc = float(self.permanenceInc) DCNL DCSP proto.permanenceDec = float(self.permanenceDec) DCNL DCSP proto.permanenceMax = float(self.permanenceMax) DCNL DCSP proto.globalDecay = float(self.globalDecay) DCNL DCSP proto.activationThreshold = self.activationThreshold DCNL DCSP proto.doPooling = self.doPooling DCNL DCSP proto.segUpdateValidDuration = self.segUpdateValidDuration DCNL DCSP proto.burnIn = self.burnIn DCNL DCSP proto.collectStats = self.collectStats DCNL DCSP proto.verbosity = self.verbosity DCNL DCSP proto.pamLength = self.pamLength DCNL DCSP proto.maxAge = self.maxAge DCNL DCSP proto.maxInfBacktrack = self.maxInfBacktrack DCNL DCSP proto.maxLrnBacktrack = self.maxLrnBacktrack DCNL DCSP proto.maxSeqLength = self.maxSeqLength DCNL DCSP proto.maxSegmentsPerCell = self.maxSegmentsPerCell DCNL DCSP proto.maxSynapsesPerSegment = self.maxSynapsesPerSegment DCNL DCSP proto.outputType = self.outputType DCNL DCSP proto.activeColumns = self.activeColumns DCNL DCSP cellListProto = proto.init('cells', len(self.cells)) DCNL DCSP for (i, columnSegments) in enumerate(self.cells): DCNL DCSP  DCSP columnSegmentsProto = cellListProto.init(i, len(columnSegments)) DCNL DCSP  DCSP for (j, cellSegments) in enumerate(columnSegments): DCNL DCSP  DCSP  DCSP cellSegmentsProto = columnSegmentsProto.init(j, len(cellSegments)) DCNL DCSP  DCSP  DCSP for (k, segment) in enumerate(cellSegments): DCNL DCSP  DCSP  DCSP  DCSP segment.write(cellSegmentsProto[k]) DCNL DCSP proto.lrnIterationIdx = self.lrnIterationIdx DCNL DCSP proto.iterationIdx = self.iterationIdx DCNL DCSP proto.segID = self.segID DCNL DCSP if (self.currentOutput is not None): DCNL DCSP  DCSP proto.currentOutput = self.currentOutput.tolist() DCNL DCSP proto.pamCounter = self.pamCounter DCNL DCSP proto.collectSequenceStats = self.collectSequenceStats DCNL DCSP proto.resetCalled = self.resetCalled DCNL DCSP proto.avgInputDensity = (self.avgInputDensity or (-1.0)) DCNL DCSP proto.learnedSeqLength = self.learnedSeqLength DCNL DCSP proto.avgLearnedSeqLength = self.avgLearnedSeqLength DCNL DCSP proto.prevLrnPatterns = self._prevLrnPatterns DCNL DCSP proto.prevInfPatterns = self._prevInfPatterns DCNL DCSP segmentUpdatesListProto = proto.init('segmentUpdates', len(self.segmentUpdates)) DCNL DCSP for (i, (key, updates)) in enumerate(self.segmentUpdates.iteritems()): DCNL DCSP  DCSP cellSegmentUpdatesProto = segmentUpdatesListProto[i] DCNL DCSP  DCSP cellSegmentUpdatesProto.columnIdx = key[0] DCNL DCSP  DCSP cellSegmentUpdatesProto.cellIdx = key[1] DCNL DCSP  DCSP segmentUpdatesProto = cellSegmentUpdatesProto.init('segmentUpdates', len(updates)) DCNL DCSP  DCSP for (j, (lrnIterationIdx, segmentUpdate)) in enumerate(updates): DCNL DCSP  DCSP  DCSP segmentUpdateWrapperProto = segmentUpdatesProto[j] DCNL DCSP  DCSP  DCSP segmentUpdateWrapperProto.lrnIterationIdx = lrnIterationIdx DCNL DCSP  DCSP  DCSP segmentUpdate.write(segmentUpdateWrapperProto.segmentUpdate) DCNL DCSP proto.cellConfidenceT = self.cellConfidence['t'].tolist() DCNL DCSP proto.cellConfidenceT1 = self.cellConfidence['t-1'].tolist() DCNL DCSP proto.cellConfidenceCandidate = self.cellConfidence['candidate'].tolist() DCNL DCSP proto.colConfidenceT = self.colConfidence['t'].tolist() DCNL DCSP proto.colConfidenceT1 = self.colConfidence['t-1'].tolist() DCNL DCSP proto.colConfidenceCandidate = self.colConfidence['candidate'].tolist() DCNL DCSP proto.lrnActiveStateT = self.lrnActiveState['t'].tolist() DCNL DCSP proto.lrnActiveStateT1 = self.lrnActiveState['t-1'].tolist() DCNL DCSP proto.infActiveStateT = self.infActiveState['t'].tolist() DCNL DCSP proto.infActiveStateT1 = self.infActiveState['t-1'].tolist() DCNL DCSP proto.infActiveStateBackup = self.infActiveState['backup'].tolist() DCNL DCSP proto.infActiveStateCandidate = self.infActiveState['candidate'].tolist() DCNL DCSP proto.lrnPredictedStateT = self.lrnPredictedState['t'].tolist() DCNL DCSP proto.lrnPredictedStateT1 = self.lrnPredictedState['t-1'].tolist() DCNL DCSP proto.infPredictedStateT = self.infPredictedState['t'].tolist() DCNL DCSP proto.infPredictedStateT1 = self.infPredictedState['t-1'].tolist() DCNL DCSP proto.infPredictedStateBackup = self.infPredictedState['backup'].tolist() DCNL DCSP proto.infPredictedStateCandidate = self.infPredictedState['candidate'].tolist() DCNL DCSP proto.consolePrinterVerbosity = self.consolePrinterVerbosity
@classmethod DCNL def read(cls, proto): DCNL DCSP assert (proto.version == TM_VERSION) DCNL DCSP obj = object.__new__(cls) DCNL DCSP obj._random = Random() DCNL DCSP obj._random.read(proto.random) DCNL DCSP obj.numberOfCols = int(proto.numberOfCols) DCNL DCSP obj.cellsPerColumn = int(proto.cellsPerColumn) DCNL DCSP obj._numberOfCells = (obj.numberOfCols * obj.cellsPerColumn) DCNL DCSP obj.initialPerm = numpy.float32(proto.initialPerm) DCNL DCSP obj.connectedPerm = numpy.float32(proto.connectedPerm) DCNL DCSP obj.minThreshold = int(proto.minThreshold) DCNL DCSP obj.newSynapseCount = int(proto.newSynapseCount) DCNL DCSP obj.permanenceInc = numpy.float32(proto.permanenceInc) DCNL DCSP obj.permanenceDec = numpy.float32(proto.permanenceDec) DCNL DCSP obj.permanenceMax = numpy.float32(proto.permanenceMax) DCNL DCSP obj.globalDecay = numpy.float32(proto.globalDecay) DCNL DCSP obj.activationThreshold = int(proto.activationThreshold) DCNL DCSP obj.doPooling = proto.doPooling DCNL DCSP obj.segUpdateValidDuration = int(proto.segUpdateValidDuration) DCNL DCSP obj.burnIn = int(proto.burnIn) DCNL DCSP obj.collectStats = proto.collectStats DCNL DCSP obj.verbosity = int(proto.verbosity) DCNL DCSP obj.pamLength = int(proto.pamLength) DCNL DCSP obj.maxAge = int(proto.maxAge) DCNL DCSP obj.maxInfBacktrack = int(proto.maxInfBacktrack) DCNL DCSP obj.maxLrnBacktrack = int(proto.maxLrnBacktrack) DCNL DCSP obj.maxSeqLength = int(proto.maxSeqLength) DCNL DCSP obj.maxSegmentsPerCell = proto.maxSegmentsPerCell DCNL DCSP obj.maxSynapsesPerSegment = proto.maxSynapsesPerSegment DCNL DCSP obj.outputType = proto.outputType DCNL DCSP obj.activeColumns = [int(col) for col in proto.activeColumns] DCNL DCSP obj.cells = [[] for _ in xrange(len(proto.cells))] DCNL DCSP for (columnSegments, columnSegmentsProto) in zip(obj.cells, proto.cells): DCNL DCSP  DCSP columnSegments.extend([[] for _ in xrange(len(columnSegmentsProto))]) DCNL DCSP  DCSP for (cellSegments, cellSegmentsProto) in zip(columnSegments, columnSegmentsProto): DCNL DCSP  DCSP  DCSP for segmentProto in cellSegmentsProto: DCNL DCSP  DCSP  DCSP  DCSP segment = Segment.read(segmentProto, obj) DCNL DCSP  DCSP  DCSP  DCSP cellSegments.append(segment) DCNL DCSP obj.lrnIterationIdx = int(proto.lrnIterationIdx) DCNL DCSP obj.iterationIdx = int(proto.iterationIdx) DCNL DCSP obj.segID = int(proto.segID) DCNL DCSP obj.pamCounter = int(proto.pamCounter) DCNL DCSP obj.collectSequenceStats = proto.collectSequenceStats DCNL DCSP obj.resetCalled = proto.resetCalled DCNL DCSP avgInputDensity = proto.avgInputDensity DCNL DCSP if (avgInputDensity < 0.0): DCNL DCSP  DCSP obj.avgInputDensity = None DCNL DCSP else: DCNL DCSP  DCSP obj.avgInputDensity = avgInputDensity DCNL DCSP obj.learnedSeqLength = int(proto.learnedSeqLength) DCNL DCSP obj.avgLearnedSeqLength = proto.avgLearnedSeqLength DCNL DCSP obj._initEphemerals() DCNL DCSP obj.currentOutput = numpy.array(proto.currentOutput, dtype='float32') DCNL DCSP for pattern in proto.prevLrnPatterns: DCNL DCSP  DCSP obj.prevLrnPatterns.append([v for v in pattern]) DCNL DCSP for pattern in proto.prevInfPatterns: DCNL DCSP  DCSP obj.prevInfPatterns.append([v for v in pattern]) DCNL DCSP for cellWrapperProto in proto.segmentUpdates: DCNL DCSP  DCSP key = (cellWrapperProto.columnIdx, cellWrapperProto.cellIdx) DCNL DCSP  DCSP value = [] DCNL DCSP  DCSP for updateWrapperProto in cellWrapperProto.segmentUpdates: DCNL DCSP  DCSP  DCSP segmentUpdate = SegmentUpdate.read(updateWrapperProto.segmentUpdate, obj) DCNL DCSP  DCSP  DCSP value.append((int(updateWrapperProto.lrnIterationIdx), segmentUpdate)) DCNL DCSP  DCSP obj.segmentUpdates[key] = value DCNL DCSP numpy.copyto(obj.cellConfidence['t'], proto.cellConfidenceT) DCNL DCSP numpy.copyto(obj.cellConfidence['t-1'], proto.cellConfidenceT1) DCNL DCSP numpy.copyto(obj.cellConfidence['candidate'], proto.cellConfidenceCandidate) DCNL DCSP numpy.copyto(obj.colConfidence['t'], proto.colConfidenceT) DCNL DCSP numpy.copyto(obj.colConfidence['t-1'], proto.colConfidenceT1) DCNL DCSP numpy.copyto(obj.colConfidence['candidate'], proto.colConfidenceCandidate) DCNL DCSP numpy.copyto(obj.lrnActiveState['t'], proto.lrnActiveStateT) DCNL DCSP numpy.copyto(obj.lrnActiveState['t-1'], proto.lrnActiveStateT1) DCNL DCSP numpy.copyto(obj.infActiveState['t'], proto.infActiveStateT) DCNL DCSP numpy.copyto(obj.infActiveState['t-1'], proto.infActiveStateT1) DCNL DCSP numpy.copyto(obj.infActiveState['backup'], proto.infActiveStateBackup) DCNL DCSP numpy.copyto(obj.infActiveState['candidate'], proto.infActiveStateCandidate) DCNL DCSP numpy.copyto(obj.lrnPredictedState['t'], proto.lrnPredictedStateT) DCNL DCSP numpy.copyto(obj.lrnPredictedState['t-1'], proto.lrnPredictedStateT1) DCNL DCSP numpy.copyto(obj.infPredictedState['t'], proto.infPredictedStateT) DCNL DCSP numpy.copyto(obj.infPredictedState['t-1'], proto.infPredictedStateT1) DCNL DCSP numpy.copyto(obj.infPredictedState['backup'], proto.infPredictedStateBackup) DCNL DCSP numpy.copyto(obj.infPredictedState['candidate'], proto.infPredictedStateCandidate) DCNL DCSP obj.consolePrinterVerbosity = int(proto.consolePrinterVerbosity) DCNL DCSP return obj
def __getattr__(self, name): DCNL DCSP try: DCNL DCSP  DCSP return super(BacktrackingTM, self).__getattr__(name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise AttributeError(("'TM' DCSP object DCSP has DCSP no DCSP attribute DCSP '%s'" % name))
def saveToFile(self, filePath): DCNL DCSP pass
def loadFromFile(self, filePath): DCNL DCSP pass
def _getRandomState(self): DCNL DCSP return pickle.dumps(self._random)
def _setRandomState(self, state): DCNL DCSP self._random = pickle.loads(state)
def reset(self): DCNL DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP print '\n==== DCSP RESET DCSP =====' DCNL DCSP self.lrnActiveState['t-1'].fill(0) DCNL DCSP self.lrnActiveState['t'].fill(0) DCNL DCSP self.lrnPredictedState['t-1'].fill(0) DCNL DCSP self.lrnPredictedState['t'].fill(0) DCNL DCSP self.infActiveState['t-1'].fill(0) DCNL DCSP self.infActiveState['t'].fill(0) DCNL DCSP self.infPredictedState['t-1'].fill(0) DCNL DCSP self.infPredictedState['t'].fill(0) DCNL DCSP self.cellConfidence['t-1'].fill(0) DCNL DCSP self.cellConfidence['t'].fill(0) DCNL DCSP self.segmentUpdates = {} DCNL DCSP self._internalStats['nInfersSinceReset'] = 0 DCNL DCSP self._internalStats['curPredictionScore'] = 0 DCNL DCSP self._internalStats['curPredictionScore2'] = 0 DCNL DCSP self._internalStats['curFalseNegativeScore'] = 0 DCNL DCSP self._internalStats['curFalsePositiveScore'] = 0 DCNL DCSP self._internalStats['curMissing'] = 0 DCNL DCSP self._internalStats['curExtra'] = 0 DCNL DCSP self._internalStats['prevSequenceSignature'] = None DCNL DCSP if self.collectSequenceStats: DCNL DCSP  DCSP if (self._internalStats['confHistogram'].sum() > 0): DCNL DCSP  DCSP  DCSP sig = self._internalStats['confHistogram'].copy() DCNL DCSP  DCSP  DCSP sig.reshape((self.numberOfCols * self.cellsPerColumn)) DCNL DCSP  DCSP  DCSP self._internalStats['prevSequenceSignature'] = sig DCNL DCSP  DCSP self._internalStats['confHistogram'].fill(0) DCNL DCSP self.resetCalled = True DCNL DCSP self._prevInfPatterns = [] DCNL DCSP self._prevLrnPatterns = []
def resetStats(self): DCNL DCSP self._stats = dict() DCNL DCSP self._internalStats = dict() DCNL DCSP self._internalStats['nInfersSinceReset'] = 0 DCNL DCSP self._internalStats['nPredictions'] = 0 DCNL DCSP self._internalStats['curPredictionScore'] = 0 DCNL DCSP self._internalStats['curPredictionScore2'] = 0 DCNL DCSP self._internalStats['predictionScoreTotal2'] = 0 DCNL DCSP self._internalStats['curFalseNegativeScore'] = 0 DCNL DCSP self._internalStats['falseNegativeScoreTotal'] = 0 DCNL DCSP self._internalStats['curFalsePositiveScore'] = 0 DCNL DCSP self._internalStats['falsePositiveScoreTotal'] = 0 DCNL DCSP self._internalStats['pctExtraTotal'] = 0 DCNL DCSP self._internalStats['pctMissingTotal'] = 0 DCNL DCSP self._internalStats['curMissing'] = 0 DCNL DCSP self._internalStats['curExtra'] = 0 DCNL DCSP self._internalStats['totalMissing'] = 0 DCNL DCSP self._internalStats['totalExtra'] = 0 DCNL DCSP self._internalStats['prevSequenceSignature'] = None DCNL DCSP if self.collectSequenceStats: DCNL DCSP  DCSP self._internalStats['confHistogram'] = numpy.zeros((self.numberOfCols, self.cellsPerColumn), dtype='float32')
def getStats(self): DCNL DCSP if (not self.collectStats): DCNL DCSP  DCSP return None DCNL DCSP self._stats['nPredictions'] = self._internalStats['nPredictions'] DCNL DCSP self._stats['curMissing'] = self._internalStats['curMissing'] DCNL DCSP self._stats['curExtra'] = self._internalStats['curExtra'] DCNL DCSP self._stats['totalMissing'] = self._internalStats['totalMissing'] DCNL DCSP self._stats['totalExtra'] = self._internalStats['totalExtra'] DCNL DCSP nPredictions = max(1, self._stats['nPredictions']) DCNL DCSP self._stats['curPredictionScore2'] = self._internalStats['curPredictionScore2'] DCNL DCSP self._stats['predictionScoreAvg2'] = (self._internalStats['predictionScoreTotal2'] / nPredictions) DCNL DCSP self._stats['curFalseNegativeScore'] = self._internalStats['curFalseNegativeScore'] DCNL DCSP self._stats['falseNegativeAvg'] = (self._internalStats['falseNegativeScoreTotal'] / nPredictions) DCNL DCSP self._stats['curFalsePositiveScore'] = self._internalStats['curFalsePositiveScore'] DCNL DCSP self._stats['falsePositiveAvg'] = (self._internalStats['falsePositiveScoreTotal'] / nPredictions) DCNL DCSP self._stats['pctExtraAvg'] = (self._internalStats['pctExtraTotal'] / nPredictions) DCNL DCSP self._stats['pctMissingAvg'] = (self._internalStats['pctMissingTotal'] / nPredictions) DCNL DCSP self._stats['prevSequenceSignature'] = self._internalStats['prevSequenceSignature'] DCNL DCSP return self._stats
def _updateStatsInferEnd(self, stats, bottomUpNZ, predictedState, colConfidence): DCNL DCSP if (not self.collectStats): DCNL DCSP  DCSP return DCNL DCSP stats['nInfersSinceReset'] += 1 DCNL DCSP (numExtra2, numMissing2, confidences2) = self._checkPrediction(patternNZs=[bottomUpNZ], output=predictedState, colConfidence=colConfidence) DCNL DCSP (predictionScore, positivePredictionScore, negativePredictionScore) = confidences2[0] DCNL DCSP stats['curPredictionScore2'] = float(predictionScore) DCNL DCSP stats['curFalseNegativeScore'] = (1.0 - float(positivePredictionScore)) DCNL DCSP stats['curFalsePositiveScore'] = float(negativePredictionScore) DCNL DCSP stats['curMissing'] = numMissing2 DCNL DCSP stats['curExtra'] = numExtra2 DCNL DCSP if (stats['nInfersSinceReset'] <= self.burnIn): DCNL DCSP  DCSP return DCNL DCSP stats['nPredictions'] += 1 DCNL DCSP numExpected = max(1.0, float(len(bottomUpNZ))) DCNL DCSP stats['totalMissing'] += numMissing2 DCNL DCSP stats['totalExtra'] += numExtra2 DCNL DCSP stats['pctExtraTotal'] += ((100.0 * numExtra2) / numExpected) DCNL DCSP stats['pctMissingTotal'] += ((100.0 * numMissing2) / numExpected) DCNL DCSP stats['predictionScoreTotal2'] += float(predictionScore) DCNL DCSP stats['falseNegativeScoreTotal'] += (1.0 - float(positivePredictionScore)) DCNL DCSP stats['falsePositiveScoreTotal'] += float(negativePredictionScore) DCNL DCSP if self.collectSequenceStats: DCNL DCSP  DCSP cc = (self.cellConfidence['t-1'] * self.infActiveState['t']) DCNL DCSP  DCSP sconf = cc.sum(axis=1) DCNL DCSP  DCSP for c in range(self.numberOfCols): DCNL DCSP  DCSP  DCSP if (sconf[c] > 0): DCNL DCSP  DCSP  DCSP  DCSP cc[c, :] /= sconf[c] DCNL DCSP  DCSP self._internalStats['confHistogram'] += cc
def printState(self, aState): DCNL DCSP def formatRow(var, i): DCNL DCSP  DCSP s = '' DCNL DCSP  DCSP for c in range(self.numberOfCols): DCNL DCSP  DCSP  DCSP if ((c > 0) and ((c % 10) == 0)): DCNL DCSP  DCSP  DCSP  DCSP s += ' DCSP ' DCNL DCSP  DCSP  DCSP s += str(var[(c, i)]) DCNL DCSP  DCSP s += ' DCSP ' DCNL DCSP  DCSP return s DCNL DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP print formatRow(aState, i)
def printConfidence(self, aState, maxCols=20): DCNL DCSP def formatFPRow(var, i): DCNL DCSP  DCSP s = '' DCNL DCSP  DCSP for c in range(min(maxCols, self.numberOfCols)): DCNL DCSP  DCSP  DCSP if ((c > 0) and ((c % 10) == 0)): DCNL DCSP  DCSP  DCSP  DCSP s += ' DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP s += (' DCSP %5.3f' % var[(c, i)]) DCNL DCSP  DCSP s += ' DCSP ' DCNL DCSP  DCSP return s DCNL DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP print formatFPRow(aState, i)
def printColConfidence(self, aState, maxCols=20): DCNL DCSP def formatFPRow(var): DCNL DCSP  DCSP s = '' DCNL DCSP  DCSP for c in range(min(maxCols, self.numberOfCols)): DCNL DCSP  DCSP  DCSP if ((c > 0) and ((c % 10) == 0)): DCNL DCSP  DCSP  DCSP  DCSP s += ' DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP s += (' DCSP %5.3f' % var[c]) DCNL DCSP  DCSP s += ' DCSP ' DCNL DCSP  DCSP return s DCNL DCSP print formatFPRow(aState)
def printStates(self, printPrevious=True, printLearnState=True): DCNL DCSP def formatRow(var, i): DCNL DCSP  DCSP s = '' DCNL DCSP  DCSP for c in range(self.numberOfCols): DCNL DCSP  DCSP  DCSP if ((c > 0) and ((c % 10) == 0)): DCNL DCSP  DCSP  DCSP  DCSP s += ' DCSP ' DCNL DCSP  DCSP  DCSP s += str(var[(c, i)]) DCNL DCSP  DCSP s += ' DCSP ' DCNL DCSP  DCSP return s DCNL DCSP print '\nInference DCSP Active DCSP state' DCNL DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP if printPrevious: DCNL DCSP  DCSP  DCSP print formatRow(self.infActiveState['t-1'], i), DCNL DCSP  DCSP print formatRow(self.infActiveState['t'], i) DCNL DCSP print 'Inference DCSP Predicted DCSP state' DCNL DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP if printPrevious: DCNL DCSP  DCSP  DCSP print formatRow(self.infPredictedState['t-1'], i), DCNL DCSP  DCSP print formatRow(self.infPredictedState['t'], i) DCNL DCSP if printLearnState: DCNL DCSP  DCSP print '\nLearn DCSP Active DCSP state' DCNL DCSP  DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP  DCSP if printPrevious: DCNL DCSP  DCSP  DCSP  DCSP print formatRow(self.lrnActiveState['t-1'], i), DCNL DCSP  DCSP  DCSP print formatRow(self.lrnActiveState['t'], i) DCNL DCSP  DCSP print 'Learn DCSP Predicted DCSP state' DCNL DCSP  DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP  DCSP if printPrevious: DCNL DCSP  DCSP  DCSP  DCSP print formatRow(self.lrnPredictedState['t-1'], i), DCNL DCSP  DCSP  DCSP print formatRow(self.lrnPredictedState['t'], i)
def printOutput(self, y): DCNL DCSP print 'Output' DCNL DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP for c in xrange(self.numberOfCols): DCNL DCSP  DCSP  DCSP print int(y[(c, i)]), DCNL DCSP  DCSP print
def printInput(self, x): DCNL DCSP print 'Input' DCNL DCSP for c in xrange(self.numberOfCols): DCNL DCSP  DCSP print int(x[c]), DCNL DCSP print
def printParameters(self): DCNL DCSP print 'numberOfCols=', self.numberOfCols DCNL DCSP print 'cellsPerColumn=', self.cellsPerColumn DCNL DCSP print 'minThreshold=', self.minThreshold DCNL DCSP print 'newSynapseCount=', self.newSynapseCount DCNL DCSP print 'activationThreshold=', self.activationThreshold DCNL DCSP print DCNL DCSP print 'initialPerm=', self.initialPerm DCNL DCSP print 'connectedPerm=', self.connectedPerm DCNL DCSP print 'permanenceInc=', self.permanenceInc DCNL DCSP print 'permanenceDec=', self.permanenceDec DCNL DCSP print 'permanenceMax=', self.permanenceMax DCNL DCSP print 'globalDecay=', self.globalDecay DCNL DCSP print DCNL DCSP print 'doPooling=', self.doPooling DCNL DCSP print 'segUpdateValidDuration=', self.segUpdateValidDuration DCNL DCSP print 'pamLength=', self.pamLength
def printActiveIndices(self, state, andValues=False): DCNL DCSP if (len(state.shape) == 2): DCNL DCSP  DCSP (cols, cellIdxs) = state.nonzero() DCNL DCSP else: DCNL DCSP  DCSP cols = state.nonzero()[0] DCNL DCSP  DCSP cellIdxs = numpy.zeros(len(cols)) DCNL DCSP if (len(cols) == 0): DCNL DCSP  DCSP print 'NONE' DCNL DCSP  DCSP return DCNL DCSP prevCol = (-1) DCNL DCSP for (col, cellIdx) in zip(cols, cellIdxs): DCNL DCSP  DCSP if (col != prevCol): DCNL DCSP  DCSP  DCSP if (prevCol != (-1)): DCNL DCSP  DCSP  DCSP  DCSP print '] DCSP ', DCNL DCSP  DCSP  DCSP print ('Col DCSP %d: DCSP [' % col), DCNL DCSP  DCSP  DCSP prevCol = col DCNL DCSP  DCSP if andValues: DCNL DCSP  DCSP  DCSP if (len(state.shape) == 2): DCNL DCSP  DCSP  DCSP  DCSP value = state[(col, cellIdx)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = state[col] DCNL DCSP  DCSP  DCSP print ('%d: DCSP %s,' % (cellIdx, value)), DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print ('%d,' % cellIdx), DCNL DCSP print ']'
def printComputeEnd(self, output, learn=False): DCNL DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP print '----- DCSP computeEnd DCSP summary: DCSP ' DCNL DCSP  DCSP print 'learn:', learn DCNL DCSP  DCSP print ('numBurstingCols: DCSP %s, DCSP ' % self.infActiveState['t'].min(axis=1).sum()), DCNL DCSP  DCSP print ('curPredScore2: DCSP %s, DCSP ' % self._internalStats['curPredictionScore2']), DCNL DCSP  DCSP print ('curFalsePosScore: DCSP %s, DCSP ' % self._internalStats['curFalsePositiveScore']), DCNL DCSP  DCSP print ('1-curFalseNegScore: DCSP %s, DCSP ' % (1 - self._internalStats['curFalseNegativeScore'])) DCNL DCSP  DCSP print 'numSegments: DCSP ', self.getNumSegments(), DCNL DCSP  DCSP print 'avgLearnedSeqLength: DCSP ', self.avgLearnedSeqLength DCNL DCSP  DCSP print ('----- DCSP infActiveState DCSP (%d DCSP on) DCSP ------' % self.infActiveState['t'].sum()) DCNL DCSP  DCSP self.printActiveIndices(self.infActiveState['t']) DCNL DCSP  DCSP if (self.verbosity >= 6): DCNL DCSP  DCSP  DCSP self.printState(self.infActiveState['t']) DCNL DCSP  DCSP print ('----- DCSP infPredictedState DCSP (%d DCSP on)-----' % self.infPredictedState['t'].sum()) DCNL DCSP  DCSP self.printActiveIndices(self.infPredictedState['t']) DCNL DCSP  DCSP if (self.verbosity >= 6): DCNL DCSP  DCSP  DCSP self.printState(self.infPredictedState['t']) DCNL DCSP  DCSP print ('----- DCSP lrnActiveState DCSP (%d DCSP on) DCSP ------' % self.lrnActiveState['t'].sum()) DCNL DCSP  DCSP self.printActiveIndices(self.lrnActiveState['t']) DCNL DCSP  DCSP if (self.verbosity >= 6): DCNL DCSP  DCSP  DCSP self.printState(self.lrnActiveState['t']) DCNL DCSP  DCSP print ('----- DCSP lrnPredictedState DCSP (%d DCSP on)-----' % self.lrnPredictedState['t'].sum()) DCNL DCSP  DCSP self.printActiveIndices(self.lrnPredictedState['t']) DCNL DCSP  DCSP if (self.verbosity >= 6): DCNL DCSP  DCSP  DCSP self.printState(self.lrnPredictedState['t']) DCNL DCSP  DCSP print '----- DCSP cellConfidence DCSP -----' DCNL DCSP  DCSP self.printActiveIndices(self.cellConfidence['t'], andValues=True) DCNL DCSP  DCSP if (self.verbosity >= 6): DCNL DCSP  DCSP  DCSP self.printConfidence(self.cellConfidence['t']) DCNL DCSP  DCSP print '----- DCSP colConfidence DCSP -----' DCNL DCSP  DCSP self.printActiveIndices(self.colConfidence['t'], andValues=True) DCNL DCSP  DCSP print '----- DCSP cellConfidence[t-1] DCSP for DCSP currently DCSP active DCSP cells DCSP -----' DCNL DCSP  DCSP cc = (self.cellConfidence['t-1'] * self.infActiveState['t']) DCNL DCSP  DCSP self.printActiveIndices(cc, andValues=True) DCNL DCSP  DCSP if (self.verbosity == 4): DCNL DCSP  DCSP  DCSP print 'Cells, DCSP predicted DCSP segments DCSP only:' DCNL DCSP  DCSP  DCSP self.printCells(predictedOnly=True) DCNL DCSP  DCSP elif (self.verbosity >= 5): DCNL DCSP  DCSP  DCSP print 'Cells, DCSP all DCSP segments:' DCNL DCSP  DCSP  DCSP self.printCells(predictedOnly=False) DCNL DCSP  DCSP print DCNL DCSP elif (self.verbosity >= 1): DCNL DCSP  DCSP print 'TM: DCSP learn:', learn DCNL DCSP  DCSP print ('TM: DCSP active DCSP outputs(%d):' % len(output.nonzero()[0])), DCNL DCSP  DCSP self.printActiveIndices(output.reshape(self.numberOfCols, self.cellsPerColumn))
def printSegmentUpdates(self): DCNL DCSP print '=== DCSP SEGMENT DCSP UPDATES DCSP ===, DCSP Num DCSP = DCSP ', len(self.segmentUpdates) DCNL DCSP for (key, updateList) in self.segmentUpdates.iteritems(): DCNL DCSP  DCSP (c, i) = (key[0], key[1]) DCNL DCSP  DCSP print c, i, updateList
def printCell(self, c, i, onlyActiveSegments=False): DCNL DCSP if (len(self.cells[c][i]) > 0): DCNL DCSP  DCSP print 'Column', c, 'Cell', i, ':', DCNL DCSP  DCSP print len(self.cells[c][i]), 'segment(s)' DCNL DCSP  DCSP for (j, s) in enumerate(self.cells[c][i]): DCNL DCSP  DCSP  DCSP isActive = self._isSegmentActive(s, self.infActiveState['t']) DCNL DCSP  DCSP  DCSP if ((not onlyActiveSegments) or isActive): DCNL DCSP  DCSP  DCSP  DCSP isActiveStr = ('*' if isActive else ' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP print (' DCSP  DCSP %sSeg DCSP #%-3d' % (isActiveStr, j)), DCNL DCSP  DCSP  DCSP  DCSP s.debugPrint()
def printCells(self, predictedOnly=False): DCNL DCSP if predictedOnly: DCNL DCSP  DCSP print '--- DCSP PREDICTED DCSP CELLS DCSP ---' DCNL DCSP else: DCNL DCSP  DCSP print '--- DCSP ALL DCSP CELLS DCSP ---' DCNL DCSP print 'Activation DCSP threshold=', self.activationThreshold, DCNL DCSP print 'min DCSP threshold=', self.minThreshold, DCNL DCSP print 'connected DCSP perm=', self.connectedPerm DCNL DCSP for c in xrange(self.numberOfCols): DCNL DCSP  DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP  DCSP if ((not predictedOnly) or self.infPredictedState['t'][(c, i)]): DCNL DCSP  DCSP  DCSP  DCSP self.printCell(c, i, predictedOnly)
def getNumSegmentsInCell(self, c, i): DCNL DCSP return len(self.cells[c][i])
def getNumSynapses(self): DCNL DCSP nSyns = self.getSegmentInfo()[1] DCNL DCSP return nSyns
def getNumSynapsesPerSegmentAvg(self): DCNL DCSP return (float(self.getNumSynapses()) / max(1, self.getNumSegments()))
def getNumSegments(self): DCNL DCSP nSegs = self.getSegmentInfo()[0] DCNL DCSP return nSegs
def getNumCells(self): DCNL DCSP return (self.numberOfCols * self.cellsPerColumn)
def getSegmentOnCell(self, c, i, segIdx): DCNL DCSP seg = self.cells[c][i][segIdx] DCNL DCSP retlist = [[seg.segID, seg.isSequenceSeg, seg.positiveActivations, seg.totalActivations, seg.lastActiveIteration, seg._lastPosDutyCycle, seg._lastPosDutyCycleIteration]] DCNL DCSP retlist += seg.syns DCNL DCSP return retlist
def _addToSegmentUpdates(self, c, i, segUpdate): DCNL DCSP if ((segUpdate is None) or (len(segUpdate.activeSynapses) == 0)): DCNL DCSP  DCSP return DCNL DCSP key = (c, i) DCNL DCSP if self.segmentUpdates.has_key(key): DCNL DCSP  DCSP self.segmentUpdates[key] += [(self.lrnIterationIdx, segUpdate)] DCNL DCSP else: DCNL DCSP  DCSP self.segmentUpdates[key] = [(self.lrnIterationIdx, segUpdate)]
def _removeSegmentUpdate(self, updateInfo): DCNL DCSP (creationDate, segUpdate) = updateInfo DCNL DCSP key = (segUpdate.columnIdx, segUpdate.cellIdx) DCNL DCSP self.segmentUpdates[key].remove(updateInfo)
def _computeOutput(self): DCNL DCSP if (self.outputType == 'activeState1CellPerCol'): DCNL DCSP  DCSP mostActiveCellPerCol = self.cellConfidence['t'].argmax(axis=1) DCNL DCSP  DCSP self.currentOutput = numpy.zeros(self.infActiveState['t'].shape, dtype='float32') DCNL DCSP  DCSP numCols = self.currentOutput.shape[0] DCNL DCSP  DCSP self.currentOutput[(xrange(numCols), mostActiveCellPerCol)] = 1 DCNL DCSP  DCSP activeCols = self.infActiveState['t'].max(axis=1) DCNL DCSP  DCSP inactiveCols = numpy.where((activeCols == 0))[0] DCNL DCSP  DCSP self.currentOutput[inactiveCols, :] = 0 DCNL DCSP elif (self.outputType == 'activeState'): DCNL DCSP  DCSP self.currentOutput = self.infActiveState['t'] DCNL DCSP elif (self.outputType == 'normal'): DCNL DCSP  DCSP self.currentOutput = numpy.logical_or(self.infPredictedState['t'], self.infActiveState['t']) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('Unimplemented DCSP outputType') DCNL DCSP return self.currentOutput.reshape((-1)).astype('float32')
def _getActiveState(self): DCNL DCSP return self.infActiveState['t'].reshape((-1)).astype('float32')
def getPredictedState(self): DCNL DCSP return self.infPredictedState['t']
def predict(self, nSteps): DCNL DCSP pristineTPDynamicState = self._getTPDynamicState() DCNL DCSP assert (nSteps > 0) DCNL DCSP multiStepColumnPredictions = numpy.zeros((nSteps, self.numberOfCols), dtype='float32') DCNL DCSP step = 0 DCNL DCSP while True: DCNL DCSP  DCSP multiStepColumnPredictions[step, :] = self.topDownCompute() DCNL DCSP  DCSP if (step == (nSteps - 1)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP step += 1 DCNL DCSP  DCSP self.infActiveState['t-1'][:, :] = self.infActiveState['t'][:, :] DCNL DCSP  DCSP self.infPredictedState['t-1'][:, :] = self.infPredictedState['t'][:, :] DCNL DCSP  DCSP self.cellConfidence['t-1'][:, :] = self.cellConfidence['t'][:, :] DCNL DCSP  DCSP self.infActiveState['t'][:, :] = self.infPredictedState['t-1'][:, :] DCNL DCSP  DCSP self.infPredictedState['t'].fill(0) DCNL DCSP  DCSP self.cellConfidence['t'].fill(0.0) DCNL DCSP  DCSP self._inferPhase2() DCNL DCSP self._setTPDynamicState(pristineTPDynamicState) DCNL DCSP return multiStepColumnPredictions
def _getTPDynamicStateVariableNames(self): DCNL DCSP return ['infActiveState', 'infPredictedState', 'lrnActiveState', 'lrnPredictedState', 'cellConfidence', 'colConfidence']
def _getTPDynamicState(self): DCNL DCSP tpDynamicState = dict() DCNL DCSP for variableName in self._getTPDynamicStateVariableNames(): DCNL DCSP  DCSP tpDynamicState[variableName] = copy.deepcopy(self.__dict__[variableName]) DCNL DCSP return tpDynamicState
def _setTPDynamicState(self, tpDynamicState): DCNL DCSP for variableName in self._getTPDynamicStateVariableNames(): DCNL DCSP  DCSP self.__dict__[variableName] = tpDynamicState.pop(variableName)
def _updateAvgLearnedSeqLength(self, prevSeqLength): DCNL DCSP if (self.lrnIterationIdx < 100): DCNL DCSP  DCSP alpha = 0.5 DCNL DCSP else: DCNL DCSP  DCSP alpha = 0.1 DCNL DCSP self.avgLearnedSeqLength = (((1.0 - alpha) * self.avgLearnedSeqLength) + (alpha * prevSeqLength))
def getAvgLearnedSeqLength(self): DCNL DCSP return self.avgLearnedSeqLength
def _inferBacktrack(self, activeColumns): DCNL DCSP numPrevPatterns = len(self._prevInfPatterns) DCNL DCSP if (numPrevPatterns <= 0): DCNL DCSP  DCSP return DCNL DCSP currentTimeStepsOffset = (numPrevPatterns - 1) DCNL DCSP self.infActiveState['backup'][:, :] = self.infActiveState['t'][:, :] DCNL DCSP self.infPredictedState['backup'][:, :] = self.infPredictedState['t-1'][:, :] DCNL DCSP badPatterns = [] DCNL DCSP inSequence = False DCNL DCSP candConfidence = None DCNL DCSP candStartOffset = None DCNL DCSP for startOffset in range(0, numPrevPatterns): DCNL DCSP  DCSP if ((startOffset == currentTimeStepsOffset) and (candConfidence is not None)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print (('Trying DCSP to DCSP lock-on DCSP using DCSP startCell DCSP state DCSP from DCSP %d DCSP steps DCSP ago:' % ((numPrevPatterns - 1) - startOffset)), self._prevInfPatterns[startOffset]) DCNL DCSP  DCSP inSequence = False DCNL DCSP  DCSP for offset in range(startOffset, numPrevPatterns): DCNL DCSP  DCSP  DCSP if (offset == currentTimeStepsOffset): DCNL DCSP  DCSP  DCSP  DCSP totalConfidence = self.colConfidence['t'][activeColumns].sum() DCNL DCSP  DCSP  DCSP self.infPredictedState['t-1'][:, :] = self.infPredictedState['t'][:, :] DCNL DCSP  DCSP  DCSP inSequence = self._inferPhase1(self._prevInfPatterns[offset], useStartCells=(offset == startOffset)) DCNL DCSP  DCSP  DCSP if (not inSequence): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP  DCSP print (' DCSP  DCSP backtrack: DCSP computing DCSP predictions DCSP from DCSP ', self._prevInfPatterns[offset]) DCNL DCSP  DCSP  DCSP inSequence = self._inferPhase2() DCNL DCSP  DCSP  DCSP if (not inSequence): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not inSequence): DCNL DCSP  DCSP  DCSP badPatterns.append(startOffset) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP candConfidence = totalConfidence DCNL DCSP  DCSP candStartOffset = startOffset DCNL DCSP  DCSP if ((self.verbosity >= 3) and (startOffset != currentTimeStepsOffset)): DCNL DCSP  DCSP  DCSP print ((' DCSP  DCSP # DCSP Prediction DCSP confidence DCSP of DCSP current DCSP input DCSP after DCSP starting DCSP %d DCSP steps DCSP ago:' % ((numPrevPatterns - 1) - startOffset)), totalConfidence) DCNL DCSP  DCSP if (candStartOffset == currentTimeStepsOffset): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP self.infActiveState['candidate'][:, :] = self.infActiveState['t'][:, :] DCNL DCSP  DCSP self.infPredictedState['candidate'][:, :] = self.infPredictedState['t'][:, :] DCNL DCSP  DCSP self.cellConfidence['candidate'][:, :] = self.cellConfidence['t'][:, :] DCNL DCSP  DCSP self.colConfidence['candidate'][:] = self.colConfidence['t'][:] DCNL DCSP  DCSP break DCNL DCSP if (candStartOffset is None): DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print 'Failed DCSP to DCSP lock DCSP on. DCSP Falling DCSP back DCSP to DCSP bursting DCSP all DCSP unpredicted.' DCNL DCSP  DCSP self.infActiveState['t'][:, :] = self.infActiveState['backup'][:, :] DCNL DCSP  DCSP self._inferPhase2() DCNL DCSP else: DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print (('Locked DCSP on DCSP to DCSP current DCSP input DCSP by DCSP using DCSP start DCSP cells DCSP from DCSP %d DCSP  DCSP steps DCSP ago:' % ((numPrevPatterns - 1) - candStartOffset)), self._prevInfPatterns[candStartOffset]) DCNL DCSP  DCSP if (candStartOffset != currentTimeStepsOffset): DCNL DCSP  DCSP  DCSP self.infActiveState['t'][:, :] = self.infActiveState['candidate'][:, :] DCNL DCSP  DCSP  DCSP self.infPredictedState['t'][:, :] = self.infPredictedState['candidate'][:, :] DCNL DCSP  DCSP  DCSP self.cellConfidence['t'][:, :] = self.cellConfidence['candidate'][:, :] DCNL DCSP  DCSP  DCSP self.colConfidence['t'][:] = self.colConfidence['candidate'][:] DCNL DCSP for i in range(numPrevPatterns): DCNL DCSP  DCSP if ((i in badPatterns) or ((candStartOffset is not None) and (i <= candStartOffset))): DCNL DCSP  DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP  DCSP print ('Removing DCSP useless DCSP pattern DCSP from DCSP history:', self._prevInfPatterns[0]) DCNL DCSP  DCSP  DCSP self._prevInfPatterns.pop(0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP self.infPredictedState['t-1'][:, :] = self.infPredictedState['backup'][:, :]
def _inferPhase1(self, activeColumns, useStartCells): DCNL DCSP self.infActiveState['t'].fill(0) DCNL DCSP numPredictedColumns = 0 DCNL DCSP if useStartCells: DCNL DCSP  DCSP for c in activeColumns: DCNL DCSP  DCSP  DCSP self.infActiveState['t'][(c, 0)] = 1 DCNL DCSP else: DCNL DCSP  DCSP for c in activeColumns: DCNL DCSP  DCSP  DCSP predictingCells = numpy.where((self.infPredictedState['t-1'][c] == 1))[0] DCNL DCSP  DCSP  DCSP numPredictingCells = len(predictingCells) DCNL DCSP  DCSP  DCSP if (numPredictingCells > 0): DCNL DCSP  DCSP  DCSP  DCSP self.infActiveState['t'][(c, predictingCells)] = 1 DCNL DCSP  DCSP  DCSP  DCSP numPredictedColumns += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self.infActiveState['t'][c, :] = 1 DCNL DCSP if (useStartCells or (numPredictedColumns >= (0.5 * len(activeColumns)))): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def _inferPhase2(self): DCNL DCSP self.infPredictedState['t'].fill(0) DCNL DCSP self.cellConfidence['t'].fill(0) DCNL DCSP self.colConfidence['t'].fill(0) DCNL DCSP for c in xrange(self.numberOfCols): DCNL DCSP  DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP  DCSP for s in self.cells[c][i]: DCNL DCSP  DCSP  DCSP  DCSP numActiveSyns = self._getSegmentActivityLevel(s, self.infActiveState['t'], connectedSynapsesOnly=False) DCNL DCSP  DCSP  DCSP  DCSP if (numActiveSyns < self.activationThreshold): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (self.verbosity >= 6): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('incorporating DCSP DC DCSP from DCSP cell[%d,%d]: DCSP  DCSP  DCSP ' % (c, i)), DCNL DCSP  DCSP  DCSP  DCSP  DCSP s.debugPrint() DCNL DCSP  DCSP  DCSP  DCSP dc = s.dutyCycle() DCNL DCSP  DCSP  DCSP  DCSP self.cellConfidence['t'][(c, i)] += dc DCNL DCSP  DCSP  DCSP  DCSP self.colConfidence['t'][c] += dc DCNL DCSP  DCSP  DCSP  DCSP if self._isSegmentActive(s, self.infActiveState['t']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.infPredictedState['t'][(c, i)] = 1 DCNL DCSP sumConfidences = self.colConfidence['t'].sum() DCNL DCSP if (sumConfidences > 0): DCNL DCSP  DCSP self.colConfidence['t'] /= sumConfidences DCNL DCSP  DCSP self.cellConfidence['t'] /= sumConfidences DCNL DCSP numPredictedCols = self.infPredictedState['t'].max(axis=1).sum() DCNL DCSP if (numPredictedCols >= (0.5 * self.avgInputDensity)): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def _updateInferenceState(self, activeColumns): DCNL DCSP self.infActiveState['t-1'][:, :] = self.infActiveState['t'][:, :] DCNL DCSP self.infPredictedState['t-1'][:, :] = self.infPredictedState['t'][:, :] DCNL DCSP self.cellConfidence['t-1'][:, :] = self.cellConfidence['t'][:, :] DCNL DCSP self.colConfidence['t-1'][:] = self.colConfidence['t'][:] DCNL DCSP if (self.maxInfBacktrack > 0): DCNL DCSP  DCSP if (len(self._prevInfPatterns) > self.maxInfBacktrack): DCNL DCSP  DCSP  DCSP self._prevInfPatterns.pop(0) DCNL DCSP  DCSP self._prevInfPatterns.append(activeColumns) DCNL DCSP inSequence = self._inferPhase1(activeColumns, self.resetCalled) DCNL DCSP if (not inSequence): DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print 'Too DCSP much DCSP unpredicted DCSP input, DCSP re-tracing DCSP back DCSP to DCSP try DCSP and DCSP lock DCSP on DCSP at DCSP an DCSP earlier DCSP timestep.' DCNL DCSP  DCSP self._inferBacktrack(activeColumns) DCNL DCSP  DCSP return DCNL DCSP inSequence = self._inferPhase2() DCNL DCSP if (not inSequence): DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print 'Not DCSP enough DCSP predictions DCSP going DCSP forward, DCSP re-tracing DCSP back DCSP to DCSP try DCSP and DCSP lock DCSP on DCSP at DCSP an DCSP earlier DCSP timestep.' DCNL DCSP  DCSP self._inferBacktrack(activeColumns)
def _learnBacktrackFrom(self, startOffset, readOnly=True): DCNL DCSP numPrevPatterns = len(self._prevLrnPatterns) DCNL DCSP currentTimeStepsOffset = (numPrevPatterns - 1) DCNL DCSP if (not readOnly): DCNL DCSP  DCSP self.segmentUpdates = {} DCNL DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP if readOnly: DCNL DCSP  DCSP  DCSP print (('Trying DCSP to DCSP lock-on DCSP using DCSP startCell DCSP state DCSP from DCSP %d DCSP steps DCSP ago:' % ((numPrevPatterns - 1) - startOffset)), self._prevLrnPatterns[startOffset]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print (('Locking DCSP on DCSP using DCSP startCell DCSP state DCSP from DCSP %d DCSP steps DCSP ago:' % ((numPrevPatterns - 1) - startOffset)), self._prevLrnPatterns[startOffset]) DCNL DCSP inSequence = True DCNL DCSP for offset in range(startOffset, numPrevPatterns): DCNL DCSP  DCSP self.lrnPredictedState['t-1'][:, :] = self.lrnPredictedState['t'][:, :] DCNL DCSP  DCSP self.lrnActiveState['t-1'][:, :] = self.lrnActiveState['t'][:, :] DCNL DCSP  DCSP inputColumns = self._prevLrnPatterns[offset] DCNL DCSP  DCSP if (not readOnly): DCNL DCSP  DCSP  DCSP self._processSegmentUpdates(inputColumns) DCNL DCSP  DCSP if (offset == startOffset): DCNL DCSP  DCSP  DCSP self.lrnActiveState['t'].fill(0) DCNL DCSP  DCSP  DCSP for c in inputColumns: DCNL DCSP  DCSP  DCSP  DCSP self.lrnActiveState['t'][(c, 0)] = 1 DCNL DCSP  DCSP  DCSP inSequence = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inSequence = self._learnPhase1(inputColumns, readOnly=readOnly) DCNL DCSP  DCSP if ((not inSequence) or (offset == currentTimeStepsOffset)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP backtrack: DCSP computing DCSP predictions DCSP from DCSP ', inputColumns DCNL DCSP  DCSP self._learnPhase2(readOnly=readOnly) DCNL DCSP return inSequence
def _learnBacktrack(self): DCNL DCSP numPrevPatterns = (len(self._prevLrnPatterns) - 1) DCNL DCSP if (numPrevPatterns <= 0): DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print 'lrnBacktrack: DCSP No DCSP available DCSP history DCSP to DCSP backtrack DCSP from' DCNL DCSP  DCSP return False DCNL DCSP badPatterns = [] DCNL DCSP inSequence = False DCNL DCSP for startOffset in range(0, numPrevPatterns): DCNL DCSP  DCSP inSequence = self._learnBacktrackFrom(startOffset, readOnly=True) DCNL DCSP  DCSP if inSequence: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP badPatterns.append(startOffset) DCNL DCSP if (not inSequence): DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print 'Failed DCSP to DCSP lock DCSP on. DCSP Falling DCSP back DCSP to DCSP start DCSP cells DCSP on DCSP current DCSP time DCSP step.' DCNL DCSP  DCSP self._prevLrnPatterns = [] DCNL DCSP  DCSP return False DCNL DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP print (('Discovered DCSP path DCSP to DCSP current DCSP input DCSP by DCSP using DCSP start DCSP cells DCSP from DCSP %d DCSP steps DCSP ago:' % (numPrevPatterns - startOffset)), self._prevLrnPatterns[startOffset]) DCNL DCSP self._learnBacktrackFrom(startOffset, readOnly=False) DCNL DCSP for i in range(numPrevPatterns): DCNL DCSP  DCSP if ((i in badPatterns) or (i <= startOffset)): DCNL DCSP  DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP  DCSP print ('Removing DCSP useless DCSP pattern DCSP from DCSP history:', self._prevLrnPatterns[0]) DCNL DCSP  DCSP  DCSP self._prevLrnPatterns.pop(0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP return (numPrevPatterns - startOffset)
def _learnPhase1(self, activeColumns, readOnly=False): DCNL DCSP self.lrnActiveState['t'].fill(0) DCNL DCSP numUnpredictedColumns = 0 DCNL DCSP for c in activeColumns: DCNL DCSP  DCSP predictingCells = numpy.where((self.lrnPredictedState['t-1'][c] == 1))[0] DCNL DCSP  DCSP numPredictedCells = len(predictingCells) DCNL DCSP  DCSP assert (numPredictedCells <= 1) DCNL DCSP  DCSP if (numPredictedCells == 1): DCNL DCSP  DCSP  DCSP i = predictingCells[0] DCNL DCSP  DCSP  DCSP self.lrnActiveState['t'][(c, i)] = 1 DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP numUnpredictedColumns += 1 DCNL DCSP  DCSP if readOnly: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (i, s, numActive) = self._getBestMatchingCell(c, self.lrnActiveState['t-1'], self.minThreshold) DCNL DCSP  DCSP if ((s is not None) and s.isSequenceSegment()): DCNL DCSP  DCSP  DCSP if (self.verbosity >= 4): DCNL DCSP  DCSP  DCSP  DCSP print 'Learn DCSP branch DCSP 0, DCSP found DCSP segment DCSP match. DCSP Learning DCSP on DCSP col=', c DCNL DCSP  DCSP  DCSP self.lrnActiveState['t'][(c, i)] = 1 DCNL DCSP  DCSP  DCSP segUpdate = self._getSegmentActiveSynapses(c, i, s, self.lrnActiveState['t-1'], newSynapses=True) DCNL DCSP  DCSP  DCSP s.totalActivations += 1 DCNL DCSP  DCSP  DCSP trimSegment = self._adaptSegment(segUpdate) DCNL DCSP  DCSP  DCSP if trimSegment: DCNL DCSP  DCSP  DCSP  DCSP self._trimSegmentsInCell(c, i, [s], minPermanence=1e-05, minNumSyns=0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i = self._getCellForNewSegment(c) DCNL DCSP  DCSP  DCSP if (self.verbosity >= 4): DCNL DCSP  DCSP  DCSP  DCSP print 'Learn DCSP branch DCSP 1, DCSP no DCSP match. DCSP Learning DCSP on DCSP col=', c, DCNL DCSP  DCSP  DCSP  DCSP print ', DCSP newCellIdxInCol=', i DCNL DCSP  DCSP  DCSP self.lrnActiveState['t'][(c, i)] = 1 DCNL DCSP  DCSP  DCSP segUpdate = self._getSegmentActiveSynapses(c, i, None, self.lrnActiveState['t-1'], newSynapses=True) DCNL DCSP  DCSP  DCSP segUpdate.sequenceSegment = True DCNL DCSP  DCSP  DCSP self._adaptSegment(segUpdate) DCNL DCSP numBottomUpColumns = len(activeColumns) DCNL DCSP if (numUnpredictedColumns < (numBottomUpColumns / 2)): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def _learnPhase2(self, readOnly=False): DCNL DCSP self.lrnPredictedState['t'].fill(0) DCNL DCSP for c in xrange(self.numberOfCols): DCNL DCSP  DCSP (i, s, numActive) = self._getBestMatchingCell(c, self.lrnActiveState['t'], minThreshold=self.activationThreshold) DCNL DCSP  DCSP if (i is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP self.lrnPredictedState['t'][(c, i)] = 1 DCNL DCSP  DCSP if readOnly: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP segUpdate = self._getSegmentActiveSynapses(c, i, s, activeState=self.lrnActiveState['t'], newSynapses=(numActive < self.newSynapseCount)) DCNL DCSP  DCSP s.totalActivations += 1 DCNL DCSP  DCSP self._addToSegmentUpdates(c, i, segUpdate) DCNL DCSP  DCSP if self.doPooling: DCNL DCSP  DCSP  DCSP predSegment = self._getBestMatchingSegment(c, i, self.lrnActiveState['t-1']) DCNL DCSP  DCSP  DCSP segUpdate = self._getSegmentActiveSynapses(c, i, predSegment, self.lrnActiveState['t-1'], newSynapses=True) DCNL DCSP  DCSP  DCSP self._addToSegmentUpdates(c, i, segUpdate)
def _updateLearningState(self, activeColumns): DCNL DCSP self.lrnPredictedState['t-1'][:, :] = self.lrnPredictedState['t'][:, :] DCNL DCSP self.lrnActiveState['t-1'][:, :] = self.lrnActiveState['t'][:, :] DCNL DCSP if (self.maxLrnBacktrack > 0): DCNL DCSP  DCSP if (len(self._prevLrnPatterns) > self.maxLrnBacktrack): DCNL DCSP  DCSP  DCSP self._prevLrnPatterns.pop(0) DCNL DCSP  DCSP self._prevLrnPatterns.append(activeColumns) DCNL DCSP  DCSP if (self.verbosity >= 4): DCNL DCSP  DCSP  DCSP print 'Previous DCSP learn DCSP patterns: DCSP \n' DCNL DCSP  DCSP  DCSP print self._prevLrnPatterns DCNL DCSP self._processSegmentUpdates(activeColumns) DCNL DCSP if (self.pamCounter > 0): DCNL DCSP  DCSP self.pamCounter -= 1 DCNL DCSP self.learnedSeqLength += 1 DCNL DCSP if (not self.resetCalled): DCNL DCSP  DCSP inSequence = self._learnPhase1(activeColumns) DCNL DCSP  DCSP if inSequence: DCNL DCSP  DCSP  DCSP self.pamCounter = self.pamLength DCNL DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP print 'pamCounter DCSP = DCSP ', self.pamCounter, 'seqLength DCSP = DCSP ', self.learnedSeqLength DCNL DCSP if (self.resetCalled or (self.pamCounter == 0) or ((self.maxSeqLength != 0) and (self.learnedSeqLength >= self.maxSeqLength))): DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP if self.resetCalled: DCNL DCSP  DCSP  DCSP  DCSP print 'Starting DCSP over:', activeColumns, '(reset DCSP was DCSP called)' DCNL DCSP  DCSP  DCSP elif (self.pamCounter == 0): DCNL DCSP  DCSP  DCSP  DCSP print 'Starting DCSP over:', activeColumns, '(PAM DCSP counter DCSP expired)' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print 'Starting DCSP over:', activeColumns, '(reached DCSP maxSeqLength)' DCNL DCSP  DCSP if (self.pamCounter == 0): DCNL DCSP  DCSP  DCSP seqLength = (self.learnedSeqLength - self.pamLength) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP seqLength = self.learnedSeqLength DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP learned DCSP sequence DCSP length DCSP was:', seqLength DCNL DCSP  DCSP self._updateAvgLearnedSeqLength(seqLength) DCNL DCSP  DCSP backSteps = 0 DCNL DCSP  DCSP if (not self.resetCalled): DCNL DCSP  DCSP  DCSP backSteps = self._learnBacktrack() DCNL DCSP  DCSP if (self.resetCalled or (backSteps is None) or (backSteps == 0)): DCNL DCSP  DCSP  DCSP backSteps = 0 DCNL DCSP  DCSP  DCSP self.lrnActiveState['t'].fill(0) DCNL DCSP  DCSP  DCSP for c in activeColumns: DCNL DCSP  DCSP  DCSP  DCSP self.lrnActiveState['t'][(c, 0)] = 1 DCNL DCSP  DCSP  DCSP self._prevLrnPatterns = [] DCNL DCSP  DCSP self.pamCounter = self.pamLength DCNL DCSP  DCSP self.learnedSeqLength = backSteps DCNL DCSP  DCSP self.segmentUpdates = {} DCNL DCSP self._learnPhase2()
def compute(self, bottomUpInput, enableLearn, enableInference=None): DCNL DCSP if (enableInference is None): DCNL DCSP  DCSP if enableLearn: DCNL DCSP  DCSP  DCSP enableInference = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP enableInference = True DCNL DCSP assert (enableLearn or enableInference) DCNL DCSP activeColumns = bottomUpInput.nonzero()[0] DCNL DCSP if enableLearn: DCNL DCSP  DCSP self.lrnIterationIdx += 1 DCNL DCSP self.iterationIdx += 1 DCNL DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP print ('\n==== DCSP PY DCSP Iteration: DCSP %d DCSP =====' % self.iterationIdx) DCNL DCSP  DCSP print 'Active DCSP cols:', activeColumns DCNL DCSP if enableLearn: DCNL DCSP  DCSP if (self.lrnIterationIdx in Segment.dutyCycleTiers): DCNL DCSP  DCSP  DCSP for (c, i) in itertools.product(xrange(self.numberOfCols), xrange(self.cellsPerColumn)): DCNL DCSP  DCSP  DCSP  DCSP for segment in self.cells[c][i]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP segment.dutyCycle() DCNL DCSP if (self.avgInputDensity is None): DCNL DCSP  DCSP self.avgInputDensity = len(activeColumns) DCNL DCSP else: DCNL DCSP  DCSP self.avgInputDensity = ((0.99 * self.avgInputDensity) + (0.01 * len(activeColumns))) DCNL DCSP if enableInference: DCNL DCSP  DCSP self._updateInferenceState(activeColumns) DCNL DCSP if enableLearn: DCNL DCSP  DCSP self._updateLearningState(activeColumns) DCNL DCSP  DCSP if ((self.globalDecay > 0.0) and ((self.lrnIterationIdx % self.maxAge) == 0)): DCNL DCSP  DCSP  DCSP for (c, i) in itertools.product(xrange(self.numberOfCols), xrange(self.cellsPerColumn)): DCNL DCSP  DCSP  DCSP  DCSP segsToDel = [] DCNL DCSP  DCSP  DCSP  DCSP for segment in self.cells[c][i]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP age = (self.lrnIterationIdx - segment.lastActiveIteration) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (age <= self.maxAge): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP synsToDel = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for synapse in segment.syns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP synapse[2] = (synapse[2] - self.globalDecay) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (synapse[2] <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP synsToDel.append(synapse) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(synsToDel) == segment.getNumSynapses()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP segsToDel.append(segment) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (len(synsToDel) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for syn in synsToDel: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP segment.syns.remove(syn) DCNL DCSP  DCSP  DCSP  DCSP for seg in segsToDel: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._cleanUpdatesList(c, i, seg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.cells[c][i].remove(seg) DCNL DCSP if self.collectStats: DCNL DCSP  DCSP if enableInference: DCNL DCSP  DCSP  DCSP predictedState = self.infPredictedState['t-1'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP predictedState = self.lrnPredictedState['t-1'] DCNL DCSP  DCSP self._updateStatsInferEnd(self._internalStats, activeColumns, predictedState, self.colConfidence['t-1']) DCNL DCSP output = self._computeOutput() DCNL DCSP self.printComputeEnd(output, learn=enableLearn) DCNL DCSP self.resetCalled = False DCNL DCSP return output
def infer(self, bottomUpInput): DCNL DCSP return self.compute(bottomUpInput, enableLearn=False)
def learn(self, bottomUpInput, enableInference=None): DCNL DCSP return self.compute(bottomUpInput, enableLearn=True, enableInference=enableInference)
def _columnConfidences(self): DCNL DCSP return self.colConfidence['t']
def topDownCompute(self): DCNL DCSP return self._columnConfidences()
def _trimSegmentsInCell(self, colIdx, cellIdx, segList, minPermanence, minNumSyns): DCNL DCSP if (minPermanence is None): DCNL DCSP  DCSP minPermanence = self.connectedPerm DCNL DCSP if (minNumSyns is None): DCNL DCSP  DCSP minNumSyns = self.activationThreshold DCNL DCSP (nSegsRemoved, nSynsRemoved) = (0, 0) DCNL DCSP segsToDel = [] DCNL DCSP for segment in segList: DCNL DCSP  DCSP synsToDel = [syn for syn in segment.syns if (syn[2] < minPermanence)] DCNL DCSP  DCSP if (len(synsToDel) == len(segment.syns)): DCNL DCSP  DCSP  DCSP segsToDel.append(segment) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (len(synsToDel) > 0): DCNL DCSP  DCSP  DCSP  DCSP for syn in synsToDel: DCNL DCSP  DCSP  DCSP  DCSP  DCSP segment.syns.remove(syn) DCNL DCSP  DCSP  DCSP  DCSP  DCSP nSynsRemoved += 1 DCNL DCSP  DCSP  DCSP if (len(segment.syns) < minNumSyns): DCNL DCSP  DCSP  DCSP  DCSP segsToDel.append(segment) DCNL DCSP nSegsRemoved += len(segsToDel) DCNL DCSP for seg in segsToDel: DCNL DCSP  DCSP self._cleanUpdatesList(colIdx, cellIdx, seg) DCNL DCSP  DCSP self.cells[colIdx][cellIdx].remove(seg) DCNL DCSP  DCSP nSynsRemoved += len(seg.syns) DCNL DCSP return (nSegsRemoved, nSynsRemoved)
def trimSegments(self, minPermanence=None, minNumSyns=None): DCNL DCSP if (minPermanence is None): DCNL DCSP  DCSP minPermanence = self.connectedPerm DCNL DCSP if (minNumSyns is None): DCNL DCSP  DCSP minNumSyns = self.activationThreshold DCNL DCSP (totalSegsRemoved, totalSynsRemoved) = (0, 0) DCNL DCSP for (c, i) in itertools.product(xrange(self.numberOfCols), xrange(self.cellsPerColumn)): DCNL DCSP  DCSP (segsRemoved, synsRemoved) = self._trimSegmentsInCell(colIdx=c, cellIdx=i, segList=self.cells[c][i], minPermanence=minPermanence, minNumSyns=minNumSyns) DCNL DCSP  DCSP totalSegsRemoved += segsRemoved DCNL DCSP  DCSP totalSynsRemoved += synsRemoved DCNL DCSP if (self.verbosity >= 5): DCNL DCSP  DCSP print 'Cells, DCSP all DCSP segments:' DCNL DCSP  DCSP self.printCells(predictedOnly=False) DCNL DCSP return (totalSegsRemoved, totalSynsRemoved)
def _cleanUpdatesList(self, col, cellIdx, seg): DCNL DCSP for (key, updateList) in self.segmentUpdates.iteritems(): DCNL DCSP  DCSP (c, i) = (key[0], key[1]) DCNL DCSP  DCSP if ((c == col) and (i == cellIdx)): DCNL DCSP  DCSP  DCSP for update in updateList: DCNL DCSP  DCSP  DCSP  DCSP if (update[1].segment == seg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._removeSegmentUpdate(update)
def finishLearning(self): DCNL DCSP self.trimSegments(minPermanence=0.0001) DCNL DCSP for (c, i) in itertools.product(xrange(self.numberOfCols), xrange(self.cellsPerColumn)): DCNL DCSP  DCSP for segment in self.cells[c][i]: DCNL DCSP  DCSP  DCSP segment.dutyCycle() DCNL DCSP if (self.cellsPerColumn > 1): DCNL DCSP  DCSP for c in xrange(self.numberOfCols): DCNL DCSP  DCSP  DCSP assert (self.getNumSegmentsInCell(c, 0) == 0)
def _checkPrediction(self, patternNZs, output=None, colConfidence=None, details=False): DCNL DCSP numPatterns = len(patternNZs) DCNL DCSP orAll = set() DCNL DCSP orAll = orAll.union(*patternNZs) DCNL DCSP if (output is None): DCNL DCSP  DCSP assert (self.currentOutput is not None) DCNL DCSP  DCSP output = self.currentOutput DCNL DCSP output = set(output.sum(axis=1).nonzero()[0]) DCNL DCSP totalExtras = len(output.difference(orAll)) DCNL DCSP totalMissing = len(orAll.difference(output)) DCNL DCSP if (colConfidence is None): DCNL DCSP  DCSP colConfidence = self.colConfidence['t'] DCNL DCSP confidences = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP positivePredictionSum = colConfidence[patternNZs[i]].sum() DCNL DCSP  DCSP positiveColumnCount = len(patternNZs[i]) DCNL DCSP  DCSP totalPredictionSum = colConfidence.sum() DCNL DCSP  DCSP totalColumnCount = len(colConfidence) DCNL DCSP  DCSP negativePredictionSum = (totalPredictionSum - positivePredictionSum) DCNL DCSP  DCSP negativeColumnCount = (totalColumnCount - positiveColumnCount) DCNL DCSP  DCSP if (positiveColumnCount != 0): DCNL DCSP  DCSP  DCSP positivePredictionScore = positivePredictionSum DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP positivePredictionScore = 0.0 DCNL DCSP  DCSP if (negativeColumnCount != 0): DCNL DCSP  DCSP  DCSP negativePredictionScore = negativePredictionSum DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP negativePredictionScore = 0.0 DCNL DCSP  DCSP currentSum = (negativePredictionScore + positivePredictionScore) DCNL DCSP  DCSP if (currentSum > 0): DCNL DCSP  DCSP  DCSP positivePredictionScore *= (1.0 / currentSum) DCNL DCSP  DCSP  DCSP negativePredictionScore *= (1.0 / currentSum) DCNL DCSP  DCSP predictionScore = (positivePredictionScore - negativePredictionScore) DCNL DCSP  DCSP confidences.append((predictionScore, positivePredictionScore, negativePredictionScore)) DCNL DCSP if details: DCNL DCSP  DCSP missingPatternBits = [set(pattern).difference(output) for pattern in patternNZs] DCNL DCSP  DCSP return (totalExtras, totalMissing, confidences, missingPatternBits) DCNL DCSP else: DCNL DCSP  DCSP return (totalExtras, totalMissing, confidences)
def _isSegmentActive(self, seg, activeState): DCNL DCSP return isSegmentActive(seg.syns, activeState, self.connectedPerm, self.activationThreshold)
def _getSegmentActivityLevel(self, seg, activeState, connectedSynapsesOnly=False): DCNL DCSP return getSegmentActivityLevel(seg.syns, activeState, connectedSynapsesOnly, self.connectedPerm)
def _getBestMatchingCell(self, c, activeState, minThreshold): DCNL DCSP bestActivityInCol = minThreshold DCNL DCSP bestSegIdxInCol = (-1) DCNL DCSP bestCellInCol = (-1) DCNL DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP maxSegActivity = 0 DCNL DCSP  DCSP maxSegIdx = 0 DCNL DCSP  DCSP for (j, s) in enumerate(self.cells[c][i]): DCNL DCSP  DCSP  DCSP activity = self._getSegmentActivityLevel(s, activeState) DCNL DCSP  DCSP  DCSP if (activity > maxSegActivity): DCNL DCSP  DCSP  DCSP  DCSP maxSegActivity = activity DCNL DCSP  DCSP  DCSP  DCSP maxSegIdx = j DCNL DCSP  DCSP if (maxSegActivity >= bestActivityInCol): DCNL DCSP  DCSP  DCSP bestActivityInCol = maxSegActivity DCNL DCSP  DCSP  DCSP bestSegIdxInCol = maxSegIdx DCNL DCSP  DCSP  DCSP bestCellInCol = i DCNL DCSP if (bestCellInCol == (-1)): DCNL DCSP  DCSP return (None, None, None) DCNL DCSP else: DCNL DCSP  DCSP return (bestCellInCol, self.cells[c][bestCellInCol][bestSegIdxInCol], bestActivityInCol)
def _getBestMatchingSegment(self, c, i, activeState): DCNL DCSP (maxActivity, which) = (self.minThreshold, (-1)) DCNL DCSP for (j, s) in enumerate(self.cells[c][i]): DCNL DCSP  DCSP activity = self._getSegmentActivityLevel(s, activeState, connectedSynapsesOnly=False) DCNL DCSP  DCSP if (activity >= maxActivity): DCNL DCSP  DCSP  DCSP (maxActivity, which) = (activity, j) DCNL DCSP if (which == (-1)): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return self.cells[c][i][which]
def _getCellForNewSegment(self, colIdx): DCNL DCSP if (self.maxSegmentsPerCell < 0): DCNL DCSP  DCSP if (self.cellsPerColumn > 1): DCNL DCSP  DCSP  DCSP i = (self._random.getUInt32((self.cellsPerColumn - 1)) + 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i = 0 DCNL DCSP  DCSP return i DCNL DCSP candidateCellIdxs = [] DCNL DCSP if (self.cellsPerColumn == 1): DCNL DCSP  DCSP minIdx = 0 DCNL DCSP  DCSP maxIdx = 0 DCNL DCSP else: DCNL DCSP  DCSP minIdx = 1 DCNL DCSP  DCSP maxIdx = (self.cellsPerColumn - 1) DCNL DCSP for i in xrange(minIdx, (maxIdx + 1)): DCNL DCSP  DCSP numSegs = len(self.cells[colIdx][i]) DCNL DCSP  DCSP if (numSegs < self.maxSegmentsPerCell): DCNL DCSP  DCSP  DCSP candidateCellIdxs.append(i) DCNL DCSP if (len(candidateCellIdxs) > 0): DCNL DCSP  DCSP candidateCellIdx = candidateCellIdxs[self._random.getUInt32(len(candidateCellIdxs))] DCNL DCSP  DCSP if (self.verbosity >= 5): DCNL DCSP  DCSP  DCSP print ('Cell DCSP [%d,%d] DCSP chosen DCSP for DCSP new DCSP segment, DCSP # DCSP of DCSP segs DCSP is DCSP %d' % (colIdx, candidateCellIdx, len(self.cells[colIdx][candidateCellIdx]))) DCNL DCSP  DCSP return candidateCellIdx DCNL DCSP candidateSegment = None DCNL DCSP candidateSegmentDC = 1.0 DCNL DCSP for i in xrange(minIdx, (maxIdx + 1)): DCNL DCSP  DCSP for s in self.cells[colIdx][i]: DCNL DCSP  DCSP  DCSP dc = s.dutyCycle() DCNL DCSP  DCSP  DCSP if (dc < candidateSegmentDC): DCNL DCSP  DCSP  DCSP  DCSP candidateCellIdx = i DCNL DCSP  DCSP  DCSP  DCSP candidateSegmentDC = dc DCNL DCSP  DCSP  DCSP  DCSP candidateSegment = s DCNL DCSP if (self.verbosity >= 5): DCNL DCSP  DCSP print ('Deleting DCSP segment DCSP #%d DCSP for DCSP cell[%d,%d] DCSP to DCSP make DCSP room DCSP for DCSP new DCSP segment' % (candidateSegment.segID, colIdx, candidateCellIdx)) DCNL DCSP  DCSP candidateSegment.debugPrint() DCNL DCSP self._cleanUpdatesList(colIdx, candidateCellIdx, candidateSegment) DCNL DCSP self.cells[colIdx][candidateCellIdx].remove(candidateSegment) DCNL DCSP return candidateCellIdx
def _getSegmentActiveSynapses(self, c, i, s, activeState, newSynapses=False): DCNL DCSP activeSynapses = [] DCNL DCSP if (s is not None): DCNL DCSP  DCSP activeSynapses = [idx for (idx, syn) in enumerate(s.syns) if activeState[(syn[0], syn[1])]] DCNL DCSP if newSynapses: DCNL DCSP  DCSP nSynapsesToAdd = (self.newSynapseCount - len(activeSynapses)) DCNL DCSP  DCSP activeSynapses += self._chooseCellsToLearnFrom(c, i, s, nSynapsesToAdd, activeState) DCNL DCSP update = BacktrackingTM._SegmentUpdate(c, i, s, activeSynapses) DCNL DCSP return update
def _chooseCellsToLearnFrom(self, c, i, s, n, activeState): DCNL DCSP if (n <= 0): DCNL DCSP  DCSP return [] DCNL DCSP tmpCandidates = numpy.where((activeState == 1)) DCNL DCSP if (len(tmpCandidates[0]) == 0): DCNL DCSP  DCSP return [] DCNL DCSP if (s is None): DCNL DCSP  DCSP cands = [syn for syn in zip(tmpCandidates[0], tmpCandidates[1])] DCNL DCSP else: DCNL DCSP  DCSP synapsesAlreadyInSegment = set(((syn[0], syn[1]) for syn in s.syns)) DCNL DCSP  DCSP cands = [syn for syn in zip(tmpCandidates[0], tmpCandidates[1]) if ((syn[0], syn[1]) not in synapsesAlreadyInSegment)] DCNL DCSP if (len(cands) <= n): DCNL DCSP  DCSP return cands DCNL DCSP if (n == 1): DCNL DCSP  DCSP idx = self._random.getUInt32(len(cands)) DCNL DCSP  DCSP return [cands[idx]] DCNL DCSP indices = numpy.array([j for j in range(len(cands))], dtype='uint32') DCNL DCSP tmp = numpy.zeros(min(n, len(indices)), dtype='uint32') DCNL DCSP self._random.sample(indices, tmp) DCNL DCSP return sorted([cands[j] for j in tmp])
def _processSegmentUpdates(self, activeColumns): DCNL DCSP removeKeys = [] DCNL DCSP trimSegments = [] DCNL DCSP for (key, updateList) in self.segmentUpdates.iteritems(): DCNL DCSP  DCSP (c, i) = (key[0], key[1]) DCNL DCSP  DCSP if (c in activeColumns): DCNL DCSP  DCSP  DCSP action = 'update' DCNL DCSP  DCSP elif (self.doPooling and (self.lrnPredictedState['t'][(c, i)] == 1)): DCNL DCSP  DCSP  DCSP action = 'keep' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP action = 'remove' DCNL DCSP  DCSP updateListKeep = [] DCNL DCSP  DCSP if (action != 'remove'): DCNL DCSP  DCSP  DCSP for (createDate, segUpdate) in updateList: DCNL DCSP  DCSP  DCSP  DCSP if (self.verbosity >= 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '_nLrnIterations DCSP =', self.lrnIterationIdx, DCNL DCSP  DCSP  DCSP  DCSP  DCSP print segUpdate DCNL DCSP  DCSP  DCSP  DCSP if ((self.lrnIterationIdx - createDate) > self.segUpdateValidDuration): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (action == 'update'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP trimSegment = self._adaptSegment(segUpdate) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if trimSegment: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP trimSegments.append((segUpdate.columnIdx, segUpdate.cellIdx, segUpdate.segment)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP updateListKeep.append((createDate, segUpdate)) DCNL DCSP  DCSP self.segmentUpdates[key] = updateListKeep DCNL DCSP  DCSP if (len(updateListKeep) == 0): DCNL DCSP  DCSP  DCSP removeKeys.append(key) DCNL DCSP for key in removeKeys: DCNL DCSP  DCSP self.segmentUpdates.pop(key) DCNL DCSP for (c, i, segment) in trimSegments: DCNL DCSP  DCSP self._trimSegmentsInCell(c, i, [segment], minPermanence=1e-05, minNumSyns=0)
def _adaptSegment(self, segUpdate): DCNL DCSP trimSegment = False DCNL DCSP (c, i, segment) = (segUpdate.columnIdx, segUpdate.cellIdx, segUpdate.segment) DCNL DCSP activeSynapses = segUpdate.activeSynapses DCNL DCSP synToUpdate = set([syn for syn in activeSynapses if (type(syn) == int)]) DCNL DCSP if (segment is not None): DCNL DCSP  DCSP if (self.verbosity >= 4): DCNL DCSP  DCSP  DCSP print ('Reinforcing DCSP segment DCSP #%d DCSP for DCSP cell[%d,%d]' % (segment.segID, c, i)) DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP before:', DCNL DCSP  DCSP  DCSP segment.debugPrint() DCNL DCSP  DCSP segment.lastActiveIteration = self.lrnIterationIdx DCNL DCSP  DCSP segment.positiveActivations += 1 DCNL DCSP  DCSP segment.dutyCycle(active=True) DCNL DCSP  DCSP lastSynIndex = (len(segment.syns) - 1) DCNL DCSP  DCSP inactiveSynIndices = [s for s in xrange(0, (lastSynIndex + 1)) if (s not in synToUpdate)] DCNL DCSP  DCSP trimSegment = segment.updateSynapses(inactiveSynIndices, (- self.permanenceDec)) DCNL DCSP  DCSP activeSynIndices = [syn for syn in synToUpdate if (syn <= lastSynIndex)] DCNL DCSP  DCSP segment.updateSynapses(activeSynIndices, self.permanenceInc) DCNL DCSP  DCSP synsToAdd = [syn for syn in activeSynapses if (type(syn) != int)] DCNL DCSP  DCSP if ((self.maxSynapsesPerSegment > 0) and ((len(synsToAdd) + len(segment.syns)) > self.maxSynapsesPerSegment)): DCNL DCSP  DCSP  DCSP numToFree = ((len(segment.syns) + len(synsToAdd)) - self.maxSynapsesPerSegment) DCNL DCSP  DCSP  DCSP segment.freeNSynapses(numToFree, inactiveSynIndices, self.verbosity) DCNL DCSP  DCSP for newSyn in synsToAdd: DCNL DCSP  DCSP  DCSP segment.addSynapse(newSyn[0], newSyn[1], self.initialPerm) DCNL DCSP  DCSP if (self.verbosity >= 4): DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP after:', DCNL DCSP  DCSP  DCSP segment.debugPrint() DCNL DCSP else: DCNL DCSP  DCSP newSegment = Segment(tm=self, isSequenceSeg=segUpdate.sequenceSegment) DCNL DCSP  DCSP for synapse in activeSynapses: DCNL DCSP  DCSP  DCSP newSegment.addSynapse(synapse[0], synapse[1], self.initialPerm) DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP print ('New DCSP segment DCSP #%d DCSP for DCSP cell[%d,%d]' % ((self.segID - 1), c, i)), DCNL DCSP  DCSP  DCSP newSegment.debugPrint() DCNL DCSP  DCSP self.cells[c][i].append(newSegment) DCNL DCSP return trimSegment
def getSegmentInfo(self, collectActiveData=False): DCNL DCSP (nSegments, nSynapses) = (0, 0) DCNL DCSP (nActiveSegs, nActiveSynapses) = (0, 0) DCNL DCSP (distSegSizes, distNSegsPerCell) = ({}, {}) DCNL DCSP distPermValues = {} DCNL DCSP numAgeBuckets = 20 DCNL DCSP distAges = [] DCNL DCSP ageBucketSize = int(((self.lrnIterationIdx + 20) / 20)) DCNL DCSP for i in range(numAgeBuckets): DCNL DCSP  DCSP distAges.append([('%d-%d' % ((i * ageBucketSize), (((i + 1) * ageBucketSize) - 1))), 0]) DCNL DCSP for c in xrange(self.numberOfCols): DCNL DCSP  DCSP for i in xrange(self.cellsPerColumn): DCNL DCSP  DCSP  DCSP if (len(self.cells[c][i]) > 0): DCNL DCSP  DCSP  DCSP  DCSP nSegmentsThisCell = len(self.cells[c][i]) DCNL DCSP  DCSP  DCSP  DCSP nSegments += nSegmentsThisCell DCNL DCSP  DCSP  DCSP  DCSP if distNSegsPerCell.has_key(nSegmentsThisCell): DCNL DCSP  DCSP  DCSP  DCSP  DCSP distNSegsPerCell[nSegmentsThisCell] += 1 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP distNSegsPerCell[nSegmentsThisCell] = 1 DCNL DCSP  DCSP  DCSP  DCSP for seg in self.cells[c][i]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP nSynapsesThisSeg = seg.getNumSynapses() DCNL DCSP  DCSP  DCSP  DCSP  DCSP nSynapses += nSynapsesThisSeg DCNL DCSP  DCSP  DCSP  DCSP  DCSP if distSegSizes.has_key(nSynapsesThisSeg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP distSegSizes[nSynapsesThisSeg] += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP distSegSizes[nSynapsesThisSeg] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP for syn in seg.syns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP p = int((syn[2] * 10)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if distPermValues.has_key(p): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP distPermValues[p] += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP distPermValues[p] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP age = (self.lrnIterationIdx - seg.lastActiveIteration) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ageBucket = int((age / ageBucketSize)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP distAges[ageBucket][1] += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if collectActiveData: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if self._isSegmentActive(seg, self.infActiveState['t']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nActiveSegs += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for syn in seg.syns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (self.activeState['t'][syn[0]][syn[1]] == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nActiveSynapses += 1 DCNL DCSP return (nSegments, nSynapses, nActiveSegs, nActiveSynapses, distSegSizes, distNSegsPerCell, distPermValues, distAges)
def dutyCycle(self, active=False, readOnly=False): DCNL DCSP if (self.tm.lrnIterationIdx <= self.dutyCycleTiers[1]): DCNL DCSP  DCSP dutyCycle = (float(self.positiveActivations) / self.tm.lrnIterationIdx) DCNL DCSP  DCSP if (not readOnly): DCNL DCSP  DCSP  DCSP self._lastPosDutyCycleIteration = self.tm.lrnIterationIdx DCNL DCSP  DCSP  DCSP self._lastPosDutyCycle = dutyCycle DCNL DCSP  DCSP return dutyCycle DCNL DCSP age = (self.tm.lrnIterationIdx - self._lastPosDutyCycleIteration) DCNL DCSP if ((age == 0) and (not active)): DCNL DCSP  DCSP return self._lastPosDutyCycle DCNL DCSP for tierIdx in range((len(self.dutyCycleTiers) - 1), 0, (-1)): DCNL DCSP  DCSP if (self.tm.lrnIterationIdx > self.dutyCycleTiers[tierIdx]): DCNL DCSP  DCSP  DCSP alpha = self.dutyCycleAlphas[tierIdx] DCNL DCSP  DCSP  DCSP break DCNL DCSP dutyCycle = (pow((1.0 - alpha), age) * self._lastPosDutyCycle) DCNL DCSP if active: DCNL DCSP  DCSP dutyCycle += alpha DCNL DCSP if (not readOnly): DCNL DCSP  DCSP self._lastPosDutyCycleIteration = self.tm.lrnIterationIdx DCNL DCSP  DCSP self._lastPosDutyCycle = dutyCycle DCNL DCSP return dutyCycle
def debugPrint(self): DCNL DCSP print ('ID:%-5d' % self.segID), DCNL DCSP if self.isSequenceSeg: DCNL DCSP  DCSP print 'True', DCNL DCSP else: DCNL DCSP  DCSP print 'False', DCNL DCSP print ('%9.7f' % self.dutyCycle(readOnly=True)), DCNL DCSP print ('(%4d/%-4d)' % (self.positiveActivations, self.totalActivations)), DCNL DCSP print ('%4d' % (self.tm.lrnIterationIdx - self.lastActiveIteration)), DCNL DCSP sortedSyns = sorted(self.syns) DCNL DCSP for (_, synapse) in enumerate(sortedSyns): DCNL DCSP  DCSP print ('[%d,%d]%4.2f' % (synapse[0], synapse[1], synapse[2])), DCNL DCSP print
def freeNSynapses(self, numToFree, inactiveSynapseIndices, verbosity=0): DCNL DCSP assert (numToFree <= len(self.syns)) DCNL DCSP if (verbosity >= 4): DCNL DCSP  DCSP print '\nIn DCSP PY DCSP freeNSynapses DCSP with DCSP numToFree DCSP =', numToFree, DCNL DCSP  DCSP print 'inactiveSynapseIndices DCSP =', DCNL DCSP  DCSP for i in inactiveSynapseIndices: DCNL DCSP  DCSP  DCSP print self.syns[i][0:2], DCNL DCSP  DCSP print DCNL DCSP if (len(inactiveSynapseIndices) > 0): DCNL DCSP  DCSP perms = numpy.array([self.syns[i][2] for i in inactiveSynapseIndices]) DCNL DCSP  DCSP candidates = numpy.array(inactiveSynapseIndices)[perms.argsort()[0:numToFree]] DCNL DCSP  DCSP candidates = list(candidates) DCNL DCSP else: DCNL DCSP  DCSP candidates = [] DCNL DCSP if (len(candidates) < numToFree): DCNL DCSP  DCSP activeSynIndices = [i for i in xrange(len(self.syns)) if (i not in inactiveSynapseIndices)] DCNL DCSP  DCSP perms = numpy.array([self.syns[i][2] for i in activeSynIndices]) DCNL DCSP  DCSP moreToFree = (numToFree - len(candidates)) DCNL DCSP  DCSP moreCandidates = numpy.array(activeSynIndices)[perms.argsort()[0:moreToFree]] DCNL DCSP  DCSP candidates += list(moreCandidates) DCNL DCSP if (verbosity >= 4): DCNL DCSP  DCSP print ('Deleting DCSP %d DCSP synapses DCSP from DCSP segment DCSP to DCSP make DCSP room DCSP for DCSP new DCSP ones:' % len(candidates)), candidates DCNL DCSP  DCSP print 'BEFORE:', DCNL DCSP  DCSP self.debugPrint() DCNL DCSP synsToDelete = [self.syns[i] for i in candidates] DCNL DCSP for syn in synsToDelete: DCNL DCSP  DCSP self.syns.remove(syn) DCNL DCSP if (verbosity >= 4): DCNL DCSP  DCSP print 'AFTER:', DCNL DCSP  DCSP self.debugPrint()
def addSynapse(self, srcCellCol, srcCellIdx, perm): DCNL DCSP self.syns.append([int(srcCellCol), int(srcCellIdx), numpy.float32(perm)])
def updateSynapses(self, synapses, delta): DCNL DCSP reached0 = False DCNL DCSP if (delta > 0): DCNL DCSP  DCSP for synapse in synapses: DCNL DCSP  DCSP  DCSP self.syns[synapse][2] = newValue = (self.syns[synapse][2] + delta) DCNL DCSP  DCSP  DCSP if (newValue > self.tm.permanenceMax): DCNL DCSP  DCSP  DCSP  DCSP self.syns[synapse][2] = self.tm.permanenceMax DCNL DCSP else: DCNL DCSP  DCSP for synapse in synapses: DCNL DCSP  DCSP  DCSP self.syns[synapse][2] = newValue = (self.syns[synapse][2] + delta) DCNL DCSP  DCSP  DCSP if (newValue <= 0): DCNL DCSP  DCSP  DCSP  DCSP self.syns[synapse][2] = 0 DCNL DCSP  DCSP  DCSP  DCSP reached0 = True DCNL DCSP return reached0
def __constructEphemeralInstanceVars(self): DCNL DCSP assert (not hasattr(self, 'ephemeral')) DCNL DCSP self.ephemeral = DictObj() DCNL DCSP self.ephemeral.logPathInput = '' DCNL DCSP self.ephemeral.logPathOutput = '' DCNL DCSP self.ephemeral.logPathOutputDense = '' DCNL DCSP self.ephemeral._fpLogInput = None DCNL DCSP self.ephemeral._fpLogOutput = None DCNL DCSP self.ephemeral._fpLogOutputDense = None DCNL DCSP return
def initialize(self): DCNL DCSP self.identityPolicy.initialize(self) DCNL DCSP _debugOut(self.identityPolicy.getName())
def compute(self, inputs, outputs): DCNL DCSP self.identityPolicy.compute(inputs, outputs) DCNL DCSP _debugOut(('%s: DCSP inputs=%s; DCSP outputs=%s' % (self.identityPolicy.getName(), inputs, outputs))) DCNL DCSP return
@classmethod DCNL def getSpec(cls): DCNL DCSP spec = dict(description='TestRegion', singleNodeOnly=True, inputs=dict(bottomUpIn=dict(description='The DCSP input DCSP vector.', dataType='Real32', count=0, required=False, regionLevel=True, isDefaultInput=True, requireSplitterMap=False), topDownIn=dict(description='The DCSP top-down DCSP input DCSP signal, DCSP generated DCSP from\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP feedback DCSP from DCSP upper DCSP levels', dataType='Real32', count=0, required=False, regionLevel=True, isDefaultInput=False, requireSplitterMap=False)), outputs=dict(bottomUpOut=dict(description='The DCSP output DCSP signal DCSP generated DCSP from DCSP the DCSP bottom-up DCSP inputs\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP lower DCSP levels.', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=True), topDownOut=dict(description='The DCSP top-down DCSP output DCSP signal, DCSP generated DCSP from\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP feedback DCSP from DCSP upper DCSP levels', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False)), parameters=dict(logPathInput=dict(description='Optional DCSP name DCSP of DCSP input DCSP log DCSP file. DCSP If DCSP set, DCSP every DCSP input DCSP vector DCSP will DCSP be DCSP logged DCSP to DCSP this DCSP file.', accessMode='ReadWrite', dataType='Byte', count=0, constraints=''), logPathOutput=dict(description='Optional DCSP name DCSP of DCSP output DCSP log DCSP file. DCSP If DCSP set, DCSP every DCSP output DCSP vector DCSP will DCSP be DCSP logged DCSP to DCSP this DCSP file.', accessMode='ReadWrite', dataType='Byte', count=0, constraints=''), logPathOutputDense=dict(description='Optional DCSP name DCSP of DCSP output DCSP log DCSP file. DCSP If DCSP set, DCSP every DCSP output DCSP vector DCSP will DCSP be DCSP logged DCSP to DCSP this DCSP file DCSP as DCSP a DCSP dense DCSP vector.', accessMode='ReadWrite', dataType='Byte', count=0, constraints=''), breakPdb=dict(description='Set DCSP to DCSP 1 DCSP to DCSP stop DCSP in DCSP the DCSP pdb DCSP debugger DCSP on DCSP the DCSP next DCSP compute', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='ReadWrite'), breakKomodo=dict(description='Set DCSP to DCSP 1 DCSP to DCSP stop DCSP in DCSP the DCSP Komodo DCSP debugger DCSP on DCSP the DCSP next DCSP compute', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='ReadWrite')), commands=dict(setIdentityPolicyInstance=dict(description=(('Set DCSP identity DCSP policy DCSP instance DCSP BERORE DCSP running DCSP the DCSP network. DCSP ' + "The DCSP instance DCSP MUST DCSP be DCSP derived DCSP from DCSP TestRegion's DCSP ") + 'RegionIdentityPolicyBase DCSP class.')), getIdentityPolicyInstance=dict(description=(('Returns DCSP identity DCSP policy DCSP instance DCSP that DCSP was DCSP associated DCSP with DCSP ' + 'the DCSP TestRegion DCSP instance DCSP via DCSP the DCSP setIdentityPolicyInstance DCSP ') + 'command.')))) DCNL DCSP return spec
def getParameter(self, parameterName, index=(-1)): DCNL DCSP assert (not ((parameterName in self.__dict__) and (parameterName in self.ephemeral))) DCNL DCSP if (parameterName in self.ephemeral): DCNL DCSP  DCSP assert (parameterName not in self.__dict__) DCNL DCSP  DCSP return self.ephemeral[parameterName] DCNL DCSP else: DCNL DCSP  DCSP return super(PyRegion, self).getParameter(parameterName, index)
def setParameter(self, parameterName, index, parameterValue): DCNL DCSP assert (not ((parameterName in self.__dict__) and (parameterName in self.ephemeral))) DCNL DCSP if (parameterName in self.ephemeral): DCNL DCSP  DCSP if (parameterName == 'logPathInput'): DCNL DCSP  DCSP  DCSP self.ephemeral.logPathInput = parameterValue DCNL DCSP  DCSP  DCSP if self.ephemeral._fpLogInput: DCNL DCSP  DCSP  DCSP  DCSP self.ephemeral._fpLogInput.close() DCNL DCSP  DCSP  DCSP  DCSP self.ephemeral._fpLogInput = None DCNL DCSP  DCSP  DCSP if parameterValue: DCNL DCSP  DCSP  DCSP  DCSP self.ephemeral._fpLogInput = open(self.ephemeral.logPathInput, 'w') DCNL DCSP  DCSP elif (parameterName == 'logPathOutput'): DCNL DCSP  DCSP  DCSP self.ephemeral.logPathOutput = parameterValue DCNL DCSP  DCSP  DCSP if self.ephemeral._fpLogOutput: DCNL DCSP  DCSP  DCSP  DCSP self.ephemeral._fpLogOutput.close() DCNL DCSP  DCSP  DCSP  DCSP self.ephemeral._fpLogOutput = None DCNL DCSP  DCSP  DCSP if parameterValue: DCNL DCSP  DCSP  DCSP  DCSP self.ephemeral._fpLogOutput = open(self.ephemeral.logPathOutput, 'w') DCNL DCSP  DCSP elif (parameterName == 'logPathOutputDense'): DCNL DCSP  DCSP  DCSP self.ephemeral.logPathOutputDense = parameterValue DCNL DCSP  DCSP  DCSP if self.ephemeral._fpLogOutputDense: DCNL DCSP  DCSP  DCSP  DCSP self.ephemeral._fpLogOutputDense.close() DCNL DCSP  DCSP  DCSP  DCSP self.ephemeral._fpLogOutputDense = None DCNL DCSP  DCSP  DCSP if parameterValue: DCNL DCSP  DCSP  DCSP  DCSP self.ephemeral._fpLogOutputDense = open(self.ephemeral.logPathOutputDense, 'w') DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unknown DCSP parameter: DCSP ' + parameterName)) DCNL DCSP return
def setIdentityPolicyInstance(self, identityPolicyObj): DCNL DCSP assert (not self.identityPolicy) DCNL DCSP assert isinstance(identityPolicyObj, RegionIdentityPolicyBase) DCNL DCSP self.identityPolicy = identityPolicyObj DCNL DCSP return
def getIdentityPolicyInstance(self): DCNL DCSP assert self.identityPolicy DCNL DCSP return self.identityPolicy
def write(self, proto): DCNL DCSP proto.breakPdb = self.breakPdb DCNL DCSP proto.breakKomodo = self.breakKomodo
def read(self, proto): DCNL DCSP self.breakPdb = proto.breakPdb DCNL DCSP self.breakKomodo = proto.breakKomodo DCNL DCSP self.__constructEphemeralInstanceVars()
def __getstate__(self): DCNL DCSP state = self.__dict__.copy() DCNL DCSP state.pop('ephemeral') DCNL DCSP return state
def __setstate__(self, state): DCNL DCSP assert ('ephemeral' not in state) DCNL DCSP self.__dict__.update(state) DCNL DCSP self.__constructEphemeralInstanceVars() DCNL DCSP return
def _initializeEphemeralMembers(self): DCNL DCSP for attrName in self._getEphemeralMembersBase(): DCNL DCSP  DCSP if (attrName != '_loaded'): DCNL DCSP  DCSP  DCSP if hasattr(self, attrName): DCNL DCSP  DCSP  DCSP  DCSP if self._loaded: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print self.__class__.__name__, ("contains DCSP base DCSP class DCSP member DCSP '%s'" % attrName) DCNL DCSP if (not self._loaded): DCNL DCSP  DCSP for attrName in self._getEphemeralMembersBase(): DCNL DCSP  DCSP  DCSP if (attrName != '_loaded'): DCNL DCSP  DCSP  DCSP  DCSP assert (not hasattr(self, attrName)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert hasattr(self, attrName) DCNL DCSP self._profileObj = None DCNL DCSP self._iterations = 0 DCNL DCSP self._initEphemerals() DCNL DCSP self._checkEphemeralMembers()
def initialize(self): DCNL DCSP self._spatialPoolerOutput = numpy.zeros(self.columnCount, dtype=GetNTAReal()) DCNL DCSP self._spatialPoolerInput = numpy.zeros((1, self.inputWidth), dtype=GetNTAReal()) DCNL DCSP self._allocateSpatialFDR(None)
def _allocateSpatialFDR(self, rfInput): DCNL DCSP if self._sfdr: DCNL DCSP  DCSP return DCNL DCSP autoArgs = dict(((name, getattr(self, name)) for name in self._spatialArgNames)) DCNL DCSP if ((self.SpatialClass == CPPSpatialPooler) or (self.SpatialClass == PYSpatialPooler)): DCNL DCSP  DCSP autoArgs['columnDimensions'] = [self.columnCount] DCNL DCSP  DCSP autoArgs['inputDimensions'] = [self.inputWidth] DCNL DCSP  DCSP autoArgs['potentialRadius'] = self.inputWidth DCNL DCSP  DCSP self._sfdr = self.SpatialClass(**autoArgs)
def compute(self, inputs, outputs): DCNL DCSP if (False and self.learningMode and (self._iterations > 0) and (self._iterations <= 10)): DCNL DCSP  DCSP import hotshot DCNL DCSP  DCSP if (self._iterations == 10): DCNL DCSP  DCSP  DCSP print '\n DCSP  DCSP Collecting DCSP and DCSP sorting DCSP internal DCSP node DCSP profiling DCSP stats DCSP generated DCSP by DCSP hotshot...' DCNL DCSP  DCSP  DCSP stats = hotshot.stats.load('hotshot.stats') DCNL DCSP  DCSP  DCSP stats.strip_dirs() DCNL DCSP  DCSP  DCSP stats.sort_stats('time', 'calls') DCNL DCSP  DCSP  DCSP stats.print_stats() DCNL DCSP  DCSP if (self._profileObj is None): DCNL DCSP  DCSP  DCSP print '\n DCSP  DCSP Preparing DCSP to DCSP capture DCSP profile DCSP using DCSP hotshot...' DCNL DCSP  DCSP  DCSP if os.path.exists('hotshot.stats'): DCNL DCSP  DCSP  DCSP  DCSP os.remove('hotshot.stats') DCNL DCSP  DCSP  DCSP self._profileObj = hotshot.Profile('hotshot.stats', 1, 1) DCNL DCSP  DCSP self._profileObj.runcall(self._compute, *[inputs, outputs]) DCNL DCSP else: DCNL DCSP  DCSP self._compute(inputs, outputs)
def _compute(self, inputs, outputs): DCNL DCSP if (self._sfdr is None): DCNL DCSP  DCSP raise RuntimeError('Spatial DCSP pooler DCSP has DCSP not DCSP been DCSP initialized') DCNL DCSP if (not self.topDownMode): DCNL DCSP  DCSP self._iterations += 1 DCNL DCSP  DCSP buInputVector = inputs['bottomUpIn'] DCNL DCSP  DCSP resetSignal = False DCNL DCSP  DCSP if ('resetIn' in inputs): DCNL DCSP  DCSP  DCSP assert (len(inputs['resetIn']) == 1) DCNL DCSP  DCSP  DCSP resetSignal = (inputs['resetIn'][0] != 0) DCNL DCSP  DCSP rfOutput = self._doBottomUpCompute(rfInput=buInputVector.reshape((1, buInputVector.size)), resetSignal=resetSignal) DCNL DCSP  DCSP outputs['bottomUpOut'][:] = rfOutput.flat DCNL DCSP else: DCNL DCSP  DCSP topDownIn = inputs.get('topDownIn', None) DCNL DCSP  DCSP (spatialTopDownOut, temporalTopDownOut) = self._doTopDownInfer(topDownIn) DCNL DCSP  DCSP outputs['spatialTopDownOut'][:] = spatialTopDownOut DCNL DCSP  DCSP if (temporalTopDownOut is not None): DCNL DCSP  DCSP  DCSP outputs['temporalTopDownOut'][:] = temporalTopDownOut DCNL DCSP outputs['anomalyScore'][:] = 0
def _doBottomUpCompute(self, rfInput, resetSignal): DCNL DCSP self._conditionalBreak() DCNL DCSP self._spatialPoolerInput = rfInput.reshape((-1)) DCNL DCSP assert (rfInput.shape[0] == 1) DCNL DCSP inputVector = numpy.array(rfInput[0]).astype('uint32') DCNL DCSP outputVector = numpy.zeros(self._sfdr.getNumColumns()).astype('uint32') DCNL DCSP self._sfdr.compute(inputVector, self.learningMode, outputVector) DCNL DCSP self._spatialPoolerOutput[:] = outputVector[:] DCNL DCSP if self._fpLogSP: DCNL DCSP  DCSP output = self._spatialPoolerOutput.reshape((-1)) DCNL DCSP  DCSP outputNZ = output.nonzero()[0] DCNL DCSP  DCSP outStr = ' DCSP '.join([('%d' % int(token)) for token in outputNZ]) DCNL DCSP  DCSP print >>self._fpLogSP, output.size, outStr DCNL DCSP if self._fpLogSPInput: DCNL DCSP  DCSP output = rfInput.reshape((-1)) DCNL DCSP  DCSP outputNZ = output.nonzero()[0] DCNL DCSP  DCSP outStr = ' DCSP '.join([('%d' % int(token)) for token in outputNZ]) DCNL DCSP  DCSP print >>self._fpLogSPInput, output.size, outStr DCNL DCSP return self._spatialPoolerOutput
def _doTopDownInfer(self, topDownInput=None): DCNL DCSP return (None, None)
@classmethod DCNL def getBaseSpec(cls): DCNL DCSP spec = dict(description=SPRegion.__doc__, singleNodeOnly=True, inputs=dict(bottomUpIn=dict(description='The DCSP input DCSP vector.', dataType='Real32', count=0, required=True, regionLevel=False, isDefaultInput=True, requireSplitterMap=False), resetIn=dict(description='A DCSP boolean DCSP flag DCSP that DCSP indicates DCSP whether\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP or DCSP not DCSP the DCSP input DCSP vector DCSP received DCSP in DCSP this DCSP compute DCSP cycle\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP represents DCSP the DCSP start DCSP of DCSP a DCSP new DCSP temporal DCSP sequence.', dataType='Real32', count=1, required=False, regionLevel=True, isDefaultInput=False, requireSplitterMap=False), topDownIn=dict(description='The DCSP top-down DCSP input DCSP signal, DCSP generated DCSP from\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP feedback DCSP from DCSP upper DCSP levels', dataType='Real32', count=0, required=False, regionLevel=True, isDefaultInput=False, requireSplitterMap=False), sequenceIdIn=dict(description='Sequence DCSP ID', dataType='UInt64', count=1, required=False, regionLevel=True, isDefaultInput=False, requireSplitterMap=False)), outputs=dict(bottomUpOut=dict(description='The DCSP output DCSP signal DCSP generated DCSP from DCSP the DCSP bottom-up DCSP inputs\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP lower DCSP levels.', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=True), topDownOut=dict(description='The DCSP top-down DCSP output DCSP signal, DCSP generated DCSP from\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP feedback DCSP from DCSP upper DCSP levels', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False), spatialTopDownOut=dict(description='The DCSP top-down DCSP output, DCSP generated DCSP only DCSP from DCSP the DCSP current\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SP DCSP output. DCSP This DCSP can DCSP be DCSP used DCSP to DCSP evaluate DCSP how DCSP well DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SP DCSP is DCSP representing DCSP the DCSP inputs DCSP independent DCSP of DCSP the DCSP TM.', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False), temporalTopDownOut=dict(description='The DCSP top-down DCSP output, DCSP generated DCSP only DCSP from DCSP the DCSP current\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TM DCSP output DCSP feedback DCSP down DCSP through DCSP the DCSP SP.', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False), anomalyScore=dict(description="The DCSP score DCSP for DCSP how DCSP 'anomalous' DCSP (i.e. DCSP rare) DCSP this DCSP spatial\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP input DCSP pattern DCSP is. DCSP Higher DCSP values DCSP are DCSP increasingly DCSP rare", dataType='Real32', count=1, regionLevel=True, isDefaultOutput=False)), parameters=dict(breakPdb=dict(description='Set DCSP to DCSP 1 DCSP to DCSP stop DCSP in DCSP the DCSP pdb DCSP debugger DCSP on DCSP the DCSP next DCSP compute', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='ReadWrite'), breakKomodo=dict(description='Set DCSP to DCSP 1 DCSP to DCSP stop DCSP in DCSP the DCSP Komodo DCSP debugger DCSP on DCSP the DCSP next DCSP compute', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='ReadWrite'))) DCNL DCSP return spec
@classmethod DCNL def getSpec(cls): DCNL DCSP spec = cls.getBaseSpec() DCNL DCSP (s, o) = _getAdditionalSpecs(spatialImp=getDefaultSPImp()) DCNL DCSP spec['parameters'].update(s) DCNL DCSP spec['parameters'].update(o) DCNL DCSP return spec
def getAlgorithmInstance(self): DCNL DCSP return self._sfdr
def getParameter(self, parameterName, index=(-1)): DCNL DCSP if (parameterName == 'activeOutputCount'): DCNL DCSP  DCSP return self.columnCount DCNL DCSP elif (parameterName == 'spatialPoolerInput'): DCNL DCSP  DCSP return list(self._spatialPoolerInput.reshape((-1))) DCNL DCSP elif (parameterName == 'spatialPoolerOutput'): DCNL DCSP  DCSP return list(self._spatialPoolerOutput) DCNL DCSP elif (parameterName == 'spNumActiveOutputs'): DCNL DCSP  DCSP return len(self._spatialPoolerOutput.nonzero()[0]) DCNL DCSP elif (parameterName == 'spOutputNonZeros'): DCNL DCSP  DCSP return ([len(self._spatialPoolerOutput)] + list(self._spatialPoolerOutput.nonzero()[0])) DCNL DCSP elif (parameterName == 'spInputNonZeros'): DCNL DCSP  DCSP import pdb DCNL DCSP  DCSP pdb.set_trace() DCNL DCSP  DCSP return ([len(self._spatialPoolerInput)] + list(self._spatialPoolerInput.nonzero()[0])) DCNL DCSP elif (parameterName == 'spLearningStatsStr'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return str(self._sfdr.getLearningStats()) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return str(dict()) DCNL DCSP else: DCNL DCSP  DCSP return PyRegion.getParameter(self, parameterName, index)
def setParameter(self, parameterName, index, parameterValue): DCNL DCSP if (parameterName in self._spatialArgNames): DCNL DCSP  DCSP setattr(self._sfdr, parameterName, parameterValue) DCNL DCSP elif (parameterName == 'logPathInput'): DCNL DCSP  DCSP self.logPathInput = parameterValue DCNL DCSP  DCSP if self._fpLogSPInput: DCNL DCSP  DCSP  DCSP self._fpLogSPInput.close() DCNL DCSP  DCSP  DCSP self._fpLogSPInput = None DCNL DCSP  DCSP if parameterValue: DCNL DCSP  DCSP  DCSP self._fpLogSPInput = open(self.logPathInput, 'w') DCNL DCSP elif (parameterName == 'logPathOutput'): DCNL DCSP  DCSP self.logPathOutput = parameterValue DCNL DCSP  DCSP if self._fpLogSP: DCNL DCSP  DCSP  DCSP self._fpLogSP.close() DCNL DCSP  DCSP  DCSP self._fpLogSP = None DCNL DCSP  DCSP if parameterValue: DCNL DCSP  DCSP  DCSP self._fpLogSP = open(self.logPathOutput, 'w') DCNL DCSP elif (parameterName == 'logPathOutputDense'): DCNL DCSP  DCSP self.logPathOutputDense = parameterValue DCNL DCSP  DCSP if self._fpLogSPDense: DCNL DCSP  DCSP  DCSP self._fpLogSPDense.close() DCNL DCSP  DCSP  DCSP self._fpLogSPDense = None DCNL DCSP  DCSP if parameterValue: DCNL DCSP  DCSP  DCSP self._fpLogSPDense = open(self.logPathOutputDense, 'w') DCNL DCSP elif hasattr(self, parameterName): DCNL DCSP  DCSP setattr(self, parameterName, parameterValue) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unknown DCSP parameter: DCSP ' + parameterName))
@staticmethod DCNL def getSchema(): DCNL DCSP return SPRegionProto
def writeToProto(self, proto): DCNL DCSP proto.spatialImp = self.spatialImp DCNL DCSP proto.columnCount = self.columnCount DCNL DCSP proto.inputWidth = self.inputWidth DCNL DCSP proto.learningMode = (1 if self.learningMode else 0) DCNL DCSP proto.inferenceMode = (1 if self.inferenceMode else 0) DCNL DCSP proto.anomalyMode = (1 if self.anomalyMode else 0) DCNL DCSP proto.topDownMode = (1 if self.topDownMode else 0) DCNL DCSP self._sfdr.write(proto.spatialPooler)
@classmethod DCNL def readFromProto(cls, proto): DCNL DCSP instance = cls(proto.columnCount, proto.inputWidth) DCNL DCSP instance.spatialImp = proto.spatialImp DCNL DCSP instance.learningMode = proto.learningMode DCNL DCSP instance.inferenceMode = proto.inferenceMode DCNL DCSP instance.anomalyMode = proto.anomalyMode DCNL DCSP instance.topDownMode = proto.topDownMode DCNL DCSP spatialImp = proto.spatialImp DCNL DCSP instance._sfdr = getSPClass(spatialImp).read(proto.spatialPooler) DCNL DCSP return instance
def __getstate__(self): DCNL DCSP state = self.__dict__.copy() DCNL DCSP for ephemeralMemberName in self._getEphemeralMembersAll(): DCNL DCSP  DCSP state.pop(ephemeralMemberName, None) DCNL DCSP return state
def __setstate__(self, state): DCNL DCSP self.__dict__.update(state) DCNL DCSP self._loaded = True DCNL DCSP if (not hasattr(self, 'SpatialClass')): DCNL DCSP  DCSP self.SpatialClass = self._sfdr.__class__ DCNL DCSP self._initializeEphemeralMembers() DCNL DCSP self._allocateSpatialFDR(None)
def _initEphemerals(self): DCNL DCSP if (hasattr(self, '_sfdr') and self._sfdr): DCNL DCSP  DCSP self._spatialPoolerOutput = numpy.zeros(self.columnCount, dtype=GetNTAReal()) DCNL DCSP else: DCNL DCSP  DCSP self._spatialPoolerOutput = None DCNL DCSP self._fpLogSPInput = None DCNL DCSP self._fpLogSP = None DCNL DCSP self._fpLogSPDense = None DCNL DCSP self.logPathInput = '' DCNL DCSP self.logPathOutput = '' DCNL DCSP self.logPathOutputDense = ''
def _getEphemeralMembers(self): DCNL DCSP return ['_spatialPoolerOutput', '_fpLogSP', '_fpLogSPDense', 'logPathInput', 'logPathOutput', 'logPathOutputDense']
def _getEphemeralMembersBase(self): DCNL DCSP return ['_loaded', '_profileObj', '_iterations']
def _getEphemeralMembersAll(self): DCNL DCSP return (self._getEphemeralMembersBase() + self._getEphemeralMembers())
def getParameterArrayCount(self, name, index): DCNL DCSP p = self.getParameter(name) DCNL DCSP if (not hasattr(p, '__len__')): DCNL DCSP  DCSP raise Exception(("Attempt DCSP to DCSP access DCSP parameter DCSP '%s' DCSP as DCSP an DCSP array DCSP but DCSP it DCSP is DCSP not DCSP an DCSP array" % name)) DCNL DCSP return len(p)
def getParameterArray(self, name, index, a): DCNL DCSP p = self.getParameter(name) DCNL DCSP if (not hasattr(p, '__len__')): DCNL DCSP  DCSP raise Exception(("Attempt DCSP to DCSP access DCSP parameter DCSP '%s' DCSP as DCSP an DCSP array DCSP but DCSP it DCSP is DCSP not DCSP an DCSP array" % name)) DCNL DCSP if (len(p) > 0): DCNL DCSP  DCSP a[:] = p[:]
def invariant(self): DCNL DCSP assert isinstance(self.description, str) DCNL DCSP assert isinstance(self.singleNodeOnly, bool) DCNL DCSP assert isinstance(self.inputs, dict) DCNL DCSP assert isinstance(self.outputs, dict) DCNL DCSP assert isinstance(self.parameters, dict) DCNL DCSP assert isinstance(self.commands, dict) DCNL DCSP hasDefaultInput = False DCNL DCSP for (k, v) in self.inputs.items(): DCNL DCSP  DCSP assert isinstance(k, str) DCNL DCSP  DCSP assert isinstance(v, InputSpec) DCNL DCSP  DCSP v.invariant() DCNL DCSP  DCSP if v.isDefaultInput: DCNL DCSP  DCSP  DCSP assert (not hasDefaultInput) DCNL DCSP  DCSP  DCSP hasDefaultInput = True DCNL DCSP hasDefaultOutput = False DCNL DCSP for (k, v) in self.outputs.items(): DCNL DCSP  DCSP assert isinstance(k, str) DCNL DCSP  DCSP assert isinstance(v, OutputSpec) DCNL DCSP  DCSP v.invariant() DCNL DCSP  DCSP if v.isDefaultOutput: DCNL DCSP  DCSP  DCSP assert (not hasDefaultOutput) DCNL DCSP  DCSP  DCSP hasDefaultOutput = True DCNL DCSP for (k, v) in self.parameters.items(): DCNL DCSP  DCSP assert isinstance(k, str) DCNL DCSP  DCSP assert isinstance(v, ParameterSpec) DCNL DCSP  DCSP v.invariant() DCNL DCSP for (k, v) in self.commands.items(): DCNL DCSP  DCSP assert isinstance(k, str) DCNL DCSP  DCSP assert isinstance(v, CommandSpec) DCNL DCSP  DCSP v.invariant()
def toDict(self): DCNL DCSP def items2dict(items): DCNL DCSP  DCSP 'Convert DCSP a DCSP dict DCSP of DCSP node DCSP spec DCSP items DCSP to DCSP a DCSP plain DCSP dict\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Each DCSP node DCSP spec DCSP item DCSP object DCSP will DCSP be DCSP converted DCSP to DCSP a DCSP dict DCSP of DCSP its\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP attributes. DCSP The DCSP entire DCSP items DCSP dict DCSP will DCSP become DCSP a DCSP dict DCSP of DCSP dicts DCSP (same DCSP keys).\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP d = {} DCNL DCSP  DCSP for (k, v) in items.items(): DCNL DCSP  DCSP  DCSP d[k] = v.__dict__ DCNL DCSP  DCSP return d DCNL DCSP self.invariant() DCNL DCSP return dict(description=self.description, singleNodeOnly=self.singleNodeOnly, inputs=items2dict(self.inputs), outputs=items2dict(self.outputs), parameters=items2dict(self.parameters), commands=items2dict(self.commands))
@classmethod DCNL def getSpec(cls): DCNL DCSP ns = dict(description=KNNClassifierRegion.__doc__, singleNodeOnly=True, inputs=dict(categoryIn=dict(description='Vector DCSP of DCSP zero DCSP or DCSP more DCSP category DCSP indices DCSP for DCSP this DCSP inputsample. DCSP -1 DCSP implies DCSP no DCSP category.', dataType='Real32', count=0, required=True, regionLevel=True, isDefaultInput=False, requireSplitterMap=False), bottomUpIn=dict(description="Belief DCSP values DCSP over DCSP children's DCSP groups", dataType='Real32', count=0, required=True, regionLevel=False, isDefaultInput=True, requireSplitterMap=False), partitionIn=dict(description='Partition DCSP ID DCSP of DCSP the DCSP input DCSP sample', dataType='Real32', count=0, required=True, regionLevel=True, isDefaultInput=False, requireSplitterMap=False), auxDataIn=dict(description='Auxiliary DCSP data DCSP from DCSP the DCSP sensor', dataType='Real32', count=0, required=False, regionLevel=True, isDefaultInput=False, requireSplitterMap=False)), outputs=dict(categoriesOut=dict(description='A DCSP vector DCSP representing, DCSP for DCSP each DCSP category DCSP index, DCSP the DCSP likelihood DCSP that DCSP the DCSP input DCSP to DCSP the DCSP node DCSP belongs DCSP to DCSP that DCSP category DCSP based DCSP on DCSP the DCSP number DCSP of DCSP neighbors DCSP of DCSP that DCSP category DCSP that DCSP are DCSP among DCSP the DCSP nearest DCSP K.', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=True), bestPrototypeIndices=dict(description='A DCSP vector DCSP that DCSP lists, DCSP in DCSP descending DCSP order DCSP of DCSP the DCSP match, DCSP the DCSP positions DCSP of DCSP the DCSP prototypes DCSP that DCSP best DCSP match DCSP the DCSP input DCSP pattern.', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False), categoryProbabilitiesOut=dict(description='A DCSP vector DCSP representing, DCSP for DCSP each DCSP category DCSP index, DCSP the DCSP probability DCSP that DCSP the DCSP input DCSP to DCSP the DCSP node DCSP belongs DCSP to DCSP that DCSP category DCSP based DCSP on DCSP the DCSP distance DCSP to DCSP the DCSP nearest DCSP neighbor DCSP of DCSP each DCSP category.', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=True)), parameters=dict(learningMode=dict(description='Boolean DCSP (0/1) DCSP indicating DCSP whether DCSP or DCSP not DCSP a DCSP region DCSP is DCSP in DCSP learning DCSP mode.', dataType='UInt32', count=1, constraints='bool', defaultValue=1, accessMode='ReadWrite'), inferenceMode=dict(description='Boolean DCSP (0/1) DCSP indicating DCSP whether DCSP or DCSP not DCSP a DCSP region DCSP is DCSP in DCSP inference DCSP mode.', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='ReadWrite'), acceptanceProbability=dict(description='During DCSP learning, DCSP inputs DCSP are DCSP learned DCSP with DCSP probability DCSP equal DCSP to DCSP this DCSP parameter. DCSP If DCSP set DCSP to DCSP 1.0, DCSP the DCSP default, DCSP all DCSP inputs DCSP will DCSP be DCSP considered DCSP (subject DCSP to DCSP other DCSP tests).', dataType='Real32', count=1, constraints='', defaultValue=1.0, accessMode='ReadWrite'), confusion=dict(description='Confusion DCSP matrix DCSP accumulated DCSP during DCSP inference. DCSP Reset DCSP with DCSP reset(). DCSP This DCSP is DCSP available DCSP to DCSP Python DCSP client DCSP code DCSP only.', dataType='Handle', count=2, constraints='', defaultValue=None, accessMode='Read'), activeOutputCount=dict(description='The DCSP number DCSP of DCSP active DCSP elements DCSP in DCSP the DCSP "categoriesOut" DCSP output.', dataType='UInt32', count=1, constraints='', defaultValue=0, accessMode='Read'), categoryCount=dict(description='An DCSP integer DCSP indicating DCSP the DCSP number DCSP of DCSP categories DCSP that DCSP have DCSP been DCSP learned', dataType='UInt32', count=1, constraints='', defaultValue=None, accessMode='Read'), patternCount=dict(description='Number DCSP of DCSP patterns DCSP learned DCSP by DCSP the DCSP classifier.', dataType='UInt32', count=1, constraints='', defaultValue=None, accessMode='Read'), patternMatrix=dict(description='The DCSP actual DCSP patterns DCSP learned DCSP by DCSP the DCSP classifier, DCSP returned DCSP as DCSP a DCSP matrix.', dataType='Handle', count=1, constraints='', defaultValue=None, accessMode='Read'), k=dict(description='The DCSP number DCSP of DCSP nearest DCSP neighbors DCSP to DCSP use DCSP during DCSP inference.', dataType='UInt32', count=1, constraints='', defaultValue=1, accessMode='Create'), maxCategoryCount=dict(description='The DCSP maximal DCSP number DCSP of DCSP categories DCSP the DCSP classifier DCSP will DCSP distinguish DCSP between.', dataType='UInt32', count=1, constraints='', defaultValue=2, accessMode='Create'), distanceNorm=dict(description='The DCSP norm DCSP to DCSP use DCSP for DCSP a DCSP distance DCSP metric DCSP (i.e., DCSP the DCSP "p" DCSP in DCSP Lp-norm)', dataType='Real32', count=1, constraints='', defaultValue=2.0, accessMode='ReadWrite'), distanceMethod=dict(description='Method DCSP used DCSP to DCSP compute DCSP distances DCSP between DCSP inputs DCSP andprototypes. DCSP Possible DCSP options DCSP are DCSP norm, DCSP rawOverlap, DCSP pctOverlapOfLarger, DCSP and DCSP pctOverlapOfProto', dataType='Byte', count=0, constraints='enum: DCSP norm, DCSP rawOverlap, DCSP pctOverlapOfLarger, DCSP pctOverlapOfProto, DCSP pctOverlapOfInput', defaultValue='norm', accessMode='ReadWrite'), outputProbabilitiesByDist=dict(description='If DCSP True, DCSP categoryProbabilitiesOut DCSP is DCSP the DCSP probability DCSP of DCSP each DCSP category DCSP based DCSP on DCSP the DCSP distance DCSP to DCSP the DCSP nearest DCSP neighbor DCSP of DCSP each DCSP category. DCSP If DCSP False, DCSP categoryProbabilitiesOut DCSP is DCSP the DCSP percentage DCSP of DCSP neighbors DCSP among DCSP the DCSP top DCSP K DCSP that DCSP are DCSP of DCSP each DCSP category.', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='Create'), distThreshold=dict(description='Distance DCSP Threshold. DCSP  DCSP If DCSP a DCSP pattern DCSP that DCSP is DCSP less DCSP than DCSP distThreshold DCSP apart DCSP from DCSP the DCSP input DCSP pattern DCSP already DCSP exists DCSP in DCSP the DCSP KNN DCSP memory, DCSP then DCSP the DCSP input DCSP pattern DCSP is DCSP not DCSP added DCSP to DCSP KNN DCSP memory.', dataType='Real32', count=1, constraints='', defaultValue=0.0, accessMode='ReadWrite'), inputThresh=dict(description='Input DCSP binarization DCSP threshold, DCSP used DCSP if DCSP "doBinarization" DCSP is DCSP True.', dataType='Real32', count=1, constraints='', defaultValue=0.5, accessMode='Create'), doBinarization=dict(description='Whether DCSP or DCSP not DCSP to DCSP binarize DCSP the DCSP input DCSP vectors.', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='Create'), useSparseMemory=dict(description='A DCSP boolean DCSP flag DCSP that DCSP determines DCSP whether DCSP or DCSP not DCSP the DCSP KNNClassifier DCSP will DCSP use DCSP sparse DCSP Memory', dataType='UInt32', count=1, constraints='', defaultValue=1, accessMode='Create'), minSparsity=dict(description='If DCSP useSparseMemory DCSP is DCSP set, DCSP only DCSP vectors DCSP with DCSP sparsity DCSP >= DCSP minSparsity DCSP will DCSP be DCSP stored DCSP during DCSP learning. DCSP A DCSP value DCSP of DCSP 0.0 DCSP implies DCSP all DCSP vectors DCSP will DCSP be DCSP stored. DCSP A DCSP value DCSP of DCSP 0.1 DCSP implies DCSP only DCSP vectors DCSP with DCSP at DCSP least DCSP 10% DCSP sparsity DCSP will DCSP be DCSP stored', dataType='Real32', count=1, constraints='', defaultValue=0.0, accessMode='ReadWrite'), sparseThreshold=dict(description='If DCSP sparse DCSP memory DCSP is DCSP used, DCSP input DCSP variables DCSP whose DCSP absolute DCSP value DCSP is DCSP less DCSP than DCSP this DCSP threshold DCSP  DCSP will DCSP be DCSP stored DCSP as DCSP zero', dataType='Real32', count=1, constraints='', defaultValue=0.0, accessMode='Create'), relativeThreshold=dict(description='Whether DCSP to DCSP multiply DCSP sparseThreshold DCSP by DCSP max DCSP value DCSP  DCSP in DCSP input', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='Create'), winnerCount=dict(description='Only DCSP this DCSP many DCSP elements DCSP of DCSP the DCSP input DCSP are DCSP stored. DCSP All DCSP elements DCSP are DCSP stored DCSP if DCSP 0.', dataType='UInt32', count=1, constraints='', defaultValue=0, accessMode='Create'), doSphering=dict(description='A DCSP boolean DCSP indicating DCSP whether DCSP or DCSP not DCSP data DCSP shouldbe DCSP "sphered" DCSP (i.e. DCSP each DCSP dimension DCSP should DCSP be DCSP normalized DCSP suchthat DCSP its DCSP mean DCSP and DCSP variance DCSP are DCSP zero DCSP and DCSP one, DCSP respectively.) DCSP This DCSP sphering DCSP normalization DCSP would DCSP be DCSP performed DCSP after DCSP all DCSP training DCSP samples DCSP had DCSP been DCSP received DCSP but DCSP before DCSP inference DCSP was DCSP performed. DCSP The DCSP dimension-specific DCSP normalization DCSP constants DCSP would DCSP then DCSP  DCSP be DCSP applied DCSP to DCSP all DCSP future DCSP incoming DCSP vectors DCSP prior DCSP to DCSP performing DCSP  DCSP conventional DCSP NN DCSP inference.', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='Create'), SVDSampleCount=dict(description='If DCSP not DCSP 0, DCSP carries DCSP out DCSP SVD DCSP transformation DCSP after DCSP that DCSP many DCSP samples DCSP have DCSP been DCSP seen.', dataType='UInt32', count=1, constraints='', defaultValue=0, accessMode='Create'), SVDDimCount=dict(description='Number DCSP of DCSP dimensions DCSP to DCSP keep DCSP after DCSP SVD DCSP if DCSP greater DCSP than DCSP 0. DCSP If DCSP set DCSP to DCSP -1 DCSP it DCSP is DCSP considered DCSP unspecified. DCSP If DCSP set DCSP to DCSP 0 DCSP it DCSP is DCSP consider DCSP "adaptive" DCSP and DCSP the DCSP number DCSP is DCSP chosen DCSP automatically.', dataType='Int32', count=1, constraints='', defaultValue=(-1), accessMode='Create'), fractionOfMax=dict(description='The DCSP smallest DCSP singular DCSP value DCSP which DCSP is DCSP retained DCSP as DCSP a DCSP fraction DCSP of DCSP the DCSP largest DCSP singular DCSP value. DCSP This DCSP is DCSP used DCSP only DCSP if DCSP SVDDimCount==0 DCSP ("adaptive").', dataType='UInt32', count=1, constraints='', defaultValue=0, accessMode='Create'), useAuxiliary=dict(description='Whether DCSP or DCSP not DCSP the DCSP classifier DCSP should DCSP use DCSP auxiliary DCSP input DCSP data.', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='Create'), justUseAuxiliary=dict(description='Whether DCSP or DCSP not DCSP the DCSP classifier DCSP should DCSP ONLUY DCSP use DCSP the DCSP auxiliary DCSP input DCSP data.', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='Create'), verbosity=dict(description='An DCSP integer DCSP that DCSP controls DCSP the DCSP verbosity DCSP level, DCSP 0 DCSP means DCSP no DCSP verbose DCSP output, DCSP increasing DCSP integers DCSP provide DCSP more DCSP verbosity.', dataType='UInt32', count=1, constraints='', defaultValue=0, accessMode='ReadWrite'), keepAllDistances=dict(description='Whether DCSP to DCSP store DCSP all DCSP the DCSP protoScores DCSP in DCSP an DCSP array, DCSP rather DCSP than DCSP just DCSP the DCSP ones DCSP for DCSP the DCSP last DCSP inference. DCSP When DCSP this DCSP parameter DCSP is DCSP changed DCSP from DCSP True DCSP to DCSP False, DCSP all DCSP the DCSP scores DCSP are DCSP discarded DCSP except DCSP for DCSP the DCSP most DCSP recent DCSP one.', dataType='UInt32', count=1, constraints='bool', defaultValue=None, accessMode='ReadWrite'), replaceDuplicates=dict(description='A DCSP boolean DCSP flag DCSP that DCSP determines DCSP whether DCSP ornot DCSP the DCSP KNNClassifier DCSP should DCSP replace DCSP duplicatesduring DCSP learning. DCSP This DCSP should DCSP be DCSP on DCSP when DCSP onlinelearning.', dataType='UInt32', count=1, constraints='bool', defaultValue=None, accessMode='ReadWrite'), cellsPerCol=dict(description='If DCSP >= DCSP 1, DCSP we DCSP assume DCSP the DCSP input DCSP is DCSP organized DCSP into DCSP columns, DCSP in DCSP the DCSP same DCSP manner DCSP as DCSP the DCSP temporal DCSP memory DCSP AND DCSP whenever DCSP we DCSP store DCSP a DCSP new DCSP prototype, DCSP we DCSP only DCSP store DCSP the DCSP start DCSP cell DCSP (first DCSP cell) DCSP in DCSP any DCSP column DCSP which DCSP is DCSP bursting.colum DCSP ', dataType='UInt32', count=1, constraints='', defaultValue=0, accessMode='Create'), maxStoredPatterns=dict(description='Limits DCSP the DCSP maximum DCSP number DCSP of DCSP the DCSP training DCSP patterns DCSP stored. DCSP When DCSP KNN DCSP learns DCSP in DCSP a DCSP fixed DCSP capacity DCSP mode, DCSP the DCSP unused DCSP patterns DCSP are DCSP deleted DCSP once DCSP the DCSP number DCSP of DCSP stored DCSP patterns DCSP is DCSP greater DCSP than DCSP maxStoredPatternscolumns. DCSP [-1 DCSP is DCSP no DCSP limit] DCSP ', dataType='Int32', count=1, constraints='', defaultValue=(-1), accessMode='Create')), commands=dict()) DCNL DCSP return ns
def _getEphemeralAttributes(self): DCNL DCSP return ['_firstComputeCall', '_accuracy', '_protoScores', '_categoryDistances']
def _initEphemerals(self): DCNL DCSP self._firstComputeCall = True DCNL DCSP self._accuracy = None DCNL DCSP self._protoScores = None DCNL DCSP self._categoryDistances = None DCNL DCSP self._knn = knn_classifier.KNNClassifier(**self.knnParams) DCNL DCSP for x in ('_partitions', '_useAuxiliary', '_doSphering', '_scanInfo', '_protoScores'): DCNL DCSP  DCSP if (not hasattr(self, x)): DCNL DCSP  DCSP  DCSP setattr(self, x, None)
def __setstate__(self, state): DCNL DCSP if ('version' not in state): DCNL DCSP  DCSP self.__dict__.update(state) DCNL DCSP elif (state['version'] == 1): DCNL DCSP  DCSP if ('doSelfValidation' in state): DCNL DCSP  DCSP  DCSP state.pop('doSelfValidation') DCNL DCSP  DCSP knnState = state['_knn_state'] DCNL DCSP  DCSP del state['_knn_state'] DCNL DCSP  DCSP self.__dict__.update(state) DCNL DCSP  DCSP self._initEphemerals() DCNL DCSP  DCSP self._knn.__setstate__(knnState) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('Invalid DCSP KNNClassifierRegion DCSP version DCSP for DCSP __setstate__') DCNL DCSP self.version = KNNClassifierRegion.__VERSION__
def __getstate__(self): DCNL DCSP state = self.__dict__.copy() DCNL DCSP state['_knn_state'] = self._knn.__getstate__() DCNL DCSP del state['_knn'] DCNL DCSP for field in self._getEphemeralAttributes(): DCNL DCSP  DCSP del state[field] DCNL DCSP return state
def getAlgorithmInstance(self): DCNL DCSP return self._knn
def getParameter(self, name, index=(-1)): DCNL DCSP if (name == 'patternCount'): DCNL DCSP  DCSP return self._knn._numPatterns DCNL DCSP elif (name == 'patternMatrix'): DCNL DCSP  DCSP return self._getPatternMatrix() DCNL DCSP elif (name == 'k'): DCNL DCSP  DCSP return self._knn.k DCNL DCSP elif (name == 'distanceNorm'): DCNL DCSP  DCSP return self._knn.distanceNorm DCNL DCSP elif (name == 'distanceMethod'): DCNL DCSP  DCSP return self._knn.distanceMethod DCNL DCSP elif (name == 'distThreshold'): DCNL DCSP  DCSP return self._knn.distThreshold DCNL DCSP elif (name == 'inputThresh'): DCNL DCSP  DCSP return self._knn.binarizationThreshold DCNL DCSP elif (name == 'doBinarization'): DCNL DCSP  DCSP return self._knn.doBinarization DCNL DCSP elif (name == 'useSparseMemory'): DCNL DCSP  DCSP return self._knn.useSparseMemory DCNL DCSP elif (name == 'sparseThreshold'): DCNL DCSP  DCSP return self._knn.sparseThreshold DCNL DCSP elif (name == 'winnerCount'): DCNL DCSP  DCSP return self._knn.numWinners DCNL DCSP elif (name == 'relativeThreshold'): DCNL DCSP  DCSP return self._knn.relativeThreshold DCNL DCSP elif (name == 'SVDSampleCount'): DCNL DCSP  DCSP v = self._knn.numSVDSamples DCNL DCSP  DCSP return (v if (v is not None) else 0) DCNL DCSP elif (name == 'SVDDimCount'): DCNL DCSP  DCSP v = self._knn.numSVDDims DCNL DCSP  DCSP return (v if (v is not None) else 0) DCNL DCSP elif (name == 'fractionOfMax'): DCNL DCSP  DCSP v = self._knn.fractionOfMax DCNL DCSP  DCSP return (v if (v is not None) else 0) DCNL DCSP elif (name == 'useAuxiliary'): DCNL DCSP  DCSP return self._useAuxiliary DCNL DCSP elif (name == 'justUseAuxiliary'): DCNL DCSP  DCSP return self._justUseAuxiliary DCNL DCSP elif (name == 'doSphering'): DCNL DCSP  DCSP return self._doSphering DCNL DCSP elif (name == 'cellsPerCol'): DCNL DCSP  DCSP return self._knn.cellsPerCol DCNL DCSP elif (name == 'maxStoredPatterns'): DCNL DCSP  DCSP return self.maxStoredPatterns DCNL DCSP elif (name == 'categoryRecencyList'): DCNL DCSP  DCSP return self._knn._categoryRecencyList DCNL DCSP else: DCNL DCSP  DCSP return PyRegion.getParameter(self, name, index)
def setParameter(self, name, index, value): DCNL DCSP if (name == 'learningMode'): DCNL DCSP  DCSP self.learningMode = bool(int(value)) DCNL DCSP  DCSP self._epoch = 0 DCNL DCSP elif (name == 'inferenceMode'): DCNL DCSP  DCSP self._epoch = 0 DCNL DCSP  DCSP if (int(value) and (not self.inferenceMode)): DCNL DCSP  DCSP  DCSP self._finishLearning() DCNL DCSP  DCSP self.inferenceMode = bool(int(value)) DCNL DCSP elif (name == 'distanceNorm'): DCNL DCSP  DCSP self._knn.distanceNorm = value DCNL DCSP elif (name == 'distanceMethod'): DCNL DCSP  DCSP self._knn.distanceMethod = value DCNL DCSP elif (name == 'keepAllDistances'): DCNL DCSP  DCSP self.keepAllDistances = bool(value) DCNL DCSP  DCSP if (not self.keepAllDistances): DCNL DCSP  DCSP  DCSP if ((self._protoScores is not None) and (self._protoScores.shape[0] > 1)): DCNL DCSP  DCSP  DCSP  DCSP self._protoScores = self._protoScores[(-1), :] DCNL DCSP  DCSP  DCSP if (self._protoScores is not None): DCNL DCSP  DCSP  DCSP  DCSP self._protoScoreCount = 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self._protoScoreCount = 0 DCNL DCSP elif (name == 'verbosity'): DCNL DCSP  DCSP self.verbosity = value DCNL DCSP  DCSP self._knn.verbosity = value DCNL DCSP else: DCNL DCSP  DCSP return PyRegion.setParameter(self, name, index, value)
def reset(self): DCNL DCSP self.confusion = numpy.zeros((1, 1))
def enableTap(self, tapPath): DCNL DCSP self._tapFileIn = open((tapPath + '.in'), 'w') DCNL DCSP self._tapFileOut = open((tapPath + '.out'), 'w')
def disableTap(self): DCNL DCSP if (self._tapFileIn is not None): DCNL DCSP  DCSP self._tapFileIn.close() DCNL DCSP  DCSP self._tapFileIn = None DCNL DCSP if (self._tapFileOut is not None): DCNL DCSP  DCSP self._tapFileOut.close() DCNL DCSP  DCSP self._tapFileOut = None
def handleLogInput(self, inputs): DCNL DCSP if (self._tapFileIn is not None): DCNL DCSP  DCSP for input in inputs: DCNL DCSP  DCSP  DCSP for k in range(len(input)): DCNL DCSP  DCSP  DCSP  DCSP print >>self._tapFileIn, input[k], DCNL DCSP  DCSP  DCSP print >>self._tapFileIn
def handleLogOutput(self, output): DCNL DCSP if (self._tapFileOut is not None): DCNL DCSP  DCSP for k in range(len(output)): DCNL DCSP  DCSP  DCSP print >>self._tapFileOut, output[k], DCNL DCSP  DCSP print >>self._tapFileOut
def _storeSample(self, inputVector, trueCatIndex, partition=0): DCNL DCSP if (self._samples is None): DCNL DCSP  DCSP self._samples = numpy.zeros((0, len(inputVector)), dtype=RealNumpyDType) DCNL DCSP  DCSP assert (self._labels is None) DCNL DCSP  DCSP self._labels = [] DCNL DCSP self._samples = numpy.concatenate((self._samples, numpy.atleast_2d(inputVector)), axis=0) DCNL DCSP self._labels += [trueCatIndex] DCNL DCSP if (self._partitions is None): DCNL DCSP  DCSP self._partitions = [] DCNL DCSP if (partition is None): DCNL DCSP  DCSP partition = 0 DCNL DCSP self._partitions += [partition]
def compute(self, inputs, outputs): DCNL DCSP if (self._useAuxiliary is None): DCNL DCSP  DCSP self._useAuxiliary = False DCNL DCSP if self._firstComputeCall: DCNL DCSP  DCSP self._firstComputeCall = False DCNL DCSP  DCSP if self._useAuxiliary: DCNL DCSP  DCSP  DCSP if (self._justUseAuxiliary == True): DCNL DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP Warning: DCSP You DCSP have DCSP chosen DCSP to DCSP ignore DCSP the DCSP image DCSP data DCSP and DCSP instead DCSP just DCSP use DCSP the DCSP auxiliary DCSP data DCSP stream.' DCNL DCSP inputVector = inputs['bottomUpIn'] DCNL DCSP if (self._useAuxiliary == True): DCNL DCSP  DCSP auxVector = inputs['auxDataIn'] DCNL DCSP  DCSP if (auxVector.dtype != numpy.float32): DCNL DCSP  DCSP  DCSP raise RuntimeError, 'KNNClassifierRegion DCSP expects DCSP numpy.float32 DCSP for DCSP the DCSP auxiliary DCSP data DCSP vector' DCNL DCSP  DCSP if (self._justUseAuxiliary == True): DCNL DCSP  DCSP  DCSP inputVector = inputs['auxDataIn'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inputVector = numpy.concatenate([inputVector, inputs['auxDataIn']]) DCNL DCSP self.handleLogInput([inputVector]) DCNL DCSP assert ('categoryIn' in inputs), 'No DCSP linked DCSP category DCSP input.' DCNL DCSP categories = inputs['categoryIn'] DCNL DCSP if ('partitionIn' in inputs): DCNL DCSP  DCSP assert (len(inputs['partitionIn']) == 1), 'Must DCSP have DCSP exactly DCSP one DCSP link DCSP to DCSP partition DCSP input.' DCNL DCSP  DCSP partInput = inputs['partitionIn'] DCNL DCSP  DCSP assert (len(partInput) == 1), 'Partition DCSP input DCSP element DCSP count DCSP must DCSP be DCSP exactly DCSP 1.' DCNL DCSP  DCSP partition = int(partInput[0]) DCNL DCSP else: DCNL DCSP  DCSP partition = None DCNL DCSP if self.inferenceMode: DCNL DCSP  DCSP categoriesOut = outputs['categoriesOut'] DCNL DCSP  DCSP probabilitiesOut = outputs['categoryProbabilitiesOut'] DCNL DCSP  DCSP if self._doSphering: DCNL DCSP  DCSP  DCSP inputVector = ((inputVector + self._normOffset) * self._normScale) DCNL DCSP  DCSP nPrototypes = 0 DCNL DCSP  DCSP if ('bestPrototypeIndices' in outputs): DCNL DCSP  DCSP  DCSP bestPrototypeIndicesOut = outputs['bestPrototypeIndices'] DCNL DCSP  DCSP  DCSP nPrototypes = len(bestPrototypeIndicesOut) DCNL DCSP  DCSP (winner, inference, protoScores, categoryDistances) = self._knn.infer(inputVector, partitionId=partition) DCNL DCSP  DCSP if (not self.keepAllDistances): DCNL DCSP  DCSP  DCSP self._protoScores = protoScores DCNL DCSP  DCSP elif (self._protoScores is None): DCNL DCSP  DCSP  DCSP self._protoScores = numpy.zeros((1, protoScores.shape[0]), protoScores.dtype) DCNL DCSP  DCSP  DCSP self._protoScores[0, :] = protoScores DCNL DCSP  DCSP  DCSP self._protoScoreCount = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (self._protoScoreCount == self._protoScores.shape[0]): DCNL DCSP  DCSP  DCSP  DCSP newProtoScores = numpy.zeros(((self._protoScores.shape[0] * 2), self._protoScores.shape[1]), self._protoScores.dtype) DCNL DCSP  DCSP  DCSP  DCSP newProtoScores[:self._protoScores.shape[0], :] = self._protoScores DCNL DCSP  DCSP  DCSP  DCSP self._protoScores = newProtoScores DCNL DCSP  DCSP  DCSP self._protoScores[self._protoScoreCount, :] = protoScores DCNL DCSP  DCSP  DCSP self._protoScoreCount += 1 DCNL DCSP  DCSP self._categoryDistances = categoryDistances DCNL DCSP  DCSP if self.outputProbabilitiesByDist: DCNL DCSP  DCSP  DCSP scores = (1.0 - self._categoryDistances) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP scores = inference DCNL DCSP  DCSP total = scores.sum() DCNL DCSP  DCSP if (total == 0): DCNL DCSP  DCSP  DCSP numScores = len(scores) DCNL DCSP  DCSP  DCSP probabilities = (numpy.ones(numScores) / numScores) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP probabilities = (scores / total) DCNL DCSP  DCSP nout = min(len(categoriesOut), len(inference)) DCNL DCSP  DCSP categoriesOut.fill(0) DCNL DCSP  DCSP categoriesOut[0:nout] = inference[0:nout] DCNL DCSP  DCSP probabilitiesOut.fill(0) DCNL DCSP  DCSP probabilitiesOut[0:nout] = probabilities[0:nout] DCNL DCSP  DCSP if (self.verbosity >= 1): DCNL DCSP  DCSP  DCSP print 'KNNRegion: DCSP categoriesOut: DCSP ', categoriesOut[0:nout] DCNL DCSP  DCSP  DCSP print 'KNNRegion: DCSP probabilitiesOut: DCSP ', probabilitiesOut[0:nout] DCNL DCSP  DCSP if (self._scanInfo is not None): DCNL DCSP  DCSP  DCSP self._scanResults = [tuple(inference[:nout])] DCNL DCSP  DCSP for category in categories: DCNL DCSP  DCSP  DCSP if (category >= 0): DCNL DCSP  DCSP  DCSP  DCSP dims = max((int(category) + 1), len(inference)) DCNL DCSP  DCSP  DCSP  DCSP oldDims = len(self.confusion) DCNL DCSP  DCSP  DCSP  DCSP if (oldDims < dims): DCNL DCSP  DCSP  DCSP  DCSP  DCSP confusion = numpy.zeros((dims, dims)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP confusion[0:oldDims, 0:oldDims] = self.confusion DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.confusion = confusion DCNL DCSP  DCSP  DCSP  DCSP self.confusion[(inference.argmax(), int(category))] += 1 DCNL DCSP  DCSP if (nPrototypes > 1): DCNL DCSP  DCSP  DCSP bestPrototypeIndicesOut.fill(0) DCNL DCSP  DCSP  DCSP if (categoryDistances is not None): DCNL DCSP  DCSP  DCSP  DCSP indices = categoryDistances.argsort() DCNL DCSP  DCSP  DCSP  DCSP nout = min(len(indices), nPrototypes) DCNL DCSP  DCSP  DCSP  DCSP bestPrototypeIndicesOut[0:nout] = indices[0:nout] DCNL DCSP  DCSP elif (nPrototypes == 1): DCNL DCSP  DCSP  DCSP if ((categoryDistances is not None) and len(categoryDistances)): DCNL DCSP  DCSP  DCSP  DCSP bestPrototypeIndicesOut[0] = categoryDistances.argmin() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP bestPrototypeIndicesOut[0] = 0 DCNL DCSP  DCSP self.handleLogOutput(inference) DCNL DCSP if self.learningMode: DCNL DCSP  DCSP if ((self.acceptanceProbability < 1.0) and (self._rgen.getReal64() > self.acceptanceProbability)): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for category in categories: DCNL DCSP  DCSP  DCSP  DCSP if (category >= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if self._doSphering: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._storeSample(inputVector, category, partition) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._knn.learn(inputVector, category, partition) DCNL DCSP self._epoch += 1
def getCategoryList(self): DCNL DCSP return self._knn._categoryList
def removeCategory(self, categoryToRemove): DCNL DCSP return self._knn.removeCategory(categoryToRemove)
def getLatestDistances(self): DCNL DCSP if (self._protoScores is not None): DCNL DCSP  DCSP if self.keepAllDistances: DCNL DCSP  DCSP  DCSP return self._protoScores[(self._protoScoreCount - 1), :] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return self._protoScores DCNL DCSP else: DCNL DCSP  DCSP return None
def getAllDistances(self): DCNL DCSP if (self._protoScores is None): DCNL DCSP  DCSP return None DCNL DCSP return self._protoScores[:self._protoScoreCount, :]
def _finishLearning(self): DCNL DCSP if self._doSphering: DCNL DCSP  DCSP self._finishSphering() DCNL DCSP self._knn.finishLearning() DCNL DCSP self._accuracy = None
def _finishSphering(self): DCNL DCSP self._normOffset = (self._samples.mean(axis=0) * (-1.0)) DCNL DCSP self._samples += self._normOffset DCNL DCSP variance = self._samples.var(axis=0) DCNL DCSP variance[numpy.where((variance == 0.0))] = 1.0 DCNL DCSP self._normScale = (1.0 / numpy.sqrt(variance)) DCNL DCSP self._samples *= self._normScale DCNL DCSP for sampleIndex in range(len(self._labels)): DCNL DCSP  DCSP self._knn.learn(self._samples[sampleIndex], self._labels[sampleIndex], self._partitions[sampleIndex])
def getOutputElementCount(self, name): DCNL DCSP if (name == 'categoriesOut'): DCNL DCSP  DCSP return self.maxCategoryCount DCNL DCSP elif (name == 'categoryProbabilitiesOut'): DCNL DCSP  DCSP return self.maxCategoryCount DCNL DCSP elif (name == 'bestPrototypeIndices'): DCNL DCSP  DCSP return (self._bestPrototypeIndexCount if self._bestPrototypeIndexCount else 0) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unknown DCSP output: DCSP ' + name))
def rewind(self): DCNL DCSP self._iterNum = 0 DCNL DCSP if (self.dataSource is not None): DCNL DCSP  DCSP self.dataSource.rewind()
def getNextRecord(self): DCNL DCSP allFiltersHaveEnoughData = False DCNL DCSP while (not allFiltersHaveEnoughData): DCNL DCSP  DCSP data = self.dataSource.getNextRecordDict() DCNL DCSP  DCSP if (not data): DCNL DCSP  DCSP  DCSP raise StopIteration('Datasource DCSP has DCSP no DCSP more DCSP data') DCNL DCSP  DCSP if ('_reset' not in data): DCNL DCSP  DCSP  DCSP data['_reset'] = 0 DCNL DCSP  DCSP if ('_sequenceId' not in data): DCNL DCSP  DCSP  DCSP data['_sequenceId'] = 0 DCNL DCSP  DCSP if ('_category' not in data): DCNL DCSP  DCSP  DCSP data['_category'] = [None] DCNL DCSP  DCSP (data, allFiltersHaveEnoughData) = self.applyFilters(data) DCNL DCSP self.lastRecord = data DCNL DCSP return data
def applyFilters(self, data): DCNL DCSP if (self.verbosity > 0): DCNL DCSP  DCSP print ('RecordSensor DCSP got DCSP data: DCSP %s' % data) DCNL DCSP allFiltersHaveEnoughData = True DCNL DCSP if (len(self.preEncodingFilters) > 0): DCNL DCSP  DCSP originalReset = data['_reset'] DCNL DCSP  DCSP actualReset = originalReset DCNL DCSP  DCSP for f in self.preEncodingFilters: DCNL DCSP  DCSP  DCSP filterHasEnoughData = f.process(data) DCNL DCSP  DCSP  DCSP allFiltersHaveEnoughData = (allFiltersHaveEnoughData and filterHasEnoughData) DCNL DCSP  DCSP  DCSP actualReset = (actualReset or data['_reset']) DCNL DCSP  DCSP  DCSP data['_reset'] = originalReset DCNL DCSP  DCSP data['_reset'] = actualReset DCNL DCSP return (data, allFiltersHaveEnoughData)
def populateCategoriesOut(self, categories, output): DCNL DCSP if (categories[0] is None): DCNL DCSP  DCSP output[:] = (-1) DCNL DCSP else: DCNL DCSP  DCSP for (i, cat) in enumerate(categories[:len(output)]): DCNL DCSP  DCSP  DCSP output[i] = cat DCNL DCSP  DCSP output[len(categories):] = (-1)
def compute(self, inputs, outputs): DCNL DCSP if (not self.topDownMode): DCNL DCSP  DCSP data = self.getNextRecord() DCNL DCSP  DCSP reset = data['_reset'] DCNL DCSP  DCSP sequenceId = data['_sequenceId'] DCNL DCSP  DCSP categories = data['_category'] DCNL DCSP  DCSP self.encoder.encodeIntoArray(data, outputs['dataOut']) DCNL DCSP  DCSP if ((self.predictedField is not None) and (self.predictedField != 'vector')): DCNL DCSP  DCSP  DCSP allEncoders = list(self.encoder.encoders) DCNL DCSP  DCSP  DCSP if (self.disabledEncoder is not None): DCNL DCSP  DCSP  DCSP  DCSP allEncoders.extend(self.disabledEncoder.encoders) DCNL DCSP  DCSP  DCSP encoders = [e for e in allEncoders if (e[0] == self.predictedField)] DCNL DCSP  DCSP  DCSP if (len(encoders) == 0): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('There DCSP is DCSP no DCSP encoder DCSP for DCSP set DCSP for DCSP the DCSP predicted DCSP field: DCSP %s' % self.predictedField)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP encoder = encoders[0][1] DCNL DCSP  DCSP  DCSP actualValue = data[self.predictedField] DCNL DCSP  DCSP  DCSP outputs['bucketIdxOut'][:] = encoder.getBucketIndices(actualValue) DCNL DCSP  DCSP  DCSP if isinstance(actualValue, str): DCNL DCSP  DCSP  DCSP  DCSP outputs['actValueOut'][:] = encoder.getBucketIndices(actualValue) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP outputs['actValueOut'][:] = actualValue DCNL DCSP  DCSP outputs['sourceOut'][:] = self.encoder.getScalars(data) DCNL DCSP  DCSP self._outputValues['sourceOut'] = self.encoder.getEncodedValues(data) DCNL DCSP  DCSP encoders = self.encoder.getEncoderList() DCNL DCSP  DCSP prevOffset = 0 DCNL DCSP  DCSP sourceEncodings = [] DCNL DCSP  DCSP bitData = outputs['dataOut'] DCNL DCSP  DCSP for encoder in encoders: DCNL DCSP  DCSP  DCSP nextOffset = (prevOffset + encoder.getWidth()) DCNL DCSP  DCSP  DCSP sourceEncodings.append(bitData[prevOffset:nextOffset]) DCNL DCSP  DCSP  DCSP prevOffset = nextOffset DCNL DCSP  DCSP self._outputValues['sourceEncodings'] = sourceEncodings DCNL DCSP  DCSP for filter in self.postEncodingFilters: DCNL DCSP  DCSP  DCSP filter.process(encoder=self.encoder, data=outputs['dataOut']) DCNL DCSP  DCSP outputs['resetOut'][0] = reset DCNL DCSP  DCSP outputs['sequenceIdOut'][0] = sequenceId DCNL DCSP  DCSP self.populateCategoriesOut(categories, outputs['categoryOut']) DCNL DCSP  DCSP if (self.verbosity >= 1): DCNL DCSP  DCSP  DCSP if (self._iterNum == 0): DCNL DCSP  DCSP  DCSP  DCSP self.encoder.pprintHeader(prefix='sensor:') DCNL DCSP  DCSP  DCSP if reset: DCNL DCSP  DCSP  DCSP  DCSP print ('RESET DCSP - DCSP sequenceID:%d' % sequenceId) DCNL DCSP  DCSP  DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP if (self.verbosity >= 1): DCNL DCSP  DCSP  DCSP self.encoder.pprint(outputs['dataOut'], prefix=('%7d:' % self._iterNum)) DCNL DCSP  DCSP  DCSP scalarValues = self.encoder.getScalars(data) DCNL DCSP  DCSP  DCSP nz = outputs['dataOut'].nonzero()[0] DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP  DCSP nz: DCSP (%d)' % len(nz)), nz DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP encIn:', self.encoder.scalarsToStr(scalarValues) DCNL DCSP  DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP data:', str(data) DCNL DCSP  DCSP if (self.verbosity >= 3): DCNL DCSP  DCSP  DCSP decoded = self.encoder.decode(outputs['dataOut']) DCNL DCSP  DCSP  DCSP print 'decoded:', self.encoder.decodedToStr(decoded) DCNL DCSP  DCSP self._iterNum += 1 DCNL DCSP else: DCNL DCSP  DCSP spatialTopDownIn = inputs['spatialTopDownIn'] DCNL DCSP  DCSP spatialTopDownOut = self.encoder.topDownCompute(spatialTopDownIn) DCNL DCSP  DCSP values = [elem.value for elem in spatialTopDownOut] DCNL DCSP  DCSP scalars = [elem.scalar for elem in spatialTopDownOut] DCNL DCSP  DCSP encodings = [elem.encoding for elem in spatialTopDownOut] DCNL DCSP  DCSP self._outputValues['spatialTopDownOut'] = values DCNL DCSP  DCSP outputs['spatialTopDownOut'][:] = numpy.array(scalars) DCNL DCSP  DCSP self._outputValues['spatialTopDownEncodings'] = encodings DCNL DCSP  DCSP temporalTopDownIn = inputs['temporalTopDownIn'] DCNL DCSP  DCSP temporalTopDownOut = self.encoder.topDownCompute(temporalTopDownIn) DCNL DCSP  DCSP values = [elem.value for elem in temporalTopDownOut] DCNL DCSP  DCSP scalars = [elem.scalar for elem in temporalTopDownOut] DCNL DCSP  DCSP encodings = [elem.encoding for elem in temporalTopDownOut] DCNL DCSP  DCSP self._outputValues['temporalTopDownOut'] = values DCNL DCSP  DCSP outputs['temporalTopDownOut'][:] = numpy.array(scalars) DCNL DCSP  DCSP self._outputValues['temporalTopDownEncodings'] = encodings DCNL DCSP  DCSP assert (len(spatialTopDownOut) == len(temporalTopDownOut)), 'Error: DCSP spatialTopDownOut DCSP and DCSP temporalTopDownOut DCSP should DCSP be DCSP the DCSP same DCSP size'
def _convertNonNumericData(self, spatialOutput, temporalOutput, output): DCNL DCSP encoders = self.encoder.getEncoderList() DCNL DCSP types = self.encoder.getDecoderOutputFieldTypes() DCNL DCSP for (i, (encoder, type)) in enumerate(zip(encoders, types)): DCNL DCSP  DCSP spatialData = spatialOutput[i] DCNL DCSP  DCSP temporalData = temporalOutput[i] DCNL DCSP  DCSP if ((type != FieldMetaType.integer) and (type != FieldMetaType.float)): DCNL DCSP  DCSP  DCSP spatialData = encoder.getScalars(spatialData)[0] DCNL DCSP  DCSP  DCSP temporalData = encoder.getScalars(temporalData)[0] DCNL DCSP  DCSP assert isinstance(spatialData, (float, int)) DCNL DCSP  DCSP assert isinstance(temporalData, (float, int)) DCNL DCSP  DCSP output['spatialTopDownOut'][i] = spatialData DCNL DCSP  DCSP output['temporalTopDownOut'][i] = temporalData
def getOutputValues(self, outputName): DCNL DCSP return self._outputValues[outputName]
def getOutputElementCount(self, name): DCNL DCSP if (name == 'resetOut'): DCNL DCSP  DCSP print 'WARNING: DCSP getOutputElementCount DCSP should DCSP not DCSP have DCSP been DCSP called DCSP with DCSP resetOut' DCNL DCSP  DCSP return 1 DCNL DCSP elif (name == 'sequenceIdOut'): DCNL DCSP  DCSP print 'WARNING: DCSP getOutputElementCount DCSP should DCSP not DCSP have DCSP been DCSP called DCSP with DCSP sequenceIdOut' DCNL DCSP  DCSP return 1 DCNL DCSP elif (name == 'dataOut'): DCNL DCSP  DCSP if (self.encoder is None): DCNL DCSP  DCSP  DCSP raise Exception("NuPIC DCSP requested DCSP output DCSP element DCSP count DCSP for DCSP 'dataOut' DCSP on DCSP a DCSP RecordSensor DCSP node, DCSP but DCSP the DCSP encoder DCSP has DCSP not DCSP been DCSP set") DCNL DCSP  DCSP return self.encoder.getWidth() DCNL DCSP elif (name == 'sourceOut'): DCNL DCSP  DCSP if (self.encoder is None): DCNL DCSP  DCSP  DCSP raise Exception("NuPIC DCSP requested DCSP output DCSP element DCSP count DCSP for DCSP 'sourceOut' DCSP on DCSP a DCSP RecordSensor DCSP node, DCSP but DCSP the DCSP encoder DCSP has DCSP not DCSP been DCSP set") DCNL DCSP  DCSP return len(self.encoder.getDescription()) DCNL DCSP elif (name == 'bucketIdxOut'): DCNL DCSP  DCSP return 1 DCNL DCSP elif (name == 'actValueOut'): DCNL DCSP  DCSP return 1 DCNL DCSP elif (name == 'categoryOut'): DCNL DCSP  DCSP return self.numCategories DCNL DCSP elif ((name == 'spatialTopDownOut') or (name == 'temporalTopDownOut')): DCNL DCSP  DCSP if (self.encoder is None): DCNL DCSP  DCSP  DCSP raise Exception("NuPIC DCSP requested DCSP output DCSP element DCSP count DCSP for DCSP 'sourceOut' DCSP on DCSP a DCSP RecordSensor DCSP node, DCSP but DCSP the DCSP encoder DCSP has DCSP not DCSP been DCSP set") DCNL DCSP  DCSP return len(self.encoder.getDescription()) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unknown DCSP output DCSP %s' % name))
def setParameter(self, parameterName, index, parameterValue): DCNL DCSP if (parameterName == 'topDownMode'): DCNL DCSP  DCSP self.topDownMode = parameterValue DCNL DCSP elif (parameterName == 'predictedField'): DCNL DCSP  DCSP self.predictedField = parameterValue DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unknown DCSP parameter: DCSP ' + parameterName))
@staticmethod DCNL def getSchema(): DCNL DCSP return RecordSensorProto
def writeToProto(self, proto): DCNL DCSP self.encoder.write(proto.encoder) DCNL DCSP if (self.disabledEncoder is not None): DCNL DCSP  DCSP self.disabledEncoder.write(proto.disabledEncoder) DCNL DCSP proto.topDownMode = int(self.topDownMode) DCNL DCSP proto.verbosity = self.verbosity DCNL DCSP proto.numCategories = self.numCategories
@classmethod DCNL def readFromProto(cls, proto): DCNL DCSP instance = cls() DCNL DCSP instance.encoder = MultiEncoder.read(proto.encoder) DCNL DCSP if (proto.disabledEncoder is not None): DCNL DCSP  DCSP instance.disabledEncoder = MultiEncoder.read(proto.disabledEncoder) DCNL DCSP instance.topDownMode = bool(proto.topDownMode) DCNL DCSP instance.verbosity = proto.verbosity DCNL DCSP instance.numCategories = proto.numCategories DCNL DCSP return instance
def _initialize(self): DCNL DCSP for attrName in self._getEphemeralMembersBase(): DCNL DCSP  DCSP if (attrName != '_loaded'): DCNL DCSP  DCSP  DCSP if hasattr(self, attrName): DCNL DCSP  DCSP  DCSP  DCSP if self._loaded: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print self.__class__.__name__, ("contains DCSP base DCSP class DCSP member DCSP '%s'" % attrName) DCNL DCSP if (not self._loaded): DCNL DCSP  DCSP for attrName in self._getEphemeralMembersBase(): DCNL DCSP  DCSP  DCSP if (attrName != '_loaded'): DCNL DCSP  DCSP  DCSP  DCSP assert (not hasattr(self, attrName)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert hasattr(self, attrName) DCNL DCSP self._profileObj = None DCNL DCSP self._iterations = 0 DCNL DCSP self._initEphemerals() DCNL DCSP self._checkEphemeralMembers()
def initialize(self): DCNL DCSP autoArgs = dict(((name, getattr(self, name)) for name in self._temporalArgNames)) DCNL DCSP if (self._tfdr is None): DCNL DCSP  DCSP tpClass = _getTPClass(self.temporalImp) DCNL DCSP  DCSP if (self.temporalImp in ['py', 'cpp', 'r', 'tm_py', 'tm_cpp', 'monitored_tm_py']): DCNL DCSP  DCSP  DCSP self._tfdr = tpClass(numberOfCols=self.columnCount, cellsPerColumn=self.cellsPerColumn, **autoArgs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError('Invalid DCSP temporalImp')
def compute(self, inputs, outputs): DCNL DCSP if (False and self.learningMode and (self._iterations > 0) and (self._iterations <= 10)): DCNL DCSP  DCSP import hotshot DCNL DCSP  DCSP if (self._iterations == 10): DCNL DCSP  DCSP  DCSP print '\n DCSP  DCSP Collecting DCSP and DCSP sorting DCSP internal DCSP node DCSP profiling DCSP stats DCSP generated DCSP by DCSP hotshot...' DCNL DCSP  DCSP  DCSP stats = hotshot.stats.load('hotshot.stats') DCNL DCSP  DCSP  DCSP stats.strip_dirs() DCNL DCSP  DCSP  DCSP stats.sort_stats('time', 'calls') DCNL DCSP  DCSP  DCSP stats.print_stats() DCNL DCSP  DCSP if (self._profileObj is None): DCNL DCSP  DCSP  DCSP print '\n DCSP  DCSP Preparing DCSP to DCSP capture DCSP profile DCSP using DCSP hotshot...' DCNL DCSP  DCSP  DCSP if os.path.exists('hotshot.stats'): DCNL DCSP  DCSP  DCSP  DCSP os.remove('hotshot.stats') DCNL DCSP  DCSP  DCSP self._profileObj = hotshot.Profile('hotshot.stats', 1, 1) DCNL DCSP  DCSP self._profileObj.runcall(self._compute, *[inputs, outputs]) DCNL DCSP else: DCNL DCSP  DCSP self._compute(inputs, outputs)
def _compute(self, inputs, outputs): DCNL DCSP if (self._tfdr is None): DCNL DCSP  DCSP raise RuntimeError('TM DCSP has DCSP not DCSP been DCSP initialized') DCNL DCSP self._conditionalBreak() DCNL DCSP self._iterations += 1 DCNL DCSP buInputVector = inputs['bottomUpIn'] DCNL DCSP resetSignal = False DCNL DCSP if ('resetIn' in inputs): DCNL DCSP  DCSP assert (len(inputs['resetIn']) == 1) DCNL DCSP  DCSP if (inputs['resetIn'][0] != 0): DCNL DCSP  DCSP  DCSP self._tfdr.reset() DCNL DCSP  DCSP  DCSP self._sequencePos = 0 DCNL DCSP if self.computePredictedActiveCellIndices: DCNL DCSP  DCSP prevPredictedState = self._tfdr.getPredictedState().reshape((-1)).astype('float32') DCNL DCSP if self.anomalyMode: DCNL DCSP  DCSP prevPredictedColumns = self._tfdr.topDownCompute().copy().nonzero()[0] DCNL DCSP tpOutput = self._tfdr.compute(buInputVector, self.learningMode, self.inferenceMode) DCNL DCSP self._sequencePos += 1 DCNL DCSP if self.orColumnOutputs: DCNL DCSP  DCSP tpOutput = tpOutput.reshape(self.columnCount, self.cellsPerColumn).max(axis=1) DCNL DCSP if self._fpLogTPOutput: DCNL DCSP  DCSP output = tpOutput.reshape((-1)) DCNL DCSP  DCSP outputNZ = tpOutput.nonzero()[0] DCNL DCSP  DCSP outStr = ' DCSP '.join([('%d' % int(token)) for token in outputNZ]) DCNL DCSP  DCSP print >>self._fpLogTPOutput, output.size, outStr DCNL DCSP outputs['bottomUpOut'][:] = tpOutput.flat DCNL DCSP if self.topDownMode: DCNL DCSP  DCSP outputs['topDownOut'][:] = self._tfdr.topDownCompute().copy() DCNL DCSP if self.anomalyMode: DCNL DCSP  DCSP activeLearnCells = self._tfdr.getLearnActiveStateT() DCNL DCSP  DCSP size = (activeLearnCells.shape[0] * activeLearnCells.shape[1]) DCNL DCSP  DCSP outputs['lrnActiveStateT'][:] = activeLearnCells.reshape(size) DCNL DCSP  DCSP activeColumns = buInputVector.nonzero()[0] DCNL DCSP  DCSP outputs['anomalyScore'][:] = anomaly.computeRawAnomalyScore(activeColumns, prevPredictedColumns) DCNL DCSP if self.computePredictedActiveCellIndices: DCNL DCSP  DCSP activeState = self._tfdr._getActiveState().reshape((-1)).astype('float32') DCNL DCSP  DCSP activeIndices = numpy.where((activeState != 0))[0] DCNL DCSP  DCSP predictedIndices = numpy.where((prevPredictedState != 0))[0] DCNL DCSP  DCSP predictedActiveIndices = numpy.intersect1d(activeIndices, predictedIndices) DCNL DCSP  DCSP outputs['activeCells'].fill(0) DCNL DCSP  DCSP outputs['activeCells'][activeIndices] = 1 DCNL DCSP  DCSP outputs['predictedActiveCells'].fill(0) DCNL DCSP  DCSP outputs['predictedActiveCells'][predictedActiveIndices] = 1
@classmethod DCNL def getBaseSpec(cls): DCNL DCSP spec = dict(description=TMRegion.__doc__, singleNodeOnly=True, inputs=dict(bottomUpIn=dict(description='The DCSP input DCSP signal, DCSP conceptually DCSP organized DCSP as DCSP an\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image DCSP pyramid DCSP data DCSP structure, DCSP but DCSP internally\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP organized DCSP as DCSP a DCSP flattened DCSP vector.', dataType='Real32', count=0, required=True, regionLevel=False, isDefaultInput=True, requireSplitterMap=False), resetIn=dict(description='Effectively DCSP a DCSP boolean DCSP flag DCSP that DCSP indicates DCSP whether\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP or DCSP not DCSP the DCSP input DCSP vector DCSP received DCSP in DCSP this DCSP compute DCSP cycle\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP represents DCSP the DCSP first DCSP training DCSP presentation DCSP in DCSP a\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new DCSP temporal DCSP sequence.', dataType='Real32', count=1, required=False, regionLevel=True, isDefaultInput=False, requireSplitterMap=False), sequenceIdIn=dict(description='Sequence DCSP ID', dataType='UInt64', count=1, required=False, regionLevel=True, isDefaultInput=False, requireSplitterMap=False)), outputs=dict(bottomUpOut=dict(description='The DCSP output DCSP signal DCSP generated DCSP from DCSP the DCSP bottom-up DCSP inputs\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP lower DCSP levels.', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=True), topDownOut=dict(description='The DCSP top-down DCSP inputsignal, DCSP generated DCSP from\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP feedback DCSP from DCSP upper DCSP levels', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False), activeCells=dict(description='The DCSP cells DCSP that DCSP are DCSP active', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False), predictedActiveCells=dict(description='The DCSP cells DCSP that DCSP are DCSP active DCSP and DCSP predicted', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False), anomalyScore=dict(description="The DCSP score DCSP for DCSP how DCSP 'anomalous' DCSP (i.e. DCSP rare) DCSP the DCSP current\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sequence DCSP is. DCSP Higher DCSP values DCSP are DCSP increasingly DCSP rare", dataType='Real32', count=1, regionLevel=True, isDefaultOutput=False), lrnActiveStateT=dict(description='Active DCSP cells DCSP during DCSP learn DCSP phase DCSP at DCSP time DCSP t. DCSP  DCSP This DCSP is\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP used DCSP for DCSP anomaly DCSP classification.', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False)), parameters=dict(breakPdb=dict(description='Set DCSP to DCSP 1 DCSP to DCSP stop DCSP in DCSP the DCSP pdb DCSP debugger DCSP on DCSP the DCSP next DCSP compute', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='ReadWrite'), breakKomodo=dict(description='Set DCSP to DCSP 1 DCSP to DCSP stop DCSP in DCSP the DCSP Komodo DCSP debugger DCSP on DCSP the DCSP next DCSP compute', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='ReadWrite')), commands={}) DCNL DCSP return spec
@classmethod DCNL def getSpec(cls): DCNL DCSP spec = cls.getBaseSpec() DCNL DCSP (t, o) = _getAdditionalSpecs(temporalImp=gDefaultTemporalImp) DCNL DCSP spec['parameters'].update(t) DCNL DCSP spec['parameters'].update(o) DCNL DCSP return spec
def getAlgorithmInstance(self): DCNL DCSP return self._tfdr
def getParameter(self, parameterName, index=(-1)): DCNL DCSP if (parameterName in self._temporalArgNames): DCNL DCSP  DCSP return getattr(self._tfdr, parameterName) DCNL DCSP else: DCNL DCSP  DCSP return PyRegion.getParameter(self, parameterName, index)
def setParameter(self, parameterName, index, parameterValue): DCNL DCSP if (parameterName in self._temporalArgNames): DCNL DCSP  DCSP setattr(self._tfdr, parameterName, parameterValue) DCNL DCSP elif (parameterName == 'logPathOutput'): DCNL DCSP  DCSP self.logPathOutput = parameterValue DCNL DCSP  DCSP if (self._fpLogTPOutput is not None): DCNL DCSP  DCSP  DCSP self._fpLogTPOutput.close() DCNL DCSP  DCSP  DCSP self._fpLogTPOutput = None DCNL DCSP  DCSP if parameterValue: DCNL DCSP  DCSP  DCSP self._fpLogTPOutput = open(self.logPathOutput, 'w') DCNL DCSP elif hasattr(self, parameterName): DCNL DCSP  DCSP setattr(self, parameterName, parameterValue) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Unknown DCSP parameter: DCSP ' + parameterName))
def resetSequenceStates(self): DCNL DCSP self._tfdr.reset() DCNL DCSP self._sequencePos = 0 DCNL DCSP return
def finishLearning(self): DCNL DCSP if (self._tfdr is None): DCNL DCSP  DCSP raise RuntimeError('Temporal DCSP memory DCSP has DCSP not DCSP been DCSP initialized') DCNL DCSP if hasattr(self._tfdr, 'finishLearning'): DCNL DCSP  DCSP self.resetSequenceStates() DCNL DCSP  DCSP self._tfdr.finishLearning()
@staticmethod DCNL def getSchema(): DCNL DCSP return TMRegionProto
def writeToProto(self, proto): DCNL DCSP proto.temporalImp = self.temporalImp DCNL DCSP proto.columnCount = self.columnCount DCNL DCSP proto.inputWidth = self.inputWidth DCNL DCSP proto.cellsPerColumn = self.cellsPerColumn DCNL DCSP proto.learningMode = self.learningMode DCNL DCSP proto.inferenceMode = self.inferenceMode DCNL DCSP proto.anomalyMode = self.anomalyMode DCNL DCSP proto.topDownMode = self.topDownMode DCNL DCSP proto.computePredictedActiveCellIndices = self.computePredictedActiveCellIndices DCNL DCSP proto.orColumnOutputs = self.orColumnOutputs DCNL DCSP if (self.temporalImp == 'py'): DCNL DCSP  DCSP tmProto = proto.init('backtrackingTM') DCNL DCSP elif (self.temporalImp == 'cpp'): DCNL DCSP  DCSP tmProto = proto.init('backtrackingTMCpp') DCNL DCSP elif (self.temporalImp == 'tm_py'): DCNL DCSP  DCSP tmProto = proto.init('temporalMemory') DCNL DCSP elif (self.temporalImp == 'tm_cpp'): DCNL DCSP  DCSP tmProto = proto.init('temporalMemory') DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Unsupported DCSP temporalImp DCSP for DCSP capnp DCSP serialization: DCSP {}'.format(self.temporalImp)) DCNL DCSP self._tfdr.write(tmProto)
@classmethod DCNL def readFromProto(cls, proto): DCNL DCSP instance = cls(proto.columnCount, proto.inputWidth, proto.cellsPerColumn) DCNL DCSP instance.temporalImp = proto.temporalImp DCNL DCSP instance.learningMode = proto.learningMode DCNL DCSP instance.inferenceMode = proto.inferenceMode DCNL DCSP instance.anomalyMode = proto.anomalyMode DCNL DCSP instance.topDownMode = proto.topDownMode DCNL DCSP instance.computePredictedActiveCellIndices = proto.computePredictedActiveCellIndices DCNL DCSP instance.orColumnOutputs = proto.orColumnOutputs DCNL DCSP if (instance.temporalImp == 'py'): DCNL DCSP  DCSP tmProto = proto.backtrackingTM DCNL DCSP elif (instance.temporalImp == 'cpp'): DCNL DCSP  DCSP tmProto = proto.backtrackingTMCpp DCNL DCSP elif (instance.temporalImp == 'tm_py'): DCNL DCSP  DCSP tmProto = proto.temporalMemory DCNL DCSP elif (instance.temporalImp == 'tm_cpp'): DCNL DCSP  DCSP tmProto = proto.temporalMemory DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Unsupported DCSP temporalImp DCSP for DCSP capnp DCSP serialization: DCSP {}'.format(instance.temporalImp)) DCNL DCSP instance._tfdr = _getTPClass(proto.temporalImp).read(tmProto) DCNL DCSP return instance
def __getstate__(self): DCNL DCSP state = self.__dict__.copy() DCNL DCSP for ephemeralMemberName in self._getEphemeralMembersAll(): DCNL DCSP  DCSP state.pop(ephemeralMemberName, None) DCNL DCSP return state
def serializeExtraData(self, filePath): DCNL DCSP if (self._tfdr is not None): DCNL DCSP  DCSP self._tfdr.saveToFile(filePath)
def deSerializeExtraData(self, filePath): DCNL DCSP if (self._tfdr is not None): DCNL DCSP  DCSP self._tfdr.loadFromFile(filePath)
def __setstate__(self, state): DCNL DCSP if (not hasattr(self, 'storeDenseOutput')): DCNL DCSP  DCSP self.storeDenseOutput = False DCNL DCSP if (not hasattr(self, 'computePredictedActiveCellIndices')): DCNL DCSP  DCSP self.computePredictedActiveCellIndices = False DCNL DCSP self.__dict__.update(state) DCNL DCSP self._loaded = True DCNL DCSP self._initialize()
def _initEphemerals(self): DCNL DCSP self._sequencePos = 0 DCNL DCSP self._fpLogTPOutput = None DCNL DCSP self.logPathOutput = None
def _getEphemeralMembers(self): DCNL DCSP return ['_sequencePos', '_fpLogTPOutput', 'logPathOutput']
def _getEphemeralMembersBase(self): DCNL DCSP return ['_loaded', '_profileObj', '_iterations']
def _getEphemeralMembersAll(self): DCNL DCSP return (self._getEphemeralMembersBase() + self._getEphemeralMembers())
def getOutputElementCount(self, name): DCNL DCSP if (name == 'bottomUpOut'): DCNL DCSP  DCSP return self.outputWidth DCNL DCSP elif (name == 'topDownOut'): DCNL DCSP  DCSP return self.columnCount DCNL DCSP elif (name == 'lrnActiveStateT'): DCNL DCSP  DCSP return self.outputWidth DCNL DCSP elif (name == 'activeCells'): DCNL DCSP  DCSP return self.outputWidth DCNL DCSP elif (name == 'predictedActiveCells'): DCNL DCSP  DCSP return self.outputWidth DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Invalid DCSP output DCSP name DCSP specified')
def getParameterArrayCount(self, name, index): DCNL DCSP p = self.getParameter(name) DCNL DCSP if (not hasattr(p, '__len__')): DCNL DCSP  DCSP raise Exception(("Attempt DCSP to DCSP access DCSP parameter DCSP '%s' DCSP as DCSP an DCSP array DCSP but DCSP it DCSP is DCSP not DCSP an DCSP array" % name)) DCNL DCSP return len(p)
def getParameterArray(self, name, index, a): DCNL DCSP p = self.getParameter(name) DCNL DCSP if (not hasattr(p, '__len__')): DCNL DCSP  DCSP raise Exception(("Attempt DCSP to DCSP access DCSP parameter DCSP '%s' DCSP as DCSP an DCSP array DCSP but DCSP it DCSP is DCSP not DCSP an DCSP array" % name)) DCNL DCSP if (len(p) > 0): DCNL DCSP  DCSP a[:] = p[:]
@classmethod DCNL def getSpec(cls): DCNL DCSP ns = dict(description=SDRClassifierRegion.__doc__, singleNodeOnly=True, inputs=dict(actValueIn=dict(description='Actual DCSP value DCSP of DCSP the DCSP field DCSP to DCSP predict. DCSP Only DCSP taken DCSP into DCSP account DCSP if DCSP the DCSP input DCSP has DCSP no DCSP category DCSP field.', dataType='Real32', count=0, required=False, regionLevel=False, isDefaultInput=False, requireSplitterMap=False), bucketIdxIn=dict(description='Active DCSP index DCSP of DCSP the DCSP encoder DCSP bucket DCSP for DCSP the DCSP actual DCSP value DCSP of DCSP the DCSP field DCSP to DCSP predict. DCSP Only DCSP taken DCSP into DCSP account DCSP if DCSP the DCSP input DCSP has DCSP no DCSP category DCSP field.', dataType='UInt64', count=0, required=False, regionLevel=False, isDefaultInput=False, requireSplitterMap=False), categoryIn=dict(description='Vector DCSP of DCSP categories DCSP of DCSP the DCSP input DCSP sample', dataType='Real32', count=0, required=True, regionLevel=True, isDefaultInput=False, requireSplitterMap=False), bottomUpIn=dict(description="Belief DCSP values DCSP over DCSP children's DCSP groups", dataType='Real32', count=0, required=True, regionLevel=False, isDefaultInput=True, requireSplitterMap=False), predictedActiveCells=dict(description='The DCSP cells DCSP that DCSP are DCSP active DCSP and DCSP predicted', dataType='Real32', count=0, required=True, regionLevel=True, isDefaultInput=False, requireSplitterMap=False), sequenceIdIn=dict(description='Sequence DCSP ID', dataType='UInt64', count=1, required=False, regionLevel=True, isDefaultInput=False, requireSplitterMap=False)), outputs=dict(categoriesOut=dict(description='Classification DCSP results', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False, requireSplitterMap=False), actualValues=dict(description='Classification DCSP results', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False, requireSplitterMap=False), probabilities=dict(description='Classification DCSP results', dataType='Real32', count=0, regionLevel=True, isDefaultOutput=False, requireSplitterMap=False)), parameters=dict(learningMode=dict(description='Boolean DCSP (0/1) DCSP indicating DCSP whether DCSP or DCSP not DCSP a DCSP region DCSP is DCSP in DCSP learning DCSP mode.', dataType='UInt32', count=1, constraints='bool', defaultValue=1, accessMode='ReadWrite'), inferenceMode=dict(description='Boolean DCSP (0/1) DCSP indicating DCSP whether DCSP or DCSP not DCSP a DCSP region DCSP is DCSP in DCSP inference DCSP mode.', dataType='UInt32', count=1, constraints='bool', defaultValue=0, accessMode='ReadWrite'), maxCategoryCount=dict(description='The DCSP maximal DCSP number DCSP of DCSP categories DCSP the DCSP classifier DCSP will DCSP distinguish DCSP between.', dataType='UInt32', required=True, count=1, constraints='', defaultValue=2000, accessMode='Create'), steps=dict(description='Comma DCSP separated DCSP list DCSP of DCSP the DCSP desired DCSP steps DCSP of DCSP prediction DCSP that DCSP the DCSP classifier DCSP should DCSP learn', dataType='Byte', count=0, constraints='', defaultValue='0', accessMode='Create'), alpha=dict(description='The DCSP alpha DCSP is DCSP the DCSP learning DCSP rate DCSP of DCSP the DCSP classifier.lower DCSP alpha DCSP results DCSP in DCSP longer DCSP term DCSP memory DCSP and DCSP slower DCSP learning', dataType='Real32', count=1, constraints='', defaultValue=0.001, accessMode='Create'), implementation=dict(description='The DCSP classifier DCSP implementation DCSP to DCSP use.', accessMode='ReadWrite', dataType='Byte', count=0, constraints='enum: DCSP py, DCSP cpp'), verbosity=dict(description='An DCSP integer DCSP that DCSP controls DCSP the DCSP verbosity DCSP level, DCSP 0 DCSP means DCSP no DCSP verbose DCSP output, DCSP increasing DCSP integers DCSP provide DCSP more DCSP verbosity.', dataType='UInt32', count=1, constraints='', defaultValue=0, accessMode='ReadWrite')), commands=dict()) DCNL DCSP return ns
def initialize(self): DCNL DCSP if (self._sdrClassifier is None): DCNL DCSP  DCSP self._sdrClassifier = SDRClassifierFactory.create(steps=self.stepsList, alpha=self.alpha, verbosity=self.verbosity, implementation=self.implementation)
def getAlgorithmInstance(self): DCNL DCSP return self._sdrClassifier
def getParameter(self, name, index=(-1)): DCNL DCSP return PyRegion.getParameter(self, name, index)
def setParameter(self, name, index, value): DCNL DCSP if (name == 'learningMode'): DCNL DCSP  DCSP self.learningMode = bool(int(value)) DCNL DCSP elif (name == 'inferenceMode'): DCNL DCSP  DCSP self.inferenceMode = bool(int(value)) DCNL DCSP else: DCNL DCSP  DCSP return PyRegion.setParameter(self, name, index, value)
@staticmethod DCNL def getSchema(): DCNL DCSP return SDRClassifierRegionProto
def writeToProto(self, proto): DCNL DCSP proto.implementation = self.implementation DCNL DCSP proto.steps = self.steps DCNL DCSP proto.alpha = self.alpha DCNL DCSP proto.verbosity = self.verbosity DCNL DCSP proto.maxCategoryCount = self.maxCategoryCount DCNL DCSP self._sdrClassifier.write(proto.sdrClassifier)
@classmethod DCNL def readFromProto(cls, proto): DCNL DCSP instance = cls() DCNL DCSP instance.implementation = proto.implementation DCNL DCSP instance.steps = proto.steps DCNL DCSP instance.alpha = proto.alpha DCNL DCSP instance.verbosity = proto.verbosity DCNL DCSP instance.maxCategoryCount = proto.maxCategoryCount DCNL DCSP instance._sdrClassifier = SDRClassifierFactory.read(proto) DCNL DCSP return instance
def compute(self, inputs, outputs): DCNL DCSP self._computeFlag = True DCNL DCSP patternNZ = inputs['bottomUpIn'].nonzero()[0] DCNL DCSP if self.learningMode: DCNL DCSP  DCSP categories = [category for category in inputs['categoryIn'] if (category >= 0)] DCNL DCSP  DCSP if (len(categories) > 0): DCNL DCSP  DCSP  DCSP bucketIdxList = [] DCNL DCSP  DCSP  DCSP actValueList = [] DCNL DCSP  DCSP  DCSP for category in categories: DCNL DCSP  DCSP  DCSP  DCSP bucketIdxList.append(int(category)) DCNL DCSP  DCSP  DCSP  DCSP if ('actValueIn' not in inputs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP actValueList.append(int(category)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP actValueList.append(float(inputs['actValueIn'])) DCNL DCSP  DCSP  DCSP classificationIn = {'bucketIdx': bucketIdxList, 'actValue': actValueList} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if ('bucketIdxIn' not in inputs): DCNL DCSP  DCSP  DCSP  DCSP raise KeyError('Network DCSP link DCSP missing: DCSP bucketIdxOut DCSP -> DCSP bucketIdxIn') DCNL DCSP  DCSP  DCSP if ('actValueIn' not in inputs): DCNL DCSP  DCSP  DCSP  DCSP raise KeyError('Network DCSP link DCSP missing: DCSP actValueOut DCSP -> DCSP actValueIn') DCNL DCSP  DCSP  DCSP classificationIn = {'bucketIdx': int(inputs['bucketIdxIn']), 'actValue': float(inputs['actValueIn'])} DCNL DCSP else: DCNL DCSP  DCSP classificationIn = {'actValue': 0, 'bucketIdx': 0} DCNL DCSP clResults = self._sdrClassifier.compute(recordNum=self.recordNum, patternNZ=patternNZ, classification=classificationIn, learn=self.learningMode, infer=self.inferenceMode) DCNL DCSP if ((clResults is not None) and (len(clResults) > 0)): DCNL DCSP  DCSP outputs['actualValues'][:len(clResults['actualValues'])] = clResults['actualValues'] DCNL DCSP  DCSP for step in self.stepsList: DCNL DCSP  DCSP  DCSP stepIndex = self.stepsList.index(step) DCNL DCSP  DCSP  DCSP categoryOut = clResults['actualValues'][clResults[step].argmax()] DCNL DCSP  DCSP  DCSP outputs['categoriesOut'][stepIndex] = categoryOut DCNL DCSP  DCSP  DCSP stepProbabilities = clResults[step] DCNL DCSP  DCSP  DCSP for categoryIndex in xrange(self.maxCategoryCount): DCNL DCSP  DCSP  DCSP  DCSP flatIndex = (categoryIndex + (stepIndex * self.maxCategoryCount)) DCNL DCSP  DCSP  DCSP  DCSP if (categoryIndex < len(stepProbabilities)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP outputs['probabilities'][flatIndex] = stepProbabilities[categoryIndex] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP outputs['probabilities'][flatIndex] = 0.0 DCNL DCSP self.recordNum += 1
def customCompute(self, recordNum, patternNZ, classification): DCNL DCSP if (not hasattr(self, '_computeFlag')): DCNL DCSP  DCSP self._computeFlag = False DCNL DCSP if self._computeFlag: DCNL DCSP  DCSP warnings.simplefilter('error', DeprecationWarning) DCNL DCSP  DCSP warnings.warn('The DCSP customCompute() DCSP method DCSP should DCSP not DCSP be DCSP called DCSP at DCSP the DCSP same DCSP time DCSP as DCSP the DCSP compute() DCSP method. DCSP The DCSP compute() DCSP method DCSP is DCSP called DCSP whenever DCSP network.run() DCSP is DCSP called.', DeprecationWarning) DCNL DCSP return self._sdrClassifier.compute(recordNum, patternNZ, classification, self.learningMode, self.inferenceMode)
def getOutputElementCount(self, outputName): DCNL DCSP if (outputName == 'categoriesOut'): DCNL DCSP  DCSP return len(self.stepsList) DCNL DCSP elif (outputName == 'probabilities'): DCNL DCSP  DCSP return (len(self.stepsList) * self.maxCategoryCount) DCNL DCSP elif (outputName == 'actualValues'): DCNL DCSP  DCSP return self.maxCategoryCount DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unknown DCSP output DCSP {}.'.format(outputName))
@classmethod DCNL def getSpec(cls): DCNL DCSP ns = dict(description=KNNAnomalyClassifierRegion.__doc__, singleNodeOnly=True, inputs=dict(spBottomUpOut=dict(description='The DCSP output DCSP signal DCSP generated DCSP from DCSP the DCSP bottom-up DCSP inputs\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP lower DCSP levels.', dataType='Real32', count=0, required=True, regionLevel=False, isDefaultInput=True, requireSplitterMap=False), tpTopDownOut=dict(description='The DCSP top-down DCSP inputsignal, DCSP generated DCSP from\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP feedback DCSP from DCSP upper DCSP levels', dataType='Real32', count=0, required=True, regionLevel=False, isDefaultInput=True, requireSplitterMap=False), tpLrnActiveStateT=dict(description='Active DCSP cells DCSP in DCSP the DCSP learn DCSP state DCSP at DCSP time DCSP T DCSP from DCSP TM.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP This DCSP is DCSP used DCSP to DCSP classify DCSP on.', dataType='Real32', count=0, required=True, regionLevel=False, isDefaultInput=True, requireSplitterMap=False), sequenceIdIn=dict(description='Sequence DCSP ID', dataType='UInt64', count=1, required=False, regionLevel=True, isDefaultInput=False, requireSplitterMap=False)), outputs=dict(), parameters=dict(trainRecords=dict(description='Number DCSP of DCSP records DCSP to DCSP wait DCSP for DCSP training', dataType='UInt32', count=1, constraints='', defaultValue=0, accessMode='Create'), anomalyThreshold=dict(description='Threshold DCSP used DCSP to DCSP classify DCSP anomalies.', dataType='Real32', count=1, constraints='', defaultValue=0, accessMode='Create'), cacheSize=dict(description='Number DCSP of DCSP records DCSP to DCSP store DCSP in DCSP cache.', dataType='UInt32', count=1, constraints='', defaultValue=0, accessMode='Create'), classificationVectorType=dict(description='Vector DCSP type DCSP to DCSP use DCSP when DCSP classifying.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 1 DCSP - DCSP Vector DCSP Column DCSP with DCSP Difference DCSP (TM DCSP and DCSP SP)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ', dataType='UInt32', count=1, constraints='', defaultValue=1, accessMode='ReadWrite'), activeColumnCount=dict(description='Number DCSP of DCSP active DCSP columns DCSP in DCSP a DCSP given DCSP step. DCSP Typically\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP equivalent DCSP to DCSP SP.numActiveColumnsPerInhArea', dataType='UInt32', count=1, constraints='', defaultValue=40, accessMode='ReadWrite'), classificationMaxDist=dict(description='Maximum DCSP distance DCSP a DCSP sample DCSP can DCSP be DCSP from DCSP an DCSP anomaly\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in DCSP the DCSP classifier DCSP to DCSP be DCSP labeled DCSP as DCSP an DCSP anomaly.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Ex: DCSP With DCSP rawOverlap DCSP distance, DCSP a DCSP value DCSP of DCSP 0.65 DCSP means DCSP that DCSP the DCSP points\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP must DCSP be DCSP at DCSP most DCSP a DCSP distance DCSP 0.65 DCSP apart DCSP from DCSP each DCSP other. DCSP This\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP translates DCSP to DCSP they DCSP must DCSP be DCSP at DCSP least DCSP 35% DCSP similar.', dataType='Real32', count=1, constraints='', defaultValue=0.65, accessMode='Create')), commands=dict(getLabels=dict(description='Returns DCSP a DCSP list DCSP of DCSP label DCSP dicts DCSP with DCSP properties DCSP ROWID DCSP and DCSP labels.ROWID DCSP corresponds DCSP to DCSP the DCSP records DCSP id DCSP and DCSP labels DCSP is DCSP a DCSP list DCSP of DCSP strings DCSP representing DCSP the DCSP records DCSP labels. DCSP  DCSP Takes DCSP additional DCSP integer DCSP properties DCSP start DCSP and DCSP end DCSP representing DCSP the DCSP range DCSP that DCSP will DCSP be DCSP returned.'), addLabel=dict(description='Takes DCSP parameters DCSP start, DCSP end DCSP and DCSP labelName. DCSP Adds DCSP the DCSP label DCSP labelName DCSP to DCSP the DCSP records DCSP from DCSP start DCSP to DCSP end. DCSP This DCSP will DCSP recalculate DCSP labels DCSP from DCSP end DCSP to DCSP the DCSP most DCSP recent DCSP record.'), removeLabels=dict(description='Takes DCSP additional DCSP parameters DCSP start, DCSP end, DCSP labelFilter. DCSP  DCSP Start DCSP and DCSP end DCSP correspond DCSP to DCSP range DCSP to DCSP remove DCSP the DCSP label. DCSP Remove DCSP labels DCSP from DCSP each DCSP record DCSP with DCSP record DCSP ROWID DCSP in DCSP range DCSP from DCSP start DCSP to DCSP end, DCSP noninclusive DCSP of DCSP end. DCSP Removes DCSP all DCSP records DCSP if DCSP labelFilter DCSP is DCSP None, DCSP otherwise DCSP only DCSP removes DCSP the DCSP labels DCSP eqaul DCSP to DCSP labelFilter.'))) DCNL DCSP ns['parameters'].update(KNNClassifierRegion.getSpec()['parameters']) DCNL DCSP return ns
def getParameter(self, name, index=(-1)): DCNL DCSP if (name == 'trainRecords'): DCNL DCSP  DCSP return self.trainRecords DCNL DCSP elif (name == 'anomalyThreshold'): DCNL DCSP  DCSP return self.anomalyThreshold DCNL DCSP elif (name == 'activeColumnCount'): DCNL DCSP  DCSP return self._activeColumnCount DCNL DCSP elif (name == 'classificationMaxDist'): DCNL DCSP  DCSP return self._classificationMaxDist DCNL DCSP else: DCNL DCSP  DCSP return PyRegion.getParameter(self, name, index)
def setParameter(self, name, index, value): DCNL DCSP if (name == 'trainRecords'): DCNL DCSP  DCSP if (not (isinstance(value, float) or isinstance(value, int))): DCNL DCSP  DCSP  DCSP raise HTMPredictionModelInvalidArgument(("Invalid DCSP argument DCSP type DCSP '%s'. DCSP threshold DCSP must DCSP be DCSP a DCSP number." % type(value))) DCNL DCSP  DCSP if ((len(self._recordsCache) > 0) and (value < self._recordsCache[0].ROWID)): DCNL DCSP  DCSP  DCSP raise HTMPredictionModelInvalidArgument(('Invalid DCSP value. DCSP autoDetectWaitRecord DCSP value DCSP must DCSP be DCSP valid DCSP record DCSP within DCSP output DCSP stream. DCSP Current DCSP minimum DCSP  DCSP ROWID DCSP in DCSP output DCSP stream DCSP is DCSP %d.' % self._recordsCache[0].ROWID)) DCNL DCSP  DCSP self.trainRecords = value DCNL DCSP  DCSP self._deleteRangeFromKNN(0, self._recordsCache[0].ROWID) DCNL DCSP  DCSP self._classifyStates() DCNL DCSP elif (name == 'anomalyThreshold'): DCNL DCSP  DCSP if (not (isinstance(value, float) or isinstance(value, int))): DCNL DCSP  DCSP  DCSP raise HTMPredictionModelInvalidArgument(("Invalid DCSP argument DCSP type DCSP '%s'. DCSP threshold DCSP must DCSP be DCSP a DCSP number." % type(value))) DCNL DCSP  DCSP self.anomalyThreshold = value DCNL DCSP  DCSP self._classifyStates() DCNL DCSP elif (name == 'classificationMaxDist'): DCNL DCSP  DCSP if (not (isinstance(value, float) or isinstance(value, int))): DCNL DCSP  DCSP  DCSP raise HTMPredictionModelInvalidArgument(("Invalid DCSP argument DCSP type DCSP '%s'. DCSP classificationMaxDist DCSP must DCSP be DCSP a DCSP number." % type(value))) DCNL DCSP  DCSP self._classificationMaxDist = value DCNL DCSP  DCSP self._classifyStates() DCNL DCSP elif (name == 'activeColumnCount'): DCNL DCSP  DCSP self._activeColumnCount = value DCNL DCSP else: DCNL DCSP  DCSP return PyRegion.setParameter(self, name, index, value)
def compute(self, inputs, outputs): DCNL DCSP record = self._constructClassificationRecord(inputs) DCNL DCSP if (record.ROWID >= self.getParameter('trainRecords')): DCNL DCSP  DCSP self._classifyState(record) DCNL DCSP self._recordsCache.append(record) DCNL DCSP while (len(self._recordsCache) > self.cacheSize): DCNL DCSP  DCSP self._recordsCache.pop(0) DCNL DCSP self.labelResults = record.anomalyLabel DCNL DCSP self._iteration += 1
def getLabelResults(self): DCNL DCSP return self.labelResults
def _classifyStates(self): DCNL DCSP for state in self._recordsCache: DCNL DCSP  DCSP self._classifyState(state)
def _classifyState(self, state): DCNL DCSP if (state.ROWID < self.getParameter('trainRecords')): DCNL DCSP  DCSP if (not state.setByUser): DCNL DCSP  DCSP  DCSP state.anomalyLabel = [] DCNL DCSP  DCSP  DCSP self._deleteRecordsFromKNN([state]) DCNL DCSP  DCSP return DCNL DCSP label = KNNAnomalyClassifierRegion.AUTO_THRESHOLD_CLASSIFIED_LABEL DCNL DCSP autoLabel = (label + KNNAnomalyClassifierRegion.AUTO_TAG) DCNL DCSP newCategory = self._recomputeRecordFromKNN(state) DCNL DCSP labelList = self._categoryToLabelList(newCategory) DCNL DCSP if state.setByUser: DCNL DCSP  DCSP if (label in state.anomalyLabel): DCNL DCSP  DCSP  DCSP state.anomalyLabel.remove(label) DCNL DCSP  DCSP if (autoLabel in state.anomalyLabel): DCNL DCSP  DCSP  DCSP state.anomalyLabel.remove(autoLabel) DCNL DCSP  DCSP labelList.extend(state.anomalyLabel) DCNL DCSP if (state.anomalyScore >= self.getParameter('anomalyThreshold')): DCNL DCSP  DCSP labelList.append(label) DCNL DCSP elif (label in labelList): DCNL DCSP  DCSP ind = labelList.index(label) DCNL DCSP  DCSP labelList[ind] = autoLabel DCNL DCSP labelList = list(set(labelList)) DCNL DCSP if ((label in labelList) and (autoLabel in labelList)): DCNL DCSP  DCSP labelList.remove(autoLabel) DCNL DCSP if (state.anomalyLabel == labelList): DCNL DCSP  DCSP return DCNL DCSP state.anomalyLabel = labelList DCNL DCSP if (state.anomalyLabel == []): DCNL DCSP  DCSP self._deleteRecordsFromKNN([state]) DCNL DCSP else: DCNL DCSP  DCSP self._addRecordToKNN(state)
def _constructClassificationRecord(self, inputs): DCNL DCSP allSPColumns = inputs['spBottomUpOut'] DCNL DCSP activeSPColumns = allSPColumns.nonzero()[0] DCNL DCSP score = anomaly.computeRawAnomalyScore(activeSPColumns, self._prevPredictedColumns) DCNL DCSP spSize = len(allSPColumns) DCNL DCSP allTPCells = inputs['tpTopDownOut'] DCNL DCSP tpSize = len(inputs['tpLrnActiveStateT']) DCNL DCSP classificationVector = numpy.array([]) DCNL DCSP if (self.classificationVectorType == 1): DCNL DCSP  DCSP classificationVector = numpy.zeros(tpSize) DCNL DCSP  DCSP activeCellMatrix = inputs['tpLrnActiveStateT'].reshape(tpSize, 1) DCNL DCSP  DCSP activeCellIdx = numpy.where((activeCellMatrix > 0))[0] DCNL DCSP  DCSP if (activeCellIdx.shape[0] > 0): DCNL DCSP  DCSP  DCSP classificationVector[numpy.array(activeCellIdx, dtype=numpy.uint16)] = 1 DCNL DCSP elif (self.classificationVectorType == 2): DCNL DCSP  DCSP classificationVector = numpy.zeros((spSize + spSize)) DCNL DCSP  DCSP if (activeSPColumns.shape[0] > 0): DCNL DCSP  DCSP  DCSP classificationVector[activeSPColumns] = 1.0 DCNL DCSP  DCSP errorColumns = numpy.setdiff1d(self._prevPredictedColumns, activeSPColumns) DCNL DCSP  DCSP if (errorColumns.shape[0] > 0): DCNL DCSP  DCSP  DCSP errorColumnIndexes = (numpy.array(errorColumns, dtype=numpy.uint16) + spSize) DCNL DCSP  DCSP  DCSP classificationVector[errorColumnIndexes] = 1.0 DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(("Classification DCSP vector DCSP type DCSP must DCSP be DCSP either DCSP 'tpc' DCSP or DCSP 'sp_tpe', DCSP current DCSP value DCSP is DCSP %s" % self.classificationVectorType)) DCNL DCSP numPredictedCols = len(self._prevPredictedColumns) DCNL DCSP predictedColumns = allTPCells.nonzero()[0] DCNL DCSP self._prevPredictedColumns = copy.deepcopy(predictedColumns) DCNL DCSP if (self._anomalyVectorLength is None): DCNL DCSP  DCSP self._anomalyVectorLength = len(classificationVector) DCNL DCSP result = _CLAClassificationRecord(ROWID=self._iteration, anomalyScore=score, anomalyVector=classificationVector.nonzero()[0].tolist(), anomalyLabel=[]) DCNL DCSP return result
def _addRecordToKNN(self, record): DCNL DCSP knn = self._knnclassifier._knn DCNL DCSP prototype_idx = self._knnclassifier.getParameter('categoryRecencyList') DCNL DCSP category = self._labelListToCategoryNumber(record.anomalyLabel) DCNL DCSP if (record.ROWID in prototype_idx): DCNL DCSP  DCSP knn.prototypeSetCategory(record.ROWID, category) DCNL DCSP  DCSP return DCNL DCSP pattern = self._getStateAnomalyVector(record) DCNL DCSP rowID = record.ROWID DCNL DCSP knn.learn(pattern, category, rowID=rowID)
def _deleteRecordsFromKNN(self, recordsToDelete): DCNL DCSP prototype_idx = self._knnclassifier.getParameter('categoryRecencyList') DCNL DCSP idsToDelete = [r.ROWID for r in recordsToDelete if ((not r.setByUser) and (r.ROWID in prototype_idx))] DCNL DCSP nProtos = self._knnclassifier._knn._numPatterns DCNL DCSP self._knnclassifier._knn.removeIds(idsToDelete) DCNL DCSP assert (self._knnclassifier._knn._numPatterns == (nProtos - len(idsToDelete)))
def _deleteRangeFromKNN(self, start=0, end=None): DCNL DCSP prototype_idx = numpy.array(self._knnclassifier.getParameter('categoryRecencyList')) DCNL DCSP if (end is None): DCNL DCSP  DCSP end = (prototype_idx.max() + 1) DCNL DCSP idsIdxToDelete = numpy.logical_and((prototype_idx >= start), (prototype_idx < end)) DCNL DCSP idsToDelete = prototype_idx[idsIdxToDelete] DCNL DCSP nProtos = self._knnclassifier._knn._numPatterns DCNL DCSP self._knnclassifier._knn.removeIds(idsToDelete.tolist()) DCNL DCSP assert (self._knnclassifier._knn._numPatterns == (nProtos - len(idsToDelete)))
def _recomputeRecordFromKNN(self, record): DCNL DCSP inputs = {'categoryIn': [None], 'bottomUpIn': self._getStateAnomalyVector(record)} DCNL DCSP outputs = {'categoriesOut': numpy.zeros((1,)), 'bestPrototypeIndices': numpy.zeros((1,)), 'categoryProbabilitiesOut': numpy.zeros((1,))} DCNL DCSP classifier_indexes = numpy.array(self._knnclassifier.getParameter('categoryRecencyList')) DCNL DCSP valid_idx = numpy.where(((classifier_indexes >= self.getParameter('trainRecords')) & (classifier_indexes < record.ROWID)))[0].tolist() DCNL DCSP if (len(valid_idx) == 0): DCNL DCSP  DCSP return None DCNL DCSP self._knnclassifier.setParameter('inferenceMode', None, True) DCNL DCSP self._knnclassifier.setParameter('learningMode', None, False) DCNL DCSP self._knnclassifier.compute(inputs, outputs) DCNL DCSP self._knnclassifier.setParameter('learningMode', None, True) DCNL DCSP classifier_distances = self._knnclassifier.getLatestDistances() DCNL DCSP valid_distances = classifier_distances[valid_idx] DCNL DCSP if (valid_distances.min() <= self._classificationMaxDist): DCNL DCSP  DCSP classifier_indexes_prev = classifier_indexes[valid_idx] DCNL DCSP  DCSP rowID = classifier_indexes_prev[valid_distances.argmin()] DCNL DCSP  DCSP indexID = numpy.where((classifier_indexes == rowID))[0][0] DCNL DCSP  DCSP category = self._knnclassifier.getCategoryList()[indexID] DCNL DCSP  DCSP return category DCNL DCSP return None
def _labelToCategoryNumber(self, label): DCNL DCSP if (label not in self.saved_categories): DCNL DCSP  DCSP self.saved_categories.append(label) DCNL DCSP return pow(2, self.saved_categories.index(label))
def _labelListToCategoryNumber(self, labelList): DCNL DCSP categoryNumber = 0 DCNL DCSP for label in labelList: DCNL DCSP  DCSP categoryNumber += self._labelToCategoryNumber(label) DCNL DCSP return categoryNumber
def _categoryToLabelList(self, category): DCNL DCSP if (category is None): DCNL DCSP  DCSP return [] DCNL DCSP labelList = [] DCNL DCSP labelNum = 0 DCNL DCSP while (category > 0): DCNL DCSP  DCSP if ((category % 2) == 1): DCNL DCSP  DCSP  DCSP labelList.append(self.saved_categories[labelNum]) DCNL DCSP  DCSP labelNum += 1 DCNL DCSP  DCSP category = (category >> 1) DCNL DCSP return labelList
def _getStateAnomalyVector(self, state): DCNL DCSP vector = numpy.zeros(self._anomalyVectorLength) DCNL DCSP vector[state.anomalyVector] = 1 DCNL DCSP return vector
def getLabels(self, start=None, end=None): DCNL DCSP if (len(self._recordsCache) == 0): DCNL DCSP  DCSP return {'isProcessing': False, 'recordLabels': []} DCNL DCSP try: DCNL DCSP  DCSP start = int(start) DCNL DCSP except Exception: DCNL DCSP  DCSP start = 0 DCNL DCSP try: DCNL DCSP  DCSP end = int(end) DCNL DCSP except Exception: DCNL DCSP  DCSP end = self._recordsCache[(-1)].ROWID DCNL DCSP if (end <= start): DCNL DCSP  DCSP raise HTMPredictionModelInvalidRangeError("Invalid DCSP supplied DCSP range DCSP for DCSP 'getLabels'.", debugInfo={'requestRange': {'startRecordID': start, 'endRecordID': end}, 'numRecordsStored': len(self._recordsCache)}) DCNL DCSP results = {'isProcessing': False, 'recordLabels': []} DCNL DCSP ROWIDX = numpy.array(self._knnclassifier.getParameter('categoryRecencyList')) DCNL DCSP validIdx = numpy.where(((ROWIDX >= start) & (ROWIDX < end)))[0].tolist() DCNL DCSP categories = self._knnclassifier.getCategoryList() DCNL DCSP for idx in validIdx: DCNL DCSP  DCSP row = dict(ROWID=int(ROWIDX[idx]), labels=self._categoryToLabelList(categories[idx])) DCNL DCSP  DCSP results['recordLabels'].append(row) DCNL DCSP return results
def addLabel(self, start, end, labelName): DCNL DCSP if (len(self._recordsCache) == 0): DCNL DCSP  DCSP raise HTMPredictionModelInvalidRangeError("Invalid DCSP supplied DCSP range DCSP for DCSP 'addLabel'. DCSP Model DCSP has DCSP no DCSP saved DCSP records.") DCNL DCSP try: DCNL DCSP  DCSP start = int(start) DCNL DCSP except Exception: DCNL DCSP  DCSP start = 0 DCNL DCSP try: DCNL DCSP  DCSP end = int(end) DCNL DCSP except Exception: DCNL DCSP  DCSP end = int(self._recordsCache[(-1)].ROWID) DCNL DCSP startID = self._recordsCache[0].ROWID DCNL DCSP clippedStart = max(0, (start - startID)) DCNL DCSP clippedEnd = max(0, min(len(self._recordsCache), (end - startID))) DCNL DCSP if (clippedEnd <= clippedStart): DCNL DCSP  DCSP raise HTMPredictionModelInvalidRangeError("Invalid DCSP supplied DCSP range DCSP for DCSP 'addLabel'.", debugInfo={'requestRange': {'startRecordID': start, 'endRecordID': end}, 'clippedRequestRange': {'startRecordID': clippedStart, 'endRecordID': clippedEnd}, 'validRange': {'startRecordID': startID, 'endRecordID': self._recordsCache[(len(self._recordsCache) - 1)].ROWID}, 'numRecordsStored': len(self._recordsCache)}) DCNL DCSP for state in self._recordsCache[clippedStart:clippedEnd]: DCNL DCSP  DCSP if (labelName not in state.anomalyLabel): DCNL DCSP  DCSP  DCSP state.anomalyLabel.append(labelName) DCNL DCSP  DCSP  DCSP state.setByUser = True DCNL DCSP  DCSP  DCSP self._addRecordToKNN(state) DCNL DCSP assert (len(self.saved_categories) > 0) DCNL DCSP for state in self._recordsCache[clippedEnd:]: DCNL DCSP  DCSP self._classifyState(state)
def removeLabels(self, start=None, end=None, labelFilter=None): DCNL DCSP if (len(self._recordsCache) == 0): DCNL DCSP  DCSP raise HTMPredictionModelInvalidRangeError("Invalid DCSP supplied DCSP range DCSP for DCSP 'removeLabels'. DCSP Model DCSP has DCSP no DCSP saved DCSP records.") DCNL DCSP try: DCNL DCSP  DCSP start = int(start) DCNL DCSP except Exception: DCNL DCSP  DCSP start = 0 DCNL DCSP try: DCNL DCSP  DCSP end = int(end) DCNL DCSP except Exception: DCNL DCSP  DCSP end = self._recordsCache[(-1)].ROWID DCNL DCSP startID = self._recordsCache[0].ROWID DCNL DCSP clippedStart = (0 if (start is None) else max(0, (start - startID))) DCNL DCSP clippedEnd = (len(self._recordsCache) if (end is None) else max(0, min(len(self._recordsCache), (end - startID)))) DCNL DCSP if (clippedEnd <= clippedStart): DCNL DCSP  DCSP raise HTMPredictionModelInvalidRangeError("Invalid DCSP supplied DCSP range DCSP for DCSP 'removeLabels'.", debugInfo={'requestRange': {'startRecordID': start, 'endRecordID': end}, 'clippedRequestRange': {'startRecordID': clippedStart, 'endRecordID': clippedEnd}, 'validRange': {'startRecordID': startID, 'endRecordID': self._recordsCache[(len(self._recordsCache) - 1)].ROWID}, 'numRecordsStored': len(self._recordsCache)}) DCNL DCSP recordsToDelete = [] DCNL DCSP for state in self._recordsCache[clippedStart:clippedEnd]: DCNL DCSP  DCSP if (labelFilter is not None): DCNL DCSP  DCSP  DCSP if (labelFilter in state.anomalyLabel): DCNL DCSP  DCSP  DCSP  DCSP state.anomalyLabel.remove(labelFilter) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP state.anomalyLabel = [] DCNL DCSP  DCSP state.setByUser = False DCNL DCSP  DCSP recordsToDelete.append(state) DCNL DCSP self._deleteRecordsFromKNN(recordsToDelete) DCNL DCSP self._deleteRangeFromKNN(start, end) DCNL DCSP for state in self._recordsCache[clippedEnd:]: DCNL DCSP  DCSP self._classifyState(state)
def __getstate__(self): DCNL DCSP state = self.__dict__.copy() DCNL DCSP state['_knnclassifierProps'] = state['_knnclassifier'].__getstate__() DCNL DCSP state.pop('_knnclassifier') DCNL DCSP return state
def __setstate__(self, state): DCNL DCSP if (('_version' not in state) or (state['_version'] == 1)): DCNL DCSP  DCSP knnclassifierProps = state.pop('_knnclassifierProps') DCNL DCSP  DCSP self.__dict__.update(state) DCNL DCSP  DCSP self._knnclassifier = KNNClassifierRegion(**self._knnclassifierArgs) DCNL DCSP  DCSP self._knnclassifier.__setstate__(knnclassifierProps) DCNL DCSP  DCSP self._version = KNNAnomalyClassifierRegion.__VERSION__ DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Invalid DCSP KNNAnomalyClassifierRegion DCSP version. DCSP Current DCSP version: DCSP %s' % KNNAnomalyClassifierRegion.__VERSION__))
def getOutputElementCount(self, name): DCNL DCSP if (name == 'labels'): DCNL DCSP  DCSP return self._maxLabelOutputs DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Invalid DCSP output DCSP name DCSP specified')
def getSensedValue(self): DCNL DCSP return self._sensedValue
def setSensedValue(self, value): DCNL DCSP self._sensedValue = value
@classmethod DCNL def dbNamePrefix(cls): DCNL DCSP return cls.__getDBNamePrefixForVersion(cls._DB_VERSION)
@classmethod DCNL def __getDBNamePrefixForVersion(cls, dbVersion): DCNL DCSP return ('%s_v%d' % (cls._DB_ROOT_NAME, dbVersion))
@classmethod DCNL def _getDBName(cls): DCNL DCSP return cls.__getDBNameForVersion(cls._DB_VERSION)
@classmethod DCNL def __getDBNameForVersion(cls, dbVersion): DCNL DCSP prefix = cls.__getDBNamePrefixForVersion(dbVersion) DCNL DCSP suffix = Configuration.get('nupic.cluster.database.nameSuffix') DCNL DCSP suffix = suffix.replace('-', '_') DCNL DCSP suffix = suffix.replace('.', '_') DCNL DCSP dbName = ('%s_%s' % (prefix, suffix)) DCNL DCSP return dbName
@staticmethod DCNL @logExceptions(_LOGGER) DCNL def get(): DCNL DCSP if (ClientJobsDAO._instance is None): DCNL DCSP  DCSP cjDAO = ClientJobsDAO() DCNL DCSP  DCSP cjDAO.connect() DCNL DCSP  DCSP ClientJobsDAO._instance = cjDAO DCNL DCSP return ClientJobsDAO._instance
@logExceptions(_LOGGER) DCNL def __init__(self): DCNL DCSP self._logger = _LOGGER DCNL DCSP assert (ClientJobsDAO._instance is None) DCNL DCSP self.dbName = self._getDBName() DCNL DCSP self._jobs = self._JobsTableInfo() DCNL DCSP self._jobs.tableName = ('%s.jobs' % self.dbName) DCNL DCSP self._models = self._ModelsTableInfo() DCNL DCSP self._models.tableName = ('%s.models' % self.dbName) DCNL DCSP self._connectionID = None
def _columnNameDBToPublic(self, dbName): DCNL DCSP words = dbName.split('_') DCNL DCSP if dbName.startswith('_'): DCNL DCSP  DCSP words = words[1:] DCNL DCSP pubWords = [words[0]] DCNL DCSP for word in words[1:]: DCNL DCSP  DCSP pubWords.append((word[0].upper() + word[1:])) DCNL DCSP return ''.join(pubWords)
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def connect(self, deleteOldVersions=False, recreate=False): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP self._initTables(cursor=conn.cursor, deleteOldVersions=deleteOldVersions, recreate=recreate) DCNL DCSP  DCSP conn.cursor.execute('SELECT DCSP CONNECTION_ID()') DCNL DCSP  DCSP self._connectionID = conn.cursor.fetchall()[0][0] DCNL DCSP  DCSP self._logger.info('clientJobsConnectionID=%r', self._connectionID) DCNL DCSP return
@logExceptions(_LOGGER) DCNL def _initTables(self, cursor, deleteOldVersions, recreate): DCNL DCSP if deleteOldVersions: DCNL DCSP  DCSP self._logger.info('Dropping DCSP old DCSP versions DCSP of DCSP client_jobs DCSP DB; DCSP called DCSP from: DCSP %r', traceback.format_stack()) DCNL DCSP  DCSP for i in range(self._DB_VERSION): DCNL DCSP  DCSP  DCSP cursor.execute(('DROP DCSP DATABASE DCSP IF DCSP EXISTS DCSP %s' % (self.__getDBNameForVersion(i),))) DCNL DCSP if recreate: DCNL DCSP  DCSP self._logger.info('Dropping DCSP client_jobs DCSP DB DCSP %r; DCSP called DCSP from: DCSP %r', self.dbName, traceback.format_stack()) DCNL DCSP  DCSP cursor.execute(('DROP DCSP DATABASE DCSP IF DCSP EXISTS DCSP %s' % self.dbName)) DCNL DCSP cursor.execute(('CREATE DCSP DATABASE DCSP IF DCSP NOT DCSP EXISTS DCSP %s' % self.dbName)) DCNL DCSP cursor.execute(('SHOW DCSP TABLES DCSP IN DCSP %s' % self.dbName)) DCNL DCSP output = cursor.fetchall() DCNL DCSP tableNames = [x[0] for x in output] DCNL DCSP if ('jobs' not in tableNames): DCNL DCSP  DCSP self._logger.info('Creating DCSP table DCSP %r', self.jobsTableName) DCNL DCSP  DCSP fields = ['job_id DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP UNSIGNED DCSP NOT DCSP NULL DCSP AUTO_INCREMENT', ('client DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHAR(%d)' % self.CLIENT_MAX_LEN), 'client_info DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', 'client_key DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP varchar(255)', 'cmd_line DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', 'params DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', ('job_hash DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP BINARY(%d) DCSP DEFAULT DCSP NULL' % self.HASH_MAX_LEN), 'status DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VARCHAR(16) DCSP DEFAULT DCSP "notStarted"', 'completion_reason DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VARCHAR(16)', 'completion_msg DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', ('worker_completion_reason DCSP  DCSP  DCSP VARCHAR(16) DCSP DEFAULT DCSP "%s"' % self.CMPL_REASON_SUCCESS), 'worker_completion_msg DCSP  DCSP  DCSP LONGTEXT', 'cancel DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP BOOLEAN DCSP DEFAULT DCSP FALSE', 'start_time DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP DATETIME DCSP DEFAULT DCSP NULL', 'end_time DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP DATETIME DCSP DEFAULT DCSP NULL', 'results DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', '_eng_job_type DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VARCHAR(32)', 'minimum_workers DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP UNSIGNED DCSP DEFAULT DCSP 0', 'maximum_workers DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP UNSIGNED DCSP DEFAULT DCSP 0', ('priority DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP DEFAULT DCSP %d' % self.DEFAULT_JOB_PRIORITY), '_eng_allocate_new_workers DCSP  DCSP  DCSP  DCSP BOOLEAN DCSP DEFAULT DCSP TRUE', '_eng_untended_dead_workers DCSP  DCSP  DCSP BOOLEAN DCSP DEFAULT DCSP FALSE', 'num_failed_workers DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP UNSIGNED DCSP DEFAULT DCSP 0', 'last_failed_worker_error_msg DCSP  DCSP LONGTEXT', ('_eng_cleaning_status DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VARCHAR(16) DCSP DEFAULT DCSP "%s"' % self.CLEAN_NOT_DONE), 'gen_base_description DCSP  DCSP  DCSP  DCSP LONGTEXT', 'gen_permutations DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', '_eng_last_update_time DCSP  DCSP  DCSP DATETIME DCSP DEFAULT DCSP NULL', '_eng_cjm_conn_id DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP UNSIGNED', '_eng_worker_state DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', '_eng_status DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', '_eng_model_milestones DCSP  DCSP  DCSP LONGTEXT', 'PRIMARY DCSP KEY DCSP (job_id)', 'UNIQUE DCSP INDEX DCSP (client, DCSP job_hash)', 'INDEX DCSP (status)', 'INDEX DCSP (client_key)'] DCNL DCSP  DCSP options = ['AUTO_INCREMENT=1000'] DCNL DCSP  DCSP query = ('CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP %s DCSP (%s) DCSP %s' % (self.jobsTableName, ','.join(fields), ','.join(options))) DCNL DCSP  DCSP cursor.execute(query) DCNL DCSP if ('models' not in tableNames): DCNL DCSP  DCSP self._logger.info('Creating DCSP table DCSP %r', self.modelsTableName) DCNL DCSP  DCSP fields = ['model_id DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP BIGINT DCSP UNSIGNED DCSP NOT DCSP NULL DCSP AUTO_INCREMENT', 'job_id DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP UNSIGNED DCSP NOT DCSP NULL', 'params DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT DCSP NOT DCSP NULL', 'status DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VARCHAR(16) DCSP DEFAULT DCSP "notStarted"', 'completion_reason DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VARCHAR(16)', 'completion_msg DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', 'results DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT DCSP DEFAULT DCSP NULL', 'optimized_metric DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FLOAT DCSP ', 'update_counter DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP UNSIGNED DCSP DEFAULT DCSP 0', 'num_records DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP UNSIGNED DCSP DEFAULT DCSP 0', 'start_time DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP DATETIME DCSP DEFAULT DCSP NULL', 'end_time DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP DATETIME DCSP DEFAULT DCSP NULL', 'cpu_time DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FLOAT DCSP DEFAULT DCSP 0', 'model_checkpoint_id DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', 'gen_description DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', ('_eng_params_hash DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP BINARY(%d) DCSP DEFAULT DCSP NULL' % self.HASH_MAX_LEN), ('_eng_particle_hash DCSP  DCSP  DCSP  DCSP  DCSP  DCSP BINARY(%d) DCSP DEFAULT DCSP NULL' % self.HASH_MAX_LEN), '_eng_last_update_time DCSP  DCSP  DCSP DATETIME DCSP DEFAULT DCSP NULL', '_eng_task_tracker_id DCSP  DCSP  DCSP  DCSP TINYBLOB', '_eng_worker_id DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TINYBLOB', '_eng_attempt_id DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TINYBLOB', '_eng_worker_conn_id DCSP  DCSP  DCSP  DCSP  DCSP INT DCSP DEFAULT DCSP 0', '_eng_milestones DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LONGTEXT', '_eng_stop DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VARCHAR(16) DCSP DEFAULT DCSP NULL', '_eng_matured DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP BOOLEAN DCSP DEFAULT DCSP FALSE', 'PRIMARY DCSP KEY DCSP (model_id)', 'UNIQUE DCSP INDEX DCSP (job_id, DCSP _eng_params_hash)', 'UNIQUE DCSP INDEX DCSP (job_id, DCSP _eng_particle_hash)'] DCNL DCSP  DCSP options = ['AUTO_INCREMENT=1000'] DCNL DCSP  DCSP query = ('CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP %s DCSP (%s) DCSP %s' % (self.modelsTableName, ','.join(fields), ','.join(options))) DCNL DCSP  DCSP cursor.execute(query) DCNL DCSP cursor.execute(('DESCRIBE DCSP %s' % self.jobsTableName)) DCNL DCSP fields = cursor.fetchall() DCNL DCSP self._jobs.dbFieldNames = [str(field[0]) for field in fields] DCNL DCSP cursor.execute(('DESCRIBE DCSP %s' % self.modelsTableName)) DCNL DCSP fields = cursor.fetchall() DCNL DCSP self._models.dbFieldNames = [str(field[0]) for field in fields] DCNL DCSP self._jobs.publicFieldNames = [self._columnNameDBToPublic(x) for x in self._jobs.dbFieldNames] DCNL DCSP self._models.publicFieldNames = [self._columnNameDBToPublic(x) for x in self._models.dbFieldNames] DCNL DCSP self._jobs.pubToDBNameDict = dict(zip(self._jobs.publicFieldNames, self._jobs.dbFieldNames)) DCNL DCSP self._jobs.dbToPubNameDict = dict(zip(self._jobs.dbFieldNames, self._jobs.publicFieldNames)) DCNL DCSP self._models.pubToDBNameDict = dict(zip(self._models.publicFieldNames, self._models.dbFieldNames)) DCNL DCSP self._models.dbToPubNameDict = dict(zip(self._models.dbFieldNames, self._models.publicFieldNames)) DCNL DCSP self._models.modelInfoNamedTuple = collections.namedtuple('_modelInfoNamedTuple', self._models.publicFieldNames) DCNL DCSP self._jobs.jobInfoNamedTuple = collections.namedtuple('_jobInfoNamedTuple', self._jobs.publicFieldNames) DCNL DCSP return
def _getMatchingRowsNoRetries(self, tableInfo, conn, fieldsToMatch, selectFieldNames, maxRows=None): DCNL DCSP assert fieldsToMatch, repr(fieldsToMatch) DCNL DCSP assert all(((k in tableInfo.dbFieldNames) for k in fieldsToMatch.iterkeys())), repr(fieldsToMatch) DCNL DCSP assert selectFieldNames, repr(selectFieldNames) DCNL DCSP assert all(((f in tableInfo.dbFieldNames) for f in selectFieldNames)), repr(selectFieldNames) DCNL DCSP matchPairs = fieldsToMatch.items() DCNL DCSP matchExpressionGen = ((p[0] + ((' DCSP IS DCSP ' + {True: 'TRUE', False: 'FALSE'}[p[1]]) if isinstance(p[1], bool) else (' DCSP IS DCSP NULL' if (p[1] is None) else (' DCSP IN DCSP %s' if isinstance(p[1], self._SEQUENCE_TYPES) else '=%s')))) for p in matchPairs) DCNL DCSP matchFieldValues = [p[1] for p in matchPairs if ((not isinstance(p[1], bool)) and (p[1] is not None))] DCNL DCSP query = ('SELECT DCSP %s DCSP FROM DCSP %s DCSP WHERE DCSP (%s)' % (','.join(selectFieldNames), tableInfo.tableName, ' DCSP AND DCSP '.join(matchExpressionGen))) DCNL DCSP sqlParams = matchFieldValues DCNL DCSP if (maxRows is not None): DCNL DCSP  DCSP query += ' DCSP LIMIT DCSP %s' DCNL DCSP  DCSP sqlParams.append(maxRows) DCNL DCSP conn.cursor.execute(query, sqlParams) DCNL DCSP rows = conn.cursor.fetchall() DCNL DCSP if rows: DCNL DCSP  DCSP assert ((maxRows is None) or (len(rows) <= maxRows)), ('%d DCSP !<= DCSP %d' % (len(rows), maxRows)) DCNL DCSP  DCSP assert (len(rows[0]) == len(selectFieldNames)), ('%d DCSP != DCSP %d' % (len(rows[0]), len(selectFieldNames))) DCNL DCSP else: DCNL DCSP  DCSP rows = tuple() DCNL DCSP return rows
@g_retrySQL DCNL def _getMatchingRowsWithRetries(self, tableInfo, fieldsToMatch, selectFieldNames, maxRows=None): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP return self._getMatchingRowsNoRetries(tableInfo, conn, fieldsToMatch, selectFieldNames, maxRows)
def _getOneMatchingRowNoRetries(self, tableInfo, conn, fieldsToMatch, selectFieldNames): DCNL DCSP rows = self._getMatchingRowsNoRetries(tableInfo, conn, fieldsToMatch, selectFieldNames, maxRows=1) DCNL DCSP if rows: DCNL DCSP  DCSP assert (len(rows) == 1), repr(len(rows)) DCNL DCSP  DCSP result = rows[0] DCNL DCSP else: DCNL DCSP  DCSP result = None DCNL DCSP return result
@g_retrySQL DCNL def _getOneMatchingRowWithRetries(self, tableInfo, fieldsToMatch, selectFieldNames): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP return self._getOneMatchingRowNoRetries(tableInfo, conn, fieldsToMatch, selectFieldNames)
def _insertOrGetUniqueJobNoRetries(self, conn, client, cmdLine, jobHash, clientInfo, clientKey, params, minimumWorkers, maximumWorkers, jobType, priority, alreadyRunning): DCNL DCSP assert (len(client) <= self.CLIENT_MAX_LEN), ('client DCSP too DCSP long:' + repr(client)) DCNL DCSP assert cmdLine, ('Unexpected DCSP empty DCSP or DCSP None DCSP command-line: DCSP ' + repr(cmdLine)) DCNL DCSP assert (len(jobHash) == self.HASH_MAX_LEN), ('wrong DCSP hash DCSP len=%d' % len(jobHash)) DCNL DCSP if alreadyRunning: DCNL DCSP  DCSP initStatus = self.STATUS_TESTMODE DCNL DCSP else: DCNL DCSP  DCSP initStatus = self.STATUS_NOTSTARTED DCNL DCSP query = ('INSERT DCSP IGNORE DCSP INTO DCSP %s DCSP (status, DCSP client, DCSP client_info, DCSP client_key,cmd_line, DCSP params, DCSP job_hash, DCSP _eng_last_update_time, DCSP minimum_workers, DCSP maximum_workers, DCSP priority, DCSP _eng_job_type) DCSP  DCSP VALUES DCSP (%%s, DCSP %%s, DCSP %%s, DCSP %%s, DCSP %%s, DCSP %%s, DCSP %%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UTC_TIMESTAMP(), DCSP %%s, DCSP %%s, DCSP %%s, DCSP %%s) DCSP ' % (self.jobsTableName,)) DCNL DCSP sqlParams = (initStatus, client, clientInfo, clientKey, cmdLine, params, jobHash, minimumWorkers, maximumWorkers, priority, jobType) DCNL DCSP numRowsInserted = conn.cursor.execute(query, sqlParams) DCNL DCSP jobID = 0 DCNL DCSP if (numRowsInserted == 1): DCNL DCSP  DCSP conn.cursor.execute('SELECT DCSP LAST_INSERT_ID()') DCNL DCSP  DCSP jobID = conn.cursor.fetchall()[0][0] DCNL DCSP  DCSP if (jobID == 0): DCNL DCSP  DCSP  DCSP self._logger.warn('_insertOrGetUniqueJobNoRetries: DCSP SELECT DCSP LAST_INSERT_ID() DCSP returned DCSP 0; DCSP likely DCSP due DCSP to DCSP reconnection DCSP in DCSP SteadyDB DCSP following DCSP INSERT. DCSP jobType=%r; DCSP client=%r; DCSP clientInfo=%r; DCSP clientKey=%s; DCSP jobHash=%r; DCSP cmdLine=%r', jobType, client, _abbreviate(clientInfo, 32), clientKey, jobHash, cmdLine) DCNL DCSP else: DCNL DCSP  DCSP assert (numRowsInserted == 0), repr(numRowsInserted) DCNL DCSP if (jobID == 0): DCNL DCSP  DCSP row = self._getOneMatchingRowNoRetries(self._jobs, conn, dict(client=client, job_hash=jobHash), ['job_id']) DCNL DCSP  DCSP assert (row is not None) DCNL DCSP  DCSP assert (len(row) == 1), ('Unexpected DCSP num DCSP fields: DCSP ' + repr(len(row))) DCNL DCSP  DCSP jobID = row[0] DCNL DCSP if alreadyRunning: DCNL DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP _eng_cjm_conn_id=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP start_time=UTC_TIMESTAMP(), DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_last_update_time=UTC_TIMESTAMP() DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s' % (self.jobsTableName,)) DCNL DCSP  DCSP conn.cursor.execute(query, (self._connectionID, jobID)) DCNL DCSP return jobID
def _resumeJobNoRetries(self, conn, jobID, alreadyRunning): DCNL DCSP if alreadyRunning: DCNL DCSP  DCSP initStatus = self.STATUS_TESTMODE DCNL DCSP else: DCNL DCSP  DCSP initStatus = self.STATUS_NOTSTARTED DCNL DCSP assignments = ['status=%s', 'completion_reason=DEFAULT', 'completion_msg=DEFAULT', 'worker_completion_reason=DEFAULT', 'worker_completion_msg=DEFAULT', 'end_time=DEFAULT', 'cancel=DEFAULT', '_eng_last_update_time=UTC_TIMESTAMP()', '_eng_allocate_new_workers=DEFAULT', '_eng_untended_dead_workers=DEFAULT', 'num_failed_workers=DEFAULT', 'last_failed_worker_error_msg=DEFAULT', '_eng_cleaning_status=DEFAULT'] DCNL DCSP assignmentValues = [initStatus] DCNL DCSP if alreadyRunning: DCNL DCSP  DCSP assignments += ['_eng_cjm_conn_id=%s', 'start_time=UTC_TIMESTAMP()', '_eng_last_update_time=UTC_TIMESTAMP()'] DCNL DCSP  DCSP assignmentValues.append(self._connectionID) DCNL DCSP else: DCNL DCSP  DCSP assignments += ['_eng_cjm_conn_id=DEFAULT', 'start_time=DEFAULT'] DCNL DCSP assignments = ', DCSP '.join(assignments) DCNL DCSP query = ('UPDATE DCSP %s DCSP SET DCSP %s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s DCSP AND DCSP status=%%s' % (self.jobsTableName, assignments)) DCNL DCSP sqlParams = (assignmentValues + [jobID, self.STATUS_COMPLETED]) DCNL DCSP numRowsAffected = conn.cursor.execute(query, sqlParams) DCNL DCSP assert (numRowsAffected <= 1), repr(numRowsAffected) DCNL DCSP if (numRowsAffected == 0): DCNL DCSP  DCSP self._logger.info('_resumeJobNoRetries: DCSP Redundant DCSP job-resume DCSP UPDATE: DCSP job DCSP was DCSP not DCSP suspended DCSP or DCSP was DCSP resumed DCSP by DCSP another DCSP process DCSP or DCSP operation DCSP was DCSP retried DCSP after DCSP connection DCSP failure; DCSP jobID=%s', jobID) DCNL DCSP return
def getConnectionID(self): DCNL DCSP return self._connectionID
@logExceptions(_LOGGER) DCNL def jobSuspend(self, jobID): DCNL DCSP self.jobCancel(jobID) DCNL DCSP return
@logExceptions(_LOGGER) DCNL def jobResume(self, jobID, alreadyRunning=False): DCNL DCSP row = self.jobGetFields(jobID, ['status']) DCNL DCSP (jobStatus,) = row DCNL DCSP if (jobStatus != self.STATUS_COMPLETED): DCNL DCSP  DCSP raise RuntimeError(('Failed DCSP to DCSP resume DCSP job: DCSP job DCSP was DCSP not DCSP suspended; DCSP jobID=%s; DCSP job DCSP status=%r' % (jobID, jobStatus))) DCNL DCSP @g_retrySQL DCNL DCSP def resumeWithRetries(): DCNL DCSP  DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP  DCSP self._resumeJobNoRetries(conn, jobID, alreadyRunning) DCNL DCSP resumeWithRetries() DCNL DCSP return
@logExceptions(_LOGGER) DCNL def jobInsert(self, client, cmdLine, clientInfo='', clientKey='', params='', alreadyRunning=False, minimumWorkers=0, maximumWorkers=0, jobType='', priority=DEFAULT_JOB_PRIORITY): DCNL DCSP jobHash = self._normalizeHash(uuid.uuid1().bytes) DCNL DCSP @g_retrySQL DCNL DCSP def insertWithRetries(): DCNL DCSP  DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP  DCSP return self._insertOrGetUniqueJobNoRetries(conn, client=client, cmdLine=cmdLine, jobHash=jobHash, clientInfo=clientInfo, clientKey=clientKey, params=params, minimumWorkers=minimumWorkers, maximumWorkers=maximumWorkers, jobType=jobType, priority=priority, alreadyRunning=alreadyRunning) DCNL DCSP try: DCNL DCSP  DCSP jobID = insertWithRetries() DCNL DCSP except: DCNL DCSP  DCSP self._logger.exception('jobInsert DCSP FAILED: DCSP jobType=%r; DCSP client=%r; DCSP clientInfo=%r; DCSP clientKey=%r;jobHash=%r; DCSP cmdLine=%r', jobType, client, _abbreviate(clientInfo, 48), clientKey, jobHash, cmdLine) DCNL DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP self._logger.info('jobInsert: DCSP returning DCSP jobID=%s. DCSP jobType=%r; DCSP client=%r; DCSP clientInfo=%r; DCSP clientKey=%r; DCSP jobHash=%r; DCSP cmdLine=%r', jobID, jobType, client, _abbreviate(clientInfo, 48), clientKey, jobHash, cmdLine) DCNL DCSP return jobID
@logExceptions(_LOGGER) DCNL def jobInsertUnique(self, client, cmdLine, jobHash, clientInfo='', clientKey='', params='', minimumWorkers=0, maximumWorkers=0, jobType='', priority=DEFAULT_JOB_PRIORITY): DCNL DCSP assert cmdLine, ('Unexpected DCSP empty DCSP or DCSP None DCSP command-line: DCSP ' + repr(cmdLine)) DCNL DCSP @g_retrySQL DCNL DCSP def insertUniqueWithRetries(): DCNL DCSP  DCSP jobHashValue = self._normalizeHash(jobHash) DCNL DCSP  DCSP jobID = None DCNL DCSP  DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP  DCSP row = self._getOneMatchingRowNoRetries(self._jobs, conn, dict(client=client, job_hash=jobHashValue), ['job_id', 'status']) DCNL DCSP  DCSP  DCSP if (row is not None): DCNL DCSP  DCSP  DCSP  DCSP (jobID, status) = row DCNL DCSP  DCSP  DCSP  DCSP if (status == self.STATUS_COMPLETED): DCNL DCSP  DCSP  DCSP  DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP client_info=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP client_key=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cmd_line=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP params=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP minimum_workers=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP maximum_workers=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP priority=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_job_type=%%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP (job_id=%%s DCSP AND DCSP status=%%s)' % (self.jobsTableName,)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sqlParams = (clientInfo, clientKey, cmdLine, params, minimumWorkers, maximumWorkers, priority, jobType, jobID, self.STATUS_COMPLETED) DCNL DCSP  DCSP  DCSP  DCSP  DCSP numRowsUpdated = conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (numRowsUpdated <= 1), repr(numRowsUpdated) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (numRowsUpdated == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._logger.info('jobInsertUnique: DCSP Redundant DCSP job-reuse DCSP UPDATE: DCSP job DCSP restarted DCSP by DCSP another DCSP process, DCSP values DCSP were DCSP unchanged, DCSP or DCSP operation DCSP was DCSP retried DCSP after DCSP connection DCSP failure; DCSP jobID=%s', jobID) DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._resumeJobNoRetries(conn, jobID, alreadyRunning=False) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP jobID = self._insertOrGetUniqueJobNoRetries(conn, client=client, cmdLine=cmdLine, jobHash=jobHashValue, clientInfo=clientInfo, clientKey=clientKey, params=params, minimumWorkers=minimumWorkers, maximumWorkers=maximumWorkers, jobType=jobType, priority=priority, alreadyRunning=False) DCNL DCSP  DCSP  DCSP return jobID DCNL DCSP try: DCNL DCSP  DCSP jobID = insertUniqueWithRetries() DCNL DCSP except: DCNL DCSP  DCSP self._logger.exception('jobInsertUnique DCSP FAILED: DCSP jobType=%r; DCSP client=%r; DCSP clientInfo=%r; DCSP clientKey=%r; DCSP jobHash=%r; DCSP cmdLine=%r', jobType, client, _abbreviate(clientInfo, 48), clientKey, jobHash, cmdLine) DCNL DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP self._logger.info('jobInsertUnique: DCSP returning DCSP jobID=%s. DCSP jobType=%r; DCSP client=%r; DCSP clientInfo=%r; DCSP clientKey=%r; DCSP jobHash=%r; DCSP cmdLine=%r', jobID, jobType, client, _abbreviate(clientInfo, 48), clientKey, jobHash, cmdLine) DCNL DCSP return jobID
@g_retrySQL DCNL def _startJobWithRetries(self, jobID): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP status=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_cjm_conn_id=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP start_time=UTC_TIMESTAMP(), DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_last_update_time=UTC_TIMESTAMP() DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP (job_id=%%s DCSP AND DCSP status=%%s)' % (self.jobsTableName,)) DCNL DCSP  DCSP sqlParams = [self.STATUS_RUNNING, self._connectionID, jobID, self.STATUS_NOTSTARTED] DCNL DCSP  DCSP numRowsUpdated = conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP if (numRowsUpdated != 1): DCNL DCSP  DCSP  DCSP self._logger.warn('jobStartNext: DCSP numRowsUpdated=%r DCSP instead DCSP of DCSP 1; DCSP likely DCSP side-effect DCSP of DCSP transient DCSP connection DCSP failure', numRowsUpdated) DCNL DCSP return
@logExceptions(_LOGGER) DCNL def jobStartNext(self): DCNL DCSP row = self._getOneMatchingRowWithRetries(self._jobs, dict(status=self.STATUS_NOTSTARTED), ['job_id']) DCNL DCSP if (row is None): DCNL DCSP  DCSP return None DCNL DCSP (jobID,) = row DCNL DCSP self._startJobWithRetries(jobID) DCNL DCSP return jobID
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobReactivateRunningJobs(self): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP _eng_cjm_conn_id=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_allocate_new_workers=TRUE DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP status=%%s DCSP ' % (self.jobsTableName,)) DCNL DCSP  DCSP conn.cursor.execute(query, [self._connectionID, self.STATUS_RUNNING]) DCNL DCSP return
@logExceptions(_LOGGER) DCNL def jobGetDemand(self): DCNL DCSP rows = self._getMatchingRowsWithRetries(self._jobs, dict(status=self.STATUS_RUNNING), [self._jobs.pubToDBNameDict[f] for f in self._jobs.jobDemandNamedTuple._fields]) DCNL DCSP return [self._jobs.jobDemandNamedTuple._make(r) for r in rows]
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobCancelAllRunningJobs(self): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP cancel=TRUE DCSP WHERE DCSP status<>%%s DCSP ' % (self.jobsTableName,)) DCNL DCSP  DCSP conn.cursor.execute(query, [self.STATUS_COMPLETED]) DCNL DCSP return
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobCountCancellingJobs(self): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('SELECT DCSP COUNT(job_id) DCSP FROM DCSP %s DCSP WHERE DCSP (status<>%%s DCSP AND DCSP cancel DCSP is DCSP TRUE)' % (self.jobsTableName,)) DCNL DCSP  DCSP conn.cursor.execute(query, [self.STATUS_COMPLETED]) DCNL DCSP  DCSP rows = conn.cursor.fetchall() DCNL DCSP return rows[0][0]
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobGetCancellingJobs(self): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('SELECT DCSP job_id DCSP FROM DCSP %s DCSP WHERE DCSP (status<>%%s DCSP AND DCSP cancel DCSP is DCSP TRUE)' % (self.jobsTableName,)) DCNL DCSP  DCSP conn.cursor.execute(query, [self.STATUS_COMPLETED]) DCNL DCSP  DCSP rows = conn.cursor.fetchall() DCNL DCSP return tuple((r[0] for r in rows))
@staticmethod DCNL @logExceptions(_LOGGER) DCNL def partitionAtIntervals(data, intervals): DCNL DCSP assert (sum(intervals) <= len(data)) DCNL DCSP start = 0 DCNL DCSP for interval in intervals: DCNL DCSP  DCSP end = (start + interval) DCNL DCSP  DCSP (yield data[start:end]) DCNL DCSP  DCSP start = end DCNL DCSP raise StopIteration
@staticmethod DCNL @logExceptions(_LOGGER) DCNL def _combineResults(result, *namedTuples): DCNL DCSP results = ClientJobsDAO.partitionAtIntervals(result, [len(nt._fields) for nt in namedTuples]) DCNL DCSP return [nt._make(result) for (nt, result) in zip(namedTuples, results)]
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobInfoWithModels(self, jobID): DCNL DCSP combinedResults = None DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ' DCSP '.join([('SELECT DCSP %s.*, DCSP %s.*' % (self.jobsTableName, self.modelsTableName)), ('FROM DCSP %s' % self.jobsTableName), ('LEFT DCSP JOIN DCSP %s DCSP USING(job_id)' % self.modelsTableName), 'WHERE DCSP job_id=%s']) DCNL DCSP  DCSP conn.cursor.execute(query, (jobID,)) DCNL DCSP  DCSP if (conn.cursor.rowcount > 0): DCNL DCSP  DCSP  DCSP combinedResults = [ClientJobsDAO._combineResults(result, self._jobs.jobInfoNamedTuple, self._models.modelInfoNamedTuple) for result in conn.cursor.fetchall()] DCNL DCSP if (combinedResults is not None): DCNL DCSP  DCSP return combinedResults DCNL DCSP raise RuntimeError(('jobID=%s DCSP not DCSP found DCSP within DCSP the DCSP jobs DCSP table' % jobID))
@logExceptions(_LOGGER) DCNL def jobInfo(self, jobID): DCNL DCSP row = self._getOneMatchingRowWithRetries(self._jobs, dict(job_id=jobID), [self._jobs.pubToDBNameDict[n] for n in self._jobs.jobInfoNamedTuple._fields]) DCNL DCSP if (row is None): DCNL DCSP  DCSP raise RuntimeError(('jobID=%s DCSP not DCSP found DCSP within DCSP the DCSP jobs DCSP table' % jobID)) DCNL DCSP return self._jobs.jobInfoNamedTuple._make(row)
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobSetStatus(self, jobID, status, useConnectionID=True): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP status=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_last_update_time=UTC_TIMESTAMP() DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s' % (self.jobsTableName,)) DCNL DCSP  DCSP sqlParams = [status, jobID] DCNL DCSP  DCSP if useConnectionID: DCNL DCSP  DCSP  DCSP query += ' DCSP AND DCSP _eng_cjm_conn_id=%s' DCNL DCSP  DCSP  DCSP sqlParams.append(self._connectionID) DCNL DCSP  DCSP result = conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP if (result != 1): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Tried DCSP to DCSP change DCSP the DCSP status DCSP of DCSP job DCSP %d DCSP to DCSP %s, DCSP but DCSP this DCSP job DCSP belongs DCSP to DCSP some DCSP other DCSP CJM' % (jobID, status)))
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobSetCompleted(self, jobID, completionReason, completionMsg, useConnectionID=True): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP status=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP completion_reason=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP completion_msg=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP end_time=UTC_TIMESTAMP(), DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_last_update_time=UTC_TIMESTAMP() DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s' % (self.jobsTableName,)) DCNL DCSP  DCSP sqlParams = [self.STATUS_COMPLETED, completionReason, completionMsg, jobID] DCNL DCSP  DCSP if useConnectionID: DCNL DCSP  DCSP  DCSP query += ' DCSP AND DCSP _eng_cjm_conn_id=%s' DCNL DCSP  DCSP  DCSP sqlParams.append(self._connectionID) DCNL DCSP  DCSP result = conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP if (result != 1): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Tried DCSP to DCSP change DCSP the DCSP status DCSP of DCSP jobID=%s DCSP to DCSP completed, DCSP but DCSP this DCSP job DCSP could DCSP not DCSP be DCSP found DCSP or DCSP belongs DCSP to DCSP some DCSP other DCSP CJM' % jobID))
@logExceptions(_LOGGER) DCNL def jobCancel(self, jobID): DCNL DCSP self._logger.info('Canceling DCSP jobID=%s', jobID) DCNL DCSP self.jobSetFields(jobID, {'cancel': True}, useConnectionID=False)
@logExceptions(_LOGGER) DCNL def jobGetModelIDs(self, jobID): DCNL DCSP rows = self._getMatchingRowsWithRetries(self._models, dict(job_id=jobID), ['model_id']) DCNL DCSP return [r[0] for r in rows]
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getActiveJobCountForClientInfo(self, clientInfo): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('SELECT DCSP count(job_id) DCSP FROM DCSP %s DCSP WHERE DCSP client_info DCSP = DCSP %%s DCSP  DCSP AND DCSP status DCSP != DCSP %%s' % self.jobsTableName) DCNL DCSP  DCSP conn.cursor.execute(query, [clientInfo, self.STATUS_COMPLETED]) DCNL DCSP  DCSP activeJobCount = conn.cursor.fetchone()[0] DCNL DCSP return activeJobCount
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getActiveJobCountForClientKey(self, clientKey): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('SELECT DCSP count(job_id) DCSP FROM DCSP %s DCSP WHERE DCSP client_key DCSP = DCSP %%s DCSP  DCSP AND DCSP status DCSP != DCSP %%s' % self.jobsTableName) DCNL DCSP  DCSP conn.cursor.execute(query, [clientKey, self.STATUS_COMPLETED]) DCNL DCSP  DCSP activeJobCount = conn.cursor.fetchone()[0] DCNL DCSP return activeJobCount
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getActiveJobsForClientInfo(self, clientInfo, fields=[]): DCNL DCSP dbFields = [self._jobs.pubToDBNameDict[x] for x in fields] DCNL DCSP dbFieldsStr = ','.join((['job_id'] + dbFields)) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('SELECT DCSP %s DCSP FROM DCSP %s DCSP WHERE DCSP client_info DCSP = DCSP %%s DCSP  DCSP AND DCSP status DCSP != DCSP %%s' % (dbFieldsStr, self.jobsTableName)) DCNL DCSP  DCSP conn.cursor.execute(query, [clientInfo, self.STATUS_COMPLETED]) DCNL DCSP  DCSP rows = conn.cursor.fetchall() DCNL DCSP return rows
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getActiveJobsForClientKey(self, clientKey, fields=[]): DCNL DCSP dbFields = [self._jobs.pubToDBNameDict[x] for x in fields] DCNL DCSP dbFieldsStr = ','.join((['job_id'] + dbFields)) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('SELECT DCSP %s DCSP FROM DCSP %s DCSP WHERE DCSP client_key DCSP = DCSP %%s DCSP  DCSP AND DCSP status DCSP != DCSP %%s' % (dbFieldsStr, self.jobsTableName)) DCNL DCSP  DCSP conn.cursor.execute(query, [clientKey, self.STATUS_COMPLETED]) DCNL DCSP  DCSP rows = conn.cursor.fetchall() DCNL DCSP return rows
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getJobs(self, fields=[]): DCNL DCSP dbFields = [self._jobs.pubToDBNameDict[x] for x in fields] DCNL DCSP dbFieldsStr = ','.join((['job_id'] + dbFields)) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('SELECT DCSP %s DCSP FROM DCSP %s' % (dbFieldsStr, self.jobsTableName)) DCNL DCSP  DCSP conn.cursor.execute(query) DCNL DCSP  DCSP rows = conn.cursor.fetchall() DCNL DCSP return rows
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getFieldsForActiveJobsOfType(self, jobType, fields=[]): DCNL DCSP dbFields = [self._jobs.pubToDBNameDict[x] for x in fields] DCNL DCSP dbFieldsStr = ','.join((['job_id'] + dbFields)) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('SELECT DCSP DISTINCT DCSP %s DCSP FROM DCSP %s DCSP j DCSP LEFT DCSP JOIN DCSP %s DCSP m DCSP USING(job_id) DCSP WHERE DCSP j.status DCSP != DCSP %%s DCSP AND DCSP _eng_job_type DCSP = DCSP %%s' % (dbFieldsStr, self.jobsTableName, self.modelsTableName)) DCNL DCSP  DCSP conn.cursor.execute(query, [self.STATUS_COMPLETED, jobType]) DCNL DCSP  DCSP return conn.cursor.fetchall()
@logExceptions(_LOGGER) DCNL def jobGetFields(self, jobID, fields): DCNL DCSP return self.jobsGetFields([jobID], fields, requireAll=True)[0][1]
@logExceptions(_LOGGER) DCNL def jobsGetFields(self, jobIDs, fields, requireAll=True): DCNL DCSP assert isinstance(jobIDs, self._SEQUENCE_TYPES) DCNL DCSP assert (len(jobIDs) >= 1) DCNL DCSP rows = self._getMatchingRowsWithRetries(self._jobs, dict(job_id=jobIDs), (['job_id'] + [self._jobs.pubToDBNameDict[x] for x in fields])) DCNL DCSP if (requireAll and (len(rows) < len(jobIDs))): DCNL DCSP  DCSP raise RuntimeError(('jobIDs DCSP %s DCSP not DCSP found DCSP within DCSP the DCSP jobs DCSP table' % ((set(jobIDs) - set((r[0] for r in rows))),))) DCNL DCSP return [(r[0], list(r[1:])) for r in rows]
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobSetFields(self, jobID, fields, useConnectionID=True, ignoreUnchanged=False): DCNL DCSP assignmentExpressions = ','.join([('%s=%%s' % (self._jobs.pubToDBNameDict[f],)) for f in fields.iterkeys()]) DCNL DCSP assignmentValues = fields.values() DCNL DCSP query = ('UPDATE DCSP %s DCSP SET DCSP %s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s' % (self.jobsTableName, assignmentExpressions)) DCNL DCSP sqlParams = (assignmentValues + [jobID]) DCNL DCSP if useConnectionID: DCNL DCSP  DCSP query += ' DCSP AND DCSP _eng_cjm_conn_id=%s' DCNL DCSP  DCSP sqlParams.append(self._connectionID) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP result = conn.cursor.execute(query, sqlParams) DCNL DCSP if ((result != 1) and (not ignoreUnchanged)): DCNL DCSP  DCSP raise RuntimeError(('Tried DCSP to DCSP change DCSP fields DCSP (%r) DCSP of DCSP jobID=%s DCSP conn_id=%r), DCSP but DCSP an DCSP error DCSP occurred. DCSP result=%r; DCSP query=%r' % (assignmentExpressions, jobID, self._connectionID, result, query)))
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobSetFieldIfEqual(self, jobID, fieldName, newValue, curValue): DCNL DCSP dbFieldName = self._jobs.pubToDBNameDict[fieldName] DCNL DCSP conditionValue = [] DCNL DCSP if isinstance(curValue, bool): DCNL DCSP  DCSP conditionExpression = ('%s DCSP IS DCSP %s' % (dbFieldName, {True: 'TRUE', False: 'FALSE'}[curValue])) DCNL DCSP elif (curValue is None): DCNL DCSP  DCSP conditionExpression = ('%s DCSP is DCSP NULL' % (dbFieldName,)) DCNL DCSP else: DCNL DCSP  DCSP conditionExpression = ('%s=%%s' % (dbFieldName,)) DCNL DCSP  DCSP conditionValue.append(curValue) DCNL DCSP query = ('UPDATE DCSP %s DCSP SET DCSP _eng_last_update_time=UTC_TIMESTAMP(), DCSP %s=%%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s DCSP AND DCSP %s' % (self.jobsTableName, dbFieldName, conditionExpression)) DCNL DCSP sqlParams = ([newValue, jobID] + conditionValue) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP result = conn.cursor.execute(query, sqlParams) DCNL DCSP return (result == 1)
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobIncrementIntField(self, jobID, fieldName, increment=1, useConnectionID=False): DCNL DCSP dbFieldName = self._jobs.pubToDBNameDict[fieldName] DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP %s=%s+%%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s' % (self.jobsTableName, dbFieldName, dbFieldName)) DCNL DCSP  DCSP sqlParams = [increment, jobID] DCNL DCSP  DCSP if useConnectionID: DCNL DCSP  DCSP  DCSP query += ' DCSP AND DCSP _eng_cjm_conn_id=%s' DCNL DCSP  DCSP  DCSP sqlParams.append(self._connectionID) DCNL DCSP  DCSP result = conn.cursor.execute(query, sqlParams) DCNL DCSP if (result != 1): DCNL DCSP  DCSP raise RuntimeError(('Tried DCSP to DCSP increment DCSP the DCSP field DCSP (%r) DCSP of DCSP jobID=%s DCSP (conn_id=%r), DCSP but DCSP an DCSP error DCSP occurred. DCSP result=%r; DCSP query=%r' % (dbFieldName, jobID, self._connectionID, result, query)))
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobUpdateResults(self, jobID, results): DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP _eng_last_update_time=UTC_TIMESTAMP(), DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP results=%%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s' % (self.jobsTableName,)) DCNL DCSP  DCSP conn.cursor.execute(query, [results, jobID])
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelsClearAll(self): DCNL DCSP self._logger.info('Deleting DCSP all DCSP rows DCSP from DCSP models DCSP table DCSP %r', self.modelsTableName) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP query = ('DELETE DCSP FROM DCSP %s' % self.modelsTableName) DCNL DCSP  DCSP conn.cursor.execute(query)
@logExceptions(_LOGGER) DCNL def modelInsertAndStart(self, jobID, params, paramsHash, particleHash=None): DCNL DCSP if (particleHash is None): DCNL DCSP  DCSP particleHash = paramsHash DCNL DCSP paramsHash = self._normalizeHash(paramsHash) DCNL DCSP particleHash = self._normalizeHash(particleHash) DCNL DCSP def findExactMatchNoRetries(conn): DCNL DCSP  DCSP return self._getOneMatchingRowNoRetries(self._models, conn, {'job_id': jobID, '_eng_params_hash': paramsHash, '_eng_particle_hash': particleHash}, ['model_id', '_eng_worker_conn_id']) DCNL DCSP @g_retrySQL DCNL DCSP def findExactMatchWithRetries(): DCNL DCSP  DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP  DCSP return findExactMatchNoRetries(conn) DCNL DCSP row = findExactMatchWithRetries() DCNL DCSP if (row is not None): DCNL DCSP  DCSP return (row[0], False) DCNL DCSP @g_retrySQL DCNL DCSP def insertModelWithRetries(): DCNL DCSP  DCSP " DCSP NOTE: DCSP it's DCSP possible DCSP that DCSP another DCSP process DCSP on DCSP some DCSP machine DCSP is DCSP attempting\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP to DCSP insert DCSP the DCSP same DCSP model DCSP at DCSP the DCSP same DCSP time DCSP as DCSP the DCSP caller DCSP " DCNL DCSP  DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP  DCSP query = ('INSERT DCSP INTO DCSP %s DCSP (job_id, DCSP params, DCSP status, DCSP _eng_params_hash, DCSP  DCSP  DCSP _eng_particle_hash, DCSP start_time, DCSP _eng_last_update_time, DCSP  DCSP  DCSP _eng_worker_conn_id) DCSP  DCSP  DCSP VALUES DCSP (%%s, DCSP %%s, DCSP %%s, DCSP %%s, DCSP %%s, DCSP UTC_TIMESTAMP(), DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UTC_TIMESTAMP(), DCSP %%s) DCSP ' % (self.modelsTableName,)) DCNL DCSP  DCSP  DCSP sqlParams = (jobID, params, self.STATUS_RUNNING, paramsHash, particleHash, self._connectionID) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP numRowsAffected = conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP if ('Duplicate DCSP entry' not in str(e)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP self._logger.info('Model DCSP insert DCSP attempt DCSP failed DCSP with DCSP DUP_ENTRY: DCSP jobID=%s; DCSP paramsHash=%s DCSP OR DCSP particleHash=%s; DCSP %r', jobID, paramsHash.encode('hex'), particleHash.encode('hex'), e) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (numRowsAffected == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP conn.cursor.execute('SELECT DCSP LAST_INSERT_ID()') DCNL DCSP  DCSP  DCSP  DCSP  DCSP modelID = conn.cursor.fetchall()[0][0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (modelID != 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (modelID, True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._logger.warn('SELECT DCSP LAST_INSERT_ID DCSP for DCSP model DCSP returned DCSP 0, DCSP implying DCSP loss DCSP of DCSP connection: DCSP jobID=%s; DCSP paramsHash=%r; DCSP particleHash=%r', jobID, paramsHash, particleHash) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._logger.error('Attempt DCSP to DCSP insert DCSP model DCSP resulted DCSP in DCSP unexpected DCSP numRowsAffected: DCSP expected DCSP 1, DCSP but DCSP got DCSP %r; DCSP jobID=%s; DCSP paramsHash=%r; DCSP particleHash=%r', numRowsAffected, jobID, paramsHash, particleHash) DCNL DCSP  DCSP  DCSP row = findExactMatchNoRetries(conn) DCNL DCSP  DCSP  DCSP if (row is not None): DCNL DCSP  DCSP  DCSP  DCSP (modelID, connectionID) = row DCNL DCSP  DCSP  DCSP  DCSP return (modelID, (connectionID == self._connectionID)) DCNL DCSP  DCSP  DCSP query = ('SELECT DCSP (model_id) DCSP FROM DCSP %s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s DCSP AND DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (_eng_params_hash=%%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP OR DCSP _eng_particle_hash=%%s) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LIMIT DCSP 1 DCSP ' % (self.modelsTableName,)) DCNL DCSP  DCSP  DCSP sqlParams = [jobID, paramsHash, particleHash] DCNL DCSP  DCSP  DCSP numRowsFound = conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP  DCSP assert (numRowsFound == 1), ('Model DCSP not DCSP found: DCSP jobID=%s DCSP AND DCSP (paramsHash=%r DCSP OR DCSP particleHash=%r); DCSP numRowsFound=%r' % (jobID, paramsHash, particleHash, numRowsFound)) DCNL DCSP  DCSP  DCSP (modelID,) = conn.cursor.fetchall()[0] DCNL DCSP  DCSP  DCSP return (modelID, False) DCNL DCSP return insertModelWithRetries()
@logExceptions(_LOGGER) DCNL def modelsInfo(self, modelIDs): DCNL DCSP assert isinstance(modelIDs, self._SEQUENCE_TYPES), ('wrong DCSP modelIDs DCSP type: DCSP %s' % (type(modelIDs),)) DCNL DCSP assert modelIDs, 'modelIDs DCSP is DCSP empty' DCNL DCSP rows = self._getMatchingRowsWithRetries(self._models, dict(model_id=modelIDs), [self._models.pubToDBNameDict[f] for f in self._models.modelInfoNamedTuple._fields]) DCNL DCSP results = [self._models.modelInfoNamedTuple._make(r) for r in rows] DCNL DCSP assert (len(results) == len(modelIDs)), ('modelIDs DCSP not DCSP found: DCSP %s' % (set(modelIDs) - set((r.modelId for r in results)))) DCNL DCSP return results
@logExceptions(_LOGGER) DCNL def modelsGetFields(self, modelIDs, fields): DCNL DCSP assert (len(fields) >= 1), 'fields DCSP is DCSP empty' DCNL DCSP isSequence = isinstance(modelIDs, self._SEQUENCE_TYPES) DCNL DCSP if isSequence: DCNL DCSP  DCSP assert (len(modelIDs) >= 1), 'modelIDs DCSP is DCSP empty' DCNL DCSP else: DCNL DCSP  DCSP modelIDs = [modelIDs] DCNL DCSP rows = self._getMatchingRowsWithRetries(self._models, dict(model_id=modelIDs), (['model_id'] + [self._models.pubToDBNameDict[f] for f in fields])) DCNL DCSP if (len(rows) < len(modelIDs)): DCNL DCSP  DCSP raise RuntimeError(('modelIDs DCSP not DCSP found DCSP within DCSP the DCSP models DCSP table: DCSP %s' % ((set(modelIDs) - set((r[0] for r in rows))),))) DCNL DCSP if (not isSequence): DCNL DCSP  DCSP return list(rows[0][1:]) DCNL DCSP return [(r[0], list(r[1:])) for r in rows]
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelsGetFieldsForJob(self, jobID, fields, ignoreKilled=False): DCNL DCSP assert (len(fields) >= 1), 'fields DCSP is DCSP empty' DCNL DCSP dbFields = [self._models.pubToDBNameDict[x] for x in fields] DCNL DCSP dbFieldsStr = ','.join(dbFields) DCNL DCSP query = ('SELECT DCSP model_id, DCSP %s DCSP FROM DCSP %s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP job_id=%%s DCSP ' % (dbFieldsStr, self.modelsTableName)) DCNL DCSP sqlParams = [jobID] DCNL DCSP if ignoreKilled: DCNL DCSP  DCSP query += ' DCSP AND DCSP (completion_reason DCSP IS DCSP NULL DCSP OR DCSP completion_reason DCSP != DCSP %s)' DCNL DCSP  DCSP sqlParams.append(self.CMPL_REASON_KILLED) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP rows = conn.cursor.fetchall() DCNL DCSP if (rows is None): DCNL DCSP  DCSP self._logger.error('Unexpected DCSP None DCSP result DCSP from DCSP cursor.fetchall; DCSP query=%r; DCSP Traceback=%r', query, traceback.format_exc()) DCNL DCSP return [(r[0], list(r[1:])) for r in rows]
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelsGetFieldsForCheckpointed(self, jobID, fields): DCNL DCSP assert (len(fields) >= 1), 'fields DCSP is DCSP empty' DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP dbFields = [self._models.pubToDBNameDict[f] for f in fields] DCNL DCSP  DCSP dbFieldStr = ', DCSP '.join(dbFields) DCNL DCSP  DCSP query = 'SELECT DCSP model_id, DCSP {fields} DCSP from DCSP {models} DCSP  DCSP  DCSP WHERE DCSP job_id=%s DCSP AND DCSP model_checkpoint_id DCSP IS DCSP NOT DCSP NULL'.format(fields=dbFieldStr, models=self.modelsTableName) DCNL DCSP  DCSP conn.cursor.execute(query, [jobID]) DCNL DCSP  DCSP rows = conn.cursor.fetchall() DCNL DCSP return [(r[0], list(r[1:])) for r in rows]
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelSetFields(self, modelID, fields, ignoreUnchanged=False): DCNL DCSP assignmentExpressions = ','.join((('%s=%%s' % (self._models.pubToDBNameDict[f],)) for f in fields.iterkeys())) DCNL DCSP assignmentValues = fields.values() DCNL DCSP query = ('UPDATE DCSP %s DCSP SET DCSP %s, DCSP update_counter DCSP = DCSP update_counter+1 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP model_id=%%s' % (self.modelsTableName, assignmentExpressions)) DCNL DCSP sqlParams = (assignmentValues + [modelID]) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP numAffectedRows = conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP self._logger.debug('Executed: DCSP numAffectedRows=%r, DCSP query=%r, DCSP sqlParams=%r', numAffectedRows, query, sqlParams) DCNL DCSP if ((numAffectedRows != 1) and (not ignoreUnchanged)): DCNL DCSP  DCSP raise RuntimeError(('Tried DCSP to DCSP change DCSP fields DCSP (%r) DCSP of DCSP model DCSP %r DCSP (conn_id=%r), DCSP but DCSP an DCSP error DCSP occurred. DCSP numAffectedRows=%r; DCSP query=%r; DCSP sqlParams=%r' % (fields, modelID, self._connectionID, numAffectedRows, query, sqlParams)))
@logExceptions(_LOGGER) DCNL def modelsGetParams(self, modelIDs): DCNL DCSP assert isinstance(modelIDs, self._SEQUENCE_TYPES), ('Wrong DCSP modelIDs DCSP type: DCSP %r' % (type(modelIDs),)) DCNL DCSP assert (len(modelIDs) >= 1), 'modelIDs DCSP is DCSP empty' DCNL DCSP rows = self._getMatchingRowsWithRetries(self._models, {'model_id': modelIDs}, [self._models.pubToDBNameDict[f] for f in self._models.getParamsNamedTuple._fields]) DCNL DCSP assert (len(rows) == len(modelIDs)), ("Didn't DCSP find DCSP modelIDs: DCSP %r" % ((set(modelIDs) - set((r[0] for r in rows))),)) DCNL DCSP return [self._models.getParamsNamedTuple._make(r) for r in rows]
@logExceptions(_LOGGER) DCNL def modelsGetResultAndStatus(self, modelIDs): DCNL DCSP assert isinstance(modelIDs, self._SEQUENCE_TYPES), ('Wrong DCSP modelIDs DCSP type: DCSP %r' % type(modelIDs)) DCNL DCSP assert (len(modelIDs) >= 1), 'modelIDs DCSP is DCSP empty' DCNL DCSP rows = self._getMatchingRowsWithRetries(self._models, {'model_id': modelIDs}, [self._models.pubToDBNameDict[f] for f in self._models.getResultAndStatusNamedTuple._fields]) DCNL DCSP assert (len(rows) == len(modelIDs)), ("Didn't DCSP find DCSP modelIDs: DCSP %r" % ((set(modelIDs) - set((r[0] for r in rows))),)) DCNL DCSP return [self._models.getResultAndStatusNamedTuple._make(r) for r in rows]
@logExceptions(_LOGGER) DCNL def modelsGetUpdateCounters(self, jobID): DCNL DCSP rows = self._getMatchingRowsWithRetries(self._models, {'job_id': jobID}, [self._models.pubToDBNameDict[f] for f in self._models.getUpdateCountersNamedTuple._fields]) DCNL DCSP return [self._models.getUpdateCountersNamedTuple._make(r) for r in rows]
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelUpdateResults(self, modelID, results=None, metricValue=None, numRecords=None): DCNL DCSP assignmentExpressions = ['_eng_last_update_time=UTC_TIMESTAMP()', 'update_counter=update_counter+1'] DCNL DCSP assignmentValues = [] DCNL DCSP if (results is not None): DCNL DCSP  DCSP assignmentExpressions.append('results=%s') DCNL DCSP  DCSP assignmentValues.append(results) DCNL DCSP if (numRecords is not None): DCNL DCSP  DCSP assignmentExpressions.append('num_records=%s') DCNL DCSP  DCSP assignmentValues.append(numRecords) DCNL DCSP if ((metricValue is not None) and (metricValue == metricValue)): DCNL DCSP  DCSP assignmentExpressions.append('optimized_metric=%s') DCNL DCSP  DCSP assignmentValues.append(float(metricValue)) DCNL DCSP query = ('UPDATE DCSP %s DCSP SET DCSP %s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP model_id=%%s DCSP and DCSP _eng_worker_conn_id=%%s' % (self.modelsTableName, ','.join(assignmentExpressions))) DCNL DCSP sqlParams = (assignmentValues + [modelID, self._connectionID]) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP numRowsAffected = conn.cursor.execute(query, sqlParams) DCNL DCSP if (numRowsAffected != 1): DCNL DCSP  DCSP raise InvalidConnectionException(('Tried DCSP to DCSP update DCSP the DCSP info DCSP of DCSP modelID=%r DCSP using DCSP connectionID=%r, DCSP but DCSP this DCSP model DCSP belongs DCSP to DCSP some DCSP other DCSP worker DCSP or DCSP modelID DCSP not DCSP found; DCSP numRowsAffected=%r' % (modelID, self._connectionID, numRowsAffected)))
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelSetCompleted(self, modelID, completionReason, completionMsg, cpuTime=0, useConnectionID=True): DCNL DCSP if (completionMsg is None): DCNL DCSP  DCSP completionMsg = '' DCNL DCSP query = ('UPDATE DCSP %s DCSP SET DCSP status=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP completion_reason=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP completion_msg=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP end_time=UTC_TIMESTAMP(), DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cpu_time=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_last_update_time=UTC_TIMESTAMP(), DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP update_counter=update_counter+1 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP model_id=%%s' % (self.modelsTableName,)) DCNL DCSP sqlParams = [self.STATUS_COMPLETED, completionReason, completionMsg, cpuTime, modelID] DCNL DCSP if useConnectionID: DCNL DCSP  DCSP query += ' DCSP AND DCSP _eng_worker_conn_id=%s' DCNL DCSP  DCSP sqlParams.append(self._connectionID) DCNL DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP numRowsAffected = conn.cursor.execute(query, sqlParams) DCNL DCSP if (numRowsAffected != 1): DCNL DCSP  DCSP raise InvalidConnectionException(('Tried DCSP to DCSP set DCSP modelID=%r DCSP using DCSP connectionID=%r, DCSP but DCSP this DCSP model DCSP belongs DCSP to DCSP some DCSP other DCSP worker DCSP or DCSP modelID DCSP not DCSP found; DCSP numRowsAffected=%r' % (modelID, self._connectionID, numRowsAffected)))
@logExceptions(_LOGGER) DCNL def modelAdoptNextOrphan(self, jobId, maxUpdateInterval): DCNL DCSP @g_retrySQL DCNL DCSP def findCandidateModelWithRetries(): DCNL DCSP  DCSP modelID = None DCNL DCSP  DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP  DCSP query = ('SELECT DCSP model_id DCSP FROM DCSP %s DCSP  DCSP  DCSP  DCSP WHERE DCSP  DCSP status=%%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP job_id=%%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP TIMESTAMPDIFF(SECOND, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_last_update_time, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UTC_TIMESTAMP()) DCSP > DCSP %%s DCSP  DCSP  DCSP  DCSP LIMIT DCSP 1 DCSP ' % (self.modelsTableName,)) DCNL DCSP  DCSP  DCSP sqlParams = [self.STATUS_RUNNING, jobId, maxUpdateInterval] DCNL DCSP  DCSP  DCSP numRows = conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP  DCSP rows = conn.cursor.fetchall() DCNL DCSP  DCSP assert (numRows <= 1), ('Unexpected DCSP numRows: DCSP %r' % numRows) DCNL DCSP  DCSP if (numRows == 1): DCNL DCSP  DCSP  DCSP (modelID,) = rows[0] DCNL DCSP  DCSP return modelID DCNL DCSP @g_retrySQL DCNL DCSP def adoptModelWithRetries(modelID): DCNL DCSP  DCSP adopted = False DCNL DCSP  DCSP with ConnectionFactory.get() as conn: DCNL DCSP  DCSP  DCSP query = ('UPDATE DCSP %s DCSP SET DCSP _eng_worker_conn_id=%%s, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_last_update_time=UTC_TIMESTAMP() DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP model_id=%%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP status=%%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP TIMESTAMPDIFF(SECOND, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _eng_last_update_time, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UTC_TIMESTAMP()) DCSP > DCSP %%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LIMIT DCSP 1 DCSP ' % (self.modelsTableName,)) DCNL DCSP  DCSP  DCSP sqlParams = [self._connectionID, modelID, self.STATUS_RUNNING, maxUpdateInterval] DCNL DCSP  DCSP  DCSP numRowsAffected = conn.cursor.execute(query, sqlParams) DCNL DCSP  DCSP  DCSP assert (numRowsAffected <= 1), ('Unexpected DCSP numRowsAffected=%r' % (numRowsAffected,)) DCNL DCSP  DCSP  DCSP if (numRowsAffected == 1): DCNL DCSP  DCSP  DCSP  DCSP adopted = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (status, connectionID) = self._getOneMatchingRowNoRetries(self._models, conn, {'model_id': modelID}, ['status', '_eng_worker_conn_id']) DCNL DCSP  DCSP  DCSP  DCSP adopted = ((status == self.STATUS_RUNNING) and (connectionID == self._connectionID)) DCNL DCSP  DCSP return adopted DCNL DCSP adoptedModelID = None DCNL DCSP while True: DCNL DCSP  DCSP modelID = findCandidateModelWithRetries() DCNL DCSP  DCSP if (modelID is None): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if adoptModelWithRetries(modelID): DCNL DCSP  DCSP  DCSP adoptedModelID = modelID DCNL DCSP  DCSP  DCSP break DCNL DCSP return adoptedModelID
@classmethod DCNL def get(cls): DCNL DCSP if (cls._connectionPolicy is None): DCNL DCSP  DCSP logger = _getLogger(cls) DCNL DCSP  DCSP logger.info('Creating DCSP db DCSP connection DCSP policy DCSP via DCSP provider DCSP %r', cls._connectionPolicyInstanceProvider) DCNL DCSP  DCSP cls._connectionPolicy = cls._connectionPolicyInstanceProvider() DCNL DCSP  DCSP logger.debug('Created DCSP connection DCSP policy: DCSP %r', cls._connectionPolicy) DCNL DCSP return cls._connectionPolicy.acquireConnection()
@classmethod DCNL def close(cls): DCNL DCSP if (cls._connectionPolicy is not None): DCNL DCSP  DCSP cls._connectionPolicy.close() DCNL DCSP  DCSP cls._connectionPolicy = None DCNL DCSP return
@classmethod DCNL def setConnectionPolicyProvider(cls, provider): DCNL DCSP cls._connectionPolicyInstanceProvider = provider DCNL DCSP return
@classmethod DCNL def _createDefaultPolicy(cls): DCNL DCSP logger = _getLogger(cls) DCNL DCSP logger.debug('Creating DCSP database DCSP connection DCSP policy: DCSP platform=%r; DCSP pymysql.VERSION=%r', platform.system(), pymysql.VERSION) DCNL DCSP if (platform.system() == 'Java'): DCNL DCSP  DCSP policy = SingleSharedConnectionPolicy() DCNL DCSP else: DCNL DCSP  DCSP policy = PooledConnectionPolicy() DCNL DCSP return policy
def __init__(self, dbConn, cursor, releaser, logger): DCNL DCSP global g_max_concurrency DCNL DCSP try: DCNL DCSP  DCSP self._logger = logger DCNL DCSP  DCSP self.dbConn = dbConn DCNL DCSP  DCSP ' DCSP database DCSP connection DCSP instance DCSP ' DCNL DCSP  DCSP self.cursor = cursor DCNL DCSP  DCSP " DCSP Public DCSP cursor DCSP instance. DCSP Don't DCSP close DCSP it DCSP directly: DCSP  DCSP Connection.release()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP will DCSP do DCSP the DCSP right DCSP thing.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP self._releaser = releaser DCNL DCSP  DCSP self._addedToInstanceSet = False DCNL DCSP  DCSP ' DCSP True DCSP if DCSP we DCSP added DCSP self DCSP to DCSP _clsOutstandingInstances DCSP ' DCNL DCSP  DCSP self._creationTracebackString = None DCNL DCSP  DCSP ' DCSP Instance DCSP creation DCSP traceback DCSP string DCSP (if DCSP g_max_concurrency DCSP is DCSP enabled) DCSP ' DCNL DCSP  DCSP if (g_max_concurrency is not None): DCNL DCSP  DCSP  DCSP self._trackInstanceAndCheckForConcurrencyViolation() DCNL DCSP  DCSP logger.debug('Acquired: DCSP %r; DCSP numOutstanding=%s', self, self._clsNumOutstanding) DCNL DCSP except: DCNL DCSP  DCSP logger.exception('Exception DCSP while DCSP instantiating DCSP %r;', self) DCNL DCSP  DCSP if self._addedToInstanceSet: DCNL DCSP  DCSP  DCSP self._clsOutstandingInstances.remove(self) DCNL DCSP  DCSP releaser(dbConn=dbConn, cursor=cursor) DCNL DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP self.__class__._clsNumOutstanding += 1 DCNL DCSP return
def __enter__(self): DCNL DCSP return self
def __exit__(self, exc_type, exc_val, exc_tb): DCNL DCSP self.release() DCNL DCSP return False
def release(self): DCNL DCSP self._logger.debug('Releasing: DCSP %r', self) DCNL DCSP if self._addedToInstanceSet: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP self._clsOutstandingInstances.remove(self) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP self._logger.exception('Failed DCSP to DCSP remove DCSP self DCSP from DCSP _clsOutstandingInstances: DCSP %r;', self) DCNL DCSP  DCSP  DCSP raise DCNL DCSP self._releaser(dbConn=self.dbConn, cursor=self.cursor) DCNL DCSP self.__class__._clsNumOutstanding -= 1 DCNL DCSP assert (self._clsNumOutstanding >= 0), ('_clsNumOutstanding=%r' % (self._clsNumOutstanding,)) DCNL DCSP self._releaser = None DCNL DCSP self.cursor = None DCNL DCSP self.dbConn = None DCNL DCSP self._creationTracebackString = None DCNL DCSP self._addedToInstanceSet = False DCNL DCSP self._logger = None DCNL DCSP return
def _trackInstanceAndCheckForConcurrencyViolation(self): DCNL DCSP global g_max_concurrency, g_max_concurrency_raise_exception DCNL DCSP assert (g_max_concurrency is not None) DCNL DCSP assert (self not in self._clsOutstandingInstances), repr(self) DCNL DCSP self._creationTracebackString = traceback.format_stack() DCNL DCSP if (self._clsNumOutstanding >= g_max_concurrency): DCNL DCSP  DCSP errorMsg = ('With DCSP numOutstanding=%r, DCSP exceeded DCSP concurrency DCSP limit=%r DCSP when DCSP requesting DCSP %r. DCSP OTHER DCSP TRACKED DCSP UNRELEASED DCSP INSTANCES DCSP (%s): DCSP %r' % (self._clsNumOutstanding, g_max_concurrency, self, len(self._clsOutstandingInstances), self._clsOutstandingInstances)) DCNL DCSP  DCSP self._logger.error(errorMsg) DCNL DCSP  DCSP if g_max_concurrency_raise_exception: DCNL DCSP  DCSP  DCSP raise ConcurrencyExceededError(errorMsg) DCNL DCSP self._clsOutstandingInstances.add(self) DCNL DCSP self._addedToInstanceSet = True DCNL DCSP return
def close(self): DCNL DCSP raise NotImplementedError()
def acquireConnection(self): DCNL DCSP raise NotImplementedError()
def __init__(self): DCNL DCSP self._logger = _getLogger(self.__class__) DCNL DCSP self._conn = SteadyDB.connect(**_getCommonSteadyDBArgsDict()) DCNL DCSP self._logger.debug('Created DCSP %s', self.__class__.__name__) DCNL DCSP return
def close(self): DCNL DCSP self._logger.info('Closing') DCNL DCSP if (self._conn is not None): DCNL DCSP  DCSP self._conn.close() DCNL DCSP  DCSP self._conn = None DCNL DCSP else: DCNL DCSP  DCSP self._logger.warning('close() DCSP called, DCSP but DCSP connection DCSP policy DCSP was DCSP alredy DCSP closed') DCNL DCSP return
def acquireConnection(self): DCNL DCSP self._logger.debug('Acquiring DCSP connection') DCNL DCSP self._conn._ping_check() DCNL DCSP connWrap = ConnectionWrapper(dbConn=self._conn, cursor=self._conn.cursor(), releaser=self._releaseConnection, logger=self._logger) DCNL DCSP return connWrap
def _releaseConnection(self, dbConn, cursor): DCNL DCSP self._logger.debug('Releasing DCSP connection') DCNL DCSP cursor.close() DCNL DCSP return
def __init__(self): DCNL DCSP self._logger = _getLogger(self.__class__) DCNL DCSP self._logger.debug('Opening') DCNL DCSP self._pool = PooledDB(**_getCommonSteadyDBArgsDict()) DCNL DCSP self._logger.info('Created DCSP %s', self.__class__.__name__) DCNL DCSP return
def close(self): DCNL DCSP self._logger.info('Closing') DCNL DCSP if (self._pool is not None): DCNL DCSP  DCSP self._pool.close() DCNL DCSP  DCSP self._pool = None DCNL DCSP else: DCNL DCSP  DCSP self._logger.warning('close() DCSP called, DCSP but DCSP connection DCSP policy DCSP was DCSP alredy DCSP closed') DCNL DCSP return
def acquireConnection(self): DCNL DCSP self._logger.debug('Acquiring DCSP connection') DCNL DCSP dbConn = self._pool.connection(shareable=False) DCNL DCSP connWrap = ConnectionWrapper(dbConn=dbConn, cursor=dbConn.cursor(), releaser=self._releaseConnection, logger=self._logger) DCNL DCSP return connWrap
def _releaseConnection(self, dbConn, cursor): DCNL DCSP self._logger.debug('Releasing DCSP connection') DCNL DCSP cursor.close() DCNL DCSP dbConn.close() DCNL DCSP return
def __init__(self): DCNL DCSP self._logger = _getLogger(self.__class__) DCNL DCSP self._opened = True DCNL DCSP self._logger.info('Created DCSP %s', self.__class__.__name__) DCNL DCSP return
def close(self): DCNL DCSP self._logger.info('Closing') DCNL DCSP if self._opened: DCNL DCSP  DCSP self._opened = False DCNL DCSP else: DCNL DCSP  DCSP self._logger.warning('close() DCSP called, DCSP but DCSP connection DCSP policy DCSP was DCSP alredy DCSP closed') DCNL DCSP return
def acquireConnection(self): DCNL DCSP self._logger.debug('Acquiring DCSP connection') DCNL DCSP dbConn = SteadyDB.connect(**_getCommonSteadyDBArgsDict()) DCNL DCSP connWrap = ConnectionWrapper(dbConn=dbConn, cursor=dbConn.cursor(), releaser=self._releaseConnection, logger=self._logger) DCNL DCSP return connWrap
def _releaseConnection(self, dbConn, cursor): DCNL DCSP self._logger.debug('Releasing DCSP connection') DCNL DCSP cursor.close() DCNL DCSP dbConn.close() DCNL DCSP return
def __init__(self, n, w=None, name='sparse_pass_through', forced=False, verbosity=0): DCNL DCSP super(SparsePassThroughEncoder, self).__init__(n, w, name, forced, verbosity)
def encodeIntoArray(self, value, output): DCNL DCSP denseInput = numpy.zeros(output.shape) DCNL DCSP try: DCNL DCSP  DCSP denseInput[value] = 1 DCNL DCSP except IndexError: DCNL DCSP  DCSP if isinstance(value, numpy.ndarray): DCNL DCSP  DCSP  DCSP raise ValueError('Numpy DCSP array DCSP must DCSP have DCSP integer DCSP dtype DCSP but DCSP got DCSP {}'.format(value.dtype)) DCNL DCSP  DCSP raise DCNL DCSP super(SparsePassThroughEncoder, self).encodeIntoArray(denseInput, output)
def __init__(self, w, minval=None, maxval=None, periodic=False, n=0, radius=0, resolution=0, name=None, verbosity=0, clipInput=True, forced=False): DCNL DCSP self._learningEnabled = True DCNL DCSP self._stateLock = False DCNL DCSP self.width = 0 DCNL DCSP self.encoders = None DCNL DCSP self.description = [] DCNL DCSP self.name = name DCNL DCSP if periodic: DCNL DCSP  DCSP raise Exception('Delta DCSP encoder DCSP does DCSP not DCSP encode DCSP periodic DCSP inputs') DCNL DCSP assert (n != 0) DCNL DCSP self._adaptiveScalarEnc = AdaptiveScalarEncoder(w=w, n=n, minval=minval, maxval=maxval, clipInput=True, name=name, verbosity=verbosity, forced=forced) DCNL DCSP self.width += self._adaptiveScalarEnc.getWidth() DCNL DCSP self.n = self._adaptiveScalarEnc.n DCNL DCSP self._prevAbsolute = None DCNL DCSP self._prevDelta = None
def topDownCompute(self, encoded): DCNL DCSP if ((self._prevAbsolute == None) or (self._prevDelta == None)): DCNL DCSP  DCSP return [EncoderResult(value=0, scalar=0, encoding=numpy.zeros(self.n))] DCNL DCSP ret = self._adaptiveScalarEnc.topDownCompute(encoded) DCNL DCSP if (self._prevAbsolute != None): DCNL DCSP  DCSP ret = [EncoderResult(value=(ret[0].value + self._prevAbsolute), scalar=(ret[0].scalar + self._prevAbsolute), encoding=ret[0].encoding)] DCNL DCSP return ret
def getDecoderOutputFieldTypes(self): DCNL DCSP return (FieldMetaType.float,)
def _getScaledValue(self, inpt): DCNL DCSP if (inpt == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP val = inpt DCNL DCSP  DCSP if (val < self.minval): DCNL DCSP  DCSP  DCSP val = self.minval DCNL DCSP  DCSP elif (val > self.maxval): DCNL DCSP  DCSP  DCSP val = self.maxval DCNL DCSP  DCSP scaledVal = math.log10(val) DCNL DCSP  DCSP return scaledVal
def getBucketIndices(self, inpt): DCNL DCSP scaledVal = self._getScaledValue(inpt) DCNL DCSP if (scaledVal is None): DCNL DCSP  DCSP return [None] DCNL DCSP else: DCNL DCSP  DCSP return self.encoder.getBucketIndices(scaledVal)
def encodeIntoArray(self, inpt, output): DCNL DCSP scaledVal = self._getScaledValue(inpt) DCNL DCSP if (scaledVal is None): DCNL DCSP  DCSP output[0:] = 0 DCNL DCSP else: DCNL DCSP  DCSP self.encoder.encodeIntoArray(scaledVal, output) DCNL DCSP  DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP  DCSP print 'input:', inpt, 'scaledVal:', scaledVal, 'output:', output DCNL DCSP  DCSP  DCSP print 'decoded:', self.decodedToStr(self.decode(output))
def decode(self, encoded, parentFieldName=''): DCNL DCSP (fieldsDict, fieldNames) = self.encoder.decode(encoded) DCNL DCSP if (len(fieldsDict) == 0): DCNL DCSP  DCSP return (fieldsDict, fieldNames) DCNL DCSP assert (len(fieldsDict) == 1) DCNL DCSP (inRanges, inDesc) = fieldsDict.values()[0] DCNL DCSP outRanges = [] DCNL DCSP for (minV, maxV) in inRanges: DCNL DCSP  DCSP outRanges.append((math.pow(10, minV), math.pow(10, maxV))) DCNL DCSP desc = '' DCNL DCSP numRanges = len(outRanges) DCNL DCSP for i in xrange(numRanges): DCNL DCSP  DCSP if (outRanges[i][0] != outRanges[i][1]): DCNL DCSP  DCSP  DCSP desc += ('%.2f-%.2f' % (outRanges[i][0], outRanges[i][1])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP desc += ('%.2f' % outRanges[i][0]) DCNL DCSP  DCSP if (i < (numRanges - 1)): DCNL DCSP  DCSP  DCSP desc += ', DCSP ' DCNL DCSP if (parentFieldName != ''): DCNL DCSP  DCSP fieldName = ('%s.%s' % (parentFieldName, self.name)) DCNL DCSP else: DCNL DCSP  DCSP fieldName = self.name DCNL DCSP return ({fieldName: (outRanges, desc)}, [fieldName])
def getBucketValues(self): DCNL DCSP if (self._bucketValues is None): DCNL DCSP  DCSP scaledValues = self.encoder.getBucketValues() DCNL DCSP  DCSP self._bucketValues = [] DCNL DCSP  DCSP for scaledValue in scaledValues: DCNL DCSP  DCSP  DCSP value = math.pow(10, scaledValue) DCNL DCSP  DCSP  DCSP self._bucketValues.append(value) DCNL DCSP return self._bucketValues
def getBucketInfo(self, buckets): DCNL DCSP scaledResult = self.encoder.getBucketInfo(buckets)[0] DCNL DCSP scaledValue = scaledResult.value DCNL DCSP value = math.pow(10, scaledValue) DCNL DCSP return [EncoderResult(value=value, scalar=value, encoding=scaledResult.encoding)]
def topDownCompute(self, encoded): DCNL DCSP scaledResult = self.encoder.topDownCompute(encoded)[0] DCNL DCSP scaledValue = scaledResult.value DCNL DCSP value = math.pow(10, scaledValue) DCNL DCSP return EncoderResult(value=value, scalar=value, encoding=scaledResult.encoding)
def closenessScores(self, expValues, actValues, fractional=True): DCNL DCSP if (expValues[0] > 0): DCNL DCSP  DCSP expValue = math.log10(expValues[0]) DCNL DCSP else: DCNL DCSP  DCSP expValue = self.minScaledValue DCNL DCSP if (actValues[0] > 0): DCNL DCSP  DCSP actValue = math.log10(actValues[0]) DCNL DCSP else: DCNL DCSP  DCSP actValue = self.minScaledValue DCNL DCSP if fractional: DCNL DCSP  DCSP err = abs((expValue - actValue)) DCNL DCSP  DCSP pctErr = (err / (self.maxScaledValue - self.minScaledValue)) DCNL DCSP  DCSP pctErr = min(1.0, pctErr) DCNL DCSP  DCSP closeness = (1.0 - pctErr) DCNL DCSP else: DCNL DCSP  DCSP err = abs((expValue - actValue)) DCNL DCSP  DCSP closeness = err DCNL DCSP return numpy.array([closeness])
def getDescription(self): DCNL DCSP return [('speed', 0), ('longitude', 1), ('latitude', 2), ('altitude', 3)]
def getScalars(self, inputData): DCNL DCSP return numpy.array(([0] * len(self.getDescription())))
def encodeIntoArray(self, inputData, output): DCNL DCSP altitude = None DCNL DCSP if (len(inputData) == 4): DCNL DCSP  DCSP (speed, longitude, latitude, altitude) = inputData DCNL DCSP else: DCNL DCSP  DCSP (speed, longitude, latitude) = inputData DCNL DCSP coordinate = self.coordinateForPosition(longitude, latitude, altitude) DCNL DCSP radius = self.radiusForSpeed(speed) DCNL DCSP super(GeospatialCoordinateEncoder, self).encodeIntoArray((coordinate, radius), output)
def coordinateForPosition(self, longitude, latitude, altitude=None): DCNL DCSP coords = PROJ(longitude, latitude) DCNL DCSP if (altitude is not None): DCNL DCSP  DCSP coords = transform(PROJ, geocentric, coords[0], coords[1], altitude) DCNL DCSP coordinate = numpy.array(coords) DCNL DCSP coordinate = (coordinate / self.scale) DCNL DCSP return coordinate.astype(int)
def radiusForSpeed(self, speed): DCNL DCSP overlap = 1.5 DCNL DCSP coordinatesPerTimestep = ((speed * self.timestep) / self.scale) DCNL DCSP radius = int(round(((float(coordinatesPerTimestep) / 2) * overlap))) DCNL DCSP minRadius = int(math.ceil(((math.sqrt(self.w) - 1) / 2))) DCNL DCSP return max(radius, minRadius)
def getWidth(self): DCNL DCSP raise NotImplementedError()
def encodeIntoArray(self, inputData, output): DCNL DCSP raise NotImplementedError()
def setLearning(self, learningEnabled): DCNL DCSP if hasattr(self, '_learningEnabled'): DCNL DCSP  DCSP self._learningEnabled = learningEnabled
def setFieldStats(self, fieldName, fieldStatistics): DCNL DCSP pass
def encode(self, inputData): DCNL DCSP output = numpy.zeros((self.getWidth(),), dtype=defaultDtype) DCNL DCSP self.encodeIntoArray(inputData, output) DCNL DCSP return output
def getScalarNames(self, parentFieldName=''): DCNL DCSP names = [] DCNL DCSP if (self.encoders is not None): DCNL DCSP  DCSP for (name, encoder, offset) in self.encoders: DCNL DCSP  DCSP  DCSP subNames = encoder.getScalarNames(parentFieldName=name) DCNL DCSP  DCSP  DCSP if (parentFieldName != ''): DCNL DCSP  DCSP  DCSP  DCSP subNames = [('%s.%s' % (parentFieldName, name)) for name in subNames] DCNL DCSP  DCSP  DCSP names.extend(subNames) DCNL DCSP elif (parentFieldName != ''): DCNL DCSP  DCSP names.append(parentFieldName) DCNL DCSP else: DCNL DCSP  DCSP names.append(self.name) DCNL DCSP return names
def getDecoderOutputFieldTypes(self): DCNL DCSP if (hasattr(self, '_flattenedFieldTypeList') and (self._flattenedFieldTypeList is not None)): DCNL DCSP  DCSP return self._flattenedFieldTypeList DCNL DCSP fieldTypes = [] DCNL DCSP for (name, encoder, offset) in self.encoders: DCNL DCSP  DCSP subTypes = encoder.getDecoderOutputFieldTypes() DCNL DCSP  DCSP fieldTypes.extend(subTypes) DCNL DCSP self._flattenedFieldTypeList = fieldTypes DCNL DCSP return fieldTypes
def setStateLock(self, lock): DCNL DCSP pass
def _getInputValue(self, obj, fieldName): DCNL DCSP if isinstance(obj, dict): DCNL DCSP  DCSP if (not (fieldName in obj)): DCNL DCSP  DCSP  DCSP knownFields = ', DCSP '.join((key for key in obj.keys() if (not key.startswith('_')))) DCNL DCSP  DCSP  DCSP raise ValueError(("Unknown DCSP field DCSP name DCSP '%s' DCSP in DCSP input DCSP record. DCSP Known DCSP fields DCSP are DCSP '%s'.\nThis DCSP could DCSP be DCSP because DCSP input DCSP headers DCSP are DCSP mislabeled, DCSP or DCSP because DCSP input DCSP data DCSP rows DCSP do DCSP not DCSP contain DCSP a DCSP value DCSP for DCSP '%s'." % (fieldName, knownFields, fieldName))) DCNL DCSP  DCSP return obj[fieldName] DCNL DCSP else: DCNL DCSP  DCSP return getattr(obj, fieldName)
def getEncoderList(self): DCNL DCSP if (hasattr(self, '_flattenedEncoderList') and (self._flattenedEncoderList is not None)): DCNL DCSP  DCSP return self._flattenedEncoderList DCNL DCSP encoders = [] DCNL DCSP if (self.encoders is not None): DCNL DCSP  DCSP for (name, encoder, offset) in self.encoders: DCNL DCSP  DCSP  DCSP subEncoders = encoder.getEncoderList() DCNL DCSP  DCSP  DCSP encoders.extend(subEncoders) DCNL DCSP else: DCNL DCSP  DCSP encoders.append(self) DCNL DCSP self._flattenedEncoderList = encoders DCNL DCSP return encoders
def getScalars(self, inputData): DCNL DCSP retVals = numpy.array([]) DCNL DCSP if (self.encoders is not None): DCNL DCSP  DCSP for (name, encoder, offset) in self.encoders: DCNL DCSP  DCSP  DCSP values = encoder.getScalars(self._getInputValue(inputData, name)) DCNL DCSP  DCSP  DCSP retVals = numpy.hstack((retVals, values)) DCNL DCSP else: DCNL DCSP  DCSP retVals = numpy.hstack((retVals, inputData)) DCNL DCSP return retVals
def getEncodedValues(self, inputData): DCNL DCSP retVals = [] DCNL DCSP if (self.encoders is not None): DCNL DCSP  DCSP for (name, encoders, offset) in self.encoders: DCNL DCSP  DCSP  DCSP values = encoders.getEncodedValues(self._getInputValue(inputData, name)) DCNL DCSP  DCSP  DCSP if _isSequence(values): DCNL DCSP  DCSP  DCSP  DCSP retVals.extend(values) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP retVals.append(values) DCNL DCSP elif _isSequence(inputData): DCNL DCSP  DCSP retVals.extend(inputData) DCNL DCSP else: DCNL DCSP  DCSP retVals.append(inputData) DCNL DCSP return tuple(retVals)
def getBucketIndices(self, inputData): DCNL DCSP retVals = [] DCNL DCSP if (self.encoders is not None): DCNL DCSP  DCSP for (name, encoder, offset) in self.encoders: DCNL DCSP  DCSP  DCSP values = encoder.getBucketIndices(self._getInputValue(inputData, name)) DCNL DCSP  DCSP  DCSP retVals.extend(values) DCNL DCSP else: DCNL DCSP  DCSP assert False, 'Should DCSP be DCSP implemented DCSP in DCSP base DCSP classes DCSP that DCSP are DCSP not DCSP containers DCSP for DCSP other DCSP encoders' DCNL DCSP return retVals
def scalarsToStr(self, scalarValues, scalarNames=None): DCNL DCSP if (scalarNames is None): DCNL DCSP  DCSP scalarNames = self.getScalarNames() DCNL DCSP desc = '' DCNL DCSP for (name, value) in zip(scalarNames, scalarValues): DCNL DCSP  DCSP if (len(desc) > 0): DCNL DCSP  DCSP  DCSP desc += (', DCSP %s:%.2f' % (name, value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP desc += ('%s:%.2f' % (name, value)) DCNL DCSP return desc
def getDescription(self): DCNL DCSP raise Exception('getDescription DCSP must DCSP be DCSP implemented DCSP by DCSP all DCSP subclasses')
def getFieldDescription(self, fieldName): DCNL DCSP description = (self.getDescription() + [('end', self.getWidth())]) DCNL DCSP for i in xrange(len(description)): DCNL DCSP  DCSP (name, offset) = description[i] DCNL DCSP  DCSP if (name == fieldName): DCNL DCSP  DCSP  DCSP break DCNL DCSP if (i >= (len(description) - 1)): DCNL DCSP  DCSP raise RuntimeError(('Field DCSP name DCSP %s DCSP not DCSP found DCSP in DCSP this DCSP encoder' % fieldName)) DCNL DCSP return (offset, (description[(i + 1)][1] - offset))
def encodedBitDescription(self, bitOffset, formatted=False): DCNL DCSP (prevFieldName, prevFieldOffset) = (None, None) DCNL DCSP description = self.getDescription() DCNL DCSP for i in xrange(len(description)): DCNL DCSP  DCSP (name, offset) = description[i] DCNL DCSP  DCSP if formatted: DCNL DCSP  DCSP  DCSP offset = (offset + i) DCNL DCSP  DCSP  DCSP if (bitOffset == (offset - 1)): DCNL DCSP  DCSP  DCSP  DCSP prevFieldName = 'separator' DCNL DCSP  DCSP  DCSP  DCSP prevFieldOffset = bitOffset DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (bitOffset < offset): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (prevFieldName, prevFieldOffset) = (name, offset) DCNL DCSP width = (self.getDisplayWidth() if formatted else self.getWidth()) DCNL DCSP if ((prevFieldOffset is None) or (bitOffset > self.getWidth())): DCNL DCSP  DCSP raise IndexError(('Bit DCSP is DCSP outside DCSP of DCSP allowable DCSP range: DCSP [0 DCSP - DCSP %d]' % width)) DCNL DCSP return (prevFieldName, (bitOffset - prevFieldOffset))
def pprintHeader(self, prefix=''): DCNL DCSP print prefix, DCNL DCSP description = (self.getDescription() + [('end', self.getWidth())]) DCNL DCSP for i in xrange((len(description) - 1)): DCNL DCSP  DCSP name = description[i][0] DCNL DCSP  DCSP width = (description[(i + 1)][1] - description[i][1]) DCNL DCSP  DCSP formatStr = ('%%-%ds DCSP |' % width) DCNL DCSP  DCSP if (len(name) > width): DCNL DCSP  DCSP  DCSP pname = name[0:width] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pname = name DCNL DCSP  DCSP print (formatStr % pname), DCNL DCSP print DCNL DCSP print prefix, ('-' * ((self.getWidth() + ((len(description) - 1) * 3)) - 1))
def pprint(self, output, prefix=''): DCNL DCSP print prefix, DCNL DCSP description = (self.getDescription() + [('end', self.getWidth())]) DCNL DCSP for i in xrange((len(description) - 1)): DCNL DCSP  DCSP offset = description[i][1] DCNL DCSP  DCSP nextoffset = description[(i + 1)][1] DCNL DCSP  DCSP print ('%s DCSP |' % bitsToString(output[offset:nextoffset])), DCNL DCSP print
def decode(self, encoded, parentFieldName=''): DCNL DCSP fieldsDict = dict() DCNL DCSP fieldsOrder = [] DCNL DCSP if (parentFieldName == ''): DCNL DCSP  DCSP parentName = self.name DCNL DCSP else: DCNL DCSP  DCSP parentName = ('%s.%s' % (parentFieldName, self.name)) DCNL DCSP if (self.encoders is not None): DCNL DCSP  DCSP for i in xrange(len(self.encoders)): DCNL DCSP  DCSP  DCSP (name, encoder, offset) = self.encoders[i] DCNL DCSP  DCSP  DCSP if (i < (len(self.encoders) - 1)): DCNL DCSP  DCSP  DCSP  DCSP nextOffset = self.encoders[(i + 1)][2] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP nextOffset = self.width DCNL DCSP  DCSP  DCSP fieldOutput = encoded[offset:nextOffset] DCNL DCSP  DCSP  DCSP (subFieldsDict, subFieldsOrder) = encoder.decode(fieldOutput, parentFieldName=parentName) DCNL DCSP  DCSP  DCSP fieldsDict.update(subFieldsDict) DCNL DCSP  DCSP  DCSP fieldsOrder.extend(subFieldsOrder) DCNL DCSP return (fieldsDict, fieldsOrder)
def decodedToStr(self, decodeResults): DCNL DCSP (fieldsDict, fieldsOrder) = decodeResults DCNL DCSP desc = '' DCNL DCSP for fieldName in fieldsOrder: DCNL DCSP  DCSP (ranges, rangesStr) = fieldsDict[fieldName] DCNL DCSP  DCSP if (len(desc) > 0): DCNL DCSP  DCSP  DCSP desc += (', DCSP %s:' % fieldName) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP desc += ('%s:' % fieldName) DCNL DCSP  DCSP desc += ('[%s]' % rangesStr) DCNL DCSP return desc
def getBucketValues(self): DCNL DCSP raise Exception('getBucketValues DCSP must DCSP be DCSP implemented DCSP by DCSP all DCSP subclasses')
def getBucketInfo(self, buckets): DCNL DCSP if (self.encoders is None): DCNL DCSP  DCSP raise RuntimeError('Must DCSP be DCSP implemented DCSP in DCSP sub-class') DCNL DCSP retVals = [] DCNL DCSP bucketOffset = 0 DCNL DCSP for i in xrange(len(self.encoders)): DCNL DCSP  DCSP (name, encoder, offset) = self.encoders[i] DCNL DCSP  DCSP if (encoder.encoders is not None): DCNL DCSP  DCSP  DCSP nextBucketOffset = (bucketOffset + len(encoder.encoders)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP nextBucketOffset = (bucketOffset + 1) DCNL DCSP  DCSP bucketIndices = buckets[bucketOffset:nextBucketOffset] DCNL DCSP  DCSP values = encoder.getBucketInfo(bucketIndices) DCNL DCSP  DCSP retVals.extend(values) DCNL DCSP  DCSP bucketOffset = nextBucketOffset DCNL DCSP return retVals
def topDownCompute(self, encoded): DCNL DCSP if (self.encoders is None): DCNL DCSP  DCSP raise RuntimeError('Must DCSP be DCSP implemented DCSP in DCSP sub-class') DCNL DCSP retVals = [] DCNL DCSP for i in xrange(len(self.encoders)): DCNL DCSP  DCSP (name, encoder, offset) = self.encoders[i] DCNL DCSP  DCSP if (i < (len(self.encoders) - 1)): DCNL DCSP  DCSP  DCSP nextOffset = self.encoders[(i + 1)][2] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP nextOffset = self.width DCNL DCSP  DCSP fieldOutput = encoded[offset:nextOffset] DCNL DCSP  DCSP values = encoder.topDownCompute(fieldOutput) DCNL DCSP  DCSP if _isSequence(values): DCNL DCSP  DCSP  DCSP retVals.extend(values) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP retVals.append(values) DCNL DCSP return retVals
def closenessScores(self, expValues, actValues, fractional=True): DCNL DCSP if (self.encoders is None): DCNL DCSP  DCSP err = abs((expValues[0] - actValues[0])) DCNL DCSP  DCSP if fractional: DCNL DCSP  DCSP  DCSP denom = max(expValues[0], actValues[0]) DCNL DCSP  DCSP  DCSP if (denom == 0): DCNL DCSP  DCSP  DCSP  DCSP denom = 1.0 DCNL DCSP  DCSP  DCSP closeness = (1.0 - (float(err) / denom)) DCNL DCSP  DCSP  DCSP if (closeness < 0): DCNL DCSP  DCSP  DCSP  DCSP closeness = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP closeness = err DCNL DCSP  DCSP return numpy.array([closeness]) DCNL DCSP scalarIdx = 0 DCNL DCSP retVals = numpy.array([]) DCNL DCSP for (name, encoder, offset) in self.encoders: DCNL DCSP  DCSP values = encoder.closenessScores(expValues[scalarIdx:], actValues[scalarIdx:], fractional=fractional) DCNL DCSP  DCSP scalarIdx += len(values) DCNL DCSP  DCSP retVals = numpy.hstack((retVals, values)) DCNL DCSP return retVals
def getDisplayWidth(self): DCNL DCSP width = ((self.getWidth() + len(self.getDescription())) - 1) DCNL DCSP return width
def getDecoderOutputFieldTypes(self): DCNL DCSP return (FieldMetaType.string,)
def getScalars(self, input): DCNL DCSP return numpy.array([0])
def getBucketIndices(self, input): DCNL DCSP return [0]
def encodeIntoArray(self, inputVal, outputVal): DCNL DCSP if (len(inputVal) != len(outputVal)): DCNL DCSP  DCSP raise ValueError(('Different DCSP input DCSP (%i) DCSP and DCSP output DCSP (%i) DCSP sizes.' % (len(inputVal), len(outputVal)))) DCNL DCSP if ((self.w is not None) and (sum(inputVal) != self.w)): DCNL DCSP  DCSP raise ValueError(('Input DCSP has DCSP %i DCSP bits DCSP but DCSP w DCSP was DCSP set DCSP to DCSP %i.' % (sum(inputVal), self.w))) DCNL DCSP outputVal[:] = inputVal[:] DCNL DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP print 'input:', inputVal, 'output:', outputVal DCNL DCSP  DCSP print 'decoded:', self.decodedToStr(self.decode(outputVal))
def decode(self, encoded, parentFieldName=''): DCNL DCSP if (parentFieldName != ''): DCNL DCSP  DCSP fieldName = ('%s.%s' % (parentFieldName, self.name)) DCNL DCSP else: DCNL DCSP  DCSP fieldName = self.name DCNL DCSP return ({fieldName: ([[0, 0]], 'input')}, [fieldName])
def getBucketInfo(self, buckets): DCNL DCSP return [EncoderResult(value=0, scalar=0, encoding=numpy.zeros(self.n))]
def topDownCompute(self, encoded): DCNL DCSP return EncoderResult(value=0, scalar=0, encoding=numpy.zeros(self.n))
def closenessScores(self, expValues, actValues, **kwargs): DCNL DCSP ratio = 1.0 DCNL DCSP esum = int(expValues.sum()) DCNL DCSP asum = int(actValues.sum()) DCNL DCSP if (asum > esum): DCNL DCSP  DCSP diff = (asum - esum) DCNL DCSP  DCSP if (diff < esum): DCNL DCSP  DCSP  DCSP ratio = (1 - (diff / float(esum))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ratio = (1 / float(diff)) DCNL DCSP olap = (expValues & actValues) DCNL DCSP osum = int(olap.sum()) DCNL DCSP if (esum == 0): DCNL DCSP  DCSP r = 0.0 DCNL DCSP else: DCNL DCSP  DCSP r = (osum / float(esum)) DCNL DCSP r = (r * ratio) DCNL DCSP return numpy.array([r])
def getDecoderOutputFieldTypes(self): DCNL DCSP return (FieldMetaType.integer,)
def getScalars(self, input): DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP return numpy.array([None]) DCNL DCSP else: DCNL DCSP  DCSP return numpy.array([self.categoryToIndex.get(input, 0)])
def getBucketIndices(self, input): DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP return [None] DCNL DCSP else: DCNL DCSP  DCSP return self.encoder.getBucketIndices(self.categoryToIndex.get(input, 0))
def decode(self, encoded, parentFieldName=''): DCNL DCSP (fieldsDict, fieldNames) = self.encoder.decode(encoded) DCNL DCSP if (len(fieldsDict) == 0): DCNL DCSP  DCSP return (fieldsDict, fieldNames) DCNL DCSP assert (len(fieldsDict) == 1) DCNL DCSP (inRanges, inDesc) = fieldsDict.values()[0] DCNL DCSP outRanges = [] DCNL DCSP desc = '' DCNL DCSP for (minV, maxV) in inRanges: DCNL DCSP  DCSP minV = int(round(minV)) DCNL DCSP  DCSP maxV = int(round(maxV)) DCNL DCSP  DCSP outRanges.append((minV, maxV)) DCNL DCSP  DCSP while (minV <= maxV): DCNL DCSP  DCSP  DCSP if (len(desc) > 0): DCNL DCSP  DCSP  DCSP  DCSP desc += ', DCSP ' DCNL DCSP  DCSP  DCSP desc += self.indexToCategory[minV] DCNL DCSP  DCSP  DCSP minV += 1 DCNL DCSP if (parentFieldName != ''): DCNL DCSP  DCSP fieldName = ('%s.%s' % (parentFieldName, self.name)) DCNL DCSP else: DCNL DCSP  DCSP fieldName = self.name DCNL DCSP return ({fieldName: (outRanges, desc)}, [fieldName])
def closenessScores(self, expValues, actValues, fractional=True): DCNL DCSP expValue = expValues[0] DCNL DCSP actValue = actValues[0] DCNL DCSP if (expValue == actValue): DCNL DCSP  DCSP closeness = 1.0 DCNL DCSP else: DCNL DCSP  DCSP closeness = 0.0 DCNL DCSP if (not fractional): DCNL DCSP  DCSP closeness = (1.0 - closeness) DCNL DCSP return numpy.array([closeness])
def getBucketValues(self): DCNL DCSP if (self._bucketValues is None): DCNL DCSP  DCSP numBuckets = len(self.encoder.getBucketValues()) DCNL DCSP  DCSP self._bucketValues = [] DCNL DCSP  DCSP for bucketIndex in range(numBuckets): DCNL DCSP  DCSP  DCSP self._bucketValues.append(self.getBucketInfo([bucketIndex])[0].value) DCNL DCSP return self._bucketValues
def getBucketInfo(self, buckets): DCNL DCSP bucketInfo = self.encoder.getBucketInfo(buckets)[0] DCNL DCSP categoryIndex = int(round(bucketInfo.value)) DCNL DCSP category = self.indexToCategory[categoryIndex] DCNL DCSP return [EncoderResult(value=category, scalar=categoryIndex, encoding=bucketInfo.encoding)]
def topDownCompute(self, encoded): DCNL DCSP encoderResult = self.encoder.topDownCompute(encoded)[0] DCNL DCSP value = encoderResult.value DCNL DCSP categoryIndex = int(round(value)) DCNL DCSP category = self.indexToCategory[categoryIndex] DCNL DCSP return EncoderResult(value=category, scalar=categoryIndex, encoding=encoderResult.encoding)
def _setEncoderParams(self): DCNL DCSP self.rangeInternal = float((self.maxval - self.minval)) DCNL DCSP self.resolution = (float(self.rangeInternal) / (self.n - self.w)) DCNL DCSP self.radius = (self.w * self.resolution) DCNL DCSP self.range = (self.rangeInternal + self.resolution) DCNL DCSP self.nInternal = (self.n - (2 * self.padding)) DCNL DCSP self._bucketValues = None
def setFieldStats(self, fieldName, fieldStats): DCNL DCSP if ((fieldStats[fieldName]['min'] == None) or (fieldStats[fieldName]['max'] == None)): DCNL DCSP  DCSP return DCNL DCSP self.minval = fieldStats[fieldName]['min'] DCNL DCSP self.maxval = fieldStats[fieldName]['max'] DCNL DCSP if (self.minval == self.maxval): DCNL DCSP  DCSP self.maxval += 1 DCNL DCSP self._setEncoderParams()
def _setMinAndMax(self, input, learn): DCNL DCSP self.slidingWindow.next(input) DCNL DCSP if ((self.minval is None) and (self.maxval is None)): DCNL DCSP  DCSP self.minval = input DCNL DCSP  DCSP self.maxval = (input + 1) DCNL DCSP  DCSP self._setEncoderParams() DCNL DCSP elif learn: DCNL DCSP  DCSP sorted = self.slidingWindow.getSlidingWindow() DCNL DCSP  DCSP sorted.sort() DCNL DCSP  DCSP minOverWindow = sorted[0] DCNL DCSP  DCSP maxOverWindow = sorted[(len(sorted) - 1)] DCNL DCSP  DCSP if (minOverWindow < self.minval): DCNL DCSP  DCSP  DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP print ('Input DCSP %s=%.2f DCSP smaller DCSP than DCSP minval DCSP %.2f. DCSP Adjusting DCSP minval DCSP to DCSP %.2f' % (self.name, input, self.minval, minOverWindow)) DCNL DCSP  DCSP  DCSP self.minval = minOverWindow DCNL DCSP  DCSP  DCSP self._setEncoderParams() DCNL DCSP  DCSP if (maxOverWindow > self.maxval): DCNL DCSP  DCSP  DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP print ('Input DCSP %s=%.2f DCSP greater DCSP than DCSP maxval DCSP %.2f. DCSP Adjusting DCSP maxval DCSP to DCSP %.2f' % (self.name, input, self.maxval, maxOverWindow)) DCNL DCSP  DCSP  DCSP self.maxval = maxOverWindow DCNL DCSP  DCSP  DCSP self._setEncoderParams()
def getBucketIndices(self, input, learn=None): DCNL DCSP self.recordNum += 1 DCNL DCSP if (learn is None): DCNL DCSP  DCSP learn = self._learningEnabled DCNL DCSP if ((type(input) is float) and math.isnan(input)): DCNL DCSP  DCSP input = SENTINEL_VALUE_FOR_MISSING_DATA DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP return [None] DCNL DCSP else: DCNL DCSP  DCSP self._setMinAndMax(input, learn) DCNL DCSP  DCSP return super(AdaptiveScalarEncoder, self).getBucketIndices(input)
def encodeIntoArray(self, input, output, learn=None): DCNL DCSP self.recordNum += 1 DCNL DCSP if (learn is None): DCNL DCSP  DCSP learn = self._learningEnabled DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP output[0:self.n] = 0 DCNL DCSP elif (not math.isnan(input)): DCNL DCSP  DCSP self._setMinAndMax(input, learn) DCNL DCSP super(AdaptiveScalarEncoder, self).encodeIntoArray(input, output)
def getBucketInfo(self, buckets): DCNL DCSP if ((self.minval is None) or (self.maxval is None)): DCNL DCSP  DCSP return [EncoderResult(value=0, scalar=0, encoding=numpy.zeros(self.n))] DCNL DCSP return super(AdaptiveScalarEncoder, self).getBucketInfo(buckets)
def topDownCompute(self, encoded): DCNL DCSP if ((self.minval is None) or (self.maxval is None)): DCNL DCSP  DCSP return [EncoderResult(value=0, scalar=0, encoding=numpy.zeros(self.n))] DCNL DCSP return super(AdaptiveScalarEncoder, self).topDownCompute(encoded)
def _seed(self, seed=(-1)): DCNL DCSP if (seed != (-1)): DCNL DCSP  DCSP self.random = NupicRandom(seed) DCNL DCSP else: DCNL DCSP  DCSP self.random = NupicRandom()
def getDecoderOutputFieldTypes(self): DCNL DCSP return (FieldMetaType.string,)
def _newRep(self): DCNL DCSP maxAttempts = 1000 DCNL DCSP for _ in xrange(maxAttempts): DCNL DCSP  DCSP foundUnique = True DCNL DCSP  DCSP population = numpy.arange(self.n, dtype=numpy.uint32) DCNL DCSP  DCSP choices = numpy.arange(self.w, dtype=numpy.uint32) DCNL DCSP  DCSP oneBits = sorted(self.random.sample(population, choices)) DCNL DCSP  DCSP sdr = numpy.zeros(self.n, dtype='uint8') DCNL DCSP  DCSP sdr[oneBits] = 1 DCNL DCSP  DCSP for i in xrange(self.ncategories): DCNL DCSP  DCSP  DCSP if (sdr == self.sdrs[i]).all(): DCNL DCSP  DCSP  DCSP  DCSP foundUnique = False DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if foundUnique: DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not foundUnique): DCNL DCSP  DCSP raise RuntimeError(('Error, DCSP could DCSP not DCSP find DCSP unique DCSP pattern DCSP %d DCSP after DCSP %d DCSP attempts' % (self.ncategories, maxAttempts))) DCNL DCSP return sdr
def getScalars(self, input): DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP return numpy.array([0]) DCNL DCSP index = self.categoryToIndex.get(input, None) DCNL DCSP if (index is None): DCNL DCSP  DCSP if self._learningEnabled: DCNL DCSP  DCSP  DCSP self._addCategory(input) DCNL DCSP  DCSP  DCSP index = (self.ncategories - 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP index = 0 DCNL DCSP return numpy.array([index])
def getBucketIndices(self, input): DCNL DCSP return self.getScalars(input)
def decode(self, encoded, parentFieldName=''): DCNL DCSP assert (encoded[0:self.n] <= 1.0).all() DCNL DCSP resultString = '' DCNL DCSP resultRanges = [] DCNL DCSP overlaps = (self.sdrs * encoded[0:self.n]).sum(axis=1) DCNL DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP print 'Overlaps DCSP for DCSP decoding:' DCNL DCSP  DCSP for i in xrange(0, self.ncategories): DCNL DCSP  DCSP  DCSP print ('%d DCSP %s' % (overlaps[i], self.categories[i])) DCNL DCSP matchingCategories = (overlaps > self.thresholdOverlap).nonzero()[0] DCNL DCSP for index in matchingCategories: DCNL DCSP  DCSP if (resultString != ''): DCNL DCSP  DCSP  DCSP resultString += ' DCSP ' DCNL DCSP  DCSP resultString += str(self.categories[index]) DCNL DCSP  DCSP resultRanges.append([int(index), int(index)]) DCNL DCSP if (parentFieldName != ''): DCNL DCSP  DCSP fieldName = ('%s.%s' % (parentFieldName, self.name)) DCNL DCSP else: DCNL DCSP  DCSP fieldName = self.name DCNL DCSP return ({fieldName: (resultRanges, resultString)}, [fieldName])
def _getTopDownMapping(self): DCNL DCSP if (self._topDownMappingM is None): DCNL DCSP  DCSP self._topDownMappingM = SM32(self.ncategories, self.n) DCNL DCSP  DCSP outputSpace = numpy.zeros(self.n, dtype=GetNTAReal()) DCNL DCSP  DCSP for i in xrange(self.ncategories): DCNL DCSP  DCSP  DCSP self.encodeIntoArray(self.categories[i], outputSpace) DCNL DCSP  DCSP  DCSP self._topDownMappingM.setRowFromDense(i, outputSpace) DCNL DCSP return self._topDownMappingM
def getBucketValues(self): DCNL DCSP return self.categories
def getBucketInfo(self, buckets): DCNL DCSP if (self.ncategories == 0): DCNL DCSP  DCSP return 0 DCNL DCSP topDownMappingM = self._getTopDownMapping() DCNL DCSP categoryIndex = buckets[0] DCNL DCSP category = self.categories[categoryIndex] DCNL DCSP encoding = topDownMappingM.getRow(categoryIndex) DCNL DCSP return [EncoderResult(value=category, scalar=categoryIndex, encoding=encoding)]
def topDownCompute(self, encoded): DCNL DCSP if (self.ncategories == 0): DCNL DCSP  DCSP return 0 DCNL DCSP topDownMappingM = self._getTopDownMapping() DCNL DCSP categoryIndex = topDownMappingM.rightVecProd(encoded).argmax() DCNL DCSP category = self.categories[categoryIndex] DCNL DCSP encoding = topDownMappingM.getRow(categoryIndex) DCNL DCSP return EncoderResult(value=category, scalar=categoryIndex, encoding=encoding)
def closenessScores(self, expValues, actValues, fractional=True): DCNL DCSP expValue = expValues[0] DCNL DCSP actValue = actValues[0] DCNL DCSP if (expValue == actValue): DCNL DCSP  DCSP closeness = 1.0 DCNL DCSP else: DCNL DCSP  DCSP closeness = 0.0 DCNL DCSP if (not fractional): DCNL DCSP  DCSP closeness = (1.0 - closeness) DCNL DCSP return numpy.array([closeness])
def _seed(self, seed=(-1)): DCNL DCSP if (seed != (-1)): DCNL DCSP  DCSP self.random = NupicRandom(seed) DCNL DCSP else: DCNL DCSP  DCSP self.random = NupicRandom()
def getDecoderOutputFieldTypes(self): DCNL DCSP return (FieldMetaType.float,)
def getWidth(self): DCNL DCSP return self.n
def getBucketIndices(self, x): DCNL DCSP if ((isinstance(x, float) and math.isnan(x)) or (x == SENTINEL_VALUE_FOR_MISSING_DATA)): DCNL DCSP  DCSP return [None] DCNL DCSP if (self._offset is None): DCNL DCSP  DCSP self._offset = x DCNL DCSP bucketIdx = ((self._maxBuckets / 2) + int(round(((x - self._offset) / self.resolution)))) DCNL DCSP if (bucketIdx < 0): DCNL DCSP  DCSP bucketIdx = 0 DCNL DCSP elif (bucketIdx >= self._maxBuckets): DCNL DCSP  DCSP bucketIdx = (self._maxBuckets - 1) DCNL DCSP return [bucketIdx]
def mapBucketIndexToNonZeroBits(self, index): DCNL DCSP if (index < 0): DCNL DCSP  DCSP index = 0 DCNL DCSP if (index >= self._maxBuckets): DCNL DCSP  DCSP index = (self._maxBuckets - 1) DCNL DCSP if (not self.bucketMap.has_key(index)): DCNL DCSP  DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP  DCSP print 'Adding DCSP additional DCSP buckets DCSP to DCSP handle DCSP index=', index DCNL DCSP  DCSP self._createBucket(index) DCNL DCSP return self.bucketMap[index]
def encodeIntoArray(self, x, output): DCNL DCSP if ((x is not None) and (not isinstance(x, numbers.Number))): DCNL DCSP  DCSP raise TypeError(('Expected DCSP a DCSP scalar DCSP input DCSP but DCSP got DCSP input DCSP of DCSP type DCSP %s' % type(x))) DCNL DCSP bucketIdx = self.getBucketIndices(x)[0] DCNL DCSP output[0:self.n] = 0 DCNL DCSP if (bucketIdx is not None): DCNL DCSP  DCSP output[self.mapBucketIndexToNonZeroBits(bucketIdx)] = 1
def _createBucket(self, index): DCNL DCSP if (index < self.minIndex): DCNL DCSP  DCSP if (index == (self.minIndex - 1)): DCNL DCSP  DCSP  DCSP self.bucketMap[index] = self._newRepresentation(self.minIndex, index) DCNL DCSP  DCSP  DCSP self.minIndex = index DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._createBucket((index + 1)) DCNL DCSP  DCSP  DCSP self._createBucket(index) DCNL DCSP elif (index == (self.maxIndex + 1)): DCNL DCSP  DCSP self.bucketMap[index] = self._newRepresentation(self.maxIndex, index) DCNL DCSP  DCSP self.maxIndex = index DCNL DCSP else: DCNL DCSP  DCSP self._createBucket((index - 1)) DCNL DCSP  DCSP self._createBucket(index)
def _newRepresentation(self, index, newIndex): DCNL DCSP newRepresentation = self.bucketMap[index].copy() DCNL DCSP ri = (newIndex % self.w) DCNL DCSP newBit = self.random.getUInt32(self.n) DCNL DCSP newRepresentation[ri] = newBit DCNL DCSP while ((newBit in self.bucketMap[index]) or (not self._newRepresentationOK(newRepresentation, newIndex))): DCNL DCSP  DCSP self.numTries += 1 DCNL DCSP  DCSP newBit = self.random.getUInt32(self.n) DCNL DCSP  DCSP newRepresentation[ri] = newBit DCNL DCSP return newRepresentation
def _newRepresentationOK(self, newRep, newIndex): DCNL DCSP if (newRep.size != self.w): DCNL DCSP  DCSP return False DCNL DCSP if ((newIndex < (self.minIndex - 1)) or (newIndex > (self.maxIndex + 1))): DCNL DCSP  DCSP raise ValueError('newIndex DCSP must DCSP be DCSP within DCSP one DCSP of DCSP existing DCSP indices') DCNL DCSP newRepBinary = numpy.array(([False] * self.n)) DCNL DCSP newRepBinary[newRep] = True DCNL DCSP midIdx = (self._maxBuckets / 2) DCNL DCSP runningOverlap = self._countOverlap(self.bucketMap[self.minIndex], newRep) DCNL DCSP if (not self._overlapOK(self.minIndex, newIndex, overlap=runningOverlap)): DCNL DCSP  DCSP return False DCNL DCSP for i in range((self.minIndex + 1), (midIdx + 1)): DCNL DCSP  DCSP newBit = ((i - 1) % self.w) DCNL DCSP  DCSP if newRepBinary[self.bucketMap[(i - 1)][newBit]]: DCNL DCSP  DCSP  DCSP runningOverlap -= 1 DCNL DCSP  DCSP if newRepBinary[self.bucketMap[i][newBit]]: DCNL DCSP  DCSP  DCSP runningOverlap += 1 DCNL DCSP  DCSP if (not self._overlapOK(i, newIndex, overlap=runningOverlap)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP for i in range((midIdx + 1), (self.maxIndex + 1)): DCNL DCSP  DCSP newBit = (i % self.w) DCNL DCSP  DCSP if newRepBinary[self.bucketMap[(i - 1)][newBit]]: DCNL DCSP  DCSP  DCSP runningOverlap -= 1 DCNL DCSP  DCSP if newRepBinary[self.bucketMap[i][newBit]]: DCNL DCSP  DCSP  DCSP runningOverlap += 1 DCNL DCSP  DCSP if (not self._overlapOK(i, newIndex, overlap=runningOverlap)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
def _countOverlapIndices(self, i, j): DCNL DCSP if (self.bucketMap.has_key(i) and self.bucketMap.has_key(j)): DCNL DCSP  DCSP iRep = self.bucketMap[i] DCNL DCSP  DCSP jRep = self.bucketMap[j] DCNL DCSP  DCSP return self._countOverlap(iRep, jRep) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError("Either DCSP i DCSP or DCSP j DCSP don't DCSP exist")
@staticmethod DCNL def _countOverlap(rep1, rep2): DCNL DCSP overlap = 0 DCNL DCSP for e in rep1: DCNL DCSP  DCSP if (e in rep2): DCNL DCSP  DCSP  DCSP overlap += 1 DCNL DCSP return overlap
def _overlapOK(self, i, j, overlap=None): DCNL DCSP if (overlap is None): DCNL DCSP  DCSP overlap = self._countOverlapIndices(i, j) DCNL DCSP if (abs((i - j)) < self.w): DCNL DCSP  DCSP if (overlap == (self.w - abs((i - j)))): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP elif (overlap <= self._maxOverlap): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def _initializeBucketMap(self, maxBuckets, offset): DCNL DCSP self._maxBuckets = maxBuckets DCNL DCSP self.minIndex = (self._maxBuckets / 2) DCNL DCSP self.maxIndex = (self._maxBuckets / 2) DCNL DCSP self._offset = offset DCNL DCSP self.bucketMap = {} DCNL DCSP def _permutation(n): DCNL DCSP  DCSP r = numpy.arange(n, dtype=numpy.uint32) DCNL DCSP  DCSP self.random.shuffle(r) DCNL DCSP  DCSP return r DCNL DCSP self.bucketMap[self.minIndex] = _permutation(self.n)[0:self.w] DCNL DCSP self.numTries = 0
def _initEncoder(self, w, minval, maxval, n, radius, resolution): DCNL DCSP if (n != 0): DCNL DCSP  DCSP if ((radius != 0) or (resolution != 0)): DCNL DCSP  DCSP  DCSP raise ValueError('Only DCSP one DCSP of DCSP n/radius/resolution DCSP can DCSP be DCSP specified DCSP for DCSP a DCSP ScalarEncoder') DCNL DCSP  DCSP assert (n > w) DCNL DCSP  DCSP self.n = n DCNL DCSP  DCSP if ((minval is not None) and (maxval is not None)): DCNL DCSP  DCSP  DCSP if (not self.periodic): DCNL DCSP  DCSP  DCSP  DCSP self.resolution = (float(self.rangeInternal) / (self.n - self.w)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self.resolution = (float(self.rangeInternal) / self.n) DCNL DCSP  DCSP  DCSP self.radius = (self.w * self.resolution) DCNL DCSP  DCSP  DCSP if self.periodic: DCNL DCSP  DCSP  DCSP  DCSP self.range = self.rangeInternal DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self.range = (self.rangeInternal + self.resolution) DCNL DCSP else: DCNL DCSP  DCSP if (radius != 0): DCNL DCSP  DCSP  DCSP if (resolution != 0): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Only DCSP one DCSP of DCSP radius/resolution DCSP can DCSP be DCSP specified DCSP for DCSP a DCSP ScalarEncoder') DCNL DCSP  DCSP  DCSP self.radius = radius DCNL DCSP  DCSP  DCSP self.resolution = (float(self.radius) / w) DCNL DCSP  DCSP elif (resolution != 0): DCNL DCSP  DCSP  DCSP self.resolution = float(resolution) DCNL DCSP  DCSP  DCSP self.radius = (self.resolution * self.w) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception('One DCSP of DCSP n, DCSP radius, DCSP resolution DCSP must DCSP be DCSP specified DCSP for DCSP a DCSP ScalarEncoder') DCNL DCSP  DCSP if ((minval is not None) and (maxval is not None)): DCNL DCSP  DCSP  DCSP if self.periodic: DCNL DCSP  DCSP  DCSP  DCSP self.range = self.rangeInternal DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self.range = (self.rangeInternal + self.resolution) DCNL DCSP  DCSP  DCSP nfloat = ((self.w * (self.range / self.radius)) + (2 * self.padding)) DCNL DCSP  DCSP  DCSP self.n = int(math.ceil(nfloat))
def _checkReasonableSettings(self): DCNL DCSP if (self.w < 21): DCNL DCSP  DCSP raise ValueError(('Number DCSP of DCSP bits DCSP in DCSP the DCSP SDR DCSP (%d) DCSP must DCSP be DCSP >= DCSP 21 DCSP (use DCSP forced=True DCSP to DCSP override).' % self.w))
def getDecoderOutputFieldTypes(self): DCNL DCSP return (FieldMetaType.float,)
def _getFirstOnBit(self, input): DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP return [None] DCNL DCSP else: DCNL DCSP  DCSP if (input < self.minval): DCNL DCSP  DCSP  DCSP if (self.clipInput and (not self.periodic)): DCNL DCSP  DCSP  DCSP  DCSP if (self.verbosity > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('Clipped DCSP input DCSP %s=%.2f DCSP to DCSP minval DCSP %.2f' % (self.name, input, self.minval)) DCNL DCSP  DCSP  DCSP  DCSP input = self.minval DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('input DCSP (%s) DCSP less DCSP than DCSP range DCSP (%s DCSP - DCSP %s)' % (str(input), str(self.minval), str(self.maxval)))) DCNL DCSP  DCSP if self.periodic: DCNL DCSP  DCSP  DCSP if (input >= self.maxval): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('input DCSP (%s) DCSP greater DCSP than DCSP periodic DCSP range DCSP (%s DCSP - DCSP %s)' % (str(input), str(self.minval), str(self.maxval)))) DCNL DCSP  DCSP elif (input > self.maxval): DCNL DCSP  DCSP  DCSP if self.clipInput: DCNL DCSP  DCSP  DCSP  DCSP if (self.verbosity > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('Clipped DCSP input DCSP %s=%.2f DCSP to DCSP maxval DCSP %.2f' % (self.name, input, self.maxval)) DCNL DCSP  DCSP  DCSP  DCSP input = self.maxval DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('input DCSP (%s) DCSP greater DCSP than DCSP range DCSP (%s DCSP - DCSP %s)' % (str(input), str(self.minval), str(self.maxval)))) DCNL DCSP  DCSP if self.periodic: DCNL DCSP  DCSP  DCSP centerbin = (int((((input - self.minval) * self.nInternal) / self.range)) + self.padding) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP centerbin = (int((((input - self.minval) + (self.resolution / 2)) / self.resolution)) + self.padding) DCNL DCSP  DCSP minbin = (centerbin - self.halfwidth) DCNL DCSP  DCSP return [minbin]
def getBucketIndices(self, input): DCNL DCSP if ((type(input) is float) and math.isnan(input)): DCNL DCSP  DCSP input = SENTINEL_VALUE_FOR_MISSING_DATA DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP return [None] DCNL DCSP minbin = self._getFirstOnBit(input)[0] DCNL DCSP if self.periodic: DCNL DCSP  DCSP bucketIdx = (minbin + self.halfwidth) DCNL DCSP  DCSP if (bucketIdx < 0): DCNL DCSP  DCSP  DCSP bucketIdx += self.n DCNL DCSP else: DCNL DCSP  DCSP bucketIdx = minbin DCNL DCSP return [bucketIdx]
def encodeIntoArray(self, input, output, learn=True): DCNL DCSP if ((input is not None) and (not isinstance(input, numbers.Number))): DCNL DCSP  DCSP raise TypeError(('Expected DCSP a DCSP scalar DCSP input DCSP but DCSP got DCSP input DCSP of DCSP type DCSP %s' % type(input))) DCNL DCSP if ((type(input) is float) and math.isnan(input)): DCNL DCSP  DCSP input = SENTINEL_VALUE_FOR_MISSING_DATA DCNL DCSP bucketIdx = self._getFirstOnBit(input)[0] DCNL DCSP if (bucketIdx is None): DCNL DCSP  DCSP output[0:self.n] = 0 DCNL DCSP else: DCNL DCSP  DCSP output[:self.n] = 0 DCNL DCSP  DCSP minbin = bucketIdx DCNL DCSP  DCSP maxbin = (minbin + (2 * self.halfwidth)) DCNL DCSP  DCSP if self.periodic: DCNL DCSP  DCSP  DCSP if (maxbin >= self.n): DCNL DCSP  DCSP  DCSP  DCSP bottombins = ((maxbin - self.n) + 1) DCNL DCSP  DCSP  DCSP  DCSP output[:bottombins] = 1 DCNL DCSP  DCSP  DCSP  DCSP maxbin = (self.n - 1) DCNL DCSP  DCSP  DCSP if (minbin < 0): DCNL DCSP  DCSP  DCSP  DCSP topbins = (- minbin) DCNL DCSP  DCSP  DCSP  DCSP output[(self.n - topbins):self.n] = 1 DCNL DCSP  DCSP  DCSP  DCSP minbin = 0 DCNL DCSP  DCSP assert (minbin >= 0) DCNL DCSP  DCSP assert (maxbin < self.n) DCNL DCSP  DCSP output[minbin:(maxbin + 1)] = 1 DCNL DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP print DCNL DCSP  DCSP print 'input:', input DCNL DCSP  DCSP print 'range:', self.minval, '-', self.maxval DCNL DCSP  DCSP print 'n:', self.n, 'w:', self.w, 'resolution:', self.resolution, 'radius', self.radius, 'periodic:', self.periodic DCNL DCSP  DCSP print 'output:', DCNL DCSP  DCSP self.pprint(output) DCNL DCSP  DCSP print 'input DCSP desc:', self.decodedToStr(self.decode(output))
def decode(self, encoded, parentFieldName=''): DCNL DCSP tmpOutput = numpy.array((encoded[:self.n] > 0)).astype(encoded.dtype) DCNL DCSP if (not tmpOutput.any()): DCNL DCSP  DCSP return (dict(), []) DCNL DCSP maxZerosInARow = self.halfwidth DCNL DCSP for i in xrange(maxZerosInARow): DCNL DCSP  DCSP searchStr = numpy.ones((i + 3), dtype=encoded.dtype) DCNL DCSP  DCSP searchStr[1:(-1)] = 0 DCNL DCSP  DCSP subLen = len(searchStr) DCNL DCSP  DCSP if self.periodic: DCNL DCSP  DCSP  DCSP for j in xrange(self.n): DCNL DCSP  DCSP  DCSP  DCSP outputIndices = numpy.arange(j, (j + subLen)) DCNL DCSP  DCSP  DCSP  DCSP outputIndices %= self.n DCNL DCSP  DCSP  DCSP  DCSP if numpy.array_equal(searchStr, tmpOutput[outputIndices]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tmpOutput[outputIndices] = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for j in xrange(((self.n - subLen) + 1)): DCNL DCSP  DCSP  DCSP  DCSP if numpy.array_equal(searchStr, tmpOutput[j:(j + subLen)]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tmpOutput[j:(j + subLen)] = 1 DCNL DCSP if (self.verbosity >= 2): DCNL DCSP  DCSP print 'raw DCSP output:', encoded[:self.n] DCNL DCSP  DCSP print 'filtered DCSP output:', tmpOutput DCNL DCSP nz = tmpOutput.nonzero()[0] DCNL DCSP runs = [] DCNL DCSP run = [nz[0], 1] DCNL DCSP i = 1 DCNL DCSP while (i < len(nz)): DCNL DCSP  DCSP if (nz[i] == (run[0] + run[1])): DCNL DCSP  DCSP  DCSP run[1] += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP runs.append(run) DCNL DCSP  DCSP  DCSP run = [nz[i], 1] DCNL DCSP  DCSP i += 1 DCNL DCSP runs.append(run) DCNL DCSP if (self.periodic and (len(runs) > 1)): DCNL DCSP  DCSP if ((runs[0][0] == 0) and ((runs[(-1)][0] + runs[(-1)][1]) == self.n)): DCNL DCSP  DCSP  DCSP runs[(-1)][1] += runs[0][1] DCNL DCSP  DCSP  DCSP runs = runs[1:] DCNL DCSP ranges = [] DCNL DCSP for run in runs: DCNL DCSP  DCSP (start, runLen) = run DCNL DCSP  DCSP if (runLen <= self.w): DCNL DCSP  DCSP  DCSP left = right = (start + (runLen / 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP left = (start + self.halfwidth) DCNL DCSP  DCSP  DCSP right = (((start + runLen) - 1) - self.halfwidth) DCNL DCSP  DCSP if (not self.periodic): DCNL DCSP  DCSP  DCSP inMin = (((left - self.padding) * self.resolution) + self.minval) DCNL DCSP  DCSP  DCSP inMax = (((right - self.padding) * self.resolution) + self.minval) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inMin = ((((left - self.padding) * self.range) / self.nInternal) + self.minval) DCNL DCSP  DCSP  DCSP inMax = ((((right - self.padding) * self.range) / self.nInternal) + self.minval) DCNL DCSP  DCSP if self.periodic: DCNL DCSP  DCSP  DCSP if (inMin >= self.maxval): DCNL DCSP  DCSP  DCSP  DCSP inMin -= self.range DCNL DCSP  DCSP  DCSP  DCSP inMax -= self.range DCNL DCSP  DCSP if (inMin < self.minval): DCNL DCSP  DCSP  DCSP inMin = self.minval DCNL DCSP  DCSP if (inMax < self.minval): DCNL DCSP  DCSP  DCSP inMax = self.minval DCNL DCSP  DCSP if (self.periodic and (inMax >= self.maxval)): DCNL DCSP  DCSP  DCSP ranges.append([inMin, self.maxval]) DCNL DCSP  DCSP  DCSP ranges.append([self.minval, (inMax - self.range)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (inMax > self.maxval): DCNL DCSP  DCSP  DCSP  DCSP inMax = self.maxval DCNL DCSP  DCSP  DCSP if (inMin > self.maxval): DCNL DCSP  DCSP  DCSP  DCSP inMin = self.maxval DCNL DCSP  DCSP  DCSP ranges.append([inMin, inMax]) DCNL DCSP desc = self._generateRangeDescription(ranges) DCNL DCSP if (parentFieldName != ''): DCNL DCSP  DCSP fieldName = ('%s.%s' % (parentFieldName, self.name)) DCNL DCSP else: DCNL DCSP  DCSP fieldName = self.name DCNL DCSP return ({fieldName: (ranges, desc)}, [fieldName])
def _generateRangeDescription(self, ranges): DCNL DCSP desc = '' DCNL DCSP numRanges = len(ranges) DCNL DCSP for i in xrange(numRanges): DCNL DCSP  DCSP if (ranges[i][0] != ranges[i][1]): DCNL DCSP  DCSP  DCSP desc += ('%.2f-%.2f' % (ranges[i][0], ranges[i][1])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP desc += ('%.2f' % ranges[i][0]) DCNL DCSP  DCSP if (i < (numRanges - 1)): DCNL DCSP  DCSP  DCSP desc += ', DCSP ' DCNL DCSP return desc
def _getTopDownMapping(self): DCNL DCSP if (self._topDownMappingM is None): DCNL DCSP  DCSP if self.periodic: DCNL DCSP  DCSP  DCSP self._topDownValues = numpy.arange((self.minval + (self.resolution / 2.0)), self.maxval, self.resolution) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._topDownValues = numpy.arange(self.minval, (self.maxval + (self.resolution / 2.0)), self.resolution) DCNL DCSP  DCSP numCategories = len(self._topDownValues) DCNL DCSP  DCSP self._topDownMappingM = SM32(numCategories, self.n) DCNL DCSP  DCSP outputSpace = numpy.zeros(self.n, dtype=GetNTAReal()) DCNL DCSP  DCSP for i in xrange(numCategories): DCNL DCSP  DCSP  DCSP value = self._topDownValues[i] DCNL DCSP  DCSP  DCSP value = max(value, self.minval) DCNL DCSP  DCSP  DCSP value = min(value, self.maxval) DCNL DCSP  DCSP  DCSP self.encodeIntoArray(value, outputSpace, learn=False) DCNL DCSP  DCSP  DCSP self._topDownMappingM.setRowFromDense(i, outputSpace) DCNL DCSP return self._topDownMappingM
def getBucketValues(self): DCNL DCSP if (self._bucketValues is None): DCNL DCSP  DCSP topDownMappingM = self._getTopDownMapping() DCNL DCSP  DCSP numBuckets = topDownMappingM.nRows() DCNL DCSP  DCSP self._bucketValues = [] DCNL DCSP  DCSP for bucketIdx in range(numBuckets): DCNL DCSP  DCSP  DCSP self._bucketValues.append(self.getBucketInfo([bucketIdx])[0].value) DCNL DCSP return self._bucketValues
def getBucketInfo(self, buckets): DCNL DCSP topDownMappingM = self._getTopDownMapping() DCNL DCSP category = buckets[0] DCNL DCSP encoding = self._topDownMappingM.getRow(category) DCNL DCSP if self.periodic: DCNL DCSP  DCSP inputVal = ((self.minval + (self.resolution / 2.0)) + (category * self.resolution)) DCNL DCSP else: DCNL DCSP  DCSP inputVal = (self.minval + (category * self.resolution)) DCNL DCSP return [EncoderResult(value=inputVal, scalar=inputVal, encoding=encoding)]
def topDownCompute(self, encoded): DCNL DCSP topDownMappingM = self._getTopDownMapping() DCNL DCSP category = topDownMappingM.rightVecProd(encoded).argmax() DCNL DCSP return self.getBucketInfo([category])
def closenessScores(self, expValues, actValues, fractional=True): DCNL DCSP expValue = expValues[0] DCNL DCSP actValue = actValues[0] DCNL DCSP if self.periodic: DCNL DCSP  DCSP expValue = (expValue % self.maxval) DCNL DCSP  DCSP actValue = (actValue % self.maxval) DCNL DCSP err = abs((expValue - actValue)) DCNL DCSP if self.periodic: DCNL DCSP  DCSP err = min(err, (self.maxval - err)) DCNL DCSP if fractional: DCNL DCSP  DCSP pctErr = (float(err) / (self.maxval - self.minval)) DCNL DCSP  DCSP pctErr = min(1.0, pctErr) DCNL DCSP  DCSP closeness = (1.0 - pctErr) DCNL DCSP else: DCNL DCSP  DCSP closeness = err DCNL DCSP return numpy.array([closeness])
def getScalarNames(self, parentFieldName=''): DCNL DCSP names = [] DCNL DCSP def _formFieldName(encoder): DCNL DCSP  DCSP if (parentFieldName == ''): DCNL DCSP  DCSP  DCSP return encoder.name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ('%s.%s' % (parentFieldName, encoder.name)) DCNL DCSP if (self.seasonEncoder is not None): DCNL DCSP  DCSP names.append(_formFieldName(self.seasonEncoder)) DCNL DCSP if (self.dayOfWeekEncoder is not None): DCNL DCSP  DCSP names.append(_formFieldName(self.dayOfWeekEncoder)) DCNL DCSP if (self.customDaysEncoder is not None): DCNL DCSP  DCSP names.append(_formFieldName(self.customDaysEncoder)) DCNL DCSP if (self.weekendEncoder is not None): DCNL DCSP  DCSP names.append(_formFieldName(self.weekendEncoder)) DCNL DCSP if (self.holidayEncoder is not None): DCNL DCSP  DCSP names.append(_formFieldName(self.holidayEncoder)) DCNL DCSP if (self.timeOfDayEncoder is not None): DCNL DCSP  DCSP names.append(_formFieldName(self.timeOfDayEncoder)) DCNL DCSP return names
def getEncodedValues(self, input): DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP return numpy.array([None]) DCNL DCSP assert isinstance(input, datetime.datetime) DCNL DCSP values = [] DCNL DCSP timetuple = input.timetuple() DCNL DCSP timeOfDay = (timetuple.tm_hour + (float(timetuple.tm_min) / 60.0)) DCNL DCSP if (self.seasonEncoder is not None): DCNL DCSP  DCSP dayOfYear = timetuple.tm_yday DCNL DCSP  DCSP values.append((dayOfYear - 1)) DCNL DCSP if (self.dayOfWeekEncoder is not None): DCNL DCSP  DCSP dayOfWeek = (timetuple.tm_wday + (timeOfDay / 24.0)) DCNL DCSP  DCSP values.append(dayOfWeek) DCNL DCSP if (self.weekendEncoder is not None): DCNL DCSP  DCSP if ((timetuple.tm_wday == 6) or (timetuple.tm_wday == 5) or ((timetuple.tm_wday == 4) and (timeOfDay > 18))): DCNL DCSP  DCSP  DCSP weekend = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP weekend = 0 DCNL DCSP  DCSP values.append(weekend) DCNL DCSP if (self.customDaysEncoder is not None): DCNL DCSP  DCSP if (timetuple.tm_wday in self.customDays): DCNL DCSP  DCSP  DCSP customDay = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP customDay = 0 DCNL DCSP  DCSP values.append(customDay) DCNL DCSP if (self.holidayEncoder is not None): DCNL DCSP  DCSP holidays = [(12, 25)] DCNL DCSP  DCSP val = 0 DCNL DCSP  DCSP for h in holidays: DCNL DCSP  DCSP  DCSP hdate = datetime.datetime(timetuple.tm_year, h[0], h[1], 0, 0, 0) DCNL DCSP  DCSP  DCSP if (input > hdate): DCNL DCSP  DCSP  DCSP  DCSP diff = (input - hdate) DCNL DCSP  DCSP  DCSP  DCSP if (diff.days == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP val = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP elif (diff.days == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP val = (1.0 - (float(diff.seconds) / 86400)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP diff = (hdate - input) DCNL DCSP  DCSP  DCSP  DCSP if (diff.days == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP val = (1.0 - (float(diff.seconds) / 86400)) DCNL DCSP  DCSP values.append(val) DCNL DCSP if (self.timeOfDayEncoder is not None): DCNL DCSP  DCSP values.append(timeOfDay) DCNL DCSP return values
def getScalars(self, input): DCNL DCSP return numpy.array(self.getEncodedValues(input))
def getBucketIndices(self, input): DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP return ([None] * len(self.encoders)) DCNL DCSP else: DCNL DCSP  DCSP assert isinstance(input, datetime.datetime) DCNL DCSP  DCSP scalars = self.getScalars(input) DCNL DCSP  DCSP result = [] DCNL DCSP  DCSP for i in xrange(len(self.encoders)): DCNL DCSP  DCSP  DCSP (name, encoder, offset) = self.encoders[i] DCNL DCSP  DCSP  DCSP result.extend(encoder.getBucketIndices(scalars[i])) DCNL DCSP  DCSP return result
def encodeIntoArray(self, input, output): DCNL DCSP if (input == SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP output[0:] = 0 DCNL DCSP else: DCNL DCSP  DCSP if (not isinstance(input, datetime.datetime)): DCNL DCSP  DCSP  DCSP raise ValueError(('Input DCSP is DCSP type DCSP %s, DCSP expected DCSP datetime. DCSP Value: DCSP %s' % (type(input), str(input)))) DCNL DCSP  DCSP scalars = self.getScalars(input) DCNL DCSP  DCSP for i in xrange(len(self.encoders)): DCNL DCSP  DCSP  DCSP (name, encoder, offset) = self.encoders[i] DCNL DCSP  DCSP  DCSP encoder.encodeIntoArray(scalars[i], output[offset:])
def addEncoder(self, name, encoder): DCNL DCSP self.encoders.append((name, encoder, self.width)) DCNL DCSP for d in encoder.getDescription(): DCNL DCSP  DCSP self.description.append((d[0], (d[1] + self.width))) DCNL DCSP self.width += encoder.getWidth() DCNL DCSP self._flattenedEncoderList = None DCNL DCSP self._flattenedFieldTypeList = None
def getWidth(self): DCNL DCSP return self.width
def addMultipleEncoders(self, fieldEncodings): DCNL DCSP encoderList = sorted(fieldEncodings.items()) DCNL DCSP for (key, fieldParams) in encoderList: DCNL DCSP  DCSP if ((':' not in key) and (fieldParams is not None)): DCNL DCSP  DCSP  DCSP fieldParams = fieldParams.copy() DCNL DCSP  DCSP  DCSP fieldName = fieldParams.pop('fieldname') DCNL DCSP  DCSP  DCSP encoderName = fieldParams.pop('type') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP self.addEncoder(fieldName, eval(encoderName)(**fieldParams)) DCNL DCSP  DCSP  DCSP except TypeError as e: DCNL DCSP  DCSP  DCSP  DCSP print ('#### DCSP Error DCSP in DCSP constructing DCSP %s DCSP encoder. DCSP Possibly DCSP missing DCSP some DCSP required DCSP constructor DCSP parameters. DCSP Parameters DCSP that DCSP were DCSP provided DCSP are: DCSP %s' % (encoderName, fieldParams)) DCNL DCSP  DCSP  DCSP  DCSP raise
def getWidth(self): DCNL DCSP return self.n
def getDescription(self): DCNL DCSP return [('coordinate', 0), ('radius', 1)]
def getScalars(self, inputData): DCNL DCSP return numpy.array(([0] * len(inputData)))
def encodeIntoArray(self, inputData, output): DCNL DCSP (coordinate, radius) = inputData DCNL DCSP assert isinstance(radius, int), 'Expected DCSP integer DCSP radius, DCSP got: DCSP {} DCSP ({})'.format(radius, type(radius)) DCNL DCSP neighbors = self._neighbors(coordinate, radius) DCNL DCSP winners = self._topWCoordinates(neighbors, self.w) DCNL DCSP bitFn = (lambda coordinate: self._bitForCoordinate(coordinate, self.n)) DCNL DCSP indices = numpy.array([bitFn(w) for w in winners]) DCNL DCSP output[:] = 0 DCNL DCSP output[indices] = 1
@staticmethod DCNL def _neighbors(coordinate, radius): DCNL DCSP ranges = (xrange((n - radius), ((n + radius) + 1)) for n in coordinate.tolist()) DCNL DCSP return numpy.array(list(itertools.product(*ranges)))
@classmethod DCNL def _topWCoordinates(cls, coordinates, w): DCNL DCSP orders = numpy.array([cls._orderForCoordinate(c) for c in coordinates.tolist()]) DCNL DCSP indices = numpy.argsort(orders)[(- w):] DCNL DCSP return coordinates[indices]
@staticmethod DCNL def _hashCoordinate(coordinate): DCNL DCSP coordinateStr = ','.join((str(v) for v in coordinate)) DCNL DCSP hash = int((int(hashlib.md5(coordinateStr).hexdigest(), 16) % (2 ** 64))) DCNL DCSP return hash
@classmethod DCNL def _orderForCoordinate(cls, coordinate): DCNL DCSP seed = cls._hashCoordinate(coordinate) DCNL DCSP rng = Random(seed) DCNL DCSP return rng.getReal64()
@classmethod DCNL def _bitForCoordinate(cls, coordinate, n): DCNL DCSP seed = cls._hashCoordinate(coordinate) DCNL DCSP rng = Random(seed) DCNL DCSP return rng.getUInt32(n)
def __init__(cls, name, bases, dict): DCNL DCSP def custom_setattr(self, name, value): DCNL DCSP  DCSP 'A DCSP custom DCSP replacement DCSP for DCSP __setattr__\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Allows DCSP setting DCSP only DCSP exisitng DCSP attributes. DCSP It DCSP is DCSP designed DCSP to DCSP work\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with DCSP the DCSP _allow_new_attributes DCSP decorator.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP It DCSP works DCSP is DCSP by DCSP checking DCSP if DCSP the DCSP requested DCSP attribute DCSP is DCSP already DCSP in DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP __dict__ DCSP or DCSP if DCSP the DCSP _canAddAttributes DCSP counter DCSP > DCSP 0. DCSP Otherwise DCSP it DCSP raises DCSP an\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP exception.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP all DCSP is DCSP well DCSP it DCSP calls DCSP the DCSP original DCSP __setattr__. DCSP This DCSP means DCSP it DCSP can DCSP work\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP also DCSP with DCSP classes DCSP that DCSP already DCSP have DCSP custom DCSP __setattr__\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if ((name == '_canAddAttributes') or (hasattr(self, '_canAddAttributes') and (self._canAddAttributes > 0)) or hasattr(self, name)): DCNL DCSP  DCSP  DCSP return self._original_setattr(name, value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Attempting DCSP to DCSP set DCSP a DCSP new DCSP attribute: DCSP ' + name)) DCNL DCSP if (deactivation_key in os.environ): DCNL DCSP  DCSP return DCNL DCSP super(LockAttributesMetaclass, cls).__init__(name, bases, dict) DCNL DCSP if (not hasattr(cls, '_original_setattr')): DCNL DCSP  DCSP cls._original_setattr = cls.__setattr__ DCNL DCSP  DCSP cls.__setattr__ = custom_setattr DCNL DCSP if ('__init__' in dict): DCNL DCSP  DCSP setattr(cls, '_original_init', dict['__init__']) DCNL DCSP methods = [('__init__', dict.get('__init__', _simple_init)), ('__setstate__', dict.get('__setstate__', None))] DCNL DCSP for (name, method) in methods: DCNL DCSP  DCSP if (method is not None): DCNL DCSP  DCSP  DCSP setattr(cls, name, _allow_new_attributes(method))
def printTestHeader(self): DCNL DCSP print DCNL DCSP print '###############################################################' DCNL DCSP print ('Running DCSP %s...' % (self,)) DCNL DCSP print ('[%s DCSP UTC]' % datetime.utcnow()) DCNL DCSP print '###############################################################' DCNL DCSP sys.stdout.flush() DCNL DCSP return
def printBanner(self, msg, *args): DCNL DCSP print DCNL DCSP print '===============================================================' DCNL DCSP print (msg % args) DCNL DCSP print >>sys.stdout, ('[%s DCSP UTC; DCSP %s]' % (datetime.utcnow(), self)) DCNL DCSP print '===============================================================' DCNL DCSP sys.stdout.flush() DCNL DCSP return
def addExtraLogItem(self, item): DCNL DCSP self.__logItems.append(item) DCNL DCSP return
def __wrapMsg(self, msg): DCNL DCSP msg = (msg if (not self.__logItems) else {'msg': msg, 'extra': copy.copy(self.__logItems)}) DCNL DCSP msg = str(msg) DCNL DCSP msg = msg.replace('\\n', '\n') DCNL DCSP return msg
def assertEqual(self, first, second, msg=None): DCNL DCSP unittest.TestCase.assertEqual(self, first, second, self.__wrapMsg(msg)) DCNL DCSP return
def assertNotEqual(self, first, second, msg=None): DCNL DCSP unittest.TestCase.assertNotEqual(self, first, second, self.__wrapMsg(msg)) DCNL DCSP return
def assertTrue(self, expr, msg=None): DCNL DCSP unittest.TestCase.assertTrue(self, expr, self.__wrapMsg(msg)) DCNL DCSP return
def assertFalse(self, expr, msg=None): DCNL DCSP unittest.TestCase.assertFalse(self, expr, self.__wrapMsg(msg)) DCNL DCSP return
def getDefaultTMParams(self): DCNL DCSP return {}
def init(self, overrides=None): DCNL DCSP params = self._computeTMParams(overrides) DCNL DCSP class MonitoredTemporalMemory(TemporalMemoryMonitorMixin, self.getTMClass(), ): DCNL DCSP  DCSP pass DCNL DCSP self.tm = MonitoredTemporalMemory(**params)
@classmethod DCNL def getCustomDict(cls): DCNL DCSP return _CustomConfigurationFileWrapper.getCustomDict()
@classmethod DCNL def setCustomProperty(cls, propertyName, value): DCNL DCSP cls.setCustomProperties({propertyName: value})
@classmethod DCNL def setCustomProperties(cls, properties): DCNL DCSP _getLogger().info('Setting DCSP custom DCSP configuration DCSP properties=%r; DCSP caller=%r', properties, traceback.format_stack()) DCNL DCSP _CustomConfigurationFileWrapper.edit(properties) DCNL DCSP for (propertyName, value) in properties.iteritems(): DCNL DCSP  DCSP cls.set(propertyName, value)
@classmethod DCNL def clear(cls): DCNL DCSP super(Configuration, cls).clear() DCNL DCSP _CustomConfigurationFileWrapper.clear(persistent=False)
@classmethod DCNL def resetCustomConfig(cls): DCNL DCSP _getLogger().info('Resetting DCSP all DCSP custom DCSP configuration DCSP properties; DCSP caller=%r', traceback.format_stack()) DCNL DCSP super(Configuration, cls).clear() DCNL DCSP _CustomConfigurationFileWrapper.clear(persistent=True)
@classmethod DCNL def loadCustomConfig(cls): DCNL DCSP cls.readConfigFile(_CustomConfigurationFileWrapper.customFileName)
@classmethod DCNL def _readStdConfigFiles(cls): DCNL DCSP super(Configuration, cls)._readStdConfigFiles() DCNL DCSP cls.loadCustomConfig()
@classmethod DCNL def clear(cls, persistent=False): DCNL DCSP if persistent: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.unlink(cls.getPath()) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP if (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP _getLogger().exception('Error DCSP %s DCSP while DCSP trying DCSP to DCSP remove DCSP dynamic DCSP configuration DCSP file: DCSP %s', e.errno, cls.getPath()) DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP cls._path = None
@classmethod DCNL def getCustomDict(cls): DCNL DCSP if (not os.path.exists(cls.getPath())): DCNL DCSP  DCSP return dict() DCNL DCSP properties = Configuration._readConfigFile(os.path.basename(cls.getPath()), os.path.dirname(cls.getPath())) DCNL DCSP values = dict() DCNL DCSP for propName in properties: DCNL DCSP  DCSP if ('value' in properties[propName]): DCNL DCSP  DCSP  DCSP values[propName] = properties[propName]['value'] DCNL DCSP return values
@classmethod DCNL def edit(cls, properties): DCNL DCSP copyOfProperties = copy(properties) DCNL DCSP configFilePath = cls.getPath() DCNL DCSP try: DCNL DCSP  DCSP with open(configFilePath, 'r') as fp: DCNL DCSP  DCSP  DCSP contents = fp.read() DCNL DCSP except IOError as e: DCNL DCSP  DCSP if (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP _getLogger().exception('Error DCSP %s DCSP reading DCSP custom DCSP configuration DCSP store DCSP from DCSP %s, DCSP while DCSP editing DCSP properties DCSP %s.', e.errno, configFilePath, properties) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP contents = '<configuration/>' DCNL DCSP try: DCNL DCSP  DCSP elements = ElementTree.XML(contents) DCNL DCSP  DCSP ElementTree.tostring(elements) DCNL DCSP except Exception as e: DCNL DCSP  DCSP msg = ("File DCSP contents DCSP of DCSP custom DCSP configuration DCSP is DCSP corrupt. DCSP  DCSP File DCSP location: DCSP %s; DCSP Contents: DCSP '%s'. DCSP Original DCSP Error DCSP (%s): DCSP %s." % (configFilePath, contents, type(e), e)) DCNL DCSP  DCSP _getLogger().exception(msg) DCNL DCSP  DCSP raise RuntimeError(msg), None, sys.exc_info()[2] DCNL DCSP if (elements.tag != 'configuration'): DCNL DCSP  DCSP e = ("Expected DCSP top-level DCSP element DCSP to DCSP be DCSP 'configuration' DCSP but DCSP got DCSP '%s'" % elements.tag) DCNL DCSP  DCSP _getLogger().error(e) DCNL DCSP  DCSP raise RuntimeError(e) DCNL DCSP for propertyItem in elements.findall('./property'): DCNL DCSP  DCSP propInfo = dict(((attr.tag, attr.text) for attr in propertyItem)) DCNL DCSP  DCSP name = propInfo['name'] DCNL DCSP  DCSP if (name in copyOfProperties): DCNL DCSP  DCSP  DCSP foundValues = propertyItem.findall('./value') DCNL DCSP  DCSP  DCSP if (len(foundValues) > 0): DCNL DCSP  DCSP  DCSP  DCSP foundValues[0].text = str(copyOfProperties.pop(name)) DCNL DCSP  DCSP  DCSP  DCSP if (not copyOfProperties): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP e = ('Property DCSP %s DCSP missing DCSP value DCSP tag.' % (name,)) DCNL DCSP  DCSP  DCSP  DCSP _getLogger().error(e) DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(e) DCNL DCSP for (propertyName, value) in copyOfProperties.iteritems(): DCNL DCSP  DCSP newProp = ElementTree.Element('property') DCNL DCSP  DCSP nameTag = ElementTree.Element('name') DCNL DCSP  DCSP nameTag.text = propertyName DCNL DCSP  DCSP newProp.append(nameTag) DCNL DCSP  DCSP valueTag = ElementTree.Element('value') DCNL DCSP  DCSP valueTag.text = str(value) DCNL DCSP  DCSP newProp.append(valueTag) DCNL DCSP  DCSP elements.append(newProp) DCNL DCSP try: DCNL DCSP  DCSP makeDirectoryFromAbsolutePath(os.path.dirname(configFilePath)) DCNL DCSP  DCSP with open(configFilePath, 'w') as fp: DCNL DCSP  DCSP  DCSP fp.write(ElementTree.tostring(elements)) DCNL DCSP except Exception as e: DCNL DCSP  DCSP _getLogger().exception('Error DCSP while DCSP saving DCSP custom DCSP configuration DCSP properties DCSP %s DCSP in DCSP %s.', properties, configFilePath) DCNL DCSP  DCSP raise
@classmethod DCNL def _setPath(cls): DCNL DCSP cls._path = os.path.join(os.environ['NTA_DYNAMIC_CONF_DIR'], cls.customFileName)
@classmethod DCNL def getPath(cls): DCNL DCSP if (cls._path is None): DCNL DCSP  DCSP cls._setPath() DCNL DCSP return cls._path
@classmethod DCNL def getString(cls, prop): DCNL DCSP if (cls._properties is None): DCNL DCSP  DCSP cls._readStdConfigFiles() DCNL DCSP envValue = os.environ.get(('%s%s' % (cls.envPropPrefix, prop.replace('.', '_'))), None) DCNL DCSP if (envValue is not None): DCNL DCSP  DCSP return envValue DCNL DCSP return cls._properties[prop]
@classmethod DCNL def getBool(cls, prop): DCNL DCSP value = cls.getInt(prop) DCNL DCSP if (value not in (0, 1)): DCNL DCSP  DCSP raise ValueError(('Expected DCSP 0 DCSP or DCSP 1, DCSP but DCSP got DCSP %r DCSP in DCSP config DCSP property DCSP %s' % (value, prop))) DCNL DCSP return bool(value)
@classmethod DCNL def getInt(cls, prop): DCNL DCSP return int(cls.getString(prop))
@classmethod DCNL def getFloat(cls, prop): DCNL DCSP return float(cls.getString(prop))
@classmethod DCNL def get(cls, prop, default=None): DCNL DCSP try: DCNL DCSP  DCSP return cls.getString(prop) DCNL DCSP except KeyError: DCNL DCSP  DCSP return default
@classmethod DCNL def set(cls, prop, value): DCNL DCSP if (cls._properties is None): DCNL DCSP  DCSP cls._readStdConfigFiles() DCNL DCSP cls._properties[prop] = str(value)
@classmethod DCNL def dict(cls): DCNL DCSP if (cls._properties is None): DCNL DCSP  DCSP cls._readStdConfigFiles() DCNL DCSP result = dict(cls._properties) DCNL DCSP keys = os.environ.keys() DCNL DCSP replaceKeys = filter((lambda x: x.startswith(cls.envPropPrefix)), keys) DCNL DCSP for envKey in replaceKeys: DCNL DCSP  DCSP key = envKey[len(cls.envPropPrefix):] DCNL DCSP  DCSP key = key.replace('_', '.') DCNL DCSP  DCSP result[key] = os.environ[envKey] DCNL DCSP return result
@classmethod DCNL def readConfigFile(cls, filename, path=None): DCNL DCSP properties = cls._readConfigFile(filename, path) DCNL DCSP if (cls._properties is None): DCNL DCSP  DCSP cls._properties = dict() DCNL DCSP for name in properties: DCNL DCSP  DCSP if ('value' in properties[name]): DCNL DCSP  DCSP  DCSP cls._properties[name] = properties[name]['value']
@classmethod DCNL def _readConfigFile(cls, filename, path=None): DCNL DCSP outputProperties = dict() DCNL DCSP if (path is None): DCNL DCSP  DCSP filePath = cls.findConfigFile(filename) DCNL DCSP else: DCNL DCSP  DCSP filePath = os.path.join(path, filename) DCNL DCSP try: DCNL DCSP  DCSP if (filePath is not None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _getLogger().debug('Loading DCSP config DCSP file: DCSP %s', filePath) DCNL DCSP  DCSP  DCSP  DCSP with open(filePath, 'r') as inp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP contents = inp.read() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Expected DCSP configuration DCSP file DCSP at DCSP %s' % filePath)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP contents = resource_string('nupic.support', filename) DCNL DCSP  DCSP  DCSP except Exception as resourceException: DCNL DCSP  DCSP  DCSP  DCSP if (filename in [USER_CONFIG, CUSTOM_CONFIG]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP contents = '<configuration/>' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise resourceException DCNL DCSP  DCSP elements = ElementTree.XML(contents) DCNL DCSP  DCSP if (elements.tag != 'configuration'): DCNL DCSP  DCSP  DCSP raise RuntimeError(("Expected DCSP top-level DCSP element DCSP to DCSP be DCSP 'configuration' DCSP but DCSP got DCSP '%s'" % elements.tag)) DCNL DCSP  DCSP propertyElements = elements.findall('./property') DCNL DCSP  DCSP for propertyItem in propertyElements: DCNL DCSP  DCSP  DCSP propInfo = dict() DCNL DCSP  DCSP  DCSP propertyAttributes = list(propertyItem) DCNL DCSP  DCSP  DCSP for propertyAttribute in propertyAttributes: DCNL DCSP  DCSP  DCSP  DCSP propInfo[propertyAttribute.tag] = propertyAttribute.text DCNL DCSP  DCSP  DCSP name = propInfo.get('name', None) DCNL DCSP  DCSP  DCSP if (('value' in propInfo) and (propInfo['value'] is None)): DCNL DCSP  DCSP  DCSP  DCSP value = '' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = propInfo.get('value', None) DCNL DCSP  DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('novalue' in propInfo): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError(("Missing DCSP 'value' DCSP element DCSP within DCSP the DCSP property DCSP element: DCSP => DCSP %s DCSP " % str(propInfo))) DCNL DCSP  DCSP  DCSP restOfValue = value DCNL DCSP  DCSP  DCSP value = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP pos = restOfValue.find('${env.') DCNL DCSP  DCSP  DCSP  DCSP if (pos == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value += restOfValue DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP value += restOfValue[0:pos] DCNL DCSP  DCSP  DCSP  DCSP varTailPos = restOfValue.find('}', pos) DCNL DCSP  DCSP  DCSP  DCSP if (varTailPos == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError(("Trailing DCSP environment DCSP variable DCSP tag DCSP delimiter DCSP '}' DCSP not DCSP found DCSP in DCSP %r" % restOfValue)) DCNL DCSP  DCSP  DCSP  DCSP varname = restOfValue[(pos + 6):varTailPos] DCNL DCSP  DCSP  DCSP  DCSP if (varname not in os.environ): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Attempting DCSP to DCSP use DCSP the DCSP value DCSP of DCSP the DCSP environment DCSP variable DCSP %r, DCSP which DCSP is DCSP not DCSP defined' % varname)) DCNL DCSP  DCSP  DCSP  DCSP envVarValue = os.environ[varname] DCNL DCSP  DCSP  DCSP  DCSP value += envVarValue DCNL DCSP  DCSP  DCSP  DCSP restOfValue = restOfValue[(varTailPos + 1):] DCNL DCSP  DCSP  DCSP if (name is None): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(("Missing DCSP 'name' DCSP element DCSP within DCSP following DCSP property DCSP element:\n DCSP => DCSP %s DCSP " % str(propInfo))) DCNL DCSP  DCSP  DCSP propInfo['value'] = value DCNL DCSP  DCSP  DCSP outputProperties[name] = propInfo DCNL DCSP  DCSP return outputProperties DCNL DCSP except Exception: DCNL DCSP  DCSP _getLogger().exception('Error DCSP while DCSP parsing DCSP configuration DCSP file: DCSP %s.', filePath) DCNL DCSP  DCSP raise
@classmethod DCNL def clear(cls): DCNL DCSP cls._properties = None DCNL DCSP cls._configPaths = None
@classmethod DCNL def findConfigFile(cls, filename): DCNL DCSP paths = cls.getConfigPaths() DCNL DCSP for p in paths: DCNL DCSP  DCSP testPath = os.path.join(p, filename) DCNL DCSP  DCSP if os.path.isfile(testPath): DCNL DCSP  DCSP  DCSP return os.path.join(p, filename)
@classmethod DCNL def getConfigPaths(cls): DCNL DCSP configPaths = [] DCNL DCSP if (cls._configPaths is not None): DCNL DCSP  DCSP return cls._configPaths DCNL DCSP else: DCNL DCSP  DCSP if ('NTA_CONF_PATH' in os.environ): DCNL DCSP  DCSP  DCSP configVar = os.environ['NTA_CONF_PATH'] DCNL DCSP  DCSP  DCSP configPaths = configVar.split(os.pathsep) DCNL DCSP  DCSP return configPaths
@classmethod DCNL def setConfigPaths(cls, paths): DCNL DCSP cls._configPaths = list(paths)
@classmethod DCNL def _readStdConfigFiles(cls): DCNL DCSP cls.readConfigFile(DEFAULT_CONFIG) DCNL DCSP cls.readConfigFile(USER_CONFIG)
def cPrint(self, level, message, *args, **kw): DCNL DCSP if (level > self.consolePrinterVerbosity): DCNL DCSP  DCSP return DCNL DCSP if (len(kw) > 1): DCNL DCSP  DCSP raise KeyError(('Invalid DCSP keywords DCSP for DCSP cPrint: DCSP %s' % str(kw.keys()))) DCNL DCSP newline = kw.get('newline', True) DCNL DCSP if ((len(kw) == 1) and ('newline' not in kw)): DCNL DCSP  DCSP raise KeyError(('Invalid DCSP keyword DCSP for DCSP cPrint: DCSP %s' % kw.keys()[0])) DCNL DCSP if (len(args) == 0): DCNL DCSP  DCSP if newline: DCNL DCSP  DCSP  DCSP print message DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print message, DCNL DCSP elif newline: DCNL DCSP  DCSP print (message % args) DCNL DCSP else: DCNL DCSP  DCSP print (message % args),
def propose(self, current, r): DCNL DCSP stay = (r.uniform(0, 1) < self.kernel) DCNL DCSP if stay: DCNL DCSP  DCSP logKernel = numpy.log(self.kernel) DCNL DCSP  DCSP return (current, logKernel, logKernel) DCNL DCSP else: DCNL DCSP  DCSP curIndex = self.keyMap[current] DCNL DCSP  DCSP ri = r.randint(0, (self.nKeys - 1)) DCNL DCSP  DCSP logKernel = numpy.log((1.0 - self.kernel)) DCNL DCSP  DCSP lp = (logKernel + self.logp) DCNL DCSP  DCSP if (ri < curIndex): DCNL DCSP  DCSP  DCSP return (self.keys[ri], lp, lp) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (self.keys[(ri + 1)], lp, lp)
def propose(self, current, r): DCNL DCSP curLambda = (current + self.offset) DCNL DCSP (x, logProb) = PoissonDistribution(curLambda).sample(r) DCNL DCSP logBackward = PoissonDistribution((x + self.offset)).logDensity(current) DCNL DCSP return (x, logProb, logBackward)
def sample(self, rgen): DCNL DCSP rf = rgen.uniform(0, self.sum) DCNL DCSP index = bisect.bisect(self.cdf, rf) DCNL DCSP return (self.keys[index], numpy.log(self.pmf[index]))
def logProbability(self, distn): DCNL DCSP x = numpy.asarray(distn) DCNL DCSP n = x.sum() DCNL DCSP return ((logFactorial(n) - numpy.sum([logFactorial(k) for k in x])) + numpy.sum((x * numpy.log(self.dist.pmf))))
def sample(self, rgen): DCNL DCSP x = rgen.poisson(self.lambdaParameter) DCNL DCSP return (x, self.logDensity(x))
def numRows(self): DCNL DCSP if self.hist_: DCNL DCSP  DCSP return self.hist_.nRows() DCNL DCSP else: DCNL DCSP  DCSP return 0
def numColumns(self): DCNL DCSP if self.hist_: DCNL DCSP  DCSP return self.hist_.nCols() DCNL DCSP else: DCNL DCSP  DCSP return 0
def grow(self, rows, cols): DCNL DCSP if (not self.hist_): DCNL DCSP  DCSP self.hist_ = SparseMatrix(rows, cols) DCNL DCSP  DCSP self.rowSums_ = numpy.zeros(rows, dtype=dtype) DCNL DCSP  DCSP self.colSums_ = numpy.zeros(cols, dtype=dtype) DCNL DCSP  DCSP self.hack_ = None DCNL DCSP else: DCNL DCSP  DCSP oldRows = self.hist_.nRows() DCNL DCSP  DCSP oldCols = self.hist_.nCols() DCNL DCSP  DCSP nextRows = max(oldRows, rows) DCNL DCSP  DCSP nextCols = max(oldCols, cols) DCNL DCSP  DCSP if ((oldRows < nextRows) or (oldCols < nextCols)): DCNL DCSP  DCSP  DCSP self.hist_.resize(nextRows, nextCols) DCNL DCSP  DCSP  DCSP if (oldRows < nextRows): DCNL DCSP  DCSP  DCSP  DCSP oldSums = self.rowSums_ DCNL DCSP  DCSP  DCSP  DCSP self.rowSums_ = numpy.zeros(nextRows, dtype=dtype) DCNL DCSP  DCSP  DCSP  DCSP self.rowSums_[0:len(oldSums)] = oldSums DCNL DCSP  DCSP  DCSP  DCSP self.hack_ = None DCNL DCSP  DCSP  DCSP if (oldCols < nextCols): DCNL DCSP  DCSP  DCSP  DCSP oldSums = self.colSums_ DCNL DCSP  DCSP  DCSP  DCSP self.colSums_ = numpy.zeros(nextCols, dtype=dtype) DCNL DCSP  DCSP  DCSP  DCSP self.colSums_[0:len(oldSums)] = oldSums DCNL DCSP  DCSP  DCSP  DCSP self.hack_ = None
def updateRow(self, row, distribution): DCNL DCSP self.grow((row + 1), len(distribution)) DCNL DCSP self.hist_.axby(row, 1, 1, distribution) DCNL DCSP self.rowSums_[row] += distribution.sum() DCNL DCSP self.colSums_ += distribution DCNL DCSP self.hack_ = None
def inferRow(self, distribution): DCNL DCSP return (self.hist_ * (distribution / self.colSums_))
def inferRowEvidence(self, distribution): DCNL DCSP return ((self.hist_ * distribution) / self.rowSums_)
def inferRowCompat(self, distribution): DCNL DCSP if (self.hack_ is None): DCNL DCSP  DCSP self.clean_outcpd() DCNL DCSP return self.hack_.vecMaxProd(distribution)
def clean_outcpd(self): DCNL DCSP m = self.hist_.toDense() DCNL DCSP for j in xrange(m.shape[1]): DCNL DCSP  DCSP cmax = m[:, j].max() DCNL DCSP  DCSP if cmax: DCNL DCSP  DCSP  DCSP m[:, j] = numpy.array((m[:, j] == cmax), dtype=dtype) DCNL DCSP self.hack_ = SparseMatrix(0, self.hist_.nCols()) DCNL DCSP for i in xrange(m.shape[0]): DCNL DCSP  DCSP self.hack_.addRow(m[i, :])
def shift(self, modelResult): DCNL DCSP inferencesToWrite = {} DCNL DCSP if (self._inferenceBuffer is None): DCNL DCSP  DCSP maxDelay = InferenceElement.getMaxDelay(modelResult.inferences) DCNL DCSP  DCSP self._inferenceBuffer = collections.deque(maxlen=(maxDelay + 1)) DCNL DCSP self._inferenceBuffer.appendleft(copy.deepcopy(modelResult.inferences)) DCNL DCSP for (inferenceElement, inference) in modelResult.inferences.iteritems(): DCNL DCSP  DCSP if isinstance(inference, dict): DCNL DCSP  DCSP  DCSP inferencesToWrite[inferenceElement] = {} DCNL DCSP  DCSP  DCSP for (key, _) in inference.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP delay = InferenceElement.getTemporalDelay(inferenceElement, key) DCNL DCSP  DCSP  DCSP  DCSP if (len(self._inferenceBuffer) > delay): DCNL DCSP  DCSP  DCSP  DCSP  DCSP prevInference = self._inferenceBuffer[delay][inferenceElement][key] DCNL DCSP  DCSP  DCSP  DCSP  DCSP inferencesToWrite[inferenceElement][key] = prevInference DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP inferencesToWrite[inferenceElement][key] = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP delay = InferenceElement.getTemporalDelay(inferenceElement) DCNL DCSP  DCSP  DCSP if (len(self._inferenceBuffer) > delay): DCNL DCSP  DCSP  DCSP  DCSP inferencesToWrite[inferenceElement] = self._inferenceBuffer[delay][inferenceElement] DCNL DCSP  DCSP  DCSP elif (type(inference) in (list, tuple)): DCNL DCSP  DCSP  DCSP  DCSP inferencesToWrite[inferenceElement] = ([None] * len(inference)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP inferencesToWrite[inferenceElement] = None DCNL DCSP shiftedResult = ModelResult(rawInput=modelResult.rawInput, sensorInput=modelResult.sensorInput, inferences=inferencesToWrite, metrics=modelResult.metrics, predictedFieldIdx=modelResult.predictedFieldIdx, predictedFieldName=modelResult.predictedFieldName) DCNL DCSP return shiftedResult
def __init__(self, filterDict): DCNL DCSP self.filterDict = filterDict
def match(self, record): DCNL DCSP for (field, meta) in self.filterDict.iteritems(): DCNL DCSP  DCSP index = meta['index'] DCNL DCSP  DCSP categories = meta['categories'] DCNL DCSP  DCSP for category in categories: DCNL DCSP  DCSP  DCSP if (not record): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (record[index].find(category) != (-1)): DCNL DCSP  DCSP  DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP This DCSP field DCSP contains DCSP the DCSP string DCSP we're DCSP searching DCSP for\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP so DCSP we'll DCSP keep DCSP the DCSP records\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
def __init__(self, n, w, num=100, seed=42): DCNL DCSP self._n = n DCNL DCSP self._w = w DCNL DCSP self._num = num DCNL DCSP self._random = Random(seed) DCNL DCSP self._patterns = dict() DCNL DCSP self._generate()
def get(self, number): DCNL DCSP if (not (number in self._patterns)): DCNL DCSP  DCSP raise IndexError('Invalid DCSP number') DCNL DCSP return self._patterns[number]
def addNoise(self, bits, amount): DCNL DCSP newBits = set() DCNL DCSP for bit in bits: DCNL DCSP  DCSP if (self._random.getReal64() < amount): DCNL DCSP  DCSP  DCSP newBits.add(self._random.getUInt32(self._n)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP newBits.add(bit) DCNL DCSP return newBits
def numbersForBit(self, bit): DCNL DCSP if (bit >= self._n): DCNL DCSP  DCSP raise IndexError('Invalid DCSP bit') DCNL DCSP numbers = set() DCNL DCSP for (index, pattern) in self._patterns.iteritems(): DCNL DCSP  DCSP if (bit in pattern): DCNL DCSP  DCSP  DCSP numbers.add(index) DCNL DCSP return numbers
def numberMapForBits(self, bits): DCNL DCSP numberMap = dict() DCNL DCSP for bit in bits: DCNL DCSP  DCSP numbers = self.numbersForBit(bit) DCNL DCSP  DCSP for number in numbers: DCNL DCSP  DCSP  DCSP if (not (number in numberMap)): DCNL DCSP  DCSP  DCSP  DCSP numberMap[number] = set() DCNL DCSP  DCSP  DCSP numberMap[number].add(bit) DCNL DCSP return numberMap
def prettyPrintPattern(self, bits, verbosity=1): DCNL DCSP numberMap = self.numberMapForBits(bits) DCNL DCSP text = '' DCNL DCSP numberList = [] DCNL DCSP numberItems = sorted(numberMap.iteritems(), key=(lambda (number, bits): len(bits)), reverse=True) DCNL DCSP for (number, bits) in numberItems: DCNL DCSP  DCSP if (verbosity > 2): DCNL DCSP  DCSP  DCSP strBits = [str(n) for n in bits] DCNL DCSP  DCSP  DCSP numberText = '{0} DCSP (bits: DCSP {1})'.format(number, ','.join(strBits)) DCNL DCSP  DCSP elif (verbosity > 1): DCNL DCSP  DCSP  DCSP numberText = '{0} DCSP ({1} DCSP bits)'.format(number, len(bits)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP numberText = str(number) DCNL DCSP  DCSP numberList.append(numberText) DCNL DCSP text += '[{0}]'.format(', DCSP '.join(numberList)) DCNL DCSP return text
def _generate(self): DCNL DCSP candidates = np.array(range(self._n), np.uint32) DCNL DCSP for i in xrange(self._num): DCNL DCSP  DCSP self._random.shuffle(candidates) DCNL DCSP  DCSP pattern = candidates[0:self._getW()] DCNL DCSP  DCSP self._patterns[i] = set(pattern)
def _getW(self): DCNL DCSP w = self._w DCNL DCSP if (type(w) is list): DCNL DCSP  DCSP return w[self._random.getUInt32(len(w))] DCNL DCSP else: DCNL DCSP  DCSP return w
def _generate(self): DCNL DCSP n = self._n DCNL DCSP w = self._w DCNL DCSP assert (type(w) is int), 'List DCSP for DCSP w DCSP not DCSP supported' DCNL DCSP for i in xrange((n / w)): DCNL DCSP  DCSP pattern = set(xrange((i * w), ((i + 1) * w))) DCNL DCSP  DCSP self._patterns[i] = pattern
def getNext(self): DCNL DCSP raise Exception('getNext DCSP must DCSP be DCSP implemented DCSP by DCSP all DCSP subclasses')
def getData(self, n): DCNL DCSP records = [self.getNext() for x in range(n)] DCNL DCSP return records
def getDescription(self): DCNL DCSP raise Exception('getDescription DCSP must DCSP be DCSP implemented DCSP by DCSP all DCSP subclasses')
def __init__(self, patternMachine, seed=42): DCNL DCSP self.patternMachine = patternMachine DCNL DCSP self._random = Random(seed)
def generateFromNumbers(self, numbers): DCNL DCSP sequence = [] DCNL DCSP for number in numbers: DCNL DCSP  DCSP if (number == None): DCNL DCSP  DCSP  DCSP sequence.append(number) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pattern = self.patternMachine.get(number) DCNL DCSP  DCSP  DCSP sequence.append(pattern) DCNL DCSP return sequence
def addSpatialNoise(self, sequence, amount): DCNL DCSP newSequence = [] DCNL DCSP for pattern in sequence: DCNL DCSP  DCSP if (pattern is not None): DCNL DCSP  DCSP  DCSP pattern = self.patternMachine.addNoise(pattern, amount) DCNL DCSP  DCSP newSequence.append(pattern) DCNL DCSP return newSequence
def prettyPrintSequence(self, sequence, verbosity=1): DCNL DCSP text = '' DCNL DCSP for i in xrange(len(sequence)): DCNL DCSP  DCSP pattern = sequence[i] DCNL DCSP  DCSP if (pattern == None): DCNL DCSP  DCSP  DCSP text += '<reset>' DCNL DCSP  DCSP  DCSP if (i < (len(sequence) - 1)): DCNL DCSP  DCSP  DCSP  DCSP text += '\n' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP text += self.patternMachine.prettyPrintPattern(pattern, verbosity=verbosity) DCNL DCSP return text
def generateNumbers(self, numSequences, sequenceLength, sharedRange=None): DCNL DCSP numbers = [] DCNL DCSP if sharedRange: DCNL DCSP  DCSP (sharedStart, sharedEnd) = sharedRange DCNL DCSP  DCSP sharedLength = (sharedEnd - sharedStart) DCNL DCSP  DCSP sharedNumbers = range((numSequences * sequenceLength), ((numSequences * sequenceLength) + sharedLength)) DCNL DCSP for i in xrange(numSequences): DCNL DCSP  DCSP start = (i * sequenceLength) DCNL DCSP  DCSP newNumbers = np.array(range(start, (start + sequenceLength)), np.uint32) DCNL DCSP  DCSP self._random.shuffle(newNumbers) DCNL DCSP  DCSP newNumbers = list(newNumbers) DCNL DCSP  DCSP if (sharedRange is not None): DCNL DCSP  DCSP  DCSP newNumbers[sharedStart:sharedEnd] = sharedNumbers DCNL DCSP  DCSP numbers += newNumbers DCNL DCSP  DCSP numbers.append(None) DCNL DCSP return numbers
def __init__(self, name='testDataset', seed=42, verbosity=0): DCNL DCSP self.name = name DCNL DCSP self.verbosity = verbosity DCNL DCSP self.setSeed(seed) DCNL DCSP self.fields = []
def getDescription(self): DCNL DCSP description = {'name': self.name, 'fields': [f.name for f in self.fields], 'numRecords DCSP by DCSP field': [f.numRecords for f in self.fields]} DCNL DCSP return description
def setSeed(self, seed): DCNL DCSP rand.seed(seed) DCNL DCSP np.random.seed(seed)
def addField(self, name, fieldParams, encoderParams): DCNL DCSP assert ((fieldParams is not None) and ('type' in fieldParams)) DCNL DCSP dataClassName = fieldParams.pop('type') DCNL DCSP try: DCNL DCSP  DCSP dataClass = eval(dataClassName)(fieldParams) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP print ('#### DCSP Error DCSP in DCSP constructing DCSP %s DCSP class DCSP object. DCSP Possibly DCSP missing DCSP some DCSP required DCSP constructor DCSP parameters. DCSP Parameters DCSP that DCSP were DCSP provided DCSP are: DCSP %s' % (dataClass, fieldParams)) DCNL DCSP  DCSP raise DCNL DCSP encoderParams['dataClass'] = dataClass DCNL DCSP encoderParams['dataClassName'] = dataClassName DCNL DCSP fieldIndex = self.defineField(name, encoderParams)
def addMultipleFields(self, fieldsInfo): DCNL DCSP assert all(((x in field) for x in ['name', 'fieldSpec', 'encoderParams'] for field in fieldsInfo)) DCNL DCSP for spec in fieldsInfo: DCNL DCSP  DCSP self.addField(spec.pop('name'), spec.pop('fieldSpec'), spec.pop('encoderParams'))
def defineField(self, name, encoderParams=None): DCNL DCSP self.fields.append(_field(name, encoderParams)) DCNL DCSP return (len(self.fields) - 1)
def setFlag(self, index, flag): DCNL DCSP assert (len(self.fields) > index) DCNL DCSP self.fields[index].flag = flag
def generateRecord(self, record): DCNL DCSP assert (len(record) == len(self.fields)) DCNL DCSP if (record is not None): DCNL DCSP  DCSP for x in range(len(self.fields)): DCNL DCSP  DCSP  DCSP self.fields[x].addValue(record[x]) DCNL DCSP else: DCNL DCSP  DCSP for field in self.fields: DCNL DCSP  DCSP  DCSP field.addValue(field.dataClass.getNext())
def generateRecords(self, records): DCNL DCSP if (self.verbosity > 0): DCNL DCSP  DCSP print 'Generating', len(records), 'records...' DCNL DCSP for record in records: DCNL DCSP  DCSP self.generateRecord(record)
def getRecord(self, n=None): DCNL DCSP if (n is None): DCNL DCSP  DCSP assert (len(self.fields) > 0) DCNL DCSP  DCSP n = (self.fields[0].numRecords - 1) DCNL DCSP assert all(((field.numRecords > n) for field in self.fields)) DCNL DCSP record = [field.values[n] for field in self.fields] DCNL DCSP return record
def getAllRecords(self): DCNL DCSP values = [] DCNL DCSP numRecords = self.fields[0].numRecords DCNL DCSP assert all(((field.numRecords == numRecords) for field in self.fields)) DCNL DCSP for x in range(numRecords): DCNL DCSP  DCSP values.append(self.getRecord(x)) DCNL DCSP return values
def encodeRecord(self, record, toBeAdded=True): DCNL DCSP encoding = [self.fields[i].encodeValue(record[i], toBeAdded) for i in xrange(len(self.fields))] DCNL DCSP return encoding
def encodeAllRecords(self, records=None, toBeAdded=True): DCNL DCSP if (records is None): DCNL DCSP  DCSP records = self.getAllRecords() DCNL DCSP if (self.verbosity > 0): DCNL DCSP  DCSP print 'Encoding', len(records), 'records.' DCNL DCSP encodings = [self.encodeRecord(record, toBeAdded) for record in records] DCNL DCSP return encodings
def addValueToField(self, i, value=None): DCNL DCSP assert (len(self.fields) > i) DCNL DCSP if (value is None): DCNL DCSP  DCSP value = self.fields[i].dataClass.getNext() DCNL DCSP  DCSP self.fields[i].addValue(value) DCNL DCSP  DCSP return value DCNL DCSP else: DCNL DCSP  DCSP self.fields[i].addValue(value)
def addValuesToField(self, i, numValues): DCNL DCSP assert (len(self.fields) > i) DCNL DCSP values = [self.addValueToField(i) for n in range(numValues)] DCNL DCSP return values
def getSDRforValue(self, i, j): DCNL DCSP assert (len(self.fields) > i) DCNL DCSP assert (self.fields[i].numRecords > j) DCNL DCSP encoding = self.fields[i].encodings[j] DCNL DCSP return encoding
def getZeroedOutEncoding(self, n): DCNL DCSP assert all(((field.numRecords > n) for field in self.fields)) DCNL DCSP encoding = np.concatenate([(field.encoder.encode(SENTINEL_VALUE_FOR_MISSING_DATA) if field.isPredictedField else field.encodings[n]) for field in self.fields]) DCNL DCSP return encoding
def getTotaln(self): DCNL DCSP n = sum([field.n for field in self.fields]) DCNL DCSP return n
def getTotalw(self): DCNL DCSP w = sum([field.w for field in self.fields]) DCNL DCSP return w
def getEncoding(self, n): DCNL DCSP assert all(((field.numEncodings > n) for field in self.fields)) DCNL DCSP encoding = np.concatenate([field.encodings[n] for field in self.fields]) DCNL DCSP return encoding
def getAllEncodings(self): DCNL DCSP numEncodings = self.fields[0].numEncodings DCNL DCSP assert all(((field.numEncodings == numEncodings) for field in self.fields)) DCNL DCSP encodings = [self.getEncoding(index) for index in range(numEncodings)] DCNL DCSP return encodings
def getAllFieldNames(self): DCNL DCSP names = [field.name for field in self.fields] DCNL DCSP return names
def getAllFlags(self): DCNL DCSP flags = [field.flag for field in self.fields] DCNL DCSP return flags
def getAllDataTypes(self): DCNL DCSP dataTypes = [field.dataType for field in self.fields] DCNL DCSP return dataTypes
def getFieldDescriptions(self): DCNL DCSP descriptions = [field.getDescription() for field in self.fields] DCNL DCSP return descriptions
def saveRecords(self, path='myOutput'): DCNL DCSP numRecords = self.fields[0].numRecords DCNL DCSP assert all(((field.numRecords == numRecords) for field in self.fields)) DCNL DCSP import csv DCNL DCSP with open((path + '.csv'), 'wb') as f: DCNL DCSP  DCSP writer = csv.writer(f) DCNL DCSP  DCSP writer.writerow(self.getAllFieldNames()) DCNL DCSP  DCSP writer.writerow(self.getAllDataTypes()) DCNL DCSP  DCSP writer.writerow(self.getAllFlags()) DCNL DCSP  DCSP writer.writerows(self.getAllRecords()) DCNL DCSP if (self.verbosity > 0): DCNL DCSP  DCSP print '******', numRecords, 'records DCSP exported DCSP in DCSP numenta DCSP format DCSP to DCSP file:', path, '******\n'
def removeAllRecords(self): DCNL DCSP for field in self.fields: DCNL DCSP  DCSP (field.encodings, field.values) = ([], []) DCNL DCSP  DCSP (field.numRecords, field.numEncodings) = (0, 0)
def __init__(self, name, encoderSpec): DCNL DCSP self.name = name DCNL DCSP (self.n, self.w) = (100, 15) DCNL DCSP (self.encoderType, self.dataType, self.dataClassName) = (None, None, None) DCNL DCSP self.flag = '' DCNL DCSP self.isPredictedField = False DCNL DCSP if (encoderSpec is not None): DCNL DCSP  DCSP if ('n' in encoderSpec): DCNL DCSP  DCSP  DCSP self.n = encoderSpec.pop('n') DCNL DCSP  DCSP if ('w' in encoderSpec): DCNL DCSP  DCSP  DCSP self.w = encoderSpec.pop('w') DCNL DCSP  DCSP if ('flag' in encoderSpec): DCNL DCSP  DCSP  DCSP self.flag = encoderSpec.pop('flag') DCNL DCSP  DCSP if ('isPredictedField' in encoderSpec): DCNL DCSP  DCSP  DCSP self.isPredictedField = encoderSpec.pop('isPredictedField') DCNL DCSP  DCSP if ('dataClass' in encoderSpec): DCNL DCSP  DCSP  DCSP self.dataClass = encoderSpec.pop('dataClass') DCNL DCSP  DCSP if ('dataClassName' in encoderSpec): DCNL DCSP  DCSP  DCSP self.dataClassName = encoderSpec.pop('dataClassName') DCNL DCSP  DCSP if ('dataType' in encoderSpec): DCNL DCSP  DCSP  DCSP self.dataType = encoderSpec.pop('dataType') DCNL DCSP  DCSP if ('encoderType' in encoderSpec): DCNL DCSP  DCSP  DCSP self.encoderType = encoderSpec.pop('encoderType') DCNL DCSP if ((self.dataType is None) and (self.encoderType is None)): DCNL DCSP  DCSP raise RuntimeError('At DCSP least DCSP one DCSP of DCSP dataType DCSP and DCSP encoderType DCSP must DCSP be DCSP specified') DCNL DCSP assert ((self.dataType is not None) or (self.encoderType is not None)) DCNL DCSP if ((self.dataType is None) or (self.encoderType is None)): DCNL DCSP  DCSP self._setTypes(encoderSpec) DCNL DCSP self._initializeEncoders(encoderSpec) DCNL DCSP self.encodings = [] DCNL DCSP self.values = [] DCNL DCSP self.numRecords = 0 DCNL DCSP self.numEncodings = 0
def addValues(self, values): DCNL DCSP for v in values: DCNL DCSP  DCSP self.addValue(v)
def addValue(self, value): DCNL DCSP self.values.append(value) DCNL DCSP self.numRecords += 1
def encodeValue(self, value, toBeAdded=True): DCNL DCSP encodedValue = np.array(self.encoder.encode(value), dtype=realDType) DCNL DCSP if toBeAdded: DCNL DCSP  DCSP self.encodings.append(encodedValue) DCNL DCSP  DCSP self.numEncodings += 1 DCNL DCSP return encodedValue
def _setTypes(self, encoderSpec): DCNL DCSP if (self.encoderType is None): DCNL DCSP  DCSP if (self.dataType in ['int', 'float']): DCNL DCSP  DCSP  DCSP self.encoderType = 'adaptiveScalar' DCNL DCSP  DCSP elif (self.dataType == 'string'): DCNL DCSP  DCSP  DCSP self.encoderType = 'category' DCNL DCSP  DCSP elif (self.dataType in ['date', 'datetime']): DCNL DCSP  DCSP  DCSP self.encoderType = 'date' DCNL DCSP if (self.dataType is None): DCNL DCSP  DCSP if (self.encoderType in ['scalar', 'adaptiveScalar']): DCNL DCSP  DCSP  DCSP self.dataType = 'float' DCNL DCSP  DCSP elif (self.encoderType in ['category', 'enumeration']): DCNL DCSP  DCSP  DCSP self.dataType = 'string' DCNL DCSP  DCSP elif (self.encoderType in ['date', 'datetime']): DCNL DCSP  DCSP  DCSP self.dataType = 'datetime'
def _initializeEncoders(self, encoderSpec): DCNL DCSP if (self.encoderType in ['adaptiveScalar', 'scalar']): DCNL DCSP  DCSP if ('minval' in encoderSpec): DCNL DCSP  DCSP  DCSP self.minval = encoderSpec.pop('minval') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.minval = None DCNL DCSP  DCSP if ('maxval' in encoderSpec): DCNL DCSP  DCSP  DCSP self.maxval = encoderSpec.pop('maxval') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.maxval = None DCNL DCSP  DCSP self.encoder = adaptive_scalar.AdaptiveScalarEncoder(name='AdaptiveScalarEncoder', w=self.w, n=self.n, minval=self.minval, maxval=self.maxval, periodic=False, forced=True) DCNL DCSP elif (self.encoderType == 'category'): DCNL DCSP  DCSP self.encoder = sdr_category.SDRCategoryEncoder(name='categoryEncoder', w=self.w, n=self.n) DCNL DCSP elif (self.encoderType in ['date', 'datetime']): DCNL DCSP  DCSP self.encoder = date.DateEncoder(name='dateEncoder') DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('Error DCSP in DCSP constructing DCSP class DCSP object. DCSP Either DCSP encoder DCSP typeor DCSP dataType DCSP must DCSP be DCSP specified')
@staticmethod DCNL def createFromFileFieldElement(fieldInfoTuple): DCNL DCSP return FieldMetaInfo._make(fieldInfoTuple)
@classmethod DCNL def createListFromFileFieldList(cls, fields): DCNL DCSP return [cls.createFromFileFieldElement(f) for f in fields]
@classmethod DCNL def isValid(cls, fieldDataType): DCNL DCSP return (fieldDataType in cls._ALL)
@classmethod DCNL def isValid(cls, attr): DCNL DCSP return (attr in cls._ALL)
def getStats(self, stats): DCNL DCSP BaseStatsCollector.getStats(self, stats) DCNL DCSP sortedNumberList = sorted(self.valueList) DCNL DCSP listLength = len(sortedNumberList) DCNL DCSP min = sortedNumberList[0] DCNL DCSP max = sortedNumberList[(-1)] DCNL DCSP mean = numpy.mean(self.valueList) DCNL DCSP median = sortedNumberList[int((0.5 * listLength))] DCNL DCSP percentile1st = sortedNumberList[int((0.01 * listLength))] DCNL DCSP percentile99th = sortedNumberList[int((0.99 * listLength))] DCNL DCSP differenceList = [(cur - prev) for (prev, cur) in itertools.izip(list(self.valueSet)[:(-1)], list(self.valueSet)[1:])] DCNL DCSP if (min > max): DCNL DCSP  DCSP print self.fieldname, min, max, '-----' DCNL DCSP meanResolution = numpy.mean(differenceList) DCNL DCSP stats[self.fieldname]['min'] = min DCNL DCSP stats[self.fieldname]['max'] = max DCNL DCSP stats[self.fieldname]['mean'] = mean DCNL DCSP stats[self.fieldname]['median'] = median DCNL DCSP stats[self.fieldname]['percentile1st'] = percentile1st DCNL DCSP stats[self.fieldname]['percentile99th'] = percentile99th DCNL DCSP stats[self.fieldname]['meanResolution'] = meanResolution DCNL DCSP passData = True DCNL DCSP if passData: DCNL DCSP  DCSP stats[self.fieldname]['data'] = self.valueList DCNL DCSP if (VERBOSITY > 2): DCNL DCSP  DCSP print '--' DCNL DCSP  DCSP print 'Statistics:' DCNL DCSP  DCSP print 'min:', min DCNL DCSP  DCSP print 'max:', max DCNL DCSP  DCSP print 'mean:', mean DCNL DCSP  DCSP print 'median:', median DCNL DCSP  DCSP print '1st DCSP percentile DCSP :', percentile1st DCNL DCSP  DCSP print '99th DCSP percentile:', percentile99th DCNL DCSP  DCSP print '--' DCNL DCSP  DCSP print 'Resolution:' DCNL DCSP  DCSP print 'Mean DCSP Resolution:', meanResolution DCNL DCSP if (VERBOSITY > 3): DCNL DCSP  DCSP print '--' DCNL DCSP  DCSP print 'Histogram:' DCNL DCSP  DCSP (counts, bins) = numpy.histogram(self.valueList, new=True) DCNL DCSP  DCSP print 'Counts:', counts.tolist() DCNL DCSP  DCSP print 'Bins:', bins.tolist()
def __init__(self, origField, deltaField): DCNL DCSP self.origField = origField DCNL DCSP self.deltaField = deltaField DCNL DCSP self.previousValue = None DCNL DCSP self.rememberReset = False
@staticmethod DCNL def _openStream(dataUrl, isBlocking, maxTimeout, bookmark, firstRecordIdx): DCNL DCSP filePath = dataUrl[len(FILE_PREF):] DCNL DCSP if (not os.path.isabs(filePath)): DCNL DCSP  DCSP filePath = os.path.join(os.getcwd(), filePath) DCNL DCSP return FileRecordStream(streamID=filePath, write=False, bookmark=bookmark, firstRecord=firstRecordIdx)
def close(self): DCNL DCSP return self._recordStore.close()
def getNextRecord(self): DCNL DCSP while True: DCNL DCSP  DCSP if ((self._sourceLastRecordIdx is not None) and (self._recordStore.getNextRecordIdx() >= self._sourceLastRecordIdx)): DCNL DCSP  DCSP  DCSP preAggValues = None DCNL DCSP  DCSP  DCSP bookmark = self._recordStore.getBookmark() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP preAggValues = self._recordStore.getNextRecord() DCNL DCSP  DCSP  DCSP bookmark = self._recordStore.getBookmark() DCNL DCSP  DCSP if (preAggValues == ()): DCNL DCSP  DCSP  DCSP if self._eofOnTimeout: DCNL DCSP  DCSP  DCSP  DCSP preAggValues = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return preAggValues DCNL DCSP  DCSP self._logger.debug('Read DCSP source DCSP record DCSP #%d: DCSP %r', (self._recordStore.getNextRecordIdx() - 1), preAggValues) DCNL DCSP  DCSP (fieldValues, aggBookmark) = self._aggregator.next(preAggValues, bookmark) DCNL DCSP  DCSP if (fieldValues is not None): DCNL DCSP  DCSP  DCSP self._aggBookmark = aggBookmark DCNL DCSP  DCSP if ((preAggValues is None) and (fieldValues is None)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (fieldValues is not None): DCNL DCSP  DCSP  DCSP break DCNL DCSP if self._needFieldsFiltering: DCNL DCSP  DCSP values = [] DCNL DCSP  DCSP srcDict = dict(zip(self._recordStoreFieldNames, fieldValues)) DCNL DCSP  DCSP for name in self._streamFieldNames: DCNL DCSP  DCSP  DCSP values.append(srcDict[name]) DCNL DCSP  DCSP fieldValues = values DCNL DCSP if (self._writer is not None): DCNL DCSP  DCSP self._writer.appendRecord(fieldValues) DCNL DCSP self._recordCount += 1 DCNL DCSP self._logger.debug('Returning DCSP aggregated DCSP record DCSP #%d DCSP from DCSP getNextRecord(): DCSP %r. DCSP Bookmark: DCSP %r', (self._recordCount - 1), fieldValues, self._aggBookmark) DCNL DCSP return fieldValues
def getDataRowCount(self): DCNL DCSP inputRowCountAfterAggregation = 0 DCNL DCSP while True: DCNL DCSP  DCSP record = self.getNextRecord() DCNL DCSP  DCSP if (record is None): DCNL DCSP  DCSP  DCSP return inputRowCountAfterAggregation DCNL DCSP  DCSP inputRowCountAfterAggregation += 1 DCNL DCSP  DCSP if (inputRowCountAfterAggregation > 10000): DCNL DCSP  DCSP  DCSP raise RuntimeError('No DCSP end DCSP of DCSP datastream DCSP found.')
def getNextRecordIdx(self): DCNL DCSP return self._recordCount
def recordsExistAfter(self, bookmark): DCNL DCSP return self._recordStore.recordsExistAfter(bookmark)
def getAggregationMonthsAndSeconds(self): DCNL DCSP return self._aggMonthsAndSeconds
def getFieldNames(self): DCNL DCSP return [f.name for f in self._streamFields]
def getFields(self): DCNL DCSP return self._streamFields
def getBookmark(self): DCNL DCSP return self._aggBookmark
def clearStats(self): DCNL DCSP self._recordStore.clearStats()
def getStats(self): DCNL DCSP recordStoreStats = self._recordStore.getStats() DCNL DCSP streamStats = dict() DCNL DCSP for (key, values) in recordStoreStats.items(): DCNL DCSP  DCSP fieldStats = dict(zip(self._recordStoreFieldNames, values)) DCNL DCSP  DCSP streamValues = [] DCNL DCSP  DCSP for name in self._streamFieldNames: DCNL DCSP  DCSP  DCSP streamValues.append(fieldStats[name]) DCNL DCSP  DCSP streamStats[key] = streamValues DCNL DCSP return streamStats
def getError(self): DCNL DCSP return self._recordStore.getError()
def setError(self, error): DCNL DCSP self._recordStore.setError(error)
def isCompleted(self): DCNL DCSP return self._recordStore.isCompleted()
def setCompleted(self, completed=True): DCNL DCSP self._recordStore.setCompleted(completed)
def setTimeout(self, timeout): DCNL DCSP self._recordStore.setTimeout(timeout)
def _cacheSequenceInfoType(self): DCNL DCSP hasReset = (self.resetFieldName is not None) DCNL DCSP hasSequenceId = (self.sequenceIdFieldName is not None) DCNL DCSP if (hasReset and (not hasSequenceId)): DCNL DCSP  DCSP self._sequenceInfoType = self.SEQUENCEINFO_RESET_ONLY DCNL DCSP  DCSP self._prevSequenceId = 0 DCNL DCSP elif ((not hasReset) and hasSequenceId): DCNL DCSP  DCSP self._sequenceInfoType = self.SEQUENCEINFO_SEQUENCEID_ONLY DCNL DCSP  DCSP self._prevSequenceId = None DCNL DCSP elif (hasReset and hasSequenceId): DCNL DCSP  DCSP self._sequenceInfoType = self.SEQUENCEINFO_BOTH DCNL DCSP else: DCNL DCSP  DCSP self._sequenceInfoType = self.SEQUENCEINFO_NONE
def __init__(self, aggregationInfo, inputFields, timeFieldName=None, sequenceIdFieldName=None, resetFieldName=None, filterInfo=None): DCNL DCSP self._filterInfo = filterInfo DCNL DCSP self._nullAggregation = False DCNL DCSP self._inputFields = inputFields DCNL DCSP self._nullAggregation = False DCNL DCSP if (aggregationInfo is None): DCNL DCSP  DCSP self._nullAggregation = True DCNL DCSP else: DCNL DCSP  DCSP aggDef = defaultdict((lambda : 0), aggregationInfo) DCNL DCSP  DCSP if (aggDef['years'] == aggDef['months'] == aggDef['weeks'] == aggDef['days'] == aggDef['hours'] == aggDef['minutes'] == aggDef['seconds'] == aggDef['milliseconds'] == aggDef['microseconds'] == 0): DCNL DCSP  DCSP  DCSP self._nullAggregation = True DCNL DCSP self._filter = initFilter(self._inputFields, self._filterInfo) DCNL DCSP self._fields = None DCNL DCSP self._resetFieldIdx = None DCNL DCSP self._timeFieldIdx = None DCNL DCSP self._sequenceIdFieldIdx = None DCNL DCSP self._aggTimeDelta = datetime.timedelta() DCNL DCSP self._aggYears = 0 DCNL DCSP self._aggMonths = 0 DCNL DCSP self._aggrInputBookmark = None DCNL DCSP self._startTime = None DCNL DCSP self._endTime = None DCNL DCSP self._sequenceId = None DCNL DCSP self._firstSequenceStartTime = None DCNL DCSP self._inIdx = (-1) DCNL DCSP self._slice = defaultdict(list) DCNL DCSP if (not self._nullAggregation): DCNL DCSP  DCSP fieldNames = [f[0] for f in aggregationInfo['fields']] DCNL DCSP  DCSP readerFieldNames = [f[0] for f in self._inputFields] DCNL DCSP  DCSP for name in fieldNames: DCNL DCSP  DCSP  DCSP if (not (name in readerFieldNames)): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('No DCSP such DCSP input DCSP field: DCSP %s' % name)) DCNL DCSP  DCSP if (timeFieldName is not None): DCNL DCSP  DCSP  DCSP self._timeFieldIdx = readerFieldNames.index(timeFieldName) DCNL DCSP  DCSP if (resetFieldName is not None): DCNL DCSP  DCSP  DCSP self._resetFieldIdx = readerFieldNames.index(resetFieldName) DCNL DCSP  DCSP if (sequenceIdFieldName is not None): DCNL DCSP  DCSP  DCSP self._sequenceIdFieldIdx = readerFieldNames.index(sequenceIdFieldName) DCNL DCSP  DCSP self._fields = [] DCNL DCSP  DCSP fieldIdx = (-1) DCNL DCSP  DCSP for (name, type, special) in self._inputFields: DCNL DCSP  DCSP  DCSP fieldIdx += 1 DCNL DCSP  DCSP  DCSP found = False DCNL DCSP  DCSP  DCSP for field in aggregationInfo['fields']: DCNL DCSP  DCSP  DCSP  DCSP if (field[0] == name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP aggFunctionName = field[1] DCNL DCSP  DCSP  DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not found): DCNL DCSP  DCSP  DCSP  DCSP aggFunctionName = 'first' DCNL DCSP  DCSP  DCSP (funcPtr, params) = self._getFuncPtrAndParams(aggFunctionName) DCNL DCSP  DCSP  DCSP self._fields.append((fieldIdx, funcPtr, params)) DCNL DCSP  DCSP  DCSP if ((special == FieldMetaSpecial.reset) and (self._resetFieldIdx is None)): DCNL DCSP  DCSP  DCSP  DCSP self._resetFieldIdx = fieldIdx DCNL DCSP  DCSP  DCSP if ((special == FieldMetaSpecial.timestamp) and (self._timeFieldIdx is None)): DCNL DCSP  DCSP  DCSP  DCSP self._timeFieldIdx = fieldIdx DCNL DCSP  DCSP  DCSP if ((special == FieldMetaSpecial.sequence) and (self._sequenceIdFieldIdx is None)): DCNL DCSP  DCSP  DCSP  DCSP self._sequenceIdFieldIdx = fieldIdx DCNL DCSP  DCSP assert (self._timeFieldIdx is not None), 'No DCSP time DCSP field DCSP was DCSP found' DCNL DCSP  DCSP self._aggTimeDelta = datetime.timedelta(days=aggDef['days'], hours=aggDef['hours'], minutes=aggDef['minutes'], seconds=aggDef['seconds'], milliseconds=aggDef['milliseconds'], microseconds=aggDef['microseconds'], weeks=aggDef['weeks']) DCNL DCSP  DCSP self._aggYears = aggDef['years'] DCNL DCSP  DCSP self._aggMonths = aggDef['months'] DCNL DCSP  DCSP if self._aggTimeDelta: DCNL DCSP  DCSP  DCSP assert (self._aggYears == 0) DCNL DCSP  DCSP  DCSP assert (self._aggMonths == 0)
def _getEndTime(self, t): DCNL DCSP assert isinstance(t, datetime.datetime) DCNL DCSP if self._aggTimeDelta: DCNL DCSP  DCSP return (t + self._aggTimeDelta) DCNL DCSP else: DCNL DCSP  DCSP year = ((t.year + self._aggYears) + (((t.month - 1) + self._aggMonths) / 12)) DCNL DCSP  DCSP month = ((((t.month - 1) + self._aggMonths) % 12) + 1) DCNL DCSP  DCSP return t.replace(year=year, month=month)
def _getFuncPtrAndParams(self, funcName): DCNL DCSP params = None DCNL DCSP if isinstance(funcName, basestring): DCNL DCSP  DCSP if (funcName == 'sum'): DCNL DCSP  DCSP  DCSP fp = _aggr_sum DCNL DCSP  DCSP elif (funcName == 'first'): DCNL DCSP  DCSP  DCSP fp = _aggr_first DCNL DCSP  DCSP elif (funcName == 'last'): DCNL DCSP  DCSP  DCSP fp = _aggr_last DCNL DCSP  DCSP elif (funcName == 'mean'): DCNL DCSP  DCSP  DCSP fp = _aggr_mean DCNL DCSP  DCSP elif (funcName == 'max'): DCNL DCSP  DCSP  DCSP fp = max DCNL DCSP  DCSP elif (funcName == 'min'): DCNL DCSP  DCSP  DCSP fp = min DCNL DCSP  DCSP elif (funcName == 'mode'): DCNL DCSP  DCSP  DCSP fp = _aggr_mode DCNL DCSP  DCSP elif funcName.startswith('wmean:'): DCNL DCSP  DCSP  DCSP fp = _aggr_weighted_mean DCNL DCSP  DCSP  DCSP paramsName = funcName[6:] DCNL DCSP  DCSP  DCSP params = [f[0] for f in self._inputFields].index(paramsName) DCNL DCSP else: DCNL DCSP  DCSP fp = funcName DCNL DCSP return (fp, params)
def _createAggregateRecord(self): DCNL DCSP record = [] DCNL DCSP for (i, (fieldIdx, aggFP, paramIdx)) in enumerate(self._fields): DCNL DCSP  DCSP if (aggFP is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP values = self._slice[i] DCNL DCSP  DCSP refIndex = None DCNL DCSP  DCSP if (paramIdx is not None): DCNL DCSP  DCSP  DCSP record.append(aggFP(values, self._slice[paramIdx])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP record.append(aggFP(values)) DCNL DCSP return record
def isNullAggregation(self): DCNL DCSP return self._nullAggregation
def next(self, record, curInputBookmark): DCNL DCSP outRecord = None DCNL DCSP retInputBookmark = None DCNL DCSP if (record is not None): DCNL DCSP  DCSP self._inIdx += 1 DCNL DCSP  DCSP if ((self._filter != None) and (not self._filter[0](self._filter[1], record))): DCNL DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP if self._nullAggregation: DCNL DCSP  DCSP  DCSP return (record, curInputBookmark) DCNL DCSP  DCSP t = record[self._timeFieldIdx] DCNL DCSP  DCSP if (self._firstSequenceStartTime == None): DCNL DCSP  DCSP  DCSP self._firstSequenceStartTime = t DCNL DCSP  DCSP if (self._startTime is None): DCNL DCSP  DCSP  DCSP self._startTime = t DCNL DCSP  DCSP if (self._endTime is None): DCNL DCSP  DCSP  DCSP self._endTime = self._getEndTime(t) DCNL DCSP  DCSP  DCSP assert (self._endTime > t) DCNL DCSP  DCSP if (self._resetFieldIdx is not None): DCNL DCSP  DCSP  DCSP resetSignal = record[self._resetFieldIdx] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP resetSignal = None DCNL DCSP  DCSP if (self._sequenceIdFieldIdx is not None): DCNL DCSP  DCSP  DCSP currSequenceId = record[self._sequenceIdFieldIdx] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP currSequenceId = None DCNL DCSP  DCSP newSequence = (((resetSignal == 1) and (self._inIdx > 0)) or (self._sequenceId != currSequenceId) or (self._inIdx == 0)) DCNL DCSP  DCSP if newSequence: DCNL DCSP  DCSP  DCSP self._sequenceId = currSequenceId DCNL DCSP  DCSP sliceEnded = ((t >= self._endTime) or (t < self._startTime)) DCNL DCSP  DCSP if ((newSequence or sliceEnded) and (len(self._slice) > 0)): DCNL DCSP  DCSP  DCSP for (j, f) in enumerate(self._fields): DCNL DCSP  DCSP  DCSP  DCSP index = f[0] DCNL DCSP  DCSP  DCSP  DCSP if (index == self._timeFieldIdx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._slice[j][0] = self._startTime DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP outRecord = self._createAggregateRecord() DCNL DCSP  DCSP  DCSP retInputBookmark = self._aggrInputBookmark DCNL DCSP  DCSP  DCSP self._slice = defaultdict(list) DCNL DCSP  DCSP for (j, f) in enumerate(self._fields): DCNL DCSP  DCSP  DCSP index = f[0] DCNL DCSP  DCSP  DCSP self._slice[j].append(record[index]) DCNL DCSP  DCSP  DCSP self._aggrInputBookmark = curInputBookmark DCNL DCSP  DCSP if newSequence: DCNL DCSP  DCSP  DCSP self._startTime = t DCNL DCSP  DCSP  DCSP self._endTime = self._getEndTime(t) DCNL DCSP  DCSP if sliceEnded: DCNL DCSP  DCSP  DCSP if (t < self._startTime): DCNL DCSP  DCSP  DCSP  DCSP self._endTime = self._firstSequenceStartTime DCNL DCSP  DCSP  DCSP while (t >= self._endTime): DCNL DCSP  DCSP  DCSP  DCSP self._startTime = self._endTime DCNL DCSP  DCSP  DCSP  DCSP self._endTime = self._getEndTime(self._endTime) DCNL DCSP  DCSP if (outRecord is not None): DCNL DCSP  DCSP  DCSP return (outRecord, retInputBookmark) DCNL DCSP elif self._slice: DCNL DCSP  DCSP for (j, f) in enumerate(self._fields): DCNL DCSP  DCSP  DCSP index = f[0] DCNL DCSP  DCSP  DCSP if (index == self._timeFieldIdx): DCNL DCSP  DCSP  DCSP  DCSP self._slice[j][0] = self._startTime DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP outRecord = self._createAggregateRecord() DCNL DCSP  DCSP retInputBookmark = self._aggrInputBookmark DCNL DCSP  DCSP self._slice = defaultdict(list) DCNL DCSP return (outRecord, retInputBookmark)
def __init__(self, fields, aggregationPeriod=None): DCNL DCSP if (not fields): DCNL DCSP  DCSP raise ValueError(('fields DCSP arg DCSP must DCSP be DCSP non-empty, DCSP but DCSP got DCSP %r' % (fields,))) DCNL DCSP self._fields = fields DCNL DCSP self._aggregationPeriod = aggregationPeriod DCNL DCSP self._sequenceId = (-1) DCNL DCSP self._fieldNames = tuple((f.name for f in fields)) DCNL DCSP self._categoryFieldIndex = _getFieldIndexBySpecial(fields, FieldMetaSpecial.category) DCNL DCSP self._resetFieldIndex = _getFieldIndexBySpecial(fields, FieldMetaSpecial.reset) DCNL DCSP self._sequenceFieldIndex = _getFieldIndexBySpecial(fields, FieldMetaSpecial.sequence) DCNL DCSP self._timestampFieldIndex = _getFieldIndexBySpecial(fields, FieldMetaSpecial.timestamp) DCNL DCSP self._learningFieldIndex = _getFieldIndexBySpecial(fields, FieldMetaSpecial.learning)
def rewind(self): DCNL DCSP self._sequenceId = (-1)
def encode(self, inputRow): DCNL DCSP result = dict(zip(self._fieldNames, inputRow)) DCNL DCSP if (self._categoryFieldIndex is not None): DCNL DCSP  DCSP if isinstance(inputRow[self._categoryFieldIndex], int): DCNL DCSP  DCSP  DCSP result['_category'] = [inputRow[self._categoryFieldIndex]] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result['_category'] = (inputRow[self._categoryFieldIndex] if inputRow[self._categoryFieldIndex] else [None]) DCNL DCSP else: DCNL DCSP  DCSP result['_category'] = [None] DCNL DCSP if (self._resetFieldIndex is not None): DCNL DCSP  DCSP result['_reset'] = int(bool(inputRow[self._resetFieldIndex])) DCNL DCSP else: DCNL DCSP  DCSP result['_reset'] = 0 DCNL DCSP if (self._learningFieldIndex is not None): DCNL DCSP  DCSP result['_learning'] = int(bool(inputRow[self._learningFieldIndex])) DCNL DCSP result['_timestampRecordIdx'] = None DCNL DCSP if (self._timestampFieldIndex is not None): DCNL DCSP  DCSP result['_timestamp'] = inputRow[self._timestampFieldIndex] DCNL DCSP  DCSP result['_timestampRecordIdx'] = self._computeTimestampRecordIdx(inputRow[self._timestampFieldIndex]) DCNL DCSP else: DCNL DCSP  DCSP result['_timestamp'] = None DCNL DCSP hasReset = (self._resetFieldIndex is not None) DCNL DCSP hasSequenceId = (self._sequenceFieldIndex is not None) DCNL DCSP if (hasReset and (not hasSequenceId)): DCNL DCSP  DCSP if result['_reset']: DCNL DCSP  DCSP  DCSP self._sequenceId += 1 DCNL DCSP  DCSP sequenceId = self._sequenceId DCNL DCSP elif ((not hasReset) and hasSequenceId): DCNL DCSP  DCSP sequenceId = inputRow[self._sequenceFieldIndex] DCNL DCSP  DCSP result['_reset'] = int((sequenceId != self._sequenceId)) DCNL DCSP  DCSP self._sequenceId = sequenceId DCNL DCSP elif (hasReset and hasSequenceId): DCNL DCSP  DCSP sequenceId = inputRow[self._sequenceFieldIndex] DCNL DCSP else: DCNL DCSP  DCSP sequenceId = 0 DCNL DCSP if (sequenceId is not None): DCNL DCSP  DCSP result['_sequenceId'] = hash(sequenceId) DCNL DCSP else: DCNL DCSP  DCSP result['_sequenceId'] = None DCNL DCSP return result
def _computeTimestampRecordIdx(self, recordTS): DCNL DCSP if (self._aggregationPeriod is None): DCNL DCSP  DCSP return None DCNL DCSP if (self._aggregationPeriod['months'] > 0): DCNL DCSP  DCSP assert (self._aggregationPeriod['seconds'] == 0) DCNL DCSP  DCSP result = int((((recordTS.year * 12) + (recordTS.month - 1)) / self._aggregationPeriod['months'])) DCNL DCSP elif (self._aggregationPeriod['seconds'] > 0): DCNL DCSP  DCSP delta = (recordTS - datetime.datetime(year=1, month=1, day=1)) DCNL DCSP  DCSP deltaSecs = (((((delta.days * 24) * 60) * 60) + delta.seconds) + (delta.microseconds / 1000000.0)) DCNL DCSP  DCSP result = int((deltaSecs / self._aggregationPeriod['seconds'])) DCNL DCSP else: DCNL DCSP  DCSP result = None DCNL DCSP return result
def rewind(self): DCNL DCSP if (self._modelRecordEncoder is not None): DCNL DCSP  DCSP self._modelRecordEncoder.rewind()
def getNextRecordDict(self): DCNL DCSP values = self.getNextRecord() DCNL DCSP if (values is None): DCNL DCSP  DCSP return None DCNL DCSP if (not values): DCNL DCSP  DCSP return dict() DCNL DCSP if (self._modelRecordEncoder is None): DCNL DCSP  DCSP self._modelRecordEncoder = ModelRecordEncoder(fields=self.getFields(), aggregationPeriod=self.getAggregationMonthsAndSeconds()) DCNL DCSP return self._modelRecordEncoder.encode(values)
def getAggregationMonthsAndSeconds(self): DCNL DCSP return None
def getFieldMin(self, fieldName): DCNL DCSP stats = self.getStats() DCNL DCSP if (stats == None): DCNL DCSP  DCSP return None DCNL DCSP minValues = stats.get('min', None) DCNL DCSP if (minValues == None): DCNL DCSP  DCSP return None DCNL DCSP index = self.getFieldNames().index(fieldName) DCNL DCSP return minValues[index]
def getFieldMax(self, fieldName): DCNL DCSP stats = self.getStats() DCNL DCSP if (stats == None): DCNL DCSP  DCSP return None DCNL DCSP maxValues = stats.get('max', None) DCNL DCSP if (maxValues == None): DCNL DCSP  DCSP return None DCNL DCSP index = self.getFieldNames().index(fieldName) DCNL DCSP return maxValues[index]
def getResetFieldIdx(self): DCNL DCSP return _getFieldIndexBySpecial(self.getFields(), FieldMetaSpecial.reset)
def getTimestampFieldIdx(self): DCNL DCSP return _getFieldIndexBySpecial(self.getFields(), FieldMetaSpecial.timestamp)
def getSequenceIdFieldIdx(self): DCNL DCSP return _getFieldIndexBySpecial(self.getFields(), FieldMetaSpecial.sequence)
def getCategoryFieldIdx(self): DCNL DCSP return _getFieldIndexBySpecial(self.getFields(), FieldMetaSpecial.category)
def getLearningFieldIdx(self): DCNL DCSP return _getFieldIndexBySpecial(self.getFields(), FieldMetaSpecial.learning)
def close(self): DCNL DCSP if (self._file is not None): DCNL DCSP  DCSP self._file.close() DCNL DCSP  DCSP self._file = None
def rewind(self): DCNL DCSP super(FileRecordStream, self).rewind() DCNL DCSP self.close() DCNL DCSP self._file = open(self._filename, self._mode) DCNL DCSP self._reader = csv.reader(self._file, dialect='excel') DCNL DCSP self._reader.next() DCNL DCSP self._reader.next() DCNL DCSP self._reader.next() DCNL DCSP self._recordCount = 0
def getNextRecord(self, useCache=True): DCNL DCSP assert (self._file is not None) DCNL DCSP assert (self._mode == self._FILE_READ_MODE) DCNL DCSP try: DCNL DCSP  DCSP line = self._reader.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP if self.rewindAtEOF: DCNL DCSP  DCSP  DCSP if (self._recordCount == 0): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(("The DCSP source DCSP configured DCSP to DCSP reset DCSP at DCSP EOF DCSP but DCSP '%s' DCSP appears DCSP to DCSP be DCSP empty" % self._filename)) DCNL DCSP  DCSP  DCSP self.rewind() DCNL DCSP  DCSP  DCSP line = self._reader.next() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP self._recordCount += 1 DCNL DCSP record = [] DCNL DCSP for (i, f) in enumerate(line): DCNL DCSP  DCSP if (f in self._missingValues): DCNL DCSP  DCSP  DCSP record.append(SENTINEL_VALUE_FOR_MISSING_DATA) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP record.append(self._adapters[i](f)) DCNL DCSP return record
def appendRecord(self, record): DCNL DCSP assert (self._file is not None) DCNL DCSP assert (self._mode == self._FILE_WRITE_MODE) DCNL DCSP assert isinstance(record, (list, tuple)), ('unexpected DCSP record DCSP type: DCSP ' + repr(type(record))) DCNL DCSP assert (len(record) == self._fieldCount), ('len(record): DCSP %s, DCSP fieldCount: DCSP %s' % (len(record), self._fieldCount)) DCNL DCSP if (self._recordCount == 0): DCNL DCSP  DCSP (names, types, specials) = zip(*self.getFields()) DCNL DCSP  DCSP for line in (names, types, specials): DCNL DCSP  DCSP  DCSP self._writer.writerow(line) DCNL DCSP self._updateSequenceInfo(record) DCNL DCSP line = [self._adapters[i](f) for (i, f) in enumerate(record)] DCNL DCSP self._writer.writerow(line) DCNL DCSP self._recordCount += 1
def appendRecords(self, records, progressCB=None): DCNL DCSP for record in records: DCNL DCSP  DCSP self.appendRecord(record) DCNL DCSP  DCSP if (progressCB is not None): DCNL DCSP  DCSP  DCSP progressCB()
def getBookmark(self): DCNL DCSP if (self._write and (self._recordCount == 0)): DCNL DCSP  DCSP return None DCNL DCSP rowDict = dict(filepath=os.path.realpath(self._filename), currentRow=self._recordCount) DCNL DCSP return json.dumps(rowDict)
def recordsExistAfter(self, bookmark): DCNL DCSP return ((self.getDataRowCount() - self.getNextRecordIdx()) > 0)
def seekFromEnd(self, numRecords): DCNL DCSP self._file.seek((self._getTotalLineCount() - numRecords)) DCNL DCSP return self.getBookmark()
def setAutoRewind(self, autoRewind): DCNL DCSP self.rewindAtEOF = autoRewind
def getStats(self): DCNL DCSP if (self._stats == None): DCNL DCSP  DCSP assert (self._mode == self._FILE_READ_MODE) DCNL DCSP  DCSP inFile = open(self._filename, self._FILE_READ_MODE) DCNL DCSP  DCSP reader = csv.reader(inFile, dialect='excel') DCNL DCSP  DCSP names = [n.strip() for n in reader.next()] DCNL DCSP  DCSP types = [t.strip() for t in reader.next()] DCNL DCSP  DCSP reader.next() DCNL DCSP  DCSP self._stats = dict() DCNL DCSP  DCSP self._stats['min'] = [] DCNL DCSP  DCSP self._stats['max'] = [] DCNL DCSP  DCSP for i in xrange(len(names)): DCNL DCSP  DCSP  DCSP self._stats['min'].append(None) DCNL DCSP  DCSP  DCSP self._stats['max'].append(None) DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP line = reader.next() DCNL DCSP  DCSP  DCSP  DCSP for (i, f) in enumerate(line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((len(types) > i) and (types[i] in [FieldMetaType.integer, FieldMetaType.float]) and (f not in self._missingValues)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = self._adapters[i](f) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((self._stats['max'][i] == None) or (self._stats['max'][i] < value)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._stats['max'][i] = value DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((self._stats['min'][i] == None) or (self._stats['min'][i] > value)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self._stats['min'][i] = value DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return self._stats
def clearStats(self): DCNL DCSP self._stats = None
def getError(self): DCNL DCSP return None
def setError(self, error): DCNL DCSP return
def isCompleted(self): DCNL DCSP return True
def setCompleted(self, completed=True): DCNL DCSP return
def getFieldNames(self): DCNL DCSP return [f.name for f in self._fields]
def getFields(self): DCNL DCSP if (self._fields is None): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return copy.copy(self._fields)
def _updateSequenceInfo(self, r): DCNL DCSP newSequence = False DCNL DCSP sequenceId = (r[self._sequenceIdIdx] if (self._sequenceIdIdx is not None) else None) DCNL DCSP if (sequenceId != self._currSequence): DCNL DCSP  DCSP if (sequenceId in self._sequences): DCNL DCSP  DCSP  DCSP raise Exception(('Broken DCSP sequence: DCSP %s, DCSP record: DCSP %s' % (sequenceId, r))) DCNL DCSP  DCSP self._sequences.add(self._currSequence) DCNL DCSP  DCSP self._currSequence = sequenceId DCNL DCSP  DCSP if self._resetIdx: DCNL DCSP  DCSP  DCSP assert (r[self._resetIdx] == 1) DCNL DCSP  DCSP newSequence = True DCNL DCSP else: DCNL DCSP  DCSP reset = False DCNL DCSP  DCSP if self._resetIdx: DCNL DCSP  DCSP  DCSP reset = r[self._resetIdx] DCNL DCSP  DCSP  DCSP if (reset == 1): DCNL DCSP  DCSP  DCSP  DCSP newSequence = True DCNL DCSP if (not newSequence): DCNL DCSP  DCSP if (self._timeStampIdx and (self._currTime is not None)): DCNL DCSP  DCSP  DCSP t = r[self._timeStampIdx] DCNL DCSP  DCSP  DCSP if (t < self._currTime): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('No DCSP time DCSP travel. DCSP Early DCSP timestamp DCSP for DCSP record: DCSP %s' % r)) DCNL DCSP if self._timeStampIdx: DCNL DCSP  DCSP self._currTime = r[self._timeStampIdx]
def _getStartRow(self, bookmark): DCNL DCSP bookMarkDict = json.loads(bookmark) DCNL DCSP realpath = os.path.realpath(self._filename) DCNL DCSP bookMarkFile = bookMarkDict.get('filepath', None) DCNL DCSP if (bookMarkFile != realpath): DCNL DCSP  DCSP print ("Ignoring DCSP bookmark DCSP due DCSP to DCSP mismatch DCSP between DCSP File's DCSP filename DCSP realpath DCSP vs. DCSP bookmark; DCSP realpath: DCSP %r; DCSP bookmark: DCSP %r" % (realpath, bookMarkDict)) DCNL DCSP  DCSP return 0 DCNL DCSP else: DCNL DCSP  DCSP return bookMarkDict['currentRow']
def _getTotalLineCount(self): DCNL DCSP if (self._mode == self._FILE_WRITE_MODE): DCNL DCSP  DCSP self._file.flush() DCNL DCSP return sum((1 for line in open(self._filename, self._FILE_READ_MODE)))
def getNextRecordIdx(self): DCNL DCSP return self._recordCount
def getDataRowCount(self): DCNL DCSP numLines = self._getTotalLineCount() DCNL DCSP if (numLines == 0): DCNL DCSP  DCSP assert ((self._mode == self._FILE_WRITE_MODE) and (self._recordCount == 0)) DCNL DCSP  DCSP numDataRows = 0 DCNL DCSP else: DCNL DCSP  DCSP numDataRows = (numLines - self._NUM_HEADER_ROWS) DCNL DCSP assert (numDataRows >= 0) DCNL DCSP return numDataRows
def flush(self): DCNL DCSP if (self._file is not None): DCNL DCSP  DCSP self._file.flush()
def __enter__(self): DCNL DCSP return self
def __exit__(self, yupe, value, traceback): DCNL DCSP self.close()
def __iter__(self): DCNL DCSP return self
def next(self): DCNL DCSP record = self.getNextRecord() DCNL DCSP if (record is None): DCNL DCSP  DCSP raise StopIteration DCNL DCSP return record
def __init__(self, *args): DCNL DCSP engine_internal.Dimensions.__init__(self, *args)
def __init__(self, region, network): DCNL DCSP self._network = network DCNL DCSP self._region = region DCNL DCSP (self.__class__.__doc__ == region.__class__.__doc__) DCNL DCSP self._paramTypeCache = {}
@staticmethod DCNL def getSpecFromType(nodeType): DCNL DCSP return Spec(engine_internal.Region.getSpecFromType(nodeType))
def compute(self): DCNL DCSP return self._region.compute()
def getInputData(self, inputName): DCNL DCSP return self._region.getInputArray(inputName)
def getOutputData(self, outputName): DCNL DCSP return self._region.getOutputArray(outputName)
def getInputNames(self): DCNL DCSP inputs = self.getSpec().inputs DCNL DCSP return [inputs.getByIndex(i)[0] for i in xrange(inputs.getCount())]
def getOutputNames(self): DCNL DCSP outputs = self.getSpec().outputs DCNL DCSP return [outputs.getByIndex(i)[0] for i in xrange(outputs.getCount())]
def executeCommand(self, args): DCNL DCSP return self._region.executeCommand(args)
def _getSpec(self): DCNL DCSP return Spec(self._region.getSpec())
def _getDimensions(self): DCNL DCSP return Dimensions(tuple(self._region.getDimensions()))
def _getNetwork(self): DCNL DCSP return self._network
def __hash__(self): DCNL DCSP return self._region.__hash__()
def __cmp__(self, other): DCNL DCSP return (self._region == other._region)
def _getParameterMethods(self, paramName): DCNL DCSP if (paramName in self._paramTypeCache): DCNL DCSP  DCSP return self._paramTypeCache[paramName] DCNL DCSP try: DCNL DCSP  DCSP paramSpec = self.getSpec().parameters.getByName(paramName) DCNL DCSP except: DCNL DCSP  DCSP return (None, None) DCNL DCSP dataType = paramSpec.dataType DCNL DCSP dataTypeName = basicTypes[dataType] DCNL DCSP count = paramSpec.count DCNL DCSP if (count == 1): DCNL DCSP  DCSP x = ('etParameter' + dataTypeName) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP g = getattr(self, ('g' + x)) DCNL DCSP  DCSP  DCSP s = getattr(self, ('s' + x)) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise Exception(('Internal DCSP error: DCSP unknown DCSP parameter DCSP type DCSP %s' % dataTypeName)) DCNL DCSP  DCSP info = (s, g) DCNL DCSP elif (dataTypeName == 'Byte'): DCNL DCSP  DCSP info = (self.setParameterString, self.getParameterString) DCNL DCSP else: DCNL DCSP  DCSP helper = _ArrayParameterHelper(self, dataType) DCNL DCSP  DCSP info = (self.setParameterArray, helper.getParameterArray) DCNL DCSP self._paramTypeCache[paramName] = info DCNL DCSP return info
def getParameter(self, paramName): DCNL DCSP (setter, getter) = self._getParameterMethods(paramName) DCNL DCSP if (getter is None): DCNL DCSP  DCSP import exceptions DCNL DCSP  DCSP raise exceptions.Exception(("getParameter DCSP -- DCSP parameter DCSP name DCSP '%s' DCSP does DCSP not DCSP exist DCSP in DCSP region DCSP %s DCSP of DCSP type DCSP %s" % (paramName, self.name, self.type))) DCNL DCSP return getter(paramName)
def setParameter(self, paramName, value): DCNL DCSP (setter, getter) = self._getParameterMethods(paramName) DCNL DCSP if (setter is None): DCNL DCSP  DCSP import exceptions DCNL DCSP  DCSP raise exceptions.Exception(("setParameter DCSP -- DCSP parameter DCSP name DCSP '%s' DCSP does DCSP not DCSP exist DCSP in DCSP region DCSP %s DCSP of DCSP type DCSP %s" % (paramName, self.name, self.type))) DCNL DCSP setter(paramName, value)
def _get(self, method): DCNL DCSP return getattr(self._region, method)()
def __init__(self, *args): DCNL DCSP engine_internal.Network.__init__(self, *args) DCNL DCSP docTable = ((engine_internal.Network.getRegions, 'Get DCSP the DCSP collection DCSP of DCSP regions DCSP in DCSP a DCSP network'),) DCNL DCSP for (obj, docString) in docTable: DCNL DCSP  DCSP if isinstance(obj, str): DCNL DCSP  DCSP  DCSP prop = getattr(Network, obj) DCNL DCSP  DCSP  DCSP assert isinstance(prop, property) DCNL DCSP  DCSP  DCSP setattr(Network, obj, property(prop.fget, prop.fset, prop.fdel, docString)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP obj.im_func.__doc__ = docString
def _getRegions(self): DCNL DCSP def makeRegion(name, r): DCNL DCSP  DCSP 'Wrap DCSP a DCSP engine DCSP region DCSP with DCSP a DCSP nupic.engine_internal.Region\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Also DCSP passes DCSP the DCSP containing DCSP nupic.engine_internal.Network DCSP network DCSP in DCSP _network. DCSP This\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP function DCSP is DCSP passed DCSP a DCSP value DCSP wrapper DCSP to DCSP the DCSP CollectionWrapper\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP r = Region(r, self) DCNL DCSP  DCSP return r DCNL DCSP regions = CollectionWrapper(engine_internal.Network.getRegions(self), makeRegion) DCNL DCSP return regions
def addRegion(self, name, nodeType, nodeParams): DCNL DCSP engine_internal.Network.addRegion(self, name, nodeType, nodeParams) DCNL DCSP return self._getRegions()[name]
def addRegionFromBundle(self, name, nodeType, dimensions, bundlePath, label): DCNL DCSP engine_internal.Network.addRegionFromBundle(self, name, nodeType, dimensions, bundlePath, label) DCNL DCSP return self._getRegions()[name]
def setPhases(self, name, phases): DCNL DCSP phases = engine_internal.UInt32Set(phases) DCNL DCSP engine_internal.Network.setPhases(self, name, phases)
def run(self, n): DCNL DCSP engine_internal.Network.run(self, n)
def disableProfiling(self, *args, **kwargs): DCNL DCSP engine_internal.Network.disableProfiling(self, *args, **kwargs)
def enableProfiling(self, *args, **kwargs): DCNL DCSP engine_internal.Network.enableProfiling(self, *args, **kwargs)
def getCallbacks(self, *args, **kwargs): DCNL DCSP engine_internal.Network.getCallbacks(self, *args, **kwargs)
def initialize(self, *args, **kwargs): DCNL DCSP engine_internal.Network.initialize(self, *args, **kwargs)
def link(self, *args, **kwargs): DCNL DCSP engine_internal.Network.link(self, *args, **kwargs)
def removeLink(self, *args, **kwargs): DCNL DCSP engine_internal.Network.removeLink(self, *args, **kwargs)
def removeRegion(self, *args, **kwargs): DCNL DCSP engine_internal.Network.removeRegion(self, *args, **kwargs)
def resetProfiling(self, *args, **kwargs): DCNL DCSP engine_internal.Network.resetProfiling(self, *args, **kwargs)
def save(self, *args, **kwargs): DCNL DCSP if ((len(args) > 0) and (not isinstance(args[0], str))): DCNL DCSP  DCSP raise TypeError('Save DCSP path DCSP must DCSP be DCSP of DCSP type DCSP {}.'.format(str)) DCNL DCSP engine_internal.Network.save(self, *args, **kwargs)
def getRegionsByType(self, regionClass): DCNL DCSP regions = [] DCNL DCSP for region in self.regions.values(): DCNL DCSP  DCSP if (type(region.getSelf()) is regionClass): DCNL DCSP  DCSP  DCSP regions.append(region) DCNL DCSP return regions
@staticmethod DCNL def registerRegion(regionClass): DCNL DCSP engine_internal.Network.registerPyRegion(regionClass.__module__, regionClass.__name__)
@staticmethod DCNL def unregisterRegion(regionName): DCNL DCSP engine_internal.Network.unregisterPyRegion(regionName)
