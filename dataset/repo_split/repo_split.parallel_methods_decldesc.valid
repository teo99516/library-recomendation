def __init__(self): DCNL '__init__: This has to be present'
def XXX11(): DCNL 'XXX22: This has to be present'
def cleanup(self): DCNL 'Remove recursive references to allow garbage DCNL collector to collect this object.'
def disassemble(self, co, classname=None, deob=0): DCNL 'Disassemble a code object, returning a list of \'Token\'. DCNL The main part of this procedure is modelled after DCNL dis.disassemble().'
def first_instr(self, start, end, instr, target=None, exact=True): DCNL 'Find the first <instr> in the block from start to end. DCNL <instr> is any python bytecode instruction or a list of opcodes DCNL If <instr> is an opcode with a target (like a jump), a target DCNL destination can be specified which must match precisely if exact DCNL is True, or if exact is False, the instruction which has a target DCNL closest to <target> will be returned. DCNL Return index to it or None if not found.'
def last_instr(self, start, end, instr, target=None, exact=True): DCNL 'Find the last <instr> in the block from start to end. DCNL <instr> is any python bytecode instruction or a list of opcodes DCNL If <instr> is an opcode with a target (like a jump), a target DCNL destination can be specified which must match precisely if exact DCNL is True, or if exact is False, the instruction which has a target DCNL closest to <target> will be returned. DCNL Return index to it or None if not found.'
def all_instr(self, start, end, instr, target=None, include_beyond_target=False): DCNL 'Find all <instr> in the block from start to end. DCNL <instr> is any python bytecode instruction or a list of opcodes DCNL If <instr> is an opcode with a target (like a jump), a target DCNL destination can be specified which must match precisely. DCNL Return a list with indexes to them or [] if none found.'
def rem_or(self, start, end, instr, target=None, include_beyond_target=False): DCNL 'Find all <instr> in the block from start to end. DCNL <instr> is any python bytecode instruction or a list of opcodes DCNL If <instr> is an opcode with a target (like a jump), a target DCNL destination can be specified which must match precisely. DCNL Return a list with indexes to them or [] if none found.'
def next_except_jump(self, start): DCNL 'Return the next jump that was generated by an except SomeException: DCNL construct in a try...except...else clause or None if not found.'
def restrict_to_parent(self, target, parent): DCNL 'Restrict pos to parent boundaries.'
def detect_structure(self, pos, op=None): DCNL 'Detect structures and their boundaries to fix optimizied jumps DCNL in python2.3+'
def find_jump_targets(self, code): DCNL 'Detect all offsets in a byte code which are jump targets. DCNL Return the list of offsets. DCNL This procedure is modelled after dis.findlables(), but here DCNL for each target the number of jumps are counted.'
def n_exec_stmt(self, node): DCNL 'exec_stmt ::= expr exprlist DUP_TOP EXEC_STMT DCNL exec_stmt ::= expr exprlist EXEC_STMT'
def n_mapexpr(self, node): DCNL 'prettyprint a mapexpr DCNL \'mapexpr\' is something like k = {\'a\': 1, \'b\': 42 }"'
def n_build_list(self, node): DCNL 'prettyprint a list or tuple'
def customize(self, customize): DCNL 'Special handling for opcodes that take a variable number DCNL of arguments -- we add a new entry for each in TABLE_R.'
def get_tuple_parameter(self, ast, name): DCNL 'If the name of the formal parameter starts with dot, DCNL it\'s a tuple parameter, like this: DCNL #          def MyFunc(xx, (a,b,c), yy): DCNL #                  print a, b*2, c*42 DCNL In byte-code, the whole tuple is assigned to parameter \'.1\' and DCNL then the tuple gets unpacked to \'a\', \'b\' and \'c\'. DCNL Since identifiers starting with a dot are illegal in Python, DCNL we can search for the byte-code equivalent to \'(a,b,c) = .1\''
def make_function(self, node, isLambda, nested=1): DCNL 'Dump function defintion, doc string, and function body.'
def build_class(self, code): DCNL 'Dump class definition, doc string and class body.'
def gen_source(self, ast, customize, isLambda=0, returnNone=False): DCNL 'convert AST to source code'
def __repr__(self): DCNL 'Return the function\'s docstring.'
def __get__(self, obj, objtype): DCNL 'Support instance methods.'
@staticmethod DCNL def from_param(this): DCNL '(INTERNAL) ctypes parameter conversion method.'
def event_attach(self, eventtype, callback, *args, **kwds): DCNL 'Register an event notification. DCNL @param eventtype: the desired event type to be notified about. DCNL @param callback: the function to call when the event occurs. DCNL @param args: optional positional arguments for the callback. DCNL @param kwds: optional keyword arguments for the callback. DCNL @return: 0 on success, ENOMEM on error. DCNL @note: The callback function must have at least one argument, DCNL an Event instance.  Any other, optional positional and keyword DCNL arguments are in B{addition} to the first one.'
def event_detach(self, eventtype): DCNL 'Unregister an event notification. DCNL @param eventtype: the event type notification to be removed.'
def media_player_new(self, uri=None): DCNL 'Create a new MediaPlayer instance. DCNL @param uri: an optional URI to play in the player.'
def media_list_player_new(self): DCNL 'Create a new MediaListPlayer instance.'
def media_new(self, mrl, *options): DCNL 'Create a new Media instance. DCNL If mrl contains a colon (:) preceded by more than 1 letter, it DCNL will be treated as a URL. Else, it will be considered as a DCNL local path. If you need more control, directly use DCNL media_new_location/media_new_path methods. DCNL Options can be specified as supplementary string parameters, DCNL but note that many options cannot be set at the media level, DCNL and rather at the Instance level. For instance, the marquee DCNL filter must be specified when creating the vlc.Instance or DCNL vlc.MediaPlayer. DCNL Alternatively, options can be added to the media using the DCNL Media.add_options method (with the same limitation). DCNL @param options: optional media option=value strings'
def media_list_new(self, mrls=None): DCNL 'Create a new MediaList instance. DCNL @param mrls: optional list of MRL strings'
def audio_output_enumerate_devices(self): DCNL 'Enumerate the defined audio output devices. DCNL @return: list of dicts {name:, description:, devices:}'
def audio_filter_list_get(self): DCNL 'Returns a list of available audio filters.'
def video_filter_list_get(self): DCNL 'Returns a list of available video filters.'
def release(self): DCNL 'Decrement the reference count of a libvlc instance, and destroy it DCNL if it reaches zero.'
def retain(self): DCNL 'Increments the reference count of a libvlc instance. DCNL The initial reference count is 1 after L{new}() returns.'
def add_intf(self, name): DCNL 'Try to start a user interface for the libvlc instance. DCNL @param name: interface name, or None for default. DCNL @return: 0 on success, -1 on error.'
def set_user_agent(self, name, http): DCNL 'Sets the application name. LibVLC passes this as the user agent string DCNL when a protocol requires it. DCNL @param name: human-readable application name, e.g. "FooBar player 1.2.3". DCNL @param http: HTTP User Agent, e.g. "FooBar/1.2.3 Python/2.6.0". DCNL @version: LibVLC 1.1.1 or later.'
def set_app_id(self, id, version, icon): DCNL 'Sets some meta-information about the application. DCNL See also L{set_user_agent}(). DCNL @param id: Java-style application identifier, e.g. "com.acme.foobar". DCNL @param version: application version numbers, e.g. "1.2.3". DCNL @param icon: application icon name, e.g. "foobar". DCNL @version: LibVLC 2.1.0 or later.'
def log_unset(self): DCNL 'Unsets the logging callback for a LibVLC instance. This is rarely needed: DCNL the callback is implicitly unset when the instance is destroyed. DCNL This function will wait for any pending callbacks invocation to complete DCNL (causing a deadlock if called from within the callback). DCNL @version: LibVLC 2.1.0 or later.'
def log_set(self, data, p_instance): DCNL 'Sets the logging callback for a LibVLC instance. DCNL This function is thread-safe: it will wait for any pending callbacks DCNL invocation to complete. DCNL @param data: opaque data pointer for the callback function @note Some log messages (especially debug) are emitted by LibVLC while is being initialized. These messages cannot be captured with this interface. @warning A deadlock may occur if this function is called from the callback. DCNL @param p_instance: libvlc instance. DCNL @version: LibVLC 2.1.0 or later.'
def log_set_file(self, stream): DCNL 'Sets up logging to a file. DCNL @param stream: FILE pointer opened for writing (the FILE pointer must remain valid until L{log_unset}()). DCNL @version: LibVLC 2.1.0 or later.'
def media_new_location(self, psz_mrl): DCNL 'Create a media with a certain given media resource location, DCNL for instance a valid URL. DCNL @note: To refer to a local file with this function, DCNL the file://... URI syntax B{must} be used (see IETF RFC3986). DCNL We recommend using L{media_new_path}() instead when dealing with DCNL local files. DCNL See L{media_release}. DCNL @param psz_mrl: the media location. DCNL @return: the newly created media or None on error.'
def media_new_path(self, path): DCNL 'Create a media for a certain file path. DCNL See L{media_release}. DCNL @param path: local filesystem path. DCNL @return: the newly created media or None on error.'
def media_new_fd(self, fd): DCNL 'Create a media for an already open file descriptor. DCNL The file descriptor shall be open for reading (or reading and writing). DCNL Regular file descriptors, pipe read descriptors and character device DCNL descriptors (including TTYs) are supported on all platforms. DCNL Block device descriptors are supported where available. DCNL Directory descriptors are supported on systems that provide fdopendir(). DCNL Sockets are supported on all platforms where they are file descriptors, DCNL i.e. all except Windows. DCNL @note: This library will B{not} automatically close the file descriptor DCNL under any circumstance. Nevertheless, a file descriptor can usually only be DCNL rendered once in a media player. To render it a second time, the file DCNL descriptor should probably be rewound to the beginning with lseek(). DCNL See L{media_release}. DCNL @param fd: open file descriptor. DCNL @return: the newly created media or None on error. DCNL @version: LibVLC 1.1.5 and later.'
def media_new_callbacks(self, open_cb, read_cb, seek_cb, close_cb, opaque): DCNL 'Create a media with custom callbacks to read the data from. DCNL @param open_cb: callback to open the custom bitstream input media. DCNL @param read_cb: callback to read data (must not be None). DCNL @param seek_cb: callback to seek, or None if seeking is not supported. DCNL @param close_cb: callback to close the media, or None if unnecessary. DCNL @param opaque: data pointer for the open callback. DCNL @return: the newly created media or None on error @note If open_cb is None, the opaque pointer will be passed to read_cb, seek_cb and close_cb, and the stream size will be treated as unknown. @note The callbacks may be called asynchronously (from another thread). A single stream instance need not be reentrant. However the open_cb needs to be reentrant if the media is used by multiple player instances. @warning The callbacks may be used until all or any player instances that were supplied the media item are stopped. See L{media_release}. DCNL @version: LibVLC 3.0.0 and later.'
def media_new_as_node(self, psz_name): DCNL 'Create a media as an empty node with a given name. DCNL See L{media_release}. DCNL @param psz_name: the name of the node. DCNL @return: the new empty media or None on error.'
def media_discoverer_new(self, psz_name): DCNL 'Create a media discoverer object by name. DCNL After this object is created, you should attach to events in order to be DCNL notified of the discoverer state. DCNL You should also attach to media_list events in order to be notified of new DCNL items discovered. DCNL You need to call L{media_discoverer_start}() in order to start the DCNL discovery. DCNL See L{media_discoverer_media_list} DCNL See L{media_discoverer_event_manager} DCNL See L{media_discoverer_start}. DCNL @param psz_name: service name. DCNL @return: media discover object or None in case of error. DCNL @version: LibVLC 3.0.0 or later.'
def media_library_new(self): DCNL 'Create an new Media Library object. DCNL @return: a new object or None on error.'
def audio_output_list_get(self): DCNL 'Gets the list of available audio output modules. DCNL @return: list of available audio outputs. It must be freed with In case of error, None is returned.'
def audio_output_device_list_get(self, aout): DCNL 'Gets a list of audio output devices for a given audio output module, DCNL See L{audio_output_device_set}(). DCNL @note: Not all audio outputs support this. In particular, an empty (None) DCNL list of devices does B{not} imply that the specified audio output does DCNL not work. DCNL @note: The list might not be exhaustive. DCNL @warning: Some audio output devices in the list might not actually work in DCNL some circumstances. By default, it is recommended to not specify any DCNL explicit audio device. DCNL @param psz_aout: audio output name (as returned by L{audio_output_list_get}()). DCNL @return: A None-terminated linked list of potential audio output devices. It must be freed with L{audio_output_device_list_release}(). DCNL @version: LibVLC 2.1.0 or later.'
def vlm_release(self): DCNL 'Release the vlm instance related to the given L{Instance}.'
def vlm_add_broadcast(self, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop): DCNL 'Add a broadcast, with one input. DCNL @param psz_name: the name of the new broadcast. DCNL @param psz_input: the input MRL. DCNL @param psz_output: the output MRL (the parameter to the "sout" variable). DCNL @param i_options: number of additional options. DCNL @param ppsz_options: additional options. DCNL @param b_enabled: boolean for enabling the new broadcast. DCNL @param b_loop: Should this broadcast be played in loop ? DCNL @return: 0 on success, -1 on error.'
def vlm_add_vod(self, psz_name, psz_input, i_options, ppsz_options, b_enabled, psz_mux): DCNL 'Add a vod, with one input. DCNL @param psz_name: the name of the new vod media. DCNL @param psz_input: the input MRL. DCNL @param i_options: number of additional options. DCNL @param ppsz_options: additional options. DCNL @param b_enabled: boolean for enabling the new vod. DCNL @param psz_mux: the muxer of the vod media. DCNL @return: 0 on success, -1 on error.'
def vlm_del_media(self, psz_name): DCNL 'Delete a media (VOD or broadcast). DCNL @param psz_name: the media to delete. DCNL @return: 0 on success, -1 on error.'
def vlm_set_enabled(self, psz_name, b_enabled): DCNL 'Enable or disable a media (VOD or broadcast). DCNL @param psz_name: the media to work on. DCNL @param b_enabled: the new status. DCNL @return: 0 on success, -1 on error.'
def vlm_set_output(self, psz_name, psz_output): DCNL 'Set the output for a media. DCNL @param psz_name: the media to work on. DCNL @param psz_output: the output MRL (the parameter to the "sout" variable). DCNL @return: 0 on success, -1 on error.'
def vlm_set_input(self, psz_name, psz_input): DCNL 'Set a media\'s input MRL. This will delete all existing inputs and DCNL add the specified one. DCNL @param psz_name: the media to work on. DCNL @param psz_input: the input MRL. DCNL @return: 0 on success, -1 on error.'
def vlm_add_input(self, psz_name, psz_input): DCNL 'Add a media\'s input MRL. This will add the specified one. DCNL @param psz_name: the media to work on. DCNL @param psz_input: the input MRL. DCNL @return: 0 on success, -1 on error.'
def vlm_set_loop(self, psz_name, b_loop): DCNL 'Set a media\'s loop status. DCNL @param psz_name: the media to work on. DCNL @param b_loop: the new status. DCNL @return: 0 on success, -1 on error.'
def vlm_set_mux(self, psz_name, psz_mux): DCNL 'Set a media\'s vod muxer. DCNL @param psz_name: the media to work on. DCNL @param psz_mux: the new muxer. DCNL @return: 0 on success, -1 on error.'
def vlm_change_media(self, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop): DCNL 'Edit the parameters of a media. This will delete all existing inputs and DCNL add the specified one. DCNL @param psz_name: the name of the new broadcast. DCNL @param psz_input: the input MRL. DCNL @param psz_output: the output MRL (the parameter to the "sout" variable). DCNL @param i_options: number of additional options. DCNL @param ppsz_options: additional options. DCNL @param b_enabled: boolean for enabling the new broadcast. DCNL @param b_loop: Should this broadcast be played in loop ? DCNL @return: 0 on success, -1 on error.'
def vlm_play_media(self, psz_name): DCNL 'Play the named broadcast. DCNL @param psz_name: the name of the broadcast. DCNL @return: 0 on success, -1 on error.'
def vlm_stop_media(self, psz_name): DCNL 'Stop the named broadcast. DCNL @param psz_name: the name of the broadcast. DCNL @return: 0 on success, -1 on error.'
def vlm_pause_media(self, psz_name): DCNL 'Pause the named broadcast. DCNL @param psz_name: the name of the broadcast. DCNL @return: 0 on success, -1 on error.'
def vlm_seek_media(self, psz_name, f_percentage): DCNL 'Seek in the named broadcast. DCNL @param psz_name: the name of the broadcast. DCNL @param f_percentage: the percentage to seek to. DCNL @return: 0 on success, -1 on error.'
def vlm_show_media(self, psz_name): DCNL 'Return information about the named media as a JSON DCNL string representation. DCNL This function is mainly intended for debugging use, DCNL if you want programmatic access to the state of DCNL a vlm_media_instance_t, please use the corresponding DCNL libvlc_vlm_get_media_instance_xxx -functions. DCNL Currently there are no such functions available for DCNL vlm_media_t though. DCNL @param psz_name: the name of the media, if the name is an empty string, all media is described. DCNL @return: string with information about named media, or None on error.'
def vlm_get_media_instance_position(self, psz_name, i_instance): DCNL 'Get vlm_media instance position by name or instance id. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: position as float or -1. on error.'
def vlm_get_media_instance_time(self, psz_name, i_instance): DCNL 'Get vlm_media instance time by name or instance id. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: time as integer or -1 on error.'
def vlm_get_media_instance_length(self, psz_name, i_instance): DCNL 'Get vlm_media instance length by name or instance id. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: length of media item or -1 on error.'
def vlm_get_media_instance_rate(self, psz_name, i_instance): DCNL 'Get vlm_media instance playback rate by name or instance id. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: playback rate or -1 on error.'
def vlm_get_media_instance_title(self, psz_name, i_instance): DCNL 'Get vlm_media instance title number by name or instance id. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: title as number or -1 on error. DCNL @bug: will always return 0.'
def vlm_get_media_instance_chapter(self, psz_name, i_instance): DCNL 'Get vlm_media instance chapter number by name or instance id. DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: chapter as number or -1 on error. DCNL @bug: will always return 0.'
def vlm_get_media_instance_seekable(self, psz_name, i_instance): DCNL 'Is libvlc instance seekable ? DCNL @param psz_name: name of vlm media instance. DCNL @param i_instance: instance id. DCNL @return: 1 if seekable, 0 if not, -1 if media does not exist. DCNL @bug: will always return 0.'
@memoize_parameterless DCNL def vlm_get_event_manager(self): DCNL 'Get libvlc_event_manager from a vlm media. DCNL The p_event_manager is immutable, so you don\'t have to hold the lock. DCNL @return: libvlc_event_manager.'
def add_options(self, *options): DCNL 'Add a list of options to the media. DCNL Options must be written without the double-dash. Warning: most DCNL audio and video options, such as text renderer, have no DCNL effects on an individual media. These options must be set at DCNL the vlc.Instance or vlc.MediaPlayer instanciation. DCNL @param options: optional media option=value strings'
def tracks_get(self): DCNL 'Get media descriptor\'s elementary streams description DCNL Note, you need to call L{parse}() or play the media at least once DCNL before calling this function. DCNL Not doing this will result in an empty array. DCNL The result must be freed with L{tracks_release}. DCNL @version: LibVLC 2.1.0 and later.'
def add_option(self, psz_options): DCNL 'Add an option to the media. DCNL This option will be used to determine how the media_player will DCNL read the media. This allows to use VLC\'s advanced DCNL reading/streaming options on a per-media basis. DCNL @note: The options are listed in \'vlc --long-help\' from the command line, DCNL e.g. "-sout-all". Keep in mind that available options and their semantics DCNL vary across LibVLC versions and builds. DCNL @warning: Not all options affects L{Media} objects: DCNL Specifically, due to architectural issues most audio and video options, DCNL such as text renderer options, have no effects on an individual media. DCNL These options must be set through L{new}() instead. DCNL @param psz_options: the options (as a string).'
def add_option_flag(self, psz_options, i_flags): DCNL 'Add an option to the media with configurable flags. DCNL This option will be used to determine how the media_player will DCNL read the media. This allows to use VLC\'s advanced DCNL reading/streaming options on a per-media basis. DCNL The options are detailed in vlc --long-help, for instance DCNL "--sout-all". Note that all options are not usable on medias: DCNL specifically, due to architectural issues, video-related options DCNL such as text renderer options cannot be set on a single media. They DCNL must be set on the whole libvlc instance instead. DCNL @param psz_options: the options (as a string). DCNL @param i_flags: the flags for this option.'
def retain(self): DCNL 'Retain a reference to a media descriptor object (libvlc_media_t). Use DCNL L{release}() to decrement the reference count of a DCNL media descriptor object.'
def release(self): DCNL 'Decrement the reference count of a media descriptor object. If the DCNL reference count is 0, then L{release}() will release the DCNL media descriptor object. It will send out an libvlc_MediaFreed event DCNL to all listeners. If the media descriptor object has been released it DCNL should not be used again.'
def get_mrl(self): DCNL 'Get the media resource locator (mrl) from a media descriptor object. DCNL @return: string with mrl of media descriptor object.'
def duplicate(self): DCNL 'Duplicate a media descriptor object.'
def get_meta(self, e_meta): DCNL 'Read the meta of the media. DCNL If the media has not yet been parsed this will return None. DCNL This methods automatically calls L{parse_async}(), so after calling DCNL it you may receive a libvlc_MediaMetaChanged event. If you prefer a synchronous DCNL version ensure that you call L{parse}() before get_meta(). DCNL See L{parse} DCNL See L{parse_async} DCNL See libvlc_MediaMetaChanged. DCNL @param e_meta: the meta to read. DCNL @return: the media\'s meta.'
def set_meta(self, e_meta, psz_value): DCNL 'Set the meta of the media (this function will not save the meta, call DCNL L{save_meta} in order to save the meta). DCNL @param e_meta: the meta to write. DCNL @param psz_value: the media\'s meta.'
def save_meta(self): DCNL 'Save the meta previously set. DCNL @return: true if the write operation was successful.'
def get_state(self): DCNL 'Get current state of media descriptor object. Possible media states DCNL are defined in libvlc_structures.c ( libvlc_NothingSpecial=0, DCNL libvlc_Opening, libvlc_Buffering, libvlc_Playing, libvlc_Paused, DCNL libvlc_Stopped, libvlc_Ended, DCNL libvlc_Error). DCNL See libvlc_state_t. DCNL @return: state of media descriptor object.'
def get_stats(self, p_stats): DCNL 'Get the current statistics about the media. DCNL @param p_stats:: structure that contain the statistics about the media (this structure must be allocated by the caller). DCNL @return: true if the statistics are available, false otherwise \libvlc_return_bool.'
def subitems(self): DCNL 'Get subitems of media descriptor object. This will increment DCNL the reference count of supplied media descriptor object. Use DCNL L{list_release}() to decrement the reference counting. DCNL @return: list of media descriptor subitems or None.'
@memoize_parameterless DCNL def event_manager(self): DCNL 'Get event manager from media descriptor object. DCNL NOTE: this function doesn\'t increment reference counting. DCNL @return: event manager object.'
def get_duration(self): DCNL 'Get duration (in ms) of media descriptor object item. DCNL @return: duration of media item or -1 on error.'
def parse(self): DCNL 'Parse a media. DCNL This fetches (local) art, meta data and tracks information. DCNL The method is synchronous. DCNL See L{parse_async} DCNL See L{get_meta} DCNL See libvlc_media_get_tracks_info.'
def parse_async(self): DCNL 'Parse a media. DCNL This fetches (local) art, meta data and tracks information. DCNL The method is the asynchronous of L{parse}(). DCNL To track when this is over you can listen to libvlc_MediaParsedChanged DCNL event. However if the media was already parsed you will not receive this DCNL event. DCNL See L{parse} DCNL See libvlc_MediaParsedChanged DCNL See L{get_meta} DCNL See libvlc_media_get_tracks_info.'
def parse_with_options(self, parse_flag): DCNL 'Parse the media asynchronously with options. DCNL This fetches (local or network) art, meta data and/or tracks information. DCNL This method is the extended version of L{parse_async}(). DCNL To track when this is over you can listen to libvlc_MediaParsedChanged DCNL event. However if this functions returns an error, you will not receive this DCNL event. DCNL It uses a flag to specify parse options (see libvlc_media_parse_flag_t). All DCNL these flags can be combined. By default, media is parsed if it\'s a local DCNL file. DCNL See libvlc_MediaParsedChanged DCNL See L{get_meta} DCNL See L{tracks_get} DCNL See libvlc_media_parse_flag_t. DCNL @param parse_flag: parse options: DCNL @return: -1 in case of error, 0 otherwise. DCNL @version: LibVLC 3.0.0 or later.'
def is_parsed(self): DCNL 'Get Parsed status for media descriptor object. DCNL See libvlc_MediaParsedChanged. DCNL @return: true if media object has been parsed otherwise it returns false \libvlc_return_bool.'
def set_user_data(self, p_new_user_data): DCNL 'Sets media descriptor\'s user_data. user_data is specialized data DCNL accessed by the host application, VLC.framework uses it as a pointer to DCNL an native object that references a L{Media} pointer. DCNL @param p_new_user_data: pointer to user data.'
def get_user_data(self): DCNL 'Get media descriptor\'s user_data. user_data is specialized data DCNL accessed by the host application, VLC.framework uses it as a pointer to DCNL an native object that references a L{Media} pointer.'
def get_type(self): DCNL 'Get the media type of the media descriptor object. DCNL @return: media type. DCNL @version: LibVLC 3.0.0 and later. See libvlc_media_type_t.'
def player_new_from_media(self): DCNL 'Create a Media Player object from a Media. DCNL @return: a new media player object, or None on error.'
def __new__(cls, ptr=_internal_guard): DCNL '(INTERNAL) ctypes wrapper constructor.'
def start(self): DCNL 'Start media discovery. DCNL To stop it, call L{stop}() or DCNL L{release}() directly. DCNL See L{stop}. DCNL @return: -1 in case of error, 0 otherwise. DCNL @version: LibVLC 3.0.0 or later.'
def stop(self): DCNL 'Stop media discovery. DCNL See L{start}. DCNL @version: LibVLC 3.0.0 or later.'
def release(self): DCNL 'Release media discover object. If the reference count reaches 0, then DCNL the object will be released.'
def localized_name(self): DCNL 'Get media service discover object its localized name. DCNL @return: localized name.'
def media_list(self): DCNL 'Get media service discover media list. DCNL @return: list of media items.'
@memoize_parameterless DCNL def event_manager(self): DCNL 'Get event manager from media service discover object. DCNL @return: event manager object.'
def is_running(self): DCNL 'Query if media service discover object is running. DCNL @return: true if running, false if not \libvlc_return_bool.'
def __new__(cls, ptr=_internal_guard): DCNL '(INTERNAL) ctypes wrapper constructor.'
def release(self): DCNL 'Release media library object. This functions decrements the DCNL reference count of the media library object. If it reaches 0, DCNL then the object will be released.'
def retain(self): DCNL 'Retain a reference to a media library object. This function will DCNL increment the reference counting for this object. Use DCNL L{release}() to decrement the reference count.'
def load(self): DCNL 'Load media library. DCNL @return: 0 on success, -1 on error.'
def media_list(self): DCNL 'Get media library subitems. DCNL @return: media list subitems.'
def add_media(self, mrl): DCNL 'Add media instance to media list. DCNL The L{lock} should be held upon entering this function. DCNL @param mrl: a media instance or a MRL. DCNL @return: 0 on success, -1 if the media list is read-only.'
def release(self): DCNL 'Release media list created with L{new}().'
def retain(self): DCNL 'Retain reference to a media list.'
def set_media(self, p_md): DCNL 'Associate media instance with this media list instance. DCNL If another media instance was present it will be released. DCNL The L{lock} should NOT be held upon entering this function. DCNL @param p_md: media instance to add.'
def media(self): DCNL 'Get media instance from this media list instance. This action will increase DCNL the refcount on the media instance. DCNL The L{lock} should NOT be held upon entering this function. DCNL @return: media instance.'
def insert_media(self, p_md, i_pos): DCNL 'Insert media instance in media list on a position DCNL The L{lock} should be held upon entering this function. DCNL @param p_md: a media instance. DCNL @param i_pos: position in array where to insert. DCNL @return: 0 on success, -1 if the media list is read-only.'
def remove_index(self, i_pos): DCNL 'Remove media instance from media list on a position DCNL The L{lock} should be held upon entering this function. DCNL @param i_pos: position in array where to insert. DCNL @return: 0 on success, -1 if the list is read-only or the item was not found.'
def count(self): DCNL 'Get count on media list items DCNL The L{lock} should be held upon entering this function. DCNL @return: number of items in media list.'
def item_at_index(self, i_pos): DCNL 'List media instance in media list at a position DCNL The L{lock} should be held upon entering this function. DCNL @param i_pos: position in array where to insert. DCNL @return: media instance at position i_pos, or None if not found. In case of success, L{media_retain}() is called to increase the refcount on the media.'
def index_of_item(self, p_md): DCNL 'Find index position of List media instance in media list. DCNL Warning: the function will return the first matched position. DCNL The L{lock} should be held upon entering this function. DCNL @param p_md: media instance. DCNL @return: position of media instance or -1 if media not found.'
def is_readonly(self): DCNL 'This indicates if this media list is read-only from a user point of view. DCNL @return: 1 on readonly, 0 on readwrite \libvlc_return_bool.'
def lock(self): DCNL 'Get lock on media list items.'
def unlock(self): DCNL 'Release lock on media list items DCNL The L{lock} should be held upon entering this function.'
@memoize_parameterless DCNL def event_manager(self): DCNL 'Get libvlc_event_manager from this media list instance. DCNL The p_event_manager is immutable, so you don\'t have to hold the lock. DCNL @return: libvlc_event_manager.'
def get_instance(self): DCNL 'Return the associated Instance.'
def release(self): DCNL 'Release a media_list_player after use DCNL Decrement the reference count of a media player object. If the DCNL reference count is 0, then L{release}() will DCNL release the media player object. If the media player object DCNL has been released, then it should not be used again.'
def retain(self): DCNL 'Retain a reference to a media player list object. Use DCNL L{release}() to decrement reference count.'
@memoize_parameterless DCNL def event_manager(self): DCNL 'Return the event manager of this media_list_player. DCNL @return: the event manager.'
def set_media_player(self, p_mi): DCNL 'Replace media player in media_list_player with this instance. DCNL @param p_mi: media player instance.'
def get_media_player(self): DCNL 'Get media player of the media_list_player instance. DCNL @return: media player instance @note the caller is responsible for releasing the returned instance.'
def set_media_list(self, p_mlist): DCNL 'Set the media list associated with the player. DCNL @param p_mlist: list of media.'
def play(self): DCNL 'Play media list.'
def pause(self): DCNL 'Toggle pause (or resume) media list.'
def is_playing(self): DCNL 'Is media list playing? DCNL @return: true for playing and false for not playing \libvlc_return_bool.'
def get_state(self): DCNL 'Get current libvlc_state of media list player. DCNL @return: libvlc_state_t for media list player.'
def play_item_at_index(self, i_index): DCNL 'Play media list item at position index. DCNL @param i_index: index in media list to play. DCNL @return: 0 upon success -1 if the item wasn\'t found.'
def play_item(self, p_md): DCNL 'Play the given media item. DCNL @param p_md: the media instance. DCNL @return: 0 upon success, -1 if the media is not part of the media list.'
def stop(self): DCNL 'Stop playing media list.'
def next(self): DCNL 'Play next item from media list. DCNL @return: 0 upon success -1 if there is no next item.'
def previous(self): DCNL 'Play previous item from media list. DCNL @return: 0 upon success -1 if there is no previous item.'
def set_playback_mode(self, e_mode): DCNL 'Sets the playback mode for the playlist. DCNL @param e_mode: playback mode specification.'
def get_instance(self): DCNL 'Return the associated Instance.'
def set_mrl(self, mrl, *options): DCNL 'Set the MRL to play. DCNL Warning: most audio and video options, such as text renderer, DCNL have no effects on an individual media. These options must be DCNL set at the vlc.Instance or vlc.MediaPlayer instanciation. DCNL @param mrl: The MRL DCNL @param options: optional media option=value strings DCNL @return: the Media object'
def video_get_spu_description(self): DCNL 'Get the description of available video subtitles.'
def video_get_title_description(self): DCNL 'Get the description of available titles.'
def video_get_chapter_description(self, title): DCNL 'Get the description of available chapters for specific title. DCNL @param title: selected title (int)'
def video_get_track_description(self): DCNL 'Get the description of available video tracks.'
def audio_get_track_description(self): DCNL 'Get the description of available audio tracks.'
def get_full_title_descriptions(self): DCNL 'Get the full description of available titles. DCNL @return: the titles list DCNL @version: LibVLC 3.0.0 and later.'
def get_full_chapter_descriptions(self, i_chapters_of_title): DCNL 'Get the full description of available chapters. DCNL @param index: of the title to query for chapters. DCNL @return: the chapter list DCNL @version: LibVLC 3.0.0 and later.'
def video_get_size(self, num=0): DCNL 'Get the video size in pixels as 2-tuple (width, height). DCNL @param num: video number (default 0).'
def set_hwnd(self, drawable): DCNL 'Set a Win32/Win64 API window handle (HWND). DCNL Specify where the media player should render its video DCNL output. If LibVLC was built without Win32/Win64 API output DCNL support, then this has no effects. DCNL @param drawable: windows handle of the drawable.'
def video_get_width(self, num=0): DCNL 'Get the width of a video in pixels. DCNL @param num: video number (default 0).'
def video_get_height(self, num=0): DCNL 'Get the height of a video in pixels. DCNL @param num: video number (default 0).'
def video_get_cursor(self, num=0): DCNL 'Get the mouse pointer coordinates over a video as 2-tuple (x, y). DCNL Coordinates are expressed in terms of the decoded video resolution, DCNL B{not} in terms of pixels on the screen/viewport.  To get the DCNL latter, you must query your windowing system directly. DCNL Either coordinate may be negative or larger than the corresponding DCNL size of the video, if the cursor is outside the rendering area. DCNL @warning: The coordinates may be out-of-date if the pointer is not DCNL located on the video rendering area.  LibVLC does not track the DCNL mouse pointer if the latter is outside the video widget. DCNL @note: LibVLC does not support multiple mouse pointers (but does DCNL support multiple input devices sharing the same pointer). DCNL @param num: video number (default 0).'
def release(self): DCNL 'Release a media_player after use DCNL Decrement the reference count of a media player object. If the DCNL reference count is 0, then L{release}() will DCNL release the media player object. If the media player object DCNL has been released, then it should not be used again.'
def retain(self): DCNL 'Retain a reference to a media player object. Use DCNL L{release}() to decrement reference count.'
def set_media(self, p_md): DCNL 'Set the media that will be used by the media_player. If any, DCNL previous md will be released. DCNL @param p_md: the Media. Afterwards the p_md can be safely destroyed.'
def get_media(self): DCNL 'Get the media used by the media_player. DCNL @return: the media associated with p_mi, or None if no media is associated.'
@memoize_parameterless DCNL def event_manager(self): DCNL 'Get the Event Manager from which the media player send event. DCNL @return: the event manager associated with p_mi.'
def is_playing(self): DCNL 'is_playing. DCNL @return: 1 if the media player is playing, 0 otherwise \libvlc_return_bool.'
def play(self): DCNL 'Play. DCNL @return: 0 if playback started (and was already started), or -1 on error.'
def set_pause(self, do_pause): DCNL 'Pause or resume (no effect if there is no media). DCNL @param do_pause: play/resume if zero, pause if non-zero. DCNL @version: LibVLC 1.1.1 or later.'
def pause(self): DCNL 'Toggle pause (no effect if there is no media).'
def stop(self): DCNL 'Stop (no effect if there is no media).'
def video_set_callbacks(self, lock, unlock, display, opaque): DCNL 'Set callbacks and private data to render decoded video to a custom area DCNL in memory. DCNL Use L{video_set_format}() or L{video_set_format_callbacks}() DCNL to configure the decoded format. DCNL @param lock: callback to lock video memory (must not be None). DCNL @param unlock: callback to unlock video memory (or None if not needed). DCNL @param display: callback to display video (or None if not needed). DCNL @param opaque: private pointer for the three callbacks (as first parameter). DCNL @version: LibVLC 1.1.1 or later.'
def video_set_format(self, chroma, width, height, pitch): DCNL 'Set decoded video chroma and dimensions. DCNL This only works in combination with L{video_set_callbacks}(), DCNL and is mutually exclusive with L{video_set_format_callbacks}(). DCNL @param chroma: a four-characters string identifying the chroma (e.g. "RV32" or "YUYV"). DCNL @param width: pixel width. DCNL @param height: pixel height. DCNL @param pitch: line pitch (in bytes). DCNL @version: LibVLC 1.1.1 or later. DCNL @bug: All pixel planes are expected to have the same pitch. To use the YCbCr color space with chrominance subsampling, consider using L{video_set_format_callbacks}() instead.'
def video_set_format_callbacks(self, setup, cleanup): DCNL 'Set decoded video chroma and dimensions. This only works in combination with DCNL L{video_set_callbacks}(). DCNL @param setup: callback to select the video format (cannot be None). DCNL @param cleanup: callback to release any allocated resources (or None). DCNL @version: LibVLC 2.0.0 or later.'
def set_nsobject(self, drawable): DCNL 'Set the NSView handler where the media player should render its video output. DCNL Use the vout called "macosx". DCNL The drawable is an NSObject that follow the VLCOpenGLVideoViewEmbedding DCNL protocol: DCNL @code.m DCNL \@protocol VLCOpenGLVideoViewEmbedding <NSObject> DCNL - (void)addVoutSubview:(NSView *)view; DCNL - (void)removeVoutSubview:(NSView *)view; DCNL \@end DCNL @endcode DCNL Or it can be an NSView object. DCNL If you want to use it along with Qt4 see the QMacCocoaViewContainer. Then DCNL the following code should work: DCNL @code.mm DCNL NSView *video = [[NSView alloc] init]; DCNL QMacCocoaViewContainer *container = new QMacCocoaViewContainer(video, parent); DCNL L{set_nsobject}(mp, video); DCNL [video release]; DCNL @endcode DCNL You can find a live example in VLCVideoView in VLCKit.framework. DCNL @param drawable: the drawable that is either an NSView or an object following the VLCOpenGLVideoViewEmbedding protocol.'
def get_nsobject(self): DCNL 'Get the NSView handler previously set with L{set_nsobject}(). DCNL @return: the NSView handler or 0 if none where set.'
def set_agl(self, drawable): DCNL '\deprecated Use L{set_nsobject} instead.'
def get_agl(self): DCNL '\deprecated Use L{get_nsobject} instead.'
def set_xwindow(self, drawable): DCNL 'Set an X Window System drawable where the media player should render its DCNL video output. The call takes effect when the playback starts. If it is DCNL already started, it might need to be stopped before changes apply. DCNL If LibVLC was built without X11 output support, then this function has no DCNL effects. DCNL By default, LibVLC will capture input events on the video rendering area. DCNL Use L{video_set_mouse_input}() and L{video_set_key_input}() to DCNL disable that and deliver events to the parent window / to the application DCNL instead. By design, the X11 protocol delivers input events to only one DCNL recipient. DCNL @warning DCNL The application must call the XInitThreads() function from Xlib before DCNL L{new}(), and before any call to XOpenDisplay() directly or via any DCNL other library. Failure to call XInitThreads() will seriously impede LibVLC DCNL performance. Calling XOpenDisplay() before XInitThreads() will eventually DCNL crash the process. That is a limitation of Xlib. DCNL @param drawable: X11 window ID @note The specified identifier must correspond to an existing Input/Output class X11 window. Pixmaps are B{not} currently supported. The default X11 server is assumed, i.e. that specified in the DISPLAY environment variable. @warning LibVLC can deal with invalid X11 handle errors, however some display drivers (EGL, GLX, VA and/or VDPAU) can unfortunately not. Thus the window handle must remain valid until playback is stopped, otherwise the process may abort or crash. DCNL @bug No more than one window handle per media player instance can be specified. If the media has multiple simultaneously active video tracks, extra tracks will be rendered into external windows beyond the control of the application.'
def get_xwindow(self): DCNL 'Get the X Window System window identifier previously set with DCNL L{set_xwindow}(). Note that this will return the identifier DCNL even if VLC is not currently using it (for instance if it is playing an DCNL audio-only input). DCNL @return: an X window ID, or 0 if none where set.'
def get_hwnd(self): DCNL 'Get the Windows API window handle (HWND) previously set with DCNL L{set_hwnd}(). The handle will be returned even if LibVLC DCNL is not currently outputting any video to it. DCNL @return: a window handle or None if there are none.'
def set_android_context(self, p_jvm, p_awindow_handler): DCNL 'Set the android context. DCNL @param p_jvm: the Java VM of the android process. DCNL @param awindow_handler: org.videolan.libvlc.IAWindowNativeHandler jobject implemented by the org.videolan.libvlc.MediaPlayer class from the libvlc-android project. DCNL @version: LibVLC 3.0.0 and later.'
def audio_set_callbacks(self, play, pause, resume, flush, drain, opaque): DCNL 'Set callbacks and private data for decoded audio. DCNL Use L{audio_set_format}() or L{audio_set_format_callbacks}() DCNL to configure the decoded audio format. DCNL @param play: callback to play audio samples (must not be None). DCNL @param pause: callback to pause playback (or None to ignore). DCNL @param resume: callback to resume playback (or None to ignore). DCNL @param flush: callback to flush audio buffers (or None to ignore). DCNL @param drain: callback to drain audio buffers (or None to ignore). DCNL @param opaque: private pointer for the audio callbacks (as first parameter). DCNL @version: LibVLC 2.0.0 or later.'
def audio_set_volume_callback(self, set_volume): DCNL 'Set callbacks and private data for decoded audio. This only works in DCNL combination with L{audio_set_callbacks}(). DCNL Use L{audio_set_format}() or L{audio_set_format_callbacks}() DCNL to configure the decoded audio format. DCNL @param set_volume: callback to apply audio volume, or None to apply volume in software. DCNL @version: LibVLC 2.0.0 or later.'
def audio_set_format_callbacks(self, setup, cleanup): DCNL 'Set decoded audio format. This only works in combination with DCNL L{audio_set_callbacks}(). DCNL @param setup: callback to select the audio format (cannot be None). DCNL @param cleanup: callback to release any allocated resources (or None). DCNL @version: LibVLC 2.0.0 or later.'
def audio_set_format(self, format, rate, channels): DCNL 'Set decoded audio format. DCNL This only works in combination with L{audio_set_callbacks}(), DCNL and is mutually exclusive with L{audio_set_format_callbacks}(). DCNL @param format: a four-characters string identifying the sample format (e.g. "S16N" or "FL32"). DCNL @param rate: sample rate (expressed in Hz). DCNL @param channels: channels count. DCNL @version: LibVLC 2.0.0 or later.'
def get_length(self): DCNL 'Get the current movie length (in ms). DCNL @return: the movie length (in ms), or -1 if there is no media.'
def get_time(self): DCNL 'Get the current movie time (in ms). DCNL @return: the movie time (in ms), or -1 if there is no media.'
def set_time(self, i_time): DCNL 'Set the movie time (in ms). This has no effect if no media is being played. DCNL Not all formats and protocols support this. DCNL @param i_time: the movie time (in ms).'
def get_position(self): DCNL 'Get movie position as percentage between 0.0 and 1.0. DCNL @return: movie position, or -1. in case of error.'
def set_position(self, f_pos): DCNL 'Set movie position as percentage between 0.0 and 1.0. DCNL This has no effect if playback is not enabled. DCNL This might not work depending on the underlying input format and protocol. DCNL @param f_pos: the position.'
def set_chapter(self, i_chapter): DCNL 'Set movie chapter (if applicable). DCNL @param i_chapter: chapter number to play.'
def get_chapter(self): DCNL 'Get movie chapter. DCNL @return: chapter number currently playing, or -1 if there is no media.'
def get_chapter_count(self): DCNL 'Get movie chapter count. DCNL @return: number of chapters in movie, or -1.'
def will_play(self): DCNL 'Is the player able to play. DCNL @return: boolean \libvlc_return_bool.'
def get_chapter_count_for_title(self, i_title): DCNL 'Get title chapter count. DCNL @param i_title: title. DCNL @return: number of chapters in title, or -1.'
def set_title(self, i_title): DCNL 'Set movie title. DCNL @param i_title: title number to play.'
def get_title(self): DCNL 'Get movie title. DCNL @return: title number currently playing, or -1.'
def get_title_count(self): DCNL 'Get movie title count. DCNL @return: title number count, or -1.'
def previous_chapter(self): DCNL 'Set previous chapter (if applicable).'
def next_chapter(self): DCNL 'Set next chapter (if applicable).'
def get_rate(self): DCNL 'Get the requested movie play rate. DCNL @warning: Depending on the underlying media, the requested rate may be DCNL different from the real playback rate. DCNL @return: movie play rate.'
def set_rate(self, rate): DCNL 'Set movie play rate. DCNL @param rate: movie play rate to set. DCNL @return: -1 if an error was detected, 0 otherwise (but even then, it might not actually work depending on the underlying media protocol).'
def get_state(self): DCNL 'Get current movie state. DCNL @return: the current state of the media player (playing, paused, ...) See libvlc_state_t.'
def get_fps(self): DCNL 'Get movie fps rate. DCNL @return: frames per second (fps) for this playing movie, or 0 if unspecified.'
def has_vout(self): DCNL 'How many video outputs does this media player have? DCNL @return: the number of video outputs.'
def is_seekable(self): DCNL 'Is this media player seekable? DCNL @return: true if the media player can seek \libvlc_return_bool.'
def can_pause(self): DCNL 'Can this media player be paused? DCNL @return: true if the media player can pause \libvlc_return_bool.'
def program_scrambled(self): DCNL 'Check if the current program is scrambled. DCNL @return: true if the current program is scrambled \libvlc_return_bool. DCNL @version: LibVLC 2.2.0 or later.'
def next_frame(self): DCNL 'Display the next frame (if supported).'
def navigate(self, navigate): DCNL 'Navigate through DVD Menu. DCNL @param navigate: the Navigation mode. DCNL @version: libVLC 2.0.0 or later.'
def set_video_title_display(self, position, timeout): DCNL 'Set if, and how, the video title will be shown when media is played. DCNL @param position: position at which to display the title, or libvlc_position_disable to prevent the title from being displayed. DCNL @param timeout: title display timeout in milliseconds (ignored if libvlc_position_disable). DCNL @version: libVLC 2.1.0 or later.'
def toggle_fullscreen(self): DCNL 'Toggle fullscreen status on non-embedded video outputs. DCNL @warning: The same limitations applies to this function DCNL as to L{set_fullscreen}().'
def set_fullscreen(self, b_fullscreen): DCNL 'Enable or disable fullscreen. DCNL @warning: With most window managers, only a top-level windows can be in DCNL full-screen mode. Hence, this function will not operate properly if DCNL L{set_xwindow}() was used to embed the video in a DCNL non-top-level window. In that case, the embedding window must be reparented DCNL to the root window B{before} fullscreen mode is enabled. You will want DCNL to reparent it back to its normal parent when disabling fullscreen. DCNL @param b_fullscreen: boolean for fullscreen status.'
def get_fullscreen(self): DCNL 'Get current fullscreen status. DCNL @return: the fullscreen status (boolean) \libvlc_return_bool.'
def video_set_key_input(self, on): DCNL 'Enable or disable key press events handling, according to the LibVLC hotkeys DCNL configuration. By default and for historical reasons, keyboard events are DCNL handled by the LibVLC video widget. DCNL @note: On X11, there can be only one subscriber for key press and mouse DCNL click events per window. If your application has subscribed to those events DCNL for the X window ID of the video widget, then LibVLC will not be able to DCNL handle key presses and mouse clicks in any case. DCNL @warning: This function is only implemented for X11 and Win32 at the moment. DCNL @param on: true to handle key press events, false to ignore them.'
def video_set_mouse_input(self, on): DCNL 'Enable or disable mouse click events handling. By default, those events are DCNL handled. This is needed for DVD menus to work, as well as a few video DCNL filters such as "puzzle". DCNL See L{video_set_key_input}(). DCNL @warning: This function is only implemented for X11 and Win32 at the moment. DCNL @param on: true to handle mouse click events, false to ignore them.'
def video_get_scale(self): DCNL 'Get the current video scaling factor. DCNL See also L{video_set_scale}(). DCNL @return: the currently configured zoom factor, or 0. if the video is set to fit to the output window/drawable automatically.'
def video_set_scale(self, f_factor): DCNL 'Set the video scaling factor. That is the ratio of the number of pixels on DCNL screen to the number of pixels in the original decoded video in each DCNL dimension. Zero is a special value; it will adjust the video to the output DCNL window/drawable (in windowed mode) or the entire screen. DCNL Note that not all video outputs support scaling. DCNL @param f_factor: the scaling factor, or zero.'
def video_get_aspect_ratio(self): DCNL 'Get current video aspect ratio. DCNL @return: the video aspect ratio or None if unspecified (the result must be released with free() or L{free}()).'
def video_set_aspect_ratio(self, psz_aspect): DCNL 'Set new video aspect ratio. DCNL @param psz_aspect: new video aspect-ratio or None to reset to default @note Invalid aspect ratios are ignored.'
def video_get_spu(self): DCNL 'Get current video subtitle. DCNL @return: the video subtitle selected, or -1 if none.'
def video_get_spu_count(self): DCNL 'Get the number of available video subtitles. DCNL @return: the number of available video subtitles.'
def video_set_spu(self, i_spu): DCNL 'Set new video subtitle. DCNL @param i_spu: video subtitle track to select (i_id from track description). DCNL @return: 0 on success, -1 if out of range.'
def video_set_subtitle_file(self, psz_subtitle): DCNL 'Set new video subtitle file. DCNL @param psz_subtitle: new video subtitle file. DCNL @return: the success status (boolean).'
def video_get_spu_delay(self): DCNL 'Get the current subtitle delay. Positive values means subtitles are being DCNL displayed later, negative values earlier. DCNL @return: time (in microseconds) the display of subtitles is being delayed. DCNL @version: LibVLC 2.0.0 or later.'
def video_set_spu_delay(self, i_delay): DCNL 'Set the subtitle delay. This affects the timing of when the subtitle will DCNL be displayed. Positive values result in subtitles being displayed later, DCNL while negative values will result in subtitles being displayed earlier. DCNL The subtitle delay will be reset to zero each time the media changes. DCNL @param i_delay: time (in microseconds) the display of subtitles should be delayed. DCNL @return: 0 on success, -1 on error. DCNL @version: LibVLC 2.0.0 or later.'
def video_get_crop_geometry(self): DCNL 'Get current crop filter geometry. DCNL @return: the crop filter geometry or None if unset.'
def video_set_crop_geometry(self, psz_geometry): DCNL 'Set new crop filter geometry. DCNL @param psz_geometry: new crop filter geometry (None to unset).'
def video_get_teletext(self): DCNL 'Get current teletext page requested. DCNL @return: the current teletext page requested.'
def video_set_teletext(self, i_page): DCNL 'Set new teletext page to retrieve. DCNL @param i_page: teletex page number requested.'
def toggle_teletext(self): DCNL 'Toggle teletext transparent status on video output.'
def video_get_track_count(self): DCNL 'Get number of available video tracks. DCNL @return: the number of available video tracks (int).'
def video_get_track(self): DCNL 'Get current video track. DCNL @return: the video track ID (int) or -1 if no active input.'
def video_set_track(self, i_track): DCNL 'Set video track. DCNL @param i_track: the track ID (i_id field from track description). DCNL @return: 0 on success, -1 if out of range.'
def video_take_snapshot(self, num, psz_filepath, i_width, i_height): DCNL 'Take a snapshot of the current video window. DCNL If i_width AND i_height is 0, original size is used. DCNL If i_width XOR i_height is 0, original aspect-ratio is preserved. DCNL @param num: number of video output (typically 0 for the first/only one). DCNL @param psz_filepath: the path where to save the screenshot to. DCNL @param i_width: the snapshot\'s width. DCNL @param i_height: the snapshot\'s height. DCNL @return: 0 on success, -1 if the video was not found.'
def video_set_deinterlace(self, psz_mode): DCNL 'Enable or disable deinterlace filter. DCNL @param psz_mode: type of deinterlace filter, None to disable.'
def video_get_marquee_int(self, option): DCNL 'Get an integer marquee option value. DCNL @param option: marq option to get See libvlc_video_marquee_int_option_t.'
def video_get_marquee_string(self, option): DCNL 'Get a string marquee option value. DCNL @param option: marq option to get See libvlc_video_marquee_string_option_t.'
def video_set_marquee_int(self, option, i_val): DCNL 'Enable, disable or set an integer marquee option DCNL Setting libvlc_marquee_Enable has the side effect of enabling (arg !0) DCNL or disabling (arg 0) the marq filter. DCNL @param option: marq option to set See libvlc_video_marquee_int_option_t. DCNL @param i_val: marq option value.'
def video_set_marquee_string(self, option, psz_text): DCNL 'Set a marquee string option. DCNL @param option: marq option to set See libvlc_video_marquee_string_option_t. DCNL @param psz_text: marq option value.'
def video_get_logo_int(self, option): DCNL 'Get integer logo option. DCNL @param option: logo option to get, values of libvlc_video_logo_option_t.'
def video_set_logo_int(self, option, value): DCNL 'Set logo option as integer. Options that take a different type value DCNL are ignored. DCNL Passing libvlc_logo_enable as option value has the side effect of DCNL starting (arg !0) or stopping (arg 0) the logo filter. DCNL @param option: logo option to set, values of libvlc_video_logo_option_t. DCNL @param value: logo option value.'
def video_set_logo_string(self, option, psz_value): DCNL 'Set logo option as string. Options that take a different type value DCNL are ignored. DCNL @param option: logo option to set, values of libvlc_video_logo_option_t. DCNL @param psz_value: logo option value.'
def video_get_adjust_int(self, option): DCNL 'Get integer adjust option. DCNL @param option: adjust option to get, values of libvlc_video_adjust_option_t. DCNL @version: LibVLC 1.1.1 and later.'
def video_set_adjust_int(self, option, value): DCNL 'Set adjust option as integer. Options that take a different type value DCNL are ignored. DCNL Passing libvlc_adjust_enable as option value has the side effect of DCNL starting (arg !0) or stopping (arg 0) the adjust filter. DCNL @param option: adust option to set, values of libvlc_video_adjust_option_t. DCNL @param value: adjust option value. DCNL @version: LibVLC 1.1.1 and later.'
def video_get_adjust_float(self, option): DCNL 'Get float adjust option. DCNL @param option: adjust option to get, values of libvlc_video_adjust_option_t. DCNL @version: LibVLC 1.1.1 and later.'
def video_set_adjust_float(self, option, value): DCNL 'Set adjust option as float. Options that take a different type value DCNL are ignored. DCNL @param option: adust option to set, values of libvlc_video_adjust_option_t. DCNL @param value: adjust option value. DCNL @version: LibVLC 1.1.1 and later.'
def audio_output_set(self, psz_name): DCNL 'Selects an audio output module. DCNL @note: Any change will take be effect only after playback is stopped and DCNL restarted. Audio output cannot be changed while playing. DCNL @param psz_name: name of audio output, use psz_name of See L{AudioOutput}. DCNL @return: 0 if function succeded, -1 on error.'
def audio_output_device_enum(self): DCNL 'Gets a list of potential audio output devices, DCNL See L{audio_output_device_set}(). DCNL @note: Not all audio outputs support enumerating devices. DCNL The audio output may be functional even if the list is empty (None). DCNL @note: The list may not be exhaustive. DCNL @warning: Some audio output devices in the list might not actually work in DCNL some circumstances. By default, it is recommended to not specify any DCNL explicit audio device. DCNL @return: A None-terminated linked list of potential audio output devices. It must be freed with L{audio_output_device_list_release}(). DCNL @version: LibVLC 2.2.0 or later.'
def audio_output_device_set(self, module, device_id): DCNL 'Configures an explicit audio output device. DCNL If the module paramater is None, audio output will be moved to the device DCNL specified by the device identifier string immediately. This is the DCNL recommended usage. DCNL A list of adequate potential device strings can be obtained with DCNL L{audio_output_device_enum}(). DCNL However passing None is supported in LibVLC version 2.2.0 and later only; DCNL in earlier versions, this function would have no effects when the module DCNL parameter was None. DCNL If the module parameter is not None, the device parameter of the DCNL corresponding audio output, if it exists, will be set to the specified DCNL string. Note that some audio output modules do not have such a parameter DCNL (notably MMDevice and PulseAudio). DCNL A list of adequate potential device strings can be obtained with DCNL L{audio_output_device_list_get}(). DCNL @note: This function does not select the specified audio output plugin. DCNL L{audio_output_set}() is used for that purpose. DCNL @warning: The syntax for the device parameter depends on the audio output. DCNL Some audio output modules require further parameters (e.g. a channels map DCNL in the case of ALSA). DCNL @param module: If None, current audio output module. if non-None, name of audio output module. DCNL @param device_id: device identifier string. DCNL @return: Nothing. Errors are ignored (this is a design bug).'
def audio_output_device_get(self): DCNL 'Get the current audio output device identifier. DCNL This complements L{audio_output_device_set}(). DCNL @warning: The initial value for the current audio output device identifier DCNL may not be set or may be some unknown value. A LibVLC application should DCNL compare this value against the known device identifiers (e.g. those that DCNL were previously retrieved by a call to L{audio_output_device_enum} or DCNL L{audio_output_device_list_get}) to find the current audio output device. DCNL It is possible that the selected audio output device changes (an external DCNL change) without a call to L{audio_output_device_set}. That may make this DCNL method unsuitable to use if a LibVLC application is attempting to track DCNL dynamic audio device changes as they happen. DCNL @return: the current audio output device identifier None if no device is selected or in case of error (the result must be released with free() or L{free}()). DCNL @version: LibVLC 3.0.0 or later.'
def audio_toggle_mute(self): DCNL 'Toggle mute status.'
def audio_get_mute(self): DCNL 'Get current mute status. DCNL @return: the mute status (boolean) if defined, -1 if undefined/unapplicable.'
def audio_set_mute(self, status): DCNL 'Set mute status. DCNL @param status: If status is true then mute, otherwise unmute @warning This function does not always work. If there are no active audio playback stream, the mute status might not be available. If digital pass-through (S/PDIF, HDMI...) is in use, muting may be unapplicable. Also some audio output plugins do not support muting at all. @note To force silent playback, disable all audio tracks. This is more efficient and reliable than mute.'
def audio_get_volume(self): DCNL 'Get current software audio volume. DCNL @return: the software volume in percents (0 = mute, 100 = nominal / 0dB).'
def audio_set_volume(self, i_volume): DCNL 'Set current software audio volume. DCNL @param i_volume: the volume in percents (0 = mute, 100 = 0dB). DCNL @return: 0 if the volume was set, -1 if it was out of range.'
def audio_get_track_count(self): DCNL 'Get number of available audio tracks. DCNL @return: the number of available audio tracks (int), or -1 if unavailable.'
def audio_get_track(self): DCNL 'Get current audio track. DCNL @return: the audio track ID or -1 if no active input.'
def audio_set_track(self, i_track): DCNL 'Set current audio track. DCNL @param i_track: the track ID (i_id field from track description). DCNL @return: 0 on success, -1 on error.'
def audio_get_channel(self): DCNL 'Get current audio channel. DCNL @return: the audio channel See libvlc_audio_output_channel_t.'
def audio_set_channel(self, channel): DCNL 'Set current audio channel. DCNL @param channel: the audio channel, See libvlc_audio_output_channel_t. DCNL @return: 0 on success, -1 on error.'
def audio_get_delay(self): DCNL 'Get current audio delay. DCNL @return: the audio delay (microseconds). DCNL @version: LibVLC 1.1.1 or later.'
def audio_set_delay(self, i_delay): DCNL 'Set current audio delay. The audio delay will be reset to zero each time the media changes. DCNL @param i_delay: the audio delay (microseconds). DCNL @return: 0 on success, -1 on error. DCNL @version: LibVLC 1.1.1 or later.'
def set_equalizer(self, p_equalizer): DCNL 'Apply new equalizer settings to a media player. DCNL The equalizer is first created by invoking L{audio_equalizer_new}() or DCNL L{audio_equalizer_new_from_preset}(). DCNL It is possible to apply new equalizer settings to a media player whether the media DCNL player is currently playing media or not. DCNL Invoking this method will immediately apply the new equalizer settings to the audio DCNL output of the currently playing media if there is any. DCNL If there is no currently playing media, the new equalizer settings will be applied DCNL later if and when new media is played. DCNL Equalizer settings will automatically be applied to subsequently played media. DCNL To disable the equalizer for a media player invoke this method passing None for the DCNL p_equalizer parameter. DCNL The media player does not keep a reference to the supplied equalizer so it is safe DCNL for an application to release the equalizer reference any time after this method DCNL returns. DCNL @param p_equalizer: opaque equalizer handle, or None to disable the equalizer for this media player. DCNL @return: zero on success, -1 on error. DCNL @version: LibVLC 2.2.0 or later.'
def start(self): DCNL 'First test whether we already have a Tribler process listening on port 8085. If so, use that one and don\'t DCNL start a new, fresh session.'
def pipe_wait(self, child_conn): DCNL 'This method is executed in a separate thread and is only here since there are some calls that are crashing on DCNL macOS in a subprocess (due to libdispatch.dylib).'
def plot_absolute_values(self): DCNL 'Plot two lines of the absolute amounts of contributed and consumed bytes.'
def check_health(self): DCNL 'Perform a request to check the health of the torrent that is represented by this widget. DCNL Don\'t do this if we are already checking the health or if we have the health info.'
def on_health_response(self, response): DCNL 'When we receive a health response, update the health status.'
def get_first_items(self, num, cls=None): DCNL 'Return the first num widget items with type cls. DCNL This can be useful when for instance you need the first five search results.'
def reset_player(self): DCNL 'Reset the video player, i.e. when a download is removed that was being played.'
def process_uri_request(self): DCNL 'Process a URI request if we have one in the queue.'
def perform_request(self, endpoint, read_callback, data='', method='GET', capture_errors=True): DCNL 'Perform a HTTP request. DCNL :param endpoint: the endpoint to call (i.e. "statistics") DCNL :param read_callback: the callback to be called with result info when we have the data DCNL :param data: optional POST data to be sent with the request DCNL :param method: the HTTP verb (GET/POST/PUT/PATCH) DCNL :param capture_errors: whether errors should be handled by this class (defaults to True)'
def on_finished(self): DCNL 'Somehow, the events connection dropped. Try to reconnect.'
@pass_when_stopped DCNL def schedule_task(self, task, delay_time=0.0, *args, **kwargs): DCNL 'Uses RemoteTorrentHandler to schedule a task.'
@pass_when_stopped DCNL def _start_pending_requests(self): DCNL 'Starts pending requests.'
@abstractmethod DCNL def add_request(self, key, candidate, timeout=None): DCNL 'Adds a new request.'
@abstractmethod DCNL def _do_request(self): DCNL 'Starts processing pending requests.'
@call_on_reactor_thread DCNL def _success_callback(self, meta_info): DCNL 'The callback that will be called by LibtorrentMgr when a download was successful.'
@call_on_reactor_thread DCNL def _failure_callback(self, infohash): DCNL 'The callback that will be called by LibtorrentMgr when a download failed.'
def get_libtorrent_version(self): DCNL 'This method returns the version of the used libtorrent DCNL library and is required for compatibility purposes'
def update_max_rates_from_config(self): DCNL 'Set the maximum download and maximum upload rate limits with the value in the config. DCNL This is the extra step necessary to apply a new maximum download/upload rate setting. DCNL :return:'
def check_handle(self): DCNL 'Check whether the handle exists and is valid. If so, stop the looping call and fire the deferreds waiting DCNL for the handle.'
def get_handle(self): DCNL 'Returns a deferred that fires with a valid libtorrent download handle.'
def setup(self, dcfg=None, pstate=None, wrapperDelay=0, share_mode=False, checkpoint_disabled=False): DCNL 'Create a Download object. Used internally by Session. DCNL @param dcfg DownloadStartupConfig or None (in which case DCNL a new DownloadConfig() is created and the result DCNL becomes the runtime config of this Download. DCNL :returns a Deferred to which a callback can be added which returns the result of DCNL network_create_engine_wrapper.'
def can_create_engine_wrapper(self): DCNL 'Periodically checks whether the engine wrapper can be created. DCNL Notifies when it\'s ready by calling the callback of the deferred being returned. DCNL :return: A deferred that will be called when you can create the engine wrapper.'
@checkHandleAndSynchronize('') DCNL def get_pieces_base64(self): DCNL 'Returns a base64 encoded bitmask of the pieces that we have.'
@checkHandleAndSynchronize(0) DCNL def get_num_pieces(self): DCNL 'Return the total number of pieces'
def on_save_resume_data_alert(self, alert): DCNL 'Callback for the alert that contains the resume data of a specific download. DCNL This resume data will be written to a file on disk.'
def update_lt_stats(self): DCNL 'Update libtorrent stats and check if the download should be stopped.'
def get_status(self): DCNL 'Returns the status of the download. DCNL @return DLSTATUS_*'
def get_length(self): DCNL 'Returns the size of the torrent content. DCNL @return float'
def get_progress(self): DCNL 'Return fraction of content downloaded. DCNL @return float 0..1'
def get_current_speed(self, dir): DCNL 'Return last reported speed in bytes/s DCNL @return float'
def save_resume_data(self): DCNL 'Save the resume data of a download. This method returns a deferred that fires when the resume data is available. DCNL Note that this method only calls save_resume_data once on subsequent calls.'
def set_moreinfo_stats(self, enable): DCNL 'Called by any thread'
def network_get_stats(self, getpeerlist): DCNL '@return (status, stats, seeding_stats, logmsgs, coopdl_helpers, coopdl_coordinator)'
@staticmethod DCNL def create_peerlist_data(peer_info): DCNL 'A function to convert peer_info libtorrent object into dictionary DCNL This data is used to identify peers with combination of several flags'
def set_state_callback(self, usercallback, getpeerlist=False): DCNL 'Called by any thread'
def network_get_state(self, usercallback, getpeerlist): DCNL 'Called by network thread'
def stop_remove(self, removestate=False, removecontent=False): DCNL 'Called by any thread. Called on Session.remove_download()'
def network_stop(self, removestate, removecontent): DCNL 'Called by network thread, but safe for any'
def get_content_dest(self): DCNL 'Returns the file to which the downloaded content is saved.'
def set_filepieceranges(self): DCNL 'Determine which file maps to which piece ranges for progress info'
def restart(self): DCNL 'Restart the Download'
@checkHandleAndSynchronize([]) DCNL def get_dest_files(self, exts=None): DCNL 'You can give a list of extensions to return. If None: return all dest_files DCNL @return list of (torrent,disk) filename tuples.'
def checkpoint(self): DCNL 'Checkpoint this download. Returns a deferred that fires when the checkpointing is completed.'
def add_peer(self, addr): DCNL 'Add a peer address from 3rd source (not tracker, not DHT) to this download. DCNL @param (hostname_ip,port) tuple'
def __init__(self, session): DCNL 'Constructor. DCNL :param session: The Tribler session.'
def get_tribler_statistics(self): DCNL 'Return a dictionary with some general Tribler statistics.'
def get_dispersy_statistics(self): DCNL 'Return a dictionary with some general Dispersy statistics.'
def get_community_statistics(self): DCNL 'Return a dictionary with general statistics of the active Dispersy communities.'
def _migrate_torrent_collecting_dir(self): DCNL 'Migrates the torrent collecting directory.'
def _ingest_torrent_files(self): DCNL 'Renames all the torrent files to INFOHASH.torrent and delete unparseable ones.'
def convert(self): DCNL 'Calling this method will convert all configuration files to the ConfigObj.state format.'
def convert_session_config(self): DCNL 'Convert the sessionconfig.pickle file to triblerd.conf. Do nothing if we do not have a pickle file. DCNL Remove the pickle file after we are done.'
def convert_main_config(self): DCNL 'Convert the abc.conf, user_download_choice.pickle, gui_settings and recent download history files DCNL to triblerd.conf.'
def convert_download_checkpoints(self): DCNL 'Convert all pickle download checkpoints to .state files.'
def run(self): DCNL 'Run the upgrader if it is enabled in the config. DCNL Note that by default, upgrading is enabled in the config. It is then disabled DCNL after upgrading to Tribler 7.'
def upgrade_to_tribler7(self): DCNL 'This method performs actions necessary to upgrade to Tribler 7.'
def notify_starting(self): DCNL 'Broadcast a notification (event) that the upgrader is starting doing work DCNL after a check has established work on the db is required. DCNL Will only fire once.'
def notify_done(self): DCNL 'Broadcast a notification (event) that the upgrader is done.'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def upgrade_database_to_current_version(self): DCNL 'Checks the database version and upgrade if it is not the latest version.'
def start_migrate(self): DCNL 'Starts migrating from Tribler 6.3 to 6.4.'
def _migrate_torrent_collecting_dir(self): DCNL 'Migrates the torrent collecting directory.'
def _get_total_file_count(self): DCNL 'Walks through the torrent collecting directory and gets the total number of file.'
def _delete_swift_reseeds(self): DCNL 'Deletes the reseeds dir, not used anymore.'
def _delete_swift_files(self): DCNL 'Deletes all partial swift downloads, also clean up obsolete .mhash and .mbinmap files.'
def _rename_torrent_files(self): DCNL 'Renames all the torrent files to INFOHASH.torrent and delete unparseable ones.'
def _delete_all_directories(self): DCNL 'Deletes all directories in the torrent collecting directory.'
def _update_dispersy(self): DCNL 'Cleans up all SearchCommunity and MetadataCommunity stuff in dispersy database.'
def start_migrate(self): DCNL 'Starts migrating from Tribler 6.3 to 6.4.'
def _purge_old_search_metadata_communities(self): DCNL 'Cleans up all SearchCommunity and MetadataCommunity stuff in dispersy database.'
def _upgrade_22_to_23(self): DCNL 'Migrates the database to the new version.'
def reimport_torrents(self): DCNL 'Import all torrent files in the collected torrent dir, all the files already in the database will be ignored.'
def reindex_torrents(self): DCNL 'Reindex all torrents in the database. Required when upgrading to a newer FTS engine.'
def shutdown(self): DCNL 'Shutting down boosting manager. It also stops and remove all the sources.'
def get_source_object(self, sourcekey): DCNL 'Get the actual object of the source key'
def set_enable_mining(self, source, mining_bool=True, force_restart=False): DCNL 'Dynamically enable/disable mining source.'
def add_source(self, source): DCNL 'add new source into the boosting manager'
def remove_source(self, source_key): DCNL 'remove source by stop the downloading and remove its metainfo for all its swarms'
def on_torrent_insert(self, source, infohash, torrent): DCNL 'This function called when a source is finally determined. Fetch some torrents from it, DCNL then insert it into our data'
def on_torrent_notify(self, subject, change_type, infohash): DCNL 'Notify us when we have new seeder/leecher value in torrent from tracker'
def scrape_trackers(self): DCNL 'Manually scrape tracker by requesting to tracker manager'
def set_archive(self, source, enable): DCNL 'setting archive of a particular source. This affects all the torrents in this source'
def start_download(self, torrent): DCNL 'Start downloading a particular torrent and add it to download list in Tribler'
def stop_download(self, torrent): DCNL 'Stopping torrent that currently downloading'
def _select_torrent(self): DCNL 'Function to select which torrent in the torrent list will be downloaded in the DCNL next iteration. It depends on the source and applied policy'
def load_config(self): DCNL 'load config in file configuration and apply it to manager'
def save_config(self): DCNL 'save the environment parameters in config file'
def log_statistics(self): DCNL 'Log transfer statistics'
def update_torrent_stats(self, torrent_infohash_str, seeding_stats): DCNL 'function to update swarm statistics. DCNL This function called when we get new Downloadstate for active torrents. DCNL Updated downloadstate (seeding_stats) for a particular torrent is stored here.'
def start(self): DCNL 'Start operating mining for this source'
def kill_tasks(self): DCNL 'kill tasks on this source'
def _load_if_ready(self, source): DCNL 'load source if and only if the overall system is ready. DCNL This is useful so we don\'t burden the application during the startup'
def get_source_text(self): DCNL 'returning \'raw\' source. May be overriden'
def _check_tor(self): DCNL 'periodically check torrents in channel. Will return the torrent data if finished.'
def _load_torrent(self, infohash): DCNL 'function to download a torrent by infohash and call a callback afterwards DCNL with TorrentDef object as parameter.'
def _on_success_rss(self, body_rss, rss_feed): DCNL 'function called when RSS successfully read'
def _on_error_rss(self, failure, rss_feed): DCNL 'function called when RSS failed except from 503 DCNL aborting load the source'
def apply(self, torrents, max_active, force=False): DCNL 'apply the policy to the torrents stored'
def key(self, key): DCNL 'function to find a key of an object'
def key_check(self, key): DCNL 'function to check whether a swarm is included to download'
def initialize(self, *args, **kwargs): DCNL 'Initializes this DBHandler.'
def search_in_local_torrents_db(self, query, keys=None): DCNL 'Search in the local database for torrents matching a specific query. This method also assigns a relevance DCNL score to each torrent, based on the name, files and file extensions. DCNL The algorithm is based on BM25. The document length factor is regarded since our "documents" are very small DCNL (often a few keywords). DCNL See https://en.wikipedia.org/wiki/Okapi_BM25 for more information about BM25.'
def getVoteOnChannel(self, channel_id, voter_id): DCNL 'return the vote status if such record exists, otherwise None'
def getDispersyId(self, channel_id, voter_id): DCNL 'return the dispersy_id for this vote'
def getTimestamp(self, channel_id, voter_id): DCNL 'return the timestamp for this vote'
def get_random_channel_torrents(self, keys, limit=10): DCNL 'Return some random (channel) torrents from the database.'
@staticmethod DCNL def calculate_score_channel(keywords, channel_name, channel_description): DCNL 'Calculate the relevance score of a channel from the database. DCNL The algorithm used is a very stripped-down version of BM25 where only the matching terms are counted.'
def search_in_local_channels_db(self, query): DCNL 'Searches for matching channels against a given query in the database.'
def getAllChannels(self): DCNL 'Returns all the channels'
def getNewChannels(self, updated_since=0): DCNL 'Returns all newest unsubscribed channels, ie the ones with no votes (positive or negative)'
def _getChannels(self, sql, args=None, cmpF=None, includeSpam=True): DCNL 'Returns the channels based on the input sql, if the number of positive votes DCNL is less than maxvotes and the number of torrent > 0'
def getMostPopularChannelFromTorrent(self, infohash): DCNL 'Returns channel id, name, nrfavorites of most popular channel if any'
def get_torrent_ids_from_playlist(self, playlist_id): DCNL 'Returns the torrent dispersy IDs from a specified playlist.'
@property DCNL def version(self): DCNL 'The version of this database.'
@property DCNL def connection(self): DCNL 'Returns the connection of the database, which may be None if not initialized or closed. DCNL :return: The connection object of the database'
@blocking_call_on_reactor_thread DCNL def initialize(self): DCNL 'Initializes the database. If the database doesn\'t exist, we create a new one. Otherwise, we check the DCNL version and upgrade to the latest version.'
@blocking_call_on_reactor_thread DCNL def close(self): DCNL 'Cancels all pending tasks and closes all cursors. Then, it closes the connection.'
def _open_connection(self): DCNL 'Opens a connection to the database. If the database doesn\'t exist, we create a new one and run the DCNL initialization SQL scripts. If the database doesn\'t exist, we simply connect to it. DCNL And finally, we read the database version.'
def insertMany(self, table_name, values, keys=None): DCNL 'values must be a list of tuples'
def getOne(self, table_name, value_name, where=None, conj=u'AND', **kw): DCNL 'value_name could be a string, a tuple of strings, or \'*\''
def getAll(self, table_name, value_name, where=None, group_by=None, having=None, order_by=None, limit=None, offset=None, conj=u'AND', **kw): DCNL 'value_name could be a string, or a tuple of strings DCNL order by is represented as order_by DCNL group by is represented as group_by'
def add_observer(self, func, subject, changeTypes=[NTFY_UPDATE, NTFY_INSERT, NTFY_DELETE], id=None, cache=0): DCNL 'Add observer function which will be called upon certain event DCNL Example: DCNL addObserver(NTFY_TORRENTS, [NTFY_INSERT,NTFY_DELETE]) -> get callbacks DCNL when peers are added or deleted DCNL addObserver(NTFY_TORRENTS, [NTFY_SEARCH_RESULT], \'a_search_id\') -> get DCNL callbacks when peer-searchresults of of search DCNL with id==\'a_search_id\' come in'
def remove_observer(self, func): DCNL 'Remove all observers with function func'
def notify(self, subject, changeType, obj_id, *args): DCNL 'Notify all interested observers about an event with threads from the pool'
def get_vod_download(self): DCNL 'Return the current Video-On-Demand download that is being requested.'
def set_vod_download(self, new_download): DCNL 'Set a new Video-On-Demand download. Set the mode of old download to normal and close the file stream of DCNL the old download.'
@staticmethod DCNL def get_vod_destination(download): DCNL 'Get the destination directory of the VOD download.'
def shutdown_server(self): DCNL 'Shutdown the video HTTP server.'
def __init__(self): DCNL 'Called only once (unless we have multiple Sessions) by MainThread'
def add(self, tdef, dscfg, pstate=None, setupDelay=0, hidden=False, share_mode=False, checkpoint_disabled=False): DCNL 'Called by any thread'
def on_download_handle_created(self, download): DCNL 'This method is called when the download handle has been created. DCNL Immediately checkpoint the download and write the resume data.'
def remove(self, d, removecontent=False, removestate=True, hidden=False): DCNL 'Called by any thread'
def get_downloads(self): DCNL 'Called by any thread'
def get_download(self, infohash): DCNL 'Called by any thread'
def update_download_hops(self, download, new_hops): DCNL 'Update the amount of hops for a specified download. This can be done on runtime.'
def update_trackers(self, infohash, trackers): DCNL 'Update the trackers for a download. DCNL :param infohash: infohash of the torrent that needs to be updated DCNL :param trackers: A list of tracker urls.'
def stop_download_states_callback(self): DCNL 'Stop any download states callback if present.'
def set_download_states_callback(self, user_callback, interval=1.0): DCNL 'Set the download state callback. Remove any old callback if it\'s present.'
def _invoke_states_cb(self, callback): DCNL 'Invoke the download states callback with a list of the download states.'
def sesscb_states_callback(self, states_list): DCNL 'This method is periodically (every second) called with a list of the download states of the active downloads.'
def load_checkpoint(self): DCNL 'Called by any thread'
def load_download_pstate_noexc(self, infohash): DCNL 'Called by any thread, assume session_lock already held'
def checkpoint_downloads(self): DCNL 'Checkpoints all running downloads in Tribler. DCNL Even if the list of Downloads changes in the mean time this is no problem. DCNL For removals, dllist will still hold a pointer to the download, and additions are no problem DCNL (just won\'t be included in list of states returned via callback).'
def shutdown_downloads(self): DCNL 'Shutdown all downloads in Tribler.'
@inlineCallbacks DCNL def early_shutdown(self): DCNL 'Called as soon as Session shutdown is initiated. Used to start DCNL shutdown tasks that takes some time and that can run in parallel DCNL to checkpointing, etc. DCNL :returns a Deferred that will fire once all dependencies acknowledge they have shutdown.'
def save_download_pstate(self, infohash, pstate): DCNL 'Called by network thread'
def load_download_pstate(self, filename): DCNL 'Called by any thread'
@call_on_reactor_thread DCNL def add_tracker(self, tracker_url): DCNL 'Adds a new tracker into the tracker info dict and the database. DCNL :param tracker_url: The new tracker URL to be added.'
@call_on_reactor_thread DCNL def get_tracker_info(self, tracker_url): DCNL 'Gets the tracker information with the given tracker URL. DCNL :param tracker_url: The given tracker URL. DCNL :return: The tracker info dict if exists, None otherwise.'
def update_tracker_info(self, tracker_url, is_successful): DCNL 'Updates a tracker information. DCNL :param tracker_url: The given tracker_url. DCNL :param is_successful: If the check was successful.'
@call_on_reactor_thread DCNL def should_check_tracker(self, tracker_url): DCNL 'Checks if the given tracker URL should be checked right now or not. DCNL :param tracker_url: The given tracker URL. DCNL :return: True or False.'
@call_on_reactor_thread DCNL def get_next_tracker_for_auto_check(self): DCNL 'Gets the next tracker for automatic tracker-checking. DCNL :return: The next tracker for automatic tracker-checking.'
def __init__(self, state_directory=None): DCNL 'Check whether a lock file exists in the Tribler directory. If not, create the file. If it exists, DCNL check the PID that is written inside the lock file.'
@staticmethod DCNL def is_pid_running(pid): DCNL 'Check whether a given process ID is currently running. We do this by sending signal 0 to the process DCNL which does not has any effect on the running process. DCNL Source: http://stackoverflow.com/questions/7647167/check-if-a-process-is-running-in-python-in-linux-unix'
def create_lock_file(self): DCNL 'Create the lock file and write the PID in it. We also create the directory structure since the ProcessChecker DCNL might be called before the .Tribler directory has been created.'
def remove_lock_file(self): DCNL 'Remove the lock file.'
def get_pid_from_lock_file(self): DCNL 'Returns the PID from the lock file.'
def _parse_html(self, content): DCNL 'Parses an HTML content and find links.'
def _html2plaintext(self, html_content): DCNL 'Converts an HTML document to plain text.'
def parse(self, url, cache): DCNL 'Parses a RSS feed. This methods supports RSS 2.0 and Media RSS.'
@call_on_reactor_thread DCNL def create_channel(self, name, description, mode, rss_url=None): DCNL 'Creates a new Channel. DCNL :param name: Name of the Channel. DCNL :param description: Description of the Channel. DCNL :param mode: Mode of the Channel (\'open\', \'semi-open\', or \'closed\'). DCNL :param rss_url: RSS URL for the Channel. DCNL :return: Channel ID DCNL :raises DuplicateChannelNameError if name already exists'
def get_my_channel(self, channel_id): DCNL 'Gets the ChannelObject with the given channel id. DCNL :return: The ChannelObject if exists, otherwise None.'
def get_channel(self, name): DCNL 'Gets a Channel by name. DCNL :param name: Channel name. DCNL :return: The channel object if exists, otherwise None.'
def get_channel_list(self): DCNL 'Gets a list of all channel objects. DCNL :return: The list of all channel objects.'
@call_on_reactor_thread DCNL def search_for_torrents(self, keywords): DCNL 'Searches for torrents using SearchCommunity with the given keywords. DCNL :param keywords: The given keywords.'
@call_on_reactor_thread DCNL def _on_torrent_search_results(self, subject, change_type, object_id, search_results): DCNL 'The callback function handles the search results from SearchCommunity. DCNL :param subject: Must be SIGNAL_SEARCH_COMMUNITY. DCNL :param change_type: Must be SIGNAL_ON_SEARCH_RESULTS. DCNL :param object_id: Must be None. DCNL :param search_results: The result dictionary which has \'keywords\', \'results\', and \'candidate\'.'
@call_on_reactor_thread DCNL def search_for_channels(self, keywords): DCNL 'Searches for channels using AllChannelCommunity with the given keywords. DCNL :param keywords: The given keywords.'
@call_on_reactor_thread DCNL def _on_channel_search_results(self, subject, change_type, object_id, search_results): DCNL 'The callback function handles the search results from AllChannelCommunity. DCNL :param subject: Must be SIGNAL_ALLCHANNEL_COMMUNITY. DCNL :param change_type: Must be SIGNAL_ON_SEARCH_RESULTS. DCNL :param object_id: Must be None. DCNL :param search_results: The result dictionary which has \'keywords\', \'results\', and \'candidate\'.'
def render_PUT(self, request): DCNL '.. http:put:: /shutdown DCNL A PUT request to this endpoint will shutdown Tribler. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/shutdown DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "shutdown": True'
def render_GET(self, request): DCNL '.. http:get:: /wallets DCNL A GET request to this endpoint will return information about all available wallets in Tribler. DCNL This includes information about the address, a human-readable wallet name and the balance. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/wallets DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "wallets": [{ DCNL "created": True, DCNL "name": "Bitcoin", DCNL "address": "17AVS7n3zgBjPq1JT4uVmEXdcX3vgB2wAh", DCNL "balance": { DCNL "available": 0.000126, DCNL "pending": 0.0, DCNL "currency": "BTC"'
def render_PUT(self, request): DCNL '.. http:put:: /wallets/(string:wallet identifier) DCNL A request to this endpoint will create a new wallet. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/wallets/BTC --data "password=secret" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "created": True'
def render_GET(self, request): DCNL '.. http:get:: /wallets/(string:wallet identifier)/balance DCNL A GET request to this endpoint will return balance information of a specific wallet. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/wallets/BTC/balance DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "balance": { DCNL "available": 0.000126, DCNL "pending": 0.0, DCNL "currency": "BTC"'
def render_GET(self, request): DCNL '.. http:get:: /wallets/(string:wallet identifier)/transactions DCNL A GET request to this endpoint will return past transactions of a specific wallet. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/wallets/BTC/transactions DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "transactions": [{ DCNL "currency": "BTC", DCNL "to": "17AVS7n3zgBjPq1JT4uVmEXdcX3vgB2wAh", DCNL "outgoing": false, DCNL "from": "", DCNL "description": "", DCNL "timestamp": "1489673696", DCNL "fee_amount": 0.0, DCNL "amount": 0.00395598, DCNL "id": "6f6c40d034d69c5113ad8cb3710c172955f84787b9313ede1c39cac85eeaaffe"'
def render_POST(self, request): DCNL '.. http:get:: /wallets/(string:wallet identifier)/transfer DCNL A GET request to this endpoint will return past transactions of a specific wallet. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/wallets/BTC/transfer DCNL --data "amount=0.3&destination=mpC1DDgSP4PKc5HxJzQ5w9q6CGLBEQuLsN" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "txid": "abcd"'
def __init__(self, session): DCNL 'During the initialization of the REST API, we only start the event sockets and the state endpoint. DCNL We enable the other endpoints when Tribler has completed the starting procedure.'
def start_endpoints(self): DCNL 'This method is only called when Tribler has started. It enables the other endpoints that are dependent DCNL on a fully started Tribler.'
def get_tunnel_community(self): DCNL 'Search for the tunnel community in the dispersy communities.'
def render_GET(self, request): DCNL '.. http:get:: /debug/circuits DCNL A GET request to this endpoint returns information about the built circuits in the tunnel community. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/debug/circuits DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "circuits": [ DCNL "id": 1234, DCNL "state": "EXTENDING", DCNL "goal_hops": 4, DCNL "bytes_up": 45, DCNL "bytes_down": 49, DCNL "created": 1468176257, DCNL "hops": [{ DCNL "host": "unknown" DCNL "host": "39.95.147.20:8965"'
def render_GET(self, request): DCNL '.. http:get:: /settings DCNL A GET request to this endpoint returns all the session settings that can be found in Tribler. DCNL Please note that a port with a value of -1 means that the port is randomly assigned at startup. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/settings DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "settings": { DCNL "libtorrent": { DCNL "anon_listen_port": -1,'
def render_POST(self, request): DCNL '.. http:post:: /settings DCNL A POST request to this endpoint will update Tribler settings. A JSON-dictionary should be passed as body DCNL contents. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X POST http://localhost:8085/settings --data "{" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "modified": True'
def parse_setting(self, section, option, value): DCNL 'Set a specific Tribler setting. Throw a ValueError if this setting is not available.'
def parse_settings_dict(self, settings_dict, depth=1, root_key=None): DCNL 'Parse the settings dictionary.'
def render_GET(self, request): DCNL '.. http:get:: /market/transactions DCNL A GET request to this endpoint will return all performed transactions in the market community. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/market/transactions DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "transactions": [{ DCNL "trader_id": "12c406358ba05e5883a75da3f009477e4ca699a9", DCNL "order_number": 4, DCNL "partner_trader_id": "34c406358ba05e5883a75da3f009477e4ca699a9", DCNL "partner_order_number": 1, DCNL "transaction_number": 3, DCNL "price": 10, DCNL "price_type": "MC", DCNL "transferred_price": 5, DCNL "quantity": 10, DCNL "quantity_type": "BTC", DCNL "transferred_quantity": 4, DCNL "timestamp": 1493906434.627721, DCNL "payment_complete": False'
def render_GET(self, request): DCNL '.. http:get:: /market/transactions/(string:trader_id)/(string:transaction_number)/payments DCNL A GET request to this endpoint will return all payments tied to a specific transaction. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/market/transactions/ DCNL 12c406358ba05e5883a75da3f009477e4ca699a9/3/payments DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "payments": [{ DCNL "trader_id": "12c406358ba05e5883a75da3f009477e4ca699a9", DCNL "transaction_number": 3, DCNL "price": 10, DCNL "price_type": "MC", DCNL "quantity": 10, DCNL "quantity_type": "BTC", DCNL "transferred_quantity": 4, DCNL "payment_id": "abcd", DCNL "address_from": "my_mc_address", DCNL "address_to": "my_btc_address", DCNL "timestamp": 1493906434.627721,'
@staticmethod DCNL def create_ask_bid_from_params(parameters): DCNL 'Create an ask/bid from the provided parameters in a request. This method returns a tuple with the price, DCNL quantity and timeout of the ask/bid.'
def render_GET(self, request): DCNL '.. http:get:: /market/asks DCNL A GET request to this endpoint will return all ask ticks in the order book of the market community. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/market/asks DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "asks": [{ DCNL "price_type": "BTC", DCNL "quantity_type": "MC", DCNL "ticks": [{ DCNL "trader_id": "12c406358ba05e5883a75da3f009477e4ca699a9", DCNL "timeout": 3600, DCNL "quantity_type": "MC", DCNL "price_type": "BTC", DCNL "timestamp": 1493905920.68573, DCNL "price": 10.0, DCNL "order_number": 1, DCNL "message_id": "12c406358ba05e5883a75da3f009477e4ca699a9.1", DCNL "quantity": 10.0}, ...]'
def render_PUT(self, request): DCNL '.. http:put:: /market/asks DCNL A request to this endpoint will create a new ask order. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/market/asks --data DCNL "price=10&quantity=10&price_type=BTC&quantity_type=MC" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "created": True'
def render_GET(self, request): DCNL '.. http:get:: /market/bids DCNL A GET request to this endpoint will return all bid ticks in the order book of the market community. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/market/bids DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "bids": [{ DCNL "price_type": "BTC", DCNL "quantity_type": "MC", DCNL "ticks": [{ DCNL "trader_id": "12c406358ba05e5883a75da3f009477e4ca699a9", DCNL "timeout": 3600, DCNL "quantity_type": "MC", DCNL "price_type": "BTC", DCNL "timestamp": 1493905920.68573, DCNL "price": 10.0, DCNL "order_number": 1, DCNL "message_id": "12c406358ba05e5883a75da3f009477e4ca699a9.1", DCNL "quantity": 10.0}, ...]'
def render_PUT(self, request): DCNL '.. http:put:: /market/bids DCNL A request to this endpoint will create a new bid order. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/market/bids --data DCNL "price=10&quantity=10&price_type=BTC&quantity_type=MC" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "created": True'
def render_GET(self, request): DCNL '.. http:get:: /market/orders DCNL A GET request to this endpoint will return all your orders in the market community. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/market/orders DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "orders": [{ DCNL "trader_id": "12c406358ba05e5883a75da3f009477e4ca699a9", DCNL "timestamp": 1493906434.627721, DCNL "price": 10.0, DCNL "quantity_type": "MC", DCNL "reserved_quantity": 0.0, DCNL "is_ask": False, DCNL "price_type": "BTC", DCNL "timeout": 3600.0, DCNL "traded_quantity": 0.0, DCNL "order_number": 1, DCNL "completed_timestamp": null, DCNL "quantity": 10.0, DCNL "cancelled": False, DCNL "status": "open"'
def render_POST(self, request): DCNL '.. http:get:: /market/orders/(string:order_number)/cancel DCNL A POST request to this endpoint will cancel a specific order. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/market/orders/3/cancel DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "cancelled": True'
def render_GET(self, request): DCNL '.. http:get:: /search?q=(string:query) DCNL A GET request to this endpoint will create a search. Results are returned over the events endpoint, one by one. DCNL First, the results available in the local database will be pushed. After that, incoming Dispersy results are DCNL pushed. The query to this endpoint is passed using the url, i.e. /search?q=pioneer. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/search?q=tribler DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "type": "search_result_channel", DCNL "query": "test", DCNL "result": { DCNL "id": 3, DCNL "dispersy_cid": "da69aaad39ccf468aba2ab9177d5f8d8160135e6", DCNL "name": "My fancy channel", DCNL "description": "A description of this fancy channel", DCNL "subscribed": True, DCNL "votes": 23, DCNL "torrents": 3, DCNL "spam": 5, DCNL "modified": 14598395, DCNL "can_edit": False'
def render_GET(self, request): DCNL '.. http:get:: /search/completions?q=(string:query) DCNL A GET request to this endpoint will return autocompletion suggestions for the given query. For instance, DCNL when searching for "pioneer", this endpoint might return "pioneer one" if that torrent is present in the DCNL local database. This endpoint can be used to suggest terms to users while they type their search query. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/search/completions?q=pioneer DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "completions": ["pioneer one", "pioneer movie"]'
def render_GET(self, request): DCNL '.. http:get:: /torrentinfo DCNL A GET request to this endpoint will return information from a torrent found at a provided URI. DCNL This URI can either represent a file location, a magnet link or a HTTP(S) url. DCNL - torrent: the URI of the torrent file that should be downloaded. This parameter is required. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/torrentinfo?torrent=file:/home/me/test.torrent DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL {"metainfo": <torrent metainfo dictionary>}'
@staticmethod DCNL def return_404(request, message='this DCSP download DCSP does DCSP not DCSP exist'): DCNL 'Returns a 404 response code if your channel has not been created.'
@staticmethod DCNL def create_dconfig_from_params(parameters): DCNL 'Create a download configuration based on some given parameters. Possible parameters are: DCNL - anon_hops: the number of hops for the anonymous download. 0 hops is equivalent to a plain download DCNL - safe_seeding: whether the seeding of the download should be anonymous or not (0 = off, 1 = on) DCNL - destination: the destination path of the torrent (where it is saved on disk)'
def render_GET(self, request): DCNL '.. http:get:: /downloads?get_peers=(boolean: get_peers)&get_pieces=(boolean: get_pieces) DCNL A GET request to this endpoint returns all downloads in Tribler, both active and inactive. The progress is a DCNL number ranging from 0 to 1, indicating the progress of the specific state (downloading, checking etc). The DCNL download speeds have the unit bytes/sec. The size of the torrent is given in bytes. The estimated time assumed DCNL is given in seconds. A description of the possible download statuses can be found in the REST API documentation. DCNL Detailed information about peers and pieces is only requested when the get_peers and/or get_pieces flag is set. DCNL Note that setting this flag has a negative impact on performance and should only be used in situations DCNL where this data is required. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/downloads?get_peers=1&get_pieces=1 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "downloads": [{ DCNL "name": "Ubuntu-16.04-desktop-amd64", DCNL "progress": 0.31459265, DCNL "infohash": "4344503b7e797ebf31582327a5baae35b11bda01", DCNL "speed_down": 4938.83, DCNL "speed_up": 321.84, DCNL "status": "DLSTATUS_DOWNLOADING", DCNL "size": 89432483, DCNL "eta": 38493, DCNL "num_peers": 53, DCNL "num_seeds": 93, DCNL "total_up": 10000, DCNL "total_down": 100000, DCNL "ratio": 0.1, DCNL "files": [{ DCNL "index": 0, DCNL "name": "ubuntu.iso", DCNL "size": 89432483, DCNL "included": True DCNL "trackers": [{ DCNL "url": "http://ipv6.torrent.ubuntu.com:6969/announce", DCNL "status": "Working", DCNL "peers": 42 DCNL "hops": 1, DCNL "anon_download": True, DCNL "safe_seeding": True, DCNL "max_upload_speed": 0, DCNL "max_download_speed": 0, DCNL "destination": "/home/user/file.txt", DCNL "availability": 1.234, DCNL "peers": [{ DCNL "ip": "123.456.789.987", DCNL "dtotal": 23, DCNL "downrate": 0, DCNL "uinterested": False, DCNL "wstate": " ", DCNL "optimistic": False, DCNL "total_pieces": 420, DCNL "vod_mod": True, DCNL "vod_prebuffering_progress": 0.89, DCNL "vod_prebuffering_progress_consec": 0.86, DCNL "error": "", DCNL "time_added": 1484819242,'
def render_PUT(self, request): DCNL '.. http:put:: /downloads DCNL A PUT request to this endpoint will start a download from a provided URI. This URI can either represent a file DCNL location, a magnet link or a HTTP(S) url. DCNL - anon_hops: the number of hops for the anonymous download. 0 hops is equivalent to a plain download DCNL - safe_seeding: whether the seeding of the download should be anonymous or not (0 = off, 1 = on) DCNL - destination: the download destination path of the torrent DCNL - torrent: the URI of the torrent file that should be downloaded. This parameter is required. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/downloads DCNL --data "anon_hops=2&safe_seeding=1&destination=/my/dest/on/disk/&uri=file:/home/me/test.torrent DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL {"started": True, "infohash": "4344503b7e797ebf31582327a5baae35b11bda01"}'
def render_DELETE(self, request): DCNL '.. http:delete:: /downloads/(string: infohash) DCNL A DELETE request to this endpoint removes a specific download from Tribler. You can specify whether you only DCNL want to remove the download or the download and the downloaded data using the remove_data parameter. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X DELETE http://localhost:8085/download/4344503b7e797ebf31582327a5baae35b11bda01 DCNL --data "remove_data=1" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL {"removed": True}'
def render_PATCH(self, request): DCNL '.. http:patch:: /download/(string: infohash) DCNL A PATCH request to this endpoint will update a download in Tribler. DCNL A state parameter can be passed to modify the state of the download. Valid states are "resume" DCNL (to resume a stopped/paused download), "stop" (to stop a running download) and "recheck" DCNL (to force a recheck of the hashes of a download). DCNL Another possible parameter is selected_files which manipulates which files are included in the download. DCNL The selected_files parameter is an array with the file indices as values. DCNL The anonymity of a download can be changed at runtime by passing the anon_hops parameter, however, this must DCNL be the only parameter in this request. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PATCH http://localhost:8085/downloads/4344503b7e797ebf31582327a5baae35b11bda01 DCNL --data "state=resume&selected_files[]=file1.iso&selected_files[]=1" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL {"modified": True}'
def render_GET(self, request): DCNL '.. http:get:: /download/(string: infohash)/torrent DCNL A GET request to this endpoint returns the .torrent file associated with the specified download. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/downloads/4344503b7e797ebf31582327a5baae35b11bda01/torrent DCNL **Example response**: DCNL The contents of the .torrent file.'
def render_GET(self, request): DCNL '.. http:get:: /torrents/random?limit=(int: max nr of torrents) DCNL A GET request to this endpoint returns random (channel) torrents. DCNL You can optionally specify a limit parameter to limit the maximum number of results. By default, this is 10. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/torrents/random?limit=1 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "torrents": [{ DCNL "id": 4, DCNL "infohash": "97d2d8f5d37e56cfaeaae151d55f05b077074779", DCNL "name": "Ubuntu-16.04-desktop-amd64", DCNL "size": 8592385, DCNL "category": "other", DCNL "num_seeders": 42, DCNL "num_leechers": 184, DCNL "last_tracker_check": 1463176959'
def render_GET(self, request): DCNL '.. http:get:: /torrents/(string: torrent infohash)/tracker DCNL Fetch all trackers of a specific torrent. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl http://localhost:8085/torrents/97d2d8f5d37e56cfaeaae151d55f05b077074779/trackers DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "trackers": [ DCNL "http://mytracker.com:80/announce", DCNL "udp://fancytracker.org:1337/announce" DCNL :statuscode 404: if the torrent is not found in the database'
def render_GET(self, request): DCNL '.. http:get:: /torrents/(string: torrent infohash)/health DCNL Fetch the swarm health of a specific torrent. You can optionally specify the timeout to be used in the DCNL connections to the trackers. This is by default 20 seconds. DCNL By default, we will not check the health of a torrent again if it was recently checked. You can force a health DCNL recheck by passing the refresh parameter. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl http://localhost:8085/torrents/97d2d8f5d37e56cfaeaae151d55f05b077074779/health?timeout=15&refresh=1 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "http://mytracker.com:80/announce": [{ DCNL "seeders": 43, DCNL "leechers": 20, DCNL "infohash": "97d2d8f5d37e56cfaeaae151d55f05b077074779" DCNL "http://nonexistingtracker.com:80/announce": { DCNL "error": "timeout" DCNL :statuscode 404: if the torrent is not found in the database'
def get_trustchain_community(self): DCNL 'Search for the trustchain community in the dispersy communities.'
def render_GET(self, request): DCNL '.. http:get:: /trustchain/statistics DCNL A GET request to this endpoint returns statistics about the trustchain community DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/trustchain/statistics DCNL **Example response**: DCNL Note: latest_block does not exist if there is no data DCNL .. sourcecode:: javascript DCNL "statistics": DCNL "id": "TGliTmFDTFBLO...VGbxS406vrI=", DCNL "total_blocks": 8537, DCNL "total_down": 108904042, DCNL "total_up": 95138354, DCNL "latest_block": DCNL "hash": ab672fd6acc0... DCNL "up": 123, DCNL "down": 495, DCNL "total_up": 8393, DCNL "total_down": 8943, DCNL "link_public_key": 7324b765a98e, DCNL "sequence_number": 50, DCNL "link_public_key": 9a5572ec59bbf, DCNL "link_sequence_number": 3482, DCNL "previous_hash": bd7830e7bdd1...,'
def render_GET(self, request): DCNL '.. http:get:: /trustchain/blocks/TGliTmFDTFBLOVGbxS406vrI=?limit=(int: max nr of returned blocks) DCNL A GET request to this endpoint returns all blocks of a specific identity, both that were signed and responded DCNL by him. You can optionally limit the amount of blocks returned, this will only return some of the most recent DCNL blocks. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/trustchain/blocks/d78130e71bdd1...=?limit=10 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "blocks": [{ DCNL "hash": ab672fd6acc0... DCNL "up": 123, DCNL "down": 495, DCNL "total_up": 8393, DCNL "total_down": 8943, DCNL "sequence_number": 50, DCNL "link_public_key": 9a5572ec59bbf, DCNL "link_sequence_number": 3482, DCNL "previous_hash": bd7830e7bdd1...,'
def render_GET(self, request): DCNL '.. http:get:: /state DCNL A GET request to this endpoint returns the current state of the Tribler core. There are three states: DCNL - STARTING: The core of Tribler is starting DCNL - UPGRADING: The upgrader is active DCNL - STARTED: The Tribler core has started DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/state DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "state": "STARTED", DCNL "last_exception": None'
def render_POST(self, request): DCNL '.. http:post:: /createtorrent?download=(boolean: download) DCNL Create a torrent from local files and return it in base64 encoding. DCNL Description and trackers list are optional. DCNL This endpoint returns a 500 HTTP response if a source file does not exist. DCNL You can optionally pass a flag to start downloading the created torrent. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X POST http://localhost:8085/createtorrent DCNL --data "files[]=path/to/file.txt DCNL &files[]=path/to/another/file.mp4 DCNL &description=Video DCNL &trackers[]=url_tracker1 DCNL &trackers[]=url_backup1 DCNL &trackers[]=url_backup2" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "torrent": { base64 encoded torrent file } DCNL :statuscode 500: if source files do not exist.'
def write_data(self, message): DCNL 'Write data over the event socket if it\'s open.'
def on_search_results_channels(self, subject, changetype, objectID, results): DCNL 'Returns the channel search results over the events endpoint.'
def on_search_results_torrents(self, subject, changetype, objectID, results): DCNL 'Returns the torrent search results over the events endpoint.'
def render_GET(self, request): DCNL '.. http:get:: /events DCNL A GET request to this endpoint will open the event connection. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/events'
def render_GET(self, request): DCNL '.. http:get:: /statistics/tribler DCNL A GET request to this endpoint returns general statistics in Tribler. DCNL The size of the Tribler database is in bytes. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/statistics/tribler DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "tribler_statistics": { DCNL "num_channels": 1234, DCNL "database_size": 384923, DCNL "torrent_queue_stats": [{ DCNL "failed": 2, DCNL "total": 9, DCNL "type": "TFTP", DCNL "pending": 1, DCNL "success": 6'
def render_GET(self, request): DCNL '.. http:get:: /statistics/dispersy DCNL A GET request to this endpoint returns general statistics in Dispersy. DCNL The returned runtime is the amount of seconds that Dispersy is active. The total uploaded and total downloaded DCNL statistics are in bytes. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/statistics/dispersy DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "dispersy_statistics": { DCNL "wan_address": "123.321.456.654:1234", DCNL "lan_address": "192.168.1.2:1435", DCNL "connection": "unknown", DCNL "runtime": 859.34, DCNL "total_downloaded": 538.53, DCNL "total_uploaded": 983.24, DCNL "packets_sent": 43, DCNL "packets_received": 89,'
def render_GET(self, request): DCNL '.. http:get:: /statistics/communities DCNL A GET request to this endpoint returns general statistics of active Dispersy communities. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/statistics/communities DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "community_statistics": [{ DCNL "identifier": "48d04e922dec4430daf22400c9d4cc5a3a53b27d", DCNL "member": "a66ebac9d88a239ef348a030d5ed3837868fc06d", DCNL "candidates": 43, DCNL "global_time": 42, DCNL "classification", "ChannelCommunity", DCNL "packets_sent": 43, DCNL "packets_received": 89,'
@staticmethod DCNL def return_404(request, message=UNKNOWN_CHANNEL_RESPONSE_MSG): DCNL 'Returns a 404 response code if your channel has not been created.'
@staticmethod DCNL def return_401(request, message=UNAUTHORIZED_RESPONSE_MSG): DCNL 'Returns a 401 response code if you are not authorized to perform a specific request.'
def get_channel_from_db(self, cid): DCNL 'Returns information about the channel from the database. Returns None if the channel with given cid DCNL does not exist.'
def get_my_channel_object(self): DCNL 'Returns the Channel object associated with a channel that is used to manage rss feeds.'
def vote_for_channel(self, cid, vote): DCNL 'Make a vote in the channel specified by the cid. Returns a deferred that fires when the vote is done.'
def get_community_for_channel_id(self, channel_id): DCNL 'Returns a Dispersy community from the given channel id. The Community object can be used to delete/add torrents DCNL or modify playlists in a specific channel.'
def render_GET(self, request): DCNL '.. http:get:: /channels/popular?limit=(int:max nr of channels) DCNL A GET request to this endpoint will return the most popular discovered channels in Tribler. DCNL You can optionally pass a limit parameter to limit the number of results. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/channels/popular?limit=1 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "channels": [{ DCNL "id": 3, DCNL "dispersy_cid": "da69aaad39ccf468aba2ab9177d5f8d8160135e6", DCNL "name": "My fancy channel", DCNL "description": "A description of this fancy channel", DCNL "subscribed": False, DCNL "votes": 23, DCNL "torrents": 3, DCNL "spam": 5, DCNL "modified": 14598395, DCNL "can_edit": True,'
def render_GET(self, _): DCNL '.. http:get:: /channels/discovered DCNL A GET request to this endpoint returns all channels discovered in Tribler. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/channels/discovered DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "channels": [{ DCNL "id": 3, DCNL "dispersy_cid": "da69aaad39ccf468aba2ab9177d5f8d8160135e6", DCNL "name": "My fancy channel", DCNL "description": "A description of this fancy channel", DCNL "subscribed": False, DCNL "votes": 23, DCNL "torrents": 3, DCNL "spam": 5, DCNL "modified": 14598395, DCNL "can_edit": True'
def render_PUT(self, request): DCNL '.. http:put:: /channels/discovered DCNL Create your own new channel. The passed mode and descriptions are optional. DCNL Valid modes include: \'open\', \'semi-open\' or \'closed\'. By default, the mode of the new channel is \'closed\'. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/channels/discovered DCNL --data "name=fancy name&description=fancy description&mode=open" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "added": 23 DCNL :statuscode 500: if a channel with the specified name already exists.'
def render_GET(self, request): DCNL '.. http:get:: /channels/discovered/(string: channelid) DCNL Return the name, description and identifier of a channel. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/channels/discovered/4a9cfc7ca9d15617765f4151dd9fae94c8f3ba11 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "overview": { DCNL "name": "My Tribler channel", DCNL "description": "A great collection of open-source movies", DCNL "identifier": "4a9cfc7ca9d15617765f4151dd9fae94c8f3ba11" DCNL :statuscode 404: if your channel has not been created (yet).'
def render_GET(self, request): DCNL '.. http:get:: /channels/discovered/(string: channelid)/playlists DCNL Returns the playlists in your channel. Returns error 404 if you have not created a channel. DCNL - disable_filter: whether the family filter should be disabled for this request (1 = disabled) DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/channels/discovered/abcd/playlists DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "playlists": [{ DCNL "id": 1, DCNL "name": "My first playlist", DCNL "description": "Funny movies", DCNL "torrents": [{ DCNL "id": 4, DCNL "infohash": "97d2d8f5d37e56cfaeaae151d55f05b077074779", DCNL "name": "Ubuntu-16.04-desktop-amd64", DCNL "size": 8592385, DCNL "category": "other", DCNL "num_seeders": 42, DCNL "num_leechers": 184, DCNL "last_tracker_check": 1463176959 DCNL :statuscode 404: if you have not created a channel.'
def render_PUT(self, request): DCNL '.. http:put:: /channels/discovered/(string: channelid)/playlists DCNL Create a new empty playlist with a given name and description. The name and description parameters are DCNL mandatory. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/channels/discovered/abcd/playlists DCNL --data "name=My fancy playlist&description=This playlist contains some random movies" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "created": True DCNL :statuscode 400: if you are missing the name and/or description parameter DCNL :statuscode 404: if the specified channel does not exist'
def render_DELETE(self, request): DCNL '.. http:delete:: /channels/discovered/(string: channelid)/playlists/(int: playlistid) DCNL Remove a playlist with a specified playlist id. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X DELETE http://localhost:8085/channels/discovered/abcd/playlists/3 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "removed": True DCNL :statuscode 404: if the specified channel (community) or playlist does not exist'
def render_POST(self, request): DCNL '.. http:post:: /channels/discovered/(string: channelid)/playlists/(int: playlistid) DCNL Edit a specific playlist. The new name and description should be passed as parameter. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X POST http://localhost:8085/channels/discovered/abcd/playlists/3 DCNL --data "name=test&description=my test description" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "modified": True DCNL :statuscode 404: if the specified channel (community) or playlist does not exist or if the DCNL name and description parameters are missing.'
def render_PUT(self, request): DCNL '.. http:put:: /channels/discovered/(string: channelid)/playlists/(int: playlistid)/(string: infohash) DCNL Add a torrent with a specified infohash to a specified playlist. The torrent that is added to the playlist, DCNL should be present in the channel. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/channels/discovered/abcd/playlists/3/abcdef DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "added": True DCNL :statuscode 404: if the specified channel/playlist/torrent does not exist. DCNL :statuscode 409: if the specified torrent is already in the specified playlist.'
def render_DELETE(self, request): DCNL '.. http:delete:: /channels/discovered/(string: channelid)/playlists/(int: playlistid)/(string: infohash) DCNL Remove a torrent with a specified infohash from a specified playlist. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X DELETE http://localhost:8085/channels/discovered/abcd/playlists/3/abcdef DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "removed": True DCNL :statuscode 404: if the specified channel/playlist/torrent does not exist.'
def render_GET(self, request): DCNL '.. http:get:: /mychannel DCNL Return the name, description and identifier of your channel. DCNL This endpoint returns a 404 HTTP response if you have not created a channel (yet). DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/mychannel DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "overview": { DCNL "name": "My Tribler channel", DCNL "description": "A great collection of open-source movies", DCNL "identifier": "4a9cfc7ca9d15617765f4151dd9fae94c8f3ba11" DCNL :statuscode 404: if your channel has not been created (yet).'
def render_POST(self, request): DCNL '.. http:post:: /mychannel DCNL Modify the name and/or the description of your channel. DCNL This endpoint returns a 404 HTTP response if you have not created a channel (yet). DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X POST http://localhost:8085/mychannel DCNL --data "name=My fancy playlist&description=This playlist contains some random movies" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "modified": True DCNL :statuscode 404: if your channel has not been created (yet).'
def get_my_channel_obj_or_error(self, request): DCNL 'Returns a tuple of (channel_obj, error). Callers of this method should check whether the channel_obj is None and DCNL if so, return the error.'
def render_GET(self, request): DCNL '.. http:get:: /channels/discovered/(string: channelid)/rssfeeds DCNL Returns the RSS feeds in your channel. DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/channels/discovered/abcd/rssfeeds DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "rssfeeds": [{ DCNL "url": "http://rssprovider.com/feed.xml",'
def render_POST(self, request): DCNL '.. http:post:: /channels/discovered/(string: channelid)/recheckfeeds DCNL Rechecks all rss feeds in your channel. Returns error 404 if you channel does not exist. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X POST http://localhost:8085/channels/discovered/recheckrssfeeds DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "rechecked": True DCNL :statuscode 404: if you have not created a channel.'
def render_PUT(self, request): DCNL '.. http:put:: /channels/discovered/(string: channelid)/rssfeeds/http%3A%2F%2Ftest.com%2Frss.xml DCNL Add a RSS feed to your channel. Returns error 409 if the supplied RSS feed already exists. DCNL Note that the rss feed url should be URL-encoded. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/channels/discovered/abcd/rssfeeds/http%3A%2F%2Ftest.com%2Frss.xml DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "added": True DCNL :statuscode 409: (conflict) if the specified RSS URL is already present in your feeds.'
def render_DELETE(self, request): DCNL '.. http:delete:: /channels/discovered/(string: channelid)/rssfeeds/http%3A%2F%2Ftest.com%2Frss.xml DCNL Delete a RSS feed from your channel. Returns error 404 if the RSS feed that is being removed does not exist. DCNL Note that the rss feed url should be URL-encoded. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X DELETE http://localhost:8085/channels/discovered/abcd/rssfeeds/http%3A%2F%2Ftest.com%2Frss.xml DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "removed": True DCNL :statuscode 404: if the specified RSS URL is not in your feed list.'
def render_GET(self, request): DCNL '.. http:get:: /channels/discovered/(string: channelid)/torrents DCNL A GET request to this endpoint returns all discovered torrents in a specific channel. The size of the torrent is DCNL in number of bytes. The last_tracker_check value will be 0 if we did not check the tracker state of the torrent DCNL yet. Optionally, we can disable the family filter for this particular request by passing the following flag: DCNL - disable_filter: whether the family filter should be disabled for this request (1 = disabled) DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/channels/discovered/da69aaad39ccf468aba2ab9177d5f8d8160135e6/torrents DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "torrents": [{ DCNL "id": 4, DCNL "infohash": "97d2d8f5d37e56cfaeaae151d55f05b077074779", DCNL "name": "Ubuntu-16.04-desktop-amd64", DCNL "size": 8592385, DCNL "category": "other", DCNL "num_seeders": 42, DCNL "num_leechers": 184, DCNL "last_tracker_check": 1463176959 DCNL :statuscode 404: if the specified channel cannot be found.'
def render_PUT(self, request): DCNL '.. http:put:: /channels/discovered/(string: channelid)/torrents DCNL Add a torrent file to your own channel. Returns error 500 if something is wrong with the torrent file DCNL and DuplicateTorrentFileError if already added to your channel. The torrent data is passed as base-64 encoded DCNL string. The description is optional. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/channels/discovered/abcd/torrents DCNL --data "torrent=...&description=funny video" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "added": True DCNL :statuscode 404: if your channel does not exist. DCNL :statuscode 500: if the passed torrent data is corrupt.'
def render_PUT(self, request): DCNL '.. http:put:: /channels/discovered/(string: channelid)/torrents/http%3A%2F%2Ftest.com%2Ftest.torrent DCNL Add a torrent by magnet or url to your channel. Returns error 500 if something is wrong with the torrent file DCNL and DuplicateTorrentFileError if already added to your channel (except with magnet links). DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/channels/discovered/abcdefg/torrents/ DCNL http%3A%2F%2Ftest.com%2Ftest.torrent --data "description=nice video" DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "added": "http://test.com/test.torrent" DCNL :statuscode 404: if your channel does not exist. DCNL :statuscode 500: if the specified torrent is already in your channel.'
def render_DELETE(self, request): DCNL '.. http:delete:: /channels/discovered/(string: channelid)/torrents/(string: torrent infohash) DCNL Remove a torrent with a given infohash from a given channel. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X DELETE http://localhost:8085/channels/discovered/abcdefg/torrents/ DCNL 97d2d8f5d37e56cfaeaae151d55f05b077074779 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "removed": True DCNL :statuscode 404: if the channel is not found or if the torrent is not found in the specified channel'
def render_GET(self, _): DCNL '.. http:get:: /channels/subscribed DCNL Returns all the channels the user is subscribed to. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X GET http://localhost:8085/channels/subscribed DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "subscribed": [{ DCNL "id": 3, DCNL "dispersy_cid": "da69aaad39ccf468aba2ab9177d5f8d8160135e6", DCNL "name": "My fancy channel", DCNL "description": "A description of this fancy channel", DCNL "subscribed": True, DCNL "votes": 23, DCNL "torrents": 3, DCNL "spam": 5, DCNL "modified": 14598395, DCNL "can_edit": True,'
def render_PUT(self, request): DCNL '.. http:put:: /channels/subscribed/(string: channelid) DCNL Subscribe to a specific channel. Returns error 409 if you are already subscribed to this channel. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X PUT http://localhost:8085/channels/subscribed/da69aaad39ccf468aba2ab9177d5f8d8160135e6 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "subscribed" : True DCNL :statuscode 409: (conflict) if you are already subscribed to the specified channel.'
def render_DELETE(self, request): DCNL '.. http:delete:: /channels/subscribed/(string: channelid) DCNL Unsubscribe from a specific channel. Returns error 404 if you are not subscribed to this channel. DCNL **Example request**: DCNL .. sourcecode:: none DCNL curl -X DELETE http://localhost:8085/channels/subscribed/da69aaad39ccf468aba2ab9177d5f8d8160135e6 DCNL **Example response**: DCNL .. sourcecode:: javascript DCNL "unsubscribed" : True DCNL :statuscode 404: if you are not subscribed to the specified channel.'
def start(self): DCNL 'Starts the HTTP API with the listen port as specified in the session configuration.'
def stop(self): DCNL 'Stop the HTTP API and return a deferred that fires when the server has shut down.'
@inlineCallbacks DCNL def cleanup(self): DCNL 'Sets the _infohash_list to None and returns a deferred that has succeeded. DCNL :return: A deferred that succeeds immediately.'
def can_add_request(self): DCNL 'Checks if we still can add requests to this session. DCNL :return: True or False.'
def add_infohash(self, infohash): DCNL 'Adds a infohash into this session. DCNL :param infohash: The infohash to be added.'
@abstractmethod DCNL def connect_to_tracker(self): DCNL 'Does some work when a connection has been established.'
@abstractproperty DCNL def max_retries(self): DCNL 'Number of retries before a session is marked as failed.'
@abstractproperty DCNL def retry_interval(self): DCNL 'Interval between retries.'
def max_retries(self): DCNL 'Returns the max amount of retries allowed for this session. DCNL :return: The maximum amount of retries.'
def retry_interval(self): DCNL 'Returns the interval one has to wait before retrying to connect. DCNL :return: The interval before retrying.'
def on_error(self, failure): DCNL 'Handles the case of an error during the request. DCNL :param failure: The failure object that is thrown by a deferred.'
def _on_cancel(self, a): DCNL ':param _: The deferred which we ignore. DCNL This function handles the scenario of the session prematurely being cleaned up, DCNL most likely due to a shutdown. DCNL This function only should be called by the result_deferred.'
def failed(self, msg=None): DCNL 'This method handles everything that needs to be done when one step DCNL in the session has failed and thus no data can be obtained.'
def _process_scrape_response(self, body): DCNL 'This function handles the response body of a HTTP tracker, DCNL parsing the results.'
@inlineCallbacks DCNL def cleanup(self): DCNL 'Cleans the session by cancelling all deferreds and closing sockets. DCNL :return: A deferred that fires once the cleanup is done.'
def on_error(self): DCNL 'This method handles everything that needs to be done when something during DCNL the UDP scraping went wrong.'
def stop(self): DCNL 'Stops the UDP scraper and closes the socket. DCNL :return: A deferred that fires once it has closed the connection.'
def startProtocol(self): DCNL 'This function is called when the scraper is initialized. DCNL Initiates the connection with the tracker.'
def write_data(self, data): DCNL 'This function can be called to send serialized data to the tracker. DCNL :param data: The serialized data to be send.'
def datagramReceived(self, data, (_host, _port)): DCNL 'This function dispatches data received from a UDP tracker. DCNL If it\'s the first response, it will dispatch the data to the handle_connection_response DCNL function of the UDP session. DCNL All subsequent data will be send to the _handle_response function of the UDP session. DCNL :param data: The data received from the UDP tracker.'
def connectionRefused(self): DCNL 'Handles the case of a connection being refused by a tracker.'
def on_error(self, failure): DCNL 'Handles the case when resolving an ip address fails. DCNL :param failure: The failure object thrown by the deferred.'
def _on_cancel(self, _): DCNL ':param _: The deferred which we ignore. DCNL This function handles the scenario of the session prematurely being cleaned up, DCNL most likely due to a shutdown. DCNL This function only should be called by the result_deferred.'
def on_ip_address_resolved(self, ip_address, start_scraper=True): DCNL 'Called when a hostname has been resolved to an ip address. DCNL Constructs a scraper and opens a UDP port to listen on. DCNL Removes an old scraper if present. DCNL :param ip_address: The ip address that matches the hostname of the tracker_url. DCNL :param start_scraper: Whether we should start the scraper immediately.'
def failed(self, msg=None): DCNL 'This method handles everything that needs to be done when one step DCNL in the session has failed and thus no data can be obtained.'
def generate_transaction_id(self): DCNL 'Generates a unique transaction id and stores this in the _active_session_dict set.'
@staticmethod DCNL def remove_transaction_id(session): DCNL 'Removes an session and its corresponding id from the _active_session_dict set. DCNL :param session: The session that needs to be removed from the set.'
@inlineCallbacks DCNL def cleanup(self): DCNL 'Cleans the session by cancelling all deferreds and closing sockets. DCNL :return: A deferred that fires once the cleanup is done.'
def max_retries(self): DCNL 'Returns the max amount of retries allowed for this session. DCNL :return: The maximum amount of retries.'
def retry_interval(self): DCNL 'Returns the time one has to wait until retrying the connection again. DCNL Increases exponentially with the number of retries. DCNL :return: The interval one has to wait before retrying the connection.'
def connect_to_tracker(self): DCNL 'Connects to the tracker and starts querying for seed and leech data. DCNL :return: A deferred that will fire with a dictionary containing seed/leech information per infohash'
def on_start(self): DCNL 'Called by the UDPScraper when it is connected to the tracker. DCNL Creates a connection message and calls the scraper to send it.'
def handle_connection_response(self, response): DCNL 'Handles the connection response from the UDP scraper and queries DCNL it immediately for seed/leech data per infohash DCNL :param response: The connection response from the UDP scraper'
def handle_response(self, response): DCNL 'Handles the response from the UDP scraper. DCNL :param response: The response from the UDP scraper'
def cleanup(self): DCNL 'Cleans the session by cancelling all deferreds and closing sockets. DCNL :return: A deferred that fires once the cleanup is done.'
def can_add_request(self): DCNL 'Returns whether or not this session can accept additional infohashes. DCNL :return:'
def add_infohash(self, infohash): DCNL 'This function adds a infohash to the request list. DCNL :param infohash: The infohash to be added.'
def connect_to_tracker(self): DCNL 'Fakely connects to a tracker. DCNL :return: A deferred with a callback containing an empty dictionary.'
@property DCNL def max_retries(self): DCNL 'Returns the max amount of retries allowed for this session. DCNL :return: The maximum amount of retries.'
@property DCNL def retry_interval(self): DCNL 'Returns the interval one has to wait before retrying to connect. DCNL :return: The interval before retrying.'
def shutdown(self): DCNL 'Shutdown the torrent health checker. DCNL Once shut down it can\'t be started again. DCNL :returns A deferred that will fire once the shutdown has completed.'
def _reschedule_tracker_select(self): DCNL 'Changes the tracker selection interval dynamically and schedules the task.'
def _task_select_tracker(self): DCNL 'The regularly scheduled task that selects torrents associated with a specific tracker to check.'
@call_on_reactor_thread DCNL def add_gui_request(self, infohash, timeout=20, scrape_now=False): DCNL 'Public API for adding a GUI request. DCNL :param infohash: Torrent infohash. DCNL :param timeout: The timeout to use in the performed requests DCNL :param scrape_now: Flag whether we want to force scraping immediately'
def on_session_error(self, session, failure): DCNL 'Handles the scenario of when a tracker session has failed by calling the DCNL tracker_manager\'s update_tracker_info function. DCNL Trap value errors that are thrown by e.g. the HTTPTrackerSession when a connection fails. DCNL And trap CancelledErrors that can be thrown when shutting down. DCNL :param failure: The failure object raised by Twisted.'
def __init__(self, config=None, ignore_singleton=False, autoload_discovery=True): DCNL 'A Session object is created which is configured with the Tribler configuration object. DCNL Only a single session instance can exist at a time in a process. DCNL :param config: a TriblerConfig object or None, in which case we DCNL look for a saved session in the default location (state dir). If DCNL we can\'t find it, we create a new TriblerConfig() object to DCNL serve as startup config. Next, the config is saved in the directory DCNL indicated by its \'state_dir\' attribute. DCNL :param ignore_singleton: for testing purposes only. Enables the existence of multiple DCNL Session instances. DCNL :param autoload_discovery: only false in the Tunnel community tests'
def create_state_directory_structure(self): DCNL 'Create directory structure of the state directory.'
def get_ports_in_config(self): DCNL 'Claim all required random ports.'
def init_keypair(self): DCNL 'Set parameters that depend on state_dir.'
@staticmethod DCNL def get_instance(*args, **kw): DCNL 'Returns the Session singleton if it exists or otherwise creates it first, in which DCNL case you need to pass the constructor params. DCNL :return: the Session singleton'
@staticmethod DCNL def has_instance(): DCNL 'Check if there exists a Session singleton. DCNL :return: either True or False.'
@staticmethod DCNL def del_instance(): DCNL 'Remove the Session singleton.'
def unhandled_error_observer(self, event): DCNL 'This method is called when an unhandled error in Tribler is observed. DCNL It broadcasts the tribler_exception event.'
def start_download_from_uri(self, uri, download_config=None): DCNL 'Start a download from an argument. This argument can be of the following type: DCNL -http: Start a download from a torrent file at the given url. DCNL -magnet: Start a download from a torrent file by using a magnet link. DCNL -file: Start a download from a torrent file at given location. DCNL :param uri: specifies the location of the torrent to be downloaded DCNL :param download_config: an optional configuration for the download DCNL :return: a deferred that fires when a download has been added to the Tribler core'
def start_download_from_tdef(self, torrent_definition, download_startup_config=None, hidden=False): DCNL 'Creates a Download object and adds it to the session. The passed DCNL ContentDef and DownloadStartupConfig are copied into the new Download DCNL object. The Download is then started and checkpointed. DCNL If a checkpointed version of the Download is found, that is restarted DCNL overriding the saved DownloadStartupConfig if "download_startup_config" is not None. DCNL Locking is done by LaunchManyCore. DCNL :param torrent_definition: a finalized TorrentDef DCNL :param download_startup_config: a DownloadStartupConfig or None, in which case DCNL a new DownloadStartupConfig() is created with its default settings DCNL and the result becomes the runtime config of this Download DCNL :param hidden: whether this torrent should be added to the mypreference table DCNL :return: a Download'
def resume_download_from_file(self, filename): DCNL 'Recreates Download from resume file. DCNL Note: this cannot be made into a method of Download, as the Download DCNL needs to be bound to a session, it cannot exist independently. DCNL :return: a Download object DCNL :raises: a NotYetImplementedException'
def get_downloads(self): DCNL 'Returns a copy of the list of Downloads. DCNL Locking is done by LaunchManyCore. DCNL :return: a list of Download objects'
def get_download(self, infohash): DCNL 'Returns the Download object for this hash. DCNL Locking is done by LaunchManyCore. DCNL :return: a Download object'
def has_download(self, infohash): DCNL 'Checks if the torrent download already exists. DCNL :param infohash: The torrent infohash DCNL :return: True or False indicating if the torrent download already exists'
def remove_download(self, download, remove_content=False, remove_state=True, hidden=False): DCNL 'Stops the download and removes it from the session. DCNL Note that LaunchManyCore locks. DCNL :param download: the Download to remove DCNL :param remove_content: whether to delete the already downloaded content from disk DCNL :param remove_state: whether to delete the metadata files of the downloaded content from disk DCNL :param hidden: whether this torrent is added to the mypreference table and this entry should be removed'
def remove_download_by_id(self, infohash, remove_content=False, remove_state=True): DCNL 'Remove a download by it\'s infohash. DCNL We can only remove content when the download object is found, otherwise only DCNL the state is removed. DCNL :param infohash: the download to remove DCNL :param remove_content: whether to delete the already downloaded content from disk DCNL :param remove_state: whether to remove the metadata files from disk'
def set_download_states_callback(self, user_callback, interval=1.0): DCNL 'See Download.set_state_callback. Calls user_callback with a list of DCNL DownloadStates, one for each Download in the Session as first argument. DCNL The user_callback must return a tuple (when, getpeerlist) that indicates DCNL when to invoke the callback again (as a number of seconds from now, DCNL or < 0.0 if not at all) and whether to also include the details of DCNL the connected peers in the DownloadStates on that next call. DCNL The callback will be called by a popup thread which can be used DCNL indefinitely (within reason) by the higher level code. DCNL :param user_callback: a function adhering to the above spec DCNL :param interval: time in between the download states callback\'s'
def get_permid(self): DCNL 'Returns the PermID of the Session, as determined by the DCNL TriblerConfig.set_permid() parameter. A PermID is a public key. DCNL :return: the PermID encoded in a string in DER format'
def add_observer(self, observer_function, subject, change_types=None, object_id=None, cache=0): DCNL 'Add an observer function function to the Session. The observer DCNL function will be called when one of the specified events (changeTypes) DCNL occurs on the specified subject. DCNL The function will be called by a popup thread which can be used indefinitely (within reason) DCNL by the higher level code. Note that this function is called by any thread and is thread safe. DCNL :param observer_function: should accept as its first argument DCNL the subject, as second argument the changeType, as third argument an DCNL object_id (e.g. the primary key in the observed database) and an DCNL optional list of arguments. DCNL :param subject: the subject to observe, one of NTFY_* subjects (see simpledefs). DCNL :param change_types: the list of events to be notified of one of NTFY_* events. DCNL :param object_id: The specific object in the subject to monitor (e.g. a DCNL specific primary key in a database to monitor for updates.) DCNL :param cache: the time to bundle/cache events matching this function'
def remove_observer(self, function): DCNL 'Remove observer function. No more callbacks will be made. DCNL This function is called by any thread and is thread safe. DCNL :param function: the observer function to remove.'
def open_dbhandler(self, subject): DCNL 'Opens a connection to the specified database. Only the thread calling this method may DCNL use this connection. The connection must be closed with close_dbhandler() when this DCNL thread exits. This function is called by any thread. DCNL ;param subject: the database to open. Must be one of the subjects specified here. DCNL :return: a reference to a DBHandler class for the specified subject or DCNL None when the Session was not started with megacache enabled.'
@staticmethod DCNL def close_dbhandler(database_handler): DCNL 'Closes the given database connection.'
def get_tribler_statistics(self): DCNL 'Return a dictionary with general Tribler statistics.'
def get_dispersy_statistics(self): DCNL 'Return a dictionary with general Dispersy statistics.'
def get_community_statistics(self): DCNL 'Return a dictionary with general communities statistics.'
def load_checkpoint(self): DCNL 'Restart Downloads from a saved checkpoint, if any. Note that we fetch information from the user download DCNL choices since it might be that a user has stopped a download. In that case, the download should not be DCNL resumed immediately when being loaded by libtorrent.'
def checkpoint(self): DCNL 'Saves the internal session state to the Session\'s state dir. DCNL Checkpoints the downloads via the LaunchManyCore instance. This function is called by any thread.'
@blocking_call_on_reactor_thread DCNL def start_database(self): DCNL 'Start the SQLite database.'
@blocking_call_on_reactor_thread DCNL def start(self): DCNL 'Start a Tribler session by initializing the LaunchManyCore class, opening the database and running the upgrader. DCNL Returns a deferred that fires when the Tribler session is ready for use.'
@blocking_call_on_reactor_thread DCNL def shutdown(self): DCNL 'Checkpoints the session and closes it, stopping the download engine. DCNL This method has to be called from the reactor thread.'
def has_shutdown(self): DCNL 'Whether the Session has completely shutdown, i.e., its internal DCNL threads are finished and it is safe to quit the process the Session DCNL is running in. DCNL :return: a boolean.'
def get_downloads_pstate_dir(self): DCNL 'Returns the directory in which to checkpoint the Downloads in this DCNL Session. This function is called by the network thread.'
def download_torrentfile(self, infohash=None, user_callback=None, priority=0): DCNL 'Try to download the torrent file without a known source. A possible source could be the DHT. DCNL If the torrent is received successfully, the user_callback method is called with the infohash as first DCNL and the contents of the torrent file (bencoded dict) as second parameter. If the torrent could not DCNL be obtained, the callback is not called. The torrent will have been added to the TorrentDBHandler (if enabled) DCNL at the time of the call. DCNL :param infohash: the infohash of the torrent DCNL :param user_callback: a function adhering to the above spec DCNL :param priority: the priority of this download'
def download_torrentfile_from_peer(self, candidate, infohash=None, user_callback=None, priority=0): DCNL 'Ask the designated peer to send us the torrent file for the torrent DCNL identified by the passed infohash. If the torrent is successfully DCNL received, the user_callback method is called with the infohash as first DCNL and the contents of the torrent file (bencoded dict) as second parameter. DCNL If the torrent could not be obtained, the callback is not called. DCNL The torrent will have been added to the TorrentDBHandler (if enabled) DCNL at the time of the call. DCNL :param candidate: the designated peer DCNL :param infohash: the infohash of the torrent DCNL :param user_callback: a function adhering to the above spec DCNL :param priority: priority of this request'
def download_torrentmessage_from_peer(self, candidate, infohash, user_callback, priority=0): DCNL 'Ask the designated peer to send us the torrent message for the torrent DCNL identified by the passed infohash. If the torrent message is successfully DCNL received, the user_callback method is called with the infohash as first DCNL and the contents of the torrent file (bencoded dict) as second parameter. DCNL If the torrent could not be obtained, the callback is not called. DCNL The torrent will have been added to the TorrentDBHandler (if enabled) DCNL at the time of the call. DCNL :param candidate: the designated peer DCNL :param infohash: the infohash of the torrent DCNL :param user_callback: a function adhering to the above spec DCNL :param priority: priority of this request'
def checkpoint_downloads(self): DCNL 'Checkpoints the downloads.'
def update_trackers(self, infohash, trackers): DCNL 'Updates the trackers of a torrent. DCNL :param infohash: infohash of the torrent that needs to be updated DCNL :param trackers: A list of tracker urls'
def has_collected_torrent(self, infohash): DCNL 'Checks if the given torrent infohash exists in the torrent_store database. DCNL :param infohash: The given infohash binary DCNL :return: True or False indicating if we have the torrent'
def get_collected_torrent(self, infohash): DCNL 'Gets the given torrent from the torrent_store database. DCNL :param infohash: the given infohash binary DCNL :return: the torrent data if exists, None otherwise'
def save_collected_torrent(self, infohash, data): DCNL 'Saves the given torrent into the torrent_store database. DCNL :param infohash: the given infohash binary DCNL :param data: the torrent file data'
def delete_collected_torrent(self, infohash): DCNL 'Deletes the given torrent from the torrent_store database. DCNL :param infohash: the given infohash binary'
def search_remote_torrents(self, keywords): DCNL 'Searches for remote torrents through SearchCommunity with the given keywords. DCNL :param keywords: the given keywords DCNL :return: the number of requests made'
def search_remote_channels(self, keywords): DCNL 'Searches for remote channels through AllChannelCommunity with the given keywords. DCNL :param keywords: the given keywords'
@staticmethod DCNL def create_torrent_file(file_path_list, params=None): DCNL 'Creates a torrent file. DCNL :param file_path_list: files to add in torrent file DCNL :param params: optional parameters for torrent file DCNL :return: a Deferred that fires when the torrent file has been created'
def create_channel(self, name, description, mode=u'closed'): DCNL 'Creates a new Channel. DCNL :param name: name of the Channel DCNL :param description: description of the Channel DCNL :param mode: mode of the Channel (\'open\', \'semi-open\', or \'closed\') DCNL :return: a channel ID DCNL :raises a DuplicateChannelNameError if name already exists'
def add_torrent_def_to_channel(self, channel_id, torrent_def, extra_info={}, forward=True): DCNL 'Adds a TorrentDef to a Channel. DCNL :param channel_id: id of the Channel to add the Torrent to DCNL :param torrent_def: definition of the Torrent to add DCNL :param extra_info: description of the Torrent to add DCNL :param forward: when True the messages are forwarded (as defined by their message DCNL destination policy) to other nodes in the community. This parameter should (almost always) DCNL be True, its inclusion is mostly to allow certain debugging scenarios'
def check_torrent_health(self, infohash, timeout=20, scrape_now=False): DCNL 'Checks the given torrent\'s health on its trackers. DCNL :param infohash: the given torrent infohash DCNL :param timeout: time to wait while performing the request DCNL :param scrape_now: flag to scrape immediately'
def get_thumbnail_data(self, thumb_hash): DCNL 'Gets the thumbnail data. DCNL :param thumb_hash: the thumbnail SHA1 hash DCNL :return: the thumbnail data'
def __init__(self, input=None, metainfo=None, infohash=None): DCNL 'Normal constructor for TorrentDef (The input, metainfo and infohash DCNL parameters are used internally to make this a copy constructor)'
@staticmethod DCNL def load(filename): DCNL 'Load a BT .torrent or Tribler .tribe file from disk and convert DCNL it into a finalized TorrentDef. DCNL @param filename  An absolute Unicode filename DCNL @return TorrentDef'
@staticmethod DCNL def load_from_memory(data): DCNL 'Loads a torrent file that is already in memory. DCNL :param data: The torrent file data. DCNL :return: A TorrentDef object.'
def _read(stream): DCNL 'Internal class method that reads a torrent file from stream, DCNL checks it for correctness and sets self.input and self.metainfo DCNL accordingly.'
@staticmethod DCNL @blocking_call_on_reactor_thread DCNL def load_from_url(url): DCNL 'Load a BT .torrent or Tribler .tstream file from the URL and DCNL convert it into a TorrentDef. DCNL @param url URL DCNL @return Deferred'
@staticmethod DCNL def load_from_dict(metainfo): DCNL 'Load a BT .torrent or Tribler .tribe file from the metainfo dictionary DCNL it into a TorrentDef DCNL @param metainfo A dictionary following the BT torrent file spec. DCNL @return TorrentDef.'
def add_content(self, inpath, outpath=None, playtime=None): DCNL 'Add a file or directory to this torrent definition. When adding a DCNL directory, all files in that directory will be added to the torrent. DCNL One can add multiple files and directories to a torrent definition. DCNL In that case the "outpath" parameter must be used to indicate how DCNL the files/dirs should be named in the torrent. The outpaths used must DCNL start with a common prefix which will become the "name" field of the DCNL torrent. DCNL To seed the torrent via the core (as opposed to e.g. HTTP) you will DCNL need to start the download with the dest_dir set to the top-level DCNL directory containing the files and directories to seed. For example, DCNL a file "c:\Videosile.avi" is seeded as follows: DCNL <pre> DCNL tdef = TorrentDef() DCNL tdef.add_content("c:\Videosile.avi",playtime="1:59:20") DCNL tdef.set_tracker(s.get_internal_tracker_url()) DCNL tdef.finalize() DCNL dscfg = DownloadStartupConfig() DCNL dscfg.set_dest_dir("c:\Video") DCNL s.start_download(tdef,dscfg) DCNL </pre> DCNL @param inpath Absolute name of file or directory on local filesystem, DCNL as Unicode string. DCNL @param outpath (optional) Name of the content to use in the torrent def DCNL as Unicode string. DCNL @param playtime (optional) String representing the duration of the DCNL multimedia file when played, in [hh:]mm:ss format.'
def remove_content(self, inpath): DCNL 'Remove a file or directory from this torrent definition DCNL @param inpath Absolute name of file or directory on local filesystem, DCNL as Unicode string.'
def set_encoding(self, enc): DCNL 'Set the character encoding for e.g. the \'name\' field'
def set_tracker(self, url): DCNL 'Sets the tracker (i.e. the torrent file\'s \'announce\' field). DCNL @param url The announce URL.'
def get_tracker(self): DCNL 'Returns the announce URL. DCNL @return URL'
def set_tracker_hierarchy(self, hier): DCNL 'Set hierarchy of trackers (announce-list) following the spec DCNL at http://www.bittorrent.org/beps/bep_0012.html DCNL @param hier A hierarchy of trackers as a list of lists.'
def get_tracker_hierarchy(self): DCNL 'Returns the hierarchy of trackers. DCNL @return A list of lists.'
def get_trackers_as_single_tuple(self): DCNL 'Returns a flat tuple of all known trackers DCNL @return A tuple containing trackers'
def set_dht_nodes(self, nodes): DCNL 'Sets the DHT nodes required by the mainline DHT support, DCNL See http://www.bittorrent.org/beps/bep_0005.html DCNL @param nodes A list of [hostname,port] lists.'
def get_dht_nodes(self): DCNL 'Returns the DHT nodes set. DCNL @return A list of [hostname,port] lists.'
def set_comment(self, value): DCNL 'Set comment field. DCNL @param value A Unicode string.'
def get_comment(self): DCNL 'Returns the comment field of the def. DCNL @return A Unicode string.'
def get_comment_as_unicode(self): DCNL 'Returns the comment field of the def as a unicode string. DCNL @return A Unicode string.'
def set_created_by(self, value): DCNL 'Set \'created by\' field. DCNL @param value A Unicode string.'
def get_created_by(self): DCNL 'Returns the \'created by\' field. DCNL @return Unicode string.'
def set_urllist(self, value): DCNL 'Set list of HTTP seeds following the BEP 19 spec (GetRight style): DCNL http://www.bittorrent.org/beps/bep_0019.html DCNL @param value A list of URLs.'
def get_urllist(self): DCNL 'Returns the list of HTTP seeds. DCNL @return A list of URLs.'
def set_httpseeds(self, value): DCNL 'Set list of HTTP seeds following the BEP 17 spec (John Hoffman style): DCNL http://www.bittorrent.org/beps/bep_0017.html DCNL @param value A list of URLs.'
def get_httpseeds(self): DCNL 'Returns the list of HTTP seeds. DCNL @return A list of URLs.'
def set_piece_length(self, value): DCNL 'Set the size of the pieces in which the content is traded. DCNL The piece size must be a multiple of the chunk size, the unit in which DCNL it is transmitted, which is 16K by default (see DCNL DownloadConfig.set_download_slice_size()). The default is automatic DCNL (value 0). DCNL @param value A number of bytes as per the text.'
def get_piece_length(self): DCNL 'Returns the piece size. DCNL @return A number of bytes.'
def get_nr_pieces(self): DCNL 'Returns the number of pieces. DCNL @return A number of pieces.'
def get_pieces(self): DCNL 'Returns the pieces'
def set_initial_peers(self, value): DCNL 'Set the initial peers to connect to. DCNL @param value List of (IP,port) tuples'
def get_initial_peers(self): DCNL 'Returns the list of initial peers. DCNL @return List of (IP,port) tuples.'
def finalize(self, userabortflag=None, userprogresscallback=None): DCNL 'Create BT torrent file by reading the files added with DCNL add_content() and calculate the torrent file\'s infohash. DCNL Creating the torrent file can take a long time and will be carried out DCNL by the calling thread. The process can be made interruptable by passing DCNL a threading.Event() object via the userabortflag and setting it when DCNL the process should be aborted. The also optional userprogresscallback DCNL will be called by the calling thread periodically, with a progress DCNL percentage as argument. DCNL The userprogresscallback function will be called by the calling thread. DCNL @param userabortflag threading.Event() object DCNL @param userprogresscallback Function accepting a fraction as first DCNL argument.'
def is_finalized(self): DCNL 'Returns whether the TorrentDef is finalized or not. DCNL @return Boolean.'
def get_infohash(self): DCNL 'Returns the infohash of the torrent, for non-URL compatible DCNL torrents. Otherwise it returns the swarm identifier (either the root hash DCNL (Merkle torrents) or hash of the live-source authentication key. DCNL @return A string of length 20.'
def get_metainfo(self): DCNL 'Returns the torrent definition as a dictionary that follows the BT DCNL spec for torrent files. DCNL @return dict'
def get_name(self): DCNL 'Returns the info[\'name\'] field as raw string of bytes. DCNL @return String'
def set_name(self, name): DCNL 'Set the name of this torrent DCNL @param name name of torrent as String'
def get_name_as_unicode(self): DCNL 'Returns the info[\'name\'] field as Unicode string. DCNL @return Unicode string.'
def save(self, filename): DCNL 'Finalizes the torrent def and writes a torrent file i.e., bencoded dict DCNL following BT spec) to the specified filename. Note this may take a DCNL long time when the torrent def is not yet finalized. DCNL @param filename An absolute Unicode path name.'
def get_torrent_size(self): DCNL 'Finalizes the torrent def and converts the metainfo to string, returns the DCNL number of bytes the string would take on disk.'
def _get_all_files_as_unicode_with_length(self): DCNL 'Get a generator for files in the torrent def. No filtering DCNL is possible and all tricks are allowed to obtain a unicode DCNL list of filenames. DCNL @return A unicode filename generator.'
def get_files_with_length(self, exts=None): DCNL 'The list of files in the finalized torrent def. DCNL @param exts (Optional) list of filename extensions (without leading .) DCNL to search for. DCNL @return A list of filenames.'
def get_length(self, selectedfiles=None): DCNL 'Returns the total size of the content in the torrent. If the DCNL optional selectedfiles argument is specified, the method returns DCNL the total size of only those files. DCNL @return A length (long)'
def is_multifile_torrent(self): DCNL 'Returns whether this TorrentDef is a multi-file torrent. DCNL @return Boolean'
def is_private(self): DCNL 'Returns whether this TorrentDef is a private torrent. DCNL @return Boolean'
def __init__(self, session, endpoint, prefix, block_size=DEFAULT_BLOCK_SIZE, timeout=DEFAULT_TIMEOUT, max_retries=DEFAULT_RETIES): DCNL 'The constructor. DCNL :param session:     The tribler session. DCNL :param endpoint:    The endpoint to use. DCNL :param prefix:      The prefix to use. DCNL :param block_size:  Transmission block size. DCNL :param timeout:     Transmission timeout. DCNL :param max_retries: Transmission maximum retries.'
def initialize(self): DCNL 'Initializes the TFTP service. We create a UDP socket and a server session.'
@blocking_call_on_reactor_thread DCNL def shutdown(self): DCNL 'Shuts down the TFTP service.'
@call_on_reactor_thread DCNL def download_file(self, file_name, ip, port, extra_info=None, success_callback=None, failure_callback=None): DCNL 'Downloads a file from a remote host. DCNL :param file_name: The file name of the file to be downloaded. DCNL :param ip:        The IP of the remote host. DCNL :param port:      The port of the remote host. DCNL :param success_callback: The success callback. DCNL :param failure_callback: The failure callback.'
@attach_runtime_statistics(u'{0.__class__.__name__}.{function_name}') DCNL def _task_check_timeout(self): DCNL 'A scheduled task that checks for timeout.'
def _check_session_timeout(self, session): DCNL 'Checks if a session has timed out and tries to retransmit packet if allowed. DCNL :param session: The given session. DCNL :return: True or False indicating if the session has failed.'
def _schedule_callback_processing(self): DCNL 'Schedules a task to process callbacks.'
@attach_runtime_statistics(u'{0.__class__.__name__}.{function_name}') DCNL def _process_callbacks(self): DCNL 'Process the callbacks'
@attach_runtime_statistics(u'{0.__class__.__name__}.{function_name}') DCNL @call_on_reactor_thread DCNL def data_came_in(self, addr, data): DCNL 'The callback function that the thread pool will call when there is incoming data. DCNL :param addr: The (IP, port) address tuple of the sender. DCNL :param data: The data received.'
def _handle_new_request(self, ip, port, packet): DCNL 'Handles a new request. DCNL :param ip:      The IP of the client. DCNL :param port:    The port of the client. DCNL :param packet:  The packet.'
def _load_metadata(self, thumb_hash): DCNL 'Loads a thumbnail into memory. DCNL :param thumb_hash: The thumbnail hash.'
def _load_torrent(self, file_name): DCNL 'Loads a file into memory. DCNL :param file_name: The file name.'
def _get_next_data(self, session): DCNL 'Gets the next block of data to be uploaded. This method is only used for data uploading. DCNL :return The data to transfer.'
def _process_packet(self, session, packet): DCNL 'processes an incoming packet. DCNL :param packet: The incoming packet dictionary.'
def _handle_packet_as_receiver(self, session, packet): DCNL 'Processes an incoming packet as a receiver. DCNL :param packet: The incoming packet dictionary.'
def _handle_packet_as_sender(self, session, packet): DCNL 'Processes an incoming packet as a sender. DCNL :param packet: The incoming packet dictionary.'
def _handle_error(self, session, error_code, error_msg=''): DCNL 'Handles an error during packet processing. DCNL :param error_code: The error code.'
def set_dest_dir(self, path): DCNL 'Sets the directory where to save this Download. DCNL @param path A path of a directory.'
def get_dest_dir(self): DCNL 'Gets the directory where to save this Download.'
def get_corrected_filename(self): DCNL 'Gets the directory name where to save this torrent'
def set_corrected_filename(self, correctedfilename): DCNL 'Sets the directory name where to save this torrent DCNL @param correctedfilename name for multifile directory'
def set_mode(self, mode): DCNL 'Sets the mode of this download. DCNL @param mode DLMODE_NORMAL/DLMODE_VOD'
def get_mode(self): DCNL 'Returns the mode of this download. DCNL @return DLMODE_NORMAL/DLMODE_VOD'
def set_selected_files(self, files): DCNL 'Select which files in the torrent to download. The filenames must DCNL be the names as they appear in the content def, including encoding. DCNL Trivially, when the torrent contains a file \'sjaak.avi\' the files DCNL parameter must be \'sjaak.avi\'. When the content def is a torrent def DCNL and contains multiple files and is named \'filecollection\', the files DCNL parameter must be DCNL os.path.join(\'filecollection\',\'sjaak.avi\') DCNL For a swift def, the files must be following the multi-file spec encoding DCNL (i.e., UTF-8 and /). DCNL @param files Can be a single filename or a list of filenames (e.g. DCNL [\'harry.avi\',\'sjaak.avi\']). Not Unicode strings!'
def get_selected_files(self): DCNL 'Returns the list of files selected for download. DCNL @return A list of strings.'
def __init__(self, dlconfig=None): DCNL 'Normal constructor for DownloadStartupConfig (copy constructor DCNL used internally)'
def load(filename): DCNL 'Load a saved DownloadStartupConfig from disk. DCNL @param filename  An absolute Unicode filename DCNL @return DownloadStartupConfig object'
def save(self, filename): DCNL 'Save the DownloadStartupConfig to disk. DCNL @param filename  An absolute Unicode filename'
def __init__(self, config=None): DCNL 'Create a new TriblerConfig instance. DCNL :param config: a ConfigObj instance DCNL :raises an InvalidConfigException if ConfigObj is invalid'
@staticmethod DCNL def load(config_path=None): DCNL 'Load a TriblerConfig from disk.'
def copy(self): DCNL 'Return a TriblerConfig object that has the same values.'
def validate(self): DCNL 'Validate the ConfigObj using Validator. DCNL Note that `validate()` returns `True` if the ConfigObj is correct and a dictionary with `True` and `False` DCNL values for keys who\'s validation failed if at least one key was found to be incorrect.'
def write(self): DCNL 'Write the configuration to the config file in the state dir as specified in the config.'
@staticmethod DCNL def get_default_state_dir(home_dir_postfix=u'.Tribler'): DCNL 'Get the default application state directory.'
def _obtain_port(self, section, option): DCNL 'Fetch a port setting from the config file and in case it\'s set to -1 (random), look for a free port DCNL and assign it to this particular setting.'
def _get_random_port(self, path): DCNL 'Get a random port which is not already selected.'
def _set_video_analyser_path(self): DCNL 'Set the path of the video analyser. DCNL The path set depends on the current platform. DCNL :return:'
def set_libtorrent_proxy_settings(self, proxy_type, server=None, auth=None): DCNL 'Set which proxy LibTorrent should use (default = 0). DCNL :param proxy_type: int (0 = no proxy server, DCNL 1 = SOCKS4, DCNL 2 = SOCKS5, DCNL 3 = SOCKS5 + auth, DCNL 4 = HTTP, DCNL 5 = HTTP + auth) DCNL :param server: (host, port) tuple or None DCNL :param auth: (username, password) tuple or None'
def set_anon_proxy_settings(self, proxy_type, server=None, auth=None): DCNL ':param proxy_type: int (0 = no proxy server, DCNL 1 = SOCKS4, DCNL 2 = SOCKS5, DCNL 3 = SOCKS5 + auth, DCNL 4 = HTTP, DCNL 5 = HTTP + auth) DCNL :param server: (host, [ports]) tuple or None DCNL :param auth: (username, password) tuple or None'
def get_anon_proxy_settings(self): DCNL 'Get the anon proxy settings. DCNL :return: a 4-tuple with the proxytype in int, (ip as string, list of ports in int), auth'
def set_libtorrent_max_conn_download(self, value): DCNL 'Set the maximum amount of connections for each download. DCNL By default, this is -1, unlimited. DCNL :param value: int.'
def get_libtorrent_max_conn_download(self): DCNL 'Returns the maximum amount of connections per download DCNL :return: int.'
def set_libtorrent_max_upload_rate(self, value): DCNL 'Sets the maximum upload rate (kB / s). DCNL :param value: the new maximum upload rate in kB / s DCNL :return:'
def get_libtorrent_max_upload_rate(self): DCNL 'Gets the maximum upload rate (kB / s). DCNL :return: the maximum upload rate in kB / s'
def set_libtorrent_max_download_rate(self, value): DCNL 'Sets the maximum download rate (kB / s). DCNL :param value: the new maximum download rate in kB / s DCNL :return:'
def get_libtorrent_max_download_rate(self): DCNL 'Gets the maximum download rate (kB / s). DCNL :return: the maximum download rate in kB / s'
def set_credit_mining_sources(self, source_list, key): DCNL 'Set source list for a chosen key: boosting_sources, boosting_enabled, boosting_disabled, or archive_sources. DCNL :param source_list: One of boosting_sources, DCNL boosting_enabled, DCNL boosting_disabled, DCNL archive_sources DCNL :param key: the ConfigObj key'
def set_credit_mining_policy(self, policy): DCNL 'The policy should be one of DCNL - "random" DCNL - "creation" DCNL - "seederratio" DCNL :param policy: a string DCNL :return:'
def get_credit_mining_policy(self, as_class=False): DCNL 'Get the credit mining policy. DCNL :param as_class: whether to return a string or the python class DCNL :return: the policy in string form or the policy class.'
def __init__(self, download, status, error, progress, stats=None, seeding_stats=None, filepieceranges=None, logmsgs=None, peerid=None, videoinfo=None): DCNL 'Internal constructor. DCNL @param download The Download this state belongs too. DCNL @param status The status of the Download (DLSTATUS_*) DCNL @param progress The general progress of the Download. DCNL @param stats The BT engine statistics for the Download. DCNL @param filepieceranges The range of pieces that we are interested in. DCNL The get_pieces_complete() returns only completeness information about DCNL this range. This is used for playing a video in a multi-torrent file. DCNL @param logmsgs A list of messages from the BT engine which may be of'
def get_download(self): DCNL 'Returns the Download object of which this is the state'
def get_progress(self): DCNL 'The general progress of the Download as a percentage. When status is DCNL * DLSTATUS_HASHCHECKING it is the percentage of already downloaded DCNL content checked for integrity. DCNL * DLSTATUS_DOWNLOADING/SEEDING it is the percentage downloaded. DCNL @return Progress as a float (0..1).'
def get_status(self): DCNL 'Returns the status of the torrent. DCNL @return DLSTATUS_*'
def get_error(self): DCNL 'Returns the Exception that caused the download to be moved to DCNL DLSTATUS_STOPPED_ON_ERROR status. DCNL @return Exception'
def get_current_speed(self, direct): DCNL 'Returns the current up or download speed. DCNL @return The speed in bytes/s.'
def get_total_transferred(self, direct): DCNL 'Returns the total amount of up or downloaded bytes. DCNL @return The amount in bytes.'
def get_seeding_statistics(self): DCNL 'Returns the seedings stats for this download. Will only be availible after DCNL SeedingManager update_download_state is called. DCNL Contains if not null, version, total_up, total_down, time_seeding DCNL All values are stored by the seedingmanager, thus will not only contain current download session values'
def get_eta(self): DCNL 'Returns the estimated time to finish of download. DCNL @return The time in ?, as ?.'
def get_num_con_initiated(self): DCNL 'Returns the download\'s number of initiated connections. This is used DCNL to see if there is any progress when non-fatal errors have occured DCNL (e.g. tracker timeout). DCNL @return An integer.'
def get_num_peers(self): DCNL 'Returns the download\'s number of active connections. This is used DCNL to see if there is any progress when non-fatal errors have occured DCNL (e.g. tracker timeout). DCNL @return An integer.'
def get_num_nonseeds(self): DCNL 'Returns the download\'s number of non-seeders. DCNL @return An integer.'
def get_num_seeds_peers(self): DCNL 'Returns the sum of the number of seeds and peers. This function DCNL works only if the Download.set_state_callback() / DCNL Session.set_download_states_callback() was called with the getpeerlist DCNL parameter set to True, otherwise returns (None,None) DCNL @return A tuple (num seeds, num peers)'
def get_pieces_complete(self): DCNL 'Returns a list of booleans indicating whether we have completely DCNL received that piece of the content. The list of pieces for which DCNL we provide this info depends on which files were selected for download DCNL using DownloadStartupConfig.set_selected_files(). DCNL @return A list of booleans'
def get_pieces_total_complete(self): DCNL 'Returns the number of total and completed pieces DCNL @return A tuple containing two integers, total and completed nr of pieces'
def get_files_completion(self): DCNL 'Returns a list of filename, progress tuples indicating the progress DCNL for every file selected using set_selected_files. Progress is a float DCNL between 0 and 1'
def get_availability(self): DCNL 'Return overall the availability of all pieces, using connected peers DCNL Availability is defined as the number of complete copies of a piece, thus seeders DCNL increment the availability by 1. Leechers provide a subset of piece thus we count the DCNL overall availability of all pieces provided by the connected peers and use the minimum DCNL of this + the average of all additional pieces.'
def get_vod_prebuffering_progress(self): DCNL 'Returns the percentage of prebuffering for Video-On-Demand already DCNL completed. DCNL @return A float (0..1)'
def get_vod_prebuffering_progress_consec(self): DCNL 'Returns the percentage of consecutive prebuffering for Video-On-Demand already DCNL completed. DCNL @return A float (0..1)'
def is_vod(self): DCNL 'Returns if this download is currently in vod mode DCNL @return A Boolean'
def get_peerlist(self): DCNL 'Returns a list of dictionaries, one for each connected peer DCNL containing the statistics for that peer. In particular, the DCNL dictionary contains the keys: DCNL <pre> DCNL \'id\' = PeerID or \'http seed\' DCNL \'extended_version\' = Peer client version, as received during the extend handshake message DCNL \'ip\' = IP address as string or URL of httpseed DCNL \'port\' = Port DCNL \'pex_received\' = True/False DCNL \'optimistic\' = True/False DCNL \'direction\' = \'L\'/\'R\' (outgoing/incoming) DCNL \'uprate\' = Upload rate in KB/s DCNL \'uinterested\' = Upload Interested: True/False DCNL \'uchoked\' = Upload Choked: True/False DCNL \'uhasqueries\' = Upload has requests in buffer and not choked DCNL \'uflushed\' = Upload is not flushed DCNL \'downrate\' = Download rate in KB/s DCNL \'dinterested\' = Download interested: True/Flase DCNL \'dchoked\' = Download choked: True/False DCNL \'snubbed\' = Download snubbed: True/False DCNL \'utotal\' = Total uploaded from peer in KB DCNL \'dtotal\' = Total downloaded from peer in KB DCNL \'completed\' = Fraction of download completed by peer (0-1.0) DCNL -- QUESTION(lipu): swift and Bitfield are gone. Does this \'have\' thing has anything to do with swift? DCNL \'have\' = Bitfield object for this peer if not complete DCNL \'speed\' = The peer\'s current total download speed (estimated) DCNL </pre>'
def family_filter_enabled(self): DCNL 'Return is xxx filtering is enabled in this client'
@staticmethod DCNL def _encode_half_block(message): DCNL 'Encode a half block message. DCNL :param message: Message.impl of HalfBlockPayload.impl DCNL :return encoding ready to be sent to the network of the message'
@staticmethod DCNL def _decode_half_block(placeholder, offset, data): DCNL 'Decode an incoming half block message. DCNL :param placeholder: DCNL :param offset: Start of the HalfBlock message in the data. DCNL :param data: ByteStream containing the message. DCNL :return: (offset, HalfBlockPayload.impl)'
@staticmethod DCNL def _encode_crawl_request(message): DCNL 'Encode a crawl request message. DCNL :param message: Message.impl of CrawlRequestPayload.impl DCNL :return encoding ready to be sent of the network of the message'
@staticmethod DCNL def _decode_crawl_request(placeholder, offset, data): DCNL 'Decode an incoming crawl request message. DCNL :param placeholder: DCNL :param offset: Start of the CrawlRequest message in the data. DCNL :param data: ByteStream containing the message. DCNL :return: (offset, CrawlRequest.impl)'
def __init__(self, working_directory, db_name): DCNL 'Sets up the persistence layer ready for use. DCNL :param working_directory: Path to the working directory DCNL that will contain the the db at working directory/DATABASE_PATH DCNL :param db_name: The name of the database'
def add_block(self, block): DCNL 'Persist a block DCNL :param block: The data that will be saved.'
def get(self, public_key, sequence_number): DCNL 'Get a specific block for a given public key DCNL :param public_key: The public_key for which the block has to be found. DCNL :param sequence_number: The specific block to get DCNL :return: the block or None if it is not known'
def contains(self, block): DCNL 'Check if a block is existent in the persistence layer. DCNL :param block: the block to check DCNL :return: True if the block exists, else false.'
def get_latest(self, public_key): DCNL 'Get the latest block for a given public key DCNL :param public_key: The public_key for which the latest block has to be found. DCNL :return: the latest block or None if it is not known'
def get_block_after(self, block): DCNL 'Returns database block with the lowest sequence number higher than the block\'s sequence_number DCNL :param block: The block who\'s successor we want to find DCNL :return A block'
def get_block_before(self, block): DCNL 'Returns database block with the highest sequence number lower than the block\'s sequence_number DCNL :param block: The block who\'s predecessor we want to find DCNL :return A block'
def get_linked(self, block): DCNL 'Get the block that is linked to the given block DCNL :param block: The block for which to get the linked block DCNL :return: the latest block or None if it is not known'
def get_sql_header(self): DCNL 'Return the first part of a generic sql select query.'
def get_schema(self): DCNL 'Return the schema for the database.'
def get_upgrade_script(self, current_version): DCNL 'Return the upgrade script for a specific version. DCNL :param current_version: the version of the script to return.'
def check_database(self, database_version): DCNL 'Ensure the proper schema is used by the database. DCNL :param database_version: Current version of the database. DCNL :return:'
def validate_transaction(self, database): DCNL 'Validates the transaction of this block DCNL :param database: the database to check against DCNL :return: A tuple consisting of a ValidationResult and a list of user string errors'
def validate(self, database): DCNL 'Validates this block against what is known in the database DCNL :param database: the database to check against DCNL :return: A tuple consisting of a ValidationResult and a list of user string errors'
def sign(self, key): DCNL 'Signs this block with the given key DCNL :param key: the key to sign this block with'
@classmethod DCNL def create(cls, transaction, database, public_key, link=None, link_pk=None): DCNL 'Create an empty next block. DCNL :param database: the database to use as information source DCNL :param transaction: the transaction to use in this block DCNL :param public_key: the public key to use for this block DCNL :param link: optionally create the block as a linked block to this block DCNL :param link_pk: the public key of the counterparty in this transaction DCNL :return: A newly created block'
def pack(self, signature=True): DCNL 'Encode this block for transport DCNL :param signature: False to pack EMPTY_SIG in the signature location, true to pack the signature field DCNL :return: the buffer the data was packed into'
@classmethod DCNL def unpack(cls, data, offset=0): DCNL 'Unpacks a block from a buffer DCNL :param data: The buffer to unpack from DCNL :param offset: Optionally, the offset at which to start unpacking DCNL :return: The TrustChainBlock that was unpacked from the buffer'
def pack_db_insert(self): DCNL 'Prepare a tuple to use for inserting into the database DCNL :return: A database insertable tuple'
def __iter__(self): DCNL 'This override allows one to take the dict(<block>) of a block. DCNL :return: generator to iterate over all properties of this block'
@staticmethod DCNL def valid(): DCNL 'The block does not violate any rules'
@staticmethod DCNL def partial(): DCNL 'The block does not violate any rules, but there are gaps or no blocks on the previous or next block'
@staticmethod DCNL def partial_next(): DCNL 'The block does not violate any rules, but there is a gap or no block on the next block'
@staticmethod DCNL def partial_previous(): DCNL 'The block does not violate any rules, but there is a gap or no block on the previous block'
@staticmethod DCNL def no_info(): DCNL 'There are no blocks (previous or next) to validate against'
@staticmethod DCNL def invalid(): DCNL 'The block violates at least one validation rule'
def initiate_meta_messages(self): DCNL 'Setup all message that can be received by this community and the super classes. DCNL :return: list of meta messages.'
def should_sign(self, message): DCNL 'Return whether we should sign the block in the passed message. DCNL @param message: the message containing a block we want to sign or not.'
def wait_for_intro_of_candidate(self, candidate): DCNL 'Returns a Deferred that fires when we receive an introduction response from a given candidate.'
def wait_for_signature_request(self, block_id): DCNL 'Returns a Deferred that fires when we receive a signature request with a specific block hash.'
def sign_block(self, candidate, public_key=None, transaction=None, linked=None): DCNL 'Create, sign, persist and send a block signed message DCNL :param candidate: The peer with whom you have interacted, as a dispersy candidate DCNL :param transaction: A string describing the interaction in this block DCNL :param linked: The block that the requester is asking us to sign'
def received_half_block(self, messages): DCNL 'We\'ve received a half block, either because we sent a SIGNED message to some one or we are crawling DCNL :param messages The half block messages'
def set_live_edge_callback(self, func): DCNL 'Set the callback function for live edge updates. DCNL Passed arguments are: DCNL live_edge_id, [candidates]'
def reset_live_edges(self): DCNL 'Reset the live edges counter and current live edge.'
def set_live_edges_enabled(self, value): DCNL 'Enable or disable live edges. DCNL :param value: whether or not to enable live edges DCNL :type value: boolean'
def get_trust(self, member): DCNL 'Get the trust for another member. DCNL Currently this is just the length of their chain. DCNL :param member: the member we interacted with DCNL :type member: dispersy.member.Member DCNL :return: the trust value for this member DCNL :rtype: int'
def dispersy_get_introduce_candidate(self, exclude_candidate=None): DCNL 'Choose a trusted candidate to introduce to someone else. DCNL The more trust you have for someone, the higher the chance is to forward them.'
def __init__(self, order_book): DCNL ':param order_book: The order book to search in DCNL :type order_book: OrderBook'
@abstractmethod DCNL def match_order(self, order): DCNL ':param order: The order to match against DCNL :type order: Order DCNL :return: The proposed trades DCNL :rtype: [ProposedTrade]'
def match_order(self, order): DCNL ':param order: The order to match against DCNL :type order: Order DCNL :return: The proposed trades DCNL :rtype: [ProposedTrade]'
def _search_for_quantity_in_order_book(self, price, price_level, quantity_to_trade, order): DCNL 'Search through the price levels in the order book DCNL :param price: The price of the price level DCNL :param price_level: The price level to search in DCNL :param quantity_to_trade: The quantity still to be matched DCNL :param order: The order to match for DCNL :type price: Price DCNL :type price_level: PriceLevel DCNL :type quantity_to_trade: Quantity DCNL :type order: Order DCNL :return: The quantity to trade and the proposed trades DCNL :rtype: Quantity, [ProposedTrade]'
def _search_for_quantity_in_price_level(self, tick_entry, quantity_to_trade, order): DCNL 'Search through the tick entries in the price levels DCNL :param tick_entry: The tick entry to match against DCNL :param quantity_to_trade: The quantity still to be matched DCNL :param order: The order to match for DCNL :type tick_entry: TickEntry DCNL :type quantity_to_trade: Quantity DCNL :type order: Order DCNL :return: The quantity to trade and the proposed trades DCNL :rtype: Quantity, [ProposedTrade]'
def __init__(self, matching_strategy): DCNL ':param matching_strategy: The strategy to use DCNL :type matching_strategy: MatchingStrategy'
def match_order(self, order): DCNL ':param order: The order to match against DCNL :type order: Order DCNL :return: The proposed trades DCNL :rtype: [ProposedTrade]'
def __init__(self, order_number): DCNL ':param order_number: Integer representing the number of an order DCNL :type order_number: int DCNL :raises ValueError: Thrown when one of the arguments are invalid'
def __init__(self, trader_id, order_number): DCNL ':param trader_id: The trader id who created the order DCNL :param order_number: The number of the order created DCNL :type trader_id: TraderId DCNL :type order_number: OrderNumber'
@property DCNL def trader_id(self): DCNL ':rtype: TraderId'
@property DCNL def order_number(self): DCNL ':rtype: OrderNumber'
def __str__(self): DCNL 'format: <trader_id>.<order_number>'
def __init__(self, order_id, price, quantity, timeout, timestamp, is_ask): DCNL ':param order_id: An order id to identify the order DCNL :param price: A price to indicate for which amount to sell or buy DCNL :param quantity: A quantity to indicate how much to sell or buy DCNL :param timeout: A timeout when this tick is going to expire DCNL :param timestamp: A timestamp when the order was created DCNL :param is_ask: A bool to indicate if this order is an ask DCNL :type order_id: OrderId DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type timeout: Timeout DCNL :type timestamp: Timestamp DCNL :type is_ask: bool'
@classmethod DCNL def from_database(cls, data, reserved_ticks): DCNL 'Create an Order object based on information in the database.'
def to_database(self): DCNL 'Returns a database representation of an Order object. DCNL :rtype: tuple'
@property DCNL def reserved_ticks(self): DCNL ':rtype: Dictionary[OrderId: Quantity]'
@property DCNL def order_id(self): DCNL ':rtype: OrderId'
@property DCNL def price(self): DCNL ':rtype: Price'
@property DCNL def total_quantity(self): DCNL 'Return the total quantity of the order DCNL :rtype: Quantity'
@property DCNL def available_quantity(self): DCNL 'Return the quantity that is not reserved DCNL :rtype: Quantity'
@property DCNL def reserved_quantity(self): DCNL 'Return the reserved quantity of the order DCNL :rtype: Quantity'
@property DCNL def traded_quantity(self): DCNL 'Return the traded quantity of the order DCNL :rtype: Quantity'
@property DCNL def timeout(self): DCNL 'Return when the order is going to expire DCNL :rtype: Timeout'
@property DCNL def timestamp(self): DCNL ':rtype: Timestamp'
@property DCNL def completed_timestamp(self): DCNL ':return: the timestamp of completion of this order, None if this order is not completed (yet). DCNL :rtype: Timestamp'
def is_ask(self): DCNL ':return: True if message is an ask, False otherwise DCNL :rtype: bool'
@property DCNL def cancelled(self): DCNL ':return: whether the order has been cancelled or not. DCNL :rtype: bool'
def is_complete(self): DCNL ':return: True if the order is completed. DCNL :rtype: bool'
@property DCNL def status(self): DCNL 'Return the status of this order. Can be one of these: "open", "completed", "expired" or "cancelled" DCNL :return: The status of this order DCNL :rtype: str'
def reserve_quantity_for_tick(self, order_id, quantity): DCNL ':param order_id: The order id from another peer that the quantity needs to be reserved for DCNL :param quantity: The quantity to reserve DCNL :type order_id: OrderId DCNL :type quantity: Quantity DCNL :return: True if the quantity was reserved, False otherwise DCNL :rtype: bool'
def release_quantity_for_tick(self, order_id, quantity): DCNL 'Release all quantity for a specific tick. DCNL :param order_id: The order id from another peer that the quantity needs to be released for DCNL :type order_id: OrderId DCNL :raises TickWasNotReserved: Thrown when the tick was not reserved first'
def is_valid(self): DCNL ':return: True if valid, False otherwise DCNL :rtype: bool'
def to_dictionary(self): DCNL 'Return a dictionary representation of this dictionary.'
def __init__(self, payment_id): DCNL ':param payment_id: String representation of the id of the payment DCNL :type payment_id: str DCNL :raises ValueError: Thrown when one of the arguments are invalid'
@property DCNL def payment_id(self): DCNL 'Return the payment id.'
def __init__(self, message_id, order_id, price, quantity, timeout, timestamp, is_ask, public_key=EMPTY_PK, signature=EMPTY_SIG): DCNL 'Don\'t use this class directly, use one of the class methods DCNL :param message_id: A message id to identify the tick DCNL :param order_id: A order id to identify the order this tick represents DCNL :param price: A price to indicate for which amount to sell or buy DCNL :param quantity: A quantity to indicate how much to sell or buy DCNL :param timeout: A timeout when this tick is going to expire DCNL :param timestamp: A timestamp when the tick was created DCNL :param is_ask: A bool to indicate if this tick is an ask DCNL :param public_key: The public key of the originator of this message DCNL :param signature: A signature of this message DCNL :type message_id: MessageId DCNL :type order_id: OrderId DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type timeout: Timeout DCNL :type timestamp: Timestamp DCNL :type is_ask: bool DCNL :type public_key: str DCNL :type signature: str'
@classmethod DCNL def from_order(cls, order, message_id): DCNL 'Create a tick from an order DCNL :param order: The order that this tick represents DCNL :param message_id: The message id for the tick DCNL :return: The created tick DCNL :rtype: Tick'
@property DCNL def order_id(self): DCNL ':rtype: OrderId'
@property DCNL def price(self): DCNL ':rtype: Price'
@property DCNL def quantity(self): DCNL ':rtype: Quantity'
@quantity.setter DCNL def quantity(self, quantity): DCNL ':param quantity: The new quantity DCNL :type quantity: Quantity'
@property DCNL def timeout(self): DCNL 'Return when the tick is going to expire DCNL :rtype: Timeout'
def is_ask(self): DCNL ':return: True if this tick is an ask, False otherwise DCNL :rtype: bool'
def is_valid(self): DCNL ':return: True if valid, False otherwise DCNL :rtype: bool'
def sign(self, member): DCNL 'Sign this tick using a private key. DCNL :param member: The member that signs this tick'
def update_timestamp(self): DCNL 'Update the timestamp of this tick and set it to the current time.'
def to_network(self): DCNL 'Return network representation of the tick'
def to_dictionary(self): DCNL 'Return a dictionary with a representation of this tick.'
def __init__(self, message_id, order_id, price, quantity, timeout, timestamp, public_key=EMPTY_PK, signature=EMPTY_SIG): DCNL ':param message_id: A message id to identify the ask DCNL :param order_id: A order id to identify the order this tick represents DCNL :param price: A price that needs to be paid for the ask DCNL :param quantity: The quantity that needs to be sold DCNL :param timeout: A timeout for the ask DCNL :param timestamp: A timestamp for when the ask was created DCNL :param public_key: The public key of the originator of this message DCNL :param signature: A signature of this message DCNL :type message_id: MessageId DCNL :type order_id: OrderId DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type timeout: Timeout DCNL :type timestamp: Timestamp DCNL :type public_key: str DCNL :type signature: str'
@classmethod DCNL def from_network(cls, data): DCNL 'Restore an ask from the network DCNL :param data: OfferPayload DCNL :return: Restored ask DCNL :rtype: Ask'
def __init__(self, message_id, order_id, price, quantity, timeout, timestamp, public_key=EMPTY_PK, signature=EMPTY_SIG): DCNL ':param message_id: A message id to identify the bid DCNL :param order_id: A order id to identify the order this tick represents DCNL :param price: A price that you are willing to pay for the bid DCNL :param quantity: The quantity that you want to buy DCNL :param timeout: A timeout for the bid DCNL :param timestamp: A timestamp for when the bid was created DCNL :param public_key: The public key of the originator of this message DCNL :param signature: A signature of this message DCNL :type message_id: MessageId DCNL :type order_id: OrderId DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type timeout: Timeout DCNL :type timestamp: Timestamp DCNL :type public_key: str DCNL :type signature: str'
@classmethod DCNL def from_network(cls, data): DCNL 'Restore a bid from the network DCNL :param data: OfferPayload DCNL :return: Restored bid DCNL :rtype: Bid'
def __init__(self): DCNL 'Do not use this class directly DCNL Make a subclass of this class with a specific implementation for a storage backend'
def __init__(self, mid): DCNL ':param mid: Hex encoded version of the member id of this node DCNL :type mid: str'
def find_all(self): DCNL ':rtype: [Transaction]'
def find_by_id(self, transaction_id): DCNL ':param transaction_id: The transaction id to look for DCNL :type transaction_id: TransactionId DCNL :return: The transaction or null if it cannot be found DCNL :rtype: Transaction'
def add(self, transaction): DCNL ':type transaction: Transaction'
def update(self, transaction): DCNL ':type transaction: Transaction'
def delete_by_id(self, transaction_id): DCNL ':type transaction_id: TransactionId'
def next_identity(self): DCNL ':rtype: TransactionId'
def __init__(self, mid, persistence): DCNL ':param mid: Hex encoded version of the member id of this node DCNL :type mid: str'
def find_all(self): DCNL ':rtype: [Transaction]'
def find_by_id(self, transaction_id): DCNL ':param transaction_id: The transaction id to look for DCNL :type transaction_id: TransactionId DCNL :return: The transaction or null if it cannot be found DCNL :rtype: Transaction'
def add(self, transaction): DCNL ':param transaction: The transaction to add to the database DCNL :type transaction: Transaction'
def update(self, transaction): DCNL ':param transaction: The transaction to update DCNL :type transaction: Transaction'
def delete_by_id(self, transaction_id): DCNL ':param transaction_id: The id of the transaction to remove'
def next_identity(self): DCNL ':rtype: TransactionId'
def __init__(self, timeout): DCNL ':param timeout: Float representation of a timeout DCNL :type timeout: float DCNL :raises ValueError: Thrown when one of the arguments are invalid'
def is_timed_out(self, timestamp): DCNL 'Return if a timeout has occurred DCNL :param timestamp: A timestamp DCNL :type timestamp: Timestamp DCNL :return: True if timeout has occurred, False otherwise DCNL :rtype: bool'
def __init__(self, quantity, wallet_id): DCNL ':param quantity: float representation of a quantity that is positive or zero DCNL :param wallet_id: Identifier of the wallet type of this price DCNL :type quantity: float DCNL :type wallet_id: str DCNL :raises ValueError: Thrown when one of the arguments are invalid'
@property DCNL def wallet_id(self): DCNL ':rtype: str'
@property DCNL def int_wallet_id(self): DCNL ':rtype: int'
@classmethod DCNL def from_database(cls, data): DCNL 'Create a Payment object based on information in the database.'
def to_database(self): DCNL 'Returns a database representation of a Payment object. DCNL :rtype: tuple'
@classmethod DCNL def from_network(cls, data): DCNL 'Restore a payment from the network DCNL :param data: PaymentPayload DCNL :return: Restored payment DCNL :rtype: Payment'
def to_network(self): DCNL 'Return network representation of the multi chain payment'
def insert_ask(self, ask): DCNL ':type ask: Ask'
def remove_ask(self, order_id): DCNL ':type order_id: OrderId'
def insert_bid(self, bid): DCNL ':type bid: Bid'
def remove_bid(self, order_id): DCNL ':type order_id: OrderId'
def trade_tick(self, order_id, recipient_order_id, quantity, end_transaction_timestamp): DCNL ':type order_id: OrderId DCNL :type recipient_order_id: OrderId DCNL :type quantity: Quantity DCNL :type end_transaction_timestamp: Timestamp'
def tick_exists(self, order_id): DCNL ':param order_id: The order id to search for DCNL :type order_id: OrderId DCNL :return: True if the tick exists, False otherwise DCNL :rtype: bool'
def get_ask(self, order_id): DCNL ':param order_id: The order id to search for DCNL :type order_id: OrderId DCNL :rtype: TickEntry'
def get_bid(self, order_id): DCNL ':param order_id: The order id to search for DCNL :type order_id: OrderId DCNL :rtype: TickEntry'
def get_tick(self, order_id): DCNL 'Return a tick with the specified order id. DCNL :param order_id: The order id to search for DCNL :type order_id: OrderId DCNL :rtype: TickEntry'
def ask_exists(self, order_id): DCNL ':param order_id: The order id to search for DCNL :type order_id: OrderId DCNL :return: True if the ask exists, False otherwise DCNL :rtype: bool'
def bid_exists(self, order_id): DCNL ':param order_id: The order id to search for DCNL :type order_id: OrderId DCNL :return: True if the bid exists, False otherwise DCNL :rtype: bool'
def remove_tick(self, order_id): DCNL ':type order_id: OrderId'
@property DCNL def asks(self): DCNL 'Return the asks side DCNL :rtype: Side'
@property DCNL def bids(self): DCNL 'Return the bids side DCNL :rtype: Side'
def get_bid_price(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the price an ask needs to have to make a trade DCNL :rtype: Price'
def get_ask_price(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the price a bid needs to have to make a trade DCNL :rtype: Price'
def get_bid_ask_spread(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the spread between the bid and the ask price DCNL :rtype: Price'
def get_mid_price(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the price in between the bid and the ask price DCNL :rtype: Price'
def bid_side_depth(self, price): DCNL 'Return the depth of the price level with the given price on the bid side DCNL :param price: The price for the price level DCNL :type price: Price DCNL :return: The depth at that price level DCNL :rtype: Quantity'
def ask_side_depth(self, price): DCNL 'Return the depth of the price level with the given price on the ask side DCNL :param price: The price for the price level DCNL :type price: Price DCNL :return: The depth at that price level DCNL :rtype: Quantity'
def get_bid_side_depth_profile(self, price_wallet_id, quantity_wallet_id): DCNL 'format: [(<price>, <depth>), (<price>, <depth>), ...] DCNL :return: The depth profile DCNL :rtype: list'
def get_ask_side_depth_profile(self, price_wallet_id, quantity_wallet_id): DCNL 'format: [(<price>, <depth>), (<price>, <depth>), ...] DCNL :return: The depth profile DCNL :rtype: list'
def bid_relative_price(self, price): DCNL ':param price: The price to be relative to DCNL :type price: Price DCNL :return: The relative price DCNL :rtype: Price'
def ask_relative_price(self, price): DCNL ':param price: The price to be relative to DCNL :type price: Price DCNL :return: The relative price DCNL :rtype: Price'
def relative_tick_price(self, tick): DCNL ':param tick: The tick with the price to be relative to DCNL :type tick: Tick DCNL :return: The relative price DCNL :rtype: Price'
def get_bid_price_level(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the price level that an ask has to match to make a trade DCNL :rtype: PriceLevel'
def get_ask_price_level(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the price level that a bid has to match to make a trade DCNL :rtype: PriceLevel'
def get_order_ids(self): DCNL 'Return all IDs of the orders in the orderbook, both asks and bids. The returned list is sorted. DCNL :rtype: [OrderId]'
def save_to_database(self): DCNL 'Write all ticks to the database'
def restore_from_database(self): DCNL 'Restore ticks from the database'
def __init__(self, ttl): DCNL ':param ttl: Integer representation of a time to live DCNL :type ttl: int DCNL :raises ValueError: Thrown when one of the arguments are invalid'
@classmethod DCNL def default(cls): DCNL 'Create a time to live with the default value DCNL :return: The ttl DCNL :rtype: Ttl'
def is_alive(self): DCNL 'Check if the ttl is still hig enough to be send on DCNL :return: True if it is alive, False otherwise DCNL :rtype: bool'
def make_hop(self): DCNL 'Makes a hop by reducing the ttl by 1, to simulate the message being relayed through a node'
@property DCNL def first_tick(self): DCNL ':rtype: TickEntry'
@property DCNL def length(self): DCNL 'Return the length of the amount of ticks contained in the price level DCNL :rtype: integer'
@property DCNL def depth(self): DCNL 'The depth is equal to the total amount of volume contained in this price level DCNL :rtype: Quantity'
@depth.setter DCNL def depth(self, new_depth): DCNL ':param new_depth: The new depth DCNL :type new_depth: Quantity'
def __len__(self): DCNL 'Return the length of the amount of ticks contained in the price level'
def next(self): DCNL 'Return the next tick in the price level for the iterator'
def append_tick(self, tick): DCNL ':type tick: TickEntry'
def remove_tick(self, tick): DCNL ':type tick: TickEntry'
def __init__(self, transaction_repository): DCNL ':type transaction_repository: TransactionRepository'
def create_from_proposed_trade(self, proposed_trade): DCNL ':type proposed_trade: ProposedTrade DCNL :rtype: Transaction'
def create_from_start_transaction(self, start_transaction): DCNL ':type start_transaction: StartTransaction DCNL :rtype: Transaction'
def find_by_id(self, transaction_id): DCNL ':param transaction_id: The transaction id to look for DCNL :type transaction_id: TransactionId DCNL :return: The transaction or null if it cannot be found DCNL :rtype: Transaction'
def find_all(self): DCNL ':rtype: [Transaction]'
def __init__(self, transaction_number): DCNL ':type transaction_number: int DCNL :raises ValueError: Thrown when one of the arguments are invalid'
def __init__(self, trader_id, transaction_number): DCNL ':param trader_id: The trader id who created the order DCNL :param transaction_number: The number of the transaction created DCNL :type trader_id: TraderId DCNL :type transaction_number: TransactionNumber'
@property DCNL def trader_id(self): DCNL ':rtype: TraderId'
@property DCNL def transaction_number(self): DCNL ':rtype: TransactionNumber'
def __str__(self): DCNL 'format: <trader_id>.<transaction_number>'
def __init__(self, transaction_id, price, quantity, order_id, partner_order_id, timestamp): DCNL ':param transaction_id: An transaction id to identify the order DCNL :param price: A price to indicate for which amount to sell or buy DCNL :param quantity: A quantity to indicate how much to sell or buy DCNL :param order_id: The id of your order for this transaction DCNL :param partner_order_id: The id of the order of the other party DCNL :param timestamp: A timestamp when the transaction was created DCNL :type transaction_id: TransactionId DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type order_id: OrderId DCNL :type partner_order_id: OrderId DCNL :type timestamp: Timestamp'
@classmethod DCNL def from_database(cls, data, payments): DCNL 'Create a Transaction object based on information in the database.'
def to_database(self): DCNL 'Returns a database representation of a Transaction object. DCNL :rtype: tuple'
@classmethod DCNL def from_proposed_trade(cls, proposed_trade, transaction_id): DCNL ':param proposed_trade: The proposed trade to create the transaction for DCNL :param transaction_id: The transaction id to use for this transaction DCNL :type proposed_trade: ProposedTrade DCNL :type transaction_id: TransactionId DCNL :return: The created transaction DCNL :rtype: Transaction'
@property DCNL def transaction_id(self): DCNL ':rtype: TransactionId'
@property DCNL def price(self): DCNL ':rtype: Price'
@property DCNL def total_price(self): DCNL ':rtype: Price'
@property DCNL def transferred_price(self): DCNL ':rtype: Price'
@property DCNL def total_quantity(self): DCNL ':rtype: Quantity'
@property DCNL def transferred_quantity(self): DCNL ':rtype: Quantity'
@property DCNL def order_id(self): DCNL 'Return the id of your order DCNL :rtype: OrderId'
@property DCNL def partner_order_id(self): DCNL ':rtype: OrderId'
@property DCNL def payments(self): DCNL ':rtype: [Payment]'
@property DCNL def timestamp(self): DCNL ':rtype: Timestamp'
@property DCNL def status(self): DCNL 'Return the status of this transaction, can be one of these: "pending", "completed", "error". DCNL :rtype: str'
@staticmethod DCNL def unitize(amount, min_unit): DCNL 'Return an a amount that is a multiple of min_unit.'
def to_dictionary(self): DCNL 'Return a dictionary with a representation of this transaction.'
def __init__(self, message_id, transaction_id, order_id, recipient_order_id, proposal_id, price, quantity, timestamp): DCNL ':param message_id: A message id to identify the message DCNL :param transaction_id: A transaction id to identify the transaction DCNL :param order_id: My order id DCNL :param recipient_order_id: The order id of the recipient of this message DCNL :param proposal_id: The proposal ID associated with this start transaction message DCNL :param price: A price for the trade DCNL :param quantity: A quantity to be traded DCNL :param timestamp: A timestamp when the transaction was created DCNL :type message_id: MessageId DCNL :type transaction_id: TransactionId DCNL :type proposal_id: int DCNL :type order_id: OrderId DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type timestamp: Timestamp'
@property DCNL def transaction_id(self): DCNL ':rtype: TransactionId'
@property DCNL def order_id(self): DCNL ':rtype: OrderId'
@property DCNL def recipient_order_id(self): DCNL ':rtype: OrderId'
@property DCNL def proposal_id(self): DCNL ':return: The proposal id DCNL :rtype: int'
@property DCNL def price(self): DCNL ':return: The price DCNL :rtype: Price'
@property DCNL def quantity(self): DCNL ':return: The quantity DCNL :rtype: Quantity'
@classmethod DCNL def from_network(cls, data): DCNL 'Restore a start transaction message from the network DCNL :param data: StartTransactionPayload DCNL :return: Restored start transaction DCNL :rtype: StartTransaction'
def to_network(self): DCNL 'Return network representation of the start transaction message'
def __init__(self, message_id, order_id, recipient_order_id, proposal_id, timestamp): DCNL 'Don\'t use this method directly, use one of the class methods. DCNL :param message_id: A message id to identify the trade DCNL :param order_id: A order id to identify the order DCNL :param recipient_order_id: A order id to identify the traded party DCNL :param proposal_id: The ID of the trade proposal DCNL :param timestamp: A timestamp wen this trade was created DCNL :type message_id: MessageId DCNL :type order_id: OrderId DCNL :type recipient_order_id: OrderId DCNL :type proposal_id: int DCNL :type timestamp: Timestamp'
@classmethod DCNL def propose(cls, message_id, order_id, recipient_order_id, price, quantity, timestamp): DCNL 'Propose a trade to another node DCNL :param message_id: A message id to identify the trade DCNL :param order_id: A order id to identify the order DCNL :param recipient_order_id: A order id to identify the traded party DCNL :param price: A price for the trade DCNL :param quantity: A quantity to be traded DCNL :param timestamp: A timestamp wen this trade was created DCNL :type message_id: MessageId DCNL :type order_id: OrderId DCNL :type recipient_order_id: OrderId DCNL :type timestamp: Timestamp DCNL :return: A proposed trade DCNL :rtype: ProposedTrade'
@classmethod DCNL def decline(cls, message_id, timestamp, proposed_trade): DCNL 'Decline a trade from another node DCNL :param message_id: A message id to identify the trade DCNL :param timestamp: A timestamp when the trade was declined DCNL :param proposed_trade: A proposed trade that needs to be declined DCNL :type message_id: MessageId DCNL :type timestamp: Timestamp DCNL :type proposed_trade: ProposedTrade DCNL :return: A declined trade DCNL :rtype: DeclinedTrade'
@classmethod DCNL def counter(cls, message_id, quantity, timestamp, proposed_trade): DCNL 'Counter a trade from another node DCNL :param message_id: A message id to identify the trade DCNL :param quantity: The quantity to use for the counter offer DCNL :param timestamp: A timestamp when the trade was countered DCNL :param proposed_trade: A proposed trade that needs to be countered DCNL :type message_id: MessageId DCNL :type quantity: Quantity DCNL :type timestamp: Timestamp DCNL :type proposed_trade: ProposedTrade DCNL :return: A counter trade DCNL :rtype: CounterTrade'
@property DCNL def order_id(self): DCNL ':return: The order id DCNL :rtype: OrderId'
@property DCNL def recipient_order_id(self): DCNL ':return: The order id DCNL :rtype: OrderId'
@property DCNL def proposal_id(self): DCNL ':return: The proposal id DCNL :rtype: int'
def __init__(self, message_id, order_id, recipient_order_id, proposal_id, price, quantity, timestamp): DCNL 'Don\'t use this method directly, use the class methods from Trade or use the from_network DCNL :param message_id: A message id to identify the trade DCNL :param order_id: A order id to identify the order DCNL :param recipient_order_id: A order id to identify the traded party DCNL :param proposal_id: The ID of the trade proposal DCNL :param price: A price for the trade DCNL :param quantity: A quantity to be traded DCNL :param timestamp: A timestamp wen this trade was created DCNL :type message_id: MessageId DCNL :type order_id: OrderId DCNL :type recipient_order_id: OrderId DCNL :type proposal_id: int DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type timestamp: Timestamp'
@classmethod DCNL def from_network(cls, data): DCNL 'Restore a proposed trade from the network DCNL :param data: TradePayload DCNL :return: Restored proposed trade DCNL :rtype: ProposedTrade'
@property DCNL def price(self): DCNL ':return: The price DCNL :rtype: Price'
@property DCNL def quantity(self): DCNL ':return: The quantity DCNL :rtype: Quantity'
def has_acceptable_price(self, is_ask, order_price): DCNL 'Return whether this trade proposal has an acceptable price. DCNL :rtype: bool'
def to_network(self): DCNL 'Return network representation of a proposed trade'
def __init__(self, message_id, order_id, recipient_order_id, proposal_id, price, quantity, timestamp): DCNL 'Don\'t use this method directly, use one of the class methods of Trade or use from_network DCNL :param message_id: A message id to identify the trade DCNL :param order_id: A order id to identify the order DCNL :param recipient_order_id: A order id to identify the traded party DCNL :param proposal_id: The ID of the trade proposal DCNL :param price: A price for the trade DCNL :param quantity: A quantity to be traded DCNL :param timestamp: A timestamp wen this trade was created DCNL :type message_id: MessageId DCNL :type order_id: OrderId DCNL :type recipient_order_id: OrderId DCNL :type proposal_id: int DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type timestamp: Timestamp'
@classmethod DCNL def from_network(cls, data): DCNL 'Restore a counter trade from the network DCNL :param data: TradePayload DCNL :return: Restored counter trade DCNL :rtype: CounterTrade'
def to_network(self): DCNL 'Return network representation of a counter trade'
def __init__(self, message_id, order_id, recipient_order_id, proposal_id, timestamp): DCNL 'Don\'t use this method directly, use one of the class methods from Trade or the from_network DCNL :param message_id: A message id to identify the trade DCNL :param order_id: A order id to identify the order DCNL :param recipient_order_id: A order id to identify the order DCNL :param proposal_id: The ID of the trade proposal DCNL :param timestamp: A timestamp wen this trade was created DCNL :type message_id: MessageId DCNL :type order_id: OrderId DCNL :type recipient_order_id: OrderId DCNL :type proposal_id: int DCNL :type timestamp: Timestamp'
@classmethod DCNL def from_network(cls, data): DCNL 'Restore a declined trade from the network DCNL :param data: DeclinedTradePayload DCNL :return: Restored declined trade DCNL :rtype: DeclinedTrade'
def to_network(self): DCNL 'Return network representation of a declined trade'
def __init__(self, ip, port): DCNL ':param ip: String representation of an ipv4 address DCNL :type ip: str DCNL :param port: Integer representation of a port DCNL :type port: int DCNL :raises ValueError: Thrown when one of the arguments are invalid'
@property DCNL def ip(self): DCNL ':return: The ip DCNL :rtype: str'
@property DCNL def port(self): DCNL ':return: The port DCNL :rtype: int'
def __init__(self, price, wallet_id): DCNL ':param price: Integer representation of a price that is positive or zero DCNL :param wallet_id: Identifier of the wallet type of this price DCNL :type price: float DCNL :type wallet_id: str DCNL :raises ValueError: Thrown when one of the arguments are invalid'
@property DCNL def wallet_id(self): DCNL ':rtype: str'
@property DCNL def int_wallet_id(self): DCNL ':rtype: int'
def __init__(self, timestamp): DCNL ':param timestamp: Float representation of a timestamp DCNL :type timestamp: float DCNL :raises ValueError: Thrown when one of the arguments are invalid'
@classmethod DCNL def now(cls): DCNL 'Create a timestamp with the time set to the current time DCNL :return: A timestamp DCNL :rtype: Timestamp'
def __len__(self): DCNL 'Return the length of the amount of ticks contained in all the price level of this side'
def get_price_level(self, price): DCNL 'Return the price level corresponding to the given price DCNL :param price: The price for which the price level needs to be returned DCNL :type price: Price DCNL :return: The price level DCNL :rtype: PriceLevel'
def get_tick(self, order_id): DCNL ':param order_id: The order id of the tick DCNL :type order_id: OrderId DCNL :return: The tick DCNL :rtype: TickEntry'
def _create_price_level(self, price, quantity_wallet_id): DCNL ':param price: The price to create the level for DCNL :param quantity_wallet_id: the id of the quantities stored in this price level DCNL :type price: Price DCNL :type quantity_wallet_id: str'
def _remove_price_level(self, price, quantity_wallet_id): DCNL ':param price: The price to remove the level for DCNL :param quantity_wallet_id: the id of the quantities stored in this price level DCNL :type price: Price DCNL :type quantity_wallet_id: str'
def _price_level_exists(self, price): DCNL ':param price: The price to check for DCNL :type price: Price DCNL :return: True if the price level exists, False otherwise DCNL :rtype: bool'
def tick_exists(self, order_id): DCNL ':param order_id: The order id to search for DCNL :type order_id: OrderId DCNL :return: True if the tick exists, False otherwise DCNL :rtype: bool'
def insert_tick(self, tick): DCNL ':param tick: The tick to insert DCNL :type tick: Tick'
def remove_tick(self, order_id): DCNL ':param order_id: The order id of the tick that needs to be removed DCNL :type order_id: OrderId'
def get_price_level_list(self, price_wallet_id, quantity_wallet_id): DCNL ':return: PriceLevelList'
def get_price_level_list_wallets(self): DCNL 'Returns the combinations (price wallet id, quantity wallet id) available in the side.'
def get_max_price(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the maximum price that a tick is listed for on this side of the order book DCNL :rtype: Price'
def get_min_price(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the minimum price that a tick is listed for on this side of the order book DCNL :rtype: Price'
def get_max_price_list(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the price level for the maximum price DCNL :rtype: PriceLevel'
def get_min_price_list(self, price_wallet_id, quantity_wallet_id): DCNL 'Return the price level for the minimum price DCNL :rtype: PriceLevel'
def get_list_representation(self): DCNL 'Return a list describing all ticks in this side. DCNL :rtype: list'
def __init__(self, order_repository): DCNL ':type order_repository: OrderRepository'
def create_ask_order(self, price, quantity, timeout): DCNL 'Create an ask order (sell order) DCNL :param price: The price for the order DCNL :param quantity: The quantity of the order DCNL :param timeout: The timeout of the order, when does the order need to be timed out DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type timeout: Timeout DCNL :return: The order that is created DCNL :rtype: Order'
def create_bid_order(self, price, quantity, timeout): DCNL 'Create a bid order (buy order) DCNL :param price: The price for the order DCNL :param quantity: The quantity of the order DCNL :param timeout: The timeout of the order, when does the order need to be timed out DCNL :type price: Price DCNL :type quantity: Quantity DCNL :type timeout: Timeout DCNL :return: The order that is created DCNL :rtype: Order'
def cancel_order(self, order_id): DCNL 'Cancel an order that was created by the user. DCNL :return: The order that is created DCNL :rtype: Order'
def __init__(self, trader_id): DCNL ':param trader_id: String representing the trader id DCNL :type trader_id: str DCNL :raises ValueError: Thrown when one of the arguments are invalid'
def __init__(self, message_number): DCNL ':param message_number: String representing the number of a message DCNL :type message_number: str DCNL :raises ValueError: Thrown when one of the arguments are invalid'
def __init__(self, trader_id, message_number): DCNL ':param trader_id: The trader id who created the message DCNL :param message_number: The number of the message created DCNL :type trader_id: TraderId DCNL :type message_number: MessageNumber'
@property DCNL def trader_id(self): DCNL ':rtype: TraderId'
@property DCNL def message_number(self): DCNL ':rtype: MessageNumber'
def __str__(self): DCNL 'format: <trader_id>.<message_number> DCNL :rtype: str'
def __init__(self, message_id, timestamp): DCNL 'Don\'t use this class directly, use on of its implementations DCNL :param message_id: A message id to identify the message DCNL :param timestamp: A timestamp when the message was created DCNL :type message_id: MessageId DCNL :type timestamp: Timestamp'
@property DCNL def message_id(self): DCNL ':rtype: MessageId'
@property DCNL def timestamp(self): DCNL ':rtype: Timestamp'
def __init__(self, wallet_address): DCNL ':param wallet_address: String representation of a wallet address DCNL :type wallet_address: str DCNL :raises ValueError: Thrown when one of the arguments are invalid'
def __init__(self): DCNL 'Do not use this class directly DCNL Make a subclass of this class with a specific implementation for a storage backend'
def __init__(self, mid): DCNL ':param mid: Hex encoded version of the member id of this node DCNL :type mid: str'
def find_all(self): DCNL ':rtype: [Order]'
def find_by_id(self, order_id): DCNL ':param order_id: The order id to look for DCNL :type order_id: OrderId DCNL :return: The order or null if it cannot be found DCNL :rtype: Order'
def add(self, order): DCNL ':type order: Order'
def update(self, order): DCNL ':type order: Order'
def delete_by_id(self, order_id): DCNL ':type order_id: OrderId'
def next_identity(self): DCNL ':rtype: OrderId'
def __init__(self, mid, persistence): DCNL ':param mid: Hex encoded version of the member id of this node DCNL :type mid: str'
def find_all(self): DCNL ':rtype: [Order]'
def find_by_id(self, order_id): DCNL ':param order_id: The order id to look for DCNL :type order_id: OrderId DCNL :return: The order or null if it cannot be found DCNL :rtype: Order'
def add(self, order): DCNL ':param order: The order to add to the database DCNL :type order: Order'
def update(self, order): DCNL ':param order: The order to update DCNL :type order: Order'
def delete_by_id(self, order_id): DCNL ':param order_id: The id of the order to remove'
def next_identity(self): DCNL ':rtype OrderId'
def __init__(self, tick, price_level): DCNL ':param tick: A tick to represent in the order book DCNL :param price_level: A price level to place the tick in DCNL :type tick: Tick DCNL :type price_level: PriceLevel'
@property DCNL def tick(self): DCNL ':rtype: Tick'
@property DCNL def order_id(self): DCNL ':rtype: OrderId'
@property DCNL def price(self): DCNL ':rtype: Price'
@property DCNL def quantity(self): DCNL ':rtype: Quantity'
@quantity.setter DCNL def quantity(self, new_quantity): DCNL ':param new_quantity: The new quantity DCNL :type new_quantity: Quantity'
def is_valid(self): DCNL 'Return if the tick is still valid DCNL :return: True if valid, False otherwise DCNL :rtype: bool'
def price_level(self): DCNL ':return: The price level the tick was placed in DCNL :rtype: PriceLevel'
@property DCNL def prev_tick(self): DCNL ':rtype: TickEntry'
@prev_tick.setter DCNL def prev_tick(self, new_prev_tick): DCNL ':param new_prev_tick: The new previous tick DCNL :type new_prev_tick: TickEntry'
@property DCNL def next_tick(self): DCNL ':rtype: TickEntry'
@next_tick.setter DCNL def next_tick(self, new_next_tick): DCNL ':param new_next_tick: The new previous tick DCNL :type new_next_tick: TickEntry'
def __str__(self): DCNL 'format: <quantity>      @       <price> DCNL :rtype: str'
def insert(self, price, price_level): DCNL ':type price: Price DCNL :type price_level: PriceLevel'
def remove(self, price): DCNL ':type price: Price'
def succ_item(self, price): DCNL 'Returns (price, price_level) pair where price is successor to given price DCNL :type price: Price DCNL :rtype: (Price, PriceLevel)'
def prev_item(self, price): DCNL 'Returns (price, price_level) pair where price is predecessor to given price DCNL :type price: Price DCNL :rtype: (Price, PriceLevel)'
def min_key(self): DCNL 'Return the lowest price in the price level list DCNL :rtype: Price'
def max_key(self): DCNL 'Return the highest price in the price level list DCNL :rtype: Price'
def items(self, reverse=False): DCNL 'Returns a sorted list of price, price_level tuples DCNL :param reverse: When true returns the reversed sorted list of price, price_level tuples DCNL :type reverse: bool DCNL :rtype: List[(Price, PriceLevel)]'
def get_ticks_list(self): DCNL 'Returns a list describing all ticks. DCNL :return: list'
def __init__(self, mid): DCNL ':param mid: Hex encoded version of the member id of this node DCNL :type mid: str'
def next_identity(self): DCNL ':rtype: MessageId'
def __init__(self, working_directory): DCNL 'Sets up the persistence layer ready for use. DCNL :param working_directory: Path to the working directory DCNL that will contain the the db at working directory/DATABASE_PATH DCNL :return:'
def get_all_orders(self): DCNL 'Return all orders in the database.'
def get_order(self, order_id): DCNL 'Return an order with a specific id.'
def add_order(self, order): DCNL 'Add a specific order to the database'
def delete_order(self, order_id): DCNL 'Delete a specific order from the database'
def get_next_order_number(self): DCNL 'Return the next order number from the database'
def delete_reserved_ticks(self, order_id): DCNL 'Delete all reserved ticks from a specific order'
def add_reserved_tick(self, order_id, reserved_order_id, quantity): DCNL 'Add a reserved tick to the database'
def get_reserved_ticks(self, order_id): DCNL 'Get all reserved ticks for a specific order.'
def get_all_transactions(self): DCNL 'Return all transactions in the database.'
def get_transaction(self, transaction_id): DCNL 'Return a transaction with a specific id.'
def add_transaction(self, transaction): DCNL 'Add a specific transaction to the database'
def delete_transaction(self, transaction_id): DCNL 'Delete a specific transaction from the database'
def get_next_transaction_number(self): DCNL 'Return the next transaction number from the database'
def add_payment(self, payment): DCNL 'Add a specific transaction to the database'
def get_payments(self, transaction_id): DCNL 'Return all payment tied to a specific transaction.'
def delete_payments(self, transaction_id): DCNL 'Delete all payments that are associated with a specific transaction'
def add_tick(self, tick): DCNL 'Add a specific tick to the database'
def delete_all_ticks(self): DCNL 'Remove all ticks from the database.'
def get_ticks(self): DCNL 'Get all ticks present in the database.'
def check_database(self, database_version): DCNL 'Ensure the proper schema is used by the database. DCNL :param database_version: Current version of the database. DCNL :return:'
def get_wallet_ids(self): DCNL 'Return the IDs of all wallets in the market community.'
def get_dispersy_address(self): DCNL 'Returns the address of the Dispersy instance. This method is here to make the experiments on the DAS5 succeed; DCNL direct messaging is not possible there with a wan address so we are using the local address instead.'
def get_wallet_address(self, wallet_id): DCNL 'Returns the address of the wallet with a specific identifier. Raises a ValueError if that wallet is not DCNL available.'
def get_order_addresses(self, order): DCNL 'Return a tuple of incoming and outgoing payment address of an order.'
def match(self, order): DCNL 'Try to find a match for a specific order and send proposed trade messages if there is a match DCNL :param order: The order to match'
def lookup_ip(self, trader_id): DCNL 'Lookup the ip for the public key to send a message to a specific node DCNL :param trader_id: The public key of the node to send to DCNL :type trader_id: TraderId DCNL :return: The ip and port tuple: (<ip>, <port>) DCNL :rtype: tuple'
def update_ip(self, trader_id, ip): DCNL 'Update the public key to ip mapping DCNL :param trader_id: The public key of the node DCNL :param ip: The ip and port of the node DCNL :type trader_id: TraderId DCNL :type ip: tuple'
def create_ask(self, price, price_wallet_id, quantity, quantity_wallet_id, timeout): DCNL 'Create an ask order (sell order) DCNL :param price: The price for the order in btc DCNL :param price_wallet_id: The type of the price (i.e. EUR, BTC) DCNL :param quantity: The quantity of the order DCNL :param price_wallet_id: The type of the price (i.e. EUR, BTC) DCNL :param timeout: The timeout of the order, when does the order need to be timed out DCNL :type price: float DCNL :type price_wallet_id: str DCNL :type quantity: float DCNL :type quantity_wallet_id: str DCNL :type timeout: float DCNL :return: The created order DCNL :rtype: Order'
def send_tick(self, tick): DCNL 'Send a tick message DCNL :param tick: The message to send DCNL :type tick: Tick'
def create_bid(self, price, price_wallet_id, quantity, quantity_wallet_id, timeout): DCNL 'Create an ask order (sell order) DCNL :param price: The price for the order in btc DCNL :param price_wallet_id: The type of the price (i.e. EUR, BTC) DCNL :param quantity: The quantity of the order DCNL :param price_wallet_id: The type of the price (i.e. EUR, BTC) DCNL :param timeout: The timeout of the order, when does the order need to be timed out DCNL :type price: float DCNL :type price_wallet_id: str DCNL :type quantity: float DCNL :type quantity_wallet_id: str DCNL :type timeout: float DCNL :return: The created order DCNL :rtype: Order'
def send_cancel_order(self, order): DCNL 'Send a cancel-order message to the community'
def send_offer_sync(self, target_candidate, tick): DCNL 'Send an offer sync message DCNL :param target_candidate: The candidate to send this message to DCNL :type: target_candidate: WalkCandidate DCNL :param tick: The tick to send DCNL :type tick: Tick'
def update_ticks(self, transaction, end_transaction_timestamp): DCNL 'Update your tick in the order book according to a specific transaction. DCNL Afterwards, send the updated tick.'
def abort_transaction(self, transaction): DCNL 'Abort a specific transaction by releasing all reserved quantity for this order.'
def compute_reputation(self): DCNL 'Compute the reputation of peers in the community'
def monitor_transaction(self, payment_id): DCNL 'Monitor an incoming transaction with a specific id.'
def monitor_transaction(self, transaction_id): DCNL 'Monitor an incoming transaction with a specific ID.'
def generate_txid(self, length=10): DCNL 'Generate a random transaction ID'
def get_daemon(self): DCNL 'Return the daemon that can be used to send JSON RPC commands to. This method is here so we can unit test DCNL this class.'
def create_wallet(self, password=''): DCNL 'Create a new bitcoin wallet.'
def get_balance(self): DCNL 'Return the balance of the wallet.'
def monitor_transaction(self, txid): DCNL 'Monitor a given transaction ID. Returns a Deferred that fires when the transaction is present.'
def compute(self, own_public_key): DCNL 'Compute the reputation based on the data in the TradeChain database.'
def compute(self, own_public_key): DCNL 'Compute the reputation based on the data in the TradeChain database using the PageRank algorithm.'
def get_all_blocks(self): DCNL 'Return all blocks in the database.'
def get_upgrade_script(self, current_version): DCNL 'Return the upgrade script for a specific version. DCNL :param current_version: the version of the script to return.'
def should_sign(self, message): DCNL 'Only sign the block if we have a (completed) transaction in the market community with the specific txid.'
def __init__(self, circuit_id, goal_hops=0, first_hop=None, proxy=None, ctype=CIRCUIT_TYPE_DATA, callback=None, required_exit=None, mid=None, info_hash=None): DCNL 'Instantiate a new Circuit data structure DCNL :type proxy: TunnelCommunity DCNL :param long circuit_id: the id of the candidate circuit DCNL :param (str, int) first_hop: the first hop of the circuit DCNL :return: Circuit'
@property DCNL def hops(self): DCNL 'Return a read only tuple version of the hop-list of this circuit DCNL @rtype tuple[Hop]'
def add_hop(self, hop): DCNL 'Adds a hop to the circuits hop collection DCNL @param Hop hop: the hop to add'
@property DCNL def state(self): DCNL 'The circuit state, can be either: DCNL CIRCUIT_STATE_BROKEN, CIRCUIT_STATE_EXTENDING or CIRCUIT_STATE_READY DCNL @rtype: str'
def beat_heart(self): DCNL 'Mark the circuit as active'
def tunnel_data(self, destination, payload): DCNL 'Convenience method to tunnel data over this circuit DCNL @param (str, int) destination: the destination of the packet DCNL @param str payload: the packet\'s payload'
def destroy(self, reason='unknown'): DCNL 'Destroys the circuit and calls the error callback of the circuit\'s DCNL deferred if it has not been called before DCNL @param str reason: the reason why the circuit is being destroyed'
def __init__(self, public_key=None): DCNL '@param None|LibNaCLPK public_key: public key object of the hop'
@property DCNL def host(self): DCNL 'The hop\'s hostname'
@property DCNL def port(self): DCNL 'The hop\'s port'
@property DCNL def node_id(self): DCNL 'The hop\'s nodeid'
@property DCNL def node_public_key(self): DCNL 'The hop\'s public_key'
def __init__(self, circuit_id, sock_addr, rendezvous_relay=False, mid=None): DCNL '@type sock_addr: (str, int) DCNL @type circuit_id: int DCNL @return:'
@property DCNL def destination(self): DCNL 'The destination address as a tuple DCNL @rtype: (str, int)'
@property DCNL def destination(self): DCNL 'The destination address as a tuple DCNL @rtype: (str, int)'
def _try_handshake(self): DCNL 'Try to read a HANDSHAKE request DCNL :return: False if command could not been processes due to lack of bytes, True otherwise'
def _try_request(self): DCNL 'Try to consume a REQUEST message and respond whether we will accept the DCNL request. DCNL Will setup a TCP relay or an UDP socket to accommodate TCP RELAY and DCNL UDP ASSOCIATE requests. After a TCP relay is set up the handler will DCNL deactivate itself and change the Connection to a TcpRelayConnection. DCNL Further data will be passed on to that handler. DCNL :return: False if command could not been processes due to lack of bytes, True otherwise'
def deny_request(self, request, reason): DCNL 'Deny SOCKS5 request DCNL @param Request request: the request to deny'
def circuit_dead(self, broken_circuit): DCNL 'When a circuit breaks and it affects our operation we should re-add the DCNL peers when a new circuit is available DCNL @param Circuit broken_circuit: the circuit that has been broken DCNL @return Set with destinations using this circuit'
@inlineCallbacks DCNL def close(self): DCNL 'Closes the UDP socket if enabled and cancels all pending deferreds. DCNL :return: A deferred that fires once the UDP socket has closed.'
def on_download_removed(self, download): DCNL 'This method is called when a download is removed. We check here whether we can stop building circuits for a DCNL specific number of hops in case it hasn\'t been finished yet.'
def copy_shallow_candidate(self, tunnel, sock_addr): DCNL 'Create an unmanaged Candidate for a tunnel mechanism with a certain address DCNL This avoids candidates being disassociated while they are being used in notifications. DCNL :param tunnel: the tunnel object being used DCNL :type tunnel: Circuit or RelayRoute or TunnelExitSocket DCNL :param sock_addr: the socket address of the candidate DCNL :type sock_addr: tuple DCNL :return: the immutable Candidate object DCNL :rtype: Candidate'
def get_num_unique_interactors(self, public_key): DCNL 'Returns the number of people you interacted with (either helped or that have helped you) DCNL :param public_key: The public key of the member of which we want the information DCNL :return: A tuple of unique number of interactors that helped you and that you have helped respectively'
def get_upgrade_script(self, current_version): DCNL 'Return the upgrade script for a specific version. DCNL :param current_version: the version of the script to return.'
@classmethod DCNL def create(cls, transaction, database, public_key, link=None, link_pk=None): DCNL 'Create an empty next block. DCNL :param database: the database to use as information source DCNL :param transaction: the transaction to use in this block DCNL :param public_key: the public key to use for this block DCNL :param link: optionally create the block as a linked block to this block DCNL :param link_pk: the public key of the counterparty in this transaction DCNL :return: A newly created block'
def validate_transaction(self, database): DCNL 'Validates this transaction DCNL :param transaction the transaction to validate DCNL :param database: the database to check against DCNL :return: A tuple consisting of a ValidationResult and a list of user string errors'
def received_payment_message(self, payment_id): DCNL 'We received a payment message originating from the market community. We set pending bytes so the validator DCNL passes when we receive the half block from the counterparty. DCNL Note that it might also be possible that the half block has been received already. That\'s why we revalidate DCNL the invalid messages again.'
def should_sign(self, message): DCNL 'Return whether we should sign the block in the passed message. DCNL @param message: the message containing a block we want to sign or not.'
@blocking_call_on_reactor_thread DCNL def get_statistics(self, public_key=None): DCNL 'Returns a dictionary with some statistics regarding the local trustchain database DCNL :returns a dictionary with statistics'
@blocking_call_on_reactor_thread DCNL def on_tunnel_remove(self, subject, change_type, tunnel, candidate): DCNL 'Handler for the remove event of a tunnel. This function will attempt to create a block for the amounts that DCNL were transferred using the tunnel. DCNL :param subject: Category of the notifier event DCNL :param change_type: Type of the notifier event DCNL :param tunnel: The tunnel that was removed (closed) DCNL :param candidate: The dispersy candidate with whom this node has interacted in the tunnel'
def get_trust(self, member): DCNL 'Get the trust for another member. DCNL Currently this is just the amount of MBs exchanged with them. DCNL :param member: the member we interacted with DCNL :type member: dispersy.member.Member DCNL :return: the trust value for this member DCNL :rtype: int'
def test_add_pending_bytes(self): DCNL 'Test adding to pending bytes'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_cleanup_pending_bytes(self): DCNL 'Test cleaning of pending bytes'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_on_tunnel_remove(self): DCNL 'Test the on_tunnel_remove handler function for a circuit'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_on_tunnel_remove_small(self): DCNL 'Test the on_tunnel_remove handler function for a circuit'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_on_tunnel_remove_append_pending(self): DCNL 'Test the on_tunnel_remove handler function for a circuit'
def test_receive_request_invalid(self): DCNL 'Test the community to receive a request message.'
def test_receive_request_twice(self): DCNL 'Test the community to receive a request message twice.'
def test_receive_request_too_much(self): DCNL 'Test the community to receive a request that claims more than we are prepared to sign'
def test_receive_request_unknown_pend(self): DCNL 'Test the community to receive a request that claims about a peer we know nothing about'
def test_block_values(self): DCNL 'If a block is created between two nodes both DCNL should have the correct total_up and total_down of the signature request.'
def test_block_values_after_request(self): DCNL 'After a request is sent, a node should update its totals.'
def test_crawler_on_introduction_received(self): DCNL 'Test the crawler takes a step when an introduction is made by the walker'
def test_get_statistics_no_blocks(self): DCNL 'Test the get_statistics method where last block is none'
def test_get_statistics_with_previous_block(self): DCNL 'Test the get_statistics method where a last block exists'
def test_get_statistics_for_not_self(self): DCNL 'Test the get_statistics method where a last block exists'
def test_get_trust(self): DCNL 'Test that the trust nodes have for each other is the upload + the download total of all blocks.'
def test_get_default_trust(self): DCNL 'Test that the trust between nodes without blocks is 1.'
@blocking_call_on_reactor_thread DCNL def test_get_num_interactors(self): DCNL 'Test whether the right number of interactors is returned'
def test_sign_block(self): DCNL 'Test the community to send a signature request message.'
def test_sign_block_missing_member(self): DCNL 'Test the sign_block function with a missing member'
def test_sign_invalid_block(self): DCNL 'Test the community to publish a signature request message.'
def test_receive_signature_request_and_response(self): DCNL 'Test the community to receive a signature request and a signature response message.'
def test_crawl_on_partial(self): DCNL 'Test that a crawl is requested if the signer cannot validate the previous hash of a request'
def test_crawl_not_double(self): DCNL 'Test that a crawl is not send multiple times when a crawl is already happening as a result of an incoming block'
def test_crawl_on_partial_complete(self): DCNL 'Test that a crawl is requested and serviced if the signer cannot validate the previous hash of a request'
def test_crawl_block_latest(self): DCNL 'Test the crawler to request the latest block.'
def test_crawl_block_specified_sequence_number(self): DCNL 'Test the crawler to fetch a block with a specified sequence number.'
def test_crawl_blocks_negative_sequence_number(self): DCNL 'Test the crawler to fetch blocks starting from a negative sequence number.'
def test_crawl_no_block(self): DCNL 'Test crawl without a block.'
def test_crawl_block_known(self): DCNL 'Test the crawler to request a known block.'
def test_crawl_batch(self): DCNL 'Test the crawler for fetching multiple blocks in one crawl.'
def test_get_trust(self): DCNL 'Test that the trust nodes have for each other is the sum of the length of both chains.'
def test_get_default_trust(self): DCNL 'Test that the trust between nodes without blocks is 1.'
def test_live_edge_bootstrapping(self): DCNL 'A node without trust for anyone should still find a candidate.'
def test_live_edge_recommend_valid(self): DCNL 'Live edges should never include invalid/old candidates.'
def test_live_edge_callback_no_candidates(self): DCNL 'Test live edges start with my member.'
def test_live_edge_callback(self): DCNL 'Test creation and handling of a new live edge.'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_wait_for_intro_candidate(self): DCNL 'Test the waiting for an introduction candidate'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_wait_for_signature_request(self): DCNL 'Test the waiting for a signature request'
def assertEqual_block(self, expected_block, actual_block): DCNL 'Function to assertEqual two blocks'
def test_encoding_decoding_half_block(self): DCNL 'Test encoding of a signed message'
def test_encoding_decoding_half_block_big_number(self): DCNL 'Test if a responder can send a signature message with big total_up and down.'
def test_decoding_half_block_wrong_size(self): DCNL 'Test decoding a signature message with wrong size'
def test_encoding_decoding_crawl_request(self): DCNL 'Test if a requester can send a crawl request message.'
def test_decoding_crawl_request_wrong_size(self): DCNL 'Test if a DropPacket is raised when the crawl request size is wrong.'
@blocking_call_on_reactor_thread DCNL def test_save_large_upload_download_block(self): DCNL 'Test if the block can save very large numbers.'
@blocking_call_on_reactor_thread DCNL def test_block_to_dictionary(self): DCNL 'Test whether a block is correctly represented when converted to a dictionary'
def test_should_sign_no_market(self): DCNL 'Test whether the should_sign method return False when there is no market community'
def test_circuit_tunnel_data(self): DCNL 'Test whether the right methods are called when tunneling data over a circuit'
@blocking_call_on_reactor_thread DCNL def test_create_intro_no_download(self): DCNL 'Test the creation of an introduction point with an unexisting download'
@deferred(timeout=60) DCNL @inlineCallbacks DCNL def test_anon_download(self): DCNL 'Testing whether an anonymous download over our tunnels works'
@deferred(timeout=60) DCNL @inlineCallbacks DCNL def test_anon_download_no_exitnodes(self): DCNL 'Testing whether an anon download does not make progress without exit nodes'
@deferred(timeout=60) DCNL @inlineCallbacks DCNL def test_anon_download_no_relays(self): DCNL 'Testing whether an anon download does not make progress without relay nodes'
def get_peers(self, lookup_id, _, callback_f, bt_port=0): DCNL 'This mocked method simply adds a peer to the DHT dictionary and invokes the callback.'
def configure_hidden_seeder(self): DCNL 'Setup the hidden seeder. This includes setting the right circuit parameters, creating the download callback and DCNL waiting for the creation of an introduction point for the download.'
@deferred(timeout=50) DCNL @inlineCallbacks DCNL def test_hidden_services(self): DCNL 'Testing the hidden services'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_unload_receive(self): DCNL 'Testing whether the TunnelCommunity does not reload itself after unloading'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_load_other_tunnel_community(self): DCNL 'Testing whether we do not load two different tunnel communities in the same session'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setUp(self, autoload_discovery=True): DCNL 'Setup various variables and load the tunnel community in the main downloader session.'
@inlineCallbacks DCNL def setup_nodes(self, num_relays=1, num_exitnodes=1, seed_hops=0): DCNL 'Setup all required nodes, including the relays, exit nodes and seeder.'
@blocking_call_on_reactor_thread DCNL def load_tunnel_community_in_session(self, session, exitnode=False): DCNL 'Load the tunnel community in a given session. We are using our own tunnel community here instead of the one DCNL used in Tribler.'
@inlineCallbacks DCNL def create_proxy(self, index, exitnode=False): DCNL 'Create a single proxy and load the tunnel community in the session of that proxy.'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setup_tunnel_seeder(self, hops): DCNL 'Setup the seeder.'
def seeder_state_callback(self, ds): DCNL 'The callback of the seeder download. For now, this only logs the state of the download that\'s seeder and is DCNL useful for debugging purposes.'
def start_anon_download(self, hops=1): DCNL 'Start an anonymous download in the main Tribler session.'
def test_decode_request(self): DCNL 'Test the decoding process of a request'
def test_associate(self): DCNL 'Test whether UDP ASSOCIATE requests are answered with a REP_SUCCEEDED'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_double_close(self): DCNL 'When a Socks5Connection connection is closed twice, it should just DCNL return True'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_double_close(self): DCNL 'When a SocksUDPConnection connection is closed twice, it should just DCNL return True'
def test_on_data_invalid_encoding(self): DCNL 'When on_data receives an invalid encryption, crypto_in() should throw a CryptoException.'
@blocking_call_on_reactor_thread DCNL def test_valid_member_on_tunnel_remove(self): DCNL 'Notifications of NTFY_TUNNEL NTFY_REMOVE should report candidates with valid member associations'
@blocking_call_on_reactor_thread DCNL def test_reconstruct_candidate_on_tunnel_remove(self): DCNL 'Notifications of NTFY_TUNNEL NTFY_REMOVE should report candidates even though they are no longer tracked DCNL The notification should still have a valid Candidate object for the reference of third parties. DCNL For example, Dispersy might determine a Candidate is no longer needed for the TunnelCommunity, but the DCNL TrustChainCommunity will still be interested in the Candidate object tied to a removed circuit.'
@blocking_call_on_reactor_thread DCNL def test_reconstruct_candidate_on_relay_remove(self): DCNL 'Notifications of NTFY_TUNNEL NTFY_REMOVE should report candidates even though they are no longer tracked DCNL The notification should still have a valid Candidate object for the reference of third parties. DCNL For example, Dispersy might determine a Candidate is no longer needed for the TunnelCommunity, but the DCNL TrustChainCommunity will still be interested in the Candidate object tied to a removed circuit.'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_e2e_transaction(self): DCNL 'test whether a full transaction will be executed between two nodes.'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_orderbook_sync(self): DCNL 'Test whether the order book of two nodes are being synchronized'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_accept_trade(self): DCNL 'Test whether a trade is made between two nodes'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_counter_trade(self): DCNL 'Test whether a counter trade is made between two nodes'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_decline_trade(self): DCNL 'Test whether a decline trade is sent between nodes if the price of a proposed trade is not right'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_cancel_order(self): DCNL 'Test whether a cancel-order message is sent between nodes if we cancel an order'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setUp(self, autoload_discovery=True): DCNL 'Setup various variables.'
@blocking_call_on_reactor_thread DCNL def load_market_community_in_session(self, session, market_member, mc_community): DCNL 'Load the market community and tradechain community in a given session.'
@blocking_call_on_reactor_thread DCNL def load_triblerchain_community_in_session(self, session): DCNL 'Load a custom instance of the TriblerChain community in a given session.'
@inlineCallbacks DCNL def create_session(self, index): DCNL 'Create a single session and load the tunnel community in the session of that proxy.'
def test_signature(self): DCNL 'Test signing a tick'
def test_update_timestamp(self): DCNL 'Test the update_timestamp method of a Tick object'
def test_to_dictionary(self): DCNL 'Test the to dictionary method of a tick'
def test_match_order_other_price(self): DCNL 'Test whether two ticks with different price types are not matched'
def test_match_order_other_quantity(self): DCNL 'Test whether two ticks with different quantity types are not matched'
def test_match_order_partial_ask(self): DCNL 'Test partial matching of a bid order with the matching engine'
def test_match_order_partial_bid(self): DCNL 'Test partial matching of an ask order with the matching engine'
def test_search_for_quantity_in_price_level(self): DCNL 'Test searching within a price level'
def test_init(self): DCNL 'Test the initialization of a quantity'
@blocking_call_on_reactor_thread DCNL def test_get_master_members(self): DCNL 'Test retrieval of the master members of the Market community'
@blocking_call_on_reactor_thread DCNL def test_proposed_trade_cache_timeout(self): DCNL 'Test the timeout method of a proposed trade request in the cache'
@blocking_call_on_reactor_thread DCNL def test_verify_offer_creation(self): DCNL 'Test creation of an offer in the community'
@blocking_call_on_reactor_thread DCNL def test_check_message(self): DCNL 'Test the general check of the validity of a message in the market community'
@blocking_call_on_reactor_thread DCNL def test_check_tick_message(self): DCNL 'Test the general check of the validity of a tick message in the market community'
@blocking_call_on_reactor_thread DCNL def test_check_trade_message(self): DCNL 'Test the general check of the validity of a trade message in the market community'
@blocking_call_on_reactor_thread DCNL def test_send_offer_sync(self): DCNL 'Test sending an offer sync'
@blocking_call_on_reactor_thread DCNL def test_send_proposed_trade(self): DCNL 'Test sending a proposed trade'
@blocking_call_on_reactor_thread DCNL def test_send_counter_trade(self): DCNL 'Test sending a counter trade'
@blocking_call_on_reactor_thread DCNL def test_start_transaction(self): DCNL 'Test the start transaction method'
@blocking_call_on_reactor_thread DCNL def test_create_intro_request(self): DCNL 'Test the creation of an introduction request'
@blocking_call_on_reactor_thread DCNL def test_on_introduction_request(self): DCNL 'Test that when we receive an intro request with a orders bloom filter, we send an order sync back'
@blocking_call_on_reactor_thread DCNL def test_get_wallet_address(self): DCNL 'Test the retrieval of a wallet address'
@blocking_call_on_reactor_thread DCNL def test_on_tick(self): DCNL 'Test whether a tick is inserted in the order book when we receive one'
@blocking_call_on_reactor_thread DCNL def test_on_proposed_trade_accept(self): DCNL 'Test whether we accept a trade when we receive a correct proposed trade message'
@blocking_call_on_reactor_thread DCNL def test_on_proposed_trade_decline(self): DCNL 'Test whether we decline a trade when we receive an invalid proposed trade message'
@blocking_call_on_reactor_thread DCNL def test_on_proposed_trade_counter(self): DCNL 'Test whether we send a counter trade when we receive a proposed trade message'
@blocking_call_on_reactor_thread DCNL def test_on_offer_sync(self): DCNL 'Test whether the right operations happen when we receive an offer sync'
@blocking_call_on_reactor_thread DCNL def test_compute_reputation(self): DCNL 'Test the compute_reputation method'
@blocking_call_on_reactor_thread DCNL def test_abort_transaction(self): DCNL 'Test aborting a transaction'
def test_init(self): DCNL 'Test the initialization of a price'
def test_add_trade(self): DCNL 'Test the add trade method of an order'
def test_status(self): DCNL 'Test the status of an order'
def test_compute(self): DCNL 'Test the base compute method of the reputation manager'
def test_get_price_level_list_wallets(self): DCNL 'Test the price level lists of wallets of a side'
def test_get_list_representation(self): DCNL 'Testing the list representation of a side'
def test_properties(self): DCNL 'Test the market intro payload'
def test_properties(self): DCNL 'Test the start transaction payload'
def test_properties(self): DCNL 'Test the payment payload'
def test_properties(self): DCNL 'Test the wallet info payload'
def test_to_dictionary(self): DCNL 'Test the dictionary representation of a payment'
def test_init(self): DCNL 'Test the initialization of a quantity'
def test_str(self): DCNL 'Test the string representation of a payment id'
def test_equality(self): DCNL 'Test equality between payment ids'
def test_hash(self): DCNL 'Test the hash creation of a payment id'
def test_timeouts(self): DCNL 'Test the timeout functions of asks/bids'
def test_get_tick(self): DCNL 'Test the retrieval of a tick from the order book'
@deferred(timeout=10) DCNL def test_ask_insertion_invalid(self): DCNL 'Test whether we get an error when we add an invalid ask to the order book'
@deferred(timeout=10) DCNL def test_bid_insertion_invalid(self): DCNL 'Test whether we get an error when we add an invalid bid to the order book'
def test_trade_tick(self): DCNL 'Test the trade tick method in an order book'
def test_get_order_ids(self): DCNL 'Test the get order IDs function in order book'
@blocking_call_on_reactor_thread DCNL def test_save_to_db(self): DCNL 'Test whether ticks from the order book are correctly saved to the database'
@blocking_call_on_reactor_thread DCNL def test_restore_from_db(self): DCNL 'Test whether ticks from the database are correctly restored to the order book'
@deferred(timeout=20) DCNL def test_btc_wallet(self): DCNL 'Test the creating, opening, transactions and balance query of a Bitcoin wallet'
def test_btc_wallet_name(self): DCNL 'Test the name of a Bitcoin wallet'
def test_btc_wallet_identfier(self): DCNL 'Test the identifier of a Bitcoin wallet'
def test_btc_wallet_address(self): DCNL 'Test the address of a Bitcoin wallet'
def test_btc_wallet_unit(self): DCNL 'Test the mininum unit of a Bitcoin wallet'
def test_btc_balance_no_wallet(self): DCNL 'Test the retrieval of the balance of a BTC wallet that is not created yet'
@deferred(timeout=10) DCNL def test_btc_wallet_transfer_no_funds(self): DCNL 'Test that the transfer method of a BTC wallet raises an error when we don\'t have enough funds'
@deferred(timeout=10) DCNL def test_btc_wallet_transfer(self): DCNL 'Test that the transfer method of a BTC wallet'
@deferred(timeout=10) DCNL def test_btc_wallet_transfer_error(self): DCNL 'Test that the transfer method of a BTC wallet'
def test_get_mc_wallet_name(self): DCNL 'Test the identifier of the Trustchain wallet'
def test_get_mc_wallet_id(self): DCNL 'Test the identifier of a Trustchain wallet'
@deferred(timeout=10) DCNL def test_get_balance(self): DCNL 'Test the balance retrieval of a Trustchain wallet'
def test_create_wallet(self): DCNL 'Test whether creating a Trustchain wallet raises an error'
@deferred(timeout=10) DCNL def test_transfer_invalid(self): DCNL 'Test the transfer method of a Trustchain wallet'
@deferred(timeout=10) DCNL def test_transfer_missing_member(self): DCNL 'Test the transfer method of a Trustchain wallet with a missing member'
@deferred(timeout=10) DCNL def test_monitor_transaction(self): DCNL 'Test the monitoring of a transaction in a Trustchain wallet'
def test_address(self): DCNL 'Test the address of a Trustchain wallet'
@deferred(timeout=10) DCNL def test_get_transaction(self): DCNL 'Test the retrieval of transactions of a dummy wallet'
def test_min_unit(self): DCNL 'Test the minimum unit of a Trustchain wallet'
def test_wait_for_intro_of_candidate(self): DCNL 'Test waiting for an introduction candidate in the TrustChain wallet'
def test_wallet_id(self): DCNL 'Test the identifier of a dummy wallet'
def test_wallet_name(self): DCNL 'Test the name of a dummy wallet'
@deferred(timeout=10) DCNL def test_create_wallet(self): DCNL 'Test the creation of a dummy wallet'
@deferred(timeout=10) DCNL def test_get_balance(self): DCNL 'Test fetching the balance of a dummy wallet'
@deferred(timeout=10) DCNL def test_transfer(self): DCNL 'Test the transfer of money from a dummy wallet'
@deferred(timeout=10) DCNL def test_transfer_invalid(self): DCNL 'Test whether transferring a too large amount of money from a dummy wallet raises an error'
@deferred(timeout=10) DCNL def test_monitor(self): DCNL 'Test the monitor loop of a transaction wallet'
@deferred(timeout=10) DCNL def test_monitor_instant(self): DCNL 'Test an instant the monitor loop of a transaction wallet'
def test_address(self): DCNL 'Test the address of a dummy wallet'
@deferred(timeout=10) DCNL def test_get_transaction(self): DCNL 'Test the retrieval of transactions of a dummy wallet'
def test_min_unit(self): DCNL 'Test the minimum unit of a dummy wallet'
def test_generate_txid(self): DCNL 'Test the generation of a random transaction id'
def test_unitize(self): DCNL 'Test the unitize method of a Transaction'
def test_add_payment(self): DCNL 'Test the addition of a payment to a transaction'
def test_last_payment(self): DCNL 'Test the retrieval of the last payment'
def test_next_payment(self): DCNL 'Test the process of determining the next payment details during a transaction'
def test_to_dictionary(self): DCNL 'Test the to dictionary method of a transaction'
def test_status(self): DCNL 'Test the status of a transaction'
def test_to_network(self): DCNL 'Test the conversion of a StartTransaction object to the network'
def get_placeholder_msg(self, meta_name): DCNL 'Return a placeholder message with a specific meta name'
def test_decode_payload(self): DCNL 'Test decoding of a payload'
def test_encode_decode_intro_request(self): DCNL 'Test encoding and decoding of an introduction request'
def test_encode_decode_offer(self): DCNL 'Test encoding and decoding of an offer'
def test_encode_decode_cancel_order(self): DCNL 'Test encoding and decoding of a cancel order'
def test_encode_decode_offer_sync(self): DCNL 'Test encoding and decoding of an offer sync'
def test_encode_decode_declined_trade(self): DCNL 'Test encoding and decoding of an declined trade'
def test_encode_decode_start_transaction(self): DCNL 'Test encoding and decoding of a start transaction message'
def test_encode_decode_transaction(self): DCNL 'Test encoding and decoding of a transaction message'
def test_encode_decode_wallet_info(self): DCNL 'Test encoding and decoding of wallet info'
def test_encode_decode_payment(self): DCNL 'Test encoding and decoding of a payment'
def test_init(self): DCNL 'Test the initialization of the database order repository'
@blocking_call_on_reactor_thread DCNL def test_add_get_order(self): DCNL 'Test the insertion and retrieval of an order in the database'
@blocking_call_on_reactor_thread DCNL def test_get_specific_order(self): DCNL 'Test the retrieval of a specific order'
@blocking_call_on_reactor_thread DCNL def test_delete_order(self): DCNL 'Test the deletion of an order from the database'
@blocking_call_on_reactor_thread DCNL def test_get_next_order_number(self): DCNL 'Test the retrieval of the next order number from the database'
@blocking_call_on_reactor_thread DCNL def test_add_delete_reserved_ticks(self): DCNL 'Test the retrieval, addition and deletion of reserved ticks in the database'
@blocking_call_on_reactor_thread DCNL def test_add_get_transaction(self): DCNL 'Test the insertion and retrieval of a transaction in the database'
@blocking_call_on_reactor_thread DCNL def test_get_specific_transaction(self): DCNL 'Test the retrieval of a specific transaction'
@blocking_call_on_reactor_thread DCNL def test_delete_transaction(self): DCNL 'Test the deletion of a transaction from the database'
@blocking_call_on_reactor_thread DCNL def test_get_next_transaction_number(self): DCNL 'Test the retrieval of the next transaction number from the database'
@blocking_call_on_reactor_thread DCNL def test_add_get_payment(self): DCNL 'Test the insertion and retrieval of a payment in the database'
@blocking_call_on_reactor_thread DCNL def test_add_remove_tick(self): DCNL 'Test addition, retrieval and deletion of ticks in the database'
@blocking_call_on_reactor_thread DCNL def test_add_get_trader_identity(self): DCNL 'Test the addition and retrieval of a trader identity in the database'
@blocking_call_on_reactor_thread DCNL def test_check_database(self): DCNL 'Test the check of the database'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setup_peer(self): DCNL 'Setup a second peer that contains some search results.'
@deferred(timeout=20) DCNL def test_torrent_search(self): DCNL 'Test whether we receive results when searching remotely for torrents'
@deferred(timeout=20) DCNL def test_channel_search(self): DCNL 'Test whether we receive results when searching remotely for channels'
def test_on_search(self): DCNL 'Test whether we are creating a search response when we receive a search request'
@raises(DropPacket) DCNL def test_decode_response_invalid(self): DCNL 'Test whether decoding an invalid search response does not crash the program'
@blocking_call_on_reactor_thread DCNL def test_create_torrent(self): DCNL 'Test the creation of a torrent in the search community'
def test_remove_playlist_torrents(self): DCNL 'Testing whether the right methods are called when a torrent is removed from a playlist'
@blocking_call_on_reactor_thread DCNL def test_create_torrent_from_def(self): DCNL 'Testing whether a correct Dispersy message is created when we add a torrent to our channel'
def test_encode_torrent(self): DCNL 'Test the encoding of a torrent file'
def test_decode_torrent(self): DCNL 'Test the decoding of a torrent message'
@deferred(timeout=10) DCNL def test_create_votecast(self): DCNL 'Testing whether a votecast can be created in the community'
@deferred(timeout=10) DCNL def test_unload_preview(self): DCNL 'Test the unloading of the preview community'
@deferred(timeout=60) DCNL def test_seeding(self): DCNL 'Test whether a torrent is correctly seeded'
def screenshot(self, widget, name=None): DCNL 'Take a screenshot of the widget. You can optionally append a string to the name of the screenshot. The DCNL screenshot itself is saved as a JPEG file.'
def get_bucket_range_port(self): DCNL 'Return the port range of the test bucket assigned.'
def get_socks5_ports(self): DCNL 'Return five random, free socks5 ports. DCNL This is here to make sure that tests in different buckets get assigned different SOCKS5 listen ports. DCNL Also, make sure that we have no duplicates in selected socks5 ports.'
def create_local_torrent(self, source_file): DCNL 'This method creates a torrent from a local file and saves the torrent in the session state dir. DCNL Note that the source file needs to exist.'
def test_create_torrent(self): DCNL 'Tests the create_torrent_file() function.'
def create_tdef(self): DCNL 'create and save torrent definition used in this test file'
@deferred(timeout=10) DCNL def test_save_resume(self): DCNL 'testing call resume data alert'
def test_selected_files(self): DCNL 'Test whether the selected files are set correctly'
def test_get_share_mode(self): DCNL 'Test whether we return the right share mode when requested in the LibtorrentDownloadImpl'
def test_set_share_mode(self): DCNL 'Test whether we set the right share mode in LibtorrentDownloadImpl'
def test_set_priority(self): DCNL 'Test whether setting the priority calls the right methods in LibtorrentDownloadImpl'
def test_dlconfig_cb_change(self): DCNL 'Testing whether changing the configuration on runtime calls the right methods in LibtorrentDownloadImpl'
def test_add_trackers(self): DCNL 'Testing whether trackers are added to the libtorrent handler in LibtorrentDownloadImpl'
def test_process_error_alert(self): DCNL 'Testing whether error alerts are processed correctly'
def test_tracker_warning_alert(self): DCNL 'Test whether a tracking warning alert is processed correctly'
@deferred(timeout=10) DCNL def test_on_metadata_received_alert(self): DCNL 'Testing whether the right operations happen when we receive metadata'
def test_metadata_received_invalid_info(self): DCNL 'Testing whether the right operations happen when we receive metadata but the torrent info is invalid'
def test_torrent_checked_alert(self): DCNL 'Testing whether the right operations happen after a torrent checked alert is received'
def test_get_length(self): DCNL 'Testing whether the right length of the content of the download is returned'
def test_get_dest_files(self): DCNL 'Testing whether the right list of files is returned when fetching files from a download'
def test_get_vod_fileindex(self): DCNL 'Testing whether the right vod file index is returned in LibtorrentDownloadImpl'
def test_get_vod_filesize(self): DCNL 'Testing whether the right vod file size is returned in LibtorrentDownloadImpl'
def test_get_piece_progress(self): DCNL 'Testing whether the right piece progress is returned in LibtorrentDownloadImpl'
def test_get_byte_progress(self): DCNL 'Testing whether the right byte progress is returned in LibtorrentDownloadImpl'
def test_setup_exception(self): DCNL 'Testing whether an exception in the setup method of LibtorrentDownloadImpl is handled correctly'
def test_tracker_reply_alert(self): DCNL 'Testing the tracker reply alert in LibtorrentDownloadImpl'
def test_stop(self): DCNL 'Testing whether the stop method in LibtorrentDownloadImpl invokes the correct method'
def test_download_finish_alert(self): DCNL 'Testing whether the right operations are performed when we get a torrent finished alert'
def test_get_pieces_bitmask(self): DCNL 'Testing whether a correct pieces bitmask is returned when requested'
@deferred(timeout=10) DCNL def test_resume_data_failed(self): DCNL 'Testing whether the correct operations happen when an error is raised during resume data saving'
def test_get_metainfo_not_ready(self): DCNL 'Testing the metainfo fetching method when the DHT is not ready'
@deferred(timeout=20) DCNL def test_get_metainfo(self): DCNL 'Testing the metainfo fetching method'
@deferred(timeout=20) DCNL def test_got_metainfo(self): DCNL 'Testing whether the callback is correctly invoked when we received metainfo'
@deferred(timeout=20) DCNL def test_got_metainfo_timeout(self): DCNL 'Testing whether the callback is correctly invoked when we received metainfo after timeout'
def test_add_torrent(self): DCNL 'Testing the addition of a torrent to the libtorrent manager'
def test_start_download_corrupt(self): DCNL 'Testing whether starting the download of a corrupt torrent file raises an exception'
def test_start_download_duplicate(self): DCNL 'Test the starting of a download when there are no new trackers'
def test_set_proxy_settings(self): DCNL 'Test setting the proxy settings'
def test_read_test_corr_tribler_conf(self): DCNL 'Adding corrupt values should result in the default value. DCNL Note that this test might fail if there is already an upgraded config stored in the default DCNL state directory. The code being tested here however shouldn\'t be ran if that config already exists. DCNL :return:'
def test_read_test_corr_libtribler_conf(self): DCNL 'Adding corrupt values should result in the default value. DCNL Note that this test might fail if there is already an upgraded config stored in the default DCNL state directory. The code being tested here however shouldn\'t be ran if that config already exists. DCNL :return:'
def test_upgrade_from_obsolete_version(self): DCNL 'We no longer support DB versions older than 17 (Tribler 6.0)'
@blocking_call_on_reactor_thread DCNL def test_run(self): DCNL 'Test the run method of the upgrader'
def test_search_local_channels(self): DCNL 'Testing whether the right results are returned when searching in the local database for channels'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setUp(self, annotate=True, autoload_discovery=True): DCNL 'Setup some classes and files that are used by the tests in this module.'
@blocking_call_on_reactor_thread DCNL def create_fake_allchannel_community(self): DCNL 'This method creates a fake AllChannel community so we can check whether a request is made in the community DCNL when doing stuff with a channel.'
def test_create_channel(self): DCNL 'Test the pass through function of Session.create_channel to the ChannelManager.'
def test_unhandled_error_observer(self): DCNL 'Test the unhandled error observer'
def test_error_observer_ignored_error(self): DCNL 'Testing whether some errors are ignored (like socket errors)'
@deferred(timeout=10) DCNL def test_add_torrent_def_to_channel(self): DCNL 'Test whether adding a torrent def to a channel works'
@deferred(timeout=10) DCNL def test_add_torrent_def_to_channel_duplicate(self): DCNL 'Test whether adding a torrent def twice to a channel raises an exception'
@raises(OperationNotEnabledByConfigurationException) DCNL def test_get_libtorrent_process_not_enabled(self): DCNL 'When libtorrent is not enabled, an exception should be thrown when getting the libtorrent instance.'
@raises(OperationNotEnabledByConfigurationException) DCNL def test_open_dbhandler(self): DCNL 'Opening the database without the megacache enabled should raise an exception.'
def test_download_torrentfile(self): DCNL 'When libtorrent is not enabled, an exception should be thrown when downloading a torrentfile.'
def test_download_torrentfile_from_peer(self): DCNL 'When libtorrent is not enabled, an exception should be thrown when downloading a torrentfile from a peer.'
def test_download_torrentmessage_from_peer(self): DCNL 'When libtorrent is not enabled, an exception should be thrown when downloading a torrentfile from a peer.'
def test_get_permid(self): DCNL 'Retrieving the string encoded permid should be successful.'
def test_remove_download_by_id_empty(self): DCNL 'Remove downloads method when empty.'
def test_remove_download_by_id_nonempty(self): DCNL 'Remove an existing download.'
@raises(OperationNotEnabledByConfigurationException) DCNL def test_get_dispersy_instance(self): DCNL 'Test whether the get dispersy instance throws an exception if dispersy is not enabled.'
@raises(OperationNotEnabledByConfigurationException) DCNL def test_has_collected_torrent(self): DCNL 'Test whether the has_collected_torrent throws an exception if dispersy is not enabled.'
@raises(OperationNotEnabledByConfigurationException) DCNL def test_get_collected_torrent(self): DCNL 'Test whether the get_collected_torrent throws an exception if dispersy is not enabled.'
@raises(OperationNotEnabledByConfigurationException) DCNL def test_save_collected_torrent(self): DCNL 'Test whether the save_collected_torrent throws an exception if dispersy is not enabled.'
@raises(OperationNotEnabledByConfigurationException) DCNL def test_delete_collected_torrent(self): DCNL 'Test whether the delete_collected_torrent throws an exception if dispersy is not enabled.'
@raises(OperationNotEnabledByConfigurationException) DCNL def test_search_remote_channels(self): DCNL 'Test whether the search_remote_channels throws an exception if dispersy is not enabled.'
@raises(OperationNotEnabledByConfigurationException) DCNL def test_get_thumbnail_data(self): DCNL 'Test whether the get_thumbnail_data throws an exception if dispersy is not enabled.'
def test_random_policy(self): DCNL 'testing random policy'
def test_seederratio_policy(self): DCNL 'testing seeder ratio policy'
@skip('The DCSP random DCSP seed DCSP is DCSP not DCSP reliable') DCNL def test_fallback_policy(self): DCNL 'testing policy (seederratio) and then fallback'
def test_creationdate_policy(self): DCNL 'test policy based on creation date'
def test_boosting_dependencies(self): DCNL 'Test whether boosting manager dependencies works or not. DCNL In all test, check dependencies always off. In production, it is on by default.'
def test_load_default(self): DCNL 'Test load default configuration in BoostingManager'
def test_translate_peer_info(self): DCNL 'test - predict number of seeder and leecher only based on peer discovered and DCNL their activities'
def test_levenshtein(self): DCNL 'test levenshtein between two string (in this case, file name) DCNL source : DCNL http://people.cs.pitt.edu/~kirk/cs1501/Pruhs/Fall2006/Assignments/editdistance/Levenshtein%20Distance.htm'
def test_update_statistics(self): DCNL 'test updating statistics of a torrent (pick a new one)'
def test_escape_xml(self): DCNL 'testing escape symbols occured in xml/rss document file.'
def test_insert_torrent_unknown_source(self): DCNL 'testing insert torrent on unknown source'
def test_unknown_source(self): DCNL 'testing uknkown source added to boosting source, and try to apply archive DCNL on top of that'
def test_failed_start_download(self): DCNL 'test assertion error then not download the actual torrent'
def set_boosting_settings(self): DCNL 'set settings in credit mining'
def check_torrents(self, src, target=1): DCNL 'Check if a specified number of torrent has been added to the passed source.'
def check_source(self, src): DCNL 'function to check if a source is ready initializing'
@deferred(timeout=30) DCNL def test_rss(self): DCNL 'test rss source'
def _on_error_rss(self, dummy_1, dummy_2): DCNL 'dummy errback when RSS source produces an error'
@deferred(timeout=8) DCNL def test_rss_unexist(self): DCNL 'Testing an unexisting RSS feed'
@deferred(timeout=8) DCNL def test_rss_unavailable(self): DCNL 'Testing an unavailable RSS feed'
@deferred(timeout=10) DCNL def test_dir(self): DCNL 'test directory filled with .torrents'
@deferred(timeout=10) DCNL def test_dir_archive_example(self): DCNL 'test archive mode. Use diretory because easier to fetch torrent'
def _load(self, _): DCNL 'Dummy method to download the torrent'
@blocking_call_on_reactor_thread DCNL def create_torrents_in_channel(self, dispersy_cid_hex): DCNL 'Helper function to insert 10 torrent into designated channel'
@deferred(timeout=20) DCNL def test_chn_lookup(self): DCNL 'testing channel source. DCNL It includes finding and downloading actual torrent'
@deferred(timeout=30) DCNL def test_chn_exist_lookup(self): DCNL 'testing existing channel as a source. DCNL It also tests how boosting manager cope with unknown channel with retrying DCNL the lookup'
@deferred(timeout=30) DCNL def test_chn_max_torrents(self): DCNL 'Test the restriction of max_torrents in a source.'
def get_peer_info(self): DCNL 'class returning peer info for a particular handle'
def is_valid(self): DCNL 'check whether the handle is valid or not'
def get_infohash(self): DCNL 'returning infohash of torrents'
def get_session(self): DCNL 'supposed to get libtorrent session'
def set_settings(self, _): DCNL 'set settings (don\'t do anything)'
def shutdown(self): DCNL 'obligatory shutdown function'
def get_download(self, x): DCNL 'mocked function to get a download'
def test_init(self): DCNL 'Testing the init method of DownloadState'
def test_getters_setters_1(self): DCNL 'Testing various getters and setters in DownloadState'
def test_getters_setters_2(self): DCNL 'Testing various getters and setters in DownloadState'
def test_get_files_completion(self): DCNL 'Testing whether the right completion of files is returned'
def test_get_availability(self): DCNL 'Testing whether the right availability of a file is returned'
def test_get_vod_dest_dir(self): DCNL 'Testing whether the right destination of a VOD download is returned'
def test_get_vod_stream(self): DCNL 'Testing whether the right VOD stream is returned'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setUp(self, autoload_discovery=True): DCNL 'unittest test setup code'
def test_no_lock_file(self): DCNL 'Testing whether the process checker returns false when there is no lock file.'
def test_invalid_pid_in_lock_file(self): DCNL 'Test whether a new lock file is created when an invalid pid is written inside the current lock file'
def test_own_pid_in_lock_file(self): DCNL 'Testing whether the process checker returns false when it finds its own pid in the lock file.'
def test_other_instance_running(self): DCNL 'Testing whether the process checker returns true when another process is running.'
def test_dead_pid_in_lock_file(self): DCNL 'Testing whether the process checker returns false when there is a dead pid in the lock file.'
def setUp(self, annotate=True): DCNL 'Setup the tests by creating the ChannelRssParser instance and initializing it.'
def setUp(self, annotate=True): DCNL 'Setup the tests by creating the ChannelObject instance.'
@blocking_call_on_reactor_thread DCNL def test_initialize(self): DCNL 'Test the initialization of the tracker manager'
@blocking_call_on_reactor_thread DCNL def test_add_tracker(self): DCNL 'Test whether adding a tracker works correctly'
@blocking_call_on_reactor_thread DCNL def test_get_tracker_info(self): DCNL 'Test whether the correct tracker info is returned when requesting it in the tracker manager'
@blocking_call_on_reactor_thread DCNL def test_update_tracker_info(self): DCNL 'Test whether the tracker info is correctly updated'
@blocking_call_on_reactor_thread DCNL def test_should_check_tracker(self): DCNL 'Test whether we should check a tracker or not'
@blocking_call_on_reactor_thread DCNL def test_get_tracker_for_check(self): DCNL 'Test whether the correct tracker is returned when fetching the next eligable tracker for the auto check'
def test_get_market_community(self): DCNL 'Test the method to get the market community in the market API'
def add_transaction_and_payment(self): DCNL 'Add a transaction and a payment to the market'
@deferred(timeout=10) DCNL def test_get_asks(self): DCNL 'Test whether the API returns the right asks in the order book when performing a request'
@deferred(timeout=10) DCNL def test_create_ask(self): DCNL 'Test whether we can create an ask using the API'
@deferred(timeout=10) DCNL def test_create_ask_no_price(self): DCNL 'Test for an error when we don\'t add a price when creating an ask'
@deferred(timeout=10) DCNL def test_create_ask_no_price_type(self): DCNL 'Test for an error when we don\'t add a price type when creating an ask'
@deferred(timeout=10) DCNL def test_get_bids(self): DCNL 'Test whether the API returns the right bids in the order book when performing a request'
@deferred(timeout=10) DCNL def test_create_bid(self): DCNL 'Test whether we can create a bid using the API'
@deferred(timeout=10) DCNL def test_create_bid_no_price(self): DCNL 'Test for an error when we don\'t add a price when creating a bid'
@deferred(timeout=10) DCNL def test_create_bid_no_price_type(self): DCNL 'Test for an error when we don\'t add a price type when creating a bid'
@deferred(timeout=10) DCNL def test_get_transactions(self): DCNL 'Test whether the API returns the right transactions in the order book when performing a request'
@deferred(timeout=10) DCNL def test_get_payment_not_found(self): DCNL 'Test whether the API returns a 404 when a payment cannot be found'
@deferred(timeout=10) DCNL def test_get_orders(self): DCNL 'Test whether the API returns the right orders when we perform a request'
@deferred(timeout=10) DCNL def test_get_payments(self): DCNL 'Test whether the API returns the right payments when we perform a request'
@deferred(timeout=10) DCNL def test_cancel_order_not_found(self): DCNL 'Test whether a 404 is returned when we try to cancel an order that does not exist'
@deferred(timeout=10) DCNL def test_cancel_order_invalid(self): DCNL 'Test whether an error is returned when we try to cancel an order that has expired'
@deferred(timeout=10) DCNL def test_cancel_order(self): DCNL 'Test whether an error is returned when we try to cancel an order that has expired'
def test_convert_torrent_to_json_dict(self): DCNL 'Test whether the conversion from remote torrent dict to json works'
def test_convert_torrent_to_json_tuple(self): DCNL 'Test whether the conversion from db torrent tuple to json works'
def test_get_parameter(self): DCNL 'Testing the get_parameters method in REST API util class'
def test_convert_db_channel_to_json(self): DCNL 'Test whether the conversion from a db channel tuple to json works'
def test_can_edit_channel(self): DCNL 'Testing whether we can edit a channel.'
def test_fix_unicode_array(self): DCNL 'Testing the fix of a unicode array'
def test_fix_unicode_dict(self): DCNL 'Testing the fix of a unicode dictionary'
@deferred(timeout=20) DCNL def test_search_results(self): DCNL 'Testing whether the event endpoint returns search results when we have search results available'
@deferred(timeout=20) DCNL def test_events(self): DCNL 'Testing whether various events are coming through the events endpoints'
@deferred(timeout=20) DCNL def test_family_filter_search(self): DCNL 'Testing the family filter when searching for torrents and channels'
@deferred(timeout=10) DCNL def test_get_tribler_statistics(self): DCNL 'Testing whether the API returns a correct Tribler statistics dictionary when requested'
@deferred(timeout=10) DCNL def test_get_dispersy_statistics(self): DCNL 'Testing whether the API returns a correct Dispersy statistics dictionary when requested'
@deferred(timeout=10) DCNL def test_get_community_statistics(self): DCNL 'Testing whether the API returns a correct community statistics dictionary when requested'
@deferred(10) DCNL def test_unhandled_exception(self): DCNL 'Testing whether the API returns a formatted 500 error if an unhandled Exception is raised'
@deferred(timeout=10) DCNL def test_get_statistics_no_community(self): DCNL 'Testing whether the API returns error 404 if no trustchain community is loaded'
@deferred(timeout=10) DCNL def test_get_statistics(self): DCNL 'Testing whether the API returns the correct statistics'
@deferred(timeout=10) DCNL def test_get_statistics_no_data(self): DCNL 'Testing whether the API returns the correct statistics'
@deferred(timeout=10) DCNL def test_get_blocks_no_community(self): DCNL 'Testing whether the API returns error 404 if no trustchain community is loaded when requesting blocks'
@deferred(timeout=10) DCNL def test_get_blocks(self): DCNL 'Testing whether the API returns the correct blocks'
@deferred(timeout=10) DCNL def test_get_blocks_bad_limit_too_many(self): DCNL 'Testing whether the API takes large values for the limit'
@deferred(timeout=10) DCNL def test_get_blocks_bad_limit_negative(self): DCNL 'Testing whether the API takes negative values for the limit'
@deferred(timeout=10) DCNL def test_get_blocks_bad_limit_nan(self): DCNL 'Testing whether the API takes odd values for the limit'
@deferred(timeout=10) DCNL def test_get_blocks_bad_limit_nothing(self): DCNL 'Testing whether the API takes no values for the limit'
@deferred(timeout=10) DCNL def test_get_blocks_unlimited(self): DCNL 'Testing whether the API takes no limit argument'
@deferred(timeout=10) DCNL def test_get_random_torrents(self): DCNL 'Testing whether random torrents are returned if random torrents are fetched'
@deferred(timeout=10) DCNL def test_random_torrents_negative(self): DCNL 'Testing whether error 400 is returned when a negative limit is passed to the request to fetch random torrents'
@deferred(timeout=10) DCNL def test_get_torrent_trackers_404(self): DCNL 'Testing whether we get an error 404 if we are fetching the trackers of a non-existent torrent'
@deferred(timeout=10) DCNL def test_get_torrent_trackers(self): DCNL 'Testing whether fetching the trackers of a non-existent torrent is successful'
@deferred(timeout=20) DCNL @inlineCallbacks DCNL def test_check_torrent_health(self): DCNL 'Test the endpoint to fetch the health of a torrent'
@deferred(timeout=10) DCNL def test_shutdown(self): DCNL 'Testing whether the API triggers a Tribler shutdown'
@deferred(timeout=10) DCNL def test_create_torrent(self): DCNL 'Testing whether the API returns a proper base64 encoded torrent'
@deferred(timeout=10) DCNL def test_create_torrent_io_error(self): DCNL 'Testing whether the API returns a formatted 500 error if IOError is raised'
def test_get_parameters(self): DCNL 'Test the get_parameters method'
@deferred(timeout=10) DCNL def test_get_downloads_no_downloads(self): DCNL 'Testing whether the API returns an empty list when downloads are fetched but no downloads are active'
@deferred(timeout=20) DCNL def test_get_downloads(self): DCNL 'Testing whether the API returns the right download when a download is added'
@deferred(timeout=10) DCNL def test_start_download_no_uri(self): DCNL 'Testing whether an error is returned when we start a torrent download and do not pass any URI'
@deferred(timeout=10) DCNL def test_start_download_bad_params(self): DCNL 'Testing whether an error is returned when we start a torrent download and pass wrong data'
@deferred(timeout=10) DCNL def test_start_download_bad_uri(self): DCNL 'Testing whether an error is returned when we start a download from a bad URI'
@deferred(timeout=10) DCNL def test_start_download_from_file(self): DCNL 'Testing whether we can start a download from a file'
@deferred(timeout=10) DCNL def test_start_download_from_magnet(self): DCNL 'Testing whether we can start a download from a magnet'
@deferred(timeout=10) DCNL def test_start_download_from_bad_url(self): DCNL 'Testing whether starting a download from a unexisting URL gives an error'
@deferred(timeout=10) DCNL def test_remove_download_no_remove_data_param(self): DCNL 'Testing whether the API returns error 400 if the remove_data parameter is not passed'
@deferred(timeout=10) DCNL def test_remove_download_wrong_infohash(self): DCNL 'Testing whether the API returns error 404 if a non-existent download is removed'
@deferred(timeout=10) DCNL def test_remove_download(self): DCNL 'Testing whether the API returns 200 if a download is being removed'
@deferred(timeout=10) DCNL def test_stop_download_wrong_infohash(self): DCNL 'Testing whether the API returns error 404 if a non-existent download is stopped'
@deferred(timeout=10) DCNL def test_stop_download(self): DCNL 'Testing whether the API returns 200 if a download is being stopped'
@deferred(timeout=10) DCNL def test_select_download_file_range(self): DCNL 'Testing whether an error is returned when we toggle a file for inclusion out of range'
@deferred(timeout=10) DCNL def test_select_download_file(self): DCNL 'Testing whether files can be correctly toggled in a download'
@deferred(timeout=10) DCNL def test_resume_download_wrong_infohash(self): DCNL 'Testing whether the API returns error 404 if a non-existent download is resumed'
@deferred(timeout=10) DCNL def test_resume_download(self): DCNL 'Testing whether the API returns 200 if a download is being resumed'
@deferred(timeout=10) DCNL def test_recheck_download(self): DCNL 'Testing whether the API returns 200 if a download is being rechecked'
@deferred(timeout=10) DCNL def test_change_hops_error(self): DCNL 'Testing whether the API returns 400 if we supply both anon_hops and another parameter'
@deferred(timeout=10) DCNL def test_download_unknown_state(self): DCNL 'Testing whether the API returns error 400 if an unknown state is passed when modifying a download'
@deferred(timeout=10) DCNL def test_export_unknown_download(self): DCNL 'Testing whether the API returns error 404 if a non-existent download is exported'
@deferred(timeout=10) DCNL def test_export_download(self): DCNL 'Testing whether the API returns the contents of the torrent file if a download is exported'
@deferred(timeout=10) DCNL def test_change_hops(self): DCNL 'Testing whether the API returns 200 if we change the amount of hops of a download'
def test_get_parameters(self): DCNL 'Test the get_parameters method'
@deferred(timeout=10) DCNL def test_get_state(self): DCNL 'Testing whether the API returns a correct state when requested'
@deferred(timeout=20) DCNL def test_get_wallets(self): DCNL 'Testing whether the API returns wallets when we query for them'
@deferred(timeout=20) DCNL def test_create_wallet_exists(self): DCNL 'Testing whether creating a wallet that already exists throws an error'
@deferred(timeout=20) DCNL def test_create_wallet_btc_pw(self): DCNL 'Test creating a BTC wallet without specifying a password, which should throw an error'
@deferred(timeout=20) DCNL def test_create_wallet_btc(self): DCNL 'Test creating a BTC wallet'
@deferred(timeout=20) DCNL def test_create_wallet(self): DCNL 'Testing whether we can create a wallet'
@deferred(timeout=20) DCNL def test_get_wallet_balance(self): DCNL 'Testing whether we can retrieve the balance of a wallet'
@deferred(timeout=20) DCNL def test_get_wallet_transaction(self): DCNL 'Testing whether we can receive the transactions of a wallet'
@deferred(timeout=20) DCNL def test_transfer_no_btc(self): DCNL 'Test transferring assets from a non-BTC wallet'
@deferred(timeout=20) DCNL def test_transfer_not_created(self): DCNL 'Test transferring assets from a non-created BTC wallet'
@deferred(timeout=20) DCNL def test_transfer_bad_params(self): DCNL 'Test transferring assets when providing wrong parameters'
@deferred(timeout=20) DCNL def test_transfer_error(self): DCNL 'Test whether we receive the right response when we try a transfer that errors'
@deferred(timeout=20) DCNL def test_transfer(self): DCNL 'Test transferring assets'
@deferred(timeout=10) DCNL def test_channels_unknown_endpoint(self): DCNL 'Testing whether the API returns an error if an unknown endpoint is queried'
@deferred(timeout=10) DCNL def test_get_discovered_channels_no_channels(self): DCNL 'Testing whether the API returns no channels when fetching discovered channels DCNL and there are no channels in the database'
@deferred(timeout=10) DCNL def test_get_discovered_channels(self): DCNL 'Testing whether the API returns inserted channels when fetching discovered channels'
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create(self): DCNL 'Testing whether the API returns the right JSON data if a channel is created'
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create_default_mode(self): DCNL 'Testing whether the API returns the right JSON data if a channel is created'
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create_duplicate_name_error(self): DCNL 'Testing whether the API returns a formatted 500 error if DuplicateChannelNameError is raised'
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create_no_name_param(self): DCNL 'Testing whether the API returns a 400 and error if the name parameter is not passed'
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create_no_description_param(self): DCNL 'Testing whether the API returns the right JSON data if description parameter is not passed'
def setUp(self, autoload_discovery=True): DCNL 'The startup method of this class creates a fake Dispersy instance with a fake AllChannel community. It also DCNL inserts some random channels so we have some data to work with.'
def on_dispersy_create_votecast(self, cid, vote, _): DCNL 'Check whether we have the expected parameters when this method is called.'
@deferred(timeout=10) DCNL def test_subscribe_channel_already_subscribed(self): DCNL 'Testing whether the API returns error 409 when subscribing to an already subscribed channel'
@deferred(timeout=10) DCNL def test_subscribe_channel(self): DCNL 'Testing whether the API creates a request in the AllChannel community when subscribing to a channel'
@deferred(timeout=10) DCNL def test_sub_channel_throw_error(self): DCNL 'Testing whether an error is returned when we subscribe to a channel and an error pops up'
@deferred(timeout=10) DCNL def test_unsubscribe_channel_not_exist(self): DCNL 'Testing whether the API returns an error when unsubscribing if the channel with the specified CID does not exist'
@deferred(timeout=10) DCNL def test_unsubscribe_channel_not_subscribed(self): DCNL 'Testing whether the API returns error 404 when unsubscribing from an already unsubscribed channel'
@deferred(timeout=10) DCNL def test_get_subscribed_channels_no_subscriptions(self): DCNL 'Testing whether the API returns no channels when you have not subscribed to any channel'
@deferred(timeout=10) DCNL def test_get_subscribed_channels_one_subscription(self): DCNL 'Testing whether the API returns the right channel when subscribed to one channel'
@deferred(timeout=10) DCNL def test_unsubscribe_channel(self): DCNL 'Testing whether the API creates a request in the AllChannel community when unsubscribing from a channel'
@deferred(timeout=10) DCNL @inlineCallbacks DCNL def test_popular_channels_endpoint(self): DCNL 'Testing whether the API returns some popular channels if the are queried'
@deferred(timeout=10) DCNL def test_popular_channels_limit_neg(self): DCNL 'Testing whether error 400 is returned when a negative limit is passed to the request to fetch popular channels'
@deferred(timeout=10) DCNL def test_rss_feeds_endpoint_with_channel(self): DCNL 'Testing whether the API returns the right JSON data if a rss feeds from a channel are fetched'
@deferred(timeout=10) DCNL def test_add_rss_feed_no_my_channel(self): DCNL 'Testing whether the API returns a 404 if no channel has been created when adding a rss feed'
@deferred(timeout=10) DCNL def test_add_rss_feed_conflict(self): DCNL 'Testing whether the API returns error 409 if a channel the rss feed already exists'
@deferred(timeout=10) DCNL def test_add_rss_feed_with_channel(self): DCNL 'Testing whether the API returns a 200 if a channel has been created and when adding a rss feed'
@deferred(timeout=10) DCNL def test_remove_rss_feed_no_channel(self): DCNL 'Testing whether the API returns a 404 if no channel has been created when adding a rss feed'
@deferred(timeout=10) DCNL def test_remove_rss_feed_invalid_url(self): DCNL 'Testing whether the API returns a 404 and error if the url parameter does not exist in the existing feeds'
@deferred(timeout=10) DCNL def test_remove_rss_feed_with_channel(self): DCNL 'Testing whether the API returns a 200 if a channel has been created and when removing a rss feed'
@deferred(timeout=10) DCNL def test_recheck_rss_feeds_no_channel(self): DCNL 'Testing whether the API returns a 404 if no channel has been created when rechecking rss feeds'
@deferred(timeout=10) DCNL def test_recheck_rss_feeds(self): DCNL 'Testing whether the API returns a 200 if the rss feeds are rechecked in your channel'
@deferred(timeout=10) DCNL def test_get_rss_feed_no_authorization(self): DCNL 'Testing whether the API returns unauthorized error if attempting to recheck feeds in another channel'
@deferred(timeout=10) DCNL def test_get_rss_feed_no_channel_obj(self): DCNL 'Testing whether the API returns error 404 if no channel object exists in the channel manager'
@deferred(timeout=10) DCNL def test_my_channel_overview_endpoint_no_my_channel(self): DCNL 'Testing whether the API returns response code 404 if no channel has been created'
@deferred(timeout=10) DCNL def test_my_channel_overview_endpoint_with_channel(self): DCNL 'Testing whether the API returns the right JSON data if a channel overview is requested'
@deferred(timeout=10) DCNL def test_edit_my_channel_no_channel(self): DCNL 'Testing whether an error 404 is returned when trying to edit your non-existing channel'
@deferred(timeout=10) DCNL def test_edit_my_channel_no_cmty(self): DCNL 'Testing whether an error 404 is returned when trying to edit your channel without community'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_edit_channel(self): DCNL 'Testing whether a channel is correctly modified'
@deferred(timeout=10) DCNL def test_get_torrents_in_channel_invalid_cid(self): DCNL 'Testing whether the API returns error 404 if a non-existent channel is queried for torrents'
@deferred(timeout=15) DCNL @inlineCallbacks DCNL def test_get_torrents_in_channel(self): DCNL 'Testing whether the API returns inserted torrents when fetching discovered channels, with and without filter'
@deferred(timeout=10) DCNL def test_add_torrent_to_channel(self): DCNL 'Testing whether adding a torrent to your channels works'
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_with_description(self): DCNL 'Testing whether adding a torrent with a description to a channel works'
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_404(self): DCNL 'Testing whether adding a torrent to a non-existing channel returns error 404'
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_missing_parameter(self): DCNL 'Testing whether error 400 is returned when the torrent parameter is missing when adding a torrent to a channel'
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_500(self): DCNL 'Testing whether the API returns a formatted 500 error if ValueError is raised'
@deferred(timeout=10) DCNL def test_add_torrent_from_url_to_channel_with_description(self): DCNL 'Testing whether a torrent can be added to a channel using the API'
@deferred(timeout=10) DCNL def test_add_torrent_from_magnet_to_channel(self): DCNL 'Testing whether adding a torrent with a magnet link to a channel without description works'
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_404(self): DCNL 'Testing whether adding a torrent to a non-existing channel returns error code 404'
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_500(self): DCNL 'Testing whether the API returns a formatted 500 error if ValueError is raised'
@deferred(timeout=10) DCNL def test_remove_tor_unknown_channel(self): DCNL 'Testing whether the API returns an error 500 if a torrent is removed from an unknown channel'
@deferred(timeout=10) DCNL def test_remove_tor_unknown_infohash(self): DCNL 'Testing whether the API returns an error 500 if an unknown torrent is removed from a channel'
@deferred(timeout=10) DCNL def test_remove_tor_unknown_cmty(self): DCNL 'Testing whether the API returns an error 500 if torrent is removed from a channel without community'
@deferred(timeout=10) DCNL def test_remove_torrent(self): DCNL 'Testing whether the API can remove a torrent from a channel'
@deferred(timeout=10) DCNL def test_get_playlists_endpoint_without_channel(self): DCNL 'Testing whether the API returns error 404 if an unknown channel is queried for playlists'
@deferred(timeout=10) DCNL def test_playlists_endpoint_no_playlists(self): DCNL 'Testing whether the API returns the right JSON data if no playlists have been added to your channel'
@deferred(timeout=10) DCNL def test_playlists_endpoint(self): DCNL 'Testing whether the API returns the right JSON data if playlists are fetched'
@deferred(timeout=10) DCNL def test_create_playlist_no_channel(self): DCNL 'Testing whether the API returns error 404 if the channel does not exist when creating a playlist'
@deferred(timeout=10) DCNL def test_create_playlist_no_name(self): DCNL 'Testing whether the API returns error 400 if the name is missing when creating a new playlist'
@deferred(timeout=10) DCNL def test_create_playlist_no_description(self): DCNL 'Testing whether the API returns error 400 if the description is missing when creating a new playlist'
@deferred(timeout=10) DCNL def test_create_playlist_no_cmty(self): DCNL 'Testing whether the API returns error 404 if the the channel community is missing when creating a new playlist'
@deferred(timeout=10) DCNL def test_create_playlist(self): DCNL 'Testing whether the API can create a new playlist in a given channel'
@deferred(timeout=10) DCNL def test_delete_playlist_no_channel(self): DCNL 'Testing whether an error 404 is returned when a playlist is removed from a non-existent channel'
@deferred(timeout=10) DCNL def test_delete_playlist_no_playlist(self): DCNL 'Testing whether an error 404 is returned when a non-existent playlist is removed from a channel'
@deferred(timeout=10) DCNL def test_delete_playlist_no_community(self): DCNL 'Testing whether an error 404 is returned when a playlist is removed from a channel without community'
@deferred(timeout=10) DCNL def test_delete_playlist(self): DCNL 'Testing whether a playlist is correctly removed'
@deferred(timeout=10) DCNL def test_edit_playlist_no_name(self): DCNL 'Testing whether an error 400 is returned when a playlist is edit without a name parameter passed'
@deferred(timeout=10) DCNL def test_edit_playlist_no_description(self): DCNL 'Testing whether an error 400 is returned when a playlist is edit without a description parameter passed'
@deferred(timeout=10) DCNL def test_edit_playlist_no_channel(self): DCNL 'Testing whether an error 404 is returned when a playlist is edit from a non-existent channel'
@deferred(timeout=10) DCNL def test_edit_playlist_no_playlist(self): DCNL 'Testing whether an error 404 is returned when a non-existent playlist is edited'
@deferred(timeout=10) DCNL def test_edit_playlist_no_community(self): DCNL 'Testing whether an error 404 is returned when a playlist is edited from a channel without community'
@deferred(timeout=10) DCNL def test_edit_playlist(self): DCNL 'Testing whether a playlist is correctly modified'
@deferred(timeout=10) DCNL def test_add_torrent_no_channel(self): DCNL 'Testing whether an error 404 is returned when a torrent is added to a playlist with a non-existent channel'
@deferred(timeout=10) DCNL def test_add_torrent_no_playlist(self): DCNL 'Testing whether an error 404 is returned when a torrent is added to a non-existing playlist'
@deferred(timeout=10) DCNL def test_add_torrent_no_community(self): DCNL 'Testing whether an error 404 is returned when a torrent is added to a playlist without channel community'
@deferred(timeout=15) DCNL @inlineCallbacks DCNL def test_add_torrent_playlist(self): DCNL 'Testing whether a torrent can successfully be added to a playlist'
@deferred(timeout=10) DCNL def test_delete_torrent_no_channel(self): DCNL 'Testing whether an error 404 is returned when a torrent from a playlist is removed from a non-existent channel'
@deferred(timeout=10) DCNL def test_delete_torrent_no_playlist(self): DCNL 'Testing whether an error 404 is returned when a torrent from a playlist is removed from a non-existent playlist'
@deferred(timeout=10) DCNL def test_remove_torrent_no_community(self): DCNL 'Testing whether an error 404 is returned when a torrent from a playlist without channel community'
@deferred(timeout=15) DCNL @inlineCallbacks DCNL def test_remove_torrent_playlist(self): DCNL 'Testing whether a torrent can be successfully removed from a playlist'
@deferred(timeout=10) DCNL def test_get_channel_info_non_existent(self): DCNL 'Testing whether the API returns error 404 if an unknown channel is queried'
@deferred(timeout=10) DCNL def test_get_channel_info(self): DCNL 'Testing whether the API returns the right JSON data if a channel overview is requested'
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_get_torrentinfo(self): DCNL 'Testing whether the API returns a correct dictionary with torrent info.'
@deferred(timeout=10) DCNL def test_on_got_invalid_metainfo(self): DCNL 'Test whether the right operations happen when we receive an invalid metainfo object'
@deferred(timeout=10) DCNL def test_search_no_parameter(self): DCNL 'Testing whether the API returns an error 400 if no search query is passed with the request'
@deferred(timeout=10) DCNL def test_search_no_matches(self): DCNL 'Testing whether the API finds no channels/torrents when searching if they are not in the database'
@deferred(timeout=10) DCNL def test_search(self): DCNL 'Testing whether the API finds channels/torrents when searching if there is some inserted data in the database'
@deferred(timeout=10) DCNL def test_completions_no_query(self): DCNL 'Testing whether the API returns an error 400 if no query is passed when getting search completion terms'
@deferred(timeout=10) DCNL def test_completions(self): DCNL 'Testing whether the API returns the right terms when getting search completion terms'
def verify_settings(self, settings): DCNL 'Verify that the expected sections are present.'
@deferred(timeout=10) DCNL def test_get_settings(self): DCNL 'Testing whether the API returns a correct settings dictionary when the settings are requested'
@deferred(timeout=10) DCNL def test_set_settings_invalid_dict(self): DCNL 'Testing whether an error is returned if we are passing an invalid dictionary that is too deep'
@deferred(timeout=10) DCNL @inlineCallbacks DCNL def test_set_settings_no_key(self): DCNL 'Testing whether an error is returned when we try to set a non-existing key'
@deferred(timeout=10) DCNL def test_set_settings(self): DCNL 'Testing whether settings in the API can be successfully set'
@deferred(timeout=10) DCNL def test_get_circuit_no_community(self): DCNL 'Testing whether the API returns error 404 if no tunnel community is loaded'
@deferred(timeout=10) DCNL def test_get_circuits(self): DCNL 'Testing whether the API returns the correct circuits'
@blocking_call_on_reactor_thread DCNL def test_search_names_no_sort(self): DCNL 'Test whether the right amount of torrents are returned when searching for torrents in db'
@blocking_call_on_reactor_thread DCNL def test_search_names_sort(self): DCNL 'Test whether the right amount of sorted torrents are returned when searching for torrents in db'
@blocking_call_on_reactor_thread DCNL def test_search_local_torrents(self): DCNL 'Test the search procedure in the local database when searching for torrents'
@blocking_call_on_reactor_thread DCNL def test_delete_single_element(self): DCNL 'This test tests whether deleting using a single element as value works.'
@blocking_call_on_reactor_thread DCNL def test_delete_tuple(self): DCNL 'This test tests whether deleting using a tuple as value works.'
@deferred(timeout=10) DCNL def test_cleanup(self): DCNL 'Test the cleanup of a DHT session'
@deferred(timeout=10) DCNL def test_connect_to_tracker(self): DCNL 'Test the metainfo lookup of the DHT session'
@deferred(timeout=10) DCNL def test_metainfo_timeout(self): DCNL 'Test the metainfo timeout of the DHT session'
def test_methods(self): DCNL 'Test various methods in the DHT session class'
@blocking_call_on_reactor_thread DCNL def test_initialize(self): DCNL 'Test the initialization of the torrent checker'
@blocking_call_on_reactor_thread DCNL def test_reschedule_tracker_select(self): DCNL 'Test the rescheduling of the tracker select task'
@blocking_call_on_reactor_thread DCNL def test_add_gui_request_no_trackers(self): DCNL 'Test whether adding a request to fetch health of a trackerless torrent fails'
@blocking_call_on_reactor_thread DCNL def test_add_gui_request_cached(self): DCNL 'Test whether cached results of a torrent are returned when fetching the health of a torrent'
@blocking_call_on_reactor_thread DCNL def test_add_gui_request_no_tor(self): DCNL 'Test whether a Failure is raised when we try to fetch info about a torrent unknown to the database'
@deferred(timeout=30) DCNL def test_tracker_test_error_resolve(self): DCNL 'Test whether we capture the error when a tracker check fails'
@blocking_call_on_reactor_thread DCNL def test_tracker_test_invalid_tracker(self): DCNL 'Test whether we do nothing when tracker URL is invalid'
@deferred(timeout=10) DCNL def test_tracker_no_infohashes(self): DCNL 'Test the check of a tracker without associated torrents'
def test_add_content_file_and_copy(self): DCNL 'Add a single file to a TorrentDef'
def test_add_content_dir(self): DCNL 'Add a single dir to a TorrentDef'
def test_add_content_dir_and_file(self): DCNL 'Add a single dir and single file to a TorrentDef'
def test_add_content_announce_list(self): DCNL 'Add a single file with announce-list to a TorrentDef'
def test_add_content_httpseeds(self): DCNL 'Add a single file with BitTornado httpseeds to a TorrentDef'
def test_add_content_piece_length(self): DCNL 'Add a single file with piece length to a TorrentDef'
def test_add_content_file_save(self): DCNL 'Add a single file to a TorrentDef and save the latter'
@raises(ValueError) DCNL def test_add_tdef_not_finalized(self): DCNL 'Testing whether a ValueError is raised when a non-finalized tdef is added as download.'
@raises(DuplicateDownloadException) DCNL def test_add_duplicate_download(self): DCNL 'Testing whether a DuplicateDownloadException is raised when a download is added twice'
def test_load_download_pstate(self): DCNL 'Testing whether a pstate is successfully loaded'
@deferred(timeout=10) DCNL def test_dlstates_cb_error(self): DCNL 'Testing whether a download is stopped on error in the download states callback in LaunchManyCore'
@deferred(timeout=10) DCNL def test_dlstates_cb_seeding(self): DCNL 'Testing whether a download is readded when safe seeding in the download states callback in LaunchManyCore'
def test_load_checkpoint(self): DCNL 'Test whether we are resuming downloads after loading checkpoint'
def test_load_communities(self): DCNL 'Testing whether all Dispersy communities can be succesfully loaded'
@blocking_call_on_reactor_thread DCNL def test_download_file_not_running(self): DCNL 'Testing whether we do nothing if we are not running a session'
def test_check_session_timeout(self): DCNL 'Testing whether we fail if we exceed our maximum amount of retries'
def test_schedule_callback_processing(self): DCNL 'Testing whether scheduling a TFTP callback works correctly'
def test_cleanup_session(self): DCNL 'Testing whether a tftp session is correctly cleaned up'
def test_data_came_in(self): DCNL 'Testing whether we do nothing when data comes in and the handler is not running'
def test_handle_new_request_no_metadata(self): DCNL 'When the metadata_store from LaunchManyCore is not available, return DCNL from the function rather than trying to load the metadata. DCNL :return:'
def test_handle_new_request_no_torrent_store(self): DCNL 'When the torrent_store from LaunchManyCore is not available, return DCNL from the function rather than trying to load the metadata. DCNL :return:'
@raises(FileNotFound) DCNL def test_load_metadata_not_found(self): DCNL 'Testing whether a FileNotFound exception is raised when metadata cannot be found'
@raises(FileNotFound) DCNL def test_load_torrent_not_found(self): DCNL 'Testing whether a FileNotFound exception is raised when a torrent cannot be found'
def test_handle_packet_as_receiver(self): DCNL 'Testing the handle_packet_as_receiver method'
def test_handle_packet_as_sender(self): DCNL 'Testing the handle_packet_as_sender method'
def test_handle_error(self): DCNL 'Testing the error handling of a tftp handler'
def test_send_error_packet(self): DCNL 'Testing whether a correct error message is sent in the tftp handler'
@raises(InvalidStringException) DCNL def test_get_string_no_end(self): DCNL 'Testing whether the get_string method raises InvalidStringException when no zero terminator is found'
@raises(InvalidPacketException) DCNL def test_decode_options_no_option(self): DCNL 'Testing whether decoding the options raises InvalidPacketException if no options are found'
@raises(InvalidPacketException) DCNL def test_decode_options_no_value(self): DCNL 'Testing whether decoding the options raises InvalidPacketException if no value is found'
@raises(InvalidOptionException) DCNL def test_decode_options_unknown(self): DCNL 'Testing whether decoding the options raises InvalidOptionException if an invalid option is found'
@raises(InvalidOptionException) DCNL def test_decode_options_invalid(self): DCNL 'Testing whether decoding the options raises InvalidOptionException if an invalid option is found'
@raises(InvalidPacketException) DCNL def test_decode_data(self): DCNL 'Testing whether an InvalidPacketException is raised when our incoming data is too small'
@raises(InvalidPacketException) DCNL def test_decode_ack(self): DCNL 'Testing whether an InvalidPacketException is raised when our incoming ack has an invalid size'
@raises(InvalidPacketException) DCNL def test_decode_error_too_small(self): DCNL 'Testing whether an InvalidPacketException is raised when our incoming error has an invalid size'
@raises(InvalidPacketException) DCNL def test_decode_error_no_message(self): DCNL 'Testing whether an InvalidPacketException is raised when our incoming error has an empty message'
@raises(InvalidPacketException) DCNL def test_decode_error_invalid_pkg(self): DCNL 'Testing whether an InvalidPacketException is raised when our incoming error has an invalid structure'
@raises(InvalidPacketException) DCNL def test_decode_packet_too_small(self): DCNL 'Testing whether an InvalidPacketException is raised when our incoming packet is too small'
@raises(InvalidPacketException) DCNL def test_decode_packet_opcode(self): DCNL 'Testing whether an InvalidPacketException is raised when our incoming packet contains an invalid opcode'
def test_encode_packet_error(self): DCNL 'Testing whether the encoding of an error packet is correct'
def setUp(self, annotate=True): DCNL 'Create a new TriblerConfig instance'
def test_init_with_config(self): DCNL 'When creating a new instance with a configobject provided, the given options DCNL must be contained in the resulting instance.'
def test_init_without_config(self): DCNL 'A newly created TriblerConfig is valid.'
def test_write_load(self): DCNL 'When writing and reading a config the options should remain the same.'
def test_libtorrent_proxy_settings(self): DCNL 'Setting and getting of libtorrent proxy settings.'
def test_get_set_methods_general(self): DCNL 'Check whether general get and set methods are working as expected.'
def test_get_set_methods_torrent_checking(self): DCNL 'Check whether torrent checking get and set methods are working as expected.'
def test_get_set_methods_http_api(self): DCNL 'Check whether http api get and set methods are working as expected.'
def test_get_set_methods_dispersy(self): DCNL 'Check whether dispersy get and set methods are working as expected.'
def test_get_set_methods_libtorrent(self): DCNL 'Check whether libtorrent get and set methods are working as expected.'
def test_get_set_methods_mainline_dht(self): DCNL 'Check whether mainline dht get and set methods are working as expected.'
def test_get_set_methods_video_server(self): DCNL 'Check whether video server get and set methods are working as expected.'
def test_get_set_methods_tunnel_community(self): DCNL 'Check whether tunnel community get and set methods are working as expected.'
def test_get_set_methods_upgrader(self): DCNL 'Check whether upgrader get and set methods are working as expected.'
def test_get_set_methods_torrent_store(self): DCNL 'Check whether torrent store get and set methods are working as expected.'
def test_get_set_methods_wallets(self): DCNL 'Check whether wallet get and set methods are working as expected.'
def test_get_set_methods_metadata(self): DCNL 'Check whether metadata get and set methods are working as expected.'
def test_get_set_methods_torrent_collecting(self): DCNL 'Check whether torrent collecting get and set methods are working as expected.'
def test_get_set_methods_search_community(self): DCNL 'Check whether search community get and set methods are working as expected.'
def test_get_set_methods_allchannel_community(self): DCNL 'Check whether allchannel community get and set methods are working as expected.'
def test_get_set_methods_channel_community(self): DCNL 'Check whether channel community get and set methods are working as expected.'
def test_get_set_methods_preview_channel_community(self): DCNL 'Check whether preview channel community get and set methods are working as expected.'
def test_get_set_methods_trustchain_community(self): DCNL 'Check whether trustchain community get and set methods are working as expected.'
def test_get_set_methods_watch_folder(self): DCNL 'Check whether watch folder get and set methods are working as expected.'
def test_get_set_methods_credit_mining(self): DCNL 'Check whether credit mining get and set methods are working as expected.'
@deferred(timeout=20) DCNL @skipIf((sys.platform == 'win32'), 'chmod DCSP does DCSP not DCSP work DCSP on DCSP Windows') DCNL def test_torrent_download(self): DCNL 'Testing whether downloading a torrent from another peer is successful'
@deferred(timeout=20) DCNL def test_metadata_download(self): DCNL 'Testing whether downloading torrent metadata from another peer is successful'
def read_extend_metadata_close(self, conn): DCNL 'No extend metadata messages may be send and the connection DCNL needs to close.'
def send(self, data): DCNL 'send length-prefixed message'
def recv(self): DCNL 'received length-prefixed message'
def _readn(self, n): DCNL 'read n bytes from socket stream'
def catch_exception(self, type, value, tb): DCNL 'Catch unhandled exception, log it and store it to be printed at teardown time too.'
def check_exceptions(self): DCNL 'Log all unhandled exceptions, clear logged exceptions and raise to fail the currently running test.'
def add_info_about_infohash(self, infohash, seeders, leechers, downloaded=0): DCNL 'Add information about an infohash to our tracker info.'
def get_info_about_infohash(self, infohash): DCNL 'Returns information about an infohash, None if this infohash is not in our info.'
def has_info_about_infohash(self, infohash): DCNL 'Return True if we have information about a specified infohash'
def datagramReceived(self, response, (host, port)): DCNL 'Parse an incoming datagram. Check the action and based on that, send a response.'
def send_connection_reply(self, host, port): DCNL 'Send a connection reply.'
def send_scrape_reply(self, host, port, infohashes): DCNL 'Send a scrape reply.'
def send_error(self, host, port, error_msg): DCNL 'Send an error message if the client does not follow the protocol.'
def start(self): DCNL 'Start the UDP Tracker'
def stop(self): DCNL 'Stop the UDP Tracker, returns a deferred that fires when the server is closed.'
def render_GET(self, request): DCNL 'Return a bencoded dictionary with information about the queried infohashes.'
def start(self): DCNL 'Start the HTTP Tracker'
def stop(self): DCNL 'Stop the HTTP Tracker, returns a deferred that fires when the server is closed.'
def __init__(self): DCNL 'Initialize the variables of the TriblerServiceMaker and the logger.'
def start_tribler(self, options): DCNL 'Main method to startup Tribler.'
def makeService(self, options): DCNL 'Construct a Tribler service.'
def load_market_community(self, _): DCNL 'Load the Market community'
def start_tribler(self, options): DCNL 'Main method to startup Tribler.'
def makeService(self, options): DCNL 'Construct a Tribler service.'
def __init__(self): DCNL 'Initialize the variables of this service and the logger.'
def start_tunnel(self, options): DCNL 'Main method to startup a tunnel helper and add a signal handler.'
def makeService(self, options): DCNL 'Construct a tunnel helper service.'
def handle(self, **options): DCNL 'Provides feedback about the current Haystack setup.'
def handle(self, **options): DCNL 'Clears out the search index completely.'
def handle(self, **options): DCNL 'Generates a Solr schema that reflects the indexes.'
def extract_file_contents(self, file_obj, **kwargs): DCNL 'Extract text and metadata from a structured file (PDF, MS Word, etc.) DCNL Uses the Solr ExtractingRequestHandler, which is based on Apache Tika. DCNL See the Solr wiki for details: DCNL http://wiki.apache.org/solr/ExtractingRequestHandler DCNL Due to the way the ExtractingRequestHandler is implemented it completely DCNL replaces the normal Haystack indexing process with several unfortunate DCNL restrictions: only one file per request, the extracted data is added to DCNL the index with no ability to modify it, etc. To simplify the process and DCNL allow for more advanced use we\'ll run using the extract-only mode to DCNL return the extracted data without adding it to the index so we can then DCNL use it within Haystack\'s normal templating process. DCNL Returns None if metadata cannot be extracted; otherwise returns a DCNL dictionary containing at least two keys: DCNL :contents: DCNL Extracted full-text content, if applicable DCNL :metadata: DCNL key:value pairs of text strings'
def run(self, spelling_query=None, **kwargs): DCNL 'Builds and executes the query. Returns a list of search results.'
def run_mlt(self, **kwargs): DCNL 'Builds and executes the query. Returns a list of search results.'
def update(self, index, iterable, commit=True): DCNL 'Updates the backend when given a SearchIndex and a collection of DCNL documents. DCNL This method MUST be implemented by each backend, as it will be highly DCNL specific to each one.'
def remove(self, obj_or_string): DCNL 'Removes a document/object from the backend. Can be either a model DCNL instance or the identifier (i.e. ``app_name.model_name.id``) in the DCNL event the object no longer exists. DCNL This method MUST be implemented by each backend, as it will be highly DCNL specific to each one.'
def clear(self, models=None, commit=True): DCNL 'Clears the backend of all documents/objects for a collection of models. DCNL This method MUST be implemented by each backend, as it will be highly DCNL specific to each one.'
@log_query DCNL def search(self, query_string, **kwargs): DCNL 'Takes a query to search on and returns dictionary. DCNL The query should be a string that is appropriate syntax for the backend. DCNL The returned dictionary should contain the keys \'results\' and \'hits\'. DCNL The \'results\' value should be an iterable of populated SearchResult DCNL objects. The \'hits\' should be an integer count of the number of matched DCNL results the search backend found. DCNL This method MUST be implemented by each backend, as it will be highly DCNL specific to each one.'
def prep_value(self, value): DCNL 'Hook to give the backend a chance to prep an attribute value before DCNL sending it to the search engine. By default, just force it to unicode.'
def more_like_this(self, model_instance, additional_query_string=None, result_class=None): DCNL 'Takes a model object and returns results the backend thinks are similar. DCNL This method MUST be implemented by each backend, as it will be highly DCNL specific to each one.'
def extract_file_contents(self, file_obj): DCNL 'Hook to allow backends which support rich-content types such as PDF, DCNL Word, etc. extraction to process the provided file object and return DCNL the contents for indexing DCNL Returns None if metadata cannot be extracted; otherwise returns a DCNL dictionary containing at least two keys: DCNL :contents: DCNL Extracted full-text content, if applicable DCNL :metadata: DCNL key:value pairs of text strings'
def build_schema(self, fields): DCNL 'Takes a dictionary of fields and returns schema information. DCNL This method MUST be implemented by each backend, as it will be highly DCNL specific to each one.'
def build_models_list(self): DCNL 'Builds a list of models for searching. DCNL The ``search`` method should use this and the ``django_ct`` field to DCNL narrow the results (unless the user indicates not to). This helps ignore DCNL any results that are not currently handled models and ensures DCNL consistent caching.'
def __init__(self, children=None, connector=None, negated=False): DCNL 'Constructs a new Node. If no connector is given, the default will be DCNL used. DCNL Warning: You probably don\'t want to pass in the \'negated\' parameter. It DCNL is NOT the same as constructing a node and calling negate() on the DCNL result.'
def _new_instance(cls, children=None, connector=None, negated=False): DCNL 'This is called to create a new instance of this class when we need new DCNL Nodes (or subclasses) in the internal code in this class. Normally, it DCNL just shadows __init__(). However, subclasses with an __init__ signature DCNL that is not an extension of Node.__init__ might need to implement this DCNL method to allow a Node to create a new instance of them (if they have DCNL any extra setting up to do).'
def __deepcopy__(self, memodict): DCNL 'Utility method used by copy.deepcopy().'
def __len__(self): DCNL 'The size of a node if the number of children it has.'
def __bool__(self): DCNL 'For truth value testing.'
def __contains__(self, other): DCNL 'Returns True is \'other\' is a direct child of this instance.'
def add(self, node, conn_type): DCNL 'Adds a new node to the tree. If the conn_type is the same as the root\'s DCNL current connector type, the node is added to the first level. DCNL Otherwise, the whole tree is pushed down one level and a new root DCNL connector is created, connecting the existing tree and the new node.'
def negate(self): DCNL 'Negate the sense of the root connector. This reorganises the children DCNL so that the current node has a single child: a negated node containing DCNL all the previous children. This slightly odd construction makes adding DCNL new children behave more intuitively. DCNL Interpreting the meaning of this negate is up to client code. This DCNL method is useful for implementing "not" arrangements.'
def start_subtree(self, conn_type): DCNL 'Sets up internal state so that new nodes are added to a subtree of the DCNL current node. The conn_type specifies how the sub-tree is joined to the DCNL existing children.'
def end_subtree(self): DCNL 'Closes off the most recently unmatched start_subtree() call. DCNL This puts the current state into a node of the parent tree and returns DCNL the current instances state to be the parent.'
def as_query_string(self, query_fragment_callback): DCNL 'Produces a portion of the search query from the current SQ and its DCNL children.'
def split_expression(self, expression): DCNL 'Parses an expression and determines the field and filter type.'
def __getstate__(self): DCNL 'For pickling.'
def __setstate__(self, obj_dict): DCNL 'For unpickling.'
def has_run(self): DCNL 'Indicates if any query has been been run.'
def build_params(self, spelling_query=None): DCNL 'Generates a list of params to use when searching.'
def run(self, spelling_query=None, **kwargs): DCNL 'Builds and executes the query. Returns a list of search results.'
def run_mlt(self, **kwargs): DCNL 'Executes the More Like This. Returns a list of search results similar DCNL to the provided document (and optionally query).'
def run_raw(self, **kwargs): DCNL 'Executes a raw query. Returns a list of search results.'
def get_count(self): DCNL 'Returns the number of results the backend found for the query. DCNL If the query has not been run, this will execute the query and store DCNL the results.'
def get_results(self, **kwargs): DCNL 'Returns the results received from the backend. DCNL If the query has not been run, this will execute the query and store DCNL the results.'
def get_facet_counts(self): DCNL 'Returns the facet counts received from the backend. DCNL If the query has not been run, this will execute the query and store DCNL the results.'
def get_stats(self): DCNL 'Returns the stats received from the backend. DCNL If the query has not been run, this will execute the query and store DCNL the results'
def get_spelling_suggestion(self, preferred_query=None): DCNL 'Returns the spelling suggestion received from the backend. DCNL If the query has not been run, this will execute the query and store DCNL the results.'
def boost_fragment(self, boost_word, boost_value): DCNL 'Generates query fragment for boosting a single word/value pair.'
def matching_all_fragment(self): DCNL 'Generates the query that matches all documents.'
def build_query(self): DCNL 'Interprets the collected query metadata and builds the final query to DCNL be sent to the backend.'
def build_query_fragment(self, field, filter_type, value): DCNL 'Generates a query fragment from a field, filter type and a value. DCNL Must be implemented in backends as this will be highly backend specific.'
def clean(self, query_fragment): DCNL 'Provides a mechanism for sanitizing user input before presenting the DCNL value to the backend. DCNL A basic (override-able) implementation is provided.'
def add_filter(self, query_filter, use_or=False): DCNL 'Adds a SQ to the current query.'
def add_order_by(self, field): DCNL 'Orders the search result by a field.'
def clear_order_by(self): DCNL 'Clears out all ordering that has been already added, reverting the DCNL query to relevancy.'
def add_model(self, model): DCNL 'Restricts the query requiring matches in the given model. DCNL This builds upon previous additions, so you can limit to multiple models DCNL by chaining this method several times.'
def set_limits(self, low=None, high=None): DCNL 'Restricts the query by altering either the start, end or both offsets.'
def clear_limits(self): DCNL 'Clears any existing limits.'
def add_boost(self, term, boost_value): DCNL 'Adds a boosted term and the amount to boost it to the query.'
def raw_search(self, query_string, **kwargs): DCNL 'Runs a raw query (no parsing) against the backend. DCNL This method causes the SearchQuery to ignore the standard query DCNL generating facilities, running only what was provided instead. DCNL Note that any kwargs passed along will override anything provided DCNL to the rest of the ``SearchQuerySet``.'
def more_like_this(self, model_instance): DCNL 'Allows backends with support for "More Like This" to return results DCNL similar to the provided instance.'
def add_stats_query(self, stats_field, stats_facets): DCNL 'Adds stats and stats_facets queries for the Solr backend.'
def add_highlight(self, **kwargs): DCNL 'Adds highlighting to the search results.'
def add_within(self, field, point_1, point_2): DCNL 'Adds bounding box parameters to search query.'
def add_dwithin(self, field, point, distance): DCNL 'Adds radius-based parameters to search query.'
def add_distance(self, field, point): DCNL 'Denotes that results should include distance measurements from the DCNL point passed in.'
def add_field_facet(self, field, **options): DCNL 'Adds a regular facet on a field.'
def add_date_facet(self, field, start_date, end_date, gap_by, gap_amount=1): DCNL 'Adds a date-based facet on a field.'
def add_query_facet(self, field, query): DCNL 'Adds a query facet on a field.'
def add_narrow_query(self, query): DCNL 'Narrows a search to a subset of all documents per the query. DCNL Generally used in conjunction with faceting.'
def set_result_class(self, klass): DCNL 'Sets the result class to use for results. DCNL Overrides any previous usages. If ``None`` is provided, Haystack will DCNL revert back to the default ``SearchResult`` object.'
def using(self, using=None): DCNL 'Allows for overriding which connection should be used. This DCNL disables the use of routers when performing the query. DCNL If ``None`` is provided, it has no effect on what backend is used.'
def _reset(self): DCNL 'Resets the instance\'s internal state to appear as though no query has DCNL been run before. Only need to tweak a few variables we check.'
def reset_sessions(self): DCNL 'Reset any transient connections, file handles, etc.'
def setup(self): DCNL 'Defers loading until needed.'
def _from_python(self, value): DCNL 'Converts Python values to a string for Whoosh. DCNL Code courtesy of pysolr.'
def _to_python(self, value): DCNL 'Converts values from Whoosh to native Python values. DCNL A port of the same method in pysolr, as they deal with data the same way.'
def clean(self, query_fragment): DCNL 'Provides a mechanism for sanitizing user input before presenting the DCNL value to the backend. DCNL Whoosh 1.X differs here in that you can no longer use a backslash DCNL to escape reserved characters. Instead, the whole word should be DCNL quoted.'
def clear(self, models=None, commit=True): DCNL 'Clears the backend of all documents/objects for a collection of models. DCNL :param models: List or tuple of models to clear. DCNL :param commit: Not used.'
def setup(self): DCNL 'Defers loading until needed.'
def _iso_datetime(self, value): DCNL 'If value appears to be something datetime-like, return it in ISO format. DCNL Otherwise, return None.'
def _from_python(self, value): DCNL 'Convert more Python data types to ES-understandable JSON.'
def _to_python(self, value): DCNL 'Convert values from ElasticSearch to native Python values.'
def run(self, spelling_query=None, **kwargs): DCNL 'Builds and executes the query. Returns a list of search results.'
def run_mlt(self, **kwargs): DCNL 'Builds and executes the query. Returns a list of search results.'
def get_form_kwargs(self): DCNL 'Returns the keyword arguments for instantiating the form.'
def get(self, request, *args, **kwargs): DCNL 'Handles GET requests and instantiates a blank version of the form.'
def has_default(self): DCNL 'Returns a boolean of whether this field has a default value.'
@property DCNL def default(self): DCNL 'Returns the default value for the field.'
def prepare(self, obj): DCNL 'Takes data from the provided object and prepares it for storage in the DCNL index.'
def resolve_attributes_lookup(self, current_objects, attributes): DCNL 'Recursive method that looks, for one or more objects, for an attribute that can be multiple DCNL objects (relations) deep.'
def split_model_attr_lookups(self): DCNL 'Returns list of nested attributes for looking through the relation.'
@classmethod DCNL def get_iterable_objects(cls, current_objects): DCNL 'Returns iterable of objects that contain data. For example, resolves Django ManyToMany relationship DCNL so the attributes of the related models can then be accessed.'
def prepare_template(self, obj): DCNL 'Flattens an object for indexing. DCNL This loads a template DCNL (``search/indexes/{app_label}/{model_name}_{field_name}.txt``) and DCNL returns the result of rendering that template. ``object`` will be in DCNL its context.'
def convert(self, value): DCNL 'Handles conversion between the data found and the type of the field. DCNL Extending classes should override this method and provide correct DCNL data coercion.'
def get_model(self): DCNL 'Should return the ``Model`` class (not an instance) that the rest of the DCNL ``SearchIndex`` should use. DCNL This method is required & you must override it to return the correct class.'
def index_queryset(self, using=None): DCNL 'Get the default QuerySet to index when doing a full update. DCNL Subclasses can override this method to avoid indexing certain objects.'
def read_queryset(self, using=None): DCNL 'Get the default QuerySet for read actions. DCNL Subclasses can override this method to work with other managers. DCNL Useful when working with default managers that filter some objects.'
def build_queryset(self, using=None, start_date=None, end_date=None): DCNL 'Get the default QuerySet to index when doing an index update. DCNL Subclasses can override this method to take into account related DCNL model modification times. DCNL The default is to use ``SearchIndex.index_queryset`` and filter DCNL based on ``SearchIndex.get_updated_field``'
def prepare(self, obj): DCNL 'Fetches and adds/alters data before indexing.'
def get_content_field(self): DCNL 'Returns the field that supplies the primary document to be indexed.'
def get_field_weights(self): DCNL 'Returns a dict of fields with weight values'
def update(self, using=None): DCNL 'Updates the entire index. DCNL If ``using`` is provided, it specifies which connection should be DCNL used. Default relies on the routers to decide which backend should DCNL be used.'
def update_object(self, instance, using=None, **kwargs): DCNL 'Update the index for a single object. Attached to the class\'s DCNL post-save hook. DCNL If ``using`` is provided, it specifies which connection should be DCNL used. Default relies on the routers to decide which backend should DCNL be used.'
def remove_object(self, instance, using=None, **kwargs): DCNL 'Remove an object from the index. Attached to the class\'s DCNL post-delete hook. DCNL If ``using`` is provided, it specifies which connection should be DCNL used. Default relies on the routers to decide which backend should DCNL be used.'
def clear(self, using=None): DCNL 'Clears the entire index. DCNL If ``using`` is provided, it specifies which connection should be DCNL used. Default relies on the routers to decide which backend should DCNL be used.'
def reindex(self, using=None): DCNL 'Completely clear the index for this model and rebuild it. DCNL If ``using`` is provided, it specifies which connection should be DCNL used. Default relies on the routers to decide which backend should DCNL be used.'
def get_updated_field(self): DCNL 'Get the field name that represents the updated date for the model. DCNL If specified, this is used by the reindex command to filter out results DCNL from the QuerySet, enabling you to reindex only recent records. This DCNL method should either return None (reindex everything always) or a DCNL string of the Model\'s DateField/DateTimeField name.'
def should_update(self, instance, **kwargs): DCNL 'Determine if an object should be updated in the index. DCNL It\'s useful to override this when an object may save frequently and DCNL cause excessive reindexing. You should check conditions on the instance DCNL and return False if it is not to be indexed. DCNL By default, returns True (always reindex).'
def load_all_queryset(self): DCNL 'Provides the ability to override how objects get loaded in conjunction DCNL with ``SearchQuerySet.load_all``. DCNL This is useful for post-processing the results from the query, enabling DCNL things like adding ``select_related`` or filtering certain data. DCNL By default, returns ``all()`` on the model\'s default manager.'
def should_skip_field(self, field): DCNL 'Given a Django model field, return if it should be included in the DCNL contributed SearchFields.'
def get_index_fieldname(self, f): DCNL 'Given a Django field, return the appropriate index fieldname.'
def get_fields(self, fields=None, excludes=None): DCNL 'Given any explicit fields to include and fields to exclude, add DCNL additional fields based on the associated model.'
def content_type(self): DCNL 'Returns the content type for the result\'s model instance.'
def get_additional_fields(self): DCNL 'Returns a dictionary of all of the fields from the raw result. DCNL Useful for serializing results. Only returns what was seen from the DCNL search engine, so it may have extra fields Haystack\'s indexes aren\'t DCNL aware of.'
def get_stored_fields(self): DCNL 'Returns a dictionary of all of the stored fields from the SearchIndex. DCNL Useful for serializing results. Only returns the fields Haystack\'s DCNL indexes are aware of as being \'stored\'.'
def __getstate__(self): DCNL 'Returns a dictionary representing the ``SearchResult`` in order to DCNL make it pickleable.'
def __setstate__(self, data_dict): DCNL 'Updates the object\'s attributes according to data passed by pickle.'
def __getstate__(self): DCNL 'For pickling.'
def __setstate__(self, data_dict): DCNL 'For unpickling.'
def __getitem__(self, k): DCNL 'Retrieves an item or slice from the set of results.'
def all(self): DCNL 'Returns all results for the query.'
def none(self): DCNL 'Returns an empty result list for the query.'
def filter(self, *args, **kwargs): DCNL 'Narrows the search based on certain attributes and the default operator.'
def exclude(self, *args, **kwargs): DCNL 'Narrows the search by ensuring certain attributes are not included.'
def filter_and(self, *args, **kwargs): DCNL 'Narrows the search by looking for (and including) certain attributes.'
def filter_or(self, *args, **kwargs): DCNL 'Narrows the search by ensuring certain attributes are not included.'
def order_by(self, *args): DCNL 'Alters the order in which the results should appear.'
def highlight(self, **kwargs): DCNL 'Adds highlighting to the results.'
def models(self, *models): DCNL 'Accepts an arbitrary number of Model classes to include in the search.'
def result_class(self, klass): DCNL 'Allows specifying a different class to use for results. DCNL Overrides any previous usages. If ``None`` is provided, Haystack will DCNL revert back to the default ``SearchResult`` object.'
def boost(self, term, boost): DCNL 'Boosts a certain aspect of the query.'
def facet(self, field, **options): DCNL 'Adds faceting to a query for the provided field.'
def within(self, field, point_1, point_2): DCNL 'Spatial: Adds a bounding box search to the query.'
def dwithin(self, field, point, distance): DCNL 'Spatial: Adds a distance-based search to the query.'
def stats(self, field): DCNL 'Adds stats to a query for the provided field.'
def stats_facet(self, field, facet_fields=None): DCNL 'Adds stats facet for the given field and facet_fields represents DCNL the faceted fields.'
def distance(self, field, point): DCNL 'Spatial: Denotes results must have distance measurements from the DCNL provided point.'
def date_facet(self, field, start_date, end_date, gap_by, gap_amount=1): DCNL 'Adds faceting to a query for the provided field by date.'
def query_facet(self, field, query): DCNL 'Adds faceting to a query for the provided field with a custom query.'
def narrow(self, query): DCNL 'Pushes existing facet choices into the search.'
def raw_search(self, query_string, **kwargs): DCNL 'Passes a raw query directly to the backend.'
def load_all(self): DCNL 'Efficiently populates the objects in the search results.'
def auto_query(self, query_string, fieldname=u'content'): DCNL 'Performs a best guess constructing the search query. DCNL This method is somewhat naive but works well enough for the simple, DCNL common cases.'
def autocomplete(self, **kwargs): DCNL 'A shortcut method to perform an autocomplete search. DCNL Must be run against fields that are either ``NgramField`` or DCNL ``EdgeNgramField``.'
def using(self, connection_name): DCNL 'Allows switching which connection the ``SearchQuerySet`` uses to DCNL search in.'
def count(self): DCNL 'Returns the total number of matching results.'
def best_match(self): DCNL 'Returns the best/top search result that matches the query.'
def latest(self, date_field): DCNL 'Returns the most recent search result that matches the query.'
def more_like_this(self, model_instance): DCNL 'Finds similar results to the object passed in.'
def facet_counts(self): DCNL 'Returns the facet counts found by the query. DCNL This will cause the query to execute and should generally be used when DCNL presenting the data.'
def stats_results(self): DCNL 'Returns the stats results found by the query.'
def set_spelling_query(self, spelling_query): DCNL 'Set the exact text to be used to generate spelling suggestions DCNL When making complicated queries, such as the alt parser mechanism DCNL used by Solr dismax/edismax, this provides a convenient way to set DCNL the a simple text string which will be used to generate spelling DCNL suggestions without including unnecessary syntax.'
def spelling_suggestion(self, preferred_query=None): DCNL 'Returns the spelling suggestion found by the query. DCNL To work, you must set ``INCLUDE_SPELLING`` within your connection\'s DCNL settings dictionary to ``True``. Otherwise, ``None`` will be returned. DCNL This will cause the query to execute and should generally be used when DCNL presenting the data.'
def values(self, *fields): DCNL 'Returns a list of dictionaries, each containing the key/value pairs for DCNL the result, exactly like Django\'s ``ValuesQuerySet``.'
def values_list(self, *fields, **kwargs): DCNL 'Returns a list of field values as tuples, exactly like Django\'s DCNL ``QuerySet.values``. DCNL Optionally accepts a ``flat=True`` kwarg, which in the case of a DCNL single field being provided, will return a flat list of that field DCNL rather than a list of tuples.'
def load_all_queryset(self, model, queryset): DCNL 'Allows for specifying a custom ``QuerySet`` that changes how ``load_all`` DCNL will fetch records for the provided model. DCNL This is useful for post-processing the results from the query, enabling DCNL things like adding ``select_related`` or filtering certain data.'
def get_search_queryset(self): DCNL 'Returns a new SearchQuerySet object.  Subclasses can override this method DCNL to easily customize the behavior of the Manager.'
def no_query_found(self): DCNL 'Determines the behavior when no query was found. DCNL By default, no results are returned (``EmptySearchQuerySet``). DCNL Should you want to show all results, override this method in your DCNL own ``SearchForm`` subclass and do ``return self.searchqueryset.all()``.'
def get_models(self): DCNL 'Return a list of the selected models.'
def __call__(self, request): DCNL 'Generates the actual response to the search. DCNL Relies on internal, overridable methods to construct the response.'
def build_form(self, form_kwargs=None): DCNL 'Instantiates the form the class should use to process the search query.'
def get_query(self): DCNL 'Returns the query provided by the user. DCNL Returns an empty string if the query is invalid.'
def get_results(self): DCNL 'Fetches the results via the form. DCNL Returns an empty list if there\'s no query to search with.'
def build_page(self): DCNL 'Paginates the results appropriately. DCNL In case someone does not want to use Django\'s built-in pagination, it DCNL should be a simple matter to override this method to do what they would DCNL like.'
def extra_context(self): DCNL 'Allows the addition of more context variables as needed. DCNL Must return a dictionary.'
def create_response(self): DCNL 'Generates the actual HttpResponse to send back to the user.'
def setup(self): DCNL 'A hook for setting up anything necessary for DCNL ``handle_save/handle_delete`` to be executed. DCNL Default behavior is to do nothing (``pass``).'
def teardown(self): DCNL 'A hook for tearing down anything necessary for DCNL ``handle_save/handle_delete`` to no longer be executed. DCNL Default behavior is to do nothing (``pass``).'
def handle_save(self, sender, instance, **kwargs): DCNL 'Given an individual model instance, determine which backends the DCNL update should be sent to & update the object on those backends.'
def handle_delete(self, sender, instance, **kwargs): DCNL 'Given an individual model instance, determine which backends the DCNL delete should be sent to & delete the object on those backends.'
def test_get_form_kwargs(self): DCNL 'Test getting the search view form kwargs.'
def test_search_view_response(self): DCNL 'Test the generic SearchView response.'
def test_search_view_form_valid(self): DCNL 'Test the generic SearchView form is valid.'
def test_search_view_form_invalid(self): DCNL 'Test the generic SearchView form is invalid.'
def get_request(self, url, method=u'get', data=None, **kwargs): DCNL 'Gets the request object for the view. DCNL :param url: a mock url to use for the request DCNL :param method: the http method to use for the request (\'get\', \'post\', DCNL etc).'
@patch(u'haystack.management.commands.update_index.Command.update_backend') DCNL def test_update_index_default_using(self, m): DCNL 'update_index uses default index when --using is not present'
@patch(u'haystack.management.commands.update_index.Command.update_backend') DCNL def test_update_index_using(self, m): DCNL 'update_index only applies to indexes specified with --using'
@patch(u'haystack.loading.ConnectionHandler.__getitem__') DCNL def test_clear_index_default_using(self, m): DCNL 'clear_index uses all keys when --using is not present'
@patch(u'haystack.loading.ConnectionHandler.__getitem__') DCNL def test_clear_index_using(self, m): DCNL 'clear_index only applies to indexes specified with --using'
@patch(u'haystack.loading.ConnectionHandler.__getitem__') DCNL @patch(u'haystack.management.commands.update_index.Command.update_backend') DCNL def test_rebuild_index_default_using(self, m1, m2): DCNL 'rebuild_index uses default index when --using is not present'
@patch(u'haystack.loading.ConnectionHandler.__getitem__') DCNL @patch(u'haystack.management.commands.update_index.Command.update_backend') DCNL def test_rebuild_index_using(self, m1, m2): DCNL 'rebuild_index passes --using to clear_index and update_index'
@patch(u'haystack.management.commands.update_index.Command.handle') DCNL @patch(u'haystack.management.commands.clear_index.Command.handle') DCNL def test_rebuild_index_nocommit(self, *mocks): DCNL 'Confirm that command-line option parsing produces the same results as using call_command() directly, DCNL mostly as a sanity check for the logic in rebuild_index which combines the option_lists for its DCNL component commands.'
def test_and_or(self): DCNL 'Combining AND queries with OR should give DCNL AND(OR(a, b), OR(c, d))'
def test_or_and(self): DCNL 'Combining OR queries with AND should give DCNL OR(AND(a, b), AND(c, d))'
def test_dictionary_lookup(self): DCNL 'Ensure doing a dictionary lookup raises a TypeError so DCNL EmptySearchQuerySets can be used in templates.'
def test_query__in_empty_list(self): DCNL 'Confirm that an empty list avoids a Elasticsearch exception'
def test_query__in_empty_list(self): DCNL 'Confirm that an empty list avoids a Elasticsearch exception'
def test_build_query_with_dwithin_range(self): DCNL 'Test build_search_kwargs with dwithin range for Elasticsearch versions < 1.0.0'
def test_build_query_with_dwithin_range(self): DCNL 'Test build_search_kwargs with dwithin range for Elasticsearch versions >= 1.0.0'
def test_query__in_empty_list(self): DCNL 'Confirm that an empty list avoids a Solr exception'
def test_more_like_this_custom_result_class(self): DCNL 'Ensure that swapping the ``result_class`` works'
def test_query__in_empty_list(self): DCNL 'Confirm that an empty list avoids a Solr exception'
def verify_indexed_documents(self): DCNL 'Confirm that the documents in the search index match the database'
def test_age_with_time_zones(self): DCNL 'Haystack should use django.utils.timezone.now'
def test_build_query_with_dwithin_range(self): DCNL 'Test build_search_kwargs with dwithin range for Elasticsearch versions < 1.0.0'
def test_build_query_with_dwithin_range(self): DCNL 'Test build_search_kwargs with dwithin range for Elasticsearch versions >= 1.0.0'
def handle(self, *args, **options): DCNL 'Publishes Deis platform state from the database to etcd.'
def to_representation(self, obj): DCNL 'Serialize the field\'s JSON data, for read operations.'
def to_internal_value(self, data): DCNL 'Deserialize the field\'s JSON data, for write operations.'
def to_internal_value(self, data): DCNL 'Deserialize the field\'s JSON integer data.'
def to_internal_value(self, data): DCNL 'Deserialize the field\'s JSON string data.'
def get_validators(self): DCNL 'Hack to remove DRF\'s UniqueTogetherValidator when it concerns the UUID. DCNL See https://github.com/deis/deis/pull/2898#discussion_r23105147'
def validate_domain(self, value): DCNL 'Check that the hostname is valid'
def db_type(self, connection=None): DCNL 'Return the database column type for a UuidField.'
def pre_save(self, model_instance, add): DCNL 'Initialize an empty field with a new UUID before it is saved.'
def formfield(self, **kwargs): DCNL 'Tell forms how to represent this UuidField.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_build(self): DCNL 'Test that a null build is created and that users can post new builds'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_response_data(self): DCNL 'Test that the serialized response contains only relevant data.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_build_str(self): DCNL 'Test the text representation of a build.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_admin_can_create_builds_on_other_apps(self): DCNL 'If a user creates an application, an administrator should be able DCNL to push builds.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_unauthorized_user_cannot_modify_build(self): DCNL 'An unauthorized user should not be able to modify other builds. DCNL Since an unauthorized user can\'t access the application, these DCNL requests should return a 403.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_new_build_does_not_scale_up_automatically(self): DCNL 'After the first initial deploy, if the containers are scaled down to zero, DCNL they should stay that way on a new release.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_config(self): DCNL 'Test that config is auto-created for a new app and that DCNL config can be updated using a PATCH'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_overlapping_config(self): DCNL 'Test that config won\'t be created if a similar operation DCNL is in progress for that app.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_response_data(self): DCNL 'Test that the serialized response contains only relevant data.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_response_data_types_converted(self): DCNL 'Test that config data is converted into the correct type.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_config_set_same_key(self): DCNL 'Test that config sets on the same key function properly'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_config_set_unicode(self): DCNL 'Test that config sets with unicode values are accepted.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_config_str(self): DCNL 'Test the text representation of a node.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_valid_config_keys(self): DCNL 'Test that valid config keys are accepted.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_invalid_config_keys(self): DCNL 'Test that invalid config keys are rejected.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_admin_can_create_config_on_other_apps(self): DCNL 'If a non-admin creates an app, an administrator should be able to set config DCNL values for that app.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_limit_memory(self): DCNL 'Test that limit is auto-created for a new app and that DCNL limits can be updated using a PATCH'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_limit_cpu(self): DCNL 'Test that CPU limits can be set'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_tags(self): DCNL 'Test that tags can be set on an application'
def test_config_owner_is_requesting_user(self): DCNL 'Ensure that setting the config value is owned by the requesting user DCNL See https://github.com/deis/deis/issues/2650'
def test_unauthorized_user_cannot_modify_config(self): DCNL 'An unauthorized user should not be able to modify other config. DCNL Since an unauthorized user can\'t access the application, these DCNL requests should return a 403.'
@mock.patch(u'requests.get', mock_status_ok) DCNL @mock.patch(u'time.sleep', (lambda func: func)) DCNL def test_app_healthcheck_good(self): DCNL 'If a user deploys an app with a config value set for HEALTHCHECK_URL, the controller DCNL should check that the application responds with a 200 OK.'
@mock.patch(u'requests.get', mock_status_not_found) DCNL @mock.patch(u'api.models.get_etcd_client', (lambda func: func)) DCNL @mock.patch(u'time.sleep', (lambda func: func)) DCNL @mock.patch(u'api.models.logger') DCNL def test_app_healthcheck_bad(self, mock_logger): DCNL 'If a user deploys an app with a config value set for HEALTHCHECK_URL, the controller DCNL should check that the application responds with a 200 OK. If it\'s down, the app should be DCNL rolled back.'
@mock.patch(u'requests.get', mock_status_not_found) DCNL @mock.patch(u'api.models.get_etcd_client', (lambda func: func)) DCNL @mock.patch(u'time.sleep') DCNL def test_app_backoff_interval(self, mock_time): DCNL 'Ensure that when a healthcheck fails, a backoff strategy is used before trying again.'
@mock.patch(u'requests.get', mock_status_ok) DCNL @mock.patch(u'time.sleep') DCNL def test_app_healthcheck_initial_delay(self, mock_time): DCNL 'Ensure that when an initial delay is set, the request will sleep for x seconds, where DCNL x is the number of seconds in the initial timeout.'
@mock.patch(u'requests.get') DCNL @mock.patch(u'time.sleep', (lambda func: func)) DCNL def test_app_healthcheck_timeout(self, mock_request): DCNL 'Ensure when a timeout value is set, the controller respects that value DCNL when making a request.'
@mock.patch(u'requests.get', mock_request_connection_error) DCNL @mock.patch(u'time.sleep', (lambda func: func)) DCNL def test_app_healthcheck_connection_error(self): DCNL 'If a user deploys an app with a config value set for HEALTHCHECK_URL but the app DCNL returns a connection error, the controller should continue checking until either the app DCNL responds or the app fails to respond within the timeout. DCNL NOTE (bacongobbler): the Docker userland proxy listens for connections and returns a DCNL ConnectionError, hence the unit test.'
def test_auth(self): DCNL 'Test that a user can register using the API, login and logout'
@override_settings(REGISTRATION_MODE=u'disabled') DCNL def test_auth_registration_disabled(self): DCNL 'test that a new user cannot register when registration is disabled.'
@override_settings(REGISTRATION_MODE=u'admin_only') DCNL def test_auth_registration_admin_only_fails_if_not_admin(self): DCNL 'test that a non superuser cannot register when registration is admin only.'
@override_settings(REGISTRATION_MODE=u'admin_only') DCNL def test_auth_registration_admin_only_works(self): DCNL 'test that a superuser can register when registration is admin only.'
@override_settings(REGISTRATION_MODE=u'not_a_mode') DCNL def test_auth_registration_fails_with_nonexistant_mode(self): DCNL 'test that a registration should fail with a nonexistant mode'
def test_cancel(self): DCNL 'Test that a registered user can cancel her account.'
def test_passwd(self): DCNL 'Test that a registered user can change the password.'
def test_change_user_passwd(self): DCNL 'Test that an administrator can change a user\'s password, while a regular user cannot.'
def test_regenerate(self): DCNL 'Test that token regeneration works'
def test_container_state_good(self): DCNL 'Test that the finite state machine transitions with a good scheduler'
def test_container_state_protected(self): DCNL 'Test that you cannot directly modify the state'
def test_container_str(self): DCNL 'Test the text representation of a container.'
def test_admin_can_manage_other_containers(self): DCNL 'If a non-admin user creates a container, an administrator should be able to DCNL manage it.'
def test_scale_without_build_should_error(self): DCNL 'A user should not be able to scale processes unless a build is present.'
def test_command_good(self): DCNL 'Test the default command for each container workflow'
def test_run_command_good(self): DCNL 'Test the run command for each container workflow'
def test_scaling_does_not_add_run_proctypes_to_structure(self): DCNL 'Test that app info doesn\'t show transient "run" proctypes.'
def test_scale_with_unauthorized_user_returns_403(self): DCNL 'An unauthorized user should not be able to access an app\'s resources. DCNL If an unauthorized user is trying to scale an app he or she does not have access to, it DCNL should return a 403.'
def test_modified_procfile_from_build_removes_containers(self): DCNL 'When a new procfile is posted which removes a certain process type, deis should stop the DCNL existing containers.'
def run_tests(self, test_labels, extra_tests=None, **kwargs): DCNL 'Run tests with all but critical log messages disabled.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_release(self): DCNL 'Test that a release is created when an app is created, and DCNL that updating config or build or triggers a new release'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_release_str(self): DCNL 'Test the text representation of a release.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_release_summary(self): DCNL 'Test the text summary of a release.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_admin_can_create_release(self): DCNL 'If a non-user creates an app, an admin should be able to create releases.'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_unauthorized_user_cannot_modify_release(self): DCNL 'An unauthorized user should not be able to modify other releases. DCNL Since an unauthorized user should not know about the application at all, these DCNL requests should return a 404.'
def _check_key(self, pubkey): DCNL 'Test that a user can add, remove and manage their SSH public keys'
def _check_bad_key(self, pubkey): DCNL 'Test that a user cannot add invalid SSH public keys'
def _check_duplicate_key(self, pubkey, pubkey2): DCNL 'Test that a user cannot add a duplicate key'
def test_rsa_key_str(self): DCNL 'Test the text representation of a key'
def test_admin_can_list(self): DCNL 'Check that an administrator can list an app\'s perms'
def test_unauthorized_user_cannot_modify_perms(self): DCNL 'An unauthorized user should not be able to modify other apps\' permissions. DCNL Since an unauthorized user should not know about the application at all, these DCNL requests should return a 404.'
def test_collaborator_cannot_share(self): DCNL 'An collaborator should not be able to modify the app\'s permissions.'
def test_response_data(self): DCNL 'Test that the serialized response contains only relevant data.'
def test_delete_domain_does_not_remove_latest(self): DCNL 'https://github.com/deis/deis/issues/3239'
def test_delete_domain_does_not_remove_others(self): DCNL 'https://github.com/deis/deis/issues/3475'
def test_manage_domain_wildcard(self): DCNL 'Wildcards are not allowed for now.'
def test_admin_can_add_domains_to_other_apps(self): DCNL 'If a non-admin user creates an app, an administrator should be able to add DCNL domains to it.'
def test_unauthorized_user_cannot_modify_domain(self): DCNL 'An unauthorized user should not be able to modify other domains. DCNL Since an unauthorized user should not know about the application at all, these DCNL requests should return a 404.'
def test_deis_version_header_good(self): DCNL 'Test that when the version header is sent, the request is accepted.'
def test_deis_version_header_bad(self): DCNL 'Test that when an improper version header is sent, the request is declined.'
def test_deis_version_header_not_present(self): DCNL 'Test that when the version header is not present, the request is accepted.'
def test_push_hook(self): DCNL 'Test creating a Push via the API'
def test_push_abuse(self): DCNL 'Test a user pushing to an unauthorized application'
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_build_hook(self): DCNL 'Test creating a Build via an API Hook'
def test_build_hook_procfile(self): DCNL 'Test creating a Procfile build via an API Hook'
def test_build_hook_dockerfile(self): DCNL 'Test creating a Dockerfile build via an API Hook'
def test_config_hook(self): DCNL 'Test reading Config via an API Hook'
def test_admin_can_hook(self): DCNL 'Administrator should be able to create build hooks on non-admin apps.'
def test_app(self): DCNL 'Test that a user can create, read, update and delete an application'
def test_response_data(self): DCNL 'Test that the serialized response contains only relevant data.'
@mock.patch(u'api.models.logger') DCNL def test_app_release_notes_in_logs(self, mock_logger): DCNL 'Verifies that an app\'s release summary is dumped into the logs.'
def test_app_reserved_names(self): DCNL 'Nobody should be able to create applications with names which are reserved.'
def test_app_structure_is_valid_json(self): DCNL 'Application structures should be valid JSON objects.'
@mock.patch(u'requests.post', mock_status_ok) DCNL @mock.patch(u'api.models.logger') DCNL def test_admin_can_manage_other_apps(self, mock_logger): DCNL 'Administrators of Deis should be able to manage all applications.'
def test_admin_can_see_other_apps(self): DCNL 'If a user creates an application, the administrator should be able DCNL to see it.'
def test_run_without_auth(self): DCNL 'If the administrator has not provided SSH private key for run commands, DCNL make sure a friendly error message is provided on run'
def test_run_without_release_should_error(self): DCNL 'A user should not be able to run a one-off command unless a release DCNL is present.'
def test_unauthorized_user_cannot_see_app(self): DCNL 'An unauthorized user should not be able to access an app\'s resources. DCNL Since an unauthorized user can\'t access the application, these DCNL tests should return a 403, but currently return a 404. FIXME!'
def test_create_certificate_with_domain(self): DCNL 'Tests creating a certificate.'
def test_create_wildcard_certificate(self): DCNL 'Tests creating a wildcard certificate, which should be disabled.'
def test_create_certificate_with_different_common_name(self): DCNL 'In some cases such as with SAN certificates, the certificate can cover more DCNL than a single domain. In that case, we want to be able to specify the common DCNL name for the certificate/key.'
def test_get_certificate_screens_data(self): DCNL 'When a user retrieves a certificate, only the common name and expiry date should be DCNL displayed.'
def test_certficate_denied_requests(self): DCNL 'Disallow put/patch requests'
def test_delete_certificate(self): DCNL 'Destroying a certificate should generate a 204 response'
def log(self, message, level=logging.INFO): DCNL 'Logs a message in the context of this application. DCNL This prefixes log messages with an application "tag" that the customized deis-logspout will DCNL be on the lookout for.  When it\'s seen, the message-- usually an application event of some DCNL sort like releasing or scaling, will be considered as "belonging" to the application DCNL instead of the controller and will be handled accordingly.'
def create(self, *args, **kwargs): DCNL 'Create a new application with an initial config and release'
def delete(self, *args, **kwargs): DCNL 'Delete this application including all containers'
def _clean_app_logs(self): DCNL 'Delete application logs stored by the logger component'
def scale(self, user, structure): DCNL 'Scale containers up or down to match requested structure.'
def _start_containers(self, to_add): DCNL 'Creates and starts containers via the scheduler'
def _restart_containers(self, to_restart): DCNL 'Restarts containers via the scheduler'
def _destroy_containers(self, to_destroy): DCNL 'Destroys containers via the scheduler'
def deploy(self, user, release): DCNL 'Deploy a new release to this application'
def _default_scale(self, user, release): DCNL 'Scale to default structure based on release type'
def logs(self, log_lines=str(settings.LOG_LINES)): DCNL 'Return aggregated log data for this application.'
def run(self, user, command): DCNL 'Run a one-off command in an ephemeral app container.'
def run(self, command): DCNL 'Run a one-off command'
def save(self, **kwargs): DCNL 'merge the old config with the new'
def new(self, user, config, build, summary=None, source_version=u'latest'): DCNL 'Create a new application release using the provided Build and Config DCNL on behalf of a user. DCNL Releases start at v1 and auto-increment.'
def previous(self): DCNL 'Return the previous Release to this one. DCNL :return: the previous :class:`Release`, or None'
def forwards(self, orm): DCNL 'Drop django-allauth tables.'
def forwards(self, orm): DCNL 'Drop socialaccount tables.'
def forwards(self, orm): DCNL 'Drop django-celery tables.'
def forwards(self, orm): DCNL 'Set empty Config fields to an empty dict.'
def forwards(self, orm): DCNL 'Create custom model permissions.'
def has_permission(self, request, view): DCNL 'Return `True` if permission is granted, `False` otherwise.'
def has_permission(self, request, view): DCNL 'Return `True` if permission is granted, `False` otherwise.'
def has_permission(self, request, view): DCNL 'Return `True` if permission is granted, `False` otherwise.'
def has_permission(self, request, view): DCNL 'If settings.REGISTRATION_MODE does not exist, such as during a test, return True DCNL Return `True` if permission is granted, `False` otherwise.'
def has_permission(self, request, view): DCNL 'Return `True` if permission is granted, `False` otherwise.'
def has_permission(self, request, view): DCNL 'Return `True` if permission is granted, `False` otherwise.'
def authenticate(self, request): DCNL 'Authenticate the request for anyone!'
def authenticate(self, request): DCNL 'Authenticate the request for anyone or if a valid token is provided, a user.'
def get_object(self): DCNL 'Retrieve the object based on the latest release\'s value'
def list(self, request, *args, **kwargs): DCNL 'HACK: Instead of filtering by the queryset, we limit the queryset to list only the apps DCNL which are owned by the user as well as any apps they have been given permission to DCNL interact with.'
def get_object(self, **kwargs): DCNL 'Retrieve domain certificate by common name'
def get_object(self, **kwargs): DCNL 'Get release by version always'
def rollback(self, request, **kwargs): DCNL 'Create a new release as a copy of the state of the compiled slug and config vars of a DCNL previous release.'
def process_request(self, request): DCNL 'Return a 405 "Not Allowed" if the request\'s client major version DCNL doesn\'t match this controller\'s REST API major version (currently "1").'
def process_response(self, request, response): DCNL 'Include the controller\'s REST API major and minor version in DCNL a response header.'
def post_save(self, obj): DCNL 'A post_save hook for performing actions after the object has been pushed to the DCNL database. DCNL Leave it up to child classes to implement.'
def publish_release(self, source, config, target, deis_registry): DCNL 'Update a source Docker image with environment config and publish it to deis-registry.'
def build(self, source, config, repo, tag): DCNL 'Add a "last-mile" layer of environment config to a Docker image for deis-registry.'
def pull(self, repo, tag): DCNL 'Pull a Docker image into the local storage graph.'
def push(self, repo, tag): DCNL 'Push a local Docker image to a registry.'
def tag(self, image, repo, tag): DCNL 'Tag a local Docker image with a new name and tag.'
def create(self, name, image, command, **kwargs): DCNL 'Create a new container.'
def destroy(self, name): DCNL 'Destroy a container.'
def run(self, name, image, entrypoint, command): DCNL 'Run a one-off command.'
def start(self, name): DCNL 'Start a container.'
def state(self, name): DCNL 'Display the given job\'s running state.'
def stop(self, name): DCNL 'Stop a container.'
def create(self, name, image, command, **kwargs): DCNL 'Create a new container.'
def destroy(self, name): DCNL 'Destroy a container.'
def run(self, name, image, entrypoint, command): DCNL 'Run a one-off command.'
def start(self, name): DCNL 'Start a container.'
def state(self, name): DCNL 'Display the given job\'s running state.'
def stop(self, name): DCNL 'Stop a container.'
def create(self, name, image, command='', template=None, **kwargs): DCNL 'Create a container.'
def start(self, name): DCNL 'Start a container.'
def stop(self, name): DCNL 'Stop a container.'
def destroy(self, name): DCNL 'Destroy a container.'
def run(self, name, image, entrypoint, command): DCNL 'Run a one-off command.'
def state(self, name): DCNL 'Display the given job\'s running state.'
def create(self, name, image, command, **kwargs): DCNL 'Create a new container.'
def destroy(self, name): DCNL 'Destroy a container.'
def run(self, name, image, entrypoint, command): DCNL 'Run a one-off command.'
def start(self, name): DCNL 'Start a container.'
def stop(self, name): DCNL 'Stop a container.'
def _render_template(self, t, ctx=None): DCNL 'Test that the tag renders a gravatar URL.'
def test_render_syntax_error(self): DCNL 'Test that the tag requires one argument.'
def test_render_context_error(self): DCNL 'Test that an empty email returns an empty string.'
def report(self, logprob): DCNL 'Reports convergence to :data:`sys.stderr`. DCNL The output consists of three columns: iteration number, log DCNL probability of the data at the current iteration and convergence DCNL rate.  At the first iteration convergence rate is unknown and DCNL is thus denoted by NaN. DCNL Parameters DCNL logprob : float DCNL The log probability of the data as computed by EM algorithm DCNL in the current iteration.'
@property DCNL def converged(self): DCNL '``True`` if the EM algorithm converged and ``False`` otherwise.'
def score_samples(self, X, lengths=None): DCNL 'Compute the log probability under the model and compute posteriors. DCNL Parameters DCNL X : array-like, shape (n_samples, n_features) DCNL Feature matrix of individual samples. DCNL lengths : array-like of integers, shape (n_sequences, ), optional DCNL Lengths of the individual sequences in ``X``. The sum of DCNL these should be ``n_samples``. DCNL Returns DCNL logprob : float DCNL Log likelihood of ``X``. DCNL posteriors : array, shape (n_samples, n_components) DCNL State-membership probabilities for each sample in ``X``. DCNL See Also DCNL score : Compute the log probability under the model. DCNL decode : Find most likely state sequence corresponding to ``X``.'
def score(self, X, lengths=None): DCNL 'Compute the log probability under the model. DCNL Parameters DCNL X : array-like, shape (n_samples, n_features) DCNL Feature matrix of individual samples. DCNL lengths : array-like of integers, shape (n_sequences, ), optional DCNL Lengths of the individual sequences in ``X``. The sum of DCNL these should be ``n_samples``. DCNL Returns DCNL logprob : float DCNL Log likelihood of ``X``. DCNL See Also DCNL score_samples : Compute the log probability under the model and DCNL posteriors. DCNL decode : Find most likely state sequence corresponding to ``X``.'
def decode(self, X, lengths=None, algorithm=None): DCNL 'Find most likely state sequence corresponding to ``X``. DCNL Parameters DCNL X : array-like, shape (n_samples, n_features) DCNL Feature matrix of individual samples. DCNL lengths : array-like of integers, shape (n_sequences, ), optional DCNL Lengths of the individual sequences in ``X``. The sum of DCNL these should be ``n_samples``. DCNL algorithm : string DCNL Decoder algorithm. Must be one of "viterbi" or "map". DCNL If not given, :attr:`decoder` is used. DCNL Returns DCNL logprob : float DCNL Log probability of the produced state sequence. DCNL state_sequence : array, shape (n_samples, ) DCNL Labels for each sample from ``X`` obtained via a given DCNL decoder ``algorithm``. DCNL See Also DCNL score_samples : Compute the log probability under the model and DCNL posteriors. DCNL score : Compute the log probability under the model.'
def predict(self, X, lengths=None): DCNL 'Find most likely state sequence corresponding to ``X``. DCNL Parameters DCNL X : array-like, shape (n_samples, n_features) DCNL Feature matrix of individual samples. DCNL lengths : array-like of integers, shape (n_sequences, ), optional DCNL Lengths of the individual sequences in ``X``. The sum of DCNL these should be ``n_samples``. DCNL Returns DCNL state_sequence : array, shape (n_samples, ) DCNL Labels for each sample from ``X``.'
def predict_proba(self, X, lengths=None): DCNL 'Compute the posterior probability for each state in the model. DCNL X : array-like, shape (n_samples, n_features) DCNL Feature matrix of individual samples. DCNL lengths : array-like of integers, shape (n_sequences, ), optional DCNL Lengths of the individual sequences in ``X``. The sum of DCNL these should be ``n_samples``. DCNL Returns DCNL posteriors : array, shape (n_samples, n_components) DCNL State-membership probabilities for each sample from ``X``.'
def sample(self, n_samples=1, random_state=None): DCNL 'Generate random samples from the model. DCNL Parameters DCNL n_samples : int DCNL Number of samples to generate. DCNL random_state : RandomState or an int seed DCNL A random number generator instance. If ``None``, the object\'s DCNL ``random_state`` is used. DCNL Returns DCNL X : array, shape (n_samples, n_features) DCNL Feature matrix. DCNL state_sequence : array, shape (n_samples, ) DCNL State sequence produced by the model.'
def fit(self, X, lengths=None): DCNL 'Estimate model parameters. DCNL An initialization step is performed before entering the DCNL EM algorithm. If you want to avoid this step for a subset of DCNL the parameters, pass proper ``init_params`` keyword argument DCNL to estimator\'s constructor. DCNL Parameters DCNL X : array-like, shape (n_samples, n_features) DCNL Feature matrix of individual samples. DCNL lengths : array-like of integers, shape (n_sequences, ) DCNL Lengths of the individual sequences in ``X``. The sum of DCNL these should be ``n_samples``. DCNL Returns DCNL self : object DCNL Returns self.'
def _init(self, X, lengths): DCNL 'Initializes model parameters prior to fitting. DCNL Parameters DCNL X : array-like, shape (n_samples, n_features) DCNL Feature matrix of individual samples. DCNL lengths : array-like of integers, shape (n_sequences, ) DCNL Lengths of the individual sequences in ``X``. The sum of DCNL these should be ``n_samples``.'
def _check(self): DCNL 'Validates model parameters prior to fitting. DCNL Raises DCNL ValueError DCNL If any of the parameters are invalid, e.g. if :attr:`startprob_` DCNL don\'t sum to 1.'
def _initialize_sufficient_statistics(self): DCNL 'Initializes sufficient statistics required for M-step. DCNL The method is *pure*, meaning that it doesn\'t change the state of DCNL the instance.  For extensibility computed statistics are stored DCNL in a dictionary. DCNL Returns DCNL nobs : int DCNL Number of samples in the data. DCNL start : array, shape (n_components, ) DCNL An array where the i-th element corresponds to the posterior DCNL probability of the first sample being generated by the i-th DCNL state. DCNL trans : array, shape (n_components, n_components) DCNL An array where the (i, j)-th element corresponds to the DCNL posterior probability of transitioning between the i-th to j-th DCNL states.'
def _accumulate_sufficient_statistics(self, stats, X, framelogprob, posteriors, fwdlattice, bwdlattice): DCNL 'Updates sufficient statistics from a given sample. DCNL Parameters DCNL stats : dict DCNL Sufficient statistics as returned by DCNL :meth:`~base._BaseHMM._initialize_sufficient_statistics`. DCNL X : array, shape (n_samples, n_features) DCNL Sample sequence. DCNL framelogprob : array, shape (n_samples, n_components) DCNL Log-probabilities of each sample under each of the model states. DCNL posteriors : array, shape (n_samples, n_components) DCNL Posterior probabilities of each sample being generated by each DCNL of the model states. DCNL fwdlattice, bwdlattice : array, shape (n_samples, n_components) DCNL Log-forward and log-backward probabilities.'
def _do_mstep(self, stats): DCNL 'Performs the M-step of EM algorithm. DCNL Parameters DCNL stats : dict DCNL Sufficient statistics updated from all available samples.'
@property DCNL def covars_(self): DCNL 'Return covars as a full matrix.'
def _check_input_symbols(self, X): DCNL 'Check if ``X`` is a sample from a Multinomial distribution. DCNL That is ``X`` should be an array of non-negative integers from DCNL range ``[min(X), max(X)]``, such that each integer from the range DCNL occurs in ``X`` at least once. DCNL For example ``[0, 0, 2, 1, 3, 1, 1]`` is a valid sample from a DCNL Multinomial distribution, while ``[0, 0, 3, 5, 10]`` is not.'
def omittags(self): DCNL 'Don\'t render this element\'s tag(s).'
def omit(self): DCNL 'Don\'t render this element.'
def repeat(self, fn, list, *args): DCNL 'Render an instance of this node for each item in list.'
def __init__(self, callback, html, attribute='node', codecs=(defaultEncoder, defaultDecoder), warnings=False): DCNL 'callback : function -- the function that controls how this DCNL template is rendered DCNL html : string or unicode -- the template HTML DCNL [attribute : string or unicode] -- name of the tag attribute used DCNL to hold compiler directives DCNL [codecs : tuple] -- a tuple containing two functions used by the DCNL content property to encode/decode HTML entities DCNL [warnings : boolean] -- warn when non-directive attribute DCNL is encountered'
def render(self, *args, **kwargs): DCNL 'Render this template; *args will be passed directly to the template.'
def structure(self): DCNL 'Print the object model\'s structure for diagnostic use.'
def __call__(self, name, value=None): DCNL 'Shortcut for append method.'
def __init__(self, asciidoc_py=None): DCNL 'Locate and import asciidoc.py. DCNL Initialize instance attributes.'
def __import_asciidoc(self, reload=False): DCNL 'Import asciidoc module (script or compiled .pyc). DCNL See DCNL http://groups.google.com/group/asciidoc/browse_frm/thread/66e7b59d12cd2f91 DCNL for an explanation of why a seemingly straight-forward job turned out DCNL quite complicated.'
def execute(self, infile, outfile=None, backend=None): DCNL 'Compile infile to outfile using backend format. DCNL infile can outfile can be file path strings or file like objects.'
def test_alternative_types(self, ty, other_ty, alternatives): DCNL 'print "-----------------------" DCNL print ty.strip() DCNL print other_ty.strip() DCNL print "ty in alternatives " + str(ty in alternatives) DCNL if ty in alternatives: DCNL print "alternatives[ty].count(other_ty) " + str(alternatives[ty].count(other_ty))'
def test_alternative_types(self, ty, other_ty, alternatives): DCNL 'print "-----------------------" DCNL print ty.strip() DCNL print other_ty.strip() DCNL print "ty in alternatives " + str(ty in alternatives) DCNL if ty in alternatives: DCNL print "alternatives[ty].count(other_ty) " + str(alternatives[ty].count(other_ty))'
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True): DCNL 'Runs a command in an out-of-process shell. DCNL Returns the output of that command. Working directory is self.root.'
def create_virtualenv(self, no_site_packages=True): DCNL 'Creates the virtual environment and installs PIP. DCNL Creates the virtual environment and installs PIP only into the DCNL virtual environment.'
def parse_args(self, argv): DCNL 'Parses command-line arguments.'
def post_process(self): DCNL 'Any distribution-specific post-processing gets done here. DCNL In particular, this is useful for applying patches to code inside DCNL the venv.'
def post_process(self): DCNL 'Workaround for a bug in eventlet. DCNL This currently affects RHEL6.1, but the fix can safely be DCNL applied to all RHEL and Fedora distributions. DCNL This can be removed when the fix is applied upstream. DCNL Nova: https://bugs.launchpad.net/nova/+bug/884915 DCNL Upstream: https://bitbucket.org/which_linden/eventlet/issue/89'
def __init__(self, fd): DCNL ':param fd: Underlying image file object'
def read(self, length=None): DCNL 'Return the next chunk of the underlying iterator. DCNL This is replaced with cooperative_read in __init__ if the underlying DCNL fd already supports read().'
def __init__(self, data, limit): DCNL ':param data: Underlying image data object DCNL :param limit: maximum number of bytes the reader should allow'
def add_column(self, width, label='', just='l'): DCNL 'Add a column to the table DCNL :param width: number of characters wide the column should be DCNL :param label: column heading DCNL :param just: justification for the column, \'l\' for left, DCNL \'r\' for right'
def authenticate(self): DCNL 'Authenticate with the Keystone service. DCNL There are a few scenarios to consider here: DCNL 1. Which version of Keystone are we using? v1 which uses headers to DCNL pass the credentials, or v2 which uses a JSON encoded request body? DCNL 2. Keystone may respond back with a redirection using a 305 status DCNL code. DCNL 3. We may attempt a v1 auth when v2 is what\'s called for. In this DCNL case, we rewrite the url to contain /v2.0/ and retry using the v2 DCNL protocol.'
def connect(self): DCNL 'Connect to a host on a given (SSL) port. DCNL If ca_file is pointing somewhere, use it to check Server Certificate. DCNL Redefined/copied and extended from httplib.py:1105 (Python 2.6.x). DCNL This is needed to pass cert_reqs=ssl.CERT_REQUIRED as parameter to DCNL ssl.wrap_socket(), which forces SSL to check server certificate against DCNL our client certificate.'
def __init__(self, host, port=None, timeout=None, use_ssl=False, auth_tok=None, creds=None, doc_root=None, key_file=None, cert_file=None, ca_file=None, insecure=False, configure_via_auth=True): DCNL 'Creates a new client to some service. DCNL :param host: The host where service resides DCNL :param port: The port where service resides DCNL :param timeout: Connection timeout. DCNL :param use_ssl: Should we use HTTPS? DCNL :param auth_tok: The auth token to pass to the server DCNL :param creds: The credentials to pass to the auth plugin DCNL :param doc_root: Prefix for all URLs we request from host DCNL :param key_file: Optional PEM-formatted file that contains the private DCNL key. DCNL If use_ssl is True, and this param is None (the DCNL default), then an environ variable DCNL GLANCE_CLIENT_KEY_FILE is looked for. If no such DCNL environ variable is found, ClientConnectionError DCNL will be raised. DCNL :param cert_file: Optional PEM-formatted certificate chain file. DCNL If use_ssl is True, and this param is None (the DCNL default), then an environ variable DCNL GLANCE_CLIENT_CERT_FILE is looked for. If no such DCNL environ variable is found, ClientConnectionError DCNL will be raised. DCNL :param ca_file: Optional CA cert file to use in SSL connections DCNL If use_ssl is True, and this param is None (the DCNL default), then an environ variable DCNL GLANCE_CLIENT_CA_FILE is looked for. DCNL :param insecure: Optional. If set then the server\'s certificate DCNL will not be verified. DCNL :param configure_via_auth: Optional. Defaults to True. If set, the DCNL URL returned from the service catalog for the image DCNL endpoint will **override** the URL supplied to in DCNL the host parameter.'
def set_auth_token(self, auth_tok): DCNL 'Updates the authentication token for this client connection.'
def configure_from_url(self, url): DCNL 'Setups the connection based on the given url. DCNL The form is: DCNL <http|https>://<host>:port/doc_root'
def make_auth_plugin(self, creds, insecure): DCNL 'Returns an instantiated authentication plugin.'
def get_connection_type(self): DCNL 'Returns the proper connection type'
def _authenticate(self, force_reauth=False): DCNL 'Use the authentication plugin to authenticate and set the auth token. DCNL :param force_reauth: For re-authentication to bypass cache.'
@handle_unauthenticated DCNL def do_request(self, method, action, body=None, headers=None, params=None): DCNL 'Make a request, returning an HTTP response object. DCNL :param method: HTTP verb (GET, POST, PUT, etc.) DCNL :param action: Requested path to append to self.doc_root DCNL :param body: Data to send in the body of the request DCNL :param headers: Headers to send with the request DCNL :param params: Key/value pairs to use in query string DCNL :returns: HTTP response object'
def _construct_url(self, action, params=None): DCNL 'Create a URL object we can use to pass to _do_request().'
@handle_redirects DCNL def _do_request(self, method, url, body, headers): DCNL 'Connects to the server and issues a request.  Handles converting DCNL any returned HTTP error status codes to OpenStack/Glance exceptions DCNL and closing the server connection. Returns the result data, or DCNL raises an appropriate exception. DCNL :param method: HTTP method ("GET", "POST", "PUT", etc...) DCNL :param url: urlparse.ParsedResult object with URL information DCNL :param body: data to send (as string, filelike or iterable), DCNL or None (default) DCNL :param headers: mapping of key/value pairs to add as headers DCNL :note DCNL If the body param has a read attribute, and method is either DCNL POST or PUT, this method will automatically conduct a chunked-transfer DCNL encoding and use the body as a file object or iterable, transferring DCNL chunks of data using the connection\'s send() method. This allows large DCNL objects to be transferred efficiently without buffering the entire DCNL body in memory.'
def get_status_code(self, response): DCNL 'Returns the integer status code from the response, which DCNL can be either a Webob.Response (used in testing) or httplib.Response'
def _extract_params(self, actual_params, allowed_params): DCNL 'Extract a subset of keys from a dictionary. The filters key DCNL will also be extracted, and each of its values will be returned DCNL as an individual param. DCNL :param actual_params: dict of keys to filter DCNL :param allowed_params: list of keys that \'actual_params\' will be DCNL reduced to DCNL :retval subset of \'params\' dict'
def start(self, application, default_port): DCNL 'Run a WSGI server with the given application. DCNL :param application: The application to be run in the WSGI server DCNL :param default_port: Port to bind to if none is specified in conf'
def wait(self): DCNL 'Wait until all servers have completed running.'
def run_server(self): DCNL 'Run a WSGI server.'
def _single_run(self, application, sock): DCNL 'Start a WSGI server in a new green thread.'
def process_request(self, req): DCNL 'Called on each request. DCNL If this returns None, the next application down the stack will be DCNL executed. If it returns a response then that response will be returned DCNL and execution will stop here.'
def process_response(self, response): DCNL 'Do whatever you\'d like to the response.'
@staticmethod DCNL def print_generator(app_iter): DCNL 'Iterator that prints the contents of a wrapper string iterator DCNL when iterated.'
def __init__(self, mapper): DCNL 'Create a router for the given routes.Mapper. DCNL Each route in `mapper` must specify a \'controller\', which is a DCNL WSGI app to call.  You\'ll probably want to specify an \'action\' as DCNL well and have your controller be a wsgi.Controller, who will route DCNL the request to the action method. DCNL Examples: DCNL mapper = routes.Mapper() DCNL sc = ServerController() DCNL # Explicit mapping of one route to a controller+action DCNL mapper.connect(None, "/svrlist", controller=sc, action="list") DCNL # Actions are all implicitly defined DCNL mapper.resource("server", "servers", controller=sc) DCNL # Pointing to an arbitrary WSGI app.  You can specify the DCNL # {path_info:.*} parameter so the target app can be handed just that DCNL # section of the URL. DCNL mapper.connect(None, "/v1.0/{path_info:.*}", controller=BlogApp())'
@webob.dec.wsgify DCNL def __call__(self, req): DCNL 'Route the incoming request to a controller based on self.map. DCNL If no match, return a 404.'
@staticmethod DCNL @webob.dec.wsgify DCNL def _dispatch(req): DCNL 'Called by self._router after matching the incoming request to a route DCNL and putting the information into req.environ.  Either returns 404 DCNL or the routed WSGI app\'s response.'
def best_match_content_type(self): DCNL 'Determine the requested response content-type.'
def get_content_type(self, allowed_content_types): DCNL 'Determine content type of the request body.'
def has_body(self, request): DCNL 'Returns whether a Webob.Request object will possess an entity body. DCNL :param request:  Webob.Request object'
def __init__(self, controller, deserializer=None, serializer=None): DCNL ':param controller: object that implement methods created by routes lib DCNL :param deserializer: object that supports webob request deserialization DCNL through controller-like actions DCNL :param serializer: object that supports webob response serialization DCNL through controller-like actions'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'WSGI method that controls (de)serialization and method dispatch.'
def dispatch(self, obj, action, *args, **kwargs): DCNL 'Find action-specific method on self and call it.'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
def process_request(self, req): DCNL 'Try to find a version first in the accept header, then the URL'
def _match_version_string(self, subject): DCNL 'Given a string, tries to match a major and/or DCNL minor version number. DCNL :param subject: The string to check DCNL :returns version found in the subject DCNL :raises ValueError if no acceptable version could be found'
def process_request(self, req): DCNL 'Convert authentication information into a request context DCNL Generate a glance.context.RequestContext object from the available DCNL authentication headers and store on the \'context\' attribute DCNL of the req object. DCNL :param req: wsgi request object that will be given the context object DCNL :raises webob.exc.HTTPUnauthorized: when value of the X-Identity-Status DCNL header is not \'Confirmed\' and DCNL anonymous access is disallowed'
def process_request(self, req): DCNL 'Create a context without an authorized user.'
def _verify_metadata(self, image_meta): DCNL 'Sanity check the \'deleted\' and \'size\' metadata values.'
@staticmethod DCNL def _match_request(request): DCNL 'Determine the version of the url and extract the image id DCNL :returns tuple of version and image id if the url is a cacheable, DCNL otherwise None'
def process_request(self, request): DCNL 'For requests for an image file, we check the local image DCNL cache. If present, we return the image file, appending DCNL the image metadata in headers. If not present, we pass DCNL the request on to the next application in the pipeline.'
@staticmethod DCNL def _stash_request_info(request, image_id, method): DCNL 'Preserve the image id and request method for later retrieval'
@staticmethod DCNL def _fetch_request_info(request): DCNL 'Preserve the cached image id for consumption by the DCNL process_response method of this middleware'
def process_response(self, resp): DCNL 'We intercept the response coming back from the main DCNL images Resource, removing image file from the cache DCNL if necessary'
def get_status_code(self, response): DCNL 'Returns the integer status code from the response, which DCNL can be either a Webob.Response (used in testing) or httplib.Response'
def get_from_cache(self, image_id): DCNL 'Called if cache hit'
def set_rules(self, rules): DCNL 'Create a new Rules object based on the provided dict of rules'
def load_rules(self): DCNL 'Set the rules found in the json file on disk'
@staticmethod DCNL def _find_policy_file(): DCNL 'Locate the policy json data file'
def _read_policy_file(self): DCNL 'Read contents of the policy file DCNL This re-caches policy data if the file has been changed.'
def _check(self, context, rule, target, *args, **kwargs): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: Glance request context DCNL :param rule: String representing the action to be checked DCNL :param object: Dictionary representing the object of the action. DCNL :raises: `glance.common.exception.Forbidden` DCNL :returns: A non-False value if access is allowed.'
def enforce(self, context, action, target): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: Glance request context DCNL :param action: String representing the action to be checked DCNL :param object: Dictionary representing the object of the action. DCNL :raises: `glance.common.exception.Forbidden` DCNL :returns: A non-False value if access is allowed.'
def check(self, context, action, target): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: Glance request context DCNL :param action: String representing the action to be checked DCNL :param object: Dictionary representing the object of the action. DCNL :returns: A non-False value if access is allowed.'
@utils.mutating DCNL def create(self, req, image_id, member_id): DCNL 'Adds a membership to the image. DCNL :param req: the Request object coming from the wsgi layer DCNL :param image_id: the image identifier DCNL :param member_id: the member identifier DCNL :retval The response body is a mapping of the following form:: DCNL {\'member_id\': <MEMBER>, DCNL \'image_id\': <IMAGE>, DCNL \'status\': <MEMBER_STATUS> DCNL \'created_at\': .., DCNL \'updated_at\': ..}'
@utils.mutating DCNL def update(self, req, image_id, member_id, status): DCNL 'Adds a membership to the image. DCNL :param req: the Request object coming from the wsgi layer DCNL :param image_id: the image identifier DCNL :param member_id: the member identifier DCNL :retval The response body is a mapping of the following form:: DCNL {\'member_id\': <MEMBER>, DCNL \'image_id\': <IMAGE>, DCNL \'status\': <MEMBER_STATUS> DCNL \'created_at\': .., DCNL \'updated_at\': ..}'
def index(self, req, image_id): DCNL 'Return a list of dictionaries indicating the members of the DCNL image, i.e., those tenants the image is shared with. DCNL :param req: the Request object coming from the wsgi layer DCNL :param image_id: The image identifier DCNL :retval The response body is a mapping of the following form:: DCNL {\'members\': [ DCNL {\'member_id\': <MEMBER>, DCNL \'image_id\': <IMAGE>, DCNL \'status\': <MEMBER_STATUS> DCNL \'created_at\': .., DCNL \'updated_at\': ..}, ..'
@utils.mutating DCNL def delete(self, req, image_id, member_id): DCNL 'Removes a membership from the image.'
def _decode_json_pointer(self, pointer): DCNL 'Parse a json pointer. DCNL Json Pointers are defined in DCNL http://tools.ietf.org/html/draft-pbryan-zyp-json-pointer . DCNL The pointers use \'/\' for separation between object attributes, such DCNL that \'/A/B\' would evaluate to C in {"A": {"B": "C"}}. A \'/\' character DCNL in an attribute name is encoded as "~1" and a \'~\' character is encoded DCNL as "~0".'
def _validate_json_pointer(self, pointer): DCNL 'Validate a json pointer. DCNL We only accept a limited form of json pointers. Specifically, we do DCNL not allow multiple levels of indirection, so there can only be one \'/\' DCNL in the pointer, located at the start of the string.'
def index(self, req, image_id): DCNL 'Return a list of dictionaries indicating the members of the DCNL image, i.e., those tenants the image is shared with. DCNL :param req: the Request object coming from the wsgi layer DCNL :param image_id: The opaque image identifier DCNL :retval The response body is a mapping of the following form:: DCNL {\'members\': [ DCNL {\'member_id\': <MEMBER>, DCNL \'can_share\': <SHARE_PERMISSION>, ...}, ...'
@utils.mutating DCNL def delete(self, req, image_id, id): DCNL 'Removes a membership from the image.'
def default(self, req, image_id, id, body=None): DCNL 'This will cover the missing \'show\' and \'create\' actions'
@utils.mutating DCNL def update(self, req, image_id, id, body=None): DCNL 'Adds a membership to the image, or updates an existing one. DCNL If a body is present, it is a dict with the following format:: DCNL {"member": { DCNL "can_share": [True|False] DCNL If "can_share" is provided, the member\'s ability to share is DCNL set accordingly.  If it is not provided, existing memberships DCNL remain unchanged and new memberships default to False.'
@utils.mutating DCNL def update_all(self, req, image_id, body): DCNL 'Replaces the members of the image with those specified in the DCNL body.  The body is a dict with the following format:: DCNL {"memberships": [ DCNL {"member_id": <MEMBER_ID>, DCNL ["can_share": [True|False]]}, ...'
def index_shared_images(self, req, id): DCNL 'Retrieves list of image memberships for the given member. DCNL :param req: the Request object coming from the wsgi layer DCNL :param id: the opaque member identifier DCNL :retval The response body is a mapping of the following form:: DCNL {\'shared_images\': [ DCNL {\'image_id\': <IMAGE>, DCNL \'can_share\': <SHARE_PERMISSION>, ...}, ...'
def _enforce(self, req, action): DCNL 'Authorize an action against our policies'
def index(self, req): DCNL 'Returns the following information for all public, available images: DCNL * id -- The opaque image identifier DCNL * name -- The name of the image DCNL * disk_format -- The disk image format DCNL * container_format -- The "container" format of the image DCNL * checksum -- MD5 checksum of the image data DCNL * size -- Size of image data in bytes DCNL :param req: The WSGI/Webob Request object DCNL :retval The response body is a mapping of the following form:: DCNL {\'images\': [ DCNL {\'id\': <ID>, DCNL \'name\': <NAME>, DCNL \'disk_format\': <DISK_FORMAT>, DCNL \'container_format\': <DISK_FORMAT>, DCNL \'checksum\': <CHECKSUM> DCNL \'size\': <SIZE>}, ...'
def detail(self, req): DCNL 'Returns detailed information for all public, available images DCNL :param req: The WSGI/Webob Request object DCNL :retval The response body is a mapping of the following form:: DCNL {\'images\': [ DCNL {\'id\': <ID>, DCNL \'name\': <NAME>, DCNL \'size\': <SIZE>, DCNL \'disk_format\': <DISK_FORMAT>, DCNL \'container_format\': <CONTAINER_FORMAT>, DCNL \'checksum\': <CHECKSUM>, DCNL \'min_disk\': <MIN_DISK>, DCNL \'min_ram\': <MIN_RAM>, DCNL \'store\': <STORE>, DCNL \'status\': <STATUS>, DCNL \'created_at\': <TIMESTAMP>, DCNL \'updated_at\': <TIMESTAMP>, DCNL \'deleted_at\': <TIMESTAMP>|<NONE>, DCNL \'properties\': {\'distro\': \'Ubuntu 10.04 LTS\', ...}}, ...'
def _get_query_params(self, req): DCNL 'Extracts necessary query params from request. DCNL :param req: the WSGI Request object DCNL :retval dict of parameters that can be used by registry client'
def _get_filters(self, req): DCNL 'Return a dictionary of query param filters from the request DCNL :param req: the Request object coming from the wsgi layer DCNL :retval a dict of key/value filters'
def meta(self, req, id): DCNL 'Returns metadata about an image in the HTTP headers of the DCNL response object DCNL :param req: The WSGI/Webob Request object DCNL :param id: The opaque image identifier DCNL :retval similar to \'show\' method but without image_data DCNL :raises HTTPNotFound if image metadata is not available to user'
@staticmethod DCNL def _validate_source(source, req): DCNL 'External sources (as specified via the location or copy-from headers) DCNL are supported only over non-local store types, i.e. S3, Swift, HTTP. DCNL Note the absence of file:// for security reasons, see LP bug #942118. DCNL If the above constraint is violated, we reject with 400 "Bad Request".'
def show(self, req, id): DCNL 'Returns an iterator that can be used to retrieve an image\'s DCNL data along with the image metadata. DCNL :param req: The WSGI/Webob Request object DCNL :param id: The opaque image identifier DCNL :raises HTTPNotFound if image is not available to user'
def _reserve(self, req, image_meta): DCNL 'Adds the image metadata to the registry and assigns DCNL an image identifier if one is not supplied in the request DCNL headers. Sets the image\'s status to `queued`. DCNL :param req: The WSGI/Webob Request object DCNL :param id: The opaque image identifier DCNL :param image_meta: The image metadata DCNL :raises HTTPConflict if image already exists DCNL :raises HTTPBadRequest if image metadata is not valid'
def _upload(self, req, image_meta): DCNL 'Uploads the payload of the request to a backend store in DCNL Glance. If the `x-image-meta-store` header is set, Glance DCNL will attempt to use that scheme; if not, Glance will use the DCNL scheme set by the flag `default_store` to find the backing store. DCNL :param req: The WSGI/Webob Request object DCNL :param image_meta: Mapping of metadata about image DCNL :raises HTTPConflict if image already exists DCNL :retval The location where the image was stored'
def _activate(self, req, image_id, location): DCNL 'Sets the image status to `active` and the image\'s location DCNL attribute. DCNL :param req: The WSGI/Webob Request object DCNL :param image_id: Opaque image identifier DCNL :param location: Location of where Glance stored this image'
def _kill(self, req, image_id): DCNL 'Marks the image status to `killed`. DCNL :param req: The WSGI/Webob Request object DCNL :param image_id: Opaque image identifier'
def _safe_kill(self, req, image_id): DCNL 'Mark image killed without raising exceptions if it fails. DCNL Since _kill is meant to be called from exceptions handlers, it should DCNL not raise itself, rather it should just log its error. DCNL :param req: The WSGI/Webob Request object DCNL :param image_id: Opaque image identifier'
def _upload_and_activate(self, req, image_meta): DCNL 'Safely uploads the image data in the request payload DCNL and activates the image in the registry after a successful DCNL upload. DCNL :param req: The WSGI/Webob Request object DCNL :param image_meta: Mapping of metadata about image DCNL :retval Mapping of updated image data'
def _validate_image_for_activation(self, req, id, values): DCNL 'Ensures that all required image metadata values are valid.'
@utils.mutating DCNL def create(self, req, image_meta, image_data): DCNL 'Adds a new image to Glance. Four scenarios exist when creating an DCNL image: DCNL 1. If the image data is available directly for upload, create can be DCNL passed the image data as the request body and the metadata as the DCNL request headers. The image will initially be \'queued\', during DCNL upload it will be in the \'saving\' status, and then \'killed\' or DCNL \'active\' depending on whether the upload completed successfully. DCNL 2. If the image data exists somewhere else, you can upload indirectly DCNL from the external source using the x-glance-api-copy-from header. DCNL Once the image is uploaded, the external store is not subsequently DCNL consulted, i.e. the image content is served out from the configured DCNL glance image store.  State transitions are as for option #1. DCNL 3. If the image data exists somewhere else, you can reference the DCNL source using the x-image-meta-location header. The image content DCNL will be served out from the external store, i.e. is never uploaded DCNL to the configured glance image store. DCNL 4. If the image data is not available yet, but you\'d like reserve a DCNL spot for it, you can omit the data and a record will be created in DCNL the \'queued\' state. This exists primarily to maintain backwards DCNL compatibility with OpenStack/Rackspace API semantics. DCNL The request body *must* be encoded as application/octet-stream, DCNL otherwise an HTTPBadRequest is returned. DCNL Upon a successful save of the image data and metadata, a response DCNL containing metadata about the image is returned, including its DCNL opaque identifier. DCNL :param req: The WSGI/Webob Request object DCNL :param image_meta: Mapping of metadata about image DCNL :param image_data: Actual image data that is to be stored DCNL :raises HTTPBadRequest if x-image-meta-location is missing DCNL and the request body is not application/octet-stream DCNL image data.'
@utils.mutating DCNL def update(self, req, id, image_meta, image_data): DCNL 'Updates an existing image with the registry. DCNL :param request: The WSGI/Webob Request object DCNL :param id: The opaque image identifier DCNL :retval Returns the updated image information as a mapping'
@utils.mutating DCNL def delete(self, req, id): DCNL 'Deletes the image and all its chunks from the Glance DCNL :param req: The WSGI/Webob Request object DCNL :param id: The opaque image identifier DCNL :raises HttpBadRequest if image registry is invalid DCNL :raises HttpNotFound if image or any chunk is not available DCNL :raises HttpUnauthorized if image or any chunk is not DCNL deleteable by the requesting user'
def get_store_or_400(self, request, scheme): DCNL 'Grabs the storage backend for the supplied store name DCNL or raises an HTTPBadRequest (400) response DCNL :param request: The WSGI/Webob Request object DCNL :param scheme: The backend store scheme DCNL :raises HTTPNotFound if store does not exist'
def _inject_image_meta_headers(self, response, image_meta): DCNL 'Given a response and mapping of image metadata, injects DCNL the Response with a set of HTTP headers for the image DCNL metadata. Each main image metadata field is injected DCNL as a HTTP header with key \'x-image-meta-<FIELD>\' except DCNL for the properties field, which is further broken out DCNL into a set of \'x-image-meta-property-<KEY>\' headers DCNL :param response: The Webob Response object DCNL :param image_meta: Mapping of image metadata'
def _get_image_location(self, image_meta): DCNL 'Build a relative url to reach the image defined by image_meta.'
def get_image_meta_or_404(self, request, image_id): DCNL 'Grabs the image metadata for an image with a supplied DCNL identifier or raises an HTTPNotFound (404) response DCNL :param request: The WSGI/Webob Request object DCNL :param image_id: The opaque image identifier DCNL :raises HTTPNotFound if image does not exist'
def get_active_image_meta_or_404(self, request, image_id): DCNL 'Same as get_image_meta_or_404 except that it will raise a 404 if the DCNL image isn\'t \'active\'.'
def _enforce(self, req): DCNL 'Authorize request against \'manage_image_cache\' policy'
def get_cached_images(self, req): DCNL 'GET /cached_images DCNL Returns a mapping of records about cached images.'
def delete_cached_image(self, req, image_id): DCNL 'DELETE /cached_images/<IMAGE_ID> DCNL Removes an image from the cache.'
def delete_cached_images(self, req): DCNL 'DELETE /cached_images - Clear all active cached images DCNL Removes all images from the cache.'
def get_queued_images(self, req): DCNL 'GET /queued_images DCNL Returns a mapping of records about queued images.'
def queue_image(self, req, image_id): DCNL 'PUT /queued_images/<IMAGE_ID> DCNL Queues an image for caching. We do not check to see if DCNL the image is in the registry here. That is done by the DCNL prefetcher...'
def delete_queued_image(self, req, image_id): DCNL 'DELETE /queued_images/<IMAGE_ID> DCNL Removes an image from the cache.'
def delete_queued_images(self, req): DCNL 'DELETE /queued_images - Clear all active queued images DCNL Removes all images from the cache.'
def index(self, req): DCNL 'Respond to a request for all OpenStack API versions.'
def save(self, session=None): DCNL 'Save this object'
def delete(self, session=None): DCNL 'Delete this object'
def update(self, values): DCNL 'dict.update() behaviour.'
def __init__(self, context=None, location=None): DCNL 'Initialize the Store'
def configure(self): DCNL 'Configure the Store to use the stored configuration options DCNL Any store that needs special configuration should implement DCNL this method.'
def get_schemes(self): DCNL 'Returns a tuple of schemes which this store can handle.'
def get_store_location_class(self): DCNL 'Returns the store location class that is used by this store.'
def configure_add(self): DCNL 'This is like `configure` except that it\'s specifically for DCNL configuring the store to accept objects. DCNL If the store was not able to successfully configure DCNL itself, it should raise `exception.BadStoreConfiguration`.'
def get(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file, and returns a tuple of generator DCNL (for reading the image file) and image_size DCNL :param location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises `glance.exception.NotFound` if image does not exist'
def get_size(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file, and returns the size DCNL :param location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises `glance.exception.NotFound` if image does not exist'
def add_disabled(self, *args, **kwargs): DCNL 'Add method that raises an exception because the Store was DCNL not able to be configured properly and therefore the add() DCNL method would error out.'
def add(self, image_id, image_file, image_size): DCNL 'Stores an image file with supplied identifier to the backend DCNL storage system and returns a tuple containing information DCNL about the stored image. DCNL :param image_id: The opaque image identifier DCNL :param image_file: The image data to write, as a file-like object DCNL :param image_size: The size of the image data to write, in bytes DCNL :retval tuple of URL in backing store, bytes written, and checksum DCNL :raises `glance.common.exception.Duplicate` if the image already DCNL existed'
def delete(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file to delete DCNL :location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises `glance.exception.NotFound` if image does not exist'
def set_acls(self, location, public=False, read_tenants=[], write_tenants=[]): DCNL 'Sets the read and write access control list for an image in the DCNL backend store. DCNL :location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :public A boolean indicating whether the image should be public. DCNL :read_tenants A list of tenant strings which should be granted DCNL read access for an image. DCNL :write_tenants A list of tenant strings which should be granted DCNL write access for an image.'
def parse_uri(self, uri): DCNL 'Parse URLs. This method fixes an issue where credentials specified DCNL in the URL are interpreted differently in Python 2.6.1+ than prior DCNL versions of Python. DCNL Note that an Amazon AWS secret key can contain the forward slash, DCNL which is entirely retarded, and breaks urlparse miserably. DCNL This function works around that issue.'
def __iter__(self): DCNL 'Return an iterator over the image file'
def getvalue(self): DCNL 'Return entire string value... used in testing'
def close(self): DCNL 'Close the internal file pointer'
def configure_add(self): DCNL 'Configure the Store to use the stored configuration options DCNL Any store that needs special configuration should implement DCNL this method. If the store was not able to successfully configure DCNL itself, it should raise `exception.BadStoreConfiguration`'
def get(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file, and returns a tuple of generator DCNL (for reading the image file) and image_size DCNL :param location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises `glance.exception.NotFound` if image does not exist'
def get_size(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file, and returns the image_size (or 0 DCNL if unavailable) DCNL :param location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri()'
def add(self, image_id, image_file, image_size): DCNL 'Stores an image file with supplied identifier to the backend DCNL storage system and returns a tuple containing information DCNL about the stored image. DCNL :param image_id: The opaque image identifier DCNL :param image_file: The image data to write, as a file-like object DCNL :param image_size: The size of the image data to write, in bytes DCNL :retval tuple of URL in backing store, bytes written, and checksum DCNL :raises `glance.common.exception.Duplicate` if the image already DCNL existed DCNL S3 writes the image data using the scheme: DCNL s3://<ACCESS_KEY>:<SECRET_KEY>@<S3_URL>/<BUCKET>/<OBJ> DCNL where: DCNL <USER> = ``s3_store_user`` DCNL <KEY> = ``s3_store_key`` DCNL <S3_HOST> = ``s3_store_host`` DCNL <BUCKET> = ``s3_store_bucket`` DCNL <ID> = The id of the image being added'
def delete(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file to delete DCNL :location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises NotFound if image does not exist'
def __init__(self, wrapped, size): DCNL 'Initialize the object DCNL :param wrappped: the wrapped iterator or filelike. DCNL :param size: the size of data available'
def __iter__(self): DCNL 'Delegate iteration to the wrapped instance.'
def __getitem__(self, i): DCNL 'Index into the next chunk (or previous chunk in the case where DCNL the last data returned was not fully consumed). DCNL :param i: a slice-to-the-end'
def another(self): DCNL 'Implemented by subclasses to return the next element'
def getvalue(self): DCNL 'Return entire string value... used in testing'
def __len__(self): DCNL 'Length accessor.'
def configure_add(self): DCNL 'Configure the Store to use the stored configuration options DCNL Any store that needs special configuration should implement DCNL this method. If the store was not able to successfully configure DCNL itself, it should raise `exception.BadStoreConfiguration`'
def get(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file, and returns a generator for reading DCNL the image file DCNL :param location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises `glance.exception.NotFound` if image does not exist'
def _create_image(self, fsid, ioctx, name, size, order): DCNL 'Create an rbd image. If librbd supports it, DCNL make it a cloneable snapshot, so that copy-on-write DCNL volumes can be created from it. DCNL :retval `glance.store.rbd.StoreLocation` object'
def add(self, image_id, image_file, image_size): DCNL 'Stores an image file with supplied identifier to the backend DCNL storage system and returns a tuple containing information DCNL about the stored image. DCNL :param image_id: The opaque image identifier DCNL :param image_file: The image data to write, as a file-like object DCNL :param image_size: The size of the image data to write, in bytes DCNL :retval tuple of URL in backing store, bytes written, and checksum DCNL :raises `glance.common.exception.Duplicate` if the image already DCNL existed'
def delete(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file to delete DCNL :location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises NotFound if image does not exist'
def parse_uri(self, uri): DCNL 'Parse URLs. This method fixes an issue where credentials specified DCNL in the URL are interpreted differently in Python 2.6.1+ than prior DCNL versions of Python. It also deals with the peculiarity that new-style DCNL Swift URIs have where a username can contain a \':\', like so: DCNL swift://account:user:pass@authurl.com/container/obj'
@property DCNL def swift_url(self): DCNL 'Creates a fully-qualified auth url that the Swift client library can DCNL use. The scheme for the auth_url is determined using the scheme DCNL included in the `location` field. DCNL HTTPS is assumed, unless \'swift+http\' is specified.'
def _create_container_if_missing(self, container, connection): DCNL 'Creates a missing container in Swift if the DCNL ``swift_store_create_container_on_put`` option is set. DCNL :param container: Name of container to create DCNL :param connection: Connection to swift service'
def __init__(self, store_name, store_location_class, uri=None, image_id=None, store_specs=None): DCNL 'Create a new Location object. DCNL :param store_name: The string identifier/scheme of the storage backend DCNL :param store_location_class: The store location class to use DCNL for this location instance. DCNL :param image_id: The identifier of the image in whatever storage DCNL backend is used. DCNL :param uri: Optional URI to construct location from DCNL :param store_specs: Dictionary of information about the location DCNL of the image that is dependent on the backend DCNL store'
def get_store_uri(self): DCNL 'Returns the Glance image URI, which is the host:port of the API server DCNL along with /images/<IMAGE_ID>'
def process_specs(self): DCNL 'Subclasses should implement any processing of the self.specs collection DCNL such as storing credentials and possibly establishing connections.'
def get_uri(self): DCNL 'Subclasses should implement a method that returns an internal URI that, DCNL when supplied to the StoreLocation instance, can be interpreted by the DCNL StoreLocation\'s parse_uri() method. The URI returned from this method DCNL shall never be public and only used internally within Glance, so it is DCNL fine to encode credentials in this URI.'
def parse_uri(self, uri): DCNL 'Subclasses should implement a method that accepts a string URI and DCNL sets appropriate internal fields such that a call to get_uri() will DCNL return a proper internal URI'
def parse_uri(self, uri): DCNL 'Parse URLs. This method fixes an issue where credentials specified DCNL in the URL are interpreted differently in Python 2.6.1+ than prior DCNL versions of Python.'
def __iter__(self): DCNL 'Return an iterator over the image file'
def close(self): DCNL 'Close the internal file pointer'
def configure_add(self): DCNL 'Configure the Store to use the stored configuration options DCNL Any store that needs special configuration should implement DCNL this method. If the store was not able to successfully configure DCNL itself, it should raise `exception.BadStoreConfiguration`'
def get(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file, and returns a tuple of generator DCNL (for reading the image file) and image_size DCNL :param location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises `glance.exception.NotFound` if image does not exist'
def get_size(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file and returns the image size DCNL :param location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises `glance.exception.NotFound` if image does not exist DCNL :rtype int'
def delete(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file to delete DCNL :location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri() DCNL :raises NotFound if image does not exist DCNL :raises Forbidden if cannot delete because of permissions'
def add(self, image_id, image_file, image_size): DCNL 'Stores an image file with supplied identifier to the backend DCNL storage system and returns a tuple containing information DCNL about the stored image. DCNL :param image_id: The opaque image identifier DCNL :param image_file: The image data to write, as a file-like object DCNL :param image_size: The size of the image data to write, in bytes DCNL :retval tuple of URL in backing store, bytes written, and checksum DCNL :raises `glance.common.exception.Duplicate` if the image already DCNL existed DCNL :note By default, the backend writes the image data to a file DCNL `/<DATADIR>/<ID>`, where <DATADIR> is the value of DCNL the filesystem_store_datadir configuration option and <ID> DCNL is the supplied image ID.'
def parse_uri(self, uri): DCNL 'Parse URLs. This method fixes an issue where credentials specified DCNL in the URL are interpreted differently in Python 2.6.1+ than prior DCNL versions of Python.'
def get(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file, and returns a tuple of generator DCNL (for reading the image file) and image_size DCNL :param location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri()'
def get_size(self, location): DCNL 'Takes a `glance.store.location.Location` object that indicates DCNL where to find the image file, and returns the size DCNL :param location `glance.store.location.Location` object, supplied DCNL from glance.store.location.get_location_from_uri()'
def _get_conn_class(self, loc): DCNL 'Returns connection class for accessing the resource. Useful DCNL for dependency injection and stubouts in testing...'
def test_get_without_redirect(self): DCNL 'Test GET with no redirect'
def test_get_with_one_redirect(self): DCNL 'Test GET with one 302 FOUND redirect'
def test_get_with_one_redirect_query_string(self): DCNL 'Test GET with one 302 FOUND redirect w/ a query string'
def test_get_with_max_redirects(self): DCNL 'Test we don\'t redirect forever.'
def test_post_redirect(self): DCNL 'Test POST with 302 redirect'
def test_redirect_to_new_host(self): DCNL 'Test redirect to one host and then another.'
def test_image_get_all_marker_deleted(self): DCNL 'Cannot specify a deleted image as a marker.'
def test_image_get_all_marker_deleted_showing_deleted_as_admin(self): DCNL 'Specify a deleted image as a marker if showing deleted images.'
def test_image_get_all_marker_deleted_showing_deleted(self): DCNL 'Specify a deleted image as a marker if showing deleted images. DCNL A non-admin user has to explicitly ask for deleted DCNL images, and should only see deleted images in the results'
def test_image_paginate(self): DCNL 'Paginate through a list of images using limit and marker'
def test_owner1_finding_user1_memberships(self): DCNL 'Owner1 should see images it owns that are shared with User1'
def test_user1_finding_user1_memberships(self): DCNL 'User1 should see all images shared with User1'
def test_user2_finding_user1_memberships(self): DCNL 'User2 should see no images shared with User1'
def test_admin_finding_user1_memberships(self): DCNL 'Admin should see all images shared with User1'
def test_owner1_finding_owner1s_image_members(self): DCNL 'Owner1 should see all memberships of its image'
def test_admin_finding_owner1s_image_members(self): DCNL 'Admin should see all memberships of owner1\'s image'
def test_user1_finding_owner1s_image_members(self): DCNL 'User1 should see its own membership of owner1\'s image'
def test_user2_finding_owner1s_image_members(self): DCNL 'User2 should see its own membership of owner1\'s image'
def test_user3_finding_owner1s_image_members(self): DCNL 'User3 should see no memberships of owner1\'s image'
@skip_if_disabled DCNL def test_fallback_pidfile_uncreateable_dir(self): DCNL 'We test that glance-control falls back to a temporary pid file DCNL for non-existent pid file directory that cannot be created.'
@skip_if_disabled DCNL def test_fallback_pidfile_unwriteable_dir(self): DCNL 'We test that glance-control falls back to a temporary pid file DCNL for unwriteable pid file directory.'
@skip_if_disabled DCNL def test_respawn(self): DCNL 'We test that the \'--respawn\' option causes the API server DCNL to be respawned after death but not after a deliberate stop'
@skip_if_disabled DCNL def test_bouncing(self): DCNL 'We test that the \'--respawn\' option doesn\'t cause bouncing DCNL API server to be respawned'
@skip_if_disabled DCNL def test_reload(self): DCNL 'Exercise `glance-control api reload`'
@skip_if_disabled DCNL def test_infinite_child_death(self): DCNL 'Ensure child processes don\'t respawn forever if they can\'t start'
def test_verbose_debug(self): DCNL 'Test logging output proper when verbose and debug DCNL is on.'
def test_no_verbose_no_debug(self): DCNL 'Test logging output proper when verbose and debug DCNL is off.'
def test_logrotate(self): DCNL 'Test that we notice when our log file has been rotated'
def test_delayed_delete(self): DCNL 'test that images don\'t get deleted immediatly and that the scrubber DCNL scrubs them'
def test_scrubber_app(self): DCNL 'test that the glance-scrubber script runs successfully when not in DCNL daemon mode'
def test_scrubber_app_against_swift(self): DCNL 'test that the glance-scrubber script runs successfully against a swift DCNL backend when not in daemon mode'
def test_scrubber_with_metadata_enc(self): DCNL 'test that files written to scrubber_data_dir use DCNL metadata_encryption_key when available to encrypt the location'
def test_scrubber_handles_swift_missing(self): DCNL 'Test that the scrubber handles the case where the image to be scrubbed DCNL is missing from swift'
def __init__(self, test_dir, port): DCNL 'Creates a new Server object. DCNL :param test_dir: The directory where all test stuff is kept. This is DCNL passed from the FunctionalTestCase. DCNL :param port: The port to start a server up on.'
def write_conf(self, **kwargs): DCNL 'Writes the configuration file for the server to its intended DCNL destination.  Returns the name of the configuration file and DCNL the over-ridden config content (may be useful for populating DCNL error messages).'
def start(self, expect_exit=True, expected_exitcode=0, **kwargs): DCNL 'Starts the server. DCNL Any kwargs passed to this method will override the configuration DCNL value in the conf file used in starting the servers.'
def reload(self, expect_exit=True, expected_exitcode=0, **kwargs): DCNL 'Call glane-control reload for a specific server. DCNL Any kwargs passed to this method will override the configuration DCNL value in the conf file used in starting the servers.'
def create_database(self): DCNL 'Create database if required for this server'
def stop(self): DCNL 'Spin down the server.'
def cleanup(self): DCNL 'Makes sure anything we created or started up in the DCNL tests are destroyed or spun down'
def start_server(self, server, expect_launch, expect_exit=True, expected_exitcode=0, **kwargs): DCNL 'Starts a server on an unused port. DCNL Any kwargs passed to this method will override the configuration DCNL value in the conf file used in starting the server. DCNL :param server: the server to launch DCNL :param expect_launch: true iff the server is expected to DCNL successfully start DCNL :param expect_exit: true iff the launched process is expected DCNL to exit in a timely fashion DCNL :param expected_exitcode: expected exitcode from the launcher'
def start_with_retry(self, server, port_name, max_retries, expect_launch=True, expect_exit=True, expect_confirmation=True, **kwargs): DCNL 'Starts a server, with retries if the server launches but DCNL fails to start listening on the expected port. DCNL :param server: the server to launch DCNL :param port_name: the name of the port attribute DCNL :param max_retries: the maximum number of attempts DCNL :param expect_launch: true iff the server is expected to DCNL successfully start DCNL :param expect_exit: true iff the launched process is expected DCNL to exit in a timely fashion DCNL :param expect_confirmation: true iff launch confirmation msg DCNL expected on stdout'
def start_servers(self, **kwargs): DCNL 'Starts the API and Registry servers (bin/glance-control api start DCNL & bin/glance-control registry start) on unused ports. DCNL Any kwargs passed to this method will override the configuration DCNL value in the conf file used in starting the servers.'
def ping_server(self, port): DCNL 'Simple ping on the port. If responsive, return True, else DCNL return False. DCNL :note We use raw sockets, not ping here, since ping uses ICMP and DCNL has no concept of ports...'
def wait_for_servers(self, servers, expect_launch=True, timeout=10): DCNL 'Tight loop, waiting for the given server port(s) to be available. DCNL Returns when all are pingable. There is a timeout on waiting DCNL for the servers to come up. DCNL :param servers: Glance server ports to ping DCNL :param expect_launch: Optional, true iff the server(s) are DCNL expected to successfully start DCNL :param timeout: Optional, defaults to 3 seconds DCNL :return: None if launch expectation is met, otherwise an DCNL assertion message'
def reload_server(self, server, expect_launch, expect_exit=True, expected_exitcode=0, **kwargs): DCNL 'Reload a running server DCNL Any kwargs passed to this method will override the configuration DCNL value in the conf file used in starting the server. DCNL :param server: the server to launch DCNL :param expect_launch: true iff the server is expected to DCNL successfully start DCNL :param expect_exit: true iff the launched process is expected DCNL to exit in a timely fashion DCNL :param expected_exitcode: expected exitcode from the launcher'
def stop_server(self, server, name): DCNL 'Called to stop a single server in a normal fashion using the DCNL glance-control stop method to gracefully shut the server down. DCNL :param server: the server to stop'
def stop_servers(self): DCNL 'Called to stop the started servers in a normal fashion. Note DCNL that cleanup() will stop the servers using a fairly draconian DCNL method of sending a SIGTERM signal to the servers. Here, we use DCNL the glance-control stop method to gracefully shut the server down. DCNL This method also asserts that the shutdown was clean, and so it DCNL is meant to be called during a normal test case sequence.'
def run_sql_cmd(self, sql): DCNL 'Provides a crude mechanism to run manual SQL commands for backend DCNL DB verification within the functional tests. DCNL The raw result set is returned.'
@depends_on_exe('sqlite3') DCNL @skip_if_disabled DCNL def test_db_creation(self): DCNL 'Test DB creation by db_sync on a fresh DB'
@depends_on_exe('sqlite3') DCNL @skip_if_disabled DCNL def test_db_creation_auto_create_overridden(self): DCNL 'Test DB creation with db_auto_create False'
def stash_image(self, image_id, image_data): DCNL 'Store image data in the backend manually DCNL :param image_id: image identifier DCNL :param image_data: string representing image data fixture DCNL :return URI referencing newly-created backend object'
def test_lifecycle(self): DCNL 'Add, get and delete an image'
def test_get_remote_image(self): DCNL 'Get an image that was created externally to Glance'
def test_object_chunking(self): DCNL 'Upload an image that is split into multiple swift objects. DCNL We specifically check the case that DCNL image_size % swift_store_large_object_chunk_size != 0 to DCNL ensure we aren\'t losing image data.'
def test_multitenant(self): DCNL 'Ensure an image is properly configured when using multitenancy.'
@depends_on_exe('sqlite3') DCNL @skip_if_disabled DCNL def test_big_int_mapping(self): DCNL 'Ensure BigInteger not mapped to BIGINT'
def test_rate_limited(self): DCNL 'Test rate limited response'
def test_rate_limited_retry(self): DCNL 'Test rate limited response with retry'
def test_service_unavailable(self): DCNL 'Test service unavailable response'
def test_service_unavailable_retry(self): DCNL 'Test service unavailable response with retry'
def test_expectation_failed(self): DCNL 'Test expectation failed response'
def test_server_error(self): DCNL 'Test server error response'
def add_image(self, name): DCNL 'Adds an image with supplied name and returns the newly-created DCNL image identifier.'
def is_image_cached(self, image_id): DCNL 'Return True if supplied image ID is cached, False otherwise'
def iso_date(self, image_id): DCNL 'Return True if supplied image ID is cached, False otherwise'
def test_no_cache_enabled(self): DCNL 'Test that cache index command works'
def test_cache_index(self): DCNL 'Test that cache index command works'
def test_queue(self): DCNL 'Test that we can queue and fetch images using the DCNL CLI utility'
@skip_if_disabled DCNL def test_cache_middleware_transparent_v1(self): DCNL 'We test that putting the cache middleware into the DCNL application pipeline gives us transparent image caching'
@skip_if_disabled DCNL def test_cache_middleware_transparent_v2(self): DCNL 'Ensure the v2 API image transfer calls trigger caching'
@skip_if_disabled DCNL def test_cache_remote_image(self): DCNL 'We test that caching is no longer broken for remote images'
def add_image(self, name): DCNL 'Adds an image and returns the newly-added image DCNL identifier'
def verify_no_cached_images(self): DCNL 'Verify no images in the image cache'
@skip_if_disabled DCNL def test_cache_manage_get_cached_images(self): DCNL 'Tests that cached images are queryable'
@skip_if_disabled DCNL def test_cache_manage_delete_cached_images(self): DCNL 'Tests that cached images may be deleted'
@skip_if_disabled DCNL def test_queue_and_prefetch(self): DCNL 'Tests that images may be queued and prefetched'
def setUp(self): DCNL 'Test to see if the pre-requisites for the image cache DCNL are working (python-xattr installed and xattr support on the DCNL filesystem)'
def setUp(self): DCNL 'Test to see if the pre-requisites for the image cache DCNL are working (python-xattr installed and xattr support on the DCNL filesystem)'
def setUp(self): DCNL 'Test to see if the pre-requisites for the image cache DCNL are working (python-xattr installed and xattr support on the DCNL filesystem)'
def setUp(self): DCNL 'Test to see if the pre-requisites for the image cache DCNL are working (python-xattr installed and xattr support on the DCNL filesystem)'
def test_api_response_when_image_deleted_from_filesystem(self): DCNL 'A test for LP bug #781410 -- glance should fail more gracefully DCNL on requests for images that have been removed from the fs'
def test_exception_not_eaten_from_registry_to_api(self): DCNL 'A test for LP bug #704854 -- Exception thrown by registry DCNL server is consumed by API server. DCNL We start both servers daemonized. DCNL We then use curl to try adding an image that does not DCNL meet validation requirements on the registry server and test DCNL that the error returned from the API server to curl is appropriate'
def _do_test_copy_from(self, from_store, get_uri): DCNL 'Ensure we can copy from an external image in from_store.'
@requires(setup_swift, teardown_swift) DCNL @skip_if_disabled DCNL def test_copy_from_swift(self): DCNL 'Ensure we can copy from an external image in Swift.'
@requires(setup_s3, teardown_s3) DCNL @skip_if_disabled DCNL def test_copy_from_s3(self): DCNL 'Ensure we can copy from an external image in S3.'
@skip_if_disabled DCNL def _do_test_copy_from_http(self, exists): DCNL 'Ensure we can copy from an external image in HTTP. DCNL :param exists: True iff the external source image exists'
@skip_if_disabled DCNL def test_copy_from_file(self): DCNL 'Ensure we can\'t copy from file'
@skip_if_disabled DCNL def test_get_head_simple_post(self): DCNL 'We test the following sequential series of actions: DCNL 0. GET /images DCNL - Verify no public images DCNL 1. GET /images/detail DCNL - Verify no public images DCNL 2. POST /images with public image named Image1 DCNL and no custom properties DCNL - Verify 201 returned DCNL 3. HEAD image DCNL - Verify HTTP headers have correct information we just added DCNL 4. GET image DCNL - Verify all information on image we just added is correct DCNL 5. GET /images DCNL - Verify the image we just added is returned DCNL 6. GET /images/detail DCNL - Verify the image we just added is returned DCNL 7. PUT image with custom properties of "distro" and "arch" DCNL - Verify 200 returned DCNL 8. GET image DCNL - Verify updated information about image was stored DCNL 9. PUT image DCNL - Remove a previously existing property. DCNL 10. PUT image DCNL - Add a previously deleted property.'
@skip_if_disabled DCNL def test_queued_process_flow(self): DCNL 'We test the process flow where a user registers an image DCNL with Glance but does not immediately upload an image file. DCNL Later, the user uploads an image file using a PUT operation. DCNL We track the changing of image status throughout this process. DCNL 0. GET /images DCNL - Verify no public images DCNL 1. POST /images with public image named Image1 with no location DCNL attribute and no image data. DCNL - Verify 201 returned DCNL 2. GET /images DCNL - Verify one public image DCNL 3. HEAD image DCNL - Verify image now in queued status DCNL 4. PUT image with image data DCNL - Verify 200 returned DCNL 5. HEAD images DCNL - Verify image now in active status DCNL 6. GET /images DCNL - Verify one public image'
@skip_if_disabled DCNL def test_size_greater_2G_mysql(self): DCNL 'A test against the actual datastore backend for the registry DCNL to ensure that the image size property is not truncated. DCNL :see https://bugs.launchpad.net/glance/+bug/739433'
@skip_if_disabled DCNL def test_zero_initial_size(self): DCNL 'A test to ensure that an image with size explicitly set to zero DCNL has status that immediately transitions to active.'
@skip_if_disabled DCNL def test_traceback_not_consumed(self): DCNL 'A test that errors coming from the POST API do not DCNL get consumed and print the actual error message, and DCNL not something like &lt;traceback object at 0x1918d40&gt; DCNL :see https://bugs.launchpad.net/glance/+bug/755912'
@skip_if_disabled DCNL def test_filtered_images(self): DCNL 'Set up four test images and ensure each query param filter works'
@skip_if_disabled DCNL def test_limited_images(self): DCNL 'Ensure marker and limit query params work'
@skip_if_disabled DCNL def test_ordered_images(self): DCNL 'Set up three test images and ensure each query param filter works'
@skip_if_disabled DCNL def test_duplicate_image_upload(self): DCNL 'Upload initial image, then attempt to upload duplicate image'
@skip_if_disabled DCNL def test_delete_not_existing(self): DCNL 'We test the following: DCNL 0. GET /images/1 DCNL - Verify 404 DCNL 1. DELETE /images/1 DCNL - Verify 404'
@skip_if_disabled DCNL def test_unsupported_default_store(self): DCNL 'We test that a mis-configured default_store causes the API server DCNL to fail to start.'
def _do_test_post_image_content_bad_format(self, format): DCNL 'We test that missing container/disk format fails with 400 "Bad Request" DCNL :see https://bugs.launchpad.net/glance/+bug/933702'
def _do_test_put_image_content_missing_format(self, format): DCNL 'We test that missing container/disk format only fails with DCNL 400 "Bad Request" when the image content is PUT (i.e. not DCNL on the original POST of a queued image). DCNL :see https://bugs.launchpad.net/glance/+bug/937216'
def _do_test_mismatched_attribute(self, attribute, value): DCNL 'Test mismatched attribute.'
@skip_if_disabled DCNL def test_mismatched_size(self): DCNL 'Test mismatched size.'
@skip_if_disabled DCNL def test_mismatched_checksum(self): DCNL 'Test mismatched checksum.'
@skip_if_disabled DCNL def test_get_head_simple_post(self): DCNL 'We test the following sequential series of actions: DCNL 0. GET /images DCNL - Verify no public images DCNL 1. GET /images/detail DCNL - Verify no public images DCNL 2. POST /images with public image named Image1 DCNL and no custom properties DCNL - Verify 201 returned DCNL 3. HEAD image DCNL - Verify HTTP headers have correct information we just added DCNL 4. GET image DCNL - Verify all information on image we just added is correct DCNL 5. GET /images DCNL - Verify the image we just added is returned DCNL 6. GET /images/detail DCNL - Verify the image we just added is returned DCNL 7. PUT image with custom properties of "distro" and "arch" DCNL - Verify 200 returned DCNL 8. GET image DCNL - Verify updated information about image was stored DCNL 9. PUT image DCNL - Remove a previously existing property. DCNL 10. PUT image DCNL - Add a previously deleted property.'
@skip_if_disabled DCNL def test_queued_process_flow(self): DCNL 'We test the process flow where a user registers an image DCNL with Glance but does not immediately upload an image file. DCNL Later, the user uploads an image file using a PUT operation. DCNL We track the changing of image status throughout this process. DCNL 0. GET /images DCNL - Verify no public images DCNL 1. POST /images with public image named Image1 with no location DCNL attribute and no image data. DCNL - Verify 201 returned DCNL 2. GET /images DCNL - Verify one public image DCNL 3. HEAD image DCNL - Verify image now in queued status DCNL 4. PUT image with image data DCNL - Verify 200 returned DCNL 5. HEAD image DCNL - Verify image now in active status DCNL 6. GET /images DCNL - Verify one public image'
@skip_if_disabled DCNL def test_version_variations(self): DCNL 'We test that various calls to the images and root endpoints are DCNL handled properly, and that usage of the Accept: header does DCNL content negotiation properly.'
@skip_if_disabled DCNL def test_size_greater_2G_mysql(self): DCNL 'A test against the actual datastore backend for the registry DCNL to ensure that the image size property is not truncated. DCNL :see https://bugs.launchpad.net/glance/+bug/739433'
@skip_if_disabled DCNL def test_traceback_not_consumed(self): DCNL 'A test that errors coming from the POST API do not get consumed DCNL and print the actual error message, and DCNL not something like &lt;traceback object at 0x1918d40&gt; DCNL :see https://bugs.launchpad.net/glance/+bug/755912'
@skip_if_disabled DCNL def test_filtered_images(self): DCNL 'Set up four test images and ensure each query param filter works'
@skip_if_disabled DCNL def test_limited_images(self): DCNL 'Ensure marker and limit query params work'
@skip_if_disabled DCNL def test_ordered_images(self): DCNL 'Set up three test images and ensure each query param filter works'
@skip_if_disabled DCNL def test_duplicate_image_upload(self): DCNL 'Upload initial image, then attempt to upload duplicate image'
@skip_if_disabled DCNL def test_delete_not_existing(self): DCNL 'We test the following: DCNL 0. GET /images DCNL - Verify no public images DCNL 1. DELETE random image DCNL - Verify 404'
def test_multiprocessing(self): DCNL 'Spin up the api servers with multiprocessing on'
def test_interrupt_avoids_respawn_storm(self): DCNL 'Ensure an interrupt signal does not cause a respawn storm. DCNL See bug #978130'
def test_version_configurations(self): DCNL 'Test that versioning is handled properly through all channels'
def test_version_variations(self): DCNL 'Test that versioning is handled properly through all channels'
def do_HEAD(self): DCNL 'Respond to an image HEAD request fake metadata'
def do_GET(self): DCNL 'Respond to an image GET request with fake image content.'
def log_message(self, format, *args): DCNL 'Simple override to prevent writing crap to stderr...'
def config(self, **kw): DCNL 'Override some configuration values. DCNL The keyword arguments are the names of configuration options to DCNL override and their values. DCNL If a group argument is supplied, the overrides are applied to DCNL the specified configuration option group. DCNL All overrides are automatically cleared at the end of the current DCNL test by the fixtures cleanup process.'
def do_visible(self, exp_res, img_owner, img_public, **kwargs): DCNL 'Perform a context visibility test.  Creates a (fake) image DCNL with the specified owner and is_public attributes, then DCNL creates a context with the given keyword arguments and expects DCNL exp_res as the result of an is_image_visible() call on the DCNL context.'
def do_sharable(self, exp_res, img_owner, membership=None, **kwargs): DCNL 'Perform a context sharability test.  Creates a (fake) image DCNL with the specified owner and is_public attributes, then DCNL creates a context with the given keyword arguments and expects DCNL exp_res as the result of an is_image_sharable() call on the DCNL context.  If membership is not None, its value will be passed DCNL in as the \'membership\' keyword argument of DCNL is_image_sharable().'
def test_empty_public(self): DCNL 'Tests that an empty context (with is_admin set to True) can DCNL access an image with is_public set to True.'
def test_empty_public_owned(self): DCNL 'Tests that an empty context (with is_admin set to True) can DCNL access an owned image with is_public set to True.'
def test_empty_private(self): DCNL 'Tests that an empty context (with is_admin set to True) can DCNL access an image with is_public set to False.'
def test_empty_private_owned(self): DCNL 'Tests that an empty context (with is_admin set to True) can DCNL access an owned image with is_public set to False.'
def test_empty_shared(self): DCNL 'Tests that an empty context (with is_admin set to False) can DCNL not share an image, with or without membership.'
def test_anon_public(self): DCNL 'Tests that an anonymous context (with is_admin set to False) DCNL can access an image with is_public set to True.'
def test_anon_public_owned(self): DCNL 'Tests that an anonymous context (with is_admin set to False) DCNL can access an owned image with is_public set to True.'
def test_anon_private(self): DCNL 'Tests that an anonymous context (with is_admin set to False) DCNL can access an unowned image with is_public set to False.'
def test_anon_private_owned(self): DCNL 'Tests that an anonymous context (with is_admin set to False) DCNL cannot access an owned image with is_public set to False.'
def test_anon_shared(self): DCNL 'Tests that an empty context (with is_admin set to True) can DCNL not share an image, with or without membership.'
def test_auth_public(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) can access an image with is_public set to True.'
def test_auth_public_unowned(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) can access an image (which it does not own) with DCNL is_public set to True.'
def test_auth_public_owned(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) can access an image (which it does own) with is_public DCNL set to True.'
def test_auth_private(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) can access an image with is_public set to False.'
def test_auth_private_unowned(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) cannot access an image (which it does not own) with DCNL is_public set to False.'
def test_auth_private_owned(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) can access an image (which it does own) with is_public DCNL set to False.'
def test_auth_sharable(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) cannot share an image it neither owns nor is shared DCNL with it.'
def test_auth_sharable_admin(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL True) can share an image it neither owns nor is shared with DCNL it.'
def test_auth_sharable_owned(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) can share an image it owns, even if it is not shared DCNL with it.'
def test_auth_sharable_cannot_share(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) cannot share an image it does not own even if it is DCNL shared with it, but with can_share = False.'
def test_auth_sharable_can_share(self): DCNL 'Tests that an authenticated context (with is_admin set to DCNL False) can share an image it does not own if it is shared with DCNL it with can_share = True.'
def test_too_many_chunks(self): DCNL 'An image should streamed regardless of expected_size'
def enforce(self, _ctxt, action, target=None, **kwargs): DCNL 'Raise Forbidden if a rule for given action is set to false.'
def test_required_creds(self): DCNL 'Test that plugin created without required DCNL credential pieces raises an exception'
def test_invalid_auth_url_v1(self): DCNL 'Test that a 400 during authenticate raises exception.AuthBadRequst'
def test_invalid_auth_url_v2(self): DCNL 'Test that a 400 during authenticate raises exception.AuthBadRequst'
def test_v1_auth(self): DCNL 'Test v1 auth code paths'
def test_v2_auth(self): DCNL 'Test v2 auth code paths'
def test_empty_metadata_headers(self): DCNL 'Ensure unset metadata is not encoded in HTTP headers'
def test_get_location_from_uri_back_to_uri(self): DCNL 'Test that for various URIs, the correct Location DCNL object can be contructed and then the original URI DCNL returned via the get_store_uri() method.'
def test_bad_store_scheme(self): DCNL 'Test that a URI with a non-existing scheme triggers exception'
def test_filesystem_store_location(self): DCNL 'Test the specific StoreLocation for the Filesystem store'
def test_http_store_location(self): DCNL 'Test the specific StoreLocation for the HTTP store'
def test_swift_store_location(self): DCNL 'Test the specific StoreLocation for the Swift store'
def test_s3_store_location(self): DCNL 'Test the specific StoreLocation for the S3 store'
def test_rbd_store_location(self): DCNL 'Test the specific StoreLocation for the RBD store'
def test_get_store_from_scheme(self): DCNL 'Test that the backend returned by glance.store.get_backend_class DCNL is correct or raises an appropriate error.'
def test_policy_file_specified_but_not_found(self): DCNL 'Missing defined policy file should result in a default ruleset'
def test_policy_file_default_not_found(self): DCNL 'Missing default policy file should result in a default ruleset'
def test_show_deleted_properties(self): DCNL 'Ensure that the api filters out deleted image properties.'
def test_delete_queued_updates_status(self): DCNL 'Ensure status of queued image is updated (LP bug #1048851)'
def test_delete_queued_updates_status_delayed_delete(self): DCNL 'Ensure status of queued image is updated (LP bug #1048851) DCNL to \'deleted\' when delayed_delete isenabled'
def test_show_invalid_additional_property(self): DCNL 'Ensure that the serializer passes through invalid additional DCNL properties (i.e. non-string) without complaining.'
def setUp(self): DCNL 'Establish a clean test environment'
def tearDown(self): DCNL 'Clear the test environment'
def test_get_image_index(self): DCNL 'Test correct set of public image returned'
def test_get_index_sort_name_asc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted alphabetically by name in DCNL ascending order.'
def test_get_index_sort_status_desc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted alphabetically by status in DCNL descending order.'
def test_get_index_sort_disk_format_asc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted alphabetically by disk_format in DCNL ascending order.'
def test_get_index_sort_container_format_desc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted alphabetically by container_format in DCNL descending order.'
def test_get_index_sort_size_asc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted by size in ascending order.'
def test_get_index_sort_created_at_asc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted by created_at in ascending order.'
def test_get_index_sort_updated_at_desc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted by updated_at in descending order.'
def test_get_image_index_marker(self): DCNL 'Test correct set of images returned with marker param.'
def test_get_image_index_invalid_marker(self): DCNL 'Test exception is raised when marker is invalid'
def test_get_image_index_limit(self): DCNL 'Test correct number of images returned with limit param.'
def test_get_image_index_marker_limit(self): DCNL 'Test correct set of images returned with marker/limit params.'
def test_get_image_index_limit_None(self): DCNL 'Test correct set of images returned with limit param == None.'
def test_get_image_index_by_name(self): DCNL 'Test correct set of public, name-filtered image returned. This DCNL is just a sanity check, we test the details call more in-depth.'
def test_get_image_details(self): DCNL 'Tests that the detailed info about public images returned'
def test_get_image_details_marker_limit(self): DCNL 'Test correct set of images returned with marker/limit params.'
def test_get_image_details_invalid_marker(self): DCNL 'Test exception is raised when marker is invalid'
def test_get_image_details_by_name(self): DCNL 'Tests that a detailed call can be filtered by name'
def test_get_image_details_by_status(self): DCNL 'Tests that a detailed call can be filtered by status'
def test_get_image_details_by_container_format(self): DCNL 'Tests that a detailed call can be filtered by container_format'
def test_get_image_details_by_disk_format(self): DCNL 'Tests that a detailed call can be filtered by disk_format'
def test_get_image_details_with_maximum_size(self): DCNL 'Tests that a detailed call can be filtered by size_max'
def test_get_image_details_with_minimum_size(self): DCNL 'Tests that a detailed call can be filtered by size_min'
def test_get_image_details_with_changes_since(self): DCNL 'Tests that a detailed call can be filtered by size_min'
def test_get_image_details_with_changes_since(self): DCNL 'Tests that a detailed call can be filtered by changes-since'
def test_get_image_details_by_property(self): DCNL 'Tests that a detailed call can be filtered by a property'
def test_get_image_details_sort_disk_format_asc(self): DCNL 'Tests that a detailed call returns list of DCNL public images sorted alphabetically by disk_format in DCNL ascending order.'
def test_get_image(self): DCNL 'Tests that the detailed info about an image returned'
def test_get_image_non_existing(self): DCNL 'Tests that NotFound is raised when getting a non-existing image'
def test_add_image_basic(self): DCNL 'Tests that we can add image metadata and returns the new id'
def test_add_image_with_properties(self): DCNL 'Tests that we can add image metadata with properties'
def test_add_image_already_exists(self): DCNL 'Tests proper exception is raised if image with ID already exists'
def test_add_image_with_bad_status(self): DCNL 'Tests proper exception is raised if a bad status is set'
def test_update_image(self): DCNL 'Tests that the /images PUT registry API updates the image'
def test_update_image_not_existing(self): DCNL 'Tests non existing image update doesn\'t work'
def test_delete_image(self): DCNL 'Tests that image metadata is deleted properly'
def test_delete_image_not_existing(self): DCNL 'Tests cannot delete non-existing image'
def test_get_image_members(self): DCNL 'Tests getting image members'
def test_get_image_members_not_existing(self): DCNL 'Tests getting non-existent image members'
def test_get_member_images(self): DCNL 'Tests getting member images'
def test_add_replace_members(self): DCNL 'Tests replacing image members'
def test_add_delete_member(self): DCNL 'Tests deleting image members'
def setUp(self): DCNL 'Establish a clean test environment'
def test_get(self): DCNL 'Test a "normal" retrieval of an image in chunks'
def test_get_calling_format_path(self): DCNL 'Test a "normal" retrieval of an image in chunks'
def test_get_calling_format_default(self): DCNL 'Test a "normal" retrieval of an image in chunks'
def test_get_non_existing(self): DCNL 'Test that trying to retrieve a s3 that doesn\'t exist DCNL raises an error'
def test_add(self): DCNL 'Test that we can add an image via the s3 backend'
def test_add_host_variations(self): DCNL 'Test that having http(s):// in the s3serviceurl in config DCNL options works as expected.'
def test_add_already_existing(self): DCNL 'Tests that adding an image with an existing identifier DCNL raises an appropriate exception'
def test_no_access_key(self): DCNL 'Tests that options without access key disables the add method'
def test_no_secret_key(self): DCNL 'Tests that options without secret key disables the add method'
def test_no_host(self): DCNL 'Tests that options without host disables the add method'
def test_delete(self): DCNL 'Test we can delete an existing image in the s3 store'
def test_delete_non_existing(self): DCNL 'Test that trying to delete a s3 that doesn\'t exist DCNL raises an error'
def test_get_s3_good_location(self): DCNL 'Test that the s3 location can be derived from the host'
def test_get_s3_bad_location(self): DCNL 'Test that the s3 location cannot be derived from an unexpected host'
@skip_if_disabled DCNL def test_is_cached(self): DCNL 'Verify is_cached(1) returns 0, then add something to the cache DCNL and verify is_cached(1) returns 1.'
@skip_if_disabled DCNL def test_read(self): DCNL 'Verify is_cached(1) returns 0, then add something to the cache DCNL and verify after a subsequent read from the cache that DCNL is_cached(1) returns 1.'
@skip_if_disabled DCNL def test_open_for_read(self): DCNL 'Test convenience wrapper for opening a cache file via DCNL its image identifier.'
@skip_if_disabled DCNL def test_get_image_size(self): DCNL 'Test convenience wrapper for querying cache file size via DCNL its image identifier.'
@skip_if_disabled DCNL def test_delete(self): DCNL 'Test delete method that removes an image from the cache'
@skip_if_disabled DCNL def test_delete_all(self): DCNL 'Test delete method that removes an image from the cache'
@skip_if_disabled DCNL def test_clean_stalled(self): DCNL 'Test the clean method removes expected images'
@skip_if_disabled DCNL def test_prune(self): DCNL 'Test that pruning the cache works as expected...'
@skip_if_disabled DCNL def test_prune_to_zero(self): DCNL 'Test that an image_cache_max_size of 0 doesn\'t kill the pruner DCNL This is a test specifically for LP #1039854'
@skip_if_disabled DCNL def test_queue(self): DCNL 'Test that queueing works properly'
def test_open_for_write_good(self): DCNL 'Test to see if open_for_write works in normal case'
def test_open_for_write_with_exception(self): DCNL 'Test to see if open_for_write works in a failure case for each driver DCNL This case is where an exception is raised while the file is being DCNL written. The image is partially filled in cache and filling wont resume DCNL so verify the image is moved to invalid/ directory'
def test_caching_iterator(self): DCNL 'Test to see if the caching iterator interacts properly with the driver DCNL When the iterator completes going through the data the driver should DCNL have closed the image and placed it correctly'
def test_caching_iterator_handles_backend_failure(self): DCNL 'Test that when the backend fails, caching_iter does not continue trying DCNL to consume data, and rolls back the cache.'
def test_caching_iterator_falloffend(self): DCNL 'Test to see if the caching iterator interacts properly with the driver DCNL in a case where the iterator is only partially consumed. In this case DCNL the image is only partially filled in cache and filling wont resume. DCNL When the iterator goes out of scope the driver should have closed the DCNL image and moved it from incomplete/ to invalid/'
def setUp(self): DCNL 'Test to see if the pre-requisites for the image cache DCNL are working (python-xattr installed and xattr support on the DCNL filesystem)'
def setUp(self): DCNL 'Test to see if the pre-requisites for the image cache DCNL are working (python-sqlite3 installed)'
def test_headers_are_unicode(self): DCNL 'Verifies that the headers returned by conversion code are unicode. DCNL Headers are passed via http in non-testing mode, which automatically DCNL converts them to unicode. Verifying that the method does the DCNL conversion proves that we aren\'t passing data that works in tests DCNL but will fail in production.'
def test_data_passed_properly_through_headers(self): DCNL 'Verifies that data is the same after being passed through headers'
def test_time_is_monkey_patched(self): DCNL 'Test GET with no redirect'
def test_get_size(self): DCNL 'Test that we can get the size of an object in the swift store'
def test_get_size_with_multi_tenant_on(self): DCNL 'Test that single tenant uris work with multi tenant on.'
def test_get(self): DCNL 'Test a "normal" retrieval of an image in chunks'
def test_get_with_http_auth(self): DCNL 'Test a retrieval from Swift with an HTTP authurl. This is DCNL specified either via a Location header with swift+http:// or using DCNL http:// in the swift_store_auth_address config value'
def test_get_non_existing(self): DCNL 'Test that trying to retrieve a swift that doesn\'t exist DCNL raises an error'
def test_add(self): DCNL 'Test that we can add an image via the swift backend'
def test_add_auth_url_variations(self): DCNL 'Test that we can add an image via the swift backend with DCNL a variety of different auth_address values'
def test_add_no_container_no_create(self): DCNL 'Tests that adding an image with a non-existing container DCNL raises an appropriate exception'
def test_add_no_container_and_create(self): DCNL 'Tests that adding an image with a non-existing container DCNL creates the container automatically if flag is set'
def test_add_large_object(self): DCNL 'Tests that adding a very large image. We simulate the large DCNL object by setting store.large_object_size to a small number DCNL and then verify that there have been a number of calls to DCNL put_object()...'
def test_add_large_object_zero_size(self): DCNL 'Tests that adding an image to Swift which has both an unknown size and DCNL exceeds Swift\'s maximum limit of 5GB is correctly uploaded. DCNL We avoid the overhead of creating a 5GB object for this test by DCNL temporarily setting MAX_SWIFT_OBJECT_SIZE to 1KB, and then adding DCNL an object of 5KB. DCNL Bug lp:891738'
def test_add_already_existing(self): DCNL 'Tests that adding an image with an existing identifier DCNL raises an appropriate exception'
def test_no_user(self): DCNL 'Tests that options without user disables the add method'
def test_no_key(self): DCNL 'Tests that options without key disables the add method'
def test_no_auth_address(self): DCNL 'Tests that options without auth address disables the add method'
def test_delete(self): DCNL 'Test we can delete an existing image in the swift store'
def test_delete_non_existing(self): DCNL 'Test that trying to delete a swift that doesn\'t exist DCNL raises an error'
def test_read_acl_public(self): DCNL 'Test that we can set a public read acl.'
def test_read_acl_tenants(self): DCNL 'Test that we can set read acl for tenants.'
def test_read_write_public(self): DCNL 'Test that we can set write acl for tenants.'
def setUp(self): DCNL 'Establish a clean test environment'
def test_read_all_data(self): DCNL 'Replicate what goes on in the Swift driver with the DCNL repeated creation of the ChunkReader object'
def test_v1_deleted_image_fetch(self): DCNL 'Test for determining that when an admin tries to download a deleted DCNL image it returns 404 Not Found error.'
def test_process_v1_request_for_deleted_but_cached_image(self): DCNL 'Test for determining image is deleted from cache when it is not found DCNL in Glance Registry.'
def setUp(self): DCNL 'Establish a clean test environment'
def test_bad_sql_connection(self): DCNL 'Test that a bad sql_connection option supplied to the registry DCNL API controller results in a) an Exception being thrown and b) DCNL a message being logged to the registry log file...'
def setUp(self): DCNL 'Establish a clean test environment'
def tearDown(self): DCNL 'Clear the test environment'
def test_show(self): DCNL 'Tests that the /images/<id> registry API endpoint DCNL returns the expected image'
def test_show_unknown(self): DCNL 'Tests that the /images/<id> registry API endpoint DCNL returns a 404 for an unknown image id'
def test_show_invalid(self): DCNL 'Tests that the /images/<id> registry API endpoint DCNL returns a 404 for an invalid (therefore unknown) image id'
def test_show_deleted_image_as_admin(self): DCNL 'Tests that the /images/<id> registry API endpoint DCNL returns a 200 for deleted image to admin user.'
def test_show_deleted_image_as_nonadmin(self): DCNL 'Tests that the /images/<id> registry API endpoint DCNL returns a 404 for deleted image to non-admin user.'
def test_get_root(self): DCNL 'Tests that the root registry API returns "index", DCNL which is a list of public images'
def test_get_index(self): DCNL 'Tests that the /images registry API returns list of DCNL public images'
def test_get_index_marker(self): DCNL 'Tests that the /images registry API returns list of DCNL public images that conforms to a marker query param'
def test_get_index_unknown_marker(self): DCNL 'Tests that the /images registry API returns a 400 DCNL when an unknown marker is provided'
def test_get_index_malformed_marker(self): DCNL 'Tests that the /images registry API returns a 400 DCNL when a malformed marker is provided'
def test_get_index_limit(self): DCNL 'Tests that the /images registry API returns list of DCNL public images that conforms to a limit query param'
def test_get_index_limit_negative(self): DCNL 'Tests that the /images registry API returns list of DCNL public images that conforms to a limit query param'
def test_get_index_limit_non_int(self): DCNL 'Tests that the /images registry API returns list of DCNL public images that conforms to a limit query param'
def test_get_index_limit_marker(self): DCNL 'Tests that the /images registry API returns list of DCNL public images that conforms to limit and marker query params'
def test_get_index_filter_name(self): DCNL 'Tests that the /images registry API returns list of DCNL public images that have a specific name. This is really a sanity DCNL check, filtering is tested more in-depth using /images/detail'
def test_get_index_sort_default_created_at_desc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images that conforms to a default sort key/dir'
def test_get_index_bad_sort_key(self): DCNL 'Ensure a 400 is returned when a bad sort_key is provided.'
def test_get_index_bad_sort_dir(self): DCNL 'Ensure a 400 is returned when a bad sort_dir is provided.'
def test_get_index_sort_name_asc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted alphabetically by name in DCNL ascending order.'
def test_get_index_sort_status_desc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted alphabetically by status in DCNL descending order.'
def test_get_index_sort_disk_format_asc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted alphabetically by disk_format in DCNL ascending order.'
def test_get_index_sort_container_format_desc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted alphabetically by container_format in DCNL descending order.'
def test_get_index_sort_size_asc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted by size in ascending order.'
def test_get_index_sort_created_at_asc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted by created_at in ascending order.'
def test_get_index_sort_updated_at_desc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted by updated_at in descending order.'
def test_get_details(self): DCNL 'Tests that the /images/detail registry API returns DCNL a mapping containing a list of detailed image information'
def test_get_details_limit_marker(self): DCNL 'Tests that the /images/details registry API returns list of DCNL public images that conforms to limit and marker query params. DCNL This functionality is tested more thoroughly on /images, this is DCNL just a sanity check'
def test_get_details_invalid_marker(self): DCNL 'Tests that the /images/detail registry API returns a 400 DCNL when an invalid marker is provided'
def test_get_details_filter_name(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a specific name'
def test_get_details_filter_status(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a specific status'
def test_get_details_filter_container_format(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a specific container_format'
def test_get_details_filter_min_disk(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a specific min_disk'
def test_get_details_filter_min_ram(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a specific min_ram'
def test_get_details_filter_disk_format(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a specific disk_format'
def test_get_details_filter_size_min(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a size greater than or equal to size_min'
def test_get_details_filter_size_max(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a size less than or equal to size_max'
def test_get_details_filter_size_min_max(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a size less than or equal to size_max DCNL and greater than or equal to size_min'
def test_get_details_filter_changes_since(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a size less than or equal to size_max'
def test_get_details_filter_property(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a specific custom property'
def test_get_details_filter_public_none(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL all images if is_public none is passed'
def test_get_details_filter_public_false(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL private images if is_public false is passed'
def test_get_details_filter_public_true(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images if is_public true is passed (same as default)'
def test_get_details_sort_name_asc(self): DCNL 'Tests that the /images/details registry API returns list of DCNL public images sorted alphabetically by name in DCNL ascending order.'
def test_create_image(self): DCNL 'Tests that the /images POST registry API creates the image'
def test_create_image_with_min_disk(self): DCNL 'Tests that the /images POST registry API creates the image'
def test_create_image_with_min_ram(self): DCNL 'Tests that the /images POST registry API creates the image'
def test_create_image_with_min_ram_default(self): DCNL 'Tests that the /images POST registry API creates the image'
def test_create_image_with_min_disk_default(self): DCNL 'Tests that the /images POST registry API creates the image'
def test_create_image_with_bad_status(self): DCNL 'Tests proper exception is raised if a bad status is set'
def test_create_image_with_bad_id(self): DCNL 'Tests proper exception is raised if a bad disk_format is set'
def test_update_image(self): DCNL 'Tests that the /images PUT registry API updates the image'
def test_update_image_not_existing(self): DCNL 'Tests proper exception is raised if attempt to update DCNL non-existing image'
def test_update_image_with_bad_status(self): DCNL 'Tests that exception raised trying to set a bad status'
def test_delete_image(self): DCNL 'Tests that the /images DELETE registry API deletes the image'
def test_delete_image_response(self): DCNL 'Tests that the registry API delete returns the image metadata'
def test_delete_image_not_existing(self): DCNL 'Tests proper exception is raised if attempt to delete DCNL non-existing image'
def test_get_image_members(self): DCNL 'Tests members listing for existing images'
def test_get_image_members_not_existing(self): DCNL 'Tests proper exception is raised if attempt to get members of DCNL non-existing image'
def test_get_member_images(self): DCNL 'Tests image listing for members'
def test_replace_members(self): DCNL 'Tests replacing image members raises right exception'
def test_add_member(self): DCNL 'Tests adding image members raises right exception'
def test_delete_member(self): DCNL 'Tests deleting image members raises right exception'
def test_delete_member_invalid(self): DCNL 'Tests deleting a invalid/non existing member raises right exception'
def setUp(self): DCNL 'Establish a clean test environment'
def tearDown(self): DCNL 'Clear the test environment'
def test_add_image_no_location_no_image_as_body(self): DCNL 'Tests creates a queued image for no body and no loc header'
def test_add_image_no_location_no_content_type(self): DCNL 'Tests creates a queued image for no body and no loc header'
def test_add_image_size_header_too_big(self): DCNL 'Tests raises BadRequest for supplied image size that is too big'
def test_add_image_zero_size(self): DCNL 'Tests creating an active image with explicitly zero size'
def test_add_image_bad_store(self): DCNL 'Tests raises BadRequest for invalid store header'
def test_add_image_basic_file_store(self): DCNL 'Tests to add a basic image in the file store'
def _do_test_post_image_content_missing_format(self, missing): DCNL 'Tests creation of an image with missing format'
def test_post_image_content_missing_disk_format(self): DCNL 'Tests creation of an image with missing disk format'
def test_post_image_content_missing_container_type(self): DCNL 'Tests creation of an image with missing container format'
def _do_test_put_image_content_missing_format(self, missing): DCNL 'Tests delayed activation of an image with missing format'
def test_put_image_content_missing_disk_format(self): DCNL 'Tests delayed activation of image with missing disk format'
def test_put_image_content_missing_container_type(self): DCNL 'Tests delayed activation of image with missing container format'
def test_update_deleted_image(self): DCNL 'Tests that exception raised trying to update a deleted image'
def test_delete_deleted_image(self): DCNL 'Tests that exception raised trying to delete a deleted image'
def test_register_and_upload(self): DCNL 'Test that the process of registering an image with DCNL some metadata, then uploading an image file with some DCNL more metadata doesn\'t mark the original metadata deleted DCNL :see LP Bug#901534'
def test_disable_purge_props(self): DCNL 'Test the special x-glance-registry-purge-props header controls DCNL the purge property behaviour of the registry. DCNL :see LP Bug#901534'
def test_publicize_image_unauthorized(self): DCNL 'Create a non-public image then fail to make public'
def test_update_image_size_header_too_big(self): DCNL 'Tests raises BadRequest for supplied image size that is too big'
def test_get_index_sort_name_asc(self): DCNL 'Tests that the /images registry API returns list of DCNL public images sorted alphabetically by name in DCNL ascending order.'
def test_get_details_filter_changes_since(self): DCNL 'Tests that the /images/detail registry API returns list of DCNL public images that have a size less than or equal to size_max'
def test_store_location_not_revealed(self): DCNL 'Test that the internal store location is NOT revealed DCNL through the API server'
def test_image_is_checksummed(self): DCNL 'Test that the image contents are checksummed properly'
def test_etag_equals_checksum_header(self): DCNL 'Test that the ETag header matches the x-image-meta-checksum'
def test_bad_checksum_prevents_image_creation(self): DCNL 'Test that the image contents are checksummed properly'
def test_image_meta(self): DCNL 'Test for HEAD /images/<ID>'
def test_delete_queued_image(self): DCNL 'Delete an image in a queued state DCNL Bug #747799 demonstrated that trying to DELETE an image DCNL that had had its save process killed manually results in failure DCNL because the location attribute is None. DCNL Bug #1048851 demonstrated that the status was not properly DCNL being updated to \'deleted\' from \'queued\'.'
def test_delete_queued_image_delayed_delete(self): DCNL 'Delete an image in a queued state when delayed_delete is on DCNL Bug #1048851 demonstrated that the status was not properly DCNL being updated to \'deleted\' from \'queued\'.'
def test_get_details_invalid_marker(self): DCNL 'Tests that the /images/detail registry API returns a 400 DCNL when an invalid marker is provided'
def test_get_image_members(self): DCNL 'Tests members listing for existing images'
def test_get_image_members_not_existing(self): DCNL 'Tests proper exception is raised if attempt to get members of DCNL non-existing image'
def test_get_member_images(self): DCNL 'Tests image listing for members'
def test_replace_members(self): DCNL 'Tests replacing image members raises right exception'
def test_add_member(self): DCNL 'Tests adding image members raises right exception'
def test_delete_member(self): DCNL 'Tests deleting image members raises right exception'
def setUp(self): DCNL 'Establish a clean test environment'
def test_show_notify(self): DCNL 'Make sure an eventlet posthook for notify_image_sent is added.'
def test_image_send_notification_error(self): DCNL 'Ensure image.send notification is sent on error.'
def test_redact_location(self): DCNL 'Ensure location redaction does not change original metadata'
def test_noop_redact_location(self): DCNL 'Check no-op location redaction does not change original metadata'
def test_cooperative_reader(self): DCNL 'Ensure cooperative reader class accesses all bytes of file'
def test_cooperative_reader_of_iterator(self): DCNL 'Ensure cooperative reader supports iterator backends too'
def test_limiting_reader(self): DCNL 'Ensure limiting reader class accesses all bytes of file'
def test_limiting_reader_fails(self): DCNL 'Ensure limiting reader class throws exceptions if limit exceeded'
def setUp(self): DCNL 'Establish a clean test environment'
def tearDown(self): DCNL 'Clear the test environment'
def test_get(self): DCNL 'Test a "normal" retrieval of an image in chunks'
def test_get_non_existing(self): DCNL 'Test that trying to retrieve a file that doesn\'t exist DCNL raises an error'
def test_add(self): DCNL 'Test that we can add an image via the filesystem backend'
def test_add_already_existing(self): DCNL 'Tests that adding an image with an existing identifier DCNL raises an appropriate exception'
def test_add_storage_full(self): DCNL 'Tests that adding an image without enough space on disk DCNL raises an appropriate exception'
def test_add_file_too_big(self): DCNL 'Tests that adding an excessively large image file DCNL raises an appropriate exception'
def test_add_storage_write_denied(self): DCNL 'Tests that adding an image with insufficient filestore permissions DCNL raises an appropriate exception'
def test_add_other_failure(self): DCNL 'Tests that a non-space-related IOError does not raise a DCNL StorageFull exception.'
def test_add_cleanup_on_read_failure(self): DCNL 'Tests the partial image file is cleaned up after a read DCNL failure.'
def test_delete(self): DCNL 'Test we can delete an existing image in the filesystem store'
def test_delete_non_existing(self): DCNL 'Test that trying to delete a file that doesn\'t exist DCNL raises an error'
def test_walk_versions(self): DCNL 'Walks all version scripts for each tested database, ensuring DCNL that there are no errors in the version scripts for each engine'
def test_mysql_connect_fail(self): DCNL 'Test that we can trigger a mysql connection failure and we fail DCNL gracefully to ensure we don\'t break people without mysql'
def test_postgresql_connect_fail(self): DCNL 'Test that we can trigger a postgres connection failure and we fail DCNL gracefully to ensure we don\'t break people without postgres'
def _migrate_up(self, engine, version, with_data=False): DCNL 'migrate up to a new version of the db. DCNL We allow for data insertion and post checks at every DCNL migration version with special _prerun_### and DCNL _check_### functions in the main test.'
def test_version_control_existing_db(self): DCNL 'Creates a DB without version control information, places it DCNL under version control and checks that it can be upgraded DCNL without errors.'
def _prerun_004(self, engine): DCNL 'Insert checksum data sample to check if migration goes fine with DCNL data'
def _check_004(self, engine, data): DCNL 'Assure that checksum data is present on table'
def init_driver(self): DCNL 'Create the driver for the cache'
def configure_driver(self): DCNL 'Configure the driver for the cache and, if it fails to configure, DCNL fall back to using the SQLite driver which has no odd dependencies'
def is_cached(self, image_id): DCNL 'Returns True if the image with the supplied ID has its image DCNL file cached. DCNL :param image_id: Image ID'
def is_queued(self, image_id): DCNL 'Returns True if the image identifier is in our cache queue. DCNL :param image_id: Image ID'
def get_cache_size(self): DCNL 'Returns the total size in bytes of the image cache.'
def get_hit_count(self, image_id): DCNL 'Return the number of hits that an image has DCNL :param image_id: Opaque image identifier'
def get_cached_images(self): DCNL 'Returns a list of records about cached images.'
def delete_all_cached_images(self): DCNL 'Removes all cached image files and any attributes about the images DCNL and returns the number of cached image files that were deleted.'
def delete_cached_image(self, image_id): DCNL 'Removes a specific cached image file and any attributes about the image DCNL :param image_id: Image ID'
def delete_all_queued_images(self): DCNL 'Removes all queued image files and any attributes about the images DCNL and returns the number of queued image files that were deleted.'
def delete_queued_image(self, image_id): DCNL 'Removes a specific queued image file and any attributes about the image DCNL :param image_id: Image ID'
def prune(self): DCNL 'Removes all cached image files above the cache\'s maximum DCNL size. Returns a tuple containing the total number of cached DCNL files removed and the total size of all pruned image files.'
def clean(self, stall_time=None): DCNL 'Cleans up any invalid or incomplete cached images. The cache driver DCNL decides what that means...'
def queue_image(self, image_id): DCNL 'This adds a image to be cache to the queue. DCNL If the image already exists in the queue or has already been DCNL cached, we return False, True otherwise DCNL :param image_id: Image ID'
def get_caching_iter(self, image_id, image_checksum, image_iter): DCNL 'Returns an iterator that caches the contents of an image DCNL while the image contents are read through the supplied DCNL iterator. DCNL :param image_id: Image ID DCNL :param image_checksum: checksum expected to be generated while DCNL iterating over image data DCNL :param image_iter: Iterator that will read image contents'
def cache_image_iter(self, image_id, image_iter): DCNL 'Cache an image with supplied iterator. DCNL :param image_id: Image ID DCNL :param image_file: Iterator retrieving image chunks DCNL :retval True if image file was cached, False otherwise'
def cache_image_file(self, image_id, image_file): DCNL 'Cache an image file. DCNL :param image_id: Image ID DCNL :param image_file: Image file to cache DCNL :retval True if image file was cached, False otherwise'
def open_for_read(self, image_id): DCNL 'Open and yield file for reading the image file for an image DCNL with supplied identifier. DCNL :note Upon successful reading of the image file, the image\'s DCNL hit count will be incremented. DCNL :param image_id: Image ID'
def get_image_size(self, image_id): DCNL 'Return the size of the image file for an image with supplied DCNL identifier. DCNL :param image_id: Image ID'
def get_queued_images(self): DCNL 'Returns a list of image IDs that are in the queue. The DCNL list should be sorted by the time the image ID was inserted DCNL into the queue.'
def configure(self): DCNL 'Configure the driver to use the stored configuration options DCNL Any store that needs special configuration should implement DCNL this method. If the store was not able to successfully configure DCNL itself, it should raise `exception.BadDriverConfiguration`'
def get_cache_size(self): DCNL 'Returns the total size in bytes of the image cache.'
def get_hit_count(self, image_id): DCNL 'Return the number of hits that an image has. DCNL :param image_id: Opaque image identifier'
def get_cached_images(self): DCNL 'Returns a list of records about cached images.'
def is_cached(self, image_id): DCNL 'Returns True if the image with the supplied ID has its image DCNL file cached. DCNL :param image_id: Image ID'
def is_cacheable(self, image_id): DCNL 'Returns True if the image with the supplied ID can have its DCNL image file cached, False otherwise. DCNL :param image_id: Image ID'
def is_being_cached(self, image_id): DCNL 'Returns True if the image with supplied id is currently DCNL in the process of having its image file cached. DCNL :param image_id: Image ID'
def is_queued(self, image_id): DCNL 'Returns True if the image identifier is in our cache queue. DCNL :param image_id: Image ID'
def delete_all_cached_images(self): DCNL 'Removes all cached image files and any attributes about the images'
def delete_cached_image(self, image_id): DCNL 'Removes a specific cached image file and any attributes about the image DCNL :param image_id: Image ID'
def delete_all_queued_images(self): DCNL 'Removes all queued image files and any attributes about the images'
def delete_queued_image(self, image_id): DCNL 'Removes a specific queued image file and any attributes about the image DCNL :param image_id: Image ID'
def clean(self, stall_time=None): DCNL 'Delete any image files in the invalid directory and any DCNL files in the incomplete directory that are older than a DCNL configurable amount of time.'
def get_least_recently_accessed(self): DCNL 'Return a tuple containing the image_id and size of the least recently DCNL accessed cached file, or None if no cached files.'
@contextmanager DCNL def open_for_write(self, image_id): DCNL 'Open a file for writing the image file for an image DCNL with supplied identifier. DCNL :param image_id: Image ID'
@contextmanager DCNL def open_for_read(self, image_id): DCNL 'Open and yield file for reading the image file for an image DCNL with supplied identifier. DCNL :param image_id: Image ID'
@contextmanager DCNL def get_db(self): DCNL 'Returns a context manager that produces a database connection that DCNL self-closes and calls rollback if an error occurs while using the DCNL database connection'
def queue_image(self, image_id): DCNL 'This adds a image to be cache to the queue. DCNL If the image already exists in the queue or has already been DCNL cached, we return False, True otherwise DCNL :param image_id: Image ID'
def delete_invalid_files(self): DCNL 'Removes any invalid cache entries'
def delete_stalled_files(self, older_than): DCNL 'Removes any incomplete cache entries older than a DCNL supplied modified time. DCNL :param older_than: Files written to on or before this timestemp DCNL will be deleted.'
def get_queued_images(self): DCNL 'Returns a list of image IDs that are in the queue. The DCNL list should be sorted by the time the image ID was inserted DCNL into the queue.'
def get_cache_files(self, basepath): DCNL 'Returns cache files in the supplied directory DCNL :param basepath: Directory to look in for cache files'
def configure(self): DCNL 'Configure the driver to use the stored configuration options DCNL Any store that needs special configuration should implement DCNL this method. If the store was not able to successfully configure DCNL itself, it should raise `exception.BadDriverConfiguration`'
def set_paths(self): DCNL 'Creates all necessary directories under the base cache directory'
def get_cache_size(self): DCNL 'Returns the total size in bytes of the image cache.'
def get_cached_images(self): DCNL 'Returns a list of records about cached images. DCNL The list of records shall be ordered by image ID and shall look like:: DCNL \'image_id\': <IMAGE_ID>, DCNL \'hits\': INTEGER, DCNL \'last_modified\': ISO_TIMESTAMP, DCNL \'last_accessed\': ISO_TIMESTAMP, DCNL \'size\': INTEGER'
def is_cached(self, image_id): DCNL 'Returns True if the image with the supplied ID has its image DCNL file cached. DCNL :param image_id: Image ID'
def is_cacheable(self, image_id): DCNL 'Returns True if the image with the supplied ID can have its DCNL image file cached, False otherwise. DCNL :param image_id: Image ID'
def is_queued(self, image_id): DCNL 'Returns True if the image identifier is in our cache queue. DCNL :param image_id: Image ID'
def delete_all_cached_images(self): DCNL 'Removes all cached image files and any attributes about the images DCNL and returns the number of cached image files that were deleted.'
def delete_cached_image(self, image_id): DCNL 'Removes a specific cached image file and any attributes about the image DCNL :param image_id: Image ID'
def delete_all_queued_images(self): DCNL 'Removes all queued image files and any attributes about the images DCNL and returns the number of queued image files that were deleted.'
def delete_queued_image(self, image_id): DCNL 'Removes a specific queued image file and any attributes about the image DCNL :param image_id: Image ID'
def clean(self, stall_time=None): DCNL 'Dependent on the driver, clean up and destroy any invalid or incomplete DCNL cached images'
def get_least_recently_accessed(self): DCNL 'Return a tuple containing the image_id and size of the least recently DCNL accessed cached file, or None if no cached files.'
def open_for_write(self, image_id): DCNL 'Open a file for writing the image file for an image DCNL with supplied identifier. DCNL :param image_id: Image ID'
def open_for_read(self, image_id): DCNL 'Open and yield file for reading the image file for an image DCNL with supplied identifier. DCNL :param image_id: Image ID'
def get_image_filepath(self, image_id, cache_status='active'): DCNL 'This crafts an absolute path to a specific entry DCNL :param image_id: Image ID DCNL :param cache_status: Status of the image in the cache'
def get_image_size(self, image_id): DCNL 'Return the size of the image file for an image with supplied DCNL identifier. DCNL :param image_id: Image ID'
def get_queued_images(self): DCNL 'Returns a list of image IDs that are in the queue. The DCNL list should be sorted by the time the image ID was inserted DCNL into the queue.'
def configure(self): DCNL 'Configure the driver to use the stored configuration options DCNL Any store that needs special configuration should implement DCNL this method. If the store was not able to successfully configure DCNL itself, it should raise `exception.BadDriverConfiguration`'
def get_cache_size(self): DCNL 'Returns the total size in bytes of the image cache.'
def get_hit_count(self, image_id): DCNL 'Return the number of hits that an image has. DCNL :param image_id: Opaque image identifier'
def get_cached_images(self): DCNL 'Returns a list of records about cached images.'
def is_cached(self, image_id): DCNL 'Returns True if the image with the supplied ID has its image DCNL file cached. DCNL :param image_id: Image ID'
def is_cacheable(self, image_id): DCNL 'Returns True if the image with the supplied ID can have its DCNL image file cached, False otherwise. DCNL :param image_id: Image ID'
def is_being_cached(self, image_id): DCNL 'Returns True if the image with supplied id is currently DCNL in the process of having its image file cached. DCNL :param image_id: Image ID'
def is_queued(self, image_id): DCNL 'Returns True if the image identifier is in our cache queue.'
def delete_all_cached_images(self): DCNL 'Removes all cached image files and any attributes about the images'
def delete_cached_image(self, image_id): DCNL 'Removes a specific cached image file and any attributes about the image DCNL :param image_id: Image ID'
def delete_all_queued_images(self): DCNL 'Removes all queued image files and any attributes about the images'
def delete_queued_image(self, image_id): DCNL 'Removes a specific queued image file and any attributes about the image DCNL :param image_id: Image ID'
def get_least_recently_accessed(self): DCNL 'Return a tuple containing the image_id and size of the least recently DCNL accessed cached file, or None if no cached files.'
@contextmanager DCNL def open_for_write(self, image_id): DCNL 'Open a file for writing the image file for an image DCNL with supplied identifier. DCNL :param image_id: Image ID'
@contextmanager DCNL def open_for_read(self, image_id): DCNL 'Open and yield file for reading the image file for an image DCNL with supplied identifier. DCNL :param image_id: Image ID'
def queue_image(self, image_id): DCNL 'This adds a image to be cache to the queue. DCNL If the image already exists in the queue or has already been DCNL cached, we return False, True otherwise DCNL :param image_id: Image ID'
def get_queued_images(self): DCNL 'Returns a list of image IDs that are in the queue. The DCNL list should be sorted by the time the image ID was inserted DCNL into the queue.'
def reap_invalid(self, grace=None): DCNL 'Remove any invalid cache entries DCNL :param grace: Number of seconds to keep an invalid entry around for DCNL debugging purposes. If None, then delete immediately.'
def reap_stalled(self, grace=None): DCNL 'Remove any stalled cache entries DCNL :param grace: Number of seconds to keep an invalid entry around for DCNL debugging purposes. If None, then delete immediately.'
def clean(self, stall_time=None): DCNL 'Delete any image files in the invalid directory and any DCNL files in the incomplete directory that are older than a DCNL configurable amount of time.'
def delete_cached_image(self, image_id): DCNL 'Delete a specified image from the cache'
def get_cached_images(self, **kwargs): DCNL 'Returns a list of images stored in the image cache.'
def get_queued_images(self, **kwargs): DCNL 'Returns a list of images queued for caching'
def delete_all_cached_images(self): DCNL 'Delete all cached images'
def queue_image_for_caching(self, image_id): DCNL 'Queue an image for prefetching into cache'
def delete_queued_image(self, image_id): DCNL 'Delete a specified image from the cache queue'
def delete_all_queued_images(self): DCNL 'Delete all queued images'
def format(self, record): DCNL 'Uses contextstring if request_id is set, otherwise default.'
def formatException(self, exc_info, record=None): DCNL 'Format exception output with CONF.logging_exception_prefix.'
@classmethod DCNL def load_json(cls, data, default_rule=None): DCNL 'Allow loading of JSON rule data.'
def __init__(self, rules=None, default_rule=None): DCNL 'Initialize the Rules store.'
def __missing__(self, key): DCNL 'Implements the default rule handling.'
def __str__(self): DCNL 'Dumps a string representation of the rules.'
@abc.abstractmethod DCNL def __str__(self): DCNL 'Retrieve a string representation of the Check tree rooted at DCNL this node.'
@abc.abstractmethod DCNL def __call__(self, target, cred): DCNL 'Perform the check.  Returns False to reject the access or a DCNL true value (not necessary True) to accept the access.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __init__(self, kind, match): DCNL ':param kind: The kind of the check, i.e., the field before the DCNL :param match: The match of the check, i.e., the field after DCNL the \':\'.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __init__(self, rule): DCNL 'Initialize the \'not\' check. DCNL :param rule: The rule to negate.  Must be a Check.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Returns the logical inverse of the wrapped DCNL check.'
def __init__(self, rules): DCNL 'Initialize the \'and\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Requires that all rules accept in order to DCNL return True.'
def add_check(self, rule): DCNL 'Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the AndCheck object for convenience.'
def __init__(self, rules): DCNL 'Initialize the \'or\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Requires that at least one rule accept in DCNL order to return True.'
def add_check(self, rule): DCNL 'Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the OrCheck object for convenience.'
def __new__(mcs, name, bases, cls_dict): DCNL 'Create the class.  Injects the \'reducers\' list, a list of DCNL tuples matching token sequences to the names of the DCNL corresponding reduction methods.'
def __init__(self): DCNL 'Initialize the ParseState.'
def reduce(self): DCNL 'Perform a greedy reduction of the token stream.  If a reducer DCNL method matches, it will be executed, then the reduce() method DCNL will be called recursively to search for any more possible DCNL reductions.'
def shift(self, tok, value): DCNL 'Adds one more token to the state.  Calls reduce().'
@property DCNL def result(self): DCNL 'Obtain the final result of the parse.  Raises ValueError if DCNL the parse failed to reduce to a single result.'
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2): DCNL 'Turn parenthesized expressions into a \'check\' token.'
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2): DCNL 'Create an \'and_expr\' from two checks joined by the \'and\' DCNL operator.'
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check): DCNL 'Extend an \'and_expr\' by adding one more check.'
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2): DCNL 'Create an \'or_expr\' from two checks joined by the \'or\' DCNL operator.'
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check): DCNL 'Extend an \'or_expr\' by adding one more check.'
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check): DCNL 'Invert the result of another check.'
def __call__(self, target, creds): DCNL 'Recursively checks credentials based on the defined rules.'
def __call__(self, target, creds): DCNL 'Check that there is a matching role in the cred dict.'
def __call__(self, target, creds): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response DCNL is exactly \'True\'.'
def __call__(self, target, creds): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def __str__(self): DCNL 'Make the VersionInfo object behave like a string.'
def __repr__(self): DCNL 'Include the name.'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def __init__(self): DCNL 'Initialize the rabbit notification strategy.'
def _close(self): DCNL 'Close connection to rabbit.'
def _connect(self): DCNL 'Connect to rabbit.  Exceptions should be handled by the DCNL caller.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing queues.'
def log_failure(self, msg, priority): DCNL 'Fallback to logging when we can\'t send to rabbit.'
def _send_message(self, msg, routing_key): DCNL 'Send a message.  Caller needs to catch exceptions for retry.'
def _notify(self, msg, priority): DCNL 'Send a notification and retry if needed.'
def _get_session(self): DCNL 'Initialize the Qpid notification strategy.'
def index(self, req, image_id): DCNL 'Get the members of an image.'
@utils.mutating DCNL def update_all(self, req, image_id, body): DCNL 'Replaces the members of the image with those specified in the DCNL body.  The body is a dict with the following format:: DCNL {"memberships": [ DCNL {"member_id": <MEMBER_ID>, DCNL ["can_share": [True|False]]}, ...'
@utils.mutating DCNL def update(self, req, image_id, id, body=None): DCNL 'Adds a membership to the image, or updates an existing one. DCNL If a body is present, it is a dict with the following format:: DCNL {"member": { DCNL "can_share": [True|False] DCNL If "can_share" is provided, the member\'s ability to share is DCNL set accordingly.  If it is not provided, existing memberships DCNL remain unchanged and new memberships default to False.'
@utils.mutating DCNL def delete(self, req, image_id, id): DCNL 'Removes a membership from the image.'
def index_shared_images(self, req, id): DCNL 'Retrieves images shared with the given member.'
def _get_images(self, context, filters, **params): DCNL 'Get images, wrapping in exception if necessary.'
def index(self, req): DCNL 'Return a basic filtered list of public, non-deleted images DCNL :param req: the Request object coming from the wsgi layer DCNL :retval a mapping of the following form:: DCNL dict(images=[image_list]) DCNL Where image_list is a sequence of mappings:: DCNL \'id\': <ID>, DCNL \'name\': <NAME>, DCNL \'size\': <SIZE>, DCNL \'disk_format\': <DISK_FORMAT>, DCNL \'container_format\': <CONTAINER_FORMAT>, DCNL \'checksum\': <CHECKSUM>'
def detail(self, req): DCNL 'Return a filtered list of public, non-deleted images in detail DCNL :param req: the Request object coming from the wsgi layer DCNL :retval a mapping of the following form:: DCNL dict(images=[image_list]) DCNL Where image_list is a sequence of mappings containing DCNL all image model fields.'
def _get_query_params(self, req): DCNL 'Extract necessary query parameters from http request. DCNL :param req: the Request object coming from the wsgi layer DCNL :retval dictionary of filters to apply to list of images'
def _get_filters(self, req): DCNL 'Return a dictionary of query param filters from the request DCNL :param req: the Request object coming from the wsgi layer DCNL :retval a dict of key/value filters'
def _get_limit(self, req): DCNL 'Parse a limit query param into something usable.'
def _get_marker(self, req): DCNL 'Parse a marker query param into something usable.'
def _get_sort_key(self, req): DCNL 'Parse a sort key query param from the request object.'
def _get_sort_dir(self, req): DCNL 'Parse a sort direction query param from the request object.'
def _get_is_public(self, req): DCNL 'Parse is_public into something usable.'
def _parse_deleted_filter(self, req): DCNL 'Parse deleted into something usable.'
def show(self, req, id): DCNL 'Return data about the given image id.'
@utils.mutating DCNL def delete(self, req, id): DCNL 'Deletes an existing image with the registry. DCNL :param req: wsgi Request object DCNL :param id:  The opaque internal identifier for the image DCNL :retval Returns 200 if delete was successful, a fault if not. On DCNL success, the body contains the deleted image information as a mapping.'
@utils.mutating DCNL def create(self, req, body): DCNL 'Registers a new image with the registry. DCNL :param req: wsgi Request object DCNL :param body: Dictionary of information about the image DCNL :retval Returns the newly-created image information as a mapping, DCNL which will include the newly-created image\'s internal id DCNL in the \'id\' field'
@utils.mutating DCNL def update(self, req, id, body): DCNL 'Updates an existing image with the registry. DCNL :param req: wsgi Request object DCNL :param body: Dictionary of information about the image DCNL :param id:  The opaque internal identifier for the image DCNL :retval Returns the updated image information as a mapping,'
def __init__(self, host=None, port=None, metadata_encryption_key=None, **kwargs): DCNL ':param metadata_encryption_key: Key used to encrypt \'location\' metadata'
def get_images(self, **kwargs): DCNL 'Returns a list of image id/name mappings from Registry DCNL :param filters: dict of keys & expected values to filter results DCNL :param marker: image id after which to start page DCNL :param limit: max number of images to return DCNL :param sort_key: results will be ordered by this image attribute DCNL :param sort_dir: direction in which to to order results (asc, desc)'
def get_images_detailed(self, **kwargs): DCNL 'Returns a list of detailed image data mappings from Registry DCNL :param filters: dict of keys & expected values to filter results DCNL :param marker: image id after which to start page DCNL :param limit: max number of images to return DCNL :param sort_key: results will be ordered by this image attribute DCNL :param sort_dir: direction in which to to order results (asc, desc)'
def get_image(self, image_id): DCNL 'Returns a mapping of image metadata from Registry'
def add_image(self, image_metadata): DCNL 'Tells registry about an image\'s metadata'
def update_image(self, image_id, image_metadata, purge_props=False): DCNL 'Updates Registry\'s information about an image'
def delete_image(self, image_id): DCNL 'Deletes Registry\'s information about an image'
def get_image_members(self, image_id): DCNL 'Returns a list of membership associations from Registry'
def get_member_images(self, member_id): DCNL 'Returns a list of membership associations from Registry'
def replace_members(self, image_id, member_data): DCNL 'Replaces Registry\'s information about image membership'
def add_member(self, image_id, member_id, can_share=None): DCNL 'Adds to Registry\'s information about image membership'
def delete_member(self, image_id, member_id): DCNL 'Deletes Registry\'s information about image membership'
@property DCNL def owner(self): DCNL 'Return the owner to correlate with an image.'
@property DCNL def show_deleted(self): DCNL 'Admins can see deleted by default'
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True): DCNL 'Runs a command in an out-of-process shell. DCNL Returns the output of that command. Working directory is self.root.'
def create_virtualenv(self, no_site_packages=True): DCNL 'Creates the virtual environment and installs PIP. DCNL Creates the virtual environment and installs PIP only into the DCNL virtual environment.'
def parse_args(self, argv): DCNL 'Parses command-line arguments.'
def post_process(self): DCNL 'Any distribution-specific post-processing gets done here. DCNL In particular, this is useful for applying patches to code inside DCNL the venv.'
def post_process(self): DCNL 'Workaround for a bug in eventlet. DCNL This currently affects RHEL6.1, but the fix can safely be DCNL applied to all RHEL and Fedora distributions. DCNL This can be removed when the fix is applied upstream. DCNL Nova: https://bugs.launchpad.net/nova/+bug/884915 DCNL Upstream: https://bitbucket.org/which_linden/eventlet/issue/89'
def setUp(self): DCNL 'Run before each test method to initialize test environment.'
def tearDown(self): DCNL 'Runs after each test method to tear down test environment.'
def flags(self, **kw): DCNL 'Override flag variables for a test.'
def assertDictMatch(self, d1, d2, approx_equal=False, tolerance=0.001): DCNL 'Assert two dicts are equivalent. DCNL This is a \'deep\' match in the sense that it handles nested DCNL dictionaries appropriately. DCNL NOTE: DCNL If you don\'t care (or don\'t know) a given value, you can specify DCNL the string DONTCARE as the value. This will cause that dict-item DCNL to be skipped.'
def assertDictListMatch(self, L1, L2, approx_equal=False, tolerance=0.001): DCNL 'Assert a list of dicts are equivalent.'
def assertSubDictMatch(self, sub_dict, super_dict): DCNL 'Assert a sub_dict is subset of super_dict.'
def assertIn(self, a, b, *args, **kwargs): DCNL 'Python < v2.7 compatibility.  Assert \'a\' in \'b\''
def assertNotIn(self, a, b, *args, **kwargs): DCNL 'Python < v2.7 compatibility.  Assert \'a\' NOT in \'b\''
def __init__(self, data, limit): DCNL ':param data: Underlying data object DCNL :param limit: maximum number of bytes the reader should allow'
def __init__(self, ext_mgr): DCNL 'Register extension with the extension manager.'
def get_resources(self): DCNL 'List of extensions.ResourceExtension extension objects. DCNL Resources define new nouns, and are accessible through URLs.'
def get_controller_extensions(self): DCNL 'List of extensions.ControllerExtension extension objects. DCNL Controller extensions are used to extend existing controllers.'
@classmethod DCNL def nsmap(cls): DCNL 'Synthesize a namespace map from extension.'
@classmethod DCNL def xmlname(cls, name): DCNL 'Synthesize element and attribute names.'
def get_resources(self): DCNL 'Returns a list of ResourceExtension objects.'
def get_controller_extensions(self): DCNL 'Returns a list of ControllerExtension objects.'
def _check_extension(self, extension): DCNL 'Checks for required methods in extension objects.'
def load_extension(self, ext_factory): DCNL 'Execute an extension factory. DCNL Loads an extension.  The \'ext_factory\' is the name of a DCNL callable that will be imported and called with one DCNL argument--the extension manager.  The factory callable is DCNL expected to call the register() method at least once.'
def _load_extensions(self): DCNL 'Load extensions specified on the command line.'
def _extract_volume(self, node): DCNL 'Marshal the volume attribute of a parsed request.'
def default(self, string): DCNL 'Deserialize an xml-formatted volume create request.'
@wsgi.serializers(xml=VolumeTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given volume.'
def delete(self, req, id): DCNL 'Delete a volume.'
@wsgi.serializers(xml=VolumesTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of volumes.'
@wsgi.serializers(xml=VolumesTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of volumes.'
def _get_volumes(self, req, is_detail): DCNL 'Returns a list of volumes, transformed through view builder.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=VolumeTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body): DCNL 'Creates a new volume.'
def _get_volume_filter_options(self): DCNL 'Return volume search options allowed by non-admin.'
@wsgi.serializers(xml=VolumeTemplate) DCNL def update(self, req, id, body): DCNL 'Update a volume.'
def __init__(self): DCNL 'Initialize view builder.'
def summary_list(self, request, volumes): DCNL 'Show a list of volumes without many details.'
def detail_list(self, request, volumes): DCNL 'Detailed view of a list of volumes.'
def summary(self, request, volume): DCNL 'Generic, non-detailed view of an volume.'
def detail(self, request, volume): DCNL 'Detailed view of a single volume.'
def _get_attachments(self, volume): DCNL 'Retrieves the attachments of the volume object'
def _get_volume_metadata(self, volume): DCNL 'Retrieves the metadata of the volume object'
def _get_volume_type(self, volume): DCNL 'Retrieves the type the volume object is'
def _list_view(self, func, request, volumes): DCNL 'Provide a view for a list of volumes.'
@wsgi.serializers(xml=SnapshotTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given snapshot.'
def delete(self, req, id): DCNL 'Delete a snapshot.'
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of snapshots.'
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of snapshots.'
def _items(self, req, entity_maker): DCNL 'Returns a list of snapshots, transformed through entity_maker.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=SnapshotTemplate) DCNL def create(self, req, body): DCNL 'Creates a new snapshot.'
@wsgi.serializers(xml=SnapshotTemplate) DCNL def update(self, req, id, body): DCNL 'Update a snapshot.'
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, snapshot_id): DCNL 'Returns the list of metadata for a given snapshot'
@wsgi.serializers(xml=common.MetaItemTemplate) DCNL def show(self, req, snapshot_id, id): DCNL 'Return a single metadata item'
def delete(self, req, snapshot_id, id): DCNL 'Deletes an existing metadata'
@wsgi.serializers(xml=VolumeTypesTemplate) DCNL def index(self, req): DCNL 'Returns the list of volume types.'
@wsgi.serializers(xml=VolumeTypeTemplate) DCNL def show(self, req, id): DCNL 'Return a single volume type item.'
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req): DCNL 'Return all global and rate limit information.'
def __init__(self, verb, uri, regex, value, unit): DCNL 'Initialize a new `Limit`. DCNL @param verb: HTTP verb (POST, PUT, etc.) DCNL @param uri: Human-readable URI DCNL @param regex: Regular expression format for this limit DCNL @param value: Integer number of requests which can be made DCNL @param unit: Unit of measure for the value parameter'
def __call__(self, verb, url): DCNL 'Represents a call to this limit from a relevant request. DCNL @param verb: string http verb (POST, GET, etc.) DCNL @param url: string URL'
def _get_time(self): DCNL 'Retrieve the current time. Broken out for testability.'
def display_unit(self): DCNL 'Display the string name of the unit.'
def display(self): DCNL 'Return a useful representation of this class.'
def __init__(self, application, limits=None, limiter=None, **kwargs): DCNL 'Initialize new `RateLimitingMiddleware`, which wraps the given WSGI DCNL application and sets up the given limits. DCNL @param application: WSGI application to wrap DCNL @param limits: String describing limits DCNL @param limiter: String identifying class for representing limits DCNL Other parameters are passed to the constructor for the limiter.'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req): DCNL 'Represents a single call through this middleware. We should record the DCNL request if we have a limit relevant to it. If no limit is relevant to DCNL the request, ignore it. DCNL If the request should be rate limited, return a fault telling the user DCNL they are over the limit and need to retry later.'
def __init__(self, limits, **kwargs): DCNL 'Initialize the new `Limiter`. DCNL @param limits: List of `Limit` objects'
def get_limits(self, username=None): DCNL 'Return the limits for a given user.'
def check_for_delay(self, verb, url, username=None): DCNL 'Check the given verb/user/user triplet for limit. DCNL @return: Tuple of delay (in seconds) and error message (or None, None)'
@staticmethod DCNL def parse_limits(limits): DCNL 'Convert a string into a list of Limit instances.  This DCNL implementation expects a semicolon-separated sequence of DCNL parenthesized groups, where each group contains a DCNL comma-separated sequence consisting of HTTP method, DCNL user-readable URI, a URI reg-exp, an integer number of DCNL requests which can be made, and a unit of measure.  Valid DCNL values for the latter are "SECOND", "MINUTE", "HOUR", and DCNL "DAY". DCNL @return: List of Limit instances.'
def __init__(self, limits=None): DCNL 'Initialize the new `WsgiLimiter`. DCNL @param limits: List of `Limit` objects'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request): DCNL 'Handles a call to this application. Returns 204 if the request is DCNL acceptable to the limiter, else a 403 is returned with a relevant DCNL header indicating when the request *will* succeed.'
def __init__(self, limiter_address): DCNL 'Initialize the new `WsgiLimiterProxy`. DCNL @param limiter_address: IP/port combination of where to request limit'
@staticmethod DCNL def parse_limits(limits): DCNL 'Ignore a limits string--simply doesn\'t apply for the limit DCNL proxy. DCNL @return: Empty list.'
def _get_next_link(self, request, identifier): DCNL 'Return href string with proper limit and marker params.'
def _get_href_link(self, request, identifier): DCNL 'Return an href string pointing to this object.'
def _get_bookmark_link(self, request, identifier): DCNL 'Create a URL that refers to a specific resource.'
def _get_collection_links(self, request, items, id_key='uuid'): DCNL 'Retrieve \'next\' link, if applicable.'
def extract_metadata(self, metadata_node): DCNL 'Marshal the metadata attribute of a parsed request'
def __init__(self): DCNL 'Initialize view builder.'
def summary_list(self, request, backups): DCNL 'Show a list of backups without many details.'
def detail_list(self, request, backups): DCNL 'Detailed view of a list of backups .'
def summary(self, request, backup): DCNL 'Generic, non-detailed view of a backup.'
def restore_summary(self, request, restore): DCNL 'Generic, non-detailed view of a restore.'
def detail(self, request, backup): DCNL 'Detailed view of a single backup.'
def _list_view(self, func, request, backups): DCNL 'Provide a view for a list of backups.'
def show(self, request, volume_type, brief=False): DCNL 'Trim away extraneous volume type attributes.'
def index(self, request, volume_types): DCNL 'Index over trimmed volume types'
def _build_absolute_limits(self, absolute_limits): DCNL 'Builder for absolute limits DCNL absolute_limits should be given as a dict of limits. DCNL For example: {"ram": 512, "gigabytes": 1024}.'
def __init__(self, base_url): DCNL ':param base_url: url of the root wsgi application'
def _build_links(self, version_data): DCNL 'Generate a container of links that refer to the provided version.'
def generate_href(self, path=None): DCNL 'Create an url that refers to a specific version_number.'
def __init__(self, *chain): DCNL 'Initialize the selector. DCNL Each argument is a subsequent index into the object.'
def __repr__(self): DCNL 'Return a representation of the selector.'
def __call__(self, obj, do_raise=False): DCNL 'Select a datum to operate on. DCNL Selects the relevant datum within the object. DCNL :param obj: The object from which to select the object. DCNL :param do_raise: If False (the default), return None if the DCNL indexed datum does not exist.  Otherwise, DCNL raise a KeyError.'
def __call__(self, obj, do_raise=False): DCNL 'Returns empty string if the selected value does not exist.'
def __init__(self, value): DCNL 'Initialize the selector. DCNL :param value: The value to return.'
def __repr__(self): DCNL 'Return a representation of the selector.'
def __call__(self, _obj, _do_raise=False): DCNL 'Select a datum to operate on. DCNL Returns a constant value.  Compatible with DCNL Selector.__call__().'
def __init__(self, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Initialize an element. DCNL Initializes an element in the template.  Keyword arguments DCNL specify attributes to be set on the element; values must be DCNL callables.  See TemplateElement.set() for more information. DCNL :param tag: The name of the tag to create. DCNL :param attrib: An optional dictionary of element attributes. DCNL :param selector: An optional callable taking an object and DCNL optional boolean do_raise indicator and DCNL returning the object bound to the element. DCNL :param subselector: An optional callable taking an object and DCNL optional boolean do_raise indicator and DCNL returning the object bound to the element. DCNL This is used to further refine the datum DCNL object returned by selector in the event DCNL that it is a list of objects.'
def __repr__(self): DCNL 'Return a representation of the template element.'
def __len__(self): DCNL 'Return the number of child elements.'
def __contains__(self, key): DCNL 'Determine whether a child node named by key exists.'
def __getitem__(self, idx): DCNL 'Retrieve a child node by index or name.'
def append(self, elem): DCNL 'Append a child to the element.'
def extend(self, elems): DCNL 'Append children to the element.'
def insert(self, idx, elem): DCNL 'Insert a child element at the given index.'
def remove(self, elem): DCNL 'Remove a child element.'
def get(self, key): DCNL 'Get an attribute. DCNL Returns a callable which performs datum selection. DCNL :param key: The name of the attribute to get.'
def set(self, key, value=None): DCNL 'Set an attribute. DCNL :param key: The name of the attribute to set. DCNL :param value: A callable taking an object and optional boolean DCNL do_raise indicator and returning the datum bound DCNL to the attribute.  If None, a Selector() will be DCNL constructed from the key.  If a string, a DCNL Selector() will be constructed from the string.'
def keys(self): DCNL 'Return the attribute names.'
def items(self): DCNL 'Return the attribute names and values.'
def unwrap(self): DCNL 'Unwraps a template to return a template element.'
def wrap(self): DCNL 'Wraps a template element to return a template.'
def apply(self, elem, obj): DCNL 'Apply text and attributes to an etree.Element. DCNL Applies the text and attribute instructions in the template DCNL element to an etree.Element instance. DCNL :param elem: An etree.Element instance. DCNL :param obj: The base object associated with this template DCNL element.'
def _render(self, parent, datum, patches, nsmap): DCNL 'Internal rendering. DCNL Renders the template node into an etree.Element object. DCNL Returns the etree.Element object. DCNL :param parent: The parent etree.Element instance. DCNL :param datum: The datum associated with this template element. DCNL :param patches: A list of other template elements that must DCNL also be applied. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the etree.Element instance.'
def render(self, parent, obj, patches=[], nsmap=None): DCNL 'Render an object. DCNL Renders an object against this template node.  Returns a list DCNL of two-item tuples, where the first item is an etree.Element DCNL instance and the second item is the datum associated with that DCNL instance. DCNL :param parent: The parent for the etree.Element instances. DCNL :param obj: The object to render this template element DCNL against. DCNL :param patches: A list of other template elements to apply DCNL when rendering this template element. DCNL :param nsmap: An optional namespace dictionary to attach to DCNL the etree.Element instances.'
def will_render(self, datum): DCNL 'Hook method. DCNL An overridable hook method to determine whether this template DCNL element will be rendered at all.  By default, returns False DCNL (inhibiting rendering) if the datum is None. DCNL :param datum: The datum associated with this template element.'
def _text_get(self): DCNL 'Template element text. DCNL Either None or a callable taking an object and optional DCNL boolean do_raise indicator and returning the datum bound to DCNL the text of the template element.'
def tree(self): DCNL 'Return string representation of the template tree. DCNL Returns a representation of the template rooted at this DCNL element as a string, suitable for inclusion in debug logs.'
def __init__(self, root, nsmap=None): DCNL 'Initialize a template. DCNL :param root: The root element of the template. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def _serialize(self, parent, obj, siblings, nsmap=None): DCNL 'Internal serialization. DCNL Recursive routine to build a tree of etree.Element instances DCNL from an object based on the template.  Returns the first DCNL etree.Element instance rendered, or None. DCNL :param parent: The parent etree.Element instance.  Can be DCNL None. DCNL :param obj: The object to render. DCNL :param siblings: The TemplateElement instances against which DCNL to render the object. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the etree.Element instance DCNL rendered.'
def serialize(self, obj, *args, **kwargs): DCNL 'Serialize an object. DCNL Serializes an object against the template.  Returns a string DCNL with the serialized XML.  Positional and keyword arguments are DCNL passed to etree.tostring(). DCNL :param obj: The object to serialize.'
def make_tree(self, obj): DCNL 'Create a tree. DCNL Serializes an object against the template.  Returns an Element DCNL node with appropriate children. DCNL :param obj: The object to serialize.'
def _siblings(self): DCNL 'Hook method for computing root siblings. DCNL An overridable hook method to return the siblings of the root DCNL element.  By default, this is the root element itself.'
def _nsmap(self): DCNL 'Hook method for computing the namespace dictionary. DCNL An overridable hook method to return the namespace dictionary.'
def unwrap(self): DCNL 'Unwraps a template to return a template element.'
def wrap(self): DCNL 'Wraps a template element to return a template.'
def apply(self, master): DCNL 'Hook method for determining slave applicability. DCNL An overridable hook method used to determine if this template DCNL is applicable as a slave to a given master template. DCNL :param master: The master template to test.'
def tree(self): DCNL 'Return string representation of the template tree. DCNL Returns a representation of the template as a string, suitable DCNL for inclusion in debug logs.'
def __init__(self, root, version, nsmap=None): DCNL 'Initialize a master template. DCNL :param root: The root element of the template. DCNL :param version: The version number of the template. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def __repr__(self): DCNL 'Return string representation of the template.'
def _siblings(self): DCNL 'Hook method for computing root siblings. DCNL An overridable hook method to return the siblings of the root DCNL element.  This is the root element plus the root elements of DCNL all the slave templates.'
def _nsmap(self): DCNL 'Hook method for computing the namespace dictionary. DCNL An overridable hook method to return the namespace dictionary. DCNL The namespace dictionary is computed by taking the master DCNL template\'s namespace dictionary and updating it from all the DCNL slave templates.'
def attach(self, *slaves): DCNL 'Attach one or more slave templates. DCNL Attaches one or more slave templates to the master template. DCNL Slave templates must have a root element with the same tag as DCNL the master template.  The slave template\'s apply() method will DCNL be called to determine if the slave should be applied to this DCNL master; if it returns False, that slave will be skipped. DCNL (This allows filtering of slaves based on the version of the DCNL master template.)'
def copy(self): DCNL 'Return a copy of this master template.'
def __init__(self, root, min_vers, max_vers=None, nsmap=None): DCNL 'Initialize a slave template. DCNL :param root: The root element of the template. DCNL :param min_vers: The minimum permissible version of the master DCNL template for this slave template to apply. DCNL :param max_vers: An optional upper bound for the master DCNL template version. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def __repr__(self): DCNL 'Return string representation of the template.'
def apply(self, master): DCNL 'Hook method for determining slave applicability. DCNL An overridable hook method used to determine if this template DCNL is applicable as a slave to a given master template.  This DCNL version requires the master template to have a version number DCNL between min_vers and max_vers. DCNL :param master: The master template to test.'
def __new__(cls, copy=True): DCNL 'Construct and return a template. DCNL :param copy: If True (the default), a copy of the template DCNL will be constructed and returned, if possible.'
def construct(self): DCNL 'Construct a template. DCNL Called to construct a template instance, which it must return. DCNL Only called once.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Simple paste factory, :class:`cinder.wsgi.Router` doesn\'t have'
def best_match_content_type(self): DCNL 'Determine the requested response content-type.'
def get_content_type(self): DCNL 'Determine content type of the request body. DCNL Does not do any body introspection, only checks header'
def dispatch(self, *args, **kwargs): DCNL 'Find and call local method.'
def __init__(self, metadata=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary.'
def _from_xml_node(self, node, listnames): DCNL 'Convert a minidom node to a simple Python type. DCNL :param listnames: list of XML node names whose subnodes should DCNL be considered list items.'
def find_first_child_named(self, parent, name): DCNL 'Search a nodes children for the first child with a given name'
def find_children_named(self, parent, name): DCNL 'Return all of a nodes children who have the given name'
def extract_text(self, node): DCNL 'Get the text field contained by the given node'
def find_attribute_or_element(self, parent, name): DCNL 'Get an attribute value; fallback to an element if not found'
def extract_metadata(self, metadata_node): DCNL 'Marshal the metadata attribute of a parsed request'
def __init__(self, metadata=None, xmlns=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary. DCNL :param xmlns: XML namespace to include with serialized xml'
def _to_xml_node(self, doc, metadata, nodename, data): DCNL 'Recursive method to convert data members to XML nodes.'
def _to_xml(self, root): DCNL 'Convert the xml object to an xml string.'
def __init__(self, obj, code=None, **serializers): DCNL 'Binds serializers with an object. DCNL Takes keyword arguments akin to the @serializer() decorator DCNL for specifying serializers.  Serializers specified will be DCNL given preference over default serializers or method-specific DCNL serializers on return.'
def __getitem__(self, key): DCNL 'Retrieves a header with the given name.'
def __setitem__(self, key, value): DCNL 'Sets a header with the given name to the given value.'
def __delitem__(self, key): DCNL 'Deletes the header with the given name.'
def _bind_method_serializers(self, meth_serializers): DCNL 'Binds method serializers with the response object. DCNL Binds the method serializers with the response object. DCNL Serializers specified to the constructor will take precedence DCNL over serializers specified to this method. DCNL :param meth_serializers: A dictionary with keys mapping to DCNL response types and values containing DCNL serializer objects.'
def get_serializer(self, content_type, default_serializers=None): DCNL 'Returns the serializer for the wrapped object. DCNL Returns the serializer for the wrapped object subject to the DCNL indicated content type.  If no serializer matching the content DCNL type is attached, an appropriate serializer drawn from the DCNL default serializers will be used.  If no appropriate DCNL serializer is available, raises InvalidContentType.'
def preserialize(self, content_type, default_serializers=None): DCNL 'Prepares the serializer that will be used to serialize. DCNL Determines the serializer that will be used and prepares an DCNL instance of it for later call.  This allows the serializer to DCNL be accessed by extensions for, e.g., template extension.'
def attach(self, **kwargs): DCNL 'Attach slave templates to serializers.'
def serialize(self, request, content_type, default_serializers=None): DCNL 'Serializes the wrapped object. DCNL Utility method for serializing the wrapped object.  Returns a DCNL webob.Response object.'
@property DCNL def code(self): DCNL 'Retrieve the response status.'
@property DCNL def headers(self): DCNL 'Retrieve the headers.'
def __init__(self, controller, action_peek=None, **deserializers): DCNL ':param controller: object that implement methods created by routes lib DCNL :param action_peek: dictionary of routines for peeking into an action DCNL request body to determine the desired action'
def register_actions(self, controller): DCNL 'Registers controller actions with this resource.'
def register_extensions(self, controller): DCNL 'Registers controller extensions with this resource.'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'WSGI method that controls (de)serialization and method dispatch.'
def _process_stack(self, request, action, action_args, content_type, body, accept): DCNL 'Implement the processing stack.'
def get_method(self, request, action, content_type, body): DCNL 'Look up the action-specific method and its extensions.'
def dispatch(self, method, request, action_args): DCNL 'Dispatch a call to the action-specific method.'
def __new__(mcs, name, bases, cls_dict): DCNL 'Adds the wsgi_actions dictionary to the class.'
def __init__(self, view_builder=None): DCNL 'Initialize controller with a view builder instance.'
def __init__(self, exception): DCNL 'Create a Fault for the given webob.exc.exception.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Generate a WSGI response based on the exception passed to ctor.'
def __init__(self, message, details, retry_time): DCNL 'Initialize new `OverLimitFault` with relevant information.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'Return the wrapped exception with a serialized body conforming to our DCNL error format.'
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, volume_id): DCNL 'Returns the list of metadata for a given volume'
@wsgi.serializers(xml=common.MetaItemTemplate) DCNL def show(self, req, volume_id, id): DCNL 'Return a single metadata item'
def delete(self, req, volume_id, id): DCNL 'Deletes an existing metadata'
def _extract_volume(self, node): DCNL 'Marshal the volume attribute of a parsed request.'
def default(self, string): DCNL 'Deserialize an xml-formatted volume create request.'
@wsgi.serializers(xml=VolumeTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given volume.'
def delete(self, req, id): DCNL 'Delete a volume.'
@wsgi.serializers(xml=VolumesTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of volumes.'
@wsgi.serializers(xml=VolumesTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of volumes.'
def _items(self, req, entity_maker): DCNL 'Returns a list of volumes, transformed through entity_maker.'
@wsgi.serializers(xml=VolumeTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body): DCNL 'Creates a new volume.'
def _get_volume_search_options(self): DCNL 'Return volume search options allowed by non-admin.'
@wsgi.serializers(xml=VolumeTemplate) DCNL def update(self, req, id, body): DCNL 'Update a volume.'
@wsgi.serializers(xml=SnapshotTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given snapshot.'
def delete(self, req, id): DCNL 'Delete a snapshot.'
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of snapshots.'
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of snapshots.'
def _items(self, req, entity_maker): DCNL 'Returns a list of snapshots, transformed through entity_maker.'
@wsgi.serializers(xml=SnapshotTemplate) DCNL def create(self, req, body): DCNL 'Creates a new snapshot.'
@wsgi.serializers(xml=SnapshotTemplate) DCNL def update(self, req, id, body): DCNL 'Update a snapshot.'
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, snapshot_id): DCNL 'Returns the list of metadata for a given snapshot'
@wsgi.serializers(xml=common.MetaItemTemplate) DCNL def show(self, req, snapshot_id, id): DCNL 'Return a single metadata item'
def delete(self, req, snapshot_id, id): DCNL 'Deletes an existing metadata'
@wsgi.serializers(xml=VolumeTypesTemplate) DCNL def index(self, req): DCNL 'Returns the list of volume types.'
@wsgi.serializers(xml=VolumeTypeTemplate) DCNL def show(self, req, id): DCNL 'Return a single volume type item.'
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req): DCNL 'Return all global and rate limit information.'
def __init__(self, verb, uri, regex, value, unit): DCNL 'Initialize a new `Limit`. DCNL @param verb: HTTP verb (POST, PUT, etc.) DCNL @param uri: Human-readable URI DCNL @param regex: Regular expression format for this limit DCNL @param value: Integer number of requests which can be made DCNL @param unit: Unit of measure for the value parameter'
def __call__(self, verb, url): DCNL 'Represents a call to this limit from a relevant request. DCNL @param verb: string http verb (POST, GET, etc.) DCNL @param url: string URL'
def _get_time(self): DCNL 'Retrieve the current time. Broken out for testability.'
def display_unit(self): DCNL 'Display the string name of the unit.'
def display(self): DCNL 'Return a useful representation of this class.'
def __init__(self, application, limits=None, limiter=None, **kwargs): DCNL 'Initialize new `RateLimitingMiddleware`, which wraps the given WSGI DCNL application and sets up the given limits. DCNL @param application: WSGI application to wrap DCNL @param limits: String describing limits DCNL @param limiter: String identifying class for representing limits DCNL Other parameters are passed to the constructor for the limiter.'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req): DCNL 'Represents a single call through this middleware. We should record the DCNL request if we have a limit relevant to it. If no limit is relevant to DCNL the request, ignore it. DCNL If the request should be rate limited, return a fault telling the user DCNL they are over the limit and need to retry later.'
def __init__(self, limits, **kwargs): DCNL 'Initialize the new `Limiter`. DCNL @param limits: List of `Limit` objects'
def get_limits(self, username=None): DCNL 'Return the limits for a given user.'
def check_for_delay(self, verb, url, username=None): DCNL 'Check the given verb/user/user triplet for limit. DCNL @return: Tuple of delay (in seconds) and error message (or None, None)'
@staticmethod DCNL def parse_limits(limits): DCNL 'Convert a string into a list of Limit instances.  This DCNL implementation expects a semicolon-separated sequence of DCNL parenthesized groups, where each group contains a DCNL comma-separated sequence consisting of HTTP method, DCNL user-readable URI, a URI reg-exp, an integer number of DCNL requests which can be made, and a unit of measure.  Valid DCNL values for the latter are "SECOND", "MINUTE", "HOUR", and DCNL "DAY". DCNL @return: List of Limit instances.'
def __init__(self, limits=None): DCNL 'Initialize the new `WsgiLimiter`. DCNL @param limits: List of `Limit` objects'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request): DCNL 'Handles a call to this application. Returns 204 if the request is DCNL acceptable to the limiter, else a 403 is returned with a relevant DCNL header indicating when the request *will* succeed.'
def __init__(self, limiter_address): DCNL 'Initialize the new `WsgiLimiterProxy`. DCNL @param limiter_address: IP/port combination of where to request limit'
@staticmethod DCNL def parse_limits(limits): DCNL 'Ignore a limits string--simply doesn\'t apply for the limit DCNL proxy. DCNL @return: Empty list.'
def content_type_params(self, best_content_type): DCNL 'Find parameters in Accept header for given content type.'
def _match(self, host, port, path_info): DCNL 'Find longest match for a given URL path.'
def _path_strategy(self, host, port, path_info): DCNL 'Check path suffix for MIME type and path prefix for API version.'
def _content_type_strategy(self, host, port, environ): DCNL 'Check Content-Type header for API version.'
def _accept_strategy(self, host, port, environ, supported_content_types): DCNL 'Check Accept header for best matching MIME type and API version.'
def _set_enabled_status(self, req, host, enabled): DCNL 'Sets the specified host\'s ability to accept new volumes.'
@wsgi.serializers(xml=HostShowTemplate) DCNL def show(self, req, id): DCNL 'Shows the volume usage info given by hosts. DCNL :param context: security context DCNL :param host: hostname DCNL :returns: expected to use HostShowTemplate. DCNL ex.:: DCNL {\'host\': {\'resource\':D},..} DCNL D: {\'host\': \'hostname\',\'project\': \'admin\', DCNL \'volume_count\': 1, \'total_volume_gb\': 2048}'
@wsgi.serializers(xml=VolumeTypeExtraSpecsTemplate) DCNL def index(self, req, type_id): DCNL 'Returns the list of extra specs for a given volume type'
@wsgi.serializers(xml=VolumeTypeExtraSpecTemplate) DCNL def show(self, req, type_id, id): DCNL 'Return a single extra spec item.'
def delete(self, req, type_id, id): DCNL 'Deletes an existing extra spec'
def _format_quota_set(self, quota_class, quota_set): DCNL 'Convert the quota object to a result dict'
@wsgi.serializers(xml=ServicesIndexTemplate) DCNL def index(self, req): DCNL 'Return a list of all running services. Filter by host & service name.'
@wsgi.serializers(xml=ServicesUpdateTemplate) DCNL def update(self, req, id, body): DCNL 'Enable/Disable scheduling for a service'
def _format_quota_set(self, project_id, quota_set): DCNL 'Convert the quota object to a result dict'
@wsgi.serializers(xml=BackupTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given backup.'
def delete(self, req, id): DCNL 'Delete a backup.'
@wsgi.serializers(xml=BackupsTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of backups.'
@wsgi.serializers(xml=BackupsTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of backups.'
def _get_backups(self, req, is_detail): DCNL 'Returns a list of backups, transformed through view builder.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body): DCNL 'Create a new backup.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupRestoreTemplate) DCNL @wsgi.deserializers(xml=RestoreDeserializer) DCNL def restore(self, req, id, body): DCNL 'Restore an existing backup to a volume.'
@wsgi.action('create') DCNL @wsgi.serializers(xml=types.VolumeTypeTemplate) DCNL def _create(self, req, body): DCNL 'Creates a new volume type.'
@wsgi.action('delete') DCNL def _delete(self, req, id): DCNL 'Deletes an existing volume type.'
@wsgi.action('os-reset_status') DCNL def _reset_status(self, req, id, body): DCNL 'Reset status on the resource.'
@wsgi.action('os-force_delete') DCNL def _force_delete(self, req, id, body): DCNL 'Delete a resource, bypassing the check that it must be available.'
@wsgi.action('os-force_detach') DCNL def _force_detach(self, req, id, body): DCNL 'Roll back a bad detach after the volume been disconnected from DCNL the hypervisor.'
@wsgi.action('os-attach') DCNL def _attach(self, req, id, body): DCNL 'Add attachment metadata.'
@wsgi.action('os-detach') DCNL def _detach(self, req, id, body): DCNL 'Clear attachment metadata.'
@wsgi.action('os-reserve') DCNL def _reserve(self, req, id, body): DCNL 'Mark volume as reserved.'
@wsgi.action('os-unreserve') DCNL def _unreserve(self, req, id, body): DCNL 'Unmark volume as reserved.'
@wsgi.action('os-begin_detaching') DCNL def _begin_detaching(self, req, id, body): DCNL 'Update volume status to \'detaching\'.'
@wsgi.action('os-roll_detaching') DCNL def _roll_detaching(self, req, id, body): DCNL 'Roll back volume status to \'in-use\'.'
@wsgi.action('os-initialize_connection') DCNL def _initialize_connection(self, req, id, body): DCNL 'Initialize volume attachment.'
@wsgi.action('os-terminate_connection') DCNL def _terminate_connection(self, req, id, body): DCNL 'Terminate volume attachment.'
@wsgi.response(202) DCNL @wsgi.action('os-volume_upload_image') DCNL @wsgi.serializers(xml=VolumeToImageSerializer) DCNL @wsgi.deserializers(xml=VolumeToImageDeserializer) DCNL def _volume_upload_image(self, req, id, body): DCNL 'Uploads the specified volume to image service.'
@wsgi.serializers(xml=VersionsTemplate, atom=VersionsAtomSerializer) DCNL def index(self, req): DCNL 'Return all versions.'
@wsgi.serializers(xml=ChoicesTemplate) DCNL @wsgi.response(300) DCNL def multi(self, req): DCNL 'Return multiple choices.'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
def save(self, session=None): DCNL 'Save this object.'
def delete(self, session=None): DCNL 'Delete this object.'
def update(self, values): DCNL 'Make the model object behave like a dict.'
def iteritems(self): DCNL 'Make the model object behave like a dict. DCNL Includes attributes from joins.'
def get(self): DCNL 'Return an item from the pool, when one is available.  This may DCNL cause the calling greenthread to block. Check if a connection is active DCNL before returning it. For dead connections create and return a new DCNL connection.'
def __init__(self, retvalue=True): DCNL ':param retvalue: Value that LoopingCall.wait() should return.'
def rollback_and_reraise(self, msg=None, **kwargs): DCNL 'Rollback a series of actions then re-raise the exception. DCNL .. note:: (sirp) This should only be called within an DCNL exception handler.'
def _fake_cliq_run(self, verb, cliq_args, check_exit_code=True): DCNL 'Return fake results for the various methods.'
def setUp(self): DCNL 'Run before each test.'
def test_limiter_offset_zero(self): DCNL 'Test offset key works with 0.'
def test_limiter_offset_medium(self): DCNL 'Test offset key works with a medium sized number.'
def test_limiter_offset_over_max(self): DCNL 'Test offset key works with a number over 1000 (max_limit).'
def test_limiter_offset_blank(self): DCNL 'Test offset key works with a blank offset.'
def test_limiter_offset_bad(self): DCNL 'Test offset key works with a BAD offset.'
def test_limiter_nothing(self): DCNL 'Test request with no offset or limit'
def test_limiter_limit_zero(self): DCNL 'Test limit of zero.'
def test_limiter_limit_medium(self): DCNL 'Test limit of 10.'
def test_limiter_limit_over_max(self): DCNL 'Test limit of 3000.'
def test_limiter_limit_and_offset(self): DCNL 'Test request with both limit and offset.'
def test_limiter_custom_max_limit(self): DCNL 'Test a max_limit other than 1000.'
def test_limiter_negative_limit(self): DCNL 'Test a negative limit.'
def test_limiter_negative_offset(self): DCNL 'Test a negative offset.'
def test_no_params(self): DCNL 'Test no params.'
def test_valid_marker(self): DCNL 'Test valid marker param.'
def test_valid_limit(self): DCNL 'Test valid limit param.'
def test_invalid_limit(self): DCNL 'Test invalid limit param.'
def test_valid_limit_and_marker(self): DCNL 'Test valid limit and marker parameters.'
def _prepare_xml(self, xml_string): DCNL 'Remove characters from string which hinder XML equality testing.'
def test_400_fault_json(self): DCNL 'Test fault serialized to JSON via file-extension and/or header.'
def test_413_fault_json(self): DCNL 'Test fault serialized to JSON via file-extension and/or header.'
def test_raise(self): DCNL 'Ensure the ability to raise :class:`Fault` in WSGI-ified methods.'
def test_raise_403(self): DCNL 'Ensure the ability to raise :class:`Fault` in WSGI-ified methods.'
def test_fault_has_status_int(self): DCNL 'Ensure the status_int is set correctly on faults'
def test_xml_serializer(self): DCNL 'Ensure that a v1.1 request responds with a v1 xmlns'
def _get_time(self): DCNL 'Return the "time" according to this test suite.'
def setUp(self): DCNL 'Run before each test.'
def _get_index_request(self, accept_header='application/json'): DCNL 'Helper to set routing arguments.'
def _populate_limits(self, request): DCNL 'Put limit info into a request.'
def test_empty_index_json(self): DCNL 'Test getting empty limit details in JSON.'
def test_index_json(self): DCNL 'Test getting limit details in JSON.'
def _populate_limits_diff_regex(self, request): DCNL 'Put limit info into a request.'
def test_index_diff_regex(self): DCNL 'Test getting limit details in JSON.'
@webob.dec.wsgify DCNL def _empty_app(self, request): DCNL 'Do-nothing WSGI app.'
def setUp(self): DCNL 'Prepare middleware for use through fake WSGI app.'
def test_limit_class(self): DCNL 'Test that middleware selected correct limiter class.'
def test_good_request(self): DCNL 'Test successful GET request through middleware.'
def test_limited_request_json(self): DCNL 'Test a rate-limited (413) GET request through middleware.'
def test_limited_request_xml(self): DCNL 'Test a rate-limited (413) response as XML'
def test_GET_no_delay(self): DCNL 'Test a limit handles 1 GET per second.'
def test_GET_delay(self): DCNL 'Test two calls to 1 GET per second limit.'
def test_invalid(self): DCNL 'Test that parse_limits() handles invalid input correctly.'
def test_bad_rule(self): DCNL 'Test that parse_limits() handles bad rules correctly.'
def test_missing_arg(self): DCNL 'Test that parse_limits() handles missing args correctly.'
def test_bad_value(self): DCNL 'Test that parse_limits() handles bad values correctly.'
def test_bad_unit(self): DCNL 'Test that parse_limits() handles bad units correctly.'
def test_multiple_rules(self): DCNL 'Test that parse_limits() handles multiple rules correctly.'
def setUp(self): DCNL 'Run before each test.'
def _check(self, num, verb, url, username=None): DCNL 'Check and yield results from checks.'
def _check_sum(self, num, verb, url, username=None): DCNL 'Check and sum results from checks.'
def test_no_delay_GET(self): DCNL 'Simple test to ensure no delay on a single call for a limit verb we DCNL didn"t set.'
def test_no_delay_PUT(self): DCNL 'Simple test to ensure no delay on a single call for a known limit.'
def test_delay_PUT(self): DCNL 'Ensure the 11th PUT will result in a delay of 6.0 seconds until DCNL the next request will be granced.'
def test_delay_POST(self): DCNL 'Ensure the 8th POST will result in a delay of 6.0 seconds until DCNL the next request will be granced.'
def test_delay_GET(self): DCNL 'Ensure the 11th GET will result in NO delay.'
def test_delay_PUT_volumes(self): DCNL 'Ensure PUT on /volumes limits at 5 requests, and PUT elsewhere is still DCNL OK after 5 requests...but then after 11 total requests, PUT limiting DCNL kicks in.'
def test_delay_PUT_wait(self): DCNL 'Ensure after hitting the limit and then waiting for the correct DCNL amount of time, the limit will be lifted.'
def test_multiple_delays(self): DCNL 'Ensure multiple requests still get a delay.'
def test_user_limit(self): DCNL 'Test user-specific limits.'
def test_multiple_users(self): DCNL 'Tests involving multiple users.'
def setUp(self): DCNL 'Run before each test.'
def _request_data(self, verb, path): DCNL 'Get data decribing a limit request verb/path.'
def _request(self, verb, url, username=None): DCNL 'Make sure that POSTing to the given url causes the given username DCNL to perform the given action.  Make the internal rate limiter return DCNL delay and make sure that the WSGI app returns the correct response.'
def test_invalid_methods(self): DCNL 'Only POSTs should work.'
def __init__(self, response_string): DCNL 'Initialize new `FakeHttplibSocket`.'
def makefile(self, _mode, _other): DCNL 'Returns the socket\'s internal buffer.'
def __init__(self, app, host): DCNL 'Initialize `FakeHttplibConnection`.'
def request(self, method, path, body='', headers=None): DCNL 'Requests made via this connection actually get translated and routed DCNL into our WSGI app, we then wait for the response and turn it back into DCNL an `httplib.HTTPResponse`.'
def getresponse(self): DCNL 'Return our generated response from the request.'
def setUp(self): DCNL 'Do some nifty HTTP/WSGI magic which allows for WSGI to be called DCNL directly by something like the `httplib` library.'
def test_200(self): DCNL 'Successful request test.'
def test_403(self): DCNL 'Forbidden request test.'
def _get_time(self): DCNL 'Return the "time" according to this test suite.'
def setUp(self): DCNL 'Run before each test.'
def _get_index_request(self, accept_header='application/json'): DCNL 'Helper to set routing arguments.'
def _populate_limits(self, request): DCNL 'Put limit info into a request.'
def test_empty_index_json(self): DCNL 'Test getting empty limit details in JSON.'
def test_index_json(self): DCNL 'Test getting limit details in JSON.'
def _populate_limits_diff_regex(self, request): DCNL 'Put limit info into a request.'
def test_index_diff_regex(self): DCNL 'Test getting limit details in JSON.'
@webob.dec.wsgify DCNL def _empty_app(self, request): DCNL 'Do-nothing WSGI app.'
def setUp(self): DCNL 'Prepare middleware for use through fake WSGI app.'
def test_limit_class(self): DCNL 'Test that middleware selected correct limiter class.'
def test_good_request(self): DCNL 'Test successful GET request through middleware.'
def test_limited_request_json(self): DCNL 'Test a rate-limited (413) GET request through middleware.'
def test_limited_request_xml(self): DCNL 'Test a rate-limited (413) response as XML'
def test_GET_no_delay(self): DCNL 'Test a limit handles 1 GET per second.'
def test_GET_delay(self): DCNL 'Test two calls to 1 GET per second limit.'
def test_invalid(self): DCNL 'Test that parse_limits() handles invalid input correctly.'
def test_bad_rule(self): DCNL 'Test that parse_limits() handles bad rules correctly.'
def test_missing_arg(self): DCNL 'Test that parse_limits() handles missing args correctly.'
def test_bad_value(self): DCNL 'Test that parse_limits() handles bad values correctly.'
def test_bad_unit(self): DCNL 'Test that parse_limits() handles bad units correctly.'
def test_multiple_rules(self): DCNL 'Test that parse_limits() handles multiple rules correctly.'
def setUp(self): DCNL 'Run before each test.'
def _check(self, num, verb, url, username=None): DCNL 'Check and yield results from checks.'
def _check_sum(self, num, verb, url, username=None): DCNL 'Check and sum results from checks.'
def test_no_delay_GET(self): DCNL 'Simple test to ensure no delay on a single call for a limit verb we DCNL didn"t set.'
def test_no_delay_PUT(self): DCNL 'Simple test to ensure no delay on a single call for a known limit.'
def test_delay_PUT(self): DCNL 'Ensure the 11th PUT will result in a delay of 6.0 seconds until DCNL the next request will be granced.'
def test_delay_POST(self): DCNL 'Ensure the 8th POST will result in a delay of 6.0 seconds until DCNL the next request will be granced.'
def test_delay_GET(self): DCNL 'Ensure the 11th GET will result in NO delay.'
def test_delay_PUT_volumes(self): DCNL 'Ensure PUT on /volumes limits at 5 requests, and PUT elsewhere is still DCNL OK after 5 requests...but then after 11 total requests, PUT limiting DCNL kicks in.'
def test_delay_PUT_wait(self): DCNL 'Ensure after hitting the limit and then waiting for the correct DCNL amount of time, the limit will be lifted.'
def test_multiple_delays(self): DCNL 'Ensure multiple requests still get a delay.'
def test_user_limit(self): DCNL 'Test user-specific limits.'
def test_multiple_users(self): DCNL 'Tests involving multiple users.'
def setUp(self): DCNL 'Run before each test.'
def _request_data(self, verb, path): DCNL 'Get data decribing a limit request verb/path.'
def _request(self, verb, url, username=None): DCNL 'Make sure that POSTing to the given url causes the given username DCNL to perform the given action.  Make the internal rate limiter return DCNL delay and make sure that the WSGI app returns the correct response.'
def test_invalid_methods(self): DCNL 'Only POSTs should work.'
def __init__(self, response_string): DCNL 'Initialize new `FakeHttplibSocket`.'
def makefile(self, _mode, _other): DCNL 'Returns the socket\'s internal buffer.'
def __init__(self, app, host): DCNL 'Initialize `FakeHttplibConnection`.'
def request(self, method, path, body='', headers=None): DCNL 'Requests made via this connection actually get translated and routed DCNL into our WSGI app, we then wait for the response and turn it back into DCNL an `httplib.HTTPResponse`.'
def getresponse(self): DCNL 'Return our generated response from the request.'
def setUp(self): DCNL 'Do some nifty HTTP/WSGI magic which allows for WSGI to be called DCNL directly by something like the `httplib` library.'
def test_200(self): DCNL 'Successful request test.'
def test_403(self): DCNL 'Forbidden request test.'
def test_attach_in_use_volume(self): DCNL 'Test that attaching to an in-use volume fails.'
def test_attach_attaching_volume_with_different_instance(self): DCNL 'Test that attaching volume reserved for another instance fails.'
def test_list_hosts(self): DCNL 'Verify that the volume hosts are returned.'
def test_show_host_not_exist(self): DCNL 'A host given as an argument does not exists.'
@staticmethod DCNL def _create_backup(volume_id=1, display_name='test_backup', display_description='this DCSP is DCSP a DCSP test DCSP backup', container='volumebackups', status='creating', size=0, object_count=0): DCNL 'Create a backup object.'
@staticmethod DCNL def _create_volume(display_name='test_volume', display_description='this DCSP is DCSP a DCSP test DCSP volume', status='creating', size=1): DCNL 'Create a volume object.'
def test_namespace_volumes(self): DCNL '/servers should have v1.1 namespace (has changed in 1.1).'
def test_get_volumes_summary(self): DCNL 'Simple check that listing volumes works.'
def test_get_volumes(self): DCNL 'Simple check that listing volumes works.'
def _poll_while(self, volume_id, continue_states, max_retries=5): DCNL 'Poll (briefly) while the state is in continue_states.'
def test_create_and_delete_volume(self): DCNL 'Creates and deletes a volume.'
def test_create_volume_with_metadata(self): DCNL 'Creates a volume with metadata.'
def test_create_volume_in_availability_zone(self): DCNL 'Creates a volume in availability_zone.'
def test_get_foxnsocks(self): DCNL 'Simple check that fox-n-socks works.'
def test_login(self): DCNL 'Simple check - we list volumes - so we know we\'re logged in.'
def _get_flags(self): DCNL 'An opportunity to setup flags, before the services are started.'
def __init__(self, xiv_info, logger, expt): DCNL 'Initialize Proxy'
def setUp(self): DCNL 'Initialize IVM XIV Driver.'
def test_initialized_should_set_xiv_info(self): DCNL 'Test that the san flags are passed to the XIV proxy.'
def test_setup_should_fail_if_credentials_are_invalid(self): DCNL 'Test that the xiv_proxy validates credentials.'
def test_setup_should_fail_if_connection_is_invalid(self): DCNL 'Test that the xiv_proxy validates connection.'
def test_create_volume(self): DCNL 'Test creating a volume.'
def test_volume_exists(self): DCNL 'Test the volume exist method with a volume that doesn\'t exist.'
def test_delete_volume(self): DCNL 'Verify that a volume is deleted.'
def test_delete_volume_should_fail_for_not_existing_volume(self): DCNL 'Verify that deleting a non-existing volume is OK.'
def test_create_volume_should_fail_if_no_pool_space_left(self): DCNL 'Vertify that the xiv_proxy validates volume pool space.'
def test_initialize_connection(self): DCNL 'Test that inititialize connection attaches volume to host.'
def test_initialize_connection_should_fail_for_non_existing_volume(self): DCNL 'Verify that initialize won\'t work for non-existing volume.'
def test_terminate_connection(self): DCNL 'Test terminating a connection.'
def test_terminate_connection_should_fail_on_non_existing_volume(self): DCNL 'Test that terminate won\'t work for non-existing volumes.'
def test_terminate_connection_should_fail_on_non_attached_volume(self): DCNL 'Test that terminate won\'t work for volumes that are not attached.'
def test_get_test_admin_context(self): DCNL 'get_test_admin_context\'s return value behaves like admin context.'
def _create_backup_db_entry(self, volume_id=1, display_name='test_backup', display_description='this DCSP is DCSP a DCSP test DCSP backup', container='volumebackups', status='creating', size=0, object_count=0, project_id='fake'): DCNL 'Create a backup entry in the DB. DCNL Return the entry ID'
def _create_volume_db_entry(self, display_name='test_volume', display_description='this DCSP is DCSP a DCSP test DCSP volume', status='backing-up', size=1): DCNL 'Create a volume entry in the DB. DCNL Return the entry ID'
def test_init_host(self): DCNL 'Make sure stuck volumes and backups are reset to correct DCNL states when backup_manager.init_host() is called'
def test_create_backup_with_bad_volume_status(self): DCNL 'Test error handling when creating a backup from a volume DCNL with a bad status'
def test_create_backup_with_bad_backup_status(self): DCNL 'Test error handling when creating a backup with a backup DCNL with a bad status'
def test_create_backup_with_error(self): DCNL 'Test error handling when an error occurs during backup creation'
def test_create_backup(self): DCNL 'Test normal backup creation'
def test_restore_backup_with_bad_volume_status(self): DCNL 'Test error handling when restoring a backup to a volume DCNL with a bad status'
def test_restore_backup_with_bad_backup_status(self): DCNL 'Test error handling when restoring a backup with a backup DCNL with a bad status'
def test_restore_backup_with_driver_error(self): DCNL 'Test error handling when an error occurs during backup restore'
def test_restore_backup_with_bad_service(self): DCNL 'Test error handling when attempting a restore of a backup DCNL with a different service to that used to create the backup'
def test_restore_backup(self): DCNL 'Test normal backup restoration'
def test_delete_backup_with_bad_backup_status(self): DCNL 'Test error handling when deleting a backup with a backup DCNL with a bad status'
def test_delete_backup_with_error(self): DCNL 'Test error handling when an error occurs during backup deletion.'
def test_delete_backup_with_bad_service(self): DCNL 'Test error handling when attempting a delete of a backup DCNL with a different service to that used to create the backup'
def test_delete_backup(self): DCNL 'Test normal backup deletion'
def test_backup_get_all_by_project_with_deleted(self): DCNL 'Test deleted backups don\'t show up in backup_get_all_by_project. DCNL Unless context.read_deleted is \'yes\''
def test_backup_get_all_by_host_with_deleted(self): DCNL 'Test deleted backups don\'t show up in backup_get_all_by_project. DCNL Unless context.read_deleted is \'yes\''
def test_create_destroy(self): DCNL 'Create/Delete volume.'
def test_create_destroy_multiple(self): DCNL 'Create/Delete multiple volumes.'
def test_destroy_non_existent(self): DCNL 'Delete non-existent volume.'
def test_empty_apis(self): DCNL 'Test empty func (for coverage only).'
def test_volume_attach_detach(self): DCNL 'Test volume attachment and detach.'
def test_volume_attach_multiple_detach(self): DCNL 'Test multiple volume attachment and detach.'
def test_wrong_attach_params(self): DCNL 'Test different wrong attach scenarios.'
def test_wrong_detach_params(self): DCNL 'Test different wrong detachment scenarios.'
def test_wrong_login_reply(self): DCNL 'Test wrong login reply.'
def test_ssl_use(self): DCNL 'Coverage test for SSL connection.'
def test_bad_http_response(self): DCNL 'Coverage test for non-good HTTP response.'
def test_delete_without_detach(self): DCNL 'Test volume deletion without detach.'
@staticmethod DCNL def _create_volume(size=0, snapshot_id=None, image_id=None, metadata=None): DCNL 'Create a volume object.'
def test_create_delete_volume(self): DCNL 'Test volume can be created and deleted.'
def test_create_delete_volume_with_metadata(self): DCNL 'Test volume can be created with metadata and deleted.'
def test_create_volume_with_invalid_metadata(self): DCNL 'Test volume create with too much metadata fails.'
def test_create_volume_with_volume_type(self): DCNL 'Test volume creation with default volume type.'
def test_delete_busy_volume(self): DCNL 'Test volume survives deletion if driver reports it as busy.'
def test_create_volume_from_snapshot(self): DCNL 'Test volume can be created from a snapshot.'
def test_too_big_volume(self): DCNL 'Ensure failure if a too large of a volume is requested.'
def test_run_attach_detach_volume(self): DCNL 'Make sure volume can be attached and detached from instance.'
@test.skip_test DCNL def test_preattach_status_volume(self): DCNL 'Ensure volume goes into pre-attaching state'
def test_concurrent_volumes_get_different_targets(self): DCNL 'Ensure multiple concurrent volumes get different targets.'
@staticmethod DCNL def _create_snapshot(volume_id, size='0'): DCNL 'Create a snapshot object.'
def test_create_delete_snapshot(self): DCNL 'Test snapshot can be created and deleted.'
def test_cant_delete_volume_in_use(self): DCNL 'Test volume can\'t be deleted in invalid stats.'
def test_force_delete_volume(self): DCNL 'Test volume can be forced to delete.'
def test_cant_delete_volume_with_snapshots(self): DCNL 'Test volume can\'t be deleted with dependent snapshots.'
def test_can_delete_errored_snapshot(self): DCNL 'Test snapshot can be created and deleted.'
def test_create_snapshot_force(self): DCNL 'Test snapshot in use can be created forcibly.'
def test_delete_busy_snapshot(self): DCNL 'Test snapshot can be created and deleted.'
def _create_volume_from_image(self, expected_status, fakeout_copy_image_to_volume=False): DCNL 'Call copy image to volume, Test the status of volume after calling DCNL copying image to volume.'
def test_create_volume_from_image_status_available(self): DCNL 'Verify that before copying image to volume, it is in available DCNL state.'
def test_create_volume_from_image_exception(self): DCNL 'Verify that create volume from image, the volume status is DCNL \'downloading\'.'
def test_create_volume_from_exact_sized_image(self): DCNL 'Verify that an image which is exactly the same size as the DCNL volume, will work correctly.'
def test_create_volume_from_oversized_image(self): DCNL 'Verify that an image which is too big will fail correctly.'
def test_create_volume_int_size(self): DCNL 'Test volume creation with int size.'
def test_create_volume_string_size(self): DCNL 'Test volume creation with string size.'
def test_create_volume_usage_notification(self): DCNL 'Ensure create volume generates appropriate usage notification'
def test_begin_roll_detaching_volume(self): DCNL 'Test begin_detaching and roll_detaching functions.'
def _attach_volume(self): DCNL 'Attach volumes to an instance.'
def _detach_volume(self, volume_id_list): DCNL 'Detach volumes from an instance.'
def test_delete_busy_volume(self): DCNL 'Test deleting a busy volume.'
def _attach_volume(self): DCNL 'Attach volumes to an instance.'
def __init__(self, status): DCNL ':param status: Either \'failed\' or \'passed\''
def test_create_snapshot(self): DCNL 'Test snapshot can be created and deleted.'
def test_create_volume_from_snapshot(self): DCNL 'Tests volume creation from snapshot.'
def test_create_snapshot(self): DCNL 'Test snapshot can be created and deleted'
def test_create_volume_from_snapshot(self): DCNL 'Tests volume creation from snapshot'
def _print_info_cmd(self, rows, delim=' DCSP ', nohdr=False, **kwargs): DCNL 'Generic function for printing information.'
def _print_info_obj_cmd(self, header, row, delim=' DCSP ', nohdr=False): DCNL 'Generic function for printing information for a specific object.'
def test_setup_no_config(self): DCNL 'Missing SOFS configuration shall raise an error.'
def test_setup_missing_config(self): DCNL 'Non-existent SOFS configuration file shall raise an error.'
def test_setup_no_mount_helper(self): DCNL 'SOFS must be installed to use the driver.'
def test_setup_make_voldir(self): DCNL 'The directory for volumes shall be created automatically.'
def test_local_path(self): DCNL 'Expected behaviour for local_path.'
def test_create_volume(self): DCNL 'Expected behaviour for create_volume.'
def test_delete_volume(self): DCNL 'Expected behaviour for delete_volume.'
def test_create_snapshot(self): DCNL 'Expected behaviour for create_snapshot.'
def test_delete_snapshot(self): DCNL 'Expected behaviour for delete_snapshot.'
def test_initialize_connection(self): DCNL 'Expected behaviour for initialize_connection.'
def _create_volume(self, params={}): DCNL 'Create a test volume.'
def test_notify_usage_exists(self): DCNL 'Ensure \'exists\' notification generates appropriate usage data.'
def check_for_setup_error(self): DCNL 'No setup necessary in fake mode.'
@staticmethod DCNL def fake_execute(cmd, *_args, **_kwargs): DCNL 'Execute that simply logs the command.'
@staticmethod DCNL def log_action(action, parameters): DCNL 'Logs the command.'
def test_volume_type_create_then_destroy(self): DCNL 'Ensure volume types can be created and deleted.'
def test_get_all_volume_types(self): DCNL 'Ensures that all volume types can be retrieved.'
def test_get_default_volume_type(self): DCNL 'Ensures default volume type can be retrieved.'
def test_default_volume_type_missing_in_db(self): DCNL 'Ensures proper exception raised if default volume type DCNL is not in database.'
def test_non_existent_vol_type_shouldnt_delete(self): DCNL 'Ensures that volume type creation fails with invalid args.'
def test_repeated_vol_types_shouldnt_raise(self): DCNL 'Ensures that volume duplicates don\'t raise.'
def test_invalid_volume_types_params(self): DCNL 'Ensures that volume type creation fails with invalid args.'
def test_volume_type_get_by_id_and_name(self): DCNL 'Ensure volume types get returns same entry.'
def test_volume_type_search_by_extra_spec(self): DCNL 'Ensure volume types get by extra spec returns correct type.'
def test_volume_type_search_by_extra_spec_multiple(self): DCNL 'Ensure volume types get by extra spec returns correct type.'
def test_create_with_instance_id(self): DCNL 'Ensure instance_id is persisted as an image-property.'
def test_create_without_instance_id(self): DCNL 'Ensure we can create an image without having to specify an DCNL instance_id. Public images are an example of an image not tied to an DCNL instance.'
def test_glance_version_by_flag(self): DCNL 'Test glance version set by flag is honoured'
def test_glance_version_by_arg(self): DCNL 'Test glance version set by arg to GlanceClientWrapper'
def detail(self, context, **kwargs): DCNL 'Return list of detailed image information.'
def show(self, context, image_id): DCNL 'Get data about specified image. DCNL Returns a dict containing image data for the given opaque image id.'
def create(self, context, metadata, data=None): DCNL 'Store the image data and return the new image id. DCNL :raises: Duplicate if the image already exist.'
def update(self, context, image_id, metadata, data=None, purge_props=False): DCNL 'Replace the contents of the given image with the new data. DCNL :raises: ImageNotFound if the image does not exist.'
def delete(self, context, image_id): DCNL 'Delete the given image. DCNL :raises: ImageNotFound if the image does not exist.'
def test_path_exists_should_return_true(self): DCNL '_path_exists should return True if stat returns 0.'
def test_path_exists_should_return_false(self): DCNL '_path_exists should return True if stat doesn\'t return 0.'
def test_local_path(self): DCNL 'local_path common use case.'
def test_mount_glusterfs_should_mount_correctly(self): DCNL '_mount_glusterfs common case usage.'
def test_mount_glusterfs_should_suppress_already_mounted_error(self): DCNL '_mount_glusterfs should suppress already mounted error if DCNL ensure=True'
def test_mount_glusterfs_should_reraise_already_mounted_error(self): DCNL '_mount_glusterfs should not suppress already mounted error DCNL if ensure=False'
def test_mount_glusterfs_should_create_mountpoint_if_not_yet(self): DCNL '_mount_glusterfs should create mountpoint if it doesn\'t exist.'
def test_mount_glusterfs_should_not_create_mountpoint_if_already(self): DCNL '_mount_glusterfs should not create mountpoint if it already exists.'
def test_get_hash_str(self): DCNL '_get_hash_str should calculation correct value.'
def test_get_mount_point_for_share(self): DCNL '_get_mount_point_for_share should calculate correct value.'
def test_get_available_capacity_with_df(self): DCNL '_get_available_capacity should calculate correct value.'
def test_get_available_capacity_with_du(self): DCNL '_get_available_capacity should calculate correct value.'
def test_ensure_share_mounted(self): DCNL '_ensure_share_mounted simple use case.'
def test_ensure_shares_mounted_should_save_mounting_successfully(self): DCNL '_ensure_shares_mounted should save share if mounted with success.'
def test_ensure_shares_mounted_should_not_save_mounting_with_error(self): DCNL '_ensure_shares_mounted should not save share if failed to mount.'
def test_setup_should_throw_error_if_shares_config_not_configured(self): DCNL 'do_setup should throw error if shares config is not configured.'
def test_setup_should_throw_exception_if_client_is_not_installed(self): DCNL 'do_setup should throw exception if client is not installed.'
def test_find_share_should_throw_error_if_there_is_no_mounted_shares(self): DCNL '_find_share should throw error if there is no mounted shares.'
def test_find_share(self): DCNL '_find_share simple use case.'
def test_find_share_should_throw_error_if_there_is_no_enough_place(self): DCNL '_find_share should throw error if there is no share to host vol.'
def test_create_volume_should_ensure_glusterfs_mounted(self): DCNL 'create_volume ensures shares provided in config are mounted.'
def test_create_volume_should_return_provider_location(self): DCNL 'create_volume should return provider_location with found share.'
def test_delete_volume(self): DCNL 'delete_volume simple test case.'
def test_delete_should_ensure_share_mounted(self): DCNL 'delete_volume should ensure that corresponding share is mounted.'
def test_delete_should_not_delete_if_provider_location_not_provided(self): DCNL 'delete_volume shouldn\'t delete if provider_location missed.'
def test_delete_should_not_delete_if_there_is_no_file(self): DCNL 'delete_volume should not try to delete if file missed.'
@test.skip_if((not test_utils.is_cinder_installed()), 'Test DCSP requires DCSP Cinder DCSP installed DCSP (try DCSP setup.py DCSP develop') DCNL def test_create_volume_no_hosts(self): DCNL 'Ensure empty hosts & child_zones result in NoValidHosts exception.'
@test.skip_if((not test_utils.is_cinder_installed()), 'Test DCSP requires DCSP Cinder DCSP installed DCSP (try DCSP setup.py DCSP develop') DCNL def test_create_volume_non_admin(self): DCNL 'Test creating an instance locally using run_instance, passing DCNL a non-admin context.  DB actions should work.'
@test.skip_if((not test_utils.is_cinder_installed()), 'Test DCSP requires DCSP Cinder DCSP installed DCSP (try DCSP setup.py DCSP develop') DCNL def test_schedule_happy_day(self): DCNL 'Make sure there\'s nothing glaringly wrong with _schedule() DCNL by doing a happy day pass through.'
def test_create_volume_exception_puts_volume_in_error_state(self): DCNL 'Test that a NoValideHost exception for create_volume. DCNL Puts the volume in \'error\' state and eats the exception.'
def _clone_volume_from_image(self, expected_status, clone_works=True): DCNL 'Try to clone a volume from an image, and check the status DCNL afterwards'
def test_clone_image_status_available(self): DCNL 'Verify that before cloning, an image is in the available state.'
def test_clone_image_status_error(self): DCNL 'Verify that before cloning, an image is in the available state.'
def _create_volume(self, size=10): DCNL 'Create a test volume.'
def test_path_exists_should_return_true(self): DCNL '_path_exists should return True if stat returns 0.'
def test_path_exists_should_return_false(self): DCNL '_path_exists should return True if stat doesn\'t return 0.'
def test_get_hash_str(self): DCNL '_get_hash_str should calculation correct value.'
def test_path_exists_should_return_true(self): DCNL '_path_exists should return True if stat returns 0.'
def test_path_exists_should_return_false(self): DCNL '_path_exists should return True if stat doesn\'t return 0.'
def test_local_path(self): DCNL 'local_path common use case.'
def test_mount_nfs_should_mount_correctly(self): DCNL '_mount_nfs common case usage.'
def test_mount_nfs_should_suppress_already_mounted_error(self): DCNL '_mount_nfs should suppress already mounted error if ensure=True'
def test_mount_nfs_should_reraise_already_mounted_error(self): DCNL '_mount_nfs should not suppress already mounted error if ensure=False'
def test_mount_nfs_should_create_mountpoint_if_not_yet(self): DCNL '_mount_nfs should create mountpoint if it doesn\'t exist.'
def test_mount_nfs_should_not_create_mountpoint_if_already(self): DCNL '_mount_nfs should not create mountpoint if it already exists.'
def test_get_hash_str(self): DCNL '_get_hash_str should calculation correct value.'
def test_get_mount_point_for_share(self): DCNL '_get_mount_point_for_share should calculate correct value.'
def test_get_available_capacity_with_df(self): DCNL '_get_available_capacity should calculate correct value.'
def test_get_available_capacity_with_du(self): DCNL '_get_available_capacity should calculate correct value.'
def test_ensure_share_mounted(self): DCNL '_ensure_share_mounted simple use case.'
def test_ensure_shares_mounted_should_save_mounting_successfully(self): DCNL '_ensure_shares_mounted should save share if mounted with success.'
def test_ensure_shares_mounted_should_not_save_mounting_with_error(self): DCNL '_ensure_shares_mounted should not save share if failed to mount.'
def test_setup_should_throw_error_if_shares_config_not_configured(self): DCNL 'do_setup should throw error if shares config is not configured.'
def test_setup_should_throw_exception_if_nfs_client_is_not_installed(self): DCNL 'do_setup should throw error if nfs client is not installed.'
def test_find_share_should_throw_error_if_there_is_no_mounted_shares(self): DCNL '_find_share should throw error if there is no mounted shares.'
def test_find_share(self): DCNL '_find_share simple use case.'
def test_find_share_should_throw_error_if_there_is_no_enough_place(self): DCNL '_find_share should throw error if there is no share to host vol.'
def test_create_volume_should_ensure_nfs_mounted(self): DCNL 'create_volume ensures shares provided in config are mounted.'
def test_create_volume_should_return_provider_location(self): DCNL 'create_volume should return provider_location with found share.'
def test_delete_volume(self): DCNL 'delete_volume simple test case.'
def test_delete_should_ensure_share_mounted(self): DCNL 'delete_volume should ensure that corresponding share is mounted.'
def test_delete_should_not_delete_if_provider_location_not_provided(self): DCNL 'delete_volume shouldn\'t delete if provider_location missed.'
def test_delete_should_not_delete_if_there_is_no_file(self): DCNL 'delete_volume should not try to delete if file missed.'
def test_get_volume_stats(self): DCNL 'get_volume_stats must fill the correct values'
def makefile(self, _mode, _other): DCNL 'Returns the socket\'s internal buffer.'
def close(self): DCNL 'Required for compatibility with boto/tornado.'
def test_walk_versions(self): DCNL 'Walks all version scripts for each tested database, ensuring DCNL that there are no errors in the version scripts for each engine'
def test_mysql_connect_fail(self): DCNL 'Test that we can trigger a mysql connection failure and we fail DCNL gracefully to ensure we don\'t break people without mysql'
@test.skip_unless(_have_mysql(), 'mysql DCSP not DCSP available') DCNL def test_mysql_innodb(self): DCNL 'Test that table creation on mysql only builds InnoDB tables'
def test_postgresql_connect_fail(self): DCNL 'Test that we can trigger a postgres connection failure and we fail DCNL gracefully to ensure we don\'t break people without postgres'
def _migrate_up(self, engine, version, with_data=False): DCNL 'migrate up to a new version of the db. DCNL We allow for data insertion and post checks at every DCNL migration version with special _prerun_### and DCNL _check_### functions in the main test.'
def test_migration_005(self): DCNL 'Test that adding source_volid column works correctly.'
def test_migration_008(self): DCNL 'Test that adding and removing the backups table works correctly'
def test_migration_009(self): DCNL 'Test adding snapshot_metadata table works correctly.'
def find_vhd_by_name(self, name): DCNL 'Finds a volume by its name.'
def volume_exists(self, name): DCNL 'Checks if a volume exists.'
def snapshot_exists(self, name): DCNL 'Checks if a snapshot exists.'
def find_snapshot_by_name(self, name): DCNL 'Finds a snapshot by its name.'
def delete_volume(self, name): DCNL 'Deletes a volume.'
def _get_vhd_path(self, volume_name): DCNL 'Gets the path disk of the volume.'
def delete_snapshot(self, name): DCNL 'Deletes a snapshot.'
def find_initiator_ids(self, target_name, initiator_name): DCNL 'Finds a initiator id by its name.'
def initiator_id_exists(self, target_name, initiator_name): DCNL 'Checks if  a initiatorId exists.'
def find_exports(self, target_name): DCNL 'Finds a export id by its name.'
def export_exists(self, target_name): DCNL 'Checks if  a export exists.'
def delete_initiator_id(self, target_name, initiator_name): DCNL 'Deletes a initiatorId.'
def delete_export(self, target_name): DCNL 'Deletes an export.'
def do_GET(s): DCNL 'Respond to a GET request.'
def do_POST(s): DCNL 'Respond to a POST request.'
def makefile(self, mode, _other): DCNL 'Returns the socket\'s internal buffer'
def do_GET(s): DCNL 'Respond to a GET request.'
def do_POST(s): DCNL 'Respond to a POST request.'
def do_GET(s): DCNL 'Respond to a GET request.'
def do_POST(s): DCNL 'Respond to a POST request.'
@staticmethod DCNL def _get_child_content(self, name): DCNL 'Get the content of the child'
def do_GET(s): DCNL 'Respond to a GET request.'
def do_POST(s): DCNL 'Respond to a POST request.'
def init_host(self): DCNL 'Do any initialization that needs to be run if this is a DCNL standalone service.'
def create_backup(self, context, backup_id): DCNL 'Create volume backups using configured backup service.'
def restore_backup(self, context, backup_id, volume_id): DCNL 'Restore volume backups from configured backup service.'
def delete_backup(self, context, backup_id): DCNL 'Delete volume backup from configured backup service.'
def delete(self, context, backup_id): DCNL 'Make the RPC call to delete a volume backup.'
def create(self, context, name, description, volume_id, container, availability_zone=None): DCNL 'Make the RPC call to create a volume backup.'
def restore(self, context, backup_id, volume_id=None): DCNL 'Make the RPC call to restore a volume backup.'
def backup(self, backup, volume_file): DCNL 'Backup the given volume to swift using the given backup metadata.'
def _restore_v1(self, backup, volume_id, metadata, volume_file): DCNL 'Restore a v1 swift volume backup from swift.'
def restore(self, backup, volume_id, volume_file): DCNL 'Restore the given volume backup from swift.'
def delete(self, backup): DCNL 'Delete the given backup from swift.'
def __init__(self): DCNL 'Initialize the service launcher. DCNL :returns: None'
@staticmethod DCNL def run_server(server): DCNL 'Start and wait for a server to finish. DCNL :param service: Server to run and wait for. DCNL :returns: None'
def launch_server(self, server): DCNL 'Load and start the given server. DCNL :param server: The server you would like to start. DCNL :returns: None'
def stop(self): DCNL 'Stop all services which are currently running. DCNL :returns: None'
def wait(self): DCNL 'Waits until all services have been stopped, and then returns. DCNL :returns: None'
def wait(self): DCNL 'Loop waiting on children to die and respawning as necessary.'
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_interval=None, periodic_fuzzy_delay=None, service_name=None): DCNL 'Instantiates class and passes back application object. DCNL :param host: defaults to FLAGS.host DCNL :param binary: defaults to basename of executable DCNL :param topic: defaults to bin_name - \'cinder-\' part DCNL :param manager: defaults to FLAGS.<topic>_manager DCNL :param report_interval: defaults to FLAGS.report_interval DCNL :param periodic_interval: defaults to FLAGS.periodic_interval DCNL :param periodic_fuzzy_delay: defaults to FLAGS.periodic_fuzzy_delay'
def kill(self): DCNL 'Destroy the service object in the datastore.'
def periodic_tasks(self, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def report_state(self): DCNL 'Update the state of this service in the datastore.'
def __init__(self, name, loader=None): DCNL 'Initialize, but do not start the WSGI server. DCNL :param name: The name of the WSGI server given to the loader. DCNL :param loader: Loads the WSGI application using the given name. DCNL :returns: None'
def _get_manager(self): DCNL 'Initialize a Manager object appropriate for this service. DCNL Use the service name to look up a Manager subclass from the DCNL configuration and initialize an instance. If no class name DCNL is configured, just return None. DCNL :returns: a Manager instance, or None.'
def start(self): DCNL 'Start serving this service using loaded configuration. DCNL Also, retrieve updated port number in case \'0\' was passed in, which DCNL indicates a random port should be used. DCNL :returns: None'
def stop(self): DCNL 'Stop serving this API. DCNL :returns: None'
def wait(self): DCNL 'Wait for the service to stop serving this API. DCNL :returns: None'
def format(self, record): DCNL 'Uses contextstring if request_id is set, otherwise default.'
def formatException(self, exc_info, record=None): DCNL 'Format exception output with CONF.logging_exception_prefix.'
def __init__(self, topic, default_version): DCNL 'Initialize an RpcProxy. DCNL :param topic: The topic to use for all messages. DCNL :param default_version: The default API version to request in all DCNL outgoing messages.  This can be overridden on a per-message DCNL basis.'
def _set_version(self, msg, vers): DCNL 'Helper method to set the version in a message. DCNL :param msg: The message having a version added to it. DCNL :param vers: The version number to add to the message.'
def _get_topic(self, topic): DCNL 'Return the topic to use for a message.'
def call(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.call() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: The return value from the remote method.'
def multicall(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.multicall() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: An iterator that lets you process each of the returned values DCNL from the remote method as they arrive.'
def cast(self, context, msg, topic=None, version=None): DCNL 'rpc.cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast() does not wait on any return value from the DCNL remote method.'
def fanout_cast(self, context, msg, topic=None, version=None): DCNL 'rpc.fanout_cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast() does not wait on any return value DCNL from the remote method.'
def cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast_to_server() does not wait on any DCNL return values.'
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.fanout_cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast_to_server() does not wait on any DCNL return values.'
def __init__(self, conf, connection_pool, pooled=True, server_params=None): DCNL 'Create a new connection, or get one from the pool'
def __enter__(self): DCNL 'When with ConnectionContext() is used, return self'
def _done(self): DCNL 'If the connection came from a pool, clean it up and put it back. DCNL If it did not come from a pool, close it.'
def __exit__(self, exc_type, exc_value, tb): DCNL 'End of \'with\' statement.  We\'re done here.'
def __del__(self): DCNL 'Caller is done with this connection.  Make sure we cleaned up.'
def close(self): DCNL 'Caller is done with this connection.'
def __getattr__(self, key): DCNL 'Proxy all other calls to the Connection instance'
def check_duplicate_message(self, message_data): DCNL 'AMQP consumers may read same message twice when exceptions occur DCNL before ack is returned. This method prevents doing it.'
def wait(self): DCNL 'Wait for all callback threads to exit.'
def __init__(self, conf, callback, connection_pool): DCNL ':param conf: cfg.CONF instance DCNL :param callback: a callable (probably a function) DCNL :param connection_pool: connection pool as returned by DCNL get_connection_pool()'
def __call__(self, message_data): DCNL 'Consumer callback to call a method on a proxy object. DCNL Parses the message for validity and fires off a thread to call the DCNL proxy object method. DCNL Message data should be a dictionary with two keys: DCNL method: string representing the method to call DCNL args: dictionary of arg: value DCNL Example: {\'method\': \'echo\', \'args\': {\'value\': 42}}'
def _process_data(self, ctxt, version, method, args): DCNL 'Process a message in a new thread. DCNL If the proxy object we have has a dispatch method DCNL (see rpc.dispatcher.RpcDispatcher), pass it the version, DCNL method, and args and let it dispatch as appropriate.  If not, use DCNL the old behavior of magically calling the specified method on the DCNL proxy we have here.'
def __iter__(self): DCNL 'Return a result until we get a reply with an \'ending" flag'
def __call__(self, data): DCNL 'The consume() callback will call this.  Store the result.'
def __iter__(self): DCNL 'Return a result until we get a \'None\' response from consumer'
def __init__(self, callbacks): DCNL 'Initialize the rpc dispatcher. DCNL :param callbacks: List of proxy objects that are an instance DCNL of a class with rpc methods exposed.  Each proxy DCNL object should have an RPC_API_VERSION attribute.'
def dispatch(self, ctxt, version, method, **kwargs): DCNL 'Dispatch a message based on a requested version. DCNL :param ctxt: The request context DCNL :param version: The requested API version from the incoming message DCNL :param method: The method requested to be called by the incoming DCNL message. DCNL :param kwargs: A dict of keyword arguments to be passed to the method. DCNL :returns: Whatever is returned by the underlying method that gets DCNL called.'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a key.host is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def is_alive(self, topic, host): DCNL 'Checks if a host is alive.'
def expire(self, topic, host): DCNL 'Explicitly expire a host\'s registration.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Spawn heartbeat greenthread.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a host.topic is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def backend_register(self, key, host): DCNL 'Implements registration logic. DCNL Called by register(self,key,host)'
def backend_unregister(self, key, key_host): DCNL 'Implements de-registration logic. DCNL Called by unregister(self,key,host)'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Implementation of MatchMakerBase.start_heartbeat DCNL Launches greenthread looping send_heartbeats(), DCNL yielding for CONF.matchmaker_heartbeat_freq seconds DCNL between iterations.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts): DCNL 'Declare a queue on an amqp session. DCNL \'session\' is the amqp session to use DCNL \'callback\' is the callback to call when messages are received DCNL \'node_name\' is the first part of the Qpid address string, before \';\' DCNL \'node_opts\' will be applied to the "x-declare" section of "node" DCNL in the address string. DCNL \'link_name\' goes into the "name" field of the "link" in the address DCNL string DCNL \'link_opts\' will be applied to the "x-declare" section of "link" DCNL in the address string.'
def reconnect(self, session): DCNL 'Re-declare the receiver after a qpid reconnect'
def consume(self): DCNL 'Fetch the message and pass it to the callback object'
def __init__(self, conf, session, msg_id, callback): DCNL 'Init a \'direct\' queue. DCNL \'session\' is the amqp session to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None): DCNL 'Init a \'topic\' queue. DCNL :param session: the amqp session to use DCNL :param topic: is the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param name: optional queue name, defaults to topic'
def __init__(self, conf, session, topic, callback): DCNL 'Init a \'fanout\' queue. DCNL \'session\' is the amqp session to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, session, node_name, node_opts=None): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, session): DCNL 'Re-establish the Sender after a reconnection'
def send(self, msg): DCNL 'Send a message'
def __init__(self, conf, session, msg_id): DCNL 'Init a \'direct\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'fanout\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing sessions and queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
def socket_s(self): DCNL 'Get socket type as string.'
def subscribe(self, msg_filter): DCNL 'Subscribe.'
def unsubscribe(self, msg_filter): DCNL 'Unsubscribe.'
def _get_response(self, ctx, proxy, topic, data): DCNL 'Process a curried message and cast the result to topic.'
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None): DCNL 'Reply to a casted call.'
def consume_in_thread(self): DCNL 'Runs the ZmqProxy service'
def close(self): DCNL 'Close the connection. DCNL This method must be called when the connection will no longer be used. DCNL It will ensure that any resources associated with the connection, such DCNL as a network connection, and cleaned up.'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer on this connection. DCNL A consumer is associated with a message queue on the backend message DCNL bus.  The consumer will read messages from the queue, unpack them, and DCNL dispatch them to the proxy object.  The contents of the message pulled DCNL off of the queue will determine which method gets called on the proxy DCNL object. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. For example, all instances of nova-compute consume DCNL from a queue called "compute".  In that case, the DCNL messages will get distributed amongst the consumers in a DCNL round-robin fashion if fanout=False.  If fanout=True, DCNL every consumer associated with this topic will get a DCNL copy of every message. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param fanout: Whether or not this is a fanout topic.  See the DCNL documentation for the topic parameter for some DCNL additional comments on this.'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker on this connection. DCNL A worker is like a regular consumer of messages directed to a DCNL topic, except that it is part of a set of such consumers (the DCNL "pool") which may run in parallel. Every pool of workers will DCNL receive a given message, but only one worker in the pool will DCNL be asked to process it. Load is distributed across the members DCNL of the pool in round-robin fashion. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param pool_name: String containing the name of the pool of workers'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created. DCNL :param callback: Callable to be invoked for each message. DCNL :type callback: callable accepting one argument DCNL :param pool_name: The name of the consumer pool. DCNL :type pool_name: str DCNL :param topic: The routing topic for desired messages. DCNL :type topic: str DCNL :param exchange_name: The name of the message exchange where DCNL the client should attach. Defaults to DCNL the configured exchange. DCNL :type exchange_name: str'
def consume_in_thread(self): DCNL 'Spawn a thread to handle incoming messages. DCNL Spawn a thread that will be responsible for handling all incoming DCNL messages for consumers that were set up on this connection. DCNL Message dispatching inside of this is expected to be implemented in a DCNL non-blocking manner.  An example implementation would be having this DCNL thread pull messages in for all of the consumers, but utilize a thread DCNL pool for dispatching the messages to the proxy objects.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
def __init__(self, channel, callback, tag, **kwargs): DCNL 'Declare a queue on an amqp channel. DCNL \'channel\' is the amqp channel to use DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL queue name, exchange name, and other kombu options are DCNL passed in here as a dictionary.'
def reconnect(self, channel): DCNL 'Re-declare the queue after a rabbit reconnect'
def consume(self, *args, **kwargs): DCNL 'Actually declare the consumer on the amqp channel.  This will DCNL start the flow of messages from the queue.  Using the DCNL Connection.iterconsume() iterator will process the messages, DCNL calling the appropriate callback. DCNL If a callback is specified in kwargs, use that.  Otherwise, DCNL use the callback passed during __init__() DCNL If kwargs[\'nowait\'] is True, then this call will block until DCNL a message is read. DCNL Messages will automatically be acked if the callback doesn\'t DCNL raise an exception'
def cancel(self): DCNL 'Cancel the consuming from the queue, if it has started'
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs): DCNL 'Init a \'direct\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs): DCNL 'Init a \'topic\' queue. DCNL :param channel: the amqp channel to use DCNL :param topic: the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param tag: a unique ID for the consumer on the channel DCNL :param name: optional queue name, defaults to topic DCNL :paramtype name: str DCNL Other kombu options may be passed as keyword arguments'
def __init__(self, conf, channel, topic, callback, tag, **kwargs): DCNL 'Init a \'fanout\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, channel, exchange_name, routing_key, **kwargs): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, channel): DCNL 'Re-establish the Producer after a rabbit reconnection'
def send(self, msg, timeout=None): DCNL 'Send a message'
def __init__(self, conf, channel, msg_id, **kwargs): DCNL 'init a \'direct\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'topic\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'fanout\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def _fetch_ssl_params(self): DCNL 'Handles fetching what ssl params DCNL should be used for the connection (if any)'
def _connect(self, params): DCNL 'Connect to rabbit.  Re-establish any queues that may have DCNL been declared before if we are reconnecting.  Exceptions should DCNL be handled by the caller.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing queues. DCNL Will retry up to self.max_retries number of times. DCNL self.max_retries = 0 means to retry forever. DCNL Sleep between tries, starting at self.interval_start DCNL seconds, backing off self.interval_stepping number of seconds DCNL each attempt.'
def get_channel(self): DCNL 'Convenience call for bin/clear_rabbit_queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
@classmethod DCNL def load_json(cls, data, default_rule=None): DCNL 'Init a brain using json instead of a rules dictionary.'
def check(self, match_list, target_dict, cred_dict): DCNL 'Checks authorization of some rules against credentials. DCNL Detailed description of the check with examples in policy.enforce(). DCNL :param match_list: nested tuples of data to match against DCNL :param target_dict: dict of object properties DCNL :param credentials_dict: dict of actor properties DCNL :returns: True if the check passes'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def __str__(self): DCNL 'Make the VersionInfo object behave like a string.'
def __repr__(self): DCNL 'Include the name.'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def _weight_multiplier(self): DCNL 'How weighted this weigher should be.  Normally this would DCNL be overriden in a subclass based on a config value.'
def _weigh_object(self, obj, weight_properties): DCNL 'Override in a subclass to specify a weight for a specific DCNL object.'
def weigh_objects(self, weighed_obj_list, weight_properties): DCNL 'Weigh multiple objects.  Override in a subclass if you need DCNL need access to all objects in order to manipulate weights.'
def _is_correct_class(self, obj): DCNL 'Return whether an object is a class of the correct type and DCNL is not prefixed with an underscore.'
def get_weighed_objects(self, weigher_classes, obj_list, weighing_properties): DCNL 'Return a sorted (highest score first) list of WeighedObjects.'
def _filter_one(self, obj, filter_properties): DCNL 'Return True if the object passes the filter, otherwise False.'
def host_passes(self, host_state, filter_properties): DCNL 'Return True if the HostState passes the filter, otherwise False. DCNL Override this in a subclass.'
def _satisfies_extra_specs(self, capabilities, resource_type): DCNL 'Check that the capabilities provided by the services DCNL satisfy the extra specs associated with the instance type'
def host_passes(self, host_state, filter_properties): DCNL 'Return a list of hosts that can create instance_type.'
def _op_compare(self, args, op): DCNL 'Returns True if the specified operator can successfully DCNL compare the first item in the args with all the rest. Will DCNL return False if only one item is in the list.'
def _equals(self, args): DCNL 'First term is == all the other terms.'
def _less_than(self, args): DCNL 'First term is < all the other terms.'
def _greater_than(self, args): DCNL 'First term is > all the other terms.'
def _in(self, args): DCNL 'First term is in set of remaining terms'
def _less_than_equal(self, args): DCNL 'First term is <= all the other terms.'
def _greater_than_equal(self, args): DCNL 'First term is >= all the other terms.'
def _not(self, args): DCNL 'Flip each of the arguments.'
def _or(self, args): DCNL 'True if any arg is True.'
def _and(self, args): DCNL 'True if all args are True.'
def _parse_string(self, string, host_state): DCNL 'Strings prefixed with $ are capability lookups in the DCNL form \'$variable\' where \'variable\' is an attribute in the DCNL HostState class.  If $variable is a dictionary, you may DCNL use: $variable.dictkey'
def _process_filter(self, query, host_state): DCNL 'Recursively parse the query structure.'
def host_passes(self, host_state, filter_properties): DCNL 'Return a list of hosts that can fulfill the requirements DCNL specified in the query.'
def _filter_one(self, obj, filter_properties): DCNL 'Return True if it passes the filter, False otherwise. DCNL Override this in a subclass.'
def filter_all(self, filter_obj_list, filter_properties): DCNL 'Yield objects that pass the filter. DCNL Can be overriden in a subclass, if you need to base filtering DCNL decisions on all objects.  Otherwise, one can just override DCNL _filter_one() to filter a single object.'
def _is_correct_class(self, obj): DCNL 'Return whether an object is a class of the correct type and DCNL is not prefixed with an underscore.'
def get_exec(self, exec_dirs=[]): DCNL 'Returns existing executable, or empty string if none found'
def match(self, userargs): DCNL 'Only check that the first argument (command) matches exec_path'
def get_command(self, userargs, exec_dirs=[]): DCNL 'Returns command to execute (with sudo -u if run_as != root).'
def get_environment(self, userargs): DCNL 'Returns specific environment to set, None if none'
def __init__(cls, names, bases, dict_): DCNL 'Metaclass that allows us to collect decorated periodic tasks.'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def periodic_tasks(self, context, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def init_host(self): DCNL 'Handle initialization if this is a standalone service. DCNL Child classes should override this method.'
def update_service_capabilities(self, capabilities): DCNL 'Remember these capabilities to send on next periodic update.'
@periodic_task DCNL def _publish_service_capabilities(self, context): DCNL 'Pass data back to the scheduler at a periodic interval.'
def _create_static_client(self, context, host, port, use_ssl, version): DCNL 'Create a client that we\'ll use for every call.'
def _create_onetime_client(self, context, version): DCNL 'Create a client that will be used for one call.'
def call(self, context, method, *args, **kwargs): DCNL 'Call a glance client method.  If we get a connection error, DCNL retry the request according to FLAGS.glance_num_retries.'
def detail(self, context, **kwargs): DCNL 'Calls out to Glance for a list of detailed image information.'
def show(self, context, image_id): DCNL 'Returns a dict with image data for the given opaque image id.'
def get_location(self, context, image_id): DCNL 'Returns the direct url representing the backend storage location, DCNL or None if this attribute is not shown by Glance.'
def download(self, context, image_id, data): DCNL 'Calls out to Glance for metadata and data and writes data.'
def create(self, context, image_meta, data=None): DCNL 'Store the image data and return the new image object.'
def update(self, context, image_id, image_meta, data=None, purge_props=True): DCNL 'Modify the given image with the new data.'
def delete(self, context, image_id): DCNL 'Delete the given image. DCNL :raises: ImageNotFound if the image does not exist. DCNL :raises: NotAuthorized if the user is not an owner.'
@staticmethod DCNL def _is_image_available(context, image): DCNL 'Check image availability. DCNL This check is needed in case Nova and Glance are deployed DCNL without authentication turned on.'
def get_by_project(self, context, project_id, resource): DCNL 'Get a specific quota by project.'
def get_by_class(self, context, quota_class, resource): DCNL 'Get a specific quota by quota class.'
def get_defaults(self, context, resources): DCNL 'Given a list of resources, retrieve the default quotas. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources.'
def get_class_quotas(self, context, resources, quota_class, defaults=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL quota class. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param quota_class: The name of the quota class to return DCNL quotas for. DCNL :param defaults: If True, the default value will be reported DCNL if there is no specific value for the DCNL resource.'
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL project. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param project_id: The ID of the project to return quotas for. DCNL :param quota_class: If project_id != context.project_id, the DCNL quota class cannot be determined.  This DCNL parameter allows it to be specified.  It DCNL will be ignored if project_id == DCNL context.project_id. DCNL :param defaults: If True, the quota class value (or the DCNL default value, if there is no value from the DCNL quota class) will be reported if there is no DCNL specific value for the resource. DCNL :param usages: If True, the current in_use and reserved counts DCNL will also be returned.'
def _get_quotas(self, context, resources, keys, has_sync, project_id=None): DCNL 'A helper method which retrieves the quotas for the specific DCNL resources identified by keys, and which apply to the current DCNL context. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param keys: A list of the desired quotas to retrieve. DCNL :param has_sync: If True, indicates that the resource must DCNL have a sync attribute; if False, indicates DCNL that the resource must NOT have a sync DCNL attribute. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def limit_check(self, context, resources, values, project_id=None): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param values: A dictionary of the values to check against the DCNL quota. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def reserve(self, context, resources, deltas, expire=None, project_id=None): DCNL 'Check quotas and reserve resources. DCNL For counting quotas--those quotas for which there is a usage DCNL synchronization function--this method checks quotas against DCNL current usage and the desired deltas. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it does not have a usage DCNL synchronization function. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns a DCNL list of reservation UUIDs which were created. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param deltas: A dictionary of the proposed delta changes. DCNL :param expire: An optional parameter specifying an expiration DCNL time for the reservations.  If it is a simple DCNL number, it is interpreted as a number of DCNL seconds and added to the current time; if it is DCNL a datetime.timedelta object, it will also be DCNL added to the current time.  A datetime.datetime DCNL object will be interpreted as the absolute DCNL expiration time.  If None is specified, the DCNL default expiration time set by DCNL --default-reservation-expire will be used (this DCNL value will be treated as a number of seconds). DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def commit(self, context, reservations, project_id=None): DCNL 'Commit reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def rollback(self, context, reservations, project_id=None): DCNL 'Roll back reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def destroy_all_by_project(self, context, project_id): DCNL 'Destroy all quotas, usages, and reservations associated with a DCNL project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project being deleted.'
def expire(self, context): DCNL 'Expire reservations. DCNL Explores all currently existing reservations and rolls back DCNL any that have expired. DCNL :param context: The request context, for access checks.'
def __init__(self, name, flag=None): DCNL 'Initializes a Resource. DCNL :param name: The name of the resource, i.e., "volumes". DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def quota(self, driver, context, **kwargs): DCNL 'Given a driver and context, obtain the quota for this DCNL resource. DCNL :param driver: A quota driver. DCNL :param context: The request context. DCNL :param project_id: The project to obtain the quota value for. DCNL If not provided, it is taken from the DCNL context.  If it is given as None, no DCNL project-specific quota will be searched DCNL for. DCNL :param quota_class: The quota class corresponding to the DCNL project, or for which the quota is to be DCNL looked up.  If not provided, it is taken DCNL from the context.  If it is given as None, DCNL no quota class-specific quota will be DCNL searched for.  Note that the quota class DCNL defaults to the value in the context, DCNL which may not correspond to the project if DCNL project_id is not the same as the one in DCNL the context.'
@property DCNL def default(self): DCNL 'Return the default value of the quota.'
def __init__(self, name, sync, flag=None): DCNL 'Initializes a ReservableResource. DCNL Reservable resources are those resources which directly DCNL correspond to objects in the database, i.e., volumes, gigabytes, DCNL etc.  A ReservableResource must be constructed with a usage DCNL synchronization function, which will be called to determine the DCNL current counts of one or more resources. DCNL The usage synchronization function will be passed three DCNL arguments: an admin context, the project ID, and an opaque DCNL session object, which should in turn be passed to the DCNL underlying database function.  Synchronization functions DCNL should return a dictionary mapping resource names to the DCNL current in_use count for those resources; more than one DCNL resource and resource count may be returned.  Note that DCNL synchronization functions may be associated with more than one DCNL ReservableResource. DCNL :param name: The name of the resource, i.e., "volumes". DCNL :param sync: A callable which returns a dictionary to DCNL resynchronize the in_use count for one or more DCNL resources, as described above. DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def __init__(self, name, count, flag=None): DCNL 'Initializes a CountableResource. DCNL Countable resources are those resources which directly DCNL correspond to objects in the database, i.e., volumes, gigabytes, DCNL etc., but for which a count by project ID is inappropriate.  A DCNL CountableResource must be constructed with a counting DCNL function, which will be called to determine the current counts DCNL of the resource. DCNL The counting function will be passed the context, along with DCNL the extra positional and keyword arguments that are passed to DCNL Quota.count().  It should return an integer specifying the DCNL count. DCNL Note that this counting is not performed in a transaction-safe DCNL manner.  This resource class is a temporary measure to provide DCNL required functionality, until a better approach to solving DCNL this problem can be evolved. DCNL :param name: The name of the resource, i.e., "volumes". DCNL :param count: A callable which returns the count of the DCNL resource.  The arguments passed are as described DCNL above. DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def __init__(self, quota_driver_class=None): DCNL 'Initialize a Quota object.'
def register_resource(self, resource): DCNL 'Register a resource.'
def register_resources(self, resources): DCNL 'Register a list of resources.'
def get_by_project(self, context, project_id, resource): DCNL 'Get a specific quota by project.'
def get_by_class(self, context, quota_class, resource): DCNL 'Get a specific quota by quota class.'
def get_defaults(self, context): DCNL 'Retrieve the default quotas. DCNL :param context: The request context, for access checks.'
def get_class_quotas(self, context, quota_class, defaults=True): DCNL 'Retrieve the quotas for the given quota class. DCNL :param context: The request context, for access checks. DCNL :param quota_class: The name of the quota class to return DCNL quotas for. DCNL :param defaults: If True, the default value will be reported DCNL if there is no specific value for the DCNL resource.'
def get_project_quotas(self, context, project_id, quota_class=None, defaults=True, usages=True): DCNL 'Retrieve the quotas for the given project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project to return quotas for. DCNL :param quota_class: If project_id != context.project_id, the DCNL quota class cannot be determined.  This DCNL parameter allows it to be specified. DCNL :param defaults: If True, the quota class value (or the DCNL default value, if there is no value from the DCNL quota class) will be reported if there is no DCNL specific value for the resource. DCNL :param usages: If True, the current in_use and reserved counts DCNL will also be returned.'
def count(self, context, resource, *args, **kwargs): DCNL 'Count a resource. DCNL For countable resources, invokes the count() function and DCNL returns its result.  Arguments following the context and DCNL resource are passed directly to the count function declared by DCNL the resource. DCNL :param context: The request context, for access checks. DCNL :param resource: The name of the resource, as a string.'
def limit_check(self, context, project_id=None, **values): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction.  The DCNL values to check are given as keyword arguments, where the key DCNL identifies the specific quota limit to check, and the value is DCNL the proposed value. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def reserve(self, context, expire=None, project_id=None, **deltas): DCNL 'Check quotas and reserve resources. DCNL For counting quotas--those quotas for which there is a usage DCNL synchronization function--this method checks quotas against DCNL current usage and the desired deltas.  The deltas are given as DCNL keyword arguments, and current usage and other reservations DCNL are factored into the quota check. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it does not have a usage DCNL synchronization function. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns a DCNL list of reservation UUIDs which were created. DCNL :param context: The request context, for access checks. DCNL :param expire: An optional parameter specifying an expiration DCNL time for the reservations.  If it is a simple DCNL number, it is interpreted as a number of DCNL seconds and added to the current time; if it is DCNL a datetime.timedelta object, it will also be DCNL added to the current time.  A datetime.datetime DCNL object will be interpreted as the absolute DCNL expiration time.  If None is specified, the DCNL default expiration time set by DCNL --default-reservation-expire will be used (this DCNL value will be treated as a number of seconds). DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def commit(self, context, reservations, project_id=None): DCNL 'Commit reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def rollback(self, context, reservations, project_id=None): DCNL 'Roll back reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def destroy_all_by_project(self, context, project_id): DCNL 'Destroy all quotas, usages, and reservations associated with a DCNL project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project being deleted.'
def expire(self, context): DCNL 'Expire reservations. DCNL Explores all currently existing reservations and rolls back DCNL any that have expired. DCNL :param context: The request context, for access checks.'
def __init__(self, name, app, host=None, port=None, pool_size=None, protocol=eventlet.wsgi.HttpProtocol): DCNL 'Initialize, but do not start, a WSGI server. DCNL :param name: Pretty name for logging. DCNL :param app: The WSGI application to serve. DCNL :param host: IP address to serve the application. DCNL :param port: Port number to server the application. DCNL :param pool_size: Maximum number of eventlets to spawn concurrently. DCNL :returns: None'
def _start(self): DCNL 'Run the blocking eventlet WSGI server. DCNL :returns: None'
def start(self, backlog=128): DCNL 'Start serving a WSGI application. DCNL :param backlog: Maximum number of queued connections. DCNL :returns: None DCNL :raises: cinder.exception.InvalidInput'
def stop(self): DCNL 'Stop this server. DCNL This is not a very nice action, as currently the method by which a DCNL server is stopped is by killing its eventlet. DCNL :returns: None'
def wait(self): DCNL 'Block, until the server has stopped. DCNL Waits on the server\'s eventlet to finish, then returns. DCNL :returns: None'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [app:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [app:wadl] DCNL latest_version = 1.3 DCNL paste.app_factory = cinder.api.fancy_api:Wadl.factory DCNL which would result in a call to the `Wadl` class as DCNL import cinder.api.fancy_api DCNL fancy_api.Wadl(latest_version=\'1.3\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def __call__(self, environ, start_response): DCNL 'Subclasses will probably want to implement __call__ like this: DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL # Any of the following objects work as responses: DCNL # Option 1: simple string DCNL res = \'message\n\' DCNL # Option 2: a nicely formatted HTTP exception page DCNL res = exc.HTTPForbidden(detail=\'Nice try\') DCNL # Option 3: a webob Response object (in case you need to play with DCNL # headers, or you want to be treated like an iterable, or or or) DCNL res = Response(); DCNL res.app_iter = open(\'somefile\') DCNL # Option 4: any wsgi app to be run next DCNL res = self.application DCNL # Option 5: you can get a Response object for a wsgi app, too, to DCNL # play with headers etc DCNL res = req.get_response(self.application) DCNL # You can then just return your response... DCNL return res DCNL # ... or set req.response and return None. DCNL req.response = res DCNL See the end of http://pythonpaste.org/webob/modules/dec.html DCNL for more info.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [filter:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [filter:analytics] DCNL redis_host = 127.0.0.1 DCNL paste.filter_factory = cinder.api.analytics:Analytics.factory DCNL which would result in a call to the `Analytics` class as DCNL import cinder.api.analytics DCNL analytics.Analytics(app_from_paste, redis_host=\'127.0.0.1\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def process_request(self, req): DCNL 'Called on each request. DCNL If this returns None, the next application down the stack will be DCNL executed. If it returns a response then that response will be returned DCNL and execution will stop here.'
def process_response(self, response): DCNL 'Do whatever you\'d like to the response.'
@staticmethod DCNL def print_generator(app_iter): DCNL 'Iterator that prints the contents of a wrapper string.'
def __init__(self, mapper): DCNL 'Create a router for the given routes.Mapper. DCNL Each route in `mapper` must specify a \'controller\', which is a DCNL WSGI app to call.  You\'ll probably want to specify an \'action\' as DCNL well and have your controller be an object that can route DCNL the request to the action-specific method. DCNL Examples: DCNL mapper = routes.Mapper() DCNL sc = ServerController() DCNL # Explicit mapping of one route to a controller+action DCNL mapper.connect(None, \'/svrlist\', controller=sc, action=\'list\') DCNL # Actions are all implicitly defined DCNL mapper.resource(\'server\', \'servers\', controller=sc) DCNL # Pointing to an arbitrary WSGI app.  You can specify the DCNL # {path_info:.*} parameter so the target app can be handed just that DCNL # section of the URL. DCNL mapper.connect(None, \'/v1.0/{path_info:.*}\', controller=BlogApp())'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Route the incoming request to a controller based on self.map. DCNL If no match, return a 404.'
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req): DCNL 'Dispatch the request to the appropriate controller. DCNL Called by self._router after matching the incoming request to a route DCNL and putting the information into req.environ.  Either returns 404 DCNL or the routed WSGI app\'s response.'
def __init__(self, config_path=None): DCNL 'Initialize the loader, and attempt to find the config. DCNL :param config_path: Full or relative path to the paste config. DCNL :returns: None'
def load_app(self, name): DCNL 'Return the paste URLMap wrapped WSGI application. DCNL :param name: Name of the application to load. DCNL :returns: Paste URLMap object wrapping the requested application. DCNL :raises: `cinder.exception.PasteAppNotFound`'
def _filter_hosts(self, request_spec, hosts, **kwargs): DCNL 'Filter a list of hosts based on request_spec.'
def _schedule(self, context, topic, request_spec, **kwargs): DCNL 'Picks a host that is up at random.'
def schedule_create_volume(self, context, request_spec, filter_properties): DCNL 'Picks a host that is up at random.'
def get_host_list(self): DCNL 'Get a list of hosts from the HostManager.'
def get_service_capabilities(self): DCNL 'Get the normalized set of capabilities for the services.'
def update_service_capabilities(self, service_name, host, capabilities): DCNL 'Process a capability update from a service node.'
def hosts_up(self, context, topic): DCNL 'Return the list of hosts that have a running service for topic.'
def schedule(self, context, topic, method, *_args, **_kwargs): DCNL 'Must override schedule method for scheduler to work.'
def schedule_create_volume(self, context, request_spec, filter_properties): DCNL 'Must override schedule method for scheduler to work.'
def update_from_volume_capability(self, capability): DCNL 'Update information about a host from its volume_node info.'
def consume_from_volume(self, volume): DCNL 'Incrementally update host state from an volume'
def _choose_host_filters(self, filter_cls_names): DCNL 'Since the caller may specify which filters to use we need DCNL to have an authoritative list of what is permissible. This DCNL function checks the filter names against a predefined set DCNL of acceptable filters.'
def _choose_host_weighers(self, weight_cls_names): DCNL 'Since the caller may specify which weighers to use, we need DCNL to have an authoritative list of what is permissible. This DCNL function checks the weigher names against a predefined set DCNL of acceptable weighers.'
def get_filtered_hosts(self, hosts, filter_properties, filter_class_names=None): DCNL 'Filter hosts and return only ones passing all filters'
def get_weighed_hosts(self, hosts, weight_properties, weigher_class_names=None): DCNL 'Weigh the hosts'
def update_service_capabilities(self, service_name, host, capabilities): DCNL 'Update the per-service capabilities based on this notification.'
def get_all_host_states(self, context): DCNL 'Returns a dict of all the hosts the HostManager DCNL knows about. Also, each of the consumable resources in HostState DCNL are pre-populated and adjusted based on data in the db. DCNL For example: DCNL {\'192.168.1.100\': HostState(), ...}'
def get_host_list(self, context): DCNL 'Get a list of hosts from the HostManager.'
def get_service_capabilities(self, context): DCNL 'Get the normalized set of capabilities for this zone.'
def update_service_capabilities(self, context, service_name=None, host=None, capabilities=None, **kwargs): DCNL 'Process a capability update from a service node.'
def schedule(self, context, topic, method, *args, **kwargs): DCNL 'The schedule() contract requires we return the one DCNL best-suited host for this request.'
def _get_configuration_options(self): DCNL 'Fetch options dictionary. Broken out for testing.'
def populate_filter_properties(self, request_spec, filter_properties): DCNL 'Stuff things into filter_properties.  Can be overridden in a DCNL subclass to add more data.'
def _post_select_populate_filter_properties(self, filter_properties, host_state): DCNL 'Add additional information to the filter properties after a host has DCNL been selected by the scheduling process.'
def _add_retry_host(self, filter_properties, host): DCNL 'Add a retry entry for the selected volume backend. In the event that DCNL the request gets re-scheduled, this entry will signal that the given DCNL backend has already been tried.'
def _log_volume_error(self, volume_id, retry): DCNL 'If the request contained an exception from a previous volume DCNL create operation, log it to aid debugging'
def _populate_retry(self, filter_properties, properties): DCNL 'Populate filter properties with history of retries for this DCNL request. If maximum retries is exceeded, raise NoValidHost.'
def _schedule(self, context, request_spec, filter_properties=None): DCNL 'Returns a list of hosts that meet the required specs, DCNL ordered by their fitness.'
def _get_file_handle(self, filename): DCNL 'Get file handle. Broken out for testing.'
def _get_file_timestamp(self, filename): DCNL 'Get the last modified datetime. Broken out for testing.'
def _load_file(self, handle): DCNL 'Decode the JSON file. Broken out for testing.'
def _get_time_now(self): DCNL 'Get current UTC. Broken out for testing.'
def get_configuration(self, filename=None): DCNL 'Check the json file for changes and load it if needed.'
def _weight_multiplier(self): DCNL 'Override the weight multiplier.'
def _weigh_object(self, host_state, weight_properties): DCNL 'Higher weights win.  We want spreading to be the default.'
def host_passes(self, host_state, filter_properties): DCNL 'Return True if host has sufficient capacity.'
def host_passes(self, host_state, filter_properties): DCNL 'Skip nodes that have already been attempted.'
def schedule_create_volume(self, context, request_spec, filter_properties): DCNL 'Picks a host that is up and has the fewest volumes.'
def __init__(self, user_id, project_id, is_admin=None, read_deleted='no', roles=None, remote_address=None, timestamp=None, request_id=None, auth_token=None, overwrite=True, quota_class=None, **kwargs): DCNL ':param read_deleted: \'no\' indicates deleted records are hidden, \'yes\' DCNL indicates deleted records are visible, \'only\' indicates that DCNL *only* deleted records are visible. DCNL :param overwrite: Set to False to ensure that the greenthread local DCNL copy of the index is not overwritten. DCNL :param kwargs: Extra arguments that might be present, but we ignore DCNL because they possibly came in from older rpc messages.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
def create_volume(self, volume): DCNL 'Creates a volume. Can optionally return a Dictionary of DCNL changes to the volume object to be persisted.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def delete_volume(self, volume): DCNL 'Deletes a volume.'
def create_snapshot(self, snapshot): DCNL 'Creates a snapshot.'
def delete_snapshot(self, snapshot): DCNL 'Deletes a snapshot.'
def ensure_export(self, context, volume): DCNL 'Synchronously recreates an export for a volume.'
def create_export(self, context, volume): DCNL 'Exports the volume. Can optionally return a Dictionary of changes DCNL to the volume object to be persisted.'
def remove_export(self, context, volume): DCNL 'Removes an export for a volume.'
def initialize_connection(self, volume, connector): DCNL 'Allow connection to connector and return connection info.'
def terminate_connection(self, volume, connector, force=False, **kwargs): DCNL 'Disallow connection from connector'
def attach_volume(self, context, volume_id, instance_uuid, mountpoint): DCNL 'Callback for volume attached to instance.'
def detach_volume(self, context, volume_id): DCNL 'Callback for volume detached.'
def get_volume_stats(self, refresh=False): DCNL 'Return the current state of the volume service. If \'refresh\' is DCNL True, run the update first.'
def do_setup(self, context): DCNL 'Any initialization the volume driver does while starting'
def copy_image_to_volume(self, context, volume, image_service, image_id): DCNL 'Fetch the image from image_service and write it to the volume.'
def copy_volume_to_image(self, context, volume, image_service, image_meta): DCNL 'Copy the volume to the specified image.'
def clone_image(self, volume, image_location): DCNL 'Create a volume efficiently from an existing image. DCNL image_location is a string whose format depends on the DCNL image service backend in use. The driver should use it DCNL to determine whether cloning is possible. DCNL Returns a boolean indicating whether cloning occurred'
def backup_volume(self, context, backup, backup_service): DCNL 'Create a new backup from an existing volume.'
def restore_backup(self, context, backup, volume, backup_service): DCNL 'Restore an existing backup to a new or existing volume.'
def _get_iscsi_properties(self, volume): DCNL 'Gets iscsi configuration DCNL We ideally get saved information in the volume entity, but fall back DCNL to discovery if need be. Discovery may be completely removed in future DCNL The properties are: DCNL :target_discovered:    boolean indicating whether discovery was used DCNL :target_iqn:    the IQN of the iSCSI target DCNL :target_portal:    the portal of the iSCSI target DCNL :target_lun:    the lun of the iSCSI target DCNL :volume_id:    the id of the volume (currently used by xen) DCNL :auth_method:, :auth_username:, :auth_password: DCNL the authentication details. Right now, either auth_method is not DCNL present meaning no authentication, or auth_method == `CHAP` DCNL meaning use CHAP with the specified credentials.'
def initialize_connection(self, volume, connector): DCNL 'Initializes the connection and returns connection info. DCNL The iscsi driver returns a driver_volume_type of \'iscsi\'. DCNL The format of the driver data is defined in _get_iscsi_properties. DCNL Example return value:: DCNL \'driver_volume_type\': \'iscsi\' DCNL \'data\': { DCNL \'target_discovered\': True, DCNL \'target_iqn\': \'iqn.2010-10.org.openstack:volume-00000001\', DCNL \'target_portal\': \'127.0.0.0.1:3260\', DCNL \'volume_id\': 1,'
def _get_iscsi_initiator(self): DCNL 'Get iscsi initiator name for this machine'
def copy_image_to_volume(self, context, volume, image_service, image_id): DCNL 'Fetch the image from image_service and write it to the volume.'
def copy_volume_to_image(self, context, volume, image_service, image_meta): DCNL 'Copy the volume to the specified image.'
def _attach_volume(self, context, volume, connector): DCNL 'Attach the volume.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def check_for_setup_error(self): DCNL 'No setup necessary in fake mode.'
@staticmethod DCNL def fake_execute(cmd, *_args, **_kwargs): DCNL 'Execute that simply logs the command.'
def initialize_connection(self, volume, connector): DCNL 'Initializes the connection and returns connection info. DCNL The  driver returns a driver_volume_type of \'fibre_channel\'. DCNL The target_wwn can be a single entry or a list of wwns that DCNL correspond to the list of remote wwn(s) that will export the volume. DCNL Example return values: DCNL \'driver_volume_type\': \'fibre_channel\' DCNL \'data\': { DCNL \'target_discovered\': True, DCNL \'target_lun\': 1, DCNL \'target_wwn\': \'1234567890123\', DCNL or DCNL \'driver_volume_type\': \'fibre_channel\' DCNL \'data\': { DCNL \'target_discovered\': True, DCNL \'target_lun\': 1, DCNL \'target_wwn\': [\'1234567890123\', \'0987654321321\'],'
def set_execute(self, execute): DCNL 'Set the function to be used to execute commands.'
def create_iscsi_target(self, name, tid, lun, path, chap_auth=None, **kwargs): DCNL 'Create a iSCSI target and logical unit'
def remove_iscsi_target(self, tid, lun, vol_id, **kwargs): DCNL 'Remove a iSCSI target and logical unit'
def _new_target(self, name, tid, **kwargs): DCNL 'Create a new iSCSI target.'
def _delete_target(self, tid, **kwargs): DCNL 'Delete a target.'
def show_target(self, tid, iqn=None, **kwargs): DCNL 'Query the given target ID.'
def _new_logicalunit(self, tid, lun, path, **kwargs): DCNL 'Create a new LUN on a target using the supplied path.'
def _delete_logicalunit(self, tid, lun, **kwargs): DCNL 'Delete a logical unit from a target.'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met'
def _delete_volume(self, volume, size_in_g): DCNL 'Deletes a logical volume.'
def create_volume(self, volume): DCNL 'Creates a logical volume. Can optionally return a Dictionary of DCNL changes to the volume object to be persisted.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot.'
def delete_volume(self, volume): DCNL 'Deletes a logical volume.'
def clear_volume(self, volume): DCNL 'unprovision old volumes to prevent data leaking between users.'
def create_snapshot(self, snapshot): DCNL 'Creates a snapshot.'
def delete_snapshot(self, snapshot): DCNL 'Deletes a snapshot.'
def copy_image_to_volume(self, context, volume, image_service, image_id): DCNL 'Fetch the image from image_service and write it to the volume.'
def copy_volume_to_image(self, context, volume, image_service, image_meta): DCNL 'Copy the volume to the specified image.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def backup_volume(self, context, backup, backup_service): DCNL 'Create a new backup from an existing volume.'
def restore_backup(self, context, backup, volume, backup_service): DCNL 'Restore an existing backup to a new or existing volume.'
def ensure_export(self, context, volume): DCNL 'Synchronously recreates an export for a logical volume.'
def _fix_id_migration(self, context, volume): DCNL 'Fix provider_location and dev files to address bug 1065702. DCNL For volumes that the provider_location has NOT been updated DCNL and are not currently in-use we\'ll create a new iscsi target DCNL and remove the persist file. DCNL If the volume is in-use, we\'ll just stick with the old name DCNL and when detach is called we\'ll feed back into ensure_export DCNL again if necessary and fix things up then. DCNL Details at: https://bugs.launchpad.net/cinder/+bug/1065702'
def _ensure_iscsi_targets(self, context, host): DCNL 'Ensure that target ids have been created in datastore.'
def create_export(self, context, volume): DCNL 'Creates an export for a logical volume.'
def remove_export(self, context, volume): DCNL 'Removes an export for a logical volume.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met'
def create_volume(self, volume): DCNL 'Creates a logical volume. Can optionally return a Dictionary of DCNL changes to the volume object to be persisted.'
def delete_volume(self, volume): DCNL 'Deletes a logical volume.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def create_snapshot(self, snapshot): DCNL 'Creates a snapshot of a volume.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def create_volume(self, volume): DCNL 'Creates a EMC(VMAX/VNX) volume.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a cloned volume.'
def delete_volume(self, volume): DCNL 'Deletes an EMC volume.'
def create_snapshot(self, snapshot): DCNL 'Creates a snapshot.'
def delete_snapshot(self, snapshot): DCNL 'Deletes a snapshot.'
def ensure_export(self, context, volume): DCNL 'Driver entry point to get the export info for an existing volume.'
def create_export(self, context, volume): DCNL 'Driver entry point to get the export info for a new volume.'
def remove_export(self, context, volume): DCNL 'Driver entry point to remove an export for a volume.'
def check_for_export(self, context, volume_id): DCNL 'Make sure volume is exported.'
def initialize_connection(self, volume, connector): DCNL 'Initializes the connection and returns connection info. DCNL The iscsi driver returns a driver_volume_type of \'iscsi\'. DCNL the format of the driver data is defined in _get_iscsi_properties. DCNL Example return value:: DCNL \'driver_volume_type\': \'iscsi\' DCNL \'data\': { DCNL \'target_discovered\': True, DCNL \'target_iqn\': \'iqn.2010-10.org.openstack:volume-00000001\', DCNL \'target_portal\': \'127.0.0.0.1:3260\', DCNL \'volume_id\': 1,'
def _get_iscsi_properties(self, volume): DCNL 'Gets iscsi configuration. DCNL We ideally get saved information in the volume entity, but fall back DCNL to discovery if need be. Discovery may be completely removed in future DCNL The properties are: DCNL :target_discovered:    boolean indicating whether discovery was used DCNL :target_iqn:    the IQN of the iSCSI target DCNL :target_portal:    the portal of the iSCSI target DCNL :target_lun:    the lun of the iSCSI target DCNL :volume_id:    the id of the volume (currently used by xen) DCNL :auth_method:, :auth_username:, :auth_password: DCNL the authentication details. Right now, either auth_method is not DCNL present meaning no authentication, or auth_method == `CHAP` DCNL meaning use CHAP with the specified credentials.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Disallow connection from connector.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def create_volume(self, volume): DCNL 'Creates a EMC(VMAX/VNX) volume.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def delete_volume(self, volume): DCNL 'Deletes an EMC volume.'
def create_snapshot(self, snapshot): DCNL 'Creates a snapshot.'
def delete_snapshot(self, snapshot): DCNL 'Deletes a snapshot.'
def create_export(self, context, volume): DCNL 'Driver entry point to get the export info for a new volume.'
def _expose_paths(self, configservice, vol_instance, connector): DCNL 'This method maps a volume to a host. DCNL It adds a volume and initiator to a Storage Group DCNL and therefore maps the volume to the host.'
def _hide_paths(self, configservice, vol_instance, connector): DCNL 'This method unmaps a volume from the host. DCNL Removes a volume from the Storage Group DCNL and therefore unmaps the volume from the host.'
def _add_members(self, configservice, vol_instance): DCNL 'This method maps a volume to a host. DCNL Add volume to the Device Masking Group that belongs to DCNL a Masking View.'
def _remove_members(self, configservice, vol_instance): DCNL 'This method unmaps a volume from a host. DCNL Removes volume from the Device Masking Group that belongs to DCNL a Masking View.'
def _map_lun(self, volume, connector): DCNL 'Maps a volume to the host.'
def _unmap_lun(self, volume, connector): DCNL 'Unmaps a volume from the host.'
def initialize_connection(self, volume, connector): DCNL 'Initializes the connection and returns connection info.'
def terminate_connection(self, volume, connector): DCNL 'Disallow connection from connector.'
def update_volume_status(self): DCNL 'Retrieve status info.'
def _get_storage_type(self, filename=None): DCNL 'Get the storage type from the config file.'
def _find_device_masking_group(self): DCNL 'Finds the Device Masking Group in a masking view.'
def connect(self): DCNL 'Create an SSH client and open an interactive SSH channel.'
def close(self): DCNL 'Close SSH connection.'
def read(self, timeout=None): DCNL 'Read data from SSH channel.'
def send_cmd(self, strcmd, timeout, waitstr=None): DCNL 'Send SSH commands and return results.'
def do_setup(self, context): DCNL 'Check config file.'
def check_for_setup_error(self): DCNL 'Try to connect with device and get device type.'
def create_volume(self, volume): DCNL 'Create a new volume.'
def delete_volume(self, volume): DCNL 'Delete a volume.'
def create_export(self, context, volume): DCNL 'Driver entry point to get the  export info for a new volume.'
def ensure_export(self, context, volume): DCNL 'Driver entry point to get the export info for a existing volume.'
def remove_export(self, context, volume_id): DCNL 'Driver entry point to remove an export for a volume.'
def initialize_connection(self, volume, connector): DCNL 'Map a volume to a host and return target iSCSI information.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Delete map between a volume and a host.'
def create_snapshot(self, snapshot): DCNL 'Create a snapshot.'
def delete_snapshot(self, snapshot): DCNL 'Delete a snapshot.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Create a volume from a snapshot. DCNL We use LUNcopy to create a new LUN from snapshot.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def _check_conf_file(self): DCNL 'Check the config file, make sure the key elements are set.'
def _read_xml(self): DCNL 'Open xml file.'
def _get_login_info(self): DCNL 'Get login IP, username and password from config file.'
def _get_lun_set_info(self): DCNL 'Get parameters from config file for creating LUN.'
def _find_pool_info(self, pooltype): DCNL 'Return pools information created in storage device.'
def _get_maximum_pool(self, poolinconf, poolindev, luntype): DCNL 'Get the maximum pool from config file. DCNL According to the given pools\' name in config file, DCNL we select the pool of maximum free capacity.'
def _get_iscsi_info(self): DCNL 'Get iSCSI info from config file.'
def _execute_cli(self, cmd): DCNL 'Build SSH connection to execute CLI commands. DCNL If the connection to first controller time out, DCNL try to connect to the other controller.'
def _name_translate(self, name): DCNL 'Form new names because of the 32-character limit on names.'
def _find_lun(self, name): DCNL 'Get the ID of a LUN with the given LUN name.'
def _create_hostgroup(self, hostgroupname): DCNL 'Create a host group.'
def _find_hostgroup(self, groupname): DCNL 'Get the given hostgroup ID.'
def _add_host(self, hostname, hostgroupid): DCNL 'Add a new host.'
def _check_initiator(self, ininame): DCNL 'Check whether the initiator is already added.'
def _add_initiator(self, ininame): DCNL 'Add a new initiator to storage device.'
def _delete_initiator(self, ininame): DCNL 'Delete an initiator.'
def _find_host_in_hostgroup(self, hostname, hostgroupid): DCNL 'Get the given host ID.'
def _get_hostport_info(self, hostid): DCNL 'Get hostports details of the given host.'
def _add_hostport(self, portname, hostid, portinfo, multipathtype=0): DCNL 'Add a host port.'
def _delete_hostport(self, portid): DCNL 'Delete a host port.'
def _get_tgt_iqn(self, iscsiip): DCNL 'Get target iSCSI iqn.'
def _get_iscsi_ip_info(self, iscsiip): DCNL 'Get iSCSI IP infomation of storage device.'
def _map_lun(self, lunid, hostid, new_hostlun_id): DCNL 'Map a lun to a host. DCNL Here we give the hostlun ID which starts from 1.'
def _get_hostlunid(self, hostid, lunid): DCNL 'Get the hostLUN ID of a LUN according host ID and LUN ID.'
def _delete_map(self, mapid, attempts=1): DCNL 'Remove the map.'
def _delete_host(self, hostid): DCNL 'Delete a host.'
def _get_map_info(self, hostid): DCNL 'Get map infomation of the given host. DCNL This method return a map information list. Every item in the list DCNL is a dictionary. The dictionarie includes three keys: mapid, DCNL devlunid, hostlunid. These items are sorted by hostlunid value DCNL from small to large.'
def _get_device_type(self): DCNL 'Get the storage device type and product version.'
def _active_snapshot(self, snapshotid): DCNL 'Active a snapshot.'
def _disable_snapshot(self, snapshotid): DCNL 'Disable a snapshot.'
def _delete_snapshot(self, snapshotid): DCNL 'Delete a snapshot.'
def _create_volume(self, name, size): DCNL 'Create a new volume with the given name and size.'
def _delete_volume(self, name, lunid): DCNL 'Delete a volume.'
def _create_luncopy(self, luncopyname, srclunid, tgtlunid): DCNL 'Create a LUNcopy.'
def _start_luncopy(self, luncopyid): DCNL 'Starte a LUNcopy.'
def _find_luncopy(self, luncopyname): DCNL 'Get the given LUNcopy\'s ID.'
def _wait_for_luncopy(self, luncopyname): DCNL 'Wait for LUNcopy to complete.'
def _get_luncopy_info(self, luncopyname): DCNL 'Get LUNcopy information.'
def _delete_luncopy(self, luncopyid): DCNL 'Delete a LUNcopy.'
def _create_snapshot(self, snapshotname, srclunid): DCNL 'Create a snapshot with snapshot name and source LUN ID.'
def _find_snapshot(self, snapshotname): DCNL 'Get the given snapshot ID.'
def _is_resource_pool_enough(self): DCNL 'Check whether resource pools\' valid size is more than 1G.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def _get_free_capacity(self): DCNL 'Get total free capacity of pools.'
def _check_prerequisites(self): DCNL 'Sanity checks before attempting to mount SOFS.'
def do_setup(self, context): DCNL 'Any initialization the volume driver does while starting.'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met.'
def create_volume(self, volume): DCNL 'Creates a logical volume. DCNL Can optionally return a Dictionary of changes to the volume DCNL object to be persisted.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot.'
def delete_volume(self, volume): DCNL 'Deletes a logical volume.'
def create_snapshot(self, snapshot): DCNL 'Creates a snapshot.'
def delete_snapshot(self, snapshot): DCNL 'Deletes a snapshot.'
def ensure_export(self, context, volume): DCNL 'Synchronously recreates an export for a logical volume.'
def create_export(self, context, volume): DCNL 'Exports the volume. DCNL Can optionally return a Dictionary of changes to the volume DCNL object to be persisted.'
def remove_export(self, context, volume): DCNL 'Removes an export for a logical volume.'
def initialize_connection(self, volume, connector): DCNL 'Allow connection to connector and return connection info.'
def terminate_connection(self, volume, connector, force=False, **kwargs): DCNL 'Disallow connection from connector.'
def attach_volume(self, context, volume_id, instance_uuid, mountpoint): DCNL 'Callback for volume attached to instance.'
def detach_volume(self, context, volume_id): DCNL 'Callback for volume detached.'
def get_volume_stats(self, refresh=False): DCNL 'Return the current state of the volume service. DCNL If \'refresh\' is True, run the update first.'
def copy_image_to_volume(self, context, volume, image_service, image_id): DCNL 'Fetch the image from image_service and write it to the volume.'
def copy_volume_to_image(self, context, volume, image_service, image_meta): DCNL 'Copy the volume to the specified image.'
def clone_image(self, volume, image_location): DCNL 'Create a volume efficiently from an existing image. DCNL image_location is a string whose format depends on the DCNL image service backend in use. The driver should use it DCNL to determine whether cloning is possible. DCNL Returns a boolean indicating whether cloning occurred'
def __init__(self, *args, **kwargs): DCNL 'Initialize the driver.'
def do_setup(self, context): DCNL 'Setup and verify IBM XIV storage connection.'
def ensure_export(self, context, volume): DCNL 'Ensure an export.'
def create_export(self, context, volume): DCNL 'Create an export.'
def create_volume(self, volume): DCNL 'Create a volume on the IBM XIV storage system.'
def delete_volume(self, volume): DCNL 'Delete a volume on the IBM XIV storage system.'
def remove_export(self, context, volume): DCNL 'Disconnect a volume from an attached instance.'
def initialize_connection(self, volume, connector): DCNL 'Map the created volume.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Terminate a connection to a volume.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Create a volume from a snapshot.'
def create_snapshot(self, snapshot): DCNL 'Create a snapshot.'
def delete_snapshot(self, snapshot): DCNL 'Delete a snapshot.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume stats.'
def do_setup(self, context): DCNL 'Any initialization the volume driver does while starting.'
def check_for_setup_error(self): DCNL 'Just to override parent behavior.'
def create_volume(self, volume): DCNL 'Creates a volume.'
def delete_volume(self, volume): DCNL 'Deletes a logical volume.'
def ensure_export(self, ctx, volume): DCNL 'Synchronously recreates an export for a logical volume.'
def create_export(self, ctx, volume): DCNL 'Exports the volume. Can optionally return a Dictionary of changes DCNL to the volume object to be persisted.'
def remove_export(self, ctx, volume): DCNL 'Removes an export for a logical volume.'
def initialize_connection(self, volume, connector): DCNL 'Allow connection to connector and return connection info.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Disallow connection from connector.'
def _do_create_volume(self, volume): DCNL 'Create a volume on given glusterfs_share. DCNL :param volume: volume reference'
def _ensure_shares_mounted(self): DCNL 'Look for GlusterFS shares in the flags and try to mount them DCNL locally.'
def _ensure_share_mounted(self, glusterfs_share): DCNL 'Mount GlusterFS share. DCNL :param glusterfs_share:'
def _find_share(self, volume_size_for): DCNL 'Choose GlusterFS share among available ones for given volume size. DCNL Current implementation looks for greatest capacity. DCNL :param volume_size_for: int size in GB'
def _get_mount_point_for_share(self, glusterfs_share): DCNL 'Return mount point for share. DCNL :param glusterfs_share: example 172.18.194.100:/var/glusterfs'
def _get_available_capacity(self, glusterfs_share): DCNL 'Calculate available space on the GlusterFS share. DCNL :param glusterfs_share: example 172.18.194.100:/var/glusterfs'
def _mount_glusterfs(self, glusterfs_share, mount_path, ensure=False): DCNL 'Mount GlusterFS share to mount path.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume stats. DCNL If \'refresh\' is True, update the stats first.'
def _update_volume_stats(self): DCNL 'Retrieve stats info from volume group.'
def _check_fail(self, request, response): DCNL 'Utility routine to handle checking ZAPI failures.'
def _create_client(self, **kwargs): DCNL 'Instantiate a web services client. DCNL This method creates a "suds" client to make web services calls to the DCNL DFM server. Note that the WSDL file is quite large and may take DCNL a few seconds to parse.'
def _set_storage_service(self, storage_service): DCNL 'Set the storage service to use for provisioning.'
def _set_storage_service_prefix(self, storage_service_prefix): DCNL 'Set the storage service prefix to use for provisioning.'
def _set_vfiler(self, vfiler): DCNL 'Set the vfiler to use for provisioning.'
def _check_flags(self): DCNL 'Ensure that the flags we care about are set.'
def do_setup(self, context): DCNL 'Setup the NetApp Volume driver. DCNL Called one time by the manager after the driver is loaded. DCNL Validate the flags we care about and setup the suds (web services) DCNL client.'
def check_for_setup_error(self): DCNL 'Check that the driver is working and can communicate. DCNL Invoke a web services API to make sure we can talk to the server. DCNL Also perform the discovery of datasets and LUNs from DFM.'
def _get_datasets(self): DCNL 'Get the list of datasets from DFM.'
def _discover_dataset_luns(self, dataset, volume): DCNL 'Discover all of the LUNs in a dataset.'
def _discover_luns(self): DCNL 'Discover the LUNs from DFM. DCNL Discover all of the OpenStack-created datasets and LUNs in the DFM DCNL database.'
def _get_job_progress(self, job_id): DCNL 'Get progress of one running DFM job. DCNL Obtain the latest progress report for the job and return the DCNL list of progress events.'
def _wait_for_job(self, job_id): DCNL 'Wait until a job terminates. DCNL Poll the job until it completes or an error is detected. Return the DCNL final list of progress events if it completes successfully.'
def _dataset_name(self, project, ss_type): DCNL 'Return the dataset name for a given project and volume type.'
def _get_dataset(self, dataset_name): DCNL 'Lookup a dataset by name in the list of discovered datasets.'
def _create_dataset(self, dataset_name, project, ss_type): DCNL 'Create a new dataset using the storage service. DCNL The export settings are set to create iSCSI LUNs aligned for Linux. DCNL Returns the ID of the new dataset.'
@lockutils.synchronized('netapp_dfm', 'cinder-', True) DCNL def _provision(self, name, description, project, ss_type, size): DCNL 'Provision a LUN through provisioning manager. DCNL The LUN will be created inside a dataset associated with the project. DCNL If the dataset doesn\'t already exist, we create it using the storage DCNL service specified in the cinder conf.'
def _get_ss_type(self, volume): DCNL 'Get the storage service type for a volume.'
@lockutils.synchronized('netapp_dfm', 'cinder-', True) DCNL def _remove_destroy(self, name, project): DCNL 'Remove the LUN from the dataset, also destroying it. DCNL Remove the LUN from the dataset and destroy the actual LUN and Qtree DCNL on the storage system.'
def create_volume(self, volume): DCNL 'Driver entry point for creating a new volume.'
def _lookup_lun_for_volume(self, name, project): DCNL 'Lookup the LUN that corresponds to the give volume. DCNL Initial lookups involve a table scan of all of the discovered LUNs, DCNL but later lookups are done instantly from the hashtable.'
def delete_volume(self, volume): DCNL 'Driver entry point for destroying existing volumes.'
def _get_lun_details(self, lun_id): DCNL 'Given the ID of a LUN, get the details about that LUN.'
def _get_host_details(self, host_id): DCNL 'Given the ID of a host, get the details about it. DCNL A "host" is a storage system here.'
def _get_iqn_for_host(self, host_id): DCNL 'Get the iSCSI Target Name for a storage system.'
def _api_elem_is_empty(self, elem): DCNL 'Return true if the API element should be considered empty. DCNL Helper routine to figure out if a list returned from a proxy API DCNL is empty. This is necessary because the API proxy produces nasty DCNL looking XML.'
def _get_target_portal_for_host(self, host_id, host_address): DCNL 'Get iSCSI target portal for a storage system. DCNL Get the iSCSI Target Portal details for a particular IP address DCNL on a storage system.'
def _get_export(self, volume): DCNL 'Get the iSCSI export details for a volume. DCNL Looks up the LUN in DFM based on the volume and project name, then get DCNL the LUN\'s ID. We store that value in the database instead of the iSCSI DCNL details because we will not have the true iSCSI details until masking DCNL time (when initialize_connection() is called).'
def ensure_export(self, context, volume): DCNL 'Driver entry point to get the export info for an existing volume.'
def create_export(self, context, volume): DCNL 'Driver entry point to get the export info for a new volume.'
def remove_export(self, context, volume): DCNL 'Driver exntry point to remove an export for a volume. DCNL Since exporting is idempotent in this driver, we have nothing DCNL to do for unexporting.'
def _find_igroup_for_initiator(self, host_id, initiator_name): DCNL 'Get the igroup for an initiator. DCNL Look for an existing igroup (initiator group) on the storage system DCNL containing a given iSCSI initiator and return the name of the igroup.'
def _create_igroup(self, host_id, initiator_name): DCNL 'Create a new igroup. DCNL Create a new igroup (initiator group) on the storage system to hold DCNL the given iSCSI initiator. The group will only have 1 member and will DCNL be named "openstack-${initiator_name}".'
def _get_lun_mappping(self, host_id, lunpath, igroup_name): DCNL 'Get the mapping between a LUN and an igroup. DCNL Check if a given LUN is already mapped to the given igroup (initiator DCNL group). If the LUN is mapped, also return the LUN number for the DCNL mapping.'
def _map_initiator(self, host_id, lunpath, igroup_name): DCNL 'Map a LUN to an igroup. DCNL Map the given LUN to the given igroup (initiator group). Return the LUN DCNL number that the LUN was mapped to (the filer will choose the lowest DCNL available number).'
def _unmap_initiator(self, host_id, lunpath, igroup_name): DCNL 'Unmap the given LUN from the given igroup (initiator group).'
def _ensure_initiator_mapped(self, host_id, lunpath, initiator_name): DCNL 'Ensure that a LUN is mapped to a particular initiator. DCNL Check if a LUN is mapped to a given initiator already and create DCNL the mapping if it is not. A new igroup will be created if needed. DCNL Returns the LUN number for the mapping between the LUN and initiator DCNL in both cases.'
def _ensure_initiator_unmapped(self, host_id, lunpath, initiator_name): DCNL 'Ensure that a LUN is not mapped to a particular initiator. DCNL Check if a LUN is mapped to a given initiator and remove the DCNL mapping if it is. This does not destroy the igroup.'
def initialize_connection(self, volume, connector): DCNL 'Driver entry point to attach a volume to an instance. DCNL Do the LUN masking on the storage system so the initiator can access DCNL the LUN on the target. Also return the iSCSI properties so the DCNL initiator can find the LUN. This implementation does not call DCNL _get_iscsi_properties() to get the properties because cannot store the DCNL LUN number in the database. We only find out what the LUN number will DCNL be during this method call so we construct the properties dictionary DCNL ourselves.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Driver entry point to unattach a volume from an instance. DCNL Unmask the LUN on the storage system so the given intiator can no DCNL longer access it.'
def _is_clone_done(self, host_id, clone_op_id, volume_uuid): DCNL 'Check the status of a clone operation. DCNL Return True if done, False otherwise.'
def _clone_lun(self, host_id, src_path, dest_path, snap): DCNL 'Create a clone of a NetApp LUN. DCNL The clone initially consumes no space and is not space reserved.'
def _refresh_dfm_luns(self, host_id): DCNL 'Refresh the LUN list for one filer in DFM.'
def _destroy_lun(self, host_id, lun_path): DCNL 'Destroy a LUN on the filer.'
def _resize_volume(self, host_id, vol_name, new_size): DCNL 'Resize the volume by the amount requested.'
def _create_qtree(self, host_id, vol_name, qtree_name): DCNL 'Create a qtree the filer.'
def create_snapshot(self, snapshot): DCNL 'Driver entry point for creating a snapshot. DCNL This driver implements snapshots by using efficient single-file DCNL (LUN) cloning.'
def delete_snapshot(self, snapshot): DCNL 'Driver entry point for deleting a snapshot.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Driver entry point for creating a new volume from a snapshot. DCNL Many would call this "cloning" and in fact we use cloning to implement DCNL this feature.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def get_metadata_property(self, prop): DCNL 'Get the metadata property of a LUN.'
def _create_client(self, **kwargs): DCNL 'Instantiate a web services client. DCNL This method creates a "suds" client to make web services calls to the DCNL DFM server. Note that the WSDL file is quite large and may take DCNL a few seconds to parse.'
def _check_flags(self): DCNL 'Ensure that the flags we care about are set.'
def do_setup(self, context): DCNL 'Setup the NetApp Volume driver. DCNL Called one time by the manager after the driver is loaded. DCNL Validate the flags we care about and setup the suds (web services) DCNL client.'
def check_for_setup_error(self): DCNL 'Check that the driver is working and can communicate. DCNL Discovers the LUNs on the NetApp server.'
def create_volume(self, volume): DCNL 'Driver entry point for creating a new volume.'
def delete_volume(self, volume): DCNL 'Driver entry point for destroying existing volumes.'
def ensure_export(self, context, volume): DCNL 'Driver entry point to get the export info for an existing volume.'
def create_export(self, context, volume): DCNL 'Driver entry point to get the export info for a new volume.'
def remove_export(self, context, volume): DCNL 'Driver exntry point to remove an export for a volume. DCNL Since exporting is idempotent in this driver, we have nothing DCNL to do for unexporting.'
def initialize_connection(self, volume, connector): DCNL 'Driver entry point to attach a volume to an instance. DCNL Do the LUN masking on the storage system so the initiator can access DCNL the LUN on the target. Also return the iSCSI properties so the DCNL initiator can find the LUN. This implementation does not call DCNL _get_iscsi_properties() to get the properties because cannot store the DCNL LUN number in the database. We only find out what the LUN number will DCNL be during this method call so we construct the properties dictionary DCNL ourselves.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Driver entry point to unattach a volume from an instance. DCNL Unmask the LUN on the storage system so the given intiator can no DCNL longer access it.'
def create_snapshot(self, snapshot): DCNL 'Driver entry point for creating a snapshot. DCNL This driver implements snapshots by using efficient single-file DCNL (LUN) cloning.'
def delete_snapshot(self, snapshot): DCNL 'Driver entry point for deleting a snapshot.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Driver entry point for creating a new volume from a snapshot. DCNL Many would call this "cloning" and in fact we use cloning to implement DCNL this feature.'
def _get_qos_type(self, volume): DCNL 'Get the storage service type for a volume.'
def _add_lun_to_table(self, lun): DCNL 'Adds LUN to cache table.'
def _clone_lun(self, handle, new_name, extra_args): DCNL 'Clone LUN with the given handle to the new name.'
def _create_metadata_list(self, extra_args): DCNL 'Creates metadata from kwargs.'
def _get_lun_handle(self, name): DCNL 'Get the details for a LUN from our cache table.'
def _create_dict_from_meta(self, metadata): DCNL 'Creates dictionary from metadata array.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def _create_client(self, **kwargs): DCNL 'Instantiate a client for NetApp server. DCNL This method creates NetApp server client for api communication.'
def _do_custom_setup(self): DCNL 'Does custom setup depending on the type of filer.'
def _check_flags(self): DCNL 'Ensure that the flags we care about are set.'
def do_setup(self, context): DCNL 'Setup the NetApp Volume driver. DCNL Called one time by the manager after the driver is loaded. DCNL Validate the flags we care about and setup NetApp DCNL client.'
def check_for_setup_error(self): DCNL 'Check that the driver is working and can communicate. DCNL Discovers the LUNs on the NetApp server.'
def create_volume(self, volume): DCNL 'Driver entry point for creating a new volume.'
def delete_volume(self, volume): DCNL 'Driver entry point for destroying existing volumes.'
def ensure_export(self, context, volume): DCNL 'Driver entry point to get the export info for an existing volume.'
def create_export(self, context, volume): DCNL 'Driver entry point to get the export info for a new volume.'
def remove_export(self, context, volume): DCNL 'Driver exntry point to remove an export for a volume. DCNL Since exporting is idempotent in this driver, we have nothing DCNL to do for unexporting.'
def initialize_connection(self, volume, connector): DCNL 'Driver entry point to attach a volume to an instance. DCNL Do the LUN masking on the storage system so the initiator can access DCNL the LUN on the target. Also return the iSCSI properties so the DCNL initiator can find the LUN. This implementation does not call DCNL _get_iscsi_properties() to get the properties because cannot store the DCNL LUN number in the database. We only find out what the LUN number will DCNL be during this method call so we construct the properties dictionary DCNL ourselves.'
def create_snapshot(self, snapshot): DCNL 'Driver entry point for creating a snapshot. DCNL This driver implements snapshots by using efficient single-file DCNL (LUN) cloning.'
def delete_snapshot(self, snapshot): DCNL 'Driver entry point for deleting a snapshot.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Driver entry point for creating a new volume from a snapshot. DCNL Many would call this "cloning" and in fact we use cloning to implement DCNL this feature.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Driver entry point to unattach a volume from an instance. DCNL Unmask the LUN on the storage system so the given intiator can no DCNL longer access it.'
def _get_ontapi_version(self): DCNL 'Gets the supported ontapi version.'
def _create_lun_on_eligible_vol(self, name, size, metadata): DCNL 'Creates an actual lun on filer.'
def _get_avl_volume_by_size(self, size): DCNL 'Get the available volume by size.'
def _get_iscsi_service_details(self): DCNL 'Returns iscsi iqn.'
def _get_target_details(self): DCNL 'Gets the target portal details.'
def _create_lun_handle(self, metadata): DCNL 'Returns lun handle based on filer type.'
def _get_lun_list(self): DCNL 'Gets the list of luns on filer.'
def _extract_and_populate_luns(self, api_luns): DCNL 'Extracts the luns from api. DCNL Populates in the lun table.'
def _invoke_successfully(self, na_element, do_tunneling=False): DCNL 'Invoke the api for successful result. DCNL do_tunneling sets flag for tunneling.'
def _configure_tunneling(self, do_tunneling=False): DCNL 'Configures tunneling based on system type.'
def _is_naelement(self, elem): DCNL 'Checks if element is NetApp element.'
def _map_lun(self, name, initiator, initiator_type='iscsi', lun_id=None): DCNL 'Maps lun to the initiator. DCNL Returns lun id assigned.'
def _unmap_lun(self, path, initiator): DCNL 'Unmaps a lun from given initiator.'
def _find_mapped_lun_igroup(self, path, initiator, os=None): DCNL 'Find the igroup for mapped lun with initiator.'
def _get_or_create_igroup(self, initiator, initiator_type='iscsi', os='default'): DCNL 'Checks for an igroup for an initiator. DCNL Creates igroup if not found.'
def _get_igroup_by_initiator(self, initiator): DCNL 'Get igroups by initiator.'
def _check_allowed_os(self, os): DCNL 'Checks if the os type supplied is NetApp supported.'
def _create_igroup(self, igroup, igroup_type='iscsi', os_type='default'): DCNL 'Creates igoup with specified args.'
def _add_igroup_initiator(self, igroup, initiator): DCNL 'Adds initiators to the specified igroup.'
def _get_qos_type(self, volume): DCNL 'Get the storage service type for a volume.'
def _add_lun_to_table(self, lun): DCNL 'Adds LUN to cache table.'
def _clone_lun(self, name, new_name, space_reserved): DCNL 'Clone LUN with the given name to the new name.'
def _get_lun_by_args(self, **args): DCNL 'Retrives lun with specified args.'
def _get_lun_attr(self, name, attr): DCNL 'Get the attributes for a LUN from our cache table.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def _do_custom_setup(self): DCNL 'Does custom setup for ontap cluster.'
def _get_avl_volume_by_size(self, size): DCNL 'Get the available volume by size.'
def _get_target_details(self): DCNL 'Gets the target portal details.'
def _get_iscsi_service_details(self): DCNL 'Returns iscsi iqn.'
def _create_lun_handle(self, metadata): DCNL 'Returns lun handle based on filer type.'
def _get_lun_list(self): DCNL 'Gets the list of luns on filer.'
def _find_mapped_lun_igroup(self, path, initiator, os=None): DCNL 'Find the igroup for mapped lun with initiator.'
def _get_lun_map(self, path): DCNL 'Gets the lun map by lun path.'
def _get_igroup_by_initiator(self, initiator): DCNL 'Get igroups by initiator.'
def _clone_lun(self, name, new_name, space_reserved): DCNL 'Clone LUN with the given handle to the new name.'
def _get_lun_by_args(self, **args): DCNL 'Retrives lun with specified args.'
def _create_lun_meta(self, lun): DCNL 'Creates lun metadata dictionary.'
def _configure_tunneling(self, do_tunneling=False): DCNL 'Configures tunneling for ontap cluster.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def _do_custom_setup(self): DCNL 'Does custom setup depending on the type of filer.'
def _get_avl_volume_by_size(self, size): DCNL 'Get the available volume by size.'
def _check_vol_not_root(self, vol): DCNL 'Checks if a volume is not root.'
def _get_igroup_by_initiator(self, initiator): DCNL 'Get igroups by initiator.'
def _get_target_details(self): DCNL 'Gets the target portal details.'
def _get_iscsi_service_details(self): DCNL 'Returns iscsi iqn.'
def _create_lun_handle(self, metadata): DCNL 'Returns lun handle based on filer type.'
def _get_lun_list(self): DCNL 'Gets the list of luns on filer.'
def _get_vol_luns(self, vol_name): DCNL 'Gets the luns for a volume.'
def _find_mapped_lun_igroup(self, path, initiator, os=None): DCNL 'Find the igroup for mapped lun with initiator.'
def _clone_lun(self, name, new_name, space_reserved): DCNL 'Clone LUN with the given handle to the new name.'
def _set_space_reserve(self, path, enable): DCNL 'Sets the space reserve info.'
def _check_clone_status(self, clone_id, vol_uuid, name, new_name): DCNL 'Checks for the job till completed.'
def _get_lun_by_args(self, **args): DCNL 'Retrives lun with specified args.'
def _create_lun_meta(self, lun): DCNL 'Creates lun metadata dictionary.'
def _configure_tunneling(self, do_tunneling=False): DCNL 'Configures tunneling for 7 mode.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def get_transport_type(self): DCNL 'Get the transport type protocol.'
def set_transport_type(self, transport_type): DCNL 'Set the transport type protocol for api. DCNL Supports http and https transport types.'
def get_style(self): DCNL 'Get the authorization style for communicating with the server.'
def set_style(self, style): DCNL 'Set the authorization style for communicating with the server. DCNL Supports basic_auth for now. DCNL Certificate_auth mode to be done.'
def get_server_type(self): DCNL 'Get the target server type.'
def set_server_type(self, server_type): DCNL 'Set the target server type. DCNL Supports filer and dfm server types.'
def set_api_version(self, major, minor): DCNL 'Set the api version.'
def get_api_version(self): DCNL 'Gets the api version.'
def set_port(self, port): DCNL 'Set the server communication port.'
def get_port(self): DCNL 'Get the server communication port.'
def set_timeout(self, seconds): DCNL 'Sets the timeout in seconds'
def get_timeout(self): DCNL 'Gets the timeout in seconds if set.'
def get_vfiler(self): DCNL 'Get the vfiler tunneling.'
def set_vfiler(self, vfiler): DCNL 'Set the vfiler tunneling.'
def get_vserver(self): DCNL 'Get the vserver for tunneling.'
def set_vserver(self, vserver): DCNL 'Set the vserver for tunneling.'
def set_username(self, username): DCNL 'Set the username for authentication.'
def set_password(self, password): DCNL 'Set the password for authentication.'
def invoke_elem(self, na_element): DCNL 'Invoke the api on the server.'
def invoke_successfully(self, na_element): DCNL 'Invokes api and checks execution status as success.'
def _create_request(self, na_element): DCNL 'Creates request in the desired format.'
def _parse_response(self, response): DCNL 'Get the NaElement for the response.'
def _get_result(self, response): DCNL 'Gets the call result.'
def __init__(self, name): DCNL 'Name of the element or etree.Element.'
def get_name(self): DCNL 'Returns the tag name of the element.'
def set_content(self, text): DCNL 'Set the text for the element.'
def get_content(self): DCNL 'Get the text for the element.'
def add_attr(self, name, value): DCNL 'Add the attribute to the element.'
def add_attrs(self, **attrs): DCNL 'Add multiple attributes to the element.'
def add_child_elem(self, na_element): DCNL 'Add the child element to the element.'
def get_child_by_name(self, name): DCNL 'Get the child element by the tag name.'
def get_child_content(self, name): DCNL 'Get the content of the child.'
def get_children(self): DCNL 'Get the children for the element.'
def has_attr(self, name): DCNL 'Checks whether element has attribute.'
def get_attr(self, name): DCNL 'Get the attribute with the given name.'
def get_attr_names(self): DCNL 'Returns the list of attribute names.'
def add_new_child(self, name, content, convert=False): DCNL 'Add child with tag name and context. DCNL Convert replaces entity refs to chars.'
@staticmethod DCNL def _convert_entity_refs(text): DCNL 'Converts entity refs to chars DCNL neccessary to handle etree auto conversions.'
@staticmethod DCNL def create_node_with_children(node, **children): DCNL 'Creates and returns named node with children.'
def add_node_with_children(self, node, **children): DCNL 'Creates named node with children.'
def to_string(self, pretty=False, method='xml', encoding='UTF-8'): DCNL 'Prints the element to string'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot.'
def create_snapshot(self, snapshot): DCNL 'Creates a snapshot.'
def delete_snapshot(self, snapshot): DCNL 'Deletes a snapshot.'
def _check_dfm_flags(self): DCNL 'Raises error if any required configuration flag for OnCommand proxy DCNL is missing.'
def _get_client(self): DCNL 'Creates SOAP _client for ONTAP-7 DataFabric Service.'
def _get_volume_location(self, volume_id): DCNL 'Returns NFS mount address as <nfs_ip_address>:<nfs_mount_dir>'
def _clone_volume(self, volume_name, clone_name, volume_id): DCNL 'Clones mounted volume with OnCommand proxy API'
def _wait_for_clone_finished(self, clone_operation_id, host_id): DCNL 'Polls ONTAP7 for clone status. Returns once clone is finished. DCNL :param clone_operation_id: Identifier of ONTAP clone operation'
def _get_provider_location(self, volume_id): DCNL 'Returns provider location for given volume DCNL :param volume_id:'
def _get_host_ip(self, volume_id): DCNL 'Returns IP address for the given volume'
def _get_export_path(self, volume_id): DCNL 'Returns NFS export path for the given volume'
def _get_host_id(self, volume_id): DCNL 'Returns ID of the ONTAP-7 host'
def _get_full_export_path(self, volume_id, host_id): DCNL 'Returns full path to the NFS share, e.g. /vol/vol0/home'
def _volume_not_present(self, nfs_mount, volume_name): DCNL 'Check if volume exists'
def _get_volume_path(self, nfs_share, volume_name): DCNL 'Get volume path (local fs path) for given volume name on given nfs DCNL share DCNL @param nfs_share string, example 172.18.194.100:/var/nfs DCNL @param volume_name string, DCNL example volume-91ee65ec-c473-4391-8c09-162b00c68a8c'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met'
def _clone_volume(self, volume_name, clone_name, volume_id): DCNL 'Clones mounted volume with NetApp Cloud Services'
def _check_flags(self): DCNL 'Raises error if any required configuration flag for NetApp Cloud DCNL Webservices is missing.'
def _get_client(self): DCNL 'Creates SOAP _client for NetApp Cloud service.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met'
def _clone_volume(self, volume_name, clone_name, volume_id): DCNL 'Clones mounted volume on NetApp filer'
def _check_flags(self): DCNL 'Raises error if any required configuration flag for NetApp DCNL filer is missing.'
def _get_client(self): DCNL 'Creates NetApp api client.'
def _do_custom_setup(self, client): DCNL 'Do the customized set up on client if any for different types'
def _is_naelement(self, elem): DCNL 'Checks if element is NetApp element'
def _invoke_successfully(self, na_element, vserver=None): DCNL 'Invoke the api for successful result. DCNL Vserver implies vserver api else filer/Cluster api.'
def _get_ontapi_version(self): DCNL 'Gets the supported ontapi version.'
def _do_custom_setup(self, client): DCNL 'Do the customized set up on client for cluster mode'
def _clone_volume(self, volume_name, clone_name, volume_id): DCNL 'Clones mounted volume on NetApp Cluster'
def _get_if_info_by_ip(self, ip): DCNL 'Gets the network interface info by ip.'
def _get_vol_by_junc_vserver(self, vserver, junction): DCNL 'Gets the volume by junction path and vserver'
def _clone_file(self, volume, src_path, dest_path, vserver=None): DCNL 'Clones file on vserver'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def _do_custom_setup(self, client): DCNL 'Do the customized set up on client if any for 7 mode'
def _clone_volume(self, volume_name, clone_name, volume_id): DCNL 'Clones mounted volume with NetApp filer'
def _get_actual_path_for_export(self, export_path): DCNL 'Gets the actual path on the filer for export path'
def _start_clone(self, src_path, dest_path): DCNL 'Starts the clone operation. DCNL Returns the clone-id'
def _wait_for_clone_finish(self, clone_op_id, vol_uuid): DCNL 'Waits till a clone operation is complete or errored out.'
def _clear_clone(self, clone_id): DCNL 'Clear the clone information. DCNL Invoke this in case of failed clone.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met'
def get_volume_stats(self, refresh=False): DCNL 'Return the current state of the volume service. If \'refresh\' is DCNL True, run the update first.'
def create_volume(self, volume): DCNL 'Creates a logical volume.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot.'
def delete_volume(self, volume): DCNL 'Deletes a logical volume.'
def create_snapshot(self, snapshot): DCNL 'Creates an rbd snapshot'
def delete_snapshot(self, snapshot): DCNL 'Deletes an rbd snapshot'
def local_path(self, volume): DCNL 'Returns the path of the rbd volume.'
def ensure_export(self, context, volume): DCNL 'Synchronously recreates an export for a logical volume.'
def create_export(self, context, volume): DCNL 'Exports the volume'
def remove_export(self, context, volume): DCNL 'Removes an export for a logical volume'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met'
def create_volume(self, volume): DCNL 'Creates a sheepdog volume'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a sheepdog volume from a snapshot.'
def delete_volume(self, volume): DCNL 'Deletes a logical volume'
def create_snapshot(self, snapshot): DCNL 'Creates a sheepdog snapshot'
def delete_snapshot(self, snapshot): DCNL 'Deletes a sheepdog snapshot'
def ensure_export(self, context, volume): DCNL 'Safely and synchronously recreates an export for a logical volume'
def create_export(self, context, volume): DCNL 'Exports the volume'
def remove_export(self, context, volume): DCNL 'Removes an export for a logical volume'
def do_setup(self, ctxt): DCNL 'Check that we have all configuration details from the storage.'
def check_for_setup_error(self): DCNL 'Ensure that the flags are set properly.'
def ensure_export(self, ctxt, volume): DCNL 'Check that the volume exists on the storage. DCNL The system does not "export" volumes as a Linux iSCSI target does, DCNL and therefore we just check that the volume exists on the storage.'
def _add_chapsecret_to_host(self, host_name): DCNL 'Generate and store a randomly-generated CHAP secret for the host.'
def _get_chap_secret_for_host(self, host_name): DCNL 'Return the CHAP secret for the given host.'
def _connector_to_hostname_prefix(self, connector): DCNL 'Translate connector info to storage system host name. DCNL Translate a host\'s name and IP to the prefix of its hostname on the DCNL storage subsystem.  We create a host name host name from the host and DCNL IP address, replacing any invalid characters (at most 55 characters), DCNL and adding a random 8-character suffix to avoid collisions. The total DCNL length should be at most 63 characters.'
def _get_host_from_connector(self, connector): DCNL 'List the hosts defined in the storage. DCNL Return the host name with the given connection info, or None if there DCNL is no host fitting that information.'
def _create_host(self, connector): DCNL 'Create a new host on the storage system. DCNL We create a host name and associate it with the given connection DCNL information.'
def _get_hostvdisk_mappings(self, host_name): DCNL 'Return the defined storage mappings for a host.'
def _map_vol_to_host(self, volume_name, host_name): DCNL 'Create a mapping between a volume to a host.'
def _delete_host(self, host_name): DCNL 'Delete a host on the storage system.'
def initialize_connection(self, volume, connector): DCNL 'Perform the necessary work so that an iSCSI/FC connection can DCNL be made. DCNL To be able to create an iSCSI/FC connection from a given host to a DCNL volume, we must: DCNL 1. Translate the given iSCSI name or WWNN to a host name DCNL 2. Create new host on the storage system if it does not yet exist DCNL 3. Map the volume to the host if it is not already done DCNL 4. Return the connection information for relevant nodes (in the DCNL proper I/O group)'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Cleanup after an iSCSI connection has been terminated. DCNL When we clean up a terminated connection between a given connector DCNL and volume, we: DCNL 1. Translate the given connector to a host name DCNL 2. Remove the volume-to-host mapping if it exists DCNL 3. Delete the host if it has no more mappings (hosts are created DCNL automatically by this driver when mappings are created)'
def _get_vdisk_attributes(self, vdisk_name): DCNL 'Return vdisk attributes, or None if vdisk does not exist DCNL Exception is raised if the information from system can not be DCNL parsed/matched to a single vdisk.'
def _get_vdisk_fc_mappings(self, vdisk_name): DCNL 'Return FlashCopy mappings that this vdisk is associated with.'
def _create_vdisk(self, name, size, units, opts): DCNL 'Create a new vdisk.'
def _run_flashcopy(self, source, target, full_copy=True): DCNL 'Create a FlashCopy mapping from the source to the target.'
def _create_copy(self, src_vdisk, tgt_vdisk, full_copy, opts, src_id, from_vol): DCNL 'Create a new snapshot using FlashCopy.'
def _is_vdisk_defined(self, vdisk_name): DCNL 'Check if vdisk is defined.'
def _delete_vdisk(self, name, force): DCNL 'Deletes existing vdisks. DCNL It is very important to properly take care of mappings before deleting DCNL the disk: DCNL 1. If no mappings, then it was a vdisk, and can be deleted DCNL 2. If it is the source of a flashcopy mapping and copy_rate is 0, then DCNL it is a vdisk that has a snapshot.  If the force flag is set, DCNL delete the mapping and the vdisk, otherwise set the mapping to DCNL copy and wait (this will allow users to delete vdisks that have DCNL snapshots if/when the upper layers allow it). DCNL 3. If it is the target of a mapping and copy_rate is 0, it is a DCNL snapshot, and we should properly stop the mapping and delete. DCNL 4. If it is the source/target of a mapping and copy_rate is not 0, it DCNL is a clone or vdisk created from a snapshot.  We wait for the copy DCNL to complete (the mapping will be autodeleted) and then delete the DCNL vdisk.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If we haven\'t gotten stats yet or \'refresh\' is True, DCNL run update the stats first.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def _execute_command_and_parse_attributes(self, ssh_cmd): DCNL 'Execute command on the Storwize/SVC and parse attributes. DCNL Exception is raised if the information from the system DCNL can not be obtained.'
def _get_hdr_dic(self, header, row, delim): DCNL 'Return CLI row data as a dictionary indexed by names from header. DCNL string. The strings are converted to columns using the delimiter in DCNL delim.'
def _driver_assert(self, assert_condition, exception_message): DCNL 'Internal assertion mechanism for CLI output.'
def _check_flags(self): DCNL 'Sanity check to ensure we have required options set.'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Clone an existing volume.'
@lockutils.synchronized('3par-vol', 'cinder-', True) DCNL def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot. DCNL TODO: support using the size from the user.'
@lockutils.synchronized('3par-attach', 'cinder-', True) DCNL def initialize_connection(self, volume, connector): DCNL 'Assigns the volume to a server. DCNL Assign any created volume to a compute node/host so that it can be DCNL used from that host. DCNL This driver returns a driver_volume_type of \'iscsi\'. DCNL The format of the driver data is defined in _get_iscsi_properties. DCNL Example return value: DCNL \'driver_volume_type\': \'iscsi\' DCNL \'data\': { DCNL \'target_discovered\': True, DCNL \'target_iqn\': \'iqn.2010-10.org.openstack:volume-00000001\', DCNL \'target_protal\': \'127.0.0.1:3260\', DCNL \'volume_id\': 1, DCNL Steps to export a volume on 3PAR DCNL * Get the 3PAR iSCSI iqn DCNL * Create a host on the 3par DCNL * create vlun on the 3par'
@lockutils.synchronized('3par-attach', 'cinder-', True) DCNL def terminate_connection(self, volume, connector, force): DCNL 'Driver entry point to unattach a volume from an instance.'
def _create_host(self, volume, connector): DCNL 'This is a 3PAR host entry for exporting volumes DCNL via active VLUNs.'
def _get_3par_vol_name(self, volume_id): DCNL 'Converts the openstack volume id from DCNL ecffc30f-98cb-4cf5-85ee-d7309cc17cd2 DCNL to DCNL osv-7P.DD5jLTPWF7tcwnMF80g DCNL We convert the 128 bits of the uuid into a 24character long DCNL base64 encoded string to ensure we don\'t exceed the maximum DCNL allowed 31 character name limit on 3Par DCNL We strip the padding \'=\' and replace + with . DCNL and / with -'
def _cli_run(self, verb, cli_args): DCNL 'Runs a CLI command over SSH, without doing any result parsing.'
def _ssh_execute(self, ssh, cmd, check_exit_code=True): DCNL 'We have to do this in order to get CSV output DCNL from the CLI command.   We first have to issue DCNL a command to tell the CLI that we want the output DCNL to be formatted in CSV, then we issue the real DCNL command.'
def _safe_hostname(self, hostname): DCNL 'We have to use a safe hostname length DCNL for 3PAR host names.'
def create_vlun(self, volume, host, client): DCNL 'In order to export a volume on a 3PAR box, we have to DCNL create a VLUN.'
@lockutils.synchronized('3par', 'cinder-', True) DCNL def create_volume_from_snapshot(self, volume, snapshot, client): DCNL 'Creates a volume from a snapshot. DCNL TODO: support using the size from the user.'
def _check_flags(self): DCNL 'Sanity check to ensure we have required options set.'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met.'
@lockutils.synchronized('3par-vol', 'cinder-', True) DCNL def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot. DCNL TODO: support using the size from the user.'
@lockutils.synchronized('3par-attach', 'cinder-', True) DCNL def initialize_connection(self, volume, connector): DCNL 'Assigns the volume to a server. DCNL Assign any created volume to a compute node/host so that it can be DCNL used from that host. DCNL The  driver returns a driver_volume_type of \'fibre_channel\'. DCNL The target_wwn can be a single entry or a list of wwns that DCNL correspond to the list of remote wwn(s) that will export the volume. DCNL Example return values: DCNL \'driver_volume_type\': \'fibre_channel\' DCNL \'data\': { DCNL \'target_discovered\': True, DCNL \'target_lun\': 1, DCNL \'target_wwn\': \'1234567890123\', DCNL or DCNL \'driver_volume_type\': \'fibre_channel\' DCNL \'data\': { DCNL \'target_discovered\': True, DCNL \'target_lun\': 1, DCNL \'target_wwn\': [\'1234567890123\', \'0987654321321\'], DCNL Steps to export a volume on 3PAR DCNL * Create a host on the 3par with the target wwn DCNL * Create a VLUN for that HOST with the volume we want to export.'
@lockutils.synchronized('3par-attach', 'cinder-', True) DCNL def terminate_connection(self, volume, connector, force): DCNL 'Driver entry point to unattach a volume from an instance.'
def _create_host(self, volume, connector): DCNL 'This is a 3PAR host entry for exporting volumes DCNL via active VLUNs.'
def _cliq_run(self, verb, cliq_args, check_exit_code=True): DCNL 'Runs a CLIQ command over SSH, without doing any result parsing'
def _cliq_run_xml(self, verb, cliq_args, check_cliq_result=True): DCNL 'Runs a CLIQ command over SSH, parsing and checking the output'
def _cliq_get_cluster_info(self, cluster_name): DCNL 'Queries for info about the cluster (including IP)'
def _cliq_get_cluster_vip(self, cluster_name): DCNL 'Gets the IP on which a cluster shares iSCSI volumes'
def _cliq_get_volume_info(self, volume_name): DCNL 'Gets the volume info, including IQN'
def create_volume(self, volume): DCNL 'Creates a volume.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Creates a volume from a snapshot.'
def create_snapshot(self, snapshot): DCNL 'Creates a snapshot.'
def delete_volume(self, volume): DCNL 'Deletes a volume.'
def initialize_connection(self, volume, connector): DCNL 'Assigns the volume to a server. DCNL Assign any created volume to a compute node/host so that it can be DCNL used from that host. HP VSA requires a volume to be assigned DCNL to a server. DCNL This driver returns a driver_volume_type of \'iscsi\'. DCNL The format of the driver data is defined in _get_iscsi_properties. DCNL Example return value: DCNL \'driver_volume_type\': \'iscsi\' DCNL \'data\': { DCNL \'target_discovered\': True, DCNL \'target_iqn\': \'iqn.2010-10.org.openstack:volume-00000001\', DCNL \'target_protal\': \'127.0.0.1:3260\', DCNL \'volume_id\': 1,'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Unassign the volume from the host.'
def ensure_export(self, context, volume): DCNL 'Synchronously recreates an export for a logical volume.'
def create_export(self, context, volume): DCNL 'Exports the volume.'
def remove_export(self, context, volume): DCNL 'Removes an export for a logical volume.'
def check_for_setup_error(self): DCNL 'Returns an error if prerequisites aren\'t met.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Create a cloen of the specified volume.'
def _get_target_groups(self): DCNL 'Gets list of target groups from host.'
def create_volume(self, volume): DCNL 'Creates a volume.'
def delete_volume(self, volume): DCNL 'Deletes a volume.'
def ensure_export(self, context, volume): DCNL 'Synchronously recreates an export for a logical volume.'
def remove_export(self, context, volume): DCNL 'Removes an export for a logical volume.'
def _collect_lines(self, data): DCNL 'Split lines from data into an array, trimming them'
def _get_prefixed_values(self, data, prefix): DCNL 'Collect lines which start with prefix; with trimming'
def _generate_vpsa_cmd(self, cmd, **kwargs): DCNL 'Generate command to be sent to VPSA.'
def ensure_connection(self, cmd=None): DCNL 'Retrieve access key for VPSA connection.'
def send_cmd(self, cmd, **kwargs): DCNL 'Send command to VPSA Controller.'
def do_setup(self, context): DCNL 'Any initialization the volume driver does while starting. DCNL Establishes initial connection with VPSA and retrieves access_key.'
def check_for_setup_error(self): DCNL 'Returns an error (exception) if prerequisites aren\'t met.'
def local_path(self, volume): DCNL 'Return local path to existing local volume.'
def _xml_parse_helper(self, xml_tree, first_level, search_tuple, first=True): DCNL 'Helper for parsing VPSA\'s XML output. DCNL Returns single item if first==True or list for multiple selection. DCNL If second argument in search_tuple is None - returns all items with DCNL appropriate key.'
def _get_vpsa_volume_name(self, name): DCNL 'Return VPSA\'s name for the volume.'
def _get_active_controller_details(self): DCNL 'Return details of VPSA\'s active controller.'
def _get_server_name(self, initiator): DCNL 'Return VPSA\'s name for server object with given IQN.'
def _create_vpsa_server(self, initiator): DCNL 'Create server object within VPSA (if doesn\'t exist).'
def create_volume(self, volume): DCNL 'Create volume.'
def delete_volume(self, volume): DCNL 'Delete volume. DCNL Return ok if doesn\'t exist. Auto detach from all servers.'
def create_export(self, context, volume): DCNL 'Irrelevant for VPSA volumes. Export created during attachment.'
def ensure_export(self, context, volume): DCNL 'Irrelevant for VPSA volumes. Export created during attachment.'
def remove_export(self, context, volume): DCNL 'Irrelevant for VPSA volumes. Export removed during detach.'
def initialize_connection(self, volume, connector): DCNL 'Attach volume to initiator/host. DCNL During this call VPSA exposes volume to particular Initiator. It also DCNL creates a \'server\' entity for Initiator (if it was not created before) DCNL All necessary connection information is returned, including auth data. DCNL Connection data (target, LUN) is not stored in the DB.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Detach volume from the initiator.'
def copy_image_to_volume(self, context, volume, image_service, image_id): DCNL 'Fetch the image from image_service and write it to the volume.'
def copy_volume_to_image(self, context, volume, image_service, image_meta): DCNL 'Copy the volume to the specified image.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def do_setup(self, context): DCNL 'Setup the Windows Volume driver. DCNL Called one time by the manager after the driver is loaded. DCNL Validate the flags we care about'
def check_for_setup_error(self): DCNL 'Check that the driver is working and can communicate.'
def initialize_connection(self, volume, connector): DCNL 'Driver entry point to attach a volume to an instance.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Driver entry point to unattach a volume from an instance. DCNL Unmask the LUN on the storage system so the given intiator can no DCNL longer access it.'
def create_volume(self, volume): DCNL 'Driver entry point for creating a new volume.'
def delete_volume(self, volume): DCNL 'Driver entry point for destroying existing volumes.'
def create_snapshot(self, snapshot): DCNL 'Driver entry point for creating a snapshot.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Driver entry point for exporting snapshots as volumes.'
def delete_snapshot(self, snapshot): DCNL 'Driver entry point for deleting a snapshot.'
def _do_export(self, _ctx, volume, ensure=False): DCNL 'Do all steps to get disk exported as LUN 0 at separate target. DCNL :param volume: reference of volume to be exported DCNL :param ensure: if True, ignore errors caused by already existing DCNL resources DCNL :return: iscsiadm-formatted provider location string'
def ensure_export(self, context, volume): DCNL 'Driver entry point to get the export info for an existing volume.'
def create_export(self, context, volume): DCNL 'Driver entry point to get the export info for a new volume.'
def remove_export(self, context, volume): DCNL 'Driver exntry point to remove an export for a volume.'
def copy_image_to_volume(self, context, volume, image_service, image_id): DCNL 'Fetch the image from image_service and write it to the volume.'
def copy_volume_to_image(self, context, volume, image_service, image_meta): DCNL 'Copy the volume to the specified image.'
def _login(self): DCNL 'Login and Session Handler.'
def _set_group(self, reply): DCNL 'Set effective group.'
def _get_group_id(self, groupName, loginResult): DCNL 'Map group name to group ID.'
def _esm(self, url=False, data=None): DCNL '_esm represent the entry point to send requests to ESM Appliance. DCNL Send the HTTPS call, get response in JSON DCNL convert response into Python Object and return it.'
def _configure(self, data): DCNL 'In charge of all commands into \'configure\'.'
def _get_volume_info(self, lvname): DCNL 'Fetch information for a given Volume or Snapshot.'
def _get_lun_address(self, volume_name): DCNL 'Return AoE Address for a given Volume.'
def create_lun(self, volume_name, volume_size, repository): DCNL 'Create LUN on Coraid Backend Storage.'
def delete_lun(self, volume_name): DCNL 'Delete LUN.'
def create_snapshot(self, volume_name, snapshot_name): DCNL 'Create Snapshot.'
def delete_snapshot(self, snapshot_name): DCNL 'Delete Snapshot.'
def create_volume_from_snapshot(self, snapshot_name, volume_name, repository): DCNL 'Create a LUN from a Snapshot.'
def do_setup(self, context): DCNL 'Initialize the volume driver.'
def check_for_setup_error(self): DCNL 'Return an error if prerequisites aren\'t met.'
def _get_repository(self, volume_type): DCNL 'Return the ESM Repository from the Volume Type. DCNL The ESM Repository is stored into a volume_type_extra_specs key.'
def create_volume(self, volume): DCNL 'Create a Volume.'
def delete_volume(self, volume): DCNL 'Delete a Volume.'
def create_snapshot(self, snapshot): DCNL 'Create a Snapshot.'
def delete_snapshot(self, snapshot): DCNL 'Delete a Snapshot.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Create a Volume from a Snapshot.'
def initialize_connection(self, volume, connector): DCNL 'Return connection information.'
def get_volume_stats(self, refresh=False): DCNL 'Return Volume Stats.'
def _issue_api_request(self, method_name, params): DCNL 'All API requests to SolidFire device go through this method. DCNL Simple json-rpc web based API calls. DCNL each call takes a set of paramaters (dict) DCNL and returns results in a dict as well.'
def _get_volumes_by_sfaccount(self, account_id): DCNL 'Get all volumes on cluster for specified account.'
def _get_sfaccount_by_name(self, sf_account_name): DCNL 'Get SolidFire account object by name.'
def _get_sf_account_name(self, project_id): DCNL 'Build the SolidFire account name to use.'
def _create_sfaccount(self, project_id): DCNL 'Create account on SolidFire device if it doesn\'t already exist. DCNL We\'re first going to check if the account already exits, if it does DCNL just return it.  If not, then create it.'
def _get_cluster_info(self): DCNL 'Query the SolidFire cluster for some property info.'
def _do_export(self, volume): DCNL 'Gets the associated account, retrieves CHAP info and updates.'
def _generate_random_string(self, length): DCNL 'Generates random_string to use for CHAP password.'
def _get_model_info(self, sfaccount, sf_volume_id): DCNL 'Gets the connection info for specified account and volume.'
def _do_clone_volume(self, src_uuid, src_project_id, v_ref): DCNL 'Create a clone of an existing volume. DCNL Currently snapshots are the same as clones on the SF cluster. DCNL Due to the way the SF cluster works there\'s no loss in efficiency DCNL or space usage between the two.  The only thing different right DCNL now is the restore snapshot functionality which has not been DCNL implemented in the pre-release version of the SolidFire Cluster.'
def create_volume(self, volume): DCNL 'Create volume on SolidFire device. DCNL The account is where CHAP settings are derived from, volume is DCNL created and exported.  Note that the new volume is immediately ready DCNL for use. DCNL One caveat here is that an existing user account must be specified DCNL in the API call to create a new volume.  We use a set algorithm to DCNL determine account info based on passed in cinder volume object.  First DCNL we check to see if the account already exists (and use it), or if it DCNL does not already exist, we\'ll go ahead and create it.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Create a clone of an existing volume.'
def delete_volume(self, volume): DCNL 'Delete SolidFire Volume from device. DCNL SolidFire allows multipe volumes with same name, DCNL volumeID is what\'s guaranteed unique.'
def ensure_export(self, context, volume): DCNL 'Verify the iscsi export info.'
def create_export(self, context, volume): DCNL 'Setup the iscsi export info.'
def delete_snapshot(self, snapshot): DCNL 'Delete the specified snapshot from the SolidFire cluster.'
def create_snapshot(self, snapshot): DCNL 'Create a snapshot of a volume on the SolidFire cluster. DCNL Note that for SolidFire Clusters currently there is no snapshot DCNL implementation.  Due to the way SF does cloning there\'s no performance DCNL hit or extra space used.  The only thing that\'s lacking from this is DCNL the abilit to restore snaps. DCNL After GA a true snapshot implementation will be available with DCNL restore at which time we\'ll rework this appropriately.'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Create a volume from the specified snapshot.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update first. DCNL The name is a bit misleading as DCNL the majority of the data here is cluster DCNL data'
def _update_cluster_status(self): DCNL 'Retrieve status info for the Cluster.'
def check_for_setup_error(self): DCNL 'Just to override parent behavior.'
def delete_snapshot(self, snapshot): DCNL 'Do nothing for this driver, but allow manager to handle deletion DCNL of snapshot in error state.'
def _create_sparsed_file(self, path, size): DCNL 'Creates file with 0 disk usage.'
def _create_regular_file(self, path, size): DCNL 'Creates regular file of given size. Takes a lot of time for large DCNL files.'
def _set_rw_permissions_for_all(self, path): DCNL 'Sets 666 permissions for the path.'
def local_path(self, volume): DCNL 'Get volume path (mounted locally fs path) for given volume DCNL :param volume: volume reference'
def _path_exists(self, path): DCNL 'Check for existence of given path.'
def _get_hash_str(self, base_str): DCNL 'returns string that represents hash of base_str DCNL (in a hex format).'
def do_setup(self, context): DCNL 'Any initialization the volume driver does while starting'
def create_volume(self, volume): DCNL 'Creates a volume'
def delete_volume(self, volume): DCNL 'Deletes a logical volume.'
def ensure_export(self, ctx, volume): DCNL 'Synchronously recreates an export for a logical volume.'
def create_export(self, ctx, volume): DCNL 'Exports the volume. Can optionally return a Dictionary of changes DCNL to the volume object to be persisted.'
def remove_export(self, ctx, volume): DCNL 'Removes an export for a logical volume.'
def initialize_connection(self, volume, connector): DCNL 'Allow connection to connector and return connection info.'
def terminate_connection(self, volume, connector, **kwargs): DCNL 'Disallow connection from connector'
def _do_create_volume(self, volume): DCNL 'Create a volume on given nfs_share DCNL :param volume: volume reference'
def _ensure_shares_mounted(self): DCNL 'Look for NFS shares in the flags and tries to mount them locally'
def _ensure_share_mounted(self, nfs_share): DCNL 'Mount NFS share DCNL :param nfs_share:'
def _find_share(self, volume_size_for): DCNL 'Choose NFS share among available ones for given volume size. Current DCNL implementation looks for greatest capacity DCNL :param volume_size_for: int size in Gb'
def _get_mount_point_for_share(self, nfs_share): DCNL ':param nfs_share: example 172.18.194.100:/var/nfs'
def _get_available_capacity(self, nfs_share): DCNL 'Calculate available space on the NFS share DCNL :param nfs_share: example 172.18.194.100:/var/nfs'
def _mount_nfs(self, nfs_share, mount_path, ensure=False): DCNL 'Mount NFS share to mount path'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def _update_volume_status(self): DCNL 'Retrieve status info from volume group.'
def check_for_setup_error(self): DCNL 'Verify that the volume for our zvols exists. DCNL :raise: :py:exc:`LookupError`'
@staticmethod DCNL def _get_zvol_name(volume_name): DCNL 'Return zvol name that corresponds given volume name.'
@staticmethod DCNL def _get_target_name(volume_name): DCNL 'Return iSCSI target name to access volume.'
@staticmethod DCNL def _get_target_group_name(volume_name): DCNL 'Return Nexenta iSCSI target group name for volume.'
def create_volume(self, volume): DCNL 'Create a zvol on appliance. DCNL :param volume: volume reference'
def delete_volume(self, volume): DCNL 'Destroy a zvol on appliance. DCNL :param volume: volume reference'
def create_snapshot(self, snapshot): DCNL 'Create snapshot of existing zvol on appliance. DCNL :param snapshot: shapshot reference'
def create_volume_from_snapshot(self, volume, snapshot): DCNL 'Create new volume from other\'s snapshot on appliance. DCNL :param volume: reference of volume to be created DCNL :param snapshot: reference of source snapshot'
def delete_snapshot(self, snapshot): DCNL 'Delete volume\'s snapshot on appliance. DCNL :param snapshot: shapshot reference'
def local_path(self, volume): DCNL 'Return local path to existing local volume. DCNL We never have local volumes, so it raises NotImplementedError. DCNL :raise: :py:exc:`NotImplementedError`'
def _do_export(self, _ctx, volume, ensure=False): DCNL 'Do all steps to get zvol exported as LUN 0 at separate target. DCNL :param volume: reference of volume to be exported DCNL :param ensure: if True, ignore errors caused by already existing DCNL resources DCNL :return: iscsiadm-formatted provider location string'
def create_export(self, _ctx, volume): DCNL 'Create new export for zvol. DCNL :param volume: reference of volume to be exported DCNL :return: iscsiadm-formatted provider location string'
def ensure_export(self, _ctx, volume): DCNL 'Recreate parts of export if necessary. DCNL :param volume: reference of volume to be exported'
def remove_export(self, _ctx, volume): DCNL 'Destroy all resources created to export zvol. DCNL :param volume: reference of volume to be unexported'
def copy_image_to_volume(self, context, volume, image_service, image_id): DCNL 'Fetch the image from image_service and write it to the volume.'
def copy_volume_to_image(self, context, volume, image_service, image_meta): DCNL 'Copy the volume to the specified image.'
def create_cloned_volume(self, volume, src_vref): DCNL 'Creates a clone of the specified volume.'
def get_volume_stats(self, refresh=False): DCNL 'Get volume status. DCNL If \'refresh\' is True, run update the stats first.'
def _update_volume_status(self): DCNL 'Retrieve status info for Nexenta device.'
def __init__(self, volume_opts, config_group=None): DCNL 'This takes care of grafting the implementation\'s config DCNL values into the config group'
def __init__(self, volume_driver=None, service_name=None, *args, **kwargs): DCNL 'Load the driver from the one specified in args, or from flags.'
def init_host(self): DCNL 'Do any initialization that needs to be run if this is a DCNL standalone service.'
def create_volume(self, context, volume_id, request_spec=None, filter_properties=None, allow_reschedule=True, snapshot_id=None, image_id=None, source_volid=None): DCNL 'Creates and exports the volume.'
def _reschedule_or_reraise(self, context, volume_id, exc_info, snapshot_id, image_id, request_spec, filter_properties, allow_reschedule): DCNL 'Try to re-schedule the create or re-raise the original error to DCNL error out the volume.'
def _reschedule(self, context, request_spec, filter_properties, volume_id, scheduler_method, method_args, exc_info=None): DCNL 'Attempt to re-schedule a volume operation.'
def delete_volume(self, context, volume_id): DCNL 'Deletes and unexports volume.'
def create_snapshot(self, context, volume_id, snapshot_id): DCNL 'Creates and exports the snapshot.'
def delete_snapshot(self, context, snapshot_id): DCNL 'Deletes and unexports snapshot.'
def attach_volume(self, context, volume_id, instance_uuid, mountpoint): DCNL 'Updates db to show volume is attached'
def detach_volume(self, context, volume_id): DCNL 'Updates db to show volume is detached'
def _copy_image_to_volume(self, context, volume, image_service, image_id): DCNL 'Downloads Glance image to the specified volume.'
def copy_volume_to_image(self, context, volume_id, image_meta): DCNL 'Uploads the specified volume to Glance. DCNL image_meta is a dictionary containing the following keys: DCNL \'id\', \'container_format\', \'disk_format\''
def initialize_connection(self, context, volume_id, connector): DCNL 'Prepare volume for connection from host represented by connector. DCNL This method calls the driver initialize_connection and returns DCNL it to the caller.  The connector parameter is a dictionary with DCNL information about the host that will connect to the volume in the DCNL following format:: DCNL \'ip\': ip, DCNL \'initiator\': initiator, DCNL ip: the ip address of the connecting machine DCNL initiator: the iscsi initiator name of the connecting machine. DCNL This can be None if the connecting machine does not support iscsi DCNL connections. DCNL driver is responsible for doing any necessary security setup and DCNL returning a connection_info dictionary in the following format:: DCNL \'driver_volume_type\': driver_volume_type, DCNL \'data\': data, DCNL driver_volume_type: a string to identify the type of volume.  This DCNL can be used by the calling code to determine the DCNL strategy for connecting to the volume. This could DCNL be \'iscsi\', \'rbd\', \'sheepdog\', etc. DCNL data: this is the data that the calling code will use to connect DCNL to the volume. Keep in mind that this will be serialized to DCNL json in various places, so it should not contain any non-json DCNL data types.'
def terminate_connection(self, context, volume_id, connector, force=False): DCNL 'Cleanup connection from host represented by connector. DCNL The format of connector is the same as for initialize_connection.'
def publish_service_capabilities(self, context): DCNL 'Collect driver status and then publish'
@wrap_check_policy DCNL def get_volume_metadata(self, context, volume): DCNL 'Get all metadata associated with a volume.'
@wrap_check_policy DCNL def delete_volume_metadata(self, context, volume, key): DCNL 'Delete the given metadata item from a volume.'
@wrap_check_policy DCNL def update_volume_metadata(self, context, volume, metadata, delete=False): DCNL 'Updates or creates volume metadata. DCNL If delete is True, metadata items that are not specified in the DCNL `metadata` argument will be deleted.'
def get_volume_metadata_value(self, volume, key): DCNL 'Get value of particular metadata key.'
def get_snapshot_metadata(self, context, snapshot): DCNL 'Get all metadata associated with a snapshot.'
def delete_snapshot_metadata(self, context, snapshot, key): DCNL 'Delete the given metadata item from a snapshot.'
def update_snapshot_metadata(self, context, snapshot, metadata, delete=False): DCNL 'Updates or creates snapshot metadata. DCNL If delete is True, metadata items that are not specified in the DCNL `metadata` argument will be deleted.'
def _check_volume_availability(self, context, volume, force): DCNL 'Check if the volume can be used.'
@wrap_check_policy DCNL def copy_volume_to_image(self, context, volume, metadata, force): DCNL 'Create a new image from the specified volume.'
def set_host_enabled(self, context, host, enabled): DCNL 'Sets the specified host\'s ability to accept new volumes.'
def get_host_uptime(self, context, host): DCNL 'Returns the result of calling "uptime" on the target host.'
def set_host_maintenance(self, context, host, mode): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL volume evacuation.'
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True): DCNL 'Runs a command in an out-of-process shell. DCNL Returns the output of that command. Working directory is self.root.'
def create_virtualenv(self, no_site_packages=True): DCNL 'Creates the virtual environment and installs PIP. DCNL Creates the virtual environment and installs PIP only into the DCNL virtual environment.'
def parse_args(self, argv): DCNL 'Parses command-line arguments.'
def post_process(self): DCNL 'Any distribution-specific post-processing gets done here. DCNL In particular, this is useful for applying patches to code inside DCNL the venv.'
def post_process(self): DCNL 'Workaround for a bug in eventlet. DCNL This currently affects RHEL6.1, but the fix can safely be DCNL applied to all RHEL and Fedora distributions. DCNL This can be removed when the fix is applied upstream. DCNL Nova: https://bugs.launchpad.net/nova/+bug/884915 DCNL Upstream: https://bitbucket.org/which_linden/eventlet/issue/89'
@classmethod DCNL def from_msg_to_dict(cls, msg): DCNL 'From the output of pylint msg, to a dict, where each key DCNL is a unique error identifier, value is a list of LintOutput'
def revoke_certs_by_user(self, context, user_id): DCNL 'Revoke all user certs.'
def revoke_certs_by_project(self, context, project_id): DCNL 'Revoke all project certs.'
def revoke_certs_by_user_and_project(self, context, user_id, project_id): DCNL 'Revoke certs for user in project.'
def generate_x509_cert(self, context, user_id, project_id): DCNL 'Generate and sign a cert for user in project.'
def fetch_ca(self, context, project_id): DCNL 'Get root ca for a project.'
def fetch_crl(self, context, project_id): DCNL 'Get crl for a project.'
def decrypt_text(self, context, project_id, text): DCNL 'Decrypt base64 encoded text using the projects private key.'
def post_migrations(self): DCNL 'Any addition steps that are needed outside of the migrations.'
def setUp(self): DCNL 'Run before each test method to initialize test environment.'
def flags(self, **kw): DCNL 'Override flag variables for a test.'
def __init__(self, instance, address=None, content=[], extra_md=None, conductor_api=None): DCNL 'Creation of this object should basically cover all time consuming DCNL collection.  Methods after that should not cause time delays due to DCNL network operations or lengthy cpu operations. DCNL The user should then get a single instance and make multiple method DCNL calls on it.'
def metadata_for_config_drive(self): DCNL 'Yields (path, value) tuples for metadata elements.'
def __init__(self, application): DCNL 'middleware can use fake for testing.'
def _matches_any_role(self, context, roles): DCNL 'Return True if any role in roles is allowed in context.'
def _format_instance_bdm(self, context, instance_uuid, root_device_name, result): DCNL 'Format InstanceBlockDeviceMappingResponseItemType.'
def _ec2_ids_to_instances(self, context, instance_id): DCNL 'Get all instances first, to prevent partial executions.'
def terminate_instances(self, context, instance_id, **kwargs): DCNL 'Terminate each instance in instance_id, which is a list of ec2 ids. DCNL instance_id is a kwarg so its name cannot be modified.'
def reboot_instances(self, context, instance_id, **kwargs): DCNL 'instance_id is a list of instance ids.'
def stop_instances(self, context, instance_id, **kwargs): DCNL 'Stop each instances in instance_id. DCNL Here instance_id is a list of instance ids'
def start_instances(self, context, instance_id, **kwargs): DCNL 'Start each instances in instance_id. DCNL Here instance_id is a list of instance ids'
def _format_image(self, image): DCNL 'Convert from format defined by GlanceImageService to S3 format.'
def __init__(self, exception): DCNL 'Create a response for the given webob.exc.exception.'
@webob.dec.wsgify DCNL def __call__(self, req): DCNL 'Generate a WSGI response based on the exception passed to ctor.'
def _get_roles(self, req): DCNL 'Get the list of roles.'
def __init__(self, ext_mgr): DCNL 'Register extension with the extension manager.'
def get_resources(self): DCNL 'List of extensions.ResourceExtension extension objects. DCNL Resources define new nouns, and are accessible through URLs.'
def get_controller_extensions(self): DCNL 'List of extensions.ControllerExtension extension objects. DCNL Controller extensions are used to extend existing controllers.'
@classmethod DCNL def nsmap(cls): DCNL 'Synthesize a namespace map from extension.'
@classmethod DCNL def xmlname(cls, name): DCNL 'Synthesize element and attribute names.'
def get_resources(self): DCNL 'Returns a list of ResourceExtension objects.'
def get_controller_extensions(self): DCNL 'Returns a list of ControllerExtension objects.'
def _check_extension(self, extension): DCNL 'Checks for required methods in extension objects.'
def load_extension(self, ext_factory): DCNL 'Execute an extension factory. DCNL Loads an extension.  The \'ext_factory\' is the name of a DCNL callable that will be imported and called with one DCNL argument--the extension manager.  The factory callable is DCNL expected to call the register() method at least once.'
def _load_extensions(self): DCNL 'Load extensions specified on the command line.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Simple paste factory, :class:`nova.wsgi.Router` doesn\'t have one.'
def extract_metadata(self, metadata_node): DCNL 'Marshal the metadata attribute of a parsed request.'
def _get_next_link(self, request, identifier, collection_name): DCNL 'Return href string with proper limit and marker params.'
def _get_href_link(self, request, identifier, collection_name): DCNL 'Return an href string pointing to this object.'
def _get_bookmark_link(self, request, identifier, collection_name): DCNL 'Create a URL that refers to a specific resource.'
def _get_collection_links(self, request, items, collection_name, id_key='uuid'): DCNL 'Retrieve \'next\' link, if applicable.'
def __init__(self, *chain): DCNL 'Initialize the selector. DCNL Each argument is a subsequent index into the object.'
def __repr__(self): DCNL 'Return a representation of the selector.'
def __call__(self, obj, do_raise=False): DCNL 'Select a datum to operate on. DCNL Selects the relevant datum within the object. DCNL :param obj: The object from which to select the object. DCNL :param do_raise: If False (the default), return None if the DCNL indexed datum does not exist.  Otherwise, DCNL raise a KeyError.'
def __call__(self, obj, do_raise=False): DCNL 'Returns empty string if the selected value does not exist.'
def __init__(self, value): DCNL 'Initialize the selector. DCNL :param value: The value to return.'
def __repr__(self): DCNL 'Return a representation of the selector.'
def __call__(self, _obj, _do_raise=False): DCNL 'Select a datum to operate on. DCNL Returns a constant value.  Compatible with DCNL Selector.__call__().'
def __init__(self, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Initialize an element. DCNL Initializes an element in the template.  Keyword arguments DCNL specify attributes to be set on the element; values must be DCNL callables.  See TemplateElement.set() for more information. DCNL :param tag: The name of the tag to create. DCNL :param attrib: An optional dictionary of element attributes. DCNL :param selector: An optional callable taking an object and DCNL optional boolean do_raise indicator and DCNL returning the object bound to the element. DCNL :param subselector: An optional callable taking an object and DCNL optional boolean do_raise indicator and DCNL returning the object bound to the element. DCNL This is used to further refine the datum DCNL object returned by selector in the event DCNL that it is a list of objects.'
def __repr__(self): DCNL 'Return a representation of the template element.'
def __len__(self): DCNL 'Return the number of child elements.'
def __contains__(self, key): DCNL 'Determine whether a child node named by key exists.'
def __getitem__(self, idx): DCNL 'Retrieve a child node by index or name.'
def append(self, elem): DCNL 'Append a child to the element.'
def extend(self, elems): DCNL 'Append children to the element.'
def insert(self, idx, elem): DCNL 'Insert a child element at the given index.'
def remove(self, elem): DCNL 'Remove a child element.'
def get(self, key): DCNL 'Get an attribute. DCNL Returns a callable which performs datum selection. DCNL :param key: The name of the attribute to get.'
def set(self, key, value=None): DCNL 'Set an attribute. DCNL :param key: The name of the attribute to set. DCNL :param value: A callable taking an object and optional boolean DCNL do_raise indicator and returning the datum bound DCNL to the attribute.  If None, a Selector() will be DCNL constructed from the key.  If a string, a DCNL Selector() will be constructed from the string.'
def keys(self): DCNL 'Return the attribute names.'
def items(self): DCNL 'Return the attribute names and values.'
def unwrap(self): DCNL 'Unwraps a template to return a template element.'
def wrap(self): DCNL 'Wraps a template element to return a template.'
def apply(self, elem, obj): DCNL 'Apply text and attributes to an etree.Element. DCNL Applies the text and attribute instructions in the template DCNL element to an etree.Element instance. DCNL :param elem: An etree.Element instance. DCNL :param obj: The base object associated with this template DCNL element.'
def _render(self, parent, datum, patches, nsmap): DCNL 'Internal rendering. DCNL Renders the template node into an etree.Element object. DCNL Returns the etree.Element object. DCNL :param parent: The parent etree.Element instance. DCNL :param datum: The datum associated with this template element. DCNL :param patches: A list of other template elements that must DCNL also be applied. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the etree.Element instance.'
def render(self, parent, obj, patches=[], nsmap=None): DCNL 'Render an object. DCNL Renders an object against this template node.  Returns a list DCNL of two-item tuples, where the first item is an etree.Element DCNL instance and the second item is the datum associated with that DCNL instance. DCNL :param parent: The parent for the etree.Element instances. DCNL :param obj: The object to render this template element DCNL against. DCNL :param patches: A list of other template elements to apply DCNL when rendering this template element. DCNL :param nsmap: An optional namespace dictionary to attach to DCNL the etree.Element instances.'
def will_render(self, datum): DCNL 'Hook method. DCNL An overridable hook method to determine whether this template DCNL element will be rendered at all.  By default, returns False DCNL (inhibiting rendering) if the datum is None. DCNL :param datum: The datum associated with this template element.'
def _text_get(self): DCNL 'Template element text. DCNL Either None or a callable taking an object and optional DCNL boolean do_raise indicator and returning the datum bound to DCNL the text of the template element.'
def tree(self): DCNL 'Return string representation of the template tree. DCNL Returns a representation of the template rooted at this DCNL element as a string, suitable for inclusion in debug logs.'
def __init__(self, root, nsmap=None): DCNL 'Initialize a template. DCNL :param root: The root element of the template. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def _serialize(self, parent, obj, siblings, nsmap=None): DCNL 'Internal serialization. DCNL Recursive routine to build a tree of etree.Element instances DCNL from an object based on the template.  Returns the first DCNL etree.Element instance rendered, or None. DCNL :param parent: The parent etree.Element instance.  Can be DCNL None. DCNL :param obj: The object to render. DCNL :param siblings: The TemplateElement instances against which DCNL to render the object. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the etree.Element instance DCNL rendered.'
def serialize(self, obj, *args, **kwargs): DCNL 'Serialize an object. DCNL Serializes an object against the template.  Returns a string DCNL with the serialized XML.  Positional and keyword arguments are DCNL passed to etree.tostring(). DCNL :param obj: The object to serialize.'
def make_tree(self, obj): DCNL 'Create a tree. DCNL Serializes an object against the template.  Returns an Element DCNL node with appropriate children. DCNL :param obj: The object to serialize.'
def _siblings(self): DCNL 'Hook method for computing root siblings. DCNL An overridable hook method to return the siblings of the root DCNL element.  By default, this is the root element itself.'
def _nsmap(self): DCNL 'Hook method for computing the namespace dictionary. DCNL An overridable hook method to return the namespace dictionary.'
def unwrap(self): DCNL 'Unwraps a template to return a template element.'
def wrap(self): DCNL 'Wraps a template element to return a template.'
def apply(self, master): DCNL 'Hook method for determining slave applicability. DCNL An overridable hook method used to determine if this template DCNL is applicable as a slave to a given master template. DCNL :param master: The master template to test.'
def tree(self): DCNL 'Return string representation of the template tree. DCNL Returns a representation of the template as a string, suitable DCNL for inclusion in debug logs.'
def __init__(self, root, version, nsmap=None): DCNL 'Initialize a master template. DCNL :param root: The root element of the template. DCNL :param version: The version number of the template. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def __repr__(self): DCNL 'Return string representation of the template.'
def _siblings(self): DCNL 'Hook method for computing root siblings. DCNL An overridable hook method to return the siblings of the root DCNL element.  This is the root element plus the root elements of DCNL all the slave templates.'
def _nsmap(self): DCNL 'Hook method for computing the namespace dictionary. DCNL An overridable hook method to return the namespace dictionary. DCNL The namespace dictionary is computed by taking the master DCNL template\'s namespace dictionary and updating it from all the DCNL slave templates.'
def attach(self, *slaves): DCNL 'Attach one or more slave templates. DCNL Attaches one or more slave templates to the master template. DCNL Slave templates must have a root element with the same tag as DCNL the master template.  The slave template\'s apply() method will DCNL be called to determine if the slave should be applied to this DCNL master; if it returns False, that slave will be skipped. DCNL (This allows filtering of slaves based on the version of the DCNL master template.)'
def copy(self): DCNL 'Return a copy of this master template.'
def __init__(self, root, min_vers, max_vers=None, nsmap=None): DCNL 'Initialize a slave template. DCNL :param root: The root element of the template. DCNL :param min_vers: The minimum permissible version of the master DCNL template for this slave template to apply. DCNL :param max_vers: An optional upper bound for the master DCNL template version. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def __repr__(self): DCNL 'Return string representation of the template.'
def apply(self, master): DCNL 'Hook method for determining slave applicability. DCNL An overridable hook method used to determine if this template DCNL is applicable as a slave to a given master template.  This DCNL version requires the master template to have a version number DCNL between min_vers and max_vers. DCNL :param master: The master template to test.'
def __new__(cls, copy=True): DCNL 'Construct and return a template. DCNL :param copy: If True (the default), a copy of the template DCNL will be constructed and returned, if possible.'
def construct(self): DCNL 'Construct a template. DCNL Called to construct a template instance, which it must return. DCNL Only called once.'
def cache_db_items(self, key, items, item_key='id'): DCNL 'Allow API methods to store objects from a DB query to be DCNL used by API extensions within the same API request. DCNL An instance of this class only lives for the lifetime of a DCNL single API request, so there\'s no need to implement full DCNL cache management.'
def get_db_items(self, key): DCNL 'Allow an API extension to get previously stored objects within DCNL the same API request. DCNL Note that the object data will be slightly stale.'
def get_db_item(self, key, item_key): DCNL 'Allow an API extension to get a previously stored object DCNL within the same API request. DCNL Note that the object data will be slightly stale.'
def best_match_content_type(self): DCNL 'Determine the requested response content-type.'
def get_content_type(self): DCNL 'Determine content type of the request body. DCNL Does not do any body introspection, only checks header'
def dispatch(self, *args, **kwargs): DCNL 'Find and call local method.'
def __init__(self, metadata=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary.'
def _from_xml_node(self, node, listnames): DCNL 'Convert a minidom node to a simple Python type. DCNL :param listnames: list of XML node names whose subnodes should DCNL be considered list items.'
def find_first_child_named_in_namespace(self, parent, namespace, name): DCNL 'Search a nodes children for the first child with a given name.'
def find_first_child_named(self, parent, name): DCNL 'Search a nodes children for the first child with a given name.'
def find_children_named(self, parent, name): DCNL 'Return all of a nodes children who have the given name.'
def extract_text(self, node): DCNL 'Get the text field contained by the given node.'
def extract_elements(self, node): DCNL 'Get only Element type childs from node.'
def find_attribute_or_element(self, parent, name): DCNL 'Get an attribute value; fallback to an element if not found.'
def extract_metadata(self, metadata_node): DCNL 'Marshal the metadata attribute of a parsed request.'
def __init__(self, metadata=None, xmlns=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary. DCNL :param xmlns: XML namespace to include with serialized xml'
def _to_xml_node(self, doc, metadata, nodename, data): DCNL 'Recursive method to convert data members to XML nodes.'
def _to_xml(self, root): DCNL 'Convert the xml object to an xml string.'
def __init__(self, obj, code=None, headers=None, **serializers): DCNL 'Binds serializers with an object. DCNL Takes keyword arguments akin to the @serializer() decorator DCNL for specifying serializers.  Serializers specified will be DCNL given preference over default serializers or method-specific DCNL serializers on return.'
def __getitem__(self, key): DCNL 'Retrieves a header with the given name.'
def __setitem__(self, key, value): DCNL 'Sets a header with the given name to the given value.'
def __delitem__(self, key): DCNL 'Deletes the header with the given name.'
def _bind_method_serializers(self, meth_serializers): DCNL 'Binds method serializers with the response object. DCNL Binds the method serializers with the response object. DCNL Serializers specified to the constructor will take precedence DCNL over serializers specified to this method. DCNL :param meth_serializers: A dictionary with keys mapping to DCNL response types and values containing DCNL serializer objects.'
def get_serializer(self, content_type, default_serializers=None): DCNL 'Returns the serializer for the wrapped object. DCNL Returns the serializer for the wrapped object subject to the DCNL indicated content type.  If no serializer matching the content DCNL type is attached, an appropriate serializer drawn from the DCNL default serializers will be used.  If no appropriate DCNL serializer is available, raises InvalidContentType.'
def preserialize(self, content_type, default_serializers=None): DCNL 'Prepares the serializer that will be used to serialize. DCNL Determines the serializer that will be used and prepares an DCNL instance of it for later call.  This allows the serializer to DCNL be accessed by extensions for, e.g., template extension.'
def attach(self, **kwargs): DCNL 'Attach slave templates to serializers.'
def serialize(self, request, content_type, default_serializers=None): DCNL 'Serializes the wrapped object. DCNL Utility method for serializing the wrapped object.  Returns a DCNL webob.Response object.'
@property DCNL def code(self): DCNL 'Retrieve the response status.'
@property DCNL def headers(self): DCNL 'Retrieve the headers.'
def __init__(self, controller, action_peek=None, inherits=None, **deserializers): DCNL ':param controller: object that implement methods created by routes lib DCNL :param action_peek: dictionary of routines for peeking into an action DCNL request body to determine the desired action DCNL :param inherits: another resource object that this resource should DCNL inherit extensions from. Any action extensions that DCNL are applied to the parent resource will also apply DCNL to this resource.'
def register_actions(self, controller): DCNL 'Registers controller actions with this resource.'
def register_extensions(self, controller): DCNL 'Registers controller extensions with this resource.'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'WSGI method that controls (de)serialization and method dispatch.'
def _process_stack(self, request, action, action_args, content_type, body, accept): DCNL 'Implement the processing stack.'
def _get_method(self, request, action, content_type, body): DCNL 'Look up the action-specific method and its extensions.'
def dispatch(self, method, request, action_args): DCNL 'Dispatch a call to the action-specific method.'
def __new__(mcs, name, bases, cls_dict): DCNL 'Adds the wsgi_actions dictionary to the class.'
def __init__(self, view_builder=None): DCNL 'Initialize controller with a view builder instance.'
def __init__(self, exception): DCNL 'Create a Fault for the given webob.exc.exception.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Generate a WSGI response based on the exception passed to ctor.'
def __init__(self, message, details, retry_time): DCNL 'Initialize new `OverLimitFault` with relevant information.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'Return the wrapped exception with a serialized body conforming to our DCNL error format.'
def content_type_params(self, best_content_type): DCNL 'Find parameters in Accept header for given content type.'
def _match(self, host, port, path_info): DCNL 'Find longest match for a given URL path.'
def _path_strategy(self, host, port, path_info): DCNL 'Check path suffix for MIME type and path prefix for API version.'
def _content_type_strategy(self, host, port, environ): DCNL 'Check Content-Type header for API version.'
def _accept_strategy(self, host, port, environ, supported_content_types): DCNL 'Check Accept header for best matching MIME type and API version.'
def basic(self, ip): DCNL 'Return a dictionary describing an IP address.'
def show(self, network, label): DCNL 'Returns a dictionary describing a network.'
def index(self, networks): DCNL 'Return a dictionary describing a list of networks.'
def basic(self, request, image): DCNL 'Return a dictionary with basic image attributes.'
def show(self, request, image): DCNL 'Return a dictionary with image details.'
def detail(self, request, images): DCNL 'Show a list of images with details.'
def index(self, request, images): DCNL 'Show a list of images with basic attributes.'
def _list_view(self, list_func, request, images): DCNL 'Provide a view for a list of images.'
def _get_links(self, request, identifier, collection_name): DCNL 'Return a list of links for this image.'
def _get_alternate_link(self, request, identifier): DCNL 'Create an alternate link for a specific image id.'
@staticmethod DCNL def _format_date(date_string): DCNL 'Return standard format for given date.'
@staticmethod DCNL def _get_status(image): DCNL 'Update the status field to standardize format.'
def index(self, request, flavors): DCNL 'Return the \'index\' view of flavors.'
def detail(self, request, flavors): DCNL 'Return the \'detail\' view of flavors.'
def _list_view(self, func, request, flavors): DCNL 'Provide a view for a list of flavors.'
def _build_absolute_limits(self, absolute_limits): DCNL 'Builder for absolute limits DCNL absolute_limits should be given as a dict of limits. DCNL For example: {"ram": 512, "gigabytes": 1024}.'
def __init__(self): DCNL 'Initialize view builder.'
def create(self, request, instance): DCNL 'View that should be returned when an instance is created.'
@_skip_precooked DCNL def basic(self, request, instance): DCNL 'Generic, non-detailed view of an instance.'
@_skip_precooked DCNL def show(self, request, instance): DCNL 'Detailed view of a single instance.'
def index(self, request, instances): DCNL 'Show a list of servers without many details.'
def detail(self, request, instances): DCNL 'Detailed view of a list of instance.'
def _list_view(self, func, request, servers): DCNL 'Provide a view for a list of servers.'
def __init__(self, base_url): DCNL ':param base_url: url of the root wsgi application'
def _build_links(self, version_data): DCNL 'Generate a container of links that refer to the provided version.'
def generate_href(self, path=None): DCNL 'Create an url that refers to a specific version_number.'
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, image_id): DCNL 'Returns the list of metadata for a given instance.'
def __init__(self, image_service=None, **kwargs): DCNL 'Initialize new `ImageController`. DCNL :param image_service: `nova.image.glance:GlanceImageService`'
def _get_filters(self, req): DCNL 'Return a dictionary of query param filters from the request DCNL :param req: the Request object coming from the wsgi layer DCNL :retval a dict of key/value filters'
@wsgi.serializers(xml=ImageTemplate) DCNL def show(self, req, id): DCNL 'Return detailed information about a specific image. DCNL :param req: `wsgi.Request` object DCNL :param id: Image identifier'
def delete(self, req, id): DCNL 'Delete an image, if allowed. DCNL :param req: `wsgi.Request` object DCNL :param id: Image identifier (integer)'
@wsgi.serializers(xml=MinimalImagesTemplate) DCNL def index(self, req): DCNL 'Return an index listing of images available to the request. DCNL :param req: `wsgi.Request` object'
@wsgi.serializers(xml=ImagesTemplate) DCNL def detail(self, req): DCNL 'Return a detailed index listing of images available to the request. DCNL :param req: `wsgi.Request` object.'
@wsgi.serializers(xml=MinimalFlavorsTemplate) DCNL def index(self, req): DCNL 'Return all flavors in brief.'
@wsgi.serializers(xml=FlavorsTemplate) DCNL def detail(self, req): DCNL 'Return all flavors in detail.'
@wsgi.serializers(xml=FlavorTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given flavor id.'
def _get_is_public(self, req): DCNL 'Parse is_public into something usable.'
def _get_flavors(self, req): DCNL 'Helper function that returns a list of flavor dicts.'
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req): DCNL 'Return all global and rate limit information.'
def create(self, req, body): DCNL 'Create a new limit.'
def delete(self, req, id): DCNL 'Delete the limit.'
def detail(self, req): DCNL 'Return limit details.'
def show(self, req, id): DCNL 'Show limit information.'
def update(self, req, id, body): DCNL 'Update existing limit.'
def __init__(self, verb, uri, regex, value, unit): DCNL 'Initialize a new `Limit`. DCNL @param verb: HTTP verb (POST, PUT, etc.) DCNL @param uri: Human-readable URI DCNL @param regex: Regular expression format for this limit DCNL @param value: Integer number of requests which can be made DCNL @param unit: Unit of measure for the value parameter'
def __call__(self, verb, url): DCNL 'Represents a call to this limit from a relevant request. DCNL @param verb: string http verb (POST, GET, etc.) DCNL @param url: string URL'
def _get_time(self): DCNL 'Retrieve the current time. Broken out for testability.'
def display_unit(self): DCNL 'Display the string name of the unit.'
def display(self): DCNL 'Return a useful representation of this class.'
def __init__(self, application, limits=None, limiter=None, **kwargs): DCNL 'Initialize new `RateLimitingMiddleware`, which wraps the given WSGI DCNL application and sets up the given limits. DCNL @param application: WSGI application to wrap DCNL @param limits: String describing limits DCNL @param limiter: String identifying class for representing limits DCNL Other parameters are passed to the constructor for the limiter.'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req): DCNL 'Represents a single call through this middleware. We should record the DCNL request if we have a limit relevant to it. If no limit is relevant to DCNL the request, ignore it. DCNL If the request should be rate limited, return a fault telling the user DCNL they are over the limit and need to retry later.'
def __init__(self, limits, **kwargs): DCNL 'Initialize the new `Limiter`. DCNL @param limits: List of `Limit` objects'
def get_limits(self, username=None): DCNL 'Return the limits for a given user.'
def check_for_delay(self, verb, url, username=None): DCNL 'Check the given verb/user/user triplet for limit. DCNL @return: Tuple of delay (in seconds) and error message (or None, None)'
@staticmethod DCNL def parse_limits(limits): DCNL 'Convert a string into a list of Limit instances.  This DCNL implementation expects a semicolon-separated sequence of DCNL parenthesized groups, where each group contains a DCNL comma-separated sequence consisting of HTTP method, DCNL user-readable URI, a URI reg-exp, an integer number of DCNL requests which can be made, and a unit of measure.  Valid DCNL values for the latter are "SECOND", "MINUTE", "HOUR", and DCNL "DAY". DCNL @return: List of Limit instances.'
def __init__(self, limits=None): DCNL 'Initialize the new `WsgiLimiter`. DCNL @param limits: List of `Limit` objects'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request): DCNL 'Handles a call to this application. Returns 204 if the request is DCNL acceptable to the limiter, else a 403 is returned with a relevant DCNL header indicating when the request *will* succeed.'
def __init__(self, limiter_address): DCNL 'Initialize the new `WsgiLimiterProxy`. DCNL @param limiter_address: IP/port combination of where to request limit'
@staticmethod DCNL def parse_limits(limits): DCNL 'Ignore a limits string--simply doesn\'t apply for the limit DCNL proxy. DCNL @return: Empty list.'
@wsgi.serializers(xml=ConsolesTemplate) DCNL def index(self, req, server_id): DCNL 'Returns a list of consoles for this instance.'
def create(self, req, server_id): DCNL 'Creates a new console.'
@wsgi.serializers(xml=ConsoleTemplate) DCNL def show(self, req, server_id, id): DCNL 'Shows in-depth information on a specific console.'
def update(self, req, server_id, id): DCNL 'You can\'t update a console.'
def delete(self, req, server_id, id): DCNL 'Deletes a console.'
@wsgi.serializers(xml=HostIndexTemplate) DCNL def index(self, req): DCNL ':returns: A dict in the format: DCNL {\'hosts\': [{\'host_name\': \'some.host.name\', DCNL \'service\': \'cells\'}, DCNL {\'host_name\': \'some.other.host.name\', DCNL \'service\': \'cells\'}, DCNL {\'host_name\': \'some.celly.host.name\', DCNL \'service\': \'cells\'}, DCNL {\'host_name\': \'console1.host.com\', DCNL \'service\': \'consoleauth\'}, DCNL {\'host_name\': \'network1.host.com\', DCNL \'service\': \'network\'}, DCNL {\'host_name\': \'netwwork2.host.com\', DCNL \'service\': \'network\'}, DCNL {\'host_name\': \'sched1.host.com\', DCNL \'service\': \'scheduler\'}, DCNL {\'host_name\': \'sched2.host.com\', DCNL \'service\': \'scheduler\'}, DCNL {\'host_name\': \'vol1.host.com\', DCNL \'service\': \'volume\'}]}'
@wsgi.serializers(xml=HostUpdateTemplate) DCNL @wsgi.deserializers(xml=HostUpdateDeserializer) DCNL def update(self, req, id, body): DCNL ':param body: example format {\'status\': \'enable\', DCNL \'maintenance_mode\': \'enable\'} DCNL :returns:'
def _set_host_maintenance(self, context, host_name, mode=True): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL guest VMs evacuation.'
def _set_enabled_status(self, context, host_name, enabled): DCNL 'Sets the specified host\'s ability to accept new instances. DCNL :param enabled: a boolean - if False no new VMs will be able to start DCNL on the host'
def _host_power_action(self, req, host_name, action): DCNL 'Reboots, shuts down or powers up the host.'
@wsgi.serializers(xml=HostShowTemplate) DCNL def show(self, req, id): DCNL 'Shows the physical/usage resource given by hosts. DCNL :param id: hostname DCNL :returns: expected to use HostShowTemplate. DCNL ex.:: DCNL {\'host\': {\'resource\':D},..} DCNL D: {\'host\': \'hostname\',\'project\': \'admin\', DCNL \'cpu\': 1, \'memory_mb\': 2048, \'disk_gb\': 30}'
def _extract_volume(self, node): DCNL 'Marshal the volume attribute of a parsed request.'
def default(self, string): DCNL 'Deserialize an xml-formatted volume create request.'
@wsgi.serializers(xml=VolumeTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given volume.'
def delete(self, req, id): DCNL 'Delete a volume.'
@wsgi.serializers(xml=VolumesTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of volumes.'
@wsgi.serializers(xml=VolumesTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of volumes.'
def _items(self, req, entity_maker): DCNL 'Returns a list of volumes, transformed through entity_maker.'
@wsgi.serializers(xml=VolumeTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body): DCNL 'Creates a new volume.'
@wsgi.serializers(xml=VolumeAttachmentsTemplate) DCNL def index(self, req, server_id): DCNL 'Returns the list of volume attachments for a given instance.'
@wsgi.serializers(xml=VolumeAttachmentTemplate) DCNL def show(self, req, server_id, id): DCNL 'Return data about the given volume attachment.'
@wsgi.serializers(xml=VolumeAttachmentTemplate) DCNL def create(self, req, server_id, body): DCNL 'Attach a volume to an instance.'
def update(self, req, server_id, id, body): DCNL 'Update a volume attachment.  We don\'t currently support this.'
def delete(self, req, server_id, id): DCNL 'Detach a volume from an instance.'
def _items(self, req, server_id, entity_maker): DCNL 'Returns a list of attachments, transformed through entity_maker.'
@wsgi.serializers(xml=SnapshotTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given snapshot.'
def delete(self, req, id): DCNL 'Delete a snapshot.'
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of snapshots.'
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of snapshots.'
def _items(self, req, entity_maker): DCNL 'Returns a list of snapshots, transformed through entity_maker.'
@wsgi.serializers(xml=SnapshotTemplate) DCNL def create(self, req, body): DCNL 'Creates a new snapshot.'
def index(self, req, server_id): DCNL 'Returns the list of interface attachments for a given instance.'
def show(self, req, server_id, id): DCNL 'Return data about the given interface attachment.'
def create(self, req, server_id, body): DCNL 'Attach an interface to an instance.'
def update(self, req, server_id, id, body): DCNL 'Update a interface attachment.  We don\'t currently support this.'
def delete(self, req, server_id, id): DCNL 'Detach an interface from an instance.'
def _items(self, req, server_id, entity_maker): DCNL 'Returns a list of attachments, transformed through entity_maker.'
@wsgi.serializers(xml=InstanceActionsTemplate) DCNL def index(self, req, server_id): DCNL 'Returns the list of actions recorded for a given instance.'
@wsgi.serializers(xml=InstanceActionTemplate) DCNL def show(self, req, server_id, id): DCNL 'Return data about the given instance action.'
def _format_quota_set(self, quota_class, quota_set): DCNL 'Convert the quota object to a result dict.'
@wsgi.action('evacuate') DCNL def _evacuate(self, req, id, body): DCNL 'Permit admins to evacuate a server from a failed host DCNL to a new one.'
@wsgi.serializers(xml=FloatingIPTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given floating ip.'
@wsgi.serializers(xml=FloatingIPsTemplate) DCNL def index(self, req): DCNL 'Return a list of floating ips allocated to a project.'
def _get_ip_by_id(self, context, value): DCNL 'Checks that value is id and then returns its address.'
@wsgi.action('addFloatingIp') DCNL def _add_floating_ip(self, req, id, body): DCNL 'Associate floating_ip to an instance.'
@wsgi.action('removeFloatingIp') DCNL def _remove_floating_ip(self, req, id, body): DCNL 'Dissociate floating_ip from an instance.'
def default(self, string): DCNL 'Deserialize an xml-formatted cell create request.'
def _get_cells(self, ctxt, req, detail=False): DCNL 'Return all cells.'
@wsgi.serializers(xml=CellsTemplate) DCNL def index(self, req): DCNL 'Return all cells in brief.'
@wsgi.serializers(xml=CellsTemplate) DCNL def detail(self, req): DCNL 'Return all cells in detail.'
@wsgi.serializers(xml=CellTemplate) DCNL def info(self, req): DCNL 'Return name and capabilities for this cell.'
@wsgi.serializers(xml=CellTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given cell name.  \'id\' is a cell name.'
def delete(self, req, id): DCNL 'Delete a child or parent cell entry.  \'id\' is a cell name.'
def _validate_cell_name(self, cell_name): DCNL 'Validate cell name is not empty and doesn\'t contain \'!\' or \'.\'.'
def _validate_cell_type(self, cell_type): DCNL 'Validate cell_type is \'parent\' or \'child\'.'
def _convert_cell_type(self, cell): DCNL 'Convert cell[\'type\'] to is_parent boolean.'
@wsgi.serializers(xml=CellTemplate) DCNL @wsgi.deserializers(xml=CellDeserializer) DCNL def create(self, req, body): DCNL 'Create a child cell entry.'
@wsgi.serializers(xml=CellTemplate) DCNL @wsgi.deserializers(xml=CellDeserializer) DCNL def update(self, req, id, body): DCNL 'Update a child cell entry.  \'id\' is the cell name to update.'
def sync_instances(self, req, body): DCNL 'Tell all cells to sync instance info.'
@wsgi.action('os-getConsoleOutput') DCNL def get_console_output(self, req, id, body): DCNL 'Get text console output.'
def index(self, req): DCNL 'Return a list of all floating ips.'
def show(self, req, id): DCNL 'Return a list of all floating ips for a given host.'
def create(self, req, body): DCNL 'Bulk create floating ips.'
def update(self, req, id, body): DCNL 'Bulk delete floating IPs.'
def _address_to_hosts(self, addresses): DCNL 'Iterate over hosts within an address range. DCNL If an explicit range specifier is missing, the parameter is DCNL interpreted as a specific individual address.'
def index(self, req): DCNL 'Returns a list a host aggregate\'s id, name, availability_zone.'
def create(self, req, body): DCNL 'Creates an aggregate, given its name and availability_zone.'
def show(self, req, id): DCNL 'Shows the details of an aggregate, hosts and metadata included.'
def update(self, req, id, body): DCNL 'Updates the name and/or availability_zone of given aggregate.'
def delete(self, req, id): DCNL 'Removes an aggregate by id.'
@get_host_from_body DCNL def _add_host(self, req, id, host): DCNL 'Adds a host to the specified aggregate.'
@get_host_from_body DCNL def _remove_host(self, req, id, host): DCNL 'Removes a host from the specified aggregate.'
def _set_metadata(self, req, id, body): DCNL 'Replaces the aggregate\'s existing metadata with new metadata.'
def _get_flavor_refs(self, context): DCNL 'Return a dictionary mapping flavorid to flavor_ref.'
def default(self, string): DCNL 'Deserialize an xml-formatted security group create request.'
def default(self, string): DCNL 'Deserialize an xml-formatted security group create request.'
def _extract_security_group_rule(self, node): DCNL 'Marshal the security group rule attribute of a parsed request.'
@wsgi.serializers(xml=SecurityGroupTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given security group.'
def delete(self, req, id): DCNL 'Delete a security group.'
@wsgi.serializers(xml=SecurityGroupsTemplate) DCNL def index(self, req): DCNL 'Returns a list of security groups.'
@wsgi.serializers(xml=SecurityGroupTemplate) DCNL @wsgi.deserializers(xml=SecurityGroupXMLDeserializer) DCNL def create(self, req, body): DCNL 'Creates a new security group.'
@wsgi.serializers(xml=SecurityGroupsTemplate) DCNL def index(self, req, server_id): DCNL 'Returns a list of security groups for the given instance.'
@wsgi.action('update') DCNL def update(self, req, id, body): DCNL 'Configure cloudpipe parameters for the project.'
def setup(self): DCNL 'Ensure the keychains and folders exist.'
def _get_all_cloudpipes(self, context): DCNL 'Get all cloudpipes.'
def _get_cloudpipe_for_project(self, context, project_id): DCNL 'Get the cloudpipe instance for a project ID.'
@wsgi.serializers(xml=CloudpipeTemplate) DCNL def create(self, req, body): DCNL 'Create a new cloudpipe instance, if none exists. DCNL Parameters: {cloudpipe: {\'project_id\': \'\'}}'
@wsgi.serializers(xml=CloudpipesTemplate) DCNL def index(self, req): DCNL 'List running cloudpipe instances.'
@wsgi.serializers(xml=CertificateTemplate) DCNL def show(self, req, id): DCNL 'Return a list of certificates.'
@wsgi.serializers(xml=CertificateTemplate) DCNL def create(self, req, body=None): DCNL 'Return a list of certificates.'
@wsgi.serializers(xml=ExtraSpecsTemplate) DCNL def index(self, req, flavor_id): DCNL 'Returns the list of extra specs for a given flavor.'
@wsgi.serializers(xml=ExtraSpecTemplate) DCNL def show(self, req, flavor_id, id): DCNL 'Return a single extra spec item.'
def delete(self, req, flavor_id, id): DCNL 'Deletes an existing extra spec.'
def _items(self, req, server_id, entity_maker): DCNL 'Returns a list of VIFs, transformed through entity_maker.'
@wsgi.serializers(xml=VirtualInterfaceTemplate) DCNL def index(self, req, server_id): DCNL 'Returns the list of VIFs for a given instance.'
@wsgi.serializers(xml=DomainsTemplate) DCNL def index(self, req): DCNL 'Return a list of available DNS domains.'
@wsgi.serializers(xml=DomainTemplate) DCNL def update(self, req, id, body): DCNL 'Add or modify domain entry.'
def delete(self, req, id): DCNL 'Delete the domain identified by id.'
@wsgi.serializers(xml=FloatingIPDNSTemplate) DCNL def show(self, req, domain_id, id): DCNL 'Return the DNS entry that corresponds to domain_id and id.'
@wsgi.serializers(xml=FloatingIPDNSTemplate) DCNL def update(self, req, domain_id, id, body): DCNL 'Add or modify dns entry.'
def delete(self, req, domain_id, id): DCNL 'Delete the entry identified by req and id.'
@wsgi.serializers(xml=ServicesIndexTemplate) DCNL def index(self, req): DCNL 'Return a list of all running services. Filter by host & service name.'
@wsgi.deserializers(xml=ServiceUpdateDeserializer) DCNL @wsgi.serializers(xml=ServiceUpdateTemplate) DCNL def update(self, req, id, body): DCNL 'Enable/Disable scheduling for a service.'
@wsgi.action('os-start') DCNL def _start_server(self, req, id, body): DCNL 'Start an instance.'
@wsgi.action('os-stop') DCNL def _stop_server(self, req, id, body): DCNL 'Stop an instance.'
def _format_quota_set(self, project_id, quota_set): DCNL 'Convert the quota object to a result dict.'
def _find_services(self, req): DCNL 'Returns a list of services.'
def _find_ports(self, req, hosts): DCNL 'Return a list of backdoor ports for all services in the list.'
def _start_coverage(self, req, body): DCNL 'Begin recording coverage information.'
@wsgi.serializers(xml=FloatingIPPoolsTemplate) DCNL def index(self, req): DCNL 'Return a list of pools.'
@wsgi.action('restore') DCNL def _restore(self, req, id, body): DCNL 'Restore a previously deleted instance.'
@wsgi.action('forceDelete') DCNL def _force_delete(self, req, id, body): DCNL 'Force delete of instance before deferred cleanup.'
def show(self, req, id): DCNL 'Return data about the given fixed ip.'
def _get_audit_task_logs(self, context, begin=None, end=None, before=None): DCNL 'Returns a full log for all instance usage audit tasks on all DCNL computes. DCNL :param begin: datetime beginning of audit period to get logs for, DCNL Defaults to the beginning of the most recently completed DCNL audit period prior to the \'before\' date. DCNL :param end: datetime ending of audit period to get logs for, DCNL Defaults to the ending of the most recently completed DCNL audit period prior to the \'before\' date. DCNL :param before: By default we look for the audit period most recently DCNL completed before this datetime. Has no effect if both begin and end DCNL are specified.'
@wsgi.action('rescue') DCNL @exts.wrap_errors DCNL def _rescue(self, req, id, body): DCNL 'Rescue an instance.'
@wsgi.action('unrescue') DCNL @exts.wrap_errors DCNL def _unrescue(self, req, id, body): DCNL 'Unrescue an instance.'
@wsgi.action('os-getVNCConsole') DCNL def get_vnc_console(self, req, id, body): DCNL 'Get text console output.'
@wsgi.action('os-getSPICEConsole') DCNL def get_spice_console(self, req, id, body): DCNL 'Get text console output.'
def get_actions(self): DCNL 'Return the actions the extension adds, as required by contract.'
def _get_flavor(self, context, compute_api, instance, flavors_cache): DCNL 'Get flavor information from the instance\'s system_metadata, DCNL allowing a fallback to lookup by-id for deleted instances only'
@wsgi.serializers(xml=SimpleTenantUsagesTemplate) DCNL def index(self, req): DCNL 'Retrieve tenant_usage for all tenants.'
@wsgi.serializers(xml=SimpleTenantUsageTemplate) DCNL def show(self, req, id): DCNL 'Retrieve tenant_usage for a specified tenant.'
@wsgi.action('pause') DCNL def _pause(self, req, id, body): DCNL 'Permit Admins to pause the server.'
@wsgi.action('unpause') DCNL def _unpause(self, req, id, body): DCNL 'Permit Admins to unpause the server.'
@wsgi.action('suspend') DCNL def _suspend(self, req, id, body): DCNL 'Permit admins to suspend the server.'
@wsgi.action('resume') DCNL def _resume(self, req, id, body): DCNL 'Permit admins to resume the server from suspend.'
@wsgi.action('migrate') DCNL def _migrate(self, req, id, body): DCNL 'Permit admins to migrate a server to a new host.'
@wsgi.action('resetNetwork') DCNL def _reset_network(self, req, id, body): DCNL 'Permit admins to reset networking on a server.'
@wsgi.action('injectNetworkInfo') DCNL def _inject_network_info(self, req, id, body): DCNL 'Permit admins to inject network info into a server.'
@wsgi.action('lock') DCNL def _lock(self, req, id, body): DCNL 'Permit admins to lock a server.'
@wsgi.action('unlock') DCNL def _unlock(self, req, id, body): DCNL 'Permit admins to lock a server.'
@wsgi.action('createBackup') DCNL def _create_backup(self, req, id, body): DCNL 'Backup a server instance. DCNL Images now have an `image_type` associated with them, which can be DCNL \'snapshot\' or the backup type, like \'daily\' or \'weekly\'. DCNL If the image_type is backup-like, then the rotation factor can be DCNL included and that will cause the oldest backups that exceed the DCNL rotation factor to be deleted.'
@wsgi.action('os-migrateLive') DCNL def _migrate_live(self, req, id, body): DCNL 'Permit admins to (live) migrate a server to a new host.'
@wsgi.action('os-resetState') DCNL def _reset_state(self, req, id, body): DCNL 'Permit admins to reset the state of a server.'
@wsgi.serializers(xml=AvailabilityZonesTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of availability zone.'
@wsgi.serializers(xml=AvailabilityZonesTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of availability zone.'
@wsgi.action('addFixedIp') DCNL def _add_fixed_ip(self, req, id, body): DCNL 'Adds an IP on a given network to an instance.'
@wsgi.action('removeFixedIp') DCNL def _remove_fixed_ip(self, req, id, body): DCNL 'Removes an IP from an instance.'
@wsgi.serializers(xml=AgentsIndexTemplate) DCNL def index(self, req): DCNL 'Return a list of all agent builds. Filter by hypervisor.'
def update(self, req, id, body): DCNL 'Update an existing agent build.'
def delete(self, req, id): DCNL 'Deletes an existing agent build.'
def create(self, req, body): DCNL 'Creates a new agent build.'
@wsgi.serializers(xml=KeypairTemplate) DCNL def create(self, req, body): DCNL 'Create or import keypair. DCNL Sending name will generate a key and return private_key DCNL and fingerprint. DCNL You can send a public_key to add an existing ssh key DCNL params: keypair object with: DCNL name (required) - string DCNL public_key (optional) - string'
def delete(self, req, id): DCNL 'Delete a keypair with a given name'
@wsgi.serializers(xml=KeypairTemplate) DCNL def show(self, req, id): DCNL 'Return data for the given key name.'
@wsgi.serializers(xml=KeypairsTemplate) DCNL def index(self, req): DCNL 'List of keypairs for a user'
def _extract_personality(self, server_node): DCNL 'Marshal the personality attribute of a parsed request.'
def _extract_server(self, node): DCNL 'Marshal the server attribute of a parsed request.'
def _extract_block_device_mapping(self, server_node): DCNL 'Marshal the block_device_mapping node of a parsed request.'
def _extract_scheduler_hints(self, server_node): DCNL 'Marshal the scheduler hints attribute of a parsed request.'
def _extract_networks(self, server_node): DCNL 'Marshal the networks attribute of a parsed request.'
def _extract_security_groups(self, server_node): DCNL 'Marshal the security_groups attribute of a parsed request.'
def default(self, string): DCNL 'Deserialize an xml-formatted server create request.'
@wsgi.serializers(xml=MinimalServersTemplate) DCNL def index(self, req): DCNL 'Returns a list of server names and ids for a given user.'
@wsgi.serializers(xml=ServersTemplate) DCNL def detail(self, req): DCNL 'Returns a list of server details for a given user.'
def _get_servers(self, req, is_detail): DCNL 'Returns a list of servers, based on any search options specified.'
def _get_server(self, context, req, instance_uuid): DCNL 'Utility function for looking up an instance by uuid.'
def _get_injected_files(self, personality): DCNL 'Create a list of injected files from the personality attribute. DCNL At this time, injected_files must be formatted as a list of DCNL (file_path, file_content) pairs for compatibility with the DCNL underlying compute service.'
def _get_requested_networks(self, requested_networks): DCNL 'Create a list of requested networks from the networks attribute.'
def _validate_user_data(self, user_data): DCNL 'Check if the user_data is encoded properly.'
@wsgi.serializers(xml=ServerTemplate) DCNL def show(self, req, id): DCNL 'Returns server details by server id.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=FullServerTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body): DCNL 'Creates a new server for a given user.'
@wsgi.serializers(xml=ServerTemplate) DCNL def update(self, req, id, body): DCNL 'Update server then pass on to version-specific controller.'
def _resize(self, req, instance_id, flavor_id, **kwargs): DCNL 'Begin the resize process with given instance/flavor.'
@wsgi.response(204) DCNL def delete(self, req, id): DCNL 'Destroys a server.'
def _image_from_req_data(self, data): DCNL 'Get image data from the request or raise appropriate DCNL exceptions DCNL If no image is supplied - checks to see if there is DCNL block devices set and proper extesions loaded.'
def _validate_metadata(self, metadata): DCNL 'Ensure that we can work with the metadata given.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=FullServerTemplate) DCNL @wsgi.deserializers(xml=ActionDeserializer) DCNL @wsgi.action('resize') DCNL def _action_resize(self, req, id, body): DCNL 'Resizes a given instance to the flavor size requested.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=FullServerTemplate) DCNL @wsgi.deserializers(xml=ActionDeserializer) DCNL @wsgi.action('rebuild') DCNL def _action_rebuild(self, req, id, body): DCNL 'Rebuild an instance with the given attributes.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=FullServerTemplate) DCNL @wsgi.deserializers(xml=ActionDeserializer) DCNL @wsgi.action('createImage') DCNL @common.check_snapshots_enabled DCNL def _action_create_image(self, req, id, body): DCNL 'Snapshot a server instance.'
def _get_server_admin_password(self, server): DCNL 'Determine the admin password for a server on creation.'
def _get_server_search_options(self): DCNL 'Return server search options allowed by non-admin.'
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, server_id): DCNL 'Returns the list of metadata for a given instance.'
@wsgi.serializers(xml=common.MetaItemTemplate) DCNL def show(self, req, server_id, id): DCNL 'Return a single metadata item.'
@wsgi.response(204) DCNL def delete(self, req, server_id, id): DCNL 'Deletes an existing metadata.'
@wsgi.serializers(xml=VersionsTemplate, atom=VersionsAtomSerializer) DCNL def index(self, req): DCNL 'Return all versions.'
@wsgi.serializers(xml=ChoicesTemplate) DCNL @wsgi.response(300) DCNL def multi(self, req): DCNL 'Return multiple choices.'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
def init_host(self): DCNL 'Perform any initialization. DCNL Currently, we only add an iptables filter rule for the metadata DCNL service.'
def __init__(self, data, limit): DCNL ':param data: Underlying data object DCNL :param limit: maximum number of bytes the reader should allow'
def process_bind_param(self, value, dialect): DCNL 'Process/Formats the value before insert it into the db.'
def process_bind_param(self, value, dialect): DCNL 'Process/Formats the value before insert it into the db.'
def __init__(self, retvalue=True): DCNL ':param retvalue: Value that LoopingCall.wait() should return.'
def rollback_and_reraise(self, msg=None, **kwargs): DCNL 'Rollback a series of actions then re-raise the exception. DCNL .. note:: (sirp) This should only be called within an DCNL exception handler.'
def get_port(self, context): DCNL 'Get available port for consoles.'
def setup_console(self, context, console): DCNL 'Sets up console.'
def teardown_console(self, context, console): DCNL 'Tears down console.'
def init_host(self): DCNL 'Perform console initialization.'
def fix_pool_password(self, password): DCNL 'Encode password.'
def generate_password(self, vim_session, pool, instance_name): DCNL 'Returns VMRC Connection credentials. DCNL Return string is of the form \'<VM PATH>:<ESX Username>@<ESX Password>\'.'
def is_otp(self): DCNL 'Is one time password or not.'
def generate_password(self, vim_session, pool, instance_name): DCNL 'Returns a VMRC Session. DCNL Return string is of the form \'<VM MOID>:<VMRC Ticket>\'.'
def is_otp(self): DCNL 'Is one time password or not.'
def get_port(self, context): DCNL 'Get available port for consoles that need one.'
def setup_console(self, context, console): DCNL 'Sets up actual proxies.'
def teardown_console(self, context, console): DCNL 'Tears down actual proxies.'
def init_host(self): DCNL 'Start up any config\'ed consoles on start.'
def fix_pool_password(self, password): DCNL 'Trim password to length, and encode.'
def fix_console_password(self, password): DCNL 'Trim password to length, and encode.'
def _xvp_encrypt(self, password, is_pool_password=False): DCNL 'Call xvp to obfuscate passwords for config file. DCNL Args: DCNL - password: the password to encode, max 8 char for vm passwords, DCNL and 16 chars for pool passwords. passwords will DCNL be trimmed to max len before encoding. DCNL - is_pool_password: True if this this is the XenServer api password DCNL False if it\'s a VM console password DCNL (xvp uses different keys and max lengths for pool passwords) DCNL Note that xvp\'s obfuscation should not be considered \'real\' encryption. DCNL It simply DES encrypts the passwords with static keys plainly viewable DCNL in the xvp source code.'
def new_client(self): DCNL 'Called after a new WebSocket connection has been established.'
def _get_vim_session(self, pool): DCNL 'Get VIM session for the pool specified.'
def _generate_console(self, context, pool, name, instance_id, instance): DCNL 'Sets up console for the instance.'
def add_console(self, context, instance_id, password=None, port=None, **kwargs): DCNL 'Adds a console for the instance. DCNL If it is one time password, then we generate new console credentials.'
def remove_console(self, context, console_id, **_kwargs): DCNL 'Removes a console entry.'
def get_pool_for_instance_host(self, context, instance_host): DCNL 'Gets console pool info for the instance.'
def setup_console(self, context, console): DCNL 'Sets up actual proxies.'
def teardown_console(self, context, console): DCNL 'Tears down actual proxies.'
def init_host(self): DCNL 'Start up any config\'ed consoles on start.'
def generate_password(self, length=8): DCNL 'Returns random console password.'
def get_port(self, context): DCNL 'Get available port for consoles that need one.'
def fix_pool_password(self, password): DCNL 'Trim password to length, and any other massaging.'
def fix_console_password(self, password): DCNL 'Trim password to length, and any other massaging.'
def __init__(self, kind, match): DCNL 'Initialize the check.'
def __call__(self, target, creds): DCNL 'Determine whether is_admin matches the requested value.'
def test_version_string_with_package_is_good(self): DCNL 'Ensure uninstalled code get version string.'
@contextlib.contextmanager DCNL def _make_base_file(self, checksum=True): DCNL 'Make a base file for testing.'
def _create_volume(self, size=0): DCNL 'Create a volume object.'
def test_spawn_fail_cleanup_1(self): DCNL 'Simulates an error while downloading an image. DCNL Verifies that the VM and VDIs created are properly cleaned up.'
def test_spawn_fail_cleanup_2(self): DCNL 'Simulates an error while creating VM record. DCNL Verifies that the VM and VDIs created are properly cleaned up.'
def test_spawn_fail_cleanup_3(self): DCNL 'Simulates an error while attaching disks. DCNL Verifies that the VM and VDIs created are properly cleaned up.'
def _create_instance(self, instance_id=1, spawn=True): DCNL 'Creates and spawns a test instance.'
def test_instance_not_auto_disk_config(self): DCNL 'Should not partition unless instance is marked as DCNL auto_disk_config.'
@stub_vm_utils_with_vdi_attached_here DCNL def test_instance_auto_disk_config_passes_fail_safes(self): DCNL 'Should partition if instance is marked as auto_disk_config=True and DCNL virt-layer specific fail-safe checks pass.'
def test_get_all_bw_counters_in_failure_case(self): DCNL 'Test that get_all_bw_conters returns an empty list when DCNL no data returned from Xenserver.  c.f. bug #910045.'
def test_add_host_to_aggregate_invalid_changing_status(self): DCNL 'Ensure InvalidAggregateAction is raised when adding host while DCNL aggregate is not ready.'
def test_add_host_to_aggregate_invalid_dismissed_status(self): DCNL 'Ensure InvalidAggregateAction is raised when aggregate is DCNL deleted.'
def test_add_host_to_aggregate_invalid_error_status(self): DCNL 'Ensure InvalidAggregateAction is raised when aggregate is DCNL in error.'
def test_remove_host_from_aggregate_invalid_dismissed_status(self): DCNL 'Ensure InvalidAggregateAction is raised when aggregate is DCNL deleted.'
def test_remove_host_from_aggregate_invalid_changing_status(self): DCNL 'Ensure InvalidAggregateAction is raised when aggregate is DCNL changing.'
def test_disassociate_auto_assigned_address(self): DCNL 'Verifies disassociating auto assigned floating IP DCNL raises an exception'
def _restart_compute_service(self, periodic_interval_max=None): DCNL 'restart compute service. NOTE: fake driver forgets all instances.'
def _do_test_create_image(self, no_reboot): DCNL 'Make sure that CreateImage works.'
def test_create_image_instance_store(self): DCNL 'Ensure CreateImage fails as expected for an instance-store-backed DCNL instance'
def _send_bad_attempts(self, access_key, num_attempts=1): DCNL 'Fail x.'
def _is_locked_out(self, access_key): DCNL 'Sends a test request to see if key is locked out.'
def test_create_volume_in_availability_zone(self): DCNL 'Makes sure create_volume works when we specify an availability DCNL zone'
def test_describe_instances_bdm(self): DCNL 'Make sure describe_instances works with root_device_name and DCNL block device mappings'
def _restart_compute_service(self, periodic_interval_max=None): DCNL 'restart compute service. NOTE: fake driver forgets all instances.'
def setUp(self): DCNL 'Run before each test.'
def test_metadata_deserializer(self): DCNL 'Should throw a 400 error on corrupt xml.'
def _prepare_xml(self, xml_string): DCNL 'Remove characters from string which hinder XML equality testing.'
def test_multi_choice_server_atom(self): DCNL 'Make sure multi choice responses do not have content-type DCNL application/atom+xml (should use default of json)'
def test_create_image_snapshots_disabled(self): DCNL 'Don\'t permit a snapshot if the allow_instance_snapshots flag is DCNL False'
def test_corrupt_xml(self): DCNL 'Should throw a 400 error on corrupt xml.'
def test_unique_host_id(self): DCNL 'Create two servers with the same host and different DCNL project_ids and check that the hostId\'s are unique'
def test_get_servers_admin_filters_as_user(self): DCNL 'Test getting servers by admin-only or unknown options when DCNL context is not admin. Make sure the admin and unknown options DCNL are stripped before they get to compute_api.get_all()'
def test_get_servers_admin_options_as_admin(self): DCNL 'Test getting servers by admin-only or unknown options when DCNL context is admin. All options should be passed'
def test_get_servers_admin_allows_ip(self): DCNL 'Test getting servers by ip with admin_api enabled and DCNL admin context'
def test_get_servers_admin_allows_ip6(self): DCNL 'Test getting servers by ip6 with admin_api enabled and DCNL admin context'
def test_get_all_server_details_with_host(self): DCNL 'We want to make sure that if two instances are on the same host, then DCNL they return the same hostId. If two instances are on different hosts, DCNL they should return different hostId\'s. In this test, there are 5 DCNL instances - 2 on one host and 3 on another.'
def setUp(self): DCNL 'Shared implementation for tests below that create instance.'
def _check_admin_pass_len(self, server_dict): DCNL 'utility function - check server_dict for adminPass length.'
def _check_admin_pass_missing(self, server_dict): DCNL 'utility function - check server_dict for absence of adminPass.'
def test_create_multiple_instances(self): DCNL 'Test creating multiple instances but not asking for DCNL reservation_id'
def test_create_multiple_instances_pass_disabled(self): DCNL 'Test creating multiple instances but not asking for DCNL reservation_id'
def test_create_multiple_instances_resv_id_return(self): DCNL 'Test creating multiple instances with asking for DCNL reservation_id'
def test_create_multiple_instances_with_multiple_volume_bdm(self): DCNL 'Test that a BadRequest is raised if multiple instances DCNL are requested with a list of block device mappings for volumes.'
def test_create_multiple_instances_with_single_volume_bdm(self): DCNL 'Test that a BadRequest is raised if multiple instances DCNL are requested to boot from a single volume.'
def test_create_instance_with_volumes_enabled_no_image(self): DCNL 'Test that the create will fail if there is no image DCNL and no bdms supplied in the request'
def test_create_instance_with_volumes_enabled_and_bdms_no_image(self): DCNL 'Test that the create works if there is no image supplied but DCNL os-volumes extension is enabled and bdms are supplied'
def test_corrupt_xml(self): DCNL 'Should throw a 400 error on corrupt xml.'
def setUp(self): DCNL 'Run before each test.'
def test_delete_deleted_image(self): DCNL 'If you try to delete a deleted image, you get back 403 Forbidden.'
def test_get_flavor_list_detail_min_ram_and_min_disk(self): DCNL 'Tests that filtering work on flavor details and that minRam and DCNL minDisk filters can be combined'
def test_show_should_include_disabled_flavor_for_user(self): DCNL 'Counterintuitively we should show disabled flavors to all users and not DCNL just admins. The reason is that, when a user performs a server-show DCNL request, we want to be able to display the pretty flavor name (\'512 MB DCNL Instance\') and not just the flavor-id even if the flavor id has been DCNL marked disabled.'
def _get_time(self): DCNL 'Return the "time" according to this test suite.'
def setUp(self): DCNL 'Run before each test.'
def _get_index_request(self, accept_header='application/json'): DCNL 'Helper to set routing arguments.'
def _populate_limits(self, request): DCNL 'Put limit info into a request.'
def _populate_limits_diff_regex(self, request): DCNL 'Put limit info into a request.'
@webob.dec.wsgify DCNL def _empty_app(self, request): DCNL 'Do-nothing WSGI app.'
def setUp(self): DCNL 'Prepare middleware for use through fake WSGI app.'
def setUp(self): DCNL 'Run before each test.'
def _check(self, num, verb, url, username=None): DCNL 'Check and yield results from checks.'
def _check_sum(self, num, verb, url, username=None): DCNL 'Check and sum results from checks.'
def test_no_delay_GET(self): DCNL 'Simple test to ensure no delay on a single call for a limit verb we DCNL didn"t set.'
def test_delay_PUT(self): DCNL 'Ensure the 11th PUT will result in a delay of 6.0 seconds until DCNL the next request will be granced.'
def test_delay_POST(self): DCNL 'Ensure the 8th POST will result in a delay of 6.0 seconds until DCNL the next request will be granced.'
def test_delay_PUT_servers(self): DCNL 'Ensure PUT on /servers limits at 5 requests, and PUT elsewhere is still DCNL OK after 5 requests...but then after 11 total requests, PUT limiting DCNL kicks in.'
def test_delay_PUT_wait(self): DCNL 'Ensure after hitting the limit and then waiting for the correct DCNL amount of time, the limit will be lifted.'
def setUp(self): DCNL 'Run before each test.'
def _request_data(self, verb, path): DCNL 'Get data describing a limit request verb/path.'
def _request(self, verb, url, username=None): DCNL 'Make sure that POSTing to the given url causes the given username DCNL to perform the given action.  Make the internal rate limiter return DCNL delay and make sure that the WSGI app returns the correct response.'
def __init__(self, response_string): DCNL 'Initialize new `FakeHttplibSocket`.'
def makefile(self, _mode, _other): DCNL 'Returns the socket\'s internal buffer.'
def __init__(self, app, host): DCNL 'Initialize `FakeHttplibConnection`.'
def request(self, method, path, body='', headers=None): DCNL 'Requests made via this connection actually get translated and routed DCNL into our WSGI app, we then wait for the response and turn it back into DCNL an `httplib.HTTPResponse`.'
def getresponse(self): DCNL 'Return our generated response from the request.'
def setUp(self): DCNL 'Do some nifty HTTP/WSGI magic which allows for WSGI to be called DCNL directly by something like the `httplib` library.'
def test_create_server_detect_from_image(self): DCNL 'If user doesn\'t pass in diskConfig for server, use image metadata DCNL to specify AUTO or MANUAL.'
def _create_floating_ips(self, floating_ips=None): DCNL 'Create a floating ip object.'
def test_create_backup_negative_rotation(self): DCNL 'Rotation must be greater than or equal to zero DCNL for backup requests'
def test_list_hosts(self): DCNL 'Verify that the compute hosts are returned.'
def _create_compute_service(self): DCNL 'Create compute-manager(ComputeNode and Service record).'
def test_show_no_project(self): DCNL 'No instances are running on the given host.'
def test_show_works_correctly(self): DCNL 'show() works correctly as expected.'
def _create_floating_ip(self): DCNL 'Create a floating ip object.'
def setUp(self): DCNL 'Run before each test.'
def _assert_no_security_groups_reserved(self, context): DCNL 'Check that no reservations are leaked during tests.'
def test_corrupt_xml(self): DCNL 'Should throw a 400 error on corrupt xml.'
def test_corrupt_xml(self): DCNL 'Should throw a 400 error on corrupt xml.'
def test_only_tests_intersect(self): DCNL 'Test that validator.validate only tests the intersect of keys DCNL from args and validator.'
def test_instance_action_start(self): DCNL 'Create an instance action.'
def test_instance_action_finish(self): DCNL 'Create an instance action.'
def test_instance_actions_get_by_instance(self): DCNL 'Ensure we can get actions by UUID.'
def test_instance_action_get_by_instance_and_action(self): DCNL 'Ensure we can get an action by instance UUID and action id.'
def test_instance_action_event_start(self): DCNL 'Create an instance action event.'
def test_instance_action_event_finish_success(self): DCNL 'Finish an instance action event.'
def test_instance_action_event_finish_error(self): DCNL 'Finish an instance action event with an error.'
def test_instance_action_and_event_start_string_time(self): DCNL 'Create an instance action and event with a string start_time.'
def test_instance_action_event_get_by_id(self): DCNL 'Get a specific instance action event.'
def test_add_key_pair(self, name=None): DCNL 'Check if keypair creation work as expected.'
def test_key_pair_destroy(self): DCNL 'Check if key pair deletion works as expected.'
def test_key_pair_get(self): DCNL 'Test if a previously created keypair can be found.'
def _restart_compute_service(self, *args, **kwargs): DCNL 'restart compute service. NOTE: fake driver forgets all instances.'
def generalize_subs(self, subs, vanilla_regexes): DCNL 'Give the test a chance to modify subs after the server response DCNL was verified, and before the on-disk doc/api_samples file is checked. DCNL This may be needed by some tests to convert exact matches expected DCNL from the server into pattern matches to verify what is in the DCNL sample file. DCNL If there are no changes to be made, subs is returned unharmed.'
def test_keypairs_post(self, public_key=None): DCNL 'Get api sample of key pairs post request.'
def test_services_list(self): DCNL 'Return a list of all agent builds.'
def test_service_enable(self): DCNL 'Enable an existing agent build.'
def test_service_disable(self): DCNL 'Disable an existing agent build.'
def setUp(self): DCNL 'setUp method for simple tenant usage.'
def tearDown(self): DCNL 'tearDown method for simple tenant usage.'
def setUp(self): DCNL 'setUp Method for AdminActions api samples extension DCNL This method creates the server that will be used in each tests'
def _create_flavor(self): DCNL 'Create a flavor.'
def _get_flags(self): DCNL 'An opportunity to setup flags, before the services are started.'
def test_run_calls_deploy(self): DCNL 'Check all queued requests are passed to deploy().'
def test_run_with_failing_deploy(self): DCNL 'Check a worker keeps on running even if deploy() raises DCNL an exception.'
def test_deploy(self): DCNL 'Check loosely all functions are called with right args.'
def test_always_logout_iscsi(self): DCNL 'logout_iscsi() must be called once login_iscsi() is called.'
def _create_instance(self): DCNL 'Create a test instance.'
def _test_get_test_network_info(self): DCNL 'Does the return value match a real network_info structure.'
def elevated(self): DCNL 'Return a consistent elevated context so we can detect it.'
def _create_vm(self): DCNL 'Create and spawn the VM.'
def _check_vm_record(self): DCNL 'Check if the spawned VM\'s properties correspond to the instance in DCNL the db.'
def _check_vm_info(self, info, pwr_state=power_state.RUNNING): DCNL 'Check if the get_info returned values correspond to the instance DCNL object in the db.'
def hgetall(self, key): DCNL 'Returns the hash for the given key; creates DCNL the hash if the key doesn\'t exist.'
def simple_bind_s(self, dn, password): DCNL 'This method is ignored, but provided for compatibility.'
def unbind_s(self): DCNL 'This method is ignored, but provided for compatibility.'
def add_s(self, dn, attr): DCNL 'Add an object with the specified attributes at dn.'
def delete_s(self, dn): DCNL 'Remove the ldap object at specified dn.'
def modify_s(self, dn, attrs): DCNL 'Modify the object at dn using the attribute list. DCNL :param dn: a dn DCNL :param attrs: a list of tuples in the following form:: DCNL ([MOD_ADD | MOD_DELETE | MOD_REPACE], attribute, value)'
def search_s(self, dn, scope, query=None, fields=None): DCNL 'Search for all matching objects under dn using the query. DCNL Args: DCNL dn -- dn to search under DCNL scope -- only SCOPE_BASE and SCOPE_SUBTREE are supported DCNL query -- query to filter objects by DCNL fields -- fields to return. Returns all fields if not specified'
@property DCNL def __prefix(self): DCNL 'Get the prefix to use for all keys.'
def match(self, d2): DCNL 'Assert two dicts are equivalent. DCNL This is a \'deep\' match in the sense that it handles nested DCNL dictionaries appropriately. DCNL NOTE: DCNL If you don\'t care (or don\'t know) a given value, you can specify DCNL the string DONTCARE as the value. This will cause that dict-item DCNL to be skipped.'
def match(self, l2): DCNL 'Assert a list of dicts are equivalent.'
def match(self, sub_dict): DCNL 'Assert a sub_dict is subset of super_dict.'
def node(self, tag, idx): DCNL 'Adds tag and index to the path; they will be popped off when DCNL the corresponding \'with\' statement exits. DCNL :param tag: The element tag DCNL :param idx: If not None, the integer index of the element DCNL within its parent.  Not included in the path DCNL element if None.'
def _compare_node(self, expected, actual, state, idx): DCNL 'Recursively compares nodes within the XML tree.'
def test_set_availability_zone_compute_service(self): DCNL 'Test for compute service get right availability zone.'
def test_set_availability_zone_not_compute_service(self): DCNL 'Test not compute service get right availability zone.'
def test_get_host_availability_zone(self): DCNL 'Test get right availability zone by given host.'
def test_get_availability_zones(self): DCNL 'Test get_availability_zones.'
def create_fake_libvirt_mock(self, **kwargs): DCNL 'Defining mocks for LibvirtDriver(libvirt is not used).'
def test_failing_vcpu_count(self): DCNL 'Domain can fail to return the vcpu description in case it\'s DCNL just starting up or shutting down. Make sure None is handled DCNL gracefully.'
def _create_instance_type(self, params=None): DCNL 'Create a test instance.'
def _create_instance(self, params=None): DCNL 'Create a test instance.'
def test_migrate_disk_and_power_off_exception(self): DCNL 'Test for nova.virt.libvirt.libvirt_driver.LivirtConnection DCNL .migrate_disk_and_power_off.'
def test_migrate_disk_and_power_off(self): DCNL 'Test for nova.virt.libvirt.libvirt_driver.LivirtConnection DCNL .migrate_disk_and_power_off.'
def test_finish_migration(self): DCNL 'Test for nova.virt.libvirt.libvirt_driver.LivirtConnection DCNL .finish_migration.'
def test_finish_revert_migration(self): DCNL 'Test for nova.virt.libvirt.libvirt_driver.LivirtConnection DCNL .finish_revert_migration.'
def test_create_without_instance_id(self): DCNL 'Ensure we can create an image without having to specify an DCNL instance_id. Public images are an example of an image not tied to an DCNL instance.'
def detail(self, context, **kwargs): DCNL 'Return list of detailed image information.'
def show(self, context, image_id): DCNL 'Get data about specified image. DCNL Returns a dict containing image data for the given opaque image id.'
def create(self, context, metadata, data=None): DCNL 'Store the image data and return the new image id. DCNL :raises: Duplicate if the image already exist.'
def update(self, context, image_id, metadata, data=None, purge_props=False): DCNL 'Replace the contents of the given image with the new data. DCNL :raises: ImageNotFound if the image does not exist.'
def delete(self, context, image_id): DCNL 'Delete the given image. DCNL :raises: ImageNotFound if the image does not exist.'
def get_volumes_5678(self, **kw): DCNL 'Volume with image metadata.'
def fake_oat_request(self, *args, **kwargs): DCNL 'Stubs out the response from OAT service.'
def test_filter_hosts_avoid(self): DCNL 'Test to make sure _filter_hosts() filters original hosts if DCNL avoid_original_host is True.'
def test_filter_hosts_no_avoid(self): DCNL 'Test to make sure _filter_hosts() does not filter original DCNL hosts if avoid_original_host is False.'
def test_schedule_happy_day(self): DCNL 'Make sure there\'s nothing glaringly wrong with _schedule() DCNL by doing a happy day pass through.'
def test_schedule_host_pool(self): DCNL 'Make sure the scheduler_host_subset_size property works properly.'
def test_schedule_large_host_pool(self): DCNL 'Hosts should still be chosen if pool size DCNL is larger than number of filtered hosts'
def test_schedule_chooses_best_host(self): DCNL 'If scheduler_host_subset_size is 1, the largest host with greatest DCNL weight should be returned'
def test_select_hosts_happy_day(self): DCNL 'select_hosts is basically a wrapper around the _select() method. DCNL Similar to the _select tests, this just does a happy path test to DCNL ensure there is nothing glaringly wrong.'
def __init__(self, context=None, params=None, type_name='m1.tiny'): DCNL 'Create a test instance. Returns uuid.'
def _create_fake_instance(self, params=None, type_name='m1.tiny'): DCNL 'Create a test instance.'
def host_call_plugin(self, _1, _2, plugin, method, args): DCNL 'Mock method four host_call_plugin to be used in unit tests DCNL for the dom0 iptables Firewall drivers for XenAPI'
def _create_instance(self, cores=2): DCNL 'Create a test instance.'
def makefile(self, _mode, _other): DCNL 'Returns the socket\'s internal buffer.'
def close(self): DCNL 'Required for compatibility with boto/tornado.'
def expect_http(self, host=None, is_secure=False, api_version=None): DCNL 'Returns a new EC2 connection.'
def test_return_valid_isoformat(self): DCNL 'Ensure that the ec2 api returns datetime in xs:dateTime DCNL (which apparently isn\'t datetime.isoformat()) DCNL NOTE(ken-pepple): https://bugs.launchpad.net/nova/+bug/721297'
def test_describe_instances(self): DCNL 'Test that, after creating a user and a project, the describe DCNL instances call to the API works properly'
def test_get_all_key_pairs(self): DCNL 'Test that, after creating a user and project and generating DCNL a key pair, that the API call to list key pairs works properly'
def test_create_duplicate_key_pair(self): DCNL 'Test that, after successfully generating a keypair, DCNL requesting a second keypair with the same name fails sanely'
def test_group_name_valid_chars_security_group(self): DCNL 'Test that we sanely handle invalid security group names. DCNL EC2 API Spec states we should only accept alphanumeric characters, DCNL spaces, dashes, and underscores. Amazon implementation DCNL accepts more characters - so, [:print:] is ok.'
def test_group_name_valid_length_security_group(self): DCNL 'Test that we sanely handle invalid security group names. DCNL API Spec states that the length should not exceed 255 chars'
def test_authorize_revoke_security_group_cidr(self): DCNL 'Test that we can add and remove CIDR based rules DCNL to a security group'
def test_authorize_revoke_security_group_cidr_v6(self): DCNL 'Test that we can add and remove CIDR based rules DCNL to a security group for IPv6'
def test_authorize_revoke_security_group_foreign_group(self): DCNL 'Test that we can grant and revoke another security group access DCNL to a security group'
def _mock_assert_host_exists(self): DCNL 'Sets it so that the host API always thinks that \'fake_host\' DCNL exists.'
def _limits(self, memory_mb=FAKE_VIRT_MEMORY_MB, disk_gb=FAKE_VIRT_LOCAL_GB, vcpus=FAKE_VIRT_VCPUS): DCNL 'Create limits dictionary used for oversubscribing resources.'
def _create_fake_instance(self, params=None, type_name='m1.tiny'): DCNL 'Create a test instance.'
def _create_instance(self, params=None, type_name='m1.tiny'): DCNL 'Create a test instance. Returns uuid.'
def _create_instance_type(self, params=None): DCNL 'Create a test instance type.'
def test_create_instance_with_oversubscribed_ram_fail(self): DCNL 'Test passing of oversubscribed ram policy from the scheduler, but DCNL with insufficient memory.'
def test_create_instance_with_oversubscribed_disk_fail(self): DCNL 'Test passing of oversubscribed disk policy from the scheduler, but DCNL with insufficient disk.'
def test_run_instance_setup_block_device_mapping_fail(self): DCNL 'block device mapping failure test. DCNL Make sure that when there is a block device mapping problem, DCNL the instance goes to ERROR state, keeping the task state'
def test_run_instance_spawn_fail(self): DCNL 'spawn failure test. DCNL Make sure that when there is a spawning problem, DCNL the instance goes to ERROR state, keeping the task state'
def test_run_instance_dealloc_network_instance_not_found(self): DCNL 'spawn network deallocate test. DCNL Make sure that when an instance is not found during spawn DCNL that the network is deallocated'
def test_run_terminate_with_vol_attached(self): DCNL 'Make sure it is possible to  run and terminate instance with volume DCNL attached'
def test_run_terminate_no_image(self): DCNL 'Make sure instance started without image (from volume) DCNL can be termintad without issues'
def test_terminate_failure_leaves_task_state(self): DCNL 'Ensure that a failure in terminate_instance does not result DCNL in the task state being reverted from DELETING (see LP 1046236).'
def _do_test_set_admin_password_driver_error(self, exc, expected_vm_state, expected_task_state, expected_exception): DCNL 'Ensure expected exception is raised if set_admin_password fails.'
def test_set_admin_password_driver_not_authorized(self): DCNL 'Ensure expected exception is raised if set_admin_password not DCNL authorized.'
def test_set_admin_password_driver_not_implemented(self): DCNL 'Ensure expected exception is raised if set_admin_password not DCNL implemented by driver.'
def _assert_state(self, state_dict): DCNL 'Assert state of VM is equal to state passed as parameter.'
def test_instance_termination_exception_sets_error(self): DCNL 'Test that we handle InstanceTerminationFailure DCNL which is propagated up from the underlying driver.'
def _ensure_quota_reservations_committed(self, expect_project=False): DCNL 'Mock up commit of quota reservations.'
def _ensure_quota_reservations_rolledback(self, expect_project=False): DCNL 'Mock up rollback of quota reservations.'
def test_finish_resize_with_volumes(self): DCNL 'Contrived test to ensure finish_resize doesn\'t raise anything.'
def test_prep_resize_instance_migration_error_on_same_host(self): DCNL 'Ensure prep_resize raise a migration error if destination is set on DCNL the same source host and allow_resize_to_same_host is false'
def test_prep_resize_instance_migration_error_on_none_host(self): DCNL 'Ensure prep_resize raises a migration error if destination host is DCNL not defined'
def test_resize_same_source_fails(self): DCNL 'Ensure instance fails to migrate when source and destination are DCNL the same host'
def test_post_live_migration_no_shared_storage_working_correctly(self): DCNL 'Confirm post_live_migration() works correctly as expected DCNL for non shared storage migration.'
def test_init_instance_update_nw_info_cache_legacy(self): DCNL 'network_info in legacy is form [(network_dict, info_dict)].'
def test_init_instance_update_nw_info_cache(self): DCNL 'network_info is NetworkInfo list-like object.'
def test_snapshot_given_image_uuid(self): DCNL 'Ensure a snapshot of an instance can be created when image UUID DCNL is already known.'
def test_snapshot_minram_mindisk_VHD(self): DCNL 'Ensure a snapshots min_ram and min_disk are correct. DCNL A snapshot of a non-shrinkable VHD should have min_disk DCNL set to that of the original instances flavor.'
def test_snapshot_minram_mindisk(self): DCNL 'Ensure a snapshots min_ram and min_disk are correct. DCNL A snapshot of an instance should have min_ram and min_disk DCNL set to that of the instances original image unless that DCNL image had a disk format of vhd.'
def test_snapshot_minram_mindisk_img_missing_minram(self): DCNL 'Ensure a snapshots min_ram and min_disk are correct. DCNL Do not show an attribute that the orig img did not have.'
def test_snapshot_minram_mindisk_no_image(self): DCNL 'Ensure a snapshots min_ram and min_disk are correct. DCNL A snapshots min_ram and min_disk should be set to default if DCNL an instances original image cannot be found.'
def test_reservation_id_one_instance(self): DCNL 'Verify building an instance has a reservation_id that DCNL matches return value from create'
def test_reservation_ids_two_instances(self): DCNL 'Verify building 2 instances at once results in a DCNL reservation_id being returned equal to reservation id set DCNL in both instances'
def test_reschedule_or_reraise_called(self): DCNL 'Basic sanity check to make sure _reschedule_or_reraise is called DCNL when a build fails.'
def test_shutdown_instance_fail(self): DCNL 'Test shutdown instance failing before re-scheduling logic can even DCNL run.'
def test_reschedule_resize_or_reraise_called(self): DCNL 'Verify the rescheduling logic gets called when there is an error DCNL during prep_resize.'
def test_reschedule_fails_with_exception(self): DCNL 'Original exception should be raised if the _reschedule method DCNL raises another exception'
def test_reschedule_false(self): DCNL 'Original exception should be raised if the resize is not DCNL rescheduled.'
def test_rebuild_on_host_updated_target(self): DCNL 'Confirm evacuate scenario updates host.'
def test_rebuild_with_wrong_shared_storage(self): DCNL 'Confirm evacuate scenario does not update host.'
def test_rebuild_on_host_with_volumes(self): DCNL 'Confirm evacuate scenario reconnects volumes.'
def test_rebuild_on_host_with_shared_storage(self): DCNL 'Confirm evacuate scenario on shared storage.'
def test_rebuild_on_host_without_shared_storage(self): DCNL 'Confirm evacuate scenario without shared storage DCNL (rebuild from image)'
def test_rebuild_on_host_instance_exists(self): DCNL 'Rebuild if instance exists raises an exception.'
def _create_instance(self, params={}): DCNL 'Create a test instance.'
def test_mysql_connect_fail(self): DCNL 'Test that we can trigger a mysql connection failure and we fail DCNL gracefully to ensure we don\'t break people without mysql'
def test_postgresql_connect_fail(self): DCNL 'Test that we can trigger a postgres connection failure and we fail DCNL gracefully to ensure we don\'t break people without postgres'
def _migrate_up(self, engine, version, with_data=False): DCNL 'migrate up to a new version of the db. DCNL We allow for data insertion and post checks at every DCNL migration version with special _pre_upgrade_### and DCNL _check_### functions in the main test.'
def test_ip_association_and_allocation_of_other_project(self): DCNL 'Makes sure that we cannot deallocaate or disassociate DCNL a public ip of other project'
def test_deallocate_fixed(self): DCNL 'Verify that release is called properly. DCNL Ensures https://bugs.launchpad.net/nova/+bug/973442 doesn\'t return'
def test_deallocate_fixed_no_vif(self): DCNL 'Verify that deallocate doesn\'t raise when no vif is returned. DCNL Ensures https://bugs.launchpad.net/nova/+bug/968457 doesn\'t return'
def test_flatdhcpmanager_static_fixed_range(self): DCNL 'Test FlatDHCPManager NAT rules for fixed_range.'
def test_flatdhcpmanager_dynamic_fixed_range(self): DCNL 'Test FlatDHCPManager NAT rules for fixed_range.'
def test_vlanmanager_static_fixed_range(self): DCNL 'Test VlanManager NAT rules for fixed_range.'
def test_vlanmanager_dynamic_fixed_range(self): DCNL 'Test VlanManager NAT rules for fixed_range.'
def test_rpc_allocate(self): DCNL 'Test to verify bug 855030 doesn\'t resurface. DCNL Mekes sure _rpc_allocate_fixed_ip returns a value so the call DCNL returns properly and the greenpool completes.'
def test_allocate_for_instance_ex1(self): DCNL 'verify we will delete created ports DCNL if we fail to allocate all net resources. DCNL Mox to raise exception when creating a second port. DCNL In this case, the code should delete the first created port.'
def test_allocate_for_instance_ex2(self): DCNL 'verify we have no port to delete DCNL if we fail to allocate the first net resource. DCNL Mox to raise exception when creating the first port. DCNL In this case, the code should not delete any ports.'
def test_validate_networks_duplicate(self): DCNL 'Verify that the correct exception is thrown when duplicate DCNL network ids are passed to validate_networks.'
def _do_test_associate_floating_ip(self, orig_instance_uuid): DCNL 'Test post-association logic.'
def test_linux_bridge_driver_plug(self): DCNL 'Makes sure plug doesn\'t drop FORWARD by default. DCNL Ensures bug 890195 doesn\'t reappear.'
def test_vlan_override(self): DCNL 'Makes sure vlan_interface flag overrides network bridge_interface. DCNL Allows heterogeneous networks a la bug 833426'
def test_flat_override(self): DCNL 'Makes sure flat_interface flag overrides network bridge_interface. DCNL Allows heterogeneous networks a la bug 833426'
def _generate_name(self): DCNL 'return a name not in the DB.'
def _generate_flavorid(self): DCNL 'return a flavorid not in the DB.'
def _existing_flavor(self): DCNL 'return first instance type name.'
def test_read_deleted_false_converting_flavorid(self): DCNL 'Ensure deleted instance types are not returned when not needed (for DCNL example when creating a server and attempting to translate from DCNL flavorid to instance_type_id.'
def setUp(self): DCNL 'Setup users, projects, and start a test server.'
def tearDown(self): DCNL 'Tear down test server.'
def instance_update(self, context, instance_uuid, **updates): DCNL 'Perform an instance update in the database.'
def wait_until_ready(self, context, early_timeout=10, early_attempts=10): DCNL 'Wait until a conductor service is up and running. DCNL This method calls the remote ping() method on the conductor topic until DCNL it gets a response.  It starts with a shorter timeout in the loop DCNL (early_timeout) up to early_attempts number of tries.  It then drops DCNL back to the globally configured timeout for rpc calls for each retry.'
def instance_update(self, context, instance_uuid, **updates): DCNL 'Perform an instance update in the database.'
def __init__(self): DCNL 'Initialize the service launcher. DCNL :returns: None'
@staticmethod DCNL def run_server(server): DCNL 'Start and wait for a server to finish. DCNL :param service: Server to run and wait for. DCNL :returns: None'
def launch_server(self, server): DCNL 'Load and start the given server. DCNL :param server: The server you would like to start. DCNL :returns: None'
def stop(self): DCNL 'Stop all services which are currently running. DCNL :returns: None'
def wait(self): DCNL 'Waits until all services have been stopped, and then returns. DCNL :returns: None'
def wait(self): DCNL 'Loop waiting on children to die and respawning as necessary.'
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_enable=None, periodic_fuzzy_delay=None, periodic_interval_max=None, db_allowed=True): DCNL 'Instantiates class and passes back application object. DCNL :param host: defaults to CONF.host DCNL :param binary: defaults to basename of executable DCNL :param topic: defaults to bin_name - \'nova-\' part DCNL :param manager: defaults to CONF.<topic>_manager DCNL :param report_interval: defaults to CONF.report_interval DCNL :param periodic_enable: defaults to CONF.periodic_enable DCNL :param periodic_fuzzy_delay: defaults to CONF.periodic_fuzzy_delay DCNL :param periodic_interval_max: if set, the max time to wait between runs'
def kill(self): DCNL 'Destroy the service object in the datastore.'
def periodic_tasks(self, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def basic_config_check(self): DCNL 'Perform basic config checks before starting processing.'
def __init__(self, name, loader=None, use_ssl=False, max_url_len=None): DCNL 'Initialize, but do not start the WSGI server. DCNL :param name: The name of the WSGI server given to the loader. DCNL :param loader: Loads the WSGI application using the given name. DCNL :returns: None'
def _get_manager(self): DCNL 'Initialize a Manager object appropriate for this service. DCNL Use the service name to look up a Manager subclass from the DCNL configuration and initialize an instance. If no class name DCNL is configured, just return None. DCNL :returns: a Manager instance, or None.'
def start(self): DCNL 'Start serving this service using loaded configuration. DCNL Also, retrieve updated port number in case \'0\' was passed in, which DCNL indicates a random port should be used. DCNL :returns: None'
def stop(self): DCNL 'Stop serving this API. DCNL :returns: None'
def wait(self): DCNL 'Wait for the service to stop serving this API. DCNL :returns: None'
def format(self, record): DCNL 'Uses contextstring if request_id is set, otherwise default.'
def formatException(self, exc_info, record=None): DCNL 'Format exception output with CONF.logging_exception_prefix.'
def __init__(self, *args, **kwargs): DCNL 'Ignores the passed in args.'
def get(self, key): DCNL 'Retrieves the value for a key or None. DCNL this expunges expired keys during each get'
def set(self, key, value, time=0, min_compress_len=0): DCNL 'Sets the value for a key.'
def add(self, key, value, time=0, min_compress_len=0): DCNL 'Sets the value for a key if it doesn\'t exist.'
def incr(self, key, delta=1): DCNL 'Increments the value for a key.'
def delete(self, key, time=0): DCNL 'Deletes the value associated with a key.'
def __init__(self, topic, default_version): DCNL 'Initialize an RpcProxy. DCNL :param topic: The topic to use for all messages. DCNL :param default_version: The default API version to request in all DCNL outgoing messages.  This can be overridden on a per-message DCNL basis.'
def _set_version(self, msg, vers): DCNL 'Helper method to set the version in a message. DCNL :param msg: The message having a version added to it. DCNL :param vers: The version number to add to the message.'
def _get_topic(self, topic): DCNL 'Return the topic to use for a message.'
def call(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.call() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: The return value from the remote method.'
def multicall(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.multicall() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: An iterator that lets you process each of the returned values DCNL from the remote method as they arrive.'
def cast(self, context, msg, topic=None, version=None): DCNL 'rpc.cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast() does not wait on any return value from the DCNL remote method.'
def fanout_cast(self, context, msg, topic=None, version=None): DCNL 'rpc.fanout_cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast() does not wait on any return value DCNL from the remote method.'
def cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast_to_server() does not wait on any DCNL return values.'
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.fanout_cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast_to_server() does not wait on any DCNL return values.'
def __init__(self, conf, connection_pool, pooled=True, server_params=None): DCNL 'Create a new connection, or get one from the pool'
def __enter__(self): DCNL 'When with ConnectionContext() is used, return self'
def _done(self): DCNL 'If the connection came from a pool, clean it up and put it back. DCNL If it did not come from a pool, close it.'
def __exit__(self, exc_type, exc_value, tb): DCNL 'End of \'with\' statement.  We\'re done here.'
def __del__(self): DCNL 'Caller is done with this connection.  Make sure we cleaned up.'
def close(self): DCNL 'Caller is done with this connection.'
def __getattr__(self, key): DCNL 'Proxy all other calls to the Connection instance'
def check_duplicate_message(self, message_data): DCNL 'AMQP consumers may read same message twice when exceptions occur DCNL before ack is returned. This method prevents doing it.'
def wait(self): DCNL 'Wait for all callback threads to exit.'
def __init__(self, conf, callback, connection_pool): DCNL ':param conf: cfg.CONF instance DCNL :param callback: a callable (probably a function) DCNL :param connection_pool: connection pool as returned by DCNL get_connection_pool()'
def __call__(self, message_data): DCNL 'Consumer callback to call a method on a proxy object. DCNL Parses the message for validity and fires off a thread to call the DCNL proxy object method. DCNL Message data should be a dictionary with two keys: DCNL method: string representing the method to call DCNL args: dictionary of arg: value DCNL Example: {\'method\': \'echo\', \'args\': {\'value\': 42}}'
def _process_data(self, ctxt, version, method, args): DCNL 'Process a message in a new thread. DCNL If the proxy object we have has a dispatch method DCNL (see rpc.dispatcher.RpcDispatcher), pass it the version, DCNL method, and args and let it dispatch as appropriate.  If not, use DCNL the old behavior of magically calling the specified method on the DCNL proxy we have here.'
def __iter__(self): DCNL 'Return a result until we get a reply with an \'ending" flag'
def __call__(self, data): DCNL 'The consume() callback will call this.  Store the result.'
def __iter__(self): DCNL 'Return a result until we get a \'None\' response from consumer'
def __init__(self, callbacks): DCNL 'Initialize the rpc dispatcher. DCNL :param callbacks: List of proxy objects that are an instance DCNL of a class with rpc methods exposed.  Each proxy DCNL object should have an RPC_API_VERSION attribute.'
def dispatch(self, ctxt, version, method, **kwargs): DCNL 'Dispatch a message based on a requested version. DCNL :param ctxt: The request context DCNL :param version: The requested API version from the incoming message DCNL :param method: The method requested to be called by the incoming DCNL message. DCNL :param kwargs: A dict of keyword arguments to be passed to the method. DCNL :returns: Whatever is returned by the underlying method that gets DCNL called.'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a key.host is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def is_alive(self, topic, host): DCNL 'Checks if a host is alive.'
def expire(self, topic, host): DCNL 'Explicitly expire a host\'s registration.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Spawn heartbeat greenthread.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a host.topic is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def backend_register(self, key, host): DCNL 'Implements registration logic. DCNL Called by register(self,key,host)'
def backend_unregister(self, key, key_host): DCNL 'Implements de-registration logic. DCNL Called by unregister(self,key,host)'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Implementation of MatchMakerBase.start_heartbeat DCNL Launches greenthread looping send_heartbeats(), DCNL yielding for CONF.matchmaker_heartbeat_freq seconds DCNL between iterations.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts): DCNL 'Declare a queue on an amqp session. DCNL \'session\' is the amqp session to use DCNL \'callback\' is the callback to call when messages are received DCNL \'node_name\' is the first part of the Qpid address string, before \';\' DCNL \'node_opts\' will be applied to the "x-declare" section of "node" DCNL in the address string. DCNL \'link_name\' goes into the "name" field of the "link" in the address DCNL string DCNL \'link_opts\' will be applied to the "x-declare" section of "link" DCNL in the address string.'
def reconnect(self, session): DCNL 'Re-declare the receiver after a qpid reconnect'
def consume(self): DCNL 'Fetch the message and pass it to the callback object'
def __init__(self, conf, session, msg_id, callback): DCNL 'Init a \'direct\' queue. DCNL \'session\' is the amqp session to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None): DCNL 'Init a \'topic\' queue. DCNL :param session: the amqp session to use DCNL :param topic: is the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param name: optional queue name, defaults to topic'
def __init__(self, conf, session, topic, callback): DCNL 'Init a \'fanout\' queue. DCNL \'session\' is the amqp session to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, session, node_name, node_opts=None): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, session): DCNL 'Re-establish the Sender after a reconnection'
def send(self, msg): DCNL 'Send a message'
def __init__(self, conf, session, msg_id): DCNL 'Init a \'direct\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'fanout\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing sessions and queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
def socket_s(self): DCNL 'Get socket type as string.'
def subscribe(self, msg_filter): DCNL 'Subscribe.'
def unsubscribe(self, msg_filter): DCNL 'Unsubscribe.'
def _get_response(self, ctx, proxy, topic, data): DCNL 'Process a curried message and cast the result to topic.'
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None): DCNL 'Reply to a casted call.'
def consume_in_thread(self): DCNL 'Runs the ZmqProxy service'
def close(self): DCNL 'Close the connection. DCNL This method must be called when the connection will no longer be used. DCNL It will ensure that any resources associated with the connection, such DCNL as a network connection, and cleaned up.'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer on this connection. DCNL A consumer is associated with a message queue on the backend message DCNL bus.  The consumer will read messages from the queue, unpack them, and DCNL dispatch them to the proxy object.  The contents of the message pulled DCNL off of the queue will determine which method gets called on the proxy DCNL object. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. For example, all instances of nova-compute consume DCNL from a queue called "compute".  In that case, the DCNL messages will get distributed amongst the consumers in a DCNL round-robin fashion if fanout=False.  If fanout=True, DCNL every consumer associated with this topic will get a DCNL copy of every message. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param fanout: Whether or not this is a fanout topic.  See the DCNL documentation for the topic parameter for some DCNL additional comments on this.'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker on this connection. DCNL A worker is like a regular consumer of messages directed to a DCNL topic, except that it is part of a set of such consumers (the DCNL "pool") which may run in parallel. Every pool of workers will DCNL receive a given message, but only one worker in the pool will DCNL be asked to process it. Load is distributed across the members DCNL of the pool in round-robin fashion. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param pool_name: String containing the name of the pool of workers'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created. DCNL :param callback: Callable to be invoked for each message. DCNL :type callback: callable accepting one argument DCNL :param pool_name: The name of the consumer pool. DCNL :type pool_name: str DCNL :param topic: The routing topic for desired messages. DCNL :type topic: str DCNL :param exchange_name: The name of the message exchange where DCNL the client should attach. Defaults to DCNL the configured exchange. DCNL :type exchange_name: str'
def consume_in_thread(self): DCNL 'Spawn a thread to handle incoming messages. DCNL Spawn a thread that will be responsible for handling all incoming DCNL messages for consumers that were set up on this connection. DCNL Message dispatching inside of this is expected to be implemented in a DCNL non-blocking manner.  An example implementation would be having this DCNL thread pull messages in for all of the consumers, but utilize a thread DCNL pool for dispatching the messages to the proxy objects.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
def __init__(self, channel, callback, tag, **kwargs): DCNL 'Declare a queue on an amqp channel. DCNL \'channel\' is the amqp channel to use DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL queue name, exchange name, and other kombu options are DCNL passed in here as a dictionary.'
def reconnect(self, channel): DCNL 'Re-declare the queue after a rabbit reconnect'
def consume(self, *args, **kwargs): DCNL 'Actually declare the consumer on the amqp channel.  This will DCNL start the flow of messages from the queue.  Using the DCNL Connection.iterconsume() iterator will process the messages, DCNL calling the appropriate callback. DCNL If a callback is specified in kwargs, use that.  Otherwise, DCNL use the callback passed during __init__() DCNL If kwargs[\'nowait\'] is True, then this call will block until DCNL a message is read. DCNL Messages will automatically be acked if the callback doesn\'t DCNL raise an exception'
def cancel(self): DCNL 'Cancel the consuming from the queue, if it has started'
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs): DCNL 'Init a \'direct\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs): DCNL 'Init a \'topic\' queue. DCNL :param channel: the amqp channel to use DCNL :param topic: the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param tag: a unique ID for the consumer on the channel DCNL :param name: optional queue name, defaults to topic DCNL :paramtype name: str DCNL Other kombu options may be passed as keyword arguments'
def __init__(self, conf, channel, topic, callback, tag, **kwargs): DCNL 'Init a \'fanout\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, channel, exchange_name, routing_key, **kwargs): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, channel): DCNL 'Re-establish the Producer after a rabbit reconnection'
def send(self, msg, timeout=None): DCNL 'Send a message'
def __init__(self, conf, channel, msg_id, **kwargs): DCNL 'init a \'direct\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'topic\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'fanout\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def _fetch_ssl_params(self): DCNL 'Handles fetching what ssl params DCNL should be used for the connection (if any)'
def _connect(self, params): DCNL 'Connect to rabbit.  Re-establish any queues that may have DCNL been declared before if we are reconnecting.  Exceptions should DCNL be handled by the caller.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing queues. DCNL Will retry up to self.max_retries number of times. DCNL self.max_retries = 0 means to retry forever. DCNL Sleep between tries, starting at self.interval_start DCNL seconds, backing off self.interval_stepping number of seconds DCNL each attempt.'
def get_channel(self): DCNL 'Convenience call for bin/clear_rabbit_queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
def _add_callback(self, callback, event_type, user_data=None): DCNL 'Add callback for a given event notification. DCNL Subclasses can call this as an alternative to implementing DCNL a fullblown notify notifier.'
def _remove_callback(self, callback): DCNL 'Remove all notification callbacks to specified function.'
def _add_api_extension_descriptor(self, descriptor): DCNL 'Subclass convenience method which adds an extension descriptor. DCNL Subclass constructors should call this method when DCNL extending a project\'s REST interface. DCNL Note that once the api service has loaded, the DCNL API extension set is more-or-less fixed, so DCNL this should mainly be called by subclass constructors.'
def _add_notifier(self, notifier): DCNL 'Subclass convenience method which adds a notifier. DCNL Notifier objects should implement the function notify(message). DCNL Each notifier receives a notify() call whenever an openstack DCNL service broadcasts a notification. DCNL Best to call this during construction.  Notifiers are enumerated DCNL and registered by the pluginmanager at plugin load time.'
def _notifiers(self): DCNL 'Returns list of notifiers for this plugin.'
def _api_extension_descriptors(self): DCNL 'Return a list of API extension descriptors. DCNL Called by a project API during its load sequence.'
def __init__(self, project_name, service_name): DCNL 'Construct Plugin Manager; load and initialize plugins. DCNL project_name (e.g. \'nova\' or \'glance\') is used DCNL to construct the entry point that identifies plugins. DCNL The service_name (e.g. \'compute\') is passed on to DCNL each plugin as a raw string for it to do what it will.'
def save(self, session=None): DCNL 'Save this object.'
def update(self, values): DCNL 'Make the model object behave like a dict.'
def iteritems(self): DCNL 'Make the model object behave like a dict. DCNL Includes attributes from joins.'
def soft_delete(self, session=None): DCNL 'Mark this object as deleted.'
@lockutils.synchronized('dbapi_backend', 'nova-') DCNL def __get_backend(self): DCNL 'Get the actual backend.  May be a module or an instance of DCNL a class.  Doesn\'t matter to us.  We do this synchronized as it\'s DCNL possible multiple greenthreads started very quickly trying to do DCNL DB calls and eventlet can switch threads before self.__backend gets DCNL assigned.'
@classmethod DCNL def load_json(cls, data, default_rule=None): DCNL 'Allow loading of JSON rule data.'
def __init__(self, rules=None, default_rule=None): DCNL 'Initialize the Rules store.'
def __missing__(self, key): DCNL 'Implements the default rule handling.'
def __str__(self): DCNL 'Dumps a string representation of the rules.'
@abc.abstractmethod DCNL def __str__(self): DCNL 'Retrieve a string representation of the Check tree rooted at DCNL this node.'
@abc.abstractmethod DCNL def __call__(self, target, cred): DCNL 'Perform the check.  Returns False to reject the access or a DCNL true value (not necessary True) to accept the access.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __init__(self, kind, match): DCNL ':param kind: The kind of the check, i.e., the field before the DCNL :param match: The match of the check, i.e., the field after DCNL the \':\'.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __init__(self, rule): DCNL 'Initialize the \'not\' check. DCNL :param rule: The rule to negate.  Must be a Check.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Returns the logical inverse of the wrapped DCNL check.'
def __init__(self, rules): DCNL 'Initialize the \'and\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Requires that all rules accept in order to DCNL return True.'
def add_check(self, rule): DCNL 'Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the AndCheck object for convenience.'
def __init__(self, rules): DCNL 'Initialize the \'or\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Requires that at least one rule accept in DCNL order to return True.'
def add_check(self, rule): DCNL 'Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the OrCheck object for convenience.'
def __new__(mcs, name, bases, cls_dict): DCNL 'Create the class.  Injects the \'reducers\' list, a list of DCNL tuples matching token sequences to the names of the DCNL corresponding reduction methods.'
def __init__(self): DCNL 'Initialize the ParseState.'
def reduce(self): DCNL 'Perform a greedy reduction of the token stream.  If a reducer DCNL method matches, it will be executed, then the reduce() method DCNL will be called recursively to search for any more possible DCNL reductions.'
def shift(self, tok, value): DCNL 'Adds one more token to the state.  Calls reduce().'
@property DCNL def result(self): DCNL 'Obtain the final result of the parse.  Raises ValueError if DCNL the parse failed to reduce to a single result.'
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2): DCNL 'Turn parenthesized expressions into a \'check\' token.'
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2): DCNL 'Create an \'and_expr\' from two checks joined by the \'and\' DCNL operator.'
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check): DCNL 'Extend an \'and_expr\' by adding one more check.'
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2): DCNL 'Create an \'or_expr\' from two checks joined by the \'or\' DCNL operator.'
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check): DCNL 'Extend an \'or_expr\' by adding one more check.'
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check): DCNL 'Invert the result of another check.'
def __call__(self, target, creds): DCNL 'Recursively checks credentials based on the defined rules.'
def __call__(self, target, creds): DCNL 'Check that there is a matching role in the cred dict.'
def __call__(self, target, creds): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response DCNL is exactly \'True\'.'
def __call__(self, target, creds): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def __str__(self): DCNL 'Make the VersionInfo object behave like a string.'
def __repr__(self): DCNL 'Include the name.'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def get_exec(self, exec_dirs=[]): DCNL 'Returns existing executable, or empty string if none found'
def match(self, userargs): DCNL 'Only check that the first argument (command) matches exec_path'
def get_command(self, userargs, exec_dirs=[]): DCNL 'Returns command to execute (with sudo -u if run_as != root).'
def get_environment(self, userargs): DCNL 'Returns specific environment to set, None if none'
def _is_correct_class(self, obj): DCNL 'Return whether an object is a class of the correct type and DCNL is not prefixed with an underscore.'
def _get_classes_from_module(self, module_name): DCNL 'Get the classes from a module that match the type we want.'
def get_all_classes(self): DCNL 'Get the classes of the type we want from all modules found DCNL in the directory that defines this class.'
def get_matching_classes(self, loadable_class_names): DCNL 'Get loadable classes from a list of names.  Each name can be DCNL a full module path or the full path to a method that returns DCNL classes to use.  The latter behavior is useful to specify a method DCNL that returns a list of classes to use in a default case.'
def __init__(cls, names, bases, dict_): DCNL 'Metaclass that allows us to collect decorated periodic tasks.'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def periodic_tasks(self, context, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def init_host(self): DCNL 'Hook to do additional manager initialization when one requests DCNL the service be started.  This is called before any service record DCNL is created. DCNL Child classes should override this method.'
def pre_start_hook(self, **kwargs): DCNL 'Hook to provide the manager the ability to do additional DCNL start-up work before any RPC queues/consumers are created. This is DCNL called after other initialization has succeeded and a service DCNL record is created. DCNL Child classes should override this method.'
def post_start_hook(self): DCNL 'Hook to provide the manager the ability to do additional DCNL start-up work immediately after a service creates RPC consumers DCNL and starts \'running\'. DCNL Child classes should override this method.'
def update_service_capabilities(self, capabilities): DCNL 'Remember these capabilities to send on next periodic update.'
@periodic_task DCNL def publish_service_capabilities(self, context): DCNL 'Pass data back to the scheduler. DCNL Called at a periodic interval. And also called via rpc soon after DCNL the start of the scheduler.'
def _filter_one(self, obj, filter_properties): DCNL 'Return True if it passes the filter, False otherwise. DCNL Override this in a subclass.'
def filter_all(self, filter_obj_list, filter_properties): DCNL 'Yield objects that pass the filter. DCNL Can be overriden in a subclass, if you need to base filtering DCNL decisions on all objects.  Otherwise, one can just override DCNL _filter_one() to filter a single object.'
def join(self, member_id, group_id, service=None): DCNL 'Join the given service with it\'s group.'
def is_up(self, service_ref): DCNL 'Moved from nova.utils DCNL Check whether a service is up based on last heartbeat.'
def get_all(self, group_id): DCNL 'Returns ALL members of the given group'
def _report_state(self, service): DCNL 'Update the state of this service in the datastore.'
def join(self, member_id, group_id, service=None): DCNL 'Join the given service with its group.'
def is_up(self, service_ref): DCNL 'Moved from nova.utils DCNL Check whether a service is up based on last heartbeat.'
def get_all(self, group_id): DCNL 'Returns ALL members of the given group'
def _report_state(self, service): DCNL 'Update the state of this service in the datastore.'
def __init__(self, *args, **kwargs): DCNL 'Create the zk session object.'
def join(self, member_id, group, service=None): DCNL 'Join the given service with its group.'
def leave(self, member_id, group): DCNL 'Remove the given member from the service group.'
def get_all(self, group_id): DCNL 'Return all members in a list, or a ServiceGroupUnavailable DCNL exception.'
def __new__(cls, *args, **kwargs): DCNL 'Create an instance of the servicegroup API. DCNL args and kwargs are passed down to the servicegroup driver when it gets DCNL created.  No args currently exist, though.  Valid kwargs are: DCNL db_allowed - Boolean. False if direct db access is not allowed and DCNL alternative data access (conductor) should be used DCNL instead.'
def join(self, member_id, group_id, service=None): DCNL 'Add a new member to the ServiceGroup DCNL @param member_id: the joined member ID DCNL @param group_id: the group name, of the joined member DCNL @param service: the parameter can be used for notifications about DCNL disconnect mode and update some internals'
def service_is_up(self, member): DCNL 'Check if the given member is up.'
def leave(self, member_id, group_id): DCNL 'Explicitly remove the given member from the ServiceGroup DCNL monitoring.'
def get_all(self, group_id): DCNL 'Returns ALL members of the given group.'
def get_one(self, group_id): DCNL 'Returns one member of the given group. The strategy to select DCNL the member is decided by the driver (e.g. random or round-robin).'
def join(self, member_id, group_id, service=None): DCNL 'Join the given service with it\'s group.'
def is_up(self, member): DCNL 'Check whether the given member is up.'
def leave(self, member_id, group_id): DCNL 'Remove the given member from the ServiceGroup monitoring.'
def get_all(self, group_id): DCNL 'Returns ALL members of the given group.'
def get_one(self, group_id): DCNL 'The default behavior of get_one is to randomly pick one from DCNL the result of get_all(). This is likely to be overridden in the DCNL actual driver implementation.'
def create(self, context, metadata, data=None): DCNL 'Create an image. DCNL metadata[\'properties\'] should contain image_location.'
def _s3_create(self, context, metadata): DCNL 'Gets a manifest from s3 and makes an image.'
@staticmethod DCNL def _test_for_malicious_tarball(path, filename): DCNL 'Raises exception if extracting tarball would escape extract path.'
def _create_static_client(self, context, host, port, use_ssl, version): DCNL 'Create a client that we\'ll use for every call.'
def _create_onetime_client(self, context, version): DCNL 'Create a client that will be used for one call.'
def call(self, context, version, method, *args, **kwargs): DCNL 'Call a glance client method.  If we get a connection error, DCNL retry the request according to CONF.glance_num_retries.'
def detail(self, context, **kwargs): DCNL 'Calls out to Glance for a list of detailed image information.'
def show(self, context, image_id): DCNL 'Returns a dict with image data for the given opaque image id.'
def get_location(self, context, image_id): DCNL 'Returns the direct url representing the backend storage location, DCNL or None if this attribute is not shown by Glance.'
def download(self, context, image_id, data=None): DCNL 'Calls out to Glance for data and writes data.'
def create(self, context, image_meta, data=None): DCNL 'Store the image data and return the new image object.'
def update(self, context, image_id, image_meta, data=None, purge_props=True): DCNL 'Modify the given image with the new data.'
def delete(self, context, image_id): DCNL 'Delete the given image. DCNL :raises: ImageNotFound if the image does not exist. DCNL :raises: NotAuthorized if the user is not an owner. DCNL :raises: ImageNotAuthorized if the user is not authorized.'
@staticmethod DCNL def _is_image_available(context, image): DCNL 'Check image availability. DCNL This check is needed in case Nova and Glance are deployed DCNL without authentication turned on.'
def get_by_project(self, context, project_id, resource): DCNL 'Get a specific quota by project.'
def get_by_class(self, context, quota_class, resource): DCNL 'Get a specific quota by quota class.'
def get_defaults(self, context, resources): DCNL 'Given a list of resources, retrieve the default quotas. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources.'
def get_class_quotas(self, context, resources, quota_class, defaults=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL quota class. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param quota_class: The name of the quota class to return DCNL quotas for. DCNL :param defaults: If True, the default value will be reported DCNL if there is no specific value for the DCNL resource.'
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL project. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param project_id: The ID of the project to return quotas for. DCNL :param quota_class: If project_id != context.project_id, the DCNL quota class cannot be determined.  This DCNL parameter allows it to be specified.  It DCNL will be ignored if project_id == DCNL context.project_id. DCNL :param defaults: If True, the quota class value (or the DCNL default value, if there is no value from the DCNL quota class) will be reported if there is no DCNL specific value for the resource. DCNL :param usages: If True, the current in_use and reserved counts DCNL will also be returned.'
def _get_quotas(self, context, resources, keys, has_sync, project_id=None): DCNL 'A helper method which retrieves the quotas for the specific DCNL resources identified by keys, and which apply to the current DCNL context. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param keys: A list of the desired quotas to retrieve. DCNL :param has_sync: If True, indicates that the resource must DCNL have a sync attribute; if False, indicates DCNL that the resource must NOT have a sync DCNL attribute. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def limit_check(self, context, resources, values, project_id=None): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param values: A dictionary of the values to check against the DCNL quota. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def reserve(self, context, resources, deltas, expire=None, project_id=None): DCNL 'Check quotas and reserve resources. DCNL For counting quotas--those quotas for which there is a usage DCNL synchronization function--this method checks quotas against DCNL current usage and the desired deltas. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it does not have a usage DCNL synchronization function. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns a DCNL list of reservation UUIDs which were created. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param deltas: A dictionary of the proposed delta changes. DCNL :param expire: An optional parameter specifying an expiration DCNL time for the reservations.  If it is a simple DCNL number, it is interpreted as a number of DCNL seconds and added to the current time; if it is DCNL a datetime.timedelta object, it will also be DCNL added to the current time.  A datetime.datetime DCNL object will be interpreted as the absolute DCNL expiration time.  If None is specified, the DCNL default expiration time set by DCNL --default-reservation-expire will be used (this DCNL value will be treated as a number of seconds). DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def commit(self, context, reservations, project_id=None): DCNL 'Commit reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def rollback(self, context, reservations, project_id=None): DCNL 'Roll back reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def usage_reset(self, context, resources): DCNL 'Reset the usage records for a particular user on a list of DCNL resources.  This will force that user\'s usage records to be DCNL refreshed the next time a reservation is made. DCNL Note: this does not affect the currently outstanding DCNL reservations the user has; those reservations must be DCNL committed or rolled back (or expired). DCNL :param context: The request context, for access checks. DCNL :param resources: A list of the resource names for which the DCNL usage must be reset.'
def destroy_all_by_project(self, context, project_id): DCNL 'Destroy all quotas, usages, and reservations associated with a DCNL project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project being deleted.'
def expire(self, context): DCNL 'Expire reservations. DCNL Explores all currently existing reservations and rolls back DCNL any that have expired. DCNL :param context: The request context, for access checks.'
def get_by_project(self, context, project_id, resource): DCNL 'Get a specific quota by project.'
def get_by_class(self, context, quota_class, resource): DCNL 'Get a specific quota by quota class.'
def get_defaults(self, context, resources): DCNL 'Given a list of resources, retrieve the default quotas. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources.'
def get_class_quotas(self, context, resources, quota_class, defaults=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL quota class. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param quota_class: The name of the quota class to return DCNL quotas for. DCNL :param defaults: If True, the default value will be reported DCNL if there is no specific value for the DCNL resource.'
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL project. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param project_id: The ID of the project to return quotas for. DCNL :param quota_class: If project_id != context.project_id, the DCNL quota class cannot be determined.  This DCNL parameter allows it to be specified.  It DCNL will be ignored if project_id == DCNL context.project_id. DCNL :param defaults: If True, the quota class value (or the DCNL default value, if there is no value from the DCNL quota class) will be reported if there is no DCNL specific value for the resource. DCNL :param usages: If True, the current in_use and reserved counts DCNL will also be returned.'
def limit_check(self, context, resources, values, project_id=None): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param values: A dictionary of the values to check against the DCNL quota. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def reserve(self, context, resources, deltas, expire=None, project_id=None): DCNL 'Check quotas and reserve resources. DCNL For counting quotas--those quotas for which there is a usage DCNL synchronization function--this method checks quotas against DCNL current usage and the desired deltas. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it does not have a usage DCNL synchronization function. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns a DCNL list of reservation UUIDs which were created. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param deltas: A dictionary of the proposed delta changes. DCNL :param expire: An optional parameter specifying an expiration DCNL time for the reservations.  If it is a simple DCNL number, it is interpreted as a number of DCNL seconds and added to the current time; if it is DCNL a datetime.timedelta object, it will also be DCNL added to the current time.  A datetime.datetime DCNL object will be interpreted as the absolute DCNL expiration time.  If None is specified, the DCNL default expiration time set by DCNL --default-reservation-expire will be used (this DCNL value will be treated as a number of seconds). DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def commit(self, context, reservations, project_id=None): DCNL 'Commit reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def rollback(self, context, reservations, project_id=None): DCNL 'Roll back reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def usage_reset(self, context, resources): DCNL 'Reset the usage records for a particular user on a list of DCNL resources.  This will force that user\'s usage records to be DCNL refreshed the next time a reservation is made. DCNL Note: this does not affect the currently outstanding DCNL reservations the user has; those reservations must be DCNL committed or rolled back (or expired). DCNL :param context: The request context, for access checks. DCNL :param resources: A list of the resource names for which the DCNL usage must be reset.'
def destroy_all_by_project(self, context, project_id): DCNL 'Destroy all quotas, usages, and reservations associated with a DCNL project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project being deleted.'
def expire(self, context): DCNL 'Expire reservations. DCNL Explores all currently existing reservations and rolls back DCNL any that have expired. DCNL :param context: The request context, for access checks.'
def __init__(self, name, flag=None): DCNL 'Initializes a Resource. DCNL :param name: The name of the resource, i.e., "instances". DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def quota(self, driver, context, **kwargs): DCNL 'Given a driver and context, obtain the quota for this DCNL resource. DCNL :param driver: A quota driver. DCNL :param context: The request context. DCNL :param project_id: The project to obtain the quota value for. DCNL If not provided, it is taken from the DCNL context.  If it is given as None, no DCNL project-specific quota will be searched DCNL for. DCNL :param quota_class: The quota class corresponding to the DCNL project, or for which the quota is to be DCNL looked up.  If not provided, it is taken DCNL from the context.  If it is given as None, DCNL no quota class-specific quota will be DCNL searched for.  Note that the quota class DCNL defaults to the value in the context, DCNL which may not correspond to the project if DCNL project_id is not the same as the one in DCNL the context.'
@property DCNL def default(self): DCNL 'Return the default value of the quota.'
def __init__(self, name, sync, flag=None): DCNL 'Initializes a ReservableResource. DCNL Reservable resources are those resources which directly DCNL correspond to objects in the database, i.e., instances, cores, DCNL etc.  A ReservableResource must be constructed with a usage DCNL synchronization function, which will be called to determine the DCNL current counts of one or more resources. DCNL The usage synchronization function will be passed three DCNL arguments: an admin context, the project ID, and an opaque DCNL session object, which should in turn be passed to the DCNL underlying database function.  Synchronization functions DCNL should return a dictionary mapping resource names to the DCNL current in_use count for those resources; more than one DCNL resource and resource count may be returned.  Note that DCNL synchronization functions may be associated with more than one DCNL ReservableResource. DCNL :param name: The name of the resource, i.e., "instances". DCNL :param sync: A callable which returns a dictionary to DCNL resynchronize the in_use count for one or more DCNL resources, as described above. DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def __init__(self, name, count, flag=None): DCNL 'Initializes a CountableResource. DCNL Countable resources are those resources which directly DCNL correspond to objects in the database, i.e., instances, cores, DCNL etc., but for which a count by project ID is inappropriate.  A DCNL CountableResource must be constructed with a counting DCNL function, which will be called to determine the current counts DCNL of the resource. DCNL The counting function will be passed the context, along with DCNL the extra positional and keyword arguments that are passed to DCNL Quota.count().  It should return an integer specifying the DCNL count. DCNL Note that this counting is not performed in a transaction-safe DCNL manner.  This resource class is a temporary measure to provide DCNL required functionality, until a better approach to solving DCNL this problem can be evolved. DCNL :param name: The name of the resource, i.e., "instances". DCNL :param count: A callable which returns the count of the DCNL resource.  The arguments passed are as described DCNL above. DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def __init__(self, quota_driver_class=None): DCNL 'Initialize a Quota object.'
def register_resource(self, resource): DCNL 'Register a resource.'
def register_resources(self, resources): DCNL 'Register a list of resources.'
def get_by_project(self, context, project_id, resource): DCNL 'Get a specific quota by project.'
def get_by_class(self, context, quota_class, resource): DCNL 'Get a specific quota by quota class.'
def get_defaults(self, context): DCNL 'Retrieve the default quotas. DCNL :param context: The request context, for access checks.'
def get_class_quotas(self, context, quota_class, defaults=True): DCNL 'Retrieve the quotas for the given quota class. DCNL :param context: The request context, for access checks. DCNL :param quota_class: The name of the quota class to return DCNL quotas for. DCNL :param defaults: If True, the default value will be reported DCNL if there is no specific value for the DCNL resource.'
def get_project_quotas(self, context, project_id, quota_class=None, defaults=True, usages=True): DCNL 'Retrieve the quotas for the given project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project to return quotas for. DCNL :param quota_class: If project_id != context.project_id, the DCNL quota class cannot be determined.  This DCNL parameter allows it to be specified. DCNL :param defaults: If True, the quota class value (or the DCNL default value, if there is no value from the DCNL quota class) will be reported if there is no DCNL specific value for the resource. DCNL :param usages: If True, the current in_use and reserved counts DCNL will also be returned.'
def count(self, context, resource, *args, **kwargs): DCNL 'Count a resource. DCNL For countable resources, invokes the count() function and DCNL returns its result.  Arguments following the context and DCNL resource are passed directly to the count function declared by DCNL the resource. DCNL :param context: The request context, for access checks. DCNL :param resource: The name of the resource, as a string.'
def limit_check(self, context, project_id=None, **values): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction.  The DCNL values to check are given as keyword arguments, where the key DCNL identifies the specific quota limit to check, and the value is DCNL the proposed value. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def reserve(self, context, expire=None, project_id=None, **deltas): DCNL 'Check quotas and reserve resources. DCNL For counting quotas--those quotas for which there is a usage DCNL synchronization function--this method checks quotas against DCNL current usage and the desired deltas.  The deltas are given as DCNL keyword arguments, and current usage and other reservations DCNL are factored into the quota check. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it does not have a usage DCNL synchronization function. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns a DCNL list of reservation UUIDs which were created. DCNL :param context: The request context, for access checks. DCNL :param expire: An optional parameter specifying an expiration DCNL time for the reservations.  If it is a simple DCNL number, it is interpreted as a number of DCNL seconds and added to the current time; if it is DCNL a datetime.timedelta object, it will also be DCNL added to the current time.  A datetime.datetime DCNL object will be interpreted as the absolute DCNL expiration time.  If None is specified, the DCNL default expiration time set by DCNL --default-reservation-expire will be used (this DCNL value will be treated as a number of seconds). DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def commit(self, context, reservations, project_id=None): DCNL 'Commit reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def rollback(self, context, reservations, project_id=None): DCNL 'Roll back reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def usage_reset(self, context, resources): DCNL 'Reset the usage records for a particular user on a list of DCNL resources.  This will force that user\'s usage records to be DCNL refreshed the next time a reservation is made. DCNL Note: this does not affect the currently outstanding DCNL reservations the user has; those reservations must be DCNL committed or rolled back (or expired). DCNL :param context: The request context, for access checks. DCNL :param resources: A list of the resource names for which the DCNL usage must be reset.'
def destroy_all_by_project(self, context, project_id): DCNL 'Destroy all quotas, usages, and reservations associated with a DCNL project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project being deleted.'
def expire(self, context): DCNL 'Expire reservations. DCNL Explores all currently existing reservations and rolls back DCNL any that have expired. DCNL :param context: The request context, for access checks.'
def __init__(self, name, app, host='0.0.0.0', port=0, pool_size=None, protocol=eventlet.wsgi.HttpProtocol, backlog=128, use_ssl=False, max_url_len=None): DCNL 'Initialize, but do not start, a WSGI server. DCNL :param name: Pretty name for logging. DCNL :param app: The WSGI application to serve. DCNL :param host: IP address to serve the application. DCNL :param port: Port number to server the application. DCNL :param pool_size: Maximum number of eventlets to spawn concurrently. DCNL :param backlog: Maximum number of queued connections. DCNL :param max_url_len: Maximum length of permitted URLs. DCNL :returns: None DCNL :raises: nova.exception.InvalidInput'
def start(self): DCNL 'Start serving a WSGI application. DCNL :returns: None'
def stop(self): DCNL 'Stop this server. DCNL This is not a very nice action, as currently the method by which a DCNL server is stopped is by killing its eventlet. DCNL :returns: None'
def wait(self): DCNL 'Block, until the server has stopped. DCNL Waits on the server\'s eventlet to finish, then returns. DCNL :returns: None'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [app:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [app:wadl] DCNL latest_version = 1.3 DCNL paste.app_factory = nova.api.fancy_api:Wadl.factory DCNL which would result in a call to the `Wadl` class as DCNL import nova.api.fancy_api DCNL fancy_api.Wadl(latest_version=\'1.3\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def __call__(self, environ, start_response): DCNL 'Subclasses will probably want to implement __call__ like this: DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL # Any of the following objects work as responses: DCNL # Option 1: simple string DCNL res = \'message\n\' DCNL # Option 2: a nicely formatted HTTP exception page DCNL res = exc.HTTPForbidden(detail=\'Nice try\') DCNL # Option 3: a webob Response object (in case you need to play with DCNL # headers, or you want to be treated like an iterable, or or or) DCNL res = Response(); DCNL res.app_iter = open(\'somefile\') DCNL # Option 4: any wsgi app to be run next DCNL res = self.application DCNL # Option 5: you can get a Response object for a wsgi app, too, to DCNL # play with headers etc DCNL res = req.get_response(self.application) DCNL # You can then just return your response... DCNL return res DCNL # ... or set req.response and return None. DCNL req.response = res DCNL See the end of http://pythonpaste.org/webob/modules/dec.html DCNL for more info.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [filter:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [filter:analytics] DCNL redis_host = 127.0.0.1 DCNL paste.filter_factory = nova.api.analytics:Analytics.factory DCNL which would result in a call to the `Analytics` class as DCNL import nova.api.analytics DCNL analytics.Analytics(app_from_paste, redis_host=\'127.0.0.1\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def process_request(self, req): DCNL 'Called on each request. DCNL If this returns None, the next application down the stack will be DCNL executed. If it returns a response then that response will be returned DCNL and execution will stop here.'
def process_response(self, response): DCNL 'Do whatever you\'d like to the response.'
@staticmethod DCNL def print_generator(app_iter): DCNL 'Iterator that prints the contents of a wrapper string.'
def __init__(self, mapper): DCNL 'Create a router for the given routes.Mapper. DCNL Each route in `mapper` must specify a \'controller\', which is a DCNL WSGI app to call.  You\'ll probably want to specify an \'action\' as DCNL well and have your controller be an object that can route DCNL the request to the action-specific method. DCNL Examples: DCNL mapper = routes.Mapper() DCNL sc = ServerController() DCNL # Explicit mapping of one route to a controller+action DCNL mapper.connect(None, \'/svrlist\', controller=sc, action=\'list\') DCNL # Actions are all implicitly defined DCNL mapper.resource(\'server\', \'servers\', controller=sc) DCNL # Pointing to an arbitrary WSGI app.  You can specify the DCNL # {path_info:.*} parameter so the target app can be handed just that DCNL # section of the URL. DCNL mapper.connect(None, \'/v1.0/{path_info:.*}\', controller=BlogApp())'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Route the incoming request to a controller based on self.map. DCNL If no match, return a 404.'
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req): DCNL 'Dispatch the request to the appropriate controller. DCNL Called by self._router after matching the incoming request to a route DCNL and putting the information into req.environ.  Either returns 404 DCNL or the routed WSGI app\'s response.'
def __init__(self, config_path=None): DCNL 'Initialize the loader, and attempt to find the config. DCNL :param config_path: Full or relative path to the paste config. DCNL :returns: None'
def load_app(self, name): DCNL 'Return the paste URLMap wrapped WSGI application. DCNL :param name: Name of the application to load. DCNL :returns: Paste URLMap object wrapping the requested application. DCNL :raises: `nova.exception.PasteAppNotFound`'
def make_drive(self, path): DCNL 'Make the config drive. DCNL :param path: the path to place the config drive image at DCNL :raises ProcessExecuteError if a helper process has failed.'
def init_host(self, host): DCNL 'Initialize anything that is necessary for the driver to function, DCNL including catching up with currently running VM\'s on the given host.'
def get_info(self, instance): DCNL 'Get the current status of an instance.'
def get_host_stats(self, refresh=False): DCNL 'Return currently known host stats.'
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info=None, block_device_info=None): DCNL 'Create a new instance/VM/domain on powerVM.'
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True): DCNL 'Destroy (shutdown and delete) the specified instance.'
def reboot(self, context, instance, network_info, reboot_type, block_device_info=None, bad_volumes_callback=None): DCNL 'Reboot the specified instance. DCNL :param instance: Instance object as returned by DB layer. DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL :param reboot_type: Either a HARD or SOFT reboot DCNL :param block_device_info: Info pertaining to attached volumes DCNL :param bad_volumes_callback: Function to handle any bad volumes DCNL encountered'
def get_host_ip_addr(self): DCNL 'Retrieves the IP address of the hypervisor host.'
def snapshot(self, context, instance, image_id, update_task_state): DCNL 'Snapshots the specified instance. DCNL :param context: security context DCNL :param instance: Instance object as returned by DB layer. DCNL :param image_id: Reference to a pre-created image that will DCNL hold the snapshot. DCNL :param update_task_state: Function reference that allows for updates DCNL to the instance task state.'
def pause(self, instance): DCNL 'Pause the specified instance.'
def unpause(self, instance): DCNL 'Unpause paused VM instance.'
def suspend(self, instance): DCNL 'suspend the specified instance.'
def resume(self, instance, network_info, block_device_info=None): DCNL 'resume the specified instance.'
def power_off(self, instance): DCNL 'Power off the specified instance.'
def power_on(self, instance): DCNL 'Power on the specified instance.'
def get_available_resource(self, nodename): DCNL 'Retrieve resource info.'
def host_power_action(self, host, action): DCNL 'Reboots, shuts down or powers up the host.'
def legacy_nwinfo(self): DCNL 'Indicate if the driver requires the legacy network_info format.'
def manage_image_cache(self, context, all_instances): DCNL 'Manage the driver\'s local image cache. DCNL Some drivers chose to cache images for instances on disk. This method DCNL is an opportunity to do management of that cache which isn\'t directly DCNL related to other calls into the driver. The prime example is to clean DCNL the cache and remove images which are no longer of interest.'
def migrate_disk_and_power_off(self, context, instance, dest, instance_type, network_info, block_device_info=None): DCNL 'Transfers the disk of a running instance in multiple phases, turning DCNL off the instance before the end. DCNL :returns: disk_info dictionary that is passed as the DCNL disk_info parameter to finish_migration DCNL on the destination nova-compute host'
def _get_resize_name(self, instance_name): DCNL 'Rename the instance to be migrated to avoid naming conflicts DCNL :param instance_name: name of instance to be migrated DCNL :returns: the new instance name'
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance, block_device_info=None): DCNL 'Completes a resize, turning on the migrated instance DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL :param image_meta: image object returned by nova.image.glance that DCNL defines the image from which this instance DCNL was created'
def confirm_migration(self, migration, instance, network_info): DCNL 'Confirms a resize, destroying the source VM.'
def finish_revert_migration(self, instance, network_info, block_device_info=None): DCNL 'Finish reverting a resize, powering back on the instance.'
def get_info(self, instance_name): DCNL 'Get the current status of an LPAR instance. DCNL Returns a dict containing: DCNL :state:           the running state, one of the power_state codes DCNL :max_mem:         (int) the maximum memory in KBytes allowed DCNL :mem:             (int) the memory in KBytes used by the domain DCNL :num_cpu:         (int) the number of virtual CPUs for the domain DCNL :cpu_time:        (int) the CPU time used in nanoseconds DCNL :raises: PowerVMLPARInstanceNotFound'
def _get_instance(self, instance_name): DCNL 'Check whether or not the LPAR instance exists and return it.'
def list_instances(self): DCNL 'Return the names of all the instances known to the virtualization DCNL layer, as a list.'
def get_available_resource(self): DCNL 'Retrieve resource info. DCNL :returns: dictionary containing resource info'
def get_host_stats(self, refresh=False): DCNL 'Return currently known host stats.'
def destroy(self, instance_name, destroy_disks=True): DCNL 'Destroy (shutdown and delete) the specified instance. DCNL :param instance_name: Instance name.'
def capture_image(self, context, instance, image_id, image_meta, update_task_state): DCNL 'Capture the root disk for a snapshot DCNL :param context: nova context for this operation DCNL :param instance: instance information to capture the image from DCNL :param image_id: uuid of pre-created snapshot image DCNL :param image_meta: metadata to upload with captured image DCNL :param update_task_state: Function reference that allows for updates DCNL to the instance task state.'
def _check_host_resources(self, instance, vcpus, mem, host_stats): DCNL 'Checks resources on host for resize, migrate, and spawn DCNL :param vcpus: CPUs to be used DCNL :param mem: memory requested by instance DCNL :param disk: size of disk to be expanded or created'
def migrate_disk(self, device_name, src_host, dest, image_path, instance_name=None): DCNL 'Migrates SVC or Logical Volume based disks DCNL :param device_name: disk device name in /dev/ DCNL :param dest: IP or DNS name of destination host/VIOS DCNL :param image_path: path on source and destination to directory DCNL for storing image files DCNL :param instance_name: name of instance being migrated DCNL :returns: disk_info dictionary object describing root volume DCNL information used for locating/mounting the volume'
def __init__(self, connection): DCNL 'Constructor. DCNL :param connection: common.Connection object with the DCNL information to connect to the remote DCNL ssh.'
def get_lpar(self, instance_name, resource_type='lpar'): DCNL 'Return a LPAR object by its instance name. DCNL :param instance_name: LPAR instance name DCNL :param resource_type: the type of resources to list DCNL :returns: LPAR object'
def list_lpar_instances(self): DCNL 'List all existent LPAR instances names. DCNL :returns: list -- list with instances names.'
def create_lpar(self, lpar): DCNL 'Receives a LPAR data object and creates a LPAR instance. DCNL :param lpar: LPAR object'
def start_lpar(self, instance_name): DCNL 'Start a LPAR instance. DCNL :param instance_name: LPAR instance name'
def stop_lpar(self, instance_name, timeout=30): DCNL 'Stop a running LPAR. DCNL :param instance_name: LPAR instance name DCNL :param timeout: value in seconds for specifying DCNL how long to wait for the LPAR to stop'
def remove_lpar(self, instance_name): DCNL 'Removes a LPAR. DCNL :param instance_name: LPAR instance name'
def get_vhost_by_instance_id(self, instance_id): DCNL 'Return the vhost name by the instance id. DCNL :param instance_id: LPAR instance id DCNL :returns: string -- vhost name or None in case none is found'
def get_virtual_eth_adapter_id(self): DCNL 'Virtual ethernet adapter id. DCNL Searches for the shared ethernet adapter and returns DCNL its id. DCNL :returns: id of the virtual ethernet adapter.'
def get_hostname(self): DCNL 'Returns the managed system hostname. DCNL :returns: string -- hostname'
def get_disk_name_by_vhost(self, vhost): DCNL 'Returns the disk name attached to a vhost. DCNL :param vhost: a vhost name DCNL :returns: string -- disk name'
def attach_disk_to_vhost(self, disk, vhost): DCNL 'Attach disk name to a specific vhost. DCNL :param disk: the disk name DCNL :param vhost: the vhost name'
def get_memory_info(self): DCNL 'Get memory info. DCNL :returns: tuple - memory info (total_mem, avail_mem)'
def get_cpu_info(self): DCNL 'Get CPU info. DCNL :returns: tuple - cpu info (total_procs, avail_procs)'
def get_disk_info(self): DCNL 'Get the disk usage information. DCNL :returns: tuple - disk info (disk_total, disk_used, disk_avail)'
def run_vios_command(self, cmd, check_exit_code=True): DCNL 'Run a remote command using an active ssh connection. DCNL :param command: String with the command to run.'
def run_vios_command_as_root(self, command, check_exit_code=True): DCNL 'Run a remote command as root using an active ssh connection. DCNL :param command: List of commands.'
def update_lpar(self, lpar_info): DCNL 'Resizing an LPAR DCNL :param lpar_info: dictionary of LPAR information'
def get_logical_vol_size(self, diskname): DCNL 'Finds and calculates the logical volume size in GB DCNL :param diskname: name of the logical volume DCNL :returns: size of logical volume in GB'
def rename_lpar(self, instance_name, new_name): DCNL 'Rename LPAR given by instance_name to new_name DCNL Note: For IVM based deployments, the name is DCNL limited to 31 characters and will be trimmed DCNL to meet this requirement DCNL :param instance_name: name of LPAR to be renamed DCNL :param new_name: desired new name of LPAR DCNL :returns: new name of renamed LPAR trimmed to 31 characters DCNL if necessary'
def _remove_file(self, file_path): DCNL 'Removes a file on the VIOS partition DCNL :param file_path: absolute path to file to be removed'
def set_lpar_mac_base_value(self, instance_name, mac): DCNL 'Set LPAR\'s property virtual_eth_mac_base_value DCNL :param instance_name: name of the instance to be set DCNL :param mac: mac of virtual ethernet'
def macs_for_instance(self, instance): DCNL 'Generates set of valid MAC addresses for an IVM instance.'
def create_volume(self, size): DCNL 'Creates a volume with a minimum size DCNL :param size: size of the volume in bytes DCNL :returns: string -- the name of the disk device.'
def delete_volume(self, volume_info): DCNL 'Removes the disk and its associated vSCSI connection DCNL :param volume_info: dictionary with volume info including name of DCNL disk device in /dev/'
def create_volume_from_image(self, context, instance, image_id): DCNL 'Creates a Volume and copies the specified image to it DCNL :param context: nova context used to retrieve image from glance DCNL :param instance: instance to create the volume for DCNL :param image_id: image_id reference used to locate image in glance DCNL :returns: dictionary with the name of the created DCNL disk device in \'device_name\' key'
def create_image_from_volume(self, device_name, context, image_id, image_meta, update_task_state): DCNL 'Capture the contents of a volume and upload to glance DCNL :param device_name: device in /dev/ to capture DCNL :param context: nova context for operation DCNL :param image_id: image reference to pre-created image in glance DCNL :param image_meta: metadata for new image DCNL :param update_task_state: Function reference that allows for updates DCNL to the instance task state'
def migrate_volume(self, lv_name, src_host, dest, image_path, instance_name=None): DCNL 'Copy a logical volume to file, compress, and transfer DCNL :param lv_name: volume device name DCNL :param src_host: source IP or DNS name. DCNL :param dest: destination IP or DNS name DCNL :param image_path: path to remote image storage directory DCNL :param instance_name: name of instance that is being migrated DCNL :returns: file path on destination of image file that was moved'
def attach_volume_to_host(self, *args, **kargs): DCNL 'Attaches volume to host using info passed in *args and **kargs'
def detach_volume_from_host(self, *args, **kargs): DCNL 'Detaches volume from host using info passed in *args and **kargs'
def create_volume(self, size): DCNL 'Creates a logical volume with a minimum size DCNL :param size: size of the logical volume in bytes DCNL :returns: string -- the name of the new logical volume. DCNL :raises: PowerVMNoSpaceLeftOnVolumeGroup'
def delete_volume(self, volume_info): DCNL 'Removes the Logical Volume and its associated vSCSI connection DCNL :param volume_info: Dictionary with volume info including name of DCNL Logical Volume device in /dev/ via device_name key'
def create_volume_from_image(self, context, instance, image_id): DCNL 'Creates a Logical Volume and copies the specified image to it DCNL :param context: nova context used to retrieve image from glance DCNL :param instance: instance to create the volume for DCNL :param image_id: image_id reference used to locate image in glance DCNL :returns: dictionary with the name of the created DCNL Logical Volume device in \'device_name\' key'
def create_image_from_volume(self, device_name, context, image_id, image_meta, update_task_state): DCNL 'Capture the contents of a volume and upload to glance DCNL :param device_name: device in /dev/ to capture DCNL :param context: nova context for operation DCNL :param image_id: image reference to pre-created image in glance DCNL :param image_meta: metadata for new image DCNL :param update_task_state: Function reference that allows for updates DCNL to the instance task state.'
def migrate_volume(self, lv_name, src_host, dest, image_path, instance_name=None): DCNL 'Copy a logical volume to file, compress, and transfer DCNL :param lv_name: logical volume device name DCNL :param dest: destination IP or DNS name DCNL :param image_path: path to remote image storage directory DCNL :param instance_name: name of instance that is being migrated DCNL :returns: file path on destination of image file that was moved'
def _create_logical_volume(self, size): DCNL 'Creates a logical volume with a minimum size. DCNL :param size: size of the logical volume in bytes DCNL :returns: string -- the name of the new logical volume. DCNL :raises: PowerVMNoSpaceLeftOnVolumeGroup'
def _remove_logical_volume(self, lv_name): DCNL 'Removes the lv and the connection between its associated vscsi. DCNL :param lv_name: a logical volume name'
def _copy_file_to_device(self, source_path, device, decompress=True): DCNL 'Copy file to device. DCNL :param source_path: path to input source file DCNL :param device: output device name DCNL :param decompress: if True (default) the file will be decompressed DCNL on the fly while being copied to the drive'
def _copy_device_to_file(self, device_name, file_path): DCNL 'Copy a device to a file using dd DCNL :param device_name: device name to copy from DCNL :param file_path: output file path'
def _copy_image_file(self, source_path, remote_path, decompress=False): DCNL 'Copy file to VIOS, decompress it, and return its new size and name. DCNL :param source_path: source file path DCNL :param remote_path remote file path DCNL :param decompress: if True, decompressess the file after copying; DCNL if False (default), just copies the file'
def _copy_image_file_from_host(self, remote_source_path, local_dest_dir, compress=False): DCNL 'Copy a file from IVM to the nova-compute host, DCNL and return the location of the copy DCNL :param remote_source_path remote source file path DCNL :param local_dest_dir local destination directory DCNL :param compress: if True, compress the file before transfer; DCNL if False (default), copy the file as is'
def run_vios_command(self, cmd, check_exit_code=True): DCNL 'Run a remote command using an active ssh connection. DCNL :param command: String with the command to run.'
def run_vios_command_as_root(self, command, check_exit_code=True): DCNL 'Run a remote command as root using an active ssh connection. DCNL :param command: List of commands.'
def _reset_state(self): DCNL 'Reset state variables used for each pass.'
def _store_image(self, base_dir, ent, original=False): DCNL 'Store a base image for later examination.'
def _list_base_images(self, base_dir): DCNL 'Return a list of the images present in _base. DCNL Determine what images we have on disk. There will be other files in DCNL this directory so we only grab the ones which are the right length DCNL to be disk images. DCNL Note that this does not return a value. It instead populates a class DCNL variable with a list of images that we need to try and explain.'
def _list_running_instances(self, context, all_instances): DCNL 'List running instances (on all compute nodes).'
def _list_backing_images(self): DCNL 'List the backing images currently in use.'
def _find_base_file(self, base_dir, fingerprint): DCNL 'Find the base file matching this fingerprint. DCNL Yields the name of the base file, a boolean which is True if the image DCNL is "small", and a boolean which indicates if this is a resized image. DCNL Note that is is possible for more than one yield to result from this DCNL check. DCNL If no base file is found, then nothing is yielded.'
def _verify_checksum(self, img_id, base_file, create_if_missing=True): DCNL 'Compare the checksum stored on disk with the current file. DCNL Note that if the checksum fails to verify this is logged, but no actual DCNL action occurs. This is something sysadmins should monitor for and DCNL handle manually when it occurs.'
def _remove_base_file(self, base_file): DCNL 'Remove a single base file if it is old enough. DCNL Returns nothing.'
def _handle_base_image(self, img_id, base_file): DCNL 'Handle the checks for a single base image.'
def verify_base_images(self, context, all_instances): DCNL 'Verify that base images are in a reasonable state.'
def set_cache_mode(self, conf): DCNL 'Set cache mode on LibvirtConfigGuestDisk object.'
def _native_thread(self): DCNL 'Receives async events coming in from libvirtd. DCNL This is a native thread which runs the default DCNL libvirt event loop implementation. This processes DCNL any incoming async events from libvirtd and queues DCNL them for later dispatch. This thread is only DCNL permitted to use libvirt python APIs, and the DCNL driver.queue_event method. In particular any use DCNL of logging is forbidden, since it will confuse DCNL eventlet\'s greenthread integration'
def _dispatch_thread(self): DCNL 'Dispatches async events coming in from libvirtd. DCNL This is a green thread which waits for events to DCNL arrive from the libvirt event loop thread. This DCNL then dispatches the events to the compute manager.'
@staticmethod DCNL def _event_lifecycle_callback(conn, dom, event, detail, opaque): DCNL 'Receives lifecycle events from libvirt. DCNL NB: this method is executing in a native thread, not DCNL an eventlet coroutine. It can only invoke other libvirt DCNL APIs, or use self.queue_event(). Any use of logging APIs DCNL in particular is forbidden.'
def _queue_event(self, event): DCNL 'Puts an event on the queue for dispatch. DCNL This method is called by the native event thread to DCNL put events on the queue for later dispatch by the DCNL green thread.'
def _dispatch_events(self): DCNL 'Wait for & dispatch events from native thread DCNL Blocks until native thread indicates some events DCNL are ready. Then dispatches all queued events.'
def _init_events_pipe(self): DCNL 'Create a self-pipe for the native thread to synchronize on. DCNL This code is taken from the eventlet tpool module, under terms DCNL of the Apache License v2.0.'
def _init_events(self): DCNL 'Initializes the libvirt events subsystem. DCNL This requires running a native thread to provide the DCNL libvirt event loop integration. This forwards events DCNL to a green thread which does the actual dispatching.'
def get_num_instances(self): DCNL 'Efficient override of base instance_exists method.'
def instance_exists(self, instance_name): DCNL 'Efficient override of base instance_exists method.'
def plug_vifs(self, instance, network_info): DCNL 'Plug VIFs into networks.'
def unplug_vifs(self, instance, network_info): DCNL 'Unplug VIFs from networks.'
def _cleanup_lvm(self, instance): DCNL 'Delete all LVM disks for given instance object.'
def _lvm_disks(self, instance): DCNL 'Returns all LVM disks for given instance object.'
@staticmethod DCNL def _get_disk_xml(xml, device): DCNL 'Returns the xml for the disk mounted at device.'
def snapshot(self, context, instance, image_href, update_task_state): DCNL 'Create snapshot from a running VM instance. DCNL This command only works with qemu 0.14+'
def _live_snapshot(self, domain, disk_path, out_path, image_format): DCNL 'Snapshot an instance without downtime.'
def reboot(self, context, instance, network_info, reboot_type='SOFT', block_device_info=None, bad_volumes_callback=None): DCNL 'Reboot a virtual machine, given an instance reference.'
def _soft_reboot(self, instance): DCNL 'Attempt to shutdown and restart the instance gracefully. DCNL We use shutdown and create here so we can return if the guest DCNL responded and actually rebooted. Note that this method only DCNL succeeds if the guest responds to acpi. Therefore we return DCNL success or failure so we can fall back to a hard reboot if DCNL necessary. DCNL :returns: True if the reboot succeeded'
def _hard_reboot(self, context, instance, network_info, block_device_info=None): DCNL 'Reboot a virtual machine, given an instance reference. DCNL Performs a Libvirt reset (if supported) on the domain. DCNL If Libvirt reset is unavailable this method actually destroys and DCNL re-creates the domain to ensure the reboot happens, as the guest DCNL OS cannot ignore this action. DCNL If xml is set, it uses the passed in xml in place of the xml from the DCNL existing domain.'
def pause(self, instance): DCNL 'Pause VM instance.'
def unpause(self, instance): DCNL 'Unpause paused VM instance.'
def power_off(self, instance): DCNL 'Power off the specified instance.'
def power_on(self, instance): DCNL 'Power on the specified instance.'
def suspend(self, instance): DCNL 'Suspend the specified instance.'
def resume(self, instance, network_info, block_device_info=None): DCNL 'resume the specified instance.'
def resume_state_on_host_boot(self, context, instance, network_info, block_device_info=None): DCNL 'resume guest state when a host is booted.'
def rescue(self, context, instance, network_info, image_meta, rescue_password): DCNL 'Loads a VM using rescue images. DCNL A rescue is normally performed when something goes wrong with the DCNL primary images and data needs to be corrected/recovered. Rescuing DCNL should not edit or over-ride the original image, only allow for DCNL data recovery.'
def unrescue(self, instance, network_info): DCNL 'Reboot the VM which is being rescued back into primary images.'
@staticmethod DCNL def _create_local(target, local_size, unit='G', fs_format=None, label=None): DCNL 'Create a blank image of specified size.'
@staticmethod DCNL def _create_swap(target, swap_mb): DCNL 'Create a swap file of specified size.'
def get_host_capabilities(self): DCNL 'Returns an instance of config.LibvirtConfigCaps representing DCNL the capabilities of the host'
def get_host_uuid(self): DCNL 'Returns a UUID representing the host.'
def get_host_cpu_for_guest(self): DCNL 'Returns an instance of config.LibvirtConfigGuestCPU DCNL representing the host\'s CPU model & topology with DCNL policy for configuring a guest to match'
def get_guest_config(self, instance, network_info, image_meta, disk_info, rescue=None, block_device_info=None): DCNL 'Get config data for parameters. DCNL :param rescue: optional dictionary that should contain the key DCNL \'ramdisk_id\' if a ramdisk is needed for the rescue image and DCNL \'kernel_id\' if a kernel is needed for the rescue image.'
def _lookup_by_name(self, instance_name): DCNL 'Retrieve libvirt domain object given an instance name. DCNL All libvirt error handling should be handled in this method and DCNL relevant nova exceptions should be raised in response.'
def get_info(self, instance): DCNL 'Retrieve information from libvirt for a specific instance name. DCNL If a libvirt error is encountered during lookup, we might raise a DCNL NotFound exception or Error exception depending on how severe the DCNL libvirt error is.'
def _create_domain(self, xml=None, domain=None, instance=None, launch_flags=0): DCNL 'Create a domain. DCNL Either domain or xml must be passed in. If both are passed, then DCNL the domain definition is overwritten from the xml.'
def _create_domain_and_network(self, xml, instance, network_info, block_device_info=None): DCNL 'Do required network setup and create domain.'
def get_all_block_devices(self): DCNL 'Return all block devices in use on this node.'
def get_disks(self, instance_name): DCNL 'Note that this function takes an instance name. DCNL Returns a list of all block devices for this domain.'
def get_interfaces(self, xml): DCNL 'Note that this function takes a domain xml. DCNL Returns a list of all network interfaces for this instance.'
def get_vcpu_total(self): DCNL 'Get vcpu number of physical computer. DCNL :returns: the number of cpu core.'
def get_memory_mb_total(self): DCNL 'Get the total memory size(MB) of physical computer. DCNL :returns: the total amount of memory(MB).'
@staticmethod DCNL def get_local_gb_info(): DCNL 'Get local storage info of the compute node in GB. DCNL :returns: A dict containing: DCNL :total: How big the overall usable filesystem is (in gigabytes) DCNL :free: How much space is free (in gigabytes) DCNL :used: How much space is used (in gigabytes)'
def get_vcpu_used(self): DCNL 'Get vcpu usage number of physical computer. DCNL :returns: The total number of vcpu that currently used.'
def get_memory_mb_used(self): DCNL 'Get the free memory size(MB) of physical computer. DCNL :returns: the total usage of memory(MB).'
def get_hypervisor_type(self): DCNL 'Get hypervisor type. DCNL :returns: hypervisor type (ex. qemu)'
def get_hypervisor_version(self): DCNL 'Get hypervisor version. DCNL :returns: hypervisor version (ex. 12003)'
def get_hypervisor_hostname(self): DCNL 'Returns the hostname of the hypervisor.'
def get_instance_capabilities(self): DCNL 'Get hypervisor instance capabilities DCNL Returns a list of tuples that describe instances the DCNL hypervisor is capable of hosting.  Each tuple consists DCNL of the triplet (arch, hypervisor_type, vm_mode). DCNL :returns: List of tuples describing instance capabilities'
def get_cpu_info(self): DCNL 'Get cpuinfo information. DCNL Obtains cpu feature from virConnect.getCapabilities, DCNL and returns as a json string. DCNL :return: see above description'
def get_all_volume_usage(self, context, compute_host_bdms): DCNL 'Return usage info for volumes attached to vms on DCNL a given host'
def block_stats(self, instance_name, disk): DCNL 'Note that this function takes an instance name.'
def interface_stats(self, instance_name, interface): DCNL 'Note that this function takes an instance name.'
def get_available_resource(self, nodename): DCNL 'Retrieve resource info. DCNL This method is called as a periodic task and is used only DCNL in live migration currently. DCNL :param nodename: ignored in this driver DCNL :returns: dictionary containing resource info'
def check_can_live_migrate_destination(self, ctxt, instance_ref, src_compute_info, dst_compute_info, block_migration=False, disk_over_commit=False): DCNL 'Check if it is possible to execute live migration. DCNL This runs checks on the destination host, and then calls DCNL back to the source host to check the results. DCNL :param ctxt: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance DCNL :param block_migration: if true, prepare for block migration DCNL :param disk_over_commit: if true, allow disk over commit'
def check_can_live_migrate_destination_cleanup(self, ctxt, dest_check_data): DCNL 'Do required cleanup on dest host after check_can_live_migrate calls DCNL :param ctxt: security context'
def check_can_live_migrate_source(self, ctxt, instance_ref, dest_check_data): DCNL 'Check if it is possible to execute live migration. DCNL This checks if the live migration can succeed, based on the DCNL results from check_can_live_migrate_destination. DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance DCNL :param dest_check_data: result of check_can_live_migrate_destination'
def _assert_dest_node_has_enough_disk(self, context, instance_ref, available_mb, disk_over_commit): DCNL 'Checks if destination has enough disk for block migration.'
def _compare_cpu(self, cpu_info): DCNL 'Checks the host cpu is compatible to a cpu given by xml. DCNL "xml" must be a part of libvirt.openReadonly().getCapabilities(). DCNL return values follows by virCPUCompareResult. DCNL if 0 > return value, do live migration. DCNL \'http://libvirt.org/html/libvirt-libvirt.html#virCPUCompareResult\' DCNL :param cpu_info: json string that shows cpu feature(see get_cpu_info()) DCNL :returns: DCNL None. if given cpu info is not compatible to this server, DCNL raise exception.'
def _create_shared_storage_test_file(self): DCNL 'Makes tmpfile under CONF.instances_path.'
def _check_shared_storage_test_file(self, filename): DCNL 'Confirms existence of the tmpfile under CONF.instances_path. DCNL Cannot confirm tmpfile return False.'
def _cleanup_shared_storage_test_file(self, filename): DCNL 'Removes existence of the tmpfile under CONF.instances_path.'
def ensure_filtering_rules_for_instance(self, instance_ref, network_info, time_module=None): DCNL 'Ensure that an instance\'s filtering rules are enabled. DCNL When migrating an instance, we need the filtering rules to DCNL be configured on the destination host before starting the DCNL migration. DCNL Also, when restarting the compute service, we need to ensure DCNL that filtering rules exist for all running services.'
def live_migration(self, ctxt, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None): DCNL 'Spawning live_migration operation for distributing high-load. DCNL :params ctxt: security context DCNL :params instance_ref: DCNL nova.db.sqlalchemy.models.Instance object DCNL instance object that is migrated. DCNL :params dest: destination host DCNL :params block_migration: destination host DCNL :params post_method: DCNL post operation method. DCNL expected nova.compute.manager.post_live_migration. DCNL :params recover_method: DCNL recovery method when any exception occurs. DCNL expected nova.compute.manager.recover_live_migration. DCNL :params block_migration: if true, do block migration. DCNL :params migrate_data: implementation specific params'
def _live_migration(self, ctxt, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None): DCNL 'Do live migration. DCNL :params ctxt: security context DCNL :params instance_ref: DCNL nova.db.sqlalchemy.models.Instance object DCNL instance object that is migrated. DCNL :params dest: destination host DCNL :params post_method: DCNL post operation method. DCNL expected nova.compute.manager.post_live_migration. DCNL :params recover_method: DCNL recovery method when any exception occurs. DCNL expected nova.compute.manager.recover_live_migration. DCNL :params migrate_data: implementation specific params'
def _fetch_instance_kernel_ramdisk(self, context, instance): DCNL 'Download kernel and ramdisk for instance in instance directory.'
def pre_live_migration(self, context, instance, block_device_info, network_info, migrate_data=None): DCNL 'Preparation live migration.'
def pre_block_migration(self, ctxt, instance, disk_info_json): DCNL 'Preparation for block migration.'
def _create_images_and_backing(self, ctxt, instance, disk_info_json): DCNL ':params ctxt: security context DCNL :params instance: DCNL nova.db.sqlalchemy.models.Instance object DCNL instance object that is migrated. DCNL :params disk_info_json: DCNL json strings specified in get_instance_disk_info'
def post_live_migration_at_destination(self, ctxt, instance_ref, network_info, block_migration, block_device_info=None): DCNL 'Post operation of live migration at destination host. DCNL :param ctxt: security context DCNL :param instance_ref: DCNL nova.db.sqlalchemy.models.Instance object DCNL instance object that is migrated. DCNL :param network_info: instance network information DCNL :param block_migration: if true, post operation of block_migraiton.'
def get_instance_disk_info(self, instance_name, xml=None): DCNL 'Preparation block migration. DCNL :params instance_ref: DCNL nova.db.sqlalchemy.models.Instance object DCNL instance object that is migrated. DCNL :return: DCNL json strings with below format:: DCNL "[{\'path\':\'disk\', \'type\':\'raw\', DCNL \'virt_disk_size\':\'10737418240\', DCNL \'backing_file\':\'backing_file\', DCNL \'disk_size\':\'83886080\'},...]"'
def get_disk_over_committed_size_total(self): DCNL 'Return total over committed disk size for all instances.'
def unfilter_instance(self, instance_ref, network_info): DCNL 'See comments of same method in firewall_driver.'
def get_host_stats(self, refresh=False): DCNL 'Return the current state of the host. DCNL If \'refresh\' is True, run update the stats first.'
def get_host_uptime(self, host): DCNL 'Returns the result of calling "uptime".'
def manage_image_cache(self, context, all_instances): DCNL 'Manage the local cache of images.'
def _cleanup_remote_migration(self, dest, inst_base, inst_base_resize): DCNL 'Used only for cleanup in case migrate_disk_and_power_off fails.'
def _cleanup_failed_migration(self, inst_base): DCNL 'Make sure that a failed migrate doesn\'t prevent us from rolling DCNL back in a revert.'
def confirm_migration(self, migration, instance, network_info): DCNL 'Confirms a resize, destroying the source VM.'
def add_to_aggregate(self, context, aggregate, host, **kwargs): DCNL 'Add a compute host to an aggregate.'
def remove_from_aggregate(self, context, aggregate, host, **kwargs): DCNL 'Remove a compute host from an aggregate.'
def undo_aggregate_operation(self, context, op, aggregate, host, set_error=True): DCNL 'only used for Resource Pools.'
def get_host_stats(self, refresh=False): DCNL 'Return the current state of the host. DCNL If \'refresh\' is True, run update the stats first.'
def update_status(self): DCNL 'Retrieve status info from libvirt.'
def get_config_bridge(self, instance, network, mapping, image_meta): DCNL 'Get VIF configurations for bridge type.'
def plug_bridge(self, instance, vif): DCNL 'Ensure that the bridge exists, and add VIF to it.'
def plug_ovs_bridge(self, instance, vif): DCNL 'No manual plugging required.'
def plug_ovs_hybrid(self, instance, vif): DCNL 'Plug using hybrid strategy DCNL Create a per-VIF linux bridge, then link that bridge to the OVS DCNL integration bridge via a veth device, setting up the other end DCNL of the veth device just like a normal OVS port.  Then boot the DCNL VIF on the linux bridge using standard libvirt mechanisms.'
def unplug_bridge(self, instance, vif): DCNL 'No manual unplugging required.'
def unplug_ovs_ethernet(self, instance, vif): DCNL 'Unplug the VIF by deleting the port from the bridge.'
def unplug_ovs_bridge(self, instance, vif): DCNL 'No manual unplugging required.'
def unplug_ovs_hybrid(self, instance, vif): DCNL 'UnPlug using hybrid strategy DCNL Unhook port from OVS, unhook port from bridge, delete DCNL bridge, and delete both veth devices.'
def connect_volume(self, connection_info, disk_info): DCNL 'Connect the volume. Returns xml for libvirt.'
def disconnect_volume(self, connection_info, disk_dev): DCNL 'Disconnect the volume.'
def connect_volume(self, connection_info, disk_info): DCNL 'Connect the volume to a local device.'
def connect_volume(self, connection_info, disk_info): DCNL 'Connect the volume to a fake device.'
@lockutils.synchronized('connect_volume', 'nova-') DCNL def connect_volume(self, connection_info, disk_info): DCNL 'Attach the volume to instance_name.'
@lockutils.synchronized('connect_volume', 'nova-') DCNL def disconnect_volume(self, connection_info, disk_dev): DCNL 'Detach the volume from instance_name.'
def __init__(self, connection): DCNL 'Create back-end to nfs.'
def connect_volume(self, connection_info, disk_info): DCNL 'Connect the volume. Returns xml for libvirt.'
def _ensure_mounted(self, nfs_export): DCNL '@type nfs_export: string'
def _mount_nfs(self, mount_path, nfs_share, ensure=False): DCNL 'Mount nfs export to mount path.'
@staticmethod DCNL def get_hash_str(base_str): DCNL 'returns string that represents hash of base_str (in hex format).'
@staticmethod DCNL def _path_exists(path): DCNL 'Check path.'
def _aoe_discover(self): DCNL 'Call aoe-discover (aoe-tools) AoE Discover.'
def _aoe_revalidate(self, aoedev): DCNL 'Revalidate the LUN Geometry (When an AoE ID is reused).'
def __init__(self, connection): DCNL 'Create back-end to glusterfs.'
def connect_volume(self, connection_info, mount_device): DCNL 'Connect the volume. Returns xml for libvirt.'
def _ensure_mounted(self, glusterfs_export): DCNL '@type glusterfs_export: string'
def _mount_glusterfs(self, mount_path, glusterfs_share, ensure=False): DCNL 'Mount glusterfs export to mount path.'
@staticmethod DCNL def get_hash_str(base_str): DCNL 'returns string that represents hash of base_str (in hex format).'
@staticmethod DCNL def _path_exists(path): DCNL 'Check path.'
@lockutils.synchronized('connect_volume', 'nova-') DCNL def connect_volume(self, connection_info, disk_info): DCNL 'Attach the volume to instance_name.'
@lockutils.synchronized('connect_volume', 'nova-') DCNL def disconnect_volume(self, connection_info, mount_device): DCNL 'Detach the volume from instance_name.'
def __init__(self, connection): DCNL 'Create back-end to SOFS and check connection.'
def connect_volume(self, connection_info, disk_info): DCNL 'Connect the volume. Returns xml for libvirt.'
def _check_prerequisites(self): DCNL 'Sanity checks before attempting to mount SOFS.'
def apply_instance_filter(self, instance, network_info): DCNL 'No-op. Everything is done in prepare_instance_filter.'
@staticmethod DCNL def nova_no_nd_reflection_filter(): DCNL 'This filter protects false positives on IPv6 Duplicate Address DCNL Detection(DAD).'
@staticmethod DCNL def nova_dhcp_filter(): DCNL 'The standard allow-dhcp-server filter is an <ip> one, so it uses DCNL ebtables to allow traffic through. Without a corresponding rule in DCNL iptables, it\'ll get blocked anyway.'
def setup_basic_filtering(self, instance, network_info): DCNL 'Set up basic filtering (MAC, IP, and ARP spoofing protection).'
def get_base_filter_list(self, instance, allow_dhcp): DCNL 'Obtain a list of base filters to apply to an instance. DCNL The return value should be a list of strings, each DCNL specifying a filter name.  Subclasses can override this DCNL function to add additional filters as needed.  Additional DCNL filters added to the list must also be correctly defined DCNL within the subclass.'
def _ensure_static_filters(self): DCNL 'Static filters are filters that have no need to be IP aware. DCNL There is no configuration or tuneability of these filters, so they DCNL can be set up once and forgotten about.'
def unfilter_instance(self, instance, network_info): DCNL 'Clear out the nwfilter rules.'
def instance_filter_exists(self, instance, network_info): DCNL 'Check nova-instance-instance-xxx exists.'
def setup_basic_filtering(self, instance, network_info): DCNL 'Set up provider rules and basic NWFilter.'
def apply_instance_filter(self, instance, network_info): DCNL 'No-op. Everything is done in prepare_instance_filter.'
def instance_filter_exists(self, instance, network_info): DCNL 'Check nova-instance-instance-xxx exists.'
def __init__(self, source_type, driver_format, is_block_dev=False): DCNL 'Image initialization. DCNL :source_type: block or file DCNL :driver_format: raw or qcow2 DCNL :is_block_dev:'
@abc.abstractmethod DCNL def create_image(self, prepare_template, base, size, *args, **kwargs): DCNL 'Create image from template. DCNL Contains specific behavior for each image type. DCNL :prepare_template: function, that creates template. DCNL Should accept `target` argument. DCNL :base: Template name DCNL :size: Size of created image in bytes'
def libvirt_info(self, disk_bus, disk_dev, device_type, cache_mode, extra_specs): DCNL 'Get `LibvirtConfigGuestDisk` filled for this image. DCNL :disk_dev: Disk bus device name DCNL :disk_bus: Disk bus type DCNL :device_type: Device type for this image. DCNL :cache_mode: Caching mode for this image DCNL :extra_specs: Instance type extra specs dict.'
def cache(self, fetch_func, filename, size=None, *args, **kwargs): DCNL 'Creates image from template. DCNL Ensures that template and image not already exists. DCNL Ensures that base directory exists. DCNL Synchronizes on template fetching. DCNL :fetch_func: Function that creates the base image DCNL Should accept `target` argument. DCNL :filename: Name of the file in the image directory DCNL :size: Size of created image in bytes (optional)'
def _can_fallocate(self): DCNL 'Check once per class, whether fallocate(1) is available, DCNL and that the instances directory supports fallocate(2).'
def image(self, instance, disk_name, image_type=None): DCNL 'Constructs image for selected backend DCNL :instance: Instance name. DCNL :name: Image name. DCNL :image_type: Image type. DCNL Optional, is CONF.libvirt_images_type by default.'
def snapshot(self, disk_path, snapshot_name, image_type=None): DCNL 'Returns snapshot for given image DCNL :path: path to image DCNL :snapshot_name: snapshot name DCNL :image_type: type of image'
def _detect_nbd_devices(self): DCNL 'Detect nbd device files.'
def get_dev(self): DCNL 'Retry requests for NBD devices.'
def reset_dev(self): DCNL 'Reset device paths to allow unmounting.'
def get_dev(self): DCNL 'Make the image available as a block device in the file system.'
def _get_dev_retry_helper(self): DCNL 'Some implementations need to retry their get_dev.'
def unget_dev(self): DCNL 'Release the block device from the file system namespace.'
def map_dev(self): DCNL 'Map partitions of the device to the file system namespace.'
def unmap_dev(self): DCNL 'Remove partitions of the device from the file system namespace.'
def mnt_dev(self): DCNL 'Mount the device into the file system.'
def unmnt_dev(self): DCNL 'Unmount the device from the file system.'
def do_mount(self): DCNL 'Call the get, map and mnt operations.'
def do_umount(self): DCNL 'Call the unmnt operation.'
def do_teardown(self): DCNL 'Call the umnt, unmap, and unget operations.'
def _reset(self, device): DCNL 'Reset internal state for a previously mounted directory.'
@property DCNL def errors(self): DCNL 'Return the collated errors from all operations.'
def mount(self): DCNL 'Mount a disk image, using the object attributes. DCNL The first supported means provided by the mount classes is used. DCNL True, or False is returned and the \'errors\' attribute DCNL contains any diagnostics.'
def umount(self): DCNL 'Umount a mount point from the filesystem.'
def teardown(self): DCNL 'Remove a disk image from the file system.'
def init_host(self, host): DCNL 'Initialize anything that is necessary for the driver to function, DCNL including catching up with currently running VM\'s on the given host.'
def get_info(self, instance): DCNL 'Get the current status of an instance, by name (not ID!) DCNL Returns a dict containing: DCNL :state:           the running state, one of the power_state codes DCNL :max_mem:         (int) the maximum memory in KBytes allowed DCNL :mem:             (int) the memory in KBytes used by the domain DCNL :num_cpu:         (int) the number of virtual CPUs for the domain DCNL :cpu_time:        (int) the CPU time used in nanoseconds'
def get_num_instances(self): DCNL 'Return the total number of virtual machines. DCNL Return the number of virtual machines that the hypervisor knows DCNL about. DCNL .. note:: DCNL This implementation works for all drivers, but it is DCNL not particularly efficient. Maintainers of the virt drivers are DCNL encouraged to override this method with something more DCNL efficient.'
def instance_exists(self, instance_id): DCNL 'Checks existence of an instance on the host. DCNL :param instance_id: The ID / name of the instance to lookup DCNL Returns True if an instance with the supplied ID exists on DCNL the host, False otherwise. DCNL .. note:: DCNL This implementation works for all drivers, but it is DCNL not particularly efficient. Maintainers of the virt drivers are DCNL encouraged to override this method with something more DCNL efficient.'
def list_instances(self): DCNL 'Return the names of all the instances known to the virtualization DCNL layer, as a list.'
def list_instance_uuids(self): DCNL 'Return the UUIDS of all the instances known to the virtualization DCNL layer, as a list.'
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info=None, block_device_info=None): DCNL 'Create a new instance/VM/domain on the virtualization platform. DCNL Once this successfully completes, the instance should be DCNL running (power_state.RUNNING). DCNL If this fails, any partial instance should be completely DCNL cleaned up, and the virtualization platform should be in the state DCNL that it was before this call began. DCNL :param context: security context DCNL :param instance: Instance object as returned by DB layer. DCNL This function should use the data there to guide DCNL the creation of the new instance. DCNL :param image_meta: image object returned by nova.image.glance that DCNL defines the image from which to boot this instance DCNL :param injected_files: User files to inject into instance. DCNL :param admin_password: Administrator password to set in instance. DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL :param block_device_info: Information about block devices to be DCNL attached to the instance.'
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True): DCNL 'Destroy (shutdown and delete) the specified instance. DCNL If the instance is not found (for example if networking failed), this DCNL function should still succeed.  It\'s probably a good idea to log a DCNL warning in that case. DCNL :param instance: Instance object as returned by DB layer. DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL :param block_device_info: Information about block devices that should DCNL be detached from the instance. DCNL :param destroy_disks: Indicates if disks should be destroyed'
def reboot(self, context, instance, network_info, reboot_type, block_device_info=None, bad_volumes_callback=None): DCNL 'Reboot the specified instance. DCNL After this is called successfully, the instance\'s state DCNL goes back to power_state.RUNNING. The virtualization DCNL platform should ensure that the reboot action has completed DCNL successfully even in cases in which the underlying domain/vm DCNL is paused or halted/stopped. DCNL :param instance: Instance object as returned by DB layer. DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL :param reboot_type: Either a HARD or SOFT reboot DCNL :param block_device_info: Info pertaining to attached volumes DCNL :param bad_volumes_callback: Function to handle any bad volumes DCNL encountered'
def get_diagnostics(self, instance): DCNL 'Return data about VM diagnostics.'
def get_all_bw_counters(self, instances): DCNL 'Return bandwidth usage counters for each interface on each DCNL running VM'
def get_all_volume_usage(self, context, compute_host_bdms): DCNL 'Return usage info for volumes attached to vms on DCNL a given host'
def get_host_ip_addr(self): DCNL 'Retrieves the IP address of the dom0'
def attach_volume(self, connection_info, instance, mountpoint): DCNL 'Attach the disk to the instance at mountpoint using info.'
def detach_volume(self, connection_info, instance, mountpoint): DCNL 'Detach the disk attached to the instance.'
def attach_interface(self, instance, image_meta, network_info): DCNL 'Attach an interface to the instance.'
def detach_interface(self, instance, network_info): DCNL 'Detach an interface from the instance.'
def migrate_disk_and_power_off(self, context, instance, dest, instance_type, network_info, block_device_info=None): DCNL 'Transfers the disk of a running instance in multiple phases, turning DCNL off the instance before the end.'
def snapshot(self, context, instance, image_id, update_task_state): DCNL 'Snapshots the specified instance. DCNL :param context: security context DCNL :param instance: Instance object as returned by DB layer. DCNL :param image_id: Reference to a pre-created image that will DCNL hold the snapshot.'
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance, block_device_info=None): DCNL 'Completes a resize, turning on the migrated instance DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL :param image_meta: image object returned by nova.image.glance that DCNL defines the image from which this instance DCNL was created'
def confirm_migration(self, migration, instance, network_info): DCNL 'Confirms a resize, destroying the source VM.'
def finish_revert_migration(self, instance, network_info, block_device_info=None): DCNL 'Finish reverting a resize, powering back on the instance.'
def pause(self, instance): DCNL 'Pause the specified instance.'
def unpause(self, instance): DCNL 'Unpause paused VM instance.'
def suspend(self, instance): DCNL 'suspend the specified instance.'
def resume(self, instance, network_info, block_device_info=None): DCNL 'resume the specified instance.'
def resume_state_on_host_boot(self, context, instance, network_info, block_device_info=None): DCNL 'resume guest state when a host is booted.'
def rescue(self, context, instance, network_info, image_meta, rescue_password): DCNL 'Rescue the specified instance.'
def unrescue(self, instance, network_info): DCNL 'Unrescue the specified instance.'
def power_off(self, instance): DCNL 'Power off the specified instance.'
def power_on(self, instance): DCNL 'Power on the specified instance.'
def soft_delete(self, instance): DCNL 'Soft delete the specified instance.'
def restore(self, instance): DCNL 'Restore the specified instance.'
def get_available_resource(self, nodename): DCNL 'Retrieve resource information. DCNL This method is called when nova-compute launches, and DCNL as part of a periodic task DCNL :param nodename: DCNL node which the caller want to get resources from DCNL a driver that manages only one node can safely ignore this DCNL :returns: Dictionary describing resources'
def pre_live_migration(self, ctxt, instance_ref, block_device_info, network_info, migrate_data=None): DCNL 'Prepare an instance for live migration DCNL :param ctxt: security context DCNL :param instance_ref: instance object that will be migrated DCNL :param block_device_info: instance block device information DCNL :param network_info: instance network information DCNL :param migrate_data: implementation specific data dict.'
def pre_block_migration(self, ctxt, instance_ref, disk_info): DCNL 'Prepare a block device for migration DCNL :param ctxt: security context DCNL :param instance_ref: instance object that will have its disk migrated DCNL :param disk_info: information about disk to be migrated (as returned DCNL from get_instance_disk_info())'
def live_migration(self, ctxt, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None): DCNL 'Live migration of an instance to another host. DCNL :params ctxt: security context DCNL :params instance_ref: DCNL nova.db.sqlalchemy.models.Instance object DCNL instance object that is migrated. DCNL :params dest: destination host DCNL :params post_method: DCNL post operation method. DCNL expected nova.compute.manager.post_live_migration. DCNL :params recover_method: DCNL recovery method when any exception occurs. DCNL expected nova.compute.manager.recover_live_migration. DCNL :params block_migration: if true, migrate VM disk. DCNL :params migrate_data: implementation specific params.'
def post_live_migration_at_destination(self, ctxt, instance_ref, network_info, block_migration=False, block_device_info=None): DCNL 'Post operation of live migration at destination host. DCNL :param ctxt: security context DCNL :param instance_ref: instance object that is migrated DCNL :param network_info: instance network information DCNL :param block_migration: if true, post operation of block_migration.'
def check_can_live_migrate_destination(self, ctxt, instance_ref, src_compute_info, dst_compute_info, block_migration=False, disk_over_commit=False): DCNL 'Check if it is possible to execute live migration. DCNL This runs checks on the destination host, and then calls DCNL back to the source host to check the results. DCNL :param ctxt: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance DCNL :param src_compute_info: Info about the sending machine DCNL :param dst_compute_info: Info about the receiving machine DCNL :param block_migration: if true, prepare for block migration DCNL :param disk_over_commit: if true, allow disk over commit'
def check_can_live_migrate_destination_cleanup(self, ctxt, dest_check_data): DCNL 'Do required cleanup on dest host after check_can_live_migrate calls DCNL :param ctxt: security context DCNL :param dest_check_data: result of check_can_live_migrate_destination'
def check_can_live_migrate_source(self, ctxt, instance_ref, dest_check_data): DCNL 'Check if it is possible to execute live migration. DCNL This checks if the live migration can succeed, based on the DCNL results from check_can_live_migrate_destination. DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance DCNL :param dest_check_data: result of check_can_live_migrate_destination'
def refresh_security_group_rules(self, security_group_id): DCNL 'This method is called after a change to security groups. DCNL All security groups and their associated rules live in the datastore, DCNL and calling this method should apply the updated rules to instances DCNL running the specified security group. DCNL An error should be raised if the operation cannot complete.'
def refresh_security_group_members(self, security_group_id): DCNL 'This method is called when a security group is added to an instance. DCNL This message is sent to the virtualization drivers on hosts that are DCNL running an instance that belongs to a security group that has a rule DCNL that references the security group identified by `security_group_id`. DCNL It is the responsibility of this method to make sure any rules DCNL that authorize traffic flow with members of the security group are DCNL updated and any new members can communicate, and any removed members DCNL cannot. DCNL Scenario: DCNL * we are running on host \'H0\' and we have an instance \'i-0\'. DCNL * instance \'i-0\' is a member of security group \'speaks-b\' DCNL * group \'speaks-b\' has an ingress rule that authorizes group \'b\' DCNL * another host \'H1\' runs an instance \'i-1\' DCNL * instance \'i-1\' is a member of security group \'b\' DCNL When \'i-1\' launches or terminates we will receive the message DCNL to update members of group \'b\', at which time we will make DCNL any changes needed to the rules for instance \'i-0\' to allow DCNL or deny traffic coming from \'i-1\', depending on if it is being DCNL added or removed from the group. DCNL In this scenario, \'i-1\' could just as easily have been running on our DCNL host \'H0\' and this method would still have been called.  The point was DCNL that this method isn\'t called on the host where instances of that DCNL group are running (as is the case with DCNL :py:meth:`refresh_security_group_rules`) but is called where references DCNL are made to authorizing those instances. DCNL An error should be raised if the operation cannot complete.'
def refresh_provider_fw_rules(self): DCNL 'This triggers a firewall update based on database changes. DCNL When this is called, rules have either been added or removed from the DCNL datastore.  You can retrieve rules with DCNL :py:meth:`nova.db.provider_fw_rule_get_all`. DCNL Provider rules take precedence over security group rules.  If an IP DCNL would be allowed by a security group ingress rule, but blocked by DCNL a provider rule, then packets from the IP are dropped.  This includes DCNL intra-project traffic in the case of the allow_project_net_traffic DCNL flag for the libvirt-derived classes.'
def reset_network(self, instance): DCNL 'reset networking for specified instance.'
def ensure_filtering_rules_for_instance(self, instance_ref, network_info): DCNL 'Setting up filtering rules and waiting for its completion. DCNL To migrate an instance, filtering rules to hypervisors DCNL and firewalls are inevitable on destination host. DCNL ( Waiting only for filtering rules to hypervisor, DCNL since filtering rules to firewall rules can be set faster). DCNL Concretely, the below method must be called. DCNL - setup_basic_filtering (for nova-basic, etc.) DCNL - prepare_instance_filter(for nova-instance-instance-xxx, etc.) DCNL to_xml may have to be called since it defines PROJNET, PROJMASK. DCNL but libvirt migrates those value through migrateToURI(), DCNL so , no need to be called. DCNL Don\'t use thread for this method since migration should DCNL not be started when setting-up filtering rules operations DCNL are not completed. DCNL :params instance_ref: nova.db.sqlalchemy.models.Instance object'
def filter_defer_apply_on(self): DCNL 'Defer application of IPTables rules.'
def filter_defer_apply_off(self): DCNL 'Turn off deferral of IPTables rules and apply the rules now.'
def unfilter_instance(self, instance, network_info): DCNL 'Stop filtering instance.'
def set_admin_password(self, context, instance_id, new_pass=None): DCNL 'Set the root password on the specified instance. DCNL The first parameter is an instance of nova.compute.service.Instance, DCNL and so the instance is being specified as instance.name. The second DCNL parameter is the value of the new password.'
def inject_file(self, instance, b64_path, b64_contents): DCNL 'Writes a file on the specified instance. DCNL The first parameter is an instance of nova.compute.service.Instance, DCNL and so the instance is being specified as instance.name. The second DCNL parameter is the base64-encoded path to which the file is to be DCNL written on the instance; the third is the contents of the file, also DCNL base64-encoded.'
def change_instance_metadata(self, context, instance, diff): DCNL 'Applies a diff to the instance metadata. DCNL This is an optional driver method which is used to publish DCNL changes to the instance\'s metadata to the hypervisor.  If the DCNL hypervisor has no means of publishing the instance metadata to DCNL the instance, then this method should not be implemented.'
def inject_network_info(self, instance, nw_info): DCNL 'inject network info for specified instance.'
def poll_rebooting_instances(self, timeout, instances): DCNL 'Poll for rebooting instances DCNL :param timeout: the currently configured timeout for considering DCNL rebooting instances to be stuck DCNL :param instances: instances that have been in rebooting state DCNL longer than the configured timeout'
def host_power_action(self, host, action): DCNL 'Reboots, shuts down or powers up the host.'
def host_maintenance_mode(self, host, mode): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL guest VMs evacuation.'
def set_host_enabled(self, host, enabled): DCNL 'Sets the specified host\'s ability to accept new instances.'
def get_host_uptime(self, host): DCNL 'Returns the result of calling "uptime" on the target host.'
def plug_vifs(self, instance, network_info): DCNL 'Plug VIFs into networks.'
def unplug_vifs(self, instance, network_info): DCNL 'Unplug VIFs from networks.'
def get_host_stats(self, refresh=False): DCNL 'Return currently known host stats.'
def block_stats(self, instance_name, disk_id): DCNL 'Return performance counters associated with the given disk_id on the DCNL given instance_name.  These are returned as [rd_req, rd_bytes, wr_req, DCNL wr_bytes, errs], where rd indicates read, wr indicates write, req is DCNL the total number of I/O requests made, bytes is the total number of DCNL bytes transferred, and errs is the number of requests held up due to a DCNL full pipeline. DCNL All counters are long integers. DCNL This method is optional.  On some platforms (e.g. XenAPI) performance DCNL statistics can be retrieved directly in aggregate form, without Nova DCNL having to do the aggregation.  On those platforms, this method is DCNL unused. DCNL Note that this function takes an instance ID.'
def interface_stats(self, instance_name, iface_id): DCNL 'Return performance counters associated with the given iface_id on the DCNL given instance_id.  These are returned as [rx_bytes, rx_packets, DCNL rx_errs, rx_drop, tx_bytes, tx_packets, tx_errs, tx_drop], where rx DCNL indicates receive, tx indicates transmit, bytes and packets indicate DCNL the total number of bytes or packets transferred, and errs and dropped DCNL is the total number of packets failed / dropped. DCNL All counters are long integers. DCNL This method is optional.  On some platforms (e.g. XenAPI) performance DCNL statistics can be retrieved directly in aggregate form, without Nova DCNL having to do the aggregation.  On those platforms, this method is DCNL unused. DCNL Note that this function takes an instance ID.'
def legacy_nwinfo(self): DCNL 'True if the driver requires the legacy network_info format.'
def macs_for_instance(self, instance): DCNL 'What MAC addresses must this instance have? DCNL Some hypervisors (such as bare metal) cannot do freeform virtualisation DCNL of MAC addresses. This method allows drivers to return a set of MAC DCNL addresses that the instance is to have. allocate_for_instance will take DCNL this into consideration when provisioning networking for the instance. DCNL Mapping of MAC addresses to actual networks (or permitting them to be DCNL freeform) is up to the network implementation layer. For instance, DCNL with openflow switches, fixed MAC addresses can still be virtualised DCNL onto any L2 domain, with arbitrary VLANs etc, but regular switches DCNL require pre-configured MAC->network mappings that will match the DCNL actual configuration. DCNL Most hypervisors can use the default implementation which returns None. DCNL Hypervisors with MAC limits should return a set of MAC addresses, which DCNL will be supplied to the allocate_for_instance call by the compute DCNL manager, and it is up to that call to ensure that all assigned network DCNL details are compatible with the set of MAC addresses. DCNL This is called during spawn_instance by the compute manager. DCNL :return: None, or a set of MAC ids (e.g. set([\'12:34:56:78:90:ab\'])). DCNL None means \'no constraints\', a set means \'these and only these DCNL MAC addresses\'.'
def manage_image_cache(self, context, all_instances): DCNL 'Manage the driver\'s local image cache. DCNL Some drivers chose to cache images for instances on disk. This method DCNL is an opportunity to do management of that cache which isn\'t directly DCNL related to other calls into the driver. The prime example is to clean DCNL the cache and remove images which are no longer of interest.'
def add_to_aggregate(self, context, aggregate, host, **kwargs): DCNL 'Add a compute host to an aggregate.'
def remove_from_aggregate(self, context, aggregate, host, **kwargs): DCNL 'Remove a compute host from an aggregate.'
def undo_aggregate_operation(self, context, op, aggregate, host, set_error=True): DCNL 'Undo for Resource Pools.'
def get_volume_connector(self, instance): DCNL 'Get connector information for the instance for attaching to volumes. DCNL Connector information is a dictionary representing the ip of the DCNL machine that will be making the connection, the name of the iscsi DCNL initiator and the hostname of the machine as follows:: DCNL \'ip\': ip, DCNL \'initiator\': initiator, DCNL \'host\': hostname'
def get_available_nodes(self): DCNL 'Returns nodenames of all nodes managed by the compute service. DCNL This method is for multi compute-nodes support. If a driver supports DCNL multi compute-nodes, this method returns a list of nodenames managed DCNL by the service. Otherwise, this method should return DCNL [hypervisor_hostname].'
def get_per_instance_usage(self): DCNL 'Get information about instance resource usage. DCNL :returns: dict of  nova uuid => dict of usage info'
def instance_on_disk(self, instance): DCNL 'Checks access of instance files on the host. DCNL :param instance: instance to lookup DCNL Returns True if files of an instance with the supplied ID accessible on DCNL the host, False otherwise. DCNL .. note:: DCNL Used in rebuild for HA implementation and required for validation DCNL of access to instance shared disk files'
def register_event_listener(self, callback): DCNL 'Register a callback to receive events. DCNL Register a callback to receive asynchronous event DCNL notifications from hypervisors. The callback will DCNL be invoked with a single parameter, which will be DCNL an instance of the nova.virt.event.Event class.'
def emit_event(self, event): DCNL 'Dispatches an event to the compute manager. DCNL Invokes the event callback registered by the DCNL compute manager to dispatch the event. This DCNL must only be invoked from a green thread.'
def activate_node(self, context, node, instance): DCNL 'For operations after power on.'
def deactivate_node(self, context, node, instance): DCNL 'For operations before power off.'
def is_power_on(self): DCNL 'Returns True or False according as the node\'s power state.'
def _require_node(self, instance): DCNL 'Get a node\'s uuid out of a manager instance dict. DCNL The compute manager is meant to know the node uuid, so missing uuid DCNL a significant issue - it may mean we\'ve been passed someone elses data.'
def power_off(self, instance, node=None): DCNL 'Power off the specified instance.'
def power_on(self, instance, node=None): DCNL 'Power on the specified instance.'
def plug_vifs(self, instance, network_info): DCNL 'Plugin VIFs into networks.'
def manage_image_cache(self, context, all_instances): DCNL 'Manage the local cache of images.'
def _run_command(self, cmd, check_exit_code=True): DCNL 'Run a remote command using an active ssh connection. DCNL :param command: String with the command to run. DCNL If {_NodeName_} is in the command it will get replaced by DCNL the _matched_name value. DCNL base_cmd will also get prepended to the command.'
def get_all_block_devices(self): DCNL 'Return all block devices in use on this node.'
def _power_on(self): DCNL 'Turn the power to this node ON.'
def _power_off(self): DCNL 'Turn the power to this node OFF.'
def activate_node(self): DCNL 'Turns the power to node ON.'
def reboot_node(self): DCNL 'Cycles the power to a node.'
def deactivate_node(self): DCNL 'Turns the power to node OFF, regardless of current state.'
def _cache_tftp_images(self, context, instance, image_info): DCNL 'Fetch the necessary kernels and ramdisks for the instance.'
def _cache_image(self, context, instance, image_meta): DCNL 'Fetch the instance\'s image from Glance DCNL This method pulls the relevant AMI and associated kernel and ramdisk, DCNL and the deploy kernel and ramdisk from Glance, and writes them DCNL to the appropriate places on local disk. DCNL Both sets of kernel and ramdisk are needed for PXE booting, so these DCNL are stored under CONF.baremetal.tftp_root. DCNL At present, the AMI is cached and certain files are injected. DCNL Debian/ubuntu-specific assumptions are made regarding the injected DCNL files. In a future revision, this functionality will be replaced by a DCNL more scalable and os-agnostic approach: the deployment ramdisk will DCNL fetch from Glance directly, and write its own last-mile configuration.'
def _inject_into_image(self, context, node, instance, network_info, injected_files=None, admin_password=None): DCNL 'Inject last-mile configuration into instances image DCNL Much of this method is a hack around DHCP and cloud-init DCNL not working together with baremetal provisioning yet.'
def cache_images(self, context, node, instance, admin_password, image_meta, injected_files, network_info): DCNL 'Prepare all the images for this instance.'
def destroy_images(self, context, node, instance): DCNL 'Delete instance\'s image file.'
def activate_bootloader(self, context, node, instance): DCNL 'Configure PXE boot loader for an instance DCNL Kernel and ramdisk images are downloaded by cache_tftp_images, DCNL and stored in /tftpboot/{uuid}/ DCNL This method writes the instances config file, and then creates DCNL symlinks for each MAC address in the instance. DCNL By default, the complete layout looks like this: DCNL /tftpboot/ DCNL ./{uuid}/ DCNL kernel DCNL ramdisk DCNL deploy_kernel DCNL deploy_ramdisk DCNL config DCNL ./pxelinux.cfg/ DCNL {mac} -> ../{uuid}/config'
def deactivate_bootloader(self, context, node, instance): DCNL 'Delete PXE bootloader images and config.'
def activate_node(self, context, node, instance): DCNL 'Wait for PXE deployment to complete.'
def activate_node(self, context, node, instance): DCNL 'For operations after power on.'
def deactivate_node(self, context, node, instance): DCNL 'For operations before power off.'
def init_host(self, host): DCNL 'Do the initialization that needs to be done.'
def list_instances(self): DCNL 'List VM instances.'
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info=None, block_device_info=None): DCNL 'Create VM instance.'
def snapshot(self, context, instance, name, update_task_state): DCNL 'Create snapshot from a running VM instance.'
def reboot(self, context, instance, network_info, reboot_type, block_device_info=None, bad_volumes_callback=None): DCNL 'Reboot VM instance.'
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True): DCNL 'Destroy VM instance.'
def pause(self, instance): DCNL 'Pause VM instance.'
def unpause(self, instance): DCNL 'Unpause paused VM instance.'
def suspend(self, instance): DCNL 'Suspend the specified instance.'
def resume(self, instance, network_info, block_device_info=None): DCNL 'Resume the suspended VM instance.'
def rescue(self, context, instance, network_info, image_meta, rescue_password): DCNL 'Rescue the specified instance.'
def unrescue(self, instance, network_info): DCNL 'Unrescue the specified instance.'
def power_off(self, instance): DCNL 'Power off the specified instance.'
def power_on(self, instance): DCNL 'Power on the specified instance.'
def poll_rebooting_instances(self, timeout, instances): DCNL 'Poll for rebooting instances.'
def get_info(self, instance): DCNL 'Return info about the VM instance.'
def get_diagnostics(self, instance): DCNL 'Return data about VM diagnostics.'
def get_console_output(self, instance): DCNL 'Return snapshot of console.'
def get_vnc_console(self, instance): DCNL 'Return link to instance\'s VNC console.'
def get_volume_connector(self, instance): DCNL 'Return volume connector information.'
def get_host_ip_addr(self): DCNL 'Retrieves the IP address of the ESX host.'
def attach_volume(self, connection_info, instance, mountpoint): DCNL 'Attach volume storage to VM instance.'
def detach_volume(self, connection_info, instance, mountpoint): DCNL 'Detach volume storage to VM instance.'
def get_console_pool_info(self, console_type): DCNL 'Get info about the host on which the VM resides.'
def get_available_resource(self, nodename): DCNL 'Retrieve resource info. DCNL This method is called when nova-compute launches, and DCNL as part of a periodic task. DCNL :returns: dictionary describing resources'
def update_host_status(self): DCNL 'Update the status info of the host, and return those values DCNL to the calling program.'
def get_host_stats(self, refresh=False): DCNL 'Return the current state of the host. If \'refresh\' is DCNL True, run the update first.'
def host_power_action(self, host, action): DCNL 'Reboots, shuts down or powers up the host.'
def host_maintenance_mode(self, host, mode): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL guest VMs evacuation.'
def set_host_enabled(self, host, enabled): DCNL 'Sets the specified host\'s ability to accept new instances.'
def inject_network_info(self, instance, network_info): DCNL 'inject network info for specified instance.'
def plug_vifs(self, instance, network_info): DCNL 'Plug VIFs into networks.'
def unplug_vifs(self, instance, network_info): DCNL 'Unplug VIFs from networks.'
def list_interfaces(self, instance_name): DCNL 'Return the IDs of all the virtual network interfaces attached to the DCNL specified instance, as a list.  These IDs are opaque to the caller DCNL (they are only useful for giving back to this layer as a parameter to DCNL interface_stats).  These IDs only need to be unique for a given DCNL instance.'
def migrate_disk_and_power_off(self, context, instance, dest, instance_type, network_info, block_device_info=None): DCNL 'Transfers the disk of a running instance in multiple phases, turning DCNL off the instance before the end.'
def confirm_migration(self, migration, instance, network_info): DCNL 'Confirms a resize, destroying the source VM.'
def finish_revert_migration(self, instance, network_info, block_device_info=None): DCNL 'Finish reverting a resize, powering back on the instance.'
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance=False, block_device_info=None): DCNL 'Completes a resize, turning on the migrated instance.'
def live_migration(self, context, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None): DCNL 'Live migration of an instance to another host.'
def _get_vim_object(self): DCNL 'Create the VIM Object instance.'
def _create_session(self): DCNL 'Creates a session with the ESX host.'
def __del__(self): DCNL 'Logs-out the session.'
def _is_vim_object(self, module): DCNL 'Check if the module is a VIM Object instance.'
def _call_method(self, module, method, *args, **kwargs): DCNL 'Calls a method within the module specified with DCNL args provided.'
def _get_vim(self): DCNL 'Gets the VIM object reference.'
def _wait_for_task(self, instance_uuid, task_ref): DCNL 'Return a Deferred that will give the result of the given task. DCNL The task is polled until it completes.'
def _poll_task(self, instance_uuid, task_ref, done): DCNL 'Poll the given task, and fires the given Deferred if we DCNL get a result.'
def __init__(self, session, virtapi, volumeops, cluster_name=None): DCNL 'Initializer.'
def list_instances(self): DCNL 'Lists the VM instances that are registered with the ESX host.'
def spawn(self, context, instance, image_meta, network_info, block_device_info=None): DCNL 'Creates a VM instance. DCNL Steps followed are: DCNL 1. Create a VM with no disk and the specifics in the instance object DCNL like RAM size. DCNL 2. For flat disk DCNL 2.1. Create a dummy vmdk of the size of the disk file that is to be DCNL uploaded. This is required just to create the metadata file. DCNL 2.2. Delete the -flat.vmdk file created in the above step and retain DCNL the metadata .vmdk file. DCNL 2.3. Upload the disk file. DCNL 3. For sparse disk DCNL 3.1. Upload the disk file to a -sparse.vmdk file. DCNL 3.2. Copy/Clone the -sparse.vmdk file to a thin vmdk. DCNL 3.3. Delete the -sparse.vmdk file. DCNL 4. Attach the disk to the VM by reconfiguring the same. DCNL 5. Power on the VM.'
def snapshot(self, context, instance, snapshot_name, update_task_state): DCNL 'Create snapshot from a running VM instance. DCNL Steps followed are: DCNL 1. Get the name of the vmdk file which the VM points to right now. DCNL Can be a chain of snapshots, so we need to know the last in the DCNL chain. DCNL 2. Create the snapshot. A new vmdk is created which the VM points to DCNL now. The earlier vmdk becomes read-only. DCNL 3. Call CopyVirtualDisk which coalesces the disk chain to form a single DCNL vmdk, rather a .vmdk metadata file and a -flat.vmdk disk data file. DCNL 4. Now upload the -flat.vmdk file to the image store. DCNL 5. Delete the coalesced .vmdk and -flat.vmdk created.'
def reboot(self, instance, network_info): DCNL 'Reboot a VM instance.'
def _delete(self, instance, network_info): DCNL 'Destroy a VM instance. Steps followed are: DCNL 1. Power off the VM, if it is in poweredOn state. DCNL 2. Destroy the VM.'
def destroy(self, instance, network_info, destroy_disks=True): DCNL 'Destroy a VM instance. Steps followed are: DCNL 1. Power off the VM, if it is in poweredOn state. DCNL 2. Un-register a VM. DCNL 3. Delete the contents of the folder holding the VM related data.'
def suspend(self, instance): DCNL 'Suspend the specified instance.'
def resume(self, instance): DCNL 'Resume the specified instance.'
def rescue(self, context, instance, network_info, image_meta): DCNL 'Rescue the specified instance. DCNL - shutdown the instance VM. DCNL - spawn a rescue VM (the vm name-label will be instance-N-rescue).'
def unrescue(self, instance): DCNL 'Unrescue the specified instance.'
def power_off(self, instance): DCNL 'Power off the specified instance.'
def power_on(self, instance): DCNL 'Power on the specified instance.'
def _update_instance_progress(self, context, instance, step, total_steps): DCNL 'Update instance progress percent to reflect current step number'
def migrate_disk_and_power_off(self, context, instance, dest, instance_type): DCNL 'Transfers the disk of a running instance in multiple phases, turning DCNL off the instance before the end.'
def confirm_migration(self, migration, instance, network_info): DCNL 'Confirms a resize, destroying the source VM.'
def finish_revert_migration(self, instance): DCNL 'Finish reverting a resize, powering back on the instance.'
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance=False): DCNL 'Completes a resize, turning on the migrated instance.'
def live_migration(self, context, instance_ref, dest, post_method, recover_method, block_migration=False): DCNL 'Spawning live_migration operation for distributing high-load.'
def poll_rebooting_instances(self, timeout, instances): DCNL 'Poll for rebooting instances.'
def get_info(self, instance): DCNL 'Return data about the VM instance.'
def get_diagnostics(self, instance): DCNL 'Return data about VM diagnostics.'
def get_console_output(self, instance): DCNL 'Return snapshot of console.'
def get_vnc_console(self, instance): DCNL 'Return connection info for a vnc console.'
@staticmethod DCNL def _get_vnc_port(vm_ref): DCNL 'Return VNC port for an VM.'
def _set_machine_id(self, client_factory, instance, network_info): DCNL 'Set the machine id of the VM for guest tools to pick up and reconfigure DCNL the network interfaces.'
def _set_vnc_config(self, client_factory, instance, port, password): DCNL 'Set the vnc configuration of the VM.'
def _get_datacenter_ref_and_name(self): DCNL 'Get the datacenter name and the reference.'
def _get_host_ref_from_name(self, host_name): DCNL 'Get reference to the host with the name specified.'
def _get_vmfolder_ref(self): DCNL 'Get the Vm folder ref from the datacenter.'
def _path_exists(self, ds_browser, ds_path): DCNL 'Check if the path exists on the datastore.'
def _path_file_exists(self, ds_browser, ds_path, file_name): DCNL 'Check if the path and file exists on the datastore.'
def _mkdir(self, ds_path): DCNL 'Creates a directory at the path specified. If it is just "NAME", DCNL then a directory with this name is created at the topmost level of the DCNL DataStore.'
def inject_network_info(self, instance, network_info): DCNL 'inject network info for specified instance.'
def plug_vifs(self, instance, network_info): DCNL 'Plug VIFs into networks.'
def unplug_vifs(self, instance, network_info): DCNL 'Unplug VIFs from networks.'
def list_interfaces(self, instance_name): DCNL 'Return the IDs of all the virtual network interfaces attached to the DCNL specified instance, as a list.  These IDs are opaque to the caller DCNL (they are only useful for giving back to this layer as a parameter to DCNL interface_stats).  These IDs only need to be unique for a given DCNL instance.'
def read(self, chunk_size): DCNL 'Read data from the pipe. Chunksize if ignored for we have ensured DCNL that the data chunks written to the pipe by readers is the same as the DCNL chunks asked for by the Writer.'
def write(self, data): DCNL 'Put a data item in the pipe.'
def seek(self, offset, whence=0): DCNL 'Set the file\'s current position at the offset.'
def tell(self): DCNL 'Get size of the file to be read.'
def close(self): DCNL 'A place-holder to maintain consistency.'
def __init__(self, protocol='https', host='localhost'): DCNL 'Creates the necessary Communication interfaces and gets the DCNL ServiceContent for initiating SOAP transactions. DCNL protocol: http or https DCNL host    : ESX IPAddress[:port] or ESX Hostname[:port]'
def get_service_content(self): DCNL 'Gets the service content object.'
def __getattr__(self, attr_name): DCNL 'Makes the API calls and gets the result.'
def _request_managed_object_builder(self, managed_object): DCNL 'Builds the request managed object.'
def read(self, chunk_size): DCNL 'Read an item from the queue. The chunk size is ignored for the DCNL Client ImageBodyIterator uses its own CHUNKSIZE.'
def get_next(self): DCNL 'Get the next item from the image iterator.'
def close(self): DCNL 'A dummy close just to maintain consistency.'
def set_eof(self, eof): DCNL 'Set the end of file marker.'
def get_eof(self): DCNL 'Check if the end of file has been reached.'
def close(self): DCNL 'Close the file handle.'
def __del__(self): DCNL 'Close the file handle on garbage collection.'
def _build_vim_cookie_headers(self, vim_cookies): DCNL 'Build ESX host session cookie headers.'
def write(self, data): DCNL 'Write data to the file.'
def read(self, chunk_size): DCNL 'Read a chunk of data.'
def get_size(self): DCNL 'Get size of the file to be read.'
def write(self, data): DCNL 'Write to the file.'
def close(self): DCNL 'Get the response and close the connection.'
def read(self, chunk_size): DCNL 'Read a chunk of data.'
def get_size(self): DCNL 'Get size of the file to be read.'
@staticmethod DCNL def retrieveproperties_fault_checker(resp_obj): DCNL 'Checks the RetrieveProperties response for errors. Certain faults DCNL are sent as part of the SOAP body as property of missingSet. DCNL For example NotAuthenticated fault.'
def host_power_action(self, host, action): DCNL 'Reboots or shuts down the host.'
def host_maintenance_mode(self, host, mode): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL guest VMs evacuation.'
def set_host_enabled(self, _host, enabled): DCNL 'Sets the specified host\'s ability to accept new instances.'
def get_host_stats(self, refresh=False): DCNL 'Return the current state of the host. If \'refresh\' is DCNL True, run the update first.'
def update_status(self): DCNL 'Update the current state of the host.'
def get_host_stats(self, refresh=False): DCNL 'Return the current state of the host. If \'refresh\' is DCNL True, run the update first.'
def update_status(self): DCNL 'Update the current state of the host.'
def attach_disk_to_vm(self, vm_ref, instance_name, adapter_type, disk_type, vmdk_path=None, disk_size=None, linked_clone=False, controller_key=None, unit_number=None, device_name=None): DCNL 'Attach disk to VM by reconfiguration.'
def detach_disk_from_vm(self, vm_ref, instance_name, device): DCNL 'Detach disk from VM by reconfiguration.'
def discover_st(self, data): DCNL 'Discover iSCSI targets.'
def get_volume_connector(self, instance): DCNL 'Return volume connector information.'
def attach_volume(self, connection_info, instance, mountpoint): DCNL 'Attach volume storage to VM instance.'
def detach_volume(self, connection_info, instance, mountpoint): DCNL 'Detach volume storage to VM instance.'
def __init__(self, name='ManagedObject', obj_ref=None): DCNL 'Sets the obj property which acts as a reference to the object.'
def set(self, attr, val): DCNL 'Sets an attribute value. Not using the __setattr__ directly for we DCNL want to set attributes of the type \'a.b.c\' and using this function DCNL class we set the same.'
def get(self, attr): DCNL 'Gets an attribute. Used as an intermediary to get nested DCNL property like \'a.b.c\' value.'
def reconfig(self, factory, val): DCNL 'Called to reconfigure the VM. Actually customizes the property DCNL setting of the Virtual Machine object.'
def _add_port_group(self, spec): DCNL 'Adds a port group to the host system object in the db.'
def create(self, obj_name): DCNL 'Creates a namespace object.'
def __init__(self, protocol='https', host='localhost', trace=None): DCNL 'Initializes the suds client object, sets the service content DCNL contents and the cookies for the session.'
def _login(self): DCNL 'Logs in and sets the session object in the db.'
def _logout(self): DCNL 'Logs out and remove the session object ref from the db.'
def _terminate_session(self, *args, **kwargs): DCNL 'Terminates a session.'
def _check_session(self): DCNL 'Checks if the session is active.'
def _create_vm(self, method, *args, **kwargs): DCNL 'Creates and registers a VM object with the Host System.'
def _reconfig_vm(self, method, *args, **kwargs): DCNL 'Reconfigures a VM and sets the properties supplied.'
def _create_copy_disk(self, method, vmdk_file_path): DCNL 'Creates/copies a vmdk file object in the datastore.'
def _snapshot_vm(self, method): DCNL 'Snapshots a VM. Here we do nothing for faking sake.'
def _delete_disk(self, method, *args, **kwargs): DCNL 'Deletes .vmdk and -flat.vmdk files corresponding to the VM.'
def _delete_file(self, method, *args, **kwargs): DCNL 'Deletes a file from the datastore.'
def _just_return(self): DCNL 'Fakes a return.'
def _just_return_task(self, method): DCNL 'Fakes a task return.'
def _unregister_vm(self, method, *args, **kwargs): DCNL 'Unregisters a VM from the Host System.'
def _search_ds(self, method, *args, **kwargs): DCNL 'Searches the datastore for a file.'
def _make_dir(self, method, *args, **kwargs): DCNL 'Creates a directory in the datastore.'
def _set_power_state(self, method, vm_ref, pwr_state='poweredOn'): DCNL 'Sets power state for the VM.'
def _retrieve_properties(self, method, *args, **kwargs): DCNL 'Retrieves properties based on the type.'
def _add_port_group(self, method, *args, **kwargs): DCNL 'Adds a port group to the host system.'
def instance_update(self, context, instance_uuid, updates): DCNL 'Perform an instance update operation on behalf of a virt driver DCNL :param context: security context DCNL :param instance_uuid: uuid of the instance to be updated DCNL :param updates: dict of attribute=value pairs to change DCNL Returns: orig_instance, new_instance'
def instance_get_by_uuid(self, context, instance_uuid): DCNL 'Look up an instance by uuid DCNL :param context: security context DCNL :param instance_uuid: uuid of the instance to be fetched'
def instance_get_all_by_host(self, context, host): DCNL 'Find all instances on a given host DCNL :param context: security context DCNL :param host: host running instances to be returned'
def aggregate_get_by_host(self, context, host, key=None): DCNL 'Get a list of aggregates to which the specified host belongs DCNL :param context: security context DCNL :param host: the host for which aggregates should be returned DCNL :param key: optionally filter by hosts with the given metadata key'
def aggregate_metadata_add(self, context, aggregate, metadata, set_delete=False): DCNL 'Add/update metadata for specified aggregate DCNL :param context: security context DCNL :param aggregate: aggregate on which to update metadata DCNL :param metadata: dict of metadata to add/update DCNL :param set_delete: if True, only add'
def aggregate_metadata_delete(self, context, aggregate, key): DCNL 'Delete the given metadata key from specified aggregate DCNL :param context: security context DCNL :param aggregate: aggregate from which to delete metadata DCNL :param key: metadata key to delete'
def security_group_get_by_instance(self, context, instance): DCNL 'Get the security group for a specified instance DCNL :param context: security context DCNL :param instance: instance defining the security group we want'
def security_group_rule_get_by_security_group(self, context, security_group): DCNL 'Get the rules associated with a specified security group DCNL :param context: security context DCNL :param security_group: the security group for which the rules DCNL should be returned'
def provider_fw_rule_get_all(self, context): DCNL 'Get the provider firewall rules DCNL :param context: security context'
def agent_build_get_by_triple(self, context, hypervisor, os, architecture): DCNL 'Get information about the available agent builds for a given DCNL hypervisor, os, and architecture DCNL :param context: security context DCNL :param hypervisor: agent hypervisor type DCNL :param os: agent operating system type DCNL :param architecture: agent architecture'
def instance_type_get(self, context, instance_type_id): DCNL 'Get information about an instance type DCNL :param context: security context DCNL :param instance_type_id: the id of the instance type in question'
def prepare_instance_filter(self, instance, network_info): DCNL 'Prepare filters for the instance. DCNL At this point, the instance isn\'t running yet.'
def filter_defer_apply_on(self): DCNL 'Defer application of IPTables rules.'
def filter_defer_apply_off(self): DCNL 'Turn off deferral of IPTables rules and apply the rules now.'
def unfilter_instance(self, instance, network_info): DCNL 'Stop filtering instance.'
def apply_instance_filter(self, instance, network_info): DCNL 'Apply instance filter. DCNL Once this method returns, the instance should be firewalled DCNL appropriately. This method should as far as possible be a DCNL no-op. It\'s vastly preferred to get everything set up in DCNL prepare_instance_filter.'
def refresh_security_group_rules(self, security_group_id): DCNL 'Refresh security group rules from data store DCNL Gets called when a rule has been added to or removed from DCNL the security group.'
def refresh_security_group_members(self, security_group_id): DCNL 'Refresh security group members from data store DCNL Gets called when an instance gets added to or removed from DCNL the security group.'
def refresh_instance_security_rules(self, instance): DCNL 'Refresh security group rules from data store DCNL Gets called when an instance gets added to or removed from DCNL the security group the instance is a member of or if the DCNL group gains or looses a rule.'
def refresh_provider_fw_rules(self): DCNL 'Refresh common rules for all hosts/instances from data store. DCNL Gets called when a rule has been added to or removed from DCNL the list of rules (via admin api).'
def setup_basic_filtering(self, instance, network_info): DCNL 'Create rules to block spoofing and allow dhcp. DCNL This gets called when spawning an instance, before DCNL :py:meth:`prepare_instance_filter`.'
def instance_filter_exists(self, instance, network_info): DCNL 'Check nova-instance-instance-xxx exists.'
def apply_instance_filter(self, instance, network_info): DCNL 'No-op. Everything is done in prepare_instance_filter.'
def _filters_for_instance(self, chain_name, network_info): DCNL 'Creates a rule corresponding to each ip that defines a DCNL jump to the corresponding instance - chain for all the traffic DCNL destined to that ip.'
def refresh_provider_fw_rules(self): DCNL 'See :class:`FirewallDriver` docs.'
@lockutils.synchronized('iptables', 'nova-', external=True) DCNL def _do_refresh_provider_fw_rules(self): DCNL 'Internal, synchronized version of refresh_provider_fw_rules.'
def _purge_provider_fw_rules(self): DCNL 'Remove all rules from the provider chains.'
def _build_provider_fw_rules(self): DCNL 'Create all rules for the provider IP DROPs.'
def _provider_rules(self): DCNL 'Generate a list of rules from provider for IP4 & IP6.'
def _get_cpu_info(self): DCNL 'Get the CPU information. DCNL :returns: A dictionary containing the main properties DCNL of the central processor in the hypervisor.'
def _get_hypervisor_version(self): DCNL 'Get hypervisor version. DCNL :returns: hypervisor version (ex. 12003)'
def get_available_resource(self): DCNL 'Retrieve resource info. DCNL This method is called when nova-compute launches, and DCNL as part of a periodic task. DCNL :returns: dictionary describing resources'
def get_host_stats(self, refresh=False): DCNL 'Return the current state of the host. If \'refresh\' is DCNL True, run the update first.'
def host_power_action(self, host, action): DCNL 'Reboots, shuts down or powers up the host.'
def get_info(self, instance): DCNL 'Get information about the VM.'
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info, block_device_info=None): DCNL 'Create a new VM and start it.'
def reboot(self, instance, network_info, reboot_type): DCNL 'Reboot the specified instance.'
def pause(self, instance): DCNL 'Pause VM instance.'
def unpause(self, instance): DCNL 'Unpause paused VM instance.'
def suspend(self, instance): DCNL 'Suspend the specified instance.'
def resume(self, instance): DCNL 'Resume the suspended VM instance.'
def power_off(self, instance): DCNL 'Power off the specified instance.'
def power_on(self, instance): DCNL 'Power on the specified instance.'
def get_memory_info(self): DCNL 'Returns a tuple with total visible memory and free physical memory DCNL expressed in kB.'
def get_volume_info(self, drive): DCNL 'Returns a tuple with total size and free space DCNL expressed in bytes.'
def login_storage_target(self, target_lun, target_iqn, target_portal): DCNL 'Add target portal, list targets and logins to the target.'
def logout_storage_target(self, target_iqn): DCNL 'Logs out storage target through its session id.'
def snapshot(self, context, instance, name, update_task_state): DCNL 'Create snapshot from a running VM instance.'
def open(self, path, mode): DCNL 'Wrapper on __builin__.open used to simplify unit testing.'
def list_instances(self): DCNL 'Return the names of all the instances known to Hyper-V.'
def create_vm(self, vm_name, memory_mb, vcpus_num, limit_cpu_features): DCNL 'Creates a VM.'
def attach_ide_drive(self, vm_name, path, ctrller_addr, drive_addr, drive_type=constants.IDE_DISK): DCNL 'Create an IDE drive and attach it to the vm.'
def create_scsi_controller(self, vm_name): DCNL 'Create an iscsi controller ready to mount volumes.'
def attach_volume_to_controller(self, vm_name, controller_path, address, mounted_disk_path): DCNL 'Attach a volume to a controller.'
def create_nic(self, vm_name, nic_name, mac_address): DCNL 'Create a (synthetic) nic and attach it to the vm.'
def set_vm_state(self, vm_name, req_state): DCNL 'Set the desired state of the VM.'
def _wait_for_job(self, job_path): DCNL 'Poll WMI job state and wait for completion.'
def _clone_wmi_obj(self, wmi_class, wmi_obj): DCNL 'Clone a WMI object.'
def _add_virt_resource(self, res_setting_data, vm_path): DCNL 'Adds a new resource to the VM.'
def _modify_virt_resource(self, res_setting_data, vm_path): DCNL 'Updates a VM resource.'
def _remove_virt_resource(self, res_setting_data, vm_path): DCNL 'Removes a VM resource.'
def attach_volume(self, connection_info, instance_name, ebs_root=False): DCNL 'Attach a volume to the SCSI controller or to the IDE controller if DCNL ebs_root is True'
def detach_volume(self, connection_info, instance_name): DCNL 'Dettach a volume to the SCSI controller.'
def get_iscsi_initiator(self): DCNL 'Get iscsi initiator name for this machine.'
def login_storage_target(self, target_lun, target_iqn, target_portal): DCNL 'Add target portal, list targets and logins to the target.'
def logout_storage_target(self, target_iqn): DCNL 'Logs out storage target through its session id.'
def execute_log_out(self, session_id): DCNL 'Executes log out of the session described by its session ID.'
def list_instances(self): DCNL 'List VM instances.'
def list_instance_uuids(self): DCNL 'Get the list of nova instance uuids for VMs found on the DCNL hypervisor.'
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info=None, block_device_info=None): DCNL 'Create VM instance.'
def confirm_migration(self, migration, instance, network_info): DCNL 'Confirms a resize, destroying the source VM.'
def finish_revert_migration(self, instance, network_info, block_device_info=None): DCNL 'Finish reverting a resize, powering back on the instance.'
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance=False, block_device_info=None): DCNL 'Completes a resize, turning on the migrated instance.'
def snapshot(self, context, instance, image_id, update_task_state): DCNL 'Create snapshot from a running VM instance.'
def reboot(self, context, instance, network_info, reboot_type, block_device_info=None, bad_volumes_callback=None): DCNL 'Reboot VM instance.'
def set_admin_password(self, instance, new_pass): DCNL 'Set the root/admin password on the VM instance.'
def inject_file(self, instance, b64_path, b64_contents): DCNL 'Create a file on the VM instance. The file path and contents DCNL should be base64-encoded.'
def change_instance_metadata(self, context, instance, diff): DCNL 'Apply a diff to the instance metadata.'
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True): DCNL 'Destroy VM instance.'
def pause(self, instance): DCNL 'Pause VM instance.'
def unpause(self, instance): DCNL 'Unpause paused VM instance.'
def migrate_disk_and_power_off(self, context, instance, dest, instance_type, network_info, block_device_info=None): DCNL 'Transfers the VHD of a running instance to another host, then shuts DCNL off the instance copies over the COW disk'
def suspend(self, instance): DCNL 'suspend the specified instance.'
def resume(self, instance, network_info, block_device_info=None): DCNL 'resume the specified instance.'
def rescue(self, context, instance, network_info, image_meta, rescue_password): DCNL 'Rescue the specified instance.'
def unrescue(self, instance, network_info): DCNL 'Unrescue the specified instance.'
def power_off(self, instance): DCNL 'Power off the specified instance.'
def power_on(self, instance): DCNL 'Power on the specified instance.'
def soft_delete(self, instance): DCNL 'Soft delete the specified instance.'
def restore(self, instance): DCNL 'Restore the specified instance.'
def poll_rebooting_instances(self, timeout, instances): DCNL 'Poll for rebooting instances.'
def reset_network(self, instance): DCNL 'reset networking for specified instance.'
def inject_network_info(self, instance, network_info): DCNL 'inject network info for specified instance.'
def plug_vifs(self, instance_ref, network_info): DCNL 'Plug VIFs into networks.'
def unplug_vifs(self, instance_ref, network_info): DCNL 'Unplug VIFs from networks.'
def get_info(self, instance): DCNL 'Return data about VM instance.'
def get_diagnostics(self, instance): DCNL 'Return data about VM diagnostics.'
def get_all_bw_counters(self, instances): DCNL 'Return bandwidth usage counters for each interface on each DCNL running VM'
def get_console_output(self, instance): DCNL 'Return snapshot of console.'
def get_vnc_console(self, instance): DCNL 'Return link to instance\'s VNC console.'
def get_volume_connector(self, instance): DCNL 'Return volume connector information.'
def attach_volume(self, connection_info, instance, mountpoint): DCNL 'Attach volume storage to VM instance.'
def detach_volume(self, connection_info, instance, mountpoint): DCNL 'Detach volume storage to VM instance.'
def get_available_resource(self, nodename): DCNL 'Retrieve resource info. DCNL This method is called when nova-compute launches, and DCNL as part of a periodic task. DCNL :param nodename: ignored in this driver DCNL :returns: dictionary describing resources'
def check_can_live_migrate_destination(self, ctxt, instance_ref, src_compute_info, dst_compute_info, block_migration=False, disk_over_commit=False): DCNL 'Check if it is possible to execute live migration. DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance object DCNL :param block_migration: if true, prepare for block migration DCNL :param disk_over_commit: if true, allow disk over commit'
def check_can_live_migrate_destination_cleanup(self, ctxt, dest_check_data): DCNL 'Do required cleanup on dest host after check_can_live_migrate calls DCNL :param ctxt: security context DCNL :param disk_over_commit: if true, allow disk over commit'
def check_can_live_migrate_source(self, ctxt, instance_ref, dest_check_data): DCNL 'Check if it is possible to execute live migration. DCNL This checks if the live migration can succeed, based on the DCNL results from check_can_live_migrate_destination. DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance DCNL :param dest_check_data: result of check_can_live_migrate_destination DCNL includes the block_migration flag'
def get_instance_disk_info(self, instance_name): DCNL 'Used by libvirt for live migration. We rely on xenapi DCNL checks to do this for us.'
def pre_block_migration(self, ctxt, instance_ref, disk_info_json): DCNL 'Used by libvirt for live migration. We rely on xenapi DCNL checks to do this for us. May be used in the future to DCNL populate the vdi/vif maps'
def live_migration(self, ctxt, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None): DCNL 'Performs the live migration of the specified instance. DCNL :params ctxt: security context DCNL :params instance_ref: DCNL nova.db.sqlalchemy.models.Instance object DCNL instance object that is migrated. DCNL :params dest: destination host DCNL :params post_method: DCNL post operation method. DCNL expected nova.compute.manager.post_live_migration. DCNL :params recover_method: DCNL recovery method when any exception occurs. DCNL expected nova.compute.manager.recover_live_migration. DCNL :params block_migration: if true, migrate VM disk. DCNL :params migrate_data: implementation specific params'
def pre_live_migration(self, context, instance_ref, block_device_info, network_info, migrate_data=None): DCNL 'Preparation live migration. DCNL :params block_device_info: DCNL It must be the result of _get_instance_volume_bdms() DCNL at compute manager.'
def post_live_migration_at_destination(self, ctxt, instance_ref, network_info, block_migration, block_device_info=None): DCNL 'Post operation of live migration at destination host. DCNL :params ctxt: security context DCNL :params instance_ref: DCNL nova.db.sqlalchemy.models.Instance object DCNL instance object that is migrated. DCNL :params network_info: instance network information DCNL :params : block_migration: if true, post operation of block_migraiton.'
def unfilter_instance(self, instance_ref, network_info): DCNL 'Removes security groups configured for an instance.'
def refresh_security_group_rules(self, security_group_id): DCNL 'Updates security group rules for all instances associated with a DCNL given security group. DCNL Invoked when security group rules are updated.'
def refresh_security_group_members(self, security_group_id): DCNL 'Updates security group rules for all instances associated with a DCNL given security group. DCNL Invoked when instances are added/removed to a security group.'
def refresh_instance_security_rules(self, instance): DCNL 'Updates security group rules for specified instance. DCNL Invoked when instances are added/removed to a security group DCNL or when a rule is added/removed to a security group.'
def get_host_stats(self, refresh=False): DCNL 'Return the current state of the host. If \'refresh\' is DCNL True, run the update first.'
def host_power_action(self, host, action): DCNL 'The only valid values for \'action\' on XenServer are \'reboot\' or DCNL \'shutdown\', even though the API also accepts \'startup\'. As this is DCNL not technically possible on XenServer, since the host is the same DCNL physical machine as the hypervisor, if this is requested, we need to DCNL raise an exception.'
def set_host_enabled(self, host, enabled): DCNL 'Sets the specified host\'s ability to accept new instances.'
def get_host_uptime(self, host): DCNL 'Returns the result of calling "uptime" on the target host.'
def host_maintenance_mode(self, host, mode): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL guest VMs evacuation.'
def add_to_aggregate(self, context, aggregate, host, **kwargs): DCNL 'Add a compute host to an aggregate.'
def remove_from_aggregate(self, context, aggregate, host, **kwargs): DCNL 'Remove a compute host from an aggregate.'
def undo_aggregate_operation(self, context, op, aggregate, host, set_error=True): DCNL 'Undo aggregate operation when pool error raised.'
def legacy_nwinfo(self): DCNL 'Indicate if the driver requires the legacy network_info format.'
def resume_state_on_host_boot(self, context, instance, network_info, block_device_info=None): DCNL 'resume guest state when a host is booted.'
def get_per_instance_usage(self): DCNL 'Get information about instance resource usage. DCNL :returns: dict of  nova uuid => dict of usage DCNL info'
def _get_product_version_and_brand(self): DCNL 'Return a tuple of (major, minor, rev) for the host version and DCNL a string of the product brand'
def get_session_id(self): DCNL 'Return a string session_id.  Used for vnc consoles.'
@contextlib.contextmanager DCNL def _get_session(self): DCNL 'Return exclusive session for scope of with statement.'
def get_xenapi_host(self): DCNL 'Return the xenapi host on which nova-compute runs on.'
def call_xenapi(self, method, *args): DCNL 'Call the specified XenAPI method on a background thread.'
def call_plugin(self, plugin, fn, args): DCNL 'Call host.call_plugin on a background thread.'
def _create_session(self, url): DCNL 'Stubout point. This can be replaced with a mock session.'
def _unwrap_plugin_exceptions(self, func, *args, **kwargs): DCNL 'Parse exception details.'
def get_all_refs_and_recs(self, record_type): DCNL 'Retrieve all refs and recs for a Xen record type. DCNL Handles race-conditions where the record may be deleted between DCNL the `get_all` call and the `get_record` call.'
def list_instances(self): DCNL 'List VM instances.'
def list_instance_uuids(self): DCNL 'Get the list of nova instance uuids for VMs found on the DCNL hypervisor.'
def _start(self, instance, vm_ref=None, bad_volumes_callback=None): DCNL 'Power on a VM instance.'
def _create_vm(self, context, instance, name_label, vdis, disk_image_type, network_info, kernel_file=None, ramdisk_file=None, rescue=False): DCNL 'Create VM instance.'
def _create_vm_record(self, context, instance, name_label, vdis, disk_image_type, kernel_file, ramdisk_file): DCNL 'Create the VM record in Xen, making sure that we do not create DCNL a duplicate name-label.  Also do a rough sanity check on memory DCNL to try to short-circuit a potential failure later.  (The memory DCNL check only accounts for running VMs, so it can miss other builds DCNL that are in progress.)'
def _boot_new_instance(self, instance, vm_ref, injected_files, admin_password): DCNL 'Boot a new instance and configure it.'
def _get_vm_opaque_ref(self, instance): DCNL 'Get xapi OpaqueRef from a db record.'
def _acquire_bootlock(self, vm): DCNL 'Prevent an instance from booting.'
def _release_bootlock(self, vm): DCNL 'Allow an instance to boot.'
def snapshot(self, context, instance, image_id, update_task_state): DCNL 'Create snapshot from a running VM instance. DCNL :param context: request context DCNL :param instance: instance to be snapshotted DCNL :param image_id: id of image to upload to DCNL Steps involved in a XenServer snapshot: DCNL 1. XAPI-Snapshot: Snapshotting the instance using XenAPI. This DCNL creates: Snapshot (Template) VM, Snapshot VBD, Snapshot VDI, DCNL Snapshot VHD DCNL 2. Wait-for-coalesce: The Snapshot VDI and Instance VDI both point to DCNL a \'base-copy\' VDI.  The base_copy is immutable and may be chained DCNL with other base_copies.  If chained, the base_copies DCNL coalesce together, so, we must wait for this coalescing to occur to DCNL get a stable representation of the data on disk. DCNL 3. Push-to-data-store: Once coalesced, we call a plugin on the DCNL XenServer that will bundle the VHDs together and then push the DCNL bundle. Depending on the configured value of DCNL \'xenapi_image_upload_handler\', image data may be pushed to DCNL Glance or the specified data store.'
def _update_instance_progress(self, context, instance, step, total_steps): DCNL 'Update instance progress percent to reflect current step number'
def migrate_disk_and_power_off(self, context, instance, dest, instance_type): DCNL 'Copies a VHD from one host machine to another, possibly DCNL resizing filesystem before hand. DCNL :param instance: the instance that owns the VHD in question. DCNL :param dest: the destination host machine. DCNL :param instance_type: instance_type to resize to'
def _resize_instance(self, instance, root_vdi): DCNL 'Resize an instances root disk.'
def check_resize_func_name(self): DCNL 'Check the function name used to resize an instance based DCNL on product_brand and product_version.'
def reboot(self, instance, reboot_type, bad_volumes_callback=None): DCNL 'Reboot VM instance.'
def set_admin_password(self, instance, new_pass): DCNL 'Set the root/admin password on the VM instance.'
def inject_file(self, instance, path, contents): DCNL 'Write a file to the VM instance.'
@staticmethod DCNL def _sanitize_xenstore_key(key): DCNL 'Xenstore only allows the following characters as keys: DCNL ABCDEFGHIJKLMNOPQRSTUVWXYZ DCNL abcdefghijklmnopqrstuvwxyz DCNL 0123456789-/_@ DCNL So convert the others to _ DCNL Also convert / to _, because that is somewhat like a path DCNL separator.'
def inject_instance_metadata(self, instance, vm_ref): DCNL 'Inject instance metadata into xenstore.'
def change_instance_metadata(self, instance, diff): DCNL 'Apply changes to instance metadata to xenstore.'
def _find_root_vdi_ref(self, vm_ref): DCNL 'Find and return the root vdi ref for a VM.'
def _destroy_vdis(self, instance, vm_ref): DCNL 'Destroys all VDIs associated with a VM.'
def _destroy_kernel_ramdisk(self, instance, vm_ref): DCNL 'Three situations can occur: DCNL 1. We have neither a ramdisk nor a kernel, in which case we are a DCNL RAW image and can omit this step DCNL 2. We have one or the other, in which case, we should flag as an DCNL error DCNL 3. We have both, in which case we safely remove both the kernel DCNL and the ramdisk.'
def _destroy_rescue_instance(self, rescue_vm_ref, original_vm_ref): DCNL 'Destroy a rescue instance.'
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True): DCNL 'Destroy VM instance. DCNL This is the method exposed by xenapi_conn.destroy(). The rest of the DCNL destroy_* methods are internal.'
def _destroy(self, instance, vm_ref, network_info=None, destroy_disks=True): DCNL 'Destroys VM instance by performing: DCNL 1. A shutdown DCNL 2. Destroying associated VDIs. DCNL 3. Destroying kernel and ramdisk files (if necessary). DCNL 4. Destroying that actual VM record.'
def pause(self, instance): DCNL 'Pause VM instance.'
def unpause(self, instance): DCNL 'Unpause VM instance.'
def suspend(self, instance): DCNL 'Suspend the specified instance.'
def resume(self, instance): DCNL 'Resume the specified instance.'
def rescue(self, context, instance, network_info, image_meta, rescue_password): DCNL 'Rescue the specified instance. DCNL - shutdown the instance VM. DCNL - set \'bootlock\' to prevent the instance from starting in rescue. DCNL - spawn a rescue VM (the vm name-label will be instance-N-rescue).'
def unrescue(self, instance): DCNL 'Unrescue the specified instance. DCNL - unplug the instance VM\'s disk from the rescue VM. DCNL - teardown the rescue VM. DCNL - release the bootlock to allow the instance VM to start.'
def soft_delete(self, instance): DCNL 'Soft delete the specified instance.'
def restore(self, instance): DCNL 'Restore the specified instance.'
def power_off(self, instance): DCNL 'Power off the specified instance.'
def power_on(self, instance): DCNL 'Power on the specified instance.'
def _cancel_stale_tasks(self, timeout, task): DCNL 'Cancel the given tasks that are older than the given timeout.'
def poll_rebooting_instances(self, timeout, instances): DCNL 'Look for expirable rebooting instances. DCNL - issue a "hard" reboot to any instance that has been stuck in a DCNL reboot state for >= the given timeout'
def get_info(self, instance, vm_ref=None): DCNL 'Return data about VM instance.'
def get_diagnostics(self, instance): DCNL 'Return data about VM diagnostics.'
def get_all_bw_counters(self): DCNL 'Return running bandwidth counter for each interface on each DCNL running VM'
def get_console_output(self, instance): DCNL 'Return snapshot of console.'
def get_vnc_console(self, instance): DCNL 'Return connection info for a vnc console.'
def _vif_xenstore_data(self, vif): DCNL 'convert a network info vif to injectable instance data.'
def inject_network_info(self, instance, network_info, vm_ref=None): DCNL 'Generate the network info and make calls to place it into the DCNL xenstore and the xenstore param list. DCNL vm_ref can be passed in because it will sometimes be different than DCNL what vm_utils.lookup(session, instance[\'name\']) will find (ex: rescue)'
def _create_vifs(self, vm_ref, instance, network_info): DCNL 'Creates vifs for an instance.'
def plug_vifs(self, instance, network_info): DCNL 'Set up VIF networking on the host.'
def reset_network(self, instance): DCNL 'Calls resetnetwork method in agent.'
def inject_hostname(self, instance, vm_ref, hostname): DCNL 'Inject the hostname of the instance into the xenstore.'
def _write_to_xenstore(self, instance, path, value, vm_ref=None): DCNL 'Writes the passed value to the xenstore record for the given VM DCNL at the specified location. A XenAPIPlugin.PluginError will be raised DCNL if any error is encountered in the write process.'
def _delete_from_xenstore(self, instance, path, vm_ref=None): DCNL 'Deletes the value from the xenstore record for the given VM at DCNL the specified location.  A XenAPIPlugin.PluginError will be DCNL raised if any error is encountered in the delete process.'
def _make_plugin_call(self, plugin, method, instance, vm_ref=None, **addl_args): DCNL 'Abstracts out the process of calling a method of a xenapi plugin. DCNL Any errors raised by the plugin will in turn raise a RuntimeError here.'
def _add_to_param_xenstore(self, vm_ref, key, val): DCNL 'Takes a key/value pair and adds it to the xenstore parameter DCNL record for the given vm instance. If the key exists in xenstore, DCNL it is overwritten'
def _remove_from_param_xenstore(self, vm_ref, key): DCNL 'Takes a single key and removes it from the xenstore parameter DCNL record data for the given VM. DCNL If the key doesn\'t exist, the request is ignored.'
def refresh_security_group_rules(self, security_group_id): DCNL 'recreates security group rules for every instance.'
def refresh_security_group_members(self, security_group_id): DCNL 'recreates security group rules for every instance.'
def refresh_instance_security_rules(self, instance): DCNL 'recreates security group rules for specified instance.'
def unfilter_instance(self, instance_ref, network_info): DCNL 'Removes filters for each VIF of the specified instance.'
def check_can_live_migrate_destination(self, ctxt, instance_ref, block_migration=False, disk_over_commit=False): DCNL 'Check if it is possible to execute live migration. DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance object DCNL :param block_migration: if true, prepare for block migration DCNL :param disk_over_commit: if true, allow disk over commit'
def check_can_live_migrate_source(self, ctxt, instance_ref, dest_check_data): DCNL 'Check if it\'s possible to execute live migration on the source side. DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance object DCNL :param dest_check_data: data returned by the check on the DCNL destination, includes block_migration flag'
def _generate_vdi_map(self, destination_sr_ref, vm_ref): DCNL 'generate a vdi_map for _call_live_migrate_command.'
def _call_live_migrate_command(self, command_name, vm_ref, migrate_data): DCNL 'unpack xapi specific parameters, and call a live migrate command.'
def get_per_instance_usage(self): DCNL 'Get usage info about each active instance.'
def upload_image(self, context, session, instance, vdi_uuids, image_id): DCNL 'Requests that the Glance plugin bundle the specified VDIs and DCNL push them into Glance using the specified human-friendly name.'
@classmethod DCNL def get_role(cls, image_type_id): DCNL 'Get the role played by the image, based on its type.'
def get_agent_version(self): DCNL 'Get the version of the agent running on the VM instance.'
def agent_update(self, agent_build): DCNL 'Update agent on the VM instance.'
def set_admin_password(self, new_pass): DCNL 'Set the root/admin password on the VM instance. DCNL This is done via an agent running on the VM. Communication between nova DCNL and the agent is done via writing xenstore records. Since communication DCNL is done over the XenAPI RPC calls, we need to encrypt the password. DCNL We\'re using a simple Diffie-Hellman class instead of a more advanced DCNL library (such as M2Crypto) for compatibility with the agent code.'
@staticmethod DCNL def mod_exp(num, exp, mod): DCNL 'Efficient implementation of (num ** exp) % mod.'
def _ensure_vlan_bridge(self, network): DCNL 'Ensure that a VLAN bridge exists.'
def undo_aggregate_operation(self, context, op, aggregate, host, set_error): DCNL 'Undo aggregate operation when pool error raised.'
def add_to_aggregate(self, context, aggregate, host, slave_info=None): DCNL 'Add a compute host to an aggregate.'
def remove_from_aggregate(self, context, aggregate, host, slave_info=None): DCNL 'Remove a compute host from an aggregate.'
def _join_slave(self, aggregate_id, host, compute_uuid, url, user, passwd): DCNL 'Joins a slave into a XenServer resource pool.'
def _eject_slave(self, aggregate_id, compute_uuid, host_uuid): DCNL 'Eject a slave from a XenServer resource pool.'
def _init_pool(self, aggregate_id, aggregate_name): DCNL 'Set the name label of a XenServer pool.'
def _clear_pool(self, aggregate_id): DCNL 'Clear the name label of a XenServer pool.'
def _create_slave_info(self): DCNL 'XenServer specific info needed to join the hypervisor pool.'
def host_power_action(self, _host, action): DCNL 'Reboots or shuts down the host.'
def host_maintenance_mode(self, host, mode): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL guest VMs evacuation.'
def set_host_enabled(self, _host, enabled): DCNL 'Sets the specified host\'s ability to accept new instances.'
def get_host_uptime(self, _host): DCNL 'Returns the result of calling "uptime" on the target host.'
def get_host_stats(self, refresh=False): DCNL 'Return the current state of the host. If \'refresh\' is DCNL True, run the update first.'
def update_status(self): DCNL 'Since under Xenserver, a compute node runs on a given host, DCNL we can get host status information using xenapi.'
def _provider_rules(self): DCNL 'Generate a list of rules from provider for IP4 & IP6. DCNL Note: We could not use the common code from virt.firewall because DCNL XS doesn\'t accept the \'-m multiport\' option'
def attach_volume(self, connection_info, instance_name, mountpoint, hotplug=True): DCNL 'Attach volume storage to VM instance.'
def detach_volume(self, connection_info, instance_name, mountpoint): DCNL 'Detach volume storage to VM instance.'
def _get_all_volume_vbd_refs(self, vm_ref): DCNL 'Return VBD refs for all Nova/Cinder volumes.'
def detach_all(self, vm_ref): DCNL 'Detach any external nova/cinder volumes and purge the SRs.'
def find_bad_volumes(self, vm_ref): DCNL 'Find any volumes with their connection severed. DCNL Certain VM operations (e.g. `VM.start`, `VM.reboot`, etc.) will not DCNL work when a VBD is present that points to a non-working volume. To work DCNL around this, we scan for non-working volumes and detach them before DCNL retrying a failed operation.'
def plug_vifs(self, instance, network_info): DCNL 'Plug VIFs into networks.'
def unplug_vifs(self, instance, network_info): DCNL 'Unplug VIFs from networks.'
def attach_volume(self, connection_info, instance, mountpoint): DCNL 'Attach the disk to the instance at mountpoint using info.'
def detach_volume(self, connection_info, instance, mountpoint): DCNL 'Detach the disk attached to the instance.'
def get_all_bw_counters(self, instances): DCNL 'Return bandwidth usage counters for each interface on each DCNL running VM'
def get_all_volume_usage(self, context, instances, start_time, stop_time=None): DCNL 'Return usage info for volumes attached to vms on DCNL a given host'
def get_available_resource(self, nodename): DCNL 'Updates compute manager resource info on ComputeNode table. DCNL Since we don\'t have a real hypervisor, pretend we have lots of DCNL disk and ram.'
def ensure_filtering_rules_for_instance(self, instance_ref, network_info): DCNL 'This method is supported only by libvirt.'
def unfilter_instance(self, instance_ref, network_info): DCNL 'This method is supported only by libvirt.'
def test_remove_vm(self, instance_name): DCNL 'Removes the named VM, as if it crashed. For testing.'
def get_host_stats(self, refresh=False): DCNL 'Return fake Host Status of ram, disk, network.'
def host_power_action(self, host, action): DCNL 'Reboots, shuts down or powers up the host.'
def host_maintenance_mode(self, host, mode): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL guest VMs evacuation.'
def set_host_enabled(self, host, enabled): DCNL 'Sets the specified host\'s ability to accept new instances.'
def _filter_hosts(self, request_spec, hosts, filter_properties): DCNL 'Filter a list of hosts based on request_spec.'
def _schedule(self, context, topic, request_spec, filter_properties): DCNL 'Picks a host that is up at random.'
def select_hosts(self, context, request_spec, filter_properties): DCNL 'Selects a set of random hosts.'
def schedule_run_instance(self, context, request_spec, admin_password, injected_files, requested_networks, is_first_time, filter_properties): DCNL 'Create and run an instance or instances.'
def schedule_prep_resize(self, context, image, request_spec, filter_properties, instance, instance_type, reservations): DCNL 'Select a target for resize.'
def update_service_capabilities(self, service_name, host, capabilities): DCNL 'Process a capability update from a service node.'
def hosts_up(self, context, topic): DCNL 'Return the list of hosts that have a running service for topic.'
def group_hosts(self, context, group): DCNL 'Return the list of hosts that have VM\'s from the group.'
def schedule_prep_resize(self, context, image, request_spec, filter_properties, instance, instance_type, reservations): DCNL 'Must override schedule_prep_resize method for scheduler to work.'
def schedule_run_instance(self, context, request_spec, admin_password, injected_files, requested_networks, is_first_time, filter_properties): DCNL 'Must override schedule_run_instance method for scheduler to work.'
def select_hosts(self, context, request_spec, filter_properties): DCNL 'Must override select_hosts method for scheduler to work.'
def schedule_live_migration(self, context, instance, dest, block_migration, disk_over_commit): DCNL 'Live migration scheduling method. DCNL :param context: DCNL :param instance: instance dict DCNL :param dest: destination host DCNL :param block_migration: if true, block_migration. DCNL :param disk_over_commit: if True, consider real(not virtual) DCNL disk size. DCNL :return: DCNL The host where instance is running currently. DCNL Then scheduler send request that host.'
def _live_migration_src_check(self, context, instance_ref): DCNL 'Live migration check routine (for src host). DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance object'
def _live_migration_dest_check(self, context, instance_ref, dest, ignore_hosts=None): DCNL 'Live migration check routine (for destination host). DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance object DCNL :param dest: destination host DCNL :param ignore_hosts: hosts that should be avoided as dest host'
def _live_migration_common_check(self, context, instance_ref, dest): DCNL 'Live migration common check routine. DCNL The following checks are based on DCNL http://wiki.libvirt.org/page/TodoPreMigrationChecks DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance object DCNL :param dest: destination host'
def _assert_compute_node_has_enough_memory(self, context, instance_ref, dest): DCNL 'Checks if destination host has enough memory for live migration. DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance object DCNL :param dest: destination host'
def _get_compute_info(self, context, host): DCNL 'get compute node\'s information specified by key DCNL :param context: security context DCNL :param host: hostname(must be compute node) DCNL :param key: column name of compute_nodes DCNL :return: value specified by key'
def update_from_compute_node(self, compute): DCNL 'Update information about a host from its compute_node info.'
def consume_from_instance(self, instance): DCNL 'Incrementally update host state from an instance.'
def _choose_host_filters(self, filter_cls_names): DCNL 'Since the caller may specify which filters to use we need DCNL to have an authoritative list of what is permissible. This DCNL function checks the filter names against a predefined set DCNL of acceptable filters.'
def get_filtered_hosts(self, hosts, filter_properties, filter_class_names=None): DCNL 'Filter hosts and return only ones passing all filters.'
def get_weighed_hosts(self, hosts, weight_properties): DCNL 'Weigh the hosts.'
def update_service_capabilities(self, service_name, host, capabilities): DCNL 'Update the per-service capabilities based on this notification.'
def get_all_host_states(self, context): DCNL 'Returns a list of HostStates that represents all the hosts DCNL the HostManager knows about. Also, each of the consumable resources DCNL in HostState are pre-populated and adjusted based on data in the db.'
def post_start_hook(self): DCNL 'After we start up and can receive messages via RPC, tell all DCNL compute nodes to send us their capabilities.'
def update_service_capabilities(self, context, service_name, host, capabilities): DCNL 'Process a capability update from a service node.'
def run_instance(self, context, request_spec, admin_password, injected_files, requested_networks, is_first_time, filter_properties): DCNL 'Tries to call schedule_run_instance on the driver. DCNL Sets instance vm_state to ERROR on exceptions'
def prep_resize(self, context, image, request_spec, filter_properties, instance, instance_type, reservations): DCNL 'Tries to call schedule_prep_resize on the driver. DCNL Sets instance vm_state to ACTIVE on NoHostFound DCNL Sets vm_state to ERROR on other exceptions'
def _set_vm_state_and_notify(self, method, updates, context, ex, request_spec): DCNL 'changes VM state and notifies.'
def show_host_resources(self, context, host): DCNL 'Shows the physical/usage resource given by hosts. DCNL :param context: security context DCNL :param host: hostname DCNL :returns: DCNL example format is below:: DCNL {\'resource\':D, \'usage\':{proj_id1:D, proj_id2:D}} DCNL D: {\'vcpus\': 3, \'memory_mb\': 2048, \'local_gb\': 2048, DCNL \'vcpus_used\': 12, \'memory_mb_used\': 10240, DCNL \'local_gb_used\': 64}'
def select_hosts(self, context, request_spec, filter_properties): DCNL 'Returns host(s) best suited for this request_spec and DCNL filter_properties'
def update_from_compute_node(self, compute): DCNL 'Update information about a host from its compute_node info.'
def schedule_run_instance(self, context, request_spec, admin_password, injected_files, requested_networks, is_first_time, filter_properties): DCNL 'This method is called from nova.compute.api to provision DCNL an instance.  We first create a build plan (a list of WeightedHosts) DCNL and then provision. DCNL Returns a list of the instances created.'
def schedule_prep_resize(self, context, image, request_spec, filter_properties, instance, instance_type, reservations): DCNL 'Select a target for resize. DCNL Selects a target host for the instance, post-resize, and casts DCNL the prep_resize operation to it.'
def select_hosts(self, context, request_spec, filter_properties): DCNL 'Selects a filtered set of hosts.'
def _provision_resource(self, context, weighed_host, request_spec, filter_properties, requested_networks, injected_files, admin_password, is_first_time, instance_uuid=None): DCNL 'Create the requested resource in this Zone.'
def _post_select_populate_filter_properties(self, filter_properties, host_state): DCNL 'Add additional information to the filter properties after a node has DCNL been selected by the scheduling process.'
def _add_retry_host(self, filter_properties, host, node): DCNL 'Add a retry entry for the selected compute node. In the event that DCNL the request gets re-scheduled, this entry will signal that the given DCNL node has already been tried.'
def _get_configuration_options(self): DCNL 'Fetch options dictionary. Broken out for testing.'
def populate_filter_properties(self, request_spec, filter_properties): DCNL 'Stuff things into filter_properties.  Can be overridden in a DCNL subclass to add more data.'
def _log_compute_error(self, instance_uuid, retry): DCNL 'If the request contained an exception from a previous compute DCNL build/resize operation, log it to aid debugging'
def _populate_retry(self, filter_properties, instance_properties): DCNL 'Populate filter properties with history of retries for this DCNL request. If maximum retries is exceeded, raise NoValidHost.'
def _schedule(self, context, request_spec, filter_properties, instance_uuids=None): DCNL 'Returns a list of hosts that meet the required specs, DCNL ordered by their fitness.'
def _assert_compute_node_has_enough_memory(self, context, instance_ref, dest): DCNL 'Checks if destination host has enough memory for live migration. DCNL :param context: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance object DCNL :param dest: destination host'
def _get_file_handle(self, filename): DCNL 'Get file handle. Broken out for testing.'
def _get_file_timestamp(self, filename): DCNL 'Get the last modified datetime. Broken out for testing.'
def _load_file(self, handle): DCNL 'Decode the JSON file. Broken out for testing.'
def _get_time_now(self): DCNL 'Get current UTC. Broken out for testing.'
def get_configuration(self, filename=None): DCNL 'Check the json file for changes and load it if needed.'
def _weight_multiplier(self): DCNL 'Override the weight multiplier.'
def _weigh_object(self, host_state, weight_properties): DCNL 'Higher weights win.  We want spreading to be the default.'
def host_passes(self, host_state, filter_properties): DCNL 'Check if host passes specified image properties. DCNL Returns True for compute nodes that satisfy image properties DCNL contained in the request_spec.'
def host_passes(self, host_state, filter_properties): DCNL 'Use information about current vm and task states collected from DCNL compute node statistics to decide whether to filter.'
def host_passes(self, host_state, filter_properties): DCNL 'Return True if host has sufficient CPU cores.'
def _filter_one(self, obj, filter_properties): DCNL 'Return True if the object passes the filter, otherwise False.'
def host_passes(self, host_state, filter_properties): DCNL 'Return True if the HostState passes the filter, otherwise False. DCNL Override this in a subclass.'
def host_passes(self, host_state, filter_properties): DCNL 'Only return hosts with sufficient available RAM.'
def host_passes(self, host_state, filter_properties): DCNL 'Returns True for only active compute nodes.'
def _satisfies_extra_specs(self, capabilities, instance_type): DCNL 'Check that the capabilities provided by the compute service DCNL satisfy the extra specs associated with the instance type'
def host_passes(self, host_state, filter_properties): DCNL 'Return a list of hosts that can create instance_type.'
def host_passes(self, host_state, filter_properties): DCNL 'Filter based on disk usage.'
def host_passes(self, host_state, filter_properties): DCNL 'Return a list of hosts that can create instance_type DCNL Check that the extra specs associated with the instance type match DCNL the metadata provided by aggregates.  If not present return False.'
def host_passes(self, host_state, filter_properties): DCNL 'Dynamically limits hosts to one instance type DCNL Return False if host has any instance types other then the requested DCNL type. Return True if all instance types match or if host is empty.'
def connect(self): DCNL 'Connect to a host on a given (SSL) port. DCNL If ca_file is pointing somewhere, use it to check Server Certificate. DCNL Redefined/copied and extended from httplib.py:1105 (Python 2.6.x). DCNL This is needed to pass cert_reqs=ssl.CERT_REQUIRED as parameter to DCNL ssl.wrap_socket(), which forces SSL to check server certificate DCNL against our client certificate.'
def do_attestation(self, hosts): DCNL 'Attests compute nodes through OAT service. DCNL :param hosts: hosts list to be attested DCNL :returns: dictionary for trust level and validate time'
def get_host_attestation(self, host): DCNL 'Check host\'s trust level.'
def host_passes(self, host_state, filter_properties): DCNL 'Skip nodes that have already been attempted.'
def _op_compare(self, args, op): DCNL 'Returns True if the specified operator can successfully DCNL compare the first item in the args with all the rest. Will DCNL return False if only one item is in the list.'
def _equals(self, args): DCNL 'First term is == all the other terms.'
def _less_than(self, args): DCNL 'First term is < all the other terms.'
def _greater_than(self, args): DCNL 'First term is > all the other terms.'
def _in(self, args): DCNL 'First term is in set of remaining terms.'
def _less_than_equal(self, args): DCNL 'First term is <= all the other terms.'
def _greater_than_equal(self, args): DCNL 'First term is >= all the other terms.'
def _not(self, args): DCNL 'Flip each of the arguments.'
def _or(self, args): DCNL 'True if any arg is True.'
def _and(self, args): DCNL 'True if all args are True.'
def _parse_string(self, string, host_state): DCNL 'Strings prefixed with $ are capability lookups in the DCNL form \'$variable\' where \'variable\' is an attribute in the DCNL HostState class.  If $variable is a dictionary, you may DCNL use: $variable.dictkey'
def _process_filter(self, query, host_state): DCNL 'Recursively parse the query structure.'
def host_passes(self, host_state, filter_properties): DCNL 'Return a list of hosts that can fulfill the requirements DCNL specified in the query.'
def host_passes(self, host_state, filter_properties): DCNL 'If a host is in an aggregate that has the metadata key DCNL "filter_tenant_id" it can only create instances from that tenant(s). DCNL A host can be in different aggregates. DCNL If a host doesn\'t belong to an aggregate with the metadata key DCNL "filter_tenant_id" it can create instances from all tenants.'
def _weight_multiplier(self): DCNL 'How weighted this weigher should be.  Normally this would DCNL be overriden in a subclass based on a config value.'
def _weigh_object(self, obj, weight_properties): DCNL 'Override in a subclass to specify a weight for a specific DCNL object.'
def weigh_objects(self, weighed_obj_list, weight_properties): DCNL 'Weigh multiple objects.  Override in a subclass if you need DCNL need access to all objects in order to manipulate weights.'
def get_weighed_objects(self, weigher_classes, obj_list, weighing_properties): DCNL 'Return a sorted (highest score first) list of WeighedObjects.'
def __init__(self, user_id, project_id, is_admin=None, read_deleted='no', roles=None, remote_address=None, timestamp=None, request_id=None, auth_token=None, overwrite=True, quota_class=None, user_name=None, project_name=None, service_catalog=None, instance_lock_checked=False, **kwargs): DCNL ':param read_deleted: \'no\' indicates deleted records are hidden, \'yes\' DCNL indicates deleted records are visible, \'only\' indicates that DCNL *only* deleted records are visible. DCNL :param overwrite: Set to False to ensure that the greenthread local DCNL copy of the index is not overwritten. DCNL :param kwargs: Extra arguments that might be present, but we ignore DCNL because they possibly came in from older rpc messages.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
def _reraise_translated_volume_exception(self, volume_id=None): DCNL 'Transform the exception for the volume but keep its traceback DCNL intact.'
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def instance_claim(self, context, instance_ref, limits=None): DCNL 'Indicate that some resources are needed for an upcoming compute DCNL instance build operation. DCNL This should be called before the compute node is about to perform DCNL an instance build operation that will consume additional resources. DCNL :param context: security context DCNL :param instance_ref: instance to reserve resources for DCNL :param limits: Dict of oversubscription limits for memory, disk, DCNL and CPUs. DCNL :returns: A Claim ticket representing the reserved resources.  It can DCNL be used to revert the resource usage if an error occurs DCNL during the instance build.'
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def resize_claim(self, context, instance_ref, instance_type, limits=None): DCNL 'Indicate that resources are needed for a resize operation to this DCNL compute host. DCNL :param context: security context DCNL :param instance_ref: instance to reserve resources for DCNL :param instance_type: new instance_type being resized to DCNL :param limits: Dict of oversubscription limits for memory, disk, DCNL and CPUs. DCNL :returns: A Claim ticket representing the reserved resources.  This DCNL should be turned into finalize  a resource claim or free DCNL resources after the compute operation is finished.'
def _create_migration(self, context, instance, instance_type): DCNL 'Create a migration record for the upcoming resize.  This should DCNL be done while the COMPUTE_RESOURCES_SEMAPHORE is held so the resource DCNL claim will not be lost if the audit process starts.'
def _set_instance_host_and_node(self, context, instance_ref): DCNL 'Tag the instance as belonging to this host.  This should be done DCNL while the COMPUTE_RESOURCES_SEMPAHORE is held so the resource claim DCNL will not be lost if the audit process starts.'
def abort_instance_claim(self, instance): DCNL 'Remove usage from the given instance.'
def abort_resize_claim(self, instance_uuid, instance_type): DCNL 'Remove usage for an incoming migration.'
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def update_usage(self, context, instance): DCNL 'Update the resource usage and stats after a change in an DCNL instance'
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def update_available_resource(self, context): DCNL 'Override in-memory calculations of compute node resource usage based DCNL on data audited from the hypervisor layer. DCNL Add in resource claims in progress to account for operations that have DCNL declared a need for resources, but not necessarily retrieved them from DCNL the hypervisor layer yet.'
def _sync_compute_node(self, context, resources): DCNL 'Create or update the compute node DB record.'
def _create(self, context, values): DCNL 'Create the compute node in the DB.'
def _report_hypervisor_resource_view(self, resources): DCNL 'Log the hypervisor\'s view of free memory in and free disk. DCNL This is just a snapshot of resource usage recorded by the DCNL virt driver.'
def _report_final_resource_view(self, resources): DCNL 'Report final calculate of free memory and free disk including DCNL instance calculations and in-progress resource claims.  These DCNL values will be exposed via the compute node table to the scheduler.'
def _update(self, context, values, prune_stats=False): DCNL 'Persist the compute node updates to the DB.'
def confirm_resize(self, context, migration, status='confirmed'): DCNL 'Cleanup usage for a confirmed resize.'
def revert_resize(self, context, migration, status='reverted'): DCNL 'Cleanup usage for a reverted resize.'
def _update_usage_from_migration(self, context, instance, resources, migration): DCNL 'Update usage for a single migration.  The record may DCNL represent an incoming or outbound migration.'
def _update_usage_from_instance(self, resources, instance): DCNL 'Update usage for a single instance.'
def _update_usage_from_instances(self, resources, instances): DCNL 'Calculate resource usage based on instance utilization.  This is DCNL different than the hypervisor\'s view as it will account for all DCNL instances assigned to the local compute host, even if they are not DCNL currently powered on.'
def _find_orphaned_instances(self): DCNL 'Given the set of instances and migrations already account for DCNL by resource tracker, sanity check the hypervisor to determine DCNL if there are any "orphaned" instances left hanging around. DCNL Orphans could be consuming memory and should be accounted for in DCNL usage calculations to guard against potential out of memory DCNL errors.'
def _update_usage_from_orphans(self, resources, orphans): DCNL 'Include orphaned instances in usage.'
def _get_instance_type(self, context, instance, prefix, instance_type_id=None): DCNL 'Get the instance type from sys metadata if it\'s stashed.  If not, DCNL fall back to fetching it via the conductor API. DCNL See bug 1164110'
def __init__(self, compute_driver=None, *args, **kwargs): DCNL 'Load configuration options and connect to the hypervisor.'
def _instance_update(self, context, instance_uuid, **kwargs): DCNL 'Update an instance in the database using kwargs as value.'
def _get_instances_on_driver(self, context): DCNL 'Return a list of instance records that match the instances found DCNL on the hypervisor.'
def _destroy_evacuated_instances(self, context): DCNL 'Destroys evacuated instances. DCNL While nova-compute was down, the instances running on it could be DCNL evacuated to another host. Check that the instances reported DCNL by the driver are still associated with this host.  If they are DCNL not, destroy them.'
def _init_instance(self, context, instance): DCNL 'Initialize this instance during service init.'
def init_host(self): DCNL 'Initialization for a standalone compute service.'
def pre_start_hook(self, **kwargs): DCNL 'After the service is initialized, but before we fully bring DCNL the service up by listening on RPC queues, make sure to update DCNL our available resources.'
def _get_power_state(self, context, instance): DCNL 'Retrieve the power state for the given instance.'
def get_backdoor_port(self, context): DCNL 'Return backdoor port for eventlet_backdoor.'
def get_console_topic(self, context): DCNL 'Retrieves the console host for a project on this host. DCNL Currently this is just set in the flags for each compute host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def refresh_security_group_rules(self, context, security_group_id): DCNL 'Tell the virtualization driver to refresh security group rules. DCNL Passes straight through to the virtualization driver.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def refresh_security_group_members(self, context, security_group_id): DCNL 'Tell the virtualization driver to refresh security group members. DCNL Passes straight through to the virtualization driver.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def refresh_instance_security_rules(self, context, instance): DCNL 'Tell the virtualization driver to refresh security rules for DCNL an instance. DCNL Passes straight through to the virtualization driver. DCNL Synchronise the call beacuse we may still be in the middle of DCNL creating the instance.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def refresh_provider_fw_rules(self, context): DCNL 'This call passes straight through to the virtualization driver.'
def _get_instance_nw_info(self, context, instance): DCNL 'Get a list of dictionaries of network data of an instance.'
def _legacy_nw_info(self, network_info): DCNL 'Converts the model nw_info object to legacy style.'
def _setup_block_device_mapping(self, context, instance, bdms): DCNL 'setup volumes for block device mapping.'
def _decode_files(self, injected_files): DCNL 'Base64 decode the list of files to inject.'
def _run_instance(self, context, request_spec, filter_properties, requested_networks, injected_files, admin_password, is_first_time, node, instance): DCNL 'Launch a new instance with specified options.'
def _reschedule_or_reraise(self, context, instance, exc_info, requested_networks, admin_password, injected_files, is_first_time, request_spec, filter_properties, bdms=None): DCNL 'Try to re-schedule the build or re-raise the original build error to DCNL error out the instance.'
def _reschedule(self, context, request_spec, filter_properties, instance_uuid, scheduler_method, method_args, task_state, exc_info=None): DCNL 'Attempt to re-schedule a compute operation.'
@manager.periodic_task DCNL def _check_instance_build_time(self, context): DCNL 'Ensure that instances are not stuck in build.'
def _check_instance_exists(self, context, instance): DCNL 'Ensure an instance with the same name is not already present.'
def _check_image_size(self, context, instance): DCNL 'Ensure image is smaller than the maximum size allowed by the DCNL instance_type. DCNL The image stored in Glance is potentially compressed, so we use two DCNL checks to ensure that the size isn\'t exceeded: DCNL 1) This one - checks compressed size, this a quick check to DCNL eliminate any images which are obviously too large DCNL 2) Check uncompressed size in nova.virt.xenapi.vm_utils. This DCNL is a slower check since it requires uncompressing the entire DCNL image, but is accurate because it reflects the image\'s DCNL actual size.'
def _start_building(self, context, instance): DCNL 'Save the host and launched_on fields and log appropriately.'
def _allocate_network(self, context, instance, requested_networks, macs, security_groups): DCNL 'Allocate networks for an instance and return the network info.'
def _prep_block_device(self, context, instance, bdms): DCNL 'Set up the block device for an instance with error logging.'
def _spawn(self, context, instance, image_meta, network_info, block_device_info, injected_files, admin_password, set_access_ip=False): DCNL 'Spawn an instance with error logging and update its power state.'
def _get_volume_bdms(self, bdms): DCNL 'Return only bdms that have a volume_id.'
def _shutdown_instance(self, context, instance, bdms): DCNL 'Shutdown an instance on this host.'
@hooks.add_hook('delete_instance') DCNL def _delete_instance(self, context, instance, bdms, reservations=None): DCNL 'Delete an instance on this host.  Commit or rollback quotas DCNL as necessary.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def terminate_instance(self, context, instance, bdms=None, reservations=None): DCNL 'Terminate an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def stop_instance(self, context, instance): DCNL 'Stopping an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def start_instance(self, context, instance): DCNL 'Starting an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def soft_delete_instance(self, context, instance, reservations=None): DCNL 'Soft delete an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def restore_instance(self, context, instance): DCNL 'Restore a soft-deleted instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def power_off_instance(self, context, instance): DCNL 'Power off an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def power_on_instance(self, context, instance): DCNL 'Power on an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def rebuild_instance(self, context, instance, orig_image_ref, image_ref, injected_files, new_pass, orig_sys_metadata=None, bdms=None, recreate=False, on_shared_storage=False): DCNL 'Destroy and re-make this instance. DCNL A \'rebuild\' effectively purges all existing data from the system and DCNL remakes the VM with given \'metadata\' and \'personalities\'. DCNL :param context: `nova.RequestContext` object DCNL :param instance: Instance dict DCNL :param orig_image_ref: Original image_ref before rebuild DCNL :param image_ref: New image_ref for rebuild DCNL :param injected_files: Files to inject DCNL :param new_pass: password to set on rebuilt instance DCNL :param orig_sys_metadata: instance system metadata from pre-rebuild DCNL :param bdms: block-device-mappings to use for rebuild DCNL :param recreate: True if instance should be recreated with same disk DCNL :param on_shared_storage: True if instance files on shared storage'
def _handle_bad_volumes_detached(self, context, instance, bad_devices, block_device_info): DCNL 'Handle cases where the virt-layer had to detach non-working volumes DCNL in order to complete an operation.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def reboot_instance(self, context, instance, block_device_info=None, network_info=None, reboot_type='SOFT'): DCNL 'Reboot an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def snapshot_instance(self, context, image_id, instance, image_type='snapshot', backup_type=None, rotation=None): DCNL 'Snapshot an instance on this host. DCNL :param context: security context DCNL :param instance: an Instance dict DCNL :param image_id: glance.db.sqlalchemy.models.Image.Id DCNL :param image_type: snapshot | backup DCNL :param backup_type: daily | weekly DCNL :param rotation: int representing how many backups to keep around; DCNL None if rotation shouldn\'t be used (as in the case of snapshots)'
@wrap_instance_fault DCNL def _rotate_backups(self, context, instance, backup_type, rotation): DCNL 'Delete excess backups associated to an instance. DCNL Instances are allowed a fixed number of backups (the rotation number); DCNL this method deletes the oldest backups that exceed the rotation DCNL threshold. DCNL :param context: security context DCNL :param instance: Instance dict DCNL :param backup_type: daily | weekly DCNL :param rotation: int representing how many backups to keep around; DCNL None if rotation shouldn\'t be used (as in the case of snapshots)'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def set_admin_password(self, context, instance, new_pass=None): DCNL 'Set the root/admin password for an instance on this host. DCNL This is generally only called by API password resets after an DCNL image has been built.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def inject_file(self, context, path, file_contents, instance): DCNL 'Write a file to the specified path in an instance on this host.'
def _get_rescue_image_ref(self, context, instance): DCNL 'Determine what image should be used to boot the rescue VM.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def rescue_instance(self, context, instance, rescue_password=None): DCNL 'Rescue an instance on this host. DCNL :param rescue_password: password to set on rescue instance'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def unrescue_instance(self, context, instance): DCNL 'Rescue an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def change_instance_metadata(self, context, diff, instance): DCNL 'Update the metadata published to the instance.'
def _cleanup_stored_instance_types(self, migration, instance, restore_old=False): DCNL 'Clean up "old" and "new" instance_type information stored in DCNL instance\'s system_metadata. Optionally update the "current" DCNL instance_type to the saved old one first. DCNL Returns the updated system_metadata as a dict, as well as the DCNL post-cleanup current instance type.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def confirm_resize(self, context, instance, reservations=None, migration=None, migration_id=None): DCNL 'Destroys the source instance.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def revert_resize(self, context, instance, migration=None, migration_id=None, reservations=None): DCNL 'Destroys the new instance on the destination machine. DCNL Reverts the model changes, and powers on the old instance on the DCNL source machine.'
def _refresh_block_device_connection_info(self, context, instance): DCNL 'After some operations, the IQN or CHAP, for example, may have DCNL changed. This call updates the DB with the latest connection info.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def finish_revert_resize(self, context, instance, reservations=None, migration=None, migration_id=None): DCNL 'Finishes the second half of reverting a resize. DCNL Power back on the source instance and revert the resized attributes DCNL in the database.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def prep_resize(self, context, image, instance, instance_type, reservations=None, request_spec=None, filter_properties=None, node=None): DCNL 'Initiates the process of moving a running instance to another host. DCNL Possibly changes the RAM and disk size in the process.'
def _reschedule_resize_or_reraise(self, context, image, instance, exc_info, instance_type, reservations, request_spec, filter_properties): DCNL 'Try to re-schedule the resize or re-raise the original error to DCNL error out the instance.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def resize_instance(self, context, instance, image, reservations=None, migration=None, migration_id=None, instance_type=None): DCNL 'Starts the migration of a running instance to another host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def finish_resize(self, context, disk_info, image, instance, reservations=None, migration=None, migration_id=None): DCNL 'Completes the migration process. DCNL Sets up the newly transferred disk and turns on the instance at its DCNL new host machine.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def add_fixed_ip_to_instance(self, context, network_id, instance): DCNL 'Calls network_api to add new fixed_ip to instance DCNL then injects the new network info and resets instance networking.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def remove_fixed_ip_from_instance(self, context, address, instance): DCNL 'Calls network_api to remove existing fixed_ip from instance DCNL by injecting the altered network info and resetting DCNL instance networking.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def pause_instance(self, context, instance): DCNL 'Pause an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def unpause_instance(self, context, instance): DCNL 'Unpause a paused instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def host_power_action(self, context, host=None, action=None): DCNL 'Reboots, shuts down or powers up the host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def host_maintenance_mode(self, context, host, mode): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL guest VMs evacuation.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def set_host_enabled(self, context, host=None, enabled=None): DCNL 'Sets the specified host\'s ability to accept new instances.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def get_host_uptime(self, context): DCNL 'Returns the result of calling "uptime" on the target host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_fault DCNL def get_diagnostics(self, context, instance): DCNL 'Retrieve diagnostics for an instance on this host.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def suspend_instance(self, context, instance): DCNL 'Suspend the given instance.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def resume_instance(self, context, instance): DCNL 'Resume the given suspended instance.'
@reverts_task_state DCNL @wrap_instance_fault DCNL def reset_network(self, context, instance): DCNL 'Reset networking on the given instance.'
def _inject_network_info(self, context, instance): DCNL 'Inject network info for the given instance.'
@wrap_instance_fault DCNL def inject_network_info(self, context, instance): DCNL 'Inject network info, but don\'t return the info.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_fault DCNL def get_console_output(self, context, instance, tail_length=None): DCNL 'Send the console output for the given instance.'
@rpc_common.client_exceptions(exception.ConsoleTypeInvalid, exception.InstanceNotReady, exception.InstanceNotFound) DCNL @exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_fault DCNL def get_vnc_console(self, context, console_type, instance): DCNL 'Return connection information for a vnc console.'
@rpc_common.client_exceptions(exception.ConsoleTypeInvalid, exception.InstanceNotReady, exception.InstanceNotFound) DCNL @exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_fault DCNL def get_spice_console(self, context, console_type, instance): DCNL 'Return connection information for a spice console.'
def _attach_volume_boot(self, context, instance, volume, mountpoint): DCNL 'Attach a volume to an instance at boot time. So actual attach DCNL is done by instance creation'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def attach_volume(self, context, volume_id, mountpoint, instance): DCNL 'Attach a volume to an instance.'
def _detach_volume(self, context, instance, bdm): DCNL 'Do the actual driver detach using block device mapping.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def detach_volume(self, context, volume_id, instance): DCNL 'Detach a volume from an instance.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def remove_volume_connection(self, context, volume_id, instance): DCNL 'Remove a volume connection using the volume api.'
def attach_interface(self, context, instance, network_id, port_id, requested_ip=None): DCNL 'Use hotplug to add an network adapter to an instance.'
def detach_interface(self, context, instance, port_id): DCNL 'Detach an network adapter from an instance.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def check_can_live_migrate_destination(self, ctxt, instance, block_migration=False, disk_over_commit=False): DCNL 'Check if it is possible to execute live migration. DCNL This runs checks on the destination host, and then calls DCNL back to the source host to check the results. DCNL :param context: security context DCNL :param instance: dict of instance data DCNL :param block_migration: if true, prepare for block migration DCNL :param disk_over_commit: if true, allow disk over commit DCNL Returns a mapping of values required in case of block migration DCNL and None otherwise.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def check_can_live_migrate_source(self, ctxt, instance, dest_check_data): DCNL 'Check if it is possible to execute live migration. DCNL This checks if the live migration can succeed, based on the DCNL results from check_can_live_migrate_destination. DCNL :param context: security context DCNL :param instance: dict of instance data DCNL :param dest_check_data: result of check_can_live_migrate_destination DCNL Returns a dict values required for live migration without shared DCNL storage.'
def pre_live_migration(self, context, instance, block_migration=False, disk=None, migrate_data=None): DCNL 'Preparations for live migration at dest host. DCNL :param context: security context DCNL :param instance: dict of instance data DCNL :param block_migration: if true, prepare for block migration DCNL :param migrate_data : if not None, it is a dict which holds data DCNL required for live migration without shared storage.'
def live_migration(self, context, dest, instance, block_migration=False, migrate_data=None): DCNL 'Executing live migration. DCNL :param context: security context DCNL :param instance: instance dict DCNL :param dest: destination host DCNL :param block_migration: if true, prepare for block migration DCNL :param migrate_data: implementation specific params'
def _post_live_migration(self, ctxt, instance_ref, dest, block_migration=False, migrate_data=None): DCNL 'Post operations for live migration. DCNL This method is called from live_migration DCNL and mainly updating database record. DCNL :param ctxt: security context DCNL :param instance_ref: nova.db.sqlalchemy.models.Instance DCNL :param dest: destination host DCNL :param block_migration: if true, prepare for block migration DCNL :param migrate_data: if not None, it is a dict which has data DCNL required for live migration without shared storage'
def post_live_migration_at_destination(self, context, instance, block_migration=False): DCNL 'Post operations for live migration . DCNL :param context: security context DCNL :param instance: Instance dict DCNL :param block_migration: if true, prepare for block migration'
def _rollback_live_migration(self, context, instance, dest, block_migration, migrate_data=None): DCNL 'Recovers Instance/volume state from migrating -> running. DCNL :param context: security context DCNL :param instance: nova.db.sqlalchemy.models.Instance DCNL :param dest: DCNL This method is called from live migration src host. DCNL This param specifies destination host. DCNL :param block_migration: if true, prepare for block migration DCNL :param migrate_data: DCNL if not none, contains implementation specific data.'
def rollback_live_migration_at_destination(self, context, instance): DCNL 'Cleaning up image directory that is created pre_live_migration. DCNL :param context: security context DCNL :param instance: an Instance dict sent over rpc'
@manager.periodic_task DCNL def _heal_instance_info_cache(self, context): DCNL 'Called periodically.  On every call, try to update the DCNL info_cache\'s network information for another instance by DCNL calling to the network manager. DCNL This is implemented by keeping a cache of uuids of instances DCNL that live on this host.  On each call, we pop one off of a DCNL list, pull the DB record, and try the call to the network API. DCNL If anything errors, we don\'t care.  It\'s possible the instance DCNL has been deleted, etc.'
def _get_host_volume_bdms(self, context, host): DCNL 'Return all block device mappings on a compute host.'
def _update_volume_usage_cache(self, context, vol_usages, refreshed): DCNL 'Updates the volume usage cache table with a list of stats.'
def _send_volume_usage_notifications(self, context, start_time): DCNL 'Queries vol usage cache table and sends a vol usage notification.'
@manager.periodic_task(spacing=600.0, run_immediately=True) DCNL def _sync_power_states(self, context): DCNL 'Align power states between the database and the hypervisor. DCNL To sync power state data we make a DB call to get the number of DCNL virtual machines known by the hypervisor and if the number matches the DCNL number of virtual machines known by the database, we proceed in a lazy DCNL loop, one database record at a time, checking if the hypervisor has the DCNL same power state as is in the database.'
def _sync_instance_power_state(self, context, db_instance, vm_power_state): DCNL 'Align instance power state between the database and hypervisor. DCNL If the instance is not found on the hypervisor, but is in the database, DCNL then a stop() API will be called on the instance.'
@manager.periodic_task DCNL def _reclaim_queued_deletes(self, context): DCNL 'Reclaim instances that are queued for deletion.'
@manager.periodic_task DCNL def update_available_resource(self, context): DCNL 'See driver.get_available_resource() DCNL Periodic process that keeps that the compute host\'s understanding of DCNL resource availability and usage in sync with the underlying hypervisor. DCNL :param context: security context'
@manager.periodic_task(spacing=CONF.running_deleted_instance_poll_interval) DCNL def _cleanup_running_deleted_instances(self, context): DCNL 'Cleanup any instances which are erroneously still running after DCNL having been deleted. DCNL Valid actions to take are: DCNL 1. noop - do nothing DCNL 2. log - log which instances are erroneously running DCNL 3. reap - shutdown and cleanup any erroneously running instances DCNL The use-case for this cleanup task is: for various reasons, it may be DCNL possible for the database to show an instance as deleted but for that DCNL instance to still be running on a host machine (see bug DCNL https://bugs.launchpad.net/nova/+bug/911366). DCNL This cleanup task is a cross-hypervisor utility for finding these DCNL zombied instances and either logging the discrepancy (likely what you DCNL should do in production), or automatically reaping the instances (more DCNL appropriate for dev environments).'
def _running_deleted_instances(self, context): DCNL 'Returns a list of instances nova thinks is deleted, DCNL but the hypervisor thinks is still running.'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def add_aggregate_host(self, context, host, slave_info=None, aggregate=None, aggregate_id=None): DCNL 'Notify hypervisor of change (for hypervisor pools).'
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def remove_aggregate_host(self, context, host, slave_info=None, aggregate=None, aggregate_id=None): DCNL 'Removes a host from a physical hypervisor pool.'
@manager.periodic_task(spacing=CONF.image_cache_manager_interval, external_process_ok=True) DCNL def _run_image_cache_manager_pass(self, context): DCNL 'Run a single pass of the image cache manager.'
def _instance_update(self, context, instance_uuid, **kwargs): DCNL 'Update an instance in the database using kwargs as value.'
def _check_injected_file_quota(self, context, injected_files): DCNL 'Enforce quota limits on injected files. DCNL Raises a QuotaError if any limit is exceeded.'
def _check_num_instances_quota(self, context, instance_type, min_count, max_count): DCNL 'Enforce quota limits on number of instances created.'
def _check_metadata_properties_quota(self, context, metadata=None): DCNL 'Enforce quota limits on metadata properties.'
def _check_requested_secgroups(self, context, secgroups): DCNL 'Check if the security group requested exists and belongs to DCNL the project.'
def _check_requested_networks(self, context, requested_networks): DCNL 'Check if the networks requested belongs to the project DCNL and the fixed IP address for each network provided is within DCNL same the network block'
@staticmethod DCNL def _handle_kernel_and_ramdisk(context, kernel_id, ramdisk_id, image): DCNL 'Choose kernel and ramdisk appropriate for the instance. DCNL The kernel and ramdisk can be chosen in one of three ways: DCNL 1. Passed in with create-instance request. DCNL 2. Inherited from image. DCNL 3. Forced to None by using `null_kernel` FLAG.'
def _validate_and_provision_instance(self, context, instance_type, image_href, kernel_id, ramdisk_id, min_count, max_count, display_name, display_description, key_name, key_data, security_groups, availability_zone, user_data, metadata, injected_files, access_ip_v4, access_ip_v6, requested_networks, config_drive, block_device_mapping, auto_disk_config, reservation_id, scheduler_hints): DCNL 'Verify all the input parameters regardless of the provisioning DCNL strategy being performed.'
def _create_instance(self, context, instance_type, image_href, kernel_id, ramdisk_id, min_count, max_count, display_name, display_description, key_name, key_data, security_group, availability_zone, user_data, metadata, injected_files, admin_password, access_ip_v4, access_ip_v6, requested_networks, config_drive, block_device_mapping, auto_disk_config, reservation_id=None, scheduler_hints=None): DCNL 'Verify all the input parameters regardless of the provisioning DCNL strategy being performed and schedule the instance(s) for DCNL creation.'
def _update_image_block_device_mapping(self, elevated_context, instance_type, instance_uuid, mappings): DCNL 'tell vm driver to create ephemeral/swap device at boot time by DCNL updating BlockDeviceMapping'
def _update_block_device_mapping(self, elevated_context, instance_type, instance_uuid, block_device_mapping): DCNL 'tell vm driver to attach volume at boot time by updating DCNL BlockDeviceMapping'
def _populate_instance_for_bdm(self, context, instance, instance_type, image, block_device_mapping): DCNL 'Populate instance block device mapping information.'
def _populate_instance_shutdown_terminate(self, instance, image, block_device_mapping): DCNL 'Populate instance shutdown_terminate information.'
def _populate_instance_names(self, instance, num_instances): DCNL 'Populate instance display_name and hostname.'
def _populate_instance_for_create(self, base_options, image, security_groups): DCNL 'Build the beginning of a new instance.'
def create_db_entry_for_new_instance(self, context, instance_type, image, base_options, security_group, block_device_mapping, num_instances, index): DCNL 'Create an entry in the DB for this new instance, DCNL including any related table updates (such as security group, DCNL etc). DCNL This is called by the scheduler after a location for the DCNL instance has been determined.'
def _check_create_policies(self, context, availability_zone, requested_networks, block_device_mapping): DCNL 'Check policies for create().'
@hooks.add_hook('create_instance') DCNL def create(self, context, instance_type, image_href, kernel_id=None, ramdisk_id=None, min_count=None, max_count=None, display_name=None, display_description=None, key_name=None, key_data=None, security_group=None, availability_zone=None, user_data=None, metadata=None, injected_files=None, admin_password=None, block_device_mapping=None, access_ip_v4=None, access_ip_v6=None, requested_networks=None, config_drive=None, auto_disk_config=None, scheduler_hints=None): DCNL 'Provision instances, sending instance information to the DCNL scheduler.  The scheduler will determine where the instance(s) DCNL go and will handle creating the DB entries. DCNL Returns a tuple of (instances, reservation_id)'
def trigger_provider_fw_rules_refresh(self, context): DCNL 'Called when a rule is added/removed from a provider firewall.'
def update_state(self, context, instance, new_state): DCNL 'Updates the state of a compute instance. DCNL For example to \'active\' or \'error\'. DCNL Also sets \'task_state\' to None. DCNL Used by admin_actions api DCNL :param context: The security context DCNL :param instance: The instance to update DCNL :param new_state: A member of vm_state, eg. \'active\''
@wrap_check_policy DCNL def update(self, context, instance, **kwargs): DCNL 'Updates the instance in the datastore. DCNL :param context: The security context DCNL :param instance: The instance to update DCNL :param kwargs: All additional keyword args are treated DCNL as data fields of the instance to be DCNL updated DCNL :returns: None'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=None, task_state=None) DCNL def soft_delete(self, context, instance): DCNL 'Terminate an instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=None, task_state=None) DCNL def delete(self, context, instance): DCNL 'Terminate an instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.SOFT_DELETED]) DCNL def restore(self, context, instance): DCNL 'Restore a previously deleted (but not reclaimed) instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.SOFT_DELETED]) DCNL def force_delete(self, context, instance): DCNL 'Force delete a previously deleted (but not reclaimed) instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_host DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.RESCUED, vm_states.ERROR, vm_states.STOPPED], task_state=[None]) DCNL def stop(self, context, instance, do_cast=True): DCNL 'Stop an instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_host DCNL @check_instance_state(vm_state=[vm_states.STOPPED]) DCNL def start(self, context, instance): DCNL 'Start an instance.'
def get_active_by_window(self, context, begin, end=None, project_id=None): DCNL 'Get instances that were continuously active over a window.'
def get_instance_type(self, context, instance_type_id): DCNL 'Get an instance type by instance type id.'
def get(self, context, instance_id): DCNL 'Get a single instance with the given instance_id.'
def get_all(self, context, search_opts=None, sort_key='created_at', sort_dir='desc', limit=None, marker=None): DCNL 'Get all instances filtered by one of the given parameters. DCNL If there is no filter and the context is an admin, it will retrieve DCNL all instances in the system. DCNL Deleted instances will be returned by default, unless there is a DCNL search option that says otherwise. DCNL The results will be returned sorted in the order specified by the DCNL \'sort_dir\' parameter using the key specified in the \'sort_key\' DCNL parameter.'
@wrap_check_policy DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED]) DCNL def backup(self, context, instance, name, backup_type, rotation, extra_properties=None, image_id=None): DCNL 'Backup the given instance DCNL :param instance: nova.db.sqlalchemy.models.Instance DCNL :param name: name of the backup or snapshot DCNL name = backup_type  # daily backups are called \'daily\' DCNL :param rotation: int representing how many backups to keep around; DCNL None if rotation shouldn\'t be used (as in the case of snapshots) DCNL :param extra_properties: dict of extra image properties to include'
@wrap_check_policy DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED, vm_states.PAUSED, vm_states.SUSPENDED]) DCNL def snapshot(self, context, instance, name, extra_properties=None, image_id=None): DCNL 'Snapshot the given instance. DCNL :param instance: nova.db.sqlalchemy.models.Instance DCNL :param name: name of the backup or snapshot DCNL :param extra_properties: dict of extra image properties to include DCNL :returns: A dict containing image metadata'
def _create_image(self, context, instance, name, image_type, backup_type=None, rotation=None, extra_properties=None): DCNL 'Create new image entry in the image service.  This new image DCNL will be reserved for the compute manager to upload a snapshot DCNL or backup. DCNL :param context: security context DCNL :param instance: nova.db.sqlalchemy.models.Instance DCNL :param name: string for name of the snapshot DCNL :param image_type: snapshot | backup DCNL :param backup_type: daily | weekly DCNL :param rotation: int representing how many backups to keep around; DCNL None if rotation shouldn\'t be used (as in the case of snapshots) DCNL :param extra_properties: dict of extra image properties to include'
@check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED]) DCNL def snapshot_volume_backed(self, context, instance, image_meta, name, extra_properties=None): DCNL 'Snapshot the given volume-backed instance. DCNL :param instance: nova.db.sqlalchemy.models.Instance DCNL :param image_meta: metadata for the new image DCNL :param name: name of the backup or snapshot DCNL :param extra_properties: dict of extra image properties to include DCNL :returns: the new image metadata'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED, vm_states.PAUSED, vm_states.SUSPENDED], task_state=[None, task_states.REBOOTING, task_states.REBOOTING_HARD, task_states.RESUMING, task_states.UNPAUSING, task_states.PAUSING, task_states.SUSPENDING]) DCNL def reboot(self, context, instance, reboot_type): DCNL 'Reboot the given instance.'
def _get_image(self, context, image_href): DCNL 'Throws an ImageNotFound exception if image_href does not exist.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED], task_state=[None]) DCNL def rebuild(self, context, instance, image_href, admin_password, **kwargs): DCNL 'Rebuild the given instance with the provided attributes.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.RESIZED]) DCNL def revert_resize(self, context, instance): DCNL 'Reverts a resize, deleting the \'new\' instance in the process.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.RESIZED]) DCNL def confirm_resize(self, context, instance, migration_ref=None): DCNL 'Confirms a migration/resize and deletes the \'old\' instance.'
@staticmethod DCNL def _resize_quota_delta(context, new_instance_type, old_instance_type, sense, compare): DCNL 'Calculate any quota adjustment required at a particular point DCNL in the resize cycle. DCNL :param context: the request context DCNL :param new_instance_type: the target instance type DCNL :param old_instance_type: the original instance type DCNL :param sense: the sense of the adjustment, 1 indicates a DCNL forward adjustment, whereas -1 indicates a DCNL reversal of a prior adjustment DCNL :param compare: the direction of the comparison, 1 indicates DCNL we\'re checking for positive deltas, whereas DCNL -1 indicates negative deltas'
@staticmethod DCNL def _upsize_quota_delta(context, new_instance_type, old_instance_type): DCNL 'Calculate deltas required to adjust quota for an instance upsize.'
@staticmethod DCNL def _reverse_upsize_quota_delta(context, migration_ref): DCNL 'Calculate deltas required to reverse a prior upsizing DCNL quota adjustment.'
@staticmethod DCNL def _downsize_quota_delta(context, instance): DCNL 'Calculate deltas required to adjust quota for an instance downsize.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED], task_state=[None]) DCNL def resize(self, context, instance, flavor_id=None, **kwargs): DCNL 'Resize (ie, migrate) a running instance. DCNL If flavor_id is None, the process is considered a migration, keeping DCNL the original flavor_id. If flavor_id is not None, the instance should DCNL be migrated to a new host and resized to the new flavor_id.'
@wrap_check_policy DCNL @check_instance_lock DCNL def add_fixed_ip(self, context, instance, network_id): DCNL 'Add fixed_ip from specified network to given instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL def remove_fixed_ip(self, context, instance, address): DCNL 'Remove fixed_ip from specified network to given instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.RESCUED]) DCNL def pause(self, context, instance): DCNL 'Pause the given instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.PAUSED]) DCNL def unpause(self, context, instance): DCNL 'Unpause the given instance.'
@wrap_check_policy DCNL def get_diagnostics(self, context, instance): DCNL 'Retrieve diagnostics for the given instance.'
def get_backdoor_port(self, context, host_name): DCNL 'Retrieve backdoor port.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.RESCUED]) DCNL def suspend(self, context, instance): DCNL 'Suspend the given instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.SUSPENDED]) DCNL def resume(self, context, instance): DCNL 'Resume the given instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED]) DCNL def rescue(self, context, instance, rescue_password=None): DCNL 'Rescue the given instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.RESCUED]) DCNL def unrescue(self, context, instance): DCNL 'Unrescue the given instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE]) DCNL def set_admin_password(self, context, instance, password=None): DCNL 'Set the root/admin password for the given instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL def inject_file(self, context, instance, path, file_contents): DCNL 'Write a file to the given instance.'
@wrap_check_policy DCNL @check_instance_host DCNL def get_vnc_console(self, context, instance, console_type): DCNL 'Get a url to an instance Console.'
@check_instance_host DCNL def get_vnc_connect_info(self, context, instance, console_type): DCNL 'Used in a child cell to get console info.'
@wrap_check_policy DCNL @check_instance_host DCNL def get_spice_console(self, context, instance, console_type): DCNL 'Get a url to an instance Console.'
@check_instance_host DCNL def get_spice_connect_info(self, context, instance, console_type): DCNL 'Used in a child cell to get console info.'
@wrap_check_policy DCNL @check_instance_host DCNL def get_console_output(self, context, instance, tail_length=None): DCNL 'Get console output for an instance.'
@wrap_check_policy DCNL def lock(self, context, instance): DCNL 'Lock the given instance.'
@wrap_check_policy DCNL def unlock(self, context, instance): DCNL 'Unlock the given instance.'
@wrap_check_policy DCNL def get_lock(self, context, instance): DCNL 'Return the boolean state of given instance\'s lock.'
@wrap_check_policy DCNL @check_instance_lock DCNL def reset_network(self, context, instance): DCNL 'Reset networking on the instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL def inject_network_info(self, context, instance): DCNL 'Inject network info for the instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.PAUSED, vm_states.SUSPENDED, vm_states.STOPPED, vm_states.RESIZED, vm_states.SOFT_DELETED], task_state=None) DCNL def attach_volume(self, context, instance, volume_id, device=None): DCNL 'Attach an existing volume to an existing instance.'
def detach_volume(self, context, volume_id): DCNL 'Detach a volume from an instance.'
@wrap_check_policy DCNL def attach_interface(self, context, instance, network_id, port_id, requested_ip): DCNL 'Use hotplug to add an network adapter to an instance.'
@wrap_check_policy DCNL def detach_interface(self, context, instance, port_id): DCNL 'Detach an network adapter from an instance.'
@wrap_check_policy DCNL def get_instance_metadata(self, context, instance): DCNL 'Get all metadata associated with an instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.PAUSED, vm_states.SUSPENDED, vm_states.STOPPED], task_state=None) DCNL def delete_instance_metadata(self, context, instance, key): DCNL 'Delete the given metadata item from an instance.'
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.PAUSED, vm_states.SUSPENDED, vm_states.STOPPED], task_state=None) DCNL def update_instance_metadata(self, context, instance, metadata, delete=False): DCNL 'Updates or creates instance metadata. DCNL If delete is True, metadata items that are not specified in the DCNL `metadata` argument will be deleted.'
def get_instance_faults(self, context, instances): DCNL 'Get all faults for a list of instance uuids.'
def get_instance_bdms(self, context, instance): DCNL 'Get all bdm tables for specified instance.'
@check_instance_state(vm_state=[vm_states.ACTIVE]) DCNL def live_migrate(self, context, instance, block_migration, disk_over_commit, host_name): DCNL 'Migrate a server lively to a new host.'
@check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED], task_state=[None]) DCNL def evacuate(self, context, instance, host, on_shared_storage, admin_password=None): DCNL 'Running evacuate to target host. DCNL Checking vm compute host state, if the host not in expected_state, DCNL raising an exception.'
def _assert_host_exists(self, context, host_name): DCNL 'Raise HostNotFound if compute host doesn\'t exist.'
def set_host_enabled(self, context, host_name, enabled): DCNL 'Sets the specified host\'s ability to accept new instances.'
def get_host_uptime(self, context, host_name): DCNL 'Returns the result of calling "uptime" on the target host.'
def host_power_action(self, context, host_name, action): DCNL 'Reboots, shuts down or powers up the host.'
def set_host_maintenance(self, context, host_name, mode): DCNL 'Start/Stop host maintenance window. On start, it triggers DCNL guest VMs evacuation.'
def service_get_all(self, context, filters=None, set_zones=False): DCNL 'Returns a list of services, optionally filtering the results. DCNL If specified, \'filters\' should be a dictionary containing services DCNL attributes and matching values.  Ie, to get a list of services for DCNL the \'compute\' topic, use filters={\'topic\': \'compute\'}.'
def service_get_by_compute_host(self, context, host_name): DCNL 'Get service entry for the given compute hostname.'
def instance_get_all_by_host(self, context, host_name): DCNL 'Return all instances on the given host.'
def task_log_get_all(self, context, task_name, period_beginning, period_ending, host=None, state=None): DCNL 'Return the task logs within a given range, optionally DCNL filtering by host and/or state.'
def compute_node_get(self, context, compute_id): DCNL 'Return compute node entry for particular integer ID.'
def create_aggregate(self, context, aggregate_name, availability_zone): DCNL 'Creates the model for the aggregate.'
def get_aggregate(self, context, aggregate_id): DCNL 'Get an aggregate by id.'
def get_aggregate_list(self, context): DCNL 'Get all the aggregates.'
def update_aggregate(self, context, aggregate_id, values): DCNL 'Update the properties of an aggregate.'
def update_aggregate_metadata(self, context, aggregate_id, metadata): DCNL 'Updates the aggregate metadata. DCNL If a key is set to None, it gets removed from the aggregate metadata.'
def delete_aggregate(self, context, aggregate_id): DCNL 'Deletes the aggregate.'
def add_host_to_aggregate(self, context, aggregate_id, host_name): DCNL 'Adds the host to an aggregate.'
def remove_host_from_aggregate(self, context, aggregate_id, host_name): DCNL 'Removes host from the aggregate.'
def _get_aggregate_info(self, context, aggregate): DCNL 'Builds a dictionary with aggregate props, metadata and hosts.'
def import_key_pair(self, context, user_id, key_name, public_key): DCNL 'Import a key pair using an existing public key.'
def create_key_pair(self, context, user_id, key_name): DCNL 'Create a new key pair.'
def delete_key_pair(self, context, user_id, key_name): DCNL 'Delete a keypair by name.'
def get_key_pairs(self, context, user_id): DCNL 'List key pairs.'
def get_key_pair(self, context, user_id, key_name): DCNL 'Get a keypair by name.'
def validate_property(self, value, property, allowed): DCNL 'Validate given security group property. DCNL :param value:          the value to validate, as a string or unicode DCNL :param property:       the property, either \'name\' or \'description\' DCNL :param allowed:        the range of characters allowed'
def ensure_default(self, context): DCNL 'Ensure that a context has a security group. DCNL Creates a security group for the security context if it does not DCNL already exist. DCNL :param context: the security context'
def is_associated_with_server(self, security_group, instance_uuid): DCNL 'Check if the security group is already associated DCNL with the instance. If Yes, return True.'
@wrap_check_security_groups_policy DCNL def add_to_instance(self, context, instance, security_group_name): DCNL 'Add security group to the instance.'
@wrap_check_security_groups_policy DCNL def remove_from_instance(self, context, instance, security_group_name): DCNL 'Remove the security group associated with the instance.'
def add_rules(self, context, id, name, vals): DCNL 'Add security group rule(s) to security group. DCNL Note: the Nova security group API doesn\'t support adding muliple DCNL security group rules at once but the EC2 one does. Therefore, DCNL this function is writen to support both.'
def default_rule_exists(self, context, values): DCNL 'Indicates whether the specified rule values are already DCNL defined in the default security group rules.'
def trigger_rules_refresh(self, context, id): DCNL 'Called when a rule is added to or removed from a security_group.'
def trigger_members_refresh(self, context, group_ids): DCNL 'Called when a security group gains a new or loses a member. DCNL Sends an update request to each compute node for each instance for DCNL which this is relevant.'
@property DCNL def io_workload(self): DCNL 'Calculate an I/O based load by counting I/O heavy operations.'
def calculate_workload(self): DCNL 'Calculate current load of the compute host based on DCNL task states.'
def update_stats_for_instance(self, instance): DCNL 'Update stats after an instance is changed.'
def _extract_state_from_instance(self, instance): DCNL 'Save the useful bits of instance state for tracking purposes.'
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def abort(self): DCNL 'Compute operation requiring claimed resources has failed or DCNL been aborted.'
def test(self, resources, limits=None): DCNL 'Test if this claim can be satisfied given available resources and DCNL optional oversubscription limits DCNL This should be called before the compute node actually consumes the DCNL resources required to execute the claim. DCNL :param resources: available local compute node resources DCNL :returns: Return true if resources are available to claim.'
def _test(self, type_, unit, total, used, requested, limit): DCNL 'Test if the given type of resource needed for a claim can be safely DCNL allocated.'
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def abort(self): DCNL 'Compute operation requiring claimed resources has failed or DCNL been aborted.'
def _cell_read_only(self, cell_name): DCNL 'Is the target cell in a read-only mode?'
def _check_requested_networks(self, context, requested_networks): DCNL 'Override compute API\'s checking of this.  It\'ll happen in DCNL child cell'
def _validate_image_href(self, context, image_href): DCNL 'Override compute API\'s checking of this.  It\'ll happen in DCNL child cell'
def backup(self, context, instance, name, backup_type, rotation, extra_properties=None, image_id=None): DCNL 'Backup the given instance.'
def snapshot(self, context, instance, name, extra_properties=None, image_id=None): DCNL 'Snapshot the given instance.'
def create(self, *args, **kwargs): DCNL 'We can use the base functionality, but I left this here just DCNL for completeness.'
def update_state(self, context, instance, new_state): DCNL 'Updates the state of a compute instance. DCNL For example to \'active\' or \'error\'. DCNL Also sets \'task_state\' to None. DCNL Used by admin_actions api DCNL :param context: The security context DCNL :param instance: The instance to update DCNL :param new_state: A member of vm_state to change DCNL the instance\'s state to, DCNL eg. \'active\''
def update(self, context, instance, pass_on_state_change=False, **kwargs): DCNL 'Update an instance. DCNL :param pass_on_state_change: if true, the state change will be passed DCNL on to child cells'
def _handle_cell_delete(self, context, instance, method, method_name): DCNL 'Terminate an instance.'
@validate_cell DCNL def restore(self, context, instance): DCNL 'Restore a previously deleted (but not reclaimed) instance.'
@validate_cell DCNL def force_delete(self, context, instance): DCNL 'Force delete a previously deleted (but not reclaimed) instance.'
@validate_cell DCNL def stop(self, context, instance, do_cast=True): DCNL 'Stop an instance.'
@validate_cell DCNL def start(self, context, instance): DCNL 'Start an instance.'
@validate_cell DCNL def reboot(self, context, instance, *args, **kwargs): DCNL 'Reboot the given instance.'
@validate_cell DCNL def rebuild(self, context, instance, *args, **kwargs): DCNL 'Rebuild the given instance with the provided attributes.'
@validate_cell DCNL def evacuate(self, context, instance, *args, **kwargs): DCNL 'Evacuate the given instance with the provided attributes.'
@check_instance_state(vm_state=[vm_states.RESIZED]) DCNL @validate_cell DCNL def revert_resize(self, context, instance): DCNL 'Reverts a resize, deleting the \'new\' instance in the process.'
@check_instance_state(vm_state=[vm_states.RESIZED]) DCNL @validate_cell DCNL def confirm_resize(self, context, instance): DCNL 'Confirms a migration/resize and deletes the \'old\' instance.'
@check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED], task_state=[None]) DCNL @validate_cell DCNL def resize(self, context, instance, flavor_id=None, *args, **kwargs): DCNL 'Resize (ie, migrate) a running instance. DCNL If flavor_id is None, the process is considered a migration, keeping DCNL the original flavor_id. If flavor_id is not None, the instance should DCNL be migrated to a new host and resized to the new flavor_id.'
@validate_cell DCNL def add_fixed_ip(self, context, instance, *args, **kwargs): DCNL 'Add fixed_ip from specified network to given instance.'
@validate_cell DCNL def remove_fixed_ip(self, context, instance, *args, **kwargs): DCNL 'Remove fixed_ip from specified network to given instance.'
@validate_cell DCNL def pause(self, context, instance): DCNL 'Pause the given instance.'
@validate_cell DCNL def unpause(self, context, instance): DCNL 'Unpause the given instance.'
def get_diagnostics(self, context, instance): DCNL 'Retrieve diagnostics for the given instance.'
@validate_cell DCNL def suspend(self, context, instance): DCNL 'Suspend the given instance.'
@validate_cell DCNL def resume(self, context, instance): DCNL 'Resume the given instance.'
@validate_cell DCNL def rescue(self, context, instance, rescue_password=None): DCNL 'Rescue the given instance.'
@validate_cell DCNL def unrescue(self, context, instance): DCNL 'Unrescue the given instance.'
@validate_cell DCNL def set_admin_password(self, context, instance, password=None): DCNL 'Set the root/admin password for the given instance.'
@validate_cell DCNL def inject_file(self, context, instance, *args, **kwargs): DCNL 'Write a file to the given instance.'
@wrap_check_policy DCNL @validate_cell DCNL def get_vnc_console(self, context, instance, console_type): DCNL 'Get a url to a VNC Console.'
@wrap_check_policy DCNL @validate_cell DCNL def get_spice_console(self, context, instance, console_type): DCNL 'Get a url to a SPICE Console.'
@validate_cell DCNL def get_console_output(self, context, instance, *args, **kwargs): DCNL 'Get console output for an an instance.'
def lock(self, context, instance): DCNL 'Lock the given instance.'
def unlock(self, context, instance): DCNL 'Unlock the given instance.'
@validate_cell DCNL def reset_network(self, context, instance): DCNL 'Reset networking on the instance.'
@validate_cell DCNL def inject_network_info(self, context, instance): DCNL 'Inject network info for the instance.'
@wrap_check_policy DCNL @validate_cell DCNL def attach_volume(self, context, instance, volume_id, device=None): DCNL 'Attach an existing volume to an existing instance.'
@check_instance_lock DCNL @validate_cell DCNL def _detach_volume(self, context, instance, volume_id): DCNL 'Detach a volume from an instance.'
@wrap_check_policy DCNL @validate_cell DCNL def associate_floating_ip(self, context, instance, address): DCNL 'Makes calls to network_api to associate_floating_ip. DCNL :param address: is a string floating ip address'
@validate_cell DCNL def delete_instance_metadata(self, context, instance, key): DCNL 'Delete the given metadata item from an instance.'
def _assert_host_exists(self, context, host_name): DCNL 'Cannot check this in API cell.  This will be checked in the DCNL target child cell.'
def instance_get_all_by_host(self, context, host_name): DCNL 'Get all instances by host.  Host might have a cell prepended DCNL to it, so we\'ll need to strip it out.  We don\'t need to proxy DCNL this call to cells, as we have instance information here in DCNL the API cell.'
def task_log_get_all(self, context, task_name, beginning, ending, host=None, state=None): DCNL 'Return the task logs within a given range from cells, DCNL optionally filtering by the host and/or state.  For cells, the DCNL host should be a path like \'path!to!cell@host\'.  If no @host DCNL is given, only task logs from a particular cell will be returned.'
def compute_node_get(self, context, compute_id): DCNL 'Get a compute node from a particular cell by its integer ID. DCNL compute_id should be in the format of \'path!to!cell@ID\'.'
def add_aggregate_host(self, ctxt, aggregate, host_param, host, slave_info=None): DCNL 'Add aggregate host. DCNL :param ctxt: request context DCNL :param aggregate_id: DCNL :param host_param: This value is placed in the message to be the \'host\' DCNL parameter for the remote method. DCNL :param host: This is the host to send the message to.'
def host_maintenance_mode(self, ctxt, host_param, mode, host): DCNL 'Set host maintenance mode DCNL :param ctxt: request context DCNL :param host_param: This value is placed in the message to be the \'host\' DCNL parameter for the remote method. DCNL :param mode: DCNL :param host: This is the host to send the message to.'
def remove_aggregate_host(self, ctxt, aggregate, host_param, host, slave_info=None): DCNL 'Remove aggregate host. DCNL :param ctxt: request context DCNL :param aggregate_id: DCNL :param host_param: This value is placed in the message to be the \'host\' DCNL parameter for the remote method. DCNL :param host: This is the host to send the message to.'
def _append_hop(self): DCNL 'Add our hop to the routing_path.'
def _at_max_hop_count(self, do_raise=True): DCNL 'Check if we\'re at the max hop count.  If we are and do_raise is DCNL True, raise CellMaxHopCountReached.  If we are at the max and DCNL do_raise is False... return True, else False.'
def _process_locally(self): DCNL 'Its been determined that we should process this message in this DCNL cell.  Go through the MessageRunner to call the appropriate DCNL method for this message.  Catch the response and/or exception and DCNL encode it within a Response instance.  Return it so the caller DCNL can potentially return it to another cell... or return it to DCNL a caller waiting in this cell.'
def _setup_response_queue(self): DCNL 'Shortcut to creating a response queue in the MessageRunner.'
def _cleanup_response_queue(self): DCNL 'Shortcut to deleting a response queue in the MessageRunner.'
def _wait_for_json_responses(self, num_responses=1): DCNL 'Wait for response(s) to be put into the eventlet queue.  Since DCNL each queue entry actually contains a list of JSON-ified responses, DCNL combine them all into a single list to return. DCNL Destroy the eventlet queue when done.'
def _send_json_responses(self, json_responses, neighbor_only=False, fanout=False): DCNL 'Send list of responses to this message.  Responses passed here DCNL are JSON-ified.  Targeted messages have a single response while DCNL Broadcast messages may have multiple responses. DCNL If this cell was the source of the message, these responses will DCNL be returned from self.process(). DCNL Otherwise, we will route the response to the source of the DCNL request.  If \'neighbor_only\' is True, the response will be sent DCNL to the neighbor cell, not the original requester.  Broadcast DCNL messages get aggregated at each hop, so neighbor_only will be DCNL True for those messages.'
def _send_response(self, response, neighbor_only=False): DCNL 'Send a response to this message.  If the source of the DCNL request was ourselves, just return the response.  It\'ll be DCNL passed back to the caller of self.process().  See DocString for DCNL _send_json_responses() as it handles most of the real work for DCNL this method. DCNL \'response\' is an instance of Response class.'
def _send_response_from_exception(self, exc_info): DCNL 'Take an exception as returned from sys.exc_info(), encode DCNL it in a Response, and send it.'
def _to_dict(self): DCNL 'Convert a message to a dictionary.  Only used internally.'
def to_json(self): DCNL 'Convert a message into JSON for sending to a sibling cell.'
def source_is_us(self): DCNL 'Did this cell create this message?'
def process(self): DCNL 'Process a message.  Deal with it locally and/or forward it to a DCNL sibling cell. DCNL Override in a subclass.'
def _get_next_hop(self): DCNL 'Return the cell name for the next hop.  If the next hop is DCNL the current cell, return None.'
def process(self): DCNL 'Process a targeted message.  This is called for all cells DCNL that touch this message.  If the local cell is the one that DCNL created this message, we reply directly with a Response instance. DCNL If the local cell is not the target, an eventlet queue is created DCNL and we wait for the response to show up via another thread DCNL receiving the Response back. DCNL Responses to targeted messages are routed directly back to the DCNL source.  No eventlet queues are created in intermediate hops. DCNL All exceptions for processing the message across the whole DCNL routing path are caught and encoded within the Response and DCNL returned to the caller.'
def _get_next_hops(self): DCNL 'Set the next hops and return the number of hops.  The next DCNL hops may include ourself.'
def _send_to_cells(self, target_cells): DCNL 'Send a message to multiple cells.'
def _send_json_responses(self, json_responses): DCNL 'Responses to broadcast messages always need to go to the DCNL neighbor cell from which we received this message.  That DCNL cell aggregates the responses and makes sure to forward them DCNL to the correct source.'
def process(self): DCNL 'Process a broadcast message.  This is called for all cells DCNL that touch this message. DCNL The message is sent to all cells in the certain direction and DCNL the creator of this message has the option of whether or not DCNL to process it locally as well. DCNL If responses from all cells are required, each hop creates an DCNL eventlet queue and waits for responses from its immediate DCNL neighbor cells.  All responses are then aggregated into a DCNL single list and are returned to the neighbor cell until the DCNL source is reached. DCNL When the source is reached, a list of Response instances are DCNL returned to the caller. DCNL All exceptions for processing the message across the whole DCNL routing path are caught and encoded within the Response and DCNL returned to the caller.  It is possible to get a mix of DCNL successful responses and failure responses.  The caller is DCNL responsible for dealing with this.'
def process(self): DCNL 'Process a response.  If the target is the local cell, process DCNL the response here.  Otherwise, forward it to where it needs to DCNL go.'
def task_log_get_all(self, message, task_name, period_beginning, period_ending, host, state): DCNL 'Get task logs from the DB.  The message could have DCNL directly targeted this cell, or it could have been a broadcast DCNL message. DCNL If \'host\' is not None, filter by host. DCNL If \'state\' is not None, filter by state.'
def schedule_run_instance(self, message, host_sched_kwargs): DCNL 'Parent cell told us to schedule new instance creation.'
def run_compute_api_method(self, message, method_info): DCNL 'Run a method in the compute api class.'
def update_capabilities(self, message, cell_name, capabilities): DCNL 'A child cell told us about their capabilities.'
def update_capacities(self, message, cell_name, capacities): DCNL 'A child cell told us about their capacity.'
def announce_capabilities(self, message): DCNL 'A parent cell has told us to send our capabilities, so let\'s DCNL do so.'
def announce_capacities(self, message): DCNL 'A parent cell has told us to send our capacity, so let\'s DCNL do so.'
def service_get_by_compute_host(self, message, host_name): DCNL 'Return the service entry for a compute host.'
def proxy_rpc_to_manager(self, message, host_name, rpc_message, topic, timeout): DCNL 'Proxy RPC to the given compute topic.'
def compute_node_get(self, message, compute_id): DCNL 'Get compute node by ID.'
def validate_console_port(self, message, instance_uuid, console_port, console_type): DCNL 'Validate console port with child cell compute node.'
def _at_the_top(self): DCNL 'Are we the API level?'
def instance_update_at_top(self, message, instance, **kwargs): DCNL 'Update an instance in the DB if we\'re a top level cell.'
def instance_destroy_at_top(self, message, instance, **kwargs): DCNL 'Destroy an instance from the DB if we\'re a top level cell.'
def instance_delete_everywhere(self, message, instance, delete_type, **kwargs): DCNL 'Call compute API delete() or soft_delete() in every cell. DCNL This is used when the API cell doesn\'t know what cell an instance DCNL belongs to but the instance was requested to be deleted or DCNL soft-deleted.  So, we\'ll run it everywhere.'
def instance_fault_create_at_top(self, message, instance_fault, **kwargs): DCNL 'Destroy an instance from the DB if we\'re a top level cell.'
def bw_usage_update_at_top(self, message, bw_update_info, **kwargs): DCNL 'Update Bandwidth usage in the DB if we\'re a top level cell.'
def compute_node_get_all(self, message, hypervisor_match): DCNL 'Return compute nodes in this cell.'
def compute_node_stats(self, message): DCNL 'Return compute node stats from this cell.'
def consoleauth_delete_tokens(self, message, instance_uuid): DCNL 'Delete consoleauth tokens for an instance in API cells.'
def _process_message_locally(self, message): DCNL 'Message processing will call this when its determined that DCNL the message should be processed within this cell.  Find the DCNL method to call based on the message type, and call it.  The DCNL caller is responsible for catching exceptions and returning DCNL results to cells, if needed.'
def _put_response(self, response_uuid, response): DCNL 'Put a response into a response queue.  This is called when DCNL a _ResponseMessage is processed in the cell that initiated a DCNL \'call\' to another cell.'
def _setup_response_queue(self, message): DCNL 'Set up an eventlet queue to use to wait for replies. DCNL Replies come back from the target cell as a _ResponseMessage DCNL being sent back to the source.'
def _cleanup_response_queue(self, message): DCNL 'Stop tracking the response queue either because we\'re DCNL done receiving responses, or we\'ve timed out.'
def _create_response_message(self, ctxt, direction, target_cell, response_uuid, response_kwargs, **kwargs): DCNL 'Create a ResponseMessage.  This is used internally within DCNL the messaging module.'
def message_from_json(self, json_message): DCNL 'Turns a message in JSON format into an appropriate Message DCNL instance.  This is called when cells receive a message from DCNL another cell.'
def ask_children_for_capabilities(self, ctxt): DCNL 'Tell child cells to send us capabilities.  This is typically DCNL called on startup of the nova-cells service.'
def ask_children_for_capacities(self, ctxt): DCNL 'Tell child cells to send us capacities.  This is typically DCNL called on startup of the nova-cells service.'
def tell_parents_our_capabilities(self, ctxt): DCNL 'Send our capabilities to parent cells.'
def tell_parents_our_capacities(self, ctxt): DCNL 'Send our capacities to parent cells.'
def schedule_run_instance(self, ctxt, target_cell, host_sched_kwargs): DCNL 'Called by the scheduler to tell a child cell to schedule DCNL a new instance for build.'
def run_compute_api_method(self, ctxt, cell_name, method_info, call): DCNL 'Call a compute API method in a specific cell.'
def instance_update_at_top(self, ctxt, instance): DCNL 'Update an instance at the top level cell.'
def instance_destroy_at_top(self, ctxt, instance): DCNL 'Destroy an instance at the top level cell.'
def instance_delete_everywhere(self, ctxt, instance, delete_type): DCNL 'This is used by API cell when it didn\'t know what cell DCNL an instance was in, but the instance was requested to be DCNL deleted or soft_deleted.  So, we\'ll broadcast this everywhere.'
def instance_fault_create_at_top(self, ctxt, instance_fault): DCNL 'Create an instance fault at the top level cell.'
def bw_usage_update_at_top(self, ctxt, bw_update_info): DCNL 'Update bandwidth usage at top level cell.'
def sync_instances(self, ctxt, project_id, updated_since, deleted): DCNL 'Force a sync of all instances, potentially by project_id, DCNL and potentially since a certain date/time.'
def task_log_get_all(self, ctxt, cell_name, task_name, period_beginning, period_ending, host=None, state=None): DCNL 'Get task logs from the DB from all cells or a particular DCNL cell. DCNL If \'cell_name\' is None or \'\', get responses from all cells. DCNL If \'host\' is not None, filter by host. DCNL If \'state\' is not None, filter by state. DCNL Return a list of Response objects.'
def compute_node_get_all(self, ctxt, hypervisor_match=None): DCNL 'Return list of compute nodes in all child cells.'
def compute_node_stats(self, ctxt): DCNL 'Return compute node stats from all child cells.'
def compute_node_get(self, ctxt, cell_name, compute_id): DCNL 'Return compute node entry from a specific cell by ID.'
def consoleauth_delete_tokens(self, ctxt, instance_uuid): DCNL 'Delete consoleauth tokens for an instance in API cells.'
def validate_console_port(self, ctxt, cell_name, instance_uuid, console_port, console_type): DCNL 'Validate console port with child cell compute node.'
def start_consumers(self, msg_runner): DCNL 'Start any consumers the driver may need.'
def stop_consumers(self): DCNL 'Stop consuming messages.'
def send_message_to_cell(self, cell_state, message): DCNL 'Send a message to a cell.'
def _run_instance(self, message, host_sched_kwargs): DCNL 'Attempt to schedule instance(s).  If we have no cells DCNL to try, raise exception.NoCellsAvailable'
def run_instance(self, message, host_sched_kwargs): DCNL 'Pick a cell where we should create a new instance.'
def post_start_hook(self): DCNL 'Have the driver start its consumers for inter-cell communication. DCNL Also ask our child cells for their capacities and capabilities so DCNL we get them more quickly than just waiting for the next periodic DCNL update.  Receiving the updates from the children will cause us to DCNL update our parents.  If we don\'t have any children, just update DCNL our parents immediately.'
@manager.periodic_task DCNL def _update_our_parents(self, ctxt): DCNL 'Update our parent cells with our capabilities and capacity DCNL if we\'re at the bottom of the tree.'
@manager.periodic_task DCNL def _heal_instances(self, ctxt): DCNL 'Periodic task to send updates for a number of instances to DCNL parent cells. DCNL On every run of the periodic task, we will attempt to sync DCNL \'CONF.cells.instance_update_num_instances\' number of instances. DCNL When we get the list of instances, we shuffle them so that multiple DCNL nova-cells services aren\'t attempting to sync the same instances DCNL in lockstep. DCNL If CONF.cells.instance_update_at_threshold is set, only attempt DCNL to sync instances that have been updated recently.  The CONF DCNL setting defines the maximum number of seconds old the updated_at DCNL can be.  Ie, a threshold of 3600 means to only update instances DCNL that have modified in the last hour.'
def _sync_instance(self, ctxt, instance): DCNL 'Broadcast an instance_update or instance_destroy message up to DCNL parent cells.'
def schedule_run_instance(self, ctxt, host_sched_kwargs): DCNL 'Pick a cell (possibly ourselves) to build new instance(s) DCNL and forward the request accordingly.'
def get_cell_info_for_neighbors(self, _ctxt): DCNL 'Return cell information for our neighbor cells.'
def run_compute_api_method(self, ctxt, cell_name, method_info, call): DCNL 'Call a compute API method in a specific cell.'
def instance_update_at_top(self, ctxt, instance): DCNL 'Update an instance at the top level cell.'
def instance_destroy_at_top(self, ctxt, instance): DCNL 'Destroy an instance at the top level cell.'
def instance_delete_everywhere(self, ctxt, instance, delete_type): DCNL 'This is used by API cell when it didn\'t know what cell DCNL an instance was in, but the instance was requested to be DCNL deleted or soft_deleted.  So, we\'ll broadcast this everywhere.'
def instance_fault_create_at_top(self, ctxt, instance_fault): DCNL 'Create an instance fault at the top level cell.'
def bw_usage_update_at_top(self, ctxt, bw_update_info): DCNL 'Update bandwidth usage at top level cell.'
def sync_instances(self, ctxt, project_id, updated_since, deleted): DCNL 'Force a sync of all instances, potentially by project_id, DCNL and potentially since a certain date/time.'
def service_get_all(self, ctxt, filters): DCNL 'Return services in this cell and in all child cells.'
def service_get_by_compute_host(self, ctxt, host_name): DCNL 'Return a service entry for a compute host in a certain cell.'
def proxy_rpc_to_manager(self, ctxt, topic, rpc_message, call, timeout): DCNL 'Proxy an RPC message as-is to a manager.'
def task_log_get_all(self, ctxt, task_name, period_beginning, period_ending, host=None, state=None): DCNL 'Get task logs from the DB from all cells or a particular DCNL cell. DCNL If \'host\' is not None, host will be of the format \'cell!name@host\', DCNL with \'@host\' being optional.  The query will be directed to the DCNL appropriate cell and return all task logs, or task logs matching DCNL the host if specified. DCNL \'state\' also may be None.  If it\'s not, filter by the state as well.'
def compute_node_get(self, ctxt, compute_id): DCNL 'Get a compute node by ID in a specific cell.'
def compute_node_get_all(self, ctxt, hypervisor_match=None): DCNL 'Return list of compute nodes in all cells.'
def compute_node_stats(self, ctxt): DCNL 'Return compute node stats totals from all cells.'
def consoleauth_delete_tokens(self, ctxt, instance_uuid): DCNL 'Delete consoleauth tokens for an instance in API cells.'
def validate_console_port(self, ctxt, instance_uuid, console_port, console_type): DCNL 'Validate console port with child cell compute node.'
def _start_consumer(self, dispatcher, topic): DCNL 'Start an RPC consumer.'
def start_consumers(self, msg_runner): DCNL 'Start RPC consumers. DCNL Start up 2 separate consumers for handling inter-cell DCNL communication via RPC.  Both handle the same types of DCNL messages, but requests/replies are separated to solve DCNL potential deadlocks. (If we used the same queue for both, DCNL it\'s possible to exhaust the RPC thread pool while we wait DCNL for replies.. such that we\'d never consume a reply.)'
def stop_consumers(self): DCNL 'Stop RPC consumers. DCNL NOTE: Currently there\'s no hooks when stopping services DCNL to have managers cleanup, so this is not currently called.'
def send_message_to_cell(self, cell_state, message): DCNL 'Use the IntercellRPCAPI to send a message to a cell.'
@staticmethod DCNL def _get_server_params_for_cell(next_hop): DCNL 'Turn the DB information for a cell into the parameters DCNL needed for the RPC call.'
def send_message_to_cell(self, cell_state, message): DCNL 'Send a message to another cell by JSON-ifying the message and DCNL making an RPC cast to \'process_message\'.  If the message says to DCNL fanout, do it.  The topic that is used will be DCNL \'CONF.rpc_driver_queue_base.<message_type>\'.'
def __init__(self, msg_runner): DCNL 'Init the Intercell RPC Dispatcher.'
def process_message(self, _ctxt, message): DCNL 'We received a message from another cell.  Use the MessageRunner DCNL to turn this from JSON back into an instance of the correct DCNL Message class.  Then process it!'
def update_db_info(self, cell_db_info): DCNL 'Update cell credentials from db.'
def update_capabilities(self, cell_metadata): DCNL 'Update cell capabilities for a cell.'
def update_capacities(self, capacities): DCNL 'Update capacity information for a cell.'
def get_cell_info(self): DCNL 'Return subset of cell information for OS API use.'
def send_message(self, message): DCNL 'Send a message to a cell.  Just forward this to the driver, DCNL passing ourselves and the message as arguments.'
def _refresh_cells_from_db(self, ctxt): DCNL 'Make our cell info map match the db.'
def _time_to_sync(self): DCNL 'Is it time to sync the DB against our memory cache?'
def _update_our_capacity(self, context): DCNL 'Update our capacity in the self.my_cell_state CellState. DCNL This will add/update 2 entries in our CellState.capacities, DCNL \'ram_free\' and \'disk_free\'. DCNL The values of these are both dictionaries with the following DCNL format: DCNL {\'total_mb\': <total_memory_free_in_the_cell>, DCNL \'units_by_mb: <units_dictionary>} DCNL <units_dictionary> contains the number of units that we can DCNL build for every instance_type that we have.  This number is DCNL computed by looking at room available on every compute_node. DCNL Take the following instance_types as an example: DCNL [{\'memory_mb\': 1024, \'root_gb\': 10, \'ephemeral_gb\': 100}, DCNL {\'memory_mb\': 2048, \'root_gb\': 20, \'ephemeral_gb\': 200}] DCNL capacities[\'ram_free\'][\'units_by_mb\'] would contain the following: DCNL {\'1024\': <number_of_instances_that_will_fit>, DCNL \'2048\': <number_of_instances_that_will_fit>} DCNL capacities[\'disk_free\'][\'units_by_mb\'] would contain the following: DCNL {\'122880\': <number_of_instances_that_will_fit>, DCNL \'225280\': <number_of_instances_that_will_fit>} DCNL Units are in MB, so 122880 = (10 + 100) * 1024. DCNL NOTE(comstud): Perhaps we should only report a single number DCNL available per instance_type.'
@lockutils.synchronized('cell-db-sync', 'nova-') DCNL def _cell_db_sync(self): DCNL 'Update status for all cells if it\'s time.  Most calls to DCNL this are from the check_for_update() decorator that checks DCNL the time, but it checks outside of a lock.  The duplicate DCNL check here is to prevent multiple threads from pulling the DCNL information simultaneously.'
@sync_from_db DCNL def get_cell_info_for_neighbors(self): DCNL 'Return cell information for all neighbor cells.'
@sync_from_db DCNL def get_my_state(self): DCNL 'Return information for my (this) cell.'
@sync_from_db DCNL def get_child_cells(self): DCNL 'Return list of child cell_infos.'
@sync_from_db DCNL def get_parent_cells(self): DCNL 'Return list of parent cell_infos.'
@sync_from_db DCNL def update_cell_capabilities(self, cell_name, capabilities): DCNL 'Update capabilities for a cell.'
@sync_from_db DCNL def update_cell_capacities(self, cell_name, capacities): DCNL 'Update capacities for a cell.'
def cast_compute_api_method(self, ctxt, cell_name, method, *args, **kwargs): DCNL 'Make a cast to a compute API method in a certain cell.'
def call_compute_api_method(self, ctxt, cell_name, method, *args, **kwargs): DCNL 'Make a call to a compute API method in a certain cell.'
def schedule_run_instance(self, ctxt, **kwargs): DCNL 'Schedule a new instance for creation.'
def instance_update_at_top(self, ctxt, instance): DCNL 'Update instance at API level.'
def instance_destroy_at_top(self, ctxt, instance): DCNL 'Destroy instance at API level.'
def instance_delete_everywhere(self, ctxt, instance, delete_type): DCNL 'Delete instance everywhere.  delete_type may be \'soft\' DCNL or \'hard\'.  This is generally only used to resolve races DCNL when API cell doesn\'t know to what cell an instance belongs.'
def instance_fault_create_at_top(self, ctxt, instance_fault): DCNL 'Create an instance fault at the top.'
def bw_usage_update_at_top(self, ctxt, uuid, mac, start_period, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refreshed=None): DCNL 'Broadcast upwards that bw_usage was updated.'
def instance_info_cache_update_at_top(self, ctxt, instance_info_cache): DCNL 'Broadcast up that an instance\'s info_cache has changed.'
def get_cell_info_for_neighbors(self, ctxt): DCNL 'Get information about our neighbor cells from the manager.'
def sync_instances(self, ctxt, project_id=None, updated_since=None, deleted=False): DCNL 'Ask all cells to sync instance data.'
def service_get_all(self, ctxt, filters=None): DCNL 'Ask all cells for their list of services.'
def service_get_by_compute_host(self, ctxt, host_name): DCNL 'Get the service entry for a host in a particular cell.  The DCNL cell name should be encoded within the host_name.'
def proxy_rpc_to_manager(self, ctxt, rpc_message, topic, call=False, timeout=None): DCNL 'Proxy RPC to a compute manager.  The host in the topic DCNL should be encoded with the target cell name.'
def task_log_get_all(self, ctxt, task_name, period_beginning, period_ending, host=None, state=None): DCNL 'Get the task logs from the DB in child cells.'
def compute_node_get(self, ctxt, compute_id): DCNL 'Get a compute node by ID in a specific cell.'
def compute_node_get_all(self, ctxt, hypervisor_match=None): DCNL 'Return list of compute nodes in all cells, optionally DCNL filtering by hypervisor host.'
def compute_node_stats(self, ctxt): DCNL 'Return compute node stats from all cells.'
def consoleauth_delete_tokens(self, ctxt, instance_uuid): DCNL 'Delete consoleauth tokens for an instance in API cells.'
def validate_console_port(self, ctxt, instance_uuid, console_port, console_type): DCNL 'Validate console port with child cell compute node.'
def __init__(self, net_manager): DCNL 'Holds a reference to the "parent" network manager, used DCNL to take advantage of various FlatManager methods to avoid DCNL code duplication.'
def get_subnets_by_net_id(self, context, tenant_id, net_id, _vif_id=None): DCNL 'Returns information about the IPv4 and IPv6 subnets DCNL associated with a Quantum Network UUID.'
def get_routes_by_ip_block(self, context, block_id, project_id): DCNL 'Returns the list of routes for the IP block.'
def get_v4_ips_by_interface(self, context, net_id, vif_id, project_id): DCNL 'Returns a list of IPv4 address strings associated with DCNL the specified virtual interface, based on the fixed_ips table.'
def get_v6_ips_by_interface(self, context, net_id, vif_id, project_id): DCNL 'Returns a list containing a single IPv6 address strings DCNL associated with the specified virtual interface.'
@wrap_check_policy DCNL def allocate_floating_ip(self, context, pool=None): DCNL 'Adds (allocates) a floating ip to a project from a pool.'
@wrap_check_policy DCNL def release_floating_ip(self, context, address, affect_auto_assigned=False): DCNL 'Removes (deallocates) a floating ip with address from a project.'
@wrap_check_policy DCNL @refresh_cache DCNL def associate_floating_ip(self, context, instance, floating_address, fixed_address, affect_auto_assigned=False): DCNL 'Associates a floating ip with a fixed ip. DCNL ensures floating ip is allocated to the project in context'
@wrap_check_policy DCNL @refresh_cache DCNL def disassociate_floating_ip(self, context, instance, address, affect_auto_assigned=False): DCNL 'Disassociates a floating ip from fixed ip it is associated with.'
@wrap_check_policy DCNL @refresh_cache DCNL def allocate_for_instance(self, context, instance, vpn, requested_networks, macs=None, conductor_api=None, security_groups=None, **kwargs): DCNL 'Allocates all network structures for an instance. DCNL TODO(someone): document the rest of these parameters. DCNL :param macs: None or a set of MAC addresses that the instance DCNL should use. macs is supplied by the hypervisor driver (contrast DCNL with requested_networks which is user supplied). DCNL NB: macs is ignored by nova-network. DCNL :returns: network info as from get_instance_nw_info() below'
@wrap_check_policy DCNL def deallocate_for_instance(self, context, instance, **kwargs): DCNL 'Deallocates all network structures related to instance.'
@wrap_check_policy DCNL @refresh_cache DCNL def add_fixed_ip_to_instance(self, context, instance, network_id, conductor_api=None, **kwargs): DCNL 'Adds a fixed ip to instance from specified network.'
@wrap_check_policy DCNL @refresh_cache DCNL def remove_fixed_ip_from_instance(self, context, instance, address, conductor=None, **kwargs): DCNL 'Removes a fixed ip from instance from specified network.'
@wrap_check_policy DCNL def add_network_to_project(self, context, project_id, network_uuid=None): DCNL 'Force adds another network to a project.'
@wrap_check_policy DCNL def associate(self, context, network_uuid, host=_sentinel, project=_sentinel): DCNL 'Associate or disassociate host or project to network.'
@wrap_check_policy DCNL def get_instance_nw_info(self, context, instance, conductor_api=None, **kwargs): DCNL 'Returns all network info related to an instance.'
def _get_instance_nw_info(self, context, instance): DCNL 'Returns all network info related to an instance.'
@wrap_check_policy DCNL def validate_networks(self, context, requested_networks): DCNL 'validate the networks passed at the time of creating DCNL the server'
@wrap_check_policy DCNL def get_instance_uuids_by_ip_filter(self, context, filters): DCNL 'Returns a list of dicts in the form of DCNL {\'instance_uuid\': uuid, \'ip\': ip} that matched the ip_filter'
@wrap_check_policy DCNL def get_dns_domains(self, context): DCNL 'Returns a list of available dns domains. DCNL These can be used to create DNS entries for floating ips.'
@wrap_check_policy DCNL def add_dns_entry(self, context, address, name, dns_type, domain): DCNL 'Create specified DNS entry for address.'
@wrap_check_policy DCNL def modify_dns_entry(self, context, name, address, domain): DCNL 'Create specified DNS entry for address.'
@wrap_check_policy DCNL def delete_dns_entry(self, context, name, domain): DCNL 'Delete the specified dns entry.'
@wrap_check_policy DCNL def delete_dns_domain(self, context, domain): DCNL 'Delete the specified dns domain.'
@wrap_check_policy DCNL def get_dns_entries_by_address(self, context, address, domain): DCNL 'Get entries for address and domain.'
@wrap_check_policy DCNL def get_dns_entries_by_name(self, context, name, domain): DCNL 'Get entries for name and domain.'
@wrap_check_policy DCNL def create_private_dns_domain(self, context, domain, availability_zone): DCNL 'Create a private DNS domain with nova availability zone.'
@wrap_check_policy DCNL def create_public_dns_domain(self, context, domain, project=None): DCNL 'Create a public DNS domain with optional nova project.'
@wrap_check_policy DCNL def setup_networks_on_host(self, context, instance, host=None, teardown=False): DCNL 'Setup or teardown the network structures on hosts related to DCNL instance'
@wrap_check_policy DCNL def migrate_instance_start(self, context, instance, migration): DCNL 'Start to migrate the network of an instance.'
@wrap_check_policy DCNL def migrate_instance_finish(self, context, instance, migration): DCNL 'Finish migrating the network of an instance.'
def add_chain(self, name, wrap=True): DCNL 'Adds a named chain to the table. DCNL The chain name is wrapped to be unique for the component creating DCNL it, so different components of Nova can safely create identically DCNL named chains without interfering with one another. DCNL At the moment, its wrapped name is <binary name>-<chain name>, DCNL so if nova-compute creates a chain named \'OUTPUT\', it\'ll actually DCNL end up named \'nova-compute-OUTPUT\'.'
def remove_chain(self, name, wrap=True): DCNL 'Remove named chain. DCNL This removal "cascades". All rule in the chain are removed, as are DCNL all rules in other chains that jump to it. DCNL If the chain is not found, this is merely logged.'
def add_rule(self, chain, rule, wrap=True, top=False): DCNL 'Add a rule to the table. DCNL This is just like what you\'d feed to iptables, just without DCNL the \'-A <chain name>\' bit at the start. DCNL However, if you need to jump to one of your wrapped chains, DCNL prepend its name with a \'$\' which will ensure the wrapping DCNL is applied correctly.'
def remove_rule(self, chain, rule, wrap=True, top=False): DCNL 'Remove a rule from a chain. DCNL Note: The rule must be exactly identical to the one that was added. DCNL You cannot switch arguments around like you can with the iptables DCNL CLI tool.'
def remove_rules_regex(self, regex): DCNL 'Remove all rules matching regex.'
def empty_chain(self, chain, wrap=True): DCNL 'Remove all rules from a chain.'
@lockutils.synchronized('iptables', 'nova-', external=True) DCNL def _apply(self): DCNL 'Apply the current in-memory set of iptables rules. DCNL This will blow away any rules left over from previous runs of the DCNL same component of Nova, and replace them with our current set of DCNL rules. This happens atomically, thanks to iptables-restore.'
def plug(self, network, mac_address): DCNL 'Create Linux device, return device name.'
def unplug(self, network): DCNL 'Destroy Linux device, return device name.'
def get_dev(self, network): DCNL 'Get device name.'
@classmethod DCNL def ensure_vlan_bridge(_self, vlan_num, bridge, bridge_interface, net_attrs=None, mac_address=None): DCNL 'Create a vlan and bridge unless they already exist.'
@classmethod DCNL def remove_vlan_bridge(cls, vlan_num, bridge): DCNL 'Delete a bridge and vlan.'
@classmethod DCNL @lockutils.synchronized('lock_vlan', 'nova-', external=True) DCNL def ensure_vlan(_self, vlan_num, bridge_interface, mac_address=None): DCNL 'Create a vlan unless it already exists.'
@classmethod DCNL @lockutils.synchronized('lock_vlan', 'nova-', external=True) DCNL def remove_vlan(cls, vlan_num): DCNL 'Delete a vlan.'
@classmethod DCNL @lockutils.synchronized('lock_bridge', 'nova-', external=True) DCNL def ensure_bridge(_self, bridge, interface, net_attrs=None, gateway=True, filtering=True): DCNL 'Create a bridge unless it already exists. DCNL :param interface: the interface to create the bridge on. DCNL :param net_attrs: dictionary with  attributes used to create bridge. DCNL :param gateway: whether or not the bridge is a gateway. DCNL :param filtering: whether or not to create filters on the bridge. DCNL If net_attrs is set, it will add the net_attrs[\'gateway\'] to the bridge DCNL using net_attrs[\'broadcast\'] and net_attrs[\'cidr\'].  It will also add DCNL the ip_v6 address specified in net_attrs[\'cidr_v6\'] if use_ipv6 is set. DCNL The code will attempt to move any ips that already exist on the DCNL interface onto the bridge and reset the default gateway if necessary.'
@classmethod DCNL @lockutils.synchronized('lock_bridge', 'nova-', external=True) DCNL def remove_bridge(cls, bridge, gateway=True, filtering=True): DCNL 'Delete a bridge.'
def init_host_floating_ips(self): DCNL 'Configures floating ips owned by host.'
def allocate_for_instance(self, context, **kwargs): DCNL 'Handles allocating the floating IP resources for an instance. DCNL calls super class allocate_for_instance() as well DCNL rpc.called by network_api'
def deallocate_for_instance(self, context, **kwargs): DCNL 'Handles deallocating floating IP resources for an instance. DCNL calls super class deallocate_for_instance() as well. DCNL rpc.called by network_api'
def _floating_ip_owned_by_project(self, context, floating_ip): DCNL 'Raises if floating ip does not belong to project.'
def allocate_floating_ip(self, context, project_id, auto_assigned=False, pool=None): DCNL 'Gets a floating ip from the pool.'
@rpc_common.client_exceptions(exception.FloatingIpNotFoundForAddress) DCNL def deallocate_floating_ip(self, context, address, affect_auto_assigned=False): DCNL 'Returns a floating ip to the pool.'
@rpc_common.client_exceptions(exception.FloatingIpNotFoundForAddress) DCNL def associate_floating_ip(self, context, floating_address, fixed_address, affect_auto_assigned=False): DCNL 'Associates a floating ip with a fixed ip. DCNL Makes sure everything makes sense then calls _associate_floating_ip, DCNL rpc\'ing to correct host if i\'m not it. DCNL Access to the floating_address is verified but access to the DCNL fixed_address is not verified. This assumes that that the calling DCNL side has already verified that the fixed_address is legal by DCNL checking access to the instance.'
def _associate_floating_ip(self, context, floating_address, fixed_address, interface, instance_uuid): DCNL 'Performs db and driver calls to associate floating ip & fixed ip.'
@rpc_common.client_exceptions(exception.FloatingIpNotFoundForAddress) DCNL def disassociate_floating_ip(self, context, address, affect_auto_assigned=False): DCNL 'Disassociates a floating ip from its fixed ip. DCNL Makes sure everything makes sense then calls _disassociate_floating_ip, DCNL rpc\'ing to correct host if i\'m not it.'
def _disassociate_floating_ip(self, context, address, interface, instance_uuid): DCNL 'Performs db and driver calls to disassociate floating ip.'
@rpc_common.client_exceptions(exception.FloatingIpNotFound) DCNL def get_floating_ip(self, context, id): DCNL 'Returns a floating IP as a dict.'
def get_floating_pools(self, context): DCNL 'Returns list of floating pools.'
def get_floating_ip_pools(self, context): DCNL 'Returns list of floating ip pools.'
def get_floating_ip_by_address(self, context, address): DCNL 'Returns a floating IP as a dict.'
def get_floating_ips_by_project(self, context): DCNL 'Returns the floating IPs allocated to a project.'
def get_floating_ips_by_fixed_address(self, context, fixed_address): DCNL 'Returns the floating IPs associated with a fixed_address.'
def _allocate_fixed_ips(self, context, instance_id, host, networks, **kwargs): DCNL 'Calls allocate_fixed_ip once for each network.'
def _rpc_allocate_fixed_ip(self, context, instance_id, network_id, **kwargs): DCNL 'Sits in between _allocate_fixed_ips and allocate_fixed_ip to DCNL perform network lookup on the far side of rpc.'
def deallocate_fixed_ip(self, context, address, host=None, teardown=True): DCNL 'Call the superclass deallocate_fixed_ip if i\'m the correct host DCNL otherwise call to the correct host'
@lockutils.synchronized('get_dhcp', 'nova-') DCNL def _get_dhcp_ip(self, context, network_ref, host=None): DCNL 'Get the proper dhcp address to listen on.'
def get_dhcp_leases(self, ctxt, network_ref): DCNL 'Broker the request to the driver to fetch the dhcp leases.'
def init_host(self): DCNL 'Do any initialization that needs to be run if this is a DCNL standalone service.'
def set_network_host(self, context, network_ref): DCNL 'Safely sets the host of the network.'
def _get_networks_for_instance(self, context, instance_id, project_id, requested_networks=None): DCNL 'Determine & return which networks an instance should connect to.'
def allocate_for_instance(self, context, **kwargs): DCNL 'Handles allocating the various network resources for an instance. DCNL rpc.called by network_api'
def deallocate_for_instance(self, context, **kwargs): DCNL 'Handles deallocating various network resources for an instance. DCNL rpc.called by network_api DCNL kwargs can contain fixed_ips to circumvent another db lookup'
def get_instance_nw_info(self, context, instance_id, rxtx_factor, host, instance_uuid=None, **kwargs): DCNL 'Creates network info list for instance. DCNL called by allocate_for_instance and network_api DCNL context needs to be elevated DCNL :returns: network info list [(network,info),(network,info)...] DCNL where network = dict containing pertinent data from a network db object DCNL and info = dict containing pertinent networking data'
def build_network_info_model(self, context, vifs, networks, rxtx_factor, instance_host): DCNL 'Builds a NetworkInfo object containing all network information DCNL for an instance'
def _get_network_dict(self, network): DCNL 'Returns the dict representing necessary and meta network fields.'
def _get_subnets_from_network(self, context, network, vif, instance_host=None): DCNL 'Returns the 1 or 2 possible subnets for a nova network.'
def _allocate_mac_addresses(self, context, instance_uuid, networks, macs): DCNL 'Generates mac addresses and creates vif rows in db for them.'
def add_fixed_ip_to_instance(self, context, instance_id, host, network_id, rxtx_factor=None): DCNL 'Adds a fixed ip to an instance from specified network.'
def get_backdoor_port(self, context): DCNL 'Return backdoor port for eventlet_backdoor.'
def remove_fixed_ip_from_instance(self, context, instance_id, host, address, rxtx_factor=None): DCNL 'Removes a fixed ip from an instance from specified network.'
def allocate_fixed_ip(self, context, instance_id, network, **kwargs): DCNL 'Gets a fixed ip from the pool.'
def deallocate_fixed_ip(self, context, address, host=None, teardown=True): DCNL 'Returns a fixed ip to the pool.'
def lease_fixed_ip(self, context, address): DCNL 'Called by dhcp-bridge when ip is leased.'
def release_fixed_ip(self, context, address): DCNL 'Called by dhcp-bridge when ip is released.'
def _do_create_networks(self, context, label, cidr, multi_host, num_networks, network_size, cidr_v6, gateway, gateway_v6, bridge, bridge_interface, dns1=None, dns2=None, fixed_cidr=None, **kwargs): DCNL 'Create networks based on parameters.'
@property DCNL def _bottom_reserved_ips(self): DCNL 'Number of reserved ips at the bottom of the range.'
@property DCNL def _top_reserved_ips(self): DCNL 'Number of reserved ips at the top of the range.'
def _create_fixed_ips(self, context, network_id, fixed_cidr=None): DCNL 'Create all fixed ips for network.'
def _allocate_fixed_ips(self, context, instance_id, host, networks, **kwargs): DCNL 'Calls allocate_fixed_ip once for each network.'
def setup_networks_on_host(self, context, instance_id, host, teardown=False): DCNL 'calls setup/teardown on network hosts for an instance.'
def _setup_network_on_host(self, context, network): DCNL 'Sets up network on this host.'
def _teardown_network_on_host(self, context, network): DCNL 'Sets up network on this host.'
def validate_networks(self, context, networks): DCNL 'check if the networks exists and host DCNL is set to each network.'
def get_vifs_by_instance(self, context, instance_id): DCNL 'Returns the vifs associated with an instance.'
def get_instance_id_by_floating_address(self, context, address): DCNL 'Returns the instance id a floating ip\'s fixed ip is allocated to.'
def get_fixed_ip(self, context, id): DCNL 'Return a fixed ip.'
def get_vif_by_mac_address(self, context, mac_address): DCNL 'Returns the vifs record for the mac_address.'
@manager.periodic_task(spacing=CONF.dns_update_periodic_interval) DCNL def _periodic_update_dns(self, context): DCNL 'Update local DNS entries of all networks on this host.'
def update_dns(self, context, network_ids): DCNL 'Called when fixed IP is allocated or deallocated.'
def _allocate_fixed_ips(self, context, instance_id, host, networks, **kwargs): DCNL 'Calls allocate_fixed_ip once for each network.'
def deallocate_fixed_ip(self, context, address, host=None, teardown=True): DCNL 'Returns a fixed ip to the pool.'
def _setup_network_on_host(self, context, network): DCNL 'Setup Network on this host.'
def _teardown_network_on_host(self, context, network): DCNL 'Tear down network on this host.'
def get_floating_ip(self, context, id): DCNL 'Returns a floating IP as a dict.'
def get_floating_pools(self, context): DCNL 'Returns list of floating pools.'
def get_floating_ip_pools(self, context): DCNL 'Returns list of floating ip pools.'
def get_floating_ip_by_address(self, context, address): DCNL 'Returns a floating IP as a dict.'
def get_floating_ips_by_project(self, context): DCNL 'Returns the floating IPs allocated to a project.'
def get_floating_ips_by_fixed_address(self, context, fixed_address): DCNL 'Returns the floating IPs associated with a fixed_address.'
@network_api.wrap_check_policy DCNL def allocate_floating_ip(self, context, project_id, pool): DCNL 'Gets a floating ip from the pool.'
@network_api.wrap_check_policy DCNL def deallocate_floating_ip(self, context, address, affect_auto_assigned): DCNL 'Returns a floating ip to the pool.'
@network_api.wrap_check_policy DCNL def associate_floating_ip(self, context, floating_address, fixed_address, affect_auto_assigned=False): DCNL 'Associates a floating ip with a fixed ip. DCNL Makes sure everything makes sense then calls _associate_floating_ip, DCNL rpc\'ing to correct host if i\'m not it.'
@network_api.wrap_check_policy DCNL def disassociate_floating_ip(self, context, address, affect_auto_assigned=False): DCNL 'Disassociates a floating ip from its fixed ip. DCNL Makes sure everything makes sense then calls _disassociate_floating_ip, DCNL rpc\'ing to correct host if i\'m not it.'
def update_dns(self, context, network_ids): DCNL 'Called when fixed IP is allocated or deallocated.'
def init_host(self): DCNL 'Do any initialization that needs to be run if this is a DCNL standalone service.'
def _setup_network_on_host(self, context, network): DCNL 'Sets up network on this host.'
def _get_network_dict(self, network): DCNL 'Returns the dict representing necessary and meta network fields.'
def init_host(self): DCNL 'Do any initialization that needs to be run if this is a DCNL standalone service.'
def allocate_fixed_ip(self, context, instance_id, network, **kwargs): DCNL 'Gets a fixed ip from the pool.'
def add_network_to_project(self, context, project_id, network_uuid=None): DCNL 'Force adds another network to a project.'
def associate(self, context, network_uuid, associations): DCNL 'Associate or disassociate host or project to network.'
def _get_networks_for_instance(self, context, instance_id, project_id, requested_networks=None): DCNL 'Determine which networks an instance should connect to.'
def create_networks(self, context, **kwargs): DCNL 'Create networks based on parameters.'
@lockutils.synchronized('setup_network', 'nova-', external=True) DCNL def _setup_network_on_host(self, context, network): DCNL 'Sets up network on this host.'
def _get_network_dict(self, network): DCNL 'Returns the dict representing necessary and meta network fields.'
@property DCNL def _bottom_reserved_ips(self): DCNL 'Number of reserved ips at the bottom of the range.'
@property DCNL def _top_reserved_ips(self): DCNL 'Number of reserved ips at the top of the range.'
def initialize(self, **kwargs): DCNL 'Set up basic L3 networking functionality.'
def initialize_network(self, network): DCNL 'Enable rules for a specific network.'
def initialize_gateway(self, network): DCNL 'Set up a gateway on this network.'
def remove_gateway(self, network_ref): DCNL 'Remove an existing gateway on this network.'
def is_initialized(self): DCNL ':returns: True/False (whether the driver is initialized).'
def add_floating_ip(self, floating_ip, fixed_ip, l3_interface_id, network=None): DCNL 'Add a floating IP bound to the fixed IP with an optional DCNL l3_interface_id.  Some drivers won\'t care about the DCNL l3_interface_id so just pass None in that case. Network DCNL is also an optional parameter.'
def _get_available_networks(self, context, project_id, net_ids=None): DCNL 'Return a network list available for the tenant. DCNL The list contains networks owned by the tenant and public networks. DCNL If net_ids specified, it searches networks with requested IDs only.'
@refresh_cache DCNL def allocate_for_instance(self, context, instance, **kwargs): DCNL 'Allocate network resources for the instance. DCNL TODO(someone): document the rest of these parameters. DCNL :param macs: None or a set of MAC addresses that the instance DCNL should use. macs is supplied by the hypervisor driver (contrast DCNL with requested_networks which is user supplied). DCNL NB: QuantumV2 currently assigns hypervisor supplied MAC addresses DCNL to arbitrary networks, which requires openflow switches to DCNL function correctly if more than one network is being used with DCNL the bare metal hypervisor (which is the only one known to limit DCNL MAC addresses).'
def deallocate_for_instance(self, context, instance, **kwargs): DCNL 'Deallocate all network resources related to the instance.'
@refresh_cache DCNL def add_fixed_ip_to_instance(self, context, instance, network_id, conductor_api=None): DCNL 'Add a fixed ip to the instance from specified network.'
@refresh_cache DCNL def remove_fixed_ip_from_instance(self, context, instance, address, conductor_api=None): DCNL 'Remove a fixed ip from the instance.'
def validate_networks(self, context, requested_networks): DCNL 'Validate that the tenant can use the requested networks.'
def _get_instance_uuids_by_ip(self, context, address): DCNL 'Retrieve instance uuids associated with the given ip address. DCNL :returns: A list of dicts containing the uuids keyed by \'instance_uuid\' DCNL e.g. [{\'instance_uuid\': uuid}, ...]'
def get_instance_uuids_by_ip_filter(self, context, filters): DCNL 'Return a list of dicts in the form of DCNL [{\'instance_uuid\': uuid}] that matched the ip filter.'
@refresh_cache DCNL def associate_floating_ip(self, context, instance, floating_address, fixed_address, affect_auto_assigned=False): DCNL 'Associate a floating ip with a fixed ip.'
def get_instance_id_by_floating_address(self, context, address): DCNL 'Returns the instance id a floating ip\'s fixed ip is allocated to.'
def allocate_floating_ip(self, context, pool=None): DCNL 'Add a floating ip to a project from a pool.'
def _get_floating_ip_by_address(self, client, address): DCNL 'Get floatingip from floating ip address.'
def _get_floating_ips_by_fixed_and_port(self, client, fixed_ip, port): DCNL 'Get floatingips from fixed ip and port.'
def release_floating_ip(self, context, address, affect_auto_assigned=False): DCNL 'Remove a floating ip with the given address from a project.'
@refresh_cache DCNL def disassociate_floating_ip(self, context, instance, address, affect_auto_assigned=False): DCNL 'Disassociate a floating ip from the instance.'
def migrate_instance_start(self, context, instance, migration): DCNL 'Start to migrate the network of an instance.'
def migrate_instance_finish(self, context, instance, migration): DCNL 'Finish migrating the network of an instance.'
def add_network_to_project(self, context, project_id, network_uuid=None): DCNL 'Force add a network to the project.'
def _get_subnets_from_port(self, context, port): DCNL 'Return the subnets for a given port.'
def get_dns_domains(self, context): DCNL 'Return a list of available dns domains. DCNL These can be used to create DNS entries for floating ips.'
def add_dns_entry(self, context, address, name, dns_type, domain): DCNL 'Create specified DNS entry for address.'
def modify_dns_entry(self, context, name, address, domain): DCNL 'Create specified DNS entry for address.'
def delete_dns_entry(self, context, name, domain): DCNL 'Delete the specified dns entry.'
def delete_dns_domain(self, context, domain): DCNL 'Delete the specified dns domain.'
def get_dns_entries_by_address(self, context, address, domain): DCNL 'Get entries for address and domain.'
def get_dns_entries_by_name(self, context, name, domain): DCNL 'Get entries for name and domain.'
def create_private_dns_domain(self, context, domain, availability_zone): DCNL 'Create a private DNS domain with nova availability zone.'
def create_public_dns_domain(self, context, domain, project=None): DCNL 'Create a private DNS domain with optional nova project.'
def get_meta(self, key, default=None): DCNL 'calls get(key, default) on self[\'meta\'].'
def as_netaddr(self): DCNL 'Convience function to get cidr as a netaddr object.'
def labeled_ips(self): DCNL 'Returns the list of all IPs DCNL The return value looks like this flat structure:: DCNL {\'network_label\': \'my_network\', DCNL \'network_id\': \'n8v29837fn234782f08fjxk3ofhb84\', DCNL \'ips\': [{\'address\': \'123.123.123.123\', DCNL \'version\': 4, DCNL \'type: \'fixed\', DCNL \'meta\': {...}}, DCNL {\'address\': \'124.124.124.124\', DCNL \'version\': 4, DCNL \'type\': \'floating\', DCNL \'meta\': {...}}, DCNL {\'address\': \'fe80::4\', DCNL \'version\': 6, DCNL \'type\': \'fixed\', DCNL \'meta\': {...}}]'
def fixed_ips(self): DCNL 'Returns all fixed_ips without floating_ips attached.'
def floating_ips(self): DCNL 'Returns all floating_ips.'
def legacy(self): DCNL 'Return the legacy network_info representation of self'
def list(self, context, names=None, ids=None, project=None, search_opts=None): DCNL 'Returns list of security group rules owned by tenant.'
def destroy(self, context, security_group): DCNL 'This function deletes a security group.'
def add_rules(self, context, id, name, vals): DCNL 'Add security group rule(s) to security group. DCNL Note: the Nova security group API doesn\'t support adding muliple DCNL security group rules at once but the EC2 one does. Therefore, DCNL this function is writen to support both. Multiple rules are DCNL installed to a security group in quantum using bulk support.'
def get_instances_security_groups_bindings(self, context): DCNL 'Returns a dict(instance_id, [security_groups]) to allow obtaining DCNL all of the instances and their security groups in one shot.'
def get_instance_security_groups(self, context, instance_id, instance_uuid=None, detailed=False): DCNL 'Returns the security groups that are associated with an instance. DCNL If detailed is True then it also returns the full details of the DCNL security groups associated with an instance.'
@wrap_check_security_groups_policy DCNL def add_to_instance(self, context, instance, security_group_name): DCNL 'Add security group to the instance.'
@wrap_check_security_groups_policy DCNL def remove_from_instance(self, context, instance, security_group_name): DCNL 'Remove the security group associated with the instance.'
def rule_exists(self, security_group, new_rule): DCNL 'Indicates whether the specified rule is already DCNL defined in the given security group.'
def trigger_rules_refresh(self, context, id): DCNL 'Called when a rule is added to or removed from a security_group.'
def trigger_members_refresh(self, context, group_ids): DCNL 'Called when a security group gains a new or loses a member. DCNL Sends an update request to each compute node for each instance for DCNL which this is relevant.'
def populate_security_groups(self, instance, security_groups): DCNL 'Called when populating the database for an instances DCNL security groups.'
@wrap_check_policy DCNL def allocate_floating_ip(self, context, pool=None): DCNL 'Adds (allocates) a floating ip to a project from a pool.'
@wrap_check_policy DCNL def release_floating_ip(self, context, address, affect_auto_assigned=False): DCNL 'Removes (deallocates) a floating ip with address from a project.'
@wrap_check_policy DCNL @refresh_cache DCNL def associate_floating_ip(self, context, instance, floating_address, fixed_address, affect_auto_assigned=False): DCNL 'Associates a floating ip with a fixed ip. DCNL Ensures floating ip is allocated to the project in context. DCNL Does not verify ownership of the fixed ip. Caller is assumed to have DCNL checked that the instance is properly owned.'
@wrap_check_policy DCNL @refresh_cache DCNL def disassociate_floating_ip(self, context, instance, address, affect_auto_assigned=False): DCNL 'Disassociates a floating ip from fixed ip it is associated with.'
@wrap_check_policy DCNL @refresh_cache DCNL def allocate_for_instance(self, context, instance, vpn, requested_networks, macs=None, conductor_api=None, security_groups=None): DCNL 'Allocates all network structures for an instance. DCNL TODO(someone): document the rest of these parameters. DCNL :param macs: None or a set of MAC addresses that the instance DCNL should use. macs is supplied by the hypervisor driver (contrast DCNL with requested_networks which is user supplied). DCNL :returns: network info as from get_instance_nw_info() below'
@wrap_check_policy DCNL def deallocate_for_instance(self, context, instance): DCNL 'Deallocates all network structures related to instance.'
@wrap_check_policy DCNL @refresh_cache DCNL def add_fixed_ip_to_instance(self, context, instance, network_id, conductor_api=None): DCNL 'Adds a fixed ip to instance from specified network.'
@wrap_check_policy DCNL @refresh_cache DCNL def remove_fixed_ip_from_instance(self, context, instance, address, conductor_api=None): DCNL 'Removes a fixed ip from instance from specified network.'
@wrap_check_policy DCNL def add_network_to_project(self, context, project_id, network_uuid=None): DCNL 'Force adds another network to a project.'
@wrap_check_policy DCNL def associate(self, context, network_uuid, host=_sentinel, project=_sentinel): DCNL 'Associate or disassociate host or project to network.'
@wrap_check_policy DCNL def get_instance_nw_info(self, context, instance, conductor_api=None): DCNL 'Returns all network info related to an instance.'
def _get_instance_nw_info(self, context, instance): DCNL 'Returns all network info related to an instance.'
@wrap_check_policy DCNL def validate_networks(self, context, requested_networks): DCNL 'validate the networks passed at the time of creating DCNL the server'
@wrap_check_policy DCNL def get_instance_uuids_by_ip_filter(self, context, filters): DCNL 'Returns a list of dicts in the form of DCNL {\'instance_uuid\': uuid, \'ip\': ip} that matched the ip_filter'
@wrap_check_policy DCNL def get_dns_domains(self, context): DCNL 'Returns a list of available dns domains. DCNL These can be used to create DNS entries for floating ips.'
@wrap_check_policy DCNL def add_dns_entry(self, context, address, name, dns_type, domain): DCNL 'Create specified DNS entry for address.'
@wrap_check_policy DCNL def modify_dns_entry(self, context, name, address, domain): DCNL 'Create specified DNS entry for address.'
@wrap_check_policy DCNL def delete_dns_entry(self, context, name, domain): DCNL 'Delete the specified dns entry.'
@wrap_check_policy DCNL def delete_dns_domain(self, context, domain): DCNL 'Delete the specified dns domain.'
@wrap_check_policy DCNL def get_dns_entries_by_address(self, context, address, domain): DCNL 'Get entries for address and domain.'
@wrap_check_policy DCNL def get_dns_entries_by_name(self, context, name, domain): DCNL 'Get entries for name and domain.'
@wrap_check_policy DCNL def create_private_dns_domain(self, context, domain, availability_zone): DCNL 'Create a private DNS domain with nova availability zone.'
@wrap_check_policy DCNL def create_public_dns_domain(self, context, domain, project=None): DCNL 'Create a public DNS domain with optional nova project.'
@wrap_check_policy DCNL def setup_networks_on_host(self, context, instance, host=None, teardown=False): DCNL 'Setup or teardown the network structures on hosts related to DCNL instance'
@wrap_check_policy DCNL def migrate_instance_start(self, context, instance, migration): DCNL 'Start to migrate the network of an instance.'
@wrap_check_policy DCNL def migrate_instance_finish(self, context, instance, migration): DCNL 'Finish migrating the network of an instance.'
def __init__(self, ldap_object): DCNL 'ldap_object is an instance of ldap.LDAPObject. DCNL It should already be initialized and bound before DCNL getting passed in here.'
@classmethod DCNL def create_domain(cls, lobj, domain): DCNL 'Create a new domain entry, and return an object that wraps it.'
def delete(self): DCNL 'Delete the domain that this entry refers to.'
def trigger_security_group_create_refresh(self, context, group): DCNL 'Called when a security group is created DCNL :param context: the security context. DCNL :param group: the new group added. group is a dictionary that contains DCNL the following: user_id, project_id, name, description).'
def trigger_security_group_destroy_refresh(self, context, security_group_id): DCNL 'Called when a security group is deleted DCNL :param context: the security context. DCNL :param security_group_id: the security group identifier.'
def trigger_security_group_rule_create_refresh(self, context, rule_ids): DCNL 'Called when a rule is added to a security_group. DCNL :param context: the security context. DCNL :param rule_ids: a list of rule ids that have been affected.'
def trigger_security_group_rule_destroy_refresh(self, context, rule_ids): DCNL 'Called when a rule is removed from a security_group. DCNL :param context: the security context. DCNL :param rule_ids: a list of rule ids that have been affected.'
def trigger_instance_add_security_group_refresh(self, context, instance, group_name): DCNL 'Called when a security group gains a new member. DCNL :param context: the security context. DCNL :param instance: the instance to be associated. DCNL :param group_name: the name of the security group to be associated.'
def trigger_instance_remove_security_group_refresh(self, context, instance, group_name): DCNL 'Called when a security group loses a member. DCNL :param context: the security context. DCNL :param instance: the instance to be associated. DCNL :param group_name: the name of the security group to be associated.'
def trigger_security_group_members_refresh(self, context, group_ids): DCNL 'Called when a security group gains or loses a member. DCNL :param context: the security context. DCNL :param group_ids: a list of security group identifiers.'
def trigger_security_group_create_refresh(self, context, group): DCNL 'Called when a rule is added to a security_group. DCNL :param context: the security context. DCNL :param group: the new group added. group is a dictionary that contains DCNL the following: user_id, project_id, name, description).'
def trigger_security_group_destroy_refresh(self, context, security_group_id): DCNL 'Called when a rule is added to a security_group. DCNL :param context: the security context. DCNL :param security_group_id: the security group identifier.'
def trigger_security_group_rule_create_refresh(self, context, rule_ids): DCNL 'Called when a rule is added to a security_group. DCNL :param context: the security context. DCNL :param rule_ids: a list of rule ids that have been affected.'
def trigger_security_group_rule_destroy_refresh(self, context, rule_ids): DCNL 'Called when a rule is removed from a security_group. DCNL :param context: the security context. DCNL :param rule_ids: a list of rule ids that have been affected.'
def trigger_instance_add_security_group_refresh(self, context, instance, group_name): DCNL 'Called when a security group gains a new member. DCNL :param context: the security context. DCNL :param instance: the instance to be associated. DCNL :param group_name: the name of the security group to be associated.'
def trigger_instance_remove_security_group_refresh(self, context, instance, group_name): DCNL 'Called when a security group loses a member. DCNL :param context: the security context. DCNL :param instance: the instance to be associated. DCNL :param group_name: the name of the security group to be associated.'
def trigger_security_group_members_refresh(self, context, group_ids): DCNL 'Called when a security group gains or loses a member. DCNL :param context: the security context. DCNL :param group_ids: a list of security group identifiers.'
def one_way_proxy(self, source, dest): DCNL 'Proxy tcp connection from source to dest.'
def handshake(self, req, connect_info, sockets): DCNL 'Execute hypervisor-specific vnc auth handshaking (if needed).'
def proxy_connection(self, req, connect_info, start_response): DCNL 'Spawn bi-directional vnc proxy.'
def supported(cls, stream=sys.stdout): DCNL 'A class method that returns True if the current platform supports DCNL coloring terminal output using this method. Returns False otherwise.'
def write(self, text, color): DCNL 'Write the given text to the stream in the given color. DCNL @param text: Text to be written to the stream. DCNL @param color: A string label for a color. e.g. \'red\', \'white\'.'
def addError(self, test, err): DCNL 'Overrides normal addError to add support for DCNL errorClasses. If the exception is a registered class, the DCNL error will be added to the list for that class, not errors.'
def can_ping(self, ip, command='ping'): DCNL 'Attempt to ping the specified IP, and give up after 1 second.'
def wait_for_running(self, instance, tries=60, wait=1): DCNL 'Wait for instance to be running.'
def wait_for_deleted(self, instance, tries=60, wait=1): DCNL 'Wait for instance to be deleted.'
def wait_for_ping(self, ip, command='ping', tries=120): DCNL 'Wait for ip to be pingable.'
def wait_for_ssh(self, ip, key_name, tries=30, wait=5): DCNL 'Wait for ip to be sshable.'
def connection_for_env(self, **kwargs): DCNL 'Returns a boto ec2 connection for the current environment.'
def split_clc_url(self, clc_url): DCNL 'Splits a cloud controller endpoint url.'
def get_all_instances(self, instance_ids=None, filters=None): DCNL 'Retrieve all the instances associated with your account. DCNL :type instance_ids: list DCNL :param instance_ids: A list of strings of instance IDs DCNL :type filters: dict DCNL :param filters: Optional filters that can be used to limit DCNL the results returned.  Filters are provided DCNL in the form of a dictionary consisting of DCNL filter names as the key and filter values DCNL as the value.  The set of allowable filter DCNL names/values is dependent on the request DCNL being performed.  Check the EC2 API guide DCNL for details. DCNL :rtype: list DCNL :return: A list of  :class:`boto.ec2.instance.Reservation`'
def run_instances(self, image_id, min_count=1, max_count=1, key_name=None, security_groups=None, user_data=None, addressing_type=None, instance_type='m1.small', placement=None, kernel_id=None, ramdisk_id=None, monitoring_enabled=False, subnet_id=None, block_device_map=None): DCNL 'Runs an image on EC2. DCNL :type image_id: string DCNL :param image_id: The ID of the image to run DCNL :type min_count: int DCNL :param min_count: The minimum number of instances to launch DCNL :type max_count: int DCNL :param max_count: The maximum number of instances to launch DCNL :type key_name: string DCNL :param key_name: The name of the key pair with which to DCNL launch instances DCNL :type security_groups: list of strings DCNL :param security_groups: The names of the security groups with DCNL which to associate instances DCNL :type user_data: string DCNL :param user_data: The user data passed to the launched instances DCNL :type instance_type: string DCNL :param instance_type: The type of instance to run DCNL (m1.small, m1.large, m1.xlarge) DCNL :type placement: string DCNL :param placement: The availability zone in which to launch DCNL the instances DCNL :type kernel_id: string DCNL :param kernel_id: The ID of the kernel with which to DCNL launch the instances DCNL :type ramdisk_id: string DCNL :param ramdisk_id: The ID of the RAM disk with which to DCNL launch the instances DCNL :type monitoring_enabled: bool DCNL :param monitoring_enabled: Enable CloudWatch monitoring DCNL on the instance. DCNL :type subnet_id: string DCNL :param subnet_id: The subnet ID within which to launch DCNL the instances for VPC. DCNL :type block_device_map: DCNL :class:`boto.ec2.blockdevicemapping.BlockDeviceMapping` DCNL :param block_device_map: A BlockDeviceMapping data structure DCNL describing the EBS volumes associated DCNL with the Image. DCNL :rtype: Reservation DCNL :return: The :class:`boto.ec2.instance.ReservationV6` DCNL associated with the request for machines'
def started(self): DCNL 'Called after Websockets server startup (i.e. after daemonize)'
def new_client(self): DCNL 'Called after a new WebSocket connection has been established.'
def get_target(self, target_cfg, path): DCNL 'Parses the path, extracts a token, and looks for a valid DCNL target for that token in the configuration file(s). Sets DCNL target_host and target_port if successful'
def do_proxy(self, target): DCNL 'Proxy client WebSocket to normal target socket.'
@staticmethod DCNL def socket(host, port=None, connect=False, prefer_ipv6=False, unix_socket=None, use_ssl=False): DCNL 'Resolve a host (and optional port) to an IPv4 or IPv6 DCNL address. Create a socket. Bind to it if listen is set, DCNL otherwise connect to it. Return the socket.'
@staticmethod DCNL def encode_hybi(buf, opcode, base64=False): DCNL 'Encode a HyBi style WebSocket frame. DCNL Optional opcode: DCNL 0x0 - continuation DCNL 0x1 - text frame (base64 encode buf) DCNL 0x2 - binary frame (use raw buf) DCNL 0x8 - connection close DCNL 0x9 - ping DCNL 0xA - pong'
@staticmethod DCNL def decode_hybi(buf, base64=False): DCNL 'Decode HyBi style WebSocket packets. DCNL Returns: DCNL {\'fin\'          : 0_or_1, DCNL \'opcode\'       : number, DCNL \'masked\'       : boolean, DCNL \'hlen\'         : header_bytes_number, DCNL \'length\'       : payload_bytes_number, DCNL \'payload\'      : decoded_buffer, DCNL \'left\'         : bytes_left_number, DCNL \'close_code\'   : number, DCNL \'close_reason\' : string}'
@staticmethod DCNL def gen_md5(keys): DCNL 'Generate hash value for WebSockets hixie-76.'
def traffic(self, token='.'): DCNL 'Show traffic flow in verbose mode.'
def msg(self, msg): DCNL 'Output message with handler_id prefix.'
def vmsg(self, msg): DCNL 'Same as msg() but only if verbose.'
def send_frames(self, bufs=None): DCNL 'Encode and send WebSocket frames. Any frames already DCNL queued will be sent first. If buf is not set then only queued DCNL frames will be sent. Returns the number of pending frames that DCNL could not be fully sent. If returned pending frames is greater DCNL than 0, then the caller should call again when the socket is DCNL ready.'
def recv_frames(self): DCNL 'Receive and decode WebSocket frames. DCNL Returns: DCNL (bufs_list, closed_string)'
def send_close(self, code=1000, reason=''): DCNL 'Send a WebSocket orderly close frame.'
def do_handshake(self, sock, address): DCNL 'do_handshake does the following: DCNL - Peek at the first few bytes from the socket. DCNL - If the connection is Flash policy request then answer it, DCNL close the socket and return. DCNL - If the connection is an HTTPS/SSL/TLS connection then SSL DCNL wrap the socket. DCNL - Read from the (possibly wrapped) socket. DCNL - If we have received a HTTP GET request and the webserver DCNL functionality is enabled, answer it, close the socket and DCNL return. DCNL - Assume we have a WebSockets connection, parse the client DCNL handshake data. DCNL - Send a WebSockets handshake server response. DCNL - Return the socket for this WebSocket client.'
def started(self): DCNL 'Called after WebSockets startup'
def poll(self): DCNL 'Run periodically while waiting for connections.'
def top_new_client(self, startsock, address): DCNL 'Do something with a WebSockets client connection.'
def new_client(self): DCNL 'Do something with a WebSockets client connection.'
def start_server(self): DCNL 'Daemonize if requested. Listen for for connections. Run DCNL do_handshake() method for each connection. If the connection DCNL is a WebSockets client then call new_client() method (which must DCNL be overridden) for each new client connection.'
def started(self): DCNL 'Called after Websockets server startup (i.e. after daemonize)'
def new_client(self): DCNL 'Called after a new WebSocket connection has been established.'
def get_target(self, target_cfg, path): DCNL 'Parses the path, extracts a token, and looks for a valid DCNL target for that token in the configuration file(s). Sets DCNL target_host and target_port if successful'
def do_proxy(self, target): DCNL 'Proxy client WebSocket to normal target socket.'
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True): DCNL 'Runs a command in an out-of-process shell. DCNL Returns the output of that command. Working directory is self.root.'
def create_virtualenv(self, no_site_packages=True): DCNL 'Creates the virtual environment and installs PIP. DCNL Creates the virtual environment and installs PIP only into the DCNL virtual environment.'
def parse_args(self, argv): DCNL 'Parses command-line arguments.'
def post_process(self): DCNL 'Any distribution-specific post-processing gets done here. DCNL In particular, this is useful for applying patches to code inside DCNL the venv.'
def post_process(self): DCNL 'Workaround for a bug in eventlet. DCNL This currently affects RHEL6.1, but the fix can safely be DCNL applied to all RHEL and Fedora distributions. DCNL This can be removed when the fix is applied upstream. DCNL Nova: https://bugs.launchpad.net/nova/+bug/884915 DCNL Upstream: https://bitbucket.org/which_linden/eventlet/issue/89'
def supported(cls, stream=sys.stdout): DCNL 'A class method that returns True if the current platform supports DCNL coloring terminal output using this method. Returns False otherwise.'
def write(self, text, color): DCNL 'Write the given text to the stream in the given color. DCNL @param text: Text to be written to the stream. DCNL @param color: A string label for a color. e.g. \'red\', \'white\'.'
def addError(self, test, err): DCNL 'Overrides normal addError to add support for errorClasses. DCNL If the exception is a registered class, the error will be added DCNL to the list for that class, not errors.'
def _notification_host(self, context, method, payload, host): DCNL 'Notify the agent that is hosting the router'
def _agent_notification(self, context, method, routers, operation, data): DCNL 'Notify changed routers to hosting l3 agents. DCNL Adjust routers according to l3 agents\' role and DCNL related dhcp agents. DCNL Notify dhcp agent to get right subnet\'s gateway ips.'
def _notification(self, context, method, routers, operation, data): DCNL 'Notify all the agents that are hosting the routers'
def _notification_fanout(self, context, method, router_id): DCNL 'Fanout the deleted router to all L3 agents'
def _notification_host(self, context, method, payload, host): DCNL 'Notify the agent on host'
def _notification(self, context, method, payload, network_id): DCNL 'Notify all the agents that are hosting the network'
def _notification_fanout(self, context, method, payload): DCNL 'Fanout the payload to all dhcp agents'
@classmethod DCNL def __subclasshook__(cls, klass): DCNL 'The __subclasshook__ method is a class method DCNL that will be called everytime a class is tested DCNL using issubclass(klass, PluginInterface). DCNL In that case, it will check that every method DCNL marked with the abstractmethod decorator is DCNL provided by the plugin class.'
def get_name(self): DCNL 'The name of the extension. DCNL e.g. \'Fox In Socks\''
def get_alias(self): DCNL 'The alias for the extension. DCNL e.g. \'FOXNSOX\''
def get_description(self): DCNL 'Friendly description for the extension. DCNL e.g. \'The Fox In Socks Extension\''
def get_namespace(self): DCNL 'The XML namespace for the extension. DCNL e.g. \'http://www.fox.in.socks/api/ext/pie/v1.0\''
def get_updated(self): DCNL 'The timestamp when the extension was last updated. DCNL e.g. \'2011-01-22T13:25:27-06:00\''
def get_resources(self): DCNL 'List of extensions.ResourceExtension extension objects. DCNL Resources define new nouns, and are accessible through URLs.'
def get_actions(self): DCNL 'List of extensions.ActionExtension extension objects. DCNL Actions are verbs callable from the API.'
def get_request_extensions(self): DCNL 'List of extensions.RequestException extension objects. DCNL Request extensions are used to handle custom request data.'
def get_extended_resources(self, version): DCNL 'retrieve extended resources or attributes for core resources. DCNL Extended attributes are implemented by a core plugin similarly DCNL to the attributes defined in the core, and can appear in DCNL request and response messages. Their names are scoped with the DCNL extension\'s prefix. The core API version is passed to this DCNL function, which must return a DCNL map[<resource_name>][<attribute_name>][<attribute_property>] DCNL specifying the extended resource attribute properties required DCNL by that API version. DCNL Extension can add resources and their attr definitions too. DCNL The returned map can be integrated into RESOURCE_ATTRIBUTE_MAP.'
def get_plugin_interface(self): DCNL 'Returns an abstract class which defines contract for the plugin. DCNL The abstract class should inherit from extesnions.PluginInterface, DCNL Methods in this abstract class  should be decorated as abstractmethod'
def update_attributes_map(self, extended_attributes, extension_attrs_map=None): DCNL 'Update attributes map for this extension DCNL This is default method for extending an extension\'s attributes map. DCNL An extension can use this method and supplying its own resource DCNL attribute map in extension_attrs_map argument to extend all its DCNL attributes that needs to be extended. DCNL If an extension does not implement update_attributes_map, the method DCNL does nothing and just return.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Paste factory.'
def _action_ext_controllers(self, application, ext_mgr, mapper): DCNL 'Return a dict of ActionExtensionController-s by collection.'
def _request_ext_controllers(self, application, ext_mgr, mapper): DCNL 'Returns a dict of RequestExtensionController-s by collection.'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req): DCNL 'Route the incoming request with router.'
@staticmethod DCNL @webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def _dispatch(req): DCNL 'Dispatch the request. DCNL Returns the routed WSGI app\'s response or defers to the extended DCNL application.'
def get_resources(self): DCNL 'Returns a list of ResourceExtension objects.'
def get_actions(self): DCNL 'Returns a list of ActionExtension objects.'
def get_request_extensions(self): DCNL 'Returns a list of RequestExtension objects.'
def extend_resources(self, version, attr_map): DCNL 'Extend resources with additional resources or attributes. DCNL :param: attr_map, the existing mapping from resource name to DCNL attrs definition. DCNL After this function, we will extend the attr_map if an extension DCNL wants to extend this map.'
def _check_extension(self, extension): DCNL 'Checks for required methods in extension objects.'
def _load_all_extensions(self): DCNL 'Load extensions from the configured path. DCNL Load extensions from the configured path. The extension name is DCNL constructed from the module_name. If your extension module was named DCNL widgets.py the extension class within that module should be DCNL \'Widgets\'. DCNL See tests/unit/extensions/foxinsocks.py for an example DCNL extension implementation.'
def _check_extension(self, extension): DCNL 'Checks if any of plugins supports extension and implements the DCNL extension contract.'
def _items(self, request, do_authz=False, parent_id=None): DCNL 'Retrieves and formats a list of elements of the requested entity'
def _item(self, request, id, do_authz=False, field_list=None, parent_id=None): DCNL 'Retrieves and formats a single element of the requested entity'
def index(self, request, **kwargs): DCNL 'Returns a list of the requested entity'
def show(self, request, id, **kwargs): DCNL 'Returns detailed information about the requested entity'
def create(self, request, body=None, **kwargs): DCNL 'Creates a new instance of the requested entity'
def delete(self, request, id, **kwargs): DCNL 'Deletes the specified entity'
def update(self, request, id, body=None, **kwargs): DCNL 'Updates the specified entity\'s attributes'
@staticmethod DCNL def prepare_request_body(context, body, is_create, resource, attr_info, allow_bulk=False): DCNL 'verifies required attributes are in request body, and that DCNL an attribute is only specified if it is allowed for the given DCNL operation (create/update). DCNL Attribute with default values are considered to be DCNL optional. DCNL body argument must be the deserialized body'
def __init__(self, base_url): DCNL ':param base_url: url of the root wsgi application'
def build(self, version_data): DCNL 'Generic method used to generate a version entity.'
def _build_links(self, version_data): DCNL 'Generate a container of links that refer to the provided version.'
def generate_href(self, version_number): DCNL 'Create an url that refers to a specific version_number.'
def _prepare_request_body(self, body, params): DCNL 'verifies required parameters are in request body. DCNL sets default value for missing optional parameters. DCNL body argument must be the deserialized body'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req): DCNL 'Respond to a request for all Quantum API versions.'
def get_active_networks(self, context, **kwargs): DCNL 'Retrieve and return a list of the active network ids.'
def get_network_info(self, context, **kwargs): DCNL 'Retrieve and return a extended information about a network.'
def get_dhcp_port(self, context, **kwargs): DCNL 'Allocate a DHCP port for the host and return port information. DCNL This method will re-use an existing port if one already exists.  When a DCNL port is re-used, the fixed_ip allocation will be updated to the current DCNL network state.'
def release_dhcp_port(self, context, **kwargs): DCNL 'Release the port currently being used by a DHCP agent.'
def release_port_fixed_ip(self, context, **kwargs): DCNL 'Release the fixed_ip associated the subnet on a port.'
def update_lease_expiration(self, context, **kwargs): DCNL 'Release the fixed_ip associated the subnet on a port.'
def _check_session_persistence_info(self, info): DCNL 'Performs sanity check on session persistence info. DCNL :param info: Session persistence info'
def add_router_to_l3_agent(self, context, id, router_id): DCNL 'Add a l3 agent to host a router.'
def remove_router_from_l3_agent(self, context, id, router_id): DCNL 'Remove the router from l3 agent. After it, the router DCNL will be non-hosted until there is update which DCNL lead to re schedule or be added to another agent manually.'
def get_l3_agent_candidates(self, sync_router, l3_agents): DCNL 'Get the valid l3 agents for the router from a list of l3_agents'
def schedule_routers(self, context, routers): DCNL 'Schedule the routers to l3 agents.'
def create_security_group(self, context, security_group, default_sg=False): DCNL 'Create security group. DCNL If default_sg is true that means we are a default security group for DCNL a given tenant if it does not exist.'
def get_security_group(self, context, id, fields=None, tenant_id=None): DCNL 'Tenant id is given to handle the case when we DCNL are creating a security group rule on behalf of another use.'
def _validate_security_group_rules(self, context, security_group_rule): DCNL 'Check that rules being installed all belong to the same security DCNL group, remote_group_id/security_group_id belong to the same tenant, DCNL and rules are valid.'
def _ensure_default_security_group(self, context, tenant_id): DCNL 'Create a default security group if one doesn\'t exist. DCNL :returns: the default security group id.'
def _get_security_groups_on_port(self, context, port): DCNL 'Check that all security groups on port belong to tenant. DCNL :returns: all security groups IDs on port belonging to tenant.'
def _check_update_deletes_security_groups(self, port): DCNL 'Return True if port has as a security group and it\'s value DCNL is either [] or not is_attr_set, otherwise return False'
def _check_update_has_security_groups(self, port): DCNL 'Return True if port has as a security group and False if the DCNL security_group field is is_attr_set or [].'
def as_dict(self): DCNL 'Convert a row into a dict'
def get_service_type(self, context, id, fields=None): DCNL 'Retrieve a service type record'
def get_service_types(self, context, fields=None, filters=None): DCNL 'Retrieve a possibly filtered list of service types'
def create_service_type(self, context, service_type): DCNL 'Create a new service type'
def update_service_type(self, context, id, service_type): DCNL 'Update a service type'
def delete_service_type(self, context, id): DCNL 'Delete a service type'
def increase_service_type_refcount(self, context, id): DCNL 'Increase references count for a service type object DCNL This method should be invoked by plugins using the service DCNL type concept everytime an instance of an object associated DCNL with a given service type is created.'
def decrease_service_type_refcount(self, context, id): DCNL 'Decrease references count for a service type object DCNL This method should be invoked by plugins using the service DCNL type concept everytime an instance of an object associated DCNL with a given service type is removed'
def get_sync_data(self, context, router_ids=None, active=None): DCNL 'Query routers and their related floating_ips, interfaces.'
def update(self, values): DCNL 'Make the model object behave like a dict'
def iteritems(self): DCNL 'Make the model object behave like a dict. DCNL Includes attributes from joins.'
def __repr__(self): DCNL 'sqlalchemy based automatic __repr__ method'
def sync_routers(self, context, **kwargs): DCNL 'Sync routers according to filters to a specific agent. DCNL @param context: contain user information DCNL @param kwargs: host, or router_id DCNL @return: a list of routers DCNL with their interfaces and floating_ips'
def get_external_network_id(self, context, **kwargs): DCNL 'Get one external network id for l3 agent. DCNL l3 agent expects only on external network when it performs DCNL this query.'
@classmethod DCNL def register_model_query_hook(cls, model, name, query_hook, filter_hook, result_filters=None): DCNL 'register an hook to be invoked when a query is executed. DCNL Add the hooks to the _model_query_hooks dict. Models are the keys DCNL of this dict, whereas the value is another dict mapping hook names to DCNL callables performing the hook. DCNL Each hook has a "query" component, used to build the query expression DCNL and a "filter" component, which is used to build the filter expression. DCNL Query hooks take as input the query being built and return a DCNL transformed query expression. DCNL Filter hooks take as input the filter expression being built and return DCNL a transformed filter expression'
@staticmethod DCNL def _recycle_expired_ip_allocations(context, network_id): DCNL 'Return held ip allocations with expired leases back to the pool.'
@staticmethod DCNL def _recycle_ip(context, network_id, subnet_id, ip_address): DCNL 'Return an IP address to the pool of free IP\'s on the network DCNL subnet.'
@staticmethod DCNL def _generate_ip(context, subnets): DCNL 'Generate an IP address. DCNL The IP address will be generated from one of the subnets defined on DCNL the network.'
@staticmethod DCNL def _allocate_specific_ip(context, subnet_id, ip_address): DCNL 'Allocate a specific IP address on the subnet.'
@staticmethod DCNL def _check_unique_ip(context, network_id, subnet_id, ip_address): DCNL 'Validate that the IP address on the subnet is not in use.'
@staticmethod DCNL def _check_subnet_ip(cidr, ip_address): DCNL 'Validate that the IP address is on the subnet.'
@staticmethod DCNL def _check_ip_in_allocation_pool(context, subnet_id, gateway_ip, ip_address): DCNL 'Validate IP in allocation pool. DCNL Validates that the IP address is either the default gateway or DCNL in the allocation pools of the subnet.'
def _test_fixed_ips_for_port(self, context, network_id, fixed_ips): DCNL 'Test fixed IPs for port. DCNL Check that configured subnets are valid prior to allocating any DCNL IPs. Include the subnet_id in the result if only an IP address is DCNL configured. DCNL :raises: InvalidInput, IpAddressInUse'
def _allocate_fixed_ips(self, context, network, fixed_ips): DCNL 'Allocate IP addresses according to the configured fixed_ips.'
def _update_ips_for_port(self, context, network_id, port_id, original_ips, new_ips): DCNL 'Add or remove IPs from the port.'
def _allocate_ips_for_port(self, context, network, port): DCNL 'Allocate IP addresses for the port. DCNL If port[\'fixed_ips\'] is set to \'ATTR_NOT_SPECIFIED\', allocate IP DCNL addresses for the port. If port[\'fixed_ips\'] contains an IP address or DCNL a subnet_id then allocate an IP address accordingly.'
def _validate_subnet_cidr(self, context, network, new_subnet_cidr): DCNL 'Validate the CIDR for a subnet. DCNL Verifies the specified CIDR does not overlap with the ones defined DCNL for the other subnets specified for this network, or with any other DCNL CIDR if overlapping IPs are disabled.'
def _validate_allocation_pools(self, ip_pools, subnet_cidr): DCNL 'Validate IP allocation pools. DCNL Verify start and end address for each allocation pool are valid, DCNL ie: constituted by valid and appropriately ordered IP addresses. DCNL Also, verify pools do not overlap among themselves. DCNL Finally, verify that each range fall within the subnet\'s CIDR.'
def _allocate_pools_for_subnet(self, context, subnet): DCNL 'Create IP allocation pools for a given subnet DCNL Pools are defined by the \'allocation_pools\' attribute, DCNL a list of dict objects with \'start\' and \'end\' keys for DCNL defining the pool range.'
def create_network(self, context, network): DCNL 'handle creation of a single network'
def _validate_ip_version(self, ip_version, addr, name): DCNL 'Check IP field of a subnet match specified ip version'
def _validate_subnet(self, s): DCNL 'Validate a subnet spec'
def update_subnet(self, context, id, subnet): DCNL 'Update the subnet with new info. The change however will not be DCNL realized until the client renew the dns lease or we support DCNL gratuitous DHCP offers'
def get_assoc_data(self, context, fip, floating_network_id): DCNL 'When a floating IP is associated with an internal port, DCNL we need to extract/determine some data associated with the DCNL internal port, including the internal_ip_address, and router_id. DCNL We also need to confirm that this internal port is owned by the DCNL tenant who owns the floating IP.'
def prevent_l3_port_deletion(self, context, port_id): DCNL 'Checks to make sure a port is allowed to be deleted, raising DCNL an exception if this is not the case.  This should be called by DCNL any plugin when the API requests the deletion of a port, since DCNL some ports for L3 are not intended to be deleted directly via a DCNL DELETE to /ports, but rather via other API calls that perform the DCNL proper deletion checks.'
def _get_sync_routers(self, context, router_ids=None, active=None): DCNL 'Query routers and their gw ports for l3 agent. DCNL Query routers with the router_ids. The gateway ports, if any, DCNL will be queried too. DCNL l3 agent has an option to deal with only one router id. In addition, DCNL when we need to notify the agent the data about only one router DCNL (when modification of router, its interfaces, gw_port and floatingips), DCNL we will have router_ids. DCNL @param router_ids: the list of router ids which we want to query. DCNL if it is None, all of routers will be queried. DCNL @return: a list of dicted routers with dicted gw_port populated if any'
def _get_sync_floating_ips(self, context, router_ids): DCNL 'Query floating_ips that relate to list of router_ids.'
def get_sync_interfaces(self, context, router_ids, device_owner=DEVICE_OWNER_ROUTER_INTF): DCNL 'Query router interfaces that relate to list of router_ids.'
def _populate_subnet_for_ports(self, context, ports): DCNL 'Populate ports with subnet. DCNL These ports already have fixed_ips populated.'
def get_sync_data(self, context, router_ids=None, active=None): DCNL 'Query routers and their related floating_ips, interfaces.'
def update_security_group_on_port(self, context, id, port, original_port, updated_port): DCNL 'update security groups on port DCNL This method returns a flag which indicates request notification DCNL is required and does not perform notification itself. DCNL It is because another changes for the port may require notification.'
def is_security_group_member_updated(self, context, original_port, updated_port): DCNL 'check security group member updated or not DCNL This method returns a flag which indicates request notification DCNL is required and does not perform notification itself. DCNL It is because another changes for the port may require notification.'
def notify_security_groups_member_updated(self, context, port): DCNL 'notify update event of security group members DCNL The agent setups the iptables rule to allow DCNL ingress packet from the dhcp server (as a part of provider rules), DCNL so we need to notify an update of dhcp server ip DCNL address to the plugin agent. DCNL security_groups_provider_updated() just notifies that an event DCNL occurs and the plugin agent fetches the update provider DCNL rule in the other RPC call (security_group_rules_for_devices).'
def security_group_rules_for_devices(self, context, **kwargs): DCNL 'return security group rules for each port DCNL also convert remote_group_id rule DCNL to source_ip_prefix and dest_ip_prefix rule DCNL :params devices: list of devices DCNL :returns: port correspond to the devices with security group rules'
@staticmethod DCNL def get_tenant_quotas(context, resources, tenant_id): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL tenant. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resource keys. DCNL :param tenant_id: The ID of the tenant to return quotas for. DCNL :return dict: from resource name to dict of name and limit'
@staticmethod DCNL def delete_tenant_quota(context, tenant_id): DCNL 'Delete the quota entries for a given tenant_id. DCNL Atfer deletion, this tenant will use default quota values in conf.'
@staticmethod DCNL def get_all_quotas(context, resources): DCNL 'Given a list of resources, retrieve the quotas for the all DCNL tenants. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resource keys. DCNL :return quotas: list of dict of tenant_id:, resourcekey1: DCNL resourcekey2: ...'
def _get_quotas(self, context, tenant_id, resources, keys): DCNL 'A helper method which retrieves the quotas for the specific DCNL resources identified by keys, and which apply to the current DCNL context. DCNL :param context: The request context, for access checks. DCNL :param tenant_id: the tenant_id to check quota. DCNL :param resources: A dictionary of the registered resources. DCNL :param keys: A list of the desired quotas to retrieve.'
def limit_check(self, context, tenant_id, resources, values): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param tenant_id: The tenant_id to check the quota. DCNL :param resources: A dictionary of the registered resources. DCNL :param values: A dictionary of the values to check against the DCNL quota.'
def _determine_port_security_and_has_ip(self, context, port): DCNL 'Returns a tuple of (port_security_enabled, has_ip) where DCNL port_security_enabled and has_ip are bools. Port_security is the DCNL value assocated with the port if one is present otherwise the value DCNL associated with the network is returned. has_ip is if the port is DCNL associated with an ip or not.'
def create_or_update_agent(self, context, agent): DCNL 'Create or update agent according to report.'
def report_state(self, context, **kwargs): DCNL 'Report state from agent to server.'
def config(self, **kw): DCNL 'Override some configuration values. DCNL The keyword arguments are the names of configuration options to DCNL override and their values. DCNL If a group argument is supplied, the overrides are applied to DCNL the specified configuration option group. DCNL All overrides are automatically cleared at the end of the current DCNL test by the fixtures cleanup process.'
def _construct_dict_and_constraints(self): DCNL 'Constructs a test dictionary and a definition of constraints. DCNL :return: A (dictionary, constraint) tuple'
def _delete_default_security_group_egress_rules(self, security_group_id): DCNL 'Deletes default egress rules given a security group ID'
def _assert_sg_rule_has_kvs(self, security_group_rule, expected_kvs): DCNL 'Asserts that the sg rule has expected key/value pairs passed DCNL in as expected_kvs dictionary'
def _test_entity_delete(self, entity): DCNL 'does the entity deletion based on naming convention'
def test_create_vip_twice_for_same_pool(self): DCNL 'Test loadbalancer db plugin via extension and directly'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Extended Resource for dummy management'
def _create_bulk_from_list(self, fmt, resource, objects, **kwargs): DCNL 'Creates a bulk request from a list of objects'
def _create_bulk(self, fmt, number, resource, data, name='test', **kwargs): DCNL 'Creates a bulk request for any kind of resource'
def _do_side_effect(self, patched_plugin, orig, *args, **kwargs): DCNL 'Invoked by test cases for injecting failures in plugin'
def test_list_with_fields_noadmin_and_policy_field(self): DCNL 'If a field used by policy is selected, do not duplicate it. DCNL Verifies that if the field parameter explicitly specifies a field DCNL which is used by the policy engine, then it is not duplicated DCNL in the response.'
def test_update_port_update_ip(self): DCNL 'Test update of port IP. DCNL Check that a configured IP 10.0.0.2 is replaced by 10.0.0.10.'
def test_update_port_update_ips(self): DCNL 'Update IP and generate new IP on port. DCNL Check a port update with the specified subnet_id\'s. A IP address DCNL will be allocated for each subnet_id.'
def test_update_port_add_additional_ip(self): DCNL 'Test update of port with additional IP.'
def test_repr(self): DCNL 'testing the string representation of \'model\' classes'
def test_KillFilter_no_raise(self): DCNL 'Makes sure ValueError from bug 926412 is gone'
def test_KillFilter_deleted_exe(self): DCNL 'Makes sure deleted exe\'s are killed correctly'
def _get_resource_type(self, path): DCNL 'Identifies resource type and relevant uuids in the uri DCNL /ws.v1/lswitch/xxx DCNL /ws.v1/lswitch/xxx/status DCNL /ws.v1/lswitch/xxx/lport/yyy DCNL /ws.v1/lswitch/xxx/lport/yyy/status DCNL /ws.v1/lrouter/zzz DCNL /ws.v1/lrouter/zzz/status DCNL /ws.v1/lrouter/zzz/lport/www DCNL /ws.v1/lrouter/zzz/lport/www/status DCNL /ws.v1/lqueue/xxx'
def _nvp_validate_ext_gw(self, router_id, l3_gw_uuid, vlan_id): DCNL 'Verify data on fake NVP API client in order to validate DCNL plugin did set them properly'
def get_all_networks(self, tenant_id): DCNL 'Get all networks'
def get_network(self, network_id): DCNL 'Get a network'
def create_network(self, tenant_id, net_name): DCNL 'Create a network'
def delete_network(self, net_id): DCNL 'Delete a network'
def update_network(self, tenant_id, net_id, param_data): DCNL 'Rename a network'
def get_all_ports(self, net_id): DCNL 'Get all ports'
def get_port(self, net_id, port_id): DCNL 'Get a port'
def create_port(self, net_id): DCNL 'Add a port'
def delete_port(self, net_id, port_id): DCNL 'Delete a port'
def update_port(self, net_id, port_id, **kwargs): DCNL 'Update a port'
def plug_interface(self, net_id, port_id, int_id): DCNL 'Plug interface to a port'
def unplug_interface(self, net_id, port_id): DCNL 'Unplug interface to a port'
def test_serialize_unknown_content_type(self): DCNL 'Test serialize verifies that exception InvalidContentType is raised'
def test_get_deserialize_handler_unknown_content_type(self): DCNL 'Test get deserialize verifies DCNL that exception InvalidContentType is raised'
def test_serialize_content_type_json(self): DCNL 'Test serialize with content type json'
def test_serialize_content_type_xml(self): DCNL 'Test serialize with content type xml'
def test_deserialize_raise_bad_request(self): DCNL 'Test serialize verifies that exception is raises'
def test_deserialize_json_content_type(self): DCNL 'Test Serializer.deserialize with content type json'
def test_deserialize_xml_content_type(self): DCNL 'Test deserialize with content type xml'
def test_deserialize_xml_content_type_with_meta(self): DCNL 'Test deserialize with content type xml with meta'
def test_serialize_xml_root_key_is_dict(self): DCNL 'Test Serializer.serialize with content type xml with meta dict'
def test_serialize_xml_root_key_is_list(self): DCNL 'Test serialize with content type xml with meta list'
def test_get_deserializer(self): DCNL 'Test RequestDeserializer.get_body_deserializer'
def test_get_expected_content_type(self): DCNL 'Test RequestDeserializer.get_expected_content_type'
def test_get_action_args(self): DCNL 'Test RequestDeserializer.get_action_args'
def test_deserialize(self): DCNL 'Test RequestDeserializer.deserialize'
def test_get_body_deserializer_unknown_content_type(self): DCNL 'Test get body deserializer verifies DCNL that exception InvalidContentType is raised'
def test_serialize_unknown_content_type(self): DCNL 'Test serialize verifies DCNL that exception InvalidContentType is raised'
def test_get_body_serializer(self): DCNL 'Test get body serializer verifies DCNL that exception InvalidContentType is raised'
def test_get_serializer(self): DCNL 'Test ResponseSerializer.get_body_serializer'
def test_dispatch(self): DCNL 'Test ActionDispatcher.dispatch'
def test_dispatch_action_None(self): DCNL 'Test ActionDispatcher.dispatch with none action'
def test_default_raise_Malformed_Exception(self): DCNL 'Test verifies JsonDeserializer.default DCNL raises exception MalformedRequestBody correctly'
def test_default_raise_Malformed_Exception(self): DCNL 'Test verifies that exception MalformedRequestBody is raised'
def _register_agent_states(self): DCNL 'Register two L3 agents and two DHCP agents.'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
def get_ofc_item_random_params(self): DCNL 'create random parameters for ofc_item test'
def get_ofc_description(self, desc): DCNL 'OFC description consists of [A-Za-z0-9_].'
def get_random_params(self): DCNL 'create random parameters for portinfo test'
def testa_create_ofc_tenant(self): DCNL 'test create ofc_tenant'
def testb_exists_ofc_tenant(self): DCNL 'test exists_ofc_tenant'
def testc_delete_ofc_tenant(self): DCNL 'test delete ofc_tenant'
def testd_create_ofc_network(self): DCNL 'test create ofc_network'
def teste_exists_ofc_network(self): DCNL 'test exists_ofc_network'
def testf_delete_ofc_network(self): DCNL 'test delete ofc_network'
def testg_create_ofc_port(self): DCNL 'test create ofc_port'
def testh_exists_ofc_port(self): DCNL 'test exists_ofc_port'
def testi_delete_ofc_port(self): DCNL 'test delete ofc_port'
def testj_create_ofc_packet_filter(self): DCNL 'test create ofc_filter'
def testk_exists_ofc_packet_filter(self): DCNL 'test exists_ofc_packet_filter'
def testl_delete_ofc_packet_filter(self): DCNL 'test delete ofc_filter'
def setUp(self): DCNL 'Setup for tests'
def get_ofc_item_random_params(self): DCNL 'create random parameters for ofc_item test'
def get_portinfo_random_params(self): DCNL 'create random parameters for portinfo test'
def testa_add_ofc_item(self): DCNL 'test add OFC item'
def testb_get_ofc_item(self): DCNL 'test get OFC item'
def testb_get_ofc_id(self): DCNL 'test get OFC d'
def testb_exists_ofc_item(self): DCNL 'test get OFC d'
def testc_find_ofc_item(self): DCNL 'test find OFC item'
def testc_del_ofc_item(self): DCNL 'test delete OFC item'
def testd_add_portinfo(self): DCNL 'test add portinfo'
def teste_get_portinfo(self): DCNL 'test get portinfo'
def testf_del_portinfo(self): DCNL 'test delete portinfo'
def get_ofc_item_random_params(self): DCNL 'create random parameters for ofc_item test'
def get_ofc_item_random_params(self): DCNL 'create random parameters for ofc_item test'
def mock_treat_devices_added(self, details, func_name): DCNL ':param details: the details to return for the device DCNL :param func_name: the function that should be called DCNL :returns: whether the named function was called'
def mock_treat_devices_added(self, details, port, func_name): DCNL ':param details: the details to return for the device DCNL :param port: the port that get_vif_port_by_id should return DCNL :param func_name: the function that should be called DCNL :returns: whether the named function was called'
def test_vifport(self): DCNL 'create and stringify vif port, confirm no exceptions'
def _create_network(self, fmt, name, admin_state_up, **kwargs): DCNL 'Override the routine for allowing the router:external attribute'
def test_vlan(self): DCNL 'test vlan allocation/de-alloc.'
def test_create_network(self): DCNL 'Test brocade specific network db.'
def test_create_port(self): DCNL 'Test brocade specific port db.'
def setUp(self): DCNL 'Set up function'
def test_a_create_network(self): DCNL 'Tests creation of two new Virtual Network. DCNL Tests deletion of one Virtual Network. DCNL This would result the following - DCNL The Nexus device should have only one network DCNL vlan configured on it\'s plugin configured DCNL interfaces. DCNL If running this test individually, run DCNL test_nexus_clear_vlan after this test to clean DCNL up the second vlan created by this test.'
def test_b_nexus_delete_port(self): DCNL 'Test to clean up second vlan of nexus device DCNL created by test_create_delete_network. This DCNL test will fail if it is run individually.'
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_interval=None, periodic_fuzzy_delay=None): DCNL 'Instantiates class and passes back application object. DCNL :param host: defaults to CONF.host DCNL :param binary: defaults to basename of executable DCNL :param topic: defaults to bin_name - \'nova-\' part DCNL :param manager: defaults to CONF.<topic>_manager DCNL :param report_interval: defaults to CONF.report_interval DCNL :param periodic_interval: defaults to CONF.periodic_interval DCNL :param periodic_fuzzy_delay: defaults to CONF.periodic_fuzzy_delay'
def kill(self): DCNL 'Destroy the service object.'
def periodic_tasks(self, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def report_state(self): DCNL 'Update the state of this service.'
def format(self, record): DCNL 'Uses contextstring if request_id is set, otherwise default.'
def formatException(self, exc_info, record=None): DCNL 'Format exception output with CONF.logging_exception_prefix.'
def __init__(cls, names, bases, dict_): DCNL 'Metaclass that allows us to collect decorated periodic tasks.'
def run_periodic_tasks(self, context, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def __init__(self, topic, default_version): DCNL 'Initialize an RpcProxy. DCNL :param topic: The topic to use for all messages. DCNL :param default_version: The default API version to request in all DCNL outgoing messages.  This can be overridden on a per-message DCNL basis.'
def _set_version(self, msg, vers): DCNL 'Helper method to set the version in a message. DCNL :param msg: The message having a version added to it. DCNL :param vers: The version number to add to the message.'
def _get_topic(self, topic): DCNL 'Return the topic to use for a message.'
def call(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.call() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: The return value from the remote method.'
def multicall(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.multicall() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: An iterator that lets you process each of the returned values DCNL from the remote method as they arrive.'
def cast(self, context, msg, topic=None, version=None): DCNL 'rpc.cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast() does not wait on any return value from the DCNL remote method.'
def fanout_cast(self, context, msg, topic=None, version=None): DCNL 'rpc.fanout_cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast() does not wait on any return value DCNL from the remote method.'
def cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast_to_server() does not wait on any DCNL return values.'
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.fanout_cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast_to_server() does not wait on any DCNL return values.'
def __init__(self, conf, connection_pool, pooled=True, server_params=None): DCNL 'Create a new connection, or get one from the pool'
def __enter__(self): DCNL 'When with ConnectionContext() is used, return self'
def _done(self): DCNL 'If the connection came from a pool, clean it up and put it back. DCNL If it did not come from a pool, close it.'
def __exit__(self, exc_type, exc_value, tb): DCNL 'End of \'with\' statement.  We\'re done here.'
def __del__(self): DCNL 'Caller is done with this connection.  Make sure we cleaned up.'
def close(self): DCNL 'Caller is done with this connection.'
def __getattr__(self, key): DCNL 'Proxy all other calls to the Connection instance'
def check_duplicate_message(self, message_data): DCNL 'AMQP consumers may read same message twice when exceptions occur DCNL before ack is returned. This method prevents doing it.'
def wait(self): DCNL 'Wait for all callback threads to exit.'
def __init__(self, conf, callback, connection_pool): DCNL ':param conf: cfg.CONF instance DCNL :param callback: a callable (probably a function) DCNL :param connection_pool: connection pool as returned by DCNL get_connection_pool()'
def __call__(self, message_data): DCNL 'Consumer callback to call a method on a proxy object. DCNL Parses the message for validity and fires off a thread to call the DCNL proxy object method. DCNL Message data should be a dictionary with two keys: DCNL method: string representing the method to call DCNL args: dictionary of arg: value DCNL Example: {\'method\': \'echo\', \'args\': {\'value\': 42}}'
def _process_data(self, ctxt, version, method, args): DCNL 'Process a message in a new thread. DCNL If the proxy object we have has a dispatch method DCNL (see rpc.dispatcher.RpcDispatcher), pass it the version, DCNL method, and args and let it dispatch as appropriate.  If not, use DCNL the old behavior of magically calling the specified method on the DCNL proxy we have here.'
def __iter__(self): DCNL 'Return a result until we get a reply with an \'ending" flag'
def __call__(self, data): DCNL 'The consume() callback will call this.  Store the result.'
def __iter__(self): DCNL 'Return a result until we get a \'None\' response from consumer'
def __init__(self, callbacks): DCNL 'Initialize the rpc dispatcher. DCNL :param callbacks: List of proxy objects that are an instance DCNL of a class with rpc methods exposed.  Each proxy DCNL object should have an RPC_API_VERSION attribute.'
def dispatch(self, ctxt, version, method, **kwargs): DCNL 'Dispatch a message based on a requested version. DCNL :param ctxt: The request context DCNL :param version: The requested API version from the incoming message DCNL :param method: The method requested to be called by the incoming DCNL message. DCNL :param kwargs: A dict of keyword arguments to be passed to the method. DCNL :returns: Whatever is returned by the underlying method that gets DCNL called.'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a key.host is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def is_alive(self, topic, host): DCNL 'Checks if a host is alive.'
def expire(self, topic, host): DCNL 'Explicitly expire a host\'s registration.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Spawn heartbeat greenthread.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a host.topic is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def backend_register(self, key, host): DCNL 'Implements registration logic. DCNL Called by register(self,key,host)'
def backend_unregister(self, key, key_host): DCNL 'Implements de-registration logic. DCNL Called by unregister(self,key,host)'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Implementation of MatchMakerBase.start_heartbeat DCNL Launches greenthread looping send_heartbeats(), DCNL yielding for CONF.matchmaker_heartbeat_freq seconds DCNL between iterations.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts): DCNL 'Declare a queue on an amqp session. DCNL \'session\' is the amqp session to use DCNL \'callback\' is the callback to call when messages are received DCNL \'node_name\' is the first part of the Qpid address string, before \';\' DCNL \'node_opts\' will be applied to the "x-declare" section of "node" DCNL in the address string. DCNL \'link_name\' goes into the "name" field of the "link" in the address DCNL string DCNL \'link_opts\' will be applied to the "x-declare" section of "link" DCNL in the address string.'
def reconnect(self, session): DCNL 'Re-declare the receiver after a qpid reconnect'
def consume(self): DCNL 'Fetch the message and pass it to the callback object'
def __init__(self, conf, session, msg_id, callback): DCNL 'Init a \'direct\' queue. DCNL \'session\' is the amqp session to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None): DCNL 'Init a \'topic\' queue. DCNL :param session: the amqp session to use DCNL :param topic: is the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param name: optional queue name, defaults to topic'
def __init__(self, conf, session, topic, callback): DCNL 'Init a \'fanout\' queue. DCNL \'session\' is the amqp session to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, session, node_name, node_opts=None): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, session): DCNL 'Re-establish the Sender after a reconnection'
def send(self, msg): DCNL 'Send a message'
def __init__(self, conf, session, msg_id): DCNL 'Init a \'direct\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'fanout\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing sessions and queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
def socket_s(self): DCNL 'Get socket type as string.'
def subscribe(self, msg_filter): DCNL 'Subscribe.'
def unsubscribe(self, msg_filter): DCNL 'Unsubscribe.'
def _get_response(self, ctx, proxy, topic, data): DCNL 'Process a curried message and cast the result to topic.'
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None): DCNL 'Reply to a casted call.'
def consume_in_thread(self): DCNL 'Runs the ZmqProxy service'
def close(self): DCNL 'Close the connection. DCNL This method must be called when the connection will no longer be used. DCNL It will ensure that any resources associated with the connection, such DCNL as a network connection, and cleaned up.'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer on this connection. DCNL A consumer is associated with a message queue on the backend message DCNL bus.  The consumer will read messages from the queue, unpack them, and DCNL dispatch them to the proxy object.  The contents of the message pulled DCNL off of the queue will determine which method gets called on the proxy DCNL object. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. For example, all instances of nova-compute consume DCNL from a queue called "compute".  In that case, the DCNL messages will get distributed amongst the consumers in a DCNL round-robin fashion if fanout=False.  If fanout=True, DCNL every consumer associated with this topic will get a DCNL copy of every message. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param fanout: Whether or not this is a fanout topic.  See the DCNL documentation for the topic parameter for some DCNL additional comments on this.'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker on this connection. DCNL A worker is like a regular consumer of messages directed to a DCNL topic, except that it is part of a set of such consumers (the DCNL "pool") which may run in parallel. Every pool of workers will DCNL receive a given message, but only one worker in the pool will DCNL be asked to process it. Load is distributed across the members DCNL of the pool in round-robin fashion. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param pool_name: String containing the name of the pool of workers'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created. DCNL :param callback: Callable to be invoked for each message. DCNL :type callback: callable accepting one argument DCNL :param pool_name: The name of the consumer pool. DCNL :type pool_name: str DCNL :param topic: The routing topic for desired messages. DCNL :type topic: str DCNL :param exchange_name: The name of the message exchange where DCNL the client should attach. Defaults to DCNL the configured exchange. DCNL :type exchange_name: str'
def consume_in_thread(self): DCNL 'Spawn a thread to handle incoming messages. DCNL Spawn a thread that will be responsible for handling all incoming DCNL messages for consumers that were set up on this connection. DCNL Message dispatching inside of this is expected to be implemented in a DCNL non-blocking manner.  An example implementation would be having this DCNL thread pull messages in for all of the consumers, but utilize a thread DCNL pool for dispatching the messages to the proxy objects.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
def __init__(self, channel, callback, tag, **kwargs): DCNL 'Declare a queue on an amqp channel. DCNL \'channel\' is the amqp channel to use DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL queue name, exchange name, and other kombu options are DCNL passed in here as a dictionary.'
def reconnect(self, channel): DCNL 'Re-declare the queue after a rabbit reconnect'
def consume(self, *args, **kwargs): DCNL 'Actually declare the consumer on the amqp channel.  This will DCNL start the flow of messages from the queue.  Using the DCNL Connection.iterconsume() iterator will process the messages, DCNL calling the appropriate callback. DCNL If a callback is specified in kwargs, use that.  Otherwise, DCNL use the callback passed during __init__() DCNL If kwargs[\'nowait\'] is True, then this call will block until DCNL a message is read. DCNL Messages will automatically be acked if the callback doesn\'t DCNL raise an exception'
def cancel(self): DCNL 'Cancel the consuming from the queue, if it has started'
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs): DCNL 'Init a \'direct\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs): DCNL 'Init a \'topic\' queue. DCNL :param channel: the amqp channel to use DCNL :param topic: the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param tag: a unique ID for the consumer on the channel DCNL :param name: optional queue name, defaults to topic DCNL :paramtype name: str DCNL Other kombu options may be passed as keyword arguments'
def __init__(self, conf, channel, topic, callback, tag, **kwargs): DCNL 'Init a \'fanout\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, channel, exchange_name, routing_key, **kwargs): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, channel): DCNL 'Re-establish the Producer after a rabbit reconnection'
def send(self, msg, timeout=None): DCNL 'Send a message'
def __init__(self, conf, channel, msg_id, **kwargs): DCNL 'init a \'direct\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'topic\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'fanout\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def _fetch_ssl_params(self): DCNL 'Handles fetching what ssl params DCNL should be used for the connection (if any)'
def _connect(self, params): DCNL 'Connect to rabbit.  Re-establish any queues that may have DCNL been declared before if we are reconnecting.  Exceptions should DCNL be handled by the caller.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing queues. DCNL Will retry up to self.max_retries number of times. DCNL self.max_retries = 0 means to retry forever. DCNL Sleep between tries, starting at self.interval_start DCNL seconds, backing off self.interval_stepping number of seconds DCNL each attempt.'
def get_channel(self): DCNL 'Convenience call for bin/clear_rabbit_queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
def __init__(self, retvalue=True): DCNL ':param retvalue: Value that LoopingCall.wait() should return.'
@classmethod DCNL def load_json(cls, data, default_rule=None): DCNL 'Allow loading of JSON rule data.'
def __init__(self, rules=None, default_rule=None): DCNL 'Initialize the Rules store.'
def __missing__(self, key): DCNL 'Implements the default rule handling.'
def __str__(self): DCNL 'Dumps a string representation of the rules.'
@abc.abstractmethod DCNL def __str__(self): DCNL 'Retrieve a string representation of the Check tree rooted at DCNL this node.'
@abc.abstractmethod DCNL def __call__(self, target, cred): DCNL 'Perform the check.  Returns False to reject the access or a DCNL true value (not necessary True) to accept the access.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __init__(self, kind, match): DCNL ':param kind: The kind of the check, i.e., the field before the DCNL :param match: The match of the check, i.e., the field after DCNL the \':\'.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __init__(self, rule): DCNL 'Initialize the \'not\' check. DCNL :param rule: The rule to negate.  Must be a Check.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Returns the logical inverse of the wrapped DCNL check.'
def __init__(self, rules): DCNL 'Initialize the \'and\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Requires that all rules accept in order to DCNL return True.'
def add_check(self, rule): DCNL 'Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the AndCheck object for convenience.'
def __init__(self, rules): DCNL 'Initialize the \'or\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Requires that at least one rule accept in DCNL order to return True.'
def add_check(self, rule): DCNL 'Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the OrCheck object for convenience.'
def __new__(mcs, name, bases, cls_dict): DCNL 'Create the class.  Injects the \'reducers\' list, a list of DCNL tuples matching token sequences to the names of the DCNL corresponding reduction methods.'
def __init__(self): DCNL 'Initialize the ParseState.'
def reduce(self): DCNL 'Perform a greedy reduction of the token stream.  If a reducer DCNL method matches, it will be executed, then the reduce() method DCNL will be called recursively to search for any more possible DCNL reductions.'
def shift(self, tok, value): DCNL 'Adds one more token to the state.  Calls reduce().'
@property DCNL def result(self): DCNL 'Obtain the final result of the parse.  Raises ValueError if DCNL the parse failed to reduce to a single result.'
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2): DCNL 'Turn parenthesized expressions into a \'check\' token.'
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2): DCNL 'Create an \'and_expr\' from two checks joined by the \'and\' DCNL operator.'
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check): DCNL 'Extend an \'and_expr\' by adding one more check.'
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2): DCNL 'Create an \'or_expr\' from two checks joined by the \'or\' DCNL operator.'
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check): DCNL 'Extend an \'or_expr\' by adding one more check.'
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check): DCNL 'Invert the result of another check.'
def __call__(self, target, creds): DCNL 'Recursively checks credentials based on the defined rules.'
def __call__(self, target, creds): DCNL 'Check that there is a matching role in the cred dict.'
def __call__(self, target, creds): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response DCNL is exactly \'True\'.'
def __call__(self, target, creds): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def __init__(self): DCNL 'Initialize the service launcher. DCNL :returns: None'
@staticmethod DCNL def run_service(service): DCNL 'Start and wait for a service to finish. DCNL :param service: service to run and wait for. DCNL :returns: None'
def launch_service(self, service): DCNL 'Load and start the given service. DCNL :param service: The service you would like to start. DCNL :returns: None'
def stop(self): DCNL 'Stop all services which are currently running. DCNL :returns: None'
def wait(self): DCNL 'Waits until all services have been stopped, and then returns. DCNL :returns: None'
def wait(self): DCNL 'Loop waiting on children to die and respawning as necessary'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def __str__(self): DCNL 'Make the VersionInfo object behave like a string.'
def __repr__(self): DCNL 'Include the name.'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def init_host(self): DCNL 'Handle initialization if this is a standalone service. DCNL Child classes should override this method.'
def after_start(self): DCNL 'Handler post initialization stuff. DCNL Child classes can override this method.'
def _run(self, application, socket): DCNL 'Start a WSGI service in a new green thread.'
def _populate_networks_cache(self): DCNL 'Populate the networks cache when the DHCP-agent starts'
def run(self): DCNL 'Activate the DHCP agent.'
def call_driver(self, action, network): DCNL 'Invoke an action on a DHCP driver instance.'
def sync_state(self): DCNL 'Sync the local DHCP state with Quantum.'
def _periodic_resync_helper(self): DCNL 'Resync the dhcp state at the configured interval.'
def periodic_resync(self): DCNL 'Spawn a thread to periodically resync the dhcp state.'
def enable_dhcp_helper(self, network_id): DCNL 'Enable DHCP for a network that meets enabling criteria.'
def disable_dhcp_helper(self, network_id): DCNL 'Disable DHCP for a network known to the agent.'
def refresh_dhcp_helper(self, network_id): DCNL 'Refresh or disable DHCP for a network depending on the current state DCNL of the network.'
@lockutils.synchronized('agent', 'dhcp-') DCNL def network_create_end(self, context, payload): DCNL 'Handle the network.create.end notification event.'
@lockutils.synchronized('agent', 'dhcp-') DCNL def network_update_end(self, context, payload): DCNL 'Handle the network.update.end notification event.'
@lockutils.synchronized('agent', 'dhcp-') DCNL def network_delete_end(self, context, payload): DCNL 'Handle the network.delete.end notification event.'
@lockutils.synchronized('agent', 'dhcp-') DCNL def subnet_update_end(self, context, payload): DCNL 'Handle the subnet.update.end notification event.'
@lockutils.synchronized('agent', 'dhcp-') DCNL def subnet_delete_end(self, context, payload): DCNL 'Handle the subnet.delete.end notification event.'
@lockutils.synchronized('agent', 'dhcp-') DCNL def port_update_end(self, context, payload): DCNL 'Handle the port.update.end notification event.'
@lockutils.synchronized('agent', 'dhcp-') DCNL def port_delete_end(self, context, payload): DCNL 'Handle the port.delete.end notification event.'
def get_active_networks(self): DCNL 'Make a remote process call to retrieve the active networks.'
def get_network_info(self, network_id): DCNL 'Make a remote process call to retrieve network info.'
def get_dhcp_port(self, network_id, device_id): DCNL 'Make a remote process call to create the dhcp port.'
def release_dhcp_port(self, network_id, device_id): DCNL 'Make a remote process call to release the dhcp port.'
def release_port_fixed_ip(self, network_id, device_id, subnet_id): DCNL 'Make a remote process call to release a fixed_ip on the port.'
def update_lease_expiration(self, network_id, ip_address, lease_remaining): DCNL 'Make a remote process call to update the ip lease expiration.'
def get_interface_name(self, network, port=None): DCNL 'Return interface(device) name for use by the DHCP process.'
def get_device_id(self, network): DCNL 'Return a unique DHCP device ID for this host on the network.'
def setup(self, network, reuse_existing=False): DCNL 'Create and initialize a device for network\'s DHCP on this host.'
def destroy(self, network, device_name): DCNL 'Destroy the device used for the network\'s DHCP on this host.'
def _handler(self, client_sock, client_addr): DCNL 'Handle incoming lease relay stream connection. DCNL This method will only read the first 1024 bytes and then close the DCNL connection.  The limit exists to limit the impact of misbehaving DCNL clients.'
def start(self): DCNL 'Spawn a green thread to run the lease relay unix socket server.'
def agent_updated(self, context, payload): DCNL 'Handle the agent_updated notification event.'
def daemonize(self): DCNL 'Daemonize process by doing Stevens double fork.'
def start(self): DCNL 'Start the daemon'
def run(self): DCNL 'Override this method when subclassing Daemon. DCNL start() will call this method after the process has daemonized.'
def init_l3(self, device_name, ip_cidrs, namespace=None): DCNL 'Set the L3 settings for the interface using data from the port. DCNL ip_cidrs: list of \'X.X.X.X/YY\' strings'
def plug(self, network_id, port_id, device_name, mac_address, bridge=None, namespace=None, prefix=None): DCNL 'Plug in the interface.'
def unplug(self, device_name, bridge=None, namespace=None, prefix=None): DCNL 'Unplug the interface.'
def plug(self, network_id, port_id, device_name, mac_address, bridge=None, namespace=None, prefix=None): DCNL 'Plugin the interface.'
def unplug(self, device_name, bridge=None, namespace=None, prefix=None): DCNL 'Unplug the interface.'
def get_pid_file_name(self, ensure_pids_dir=False): DCNL 'Returns the file name for a given kind of config file.'
@property DCNL def pid(self): DCNL 'Last known pid for this external process spawned for this uuid.'
def garbage_collect_namespace(self): DCNL 'Conditionally destroy the namespace if it is empty.'
def pullup_route(self, interface_name): DCNL 'Ensures that the route entry for the interface is before all DCNL others on the same subnet.'
def restart(self): DCNL 'Restart the dhcp service for the network.'
@classmethod DCNL def existing_dhcp_networks(cls, conf, root_helper): DCNL 'Return a list of existing networks ids (ones we have configs for)'
def _enable_dhcp(self): DCNL 'check if there is a subnet within the network with dhcp enabled.'
def enable(self): DCNL 'Enables DHCP for this network by spawning a local process.'
def disable(self, retain_port=False): DCNL 'Disable DHCP for this network by killing the local process.'
def get_conf_file_name(self, kind, ensure_conf_dir=False): DCNL 'Returns the file name for a given kind of config file.'
def _get_value_from_conf_file(self, kind, converter=None): DCNL 'A helper function to read a value from one of the state files.'
@property DCNL def pid(self): DCNL 'Last known pid for the DHCP process spawned for this network.'
@classmethod DCNL def existing_dhcp_networks(cls, conf, root_helper): DCNL 'Return a list of existing networks ids (ones we have configs for)'
def spawn_process(self): DCNL 'Spawns a Dnsmasq process for the network.'
def reload_allocations(self): DCNL 'Rebuild the dnsmasq config and signal the dnsmasq to reload.'
def _output_hosts_file(self): DCNL 'Writes a dnsmasq compatible hosts file.'
def _output_opts_file(self): DCNL 'Write a dnsmasq compatible options file.'
def _setup_chains(self): DCNL 'Setup ingress and egress chain for a port.'
def _remove_chains(self): DCNL 'Remove ingress and egress chain for a port'
def add_chain(self, name, wrap=True): DCNL 'Adds a named chain to the table. DCNL The chain name is wrapped to be unique for the component creating DCNL it, so different components of Nova can safely create identically DCNL named chains without interfering with one another. DCNL At the moment, its wrapped name is <binary name>-<chain name>, DCNL so if nova-compute creates a chain named \'OUTPUT\', it\'ll actually DCNL end up named \'nova-compute-OUTPUT\'.'
def ensure_remove_chain(self, name, wrap=True): DCNL 'Ensure the chain is removed. DCNL This removal "cascades". All rule in the chain are removed, as are DCNL all rules in other chains that jump to it.'
def remove_chain(self, name, wrap=True): DCNL 'Remove named chain. DCNL This removal "cascades". All rule in the chain are removed, as are DCNL all rules in other chains that jump to it. DCNL If the chain is not found, this is merely logged.'
def add_rule(self, chain, rule, wrap=True, top=False): DCNL 'Add a rule to the table. DCNL This is just like what you\'d feed to iptables, just without DCNL the \'-A <chain name>\' bit at the start. DCNL However, if you need to jump to one of your wrapped chains, DCNL prepend its name with a \'$\' which will ensure the wrapping DCNL is applied correctly.'
def remove_rule(self, chain, rule, wrap=True, top=False): DCNL 'Remove a rule from a chain. DCNL Note: The rule must be exactly identical to the one that was added. DCNL You cannot switch arguments around like you can with the iptables DCNL CLI tool.'
def empty_chain(self, chain, wrap=True): DCNL 'Remove all rules from a chain.'
@lockutils.synchronized('iptables', 'quantum-', external=True) DCNL def _apply(self): DCNL 'Apply the current in-memory set of iptables rules. DCNL This will blow away any rules left over from previous runs of the DCNL same component of Nova, and replace them with our current set of DCNL rules. This happens atomically, thanks to iptables-restore.'
def get_routers(self, context, fullsync=True, router_id=None): DCNL 'Make a remote process call to retrieve the sync data for routers.'
def get_external_network_id(self, context): DCNL 'Make a remote process call to retrieve the external network id. DCNL @raise common.RemoteError: with TooManyExternalNetworks DCNL as exc_type if there are DCNL more than one external network'
def _destroy_router_namespaces(self, only_router_id=None): DCNL 'Destroy router namespaces on the host to eliminate all stale DCNL linux devices, iptables rules, and namespaces. DCNL If only_router_id is passed, only destroy single namespace, to allow DCNL for multiple l3 agents on the same host, without stepping on each DCNL other\'s toes on init.  This only makes sense if router_id is set.'
def _fetch_external_net_id(self): DCNL 'Find UUID of single external network for this agent'
def router_deleted(self, context, router_id): DCNL 'Deal with router deletion RPC message.'
def routers_updated(self, context, routers): DCNL 'Deal with routers modification and creation RPC message.'
def agent_updated(self, context, payload): DCNL 'Handle the agent_updated notification event.'
def prepare_port_filter(self, port): DCNL 'Prepare filters for the port. DCNL This method should be called before the port is created.'
def apply_port_filter(self, port): DCNL 'Apply port filter. DCNL Once this method returns, the port should be firewalled DCNL appropriately. This method should as far as possible be a DCNL no-op. It\'s vastly preferred to get everything set up in DCNL prepare_port_filter.'
def update_port_filter(self, port): DCNL 'Refresh security group rules from data store DCNL Gets called when an port gets added to or removed from DCNL the security group the port is a member of or if the DCNL group gains or looses a rule.'
def remove_port_filter(self, port): DCNL 'Stop filtering port'
def filter_defer_apply_on(self): DCNL 'Defer application of filtering rule'
def filter_defer_apply_off(self): DCNL 'Turn off deferral of rules and apply the rules now'
@property DCNL def ports(self): DCNL 'returns filterd ports'
@contextlib.contextmanager DCNL def defer_apply(self): DCNL 'defer apply context'
def security_groups_rule_updated(self, context, **kwargs): DCNL 'callback for security group rule update DCNL :param security_groups: list of updated security_groups'
def security_groups_member_updated(self, context, **kwargs): DCNL 'callback for security group member update DCNL :param security_groups: list of updated security_groups'
def security_groups_provider_updated(self, context, **kwargs): DCNL 'callback for security group provider update'
def security_groups_rule_updated(self, context, security_groups): DCNL 'notify rule updated security groups'
def security_groups_member_updated(self, context, security_groups): DCNL 'notify member updated security groups'
def security_groups_provider_updated(self, context): DCNL 'notify provider updated security groups'
def tenant(self, request): DCNL 'Retrieve the tenant info in context.'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
def create_agent(self, context, agent): DCNL 'Create agent. DCNL This operation is not allow in REST API. DCNL @raise exceptions.BadRequest:'
@abstractmethod DCNL def delete_agent(self, context, id): DCNL 'Delete agent. DCNL Agents register themselves on reporting state. DCNL But if a agent does not report its status DCNL for a long time (for example, it is dead for ever. ), DCNL admin can remove it. Agents must be disabled before DCNL being removed.'
@abstractmethod DCNL def update_agent(self, context, agent): DCNL 'Disable or Enable the agent. DCNL Discription also can be updated. DCNL Some agents cannot be disabled, DCNL such as plugins, services. DCNL An error code should be reported in this case. DCNL @raise exceptions.BadRequest:'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Extended Resource for service type management'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
def create_for_sg(self, tenant_id, sg_id, sg_name): DCNL 'Create a new chain for security group. DCNL Creating a security group creates a pair of chains in MidoNet, one for DCNL inbound and the other for outbound.'
def delete_for_sg(self, tenant_id, sg_id, sg_name): DCNL 'Delete a chain mapped to a security group. DCNL Delete a SG means deleting all the chains (inbound and outbound) DCNL associated with the SG in MidoNet.'
def get_router_chains(self, tenant_id, router_id): DCNL 'Get router chains. DCNL Returns a dictionary that has in/out chain resources key\'ed with \'in\' DCNL and \'out\' respectively, given the tenant_id and the router_id passed DCNL in in the arguments.'
def create_router_chains(self, tenant_id, router_id): DCNL 'Create a new chain on a router. DCNL Creates chains for the router and returns the same dictionary as DCNL get_router_chains() returns.'
def get_sg_chains(self, tenant_id, sg_id): DCNL 'Get a list of chains mapped to a security group.'
def create_subnet(self, context, subnet): DCNL 'Create Quantum subnet. DCNL Creates a Quantum subnet and a DHCP entry in MidoNet bridge.'
def get_subnet(self, context, id, fields=None): DCNL 'Get Quantum subnet. DCNL Retrieves a Quantum subnet record but also including the DHCP entry DCNL data stored in MidoNet.'
def get_subnets(self, context, filters=None, fields=None): DCNL 'List Quantum subnets. DCNL Retrieves Quantum subnets with some fields populated by the data DCNL stored in MidoNet.'
def delete_subnet(self, context, id): DCNL 'Delete Quantum subnet. DCNL Delete quantum network and its corresponding MidoNet bridge.'
def create_network(self, context, network): DCNL 'Create Quantum network. DCNL Create a new Quantum network and its corresponding MidoNet bridge.'
def update_network(self, context, id, network): DCNL 'Update Quantum network. DCNL Update an existing Quantum network and its corresponding MidoNet DCNL bridge.'
def get_network(self, context, id, fields=None): DCNL 'Get Quantum network. DCNL Retrieves a Quantum network and its corresponding MidoNet bridge.'
def get_networks(self, context, filters=None, fields=None): DCNL 'List quantum networks and verify that all exist in MidoNet.'
def delete_network(self, context, id): DCNL 'Delete a network and its corresponding MidoNet bridge.'
def create_port(self, context, port): DCNL 'Create a L2 port in Quantum/MidoNet.'
def update_port(self, context, id, port): DCNL 'Update port.'
def get_port(self, context, id, fields=None): DCNL 'Retrieve port.'
def get_ports(self, context, filters=None, fields=None): DCNL 'List quantum ports and verify that they exist in MidoNet.'
def delete_port(self, context, id, l3_port_check=True): DCNL 'Delete a quantum port and corresponding MidoNet bridge port.'
def remove_router_interface(self, context, router_id, interface_info): DCNL 'Remove interior router ports.'
def create_security_group(self, context, security_group, default_sg=False): DCNL 'Create chains for Quantum security group.'
def delete_security_group(self, context, id): DCNL 'Delete chains for Quantum security group.'
def match(self, prior, method_regexp, uri_regexp, handler, data=None, multi=True): DCNL 'Adds to the list of exptected inputs. The incomming request is DCNL matched in the order of priority. For same priority, match the DCNL oldest match request first. DCNL :param prior: intgere priority of this match (e.g. 100) DCNL :param method_regexp: regexp to match method (e.g. \'PUT|POST\') DCNL :param uri_regexp: regexp to match uri (e.g. \'/quantum/v?.?/\') DCNL :param handler: function with signature: DCNL lambda(method, uri, body, **kwargs) : status, body DCNL where DCNL - method: HTTP method for this request DCNL - uri: URI for this HTTP request DCNL - body: body of this HTTP request DCNL - kwargs are: DCNL - data: data object that was in the match call DCNL - node: TestNetworkCtrl object itself DCNL - id: offset of the matching tuple DCNL and return values is: DCNL (status, body) where: DCNL - status: HTTP resp status (e.g. \'200 OK\'). DCNL If None, use default_status DCNL - body: HTTP resp body. If None, use \'\''
def server_failure(self, resp): DCNL 'Define failure codes as required. DCNL Note: We assume 301-303 is a failure, and try the next server in DCNL the server pool.'
def action_success(self, resp): DCNL 'Defining success codes as required. DCNL Note: We assume any valid 2xx as being successful response.'
def create_network(self, context, network): DCNL 'Create a network, which represents an L2 network segment which DCNL can have a set of subnets and ports associated with it. DCNL :param context: quantum api request context DCNL :param network: dictionary describing the network DCNL :returns: a sequence of mappings with the following signature: DCNL "id": UUID representing the network. DCNL "name": Human-readable name identifying the network. DCNL "tenant_id": Owner of network. NOTE: only admin user can specify DCNL a tenant_id other than its own. DCNL "admin_state_up": Sets admin state of network. DCNL if down, network does not forward packets. DCNL "status": Indicates whether network is currently operational DCNL (values are "ACTIVE", "DOWN", "BUILD", and "ERROR") DCNL "subnets": Subnets associated with this network. DCNL :raises: RemoteRestError'
def update_network(self, context, net_id, network): DCNL 'Updates the properties of a particular Virtual Network. DCNL :param context: quantum api request context DCNL :param net_id: uuid of the network to update DCNL :param network: dictionary describing the updates DCNL :returns: a sequence of mappings with the following signature: DCNL "id": UUID representing the network. DCNL "name": Human-readable name identifying the network. DCNL "tenant_id": Owner of network. NOTE: only admin user can DCNL specify a tenant_id other than its own. DCNL "admin_state_up": Sets admin state of network. DCNL if down, network does not forward packets. DCNL "status": Indicates whether network is currently operational DCNL (values are "ACTIVE", "DOWN", "BUILD", and "ERROR") DCNL "subnets": Subnets associated with this network. DCNL :raises: exceptions.NetworkNotFound DCNL :raises: RemoteRestError'
def delete_network(self, context, net_id): DCNL 'Delete a network. DCNL :param context: quantum api request context DCNL :param id: UUID representing the network to delete. DCNL :returns: None DCNL :raises: exceptions.NetworkInUse DCNL :raises: exceptions.NetworkNotFound DCNL :raises: RemoteRestError'
def create_port(self, context, port): DCNL 'Create a port, which is a connection point of a device DCNL (e.g., a VM NIC) to attach to a L2 Quantum network. DCNL :param context: quantum api request context DCNL :param port: dictionary describing the port DCNL :returns: DCNL "id": uuid represeting the port. DCNL "network_id": uuid of network. DCNL "tenant_id": tenant_id DCNL "mac_address": mac address to use on this port. DCNL "admin_state_up": Sets admin state of port. if down, port DCNL does not forward packets. DCNL "status": dicates whether port is currently operational DCNL (limit values to "ACTIVE", "DOWN", "BUILD", and "ERROR") DCNL "fixed_ips": list of subnet ID"s and IP addresses to be used on DCNL this port DCNL "device_id": identifies the device (e.g., virtual server) using DCNL this port. DCNL :raises: exceptions.NetworkNotFound DCNL :raises: exceptions.StateInvalid DCNL :raises: RemoteRestError'
def update_port(self, context, port_id, port): DCNL 'Update values of a port. DCNL :param context: quantum api request context DCNL :param id: UUID representing the port to update. DCNL :param port: dictionary with keys indicating fields to update. DCNL :returns: a mapping sequence with the following signature: DCNL "id": uuid represeting the port. DCNL "network_id": uuid of network. DCNL "tenant_id": tenant_id DCNL "mac_address": mac address to use on this port. DCNL "admin_state_up": sets admin state of port. if down, port DCNL does not forward packets. DCNL "status": dicates whether port is currently operational DCNL (limit values to "ACTIVE", "DOWN", "BUILD", and "ERROR") DCNL "fixed_ips": list of subnet ID\'s and IP addresses to be used on DCNL this port DCNL "device_id": identifies the device (e.g., virtual server) using DCNL this port. DCNL :raises: exceptions.StateInvalid DCNL :raises: exceptions.PortNotFound DCNL :raises: RemoteRestError'
def delete_port(self, context, port_id, l3_port_check=True): DCNL 'Delete a port. DCNL :param context: quantum api request context DCNL :param id: UUID representing the port to delete. DCNL :raises: exceptions.PortInUse DCNL :raises: exceptions.PortNotFound DCNL :raises: exceptions.NetworkNotFound DCNL :raises: RemoteRestError'
def _plug_interface(self, context, tenant_id, net_id, port_id, remote_interface_id): DCNL 'Attaches a remote interface to the specified port on the DCNL specified Virtual Network. DCNL :returns: None DCNL :raises: exceptions.NetworkNotFound DCNL :raises: exceptions.PortNotFound DCNL :raises: RemoteRestError'
def _unplug_interface(self, context, tenant_id, net_id, port_id): DCNL 'Detaches a remote interface from the specified port on the DCNL network controller DCNL :returns: None DCNL :raises: RemoteRestError'
def _send_all_data(self): DCNL 'Pushes all data to network ctrl (networks/ports, ports/attachments) DCNL to give the controller an option to re-sync it\'s persistent store DCNL with quantum\'s current view of that data.'
def _do_get(self, name, group=None): DCNL 'Look up an option value. DCNL :param name: the opt name (or \'dest\', more precisely) DCNL :param group: an OptGroup DCNL :returns: the option value, or a GroupAttr object DCNL :raises: NoSuchOptError, NoSuchGroupError, ConfigFileValueError, DCNL TemplateSubstitutionError'
def register_opts(self, opts, group_internal_name=None, group=None): DCNL 'Register multiple option schemas at once.'
def _convert_to_nvp_rule(self, rule, with_id=False): DCNL 'Converts Quantum API security group rule to NVP API.'
def _convert_to_nvp_rules(self, rules, with_id=False): DCNL 'Converts a list of Quantum API security group rules to NVP API.'
def _get_security_group_rules_nvp_format(self, context, security_group_id, with_id=False): DCNL 'Query quantum db for security group rules.'
def _get_profile_uuid(self, context, remote_group_id): DCNL 'Return profile id from novas group id.'
def _remove_security_group_with_id_and_id_field(self, rules, rule_id): DCNL 'This function receives all of the current rule associated with a DCNL security group and then removes the rule that matches the rule_id. In DCNL addition it removes the id field in the dict with each rule since that DCNL should not be passed to nvp.'
def add_controller(self, ip, port, user, password, request_timeout, http_timeout, retries, redirects, default_tz_uuid, uuid=None, zone=None, default_l3_gw_service_uuid=None, default_l2_gw_service_uuid=None, default_interface_name=None): DCNL 'Add a new set of controller parameters. DCNL :param ip: IP address of controller. DCNL :param port: port controller is listening on. DCNL :param user: user name. DCNL :param password: user password. DCNL :param request_timeout: timeout for an entire API request. DCNL :param http_timeout: timeout for a connect to a controller. DCNL :param retries: maximum number of request retries. DCNL :param redirects: maximum number of server redirect responses to DCNL follow. DCNL :param default_tz_uuid: default transport zone uuid. DCNL :param uuid: UUID of this cluster (used in MDI configs). DCNL :param zone: Zone of this cluster (used in MDI configs). DCNL :param default_l3_gw_service_uuid: Default l3 gateway service DCNL :param default_l2_gw_service_uuid: Default l2 gateway service DCNL :param default_interface_name: Default interface name for l2 gateways'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def _build_ip_address_list(self, context, fixed_ips, subnet_ids=None): DCNL 'Build ip_addresses data structure for logical router port DCNL No need to perform validation on IPs - this has already been DCNL done in the l3_db mixin class'
def _get_port_by_device_id(self, context, device_id, device_owner): DCNL 'Retrieve ports associated with a specific device id. DCNL Used for retrieving all quantum ports attached to a given router.'
def _find_router_subnets_cidrs(self, context, router_id): DCNL 'Retrieve subnets attached to the specified router'
def _nvp_create_port(self, context, port_data): DCNL 'Driver for creating a logical switch port on NVP platform'
def _nvp_create_router_port(self, context, port_data): DCNL 'Driver for creating a switch port to be connected to a router'
def _nvp_create_ext_gw_port(self, context, port_data): DCNL 'Driver for creating an external gateway port on NVP platform'
def _nvp_create_l2_gw_port(self, context, port_data): DCNL 'Create a switch port, and attach it to a L2 gateway attachment'
def _nvp_get_port_id(self, context, cluster, quantum_port): DCNL 'Return the NVP port uuid for a given quantum port. DCNL First, look up the Quantum database. If not found, execute DCNL a query on NVP platform as the mapping might be missing because DCNL the port was created before upgrading to grizzly.'
def _extend_fault_map(self): DCNL 'Extends the Quantum Fault Map DCNL Exceptions specific to the NVP Plugin are mapped to standard DCNL HTTP Exceptions'
def _find_target_cluster(self, resource): DCNL 'Return cluster where configuration should be applied DCNL If the resource being configured has a paremeter expressing DCNL the zone id (nova_id), then select corresponding cluster, DCNL otherwise return default cluster.'
def _get_lswitch_cluster_pairs(self, netw_id, tenant_id): DCNL 'Figure out the set of lswitches on each cluster that maps to this DCNL network id'
def delete_port(self, context, id, l3_port_check=True, nw_gw_port_check=True): DCNL 'Deletes a port on a specified Virtual Network, DCNL if the port contains a remote interface attachment, DCNL the remote interface is first un-plugged and then the port DCNL is deleted. DCNL :returns: None DCNL :raises: exception.PortInUse DCNL :raises: exception.PortNotFound DCNL :raises: exception.NetworkNotFound'
def _update_fip_assoc(self, context, fip, floatingip_db, external_port): DCNL 'Update floating IP association data. DCNL Overrides method from base class. DCNL The method is augmented for creating NAT rules in the process.'
def create_network_gateway(self, context, network_gateway): DCNL 'Create a layer-2 network gateway DCNL Create the gateway service on NVP platform and corresponding data DCNL structures in Quantum datase'
def delete_network_gateway(self, context, id): DCNL 'Remove a layer-2 network gateway DCNL Remove the gateway service from NVP platform and corresponding data DCNL structures in Quantum datase'
def create_security_group(self, context, security_group, default_sg=False): DCNL 'Create security group. DCNL If default_sg is true that means a we are creating a default security DCNL group and we don\'t need to check if one exists.'
def delete_security_group(self, context, security_group_id): DCNL 'Delete a security group DCNL :param security_group_id: security group rule to remove.'
def create_security_group_rule(self, context, security_group_rule): DCNL 'create a single security group rule'
def create_security_group_rule_bulk(self, context, security_group_rule): DCNL 'create security group rules DCNL :param security_group_rule: list of rules to create'
def delete_security_group_rule(self, context, sgrid): DCNL 'Delete a security group rule DCNL :param sgrid: security group id to remove.'
def _check_for_queue_and_create(self, context, port): DCNL 'This function determines if a port should be associated with a DCNL queue. It works by first querying NetworkQueueMapping to determine DCNL if the network is associated with a queue. If so, then it queries DCNL NetworkQueueMapping for all the networks that are associated with DCNL this queue. Next, it queries against all the ports on these networks DCNL with the port device_id. Finally it queries PortQueueMapping. If that DCNL query returns a queue_id that is returned. Otherwise a queue is DCNL created that is the size of the queue associated with the network and DCNL that queue_id is returned. DCNL If the network is not associated with a queue we then query to see DCNL if there is a default queue in the system. If so, a copy of that is DCNL created and the queue_id is returned. DCNL Otherwise None is returned. None is also returned if the port does not DCNL have a device_id or if the device_owner is network:'
def _nvp_lqueue(self, queue): DCNL 'Convert fields to nvp fields.'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
def __init__(self, api_providers, user, password, request_timeout, http_timeout, retries, redirects, concurrent_connections=3, nvp_gen_timeout=(-1)): DCNL 'Constructor. DCNL :param api_providers: a list of tuples in the form: DCNL (host, port, is_ssl=True). Passed on to NvpClientEventlet. DCNL :param user: the login username. DCNL :param password: the login password. DCNL :param concurrent_connections: the number of concurrent connections. DCNL :param request_timeout: all operations (including retries, redirects DCNL from unresponsive controllers, etc) should finish within this DCNL timeout. DCNL :param http_timeout: how long to wait before aborting an DCNL unresponsive controller (and allow for retries to another DCNL controller in the cluster) DCNL :param retries: the number of concurrent connections. DCNL :param redirects: the number of concurrent connections.'
def login(self, user=None, password=None): DCNL 'Login to NVP controller. DCNL Assumes same password is used for all controllers. DCNL :param user: NVP controller user (usually admin). Provided for DCNL backwards compatability. In the  normal mode of operation DCNL this should be None. DCNL :param password: NVP controller password. Provided for backwards DCNL compatability. In the normal mode of operation this should DCNL be None. DCNL :returns: Does not return a value.'
def request(self, method, url, body='', content_type='application/json'): DCNL 'Issues request to controller.'
def __init__(self, nvp_api_client, url, method='GET', body=None, headers=None, request_timeout=request.DEFAULT_REQUEST_TIMEOUT, retries=request.DEFAULT_RETRIES, auto_login=True, redirects=request.DEFAULT_REDIRECTS, http_timeout=request.DEFAULT_HTTP_TIMEOUT, client_conn=None): DCNL 'Constructor.'
@classmethod DCNL def _spawn(cls, func, *args, **kwargs): DCNL 'Allocate a green thread from the class pool.'
def spawn(self, func, *args, **kwargs): DCNL 'Spawn a new green thread with the supplied function and args.'
@classmethod DCNL def joinall(cls): DCNL 'Wait for all outstanding requests to complete.'
def join(self): DCNL 'Wait for instance green thread to complete.'
def start(self): DCNL 'Start request processing.'
def copy(self): DCNL 'Return a copy of this request instance.'
def _run(self): DCNL 'Method executed within green thread.'
def _handle_request(self): DCNL 'First level request handling.'
def api_providers(self): DCNL 'Parse api_providers from response. DCNL Returns: api_providers in [(host, port, is_ssl), ...] format'
def acquire_connection(self, auto_login=True, headers=None, rid=(-1)): DCNL 'Check out an available HTTPConnection instance. DCNL Blocks until a connection is available. DCNL :auto_login: automatically logins before returning conn DCNL :headers: header to pass on to login attempt DCNL :param rid: request id passed in from request eventlet. DCNL :returns: An available HTTPConnection instance or None if no DCNL api_providers are configured.'
def release_connection(self, http_conn, bad_state=False, service_unavail=False, rid=(-1)): DCNL 'Mark HTTPConnection instance as available for check-out. DCNL :param http_conn: An HTTPConnection instance obtained from this DCNL instance. DCNL :param bad_state: True if http_conn is known to be in a bad state DCNL (e.g. connection fault.) DCNL :service_unavail: True if http_conn returned 503 response. DCNL :param rid: request id passed in from request eventlet.'
def _wait_for_login(self, conn, headers=None): DCNL 'Block until a login has occurred for the current API provider.'
def _get_provider_data(self, conn_or_conn_params, default=None): DCNL 'Get data for specified API provider. DCNL Args: DCNL conn_or_conn_params: either a HTTP(S)Connection object or the DCNL resolved conn_params tuple returned by self._conn_params(). DCNL default: conn_params if ones passed aren\'t known DCNL Returns: Data associated with specified provider'
def _set_provider_data(self, conn_or_conn_params, data): DCNL 'Set data for specified API provider. DCNL Args: DCNL conn_or_conn_params: either a HTTP(S)Connection object or the DCNL resolved conn_params tuple returned by self._conn_params(). DCNL data: data to associate with API provider'
def _normalize_conn_params(self, conn_or_conn_params): DCNL 'Normalize conn_param tuple. DCNL Args: DCNL conn_or_conn_params: either a HTTP(S)Connection object or the DCNL resolved conn_params tuple returned by self._conn_params(). DCNL Returns: Normalized conn_param tuple'
def __init__(self, api_providers, user, password, concurrent_connections=client.DEFAULT_CONCURRENT_CONNECTIONS, nvp_gen_timeout=client.GENERATION_ID_TIMEOUT, use_https=True, connect_timeout=client.DEFAULT_CONNECT_TIMEOUT): DCNL 'Constructor DCNL :param api_providers: a list of tuples of the form: (host, port, DCNL is_ssl). DCNL :param user: login username. DCNL :param password: login password. DCNL :param concurrent_connections: total number of concurrent connections. DCNL :param use_https: whether or not to use https for requests. DCNL :param connect_timeout: connection timeout in seconds. DCNL :param nvp_gen_timeout controls how long the generation id is kept DCNL if set to -1 the generation id is never timed out'
def acquire_redirect_connection(self, conn_params, auto_login=True, headers=None): DCNL 'Check out or create connection to redirected NVP API server. DCNL Args: DCNL conn_params: tuple specifying target of redirect, see DCNL self._conn_params() DCNL auto_login: returned connection should have valid session cookie DCNL headers: headers to pass on if auto_login DCNL Returns: An available HTTPConnection instance corresponding to the DCNL specified conn_params. If a connection did not previously DCNL exist, new connections are created with the highest prioity DCNL in the connection pool and one of these new connections DCNL returned.'
def _login(self, conn=None, headers=None): DCNL 'Issue login request and update authentication cookie.'
def _issue_request(self): DCNL 'Issue a request to a provider.'
def _redirect_params(self, conn, headers, allow_release_conn=False): DCNL 'Process redirect response, create new connection if necessary. DCNL Args: DCNL conn: connection that returned the redirect response DCNL headers: response headers of the redirect response DCNL allow_release_conn: if redirecting to a different server, DCNL release existing connection back to connection pool. DCNL Returns: Return tuple(conn, url) where conn is a connection object DCNL to the redirect target and url is the path of the API request'
def _rid(self): DCNL 'Return current request id.'
@property DCNL def request_error(self): DCNL 'Return any errors associated with this instance.'
def _request_str(self, conn, url): DCNL 'Return string representation of connection.'
def prevent_network_gateway_port_deletion(self, context, port): DCNL 'Pre-deletion check. DCNL Ensures a port will not be deleted if is being used by a network DCNL gateway. In that case an exception will be raised.'
def create_network(self, context, network): DCNL 'Create network core Quantum API'
def update_network(self, context, net_id, network): DCNL 'Update network core Quantum API'
def delete_network(self, context, net_id): DCNL 'Delete network core Quantum API'
def create_port(self, context, port): DCNL 'Create port core Quantum API'
def update_port(self, context, port_id, port): DCNL 'Update port core Quantum API'
def delete_port(self, context, port_id): DCNL 'Delete port core Quantum API'
def create_subnet(self, context, subnet): DCNL 'Create subnet core Quantum API'
def delete_subnet(self, context, subnet_id): DCNL 'Delete subnet core Quantum API'
def update_subnet(self, context, subnet_id, subnet): DCNL 'Update subnet core Quantum API'
def device_exists(self, device): DCNL 'Check if ethernet device exists.'
def ensure_vlan_bridge(self, network_id, physical_interface, vlan_id): DCNL 'Create a vlan and bridge unless they already exist.'
def ensure_flat_bridge(self, network_id, physical_interface): DCNL 'Create a non-vlan bridge unless it already exists.'
def ensure_local_bridge(self, network_id): DCNL 'Create a local bridge unless it already exists.'
def ensure_vlan(self, physical_interface, vlan_id): DCNL 'Create a vlan unless it already exists.'
def ensure_bridge(self, bridge_name, interface=None, ips=None, gateway=None): DCNL 'Create a bridge unless it already exists.'
def add_tap_interface(self, network_id, physical_network, vlan_id, tap_device_name): DCNL 'If a VIF has been plugged into a network, this function will DCNL add the corresponding tap device to the relevant bridge'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def get_device_details(self, rpc_context, **kwargs): DCNL 'Agent requests device details'
def update_device_down(self, rpc_context, **kwargs): DCNL 'Device no longer exists on agent'
def update_device_up(self, rpc_context, **kwargs): DCNL 'Device is up on agent'
def __init__(self, host='127.0.0.1', port=8888, use_ssl=False, key_file=None, cert_file=None): DCNL 'Creates a new client to some OFC. DCNL :param host: The host where service resides DCNL :param port: The port where service resides DCNL :param use_ssl: True to use SSL, False to use HTTP DCNL :param key_file: The SSL key file to use if use_ssl is true DCNL :param cert_file: The SSL cert file to use if use_ssl is true'
def get_connection_type(self): DCNL 'Returns the proper connection type'
def _generate_pfc_str(self, raw_str): DCNL 'Generate PFC acceptable String'
def _generate_pfc_id(self, id_str): DCNL 'Generate ID on PFC DCNL Currently, PFC ID must be less than 32. DCNL Shorten UUID string length from 36 to 31 by follows: DCNL * delete UUID Version and hyphen (see RFC4122) DCNL * ensure str length'
def _generate_pfc_description(self, desc): DCNL 'Generate Description on PFC DCNL Currently, PFC Description must be less than 128.'
def update_ports(self, context, agent_id, datapath_id, port_added, port_removed): DCNL 'RPC to update information of ports on Quantum Server'
def __init__(self, integ_br, root_helper, polling_interval): DCNL 'Constructor. DCNL :param integ_br: name of the integration bridge. DCNL :param root_helper: utility to use when running shell cmds. DCNL :param polling_interval: interval (secs) to check the bridge.'
def daemon_loop(self): DCNL 'Main processing loop for NEC Plugin Agent.'
def _update_resource_status(self, context, resource, id, status): DCNL 'Update status of specified resource.'
def activate_port_if_ready(self, context, port, network=None): DCNL 'Activate port by creating port on OFC if ready. DCNL Activate port and packet_filters associated with the port. DCNL Conditions to activate port on OFC are: DCNL * port admin_state is UP DCNL * network admin_state is UP DCNL * portinfo are available (to identify port on OFC)'
def deactivate_port(self, context, port): DCNL 'Deactivate port by deleting port from OFC if exists. DCNL Deactivate port and packet_filters associated with the port.'
def create_network(self, context, network): DCNL 'Create a new network entry on DB, and create it on OFC.'
def update_network(self, context, id, network): DCNL 'Update network and handle resources associated with the network. DCNL Update network entry on DB. If \'admin_state_up\' was changed, activate DCNL or deactivate ports and packetfilters associated with the network.'
def delete_network(self, context, id): DCNL 'Delete network and packet_filters associated with the network. DCNL Delete network entry from DB and OFC. Then delete packet_filters DCNL associated with the network. If the network is the last resource DCNL of the tenant, delete unnessary ofc_tenant.'
def create_port(self, context, port): DCNL 'Create a new port entry on DB, then try to activate it.'
def update_port(self, context, id, port): DCNL 'Update port, and handle packetfilters associated with the port. DCNL Update network entry on DB. If admin_state_up was changed, activate DCNL or deactivate the port and packetfilters associated with it.'
def delete_port(self, context, id, l3_port_check=True): DCNL 'Delete port and packet_filters associated with the port.'
def _activate_packet_filter_if_ready(self, context, packet_filter, network=None, in_port=None): DCNL 'Activate packet_filter by creating filter on OFC if ready. DCNL Conditions to create packet_filter on OFC are: DCNL * packet_filter admin_state is UP DCNL * network admin_state is UP DCNL * (if \'in_port\' is specified) portinfo is available'
def _deactivate_packet_filter(self, context, packet_filter): DCNL 'Deactivate packet_filter by deleting filter from OFC if exixts.'
def create_packet_filter(self, context, packet_filter): DCNL 'Create a new packet_filter entry on DB, then try to activate it.'
def update_packet_filter(self, context, id, packet_filter): DCNL 'Update packet_filter entry on DB, and recreate it if changed. DCNL If any rule of the packet_filter was changed, recreate it on OFC.'
def delete_packet_filter(self, context, id): DCNL 'Deactivate and delete packet_filter.'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def update_ports(self, rpc_context, **kwargs): DCNL 'Update ports\' information and activate/deavtivate them. DCNL Expected input format is: DCNL {\'topic\': \'q-agent-notifier\', DCNL \'agent_id\': \'nec-q-agent.\' + <hostname>, DCNL \'datapath_id\': <datapath_id of br-int on remote host>, DCNL \'port_added\': [<new PortInfo>,...], DCNL \'port_removed\': [<removed Port ID>,...]}'
@abstractmethod DCNL def create_tenant(self, description, tenant_id=None): DCNL 'Create a new tenant at OpenFlow Controller. DCNL :param description: A description of this tenant. DCNL :param tenant_id: A hint of OFC tenant ID. DCNL A driver could use this id as a OFC id or ignore it. DCNL :returns: ID of the tenant created at OpenFlow Controller. DCNL :raises: quantum.plugin.nec.common.exceptions.OFCException'
@abstractmethod DCNL def delete_tenant(self, ofc_tenant_id): DCNL 'Delete a tenant at OpenFlow Controller. DCNL :raises: quantum.plugin.nec.common.exceptions.OFCException'
@abstractmethod DCNL def create_network(self, ofc_tenant_id, description, network_id=None): DCNL 'Create a new network on specified OFC tenant at OpenFlow Controller. DCNL :param ofc_tenant_id: a OFC tenant ID in which a new network belongs. DCNL :param description: A description of this network. DCNL :param network_id: A hint of an ID of OFC network. DCNL :returns: ID of the network created at OpenFlow Controller. DCNL ID returned must be unique in the OpenFlow Controller. DCNL If a network is identified in conjunction with other information DCNL such as a tenant ID, such information should be included in the ID. DCNL :raises: quantum.plugin.nec.common.exceptions.OFCException'
@abstractmethod DCNL def delete_network(self, ofc_network_id): DCNL 'Delete a netwrok at OpenFlow Controller. DCNL :raises: quantum.plugin.nec.common.exceptions.OFCException'
@abstractmethod DCNL def create_port(self, ofc_network_id, portinfo, port_id=None): DCNL 'Create a new port on specified network at OFC. DCNL :param ofc_network_id: a OFC tenant ID in which a new port belongs. DCNL :param portinfo: An OpenFlow information of this port. DCNL {\'datapath_id\': Switch ID that a port connected. DCNL \'port_no\': Port Number that a port connected on a Swtich. DCNL \'vlan_id\': VLAN ID that a port tagging. DCNL \'mac\': Mac address. DCNL :param port_id: A hint of an ID of OFC port. DCNL ID returned must be unique in the OpenFlow Controller. DCNL If a port is identified in combination with a network or DCNL a tenant, such information should be included in the ID. DCNL :returns: ID of the port created at OpenFlow Controller. DCNL :raises: quantum.plugin.nec.common.exceptions.OFCException'
@abstractmethod DCNL def delete_port(self, ofc_port_id): DCNL 'Delete a port at OpenFlow Controller. DCNL :raises: quantum.plugin.nec.common.exceptions.OFCException'
@abstractmethod DCNL def convert_ofc_tenant_id(self, context, ofc_tenant_id): DCNL 'Convert old-style ofc tenand id to new-style one. DCNL :param context: quantum context object DCNL :param ofc_tenant_id: ofc_tenant_id to be converted'
@abstractmethod DCNL def convert_ofc_network_id(self, context, ofc_network_id, tenant_id): DCNL 'Convert old-style ofc network id to new-style one. DCNL :param context: quantum context object DCNL :param ofc_network_id: ofc_network_id to be converted DCNL :param tenant_id: quantum tenant_id of the network'
@abstractmethod DCNL def convert_ofc_port_id(self, context, ofc_port_id, tenant_id, network_id): DCNL 'Convert old-style ofc port id to new-style one. DCNL :param context: quantum context object DCNL :param ofc_port_id: ofc_port_id to be converted DCNL :param tenant_id: quantum tenant_id of the port DCNL :param network_id: quantum network_id of the port'
def _find_key(self, session, last_key): DCNL 'Try to find unused tunnel key in TunnelKey table starting DCNL from last_key + 1. DCNL When all keys are used, raise sqlalchemy.orm.exc.NoResultFound'
def sync_vlan_allocations(self, network_vlan_ranges): DCNL 'Synchronize vlan_allocations table with configured VLAN ranges'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def get_device_details(self, rpc_context, **kwargs): DCNL 'Agent requests device details'
def update_device_down(self, rpc_context, **kwargs): DCNL 'Device no longer exists on agent'
def tunnel_sync(self, rpc_context, **kwargs): DCNL 'Dummy function for ovs agent running on Linux to DCNL work with Hyper-V plugin and agent.'
def _check_job_status(self, ret_val, jobpath): DCNL 'Poll WMI job state for completion'
def _create_switch_port(self, vswitch_name, switch_port_name): DCNL 'Creates a switch port'
def disconnect_switch_port(self, vswitch_name, switch_port_name, delete_port): DCNL 'Disconnects the switch port'
def __eq__(self, other): DCNL 'Compare only fields that will cause us to re-wire.'
def __init__(self, integ_br, tun_br, local_ip, bridge_mappings, root_helper, polling_interval, enable_tunneling): DCNL 'Constructor. DCNL :param integ_br: name of the integration bridge. DCNL :param tun_br: name of the tunnel bridge. DCNL :param local_ip: local IP address of this hypervisor. DCNL :param bridge_mappings: mappings from physical network name to bridge. DCNL :param root_helper: utility to use when running shell cmds. DCNL :param polling_interval: interval (secs) to poll DB. DCNL :param enable_tunneling: if True enable GRE networks.'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def provision_local_vlan(self, net_uuid, network_type, physical_network, segmentation_id): DCNL 'Provisions a local VLAN. DCNL :param net_uuid: the uuid of the network associated with this vlan. DCNL :param network_type: the network type (\'gre\', \'vlan\', \'flat\', \'local\') DCNL :param physical_network: the physical network for \'vlan\' or \'flat\' DCNL :param segmentation_id: the VID for \'vlan\' or tunnel ID for \'tunnel\''
def reclaim_local_vlan(self, net_uuid, lvm): DCNL 'Reclaim a local VLAN. DCNL :param net_uuid: the network uuid associated with this vlan. DCNL :param lvm: a LocalVLANMapping object that tracks (vlan, lsw_id, DCNL vif_ids) mapping.'
def port_bound(self, port, net_uuid, network_type, physical_network, segmentation_id): DCNL 'Bind port to net_uuid/lsw_id and install flow for inbound traffic DCNL to vm. DCNL :param port: a ovslib.VifPort object. DCNL :param net_uuid: the net_uuid this port is to be associated with. DCNL :param network_type: the network type (\'gre\', \'vlan\', \'flat\', \'local\') DCNL :param physical_network: the physical network for \'vlan\' or \'flat\' DCNL :param segmentation_id: the VID for \'vlan\' or tunnel ID for \'tunnel\''
def port_unbound(self, vif_id, net_uuid=None): DCNL 'Unbind port. DCNL Removes corresponding local vlan mapping object if this is its last DCNL VIF. DCNL :param vif_id: the id of the vif DCNL :param net_uuid: the net_uuid this port is associated with.'
def port_dead(self, port): DCNL 'Once a port has no binding, put it on the "dead vlan". DCNL :param port: a ovs_lib.VifPort object.'
def setup_integration_br(self, bridge_name): DCNL 'Setup the integration bridge. DCNL Create patch ports and remove all existing flows. DCNL :param bridge_name: the name of the integration bridge. DCNL :returns: the integration bridge'
def setup_tunnel_br(self, tun_br): DCNL 'Setup the tunnel bridge. DCNL Creates tunnel bridge, and links it to the integration bridge DCNL using a patch port. DCNL :param tun_br: the name of the tunnel bridge.'
def setup_physical_bridges(self, bridge_mappings): DCNL 'Setup the physical network bridges. DCNL Creates physical network bridges and links them to the DCNL integration bridge using veths. DCNL :param bridge_mappings: map physical network names to bridge names.'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def get_device_details(self, rpc_context, **kwargs): DCNL 'Agent requests device details'
def update_device_down(self, rpc_context, **kwargs): DCNL 'Device no longer exists on agent'
def update_device_up(self, rpc_context, **kwargs): DCNL 'Device is up on agent'
def tunnel_sync(self, rpc_context, **kwargs): DCNL 'Update new tunnel. DCNL Updates the datbase with the tunnel IP. All listening agents will also DCNL be notified about the new tunnel IP.'
def _get_state_file_path(self, pool_id, kind, ensure_state_dir=True): DCNL 'Returns the file name for a given kind of config file.'
def reload_pool(self, context, pool_id=None, host=None): DCNL 'Handle RPC cast from plugin to reload a pool.'
def modify_pool(self, context, pool_id=None, host=None): DCNL 'Handle RPC cast from plugin to modify a pool if known to agent.'
def destroy_pool(self, context, pool_id=None, host=None): DCNL 'Handle RPC cast from plugin to destroy a pool if known to agent.'
def pool_destroyed(self, context, pool_id=None, host=None): DCNL 'Agent confirmation hook that a pool has been destroyed. DCNL This method exists for subclasses to change the deletion DCNL behavior.'
def __init__(self): DCNL 'Do the initialization for the loadbalancer service plugin here.'
@abc.abstractmethod DCNL def get_plugin_type(self): DCNL 'returns one of predefine service types. see DCNL quantum/plugins/common/constants.py'
@abc.abstractmethod DCNL def get_plugin_name(self): DCNL 'return a symbolic name for the plugin. DCNL Each service plugin should have a symbolic name. This name DCNL will be used, for instance, by service definitions in service types'
@abc.abstractmethod DCNL def get_plugin_description(self): DCNL 'returns string description of the plugin'
def __init__(self, ctxt): DCNL 'initialize the vlan as a set.'
def get_next_vlan(self, vlan_id=None): DCNL 'try to get a specific vlan if requested DCNL or get the next vlan.'
def release_vlan(self, vlan_id): DCNL 'return the vlan to the pool.'
def connect(self, host, username, password): DCNL 'Connect via SSH and initialize the NETCONF session.'
def create_network(self, host, username, password, net_id): DCNL 'Creates a new virtual network.'
def delete_network(self, host, username, password, net_id): DCNL 'Deletes a virtual network.'
def associate_mac_to_network(self, host, username, password, net_id, mac): DCNL 'Associates a MAC address to virtual network.'
def dissociate_mac_from_network(self, host, username, password, net_id, mac): DCNL 'Dissociates a MAC address from virtual network.'
def create_vlan_interface(self, mgr, vlan_id): DCNL 'Configures a VLAN interface.'
def delete_vlan_interface(self, mgr, vlan_id): DCNL 'Deletes a VLAN interface.'
def get_port_profiles(self, mgr): DCNL 'Retrieves all port profiles.'
def get_port_profile(self, mgr, name): DCNL 'Retrieves a port profile.'
def create_port_profile(self, mgr, name): DCNL 'Creates a port profile.'
def delete_port_profile(self, mgr, name): DCNL 'Deletes a port profile.'
def activate_port_profile(self, mgr, name): DCNL 'Activates a port profile.'
def deactivate_port_profile(self, mgr, name): DCNL 'Deactivates a port profile.'
def associate_mac_to_port_profile(self, mgr, name, mac_address): DCNL 'Associates a MAC address to a port profile.'
def dissociate_mac_from_port_profile(self, mgr, name, mac_address): DCNL 'Dissociates a MAC address from a port profile.'
def create_vlan_profile_for_port_profile(self, mgr, name): DCNL 'Creates VLAN sub-profile for port profile.'
def configure_l2_mode_for_vlan_profile(self, mgr, name): DCNL 'Configures L2 mode for VLAN sub-profile.'
def configure_trunk_mode_for_vlan_profile(self, mgr, name): DCNL 'Configures trunk mode for VLAN sub-profile.'
def configure_allowed_vlans_for_vlan_profile(self, mgr, name, vlan_id): DCNL 'Configures allowed VLANs for VLAN sub-profile.'
def connect(self, host, username, password): DCNL 'Connect via SSH and initialize the NETCONF session.'
def create_network(self, host, username, password, net_id): DCNL 'Creates a new virtual network.'
def delete_network(self, host, username, password, net_id): DCNL 'Deletes a virtual network.'
def associate_mac_to_network(self, host, username, password, net_id, mac): DCNL 'Associates a MAC address to virtual network.'
def dissociate_mac_from_network(self, host, username, password, net_id, mac): DCNL 'Dissociates a MAC address from virtual network.'
def create_vlan_interface(self, mgr, vlan_id): DCNL 'Configures a VLAN interface.'
def delete_vlan_interface(self, mgr, vlan_id): DCNL 'Deletes a VLAN interface.'
def get_port_profiles(self, mgr): DCNL 'Retrieves all port profiles.'
def get_port_profile(self, mgr, name): DCNL 'Retrieves a port profile.'
def create_port_profile(self, mgr, name): DCNL 'Creates a port profile.'
def delete_port_profile(self, mgr, name): DCNL 'Deletes a port profile.'
def activate_port_profile(self, mgr, name): DCNL 'Activates a port profile.'
def deactivate_port_profile(self, mgr, name): DCNL 'Deactivates a port profile.'
def associate_mac_to_port_profile(self, mgr, name, mac_address): DCNL 'Associates a MAC address to a port profile.'
def dissociate_mac_from_port_profile(self, mgr, name, mac_address): DCNL 'Dissociates a MAC address from a port profile.'
def create_vlan_profile_for_port_profile(self, mgr, name): DCNL 'Creates VLAN sub-profile for port profile.'
def configure_l2_mode_for_vlan_profile(self, mgr, name): DCNL 'Configures L2 mode for VLAN sub-profile.'
def configure_trunk_mode_for_vlan_profile(self, mgr, name): DCNL 'Configures trunk mode for VLAN sub-profile.'
def configure_allowed_vlans_for_vlan_profile(self, mgr, name, vlan_id): DCNL 'Configures allowed VLANs for VLAN sub-profile.'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
@classmethod DCNL def get_port_from_device(cls, device): DCNL 'Get port from the brocade specific db.'
def get_device_details(self, rpc_context, **kwargs): DCNL 'Agent requests device details.'
def update_device_down(self, rpc_context, **kwargs): DCNL 'Device no longer exists on agent.'
def __init__(self): DCNL 'Initialize Brocade Plugin, specify switch address DCNL and db configuration.'
def brocade_init(self): DCNL 'Brocade specific initialization.'
def create_network(self, context, network): DCNL 'This call to create network translates to creation of DCNL port-profile on the physical switch.'
def delete_network(self, context, net_id): DCNL 'This call to delete the network translates to removing DCNL the port-profile on the physical switch.'
def create_port(self, context, port): DCNL 'Create logical port on the switch.'
def get_plugin_version(self): DCNL 'Get version number of the plugin.'
@staticmethod DCNL def mac_reformat_62to34(interface_mac): DCNL 'Transform MAC address format. DCNL Transforms from 6 groups of 2 hexadecimal numbers delimited by ":" DCNL to 3 groups of 4 hexadecimals numbers delimited by ".". DCNL :param interface_mac: MAC address in the format xx:xx:xx:xx:xx:xx DCNL :type interface_mac: string DCNL :returns: MAC address in the format xxxx.xxxx.xxxx DCNL :rtype: string'
def __init__(self): DCNL 'Initialize the segmentation manager, check which device plugins are DCNL configured, and load the inventories those device plugins for which the DCNL inventory is configured'
def __getattribute__(self, name): DCNL 'This delegates the calls to the methods implemented only by the OVS DCNL sub-plugin. Note: Currently, bulking is handled by the caller DCNL (PluginV2), and this model class expects to receive only non-bulking DCNL calls. If, however, a bulking call is made, this will method will DCNL delegate the call to the OVS plugin.'
def _func_name(self, offset=0): DCNL 'Get the name of the calling function'
def _invoke_plugin_per_device(self, plugin_key, function_name, args): DCNL 'Invokes a device plugin\'s relevant functions (on the it\'s DCNL inventory and plugin implementation) for completing this operation.'
def _invoke_inventory(self, plugin_key, function_name, args): DCNL 'Invokes the relevant function on a device plugin\'s DCNL inventory for completing this operation.'
def _invoke_plugin(self, plugin_key, function_name, args, kwargs): DCNL 'Invokes the relevant function on a device plugin\'s DCNL implementation for completing this operation.'
def create_network(self, context, network): DCNL 'Perform this operation in the context of the configured device DCNL plugins.'
def update_network(self, context, id, network): DCNL 'Perform this operation in the context of the configured device DCNL plugins.'
def delete_network(self, context, id): DCNL 'Perform this operation in the context of the configured device DCNL plugins.'
def get_network(self, context, id, fields=None): DCNL 'For this model this method will be delegated to vswitch plugin'
def get_networks(self, context, filters=None, fields=None): DCNL 'For this model this method will be delegated to vswitch plugin'
def create_port(self, context, port): DCNL 'Perform this operation in the context of the configured device DCNL plugins.'
def get_port(self, context, id, fields=None): DCNL 'For this model this method will be delegated to vswitch plugin'
def get_ports(self, context, filters=None, fields=None): DCNL 'For this model this method will be delegated to vswitch plugin'
def update_port(self, context, id, port): DCNL 'Perform this operation in the context of the configured device DCNL plugins.'
def delete_port(self, context, id): DCNL 'Perform this operation in the context of the configured device DCNL plugins.'
def create_subnet(self, context, subnet): DCNL 'For this model this method will be delegated to vswitch plugin'
def update_subnet(self, context, id, subnet): DCNL 'For this model this method will be delegated to vswitch plugin'
def get_subnet(self, context, id, fields=None): DCNL 'For this model this method will be delegated to vswitch plugin'
def delete_subnet(self, context, id, kwargs): DCNL 'For this model this method will be delegated to vswitch plugin'
def get_subnets(self, context, filters=None, fields=None): DCNL 'For this model this method will be delegated to vswitch plugin'
@staticmethod DCNL def put_credential(cred_name, username, password): DCNL 'Set the username and password'
@staticmethod DCNL def get_username(cred_name): DCNL 'Get the username'
@staticmethod DCNL def get_password(cred_name): DCNL 'Get the password'
@staticmethod DCNL def get_credential(cred_name): DCNL 'Get the username and password'
@staticmethod DCNL def delete_credential(cred_name): DCNL 'Delete a credential'
def __init__(self, exception): DCNL 'Create a Fault for the given webob.exc.exception.'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req): DCNL 'Generate a WSGI response based on the DCNL exception passed to constructor.'
def dummy(self, section, key): DCNL 'Dummy function to return the same key, used in walk'
def __setitem__(self, key, value): DCNL 'Internal Dict set method'
def __getitem__(self, key): DCNL 'Internal Dict get method'
def get(self, key, default=None): DCNL 'Dict get method'
def __iter__(self): DCNL 'Iterate over table columns'
def next(self): DCNL 'Next method for the iterator'
def update(self, values): DCNL 'Make the model object behave like a dict'
def iteritems(self): DCNL 'Make the model object behave like a dict" DCNL Includes attributes from joins.'
def update(self, values): DCNL 'Make the model object behave like a dict'
def iteritems(self): DCNL 'Make the model object behave like a dict. DCNL Includes attributes from joins.'
def __setitem__(self, key, value): DCNL 'Internal Dict set method'
def __getitem__(self, key): DCNL 'Internal Dict get method'
def get(self, key, default=None): DCNL 'Dict get method'
def __iter__(self): DCNL 'Iterate over table columns'
def next(self): DCNL 'Next method for the iterator'
def update(self, values): DCNL 'Make the model object behave like a dict'
def iteritems(self): DCNL 'Make the model object behave like a dict" DCNL Includes attributes from joins.'
def create_request(self, path, body, content_type, method='GET'): DCNL 'Test create request'
def _create_network(self, name=None): DCNL 'Test create network'
def _create_port(self, network_id, port_state): DCNL 'Test create port'
def _delete_port(self, network_id, port_id): DCNL 'Delete port'
def _delete_network(self, network_id): DCNL 'Delete network'
def tear_down_port_network(self, net_id, port_id): DCNL 'Tear down port and network'
def setUp(self): DCNL 'Set up function'
def test_create_qos(self): DCNL 'Test create qos'
def test_create_qosBADRequest(self): DCNL 'Test create qos bad request'
def test_list_qoss(self): DCNL 'Test list qoss'
def test_show_qos(self): DCNL 'Test show qos'
def test_show_qosDNE(self, qos_id='100'): DCNL 'Test show qos does not exist'
def test_update_qos(self): DCNL 'Test update qos'
def test_update_qosDNE(self, qos_id='100'): DCNL 'Test update qos does not exist'
def test_update_qosBADRequest(self): DCNL 'Test update qos bad request'
def test_delete_qos(self): DCNL 'Test delte qos'
def test_delete_qosDNE(self, qos_id='100'): DCNL 'Test delte qos does not exist'
def tearDownQos(self, delete_profile_path): DCNL 'Tear Down Qos'
def setUp(self): DCNL 'Set up function'
def test_list_credentials(self): DCNL 'Test list credentials'
def test_create_credential(self): DCNL 'Test create credential'
def test_create_credentialBADRequest(self): DCNL 'Test create credential bad request'
def test_show_credential(self): DCNL 'Test show credential'
def test_show_credentialDNE(self, credential_id='100'): DCNL 'Test show credential does not exist'
def test_update_credential(self): DCNL 'Test update credential'
def test_update_credBADReq(self): DCNL 'Test update credential bad request'
def test_update_credentialDNE(self, credential_id='100'): DCNL 'Test update credential does not exist'
def test_delete_credential(self): DCNL 'Test delete credential'
def test_delete_credentialDNE(self, credential_id='100'): DCNL 'Test delete credential does not exist'
def nxos_connect(self, nexus_host, nexus_ssh_port, nexus_user, nexus_password): DCNL 'Makes the fake connection to the Nexus Switch'
def create_xml_snippet(self, cutomized_config): DCNL 'Creates the Proper XML structure for the Nexus Switch Configuration'
def enable_vlan(self, mgr, vlanid, vlanname): DCNL 'Creates a VLAN on Nexus Switch given the VLAN ID and Name'
def disable_vlan(self, mgr, vlanid): DCNL 'Delete a VLAN on Nexus Switch given the VLAN ID'
def enable_port_trunk(self, mgr, interface): DCNL 'Enables trunk mode an interface on Nexus Switch'
def disable_switch_port(self, mgr, interface): DCNL 'Disables trunk mode an interface on Nexus Switch'
def enable_vlan_on_trunk_int(self, mgr, interface, vlanid): DCNL 'Enables trunk mode vlan access an interface on Nexus Switch given DCNL VLANID'
def disable_vlan_on_trunk_int(self, mgr, interface, vlanid): DCNL 'Enables trunk mode vlan access an interface on Nexus Switch given DCNL VLANID'
def create_vlan(self, vlan_name, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port, vlan_ids): DCNL 'Creates a VLAN and Enable on trunk mode an interface on Nexus Switch DCNL given the VLAN ID and Name and Interface Number'
def delete_vlan(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port): DCNL 'Delete a VLAN and Disables trunk mode an interface on Nexus Switch DCNL given the VLAN ID and Interface Number'
def build_vlans_cmd(self): DCNL 'Builds a string with all the VLANs on the same Switch'
def add_vlan_int(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port, vlan_ids=None): DCNL 'Adds a vlan from interfaces on the Nexus switch given the VLAN ID'
def remove_vlan_int(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port): DCNL 'Removes a vlan from interfaces on the Nexus switch given the VLAN ID'
def get_all_nexusportbindings(self): DCNL 'get all nexus port bindings'
def get_nexusportbinding(self, vlan_id): DCNL 'get nexus port binding'
def create_nexusportbinding(self, port_id, vlan_id): DCNL 'create nexus port binding'
def delete_nexusportbinding(self, vlan_id): DCNL 'delete nexus port binding'
def update_nexusport_binding(self, port_id, new_vlan_id): DCNL 'update nexus port binding'
def get_all_vlan_bindings(self): DCNL 'Get all vlan binding into a list of dict'
def get_vlan_binding(self, network_id): DCNL 'Get a vlan binding'
def create_vlan_binding(self, vlan_id, vlan_name, network_id): DCNL 'Create a vlan binding'
def delete_vlan_binding(self, network_id): DCNL 'Delete a vlan binding'
def update_vlan_binding(self, network_id, vlan_id, vlan_name): DCNL 'Update a vlan binding'
def get_all_networks(self, tenant_id): DCNL 'Get all networks'
def get_network(self, network_id): DCNL 'Get a network'
def create_network(self, tenant_id, net_name): DCNL 'Create a network'
def delete_network(self, net_id): DCNL 'Delete a network'
def update_network(self, tenant_id, net_id, **kwargs): DCNL 'Update a network'
def get_all_ports(self, net_id): DCNL 'Get all ports'
def get_port(self, net_id, port_id): DCNL 'Get a port'
def create_port(self, net_id): DCNL 'Add a port'
def delete_port(self, net_id, port_id): DCNL 'Delete a port'
def update_port(self, net_id, port_id, port_state): DCNL 'Update a port'
def plug_interface(self, net_id, port_id, int_id): DCNL 'Plug interface to a port'
def unplug_interface(self, net_id, port_id): DCNL 'Unplug interface to a port'
def testa_create_nexusportbinding(self): DCNL 'create nexus port binding'
def testb_getall_nexusportbindings(self): DCNL 'get all nexus port binding'
def testc_delete_nexusportbinding(self): DCNL 'delete nexus port binding'
def testd_update_nexusportbinding(self): DCNL 'update nexus port binding'
def tearDown_nexusportbinding(self): DCNL 'tear down nexusport binding table'
def setUp(self): DCNL 'Setup for tests'
def testa_create_vlanbinding(self): DCNL 'test add vlan binding'
def testb_getall_vlanbindings(self): DCNL 'test get all vlan binding'
def testc_delete_vlanbinding(self): DCNL 'test delete vlan binding'
def testd_update_vlanbinding(self): DCNL 'test update vlan binding'
def testm_test_vlanids(self): DCNL 'test vlanid methods'
def teardown_network(self): DCNL 'tearDown Network table'
def teardown_port(self): DCNL 'tearDown Port table'
def teardown_vlanbinding(self): DCNL 'tearDown VlanBinding table'
def setUp(self): DCNL 'Setup for tests'
def testa_create_network(self): DCNL 'test to create network'
def testb_get_networks(self): DCNL 'test to get all networks'
def testc_delete_network(self): DCNL 'test to delete network'
def testd_update_network(self): DCNL 'test to update (rename) network'
def teste_create_port(self): DCNL 'test to create port'
def testf_delete_port(self): DCNL 'test to delete port'
def testg_plug_unplug_interface(self): DCNL 'test to plug/unplug interface'
def testh_joined_test(self): DCNL 'test to get network and port'
def teardown_network_port(self): DCNL 'tearDown for Network and Port table'
def teardown_joined_test(self): DCNL 'tearDown for joined Network and Port test'
@abstractmethod DCNL def get_all_networks(self, tenant_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def create_network(self, tenant_id, net_name, net_id, vlan_name, vlan_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def delete_network(self, tenant_id, net_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def get_network_details(self, tenant_id, net_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def update_network(self, tenant_id, net_id, name, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def get_all_ports(self, tenant_id, net_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def create_port(self, tenant_id, net_id, port_state, port_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def delete_port(self, tenant_id, net_id, port_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def update_port(self, tenant_id, net_id, port_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def get_port_details(self, tenant_id, net_id, port_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def plug_interface(self, tenant_id, net_id, port_id, remote_interface_id, **kwargs): DCNL ':returns: DCNL :raises:'
@abstractmethod DCNL def unplug_interface(self, tenant_id, net_id, port_id, **kwargs): DCNL ':returns: DCNL :raises:'
def create_subnet(self, tenant_id, net_id, ip_version, subnet_cidr, **kwargs): DCNL ':returns: DCNL :raises:'
def get_subnets(self, tenant_id, net_id, **kwargs): DCNL ':returns: DCNL :raises:'
def get_subnet(self, tenant_id, net_id, subnet_id, **kwargs): DCNL ':returns: DCNL :raises:'
def update_subnet(self, tenant_id, net_id, subnet_id, **kwargs): DCNL ':returns: DCNL :raises:'
def delete_subnet(self, tenant_id, net_id, subnet_id, **kwargs): DCNL ':returns: DCNL :raises:'
@classmethod DCNL def __subclasshook__(cls, klass): DCNL 'The __subclasshook__ method is a class method DCNL that will be called everytime a class is tested DCNL using issubclass(klass, Plugin). DCNL In that case, it will check that every method DCNL marked with the abstractmethod decorator is DCNL provided by the plugin class.'
def __init__(self): DCNL 'Loads the model class.'
def __getattribute__(self, name): DCNL 'When the configured model class offers to manage the state of the DCNL logical resources, we delegate the core API calls directly to it. DCNL Note: Bulking calls will be handled by this class, and turned into DCNL non-bulking calls to be considered for delegation.'
def __getattr__(self, name): DCNL 'This delegates the calls to the extensions explicitly implemented by DCNL the model.'
def create_network(self, context, network): DCNL 'Creates a new Virtual Network, and assigns it DCNL a symbolic name.'
def update_network(self, context, id, network): DCNL 'Updates the symbolic name belonging to a particular DCNL Virtual Network.'
def delete_network(self, context, id): DCNL 'Deletes the network with the specified network identifier DCNL belonging to the specified tenant.'
def get_network(self, context, id, fields=None): DCNL 'Gets a particular network'
def get_networks(self, context, filters=None, fields=None): DCNL 'Gets all networks'
def create_port(self, context, port): DCNL 'Creates a port on the specified Virtual Network.'
def delete_port(self, context, id): DCNL 'Deletes a port'
def update_port(self, context, id, port): DCNL 'Updates the state of a port and returns the updated port'
def create_subnet(self, context, subnet): DCNL 'Create a subnet, which represents a range of IP addresses DCNL that can be allocated to devices.'
def update_subnet(self, context, id, subnet): DCNL 'Updates the state of a subnet and returns the updated subnet'
def delete_subnet(self, context, id): DCNL 'Deletes a subnet'
def get_all_qoss(self, tenant_id): DCNL 'Get all QoS levels'
def get_qos_details(self, tenant_id, qos_id): DCNL 'Get QoS Details'
def create_qos(self, tenant_id, qos_name, qos_desc): DCNL 'Create a QoS level'
def delete_qos(self, tenant_id, qos_id): DCNL 'Delete a QoS level'
def rename_qos(self, tenant_id, qos_id, new_name): DCNL 'Rename QoS level'
def get_all_credentials(self, tenant_id): DCNL 'Get all credentials'
def get_credential_details(self, tenant_id, credential_id): DCNL 'Get a particular credential'
def create_credential(self, tenant_id, credential_name, user_name, password): DCNL 'Create a new credential'
def delete_credential(self, tenant_id, credential_id): DCNL 'Delete a credential'
def rename_credential(self, tenant_id, credential_id, new_name): DCNL 'Rename the particular credential resource'
def schedule_host(self, tenant_id, instance_id, instance_desc): DCNL 'Provides the hostname on which a dynamic vnic is reserved'
def associate_port(self, tenant_id, instance_id, instance_desc): DCNL 'Get the portprofile name and the device name for the dynamic vnic'
def detach_port(self, tenant_id, instance_id, instance_desc): DCNL 'Remove the association of the VIF with the dynamic vnic'
def _invoke_device_plugins(self, function_name, args): DCNL 'Device-specific calls including core API and extensions are DCNL delegated to the model.'
def _func_name(self, offset=0): DCNL 'Getting the name of the calling funciton'
@classmethod DCNL def get_name(cls): DCNL 'Returns Ext Resource Name'
@classmethod DCNL def get_alias(cls): DCNL 'Returns Ext Resource Alias'
@classmethod DCNL def get_description(cls): DCNL 'Returns Ext Resource Description'
@classmethod DCNL def get_namespace(cls): DCNL 'Returns Ext Resource Namespace'
@classmethod DCNL def get_updated(cls): DCNL 'Returns Ext Resource Update Time'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
def index(self, request, tenant_id): DCNL 'Returns a list of credential ids'
def _items(self, request, tenant_id, is_detail): DCNL 'Returns a list of credentials.'
def show(self, request, tenant_id, id): DCNL 'Returns credential details for the given credential id'
def create(self, request, tenant_id): DCNL 'Creates a new credential for a given tenant'
def update(self, request, tenant_id, id): DCNL 'Updates the name for the credential with the given id'
def delete(self, request, tenant_id, id): DCNL 'Destroys the credential with the given id'
def __init__(self, base_url): DCNL ':param base_url: url of the root wsgi application'
def build(self, credential_data, is_detail=False): DCNL 'Generic method used to generate a credential entity.'
def _build_simple(self, credential_data): DCNL 'Return a simple description of credential.'
def _build_detail(self, credential_data): DCNL 'Return a detailed description of credential.'
def __init__(self, base_url): DCNL ':param base_url: url of the root wsgi application'
def build(self, qos_data, is_detail=False): DCNL 'Generic method used to generate a QoS entity.'
def _build_simple(self, qos_data): DCNL 'Return a simple description of qos.'
def _build_detail(self, qos_data): DCNL 'Return a detailed description of qos.'
@classmethod DCNL def get_name(cls): DCNL 'Returns Ext Resource Name'
@classmethod DCNL def get_alias(cls): DCNL 'Returns Ext Resource Alias'
@classmethod DCNL def get_description(cls): DCNL 'Returns Ext Resource Description'
@classmethod DCNL def get_namespace(cls): DCNL 'Returns Ext Resource Namespace'
@classmethod DCNL def get_updated(cls): DCNL 'Returns Ext Resource update'
@classmethod DCNL def get_resources(cls): DCNL 'Returns Ext Resources'
def index(self, request, tenant_id): DCNL 'Returns a list of qos ids'
def _items(self, request, tenant_id, is_detail): DCNL 'Returns a list of qoss.'
def show(self, request, tenant_id, id): DCNL 'Returns qos details for the given qos id'
def create(self, request, tenant_id): DCNL 'Creates a new qos for a given tenant'
def update(self, request, tenant_id, id): DCNL 'Updates the name for the qos with the given id'
def delete(self, request, tenant_id, id): DCNL 'Destroys the qos with the given id'
def nxos_connect(self, nexus_host, nexus_ssh_port, nexus_user, nexus_password): DCNL 'Makes the SSH connection to the Nexus Switch'
def create_xml_snippet(self, cutomized_config): DCNL 'Creates the Proper XML structure for the Nexus Switch Configuration'
def enable_vlan(self, mgr, vlanid, vlanname): DCNL 'Creates a VLAN on Nexus Switch given the VLAN ID and Name'
def disable_vlan(self, mgr, vlanid): DCNL 'Delete a VLAN on Nexus Switch given the VLAN ID'
def enable_port_trunk(self, mgr, interface): DCNL 'Enables trunk mode an interface on Nexus Switch'
def disable_switch_port(self, mgr, interface): DCNL 'Disables trunk mode an interface on Nexus Switch'
def enable_vlan_on_trunk_int(self, mgr, interface, vlanid): DCNL 'Enables trunk mode vlan access an interface on Nexus Switch given DCNL VLANID'
def disable_vlan_on_trunk_int(self, mgr, interface, vlanid): DCNL 'Enables trunk mode vlan access an interface on Nexus Switch given DCNL VLANID'
def create_vlan(self, vlan_name, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port, vlan_ids=None): DCNL 'Creates a VLAN and Enable on trunk mode an interface on Nexus Switch DCNL given the VLAN ID and Name and Interface Number'
def delete_vlan(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port): DCNL 'Delete a VLAN and Disables trunk mode an interface on Nexus Switch DCNL given the VLAN ID and Interface Number'
def build_vlans_cmd(self): DCNL 'Builds a string with all the VLANs on the same Switch'
def add_vlan_int(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port, vlan_ids=None): DCNL 'Adds a vlan from interfaces on the Nexus switch given the VLAN ID'
def remove_vlan_int(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port): DCNL 'Removes a vlan from interfaces on the Nexus switch given the VLAN ID'
def __init__(self): DCNL 'Extracts the configuration parameters from the configuration file'
def get_all_networks(self, tenant_id): DCNL 'Returns a dictionary containing all DCNL <network_uuid, network_name> for DCNL the specified tenant.'
def create_network(self, tenant_id, net_name, net_id, vlan_name, vlan_id, host, instance): DCNL 'Create a VLAN in the appropriate switch/port, DCNL and configure the appropriate interfaces DCNL for this VLAN'
def delete_network(self, tenant_id, net_id, **kwargs): DCNL 'Deletes the VLAN in all switches, and removes the VLAN configuration DCNL from the relevant interfaces'
def get_network_details(self, tenant_id, net_id, **kwargs): DCNL 'Returns the details of a particular network'
def update_network(self, tenant_id, net_id, **kwargs): DCNL 'Updates the properties of a particular DCNL Virtual Network.'
def get_all_ports(self, tenant_id, net_id, **kwargs): DCNL 'This is probably not applicable to the Nexus plugin. DCNL Delete if not required.'
def create_port(self, tenant_id, net_id, port_state, port_id, **kwargs): DCNL 'This is probably not applicable to the Nexus plugin. DCNL Delete if not required.'
def delete_port(self, device_id, vlan_id): DCNL 'Delete port bindings from the database and scan DCNL whether the network is still required on DCNL the interfaces trunked'
def update_port(self, tenant_id, net_id, port_id, port_state, **kwargs): DCNL 'This is probably not applicable to the Nexus plugin. DCNL Delete if not required.'
def get_port_details(self, tenant_id, net_id, port_id, **kwargs): DCNL 'This is probably not applicable to the Nexus plugin. DCNL Delete if not required.'
def plug_interface(self, tenant_id, net_id, port_id, remote_interface_id, **kwargs): DCNL 'This is probably not applicable to the Nexus plugin. DCNL Delete if not required.'
def unplug_interface(self, tenant_id, net_id, port_id, **kwargs): DCNL 'This is probably not applicable to the Nexus plugin. DCNL Delete if not required.'
def _get_vlan_id_for_network(self, tenant_id, network_id, context, base_plugin_ref): DCNL 'Obtain the VLAN ID given the Network ID'
def _get_network(self, tenant_id, network_id, context, base_plugin_ref): DCNL 'Gets the NETWORK ID'
def _get_quotas(self, context, resources, keys): DCNL 'A helper method which retrieves the quotas for the specific DCNL resources identified by keys, and which apply to the current DCNL context. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param keys: A list of the desired quotas to retrieve.'
def limit_check(self, context, tenant_id, resources, values): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param tennant_id: The tenant_id to check quota. DCNL :param resources: A dictionary of the registered resources. DCNL :param values: A dictionary of the values to check against the DCNL quota.'
def __init__(self, name, flag): DCNL 'Initializes a Resource. DCNL :param name: The name of the resource, i.e., "instances". DCNL :param flag: The name of the flag or configuration option'
@property DCNL def default(self): DCNL 'Return the default value of the quota.'
def __init__(self, name, count, flag=None): DCNL 'Initializes a CountableResource. DCNL Countable resources are those resources which directly DCNL correspond to objects in the database, i.e., netowk, subnet, DCNL etc.,.  A CountableResource must be constructed with a counting DCNL function, which will be called to determine the current counts DCNL of the resource. DCNL The counting function will be passed the context, along with DCNL the extra positional and keyword arguments that are passed to DCNL Quota.count().  It should return an integer specifying the DCNL count. DCNL :param name: The name of the resource, i.e., "instances". DCNL :param count: A callable which returns the count of the DCNL resource.  The arguments passed are as described DCNL above. DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def __init__(self, quota_driver_class=None): DCNL 'Initialize a Quota object.'
def register_resource(self, resource): DCNL 'Register a resource.'
def register_resource_by_name(self, resourcename): DCNL 'Register a resource by name.'
def register_resources(self, resources): DCNL 'Register a list of resources.'
def count(self, context, resource, *args, **kwargs): DCNL 'Count a resource. DCNL For countable resources, invokes the count() function and DCNL returns its result.  Arguments following the context and DCNL resource are passed directly to the count function declared by DCNL the resource. DCNL :param context: The request context, for access checks. DCNL :param resource: The name of the resource, as a string.'
def limit_check(self, context, tenant_id, **values): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction.  The DCNL values to check are given as keyword arguments, where the key DCNL identifies the specific quota limit to check, and the value is DCNL the proposed value. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks.'
@abstractmethod DCNL def create_subnet(self, context, subnet): DCNL 'Create a subnet, which represents a range of IP addresses DCNL that can be allocated to devices DCNL : param context: quantum api request context DCNL : param subnet: dictionary describing the subnet, with keys DCNL as listed in the RESOURCE_ATTRIBUTE_MAP object in DCNL quantum/api/v2/attributes.py.  All keys will be populated.'
@abstractmethod DCNL def update_subnet(self, context, id, subnet): DCNL 'Update values of a subnet. DCNL : param context: quantum api request context DCNL : param id: UUID representing the subnet to update. DCNL : param subnet: dictionary with keys indicating fields to update. DCNL valid keys are those that have a value of True for \'allow_put\' DCNL as listed in the RESOURCE_ATTRIBUTE_MAP object in DCNL quantum/api/v2/attributes.py.'
@abstractmethod DCNL def get_subnet(self, context, id, fields=None): DCNL 'Retrieve a subnet. DCNL : param context: quantum api request context DCNL : param id: UUID representing the subnet to fetch. DCNL : param fields: a list of strings that are valid keys in a DCNL subnet dictionary as listed in the RESOURCE_ATTRIBUTE_MAP DCNL object in quantum/api/v2/attributes.py. Only these fields DCNL will be returned.'
@abstractmethod DCNL def get_subnets(self, context, filters=None, fields=None, sorts=None, limit=None, marker=None, page_reverse=False): DCNL 'Retrieve a list of subnets.  The contents of the list depends on DCNL the identity of the user making the request (as indicated by the DCNL context) as well as any filters. DCNL : param context: quantum api request context DCNL : param filters: a dictionary with keys that are valid keys for DCNL a subnet as listed in the RESOURCE_ATTRIBUTE_MAP object DCNL in quantum/api/v2/attributes.py.  Values in this dictiontary DCNL are an iterable containing values that will be used for an exact DCNL match comparison for that value.  Each result returned by this DCNL function will have matched one of the values for each key in DCNL filters. DCNL : param fields: a list of strings that are valid keys in a DCNL subnet dictionary as listed in the RESOURCE_ATTRIBUTE_MAP DCNL object in quantum/api/v2/attributes.py. Only these fields DCNL will be returned.'
def get_subnets_count(self, context, filters=None): DCNL 'Return the number of subnets.  The result depends on the identity of DCNL the user making the request (as indicated by the context) as well as DCNL any filters. DCNL : param context: quantum api request context DCNL : param filters: a dictionary with keys that are valid keys for DCNL a network as listed in the RESOURCE_ATTRIBUTE_MAP object DCNL in quantum/api/v2/attributes.py.  Values in this dictiontary DCNL are an iterable containing values that will be used for an exact DCNL match comparison for that value.  Each result returned by this DCNL function will have matched one of the values for each key in DCNL filters. DCNL NOTE: this method is optional, as it was not part of the originally DCNL defined plugin API.'
@abstractmethod DCNL def delete_subnet(self, context, id): DCNL 'Delete a subnet. DCNL : param context: quantum api request context DCNL : param id: UUID representing the subnet to delete.'
@abstractmethod DCNL def create_network(self, context, network): DCNL 'Create a network, which represents an L2 network segment which DCNL can have a set of subnets and ports associated with it. DCNL : param context: quantum api request context DCNL : param network: dictionary describing the network, with keys DCNL as listed in the RESOURCE_ATTRIBUTE_MAP object in DCNL quantum/api/v2/attributes.py.  All keys will be populated.'
@abstractmethod DCNL def update_network(self, context, id, network): DCNL 'Update values of a network. DCNL : param context: quantum api request context DCNL : param id: UUID representing the network to update. DCNL : param network: dictionary with keys indicating fields to update. DCNL valid keys are those that have a value of True for \'allow_put\' DCNL as listed in the RESOURCE_ATTRIBUTE_MAP object in DCNL quantum/api/v2/attributes.py.'
@abstractmethod DCNL def get_network(self, context, id, fields=None): DCNL 'Retrieve a network. DCNL : param context: quantum api request context DCNL : param id: UUID representing the network to fetch. DCNL : param fields: a list of strings that are valid keys in a DCNL network dictionary as listed in the RESOURCE_ATTRIBUTE_MAP DCNL object in quantum/api/v2/attributes.py. Only these fields DCNL will be returned.'
@abstractmethod DCNL def get_networks(self, context, filters=None, fields=None, sorts=None, limit=None, marker=None, page_reverse=False): DCNL 'Retrieve a list of networks.  The contents of the list depends on DCNL the identity of the user making the request (as indicated by the DCNL context) as well as any filters. DCNL : param context: quantum api request context DCNL : param filters: a dictionary with keys that are valid keys for DCNL a network as listed in the RESOURCE_ATTRIBUTE_MAP object DCNL in quantum/api/v2/attributes.py.  Values in this dictiontary DCNL are an iterable containing values that will be used for an exact DCNL match comparison for that value.  Each result returned by this DCNL function will have matched one of the values for each key in DCNL filters. DCNL : param fields: a list of strings that are valid keys in a DCNL network dictionary as listed in the RESOURCE_ATTRIBUTE_MAP DCNL object in quantum/api/v2/attributes.py. Only these fields DCNL will be returned.'
def get_networks_count(self, context, filters=None): DCNL 'Return the number of networks.  The result depends on the identity DCNL of the user making the request (as indicated by the context) as well DCNL as any filters. DCNL : param context: quantum api request context DCNL : param filters: a dictionary with keys that are valid keys for DCNL a network as listed in the RESOURCE_ATTRIBUTE_MAP object DCNL in quantum/api/v2/attributes.py.  Values in this dictiontary DCNL are an iterable containing values that will be used for an exact DCNL match comparison for that value.  Each result returned by this DCNL function will have matched one of the values for each key in DCNL filters. DCNL NOTE: this method is optional, as it was not part of the originally DCNL defined plugin API.'
@abstractmethod DCNL def delete_network(self, context, id): DCNL 'Delete a network. DCNL : param context: quantum api request context DCNL : param id: UUID representing the network to delete.'
@abstractmethod DCNL def create_port(self, context, port): DCNL 'Create a port, which is a connection point of a device (e.g., a VM DCNL NIC) to attach to a L2 Quantum network. DCNL : param context: quantum api request context DCNL : param port: dictionary describing the port, with keys DCNL as listed in the RESOURCE_ATTRIBUTE_MAP object in DCNL quantum/api/v2/attributes.py.  All keys will be populated.'
@abstractmethod DCNL def update_port(self, context, id, port): DCNL 'Update values of a port. DCNL : param context: quantum api request context DCNL : param id: UUID representing the port to update. DCNL : param port: dictionary with keys indicating fields to update. DCNL valid keys are those that have a value of True for \'allow_put\' DCNL as listed in the RESOURCE_ATTRIBUTE_MAP object in DCNL quantum/api/v2/attributes.py.'
@abstractmethod DCNL def get_port(self, context, id, fields=None): DCNL 'Retrieve a port. DCNL : param context: quantum api request context DCNL : param id: UUID representing the port to fetch. DCNL : param fields: a list of strings that are valid keys in a DCNL port dictionary as listed in the RESOURCE_ATTRIBUTE_MAP DCNL object in quantum/api/v2/attributes.py. Only these fields DCNL will be returned.'
@abstractmethod DCNL def get_ports(self, context, filters=None, fields=None, sorts=None, limit=None, marker=None, page_reverse=False): DCNL 'Retrieve a list of ports.  The contents of the list depends on DCNL the identity of the user making the request (as indicated by the DCNL context) as well as any filters. DCNL : param context: quantum api request context DCNL : param filters: a dictionary with keys that are valid keys for DCNL a port as listed in the RESOURCE_ATTRIBUTE_MAP object DCNL in quantum/api/v2/attributes.py.  Values in this dictiontary DCNL are an iterable containing values that will be used for an exact DCNL match comparison for that value.  Each result returned by this DCNL function will have matched one of the values for each key in DCNL filters. DCNL : param fields: a list of strings that are valid keys in a DCNL port dictionary as listed in the RESOURCE_ATTRIBUTE_MAP DCNL object in quantum/api/v2/attributes.py. Only these fields DCNL will be returned.'
def get_ports_count(self, context, filters=None): DCNL 'Return the number of ports.  The result depends on the identity of DCNL the user making the request (as indicated by the context) as well as DCNL any filters. DCNL : param context: quantum api request context DCNL : param filters: a dictionary with keys that are valid keys for DCNL a network as listed in the RESOURCE_ATTRIBUTE_MAP object DCNL in quantum/api/v2/attributes.py.  Values in this dictiontary DCNL are an iterable containing values that will be used for an exact DCNL match comparison for that value.  Each result returned by this DCNL function will have matched one of the values for each key in DCNL filters. DCNL NOTE: this method is optional, as it was not part of the originally DCNL defined plugin API.'
@abstractmethod DCNL def delete_port(self, context, id): DCNL 'Delete a port. DCNL : param context: quantum api request context DCNL : param id: UUID representing the port to delete.'
def start(self, application, port, host='0.0.0.0', backlog=128): DCNL 'Run a WSGI server with the given application.'
def wait(self): DCNL 'Wait until all servers have completed running.'
def _run(self, application, socket): DCNL 'Start a WSGI server in a new green thread.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [filter:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [filter:analytics] DCNL redis_host = 127.0.0.1 DCNL paste.filter_factory = nova.api.analytics:Analytics.factory DCNL which would result in a call to the `Analytics` class as DCNL import nova.api.analytics DCNL analytics.Analytics(app_from_paste, redis_host=\'127.0.0.1\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def process_request(self, req): DCNL 'Called on each request. DCNL If this returns None, the next application down the stack will be DCNL executed. If it returns a response then that response will be returned DCNL and execution will stop here.'
def process_response(self, response): DCNL 'Do whatever you\'d like to the response.'
def best_match_content_type(self): DCNL 'Determine the most acceptable content-type. DCNL Based on: DCNL 1) URI extension (.json/.xml) DCNL 2) Content-type header DCNL 3) Accept* headers'
def dispatch(self, *args, **kwargs): DCNL 'Find and call local method.'
def __init__(self, metadata=None, xmlns=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary. DCNL :param xmlns: XML namespace to include with serialized xml'
def default(self, data): DCNL ':param data: expect data to contain a single key as XML root, or DCNL contain another \'*_links\' key as atom links. Other DCNL case will use \'VIRTUAL_ROOT_KEY\' as XML root.'
def _to_xml_node(self, parent, metadata, nodename, data, used_prefixes): DCNL 'Recursive method to convert data members to XML nodes.'
def serialize(self, response_data, content_type, action='default'): DCNL 'Serialize a dict into a string and wrap in a wsgi.Request object. DCNL :param response_data: dict produced by the Controller DCNL :param content_type: expected mimetype of serialized response body'
def __init__(self, metadata=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary.'
def _from_xml_node(self, node, listnames): DCNL 'Convert a minidom node to a simple Python type. DCNL :param listnames: list of XML node names whose subnodes should DCNL be considered list items.'
def deserialize(self, request): DCNL 'Extract necessary pieces of the request. DCNL :param request: Request object DCNL :returns tuple of expected controller action name, dictionary of DCNL keyword arguments to pass to the controller, the expected DCNL content type of the response'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [app:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [app:wadl] DCNL latest_version = 1.3 DCNL paste.app_factory = nova.api.fancy_api:Wadl.factory DCNL which would result in a call to the `Wadl` class as DCNL import quantum.api.fancy_api DCNL fancy_api.Wadl(latest_version=\'1.3\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def __call__(self, environ, start_response): DCNL 'Subclasses will probably want to implement __call__ like this: DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL # Any of the following objects work as responses: DCNL # Option 1: simple string DCNL res = \'message\n\' DCNL # Option 2: a nicely formatted HTTP exception page DCNL res = exc.HTTPForbidden(detail=\'Nice try\') DCNL # Option 3: a webob Response object (in case you need to play with DCNL # headers, or you want to be treated like an iterable, or or or) DCNL res = Response(); DCNL res.app_iter = open(\'somefile\') DCNL # Option 4: any wsgi app to be run next DCNL res = self.application DCNL # Option 5: you can get a Response object for a wsgi app, too, to DCNL # play with headers etc DCNL res = req.get_response(self.application) DCNL # You can then just return your response... DCNL return res DCNL # ... or set req.response and return None. DCNL req.response = res DCNL See the end of http://pythonpaste.org/webob/modules/dec.html DCNL for more info.'
@staticmethod DCNL def print_generator(app_iter): DCNL 'Iterator that prints the contents of a wrapper string iterator DCNL when iterated.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Returns an instance of the WSGI Router class'
def __init__(self, mapper): DCNL 'Create a router for the given routes.Mapper. DCNL Each route in `mapper` must specify a \'controller\', which is a DCNL WSGI app to call.  You\'ll probably want to specify an \'action\' as DCNL well and have your controller be a wsgi.Controller, who will route DCNL the request to the action method. DCNL Examples: DCNL mapper = routes.Mapper() DCNL sc = ServerController() DCNL # Explicit mapping of one route to a controller+action DCNL mapper.connect(None, "/svrlist", controller=sc, action="list") DCNL # Actions are all implicitly defined DCNL mapper.resource("network", "networks", controller=nc) DCNL # Pointing to an arbitrary WSGI app.  You can specify the DCNL # {path_info:.*} parameter so the target app can be handed just that DCNL # section of the URL. DCNL mapper.connect(None, "/v1.0/{path_info:.*}", controller=BlogApp())'
@webob.dec.wsgify DCNL def __call__(self, req): DCNL 'Route the incoming request to a controller based on self.map. DCNL If no match, return a 404.'
@staticmethod DCNL @webob.dec.wsgify DCNL def _dispatch(req): DCNL 'Called by self._router after matching the incoming request to a route DCNL and putting the information into req.environ.  Either returns 404 DCNL or the routed WSGI app\'s response.'
def __init__(self, controller, fault_body_function, deserializer=None, serializer=None): DCNL ':param controller: object that implement methods created by routes lib DCNL :param deserializer: object that can serialize the output of a DCNL controller into a webob response DCNL :param serializer: object that can deserialize a webob request DCNL into necessary pieces DCNL :param fault_body_function: a function that will build the response DCNL body for HTTP errors raised by operations DCNL on this resource object'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'WSGI method that controls (de)serialization and method dispatch.'
def dispatch(self, request, action, action_args): DCNL 'Find action-spefic method on controller and call it.'
def __init__(self, exception, xmlns=None, body_function=None): DCNL 'Creates a Fault for the given webob.exc.exception.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Generate a WSGI response based on the exception passed to ctor.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Call the method specified in req.environ by RoutesMiddleware.'
def _serialize(self, data, content_type, default_xmlns): DCNL 'Serialize the given dict to the provided content_type. DCNL Uses self._serialization_metadata if it exists, which is a dict mapping DCNL MIME types to information needed to serialize to that type.'
def _deserialize(self, data, content_type): DCNL 'Deserialize the request body to the specefied content type. DCNL Uses self._serialization_metadata if it exists, which is a dict mapping DCNL MIME types to information needed to serialize to that type.'
def get_default_xmlns(self, req): DCNL 'Provide the XML namespace to use if none is otherwise specified.'
def __init__(self, metadata=None, default_xmlns=None): DCNL 'Create a serializer based on the given WSGI environment. DCNL \'metadata\' is an optional dict mapping MIME types to information DCNL needed to serialize a dictionary to that type.'
def serialize(self, data, content_type): DCNL 'Serialize a dictionary into the specified content type.'
def deserialize(self, datastring, content_type): DCNL 'Deserialize a string to a dictionary. DCNL The string must be in the format of a supported MIME type.'
def schedule(self, plugin, context, network): DCNL 'Schedule the network to an active DHCP agent if there DCNL is no active DHCP agent hosting it.'
def auto_schedule_networks(self, plugin, context, host): DCNL 'Schedule non-hosted networks to the DHCP agent on DCNL the specified host.'
def auto_schedule_routers(self, plugin, context, host, router_id): DCNL 'Schedule non-hosted routers to L3 Agent running on host. DCNL If router_id is given, only this router is scheduled DCNL if it is not hosted yet. DCNL Don\'t schedule the routers which are hosted already DCNL by active l3 agents.'
def schedule(self, plugin, context, sync_router): DCNL 'Schedule the router to an active L3 agent if there DCNL is no enable L3 agent hosting it.'
def __init__(self, user_id, tenant_id, is_admin=None, read_deleted='no', roles=None, timestamp=None, **kwargs): DCNL ':param read_deleted: \'no\' indicates deleted records are hidden, \'yes\' DCNL indicates deleted records are visible, \'only\' indicates that DCNL *only* deleted records are visible.'
def elevated(self, read_deleted=None): DCNL 'Return a version of this context with admin flag set.'
def match(self, userargs): DCNL 'Only check that the first argument (command) matches exec_path'
def get_command(self, userargs): DCNL 'Returns command to execute (with sudo -u if run_as != root).'
def get_environment(self, userargs): DCNL 'Returns specific environment to set, None if none'
def match(self, userargs): DCNL 'This matches the combination of the leading env DCNL vars plus "dnsmasq"'
def match(self, userargs): DCNL 'This matches the combination of the leading env DCNL vars plus "ip" "netns" "exec" <foo> "dnsmasq"'
def get_help_text(self, extra_context=None): DCNL 'Returns the help text for this step.'
def add_error(self, message): DCNL 'Adds an error to the Action\'s Step based on API issues.'
def handle(self, request, context): DCNL 'Handles any requisite processing for this action. The method should DCNL return either ``None`` or a dictionary of data to be passed to DCNL :meth:`~horizon.workflows.Step.contribute`. DCNL Returns ``None`` by default, effectively making it a no-op.'
def prepare_action_context(self, request, context): DCNL 'Allows for customization of how the workflow context is passed to the DCNL action; this is the reverse of what "contribute" does to make the DCNL action outputs sane for the workflow. Changes to the context are not DCNL saved globally here. They are localized to the action. DCNL Simply returns the unaltered context by default.'
def get_id(self): DCNL 'Returns the ID for this step. Suitable for use in HTML markup.'
def contribute(self, data, context): DCNL 'Adds the data listed in ``contributes`` to the workflow\'s shared DCNL context. By default, the context is simply updated with all the data DCNL returned by the action. DCNL Note that even if the value of one of the ``contributes`` keys is DCNL not present (e.g. optional) the key should still be added to the DCNL context with a value of ``None``.'
def render(self): DCNL 'Renders the step.'
def get_help_text(self): DCNL 'Returns the help text for this step.'
def add_error(self, message): DCNL 'Adds an error to the Step based on API issues.'
def get_step(self, slug): DCNL 'Returns the instantiated step matching the given slug.'
def get_entry_point(self): DCNL 'Returns the slug of the step which the workflow should begin on. DCNL This method takes into account both already-available data and errors DCNL within the steps.'
@classmethod DCNL def register(cls, step_class): DCNL 'Registers a :class:`~horizon.workflows.Step` with the workflow.'
@classmethod DCNL def unregister(cls, step_class): DCNL 'Unregisters a :class:`~horizon.workflows.Step` from the workflow.'
def validate(self, context): DCNL 'Hook for custom context data validation. Should return a boolean DCNL value or raise :class:`~horizon.exceptions.WorkflowValidationError`.'
def is_valid(self): DCNL 'Verified that all required data is present in the context and DCNL calls the ``validate`` method to allow for finer-grained checks DCNL on the context data.'
def finalize(self): DCNL 'Finalizes a workflow by running through all the actions in order DCNL and calling their ``handle`` methods. Returns ``True`` on full success, DCNL or ``False`` for a partial success, e.g. there were non-critical DCNL errors. (If it failed completely the function wouldn\'t return.)'
def handle(self, request, context): DCNL 'Handles any final processing for this workflow. Should return a boolean DCNL value indicating success.'
def get_success_url(self): DCNL 'Returns a URL to redirect the user to upon completion. By default it DCNL will attempt to parse a ``success_url`` attribute on the workflow, DCNL which can take the form of a reversible URL pattern name, or a DCNL standard HTTP URL.'
def format_status_message(self, message): DCNL 'Hook to allow customization of the message returned to the user DCNL upon successful or unsuccessful completion of the workflow. DCNL By default it simply inserts the workflow\'s name into the message DCNL string.'
def render(self): DCNL 'Renders the workflow.'
def get_absolute_url(self): DCNL 'Returns the canonical URL for this workflow. DCNL This is used for the POST action attribute on the form element DCNL wrapping the workflow. DCNL For convenience it defaults to the value of DCNL ``request.get_full_path()`` with any query string stripped off, DCNL e.g. the path at which the workflow was requested.'
def add_error_to_step(self, message, slug): DCNL 'Adds an error to the workflow\'s Step with the DCNL specifed slug based on API issues. This is useful DCNL when you wish for API errors to appear as errors on DCNL the form rather than using the messages framework.'
def get_initial(self): DCNL 'Returns initial data for the workflow. Defaults to using the GET DCNL parameters to allow pre-seeding of the workflow context values.'
def get_workflow(self): DCNL 'Returns the instanciated workflow class.'
def get_context_data(self, **kwargs): DCNL 'Returns the template context, including the workflow class. DCNL This method should be overridden in subclasses to provide additional DCNL context data to the template.'
def get_template_names(self): DCNL 'Returns the template name to use for this request.'
def get(self, request, *args, **kwargs): DCNL 'Handler for HTTP GET requests.'
def post(self, request, *args, **kwargs): DCNL 'Handler for HTTP POST requests.'
def get_raw_data(self, datum): DCNL 'Returns the raw data for this column, before any filters or formatting DCNL are applied to it. This is useful when doing calculations on data in DCNL the table.'
def get_data(self, datum): DCNL 'Returns the final display data for this column from the given inputs. DCNL The return value will be either the attribute specified for this column DCNL or the return value of the attr:`~horizon.tables.Column.transform` DCNL method for this column.'
def get_link_url(self, datum): DCNL 'Returns the final value for the column\'s ``link`` property. DCNL If ``allowed_data_types`` of this column  is not empty and the datum DCNL has an assigned type, check if the datum\'s type is in the DCNL ``allowed_data_types`` list. If not, the datum won\'t be displayed DCNL as a link. DCNL If ``link`` is a callable, it will be passed the current data object DCNL and should return a URL. Otherwise ``get_link_url`` will attempt to DCNL call ``reverse`` on ``link`` with the object\'s id as a parameter. DCNL Failing that, it will simply return the value of ``link``.'
def get_summation(self): DCNL 'Returns the summary value for the data in this column if a DCNL valid summation method is specified for it. Otherwise returns ``None``.'
def load_cells(self, datum=None): DCNL 'Load the row\'s data (either provided at initialization or as an DCNL argument to this function), initiailize all the cells contained DCNL by this row, and set the appropriate row properties which require DCNL the row\'s data to be determined. DCNL This function is called automatically by DCNL :meth:`~horizon.tables.Row.__init__` if the ``datum`` argument is DCNL provided. However, by not providing the data during initialization DCNL this function allows for the possibility of a two-step loading DCNL pattern when you need a row instance but don\'t yet have the data DCNL available.'
def get_cells(self): DCNL 'Returns the bound cells for this row in order.'
def get_data(self, request, obj_id): DCNL 'Fetches the updated data for the row based on the object id DCNL passed in. Must be implemented by a subclass to allow AJAX updating.'
@property DCNL def value(self): DCNL 'Returns a formatted version of the data for final output. DCNL This takes into consideration the DCNL :attr:`~horizon.tables.Column.link`` and DCNL :attr:`~horizon.tables.Column.empty_value` DCNL attributes.'
@property DCNL def status(self): DCNL 'Gets the status for the column based on the cell\'s data.'
def get_status_class(self, status): DCNL 'Returns a css class name determined by the status value.'
def get_default_classes(self): DCNL 'Returns a flattened string of the cell\'s CSS classes.'
def render(self): DCNL 'Renders the table using the template from the table options.'
def get_absolute_url(self): DCNL 'Returns the canonical URL for this table. DCNL This is used for the POST action attribute on the form element DCNL wrapping the table. In many cases it is also useful for redirecting DCNL after a successful action on the table. DCNL For convenience it defaults to the value of DCNL ``request.get_full_path()`` with any query string stripped off, DCNL e.g. the path at which the table was requested.'
def get_empty_message(self): DCNL 'Returns the message to be displayed when there is no data.'
def get_object_by_id(self, lookup): DCNL 'Returns the data object from the table\'s dataset which matches DCNL the ``lookup`` parameter specified. An error will be raised if DCNL the match is not a single data object. DCNL Uses :meth:`~horizon.tables.DataTable.get_object_id` internally.'
@property DCNL def has_actions(self): DCNL 'Boolean. Indicates whether there are any available actions on this DCNL table.'
@property DCNL def needs_form_wrapper(self): DCNL 'Boolean. Indicates whather this table should be rendered wrapped in DCNL a ``<form>`` tag or not.'
def get_table_actions(self): DCNL 'Returns a list of the action instances for this table.'
def get_row_actions(self, datum): DCNL 'Returns a list of the action instances for a specific row.'
def render_table_actions(self): DCNL 'Renders the actions specified in ``Meta.table_actions``.'
def render_row_actions(self, datum): DCNL 'Renders the actions specified in ``Meta.row_actions`` using the DCNL current row data.'
@staticmethod DCNL def parse_action(action_string): DCNL 'Parses the ``action`` parameter (a string) sent back with the DCNL POST data. By default this parses a string formatted as DCNL ``{{ table_name }}__{{ action_name }}__{{ row_id }}`` and returns DCNL each of the pieces. The ``row_id`` is optional.'
def take_action(self, action_name, obj_id=None, obj_ids=None): DCNL 'Locates the appropriate action and routes the object DCNL data to it. The action should return an HTTP redirect DCNL if successful, or a value which evaluates to ``False`` DCNL if unsuccessful.'
@classmethod DCNL def check_handler(cls, request): DCNL 'Determine whether the request should be handled by this table.'
def maybe_preempt(self): DCNL 'Determine whether the request should be handled by a preemptive action DCNL on this table or by an AJAX row update before loading any data.'
def maybe_handle(self): DCNL 'Determine whether the request should be handled by any action on this DCNL table after data has been loaded.'
def sanitize_id(self, obj_id): DCNL 'Override to modify an incoming obj_id to match existing DCNL API data types or modify the format.'
def get_object_id(self, datum): DCNL 'Returns the identifier for the object this row will represent. DCNL By default this returns an ``id`` attribute on the given object, DCNL but this can be overridden to return other values. DCNL .. warning:: DCNL Make sure that the value returned is a unique value for the id DCNL otherwise rendering issues can occur.'
def get_object_display(self, datum): DCNL 'Returns a display name that identifies this object. DCNL By default, this returns a ``name`` attribute from the given object, DCNL but this can be overriden to return other values.'
def has_more_data(self): DCNL 'Returns a boolean value indicating whether there is more data DCNL available to this table from the source (generally an API). DCNL The method is largely meant for internal use, but if you want to DCNL override it to provide custom behavior you can do so at your own risk.'
def get_marker(self): DCNL 'Returns the identifier for the last object in the current data set DCNL for APIs that use marker/limit-based paging.'
def get_pagination_string(self): DCNL 'Returns the query parameter string to paginate this table.'
def calculate_row_status(self, statuses): DCNL 'Returns a boolean value determining the overall row status DCNL based on the dictionary of column name to status mappings passed in. DCNL By default, it uses the following logic: DCNL #. If any statuses are ``False``, return ``False``. DCNL #. If no statuses are ``False`` but any or ``None``, return ``None``. DCNL #. If all statuses are ``True``, return ``True``. DCNL This provides the greatest protection against false positives without DCNL weighting any particular columns. DCNL The ``statuses`` parameter is passed in as a dictionary mapping DCNL column names to their statuses in order to allow this function to DCNL be overridden in such a way as to weight one column\'s status over DCNL another should that behavior be desired.'
def get_row_status_class(self, status): DCNL 'Returns a css class name determined by the status value. This class DCNL name is used to indicate the status of the rows in the table if DCNL any ``status_columns`` have been specified.'
def get_columns(self): DCNL 'Returns this table\'s columns including auto-generated ones.'
def get_rows(self): DCNL 'Return the row data for this table broken out by columns.'
def data_type_matched(self, datum): DCNL 'Method to see if the action is allowed for a certain type of data. DCNL Only affects mixed data type tables.'
def allowed(self, request, datum): DCNL 'Determine whether this action is allowed for the current request. DCNL This method is meant to be overridden with more specific checks.'
def update(self, request, datum): DCNL 'Allows per-action customization based on current conditions. DCNL This is particularly useful when you wish to create a "toggle" DCNL action that will be rendered differently based on the value of an DCNL attribute on the current row\'s data. DCNL By default this method is a no-op.'
def get_default_classes(self): DCNL 'Returns a list of the default classes for the action. Defaults to DCNL ``["btn", "btn-small"]``.'
def get_default_attrs(self): DCNL 'Returns a list of the default HTML attributes for the action. Defaults DCNL to returning an ``id`` attribute with the value DCNL ``{{ table.name }}__action_{{ action.name }}__{{ creation counter }}``.'
def get_param_name(self): DCNL 'Returns the full POST parameter name for this action. DCNL Defaults to DCNL ``{{ table.name }}__{{ action.name }}``.'
def get_link_url(self, datum=None): DCNL 'Returns the final URL based on the value of ``url``. DCNL If ``url`` is callable it will call the function. DCNL If not, it will then try to call ``reverse`` on ``url``. DCNL Failing that, it will simply return the value of ``url`` as-is. DCNL When called for a row action, the current row data object will be DCNL passed as the first parameter.'
def get_param_name(self): DCNL 'Returns the full query parameter name for this action. DCNL Defaults to DCNL ``{{ table.name }}__{{ action.name }}__{{ action.param_name }}``.'
def filter(self, table, data, filter_string): DCNL 'Provides the actual filtering logic. DCNL This method must be overridden by subclasses and return DCNL the filtered data.'
def get_fixed_buttons(self): DCNL 'Returns a list of dictionaries describing the fixed buttons DCNL to use for filtering. DCNL Each list item should be a dict with the keys: DCNL text:  Text to display on the button DCNL icon:  Icon class for icon element (inserted before text). DCNL value: Value returned when the button is clicked. DCNL This value is passed to ``filter()`` as DCNL ``filter_string``.'
def categorize(self, table, images): DCNL 'Override to separate images into categories. DCNL Return a dict with a key for the value of each fixed button, DCNL and a value that is a list of images in that category.'
def _conjugate(self, items=None, past=False): DCNL 'Builds combinations like \'Delete Object\' and \'Deleted DCNL Objects\' based on the number of items and `past` flag.'
def action(self, request, datum_id): DCNL 'Required. Accepts a single object id and performs the specific action. DCNL Return values are discarded, errors raised are caught and logged.'
def update(self, request, datum): DCNL 'Switches the action verbose name, if needed'
def get_success_url(self, request=None): DCNL 'Returns the URL to redirect to after a successful action.'
def _register(self, cls): DCNL 'Registers the given class. DCNL If the specified class is already registered then it is ignored.'
def _unregister(self, cls): DCNL 'Unregisters the given class. DCNL If the specified class isn\'t registered, ``NotRegistered`` will DCNL be raised.'
def get_absolute_url(self): DCNL 'Returns the default URL for this panel. DCNL The default URL is defined as the URL pattern with ``name="index"`` in DCNL the URLconf for this panel.'
def get_panel(self, panel): DCNL 'Returns the specified :class:`~horizon.Panel` instance registered DCNL with this dashboard.'
def get_panels(self): DCNL 'Returns the :class:`~horizon.Panel` instances registered with this DCNL dashboard in order, without any panel groupings.'
def get_absolute_url(self): DCNL 'Returns the default URL for this dashboard. DCNL The default URL is defined as the URL pattern with ``name="index"`` DCNL in the URLconf for the :class:`~horizon.Panel` specified by DCNL :attr:`~horizon.Dashboard.default_panel`.'
def _autodiscover(self): DCNL 'Discovers panels to register from the current dashboard module.'
@classmethod DCNL def register(cls, panel): DCNL 'Registers a :class:`~horizon.Panel` with this dashboard.'
@classmethod DCNL def unregister(cls, panel): DCNL 'Unregisters a :class:`~horizon.Panel` from this dashboard.'
def register(self, dashboard): DCNL 'Registers a :class:`~horizon.Dashboard` with Horizon.'
def unregister(self, dashboard): DCNL 'Unregisters a :class:`~horizon.Dashboard` from Horizon.'
def get_dashboard(self, dashboard): DCNL 'Returns the specified :class:`~horizon.Dashboard` instance.'
def get_dashboards(self): DCNL 'Returns an ordered tuple of :class:`~horizon.Dashboard` modules. DCNL Orders dashboards according to the ``"dashboards"`` key in DCNL ``HORIZON_CONFIG`` or else returns all registered dashboards DCNL in alphabetical order. DCNL Any remaining :class:`~horizon.Dashboard` classes registered with DCNL Horizon but not listed in ``HORIZON_CONFIG[\'dashboards\']`` DCNL will be appended to the end of the list alphabetically.'
def get_default_dashboard(self): DCNL 'Returns the default :class:`~horizon.Dashboard` instance. DCNL If ``"default_dashboard"`` is specified in ``HORIZON_CONFIG`` DCNL then that dashboard will be returned. If not, the first dashboard DCNL returned by :func:`~horizon.get_dashboards` will be returned.'
def get_user_home(self, user): DCNL 'Returns the default URL for a particular user. DCNL This method can be used to customize where a user is sent when DCNL they log in, etc. By default it returns the value of DCNL :meth:`get_absolute_url`. DCNL An alternative function can be supplied to customize this behavior DCNL by specifying a either a URL or a function which returns a URL via DCNL the ``"user_home"`` key in ``HORIZON_CONFIG``. Each of these DCNL would be valid:: DCNL {"user_home": "/home",}  # A URL DCNL {"user_home": "my_module.get_user_home",}  # Path to a function DCNL {"user_home": lambda user: "/" + user.name,}  # A function DCNL {"user_home": None,}  # Will always return the default dashboard DCNL This can be useful if the default dashboard may not be accessible DCNL to all users. When user_home is missing from HORIZON_CONFIG, DCNL it will default to the settings.LOGIN_REDIRECT_URL value.'
def get_absolute_url(self): DCNL 'Returns the default URL for Horizon\'s URLconf. DCNL The default URL is determined by calling DCNL :meth:`~horizon.Dashboard.get_absolute_url` DCNL on the :class:`~horizon.Dashboard` instance returned by DCNL :meth:`~horizon.get_default_dashboard`.'
@property DCNL def _lazy_urls(self): DCNL 'Lazy loading for URL patterns. DCNL This method avoids problems associated with attempting to evaluate DCNL the the URLconf before the settings module has been loaded.'
def _urls(self): DCNL 'Constructs the URLconf for Horizon from registered Dashboards.'
def _autodiscover(self): DCNL 'Discovers modules to register from ``settings.INSTALLED_APPS``. DCNL This makes sure that the appropriate modules get imported to register DCNL themselves with Horizon.'
def set_tables(self, tables): DCNL 'Sets the table instances on the browser from a dictionary mapping table DCNL names to table instances (as constructed by MultiTableView).'
def render(self): DCNL 'Renders the table using the template from the table options.'
def render(self, datestring): DCNL 'Parses a date-like input string into a timezone aware Python datetime.'
def get_traceback_frame_variables(self, request, tb_frame): DCNL 'Replaces the values of variables marked as sensitive with DCNL stars (*********).'
def api_error(self, message): DCNL 'Adds an error to the form\'s error dictionary after validation DCNL based on problems reported via the API. This is useful when you DCNL wish for API errors to appear as errors on the form rather than DCNL using the messages framework.'
def get_object_id(self, obj): DCNL 'For dynamic insertion of resources created in modals, this method DCNL returns the id of the created object. Defaults to returning the ``id`` DCNL attribute.'
def get_object_display(self, obj): DCNL 'For dynamic insertion of resources created in modals, this method DCNL returns the display name of the created object. Defaults to returning DCNL the ``name`` attribute.'
def get_form(self, form_class): DCNL 'Returns an instance of the form to be used in this view.'
def _reload_urls(self): DCNL 'Clears out the URL caches, reloads the root urls module, and DCNL re-triggers the autodiscovery mechanism for Horizon. Allows URLs DCNL to be re-calculated after registering new dashboards. Useful DCNL only for testing and should never be used on a live site.'
def test_registry(self): DCNL 'Verify registration and autodiscovery work correctly. DCNL Please note that this implicitly tests that autodiscovery works DCNL by virtue of the fact that the dashboards listed in DCNL ``settings.INSTALLED_APPS`` are loaded from the start.'
def test_horizon_test_isolation_1(self): DCNL 'Isolation Test Part 1: sets a value.'
def test_horizon_test_isolation_2(self): DCNL 'Isolation Test Part 2: The value set in part 1 should be gone.'
def test_table_instantiation(self): DCNL 'Tests everything that happens when the table is instantiated.'
def render_template_tag(self, tag_name, tag_require=''): DCNL 'Render a Custom Template Tag to string'
def test_site_branding_tag(self): DCNL 'Test if site_branding tag renders the correct setting'
def assertNoMessages(self, response=None): DCNL 'Asserts that no messages have been attached by the ``contrib.messages`` DCNL framework.'
def assertMessageCount(self, response=None, **kwargs): DCNL 'Asserts that the specified number of messages have been attached DCNL for various message types. Usage would look like DCNL ``self.assertMessageCount(success=1)``.'
def load_tab_data(self): DCNL 'Preload all data that for the tabs that will be displayed.'
def get_id(self): DCNL 'Returns the id for this tab group. Defaults to the value of the tab DCNL group\'s :attr:`horizon.tabs.Tab.slug`.'
def get_default_classes(self): DCNL 'Returns a list of the default classes for the tab group. Defaults to DCNL ``["nav", "nav-tabs", "ajax-tabs"]``.'
def tabs_not_available(self): DCNL 'In the event that no tabs are either allowed or enabled, this method DCNL is the fallback handler. By default it\'s a no-op, but it exists DCNL to make redirecting or raising exceptions possible for subclasses.'
def render(self): DCNL 'Renders the HTML output for this tab group.'
def get_tabs(self): DCNL 'Returns a list of the allowed tabs for this tab group.'
def get_tab(self, tab_name, allow_disabled=False): DCNL 'Returns a specific tab from this tab group. DCNL If the tab is not allowed or not enabled this method returns ``None``. DCNL If the tab is disabled but you wish to return it anyway, you can pass DCNL ``True`` to the allow_disabled argument.'
def get_selected_tab(self): DCNL 'Returns the tab specific by the GET request parameter. DCNL In the event that there is no GET request parameter, the value DCNL of the query parameter is invalid, or the tab is not allowed/enabled, DCNL the return value of this function is None.'
def is_active(self): DCNL 'Method to access whether or not this tab is the active tab.'
def render(self): DCNL 'Renders the tab to HTML using the DCNL :meth:`~horizon.tabs.Tab.get_context_data` method and DCNL the :meth:`~horizon.tabs.Tab.get_template_name` method. DCNL If :attr:`~horizon.tabs.Tab.preload` is ``False`` and ``force_load`` DCNL is not ``True``, or DCNL either :meth:`~horizon.tabs.Tab.allowed` or DCNL :meth:`~horizon.tabs.Tab.enabled` returns ``False`` this method will DCNL return an empty string.'
def get_id(self): DCNL 'Returns the id for this tab. Defaults to DCNL ``"{{ tab_group.slug }}__{{ tab.slug }}"``.'
def get_default_classes(self): DCNL 'Returns a list of the default classes for the tab. Defaults to DCNL and empty list (``[]``), however additional classes may be added DCNL depending on the state of the tab as follows: DCNL If the tab is the active tab for the tab group, in which DCNL the class ``"active"`` will be added. DCNL If the tab is not enabled, the classes the class ``"disabled"`` DCNL will be added.'
def get_template_name(self, request): DCNL 'Returns the name of the template to be used for rendering this tab. DCNL By default it returns the value of the ``template_name`` attribute DCNL on the ``Tab`` class.'
def get_context_data(self, request): DCNL 'This method should return a dictionary of context data used to render DCNL the tab. Required.'
def enabled(self, request): DCNL 'Determines whether or not the tab should be accessible DCNL (e.g. be rendered into the HTML on load and respond to a click event). DCNL If a tab returns ``False`` from ``enabled`` it will ignore the value DCNL of ``preload`` and only render the HTML of the tab after being clicked. DCNL The default behavior is to return ``True`` for all cases.'
def allowed(self, request): DCNL 'Determines whether or not the tab is displayed. DCNL Tab instances can override this method to specify conditions under DCNL which this tab should not be shown at all by returning ``False``. DCNL The default behavior is to return ``True`` for all cases.'
def load_table_data(self): DCNL 'Calls the ``get_{{ table_name }}_data`` methods for each table class DCNL and sets the data on the tables.'
def get_context_data(self, request): DCNL 'Adds a ``{{ table_name }}_table`` item to the context for each table DCNL in the :attr:`~horizon.tabs.TableTab.table_classes` attribute. DCNL If only one table class is provided, a shortcut ``table`` context DCNL variable is also added containing the single table.'
def get_tabs(self, request, **kwargs): DCNL 'Returns the initialized tab group for this view.'
def get_context_data(self, **kwargs): DCNL 'Adds the ``tab_group`` variable to the context data.'
def handle_tabbed_response(self, tab_group, context): DCNL 'Sends back an AJAX-appropriate response for the tab group if DCNL required, otherwise renders the response as normal.'
def load_tabs(self): DCNL 'Loads the tab group, and compiles the table instances for each DCNL table attached to any :class:`horizon.tabs.TableTab` instances on DCNL the tab group. This step is necessary before processing any DCNL tab or table actions.'
def get_tables(self): DCNL 'A no-op on this class. Tables are handled at the tab level.'
def handle_table(self, table_dict): DCNL 'For the given dict containing a ``DataTable`` and a ``TableTab`` DCNL instance, it loads the table data for that tab and calls the DCNL table\'s :meth:`~horizon.tables.DataTable.maybe_handle` method. The DCNL return value will be the result of ``maybe_handle``.'
def get_data(self, request, context, *args, **kwargs): DCNL 'This method should handle any necessary API calls, update the DCNL context object, and return the context object at the end.'
def process_request(self, request): DCNL 'Adds data necessary for Horizon to function to the request.'
def process_exception(self, request, exception): DCNL 'Catches internal Horizon exception classes such as NotAuthorized, DCNL NotFound and Http302 and handles them gracefully.'
def process_response(self, request, response): DCNL 'Convert HttpResponseRedirect to HttpResponse if request is via ajax DCNL to allow ajax request to redirect url'
def get_default_classes(self): DCNL 'Returns an iterable of default classes which should be combined with DCNL any other declared classes.'
def get_default_attrs(self): DCNL 'Returns a dict of default attributes which should be combined with DCNL other declared attributes.'
def get_final_attrs(self): DCNL 'Returns a dict containing the final attributes of this element DCNL which will be rendered.'
@property DCNL def attr_string(self): DCNL 'Returns a flattened string of HTML attributes based on the DCNL ``attrs`` dict provided to the class.'
@property DCNL def class_string(self): DCNL 'Returns a list of class name of HTML Element in string'
def __repr__(self): DCNL 'Return the function\'s docstring.'
def __get__(self, obj, objtype): DCNL 'Support instance methods.'
@property DCNL def rules(self): DCNL 'Wraps transmitted rule info in the novaclient rule class.'
@abc.abstractmethod DCNL def list_pools(self): DCNL 'Fetches a list of all floating IP pools. DCNL A list of FloatingIpPool objects is returned. DCNL FloatingIpPool object is an APIResourceWrapper/APIDictWrapper DCNL where \'id\' and \'name\' attributes are defined.'
@abc.abstractmethod DCNL def list(self): DCNL 'Fetches a list all floating IPs. DCNL A returned value is a list of FloatingIp object.'
@abc.abstractmethod DCNL def get(self, floating_ip_id): DCNL 'Fetches the floating IP. DCNL It returns a FloatingIp object corresponding to floating_ip_id.'
@abc.abstractmethod DCNL def allocate(self, pool=None): DCNL 'Allocates a floating IP to the tenant. DCNL You must provide a pool name or id for which you would like to DCNL allocate an floating IP.'
@abc.abstractmethod DCNL def release(self, floating_ip_id): DCNL 'Releases a floating IP specified.'
@abc.abstractmethod DCNL def associate(self, floating_ip_id, port_id): DCNL 'Associates the floating IP to the port. DCNL port_id is a fixed IP of a instance (Nova) or DCNL a port_id attached to a VNIC of a instance.'
@abc.abstractmethod DCNL def disassociate(self, floating_ip_id, port_id): DCNL 'Disassociates the floating IP from the port. DCNL port_id is a fixed IP of a instance (Nova) or DCNL a port_id attached to a VNIC of a instance.'
@abc.abstractmethod DCNL def list_targets(self): DCNL 'Returns a list of association targets of instance VIFs. DCNL Each association target is represented as FloatingIpTarget object. DCNL FloatingIpTarget is a APIResourceWrapper/APIDictWrapper and DCNL \'id\' and \'name\' attributes must be defined in each object. DCNL FloatingIpTarget.id can be passed as port_id in associate(). DCNL FloatingIpTarget.name is displayed in Floating Ip Association Form.'
@abc.abstractmethod DCNL def get_target_id_by_instance(self, instance_id): DCNL 'Returns a target ID of floating IP association based on DCNL a backend implementation.'
@abc.abstractmethod DCNL def is_simple_associate_supported(self): DCNL 'Returns True if the default floating IP pool is enabled.'
def add_quota(self, quota): DCNL 'Adds an internal tracking reference for the given quota.'
def tally(self, name, value): DCNL 'Adds to the "used" metric for the given quota.'
def update_available(self, name): DCNL 'Updates the "available" metric for the given quota.'
def get_success_url(self, request=None): DCNL 'Returns the URL to redirect to after a successful action.'
@property DCNL def objects(self): DCNL 'Returns a list of objects given the subfolder\'s path. DCNL The path is from the kwargs of the request.'
def get_objects_data(self): DCNL 'Returns a list of objects within the current folder.'
def get_subfolders_data(self): DCNL 'Returns a list of subfolders within the current folder.'
def _setup_subnet_parameters(self, params, data, is_create=True): DCNL 'Setup subnet parameters DCNL This methods setups subnet parameters which are available DCNL in both create and update.'
def _delete_network(self, request, network): DCNL 'Delete the created network when subnet creation failed'
def test_no_location_or_file(self): DCNL 'The form will not be valid if both copy_from and image_file are not DCNL provided.'
@override_settings(HORIZON_IMAGES_ALLOW_UPLOAD=False) DCNL def test_image_upload_disabled(self): DCNL 'If HORIZON_IMAGES_ALLOW_UPLOAD is false, the image_file field widget DCNL will be a HiddenInput widget instead of a FileInput widget.'
def clean(self): DCNL 'Check to make sure password fields match.'
def filter(self, table, users, filter_string): DCNL 'Naive case-insensitive search'
def filter(self, table, tenants, filter_string): DCNL 'Really naive case-insensitive search.'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def test_remove_tenant_user(self): DCNL 'Tests api.keystone.remove_tenant_user DCNL Verifies that remove_tenant_user is called with the right arguments DCNL after iterating the user\'s roles. DCNL There are no assertions in this test because the checking is handled DCNL by mox in the VerifyAll() call in tearDown().'
def assertRedirectsNoFollow(self, response, expected_url): DCNL 'Asserts that the given response issued a 302 redirect without DCNL processing the view which is redirected to.'
def assertNoFormErrors(self, response, context_name='form'): DCNL 'Asserts that the response either does not contain a form in it\'s DCNL context, or that if it does, that form has no errors.'
def assertFormErrors(self, response, count=0, message=None, context_name='form'): DCNL 'Asserts that the response does contain a form in it\'s DCNL context, and that form has errors, if count were given, DCNL it must match the exact numbers of errors'
def add(self, *args): DCNL 'Add a new object to this container. DCNL Generally this method should only be used during data loading, since DCNL adding data during a test can affect the results of other tests.'
def list(self): DCNL 'Returns a list of all objects in this container.'
def filter(self, filtered=None, **kwargs): DCNL 'Returns objects in this container whose attributes match the given DCNL keyword arguments.'
def get(self, **kwargs): DCNL 'Returns the single object in this container whose attributes match DCNL the given keyword arguments. An error will be raised if the arguments DCNL provided don\'t return exactly one match.'
def first(self): DCNL 'Returns the first object from this container.'
def test_canonical_string(self): DCNL 'The hashes here were generated by running the same requests against DCNL boto.utils.canonical_string'
def GET(self, env, start_response): DCNL 'Handle GET Service request'
def GET(self, env, start_response): DCNL 'Handle GET Bucket (List Objects) request'
def PUT(self, env, start_response): DCNL 'Handle PUT Bucket request'
def DELETE(self, env, start_response): DCNL 'Handle DELETE Bucket request'
def POST(self, env, start_response): DCNL 'Handle POST Bucket (Delete/Upload Multiple Objects) request'
def HEAD(self, env, start_response): DCNL 'Handle HEAD Object request'
def GET(self, env, start_response): DCNL 'Handle GET Object request'
def PUT(self, env, start_response): DCNL 'Handle PUT Object and PUT Object (Copy) request'
def DELETE(self, env, start_response): DCNL 'Handle DELETE Object request'
def fake_tem_init(self): DCNL 'Fake a transformerManager for pipeline DCNL The faked entry point setting is below: DCNL update: TransformerClass DCNL except: TransformerClassException DCNL drop:   TransformerClassDrop'
def test_wrong_project_id(self): DCNL 'Do not accept cross posting samples to different projects.'
def test_multiple_samples(self): DCNL 'Send multiple samples. DCNL The usecase here is to reduce the chatter and send the counters DCNL at a slower cadence.'
def test_missing_mandatory_fields(self): DCNL 'Do not accept posting samples with missing mandatory fields.'
def test_multiple_sources(self): DCNL 'Do not accept a single post of mixed sources.'
def test_multiple_samples_some_null_sources(self): DCNL 'Do accept a single post with some null sources DCNL this is a convience feature so you only have to set DCNL one of the sample\'s source field.'
def test_bogus_request(self): DCNL 'Test even for arbitrary request method, this will still work.'
def publish_counters(self, context, counters, source): DCNL 'Send a metering message for publishing DCNL :param context: Execution context from the service or RPC call DCNL :param counter: Counter from pipeline after transformation DCNL :param source: counter source'
def publish_counters(self, context, counters, source): DCNL 'Send a metering message for publishing DCNL :param context: Execution context from the service or RPC call DCNL :param counter: Counter from pipeline after transformation DCNL :param source: counter source'
def publish_counters(self, context, counters, source): DCNL 'Send a metering message for publishing DCNL :param context: Execution context from the service or RPC call DCNL :param counter: Counter from pipeline after transformation DCNL :param source: counter source'
@wsme_pecan.wsexpose([Sample], [Query], int) DCNL def get_all(self, q=[], limit=None): DCNL 'Return samples for the meter. DCNL :param q: Filter rules for the data to be returned. DCNL :param limit: Maximum number of samples to return.'
@wsme.validate([Sample]) DCNL @wsme_pecan.wsexpose([Sample], body=[Sample]) DCNL def post(self, body): DCNL 'Post a list of new Samples to Ceilometer. DCNL :param body: a list of samples within the request body.'
@wsme_pecan.wsexpose([Statistics], [Query], int) DCNL def statistics(self, q=[], period=None): DCNL 'Computes the statistics of the samples in the time range given. DCNL :param q: Filter rules for the data to be returned. DCNL :param period: Returned result will be an array of statistics for a DCNL period long of that number of seconds.'
@wsme_pecan.wsexpose([Meter], [Query]) DCNL def get_all(self, q=[]): DCNL 'Return all known meters, based on the data recorded so far. DCNL :param q: Filter rules for the meters to be returned.'
@wsme_pecan.wsexpose(Resource, unicode) DCNL def get_one(self, resource_id): DCNL 'Retrieve details about one resource. DCNL :param resource_id: The UUID of the resource.'
@wsme_pecan.wsexpose([Resource], [Query]) DCNL def get_all(self, q=[]): DCNL 'Retrieve definitions of all of the resources. DCNL :param q: Filter rules for the resources to be returned.'
@wsme.validate(Alarm) DCNL @wsme_pecan.wsexpose(Alarm, body=Alarm, status_code=201) DCNL def post(self, data): DCNL 'Create a new alarm.'
@wsme.validate(Alarm) DCNL @wsme_pecan.wsexpose(Alarm, wtypes.text, body=Alarm) DCNL def put(self, alarm_id, data): DCNL 'Modify an alarm.'
@wsme_pecan.wsexpose(None, wtypes.text, status_code=204) DCNL def delete(self, alarm_id): DCNL 'Delete an alarm.'
@wsme_pecan.wsexpose(Alarm, wtypes.text) DCNL def get_one(self, alarm_id): DCNL 'Return one alarm.'
@wsme_pecan.wsexpose([Alarm], [Query]) DCNL def get_all(self, q=[]): DCNL 'Return all alarms, based on the query provided. DCNL :param q: Filter rules for the alarms to be returned.'
def __init__(self, url, token=None): DCNL 'Initializes client.'
def iter_probes(self): DCNL 'Returns a list of dicts describing all probes.'
@staticmethod DCNL def get_kwapi_client(ksclient): DCNL 'Returns a KwapiClient configured with the proper url and token.'
def iter_probes(self, ksclient): DCNL 'Iterate over all probes.'
def get_counters(self, manager): DCNL 'Returns all counters.'
def poll_and_publish(self): DCNL 'Tasks to be run at a periodic interval.'
def _check_counters(self): DCNL 'Counter rules checking DCNL At least one meaningful counter exist DCNL Included type and excluded type counter can\'t co-exist at DCNL the same pipeline DCNL Included type counter and wildcard can\'t co-exist at same pipeline'
def _publish_counters(self, start, ctxt, counters, source): DCNL 'Push counter into pipeline for publishing. DCNL param start: the first transformer that the counter will be injected. DCNL This is mainly for flush() invocation that transformer DCNL may emit counters DCNL param ctxt: execution context from the manager or service DCNL param counters: counter list DCNL param source: counter source'
def flush(self, ctxt, source): DCNL 'Flush data after all counter have been injected to pipeline.'
def __init__(self, cfg, transformer_manager): DCNL 'Setup the pipelines according to config. DCNL The top of the cfg is a list of pipeline definitions. DCNL Pipeline definition is an dictionary specifying the target counters, DCNL the tranformers involved, and the target publishers: DCNL "name": pipeline_name DCNL "interval": interval_time DCNL "counters" :  ["counter_1", "counter_2"], DCNL "tranformers":[ DCNL {"name": "Transformer_1", DCNL "parameters": {"p1": "value"}}, DCNL {"name": "Transformer_2", DCNL "parameters": {"p1": "value"}}, DCNL "publishers": ["publisher_1", "publisher_2"] DCNL Interval is how many seconds should the counters be injected to DCNL the pipeline. DCNL Valid counter format is \'*\', \'!counter_name\', or \'counter_name\'. DCNL \'*\' is wildcard symbol means any counters; \'!counter_name\' means DCNL "counter_name" will be excluded; \'counter_name\' means \'counter_name\' DCNL will be included. DCNL The \'counter_name" is Counter namedtuple\'s name field. For counter DCNL names with variable like "instance:m1.tiny", it\'s "instance:*", as DCNL returned by get_counter_list(). DCNL Valid counters definition is all "included counter names", all DCNL "excluded counter names", wildcard and "excluded counter names", or DCNL only wildcard. DCNL Transformer\'s name is plugin name in setup.py. DCNL Publisher\'s name is plugin name in setup.py'
def publisher(self, context, source): DCNL 'Build a new Publisher for these manager pipelines. DCNL :param context: The context. DCNL :param source: Counter source.'
def format(self, record): DCNL 'Uses contextstring if request_id is set, otherwise default.'
def formatException(self, exc_info, record=None): DCNL 'Format exception output with CONF.logging_exception_prefix.'
@abc.abstractmethod DCNL def serialize_entity(self, context, entity): DCNL 'Serialize something to primitive form. DCNL :param context: Security context DCNL :param entity: Entity to be serialized DCNL :returns: Serialized form of entity'
@abc.abstractmethod DCNL def deserialize_entity(self, context, entity): DCNL 'Deserialize something from primitive form. DCNL :param context: Security context DCNL :param entity: Primitive to be deserialized DCNL :returns: Deserialized form of entity'
def __init__(self, topic, default_version, version_cap=None, serializer=None): DCNL 'Initialize an RpcProxy. DCNL :param topic: The topic to use for all messages. DCNL :param default_version: The default API version to request in all DCNL outgoing messages.  This can be overridden on a per-message DCNL basis. DCNL :param version_cap: Optionally cap the maximum version used for sent DCNL messages. DCNL :param serializer: Optionaly (de-)serialize entities with a DCNL provided helper.'
def _set_version(self, msg, vers): DCNL 'Helper method to set the version in a message. DCNL :param msg: The message having a version added to it. DCNL :param vers: The version number to add to the message.'
def _get_topic(self, topic): DCNL 'Return the topic to use for a message.'
def can_send_version(self, version): DCNL 'Check to see if a version is compatible with the version cap.'
def _serialize_msg_args(self, context, kwargs): DCNL 'Helper method called to serialize message arguments. DCNL This calls our serializer on each argument, returning a new DCNL set of args that have been serialized. DCNL :param context: The request context DCNL :param kwargs: The arguments to serialize DCNL :returns: A new set of serialized arguments'
def call(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.call() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :returns: The return value from the remote method.'
def multicall(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.multicall() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :returns: An iterator that lets you process each of the returned values DCNL from the remote method as they arrive.'
def cast(self, context, msg, topic=None, version=None): DCNL 'rpc.cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast() does not wait on any return value from the DCNL remote method.'
def fanout_cast(self, context, msg, topic=None, version=None): DCNL 'rpc.fanout_cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast() does not wait on any return value DCNL from the remote method.'
def cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast_to_server() does not wait on any DCNL return values.'
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.fanout_cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast_to_server() does not wait on any DCNL return values.'
def __init__(self, conf, connection_pool, pooled=True, server_params=None): DCNL 'Create a new connection, or get one from the pool.'
def __enter__(self): DCNL 'When with ConnectionContext() is used, return self.'
def _done(self): DCNL 'If the connection came from a pool, clean it up and put it back. DCNL If it did not come from a pool, close it.'
def __exit__(self, exc_type, exc_value, tb): DCNL 'End of \'with\' statement.  We\'re done here.'
def __del__(self): DCNL 'Caller is done with this connection.  Make sure we cleaned up.'
def close(self): DCNL 'Caller is done with this connection.'
def __getattr__(self, key): DCNL 'Proxy all other calls to the Connection instance.'
def check_duplicate_message(self, message_data): DCNL 'AMQP consumers may read same message twice when exceptions occur DCNL before ack is returned. This method prevents doing it.'
def wait(self): DCNL 'Wait for all callback threads to exit.'
def __init__(self, conf, callback, connection_pool): DCNL 'Initiates CallbackWrapper object. DCNL :param conf: cfg.CONF instance DCNL :param callback: a callable (probably a function) DCNL :param connection_pool: connection pool as returned by DCNL get_connection_pool()'
def __call__(self, message_data): DCNL 'Consumer callback to call a method on a proxy object. DCNL Parses the message for validity and fires off a thread to call the DCNL proxy object method. DCNL Message data should be a dictionary with two keys: DCNL method: string representing the method to call DCNL args: dictionary of arg: value DCNL Example: {\'method\': \'echo\', \'args\': {\'value\': 42}}'
def _process_data(self, ctxt, version, method, namespace, args): DCNL 'Process a message in a new thread. DCNL If the proxy object we have has a dispatch method DCNL (see rpc.dispatcher.RpcDispatcher), pass it the version, DCNL method, and args and let it dispatch as appropriate.  If not, use DCNL the old behavior of magically calling the specified method on the DCNL proxy we have here.'
def __iter__(self): DCNL 'Return a result until we get a reply with an \'ending\' flag.'
def __init__(self, callbacks, serializer=None): DCNL 'Initialize the rpc dispatcher. DCNL :param callbacks: List of proxy objects that are an instance DCNL of a class with rpc methods exposed.  Each proxy DCNL object should have an RPC_API_VERSION attribute. DCNL :param serializer: The Serializer object that will be used to DCNL deserialize arguments before the method call and DCNL to serialize the result after it returns.'
def _deserialize_args(self, context, kwargs): DCNL 'Helper method called to deserialize args before dispatch. DCNL This calls our serializer on each argument, returning a new set of DCNL args that have been deserialized. DCNL :param context: The request context DCNL :param kwargs: The arguments to be deserialized DCNL :returns: A new set of deserialized args'
def dispatch(self, ctxt, version, method, namespace, **kwargs): DCNL 'Dispatch a message based on a requested version. DCNL :param ctxt: The request context DCNL :param version: The requested API version from the incoming message DCNL :param method: The method requested to be called by the incoming DCNL message. DCNL :param namespace: The namespace for the requested method.  If None, DCNL the dispatcher will look for a method on a callback DCNL object with no namespace set. DCNL :param kwargs: A dict of keyword arguments to be passed to the method. DCNL :returns: Whatever is returned by the underlying method that gets DCNL called.'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a key.host is alive. DCNL Used internally for updating heartbeats, but may also be used DCNL publically to acknowledge a system is alive (i.e. rpc message DCNL successfully sent to host)'
def is_alive(self, topic, host): DCNL 'Checks if a host is alive.'
def expire(self, topic, host): DCNL 'Explicitly expire a host\'s registration.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Spawn heartbeat greenthread.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a host.topic is alive. DCNL Used internally for updating heartbeats, but may also be used DCNL publically to acknowledge a system is alive (i.e. rpc message DCNL successfully sent to host)'
def backend_register(self, key, host): DCNL 'Implements registration logic. DCNL Called by register(self,key,host)'
def backend_unregister(self, key, key_host): DCNL 'Implements de-registration logic. DCNL Called by unregister(self,key,host)'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Implementation of MatchMakerBase.start_heartbeat. DCNL Launches greenthread looping send_heartbeats(), DCNL yielding for CONF.matchmaker_heartbeat_freq seconds DCNL between iterations.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts): DCNL 'Declare a queue on an amqp session. DCNL \'session\' is the amqp session to use DCNL \'callback\' is the callback to call when messages are received DCNL \'node_name\' is the first part of the Qpid address string, before \';\' DCNL \'node_opts\' will be applied to the "x-declare" section of "node" DCNL in the address string. DCNL \'link_name\' goes into the "name" field of the "link" in the address DCNL string DCNL \'link_opts\' will be applied to the "x-declare" section of "link" DCNL in the address string.'
def reconnect(self, session): DCNL 'Re-declare the receiver after a qpid reconnect.'
def _unpack_json_msg(self, msg): DCNL 'Load the JSON data in msg if msg.content_type indicates that it DCNL is necessary.  Put the loaded data back into msg.content and DCNL update msg.content_type appropriately. DCNL A Qpid Message containing a dict will have a content_type of DCNL \'amqp/map\', whereas one containing a string that needs to be converted DCNL back from JSON will have a content_type of JSON_CONTENT_TYPE. DCNL :param msg: a Qpid Message object DCNL :returns: None'
def consume(self): DCNL 'Fetch the message and pass it to the callback object.'
def __init__(self, conf, session, msg_id, callback): DCNL 'Init a \'direct\' queue. DCNL \'session\' is the amqp session to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None): DCNL 'Init a \'topic\' queue. DCNL :param session: the amqp session to use DCNL :param topic: is the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param name: optional queue name, defaults to topic'
def __init__(self, conf, session, topic, callback): DCNL 'Init a \'fanout\' queue. DCNL \'session\' is the amqp session to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, session, node_name, node_opts=None): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, session): DCNL 'Re-establish the Sender after a reconnection.'
def _pack_json_msg(self, msg): DCNL 'Qpid cannot serialize dicts containing strings longer than 65535 DCNL characters.  This function dumps the message content to a JSON DCNL string, which Qpid is able to handle. DCNL :param msg: May be either a Qpid Message object or a bare dict. DCNL :returns: A Qpid Message with its content field JSON encoded.'
def send(self, msg): DCNL 'Send a message.'
def __init__(self, conf, session, msg_id): DCNL 'Init a \'direct\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'fanout\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing sessions and queues.'
def close(self): DCNL 'Close/release this connection.'
def reset(self): DCNL 'Reset a connection so it can be used again.'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers.'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread.'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg): DCNL 'Send to a publisher based on the publisher class.'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer.'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message.'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message.'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message.'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic.'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers.'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread.'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object.'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object.'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
def socket_s(self): DCNL 'Get socket type as string.'
def subscribe(self, msg_filter): DCNL 'Subscribe.'
def unsubscribe(self, msg_filter): DCNL 'Unsubscribe.'
def _get_response(self, ctx, proxy, topic, data): DCNL 'Process a curried message and cast the result to topic.'
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None): DCNL 'Reply to a casted call.'
def consume_in_thread(self): DCNL 'Runs the ZmqProxy service.'
def __init__(self, info=None, topic=None, method=None): DCNL 'Initiates Timeout object. DCNL :param info: Extra info to convey to the user DCNL :param topic: The topic that the rpc call was sent to DCNL :param rpc_method_name: The name of the rpc method being DCNL called'
def close(self): DCNL 'Close the connection. DCNL This method must be called when the connection will no longer be used. DCNL It will ensure that any resources associated with the connection, such DCNL as a network connection, and cleaned up.'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer on this connection. DCNL A consumer is associated with a message queue on the backend message DCNL bus.  The consumer will read messages from the queue, unpack them, and DCNL dispatch them to the proxy object.  The contents of the message pulled DCNL off of the queue will determine which method gets called on the proxy DCNL object. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. For example, all instances of nova-compute consume DCNL from a queue called "compute".  In that case, the DCNL messages will get distributed amongst the consumers in a DCNL round-robin fashion if fanout=False.  If fanout=True, DCNL every consumer associated with this topic will get a DCNL copy of every message. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param fanout: Whether or not this is a fanout topic.  See the DCNL documentation for the topic parameter for some DCNL additional comments on this.'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker on this connection. DCNL A worker is like a regular consumer of messages directed to a DCNL topic, except that it is part of a set of such consumers (the DCNL "pool") which may run in parallel. Every pool of workers will DCNL receive a given message, but only one worker in the pool will DCNL be asked to process it. Load is distributed across the members DCNL of the pool in round-robin fashion. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param pool_name: String containing the name of the pool of workers'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name): DCNL 'Register as a member of a group of consumers. DCNL Uses given topic from the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created. DCNL :param callback: Callable to be invoked for each message. DCNL :type callback: callable accepting one argument DCNL :param pool_name: The name of the consumer pool. DCNL :type pool_name: str DCNL :param topic: The routing topic for desired messages. DCNL :type topic: str DCNL :param exchange_name: The name of the message exchange where DCNL the client should attach. Defaults to DCNL the configured exchange. DCNL :type exchange_name: str'
def consume_in_thread(self): DCNL 'Spawn a thread to handle incoming messages. DCNL Spawn a thread that will be responsible for handling all incoming DCNL messages for consumers that were set up on this connection. DCNL Message dispatching inside of this is expected to be implemented in a DCNL non-blocking manner.  An example implementation would be having this DCNL thread pull messages in for all of the consumers, but utilize a thread DCNL pool for dispatching the messages to the proxy objects.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
def __init__(self, channel, callback, tag, **kwargs): DCNL 'Declare a queue on an amqp channel. DCNL \'channel\' is the amqp channel to use DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL queue name, exchange name, and other kombu options are DCNL passed in here as a dictionary.'
def reconnect(self, channel): DCNL 'Re-declare the queue after a rabbit reconnect.'
def consume(self, *args, **kwargs): DCNL 'Actually declare the consumer on the amqp channel.  This will DCNL start the flow of messages from the queue.  Using the DCNL Connection.iterconsume() iterator will process the messages, DCNL calling the appropriate callback. DCNL If a callback is specified in kwargs, use that.  Otherwise, DCNL use the callback passed during __init__() DCNL If kwargs[\'nowait\'] is True, then this call will block until DCNL a message is read. DCNL Messages will automatically be acked if the callback doesn\'t DCNL raise an exception'
def cancel(self): DCNL 'Cancel the consuming from the queue, if it has started.'
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs): DCNL 'Init a \'direct\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs): DCNL 'Init a \'topic\' queue. DCNL :param channel: the amqp channel to use DCNL :param topic: the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param tag: a unique ID for the consumer on the channel DCNL :param name: optional queue name, defaults to topic DCNL :paramtype name: str DCNL Other kombu options may be passed as keyword arguments'
def __init__(self, conf, channel, topic, callback, tag, **kwargs): DCNL 'Init a \'fanout\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, channel, exchange_name, routing_key, **kwargs): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, channel): DCNL 'Re-establish the Producer after a rabbit reconnection.'
def send(self, msg, timeout=None): DCNL 'Send a message.'
def __init__(self, conf, channel, msg_id, **kwargs): DCNL 'init a \'direct\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'topic\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'fanout\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def _fetch_ssl_params(self): DCNL 'Handles fetching what ssl params should be used for the connection DCNL (if any).'
def _connect(self, params): DCNL 'Connect to rabbit.  Re-establish any queues that may have DCNL been declared before if we are reconnecting.  Exceptions should DCNL be handled by the caller.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing queues. DCNL Will retry up to self.max_retries number of times. DCNL self.max_retries = 0 means to retry forever. DCNL Sleep between tries, starting at self.interval_start DCNL seconds, backing off self.interval_stepping number of seconds DCNL each attempt.'
def get_channel(self): DCNL 'Convenience call for bin/clear_rabbit_queues.'
def close(self): DCNL 'Close/release this connection.'
def reset(self): DCNL 'Reset a connection so it can be used again.'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers.'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread.'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs): DCNL 'Send to a publisher based on the publisher class.'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer.'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message.'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message.'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message.'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic.'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers.'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread.'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object.'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object.'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
def save(self, session=None): DCNL 'Save this object.'
def update(self, values): DCNL 'Make the model object behave like a dict.'
def iteritems(self): DCNL 'Make the model object behave like a dict. DCNL Includes attributes from joins.'
def soft_delete(self, session=None): DCNL 'Mark this object as deleted.'
@lockutils.synchronized('dbapi_backend', 'ceilometer-') DCNL def __get_backend(self): DCNL 'Get the actual backend.  May be a module or an instance of DCNL a class.  Doesn\'t matter to us.  We do this synchronized as it\'s DCNL possible multiple greenthreads started very quickly trying to do DCNL DB calls and eventlet can switch threads before self.__backend gets DCNL assigned.'
def __init__(self, retvalue=True): DCNL ':param retvalue: Value that LoopingCall.wait() should return.'
@classmethod DCNL def load_json(cls, data, default_rule=None): DCNL 'Allow loading of JSON rule data.'
def __init__(self, rules=None, default_rule=None): DCNL 'Initialize the Rules store.'
def __missing__(self, key): DCNL 'Implements the default rule handling.'
def __str__(self): DCNL 'Dumps a string representation of the rules.'
def set_rules(self, rules, overwrite=True): DCNL 'Create a new Rules object based on the provided dict of rules. DCNL :param rules: New rules to use. It should be an instance of dict. DCNL :param overwrite: Whether to overwrite current rules or update them DCNL with the new rules.'
def clear(self): DCNL 'Clears Enforcer rules, policy\'s cache and policy\'s path.'
def load_rules(self, force_reload=False): DCNL 'Loads policy_path\'s rules. DCNL Policy file is cached and will be reloaded if modified. DCNL :param force_reload: Whether to overwrite current rules.'
def _get_policy_path(self): DCNL 'Locate the policy json data file. DCNL :param policy_file: Custom policy file to locate. DCNL :returns: The policy path DCNL :raises: ConfigFilesNotFoundError if the file couldn\'t DCNL be located.'
def enforce(self, rule, target, creds, do_raise=False, exc=None, *args, **kwargs): DCNL 'Checks authorization of a rule against the target and credentials. DCNL :param rule: A string or BaseCheck instance specifying the rule DCNL to evaluate. DCNL :param target: As much information about the object being operated DCNL on as possible, as a dictionary. DCNL :param creds: As much information about the user performing the DCNL action as possible, as a dictionary. DCNL :param do_raise: Whether to raise an exception or not if check DCNL fails. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passed to check() (both DCNL positional and keyword arguments) will be passed to DCNL the exception class. If not specified, PolicyNotAuthorized DCNL will be used. DCNL :return: Returns False if the policy does not allow the action and DCNL exc is not provided; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specified string DCNL from the expression.'
@abc.abstractmethod DCNL def __str__(self): DCNL 'String representation of the Check tree rooted at this node.'
@abc.abstractmethod DCNL def __call__(self, target, cred): DCNL 'Triggers if instance of the class is called. DCNL Performs the check. Returns False to reject the access or a DCNL true value (not necessary True) to accept the access.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __init__(self, kind, match): DCNL 'Initiates Check instance. DCNL :param kind: The kind of the check, i.e., the field before the DCNL :param match: The match of the check, i.e., the field after DCNL the \':\'.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __init__(self, rule): DCNL 'Initialize the \'not\' check. DCNL :param rule: The rule to negate.  Must be a Check.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy. DCNL Returns the logical inverse of the wrapped check.'
def __init__(self, rules): DCNL 'Initialize the \'and\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy. DCNL Requires that all rules accept in order to return True.'
def add_check(self, rule): DCNL 'Adds rule to be tested. DCNL Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the AndCheck object for convenience.'
def __init__(self, rules): DCNL 'Initialize the \'or\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy. DCNL Requires that at least one rule accept in order to return True.'
def add_check(self, rule): DCNL 'Adds rule to be tested. DCNL Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the OrCheck object for convenience.'
def __new__(mcs, name, bases, cls_dict): DCNL 'Create the class. DCNL Injects the \'reducers\' list, a list of tuples matching token sequences DCNL to the names of the corresponding reduction methods.'
def __init__(self): DCNL 'Initialize the ParseState.'
def reduce(self): DCNL 'Perform a greedy reduction of the token stream. DCNL If a reducer method matches, it will be executed, then the DCNL reduce() method will be called recursively to search for any more DCNL possible reductions.'
def shift(self, tok, value): DCNL 'Adds one more token to the state.  Calls reduce().'
@property DCNL def result(self): DCNL 'Obtain the final result of the parse. DCNL Raises ValueError if the parse failed to reduce to a single result.'
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2): DCNL 'Turn parenthesized expressions into a \'check\' token.'
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2): DCNL 'Create an \'and_expr\'. DCNL Join two checks by the \'and\' operator.'
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check): DCNL 'Extend an \'and_expr\' by adding one more check.'
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2): DCNL 'Create an \'or_expr\'. DCNL Join two checks by the \'or\' operator.'
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check): DCNL 'Extend an \'or_expr\' by adding one more check.'
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check): DCNL 'Invert the result of another check.'
def __call__(self, target, creds, enforcer): DCNL 'Recursively checks credentials based on the defined rules.'
def __call__(self, target, creds, enforcer): DCNL 'Check that there is a matching role in the cred dict.'
def __call__(self, target, creds, enforcer): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response DCNL is exactly \'True\'.'
def __call__(self, target, creds, enforcer): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def __init__(self): DCNL 'Initialize the service launcher. DCNL :returns: None'
@staticmethod DCNL def run_service(service): DCNL 'Start and wait for a service to finish. DCNL :param service: service to run and wait for. DCNL :returns: None'
def launch_service(self, service): DCNL 'Load and start the given service. DCNL :param service: The service you would like to start. DCNL :returns: None'
def stop(self): DCNL 'Stop all services which are currently running. DCNL :returns: None'
def wait(self): DCNL 'Waits until all services have been stopped, and then returns. DCNL :returns: None'
def wait(self): DCNL 'Loop waiting on children to die and respawning as necessary.'
def __init__(self, locale, target): DCNL 'Initialize a LocaleHandler DCNL :param locale: locale to use for translating messages DCNL :param target: logging.Handler object to forward DCNL LogRecord objects to after translation'
def __init__(self, **kwargs): DCNL 'Setup transformer. DCNL Each time a transformed is involved in a pipeline, a new transformer DCNL instance is created and chained into the pipeline. i.e. transformer DCNL instance is per pipeline. This helps if transformer need keep some DCNL cache and per-pipeline information. DCNL :param kwargs: The parameters that are defined in pipeline config file.'
def flush(self, context, source): DCNL 'Flush counters cached previously. DCNL :param context: Passed from the data collector. DCNL :param source: Source of counters that are being published.'
def iter_images(self, ksclient): DCNL 'Iterate over all images.'
@staticmethod DCNL def get_exchange_topics(conf): DCNL 'Return a sequence of ExchangeTopics defining the exchange and DCNL topics to be connected for this plugin.'
def __init__(self): DCNL 'Returns a nova Client object.'
@logged DCNL def instance_get_all_by_host(self, hostname): DCNL 'Returns list of instances on particular host.'
@logged DCNL def floating_ip_get_all(self): DCNL 'Returns all floating ips.'
def get_connection(self, conf): DCNL 'Return a Connection instance based on the configuration settings.'
def record_metering_data(self, data): DCNL 'Write the data to the backend storage system. DCNL :param data: a dictionary such as returned by DCNL ceilometer.meter.meter_message_from_counter'
def get_users(self, source=None): DCNL 'Return an iterable of user id strings. DCNL :param source: Optional source filter.'
def get_projects(self, source=None): DCNL 'Return an iterable of project id strings. DCNL :param source: Optional source filter.'
def get_resources(self, user=None, project=None, source=None, start_timestamp=None, end_timestamp=None, metaquery={}, resource=None): DCNL 'Return an iterable of dictionaries containing resource information. DCNL { \'resource_id\': UUID of the resource, DCNL \'project_id\': UUID of project owning the resource, DCNL \'user_id\': UUID of user owning the resource, DCNL \'timestamp\': UTC datetime of last update to the resource, DCNL \'metadata\': most current metadata for the resource, DCNL \'meter\': list of the meters reporting data for the resource, DCNL :param user: Optional ID for user that owns the resource. DCNL :param project: Optional ID for project that owns the resource. DCNL :param source: Optional source filter. DCNL :param start_timestamp: Optional modified timestamp start range. DCNL :param end_timestamp: Optional modified timestamp end range. DCNL :param metaquery: Optional dict with metadata to match on. DCNL :param resource: Optional resource filter.'
def get_meters(self, user=None, project=None, resource=None, source=None, limit=None, metaquery={}): DCNL 'Return an iterable of dictionaries containing meter information. DCNL { \'name\': name of the meter, DCNL \'type\': type of the meter (guage, counter), DCNL \'resource_id\': UUID of the resource, DCNL \'project_id\': UUID of project owning the resource, DCNL \'user_id\': UUID of user owning the resource, DCNL :param user: Optional ID for user that owns the resource. DCNL :param project: Optional ID for project that owns the resource. DCNL :param resource: Optional resource filter. DCNL :param source: Optional source filter. DCNL :param limit: Maximum number of results to return. DCNL :param metaquery: Optional dict with metadata to match on.'
def get_samples(self, sample_filter): DCNL 'Return an iterable of samples as created by DCNL :func:`ceilometer.meter.meter_message_from_counter`.'
def get_meter_statistics(self, sample_filter, period=None): DCNL 'Return a dictionary containing meter statistics. DCNL described by the query parameters. DCNL The filter must have a meter value set. DCNL { \'min\': DCNL \'max\': DCNL \'avg\': DCNL \'sum\': DCNL \'count\': DCNL \'period\': DCNL \'period_start\': DCNL \'period_end\': DCNL \'duration\': DCNL \'duration_start\': DCNL \'duration_end\':'
def get_alarms(self, name=None, user=None, project=None, enabled=True, alarm_id=None): DCNL 'Yields a lists of alarms that match filters'
def update_alarm(self, alarm): DCNL 'update alarm'
def record_events(self, events): DCNL 'Write the events. DCNL :param events: a list of model.Event objects.'
def get_events(self, event_filter): DCNL 'Return an iterable of model.Event objects. DCNL :param event_filter: EventFilter instance'
def update(self, values): DCNL 'Make the model object behave like a dict.'
def __init__(self, event_name, generated, traits): DCNL 'Create a new event. DCNL :param event_name:  Name of the event. DCNL :param generated:   UTC time for when the event occured. DCNL :param traits:      list of Traits on this Event.'
def __init__(self, resource_id, project_id, source, user_id, metadata, meter): DCNL 'Create a new resource. DCNL :param resource_id: UUID of the resource DCNL :param project_id:  UUID of project owning the resource DCNL :param source:      the identifier for the user/project id definition DCNL :param user_id:     UUID of user owning the resource DCNL :param metadata:    most current metadata for the resource (a dict) DCNL :param meter:       list of the meters reporting data for the resource,'
def __init__(self, counter_name, counter_type, counter_unit): DCNL 'Create a new resource meter. DCNL :param counter_name: the name of the counter updating the resource DCNL :param counter_type: one of gauge, delta, cumulative DCNL :param counter_unit: official units name for the sample data'
def __init__(self, name, type, unit, resource_id, project_id, source, user_id): DCNL 'Create a new meter. DCNL :param name: name of the meter DCNL :param type: type of the meter (guage, counter) DCNL :param unit: unit of the meter DCNL :param resource_id: UUID of the resource DCNL :param project_id: UUID of project owning the resource DCNL :param source: the identifier for the user/project id definition DCNL :param user_id: UUID of user owning the resource'
def __init__(self, source, counter_name, counter_type, counter_unit, counter_volume, user_id, project_id, resource_id, timestamp, resource_metadata, message_id, message_signature): DCNL 'Create a new sample. DCNL :param source: the identifier for the user/project id definition DCNL :param counter_name: the name of the measurement being taken DCNL :param counter_type: the type of the measurement DCNL :param counter_unit: the units for the measurement DCNL :param counter_volume: the measured value DCNL :param user_id: the user that triggered the measurement DCNL :param project_id: the project that owns the resource DCNL :param resource_id: the thing on which the measurement was taken DCNL :param timestamp: the time of the measurement DCNL :param resource_metadata: extra details about the resource DCNL :param message_id: a message identifier DCNL :param message_signature: a hash created from the rest of the DCNL message data'
def __init__(self, min, max, avg, sum, count, period, period_start, period_end, duration, duration_start, duration_end): DCNL 'Create a new statistics object. DCNL :param min: The smallest volume found DCNL :param max: The largest volume found DCNL :param avg: The average of all volumes found DCNL :param sum: The total of all volumes found DCNL :param count: The number of samples found DCNL :param period: The length of the time range covered by these stats DCNL :param period_start: The timestamp for the start of the period DCNL :param period_end: The timestamp for the end of the period DCNL :param duration: The total time for the matching samples DCNL :param duration_start: The earliest time for the matching samples DCNL :param duration_end: The latest time for the matching samples'
def register_opts(self, conf): DCNL 'Register any configuration options used by this engine.'
@staticmethod DCNL def get_connection(conf): DCNL 'Return a Connection instance based on the configuration settings.'
@staticmethod DCNL def record_metering_data(data): DCNL 'Write the data to the backend storage system. DCNL :param data: a dictionary such as returned by DCNL ceilometer.meter.meter_message_from_counter'
@staticmethod DCNL def get_users(source=None): DCNL 'Return an iterable of user id strings. DCNL :param source: Optional source filter.'
@staticmethod DCNL def get_projects(source=None): DCNL 'Return an iterable of project id strings. DCNL :param source: Optional source filter.'
@staticmethod DCNL def get_resources(user=None, project=None, source=None, start_timestamp=None, end_timestamp=None, metaquery={}, resource=None): DCNL 'Return an iterable of api_models.Resource instances DCNL :param user: Optional ID for user that owns the resource. DCNL :param project: Optional ID for project that owns the resource. DCNL :param source: Optional source filter. DCNL :param start_timestamp: Optional modified timestamp start range. DCNL :param end_timestamp: Optional modified timestamp end range. DCNL :param metaquery: Optional dict with metadata to match on. DCNL :param resource: Optional resource filter.'
@staticmethod DCNL def get_meters(user=None, project=None, resource=None, source=None, metaquery={}): DCNL 'Return an iterable of api_models.Meter instances DCNL :param user: Optional ID for user that owns the resource. DCNL :param project: Optional ID for project that owns the resource. DCNL :param resource: Optional ID of the resource. DCNL :param source: Optional source filter. DCNL :param metaquery: Optional dict with metadata to match on.'
@staticmethod DCNL def get_samples(sample_filter, limit=None): DCNL 'Return an iterable of api_models.Samples. DCNL :param sample_filter: Filter. DCNL :param limit: Maximum number of results to return.'
@staticmethod DCNL def _make_volume_query(sample_filter, counter_volume_func): DCNL 'Returns complex Meter counter_volume query for max and sum.'
def get_meter_statistics(self, sample_filter, period=None): DCNL 'Return an iterable of api_models.Statistics instances containing DCNL meter statistics described by the query parameters. DCNL The filter must have a meter value set.'
def get_alarms(self, name=None, user=None, project=None, enabled=True, alarm_id=None): DCNL 'Yields a lists of alarms that match filters DCNL :param user: Optional ID for user that owns the resource. DCNL :param project: Optional ID for project that owns the resource. DCNL :param enabled: Optional boolean to list disable alarm. DCNL :param alarm_id: Optional alarm_id to return one alarm.'
def update_alarm(self, alarm): DCNL 'update alarm DCNL :param alarm: the new Alarm to update'
@staticmethod DCNL def delete_alarm(alarm_id): DCNL 'Delete a alarm DCNL :param alarm_id: ID of the alarm to delete'
def _get_or_create_unique_name(self, key, session=None): DCNL 'Find the UniqueName entry for a given key, creating DCNL one if necessary. DCNL This may result in a flush.'
def _make_trait(self, trait_model, event, session=None): DCNL 'Make a new Trait from a Trait model. DCNL Doesn\'t flush or add to session.'
def _record_event(self, session, event_model): DCNL 'Store a single Event, including related Traits.'
def record_events(self, event_models): DCNL 'Write the events to SQL database via sqlalchemy. DCNL :param event_models: a list of model.Event objects. DCNL Flush when they\'re all added, unless new UniqueNames are DCNL added along the way.'
def get_events(self, event_filter): DCNL 'Return an iterable of model.Event objects. DCNL :param event_filter: EventFilter instance'
def register_opts(self, conf): DCNL 'Register any configuration options used by this engine.'
def get_connection(self, conf): DCNL 'Return a Connection instance based on the configuration settings.'
def record_metering_data(self, data): DCNL 'Write the data to the backend storage system. DCNL :param data: a dictionary such as returned by DCNL ceilometer.meter.meter_message_from_counter'
def get_users(self, source=None): DCNL 'Return an iterable of user id strings. DCNL :param source: Optional source filter.'
def get_projects(self, source=None): DCNL 'Return an iterable of project id strings. DCNL :param source: Optional source filter.'
def get_resources(self, user=None, project=None, source=None, start_timestamp=None, end_timestamp=None, metaquery={}, resource=None): DCNL 'Return an iterable of models.Resource instances DCNL :param user: Optional ID for user that owns the resource. DCNL :param project: Optional ID for project that owns the resource. DCNL :param source: Optional source filter. DCNL :param start_timestamp: Optional modified timestamp start range. DCNL :param end_timestamp: Optional modified timestamp end range. DCNL :param metaquery: Optional dict with metadata to match on. DCNL :param resource: Optional resource filter.'
def get_meters(self, user=None, project=None, resource=None, source=None, metaquery={}): DCNL 'Return an iterable of models.Meter instances DCNL :param user: Optional ID for user that owns the resource. DCNL :param project: Optional ID for project that owns the resource. DCNL :param resource: Optional resource filter. DCNL :param source: Optional source filter. DCNL :param metaquery: Optional dict with metadata to match on.'
def get_samples(self, sample_filter, limit=None): DCNL 'Return an iterable of model.Sample instances. DCNL :param sample_filter: Filter. DCNL :param limit: Maximum number of results to return.'
def get_meter_statistics(self, sample_filter, period=None): DCNL 'Return an iterable of models.Statistics instance containing meter DCNL statistics described by the query parameters. DCNL The filter must have a meter value set.'
def get_alarms(self, name=None, user=None, project=None, enabled=True, alarm_id=None): DCNL 'Yields a lists of alarms that match filters'
def update_alarm(self, alarm): DCNL 'update alarm'
def delete_alarm(self, alarm_id): DCNL 'Delete a alarm'
@staticmethod DCNL def record_events(events): DCNL 'Write the events. DCNL :param events: a list of model.Event objects.'
@staticmethod DCNL def get_events(event_filter): DCNL 'Return an iterable of model.Event objects. DCNL :param event_filter: EventFilter instance'
def register_opts(self, conf): DCNL 'Register any configuration options used by this engine.'
@staticmethod DCNL def get_connection(conf): DCNL 'Return a Connection instance based on the configuration settings.'
def __init__(self, conf): DCNL 'Hbase Connection Initialization'
@staticmethod DCNL def _get_connection(conf): DCNL 'Return a connection to the database. DCNL .. note:: DCNL The tests use a subclass to override this and return an DCNL in-memory connection.'
@staticmethod DCNL def _parse_connection_url(url): DCNL 'Parse connection parameters from a database url. DCNL .. note:: DCNL HBase Thrift does not support authentication and there is no DCNL database name, so we are not looking for these in the url.'
def record_metering_data(self, data): DCNL 'Write the data to the backend storage system. DCNL :param data: a dictionary such as returned by DCNL ceilometer.meter.meter_message_from_counter'
def get_users(self, source=None): DCNL 'Return an iterable of user id strings. DCNL :param source: Optional source filter.'
def get_projects(self, source=None): DCNL 'Return an iterable of project id strings. DCNL :param source: Optional source filter.'
def get_resources(self, user=None, project=None, source=None, start_timestamp=None, end_timestamp=None, metaquery={}): DCNL 'Return an iterable of models.Resource instances DCNL :param user: Optional ID for user that owns the resource. DCNL :param project: Optional ID for project that owns the resource. DCNL :param source: Optional source filter. DCNL :param start_timestamp: Optional modified timestamp start range. DCNL :param end_timestamp: Optional modified timestamp end range. DCNL :param metaquery: Optional dict with metadata to match on.'
def get_meters(self, user=None, project=None, resource=None, source=None, metaquery={}): DCNL 'Return an iterable of models.Meter instances DCNL :param user: Optional ID for user that owns the resource. DCNL :param project: Optional ID for project that owns the resource. DCNL :param resource: Optional resource filter. DCNL :param source: Optional source filter. DCNL :param metaquery: Optional dict with metadata to match on.'
def get_samples(self, sample_filter, limit=None): DCNL 'Return an iterable of models.Sample instances. DCNL :param sample_filter: Filter. DCNL :param limit: Maximum number of results to return.'
def _update_meter_stats(self, stat, meter): DCNL 'Do the stats calculation on a requested time bucket in stats dict DCNL :param stats: dict where aggregated stats are kept DCNL :param index: time bucket index in stats DCNL :param meter: meter record as returned from HBase DCNL :param start_time: query start time DCNL :param period: length of the time bucket'
def get_meter_statistics(self, sample_filter, period=None): DCNL 'Return an iterable of models.Statistics instances containing meter DCNL statistics described by the query parameters. DCNL The filter must have a meter value set. DCNL .. note:: DCNL Due to HBase limitations the aggregations are implemented DCNL in the driver itself, therefore this method will be quite slow DCNL because of all the Thrift traffic it is going to create.'
def get_alarms(self, name=None, user=None, project=None, enabled=True, alarm_id=None): DCNL 'Yields a lists of alarms that match filters DCNL raise NotImplementedError(\'metaquery not implemented\')'
def update_alarm(self, alarm): DCNL 'update alarm'
def delete_alarm(self, alarm_id): DCNL 'Delete a alarm'
def record_events(self, events): DCNL 'Write the events. DCNL :param events: a list of model.Event objects.'
def get_events(self, event_filter): DCNL 'Return an iterable of model.Event objects. DCNL :param event_filter: EventFilter instance'
@staticmethod DCNL def SingleColumnValueFilter(args, rows): DCNL 'This method is called from scan() when \'SingleColumnValueFilter\' DCNL is found in the \'filter\' argument'
@staticmethod DCNL def is_enabled(): DCNL 'Return boolean indicating whether this plugin should DCNL be enabled and used by the caller.'
def notification_to_metadata(self, event): DCNL 'Transform a payload dict to a metadata dict.'
@staticmethod DCNL def get_exchange_topics(conf): DCNL 'Return a sequence of ExchangeTopics defining the exchange and DCNL topics to be connected for this plugin.'
def setup_notifier_task(self): DCNL 'For nova notifier usage.'
def poll_instance(self, context, instance): DCNL 'Poll one instance.'
@staticmethod DCNL def get_exchange_topics(conf): DCNL 'Return a sequence of ExchangeTopics defining the exchange and DCNL topics to be connected for this plugin.'
def inspect_instances(self): DCNL 'List the instances on the current host.'
def inspect_cpus(self, instance_name): DCNL 'Inspect the CPU statistics for an instance. DCNL :param instance_name: the name of the target instance DCNL :return: the number of CPUs and cumulative CPU time'
def inspect_vnics(self, instance_name): DCNL 'Inspect the vNIC statistics for an instance. DCNL :param instance_name: the name of the target instance DCNL :return: for each vNIC, the number of bytes & packets DCNL received and transmitted'
def inspect_disks(self, instance_name): DCNL 'Inspect the disk statistics for an instance. DCNL :param instance_name: the name of the target instance DCNL :return: for each disk, the number of bytes & operations DCNL read and written, and the error count'
def _get_counters_from_plugin(self, ext, instance, *args, **kwds): DCNL 'Used with the extenaion manager map() method.'
def start(self): DCNL 'Bind the UDP socket and handle incoming data.'
def initialize_service_hook(self, service): DCNL 'Consumers must be declared before consume_thread start.'
def process_notification(self, notification): DCNL 'Make a notification processed by an handler.'
def record_metering_data(self, context, data): DCNL 'This method is triggered when metering data is DCNL cast from an agent.'
@staticmethod DCNL def get_exchange_topics(conf): DCNL 'Return a sequence of ExchangeTopics defining the exchange and topics DCNL to be connected for this plugin.'
def setUp(self): DCNL 'Set up for testing swift.object_server.ObjectController'
def tearDown(self): DCNL 'Tear down for testing swift.object_server.ObjectController'
def test_split_path(self): DCNL 'Copied from swift.common.utils.split_path'
def test_call_reifies_request_if_necessary(self): DCNL 'The actual bug was a HEAD response coming out with a body because the DCNL Request object wasn\'t passed into the Response object\'s constructor. DCNL The Response object\'s __call__ method should be able to reify a DCNL Request object from the env it gets passed.'
def test_log_request_stat_type_good(self): DCNL 'log_request() should send timing and byte-count counters for GET DCNL requests.  Also, __call__()\'s iter_response() function should DCNL statsd-log time to first byte (calling the passed-in start_response DCNL function), but only for GET requests.'
def test_deterministic_serialization(self): DCNL 'Two identical rings should produce identical .gz files on disk. DCNL Only true on Python 2.7 or greater.'
def test_add_rebalance_add_rebalance_delete_rebalance(self): DCNL 'Test for https://bugs.launchpad.net/swift/+bug/845952'
def test_creation(self): DCNL 'Test swift.common.db.ContainerBroker.__init__'
def test_exception(self): DCNL 'Test swift.common.db.ContainerBroker throwing a conn away after DCNL unhandled exception'
def test_empty(self): DCNL 'Test swift.common.db.ContainerBroker.empty'
def test_delete_object(self): DCNL 'Test swift.common.db.ContainerBroker.delete_object'
def test_put_object(self): DCNL 'Test swift.common.db.ContainerBroker.put_object'
def test_get_info(self): DCNL 'Test swift.common.db.ContainerBroker.get_info'
def test_list_objects_iter(self): DCNL 'Test swift.common.db.ContainerBroker.list_objects_iter'
def test_list_objects_iter_prefix_delim(self): DCNL 'Test swift.common.db.ContainerBroker.list_objects_iter'
def test_double_check_trailing_delimiter(self): DCNL 'Test swift.common.db.ContainerBroker.list_objects_iter for a DCNL container that has an odd file with a trailing delimiter'
def test_newid(self): DCNL 'test DatabaseBroker.newid'
def test_get_items_since(self): DCNL 'test DatabaseBroker.get_items_since'
def test_sync_merging(self): DCNL 'exercise the DatabaseBroker sync functions a bit'
def test_merge_items_overwrite(self): DCNL 'test DatabaseBroker.merge_items'
def test_merge_items_post_overwrite_out_of_order(self): DCNL 'test DatabaseBroker.merge_items'
def test_creation(self): DCNL 'Test swift.common.db.AccountBroker.__init__'
def test_exception(self): DCNL 'Test swift.common.db.AccountBroker throwing a conn away after DCNL exception'
def test_empty(self): DCNL 'Test swift.common.db.AccountBroker.empty'
def test_delete_container(self): DCNL 'Test swift.common.db.AccountBroker.delete_container'
def test_put_container(self): DCNL 'Test swift.common.db.AccountBroker.put_container'
def test_get_info(self): DCNL 'Test swift.common.db.AccountBroker.get_info'
def test_list_containers_iter(self): DCNL 'Test swift.common.db.AccountBroker.list_containers_iter'
def test_double_check_trailing_delimiter(self): DCNL 'Test swift.common.db.AccountBroker.list_containers_iter for an DCNL account that has an odd file with a trailing delimiter'
def test_canonical_version_is_clean(self): DCNL 'Ensure that a non-clean canonical_version never happens'
def test_iter_pid_files(self): DCNL 'Server.iter_pid_files is kinda boring, test the DCNL Server.pid_files stuff here as well'
def geteuid(self): DCNL 'Pretend we are running as root.'
def test_normalize_timestamp(self): DCNL 'Test swift.common.utils.normalize_timestamp'
def test_backwards(self): DCNL 'Test swift.common.utils.backward'
def test_split_path(self): DCNL 'Test swift.common.utils.split_account_path'
def test_validate_device_partition(self): DCNL 'Test swift.common.utils.validate_device_partition'
def test_NullLogger(self): DCNL 'Test swift.common.utils.NullLogger'
def _send_and_get(self, sender_fn, *args, **kwargs): DCNL 'Because the client library may not actually send a packet with DCNL sample_rate < 1, we keep trying until we get one through.'
def setUp(self): DCNL 'Set up for testing swift.object_server.ObjectController'
def tearDown(self): DCNL 'Tear down for testing swift.object_server.ObjectController'
def test_disk_file_large_app_iter_ranges(self): DCNL 'This test case is to make sure that the disk file app_iter_ranges DCNL method all the paths being tested.'
def test_disk_file_app_iter_ranges_empty(self): DCNL 'This test case tests when empty value passed into app_iter_ranges DCNL When ranges passed into the method is either empty array or None, DCNL this method will yield empty string'
def _get_data_file(self, invalid_type=None, obj_name='o', fsize=1024, csize=8, extension='.data', ts=None, iter_hook=None): DCNL 'returns a DiskFile'
def setUp(self): DCNL 'Set up for testing swift.object_server.ObjectController'
def tearDown(self): DCNL 'Tear down for testing swift.object_server.ObjectController'
def test_POST_update_meta(self): DCNL 'Test swift.object_server.ObjectController.POST'
def test_POST_quarantine_zbyte(self): DCNL 'Test swift.object_server.ObjectController.GET'
def test_HEAD(self): DCNL 'Test swift.object_server.ObjectController.HEAD'
def test_HEAD_quarantine_zbyte(self): DCNL 'Test swift.object_server.ObjectController.GET'
def test_GET(self): DCNL 'Test swift.object_server.ObjectController.GET'
def test_GET_quarantine(self): DCNL 'Test swift.object_server.ObjectController.GET'
def test_GET_quarantine_zbyte(self): DCNL 'Test swift.object_server.ObjectController.GET'
def test_GET_quarantine_range(self): DCNL 'Test swift.object_server.ObjectController.GET'
def test_DELETE(self): DCNL 'Test swift.object_server.ObjectController.DELETE'
def test_call(self): DCNL 'Test swift.object_server.ObjectController.__call__'
def test_collect_jobs_removes_zbf(self): DCNL 'After running xfs_repair, a partition directory could become a DCNL zero-byte file.  If this happens, collect_jobs() should clean it up and DCNL *not* create a job which will hit an exception as it tries to listdir() DCNL a file.'
def setUp(self): DCNL 'Set up for testing swift.account_server.AccountController'
def tearDown(self): DCNL 'Tear down for testing swift.account_server.AccountController'
def get_account_ring(self): DCNL 'Get the account ring.  Load it if it hasn\'t been yet.'
def get_paths(self): DCNL 'Get paths to all of the partitions on each drive to be processed. DCNL :returns: a list of paths'
def run_forever(self, *args, **kwargs): DCNL 'Run the updator continuously.'
def run_once(self, *args, **kwargs): DCNL 'Run the updater once.'
def container_sweep(self, path): DCNL 'Walk the path looking for container DBs and process them. DCNL :param path: path to walk'
def process_container(self, dbfile): DCNL 'Process a container, and update the information in the account. DCNL :param dbfile: container DB to process'
def container_report(self, node, part, container, put_timestamp, delete_timestamp, count, bytes): DCNL 'Report container info to an account server. DCNL :param node: node dictionary from the account ring DCNL :param part: partition the account is on DCNL :param container: container name DCNL :param put_timestamp: put timestamp DCNL :param delete_timestamp: delete timestamp DCNL :param count: object count in the container DCNL :param bytes: bytes used in the container'
def _get_container_broker(self, drive, part, account, container): DCNL 'Get a DB broker for the container. DCNL :param drive: drive that holds the container DCNL :param part: partition the container is in DCNL :param account: account name DCNL :param container: container name DCNL :returns: ContainerBroker object'
def account_update(self, req, account, container, broker): DCNL 'Update the account server(s) with latest container info. DCNL :param req: swob.Request object DCNL :param account: account name DCNL :param container: container name DCNL :param broker: container DB broker object DCNL :returns: if all the account requests return a 404 error code, DCNL HTTPNotFound response object, DCNL if the account cannot be updated due to a malformed header, DCNL an HTTPBadRequest response object, DCNL otherwise None.'
@public DCNL @timing_stats() DCNL def DELETE(self, req): DCNL 'Handle HTTP DELETE request.'
@public DCNL @timing_stats() DCNL def PUT(self, req): DCNL 'Handle HTTP PUT request.'
@public DCNL @timing_stats(sample_rate=0.1) DCNL def HEAD(self, req): DCNL 'Handle HTTP HEAD request.'
def derive_content_type_metadata(self, content_type, size): DCNL 'Will check the last parameter and if it starts with \'swift_bytes=\' will DCNL strip it off. Returns either the passed in content_type and size DCNL or the content_type without the swift_bytes param and its value as DCNL the new size. DCNL :params content_type: Content Type from db DCNL :params size: # bytes from db, an int DCNL :returns: tuple: content_type, size'
@public DCNL @timing_stats() DCNL def GET(self, req): DCNL 'Handle HTTP GET request.'
@public DCNL @timing_stats(sample_rate=0.01) DCNL def REPLICATE(self, req): DCNL 'Handle HTTP REPLICATE request (json-encoded RPC calls for replication.)'
@public DCNL @timing_stats() DCNL def POST(self, req): DCNL 'Handle HTTP POST request.'
def run_forever(self, *args, **kwargs): DCNL 'Run the container audit until stopped.'
def run_once(self, *args, **kwargs): DCNL 'Run the container audit once.'
def container_audit(self, path): DCNL 'Audits the given container path DCNL :param path: the path to a container db'
def read(self, size=(-1)): DCNL 'read([size]) -> read at most size bytes, returned as a string. DCNL If the size argument is negative or omitted, read until EOF is reached. DCNL Notice that when in non-blocking mode, less data than what was DCNL requested may be returned, even if no size parameter was given.'
def run_forever(self): DCNL 'Runs container sync scans until stopped.'
def run_once(self): DCNL 'Runs a single container sync scan.'
def report(self): DCNL 'Writes a report of the stats to the logger and resets the stats for the DCNL next report.'
def container_sync(self, path): DCNL 'Checks the given path for a container database, determines if syncing DCNL is turned on for that database and, if so, sends any updates to the DCNL other container. DCNL :param path: the path to a container db'
def container_sync_row(self, row, sync_to, sync_key, broker, info): DCNL 'Sends the update the row indicates to the sync_to container. DCNL :param row: The updated row in the local database triggering the sync DCNL update. DCNL :param sync_to: The URL to the remote container. DCNL :param sync_key: The X-Container-Sync-Key to use when sending requests DCNL to the other container. DCNL :param broker: The local container database broker. DCNL :param info: The get_info result from the local container database DCNL broker. DCNL :returns: True on success'
def __init__(self, db_file, timeout=BROKER_TIMEOUT, logger=None, account=None, container=None, pending_timeout=10, stale_reads_ok=False): DCNL 'Encapsulates working with a database.'
def initialize(self, put_timestamp=None): DCNL 'Create the DB DCNL :param put_timestamp: timestamp of initial PUT request'
def delete_db(self, timestamp): DCNL 'Mark the DB as deleted DCNL :param timestamp: delete timestamp'
def possibly_quarantine(self, exc_type, exc_value, exc_traceback): DCNL 'Checks the exception info to see if it indicates a quarantine situation DCNL (malformed or corrupted database). If not, the original exception will DCNL be reraised. If so, the database will be quarantined and a new DCNL sqlite3.DatabaseError will be raised indicating the action taken.'
@contextmanager DCNL def get(self): DCNL 'Use with the "with" statement; returns a database connection.'
@contextmanager DCNL def lock(self): DCNL 'Use with the "with" statement; locks a database.'
def newid(self, remote_id): DCNL 'Re-id the database.  This should be called after an rsync. DCNL :param remote_id: the ID of the remote database being rsynced in'
def merge_timestamps(self, created_at, put_timestamp, delete_timestamp): DCNL 'Used in replication to handle updating timestamps. DCNL :param created_at: create timestamp DCNL :param put_timestamp: put timestamp DCNL :param delete_timestamp: delete timestamp'
def get_items_since(self, start, count): DCNL 'Get a list of objects in the database between start and end. DCNL :param start: start ROWID DCNL :param count: number to get DCNL :returns: list of objects between start and end'
def get_sync(self, id, incoming=True): DCNL 'Gets the most recent sync point for a server from the sync table. DCNL :param id: remote ID to get the sync_point for DCNL :param incoming: if True, get the last incoming sync, otherwise get DCNL the last outgoing sync DCNL :returns: the sync point, or -1 if the id doesn\'t exist.'
def get_syncs(self, incoming=True): DCNL 'Get a serialized copy of the sync table. DCNL :param incoming: if True, get the last incoming sync, otherwise get DCNL the last outgoing sync DCNL :returns: list of {\'remote_id\', \'sync_point\'}'
def get_replication_info(self): DCNL 'Get information about the DB required for replication. DCNL :returns: dict containing keys: hash, id, created_at, put_timestamp, DCNL delete_timestamp, count, max_row, and metadata'
def merge_syncs(self, sync_points, incoming=True): DCNL 'Merge a list of sync points with the incoming sync table. DCNL :param sync_points: list of sync points where a sync point is a dict of DCNL {\'sync_point\', \'remote_id\'} DCNL :param incoming: if True, get the last incoming sync, otherwise get DCNL the last outgoing sync'
def _preallocate(self): DCNL 'The idea is to allocate space in front of an expanding db.  If it gets DCNL within 512k of a boundary, it allocates to the next boundary. DCNL Boundaries are 2m, 5m, 10m, 25m, 50m, then every 50m after.'
@property DCNL def metadata(self): DCNL 'Returns the metadata dict for the database. The metadata dict values DCNL are tuples of (value, timestamp) where the timestamp indicates when DCNL that key was set to that value.'
def update_metadata(self, metadata_updates): DCNL 'Updates the metadata dict for the database. The metadata dict values DCNL are tuples of (value, timestamp) where the timestamp indicates when DCNL that key was set to that value. Key/values will only be overwritten if DCNL the timestamp is newer. To delete a key, set its value to (\'\', DCNL timestamp). These empty keys will eventually be removed by DCNL :func:reclaim'
def reclaim(self, timestamp): DCNL 'Removes any empty metadata values older than the timestamp'
def _reclaim(self, conn, timestamp): DCNL 'Removes any empty metadata values older than the timestamp using the DCNL given database connection. This function will not call commit on the DCNL conn, but will instead return True if the database needs committing. DCNL This function was created as a worker to limit transactions and commits DCNL from other related functions. DCNL :param conn: Database connection to reclaim metadata within. DCNL :param timestamp: Empty metadata items last updated before this DCNL timestamp will be removed. DCNL :returns: True if conn.commit() should be called'
def _initialize(self, conn, put_timestamp): DCNL 'Creates a brand new database (tables, indices, triggers, etc.)'
def create_object_table(self, conn): DCNL 'Create the object table which is specifc to the container DB. DCNL :param conn: DB connection object'
def create_container_stat_table(self, conn, put_timestamp=None): DCNL 'Create the container_stat table which is specific to the container DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'
def update_put_timestamp(self, timestamp): DCNL 'Update the put_timestamp.  Only modifies it if it is greater than DCNL the current timestamp. DCNL :param timestamp: put timestamp'
def _delete_db(self, conn, timestamp): DCNL 'Mark the DB as deleted DCNL :param conn: DB connection object DCNL :param timestamp: timestamp to mark as deleted'
def empty(self): DCNL 'Check if the DB is empty. DCNL :returns: True if the database has no active objects, False otherwise'
def _commit_puts(self, item_list=None): DCNL 'Handles committing rows in .pending files.'
def reclaim(self, object_timestamp, sync_timestamp): DCNL 'Delete rows from the object table that are marked deleted and DCNL whose created_at timestamp is < object_timestamp.  Also deletes rows DCNL from incoming_sync and outgoing_sync where the updated_at timestamp is DCNL < sync_timestamp. DCNL In addition, this calls the DatabaseBroker\'s :func:_reclaim method. DCNL :param object_timestamp: max created_at timestamp of object rows to DCNL delete DCNL :param sync_timestamp: max update_at timestamp of sync rows to delete'
def delete_object(self, name, timestamp): DCNL 'Mark an object deleted. DCNL :param name: object name to be deleted DCNL :param timestamp: timestamp when the object was marked as deleted'
def put_object(self, name, timestamp, size, content_type, etag, deleted=0): DCNL 'Creates an object in the DB with its metadata. DCNL :param name: object name to be created DCNL :param timestamp: timestamp of when the object was created DCNL :param size: object size DCNL :param content_type: object content-type DCNL :param etag: object etag DCNL :param deleted: if True, marks the object as deleted and sets the DCNL deteleted_at timestamp to timestamp'
def is_deleted(self, timestamp=None): DCNL 'Check if the DB is considered to be deleted. DCNL :returns: True if the DB is considered to be deleted, False otherwise'
def get_info(self, include_metadata=False): DCNL 'Get global data for the container. DCNL :returns: dict with keys: account, container, created_at, DCNL put_timestamp, delete_timestamp, object_count, bytes_used, DCNL reported_put_timestamp, reported_delete_timestamp, DCNL reported_object_count, reported_bytes_used, hash, id, DCNL x_container_sync_point1, and x_container_sync_point2. DCNL If include_metadata is set, metadata is included as a key DCNL pointing to a dict of tuples of the metadata'
def reported(self, put_timestamp, delete_timestamp, object_count, bytes_used): DCNL 'Update reported stats. DCNL :param put_timestamp: put_timestamp to update DCNL :param delete_timestamp: delete_timestamp to update DCNL :param object_count: object_count to update DCNL :param bytes_used: bytes_used to update'
def list_objects_iter(self, limit, marker, end_marker, prefix, delimiter, path=None): DCNL 'Get a list of objects sorted by name starting at marker onward, up DCNL to limit entries.  Entries will begin with the prefix and will not DCNL have the delimiter after the prefix. DCNL :param limit: maximum number of entries to get DCNL :param marker: marker query DCNL :param end_marker: end marker query DCNL :param prefix: prefix query DCNL :param delimiter: delimiter for query DCNL :param path: if defined, will set the prefix and delimter based on DCNL the path DCNL :returns: list of tuples of (name, created_at, size, content_type, DCNL etag)'
def merge_items(self, item_list, source=None): DCNL 'Merge items into the object table. DCNL :param item_list: list of dictionaries of {\'name\', \'created_at\', DCNL \'size\', \'content_type\', \'etag\', \'deleted\'} DCNL :param source: if defined, update incoming_sync with the source'
def _initialize(self, conn, put_timestamp): DCNL 'Create a brand new database (tables, indices, triggers, etc.) DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'
def create_container_table(self, conn): DCNL 'Create container table which is specific to the account DB. DCNL :param conn: DB connection object'
def create_account_stat_table(self, conn, put_timestamp): DCNL 'Create account_stat table which is specific to the account DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'
def update_put_timestamp(self, timestamp): DCNL 'Update the put_timestamp.  Only modifies it if it is greater than DCNL the current timestamp. DCNL :param timestamp: put timestamp'
def _delete_db(self, conn, timestamp, force=False): DCNL 'Mark the DB as deleted. DCNL :param conn: DB connection object DCNL :param timestamp: timestamp to mark as deleted'
def _commit_puts(self, item_list=None): DCNL 'Handles committing rows in .pending files.'
def empty(self): DCNL 'Check if the account DB is empty. DCNL :returns: True if the database has no active containers.'
def reclaim(self, container_timestamp, sync_timestamp): DCNL 'Delete rows from the container table that are marked deleted and DCNL whose created_at timestamp is < container_timestamp.  Also deletes rows DCNL from incoming_sync and outgoing_sync where the updated_at timestamp is DCNL < sync_timestamp. DCNL In addition, this calls the DatabaseBroker\'s :func:_reclaim method. DCNL :param container_timestamp: max created_at timestamp of container rows DCNL to delete DCNL :param sync_timestamp: max update_at timestamp of sync rows to delete'
def put_container(self, name, put_timestamp, delete_timestamp, object_count, bytes_used): DCNL 'Create a container with the given attributes. DCNL :param name: name of the container to create DCNL :param put_timestamp: put_timestamp of the container to create DCNL :param delete_timestamp: delete_timestamp of the container to create DCNL :param object_count: number of objects in the container DCNL :param bytes_used: number of bytes used by the container'
def can_delete_db(self, cutoff): DCNL 'Check if the accont DB can be deleted. DCNL :returns: True if the account can be deleted, False otherwise'
def is_deleted(self): DCNL 'Check if the account DB is considered to be deleted. DCNL :returns: True if the account DB is considered to be deleted, False DCNL otherwise'
def is_status_deleted(self): DCNL 'Only returns true if the status field is set to DELETED.'
def get_info(self): DCNL 'Get global data for the account. DCNL :returns: dict with keys: account, created_at, put_timestamp, DCNL delete_timestamp, container_count, object_count, DCNL bytes_used, hash, id'
def list_containers_iter(self, limit, marker, end_marker, prefix, delimiter): DCNL 'Get a list of containerss sorted by name starting at marker onward, up DCNL to limit entries.  Entries will begin with the prefix and will not DCNL have the delimiter after the prefix. DCNL :param limit: maximum number of entries to get DCNL :param marker: marker query DCNL :param end_marker: end marker query DCNL :param prefix: prefix query DCNL :param delimiter: delimiter for query DCNL :returns: list of tuples of (name, object_count, bytes_used, 0)'
def merge_items(self, item_list, source=None): DCNL 'Merge items into the container table. DCNL :param item_list: list of dictionaries of {\'name\', \'put_timestamp\', DCNL \'delete_timestamp\', \'object_count\', \'bytes_used\', DCNL \'deleted\'} DCNL :param source: if defined, update incoming_sync with the source'
def run_once(self, *args, **kwargs): DCNL 'Override this to run the script once'
def run_forever(self, *args, **kwargs): DCNL 'Override this to run forever'
def run(self, once=False, **kwargs): DCNL 'Run the daemon'
def __call__(self, env, start_response): DCNL 'Accepts a standard WSGI application call, authenticating the request DCNL and installing callback hooks for authorization and ACL header DCNL validation. For an authenticated request, REMOTE_USER will be set to a DCNL comma separated list of the user\'s groups. DCNL With a non-empty reseller prefix, acts as the definitive auth service DCNL for just tokens and accounts that begin with that prefix, but will deny DCNL requests outside this prefix if no other auth middleware overrides it. DCNL With an empty reseller prefix, acts as the definitive auth service only DCNL for tokens that validate to a non-empty set of groups. For all other DCNL requests, acts as the fallback auth service when no other auth DCNL middleware overrides it. DCNL Alternatively, if the request matches the self.auth_prefix, the request DCNL will be routed through the internal auth request handler (self.handle). DCNL This is to handle granting tokens, etc.'
def get_groups(self, env, token): DCNL 'Get groups for the given token. DCNL :param env: The current WSGI environment dictionary. DCNL :param token: Token to validate and return a group string for. DCNL :returns: None if the token is invalid or a string containing a comma DCNL separated list of groups the authenticated user is a member DCNL of. The first group in the list is also considered a unique DCNL identifier for that user.'
def authorize(self, req): DCNL 'Returns None if the request is authorized to continue or a standard DCNL WSGI response callable if not.'
def denied_response(self, req): DCNL 'Returns a standard WSGI response callable with the status of 403 or 401 DCNL depending on whether the REMOTE_USER is set or not.'
def handle(self, env, start_response): DCNL 'WSGI entry point for auth requests (ones that match the DCNL self.auth_prefix). DCNL Wraps env in swob.Request object and passes it down. DCNL :param env: WSGI environment dictionary DCNL :param start_response: WSGI callable'
def handle_request(self, req): DCNL 'Entry point for auth requests (ones that match the self.auth_prefix). DCNL Should return a WSGI-style callable (such as swob.Response). DCNL :param req: swob.Request object'
def handle_get_token(self, req): DCNL 'Handles the various `request for token and service end point(s)` calls. DCNL There are various formats to support the various auth servers in the DCNL past. Examples:: DCNL GET <auth-prefix>/v1/<act>/auth DCNL X-Auth-User: <act>:<usr>  or  X-Storage-User: <usr> DCNL X-Auth-Key: <key>         or  X-Storage-Pass: <key> DCNL GET <auth-prefix>/auth DCNL X-Auth-User: <act>:<usr>  or  X-Storage-User: <act>:<usr> DCNL X-Auth-Key: <key>         or  X-Storage-Pass: <key> DCNL GET <auth-prefix>/v1.0 DCNL X-Auth-User: <act>:<usr>  or  X-Storage-User: <act>:<usr> DCNL X-Auth-Key: <key>         or  X-Storage-Pass: <key> DCNL On successful authentication, the response will have X-Auth-Token and DCNL X-Storage-Token set to the token to use with Swift and X-Storage-URL DCNL set to the URL to the default Swift cluster to use. DCNL :param req: The swob.Request to process. DCNL :returns: swob.Response, 2xx on success with data set as explained DCNL above.'
def _error_response(self, response, env, start_response): DCNL 'Sends the error response to the remote client, possibly resolving a DCNL custom error response body based on x-container-meta-web-error. DCNL :param response: The error response we should default to sending. DCNL :param env: The original request WSGI environment. DCNL :param start_response: The WSGI start_response hook.'
def _get_container_info(self, env): DCNL 'Retrieves x-container-meta-web-index, x-container-meta-web-error, DCNL x-container-meta-web-listings, and x-container-meta-web-listings-css DCNL from memcache or from the cluster and stores the result in memcache and DCNL in self._index, self._error, self._listings, and self._listings_css. DCNL :param env: The WSGI environment dict.'
def _listing(self, env, start_response, prefix=None): DCNL 'Sends an HTML object listing to the remote client. DCNL :param env: The original WSGI environment dict. DCNL :param start_response: The original WSGI start_response hook. DCNL :param prefix: Any prefix desired for the container listing.'
def _build_css_path(self, prefix=''): DCNL 'Constructs a relative path from a given prefix within the container. DCNL URLs and paths starting with \'/\' are not modified. DCNL :param prefix: The prefix for the container listing.'
def handle_container(self, env, start_response): DCNL 'Handles a possible static web request for a container. DCNL :param env: The original WSGI environment dict. DCNL :param start_response: The original WSGI start_response hook.'
def handle_object(self, env, start_response): DCNL 'Handles a possible static web request for an object. This object could DCNL resolve into an index or listing request. DCNL :param env: The original WSGI environment dict. DCNL :param start_response: The original WSGI start_response hook.'
def __call__(self, env, start_response): DCNL 'Main hook into the WSGI paste.deploy filter/app pipeline. DCNL :param env: The WSGI environment dict. DCNL :param start_response: The WSGI start_response hook.'
def check_character(self, req): DCNL 'Checks req.path for any forbidden characters DCNL Returns True if there are any forbidden characters DCNL Returns False if there aren\'t any forbidden characters'
def check_length(self, req): DCNL 'Checks that req.path doesn\'t exceed the defined maximum length DCNL Returns True if the length exceeds the maximum DCNL Returns False if the length is <= the maximum'
def check_regexp(self, req): DCNL 'Checks that req.path doesn\'t contain a substring matching regexps. DCNL Returns True if there are any forbidden substring DCNL Returns False if there aren\'t any forbidden substring'
def __call__(self, env, start_response): DCNL 'If used, this should be the first middleware in pipeline.'
def __call__(self, env, start_response): DCNL 'Main hook into the WSGI paste.deploy filter/app pipeline. DCNL :param env: The WSGI environment dict. DCNL :param start_response: The WSGI start_response hook. DCNL :returns: Response as per WSGI.'
def _get_account(self, env): DCNL 'Returns just the account for the request, if it\'s an object GET, PUT, DCNL or HEAD request; otherwise, None is returned. DCNL :param env: The WSGI environment for the request. DCNL :returns: Account str or None.'
def _get_temp_url_info(self, env): DCNL 'Returns the provided temporary URL parameters (sig, expires), DCNL if given and syntactically valid. Either sig or expires could DCNL be None if not provided. If provided, expires is also DCNL converted to an int if possible or 0 if not, and checked for DCNL expiration (returns 0 if expired). DCNL :param env: The WSGI environment for the request. DCNL :returns: (sig, expires) as described above.'
def _get_key(self, env, account): DCNL 'Returns the X-Account-Meta-Temp-URL-Key header value for the DCNL account, or None if none is set. DCNL :param env: The WSGI environment for the request. DCNL :param account: Account str. DCNL :returns: X-Account-Meta-Temp-URL-Key str value, or None.'
def _get_hmac(self, env, expires, key, request_method=None): DCNL 'Returns the hexdigest string of the HMAC-SHA1 (RFC 2104) for DCNL the request. DCNL :param env: The WSGI environment for the request. DCNL :param expires: Unix timestamp as an int for when the URL DCNL expires. DCNL :param key: Key str, from the X-Account-Meta-Temp-URL-Key of DCNL the account. DCNL :param request_method: Optional override of the request in DCNL the WSGI env. For example, if a HEAD DCNL does not match, you may wish to DCNL override with GET to still allow the DCNL HEAD. DCNL :returns: hexdigest str of the HMAC-SHA1 for the request.'
def _invalid(self, env, start_response): DCNL 'Performs the necessary steps to indicate a WSGI 401 DCNL Unauthorized response to the request. DCNL :param env: The WSGI environment for the request. DCNL :param start_response: The WSGI start_response hook. DCNL :returns: 401 response as per WSGI.'
def _clean_incoming_headers(self, env): DCNL 'Removes any headers from the WSGI environment as per the DCNL middleware configuration for incoming requests. DCNL :param env: The WSGI environment for the request.'
def _clean_outgoing_headers(self, headers): DCNL 'Removes any headers as per the middleware configuration for DCNL outgoing responses. DCNL :param headers: A WSGI start_response style list of headers, DCNL [(\'header1\', \'value), (\'header2\', \'value), DCNL :returns: The same headers list, but with some headers DCNL removed as per the middlware configuration for DCNL outgoing responses.'
def GET(self, req): DCNL 'Returns a 200 response with "OK" in the body.'
def DISABLED(self, req): DCNL 'Returns a 503 response with "DISABLED BY FILE" in the body.'
def log_request(self, req, status_int, bytes_received, bytes_sent, request_time): DCNL 'Log a request. DCNL :param req: swob.Request object for the request DCNL :param status_int: integer code for the response status DCNL :param bytes_received: bytes successfully read from the request body DCNL :param bytes_sent: bytes yielded to the WSGI server DCNL :param request_time: time taken to satisfy the request, in seconds'
def handle_multipart_put(self, req): DCNL 'Will handle the PUT of a SLO manifest. DCNL Heads every object in manifest to check if is valid and if so will DCNL save a manifest generated from the user input. DCNL :params req: a swob.Request with an obj in path DCNL :raises: HttpException on errors'
def handle_multipart_delete(self, req): DCNL 'Will delete all the segments in the SLO manifest and then, if DCNL successful, will delete the manifest file. DCNL :params req: a swob.Request with an obj in path DCNL :raises HTTPServerError: on invalid manifest DCNL :returns: swob.Response on failure, otherwise self.app'
@wsgify DCNL def __call__(self, req): DCNL 'WSGI entry point'
def _keystone_identity(self, environ): DCNL 'Extract the identity from the Keystone auth component.'
def _reseller_check(self, account, tenant_id): DCNL 'Check reseller prefix.'
def _authorize_cross_tenant(self, user, tenant_id, tenant_name, roles): DCNL 'Check cross-tenant ACLs DCNL Match tenant_id:user, tenant_name:user, and *:user. DCNL :param user: The user name from the identity token. DCNL :param tenant_id: The tenant ID from the identity token. DCNL :param tenant_name: The tenant name from the identity token. DCNL :param roles: The given container ACL. DCNL :returns: True if tenant_id:user, tenant_name:user, or *:user matches DCNL the given ACL. False otherwise.'
def authorize_anonymous(self, req): DCNL 'Authorize an anonymous request. DCNL :returns: None if authorization is granted, an error page otherwise.'
def _authorize_unconfirmed_identity(self, req, obj, referrers, roles): DCNL 'Perform authorization for access that does not require a DCNL confirmed identity. DCNL :returns: A boolean if authorization is granted or denied.  None if DCNL a determination could not be made.'
def denied_response(self, req): DCNL 'Deny WSGI Response. DCNL Returns a standard WSGI response callable with the status of 403 or 401 DCNL depending on whether the REMOTE_USER is set or not.'
def get_container_maxrate(self, container_size): DCNL 'Returns number of requests allowed per second for given container size.'
def get_ratelimitable_key_tuples(self, req_method, account_name, container_name=None, obj_name=None): DCNL 'Returns a list of key (used in memcache), ratelimit tuples. Keys DCNL should be checked in order. DCNL :param req_method: HTTP method DCNL :param account_name: account name from path DCNL :param container_name: container name from path DCNL :param obj_name: object name from path'
def _get_sleep_time(self, key, max_rate): DCNL 'Returns the amount of time (a float in seconds) that the app DCNL should sleep. DCNL :param key: a memcache key DCNL :param max_rate: maximum rate allowed in requests per second DCNL :raises: MaxSleepTimeHitError if max sleep time is exceeded.'
def handle_ratelimit(self, req, account_name, container_name, obj_name): DCNL 'Performs rate limiting and account white/black listing.  Sleeps DCNL if necessary. If self.memcache_client is not set, immediately returns DCNL None. DCNL :param account_name: account name from path DCNL :param container_name: container name from path DCNL :param obj_name: object name from path'
def __call__(self, env, start_response): DCNL 'WSGI entry point. DCNL Wraps env in swob.Request object and passes it down. DCNL :param env: WSGI environment dictionary DCNL :param start_response: WSGI callable'
def _from_recon_cache(self, cache_keys, cache_file, openr=open): DCNL 'retrieve values from a recon cache file DCNL :params cache_keys: list of cache items to retrieve DCNL :params cache_file: cache file to retrieve items from. DCNL :params openr: open to use [for unittests] DCNL :return: dict of cache items and their value or none if not found'
def get_mounted(self, openr=open): DCNL 'get ALL mounted fs from /proc/mounts'
def get_load(self, openr=open): DCNL 'get info from /proc/loadavg'
def get_mem(self, openr=open): DCNL 'get info from /proc/meminfo'
def get_async_info(self): DCNL 'get # of async pendings'
def get_replication_info(self, recon_type): DCNL 'get replication info'
def get_device_info(self): DCNL 'get devices'
def get_updater_info(self, recon_type): DCNL 'get updater info'
def get_expirer_info(self, recon_type): DCNL 'get expirer info'
def get_auditor_info(self, recon_type): DCNL 'get auditor info'
def get_unmounted(self): DCNL 'list unmounted (failed?) devices'
def get_diskusage(self): DCNL 'get disk utilization statistics'
def get_ring_md5(self, openr=open): DCNL 'get all ring md5sum\'s'
def get_quarantine_count(self): DCNL 'get obj/container/account quarantine counts'
def get_socket_info(self, openr=open): DCNL 'get info from /proc/net/sockstat and sockstat6 DCNL Note: The mem value is actually kernel pages, but we return bytes DCNL allocated based on the systems page size.'
def __call__(self, env, start_response): DCNL 'Main hook into the WSGI paste.deploy filter/app pipeline. DCNL :param env: The WSGI environment dict. DCNL :param start_response: The WSGI start_response hook. DCNL :returns: Response as per WSGI.'
def _translate_form(self, env, boundary): DCNL 'Translates the form data into subrequests and issues a DCNL response. DCNL :param env: The WSGI environment dict. DCNL :param boundary: The MIME type boundary to look for. DCNL :returns: status_line, headers_list, body'
def _perform_subrequest(self, orig_env, attributes, fp, key): DCNL 'Performs the subrequest and returns the response. DCNL :param orig_env: The WSGI environment dict; will only be used DCNL to form a new env for the subrequest. DCNL :param attributes: dict of the attributes of the form so far. DCNL :param fp: The file-like object containing the request body. DCNL :param key: The account key to validate the signature with. DCNL :returns: (status_line, message)'
def _get_key(self, env): DCNL 'Returns the X-Account-Meta-Temp-URL-Key header value for the DCNL account, or None if none is set. DCNL :param env: The WSGI environment for the request. DCNL :returns: X-Account-Meta-Temp-URL-Key str value, or None.'
def create_container(self, req, container_path): DCNL 'Makes a subrequest to create a new container. DCNL :params container_path: an unquoted path to a container to be created DCNL :returns: None on success DCNL :raises: CreateContainerError on creation error'
def get_objs_to_delete(self, req): DCNL 'Will populate objs_to_delete with data from request input. DCNL :params req: a Swob request DCNL :returns: a list of the contents of req.body when separated by newline. DCNL :raises: HTTPException on failures'
def handle_delete(self, req, objs_to_delete=None, user_agent='BulkDelete', swift_source='BD'): DCNL ':params req: a swob Request DCNL :raises HTTPException: on unhandled errors DCNL :returns: a swob Response'
def handle_extract(self, req, compress_type): DCNL ':params req: a swob Request DCNL :params compress_type: specifying the compression type of the tar. DCNL Accepts \'\', \'gz, or \'bz2\' DCNL :raises HTTPException: on unhandled errors DCNL :returns: a swob response to request'
def __call__(self, fd, mode, offset, length): DCNL 'The length parameter must be a ctypes.c_uint64'
def process(self, msg, kwargs): DCNL 'Add extra info to message'
def notice(self, msg, *args, **kwargs): DCNL 'Convenience function for syslog priority LOG_NOTICE. The python DCNL logging lvl is set to 25, just above info.  SysLogHandler is DCNL monkey patched to map this log lvl to the LOG_NOTICE syslog DCNL priority.'
def set_statsd_prefix(self, prefix): DCNL 'The StatsD client prefix defaults to the "name" of the logger.  This DCNL method may override that default with a specific value.  Currently used DCNL in the proxy-server to differentiate the Account, Container, and Object DCNL controllers.'
def statsd_delegate(statsd_func_name): DCNL 'Factory to create methods which delegate to methods on DCNL self.logger.statsd_client (an instance of StatsdClient).  The DCNL created methods conditionally delegate to a method whose name is given DCNL in \'statsd_func_name\'.  The created delegate methods are a no-op when DCNL StatsD logging is not configured. DCNL :param statsd_func_name: the name of a method on StatsdClient.'
def __init__(self, wsgi_input): DCNL ':param wsgi_input: file-like object to wrap the functionality of'
def read(self, *args, **kwargs): DCNL 'Pass read request to the underlying file-like object and DCNL add bytes read to total.'
def readline(self, *args, **kwargs): DCNL 'Pass readline request to the underlying file-like object and DCNL add bytes read to total.'
def weight_of_one_part(self): DCNL 'Returns the weight of each partition as calculated from the DCNL total weight of all the devices.'
def copy_from(self, builder): DCNL 'Reinitializes this RingBuilder instance from data obtained from the DCNL builder dict given. Code example:: DCNL b = RingBuilder(1, 1, 1)  # Dummy values DCNL b.copy_from(builder) DCNL This is to restore a RingBuilder that has had its b.to_dict() DCNL previously saved.'
def to_dict(self): DCNL 'Returns a dict that can be used later with copy_from to DCNL restore a RingBuilder. swift-ring-builder uses this to DCNL pickle.dump the dict to a file and later load that dict into DCNL copy_from.'
def change_min_part_hours(self, min_part_hours): DCNL 'Changes the value used to decide if a given partition can be moved DCNL again. This restriction is to give the overall system enough time to DCNL settle a partition to its new location before moving it to yet another DCNL location. While no data would be lost if a partition is moved several DCNL times quickly, it could make that data unreachable for a short period DCNL of time. DCNL This should be set to at least the average full partition replication DCNL time. Starting it at 24 hours and then lowering it to what the DCNL replicator reports as the longest partition cycle is best. DCNL :param min_part_hours: new value for min_part_hours'
def set_replicas(self, new_replica_count): DCNL 'Changes the number of replicas in this ring. DCNL If the new replica count is sufficiently different that DCNL self._replica2part2dev will change size, sets DCNL self.devs_changed. This is so tools like DCNL bin/swift-ring-builder can know to write out the new ring DCNL rather than bailing out due to lack of balance change.'
def get_ring(self): DCNL 'Get the ring, or more specifically, the swift.common.ring.RingData. DCNL This ring data is the minimum required for use of the ring. The ring DCNL builder itself keeps additional data such as when partitions were last DCNL moved.'
def add_dev(self, dev): DCNL 'Add a device to the ring. This device dict should have a minimum of the DCNL following keys: DCNL id      unique integer identifier amongst devices. Defaults to the next DCNL id if the \'id\' key is not provided in the dict DCNL weight  a float of the relative weight of this device as compared to DCNL others; this indicates how many partitions the builder will try DCNL to assign to this device DCNL region  integer indicating which region the device is in DCNL zone    integer indicating which zone the device is in; a given DCNL partition will not be assigned to multiple devices within the DCNL same (region, zone) pair if there is any alternative DCNL ip      the ip address of the device DCNL port    the tcp port of the device DCNL device  the device\'s name on disk (sdb1, for example) DCNL meta    general use \'extra\' field; for example: the online date, the DCNL hardware description DCNL .. note:: DCNL This will not rebalance the ring immediately as you may want to DCNL make multiple changes for a single rebalance. DCNL :param dev: device dict'
def set_dev_weight(self, dev_id, weight): DCNL 'Set the weight of a device. This should be called rather than just DCNL altering the weight key in the device dict directly, as the builder DCNL will need to rebuild some internal state to reflect the change. DCNL .. note:: DCNL This will not rebalance the ring immediately as you may want to DCNL make multiple changes for a single rebalance. DCNL :param dev_id: device id DCNL :param weight: new weight for device'
def remove_dev(self, dev_id): DCNL 'Remove a device from the ring. DCNL .. note:: DCNL This will not rebalance the ring immediately as you may want to DCNL make multiple changes for a single rebalance. DCNL :param dev_id: device id'
def rebalance(self, seed=None): DCNL 'Rebalance the ring. DCNL This is the main work function of the builder, as it will assign and DCNL reassign partitions to devices in the ring based on weights, distinct DCNL zones, recent reassignments, etc. DCNL The process doesn\'t always perfectly assign partitions (that\'d take a DCNL lot more analysis and therefore a lot more time -- I had code that did DCNL that before). Because of this, it keeps rebalancing until the device DCNL skew (number of partitions a device wants compared to what it has) gets DCNL below 1% or doesn\'t change by more than 1% (only happens with ring that DCNL can\'t be balanced no matter what -- like with 3 zones of differing DCNL weights with replicas set to 3). DCNL :returns: (number_of_partitions_altered, resulting_balance)'
def validate(self, stats=False): DCNL 'Validate the ring. DCNL This is a safety function to try to catch any bugs in the building DCNL process. It ensures partitions have been assigned to real devices, DCNL aren\'t doubly assigned, etc. It can also optionally check the even DCNL distribution of partitions across devices. DCNL :param stats: if True, check distribution of partitions across devices DCNL :returns: if stats is True, a tuple of (device_usage, worst_stat), else DCNL (None, None). device_usage[dev_id] will equal the number of DCNL partitions assigned to that device. worst_stat will equal the DCNL number of partitions the worst device is skewed from the DCNL number it should have. DCNL :raises RingValidationError: problem was found with the ring.'
def get_balance(self): DCNL 'Get the balance of the ring. The balance value is the highest DCNL percentage off the desired amount of partitions a given device DCNL wants. For instance, if the "worst" device wants (based on its DCNL weight relative to the sum of all the devices\' weights) 123 DCNL partitions and it has 124 partitions, the balance value would DCNL be 0.83 (1 extra / 123 wanted * 100 for percentage). DCNL :returns: balance of the ring'
def pretend_min_part_hours_passed(self): DCNL 'Override min_part_hours by marking all partitions as having been moved DCNL 255 hours ago. This can be used to force a full rebalance on the next DCNL call to rebalance.'
def get_part_devices(self, part): DCNL 'Get the devices that are responsible for the partition, DCNL filtering out duplicates. DCNL :param part: partition to get devices for DCNL :returns: list of device dicts'
def _iter_devs(self): DCNL 'Returns an iterator all the non-None devices in the ring. Note that DCNL this means list(b._iter_devs())[some_id] may not equal b.devs[some_id]; DCNL you will have to check the \'id\' key of each device to obtain its DCNL dev_id.'
def _set_parts_wanted(self): DCNL 'Sets the parts_wanted key for each of the devices to the number of DCNL partitions the device wants based on its relative weight. This key is DCNL used to sort the devices according to "most wanted" during rebalancing DCNL to best distribute partitions. A negative parts_wanted indicates the DCNL device is "overweight" and wishes to give partitions away if possible.'
def _adjust_replica2part2dev_size(self): DCNL 'Make sure that the lengths of the arrays in _replica2part2dev DCNL are correct for the current value of self.replicas. DCNL Example: DCNL self.part_power = 8 DCNL self.replicas = 2.25 DCNL self._replica2part2dev will contain 3 arrays: the first 2 of DCNL length 256 (2**8), and the last of length 64 (0.25 * 2**8). DCNL Returns a 2-tuple: the first element is a list of (partition, DCNL replicas) tuples indicating which replicas need to be DCNL (re)assigned to devices, and the second element is a count of DCNL how many replicas were removed.'
def _initial_balance(self): DCNL 'Initial partition assignment is the same as rebalancing an DCNL existing ring, but with some initial setup beforehand.'
def _update_last_part_moves(self): DCNL 'Updates how many hours ago each partition was moved based on the DCNL current time. The builder won\'t move a partition that has been moved DCNL more recently than min_part_hours.'
def _gather_reassign_parts(self): DCNL 'Returns a list of (partition, replicas) pairs to be reassigned by DCNL gathering from removed devices, insufficiently-far-apart replicas, and DCNL overweight drives.'
def _reassign_parts(self, reassign_parts): DCNL 'For an existing ring data set, partitions are reassigned similarly to DCNL the initial assignment. The devices are ordered by how many partitions DCNL they still want and kept in that order throughout the process. The DCNL gathered partitions are iterated through, assigning them to devices DCNL according to the "most wanted" while keeping the replicas as "far DCNL apart" as possible. Two different regions are considered the DCNL farthest-apart things, followed by zones, then different ip/port pairs DCNL within a zone; the least-far-apart things are different devices with DCNL the same ip/port pair in the same zone. DCNL If you want more replicas than devices, you won\'t get all your DCNL replicas. DCNL :param reassign_parts: An iterable of (part, replicas_to_replace) DCNL pairs. replicas_to_replace is an iterable of the DCNL replica (an int) to replace for that partition. DCNL replicas_to_replace may be shared for multiple DCNL partitions, so be sure you do not modify it.'
def _build_max_replicas_by_tier(self): DCNL 'Returns a dict of (tier: replica_count) for all tiers in the ring. DCNL There will always be a () entry as the root of the structure, whose DCNL replica_count will equal the ring\'s replica_count. DCNL Then there will be (dev_id,) entries for each device, indicating the DCNL maximum number of replicas the device might have for any given DCNL partition. Anything greater than 1 indicates a partition at serious DCNL risk, as the data on that partition will not be stored distinctly at DCNL the ring\'s replica_count. DCNL Next there will be (dev_id, ip_port) entries for each device, DCNL indicating the maximum number of replicas the device shares with other DCNL devices on the same ip_port for any given partition. Anything greater DCNL than 1 indicates a partition at elevated risk, as if that ip_port were DCNL to fail multiple replicas of that partition would be unreachable. DCNL Last there will be (dev_id, ip_port, zone) entries for each device, DCNL indicating the maximum number of replicas the device shares with other DCNL devices within the same zone for any given partition. Anything greater DCNL than 1 indicates a partition at slightly elevated risk, as if that zone DCNL were to fail multiple replicas of that partition would be unreachable. DCNL Example return dict for the common SAIO setup:: DCNL {(): 3, DCNL (1,): 1.0, DCNL (1, \'127.0.0.1:6010\'): 1.0, DCNL (1, \'127.0.0.1:6010\', 0): 1.0, DCNL (2,): 1.0, DCNL (2, \'127.0.0.1:6020\'): 1.0, DCNL (2, \'127.0.0.1:6020\', 1): 1.0, DCNL (3,): 1.0, DCNL (3, \'127.0.0.1:6030\'): 1.0, DCNL (3, \'127.0.0.1:6030\', 2): 1.0, DCNL (4,): 1.0, DCNL (4, \'127.0.0.1:6040\'): 1.0, DCNL (4, \'127.0.0.1:6040\', 3): 1.0}'
def _devs_for_part(self, part): DCNL 'Returns a list of devices for a specified partition. DCNL Deliberately includes duplicates.'
def _replicas_for_part(self, part): DCNL 'Returns a list of replicas for a specified partition. DCNL These can be used as indices into self._replica2part2dev DCNL without worrying about IndexErrors.'
def _each_part_replica(self): DCNL 'Generator yielding every (partition, replica) pair in the ring.'
@classmethod DCNL def load(cls, builder_file, open=open): DCNL 'Obtain RingBuilder instance of the provided builder file DCNL :param builder_file: path to builder file to load DCNL :return: RingBuilder instance'
def search_devs(self, search_value): DCNL 'The <search-value> can be of the form:: DCNL d<device_id>r<region>z<zone>-<ip>:<port>/<device_name>_<meta> DCNL Any part is optional, but you must include at least one part. DCNL Examples:: DCNL d74              Matches the device id 74 DCNL r4               Matches devices in region 4 DCNL z1               Matches devices in zone 1 DCNL z1-1.2.3.4       Matches devices in zone 1 with the ip 1.2.3.4 DCNL 1.2.3.4          Matches devices in any zone with the ip 1.2.3.4 DCNL z1:5678          Matches devices in zone 1 using port 5678 DCNL :5678            Matches devices that use port 5678 DCNL /sdb1            Matches devices with the device name sdb1 DCNL _shiny           Matches devices with shiny in the meta data DCNL _"snet: 5.6.7.8" Matches devices with snet: 5.6.7.8 in the meta data DCNL [::1]            Matches devices in any zone with the ip ::1 DCNL z1-[::1]:5678    Matches devices in zone 1 with ip ::1 and port 5678 DCNL Most specific example:: DCNL d74r4z1-1.2.3.4:5678/sdb1_"snet: 5.6.7.8" DCNL Nerd explanation: DCNL All items require their single character prefix except the ip, in which DCNL case the - is optional unless the device id or zone is also included.'
@classmethod DCNL def load(cls, filename): DCNL 'Load ring data from a file. DCNL :param filename: Path to a file serialized by the save() method. DCNL :returns: A RingData instance containing the loaded data.'
def save(self, filename): DCNL 'Serialize this RingData instance to disk. DCNL :param filename: File into which this instance should be serialized.'
@property DCNL def replica_count(self): DCNL 'Number of replicas (full or partial) used in the ring.'
@property DCNL def partition_count(self): DCNL 'Number of partitions in the ring.'
@property DCNL def devs(self): DCNL 'devices in the ring'
def has_changed(self): DCNL 'Check to see if the ring on disk is different than the current one in DCNL memory. DCNL :returns: True if the ring on disk has changed, False otherwise'
def get_part_nodes(self, part): DCNL 'Get the nodes that are responsible for the partition. If one DCNL node is responsible for more than one replica of the same DCNL partition, it will only appear in the output once. DCNL :param part: partition to get nodes for DCNL :returns: list of node dicts DCNL See :func:`get_nodes` for a description of the node dicts.'
def get_nodes(self, account, container=None, obj=None): DCNL 'Get the partition and nodes for an account/container/object. DCNL If a node is responsible for more than one replica, it will DCNL only appear in the output once. DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :returns: a tuple of (partition, list of node dicts) DCNL Each node dict will have at least the following keys: DCNL id      unique integer identifier amongst devices DCNL weight  a float of the relative weight of this device as compared to DCNL others; this indicates how many partitions the builder will try DCNL to assign to this device DCNL zone    integer indicating which zone the device is in; a given DCNL partition will not be assigned to multiple devices within the DCNL same zone DCNL ip      the ip address of the device DCNL port    the tcp port of the device DCNL device  the device\'s name on disk (sdb1, for example) DCNL meta    general use \'extra\' field; for example: the online date, the DCNL hardware description'
def get_more_nodes(self, part): DCNL 'Generator to get extra nodes for a partition for hinted handoff. DCNL The handoff nodes will try to be in zones other than the DCNL primary zones, will take into account the device weights, and DCNL will usually keep the same sequences of handoffs even with DCNL ring changes. DCNL :param part: partition to get handoff nodes for DCNL :returns: generator of node dicts DCNL See :func:`get_nodes` for a description of the node dicts.'
def __init__(self, node, partition, hash_, logger): DCNL ''
def replicate(self, *args): DCNL 'Make an HTTP REPLICATE request DCNL :param args: list of json-encodable objects DCNL :returns: httplib response object'
def _zero_stats(self): DCNL 'Zero out the stats.'
def _report_stats(self): DCNL 'Report the current stats to the logs.'
def _rsync_file(self, db_file, remote_file, whole_file=True): DCNL 'Sync a single file using rsync. Used by _rsync_db to handle syncing. DCNL :param db_file: file to be synced DCNL :param remote_file: remote location to sync the DB file to DCNL :param whole-file: if True, uses rsync\'s --whole-file flag DCNL :returns: True if the sync was successful, False otherwise'
def _rsync_db(self, broker, device, http, local_id, replicate_method='complete_rsync', replicate_timeout=None): DCNL 'Sync a whole db using rsync. DCNL :param broker: DB broker object of DB to be synced DCNL :param device: device to sync to DCNL :param http: ReplConnection object DCNL :param local_id: unique ID of the local database replica DCNL :param replicate_method: remote operation to perform after rsync DCNL :param replicate_timeout: timeout to wait in seconds'
def _usync_db(self, point, broker, http, remote_id, local_id): DCNL 'Sync a db by sending all records since the last sync. DCNL :param point: synchronization high water mark between the replicas DCNL :param broker: database broker object DCNL :param http: ReplConnection object for the remote server DCNL :param remote_id: database id for the remote replica DCNL :param local_id: database id for the local replica DCNL :returns: boolean indicating completion and success'
def _in_sync(self, rinfo, info, broker, local_sync): DCNL 'Determine whether or not two replicas of a databases are considered DCNL to be in sync. DCNL :param rinfo: remote database info DCNL :param info: local database info DCNL :param broker: database broker object DCNL :param local_sync: cached last sync point between replicas DCNL :returns: boolean indicating whether or not the replicas are in sync'
def _http_connect(self, node, partition, db_file): DCNL 'Make an http_connection using ReplConnection DCNL :param node: node dictionary from the ring DCNL :param partition: partition partition to send in the url DCNL :param db_file: DB file DCNL :returns: ReplConnection object'
def _repl_to_node(self, node, broker, partition, info): DCNL 'Replicate a database to a node. DCNL :param node: node dictionary from the ring to be replicated to DCNL :param broker: DB broker for the DB to be replication DCNL :param partition: partition on the node to replicate to DCNL :param info: DB info as a dictionary of {\'max_row\', \'hash\', \'id\', DCNL \'created_at\', \'put_timestamp\', \'delete_timestamp\', DCNL \'metadata\'} DCNL :returns: True if successful, False otherwise'
def _replicate_object(self, partition, object_file, node_id): DCNL 'Replicate the db, choosing method based on whether or not it DCNL already exists on peers. DCNL :param partition: partition to be replicated to DCNL :param object_file: DB file name to be replicated DCNL :param node_id: node id of the node to be replicated to'
def extract_device(self, object_file): DCNL 'Extract the device name from an object path.  Returns "UNKNOWN" if the DCNL path could not be extracted successfully for some reason. DCNL :param object_file: the path to a database file.'
def run_once(self, *args, **kwargs): DCNL 'Run a replication pass once.'
def run_forever(self, *args, **kwargs): DCNL 'Replicate dbs under the given root in an infinite loop.'
@command DCNL def status(self, **kwargs): DCNL 'display status of tracked pids for server'
@command DCNL def start(self, **kwargs): DCNL 'starts a server'
@command DCNL def no_wait(self, **kwargs): DCNL 'spawn server and return immediately'
@command DCNL def no_daemon(self, **kwargs): DCNL 'start a server interactively'
@command DCNL def once(self, **kwargs): DCNL 'start server and run one pass on supporting daemons'
@command DCNL def stop(self, **kwargs): DCNL 'stops a server'
@command DCNL def shutdown(self, **kwargs): DCNL 'allow current requests to finish on supporting servers'
@command DCNL def restart(self, **kwargs): DCNL 'stops then restarts server'
@command DCNL def reload(self, **kwargs): DCNL 'graceful shutdown then restart on supporting servers'
@command DCNL def force_reload(self, **kwargs): DCNL 'alias for reload'
def get_command(self, cmd): DCNL 'Find and return the decorated method named like cmd DCNL :param cmd: the command to get, a string, if not found raises DCNL UnknownCommandError'
@classmethod DCNL def list_commands(cls): DCNL 'Get all publicly accessible commands DCNL :returns: a list of string tuples (cmd, help), the method names who are DCNL decorated as commands'
def run_command(self, cmd, **kwargs): DCNL 'Find the named command and run it DCNL :param cmd: the command name to run'
def get_pid_file_name(self, conf_file): DCNL 'Translate conf_file to a corresponding pid_file DCNL :param conf_file: an conf_file for this server, a string DCNL :returns: the pid_file for this conf_file'
def get_conf_file_name(self, pid_file): DCNL 'Translate pid_file to a corresponding conf_file DCNL :param pid_file: a pid_file for this server, a string DCNL :returns: the conf_file for this pid_file'
def conf_files(self, **kwargs): DCNL 'Get conf files for this server DCNL :param: number, if supplied will only lookup the nth server DCNL :returns: list of conf files'
def pid_files(self, **kwargs): DCNL 'Get pid files for this server DCNL :param: number, if supplied will only lookup the nth server DCNL :returns: list of pid files'
def iter_pid_files(self, **kwargs): DCNL 'Generator, yields (pid_file, pids)'
def signal_pids(self, sig, **kwargs): DCNL 'Send a signal to pids for this server DCNL :param sig: signal to send DCNL :returns: a dict mapping pids (ints) to pid_files (paths)'
def get_running_pids(self, **kwargs): DCNL 'Get running pids DCNL :returns: a dict mapping pids (ints) to pid_files (paths)'
def kill_running_pids(self, **kwargs): DCNL 'Kill running pids DCNL :param graceful: if True, attempt SIGHUP on supporting servers DCNL :returns: a dict mapping pids (ints) to pid_files (paths)'
def status(self, pids=None, **kwargs): DCNL 'Display status of server DCNL :param: pids, if not supplied pids will be populated automatically DCNL :param: number, if supplied will only lookup the nth server DCNL :returns: 1 if server is not running, 0 otherwise'
def spawn(self, conf_file, once=False, wait=True, daemon=True, **kwargs): DCNL 'Launch a subprocess for this server. DCNL :param conf_file: path to conf_file to use as first arg DCNL :param once: boolean, add once argument to command DCNL :param wait: boolean, if true capture stdout with a pipe DCNL :param daemon: boolean, if true ask server to log to console DCNL :returns : the pid of the spawned process'
def wait(self, **kwargs): DCNL 'wait on spawned procs to start'
def interact(self, **kwargs): DCNL 'wait on spawned procs to terminate'
def launch(self, **kwargs): DCNL 'Collect conf files and attempt to spawn the processes for this server'
def stop(self, **kwargs): DCNL 'Send stop signals to pids for this server DCNL :returns: a dict mapping pids (ints) to pid_files (paths)'
def _get_conns(self, key): DCNL 'Retrieves a server conn from the pool, or connects a new one. DCNL Chooses the server based on a consistent hash of "key".'
def _return_conn(self, server, fp, sock): DCNL 'Returns a server connection to the pool'
def set(self, key, value, serialize=True, timeout=0, time=0, min_compress_len=0): DCNL 'Set a key/value pair in memcache DCNL :param key: key DCNL :param value: value DCNL :param serialize: if True, value is serialized with JSON before sending DCNL to memcache, or with pickle if configured to use DCNL pickle instead of JSON (to avoid cache poisoning) DCNL :param timeout: ttl in memcache, this parameter is now deprecated. It DCNL will be removed in next release of OpenStack, DCNL use time parameter instead in the future DCNL :time: equivalent to timeout, this parameter is added to keep the DCNL signature compatible with python-memcached interface. This DCNL implementation will take this value and sign it to the DCNL parameter timeout DCNL :min_compress_len: minimum compress length, this parameter was added DCNL to keep the signature compatible with DCNL python-memcached interface. This implementation DCNL ignores it.'
def get(self, key): DCNL 'Gets the object specified by key.  It will also unserialize the object DCNL before returning if it is serialized in memcache with JSON, or if it DCNL is pickled and unpickling is allowed. DCNL :param key: key DCNL :returns: value of the key in memcache'
def incr(self, key, delta=1, time=0, timeout=0): DCNL 'Increments a key which has a numeric value by delta. DCNL If the key can\'t be found, it\'s added as delta or 0 if delta < 0. DCNL If passed a negative number, will use memcached\'s decr. Returns DCNL the int stored in memcached DCNL Note: The data memcached stores as the result of incr/decr is DCNL an unsigned int.  decr\'s that result in a number below 0 are DCNL stored as 0. DCNL :param key: key DCNL :param delta: amount to add to the value of key (or set as the value DCNL if the key is not found) will be cast to an int DCNL :param time: the time to live. This parameter deprecates parameter DCNL timeout. The addition of this parameter is to make the DCNL interface consistent with set and set_multi methods DCNL :param timeout: ttl in memcache, deprecated, will be removed in future DCNL OpenStack releases DCNL :raises MemcacheConnectionError:'
def decr(self, key, delta=1, time=0, timeout=0): DCNL 'Decrements a key which has a numeric value by delta. Calls incr with DCNL -delta. DCNL :param key: key DCNL :param delta: amount to subtract to the value of key (or set the DCNL value to 0 if the key is not found) will be cast to DCNL an int DCNL :param time: the time to live. This parameter depcates parameter DCNL timeout. The addition of this parameter is to make the DCNL interface consistent with set and set_multi methods DCNL :param timeout: ttl in memcache, deprecated, will be removed in future DCNL OpenStack releases DCNL :raises MemcacheConnectionError:'
def delete(self, key): DCNL 'Deletes a key/value pair from memcache. DCNL :param key: key to be deleted'
def set_multi(self, mapping, server_key, serialize=True, timeout=0, time=0, min_compress_len=0): DCNL 'Sets multiple key/value pairs in memcache. DCNL :param mapping: dictonary of keys and values to be set in memcache DCNL :param servery_key: key to use in determining which server in the ring DCNL is used DCNL :param serialize: if True, value is serialized with JSON before sending DCNL to memcache, or with pickle if configured to use DCNL pickle instead of JSON (to avoid cache poisoning) DCNL :param timeout: ttl for memcache. This parameter is now deprecated, it DCNL will be removed in next release of OpenStack, use time DCNL parameter instead in the future DCNL :time: equalvent to timeout, this parameter is added to keep the DCNL signature compatible with python-memcached interface. This DCNL implementation will take this value and sign it to parameter DCNL timeout DCNL :min_compress_len: minimum compress length, this parameter was added DCNL to keep the signature compatible with DCNL python-memcached interface. This implementation DCNL ignores it'
def get_multi(self, keys, server_key): DCNL 'Gets multiple values from memcache for the given keys. DCNL :param keys: keys for values to be retrieved from memcache DCNL :param servery_key: key to use in determining which server in the ring DCNL is used DCNL :returns: list of values'
def _start_response(self, status, headers, exc_info=None): DCNL 'Saves response info without sending it to the remote client. DCNL Uses the same semantics as the usual WSGI start_response.'
def _app_call(self, env): DCNL 'Ensures start_response has been called before returning.'
def _get_status_int(self): DCNL 'Returns the HTTP status int from the last called self._start_response DCNL result.'
def _response_header_value(self, key): DCNL 'Returns str of value for given header key or None'
def read(self, *a, **kw): DCNL 'Reads a chunk from the file object. DCNL Params are passed directly to the underlying file object\'s read(). DCNL :returns: Compressed chunk from file object.'
def make_request(self, method, path, headers, acceptable_statuses, body_file=None): DCNL 'Makes a request to Swift with retries. DCNL :param method: HTTP method of request. DCNL :param path: Path of request. DCNL :param headers: Headers to be sent with request. DCNL :param acceptable_statuses: List of acceptable statuses for request. DCNL :param body_file: Body file to be passed along with request, DCNL defaults to None. DCNL :returns : Response object on success. DCNL :raises UnexpectedResponse: Exception raised when make_request() fails DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def _get_metadata(self, path, metadata_prefix='', acceptable_statuses=(2,)): DCNL 'Gets metadata by doing a HEAD on a path and using the metadata_prefix DCNL to get values from the headers returned. DCNL :param path: Path to do HEAD on. DCNL :param metadata_prefix: Used to filter values from the headers DCNL returned.  Will strip that prefix from the DCNL keys in the dict returned.  Defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :returns : A dict of metadata with metadata_prefix stripped from keys. DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def _iter_items(self, path, marker='', end_marker='', acceptable_statuses=(2, HTTP_NOT_FOUND)): DCNL 'Returns an iterator of items from a json listing.  Assumes listing has DCNL \'name\' key defined and uses markers. DCNL :param path: Path to do GET on. DCNL :param marker: Prefix of first desired item, defaults to \'\'. DCNL :param end_marker: Last item returned will be \'less\' than this, DCNL defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2, HTTP_NOT_FOUND). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def make_path(self, account, container=None, obj=None): DCNL 'Returns a swift path for a request quoting and utf-8 encoding the path DCNL parts as need be. DCNL :param account: swift account DCNL :param container: container, defaults to None DCNL :param obj: object, defaults to None DCNL :raises ValueError: Is raised if obj is specified and container is DCNL not.'
def _set_metadata(self, path, metadata, metadata_prefix='', acceptable_statuses=(2,)): DCNL 'Sets metadata on path using metadata_prefix to set values in headers of DCNL POST request. DCNL :param path: Path to do POST on. DCNL :param metadata: Dict of metadata to set. DCNL :param metadata_prefix: Prefix used to set metadata values in headers DCNL of requests, used to prefix keys in metadata DCNL when setting metadata, defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def iter_containers(self, account, marker='', end_marker='', acceptable_statuses=(2, HTTP_NOT_FOUND)): DCNL 'Returns an iterator of containers dicts from an account. DCNL :param account: Account on which to do the container listing. DCNL :param marker: Prefix of first desired item, defaults to \'\'. DCNL :param end_marker: Last item returned will be \'less\' than this, DCNL defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2, HTTP_NOT_FOUND). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def get_account_info(self, account, acceptable_statuses=(2, HTTP_NOT_FOUND)): DCNL 'Returns (container_count, object_count) for an account. DCNL :param account: Account on which to get the information. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2, HTTP_NOT_FOUND). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def get_account_metadata(self, account, metadata_prefix='', acceptable_statuses=(2,)): DCNL 'Gets account metadata. DCNL :param account: Account on which to get the metadata. DCNL :param metadata_prefix: Used to filter values from the headers DCNL returned.  Will strip that prefix from the DCNL keys in the dict returned.  Defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :returns : Returns dict of account metadata. DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def set_account_metadata(self, account, metadata, metadata_prefix='', acceptable_statuses=(2,)): DCNL 'Sets account metadata.  A call to this will add to the account DCNL metadata and not overwrite all of it with values in the metadata dict. DCNL To clear an account metadata value, pass an empty string as DCNL the value for the key in the metadata dict. DCNL :param account: Account on which to get the metadata. DCNL :param metadata: Dict of metadata to set. DCNL :param metadata_prefix: Prefix used to set metadata values in headers DCNL of requests, used to prefix keys in metadata DCNL when setting metadata, defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def container_exists(self, account, container): DCNL 'Checks to see if a container exists. DCNL :param account: The container\'s account. DCNL :param container: Container to check. DCNL :returns : True if container exists, false otherwise. DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def create_container(self, account, container, headers=None, acceptable_statuses=(2,)): DCNL 'Creates container. DCNL :param account: The container\'s account. DCNL :param container: Container to create. DCNL :param headers: Defaults to empty dict. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def delete_container(self, account, container, acceptable_statuses=(2, HTTP_NOT_FOUND)): DCNL 'Deletes a container. DCNL :param account: The container\'s account. DCNL :param container: Container to delete. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2, HTTP_NOT_FOUND). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def get_container_metadata(self, account, container, metadata_prefix='', acceptable_statuses=(2,)): DCNL 'Gets container metadata. DCNL :param account: The container\'s account. DCNL :param container: Container to get metadata on. DCNL :param metadata_prefix: Used to filter values from the headers DCNL returned.  Will strip that prefix from the DCNL keys in the dict returned.  Defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :returns : Returns dict of container metadata. DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def iter_objects(self, account, container, marker='', end_marker='', acceptable_statuses=(2, HTTP_NOT_FOUND)): DCNL 'Returns an iterator of object dicts from a container. DCNL :param account: The container\'s account. DCNL :param container: Container to iterate objects on. DCNL :param marker: Prefix of first desired item, defaults to \'\'. DCNL :param end_marker: Last item returned will be \'less\' than this, DCNL defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2, HTTP_NOT_FOUND). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def set_container_metadata(self, account, container, metadata, metadata_prefix='', acceptable_statuses=(2,)): DCNL 'Sets container metadata.  A call to this will add to the container DCNL metadata and not overwrite all of it with values in the metadata dict. DCNL To clear a container metadata value, pass an empty string as the value DCNL for the key in the metadata dict. DCNL :param account: The container\'s account. DCNL :param container: Container to set metadata on. DCNL :param metadata: Dict of metadata to set. DCNL :param metadata_prefix: Prefix used to set metadata values in headers DCNL of requests, used to prefix keys in metadata DCNL when setting metadata, defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def delete_object(self, account, container, obj, acceptable_statuses=(2, HTTP_NOT_FOUND)): DCNL 'Deletes an object. DCNL :param account: The object\'s account. DCNL :param container: The object\'s container. DCNL :param obj: The object. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2, HTTP_NOT_FOUND). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def get_object_metadata(self, account, container, obj, metadata_prefix='', acceptable_statuses=(2,)): DCNL 'Gets object metadata. DCNL :param account: The object\'s account. DCNL :param container: The object\'s container. DCNL :param obj: The object. DCNL :param metadata_prefix: Used to filter values from the headers DCNL returned.  Will strip that prefix from the DCNL keys in the dict returned.  Defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :returns : Dict of object metadata. DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def iter_object_lines(self, account, container, obj, headers=None, acceptable_statuses=(2,)): DCNL 'Returns an iterator of object lines from an uncompressed or compressed DCNL text object. DCNL Uncompress object as it is read if the object\'s name ends with \'.gz\'. DCNL :param account: The object\'s account. DCNL :param container: The object\'s container. DCNL :param objec_namet: The object. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def set_object_metadata(self, account, container, obj, metadata, metadata_prefix='', acceptable_statuses=(2,)): DCNL 'Sets an object\'s metadata.  The object\'s metadata will be overwritten DCNL by the values in the metadata dict. DCNL :param account: The object\'s account. DCNL :param container: The object\'s container. DCNL :param obj: The object. DCNL :param metadata: Dict of metadata to set. DCNL :param metadata_prefix: Prefix used to set metadata values in headers DCNL of requests, used to prefix keys in metadata DCNL when setting metadata, defaults to \'\'. DCNL :param acceptable_statuses: List of status for valid responses, DCNL defaults to (2,). DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def upload_object(self, fobj, account, container, obj, headers=None): DCNL ':param fobj: File object to read object\'s content from. DCNL :param account: The object\'s account. DCNL :param container: The object\'s container. DCNL :param obj: The object. DCNL :param headers: Headers to send with request, defaults ot empty dict. DCNL :raises UnexpectedResponse: Exception raised when requests fail DCNL to get a response with an acceptable status DCNL :raises Exception: Exception is raised when code fails in an DCNL unexpected way.'
def ranges_for_length(self, length): DCNL 'This method is used to return multiple ranges for a given length DCNL which should represent the length of the underlying content. DCNL The constructor method __init__ made sure that any range in ranges DCNL list is syntactically valid. So if length is None or size of the DCNL ranges is zero, then the Range header should be ignored which will DCNL eventually make the response to be 200. DCNL If an empty list is returned by this method, it indicates that there DCNL are unsatisfiable ranges found in the Range header, 416 will be DCNL returned. DCNL if a returned list has at least one element, the list indicates that DCNL there is at least one range valid and the server should serve the DCNL request with a 206 status code. DCNL The start value of each range represents the starting position in DCNL the content, the end value represents the ending position. This DCNL method purposely adds 1 to the end number because the spec defines DCNL the Range to be inclusive. DCNL The Range spec can be found at the following link: DCNL http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1 DCNL :param length: length of the underlying content'
def best_match(self, options): DCNL 'Returns the item from "options" that best matches the accept header. DCNL Returns None if no available options are acceptable to the client. DCNL :param options: a list of content-types the server can respond with'
@classmethod DCNL def blank(cls, path, environ=None, headers=None, body=None): DCNL 'Create a new request object with the given parameters, and an DCNL environment otherwise filled in with non-surprising default values.'
@property DCNL def params(self): DCNL 'Provides QUERY_STRING parameters as a dictionary'
@property DCNL def path_qs(self): DCNL 'The path of the request, without host but with query string.'
@property DCNL def path(self): DCNL 'Provides the full path of the request, excluding the QUERY_STRING'
@property DCNL def url(self): DCNL 'Provides the full url of the request'
def path_info_pop(self): DCNL 'Takes one path portion (delineated by slashes) from the DCNL path_info, and appends it to the script_name.  Returns DCNL the path segment.'
def copy_get(self): DCNL 'Makes a copy of the request, converting it to a GET.'
def call_application(self, application): DCNL 'Calls the application with this request\'s environment.  Returns the DCNL status, headers, and app_iter for the response as a tuple. DCNL :param application: the WSGI application to call'
def get_response(self, application): DCNL 'Calls the application with this request\'s environment.  Returns a DCNL Response object that wraps up the application\'s result. DCNL :param application: the WSGI application to call'
def split_path(self, minsegs=1, maxsegs=None, rest_with_last=False): DCNL 'Validate and split the Request\'s path. DCNL **Examples**:: DCNL [\'a\'] = split_path(\'/a\') DCNL [\'a\', None] = split_path(\'/a\', 1, 2) DCNL [\'a\', \'c\'] = split_path(\'/a/c\', 1, 2) DCNL [\'a\', \'c\', \'o/r\'] = split_path(\'/a/c/o/r\', 1, 3, True) DCNL :param path: HTTP Request path to be split DCNL :param minsegs: Minimum number of segments to be extracted DCNL :param maxsegs: Maximum number of segments to be extracted DCNL :param rest_with_last: If True, trailing data will be returned as part DCNL of last segment.  If False, and there is DCNL trailing data, raises ValueError. DCNL :returns: list of segments with a length of maxsegs (non-existant DCNL segments will return as None) DCNL :raises: ValueError if given an invalid path'
def _prepare_for_ranges(self, ranges): DCNL 'Prepare the Response for multiple ranges.'
def absolute_location(self): DCNL 'Attempt to construct an absolute location.'
def get_container_ring(self): DCNL 'Get the container ring.  Load it, if it hasn\'t been yet.'
def run_forever(self, *args, **kwargs): DCNL 'Run the updater continuously.'
def run_once(self, *args, **kwargs): DCNL 'Run the updater once'
def object_sweep(self, device): DCNL 'If there are async pendings on the device, walk each one and update. DCNL :param device: path to device'
def process_object_update(self, update_path, device): DCNL 'Process the object information to be updated and update. DCNL :param update_path: path to pickled object update file DCNL :param device: path to device'
def object_update(self, node, part, op, obj, headers): DCNL 'Perform the object update to the container DCNL :param node: node dictionary from the container ring DCNL :param part: partition that holds the container DCNL :param op: operation performed (ex: \'POST\' or \'DELETE\') DCNL :param obj: object name being updated DCNL :param headers: headers to send with the update'
def __iter__(self): DCNL 'Returns an iterator over the data file.'
def app_iter_range(self, start, stop): DCNL 'Returns an iterator over the data file for range (start, stop)'
def app_iter_ranges(self, ranges, content_type, boundary, size): DCNL 'Returns an iterator over the data file for a set of ranges'
def _handle_close_quarantine(self): DCNL 'Check if file needs to be quarantined'
def close(self, verify_file=True): DCNL 'Close the file. Will handle quarantining file if necessary. DCNL :param verify_file: Defaults to True. If false, will not check DCNL file to see if it needs quarantining.'
def is_deleted(self): DCNL 'Check if the file is deleted. DCNL :returns: True if the file doesn\'t exist or has been flagged as DCNL deleted.'
def is_expired(self): DCNL 'Check if the file is expired. DCNL :returns: True if the file has an X-Delete-At in the past'
@contextmanager DCNL def mkstemp(self): DCNL 'Contextmanager to make a temporary file.'
def put(self, fd, metadata, extension='.data'): DCNL 'Finalize writing the file on disk, and renames it from the temp file to DCNL the real location.  This should be called after the data has been DCNL written to the temp file. DCNL :param fd: file descriptor of the temp file DCNL :param metadata: dictionary of metadata to be written DCNL :param extension: extension to be used when making the file'
def put_metadata(self, metadata, tombstone=False): DCNL 'Short hand for putting metadata to .meta and .ts files. DCNL :param metadata: dictionary of metadata to be written DCNL :param tombstone: whether or not we are writing a tombstone'
def unlinkold(self, timestamp): DCNL 'Remove any older versions of the object file.  Any file that has an DCNL older timestamp than timestamp will be deleted. DCNL :param timestamp: timestamp to compare with each file'
def drop_cache(self, fd, offset, length): DCNL 'Method for no-oping buffer cache drop method.'
def quarantine(self): DCNL 'In the case that a file is corrupted, move it to a quarantined DCNL area to allow replication to fix it. DCNL :returns: if quarantine is successful, path to quarantined DCNL directory otherwise None'
def get_data_file_size(self): DCNL 'Returns the os.path.getsize for the file.  Raises an exception if this DCNL file does not match the Content-Length stored in the metadata. Or if DCNL self.data_file does not exist. DCNL :returns: file size as an int DCNL :raises DiskFileError: on file size mismatch. DCNL :raises DiskFileNotExist: on file not existing (including deleted)'
def __init__(self, conf): DCNL 'Creates a new WSGI application for the Swift Object Server. An DCNL example configuration is given at DCNL <source-dir>/etc/object-server.conf-sample or DCNL /etc/swift/object-server.conf-sample.'
def async_update(self, op, account, container, obj, host, partition, contdevice, headers_out, objdevice): DCNL 'Sends or saves an async update. DCNL :param op: operation performed (ex: \'PUT\', or \'DELETE\') DCNL :param account: account name for the object DCNL :param container: container name for the object DCNL :param obj: object name DCNL :param host: host that the container is on DCNL :param partition: partition that the container is on DCNL :param contdevice: device name that the container is on DCNL :param headers_out: dictionary of headers to send in the container DCNL request DCNL :param objdevice: device name that the object is in'
def container_update(self, op, account, container, obj, headers_in, headers_out, objdevice): DCNL 'Update the container when objects are updated. DCNL :param op: operation performed (ex: \'PUT\', or \'DELETE\') DCNL :param account: account name for the object DCNL :param container: container name for the object DCNL :param obj: object name DCNL :param headers_in: dictionary of headers from the original request DCNL :param headers_out: dictionary of headers to send in the container DCNL request(s) DCNL :param objdevice: device name that the object is in'
def delete_at_update(self, op, delete_at, account, container, obj, headers_in, objdevice): DCNL 'Update the expiring objects container when objects are updated. DCNL :param op: operation performed (ex: \'PUT\', or \'DELETE\') DCNL :param account: account name for the object DCNL :param container: container name for the object DCNL :param obj: object name DCNL :param headers_in: dictionary of headers from the original request DCNL :param objdevice: device name that the object is in'
@public DCNL @timing_stats() DCNL def POST(self, request): DCNL 'Handle HTTP POST requests for the Swift Object Server.'
@public DCNL @timing_stats() DCNL def PUT(self, request): DCNL 'Handle HTTP PUT requests for the Swift Object Server.'
@public DCNL @timing_stats() DCNL def GET(self, request): DCNL 'Handle HTTP GET requests for the Swift Object Server.'
@public DCNL @timing_stats(sample_rate=0.8) DCNL def HEAD(self, request): DCNL 'Handle HTTP HEAD requests for the Swift Object Server.'
@public DCNL @timing_stats() DCNL def DELETE(self, request): DCNL 'Handle HTTP DELETE requests for the Swift Object Server.'
@public DCNL @timing_stats(sample_rate=0.1) DCNL def REPLICATE(self, request): DCNL 'Handle REPLICATE requests for the Swift Object Server.  This is used DCNL by the object replicator to get hashes for directories.'
def __call__(self, env, start_response): DCNL 'WSGI Application entry point for the Swift Object Server.'
def __init__(self, conf): DCNL ':param conf: configuration object obtained from ConfigParser DCNL :param logger: logging object'
def _rsync(self, args): DCNL 'Execute the rsync binary to replicate a partition. DCNL :returns: return code of rsync process. 0 is successful'
def rsync(self, node, job, suffixes): DCNL 'Synchronize local suffix directories from a partition with a remote DCNL node. DCNL :param node: the "dev" entry for the remote node to sync with DCNL :param job: information about the partition being synced DCNL :param suffixes: a list of suffixes which need to be pushed DCNL :returns: boolean indicating success or failure'
def check_ring(self): DCNL 'Check to see if the ring has been updated DCNL :returns: boolean indicating whether or not the ring has changed'
def update_deleted(self, job): DCNL 'High-level method that replicates a single partition that doesn\'t DCNL belong on this node. DCNL :param job: a dict containing info about the partition to be replicated'
def update(self, job): DCNL 'High-level method that replicates a single partition. DCNL :param job: a dict containing info about the partition to be replicated'
def stats_line(self): DCNL 'Logs various stats for the currently running replication pass.'
def kill_coros(self): DCNL 'Utility function that kills all coroutines currently running.'
def heartbeat(self): DCNL 'Loop that runs in the background during replication.  It periodically DCNL logs progress.'
def detect_lockups(self): DCNL 'In testing, the pool.waitall() call very occasionally failed to return. DCNL This is an attempt to make sure the replicator finishes its replication DCNL pass in some eventuality.'
def collect_jobs(self): DCNL 'Returns a sorted list of jobs (dictionaries) that specify the DCNL partitions, nodes, etc to be rsynced.'
def replicate(self, override_devices=[], override_partitions=[]): DCNL 'Run a replication pass'
def object_audit(self, path, device, partition): DCNL 'Audits the given object path. DCNL :param path: a path to an object DCNL :param device: the device the path is on DCNL :param partition: the partition the path is on'
def run_forever(self, *args, **kwargs): DCNL 'Run the object audit until stopped.'
def run_once(self, *args, **kwargs): DCNL 'Run the object audit once.'
def report(self, final=False): DCNL 'Emits a log line report of the progress so far, or the final progress DCNL is final=True. DCNL :param final: Set to True for the last report once the expiration pass DCNL has completed.'
def run_once(self, *args, **kwargs): DCNL 'Executes a single pass, looking for objects to expire. DCNL :param args: Extra args to fulfill the Daemon interface; this daemon DCNL has no additional args. DCNL :param kwargs: Extra keyword args to fulfill the Daemon interface; this DCNL daemon has no additional keyword args.'
def run_forever(self, *args, **kwargs): DCNL 'Executes passes forever, looking for objects to expire. DCNL :param args: Extra args to fulfill the Daemon interface; this daemon DCNL has no additional args. DCNL :param kwargs: Extra keyword args to fulfill the Daemon interface; this DCNL daemon has no additional keyword args.'
def delete_actual_object(self, actual_obj, timestamp): DCNL 'Deletes the end-user object indicated by the actual object name given DCNL \'<account>/<container>/<object>\' if and only if the X-Delete-At value DCNL of the object is exactly the timestamp given. DCNL :param actual_obj: The name of the end-user object to delete: DCNL \'<account>/<container>/<object>\' DCNL :param timestamp: The timestamp the X-Delete-At value must match to DCNL perform the actual delete.'
def get_controller(self, path): DCNL 'Get the controller to handle a request. DCNL :param path: path from request DCNL :returns: tuple of (controller class, path dictionary) DCNL :raises: ValueError (thrown by split_path) if given invalid path'
def __call__(self, env, start_response): DCNL 'WSGI entry point. DCNL Wraps env in swob.Request object and passes it down. DCNL :param env: WSGI environment dictionary DCNL :param start_response: WSGI callable'
def handle_request(self, req): DCNL 'Entry point for proxy server. DCNL Should return a WSGI-style callable (such as swob.Response). DCNL :param req: swob.Request object'
def sort_nodes(self, nodes): DCNL 'Sorts nodes in-place (and returns the sorted list) according to DCNL the configured strategy. The default "sorting" is to randomly DCNL shuffle the nodes. If the "timing" strategy is chosen, the nodes DCNL are sorted according to the stored timing data.'
def error_increment(self, node): DCNL 'Handles incrementing error counts when talking to nodes. DCNL :param node: dictionary of node to increment the error count for'
def error_occurred(self, node, msg): DCNL 'Handle logging, and handling of errors. DCNL :param node: dictionary of node to handle errors for DCNL :param msg: error message'
def exception_occurred(self, node, typ, additional_info): DCNL 'Handle logging of generic exceptions. DCNL :param node: dictionary of node to log the error for DCNL :param typ: server type DCNL :param additional_info: additional information to log'
def error_limited(self, node): DCNL 'Check if the node is currently error limited. DCNL :param node: dictionary of node to check DCNL :returns: True if error limited, False otherwise'
def error_limit(self, node): DCNL 'Mark a node as error limited. DCNL :param node: dictionary of node to error limit'
def account_info(self, account, autocreate=False): DCNL 'Get account information, and also verify that the account exists. DCNL :param account: name of the account to get the info for DCNL :returns: tuple of (account partition, account nodes, container_count) DCNL or (None, None, None) if it does not exist'
def container_info(self, account, container, account_autocreate=False): DCNL 'Get container information and thusly verify container existence. DCNL This will also make a call to account_info to verify that the DCNL account exists. DCNL :param account: account name for the container DCNL :param container: container name to look up DCNL :returns: dict containing at least container partition (\'partition\'), DCNL container nodes (\'containers\'), container read DCNL acl (\'read_acl\'), container write acl (\'write_acl\'), DCNL and container sync key (\'sync_key\'). DCNL Values are set to None if the container does not exist.'
def iter_nodes(self, partition, nodes, ring): DCNL 'Node iterator that will first iterate over the normal nodes for a DCNL partition and then the handoff partitions for the node. DCNL :param partition: partition to iterate nodes for DCNL :param nodes: list of node dicts from the ring DCNL :param ring: ring to get handoff nodes from'
def make_requests(self, req, ring, part, method, path, headers, query_string=''): DCNL 'Sends an HTTP request to multiple nodes and aggregates the results. DCNL It attempts the primary nodes concurrently, then iterates over the DCNL handoff nodes as needed. DCNL :param headers: a list of dicts, where each dict represents one DCNL backend request that should be made. DCNL :returns: a swob.Response object'
def best_response(self, req, statuses, reasons, bodies, server_type, etag=None): DCNL 'Given a list of responses from several servers, choose the best to DCNL return to the API. DCNL :param req: swob.Request object DCNL :param statuses: list of statuses returned DCNL :param reasons: list of reasons for each status DCNL :param bodies: bodies of each response DCNL :param server_type: type of server the responses came from DCNL :param etag: etag DCNL :returns: swob.Response object with the correct status, body, etc. set'
@public DCNL def GET(self, req): DCNL 'Handler for HTTP GET requests.'
@public DCNL def HEAD(self, req): DCNL 'Handler for HTTP HEAD requests.'
def _make_app_iter_reader(self, node, source, queue, logger_thread_locals): DCNL 'Reads from the source and places data in the queue. It expects DCNL something else be reading from the queue and, if nothing does within DCNL self.app.client_timeout seconds, the process will be aborted. DCNL :param node: The node dict that the source is connected to, for DCNL logging/error-limiting purposes. DCNL :param source: The httplib.Response object to read from. DCNL :param queue: The eventlet.queue.Queue to place read source data into. DCNL :param logger_thread_locals: The thread local values to be set on the DCNL self.app.logger to retain transaction DCNL logging information.'
def _make_app_iter(self, node, source): DCNL 'Returns an iterator over the contents of the source (via its read DCNL func).  There is also quite a bit of cleanup to ensure garbage DCNL collection works and the underlying socket of the source is closed. DCNL :param source: The httplib.Response object this iterator should read DCNL from. DCNL :param node: The node the source is reading from, for logging purposes.'
def is_good_source(self, src): DCNL 'Indicates whether or not the request made to the backend found DCNL what it was looking for.'
def GETorHEAD_base(self, req, server_type, partition, nodes, path, attempts): DCNL 'Base handler for HTTP GET or HEAD requests. DCNL :param req: swob.Request object DCNL :param server_type: server type DCNL :param partition: partition DCNL :param nodes: nodes DCNL :param path: path for the request DCNL :param attempts: number of attempts to try DCNL :returns: swob.Response object'
def is_origin_allowed(self, cors_info, origin): DCNL 'Is the given Origin allowed to make requests to this resource DCNL :param cors_info: the resource\'s CORS related metadata headers DCNL :param origin: the origin making the request DCNL :return: True or False'
@public DCNL def OPTIONS(self, req): DCNL 'Base handler for OPTIONS requests DCNL :param req: swob.Request object DCNL :returns: swob.Response object'
def GETorHEAD(self, req): DCNL 'Handler for HTTP GET/HEAD requests.'
@public DCNL def PUT(self, req): DCNL 'HTTP PUT request handler.'
@public DCNL def POST(self, req): DCNL 'HTTP POST request handler.'
@public DCNL def DELETE(self, req): DCNL 'HTTP DELETE request handler.'
def _load_next_segment(self): DCNL 'Loads the self.segment_iter with the next object segment\'s contents. DCNL :raises: StopIteration when there are no more object segments or DCNL segment no longer matches SLO manifest specifications.'
def __iter__(self): DCNL 'Standard iterator function that returns the object\'s contents.'
def app_iter_range(self, start, stop): DCNL 'Non-standard iterator function for use with Swob in serving Range DCNL requests more quickly. This will skip over segments and do a range DCNL request on the first segment to return data from, if needed. DCNL :param start: The first byte (zero-based) to return. None for 0. DCNL :param stop: The last byte (zero-based) to return. None for end.'
def _remaining_items(self, listing_iter): DCNL 'Returns an item-by-item iterator for a page-by-page iterator DCNL of item listings. DCNL Swallows listing-related errors; this iterator is only used DCNL after we\'ve already started streaming a response to the DCNL client, and so if we start getting errors from the container DCNL servers now, it\'s too late to send an error to the client, so DCNL we just quit looking for segments.'
def is_good_source(self, src): DCNL 'Indicates whether or not the request made to the backend found DCNL what it was looking for. DCNL In the case of an object, a 416 indicates that we found a DCNL backend with the object.'
def GETorHEAD(self, req): DCNL 'Handle HTTP GET or HEAD requests.'
@public DCNL @cors_validation DCNL @delay_denial DCNL def GET(self, req): DCNL 'Handler for HTTP GET requests.'
@public DCNL @cors_validation DCNL @delay_denial DCNL def HEAD(self, req): DCNL 'Handler for HTTP HEAD requests.'
@public DCNL @cors_validation DCNL @delay_denial DCNL def POST(self, req): DCNL 'HTTP POST request handler.'
def _send_file(self, conn, path): DCNL 'Method for a file PUT coro'
def _connect_put_node(self, nodes, part, path, headers, logger_thread_locals): DCNL 'Method for a file PUT connect'
@public DCNL @cors_validation DCNL @delay_denial DCNL def PUT(self, req): DCNL 'HTTP PUT request handler.'
@public DCNL @cors_validation DCNL @delay_denial DCNL def DELETE(self, req): DCNL 'HTTP DELETE request handler.'
@public DCNL @cors_validation DCNL @delay_denial DCNL def COPY(self, req): DCNL 'HTTP COPY request handler.'
def GETorHEAD(self, req): DCNL 'Handler for HTTP GET/HEAD requests.'
@public DCNL @delay_denial DCNL @cors_validation DCNL def GET(self, req): DCNL 'Handler for HTTP GET requests.'
@public DCNL @delay_denial DCNL @cors_validation DCNL def HEAD(self, req): DCNL 'Handler for HTTP HEAD requests.'
@public DCNL @cors_validation DCNL def PUT(self, req): DCNL 'HTTP PUT request handler.'
@public DCNL @cors_validation DCNL def POST(self, req): DCNL 'HTTP POST request handler.'
@public DCNL @cors_validation DCNL def DELETE(self, req): DCNL 'HTTP DELETE request handler.'
def get_account_ring(self): DCNL 'The account :class:`swift.common.ring.Ring` for the cluster.'
def get_container_ring(self): DCNL 'The container :class:`swift.common.ring.Ring` for the cluster.'
def get_object_ring(self): DCNL 'The object :class:`swift.common.ring.Ring` for the cluster.'
def run_forever(self, *args, **kwargs): DCNL 'Main entry point when running the reaper in its normal daemon mode. DCNL This repeatedly calls :func:`reap_once` no quicker than the DCNL configuration interval.'
def run_once(self, *args, **kwargs): DCNL 'Main entry point when running the reaper in \'once\' mode, where it will DCNL do a single pass over all accounts on the server. This is called DCNL repeatedly by :func:`run_forever`. This will call :func:`reap_device` DCNL once for each device on the server.'
def reap_device(self, device): DCNL 'Called once per pass for each device on the server. This will scan the DCNL accounts directory for the device, looking for partitions this device DCNL is the primary for, then looking for account databases that are marked DCNL status=DELETED and still have containers and calling DCNL :func:`reap_account`. Account databases marked status=DELETED that no DCNL longer have containers will eventually be permanently removed by the DCNL reclaim process within the account replicator (see DCNL :mod:`swift.db_replicator`). DCNL :param device: The device to look for accounts to be deleted.'
def reap_account(self, broker, partition, nodes): DCNL 'Called once per pass for each account this server is the primary for DCNL and attempts to delete the data for the given account. The reaper will DCNL only delete one account at any given time. It will call DCNL :func:`reap_container` up to sqrt(self.concurrency) times concurrently DCNL while reaping the account. DCNL If there is any exception while deleting a single container, the DCNL process will continue for any other containers and the failed DCNL containers will be tried again the next time this function is called DCNL with the same parameters. DCNL If there is any exception while listing the containers for deletion, DCNL the process will stop (but will obviously be tried again the next time DCNL this function is called with the same parameters). This isn\'t likely DCNL since the listing comes from the local database. DCNL After the process completes (successfully or not) statistics about what DCNL was accomplished will be logged. DCNL This function returns nothing and should raise no exception but only DCNL update various self.stats_* values for what occurs. DCNL :param broker: The AccountBroker for the account to delete. DCNL :param partition: The partition in the account ring the account is on. DCNL :param nodes: The primary node dicts for the account to delete. DCNL .. seealso:: DCNL :class:`swift.common.db.AccountBroker` for the broker class. DCNL .. seealso:: DCNL :func:`swift.common.ring.Ring.get_nodes` for a description DCNL of the node dicts.'
def reap_container(self, account, account_partition, account_nodes, container): DCNL 'Deletes the data and the container itself for the given container. This DCNL will call :func:`reap_object` up to sqrt(self.concurrency) times DCNL concurrently for the objects in the container. DCNL If there is any exception while deleting a single object, the process DCNL will continue for any other objects in the container and the failed DCNL objects will be tried again the next time this function is called with DCNL the same parameters. DCNL If there is any exception while listing the objects for deletion, the DCNL process will stop (but will obviously be tried again the next time this DCNL function is called with the same parameters). This is a possibility DCNL since the listing comes from querying just the primary remote container DCNL server. DCNL Once all objects have been attempted to be deleted, the container DCNL itself will be attempted to be deleted by sending a delete request to DCNL all container nodes. The format of the delete request is such that each DCNL container server will update a corresponding account server, removing DCNL the container from the account\'s listing. DCNL This function returns nothing and should raise no exception but only DCNL update various self.stats_* values for what occurs. DCNL :param account: The name of the account for the container. DCNL :param account_partition: The partition for the account on the account DCNL ring. DCNL :param account_nodes: The primary node dicts for the account. DCNL :param container: The name of the container to delete. DCNL * See also: :func:`swift.common.ring.Ring.get_nodes` for a description DCNL of the account node dicts.'
def reap_object(self, account, container, container_partition, container_nodes, obj): DCNL 'Deletes the given object by issuing a delete request to each node for DCNL the object. The format of the delete request is such that each object DCNL server will update a corresponding container server, removing the DCNL object from the container\'s listing. DCNL This function returns nothing and should raise no exception but only DCNL update various self.stats_* values for what occurs. DCNL :param account: The name of the account for the object. DCNL :param container: The name of the container for the object. DCNL :param container_partition: The partition for the container on the DCNL container ring. DCNL :param container_nodes: The primary node dicts for the container. DCNL :param obj: The name of the object to delete. DCNL * See also: :func:`swift.common.ring.Ring.get_nodes` for a description DCNL of the container node dicts.'
@public DCNL @timing_stats() DCNL def DELETE(self, req): DCNL 'Handle HTTP DELETE request.'
@public DCNL @timing_stats() DCNL def PUT(self, req): DCNL 'Handle HTTP PUT request.'
@public DCNL @timing_stats() DCNL def HEAD(self, req): DCNL 'Handle HTTP HEAD request.'
@public DCNL @timing_stats() DCNL def GET(self, req): DCNL 'Handle HTTP GET request.'
@public DCNL @timing_stats() DCNL def REPLICATE(self, req): DCNL 'Handle HTTP REPLICATE request. DCNL Handler for RPC calls for account replication.'
@public DCNL @timing_stats() DCNL def POST(self, req): DCNL 'Handle HTTP POST request.'
def run_forever(self, *args, **kwargs): DCNL 'Run the account audit until stopped.'
def run_once(self, *args, **kwargs): DCNL 'Run the account audit once.'
def account_audit(self, path): DCNL 'Audits the given account path DCNL :param path: the path to an account db'
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True): DCNL 'Runs a command in an out-of-process shell. DCNL Returns the output of that command. Working directory is self.root.'
def create_virtualenv(self, no_site_packages=True): DCNL 'Creates the virtual environment and installs PIP. DCNL Creates the virtual environment and installs PIP only into the DCNL virtual environment.'
def parse_args(self, argv): DCNL 'Parses command-line arguments.'
def post_process(self): DCNL 'Any distribution-specific post-processing gets done here. DCNL In particular, this is useful for applying patches to code inside DCNL the venv.'
def post_process(self): DCNL 'Workaround for a bug in eventlet. DCNL This currently affects RHEL6.1, but the fix can safely be DCNL applied to all RHEL and Fedora distributions. DCNL This can be removed when the fix is applied upstream. DCNL Nova: https://bugs.launchpad.net/nova/+bug/884915 DCNL Upstream: https://bitbucket.org/which_linden/eventlet/issue/89'
def test_policy_crud(self): DCNL 'Due to lack of endpoint CRUD'
def new_ref(self): DCNL 'Populates a ref with attributes common to all API entities.'
def _get_token_id(self, r): DCNL 'Applicable only to JSON.'
def setUp(self): DCNL 'Setup for Identity Protection Test Cases. DCNL As well as the usual housekeeping, create a set of domains, DCNL users, roles and projects for the subsequent tests: DCNL - Three domains: A,B & C.  C is disabled. DCNL - DomainA has user1, DomainB has user2 and user3 DCNL - DomainA has group1 and group2, DomainB has group3 DCNL - User1 has a role on DomainA DCNL Remember that there will also be a fourth domain in existence, DCNL the default domain.'
def test_list_users_unprotected(self): DCNL 'GET /users (unprotected) DCNL Test Plan: DCNL - Update policy so api is unprotected DCNL - Use an un-scoped token to make sure we can get back all DCNL the users independent of domain'
def test_list_users_filtered_by_domain(self): DCNL 'GET /users?domain_id=mydomain (filtered) DCNL Test Plan: DCNL - Update policy so api is unprotected DCNL - Use an un-scoped token to make sure we can filter the DCNL users by domainB, getting back the 2 users in that domain'
def test_get_user_protected_match_id(self): DCNL 'GET /users/{id} (match payload) DCNL Test Plan: DCNL - Update policy to protect api by user_id DCNL - List users with user_id of user1 as filter, to check that DCNL this will correctly match user_id in the flattened DCNL payload'
def test_list_users_protected_by_domain(self): DCNL 'GET /users?domain_id=mydomain (protected) DCNL Test Plan: DCNL - Update policy to protect api by domain_id DCNL - List groups using a token scoped to domainA with a filter DCNL specifying domainA - we should only get back the one user DCNL that is in domainA. DCNL - Try and read the users from domainB - this should fail since DCNL we don\'t have a token scoped for domainB'
def test_list_groups_protected_by_domain(self): DCNL 'GET /groups?domain_id=mydomain (protected) DCNL Test Plan: DCNL - Update policy to protect api by domain_id DCNL - List groups using a token scoped to domainA and make sure DCNL we only get back the two groups that are in domainA DCNL - Try and read the groups from domainB - this should fail since DCNL we don\'t have a token scoped for domainB'
def test_list_groups_protected_by_domain_and_filtered(self): DCNL 'GET /groups?domain_id=mydomain&name=myname (protected) DCNL Test Plan: DCNL - Update policy to protect api by domain_id DCNL - List groups using a token scoped to domainA with a filter DCNL specifying both domainA and the name of group. DCNL - We should only get back the group in domainA that matches DCNL the name'
def test_list_filtered_domains(self): DCNL 'GET /domains?enabled=0 DCNL Test Plan: DCNL - Update policy for no protection on api DCNL - Filter by the \'enabled\' boolean to get disabled domains, which DCNL should return just domainC DCNL - Try the filter using different ways of specifying \'true\' DCNL to test that our handling of booleans in filter matching is DCNL correct'
def test_multiple_filters(self): DCNL 'GET /domains?enabled&name=myname DCNL Test Plan: DCNL - Update policy for no protection on api DCNL - Filter by the \'enabled\' boolean and name - this should DCNL return a single domain'
def test_two_steps_forward_one_step_back(self): DCNL 'You should be able to cleanly undo and re-apply all upgrades. DCNL Upgrades are run in the following order:: DCNL 0 -> 1 -> 0 -> 1 -> 2 -> 1 -> 2 -> 3 -> 2 -> 3 ...'
def assertTableColumns(self, table_name, expected_cols): DCNL 'Asserts that the table contains the expected set of columns.'
def insert_dict(self, session, table_name, d): DCNL 'Naively inserts key-value pairs into a table, given a dictionary.'
def assertTableDoesNotExist(self, table_name): DCNL 'Asserts that a given table exists cannot be selected by name.'
def assertEqualTokens(self, a, b): DCNL 'Assert that two tokens are equal. DCNL Compare two tokens except for their ids. This also truncates DCNL the time in the comparison.'
def test_no_external_auth(self): DCNL 'Verify that _authenticate_external() raises exception if DCNL not applicable'
def test_no_token_in_auth(self): DCNL 'Verity that _authenticate_token() raises exception if no token'
def test_no_credentials_in_auth(self): DCNL 'Verity that _authenticate_local() raises exception if no creds'
def test_authenticate_blank_request_body(self): DCNL 'Verify sending empty json dict raises the right exception.'
def test_authenticate_blank_auth(self): DCNL 'Verify sending blank \'auth\' raises the right exception.'
def test_authenticate_invalid_auth_content(self): DCNL 'Verify sending invalid \'auth\' raises the right exception.'
def test_authenticate_user_id_too_large(self): DCNL 'Verify sending large \'userId\' raises the right exception.'
def test_authenticate_username_too_large(self): DCNL 'Verify sending large \'username\' raises the right exception.'
def test_authenticate_tenant_id_too_large(self): DCNL 'Verify sending large \'tenantId\' raises the right exception.'
def test_authenticate_tenant_name_too_large(self): DCNL 'Verify sending large \'tenantName\' raises the right exception.'
def test_authenticate_token_too_large(self): DCNL 'Verify sending large \'token\' raises the right exception.'
def test_authenticate_password_too_large(self): DCNL 'Verify sending large \'password\' raises the right exception.'
def test_unscoped_token(self): DCNL 'Verify getting an unscoped token with password creds'
def test_auth_invalid_token(self): DCNL 'Verify exception is raised if invalid token'
def test_auth_bad_formatted_token(self): DCNL 'Verify exception is raised if invalid token'
def test_auth_unscoped_token_no_project(self): DCNL 'Verify getting an unscoped token with an unscoped token'
def test_auth_unscoped_token_project(self): DCNL 'Verify getting a token in a tenant with an unscoped token'
def test_auth_token_project_group_role(self): DCNL 'Verify getting a token in a tenant with group roles'
def test_auth_token_cross_domain_group_and_project(self): DCNL 'Verify getting a token in cross domain group/project roles'
def test_auth_invalid_user(self): DCNL 'Verify exception is raised if invalid user'
def test_auth_valid_user_invalid_password(self): DCNL 'Verify exception is raised if invalid password'
def test_auth_empty_password(self): DCNL 'Verify exception is raised if empty password'
def test_auth_no_password(self): DCNL 'Verify exception is raised if empty password'
def test_authenticate_blank_password_credentials(self): DCNL 'Verify sending empty json dict as passwordCredentials raises the DCNL right exception.'
def test_authenticate_no_username(self): DCNL 'Verify skipping username raises the right exception.'
def test_unscoped_remote_authn(self): DCNL 'Verify getting an unscoped token with external authn'
def test_unscoped_remote_authn_jsonless(self): DCNL 'Verify that external auth with invalid request fails'
def test_scoped_remote_authn(self): DCNL 'Verify getting a token with external authn'
def test_scoped_nometa_remote_authn(self): DCNL 'Verify getting a token with external authn and no metadata'
def test_scoped_remote_authn_invalid_user(self): DCNL 'Verify that external auth with invalid user fails'
def _maintain_token_expiration(self): DCNL 'Token expiration should be maintained after re-auth & validation.'
def setUp(self, load_sample_data=True): DCNL 'Setup for v3 Restful Test Cases. DCNL If a child class wants to create their own sample data DCNL and provide their own auth data to obtain tokens, then DCNL load_sample_data should be set to false.'
def new_ref(self): DCNL 'Populates a ref with attributes common to all API entities.'
def admin_request(self, *args, **kwargs): DCNL 'Translates XML responses to dicts. DCNL This implies that we only have to write assertions for JSON.'
def get_scoped_token(self): DCNL 'Convenience method so that we can test authenticated requests.'
def get_requested_token(self, auth): DCNL 'Request the specific token we want.'
def assertValidListResponse(self, resp, key, entity_validator, ref=None, expected_length=None): DCNL 'Make assertions common to all API list responses. DCNL If a reference is provided, it\'s ID will be searched for in the DCNL response, and asserted to be equal.'
def assertValidResponse(self, resp, key, entity_validator, *args, **kwargs): DCNL 'Make assertions common to all API responses.'
def assertValidEntity(self, entity, ref=None): DCNL 'Make assertions common to all API entities. DCNL If a reference is provided, the entity will also be compared against DCNL the reference.'
def assertEqualTokens(self, a, b): DCNL 'Assert that two tokens are equal. DCNL Compare two tokens except for their ids. This also truncates DCNL the time in the comparison.'
def build_authentication_request(self, token=None, user_id=None, username=None, user_domain_id=None, user_domain_name=None, password=None, **kwargs): DCNL 'Build auth dictionary. DCNL It will create an auth dictionary based on all the arguments DCNL that it receives.'
def test_build_tree(self): DCNL 'Regression test for building the tree names'
def tearDown(self): DCNL 'Kill running servers and release references to avoid leaks.'
def request(self, host='0.0.0.0', port=80, method='GET', path='/', headers=None, body=None, expected_status=None): DCNL 'Perform request and fetch httplib.HTTPResponse from the server.'
def assertResponseSuccessful(self, response): DCNL 'Asserts that a status code lies inside the 2xx range. DCNL :param response: :py:class:`httplib.HTTPResponse` to be DCNL verified to have a status code between 200 and 299. DCNL example:: DCNL >>> self.assertResponseSuccessful(response, 203)'
def assertResponseStatus(self, response, expected_status): DCNL 'Asserts a specific status code on the response. DCNL :param response: :py:class:`httplib.HTTPResponse` DCNL :param assert_status: The specific ``status`` result expected DCNL example:: DCNL >>> self.assertResponseStatus(response, 203)'
def assertValidResponseHeaders(self, response): DCNL 'Ensures that response headers appear as expected.'
def _to_content_type(self, body, headers, content_type=None): DCNL 'Attempt to encode JSON and XML automatically.'
def _from_content_type(self, response, content_type=None): DCNL 'Attempt to decode JSON and XML automatically, if detected.'
def restful_request(self, method='GET', headers=None, body=None, token=None, content_type=None, **kwargs): DCNL 'Serializes/deserializes json/xml as request/response body. DCNL .. WARNING:: DCNL * Existing Accept header will be overwritten. DCNL * Existing Content-Type header will be overwritten.'
def get_scoped_token(self): DCNL 'Convenience method so that we can test authenticated requests.'
def _get_token_id(self, r): DCNL 'Helper method to return a token ID from a response. DCNL This needs to be overridden by child classes for on their content type.'
def assertValidError(self, error): DCNL 'Applicable to XML and JSON.'
def assertValidVersion(self, version): DCNL 'Applicable to XML and JSON. DCNL However, navigating links and media-types differs between content DCNL types so they need to be validated separately.'
def assertValidExtension(self, extension): DCNL 'Applicable to XML and JSON. DCNL However, navigating extension links differs between content types. DCNL They need to be validated separately with assertValidExtensionLink.'
def assertValidExtensionLink(self, link): DCNL 'Applicable to XML and JSON.'
def assertValidTenant(self, tenant): DCNL 'Applicable to XML and JSON.'
def assertValidUser(self, user): DCNL 'Applicable to XML and JSON.'
def assertValidRole(self, tenant): DCNL 'Applicable to XML and JSON.'
def test_validate_token_head(self): DCNL 'The same call as above, except using HEAD. DCNL There\'s no response to validate here, but this is included for the DCNL sake of completely covering the core API.'
def test_error_response(self): DCNL 'This triggers assertValidErrorResponse by convention.'
def _get_token_id(self, r): DCNL 'Applicable only to JSON.'
def test_service_crud_requires_auth(self): DCNL 'Service CRUD should 401 without an X-Auth-Token (bug 1006822).'
def test_user_role_list_requires_auth(self): DCNL 'User role list should 401 without an X-Auth-Token (bug 1006815).'
def _tag(self, tag_name, xmlns=None): DCNL 'Helper method to build an namespaced element name.'
def test_keyword_arg_condition_or_methods(self): DCNL 'Raise if we see a keyword arg called \'condition\' or \'methods\''
def test_client_wants_xml_back(self): DCNL 'Clients requesting XML should get what they ask for.'
def test_client_wants_json_back(self): DCNL 'Clients requesting JSON should definitely not get XML back.'
def test_client_fails_to_specify_accept(self): DCNL 'If client does not specify an Accept header, default to JSON.'
def test_xml_replaced_by_json(self): DCNL 'XML requests should be replaced by JSON requests.'
def test_json_unnaffected(self): DCNL 'JSON-only requests should be unnaffected by the XML middleware.'
def setUp(self): DCNL 'Setup for Token Revoking Test Cases. DCNL As well as the usual housekeeping, create a set of domains, DCNL users, groups, roles and projects for the subsequent tests: DCNL - Two domains: A & B DCNL - DomainA has user1, domainB has user2 and user3 DCNL - DomainA has group1 and group2, domainB has group3 DCNL - User1 has a role on domainA DCNL - Two projects: A & B, both in domainA DCNL - All users have a role on projectA DCNL - Two groups: 1 & 2 DCNL - User1 and user2 are members of group1 DCNL - User3 is a member of group2'
def test_deleting_user_grant_revokes_token(self): DCNL 'Test deleting a user grant revokes token. DCNL Test Plan: DCNL - Get a token for user1, scoped to ProjectA DCNL - Delete the grant user1 has on ProjectA DCNL - Check token is no longer valid'
def test_creating_user_grant_revokes_token(self): DCNL 'Test creating a user grant revokes token. DCNL Test Plan: DCNL - Get a token for user1, scoped to ProjectA DCNL - Create a grant for user1 on DomainB DCNL - Check token is no longer valid'
def test_deleting_group_grant_revokes_tokens(self): DCNL 'Test deleting a group grant revokes tokens. DCNL Test Plan: DCNL - Get a token for user1, scoped to ProjectA DCNL - Get a token for user2, scoped to ProjectA DCNL - Get a token for user3, scoped to ProjectA DCNL - Delete the grant group1 has on ProjectA DCNL - Check tokens for user1 & user2 are no longer valid, DCNL since user1 and user2 are members of group1 DCNL - Check token for user3 is still valid'
def test_creating_group_grant_revokes_token(self): DCNL 'Test creating a group grant revokes token. DCNL Test Plan: DCNL - Get a token for user1, scoped to ProjectA DCNL - Create a grant for group1 on DomainB DCNL - Check token is no longer valid'
def test_group_membership_changes_revokes_token(self): DCNL 'Test add/removal to/from group revokes token. DCNL Test Plan: DCNL - Get a token for user1, scoped to ProjectA DCNL - Get a token for user2, scoped to ProjectA DCNL - Remove user1 from group1 DCNL - Check token for user1 is no longer valid DCNL - Check token for user2 is still valid, even though DCNL user2 is also part of group1 DCNL - Add user2 to group2 DCNL - Check token for user2 is now no longer valid'
def test_all_json_renderings(self): DCNL 'Everything callable in the exception module should be renderable. DCNL ... except for the base error class (exception.Error), which is not DCNL user-facing. DCNL This test provides a custom message to bypass docstring parsing, which DCNL should be tested separately.'
def test_ipv6_ok(self): DCNL 'Make sure both public and admin API work with ipv6.'
def test_create_policy(self): DCNL 'POST /policies'
def test_list_policies(self): DCNL 'GET /policies'
def test_list_policies_xml(self): DCNL 'GET /policies (xml data)'
def test_get_policy(self): DCNL 'GET /policies/{policy_id}'
def test_update_policy(self): DCNL 'PATCH /policies/{policy_id}'
def test_delete_policy(self): DCNL 'DELETE /policies/{policy_id}'
def assertEqualXML(self, a, b): DCNL 'Parses two XML documents from strings and compares the results. DCNL This provides easy-to-read failures from nose.'
def __init__(self, *args, **kwargs): DCNL 'Ignores the passed in args.'
def get(self, key): DCNL 'Retrieves the value for a key or None.'
def set(self, key, value, time=0): DCNL 'Sets the value for a key.'
def test_get_roles_for_user_and_domain(self): DCNL 'Test for getting roles for user on a domain. DCNL Test Plan: DCNL - Create a domain, with 2 users DCNL - Check no roles yet exit DCNL - Give user1 two roles on the domain, user2 one role DCNL - Get roles on user1 and the domain - maybe sure we only DCNL get back the 2 roles on user1 DCNL - Delete both roles from user1 DCNL - Check we get no roles back for user1 on domain'
def test_get_roles_for_user_and_domain_404(self): DCNL 'Test errors raised when getting roles for user on a domain. DCNL Test Plan: DCNL - Check non-existing user gives UserNotFound DCNL - Check non-existing domain gives DomainNotFound'
def test_build_tree(self): DCNL 'Regression test for building the tree names'
def test_user_api_get_connection_no_user_password(self): DCNL 'Don\'t bind in case the user and password are blank'
def test_trailing_slash_normalization(self): DCNL 'Tests /v2.0/tokens and /v2.0/tokens/ normalized URLs match.'
def test_rewrite_empty_path(self): DCNL 'Tests empty path is rewritten to root.'
def test_1way_ssl_ok(self): DCNL 'Make sure both public and admin API work with 1-way SSL.'
def test_2way_ssl_ok(self): DCNL 'Make sure both public and admin API work with 2-way SSL.  Requires DCNL client certificate.'
def test_1way_ssl_with_ipv6_ok(self): DCNL 'Make sure both public and admin API work with 1-way ipv6 & SSL.'
def test_2way_ssl_with_ipv6_ok(self): DCNL 'Make sure both public and admin API work with 2-way ipv6 & SSL. DCNL Requires client certificate.'
def test_2way_ssl_fail(self): DCNL 'Expect to fail when client does not present proper certificate.'
def assertMethodNotImplemented(self, f): DCNL 'Asserts that a given method raises 501 Not Implemented. DCNL Provides each argument with a value of None, ignoring optional DCNL arguments.'
def assertInterfaceNotImplemented(self, interface): DCNL 'Public methods on an interface class should not be implemented.'
def test_create_domain(self): DCNL 'POST /domains'
def test_list_domains(self): DCNL 'GET /domains'
def test_list_domains_xml(self): DCNL 'GET /domains (xml data)'
def test_get_domain(self): DCNL 'GET /domains/{domain_id}'
def test_update_domain(self): DCNL 'PATCH /domains/{domain_id}'
def test_disable_domain(self): DCNL 'PATCH /domains/{domain_id} (set enabled=False)'
def test_delete_enabled_domain_fails(self): DCNL 'DELETE /domains/{domain_id}...(when domain enabled)'
def test_delete_domain(self): DCNL 'DELETE /domains/{domain_id} DCNL The sample data set up already has a user, group, project DCNL and credential that is part of self.domain. Since the user DCNL we will authenticate with is in this domain, we create a DCNL another set of entities in a second domain.  Deleting this DCNL second domain should delete all these new entities. In addition, DCNL all the entities in the regular self.domain should be unaffected DCNL by the delete. DCNL Test Plan: DCNL - Create domain2 and a 2nd set of entities DCNL - Disable domain2 DCNL - Delete domain2 DCNL - Check entities in domain2 have been deleted DCNL - Check entities in self.domain are unaffected'
def test_list_projects(self): DCNL 'GET /projects'
def test_list_projects_xml(self): DCNL 'GET /projects (xml data)'
def test_create_project(self): DCNL 'POST /projects'
def test_get_project(self): DCNL 'GET /projects/{project_id}'
def test_update_project(self): DCNL 'PATCH /projects/{project_id}'
def test_delete_project(self): DCNL 'DELETE /projects/{project_id} DCNL As well as making sure the delete succeeds, we ensure DCNL that any credentials that reference this projects are DCNL also deleted, while other credentials are unaffected.'
def test_create_user(self): DCNL 'POST /users'
def test_list_users(self): DCNL 'GET /users'
def test_list_users_xml(self): DCNL 'GET /users (xml data)'
def test_get_user(self): DCNL 'GET /users/{user_id}'
def test_add_user_to_group(self): DCNL 'PUT /groups/{group_id}/users/{user_id}'
def test_check_user_in_group(self): DCNL 'HEAD /groups/{group_id}/users/{user_id}'
def test_list_users_in_group(self): DCNL 'GET /groups/{group_id}/users'
def test_remove_user_from_group(self): DCNL 'DELETE /groups/{group_id}/users/{user_id}'
def test_update_user(self): DCNL 'PATCH /users/{user_id}'
def test_delete_user(self): DCNL 'DELETE /users/{user_id} DCNL As well as making sure the delete succeeds, we ensure DCNL that any credentials that reference this user are DCNL also deleted, while other credentials are unaffected. DCNL In addition, no tokens should remain valid for this user.'
def test_create_group(self): DCNL 'POST /groups'
def test_list_groups(self): DCNL 'GET /groups'
def test_list_groups_xml(self): DCNL 'GET /groups (xml data)'
def test_get_group(self): DCNL 'GET /groups/{group_id}'
def test_update_group(self): DCNL 'PATCH /groups/{group_id}'
def test_delete_group(self): DCNL 'DELETE /groups/{group_id}'
def test_list_credentials(self): DCNL 'GET /credentials'
def test_list_credentials_xml(self): DCNL 'GET /credentials (xml data)'
def test_create_credential(self): DCNL 'POST /credentials'
def test_get_credential(self): DCNL 'GET /credentials/{credential_id}'
def test_update_credential(self): DCNL 'PATCH /credentials/{credential_id}'
def test_delete_credential(self): DCNL 'DELETE /credentials/{credential_id}'
def test_create_role(self): DCNL 'POST /roles'
def test_list_roles(self): DCNL 'GET /roles'
def test_list_roles_xml(self): DCNL 'GET /roles (xml data)'
def test_get_role(self): DCNL 'GET /roles/{role_id}'
def test_update_role(self): DCNL 'PATCH /roles/{role_id}'
def test_delete_role(self): DCNL 'DELETE /roles/{role_id}'
def test_create_service(self): DCNL 'POST /services'
def test_list_services(self): DCNL 'GET /services'
def test_list_services_xml(self): DCNL 'GET /services (xml data)'
def test_get_service(self): DCNL 'GET /services/{service_id}'
def test_update_service(self): DCNL 'PATCH /services/{service_id}'
def test_delete_service(self): DCNL 'DELETE /services/{service_id}'
def test_list_endpoints(self): DCNL 'GET /endpoints'
def test_list_endpoints_xml(self): DCNL 'GET /endpoints (xml data)'
def test_create_endpoint(self): DCNL 'POST /endpoints'
def test_create_endpoint_400(self): DCNL 'POST /endpoints'
def test_get_endpoint(self): DCNL 'GET /endpoints/{endpoint_id}'
def test_update_endpoint(self): DCNL 'PATCH /endpoints/{endpoint_id}'
def test_delete_endpoint(self): DCNL 'DELETE /endpoints/{endpoint_id}'
def test_update_project_returns_extra(self): DCNL 'This tests for backwards-compatibility with an essex/folsom bug. DCNL Non-indexed attributes were returned in an \'extra\' attribute, instead DCNL of on the entity itself; for consistency and backwards compatibility, DCNL those attributes should be included twice. DCNL This behavior is specific to the SQL driver.'
def test_update_user_returns_extra(self): DCNL 'This tests for backwards-compatibility with an essex/folsom bug. DCNL Non-indexed attributes were returned in an \'extra\' attribute, instead DCNL of on the entity itself; for consistency and backwards compatibility, DCNL those attributes should be included twice. DCNL This behavior is specific to the SQL driver.'
def __init__(self, message=None, **kwargs): DCNL 'Use the doc string as the error message by default.'
def _build_message(self, message, **kwargs): DCNL 'Builds and returns an exception message. DCNL :raises: KeyError given insufficient kwargs'
def __str__(self): DCNL 'Cleans up line breaks and indentation from doc strings.'
def _build_message(self, message, **kwargs): DCNL 'Only returns detailed messages in debug mode.'
def disable_module(self, module): DCNL 'Ensure ImportError for the specified module.'
def load_backends(self): DCNL 'Create shortcut references to each driver for data manipulation.'
def load_fixtures(self, fixtures): DCNL 'Hacky basic and naive fixture loading based on a python module. DCNL Expects that the various APIs into the various services are already DCNL defined on `self`.'
def assertCloseEnoughForGovernmentWork(self, a, b, delta=3): DCNL 'Asserts that two datetimes are nearly equal within a small delta. DCNL :param delta: Maximum allowable time delta, defined in seconds.'
def __call__(self, xml_str): DCNL 'Returns a dictionary populated by decoding the given xml string.'
@staticmethod DCNL def _tag_name(tag, namespace): DCNL 'Returns a tag name. DCNL The tag name may contain the namespace prefix or not, which can DCNL be determined by specifying the parameter namespace.'
def walk_element(self, element, namespace=False): DCNL 'Populates a dictionary by walking an etree element.'
def __call__(self, d, xmlns=None): DCNL 'Returns an xml etree populated by the given dictionary. DCNL Optionally, namespace the etree by specifying an ``xmlns``.'
def _populate_list(self, element, k, v): DCNL 'Populates an element with a key & list value.'
def _populate_dict(self, element, k, v): DCNL 'Populates an element with a key & dictionary value.'
def _populate_bool(self, element, k, v): DCNL 'Populates an element with a key & boolean value.'
def _populate_str(self, element, k, v): DCNL 'Populates an element with a key & string value.'
def _populate_number(self, element, k, v): DCNL 'Populates an element with a key & numeric value.'
def populate_element(self, element, value): DCNL 'Populates an etree with the given value.'
def _populate_sequence(self, element, l): DCNL 'Populates an etree with a sequence of elements, given a list.'
def _populate_tree(self, element, d): DCNL 'Populates an etree with attributes & elements, given a dict.'
def __init__(self, data, limit): DCNL ':param data: Underlying data object DCNL :param limit: maximum number of bytes the reader should allow'
def delete(self, key): DCNL 'Deletes an item, returning True on success, False otherwise.'
def __getattr__(self, name): DCNL 'Forward calls to the underlying driver.'
def simple_bind_s(self, dn, password): DCNL 'This method is ignored, but provided for compatibility.'
def unbind_s(self): DCNL 'This method is ignored, but provided for compatibility.'
def add_s(self, dn, attrs): DCNL 'Add an object with the specified attributes at dn.'
def delete_s(self, dn): DCNL 'Remove the ldap object at specified dn.'
def delete_ext_s(self, dn, serverctrls): DCNL 'Remove the ldap object at specified dn.'
def modify_s(self, dn, attrs): DCNL 'Modify the object at dn using the attribute list. DCNL :param dn: an LDAP DN DCNL :param attrs: a list of tuples in the following form: DCNL ([MOD_ADD | MOD_DELETE | MOD_REPACE], attribute, value)'
def search_s(self, dn, scope, query=None, fields=None): DCNL 'Search for all matching objects under dn using the query. DCNL Args: DCNL dn -- dn to search under DCNL scope -- only SCOPE_BASE and SCOPE_SUBTREE are supported DCNL query -- query to filter objects by DCNL fields -- fields to return. Returns all fields if not specified'
def start(self, key=None, backlog=128): DCNL 'Run a WSGI server with the given application.'
def wait(self): DCNL 'Wait until all servers have completed running.'
def _run(self, application, socket): DCNL 'Start a WSGI server in a new green thread.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [app:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [app:wadl] DCNL latest_version = 1.3 DCNL paste.app_factory = nova.api.fancy_api:Wadl.factory DCNL which would result in a call to the `Wadl` class as DCNL import nova.api.fancy_api DCNL fancy_api.Wadl(latest_version=\'1.3\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def __call__(self, environ, start_response): DCNL 'Subclasses will probably want to implement __call__ like this: DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL # Any of the following objects work as responses: DCNL # Option 1: simple string DCNL res = \'message\n\' DCNL # Option 2: a nicely formatted HTTP exception page DCNL res = exc.HTTPForbidden(detail=\'Nice try\') DCNL # Option 3: a webob Response object (in case you need to play with DCNL # headers, or you want to be treated like an iterable, or or or) DCNL res = Response(); DCNL res.app_iter = open(\'somefile\') DCNL # Option 4: any wsgi app to be run next DCNL res = self.application DCNL # Option 5: you can get a Response object for a wsgi app, too, to DCNL # play with headers etc DCNL res = req.get_response(self.application) DCNL # You can then just return your response... DCNL return res DCNL # ... or set req.response and return None. DCNL req.response = res DCNL See the end of http://pythonpaste.org/webob/modules/dec.html DCNL for more info.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [filter:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [filter:analytics] DCNL redis_host = 127.0.0.1 DCNL paste.filter_factory = nova.api.analytics:Analytics.factory DCNL which would result in a call to the `Analytics` class as DCNL import nova.api.analytics DCNL analytics.Analytics(app_from_paste, redis_host=\'127.0.0.1\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def process_request(self, request): DCNL 'Called on each request. DCNL If this returns None, the next application down the stack will be DCNL executed. If it returns a response then that response will be returned DCNL and execution will stop here.'
def process_response(self, request, response): DCNL 'Do whatever you\'d like to the response, based on the request.'
@staticmethod DCNL def print_generator(app_iter): DCNL 'Iterator that prints the contents of a wrapper string.'
def __init__(self, mapper): DCNL 'Create a router for the given routes.Mapper. DCNL Each route in `mapper` must specify a \'controller\', which is a DCNL WSGI app to call.  You\'ll probably want to specify an \'action\' as DCNL well and have your controller be an object that can route DCNL the request to the action-specific method. DCNL Examples: DCNL mapper = routes.Mapper() DCNL sc = ServerController() DCNL # Explicit mapping of one route to a controller+action DCNL mapper.connect(None, \'/svrlist\', controller=sc, action=\'list\') DCNL # Actions are all implicitly defined DCNL mapper.resource(\'server\', \'servers\', controller=sc) DCNL # Pointing to an arbitrary WSGI app.  You can specify the DCNL # {path_info:.*} parameter so the target app can be handed just that DCNL # section of the URL. DCNL mapper.connect(None, \'/v1.0/{path_info:.*}\', controller=BlogApp())'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Route the incoming request to a controller based on self.map. DCNL If no match, return a 404.'
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req): DCNL 'Dispatch the request to the appropriate controller. DCNL Called by self._router after matching the incoming request to a route DCNL and putting the information into req.environ.  Either returns 404 DCNL or the routed WSGI app\'s response.'
def add_routes(self, mapper): DCNL 'Add routes to given mapper.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [filter:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [filter:analytics] DCNL redis_host = 127.0.0.1 DCNL paste.filter_factory = nova.api.analytics:Analytics.factory DCNL which would result in a call to the `Analytics` class as DCNL import nova.api.analytics DCNL analytics.Analytics(app_from_paste, redis_host=\'127.0.0.1\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def to_dict(self, include_extra_dict=False): DCNL 'Returns the model\'s attributes as a dictionary. DCNL If include_extra_dict is True, \'extra\' attributes are literally DCNL included in the resulting dictionary twice, for backwards-compatibility DCNL with a broken implementation.'
def update(self, values): DCNL 'Make the model object behave like a dict.'
def iteritems(self): DCNL 'Make the model object behave like a dict. DCNL Includes attributes from joins.'
def get_session(self, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def get_engine(self, allow_global_engine=True): DCNL 'Return a SQLAlchemy engine. DCNL If allow_global_engine is True and an in-memory sqlite connection DCNL string is provided by CONF, all backends will share a global sqlalchemy DCNL engine.'
def get_sessionmaker(self, engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def dump_catalog(self): DCNL 'Generate the contents of a catalog templates file.'
def _require_attribute(self, ref, attr): DCNL 'Ensures the reference contains the specified attribute.'
def _normalize_domain_id(self, context, ref): DCNL 'Fill in domain_id since v2 calls are not domain-aware. DCNL This will overwrite any domain_id that was inadvertently DCNL specified in the v2 call.'
def _filter_domain_id(self, ref): DCNL 'Remove domain_id since v2 calls are not domain-aware.'
@classmethod DCNL def paginate(cls, context, refs): DCNL 'Paginates a list of references by page & per_page query strings.'
@classmethod DCNL def filter_by_attribute(cls, context, refs, attr): DCNL 'Filters a list of references by query string value.'
def _require_matching_id(self, value, ref): DCNL 'Ensures the value matches the reference\'s ID, if any.'
def _assign_unique_id(self, ref): DCNL 'Generates and assigns a unique identifer to a reference.'
def _normalize_domain_id(self, context, ref): DCNL 'Fill in domain_id if not specified in a v3 call.'
def _filter_domain_id(self, ref): DCNL 'Override v2 filter to let domain_id out for v3 calls.'
def enforce(self, context, credentials, action, target): DCNL 'Verify that a user is authorized to perform action. DCNL For more information on a full implementation of this see: DCNL `keystone.common.policy.enforce`.'
def create_policy(self, policy_id, policy): DCNL 'Store a policy blob. DCNL :raises: keystone.exception.Conflict'
def list_policies(self): DCNL 'List all policies.'
def get_policy(self, policy_id): DCNL 'Retrieve a specific policy blob. DCNL :raises: keystone.exception.PolicyNotFound'
def update_policy(self, policy_id, policy): DCNL 'Update a policy blob. DCNL :raises: keystone.exception.PolicyNotFound'
def delete_policy(self, policy_id): DCNL 'Remove a policy blob. DCNL :raises: keystone.exception.PolicyNotFound'
def _get_policy(self, session, policy_id): DCNL 'Private method to get a policy model object (NOT a dictionary).'
def process_request(self, request): DCNL 'Transform the request from XML to JSON.'
def process_response(self, request, response): DCNL 'Transform the response from JSON to XML.'
def process_request(self, request): DCNL 'Normalizes URLs.'
def __init__(self, app, conf): DCNL 'Common initialization code.'
def __call__(self, environ, start_response): DCNL 'Handle incoming request. authenticate and send downstream.'
def get_token(self, token_id): DCNL 'Get a token by id. DCNL :param token_id: identity of the token DCNL :type token_id: string DCNL :returns: token_ref DCNL :raises: keystone.exception.TokenNotFound'
def create_token(self, token_id, data): DCNL 'Create a token by id and data. DCNL :param token_id: identity of the token DCNL :type token_id: string DCNL :param data: dictionary with additional reference information DCNL expires=\'\' DCNL id=token_id, DCNL user=user_ref, DCNL tenant=tenant_ref, DCNL metadata=metadata_ref DCNL :type data: dict DCNL :returns: token_ref or None.'
def delete_token(self, token_id): DCNL 'Deletes a token by id. DCNL :param token_id: identity of the token DCNL :type token_id: string DCNL :returns: None. DCNL :raises: keystone.exception.TokenNotFound'
def list_tokens(self, user_id, tenant_id=None, trust_id=None): DCNL 'Returns a list of current token_id\'s for a user DCNL :param user_id: identity of the user DCNL :type user_id: string DCNL :param tenant_id: identity of the tenant DCNL :type tenant_id: string DCNL :param trust_id: identified of the trust DCNL :type trust_id: string DCNL :returns: list of token_id\'s'
def list_revoked_tokens(self): DCNL 'Returns a list of all revoked tokens DCNL :returns: list of token_id\'s'
def authenticate(self, context, auth=None): DCNL 'Authenticate credentials and return a token. DCNL Accept auth as a dict that looks like:: DCNL "auth":{ DCNL "passwordCredentials":{ DCNL "username":"test_user", DCNL "password":"mypass" DCNL "tenantName":"customer-x" DCNL In this case, tenant is optional, if not provided the token will be DCNL considered "unscoped" and can later be used to get a scoped token. DCNL Alternatively, this call accepts auth with only a token and tenant DCNL that will return a token that is scoped to that tenant.'
def _authenticate_token(self, context, auth): DCNL 'Try to authenticate using an already existing token. DCNL Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)'
def _authenticate_local(self, context, auth): DCNL 'Try to authenticate against the identity backend. DCNL Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)'
def _authenticate_external(self, context, auth): DCNL 'Try to authenticate an external user via REMOTE_USER variable. DCNL Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)'
def _get_project_id_from_auth(self, context, auth): DCNL 'Extract tenant information from auth dict. DCNL Returns a valid tenant_id if it exists, or None if not specified.'
def _get_domain_id_from_auth(self, context, auth): DCNL 'Extract domain information from v3 auth dict. DCNL Returns a valid domain_id if it exists, or None if not specified.'
def _get_project_ref(self, context, user_id, tenant_id): DCNL 'Returns the tenant_ref for the user\'s tenant'
def _get_metadata_ref(self, context, user_id=None, tenant_id=None, domain_id=None, group_id=None): DCNL 'Returns metadata_ref for a user or group in a tenant or domain'
def _get_group_metadata_ref(self, context, user_id, tenant_id=None, domain_id=None): DCNL 'Return any metadata for this project/domain due to group grants'
def _append_roles(self, metadata, additional_metadata): DCNL 'Update the roles in metadata to be the union of the roles from DCNL both of the passed metadatas'
def _get_token_ref(self, context, token_id, belongs_to=None): DCNL 'Returns a token if a valid one exists. DCNL Optionally, limited to a token owned by a specific tenant.'
def _assert_default_domain(self, context, token_ref): DCNL 'Make sure we are operating on default domain only.'
def validate_token_head(self, context, token_id): DCNL 'Check that a token is valid. DCNL Optionally, also ensure that it is owned by a specific tenant. DCNL Identical to ``validate_token``, except does not return a response.'
def validate_token(self, context, token_id): DCNL 'Check that a token is valid. DCNL Optionally, also ensure that it is owned by a specific tenant. DCNL Returns metadata about the token along any associated roles.'
def delete_token(self, context, token_id): DCNL 'Delete a token, effectively invalidating it for authz.'
def endpoints(self, context, token_id): DCNL 'Return a list of endpoints available to the token.'
@classmethod DCNL def format_catalog(cls, catalog_ref): DCNL 'Munge catalogs from internal to output format DCNL Internal catalogs look like: DCNL {$REGION: { DCNL {$SERVICE: { DCNL $key1: $value1, DCNL The legacy api wants them to look like DCNL [{\'name\': $SERVICE[name], DCNL \'type\': $SERVICE, DCNL \'endpoints\': [{ DCNL \'tenantId\': $tenant_id, DCNL \'region\': $REGION, DCNL \'endpoints_links\': [],'
@classmethod DCNL def format_endpoint_list(cls, catalog_ref): DCNL 'Formats a list of endpoints according to Identity API v2. DCNL The v2.0 API wants an endpoint list to look like:: DCNL \'endpoints\': [ DCNL \'id\': $endpoint_id, DCNL \'name\': $SERVICE[name], DCNL \'type\': $SERVICE, DCNL \'tenantId\': $tenant_id, DCNL \'region\': $REGION, DCNL \'endpoints_links\': [],'
def create_trust(self, trust_id, trust, roles): DCNL 'Create a new trust. DCNL :returns: a new trust'
@controller.protected DCNL def create_trust(self, context, trust=None): DCNL 'The user creating the trust must be trustor'
@controller.protected DCNL def check_role_for_trust(self, context, trust_id, role_id): DCNL 'Checks if a role has been assigned to a trust.'
@controller.protected DCNL def get_role_for_trust(self, context, trust_id, role_id): DCNL 'Checks if a role has been assigned to a trust.'
def _get_identity_url(self, version='v2.0'): DCNL 'Returns a URL to keystone\'s own endpoint.'
def _get_versions_list(self, context): DCNL 'The list of versions is dependent on the context.'
@classmethod DCNL def load_json(cls, data, default_rule=None): DCNL 'Allow loading of JSON rule data.'
def __init__(self, rules=None, default_rule=None): DCNL 'Initialize the Rules store.'
def __missing__(self, key): DCNL 'Implements the default rule handling.'
def __str__(self): DCNL 'Dumps a string representation of the rules.'
@abc.abstractmethod DCNL def __str__(self): DCNL 'Retrieve a string representation of the Check tree rooted at DCNL this node.'
@abc.abstractmethod DCNL def __call__(self, target, cred): DCNL 'Perform the check.  Returns False to reject the access or a DCNL true value (not necessary True) to accept the access.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.'
def __init__(self, kind, match): DCNL ':param kind: The kind of the check, i.e., the field before the DCNL :param match: The match of the check, i.e., the field after DCNL the \':\'.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __init__(self, rule): DCNL 'Initialize the \'not\' check. DCNL :param rule: The rule to negate.  Must be a Check.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Returns the logical inverse of the wrapped DCNL check.'
def __init__(self, rules): DCNL 'Initialize the \'and\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Requires that all rules accept in order to DCNL return True.'
def add_check(self, rule): DCNL 'Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the AndCheck object for convenience.'
def __init__(self, rules): DCNL 'Initialize the \'or\' check. DCNL :param rules: A list of rules that will be tested.'
def __str__(self): DCNL 'Return a string representation of this check.'
def __call__(self, target, cred): DCNL 'Check the policy.  Requires that at least one rule accept in DCNL order to return True.'
def add_check(self, rule): DCNL 'Allows addition of another rule to the list of rules that will DCNL be tested.  Returns the OrCheck object for convenience.'
def __new__(mcs, name, bases, cls_dict): DCNL 'Create the class.  Injects the \'reducers\' list, a list of DCNL tuples matching token sequences to the names of the DCNL corresponding reduction methods.'
def __init__(self): DCNL 'Initialize the ParseState.'
def reduce(self): DCNL 'Perform a greedy reduction of the token stream.  If a reducer DCNL method matches, it will be executed, then the reduce() method DCNL will be called recursively to search for any more possible DCNL reductions.'
def shift(self, tok, value): DCNL 'Adds one more token to the state.  Calls reduce().'
@property DCNL def result(self): DCNL 'Obtain the final result of the parse.  Raises ValueError if DCNL the parse failed to reduce to a single result.'
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2): DCNL 'Turn parenthesized expressions into a \'check\' token.'
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2): DCNL 'Create an \'and_expr\' from two checks joined by the \'and\' DCNL operator.'
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check): DCNL 'Extend an \'and_expr\' by adding one more check.'
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2): DCNL 'Create an \'or_expr\' from two checks joined by the \'or\' DCNL operator.'
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check): DCNL 'Extend an \'or_expr\' by adding one more check.'
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check): DCNL 'Invert the result of another check.'
def __call__(self, target, creds): DCNL 'Recursively checks credentials based on the defined rules.'
def __call__(self, target, creds): DCNL 'Check that there is a matching role in the cred dict.'
def __call__(self, target, creds): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response DCNL is exactly \'True\'.'
def __call__(self, target, creds): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def __str__(self): DCNL 'Make the VersionInfo object behave like a string.'
def __repr__(self): DCNL 'Include the name.'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def authenticate(self, user_id=None, tenant_id=None, password=None): DCNL 'Authenticate a given user, tenant and password. DCNL :returns: (user_ref, tenant_ref, metadata_ref) DCNL :raises: AssertionError'
def get_project(self, tenant_id): DCNL 'Get a tenant by id. DCNL :returns: tenant_ref DCNL :raises: keystone.exception.ProjectNotFound'
def get_project_by_name(self, tenant_name, domain_id): DCNL 'Get a tenant by name. DCNL :returns: tenant_ref DCNL :raises: keystone.exception.ProjectNotFound'
def get_user_by_name(self, user_name, domain_id): DCNL 'Get a user by name. DCNL :returns: user_ref DCNL :raises: keystone.exception.UserNotFound'
def add_user_to_project(self, tenant_id, user_id): DCNL 'Add user to a tenant by creating a default role relationship. DCNL :raises: keystone.exception.ProjectNotFound, DCNL keystone.exception.UserNotFound'
def remove_user_from_project(self, tenant_id, user_id): DCNL 'Remove user from a tenant DCNL :raises: keystone.exception.ProjectNotFound, DCNL keystone.exception.UserNotFound'
def get_project_users(self, tenant_id): DCNL 'Lists all users with a relationship to the specified project. DCNL :returns: a list of user_refs or an empty set. DCNL :raises: keystone.exception.ProjectNotFound'
def get_projects_for_user(self, user_id): DCNL 'Get the tenants associated with a given user. DCNL :returns: a list of tenant_id\'s. DCNL :raises: keystone.exception.UserNotFound'
def get_roles_for_user_and_project(self, user_id, tenant_id): DCNL 'Get the roles associated with a user within given tenant. DCNL :returns: a list of role ids. DCNL :raises: keystone.exception.UserNotFound, DCNL keystone.exception.ProjectNotFound'
def get_roles_for_user_and_domain(self, user_id, domain_id): DCNL 'Get the roles associated with a user within given domain. DCNL :returns: a list of role ids. DCNL :raises: keystone.exception.UserNotFound, DCNL keystone.exception.ProjectNotFound'
def add_role_to_user_and_project(self, user_id, tenant_id, role_id): DCNL 'Add a role to a user within given tenant. DCNL :raises: keystone.exception.UserNotFound, DCNL keystone.exception.ProjectNotFound, DCNL keystone.exception.RoleNotFound'
def remove_role_from_user_and_project(self, user_id, tenant_id, role_id): DCNL 'Remove a role from a user within given tenant. DCNL :raises: keystone.exception.UserNotFound, DCNL keystone.exception.ProjectNotFound, DCNL keystone.exception.RoleNotFound'
def create_project(self, tenant_id, tenant): DCNL 'Creates a new tenant. DCNL :raises: keystone.exception.Conflict'
def update_project(self, tenant_id, tenant): DCNL 'Updates an existing tenant. DCNL :raises: keystone.exception.ProjectNotFound, DCNL keystone.exception.Conflict'
def delete_project(self, tenant_id): DCNL 'Deletes an existing tenant. DCNL :raises: keystone.exception.ProjectNotFound'
def get_metadata(self, user_id=None, tenant_id=None, domain_id=None, group_id=None): DCNL 'Gets the metadata for the specified user/group on project/domain. DCNL :raises: keystone.exception.MetadataNotFound DCNL :returns: metadata'
def create_metadata(self, user_id, tenant_id, metadata, domain_id=None, group_id=None): DCNL 'Creates the metadata for the specified user/group on project/domain. DCNL :returns: metadata created'
def update_metadata(self, user_id, tenant_id, metadata, domain_id=None, group_id=None): DCNL 'Updates the metadata for the specified user/group on project/domain. DCNL :returns: metadata updated'
def create_domain(self, domain_id, domain): DCNL 'Creates a new domain. DCNL :raises: keystone.exception.Conflict'
def list_domains(self): DCNL 'List all domains in the system. DCNL :returns: a list of domain_refs or an empty list.'
def get_domain(self, domain_id): DCNL 'Get a domain by ID. DCNL :returns: domain_ref DCNL :raises: keystone.exception.DomainNotFound'
def get_domain_by_name(self, domain_name): DCNL 'Get a domain by name. DCNL :returns: domain_ref DCNL :raises: keystone.exception.DomainNotFound'
def update_domain(self, domain_id, domain): DCNL 'Updates an existing domain. DCNL :raises: keystone.exception.DomainNotFound, DCNL keystone.exception.Conflict'
def delete_domain(self, domain_id): DCNL 'Deletes an existing domain. DCNL :raises: keystone.exception.DomainNotFound'
def create_project(self, project_id, project): DCNL 'Creates a new project. DCNL :raises: keystone.exception.Conflict'
def list_projects(self): DCNL 'List all projects in the system. DCNL :returns: a list of project_refs or an empty list.'
def list_user_projects(self, user_id): DCNL 'List all projects associated with a given user. DCNL :returns: a list of project_refs or an empty list.'
def get_project(self): DCNL 'Get a project by ID. DCNL :returns: user_ref DCNL :raises: keystone.exception.ProjectNotFound'
def update_project(self, project_id, project): DCNL 'Updates an existing project. DCNL :raises: keystone.exception.ProjectNotFound, DCNL keystone.exception.Conflict'
def delete_project(self, project_id): DCNL 'Deletes an existing project. DCNL :raises: keystone.exception.ProjectNotFound'
def create_user(self, user_id, user): DCNL 'Creates a new user. DCNL :raises: keystone.exception.Conflict'
def list_users(self): DCNL 'List all users in the system. DCNL :returns: a list of user_refs or an empty list.'
def list_users_in_group(self, group_id): DCNL 'List all users in a group. DCNL :returns: a list of user_refs or an empty list.'
def get_user(self, user_id): DCNL 'Get a user by ID. DCNL :returns: user_ref DCNL :raises: keystone.exception.UserNotFound'
def update_user(self, user_id, user): DCNL 'Updates an existing user. DCNL :raises: keystone.exception.UserNotFound, DCNL keystone.exception.Conflict'
def add_user_to_group(self, user_id, group_id): DCNL 'Adds a user to a group. DCNL :raises: keystone.exception.UserNotFound, DCNL keystone.exception.GroupNotFound'
def check_user_in_group(self, user_id, group_id): DCNL 'Checks if a user is a member of a group. DCNL :raises: keystone.exception.UserNotFound, DCNL keystone.exception.GroupNotFound'
def remove_user_from_group(self, user_id, group_id): DCNL 'Removes a user from a group. DCNL :raises: keystone.exception.NotFound'
def delete_user(self, user_id): DCNL 'Deletes an existing user. DCNL :raises: keystone.exception.UserNotFound'
def create_credential(self, credential_id, credential): DCNL 'Creates a new credential. DCNL :raises: keystone.exception.Conflict'
def list_credentials(self): DCNL 'List all credentials in the system. DCNL :returns: a list of credential_refs or an empty list.'
def get_credential(self, credential_id): DCNL 'Get a credential by ID. DCNL :returns: credential_ref DCNL :raises: keystone.exception.CredentialNotFound'
def update_credential(self, credential_id, credential): DCNL 'Updates an existing credential. DCNL :raises: keystone.exception.CredentialNotFound, DCNL keystone.exception.Conflict'
def delete_credential(self, credential_id): DCNL 'Deletes an existing credential. DCNL :raises: keystone.exception.CredentialNotFound'
def create_role(self, role_id, role): DCNL 'Creates a new role. DCNL :raises: keystone.exception.Conflict'
def list_roles(self): DCNL 'List all roles in the system. DCNL :returns: a list of role_refs or an empty list.'
def get_role(self, role_id): DCNL 'Get a role by ID. DCNL :returns: role_ref DCNL :raises: keystone.exception.RoleNotFound'
def update_role(self, role_id, role): DCNL 'Updates an existing role. DCNL :raises: keystone.exception.RoleNotFound, DCNL keystone.exception.Conflict'
def delete_role(self, role_id): DCNL 'Deletes an existing role. DCNL :raises: keystone.exception.RoleNotFound'
def create_group(self, group_id, group): DCNL 'Creates a new group. DCNL :raises: keystone.exception.Conflict'
def list_groups(self): DCNL 'List all groups in the system. DCNL :returns: a list of group_refs or an empty list.'
def list_groups_for_user(self, user_id): DCNL 'List all groups a user is in DCNL :returns: a list of group_refs or an empty list.'
def get_group(self, group_id): DCNL 'Get a group by ID. DCNL :returns: group_ref DCNL :raises: keystone.exception.GroupNotFound'
def update_group(self, group_id, group): DCNL 'Updates an existing group. DCNL :raises: keystone.exceptionGroupNotFound, DCNL keystone.exception.Conflict'
def delete_group(self, group_id): DCNL 'Deletes an existing group. DCNL :raises: keystone.exception.GroupNotFound'
def to_dict(self): DCNL 'Override parent to_dict() method with a simpler implementation. DCNL Grant tables don\'t have non-indexed \'extra\' attributes, so the DCNL parent implementation is not applicable.'
def _check_password(self, password, user_ref): DCNL 'Check the specified password against the data store. DCNL This is modeled on ldap/core.py.  The idea is to make it easier to DCNL subclass Identity so that you can still use it to store all the data, DCNL but use some other means to check the password. DCNL Note that we\'ll pass in the entire user_ref in case the subclass DCNL needs things like user_ref.get(\'name\') DCNL For further justification, please see the follow up suggestion at DCNL https://blueprints.launchpad.net/keystone/+spec/sql-identiy-pam'
def authenticate(self, user_id=None, tenant_id=None, password=None): DCNL 'Authenticate based on a user, tenant and password. DCNL Expects the user object to have a password field and the tenant to be DCNL in the list of tenants on the user.'
def authenticate(self, user_id=None, tenant_id=None, password=None): DCNL 'Authenticate based on a user, tenant and password. DCNL Expects the user object to have a password field and the tenant to be DCNL in the list of tenants on the user.'
def authenticate(self, user_id=None, tenant_id=None, password=None): DCNL 'Authenticate based on a user, tenant and password. DCNL Expects the user object to have a password field and the tenant to be DCNL in the list of tenants on the user.'
def get_user_projects(self, user_id): DCNL 'Returns list of tenants a user has access to'
def list_user_groups(self, user_id): DCNL 'Returns a list of groups a user has access to'
def list_group_users(self, group_id): DCNL 'Returns a list of users that belong to a group'
def get(self, id, filter=None): DCNL 'Replaces exception.NotFound with exception.DomainNotFound.'
def get_all_projects(self, context, **kw): DCNL 'Gets a list of all tenants for an admin user.'
def get_projects_for_token(self, context, **kw): DCNL 'Get valid tenants for token based on token used to authenticate. DCNL Pulls the token from the context, validates it and gets the valid DCNL tenants for the user in the token. DCNL Doesn\'t care about token scopedness.'
def update_user_project(self, context, user_id, user): DCNL 'Update the default tenant.'
def get_user_roles(self, context, user_id, tenant_id=None): DCNL 'Get the roles for a user and tenant pair. DCNL Since we\'re trying to ignore the idea of user-only roles we\'re DCNL not implementing them in hopes that the idea will die off.'
def add_role_to_user(self, context, user_id, role_id, tenant_id=None): DCNL 'Add a role to a user and tenant pair. DCNL Since we\'re trying to ignore the idea of user-only roles we\'re DCNL not implementing them in hopes that the idea will die off.'
def remove_role_from_user(self, context, user_id, role_id, tenant_id=None): DCNL 'Remove a role from a user and tenant pair. DCNL Since we\'re trying to ignore the idea of user-only roles we\'re DCNL not implementing them in hopes that the idea will die off.'
def get_role_refs(self, context, user_id): DCNL 'Ultimate hack to get around having to make role_refs first-class. DCNL This will basically iterate over the various roles the user has in DCNL all tenants the user is a member of and create fake role_refs where DCNL the id encodes the user-tenant-role information so we can look DCNL up the appropriate data when we need to delete them.'
def create_role_ref(self, context, user_id, role): DCNL 'This is actually used for adding a user to a tenant. DCNL In the legacy data model adding a user to a tenant required setting DCNL a role.'
def delete_role_ref(self, context, user_id, role_ref_id): DCNL 'This is actually used for deleting a user from a tenant. DCNL In the legacy data model removing a user from a tenant required DCNL deleting a role. DCNL To emulate this, we encode the tenant and role in the role_ref_id, DCNL and if this happens to be the last role for the user-tenant pair, DCNL we remove the user from the tenant.'
def _delete_domain_contents(self, context, domain_id): DCNL 'Delete the contents of a domain. DCNL Before we delete a domain, we need to remove all the entities DCNL that are owned by it, i.e. Users, Groups & Projects. To do this we DCNL call the respective delete functions for these entities, which are DCNL themselves responsible for deleting any credentials and role grants DCNL associated with them as well as revoking any relevant tokens. DCNL The order we delete entities is also important since some types DCNL of backend may need to maintain referential integrity DCNL throughout, and many of the entities have relationship with each DCNL other. The following deletion order is therefore used: DCNL Projects: Reference user and groups for grants DCNL Groups: Reference users for membership and domains for grants DCNL Users: Reference domains for grants'
def _get_domain_by_name(self, context, domain_name): DCNL 'Get the domain via its unique name. DCNL For use by token authentication - not for hooking to the identity DCNL router as a public api.'
@controller.protected DCNL def create_grant(self, context, role_id, user_id=None, group_id=None, domain_id=None, project_id=None): DCNL 'Grants a role to a user or group on either a domain or project.'
@controller.protected DCNL def list_grants(self, context, user_id=None, group_id=None, domain_id=None, project_id=None): DCNL 'Lists roles granted to user/group on either a domain or project.'
@controller.protected DCNL def check_grant(self, context, role_id, user_id=None, group_id=None, domain_id=None, project_id=None): DCNL 'Checks if a role has been granted on either a domain or project.'
@controller.protected DCNL def revoke_grant(self, context, role_id, user_id=None, group_id=None, domain_id=None, project_id=None): DCNL 'Revokes a role from user/group on either a domain or project.'
def create_service(self, service_id, service_ref): DCNL 'Creates a new service. DCNL :raises: keystone.exception.Conflict'
def list_services(self): DCNL 'List all services. DCNL :returns: list of service_refs or an empty list.'
def get_service(self, service_id): DCNL 'Get service by id. DCNL :returns: service_ref dict DCNL :raises: keystone.exception.ServiceNotFound'
def update_service(self, service_id): DCNL 'Update service by id. DCNL :returns: service_ref dict DCNL :raises: keystone.exception.ServiceNotFound'
def delete_service(self, service_id): DCNL 'Deletes an existing service. DCNL :raises: keystone.exception.ServiceNotFound'
def create_endpoint(self, endpoint_id, endpoint_ref): DCNL 'Creates a new endpoint for a service. DCNL :raises: keystone.exception.Conflict, DCNL keystone.exception.ServiceNotFound'
def get_endpoint(self, endpoint_id): DCNL 'Get endpoint by id. DCNL :returns: endpoint_ref dict DCNL :raises: keystone.exception.EndpointNotFound'
def list_endpoints(self): DCNL 'List all endpoints. DCNL :returns: list of endpoint_refs or an empty list.'
def update_endpoint(self, endpoint_id, endpoint_ref): DCNL 'Get endpoint by id. DCNL :returns: endpoint_ref dict DCNL :raises: keystone.exception.EndpointNotFound DCNL keystone.exception.ServiceNotFound'
def delete_endpoint(self, endpoint_id): DCNL 'Deletes an endpoint for a service. DCNL :raises: keystone.exception.EndpointNotFound'
def get_catalog(self, user_id, tenant_id, metadata=None): DCNL 'Retrieve and format the current service catalog. DCNL Example:: DCNL { \'RegionOne\': DCNL {\'compute\': { DCNL \'adminURL\': u\'http://host:8774/v1.1/tenantid\', DCNL \'internalURL\': u\'http://host:8774/v1.1/tenant_id\', DCNL \'name\': \'Compute Service\', DCNL \'publicURL\': u\'http://host:8774/v1.1/tenantid\'}, DCNL \'ec2\': { DCNL \'adminURL\': \'http://host:8773/services/Admin\', DCNL \'internalURL\': \'http://host:8773/services/Cloud\', DCNL \'name\': \'EC2 Service\', DCNL \'publicURL\': \'http://host:8773/services/Cloud\'}} DCNL :returns: A nested dict representing the service catalog or an DCNL empty dict. DCNL :raises: keystone.exception.NotFound'
def get_v3_catalog(self, user_id, tenant_id, metadata=None): DCNL 'Retrieve and format the current V3 service catalog. DCNL Example:: DCNL "endpoints": [ DCNL "interface": "public", DCNL "id": "--endpoint-id--", DCNL "region": "RegionOne", DCNL "url": "http://external:8776/v1/--project-id--" DCNL "interface": "internal", DCNL "id": "--endpoint-id--", DCNL "region": "RegionOne", DCNL "url": "http://internal:8776/v1/--project-id--" DCNL "id": "--service-id--", DCNL "type": "volume" DCNL :returns: A list representing the service catalog or an empty list DCNL :raises: keystone.exception.NotFound'
def get_endpoints(self, context): DCNL 'Merge matching v3 endpoint refs into legacy refs.'
def create_endpoint(self, context, endpoint): DCNL 'Create three v3 endpoint refs based on a legacy ref.'
def delete_endpoint(self, context, endpoint_id): DCNL 'Delete up to three v3 endpoint refs based on a legacy ref ID.'
def authenticate(self, context, auth_payload, auth_context): DCNL 'Authenticate user and return an authentication context. DCNL :param context: keystone\'s request context DCNL :auth_payload: the content of the authentication for a given method DCNL :auth_context: user authentication context, a dictionary shared DCNL by all plugins. It contains "method_names" and "extras" DCNL by default. "method_names" is a list and "extras" is DCNL a dictionary. DCNL If successful, plugin must set "user_id" in "auth_context". DCNL "method_name" is used to convey any additional authentication methods DCNL in case authentication is for re-scoping. For example, DCNL if the authentication is for re-scoping, plugin must append the DCNL previous method names into "method_names". Also, plugin may add DCNL any additional information into "extras". Anything in "extras" DCNL will be conveyed in the token\'s "extras" field. Here\'s an example of DCNL "auth_context" on successful authentication. DCNL {"user_id": "abc123", DCNL "methods": ["password", "token"], DCNL "extras": {}} DCNL Plugins are invoked in the order in which they are specified in the DCNL "methods" attribute of the "identity" object. DCNL For example, with the following authentication request, DCNL {"auth": { DCNL "identity": { DCNL "methods": ["custom-plugin", "password", "token"], DCNL "token": { DCNL "id": "sdfafasdfsfasfasdfds" DCNL "custom-plugin": { DCNL "custom-data": "sdfdfsfsfsdfsf" DCNL "password": { DCNL "user": { DCNL "id": "s23sfad1", DCNL "password": "secrete" DCNL plugins will be invoked in this order: DCNL 1. custom-plugin DCNL 2. password DCNL 3. token DCNL :returns: None if authentication is successful. DCNL Authentication payload in the form of a dictionary for the DCNL next authentication step if this is a multi step DCNL authentication. DCNL :raises: exception.Unauthorized for authentication failure'
def _validate_and_normalize_scope_data(self): DCNL 'Validate and normalize scope data'
def _validate_and_normalize_auth_data(self): DCNL 'Make sure "auth" is valid.'
def get_method_names(self): DCNL 'Returns the identity method names. DCNL :returns: list of auth method names'
def get_method_data(self, method): DCNL 'Get the auth method payload. DCNL :returns: auth method payload'
def get_scope(self): DCNL 'Get scope information. DCNL Verify and return the scoping information. DCNL :returns: (domain_id, project_id, trust_ref). DCNL If scope to a project, (None, project_id, None) DCNL will be returned. DCNL If scoped to a domain, (domain_id, None,None) DCNL will be returned. DCNL If scoped to a trust, (None, project_id, trust_ref), DCNL Will be returned, where the project_id comes from the DCNL trust definition. DCNL If unscoped, (None, None, None) will be returned.'
def set_scope(self, domain_id=None, project_id=None, trust=None): DCNL 'Set scope information.'
def authenticate_for_token(self, context, auth=None): DCNL 'Authenticate user and issue a token.'
def authenticate(self, context, auth_info, auth_context): DCNL 'Authenticate user.'
def authenticate(self, context, auth_payload, user_context): DCNL 'Try to authenticate against the identity backend.'
def authenticate(self, context, credentials=None, ec2Credentials=None): DCNL 'Validate a signed EC2 request and provide a token. DCNL Other services (such as Nova) use this **admin** call to determine DCNL if a request they signed received is from a valid user. DCNL If it is a valid signature, an openstack token that maps DCNL to the user/tenant is returned to the caller, along with DCNL all the other details returned from a normal token validation DCNL call. DCNL The returned token is useful for making calls to other DCNL OpenStack services within the context of the request. DCNL :param context: standard context DCNL :param credentials: dict of ec2 signature DCNL :param ec2Credentials: DEPRECATED dict of ec2 signature DCNL :returns: token: openstack token equivalent to access key along DCNL with the corresponding service catalog and roles'
def create_credential(self, context, user_id, tenant_id): DCNL 'Create a secret/access pair for use with ec2 style auth. DCNL Generates a new set of credentials that map the the user/tenant DCNL pair. DCNL :param context: standard context DCNL :param user_id: id of user DCNL :param tenant_id: id of tenant DCNL :returns: credential: dict of ec2 credential'
def get_credentials(self, context, user_id): DCNL 'List all credentials for a user. DCNL :param context: standard context DCNL :param user_id: id of user DCNL :returns: credentials: list of ec2 credential dicts'
def get_credential(self, context, user_id, credential_id): DCNL 'Retrieve a user\'s access/secret pair by the access key. DCNL Grab the full access/secret pair for a given access key. DCNL :param context: standard context DCNL :param user_id: id of user DCNL :param credential_id: access key for credentials DCNL :returns: credential: dict of ec2 credential'
def delete_credential(self, context, user_id, credential_id): DCNL 'Delete a user\'s access/secret pair. DCNL Used to revoke a user\'s access/secret pair DCNL :param context: standard context DCNL :param user_id: id of user DCNL :param credential_id: access key for credentials DCNL :returns: bool: success'
def _get_credentials(self, context, credential_id): DCNL 'Return credentials from an ID. DCNL :param context: standard context DCNL :param credential_id: id of credential DCNL :raises exception.Unauthorized: when credential id is invalid DCNL :returns: credential: dict of ec2 credential.'
def _assert_identity(self, context, user_id): DCNL 'Check that the provided token belongs to the user. DCNL :param context: standard context DCNL :param user_id: id of user DCNL :raises exception.Forbidden: when token is invalid'
def _is_admin(self, context): DCNL 'Wrap admin assertion error return statement. DCNL :param context: standard context DCNL :returns: bool: success'
def _assert_owner(self, context, user_id, credential_id): DCNL 'Ensure the provided user owns the credential. DCNL :param context: standard context DCNL :param user_id: expected credential owner DCNL :param credential_id: id of credential object DCNL :raises exception.Forbidden: on failure'
def _assert_valid_user_id(self, context, user_id): DCNL 'Ensure a valid user id. DCNL :param context: standard context DCNL :param user_id: expected credential owner DCNL :raises exception.UserNotFound: on failure'
def _assert_valid_project_id(self, context, tenant_id): DCNL 'Ensure a valid tenant id. DCNL :param context: standard context DCNL :param tenant_id: expected tenant DCNL :raises exception.ProjectNotFound: on failure'
def get_stats(self, api): DCNL 'Retrieve all previously-captured statistics for an interface.'
def set_stats(self, api, stats_ref): DCNL 'Update statistics for an interface.'
def increment_stat(self, api, category, value): DCNL 'Increment the counter for an individual statistic.'
def capture_stats(self, host, obj, attributes): DCNL 'Collect each attribute from the given object.'
def process_request(self, request): DCNL 'Monitor incoming request attributes.'
def process_response(self, request, response): DCNL 'Monitor outgoing response attributes.'
def increment_stat(self, api, category, value): DCNL 'Increment a statistic counter, or create it if it doesn\'t exist.'
def post_process(self): DCNL 'Any distribution-specific post-processing gets done here. DCNL In particular, this is useful for applying patches to code inside DCNL the venv.'
@contextlib.contextmanager DCNL def completion_cache(self, cache_type, obj_class, mode): DCNL 'The completion cache store items that can be used for bash DCNL autocompletion, like UUIDs or human-friendly IDs. DCNL A resource listing will clear and repopulate the cache. DCNL A resource create will append to the cache. DCNL Delete is not handled because listings are assumed to be performed DCNL often enough to keep the cache reasonably up-to-date.'
def find(self, **kwargs): DCNL 'Find a single item with attributes matching ``**kwargs``. DCNL This isn\'t very efficient: it loads the entire list then filters on DCNL the Python side.'
def findall(self, **kwargs): DCNL 'Find all items with attributes matching ``**kwargs``. DCNL This isn\'t very efficient: it loads the entire list then filters on DCNL the Python side.'
@property DCNL def human_id(self): DCNL 'Subclasses may override this provide a pretty ID which can be used DCNL for bash completion.'
def _choose_api_version(self): DCNL 'Determine the api version that we should use.'
def _remove_auth_headers(self, env): DCNL 'Remove headers so a user can\'t fake authentication. DCNL :param env: wsgi request environment'
def _get_user_token_from_header(self, env): DCNL 'Get token id from request. DCNL :param env: wsgi request environment DCNL :return token id DCNL :raises InvalidUserToken if no token is provided in request'
def _reject_request(self, env, start_response): DCNL 'Redirect client to auth server. DCNL :param env: wsgi request environment DCNL :param start_response: wsgi response callback DCNL :returns HTTPUnauthorized http response'
def get_admin_token(self): DCNL 'Return admin token, possibly fetching a new one. DCNL if self.admin_token_expiry is set from fetching an admin token, check DCNL it for expiration, and request a new token is the existing token DCNL is about to expire. DCNL :return admin token id DCNL :raise ServiceError when unable to retrieve token from monitor'
def _http_request(self, method, path, **kwargs): DCNL 'HTTP request helper used to make unspecified content type requests. DCNL :param method: http method DCNL :param path: relative request url DCNL :return (http response object, response body) DCNL :raise ServerError when unable to communicate with monitor'
def _json_request(self, method, path, body=None, additional_headers=None): DCNL 'HTTP request helper used to make json requests. DCNL :param method: http method DCNL :param path: relative request url DCNL :param body: dict to encode to json as request body. Optional. DCNL :param additional_headers: dict of additional headers to send with DCNL http request. Optional. DCNL :return (http response object, response body parsed as json) DCNL :raise ServerError when unable to communicate with monitor'
def _request_admin_token(self): DCNL 'Retrieve new token as admin user from monitor. DCNL :return token id upon success DCNL :raises ServerError when unable to communicate with monitor DCNL Irrespective of the auth version we are going to use for the DCNL user token, for simplicity we always use a v2 admin token to DCNL validate the user token.'
def _validate_user_token(self, user_token, retry=True): DCNL 'Authenticate user using PKI DCNL :param user_token: user\'s token id DCNL :param retry: Ignored, as it is not longer relevant DCNL :return uncrypted body of the token if the token is valid DCNL :raise InvalidUserToken if token is rejected DCNL :no longer raises ServiceError since it no longer makes RPC'
def _build_user_headers(self, token_info): DCNL 'Convert token object into headers. DCNL Build headers that represent authenticated user - see main DCNL doc info at start of file for details of headers to be defined. DCNL :param token_info: token object returned by monitor on authentication DCNL :raise InvalidUserToken when unable to parse token object'
def _header_to_env_var(self, key): DCNL 'Convert header to wsgi env variable. DCNL :param key: http header name (ex. \'X-Auth-Token\') DCNL :return wsgi env variable name (ex. \'HTTP_X_AUTH_TOKEN\')'
def _add_headers(self, env, headers): DCNL 'Add http headers to environment.'
def _remove_headers(self, env, keys): DCNL 'Remove http headers from environment.'
def _get_header(self, env, key, default=None): DCNL 'Get http header from environment.'
def _protect_cache_value(self, token, data): DCNL 'Encrypt or sign data if necessary.'
def _unprotect_cache_value(self, token, data): DCNL 'Decrypt or verify signed data if necessary.'
def _get_cache_key(self, token): DCNL 'Return the cache key. DCNL Do not use clear token as key if memcache protection is on.'
def _cache_get(self, token): DCNL 'Return token information from cache. DCNL If token is invalid raise InvalidUserToken DCNL return token only if fresh (not expired).'
def _cache_store(self, token, data, expires=None): DCNL 'Store value into memcache.'
def _cache_put(self, token, data, expires): DCNL 'Put token data into the cache. DCNL Stores the parsed expire date in cache allowing DCNL quick check of token freshness on retrieval.'
def _cache_store_invalid(self, token): DCNL 'Store invalid token in cache.'
def verify_uuid_token(self, user_token, retry=True): DCNL 'Authenticate user token with monitor. DCNL :param user_token: user\'s token id DCNL :param retry: flag that forces the middleware to retry DCNL user authentication when an indeterminate DCNL response is received. Optional. DCNL :return token object received from monitor on success DCNL :raise InvalidUserToken if token is rejected DCNL :raise ServiceError if unable to authenticate token'
def is_signed_token_revoked(self, signed_text): DCNL 'Indicate whether the token appears in the revocation list.'
def cms_verify(self, data): DCNL 'Verifies the signature of the provided data\'s IAW CMS syntax. DCNL If either of the certificate files are missing, fetch them and DCNL retry.'
def verify_signed_token(self, signed_text): DCNL 'Check that the token is unrevoked and has a valid signature.'
@token_revocation_list.setter DCNL def token_revocation_list(self, value): DCNL 'Save a revocation list to memory and to disk. DCNL :param value: A json-encoded revocation list'
def _extract_service_catalog(self, url, resp, body, extract_token=True): DCNL 'See what the auth service told us and process the response. DCNL We may get redirected to another site, fail or actually get DCNL back a service catalog with a token and our endpoints.'
def _fetch_endpoints_from_auth(self, url): DCNL 'We have a token, but don\'t know the final endpoint for DCNL the region. We have to go back to the auth service and DCNL ask again. This request requires an admin-level token DCNL to work. The proxy token supplied could be from a low-level enduser. DCNL We can\'t get this from the keystone service endpoint, we have to use DCNL the admin endpoint. DCNL This will overwrite our admin token with the user token.'
def _v2_auth(self, url): DCNL 'Authenticate against a v2.0 auth service.'
def _rax_auth(self, url): DCNL 'Authenticate against the Rackspace auth service.'
def _authenticate(self, url, body): DCNL 'Authenticate and extract the service catalog.'
def error(self, message): DCNL 'error(message: string) DCNL Prints a usage message incorporating the message to stderr and DCNL exits.'
def _run_extension_hooks(self, hook_type, *args, **kwargs): DCNL 'Run hooks for all registered extensions.'
def do_bash_completion(self, args): DCNL 'Print arguments for bash_completion. DCNL Prints all of the commands and options to stdout so that the DCNL monitor.bash_completion script doesn\'t have to hard code them.'
@utils.arg('command', metavar='<subcommand>', nargs='?', help='Display DCSP help DCSP for DCSP <subcommand>') DCNL def do_help(self, args): DCNL 'Display help about this program or one of its subcommands.'
def __init__(self, *args, **kwargs): DCNL 'Ignores the passed in args.'
def get(self, key): DCNL 'Retrieves the value for a key or None. DCNL this expunges expired keys during each get'
def set(self, key, value, time=0, min_compress_len=0): DCNL 'Sets the value for a key.'
def add(self, key, value, time=0, min_compress_len=0): DCNL 'Sets the value for a key if it doesn\'t exist.'
def incr(self, key, delta=1): DCNL 'Increments the value for a key.'
def delete(self, key, time=0): DCNL 'Deletes the value associated with a key.'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def __str__(self): DCNL 'Make the VersionInfo object behave like a string.'
def __repr__(self): DCNL 'Include the name.'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def restore(self, backup_id, monitor_id=None): DCNL 'Restore a backup to a monitor. DCNL :param backup_id: The ID of the backup to restore. DCNL :param monitor_id: The ID of the monitor to restore the backup to. DCNL :rtype: :class:`Restore`'
@property DCNL def id(self): DCNL 'QuotaClassSet does not have a \'id\' attribute but base.Resource DCNL needs it to self-refresh and QuotaSet is indexed by class_name'
def authenticate(self): DCNL 'Authenticate against the server. DCNL Normally this is called automatically when you first access the API, DCNL but you can call this method to force authentication right now. DCNL Returns on success; raises :exc:`exceptions.Unauthorized` if the DCNL credentials are wrong.'
def get_keys(self): DCNL 'Get extra specs from a monitor type. DCNL :param vol_type: The :class:`ServiceManageType` to get extra specs from'
def set_keys(self, metadata): DCNL 'Set extra specs on a monitor type. DCNL :param type : The :class:`ServiceManageType` to set extra spec on DCNL :param metadata: A dict of key/value pairs to be set'
def unset_keys(self, keys): DCNL 'Unset extra specs on a volue type. DCNL :param type_id: The :class:`ServiceManageType` to unset extra spec on DCNL :param keys: A list of keys to be unset'
def list(self): DCNL 'Get a list of all monitor types. DCNL :rtype: list of :class:`ServiceManageType`.'
def get(self, monitor_type): DCNL 'Get a specific monitor type. DCNL :param monitor_type: The ID of the :class:`ServiceManageType` to get. DCNL :rtype: :class:`ServiceManageType`'
def delete(self, monitor_type): DCNL 'Delete a specific monitor_type. DCNL :param monitor_type: The ID of the :class:`ServiceManageType` to get.'
def create(self, name): DCNL 'Create a monitor type. DCNL :param name: Descriptive name of the monitor type DCNL :rtype: :class:`ServiceManageType`'
def delete(self): DCNL 'Delete this monitor backup.'
def create(self, monitor_id, container=None, name=None, description=None): DCNL 'Create a monitor backup. DCNL :param monitor_id: The ID of the monitor to backup. DCNL :param container: The name of the backup service container. DCNL :param name: The name of the backup. DCNL :param description: The description of the backup. DCNL :rtype: :class:`ServiceManageBackup`'
def get(self, backup_id): DCNL 'Show details of a monitor backup. DCNL :param backup_id: The ID of the backup to display. DCNL :rtype: :class:`ServiceManageBackup`'
def list(self, detailed=True): DCNL 'Get a list of all monitor backups. DCNL :rtype: list of :class:`ServiceManageBackup`'
def delete(self, backup): DCNL 'Delete a monitor backup. DCNL :param backup: The :class:`ServiceManageBackup` to delete.'
def delete(self): DCNL 'Delete this snapshot.'
def update(self, **kwargs): DCNL 'Update the display_name or display_description for this snapshot.'
def create(self, monitor_id, force=False, display_name=None, display_description=None): DCNL 'Create a snapshot of the given monitor. DCNL :param monitor_id: The ID of the monitor to snapshot. DCNL :param force: If force is True, create a snapshot even if the monitor is DCNL attached to an instance. Default is False. DCNL :param display_name: Name of the snapshot DCNL :param display_description: Description of the snapshot DCNL :rtype: :class:`Snapshot`'
def get(self, snapshot_id): DCNL 'Get a snapshot. DCNL :param snapshot_id: The ID of the snapshot to get. DCNL :rtype: :class:`Snapshot`'
def list(self, detailed=True, search_opts=None): DCNL 'Get a list of all snapshots. DCNL :rtype: list of :class:`Snapshot`'
def delete(self, snapshot): DCNL 'Delete a snapshot. DCNL :param snapshot: The :class:`Snapshot` to delete.'
def update(self, snapshot, **kwargs): DCNL 'Update the display_name or display_description for a snapshot. DCNL :param snapshot: The :class:`Snapshot` to delete.'
@property DCNL def id(self): DCNL 'QuotaSet does not have a \'id\' attribute but base.Resource needs it DCNL to self-refresh and QuotaSet is indexed by tenant_id'
def delete(self): DCNL 'Delete this monitor.'
def update(self, **kwargs): DCNL 'Update the display_name or display_description for this monitor.'
def attach(self, instance_uuid, mountpoint): DCNL 'Set attachment metadata. DCNL :param instance_uuid: uuid of the attaching instance. DCNL :param mountpoint: mountpoint on the attaching instance.'
def detach(self): DCNL 'Clear attachment metadata.'
def reserve(self, monitor): DCNL 'Reserve this monitor.'
def unreserve(self, monitor): DCNL 'Unreserve this monitor.'
def begin_detaching(self, monitor): DCNL 'Begin detaching monitor.'
def roll_detaching(self, monitor): DCNL 'Roll detaching monitor.'
def initialize_connection(self, monitor, connector): DCNL 'Initialize a monitor connection. DCNL :param connector: connector dict from nova.'
def terminate_connection(self, monitor, connector): DCNL 'Terminate a monitor connection. DCNL :param connector: connector dict from nova.'
def set_metadata(self, monitor, metadata): DCNL 'Set or Append metadata to a monitor. DCNL :param type : The :class: `ServiceManage` to set metadata on DCNL :param metadata: A dict of key/value pairs to set'
def upload_to_image(self, force, image_name, container_format, disk_format): DCNL 'Upload a monitor to image service as an image.'
def force_delete(self): DCNL 'Delete the specified monitor ignoring its current state. DCNL :param monitor: The UUID of the monitor to force-delete.'
def create(self, size, snapshot_id=None, source_volid=None, display_name=None, display_description=None, monitor_type=None, user_id=None, project_id=None, availability_zone=None, metadata=None, imageRef=None): DCNL 'Create a monitor. DCNL :param size: Size of monitor in GB DCNL :param snapshot_id: ID of the snapshot DCNL :param display_name: Name of the monitor DCNL :param display_description: Description of the monitor DCNL :param monitor_type: Type of monitor DCNL :rtype: :class:`ServiceManage` DCNL :param user_id: User id derived from context DCNL :param project_id: Project id derived from context DCNL :param availability_zone: Availability Zone to use DCNL :param metadata: Optional metadata to set on monitor creation DCNL :param imageRef: reference to an image stored in glance DCNL :param source_volid: ID of source monitor to clone from'
def get(self, monitor_id): DCNL 'Get a monitor. DCNL :param monitor_id: The ID of the monitor to delete. DCNL :rtype: :class:`ServiceManage`'
def list(self, detailed=True, search_opts=None): DCNL 'Get a list of all monitors. DCNL :rtype: list of :class:`ServiceManage`'
def delete(self, monitor): DCNL 'Delete a monitor. DCNL :param monitor: The :class:`ServiceManage` to delete.'
def update(self, monitor, **kwargs): DCNL 'Update the display_name or display_description for a monitor. DCNL :param monitor: The :class:`ServiceManage` to delete.'
def _action(self, action, monitor, info=None, **kwargs): DCNL 'Perform a monitor "action."'
def host_status(self, req=None): DCNL 'Perform a monitor "action."'
def resource_info(self, req=None): DCNL 'Perform a monitor "action."'
def asm_settings(self, req=None): DCNL 'Perform a monitor "action."'
def asm_settings_update(self, req=None): DCNL 'Perform a monitor "action."'
def asm_start_host(self, req=None): DCNL 'Perform a monitor "action."'
def pas_host_select(self, req=None): DCNL 'Perform a pas "action."'
def attach(self, monitor, instance_uuid, mountpoint): DCNL 'Set attachment metadata. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to attach. DCNL :param instance_uuid: uuid of the attaching instance. DCNL :param mountpoint: mountpoint on the attaching instance.'
def detach(self, monitor): DCNL 'Clear attachment metadata. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to detach.'
def reserve(self, monitor): DCNL 'Reserve this monitor. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to reserve.'
def unreserve(self, monitor): DCNL 'Unreserve this monitor. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to unreserve.'
def begin_detaching(self, monitor): DCNL 'Begin detaching this monitor. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to detach.'
def roll_detaching(self, monitor): DCNL 'Roll detaching this monitor. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to roll detaching.'
def initialize_connection(self, monitor, connector): DCNL 'Initialize a monitor connection. DCNL :param monitor: The :class:`ServiceManage` (or its ID). DCNL :param connector: connector dict from nova.'
def terminate_connection(self, monitor, connector): DCNL 'Terminate a monitor connection. DCNL :param monitor: The :class:`ServiceManage` (or its ID). DCNL :param connector: connector dict from nova.'
def set_metadata(self, monitor, metadata): DCNL 'Update/Set a monitors metadata. DCNL :param monitor: The :class:`ServiceManage`. DCNL :param metadata: A list of keys to be set.'
def delete_metadata(self, monitor, keys): DCNL 'Delete specified keys from monitors metadata. DCNL :param monitor: The :class:`ServiceManage`. DCNL :param metadata: A list of keys to be removed.'
def upload_to_image(self, monitor, force, image_name, container_format, disk_format): DCNL 'Upload monitor to image service as image. DCNL :param monitor: The :class:`ServiceManage` to upload.'
def get(self): DCNL 'Get a specific extension. DCNL :rtype: :class:`Limits`'
def url_for(self, attr=None, filter_value=None, service_type=None, endpoint_type='publicURL', service_name=None, monitor_service_name=None): DCNL 'Fetch the public URL from the Compute service for DCNL a particular endpoint attribute. If none given, return DCNL the first. See tests for sample service catalog.'
def setUp(self): DCNL 'Run before each test.'
def setUp(self): DCNL 'Run before each test.'
def assert_called(self, method, url, body=None, pos=(-1), **kwargs): DCNL 'Assert than an API method was just called.'
def assert_called_anytime(self, method, url, body=None): DCNL 'Assert than an API method was called anytime in the test.'
@contextlib.contextmanager DCNL def completion_cache(self, cache_type, obj_class, mode): DCNL 'The completion cache store items that can be used for bash DCNL autocompletion, like UUIDs or human-friendly IDs. DCNL A resource listing will clear and repopulate the cache. DCNL A resource create will append to the cache. DCNL Delete is not handled because listings are assumed to be performed DCNL often enough to keep the cache reasonably up-to-date.'
def find(self, **kwargs): DCNL 'Find a single item with attributes matching ``**kwargs``. DCNL This isn\'t very efficient: it loads the entire list then filters on DCNL the Python side.'
def findall(self, **kwargs): DCNL 'Find all items with attributes matching ``**kwargs``. DCNL This isn\'t very efficient: it loads the entire list then filters on DCNL the Python side.'
@property DCNL def human_id(self): DCNL 'Subclasses may override this provide a pretty ID which can be used DCNL for bash completion.'
def _choose_api_version(self): DCNL 'Determine the api version that we should use.'
def _remove_auth_headers(self, env): DCNL 'Remove headers so a user can\'t fake authentication. DCNL :param env: wsgi request environment'
def _get_user_token_from_header(self, env): DCNL 'Get token id from request. DCNL :param env: wsgi request environment DCNL :return token id DCNL :raises InvalidUserToken if no token is provided in request'
def _reject_request(self, env, start_response): DCNL 'Redirect client to auth server. DCNL :param env: wsgi request environment DCNL :param start_response: wsgi response callback DCNL :returns HTTPUnauthorized http response'
def get_admin_token(self): DCNL 'Return admin token, possibly fetching a new one. DCNL if self.admin_token_expiry is set from fetching an admin token, check DCNL it for expiration, and request a new token is the existing token DCNL is about to expire. DCNL :return admin token id DCNL :raise ServiceError when unable to retrieve token from monitor'
def _http_request(self, method, path, **kwargs): DCNL 'HTTP request helper used to make unspecified content type requests. DCNL :param method: http method DCNL :param path: relative request url DCNL :return (http response object, response body) DCNL :raise ServerError when unable to communicate with monitor'
def _json_request(self, method, path, body=None, additional_headers=None): DCNL 'HTTP request helper used to make json requests. DCNL :param method: http method DCNL :param path: relative request url DCNL :param body: dict to encode to json as request body. Optional. DCNL :param additional_headers: dict of additional headers to send with DCNL http request. Optional. DCNL :return (http response object, response body parsed as json) DCNL :raise ServerError when unable to communicate with monitor'
def _request_admin_token(self): DCNL 'Retrieve new token as admin user from monitor. DCNL :return token id upon success DCNL :raises ServerError when unable to communicate with monitor DCNL Irrespective of the auth version we are going to use for the DCNL user token, for simplicity we always use a v2 admin token to DCNL validate the user token.'
def _validate_user_token(self, user_token, retry=True): DCNL 'Authenticate user using PKI DCNL :param user_token: user\'s token id DCNL :param retry: Ignored, as it is not longer relevant DCNL :return uncrypted body of the token if the token is valid DCNL :raise InvalidUserToken if token is rejected DCNL :no longer raises ServiceError since it no longer makes RPC'
def _build_user_headers(self, token_info): DCNL 'Convert token object into headers. DCNL Build headers that represent authenticated user - see main DCNL doc info at start of file for details of headers to be defined. DCNL :param token_info: token object returned by monitor on authentication DCNL :raise InvalidUserToken when unable to parse token object'
def _header_to_env_var(self, key): DCNL 'Convert header to wsgi env variable. DCNL :param key: http header name (ex. \'X-Auth-Token\') DCNL :return wsgi env variable name (ex. \'HTTP_X_AUTH_TOKEN\')'
def _add_headers(self, env, headers): DCNL 'Add http headers to environment.'
def _remove_headers(self, env, keys): DCNL 'Remove http headers from environment.'
def _get_header(self, env, key, default=None): DCNL 'Get http header from environment.'
def _protect_cache_value(self, token, data): DCNL 'Encrypt or sign data if necessary.'
def _unprotect_cache_value(self, token, data): DCNL 'Decrypt or verify signed data if necessary.'
def _get_cache_key(self, token): DCNL 'Return the cache key. DCNL Do not use clear token as key if memcache protection is on.'
def _cache_get(self, token): DCNL 'Return token information from cache. DCNL If token is invalid raise InvalidUserToken DCNL return token only if fresh (not expired).'
def _cache_store(self, token, data, expires=None): DCNL 'Store value into memcache.'
def _cache_put(self, token, data, expires): DCNL 'Put token data into the cache. DCNL Stores the parsed expire date in cache allowing DCNL quick check of token freshness on retrieval.'
def _cache_store_invalid(self, token): DCNL 'Store invalid token in cache.'
def verify_uuid_token(self, user_token, retry=True): DCNL 'Authenticate user token with monitor. DCNL :param user_token: user\'s token id DCNL :param retry: flag that forces the middleware to retry DCNL user authentication when an indeterminate DCNL response is received. Optional. DCNL :return token object received from monitor on success DCNL :raise InvalidUserToken if token is rejected DCNL :raise ServiceError if unable to authenticate token'
def is_signed_token_revoked(self, signed_text): DCNL 'Indicate whether the token appears in the revocation list.'
def cms_verify(self, data): DCNL 'Verifies the signature of the provided data\'s IAW CMS syntax. DCNL If either of the certificate files are missing, fetch them and DCNL retry.'
def verify_signed_token(self, signed_text): DCNL 'Check that the token is unrevoked and has a valid signature.'
@token_revocation_list.setter DCNL def token_revocation_list(self, value): DCNL 'Save a revocation list to memory and to disk. DCNL :param value: A json-encoded revocation list'
def _extract_service_catalog(self, url, resp, body, extract_token=True): DCNL 'See what the auth service told us and process the response. DCNL We may get redirected to another site, fail or actually get DCNL back a service catalog with a token and our endpoints.'
def _fetch_endpoints_from_auth(self, url): DCNL 'We have a token, but don\'t know the final endpoint for DCNL the region. We have to go back to the auth service and DCNL ask again. This request requires an admin-level token DCNL to work. The proxy token supplied could be from a low-level enduser. DCNL We can\'t get this from the keystone service endpoint, we have to use DCNL the admin endpoint. DCNL This will overwrite our admin token with the user token.'
def _v2_auth(self, url): DCNL 'Authenticate against a v2.0 auth service.'
def _rax_auth(self, url): DCNL 'Authenticate against the Rackspace auth service.'
def _authenticate(self, url, body): DCNL 'Authenticate and extract the service catalog.'
def error(self, message): DCNL 'error(message: string) DCNL Prints a usage message incorporating the message to stderr and DCNL exits.'
def _run_extension_hooks(self, hook_type, *args, **kwargs): DCNL 'Run hooks for all registered extensions.'
def do_bash_completion(self, args): DCNL 'Print arguments for bash_completion. DCNL Prints all of the commands and options to stdout so that the DCNL monitor.bash_completion script doesn\'t have to hard code them.'
@utils.arg('command', metavar='<subcommand>', nargs='?', help='Display DCSP help DCSP for DCSP <subcommand>') DCNL def do_help(self, args): DCNL 'Display help about this program or one of its subcommands.'
def __init__(self, *args, **kwargs): DCNL 'Ignores the passed in args.'
def get(self, key): DCNL 'Retrieves the value for a key or None. DCNL this expunges expired keys during each get'
def set(self, key, value, time=0, min_compress_len=0): DCNL 'Sets the value for a key.'
def add(self, key, value, time=0, min_compress_len=0): DCNL 'Sets the value for a key if it doesn\'t exist.'
def incr(self, key, delta=1): DCNL 'Increments the value for a key.'
def delete(self, key, time=0): DCNL 'Deletes the value associated with a key.'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def __str__(self): DCNL 'Make the VersionInfo object behave like a string.'
def __repr__(self): DCNL 'Include the name.'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def restore(self, backup_id, monitor_id=None): DCNL 'Restore a backup to a monitor. DCNL :param backup_id: The ID of the backup to restore. DCNL :param monitor_id: The ID of the monitor to restore the backup to. DCNL :rtype: :class:`Restore`'
@property DCNL def id(self): DCNL 'QuotaClassSet does not have a \'id\' attribute but base.Resource DCNL needs it to self-refresh and QuotaSet is indexed by class_name'
def authenticate(self): DCNL 'Authenticate against the server. DCNL Normally this is called automatically when you first access the API, DCNL but you can call this method to force authentication right now. DCNL Returns on success; raises :exc:`exceptions.Unauthorized` if the DCNL credentials are wrong.'
def get_keys(self): DCNL 'Get extra specs from a monitor type. DCNL :param vol_type: The :class:`ServiceManageType` to get extra specs from'
def set_keys(self, metadata): DCNL 'Set extra specs on a monitor type. DCNL :param type : The :class:`ServiceManageType` to set extra spec on DCNL :param metadata: A dict of key/value pairs to be set'
def unset_keys(self, keys): DCNL 'Unset extra specs on a volue type. DCNL :param type_id: The :class:`ServiceManageType` to unset extra spec on DCNL :param keys: A list of keys to be unset'
def list(self): DCNL 'Get a list of all monitor types. DCNL :rtype: list of :class:`ServiceManageType`.'
def get(self, monitor_type): DCNL 'Get a specific monitor type. DCNL :param monitor_type: The ID of the :class:`ServiceManageType` to get. DCNL :rtype: :class:`ServiceManageType`'
def delete(self, monitor_type): DCNL 'Delete a specific monitor_type. DCNL :param monitor_type: The ID of the :class:`ServiceManageType` to get.'
def create(self, name): DCNL 'Create a monitor type. DCNL :param name: Descriptive name of the monitor type DCNL :rtype: :class:`ServiceManageType`'
def delete(self): DCNL 'Delete this monitor backup.'
def create(self, monitor_id, container=None, name=None, description=None): DCNL 'Create a monitor backup. DCNL :param monitor_id: The ID of the monitor to backup. DCNL :param container: The name of the backup service container. DCNL :param name: The name of the backup. DCNL :param description: The description of the backup. DCNL :rtype: :class:`ServiceManageBackup`'
def get(self, backup_id): DCNL 'Show details of a monitor backup. DCNL :param backup_id: The ID of the backup to display. DCNL :rtype: :class:`ServiceManageBackup`'
def list(self, detailed=True): DCNL 'Get a list of all monitor backups. DCNL :rtype: list of :class:`ServiceManageBackup`'
def delete(self, backup): DCNL 'Delete a monitor backup. DCNL :param backup: The :class:`ServiceManageBackup` to delete.'
def delete(self): DCNL 'Delete this snapshot.'
def update(self, **kwargs): DCNL 'Update the display_name or display_description for this snapshot.'
def create(self, monitor_id, force=False, display_name=None, display_description=None): DCNL 'Create a snapshot of the given monitor. DCNL :param monitor_id: The ID of the monitor to snapshot. DCNL :param force: If force is True, create a snapshot even if the monitor is DCNL attached to an instance. Default is False. DCNL :param display_name: Name of the snapshot DCNL :param display_description: Description of the snapshot DCNL :rtype: :class:`Snapshot`'
def get(self, snapshot_id): DCNL 'Get a snapshot. DCNL :param snapshot_id: The ID of the snapshot to get. DCNL :rtype: :class:`Snapshot`'
def list(self, detailed=True, search_opts=None): DCNL 'Get a list of all snapshots. DCNL :rtype: list of :class:`Snapshot`'
def delete(self, snapshot): DCNL 'Delete a snapshot. DCNL :param snapshot: The :class:`Snapshot` to delete.'
def update(self, snapshot, **kwargs): DCNL 'Update the display_name or display_description for a snapshot. DCNL :param snapshot: The :class:`Snapshot` to delete.'
@property DCNL def id(self): DCNL 'QuotaSet does not have a \'id\' attribute but base.Resource needs it DCNL to self-refresh and QuotaSet is indexed by tenant_id'
def delete(self): DCNL 'Delete this monitor.'
def update(self, **kwargs): DCNL 'Update the display_name or display_description for this monitor.'
def attach(self, instance_uuid, mountpoint): DCNL 'Set attachment metadata. DCNL :param instance_uuid: uuid of the attaching instance. DCNL :param mountpoint: mountpoint on the attaching instance.'
def detach(self): DCNL 'Clear attachment metadata.'
def reserve(self, monitor): DCNL 'Reserve this monitor.'
def unreserve(self, monitor): DCNL 'Unreserve this monitor.'
def begin_detaching(self, monitor): DCNL 'Begin detaching monitor.'
def roll_detaching(self, monitor): DCNL 'Roll detaching monitor.'
def initialize_connection(self, monitor, connector): DCNL 'Initialize a monitor connection. DCNL :param connector: connector dict from nova.'
def terminate_connection(self, monitor, connector): DCNL 'Terminate a monitor connection. DCNL :param connector: connector dict from nova.'
def set_metadata(self, monitor, metadata): DCNL 'Set or Append metadata to a monitor. DCNL :param type : The :class: `ServiceManage` to set metadata on DCNL :param metadata: A dict of key/value pairs to set'
def upload_to_image(self, force, image_name, container_format, disk_format): DCNL 'Upload a monitor to image service as an image.'
def force_delete(self): DCNL 'Delete the specified monitor ignoring its current state. DCNL :param monitor: The UUID of the monitor to force-delete.'
def create(self, size, snapshot_id=None, source_volid=None, display_name=None, display_description=None, monitor_type=None, user_id=None, project_id=None, availability_zone=None, metadata=None, imageRef=None): DCNL 'Create a monitor. DCNL :param size: Size of monitor in GB DCNL :param snapshot_id: ID of the snapshot DCNL :param display_name: Name of the monitor DCNL :param display_description: Description of the monitor DCNL :param monitor_type: Type of monitor DCNL :rtype: :class:`ServiceManage` DCNL :param user_id: User id derived from context DCNL :param project_id: Project id derived from context DCNL :param availability_zone: Availability Zone to use DCNL :param metadata: Optional metadata to set on monitor creation DCNL :param imageRef: reference to an image stored in glance DCNL :param source_volid: ID of source monitor to clone from'
def get(self, monitor_id): DCNL 'Get a monitor. DCNL :param monitor_id: The ID of the monitor to delete. DCNL :rtype: :class:`ServiceManage`'
def list(self, detailed=True, search_opts=None): DCNL 'Get a list of all monitors. DCNL :rtype: list of :class:`ServiceManage`'
def delete(self, monitor): DCNL 'Delete a monitor. DCNL :param monitor: The :class:`ServiceManage` to delete.'
def update(self, monitor, **kwargs): DCNL 'Update the display_name or display_description for a monitor. DCNL :param monitor: The :class:`ServiceManage` to delete.'
def _action(self, action, monitor, info=None, **kwargs): DCNL 'Perform a monitor "action."'
def host_status(self, req=None): DCNL 'Perform a monitor "action."'
def test_service(self, req=None): DCNL 'Perform a monitor "action."'
def resource_info(self, req=None): DCNL 'Perform a monitor "action."'
def asm_settings(self, req=None): DCNL 'Perform a monitor "action."'
def asm_settings_update(self, req=None): DCNL 'Perform a monitor "action."'
def asm_start_host(self, req=None): DCNL 'Perform a monitor "action."'
def pas_host_select(self, req=None): DCNL 'Perform a pas "action."'
def attach(self, monitor, instance_uuid, mountpoint): DCNL 'Set attachment metadata. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to attach. DCNL :param instance_uuid: uuid of the attaching instance. DCNL :param mountpoint: mountpoint on the attaching instance.'
def detach(self, monitor): DCNL 'Clear attachment metadata. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to detach.'
def reserve(self, monitor): DCNL 'Reserve this monitor. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to reserve.'
def unreserve(self, monitor): DCNL 'Unreserve this monitor. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to unreserve.'
def begin_detaching(self, monitor): DCNL 'Begin detaching this monitor. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to detach.'
def roll_detaching(self, monitor): DCNL 'Roll detaching this monitor. DCNL :param monitor: The :class:`ServiceManage` (or its ID) DCNL you would like to roll detaching.'
def initialize_connection(self, monitor, connector): DCNL 'Initialize a monitor connection. DCNL :param monitor: The :class:`ServiceManage` (or its ID). DCNL :param connector: connector dict from nova.'
def terminate_connection(self, monitor, connector): DCNL 'Terminate a monitor connection. DCNL :param monitor: The :class:`ServiceManage` (or its ID). DCNL :param connector: connector dict from nova.'
def set_metadata(self, monitor, metadata): DCNL 'Update/Set a monitors metadata. DCNL :param monitor: The :class:`ServiceManage`. DCNL :param metadata: A list of keys to be set.'
def delete_metadata(self, monitor, keys): DCNL 'Delete specified keys from monitors metadata. DCNL :param monitor: The :class:`ServiceManage`. DCNL :param metadata: A list of keys to be removed.'
def upload_to_image(self, monitor, force, image_name, container_format, disk_format): DCNL 'Upload monitor to image service as image. DCNL :param monitor: The :class:`ServiceManage` to upload.'
def get(self): DCNL 'Get a specific extension. DCNL :rtype: :class:`Limits`'
def url_for(self, attr=None, filter_value=None, service_type=None, endpoint_type='publicURL', service_name=None, monitor_service_name=None): DCNL 'Fetch the public URL from the Compute service for DCNL a particular endpoint attribute. If none given, return DCNL the first. See tests for sample service catalog.'
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True): DCNL 'Runs a command in an out-of-process shell. DCNL Returns the output of that command. Working directory is self.root.'
def create_virtualenv(self, no_site_packages=True): DCNL 'Creates the virtual environment and installs PIP. DCNL Creates the virtual environment and installs PIP only into the DCNL virtual environment.'
def parse_args(self, argv): DCNL 'Parses command-line arguments.'
def post_process(self): DCNL 'Any distribution-specific post-processing gets done here. DCNL In particular, this is useful for applying patches to code inside DCNL the venv.'
def post_process(self): DCNL 'Workaround for a bug in eventlet. DCNL This currently affects RHEL6.1, but the fix can safely be DCNL applied to all RHEL and Fedora distributions. DCNL This can be removed when the fix is applied upstream. DCNL Nova: https://bugs.launchpad.net/nova/+bug/884915 DCNL Upstream: https://bitbucket.org/which_linden/eventlet/issue/89'
def __init__(self, data, limit): DCNL ':param data: Underlying data object DCNL :param limit: maximum number of bytes the reader should allow'
def __init__(self, ext_mgr): DCNL 'Register extension with the extension manager.'
def get_resources(self): DCNL 'List of extensions.ResourceExtension extension objects. DCNL Resources define new nouns, and are accessible through URLs.'
def get_controller_extensions(self): DCNL 'List of extensions.ControllerExtension extension objects. DCNL Controller extensions are used to extend existing controllers.'
@classmethod DCNL def nsmap(cls): DCNL 'Synthesize a namespace map from extension.'
@classmethod DCNL def xmlname(cls, name): DCNL 'Synthesize element and attribute names.'
def get_resources(self): DCNL 'Returns a list of ResourceExtension objects.'
def get_controller_extensions(self): DCNL 'Returns a list of ControllerExtension objects.'
def _check_extension(self, extension): DCNL 'Checks for required methods in extension objects.'
def load_extension(self, ext_factory): DCNL 'Execute an extension factory. DCNL Loads an extension.  The \'ext_factory\' is the name of a DCNL callable that will be imported and called with one DCNL argument--the extension manager.  The factory callable is DCNL expected to call the register() method at least once.'
def _load_extensions(self): DCNL 'Load extensions specified on the command line.'
def _get_next_link(self, request, identifier): DCNL 'Return href string with proper limit and marker params.'
def _get_href_link(self, request, identifier): DCNL 'Return an href string pointing to this object.'
def _get_bookmark_link(self, request, identifier): DCNL 'Create a URL that refers to a specific resource.'
def _get_collection_links(self, request, items, id_key='uuid'): DCNL 'Retrieve \'next\' link, if applicable.'
def extract_metadata(self, metadata_node): DCNL 'Marshal the metadata attribute of a parsed request'
def __init__(self): DCNL 'Initialize view builder.'
def summary_list(self, request, backups): DCNL 'Show a list of backups without many details.'
def detail_list(self, request, backups): DCNL 'Detailed view of a list of backups .'
def summary(self, request, backup): DCNL 'Generic, non-detailed view of a backup.'
def restore_summary(self, request, restore): DCNL 'Generic, non-detailed view of a restore.'
def detail(self, request, backup): DCNL 'Detailed view of a single backup.'
def _list_view(self, func, request, backups): DCNL 'Provide a view for a list of backups.'
def show(self, request, servicemanage_type, brief=False): DCNL 'Trim away extraneous servicemanage type attributes.'
def index(self, request, servicemanage_types): DCNL 'Index over trimmed servicemanage types'
def _build_absolute_limits(self, absolute_limits): DCNL 'Builder for absolute limits DCNL absolute_limits should be given as a dict of limits. DCNL For example: {"ram": 512, "gigabytes": 1024}.'
def __init__(self, base_url): DCNL ':param base_url: url of the root wsgi application'
def _build_links(self, version_data): DCNL 'Generate a container of links that refer to the provided version.'
def generate_href(self, path=None): DCNL 'Create an url that refers to a specific version_number.'
def __init__(self, *chain): DCNL 'Initialize the selector. DCNL Each argument is a subsequent index into the object.'
def __repr__(self): DCNL 'Return a representation of the selector.'
def __call__(self, obj, do_raise=False): DCNL 'Select a datum to operate on. DCNL Selects the relevant datum within the object. DCNL :param obj: The object from which to select the object. DCNL :param do_raise: If False (the default), return None if the DCNL indexed datum does not exist.  Otherwise, DCNL raise a KeyError.'
def __call__(self, obj, do_raise=False): DCNL 'Returns empty string if the selected value does not exist.'
def __init__(self, value): DCNL 'Initialize the selector. DCNL :param value: The value to return.'
def __repr__(self): DCNL 'Return a representation of the selector.'
def __call__(self, _obj, _do_raise=False): DCNL 'Select a datum to operate on. DCNL Returns a constant value.  Compatible with DCNL Selector.__call__().'
def __init__(self, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Initialize an element. DCNL Initializes an element in the template.  Keyword arguments DCNL specify attributes to be set on the element; values must be DCNL callables.  See TemplateElement.set() for more information. DCNL :param tag: The name of the tag to create. DCNL :param attrib: An optional dictionary of element attributes. DCNL :param selector: An optional callable taking an object and DCNL optional boolean do_raise indicator and DCNL returning the object bound to the element. DCNL :param subselector: An optional callable taking an object and DCNL optional boolean do_raise indicator and DCNL returning the object bound to the element. DCNL This is used to further refine the datum DCNL object returned by selector in the event DCNL that it is a list of objects.'
def __repr__(self): DCNL 'Return a representation of the template element.'
def __len__(self): DCNL 'Return the number of child elements.'
def __contains__(self, key): DCNL 'Determine whether a child node named by key exists.'
def __getitem__(self, idx): DCNL 'Retrieve a child node by index or name.'
def append(self, elem): DCNL 'Append a child to the element.'
def extend(self, elems): DCNL 'Append children to the element.'
def insert(self, idx, elem): DCNL 'Insert a child element at the given index.'
def remove(self, elem): DCNL 'Remove a child element.'
def get(self, key): DCNL 'Get an attribute. DCNL Returns a callable which performs datum selection. DCNL :param key: The name of the attribute to get.'
def set(self, key, value=None): DCNL 'Set an attribute. DCNL :param key: The name of the attribute to set. DCNL :param value: A callable taking an object and optional boolean DCNL do_raise indicator and returning the datum bound DCNL to the attribute.  If None, a Selector() will be DCNL constructed from the key.  If a string, a DCNL Selector() will be constructed from the string.'
def keys(self): DCNL 'Return the attribute names.'
def items(self): DCNL 'Return the attribute names and values.'
def unwrap(self): DCNL 'Unwraps a template to return a template element.'
def wrap(self): DCNL 'Wraps a template element to return a template.'
def apply(self, elem, obj): DCNL 'Apply text and attributes to an etree.Element. DCNL Applies the text and attribute instructions in the template DCNL element to an etree.Element instance. DCNL :param elem: An etree.Element instance. DCNL :param obj: The base object associated with this template DCNL element.'
def _render(self, parent, datum, patches, nsmap): DCNL 'Internal rendering. DCNL Renders the template node into an etree.Element object. DCNL Returns the etree.Element object. DCNL :param parent: The parent etree.Element instance. DCNL :param datum: The datum associated with this template element. DCNL :param patches: A list of other template elements that must DCNL also be applied. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the etree.Element instance.'
def render(self, parent, obj, patches=[], nsmap=None): DCNL 'Render an object. DCNL Renders an object against this template node.  Returns a list DCNL of two-item tuples, where the first item is an etree.Element DCNL instance and the second item is the datum associated with that DCNL instance. DCNL :param parent: The parent for the etree.Element instances. DCNL :param obj: The object to render this template element DCNL against. DCNL :param patches: A list of other template elements to apply DCNL when rendering this template element. DCNL :param nsmap: An optional namespace dictionary to attach to DCNL the etree.Element instances.'
def will_render(self, datum): DCNL 'Hook method. DCNL An overridable hook method to determine whether this template DCNL element will be rendered at all.  By default, returns False DCNL (inhibiting rendering) if the datum is None. DCNL :param datum: The datum associated with this template element.'
def _text_get(self): DCNL 'Template element text. DCNL Either None or a callable taking an object and optional DCNL boolean do_raise indicator and returning the datum bound to DCNL the text of the template element.'
def tree(self): DCNL 'Return string representation of the template tree. DCNL Returns a representation of the template rooted at this DCNL element as a string, suitable for inclusion in debug logs.'
def __init__(self, root, nsmap=None): DCNL 'Initialize a template. DCNL :param root: The root element of the template. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def _serialize(self, parent, obj, siblings, nsmap=None): DCNL 'Internal serialization. DCNL Recursive routine to build a tree of etree.Element instances DCNL from an object based on the template.  Returns the first DCNL etree.Element instance rendered, or None. DCNL :param parent: The parent etree.Element instance.  Can be DCNL None. DCNL :param obj: The object to render. DCNL :param siblings: The TemplateElement instances against which DCNL to render the object. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the etree.Element instance DCNL rendered.'
def serialize(self, obj, *args, **kwargs): DCNL 'Serialize an object. DCNL Serializes an object against the template.  Returns a string DCNL with the serialized XML.  Positional and keyword arguments are DCNL passed to etree.tostring(). DCNL :param obj: The object to serialize.'
def make_tree(self, obj): DCNL 'Create a tree. DCNL Serializes an object against the template.  Returns an Element DCNL node with appropriate children. DCNL :param obj: The object to serialize.'
def _siblings(self): DCNL 'Hook method for computing root siblings. DCNL An overridable hook method to return the siblings of the root DCNL element.  By default, this is the root element itself.'
def _nsmap(self): DCNL 'Hook method for computing the namespace dictionary. DCNL An overridable hook method to return the namespace dictionary.'
def unwrap(self): DCNL 'Unwraps a template to return a template element.'
def wrap(self): DCNL 'Wraps a template element to return a template.'
def apply(self, master): DCNL 'Hook method for determining slave applicability. DCNL An overridable hook method used to determine if this template DCNL is applicable as a slave to a given master template. DCNL :param master: The master template to test.'
def tree(self): DCNL 'Return string representation of the template tree. DCNL Returns a representation of the template as a string, suitable DCNL for inclusion in debug logs.'
def __init__(self, root, version, nsmap=None): DCNL 'Initialize a master template. DCNL :param root: The root element of the template. DCNL :param version: The version number of the template. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def __repr__(self): DCNL 'Return string representation of the template.'
def _siblings(self): DCNL 'Hook method for computing root siblings. DCNL An overridable hook method to return the siblings of the root DCNL element.  This is the root element plus the root elements of DCNL all the slave templates.'
def _nsmap(self): DCNL 'Hook method for computing the namespace dictionary. DCNL An overridable hook method to return the namespace dictionary. DCNL The namespace dictionary is computed by taking the master DCNL template\'s namespace dictionary and updating it from all the DCNL slave templates.'
def attach(self, *slaves): DCNL 'Attach one or more slave templates. DCNL Attaches one or more slave templates to the master template. DCNL Slave templates must have a root element with the same tag as DCNL the master template.  The slave template\'s apply() method will DCNL be called to determine if the slave should be applied to this DCNL master; if it returns False, that slave will be skipped. DCNL (This allows filtering of slaves based on the version of the DCNL master template.)'
def copy(self): DCNL 'Return a copy of this master template.'
def __init__(self, root, min_vers, max_vers=None, nsmap=None): DCNL 'Initialize a slave template. DCNL :param root: The root element of the template. DCNL :param min_vers: The minimum permissible version of the master DCNL template for this slave template to apply. DCNL :param max_vers: An optional upper bound for the master DCNL template version. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def __repr__(self): DCNL 'Return string representation of the template.'
def apply(self, master): DCNL 'Hook method for determining slave applicability. DCNL An overridable hook method used to determine if this template DCNL is applicable as a slave to a given master template.  This DCNL version requires the master template to have a version number DCNL between min_vers and max_vers. DCNL :param master: The master template to test.'
def __new__(cls, copy=True): DCNL 'Construct and return a template. DCNL :param copy: If True (the default), a copy of the template DCNL will be constructed and returned, if possible.'
def construct(self): DCNL 'Construct a template. DCNL Called to construct a template instance, which it must return. DCNL Only called once.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Simple paste factory, :class:`monitor.wsgi.Router` doesn\'t have'
def best_match_content_type(self): DCNL 'Determine the requested response content-type.'
def get_content_type(self): DCNL 'Determine content type of the request body. DCNL Does not do any body introspection, only checks header'
def dispatch(self, *args, **kwargs): DCNL 'Find and call local method.'
def __init__(self, metadata=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary.'
def _from_xml_node(self, node, listnames): DCNL 'Convert a minidom node to a simple Python type. DCNL :param listnames: list of XML node names whose subnodes should DCNL be considered list items.'
def find_first_child_named(self, parent, name): DCNL 'Search a nodes children for the first child with a given name'
def find_children_named(self, parent, name): DCNL 'Return all of a nodes children who have the given name'
def extract_text(self, node): DCNL 'Get the text field contained by the given node'
def find_attribute_or_element(self, parent, name): DCNL 'Get an attribute value; fallback to an element if not found'
def extract_metadata(self, metadata_node): DCNL 'Marshal the metadata attribute of a parsed request'
def __init__(self, metadata=None, xmlns=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary. DCNL :param xmlns: XML namespace to include with serialized xml'
def _to_xml_node(self, doc, metadata, nodename, data): DCNL 'Recursive method to convert data members to XML nodes.'
def _to_xml(self, root): DCNL 'Convert the xml object to an xml string.'
def __init__(self, obj, code=None, **serializers): DCNL 'Binds serializers with an object. DCNL Takes keyword arguments akin to the @serializer() decorator DCNL for specifying serializers.  Serializers specified will be DCNL given preference over default serializers or method-specific DCNL serializers on return.'
def __getitem__(self, key): DCNL 'Retrieves a header with the given name.'
def __setitem__(self, key, value): DCNL 'Sets a header with the given name to the given value.'
def __delitem__(self, key): DCNL 'Deletes the header with the given name.'
def _bind_method_serializers(self, meth_serializers): DCNL 'Binds method serializers with the response object. DCNL Binds the method serializers with the response object. DCNL Serializers specified to the constructor will take precedence DCNL over serializers specified to this method. DCNL :param meth_serializers: A dictionary with keys mapping to DCNL response types and values containing DCNL serializer objects.'
def get_serializer(self, content_type, default_serializers=None): DCNL 'Returns the serializer for the wrapped object. DCNL Returns the serializer for the wrapped object subject to the DCNL indicated content type.  If no serializer matching the content DCNL type is attached, an appropriate serializer drawn from the DCNL default serializers will be used.  If no appropriate DCNL serializer is available, raises InvalidContentType.'
def preserialize(self, content_type, default_serializers=None): DCNL 'Prepares the serializer that will be used to serialize. DCNL Determines the serializer that will be used and prepares an DCNL instance of it for later call.  This allows the serializer to DCNL be accessed by extensions for, e.g., template extension.'
def attach(self, **kwargs): DCNL 'Attach slave templates to serializers.'
def serialize(self, request, content_type, default_serializers=None): DCNL 'Serializes the wrapped object. DCNL Utility method for serializing the wrapped object.  Returns a DCNL webob.Response object.'
@property DCNL def code(self): DCNL 'Retrieve the response status.'
@property DCNL def headers(self): DCNL 'Retrieve the headers.'
def __init__(self, controller, action_peek=None, **deserializers): DCNL ':param controller: object that implement methods created by routes lib DCNL :param action_peek: dictionary of routines for peeking into an action DCNL request body to determine the desired action'
def register_actions(self, controller): DCNL 'Registers controller actions with this resource.'
def register_extensions(self, controller): DCNL 'Registers controller extensions with this resource.'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'WSGI method that controls (de)serialization and method dispatch.'
def _process_stack(self, request, action, action_args, content_type, body, accept): DCNL 'Implement the processing stack.'
def get_method(self, request, action, content_type, body): DCNL 'Look up the action-specific method and its extensions.'
def dispatch(self, method, request, action_args): DCNL 'Dispatch a call to the action-specific method.'
def __new__(mcs, name, bases, cls_dict): DCNL 'Adds the wsgi_actions dictionary to the class.'
def __init__(self, view_builder=None): DCNL 'Initialize controller with a view builder instance.'
def __init__(self, exception): DCNL 'Create a Fault for the given webob.exc.exception.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Generate a WSGI response based on the exception passed to ctor.'
def __init__(self, message, details, retry_time): DCNL 'Initialize new `OverLimitFault` with relevant information.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'Return the wrapped exception with a serialized body conforming to our DCNL error format.'
@wsgi.serializers(xml=ServiceManageTypesTemplate) DCNL def index(self, req): DCNL 'Returns the list of servicemanage types.'
@wsgi.serializers(xml=ServiceManageTypeTemplate) DCNL def show(self, req, id): DCNL 'Return a single servicemanage type item.'
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req): DCNL 'Return all global and rate limit information.'
def __init__(self, verb, uri, regex, value, unit): DCNL 'Initialize a new `Limit`. DCNL @param verb: HTTP verb (POST, PUT, etc.) DCNL @param uri: Human-readable URI DCNL @param regex: Regular expression format for this limit DCNL @param value: Integer number of requests which can be made DCNL @param unit: Unit of measure for the value parameter'
def __call__(self, verb, url): DCNL 'Represents a call to this limit from a relevant request. DCNL @param verb: string http verb (POST, GET, etc.) DCNL @param url: string URL'
def _get_time(self): DCNL 'Retrieve the current time. Broken out for testability.'
def display_unit(self): DCNL 'Display the string name of the unit.'
def display(self): DCNL 'Return a useful representation of this class.'
def __init__(self, application, limits=None, limiter=None, **kwargs): DCNL 'Initialize new `RateLimitingMiddleware`, which wraps the given WSGI DCNL application and sets up the given limits. DCNL @param application: WSGI application to wrap DCNL @param limits: String describing limits DCNL @param limiter: String identifying class for representing limits DCNL Other parameters are passed to the constructor for the limiter.'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req): DCNL 'Represents a single call through this middleware. We should record the DCNL request if we have a limit relevant to it. If no limit is relevant to DCNL the request, ignore it. DCNL If the request should be rate limited, return a fault telling the user DCNL they are over the limit and need to retry later.'
def __init__(self, limits, **kwargs): DCNL 'Initialize the new `Limiter`. DCNL @param limits: List of `Limit` objects'
def get_limits(self, username=None): DCNL 'Return the limits for a given user.'
def check_for_delay(self, verb, url, username=None): DCNL 'Check the given verb/user/user triplet for limit. DCNL @return: Tuple of delay (in seconds) and error message (or None, None)'
@staticmethod DCNL def parse_limits(limits): DCNL 'Convert a string into a list of Limit instances.  This DCNL implementation expects a semicolon-separated sequence of DCNL parenthesized groups, where each group contains a DCNL comma-separated sequence consisting of HTTP method, DCNL user-readable URI, a URI reg-exp, an integer number of DCNL requests which can be made, and a unit of measure.  Valid DCNL values for the latter are "SECOND", "MINUTE", "HOUR", and DCNL "DAY". DCNL @return: List of Limit instances.'
def __init__(self, limits=None): DCNL 'Initialize the new `WsgiLimiter`. DCNL @param limits: List of `Limit` objects'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request): DCNL 'Handles a call to this application. Returns 204 if the request is DCNL acceptable to the limiter, else a 403 is returned with a relevant DCNL header indicating when the request *will* succeed.'
def __init__(self, limiter_address): DCNL 'Initialize the new `WsgiLimiterProxy`. DCNL @param limiter_address: IP/port combination of where to request limit'
@staticmethod DCNL def parse_limits(limits): DCNL 'Ignore a limits string--simply doesn\'t apply for the limit DCNL proxy. DCNL @return: Empty list.'
def content_type_params(self, best_content_type): DCNL 'Find parameters in Accept header for given content type.'
def _match(self, host, port, path_info): DCNL 'Find longest match for a given URL path.'
def _path_strategy(self, host, port, path_info): DCNL 'Check path suffix for MIME type and path prefix for API version.'
def _content_type_strategy(self, host, port, environ): DCNL 'Check Content-Type header for API version.'
def _accept_strategy(self, host, port, environ, supported_content_types): DCNL 'Check Accept header for best matching MIME type and API version.'
def _set_enabled_status(self, req, host, enabled): DCNL 'Sets the specified host\'s ability to accept new servicemanages.'
@wsgi.serializers(xml=HostShowTemplate) DCNL def show(self, req, id): DCNL 'Shows the servicemanage usage info given by hosts. DCNL :param context: security context DCNL :param host: hostname DCNL :returns: expected to use HostShowTemplate. DCNL ex.:: DCNL {\'host\': {\'resource\':D},..} DCNL D: {\'host\': \'hostname\',\'project\': \'admin\', DCNL \'servicemanage_count\': 1, \'total_servicemanage_gb\': 2048}'
@wsgi.serializers(xml=ServiceManageTypeExtraSpecsTemplate) DCNL def index(self, req, type_id): DCNL 'Returns the list of extra specs for a given servicemanage type'
@wsgi.serializers(xml=ServiceManageTypeExtraSpecTemplate) DCNL def show(self, req, type_id, id): DCNL 'Return a single extra spec item.'
def delete(self, req, type_id, id): DCNL 'Deletes an existing extra spec'
def _format_quota_set(self, quota_class, quota_set): DCNL 'Convert the quota object to a result dict'
@wsgi.serializers(xml=ServicesIndexTemplate) DCNL def index(self, req): DCNL 'Return a list of all running services. Filter by host & service name.'
@wsgi.serializers(xml=ServicesUpdateTemplate) DCNL def update(self, req, id, body): DCNL 'Enable/Disable scheduling for a service'
def _format_quota_set(self, project_id, quota_set): DCNL 'Convert the quota object to a result dict'
@wsgi.serializers(xml=BackupTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given backup.'
def delete(self, req, id): DCNL 'Delete a backup.'
@wsgi.serializers(xml=BackupsTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of backups.'
@wsgi.serializers(xml=BackupsTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of backups.'
def _get_backups(self, req, is_detail): DCNL 'Returns a list of backups, transformed through view builder.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body): DCNL 'Create a new backup.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupRestoreTemplate) DCNL @wsgi.deserializers(xml=RestoreDeserializer) DCNL def restore(self, req, id, body): DCNL 'Restore an existing backup to a servicemanage.'
@wsgi.action('create') DCNL @wsgi.serializers(xml=types.ServiceManageTypeTemplate) DCNL def _create(self, req, body): DCNL 'Creates a new servicemanage type.'
@wsgi.action('delete') DCNL def _delete(self, req, id): DCNL 'Deletes an existing servicemanage type.'
@wsgi.action('os-attach') DCNL def _attach(self, req, id, body): DCNL 'Add attachment metadata.'
@wsgi.action('os-detach') DCNL def _detach(self, req, id, body): DCNL 'Clear attachment metadata.'
@wsgi.action('os-reserve') DCNL def _reserve(self, req, id, body): DCNL 'Mark servicemanage as reserved.'
@wsgi.action('os-unreserve') DCNL def _unreserve(self, req, id, body): DCNL 'Unmark servicemanage as reserved.'
@wsgi.action('os-begin_detaching') DCNL def _begin_detaching(self, req, id, body): DCNL 'Update servicemanage status to \'detaching\'.'
@wsgi.action('os-roll_detaching') DCNL def _roll_detaching(self, req, id, body): DCNL 'Roll back servicemanage status to \'in-use\'.'
@wsgi.action('os-initialize_connection') DCNL def _initialize_connection(self, req, id, body): DCNL 'Initialize servicemanage attachment.'
@wsgi.action('os-terminate_connection') DCNL def _terminate_connection(self, req, id, body): DCNL 'Terminate servicemanage attachment.'
@wsgi.response(202) DCNL @wsgi.action('os-servicemanage_upload_image') DCNL @wsgi.serializers(xml=ServiceManageToImageSerializer) DCNL @wsgi.deserializers(xml=ServiceManageToImageDeserializer) DCNL def _servicemanage_upload_image(self, req, id, body): DCNL 'Uploads the specified servicemanage to image service.'
@wsgi.action('os-reset_status') DCNL def _reset_status(self, req, id, body): DCNL 'Reset status on the resource.'
@wsgi.action('os-force_delete') DCNL def _force_delete(self, req, id, body): DCNL 'Delete a resource, bypassing the check that it must be available.'
@wsgi.action('os-force_detach') DCNL def _force_detach(self, req, id, body): DCNL 'Roll back a bad detach after the servicemanage been disconnected from DCNL the hypervisor.'
@wsgi.serializers(xml=VersionsTemplate, atom=VersionsAtomSerializer) DCNL def index(self, req): DCNL 'Return all versions.'
@wsgi.serializers(xml=ChoicesTemplate) DCNL @wsgi.response(300) DCNL def multi(self, req): DCNL 'Return multiple choices.'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
def save(self, session=None): DCNL 'Save this object.'
def delete(self, session=None): DCNL 'Delete this object.'
def update(self, values): DCNL 'Make the model object behave like a dict.'
def iteritems(self): DCNL 'Make the model object behave like a dict. DCNL Includes attributes from joins.'
def get(self): DCNL 'Return an item from the pool, when one is available.  This may DCNL cause the calling greenthread to block. Check if a connection is active DCNL before returning it. For dead connections create and return a new DCNL connection.'
def __init__(self, retvalue=True): DCNL ':param retvalue: Value that LoopingCall.wait() should return.'
def rollback_and_reraise(self, msg=None, **kwargs): DCNL 'Rollback a series of actions then re-raise the exception. DCNL .. note:: (sirp) This should only be called within an DCNL exception handler.'
def __init__(self): DCNL 'Initialize the service launcher. DCNL :returns: None'
@staticmethod DCNL def run_server(server): DCNL 'Start and wait for a server to finish. DCNL :param service: Server to run and wait for. DCNL :returns: None'
def launch_server(self, server): DCNL 'Load and start the given server. DCNL :param server: The server you would like to start. DCNL :returns: None'
def stop(self): DCNL 'Stop all services which are currently running. DCNL :returns: None'
def wait(self): DCNL 'Waits until all services have been stopped, and then returns. DCNL :returns: None'
def wait(self): DCNL 'Loop waiting on children to die and respawning as necessary.'
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_interval=None, periodic_fuzzy_delay=None, service_name=None): DCNL 'Instantiates class and passes back application object. DCNL :param host: defaults to FLAGS.host DCNL :param binary: defaults to basename of executable DCNL :param topic: defaults to bin_name - \'monitor-\' part DCNL :param manager: defaults to FLAGS.<topic>_manager DCNL :param report_interval: defaults to FLAGS.report_interval DCNL :param periodic_interval: defaults to FLAGS.periodic_interval DCNL :param periodic_fuzzy_delay: defaults to FLAGS.periodic_fuzzy_delay'
def kill(self): DCNL 'Destroy the service object in the datastore.'
def periodic_tasks(self, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def report_state(self): DCNL 'Update the state of this service in the datastore.'
def __init__(self, name, loader=None): DCNL 'Initialize, but do not start the WSGI server. DCNL :param name: The name of the WSGI server given to the loader. DCNL :param loader: Loads the WSGI application using the given name. DCNL :returns: None'
def _get_manager(self): DCNL 'Initialize a Manager object appropriate for this service. DCNL Use the service name to look up a Manager subclass from the DCNL configuration and initialize an instance. If no class name DCNL is configured, just return None. DCNL :returns: a Manager instance, or None.'
def start(self): DCNL 'Start serving this service using loaded configuration. DCNL Also, retrieve updated port number in case \'0\' was passed in, which DCNL indicates a random port should be used. DCNL :returns: None'
def stop(self): DCNL 'Stop serving this API. DCNL :returns: None'
def wait(self): DCNL 'Wait for the service to stop serving this API. DCNL :returns: None'
def format(self, record): DCNL 'Uses contextstring if request_id is set, otherwise default.'
def formatException(self, exc_info, record=None): DCNL 'Format exception output with CONF.logging_exception_prefix.'
def __init__(self, topic, default_version): DCNL 'Initialize an RpcProxy. DCNL :param topic: The topic to use for all messages. DCNL :param default_version: The default API version to request in all DCNL outgoing messages.  This can be overridden on a per-message DCNL basis.'
def _set_version(self, msg, vers): DCNL 'Helper method to set the version in a message. DCNL :param msg: The message having a version added to it. DCNL :param vers: The version number to add to the message.'
def _get_topic(self, topic): DCNL 'Return the topic to use for a message.'
def call(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.call() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: The return value from the remote method.'
def multicall(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.multicall() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: An iterator that lets you process each of the returned values DCNL from the remote method as they arrive.'
def cast(self, context, msg, topic=None, version=None): DCNL 'rpc.cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast() does not wait on any return value from the DCNL remote method.'
def fanout_cast(self, context, msg, topic=None, version=None): DCNL 'rpc.fanout_cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast() does not wait on any return value DCNL from the remote method.'
def cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast_to_server() does not wait on any DCNL return values.'
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.fanout_cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast_to_server() does not wait on any DCNL return values.'
def __init__(self, conf, connection_pool, pooled=True, server_params=None): DCNL 'Create a new connection, or get one from the pool'
def __enter__(self): DCNL 'When with ConnectionContext() is used, return self'
def _done(self): DCNL 'If the connection came from a pool, clean it up and put it back. DCNL If it did not come from a pool, close it.'
def __exit__(self, exc_type, exc_value, tb): DCNL 'End of \'with\' statement.  We\'re done here.'
def __del__(self): DCNL 'Caller is done with this connection.  Make sure we cleaned up.'
def close(self): DCNL 'Caller is done with this connection.'
def __getattr__(self, key): DCNL 'Proxy all other calls to the Connection instance'
def check_duplicate_message(self, message_data): DCNL 'AMQP consumers may read same message twice when exceptions occur DCNL before ack is returned. This method prevents doing it.'
def wait(self): DCNL 'Wait for all callback threads to exit.'
def __init__(self, conf, callback, connection_pool): DCNL ':param conf: cfg.CONF instance DCNL :param callback: a callable (probably a function) DCNL :param connection_pool: connection pool as returned by DCNL get_connection_pool()'
def __call__(self, message_data): DCNL 'Consumer callback to call a method on a proxy object. DCNL Parses the message for validity and fires off a thread to call the DCNL proxy object method. DCNL Message data should be a dictionary with two keys: DCNL method: string representing the method to call DCNL args: dictionary of arg: value DCNL Example: {\'method\': \'echo\', \'args\': {\'value\': 42}}'
def _process_data(self, ctxt, version, method, args): DCNL 'Process a message in a new thread. DCNL If the proxy object we have has a dispatch method DCNL (see rpc.dispatcher.RpcDispatcher), pass it the version, DCNL method, and args and let it dispatch as appropriate.  If not, use DCNL the old behavior of magically calling the specified method on the DCNL proxy we have here.'
def __iter__(self): DCNL 'Return a result until we get a reply with an \'ending" flag'
def __call__(self, data): DCNL 'The consume() callback will call this.  Store the result.'
def __iter__(self): DCNL 'Return a result until we get a \'None\' response from consumer'
def __init__(self, callbacks): DCNL 'Initialize the rpc dispatcher. DCNL :param callbacks: List of proxy objects that are an instance DCNL of a class with rpc methods exposed.  Each proxy DCNL object should have an RPC_API_VERSION attribute.'
def dispatch(self, ctxt, version, method, **kwargs): DCNL 'Dispatch a message based on a requested version. DCNL :param ctxt: The request context DCNL :param version: The requested API version from the incoming message DCNL :param method: The method requested to be called by the incoming DCNL message. DCNL :param kwargs: A dict of keyword arguments to be passed to the method. DCNL :returns: Whatever is returned by the underlying method that gets DCNL called.'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a key.host is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def is_alive(self, topic, host): DCNL 'Checks if a host is alive.'
def expire(self, topic, host): DCNL 'Explicitly expire a host\'s registration.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Spawn heartbeat greenthread.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a host.topic is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def backend_register(self, key, host): DCNL 'Implements registration logic. DCNL Called by register(self,key,host)'
def backend_unregister(self, key, key_host): DCNL 'Implements de-registration logic. DCNL Called by unregister(self,key,host)'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Implementation of MatchMakerBase.start_heartbeat DCNL Launches greenthread looping send_heartbeats(), DCNL yielding for CONF.matchmaker_heartbeat_freq seconds DCNL between iterations.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts): DCNL 'Declare a queue on an amqp session. DCNL \'session\' is the amqp session to use DCNL \'callback\' is the callback to call when messages are received DCNL \'node_name\' is the first part of the Qpid address string, before \';\' DCNL \'node_opts\' will be applied to the "x-declare" section of "node" DCNL in the address string. DCNL \'link_name\' goes into the "name" field of the "link" in the address DCNL string DCNL \'link_opts\' will be applied to the "x-declare" section of "link" DCNL in the address string.'
def reconnect(self, session): DCNL 'Re-declare the receiver after a qpid reconnect'
def consume(self): DCNL 'Fetch the message and pass it to the callback object'
def __init__(self, conf, session, msg_id, callback): DCNL 'Init a \'direct\' queue. DCNL \'session\' is the amqp session to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None): DCNL 'Init a \'topic\' queue. DCNL :param session: the amqp session to use DCNL :param topic: is the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param name: optional queue name, defaults to topic'
def __init__(self, conf, session, topic, callback): DCNL 'Init a \'fanout\' queue. DCNL \'session\' is the amqp session to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, session, node_name, node_opts=None): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, session): DCNL 'Re-establish the Sender after a reconnection'
def send(self, msg): DCNL 'Send a message'
def __init__(self, conf, session, msg_id): DCNL 'Init a \'direct\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'fanout\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing sessions and queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
def socket_s(self): DCNL 'Get socket type as string.'
def subscribe(self, msg_filter): DCNL 'Subscribe.'
def unsubscribe(self, msg_filter): DCNL 'Unsubscribe.'
def _get_response(self, ctx, proxy, topic, data): DCNL 'Process a curried message and cast the result to topic.'
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None): DCNL 'Reply to a casted call.'
def consume_in_thread(self): DCNL 'Runs the ZmqProxy service'
def close(self): DCNL 'Close the connection. DCNL This method must be called when the connection will no longer be used. DCNL It will ensure that any resources associated with the connection, such DCNL as a network connection, and cleaned up.'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer on this connection. DCNL A consumer is associated with a message queue on the backend message DCNL bus.  The consumer will read messages from the queue, unpack them, and DCNL dispatch them to the proxy object.  The contents of the message pulled DCNL off of the queue will determine which method gets called on the proxy DCNL object. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. For example, all instances of nova-compute consume DCNL from a queue called "compute".  In that case, the DCNL messages will get distributed amongst the consumers in a DCNL round-robin fashion if fanout=False.  If fanout=True, DCNL every consumer associated with this topic will get a DCNL copy of every message. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param fanout: Whether or not this is a fanout topic.  See the DCNL documentation for the topic parameter for some DCNL additional comments on this.'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker on this connection. DCNL A worker is like a regular consumer of messages directed to a DCNL topic, except that it is part of a set of such consumers (the DCNL "pool") which may run in parallel. Every pool of workers will DCNL receive a given message, but only one worker in the pool will DCNL be asked to process it. Load is distributed across the members DCNL of the pool in round-robin fashion. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param pool_name: String containing the name of the pool of workers'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created. DCNL :param callback: Callable to be invoked for each message. DCNL :type callback: callable accepting one argument DCNL :param pool_name: The name of the consumer pool. DCNL :type pool_name: str DCNL :param topic: The routing topic for desired messages. DCNL :type topic: str DCNL :param exchange_name: The name of the message exchange where DCNL the client should attach. Defaults to DCNL the configured exchange. DCNL :type exchange_name: str'
def consume_in_thread(self): DCNL 'Spawn a thread to handle incoming messages. DCNL Spawn a thread that will be responsible for handling all incoming DCNL messages for consumers that were set up on this connection. DCNL Message dispatching inside of this is expected to be implemented in a DCNL non-blocking manner.  An example implementation would be having this DCNL thread pull messages in for all of the consumers, but utilize a thread DCNL pool for dispatching the messages to the proxy objects.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
def __init__(self, channel, callback, tag, **kwargs): DCNL 'Declare a queue on an amqp channel. DCNL \'channel\' is the amqp channel to use DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL queue name, exchange name, and other kombu options are DCNL passed in here as a dictionary.'
def reconnect(self, channel): DCNL 'Re-declare the queue after a rabbit reconnect'
def consume(self, *args, **kwargs): DCNL 'Actually declare the consumer on the amqp channel.  This will DCNL start the flow of messages from the queue.  Using the DCNL Connection.iterconsume() iterator will process the messages, DCNL calling the appropriate callback. DCNL If a callback is specified in kwargs, use that.  Otherwise, DCNL use the callback passed during __init__() DCNL If kwargs[\'nowait\'] is True, then this call will block until DCNL a message is read. DCNL Messages will automatically be acked if the callback doesn\'t DCNL raise an exception'
def cancel(self): DCNL 'Cancel the consuming from the queue, if it has started'
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs): DCNL 'Init a \'direct\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs): DCNL 'Init a \'topic\' queue. DCNL :param channel: the amqp channel to use DCNL :param topic: the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param tag: a unique ID for the consumer on the channel DCNL :param name: optional queue name, defaults to topic DCNL :paramtype name: str DCNL Other kombu options may be passed as keyword arguments'
def __init__(self, conf, channel, topic, callback, tag, **kwargs): DCNL 'Init a \'fanout\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, channel, exchange_name, routing_key, **kwargs): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, channel): DCNL 'Re-establish the Producer after a rabbit reconnection'
def send(self, msg, timeout=None): DCNL 'Send a message'
def __init__(self, conf, channel, msg_id, **kwargs): DCNL 'init a \'direct\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'topic\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'fanout\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def _fetch_ssl_params(self): DCNL 'Handles fetching what ssl params DCNL should be used for the connection (if any)'
def _connect(self, params): DCNL 'Connect to rabbit.  Re-establish any queues that may have DCNL been declared before if we are reconnecting.  Exceptions should DCNL be handled by the caller.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing queues. DCNL Will retry up to self.max_retries number of times. DCNL self.max_retries = 0 means to retry forever. DCNL Sleep between tries, starting at self.interval_start DCNL seconds, backing off self.interval_stepping number of seconds DCNL each attempt.'
def get_channel(self): DCNL 'Convenience call for bin/clear_rabbit_queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
@classmethod DCNL def load_json(cls, data, default_rule=None): DCNL 'Init a brain using json instead of a rules dictionary.'
def check(self, match_list, target_dict, cred_dict): DCNL 'Checks authorization of some rules against credentials. DCNL Detailed description of the check with examples in policy.enforce(). DCNL :param match_list: nested tuples of data to match against DCNL :param target_dict: dict of object properties DCNL :param credentials_dict: dict of actor properties DCNL :returns: True if the check passes'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def __str__(self): DCNL 'Make the VersionInfo object behave like a string.'
def __repr__(self): DCNL 'Include the name.'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def _weight_multiplier(self): DCNL 'How weighted this weigher should be.  Normally this would DCNL be overriden in a subclass based on a config value.'
def _weigh_object(self, obj, weight_properties): DCNL 'Override in a subclass to specify a weight for a specific DCNL object.'
def weigh_objects(self, weighed_obj_list, weight_properties): DCNL 'Weigh multiple objects.  Override in a subclass if you need DCNL need access to all objects in order to manipulate weights.'
def _is_correct_class(self, obj): DCNL 'Return whether an object is a class of the correct type and DCNL is not prefixed with an underscore.'
def get_weighed_objects(self, weigher_classes, obj_list, weighing_properties): DCNL 'Return a sorted (highest score first) list of WeighedObjects.'
def _filter_one(self, obj, filter_properties): DCNL 'Return True if the object passes the filter, otherwise False.'
def host_passes(self, host_state, filter_properties): DCNL 'Return True if the HostState passes the filter, otherwise False. DCNL Override this in a subclass.'
def _satisfies_extra_specs(self, capabilities, resource_type): DCNL 'Check that the capabilities provided by the services DCNL satisfy the extra specs associated with the instance type'
def host_passes(self, host_state, filter_properties): DCNL 'Return a list of hosts that can create instance_type.'
def _op_compare(self, args, op): DCNL 'Returns True if the specified operator can successfully DCNL compare the first item in the args with all the rest. Will DCNL return False if only one item is in the list.'
def _equals(self, args): DCNL 'First term is == all the other terms.'
def _less_than(self, args): DCNL 'First term is < all the other terms.'
def _greater_than(self, args): DCNL 'First term is > all the other terms.'
def _in(self, args): DCNL 'First term is in set of remaining terms'
def _less_than_equal(self, args): DCNL 'First term is <= all the other terms.'
def _greater_than_equal(self, args): DCNL 'First term is >= all the other terms.'
def _not(self, args): DCNL 'Flip each of the arguments.'
def _or(self, args): DCNL 'True if any arg is True.'
def _and(self, args): DCNL 'True if all args are True.'
def _parse_string(self, string, host_state): DCNL 'Strings prefixed with $ are capability lookups in the DCNL form \'$variable\' where \'variable\' is an attribute in the DCNL HostState class.  If $variable is a dictionary, you may DCNL use: $variable.dictkey'
def _process_filter(self, query, host_state): DCNL 'Recursively parse the query structure.'
def host_passes(self, host_state, filter_properties): DCNL 'Return a list of hosts that can fulfill the requirements DCNL specified in the query.'
def _filter_one(self, obj, filter_properties): DCNL 'Return True if it passes the filter, False otherwise. DCNL Override this in a subclass.'
def filter_all(self, filter_obj_list, filter_properties): DCNL 'Yield objects that pass the filter. DCNL Can be overriden in a subclass, if you need to base filtering DCNL decisions on all objects.  Otherwise, one can just override DCNL _filter_one() to filter a single object.'
def _is_correct_class(self, obj): DCNL 'Return whether an object is a class of the correct type and DCNL is not prefixed with an underscore.'
def get_exec(self, exec_dirs=[]): DCNL 'Returns existing executable, or empty string if none found'
def match(self, userargs): DCNL 'Only check that the first argument (command) matches exec_path'
def get_command(self, userargs, exec_dirs=[]): DCNL 'Returns command to execute (with sudo -u if run_as != root).'
def get_environment(self, userargs): DCNL 'Returns specific environment to set, None if none'
def __init__(cls, names, bases, dict_): DCNL 'Metaclass that allows us to collect decorated periodic tasks.'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def periodic_tasks(self, context, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def init_host(self): DCNL 'Handle initialization if this is a standalone service. DCNL Child classes should override this method.'
def get_by_project(self, context, project_id, resource): DCNL 'Get a specific quota by project.'
def get_by_class(self, context, quota_class, resource): DCNL 'Get a specific quota by quota class.'
def get_defaults(self, context, resources): DCNL 'Given a list of resources, retrieve the default quotas. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources.'
def get_class_quotas(self, context, resources, quota_class, defaults=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL quota class. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param quota_class: The name of the quota class to return DCNL quotas for. DCNL :param defaults: If True, the default value will be reported DCNL if there is no specific value for the DCNL resource.'
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL project. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param project_id: The ID of the project to return quotas for. DCNL :param quota_class: If project_id != context.project_id, the DCNL quota class cannot be determined.  This DCNL parameter allows it to be specified.  It DCNL will be ignored if project_id == DCNL context.project_id. DCNL :param defaults: If True, the quota class value (or the DCNL default value, if there is no value from the DCNL quota class) will be reported if there is no DCNL specific value for the resource. DCNL :param usages: If True, the current in_use and reserved counts DCNL will also be returned.'
def _get_quotas(self, context, resources, keys, has_sync, project_id=None): DCNL 'A helper method which retrieves the quotas for the specific DCNL resources identified by keys, and which apply to the current DCNL context. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param keys: A list of the desired quotas to retrieve. DCNL :param has_sync: If True, indicates that the resource must DCNL have a sync attribute; if False, indicates DCNL that the resource must NOT have a sync DCNL attribute. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def limit_check(self, context, resources, values, project_id=None): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param values: A dictionary of the values to check against the DCNL quota. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def reserve(self, context, resources, deltas, expire=None, project_id=None): DCNL 'Check quotas and reserve resources. DCNL For counting quotas--those quotas for which there is a usage DCNL synchronization function--this method checks quotas against DCNL current usage and the desired deltas. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it does not have a usage DCNL synchronization function. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns a DCNL list of reservation UUIDs which were created. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param deltas: A dictionary of the proposed delta changes. DCNL :param expire: An optional parameter specifying an expiration DCNL time for the reservations.  If it is a simple DCNL number, it is interpreted as a number of DCNL seconds and added to the current time; if it is DCNL a datetime.timedelta object, it will also be DCNL added to the current time.  A datetime.datetime DCNL object will be interpreted as the absolute DCNL expiration time.  If None is specified, the DCNL default expiration time set by DCNL --default-reservation-expire will be used (this DCNL value will be treated as a number of seconds). DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def commit(self, context, reservations, project_id=None): DCNL 'Commit reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def rollback(self, context, reservations, project_id=None): DCNL 'Roll back reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def destroy_all_by_project(self, context, project_id): DCNL 'Destroy all quotas, usages, and reservations associated with a DCNL project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project being deleted.'
def expire(self, context): DCNL 'Expire reservations. DCNL Explores all currently existing reservations and rolls back DCNL any that have expired. DCNL :param context: The request context, for access checks.'
def __init__(self, name, flag=None): DCNL 'Initializes a Resource. DCNL :param name: The name of the resource, i.e., "servicemanages". DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def quota(self, driver, context, **kwargs): DCNL 'Given a driver and context, obtain the quota for this DCNL resource. DCNL :param driver: A quota driver. DCNL :param context: The request context. DCNL :param project_id: The project to obtain the quota value for. DCNL If not provided, it is taken from the DCNL context.  If it is given as None, no DCNL project-specific quota will be searched DCNL for. DCNL :param quota_class: The quota class corresponding to the DCNL project, or for which the quota is to be DCNL looked up.  If not provided, it is taken DCNL from the context.  If it is given as None, DCNL no quota class-specific quota will be DCNL searched for.  Note that the quota class DCNL defaults to the value in the context, DCNL which may not correspond to the project if DCNL project_id is not the same as the one in DCNL the context.'
@property DCNL def default(self): DCNL 'Return the default value of the quota.'
def __init__(self, name, sync, flag=None): DCNL 'Initializes a ReservableResource. DCNL Reservable resources are those resources which directly DCNL correspond to objects in the database, i.e., servicemanages, gigabytes, DCNL etc.  A ReservableResource must be constructed with a usage DCNL synchronization function, which will be called to determine the DCNL current counts of one or more resources. DCNL The usage synchronization function will be passed three DCNL arguments: an admin context, the project ID, and an opaque DCNL session object, which should in turn be passed to the DCNL underlying database function.  Synchronization functions DCNL should return a dictionary mapping resource names to the DCNL current in_use count for those resources; more than one DCNL resource and resource count may be returned.  Note that DCNL synchronization functions may be associated with more than one DCNL ReservableResource. DCNL :param name: The name of the resource, i.e., "servicemanages". DCNL :param sync: A callable which returns a dictionary to DCNL resynchronize the in_use count for one or more DCNL resources, as described above. DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def __init__(self, name, count, flag=None): DCNL 'Initializes a CountableResource. DCNL Countable resources are those resources which directly DCNL correspond to objects in the database, i.e., servicemanages, gigabytes, DCNL etc., but for which a count by project ID is inappropriate.  A DCNL CountableResource must be constructed with a counting DCNL function, which will be called to determine the current counts DCNL of the resource. DCNL The counting function will be passed the context, along with DCNL the extra positional and keyword arguments that are passed to DCNL Quota.count().  It should return an integer specifying the DCNL count. DCNL Note that this counting is not performed in a transaction-safe DCNL manner.  This resource class is a temporary measure to provide DCNL required functionality, until a better approach to solving DCNL this problem can be evolved. DCNL :param name: The name of the resource, i.e., "servicemanages". DCNL :param count: A callable which returns the count of the DCNL resource.  The arguments passed are as described DCNL above. DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def __init__(self, quota_driver_class=None): DCNL 'Initialize a Quota object.'
def register_resource(self, resource): DCNL 'Register a resource.'
def register_resources(self, resources): DCNL 'Register a list of resources.'
def get_by_project(self, context, project_id, resource): DCNL 'Get a specific quota by project.'
def get_by_class(self, context, quota_class, resource): DCNL 'Get a specific quota by quota class.'
def get_defaults(self, context): DCNL 'Retrieve the default quotas. DCNL :param context: The request context, for access checks.'
def get_class_quotas(self, context, quota_class, defaults=True): DCNL 'Retrieve the quotas for the given quota class. DCNL :param context: The request context, for access checks. DCNL :param quota_class: The name of the quota class to return DCNL quotas for. DCNL :param defaults: If True, the default value will be reported DCNL if there is no specific value for the DCNL resource.'
def get_project_quotas(self, context, project_id, quota_class=None, defaults=True, usages=True): DCNL 'Retrieve the quotas for the given project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project to return quotas for. DCNL :param quota_class: If project_id != context.project_id, the DCNL quota class cannot be determined.  This DCNL parameter allows it to be specified. DCNL :param defaults: If True, the quota class value (or the DCNL default value, if there is no value from the DCNL quota class) will be reported if there is no DCNL specific value for the resource. DCNL :param usages: If True, the current in_use and reserved counts DCNL will also be returned.'
def count(self, context, resource, *args, **kwargs): DCNL 'Count a resource. DCNL For countable resources, invokes the count() function and DCNL returns its result.  Arguments following the context and DCNL resource are passed directly to the count function declared by DCNL the resource. DCNL :param context: The request context, for access checks. DCNL :param resource: The name of the resource, as a string.'
def limit_check(self, context, project_id=None, **values): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction.  The DCNL values to check are given as keyword arguments, where the key DCNL identifies the specific quota limit to check, and the value is DCNL the proposed value. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def reserve(self, context, expire=None, project_id=None, **deltas): DCNL 'Check quotas and reserve resources. DCNL For counting quotas--those quotas for which there is a usage DCNL synchronization function--this method checks quotas against DCNL current usage and the desired deltas.  The deltas are given as DCNL keyword arguments, and current usage and other reservations DCNL are factored into the quota check. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it does not have a usage DCNL synchronization function. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns a DCNL list of reservation UUIDs which were created. DCNL :param context: The request context, for access checks. DCNL :param expire: An optional parameter specifying an expiration DCNL time for the reservations.  If it is a simple DCNL number, it is interpreted as a number of DCNL seconds and added to the current time; if it is DCNL a datetime.timedelta object, it will also be DCNL added to the current time.  A datetime.datetime DCNL object will be interpreted as the absolute DCNL expiration time.  If None is specified, the DCNL default expiration time set by DCNL --default-reservation-expire will be used (this DCNL value will be treated as a number of seconds). DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def commit(self, context, reservations, project_id=None): DCNL 'Commit reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def rollback(self, context, reservations, project_id=None): DCNL 'Roll back reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def destroy_all_by_project(self, context, project_id): DCNL 'Destroy all quotas, usages, and reservations associated with a DCNL project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project being deleted.'
def expire(self, context): DCNL 'Expire reservations. DCNL Explores all currently existing reservations and rolls back DCNL any that have expired. DCNL :param context: The request context, for access checks.'
def __init__(self, name, app, host=None, port=None, pool_size=None, protocol=eventlet.wsgi.HttpProtocol): DCNL 'Initialize, but do not start, a WSGI server. DCNL :param name: Pretty name for logging. DCNL :param app: The WSGI application to serve. DCNL :param host: IP address to serve the application. DCNL :param port: Port number to server the application. DCNL :param pool_size: Maximum number of eventlets to spawn concurrently. DCNL :returns: None'
def _start(self): DCNL 'Run the blocking eventlet WSGI server. DCNL :returns: None'
def start(self, backlog=128): DCNL 'Start serving a WSGI application. DCNL :param backlog: Maximum number of queued connections. DCNL :returns: None DCNL :raises: monitor.exception.InvalidInput'
def stop(self): DCNL 'Stop this server. DCNL This is not a very nice action, as currently the method by which a DCNL server is stopped is by killing its eventlet. DCNL :returns: None'
def wait(self): DCNL 'Block, until the server has stopped. DCNL Waits on the server\'s eventlet to finish, then returns. DCNL :returns: None'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [app:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [app:wadl] DCNL latest_version = 1.3 DCNL paste.app_factory = monitor.api.fancy_api:Wadl.factory DCNL which would result in a call to the `Wadl` class as DCNL import monitor.api.fancy_api DCNL fancy_api.Wadl(latest_version=\'1.3\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def __call__(self, environ, start_response): DCNL 'Subclasses will probably want to implement __call__ like this: DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL # Any of the following objects work as responses: DCNL # Option 1: simple string DCNL res = \'message\n\' DCNL # Option 2: a nicely formatted HTTP exception page DCNL res = exc.HTTPForbidden(detail=\'Nice try\') DCNL # Option 3: a webob Response object (in case you need to play with DCNL # headers, or you want to be treated like an iterable, or or or) DCNL res = Response(); DCNL res.app_iter = open(\'somefile\') DCNL # Option 4: any wsgi app to be run next DCNL res = self.application DCNL # Option 5: you can get a Response object for a wsgi app, too, to DCNL # play with headers etc DCNL res = req.get_response(self.application) DCNL # You can then just return your response... DCNL return res DCNL # ... or set req.response and return None. DCNL req.response = res DCNL See the end of http://pythonpaste.org/webob/modules/dec.html DCNL for more info.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [filter:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [filter:analytics] DCNL redis_host = 127.0.0.1 DCNL paste.filter_factory = monitor.api.analytics:Analytics.factory DCNL which would result in a call to the `Analytics` class as DCNL import monitor.api.analytics DCNL analytics.Analytics(app_from_paste, redis_host=\'127.0.0.1\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def process_request(self, req): DCNL 'Called on each request. DCNL If this returns None, the next application down the stack will be DCNL executed. If it returns a response then that response will be returned DCNL and execution will stop here.'
def process_response(self, response): DCNL 'Do whatever you\'d like to the response.'
@staticmethod DCNL def print_generator(app_iter): DCNL 'Iterator that prints the contents of a wrapper string.'
def __init__(self, mapper): DCNL 'Create a router for the given routes.Mapper. DCNL Each route in `mapper` must specify a \'controller\', which is a DCNL WSGI app to call.  You\'ll probably want to specify an \'action\' as DCNL well and have your controller be an object that can route DCNL the request to the action-specific method. DCNL Examples: DCNL mapper = routes.Mapper() DCNL sc = ServerController() DCNL # Explicit mapping of one route to a controller+action DCNL mapper.connect(None, \'/svrlist\', controller=sc, action=\'list\') DCNL # Actions are all implicitly defined DCNL mapper.resource(\'server\', \'servers\', controller=sc) DCNL # Pointing to an arbitrary WSGI app.  You can specify the DCNL # {path_info:.*} parameter so the target app can be handed just that DCNL # section of the URL. DCNL mapper.connect(None, \'/v1.0/{path_info:.*}\', controller=BlogApp())'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Route the incoming request to a controller based on self.map. DCNL If no match, return a 404.'
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req): DCNL 'Dispatch the request to the appropriate controller. DCNL Called by self._router after matching the incoming request to a route DCNL and putting the information into req.environ.  Either returns 404 DCNL or the routed WSGI app\'s response.'
def __init__(self, config_path=None): DCNL 'Initialize the loader, and attempt to find the config. DCNL :param config_path: Full or relative path to the paste config. DCNL :returns: None'
def load_app(self, name): DCNL 'Return the paste URLMap wrapped WSGI application. DCNL :param name: Name of the application to load. DCNL :returns: Paste URLMap object wrapping the requested application. DCNL :raises: `monitor.exception.PasteAppNotFound`'
def __init__(self, user_id, project_id, is_admin=None, read_deleted='no', roles=None, remote_address=None, timestamp=None, request_id=None, auth_token=None, overwrite=True, quota_class=None, **kwargs): DCNL ':param read_deleted: \'no\' indicates deleted records are hidden, \'yes\' DCNL indicates deleted records are visible, \'only\' indicates that DCNL *only* deleted records are visible. DCNL :param overwrite: Set to False to ensure that the greenthread local DCNL copy of the index is not overwritten. DCNL :param kwargs: Extra arguments that might be present, but we ignore DCNL because they possibly came in from older rpc messages.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
def __init__(self, data, limit): DCNL ':param data: Underlying data object DCNL :param limit: maximum number of bytes the reader should allow'
def __init__(self, ext_mgr): DCNL 'Register extension with the extension manager.'
def get_resources(self): DCNL 'List of extensions.ResourceExtension extension objects. DCNL Resources define new nouns, and are accessible through URLs.'
def get_controller_extensions(self): DCNL 'List of extensions.ControllerExtension extension objects. DCNL Controller extensions are used to extend existing controllers.'
@classmethod DCNL def nsmap(cls): DCNL 'Synthesize a namespace map from extension.'
@classmethod DCNL def xmlname(cls, name): DCNL 'Synthesize element and attribute names.'
def get_resources(self): DCNL 'Returns a list of ResourceExtension objects.'
def get_controller_extensions(self): DCNL 'Returns a list of ControllerExtension objects.'
def _check_extension(self, extension): DCNL 'Checks for required methods in extension objects.'
def load_extension(self, ext_factory): DCNL 'Execute an extension factory. DCNL Loads an extension.  The \'ext_factory\' is the name of a DCNL callable that will be imported and called with one DCNL argument--the extension manager.  The factory callable is DCNL expected to call the register() method at least once.'
def _load_extensions(self): DCNL 'Load extensions specified on the command line.'
def _get_next_link(self, request, identifier): DCNL 'Return href string with proper limit and marker params.'
def _get_href_link(self, request, identifier): DCNL 'Return an href string pointing to this object.'
def _get_bookmark_link(self, request, identifier): DCNL 'Create a URL that refers to a specific resource.'
def _get_collection_links(self, request, items, id_key='uuid'): DCNL 'Retrieve \'next\' link, if applicable.'
def extract_metadata(self, metadata_node): DCNL 'Marshal the metadata attribute of a parsed request'
def __init__(self): DCNL 'Initialize view builder.'
def summary_list(self, request, backups): DCNL 'Show a list of backups without many details.'
def detail_list(self, request, backups): DCNL 'Detailed view of a list of backups .'
def summary(self, request, backup): DCNL 'Generic, non-detailed view of a backup.'
def restore_summary(self, request, restore): DCNL 'Generic, non-detailed view of a restore.'
def detail(self, request, backup): DCNL 'Detailed view of a single backup.'
def _list_view(self, func, request, backups): DCNL 'Provide a view for a list of backups.'
def show(self, request, servicemanage_type, brief=False): DCNL 'Trim away extraneous servicemanage type attributes.'
def index(self, request, servicemanage_types): DCNL 'Index over trimmed servicemanage types'
def _build_absolute_limits(self, absolute_limits): DCNL 'Builder for absolute limits DCNL absolute_limits should be given as a dict of limits. DCNL For example: {"ram": 512, "gigabytes": 1024}.'
def __init__(self, base_url): DCNL ':param base_url: url of the root wsgi application'
def _build_links(self, version_data): DCNL 'Generate a container of links that refer to the provided version.'
def generate_href(self, path=None): DCNL 'Create an url that refers to a specific version_number.'
def __init__(self, *chain): DCNL 'Initialize the selector. DCNL Each argument is a subsequent index into the object.'
def __repr__(self): DCNL 'Return a representation of the selector.'
def __call__(self, obj, do_raise=False): DCNL 'Select a datum to operate on. DCNL Selects the relevant datum within the object. DCNL :param obj: The object from which to select the object. DCNL :param do_raise: If False (the default), return None if the DCNL indexed datum does not exist.  Otherwise, DCNL raise a KeyError.'
def __call__(self, obj, do_raise=False): DCNL 'Returns empty string if the selected value does not exist.'
def __init__(self, value): DCNL 'Initialize the selector. DCNL :param value: The value to return.'
def __repr__(self): DCNL 'Return a representation of the selector.'
def __call__(self, _obj, _do_raise=False): DCNL 'Select a datum to operate on. DCNL Returns a constant value.  Compatible with DCNL Selector.__call__().'
def __init__(self, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Initialize an element. DCNL Initializes an element in the template.  Keyword arguments DCNL specify attributes to be set on the element; values must be DCNL callables.  See TemplateElement.set() for more information. DCNL :param tag: The name of the tag to create. DCNL :param attrib: An optional dictionary of element attributes. DCNL :param selector: An optional callable taking an object and DCNL optional boolean do_raise indicator and DCNL returning the object bound to the element. DCNL :param subselector: An optional callable taking an object and DCNL optional boolean do_raise indicator and DCNL returning the object bound to the element. DCNL This is used to further refine the datum DCNL object returned by selector in the event DCNL that it is a list of objects.'
def __repr__(self): DCNL 'Return a representation of the template element.'
def __len__(self): DCNL 'Return the number of child elements.'
def __contains__(self, key): DCNL 'Determine whether a child node named by key exists.'
def __getitem__(self, idx): DCNL 'Retrieve a child node by index or name.'
def append(self, elem): DCNL 'Append a child to the element.'
def extend(self, elems): DCNL 'Append children to the element.'
def insert(self, idx, elem): DCNL 'Insert a child element at the given index.'
def remove(self, elem): DCNL 'Remove a child element.'
def get(self, key): DCNL 'Get an attribute. DCNL Returns a callable which performs datum selection. DCNL :param key: The name of the attribute to get.'
def set(self, key, value=None): DCNL 'Set an attribute. DCNL :param key: The name of the attribute to set. DCNL :param value: A callable taking an object and optional boolean DCNL do_raise indicator and returning the datum bound DCNL to the attribute.  If None, a Selector() will be DCNL constructed from the key.  If a string, a DCNL Selector() will be constructed from the string.'
def keys(self): DCNL 'Return the attribute names.'
def items(self): DCNL 'Return the attribute names and values.'
def unwrap(self): DCNL 'Unwraps a template to return a template element.'
def wrap(self): DCNL 'Wraps a template element to return a template.'
def apply(self, elem, obj): DCNL 'Apply text and attributes to an etree.Element. DCNL Applies the text and attribute instructions in the template DCNL element to an etree.Element instance. DCNL :param elem: An etree.Element instance. DCNL :param obj: The base object associated with this template DCNL element.'
def _render(self, parent, datum, patches, nsmap): DCNL 'Internal rendering. DCNL Renders the template node into an etree.Element object. DCNL Returns the etree.Element object. DCNL :param parent: The parent etree.Element instance. DCNL :param datum: The datum associated with this template element. DCNL :param patches: A list of other template elements that must DCNL also be applied. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the etree.Element instance.'
def render(self, parent, obj, patches=[], nsmap=None): DCNL 'Render an object. DCNL Renders an object against this template node.  Returns a list DCNL of two-item tuples, where the first item is an etree.Element DCNL instance and the second item is the datum associated with that DCNL instance. DCNL :param parent: The parent for the etree.Element instances. DCNL :param obj: The object to render this template element DCNL against. DCNL :param patches: A list of other template elements to apply DCNL when rendering this template element. DCNL :param nsmap: An optional namespace dictionary to attach to DCNL the etree.Element instances.'
def will_render(self, datum): DCNL 'Hook method. DCNL An overridable hook method to determine whether this template DCNL element will be rendered at all.  By default, returns False DCNL (inhibiting rendering) if the datum is None. DCNL :param datum: The datum associated with this template element.'
def _text_get(self): DCNL 'Template element text. DCNL Either None or a callable taking an object and optional DCNL boolean do_raise indicator and returning the datum bound to DCNL the text of the template element.'
def tree(self): DCNL 'Return string representation of the template tree. DCNL Returns a representation of the template rooted at this DCNL element as a string, suitable for inclusion in debug logs.'
def __init__(self, root, nsmap=None): DCNL 'Initialize a template. DCNL :param root: The root element of the template. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def _serialize(self, parent, obj, siblings, nsmap=None): DCNL 'Internal serialization. DCNL Recursive routine to build a tree of etree.Element instances DCNL from an object based on the template.  Returns the first DCNL etree.Element instance rendered, or None. DCNL :param parent: The parent etree.Element instance.  Can be DCNL None. DCNL :param obj: The object to render. DCNL :param siblings: The TemplateElement instances against which DCNL to render the object. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the etree.Element instance DCNL rendered.'
def serialize(self, obj, *args, **kwargs): DCNL 'Serialize an object. DCNL Serializes an object against the template.  Returns a string DCNL with the serialized XML.  Positional and keyword arguments are DCNL passed to etree.tostring(). DCNL :param obj: The object to serialize.'
def make_tree(self, obj): DCNL 'Create a tree. DCNL Serializes an object against the template.  Returns an Element DCNL node with appropriate children. DCNL :param obj: The object to serialize.'
def _siblings(self): DCNL 'Hook method for computing root siblings. DCNL An overridable hook method to return the siblings of the root DCNL element.  By default, this is the root element itself.'
def _nsmap(self): DCNL 'Hook method for computing the namespace dictionary. DCNL An overridable hook method to return the namespace dictionary.'
def unwrap(self): DCNL 'Unwraps a template to return a template element.'
def wrap(self): DCNL 'Wraps a template element to return a template.'
def apply(self, master): DCNL 'Hook method for determining slave applicability. DCNL An overridable hook method used to determine if this template DCNL is applicable as a slave to a given master template. DCNL :param master: The master template to test.'
def tree(self): DCNL 'Return string representation of the template tree. DCNL Returns a representation of the template as a string, suitable DCNL for inclusion in debug logs.'
def __init__(self, root, version, nsmap=None): DCNL 'Initialize a master template. DCNL :param root: The root element of the template. DCNL :param version: The version number of the template. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def __repr__(self): DCNL 'Return string representation of the template.'
def _siblings(self): DCNL 'Hook method for computing root siblings. DCNL An overridable hook method to return the siblings of the root DCNL element.  This is the root element plus the root elements of DCNL all the slave templates.'
def _nsmap(self): DCNL 'Hook method for computing the namespace dictionary. DCNL An overridable hook method to return the namespace dictionary. DCNL The namespace dictionary is computed by taking the master DCNL template\'s namespace dictionary and updating it from all the DCNL slave templates.'
def attach(self, *slaves): DCNL 'Attach one or more slave templates. DCNL Attaches one or more slave templates to the master template. DCNL Slave templates must have a root element with the same tag as DCNL the master template.  The slave template\'s apply() method will DCNL be called to determine if the slave should be applied to this DCNL master; if it returns False, that slave will be skipped. DCNL (This allows filtering of slaves based on the version of the DCNL master template.)'
def copy(self): DCNL 'Return a copy of this master template.'
def __init__(self, root, min_vers, max_vers=None, nsmap=None): DCNL 'Initialize a slave template. DCNL :param root: The root element of the template. DCNL :param min_vers: The minimum permissible version of the master DCNL template for this slave template to apply. DCNL :param max_vers: An optional upper bound for the master DCNL template version. DCNL :param nsmap: An optional namespace dictionary to be DCNL associated with the root element of the DCNL template.'
def __repr__(self): DCNL 'Return string representation of the template.'
def apply(self, master): DCNL 'Hook method for determining slave applicability. DCNL An overridable hook method used to determine if this template DCNL is applicable as a slave to a given master template.  This DCNL version requires the master template to have a version number DCNL between min_vers and max_vers. DCNL :param master: The master template to test.'
def __new__(cls, copy=True): DCNL 'Construct and return a template. DCNL :param copy: If True (the default), a copy of the template DCNL will be constructed and returned, if possible.'
def construct(self): DCNL 'Construct a template. DCNL Called to construct a template instance, which it must return. DCNL Only called once.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Simple paste factory, :class:`monitor.wsgi.Router` doesn\'t have'
def best_match_content_type(self): DCNL 'Determine the requested response content-type.'
def get_content_type(self): DCNL 'Determine content type of the request body. DCNL Does not do any body introspection, only checks header'
def dispatch(self, *args, **kwargs): DCNL 'Find and call local method.'
def __init__(self, metadata=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary.'
def _from_xml_node(self, node, listnames): DCNL 'Convert a minidom node to a simple Python type. DCNL :param listnames: list of XML node names whose subnodes should DCNL be considered list items.'
def find_first_child_named(self, parent, name): DCNL 'Search a nodes children for the first child with a given name'
def find_children_named(self, parent, name): DCNL 'Return all of a nodes children who have the given name'
def extract_text(self, node): DCNL 'Get the text field contained by the given node'
def find_attribute_or_element(self, parent, name): DCNL 'Get an attribute value; fallback to an element if not found'
def extract_metadata(self, metadata_node): DCNL 'Marshal the metadata attribute of a parsed request'
def __init__(self, metadata=None, xmlns=None): DCNL ':param metadata: information needed to deserialize xml into DCNL a dictionary. DCNL :param xmlns: XML namespace to include with serialized xml'
def _to_xml_node(self, doc, metadata, nodename, data): DCNL 'Recursive method to convert data members to XML nodes.'
def _to_xml(self, root): DCNL 'Convert the xml object to an xml string.'
def __init__(self, obj, code=None, **serializers): DCNL 'Binds serializers with an object. DCNL Takes keyword arguments akin to the @serializer() decorator DCNL for specifying serializers.  Serializers specified will be DCNL given preference over default serializers or method-specific DCNL serializers on return.'
def __getitem__(self, key): DCNL 'Retrieves a header with the given name.'
def __setitem__(self, key, value): DCNL 'Sets a header with the given name to the given value.'
def __delitem__(self, key): DCNL 'Deletes the header with the given name.'
def _bind_method_serializers(self, meth_serializers): DCNL 'Binds method serializers with the response object. DCNL Binds the method serializers with the response object. DCNL Serializers specified to the constructor will take precedence DCNL over serializers specified to this method. DCNL :param meth_serializers: A dictionary with keys mapping to DCNL response types and values containing DCNL serializer objects.'
def get_serializer(self, content_type, default_serializers=None): DCNL 'Returns the serializer for the wrapped object. DCNL Returns the serializer for the wrapped object subject to the DCNL indicated content type.  If no serializer matching the content DCNL type is attached, an appropriate serializer drawn from the DCNL default serializers will be used.  If no appropriate DCNL serializer is available, raises InvalidContentType.'
def preserialize(self, content_type, default_serializers=None): DCNL 'Prepares the serializer that will be used to serialize. DCNL Determines the serializer that will be used and prepares an DCNL instance of it for later call.  This allows the serializer to DCNL be accessed by extensions for, e.g., template extension.'
def attach(self, **kwargs): DCNL 'Attach slave templates to serializers.'
def serialize(self, request, content_type, default_serializers=None): DCNL 'Serializes the wrapped object. DCNL Utility method for serializing the wrapped object.  Returns a DCNL webob.Response object.'
@property DCNL def code(self): DCNL 'Retrieve the response status.'
@property DCNL def headers(self): DCNL 'Retrieve the headers.'
def __init__(self, controller, action_peek=None, **deserializers): DCNL ':param controller: object that implement methods created by routes lib DCNL :param action_peek: dictionary of routines for peeking into an action DCNL request body to determine the desired action'
def register_actions(self, controller): DCNL 'Registers controller actions with this resource.'
def register_extensions(self, controller): DCNL 'Registers controller extensions with this resource.'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'WSGI method that controls (de)serialization and method dispatch.'
def _process_stack(self, request, action, action_args, content_type, body, accept): DCNL 'Implement the processing stack.'
def get_method(self, request, action, content_type, body): DCNL 'Look up the action-specific method and its extensions.'
def dispatch(self, method, request, action_args): DCNL 'Dispatch a call to the action-specific method.'
def __new__(mcs, name, bases, cls_dict): DCNL 'Adds the wsgi_actions dictionary to the class.'
def __init__(self, view_builder=None): DCNL 'Initialize controller with a view builder instance.'
def __init__(self, exception): DCNL 'Create a Fault for the given webob.exc.exception.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Generate a WSGI response based on the exception passed to ctor.'
def __init__(self, message, details, retry_time): DCNL 'Initialize new `OverLimitFault` with relevant information.'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request): DCNL 'Return the wrapped exception with a serialized body conforming to our DCNL error format.'
@wsgi.serializers(xml=ServiceManageTypesTemplate) DCNL def index(self, req): DCNL 'Returns the list of servicemanage types.'
@wsgi.serializers(xml=ServiceManageTypeTemplate) DCNL def show(self, req, id): DCNL 'Return a single servicemanage type item.'
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req): DCNL 'Return all global and rate limit information.'
def __init__(self, verb, uri, regex, value, unit): DCNL 'Initialize a new `Limit`. DCNL @param verb: HTTP verb (POST, PUT, etc.) DCNL @param uri: Human-readable URI DCNL @param regex: Regular expression format for this limit DCNL @param value: Integer number of requests which can be made DCNL @param unit: Unit of measure for the value parameter'
def __call__(self, verb, url): DCNL 'Represents a call to this limit from a relevant request. DCNL @param verb: string http verb (POST, GET, etc.) DCNL @param url: string URL'
def _get_time(self): DCNL 'Retrieve the current time. Broken out for testability.'
def display_unit(self): DCNL 'Display the string name of the unit.'
def display(self): DCNL 'Return a useful representation of this class.'
def __init__(self, application, limits=None, limiter=None, **kwargs): DCNL 'Initialize new `RateLimitingMiddleware`, which wraps the given WSGI DCNL application and sets up the given limits. DCNL @param application: WSGI application to wrap DCNL @param limits: String describing limits DCNL @param limiter: String identifying class for representing limits DCNL Other parameters are passed to the constructor for the limiter.'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req): DCNL 'Represents a single call through this middleware. We should record the DCNL request if we have a limit relevant to it. If no limit is relevant to DCNL the request, ignore it. DCNL If the request should be rate limited, return a fault telling the user DCNL they are over the limit and need to retry later.'
def __init__(self, limits, **kwargs): DCNL 'Initialize the new `Limiter`. DCNL @param limits: List of `Limit` objects'
def get_limits(self, username=None): DCNL 'Return the limits for a given user.'
def check_for_delay(self, verb, url, username=None): DCNL 'Check the given verb/user/user triplet for limit. DCNL @return: Tuple of delay (in seconds) and error message (or None, None)'
@staticmethod DCNL def parse_limits(limits): DCNL 'Convert a string into a list of Limit instances.  This DCNL implementation expects a semicolon-separated sequence of DCNL parenthesized groups, where each group contains a DCNL comma-separated sequence consisting of HTTP method, DCNL user-readable URI, a URI reg-exp, an integer number of DCNL requests which can be made, and a unit of measure.  Valid DCNL values for the latter are "SECOND", "MINUTE", "HOUR", and DCNL "DAY". DCNL @return: List of Limit instances.'
def __init__(self, limits=None): DCNL 'Initialize the new `WsgiLimiter`. DCNL @param limits: List of `Limit` objects'
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request): DCNL 'Handles a call to this application. Returns 204 if the request is DCNL acceptable to the limiter, else a 403 is returned with a relevant DCNL header indicating when the request *will* succeed.'
def __init__(self, limiter_address): DCNL 'Initialize the new `WsgiLimiterProxy`. DCNL @param limiter_address: IP/port combination of where to request limit'
@staticmethod DCNL def parse_limits(limits): DCNL 'Ignore a limits string--simply doesn\'t apply for the limit DCNL proxy. DCNL @return: Empty list.'
def _extract_conductor(self, node): DCNL 'Marshal the conductor attribute of a parsed request.'
def default(self, string): DCNL 'Deserialize an xml-formatted conductor create request.'
@wsgi.serializers(xml=ConductorTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given conductor.'
def delete(self, req, id): DCNL 'Delete a conductor.'
@wsgi.serializers(xml=ConductorsTemplate) DCNL def test_service(self, req): DCNL 'Returns a detailed list of conductors.'
@wsgi.serializers(xml=ConductorsTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of conductors.'
@wsgi.serializers(xml=ConductorsTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of conductors.'
def _items(self, req, entity_maker): DCNL 'Returns a list of conductors, transformed through entity_maker.'
def _get_conductor_search_options(self): DCNL 'Return conductor search options allowed by non-admin.'
def content_type_params(self, best_content_type): DCNL 'Find parameters in Accept header for given content type.'
def _match(self, host, port, path_info): DCNL 'Find longest match for a given URL path.'
def _path_strategy(self, host, port, path_info): DCNL 'Check path suffix for MIME type and path prefix for API version.'
def _content_type_strategy(self, host, port, environ): DCNL 'Check Content-Type header for API version.'
def _accept_strategy(self, host, port, environ, supported_content_types): DCNL 'Check Accept header for best matching MIME type and API version.'
def _set_enabled_status(self, req, host, enabled): DCNL 'Sets the specified host\'s ability to accept new servicemanages.'
@wsgi.serializers(xml=HostShowTemplate) DCNL def show(self, req, id): DCNL 'Shows the servicemanage usage info given by hosts. DCNL :param context: security context DCNL :param host: hostname DCNL :returns: expected to use HostShowTemplate. DCNL ex.:: DCNL {\'host\': {\'resource\':D},..} DCNL D: {\'host\': \'hostname\',\'project\': \'admin\', DCNL \'servicemanage_count\': 1, \'total_servicemanage_gb\': 2048}'
@wsgi.serializers(xml=ServiceManageTypeExtraSpecsTemplate) DCNL def index(self, req, type_id): DCNL 'Returns the list of extra specs for a given servicemanage type'
@wsgi.serializers(xml=ServiceManageTypeExtraSpecTemplate) DCNL def show(self, req, type_id, id): DCNL 'Return a single extra spec item.'
def delete(self, req, type_id, id): DCNL 'Deletes an existing extra spec'
def _format_quota_set(self, quota_class, quota_set): DCNL 'Convert the quota object to a result dict'
@wsgi.serializers(xml=ServicesIndexTemplate) DCNL def index(self, req): DCNL 'Return a list of all running services. Filter by host & service name.'
@wsgi.serializers(xml=ServicesUpdateTemplate) DCNL def update(self, req, id, body): DCNL 'Enable/Disable scheduling for a service'
def _format_quota_set(self, project_id, quota_set): DCNL 'Convert the quota object to a result dict'
@wsgi.serializers(xml=BackupTemplate) DCNL def show(self, req, id): DCNL 'Return data about the given backup.'
def delete(self, req, id): DCNL 'Delete a backup.'
@wsgi.serializers(xml=BackupsTemplate) DCNL def index(self, req): DCNL 'Returns a summary list of backups.'
@wsgi.serializers(xml=BackupsTemplate) DCNL def detail(self, req): DCNL 'Returns a detailed list of backups.'
def _get_backups(self, req, is_detail): DCNL 'Returns a list of backups, transformed through view builder.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body): DCNL 'Create a new backup.'
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupRestoreTemplate) DCNL @wsgi.deserializers(xml=RestoreDeserializer) DCNL def restore(self, req, id, body): DCNL 'Restore an existing backup to a servicemanage.'
@wsgi.action('create') DCNL @wsgi.serializers(xml=types.ServiceManageTypeTemplate) DCNL def _create(self, req, body): DCNL 'Creates a new servicemanage type.'
@wsgi.action('delete') DCNL def _delete(self, req, id): DCNL 'Deletes an existing servicemanage type.'
@wsgi.action('os-attach') DCNL def _attach(self, req, id, body): DCNL 'Add attachment metadata.'
@wsgi.action('os-detach') DCNL def _detach(self, req, id, body): DCNL 'Clear attachment metadata.'
@wsgi.action('os-reserve') DCNL def _reserve(self, req, id, body): DCNL 'Mark servicemanage as reserved.'
@wsgi.action('os-unreserve') DCNL def _unreserve(self, req, id, body): DCNL 'Unmark servicemanage as reserved.'
@wsgi.action('os-begin_detaching') DCNL def _begin_detaching(self, req, id, body): DCNL 'Update servicemanage status to \'detaching\'.'
@wsgi.action('os-roll_detaching') DCNL def _roll_detaching(self, req, id, body): DCNL 'Roll back servicemanage status to \'in-use\'.'
@wsgi.action('os-initialize_connection') DCNL def _initialize_connection(self, req, id, body): DCNL 'Initialize servicemanage attachment.'
@wsgi.action('os-terminate_connection') DCNL def _terminate_connection(self, req, id, body): DCNL 'Terminate servicemanage attachment.'
@wsgi.response(202) DCNL @wsgi.action('os-servicemanage_upload_image') DCNL @wsgi.serializers(xml=ServiceManageToImageSerializer) DCNL @wsgi.deserializers(xml=ServiceManageToImageDeserializer) DCNL def _servicemanage_upload_image(self, req, id, body): DCNL 'Uploads the specified servicemanage to image service.'
@wsgi.action('os-reset_status') DCNL def _reset_status(self, req, id, body): DCNL 'Reset status on the resource.'
@wsgi.action('os-force_delete') DCNL def _force_delete(self, req, id, body): DCNL 'Delete a resource, bypassing the check that it must be available.'
@wsgi.action('os-force_detach') DCNL def _force_detach(self, req, id, body): DCNL 'Roll back a bad detach after the servicemanage been disconnected from DCNL the hypervisor.'
@wsgi.serializers(xml=VersionsTemplate, atom=VersionsAtomSerializer) DCNL def index(self, req): DCNL 'Return all versions.'
@wsgi.serializers(xml=ChoicesTemplate) DCNL @wsgi.response(300) DCNL def multi(self, req): DCNL 'Return multiple choices.'
def get_action_args(self, request_environment): DCNL 'Parse dictionary created by routes library.'
def save(self, session=None): DCNL 'Save this object.'
def delete(self, session=None): DCNL 'Delete this object.'
def update(self, values): DCNL 'Make the model object behave like a dict.'
def iteritems(self): DCNL 'Make the model object behave like a dict. DCNL Includes attributes from joins.'
def get(self): DCNL 'Return an item from the pool, when one is available.  This may DCNL cause the calling greenthread to block. Check if a connection is active DCNL before returning it. For dead connections create and return a new DCNL connection.'
def __init__(self, retvalue=True): DCNL ':param retvalue: Value that LoopingCall.wait() should return.'
def rollback_and_reraise(self, msg=None, **kwargs): DCNL 'Rollback a series of actions then re-raise the exception. DCNL .. note:: (sirp) This should only be called within an DCNL exception handler.'
def __init__(self): DCNL 'Initialize the service launcher. DCNL :returns: None'
@staticmethod DCNL def run_server(server): DCNL 'Start and wait for a server to finish. DCNL :param service: Server to run and wait for. DCNL :returns: None'
def launch_server(self, server): DCNL 'Load and start the given server. DCNL :param server: The server you would like to start. DCNL :returns: None'
def stop(self): DCNL 'Stop all services which are currently running. DCNL :returns: None'
def wait(self): DCNL 'Waits until all services have been stopped, and then returns. DCNL :returns: None'
def wait(self): DCNL 'Loop waiting on children to die and respawning as necessary.'
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_interval=None, periodic_fuzzy_delay=None, service_name=None): DCNL 'Instantiates class and passes back application object. DCNL :param host: defaults to FLAGS.host DCNL :param binary: defaults to basename of executable DCNL :param topic: defaults to bin_name - \'monitor-\' part DCNL :param manager: defaults to FLAGS.<topic>_manager DCNL :param report_interval: defaults to FLAGS.report_interval DCNL :param periodic_interval: defaults to FLAGS.periodic_interval DCNL :param periodic_fuzzy_delay: defaults to FLAGS.periodic_fuzzy_delay'
def kill(self): DCNL 'Destroy the service object in the datastore.'
def periodic_tasks(self, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def report_state(self): DCNL 'Update the state of this service in the datastore.'
def __init__(self, name, loader=None): DCNL 'Initialize, but do not start the WSGI server. DCNL :param name: The name of the WSGI server given to the loader. DCNL :param loader: Loads the WSGI application using the given name. DCNL :returns: None'
def _get_manager(self): DCNL 'Initialize a Manager object appropriate for this service. DCNL Use the service name to look up a Manager subclass from the DCNL configuration and initialize an instance. If no class name DCNL is configured, just return None. DCNL :returns: a Manager instance, or None.'
def start(self): DCNL 'Start serving this service using loaded configuration. DCNL Also, retrieve updated port number in case \'0\' was passed in, which DCNL indicates a random port should be used. DCNL :returns: None'
def stop(self): DCNL 'Stop serving this API. DCNL :returns: None'
def wait(self): DCNL 'Wait for the service to stop serving this API. DCNL :returns: None'
def format(self, record): DCNL 'Uses contextstring if request_id is set, otherwise default.'
def formatException(self, exc_info, record=None): DCNL 'Format exception output with CONF.logging_exception_prefix.'
def __init__(self, topic, default_version): DCNL 'Initialize an RpcProxy. DCNL :param topic: The topic to use for all messages. DCNL :param default_version: The default API version to request in all DCNL outgoing messages.  This can be overridden on a per-message DCNL basis.'
def _set_version(self, msg, vers): DCNL 'Helper method to set the version in a message. DCNL :param msg: The message having a version added to it. DCNL :param vers: The version number to add to the message.'
def _get_topic(self, topic): DCNL 'Return the topic to use for a message.'
def call(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.call() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: The return value from the remote method.'
def multicall(self, context, msg, topic=None, version=None, timeout=None): DCNL 'rpc.multicall() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param timeout: (Optional) A timeout to use when waiting for the DCNL response.  If no timeout is specified, a default timeout will be DCNL used that is usually sufficient. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: An iterator that lets you process each of the returned values DCNL from the remote method as they arrive.'
def cast(self, context, msg, topic=None, version=None): DCNL 'rpc.cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast() does not wait on any return value from the DCNL remote method.'
def fanout_cast(self, context, msg, topic=None, version=None): DCNL 'rpc.fanout_cast() a remote method. DCNL :param context: The request context DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast() does not wait on any return value DCNL from the remote method.'
def cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.cast_to_server() does not wait on any DCNL return values.'
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None): DCNL 'rpc.fanout_cast_to_server() a remote method. DCNL :param context: The request context DCNL :param server_params: Server parameters.  See rpc.cast_to_server() for DCNL details. DCNL :param msg: The message to send, including the method and args. DCNL :param topic: Override the topic for this message. DCNL :param version: (Optional) Override the requested API version in this DCNL message. DCNL :returns: None.  rpc.fanout_cast_to_server() does not wait on any DCNL return values.'
def __init__(self, conf, connection_pool, pooled=True, server_params=None): DCNL 'Create a new connection, or get one from the pool'
def __enter__(self): DCNL 'When with ConnectionContext() is used, return self'
def _done(self): DCNL 'If the connection came from a pool, clean it up and put it back. DCNL If it did not come from a pool, close it.'
def __exit__(self, exc_type, exc_value, tb): DCNL 'End of \'with\' statement.  We\'re done here.'
def __del__(self): DCNL 'Caller is done with this connection.  Make sure we cleaned up.'
def close(self): DCNL 'Caller is done with this connection.'
def __getattr__(self, key): DCNL 'Proxy all other calls to the Connection instance'
def check_duplicate_message(self, message_data): DCNL 'AMQP consumers may read same message twice when exceptions occur DCNL before ack is returned. This method prevents doing it.'
def wait(self): DCNL 'Wait for all callback threads to exit.'
def __init__(self, conf, callback, connection_pool): DCNL ':param conf: cfg.CONF instance DCNL :param callback: a callable (probably a function) DCNL :param connection_pool: connection pool as returned by DCNL get_connection_pool()'
def __call__(self, message_data): DCNL 'Consumer callback to call a method on a proxy object. DCNL Parses the message for validity and fires off a thread to call the DCNL proxy object method. DCNL Message data should be a dictionary with two keys: DCNL method: string representing the method to call DCNL args: dictionary of arg: value DCNL Example: {\'method\': \'echo\', \'args\': {\'value\': 42}}'
def _process_data(self, ctxt, version, method, args): DCNL 'Process a message in a new thread. DCNL If the proxy object we have has a dispatch method DCNL (see rpc.dispatcher.RpcDispatcher), pass it the version, DCNL method, and args and let it dispatch as appropriate.  If not, use DCNL the old behavior of magically calling the specified method on the DCNL proxy we have here.'
def __iter__(self): DCNL 'Return a result until we get a reply with an \'ending" flag'
def __call__(self, data): DCNL 'The consume() callback will call this.  Store the result.'
def __iter__(self): DCNL 'Return a result until we get a \'None\' response from consumer'
def __init__(self, callbacks): DCNL 'Initialize the rpc dispatcher. DCNL :param callbacks: List of proxy objects that are an instance DCNL of a class with rpc methods exposed.  Each proxy DCNL object should have an RPC_API_VERSION attribute.'
def dispatch(self, ctxt, version, method, **kwargs): DCNL 'Dispatch a message based on a requested version. DCNL :param ctxt: The request context DCNL :param version: The requested API version from the incoming message DCNL :param method: The method requested to be called by the incoming DCNL message. DCNL :param kwargs: A dict of keyword arguments to be passed to the method. DCNL :returns: Whatever is returned by the underlying method that gets DCNL called.'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a key.host is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def is_alive(self, topic, host): DCNL 'Checks if a host is alive.'
def expire(self, topic, host): DCNL 'Explicitly expire a host\'s registration.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Spawn heartbeat greenthread.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def send_heartbeats(self): DCNL 'Send all heartbeats. DCNL Use start_heartbeat to spawn a heartbeat greenthread, DCNL which loops this method.'
def ack_alive(self, key, host): DCNL 'Acknowledge that a host.topic is alive. DCNL Used internally for updating heartbeats, DCNL but may also be used publically to acknowledge DCNL a system is alive (i.e. rpc message successfully DCNL sent to host)'
def backend_register(self, key, host): DCNL 'Implements registration logic. DCNL Called by register(self,key,host)'
def backend_unregister(self, key, key_host): DCNL 'Implements de-registration logic. DCNL Called by unregister(self,key,host)'
def register(self, key, host): DCNL 'Register a host on a backend. DCNL Heartbeats, if applicable, may keepalive registration.'
def unregister(self, key, host): DCNL 'Unregister a topic.'
def start_heartbeat(self): DCNL 'Implementation of MatchMakerBase.start_heartbeat DCNL Launches greenthread looping send_heartbeats(), DCNL yielding for CONF.matchmaker_heartbeat_freq seconds DCNL between iterations.'
def stop_heartbeat(self): DCNL 'Destroys the heartbeat greenthread.'
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts): DCNL 'Declare a queue on an amqp session. DCNL \'session\' is the amqp session to use DCNL \'callback\' is the callback to call when messages are received DCNL \'node_name\' is the first part of the Qpid address string, before \';\' DCNL \'node_opts\' will be applied to the "x-declare" section of "node" DCNL in the address string. DCNL \'link_name\' goes into the "name" field of the "link" in the address DCNL string DCNL \'link_opts\' will be applied to the "x-declare" section of "link" DCNL in the address string.'
def reconnect(self, session): DCNL 'Re-declare the receiver after a qpid reconnect'
def consume(self): DCNL 'Fetch the message and pass it to the callback object'
def __init__(self, conf, session, msg_id, callback): DCNL 'Init a \'direct\' queue. DCNL \'session\' is the amqp session to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None): DCNL 'Init a \'topic\' queue. DCNL :param session: the amqp session to use DCNL :param topic: is the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param name: optional queue name, defaults to topic'
def __init__(self, conf, session, topic, callback): DCNL 'Init a \'fanout\' queue. DCNL \'session\' is the amqp session to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received'
def __init__(self, session, node_name, node_opts=None): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, session): DCNL 'Re-establish the Sender after a reconnection'
def send(self, msg): DCNL 'Send a message'
def __init__(self, conf, session, msg_id): DCNL 'Init a \'direct\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'fanout\' publisher.'
def __init__(self, conf, session, topic): DCNL 'init a \'topic\' publisher.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing sessions and queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
def socket_s(self): DCNL 'Get socket type as string.'
def subscribe(self, msg_filter): DCNL 'Subscribe.'
def unsubscribe(self, msg_filter): DCNL 'Unsubscribe.'
def _get_response(self, ctx, proxy, topic, data): DCNL 'Process a curried message and cast the result to topic.'
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None): DCNL 'Reply to a casted call.'
def consume_in_thread(self): DCNL 'Runs the ZmqProxy service'
def close(self): DCNL 'Close the connection. DCNL This method must be called when the connection will no longer be used. DCNL It will ensure that any resources associated with the connection, such DCNL as a network connection, and cleaned up.'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer on this connection. DCNL A consumer is associated with a message queue on the backend message DCNL bus.  The consumer will read messages from the queue, unpack them, and DCNL dispatch them to the proxy object.  The contents of the message pulled DCNL off of the queue will determine which method gets called on the proxy DCNL object. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. For example, all instances of nova-compute consume DCNL from a queue called "compute".  In that case, the DCNL messages will get distributed amongst the consumers in a DCNL round-robin fashion if fanout=False.  If fanout=True, DCNL every consumer associated with this topic will get a DCNL copy of every message. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param fanout: Whether or not this is a fanout topic.  See the DCNL documentation for the topic parameter for some DCNL additional comments on this.'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker on this connection. DCNL A worker is like a regular consumer of messages directed to a DCNL topic, except that it is part of a set of such consumers (the DCNL "pool") which may run in parallel. Every pool of workers will DCNL receive a given message, but only one worker in the pool will DCNL be asked to process it. Load is distributed across the members DCNL of the pool in round-robin fashion. DCNL :param topic: This is a name associated with what to consume from. DCNL Multiple instances of a service may consume from the same DCNL topic. DCNL :param proxy: The object that will handle all incoming messages. DCNL :param pool_name: String containing the name of the pool of workers'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created. DCNL :param callback: Callable to be invoked for each message. DCNL :type callback: callable accepting one argument DCNL :param pool_name: The name of the consumer pool. DCNL :type pool_name: str DCNL :param topic: The routing topic for desired messages. DCNL :type topic: str DCNL :param exchange_name: The name of the message exchange where DCNL the client should attach. Defaults to DCNL the configured exchange. DCNL :type exchange_name: str'
def consume_in_thread(self): DCNL 'Spawn a thread to handle incoming messages. DCNL Spawn a thread that will be responsible for handling all incoming DCNL messages for consumers that were set up on this connection. DCNL Message dispatching inside of this is expected to be implemented in a DCNL non-blocking manner.  An example implementation would be having this DCNL thread pull messages in for all of the consumers, but utilize a thread DCNL pool for dispatching the messages to the proxy objects.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
def __init__(self, channel, callback, tag, **kwargs): DCNL 'Declare a queue on an amqp channel. DCNL \'channel\' is the amqp channel to use DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL queue name, exchange name, and other kombu options are DCNL passed in here as a dictionary.'
def reconnect(self, channel): DCNL 'Re-declare the queue after a rabbit reconnect'
def consume(self, *args, **kwargs): DCNL 'Actually declare the consumer on the amqp channel.  This will DCNL start the flow of messages from the queue.  Using the DCNL Connection.iterconsume() iterator will process the messages, DCNL calling the appropriate callback. DCNL If a callback is specified in kwargs, use that.  Otherwise, DCNL use the callback passed during __init__() DCNL If kwargs[\'nowait\'] is True, then this call will block until DCNL a message is read. DCNL Messages will automatically be acked if the callback doesn\'t DCNL raise an exception'
def cancel(self): DCNL 'Cancel the consuming from the queue, if it has started'
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs): DCNL 'Init a \'direct\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'msg_id\' is the msg_id to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs): DCNL 'Init a \'topic\' queue. DCNL :param channel: the amqp channel to use DCNL :param topic: the topic to listen on DCNL :paramtype topic: str DCNL :param callback: the callback to call when messages are received DCNL :param tag: a unique ID for the consumer on the channel DCNL :param name: optional queue name, defaults to topic DCNL :paramtype name: str DCNL Other kombu options may be passed as keyword arguments'
def __init__(self, conf, channel, topic, callback, tag, **kwargs): DCNL 'Init a \'fanout\' queue. DCNL \'channel\' is the amqp channel to use DCNL \'topic\' is the topic to listen on DCNL \'callback\' is the callback to call when messages are received DCNL \'tag\' is a unique ID for the consumer on the channel DCNL Other kombu options may be passed'
def __init__(self, channel, exchange_name, routing_key, **kwargs): DCNL 'Init the Publisher class with the exchange_name, routing_key, DCNL and other options'
def reconnect(self, channel): DCNL 'Re-establish the Producer after a rabbit reconnection'
def send(self, msg, timeout=None): DCNL 'Send a message'
def __init__(self, conf, channel, msg_id, **kwargs): DCNL 'init a \'direct\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'topic\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def __init__(self, conf, channel, topic, **kwargs): DCNL 'init a \'fanout\' publisher. DCNL Kombu options may be passed as keyword args to override defaults'
def _fetch_ssl_params(self): DCNL 'Handles fetching what ssl params DCNL should be used for the connection (if any)'
def _connect(self, params): DCNL 'Connect to rabbit.  Re-establish any queues that may have DCNL been declared before if we are reconnecting.  Exceptions should DCNL be handled by the caller.'
def reconnect(self): DCNL 'Handles reconnecting and re-establishing queues. DCNL Will retry up to self.max_retries number of times. DCNL self.max_retries = 0 means to retry forever. DCNL Sleep between tries, starting at self.interval_start DCNL seconds, backing off self.interval_stepping number of seconds DCNL each attempt.'
def get_channel(self): DCNL 'Convenience call for bin/clear_rabbit_queues'
def close(self): DCNL 'Close/release this connection'
def reset(self): DCNL 'Reset a connection so it can be used again'
def declare_consumer(self, consumer_cls, topic, callback): DCNL 'Create a Consumer using the class that was passed in and DCNL add it to our list of consumers'
def iterconsume(self, limit=None, timeout=None): DCNL 'Return an iterator that will consume from all queues/consumers'
def cancel_consumer_thread(self): DCNL 'Cancel a consumer thread'
def wait_on_proxy_callbacks(self): DCNL 'Wait for all proxy callback threads to exit.'
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs): DCNL 'Send to a publisher based on the publisher class'
def declare_direct_consumer(self, topic, callback): DCNL 'Create a \'direct\' queue. DCNL In nova\'s use, this is generally a msg_id queue used for DCNL responses for call/multicall'
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None): DCNL 'Create a \'topic\' consumer.'
def declare_fanout_consumer(self, topic, callback): DCNL 'Create a \'fanout\' consumer'
def direct_send(self, msg_id, msg): DCNL 'Send a \'direct\' message'
def topic_send(self, topic, msg, timeout=None): DCNL 'Send a \'topic\' message'
def fanout_send(self, topic, msg): DCNL 'Send a \'fanout\' message'
def notify_send(self, topic, msg, **kwargs): DCNL 'Send a notify message on a topic'
def consume(self, limit=None): DCNL 'Consume from all queues/consumers'
def consume_in_thread(self): DCNL 'Consumer from all queues/consumers in a greenthread'
def create_consumer(self, topic, proxy, fanout=False): DCNL 'Create a consumer that calls a method in a proxy object'
def create_worker(self, topic, proxy, pool_name): DCNL 'Create a worker that calls a method in a proxy object'
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None): DCNL 'Register as a member of a group of consumers for a given topic from DCNL the specified exchange. DCNL Exactly one member of a given pool will receive each message. DCNL A message will be delivered to multiple pools, if more than DCNL one is created.'
@classmethod DCNL def load_json(cls, data, default_rule=None): DCNL 'Init a brain using json instead of a rules dictionary.'
def check(self, match_list, target_dict, cred_dict): DCNL 'Checks authorization of some rules against credentials. DCNL Detailed description of the check with examples in policy.enforce(). DCNL :param match_list: nested tuples of data to match against DCNL :param target_dict: dict of object properties DCNL :param credentials_dict: dict of actor properties DCNL :returns: True if the check passes'
def __init__(self, package): DCNL 'Object that understands versioning for a package DCNL :param package: name of the python package, such as glance, or DCNL python-glanceclient'
def __str__(self): DCNL 'Make the VersionInfo object behave like a string.'
def __repr__(self): DCNL 'Include the name.'
def _get_version_from_pkg_resources(self): DCNL 'Get the version of the package from the pkg_resources record DCNL associated with the package.'
def release_string(self): DCNL 'Return the full version of the package including suffixes indicating DCNL VCS status.'
def version_string(self): DCNL 'Return the short version minus any alpha/beta tags.'
def cached_version_string(self, prefix=''): DCNL 'Generate an object which will expand in a string context to DCNL the results of version_string(). We do this so that don\'t DCNL call into pkg_resources every time we start up a program when DCNL passing version information into the CONF constructor, but DCNL rather only do the calculation when and if a version is requested'
def _weight_multiplier(self): DCNL 'How weighted this weigher should be.  Normally this would DCNL be overriden in a subclass based on a config value.'
def _weigh_object(self, obj, weight_properties): DCNL 'Override in a subclass to specify a weight for a specific DCNL object.'
def weigh_objects(self, weighed_obj_list, weight_properties): DCNL 'Weigh multiple objects.  Override in a subclass if you need DCNL need access to all objects in order to manipulate weights.'
def _is_correct_class(self, obj): DCNL 'Return whether an object is a class of the correct type and DCNL is not prefixed with an underscore.'
def get_weighed_objects(self, weigher_classes, obj_list, weighing_properties): DCNL 'Return a sorted (highest score first) list of WeighedObjects.'
def _filter_one(self, obj, filter_properties): DCNL 'Return True if the object passes the filter, otherwise False.'
def host_passes(self, host_state, filter_properties): DCNL 'Return True if the HostState passes the filter, otherwise False. DCNL Override this in a subclass.'
def _satisfies_extra_specs(self, capabilities, resource_type): DCNL 'Check that the capabilities provided by the services DCNL satisfy the extra specs associated with the instance type'
def host_passes(self, host_state, filter_properties): DCNL 'Return a list of hosts that can create instance_type.'
def _op_compare(self, args, op): DCNL 'Returns True if the specified operator can successfully DCNL compare the first item in the args with all the rest. Will DCNL return False if only one item is in the list.'
def _equals(self, args): DCNL 'First term is == all the other terms.'
def _less_than(self, args): DCNL 'First term is < all the other terms.'
def _greater_than(self, args): DCNL 'First term is > all the other terms.'
def _in(self, args): DCNL 'First term is in set of remaining terms'
def _less_than_equal(self, args): DCNL 'First term is <= all the other terms.'
def _greater_than_equal(self, args): DCNL 'First term is >= all the other terms.'
def _not(self, args): DCNL 'Flip each of the arguments.'
def _or(self, args): DCNL 'True if any arg is True.'
def _and(self, args): DCNL 'True if all args are True.'
def _parse_string(self, string, host_state): DCNL 'Strings prefixed with $ are capability lookups in the DCNL form \'$variable\' where \'variable\' is an attribute in the DCNL HostState class.  If $variable is a dictionary, you may DCNL use: $variable.dictkey'
def _process_filter(self, query, host_state): DCNL 'Recursively parse the query structure.'
def host_passes(self, host_state, filter_properties): DCNL 'Return a list of hosts that can fulfill the requirements DCNL specified in the query.'
def _filter_one(self, obj, filter_properties): DCNL 'Return True if it passes the filter, False otherwise. DCNL Override this in a subclass.'
def filter_all(self, filter_obj_list, filter_properties): DCNL 'Yield objects that pass the filter. DCNL Can be overriden in a subclass, if you need to base filtering DCNL decisions on all objects.  Otherwise, one can just override DCNL _filter_one() to filter a single object.'
def _is_correct_class(self, obj): DCNL 'Return whether an object is a class of the correct type and DCNL is not prefixed with an underscore.'
def get_exec(self, exec_dirs=[]): DCNL 'Returns existing executable, or empty string if none found'
def match(self, userargs): DCNL 'Only check that the first argument (command) matches exec_path'
def get_command(self, userargs, exec_dirs=[]): DCNL 'Returns command to execute (with sudo -u if run_as != root).'
def get_environment(self, userargs): DCNL 'Returns specific environment to set, None if none'
def __init__(cls, names, bases, dict_): DCNL 'Metaclass that allows us to collect decorated periodic tasks.'
def create_rpc_dispatcher(self): DCNL 'Get the rpc dispatcher for this manager. DCNL If a manager would like to set an rpc API version, or support more than DCNL one class as the target of rpc messages, override this method.'
def periodic_tasks(self, context, raise_on_error=False): DCNL 'Tasks to be run at a periodic interval.'
def init_host(self): DCNL 'Handle initialization if this is a standalone service. DCNL Child classes should override this method.'
def get_by_project(self, context, project_id, resource): DCNL 'Get a specific quota by project.'
def get_by_class(self, context, quota_class, resource): DCNL 'Get a specific quota by quota class.'
def get_defaults(self, context, resources): DCNL 'Given a list of resources, retrieve the default quotas. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources.'
def get_class_quotas(self, context, resources, quota_class, defaults=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL quota class. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param quota_class: The name of the quota class to return DCNL quotas for. DCNL :param defaults: If True, the default value will be reported DCNL if there is no specific value for the DCNL resource.'
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True): DCNL 'Given a list of resources, retrieve the quotas for the given DCNL project. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param project_id: The ID of the project to return quotas for. DCNL :param quota_class: If project_id != context.project_id, the DCNL quota class cannot be determined.  This DCNL parameter allows it to be specified.  It DCNL will be ignored if project_id == DCNL context.project_id. DCNL :param defaults: If True, the quota class value (or the DCNL default value, if there is no value from the DCNL quota class) will be reported if there is no DCNL specific value for the resource. DCNL :param usages: If True, the current in_use and reserved counts DCNL will also be returned.'
def _get_quotas(self, context, resources, keys, has_sync, project_id=None): DCNL 'A helper method which retrieves the quotas for the specific DCNL resources identified by keys, and which apply to the current DCNL context. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param keys: A list of the desired quotas to retrieve. DCNL :param has_sync: If True, indicates that the resource must DCNL have a sync attribute; if False, indicates DCNL that the resource must NOT have a sync DCNL attribute. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def limit_check(self, context, resources, values, project_id=None): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param values: A dictionary of the values to check against the DCNL quota. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def reserve(self, context, resources, deltas, expire=None, project_id=None): DCNL 'Check quotas and reserve resources. DCNL For counting quotas--those quotas for which there is a usage DCNL synchronization function--this method checks quotas against DCNL current usage and the desired deltas. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it does not have a usage DCNL synchronization function. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns a DCNL list of reservation UUIDs which were created. DCNL :param context: The request context, for access checks. DCNL :param resources: A dictionary of the registered resources. DCNL :param deltas: A dictionary of the proposed delta changes. DCNL :param expire: An optional parameter specifying an expiration DCNL time for the reservations.  If it is a simple DCNL number, it is interpreted as a number of DCNL seconds and added to the current time; if it is DCNL a datetime.timedelta object, it will also be DCNL added to the current time.  A datetime.datetime DCNL object will be interpreted as the absolute DCNL expiration time.  If None is specified, the DCNL default expiration time set by DCNL --default-reservation-expire will be used (this DCNL value will be treated as a number of seconds). DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def commit(self, context, reservations, project_id=None): DCNL 'Commit reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def rollback(self, context, reservations, project_id=None): DCNL 'Roll back reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def destroy_all_by_project(self, context, project_id): DCNL 'Destroy all quotas, usages, and reservations associated with a DCNL project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project being deleted.'
def expire(self, context): DCNL 'Expire reservations. DCNL Explores all currently existing reservations and rolls back DCNL any that have expired. DCNL :param context: The request context, for access checks.'
def __init__(self, name, flag=None): DCNL 'Initializes a Resource. DCNL :param name: The name of the resource, i.e., "servicemanages". DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def quota(self, driver, context, **kwargs): DCNL 'Given a driver and context, obtain the quota for this DCNL resource. DCNL :param driver: A quota driver. DCNL :param context: The request context. DCNL :param project_id: The project to obtain the quota value for. DCNL If not provided, it is taken from the DCNL context.  If it is given as None, no DCNL project-specific quota will be searched DCNL for. DCNL :param quota_class: The quota class corresponding to the DCNL project, or for which the quota is to be DCNL looked up.  If not provided, it is taken DCNL from the context.  If it is given as None, DCNL no quota class-specific quota will be DCNL searched for.  Note that the quota class DCNL defaults to the value in the context, DCNL which may not correspond to the project if DCNL project_id is not the same as the one in DCNL the context.'
@property DCNL def default(self): DCNL 'Return the default value of the quota.'
def __init__(self, name, sync, flag=None): DCNL 'Initializes a ReservableResource. DCNL Reservable resources are those resources which directly DCNL correspond to objects in the database, i.e., servicemanages, gigabytes, DCNL etc.  A ReservableResource must be constructed with a usage DCNL synchronization function, which will be called to determine the DCNL current counts of one or more resources. DCNL The usage synchronization function will be passed three DCNL arguments: an admin context, the project ID, and an opaque DCNL session object, which should in turn be passed to the DCNL underlying database function.  Synchronization functions DCNL should return a dictionary mapping resource names to the DCNL current in_use count for those resources; more than one DCNL resource and resource count may be returned.  Note that DCNL synchronization functions may be associated with more than one DCNL ReservableResource. DCNL :param name: The name of the resource, i.e., "servicemanages". DCNL :param sync: A callable which returns a dictionary to DCNL resynchronize the in_use count for one or more DCNL resources, as described above. DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def __init__(self, name, count, flag=None): DCNL 'Initializes a CountableResource. DCNL Countable resources are those resources which directly DCNL correspond to objects in the database, i.e., servicemanages, gigabytes, DCNL etc., but for which a count by project ID is inappropriate.  A DCNL CountableResource must be constructed with a counting DCNL function, which will be called to determine the current counts DCNL of the resource. DCNL The counting function will be passed the context, along with DCNL the extra positional and keyword arguments that are passed to DCNL Quota.count().  It should return an integer specifying the DCNL count. DCNL Note that this counting is not performed in a transaction-safe DCNL manner.  This resource class is a temporary measure to provide DCNL required functionality, until a better approach to solving DCNL this problem can be evolved. DCNL :param name: The name of the resource, i.e., "servicemanages". DCNL :param count: A callable which returns the count of the DCNL resource.  The arguments passed are as described DCNL above. DCNL :param flag: The name of the flag or configuration option DCNL which specifies the default value of the quota DCNL for this resource.'
def __init__(self, quota_driver_class=None): DCNL 'Initialize a Quota object.'
def register_resource(self, resource): DCNL 'Register a resource.'
def register_resources(self, resources): DCNL 'Register a list of resources.'
def get_by_project(self, context, project_id, resource): DCNL 'Get a specific quota by project.'
def get_by_class(self, context, quota_class, resource): DCNL 'Get a specific quota by quota class.'
def get_defaults(self, context): DCNL 'Retrieve the default quotas. DCNL :param context: The request context, for access checks.'
def get_class_quotas(self, context, quota_class, defaults=True): DCNL 'Retrieve the quotas for the given quota class. DCNL :param context: The request context, for access checks. DCNL :param quota_class: The name of the quota class to return DCNL quotas for. DCNL :param defaults: If True, the default value will be reported DCNL if there is no specific value for the DCNL resource.'
def get_project_quotas(self, context, project_id, quota_class=None, defaults=True, usages=True): DCNL 'Retrieve the quotas for the given project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project to return quotas for. DCNL :param quota_class: If project_id != context.project_id, the DCNL quota class cannot be determined.  This DCNL parameter allows it to be specified. DCNL :param defaults: If True, the quota class value (or the DCNL default value, if there is no value from the DCNL quota class) will be reported if there is no DCNL specific value for the resource. DCNL :param usages: If True, the current in_use and reserved counts DCNL will also be returned.'
def count(self, context, resource, *args, **kwargs): DCNL 'Count a resource. DCNL For countable resources, invokes the count() function and DCNL returns its result.  Arguments following the context and DCNL resource are passed directly to the count function declared by DCNL the resource. DCNL :param context: The request context, for access checks. DCNL :param resource: The name of the resource, as a string.'
def limit_check(self, context, project_id=None, **values): DCNL 'Check simple quota limits. DCNL For limits--those quotas for which there is no usage DCNL synchronization function--this method checks that a set of DCNL proposed values are permitted by the limit restriction.  The DCNL values to check are given as keyword arguments, where the key DCNL identifies the specific quota limit to check, and the value is DCNL the proposed value. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it is not a simple limit DCNL resource. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns DCNL nothing. DCNL :param context: The request context, for access checks. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def reserve(self, context, expire=None, project_id=None, **deltas): DCNL 'Check quotas and reserve resources. DCNL For counting quotas--those quotas for which there is a usage DCNL synchronization function--this method checks quotas against DCNL current usage and the desired deltas.  The deltas are given as DCNL keyword arguments, and current usage and other reservations DCNL are factored into the quota check. DCNL This method will raise a QuotaResourceUnknown exception if a DCNL given resource is unknown or if it does not have a usage DCNL synchronization function. DCNL If any of the proposed values is over the defined quota, an DCNL OverQuota exception will be raised with the sorted list of the DCNL resources which are too high.  Otherwise, the method returns a DCNL list of reservation UUIDs which were created. DCNL :param context: The request context, for access checks. DCNL :param expire: An optional parameter specifying an expiration DCNL time for the reservations.  If it is a simple DCNL number, it is interpreted as a number of DCNL seconds and added to the current time; if it is DCNL a datetime.timedelta object, it will also be DCNL added to the current time.  A datetime.datetime DCNL object will be interpreted as the absolute DCNL expiration time.  If None is specified, the DCNL default expiration time set by DCNL --default-reservation-expire will be used (this DCNL value will be treated as a number of seconds). DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def commit(self, context, reservations, project_id=None): DCNL 'Commit reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def rollback(self, context, reservations, project_id=None): DCNL 'Roll back reservations. DCNL :param context: The request context, for access checks. DCNL :param reservations: A list of the reservation UUIDs, as DCNL returned by the reserve() method. DCNL :param project_id: Specify the project_id if current context DCNL is admin and admin wants to impact on DCNL common user\'s tenant.'
def destroy_all_by_project(self, context, project_id): DCNL 'Destroy all quotas, usages, and reservations associated with a DCNL project. DCNL :param context: The request context, for access checks. DCNL :param project_id: The ID of the project being deleted.'
def expire(self, context): DCNL 'Expire reservations. DCNL Explores all currently existing reservations and rolls back DCNL any that have expired. DCNL :param context: The request context, for access checks.'
def __init__(self, name, app, host=None, port=None, pool_size=None, protocol=eventlet.wsgi.HttpProtocol): DCNL 'Initialize, but do not start, a WSGI server. DCNL :param name: Pretty name for logging. DCNL :param app: The WSGI application to serve. DCNL :param host: IP address to serve the application. DCNL :param port: Port number to server the application. DCNL :param pool_size: Maximum number of eventlets to spawn concurrently. DCNL :returns: None'
def _start(self): DCNL 'Run the blocking eventlet WSGI server. DCNL :returns: None'
def start(self, backlog=128): DCNL 'Start serving a WSGI application. DCNL :param backlog: Maximum number of queued connections. DCNL :returns: None DCNL :raises: monitor.exception.InvalidInput'
def stop(self): DCNL 'Stop this server. DCNL This is not a very nice action, as currently the method by which a DCNL server is stopped is by killing its eventlet. DCNL :returns: None'
def wait(self): DCNL 'Block, until the server has stopped. DCNL Waits on the server\'s eventlet to finish, then returns. DCNL :returns: None'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [app:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [app:wadl] DCNL latest_version = 1.3 DCNL paste.app_factory = monitor.api.fancy_api:Wadl.factory DCNL which would result in a call to the `Wadl` class as DCNL import monitor.api.fancy_api DCNL fancy_api.Wadl(latest_version=\'1.3\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def __call__(self, environ, start_response): DCNL 'Subclasses will probably want to implement __call__ like this: DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL # Any of the following objects work as responses: DCNL # Option 1: simple string DCNL res = \'message\n\' DCNL # Option 2: a nicely formatted HTTP exception page DCNL res = exc.HTTPForbidden(detail=\'Nice try\') DCNL # Option 3: a webob Response object (in case you need to play with DCNL # headers, or you want to be treated like an iterable, or or or) DCNL res = Response(); DCNL res.app_iter = open(\'somefile\') DCNL # Option 4: any wsgi app to be run next DCNL res = self.application DCNL # Option 5: you can get a Response object for a wsgi app, too, to DCNL # play with headers etc DCNL res = req.get_response(self.application) DCNL # You can then just return your response... DCNL return res DCNL # ... or set req.response and return None. DCNL req.response = res DCNL See the end of http://pythonpaste.org/webob/modules/dec.html DCNL for more info.'
@classmethod DCNL def factory(cls, global_config, **local_config): DCNL 'Used for paste app factories in paste.deploy config files. DCNL Any local configuration (that is, values under the [filter:APPNAME] DCNL section of the paste config) will be passed into the `__init__` method DCNL as kwargs. DCNL A hypothetical configuration would look like: DCNL [filter:analytics] DCNL redis_host = 127.0.0.1 DCNL paste.filter_factory = monitor.api.analytics:Analytics.factory DCNL which would result in a call to the `Analytics` class as DCNL import monitor.api.analytics DCNL analytics.Analytics(app_from_paste, redis_host=\'127.0.0.1\') DCNL You could of course re-implement the `factory` method in subclasses, DCNL but using the kwarg passing it shouldn\'t be necessary.'
def process_request(self, req): DCNL 'Called on each request. DCNL If this returns None, the next application down the stack will be DCNL executed. If it returns a response then that response will be returned DCNL and execution will stop here.'
def process_response(self, response): DCNL 'Do whatever you\'d like to the response.'
@staticmethod DCNL def print_generator(app_iter): DCNL 'Iterator that prints the contents of a wrapper string.'
def __init__(self, mapper): DCNL 'Create a router for the given routes.Mapper. DCNL Each route in `mapper` must specify a \'controller\', which is a DCNL WSGI app to call.  You\'ll probably want to specify an \'action\' as DCNL well and have your controller be an object that can route DCNL the request to the action-specific method. DCNL Examples: DCNL mapper = routes.Mapper() DCNL sc = ServerController() DCNL # Explicit mapping of one route to a controller+action DCNL mapper.connect(None, \'/svrlist\', controller=sc, action=\'list\') DCNL # Actions are all implicitly defined DCNL mapper.resource(\'server\', \'servers\', controller=sc) DCNL # Pointing to an arbitrary WSGI app.  You can specify the DCNL # {path_info:.*} parameter so the target app can be handed just that DCNL # section of the URL. DCNL mapper.connect(None, \'/v1.0/{path_info:.*}\', controller=BlogApp())'
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req): DCNL 'Route the incoming request to a controller based on self.map. DCNL If no match, return a 404.'
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req): DCNL 'Dispatch the request to the appropriate controller. DCNL Called by self._router after matching the incoming request to a route DCNL and putting the information into req.environ.  Either returns 404 DCNL or the routed WSGI app\'s response.'
def __init__(self, config_path=None): DCNL 'Initialize the loader, and attempt to find the config. DCNL :param config_path: Full or relative path to the paste config. DCNL :returns: None'
def load_app(self, name): DCNL 'Return the paste URLMap wrapped WSGI application. DCNL :param name: Name of the application to load. DCNL :returns: Paste URLMap object wrapping the requested application. DCNL :raises: `monitor.exception.PasteAppNotFound`'
def __init__(self, user_id, project_id, is_admin=None, read_deleted='no', roles=None, remote_address=None, timestamp=None, request_id=None, auth_token=None, overwrite=True, quota_class=None, **kwargs): DCNL ':param read_deleted: \'no\' indicates deleted records are hidden, \'yes\' DCNL indicates deleted records are visible, \'only\' indicates that DCNL *only* deleted records are visible. DCNL :param overwrite: Set to False to ensure that the greenthread local DCNL copy of the index is not overwritten. DCNL :param kwargs: Extra arguments that might be present, but we ignore DCNL because they possibly came in from older rpc messages.'
def elevated(self, read_deleted=None, overwrite=False): DCNL 'Return a version of this context with admin flag set.'
