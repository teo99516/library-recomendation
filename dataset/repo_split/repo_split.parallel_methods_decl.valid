def __init__(self):
def XXX11():
def cleanup(self):
def disassemble(self, co, classname=None, deob=0):
def first_instr(self, start, end, instr, target=None, exact=True):
def last_instr(self, start, end, instr, target=None, exact=True):
def all_instr(self, start, end, instr, target=None, include_beyond_target=False):
def rem_or(self, start, end, instr, target=None, include_beyond_target=False):
def next_except_jump(self, start):
def restrict_to_parent(self, target, parent):
def detect_structure(self, pos, op=None):
def find_jump_targets(self, code):
def n_exec_stmt(self, node):
def n_mapexpr(self, node):
def n_build_list(self, node):
def customize(self, customize):
def get_tuple_parameter(self, ast, name):
def make_function(self, node, isLambda, nested=1):
def build_class(self, code):
def gen_source(self, ast, customize, isLambda=0, returnNone=False):
def __repr__(self):
def __get__(self, obj, objtype):
@staticmethod DCNL def from_param(this):
def event_attach(self, eventtype, callback, *args, **kwds):
def event_detach(self, eventtype):
def media_player_new(self, uri=None):
def media_list_player_new(self):
def media_new(self, mrl, *options):
def media_list_new(self, mrls=None):
def audio_output_enumerate_devices(self):
def audio_filter_list_get(self):
def video_filter_list_get(self):
def release(self):
def retain(self):
def add_intf(self, name):
def set_user_agent(self, name, http):
def set_app_id(self, id, version, icon):
def log_unset(self):
def log_set(self, data, p_instance):
def log_set_file(self, stream):
def media_new_location(self, psz_mrl):
def media_new_path(self, path):
def media_new_fd(self, fd):
def media_new_callbacks(self, open_cb, read_cb, seek_cb, close_cb, opaque):
def media_new_as_node(self, psz_name):
def media_discoverer_new(self, psz_name):
def media_library_new(self):
def audio_output_list_get(self):
def audio_output_device_list_get(self, aout):
def vlm_release(self):
def vlm_add_broadcast(self, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop):
def vlm_add_vod(self, psz_name, psz_input, i_options, ppsz_options, b_enabled, psz_mux):
def vlm_del_media(self, psz_name):
def vlm_set_enabled(self, psz_name, b_enabled):
def vlm_set_output(self, psz_name, psz_output):
def vlm_set_input(self, psz_name, psz_input):
def vlm_add_input(self, psz_name, psz_input):
def vlm_set_loop(self, psz_name, b_loop):
def vlm_set_mux(self, psz_name, psz_mux):
def vlm_change_media(self, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop):
def vlm_play_media(self, psz_name):
def vlm_stop_media(self, psz_name):
def vlm_pause_media(self, psz_name):
def vlm_seek_media(self, psz_name, f_percentage):
def vlm_show_media(self, psz_name):
def vlm_get_media_instance_position(self, psz_name, i_instance):
def vlm_get_media_instance_time(self, psz_name, i_instance):
def vlm_get_media_instance_length(self, psz_name, i_instance):
def vlm_get_media_instance_rate(self, psz_name, i_instance):
def vlm_get_media_instance_title(self, psz_name, i_instance):
def vlm_get_media_instance_chapter(self, psz_name, i_instance):
def vlm_get_media_instance_seekable(self, psz_name, i_instance):
@memoize_parameterless DCNL def vlm_get_event_manager(self):
def add_options(self, *options):
def tracks_get(self):
def add_option(self, psz_options):
def add_option_flag(self, psz_options, i_flags):
def retain(self):
def release(self):
def get_mrl(self):
def duplicate(self):
def get_meta(self, e_meta):
def set_meta(self, e_meta, psz_value):
def save_meta(self):
def get_state(self):
def get_stats(self, p_stats):
def subitems(self):
@memoize_parameterless DCNL def event_manager(self):
def get_duration(self):
def parse(self):
def parse_async(self):
def parse_with_options(self, parse_flag):
def is_parsed(self):
def set_user_data(self, p_new_user_data):
def get_user_data(self):
def get_type(self):
def player_new_from_media(self):
def __new__(cls, ptr=_internal_guard):
def start(self):
def stop(self):
def release(self):
def localized_name(self):
def media_list(self):
@memoize_parameterless DCNL def event_manager(self):
def is_running(self):
def __new__(cls, ptr=_internal_guard):
def release(self):
def retain(self):
def load(self):
def media_list(self):
def add_media(self, mrl):
def release(self):
def retain(self):
def set_media(self, p_md):
def media(self):
def insert_media(self, p_md, i_pos):
def remove_index(self, i_pos):
def count(self):
def item_at_index(self, i_pos):
def index_of_item(self, p_md):
def is_readonly(self):
def lock(self):
def unlock(self):
@memoize_parameterless DCNL def event_manager(self):
def get_instance(self):
def release(self):
def retain(self):
@memoize_parameterless DCNL def event_manager(self):
def set_media_player(self, p_mi):
def get_media_player(self):
def set_media_list(self, p_mlist):
def play(self):
def pause(self):
def is_playing(self):
def get_state(self):
def play_item_at_index(self, i_index):
def play_item(self, p_md):
def stop(self):
def next(self):
def previous(self):
def set_playback_mode(self, e_mode):
def get_instance(self):
def set_mrl(self, mrl, *options):
def video_get_spu_description(self):
def video_get_title_description(self):
def video_get_chapter_description(self, title):
def video_get_track_description(self):
def audio_get_track_description(self):
def get_full_title_descriptions(self):
def get_full_chapter_descriptions(self, i_chapters_of_title):
def video_get_size(self, num=0):
def set_hwnd(self, drawable):
def video_get_width(self, num=0):
def video_get_height(self, num=0):
def video_get_cursor(self, num=0):
def release(self):
def retain(self):
def set_media(self, p_md):
def get_media(self):
@memoize_parameterless DCNL def event_manager(self):
def is_playing(self):
def play(self):
def set_pause(self, do_pause):
def pause(self):
def stop(self):
def video_set_callbacks(self, lock, unlock, display, opaque):
def video_set_format(self, chroma, width, height, pitch):
def video_set_format_callbacks(self, setup, cleanup):
def set_nsobject(self, drawable):
def get_nsobject(self):
def set_agl(self, drawable):
def get_agl(self):
def set_xwindow(self, drawable):
def get_xwindow(self):
def get_hwnd(self):
def set_android_context(self, p_jvm, p_awindow_handler):
def audio_set_callbacks(self, play, pause, resume, flush, drain, opaque):
def audio_set_volume_callback(self, set_volume):
def audio_set_format_callbacks(self, setup, cleanup):
def audio_set_format(self, format, rate, channels):
def get_length(self):
def get_time(self):
def set_time(self, i_time):
def get_position(self):
def set_position(self, f_pos):
def set_chapter(self, i_chapter):
def get_chapter(self):
def get_chapter_count(self):
def will_play(self):
def get_chapter_count_for_title(self, i_title):
def set_title(self, i_title):
def get_title(self):
def get_title_count(self):
def previous_chapter(self):
def next_chapter(self):
def get_rate(self):
def set_rate(self, rate):
def get_state(self):
def get_fps(self):
def has_vout(self):
def is_seekable(self):
def can_pause(self):
def program_scrambled(self):
def next_frame(self):
def navigate(self, navigate):
def set_video_title_display(self, position, timeout):
def toggle_fullscreen(self):
def set_fullscreen(self, b_fullscreen):
def get_fullscreen(self):
def video_set_key_input(self, on):
def video_set_mouse_input(self, on):
def video_get_scale(self):
def video_set_scale(self, f_factor):
def video_get_aspect_ratio(self):
def video_set_aspect_ratio(self, psz_aspect):
def video_get_spu(self):
def video_get_spu_count(self):
def video_set_spu(self, i_spu):
def video_set_subtitle_file(self, psz_subtitle):
def video_get_spu_delay(self):
def video_set_spu_delay(self, i_delay):
def video_get_crop_geometry(self):
def video_set_crop_geometry(self, psz_geometry):
def video_get_teletext(self):
def video_set_teletext(self, i_page):
def toggle_teletext(self):
def video_get_track_count(self):
def video_get_track(self):
def video_set_track(self, i_track):
def video_take_snapshot(self, num, psz_filepath, i_width, i_height):
def video_set_deinterlace(self, psz_mode):
def video_get_marquee_int(self, option):
def video_get_marquee_string(self, option):
def video_set_marquee_int(self, option, i_val):
def video_set_marquee_string(self, option, psz_text):
def video_get_logo_int(self, option):
def video_set_logo_int(self, option, value):
def video_set_logo_string(self, option, psz_value):
def video_get_adjust_int(self, option):
def video_set_adjust_int(self, option, value):
def video_get_adjust_float(self, option):
def video_set_adjust_float(self, option, value):
def audio_output_set(self, psz_name):
def audio_output_device_enum(self):
def audio_output_device_set(self, module, device_id):
def audio_output_device_get(self):
def audio_toggle_mute(self):
def audio_get_mute(self):
def audio_set_mute(self, status):
def audio_get_volume(self):
def audio_set_volume(self, i_volume):
def audio_get_track_count(self):
def audio_get_track(self):
def audio_set_track(self, i_track):
def audio_get_channel(self):
def audio_set_channel(self, channel):
def audio_get_delay(self):
def audio_set_delay(self, i_delay):
def set_equalizer(self, p_equalizer):
def start(self):
def pipe_wait(self, child_conn):
def plot_absolute_values(self):
def check_health(self):
def on_health_response(self, response):
def get_first_items(self, num, cls=None):
def reset_player(self):
def process_uri_request(self):
def perform_request(self, endpoint, read_callback, data='', method='GET', capture_errors=True):
def on_finished(self):
@pass_when_stopped DCNL def schedule_task(self, task, delay_time=0.0, *args, **kwargs):
@pass_when_stopped DCNL def _start_pending_requests(self):
@abstractmethod DCNL def add_request(self, key, candidate, timeout=None):
@abstractmethod DCNL def _do_request(self):
@call_on_reactor_thread DCNL def _success_callback(self, meta_info):
@call_on_reactor_thread DCNL def _failure_callback(self, infohash):
def get_libtorrent_version(self):
def update_max_rates_from_config(self):
def check_handle(self):
def get_handle(self):
def setup(self, dcfg=None, pstate=None, wrapperDelay=0, share_mode=False, checkpoint_disabled=False):
def can_create_engine_wrapper(self):
@checkHandleAndSynchronize('') DCNL def get_pieces_base64(self):
@checkHandleAndSynchronize(0) DCNL def get_num_pieces(self):
def on_save_resume_data_alert(self, alert):
def update_lt_stats(self):
def get_status(self):
def get_length(self):
def get_progress(self):
def get_current_speed(self, dir):
def save_resume_data(self):
def set_moreinfo_stats(self, enable):
def network_get_stats(self, getpeerlist):
@staticmethod DCNL def create_peerlist_data(peer_info):
def set_state_callback(self, usercallback, getpeerlist=False):
def network_get_state(self, usercallback, getpeerlist):
def stop_remove(self, removestate=False, removecontent=False):
def network_stop(self, removestate, removecontent):
def get_content_dest(self):
def set_filepieceranges(self):
def restart(self):
@checkHandleAndSynchronize([]) DCNL def get_dest_files(self, exts=None):
def checkpoint(self):
def add_peer(self, addr):
def __init__(self, session):
def get_tribler_statistics(self):
def get_dispersy_statistics(self):
def get_community_statistics(self):
def _migrate_torrent_collecting_dir(self):
def _ingest_torrent_files(self):
def convert(self):
def convert_session_config(self):
def convert_main_config(self):
def convert_download_checkpoints(self):
def run(self):
def upgrade_to_tribler7(self):
def notify_starting(self):
def notify_done(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def upgrade_database_to_current_version(self):
def start_migrate(self):
def _migrate_torrent_collecting_dir(self):
def _get_total_file_count(self):
def _delete_swift_reseeds(self):
def _delete_swift_files(self):
def _rename_torrent_files(self):
def _delete_all_directories(self):
def _update_dispersy(self):
def start_migrate(self):
def _purge_old_search_metadata_communities(self):
def _upgrade_22_to_23(self):
def reimport_torrents(self):
def reindex_torrents(self):
def shutdown(self):
def get_source_object(self, sourcekey):
def set_enable_mining(self, source, mining_bool=True, force_restart=False):
def add_source(self, source):
def remove_source(self, source_key):
def on_torrent_insert(self, source, infohash, torrent):
def on_torrent_notify(self, subject, change_type, infohash):
def scrape_trackers(self):
def set_archive(self, source, enable):
def start_download(self, torrent):
def stop_download(self, torrent):
def _select_torrent(self):
def load_config(self):
def save_config(self):
def log_statistics(self):
def update_torrent_stats(self, torrent_infohash_str, seeding_stats):
def start(self):
def kill_tasks(self):
def _load_if_ready(self, source):
def get_source_text(self):
def _check_tor(self):
def _load_torrent(self, infohash):
def _on_success_rss(self, body_rss, rss_feed):
def _on_error_rss(self, failure, rss_feed):
def apply(self, torrents, max_active, force=False):
def key(self, key):
def key_check(self, key):
def initialize(self, *args, **kwargs):
def search_in_local_torrents_db(self, query, keys=None):
def getVoteOnChannel(self, channel_id, voter_id):
def getDispersyId(self, channel_id, voter_id):
def getTimestamp(self, channel_id, voter_id):
def get_random_channel_torrents(self, keys, limit=10):
@staticmethod DCNL def calculate_score_channel(keywords, channel_name, channel_description):
def search_in_local_channels_db(self, query):
def getAllChannels(self):
def getNewChannels(self, updated_since=0):
def _getChannels(self, sql, args=None, cmpF=None, includeSpam=True):
def getMostPopularChannelFromTorrent(self, infohash):
def get_torrent_ids_from_playlist(self, playlist_id):
@property DCNL def version(self):
@property DCNL def connection(self):
@blocking_call_on_reactor_thread DCNL def initialize(self):
@blocking_call_on_reactor_thread DCNL def close(self):
def _open_connection(self):
def insertMany(self, table_name, values, keys=None):
def getOne(self, table_name, value_name, where=None, conj=u'AND', **kw):
def getAll(self, table_name, value_name, where=None, group_by=None, having=None, order_by=None, limit=None, offset=None, conj=u'AND', **kw):
def add_observer(self, func, subject, changeTypes=[NTFY_UPDATE, NTFY_INSERT, NTFY_DELETE], id=None, cache=0):
def remove_observer(self, func):
def notify(self, subject, changeType, obj_id, *args):
def get_vod_download(self):
def set_vod_download(self, new_download):
@staticmethod DCNL def get_vod_destination(download):
def shutdown_server(self):
def __init__(self):
def add(self, tdef, dscfg, pstate=None, setupDelay=0, hidden=False, share_mode=False, checkpoint_disabled=False):
def on_download_handle_created(self, download):
def remove(self, d, removecontent=False, removestate=True, hidden=False):
def get_downloads(self):
def get_download(self, infohash):
def update_download_hops(self, download, new_hops):
def update_trackers(self, infohash, trackers):
def stop_download_states_callback(self):
def set_download_states_callback(self, user_callback, interval=1.0):
def _invoke_states_cb(self, callback):
def sesscb_states_callback(self, states_list):
def load_checkpoint(self):
def load_download_pstate_noexc(self, infohash):
def checkpoint_downloads(self):
def shutdown_downloads(self):
@inlineCallbacks DCNL def early_shutdown(self):
def save_download_pstate(self, infohash, pstate):
def load_download_pstate(self, filename):
@call_on_reactor_thread DCNL def add_tracker(self, tracker_url):
@call_on_reactor_thread DCNL def get_tracker_info(self, tracker_url):
def update_tracker_info(self, tracker_url, is_successful):
@call_on_reactor_thread DCNL def should_check_tracker(self, tracker_url):
@call_on_reactor_thread DCNL def get_next_tracker_for_auto_check(self):
def __init__(self, state_directory=None):
@staticmethod DCNL def is_pid_running(pid):
def create_lock_file(self):
def remove_lock_file(self):
def get_pid_from_lock_file(self):
def _parse_html(self, content):
def _html2plaintext(self, html_content):
def parse(self, url, cache):
@call_on_reactor_thread DCNL def create_channel(self, name, description, mode, rss_url=None):
def get_my_channel(self, channel_id):
def get_channel(self, name):
def get_channel_list(self):
@call_on_reactor_thread DCNL def search_for_torrents(self, keywords):
@call_on_reactor_thread DCNL def _on_torrent_search_results(self, subject, change_type, object_id, search_results):
@call_on_reactor_thread DCNL def search_for_channels(self, keywords):
@call_on_reactor_thread DCNL def _on_channel_search_results(self, subject, change_type, object_id, search_results):
def render_PUT(self, request):
def render_GET(self, request):
def render_PUT(self, request):
def render_GET(self, request):
def render_GET(self, request):
def render_POST(self, request):
def __init__(self, session):
def start_endpoints(self):
def get_tunnel_community(self):
def render_GET(self, request):
def render_GET(self, request):
def render_POST(self, request):
def parse_setting(self, section, option, value):
def parse_settings_dict(self, settings_dict, depth=1, root_key=None):
def render_GET(self, request):
def render_GET(self, request):
@staticmethod DCNL def create_ask_bid_from_params(parameters):
def render_GET(self, request):
def render_PUT(self, request):
def render_GET(self, request):
def render_PUT(self, request):
def render_GET(self, request):
def render_POST(self, request):
def render_GET(self, request):
def render_GET(self, request):
def render_GET(self, request):
@staticmethod DCNL def return_404(request, message='this DCSP download DCSP does DCSP not DCSP exist'):
@staticmethod DCNL def create_dconfig_from_params(parameters):
def render_GET(self, request):
def render_PUT(self, request):
def render_DELETE(self, request):
def render_PATCH(self, request):
def render_GET(self, request):
def render_GET(self, request):
def render_GET(self, request):
def render_GET(self, request):
def get_trustchain_community(self):
def render_GET(self, request):
def render_GET(self, request):
def render_GET(self, request):
def render_POST(self, request):
def write_data(self, message):
def on_search_results_channels(self, subject, changetype, objectID, results):
def on_search_results_torrents(self, subject, changetype, objectID, results):
def render_GET(self, request):
def render_GET(self, request):
def render_GET(self, request):
def render_GET(self, request):
@staticmethod DCNL def return_404(request, message=UNKNOWN_CHANNEL_RESPONSE_MSG):
@staticmethod DCNL def return_401(request, message=UNAUTHORIZED_RESPONSE_MSG):
def get_channel_from_db(self, cid):
def get_my_channel_object(self):
def vote_for_channel(self, cid, vote):
def get_community_for_channel_id(self, channel_id):
def render_GET(self, request):
def render_GET(self, _):
def render_PUT(self, request):
def render_GET(self, request):
def render_GET(self, request):
def render_PUT(self, request):
def render_DELETE(self, request):
def render_POST(self, request):
def render_PUT(self, request):
def render_DELETE(self, request):
def render_GET(self, request):
def render_POST(self, request):
def get_my_channel_obj_or_error(self, request):
def render_GET(self, request):
def render_POST(self, request):
def render_PUT(self, request):
def render_DELETE(self, request):
def render_GET(self, request):
def render_PUT(self, request):
def render_PUT(self, request):
def render_DELETE(self, request):
def render_GET(self, _):
def render_PUT(self, request):
def render_DELETE(self, request):
def start(self):
def stop(self):
@inlineCallbacks DCNL def cleanup(self):
def can_add_request(self):
def add_infohash(self, infohash):
@abstractmethod DCNL def connect_to_tracker(self):
@abstractproperty DCNL def max_retries(self):
@abstractproperty DCNL def retry_interval(self):
def max_retries(self):
def retry_interval(self):
def on_error(self, failure):
def _on_cancel(self, a):
def failed(self, msg=None):
def _process_scrape_response(self, body):
@inlineCallbacks DCNL def cleanup(self):
def on_error(self):
def stop(self):
def startProtocol(self):
def write_data(self, data):
def datagramReceived(self, data, (_host, _port)):
def connectionRefused(self):
def on_error(self, failure):
def _on_cancel(self, _):
def on_ip_address_resolved(self, ip_address, start_scraper=True):
def failed(self, msg=None):
def generate_transaction_id(self):
@staticmethod DCNL def remove_transaction_id(session):
@inlineCallbacks DCNL def cleanup(self):
def max_retries(self):
def retry_interval(self):
def connect_to_tracker(self):
def on_start(self):
def handle_connection_response(self, response):
def handle_response(self, response):
def cleanup(self):
def can_add_request(self):
def add_infohash(self, infohash):
def connect_to_tracker(self):
@property DCNL def max_retries(self):
@property DCNL def retry_interval(self):
def shutdown(self):
def _reschedule_tracker_select(self):
def _task_select_tracker(self):
@call_on_reactor_thread DCNL def add_gui_request(self, infohash, timeout=20, scrape_now=False):
def on_session_error(self, session, failure):
def __init__(self, config=None, ignore_singleton=False, autoload_discovery=True):
def create_state_directory_structure(self):
def get_ports_in_config(self):
def init_keypair(self):
@staticmethod DCNL def get_instance(*args, **kw):
@staticmethod DCNL def has_instance():
@staticmethod DCNL def del_instance():
def unhandled_error_observer(self, event):
def start_download_from_uri(self, uri, download_config=None):
def start_download_from_tdef(self, torrent_definition, download_startup_config=None, hidden=False):
def resume_download_from_file(self, filename):
def get_downloads(self):
def get_download(self, infohash):
def has_download(self, infohash):
def remove_download(self, download, remove_content=False, remove_state=True, hidden=False):
def remove_download_by_id(self, infohash, remove_content=False, remove_state=True):
def set_download_states_callback(self, user_callback, interval=1.0):
def get_permid(self):
def add_observer(self, observer_function, subject, change_types=None, object_id=None, cache=0):
def remove_observer(self, function):
def open_dbhandler(self, subject):
@staticmethod DCNL def close_dbhandler(database_handler):
def get_tribler_statistics(self):
def get_dispersy_statistics(self):
def get_community_statistics(self):
def load_checkpoint(self):
def checkpoint(self):
@blocking_call_on_reactor_thread DCNL def start_database(self):
@blocking_call_on_reactor_thread DCNL def start(self):
@blocking_call_on_reactor_thread DCNL def shutdown(self):
def has_shutdown(self):
def get_downloads_pstate_dir(self):
def download_torrentfile(self, infohash=None, user_callback=None, priority=0):
def download_torrentfile_from_peer(self, candidate, infohash=None, user_callback=None, priority=0):
def download_torrentmessage_from_peer(self, candidate, infohash, user_callback, priority=0):
def checkpoint_downloads(self):
def update_trackers(self, infohash, trackers):
def has_collected_torrent(self, infohash):
def get_collected_torrent(self, infohash):
def save_collected_torrent(self, infohash, data):
def delete_collected_torrent(self, infohash):
def search_remote_torrents(self, keywords):
def search_remote_channels(self, keywords):
@staticmethod DCNL def create_torrent_file(file_path_list, params=None):
def create_channel(self, name, description, mode=u'closed'):
def add_torrent_def_to_channel(self, channel_id, torrent_def, extra_info={}, forward=True):
def check_torrent_health(self, infohash, timeout=20, scrape_now=False):
def get_thumbnail_data(self, thumb_hash):
def __init__(self, input=None, metainfo=None, infohash=None):
@staticmethod DCNL def load(filename):
@staticmethod DCNL def load_from_memory(data):
def _read(stream):
@staticmethod DCNL @blocking_call_on_reactor_thread DCNL def load_from_url(url):
@staticmethod DCNL def load_from_dict(metainfo):
def add_content(self, inpath, outpath=None, playtime=None):
def remove_content(self, inpath):
def set_encoding(self, enc):
def set_tracker(self, url):
def get_tracker(self):
def set_tracker_hierarchy(self, hier):
def get_tracker_hierarchy(self):
def get_trackers_as_single_tuple(self):
def set_dht_nodes(self, nodes):
def get_dht_nodes(self):
def set_comment(self, value):
def get_comment(self):
def get_comment_as_unicode(self):
def set_created_by(self, value):
def get_created_by(self):
def set_urllist(self, value):
def get_urllist(self):
def set_httpseeds(self, value):
def get_httpseeds(self):
def set_piece_length(self, value):
def get_piece_length(self):
def get_nr_pieces(self):
def get_pieces(self):
def set_initial_peers(self, value):
def get_initial_peers(self):
def finalize(self, userabortflag=None, userprogresscallback=None):
def is_finalized(self):
def get_infohash(self):
def get_metainfo(self):
def get_name(self):
def set_name(self, name):
def get_name_as_unicode(self):
def save(self, filename):
def get_torrent_size(self):
def _get_all_files_as_unicode_with_length(self):
def get_files_with_length(self, exts=None):
def get_length(self, selectedfiles=None):
def is_multifile_torrent(self):
def is_private(self):
def __init__(self, session, endpoint, prefix, block_size=DEFAULT_BLOCK_SIZE, timeout=DEFAULT_TIMEOUT, max_retries=DEFAULT_RETIES):
def initialize(self):
@blocking_call_on_reactor_thread DCNL def shutdown(self):
@call_on_reactor_thread DCNL def download_file(self, file_name, ip, port, extra_info=None, success_callback=None, failure_callback=None):
@attach_runtime_statistics(u'{0.__class__.__name__}.{function_name}') DCNL def _task_check_timeout(self):
def _check_session_timeout(self, session):
def _schedule_callback_processing(self):
@attach_runtime_statistics(u'{0.__class__.__name__}.{function_name}') DCNL def _process_callbacks(self):
@attach_runtime_statistics(u'{0.__class__.__name__}.{function_name}') DCNL @call_on_reactor_thread DCNL def data_came_in(self, addr, data):
def _handle_new_request(self, ip, port, packet):
def _load_metadata(self, thumb_hash):
def _load_torrent(self, file_name):
def _get_next_data(self, session):
def _process_packet(self, session, packet):
def _handle_packet_as_receiver(self, session, packet):
def _handle_packet_as_sender(self, session, packet):
def _handle_error(self, session, error_code, error_msg=''):
def set_dest_dir(self, path):
def get_dest_dir(self):
def get_corrected_filename(self):
def set_corrected_filename(self, correctedfilename):
def set_mode(self, mode):
def get_mode(self):
def set_selected_files(self, files):
def get_selected_files(self):
def __init__(self, dlconfig=None):
def load(filename):
def save(self, filename):
def __init__(self, config=None):
@staticmethod DCNL def load(config_path=None):
def copy(self):
def validate(self):
def write(self):
@staticmethod DCNL def get_default_state_dir(home_dir_postfix=u'.Tribler'):
def _obtain_port(self, section, option):
def _get_random_port(self, path):
def _set_video_analyser_path(self):
def set_libtorrent_proxy_settings(self, proxy_type, server=None, auth=None):
def set_anon_proxy_settings(self, proxy_type, server=None, auth=None):
def get_anon_proxy_settings(self):
def set_libtorrent_max_conn_download(self, value):
def get_libtorrent_max_conn_download(self):
def set_libtorrent_max_upload_rate(self, value):
def get_libtorrent_max_upload_rate(self):
def set_libtorrent_max_download_rate(self, value):
def get_libtorrent_max_download_rate(self):
def set_credit_mining_sources(self, source_list, key):
def set_credit_mining_policy(self, policy):
def get_credit_mining_policy(self, as_class=False):
def __init__(self, download, status, error, progress, stats=None, seeding_stats=None, filepieceranges=None, logmsgs=None, peerid=None, videoinfo=None):
def get_download(self):
def get_progress(self):
def get_status(self):
def get_error(self):
def get_current_speed(self, direct):
def get_total_transferred(self, direct):
def get_seeding_statistics(self):
def get_eta(self):
def get_num_con_initiated(self):
def get_num_peers(self):
def get_num_nonseeds(self):
def get_num_seeds_peers(self):
def get_pieces_complete(self):
def get_pieces_total_complete(self):
def get_files_completion(self):
def get_availability(self):
def get_vod_prebuffering_progress(self):
def get_vod_prebuffering_progress_consec(self):
def is_vod(self):
def get_peerlist(self):
def family_filter_enabled(self):
@staticmethod DCNL def _encode_half_block(message):
@staticmethod DCNL def _decode_half_block(placeholder, offset, data):
@staticmethod DCNL def _encode_crawl_request(message):
@staticmethod DCNL def _decode_crawl_request(placeholder, offset, data):
def __init__(self, working_directory, db_name):
def add_block(self, block):
def get(self, public_key, sequence_number):
def contains(self, block):
def get_latest(self, public_key):
def get_block_after(self, block):
def get_block_before(self, block):
def get_linked(self, block):
def get_sql_header(self):
def get_schema(self):
def get_upgrade_script(self, current_version):
def check_database(self, database_version):
def validate_transaction(self, database):
def validate(self, database):
def sign(self, key):
@classmethod DCNL def create(cls, transaction, database, public_key, link=None, link_pk=None):
def pack(self, signature=True):
@classmethod DCNL def unpack(cls, data, offset=0):
def pack_db_insert(self):
def __iter__(self):
@staticmethod DCNL def valid():
@staticmethod DCNL def partial():
@staticmethod DCNL def partial_next():
@staticmethod DCNL def partial_previous():
@staticmethod DCNL def no_info():
@staticmethod DCNL def invalid():
def initiate_meta_messages(self):
def should_sign(self, message):
def wait_for_intro_of_candidate(self, candidate):
def wait_for_signature_request(self, block_id):
def sign_block(self, candidate, public_key=None, transaction=None, linked=None):
def received_half_block(self, messages):
def set_live_edge_callback(self, func):
def reset_live_edges(self):
def set_live_edges_enabled(self, value):
def get_trust(self, member):
def dispersy_get_introduce_candidate(self, exclude_candidate=None):
def __init__(self, order_book):
@abstractmethod DCNL def match_order(self, order):
def match_order(self, order):
def _search_for_quantity_in_order_book(self, price, price_level, quantity_to_trade, order):
def _search_for_quantity_in_price_level(self, tick_entry, quantity_to_trade, order):
def __init__(self, matching_strategy):
def match_order(self, order):
def __init__(self, order_number):
def __init__(self, trader_id, order_number):
@property DCNL def trader_id(self):
@property DCNL def order_number(self):
def __str__(self):
def __init__(self, order_id, price, quantity, timeout, timestamp, is_ask):
@classmethod DCNL def from_database(cls, data, reserved_ticks):
def to_database(self):
@property DCNL def reserved_ticks(self):
@property DCNL def order_id(self):
@property DCNL def price(self):
@property DCNL def total_quantity(self):
@property DCNL def available_quantity(self):
@property DCNL def reserved_quantity(self):
@property DCNL def traded_quantity(self):
@property DCNL def timeout(self):
@property DCNL def timestamp(self):
@property DCNL def completed_timestamp(self):
def is_ask(self):
@property DCNL def cancelled(self):
def is_complete(self):
@property DCNL def status(self):
def reserve_quantity_for_tick(self, order_id, quantity):
def release_quantity_for_tick(self, order_id, quantity):
def is_valid(self):
def to_dictionary(self):
def __init__(self, payment_id):
@property DCNL def payment_id(self):
def __init__(self, message_id, order_id, price, quantity, timeout, timestamp, is_ask, public_key=EMPTY_PK, signature=EMPTY_SIG):
@classmethod DCNL def from_order(cls, order, message_id):
@property DCNL def order_id(self):
@property DCNL def price(self):
@property DCNL def quantity(self):
@quantity.setter DCNL def quantity(self, quantity):
@property DCNL def timeout(self):
def is_ask(self):
def is_valid(self):
def sign(self, member):
def update_timestamp(self):
def to_network(self):
def to_dictionary(self):
def __init__(self, message_id, order_id, price, quantity, timeout, timestamp, public_key=EMPTY_PK, signature=EMPTY_SIG):
@classmethod DCNL def from_network(cls, data):
def __init__(self, message_id, order_id, price, quantity, timeout, timestamp, public_key=EMPTY_PK, signature=EMPTY_SIG):
@classmethod DCNL def from_network(cls, data):
def __init__(self):
def __init__(self, mid):
def find_all(self):
def find_by_id(self, transaction_id):
def add(self, transaction):
def update(self, transaction):
def delete_by_id(self, transaction_id):
def next_identity(self):
def __init__(self, mid, persistence):
def find_all(self):
def find_by_id(self, transaction_id):
def add(self, transaction):
def update(self, transaction):
def delete_by_id(self, transaction_id):
def next_identity(self):
def __init__(self, timeout):
def is_timed_out(self, timestamp):
def __init__(self, quantity, wallet_id):
@property DCNL def wallet_id(self):
@property DCNL def int_wallet_id(self):
@classmethod DCNL def from_database(cls, data):
def to_database(self):
@classmethod DCNL def from_network(cls, data):
def to_network(self):
def insert_ask(self, ask):
def remove_ask(self, order_id):
def insert_bid(self, bid):
def remove_bid(self, order_id):
def trade_tick(self, order_id, recipient_order_id, quantity, end_transaction_timestamp):
def tick_exists(self, order_id):
def get_ask(self, order_id):
def get_bid(self, order_id):
def get_tick(self, order_id):
def ask_exists(self, order_id):
def bid_exists(self, order_id):
def remove_tick(self, order_id):
@property DCNL def asks(self):
@property DCNL def bids(self):
def get_bid_price(self, price_wallet_id, quantity_wallet_id):
def get_ask_price(self, price_wallet_id, quantity_wallet_id):
def get_bid_ask_spread(self, price_wallet_id, quantity_wallet_id):
def get_mid_price(self, price_wallet_id, quantity_wallet_id):
def bid_side_depth(self, price):
def ask_side_depth(self, price):
def get_bid_side_depth_profile(self, price_wallet_id, quantity_wallet_id):
def get_ask_side_depth_profile(self, price_wallet_id, quantity_wallet_id):
def bid_relative_price(self, price):
def ask_relative_price(self, price):
def relative_tick_price(self, tick):
def get_bid_price_level(self, price_wallet_id, quantity_wallet_id):
def get_ask_price_level(self, price_wallet_id, quantity_wallet_id):
def get_order_ids(self):
def save_to_database(self):
def restore_from_database(self):
def __init__(self, ttl):
@classmethod DCNL def default(cls):
def is_alive(self):
def make_hop(self):
@property DCNL def first_tick(self):
@property DCNL def length(self):
@property DCNL def depth(self):
@depth.setter DCNL def depth(self, new_depth):
def __len__(self):
def next(self):
def append_tick(self, tick):
def remove_tick(self, tick):
def __init__(self, transaction_repository):
def create_from_proposed_trade(self, proposed_trade):
def create_from_start_transaction(self, start_transaction):
def find_by_id(self, transaction_id):
def find_all(self):
def __init__(self, transaction_number):
def __init__(self, trader_id, transaction_number):
@property DCNL def trader_id(self):
@property DCNL def transaction_number(self):
def __str__(self):
def __init__(self, transaction_id, price, quantity, order_id, partner_order_id, timestamp):
@classmethod DCNL def from_database(cls, data, payments):
def to_database(self):
@classmethod DCNL def from_proposed_trade(cls, proposed_trade, transaction_id):
@property DCNL def transaction_id(self):
@property DCNL def price(self):
@property DCNL def total_price(self):
@property DCNL def transferred_price(self):
@property DCNL def total_quantity(self):
@property DCNL def transferred_quantity(self):
@property DCNL def order_id(self):
@property DCNL def partner_order_id(self):
@property DCNL def payments(self):
@property DCNL def timestamp(self):
@property DCNL def status(self):
@staticmethod DCNL def unitize(amount, min_unit):
def to_dictionary(self):
def __init__(self, message_id, transaction_id, order_id, recipient_order_id, proposal_id, price, quantity, timestamp):
@property DCNL def transaction_id(self):
@property DCNL def order_id(self):
@property DCNL def recipient_order_id(self):
@property DCNL def proposal_id(self):
@property DCNL def price(self):
@property DCNL def quantity(self):
@classmethod DCNL def from_network(cls, data):
def to_network(self):
def __init__(self, message_id, order_id, recipient_order_id, proposal_id, timestamp):
@classmethod DCNL def propose(cls, message_id, order_id, recipient_order_id, price, quantity, timestamp):
@classmethod DCNL def decline(cls, message_id, timestamp, proposed_trade):
@classmethod DCNL def counter(cls, message_id, quantity, timestamp, proposed_trade):
@property DCNL def order_id(self):
@property DCNL def recipient_order_id(self):
@property DCNL def proposal_id(self):
def __init__(self, message_id, order_id, recipient_order_id, proposal_id, price, quantity, timestamp):
@classmethod DCNL def from_network(cls, data):
@property DCNL def price(self):
@property DCNL def quantity(self):
def has_acceptable_price(self, is_ask, order_price):
def to_network(self):
def __init__(self, message_id, order_id, recipient_order_id, proposal_id, price, quantity, timestamp):
@classmethod DCNL def from_network(cls, data):
def to_network(self):
def __init__(self, message_id, order_id, recipient_order_id, proposal_id, timestamp):
@classmethod DCNL def from_network(cls, data):
def to_network(self):
def __init__(self, ip, port):
@property DCNL def ip(self):
@property DCNL def port(self):
def __init__(self, price, wallet_id):
@property DCNL def wallet_id(self):
@property DCNL def int_wallet_id(self):
def __init__(self, timestamp):
@classmethod DCNL def now(cls):
def __len__(self):
def get_price_level(self, price):
def get_tick(self, order_id):
def _create_price_level(self, price, quantity_wallet_id):
def _remove_price_level(self, price, quantity_wallet_id):
def _price_level_exists(self, price):
def tick_exists(self, order_id):
def insert_tick(self, tick):
def remove_tick(self, order_id):
def get_price_level_list(self, price_wallet_id, quantity_wallet_id):
def get_price_level_list_wallets(self):
def get_max_price(self, price_wallet_id, quantity_wallet_id):
def get_min_price(self, price_wallet_id, quantity_wallet_id):
def get_max_price_list(self, price_wallet_id, quantity_wallet_id):
def get_min_price_list(self, price_wallet_id, quantity_wallet_id):
def get_list_representation(self):
def __init__(self, order_repository):
def create_ask_order(self, price, quantity, timeout):
def create_bid_order(self, price, quantity, timeout):
def cancel_order(self, order_id):
def __init__(self, trader_id):
def __init__(self, message_number):
def __init__(self, trader_id, message_number):
@property DCNL def trader_id(self):
@property DCNL def message_number(self):
def __str__(self):
def __init__(self, message_id, timestamp):
@property DCNL def message_id(self):
@property DCNL def timestamp(self):
def __init__(self, wallet_address):
def __init__(self):
def __init__(self, mid):
def find_all(self):
def find_by_id(self, order_id):
def add(self, order):
def update(self, order):
def delete_by_id(self, order_id):
def next_identity(self):
def __init__(self, mid, persistence):
def find_all(self):
def find_by_id(self, order_id):
def add(self, order):
def update(self, order):
def delete_by_id(self, order_id):
def next_identity(self):
def __init__(self, tick, price_level):
@property DCNL def tick(self):
@property DCNL def order_id(self):
@property DCNL def price(self):
@property DCNL def quantity(self):
@quantity.setter DCNL def quantity(self, new_quantity):
def is_valid(self):
def price_level(self):
@property DCNL def prev_tick(self):
@prev_tick.setter DCNL def prev_tick(self, new_prev_tick):
@property DCNL def next_tick(self):
@next_tick.setter DCNL def next_tick(self, new_next_tick):
def __str__(self):
def insert(self, price, price_level):
def remove(self, price):
def succ_item(self, price):
def prev_item(self, price):
def min_key(self):
def max_key(self):
def items(self, reverse=False):
def get_ticks_list(self):
def __init__(self, mid):
def next_identity(self):
def __init__(self, working_directory):
def get_all_orders(self):
def get_order(self, order_id):
def add_order(self, order):
def delete_order(self, order_id):
def get_next_order_number(self):
def delete_reserved_ticks(self, order_id):
def add_reserved_tick(self, order_id, reserved_order_id, quantity):
def get_reserved_ticks(self, order_id):
def get_all_transactions(self):
def get_transaction(self, transaction_id):
def add_transaction(self, transaction):
def delete_transaction(self, transaction_id):
def get_next_transaction_number(self):
def add_payment(self, payment):
def get_payments(self, transaction_id):
def delete_payments(self, transaction_id):
def add_tick(self, tick):
def delete_all_ticks(self):
def get_ticks(self):
def check_database(self, database_version):
def get_wallet_ids(self):
def get_dispersy_address(self):
def get_wallet_address(self, wallet_id):
def get_order_addresses(self, order):
def match(self, order):
def lookup_ip(self, trader_id):
def update_ip(self, trader_id, ip):
def create_ask(self, price, price_wallet_id, quantity, quantity_wallet_id, timeout):
def send_tick(self, tick):
def create_bid(self, price, price_wallet_id, quantity, quantity_wallet_id, timeout):
def send_cancel_order(self, order):
def send_offer_sync(self, target_candidate, tick):
def update_ticks(self, transaction, end_transaction_timestamp):
def abort_transaction(self, transaction):
def compute_reputation(self):
def monitor_transaction(self, payment_id):
def monitor_transaction(self, transaction_id):
def generate_txid(self, length=10):
def get_daemon(self):
def create_wallet(self, password=''):
def get_balance(self):
def monitor_transaction(self, txid):
def compute(self, own_public_key):
def compute(self, own_public_key):
def get_all_blocks(self):
def get_upgrade_script(self, current_version):
def should_sign(self, message):
def __init__(self, circuit_id, goal_hops=0, first_hop=None, proxy=None, ctype=CIRCUIT_TYPE_DATA, callback=None, required_exit=None, mid=None, info_hash=None):
@property DCNL def hops(self):
def add_hop(self, hop):
@property DCNL def state(self):
def beat_heart(self):
def tunnel_data(self, destination, payload):
def destroy(self, reason='unknown'):
def __init__(self, public_key=None):
@property DCNL def host(self):
@property DCNL def port(self):
@property DCNL def node_id(self):
@property DCNL def node_public_key(self):
def __init__(self, circuit_id, sock_addr, rendezvous_relay=False, mid=None):
@property DCNL def destination(self):
@property DCNL def destination(self):
def _try_handshake(self):
def _try_request(self):
def deny_request(self, request, reason):
def circuit_dead(self, broken_circuit):
@inlineCallbacks DCNL def close(self):
def on_download_removed(self, download):
def copy_shallow_candidate(self, tunnel, sock_addr):
def get_num_unique_interactors(self, public_key):
def get_upgrade_script(self, current_version):
@classmethod DCNL def create(cls, transaction, database, public_key, link=None, link_pk=None):
def validate_transaction(self, database):
def received_payment_message(self, payment_id):
def should_sign(self, message):
@blocking_call_on_reactor_thread DCNL def get_statistics(self, public_key=None):
@blocking_call_on_reactor_thread DCNL def on_tunnel_remove(self, subject, change_type, tunnel, candidate):
def get_trust(self, member):
def test_add_pending_bytes(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_cleanup_pending_bytes(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_on_tunnel_remove(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_on_tunnel_remove_small(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_on_tunnel_remove_append_pending(self):
def test_receive_request_invalid(self):
def test_receive_request_twice(self):
def test_receive_request_too_much(self):
def test_receive_request_unknown_pend(self):
def test_block_values(self):
def test_block_values_after_request(self):
def test_crawler_on_introduction_received(self):
def test_get_statistics_no_blocks(self):
def test_get_statistics_with_previous_block(self):
def test_get_statistics_for_not_self(self):
def test_get_trust(self):
def test_get_default_trust(self):
@blocking_call_on_reactor_thread DCNL def test_get_num_interactors(self):
def test_sign_block(self):
def test_sign_block_missing_member(self):
def test_sign_invalid_block(self):
def test_receive_signature_request_and_response(self):
def test_crawl_on_partial(self):
def test_crawl_not_double(self):
def test_crawl_on_partial_complete(self):
def test_crawl_block_latest(self):
def test_crawl_block_specified_sequence_number(self):
def test_crawl_blocks_negative_sequence_number(self):
def test_crawl_no_block(self):
def test_crawl_block_known(self):
def test_crawl_batch(self):
def test_get_trust(self):
def test_get_default_trust(self):
def test_live_edge_bootstrapping(self):
def test_live_edge_recommend_valid(self):
def test_live_edge_callback_no_candidates(self):
def test_live_edge_callback(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_wait_for_intro_candidate(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_wait_for_signature_request(self):
def assertEqual_block(self, expected_block, actual_block):
def test_encoding_decoding_half_block(self):
def test_encoding_decoding_half_block_big_number(self):
def test_decoding_half_block_wrong_size(self):
def test_encoding_decoding_crawl_request(self):
def test_decoding_crawl_request_wrong_size(self):
@blocking_call_on_reactor_thread DCNL def test_save_large_upload_download_block(self):
@blocking_call_on_reactor_thread DCNL def test_block_to_dictionary(self):
def test_should_sign_no_market(self):
def test_circuit_tunnel_data(self):
@blocking_call_on_reactor_thread DCNL def test_create_intro_no_download(self):
@deferred(timeout=60) DCNL @inlineCallbacks DCNL def test_anon_download(self):
@deferred(timeout=60) DCNL @inlineCallbacks DCNL def test_anon_download_no_exitnodes(self):
@deferred(timeout=60) DCNL @inlineCallbacks DCNL def test_anon_download_no_relays(self):
def get_peers(self, lookup_id, _, callback_f, bt_port=0):
def configure_hidden_seeder(self):
@deferred(timeout=50) DCNL @inlineCallbacks DCNL def test_hidden_services(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_unload_receive(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_load_other_tunnel_community(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setUp(self, autoload_discovery=True):
@inlineCallbacks DCNL def setup_nodes(self, num_relays=1, num_exitnodes=1, seed_hops=0):
@blocking_call_on_reactor_thread DCNL def load_tunnel_community_in_session(self, session, exitnode=False):
@inlineCallbacks DCNL def create_proxy(self, index, exitnode=False):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setup_tunnel_seeder(self, hops):
def seeder_state_callback(self, ds):
def start_anon_download(self, hops=1):
def test_decode_request(self):
def test_associate(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_double_close(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_double_close(self):
def test_on_data_invalid_encoding(self):
@blocking_call_on_reactor_thread DCNL def test_valid_member_on_tunnel_remove(self):
@blocking_call_on_reactor_thread DCNL def test_reconstruct_candidate_on_tunnel_remove(self):
@blocking_call_on_reactor_thread DCNL def test_reconstruct_candidate_on_relay_remove(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_e2e_transaction(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_orderbook_sync(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_accept_trade(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_counter_trade(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_decline_trade(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_cancel_order(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setUp(self, autoload_discovery=True):
@blocking_call_on_reactor_thread DCNL def load_market_community_in_session(self, session, market_member, mc_community):
@blocking_call_on_reactor_thread DCNL def load_triblerchain_community_in_session(self, session):
@inlineCallbacks DCNL def create_session(self, index):
def test_signature(self):
def test_update_timestamp(self):
def test_to_dictionary(self):
def test_match_order_other_price(self):
def test_match_order_other_quantity(self):
def test_match_order_partial_ask(self):
def test_match_order_partial_bid(self):
def test_search_for_quantity_in_price_level(self):
def test_init(self):
@blocking_call_on_reactor_thread DCNL def test_get_master_members(self):
@blocking_call_on_reactor_thread DCNL def test_proposed_trade_cache_timeout(self):
@blocking_call_on_reactor_thread DCNL def test_verify_offer_creation(self):
@blocking_call_on_reactor_thread DCNL def test_check_message(self):
@blocking_call_on_reactor_thread DCNL def test_check_tick_message(self):
@blocking_call_on_reactor_thread DCNL def test_check_trade_message(self):
@blocking_call_on_reactor_thread DCNL def test_send_offer_sync(self):
@blocking_call_on_reactor_thread DCNL def test_send_proposed_trade(self):
@blocking_call_on_reactor_thread DCNL def test_send_counter_trade(self):
@blocking_call_on_reactor_thread DCNL def test_start_transaction(self):
@blocking_call_on_reactor_thread DCNL def test_create_intro_request(self):
@blocking_call_on_reactor_thread DCNL def test_on_introduction_request(self):
@blocking_call_on_reactor_thread DCNL def test_get_wallet_address(self):
@blocking_call_on_reactor_thread DCNL def test_on_tick(self):
@blocking_call_on_reactor_thread DCNL def test_on_proposed_trade_accept(self):
@blocking_call_on_reactor_thread DCNL def test_on_proposed_trade_decline(self):
@blocking_call_on_reactor_thread DCNL def test_on_proposed_trade_counter(self):
@blocking_call_on_reactor_thread DCNL def test_on_offer_sync(self):
@blocking_call_on_reactor_thread DCNL def test_compute_reputation(self):
@blocking_call_on_reactor_thread DCNL def test_abort_transaction(self):
def test_init(self):
def test_add_trade(self):
def test_status(self):
def test_compute(self):
def test_get_price_level_list_wallets(self):
def test_get_list_representation(self):
def test_properties(self):
def test_properties(self):
def test_properties(self):
def test_properties(self):
def test_to_dictionary(self):
def test_init(self):
def test_str(self):
def test_equality(self):
def test_hash(self):
def test_timeouts(self):
def test_get_tick(self):
@deferred(timeout=10) DCNL def test_ask_insertion_invalid(self):
@deferred(timeout=10) DCNL def test_bid_insertion_invalid(self):
def test_trade_tick(self):
def test_get_order_ids(self):
@blocking_call_on_reactor_thread DCNL def test_save_to_db(self):
@blocking_call_on_reactor_thread DCNL def test_restore_from_db(self):
@deferred(timeout=20) DCNL def test_btc_wallet(self):
def test_btc_wallet_name(self):
def test_btc_wallet_identfier(self):
def test_btc_wallet_address(self):
def test_btc_wallet_unit(self):
def test_btc_balance_no_wallet(self):
@deferred(timeout=10) DCNL def test_btc_wallet_transfer_no_funds(self):
@deferred(timeout=10) DCNL def test_btc_wallet_transfer(self):
@deferred(timeout=10) DCNL def test_btc_wallet_transfer_error(self):
def test_get_mc_wallet_name(self):
def test_get_mc_wallet_id(self):
@deferred(timeout=10) DCNL def test_get_balance(self):
def test_create_wallet(self):
@deferred(timeout=10) DCNL def test_transfer_invalid(self):
@deferred(timeout=10) DCNL def test_transfer_missing_member(self):
@deferred(timeout=10) DCNL def test_monitor_transaction(self):
def test_address(self):
@deferred(timeout=10) DCNL def test_get_transaction(self):
def test_min_unit(self):
def test_wait_for_intro_of_candidate(self):
def test_wallet_id(self):
def test_wallet_name(self):
@deferred(timeout=10) DCNL def test_create_wallet(self):
@deferred(timeout=10) DCNL def test_get_balance(self):
@deferred(timeout=10) DCNL def test_transfer(self):
@deferred(timeout=10) DCNL def test_transfer_invalid(self):
@deferred(timeout=10) DCNL def test_monitor(self):
@deferred(timeout=10) DCNL def test_monitor_instant(self):
def test_address(self):
@deferred(timeout=10) DCNL def test_get_transaction(self):
def test_min_unit(self):
def test_generate_txid(self):
def test_unitize(self):
def test_add_payment(self):
def test_last_payment(self):
def test_next_payment(self):
def test_to_dictionary(self):
def test_status(self):
def test_to_network(self):
def get_placeholder_msg(self, meta_name):
def test_decode_payload(self):
def test_encode_decode_intro_request(self):
def test_encode_decode_offer(self):
def test_encode_decode_cancel_order(self):
def test_encode_decode_offer_sync(self):
def test_encode_decode_declined_trade(self):
def test_encode_decode_start_transaction(self):
def test_encode_decode_transaction(self):
def test_encode_decode_wallet_info(self):
def test_encode_decode_payment(self):
def test_init(self):
@blocking_call_on_reactor_thread DCNL def test_add_get_order(self):
@blocking_call_on_reactor_thread DCNL def test_get_specific_order(self):
@blocking_call_on_reactor_thread DCNL def test_delete_order(self):
@blocking_call_on_reactor_thread DCNL def test_get_next_order_number(self):
@blocking_call_on_reactor_thread DCNL def test_add_delete_reserved_ticks(self):
@blocking_call_on_reactor_thread DCNL def test_add_get_transaction(self):
@blocking_call_on_reactor_thread DCNL def test_get_specific_transaction(self):
@blocking_call_on_reactor_thread DCNL def test_delete_transaction(self):
@blocking_call_on_reactor_thread DCNL def test_get_next_transaction_number(self):
@blocking_call_on_reactor_thread DCNL def test_add_get_payment(self):
@blocking_call_on_reactor_thread DCNL def test_add_remove_tick(self):
@blocking_call_on_reactor_thread DCNL def test_add_get_trader_identity(self):
@blocking_call_on_reactor_thread DCNL def test_check_database(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setup_peer(self):
@deferred(timeout=20) DCNL def test_torrent_search(self):
@deferred(timeout=20) DCNL def test_channel_search(self):
def test_on_search(self):
@raises(DropPacket) DCNL def test_decode_response_invalid(self):
@blocking_call_on_reactor_thread DCNL def test_create_torrent(self):
def test_remove_playlist_torrents(self):
@blocking_call_on_reactor_thread DCNL def test_create_torrent_from_def(self):
def test_encode_torrent(self):
def test_decode_torrent(self):
@deferred(timeout=10) DCNL def test_create_votecast(self):
@deferred(timeout=10) DCNL def test_unload_preview(self):
@deferred(timeout=60) DCNL def test_seeding(self):
def screenshot(self, widget, name=None):
def get_bucket_range_port(self):
def get_socks5_ports(self):
def create_local_torrent(self, source_file):
def test_create_torrent(self):
def create_tdef(self):
@deferred(timeout=10) DCNL def test_save_resume(self):
def test_selected_files(self):
def test_get_share_mode(self):
def test_set_share_mode(self):
def test_set_priority(self):
def test_dlconfig_cb_change(self):
def test_add_trackers(self):
def test_process_error_alert(self):
def test_tracker_warning_alert(self):
@deferred(timeout=10) DCNL def test_on_metadata_received_alert(self):
def test_metadata_received_invalid_info(self):
def test_torrent_checked_alert(self):
def test_get_length(self):
def test_get_dest_files(self):
def test_get_vod_fileindex(self):
def test_get_vod_filesize(self):
def test_get_piece_progress(self):
def test_get_byte_progress(self):
def test_setup_exception(self):
def test_tracker_reply_alert(self):
def test_stop(self):
def test_download_finish_alert(self):
def test_get_pieces_bitmask(self):
@deferred(timeout=10) DCNL def test_resume_data_failed(self):
def test_get_metainfo_not_ready(self):
@deferred(timeout=20) DCNL def test_get_metainfo(self):
@deferred(timeout=20) DCNL def test_got_metainfo(self):
@deferred(timeout=20) DCNL def test_got_metainfo_timeout(self):
def test_add_torrent(self):
def test_start_download_corrupt(self):
def test_start_download_duplicate(self):
def test_set_proxy_settings(self):
def test_read_test_corr_tribler_conf(self):
def test_read_test_corr_libtribler_conf(self):
def test_upgrade_from_obsolete_version(self):
@blocking_call_on_reactor_thread DCNL def test_run(self):
def test_search_local_channels(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setUp(self, annotate=True, autoload_discovery=True):
@blocking_call_on_reactor_thread DCNL def create_fake_allchannel_community(self):
def test_create_channel(self):
def test_unhandled_error_observer(self):
def test_error_observer_ignored_error(self):
@deferred(timeout=10) DCNL def test_add_torrent_def_to_channel(self):
@deferred(timeout=10) DCNL def test_add_torrent_def_to_channel_duplicate(self):
@raises(OperationNotEnabledByConfigurationException) DCNL def test_get_libtorrent_process_not_enabled(self):
@raises(OperationNotEnabledByConfigurationException) DCNL def test_open_dbhandler(self):
def test_download_torrentfile(self):
def test_download_torrentfile_from_peer(self):
def test_download_torrentmessage_from_peer(self):
def test_get_permid(self):
def test_remove_download_by_id_empty(self):
def test_remove_download_by_id_nonempty(self):
@raises(OperationNotEnabledByConfigurationException) DCNL def test_get_dispersy_instance(self):
@raises(OperationNotEnabledByConfigurationException) DCNL def test_has_collected_torrent(self):
@raises(OperationNotEnabledByConfigurationException) DCNL def test_get_collected_torrent(self):
@raises(OperationNotEnabledByConfigurationException) DCNL def test_save_collected_torrent(self):
@raises(OperationNotEnabledByConfigurationException) DCNL def test_delete_collected_torrent(self):
@raises(OperationNotEnabledByConfigurationException) DCNL def test_search_remote_channels(self):
@raises(OperationNotEnabledByConfigurationException) DCNL def test_get_thumbnail_data(self):
def test_random_policy(self):
def test_seederratio_policy(self):
@skip('The DCSP random DCSP seed DCSP is DCSP not DCSP reliable') DCNL def test_fallback_policy(self):
def test_creationdate_policy(self):
def test_boosting_dependencies(self):
def test_load_default(self):
def test_translate_peer_info(self):
def test_levenshtein(self):
def test_update_statistics(self):
def test_escape_xml(self):
def test_insert_torrent_unknown_source(self):
def test_unknown_source(self):
def test_failed_start_download(self):
def set_boosting_settings(self):
def check_torrents(self, src, target=1):
def check_source(self, src):
@deferred(timeout=30) DCNL def test_rss(self):
def _on_error_rss(self, dummy_1, dummy_2):
@deferred(timeout=8) DCNL def test_rss_unexist(self):
@deferred(timeout=8) DCNL def test_rss_unavailable(self):
@deferred(timeout=10) DCNL def test_dir(self):
@deferred(timeout=10) DCNL def test_dir_archive_example(self):
def _load(self, _):
@blocking_call_on_reactor_thread DCNL def create_torrents_in_channel(self, dispersy_cid_hex):
@deferred(timeout=20) DCNL def test_chn_lookup(self):
@deferred(timeout=30) DCNL def test_chn_exist_lookup(self):
@deferred(timeout=30) DCNL def test_chn_max_torrents(self):
def get_peer_info(self):
def is_valid(self):
def get_infohash(self):
def get_session(self):
def set_settings(self, _):
def shutdown(self):
def get_download(self, x):
def test_init(self):
def test_getters_setters_1(self):
def test_getters_setters_2(self):
def test_get_files_completion(self):
def test_get_availability(self):
def test_get_vod_dest_dir(self):
def test_get_vod_stream(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def setUp(self, autoload_discovery=True):
def test_no_lock_file(self):
def test_invalid_pid_in_lock_file(self):
def test_own_pid_in_lock_file(self):
def test_other_instance_running(self):
def test_dead_pid_in_lock_file(self):
def setUp(self, annotate=True):
def setUp(self, annotate=True):
@blocking_call_on_reactor_thread DCNL def test_initialize(self):
@blocking_call_on_reactor_thread DCNL def test_add_tracker(self):
@blocking_call_on_reactor_thread DCNL def test_get_tracker_info(self):
@blocking_call_on_reactor_thread DCNL def test_update_tracker_info(self):
@blocking_call_on_reactor_thread DCNL def test_should_check_tracker(self):
@blocking_call_on_reactor_thread DCNL def test_get_tracker_for_check(self):
def test_get_market_community(self):
def add_transaction_and_payment(self):
@deferred(timeout=10) DCNL def test_get_asks(self):
@deferred(timeout=10) DCNL def test_create_ask(self):
@deferred(timeout=10) DCNL def test_create_ask_no_price(self):
@deferred(timeout=10) DCNL def test_create_ask_no_price_type(self):
@deferred(timeout=10) DCNL def test_get_bids(self):
@deferred(timeout=10) DCNL def test_create_bid(self):
@deferred(timeout=10) DCNL def test_create_bid_no_price(self):
@deferred(timeout=10) DCNL def test_create_bid_no_price_type(self):
@deferred(timeout=10) DCNL def test_get_transactions(self):
@deferred(timeout=10) DCNL def test_get_payment_not_found(self):
@deferred(timeout=10) DCNL def test_get_orders(self):
@deferred(timeout=10) DCNL def test_get_payments(self):
@deferred(timeout=10) DCNL def test_cancel_order_not_found(self):
@deferred(timeout=10) DCNL def test_cancel_order_invalid(self):
@deferred(timeout=10) DCNL def test_cancel_order(self):
def test_convert_torrent_to_json_dict(self):
def test_convert_torrent_to_json_tuple(self):
def test_get_parameter(self):
def test_convert_db_channel_to_json(self):
def test_can_edit_channel(self):
def test_fix_unicode_array(self):
def test_fix_unicode_dict(self):
@deferred(timeout=20) DCNL def test_search_results(self):
@deferred(timeout=20) DCNL def test_events(self):
@deferred(timeout=20) DCNL def test_family_filter_search(self):
@deferred(timeout=10) DCNL def test_get_tribler_statistics(self):
@deferred(timeout=10) DCNL def test_get_dispersy_statistics(self):
@deferred(timeout=10) DCNL def test_get_community_statistics(self):
@deferred(10) DCNL def test_unhandled_exception(self):
@deferred(timeout=10) DCNL def test_get_statistics_no_community(self):
@deferred(timeout=10) DCNL def test_get_statistics(self):
@deferred(timeout=10) DCNL def test_get_statistics_no_data(self):
@deferred(timeout=10) DCNL def test_get_blocks_no_community(self):
@deferred(timeout=10) DCNL def test_get_blocks(self):
@deferred(timeout=10) DCNL def test_get_blocks_bad_limit_too_many(self):
@deferred(timeout=10) DCNL def test_get_blocks_bad_limit_negative(self):
@deferred(timeout=10) DCNL def test_get_blocks_bad_limit_nan(self):
@deferred(timeout=10) DCNL def test_get_blocks_bad_limit_nothing(self):
@deferred(timeout=10) DCNL def test_get_blocks_unlimited(self):
@deferred(timeout=10) DCNL def test_get_random_torrents(self):
@deferred(timeout=10) DCNL def test_random_torrents_negative(self):
@deferred(timeout=10) DCNL def test_get_torrent_trackers_404(self):
@deferred(timeout=10) DCNL def test_get_torrent_trackers(self):
@deferred(timeout=20) DCNL @inlineCallbacks DCNL def test_check_torrent_health(self):
@deferred(timeout=10) DCNL def test_shutdown(self):
@deferred(timeout=10) DCNL def test_create_torrent(self):
@deferred(timeout=10) DCNL def test_create_torrent_io_error(self):
def test_get_parameters(self):
@deferred(timeout=10) DCNL def test_get_downloads_no_downloads(self):
@deferred(timeout=20) DCNL def test_get_downloads(self):
@deferred(timeout=10) DCNL def test_start_download_no_uri(self):
@deferred(timeout=10) DCNL def test_start_download_bad_params(self):
@deferred(timeout=10) DCNL def test_start_download_bad_uri(self):
@deferred(timeout=10) DCNL def test_start_download_from_file(self):
@deferred(timeout=10) DCNL def test_start_download_from_magnet(self):
@deferred(timeout=10) DCNL def test_start_download_from_bad_url(self):
@deferred(timeout=10) DCNL def test_remove_download_no_remove_data_param(self):
@deferred(timeout=10) DCNL def test_remove_download_wrong_infohash(self):
@deferred(timeout=10) DCNL def test_remove_download(self):
@deferred(timeout=10) DCNL def test_stop_download_wrong_infohash(self):
@deferred(timeout=10) DCNL def test_stop_download(self):
@deferred(timeout=10) DCNL def test_select_download_file_range(self):
@deferred(timeout=10) DCNL def test_select_download_file(self):
@deferred(timeout=10) DCNL def test_resume_download_wrong_infohash(self):
@deferred(timeout=10) DCNL def test_resume_download(self):
@deferred(timeout=10) DCNL def test_recheck_download(self):
@deferred(timeout=10) DCNL def test_change_hops_error(self):
@deferred(timeout=10) DCNL def test_download_unknown_state(self):
@deferred(timeout=10) DCNL def test_export_unknown_download(self):
@deferred(timeout=10) DCNL def test_export_download(self):
@deferred(timeout=10) DCNL def test_change_hops(self):
def test_get_parameters(self):
@deferred(timeout=10) DCNL def test_get_state(self):
@deferred(timeout=20) DCNL def test_get_wallets(self):
@deferred(timeout=20) DCNL def test_create_wallet_exists(self):
@deferred(timeout=20) DCNL def test_create_wallet_btc_pw(self):
@deferred(timeout=20) DCNL def test_create_wallet_btc(self):
@deferred(timeout=20) DCNL def test_create_wallet(self):
@deferred(timeout=20) DCNL def test_get_wallet_balance(self):
@deferred(timeout=20) DCNL def test_get_wallet_transaction(self):
@deferred(timeout=20) DCNL def test_transfer_no_btc(self):
@deferred(timeout=20) DCNL def test_transfer_not_created(self):
@deferred(timeout=20) DCNL def test_transfer_bad_params(self):
@deferred(timeout=20) DCNL def test_transfer_error(self):
@deferred(timeout=20) DCNL def test_transfer(self):
@deferred(timeout=10) DCNL def test_channels_unknown_endpoint(self):
@deferred(timeout=10) DCNL def test_get_discovered_channels_no_channels(self):
@deferred(timeout=10) DCNL def test_get_discovered_channels(self):
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create(self):
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create_default_mode(self):
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create_duplicate_name_error(self):
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create_no_name_param(self):
@deferred(timeout=10) DCNL def test_my_channel_endpoint_create_no_description_param(self):
def setUp(self, autoload_discovery=True):
def on_dispersy_create_votecast(self, cid, vote, _):
@deferred(timeout=10) DCNL def test_subscribe_channel_already_subscribed(self):
@deferred(timeout=10) DCNL def test_subscribe_channel(self):
@deferred(timeout=10) DCNL def test_sub_channel_throw_error(self):
@deferred(timeout=10) DCNL def test_unsubscribe_channel_not_exist(self):
@deferred(timeout=10) DCNL def test_unsubscribe_channel_not_subscribed(self):
@deferred(timeout=10) DCNL def test_get_subscribed_channels_no_subscriptions(self):
@deferred(timeout=10) DCNL def test_get_subscribed_channels_one_subscription(self):
@deferred(timeout=10) DCNL def test_unsubscribe_channel(self):
@deferred(timeout=10) DCNL @inlineCallbacks DCNL def test_popular_channels_endpoint(self):
@deferred(timeout=10) DCNL def test_popular_channels_limit_neg(self):
@deferred(timeout=10) DCNL def test_rss_feeds_endpoint_with_channel(self):
@deferred(timeout=10) DCNL def test_add_rss_feed_no_my_channel(self):
@deferred(timeout=10) DCNL def test_add_rss_feed_conflict(self):
@deferred(timeout=10) DCNL def test_add_rss_feed_with_channel(self):
@deferred(timeout=10) DCNL def test_remove_rss_feed_no_channel(self):
@deferred(timeout=10) DCNL def test_remove_rss_feed_invalid_url(self):
@deferred(timeout=10) DCNL def test_remove_rss_feed_with_channel(self):
@deferred(timeout=10) DCNL def test_recheck_rss_feeds_no_channel(self):
@deferred(timeout=10) DCNL def test_recheck_rss_feeds(self):
@deferred(timeout=10) DCNL def test_get_rss_feed_no_authorization(self):
@deferred(timeout=10) DCNL def test_get_rss_feed_no_channel_obj(self):
@deferred(timeout=10) DCNL def test_my_channel_overview_endpoint_no_my_channel(self):
@deferred(timeout=10) DCNL def test_my_channel_overview_endpoint_with_channel(self):
@deferred(timeout=10) DCNL def test_edit_my_channel_no_channel(self):
@deferred(timeout=10) DCNL def test_edit_my_channel_no_cmty(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_edit_channel(self):
@deferred(timeout=10) DCNL def test_get_torrents_in_channel_invalid_cid(self):
@deferred(timeout=15) DCNL @inlineCallbacks DCNL def test_get_torrents_in_channel(self):
@deferred(timeout=10) DCNL def test_add_torrent_to_channel(self):
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_with_description(self):
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_404(self):
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_missing_parameter(self):
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_500(self):
@deferred(timeout=10) DCNL def test_add_torrent_from_url_to_channel_with_description(self):
@deferred(timeout=10) DCNL def test_add_torrent_from_magnet_to_channel(self):
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_404(self):
@deferred(timeout=10) DCNL def test_add_torrent_to_channel_500(self):
@deferred(timeout=10) DCNL def test_remove_tor_unknown_channel(self):
@deferred(timeout=10) DCNL def test_remove_tor_unknown_infohash(self):
@deferred(timeout=10) DCNL def test_remove_tor_unknown_cmty(self):
@deferred(timeout=10) DCNL def test_remove_torrent(self):
@deferred(timeout=10) DCNL def test_get_playlists_endpoint_without_channel(self):
@deferred(timeout=10) DCNL def test_playlists_endpoint_no_playlists(self):
@deferred(timeout=10) DCNL def test_playlists_endpoint(self):
@deferred(timeout=10) DCNL def test_create_playlist_no_channel(self):
@deferred(timeout=10) DCNL def test_create_playlist_no_name(self):
@deferred(timeout=10) DCNL def test_create_playlist_no_description(self):
@deferred(timeout=10) DCNL def test_create_playlist_no_cmty(self):
@deferred(timeout=10) DCNL def test_create_playlist(self):
@deferred(timeout=10) DCNL def test_delete_playlist_no_channel(self):
@deferred(timeout=10) DCNL def test_delete_playlist_no_playlist(self):
@deferred(timeout=10) DCNL def test_delete_playlist_no_community(self):
@deferred(timeout=10) DCNL def test_delete_playlist(self):
@deferred(timeout=10) DCNL def test_edit_playlist_no_name(self):
@deferred(timeout=10) DCNL def test_edit_playlist_no_description(self):
@deferred(timeout=10) DCNL def test_edit_playlist_no_channel(self):
@deferred(timeout=10) DCNL def test_edit_playlist_no_playlist(self):
@deferred(timeout=10) DCNL def test_edit_playlist_no_community(self):
@deferred(timeout=10) DCNL def test_edit_playlist(self):
@deferred(timeout=10) DCNL def test_add_torrent_no_channel(self):
@deferred(timeout=10) DCNL def test_add_torrent_no_playlist(self):
@deferred(timeout=10) DCNL def test_add_torrent_no_community(self):
@deferred(timeout=15) DCNL @inlineCallbacks DCNL def test_add_torrent_playlist(self):
@deferred(timeout=10) DCNL def test_delete_torrent_no_channel(self):
@deferred(timeout=10) DCNL def test_delete_torrent_no_playlist(self):
@deferred(timeout=10) DCNL def test_remove_torrent_no_community(self):
@deferred(timeout=15) DCNL @inlineCallbacks DCNL def test_remove_torrent_playlist(self):
@deferred(timeout=10) DCNL def test_get_channel_info_non_existent(self):
@deferred(timeout=10) DCNL def test_get_channel_info(self):
@blocking_call_on_reactor_thread DCNL @inlineCallbacks DCNL def test_get_torrentinfo(self):
@deferred(timeout=10) DCNL def test_on_got_invalid_metainfo(self):
@deferred(timeout=10) DCNL def test_search_no_parameter(self):
@deferred(timeout=10) DCNL def test_search_no_matches(self):
@deferred(timeout=10) DCNL def test_search(self):
@deferred(timeout=10) DCNL def test_completions_no_query(self):
@deferred(timeout=10) DCNL def test_completions(self):
def verify_settings(self, settings):
@deferred(timeout=10) DCNL def test_get_settings(self):
@deferred(timeout=10) DCNL def test_set_settings_invalid_dict(self):
@deferred(timeout=10) DCNL @inlineCallbacks DCNL def test_set_settings_no_key(self):
@deferred(timeout=10) DCNL def test_set_settings(self):
@deferred(timeout=10) DCNL def test_get_circuit_no_community(self):
@deferred(timeout=10) DCNL def test_get_circuits(self):
@blocking_call_on_reactor_thread DCNL def test_search_names_no_sort(self):
@blocking_call_on_reactor_thread DCNL def test_search_names_sort(self):
@blocking_call_on_reactor_thread DCNL def test_search_local_torrents(self):
@blocking_call_on_reactor_thread DCNL def test_delete_single_element(self):
@blocking_call_on_reactor_thread DCNL def test_delete_tuple(self):
@deferred(timeout=10) DCNL def test_cleanup(self):
@deferred(timeout=10) DCNL def test_connect_to_tracker(self):
@deferred(timeout=10) DCNL def test_metainfo_timeout(self):
def test_methods(self):
@blocking_call_on_reactor_thread DCNL def test_initialize(self):
@blocking_call_on_reactor_thread DCNL def test_reschedule_tracker_select(self):
@blocking_call_on_reactor_thread DCNL def test_add_gui_request_no_trackers(self):
@blocking_call_on_reactor_thread DCNL def test_add_gui_request_cached(self):
@blocking_call_on_reactor_thread DCNL def test_add_gui_request_no_tor(self):
@deferred(timeout=30) DCNL def test_tracker_test_error_resolve(self):
@blocking_call_on_reactor_thread DCNL def test_tracker_test_invalid_tracker(self):
@deferred(timeout=10) DCNL def test_tracker_no_infohashes(self):
def test_add_content_file_and_copy(self):
def test_add_content_dir(self):
def test_add_content_dir_and_file(self):
def test_add_content_announce_list(self):
def test_add_content_httpseeds(self):
def test_add_content_piece_length(self):
def test_add_content_file_save(self):
@raises(ValueError) DCNL def test_add_tdef_not_finalized(self):
@raises(DuplicateDownloadException) DCNL def test_add_duplicate_download(self):
def test_load_download_pstate(self):
@deferred(timeout=10) DCNL def test_dlstates_cb_error(self):
@deferred(timeout=10) DCNL def test_dlstates_cb_seeding(self):
def test_load_checkpoint(self):
def test_load_communities(self):
@blocking_call_on_reactor_thread DCNL def test_download_file_not_running(self):
def test_check_session_timeout(self):
def test_schedule_callback_processing(self):
def test_cleanup_session(self):
def test_data_came_in(self):
def test_handle_new_request_no_metadata(self):
def test_handle_new_request_no_torrent_store(self):
@raises(FileNotFound) DCNL def test_load_metadata_not_found(self):
@raises(FileNotFound) DCNL def test_load_torrent_not_found(self):
def test_handle_packet_as_receiver(self):
def test_handle_packet_as_sender(self):
def test_handle_error(self):
def test_send_error_packet(self):
@raises(InvalidStringException) DCNL def test_get_string_no_end(self):
@raises(InvalidPacketException) DCNL def test_decode_options_no_option(self):
@raises(InvalidPacketException) DCNL def test_decode_options_no_value(self):
@raises(InvalidOptionException) DCNL def test_decode_options_unknown(self):
@raises(InvalidOptionException) DCNL def test_decode_options_invalid(self):
@raises(InvalidPacketException) DCNL def test_decode_data(self):
@raises(InvalidPacketException) DCNL def test_decode_ack(self):
@raises(InvalidPacketException) DCNL def test_decode_error_too_small(self):
@raises(InvalidPacketException) DCNL def test_decode_error_no_message(self):
@raises(InvalidPacketException) DCNL def test_decode_error_invalid_pkg(self):
@raises(InvalidPacketException) DCNL def test_decode_packet_too_small(self):
@raises(InvalidPacketException) DCNL def test_decode_packet_opcode(self):
def test_encode_packet_error(self):
def setUp(self, annotate=True):
def test_init_with_config(self):
def test_init_without_config(self):
def test_write_load(self):
def test_libtorrent_proxy_settings(self):
def test_get_set_methods_general(self):
def test_get_set_methods_torrent_checking(self):
def test_get_set_methods_http_api(self):
def test_get_set_methods_dispersy(self):
def test_get_set_methods_libtorrent(self):
def test_get_set_methods_mainline_dht(self):
def test_get_set_methods_video_server(self):
def test_get_set_methods_tunnel_community(self):
def test_get_set_methods_upgrader(self):
def test_get_set_methods_torrent_store(self):
def test_get_set_methods_wallets(self):
def test_get_set_methods_metadata(self):
def test_get_set_methods_torrent_collecting(self):
def test_get_set_methods_search_community(self):
def test_get_set_methods_allchannel_community(self):
def test_get_set_methods_channel_community(self):
def test_get_set_methods_preview_channel_community(self):
def test_get_set_methods_trustchain_community(self):
def test_get_set_methods_watch_folder(self):
def test_get_set_methods_credit_mining(self):
@deferred(timeout=20) DCNL @skipIf((sys.platform == 'win32'), 'chmod DCSP does DCSP not DCSP work DCSP on DCSP Windows') DCNL def test_torrent_download(self):
@deferred(timeout=20) DCNL def test_metadata_download(self):
def read_extend_metadata_close(self, conn):
def send(self, data):
def recv(self):
def _readn(self, n):
def catch_exception(self, type, value, tb):
def check_exceptions(self):
def add_info_about_infohash(self, infohash, seeders, leechers, downloaded=0):
def get_info_about_infohash(self, infohash):
def has_info_about_infohash(self, infohash):
def datagramReceived(self, response, (host, port)):
def send_connection_reply(self, host, port):
def send_scrape_reply(self, host, port, infohashes):
def send_error(self, host, port, error_msg):
def start(self):
def stop(self):
def render_GET(self, request):
def start(self):
def stop(self):
def __init__(self):
def start_tribler(self, options):
def makeService(self, options):
def load_market_community(self, _):
def start_tribler(self, options):
def makeService(self, options):
def __init__(self):
def start_tunnel(self, options):
def makeService(self, options):
def handle(self, **options):
def handle(self, **options):
def handle(self, **options):
def extract_file_contents(self, file_obj, **kwargs):
def run(self, spelling_query=None, **kwargs):
def run_mlt(self, **kwargs):
def update(self, index, iterable, commit=True):
def remove(self, obj_or_string):
def clear(self, models=None, commit=True):
@log_query DCNL def search(self, query_string, **kwargs):
def prep_value(self, value):
def more_like_this(self, model_instance, additional_query_string=None, result_class=None):
def extract_file_contents(self, file_obj):
def build_schema(self, fields):
def build_models_list(self):
def __init__(self, children=None, connector=None, negated=False):
def _new_instance(cls, children=None, connector=None, negated=False):
def __deepcopy__(self, memodict):
def __len__(self):
def __bool__(self):
def __contains__(self, other):
def add(self, node, conn_type):
def negate(self):
def start_subtree(self, conn_type):
def end_subtree(self):
def as_query_string(self, query_fragment_callback):
def split_expression(self, expression):
def __getstate__(self):
def __setstate__(self, obj_dict):
def has_run(self):
def build_params(self, spelling_query=None):
def run(self, spelling_query=None, **kwargs):
def run_mlt(self, **kwargs):
def run_raw(self, **kwargs):
def get_count(self):
def get_results(self, **kwargs):
def get_facet_counts(self):
def get_stats(self):
def get_spelling_suggestion(self, preferred_query=None):
def boost_fragment(self, boost_word, boost_value):
def matching_all_fragment(self):
def build_query(self):
def build_query_fragment(self, field, filter_type, value):
def clean(self, query_fragment):
def add_filter(self, query_filter, use_or=False):
def add_order_by(self, field):
def clear_order_by(self):
def add_model(self, model):
def set_limits(self, low=None, high=None):
def clear_limits(self):
def add_boost(self, term, boost_value):
def raw_search(self, query_string, **kwargs):
def more_like_this(self, model_instance):
def add_stats_query(self, stats_field, stats_facets):
def add_highlight(self, **kwargs):
def add_within(self, field, point_1, point_2):
def add_dwithin(self, field, point, distance):
def add_distance(self, field, point):
def add_field_facet(self, field, **options):
def add_date_facet(self, field, start_date, end_date, gap_by, gap_amount=1):
def add_query_facet(self, field, query):
def add_narrow_query(self, query):
def set_result_class(self, klass):
def using(self, using=None):
def _reset(self):
def reset_sessions(self):
def setup(self):
def _from_python(self, value):
def _to_python(self, value):
def clean(self, query_fragment):
def clear(self, models=None, commit=True):
def setup(self):
def _iso_datetime(self, value):
def _from_python(self, value):
def _to_python(self, value):
def run(self, spelling_query=None, **kwargs):
def run_mlt(self, **kwargs):
def get_form_kwargs(self):
def get(self, request, *args, **kwargs):
def has_default(self):
@property DCNL def default(self):
def prepare(self, obj):
def resolve_attributes_lookup(self, current_objects, attributes):
def split_model_attr_lookups(self):
@classmethod DCNL def get_iterable_objects(cls, current_objects):
def prepare_template(self, obj):
def convert(self, value):
def get_model(self):
def index_queryset(self, using=None):
def read_queryset(self, using=None):
def build_queryset(self, using=None, start_date=None, end_date=None):
def prepare(self, obj):
def get_content_field(self):
def get_field_weights(self):
def update(self, using=None):
def update_object(self, instance, using=None, **kwargs):
def remove_object(self, instance, using=None, **kwargs):
def clear(self, using=None):
def reindex(self, using=None):
def get_updated_field(self):
def should_update(self, instance, **kwargs):
def load_all_queryset(self):
def should_skip_field(self, field):
def get_index_fieldname(self, f):
def get_fields(self, fields=None, excludes=None):
def content_type(self):
def get_additional_fields(self):
def get_stored_fields(self):
def __getstate__(self):
def __setstate__(self, data_dict):
def __getstate__(self):
def __setstate__(self, data_dict):
def __getitem__(self, k):
def all(self):
def none(self):
def filter(self, *args, **kwargs):
def exclude(self, *args, **kwargs):
def filter_and(self, *args, **kwargs):
def filter_or(self, *args, **kwargs):
def order_by(self, *args):
def highlight(self, **kwargs):
def models(self, *models):
def result_class(self, klass):
def boost(self, term, boost):
def facet(self, field, **options):
def within(self, field, point_1, point_2):
def dwithin(self, field, point, distance):
def stats(self, field):
def stats_facet(self, field, facet_fields=None):
def distance(self, field, point):
def date_facet(self, field, start_date, end_date, gap_by, gap_amount=1):
def query_facet(self, field, query):
def narrow(self, query):
def raw_search(self, query_string, **kwargs):
def load_all(self):
def auto_query(self, query_string, fieldname=u'content'):
def autocomplete(self, **kwargs):
def using(self, connection_name):
def count(self):
def best_match(self):
def latest(self, date_field):
def more_like_this(self, model_instance):
def facet_counts(self):
def stats_results(self):
def set_spelling_query(self, spelling_query):
def spelling_suggestion(self, preferred_query=None):
def values(self, *fields):
def values_list(self, *fields, **kwargs):
def load_all_queryset(self, model, queryset):
def get_search_queryset(self):
def no_query_found(self):
def get_models(self):
def __call__(self, request):
def build_form(self, form_kwargs=None):
def get_query(self):
def get_results(self):
def build_page(self):
def extra_context(self):
def create_response(self):
def setup(self):
def teardown(self):
def handle_save(self, sender, instance, **kwargs):
def handle_delete(self, sender, instance, **kwargs):
def test_get_form_kwargs(self):
def test_search_view_response(self):
def test_search_view_form_valid(self):
def test_search_view_form_invalid(self):
def get_request(self, url, method=u'get', data=None, **kwargs):
@patch(u'haystack.management.commands.update_index.Command.update_backend') DCNL def test_update_index_default_using(self, m):
@patch(u'haystack.management.commands.update_index.Command.update_backend') DCNL def test_update_index_using(self, m):
@patch(u'haystack.loading.ConnectionHandler.__getitem__') DCNL def test_clear_index_default_using(self, m):
@patch(u'haystack.loading.ConnectionHandler.__getitem__') DCNL def test_clear_index_using(self, m):
@patch(u'haystack.loading.ConnectionHandler.__getitem__') DCNL @patch(u'haystack.management.commands.update_index.Command.update_backend') DCNL def test_rebuild_index_default_using(self, m1, m2):
@patch(u'haystack.loading.ConnectionHandler.__getitem__') DCNL @patch(u'haystack.management.commands.update_index.Command.update_backend') DCNL def test_rebuild_index_using(self, m1, m2):
@patch(u'haystack.management.commands.update_index.Command.handle') DCNL @patch(u'haystack.management.commands.clear_index.Command.handle') DCNL def test_rebuild_index_nocommit(self, *mocks):
def test_and_or(self):
def test_or_and(self):
def test_dictionary_lookup(self):
def test_query__in_empty_list(self):
def test_query__in_empty_list(self):
def test_build_query_with_dwithin_range(self):
def test_build_query_with_dwithin_range(self):
def test_query__in_empty_list(self):
def test_more_like_this_custom_result_class(self):
def test_query__in_empty_list(self):
def verify_indexed_documents(self):
def test_age_with_time_zones(self):
def test_build_query_with_dwithin_range(self):
def test_build_query_with_dwithin_range(self):
def handle(self, *args, **options):
def to_representation(self, obj):
def to_internal_value(self, data):
def to_internal_value(self, data):
def to_internal_value(self, data):
def get_validators(self):
def validate_domain(self, value):
def db_type(self, connection=None):
def pre_save(self, model_instance, add):
def formfield(self, **kwargs):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_build(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_response_data(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_build_str(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_admin_can_create_builds_on_other_apps(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_unauthorized_user_cannot_modify_build(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_new_build_does_not_scale_up_automatically(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_config(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_overlapping_config(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_response_data(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_response_data_types_converted(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_config_set_same_key(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_config_set_unicode(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_config_str(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_valid_config_keys(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_invalid_config_keys(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_admin_can_create_config_on_other_apps(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_limit_memory(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_limit_cpu(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_tags(self):
def test_config_owner_is_requesting_user(self):
def test_unauthorized_user_cannot_modify_config(self):
@mock.patch(u'requests.get', mock_status_ok) DCNL @mock.patch(u'time.sleep', (lambda func: func)) DCNL def test_app_healthcheck_good(self):
@mock.patch(u'requests.get', mock_status_not_found) DCNL @mock.patch(u'api.models.get_etcd_client', (lambda func: func)) DCNL @mock.patch(u'time.sleep', (lambda func: func)) DCNL @mock.patch(u'api.models.logger') DCNL def test_app_healthcheck_bad(self, mock_logger):
@mock.patch(u'requests.get', mock_status_not_found) DCNL @mock.patch(u'api.models.get_etcd_client', (lambda func: func)) DCNL @mock.patch(u'time.sleep') DCNL def test_app_backoff_interval(self, mock_time):
@mock.patch(u'requests.get', mock_status_ok) DCNL @mock.patch(u'time.sleep') DCNL def test_app_healthcheck_initial_delay(self, mock_time):
@mock.patch(u'requests.get') DCNL @mock.patch(u'time.sleep', (lambda func: func)) DCNL def test_app_healthcheck_timeout(self, mock_request):
@mock.patch(u'requests.get', mock_request_connection_error) DCNL @mock.patch(u'time.sleep', (lambda func: func)) DCNL def test_app_healthcheck_connection_error(self):
def test_auth(self):
@override_settings(REGISTRATION_MODE=u'disabled') DCNL def test_auth_registration_disabled(self):
@override_settings(REGISTRATION_MODE=u'admin_only') DCNL def test_auth_registration_admin_only_fails_if_not_admin(self):
@override_settings(REGISTRATION_MODE=u'admin_only') DCNL def test_auth_registration_admin_only_works(self):
@override_settings(REGISTRATION_MODE=u'not_a_mode') DCNL def test_auth_registration_fails_with_nonexistant_mode(self):
def test_cancel(self):
def test_passwd(self):
def test_change_user_passwd(self):
def test_regenerate(self):
def test_container_state_good(self):
def test_container_state_protected(self):
def test_container_str(self):
def test_admin_can_manage_other_containers(self):
def test_scale_without_build_should_error(self):
def test_command_good(self):
def test_run_command_good(self):
def test_scaling_does_not_add_run_proctypes_to_structure(self):
def test_scale_with_unauthorized_user_returns_403(self):
def test_modified_procfile_from_build_removes_containers(self):
def run_tests(self, test_labels, extra_tests=None, **kwargs):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_release(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_release_str(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_release_summary(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_admin_can_create_release(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_unauthorized_user_cannot_modify_release(self):
def _check_key(self, pubkey):
def _check_bad_key(self, pubkey):
def _check_duplicate_key(self, pubkey, pubkey2):
def test_rsa_key_str(self):
def test_admin_can_list(self):
def test_unauthorized_user_cannot_modify_perms(self):
def test_collaborator_cannot_share(self):
def test_response_data(self):
def test_delete_domain_does_not_remove_latest(self):
def test_delete_domain_does_not_remove_others(self):
def test_manage_domain_wildcard(self):
def test_admin_can_add_domains_to_other_apps(self):
def test_unauthorized_user_cannot_modify_domain(self):
def test_deis_version_header_good(self):
def test_deis_version_header_bad(self):
def test_deis_version_header_not_present(self):
def test_push_hook(self):
def test_push_abuse(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL def test_build_hook(self):
def test_build_hook_procfile(self):
def test_build_hook_dockerfile(self):
def test_config_hook(self):
def test_admin_can_hook(self):
def test_app(self):
def test_response_data(self):
@mock.patch(u'api.models.logger') DCNL def test_app_release_notes_in_logs(self, mock_logger):
def test_app_reserved_names(self):
def test_app_structure_is_valid_json(self):
@mock.patch(u'requests.post', mock_status_ok) DCNL @mock.patch(u'api.models.logger') DCNL def test_admin_can_manage_other_apps(self, mock_logger):
def test_admin_can_see_other_apps(self):
def test_run_without_auth(self):
def test_run_without_release_should_error(self):
def test_unauthorized_user_cannot_see_app(self):
def test_create_certificate_with_domain(self):
def test_create_wildcard_certificate(self):
def test_create_certificate_with_different_common_name(self):
def test_get_certificate_screens_data(self):
def test_certficate_denied_requests(self):
def test_delete_certificate(self):
def log(self, message, level=logging.INFO):
def create(self, *args, **kwargs):
def delete(self, *args, **kwargs):
def _clean_app_logs(self):
def scale(self, user, structure):
def _start_containers(self, to_add):
def _restart_containers(self, to_restart):
def _destroy_containers(self, to_destroy):
def deploy(self, user, release):
def _default_scale(self, user, release):
def logs(self, log_lines=str(settings.LOG_LINES)):
def run(self, user, command):
def run(self, command):
def save(self, **kwargs):
def new(self, user, config, build, summary=None, source_version=u'latest'):
def previous(self):
def forwards(self, orm):
def forwards(self, orm):
def forwards(self, orm):
def forwards(self, orm):
def forwards(self, orm):
def has_permission(self, request, view):
def has_permission(self, request, view):
def has_permission(self, request, view):
def has_permission(self, request, view):
def has_permission(self, request, view):
def has_permission(self, request, view):
def authenticate(self, request):
def authenticate(self, request):
def get_object(self):
def list(self, request, *args, **kwargs):
def get_object(self, **kwargs):
def get_object(self, **kwargs):
def rollback(self, request, **kwargs):
def process_request(self, request):
def process_response(self, request, response):
def post_save(self, obj):
def publish_release(self, source, config, target, deis_registry):
def build(self, source, config, repo, tag):
def pull(self, repo, tag):
def push(self, repo, tag):
def tag(self, image, repo, tag):
def create(self, name, image, command, **kwargs):
def destroy(self, name):
def run(self, name, image, entrypoint, command):
def start(self, name):
def state(self, name):
def stop(self, name):
def create(self, name, image, command, **kwargs):
def destroy(self, name):
def run(self, name, image, entrypoint, command):
def start(self, name):
def state(self, name):
def stop(self, name):
def create(self, name, image, command='', template=None, **kwargs):
def start(self, name):
def stop(self, name):
def destroy(self, name):
def run(self, name, image, entrypoint, command):
def state(self, name):
def create(self, name, image, command, **kwargs):
def destroy(self, name):
def run(self, name, image, entrypoint, command):
def start(self, name):
def stop(self, name):
def _render_template(self, t, ctx=None):
def test_render_syntax_error(self):
def test_render_context_error(self):
def report(self, logprob):
@property DCNL def converged(self):
def score_samples(self, X, lengths=None):
def score(self, X, lengths=None):
def decode(self, X, lengths=None, algorithm=None):
def predict(self, X, lengths=None):
def predict_proba(self, X, lengths=None):
def sample(self, n_samples=1, random_state=None):
def fit(self, X, lengths=None):
def _init(self, X, lengths):
def _check(self):
def _initialize_sufficient_statistics(self):
def _accumulate_sufficient_statistics(self, stats, X, framelogprob, posteriors, fwdlattice, bwdlattice):
def _do_mstep(self, stats):
@property DCNL def covars_(self):
def _check_input_symbols(self, X):
def omittags(self):
def omit(self):
def repeat(self, fn, list, *args):
def __init__(self, callback, html, attribute='node', codecs=(defaultEncoder, defaultDecoder), warnings=False):
def render(self, *args, **kwargs):
def structure(self):
def __call__(self, name, value=None):
def __init__(self, asciidoc_py=None):
def __import_asciidoc(self, reload=False):
def execute(self, infile, outfile=None, backend=None):
def test_alternative_types(self, ty, other_ty, alternatives):
def test_alternative_types(self, ty, other_ty, alternatives):
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True):
def create_virtualenv(self, no_site_packages=True):
def parse_args(self, argv):
def post_process(self):
def post_process(self):
def __init__(self, fd):
def read(self, length=None):
def __init__(self, data, limit):
def add_column(self, width, label='', just='l'):
def authenticate(self):
def connect(self):
def __init__(self, host, port=None, timeout=None, use_ssl=False, auth_tok=None, creds=None, doc_root=None, key_file=None, cert_file=None, ca_file=None, insecure=False, configure_via_auth=True):
def set_auth_token(self, auth_tok):
def configure_from_url(self, url):
def make_auth_plugin(self, creds, insecure):
def get_connection_type(self):
def _authenticate(self, force_reauth=False):
@handle_unauthenticated DCNL def do_request(self, method, action, body=None, headers=None, params=None):
def _construct_url(self, action, params=None):
@handle_redirects DCNL def _do_request(self, method, url, body, headers):
def get_status_code(self, response):
def _extract_params(self, actual_params, allowed_params):
def start(self, application, default_port):
def wait(self):
def run_server(self):
def _single_run(self, application, sock):
def process_request(self, req):
def process_response(self, response):
@staticmethod DCNL def print_generator(app_iter):
def __init__(self, mapper):
@webob.dec.wsgify DCNL def __call__(self, req):
@staticmethod DCNL @webob.dec.wsgify DCNL def _dispatch(req):
def best_match_content_type(self):
def get_content_type(self, allowed_content_types):
def has_body(self, request):
def __init__(self, controller, deserializer=None, serializer=None):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
def dispatch(self, obj, action, *args, **kwargs):
def get_action_args(self, request_environment):
def process_request(self, req):
def _match_version_string(self, subject):
def process_request(self, req):
def process_request(self, req):
def _verify_metadata(self, image_meta):
@staticmethod DCNL def _match_request(request):
def process_request(self, request):
@staticmethod DCNL def _stash_request_info(request, image_id, method):
@staticmethod DCNL def _fetch_request_info(request):
def process_response(self, resp):
def get_status_code(self, response):
def get_from_cache(self, image_id):
def set_rules(self, rules):
def load_rules(self):
@staticmethod DCNL def _find_policy_file():
def _read_policy_file(self):
def _check(self, context, rule, target, *args, **kwargs):
def enforce(self, context, action, target):
def check(self, context, action, target):
@utils.mutating DCNL def create(self, req, image_id, member_id):
@utils.mutating DCNL def update(self, req, image_id, member_id, status):
def index(self, req, image_id):
@utils.mutating DCNL def delete(self, req, image_id, member_id):
def _decode_json_pointer(self, pointer):
def _validate_json_pointer(self, pointer):
def index(self, req, image_id):
@utils.mutating DCNL def delete(self, req, image_id, id):
def default(self, req, image_id, id, body=None):
@utils.mutating DCNL def update(self, req, image_id, id, body=None):
@utils.mutating DCNL def update_all(self, req, image_id, body):
def index_shared_images(self, req, id):
def _enforce(self, req, action):
def index(self, req):
def detail(self, req):
def _get_query_params(self, req):
def _get_filters(self, req):
def meta(self, req, id):
@staticmethod DCNL def _validate_source(source, req):
def show(self, req, id):
def _reserve(self, req, image_meta):
def _upload(self, req, image_meta):
def _activate(self, req, image_id, location):
def _kill(self, req, image_id):
def _safe_kill(self, req, image_id):
def _upload_and_activate(self, req, image_meta):
def _validate_image_for_activation(self, req, id, values):
@utils.mutating DCNL def create(self, req, image_meta, image_data):
@utils.mutating DCNL def update(self, req, id, image_meta, image_data):
@utils.mutating DCNL def delete(self, req, id):
def get_store_or_400(self, request, scheme):
def _inject_image_meta_headers(self, response, image_meta):
def _get_image_location(self, image_meta):
def get_image_meta_or_404(self, request, image_id):
def get_active_image_meta_or_404(self, request, image_id):
def _enforce(self, req):
def get_cached_images(self, req):
def delete_cached_image(self, req, image_id):
def delete_cached_images(self, req):
def get_queued_images(self, req):
def queue_image(self, req, image_id):
def delete_queued_image(self, req, image_id):
def delete_queued_images(self, req):
def index(self, req):
def save(self, session=None):
def delete(self, session=None):
def update(self, values):
def __init__(self, context=None, location=None):
def configure(self):
def get_schemes(self):
def get_store_location_class(self):
def configure_add(self):
def get(self, location):
def get_size(self, location):
def add_disabled(self, *args, **kwargs):
def add(self, image_id, image_file, image_size):
def delete(self, location):
def set_acls(self, location, public=False, read_tenants=[], write_tenants=[]):
def parse_uri(self, uri):
def __iter__(self):
def getvalue(self):
def close(self):
def configure_add(self):
def get(self, location):
def get_size(self, location):
def add(self, image_id, image_file, image_size):
def delete(self, location):
def __init__(self, wrapped, size):
def __iter__(self):
def __getitem__(self, i):
def another(self):
def getvalue(self):
def __len__(self):
def configure_add(self):
def get(self, location):
def _create_image(self, fsid, ioctx, name, size, order):
def add(self, image_id, image_file, image_size):
def delete(self, location):
def parse_uri(self, uri):
@property DCNL def swift_url(self):
def _create_container_if_missing(self, container, connection):
def __init__(self, store_name, store_location_class, uri=None, image_id=None, store_specs=None):
def get_store_uri(self):
def process_specs(self):
def get_uri(self):
def parse_uri(self, uri):
def parse_uri(self, uri):
def __iter__(self):
def close(self):
def configure_add(self):
def get(self, location):
def get_size(self, location):
def delete(self, location):
def add(self, image_id, image_file, image_size):
def parse_uri(self, uri):
def get(self, location):
def get_size(self, location):
def _get_conn_class(self, loc):
def test_get_without_redirect(self):
def test_get_with_one_redirect(self):
def test_get_with_one_redirect_query_string(self):
def test_get_with_max_redirects(self):
def test_post_redirect(self):
def test_redirect_to_new_host(self):
def test_image_get_all_marker_deleted(self):
def test_image_get_all_marker_deleted_showing_deleted_as_admin(self):
def test_image_get_all_marker_deleted_showing_deleted(self):
def test_image_paginate(self):
def test_owner1_finding_user1_memberships(self):
def test_user1_finding_user1_memberships(self):
def test_user2_finding_user1_memberships(self):
def test_admin_finding_user1_memberships(self):
def test_owner1_finding_owner1s_image_members(self):
def test_admin_finding_owner1s_image_members(self):
def test_user1_finding_owner1s_image_members(self):
def test_user2_finding_owner1s_image_members(self):
def test_user3_finding_owner1s_image_members(self):
@skip_if_disabled DCNL def test_fallback_pidfile_uncreateable_dir(self):
@skip_if_disabled DCNL def test_fallback_pidfile_unwriteable_dir(self):
@skip_if_disabled DCNL def test_respawn(self):
@skip_if_disabled DCNL def test_bouncing(self):
@skip_if_disabled DCNL def test_reload(self):
@skip_if_disabled DCNL def test_infinite_child_death(self):
def test_verbose_debug(self):
def test_no_verbose_no_debug(self):
def test_logrotate(self):
def test_delayed_delete(self):
def test_scrubber_app(self):
def test_scrubber_app_against_swift(self):
def test_scrubber_with_metadata_enc(self):
def test_scrubber_handles_swift_missing(self):
def __init__(self, test_dir, port):
def write_conf(self, **kwargs):
def start(self, expect_exit=True, expected_exitcode=0, **kwargs):
def reload(self, expect_exit=True, expected_exitcode=0, **kwargs):
def create_database(self):
def stop(self):
def cleanup(self):
def start_server(self, server, expect_launch, expect_exit=True, expected_exitcode=0, **kwargs):
def start_with_retry(self, server, port_name, max_retries, expect_launch=True, expect_exit=True, expect_confirmation=True, **kwargs):
def start_servers(self, **kwargs):
def ping_server(self, port):
def wait_for_servers(self, servers, expect_launch=True, timeout=10):
def reload_server(self, server, expect_launch, expect_exit=True, expected_exitcode=0, **kwargs):
def stop_server(self, server, name):
def stop_servers(self):
def run_sql_cmd(self, sql):
@depends_on_exe('sqlite3') DCNL @skip_if_disabled DCNL def test_db_creation(self):
@depends_on_exe('sqlite3') DCNL @skip_if_disabled DCNL def test_db_creation_auto_create_overridden(self):
def stash_image(self, image_id, image_data):
def test_lifecycle(self):
def test_get_remote_image(self):
def test_object_chunking(self):
def test_multitenant(self):
@depends_on_exe('sqlite3') DCNL @skip_if_disabled DCNL def test_big_int_mapping(self):
def test_rate_limited(self):
def test_rate_limited_retry(self):
def test_service_unavailable(self):
def test_service_unavailable_retry(self):
def test_expectation_failed(self):
def test_server_error(self):
def add_image(self, name):
def is_image_cached(self, image_id):
def iso_date(self, image_id):
def test_no_cache_enabled(self):
def test_cache_index(self):
def test_queue(self):
@skip_if_disabled DCNL def test_cache_middleware_transparent_v1(self):
@skip_if_disabled DCNL def test_cache_middleware_transparent_v2(self):
@skip_if_disabled DCNL def test_cache_remote_image(self):
def add_image(self, name):
def verify_no_cached_images(self):
@skip_if_disabled DCNL def test_cache_manage_get_cached_images(self):
@skip_if_disabled DCNL def test_cache_manage_delete_cached_images(self):
@skip_if_disabled DCNL def test_queue_and_prefetch(self):
def setUp(self):
def setUp(self):
def setUp(self):
def setUp(self):
def test_api_response_when_image_deleted_from_filesystem(self):
def test_exception_not_eaten_from_registry_to_api(self):
def _do_test_copy_from(self, from_store, get_uri):
@requires(setup_swift, teardown_swift) DCNL @skip_if_disabled DCNL def test_copy_from_swift(self):
@requires(setup_s3, teardown_s3) DCNL @skip_if_disabled DCNL def test_copy_from_s3(self):
@skip_if_disabled DCNL def _do_test_copy_from_http(self, exists):
@skip_if_disabled DCNL def test_copy_from_file(self):
@skip_if_disabled DCNL def test_get_head_simple_post(self):
@skip_if_disabled DCNL def test_queued_process_flow(self):
@skip_if_disabled DCNL def test_size_greater_2G_mysql(self):
@skip_if_disabled DCNL def test_zero_initial_size(self):
@skip_if_disabled DCNL def test_traceback_not_consumed(self):
@skip_if_disabled DCNL def test_filtered_images(self):
@skip_if_disabled DCNL def test_limited_images(self):
@skip_if_disabled DCNL def test_ordered_images(self):
@skip_if_disabled DCNL def test_duplicate_image_upload(self):
@skip_if_disabled DCNL def test_delete_not_existing(self):
@skip_if_disabled DCNL def test_unsupported_default_store(self):
def _do_test_post_image_content_bad_format(self, format):
def _do_test_put_image_content_missing_format(self, format):
def _do_test_mismatched_attribute(self, attribute, value):
@skip_if_disabled DCNL def test_mismatched_size(self):
@skip_if_disabled DCNL def test_mismatched_checksum(self):
@skip_if_disabled DCNL def test_get_head_simple_post(self):
@skip_if_disabled DCNL def test_queued_process_flow(self):
@skip_if_disabled DCNL def test_version_variations(self):
@skip_if_disabled DCNL def test_size_greater_2G_mysql(self):
@skip_if_disabled DCNL def test_traceback_not_consumed(self):
@skip_if_disabled DCNL def test_filtered_images(self):
@skip_if_disabled DCNL def test_limited_images(self):
@skip_if_disabled DCNL def test_ordered_images(self):
@skip_if_disabled DCNL def test_duplicate_image_upload(self):
@skip_if_disabled DCNL def test_delete_not_existing(self):
def test_multiprocessing(self):
def test_interrupt_avoids_respawn_storm(self):
def test_version_configurations(self):
def test_version_variations(self):
def do_HEAD(self):
def do_GET(self):
def log_message(self, format, *args):
def config(self, **kw):
def do_visible(self, exp_res, img_owner, img_public, **kwargs):
def do_sharable(self, exp_res, img_owner, membership=None, **kwargs):
def test_empty_public(self):
def test_empty_public_owned(self):
def test_empty_private(self):
def test_empty_private_owned(self):
def test_empty_shared(self):
def test_anon_public(self):
def test_anon_public_owned(self):
def test_anon_private(self):
def test_anon_private_owned(self):
def test_anon_shared(self):
def test_auth_public(self):
def test_auth_public_unowned(self):
def test_auth_public_owned(self):
def test_auth_private(self):
def test_auth_private_unowned(self):
def test_auth_private_owned(self):
def test_auth_sharable(self):
def test_auth_sharable_admin(self):
def test_auth_sharable_owned(self):
def test_auth_sharable_cannot_share(self):
def test_auth_sharable_can_share(self):
def test_too_many_chunks(self):
def enforce(self, _ctxt, action, target=None, **kwargs):
def test_required_creds(self):
def test_invalid_auth_url_v1(self):
def test_invalid_auth_url_v2(self):
def test_v1_auth(self):
def test_v2_auth(self):
def test_empty_metadata_headers(self):
def test_get_location_from_uri_back_to_uri(self):
def test_bad_store_scheme(self):
def test_filesystem_store_location(self):
def test_http_store_location(self):
def test_swift_store_location(self):
def test_s3_store_location(self):
def test_rbd_store_location(self):
def test_get_store_from_scheme(self):
def test_policy_file_specified_but_not_found(self):
def test_policy_file_default_not_found(self):
def test_show_deleted_properties(self):
def test_delete_queued_updates_status(self):
def test_delete_queued_updates_status_delayed_delete(self):
def test_show_invalid_additional_property(self):
def setUp(self):
def tearDown(self):
def test_get_image_index(self):
def test_get_index_sort_name_asc(self):
def test_get_index_sort_status_desc(self):
def test_get_index_sort_disk_format_asc(self):
def test_get_index_sort_container_format_desc(self):
def test_get_index_sort_size_asc(self):
def test_get_index_sort_created_at_asc(self):
def test_get_index_sort_updated_at_desc(self):
def test_get_image_index_marker(self):
def test_get_image_index_invalid_marker(self):
def test_get_image_index_limit(self):
def test_get_image_index_marker_limit(self):
def test_get_image_index_limit_None(self):
def test_get_image_index_by_name(self):
def test_get_image_details(self):
def test_get_image_details_marker_limit(self):
def test_get_image_details_invalid_marker(self):
def test_get_image_details_by_name(self):
def test_get_image_details_by_status(self):
def test_get_image_details_by_container_format(self):
def test_get_image_details_by_disk_format(self):
def test_get_image_details_with_maximum_size(self):
def test_get_image_details_with_minimum_size(self):
def test_get_image_details_with_changes_since(self):
def test_get_image_details_with_changes_since(self):
def test_get_image_details_by_property(self):
def test_get_image_details_sort_disk_format_asc(self):
def test_get_image(self):
def test_get_image_non_existing(self):
def test_add_image_basic(self):
def test_add_image_with_properties(self):
def test_add_image_already_exists(self):
def test_add_image_with_bad_status(self):
def test_update_image(self):
def test_update_image_not_existing(self):
def test_delete_image(self):
def test_delete_image_not_existing(self):
def test_get_image_members(self):
def test_get_image_members_not_existing(self):
def test_get_member_images(self):
def test_add_replace_members(self):
def test_add_delete_member(self):
def setUp(self):
def test_get(self):
def test_get_calling_format_path(self):
def test_get_calling_format_default(self):
def test_get_non_existing(self):
def test_add(self):
def test_add_host_variations(self):
def test_add_already_existing(self):
def test_no_access_key(self):
def test_no_secret_key(self):
def test_no_host(self):
def test_delete(self):
def test_delete_non_existing(self):
def test_get_s3_good_location(self):
def test_get_s3_bad_location(self):
@skip_if_disabled DCNL def test_is_cached(self):
@skip_if_disabled DCNL def test_read(self):
@skip_if_disabled DCNL def test_open_for_read(self):
@skip_if_disabled DCNL def test_get_image_size(self):
@skip_if_disabled DCNL def test_delete(self):
@skip_if_disabled DCNL def test_delete_all(self):
@skip_if_disabled DCNL def test_clean_stalled(self):
@skip_if_disabled DCNL def test_prune(self):
@skip_if_disabled DCNL def test_prune_to_zero(self):
@skip_if_disabled DCNL def test_queue(self):
def test_open_for_write_good(self):
def test_open_for_write_with_exception(self):
def test_caching_iterator(self):
def test_caching_iterator_handles_backend_failure(self):
def test_caching_iterator_falloffend(self):
def setUp(self):
def setUp(self):
def test_headers_are_unicode(self):
def test_data_passed_properly_through_headers(self):
def test_time_is_monkey_patched(self):
def test_get_size(self):
def test_get_size_with_multi_tenant_on(self):
def test_get(self):
def test_get_with_http_auth(self):
def test_get_non_existing(self):
def test_add(self):
def test_add_auth_url_variations(self):
def test_add_no_container_no_create(self):
def test_add_no_container_and_create(self):
def test_add_large_object(self):
def test_add_large_object_zero_size(self):
def test_add_already_existing(self):
def test_no_user(self):
def test_no_key(self):
def test_no_auth_address(self):
def test_delete(self):
def test_delete_non_existing(self):
def test_read_acl_public(self):
def test_read_acl_tenants(self):
def test_read_write_public(self):
def setUp(self):
def test_read_all_data(self):
def test_v1_deleted_image_fetch(self):
def test_process_v1_request_for_deleted_but_cached_image(self):
def setUp(self):
def test_bad_sql_connection(self):
def setUp(self):
def tearDown(self):
def test_show(self):
def test_show_unknown(self):
def test_show_invalid(self):
def test_show_deleted_image_as_admin(self):
def test_show_deleted_image_as_nonadmin(self):
def test_get_root(self):
def test_get_index(self):
def test_get_index_marker(self):
def test_get_index_unknown_marker(self):
def test_get_index_malformed_marker(self):
def test_get_index_limit(self):
def test_get_index_limit_negative(self):
def test_get_index_limit_non_int(self):
def test_get_index_limit_marker(self):
def test_get_index_filter_name(self):
def test_get_index_sort_default_created_at_desc(self):
def test_get_index_bad_sort_key(self):
def test_get_index_bad_sort_dir(self):
def test_get_index_sort_name_asc(self):
def test_get_index_sort_status_desc(self):
def test_get_index_sort_disk_format_asc(self):
def test_get_index_sort_container_format_desc(self):
def test_get_index_sort_size_asc(self):
def test_get_index_sort_created_at_asc(self):
def test_get_index_sort_updated_at_desc(self):
def test_get_details(self):
def test_get_details_limit_marker(self):
def test_get_details_invalid_marker(self):
def test_get_details_filter_name(self):
def test_get_details_filter_status(self):
def test_get_details_filter_container_format(self):
def test_get_details_filter_min_disk(self):
def test_get_details_filter_min_ram(self):
def test_get_details_filter_disk_format(self):
def test_get_details_filter_size_min(self):
def test_get_details_filter_size_max(self):
def test_get_details_filter_size_min_max(self):
def test_get_details_filter_changes_since(self):
def test_get_details_filter_property(self):
def test_get_details_filter_public_none(self):
def test_get_details_filter_public_false(self):
def test_get_details_filter_public_true(self):
def test_get_details_sort_name_asc(self):
def test_create_image(self):
def test_create_image_with_min_disk(self):
def test_create_image_with_min_ram(self):
def test_create_image_with_min_ram_default(self):
def test_create_image_with_min_disk_default(self):
def test_create_image_with_bad_status(self):
def test_create_image_with_bad_id(self):
def test_update_image(self):
def test_update_image_not_existing(self):
def test_update_image_with_bad_status(self):
def test_delete_image(self):
def test_delete_image_response(self):
def test_delete_image_not_existing(self):
def test_get_image_members(self):
def test_get_image_members_not_existing(self):
def test_get_member_images(self):
def test_replace_members(self):
def test_add_member(self):
def test_delete_member(self):
def test_delete_member_invalid(self):
def setUp(self):
def tearDown(self):
def test_add_image_no_location_no_image_as_body(self):
def test_add_image_no_location_no_content_type(self):
def test_add_image_size_header_too_big(self):
def test_add_image_zero_size(self):
def test_add_image_bad_store(self):
def test_add_image_basic_file_store(self):
def _do_test_post_image_content_missing_format(self, missing):
def test_post_image_content_missing_disk_format(self):
def test_post_image_content_missing_container_type(self):
def _do_test_put_image_content_missing_format(self, missing):
def test_put_image_content_missing_disk_format(self):
def test_put_image_content_missing_container_type(self):
def test_update_deleted_image(self):
def test_delete_deleted_image(self):
def test_register_and_upload(self):
def test_disable_purge_props(self):
def test_publicize_image_unauthorized(self):
def test_update_image_size_header_too_big(self):
def test_get_index_sort_name_asc(self):
def test_get_details_filter_changes_since(self):
def test_store_location_not_revealed(self):
def test_image_is_checksummed(self):
def test_etag_equals_checksum_header(self):
def test_bad_checksum_prevents_image_creation(self):
def test_image_meta(self):
def test_delete_queued_image(self):
def test_delete_queued_image_delayed_delete(self):
def test_get_details_invalid_marker(self):
def test_get_image_members(self):
def test_get_image_members_not_existing(self):
def test_get_member_images(self):
def test_replace_members(self):
def test_add_member(self):
def test_delete_member(self):
def setUp(self):
def test_show_notify(self):
def test_image_send_notification_error(self):
def test_redact_location(self):
def test_noop_redact_location(self):
def test_cooperative_reader(self):
def test_cooperative_reader_of_iterator(self):
def test_limiting_reader(self):
def test_limiting_reader_fails(self):
def setUp(self):
def tearDown(self):
def test_get(self):
def test_get_non_existing(self):
def test_add(self):
def test_add_already_existing(self):
def test_add_storage_full(self):
def test_add_file_too_big(self):
def test_add_storage_write_denied(self):
def test_add_other_failure(self):
def test_add_cleanup_on_read_failure(self):
def test_delete(self):
def test_delete_non_existing(self):
def test_walk_versions(self):
def test_mysql_connect_fail(self):
def test_postgresql_connect_fail(self):
def _migrate_up(self, engine, version, with_data=False):
def test_version_control_existing_db(self):
def _prerun_004(self, engine):
def _check_004(self, engine, data):
def init_driver(self):
def configure_driver(self):
def is_cached(self, image_id):
def is_queued(self, image_id):
def get_cache_size(self):
def get_hit_count(self, image_id):
def get_cached_images(self):
def delete_all_cached_images(self):
def delete_cached_image(self, image_id):
def delete_all_queued_images(self):
def delete_queued_image(self, image_id):
def prune(self):
def clean(self, stall_time=None):
def queue_image(self, image_id):
def get_caching_iter(self, image_id, image_checksum, image_iter):
def cache_image_iter(self, image_id, image_iter):
def cache_image_file(self, image_id, image_file):
def open_for_read(self, image_id):
def get_image_size(self, image_id):
def get_queued_images(self):
def configure(self):
def get_cache_size(self):
def get_hit_count(self, image_id):
def get_cached_images(self):
def is_cached(self, image_id):
def is_cacheable(self, image_id):
def is_being_cached(self, image_id):
def is_queued(self, image_id):
def delete_all_cached_images(self):
def delete_cached_image(self, image_id):
def delete_all_queued_images(self):
def delete_queued_image(self, image_id):
def clean(self, stall_time=None):
def get_least_recently_accessed(self):
@contextmanager DCNL def open_for_write(self, image_id):
@contextmanager DCNL def open_for_read(self, image_id):
@contextmanager DCNL def get_db(self):
def queue_image(self, image_id):
def delete_invalid_files(self):
def delete_stalled_files(self, older_than):
def get_queued_images(self):
def get_cache_files(self, basepath):
def configure(self):
def set_paths(self):
def get_cache_size(self):
def get_cached_images(self):
def is_cached(self, image_id):
def is_cacheable(self, image_id):
def is_queued(self, image_id):
def delete_all_cached_images(self):
def delete_cached_image(self, image_id):
def delete_all_queued_images(self):
def delete_queued_image(self, image_id):
def clean(self, stall_time=None):
def get_least_recently_accessed(self):
def open_for_write(self, image_id):
def open_for_read(self, image_id):
def get_image_filepath(self, image_id, cache_status='active'):
def get_image_size(self, image_id):
def get_queued_images(self):
def configure(self):
def get_cache_size(self):
def get_hit_count(self, image_id):
def get_cached_images(self):
def is_cached(self, image_id):
def is_cacheable(self, image_id):
def is_being_cached(self, image_id):
def is_queued(self, image_id):
def delete_all_cached_images(self):
def delete_cached_image(self, image_id):
def delete_all_queued_images(self):
def delete_queued_image(self, image_id):
def get_least_recently_accessed(self):
@contextmanager DCNL def open_for_write(self, image_id):
@contextmanager DCNL def open_for_read(self, image_id):
def queue_image(self, image_id):
def get_queued_images(self):
def reap_invalid(self, grace=None):
def reap_stalled(self, grace=None):
def clean(self, stall_time=None):
def delete_cached_image(self, image_id):
def get_cached_images(self, **kwargs):
def get_queued_images(self, **kwargs):
def delete_all_cached_images(self):
def queue_image_for_caching(self, image_id):
def delete_queued_image(self, image_id):
def delete_all_queued_images(self):
def format(self, record):
def formatException(self, exc_info, record=None):
@classmethod DCNL def load_json(cls, data, default_rule=None):
def __init__(self, rules=None, default_rule=None):
def __missing__(self, key):
def __str__(self):
@abc.abstractmethod DCNL def __str__(self):
@abc.abstractmethod DCNL def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, kind, match):
def __str__(self):
def __init__(self, rule):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __new__(mcs, name, bases, cls_dict):
def __init__(self):
def reduce(self):
def shift(self, tok, value):
@property DCNL def result(self):
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2):
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2):
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check):
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2):
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check):
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __init__(self, package):
def __str__(self):
def __repr__(self):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def __init__(self):
def _close(self):
def _connect(self):
def reconnect(self):
def log_failure(self, msg, priority):
def _send_message(self, msg, routing_key):
def _notify(self, msg, priority):
def _get_session(self):
def index(self, req, image_id):
@utils.mutating DCNL def update_all(self, req, image_id, body):
@utils.mutating DCNL def update(self, req, image_id, id, body=None):
@utils.mutating DCNL def delete(self, req, image_id, id):
def index_shared_images(self, req, id):
def _get_images(self, context, filters, **params):
def index(self, req):
def detail(self, req):
def _get_query_params(self, req):
def _get_filters(self, req):
def _get_limit(self, req):
def _get_marker(self, req):
def _get_sort_key(self, req):
def _get_sort_dir(self, req):
def _get_is_public(self, req):
def _parse_deleted_filter(self, req):
def show(self, req, id):
@utils.mutating DCNL def delete(self, req, id):
@utils.mutating DCNL def create(self, req, body):
@utils.mutating DCNL def update(self, req, id, body):
def __init__(self, host=None, port=None, metadata_encryption_key=None, **kwargs):
def get_images(self, **kwargs):
def get_images_detailed(self, **kwargs):
def get_image(self, image_id):
def add_image(self, image_metadata):
def update_image(self, image_id, image_metadata, purge_props=False):
def delete_image(self, image_id):
def get_image_members(self, image_id):
def get_member_images(self, member_id):
def replace_members(self, image_id, member_data):
def add_member(self, image_id, member_id, can_share=None):
def delete_member(self, image_id, member_id):
@property DCNL def owner(self):
@property DCNL def show_deleted(self):
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True):
def create_virtualenv(self, no_site_packages=True):
def parse_args(self, argv):
def post_process(self):
def post_process(self):
def setUp(self):
def tearDown(self):
def flags(self, **kw):
def assertDictMatch(self, d1, d2, approx_equal=False, tolerance=0.001):
def assertDictListMatch(self, L1, L2, approx_equal=False, tolerance=0.001):
def assertSubDictMatch(self, sub_dict, super_dict):
def assertIn(self, a, b, *args, **kwargs):
def assertNotIn(self, a, b, *args, **kwargs):
def __init__(self, data, limit):
def __init__(self, ext_mgr):
def get_resources(self):
def get_controller_extensions(self):
@classmethod DCNL def nsmap(cls):
@classmethod DCNL def xmlname(cls, name):
def get_resources(self):
def get_controller_extensions(self):
def _check_extension(self, extension):
def load_extension(self, ext_factory):
def _load_extensions(self):
def _extract_volume(self, node):
def default(self, string):
@wsgi.serializers(xml=VolumeTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=VolumesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=VolumesTemplate) DCNL def detail(self, req):
def _get_volumes(self, req, is_detail):
@wsgi.response(202) DCNL @wsgi.serializers(xml=VolumeTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body):
def _get_volume_filter_options(self):
@wsgi.serializers(xml=VolumeTemplate) DCNL def update(self, req, id, body):
def __init__(self):
def summary_list(self, request, volumes):
def detail_list(self, request, volumes):
def summary(self, request, volume):
def detail(self, request, volume):
def _get_attachments(self, volume):
def _get_volume_metadata(self, volume):
def _get_volume_type(self, volume):
def _list_view(self, func, request, volumes):
@wsgi.serializers(xml=SnapshotTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def detail(self, req):
def _items(self, req, entity_maker):
@wsgi.response(202) DCNL @wsgi.serializers(xml=SnapshotTemplate) DCNL def create(self, req, body):
@wsgi.serializers(xml=SnapshotTemplate) DCNL def update(self, req, id, body):
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, snapshot_id):
@wsgi.serializers(xml=common.MetaItemTemplate) DCNL def show(self, req, snapshot_id, id):
def delete(self, req, snapshot_id, id):
@wsgi.serializers(xml=VolumeTypesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=VolumeTypeTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req):
def __init__(self, verb, uri, regex, value, unit):
def __call__(self, verb, url):
def _get_time(self):
def display_unit(self):
def display(self):
def __init__(self, application, limits=None, limiter=None, **kwargs):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req):
def __init__(self, limits, **kwargs):
def get_limits(self, username=None):
def check_for_delay(self, verb, url, username=None):
@staticmethod DCNL def parse_limits(limits):
def __init__(self, limits=None):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request):
def __init__(self, limiter_address):
@staticmethod DCNL def parse_limits(limits):
def _get_next_link(self, request, identifier):
def _get_href_link(self, request, identifier):
def _get_bookmark_link(self, request, identifier):
def _get_collection_links(self, request, items, id_key='uuid'):
def extract_metadata(self, metadata_node):
def __init__(self):
def summary_list(self, request, backups):
def detail_list(self, request, backups):
def summary(self, request, backup):
def restore_summary(self, request, restore):
def detail(self, request, backup):
def _list_view(self, func, request, backups):
def show(self, request, volume_type, brief=False):
def index(self, request, volume_types):
def _build_absolute_limits(self, absolute_limits):
def __init__(self, base_url):
def _build_links(self, version_data):
def generate_href(self, path=None):
def __init__(self, *chain):
def __repr__(self):
def __call__(self, obj, do_raise=False):
def __call__(self, obj, do_raise=False):
def __init__(self, value):
def __repr__(self):
def __call__(self, _obj, _do_raise=False):
def __init__(self, tag, attrib=None, selector=None, subselector=None, **extra):
def __repr__(self):
def __len__(self):
def __contains__(self, key):
def __getitem__(self, idx):
def append(self, elem):
def extend(self, elems):
def insert(self, idx, elem):
def remove(self, elem):
def get(self, key):
def set(self, key, value=None):
def keys(self):
def items(self):
def unwrap(self):
def wrap(self):
def apply(self, elem, obj):
def _render(self, parent, datum, patches, nsmap):
def render(self, parent, obj, patches=[], nsmap=None):
def will_render(self, datum):
def _text_get(self):
def tree(self):
def __init__(self, root, nsmap=None):
def _serialize(self, parent, obj, siblings, nsmap=None):
def serialize(self, obj, *args, **kwargs):
def make_tree(self, obj):
def _siblings(self):
def _nsmap(self):
def unwrap(self):
def wrap(self):
def apply(self, master):
def tree(self):
def __init__(self, root, version, nsmap=None):
def __repr__(self):
def _siblings(self):
def _nsmap(self):
def attach(self, *slaves):
def copy(self):
def __init__(self, root, min_vers, max_vers=None, nsmap=None):
def __repr__(self):
def apply(self, master):
def __new__(cls, copy=True):
def construct(self):
@classmethod DCNL def factory(cls, global_config, **local_config):
def best_match_content_type(self):
def get_content_type(self):
def dispatch(self, *args, **kwargs):
def __init__(self, metadata=None):
def _from_xml_node(self, node, listnames):
def find_first_child_named(self, parent, name):
def find_children_named(self, parent, name):
def extract_text(self, node):
def find_attribute_or_element(self, parent, name):
def extract_metadata(self, metadata_node):
def __init__(self, metadata=None, xmlns=None):
def _to_xml_node(self, doc, metadata, nodename, data):
def _to_xml(self, root):
def __init__(self, obj, code=None, **serializers):
def __getitem__(self, key):
def __setitem__(self, key, value):
def __delitem__(self, key):
def _bind_method_serializers(self, meth_serializers):
def get_serializer(self, content_type, default_serializers=None):
def preserialize(self, content_type, default_serializers=None):
def attach(self, **kwargs):
def serialize(self, request, content_type, default_serializers=None):
@property DCNL def code(self):
@property DCNL def headers(self):
def __init__(self, controller, action_peek=None, **deserializers):
def register_actions(self, controller):
def register_extensions(self, controller):
def get_action_args(self, request_environment):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
def _process_stack(self, request, action, action_args, content_type, body, accept):
def get_method(self, request, action, content_type, body):
def dispatch(self, method, request, action_args):
def __new__(mcs, name, bases, cls_dict):
def __init__(self, view_builder=None):
def __init__(self, exception):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
def __init__(self, message, details, retry_time):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, volume_id):
@wsgi.serializers(xml=common.MetaItemTemplate) DCNL def show(self, req, volume_id, id):
def delete(self, req, volume_id, id):
def _extract_volume(self, node):
def default(self, string):
@wsgi.serializers(xml=VolumeTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=VolumesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=VolumesTemplate) DCNL def detail(self, req):
def _items(self, req, entity_maker):
@wsgi.serializers(xml=VolumeTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body):
def _get_volume_search_options(self):
@wsgi.serializers(xml=VolumeTemplate) DCNL def update(self, req, id, body):
@wsgi.serializers(xml=SnapshotTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def detail(self, req):
def _items(self, req, entity_maker):
@wsgi.serializers(xml=SnapshotTemplate) DCNL def create(self, req, body):
@wsgi.serializers(xml=SnapshotTemplate) DCNL def update(self, req, id, body):
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, snapshot_id):
@wsgi.serializers(xml=common.MetaItemTemplate) DCNL def show(self, req, snapshot_id, id):
def delete(self, req, snapshot_id, id):
@wsgi.serializers(xml=VolumeTypesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=VolumeTypeTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req):
def __init__(self, verb, uri, regex, value, unit):
def __call__(self, verb, url):
def _get_time(self):
def display_unit(self):
def display(self):
def __init__(self, application, limits=None, limiter=None, **kwargs):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req):
def __init__(self, limits, **kwargs):
def get_limits(self, username=None):
def check_for_delay(self, verb, url, username=None):
@staticmethod DCNL def parse_limits(limits):
def __init__(self, limits=None):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request):
def __init__(self, limiter_address):
@staticmethod DCNL def parse_limits(limits):
def content_type_params(self, best_content_type):
def _match(self, host, port, path_info):
def _path_strategy(self, host, port, path_info):
def _content_type_strategy(self, host, port, environ):
def _accept_strategy(self, host, port, environ, supported_content_types):
def _set_enabled_status(self, req, host, enabled):
@wsgi.serializers(xml=HostShowTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=VolumeTypeExtraSpecsTemplate) DCNL def index(self, req, type_id):
@wsgi.serializers(xml=VolumeTypeExtraSpecTemplate) DCNL def show(self, req, type_id, id):
def delete(self, req, type_id, id):
def _format_quota_set(self, quota_class, quota_set):
@wsgi.serializers(xml=ServicesIndexTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=ServicesUpdateTemplate) DCNL def update(self, req, id, body):
def _format_quota_set(self, project_id, quota_set):
@wsgi.serializers(xml=BackupTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=BackupsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=BackupsTemplate) DCNL def detail(self, req):
def _get_backups(self, req, is_detail):
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body):
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupRestoreTemplate) DCNL @wsgi.deserializers(xml=RestoreDeserializer) DCNL def restore(self, req, id, body):
@wsgi.action('create') DCNL @wsgi.serializers(xml=types.VolumeTypeTemplate) DCNL def _create(self, req, body):
@wsgi.action('delete') DCNL def _delete(self, req, id):
@wsgi.action('os-reset_status') DCNL def _reset_status(self, req, id, body):
@wsgi.action('os-force_delete') DCNL def _force_delete(self, req, id, body):
@wsgi.action('os-force_detach') DCNL def _force_detach(self, req, id, body):
@wsgi.action('os-attach') DCNL def _attach(self, req, id, body):
@wsgi.action('os-detach') DCNL def _detach(self, req, id, body):
@wsgi.action('os-reserve') DCNL def _reserve(self, req, id, body):
@wsgi.action('os-unreserve') DCNL def _unreserve(self, req, id, body):
@wsgi.action('os-begin_detaching') DCNL def _begin_detaching(self, req, id, body):
@wsgi.action('os-roll_detaching') DCNL def _roll_detaching(self, req, id, body):
@wsgi.action('os-initialize_connection') DCNL def _initialize_connection(self, req, id, body):
@wsgi.action('os-terminate_connection') DCNL def _terminate_connection(self, req, id, body):
@wsgi.response(202) DCNL @wsgi.action('os-volume_upload_image') DCNL @wsgi.serializers(xml=VolumeToImageSerializer) DCNL @wsgi.deserializers(xml=VolumeToImageDeserializer) DCNL def _volume_upload_image(self, req, id, body):
@wsgi.serializers(xml=VersionsTemplate, atom=VersionsAtomSerializer) DCNL def index(self, req):
@wsgi.serializers(xml=ChoicesTemplate) DCNL @wsgi.response(300) DCNL def multi(self, req):
def get_action_args(self, request_environment):
def save(self, session=None):
def delete(self, session=None):
def update(self, values):
def iteritems(self):
def get(self):
def __init__(self, retvalue=True):
def rollback_and_reraise(self, msg=None, **kwargs):
def _fake_cliq_run(self, verb, cliq_args, check_exit_code=True):
def setUp(self):
def test_limiter_offset_zero(self):
def test_limiter_offset_medium(self):
def test_limiter_offset_over_max(self):
def test_limiter_offset_blank(self):
def test_limiter_offset_bad(self):
def test_limiter_nothing(self):
def test_limiter_limit_zero(self):
def test_limiter_limit_medium(self):
def test_limiter_limit_over_max(self):
def test_limiter_limit_and_offset(self):
def test_limiter_custom_max_limit(self):
def test_limiter_negative_limit(self):
def test_limiter_negative_offset(self):
def test_no_params(self):
def test_valid_marker(self):
def test_valid_limit(self):
def test_invalid_limit(self):
def test_valid_limit_and_marker(self):
def _prepare_xml(self, xml_string):
def test_400_fault_json(self):
def test_413_fault_json(self):
def test_raise(self):
def test_raise_403(self):
def test_fault_has_status_int(self):
def test_xml_serializer(self):
def _get_time(self):
def setUp(self):
def _get_index_request(self, accept_header='application/json'):
def _populate_limits(self, request):
def test_empty_index_json(self):
def test_index_json(self):
def _populate_limits_diff_regex(self, request):
def test_index_diff_regex(self):
@webob.dec.wsgify DCNL def _empty_app(self, request):
def setUp(self):
def test_limit_class(self):
def test_good_request(self):
def test_limited_request_json(self):
def test_limited_request_xml(self):
def test_GET_no_delay(self):
def test_GET_delay(self):
def test_invalid(self):
def test_bad_rule(self):
def test_missing_arg(self):
def test_bad_value(self):
def test_bad_unit(self):
def test_multiple_rules(self):
def setUp(self):
def _check(self, num, verb, url, username=None):
def _check_sum(self, num, verb, url, username=None):
def test_no_delay_GET(self):
def test_no_delay_PUT(self):
def test_delay_PUT(self):
def test_delay_POST(self):
def test_delay_GET(self):
def test_delay_PUT_volumes(self):
def test_delay_PUT_wait(self):
def test_multiple_delays(self):
def test_user_limit(self):
def test_multiple_users(self):
def setUp(self):
def _request_data(self, verb, path):
def _request(self, verb, url, username=None):
def test_invalid_methods(self):
def __init__(self, response_string):
def makefile(self, _mode, _other):
def __init__(self, app, host):
def request(self, method, path, body='', headers=None):
def getresponse(self):
def setUp(self):
def test_200(self):
def test_403(self):
def _get_time(self):
def setUp(self):
def _get_index_request(self, accept_header='application/json'):
def _populate_limits(self, request):
def test_empty_index_json(self):
def test_index_json(self):
def _populate_limits_diff_regex(self, request):
def test_index_diff_regex(self):
@webob.dec.wsgify DCNL def _empty_app(self, request):
def setUp(self):
def test_limit_class(self):
def test_good_request(self):
def test_limited_request_json(self):
def test_limited_request_xml(self):
def test_GET_no_delay(self):
def test_GET_delay(self):
def test_invalid(self):
def test_bad_rule(self):
def test_missing_arg(self):
def test_bad_value(self):
def test_bad_unit(self):
def test_multiple_rules(self):
def setUp(self):
def _check(self, num, verb, url, username=None):
def _check_sum(self, num, verb, url, username=None):
def test_no_delay_GET(self):
def test_no_delay_PUT(self):
def test_delay_PUT(self):
def test_delay_POST(self):
def test_delay_GET(self):
def test_delay_PUT_volumes(self):
def test_delay_PUT_wait(self):
def test_multiple_delays(self):
def test_user_limit(self):
def test_multiple_users(self):
def setUp(self):
def _request_data(self, verb, path):
def _request(self, verb, url, username=None):
def test_invalid_methods(self):
def __init__(self, response_string):
def makefile(self, _mode, _other):
def __init__(self, app, host):
def request(self, method, path, body='', headers=None):
def getresponse(self):
def setUp(self):
def test_200(self):
def test_403(self):
def test_attach_in_use_volume(self):
def test_attach_attaching_volume_with_different_instance(self):
def test_list_hosts(self):
def test_show_host_not_exist(self):
@staticmethod DCNL def _create_backup(volume_id=1, display_name='test_backup', display_description='this DCSP is DCSP a DCSP test DCSP backup', container='volumebackups', status='creating', size=0, object_count=0):
@staticmethod DCNL def _create_volume(display_name='test_volume', display_description='this DCSP is DCSP a DCSP test DCSP volume', status='creating', size=1):
def test_namespace_volumes(self):
def test_get_volumes_summary(self):
def test_get_volumes(self):
def _poll_while(self, volume_id, continue_states, max_retries=5):
def test_create_and_delete_volume(self):
def test_create_volume_with_metadata(self):
def test_create_volume_in_availability_zone(self):
def test_get_foxnsocks(self):
def test_login(self):
def _get_flags(self):
def __init__(self, xiv_info, logger, expt):
def setUp(self):
def test_initialized_should_set_xiv_info(self):
def test_setup_should_fail_if_credentials_are_invalid(self):
def test_setup_should_fail_if_connection_is_invalid(self):
def test_create_volume(self):
def test_volume_exists(self):
def test_delete_volume(self):
def test_delete_volume_should_fail_for_not_existing_volume(self):
def test_create_volume_should_fail_if_no_pool_space_left(self):
def test_initialize_connection(self):
def test_initialize_connection_should_fail_for_non_existing_volume(self):
def test_terminate_connection(self):
def test_terminate_connection_should_fail_on_non_existing_volume(self):
def test_terminate_connection_should_fail_on_non_attached_volume(self):
def test_get_test_admin_context(self):
def _create_backup_db_entry(self, volume_id=1, display_name='test_backup', display_description='this DCSP is DCSP a DCSP test DCSP backup', container='volumebackups', status='creating', size=0, object_count=0, project_id='fake'):
def _create_volume_db_entry(self, display_name='test_volume', display_description='this DCSP is DCSP a DCSP test DCSP volume', status='backing-up', size=1):
def test_init_host(self):
def test_create_backup_with_bad_volume_status(self):
def test_create_backup_with_bad_backup_status(self):
def test_create_backup_with_error(self):
def test_create_backup(self):
def test_restore_backup_with_bad_volume_status(self):
def test_restore_backup_with_bad_backup_status(self):
def test_restore_backup_with_driver_error(self):
def test_restore_backup_with_bad_service(self):
def test_restore_backup(self):
def test_delete_backup_with_bad_backup_status(self):
def test_delete_backup_with_error(self):
def test_delete_backup_with_bad_service(self):
def test_delete_backup(self):
def test_backup_get_all_by_project_with_deleted(self):
def test_backup_get_all_by_host_with_deleted(self):
def test_create_destroy(self):
def test_create_destroy_multiple(self):
def test_destroy_non_existent(self):
def test_empty_apis(self):
def test_volume_attach_detach(self):
def test_volume_attach_multiple_detach(self):
def test_wrong_attach_params(self):
def test_wrong_detach_params(self):
def test_wrong_login_reply(self):
def test_ssl_use(self):
def test_bad_http_response(self):
def test_delete_without_detach(self):
@staticmethod DCNL def _create_volume(size=0, snapshot_id=None, image_id=None, metadata=None):
def test_create_delete_volume(self):
def test_create_delete_volume_with_metadata(self):
def test_create_volume_with_invalid_metadata(self):
def test_create_volume_with_volume_type(self):
def test_delete_busy_volume(self):
def test_create_volume_from_snapshot(self):
def test_too_big_volume(self):
def test_run_attach_detach_volume(self):
@test.skip_test DCNL def test_preattach_status_volume(self):
def test_concurrent_volumes_get_different_targets(self):
@staticmethod DCNL def _create_snapshot(volume_id, size='0'):
def test_create_delete_snapshot(self):
def test_cant_delete_volume_in_use(self):
def test_force_delete_volume(self):
def test_cant_delete_volume_with_snapshots(self):
def test_can_delete_errored_snapshot(self):
def test_create_snapshot_force(self):
def test_delete_busy_snapshot(self):
def _create_volume_from_image(self, expected_status, fakeout_copy_image_to_volume=False):
def test_create_volume_from_image_status_available(self):
def test_create_volume_from_image_exception(self):
def test_create_volume_from_exact_sized_image(self):
def test_create_volume_from_oversized_image(self):
def test_create_volume_int_size(self):
def test_create_volume_string_size(self):
def test_create_volume_usage_notification(self):
def test_begin_roll_detaching_volume(self):
def _attach_volume(self):
def _detach_volume(self, volume_id_list):
def test_delete_busy_volume(self):
def _attach_volume(self):
def __init__(self, status):
def test_create_snapshot(self):
def test_create_volume_from_snapshot(self):
def test_create_snapshot(self):
def test_create_volume_from_snapshot(self):
def _print_info_cmd(self, rows, delim=' DCSP ', nohdr=False, **kwargs):
def _print_info_obj_cmd(self, header, row, delim=' DCSP ', nohdr=False):
def test_setup_no_config(self):
def test_setup_missing_config(self):
def test_setup_no_mount_helper(self):
def test_setup_make_voldir(self):
def test_local_path(self):
def test_create_volume(self):
def test_delete_volume(self):
def test_create_snapshot(self):
def test_delete_snapshot(self):
def test_initialize_connection(self):
def _create_volume(self, params={}):
def test_notify_usage_exists(self):
def check_for_setup_error(self):
@staticmethod DCNL def fake_execute(cmd, *_args, **_kwargs):
@staticmethod DCNL def log_action(action, parameters):
def test_volume_type_create_then_destroy(self):
def test_get_all_volume_types(self):
def test_get_default_volume_type(self):
def test_default_volume_type_missing_in_db(self):
def test_non_existent_vol_type_shouldnt_delete(self):
def test_repeated_vol_types_shouldnt_raise(self):
def test_invalid_volume_types_params(self):
def test_volume_type_get_by_id_and_name(self):
def test_volume_type_search_by_extra_spec(self):
def test_volume_type_search_by_extra_spec_multiple(self):
def test_create_with_instance_id(self):
def test_create_without_instance_id(self):
def test_glance_version_by_flag(self):
def test_glance_version_by_arg(self):
def detail(self, context, **kwargs):
def show(self, context, image_id):
def create(self, context, metadata, data=None):
def update(self, context, image_id, metadata, data=None, purge_props=False):
def delete(self, context, image_id):
def test_path_exists_should_return_true(self):
def test_path_exists_should_return_false(self):
def test_local_path(self):
def test_mount_glusterfs_should_mount_correctly(self):
def test_mount_glusterfs_should_suppress_already_mounted_error(self):
def test_mount_glusterfs_should_reraise_already_mounted_error(self):
def test_mount_glusterfs_should_create_mountpoint_if_not_yet(self):
def test_mount_glusterfs_should_not_create_mountpoint_if_already(self):
def test_get_hash_str(self):
def test_get_mount_point_for_share(self):
def test_get_available_capacity_with_df(self):
def test_get_available_capacity_with_du(self):
def test_ensure_share_mounted(self):
def test_ensure_shares_mounted_should_save_mounting_successfully(self):
def test_ensure_shares_mounted_should_not_save_mounting_with_error(self):
def test_setup_should_throw_error_if_shares_config_not_configured(self):
def test_setup_should_throw_exception_if_client_is_not_installed(self):
def test_find_share_should_throw_error_if_there_is_no_mounted_shares(self):
def test_find_share(self):
def test_find_share_should_throw_error_if_there_is_no_enough_place(self):
def test_create_volume_should_ensure_glusterfs_mounted(self):
def test_create_volume_should_return_provider_location(self):
def test_delete_volume(self):
def test_delete_should_ensure_share_mounted(self):
def test_delete_should_not_delete_if_provider_location_not_provided(self):
def test_delete_should_not_delete_if_there_is_no_file(self):
@test.skip_if((not test_utils.is_cinder_installed()), 'Test DCSP requires DCSP Cinder DCSP installed DCSP (try DCSP setup.py DCSP develop') DCNL def test_create_volume_no_hosts(self):
@test.skip_if((not test_utils.is_cinder_installed()), 'Test DCSP requires DCSP Cinder DCSP installed DCSP (try DCSP setup.py DCSP develop') DCNL def test_create_volume_non_admin(self):
@test.skip_if((not test_utils.is_cinder_installed()), 'Test DCSP requires DCSP Cinder DCSP installed DCSP (try DCSP setup.py DCSP develop') DCNL def test_schedule_happy_day(self):
def test_create_volume_exception_puts_volume_in_error_state(self):
def _clone_volume_from_image(self, expected_status, clone_works=True):
def test_clone_image_status_available(self):
def test_clone_image_status_error(self):
def _create_volume(self, size=10):
def test_path_exists_should_return_true(self):
def test_path_exists_should_return_false(self):
def test_get_hash_str(self):
def test_path_exists_should_return_true(self):
def test_path_exists_should_return_false(self):
def test_local_path(self):
def test_mount_nfs_should_mount_correctly(self):
def test_mount_nfs_should_suppress_already_mounted_error(self):
def test_mount_nfs_should_reraise_already_mounted_error(self):
def test_mount_nfs_should_create_mountpoint_if_not_yet(self):
def test_mount_nfs_should_not_create_mountpoint_if_already(self):
def test_get_hash_str(self):
def test_get_mount_point_for_share(self):
def test_get_available_capacity_with_df(self):
def test_get_available_capacity_with_du(self):
def test_ensure_share_mounted(self):
def test_ensure_shares_mounted_should_save_mounting_successfully(self):
def test_ensure_shares_mounted_should_not_save_mounting_with_error(self):
def test_setup_should_throw_error_if_shares_config_not_configured(self):
def test_setup_should_throw_exception_if_nfs_client_is_not_installed(self):
def test_find_share_should_throw_error_if_there_is_no_mounted_shares(self):
def test_find_share(self):
def test_find_share_should_throw_error_if_there_is_no_enough_place(self):
def test_create_volume_should_ensure_nfs_mounted(self):
def test_create_volume_should_return_provider_location(self):
def test_delete_volume(self):
def test_delete_should_ensure_share_mounted(self):
def test_delete_should_not_delete_if_provider_location_not_provided(self):
def test_delete_should_not_delete_if_there_is_no_file(self):
def test_get_volume_stats(self):
def makefile(self, _mode, _other):
def close(self):
def test_walk_versions(self):
def test_mysql_connect_fail(self):
@test.skip_unless(_have_mysql(), 'mysql DCSP not DCSP available') DCNL def test_mysql_innodb(self):
def test_postgresql_connect_fail(self):
def _migrate_up(self, engine, version, with_data=False):
def test_migration_005(self):
def test_migration_008(self):
def test_migration_009(self):
def find_vhd_by_name(self, name):
def volume_exists(self, name):
def snapshot_exists(self, name):
def find_snapshot_by_name(self, name):
def delete_volume(self, name):
def _get_vhd_path(self, volume_name):
def delete_snapshot(self, name):
def find_initiator_ids(self, target_name, initiator_name):
def initiator_id_exists(self, target_name, initiator_name):
def find_exports(self, target_name):
def export_exists(self, target_name):
def delete_initiator_id(self, target_name, initiator_name):
def delete_export(self, target_name):
def do_GET(s):
def do_POST(s):
def makefile(self, mode, _other):
def do_GET(s):
def do_POST(s):
def do_GET(s):
def do_POST(s):
@staticmethod DCNL def _get_child_content(self, name):
def do_GET(s):
def do_POST(s):
def init_host(self):
def create_backup(self, context, backup_id):
def restore_backup(self, context, backup_id, volume_id):
def delete_backup(self, context, backup_id):
def delete(self, context, backup_id):
def create(self, context, name, description, volume_id, container, availability_zone=None):
def restore(self, context, backup_id, volume_id=None):
def backup(self, backup, volume_file):
def _restore_v1(self, backup, volume_id, metadata, volume_file):
def restore(self, backup, volume_id, volume_file):
def delete(self, backup):
def __init__(self):
@staticmethod DCNL def run_server(server):
def launch_server(self, server):
def stop(self):
def wait(self):
def wait(self):
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_interval=None, periodic_fuzzy_delay=None, service_name=None):
def kill(self):
def periodic_tasks(self, raise_on_error=False):
def report_state(self):
def __init__(self, name, loader=None):
def _get_manager(self):
def start(self):
def stop(self):
def wait(self):
def format(self, record):
def formatException(self, exc_info, record=None):
def __init__(self, topic, default_version):
def _set_version(self, msg, vers):
def _get_topic(self, topic):
def call(self, context, msg, topic=None, version=None, timeout=None):
def multicall(self, context, msg, topic=None, version=None, timeout=None):
def cast(self, context, msg, topic=None, version=None):
def fanout_cast(self, context, msg, topic=None, version=None):
def cast_to_server(self, context, server_params, msg, topic=None, version=None):
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None):
def __init__(self, conf, connection_pool, pooled=True, server_params=None):
def __enter__(self):
def _done(self):
def __exit__(self, exc_type, exc_value, tb):
def __del__(self):
def close(self):
def __getattr__(self, key):
def check_duplicate_message(self, message_data):
def wait(self):
def __init__(self, conf, callback, connection_pool):
def __call__(self, message_data):
def _process_data(self, ctxt, version, method, args):
def __iter__(self):
def __call__(self, data):
def __iter__(self):
def __init__(self, callbacks):
def dispatch(self, ctxt, version, method, **kwargs):
def register(self, key, host):
def ack_alive(self, key, host):
def is_alive(self, topic, host):
def expire(self, topic, host):
def send_heartbeats(self):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def send_heartbeats(self):
def ack_alive(self, key, host):
def backend_register(self, key, host):
def backend_unregister(self, key, key_host):
def register(self, key, host):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts):
def reconnect(self, session):
def consume(self):
def __init__(self, conf, session, msg_id, callback):
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None):
def __init__(self, conf, session, topic, callback):
def __init__(self, session, node_name, node_opts=None):
def reconnect(self, session):
def send(self, msg):
def __init__(self, conf, session, msg_id):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def reconnect(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
def socket_s(self):
def subscribe(self, msg_filter):
def unsubscribe(self, msg_filter):
def _get_response(self, ctx, proxy, topic, data):
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None):
def consume_in_thread(self):
def close(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name):
def consume_in_thread(self):
def elevated(self, read_deleted=None, overwrite=False):
def __init__(self, channel, callback, tag, **kwargs):
def reconnect(self, channel):
def consume(self, *args, **kwargs):
def cancel(self):
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, **kwargs):
def __init__(self, channel, exchange_name, routing_key, **kwargs):
def reconnect(self, channel):
def send(self, msg, timeout=None):
def __init__(self, conf, channel, msg_id, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def _fetch_ssl_params(self):
def _connect(self, params):
def reconnect(self):
def get_channel(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
@classmethod DCNL def load_json(cls, data, default_rule=None):
def check(self, match_list, target_dict, cred_dict):
def __init__(self, package):
def __str__(self):
def __repr__(self):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def _weight_multiplier(self):
def _weigh_object(self, obj, weight_properties):
def weigh_objects(self, weighed_obj_list, weight_properties):
def _is_correct_class(self, obj):
def get_weighed_objects(self, weigher_classes, obj_list, weighing_properties):
def _filter_one(self, obj, filter_properties):
def host_passes(self, host_state, filter_properties):
def _satisfies_extra_specs(self, capabilities, resource_type):
def host_passes(self, host_state, filter_properties):
def _op_compare(self, args, op):
def _equals(self, args):
def _less_than(self, args):
def _greater_than(self, args):
def _in(self, args):
def _less_than_equal(self, args):
def _greater_than_equal(self, args):
def _not(self, args):
def _or(self, args):
def _and(self, args):
def _parse_string(self, string, host_state):
def _process_filter(self, query, host_state):
def host_passes(self, host_state, filter_properties):
def _filter_one(self, obj, filter_properties):
def filter_all(self, filter_obj_list, filter_properties):
def _is_correct_class(self, obj):
def get_exec(self, exec_dirs=[]):
def match(self, userargs):
def get_command(self, userargs, exec_dirs=[]):
def get_environment(self, userargs):
def __init__(cls, names, bases, dict_):
def create_rpc_dispatcher(self):
def periodic_tasks(self, context, raise_on_error=False):
def init_host(self):
def update_service_capabilities(self, capabilities):
@periodic_task DCNL def _publish_service_capabilities(self, context):
def _create_static_client(self, context, host, port, use_ssl, version):
def _create_onetime_client(self, context, version):
def call(self, context, method, *args, **kwargs):
def detail(self, context, **kwargs):
def show(self, context, image_id):
def get_location(self, context, image_id):
def download(self, context, image_id, data):
def create(self, context, image_meta, data=None):
def update(self, context, image_id, image_meta, data=None, purge_props=True):
def delete(self, context, image_id):
@staticmethod DCNL def _is_image_available(context, image):
def get_by_project(self, context, project_id, resource):
def get_by_class(self, context, quota_class, resource):
def get_defaults(self, context, resources):
def get_class_quotas(self, context, resources, quota_class, defaults=True):
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True):
def _get_quotas(self, context, resources, keys, has_sync, project_id=None):
def limit_check(self, context, resources, values, project_id=None):
def reserve(self, context, resources, deltas, expire=None, project_id=None):
def commit(self, context, reservations, project_id=None):
def rollback(self, context, reservations, project_id=None):
def destroy_all_by_project(self, context, project_id):
def expire(self, context):
def __init__(self, name, flag=None):
def quota(self, driver, context, **kwargs):
@property DCNL def default(self):
def __init__(self, name, sync, flag=None):
def __init__(self, name, count, flag=None):
def __init__(self, quota_driver_class=None):
def register_resource(self, resource):
def register_resources(self, resources):
def get_by_project(self, context, project_id, resource):
def get_by_class(self, context, quota_class, resource):
def get_defaults(self, context):
def get_class_quotas(self, context, quota_class, defaults=True):
def get_project_quotas(self, context, project_id, quota_class=None, defaults=True, usages=True):
def count(self, context, resource, *args, **kwargs):
def limit_check(self, context, project_id=None, **values):
def reserve(self, context, expire=None, project_id=None, **deltas):
def commit(self, context, reservations, project_id=None):
def rollback(self, context, reservations, project_id=None):
def destroy_all_by_project(self, context, project_id):
def expire(self, context):
def __init__(self, name, app, host=None, port=None, pool_size=None, protocol=eventlet.wsgi.HttpProtocol):
def _start(self):
def start(self, backlog=128):
def stop(self):
def wait(self):
@classmethod DCNL def factory(cls, global_config, **local_config):
def __call__(self, environ, start_response):
@classmethod DCNL def factory(cls, global_config, **local_config):
def process_request(self, req):
def process_response(self, response):
@staticmethod DCNL def print_generator(app_iter):
def __init__(self, mapper):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req):
def __init__(self, config_path=None):
def load_app(self, name):
def _filter_hosts(self, request_spec, hosts, **kwargs):
def _schedule(self, context, topic, request_spec, **kwargs):
def schedule_create_volume(self, context, request_spec, filter_properties):
def get_host_list(self):
def get_service_capabilities(self):
def update_service_capabilities(self, service_name, host, capabilities):
def hosts_up(self, context, topic):
def schedule(self, context, topic, method, *_args, **_kwargs):
def schedule_create_volume(self, context, request_spec, filter_properties):
def update_from_volume_capability(self, capability):
def consume_from_volume(self, volume):
def _choose_host_filters(self, filter_cls_names):
def _choose_host_weighers(self, weight_cls_names):
def get_filtered_hosts(self, hosts, filter_properties, filter_class_names=None):
def get_weighed_hosts(self, hosts, weight_properties, weigher_class_names=None):
def update_service_capabilities(self, service_name, host, capabilities):
def get_all_host_states(self, context):
def get_host_list(self, context):
def get_service_capabilities(self, context):
def update_service_capabilities(self, context, service_name=None, host=None, capabilities=None, **kwargs):
def schedule(self, context, topic, method, *args, **kwargs):
def _get_configuration_options(self):
def populate_filter_properties(self, request_spec, filter_properties):
def _post_select_populate_filter_properties(self, filter_properties, host_state):
def _add_retry_host(self, filter_properties, host):
def _log_volume_error(self, volume_id, retry):
def _populate_retry(self, filter_properties, properties):
def _schedule(self, context, request_spec, filter_properties=None):
def _get_file_handle(self, filename):
def _get_file_timestamp(self, filename):
def _load_file(self, handle):
def _get_time_now(self):
def get_configuration(self, filename=None):
def _weight_multiplier(self):
def _weigh_object(self, host_state, weight_properties):
def host_passes(self, host_state, filter_properties):
def host_passes(self, host_state, filter_properties):
def schedule_create_volume(self, context, request_spec, filter_properties):
def __init__(self, user_id, project_id, is_admin=None, read_deleted='no', roles=None, remote_address=None, timestamp=None, request_id=None, auth_token=None, overwrite=True, quota_class=None, **kwargs):
def elevated(self, read_deleted=None, overwrite=False):
def create_volume(self, volume):
def create_volume_from_snapshot(self, volume, snapshot):
def create_cloned_volume(self, volume, src_vref):
def delete_volume(self, volume):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, force=False, **kwargs):
def attach_volume(self, context, volume_id, instance_uuid, mountpoint):
def detach_volume(self, context, volume_id):
def get_volume_stats(self, refresh=False):
def do_setup(self, context):
def copy_image_to_volume(self, context, volume, image_service, image_id):
def copy_volume_to_image(self, context, volume, image_service, image_meta):
def clone_image(self, volume, image_location):
def backup_volume(self, context, backup, backup_service):
def restore_backup(self, context, backup, volume, backup_service):
def _get_iscsi_properties(self, volume):
def initialize_connection(self, volume, connector):
def _get_iscsi_initiator(self):
def copy_image_to_volume(self, context, volume, image_service, image_id):
def copy_volume_to_image(self, context, volume, image_service, image_meta):
def _attach_volume(self, context, volume, connector):
def get_volume_stats(self, refresh=False):
def _update_volume_status(self):
def check_for_setup_error(self):
@staticmethod DCNL def fake_execute(cmd, *_args, **_kwargs):
def initialize_connection(self, volume, connector):
def set_execute(self, execute):
def create_iscsi_target(self, name, tid, lun, path, chap_auth=None, **kwargs):
def remove_iscsi_target(self, tid, lun, vol_id, **kwargs):
def _new_target(self, name, tid, **kwargs):
def _delete_target(self, tid, **kwargs):
def show_target(self, tid, iqn=None, **kwargs):
def _new_logicalunit(self, tid, lun, path, **kwargs):
def _delete_logicalunit(self, tid, lun, **kwargs):
def check_for_setup_error(self):
def _delete_volume(self, volume, size_in_g):
def create_volume(self, volume):
def create_volume_from_snapshot(self, volume, snapshot):
def delete_volume(self, volume):
def clear_volume(self, volume):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def copy_image_to_volume(self, context, volume, image_service, image_id):
def copy_volume_to_image(self, context, volume, image_service, image_meta):
def create_cloned_volume(self, volume, src_vref):
def backup_volume(self, context, backup, backup_service):
def restore_backup(self, context, backup, volume, backup_service):
def ensure_export(self, context, volume):
def _fix_id_migration(self, context, volume):
def _ensure_iscsi_targets(self, context, host):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def get_volume_stats(self, refresh=False):
def _update_volume_status(self):
def check_for_setup_error(self):
def create_volume(self, volume):
def delete_volume(self, volume):
def create_cloned_volume(self, volume, src_vref):
def create_snapshot(self, snapshot):
def get_volume_stats(self, refresh=False):
def _update_volume_status(self):
def create_volume(self, volume):
def create_volume_from_snapshot(self, volume, snapshot):
def create_cloned_volume(self, volume, src_vref):
def delete_volume(self, volume):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def check_for_export(self, context, volume_id):
def initialize_connection(self, volume, connector):
def _get_iscsi_properties(self, volume):
def terminate_connection(self, volume, connector, **kwargs):
def get_volume_stats(self, refresh=False):
def update_volume_status(self):
def create_volume(self, volume):
def create_volume_from_snapshot(self, volume, snapshot):
def create_cloned_volume(self, volume, src_vref):
def delete_volume(self, volume):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def create_export(self, context, volume):
def _expose_paths(self, configservice, vol_instance, connector):
def _hide_paths(self, configservice, vol_instance, connector):
def _add_members(self, configservice, vol_instance):
def _remove_members(self, configservice, vol_instance):
def _map_lun(self, volume, connector):
def _unmap_lun(self, volume, connector):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector):
def update_volume_status(self):
def _get_storage_type(self, filename=None):
def _find_device_masking_group(self):
def connect(self):
def close(self):
def read(self, timeout=None):
def send_cmd(self, strcmd, timeout, waitstr=None):
def do_setup(self, context):
def check_for_setup_error(self):
def create_volume(self, volume):
def delete_volume(self, volume):
def create_export(self, context, volume):
def ensure_export(self, context, volume):
def remove_export(self, context, volume_id):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def create_volume_from_snapshot(self, volume, snapshot):
def get_volume_stats(self, refresh=False):
def _check_conf_file(self):
def _read_xml(self):
def _get_login_info(self):
def _get_lun_set_info(self):
def _find_pool_info(self, pooltype):
def _get_maximum_pool(self, poolinconf, poolindev, luntype):
def _get_iscsi_info(self):
def _execute_cli(self, cmd):
def _name_translate(self, name):
def _find_lun(self, name):
def _create_hostgroup(self, hostgroupname):
def _find_hostgroup(self, groupname):
def _add_host(self, hostname, hostgroupid):
def _check_initiator(self, ininame):
def _add_initiator(self, ininame):
def _delete_initiator(self, ininame):
def _find_host_in_hostgroup(self, hostname, hostgroupid):
def _get_hostport_info(self, hostid):
def _add_hostport(self, portname, hostid, portinfo, multipathtype=0):
def _delete_hostport(self, portid):
def _get_tgt_iqn(self, iscsiip):
def _get_iscsi_ip_info(self, iscsiip):
def _map_lun(self, lunid, hostid, new_hostlun_id):
def _get_hostlunid(self, hostid, lunid):
def _delete_map(self, mapid, attempts=1):
def _delete_host(self, hostid):
def _get_map_info(self, hostid):
def _get_device_type(self):
def _active_snapshot(self, snapshotid):
def _disable_snapshot(self, snapshotid):
def _delete_snapshot(self, snapshotid):
def _create_volume(self, name, size):
def _delete_volume(self, name, lunid):
def _create_luncopy(self, luncopyname, srclunid, tgtlunid):
def _start_luncopy(self, luncopyid):
def _find_luncopy(self, luncopyname):
def _wait_for_luncopy(self, luncopyname):
def _get_luncopy_info(self, luncopyname):
def _delete_luncopy(self, luncopyid):
def _create_snapshot(self, snapshotname, srclunid):
def _find_snapshot(self, snapshotname):
def _is_resource_pool_enough(self):
def _update_volume_status(self):
def _get_free_capacity(self):
def _check_prerequisites(self):
def do_setup(self, context):
def check_for_setup_error(self):
def create_volume(self, volume):
def create_volume_from_snapshot(self, volume, snapshot):
def delete_volume(self, volume):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, force=False, **kwargs):
def attach_volume(self, context, volume_id, instance_uuid, mountpoint):
def detach_volume(self, context, volume_id):
def get_volume_stats(self, refresh=False):
def copy_image_to_volume(self, context, volume, image_service, image_id):
def copy_volume_to_image(self, context, volume, image_service, image_meta):
def clone_image(self, volume, image_location):
def __init__(self, *args, **kwargs):
def do_setup(self, context):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def create_volume(self, volume):
def delete_volume(self, volume):
def remove_export(self, context, volume):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def create_volume_from_snapshot(self, volume, snapshot):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def get_volume_stats(self, refresh=False):
def do_setup(self, context):
def check_for_setup_error(self):
def create_volume(self, volume):
def delete_volume(self, volume):
def ensure_export(self, ctx, volume):
def create_export(self, ctx, volume):
def remove_export(self, ctx, volume):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def _do_create_volume(self, volume):
def _ensure_shares_mounted(self):
def _ensure_share_mounted(self, glusterfs_share):
def _find_share(self, volume_size_for):
def _get_mount_point_for_share(self, glusterfs_share):
def _get_available_capacity(self, glusterfs_share):
def _mount_glusterfs(self, glusterfs_share, mount_path, ensure=False):
def get_volume_stats(self, refresh=False):
def _update_volume_stats(self):
def _check_fail(self, request, response):
def _create_client(self, **kwargs):
def _set_storage_service(self, storage_service):
def _set_storage_service_prefix(self, storage_service_prefix):
def _set_vfiler(self, vfiler):
def _check_flags(self):
def do_setup(self, context):
def check_for_setup_error(self):
def _get_datasets(self):
def _discover_dataset_luns(self, dataset, volume):
def _discover_luns(self):
def _get_job_progress(self, job_id):
def _wait_for_job(self, job_id):
def _dataset_name(self, project, ss_type):
def _get_dataset(self, dataset_name):
def _create_dataset(self, dataset_name, project, ss_type):
@lockutils.synchronized('netapp_dfm', 'cinder-', True) DCNL def _provision(self, name, description, project, ss_type, size):
def _get_ss_type(self, volume):
@lockutils.synchronized('netapp_dfm', 'cinder-', True) DCNL def _remove_destroy(self, name, project):
def create_volume(self, volume):
def _lookup_lun_for_volume(self, name, project):
def delete_volume(self, volume):
def _get_lun_details(self, lun_id):
def _get_host_details(self, host_id):
def _get_iqn_for_host(self, host_id):
def _api_elem_is_empty(self, elem):
def _get_target_portal_for_host(self, host_id, host_address):
def _get_export(self, volume):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def _find_igroup_for_initiator(self, host_id, initiator_name):
def _create_igroup(self, host_id, initiator_name):
def _get_lun_mappping(self, host_id, lunpath, igroup_name):
def _map_initiator(self, host_id, lunpath, igroup_name):
def _unmap_initiator(self, host_id, lunpath, igroup_name):
def _ensure_initiator_mapped(self, host_id, lunpath, initiator_name):
def _ensure_initiator_unmapped(self, host_id, lunpath, initiator_name):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def _is_clone_done(self, host_id, clone_op_id, volume_uuid):
def _clone_lun(self, host_id, src_path, dest_path, snap):
def _refresh_dfm_luns(self, host_id):
def _destroy_lun(self, host_id, lun_path):
def _resize_volume(self, host_id, vol_name, new_size):
def _create_qtree(self, host_id, vol_name, qtree_name):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def create_volume_from_snapshot(self, volume, snapshot):
def create_cloned_volume(self, volume, src_vref):
def get_volume_stats(self, refresh=False):
def _update_volume_status(self):
def get_metadata_property(self, prop):
def _create_client(self, **kwargs):
def _check_flags(self):
def do_setup(self, context):
def check_for_setup_error(self):
def create_volume(self, volume):
def delete_volume(self, volume):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def create_volume_from_snapshot(self, volume, snapshot):
def _get_qos_type(self, volume):
def _add_lun_to_table(self, lun):
def _clone_lun(self, handle, new_name, extra_args):
def _create_metadata_list(self, extra_args):
def _get_lun_handle(self, name):
def _create_dict_from_meta(self, metadata):
def create_cloned_volume(self, volume, src_vref):
def get_volume_stats(self, refresh=False):
def _update_volume_status(self):
def _create_client(self, **kwargs):
def _do_custom_setup(self):
def _check_flags(self):
def do_setup(self, context):
def check_for_setup_error(self):
def create_volume(self, volume):
def delete_volume(self, volume):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def initialize_connection(self, volume, connector):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def create_volume_from_snapshot(self, volume, snapshot):
def terminate_connection(self, volume, connector, **kwargs):
def _get_ontapi_version(self):
def _create_lun_on_eligible_vol(self, name, size, metadata):
def _get_avl_volume_by_size(self, size):
def _get_iscsi_service_details(self):
def _get_target_details(self):
def _create_lun_handle(self, metadata):
def _get_lun_list(self):
def _extract_and_populate_luns(self, api_luns):
def _invoke_successfully(self, na_element, do_tunneling=False):
def _configure_tunneling(self, do_tunneling=False):
def _is_naelement(self, elem):
def _map_lun(self, name, initiator, initiator_type='iscsi', lun_id=None):
def _unmap_lun(self, path, initiator):
def _find_mapped_lun_igroup(self, path, initiator, os=None):
def _get_or_create_igroup(self, initiator, initiator_type='iscsi', os='default'):
def _get_igroup_by_initiator(self, initiator):
def _check_allowed_os(self, os):
def _create_igroup(self, igroup, igroup_type='iscsi', os_type='default'):
def _add_igroup_initiator(self, igroup, initiator):
def _get_qos_type(self, volume):
def _add_lun_to_table(self, lun):
def _clone_lun(self, name, new_name, space_reserved):
def _get_lun_by_args(self, **args):
def _get_lun_attr(self, name, attr):
def create_cloned_volume(self, volume, src_vref):
def get_volume_stats(self, refresh=False):
def _update_volume_status(self):
def _do_custom_setup(self):
def _get_avl_volume_by_size(self, size):
def _get_target_details(self):
def _get_iscsi_service_details(self):
def _create_lun_handle(self, metadata):
def _get_lun_list(self):
def _find_mapped_lun_igroup(self, path, initiator, os=None):
def _get_lun_map(self, path):
def _get_igroup_by_initiator(self, initiator):
def _clone_lun(self, name, new_name, space_reserved):
def _get_lun_by_args(self, **args):
def _create_lun_meta(self, lun):
def _configure_tunneling(self, do_tunneling=False):
def _update_volume_status(self):
def _do_custom_setup(self):
def _get_avl_volume_by_size(self, size):
def _check_vol_not_root(self, vol):
def _get_igroup_by_initiator(self, initiator):
def _get_target_details(self):
def _get_iscsi_service_details(self):
def _create_lun_handle(self, metadata):
def _get_lun_list(self):
def _get_vol_luns(self, vol_name):
def _find_mapped_lun_igroup(self, path, initiator, os=None):
def _clone_lun(self, name, new_name, space_reserved):
def _set_space_reserve(self, path, enable):
def _check_clone_status(self, clone_id, vol_uuid, name, new_name):
def _get_lun_by_args(self, **args):
def _create_lun_meta(self, lun):
def _configure_tunneling(self, do_tunneling=False):
def _update_volume_status(self):
def get_transport_type(self):
def set_transport_type(self, transport_type):
def get_style(self):
def set_style(self, style):
def get_server_type(self):
def set_server_type(self, server_type):
def set_api_version(self, major, minor):
def get_api_version(self):
def set_port(self, port):
def get_port(self):
def set_timeout(self, seconds):
def get_timeout(self):
def get_vfiler(self):
def set_vfiler(self, vfiler):
def get_vserver(self):
def set_vserver(self, vserver):
def set_username(self, username):
def set_password(self, password):
def invoke_elem(self, na_element):
def invoke_successfully(self, na_element):
def _create_request(self, na_element):
def _parse_response(self, response):
def _get_result(self, response):
def __init__(self, name):
def get_name(self):
def set_content(self, text):
def get_content(self):
def add_attr(self, name, value):
def add_attrs(self, **attrs):
def add_child_elem(self, na_element):
def get_child_by_name(self, name):
def get_child_content(self, name):
def get_children(self):
def has_attr(self, name):
def get_attr(self, name):
def get_attr_names(self):
def add_new_child(self, name, content, convert=False):
@staticmethod DCNL def _convert_entity_refs(text):
@staticmethod DCNL def create_node_with_children(node, **children):
def add_node_with_children(self, node, **children):
def to_string(self, pretty=False, method='xml', encoding='UTF-8'):
def check_for_setup_error(self):
def create_volume_from_snapshot(self, volume, snapshot):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def _check_dfm_flags(self):
def _get_client(self):
def _get_volume_location(self, volume_id):
def _clone_volume(self, volume_name, clone_name, volume_id):
def _wait_for_clone_finished(self, clone_operation_id, host_id):
def _get_provider_location(self, volume_id):
def _get_host_ip(self, volume_id):
def _get_export_path(self, volume_id):
def _get_host_id(self, volume_id):
def _get_full_export_path(self, volume_id, host_id):
def _volume_not_present(self, nfs_mount, volume_name):
def _get_volume_path(self, nfs_share, volume_name):
def create_cloned_volume(self, volume, src_vref):
def _update_volume_status(self):
def check_for_setup_error(self):
def _clone_volume(self, volume_name, clone_name, volume_id):
def _check_flags(self):
def _get_client(self):
def _update_volume_status(self):
def check_for_setup_error(self):
def _clone_volume(self, volume_name, clone_name, volume_id):
def _check_flags(self):
def _get_client(self):
def _do_custom_setup(self, client):
def _is_naelement(self, elem):
def _invoke_successfully(self, na_element, vserver=None):
def _get_ontapi_version(self):
def _do_custom_setup(self, client):
def _clone_volume(self, volume_name, clone_name, volume_id):
def _get_if_info_by_ip(self, ip):
def _get_vol_by_junc_vserver(self, vserver, junction):
def _clone_file(self, volume, src_path, dest_path, vserver=None):
def _update_volume_status(self):
def _do_custom_setup(self, client):
def _clone_volume(self, volume_name, clone_name, volume_id):
def _get_actual_path_for_export(self, export_path):
def _start_clone(self, src_path, dest_path):
def _wait_for_clone_finish(self, clone_op_id, vol_uuid):
def _clear_clone(self, clone_id):
def _update_volume_status(self):
def check_for_setup_error(self):
def get_volume_stats(self, refresh=False):
def create_volume(self, volume):
def create_volume_from_snapshot(self, volume, snapshot):
def delete_volume(self, volume):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def local_path(self, volume):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def check_for_setup_error(self):
def create_volume(self, volume):
def create_volume_from_snapshot(self, volume, snapshot):
def delete_volume(self, volume):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def do_setup(self, ctxt):
def check_for_setup_error(self):
def ensure_export(self, ctxt, volume):
def _add_chapsecret_to_host(self, host_name):
def _get_chap_secret_for_host(self, host_name):
def _connector_to_hostname_prefix(self, connector):
def _get_host_from_connector(self, connector):
def _create_host(self, connector):
def _get_hostvdisk_mappings(self, host_name):
def _map_vol_to_host(self, volume_name, host_name):
def _delete_host(self, host_name):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def _get_vdisk_attributes(self, vdisk_name):
def _get_vdisk_fc_mappings(self, vdisk_name):
def _create_vdisk(self, name, size, units, opts):
def _run_flashcopy(self, source, target, full_copy=True):
def _create_copy(self, src_vdisk, tgt_vdisk, full_copy, opts, src_id, from_vol):
def _is_vdisk_defined(self, vdisk_name):
def _delete_vdisk(self, name, force):
def get_volume_stats(self, refresh=False):
def _update_volume_status(self):
def _execute_command_and_parse_attributes(self, ssh_cmd):
def _get_hdr_dic(self, header, row, delim):
def _driver_assert(self, assert_condition, exception_message):
def _check_flags(self):
def check_for_setup_error(self):
def create_cloned_volume(self, volume, src_vref):
@lockutils.synchronized('3par-vol', 'cinder-', True) DCNL def create_volume_from_snapshot(self, volume, snapshot):
@lockutils.synchronized('3par-attach', 'cinder-', True) DCNL def initialize_connection(self, volume, connector):
@lockutils.synchronized('3par-attach', 'cinder-', True) DCNL def terminate_connection(self, volume, connector, force):
def _create_host(self, volume, connector):
def _get_3par_vol_name(self, volume_id):
def _cli_run(self, verb, cli_args):
def _ssh_execute(self, ssh, cmd, check_exit_code=True):
def _safe_hostname(self, hostname):
def create_vlun(self, volume, host, client):
@lockutils.synchronized('3par', 'cinder-', True) DCNL def create_volume_from_snapshot(self, volume, snapshot, client):
def _check_flags(self):
def check_for_setup_error(self):
@lockutils.synchronized('3par-vol', 'cinder-', True) DCNL def create_volume_from_snapshot(self, volume, snapshot):
@lockutils.synchronized('3par-attach', 'cinder-', True) DCNL def initialize_connection(self, volume, connector):
@lockutils.synchronized('3par-attach', 'cinder-', True) DCNL def terminate_connection(self, volume, connector, force):
def _create_host(self, volume, connector):
def _cliq_run(self, verb, cliq_args, check_exit_code=True):
def _cliq_run_xml(self, verb, cliq_args, check_cliq_result=True):
def _cliq_get_cluster_info(self, cluster_name):
def _cliq_get_cluster_vip(self, cluster_name):
def _cliq_get_volume_info(self, volume_name):
def create_volume(self, volume):
def create_volume_from_snapshot(self, volume, snapshot):
def create_snapshot(self, snapshot):
def delete_volume(self, volume):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def check_for_setup_error(self):
def create_cloned_volume(self, volume, src_vref):
def _get_target_groups(self):
def create_volume(self, volume):
def delete_volume(self, volume):
def ensure_export(self, context, volume):
def remove_export(self, context, volume):
def _collect_lines(self, data):
def _get_prefixed_values(self, data, prefix):
def _generate_vpsa_cmd(self, cmd, **kwargs):
def ensure_connection(self, cmd=None):
def send_cmd(self, cmd, **kwargs):
def do_setup(self, context):
def check_for_setup_error(self):
def local_path(self, volume):
def _xml_parse_helper(self, xml_tree, first_level, search_tuple, first=True):
def _get_vpsa_volume_name(self, name):
def _get_active_controller_details(self):
def _get_server_name(self, initiator):
def _create_vpsa_server(self, initiator):
def create_volume(self, volume):
def delete_volume(self, volume):
def create_export(self, context, volume):
def ensure_export(self, context, volume):
def remove_export(self, context, volume):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def copy_image_to_volume(self, context, volume, image_service, image_id):
def copy_volume_to_image(self, context, volume, image_service, image_meta):
def create_cloned_volume(self, volume, src_vref):
def do_setup(self, context):
def check_for_setup_error(self):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def create_volume(self, volume):
def delete_volume(self, volume):
def create_snapshot(self, snapshot):
def create_volume_from_snapshot(self, volume, snapshot):
def delete_snapshot(self, snapshot):
def _do_export(self, _ctx, volume, ensure=False):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def remove_export(self, context, volume):
def copy_image_to_volume(self, context, volume, image_service, image_id):
def copy_volume_to_image(self, context, volume, image_service, image_meta):
def _login(self):
def _set_group(self, reply):
def _get_group_id(self, groupName, loginResult):
def _esm(self, url=False, data=None):
def _configure(self, data):
def _get_volume_info(self, lvname):
def _get_lun_address(self, volume_name):
def create_lun(self, volume_name, volume_size, repository):
def delete_lun(self, volume_name):
def create_snapshot(self, volume_name, snapshot_name):
def delete_snapshot(self, snapshot_name):
def create_volume_from_snapshot(self, snapshot_name, volume_name, repository):
def do_setup(self, context):
def check_for_setup_error(self):
def _get_repository(self, volume_type):
def create_volume(self, volume):
def delete_volume(self, volume):
def create_snapshot(self, snapshot):
def delete_snapshot(self, snapshot):
def create_volume_from_snapshot(self, volume, snapshot):
def initialize_connection(self, volume, connector):
def get_volume_stats(self, refresh=False):
def _issue_api_request(self, method_name, params):
def _get_volumes_by_sfaccount(self, account_id):
def _get_sfaccount_by_name(self, sf_account_name):
def _get_sf_account_name(self, project_id):
def _create_sfaccount(self, project_id):
def _get_cluster_info(self):
def _do_export(self, volume):
def _generate_random_string(self, length):
def _get_model_info(self, sfaccount, sf_volume_id):
def _do_clone_volume(self, src_uuid, src_project_id, v_ref):
def create_volume(self, volume):
def create_cloned_volume(self, volume, src_vref):
def delete_volume(self, volume):
def ensure_export(self, context, volume):
def create_export(self, context, volume):
def delete_snapshot(self, snapshot):
def create_snapshot(self, snapshot):
def create_volume_from_snapshot(self, volume, snapshot):
def get_volume_stats(self, refresh=False):
def _update_cluster_status(self):
def check_for_setup_error(self):
def delete_snapshot(self, snapshot):
def _create_sparsed_file(self, path, size):
def _create_regular_file(self, path, size):
def _set_rw_permissions_for_all(self, path):
def local_path(self, volume):
def _path_exists(self, path):
def _get_hash_str(self, base_str):
def do_setup(self, context):
def create_volume(self, volume):
def delete_volume(self, volume):
def ensure_export(self, ctx, volume):
def create_export(self, ctx, volume):
def remove_export(self, ctx, volume):
def initialize_connection(self, volume, connector):
def terminate_connection(self, volume, connector, **kwargs):
def _do_create_volume(self, volume):
def _ensure_shares_mounted(self):
def _ensure_share_mounted(self, nfs_share):
def _find_share(self, volume_size_for):
def _get_mount_point_for_share(self, nfs_share):
def _get_available_capacity(self, nfs_share):
def _mount_nfs(self, nfs_share, mount_path, ensure=False):
def get_volume_stats(self, refresh=False):
def _update_volume_status(self):
def check_for_setup_error(self):
@staticmethod DCNL def _get_zvol_name(volume_name):
@staticmethod DCNL def _get_target_name(volume_name):
@staticmethod DCNL def _get_target_group_name(volume_name):
def create_volume(self, volume):
def delete_volume(self, volume):
def create_snapshot(self, snapshot):
def create_volume_from_snapshot(self, volume, snapshot):
def delete_snapshot(self, snapshot):
def local_path(self, volume):
def _do_export(self, _ctx, volume, ensure=False):
def create_export(self, _ctx, volume):
def ensure_export(self, _ctx, volume):
def remove_export(self, _ctx, volume):
def copy_image_to_volume(self, context, volume, image_service, image_id):
def copy_volume_to_image(self, context, volume, image_service, image_meta):
def create_cloned_volume(self, volume, src_vref):
def get_volume_stats(self, refresh=False):
def _update_volume_status(self):
def __init__(self, volume_opts, config_group=None):
def __init__(self, volume_driver=None, service_name=None, *args, **kwargs):
def init_host(self):
def create_volume(self, context, volume_id, request_spec=None, filter_properties=None, allow_reschedule=True, snapshot_id=None, image_id=None, source_volid=None):
def _reschedule_or_reraise(self, context, volume_id, exc_info, snapshot_id, image_id, request_spec, filter_properties, allow_reschedule):
def _reschedule(self, context, request_spec, filter_properties, volume_id, scheduler_method, method_args, exc_info=None):
def delete_volume(self, context, volume_id):
def create_snapshot(self, context, volume_id, snapshot_id):
def delete_snapshot(self, context, snapshot_id):
def attach_volume(self, context, volume_id, instance_uuid, mountpoint):
def detach_volume(self, context, volume_id):
def _copy_image_to_volume(self, context, volume, image_service, image_id):
def copy_volume_to_image(self, context, volume_id, image_meta):
def initialize_connection(self, context, volume_id, connector):
def terminate_connection(self, context, volume_id, connector, force=False):
def publish_service_capabilities(self, context):
@wrap_check_policy DCNL def get_volume_metadata(self, context, volume):
@wrap_check_policy DCNL def delete_volume_metadata(self, context, volume, key):
@wrap_check_policy DCNL def update_volume_metadata(self, context, volume, metadata, delete=False):
def get_volume_metadata_value(self, volume, key):
def get_snapshot_metadata(self, context, snapshot):
def delete_snapshot_metadata(self, context, snapshot, key):
def update_snapshot_metadata(self, context, snapshot, metadata, delete=False):
def _check_volume_availability(self, context, volume, force):
@wrap_check_policy DCNL def copy_volume_to_image(self, context, volume, metadata, force):
def set_host_enabled(self, context, host, enabled):
def get_host_uptime(self, context, host):
def set_host_maintenance(self, context, host, mode):
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True):
def create_virtualenv(self, no_site_packages=True):
def parse_args(self, argv):
def post_process(self):
def post_process(self):
@classmethod DCNL def from_msg_to_dict(cls, msg):
def revoke_certs_by_user(self, context, user_id):
def revoke_certs_by_project(self, context, project_id):
def revoke_certs_by_user_and_project(self, context, user_id, project_id):
def generate_x509_cert(self, context, user_id, project_id):
def fetch_ca(self, context, project_id):
def fetch_crl(self, context, project_id):
def decrypt_text(self, context, project_id, text):
def post_migrations(self):
def setUp(self):
def flags(self, **kw):
def __init__(self, instance, address=None, content=[], extra_md=None, conductor_api=None):
def metadata_for_config_drive(self):
def __init__(self, application):
def _matches_any_role(self, context, roles):
def _format_instance_bdm(self, context, instance_uuid, root_device_name, result):
def _ec2_ids_to_instances(self, context, instance_id):
def terminate_instances(self, context, instance_id, **kwargs):
def reboot_instances(self, context, instance_id, **kwargs):
def stop_instances(self, context, instance_id, **kwargs):
def start_instances(self, context, instance_id, **kwargs):
def _format_image(self, image):
def __init__(self, exception):
@webob.dec.wsgify DCNL def __call__(self, req):
def _get_roles(self, req):
def __init__(self, ext_mgr):
def get_resources(self):
def get_controller_extensions(self):
@classmethod DCNL def nsmap(cls):
@classmethod DCNL def xmlname(cls, name):
def get_resources(self):
def get_controller_extensions(self):
def _check_extension(self, extension):
def load_extension(self, ext_factory):
def _load_extensions(self):
@classmethod DCNL def factory(cls, global_config, **local_config):
def extract_metadata(self, metadata_node):
def _get_next_link(self, request, identifier, collection_name):
def _get_href_link(self, request, identifier, collection_name):
def _get_bookmark_link(self, request, identifier, collection_name):
def _get_collection_links(self, request, items, collection_name, id_key='uuid'):
def __init__(self, *chain):
def __repr__(self):
def __call__(self, obj, do_raise=False):
def __call__(self, obj, do_raise=False):
def __init__(self, value):
def __repr__(self):
def __call__(self, _obj, _do_raise=False):
def __init__(self, tag, attrib=None, selector=None, subselector=None, **extra):
def __repr__(self):
def __len__(self):
def __contains__(self, key):
def __getitem__(self, idx):
def append(self, elem):
def extend(self, elems):
def insert(self, idx, elem):
def remove(self, elem):
def get(self, key):
def set(self, key, value=None):
def keys(self):
def items(self):
def unwrap(self):
def wrap(self):
def apply(self, elem, obj):
def _render(self, parent, datum, patches, nsmap):
def render(self, parent, obj, patches=[], nsmap=None):
def will_render(self, datum):
def _text_get(self):
def tree(self):
def __init__(self, root, nsmap=None):
def _serialize(self, parent, obj, siblings, nsmap=None):
def serialize(self, obj, *args, **kwargs):
def make_tree(self, obj):
def _siblings(self):
def _nsmap(self):
def unwrap(self):
def wrap(self):
def apply(self, master):
def tree(self):
def __init__(self, root, version, nsmap=None):
def __repr__(self):
def _siblings(self):
def _nsmap(self):
def attach(self, *slaves):
def copy(self):
def __init__(self, root, min_vers, max_vers=None, nsmap=None):
def __repr__(self):
def apply(self, master):
def __new__(cls, copy=True):
def construct(self):
def cache_db_items(self, key, items, item_key='id'):
def get_db_items(self, key):
def get_db_item(self, key, item_key):
def best_match_content_type(self):
def get_content_type(self):
def dispatch(self, *args, **kwargs):
def __init__(self, metadata=None):
def _from_xml_node(self, node, listnames):
def find_first_child_named_in_namespace(self, parent, namespace, name):
def find_first_child_named(self, parent, name):
def find_children_named(self, parent, name):
def extract_text(self, node):
def extract_elements(self, node):
def find_attribute_or_element(self, parent, name):
def extract_metadata(self, metadata_node):
def __init__(self, metadata=None, xmlns=None):
def _to_xml_node(self, doc, metadata, nodename, data):
def _to_xml(self, root):
def __init__(self, obj, code=None, headers=None, **serializers):
def __getitem__(self, key):
def __setitem__(self, key, value):
def __delitem__(self, key):
def _bind_method_serializers(self, meth_serializers):
def get_serializer(self, content_type, default_serializers=None):
def preserialize(self, content_type, default_serializers=None):
def attach(self, **kwargs):
def serialize(self, request, content_type, default_serializers=None):
@property DCNL def code(self):
@property DCNL def headers(self):
def __init__(self, controller, action_peek=None, inherits=None, **deserializers):
def register_actions(self, controller):
def register_extensions(self, controller):
def get_action_args(self, request_environment):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
def _process_stack(self, request, action, action_args, content_type, body, accept):
def _get_method(self, request, action, content_type, body):
def dispatch(self, method, request, action_args):
def __new__(mcs, name, bases, cls_dict):
def __init__(self, view_builder=None):
def __init__(self, exception):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
def __init__(self, message, details, retry_time):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
def content_type_params(self, best_content_type):
def _match(self, host, port, path_info):
def _path_strategy(self, host, port, path_info):
def _content_type_strategy(self, host, port, environ):
def _accept_strategy(self, host, port, environ, supported_content_types):
def basic(self, ip):
def show(self, network, label):
def index(self, networks):
def basic(self, request, image):
def show(self, request, image):
def detail(self, request, images):
def index(self, request, images):
def _list_view(self, list_func, request, images):
def _get_links(self, request, identifier, collection_name):
def _get_alternate_link(self, request, identifier):
@staticmethod DCNL def _format_date(date_string):
@staticmethod DCNL def _get_status(image):
def index(self, request, flavors):
def detail(self, request, flavors):
def _list_view(self, func, request, flavors):
def _build_absolute_limits(self, absolute_limits):
def __init__(self):
def create(self, request, instance):
@_skip_precooked DCNL def basic(self, request, instance):
@_skip_precooked DCNL def show(self, request, instance):
def index(self, request, instances):
def detail(self, request, instances):
def _list_view(self, func, request, servers):
def __init__(self, base_url):
def _build_links(self, version_data):
def generate_href(self, path=None):
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, image_id):
def __init__(self, image_service=None, **kwargs):
def _get_filters(self, req):
@wsgi.serializers(xml=ImageTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=MinimalImagesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=ImagesTemplate) DCNL def detail(self, req):
@wsgi.serializers(xml=MinimalFlavorsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=FlavorsTemplate) DCNL def detail(self, req):
@wsgi.serializers(xml=FlavorTemplate) DCNL def show(self, req, id):
def _get_is_public(self, req):
def _get_flavors(self, req):
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req):
def create(self, req, body):
def delete(self, req, id):
def detail(self, req):
def show(self, req, id):
def update(self, req, id, body):
def __init__(self, verb, uri, regex, value, unit):
def __call__(self, verb, url):
def _get_time(self):
def display_unit(self):
def display(self):
def __init__(self, application, limits=None, limiter=None, **kwargs):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req):
def __init__(self, limits, **kwargs):
def get_limits(self, username=None):
def check_for_delay(self, verb, url, username=None):
@staticmethod DCNL def parse_limits(limits):
def __init__(self, limits=None):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request):
def __init__(self, limiter_address):
@staticmethod DCNL def parse_limits(limits):
@wsgi.serializers(xml=ConsolesTemplate) DCNL def index(self, req, server_id):
def create(self, req, server_id):
@wsgi.serializers(xml=ConsoleTemplate) DCNL def show(self, req, server_id, id):
def update(self, req, server_id, id):
def delete(self, req, server_id, id):
@wsgi.serializers(xml=HostIndexTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=HostUpdateTemplate) DCNL @wsgi.deserializers(xml=HostUpdateDeserializer) DCNL def update(self, req, id, body):
def _set_host_maintenance(self, context, host_name, mode=True):
def _set_enabled_status(self, context, host_name, enabled):
def _host_power_action(self, req, host_name, action):
@wsgi.serializers(xml=HostShowTemplate) DCNL def show(self, req, id):
def _extract_volume(self, node):
def default(self, string):
@wsgi.serializers(xml=VolumeTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=VolumesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=VolumesTemplate) DCNL def detail(self, req):
def _items(self, req, entity_maker):
@wsgi.serializers(xml=VolumeTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body):
@wsgi.serializers(xml=VolumeAttachmentsTemplate) DCNL def index(self, req, server_id):
@wsgi.serializers(xml=VolumeAttachmentTemplate) DCNL def show(self, req, server_id, id):
@wsgi.serializers(xml=VolumeAttachmentTemplate) DCNL def create(self, req, server_id, body):
def update(self, req, server_id, id, body):
def delete(self, req, server_id, id):
def _items(self, req, server_id, entity_maker):
@wsgi.serializers(xml=SnapshotTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=SnapshotsTemplate) DCNL def detail(self, req):
def _items(self, req, entity_maker):
@wsgi.serializers(xml=SnapshotTemplate) DCNL def create(self, req, body):
def index(self, req, server_id):
def show(self, req, server_id, id):
def create(self, req, server_id, body):
def update(self, req, server_id, id, body):
def delete(self, req, server_id, id):
def _items(self, req, server_id, entity_maker):
@wsgi.serializers(xml=InstanceActionsTemplate) DCNL def index(self, req, server_id):
@wsgi.serializers(xml=InstanceActionTemplate) DCNL def show(self, req, server_id, id):
def _format_quota_set(self, quota_class, quota_set):
@wsgi.action('evacuate') DCNL def _evacuate(self, req, id, body):
@wsgi.serializers(xml=FloatingIPTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=FloatingIPsTemplate) DCNL def index(self, req):
def _get_ip_by_id(self, context, value):
@wsgi.action('addFloatingIp') DCNL def _add_floating_ip(self, req, id, body):
@wsgi.action('removeFloatingIp') DCNL def _remove_floating_ip(self, req, id, body):
def default(self, string):
def _get_cells(self, ctxt, req, detail=False):
@wsgi.serializers(xml=CellsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=CellsTemplate) DCNL def detail(self, req):
@wsgi.serializers(xml=CellTemplate) DCNL def info(self, req):
@wsgi.serializers(xml=CellTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
def _validate_cell_name(self, cell_name):
def _validate_cell_type(self, cell_type):
def _convert_cell_type(self, cell):
@wsgi.serializers(xml=CellTemplate) DCNL @wsgi.deserializers(xml=CellDeserializer) DCNL def create(self, req, body):
@wsgi.serializers(xml=CellTemplate) DCNL @wsgi.deserializers(xml=CellDeserializer) DCNL def update(self, req, id, body):
def sync_instances(self, req, body):
@wsgi.action('os-getConsoleOutput') DCNL def get_console_output(self, req, id, body):
def index(self, req):
def show(self, req, id):
def create(self, req, body):
def update(self, req, id, body):
def _address_to_hosts(self, addresses):
def index(self, req):
def create(self, req, body):
def show(self, req, id):
def update(self, req, id, body):
def delete(self, req, id):
@get_host_from_body DCNL def _add_host(self, req, id, host):
@get_host_from_body DCNL def _remove_host(self, req, id, host):
def _set_metadata(self, req, id, body):
def _get_flavor_refs(self, context):
def default(self, string):
def default(self, string):
def _extract_security_group_rule(self, node):
@wsgi.serializers(xml=SecurityGroupTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=SecurityGroupsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=SecurityGroupTemplate) DCNL @wsgi.deserializers(xml=SecurityGroupXMLDeserializer) DCNL def create(self, req, body):
@wsgi.serializers(xml=SecurityGroupsTemplate) DCNL def index(self, req, server_id):
@wsgi.action('update') DCNL def update(self, req, id, body):
def setup(self):
def _get_all_cloudpipes(self, context):
def _get_cloudpipe_for_project(self, context, project_id):
@wsgi.serializers(xml=CloudpipeTemplate) DCNL def create(self, req, body):
@wsgi.serializers(xml=CloudpipesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=CertificateTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=CertificateTemplate) DCNL def create(self, req, body=None):
@wsgi.serializers(xml=ExtraSpecsTemplate) DCNL def index(self, req, flavor_id):
@wsgi.serializers(xml=ExtraSpecTemplate) DCNL def show(self, req, flavor_id, id):
def delete(self, req, flavor_id, id):
def _items(self, req, server_id, entity_maker):
@wsgi.serializers(xml=VirtualInterfaceTemplate) DCNL def index(self, req, server_id):
@wsgi.serializers(xml=DomainsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=DomainTemplate) DCNL def update(self, req, id, body):
def delete(self, req, id):
@wsgi.serializers(xml=FloatingIPDNSTemplate) DCNL def show(self, req, domain_id, id):
@wsgi.serializers(xml=FloatingIPDNSTemplate) DCNL def update(self, req, domain_id, id, body):
def delete(self, req, domain_id, id):
@wsgi.serializers(xml=ServicesIndexTemplate) DCNL def index(self, req):
@wsgi.deserializers(xml=ServiceUpdateDeserializer) DCNL @wsgi.serializers(xml=ServiceUpdateTemplate) DCNL def update(self, req, id, body):
@wsgi.action('os-start') DCNL def _start_server(self, req, id, body):
@wsgi.action('os-stop') DCNL def _stop_server(self, req, id, body):
def _format_quota_set(self, project_id, quota_set):
def _find_services(self, req):
def _find_ports(self, req, hosts):
def _start_coverage(self, req, body):
@wsgi.serializers(xml=FloatingIPPoolsTemplate) DCNL def index(self, req):
@wsgi.action('restore') DCNL def _restore(self, req, id, body):
@wsgi.action('forceDelete') DCNL def _force_delete(self, req, id, body):
def show(self, req, id):
def _get_audit_task_logs(self, context, begin=None, end=None, before=None):
@wsgi.action('rescue') DCNL @exts.wrap_errors DCNL def _rescue(self, req, id, body):
@wsgi.action('unrescue') DCNL @exts.wrap_errors DCNL def _unrescue(self, req, id, body):
@wsgi.action('os-getVNCConsole') DCNL def get_vnc_console(self, req, id, body):
@wsgi.action('os-getSPICEConsole') DCNL def get_spice_console(self, req, id, body):
def get_actions(self):
def _get_flavor(self, context, compute_api, instance, flavors_cache):
@wsgi.serializers(xml=SimpleTenantUsagesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=SimpleTenantUsageTemplate) DCNL def show(self, req, id):
@wsgi.action('pause') DCNL def _pause(self, req, id, body):
@wsgi.action('unpause') DCNL def _unpause(self, req, id, body):
@wsgi.action('suspend') DCNL def _suspend(self, req, id, body):
@wsgi.action('resume') DCNL def _resume(self, req, id, body):
@wsgi.action('migrate') DCNL def _migrate(self, req, id, body):
@wsgi.action('resetNetwork') DCNL def _reset_network(self, req, id, body):
@wsgi.action('injectNetworkInfo') DCNL def _inject_network_info(self, req, id, body):
@wsgi.action('lock') DCNL def _lock(self, req, id, body):
@wsgi.action('unlock') DCNL def _unlock(self, req, id, body):
@wsgi.action('createBackup') DCNL def _create_backup(self, req, id, body):
@wsgi.action('os-migrateLive') DCNL def _migrate_live(self, req, id, body):
@wsgi.action('os-resetState') DCNL def _reset_state(self, req, id, body):
@wsgi.serializers(xml=AvailabilityZonesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=AvailabilityZonesTemplate) DCNL def detail(self, req):
@wsgi.action('addFixedIp') DCNL def _add_fixed_ip(self, req, id, body):
@wsgi.action('removeFixedIp') DCNL def _remove_fixed_ip(self, req, id, body):
@wsgi.serializers(xml=AgentsIndexTemplate) DCNL def index(self, req):
def update(self, req, id, body):
def delete(self, req, id):
def create(self, req, body):
@wsgi.serializers(xml=KeypairTemplate) DCNL def create(self, req, body):
def delete(self, req, id):
@wsgi.serializers(xml=KeypairTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=KeypairsTemplate) DCNL def index(self, req):
def _extract_personality(self, server_node):
def _extract_server(self, node):
def _extract_block_device_mapping(self, server_node):
def _extract_scheduler_hints(self, server_node):
def _extract_networks(self, server_node):
def _extract_security_groups(self, server_node):
def default(self, string):
@wsgi.serializers(xml=MinimalServersTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=ServersTemplate) DCNL def detail(self, req):
def _get_servers(self, req, is_detail):
def _get_server(self, context, req, instance_uuid):
def _get_injected_files(self, personality):
def _get_requested_networks(self, requested_networks):
def _validate_user_data(self, user_data):
@wsgi.serializers(xml=ServerTemplate) DCNL def show(self, req, id):
@wsgi.response(202) DCNL @wsgi.serializers(xml=FullServerTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body):
@wsgi.serializers(xml=ServerTemplate) DCNL def update(self, req, id, body):
def _resize(self, req, instance_id, flavor_id, **kwargs):
@wsgi.response(204) DCNL def delete(self, req, id):
def _image_from_req_data(self, data):
def _validate_metadata(self, metadata):
@wsgi.response(202) DCNL @wsgi.serializers(xml=FullServerTemplate) DCNL @wsgi.deserializers(xml=ActionDeserializer) DCNL @wsgi.action('resize') DCNL def _action_resize(self, req, id, body):
@wsgi.response(202) DCNL @wsgi.serializers(xml=FullServerTemplate) DCNL @wsgi.deserializers(xml=ActionDeserializer) DCNL @wsgi.action('rebuild') DCNL def _action_rebuild(self, req, id, body):
@wsgi.response(202) DCNL @wsgi.serializers(xml=FullServerTemplate) DCNL @wsgi.deserializers(xml=ActionDeserializer) DCNL @wsgi.action('createImage') DCNL @common.check_snapshots_enabled DCNL def _action_create_image(self, req, id, body):
def _get_server_admin_password(self, server):
def _get_server_search_options(self):
@wsgi.serializers(xml=common.MetadataTemplate) DCNL def index(self, req, server_id):
@wsgi.serializers(xml=common.MetaItemTemplate) DCNL def show(self, req, server_id, id):
@wsgi.response(204) DCNL def delete(self, req, server_id, id):
@wsgi.serializers(xml=VersionsTemplate, atom=VersionsAtomSerializer) DCNL def index(self, req):
@wsgi.serializers(xml=ChoicesTemplate) DCNL @wsgi.response(300) DCNL def multi(self, req):
def get_action_args(self, request_environment):
def init_host(self):
def __init__(self, data, limit):
def process_bind_param(self, value, dialect):
def process_bind_param(self, value, dialect):
def __init__(self, retvalue=True):
def rollback_and_reraise(self, msg=None, **kwargs):
def get_port(self, context):
def setup_console(self, context, console):
def teardown_console(self, context, console):
def init_host(self):
def fix_pool_password(self, password):
def generate_password(self, vim_session, pool, instance_name):
def is_otp(self):
def generate_password(self, vim_session, pool, instance_name):
def is_otp(self):
def get_port(self, context):
def setup_console(self, context, console):
def teardown_console(self, context, console):
def init_host(self):
def fix_pool_password(self, password):
def fix_console_password(self, password):
def _xvp_encrypt(self, password, is_pool_password=False):
def new_client(self):
def _get_vim_session(self, pool):
def _generate_console(self, context, pool, name, instance_id, instance):
def add_console(self, context, instance_id, password=None, port=None, **kwargs):
def remove_console(self, context, console_id, **_kwargs):
def get_pool_for_instance_host(self, context, instance_host):
def setup_console(self, context, console):
def teardown_console(self, context, console):
def init_host(self):
def generate_password(self, length=8):
def get_port(self, context):
def fix_pool_password(self, password):
def fix_console_password(self, password):
def __init__(self, kind, match):
def __call__(self, target, creds):
def test_version_string_with_package_is_good(self):
@contextlib.contextmanager DCNL def _make_base_file(self, checksum=True):
def _create_volume(self, size=0):
def test_spawn_fail_cleanup_1(self):
def test_spawn_fail_cleanup_2(self):
def test_spawn_fail_cleanup_3(self):
def _create_instance(self, instance_id=1, spawn=True):
def test_instance_not_auto_disk_config(self):
@stub_vm_utils_with_vdi_attached_here DCNL def test_instance_auto_disk_config_passes_fail_safes(self):
def test_get_all_bw_counters_in_failure_case(self):
def test_add_host_to_aggregate_invalid_changing_status(self):
def test_add_host_to_aggregate_invalid_dismissed_status(self):
def test_add_host_to_aggregate_invalid_error_status(self):
def test_remove_host_from_aggregate_invalid_dismissed_status(self):
def test_remove_host_from_aggregate_invalid_changing_status(self):
def test_disassociate_auto_assigned_address(self):
def _restart_compute_service(self, periodic_interval_max=None):
def _do_test_create_image(self, no_reboot):
def test_create_image_instance_store(self):
def _send_bad_attempts(self, access_key, num_attempts=1):
def _is_locked_out(self, access_key):
def test_create_volume_in_availability_zone(self):
def test_describe_instances_bdm(self):
def _restart_compute_service(self, periodic_interval_max=None):
def setUp(self):
def test_metadata_deserializer(self):
def _prepare_xml(self, xml_string):
def test_multi_choice_server_atom(self):
def test_create_image_snapshots_disabled(self):
def test_corrupt_xml(self):
def test_unique_host_id(self):
def test_get_servers_admin_filters_as_user(self):
def test_get_servers_admin_options_as_admin(self):
def test_get_servers_admin_allows_ip(self):
def test_get_servers_admin_allows_ip6(self):
def test_get_all_server_details_with_host(self):
def setUp(self):
def _check_admin_pass_len(self, server_dict):
def _check_admin_pass_missing(self, server_dict):
def test_create_multiple_instances(self):
def test_create_multiple_instances_pass_disabled(self):
def test_create_multiple_instances_resv_id_return(self):
def test_create_multiple_instances_with_multiple_volume_bdm(self):
def test_create_multiple_instances_with_single_volume_bdm(self):
def test_create_instance_with_volumes_enabled_no_image(self):
def test_create_instance_with_volumes_enabled_and_bdms_no_image(self):
def test_corrupt_xml(self):
def setUp(self):
def test_delete_deleted_image(self):
def test_get_flavor_list_detail_min_ram_and_min_disk(self):
def test_show_should_include_disabled_flavor_for_user(self):
def _get_time(self):
def setUp(self):
def _get_index_request(self, accept_header='application/json'):
def _populate_limits(self, request):
def _populate_limits_diff_regex(self, request):
@webob.dec.wsgify DCNL def _empty_app(self, request):
def setUp(self):
def setUp(self):
def _check(self, num, verb, url, username=None):
def _check_sum(self, num, verb, url, username=None):
def test_no_delay_GET(self):
def test_delay_PUT(self):
def test_delay_POST(self):
def test_delay_PUT_servers(self):
def test_delay_PUT_wait(self):
def setUp(self):
def _request_data(self, verb, path):
def _request(self, verb, url, username=None):
def __init__(self, response_string):
def makefile(self, _mode, _other):
def __init__(self, app, host):
def request(self, method, path, body='', headers=None):
def getresponse(self):
def setUp(self):
def test_create_server_detect_from_image(self):
def _create_floating_ips(self, floating_ips=None):
def test_create_backup_negative_rotation(self):
def test_list_hosts(self):
def _create_compute_service(self):
def test_show_no_project(self):
def test_show_works_correctly(self):
def _create_floating_ip(self):
def setUp(self):
def _assert_no_security_groups_reserved(self, context):
def test_corrupt_xml(self):
def test_corrupt_xml(self):
def test_only_tests_intersect(self):
def test_instance_action_start(self):
def test_instance_action_finish(self):
def test_instance_actions_get_by_instance(self):
def test_instance_action_get_by_instance_and_action(self):
def test_instance_action_event_start(self):
def test_instance_action_event_finish_success(self):
def test_instance_action_event_finish_error(self):
def test_instance_action_and_event_start_string_time(self):
def test_instance_action_event_get_by_id(self):
def test_add_key_pair(self, name=None):
def test_key_pair_destroy(self):
def test_key_pair_get(self):
def _restart_compute_service(self, *args, **kwargs):
def generalize_subs(self, subs, vanilla_regexes):
def test_keypairs_post(self, public_key=None):
def test_services_list(self):
def test_service_enable(self):
def test_service_disable(self):
def setUp(self):
def tearDown(self):
def setUp(self):
def _create_flavor(self):
def _get_flags(self):
def test_run_calls_deploy(self):
def test_run_with_failing_deploy(self):
def test_deploy(self):
def test_always_logout_iscsi(self):
def _create_instance(self):
def _test_get_test_network_info(self):
def elevated(self):
def _create_vm(self):
def _check_vm_record(self):
def _check_vm_info(self, info, pwr_state=power_state.RUNNING):
def hgetall(self, key):
def simple_bind_s(self, dn, password):
def unbind_s(self):
def add_s(self, dn, attr):
def delete_s(self, dn):
def modify_s(self, dn, attrs):
def search_s(self, dn, scope, query=None, fields=None):
@property DCNL def __prefix(self):
def match(self, d2):
def match(self, l2):
def match(self, sub_dict):
def node(self, tag, idx):
def _compare_node(self, expected, actual, state, idx):
def test_set_availability_zone_compute_service(self):
def test_set_availability_zone_not_compute_service(self):
def test_get_host_availability_zone(self):
def test_get_availability_zones(self):
def create_fake_libvirt_mock(self, **kwargs):
def test_failing_vcpu_count(self):
def _create_instance_type(self, params=None):
def _create_instance(self, params=None):
def test_migrate_disk_and_power_off_exception(self):
def test_migrate_disk_and_power_off(self):
def test_finish_migration(self):
def test_finish_revert_migration(self):
def test_create_without_instance_id(self):
def detail(self, context, **kwargs):
def show(self, context, image_id):
def create(self, context, metadata, data=None):
def update(self, context, image_id, metadata, data=None, purge_props=False):
def delete(self, context, image_id):
def get_volumes_5678(self, **kw):
def fake_oat_request(self, *args, **kwargs):
def test_filter_hosts_avoid(self):
def test_filter_hosts_no_avoid(self):
def test_schedule_happy_day(self):
def test_schedule_host_pool(self):
def test_schedule_large_host_pool(self):
def test_schedule_chooses_best_host(self):
def test_select_hosts_happy_day(self):
def __init__(self, context=None, params=None, type_name='m1.tiny'):
def _create_fake_instance(self, params=None, type_name='m1.tiny'):
def host_call_plugin(self, _1, _2, plugin, method, args):
def _create_instance(self, cores=2):
def makefile(self, _mode, _other):
def close(self):
def expect_http(self, host=None, is_secure=False, api_version=None):
def test_return_valid_isoformat(self):
def test_describe_instances(self):
def test_get_all_key_pairs(self):
def test_create_duplicate_key_pair(self):
def test_group_name_valid_chars_security_group(self):
def test_group_name_valid_length_security_group(self):
def test_authorize_revoke_security_group_cidr(self):
def test_authorize_revoke_security_group_cidr_v6(self):
def test_authorize_revoke_security_group_foreign_group(self):
def _mock_assert_host_exists(self):
def _limits(self, memory_mb=FAKE_VIRT_MEMORY_MB, disk_gb=FAKE_VIRT_LOCAL_GB, vcpus=FAKE_VIRT_VCPUS):
def _create_fake_instance(self, params=None, type_name='m1.tiny'):
def _create_instance(self, params=None, type_name='m1.tiny'):
def _create_instance_type(self, params=None):
def test_create_instance_with_oversubscribed_ram_fail(self):
def test_create_instance_with_oversubscribed_disk_fail(self):
def test_run_instance_setup_block_device_mapping_fail(self):
def test_run_instance_spawn_fail(self):
def test_run_instance_dealloc_network_instance_not_found(self):
def test_run_terminate_with_vol_attached(self):
def test_run_terminate_no_image(self):
def test_terminate_failure_leaves_task_state(self):
def _do_test_set_admin_password_driver_error(self, exc, expected_vm_state, expected_task_state, expected_exception):
def test_set_admin_password_driver_not_authorized(self):
def test_set_admin_password_driver_not_implemented(self):
def _assert_state(self, state_dict):
def test_instance_termination_exception_sets_error(self):
def _ensure_quota_reservations_committed(self, expect_project=False):
def _ensure_quota_reservations_rolledback(self, expect_project=False):
def test_finish_resize_with_volumes(self):
def test_prep_resize_instance_migration_error_on_same_host(self):
def test_prep_resize_instance_migration_error_on_none_host(self):
def test_resize_same_source_fails(self):
def test_post_live_migration_no_shared_storage_working_correctly(self):
def test_init_instance_update_nw_info_cache_legacy(self):
def test_init_instance_update_nw_info_cache(self):
def test_snapshot_given_image_uuid(self):
def test_snapshot_minram_mindisk_VHD(self):
def test_snapshot_minram_mindisk(self):
def test_snapshot_minram_mindisk_img_missing_minram(self):
def test_snapshot_minram_mindisk_no_image(self):
def test_reservation_id_one_instance(self):
def test_reservation_ids_two_instances(self):
def test_reschedule_or_reraise_called(self):
def test_shutdown_instance_fail(self):
def test_reschedule_resize_or_reraise_called(self):
def test_reschedule_fails_with_exception(self):
def test_reschedule_false(self):
def test_rebuild_on_host_updated_target(self):
def test_rebuild_with_wrong_shared_storage(self):
def test_rebuild_on_host_with_volumes(self):
def test_rebuild_on_host_with_shared_storage(self):
def test_rebuild_on_host_without_shared_storage(self):
def test_rebuild_on_host_instance_exists(self):
def _create_instance(self, params={}):
def test_mysql_connect_fail(self):
def test_postgresql_connect_fail(self):
def _migrate_up(self, engine, version, with_data=False):
def test_ip_association_and_allocation_of_other_project(self):
def test_deallocate_fixed(self):
def test_deallocate_fixed_no_vif(self):
def test_flatdhcpmanager_static_fixed_range(self):
def test_flatdhcpmanager_dynamic_fixed_range(self):
def test_vlanmanager_static_fixed_range(self):
def test_vlanmanager_dynamic_fixed_range(self):
def test_rpc_allocate(self):
def test_allocate_for_instance_ex1(self):
def test_allocate_for_instance_ex2(self):
def test_validate_networks_duplicate(self):
def _do_test_associate_floating_ip(self, orig_instance_uuid):
def test_linux_bridge_driver_plug(self):
def test_vlan_override(self):
def test_flat_override(self):
def _generate_name(self):
def _generate_flavorid(self):
def _existing_flavor(self):
def test_read_deleted_false_converting_flavorid(self):
def setUp(self):
def tearDown(self):
def instance_update(self, context, instance_uuid, **updates):
def wait_until_ready(self, context, early_timeout=10, early_attempts=10):
def instance_update(self, context, instance_uuid, **updates):
def __init__(self):
@staticmethod DCNL def run_server(server):
def launch_server(self, server):
def stop(self):
def wait(self):
def wait(self):
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_enable=None, periodic_fuzzy_delay=None, periodic_interval_max=None, db_allowed=True):
def kill(self):
def periodic_tasks(self, raise_on_error=False):
def basic_config_check(self):
def __init__(self, name, loader=None, use_ssl=False, max_url_len=None):
def _get_manager(self):
def start(self):
def stop(self):
def wait(self):
def format(self, record):
def formatException(self, exc_info, record=None):
def __init__(self, *args, **kwargs):
def get(self, key):
def set(self, key, value, time=0, min_compress_len=0):
def add(self, key, value, time=0, min_compress_len=0):
def incr(self, key, delta=1):
def delete(self, key, time=0):
def __init__(self, topic, default_version):
def _set_version(self, msg, vers):
def _get_topic(self, topic):
def call(self, context, msg, topic=None, version=None, timeout=None):
def multicall(self, context, msg, topic=None, version=None, timeout=None):
def cast(self, context, msg, topic=None, version=None):
def fanout_cast(self, context, msg, topic=None, version=None):
def cast_to_server(self, context, server_params, msg, topic=None, version=None):
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None):
def __init__(self, conf, connection_pool, pooled=True, server_params=None):
def __enter__(self):
def _done(self):
def __exit__(self, exc_type, exc_value, tb):
def __del__(self):
def close(self):
def __getattr__(self, key):
def check_duplicate_message(self, message_data):
def wait(self):
def __init__(self, conf, callback, connection_pool):
def __call__(self, message_data):
def _process_data(self, ctxt, version, method, args):
def __iter__(self):
def __call__(self, data):
def __iter__(self):
def __init__(self, callbacks):
def dispatch(self, ctxt, version, method, **kwargs):
def register(self, key, host):
def ack_alive(self, key, host):
def is_alive(self, topic, host):
def expire(self, topic, host):
def send_heartbeats(self):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def send_heartbeats(self):
def ack_alive(self, key, host):
def backend_register(self, key, host):
def backend_unregister(self, key, key_host):
def register(self, key, host):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts):
def reconnect(self, session):
def consume(self):
def __init__(self, conf, session, msg_id, callback):
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None):
def __init__(self, conf, session, topic, callback):
def __init__(self, session, node_name, node_opts=None):
def reconnect(self, session):
def send(self, msg):
def __init__(self, conf, session, msg_id):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def reconnect(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
def socket_s(self):
def subscribe(self, msg_filter):
def unsubscribe(self, msg_filter):
def _get_response(self, ctx, proxy, topic, data):
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None):
def consume_in_thread(self):
def close(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name):
def consume_in_thread(self):
def elevated(self, read_deleted=None, overwrite=False):
def __init__(self, channel, callback, tag, **kwargs):
def reconnect(self, channel):
def consume(self, *args, **kwargs):
def cancel(self):
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, **kwargs):
def __init__(self, channel, exchange_name, routing_key, **kwargs):
def reconnect(self, channel):
def send(self, msg, timeout=None):
def __init__(self, conf, channel, msg_id, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def _fetch_ssl_params(self):
def _connect(self, params):
def reconnect(self):
def get_channel(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
def _add_callback(self, callback, event_type, user_data=None):
def _remove_callback(self, callback):
def _add_api_extension_descriptor(self, descriptor):
def _add_notifier(self, notifier):
def _notifiers(self):
def _api_extension_descriptors(self):
def __init__(self, project_name, service_name):
def save(self, session=None):
def update(self, values):
def iteritems(self):
def soft_delete(self, session=None):
@lockutils.synchronized('dbapi_backend', 'nova-') DCNL def __get_backend(self):
@classmethod DCNL def load_json(cls, data, default_rule=None):
def __init__(self, rules=None, default_rule=None):
def __missing__(self, key):
def __str__(self):
@abc.abstractmethod DCNL def __str__(self):
@abc.abstractmethod DCNL def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, kind, match):
def __str__(self):
def __init__(self, rule):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __new__(mcs, name, bases, cls_dict):
def __init__(self):
def reduce(self):
def shift(self, tok, value):
@property DCNL def result(self):
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2):
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2):
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check):
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2):
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check):
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __init__(self, package):
def __str__(self):
def __repr__(self):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def get_exec(self, exec_dirs=[]):
def match(self, userargs):
def get_command(self, userargs, exec_dirs=[]):
def get_environment(self, userargs):
def _is_correct_class(self, obj):
def _get_classes_from_module(self, module_name):
def get_all_classes(self):
def get_matching_classes(self, loadable_class_names):
def __init__(cls, names, bases, dict_):
def create_rpc_dispatcher(self):
def periodic_tasks(self, context, raise_on_error=False):
def init_host(self):
def pre_start_hook(self, **kwargs):
def post_start_hook(self):
def update_service_capabilities(self, capabilities):
@periodic_task DCNL def publish_service_capabilities(self, context):
def _filter_one(self, obj, filter_properties):
def filter_all(self, filter_obj_list, filter_properties):
def join(self, member_id, group_id, service=None):
def is_up(self, service_ref):
def get_all(self, group_id):
def _report_state(self, service):
def join(self, member_id, group_id, service=None):
def is_up(self, service_ref):
def get_all(self, group_id):
def _report_state(self, service):
def __init__(self, *args, **kwargs):
def join(self, member_id, group, service=None):
def leave(self, member_id, group):
def get_all(self, group_id):
def __new__(cls, *args, **kwargs):
def join(self, member_id, group_id, service=None):
def service_is_up(self, member):
def leave(self, member_id, group_id):
def get_all(self, group_id):
def get_one(self, group_id):
def join(self, member_id, group_id, service=None):
def is_up(self, member):
def leave(self, member_id, group_id):
def get_all(self, group_id):
def get_one(self, group_id):
def create(self, context, metadata, data=None):
def _s3_create(self, context, metadata):
@staticmethod DCNL def _test_for_malicious_tarball(path, filename):
def _create_static_client(self, context, host, port, use_ssl, version):
def _create_onetime_client(self, context, version):
def call(self, context, version, method, *args, **kwargs):
def detail(self, context, **kwargs):
def show(self, context, image_id):
def get_location(self, context, image_id):
def download(self, context, image_id, data=None):
def create(self, context, image_meta, data=None):
def update(self, context, image_id, image_meta, data=None, purge_props=True):
def delete(self, context, image_id):
@staticmethod DCNL def _is_image_available(context, image):
def get_by_project(self, context, project_id, resource):
def get_by_class(self, context, quota_class, resource):
def get_defaults(self, context, resources):
def get_class_quotas(self, context, resources, quota_class, defaults=True):
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True):
def _get_quotas(self, context, resources, keys, has_sync, project_id=None):
def limit_check(self, context, resources, values, project_id=None):
def reserve(self, context, resources, deltas, expire=None, project_id=None):
def commit(self, context, reservations, project_id=None):
def rollback(self, context, reservations, project_id=None):
def usage_reset(self, context, resources):
def destroy_all_by_project(self, context, project_id):
def expire(self, context):
def get_by_project(self, context, project_id, resource):
def get_by_class(self, context, quota_class, resource):
def get_defaults(self, context, resources):
def get_class_quotas(self, context, resources, quota_class, defaults=True):
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True):
def limit_check(self, context, resources, values, project_id=None):
def reserve(self, context, resources, deltas, expire=None, project_id=None):
def commit(self, context, reservations, project_id=None):
def rollback(self, context, reservations, project_id=None):
def usage_reset(self, context, resources):
def destroy_all_by_project(self, context, project_id):
def expire(self, context):
def __init__(self, name, flag=None):
def quota(self, driver, context, **kwargs):
@property DCNL def default(self):
def __init__(self, name, sync, flag=None):
def __init__(self, name, count, flag=None):
def __init__(self, quota_driver_class=None):
def register_resource(self, resource):
def register_resources(self, resources):
def get_by_project(self, context, project_id, resource):
def get_by_class(self, context, quota_class, resource):
def get_defaults(self, context):
def get_class_quotas(self, context, quota_class, defaults=True):
def get_project_quotas(self, context, project_id, quota_class=None, defaults=True, usages=True):
def count(self, context, resource, *args, **kwargs):
def limit_check(self, context, project_id=None, **values):
def reserve(self, context, expire=None, project_id=None, **deltas):
def commit(self, context, reservations, project_id=None):
def rollback(self, context, reservations, project_id=None):
def usage_reset(self, context, resources):
def destroy_all_by_project(self, context, project_id):
def expire(self, context):
def __init__(self, name, app, host='0.0.0.0', port=0, pool_size=None, protocol=eventlet.wsgi.HttpProtocol, backlog=128, use_ssl=False, max_url_len=None):
def start(self):
def stop(self):
def wait(self):
@classmethod DCNL def factory(cls, global_config, **local_config):
def __call__(self, environ, start_response):
@classmethod DCNL def factory(cls, global_config, **local_config):
def process_request(self, req):
def process_response(self, response):
@staticmethod DCNL def print_generator(app_iter):
def __init__(self, mapper):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req):
def __init__(self, config_path=None):
def load_app(self, name):
def make_drive(self, path):
def init_host(self, host):
def get_info(self, instance):
def get_host_stats(self, refresh=False):
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info=None, block_device_info=None):
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True):
def reboot(self, context, instance, network_info, reboot_type, block_device_info=None, bad_volumes_callback=None):
def get_host_ip_addr(self):
def snapshot(self, context, instance, image_id, update_task_state):
def pause(self, instance):
def unpause(self, instance):
def suspend(self, instance):
def resume(self, instance, network_info, block_device_info=None):
def power_off(self, instance):
def power_on(self, instance):
def get_available_resource(self, nodename):
def host_power_action(self, host, action):
def legacy_nwinfo(self):
def manage_image_cache(self, context, all_instances):
def migrate_disk_and_power_off(self, context, instance, dest, instance_type, network_info, block_device_info=None):
def _get_resize_name(self, instance_name):
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance, block_device_info=None):
def confirm_migration(self, migration, instance, network_info):
def finish_revert_migration(self, instance, network_info, block_device_info=None):
def get_info(self, instance_name):
def _get_instance(self, instance_name):
def list_instances(self):
def get_available_resource(self):
def get_host_stats(self, refresh=False):
def destroy(self, instance_name, destroy_disks=True):
def capture_image(self, context, instance, image_id, image_meta, update_task_state):
def _check_host_resources(self, instance, vcpus, mem, host_stats):
def migrate_disk(self, device_name, src_host, dest, image_path, instance_name=None):
def __init__(self, connection):
def get_lpar(self, instance_name, resource_type='lpar'):
def list_lpar_instances(self):
def create_lpar(self, lpar):
def start_lpar(self, instance_name):
def stop_lpar(self, instance_name, timeout=30):
def remove_lpar(self, instance_name):
def get_vhost_by_instance_id(self, instance_id):
def get_virtual_eth_adapter_id(self):
def get_hostname(self):
def get_disk_name_by_vhost(self, vhost):
def attach_disk_to_vhost(self, disk, vhost):
def get_memory_info(self):
def get_cpu_info(self):
def get_disk_info(self):
def run_vios_command(self, cmd, check_exit_code=True):
def run_vios_command_as_root(self, command, check_exit_code=True):
def update_lpar(self, lpar_info):
def get_logical_vol_size(self, diskname):
def rename_lpar(self, instance_name, new_name):
def _remove_file(self, file_path):
def set_lpar_mac_base_value(self, instance_name, mac):
def macs_for_instance(self, instance):
def create_volume(self, size):
def delete_volume(self, volume_info):
def create_volume_from_image(self, context, instance, image_id):
def create_image_from_volume(self, device_name, context, image_id, image_meta, update_task_state):
def migrate_volume(self, lv_name, src_host, dest, image_path, instance_name=None):
def attach_volume_to_host(self, *args, **kargs):
def detach_volume_from_host(self, *args, **kargs):
def create_volume(self, size):
def delete_volume(self, volume_info):
def create_volume_from_image(self, context, instance, image_id):
def create_image_from_volume(self, device_name, context, image_id, image_meta, update_task_state):
def migrate_volume(self, lv_name, src_host, dest, image_path, instance_name=None):
def _create_logical_volume(self, size):
def _remove_logical_volume(self, lv_name):
def _copy_file_to_device(self, source_path, device, decompress=True):
def _copy_device_to_file(self, device_name, file_path):
def _copy_image_file(self, source_path, remote_path, decompress=False):
def _copy_image_file_from_host(self, remote_source_path, local_dest_dir, compress=False):
def run_vios_command(self, cmd, check_exit_code=True):
def run_vios_command_as_root(self, command, check_exit_code=True):
def _reset_state(self):
def _store_image(self, base_dir, ent, original=False):
def _list_base_images(self, base_dir):
def _list_running_instances(self, context, all_instances):
def _list_backing_images(self):
def _find_base_file(self, base_dir, fingerprint):
def _verify_checksum(self, img_id, base_file, create_if_missing=True):
def _remove_base_file(self, base_file):
def _handle_base_image(self, img_id, base_file):
def verify_base_images(self, context, all_instances):
def set_cache_mode(self, conf):
def _native_thread(self):
def _dispatch_thread(self):
@staticmethod DCNL def _event_lifecycle_callback(conn, dom, event, detail, opaque):
def _queue_event(self, event):
def _dispatch_events(self):
def _init_events_pipe(self):
def _init_events(self):
def get_num_instances(self):
def instance_exists(self, instance_name):
def plug_vifs(self, instance, network_info):
def unplug_vifs(self, instance, network_info):
def _cleanup_lvm(self, instance):
def _lvm_disks(self, instance):
@staticmethod DCNL def _get_disk_xml(xml, device):
def snapshot(self, context, instance, image_href, update_task_state):
def _live_snapshot(self, domain, disk_path, out_path, image_format):
def reboot(self, context, instance, network_info, reboot_type='SOFT', block_device_info=None, bad_volumes_callback=None):
def _soft_reboot(self, instance):
def _hard_reboot(self, context, instance, network_info, block_device_info=None):
def pause(self, instance):
def unpause(self, instance):
def power_off(self, instance):
def power_on(self, instance):
def suspend(self, instance):
def resume(self, instance, network_info, block_device_info=None):
def resume_state_on_host_boot(self, context, instance, network_info, block_device_info=None):
def rescue(self, context, instance, network_info, image_meta, rescue_password):
def unrescue(self, instance, network_info):
@staticmethod DCNL def _create_local(target, local_size, unit='G', fs_format=None, label=None):
@staticmethod DCNL def _create_swap(target, swap_mb):
def get_host_capabilities(self):
def get_host_uuid(self):
def get_host_cpu_for_guest(self):
def get_guest_config(self, instance, network_info, image_meta, disk_info, rescue=None, block_device_info=None):
def _lookup_by_name(self, instance_name):
def get_info(self, instance):
def _create_domain(self, xml=None, domain=None, instance=None, launch_flags=0):
def _create_domain_and_network(self, xml, instance, network_info, block_device_info=None):
def get_all_block_devices(self):
def get_disks(self, instance_name):
def get_interfaces(self, xml):
def get_vcpu_total(self):
def get_memory_mb_total(self):
@staticmethod DCNL def get_local_gb_info():
def get_vcpu_used(self):
def get_memory_mb_used(self):
def get_hypervisor_type(self):
def get_hypervisor_version(self):
def get_hypervisor_hostname(self):
def get_instance_capabilities(self):
def get_cpu_info(self):
def get_all_volume_usage(self, context, compute_host_bdms):
def block_stats(self, instance_name, disk):
def interface_stats(self, instance_name, interface):
def get_available_resource(self, nodename):
def check_can_live_migrate_destination(self, ctxt, instance_ref, src_compute_info, dst_compute_info, block_migration=False, disk_over_commit=False):
def check_can_live_migrate_destination_cleanup(self, ctxt, dest_check_data):
def check_can_live_migrate_source(self, ctxt, instance_ref, dest_check_data):
def _assert_dest_node_has_enough_disk(self, context, instance_ref, available_mb, disk_over_commit):
def _compare_cpu(self, cpu_info):
def _create_shared_storage_test_file(self):
def _check_shared_storage_test_file(self, filename):
def _cleanup_shared_storage_test_file(self, filename):
def ensure_filtering_rules_for_instance(self, instance_ref, network_info, time_module=None):
def live_migration(self, ctxt, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None):
def _live_migration(self, ctxt, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None):
def _fetch_instance_kernel_ramdisk(self, context, instance):
def pre_live_migration(self, context, instance, block_device_info, network_info, migrate_data=None):
def pre_block_migration(self, ctxt, instance, disk_info_json):
def _create_images_and_backing(self, ctxt, instance, disk_info_json):
def post_live_migration_at_destination(self, ctxt, instance_ref, network_info, block_migration, block_device_info=None):
def get_instance_disk_info(self, instance_name, xml=None):
def get_disk_over_committed_size_total(self):
def unfilter_instance(self, instance_ref, network_info):
def get_host_stats(self, refresh=False):
def get_host_uptime(self, host):
def manage_image_cache(self, context, all_instances):
def _cleanup_remote_migration(self, dest, inst_base, inst_base_resize):
def _cleanup_failed_migration(self, inst_base):
def confirm_migration(self, migration, instance, network_info):
def add_to_aggregate(self, context, aggregate, host, **kwargs):
def remove_from_aggregate(self, context, aggregate, host, **kwargs):
def undo_aggregate_operation(self, context, op, aggregate, host, set_error=True):
def get_host_stats(self, refresh=False):
def update_status(self):
def get_config_bridge(self, instance, network, mapping, image_meta):
def plug_bridge(self, instance, vif):
def plug_ovs_bridge(self, instance, vif):
def plug_ovs_hybrid(self, instance, vif):
def unplug_bridge(self, instance, vif):
def unplug_ovs_ethernet(self, instance, vif):
def unplug_ovs_bridge(self, instance, vif):
def unplug_ovs_hybrid(self, instance, vif):
def connect_volume(self, connection_info, disk_info):
def disconnect_volume(self, connection_info, disk_dev):
def connect_volume(self, connection_info, disk_info):
def connect_volume(self, connection_info, disk_info):
@lockutils.synchronized('connect_volume', 'nova-') DCNL def connect_volume(self, connection_info, disk_info):
@lockutils.synchronized('connect_volume', 'nova-') DCNL def disconnect_volume(self, connection_info, disk_dev):
def __init__(self, connection):
def connect_volume(self, connection_info, disk_info):
def _ensure_mounted(self, nfs_export):
def _mount_nfs(self, mount_path, nfs_share, ensure=False):
@staticmethod DCNL def get_hash_str(base_str):
@staticmethod DCNL def _path_exists(path):
def _aoe_discover(self):
def _aoe_revalidate(self, aoedev):
def __init__(self, connection):
def connect_volume(self, connection_info, mount_device):
def _ensure_mounted(self, glusterfs_export):
def _mount_glusterfs(self, mount_path, glusterfs_share, ensure=False):
@staticmethod DCNL def get_hash_str(base_str):
@staticmethod DCNL def _path_exists(path):
@lockutils.synchronized('connect_volume', 'nova-') DCNL def connect_volume(self, connection_info, disk_info):
@lockutils.synchronized('connect_volume', 'nova-') DCNL def disconnect_volume(self, connection_info, mount_device):
def __init__(self, connection):
def connect_volume(self, connection_info, disk_info):
def _check_prerequisites(self):
def apply_instance_filter(self, instance, network_info):
@staticmethod DCNL def nova_no_nd_reflection_filter():
@staticmethod DCNL def nova_dhcp_filter():
def setup_basic_filtering(self, instance, network_info):
def get_base_filter_list(self, instance, allow_dhcp):
def _ensure_static_filters(self):
def unfilter_instance(self, instance, network_info):
def instance_filter_exists(self, instance, network_info):
def setup_basic_filtering(self, instance, network_info):
def apply_instance_filter(self, instance, network_info):
def instance_filter_exists(self, instance, network_info):
def __init__(self, source_type, driver_format, is_block_dev=False):
@abc.abstractmethod DCNL def create_image(self, prepare_template, base, size, *args, **kwargs):
def libvirt_info(self, disk_bus, disk_dev, device_type, cache_mode, extra_specs):
def cache(self, fetch_func, filename, size=None, *args, **kwargs):
def _can_fallocate(self):
def image(self, instance, disk_name, image_type=None):
def snapshot(self, disk_path, snapshot_name, image_type=None):
def _detect_nbd_devices(self):
def get_dev(self):
def reset_dev(self):
def get_dev(self):
def _get_dev_retry_helper(self):
def unget_dev(self):
def map_dev(self):
def unmap_dev(self):
def mnt_dev(self):
def unmnt_dev(self):
def do_mount(self):
def do_umount(self):
def do_teardown(self):
def _reset(self, device):
@property DCNL def errors(self):
def mount(self):
def umount(self):
def teardown(self):
def init_host(self, host):
def get_info(self, instance):
def get_num_instances(self):
def instance_exists(self, instance_id):
def list_instances(self):
def list_instance_uuids(self):
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info=None, block_device_info=None):
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True):
def reboot(self, context, instance, network_info, reboot_type, block_device_info=None, bad_volumes_callback=None):
def get_diagnostics(self, instance):
def get_all_bw_counters(self, instances):
def get_all_volume_usage(self, context, compute_host_bdms):
def get_host_ip_addr(self):
def attach_volume(self, connection_info, instance, mountpoint):
def detach_volume(self, connection_info, instance, mountpoint):
def attach_interface(self, instance, image_meta, network_info):
def detach_interface(self, instance, network_info):
def migrate_disk_and_power_off(self, context, instance, dest, instance_type, network_info, block_device_info=None):
def snapshot(self, context, instance, image_id, update_task_state):
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance, block_device_info=None):
def confirm_migration(self, migration, instance, network_info):
def finish_revert_migration(self, instance, network_info, block_device_info=None):
def pause(self, instance):
def unpause(self, instance):
def suspend(self, instance):
def resume(self, instance, network_info, block_device_info=None):
def resume_state_on_host_boot(self, context, instance, network_info, block_device_info=None):
def rescue(self, context, instance, network_info, image_meta, rescue_password):
def unrescue(self, instance, network_info):
def power_off(self, instance):
def power_on(self, instance):
def soft_delete(self, instance):
def restore(self, instance):
def get_available_resource(self, nodename):
def pre_live_migration(self, ctxt, instance_ref, block_device_info, network_info, migrate_data=None):
def pre_block_migration(self, ctxt, instance_ref, disk_info):
def live_migration(self, ctxt, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None):
def post_live_migration_at_destination(self, ctxt, instance_ref, network_info, block_migration=False, block_device_info=None):
def check_can_live_migrate_destination(self, ctxt, instance_ref, src_compute_info, dst_compute_info, block_migration=False, disk_over_commit=False):
def check_can_live_migrate_destination_cleanup(self, ctxt, dest_check_data):
def check_can_live_migrate_source(self, ctxt, instance_ref, dest_check_data):
def refresh_security_group_rules(self, security_group_id):
def refresh_security_group_members(self, security_group_id):
def refresh_provider_fw_rules(self):
def reset_network(self, instance):
def ensure_filtering_rules_for_instance(self, instance_ref, network_info):
def filter_defer_apply_on(self):
def filter_defer_apply_off(self):
def unfilter_instance(self, instance, network_info):
def set_admin_password(self, context, instance_id, new_pass=None):
def inject_file(self, instance, b64_path, b64_contents):
def change_instance_metadata(self, context, instance, diff):
def inject_network_info(self, instance, nw_info):
def poll_rebooting_instances(self, timeout, instances):
def host_power_action(self, host, action):
def host_maintenance_mode(self, host, mode):
def set_host_enabled(self, host, enabled):
def get_host_uptime(self, host):
def plug_vifs(self, instance, network_info):
def unplug_vifs(self, instance, network_info):
def get_host_stats(self, refresh=False):
def block_stats(self, instance_name, disk_id):
def interface_stats(self, instance_name, iface_id):
def legacy_nwinfo(self):
def macs_for_instance(self, instance):
def manage_image_cache(self, context, all_instances):
def add_to_aggregate(self, context, aggregate, host, **kwargs):
def remove_from_aggregate(self, context, aggregate, host, **kwargs):
def undo_aggregate_operation(self, context, op, aggregate, host, set_error=True):
def get_volume_connector(self, instance):
def get_available_nodes(self):
def get_per_instance_usage(self):
def instance_on_disk(self, instance):
def register_event_listener(self, callback):
def emit_event(self, event):
def activate_node(self, context, node, instance):
def deactivate_node(self, context, node, instance):
def is_power_on(self):
def _require_node(self, instance):
def power_off(self, instance, node=None):
def power_on(self, instance, node=None):
def plug_vifs(self, instance, network_info):
def manage_image_cache(self, context, all_instances):
def _run_command(self, cmd, check_exit_code=True):
def get_all_block_devices(self):
def _power_on(self):
def _power_off(self):
def activate_node(self):
def reboot_node(self):
def deactivate_node(self):
def _cache_tftp_images(self, context, instance, image_info):
def _cache_image(self, context, instance, image_meta):
def _inject_into_image(self, context, node, instance, network_info, injected_files=None, admin_password=None):
def cache_images(self, context, node, instance, admin_password, image_meta, injected_files, network_info):
def destroy_images(self, context, node, instance):
def activate_bootloader(self, context, node, instance):
def deactivate_bootloader(self, context, node, instance):
def activate_node(self, context, node, instance):
def activate_node(self, context, node, instance):
def deactivate_node(self, context, node, instance):
def init_host(self, host):
def list_instances(self):
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info=None, block_device_info=None):
def snapshot(self, context, instance, name, update_task_state):
def reboot(self, context, instance, network_info, reboot_type, block_device_info=None, bad_volumes_callback=None):
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True):
def pause(self, instance):
def unpause(self, instance):
def suspend(self, instance):
def resume(self, instance, network_info, block_device_info=None):
def rescue(self, context, instance, network_info, image_meta, rescue_password):
def unrescue(self, instance, network_info):
def power_off(self, instance):
def power_on(self, instance):
def poll_rebooting_instances(self, timeout, instances):
def get_info(self, instance):
def get_diagnostics(self, instance):
def get_console_output(self, instance):
def get_vnc_console(self, instance):
def get_volume_connector(self, instance):
def get_host_ip_addr(self):
def attach_volume(self, connection_info, instance, mountpoint):
def detach_volume(self, connection_info, instance, mountpoint):
def get_console_pool_info(self, console_type):
def get_available_resource(self, nodename):
def update_host_status(self):
def get_host_stats(self, refresh=False):
def host_power_action(self, host, action):
def host_maintenance_mode(self, host, mode):
def set_host_enabled(self, host, enabled):
def inject_network_info(self, instance, network_info):
def plug_vifs(self, instance, network_info):
def unplug_vifs(self, instance, network_info):
def list_interfaces(self, instance_name):
def migrate_disk_and_power_off(self, context, instance, dest, instance_type, network_info, block_device_info=None):
def confirm_migration(self, migration, instance, network_info):
def finish_revert_migration(self, instance, network_info, block_device_info=None):
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance=False, block_device_info=None):
def live_migration(self, context, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None):
def _get_vim_object(self):
def _create_session(self):
def __del__(self):
def _is_vim_object(self, module):
def _call_method(self, module, method, *args, **kwargs):
def _get_vim(self):
def _wait_for_task(self, instance_uuid, task_ref):
def _poll_task(self, instance_uuid, task_ref, done):
def __init__(self, session, virtapi, volumeops, cluster_name=None):
def list_instances(self):
def spawn(self, context, instance, image_meta, network_info, block_device_info=None):
def snapshot(self, context, instance, snapshot_name, update_task_state):
def reboot(self, instance, network_info):
def _delete(self, instance, network_info):
def destroy(self, instance, network_info, destroy_disks=True):
def suspend(self, instance):
def resume(self, instance):
def rescue(self, context, instance, network_info, image_meta):
def unrescue(self, instance):
def power_off(self, instance):
def power_on(self, instance):
def _update_instance_progress(self, context, instance, step, total_steps):
def migrate_disk_and_power_off(self, context, instance, dest, instance_type):
def confirm_migration(self, migration, instance, network_info):
def finish_revert_migration(self, instance):
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance=False):
def live_migration(self, context, instance_ref, dest, post_method, recover_method, block_migration=False):
def poll_rebooting_instances(self, timeout, instances):
def get_info(self, instance):
def get_diagnostics(self, instance):
def get_console_output(self, instance):
def get_vnc_console(self, instance):
@staticmethod DCNL def _get_vnc_port(vm_ref):
def _set_machine_id(self, client_factory, instance, network_info):
def _set_vnc_config(self, client_factory, instance, port, password):
def _get_datacenter_ref_and_name(self):
def _get_host_ref_from_name(self, host_name):
def _get_vmfolder_ref(self):
def _path_exists(self, ds_browser, ds_path):
def _path_file_exists(self, ds_browser, ds_path, file_name):
def _mkdir(self, ds_path):
def inject_network_info(self, instance, network_info):
def plug_vifs(self, instance, network_info):
def unplug_vifs(self, instance, network_info):
def list_interfaces(self, instance_name):
def read(self, chunk_size):
def write(self, data):
def seek(self, offset, whence=0):
def tell(self):
def close(self):
def __init__(self, protocol='https', host='localhost'):
def get_service_content(self):
def __getattr__(self, attr_name):
def _request_managed_object_builder(self, managed_object):
def read(self, chunk_size):
def get_next(self):
def close(self):
def set_eof(self, eof):
def get_eof(self):
def close(self):
def __del__(self):
def _build_vim_cookie_headers(self, vim_cookies):
def write(self, data):
def read(self, chunk_size):
def get_size(self):
def write(self, data):
def close(self):
def read(self, chunk_size):
def get_size(self):
@staticmethod DCNL def retrieveproperties_fault_checker(resp_obj):
def host_power_action(self, host, action):
def host_maintenance_mode(self, host, mode):
def set_host_enabled(self, _host, enabled):
def get_host_stats(self, refresh=False):
def update_status(self):
def get_host_stats(self, refresh=False):
def update_status(self):
def attach_disk_to_vm(self, vm_ref, instance_name, adapter_type, disk_type, vmdk_path=None, disk_size=None, linked_clone=False, controller_key=None, unit_number=None, device_name=None):
def detach_disk_from_vm(self, vm_ref, instance_name, device):
def discover_st(self, data):
def get_volume_connector(self, instance):
def attach_volume(self, connection_info, instance, mountpoint):
def detach_volume(self, connection_info, instance, mountpoint):
def __init__(self, name='ManagedObject', obj_ref=None):
def set(self, attr, val):
def get(self, attr):
def reconfig(self, factory, val):
def _add_port_group(self, spec):
def create(self, obj_name):
def __init__(self, protocol='https', host='localhost', trace=None):
def _login(self):
def _logout(self):
def _terminate_session(self, *args, **kwargs):
def _check_session(self):
def _create_vm(self, method, *args, **kwargs):
def _reconfig_vm(self, method, *args, **kwargs):
def _create_copy_disk(self, method, vmdk_file_path):
def _snapshot_vm(self, method):
def _delete_disk(self, method, *args, **kwargs):
def _delete_file(self, method, *args, **kwargs):
def _just_return(self):
def _just_return_task(self, method):
def _unregister_vm(self, method, *args, **kwargs):
def _search_ds(self, method, *args, **kwargs):
def _make_dir(self, method, *args, **kwargs):
def _set_power_state(self, method, vm_ref, pwr_state='poweredOn'):
def _retrieve_properties(self, method, *args, **kwargs):
def _add_port_group(self, method, *args, **kwargs):
def instance_update(self, context, instance_uuid, updates):
def instance_get_by_uuid(self, context, instance_uuid):
def instance_get_all_by_host(self, context, host):
def aggregate_get_by_host(self, context, host, key=None):
def aggregate_metadata_add(self, context, aggregate, metadata, set_delete=False):
def aggregate_metadata_delete(self, context, aggregate, key):
def security_group_get_by_instance(self, context, instance):
def security_group_rule_get_by_security_group(self, context, security_group):
def provider_fw_rule_get_all(self, context):
def agent_build_get_by_triple(self, context, hypervisor, os, architecture):
def instance_type_get(self, context, instance_type_id):
def prepare_instance_filter(self, instance, network_info):
def filter_defer_apply_on(self):
def filter_defer_apply_off(self):
def unfilter_instance(self, instance, network_info):
def apply_instance_filter(self, instance, network_info):
def refresh_security_group_rules(self, security_group_id):
def refresh_security_group_members(self, security_group_id):
def refresh_instance_security_rules(self, instance):
def refresh_provider_fw_rules(self):
def setup_basic_filtering(self, instance, network_info):
def instance_filter_exists(self, instance, network_info):
def apply_instance_filter(self, instance, network_info):
def _filters_for_instance(self, chain_name, network_info):
def refresh_provider_fw_rules(self):
@lockutils.synchronized('iptables', 'nova-', external=True) DCNL def _do_refresh_provider_fw_rules(self):
def _purge_provider_fw_rules(self):
def _build_provider_fw_rules(self):
def _provider_rules(self):
def _get_cpu_info(self):
def _get_hypervisor_version(self):
def get_available_resource(self):
def get_host_stats(self, refresh=False):
def host_power_action(self, host, action):
def get_info(self, instance):
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info, block_device_info=None):
def reboot(self, instance, network_info, reboot_type):
def pause(self, instance):
def unpause(self, instance):
def suspend(self, instance):
def resume(self, instance):
def power_off(self, instance):
def power_on(self, instance):
def get_memory_info(self):
def get_volume_info(self, drive):
def login_storage_target(self, target_lun, target_iqn, target_portal):
def logout_storage_target(self, target_iqn):
def snapshot(self, context, instance, name, update_task_state):
def open(self, path, mode):
def list_instances(self):
def create_vm(self, vm_name, memory_mb, vcpus_num, limit_cpu_features):
def attach_ide_drive(self, vm_name, path, ctrller_addr, drive_addr, drive_type=constants.IDE_DISK):
def create_scsi_controller(self, vm_name):
def attach_volume_to_controller(self, vm_name, controller_path, address, mounted_disk_path):
def create_nic(self, vm_name, nic_name, mac_address):
def set_vm_state(self, vm_name, req_state):
def _wait_for_job(self, job_path):
def _clone_wmi_obj(self, wmi_class, wmi_obj):
def _add_virt_resource(self, res_setting_data, vm_path):
def _modify_virt_resource(self, res_setting_data, vm_path):
def _remove_virt_resource(self, res_setting_data, vm_path):
def attach_volume(self, connection_info, instance_name, ebs_root=False):
def detach_volume(self, connection_info, instance_name):
def get_iscsi_initiator(self):
def login_storage_target(self, target_lun, target_iqn, target_portal):
def logout_storage_target(self, target_iqn):
def execute_log_out(self, session_id):
def list_instances(self):
def list_instance_uuids(self):
def spawn(self, context, instance, image_meta, injected_files, admin_password, network_info=None, block_device_info=None):
def confirm_migration(self, migration, instance, network_info):
def finish_revert_migration(self, instance, network_info, block_device_info=None):
def finish_migration(self, context, migration, instance, disk_info, network_info, image_meta, resize_instance=False, block_device_info=None):
def snapshot(self, context, instance, image_id, update_task_state):
def reboot(self, context, instance, network_info, reboot_type, block_device_info=None, bad_volumes_callback=None):
def set_admin_password(self, instance, new_pass):
def inject_file(self, instance, b64_path, b64_contents):
def change_instance_metadata(self, context, instance, diff):
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True):
def pause(self, instance):
def unpause(self, instance):
def migrate_disk_and_power_off(self, context, instance, dest, instance_type, network_info, block_device_info=None):
def suspend(self, instance):
def resume(self, instance, network_info, block_device_info=None):
def rescue(self, context, instance, network_info, image_meta, rescue_password):
def unrescue(self, instance, network_info):
def power_off(self, instance):
def power_on(self, instance):
def soft_delete(self, instance):
def restore(self, instance):
def poll_rebooting_instances(self, timeout, instances):
def reset_network(self, instance):
def inject_network_info(self, instance, network_info):
def plug_vifs(self, instance_ref, network_info):
def unplug_vifs(self, instance_ref, network_info):
def get_info(self, instance):
def get_diagnostics(self, instance):
def get_all_bw_counters(self, instances):
def get_console_output(self, instance):
def get_vnc_console(self, instance):
def get_volume_connector(self, instance):
def attach_volume(self, connection_info, instance, mountpoint):
def detach_volume(self, connection_info, instance, mountpoint):
def get_available_resource(self, nodename):
def check_can_live_migrate_destination(self, ctxt, instance_ref, src_compute_info, dst_compute_info, block_migration=False, disk_over_commit=False):
def check_can_live_migrate_destination_cleanup(self, ctxt, dest_check_data):
def check_can_live_migrate_source(self, ctxt, instance_ref, dest_check_data):
def get_instance_disk_info(self, instance_name):
def pre_block_migration(self, ctxt, instance_ref, disk_info_json):
def live_migration(self, ctxt, instance_ref, dest, post_method, recover_method, block_migration=False, migrate_data=None):
def pre_live_migration(self, context, instance_ref, block_device_info, network_info, migrate_data=None):
def post_live_migration_at_destination(self, ctxt, instance_ref, network_info, block_migration, block_device_info=None):
def unfilter_instance(self, instance_ref, network_info):
def refresh_security_group_rules(self, security_group_id):
def refresh_security_group_members(self, security_group_id):
def refresh_instance_security_rules(self, instance):
def get_host_stats(self, refresh=False):
def host_power_action(self, host, action):
def set_host_enabled(self, host, enabled):
def get_host_uptime(self, host):
def host_maintenance_mode(self, host, mode):
def add_to_aggregate(self, context, aggregate, host, **kwargs):
def remove_from_aggregate(self, context, aggregate, host, **kwargs):
def undo_aggregate_operation(self, context, op, aggregate, host, set_error=True):
def legacy_nwinfo(self):
def resume_state_on_host_boot(self, context, instance, network_info, block_device_info=None):
def get_per_instance_usage(self):
def _get_product_version_and_brand(self):
def get_session_id(self):
@contextlib.contextmanager DCNL def _get_session(self):
def get_xenapi_host(self):
def call_xenapi(self, method, *args):
def call_plugin(self, plugin, fn, args):
def _create_session(self, url):
def _unwrap_plugin_exceptions(self, func, *args, **kwargs):
def get_all_refs_and_recs(self, record_type):
def list_instances(self):
def list_instance_uuids(self):
def _start(self, instance, vm_ref=None, bad_volumes_callback=None):
def _create_vm(self, context, instance, name_label, vdis, disk_image_type, network_info, kernel_file=None, ramdisk_file=None, rescue=False):
def _create_vm_record(self, context, instance, name_label, vdis, disk_image_type, kernel_file, ramdisk_file):
def _boot_new_instance(self, instance, vm_ref, injected_files, admin_password):
def _get_vm_opaque_ref(self, instance):
def _acquire_bootlock(self, vm):
def _release_bootlock(self, vm):
def snapshot(self, context, instance, image_id, update_task_state):
def _update_instance_progress(self, context, instance, step, total_steps):
def migrate_disk_and_power_off(self, context, instance, dest, instance_type):
def _resize_instance(self, instance, root_vdi):
def check_resize_func_name(self):
def reboot(self, instance, reboot_type, bad_volumes_callback=None):
def set_admin_password(self, instance, new_pass):
def inject_file(self, instance, path, contents):
@staticmethod DCNL def _sanitize_xenstore_key(key):
def inject_instance_metadata(self, instance, vm_ref):
def change_instance_metadata(self, instance, diff):
def _find_root_vdi_ref(self, vm_ref):
def _destroy_vdis(self, instance, vm_ref):
def _destroy_kernel_ramdisk(self, instance, vm_ref):
def _destroy_rescue_instance(self, rescue_vm_ref, original_vm_ref):
def destroy(self, instance, network_info, block_device_info=None, destroy_disks=True):
def _destroy(self, instance, vm_ref, network_info=None, destroy_disks=True):
def pause(self, instance):
def unpause(self, instance):
def suspend(self, instance):
def resume(self, instance):
def rescue(self, context, instance, network_info, image_meta, rescue_password):
def unrescue(self, instance):
def soft_delete(self, instance):
def restore(self, instance):
def power_off(self, instance):
def power_on(self, instance):
def _cancel_stale_tasks(self, timeout, task):
def poll_rebooting_instances(self, timeout, instances):
def get_info(self, instance, vm_ref=None):
def get_diagnostics(self, instance):
def get_all_bw_counters(self):
def get_console_output(self, instance):
def get_vnc_console(self, instance):
def _vif_xenstore_data(self, vif):
def inject_network_info(self, instance, network_info, vm_ref=None):
def _create_vifs(self, vm_ref, instance, network_info):
def plug_vifs(self, instance, network_info):
def reset_network(self, instance):
def inject_hostname(self, instance, vm_ref, hostname):
def _write_to_xenstore(self, instance, path, value, vm_ref=None):
def _delete_from_xenstore(self, instance, path, vm_ref=None):
def _make_plugin_call(self, plugin, method, instance, vm_ref=None, **addl_args):
def _add_to_param_xenstore(self, vm_ref, key, val):
def _remove_from_param_xenstore(self, vm_ref, key):
def refresh_security_group_rules(self, security_group_id):
def refresh_security_group_members(self, security_group_id):
def refresh_instance_security_rules(self, instance):
def unfilter_instance(self, instance_ref, network_info):
def check_can_live_migrate_destination(self, ctxt, instance_ref, block_migration=False, disk_over_commit=False):
def check_can_live_migrate_source(self, ctxt, instance_ref, dest_check_data):
def _generate_vdi_map(self, destination_sr_ref, vm_ref):
def _call_live_migrate_command(self, command_name, vm_ref, migrate_data):
def get_per_instance_usage(self):
def upload_image(self, context, session, instance, vdi_uuids, image_id):
@classmethod DCNL def get_role(cls, image_type_id):
def get_agent_version(self):
def agent_update(self, agent_build):
def set_admin_password(self, new_pass):
@staticmethod DCNL def mod_exp(num, exp, mod):
def _ensure_vlan_bridge(self, network):
def undo_aggregate_operation(self, context, op, aggregate, host, set_error):
def add_to_aggregate(self, context, aggregate, host, slave_info=None):
def remove_from_aggregate(self, context, aggregate, host, slave_info=None):
def _join_slave(self, aggregate_id, host, compute_uuid, url, user, passwd):
def _eject_slave(self, aggregate_id, compute_uuid, host_uuid):
def _init_pool(self, aggregate_id, aggregate_name):
def _clear_pool(self, aggregate_id):
def _create_slave_info(self):
def host_power_action(self, _host, action):
def host_maintenance_mode(self, host, mode):
def set_host_enabled(self, _host, enabled):
def get_host_uptime(self, _host):
def get_host_stats(self, refresh=False):
def update_status(self):
def _provider_rules(self):
def attach_volume(self, connection_info, instance_name, mountpoint, hotplug=True):
def detach_volume(self, connection_info, instance_name, mountpoint):
def _get_all_volume_vbd_refs(self, vm_ref):
def detach_all(self, vm_ref):
def find_bad_volumes(self, vm_ref):
def plug_vifs(self, instance, network_info):
def unplug_vifs(self, instance, network_info):
def attach_volume(self, connection_info, instance, mountpoint):
def detach_volume(self, connection_info, instance, mountpoint):
def get_all_bw_counters(self, instances):
def get_all_volume_usage(self, context, instances, start_time, stop_time=None):
def get_available_resource(self, nodename):
def ensure_filtering_rules_for_instance(self, instance_ref, network_info):
def unfilter_instance(self, instance_ref, network_info):
def test_remove_vm(self, instance_name):
def get_host_stats(self, refresh=False):
def host_power_action(self, host, action):
def host_maintenance_mode(self, host, mode):
def set_host_enabled(self, host, enabled):
def _filter_hosts(self, request_spec, hosts, filter_properties):
def _schedule(self, context, topic, request_spec, filter_properties):
def select_hosts(self, context, request_spec, filter_properties):
def schedule_run_instance(self, context, request_spec, admin_password, injected_files, requested_networks, is_first_time, filter_properties):
def schedule_prep_resize(self, context, image, request_spec, filter_properties, instance, instance_type, reservations):
def update_service_capabilities(self, service_name, host, capabilities):
def hosts_up(self, context, topic):
def group_hosts(self, context, group):
def schedule_prep_resize(self, context, image, request_spec, filter_properties, instance, instance_type, reservations):
def schedule_run_instance(self, context, request_spec, admin_password, injected_files, requested_networks, is_first_time, filter_properties):
def select_hosts(self, context, request_spec, filter_properties):
def schedule_live_migration(self, context, instance, dest, block_migration, disk_over_commit):
def _live_migration_src_check(self, context, instance_ref):
def _live_migration_dest_check(self, context, instance_ref, dest, ignore_hosts=None):
def _live_migration_common_check(self, context, instance_ref, dest):
def _assert_compute_node_has_enough_memory(self, context, instance_ref, dest):
def _get_compute_info(self, context, host):
def update_from_compute_node(self, compute):
def consume_from_instance(self, instance):
def _choose_host_filters(self, filter_cls_names):
def get_filtered_hosts(self, hosts, filter_properties, filter_class_names=None):
def get_weighed_hosts(self, hosts, weight_properties):
def update_service_capabilities(self, service_name, host, capabilities):
def get_all_host_states(self, context):
def post_start_hook(self):
def update_service_capabilities(self, context, service_name, host, capabilities):
def run_instance(self, context, request_spec, admin_password, injected_files, requested_networks, is_first_time, filter_properties):
def prep_resize(self, context, image, request_spec, filter_properties, instance, instance_type, reservations):
def _set_vm_state_and_notify(self, method, updates, context, ex, request_spec):
def show_host_resources(self, context, host):
def select_hosts(self, context, request_spec, filter_properties):
def update_from_compute_node(self, compute):
def schedule_run_instance(self, context, request_spec, admin_password, injected_files, requested_networks, is_first_time, filter_properties):
def schedule_prep_resize(self, context, image, request_spec, filter_properties, instance, instance_type, reservations):
def select_hosts(self, context, request_spec, filter_properties):
def _provision_resource(self, context, weighed_host, request_spec, filter_properties, requested_networks, injected_files, admin_password, is_first_time, instance_uuid=None):
def _post_select_populate_filter_properties(self, filter_properties, host_state):
def _add_retry_host(self, filter_properties, host, node):
def _get_configuration_options(self):
def populate_filter_properties(self, request_spec, filter_properties):
def _log_compute_error(self, instance_uuid, retry):
def _populate_retry(self, filter_properties, instance_properties):
def _schedule(self, context, request_spec, filter_properties, instance_uuids=None):
def _assert_compute_node_has_enough_memory(self, context, instance_ref, dest):
def _get_file_handle(self, filename):
def _get_file_timestamp(self, filename):
def _load_file(self, handle):
def _get_time_now(self):
def get_configuration(self, filename=None):
def _weight_multiplier(self):
def _weigh_object(self, host_state, weight_properties):
def host_passes(self, host_state, filter_properties):
def host_passes(self, host_state, filter_properties):
def host_passes(self, host_state, filter_properties):
def _filter_one(self, obj, filter_properties):
def host_passes(self, host_state, filter_properties):
def host_passes(self, host_state, filter_properties):
def host_passes(self, host_state, filter_properties):
def _satisfies_extra_specs(self, capabilities, instance_type):
def host_passes(self, host_state, filter_properties):
def host_passes(self, host_state, filter_properties):
def host_passes(self, host_state, filter_properties):
def host_passes(self, host_state, filter_properties):
def connect(self):
def do_attestation(self, hosts):
def get_host_attestation(self, host):
def host_passes(self, host_state, filter_properties):
def _op_compare(self, args, op):
def _equals(self, args):
def _less_than(self, args):
def _greater_than(self, args):
def _in(self, args):
def _less_than_equal(self, args):
def _greater_than_equal(self, args):
def _not(self, args):
def _or(self, args):
def _and(self, args):
def _parse_string(self, string, host_state):
def _process_filter(self, query, host_state):
def host_passes(self, host_state, filter_properties):
def host_passes(self, host_state, filter_properties):
def _weight_multiplier(self):
def _weigh_object(self, obj, weight_properties):
def weigh_objects(self, weighed_obj_list, weight_properties):
def get_weighed_objects(self, weigher_classes, obj_list, weighing_properties):
def __init__(self, user_id, project_id, is_admin=None, read_deleted='no', roles=None, remote_address=None, timestamp=None, request_id=None, auth_token=None, overwrite=True, quota_class=None, user_name=None, project_name=None, service_catalog=None, instance_lock_checked=False, **kwargs):
def elevated(self, read_deleted=None, overwrite=False):
def _reraise_translated_volume_exception(self, volume_id=None):
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def instance_claim(self, context, instance_ref, limits=None):
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def resize_claim(self, context, instance_ref, instance_type, limits=None):
def _create_migration(self, context, instance, instance_type):
def _set_instance_host_and_node(self, context, instance_ref):
def abort_instance_claim(self, instance):
def abort_resize_claim(self, instance_uuid, instance_type):
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def update_usage(self, context, instance):
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def update_available_resource(self, context):
def _sync_compute_node(self, context, resources):
def _create(self, context, values):
def _report_hypervisor_resource_view(self, resources):
def _report_final_resource_view(self, resources):
def _update(self, context, values, prune_stats=False):
def confirm_resize(self, context, migration, status='confirmed'):
def revert_resize(self, context, migration, status='reverted'):
def _update_usage_from_migration(self, context, instance, resources, migration):
def _update_usage_from_instance(self, resources, instance):
def _update_usage_from_instances(self, resources, instances):
def _find_orphaned_instances(self):
def _update_usage_from_orphans(self, resources, orphans):
def _get_instance_type(self, context, instance, prefix, instance_type_id=None):
def __init__(self, compute_driver=None, *args, **kwargs):
def _instance_update(self, context, instance_uuid, **kwargs):
def _get_instances_on_driver(self, context):
def _destroy_evacuated_instances(self, context):
def _init_instance(self, context, instance):
def init_host(self):
def pre_start_hook(self, **kwargs):
def _get_power_state(self, context, instance):
def get_backdoor_port(self, context):
def get_console_topic(self, context):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def refresh_security_group_rules(self, context, security_group_id):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def refresh_security_group_members(self, context, security_group_id):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def refresh_instance_security_rules(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def refresh_provider_fw_rules(self, context):
def _get_instance_nw_info(self, context, instance):
def _legacy_nw_info(self, network_info):
def _setup_block_device_mapping(self, context, instance, bdms):
def _decode_files(self, injected_files):
def _run_instance(self, context, request_spec, filter_properties, requested_networks, injected_files, admin_password, is_first_time, node, instance):
def _reschedule_or_reraise(self, context, instance, exc_info, requested_networks, admin_password, injected_files, is_first_time, request_spec, filter_properties, bdms=None):
def _reschedule(self, context, request_spec, filter_properties, instance_uuid, scheduler_method, method_args, task_state, exc_info=None):
@manager.periodic_task DCNL def _check_instance_build_time(self, context):
def _check_instance_exists(self, context, instance):
def _check_image_size(self, context, instance):
def _start_building(self, context, instance):
def _allocate_network(self, context, instance, requested_networks, macs, security_groups):
def _prep_block_device(self, context, instance, bdms):
def _spawn(self, context, instance, image_meta, network_info, block_device_info, injected_files, admin_password, set_access_ip=False):
def _get_volume_bdms(self, bdms):
def _shutdown_instance(self, context, instance, bdms):
@hooks.add_hook('delete_instance') DCNL def _delete_instance(self, context, instance, bdms, reservations=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def terminate_instance(self, context, instance, bdms=None, reservations=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def stop_instance(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def start_instance(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def soft_delete_instance(self, context, instance, reservations=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def restore_instance(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def power_off_instance(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def power_on_instance(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def rebuild_instance(self, context, instance, orig_image_ref, image_ref, injected_files, new_pass, orig_sys_metadata=None, bdms=None, recreate=False, on_shared_storage=False):
def _handle_bad_volumes_detached(self, context, instance, bad_devices, block_device_info):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def reboot_instance(self, context, instance, block_device_info=None, network_info=None, reboot_type='SOFT'):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def snapshot_instance(self, context, image_id, instance, image_type='snapshot', backup_type=None, rotation=None):
@wrap_instance_fault DCNL def _rotate_backups(self, context, instance, backup_type, rotation):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def set_admin_password(self, context, instance, new_pass=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def inject_file(self, context, path, file_contents, instance):
def _get_rescue_image_ref(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def rescue_instance(self, context, instance, rescue_password=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def unrescue_instance(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def change_instance_metadata(self, context, diff, instance):
def _cleanup_stored_instance_types(self, migration, instance, restore_old=False):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def confirm_resize(self, context, instance, reservations=None, migration=None, migration_id=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def revert_resize(self, context, instance, migration=None, migration_id=None, reservations=None):
def _refresh_block_device_connection_info(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def finish_revert_resize(self, context, instance, reservations=None, migration=None, migration_id=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def prep_resize(self, context, image, instance, instance_type, reservations=None, request_spec=None, filter_properties=None, node=None):
def _reschedule_resize_or_reraise(self, context, image, instance, exc_info, instance_type, reservations, request_spec, filter_properties):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def resize_instance(self, context, instance, image, reservations=None, migration=None, migration_id=None, instance_type=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def finish_resize(self, context, disk_info, image, instance, reservations=None, migration=None, migration_id=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def add_fixed_ip_to_instance(self, context, network_id, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def remove_fixed_ip_from_instance(self, context, address, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def pause_instance(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def unpause_instance(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def host_power_action(self, context, host=None, action=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def host_maintenance_mode(self, context, host, mode):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def set_host_enabled(self, context, host=None, enabled=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def get_host_uptime(self, context):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_fault DCNL def get_diagnostics(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def suspend_instance(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_event DCNL @wrap_instance_fault DCNL def resume_instance(self, context, instance):
@reverts_task_state DCNL @wrap_instance_fault DCNL def reset_network(self, context, instance):
def _inject_network_info(self, context, instance):
@wrap_instance_fault DCNL def inject_network_info(self, context, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_fault DCNL def get_console_output(self, context, instance, tail_length=None):
@rpc_common.client_exceptions(exception.ConsoleTypeInvalid, exception.InstanceNotReady, exception.InstanceNotFound) DCNL @exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_fault DCNL def get_vnc_console(self, context, console_type, instance):
@rpc_common.client_exceptions(exception.ConsoleTypeInvalid, exception.InstanceNotReady, exception.InstanceNotFound) DCNL @exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @wrap_instance_fault DCNL def get_spice_console(self, context, console_type, instance):
def _attach_volume_boot(self, context, instance, volume, mountpoint):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def attach_volume(self, context, volume_id, mountpoint, instance):
def _detach_volume(self, context, instance, bdm):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL @reverts_task_state DCNL @wrap_instance_fault DCNL def detach_volume(self, context, volume_id, instance):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def remove_volume_connection(self, context, volume_id, instance):
def attach_interface(self, context, instance, network_id, port_id, requested_ip=None):
def detach_interface(self, context, instance, port_id):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def check_can_live_migrate_destination(self, ctxt, instance, block_migration=False, disk_over_commit=False):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def check_can_live_migrate_source(self, ctxt, instance, dest_check_data):
def pre_live_migration(self, context, instance, block_migration=False, disk=None, migrate_data=None):
def live_migration(self, context, dest, instance, block_migration=False, migrate_data=None):
def _post_live_migration(self, ctxt, instance_ref, dest, block_migration=False, migrate_data=None):
def post_live_migration_at_destination(self, context, instance, block_migration=False):
def _rollback_live_migration(self, context, instance, dest, block_migration, migrate_data=None):
def rollback_live_migration_at_destination(self, context, instance):
@manager.periodic_task DCNL def _heal_instance_info_cache(self, context):
def _get_host_volume_bdms(self, context, host):
def _update_volume_usage_cache(self, context, vol_usages, refreshed):
def _send_volume_usage_notifications(self, context, start_time):
@manager.periodic_task(spacing=600.0, run_immediately=True) DCNL def _sync_power_states(self, context):
def _sync_instance_power_state(self, context, db_instance, vm_power_state):
@manager.periodic_task DCNL def _reclaim_queued_deletes(self, context):
@manager.periodic_task DCNL def update_available_resource(self, context):
@manager.periodic_task(spacing=CONF.running_deleted_instance_poll_interval) DCNL def _cleanup_running_deleted_instances(self, context):
def _running_deleted_instances(self, context):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def add_aggregate_host(self, context, host, slave_info=None, aggregate=None, aggregate_id=None):
@exception.wrap_exception(notifier=notifier, publisher_id=publisher_id()) DCNL def remove_aggregate_host(self, context, host, slave_info=None, aggregate=None, aggregate_id=None):
@manager.periodic_task(spacing=CONF.image_cache_manager_interval, external_process_ok=True) DCNL def _run_image_cache_manager_pass(self, context):
def _instance_update(self, context, instance_uuid, **kwargs):
def _check_injected_file_quota(self, context, injected_files):
def _check_num_instances_quota(self, context, instance_type, min_count, max_count):
def _check_metadata_properties_quota(self, context, metadata=None):
def _check_requested_secgroups(self, context, secgroups):
def _check_requested_networks(self, context, requested_networks):
@staticmethod DCNL def _handle_kernel_and_ramdisk(context, kernel_id, ramdisk_id, image):
def _validate_and_provision_instance(self, context, instance_type, image_href, kernel_id, ramdisk_id, min_count, max_count, display_name, display_description, key_name, key_data, security_groups, availability_zone, user_data, metadata, injected_files, access_ip_v4, access_ip_v6, requested_networks, config_drive, block_device_mapping, auto_disk_config, reservation_id, scheduler_hints):
def _create_instance(self, context, instance_type, image_href, kernel_id, ramdisk_id, min_count, max_count, display_name, display_description, key_name, key_data, security_group, availability_zone, user_data, metadata, injected_files, admin_password, access_ip_v4, access_ip_v6, requested_networks, config_drive, block_device_mapping, auto_disk_config, reservation_id=None, scheduler_hints=None):
def _update_image_block_device_mapping(self, elevated_context, instance_type, instance_uuid, mappings):
def _update_block_device_mapping(self, elevated_context, instance_type, instance_uuid, block_device_mapping):
def _populate_instance_for_bdm(self, context, instance, instance_type, image, block_device_mapping):
def _populate_instance_shutdown_terminate(self, instance, image, block_device_mapping):
def _populate_instance_names(self, instance, num_instances):
def _populate_instance_for_create(self, base_options, image, security_groups):
def create_db_entry_for_new_instance(self, context, instance_type, image, base_options, security_group, block_device_mapping, num_instances, index):
def _check_create_policies(self, context, availability_zone, requested_networks, block_device_mapping):
@hooks.add_hook('create_instance') DCNL def create(self, context, instance_type, image_href, kernel_id=None, ramdisk_id=None, min_count=None, max_count=None, display_name=None, display_description=None, key_name=None, key_data=None, security_group=None, availability_zone=None, user_data=None, metadata=None, injected_files=None, admin_password=None, block_device_mapping=None, access_ip_v4=None, access_ip_v6=None, requested_networks=None, config_drive=None, auto_disk_config=None, scheduler_hints=None):
def trigger_provider_fw_rules_refresh(self, context):
def update_state(self, context, instance, new_state):
@wrap_check_policy DCNL def update(self, context, instance, **kwargs):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=None, task_state=None) DCNL def soft_delete(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=None, task_state=None) DCNL def delete(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.SOFT_DELETED]) DCNL def restore(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.SOFT_DELETED]) DCNL def force_delete(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_host DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.RESCUED, vm_states.ERROR, vm_states.STOPPED], task_state=[None]) DCNL def stop(self, context, instance, do_cast=True):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_host DCNL @check_instance_state(vm_state=[vm_states.STOPPED]) DCNL def start(self, context, instance):
def get_active_by_window(self, context, begin, end=None, project_id=None):
def get_instance_type(self, context, instance_type_id):
def get(self, context, instance_id):
def get_all(self, context, search_opts=None, sort_key='created_at', sort_dir='desc', limit=None, marker=None):
@wrap_check_policy DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED]) DCNL def backup(self, context, instance, name, backup_type, rotation, extra_properties=None, image_id=None):
@wrap_check_policy DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED, vm_states.PAUSED, vm_states.SUSPENDED]) DCNL def snapshot(self, context, instance, name, extra_properties=None, image_id=None):
def _create_image(self, context, instance, name, image_type, backup_type=None, rotation=None, extra_properties=None):
@check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED]) DCNL def snapshot_volume_backed(self, context, instance, image_meta, name, extra_properties=None):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED, vm_states.PAUSED, vm_states.SUSPENDED], task_state=[None, task_states.REBOOTING, task_states.REBOOTING_HARD, task_states.RESUMING, task_states.UNPAUSING, task_states.PAUSING, task_states.SUSPENDING]) DCNL def reboot(self, context, instance, reboot_type):
def _get_image(self, context, image_href):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED], task_state=[None]) DCNL def rebuild(self, context, instance, image_href, admin_password, **kwargs):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.RESIZED]) DCNL def revert_resize(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.RESIZED]) DCNL def confirm_resize(self, context, instance, migration_ref=None):
@staticmethod DCNL def _resize_quota_delta(context, new_instance_type, old_instance_type, sense, compare):
@staticmethod DCNL def _upsize_quota_delta(context, new_instance_type, old_instance_type):
@staticmethod DCNL def _reverse_upsize_quota_delta(context, migration_ref):
@staticmethod DCNL def _downsize_quota_delta(context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED], task_state=[None]) DCNL def resize(self, context, instance, flavor_id=None, **kwargs):
@wrap_check_policy DCNL @check_instance_lock DCNL def add_fixed_ip(self, context, instance, network_id):
@wrap_check_policy DCNL @check_instance_lock DCNL def remove_fixed_ip(self, context, instance, address):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.RESCUED]) DCNL def pause(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.PAUSED]) DCNL def unpause(self, context, instance):
@wrap_check_policy DCNL def get_diagnostics(self, context, instance):
def get_backdoor_port(self, context, host_name):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.RESCUED]) DCNL def suspend(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.SUSPENDED]) DCNL def resume(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED]) DCNL def rescue(self, context, instance, rescue_password=None):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.RESCUED]) DCNL def unrescue(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE]) DCNL def set_admin_password(self, context, instance, password=None):
@wrap_check_policy DCNL @check_instance_lock DCNL def inject_file(self, context, instance, path, file_contents):
@wrap_check_policy DCNL @check_instance_host DCNL def get_vnc_console(self, context, instance, console_type):
@check_instance_host DCNL def get_vnc_connect_info(self, context, instance, console_type):
@wrap_check_policy DCNL @check_instance_host DCNL def get_spice_console(self, context, instance, console_type):
@check_instance_host DCNL def get_spice_connect_info(self, context, instance, console_type):
@wrap_check_policy DCNL @check_instance_host DCNL def get_console_output(self, context, instance, tail_length=None):
@wrap_check_policy DCNL def lock(self, context, instance):
@wrap_check_policy DCNL def unlock(self, context, instance):
@wrap_check_policy DCNL def get_lock(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL def reset_network(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL def inject_network_info(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.PAUSED, vm_states.SUSPENDED, vm_states.STOPPED, vm_states.RESIZED, vm_states.SOFT_DELETED], task_state=None) DCNL def attach_volume(self, context, instance, volume_id, device=None):
def detach_volume(self, context, volume_id):
@wrap_check_policy DCNL def attach_interface(self, context, instance, network_id, port_id, requested_ip):
@wrap_check_policy DCNL def detach_interface(self, context, instance, port_id):
@wrap_check_policy DCNL def get_instance_metadata(self, context, instance):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.PAUSED, vm_states.SUSPENDED, vm_states.STOPPED], task_state=None) DCNL def delete_instance_metadata(self, context, instance, key):
@wrap_check_policy DCNL @check_instance_lock DCNL @check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.PAUSED, vm_states.SUSPENDED, vm_states.STOPPED], task_state=None) DCNL def update_instance_metadata(self, context, instance, metadata, delete=False):
def get_instance_faults(self, context, instances):
def get_instance_bdms(self, context, instance):
@check_instance_state(vm_state=[vm_states.ACTIVE]) DCNL def live_migrate(self, context, instance, block_migration, disk_over_commit, host_name):
@check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED], task_state=[None]) DCNL def evacuate(self, context, instance, host, on_shared_storage, admin_password=None):
def _assert_host_exists(self, context, host_name):
def set_host_enabled(self, context, host_name, enabled):
def get_host_uptime(self, context, host_name):
def host_power_action(self, context, host_name, action):
def set_host_maintenance(self, context, host_name, mode):
def service_get_all(self, context, filters=None, set_zones=False):
def service_get_by_compute_host(self, context, host_name):
def instance_get_all_by_host(self, context, host_name):
def task_log_get_all(self, context, task_name, period_beginning, period_ending, host=None, state=None):
def compute_node_get(self, context, compute_id):
def create_aggregate(self, context, aggregate_name, availability_zone):
def get_aggregate(self, context, aggregate_id):
def get_aggregate_list(self, context):
def update_aggregate(self, context, aggregate_id, values):
def update_aggregate_metadata(self, context, aggregate_id, metadata):
def delete_aggregate(self, context, aggregate_id):
def add_host_to_aggregate(self, context, aggregate_id, host_name):
def remove_host_from_aggregate(self, context, aggregate_id, host_name):
def _get_aggregate_info(self, context, aggregate):
def import_key_pair(self, context, user_id, key_name, public_key):
def create_key_pair(self, context, user_id, key_name):
def delete_key_pair(self, context, user_id, key_name):
def get_key_pairs(self, context, user_id):
def get_key_pair(self, context, user_id, key_name):
def validate_property(self, value, property, allowed):
def ensure_default(self, context):
def is_associated_with_server(self, security_group, instance_uuid):
@wrap_check_security_groups_policy DCNL def add_to_instance(self, context, instance, security_group_name):
@wrap_check_security_groups_policy DCNL def remove_from_instance(self, context, instance, security_group_name):
def add_rules(self, context, id, name, vals):
def default_rule_exists(self, context, values):
def trigger_rules_refresh(self, context, id):
def trigger_members_refresh(self, context, group_ids):
@property DCNL def io_workload(self):
def calculate_workload(self):
def update_stats_for_instance(self, instance):
def _extract_state_from_instance(self, instance):
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def abort(self):
def test(self, resources, limits=None):
def _test(self, type_, unit, total, used, requested, limit):
@lockutils.synchronized(COMPUTE_RESOURCE_SEMAPHORE, 'nova-') DCNL def abort(self):
def _cell_read_only(self, cell_name):
def _check_requested_networks(self, context, requested_networks):
def _validate_image_href(self, context, image_href):
def backup(self, context, instance, name, backup_type, rotation, extra_properties=None, image_id=None):
def snapshot(self, context, instance, name, extra_properties=None, image_id=None):
def create(self, *args, **kwargs):
def update_state(self, context, instance, new_state):
def update(self, context, instance, pass_on_state_change=False, **kwargs):
def _handle_cell_delete(self, context, instance, method, method_name):
@validate_cell DCNL def restore(self, context, instance):
@validate_cell DCNL def force_delete(self, context, instance):
@validate_cell DCNL def stop(self, context, instance, do_cast=True):
@validate_cell DCNL def start(self, context, instance):
@validate_cell DCNL def reboot(self, context, instance, *args, **kwargs):
@validate_cell DCNL def rebuild(self, context, instance, *args, **kwargs):
@validate_cell DCNL def evacuate(self, context, instance, *args, **kwargs):
@check_instance_state(vm_state=[vm_states.RESIZED]) DCNL @validate_cell DCNL def revert_resize(self, context, instance):
@check_instance_state(vm_state=[vm_states.RESIZED]) DCNL @validate_cell DCNL def confirm_resize(self, context, instance):
@check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED], task_state=[None]) DCNL @validate_cell DCNL def resize(self, context, instance, flavor_id=None, *args, **kwargs):
@validate_cell DCNL def add_fixed_ip(self, context, instance, *args, **kwargs):
@validate_cell DCNL def remove_fixed_ip(self, context, instance, *args, **kwargs):
@validate_cell DCNL def pause(self, context, instance):
@validate_cell DCNL def unpause(self, context, instance):
def get_diagnostics(self, context, instance):
@validate_cell DCNL def suspend(self, context, instance):
@validate_cell DCNL def resume(self, context, instance):
@validate_cell DCNL def rescue(self, context, instance, rescue_password=None):
@validate_cell DCNL def unrescue(self, context, instance):
@validate_cell DCNL def set_admin_password(self, context, instance, password=None):
@validate_cell DCNL def inject_file(self, context, instance, *args, **kwargs):
@wrap_check_policy DCNL @validate_cell DCNL def get_vnc_console(self, context, instance, console_type):
@wrap_check_policy DCNL @validate_cell DCNL def get_spice_console(self, context, instance, console_type):
@validate_cell DCNL def get_console_output(self, context, instance, *args, **kwargs):
def lock(self, context, instance):
def unlock(self, context, instance):
@validate_cell DCNL def reset_network(self, context, instance):
@validate_cell DCNL def inject_network_info(self, context, instance):
@wrap_check_policy DCNL @validate_cell DCNL def attach_volume(self, context, instance, volume_id, device=None):
@check_instance_lock DCNL @validate_cell DCNL def _detach_volume(self, context, instance, volume_id):
@wrap_check_policy DCNL @validate_cell DCNL def associate_floating_ip(self, context, instance, address):
@validate_cell DCNL def delete_instance_metadata(self, context, instance, key):
def _assert_host_exists(self, context, host_name):
def instance_get_all_by_host(self, context, host_name):
def task_log_get_all(self, context, task_name, beginning, ending, host=None, state=None):
def compute_node_get(self, context, compute_id):
def add_aggregate_host(self, ctxt, aggregate, host_param, host, slave_info=None):
def host_maintenance_mode(self, ctxt, host_param, mode, host):
def remove_aggregate_host(self, ctxt, aggregate, host_param, host, slave_info=None):
def _append_hop(self):
def _at_max_hop_count(self, do_raise=True):
def _process_locally(self):
def _setup_response_queue(self):
def _cleanup_response_queue(self):
def _wait_for_json_responses(self, num_responses=1):
def _send_json_responses(self, json_responses, neighbor_only=False, fanout=False):
def _send_response(self, response, neighbor_only=False):
def _send_response_from_exception(self, exc_info):
def _to_dict(self):
def to_json(self):
def source_is_us(self):
def process(self):
def _get_next_hop(self):
def process(self):
def _get_next_hops(self):
def _send_to_cells(self, target_cells):
def _send_json_responses(self, json_responses):
def process(self):
def process(self):
def task_log_get_all(self, message, task_name, period_beginning, period_ending, host, state):
def schedule_run_instance(self, message, host_sched_kwargs):
def run_compute_api_method(self, message, method_info):
def update_capabilities(self, message, cell_name, capabilities):
def update_capacities(self, message, cell_name, capacities):
def announce_capabilities(self, message):
def announce_capacities(self, message):
def service_get_by_compute_host(self, message, host_name):
def proxy_rpc_to_manager(self, message, host_name, rpc_message, topic, timeout):
def compute_node_get(self, message, compute_id):
def validate_console_port(self, message, instance_uuid, console_port, console_type):
def _at_the_top(self):
def instance_update_at_top(self, message, instance, **kwargs):
def instance_destroy_at_top(self, message, instance, **kwargs):
def instance_delete_everywhere(self, message, instance, delete_type, **kwargs):
def instance_fault_create_at_top(self, message, instance_fault, **kwargs):
def bw_usage_update_at_top(self, message, bw_update_info, **kwargs):
def compute_node_get_all(self, message, hypervisor_match):
def compute_node_stats(self, message):
def consoleauth_delete_tokens(self, message, instance_uuid):
def _process_message_locally(self, message):
def _put_response(self, response_uuid, response):
def _setup_response_queue(self, message):
def _cleanup_response_queue(self, message):
def _create_response_message(self, ctxt, direction, target_cell, response_uuid, response_kwargs, **kwargs):
def message_from_json(self, json_message):
def ask_children_for_capabilities(self, ctxt):
def ask_children_for_capacities(self, ctxt):
def tell_parents_our_capabilities(self, ctxt):
def tell_parents_our_capacities(self, ctxt):
def schedule_run_instance(self, ctxt, target_cell, host_sched_kwargs):
def run_compute_api_method(self, ctxt, cell_name, method_info, call):
def instance_update_at_top(self, ctxt, instance):
def instance_destroy_at_top(self, ctxt, instance):
def instance_delete_everywhere(self, ctxt, instance, delete_type):
def instance_fault_create_at_top(self, ctxt, instance_fault):
def bw_usage_update_at_top(self, ctxt, bw_update_info):
def sync_instances(self, ctxt, project_id, updated_since, deleted):
def task_log_get_all(self, ctxt, cell_name, task_name, period_beginning, period_ending, host=None, state=None):
def compute_node_get_all(self, ctxt, hypervisor_match=None):
def compute_node_stats(self, ctxt):
def compute_node_get(self, ctxt, cell_name, compute_id):
def consoleauth_delete_tokens(self, ctxt, instance_uuid):
def validate_console_port(self, ctxt, cell_name, instance_uuid, console_port, console_type):
def start_consumers(self, msg_runner):
def stop_consumers(self):
def send_message_to_cell(self, cell_state, message):
def _run_instance(self, message, host_sched_kwargs):
def run_instance(self, message, host_sched_kwargs):
def post_start_hook(self):
@manager.periodic_task DCNL def _update_our_parents(self, ctxt):
@manager.periodic_task DCNL def _heal_instances(self, ctxt):
def _sync_instance(self, ctxt, instance):
def schedule_run_instance(self, ctxt, host_sched_kwargs):
def get_cell_info_for_neighbors(self, _ctxt):
def run_compute_api_method(self, ctxt, cell_name, method_info, call):
def instance_update_at_top(self, ctxt, instance):
def instance_destroy_at_top(self, ctxt, instance):
def instance_delete_everywhere(self, ctxt, instance, delete_type):
def instance_fault_create_at_top(self, ctxt, instance_fault):
def bw_usage_update_at_top(self, ctxt, bw_update_info):
def sync_instances(self, ctxt, project_id, updated_since, deleted):
def service_get_all(self, ctxt, filters):
def service_get_by_compute_host(self, ctxt, host_name):
def proxy_rpc_to_manager(self, ctxt, topic, rpc_message, call, timeout):
def task_log_get_all(self, ctxt, task_name, period_beginning, period_ending, host=None, state=None):
def compute_node_get(self, ctxt, compute_id):
def compute_node_get_all(self, ctxt, hypervisor_match=None):
def compute_node_stats(self, ctxt):
def consoleauth_delete_tokens(self, ctxt, instance_uuid):
def validate_console_port(self, ctxt, instance_uuid, console_port, console_type):
def _start_consumer(self, dispatcher, topic):
def start_consumers(self, msg_runner):
def stop_consumers(self):
def send_message_to_cell(self, cell_state, message):
@staticmethod DCNL def _get_server_params_for_cell(next_hop):
def send_message_to_cell(self, cell_state, message):
def __init__(self, msg_runner):
def process_message(self, _ctxt, message):
def update_db_info(self, cell_db_info):
def update_capabilities(self, cell_metadata):
def update_capacities(self, capacities):
def get_cell_info(self):
def send_message(self, message):
def _refresh_cells_from_db(self, ctxt):
def _time_to_sync(self):
def _update_our_capacity(self, context):
@lockutils.synchronized('cell-db-sync', 'nova-') DCNL def _cell_db_sync(self):
@sync_from_db DCNL def get_cell_info_for_neighbors(self):
@sync_from_db DCNL def get_my_state(self):
@sync_from_db DCNL def get_child_cells(self):
@sync_from_db DCNL def get_parent_cells(self):
@sync_from_db DCNL def update_cell_capabilities(self, cell_name, capabilities):
@sync_from_db DCNL def update_cell_capacities(self, cell_name, capacities):
def cast_compute_api_method(self, ctxt, cell_name, method, *args, **kwargs):
def call_compute_api_method(self, ctxt, cell_name, method, *args, **kwargs):
def schedule_run_instance(self, ctxt, **kwargs):
def instance_update_at_top(self, ctxt, instance):
def instance_destroy_at_top(self, ctxt, instance):
def instance_delete_everywhere(self, ctxt, instance, delete_type):
def instance_fault_create_at_top(self, ctxt, instance_fault):
def bw_usage_update_at_top(self, ctxt, uuid, mac, start_period, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refreshed=None):
def instance_info_cache_update_at_top(self, ctxt, instance_info_cache):
def get_cell_info_for_neighbors(self, ctxt):
def sync_instances(self, ctxt, project_id=None, updated_since=None, deleted=False):
def service_get_all(self, ctxt, filters=None):
def service_get_by_compute_host(self, ctxt, host_name):
def proxy_rpc_to_manager(self, ctxt, rpc_message, topic, call=False, timeout=None):
def task_log_get_all(self, ctxt, task_name, period_beginning, period_ending, host=None, state=None):
def compute_node_get(self, ctxt, compute_id):
def compute_node_get_all(self, ctxt, hypervisor_match=None):
def compute_node_stats(self, ctxt):
def consoleauth_delete_tokens(self, ctxt, instance_uuid):
def validate_console_port(self, ctxt, instance_uuid, console_port, console_type):
def __init__(self, net_manager):
def get_subnets_by_net_id(self, context, tenant_id, net_id, _vif_id=None):
def get_routes_by_ip_block(self, context, block_id, project_id):
def get_v4_ips_by_interface(self, context, net_id, vif_id, project_id):
def get_v6_ips_by_interface(self, context, net_id, vif_id, project_id):
@wrap_check_policy DCNL def allocate_floating_ip(self, context, pool=None):
@wrap_check_policy DCNL def release_floating_ip(self, context, address, affect_auto_assigned=False):
@wrap_check_policy DCNL @refresh_cache DCNL def associate_floating_ip(self, context, instance, floating_address, fixed_address, affect_auto_assigned=False):
@wrap_check_policy DCNL @refresh_cache DCNL def disassociate_floating_ip(self, context, instance, address, affect_auto_assigned=False):
@wrap_check_policy DCNL @refresh_cache DCNL def allocate_for_instance(self, context, instance, vpn, requested_networks, macs=None, conductor_api=None, security_groups=None, **kwargs):
@wrap_check_policy DCNL def deallocate_for_instance(self, context, instance, **kwargs):
@wrap_check_policy DCNL @refresh_cache DCNL def add_fixed_ip_to_instance(self, context, instance, network_id, conductor_api=None, **kwargs):
@wrap_check_policy DCNL @refresh_cache DCNL def remove_fixed_ip_from_instance(self, context, instance, address, conductor=None, **kwargs):
@wrap_check_policy DCNL def add_network_to_project(self, context, project_id, network_uuid=None):
@wrap_check_policy DCNL def associate(self, context, network_uuid, host=_sentinel, project=_sentinel):
@wrap_check_policy DCNL def get_instance_nw_info(self, context, instance, conductor_api=None, **kwargs):
def _get_instance_nw_info(self, context, instance):
@wrap_check_policy DCNL def validate_networks(self, context, requested_networks):
@wrap_check_policy DCNL def get_instance_uuids_by_ip_filter(self, context, filters):
@wrap_check_policy DCNL def get_dns_domains(self, context):
@wrap_check_policy DCNL def add_dns_entry(self, context, address, name, dns_type, domain):
@wrap_check_policy DCNL def modify_dns_entry(self, context, name, address, domain):
@wrap_check_policy DCNL def delete_dns_entry(self, context, name, domain):
@wrap_check_policy DCNL def delete_dns_domain(self, context, domain):
@wrap_check_policy DCNL def get_dns_entries_by_address(self, context, address, domain):
@wrap_check_policy DCNL def get_dns_entries_by_name(self, context, name, domain):
@wrap_check_policy DCNL def create_private_dns_domain(self, context, domain, availability_zone):
@wrap_check_policy DCNL def create_public_dns_domain(self, context, domain, project=None):
@wrap_check_policy DCNL def setup_networks_on_host(self, context, instance, host=None, teardown=False):
@wrap_check_policy DCNL def migrate_instance_start(self, context, instance, migration):
@wrap_check_policy DCNL def migrate_instance_finish(self, context, instance, migration):
def add_chain(self, name, wrap=True):
def remove_chain(self, name, wrap=True):
def add_rule(self, chain, rule, wrap=True, top=False):
def remove_rule(self, chain, rule, wrap=True, top=False):
def remove_rules_regex(self, regex):
def empty_chain(self, chain, wrap=True):
@lockutils.synchronized('iptables', 'nova-', external=True) DCNL def _apply(self):
def plug(self, network, mac_address):
def unplug(self, network):
def get_dev(self, network):
@classmethod DCNL def ensure_vlan_bridge(_self, vlan_num, bridge, bridge_interface, net_attrs=None, mac_address=None):
@classmethod DCNL def remove_vlan_bridge(cls, vlan_num, bridge):
@classmethod DCNL @lockutils.synchronized('lock_vlan', 'nova-', external=True) DCNL def ensure_vlan(_self, vlan_num, bridge_interface, mac_address=None):
@classmethod DCNL @lockutils.synchronized('lock_vlan', 'nova-', external=True) DCNL def remove_vlan(cls, vlan_num):
@classmethod DCNL @lockutils.synchronized('lock_bridge', 'nova-', external=True) DCNL def ensure_bridge(_self, bridge, interface, net_attrs=None, gateway=True, filtering=True):
@classmethod DCNL @lockutils.synchronized('lock_bridge', 'nova-', external=True) DCNL def remove_bridge(cls, bridge, gateway=True, filtering=True):
def init_host_floating_ips(self):
def allocate_for_instance(self, context, **kwargs):
def deallocate_for_instance(self, context, **kwargs):
def _floating_ip_owned_by_project(self, context, floating_ip):
def allocate_floating_ip(self, context, project_id, auto_assigned=False, pool=None):
@rpc_common.client_exceptions(exception.FloatingIpNotFoundForAddress) DCNL def deallocate_floating_ip(self, context, address, affect_auto_assigned=False):
@rpc_common.client_exceptions(exception.FloatingIpNotFoundForAddress) DCNL def associate_floating_ip(self, context, floating_address, fixed_address, affect_auto_assigned=False):
def _associate_floating_ip(self, context, floating_address, fixed_address, interface, instance_uuid):
@rpc_common.client_exceptions(exception.FloatingIpNotFoundForAddress) DCNL def disassociate_floating_ip(self, context, address, affect_auto_assigned=False):
def _disassociate_floating_ip(self, context, address, interface, instance_uuid):
@rpc_common.client_exceptions(exception.FloatingIpNotFound) DCNL def get_floating_ip(self, context, id):
def get_floating_pools(self, context):
def get_floating_ip_pools(self, context):
def get_floating_ip_by_address(self, context, address):
def get_floating_ips_by_project(self, context):
def get_floating_ips_by_fixed_address(self, context, fixed_address):
def _allocate_fixed_ips(self, context, instance_id, host, networks, **kwargs):
def _rpc_allocate_fixed_ip(self, context, instance_id, network_id, **kwargs):
def deallocate_fixed_ip(self, context, address, host=None, teardown=True):
@lockutils.synchronized('get_dhcp', 'nova-') DCNL def _get_dhcp_ip(self, context, network_ref, host=None):
def get_dhcp_leases(self, ctxt, network_ref):
def init_host(self):
def set_network_host(self, context, network_ref):
def _get_networks_for_instance(self, context, instance_id, project_id, requested_networks=None):
def allocate_for_instance(self, context, **kwargs):
def deallocate_for_instance(self, context, **kwargs):
def get_instance_nw_info(self, context, instance_id, rxtx_factor, host, instance_uuid=None, **kwargs):
def build_network_info_model(self, context, vifs, networks, rxtx_factor, instance_host):
def _get_network_dict(self, network):
def _get_subnets_from_network(self, context, network, vif, instance_host=None):
def _allocate_mac_addresses(self, context, instance_uuid, networks, macs):
def add_fixed_ip_to_instance(self, context, instance_id, host, network_id, rxtx_factor=None):
def get_backdoor_port(self, context):
def remove_fixed_ip_from_instance(self, context, instance_id, host, address, rxtx_factor=None):
def allocate_fixed_ip(self, context, instance_id, network, **kwargs):
def deallocate_fixed_ip(self, context, address, host=None, teardown=True):
def lease_fixed_ip(self, context, address):
def release_fixed_ip(self, context, address):
def _do_create_networks(self, context, label, cidr, multi_host, num_networks, network_size, cidr_v6, gateway, gateway_v6, bridge, bridge_interface, dns1=None, dns2=None, fixed_cidr=None, **kwargs):
@property DCNL def _bottom_reserved_ips(self):
@property DCNL def _top_reserved_ips(self):
def _create_fixed_ips(self, context, network_id, fixed_cidr=None):
def _allocate_fixed_ips(self, context, instance_id, host, networks, **kwargs):
def setup_networks_on_host(self, context, instance_id, host, teardown=False):
def _setup_network_on_host(self, context, network):
def _teardown_network_on_host(self, context, network):
def validate_networks(self, context, networks):
def get_vifs_by_instance(self, context, instance_id):
def get_instance_id_by_floating_address(self, context, address):
def get_fixed_ip(self, context, id):
def get_vif_by_mac_address(self, context, mac_address):
@manager.periodic_task(spacing=CONF.dns_update_periodic_interval) DCNL def _periodic_update_dns(self, context):
def update_dns(self, context, network_ids):
def _allocate_fixed_ips(self, context, instance_id, host, networks, **kwargs):
def deallocate_fixed_ip(self, context, address, host=None, teardown=True):
def _setup_network_on_host(self, context, network):
def _teardown_network_on_host(self, context, network):
def get_floating_ip(self, context, id):
def get_floating_pools(self, context):
def get_floating_ip_pools(self, context):
def get_floating_ip_by_address(self, context, address):
def get_floating_ips_by_project(self, context):
def get_floating_ips_by_fixed_address(self, context, fixed_address):
@network_api.wrap_check_policy DCNL def allocate_floating_ip(self, context, project_id, pool):
@network_api.wrap_check_policy DCNL def deallocate_floating_ip(self, context, address, affect_auto_assigned):
@network_api.wrap_check_policy DCNL def associate_floating_ip(self, context, floating_address, fixed_address, affect_auto_assigned=False):
@network_api.wrap_check_policy DCNL def disassociate_floating_ip(self, context, address, affect_auto_assigned=False):
def update_dns(self, context, network_ids):
def init_host(self):
def _setup_network_on_host(self, context, network):
def _get_network_dict(self, network):
def init_host(self):
def allocate_fixed_ip(self, context, instance_id, network, **kwargs):
def add_network_to_project(self, context, project_id, network_uuid=None):
def associate(self, context, network_uuid, associations):
def _get_networks_for_instance(self, context, instance_id, project_id, requested_networks=None):
def create_networks(self, context, **kwargs):
@lockutils.synchronized('setup_network', 'nova-', external=True) DCNL def _setup_network_on_host(self, context, network):
def _get_network_dict(self, network):
@property DCNL def _bottom_reserved_ips(self):
@property DCNL def _top_reserved_ips(self):
def initialize(self, **kwargs):
def initialize_network(self, network):
def initialize_gateway(self, network):
def remove_gateway(self, network_ref):
def is_initialized(self):
def add_floating_ip(self, floating_ip, fixed_ip, l3_interface_id, network=None):
def _get_available_networks(self, context, project_id, net_ids=None):
@refresh_cache DCNL def allocate_for_instance(self, context, instance, **kwargs):
def deallocate_for_instance(self, context, instance, **kwargs):
@refresh_cache DCNL def add_fixed_ip_to_instance(self, context, instance, network_id, conductor_api=None):
@refresh_cache DCNL def remove_fixed_ip_from_instance(self, context, instance, address, conductor_api=None):
def validate_networks(self, context, requested_networks):
def _get_instance_uuids_by_ip(self, context, address):
def get_instance_uuids_by_ip_filter(self, context, filters):
@refresh_cache DCNL def associate_floating_ip(self, context, instance, floating_address, fixed_address, affect_auto_assigned=False):
def get_instance_id_by_floating_address(self, context, address):
def allocate_floating_ip(self, context, pool=None):
def _get_floating_ip_by_address(self, client, address):
def _get_floating_ips_by_fixed_and_port(self, client, fixed_ip, port):
def release_floating_ip(self, context, address, affect_auto_assigned=False):
@refresh_cache DCNL def disassociate_floating_ip(self, context, instance, address, affect_auto_assigned=False):
def migrate_instance_start(self, context, instance, migration):
def migrate_instance_finish(self, context, instance, migration):
def add_network_to_project(self, context, project_id, network_uuid=None):
def _get_subnets_from_port(self, context, port):
def get_dns_domains(self, context):
def add_dns_entry(self, context, address, name, dns_type, domain):
def modify_dns_entry(self, context, name, address, domain):
def delete_dns_entry(self, context, name, domain):
def delete_dns_domain(self, context, domain):
def get_dns_entries_by_address(self, context, address, domain):
def get_dns_entries_by_name(self, context, name, domain):
def create_private_dns_domain(self, context, domain, availability_zone):
def create_public_dns_domain(self, context, domain, project=None):
def get_meta(self, key, default=None):
def as_netaddr(self):
def labeled_ips(self):
def fixed_ips(self):
def floating_ips(self):
def legacy(self):
def list(self, context, names=None, ids=None, project=None, search_opts=None):
def destroy(self, context, security_group):
def add_rules(self, context, id, name, vals):
def get_instances_security_groups_bindings(self, context):
def get_instance_security_groups(self, context, instance_id, instance_uuid=None, detailed=False):
@wrap_check_security_groups_policy DCNL def add_to_instance(self, context, instance, security_group_name):
@wrap_check_security_groups_policy DCNL def remove_from_instance(self, context, instance, security_group_name):
def rule_exists(self, security_group, new_rule):
def trigger_rules_refresh(self, context, id):
def trigger_members_refresh(self, context, group_ids):
def populate_security_groups(self, instance, security_groups):
@wrap_check_policy DCNL def allocate_floating_ip(self, context, pool=None):
@wrap_check_policy DCNL def release_floating_ip(self, context, address, affect_auto_assigned=False):
@wrap_check_policy DCNL @refresh_cache DCNL def associate_floating_ip(self, context, instance, floating_address, fixed_address, affect_auto_assigned=False):
@wrap_check_policy DCNL @refresh_cache DCNL def disassociate_floating_ip(self, context, instance, address, affect_auto_assigned=False):
@wrap_check_policy DCNL @refresh_cache DCNL def allocate_for_instance(self, context, instance, vpn, requested_networks, macs=None, conductor_api=None, security_groups=None):
@wrap_check_policy DCNL def deallocate_for_instance(self, context, instance):
@wrap_check_policy DCNL @refresh_cache DCNL def add_fixed_ip_to_instance(self, context, instance, network_id, conductor_api=None):
@wrap_check_policy DCNL @refresh_cache DCNL def remove_fixed_ip_from_instance(self, context, instance, address, conductor_api=None):
@wrap_check_policy DCNL def add_network_to_project(self, context, project_id, network_uuid=None):
@wrap_check_policy DCNL def associate(self, context, network_uuid, host=_sentinel, project=_sentinel):
@wrap_check_policy DCNL def get_instance_nw_info(self, context, instance, conductor_api=None):
def _get_instance_nw_info(self, context, instance):
@wrap_check_policy DCNL def validate_networks(self, context, requested_networks):
@wrap_check_policy DCNL def get_instance_uuids_by_ip_filter(self, context, filters):
@wrap_check_policy DCNL def get_dns_domains(self, context):
@wrap_check_policy DCNL def add_dns_entry(self, context, address, name, dns_type, domain):
@wrap_check_policy DCNL def modify_dns_entry(self, context, name, address, domain):
@wrap_check_policy DCNL def delete_dns_entry(self, context, name, domain):
@wrap_check_policy DCNL def delete_dns_domain(self, context, domain):
@wrap_check_policy DCNL def get_dns_entries_by_address(self, context, address, domain):
@wrap_check_policy DCNL def get_dns_entries_by_name(self, context, name, domain):
@wrap_check_policy DCNL def create_private_dns_domain(self, context, domain, availability_zone):
@wrap_check_policy DCNL def create_public_dns_domain(self, context, domain, project=None):
@wrap_check_policy DCNL def setup_networks_on_host(self, context, instance, host=None, teardown=False):
@wrap_check_policy DCNL def migrate_instance_start(self, context, instance, migration):
@wrap_check_policy DCNL def migrate_instance_finish(self, context, instance, migration):
def __init__(self, ldap_object):
@classmethod DCNL def create_domain(cls, lobj, domain):
def delete(self):
def trigger_security_group_create_refresh(self, context, group):
def trigger_security_group_destroy_refresh(self, context, security_group_id):
def trigger_security_group_rule_create_refresh(self, context, rule_ids):
def trigger_security_group_rule_destroy_refresh(self, context, rule_ids):
def trigger_instance_add_security_group_refresh(self, context, instance, group_name):
def trigger_instance_remove_security_group_refresh(self, context, instance, group_name):
def trigger_security_group_members_refresh(self, context, group_ids):
def trigger_security_group_create_refresh(self, context, group):
def trigger_security_group_destroy_refresh(self, context, security_group_id):
def trigger_security_group_rule_create_refresh(self, context, rule_ids):
def trigger_security_group_rule_destroy_refresh(self, context, rule_ids):
def trigger_instance_add_security_group_refresh(self, context, instance, group_name):
def trigger_instance_remove_security_group_refresh(self, context, instance, group_name):
def trigger_security_group_members_refresh(self, context, group_ids):
def one_way_proxy(self, source, dest):
def handshake(self, req, connect_info, sockets):
def proxy_connection(self, req, connect_info, start_response):
def supported(cls, stream=sys.stdout):
def write(self, text, color):
def addError(self, test, err):
def can_ping(self, ip, command='ping'):
def wait_for_running(self, instance, tries=60, wait=1):
def wait_for_deleted(self, instance, tries=60, wait=1):
def wait_for_ping(self, ip, command='ping', tries=120):
def wait_for_ssh(self, ip, key_name, tries=30, wait=5):
def connection_for_env(self, **kwargs):
def split_clc_url(self, clc_url):
def get_all_instances(self, instance_ids=None, filters=None):
def run_instances(self, image_id, min_count=1, max_count=1, key_name=None, security_groups=None, user_data=None, addressing_type=None, instance_type='m1.small', placement=None, kernel_id=None, ramdisk_id=None, monitoring_enabled=False, subnet_id=None, block_device_map=None):
def started(self):
def new_client(self):
def get_target(self, target_cfg, path):
def do_proxy(self, target):
@staticmethod DCNL def socket(host, port=None, connect=False, prefer_ipv6=False, unix_socket=None, use_ssl=False):
@staticmethod DCNL def encode_hybi(buf, opcode, base64=False):
@staticmethod DCNL def decode_hybi(buf, base64=False):
@staticmethod DCNL def gen_md5(keys):
def traffic(self, token='.'):
def msg(self, msg):
def vmsg(self, msg):
def send_frames(self, bufs=None):
def recv_frames(self):
def send_close(self, code=1000, reason=''):
def do_handshake(self, sock, address):
def started(self):
def poll(self):
def top_new_client(self, startsock, address):
def new_client(self):
def start_server(self):
def started(self):
def new_client(self):
def get_target(self, target_cfg, path):
def do_proxy(self, target):
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True):
def create_virtualenv(self, no_site_packages=True):
def parse_args(self, argv):
def post_process(self):
def post_process(self):
def supported(cls, stream=sys.stdout):
def write(self, text, color):
def addError(self, test, err):
def _notification_host(self, context, method, payload, host):
def _agent_notification(self, context, method, routers, operation, data):
def _notification(self, context, method, routers, operation, data):
def _notification_fanout(self, context, method, router_id):
def _notification_host(self, context, method, payload, host):
def _notification(self, context, method, payload, network_id):
def _notification_fanout(self, context, method, payload):
@classmethod DCNL def __subclasshook__(cls, klass):
def get_name(self):
def get_alias(self):
def get_description(self):
def get_namespace(self):
def get_updated(self):
def get_resources(self):
def get_actions(self):
def get_request_extensions(self):
def get_extended_resources(self, version):
def get_plugin_interface(self):
def update_attributes_map(self, extended_attributes, extension_attrs_map=None):
@classmethod DCNL def factory(cls, global_config, **local_config):
def _action_ext_controllers(self, application, ext_mgr, mapper):
def _request_ext_controllers(self, application, ext_mgr, mapper):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req):
@staticmethod DCNL @webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def _dispatch(req):
def get_resources(self):
def get_actions(self):
def get_request_extensions(self):
def extend_resources(self, version, attr_map):
def _check_extension(self, extension):
def _load_all_extensions(self):
def _check_extension(self, extension):
def _items(self, request, do_authz=False, parent_id=None):
def _item(self, request, id, do_authz=False, field_list=None, parent_id=None):
def index(self, request, **kwargs):
def show(self, request, id, **kwargs):
def create(self, request, body=None, **kwargs):
def delete(self, request, id, **kwargs):
def update(self, request, id, body=None, **kwargs):
@staticmethod DCNL def prepare_request_body(context, body, is_create, resource, attr_info, allow_bulk=False):
def __init__(self, base_url):
def build(self, version_data):
def _build_links(self, version_data):
def generate_href(self, version_number):
def _prepare_request_body(self, body, params):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req):
def get_active_networks(self, context, **kwargs):
def get_network_info(self, context, **kwargs):
def get_dhcp_port(self, context, **kwargs):
def release_dhcp_port(self, context, **kwargs):
def release_port_fixed_ip(self, context, **kwargs):
def update_lease_expiration(self, context, **kwargs):
def _check_session_persistence_info(self, info):
def add_router_to_l3_agent(self, context, id, router_id):
def remove_router_from_l3_agent(self, context, id, router_id):
def get_l3_agent_candidates(self, sync_router, l3_agents):
def schedule_routers(self, context, routers):
def create_security_group(self, context, security_group, default_sg=False):
def get_security_group(self, context, id, fields=None, tenant_id=None):
def _validate_security_group_rules(self, context, security_group_rule):
def _ensure_default_security_group(self, context, tenant_id):
def _get_security_groups_on_port(self, context, port):
def _check_update_deletes_security_groups(self, port):
def _check_update_has_security_groups(self, port):
def as_dict(self):
def get_service_type(self, context, id, fields=None):
def get_service_types(self, context, fields=None, filters=None):
def create_service_type(self, context, service_type):
def update_service_type(self, context, id, service_type):
def delete_service_type(self, context, id):
def increase_service_type_refcount(self, context, id):
def decrease_service_type_refcount(self, context, id):
def get_sync_data(self, context, router_ids=None, active=None):
def update(self, values):
def iteritems(self):
def __repr__(self):
def sync_routers(self, context, **kwargs):
def get_external_network_id(self, context, **kwargs):
@classmethod DCNL def register_model_query_hook(cls, model, name, query_hook, filter_hook, result_filters=None):
@staticmethod DCNL def _recycle_expired_ip_allocations(context, network_id):
@staticmethod DCNL def _recycle_ip(context, network_id, subnet_id, ip_address):
@staticmethod DCNL def _generate_ip(context, subnets):
@staticmethod DCNL def _allocate_specific_ip(context, subnet_id, ip_address):
@staticmethod DCNL def _check_unique_ip(context, network_id, subnet_id, ip_address):
@staticmethod DCNL def _check_subnet_ip(cidr, ip_address):
@staticmethod DCNL def _check_ip_in_allocation_pool(context, subnet_id, gateway_ip, ip_address):
def _test_fixed_ips_for_port(self, context, network_id, fixed_ips):
def _allocate_fixed_ips(self, context, network, fixed_ips):
def _update_ips_for_port(self, context, network_id, port_id, original_ips, new_ips):
def _allocate_ips_for_port(self, context, network, port):
def _validate_subnet_cidr(self, context, network, new_subnet_cidr):
def _validate_allocation_pools(self, ip_pools, subnet_cidr):
def _allocate_pools_for_subnet(self, context, subnet):
def create_network(self, context, network):
def _validate_ip_version(self, ip_version, addr, name):
def _validate_subnet(self, s):
def update_subnet(self, context, id, subnet):
def get_assoc_data(self, context, fip, floating_network_id):
def prevent_l3_port_deletion(self, context, port_id):
def _get_sync_routers(self, context, router_ids=None, active=None):
def _get_sync_floating_ips(self, context, router_ids):
def get_sync_interfaces(self, context, router_ids, device_owner=DEVICE_OWNER_ROUTER_INTF):
def _populate_subnet_for_ports(self, context, ports):
def get_sync_data(self, context, router_ids=None, active=None):
def update_security_group_on_port(self, context, id, port, original_port, updated_port):
def is_security_group_member_updated(self, context, original_port, updated_port):
def notify_security_groups_member_updated(self, context, port):
def security_group_rules_for_devices(self, context, **kwargs):
@staticmethod DCNL def get_tenant_quotas(context, resources, tenant_id):
@staticmethod DCNL def delete_tenant_quota(context, tenant_id):
@staticmethod DCNL def get_all_quotas(context, resources):
def _get_quotas(self, context, tenant_id, resources, keys):
def limit_check(self, context, tenant_id, resources, values):
def _determine_port_security_and_has_ip(self, context, port):
def create_or_update_agent(self, context, agent):
def report_state(self, context, **kwargs):
def config(self, **kw):
def _construct_dict_and_constraints(self):
def _delete_default_security_group_egress_rules(self, security_group_id):
def _assert_sg_rule_has_kvs(self, security_group_rule, expected_kvs):
def _test_entity_delete(self, entity):
def test_create_vip_twice_for_same_pool(self):
@classmethod DCNL def get_resources(cls):
def _create_bulk_from_list(self, fmt, resource, objects, **kwargs):
def _create_bulk(self, fmt, number, resource, data, name='test', **kwargs):
def _do_side_effect(self, patched_plugin, orig, *args, **kwargs):
def test_list_with_fields_noadmin_and_policy_field(self):
def test_update_port_update_ip(self):
def test_update_port_update_ips(self):
def test_update_port_add_additional_ip(self):
def test_repr(self):
def test_KillFilter_no_raise(self):
def test_KillFilter_deleted_exe(self):
def _get_resource_type(self, path):
def _nvp_validate_ext_gw(self, router_id, l3_gw_uuid, vlan_id):
def get_all_networks(self, tenant_id):
def get_network(self, network_id):
def create_network(self, tenant_id, net_name):
def delete_network(self, net_id):
def update_network(self, tenant_id, net_id, param_data):
def get_all_ports(self, net_id):
def get_port(self, net_id, port_id):
def create_port(self, net_id):
def delete_port(self, net_id, port_id):
def update_port(self, net_id, port_id, **kwargs):
def plug_interface(self, net_id, port_id, int_id):
def unplug_interface(self, net_id, port_id):
def test_serialize_unknown_content_type(self):
def test_get_deserialize_handler_unknown_content_type(self):
def test_serialize_content_type_json(self):
def test_serialize_content_type_xml(self):
def test_deserialize_raise_bad_request(self):
def test_deserialize_json_content_type(self):
def test_deserialize_xml_content_type(self):
def test_deserialize_xml_content_type_with_meta(self):
def test_serialize_xml_root_key_is_dict(self):
def test_serialize_xml_root_key_is_list(self):
def test_get_deserializer(self):
def test_get_expected_content_type(self):
def test_get_action_args(self):
def test_deserialize(self):
def test_get_body_deserializer_unknown_content_type(self):
def test_serialize_unknown_content_type(self):
def test_get_body_serializer(self):
def test_get_serializer(self):
def test_dispatch(self):
def test_dispatch_action_None(self):
def test_default_raise_Malformed_Exception(self):
def test_default_raise_Malformed_Exception(self):
def _register_agent_states(self):
@classmethod DCNL def get_resources(cls):
def get_ofc_item_random_params(self):
def get_ofc_description(self, desc):
def get_random_params(self):
def testa_create_ofc_tenant(self):
def testb_exists_ofc_tenant(self):
def testc_delete_ofc_tenant(self):
def testd_create_ofc_network(self):
def teste_exists_ofc_network(self):
def testf_delete_ofc_network(self):
def testg_create_ofc_port(self):
def testh_exists_ofc_port(self):
def testi_delete_ofc_port(self):
def testj_create_ofc_packet_filter(self):
def testk_exists_ofc_packet_filter(self):
def testl_delete_ofc_packet_filter(self):
def setUp(self):
def get_ofc_item_random_params(self):
def get_portinfo_random_params(self):
def testa_add_ofc_item(self):
def testb_get_ofc_item(self):
def testb_get_ofc_id(self):
def testb_exists_ofc_item(self):
def testc_find_ofc_item(self):
def testc_del_ofc_item(self):
def testd_add_portinfo(self):
def teste_get_portinfo(self):
def testf_del_portinfo(self):
def get_ofc_item_random_params(self):
def get_ofc_item_random_params(self):
def mock_treat_devices_added(self, details, func_name):
def mock_treat_devices_added(self, details, port, func_name):
def test_vifport(self):
def _create_network(self, fmt, name, admin_state_up, **kwargs):
def test_vlan(self):
def test_create_network(self):
def test_create_port(self):
def setUp(self):
def test_a_create_network(self):
def test_b_nexus_delete_port(self):
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_interval=None, periodic_fuzzy_delay=None):
def kill(self):
def periodic_tasks(self, raise_on_error=False):
def report_state(self):
def format(self, record):
def formatException(self, exc_info, record=None):
def __init__(cls, names, bases, dict_):
def run_periodic_tasks(self, context, raise_on_error=False):
def __init__(self, topic, default_version):
def _set_version(self, msg, vers):
def _get_topic(self, topic):
def call(self, context, msg, topic=None, version=None, timeout=None):
def multicall(self, context, msg, topic=None, version=None, timeout=None):
def cast(self, context, msg, topic=None, version=None):
def fanout_cast(self, context, msg, topic=None, version=None):
def cast_to_server(self, context, server_params, msg, topic=None, version=None):
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None):
def __init__(self, conf, connection_pool, pooled=True, server_params=None):
def __enter__(self):
def _done(self):
def __exit__(self, exc_type, exc_value, tb):
def __del__(self):
def close(self):
def __getattr__(self, key):
def check_duplicate_message(self, message_data):
def wait(self):
def __init__(self, conf, callback, connection_pool):
def __call__(self, message_data):
def _process_data(self, ctxt, version, method, args):
def __iter__(self):
def __call__(self, data):
def __iter__(self):
def __init__(self, callbacks):
def dispatch(self, ctxt, version, method, **kwargs):
def register(self, key, host):
def ack_alive(self, key, host):
def is_alive(self, topic, host):
def expire(self, topic, host):
def send_heartbeats(self):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def send_heartbeats(self):
def ack_alive(self, key, host):
def backend_register(self, key, host):
def backend_unregister(self, key, key_host):
def register(self, key, host):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts):
def reconnect(self, session):
def consume(self):
def __init__(self, conf, session, msg_id, callback):
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None):
def __init__(self, conf, session, topic, callback):
def __init__(self, session, node_name, node_opts=None):
def reconnect(self, session):
def send(self, msg):
def __init__(self, conf, session, msg_id):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def reconnect(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
def socket_s(self):
def subscribe(self, msg_filter):
def unsubscribe(self, msg_filter):
def _get_response(self, ctx, proxy, topic, data):
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None):
def consume_in_thread(self):
def close(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name):
def consume_in_thread(self):
def elevated(self, read_deleted=None, overwrite=False):
def __init__(self, channel, callback, tag, **kwargs):
def reconnect(self, channel):
def consume(self, *args, **kwargs):
def cancel(self):
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, **kwargs):
def __init__(self, channel, exchange_name, routing_key, **kwargs):
def reconnect(self, channel):
def send(self, msg, timeout=None):
def __init__(self, conf, channel, msg_id, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def _fetch_ssl_params(self):
def _connect(self, params):
def reconnect(self):
def get_channel(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
def __init__(self, retvalue=True):
@classmethod DCNL def load_json(cls, data, default_rule=None):
def __init__(self, rules=None, default_rule=None):
def __missing__(self, key):
def __str__(self):
@abc.abstractmethod DCNL def __str__(self):
@abc.abstractmethod DCNL def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, kind, match):
def __str__(self):
def __init__(self, rule):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __new__(mcs, name, bases, cls_dict):
def __init__(self):
def reduce(self):
def shift(self, tok, value):
@property DCNL def result(self):
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2):
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2):
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check):
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2):
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check):
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __init__(self):
@staticmethod DCNL def run_service(service):
def launch_service(self, service):
def stop(self):
def wait(self):
def wait(self):
def __init__(self, package):
def __str__(self):
def __repr__(self):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def init_host(self):
def after_start(self):
def _run(self, application, socket):
def _populate_networks_cache(self):
def run(self):
def call_driver(self, action, network):
def sync_state(self):
def _periodic_resync_helper(self):
def periodic_resync(self):
def enable_dhcp_helper(self, network_id):
def disable_dhcp_helper(self, network_id):
def refresh_dhcp_helper(self, network_id):
@lockutils.synchronized('agent', 'dhcp-') DCNL def network_create_end(self, context, payload):
@lockutils.synchronized('agent', 'dhcp-') DCNL def network_update_end(self, context, payload):
@lockutils.synchronized('agent', 'dhcp-') DCNL def network_delete_end(self, context, payload):
@lockutils.synchronized('agent', 'dhcp-') DCNL def subnet_update_end(self, context, payload):
@lockutils.synchronized('agent', 'dhcp-') DCNL def subnet_delete_end(self, context, payload):
@lockutils.synchronized('agent', 'dhcp-') DCNL def port_update_end(self, context, payload):
@lockutils.synchronized('agent', 'dhcp-') DCNL def port_delete_end(self, context, payload):
def get_active_networks(self):
def get_network_info(self, network_id):
def get_dhcp_port(self, network_id, device_id):
def release_dhcp_port(self, network_id, device_id):
def release_port_fixed_ip(self, network_id, device_id, subnet_id):
def update_lease_expiration(self, network_id, ip_address, lease_remaining):
def get_interface_name(self, network, port=None):
def get_device_id(self, network):
def setup(self, network, reuse_existing=False):
def destroy(self, network, device_name):
def _handler(self, client_sock, client_addr):
def start(self):
def agent_updated(self, context, payload):
def daemonize(self):
def start(self):
def run(self):
def init_l3(self, device_name, ip_cidrs, namespace=None):
def plug(self, network_id, port_id, device_name, mac_address, bridge=None, namespace=None, prefix=None):
def unplug(self, device_name, bridge=None, namespace=None, prefix=None):
def plug(self, network_id, port_id, device_name, mac_address, bridge=None, namespace=None, prefix=None):
def unplug(self, device_name, bridge=None, namespace=None, prefix=None):
def get_pid_file_name(self, ensure_pids_dir=False):
@property DCNL def pid(self):
def garbage_collect_namespace(self):
def pullup_route(self, interface_name):
def restart(self):
@classmethod DCNL def existing_dhcp_networks(cls, conf, root_helper):
def _enable_dhcp(self):
def enable(self):
def disable(self, retain_port=False):
def get_conf_file_name(self, kind, ensure_conf_dir=False):
def _get_value_from_conf_file(self, kind, converter=None):
@property DCNL def pid(self):
@classmethod DCNL def existing_dhcp_networks(cls, conf, root_helper):
def spawn_process(self):
def reload_allocations(self):
def _output_hosts_file(self):
def _output_opts_file(self):
def _setup_chains(self):
def _remove_chains(self):
def add_chain(self, name, wrap=True):
def ensure_remove_chain(self, name, wrap=True):
def remove_chain(self, name, wrap=True):
def add_rule(self, chain, rule, wrap=True, top=False):
def remove_rule(self, chain, rule, wrap=True, top=False):
def empty_chain(self, chain, wrap=True):
@lockutils.synchronized('iptables', 'quantum-', external=True) DCNL def _apply(self):
def get_routers(self, context, fullsync=True, router_id=None):
def get_external_network_id(self, context):
def _destroy_router_namespaces(self, only_router_id=None):
def _fetch_external_net_id(self):
def router_deleted(self, context, router_id):
def routers_updated(self, context, routers):
def agent_updated(self, context, payload):
def prepare_port_filter(self, port):
def apply_port_filter(self, port):
def update_port_filter(self, port):
def remove_port_filter(self, port):
def filter_defer_apply_on(self):
def filter_defer_apply_off(self):
@property DCNL def ports(self):
@contextlib.contextmanager DCNL def defer_apply(self):
def security_groups_rule_updated(self, context, **kwargs):
def security_groups_member_updated(self, context, **kwargs):
def security_groups_provider_updated(self, context, **kwargs):
def security_groups_rule_updated(self, context, security_groups):
def security_groups_member_updated(self, context, security_groups):
def security_groups_provider_updated(self, context):
def tenant(self, request):
@classmethod DCNL def get_resources(cls):
@classmethod DCNL def get_resources(cls):
@classmethod DCNL def get_resources(cls):
def create_agent(self, context, agent):
@abstractmethod DCNL def delete_agent(self, context, id):
@abstractmethod DCNL def update_agent(self, context, agent):
@classmethod DCNL def get_resources(cls):
@classmethod DCNL def get_resources(cls):
@classmethod DCNL def get_resources(cls):
def create_for_sg(self, tenant_id, sg_id, sg_name):
def delete_for_sg(self, tenant_id, sg_id, sg_name):
def get_router_chains(self, tenant_id, router_id):
def create_router_chains(self, tenant_id, router_id):
def get_sg_chains(self, tenant_id, sg_id):
def create_subnet(self, context, subnet):
def get_subnet(self, context, id, fields=None):
def get_subnets(self, context, filters=None, fields=None):
def delete_subnet(self, context, id):
def create_network(self, context, network):
def update_network(self, context, id, network):
def get_network(self, context, id, fields=None):
def get_networks(self, context, filters=None, fields=None):
def delete_network(self, context, id):
def create_port(self, context, port):
def update_port(self, context, id, port):
def get_port(self, context, id, fields=None):
def get_ports(self, context, filters=None, fields=None):
def delete_port(self, context, id, l3_port_check=True):
def remove_router_interface(self, context, router_id, interface_info):
def create_security_group(self, context, security_group, default_sg=False):
def delete_security_group(self, context, id):
def match(self, prior, method_regexp, uri_regexp, handler, data=None, multi=True):
def server_failure(self, resp):
def action_success(self, resp):
def create_network(self, context, network):
def update_network(self, context, net_id, network):
def delete_network(self, context, net_id):
def create_port(self, context, port):
def update_port(self, context, port_id, port):
def delete_port(self, context, port_id, l3_port_check=True):
def _plug_interface(self, context, tenant_id, net_id, port_id, remote_interface_id):
def _unplug_interface(self, context, tenant_id, net_id, port_id):
def _send_all_data(self):
def _do_get(self, name, group=None):
def register_opts(self, opts, group_internal_name=None, group=None):
def _convert_to_nvp_rule(self, rule, with_id=False):
def _convert_to_nvp_rules(self, rules, with_id=False):
def _get_security_group_rules_nvp_format(self, context, security_group_id, with_id=False):
def _get_profile_uuid(self, context, remote_group_id):
def _remove_security_group_with_id_and_id_field(self, rules, rule_id):
def add_controller(self, ip, port, user, password, request_timeout, http_timeout, retries, redirects, default_tz_uuid, uuid=None, zone=None, default_l3_gw_service_uuid=None, default_l2_gw_service_uuid=None, default_interface_name=None):
def create_rpc_dispatcher(self):
def _build_ip_address_list(self, context, fixed_ips, subnet_ids=None):
def _get_port_by_device_id(self, context, device_id, device_owner):
def _find_router_subnets_cidrs(self, context, router_id):
def _nvp_create_port(self, context, port_data):
def _nvp_create_router_port(self, context, port_data):
def _nvp_create_ext_gw_port(self, context, port_data):
def _nvp_create_l2_gw_port(self, context, port_data):
def _nvp_get_port_id(self, context, cluster, quantum_port):
def _extend_fault_map(self):
def _find_target_cluster(self, resource):
def _get_lswitch_cluster_pairs(self, netw_id, tenant_id):
def delete_port(self, context, id, l3_port_check=True, nw_gw_port_check=True):
def _update_fip_assoc(self, context, fip, floatingip_db, external_port):
def create_network_gateway(self, context, network_gateway):
def delete_network_gateway(self, context, id):
def create_security_group(self, context, security_group, default_sg=False):
def delete_security_group(self, context, security_group_id):
def create_security_group_rule(self, context, security_group_rule):
def create_security_group_rule_bulk(self, context, security_group_rule):
def delete_security_group_rule(self, context, sgrid):
def _check_for_queue_and_create(self, context, port):
def _nvp_lqueue(self, queue):
@classmethod DCNL def get_resources(cls):
@classmethod DCNL def get_resources(cls):
def __init__(self, api_providers, user, password, request_timeout, http_timeout, retries, redirects, concurrent_connections=3, nvp_gen_timeout=(-1)):
def login(self, user=None, password=None):
def request(self, method, url, body='', content_type='application/json'):
def __init__(self, nvp_api_client, url, method='GET', body=None, headers=None, request_timeout=request.DEFAULT_REQUEST_TIMEOUT, retries=request.DEFAULT_RETRIES, auto_login=True, redirects=request.DEFAULT_REDIRECTS, http_timeout=request.DEFAULT_HTTP_TIMEOUT, client_conn=None):
@classmethod DCNL def _spawn(cls, func, *args, **kwargs):
def spawn(self, func, *args, **kwargs):
@classmethod DCNL def joinall(cls):
def join(self):
def start(self):
def copy(self):
def _run(self):
def _handle_request(self):
def api_providers(self):
def acquire_connection(self, auto_login=True, headers=None, rid=(-1)):
def release_connection(self, http_conn, bad_state=False, service_unavail=False, rid=(-1)):
def _wait_for_login(self, conn, headers=None):
def _get_provider_data(self, conn_or_conn_params, default=None):
def _set_provider_data(self, conn_or_conn_params, data):
def _normalize_conn_params(self, conn_or_conn_params):
def __init__(self, api_providers, user, password, concurrent_connections=client.DEFAULT_CONCURRENT_CONNECTIONS, nvp_gen_timeout=client.GENERATION_ID_TIMEOUT, use_https=True, connect_timeout=client.DEFAULT_CONNECT_TIMEOUT):
def acquire_redirect_connection(self, conn_params, auto_login=True, headers=None):
def _login(self, conn=None, headers=None):
def _issue_request(self):
def _redirect_params(self, conn, headers, allow_release_conn=False):
def _rid(self):
@property DCNL def request_error(self):
def _request_str(self, conn, url):
def prevent_network_gateway_port_deletion(self, context, port):
def create_network(self, context, network):
def update_network(self, context, net_id, network):
def delete_network(self, context, net_id):
def create_port(self, context, port):
def update_port(self, context, port_id, port):
def delete_port(self, context, port_id):
def create_subnet(self, context, subnet):
def delete_subnet(self, context, subnet_id):
def update_subnet(self, context, subnet_id, subnet):
def device_exists(self, device):
def ensure_vlan_bridge(self, network_id, physical_interface, vlan_id):
def ensure_flat_bridge(self, network_id, physical_interface):
def ensure_local_bridge(self, network_id):
def ensure_vlan(self, physical_interface, vlan_id):
def ensure_bridge(self, bridge_name, interface=None, ips=None, gateway=None):
def add_tap_interface(self, network_id, physical_network, vlan_id, tap_device_name):
def create_rpc_dispatcher(self):
def create_rpc_dispatcher(self):
def get_device_details(self, rpc_context, **kwargs):
def update_device_down(self, rpc_context, **kwargs):
def update_device_up(self, rpc_context, **kwargs):
def __init__(self, host='127.0.0.1', port=8888, use_ssl=False, key_file=None, cert_file=None):
def get_connection_type(self):
def _generate_pfc_str(self, raw_str):
def _generate_pfc_id(self, id_str):
def _generate_pfc_description(self, desc):
def update_ports(self, context, agent_id, datapath_id, port_added, port_removed):
def __init__(self, integ_br, root_helper, polling_interval):
def daemon_loop(self):
def _update_resource_status(self, context, resource, id, status):
def activate_port_if_ready(self, context, port, network=None):
def deactivate_port(self, context, port):
def create_network(self, context, network):
def update_network(self, context, id, network):
def delete_network(self, context, id):
def create_port(self, context, port):
def update_port(self, context, id, port):
def delete_port(self, context, id, l3_port_check=True):
def _activate_packet_filter_if_ready(self, context, packet_filter, network=None, in_port=None):
def _deactivate_packet_filter(self, context, packet_filter):
def create_packet_filter(self, context, packet_filter):
def update_packet_filter(self, context, id, packet_filter):
def delete_packet_filter(self, context, id):
def create_rpc_dispatcher(self):
def update_ports(self, rpc_context, **kwargs):
@abstractmethod DCNL def create_tenant(self, description, tenant_id=None):
@abstractmethod DCNL def delete_tenant(self, ofc_tenant_id):
@abstractmethod DCNL def create_network(self, ofc_tenant_id, description, network_id=None):
@abstractmethod DCNL def delete_network(self, ofc_network_id):
@abstractmethod DCNL def create_port(self, ofc_network_id, portinfo, port_id=None):
@abstractmethod DCNL def delete_port(self, ofc_port_id):
@abstractmethod DCNL def convert_ofc_tenant_id(self, context, ofc_tenant_id):
@abstractmethod DCNL def convert_ofc_network_id(self, context, ofc_network_id, tenant_id):
@abstractmethod DCNL def convert_ofc_port_id(self, context, ofc_port_id, tenant_id, network_id):
def _find_key(self, session, last_key):
def sync_vlan_allocations(self, network_vlan_ranges):
def create_rpc_dispatcher(self):
def get_device_details(self, rpc_context, **kwargs):
def update_device_down(self, rpc_context, **kwargs):
def tunnel_sync(self, rpc_context, **kwargs):
def _check_job_status(self, ret_val, jobpath):
def _create_switch_port(self, vswitch_name, switch_port_name):
def disconnect_switch_port(self, vswitch_name, switch_port_name, delete_port):
def __eq__(self, other):
def __init__(self, integ_br, tun_br, local_ip, bridge_mappings, root_helper, polling_interval, enable_tunneling):
def create_rpc_dispatcher(self):
def provision_local_vlan(self, net_uuid, network_type, physical_network, segmentation_id):
def reclaim_local_vlan(self, net_uuid, lvm):
def port_bound(self, port, net_uuid, network_type, physical_network, segmentation_id):
def port_unbound(self, vif_id, net_uuid=None):
def port_dead(self, port):
def setup_integration_br(self, bridge_name):
def setup_tunnel_br(self, tun_br):
def setup_physical_bridges(self, bridge_mappings):
def create_rpc_dispatcher(self):
def get_device_details(self, rpc_context, **kwargs):
def update_device_down(self, rpc_context, **kwargs):
def update_device_up(self, rpc_context, **kwargs):
def tunnel_sync(self, rpc_context, **kwargs):
def _get_state_file_path(self, pool_id, kind, ensure_state_dir=True):
def reload_pool(self, context, pool_id=None, host=None):
def modify_pool(self, context, pool_id=None, host=None):
def destroy_pool(self, context, pool_id=None, host=None):
def pool_destroyed(self, context, pool_id=None, host=None):
def __init__(self):
@abc.abstractmethod DCNL def get_plugin_type(self):
@abc.abstractmethod DCNL def get_plugin_name(self):
@abc.abstractmethod DCNL def get_plugin_description(self):
def __init__(self, ctxt):
def get_next_vlan(self, vlan_id=None):
def release_vlan(self, vlan_id):
def connect(self, host, username, password):
def create_network(self, host, username, password, net_id):
def delete_network(self, host, username, password, net_id):
def associate_mac_to_network(self, host, username, password, net_id, mac):
def dissociate_mac_from_network(self, host, username, password, net_id, mac):
def create_vlan_interface(self, mgr, vlan_id):
def delete_vlan_interface(self, mgr, vlan_id):
def get_port_profiles(self, mgr):
def get_port_profile(self, mgr, name):
def create_port_profile(self, mgr, name):
def delete_port_profile(self, mgr, name):
def activate_port_profile(self, mgr, name):
def deactivate_port_profile(self, mgr, name):
def associate_mac_to_port_profile(self, mgr, name, mac_address):
def dissociate_mac_from_port_profile(self, mgr, name, mac_address):
def create_vlan_profile_for_port_profile(self, mgr, name):
def configure_l2_mode_for_vlan_profile(self, mgr, name):
def configure_trunk_mode_for_vlan_profile(self, mgr, name):
def configure_allowed_vlans_for_vlan_profile(self, mgr, name, vlan_id):
def connect(self, host, username, password):
def create_network(self, host, username, password, net_id):
def delete_network(self, host, username, password, net_id):
def associate_mac_to_network(self, host, username, password, net_id, mac):
def dissociate_mac_from_network(self, host, username, password, net_id, mac):
def create_vlan_interface(self, mgr, vlan_id):
def delete_vlan_interface(self, mgr, vlan_id):
def get_port_profiles(self, mgr):
def get_port_profile(self, mgr, name):
def create_port_profile(self, mgr, name):
def delete_port_profile(self, mgr, name):
def activate_port_profile(self, mgr, name):
def deactivate_port_profile(self, mgr, name):
def associate_mac_to_port_profile(self, mgr, name, mac_address):
def dissociate_mac_from_port_profile(self, mgr, name, mac_address):
def create_vlan_profile_for_port_profile(self, mgr, name):
def configure_l2_mode_for_vlan_profile(self, mgr, name):
def configure_trunk_mode_for_vlan_profile(self, mgr, name):
def configure_allowed_vlans_for_vlan_profile(self, mgr, name, vlan_id):
def create_rpc_dispatcher(self):
@classmethod DCNL def get_port_from_device(cls, device):
def get_device_details(self, rpc_context, **kwargs):
def update_device_down(self, rpc_context, **kwargs):
def __init__(self):
def brocade_init(self):
def create_network(self, context, network):
def delete_network(self, context, net_id):
def create_port(self, context, port):
def get_plugin_version(self):
@staticmethod DCNL def mac_reformat_62to34(interface_mac):
def __init__(self):
def __getattribute__(self, name):
def _func_name(self, offset=0):
def _invoke_plugin_per_device(self, plugin_key, function_name, args):
def _invoke_inventory(self, plugin_key, function_name, args):
def _invoke_plugin(self, plugin_key, function_name, args, kwargs):
def create_network(self, context, network):
def update_network(self, context, id, network):
def delete_network(self, context, id):
def get_network(self, context, id, fields=None):
def get_networks(self, context, filters=None, fields=None):
def create_port(self, context, port):
def get_port(self, context, id, fields=None):
def get_ports(self, context, filters=None, fields=None):
def update_port(self, context, id, port):
def delete_port(self, context, id):
def create_subnet(self, context, subnet):
def update_subnet(self, context, id, subnet):
def get_subnet(self, context, id, fields=None):
def delete_subnet(self, context, id, kwargs):
def get_subnets(self, context, filters=None, fields=None):
@staticmethod DCNL def put_credential(cred_name, username, password):
@staticmethod DCNL def get_username(cred_name):
@staticmethod DCNL def get_password(cred_name):
@staticmethod DCNL def get_credential(cred_name):
@staticmethod DCNL def delete_credential(cred_name):
def __init__(self, exception):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req):
def dummy(self, section, key):
def __setitem__(self, key, value):
def __getitem__(self, key):
def get(self, key, default=None):
def __iter__(self):
def next(self):
def update(self, values):
def iteritems(self):
def update(self, values):
def iteritems(self):
def __setitem__(self, key, value):
def __getitem__(self, key):
def get(self, key, default=None):
def __iter__(self):
def next(self):
def update(self, values):
def iteritems(self):
def create_request(self, path, body, content_type, method='GET'):
def _create_network(self, name=None):
def _create_port(self, network_id, port_state):
def _delete_port(self, network_id, port_id):
def _delete_network(self, network_id):
def tear_down_port_network(self, net_id, port_id):
def setUp(self):
def test_create_qos(self):
def test_create_qosBADRequest(self):
def test_list_qoss(self):
def test_show_qos(self):
def test_show_qosDNE(self, qos_id='100'):
def test_update_qos(self):
def test_update_qosDNE(self, qos_id='100'):
def test_update_qosBADRequest(self):
def test_delete_qos(self):
def test_delete_qosDNE(self, qos_id='100'):
def tearDownQos(self, delete_profile_path):
def setUp(self):
def test_list_credentials(self):
def test_create_credential(self):
def test_create_credentialBADRequest(self):
def test_show_credential(self):
def test_show_credentialDNE(self, credential_id='100'):
def test_update_credential(self):
def test_update_credBADReq(self):
def test_update_credentialDNE(self, credential_id='100'):
def test_delete_credential(self):
def test_delete_credentialDNE(self, credential_id='100'):
def nxos_connect(self, nexus_host, nexus_ssh_port, nexus_user, nexus_password):
def create_xml_snippet(self, cutomized_config):
def enable_vlan(self, mgr, vlanid, vlanname):
def disable_vlan(self, mgr, vlanid):
def enable_port_trunk(self, mgr, interface):
def disable_switch_port(self, mgr, interface):
def enable_vlan_on_trunk_int(self, mgr, interface, vlanid):
def disable_vlan_on_trunk_int(self, mgr, interface, vlanid):
def create_vlan(self, vlan_name, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port, vlan_ids):
def delete_vlan(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port):
def build_vlans_cmd(self):
def add_vlan_int(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port, vlan_ids=None):
def remove_vlan_int(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port):
def get_all_nexusportbindings(self):
def get_nexusportbinding(self, vlan_id):
def create_nexusportbinding(self, port_id, vlan_id):
def delete_nexusportbinding(self, vlan_id):
def update_nexusport_binding(self, port_id, new_vlan_id):
def get_all_vlan_bindings(self):
def get_vlan_binding(self, network_id):
def create_vlan_binding(self, vlan_id, vlan_name, network_id):
def delete_vlan_binding(self, network_id):
def update_vlan_binding(self, network_id, vlan_id, vlan_name):
def get_all_networks(self, tenant_id):
def get_network(self, network_id):
def create_network(self, tenant_id, net_name):
def delete_network(self, net_id):
def update_network(self, tenant_id, net_id, **kwargs):
def get_all_ports(self, net_id):
def get_port(self, net_id, port_id):
def create_port(self, net_id):
def delete_port(self, net_id, port_id):
def update_port(self, net_id, port_id, port_state):
def plug_interface(self, net_id, port_id, int_id):
def unplug_interface(self, net_id, port_id):
def testa_create_nexusportbinding(self):
def testb_getall_nexusportbindings(self):
def testc_delete_nexusportbinding(self):
def testd_update_nexusportbinding(self):
def tearDown_nexusportbinding(self):
def setUp(self):
def testa_create_vlanbinding(self):
def testb_getall_vlanbindings(self):
def testc_delete_vlanbinding(self):
def testd_update_vlanbinding(self):
def testm_test_vlanids(self):
def teardown_network(self):
def teardown_port(self):
def teardown_vlanbinding(self):
def setUp(self):
def testa_create_network(self):
def testb_get_networks(self):
def testc_delete_network(self):
def testd_update_network(self):
def teste_create_port(self):
def testf_delete_port(self):
def testg_plug_unplug_interface(self):
def testh_joined_test(self):
def teardown_network_port(self):
def teardown_joined_test(self):
@abstractmethod DCNL def get_all_networks(self, tenant_id, **kwargs):
@abstractmethod DCNL def create_network(self, tenant_id, net_name, net_id, vlan_name, vlan_id, **kwargs):
@abstractmethod DCNL def delete_network(self, tenant_id, net_id, **kwargs):
@abstractmethod DCNL def get_network_details(self, tenant_id, net_id, **kwargs):
@abstractmethod DCNL def update_network(self, tenant_id, net_id, name, **kwargs):
@abstractmethod DCNL def get_all_ports(self, tenant_id, net_id, **kwargs):
@abstractmethod DCNL def create_port(self, tenant_id, net_id, port_state, port_id, **kwargs):
@abstractmethod DCNL def delete_port(self, tenant_id, net_id, port_id, **kwargs):
@abstractmethod DCNL def update_port(self, tenant_id, net_id, port_id, **kwargs):
@abstractmethod DCNL def get_port_details(self, tenant_id, net_id, port_id, **kwargs):
@abstractmethod DCNL def plug_interface(self, tenant_id, net_id, port_id, remote_interface_id, **kwargs):
@abstractmethod DCNL def unplug_interface(self, tenant_id, net_id, port_id, **kwargs):
def create_subnet(self, tenant_id, net_id, ip_version, subnet_cidr, **kwargs):
def get_subnets(self, tenant_id, net_id, **kwargs):
def get_subnet(self, tenant_id, net_id, subnet_id, **kwargs):
def update_subnet(self, tenant_id, net_id, subnet_id, **kwargs):
def delete_subnet(self, tenant_id, net_id, subnet_id, **kwargs):
@classmethod DCNL def __subclasshook__(cls, klass):
def __init__(self):
def __getattribute__(self, name):
def __getattr__(self, name):
def create_network(self, context, network):
def update_network(self, context, id, network):
def delete_network(self, context, id):
def get_network(self, context, id, fields=None):
def get_networks(self, context, filters=None, fields=None):
def create_port(self, context, port):
def delete_port(self, context, id):
def update_port(self, context, id, port):
def create_subnet(self, context, subnet):
def update_subnet(self, context, id, subnet):
def delete_subnet(self, context, id):
def get_all_qoss(self, tenant_id):
def get_qos_details(self, tenant_id, qos_id):
def create_qos(self, tenant_id, qos_name, qos_desc):
def delete_qos(self, tenant_id, qos_id):
def rename_qos(self, tenant_id, qos_id, new_name):
def get_all_credentials(self, tenant_id):
def get_credential_details(self, tenant_id, credential_id):
def create_credential(self, tenant_id, credential_name, user_name, password):
def delete_credential(self, tenant_id, credential_id):
def rename_credential(self, tenant_id, credential_id, new_name):
def schedule_host(self, tenant_id, instance_id, instance_desc):
def associate_port(self, tenant_id, instance_id, instance_desc):
def detach_port(self, tenant_id, instance_id, instance_desc):
def _invoke_device_plugins(self, function_name, args):
def _func_name(self, offset=0):
@classmethod DCNL def get_name(cls):
@classmethod DCNL def get_alias(cls):
@classmethod DCNL def get_description(cls):
@classmethod DCNL def get_namespace(cls):
@classmethod DCNL def get_updated(cls):
@classmethod DCNL def get_resources(cls):
def index(self, request, tenant_id):
def _items(self, request, tenant_id, is_detail):
def show(self, request, tenant_id, id):
def create(self, request, tenant_id):
def update(self, request, tenant_id, id):
def delete(self, request, tenant_id, id):
def __init__(self, base_url):
def build(self, credential_data, is_detail=False):
def _build_simple(self, credential_data):
def _build_detail(self, credential_data):
def __init__(self, base_url):
def build(self, qos_data, is_detail=False):
def _build_simple(self, qos_data):
def _build_detail(self, qos_data):
@classmethod DCNL def get_name(cls):
@classmethod DCNL def get_alias(cls):
@classmethod DCNL def get_description(cls):
@classmethod DCNL def get_namespace(cls):
@classmethod DCNL def get_updated(cls):
@classmethod DCNL def get_resources(cls):
def index(self, request, tenant_id):
def _items(self, request, tenant_id, is_detail):
def show(self, request, tenant_id, id):
def create(self, request, tenant_id):
def update(self, request, tenant_id, id):
def delete(self, request, tenant_id, id):
def nxos_connect(self, nexus_host, nexus_ssh_port, nexus_user, nexus_password):
def create_xml_snippet(self, cutomized_config):
def enable_vlan(self, mgr, vlanid, vlanname):
def disable_vlan(self, mgr, vlanid):
def enable_port_trunk(self, mgr, interface):
def disable_switch_port(self, mgr, interface):
def enable_vlan_on_trunk_int(self, mgr, interface, vlanid):
def disable_vlan_on_trunk_int(self, mgr, interface, vlanid):
def create_vlan(self, vlan_name, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port, vlan_ids=None):
def delete_vlan(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port):
def build_vlans_cmd(self):
def add_vlan_int(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port, vlan_ids=None):
def remove_vlan_int(self, vlan_id, nexus_host, nexus_user, nexus_password, nexus_ports, nexus_ssh_port):
def __init__(self):
def get_all_networks(self, tenant_id):
def create_network(self, tenant_id, net_name, net_id, vlan_name, vlan_id, host, instance):
def delete_network(self, tenant_id, net_id, **kwargs):
def get_network_details(self, tenant_id, net_id, **kwargs):
def update_network(self, tenant_id, net_id, **kwargs):
def get_all_ports(self, tenant_id, net_id, **kwargs):
def create_port(self, tenant_id, net_id, port_state, port_id, **kwargs):
def delete_port(self, device_id, vlan_id):
def update_port(self, tenant_id, net_id, port_id, port_state, **kwargs):
def get_port_details(self, tenant_id, net_id, port_id, **kwargs):
def plug_interface(self, tenant_id, net_id, port_id, remote_interface_id, **kwargs):
def unplug_interface(self, tenant_id, net_id, port_id, **kwargs):
def _get_vlan_id_for_network(self, tenant_id, network_id, context, base_plugin_ref):
def _get_network(self, tenant_id, network_id, context, base_plugin_ref):
def _get_quotas(self, context, resources, keys):
def limit_check(self, context, tenant_id, resources, values):
def __init__(self, name, flag):
@property DCNL def default(self):
def __init__(self, name, count, flag=None):
def __init__(self, quota_driver_class=None):
def register_resource(self, resource):
def register_resource_by_name(self, resourcename):
def register_resources(self, resources):
def count(self, context, resource, *args, **kwargs):
def limit_check(self, context, tenant_id, **values):
@abstractmethod DCNL def create_subnet(self, context, subnet):
@abstractmethod DCNL def update_subnet(self, context, id, subnet):
@abstractmethod DCNL def get_subnet(self, context, id, fields=None):
@abstractmethod DCNL def get_subnets(self, context, filters=None, fields=None, sorts=None, limit=None, marker=None, page_reverse=False):
def get_subnets_count(self, context, filters=None):
@abstractmethod DCNL def delete_subnet(self, context, id):
@abstractmethod DCNL def create_network(self, context, network):
@abstractmethod DCNL def update_network(self, context, id, network):
@abstractmethod DCNL def get_network(self, context, id, fields=None):
@abstractmethod DCNL def get_networks(self, context, filters=None, fields=None, sorts=None, limit=None, marker=None, page_reverse=False):
def get_networks_count(self, context, filters=None):
@abstractmethod DCNL def delete_network(self, context, id):
@abstractmethod DCNL def create_port(self, context, port):
@abstractmethod DCNL def update_port(self, context, id, port):
@abstractmethod DCNL def get_port(self, context, id, fields=None):
@abstractmethod DCNL def get_ports(self, context, filters=None, fields=None, sorts=None, limit=None, marker=None, page_reverse=False):
def get_ports_count(self, context, filters=None):
@abstractmethod DCNL def delete_port(self, context, id):
def start(self, application, port, host='0.0.0.0', backlog=128):
def wait(self):
def _run(self, application, socket):
@classmethod DCNL def factory(cls, global_config, **local_config):
def process_request(self, req):
def process_response(self, response):
def best_match_content_type(self):
def dispatch(self, *args, **kwargs):
def __init__(self, metadata=None, xmlns=None):
def default(self, data):
def _to_xml_node(self, parent, metadata, nodename, data, used_prefixes):
def serialize(self, response_data, content_type, action='default'):
def __init__(self, metadata=None):
def _from_xml_node(self, node, listnames):
def deserialize(self, request):
def get_action_args(self, request_environment):
@classmethod DCNL def factory(cls, global_config, **local_config):
def __call__(self, environ, start_response):
@staticmethod DCNL def print_generator(app_iter):
@classmethod DCNL def factory(cls, global_config, **local_config):
def __init__(self, mapper):
@webob.dec.wsgify DCNL def __call__(self, req):
@staticmethod DCNL @webob.dec.wsgify DCNL def _dispatch(req):
def __init__(self, controller, fault_body_function, deserializer=None, serializer=None):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
def dispatch(self, request, action, action_args):
def __init__(self, exception, xmlns=None, body_function=None):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
def _serialize(self, data, content_type, default_xmlns):
def _deserialize(self, data, content_type):
def get_default_xmlns(self, req):
def __init__(self, metadata=None, default_xmlns=None):
def serialize(self, data, content_type):
def deserialize(self, datastring, content_type):
def schedule(self, plugin, context, network):
def auto_schedule_networks(self, plugin, context, host):
def auto_schedule_routers(self, plugin, context, host, router_id):
def schedule(self, plugin, context, sync_router):
def __init__(self, user_id, tenant_id, is_admin=None, read_deleted='no', roles=None, timestamp=None, **kwargs):
def elevated(self, read_deleted=None):
def match(self, userargs):
def get_command(self, userargs):
def get_environment(self, userargs):
def match(self, userargs):
def match(self, userargs):
def get_help_text(self, extra_context=None):
def add_error(self, message):
def handle(self, request, context):
def prepare_action_context(self, request, context):
def get_id(self):
def contribute(self, data, context):
def render(self):
def get_help_text(self):
def add_error(self, message):
def get_step(self, slug):
def get_entry_point(self):
@classmethod DCNL def register(cls, step_class):
@classmethod DCNL def unregister(cls, step_class):
def validate(self, context):
def is_valid(self):
def finalize(self):
def handle(self, request, context):
def get_success_url(self):
def format_status_message(self, message):
def render(self):
def get_absolute_url(self):
def add_error_to_step(self, message, slug):
def get_initial(self):
def get_workflow(self):
def get_context_data(self, **kwargs):
def get_template_names(self):
def get(self, request, *args, **kwargs):
def post(self, request, *args, **kwargs):
def get_raw_data(self, datum):
def get_data(self, datum):
def get_link_url(self, datum):
def get_summation(self):
def load_cells(self, datum=None):
def get_cells(self):
def get_data(self, request, obj_id):
@property DCNL def value(self):
@property DCNL def status(self):
def get_status_class(self, status):
def get_default_classes(self):
def render(self):
def get_absolute_url(self):
def get_empty_message(self):
def get_object_by_id(self, lookup):
@property DCNL def has_actions(self):
@property DCNL def needs_form_wrapper(self):
def get_table_actions(self):
def get_row_actions(self, datum):
def render_table_actions(self):
def render_row_actions(self, datum):
@staticmethod DCNL def parse_action(action_string):
def take_action(self, action_name, obj_id=None, obj_ids=None):
@classmethod DCNL def check_handler(cls, request):
def maybe_preempt(self):
def maybe_handle(self):
def sanitize_id(self, obj_id):
def get_object_id(self, datum):
def get_object_display(self, datum):
def has_more_data(self):
def get_marker(self):
def get_pagination_string(self):
def calculate_row_status(self, statuses):
def get_row_status_class(self, status):
def get_columns(self):
def get_rows(self):
def data_type_matched(self, datum):
def allowed(self, request, datum):
def update(self, request, datum):
def get_default_classes(self):
def get_default_attrs(self):
def get_param_name(self):
def get_link_url(self, datum=None):
def get_param_name(self):
def filter(self, table, data, filter_string):
def get_fixed_buttons(self):
def categorize(self, table, images):
def _conjugate(self, items=None, past=False):
def action(self, request, datum_id):
def update(self, request, datum):
def get_success_url(self, request=None):
def _register(self, cls):
def _unregister(self, cls):
def get_absolute_url(self):
def get_panel(self, panel):
def get_panels(self):
def get_absolute_url(self):
def _autodiscover(self):
@classmethod DCNL def register(cls, panel):
@classmethod DCNL def unregister(cls, panel):
def register(self, dashboard):
def unregister(self, dashboard):
def get_dashboard(self, dashboard):
def get_dashboards(self):
def get_default_dashboard(self):
def get_user_home(self, user):
def get_absolute_url(self):
@property DCNL def _lazy_urls(self):
def _urls(self):
def _autodiscover(self):
def set_tables(self, tables):
def render(self):
def render(self, datestring):
def get_traceback_frame_variables(self, request, tb_frame):
def api_error(self, message):
def get_object_id(self, obj):
def get_object_display(self, obj):
def get_form(self, form_class):
def _reload_urls(self):
def test_registry(self):
def test_horizon_test_isolation_1(self):
def test_horizon_test_isolation_2(self):
def test_table_instantiation(self):
def render_template_tag(self, tag_name, tag_require=''):
def test_site_branding_tag(self):
def assertNoMessages(self, response=None):
def assertMessageCount(self, response=None, **kwargs):
def load_tab_data(self):
def get_id(self):
def get_default_classes(self):
def tabs_not_available(self):
def render(self):
def get_tabs(self):
def get_tab(self, tab_name, allow_disabled=False):
def get_selected_tab(self):
def is_active(self):
def render(self):
def get_id(self):
def get_default_classes(self):
def get_template_name(self, request):
def get_context_data(self, request):
def enabled(self, request):
def allowed(self, request):
def load_table_data(self):
def get_context_data(self, request):
def get_tabs(self, request, **kwargs):
def get_context_data(self, **kwargs):
def handle_tabbed_response(self, tab_group, context):
def load_tabs(self):
def get_tables(self):
def handle_table(self, table_dict):
def get_data(self, request, context, *args, **kwargs):
def process_request(self, request):
def process_exception(self, request, exception):
def process_response(self, request, response):
def get_default_classes(self):
def get_default_attrs(self):
def get_final_attrs(self):
@property DCNL def attr_string(self):
@property DCNL def class_string(self):
def __repr__(self):
def __get__(self, obj, objtype):
@property DCNL def rules(self):
@abc.abstractmethod DCNL def list_pools(self):
@abc.abstractmethod DCNL def list(self):
@abc.abstractmethod DCNL def get(self, floating_ip_id):
@abc.abstractmethod DCNL def allocate(self, pool=None):
@abc.abstractmethod DCNL def release(self, floating_ip_id):
@abc.abstractmethod DCNL def associate(self, floating_ip_id, port_id):
@abc.abstractmethod DCNL def disassociate(self, floating_ip_id, port_id):
@abc.abstractmethod DCNL def list_targets(self):
@abc.abstractmethod DCNL def get_target_id_by_instance(self, instance_id):
@abc.abstractmethod DCNL def is_simple_associate_supported(self):
def add_quota(self, quota):
def tally(self, name, value):
def update_available(self, name):
def get_success_url(self, request=None):
@property DCNL def objects(self):
def get_objects_data(self):
def get_subfolders_data(self):
def _setup_subnet_parameters(self, params, data, is_create=True):
def _delete_network(self, request, network):
def test_no_location_or_file(self):
@override_settings(HORIZON_IMAGES_ALLOW_UPLOAD=False) DCNL def test_image_upload_disabled(self):
def clean(self):
def filter(self, table, users, filter_string):
def filter(self, table, tenants, filter_string):
def __init__(self, package):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def test_remove_tenant_user(self):
def assertRedirectsNoFollow(self, response, expected_url):
def assertNoFormErrors(self, response, context_name='form'):
def assertFormErrors(self, response, count=0, message=None, context_name='form'):
def add(self, *args):
def list(self):
def filter(self, filtered=None, **kwargs):
def get(self, **kwargs):
def first(self):
def test_canonical_string(self):
def GET(self, env, start_response):
def GET(self, env, start_response):
def PUT(self, env, start_response):
def DELETE(self, env, start_response):
def POST(self, env, start_response):
def HEAD(self, env, start_response):
def GET(self, env, start_response):
def PUT(self, env, start_response):
def DELETE(self, env, start_response):
def fake_tem_init(self):
def test_wrong_project_id(self):
def test_multiple_samples(self):
def test_missing_mandatory_fields(self):
def test_multiple_sources(self):
def test_multiple_samples_some_null_sources(self):
def test_bogus_request(self):
def publish_counters(self, context, counters, source):
def publish_counters(self, context, counters, source):
def publish_counters(self, context, counters, source):
@wsme_pecan.wsexpose([Sample], [Query], int) DCNL def get_all(self, q=[], limit=None):
@wsme.validate([Sample]) DCNL @wsme_pecan.wsexpose([Sample], body=[Sample]) DCNL def post(self, body):
@wsme_pecan.wsexpose([Statistics], [Query], int) DCNL def statistics(self, q=[], period=None):
@wsme_pecan.wsexpose([Meter], [Query]) DCNL def get_all(self, q=[]):
@wsme_pecan.wsexpose(Resource, unicode) DCNL def get_one(self, resource_id):
@wsme_pecan.wsexpose([Resource], [Query]) DCNL def get_all(self, q=[]):
@wsme.validate(Alarm) DCNL @wsme_pecan.wsexpose(Alarm, body=Alarm, status_code=201) DCNL def post(self, data):
@wsme.validate(Alarm) DCNL @wsme_pecan.wsexpose(Alarm, wtypes.text, body=Alarm) DCNL def put(self, alarm_id, data):
@wsme_pecan.wsexpose(None, wtypes.text, status_code=204) DCNL def delete(self, alarm_id):
@wsme_pecan.wsexpose(Alarm, wtypes.text) DCNL def get_one(self, alarm_id):
@wsme_pecan.wsexpose([Alarm], [Query]) DCNL def get_all(self, q=[]):
def __init__(self, url, token=None):
def iter_probes(self):
@staticmethod DCNL def get_kwapi_client(ksclient):
def iter_probes(self, ksclient):
def get_counters(self, manager):
def poll_and_publish(self):
def _check_counters(self):
def _publish_counters(self, start, ctxt, counters, source):
def flush(self, ctxt, source):
def __init__(self, cfg, transformer_manager):
def publisher(self, context, source):
def format(self, record):
def formatException(self, exc_info, record=None):
@abc.abstractmethod DCNL def serialize_entity(self, context, entity):
@abc.abstractmethod DCNL def deserialize_entity(self, context, entity):
def __init__(self, topic, default_version, version_cap=None, serializer=None):
def _set_version(self, msg, vers):
def _get_topic(self, topic):
def can_send_version(self, version):
def _serialize_msg_args(self, context, kwargs):
def call(self, context, msg, topic=None, version=None, timeout=None):
def multicall(self, context, msg, topic=None, version=None, timeout=None):
def cast(self, context, msg, topic=None, version=None):
def fanout_cast(self, context, msg, topic=None, version=None):
def cast_to_server(self, context, server_params, msg, topic=None, version=None):
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None):
def __init__(self, conf, connection_pool, pooled=True, server_params=None):
def __enter__(self):
def _done(self):
def __exit__(self, exc_type, exc_value, tb):
def __del__(self):
def close(self):
def __getattr__(self, key):
def check_duplicate_message(self, message_data):
def wait(self):
def __init__(self, conf, callback, connection_pool):
def __call__(self, message_data):
def _process_data(self, ctxt, version, method, namespace, args):
def __iter__(self):
def __init__(self, callbacks, serializer=None):
def _deserialize_args(self, context, kwargs):
def dispatch(self, ctxt, version, method, namespace, **kwargs):
def register(self, key, host):
def ack_alive(self, key, host):
def is_alive(self, topic, host):
def expire(self, topic, host):
def send_heartbeats(self):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def send_heartbeats(self):
def ack_alive(self, key, host):
def backend_register(self, key, host):
def backend_unregister(self, key, key_host):
def register(self, key, host):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts):
def reconnect(self, session):
def _unpack_json_msg(self, msg):
def consume(self):
def __init__(self, conf, session, msg_id, callback):
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None):
def __init__(self, conf, session, topic, callback):
def __init__(self, session, node_name, node_opts=None):
def reconnect(self, session):
def _pack_json_msg(self, msg):
def send(self, msg):
def __init__(self, conf, session, msg_id):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def reconnect(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
def socket_s(self):
def subscribe(self, msg_filter):
def unsubscribe(self, msg_filter):
def _get_response(self, ctx, proxy, topic, data):
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None):
def consume_in_thread(self):
def __init__(self, info=None, topic=None, method=None):
def close(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name):
def consume_in_thread(self):
def elevated(self, read_deleted=None, overwrite=False):
def __init__(self, channel, callback, tag, **kwargs):
def reconnect(self, channel):
def consume(self, *args, **kwargs):
def cancel(self):
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, **kwargs):
def __init__(self, channel, exchange_name, routing_key, **kwargs):
def reconnect(self, channel):
def send(self, msg, timeout=None):
def __init__(self, conf, channel, msg_id, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def _fetch_ssl_params(self):
def _connect(self, params):
def reconnect(self):
def get_channel(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
def save(self, session=None):
def update(self, values):
def iteritems(self):
def soft_delete(self, session=None):
@lockutils.synchronized('dbapi_backend', 'ceilometer-') DCNL def __get_backend(self):
def __init__(self, retvalue=True):
@classmethod DCNL def load_json(cls, data, default_rule=None):
def __init__(self, rules=None, default_rule=None):
def __missing__(self, key):
def __str__(self):
def set_rules(self, rules, overwrite=True):
def clear(self):
def load_rules(self, force_reload=False):
def _get_policy_path(self):
def enforce(self, rule, target, creds, do_raise=False, exc=None, *args, **kwargs):
@abc.abstractmethod DCNL def __str__(self):
@abc.abstractmethod DCNL def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, kind, match):
def __str__(self):
def __init__(self, rule):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __new__(mcs, name, bases, cls_dict):
def __init__(self):
def reduce(self):
def shift(self, tok, value):
@property DCNL def result(self):
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2):
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2):
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check):
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2):
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check):
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check):
def __call__(self, target, creds, enforcer):
def __call__(self, target, creds, enforcer):
def __call__(self, target, creds, enforcer):
def __call__(self, target, creds, enforcer):
def __init__(self):
@staticmethod DCNL def run_service(service):
def launch_service(self, service):
def stop(self):
def wait(self):
def wait(self):
def __init__(self, locale, target):
def __init__(self, **kwargs):
def flush(self, context, source):
def iter_images(self, ksclient):
@staticmethod DCNL def get_exchange_topics(conf):
def __init__(self):
@logged DCNL def instance_get_all_by_host(self, hostname):
@logged DCNL def floating_ip_get_all(self):
def get_connection(self, conf):
def record_metering_data(self, data):
def get_users(self, source=None):
def get_projects(self, source=None):
def get_resources(self, user=None, project=None, source=None, start_timestamp=None, end_timestamp=None, metaquery={}, resource=None):
def get_meters(self, user=None, project=None, resource=None, source=None, limit=None, metaquery={}):
def get_samples(self, sample_filter):
def get_meter_statistics(self, sample_filter, period=None):
def get_alarms(self, name=None, user=None, project=None, enabled=True, alarm_id=None):
def update_alarm(self, alarm):
def record_events(self, events):
def get_events(self, event_filter):
def update(self, values):
def __init__(self, event_name, generated, traits):
def __init__(self, resource_id, project_id, source, user_id, metadata, meter):
def __init__(self, counter_name, counter_type, counter_unit):
def __init__(self, name, type, unit, resource_id, project_id, source, user_id):
def __init__(self, source, counter_name, counter_type, counter_unit, counter_volume, user_id, project_id, resource_id, timestamp, resource_metadata, message_id, message_signature):
def __init__(self, min, max, avg, sum, count, period, period_start, period_end, duration, duration_start, duration_end):
def register_opts(self, conf):
@staticmethod DCNL def get_connection(conf):
@staticmethod DCNL def record_metering_data(data):
@staticmethod DCNL def get_users(source=None):
@staticmethod DCNL def get_projects(source=None):
@staticmethod DCNL def get_resources(user=None, project=None, source=None, start_timestamp=None, end_timestamp=None, metaquery={}, resource=None):
@staticmethod DCNL def get_meters(user=None, project=None, resource=None, source=None, metaquery={}):
@staticmethod DCNL def get_samples(sample_filter, limit=None):
@staticmethod DCNL def _make_volume_query(sample_filter, counter_volume_func):
def get_meter_statistics(self, sample_filter, period=None):
def get_alarms(self, name=None, user=None, project=None, enabled=True, alarm_id=None):
def update_alarm(self, alarm):
@staticmethod DCNL def delete_alarm(alarm_id):
def _get_or_create_unique_name(self, key, session=None):
def _make_trait(self, trait_model, event, session=None):
def _record_event(self, session, event_model):
def record_events(self, event_models):
def get_events(self, event_filter):
def register_opts(self, conf):
def get_connection(self, conf):
def record_metering_data(self, data):
def get_users(self, source=None):
def get_projects(self, source=None):
def get_resources(self, user=None, project=None, source=None, start_timestamp=None, end_timestamp=None, metaquery={}, resource=None):
def get_meters(self, user=None, project=None, resource=None, source=None, metaquery={}):
def get_samples(self, sample_filter, limit=None):
def get_meter_statistics(self, sample_filter, period=None):
def get_alarms(self, name=None, user=None, project=None, enabled=True, alarm_id=None):
def update_alarm(self, alarm):
def delete_alarm(self, alarm_id):
@staticmethod DCNL def record_events(events):
@staticmethod DCNL def get_events(event_filter):
def register_opts(self, conf):
@staticmethod DCNL def get_connection(conf):
def __init__(self, conf):
@staticmethod DCNL def _get_connection(conf):
@staticmethod DCNL def _parse_connection_url(url):
def record_metering_data(self, data):
def get_users(self, source=None):
def get_projects(self, source=None):
def get_resources(self, user=None, project=None, source=None, start_timestamp=None, end_timestamp=None, metaquery={}):
def get_meters(self, user=None, project=None, resource=None, source=None, metaquery={}):
def get_samples(self, sample_filter, limit=None):
def _update_meter_stats(self, stat, meter):
def get_meter_statistics(self, sample_filter, period=None):
def get_alarms(self, name=None, user=None, project=None, enabled=True, alarm_id=None):
def update_alarm(self, alarm):
def delete_alarm(self, alarm_id):
def record_events(self, events):
def get_events(self, event_filter):
@staticmethod DCNL def SingleColumnValueFilter(args, rows):
@staticmethod DCNL def is_enabled():
def notification_to_metadata(self, event):
@staticmethod DCNL def get_exchange_topics(conf):
def setup_notifier_task(self):
def poll_instance(self, context, instance):
@staticmethod DCNL def get_exchange_topics(conf):
def inspect_instances(self):
def inspect_cpus(self, instance_name):
def inspect_vnics(self, instance_name):
def inspect_disks(self, instance_name):
def _get_counters_from_plugin(self, ext, instance, *args, **kwds):
def start(self):
def initialize_service_hook(self, service):
def process_notification(self, notification):
def record_metering_data(self, context, data):
@staticmethod DCNL def get_exchange_topics(conf):
def setUp(self):
def tearDown(self):
def test_split_path(self):
def test_call_reifies_request_if_necessary(self):
def test_log_request_stat_type_good(self):
def test_deterministic_serialization(self):
def test_add_rebalance_add_rebalance_delete_rebalance(self):
def test_creation(self):
def test_exception(self):
def test_empty(self):
def test_delete_object(self):
def test_put_object(self):
def test_get_info(self):
def test_list_objects_iter(self):
def test_list_objects_iter_prefix_delim(self):
def test_double_check_trailing_delimiter(self):
def test_newid(self):
def test_get_items_since(self):
def test_sync_merging(self):
def test_merge_items_overwrite(self):
def test_merge_items_post_overwrite_out_of_order(self):
def test_creation(self):
def test_exception(self):
def test_empty(self):
def test_delete_container(self):
def test_put_container(self):
def test_get_info(self):
def test_list_containers_iter(self):
def test_double_check_trailing_delimiter(self):
def test_canonical_version_is_clean(self):
def test_iter_pid_files(self):
def geteuid(self):
def test_normalize_timestamp(self):
def test_backwards(self):
def test_split_path(self):
def test_validate_device_partition(self):
def test_NullLogger(self):
def _send_and_get(self, sender_fn, *args, **kwargs):
def setUp(self):
def tearDown(self):
def test_disk_file_large_app_iter_ranges(self):
def test_disk_file_app_iter_ranges_empty(self):
def _get_data_file(self, invalid_type=None, obj_name='o', fsize=1024, csize=8, extension='.data', ts=None, iter_hook=None):
def setUp(self):
def tearDown(self):
def test_POST_update_meta(self):
def test_POST_quarantine_zbyte(self):
def test_HEAD(self):
def test_HEAD_quarantine_zbyte(self):
def test_GET(self):
def test_GET_quarantine(self):
def test_GET_quarantine_zbyte(self):
def test_GET_quarantine_range(self):
def test_DELETE(self):
def test_call(self):
def test_collect_jobs_removes_zbf(self):
def setUp(self):
def tearDown(self):
def get_account_ring(self):
def get_paths(self):
def run_forever(self, *args, **kwargs):
def run_once(self, *args, **kwargs):
def container_sweep(self, path):
def process_container(self, dbfile):
def container_report(self, node, part, container, put_timestamp, delete_timestamp, count, bytes):
def _get_container_broker(self, drive, part, account, container):
def account_update(self, req, account, container, broker):
@public DCNL @timing_stats() DCNL def DELETE(self, req):
@public DCNL @timing_stats() DCNL def PUT(self, req):
@public DCNL @timing_stats(sample_rate=0.1) DCNL def HEAD(self, req):
def derive_content_type_metadata(self, content_type, size):
@public DCNL @timing_stats() DCNL def GET(self, req):
@public DCNL @timing_stats(sample_rate=0.01) DCNL def REPLICATE(self, req):
@public DCNL @timing_stats() DCNL def POST(self, req):
def run_forever(self, *args, **kwargs):
def run_once(self, *args, **kwargs):
def container_audit(self, path):
def read(self, size=(-1)):
def run_forever(self):
def run_once(self):
def report(self):
def container_sync(self, path):
def container_sync_row(self, row, sync_to, sync_key, broker, info):
def __init__(self, db_file, timeout=BROKER_TIMEOUT, logger=None, account=None, container=None, pending_timeout=10, stale_reads_ok=False):
def initialize(self, put_timestamp=None):
def delete_db(self, timestamp):
def possibly_quarantine(self, exc_type, exc_value, exc_traceback):
@contextmanager DCNL def get(self):
@contextmanager DCNL def lock(self):
def newid(self, remote_id):
def merge_timestamps(self, created_at, put_timestamp, delete_timestamp):
def get_items_since(self, start, count):
def get_sync(self, id, incoming=True):
def get_syncs(self, incoming=True):
def get_replication_info(self):
def merge_syncs(self, sync_points, incoming=True):
def _preallocate(self):
@property DCNL def metadata(self):
def update_metadata(self, metadata_updates):
def reclaim(self, timestamp):
def _reclaim(self, conn, timestamp):
def _initialize(self, conn, put_timestamp):
def create_object_table(self, conn):
def create_container_stat_table(self, conn, put_timestamp=None):
def update_put_timestamp(self, timestamp):
def _delete_db(self, conn, timestamp):
def empty(self):
def _commit_puts(self, item_list=None):
def reclaim(self, object_timestamp, sync_timestamp):
def delete_object(self, name, timestamp):
def put_object(self, name, timestamp, size, content_type, etag, deleted=0):
def is_deleted(self, timestamp=None):
def get_info(self, include_metadata=False):
def reported(self, put_timestamp, delete_timestamp, object_count, bytes_used):
def list_objects_iter(self, limit, marker, end_marker, prefix, delimiter, path=None):
def merge_items(self, item_list, source=None):
def _initialize(self, conn, put_timestamp):
def create_container_table(self, conn):
def create_account_stat_table(self, conn, put_timestamp):
def update_put_timestamp(self, timestamp):
def _delete_db(self, conn, timestamp, force=False):
def _commit_puts(self, item_list=None):
def empty(self):
def reclaim(self, container_timestamp, sync_timestamp):
def put_container(self, name, put_timestamp, delete_timestamp, object_count, bytes_used):
def can_delete_db(self, cutoff):
def is_deleted(self):
def is_status_deleted(self):
def get_info(self):
def list_containers_iter(self, limit, marker, end_marker, prefix, delimiter):
def merge_items(self, item_list, source=None):
def run_once(self, *args, **kwargs):
def run_forever(self, *args, **kwargs):
def run(self, once=False, **kwargs):
def __call__(self, env, start_response):
def get_groups(self, env, token):
def authorize(self, req):
def denied_response(self, req):
def handle(self, env, start_response):
def handle_request(self, req):
def handle_get_token(self, req):
def _error_response(self, response, env, start_response):
def _get_container_info(self, env):
def _listing(self, env, start_response, prefix=None):
def _build_css_path(self, prefix=''):
def handle_container(self, env, start_response):
def handle_object(self, env, start_response):
def __call__(self, env, start_response):
def check_character(self, req):
def check_length(self, req):
def check_regexp(self, req):
def __call__(self, env, start_response):
def __call__(self, env, start_response):
def _get_account(self, env):
def _get_temp_url_info(self, env):
def _get_key(self, env, account):
def _get_hmac(self, env, expires, key, request_method=None):
def _invalid(self, env, start_response):
def _clean_incoming_headers(self, env):
def _clean_outgoing_headers(self, headers):
def GET(self, req):
def DISABLED(self, req):
def log_request(self, req, status_int, bytes_received, bytes_sent, request_time):
def handle_multipart_put(self, req):
def handle_multipart_delete(self, req):
@wsgify DCNL def __call__(self, req):
def _keystone_identity(self, environ):
def _reseller_check(self, account, tenant_id):
def _authorize_cross_tenant(self, user, tenant_id, tenant_name, roles):
def authorize_anonymous(self, req):
def _authorize_unconfirmed_identity(self, req, obj, referrers, roles):
def denied_response(self, req):
def get_container_maxrate(self, container_size):
def get_ratelimitable_key_tuples(self, req_method, account_name, container_name=None, obj_name=None):
def _get_sleep_time(self, key, max_rate):
def handle_ratelimit(self, req, account_name, container_name, obj_name):
def __call__(self, env, start_response):
def _from_recon_cache(self, cache_keys, cache_file, openr=open):
def get_mounted(self, openr=open):
def get_load(self, openr=open):
def get_mem(self, openr=open):
def get_async_info(self):
def get_replication_info(self, recon_type):
def get_device_info(self):
def get_updater_info(self, recon_type):
def get_expirer_info(self, recon_type):
def get_auditor_info(self, recon_type):
def get_unmounted(self):
def get_diskusage(self):
def get_ring_md5(self, openr=open):
def get_quarantine_count(self):
def get_socket_info(self, openr=open):
def __call__(self, env, start_response):
def _translate_form(self, env, boundary):
def _perform_subrequest(self, orig_env, attributes, fp, key):
def _get_key(self, env):
def create_container(self, req, container_path):
def get_objs_to_delete(self, req):
def handle_delete(self, req, objs_to_delete=None, user_agent='BulkDelete', swift_source='BD'):
def handle_extract(self, req, compress_type):
def __call__(self, fd, mode, offset, length):
def process(self, msg, kwargs):
def notice(self, msg, *args, **kwargs):
def set_statsd_prefix(self, prefix):
def statsd_delegate(statsd_func_name):
def __init__(self, wsgi_input):
def read(self, *args, **kwargs):
def readline(self, *args, **kwargs):
def weight_of_one_part(self):
def copy_from(self, builder):
def to_dict(self):
def change_min_part_hours(self, min_part_hours):
def set_replicas(self, new_replica_count):
def get_ring(self):
def add_dev(self, dev):
def set_dev_weight(self, dev_id, weight):
def remove_dev(self, dev_id):
def rebalance(self, seed=None):
def validate(self, stats=False):
def get_balance(self):
def pretend_min_part_hours_passed(self):
def get_part_devices(self, part):
def _iter_devs(self):
def _set_parts_wanted(self):
def _adjust_replica2part2dev_size(self):
def _initial_balance(self):
def _update_last_part_moves(self):
def _gather_reassign_parts(self):
def _reassign_parts(self, reassign_parts):
def _build_max_replicas_by_tier(self):
def _devs_for_part(self, part):
def _replicas_for_part(self, part):
def _each_part_replica(self):
@classmethod DCNL def load(cls, builder_file, open=open):
def search_devs(self, search_value):
@classmethod DCNL def load(cls, filename):
def save(self, filename):
@property DCNL def replica_count(self):
@property DCNL def partition_count(self):
@property DCNL def devs(self):
def has_changed(self):
def get_part_nodes(self, part):
def get_nodes(self, account, container=None, obj=None):
def get_more_nodes(self, part):
def __init__(self, node, partition, hash_, logger):
def replicate(self, *args):
def _zero_stats(self):
def _report_stats(self):
def _rsync_file(self, db_file, remote_file, whole_file=True):
def _rsync_db(self, broker, device, http, local_id, replicate_method='complete_rsync', replicate_timeout=None):
def _usync_db(self, point, broker, http, remote_id, local_id):
def _in_sync(self, rinfo, info, broker, local_sync):
def _http_connect(self, node, partition, db_file):
def _repl_to_node(self, node, broker, partition, info):
def _replicate_object(self, partition, object_file, node_id):
def extract_device(self, object_file):
def run_once(self, *args, **kwargs):
def run_forever(self, *args, **kwargs):
@command DCNL def status(self, **kwargs):
@command DCNL def start(self, **kwargs):
@command DCNL def no_wait(self, **kwargs):
@command DCNL def no_daemon(self, **kwargs):
@command DCNL def once(self, **kwargs):
@command DCNL def stop(self, **kwargs):
@command DCNL def shutdown(self, **kwargs):
@command DCNL def restart(self, **kwargs):
@command DCNL def reload(self, **kwargs):
@command DCNL def force_reload(self, **kwargs):
def get_command(self, cmd):
@classmethod DCNL def list_commands(cls):
def run_command(self, cmd, **kwargs):
def get_pid_file_name(self, conf_file):
def get_conf_file_name(self, pid_file):
def conf_files(self, **kwargs):
def pid_files(self, **kwargs):
def iter_pid_files(self, **kwargs):
def signal_pids(self, sig, **kwargs):
def get_running_pids(self, **kwargs):
def kill_running_pids(self, **kwargs):
def status(self, pids=None, **kwargs):
def spawn(self, conf_file, once=False, wait=True, daemon=True, **kwargs):
def wait(self, **kwargs):
def interact(self, **kwargs):
def launch(self, **kwargs):
def stop(self, **kwargs):
def _get_conns(self, key):
def _return_conn(self, server, fp, sock):
def set(self, key, value, serialize=True, timeout=0, time=0, min_compress_len=0):
def get(self, key):
def incr(self, key, delta=1, time=0, timeout=0):
def decr(self, key, delta=1, time=0, timeout=0):
def delete(self, key):
def set_multi(self, mapping, server_key, serialize=True, timeout=0, time=0, min_compress_len=0):
def get_multi(self, keys, server_key):
def _start_response(self, status, headers, exc_info=None):
def _app_call(self, env):
def _get_status_int(self):
def _response_header_value(self, key):
def read(self, *a, **kw):
def make_request(self, method, path, headers, acceptable_statuses, body_file=None):
def _get_metadata(self, path, metadata_prefix='', acceptable_statuses=(2,)):
def _iter_items(self, path, marker='', end_marker='', acceptable_statuses=(2, HTTP_NOT_FOUND)):
def make_path(self, account, container=None, obj=None):
def _set_metadata(self, path, metadata, metadata_prefix='', acceptable_statuses=(2,)):
def iter_containers(self, account, marker='', end_marker='', acceptable_statuses=(2, HTTP_NOT_FOUND)):
def get_account_info(self, account, acceptable_statuses=(2, HTTP_NOT_FOUND)):
def get_account_metadata(self, account, metadata_prefix='', acceptable_statuses=(2,)):
def set_account_metadata(self, account, metadata, metadata_prefix='', acceptable_statuses=(2,)):
def container_exists(self, account, container):
def create_container(self, account, container, headers=None, acceptable_statuses=(2,)):
def delete_container(self, account, container, acceptable_statuses=(2, HTTP_NOT_FOUND)):
def get_container_metadata(self, account, container, metadata_prefix='', acceptable_statuses=(2,)):
def iter_objects(self, account, container, marker='', end_marker='', acceptable_statuses=(2, HTTP_NOT_FOUND)):
def set_container_metadata(self, account, container, metadata, metadata_prefix='', acceptable_statuses=(2,)):
def delete_object(self, account, container, obj, acceptable_statuses=(2, HTTP_NOT_FOUND)):
def get_object_metadata(self, account, container, obj, metadata_prefix='', acceptable_statuses=(2,)):
def iter_object_lines(self, account, container, obj, headers=None, acceptable_statuses=(2,)):
def set_object_metadata(self, account, container, obj, metadata, metadata_prefix='', acceptable_statuses=(2,)):
def upload_object(self, fobj, account, container, obj, headers=None):
def ranges_for_length(self, length):
def best_match(self, options):
@classmethod DCNL def blank(cls, path, environ=None, headers=None, body=None):
@property DCNL def params(self):
@property DCNL def path_qs(self):
@property DCNL def path(self):
@property DCNL def url(self):
def path_info_pop(self):
def copy_get(self):
def call_application(self, application):
def get_response(self, application):
def split_path(self, minsegs=1, maxsegs=None, rest_with_last=False):
def _prepare_for_ranges(self, ranges):
def absolute_location(self):
def get_container_ring(self):
def run_forever(self, *args, **kwargs):
def run_once(self, *args, **kwargs):
def object_sweep(self, device):
def process_object_update(self, update_path, device):
def object_update(self, node, part, op, obj, headers):
def __iter__(self):
def app_iter_range(self, start, stop):
def app_iter_ranges(self, ranges, content_type, boundary, size):
def _handle_close_quarantine(self):
def close(self, verify_file=True):
def is_deleted(self):
def is_expired(self):
@contextmanager DCNL def mkstemp(self):
def put(self, fd, metadata, extension='.data'):
def put_metadata(self, metadata, tombstone=False):
def unlinkold(self, timestamp):
def drop_cache(self, fd, offset, length):
def quarantine(self):
def get_data_file_size(self):
def __init__(self, conf):
def async_update(self, op, account, container, obj, host, partition, contdevice, headers_out, objdevice):
def container_update(self, op, account, container, obj, headers_in, headers_out, objdevice):
def delete_at_update(self, op, delete_at, account, container, obj, headers_in, objdevice):
@public DCNL @timing_stats() DCNL def POST(self, request):
@public DCNL @timing_stats() DCNL def PUT(self, request):
@public DCNL @timing_stats() DCNL def GET(self, request):
@public DCNL @timing_stats(sample_rate=0.8) DCNL def HEAD(self, request):
@public DCNL @timing_stats() DCNL def DELETE(self, request):
@public DCNL @timing_stats(sample_rate=0.1) DCNL def REPLICATE(self, request):
def __call__(self, env, start_response):
def __init__(self, conf):
def _rsync(self, args):
def rsync(self, node, job, suffixes):
def check_ring(self):
def update_deleted(self, job):
def update(self, job):
def stats_line(self):
def kill_coros(self):
def heartbeat(self):
def detect_lockups(self):
def collect_jobs(self):
def replicate(self, override_devices=[], override_partitions=[]):
def object_audit(self, path, device, partition):
def run_forever(self, *args, **kwargs):
def run_once(self, *args, **kwargs):
def report(self, final=False):
def run_once(self, *args, **kwargs):
def run_forever(self, *args, **kwargs):
def delete_actual_object(self, actual_obj, timestamp):
def get_controller(self, path):
def __call__(self, env, start_response):
def handle_request(self, req):
def sort_nodes(self, nodes):
def error_increment(self, node):
def error_occurred(self, node, msg):
def exception_occurred(self, node, typ, additional_info):
def error_limited(self, node):
def error_limit(self, node):
def account_info(self, account, autocreate=False):
def container_info(self, account, container, account_autocreate=False):
def iter_nodes(self, partition, nodes, ring):
def make_requests(self, req, ring, part, method, path, headers, query_string=''):
def best_response(self, req, statuses, reasons, bodies, server_type, etag=None):
@public DCNL def GET(self, req):
@public DCNL def HEAD(self, req):
def _make_app_iter_reader(self, node, source, queue, logger_thread_locals):
def _make_app_iter(self, node, source):
def is_good_source(self, src):
def GETorHEAD_base(self, req, server_type, partition, nodes, path, attempts):
def is_origin_allowed(self, cors_info, origin):
@public DCNL def OPTIONS(self, req):
def GETorHEAD(self, req):
@public DCNL def PUT(self, req):
@public DCNL def POST(self, req):
@public DCNL def DELETE(self, req):
def _load_next_segment(self):
def __iter__(self):
def app_iter_range(self, start, stop):
def _remaining_items(self, listing_iter):
def is_good_source(self, src):
def GETorHEAD(self, req):
@public DCNL @cors_validation DCNL @delay_denial DCNL def GET(self, req):
@public DCNL @cors_validation DCNL @delay_denial DCNL def HEAD(self, req):
@public DCNL @cors_validation DCNL @delay_denial DCNL def POST(self, req):
def _send_file(self, conn, path):
def _connect_put_node(self, nodes, part, path, headers, logger_thread_locals):
@public DCNL @cors_validation DCNL @delay_denial DCNL def PUT(self, req):
@public DCNL @cors_validation DCNL @delay_denial DCNL def DELETE(self, req):
@public DCNL @cors_validation DCNL @delay_denial DCNL def COPY(self, req):
def GETorHEAD(self, req):
@public DCNL @delay_denial DCNL @cors_validation DCNL def GET(self, req):
@public DCNL @delay_denial DCNL @cors_validation DCNL def HEAD(self, req):
@public DCNL @cors_validation DCNL def PUT(self, req):
@public DCNL @cors_validation DCNL def POST(self, req):
@public DCNL @cors_validation DCNL def DELETE(self, req):
def get_account_ring(self):
def get_container_ring(self):
def get_object_ring(self):
def run_forever(self, *args, **kwargs):
def run_once(self, *args, **kwargs):
def reap_device(self, device):
def reap_account(self, broker, partition, nodes):
def reap_container(self, account, account_partition, account_nodes, container):
def reap_object(self, account, container, container_partition, container_nodes, obj):
@public DCNL @timing_stats() DCNL def DELETE(self, req):
@public DCNL @timing_stats() DCNL def PUT(self, req):
@public DCNL @timing_stats() DCNL def HEAD(self, req):
@public DCNL @timing_stats() DCNL def GET(self, req):
@public DCNL @timing_stats() DCNL def REPLICATE(self, req):
@public DCNL @timing_stats() DCNL def POST(self, req):
def run_forever(self, *args, **kwargs):
def run_once(self, *args, **kwargs):
def account_audit(self, path):
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True):
def create_virtualenv(self, no_site_packages=True):
def parse_args(self, argv):
def post_process(self):
def post_process(self):
def test_policy_crud(self):
def new_ref(self):
def _get_token_id(self, r):
def setUp(self):
def test_list_users_unprotected(self):
def test_list_users_filtered_by_domain(self):
def test_get_user_protected_match_id(self):
def test_list_users_protected_by_domain(self):
def test_list_groups_protected_by_domain(self):
def test_list_groups_protected_by_domain_and_filtered(self):
def test_list_filtered_domains(self):
def test_multiple_filters(self):
def test_two_steps_forward_one_step_back(self):
def assertTableColumns(self, table_name, expected_cols):
def insert_dict(self, session, table_name, d):
def assertTableDoesNotExist(self, table_name):
def assertEqualTokens(self, a, b):
def test_no_external_auth(self):
def test_no_token_in_auth(self):
def test_no_credentials_in_auth(self):
def test_authenticate_blank_request_body(self):
def test_authenticate_blank_auth(self):
def test_authenticate_invalid_auth_content(self):
def test_authenticate_user_id_too_large(self):
def test_authenticate_username_too_large(self):
def test_authenticate_tenant_id_too_large(self):
def test_authenticate_tenant_name_too_large(self):
def test_authenticate_token_too_large(self):
def test_authenticate_password_too_large(self):
def test_unscoped_token(self):
def test_auth_invalid_token(self):
def test_auth_bad_formatted_token(self):
def test_auth_unscoped_token_no_project(self):
def test_auth_unscoped_token_project(self):
def test_auth_token_project_group_role(self):
def test_auth_token_cross_domain_group_and_project(self):
def test_auth_invalid_user(self):
def test_auth_valid_user_invalid_password(self):
def test_auth_empty_password(self):
def test_auth_no_password(self):
def test_authenticate_blank_password_credentials(self):
def test_authenticate_no_username(self):
def test_unscoped_remote_authn(self):
def test_unscoped_remote_authn_jsonless(self):
def test_scoped_remote_authn(self):
def test_scoped_nometa_remote_authn(self):
def test_scoped_remote_authn_invalid_user(self):
def _maintain_token_expiration(self):
def setUp(self, load_sample_data=True):
def new_ref(self):
def admin_request(self, *args, **kwargs):
def get_scoped_token(self):
def get_requested_token(self, auth):
def assertValidListResponse(self, resp, key, entity_validator, ref=None, expected_length=None):
def assertValidResponse(self, resp, key, entity_validator, *args, **kwargs):
def assertValidEntity(self, entity, ref=None):
def assertEqualTokens(self, a, b):
def build_authentication_request(self, token=None, user_id=None, username=None, user_domain_id=None, user_domain_name=None, password=None, **kwargs):
def test_build_tree(self):
def tearDown(self):
def request(self, host='0.0.0.0', port=80, method='GET', path='/', headers=None, body=None, expected_status=None):
def assertResponseSuccessful(self, response):
def assertResponseStatus(self, response, expected_status):
def assertValidResponseHeaders(self, response):
def _to_content_type(self, body, headers, content_type=None):
def _from_content_type(self, response, content_type=None):
def restful_request(self, method='GET', headers=None, body=None, token=None, content_type=None, **kwargs):
def get_scoped_token(self):
def _get_token_id(self, r):
def assertValidError(self, error):
def assertValidVersion(self, version):
def assertValidExtension(self, extension):
def assertValidExtensionLink(self, link):
def assertValidTenant(self, tenant):
def assertValidUser(self, user):
def assertValidRole(self, tenant):
def test_validate_token_head(self):
def test_error_response(self):
def _get_token_id(self, r):
def test_service_crud_requires_auth(self):
def test_user_role_list_requires_auth(self):
def _tag(self, tag_name, xmlns=None):
def test_keyword_arg_condition_or_methods(self):
def test_client_wants_xml_back(self):
def test_client_wants_json_back(self):
def test_client_fails_to_specify_accept(self):
def test_xml_replaced_by_json(self):
def test_json_unnaffected(self):
def setUp(self):
def test_deleting_user_grant_revokes_token(self):
def test_creating_user_grant_revokes_token(self):
def test_deleting_group_grant_revokes_tokens(self):
def test_creating_group_grant_revokes_token(self):
def test_group_membership_changes_revokes_token(self):
def test_all_json_renderings(self):
def test_ipv6_ok(self):
def test_create_policy(self):
def test_list_policies(self):
def test_list_policies_xml(self):
def test_get_policy(self):
def test_update_policy(self):
def test_delete_policy(self):
def assertEqualXML(self, a, b):
def __init__(self, *args, **kwargs):
def get(self, key):
def set(self, key, value, time=0):
def test_get_roles_for_user_and_domain(self):
def test_get_roles_for_user_and_domain_404(self):
def test_build_tree(self):
def test_user_api_get_connection_no_user_password(self):
def test_trailing_slash_normalization(self):
def test_rewrite_empty_path(self):
def test_1way_ssl_ok(self):
def test_2way_ssl_ok(self):
def test_1way_ssl_with_ipv6_ok(self):
def test_2way_ssl_with_ipv6_ok(self):
def test_2way_ssl_fail(self):
def assertMethodNotImplemented(self, f):
def assertInterfaceNotImplemented(self, interface):
def test_create_domain(self):
def test_list_domains(self):
def test_list_domains_xml(self):
def test_get_domain(self):
def test_update_domain(self):
def test_disable_domain(self):
def test_delete_enabled_domain_fails(self):
def test_delete_domain(self):
def test_list_projects(self):
def test_list_projects_xml(self):
def test_create_project(self):
def test_get_project(self):
def test_update_project(self):
def test_delete_project(self):
def test_create_user(self):
def test_list_users(self):
def test_list_users_xml(self):
def test_get_user(self):
def test_add_user_to_group(self):
def test_check_user_in_group(self):
def test_list_users_in_group(self):
def test_remove_user_from_group(self):
def test_update_user(self):
def test_delete_user(self):
def test_create_group(self):
def test_list_groups(self):
def test_list_groups_xml(self):
def test_get_group(self):
def test_update_group(self):
def test_delete_group(self):
def test_list_credentials(self):
def test_list_credentials_xml(self):
def test_create_credential(self):
def test_get_credential(self):
def test_update_credential(self):
def test_delete_credential(self):
def test_create_role(self):
def test_list_roles(self):
def test_list_roles_xml(self):
def test_get_role(self):
def test_update_role(self):
def test_delete_role(self):
def test_create_service(self):
def test_list_services(self):
def test_list_services_xml(self):
def test_get_service(self):
def test_update_service(self):
def test_delete_service(self):
def test_list_endpoints(self):
def test_list_endpoints_xml(self):
def test_create_endpoint(self):
def test_create_endpoint_400(self):
def test_get_endpoint(self):
def test_update_endpoint(self):
def test_delete_endpoint(self):
def test_update_project_returns_extra(self):
def test_update_user_returns_extra(self):
def __init__(self, message=None, **kwargs):
def _build_message(self, message, **kwargs):
def __str__(self):
def _build_message(self, message, **kwargs):
def disable_module(self, module):
def load_backends(self):
def load_fixtures(self, fixtures):
def assertCloseEnoughForGovernmentWork(self, a, b, delta=3):
def __call__(self, xml_str):
@staticmethod DCNL def _tag_name(tag, namespace):
def walk_element(self, element, namespace=False):
def __call__(self, d, xmlns=None):
def _populate_list(self, element, k, v):
def _populate_dict(self, element, k, v):
def _populate_bool(self, element, k, v):
def _populate_str(self, element, k, v):
def _populate_number(self, element, k, v):
def populate_element(self, element, value):
def _populate_sequence(self, element, l):
def _populate_tree(self, element, d):
def __init__(self, data, limit):
def delete(self, key):
def __getattr__(self, name):
def simple_bind_s(self, dn, password):
def unbind_s(self):
def add_s(self, dn, attrs):
def delete_s(self, dn):
def delete_ext_s(self, dn, serverctrls):
def modify_s(self, dn, attrs):
def search_s(self, dn, scope, query=None, fields=None):
def start(self, key=None, backlog=128):
def wait(self):
def _run(self, application, socket):
@classmethod DCNL def factory(cls, global_config, **local_config):
def __call__(self, environ, start_response):
@classmethod DCNL def factory(cls, global_config, **local_config):
def process_request(self, request):
def process_response(self, request, response):
@staticmethod DCNL def print_generator(app_iter):
def __init__(self, mapper):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req):
def add_routes(self, mapper):
@classmethod DCNL def factory(cls, global_config, **local_config):
def to_dict(self, include_extra_dict=False):
def update(self, values):
def iteritems(self):
def get_session(self, autocommit=True, expire_on_commit=False):
def get_engine(self, allow_global_engine=True):
def get_sessionmaker(self, engine, autocommit=True, expire_on_commit=False):
def dump_catalog(self):
def _require_attribute(self, ref, attr):
def _normalize_domain_id(self, context, ref):
def _filter_domain_id(self, ref):
@classmethod DCNL def paginate(cls, context, refs):
@classmethod DCNL def filter_by_attribute(cls, context, refs, attr):
def _require_matching_id(self, value, ref):
def _assign_unique_id(self, ref):
def _normalize_domain_id(self, context, ref):
def _filter_domain_id(self, ref):
def enforce(self, context, credentials, action, target):
def create_policy(self, policy_id, policy):
def list_policies(self):
def get_policy(self, policy_id):
def update_policy(self, policy_id, policy):
def delete_policy(self, policy_id):
def _get_policy(self, session, policy_id):
def process_request(self, request):
def process_response(self, request, response):
def process_request(self, request):
def __init__(self, app, conf):
def __call__(self, environ, start_response):
def get_token(self, token_id):
def create_token(self, token_id, data):
def delete_token(self, token_id):
def list_tokens(self, user_id, tenant_id=None, trust_id=None):
def list_revoked_tokens(self):
def authenticate(self, context, auth=None):
def _authenticate_token(self, context, auth):
def _authenticate_local(self, context, auth):
def _authenticate_external(self, context, auth):
def _get_project_id_from_auth(self, context, auth):
def _get_domain_id_from_auth(self, context, auth):
def _get_project_ref(self, context, user_id, tenant_id):
def _get_metadata_ref(self, context, user_id=None, tenant_id=None, domain_id=None, group_id=None):
def _get_group_metadata_ref(self, context, user_id, tenant_id=None, domain_id=None):
def _append_roles(self, metadata, additional_metadata):
def _get_token_ref(self, context, token_id, belongs_to=None):
def _assert_default_domain(self, context, token_ref):
def validate_token_head(self, context, token_id):
def validate_token(self, context, token_id):
def delete_token(self, context, token_id):
def endpoints(self, context, token_id):
@classmethod DCNL def format_catalog(cls, catalog_ref):
@classmethod DCNL def format_endpoint_list(cls, catalog_ref):
def create_trust(self, trust_id, trust, roles):
@controller.protected DCNL def create_trust(self, context, trust=None):
@controller.protected DCNL def check_role_for_trust(self, context, trust_id, role_id):
@controller.protected DCNL def get_role_for_trust(self, context, trust_id, role_id):
def _get_identity_url(self, version='v2.0'):
def _get_versions_list(self, context):
@classmethod DCNL def load_json(cls, data, default_rule=None):
def __init__(self, rules=None, default_rule=None):
def __missing__(self, key):
def __str__(self):
@abc.abstractmethod DCNL def __str__(self):
@abc.abstractmethod DCNL def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, kind, match):
def __str__(self):
def __init__(self, rule):
def __str__(self):
def __call__(self, target, cred):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __init__(self, rules):
def __str__(self):
def __call__(self, target, cred):
def add_check(self, rule):
def __new__(mcs, name, bases, cls_dict):
def __init__(self):
def reduce(self):
def shift(self, tok, value):
@property DCNL def result(self):
@reducer('(', 'check', ')') DCNL @reducer('(', 'and_expr', ')') DCNL @reducer('(', 'or_expr', ')') DCNL def _wrap_check(self, _p1, check, _p2):
@reducer('check', 'and', 'check') DCNL def _make_and_expr(self, check1, _and, check2):
@reducer('and_expr', 'and', 'check') DCNL def _extend_and_expr(self, and_expr, _and, check):
@reducer('check', 'or', 'check') DCNL def _make_or_expr(self, check1, _or, check2):
@reducer('or_expr', 'or', 'check') DCNL def _extend_or_expr(self, or_expr, _or, check):
@reducer('not', 'check') DCNL def _make_not_expr(self, _not, check):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __call__(self, target, creds):
def __init__(self, package):
def __str__(self):
def __repr__(self):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def authenticate(self, user_id=None, tenant_id=None, password=None):
def get_project(self, tenant_id):
def get_project_by_name(self, tenant_name, domain_id):
def get_user_by_name(self, user_name, domain_id):
def add_user_to_project(self, tenant_id, user_id):
def remove_user_from_project(self, tenant_id, user_id):
def get_project_users(self, tenant_id):
def get_projects_for_user(self, user_id):
def get_roles_for_user_and_project(self, user_id, tenant_id):
def get_roles_for_user_and_domain(self, user_id, domain_id):
def add_role_to_user_and_project(self, user_id, tenant_id, role_id):
def remove_role_from_user_and_project(self, user_id, tenant_id, role_id):
def create_project(self, tenant_id, tenant):
def update_project(self, tenant_id, tenant):
def delete_project(self, tenant_id):
def get_metadata(self, user_id=None, tenant_id=None, domain_id=None, group_id=None):
def create_metadata(self, user_id, tenant_id, metadata, domain_id=None, group_id=None):
def update_metadata(self, user_id, tenant_id, metadata, domain_id=None, group_id=None):
def create_domain(self, domain_id, domain):
def list_domains(self):
def get_domain(self, domain_id):
def get_domain_by_name(self, domain_name):
def update_domain(self, domain_id, domain):
def delete_domain(self, domain_id):
def create_project(self, project_id, project):
def list_projects(self):
def list_user_projects(self, user_id):
def get_project(self):
def update_project(self, project_id, project):
def delete_project(self, project_id):
def create_user(self, user_id, user):
def list_users(self):
def list_users_in_group(self, group_id):
def get_user(self, user_id):
def update_user(self, user_id, user):
def add_user_to_group(self, user_id, group_id):
def check_user_in_group(self, user_id, group_id):
def remove_user_from_group(self, user_id, group_id):
def delete_user(self, user_id):
def create_credential(self, credential_id, credential):
def list_credentials(self):
def get_credential(self, credential_id):
def update_credential(self, credential_id, credential):
def delete_credential(self, credential_id):
def create_role(self, role_id, role):
def list_roles(self):
def get_role(self, role_id):
def update_role(self, role_id, role):
def delete_role(self, role_id):
def create_group(self, group_id, group):
def list_groups(self):
def list_groups_for_user(self, user_id):
def get_group(self, group_id):
def update_group(self, group_id, group):
def delete_group(self, group_id):
def to_dict(self):
def _check_password(self, password, user_ref):
def authenticate(self, user_id=None, tenant_id=None, password=None):
def authenticate(self, user_id=None, tenant_id=None, password=None):
def authenticate(self, user_id=None, tenant_id=None, password=None):
def get_user_projects(self, user_id):
def list_user_groups(self, user_id):
def list_group_users(self, group_id):
def get(self, id, filter=None):
def get_all_projects(self, context, **kw):
def get_projects_for_token(self, context, **kw):
def update_user_project(self, context, user_id, user):
def get_user_roles(self, context, user_id, tenant_id=None):
def add_role_to_user(self, context, user_id, role_id, tenant_id=None):
def remove_role_from_user(self, context, user_id, role_id, tenant_id=None):
def get_role_refs(self, context, user_id):
def create_role_ref(self, context, user_id, role):
def delete_role_ref(self, context, user_id, role_ref_id):
def _delete_domain_contents(self, context, domain_id):
def _get_domain_by_name(self, context, domain_name):
@controller.protected DCNL def create_grant(self, context, role_id, user_id=None, group_id=None, domain_id=None, project_id=None):
@controller.protected DCNL def list_grants(self, context, user_id=None, group_id=None, domain_id=None, project_id=None):
@controller.protected DCNL def check_grant(self, context, role_id, user_id=None, group_id=None, domain_id=None, project_id=None):
@controller.protected DCNL def revoke_grant(self, context, role_id, user_id=None, group_id=None, domain_id=None, project_id=None):
def create_service(self, service_id, service_ref):
def list_services(self):
def get_service(self, service_id):
def update_service(self, service_id):
def delete_service(self, service_id):
def create_endpoint(self, endpoint_id, endpoint_ref):
def get_endpoint(self, endpoint_id):
def list_endpoints(self):
def update_endpoint(self, endpoint_id, endpoint_ref):
def delete_endpoint(self, endpoint_id):
def get_catalog(self, user_id, tenant_id, metadata=None):
def get_v3_catalog(self, user_id, tenant_id, metadata=None):
def get_endpoints(self, context):
def create_endpoint(self, context, endpoint):
def delete_endpoint(self, context, endpoint_id):
def authenticate(self, context, auth_payload, auth_context):
def _validate_and_normalize_scope_data(self):
def _validate_and_normalize_auth_data(self):
def get_method_names(self):
def get_method_data(self, method):
def get_scope(self):
def set_scope(self, domain_id=None, project_id=None, trust=None):
def authenticate_for_token(self, context, auth=None):
def authenticate(self, context, auth_info, auth_context):
def authenticate(self, context, auth_payload, user_context):
def authenticate(self, context, credentials=None, ec2Credentials=None):
def create_credential(self, context, user_id, tenant_id):
def get_credentials(self, context, user_id):
def get_credential(self, context, user_id, credential_id):
def delete_credential(self, context, user_id, credential_id):
def _get_credentials(self, context, credential_id):
def _assert_identity(self, context, user_id):
def _is_admin(self, context):
def _assert_owner(self, context, user_id, credential_id):
def _assert_valid_user_id(self, context, user_id):
def _assert_valid_project_id(self, context, tenant_id):
def get_stats(self, api):
def set_stats(self, api, stats_ref):
def increment_stat(self, api, category, value):
def capture_stats(self, host, obj, attributes):
def process_request(self, request):
def process_response(self, request, response):
def increment_stat(self, api, category, value):
def post_process(self):
@contextlib.contextmanager DCNL def completion_cache(self, cache_type, obj_class, mode):
def find(self, **kwargs):
def findall(self, **kwargs):
@property DCNL def human_id(self):
def _choose_api_version(self):
def _remove_auth_headers(self, env):
def _get_user_token_from_header(self, env):
def _reject_request(self, env, start_response):
def get_admin_token(self):
def _http_request(self, method, path, **kwargs):
def _json_request(self, method, path, body=None, additional_headers=None):
def _request_admin_token(self):
def _validate_user_token(self, user_token, retry=True):
def _build_user_headers(self, token_info):
def _header_to_env_var(self, key):
def _add_headers(self, env, headers):
def _remove_headers(self, env, keys):
def _get_header(self, env, key, default=None):
def _protect_cache_value(self, token, data):
def _unprotect_cache_value(self, token, data):
def _get_cache_key(self, token):
def _cache_get(self, token):
def _cache_store(self, token, data, expires=None):
def _cache_put(self, token, data, expires):
def _cache_store_invalid(self, token):
def verify_uuid_token(self, user_token, retry=True):
def is_signed_token_revoked(self, signed_text):
def cms_verify(self, data):
def verify_signed_token(self, signed_text):
@token_revocation_list.setter DCNL def token_revocation_list(self, value):
def _extract_service_catalog(self, url, resp, body, extract_token=True):
def _fetch_endpoints_from_auth(self, url):
def _v2_auth(self, url):
def _rax_auth(self, url):
def _authenticate(self, url, body):
def error(self, message):
def _run_extension_hooks(self, hook_type, *args, **kwargs):
def do_bash_completion(self, args):
@utils.arg('command', metavar='<subcommand>', nargs='?', help='Display DCSP help DCSP for DCSP <subcommand>') DCNL def do_help(self, args):
def __init__(self, *args, **kwargs):
def get(self, key):
def set(self, key, value, time=0, min_compress_len=0):
def add(self, key, value, time=0, min_compress_len=0):
def incr(self, key, delta=1):
def delete(self, key, time=0):
def __init__(self, package):
def __str__(self):
def __repr__(self):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def restore(self, backup_id, monitor_id=None):
@property DCNL def id(self):
def authenticate(self):
def get_keys(self):
def set_keys(self, metadata):
def unset_keys(self, keys):
def list(self):
def get(self, monitor_type):
def delete(self, monitor_type):
def create(self, name):
def delete(self):
def create(self, monitor_id, container=None, name=None, description=None):
def get(self, backup_id):
def list(self, detailed=True):
def delete(self, backup):
def delete(self):
def update(self, **kwargs):
def create(self, monitor_id, force=False, display_name=None, display_description=None):
def get(self, snapshot_id):
def list(self, detailed=True, search_opts=None):
def delete(self, snapshot):
def update(self, snapshot, **kwargs):
@property DCNL def id(self):
def delete(self):
def update(self, **kwargs):
def attach(self, instance_uuid, mountpoint):
def detach(self):
def reserve(self, monitor):
def unreserve(self, monitor):
def begin_detaching(self, monitor):
def roll_detaching(self, monitor):
def initialize_connection(self, monitor, connector):
def terminate_connection(self, monitor, connector):
def set_metadata(self, monitor, metadata):
def upload_to_image(self, force, image_name, container_format, disk_format):
def force_delete(self):
def create(self, size, snapshot_id=None, source_volid=None, display_name=None, display_description=None, monitor_type=None, user_id=None, project_id=None, availability_zone=None, metadata=None, imageRef=None):
def get(self, monitor_id):
def list(self, detailed=True, search_opts=None):
def delete(self, monitor):
def update(self, monitor, **kwargs):
def _action(self, action, monitor, info=None, **kwargs):
def host_status(self, req=None):
def resource_info(self, req=None):
def asm_settings(self, req=None):
def asm_settings_update(self, req=None):
def asm_start_host(self, req=None):
def pas_host_select(self, req=None):
def attach(self, monitor, instance_uuid, mountpoint):
def detach(self, monitor):
def reserve(self, monitor):
def unreserve(self, monitor):
def begin_detaching(self, monitor):
def roll_detaching(self, monitor):
def initialize_connection(self, monitor, connector):
def terminate_connection(self, monitor, connector):
def set_metadata(self, monitor, metadata):
def delete_metadata(self, monitor, keys):
def upload_to_image(self, monitor, force, image_name, container_format, disk_format):
def get(self):
def url_for(self, attr=None, filter_value=None, service_type=None, endpoint_type='publicURL', service_name=None, monitor_service_name=None):
def setUp(self):
def setUp(self):
def assert_called(self, method, url, body=None, pos=(-1), **kwargs):
def assert_called_anytime(self, method, url, body=None):
@contextlib.contextmanager DCNL def completion_cache(self, cache_type, obj_class, mode):
def find(self, **kwargs):
def findall(self, **kwargs):
@property DCNL def human_id(self):
def _choose_api_version(self):
def _remove_auth_headers(self, env):
def _get_user_token_from_header(self, env):
def _reject_request(self, env, start_response):
def get_admin_token(self):
def _http_request(self, method, path, **kwargs):
def _json_request(self, method, path, body=None, additional_headers=None):
def _request_admin_token(self):
def _validate_user_token(self, user_token, retry=True):
def _build_user_headers(self, token_info):
def _header_to_env_var(self, key):
def _add_headers(self, env, headers):
def _remove_headers(self, env, keys):
def _get_header(self, env, key, default=None):
def _protect_cache_value(self, token, data):
def _unprotect_cache_value(self, token, data):
def _get_cache_key(self, token):
def _cache_get(self, token):
def _cache_store(self, token, data, expires=None):
def _cache_put(self, token, data, expires):
def _cache_store_invalid(self, token):
def verify_uuid_token(self, user_token, retry=True):
def is_signed_token_revoked(self, signed_text):
def cms_verify(self, data):
def verify_signed_token(self, signed_text):
@token_revocation_list.setter DCNL def token_revocation_list(self, value):
def _extract_service_catalog(self, url, resp, body, extract_token=True):
def _fetch_endpoints_from_auth(self, url):
def _v2_auth(self, url):
def _rax_auth(self, url):
def _authenticate(self, url, body):
def error(self, message):
def _run_extension_hooks(self, hook_type, *args, **kwargs):
def do_bash_completion(self, args):
@utils.arg('command', metavar='<subcommand>', nargs='?', help='Display DCSP help DCSP for DCSP <subcommand>') DCNL def do_help(self, args):
def __init__(self, *args, **kwargs):
def get(self, key):
def set(self, key, value, time=0, min_compress_len=0):
def add(self, key, value, time=0, min_compress_len=0):
def incr(self, key, delta=1):
def delete(self, key, time=0):
def __init__(self, package):
def __str__(self):
def __repr__(self):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def restore(self, backup_id, monitor_id=None):
@property DCNL def id(self):
def authenticate(self):
def get_keys(self):
def set_keys(self, metadata):
def unset_keys(self, keys):
def list(self):
def get(self, monitor_type):
def delete(self, monitor_type):
def create(self, name):
def delete(self):
def create(self, monitor_id, container=None, name=None, description=None):
def get(self, backup_id):
def list(self, detailed=True):
def delete(self, backup):
def delete(self):
def update(self, **kwargs):
def create(self, monitor_id, force=False, display_name=None, display_description=None):
def get(self, snapshot_id):
def list(self, detailed=True, search_opts=None):
def delete(self, snapshot):
def update(self, snapshot, **kwargs):
@property DCNL def id(self):
def delete(self):
def update(self, **kwargs):
def attach(self, instance_uuid, mountpoint):
def detach(self):
def reserve(self, monitor):
def unreserve(self, monitor):
def begin_detaching(self, monitor):
def roll_detaching(self, monitor):
def initialize_connection(self, monitor, connector):
def terminate_connection(self, monitor, connector):
def set_metadata(self, monitor, metadata):
def upload_to_image(self, force, image_name, container_format, disk_format):
def force_delete(self):
def create(self, size, snapshot_id=None, source_volid=None, display_name=None, display_description=None, monitor_type=None, user_id=None, project_id=None, availability_zone=None, metadata=None, imageRef=None):
def get(self, monitor_id):
def list(self, detailed=True, search_opts=None):
def delete(self, monitor):
def update(self, monitor, **kwargs):
def _action(self, action, monitor, info=None, **kwargs):
def host_status(self, req=None):
def test_service(self, req=None):
def resource_info(self, req=None):
def asm_settings(self, req=None):
def asm_settings_update(self, req=None):
def asm_start_host(self, req=None):
def pas_host_select(self, req=None):
def attach(self, monitor, instance_uuid, mountpoint):
def detach(self, monitor):
def reserve(self, monitor):
def unreserve(self, monitor):
def begin_detaching(self, monitor):
def roll_detaching(self, monitor):
def initialize_connection(self, monitor, connector):
def terminate_connection(self, monitor, connector):
def set_metadata(self, monitor, metadata):
def delete_metadata(self, monitor, keys):
def upload_to_image(self, monitor, force, image_name, container_format, disk_format):
def get(self):
def url_for(self, attr=None, filter_value=None, service_type=None, endpoint_type='publicURL', service_name=None, monitor_service_name=None):
def run_command_with_code(self, cmd, redirect_output=True, check_exit_code=True):
def create_virtualenv(self, no_site_packages=True):
def parse_args(self, argv):
def post_process(self):
def post_process(self):
def __init__(self, data, limit):
def __init__(self, ext_mgr):
def get_resources(self):
def get_controller_extensions(self):
@classmethod DCNL def nsmap(cls):
@classmethod DCNL def xmlname(cls, name):
def get_resources(self):
def get_controller_extensions(self):
def _check_extension(self, extension):
def load_extension(self, ext_factory):
def _load_extensions(self):
def _get_next_link(self, request, identifier):
def _get_href_link(self, request, identifier):
def _get_bookmark_link(self, request, identifier):
def _get_collection_links(self, request, items, id_key='uuid'):
def extract_metadata(self, metadata_node):
def __init__(self):
def summary_list(self, request, backups):
def detail_list(self, request, backups):
def summary(self, request, backup):
def restore_summary(self, request, restore):
def detail(self, request, backup):
def _list_view(self, func, request, backups):
def show(self, request, servicemanage_type, brief=False):
def index(self, request, servicemanage_types):
def _build_absolute_limits(self, absolute_limits):
def __init__(self, base_url):
def _build_links(self, version_data):
def generate_href(self, path=None):
def __init__(self, *chain):
def __repr__(self):
def __call__(self, obj, do_raise=False):
def __call__(self, obj, do_raise=False):
def __init__(self, value):
def __repr__(self):
def __call__(self, _obj, _do_raise=False):
def __init__(self, tag, attrib=None, selector=None, subselector=None, **extra):
def __repr__(self):
def __len__(self):
def __contains__(self, key):
def __getitem__(self, idx):
def append(self, elem):
def extend(self, elems):
def insert(self, idx, elem):
def remove(self, elem):
def get(self, key):
def set(self, key, value=None):
def keys(self):
def items(self):
def unwrap(self):
def wrap(self):
def apply(self, elem, obj):
def _render(self, parent, datum, patches, nsmap):
def render(self, parent, obj, patches=[], nsmap=None):
def will_render(self, datum):
def _text_get(self):
def tree(self):
def __init__(self, root, nsmap=None):
def _serialize(self, parent, obj, siblings, nsmap=None):
def serialize(self, obj, *args, **kwargs):
def make_tree(self, obj):
def _siblings(self):
def _nsmap(self):
def unwrap(self):
def wrap(self):
def apply(self, master):
def tree(self):
def __init__(self, root, version, nsmap=None):
def __repr__(self):
def _siblings(self):
def _nsmap(self):
def attach(self, *slaves):
def copy(self):
def __init__(self, root, min_vers, max_vers=None, nsmap=None):
def __repr__(self):
def apply(self, master):
def __new__(cls, copy=True):
def construct(self):
@classmethod DCNL def factory(cls, global_config, **local_config):
def best_match_content_type(self):
def get_content_type(self):
def dispatch(self, *args, **kwargs):
def __init__(self, metadata=None):
def _from_xml_node(self, node, listnames):
def find_first_child_named(self, parent, name):
def find_children_named(self, parent, name):
def extract_text(self, node):
def find_attribute_or_element(self, parent, name):
def extract_metadata(self, metadata_node):
def __init__(self, metadata=None, xmlns=None):
def _to_xml_node(self, doc, metadata, nodename, data):
def _to_xml(self, root):
def __init__(self, obj, code=None, **serializers):
def __getitem__(self, key):
def __setitem__(self, key, value):
def __delitem__(self, key):
def _bind_method_serializers(self, meth_serializers):
def get_serializer(self, content_type, default_serializers=None):
def preserialize(self, content_type, default_serializers=None):
def attach(self, **kwargs):
def serialize(self, request, content_type, default_serializers=None):
@property DCNL def code(self):
@property DCNL def headers(self):
def __init__(self, controller, action_peek=None, **deserializers):
def register_actions(self, controller):
def register_extensions(self, controller):
def get_action_args(self, request_environment):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
def _process_stack(self, request, action, action_args, content_type, body, accept):
def get_method(self, request, action, content_type, body):
def dispatch(self, method, request, action_args):
def __new__(mcs, name, bases, cls_dict):
def __init__(self, view_builder=None):
def __init__(self, exception):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
def __init__(self, message, details, retry_time):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
@wsgi.serializers(xml=ServiceManageTypesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=ServiceManageTypeTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req):
def __init__(self, verb, uri, regex, value, unit):
def __call__(self, verb, url):
def _get_time(self):
def display_unit(self):
def display(self):
def __init__(self, application, limits=None, limiter=None, **kwargs):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req):
def __init__(self, limits, **kwargs):
def get_limits(self, username=None):
def check_for_delay(self, verb, url, username=None):
@staticmethod DCNL def parse_limits(limits):
def __init__(self, limits=None):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request):
def __init__(self, limiter_address):
@staticmethod DCNL def parse_limits(limits):
def content_type_params(self, best_content_type):
def _match(self, host, port, path_info):
def _path_strategy(self, host, port, path_info):
def _content_type_strategy(self, host, port, environ):
def _accept_strategy(self, host, port, environ, supported_content_types):
def _set_enabled_status(self, req, host, enabled):
@wsgi.serializers(xml=HostShowTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=ServiceManageTypeExtraSpecsTemplate) DCNL def index(self, req, type_id):
@wsgi.serializers(xml=ServiceManageTypeExtraSpecTemplate) DCNL def show(self, req, type_id, id):
def delete(self, req, type_id, id):
def _format_quota_set(self, quota_class, quota_set):
@wsgi.serializers(xml=ServicesIndexTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=ServicesUpdateTemplate) DCNL def update(self, req, id, body):
def _format_quota_set(self, project_id, quota_set):
@wsgi.serializers(xml=BackupTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=BackupsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=BackupsTemplate) DCNL def detail(self, req):
def _get_backups(self, req, is_detail):
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body):
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupRestoreTemplate) DCNL @wsgi.deserializers(xml=RestoreDeserializer) DCNL def restore(self, req, id, body):
@wsgi.action('create') DCNL @wsgi.serializers(xml=types.ServiceManageTypeTemplate) DCNL def _create(self, req, body):
@wsgi.action('delete') DCNL def _delete(self, req, id):
@wsgi.action('os-attach') DCNL def _attach(self, req, id, body):
@wsgi.action('os-detach') DCNL def _detach(self, req, id, body):
@wsgi.action('os-reserve') DCNL def _reserve(self, req, id, body):
@wsgi.action('os-unreserve') DCNL def _unreserve(self, req, id, body):
@wsgi.action('os-begin_detaching') DCNL def _begin_detaching(self, req, id, body):
@wsgi.action('os-roll_detaching') DCNL def _roll_detaching(self, req, id, body):
@wsgi.action('os-initialize_connection') DCNL def _initialize_connection(self, req, id, body):
@wsgi.action('os-terminate_connection') DCNL def _terminate_connection(self, req, id, body):
@wsgi.response(202) DCNL @wsgi.action('os-servicemanage_upload_image') DCNL @wsgi.serializers(xml=ServiceManageToImageSerializer) DCNL @wsgi.deserializers(xml=ServiceManageToImageDeserializer) DCNL def _servicemanage_upload_image(self, req, id, body):
@wsgi.action('os-reset_status') DCNL def _reset_status(self, req, id, body):
@wsgi.action('os-force_delete') DCNL def _force_delete(self, req, id, body):
@wsgi.action('os-force_detach') DCNL def _force_detach(self, req, id, body):
@wsgi.serializers(xml=VersionsTemplate, atom=VersionsAtomSerializer) DCNL def index(self, req):
@wsgi.serializers(xml=ChoicesTemplate) DCNL @wsgi.response(300) DCNL def multi(self, req):
def get_action_args(self, request_environment):
def save(self, session=None):
def delete(self, session=None):
def update(self, values):
def iteritems(self):
def get(self):
def __init__(self, retvalue=True):
def rollback_and_reraise(self, msg=None, **kwargs):
def __init__(self):
@staticmethod DCNL def run_server(server):
def launch_server(self, server):
def stop(self):
def wait(self):
def wait(self):
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_interval=None, periodic_fuzzy_delay=None, service_name=None):
def kill(self):
def periodic_tasks(self, raise_on_error=False):
def report_state(self):
def __init__(self, name, loader=None):
def _get_manager(self):
def start(self):
def stop(self):
def wait(self):
def format(self, record):
def formatException(self, exc_info, record=None):
def __init__(self, topic, default_version):
def _set_version(self, msg, vers):
def _get_topic(self, topic):
def call(self, context, msg, topic=None, version=None, timeout=None):
def multicall(self, context, msg, topic=None, version=None, timeout=None):
def cast(self, context, msg, topic=None, version=None):
def fanout_cast(self, context, msg, topic=None, version=None):
def cast_to_server(self, context, server_params, msg, topic=None, version=None):
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None):
def __init__(self, conf, connection_pool, pooled=True, server_params=None):
def __enter__(self):
def _done(self):
def __exit__(self, exc_type, exc_value, tb):
def __del__(self):
def close(self):
def __getattr__(self, key):
def check_duplicate_message(self, message_data):
def wait(self):
def __init__(self, conf, callback, connection_pool):
def __call__(self, message_data):
def _process_data(self, ctxt, version, method, args):
def __iter__(self):
def __call__(self, data):
def __iter__(self):
def __init__(self, callbacks):
def dispatch(self, ctxt, version, method, **kwargs):
def register(self, key, host):
def ack_alive(self, key, host):
def is_alive(self, topic, host):
def expire(self, topic, host):
def send_heartbeats(self):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def send_heartbeats(self):
def ack_alive(self, key, host):
def backend_register(self, key, host):
def backend_unregister(self, key, key_host):
def register(self, key, host):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts):
def reconnect(self, session):
def consume(self):
def __init__(self, conf, session, msg_id, callback):
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None):
def __init__(self, conf, session, topic, callback):
def __init__(self, session, node_name, node_opts=None):
def reconnect(self, session):
def send(self, msg):
def __init__(self, conf, session, msg_id):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def reconnect(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
def socket_s(self):
def subscribe(self, msg_filter):
def unsubscribe(self, msg_filter):
def _get_response(self, ctx, proxy, topic, data):
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None):
def consume_in_thread(self):
def close(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name):
def consume_in_thread(self):
def elevated(self, read_deleted=None, overwrite=False):
def __init__(self, channel, callback, tag, **kwargs):
def reconnect(self, channel):
def consume(self, *args, **kwargs):
def cancel(self):
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, **kwargs):
def __init__(self, channel, exchange_name, routing_key, **kwargs):
def reconnect(self, channel):
def send(self, msg, timeout=None):
def __init__(self, conf, channel, msg_id, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def _fetch_ssl_params(self):
def _connect(self, params):
def reconnect(self):
def get_channel(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
@classmethod DCNL def load_json(cls, data, default_rule=None):
def check(self, match_list, target_dict, cred_dict):
def __init__(self, package):
def __str__(self):
def __repr__(self):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def _weight_multiplier(self):
def _weigh_object(self, obj, weight_properties):
def weigh_objects(self, weighed_obj_list, weight_properties):
def _is_correct_class(self, obj):
def get_weighed_objects(self, weigher_classes, obj_list, weighing_properties):
def _filter_one(self, obj, filter_properties):
def host_passes(self, host_state, filter_properties):
def _satisfies_extra_specs(self, capabilities, resource_type):
def host_passes(self, host_state, filter_properties):
def _op_compare(self, args, op):
def _equals(self, args):
def _less_than(self, args):
def _greater_than(self, args):
def _in(self, args):
def _less_than_equal(self, args):
def _greater_than_equal(self, args):
def _not(self, args):
def _or(self, args):
def _and(self, args):
def _parse_string(self, string, host_state):
def _process_filter(self, query, host_state):
def host_passes(self, host_state, filter_properties):
def _filter_one(self, obj, filter_properties):
def filter_all(self, filter_obj_list, filter_properties):
def _is_correct_class(self, obj):
def get_exec(self, exec_dirs=[]):
def match(self, userargs):
def get_command(self, userargs, exec_dirs=[]):
def get_environment(self, userargs):
def __init__(cls, names, bases, dict_):
def create_rpc_dispatcher(self):
def periodic_tasks(self, context, raise_on_error=False):
def init_host(self):
def get_by_project(self, context, project_id, resource):
def get_by_class(self, context, quota_class, resource):
def get_defaults(self, context, resources):
def get_class_quotas(self, context, resources, quota_class, defaults=True):
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True):
def _get_quotas(self, context, resources, keys, has_sync, project_id=None):
def limit_check(self, context, resources, values, project_id=None):
def reserve(self, context, resources, deltas, expire=None, project_id=None):
def commit(self, context, reservations, project_id=None):
def rollback(self, context, reservations, project_id=None):
def destroy_all_by_project(self, context, project_id):
def expire(self, context):
def __init__(self, name, flag=None):
def quota(self, driver, context, **kwargs):
@property DCNL def default(self):
def __init__(self, name, sync, flag=None):
def __init__(self, name, count, flag=None):
def __init__(self, quota_driver_class=None):
def register_resource(self, resource):
def register_resources(self, resources):
def get_by_project(self, context, project_id, resource):
def get_by_class(self, context, quota_class, resource):
def get_defaults(self, context):
def get_class_quotas(self, context, quota_class, defaults=True):
def get_project_quotas(self, context, project_id, quota_class=None, defaults=True, usages=True):
def count(self, context, resource, *args, **kwargs):
def limit_check(self, context, project_id=None, **values):
def reserve(self, context, expire=None, project_id=None, **deltas):
def commit(self, context, reservations, project_id=None):
def rollback(self, context, reservations, project_id=None):
def destroy_all_by_project(self, context, project_id):
def expire(self, context):
def __init__(self, name, app, host=None, port=None, pool_size=None, protocol=eventlet.wsgi.HttpProtocol):
def _start(self):
def start(self, backlog=128):
def stop(self):
def wait(self):
@classmethod DCNL def factory(cls, global_config, **local_config):
def __call__(self, environ, start_response):
@classmethod DCNL def factory(cls, global_config, **local_config):
def process_request(self, req):
def process_response(self, response):
@staticmethod DCNL def print_generator(app_iter):
def __init__(self, mapper):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req):
def __init__(self, config_path=None):
def load_app(self, name):
def __init__(self, user_id, project_id, is_admin=None, read_deleted='no', roles=None, remote_address=None, timestamp=None, request_id=None, auth_token=None, overwrite=True, quota_class=None, **kwargs):
def elevated(self, read_deleted=None, overwrite=False):
def __init__(self, data, limit):
def __init__(self, ext_mgr):
def get_resources(self):
def get_controller_extensions(self):
@classmethod DCNL def nsmap(cls):
@classmethod DCNL def xmlname(cls, name):
def get_resources(self):
def get_controller_extensions(self):
def _check_extension(self, extension):
def load_extension(self, ext_factory):
def _load_extensions(self):
def _get_next_link(self, request, identifier):
def _get_href_link(self, request, identifier):
def _get_bookmark_link(self, request, identifier):
def _get_collection_links(self, request, items, id_key='uuid'):
def extract_metadata(self, metadata_node):
def __init__(self):
def summary_list(self, request, backups):
def detail_list(self, request, backups):
def summary(self, request, backup):
def restore_summary(self, request, restore):
def detail(self, request, backup):
def _list_view(self, func, request, backups):
def show(self, request, servicemanage_type, brief=False):
def index(self, request, servicemanage_types):
def _build_absolute_limits(self, absolute_limits):
def __init__(self, base_url):
def _build_links(self, version_data):
def generate_href(self, path=None):
def __init__(self, *chain):
def __repr__(self):
def __call__(self, obj, do_raise=False):
def __call__(self, obj, do_raise=False):
def __init__(self, value):
def __repr__(self):
def __call__(self, _obj, _do_raise=False):
def __init__(self, tag, attrib=None, selector=None, subselector=None, **extra):
def __repr__(self):
def __len__(self):
def __contains__(self, key):
def __getitem__(self, idx):
def append(self, elem):
def extend(self, elems):
def insert(self, idx, elem):
def remove(self, elem):
def get(self, key):
def set(self, key, value=None):
def keys(self):
def items(self):
def unwrap(self):
def wrap(self):
def apply(self, elem, obj):
def _render(self, parent, datum, patches, nsmap):
def render(self, parent, obj, patches=[], nsmap=None):
def will_render(self, datum):
def _text_get(self):
def tree(self):
def __init__(self, root, nsmap=None):
def _serialize(self, parent, obj, siblings, nsmap=None):
def serialize(self, obj, *args, **kwargs):
def make_tree(self, obj):
def _siblings(self):
def _nsmap(self):
def unwrap(self):
def wrap(self):
def apply(self, master):
def tree(self):
def __init__(self, root, version, nsmap=None):
def __repr__(self):
def _siblings(self):
def _nsmap(self):
def attach(self, *slaves):
def copy(self):
def __init__(self, root, min_vers, max_vers=None, nsmap=None):
def __repr__(self):
def apply(self, master):
def __new__(cls, copy=True):
def construct(self):
@classmethod DCNL def factory(cls, global_config, **local_config):
def best_match_content_type(self):
def get_content_type(self):
def dispatch(self, *args, **kwargs):
def __init__(self, metadata=None):
def _from_xml_node(self, node, listnames):
def find_first_child_named(self, parent, name):
def find_children_named(self, parent, name):
def extract_text(self, node):
def find_attribute_or_element(self, parent, name):
def extract_metadata(self, metadata_node):
def __init__(self, metadata=None, xmlns=None):
def _to_xml_node(self, doc, metadata, nodename, data):
def _to_xml(self, root):
def __init__(self, obj, code=None, **serializers):
def __getitem__(self, key):
def __setitem__(self, key, value):
def __delitem__(self, key):
def _bind_method_serializers(self, meth_serializers):
def get_serializer(self, content_type, default_serializers=None):
def preserialize(self, content_type, default_serializers=None):
def attach(self, **kwargs):
def serialize(self, request, content_type, default_serializers=None):
@property DCNL def code(self):
@property DCNL def headers(self):
def __init__(self, controller, action_peek=None, **deserializers):
def register_actions(self, controller):
def register_extensions(self, controller):
def get_action_args(self, request_environment):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
def _process_stack(self, request, action, action_args, content_type, body, accept):
def get_method(self, request, action, content_type, body):
def dispatch(self, method, request, action_args):
def __new__(mcs, name, bases, cls_dict):
def __init__(self, view_builder=None):
def __init__(self, exception):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
def __init__(self, message, details, retry_time):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, request):
@wsgi.serializers(xml=ServiceManageTypesTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=ServiceManageTypeTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=LimitsTemplate) DCNL def index(self, req):
def __init__(self, verb, uri, regex, value, unit):
def __call__(self, verb, url):
def _get_time(self):
def display_unit(self):
def display(self):
def __init__(self, application, limits=None, limiter=None, **kwargs):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, req):
def __init__(self, limits, **kwargs):
def get_limits(self, username=None):
def check_for_delay(self, verb, url, username=None):
@staticmethod DCNL def parse_limits(limits):
def __init__(self, limits=None):
@webob.dec.wsgify(RequestClass=wsgi.Request) DCNL def __call__(self, request):
def __init__(self, limiter_address):
@staticmethod DCNL def parse_limits(limits):
def _extract_conductor(self, node):
def default(self, string):
@wsgi.serializers(xml=ConductorTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=ConductorsTemplate) DCNL def test_service(self, req):
@wsgi.serializers(xml=ConductorsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=ConductorsTemplate) DCNL def detail(self, req):
def _items(self, req, entity_maker):
def _get_conductor_search_options(self):
def content_type_params(self, best_content_type):
def _match(self, host, port, path_info):
def _path_strategy(self, host, port, path_info):
def _content_type_strategy(self, host, port, environ):
def _accept_strategy(self, host, port, environ, supported_content_types):
def _set_enabled_status(self, req, host, enabled):
@wsgi.serializers(xml=HostShowTemplate) DCNL def show(self, req, id):
@wsgi.serializers(xml=ServiceManageTypeExtraSpecsTemplate) DCNL def index(self, req, type_id):
@wsgi.serializers(xml=ServiceManageTypeExtraSpecTemplate) DCNL def show(self, req, type_id, id):
def delete(self, req, type_id, id):
def _format_quota_set(self, quota_class, quota_set):
@wsgi.serializers(xml=ServicesIndexTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=ServicesUpdateTemplate) DCNL def update(self, req, id, body):
def _format_quota_set(self, project_id, quota_set):
@wsgi.serializers(xml=BackupTemplate) DCNL def show(self, req, id):
def delete(self, req, id):
@wsgi.serializers(xml=BackupsTemplate) DCNL def index(self, req):
@wsgi.serializers(xml=BackupsTemplate) DCNL def detail(self, req):
def _get_backups(self, req, is_detail):
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupTemplate) DCNL @wsgi.deserializers(xml=CreateDeserializer) DCNL def create(self, req, body):
@wsgi.response(202) DCNL @wsgi.serializers(xml=BackupRestoreTemplate) DCNL @wsgi.deserializers(xml=RestoreDeserializer) DCNL def restore(self, req, id, body):
@wsgi.action('create') DCNL @wsgi.serializers(xml=types.ServiceManageTypeTemplate) DCNL def _create(self, req, body):
@wsgi.action('delete') DCNL def _delete(self, req, id):
@wsgi.action('os-attach') DCNL def _attach(self, req, id, body):
@wsgi.action('os-detach') DCNL def _detach(self, req, id, body):
@wsgi.action('os-reserve') DCNL def _reserve(self, req, id, body):
@wsgi.action('os-unreserve') DCNL def _unreserve(self, req, id, body):
@wsgi.action('os-begin_detaching') DCNL def _begin_detaching(self, req, id, body):
@wsgi.action('os-roll_detaching') DCNL def _roll_detaching(self, req, id, body):
@wsgi.action('os-initialize_connection') DCNL def _initialize_connection(self, req, id, body):
@wsgi.action('os-terminate_connection') DCNL def _terminate_connection(self, req, id, body):
@wsgi.response(202) DCNL @wsgi.action('os-servicemanage_upload_image') DCNL @wsgi.serializers(xml=ServiceManageToImageSerializer) DCNL @wsgi.deserializers(xml=ServiceManageToImageDeserializer) DCNL def _servicemanage_upload_image(self, req, id, body):
@wsgi.action('os-reset_status') DCNL def _reset_status(self, req, id, body):
@wsgi.action('os-force_delete') DCNL def _force_delete(self, req, id, body):
@wsgi.action('os-force_detach') DCNL def _force_detach(self, req, id, body):
@wsgi.serializers(xml=VersionsTemplate, atom=VersionsAtomSerializer) DCNL def index(self, req):
@wsgi.serializers(xml=ChoicesTemplate) DCNL @wsgi.response(300) DCNL def multi(self, req):
def get_action_args(self, request_environment):
def save(self, session=None):
def delete(self, session=None):
def update(self, values):
def iteritems(self):
def get(self):
def __init__(self, retvalue=True):
def rollback_and_reraise(self, msg=None, **kwargs):
def __init__(self):
@staticmethod DCNL def run_server(server):
def launch_server(self, server):
def stop(self):
def wait(self):
def wait(self):
@classmethod DCNL def create(cls, host=None, binary=None, topic=None, manager=None, report_interval=None, periodic_interval=None, periodic_fuzzy_delay=None, service_name=None):
def kill(self):
def periodic_tasks(self, raise_on_error=False):
def report_state(self):
def __init__(self, name, loader=None):
def _get_manager(self):
def start(self):
def stop(self):
def wait(self):
def format(self, record):
def formatException(self, exc_info, record=None):
def __init__(self, topic, default_version):
def _set_version(self, msg, vers):
def _get_topic(self, topic):
def call(self, context, msg, topic=None, version=None, timeout=None):
def multicall(self, context, msg, topic=None, version=None, timeout=None):
def cast(self, context, msg, topic=None, version=None):
def fanout_cast(self, context, msg, topic=None, version=None):
def cast_to_server(self, context, server_params, msg, topic=None, version=None):
def fanout_cast_to_server(self, context, server_params, msg, topic=None, version=None):
def __init__(self, conf, connection_pool, pooled=True, server_params=None):
def __enter__(self):
def _done(self):
def __exit__(self, exc_type, exc_value, tb):
def __del__(self):
def close(self):
def __getattr__(self, key):
def check_duplicate_message(self, message_data):
def wait(self):
def __init__(self, conf, callback, connection_pool):
def __call__(self, message_data):
def _process_data(self, ctxt, version, method, args):
def __iter__(self):
def __call__(self, data):
def __iter__(self):
def __init__(self, callbacks):
def dispatch(self, ctxt, version, method, **kwargs):
def register(self, key, host):
def ack_alive(self, key, host):
def is_alive(self, topic, host):
def expire(self, topic, host):
def send_heartbeats(self):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def send_heartbeats(self):
def ack_alive(self, key, host):
def backend_register(self, key, host):
def backend_unregister(self, key, key_host):
def register(self, key, host):
def unregister(self, key, host):
def start_heartbeat(self):
def stop_heartbeat(self):
def __init__(self, session, callback, node_name, node_opts, link_name, link_opts):
def reconnect(self, session):
def consume(self):
def __init__(self, conf, session, msg_id, callback):
def __init__(self, conf, session, topic, callback, name=None, exchange_name=None):
def __init__(self, conf, session, topic, callback):
def __init__(self, session, node_name, node_opts=None):
def reconnect(self, session):
def send(self, msg):
def __init__(self, conf, session, msg_id):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def __init__(self, conf, session, topic):
def reconnect(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
def socket_s(self):
def subscribe(self, msg_filter):
def unsubscribe(self, msg_filter):
def _get_response(self, ctx, proxy, topic, data):
def reply(self, ctx, proxy, msg_id=None, context=None, topic=None, msg=None):
def consume_in_thread(self):
def close(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name):
def consume_in_thread(self):
def elevated(self, read_deleted=None, overwrite=False):
def __init__(self, channel, callback, tag, **kwargs):
def reconnect(self, channel):
def consume(self, *args, **kwargs):
def cancel(self):
def __init__(self, conf, channel, msg_id, callback, tag, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, name=None, exchange_name=None, **kwargs):
def __init__(self, conf, channel, topic, callback, tag, **kwargs):
def __init__(self, channel, exchange_name, routing_key, **kwargs):
def reconnect(self, channel):
def send(self, msg, timeout=None):
def __init__(self, conf, channel, msg_id, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def __init__(self, conf, channel, topic, **kwargs):
def _fetch_ssl_params(self):
def _connect(self, params):
def reconnect(self):
def get_channel(self):
def close(self):
def reset(self):
def declare_consumer(self, consumer_cls, topic, callback):
def iterconsume(self, limit=None, timeout=None):
def cancel_consumer_thread(self):
def wait_on_proxy_callbacks(self):
def publisher_send(self, cls, topic, msg, timeout=None, **kwargs):
def declare_direct_consumer(self, topic, callback):
def declare_topic_consumer(self, topic, callback=None, queue_name=None, exchange_name=None):
def declare_fanout_consumer(self, topic, callback):
def direct_send(self, msg_id, msg):
def topic_send(self, topic, msg, timeout=None):
def fanout_send(self, topic, msg):
def notify_send(self, topic, msg, **kwargs):
def consume(self, limit=None):
def consume_in_thread(self):
def create_consumer(self, topic, proxy, fanout=False):
def create_worker(self, topic, proxy, pool_name):
def join_consumer_pool(self, callback, pool_name, topic, exchange_name=None):
@classmethod DCNL def load_json(cls, data, default_rule=None):
def check(self, match_list, target_dict, cred_dict):
def __init__(self, package):
def __str__(self):
def __repr__(self):
def _get_version_from_pkg_resources(self):
def release_string(self):
def version_string(self):
def cached_version_string(self, prefix=''):
def _weight_multiplier(self):
def _weigh_object(self, obj, weight_properties):
def weigh_objects(self, weighed_obj_list, weight_properties):
def _is_correct_class(self, obj):
def get_weighed_objects(self, weigher_classes, obj_list, weighing_properties):
def _filter_one(self, obj, filter_properties):
def host_passes(self, host_state, filter_properties):
def _satisfies_extra_specs(self, capabilities, resource_type):
def host_passes(self, host_state, filter_properties):
def _op_compare(self, args, op):
def _equals(self, args):
def _less_than(self, args):
def _greater_than(self, args):
def _in(self, args):
def _less_than_equal(self, args):
def _greater_than_equal(self, args):
def _not(self, args):
def _or(self, args):
def _and(self, args):
def _parse_string(self, string, host_state):
def _process_filter(self, query, host_state):
def host_passes(self, host_state, filter_properties):
def _filter_one(self, obj, filter_properties):
def filter_all(self, filter_obj_list, filter_properties):
def _is_correct_class(self, obj):
def get_exec(self, exec_dirs=[]):
def match(self, userargs):
def get_command(self, userargs, exec_dirs=[]):
def get_environment(self, userargs):
def __init__(cls, names, bases, dict_):
def create_rpc_dispatcher(self):
def periodic_tasks(self, context, raise_on_error=False):
def init_host(self):
def get_by_project(self, context, project_id, resource):
def get_by_class(self, context, quota_class, resource):
def get_defaults(self, context, resources):
def get_class_quotas(self, context, resources, quota_class, defaults=True):
def get_project_quotas(self, context, resources, project_id, quota_class=None, defaults=True, usages=True):
def _get_quotas(self, context, resources, keys, has_sync, project_id=None):
def limit_check(self, context, resources, values, project_id=None):
def reserve(self, context, resources, deltas, expire=None, project_id=None):
def commit(self, context, reservations, project_id=None):
def rollback(self, context, reservations, project_id=None):
def destroy_all_by_project(self, context, project_id):
def expire(self, context):
def __init__(self, name, flag=None):
def quota(self, driver, context, **kwargs):
@property DCNL def default(self):
def __init__(self, name, sync, flag=None):
def __init__(self, name, count, flag=None):
def __init__(self, quota_driver_class=None):
def register_resource(self, resource):
def register_resources(self, resources):
def get_by_project(self, context, project_id, resource):
def get_by_class(self, context, quota_class, resource):
def get_defaults(self, context):
def get_class_quotas(self, context, quota_class, defaults=True):
def get_project_quotas(self, context, project_id, quota_class=None, defaults=True, usages=True):
def count(self, context, resource, *args, **kwargs):
def limit_check(self, context, project_id=None, **values):
def reserve(self, context, expire=None, project_id=None, **deltas):
def commit(self, context, reservations, project_id=None):
def rollback(self, context, reservations, project_id=None):
def destroy_all_by_project(self, context, project_id):
def expire(self, context):
def __init__(self, name, app, host=None, port=None, pool_size=None, protocol=eventlet.wsgi.HttpProtocol):
def _start(self):
def start(self, backlog=128):
def stop(self):
def wait(self):
@classmethod DCNL def factory(cls, global_config, **local_config):
def __call__(self, environ, start_response):
@classmethod DCNL def factory(cls, global_config, **local_config):
def process_request(self, req):
def process_response(self, response):
@staticmethod DCNL def print_generator(app_iter):
def __init__(self, mapper):
@webob.dec.wsgify(RequestClass=Request) DCNL def __call__(self, req):
@staticmethod DCNL @webob.dec.wsgify(RequestClass=Request) DCNL def _dispatch(req):
def __init__(self, config_path=None):
def load_app(self, name):
def __init__(self, user_id, project_id, is_admin=None, read_deleted='no', roles=None, remote_address=None, timestamp=None, request_id=None, auth_token=None, overwrite=True, quota_class=None, **kwargs):
def elevated(self, read_deleted=None, overwrite=False):
